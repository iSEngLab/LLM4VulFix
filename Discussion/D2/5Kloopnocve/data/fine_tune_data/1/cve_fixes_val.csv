,source,target
0,"static ssize_t aio_setup_single_vector ( struct kiocb * kiocb , int rw , char __user * buf , unsigned long * nr_segs , size_t len , <S2SV_StartBug> struct iovec * iovec ) <S2SV_EndBug> { if ( unlikely ( ! access_ok ( ! rw , buf , len ) ) ) return - EFAULT ; iovec -> iov_base = buf ; iovec -> iov_len = len ; * nr_segs = 1 ; <S2SV_StartBug> return 0 ; <S2SV_EndBug> }","iovec * iovec , struct iov_iter * iter ) { if ( len > MAX_RW_COUNT ) len = MAX_RW_COUNT ; <S2SV_ModEnd> if ( unlikely <S2SV_ModStart> = 1 ; iov_iter_init ( iter , rw , iovec , * nr_segs , len ) ;"
1,"static struct task_struct * copy_process ( unsigned long clone_flags , unsigned long stack_start , unsigned long stack_size , int __user * child_tidptr , struct pid * pid , int trace ) { int retval ; struct task_struct * p ; if ( ( clone_flags & ( CLONE_NEWNS | CLONE_FS ) ) == ( CLONE_NEWNS | CLONE_FS ) ) return ERR_PTR ( - EINVAL ) ; <S2SV_StartBug> if ( ( clone_flags & CLONE_THREAD ) && ! ( clone_flags & CLONE_SIGHAND ) ) <S2SV_EndBug> return ERR_PTR ( - EINVAL ) ; if ( ( clone_flags & CLONE_SIGHAND ) && ! ( clone_flags & CLONE_VM ) ) return ERR_PTR ( - EINVAL ) ; if ( ( clone_flags & CLONE_PARENT ) && current -> signal -> flags & SIGNAL_UNKILLABLE ) return ERR_PTR ( - EINVAL ) ; if ( ( clone_flags & ( CLONE_VM | CLONE_NEWPID ) ) && ( task_active_pid_ns ( current ) != current -> nsproxy -> pid_ns ) ) return ERR_PTR ( - EINVAL ) ; retval = security_task_create ( clone_flags ) ; if ( retval ) goto fork_out ; retval = - ENOMEM ; p = dup_task_struct ( current ) ; if ( ! p ) goto fork_out ; ftrace_graph_init_task ( p ) ; get_seccomp_filter ( p ) ; rt_mutex_init_task ( p ) ; # ifdef CONFIG_PROVE_LOCKING DEBUG_LOCKS_WARN_ON ( ! p -> hardirqs_enabled ) ; DEBUG_LOCKS_WARN_ON ( ! p -> softirqs_enabled ) ; # endif retval = - EAGAIN ; if ( atomic_read ( & p -> real_cred -> user -> processes ) >= task_rlimit ( p , RLIMIT_NPROC ) ) { if ( ! capable ( CAP_SYS_ADMIN ) && ! capable ( CAP_SYS_RESOURCE ) && p -> real_cred -> user != INIT_USER ) goto bad_fork_free ; } current -> flags &= ~ PF_NPROC_EXCEEDED ; retval = copy_creds ( p , clone_flags ) ; if ( retval < 0 ) goto bad_fork_free ; retval = - EAGAIN ; if ( nr_threads >= max_threads ) goto bad_fork_cleanup_count ; if ( ! try_module_get ( task_thread_info ( p ) -> exec_domain -> module ) ) goto bad_fork_cleanup_count ; p -> did_exec = 0 ; delayacct_tsk_init ( p ) ; copy_flags ( clone_flags , p ) ; INIT_LIST_HEAD ( & p -> children ) ; INIT_LIST_HEAD ( & p -> sibling ) ; rcu_copy_process ( p ) ; p -> vfork_done = NULL ; spin_lock_init ( & p -> alloc_lock ) ; init_sigpending ( & p -> pending ) ; p -> utime = p -> stime = p -> gtime = 0 ; p -> utimescaled = p -> stimescaled = 0 ; # ifndef CONFIG_VIRT_CPU_ACCOUNTING p -> prev_cputime . utime = p -> prev_cputime . stime = 0 ; # endif # ifdef CONFIG_VIRT_CPU_ACCOUNTING_GEN seqlock_init ( & p -> vtime_seqlock ) ; p -> vtime_snap = 0 ; p -> vtime_snap_whence = VTIME_SLEEPING ; # endif # if defined ( SPLIT_RSS_COUNTING ) memset ( & p -> rss_stat , 0 , sizeof ( p -> rss_stat ) ) ; # endif p -> default_timer_slack_ns = current -> timer_slack_ns ; task_io_accounting_init ( & p -> ioac ) ; acct_clear_integrals ( p ) ; posix_cpu_timers_init ( p ) ; do_posix_clock_monotonic_gettime ( & p -> start_time ) ; p -> real_start_time = p -> start_time ; monotonic_to_bootbased ( & p -> real_start_time ) ; p -> io_context = NULL ; p -> audit_context = NULL ; if ( clone_flags & CLONE_THREAD ) threadgroup_change_begin ( current ) ; cgroup_fork ( p ) ; # ifdef CONFIG_NUMA p -> mempolicy = mpol_dup ( p -> mempolicy ) ; if ( IS_ERR ( p -> mempolicy ) ) { retval = PTR_ERR ( p -> mempolicy ) ; p -> mempolicy = NULL ; goto bad_fork_cleanup_cgroup ; } mpol_fix_fork_child_flag ( p ) ; # endif # ifdef CONFIG_CPUSETS p -> cpuset_mem_spread_rotor = NUMA_NO_NODE ; p -> cpuset_slab_spread_rotor = NUMA_NO_NODE ; seqcount_init ( & p -> mems_allowed_seq ) ; # endif # ifdef CONFIG_TRACE_IRQFLAGS p -> irq_events = 0 ; p -> hardirqs_enabled = 0 ; p -> hardirq_enable_ip = 0 ; p -> hardirq_enable_event = 0 ; p -> hardirq_disable_ip = _THIS_IP_ ; p -> hardirq_disable_event = 0 ; p -> softirqs_enabled = 1 ; p -> softirq_enable_ip = _THIS_IP_ ; p -> softirq_enable_event = 0 ; p -> softirq_disable_ip = 0 ; p -> softirq_disable_event = 0 ; p -> hardirq_context = 0 ; p -> softirq_context = 0 ; # endif # ifdef CONFIG_LOCKDEP p -> lockdep_depth = 0 ; p -> curr_chain_key = 0 ; p -> lockdep_recursion = 0 ; # endif # ifdef CONFIG_DEBUG_MUTEXES p -> blocked_on = NULL ; # endif # ifdef CONFIG_MEMCG p -> memcg_batch . do_batch = 0 ; p -> memcg_batch . memcg = NULL ; # endif sched_fork ( p ) ; retval = perf_event_init_task ( p ) ; if ( retval ) goto bad_fork_cleanup_policy ; retval = audit_alloc ( p ) ; if ( retval ) goto bad_fork_cleanup_policy ; retval = copy_semundo ( clone_flags , p ) ; if ( retval ) goto bad_fork_cleanup_audit ; retval = copy_files ( clone_flags , p ) ; if ( retval ) goto bad_fork_cleanup_semundo ; retval = copy_fs ( clone_flags , p ) ; if ( retval ) goto bad_fork_cleanup_files ; retval = copy_sighand ( clone_flags , p ) ; if ( retval ) goto bad_fork_cleanup_fs ; retval = copy_signal ( clone_flags , p ) ; if ( retval ) goto bad_fork_cleanup_sighand ; retval = copy_mm ( clone_flags , p ) ; if ( retval ) goto bad_fork_cleanup_signal ; retval = copy_namespaces ( clone_flags , p ) ; if ( retval ) goto bad_fork_cleanup_mm ; retval = copy_io ( clone_flags , p ) ; if ( retval ) goto bad_fork_cleanup_namespaces ; retval = copy_thread ( clone_flags , stack_start , stack_size , p ) ; if ( retval ) goto bad_fork_cleanup_io ; if ( pid != & init_struct_pid ) { retval = - ENOMEM ; pid = alloc_pid ( p -> nsproxy -> pid_ns ) ; if ( ! pid ) goto bad_fork_cleanup_io ; } p -> pid = pid_nr ( pid ) ; p -> tgid = p -> pid ; if ( clone_flags & CLONE_THREAD ) p -> tgid = current -> tgid ; p -> set_child_tid = ( clone_flags & CLONE_CHILD_SETTID ) ? child_tidptr : NULL ; p -> clear_child_tid = ( clone_flags & CLONE_CHILD_CLEARTID ) ? child_tidptr : NULL ; # ifdef CONFIG_BLOCK p -> plug = NULL ; # endif # ifdef CONFIG_FUTEX p -> robust_list = NULL ; # ifdef CONFIG_COMPAT p -> compat_robust_list = NULL ; # endif INIT_LIST_HEAD ( & p -> pi_state_list ) ; p -> pi_state_cache = NULL ; # endif uprobe_copy_process ( p ) ; if ( ( clone_flags & ( CLONE_VM | CLONE_VFORK ) ) == CLONE_VM ) p -> sas_ss_sp = p -> sas_ss_size = 0 ; user_disable_single_step ( p ) ; clear_tsk_thread_flag ( p , TIF_SYSCALL_TRACE ) ; # ifdef TIF_SYSCALL_EMU clear_tsk_thread_flag ( p , TIF_SYSCALL_EMU ) ; # endif clear_all_latency_tracing ( p ) ; if ( clone_flags & CLONE_THREAD ) p -> exit_signal = - 1 ; else if ( clone_flags & CLONE_PARENT ) p -> exit_signal = current -> group_leader -> exit_signal ; else p -> exit_signal = ( clone_flags & CSIGNAL ) ; p -> pdeath_signal = 0 ; p -> exit_state = 0 ; p -> nr_dirtied = 0 ; p -> nr_dirtied_pause = 128 >> ( PAGE_SHIFT - 10 ) ; p -> dirty_paused_when = 0 ; p -> group_leader = p ; INIT_LIST_HEAD ( & p -> thread_group ) ; p -> task_works = NULL ; write_lock_irq ( & tasklist_lock ) ; if ( clone_flags & ( CLONE_PARENT | CLONE_THREAD ) ) { p -> real_parent = current -> real_parent ; p -> parent_exec_id = current -> parent_exec_id ; } else { p -> real_parent = current ; p -> parent_exec_id = current -> self_exec_id ; } spin_lock ( & current -> sighand -> siglock ) ; recalc_sigpending ( ) ; if ( signal_pending ( current ) ) { spin_unlock ( & current -> sighand -> siglock ) ; write_unlock_irq ( & tasklist_lock ) ; retval = - ERESTARTNOINTR ; goto bad_fork_free_pid ; } if ( clone_flags & CLONE_THREAD ) { current -> signal -> nr_threads ++ ; atomic_inc ( & current -> signal -> live ) ; atomic_inc ( & current -> signal -> sigcnt ) ; p -> group_leader = current -> group_leader ; list_add_tail_rcu ( & p -> thread_group , & p -> group_leader -> thread_group ) ; } if ( likely ( p -> pid ) ) { ptrace_init_task ( p , ( clone_flags & CLONE_PTRACE ) || trace ) ; if ( thread_group_leader ( p ) ) { if ( is_child_reaper ( pid ) ) { ns_of_pid ( pid ) -> child_reaper = p ; p -> signal -> flags |= SIGNAL_UNKILLABLE ; } p -> signal -> leader_pid = pid ; p -> signal -> tty = tty_kref_get ( current -> signal -> tty ) ; attach_pid ( p , PIDTYPE_PGID , task_pgrp ( current ) ) ; attach_pid ( p , PIDTYPE_SID , task_session ( current ) ) ; list_add_tail ( & p -> sibling , & p -> real_parent -> children ) ; list_add_tail_rcu ( & p -> tasks , & init_task . tasks ) ; __this_cpu_inc ( process_counts ) ; } attach_pid ( p , PIDTYPE_PID , pid ) ; nr_threads ++ ; } total_forks ++ ; spin_unlock ( & current -> sighand -> siglock ) ; write_unlock_irq ( & tasklist_lock ) ; proc_fork_connector ( p ) ; cgroup_post_fork ( p ) ; if ( clone_flags & CLONE_THREAD ) threadgroup_change_end ( current ) ; perf_event_fork ( p ) ; trace_task_newtask ( p , clone_flags ) ; return p ; bad_fork_free_pid : if ( pid != & init_struct_pid ) free_pid ( pid ) ; bad_fork_cleanup_io : if ( p -> io_context ) exit_io_context ( p ) ; bad_fork_cleanup_namespaces : exit_task_namespaces ( p ) ; bad_fork_cleanup_mm : if ( p -> mm ) mmput ( p -> mm ) ; bad_fork_cleanup_signal : if ( ! ( clone_flags & CLONE_THREAD ) ) free_signal_struct ( p -> signal ) ; bad_fork_cleanup_sighand : __cleanup_sighand ( p -> sighand ) ; bad_fork_cleanup_fs : exit_fs ( p ) ; bad_fork_cleanup_files : exit_files ( p ) ; bad_fork_cleanup_semundo : exit_sem ( p ) ; bad_fork_cleanup_audit : audit_free ( p ) ; bad_fork_cleanup_policy : perf_event_free_task ( p ) ; # ifdef CONFIG_NUMA mpol_put ( p -> mempolicy ) ; bad_fork_cleanup_cgroup : # endif if ( clone_flags & CLONE_THREAD ) threadgroup_change_end ( current ) ; cgroup_exit ( p , 0 ) ; delayacct_tsk_free ( p ) ; module_put ( task_thread_info ( p ) -> exec_domain -> module ) ; bad_fork_cleanup_count : atomic_dec ( & p -> cred -> user -> processes ) ; exit_creds ( p ) ; bad_fork_free : free_task ( p ) ; fork_out : return ERR_PTR ( retval ) ; }",( clone_flags & ( CLONE_NEWUSER | CLONE_FS ) ) == ( CLONE_NEWUSER | CLONE_FS ) ) return ERR_PTR ( - EINVAL ) ; if ( ( clone_flags &
2,"<S2SV_StartBug> void ntlm_print_negotiate_flags ( UINT32 flags ) <S2SV_EndBug> { int i ; const char * str ; WLog_INFO ( TAG , ""negotiateFlags<S2SV_blank>\\""0x%08"" PRIX32 ""\\"""" , flags ) ; for ( i = 31 ; i >= 0 ; i -- ) { if ( ( flags >> i ) & 1 ) { str = NTLM_NEGOTIATE_STRINGS [ ( 31 - i ) ] ; WLog_INFO ( TAG , ""\\t%s<S2SV_blank>(%d),"" , str , ( 31 - i ) ) ; } } }",<S2SV_null> <S2SV_null> <S2SV_null> static
3,"static void write_version ( FILE * fp , const char * fname , const char * dirname , xref_t * xref ) { long start ; char * c , * new_fname , data ; FILE * new_fp ; start = ftell ( fp ) ; if ( ( c = strstr ( fname , "".pdf"" ) ) ) * c = '\\0' ; <S2SV_StartBug> new_fname = malloc ( strlen ( fname ) + strlen ( dirname ) + 16 ) ; <S2SV_EndBug> snprintf ( new_fname , strlen ( fname ) + strlen ( dirname ) + 16 , ""%s/%s-version-%d.pdf"" , dirname , fname , xref -> version ) ; if ( ! ( new_fp = fopen ( new_fname , ""w"" ) ) ) { ERR ( ""Could<S2SV_blank>not<S2SV_blank>create<S2SV_blank>file<S2SV_blank>\'%s\'\\n"" , new_fname ) ; fseek ( fp , start , SEEK_SET ) ; free ( new_fname ) ; return ; } fseek ( fp , 0 , SEEK_SET ) ; while ( fread ( & data , 1 , 1 , fp ) ) fwrite ( & data , 1 , 1 , new_fp ) ; fprintf ( new_fp , ""\\r\\nstartxref\\r\\n%ld\\r\\n%%%%EOF"" , xref -> start ) ; fclose ( new_fp ) ; free ( new_fname ) ; fseek ( fp , start , SEEK_SET ) ; }",; new_fname = safe_calloc <S2SV_ModEnd> ( strlen (
4,"PHPAPI int php_var_unserialize ( UNSERIALIZE_PARAMETER ) { const unsigned char * cursor , * limit , * marker , * start ; zval * * rval_ref ; limit = max ; cursor = * p ; if ( YYCURSOR >= YYLIMIT ) { return 0 ; } if ( var_hash && cursor [ 0 ] != 'R' ) { var_push ( var_hash , rval ) ; } start = cursor ; <S2SV_StartBug> # line 496 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> { YYCTYPE yych ; static const unsigned char yybm [ ] = { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 128 , 128 , 128 , 128 , 128 , 128 , 128 , 128 , 128 , 128 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , } ; if ( ( YYLIMIT - YYCURSOR ) < 7 ) YYFILL ( 7 ) ; yych = * YYCURSOR ; switch ( yych ) { case 'C' : case 'O' : goto yy13 ; case 'N' : goto yy5 ; case 'R' : goto yy2 ; case 'S' : goto yy10 ; case 'a' : goto yy11 ; case 'b' : goto yy6 ; case 'd' : goto yy8 ; case 'i' : goto yy7 ; case 'o' : goto yy12 ; case 'r' : goto yy4 ; case 's' : goto yy9 ; case '}' : goto yy14 ; default : goto yy16 ; } yy2 : yych = * ( YYMARKER = ++ YYCURSOR ) ; if ( yych == ':' ) goto yy95 ; yy3 : <S2SV_StartBug> # line 861 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> { return 0 ; } <S2SV_StartBug> # line 558 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> yy4 : yych = * ( YYMARKER = ++ YYCURSOR ) ; if ( yych == ':' ) goto yy89 ; goto yy3 ; yy5 : yych = * ++ YYCURSOR ; if ( yych == ';' ) goto yy87 ; goto yy3 ; yy6 : yych = * ( YYMARKER = ++ YYCURSOR ) ; if ( yych == ':' ) goto yy83 ; goto yy3 ; yy7 : yych = * ( YYMARKER = ++ YYCURSOR ) ; if ( yych == ':' ) goto yy77 ; goto yy3 ; yy8 : yych = * ( YYMARKER = ++ YYCURSOR ) ; if ( yych == ':' ) goto yy53 ; goto yy3 ; yy9 : yych = * ( YYMARKER = ++ YYCURSOR ) ; if ( yych == ':' ) goto yy46 ; goto yy3 ; yy10 : yych = * ( YYMARKER = ++ YYCURSOR ) ; if ( yych == ':' ) goto yy39 ; goto yy3 ; yy11 : yych = * ( YYMARKER = ++ YYCURSOR ) ; if ( yych == ':' ) goto yy32 ; goto yy3 ; yy12 : yych = * ( YYMARKER = ++ YYCURSOR ) ; if ( yych == ':' ) goto yy25 ; goto yy3 ; yy13 : yych = * ( YYMARKER = ++ YYCURSOR ) ; if ( yych == ':' ) goto yy17 ; goto yy3 ; yy14 : ++ YYCURSOR ; <S2SV_StartBug> # line 855 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> { php_error_docref ( NULL TSRMLS_CC , E_NOTICE , ""Unexpected<S2SV_blank>end<S2SV_blank>of<S2SV_blank>serialized<S2SV_blank>data"" ) ; return 0 ; } <S2SV_StartBug> # line 607 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> yy16 : yych = * ++ YYCURSOR ; goto yy3 ; yy17 : yych = * ++ YYCURSOR ; if ( yybm [ 0 + yych ] & 128 ) { goto yy20 ; } if ( yych == '+' ) goto yy19 ; yy18 : YYCURSOR = YYMARKER ; goto yy3 ; yy19 : yych = * ++ YYCURSOR ; if ( yybm [ 0 + yych ] & 128 ) { goto yy20 ; } goto yy18 ; yy20 : ++ YYCURSOR ; if ( ( YYLIMIT - YYCURSOR ) < 2 ) YYFILL ( 2 ) ; yych = * YYCURSOR ; if ( yybm [ 0 + yych ] & 128 ) { goto yy20 ; } if ( yych <= '/' ) goto yy18 ; if ( yych >= ';' ) goto yy18 ; yych = * ++ YYCURSOR ; if ( yych != \'""\' ) goto yy18 ; ++ YYCURSOR ; <S2SV_StartBug> # line 708 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> { size_t len , len2 , len3 , maxlen ; long elements ; char * class_name ; zend_class_entry * ce ; zend_class_entry * * pce ; int incomplete_class = 0 ; int custom_object = 0 ; zval * user_func ; zval * retval_ptr ; zval * * args [ 1 ] ; zval * arg_func_name ; if ( ! var_hash ) return 0 ; if ( * start == 'C' ) { custom_object = 1 ; } INIT_PZVAL ( * rval ) ; len2 = len = parse_uiv ( start + 2 ) ; maxlen = max - YYCURSOR ; if ( maxlen < len || len == 0 ) { * p = start + 2 ; return 0 ; } class_name = ( char * ) YYCURSOR ; YYCURSOR += len ; if ( * ( YYCURSOR ) != \'""\' ) { * p = YYCURSOR ; return 0 ; } if ( * ( YYCURSOR + 1 ) != ':' ) { * p = YYCURSOR + 1 ; return 0 ; } len3 = strspn ( class_name , ""0123456789_abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\\177\\200\\201\\202\\203\\204\\205\\206\\207\\210\\211\\212\\213\\214\\215\\216\\217\\220\\221\\222\\223\\224\\225\\226\\227\\230\\231\\232\\233\\234\\235\\236\\237\\240\\241\\242\\243\\244\\245\\246\\247\\250\\251\\252\\253\\254\\255\\256\\257\\260\\261\\262\\263\\264\\265\\266\\267\\270\\271\\272\\273\\274\\275\\276\\277\\300\\301\\302\\303\\304\\305\\306\\307\\310\\311\\312\\313\\314\\315\\316\\317\\320\\321\\322\\323\\324\\325\\326\\327\\330\\331\\332\\333\\334\\335\\336\\337\\340\\341\\342\\343\\344\\345\\346\\347\\350\\351\\352\\353\\354\\355\\356\\357\\360\\361\\362\\363\\364\\365\\366\\367\\370\\371\\372\\373\\374\\375\\376\\377\\\\"" ) ; if ( len3 != len ) { * p = YYCURSOR + len3 - len ; return 0 ; } class_name = estrndup ( class_name , len ) ; do { BG ( serialize_lock ) ++ ; if ( zend_lookup_class ( class_name , len2 , & pce TSRMLS_CC ) == SUCCESS ) { BG ( serialize_lock ) -- ; if ( EG ( exception ) ) { efree ( class_name ) ; return 0 ; } ce = * pce ; break ; } BG ( serialize_lock ) -- ; if ( EG ( exception ) ) { efree ( class_name ) ; return 0 ; } if ( ( PG ( unserialize_callback_func ) == NULL ) || ( PG ( unserialize_callback_func ) [ 0 ] == '\\0' ) ) { incomplete_class = 1 ; ce = PHP_IC_ENTRY ; break ; } MAKE_STD_ZVAL ( user_func ) ; ZVAL_STRING ( user_func , PG ( unserialize_callback_func ) , 1 ) ; args [ 0 ] = & arg_func_name ; MAKE_STD_ZVAL ( arg_func_name ) ; ZVAL_STRING ( arg_func_name , class_name , 1 ) ; BG ( serialize_lock ) ++ ; if ( call_user_function_ex ( CG ( function_table ) , NULL , user_func , & retval_ptr , 1 , args , 0 , NULL TSRMLS_CC ) != SUCCESS ) { BG ( serialize_lock ) -- ; if ( EG ( exception ) ) { efree ( class_name ) ; zval_ptr_dtor ( & user_func ) ; zval_ptr_dtor ( & arg_func_name ) ; return 0 ; } php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""defined<S2SV_blank>(%s)<S2SV_blank>but<S2SV_blank>not<S2SV_blank>found"" , user_func -> value . str . val ) ; incomplete_class = 1 ; ce = PHP_IC_ENTRY ; zval_ptr_dtor ( & user_func ) ; zval_ptr_dtor ( & arg_func_name ) ; break ; } BG ( serialize_lock ) -- ; if ( retval_ptr ) { zval_ptr_dtor ( & retval_ptr ) ; } if ( EG ( exception ) ) { efree ( class_name ) ; zval_ptr_dtor ( & user_func ) ; zval_ptr_dtor ( & arg_func_name ) ; return 0 ; } if ( zend_lookup_class ( class_name , len2 , & pce TSRMLS_CC ) == SUCCESS ) { ce = * pce ; } else { php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Function<S2SV_blank>%s()<S2SV_blank>hasn\'t<S2SV_blank>defined<S2SV_blank>the<S2SV_blank>class<S2SV_blank>it<S2SV_blank>was<S2SV_blank>called<S2SV_blank>for"" , user_func -> value . str . val ) ; incomplete_class = 1 ; ce = PHP_IC_ENTRY ; } zval_ptr_dtor ( & user_func ) ; zval_ptr_dtor ( & arg_func_name ) ; break ; } while ( 1 ) ; * p = YYCURSOR ; if ( custom_object ) { int ret ; ret = object_custom ( UNSERIALIZE_PASSTHRU , ce ) ; if ( ret && incomplete_class ) { php_store_class_name ( * rval , class_name , len2 ) ; } efree ( class_name ) ; return ret ; } elements = object_common1 ( UNSERIALIZE_PASSTHRU , ce ) ; <S2SV_StartBug> if ( incomplete_class ) { <S2SV_EndBug> php_store_class_name ( * rval , class_name , len2 ) ; } efree ( class_name ) ; return object_common2 ( UNSERIALIZE_PASSTHRU , elements ) ; } <S2SV_StartBug> # line 785 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> yy25 : yych = * ++ YYCURSOR ; if ( yych <= ',' ) { if ( yych != '+' ) goto yy18 ; } else { if ( yych <= '-' ) goto yy26 ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy27 ; goto yy18 ; } yy26 : yych = * ++ YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych >= ':' ) goto yy18 ; yy27 : ++ YYCURSOR ; if ( ( YYLIMIT - YYCURSOR ) < 2 ) YYFILL ( 2 ) ; yych = * YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy27 ; if ( yych >= ';' ) goto yy18 ; yych = * ++ YYCURSOR ; if ( yych != \'""\' ) goto yy18 ; ++ YYCURSOR ; <S2SV_StartBug> # line 699 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> { if ( ! var_hash ) return 0 ; INIT_PZVAL ( * rval ) ; <S2SV_StartBug> return object_common2 ( UNSERIALIZE_PASSTHRU , <S2SV_EndBug> <S2SV_StartBug> object_common1 ( UNSERIALIZE_PASSTHRU , ZEND_STANDARD_CLASS_DEF_PTR ) ) ; <S2SV_EndBug> } <S2SV_StartBug> # line 819 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> yy32 : yych = * ++ YYCURSOR ; if ( yych == '+' ) goto yy33 ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy34 ; goto yy18 ; yy33 : yych = * ++ YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych >= ':' ) goto yy18 ; yy34 : ++ YYCURSOR ; if ( ( YYLIMIT - YYCURSOR ) < 2 ) YYFILL ( 2 ) ; yych = * YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy34 ; if ( yych >= ';' ) goto yy18 ; yych = * ++ YYCURSOR ; if ( yych != '{' ) goto yy18 ; ++ YYCURSOR ; <S2SV_StartBug> # line 678 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> { long elements = parse_iv ( start + 2 ) ; * p = YYCURSOR ; if ( ! var_hash ) return 0 ; if ( elements < 0 ) { return 0 ; } INIT_PZVAL ( * rval ) ; array_init_size ( * rval , elements ) ; if ( ! process_nested_data ( UNSERIALIZE_PASSTHRU , Z_ARRVAL_PP ( rval ) , elements , 0 ) ) { return 0 ; } return finish_nested_data ( UNSERIALIZE_PASSTHRU ) ; } <S2SV_StartBug> # line 861 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> yy39 : yych = * ++ YYCURSOR ; if ( yych == '+' ) goto yy40 ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy41 ; goto yy18 ; yy40 : yych = * ++ YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych >= ':' ) goto yy18 ; yy41 : ++ YYCURSOR ; if ( ( YYLIMIT - YYCURSOR ) < 2 ) YYFILL ( 2 ) ; yych = * YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy41 ; if ( yych >= ';' ) goto yy18 ; yych = * ++ YYCURSOR ; if ( yych != \'""\' ) goto yy18 ; ++ YYCURSOR ; <S2SV_StartBug> # line 643 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> { size_t len , maxlen ; char * str ; len = parse_uiv ( start + 2 ) ; maxlen = max - YYCURSOR ; if ( maxlen < len ) { * p = start + 2 ; return 0 ; } if ( ( str = unserialize_str ( & YYCURSOR , & len , maxlen ) ) == NULL ) { return 0 ; } if ( * ( YYCURSOR ) != \'""\' ) { efree ( str ) ; * p = YYCURSOR ; return 0 ; } if ( * ( YYCURSOR + 1 ) != ';' ) { efree ( str ) ; * p = YYCURSOR + 1 ; return 0 ; } YYCURSOR += 2 ; * p = YYCURSOR ; INIT_PZVAL ( * rval ) ; ZVAL_STRINGL ( * rval , str , len , 0 ) ; return 1 ; } <S2SV_StartBug> # line 917 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> yy46 : yych = * ++ YYCURSOR ; if ( yych == '+' ) goto yy47 ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy48 ; goto yy18 ; yy47 : yych = * ++ YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych >= ':' ) goto yy18 ; yy48 : ++ YYCURSOR ; if ( ( YYLIMIT - YYCURSOR ) < 2 ) YYFILL ( 2 ) ; yych = * YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy48 ; if ( yych >= ';' ) goto yy18 ; yych = * ++ YYCURSOR ; if ( yych != \'""\' ) goto yy18 ; ++ YYCURSOR ; <S2SV_StartBug> # line 610 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> { size_t len , maxlen ; char * str ; len = parse_uiv ( start + 2 ) ; maxlen = max - YYCURSOR ; if ( maxlen < len ) { * p = start + 2 ; return 0 ; } str = ( char * ) YYCURSOR ; YYCURSOR += len ; if ( * ( YYCURSOR ) != \'""\' ) { * p = YYCURSOR ; return 0 ; } if ( * ( YYCURSOR + 1 ) != ';' ) { * p = YYCURSOR + 1 ; return 0 ; } YYCURSOR += 2 ; * p = YYCURSOR ; INIT_PZVAL ( * rval ) ; ZVAL_STRINGL ( * rval , str , len , 1 ) ; return 1 ; } <S2SV_StartBug> # line 971 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> yy53 : yych = * ++ YYCURSOR ; if ( yych <= '/' ) { if ( yych <= ',' ) { if ( yych == '+' ) goto yy57 ; goto yy18 ; } else { if ( yych <= '-' ) goto yy55 ; if ( yych <= '.' ) goto yy60 ; goto yy18 ; } } else { if ( yych <= 'I' ) { if ( yych <= '9' ) goto yy58 ; if ( yych <= 'H' ) goto yy18 ; goto yy56 ; } else { if ( yych != 'N' ) goto yy18 ; } } yych = * ++ YYCURSOR ; if ( yych == 'A' ) goto yy76 ; goto yy18 ; yy55 : yych = * ++ YYCURSOR ; if ( yych <= '/' ) { if ( yych == '.' ) goto yy60 ; goto yy18 ; } else { if ( yych <= '9' ) goto yy58 ; if ( yych != 'I' ) goto yy18 ; } yy56 : yych = * ++ YYCURSOR ; if ( yych == 'N' ) goto yy72 ; goto yy18 ; yy57 : yych = * ++ YYCURSOR ; if ( yych == '.' ) goto yy60 ; if ( yych <= '/' ) goto yy18 ; if ( yych >= ':' ) goto yy18 ; yy58 : ++ YYCURSOR ; if ( ( YYLIMIT - YYCURSOR ) < 4 ) YYFILL ( 4 ) ; yych = * YYCURSOR ; if ( yych <= ':' ) { if ( yych <= '.' ) { if ( yych <= '-' ) goto yy18 ; goto yy70 ; } else { if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy58 ; goto yy18 ; } } else { if ( yych <= 'E' ) { if ( yych <= ';' ) goto yy63 ; if ( yych <= 'D' ) goto yy18 ; goto yy65 ; } else { if ( yych == 'e' ) goto yy65 ; goto yy18 ; } } yy60 : yych = * ++ YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych >= ':' ) goto yy18 ; yy61 : ++ YYCURSOR ; if ( ( YYLIMIT - YYCURSOR ) < 4 ) YYFILL ( 4 ) ; yych = * YYCURSOR ; if ( yych <= ';' ) { if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy61 ; if ( yych <= ':' ) goto yy18 ; } else { if ( yych <= 'E' ) { if ( yych <= 'D' ) goto yy18 ; goto yy65 ; } else { if ( yych == 'e' ) goto yy65 ; goto yy18 ; } } yy63 : ++ YYCURSOR ; <S2SV_StartBug> # line 600 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> { # if SIZEOF_LONG == 4 use_double : # endif * p = YYCURSOR ; INIT_PZVAL ( * rval ) ; ZVAL_DOUBLE ( * rval , zend_strtod ( ( const char * ) start + 2 , NULL ) ) ; return 1 ; } <S2SV_StartBug> # line 1069 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> yy65 : yych = * ++ YYCURSOR ; if ( yych <= ',' ) { if ( yych != '+' ) goto yy18 ; } else { if ( yych <= '-' ) goto yy66 ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy67 ; goto yy18 ; } yy66 : yych = * ++ YYCURSOR ; if ( yych <= ',' ) { if ( yych == '+' ) goto yy69 ; goto yy18 ; } else { if ( yych <= '-' ) goto yy69 ; if ( yych <= '/' ) goto yy18 ; if ( yych >= ':' ) goto yy18 ; } yy67 : ++ YYCURSOR ; if ( YYLIMIT <= YYCURSOR ) YYFILL ( 1 ) ; yych = * YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy67 ; if ( yych == ';' ) goto yy63 ; goto yy18 ; yy69 : yych = * ++ YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy67 ; goto yy18 ; yy70 : ++ YYCURSOR ; if ( ( YYLIMIT - YYCURSOR ) < 4 ) YYFILL ( 4 ) ; yych = * YYCURSOR ; if ( yych <= ';' ) { if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy70 ; if ( yych <= ':' ) goto yy18 ; goto yy63 ; } else { if ( yych <= 'E' ) { if ( yych <= 'D' ) goto yy18 ; goto yy65 ; } else { if ( yych == 'e' ) goto yy65 ; goto yy18 ; } } yy72 : yych = * ++ YYCURSOR ; if ( yych != 'F' ) goto yy18 ; yy73 : yych = * ++ YYCURSOR ; if ( yych != ';' ) goto yy18 ; ++ YYCURSOR ; <S2SV_StartBug> # line 585 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> { * p = YYCURSOR ; INIT_PZVAL ( * rval ) ; if ( ! strncmp ( start + 2 , ""NAN"" , 3 ) ) { ZVAL_DOUBLE ( * rval , php_get_nan ( ) ) ; } else if ( ! strncmp ( start + 2 , ""INF"" , 3 ) ) { ZVAL_DOUBLE ( * rval , php_get_inf ( ) ) ; } else if ( ! strncmp ( start + 2 , ""-INF"" , 4 ) ) { ZVAL_DOUBLE ( * rval , - php_get_inf ( ) ) ; } return 1 ; } <S2SV_StartBug> # line 1143 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> yy76 : yych = * ++ YYCURSOR ; if ( yych == 'N' ) goto yy73 ; goto yy18 ; yy77 : yych = * ++ YYCURSOR ; if ( yych <= ',' ) { if ( yych != '+' ) goto yy18 ; } else { if ( yych <= '-' ) goto yy78 ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy79 ; goto yy18 ; } yy78 : yych = * ++ YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych >= ':' ) goto yy18 ; yy79 : ++ YYCURSOR ; if ( YYLIMIT <= YYCURSOR ) YYFILL ( 1 ) ; yych = * YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy79 ; if ( yych != ';' ) goto yy18 ; ++ YYCURSOR ; <S2SV_StartBug> # line 558 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> { # if SIZEOF_LONG == 4 int digits = YYCURSOR - start - 3 ; if ( start [ 2 ] == '-' || start [ 2 ] == '+' ) { digits -- ; } if ( digits >= MAX_LENGTH_OF_LONG - 1 ) { if ( digits == MAX_LENGTH_OF_LONG - 1 ) { int cmp = strncmp ( YYCURSOR - MAX_LENGTH_OF_LONG , long_min_digits , MAX_LENGTH_OF_LONG - 1 ) ; if ( ! ( cmp < 0 || ( cmp == 0 && start [ 2 ] == '-' ) ) ) { goto use_double ; } } else { goto use_double ; } } # endif * p = YYCURSOR ; INIT_PZVAL ( * rval ) ; ZVAL_LONG ( * rval , parse_iv ( start + 2 ) ) ; return 1 ; } <S2SV_StartBug> # line 1197 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> yy83 : yych = * ++ YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych >= '2' ) goto yy18 ; yych = * ++ YYCURSOR ; if ( yych != ';' ) goto yy18 ; ++ YYCURSOR ; <S2SV_StartBug> # line 551 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> { * p = YYCURSOR ; INIT_PZVAL ( * rval ) ; ZVAL_BOOL ( * rval , parse_iv ( start + 2 ) ) ; return 1 ; } <S2SV_StartBug> # line 1212 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> yy87 : ++ YYCURSOR ; <S2SV_StartBug> # line 544 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> { * p = YYCURSOR ; INIT_PZVAL ( * rval ) ; ZVAL_NULL ( * rval ) ; return 1 ; } <S2SV_StartBug> # line 1222 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> yy89 : yych = * ++ YYCURSOR ; if ( yych <= ',' ) { if ( yych != '+' ) goto yy18 ; } else { if ( yych <= '-' ) goto yy90 ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy91 ; goto yy18 ; } yy90 : yych = * ++ YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych >= ':' ) goto yy18 ; yy91 : ++ YYCURSOR ; if ( YYLIMIT <= YYCURSOR ) YYFILL ( 1 ) ; yych = * YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy91 ; if ( yych != ';' ) goto yy18 ; ++ YYCURSOR ; <S2SV_StartBug> # line 521 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> { long id ; * p = YYCURSOR ; if ( ! var_hash ) return 0 ; id = parse_iv ( start + 2 ) - 1 ; if ( id == - 1 || var_access ( var_hash , id , & rval_ref ) != SUCCESS ) { return 0 ; } if ( * rval == * rval_ref ) return 0 ; if ( * rval != NULL ) { var_push_dtor_no_addref ( var_hash , rval ) ; } * rval = * rval_ref ; Z_ADDREF_PP ( rval ) ; Z_UNSET_ISREF_PP ( rval ) ; return 1 ; } <S2SV_StartBug> # line 1268 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> yy95 : yych = * ++ YYCURSOR ; if ( yych <= ',' ) { if ( yych != '+' ) goto yy18 ; } else { if ( yych <= '-' ) goto yy96 ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy97 ; goto yy18 ; } yy96 : yych = * ++ YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych >= ':' ) goto yy18 ; yy97 : ++ YYCURSOR ; if ( YYLIMIT <= YYCURSOR ) YYFILL ( 1 ) ; yych = * YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy97 ; if ( yych != ';' ) goto yy18 ; ++ YYCURSOR ; <S2SV_StartBug> # line 500 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> { long id ; * p = YYCURSOR ; if ( ! var_hash ) return 0 ; id = parse_iv ( start + 2 ) - 1 ; if ( id == - 1 || var_access ( var_hash , id , & rval_ref ) != SUCCESS ) { return 0 ; } if ( * rval != NULL ) { var_push_dtor_no_addref ( var_hash , rval ) ; } * rval = * rval_ref ; Z_ADDREF_PP ( rval ) ; Z_SET_ISREF_PP ( rval ) ; return 1 ; } <S2SV_StartBug> # line 1312 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> } <S2SV_StartBug> # line 863 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> return 0 ; }","; # line 501 <S2SV_ModEnd> ""ext/standard/var_unserializer.c"" { YYCTYPE <S2SV_ModStart> : # line 875 <S2SV_ModEnd> ""ext/standard/var_unserializer.re"" { return <S2SV_ModStart> } # line 563 <S2SV_ModEnd> ""ext/standard/var_unserializer.c"" yy4 : <S2SV_ModStart> ; # line 869 <S2SV_ModEnd> ""ext/standard/var_unserializer.re"" { php_error_docref <S2SV_ModStart> } # line 612 <S2SV_ModEnd> ""ext/standard/var_unserializer.c"" yy16 : <S2SV_ModStart> ; # line 717 <S2SV_ModEnd> ""ext/standard/var_unserializer.re"" { size_t <S2SV_ModStart> ; if ( elements < 0 ) { efree ( class_name ) ; return 0 ; } if ( <S2SV_ModStart> } # line 795 <S2SV_ModEnd> ""ext/standard/var_unserializer.c"" yy25 : <S2SV_ModStart> ; # line 704 ""ext/standard/var_unserializer.re"" { long elements ; <S2SV_ModEnd> if ( ! <S2SV_ModStart> rval ) ; elements = object_common1 ( UNSERIALIZE_PASSTHRU , ZEND_STANDARD_CLASS_DEF_PTR ) ; if ( elements < 0 ) { return 0 ; } <S2SV_ModStart> ( UNSERIALIZE_PASSTHRU , elements <S2SV_ModEnd> ) ; } <S2SV_ModStart> } # line 833 <S2SV_ModEnd> ""ext/standard/var_unserializer.c"" yy32 : <S2SV_ModStart> ; # line 683 <S2SV_ModEnd> ""ext/standard/var_unserializer.re"" { long <S2SV_ModStart> } # line 875 <S2SV_ModEnd> ""ext/standard/var_unserializer.c"" yy39 : <S2SV_ModStart> ; # line 648 <S2SV_ModEnd> ""ext/standard/var_unserializer.re"" { size_t <S2SV_ModStart> } # line 931 <S2SV_ModEnd> ""ext/standard/var_unserializer.c"" yy46 : <S2SV_ModStart> ; # line 615 <S2SV_ModEnd> ""ext/standard/var_unserializer.re"" { size_t <S2SV_ModStart> } # line 985 <S2SV_ModEnd> ""ext/standard/var_unserializer.c"" yy53 : <S2SV_ModStart> ; # line 605 <S2SV_ModEnd> ""ext/standard/var_unserializer.re"" { # <S2SV_ModStart> } # line 1083 <S2SV_ModEnd> ""ext/standard/var_unserializer.c"" yy65 : <S2SV_ModStart> ; # line 590 <S2SV_ModEnd> ""ext/standard/var_unserializer.re"" { * <S2SV_ModStart> } # line 1157 <S2SV_ModEnd> ""ext/standard/var_unserializer.c"" yy76 : <S2SV_ModStart> ; # line 563 <S2SV_ModEnd> ""ext/standard/var_unserializer.re"" { # <S2SV_ModStart> } # line 1211 <S2SV_ModEnd> ""ext/standard/var_unserializer.c"" yy83 : <S2SV_ModStart> ; # line 556 <S2SV_ModEnd> ""ext/standard/var_unserializer.re"" { * <S2SV_ModStart> } # line 1226 <S2SV_ModEnd> ""ext/standard/var_unserializer.c"" yy87 : <S2SV_ModStart> ; # line 549 <S2SV_ModEnd> ""ext/standard/var_unserializer.re"" { * <S2SV_ModStart> } # line 1236 <S2SV_ModEnd> ""ext/standard/var_unserializer.c"" yy89 : <S2SV_ModStart> ; # line 526 <S2SV_ModEnd> ""ext/standard/var_unserializer.re"" { long <S2SV_ModStart> } # line 1282 <S2SV_ModEnd> ""ext/standard/var_unserializer.c"" yy95 : <S2SV_ModStart> ; # line 505 <S2SV_ModEnd> ""ext/standard/var_unserializer.re"" { long <S2SV_ModStart> } # line 1326 <S2SV_ModEnd> ""ext/standard/var_unserializer.c"" } # <S2SV_ModStart> } # line 877 <S2SV_ModEnd> ""ext/standard/var_unserializer.re"" return 0"
5,"int btsock_thread_exit ( int h ) { if ( h < 0 || h >= MAX_THREAD ) { APPL_TRACE_ERROR ( ""invalid<S2SV_blank>bt<S2SV_blank>thread<S2SV_blank>handle:%d"" , h ) ; return FALSE ; } if ( ts [ h ] . cmd_fdw == - 1 ) { APPL_TRACE_ERROR ( ""cmd<S2SV_blank>socket<S2SV_blank>is<S2SV_blank>not<S2SV_blank>created"" ) ; return FALSE ; } sock_cmd_t cmd = { CMD_EXIT , 0 , 0 , 0 , 0 } ; <S2SV_StartBug> if ( send ( ts [ h ] . cmd_fdw , & cmd , sizeof ( cmd ) , 0 ) == sizeof ( cmd ) ) <S2SV_EndBug> { pthread_join ( ts [ h ] . thread_id , 0 ) ; pthread_mutex_lock ( & thread_slot_lock ) ; free_thread_slot ( h ) ; pthread_mutex_unlock ( & thread_slot_lock ) ; return TRUE ; } return FALSE ; }","; if ( TEMP_FAILURE_RETRY ( <S2SV_ModStart> ) , 0 )"
6,"int process ( register int code , unsigned char * * fill ) { int incode ; static unsigned char firstchar ; if ( code == clear ) { codesize = datasize + 1 ; codemask = ( 1 << codesize ) - 1 ; avail = clear + 2 ; oldcode = - 1 ; return 1 ; } if ( oldcode == - 1 ) { <S2SV_StartBug> * ( * fill ) ++ = suffix [ code ] ; <S2SV_EndBug> firstchar = oldcode = code ; return 1 ; } if ( code > avail ) { fprintf ( stderr , ""code<S2SV_blank>%d<S2SV_blank>too<S2SV_blank>large<S2SV_blank>for<S2SV_blank>%d\\n"" , code , avail ) ; return 0 ; } incode = code ; if ( code == avail ) { * stackp ++ = firstchar ; code = oldcode ; } while ( code > clear ) { * stackp ++ = suffix [ code ] ; code = prefix [ code ] ; } * stackp ++ = firstchar = suffix [ code ] ; prefix [ avail ] = oldcode ; suffix [ avail ] = firstchar ; avail ++ ; if ( ( ( avail & codemask ) == 0 ) && ( avail < 4096 ) ) { codesize ++ ; codemask += avail ; } oldcode = incode ; do { * ( * fill ) ++ = * -- stackp ; } while ( stackp > stack ) ; return 1 ; }","1 ) { if ( code >= clear ) { fprintf ( stderr , ""bad<S2SV_blank>input:<S2SV_blank>code=%d<S2SV_blank>is<S2SV_blank>larger<S2SV_blank>than<S2SV_blank>clear=%d\\n"" , code , clear ) ; return 0 ; }"
7,"static int irda_recvmsg_dgram ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t size , int flags ) { struct sock * sk = sock -> sk ; struct irda_sock * self = irda_sk ( sk ) ; struct sk_buff * skb ; size_t copied ; int err ; IRDA_DEBUG ( 4 , ""%s()\\n"" , __func__ ) ; <S2SV_StartBug> msg -> msg_namelen = 0 ; <S2SV_EndBug> skb = skb_recv_datagram ( sk , flags & ~ MSG_DONTWAIT , flags & MSG_DONTWAIT , & err ) ; if ( ! skb ) return err ; skb_reset_transport_header ( skb ) ; copied = skb -> len ; if ( copied > size ) { IRDA_DEBUG ( 2 , ""%s(),<S2SV_blank>Received<S2SV_blank>truncated<S2SV_blank>frame<S2SV_blank>(%zd<S2SV_blank><<S2SV_blank>%zd)!\\n"" , __func__ , copied , size ) ; copied = size ; msg -> msg_flags |= MSG_TRUNC ; } skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; skb_free_datagram ( sk , skb ) ; if ( self -> rx_flow == FLOW_STOP ) { if ( ( atomic_read ( & sk -> sk_rmem_alloc ) << 2 ) <= sk -> sk_rcvbuf ) { IRDA_DEBUG ( 2 , ""%s(),<S2SV_blank>Starting<S2SV_blank>IrTTP\\n"" , __func__ ) ; self -> rx_flow = FLOW_START ; irttp_flow_request ( self -> tsap , FLOW_START ) ; } } return copied ; }",__func__ ) ; <S2SV_ModEnd> skb = skb_recv_datagram
8,"static __latent_entropy struct task_struct * copy_process ( struct pid * pid , int trace , int node , struct kernel_clone_args * args ) { int pidfd = - 1 , retval ; struct task_struct * p ; struct multiprocess_signals delayed ; struct file * pidfile = NULL ; u64 clone_flags = args -> flags ; struct nsproxy * nsp = current -> nsproxy ; if ( ( clone_flags & ( CLONE_NEWNS | CLONE_FS ) ) == ( CLONE_NEWNS | CLONE_FS ) ) return ERR_PTR ( - EINVAL ) ; if ( ( clone_flags & ( CLONE_NEWUSER | CLONE_FS ) ) == ( CLONE_NEWUSER | CLONE_FS ) ) return ERR_PTR ( - EINVAL ) ; if ( ( clone_flags & CLONE_THREAD ) && ! ( clone_flags & CLONE_SIGHAND ) ) return ERR_PTR ( - EINVAL ) ; if ( ( clone_flags & CLONE_SIGHAND ) && ! ( clone_flags & CLONE_VM ) ) return ERR_PTR ( - EINVAL ) ; if ( ( clone_flags & CLONE_PARENT ) && current -> signal -> flags & SIGNAL_UNKILLABLE ) return ERR_PTR ( - EINVAL ) ; if ( clone_flags & CLONE_THREAD ) { if ( ( clone_flags & ( CLONE_NEWUSER | CLONE_NEWPID ) ) || ( task_active_pid_ns ( current ) != nsp -> pid_ns_for_children ) ) return ERR_PTR ( - EINVAL ) ; } if ( clone_flags & ( CLONE_THREAD | CLONE_VM ) ) { if ( nsp -> time_ns != nsp -> time_ns_for_children ) return ERR_PTR ( - EINVAL ) ; } if ( clone_flags & CLONE_PIDFD ) { if ( clone_flags & ( CLONE_DETACHED | CLONE_THREAD ) ) return ERR_PTR ( - EINVAL ) ; } sigemptyset ( & delayed . signal ) ; INIT_HLIST_NODE ( & delayed . node ) ; spin_lock_irq ( & current -> sighand -> siglock ) ; if ( ! ( clone_flags & CLONE_THREAD ) ) hlist_add_head ( & delayed . node , & current -> signal -> multiprocess ) ; recalc_sigpending ( ) ; spin_unlock_irq ( & current -> sighand -> siglock ) ; retval = - ERESTARTNOINTR ; if ( signal_pending ( current ) ) goto fork_out ; retval = - ENOMEM ; p = dup_task_struct ( current , node ) ; if ( ! p ) goto fork_out ; p -> set_child_tid = ( clone_flags & CLONE_CHILD_SETTID ) ? args -> child_tid : NULL ; p -> clear_child_tid = ( clone_flags & CLONE_CHILD_CLEARTID ) ? args -> child_tid : NULL ; ftrace_graph_init_task ( p ) ; rt_mutex_init_task ( p ) ; lockdep_assert_irqs_enabled ( ) ; # ifdef CONFIG_PROVE_LOCKING DEBUG_LOCKS_WARN_ON ( ! p -> softirqs_enabled ) ; # endif retval = - EAGAIN ; if ( atomic_read ( & p -> real_cred -> user -> processes ) >= task_rlimit ( p , RLIMIT_NPROC ) ) { if ( p -> real_cred -> user != INIT_USER && ! capable ( CAP_SYS_RESOURCE ) && ! capable ( CAP_SYS_ADMIN ) ) goto bad_fork_free ; } current -> flags &= ~ PF_NPROC_EXCEEDED ; retval = copy_creds ( p , clone_flags ) ; if ( retval < 0 ) goto bad_fork_free ; retval = - EAGAIN ; if ( data_race ( nr_threads >= max_threads ) ) goto bad_fork_cleanup_count ; delayacct_tsk_init ( p ) ; p -> flags &= ~ ( PF_SUPERPRIV | PF_WQ_WORKER | PF_IDLE ) ; p -> flags |= PF_FORKNOEXEC ; INIT_LIST_HEAD ( & p -> children ) ; INIT_LIST_HEAD ( & p -> sibling ) ; rcu_copy_process ( p ) ; p -> vfork_done = NULL ; spin_lock_init ( & p -> alloc_lock ) ; init_sigpending ( & p -> pending ) ; p -> utime = p -> stime = p -> gtime = 0 ; # ifdef CONFIG_ARCH_HAS_SCALED_CPUTIME p -> utimescaled = p -> stimescaled = 0 ; # endif prev_cputime_init ( & p -> prev_cputime ) ; # ifdef CONFIG_VIRT_CPU_ACCOUNTING_GEN seqcount_init ( & p -> vtime . seqcount ) ; p -> vtime . starttime = 0 ; p -> vtime . state = VTIME_INACTIVE ; # endif # ifdef CONFIG_IO_URING p -> io_uring = NULL ; # endif # if defined ( SPLIT_RSS_COUNTING ) memset ( & p -> rss_stat , 0 , sizeof ( p -> rss_stat ) ) ; # endif p -> default_timer_slack_ns = current -> timer_slack_ns ; # ifdef CONFIG_PSI p -> psi_flags = 0 ; # endif task_io_accounting_init ( & p -> ioac ) ; acct_clear_integrals ( p ) ; posix_cputimers_init ( & p -> posix_cputimers ) ; p -> io_context = NULL ; audit_set_context ( p , NULL ) ; cgroup_fork ( p ) ; # ifdef CONFIG_NUMA p -> mempolicy = mpol_dup ( p -> mempolicy ) ; if ( IS_ERR ( p -> mempolicy ) ) { retval = PTR_ERR ( p -> mempolicy ) ; p -> mempolicy = NULL ; goto bad_fork_cleanup_threadgroup_lock ; } # endif # ifdef CONFIG_CPUSETS p -> cpuset_mem_spread_rotor = NUMA_NO_NODE ; p -> cpuset_slab_spread_rotor = NUMA_NO_NODE ; seqcount_spinlock_init ( & p -> mems_allowed_seq , & p -> alloc_lock ) ; # endif # ifdef CONFIG_TRACE_IRQFLAGS memset ( & p -> irqtrace , 0 , sizeof ( p -> irqtrace ) ) ; p -> irqtrace . hardirq_disable_ip = _THIS_IP_ ; p -> irqtrace . softirq_enable_ip = _THIS_IP_ ; p -> softirqs_enabled = 1 ; p -> softirq_context = 0 ; # endif p -> pagefault_disabled = 0 ; # ifdef CONFIG_LOCKDEP lockdep_init_task ( p ) ; # endif # ifdef CONFIG_DEBUG_MUTEXES p -> blocked_on = NULL ; # endif # ifdef CONFIG_BCACHE p -> sequential_io = 0 ; p -> sequential_io_avg = 0 ; # endif retval = sched_fork ( clone_flags , p ) ; if ( retval ) goto bad_fork_cleanup_policy ; retval = perf_event_init_task ( p ) ; if ( retval ) goto bad_fork_cleanup_policy ; retval = audit_alloc ( p ) ; if ( retval ) goto bad_fork_cleanup_perf ; shm_init_task ( p ) ; retval = security_task_alloc ( p , clone_flags ) ; if ( retval ) goto bad_fork_cleanup_audit ; retval = copy_semundo ( clone_flags , p ) ; if ( retval ) goto bad_fork_cleanup_security ; retval = copy_files ( clone_flags , p ) ; if ( retval ) goto bad_fork_cleanup_semundo ; retval = copy_fs ( clone_flags , p ) ; if ( retval ) goto bad_fork_cleanup_files ; retval = copy_sighand ( clone_flags , p ) ; if ( retval ) goto bad_fork_cleanup_fs ; retval = copy_signal ( clone_flags , p ) ; if ( retval ) goto bad_fork_cleanup_sighand ; retval = copy_mm ( clone_flags , p ) ; if ( retval ) goto bad_fork_cleanup_signal ; retval = copy_namespaces ( clone_flags , p ) ; if ( retval ) goto bad_fork_cleanup_mm ; retval = copy_io ( clone_flags , p ) ; if ( retval ) goto bad_fork_cleanup_namespaces ; retval = copy_thread ( clone_flags , args -> stack , args -> stack_size , p , args -> tls ) ; if ( retval ) goto bad_fork_cleanup_io ; stackleak_task_init ( p ) ; if ( pid != & init_struct_pid ) { pid = alloc_pid ( p -> nsproxy -> pid_ns_for_children , args -> set_tid , args -> set_tid_size ) ; if ( IS_ERR ( pid ) ) { retval = PTR_ERR ( pid ) ; goto bad_fork_cleanup_thread ; } } if ( clone_flags & CLONE_PIDFD ) { retval = get_unused_fd_flags ( O_RDWR | O_CLOEXEC ) ; if ( retval < 0 ) goto bad_fork_free_pid ; pidfd = retval ; pidfile = anon_inode_getfile ( ""[pidfd]"" , & pidfd_fops , pid , O_RDWR | O_CLOEXEC ) ; if ( IS_ERR ( pidfile ) ) { put_unused_fd ( pidfd ) ; retval = PTR_ERR ( pidfile ) ; goto bad_fork_free_pid ; } get_pid ( pid ) ; retval = put_user ( pidfd , args -> pidfd ) ; if ( retval ) goto bad_fork_put_pidfd ; } # ifdef CONFIG_BLOCK p -> plug = NULL ; # endif futex_init_task ( p ) ; if ( ( clone_flags & ( CLONE_VM | CLONE_VFORK ) ) == CLONE_VM ) sas_ss_reset ( p ) ; user_disable_single_step ( p ) ; clear_tsk_thread_flag ( p , TIF_SYSCALL_TRACE ) ; # ifdef TIF_SYSCALL_EMU clear_tsk_thread_flag ( p , TIF_SYSCALL_EMU ) ; # endif clear_tsk_latency_tracing ( p ) ; p -> pid = pid_nr ( pid ) ; if ( clone_flags & CLONE_THREAD ) { <S2SV_StartBug> p -> exit_signal = - 1 ; <S2SV_EndBug> p -> group_leader = current -> group_leader ; p -> tgid = current -> tgid ; } else { <S2SV_StartBug> if ( clone_flags & CLONE_PARENT ) <S2SV_EndBug> p -> exit_signal = current -> group_leader -> exit_signal ; else p -> exit_signal = args -> exit_signal ; p -> group_leader = p ; p -> tgid = p -> pid ; } p -> nr_dirtied = 0 ; p -> nr_dirtied_pause = 128 >> ( PAGE_SHIFT - 10 ) ; p -> dirty_paused_when = 0 ; p -> pdeath_signal = 0 ; INIT_LIST_HEAD ( & p -> thread_group ) ; p -> task_works = NULL ; retval = cgroup_can_fork ( p , args ) ; if ( retval ) goto bad_fork_put_pidfd ; p -> start_time = ktime_get_ns ( ) ; p -> start_boottime = ktime_get_boottime_ns ( ) ; write_lock_irq ( & tasklist_lock ) ; if ( clone_flags & ( CLONE_PARENT | CLONE_THREAD ) ) { p -> real_parent = current -> real_parent ; p -> parent_exec_id = current -> parent_exec_id ; <S2SV_StartBug> } else { <S2SV_EndBug> p -> real_parent = current ; p -> parent_exec_id = current -> self_exec_id ; <S2SV_StartBug> } <S2SV_EndBug> klp_copy_process ( p ) ; spin_lock ( & current -> sighand -> siglock ) ; copy_seccomp ( p ) ; rseq_fork ( p , clone_flags ) ; if ( unlikely ( ! ( ns_of_pid ( pid ) -> pid_allocated & PIDNS_ADDING ) ) ) { retval = - ENOMEM ; goto bad_fork_cancel_cgroup ; } if ( fatal_signal_pending ( current ) ) { retval = - EINTR ; goto bad_fork_cancel_cgroup ; } if ( pidfile ) fd_install ( pidfd , pidfile ) ; init_task_pid_links ( p ) ; if ( likely ( p -> pid ) ) { ptrace_init_task ( p , ( clone_flags & CLONE_PTRACE ) || trace ) ; init_task_pid ( p , PIDTYPE_PID , pid ) ; if ( thread_group_leader ( p ) ) { init_task_pid ( p , PIDTYPE_TGID , pid ) ; init_task_pid ( p , PIDTYPE_PGID , task_pgrp ( current ) ) ; init_task_pid ( p , PIDTYPE_SID , task_session ( current ) ) ; if ( is_child_reaper ( pid ) ) { ns_of_pid ( pid ) -> child_reaper = p ; p -> signal -> flags |= SIGNAL_UNKILLABLE ; } p -> signal -> shared_pending . signal = delayed . signal ; p -> signal -> tty = tty_kref_get ( current -> signal -> tty ) ; p -> signal -> has_child_subreaper = p -> real_parent -> signal -> has_child_subreaper || p -> real_parent -> signal -> is_child_subreaper ; list_add_tail ( & p -> sibling , & p -> real_parent -> children ) ; list_add_tail_rcu ( & p -> tasks , & init_task . tasks ) ; attach_pid ( p , PIDTYPE_TGID ) ; attach_pid ( p , PIDTYPE_PGID ) ; attach_pid ( p , PIDTYPE_SID ) ; __this_cpu_inc ( process_counts ) ; } else { current -> signal -> nr_threads ++ ; atomic_inc ( & current -> signal -> live ) ; refcount_inc ( & current -> signal -> sigcnt ) ; task_join_group_stop ( p ) ; list_add_tail_rcu ( & p -> thread_group , & p -> group_leader -> thread_group ) ; list_add_tail_rcu ( & p -> thread_node , & p -> signal -> thread_head ) ; } attach_pid ( p , PIDTYPE_PID ) ; nr_threads ++ ; } total_forks ++ ; hlist_del_init ( & delayed . node ) ; spin_unlock ( & current -> sighand -> siglock ) ; syscall_tracepoint_update ( p ) ; write_unlock_irq ( & tasklist_lock ) ; proc_fork_connector ( p ) ; sched_post_fork ( p ) ; cgroup_post_fork ( p , args ) ; perf_event_fork ( p ) ; trace_task_newtask ( p , clone_flags ) ; uprobe_copy_process ( p , clone_flags ) ; copy_oom_score_adj ( clone_flags , p ) ; return p ; bad_fork_cancel_cgroup : spin_unlock ( & current -> sighand -> siglock ) ; write_unlock_irq ( & tasklist_lock ) ; cgroup_cancel_fork ( p , args ) ; bad_fork_put_pidfd : if ( clone_flags & CLONE_PIDFD ) { fput ( pidfile ) ; put_unused_fd ( pidfd ) ; } bad_fork_free_pid : if ( pid != & init_struct_pid ) free_pid ( pid ) ; bad_fork_cleanup_thread : exit_thread ( p ) ; bad_fork_cleanup_io : if ( p -> io_context ) exit_io_context ( p ) ; bad_fork_cleanup_namespaces : exit_task_namespaces ( p ) ; bad_fork_cleanup_mm : if ( p -> mm ) { mm_clear_owner ( p -> mm , p ) ; mmput ( p -> mm ) ; } bad_fork_cleanup_signal : if ( ! ( clone_flags & CLONE_THREAD ) ) free_signal_struct ( p -> signal ) ; bad_fork_cleanup_sighand : __cleanup_sighand ( p -> sighand ) ; bad_fork_cleanup_fs : exit_fs ( p ) ; bad_fork_cleanup_files : exit_files ( p ) ; bad_fork_cleanup_semundo : exit_sem ( p ) ; bad_fork_cleanup_security : security_task_free ( p ) ; bad_fork_cleanup_audit : audit_free ( p ) ; bad_fork_cleanup_perf : perf_event_free_task ( p ) ; bad_fork_cleanup_policy : lockdep_free_task ( p ) ; # ifdef CONFIG_NUMA mpol_put ( p -> mempolicy ) ; bad_fork_cleanup_threadgroup_lock : # endif delayacct_tsk_free ( p ) ; bad_fork_cleanup_count : atomic_dec ( & p -> cred -> user -> processes ) ; exit_creds ( p ) ; bad_fork_free : p -> state = TASK_DEAD ; put_task_stack ( p ) ; delayed_free_task ( p ) ; fork_out : spin_lock_irq ( & current -> sighand -> siglock ) ; hlist_del_init ( & delayed . node ) ; spin_unlock_irq ( & current -> sighand -> siglock ) ; return ERR_PTR ( retval ) ; }",{ p -> <S2SV_ModEnd> group_leader = current <S2SV_ModStart> } else { <S2SV_ModEnd> p -> group_leader <S2SV_ModStart> -> parent_exec_id ; if ( clone_flags & CLONE_THREAD ) p -> exit_signal = - 1 ; else p -> exit_signal = current -> group_leader -> exit_signal ; <S2SV_ModStart> -> self_exec_id ; p -> exit_signal = args -> exit_signal ;
9,"static const u_char * ikev1_n_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , <S2SV_StartBug> const u_char * ep , uint32_t phase , uint32_t doi0 _U_ , <S2SV_EndBug> <S2SV_StartBug> uint32_t proto0 _U_ , int depth ) <S2SV_EndBug> { const struct ikev1_pl_n * p ; struct ikev1_pl_n n ; const u_char * cp ; const u_char * ep2 ; uint32_t doi ; uint32_t proto ; static const char * notify_error_str [ ] = { NULL , ""INVALID-PAYLOAD-TYPE"" , ""DOI-NOT-SUPPORTED"" , ""SITUATION-NOT-SUPPORTED"" , ""INVALID-COOKIE"" , ""INVALID-MAJOR-VERSION"" , ""INVALID-MINOR-VERSION"" , ""INVALID-EXCHANGE-TYPE"" , ""INVALID-FLAGS"" , ""INVALID-MESSAGE-ID"" , ""INVALID-PROTOCOL-ID"" , ""INVALID-SPI"" , ""INVALID-TRANSFORM-ID"" , ""ATTRIBUTES-NOT-SUPPORTED"" , ""NO-PROPOSAL-CHOSEN"" , ""BAD-PROPOSAL-SYNTAX"" , ""PAYLOAD-MALFORMED"" , ""INVALID-KEY-INFORMATION"" , ""INVALID-ID-INFORMATION"" , ""INVALID-CERT-ENCODING"" , ""INVALID-CERTIFICATE"" , ""CERT-TYPE-UNSUPPORTED"" , ""INVALID-CERT-AUTHORITY"" , ""INVALID-HASH-INFORMATION"" , ""AUTHENTICATION-FAILED"" , ""INVALID-SIGNATURE"" , ""ADDRESS-NOTIFICATION"" , ""NOTIFY-SA-LIFETIME"" , ""CERTIFICATE-UNAVAILABLE"" , ""UNSUPPORTED-EXCHANGE-TYPE"" , ""UNEQUAL-PAYLOAD-LENGTHS"" , } ; static const char * ipsec_notify_error_str [ ] = { ""RESERVED"" , } ; static const char * notify_status_str [ ] = { ""CONNECTED"" , } ; static const char * ipsec_notify_status_str [ ] = { ""RESPONDER-LIFETIME"" , ""REPLAY-STATUS"" , ""INITIAL-CONTACT"" , } ; # define NOTIFY_ERROR_STR ( x ) STR_OR_ID ( ( x ) , notify_error_str ) # define IPSEC_NOTIFY_ERROR_STR ( x ) STR_OR_ID ( ( u_int ) ( ( x ) - 8192 ) , ipsec_notify_error_str ) # define NOTIFY_STATUS_STR ( x ) STR_OR_ID ( ( u_int ) ( ( x ) - 16384 ) , notify_status_str ) # define IPSEC_NOTIFY_STATUS_STR ( x ) STR_OR_ID ( ( u_int ) ( ( x ) - 24576 ) , ipsec_notify_status_str ) ND_PRINT ( ( ndo , ""%s:"" , NPSTR ( ISAKMP_NPTYPE_N ) ) ) ; p = ( const struct ikev1_pl_n * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & n , ext , sizeof ( n ) ) ; doi = ntohl ( n . doi ) ; proto = n . prot_id ; if ( doi != 1 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>doi=%d"" , doi ) ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>proto=%d"" , proto ) ) ; if ( ntohs ( n . type ) < 8192 ) ND_PRINT ( ( ndo , ""<S2SV_blank>type=%s"" , NOTIFY_ERROR_STR ( ntohs ( n . type ) ) ) ) ; else if ( ntohs ( n . type ) < 16384 ) ND_PRINT ( ( ndo , ""<S2SV_blank>type=%s"" , numstr ( ntohs ( n . type ) ) ) ) ; else if ( ntohs ( n . type ) < 24576 ) ND_PRINT ( ( ndo , ""<S2SV_blank>type=%s"" , NOTIFY_STATUS_STR ( ntohs ( n . type ) ) ) ) ; else ND_PRINT ( ( ndo , ""<S2SV_blank>type=%s"" , numstr ( ntohs ( n . type ) ) ) ) ; if ( n . spi_size ) { ND_PRINT ( ( ndo , ""<S2SV_blank>spi="" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( p + 1 ) , n . spi_size ) ) goto trunc ; } return ( const u_char * ) ( p + 1 ) + n . spi_size ; } ND_PRINT ( ( ndo , ""<S2SV_blank>doi=ipsec"" ) ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>proto=%s"" , PROTOIDSTR ( proto ) ) ) ; if ( ntohs ( n . type ) < 8192 ) ND_PRINT ( ( ndo , ""<S2SV_blank>type=%s"" , NOTIFY_ERROR_STR ( ntohs ( n . type ) ) ) ) ; else if ( ntohs ( n . type ) < 16384 ) ND_PRINT ( ( ndo , ""<S2SV_blank>type=%s"" , IPSEC_NOTIFY_ERROR_STR ( ntohs ( n . type ) ) ) ) ; else if ( ntohs ( n . type ) < 24576 ) ND_PRINT ( ( ndo , ""<S2SV_blank>type=%s"" , NOTIFY_STATUS_STR ( ntohs ( n . type ) ) ) ) ; else if ( ntohs ( n . type ) < 32768 ) ND_PRINT ( ( ndo , ""<S2SV_blank>type=%s"" , IPSEC_NOTIFY_STATUS_STR ( ntohs ( n . type ) ) ) ) ; else ND_PRINT ( ( ndo , ""<S2SV_blank>type=%s"" , numstr ( ntohs ( n . type ) ) ) ) ; if ( n . spi_size ) { ND_PRINT ( ( ndo , ""<S2SV_blank>spi="" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( p + 1 ) , n . spi_size ) ) goto trunc ; } cp = ( const u_char * ) ( p + 1 ) + n . spi_size ; ep2 = ( const u_char * ) p + item_len ; if ( cp < ep ) { <S2SV_StartBug> ND_PRINT ( ( ndo , ""<S2SV_blank>orig=("" ) ) ; <S2SV_EndBug> switch ( ntohs ( n . type ) ) { case IPSECDOI_NTYPE_RESPONDER_LIFETIME : { const struct attrmap * map = oakley_t_map ; <S2SV_StartBug> size_t nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; <S2SV_EndBug> while ( cp < ep && cp < ep2 ) { cp = ikev1_attrmap_print ( ndo , cp , ( ep < ep2 ) ? ep : ep2 , map , nmap ) ; } <S2SV_StartBug> break ; <S2SV_EndBug> } <S2SV_StartBug> case IPSECDOI_NTYPE_REPLAY_STATUS : <S2SV_EndBug> ND_PRINT ( ( ndo , ""replay<S2SV_blank>detection<S2SV_blank>%sabled"" , EXTRACT_32BITS ( cp ) ? ""en"" : ""dis"" ) ) ; <S2SV_StartBug> break ; <S2SV_EndBug> case ISAKMP_NTYPE_NO_PROPOSAL_CHOSEN : if ( ikev1_sub_print ( ndo , ISAKMP_NPTYPE_SA , ( const struct isakmp_gen * ) cp , ep , phase , doi , proto , depth ) == NULL ) return NULL ; break ; default : <S2SV_StartBug> isakmp_print ( ndo , cp , <S2SV_EndBug> item_len - sizeof ( * p ) - n . spi_size , NULL ) ; } <S2SV_StartBug> ND_PRINT ( ( ndo , "")"" ) ) ; <S2SV_EndBug> } return ( const u_char * ) ext + item_len ; trunc : ND_PRINT ( ( ndo , ""<S2SV_blank>[|%s]"" , NPSTR ( ISAKMP_NPTYPE_N ) ) ) ; return NULL ; }",", uint32_t phase _U_ <S2SV_ModStart> , int depth _U_ <S2SV_ModStart> ep ) { <S2SV_ModEnd> switch ( ntohs <S2SV_ModStart> [ 0 ] ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>attrs=("" ) <S2SV_ModStart> ) ; } ND_PRINT ( ( ndo , "")"" ) ) ; <S2SV_ModStart> case IPSECDOI_NTYPE_REPLAY_STATUS : ND_PRINT ( ( ndo , ""<S2SV_blank>status=("" ) ) ; <S2SV_ModStart> ) ) ; ND_PRINT ( ( ndo , "")"" ) ) <S2SV_ModEnd> ; break ; <S2SV_ModStart> ; default : if ( ndo -> ndo_vflag > 3 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>data=("" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( cp ) , ep - cp ) ) goto trunc ; <S2SV_ModEnd> ND_PRINT ( ( <S2SV_ModStart> ) ) ; } else { if ( ! ike_show_somedata ( ndo , cp , ep ) ) goto trunc ; } break ; }"
10,"ssize_t nghttp2_session_mem_recv ( nghttp2_session * session , const uint8_t * in , size_t inlen ) { const uint8_t * first = in , * last = in + inlen ; nghttp2_inbound_frame * iframe = & session -> iframe ; size_t readlen ; ssize_t padlen ; int rv ; int busy = 0 ; nghttp2_frame_hd cont_hd ; nghttp2_stream * stream ; size_t pri_fieldlen ; nghttp2_mem * mem ; DEBUGF ( ""recv:<S2SV_blank>connection<S2SV_blank>recv_window_size=%d,<S2SV_blank>local_window=%d\\n"" , session -> recv_window_size , session -> local_window_size ) ; mem = & session -> mem ; rv = nghttp2_session_adjust_idle_stream ( session ) ; if ( nghttp2_is_fatal ( rv ) ) { return rv ; } if ( ! nghttp2_session_want_read ( session ) ) { return ( ssize_t ) inlen ; } for ( ; ; ) { switch ( iframe -> state ) { case NGHTTP2_IB_READ_CLIENT_MAGIC : readlen = nghttp2_min ( inlen , iframe -> payloadleft ) ; if ( memcmp ( & NGHTTP2_CLIENT_MAGIC [ NGHTTP2_CLIENT_MAGIC_LEN - iframe -> payloadleft ] , in , readlen ) != 0 ) { return NGHTTP2_ERR_BAD_CLIENT_MAGIC ; } iframe -> payloadleft -= readlen ; in += readlen ; if ( iframe -> payloadleft == 0 ) { session_inbound_frame_reset ( session ) ; iframe -> state = NGHTTP2_IB_READ_FIRST_SETTINGS ; } break ; case NGHTTP2_IB_READ_FIRST_SETTINGS : DEBUGF ( ""recv:<S2SV_blank>[IB_READ_FIRST_SETTINGS]\\n"" ) ; readlen = inbound_frame_buf_read ( iframe , in , last ) ; in += readlen ; if ( nghttp2_buf_mark_avail ( & iframe -> sbuf ) ) { return in - first ; } if ( iframe -> sbuf . pos [ 3 ] != NGHTTP2_SETTINGS || ( iframe -> sbuf . pos [ 4 ] & NGHTTP2_FLAG_ACK ) ) { rv = session_call_error_callback ( session , NGHTTP2_ERR_SETTINGS_EXPECTED , ""Remote<S2SV_blank>peer<S2SV_blank>returned<S2SV_blank>unexpected<S2SV_blank>data<S2SV_blank>while<S2SV_blank>we<S2SV_blank>expected<S2SV_blank>"" ""SETTINGS<S2SV_blank>frame.<S2SV_blank><S2SV_blank>Perhaps,<S2SV_blank>peer<S2SV_blank>does<S2SV_blank>not<S2SV_blank>support<S2SV_blank>HTTP/2<S2SV_blank>"" ""properly."" ) ; if ( nghttp2_is_fatal ( rv ) ) { return rv ; } rv = nghttp2_session_terminate_session_with_reason ( session , NGHTTP2_PROTOCOL_ERROR , ""SETTINGS<S2SV_blank>expected"" ) ; if ( nghttp2_is_fatal ( rv ) ) { return rv ; } return ( ssize_t ) inlen ; } iframe -> state = NGHTTP2_IB_READ_HEAD ; case NGHTTP2_IB_READ_HEAD : { int on_begin_frame_called = 0 ; DEBUGF ( ""recv:<S2SV_blank>[IB_READ_HEAD]\\n"" ) ; readlen = inbound_frame_buf_read ( iframe , in , last ) ; in += readlen ; if ( nghttp2_buf_mark_avail ( & iframe -> sbuf ) ) { return in - first ; } nghttp2_frame_unpack_frame_hd ( & iframe -> frame . hd , iframe -> sbuf . pos ) ; iframe -> payloadleft = iframe -> frame . hd . length ; DEBUGF ( ""recv:<S2SV_blank>payloadlen=%zu,<S2SV_blank>type=%u,<S2SV_blank>flags=0x%02x,<S2SV_blank>stream_id=%d\\n"" , iframe -> frame . hd . length , iframe -> frame . hd . type , iframe -> frame . hd . flags , iframe -> frame . hd . stream_id ) ; if ( iframe -> frame . hd . length > session -> local_settings . max_frame_size ) { DEBUGF ( ""recv:<S2SV_blank>length<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large<S2SV_blank>%zu<S2SV_blank>><S2SV_blank>%u\\n"" , iframe -> frame . hd . length , session -> local_settings . max_frame_size ) ; rv = nghttp2_session_terminate_session_with_reason ( session , NGHTTP2_FRAME_SIZE_ERROR , ""too<S2SV_blank>large<S2SV_blank>frame<S2SV_blank>size"" ) ; if ( nghttp2_is_fatal ( rv ) ) { return rv ; } return ( ssize_t ) inlen ; } switch ( iframe -> frame . hd . type ) { case NGHTTP2_DATA : { DEBUGF ( ""recv:<S2SV_blank>DATA\\n"" ) ; iframe -> frame . hd . flags &= ( NGHTTP2_FLAG_END_STREAM | NGHTTP2_FLAG_PADDED ) ; busy = 1 ; rv = session_on_data_received_fail_fast ( session ) ; if ( iframe -> state == NGHTTP2_IB_IGN_ALL ) { return ( ssize_t ) inlen ; } if ( rv == NGHTTP2_ERR_IGN_PAYLOAD ) { DEBUGF ( ""recv:<S2SV_blank>DATA<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>stream_id=%d\\n"" , iframe -> frame . hd . stream_id ) ; iframe -> state = NGHTTP2_IB_IGN_DATA ; break ; } if ( nghttp2_is_fatal ( rv ) ) { return rv ; } rv = inbound_frame_handle_pad ( iframe , & iframe -> frame . hd ) ; if ( rv < 0 ) { rv = nghttp2_session_terminate_session_with_reason ( session , NGHTTP2_PROTOCOL_ERROR , ""DATA:<S2SV_blank>insufficient<S2SV_blank>padding<S2SV_blank>space"" ) ; if ( nghttp2_is_fatal ( rv ) ) { return rv ; } return ( ssize_t ) inlen ; } if ( rv == 1 ) { iframe -> state = NGHTTP2_IB_READ_PAD_DATA ; break ; } iframe -> state = NGHTTP2_IB_READ_DATA ; break ; } case NGHTTP2_HEADERS : DEBUGF ( ""recv:<S2SV_blank>HEADERS\\n"" ) ; iframe -> frame . hd . flags &= ( NGHTTP2_FLAG_END_STREAM | NGHTTP2_FLAG_END_HEADERS | NGHTTP2_FLAG_PADDED | NGHTTP2_FLAG_PRIORITY ) ; rv = inbound_frame_handle_pad ( iframe , & iframe -> frame . hd ) ; if ( rv < 0 ) { rv = nghttp2_session_terminate_session_with_reason ( session , NGHTTP2_PROTOCOL_ERROR , ""HEADERS:<S2SV_blank>insufficient<S2SV_blank>padding<S2SV_blank>space"" ) ; if ( nghttp2_is_fatal ( rv ) ) { return rv ; } return ( ssize_t ) inlen ; } if ( rv == 1 ) { iframe -> state = NGHTTP2_IB_READ_NBYTE ; break ; } pri_fieldlen = nghttp2_frame_priority_len ( iframe -> frame . hd . flags ) ; if ( pri_fieldlen > 0 ) { if ( iframe -> payloadleft < pri_fieldlen ) { busy = 1 ; iframe -> state = NGHTTP2_IB_FRAME_SIZE_ERROR ; break ; } iframe -> state = NGHTTP2_IB_READ_NBYTE ; inbound_frame_set_mark ( iframe , pri_fieldlen ) ; break ; } rv = session_call_on_begin_frame ( session , & iframe -> frame . hd ) ; if ( nghttp2_is_fatal ( rv ) ) { return rv ; } on_begin_frame_called = 1 ; rv = session_process_headers_frame ( session ) ; if ( nghttp2_is_fatal ( rv ) ) { return rv ; } busy = 1 ; if ( iframe -> state == NGHTTP2_IB_IGN_ALL ) { return ( ssize_t ) inlen ; } if ( rv == NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE ) { rv = nghttp2_session_add_rst_stream ( session , iframe -> frame . hd . stream_id , NGHTTP2_INTERNAL_ERROR ) ; if ( nghttp2_is_fatal ( rv ) ) { return rv ; } iframe -> state = NGHTTP2_IB_IGN_HEADER_BLOCK ; break ; } if ( rv == NGHTTP2_ERR_IGN_HEADER_BLOCK ) { iframe -> state = NGHTTP2_IB_IGN_HEADER_BLOCK ; break ; } iframe -> state = NGHTTP2_IB_READ_HEADER_BLOCK ; break ; case NGHTTP2_PRIORITY : DEBUGF ( ""recv:<S2SV_blank>PRIORITY\\n"" ) ; iframe -> frame . hd . flags = NGHTTP2_FLAG_NONE ; if ( iframe -> payloadleft != NGHTTP2_PRIORITY_SPECLEN ) { busy = 1 ; iframe -> state = NGHTTP2_IB_FRAME_SIZE_ERROR ; break ; } iframe -> state = NGHTTP2_IB_READ_NBYTE ; inbound_frame_set_mark ( iframe , NGHTTP2_PRIORITY_SPECLEN ) ; break ; case NGHTTP2_RST_STREAM : case NGHTTP2_WINDOW_UPDATE : # ifdef DEBUGBUILD switch ( iframe -> frame . hd . type ) { case NGHTTP2_RST_STREAM : DEBUGF ( ""recv:<S2SV_blank>RST_STREAM\\n"" ) ; break ; case NGHTTP2_WINDOW_UPDATE : DEBUGF ( ""recv:<S2SV_blank>WINDOW_UPDATE\\n"" ) ; break ; } # endif iframe -> frame . hd . flags = NGHTTP2_FLAG_NONE ; if ( iframe -> payloadleft != 4 ) { busy = 1 ; iframe -> state = NGHTTP2_IB_FRAME_SIZE_ERROR ; break ; } iframe -> state = NGHTTP2_IB_READ_NBYTE ; inbound_frame_set_mark ( iframe , 4 ) ; break ; case NGHTTP2_SETTINGS : DEBUGF ( ""recv:<S2SV_blank>SETTINGS\\n"" ) ; iframe -> frame . hd . flags &= NGHTTP2_FLAG_ACK ; if ( ( iframe -> frame . hd . length % NGHTTP2_FRAME_SETTINGS_ENTRY_LENGTH ) || ( ( iframe -> frame . hd . flags & NGHTTP2_FLAG_ACK ) && iframe -> payloadleft > 0 ) ) { busy = 1 ; iframe -> state = NGHTTP2_IB_FRAME_SIZE_ERROR ; break ; } iframe -> state = NGHTTP2_IB_READ_SETTINGS ; if ( iframe -> payloadleft ) { nghttp2_settings_entry * min_header_table_size_entry ; iframe -> max_niv = iframe -> frame . hd . length / NGHTTP2_FRAME_SETTINGS_ENTRY_LENGTH + 1 ; <S2SV_StartBug> iframe -> iv = nghttp2_mem_malloc ( mem , sizeof ( nghttp2_settings_entry ) * <S2SV_EndBug> iframe -> max_niv ) ; if ( ! iframe -> iv ) { return NGHTTP2_ERR_NOMEM ; } min_header_table_size_entry = & iframe -> iv [ iframe -> max_niv - 1 ] ; min_header_table_size_entry -> settings_id = NGHTTP2_SETTINGS_HEADER_TABLE_SIZE ; min_header_table_size_entry -> value = UINT32_MAX ; inbound_frame_set_mark ( iframe , NGHTTP2_FRAME_SETTINGS_ENTRY_LENGTH ) ; break ; } busy = 1 ; inbound_frame_set_mark ( iframe , 0 ) ; break ; case NGHTTP2_PUSH_PROMISE : DEBUGF ( ""recv:<S2SV_blank>PUSH_PROMISE\\n"" ) ; iframe -> frame . hd . flags &= ( NGHTTP2_FLAG_END_HEADERS | NGHTTP2_FLAG_PADDED ) ; rv = inbound_frame_handle_pad ( iframe , & iframe -> frame . hd ) ; if ( rv < 0 ) { rv = nghttp2_session_terminate_session_with_reason ( session , NGHTTP2_PROTOCOL_ERROR , ""PUSH_PROMISE:<S2SV_blank>insufficient<S2SV_blank>padding<S2SV_blank>space"" ) ; if ( nghttp2_is_fatal ( rv ) ) { return rv ; } return ( ssize_t ) inlen ; } if ( rv == 1 ) { iframe -> state = NGHTTP2_IB_READ_NBYTE ; break ; } if ( iframe -> payloadleft < 4 ) { busy = 1 ; iframe -> state = NGHTTP2_IB_FRAME_SIZE_ERROR ; break ; } iframe -> state = NGHTTP2_IB_READ_NBYTE ; inbound_frame_set_mark ( iframe , 4 ) ; break ; case NGHTTP2_PING : DEBUGF ( ""recv:<S2SV_blank>PING\\n"" ) ; iframe -> frame . hd . flags &= NGHTTP2_FLAG_ACK ; if ( iframe -> payloadleft != 8 ) { busy = 1 ; iframe -> state = NGHTTP2_IB_FRAME_SIZE_ERROR ; break ; } iframe -> state = NGHTTP2_IB_READ_NBYTE ; inbound_frame_set_mark ( iframe , 8 ) ; break ; case NGHTTP2_GOAWAY : DEBUGF ( ""recv:<S2SV_blank>GOAWAY\\n"" ) ; iframe -> frame . hd . flags = NGHTTP2_FLAG_NONE ; if ( iframe -> payloadleft < 8 ) { busy = 1 ; iframe -> state = NGHTTP2_IB_FRAME_SIZE_ERROR ; break ; } iframe -> state = NGHTTP2_IB_READ_NBYTE ; inbound_frame_set_mark ( iframe , 8 ) ; break ; case NGHTTP2_CONTINUATION : DEBUGF ( ""recv:<S2SV_blank>unexpected<S2SV_blank>CONTINUATION\\n"" ) ; rv = nghttp2_session_terminate_session_with_reason ( session , NGHTTP2_PROTOCOL_ERROR , ""CONTINUATION:<S2SV_blank>unexpected"" ) ; if ( nghttp2_is_fatal ( rv ) ) { return rv ; } return ( ssize_t ) inlen ; default : DEBUGF ( ""recv:<S2SV_blank>extension<S2SV_blank>frame\\n"" ) ; if ( check_ext_type_set ( session -> user_recv_ext_types , iframe -> frame . hd . type ) ) { if ( ! session -> callbacks . unpack_extension_callback ) { busy = 1 ; iframe -> state = NGHTTP2_IB_IGN_PAYLOAD ; break ; } busy = 1 ; iframe -> state = NGHTTP2_IB_READ_EXTENSION_PAYLOAD ; break ; } else { switch ( iframe -> frame . hd . type ) { case NGHTTP2_ALTSVC : if ( ( session -> builtin_recv_ext_types & NGHTTP2_TYPEMASK_ALTSVC ) == 0 ) { busy = 1 ; iframe -> state = NGHTTP2_IB_IGN_PAYLOAD ; break ; } DEBUGF ( ""recv:<S2SV_blank>ALTSVC\\n"" ) ; iframe -> frame . hd . flags = NGHTTP2_FLAG_NONE ; iframe -> frame . ext . payload = & iframe -> ext_frame_payload . altsvc ; if ( session -> server ) { busy = 1 ; iframe -> state = NGHTTP2_IB_IGN_PAYLOAD ; break ; } if ( iframe -> payloadleft < 2 ) { busy = 1 ; iframe -> state = NGHTTP2_IB_FRAME_SIZE_ERROR ; break ; } busy = 1 ; iframe -> state = NGHTTP2_IB_READ_NBYTE ; inbound_frame_set_mark ( iframe , 2 ) ; break ; case NGHTTP2_ORIGIN : if ( ! ( session -> builtin_recv_ext_types & NGHTTP2_TYPEMASK_ORIGIN ) ) { busy = 1 ; iframe -> state = NGHTTP2_IB_IGN_PAYLOAD ; break ; } DEBUGF ( ""recv:<S2SV_blank>ORIGIN\\n"" ) ; iframe -> frame . ext . payload = & iframe -> ext_frame_payload . origin ; if ( session -> server || iframe -> frame . hd . stream_id || ( iframe -> frame . hd . flags & 0xf0 ) ) { busy = 1 ; iframe -> state = NGHTTP2_IB_IGN_PAYLOAD ; break ; } iframe -> frame . hd . flags = NGHTTP2_FLAG_NONE ; if ( iframe -> payloadleft ) { iframe -> raw_lbuf = nghttp2_mem_malloc ( mem , iframe -> payloadleft ) ; if ( iframe -> raw_lbuf == NULL ) { return NGHTTP2_ERR_NOMEM ; } nghttp2_buf_wrap_init ( & iframe -> lbuf , iframe -> raw_lbuf , iframe -> payloadleft ) ; } else { busy = 1 ; } iframe -> state = NGHTTP2_IB_READ_ORIGIN_PAYLOAD ; break ; default : busy = 1 ; iframe -> state = NGHTTP2_IB_IGN_PAYLOAD ; break ; } } } if ( ! on_begin_frame_called ) { switch ( iframe -> state ) { case NGHTTP2_IB_IGN_HEADER_BLOCK : case NGHTTP2_IB_IGN_PAYLOAD : case NGHTTP2_IB_FRAME_SIZE_ERROR : case NGHTTP2_IB_IGN_DATA : case NGHTTP2_IB_IGN_ALL : break ; default : rv = session_call_on_begin_frame ( session , & iframe -> frame . hd ) ; if ( nghttp2_is_fatal ( rv ) ) { return rv ; } } } break ; } case NGHTTP2_IB_READ_NBYTE : DEBUGF ( ""recv:<S2SV_blank>[IB_READ_NBYTE]\\n"" ) ; readlen = inbound_frame_buf_read ( iframe , in , last ) ; in += readlen ; iframe -> payloadleft -= readlen ; DEBUGF ( ""recv:<S2SV_blank>readlen=%zu,<S2SV_blank>payloadleft=%zu,<S2SV_blank>left=%zd\\n"" , readlen , iframe -> payloadleft , nghttp2_buf_mark_avail ( & iframe -> sbuf ) ) ; if ( nghttp2_buf_mark_avail ( & iframe -> sbuf ) ) { return in - first ; } switch ( iframe -> frame . hd . type ) { case NGHTTP2_HEADERS : if ( iframe -> padlen == 0 && ( iframe -> frame . hd . flags & NGHTTP2_FLAG_PADDED ) ) { pri_fieldlen = nghttp2_frame_priority_len ( iframe -> frame . hd . flags ) ; padlen = inbound_frame_compute_pad ( iframe ) ; if ( padlen < 0 || ( size_t ) padlen + pri_fieldlen > 1 + iframe -> payloadleft ) { rv = nghttp2_session_terminate_session_with_reason ( session , NGHTTP2_PROTOCOL_ERROR , ""HEADERS:<S2SV_blank>invalid<S2SV_blank>padding"" ) ; if ( nghttp2_is_fatal ( rv ) ) { return rv ; } return ( ssize_t ) inlen ; } iframe -> frame . headers . padlen = ( size_t ) padlen ; if ( pri_fieldlen > 0 ) { if ( iframe -> payloadleft < pri_fieldlen ) { busy = 1 ; iframe -> state = NGHTTP2_IB_FRAME_SIZE_ERROR ; break ; } iframe -> state = NGHTTP2_IB_READ_NBYTE ; inbound_frame_set_mark ( iframe , pri_fieldlen ) ; break ; } else { inbound_frame_set_mark ( iframe , 0 ) ; } } rv = session_process_headers_frame ( session ) ; if ( nghttp2_is_fatal ( rv ) ) { return rv ; } busy = 1 ; if ( iframe -> state == NGHTTP2_IB_IGN_ALL ) { return ( ssize_t ) inlen ; } if ( rv == NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE ) { rv = nghttp2_session_add_rst_stream ( session , iframe -> frame . hd . stream_id , NGHTTP2_INTERNAL_ERROR ) ; if ( nghttp2_is_fatal ( rv ) ) { return rv ; } iframe -> state = NGHTTP2_IB_IGN_HEADER_BLOCK ; break ; } if ( rv == NGHTTP2_ERR_IGN_HEADER_BLOCK ) { iframe -> state = NGHTTP2_IB_IGN_HEADER_BLOCK ; break ; } iframe -> state = NGHTTP2_IB_READ_HEADER_BLOCK ; break ; case NGHTTP2_PRIORITY : rv = session_process_priority_frame ( session ) ; if ( nghttp2_is_fatal ( rv ) ) { return rv ; } if ( iframe -> state == NGHTTP2_IB_IGN_ALL ) { return ( ssize_t ) inlen ; } session_inbound_frame_reset ( session ) ; break ; case NGHTTP2_RST_STREAM : rv = session_process_rst_stream_frame ( session ) ; if ( nghttp2_is_fatal ( rv ) ) { return rv ; } if ( iframe -> state == NGHTTP2_IB_IGN_ALL ) { return ( ssize_t ) inlen ; } session_inbound_frame_reset ( session ) ; break ; case NGHTTP2_PUSH_PROMISE : if ( iframe -> padlen == 0 && ( iframe -> frame . hd . flags & NGHTTP2_FLAG_PADDED ) ) { padlen = inbound_frame_compute_pad ( iframe ) ; if ( padlen < 0 || ( size_t ) padlen + 4 > 1 + iframe -> payloadleft ) { rv = nghttp2_session_terminate_session_with_reason ( session , NGHTTP2_PROTOCOL_ERROR , ""PUSH_PROMISE:<S2SV_blank>invalid<S2SV_blank>padding"" ) ; if ( nghttp2_is_fatal ( rv ) ) { return rv ; } return ( ssize_t ) inlen ; } iframe -> frame . push_promise . padlen = ( size_t ) padlen ; if ( iframe -> payloadleft < 4 ) { busy = 1 ; iframe -> state = NGHTTP2_IB_FRAME_SIZE_ERROR ; break ; } iframe -> state = NGHTTP2_IB_READ_NBYTE ; inbound_frame_set_mark ( iframe , 4 ) ; break ; } rv = session_process_push_promise_frame ( session ) ; if ( nghttp2_is_fatal ( rv ) ) { return rv ; } busy = 1 ; if ( iframe -> state == NGHTTP2_IB_IGN_ALL ) { return ( ssize_t ) inlen ; } if ( rv == NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE ) { rv = nghttp2_session_add_rst_stream ( session , iframe -> frame . push_promise . promised_stream_id , NGHTTP2_INTERNAL_ERROR ) ; if ( nghttp2_is_fatal ( rv ) ) { return rv ; } iframe -> state = NGHTTP2_IB_IGN_HEADER_BLOCK ; break ; } if ( rv == NGHTTP2_ERR_IGN_HEADER_BLOCK ) { iframe -> state = NGHTTP2_IB_IGN_HEADER_BLOCK ; break ; } iframe -> state = NGHTTP2_IB_READ_HEADER_BLOCK ; break ; case NGHTTP2_PING : rv = session_process_ping_frame ( session ) ; if ( nghttp2_is_fatal ( rv ) ) { return rv ; } if ( iframe -> state == NGHTTP2_IB_IGN_ALL ) { return ( ssize_t ) inlen ; } session_inbound_frame_reset ( session ) ; break ; case NGHTTP2_GOAWAY : { size_t debuglen ; debuglen = iframe -> frame . hd . length - 8 ; if ( debuglen > 0 ) { iframe -> raw_lbuf = nghttp2_mem_malloc ( mem , debuglen ) ; if ( iframe -> raw_lbuf == NULL ) { return NGHTTP2_ERR_NOMEM ; } nghttp2_buf_wrap_init ( & iframe -> lbuf , iframe -> raw_lbuf , debuglen ) ; } busy = 1 ; iframe -> state = NGHTTP2_IB_READ_GOAWAY_DEBUG ; break ; } case NGHTTP2_WINDOW_UPDATE : rv = session_process_window_update_frame ( session ) ; if ( nghttp2_is_fatal ( rv ) ) { return rv ; } if ( iframe -> state == NGHTTP2_IB_IGN_ALL ) { return ( ssize_t ) inlen ; } session_inbound_frame_reset ( session ) ; break ; case NGHTTP2_ALTSVC : { size_t origin_len ; origin_len = nghttp2_get_uint16 ( iframe -> sbuf . pos ) ; DEBUGF ( ""recv:<S2SV_blank>origin_len=%zu\\n"" , origin_len ) ; if ( origin_len > iframe -> payloadleft ) { busy = 1 ; iframe -> state = NGHTTP2_IB_FRAME_SIZE_ERROR ; break ; } if ( iframe -> frame . hd . length > 2 ) { iframe -> raw_lbuf = nghttp2_mem_malloc ( mem , iframe -> frame . hd . length - 2 ) ; if ( iframe -> raw_lbuf == NULL ) { return NGHTTP2_ERR_NOMEM ; } nghttp2_buf_wrap_init ( & iframe -> lbuf , iframe -> raw_lbuf , iframe -> frame . hd . length ) ; } busy = 1 ; iframe -> state = NGHTTP2_IB_READ_ALTSVC_PAYLOAD ; break ; } default : session_inbound_frame_reset ( session ) ; break ; } break ; case NGHTTP2_IB_READ_HEADER_BLOCK : case NGHTTP2_IB_IGN_HEADER_BLOCK : { ssize_t data_readlen ; size_t trail_padlen ; int final ; # ifdef DEBUGBUILD if ( iframe -> state == NGHTTP2_IB_READ_HEADER_BLOCK ) { DEBUGF ( ""recv:<S2SV_blank>[IB_READ_HEADER_BLOCK]\\n"" ) ; } else { DEBUGF ( ""recv:<S2SV_blank>[IB_IGN_HEADER_BLOCK]\\n"" ) ; } # endif readlen = inbound_frame_payload_readlen ( iframe , in , last ) ; DEBUGF ( ""recv:<S2SV_blank>readlen=%zu,<S2SV_blank>payloadleft=%zu\\n"" , readlen , iframe -> payloadleft - readlen ) ; data_readlen = inbound_frame_effective_readlen ( iframe , iframe -> payloadleft - readlen , readlen ) ; if ( data_readlen == - 1 ) { data_readlen = 0 ; } trail_padlen = nghttp2_frame_trail_padlen ( & iframe -> frame , iframe -> padlen ) ; final = ( iframe -> frame . hd . flags & NGHTTP2_FLAG_END_HEADERS ) && iframe -> payloadleft - ( size_t ) data_readlen == trail_padlen ; if ( data_readlen > 0 || ( data_readlen == 0 && final ) ) { size_t hd_proclen = 0 ; DEBUGF ( ""recv:<S2SV_blank>block<S2SV_blank>final=%d\\n"" , final ) ; rv = inflate_header_block ( session , & iframe -> frame , & hd_proclen , ( uint8_t * ) in , ( size_t ) data_readlen , final , iframe -> state == NGHTTP2_IB_READ_HEADER_BLOCK ) ; if ( nghttp2_is_fatal ( rv ) ) { return rv ; } if ( iframe -> state == NGHTTP2_IB_IGN_ALL ) { return ( ssize_t ) inlen ; } if ( rv == NGHTTP2_ERR_PAUSE ) { in += hd_proclen ; iframe -> payloadleft -= hd_proclen ; return in - first ; } if ( rv == NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE ) { in += hd_proclen ; iframe -> payloadleft -= hd_proclen ; rv = nghttp2_session_add_rst_stream ( session , iframe -> frame . hd . type == NGHTTP2_PUSH_PROMISE ? iframe -> frame . push_promise . promised_stream_id : iframe -> frame . hd . stream_id , NGHTTP2_INTERNAL_ERROR ) ; if ( nghttp2_is_fatal ( rv ) ) { return rv ; } busy = 1 ; iframe -> state = NGHTTP2_IB_IGN_HEADER_BLOCK ; break ; } in += readlen ; iframe -> payloadleft -= readlen ; if ( rv == NGHTTP2_ERR_HEADER_COMP ) { if ( iframe -> payloadleft == 0 ) { session_inbound_frame_reset ( session ) ; } else { busy = 1 ; iframe -> state = NGHTTP2_IB_IGN_PAYLOAD ; } break ; } } else { in += readlen ; iframe -> payloadleft -= readlen ; } if ( iframe -> payloadleft ) { break ; } if ( ( iframe -> frame . hd . flags & NGHTTP2_FLAG_END_HEADERS ) == 0 ) { inbound_frame_set_mark ( iframe , NGHTTP2_FRAME_HDLEN ) ; iframe -> padlen = 0 ; if ( iframe -> state == NGHTTP2_IB_READ_HEADER_BLOCK ) { iframe -> state = NGHTTP2_IB_EXPECT_CONTINUATION ; } else { iframe -> state = NGHTTP2_IB_IGN_CONTINUATION ; } } else { if ( iframe -> state == NGHTTP2_IB_READ_HEADER_BLOCK ) { rv = session_after_header_block_received ( session ) ; if ( nghttp2_is_fatal ( rv ) ) { return rv ; } } session_inbound_frame_reset ( session ) ; } break ; } case NGHTTP2_IB_IGN_PAYLOAD : DEBUGF ( ""recv:<S2SV_blank>[IB_IGN_PAYLOAD]\\n"" ) ; readlen = inbound_frame_payload_readlen ( iframe , in , last ) ; iframe -> payloadleft -= readlen ; in += readlen ; DEBUGF ( ""recv:<S2SV_blank>readlen=%zu,<S2SV_blank>payloadleft=%zu\\n"" , readlen , iframe -> payloadleft ) ; if ( iframe -> payloadleft ) { break ; } switch ( iframe -> frame . hd . type ) { case NGHTTP2_HEADERS : case NGHTTP2_PUSH_PROMISE : case NGHTTP2_CONTINUATION : session -> hd_inflater . ctx . bad = 1 ; break ; default : break ; } session_inbound_frame_reset ( session ) ; break ; case NGHTTP2_IB_FRAME_SIZE_ERROR : DEBUGF ( ""recv:<S2SV_blank>[IB_FRAME_SIZE_ERROR]\\n"" ) ; rv = session_handle_frame_size_error ( session ) ; if ( nghttp2_is_fatal ( rv ) ) { return rv ; } assert ( iframe -> state == NGHTTP2_IB_IGN_ALL ) ; return ( ssize_t ) inlen ; case NGHTTP2_IB_READ_SETTINGS : DEBUGF ( ""recv:<S2SV_blank>[IB_READ_SETTINGS]\\n"" ) ; readlen = inbound_frame_buf_read ( iframe , in , last ) ; iframe -> payloadleft -= readlen ; in += readlen ; DEBUGF ( ""recv:<S2SV_blank>readlen=%zu,<S2SV_blank>payloadleft=%zu\\n"" , readlen , iframe -> payloadleft ) ; if ( nghttp2_buf_mark_avail ( & iframe -> sbuf ) ) { break ; } if ( readlen > 0 ) { inbound_frame_set_settings_entry ( iframe ) ; } if ( iframe -> payloadleft ) { inbound_frame_set_mark ( iframe , NGHTTP2_FRAME_SETTINGS_ENTRY_LENGTH ) ; break ; } rv = session_process_settings_frame ( session ) ; if ( nghttp2_is_fatal ( rv ) ) { return rv ; } if ( iframe -> state == NGHTTP2_IB_IGN_ALL ) { return ( ssize_t ) inlen ; } session_inbound_frame_reset ( session ) ; break ; case NGHTTP2_IB_READ_GOAWAY_DEBUG : DEBUGF ( ""recv:<S2SV_blank>[IB_READ_GOAWAY_DEBUG]\\n"" ) ; readlen = inbound_frame_payload_readlen ( iframe , in , last ) ; if ( readlen > 0 ) { iframe -> lbuf . last = nghttp2_cpymem ( iframe -> lbuf . last , in , readlen ) ; iframe -> payloadleft -= readlen ; in += readlen ; } DEBUGF ( ""recv:<S2SV_blank>readlen=%zu,<S2SV_blank>payloadleft=%zu\\n"" , readlen , iframe -> payloadleft ) ; if ( iframe -> payloadleft ) { assert ( nghttp2_buf_avail ( & iframe -> lbuf ) > 0 ) ; break ; } rv = session_process_goaway_frame ( session ) ; if ( nghttp2_is_fatal ( rv ) ) { return rv ; } if ( iframe -> state == NGHTTP2_IB_IGN_ALL ) { return ( ssize_t ) inlen ; } session_inbound_frame_reset ( session ) ; break ; case NGHTTP2_IB_EXPECT_CONTINUATION : case NGHTTP2_IB_IGN_CONTINUATION : # ifdef DEBUGBUILD if ( iframe -> state == NGHTTP2_IB_EXPECT_CONTINUATION ) { fprintf ( stderr , ""recv:<S2SV_blank>[IB_EXPECT_CONTINUATION]\\n"" ) ; } else { fprintf ( stderr , ""recv:<S2SV_blank>[IB_IGN_CONTINUATION]\\n"" ) ; } # endif readlen = inbound_frame_buf_read ( iframe , in , last ) ; in += readlen ; if ( nghttp2_buf_mark_avail ( & iframe -> sbuf ) ) { return in - first ; } nghttp2_frame_unpack_frame_hd ( & cont_hd , iframe -> sbuf . pos ) ; iframe -> payloadleft = cont_hd . length ; DEBUGF ( ""recv:<S2SV_blank>payloadlen=%zu,<S2SV_blank>type=%u,<S2SV_blank>flags=0x%02x,<S2SV_blank>stream_id=%d\\n"" , cont_hd . length , cont_hd . type , cont_hd . flags , cont_hd . stream_id ) ; if ( cont_hd . type != NGHTTP2_CONTINUATION || cont_hd . stream_id != iframe -> frame . hd . stream_id ) { DEBUGF ( ""recv:<S2SV_blank>expected<S2SV_blank>stream_id=%d,<S2SV_blank>type=%d,<S2SV_blank>but<S2SV_blank>got<S2SV_blank>stream_id=%d,<S2SV_blank>"" ""type=%u\\n"" , iframe -> frame . hd . stream_id , NGHTTP2_CONTINUATION , cont_hd . stream_id , cont_hd . type ) ; rv = nghttp2_session_terminate_session_with_reason ( session , NGHTTP2_PROTOCOL_ERROR , ""unexpected<S2SV_blank>non-CONTINUATION<S2SV_blank>frame<S2SV_blank>or<S2SV_blank>stream_id<S2SV_blank>is<S2SV_blank>invalid"" ) ; if ( nghttp2_is_fatal ( rv ) ) { return rv ; } return ( ssize_t ) inlen ; } iframe -> frame . hd . flags = ( uint8_t ) ( iframe -> frame . hd . flags | ( cont_hd . flags & NGHTTP2_FLAG_END_HEADERS ) ) ; iframe -> frame . hd . length += cont_hd . length ; busy = 1 ; if ( iframe -> state == NGHTTP2_IB_EXPECT_CONTINUATION ) { iframe -> state = NGHTTP2_IB_READ_HEADER_BLOCK ; rv = session_call_on_begin_frame ( session , & cont_hd ) ; if ( nghttp2_is_fatal ( rv ) ) { return rv ; } } else { iframe -> state = NGHTTP2_IB_IGN_HEADER_BLOCK ; } break ; case NGHTTP2_IB_READ_PAD_DATA : DEBUGF ( ""recv:<S2SV_blank>[IB_READ_PAD_DATA]\\n"" ) ; readlen = inbound_frame_buf_read ( iframe , in , last ) ; in += readlen ; iframe -> payloadleft -= readlen ; DEBUGF ( ""recv:<S2SV_blank>readlen=%zu,<S2SV_blank>payloadleft=%zu,<S2SV_blank>left=%zu\\n"" , readlen , iframe -> payloadleft , nghttp2_buf_mark_avail ( & iframe -> sbuf ) ) ; if ( nghttp2_buf_mark_avail ( & iframe -> sbuf ) ) { return in - first ; } rv = nghttp2_session_update_recv_connection_window_size ( session , readlen ) ; if ( nghttp2_is_fatal ( rv ) ) { return rv ; } if ( iframe -> state == NGHTTP2_IB_IGN_ALL ) { return ( ssize_t ) inlen ; } rv = nghttp2_session_consume ( session , iframe -> frame . hd . stream_id , readlen ) ; if ( nghttp2_is_fatal ( rv ) ) { return rv ; } if ( iframe -> state == NGHTTP2_IB_IGN_ALL ) { return ( ssize_t ) inlen ; } stream = nghttp2_session_get_stream ( session , iframe -> frame . hd . stream_id ) ; if ( stream ) { rv = nghttp2_session_update_recv_stream_window_size ( session , stream , readlen , iframe -> payloadleft || ( iframe -> frame . hd . flags & NGHTTP2_FLAG_END_STREAM ) == 0 ) ; if ( nghttp2_is_fatal ( rv ) ) { return rv ; } } busy = 1 ; padlen = inbound_frame_compute_pad ( iframe ) ; if ( padlen < 0 ) { rv = nghttp2_session_terminate_session_with_reason ( session , NGHTTP2_PROTOCOL_ERROR , ""DATA:<S2SV_blank>invalid<S2SV_blank>padding"" ) ; if ( nghttp2_is_fatal ( rv ) ) { return rv ; } return ( ssize_t ) inlen ; } iframe -> frame . data . padlen = ( size_t ) padlen ; iframe -> state = NGHTTP2_IB_READ_DATA ; break ; case NGHTTP2_IB_READ_DATA : stream = nghttp2_session_get_stream ( session , iframe -> frame . hd . stream_id ) ; if ( ! stream ) { busy = 1 ; iframe -> state = NGHTTP2_IB_IGN_DATA ; break ; } DEBUGF ( ""recv:<S2SV_blank>[IB_READ_DATA]\\n"" ) ; readlen = inbound_frame_payload_readlen ( iframe , in , last ) ; iframe -> payloadleft -= readlen ; in += readlen ; DEBUGF ( ""recv:<S2SV_blank>readlen=%zu,<S2SV_blank>payloadleft=%zu\\n"" , readlen , iframe -> payloadleft ) ; if ( readlen > 0 ) { ssize_t data_readlen ; rv = nghttp2_session_update_recv_connection_window_size ( session , readlen ) ; if ( nghttp2_is_fatal ( rv ) ) { return rv ; } if ( iframe -> state == NGHTTP2_IB_IGN_ALL ) { return ( ssize_t ) inlen ; } rv = nghttp2_session_update_recv_stream_window_size ( session , stream , readlen , iframe -> payloadleft || ( iframe -> frame . hd . flags & NGHTTP2_FLAG_END_STREAM ) == 0 ) ; if ( nghttp2_is_fatal ( rv ) ) { return rv ; } data_readlen = inbound_frame_effective_readlen ( iframe , iframe -> payloadleft , readlen ) ; if ( data_readlen == - 1 ) { data_readlen = 0 ; } padlen = ( ssize_t ) readlen - data_readlen ; if ( padlen > 0 ) { rv = nghttp2_session_consume ( session , iframe -> frame . hd . stream_id , ( size_t ) padlen ) ; if ( nghttp2_is_fatal ( rv ) ) { return rv ; } if ( iframe -> state == NGHTTP2_IB_IGN_ALL ) { return ( ssize_t ) inlen ; } } DEBUGF ( ""recv:<S2SV_blank>data_readlen=%zd\\n"" , data_readlen ) ; if ( data_readlen > 0 ) { if ( session_enforce_http_messaging ( session ) ) { if ( nghttp2_http_on_data_chunk ( stream , ( size_t ) data_readlen ) != 0 ) { if ( session -> opt_flags & NGHTTP2_OPTMASK_NO_AUTO_WINDOW_UPDATE ) { rv = session_update_connection_consumed_size ( session , ( size_t ) data_readlen ) ; if ( nghttp2_is_fatal ( rv ) ) { return rv ; } if ( iframe -> state == NGHTTP2_IB_IGN_DATA ) { return ( ssize_t ) inlen ; } } rv = nghttp2_session_add_rst_stream ( session , iframe -> frame . hd . stream_id , NGHTTP2_PROTOCOL_ERROR ) ; if ( nghttp2_is_fatal ( rv ) ) { return rv ; } busy = 1 ; iframe -> state = NGHTTP2_IB_IGN_DATA ; break ; } } if ( session -> callbacks . on_data_chunk_recv_callback ) { rv = session -> callbacks . on_data_chunk_recv_callback ( session , iframe -> frame . hd . flags , iframe -> frame . hd . stream_id , in - readlen , ( size_t ) data_readlen , session -> user_data ) ; if ( rv == NGHTTP2_ERR_PAUSE ) { return in - first ; } if ( nghttp2_is_fatal ( rv ) ) { return NGHTTP2_ERR_CALLBACK_FAILURE ; } } } } if ( iframe -> payloadleft ) { break ; } rv = session_process_data_frame ( session ) ; if ( nghttp2_is_fatal ( rv ) ) { return rv ; } session_inbound_frame_reset ( session ) ; break ; case NGHTTP2_IB_IGN_DATA : DEBUGF ( ""recv:<S2SV_blank>[IB_IGN_DATA]\\n"" ) ; readlen = inbound_frame_payload_readlen ( iframe , in , last ) ; iframe -> payloadleft -= readlen ; in += readlen ; DEBUGF ( ""recv:<S2SV_blank>readlen=%zu,<S2SV_blank>payloadleft=%zu\\n"" , readlen , iframe -> payloadleft ) ; if ( readlen > 0 ) { rv = nghttp2_session_update_recv_connection_window_size ( session , readlen ) ; if ( nghttp2_is_fatal ( rv ) ) { return rv ; } if ( iframe -> state == NGHTTP2_IB_IGN_ALL ) { return ( ssize_t ) inlen ; } if ( session -> opt_flags & NGHTTP2_OPTMASK_NO_AUTO_WINDOW_UPDATE ) { rv = session_update_connection_consumed_size ( session , readlen ) ; if ( nghttp2_is_fatal ( rv ) ) { return rv ; } if ( iframe -> state == NGHTTP2_IB_IGN_ALL ) { return ( ssize_t ) inlen ; } } } if ( iframe -> payloadleft ) { break ; } session_inbound_frame_reset ( session ) ; break ; case NGHTTP2_IB_IGN_ALL : return ( ssize_t ) inlen ; case NGHTTP2_IB_READ_EXTENSION_PAYLOAD : DEBUGF ( ""recv:<S2SV_blank>[IB_READ_EXTENSION_PAYLOAD]\\n"" ) ; readlen = inbound_frame_payload_readlen ( iframe , in , last ) ; iframe -> payloadleft -= readlen ; in += readlen ; DEBUGF ( ""recv:<S2SV_blank>readlen=%zu,<S2SV_blank>payloadleft=%zu\\n"" , readlen , iframe -> payloadleft ) ; if ( readlen > 0 ) { rv = session_call_on_extension_chunk_recv_callback ( session , in - readlen , readlen ) ; if ( nghttp2_is_fatal ( rv ) ) { return rv ; } if ( rv != 0 ) { busy = 1 ; iframe -> state = NGHTTP2_IB_IGN_PAYLOAD ; break ; } } if ( iframe -> payloadleft > 0 ) { break ; } rv = session_process_extension_frame ( session ) ; if ( nghttp2_is_fatal ( rv ) ) { return rv ; } session_inbound_frame_reset ( session ) ; break ; case NGHTTP2_IB_READ_ALTSVC_PAYLOAD : DEBUGF ( ""recv:<S2SV_blank>[IB_READ_ALTSVC_PAYLOAD]\\n"" ) ; readlen = inbound_frame_payload_readlen ( iframe , in , last ) ; if ( readlen > 0 ) { iframe -> lbuf . last = nghttp2_cpymem ( iframe -> lbuf . last , in , readlen ) ; iframe -> payloadleft -= readlen ; in += readlen ; } DEBUGF ( ""recv:<S2SV_blank>readlen=%zu,<S2SV_blank>payloadleft=%zu\\n"" , readlen , iframe -> payloadleft ) ; if ( iframe -> payloadleft ) { assert ( nghttp2_buf_avail ( & iframe -> lbuf ) > 0 ) ; break ; } rv = session_process_altsvc_frame ( session ) ; if ( nghttp2_is_fatal ( rv ) ) { return rv ; } session_inbound_frame_reset ( session ) ; break ; case NGHTTP2_IB_READ_ORIGIN_PAYLOAD : DEBUGF ( ""recv:<S2SV_blank>[IB_READ_ORIGIN_PAYLOAD]\\n"" ) ; readlen = inbound_frame_payload_readlen ( iframe , in , last ) ; if ( readlen > 0 ) { iframe -> lbuf . last = nghttp2_cpymem ( iframe -> lbuf . last , in , readlen ) ; iframe -> payloadleft -= readlen ; in += readlen ; } DEBUGF ( ""recv:<S2SV_blank>readlen=%zu,<S2SV_blank>payloadleft=%zu\\n"" , readlen , iframe -> payloadleft ) ; if ( iframe -> payloadleft ) { assert ( nghttp2_buf_avail ( & iframe -> lbuf ) > 0 ) ; break ; } rv = session_process_origin_frame ( session ) ; if ( nghttp2_is_fatal ( rv ) ) { return rv ; } if ( iframe -> state == NGHTTP2_IB_IGN_ALL ) { return ( ssize_t ) inlen ; } session_inbound_frame_reset ( session ) ; break ; } if ( ! busy && in == last ) { break ; } busy = 0 ; } assert ( in == last ) ; return in - first ; }","+ 1 ; if ( iframe -> max_niv - 1 > session -> max_settings ) { rv = nghttp2_session_terminate_session_with_reason ( session , NGHTTP2_ENHANCE_YOUR_CALM , ""SETTINGS:<S2SV_blank>too<S2SV_blank>many<S2SV_blank>setting<S2SV_blank>entries"" ) ; if ( nghttp2_is_fatal ( rv ) ) { return rv ; } return ( ssize_t ) inlen ; }"
11,"STATIC int xfs_ioctl_setattr ( xfs_inode_t * ip , struct fsxattr * fa , int mask ) { struct xfs_mount * mp = ip -> i_mount ; struct xfs_trans * tp ; unsigned int lock_flags = 0 ; struct xfs_dquot * udqp = NULL ; struct xfs_dquot * pdqp = NULL ; struct xfs_dquot * olddquot = NULL ; int code ; trace_xfs_ioctl_setattr ( ip ) ; if ( mp -> m_flags & XFS_MOUNT_RDONLY ) return XFS_ERROR ( EROFS ) ; if ( XFS_FORCED_SHUTDOWN ( mp ) ) return XFS_ERROR ( EIO ) ; if ( ( mask & FSX_PROJID ) && ( fa -> fsx_projid > ( __uint16_t ) - 1 ) && ! xfs_sb_version_hasprojid32bit ( & ip -> i_mount -> m_sb ) ) return XFS_ERROR ( EINVAL ) ; if ( XFS_IS_QUOTA_ON ( mp ) && ( mask & FSX_PROJID ) ) { code = xfs_qm_vop_dqalloc ( ip , ip -> i_d . di_uid , ip -> i_d . di_gid , fa -> fsx_projid , XFS_QMOPT_PQUOTA , & udqp , NULL , & pdqp ) ; if ( code ) return code ; } tp = xfs_trans_alloc ( mp , XFS_TRANS_SETATTR_NOT_SIZE ) ; code = xfs_trans_reserve ( tp , & M_RES ( mp ) -> tr_ichange , 0 , 0 ) ; if ( code ) goto error_return ; lock_flags = XFS_ILOCK_EXCL ; xfs_ilock ( ip , lock_flags ) ; if ( ! inode_owner_or_capable ( VFS_I ( ip ) ) ) { code = XFS_ERROR ( EPERM ) ; goto error_return ; } if ( mask & FSX_PROJID ) { if ( current_user_ns ( ) != & init_user_ns ) { code = XFS_ERROR ( EINVAL ) ; goto error_return ; } if ( XFS_IS_QUOTA_RUNNING ( mp ) && XFS_IS_PQUOTA_ON ( mp ) && xfs_get_projid ( ip ) != fa -> fsx_projid ) { ASSERT ( tp ) ; code = xfs_qm_vop_chown_reserve ( tp , ip , udqp , NULL , pdqp , capable ( CAP_FOWNER ) ? XFS_QMOPT_FORCE_RES : 0 ) ; if ( code ) goto error_return ; } } if ( mask & FSX_EXTSIZE ) { if ( ip -> i_d . di_nextents && ( ( ip -> i_d . di_extsize << mp -> m_sb . sb_blocklog ) != fa -> fsx_extsize ) ) { code = XFS_ERROR ( EINVAL ) ; goto error_return ; } if ( fa -> fsx_extsize != 0 ) { xfs_extlen_t size ; xfs_fsblock_t extsize_fsb ; extsize_fsb = XFS_B_TO_FSB ( mp , fa -> fsx_extsize ) ; if ( extsize_fsb > MAXEXTLEN ) { code = XFS_ERROR ( EINVAL ) ; goto error_return ; } if ( XFS_IS_REALTIME_INODE ( ip ) || ( ( mask & FSX_XFLAGS ) && ( fa -> fsx_xflags & XFS_XFLAG_REALTIME ) ) ) { size = mp -> m_sb . sb_rextsize << mp -> m_sb . sb_blocklog ; } else { size = mp -> m_sb . sb_blocksize ; if ( extsize_fsb > mp -> m_sb . sb_agblocks / 2 ) { code = XFS_ERROR ( EINVAL ) ; goto error_return ; } } if ( fa -> fsx_extsize % size ) { code = XFS_ERROR ( EINVAL ) ; goto error_return ; } } } if ( mask & FSX_XFLAGS ) { if ( ( ip -> i_d . di_nextents || ip -> i_delayed_blks ) && ( XFS_IS_REALTIME_INODE ( ip ) ) != ( fa -> fsx_xflags & XFS_XFLAG_REALTIME ) ) { code = XFS_ERROR ( EINVAL ) ; goto error_return ; } if ( ( fa -> fsx_xflags & XFS_XFLAG_REALTIME ) ) { if ( ( mp -> m_sb . sb_rblocks == 0 ) || ( mp -> m_sb . sb_rextsize == 0 ) || ( ip -> i_d . di_extsize % mp -> m_sb . sb_rextsize ) ) { code = XFS_ERROR ( EINVAL ) ; goto error_return ; } } if ( ( ip -> i_d . di_flags & ( XFS_DIFLAG_IMMUTABLE | XFS_DIFLAG_APPEND ) || ( fa -> fsx_xflags & ( XFS_XFLAG_IMMUTABLE | XFS_XFLAG_APPEND ) ) ) && ! capable ( CAP_LINUX_IMMUTABLE ) ) { code = XFS_ERROR ( EPERM ) ; goto error_return ; } } xfs_trans_ijoin ( tp , ip , 0 ) ; if ( mask & FSX_PROJID ) { if ( ( ip -> i_d . di_mode & ( S_ISUID | S_ISGID ) ) && <S2SV_StartBug> ! inode_capable ( VFS_I ( ip ) , CAP_FSETID ) ) <S2SV_EndBug> ip -> i_d . di_mode &= ~ ( S_ISUID | S_ISGID ) ; if ( xfs_get_projid ( ip ) != fa -> fsx_projid ) { if ( XFS_IS_QUOTA_RUNNING ( mp ) && XFS_IS_PQUOTA_ON ( mp ) ) { olddquot = xfs_qm_vop_chown ( tp , ip , & ip -> i_pdquot , pdqp ) ; } xfs_set_projid ( ip , fa -> fsx_projid ) ; if ( ip -> i_d . di_version == 1 ) xfs_bump_ino_vers2 ( tp , ip ) ; } } if ( mask & FSX_EXTSIZE ) ip -> i_d . di_extsize = fa -> fsx_extsize >> mp -> m_sb . sb_blocklog ; if ( mask & FSX_XFLAGS ) { xfs_set_diflags ( ip , fa -> fsx_xflags ) ; xfs_diflags_to_linux ( ip ) ; } xfs_trans_ichgtime ( tp , ip , XFS_ICHGTIME_CHG ) ; xfs_trans_log_inode ( tp , ip , XFS_ILOG_CORE ) ; XFS_STATS_INC ( xs_ig_attrchg ) ; if ( mp -> m_flags & XFS_MOUNT_WSYNC ) xfs_trans_set_sync ( tp ) ; code = xfs_trans_commit ( tp , 0 ) ; xfs_iunlock ( ip , lock_flags ) ; xfs_qm_dqrele ( olddquot ) ; xfs_qm_dqrele ( udqp ) ; xfs_qm_dqrele ( pdqp ) ; return code ; error_return : xfs_qm_dqrele ( udqp ) ; xfs_qm_dqrele ( pdqp ) ; xfs_trans_cancel ( tp , 0 ) ; if ( lock_flags ) xfs_iunlock ( ip , lock_flags ) ; return code ; }",) && ! capable_wrt_inode_uidgid <S2SV_ModEnd> ( VFS_I (
12,"static struct nfs4_state * nfs4_opendata_to_nfs4_state ( struct nfs4_opendata * data ) { struct inode * inode ; struct nfs4_state * state = NULL ; struct nfs_delegation * delegation ; int ret ; if ( ! data -> rpc_done ) { state = nfs4_try_open_cached ( data ) ; goto out ; } ret = - EAGAIN ; if ( ! ( data -> f_attr . valid & NFS_ATTR_FATTR ) ) goto err ; inode = nfs_fhget ( data -> dir -> d_sb , & data -> o_res . fh , & data -> f_attr ) ; ret = PTR_ERR ( inode ) ; if ( IS_ERR ( inode ) ) goto err ; ret = - ENOMEM ; state = nfs4_get_open_state ( inode , data -> owner ) ; if ( state == NULL ) goto err_put_inode ; if ( data -> o_res . delegation_type != 0 ) { int delegation_flags = 0 ; rcu_read_lock ( ) ; delegation = rcu_dereference ( NFS_I ( inode ) -> delegation ) ; if ( delegation ) delegation_flags = delegation -> flags ; rcu_read_unlock ( ) ; if ( ( delegation_flags & 1UL << NFS_DELEGATION_NEED_RECLAIM ) == 0 ) nfs_inode_set_delegation ( state -> inode , data -> owner -> so_cred , & data -> o_res ) ; else nfs_inode_reclaim_delegation ( state -> inode , data -> owner -> so_cred , & data -> o_res ) ; } update_open_stateid ( state , & data -> o_res . stateid , NULL , <S2SV_StartBug> data -> o_arg . open_flags ) ; <S2SV_EndBug> iput ( inode ) ; out : return state ; err_put_inode : iput ( inode ) ; err : return ERR_PTR ( ret ) ; }",-> o_arg . fmode <S2SV_ModEnd> ) ; iput
13,"static MagickBooleanType GetEXIFProperty ( const Image * image , const char * property , ExceptionInfo * exception ) { # define MaxDirectoryStack 16 # define EXIF_DELIMITER ""\\n"" # define EXIF_NUM_FORMATS 12 # define EXIF_FMT_BYTE 1 # define EXIF_FMT_STRING 2 # define EXIF_FMT_USHORT 3 # define EXIF_FMT_ULONG 4 # define EXIF_FMT_URATIONAL 5 # define EXIF_FMT_SBYTE 6 # define EXIF_FMT_UNDEFINED 7 # define EXIF_FMT_SSHORT 8 # define EXIF_FMT_SLONG 9 # define EXIF_FMT_SRATIONAL 10 # define EXIF_FMT_SINGLE 11 # define EXIF_FMT_DOUBLE 12 # define TAG_EXIF_OFFSET 0x8769 # define TAG_GPS_OFFSET 0x8825 # define TAG_INTEROP_OFFSET 0xa005 <S2SV_StartBug> # define EXIFMultipleValues ( size , format , arg ) { ssize_t component ; size_t length ; unsigned char * p1 ; length = 0 ; p1 = p ; for ( component = 0 ; component < components ; component ++ ) { length += FormatLocaleString ( buffer + length , MagickPathExtent - length , format "",<S2SV_blank>"" , arg ) ; if ( length >= ( MagickPathExtent - 1 ) ) length = MagickPathExtent - 1 ; p1 += size ; } if ( length > 1 ) buffer [ length - 2 ] = '\\0' ; value = AcquireString ( buffer ) ; } <S2SV_EndBug> <S2SV_StartBug> # define EXIFMultipleFractions ( size , format , arg1 , arg2 ) { ssize_t component ; size_t length ; unsigned char * p1 ; length = 0 ; p1 = p ; for ( component = 0 ; component < components ; component ++ ) { length += FormatLocaleString ( buffer + length , MagickPathExtent - length , format "",<S2SV_blank>"" , ( arg1 ) , ( arg2 ) ) ; if ( length >= ( MagickPathExtent - 1 ) ) length = MagickPathExtent - 1 ; p1 += size ; } if ( length > 1 ) buffer [ length - 2 ] = '\\0' ; value = AcquireString ( buffer ) ; } <S2SV_EndBug> typedef struct _DirectoryInfo { const unsigned char * directory ; size_t entry ; ssize_t offset ; } DirectoryInfo ; typedef struct _TagInfo { size_t tag ; const char * description ; } TagInfo ; static TagInfo EXIFTag [ ] = { { 0x001 , ""exif:InteroperabilityIndex"" } , { 0x002 , ""exif:InteroperabilityVersion"" } , { 0x100 , ""exif:ImageWidth"" } , { 0x101 , ""exif:ImageLength"" } , { 0x102 , ""exif:BitsPerSample"" } , { 0x103 , ""exif:Compression"" } , { 0x106 , ""exif:PhotometricInterpretation"" } , { 0x10a , ""exif:FillOrder"" } , { 0x10d , ""exif:DocumentName"" } , { 0x10e , ""exif:ImageDescription"" } , { 0x10f , ""exif:Make"" } , { 0x110 , ""exif:Model"" } , { 0x111 , ""exif:StripOffsets"" } , { 0x112 , ""exif:Orientation"" } , { 0x115 , ""exif:SamplesPerPixel"" } , { 0x116 , ""exif:RowsPerStrip"" } , { 0x117 , ""exif:StripByteCounts"" } , { 0x11a , ""exif:XResolution"" } , { 0x11b , ""exif:YResolution"" } , { 0x11c , ""exif:PlanarConfiguration"" } , { 0x11d , ""exif:PageName"" } , { 0x11e , ""exif:XPosition"" } , { 0x11f , ""exif:YPosition"" } , { 0x118 , ""exif:MinSampleValue"" } , { 0x119 , ""exif:MaxSampleValue"" } , { 0x120 , ""exif:FreeOffsets"" } , { 0x121 , ""exif:FreeByteCounts"" } , { 0x122 , ""exif:GrayResponseUnit"" } , { 0x123 , ""exif:GrayResponseCurve"" } , { 0x124 , ""exif:T4Options"" } , { 0x125 , ""exif:T6Options"" } , { 0x128 , ""exif:ResolutionUnit"" } , { 0x12d , ""exif:TransferFunction"" } , { 0x131 , ""exif:Software"" } , { 0x132 , ""exif:DateTime"" } , { 0x13b , ""exif:Artist"" } , { 0x13e , ""exif:WhitePoint"" } , { 0x13f , ""exif:PrimaryChromaticities"" } , { 0x140 , ""exif:ColorMap"" } , { 0x141 , ""exif:HalfToneHints"" } , { 0x142 , ""exif:TileWidth"" } , { 0x143 , ""exif:TileLength"" } , { 0x144 , ""exif:TileOffsets"" } , { 0x145 , ""exif:TileByteCounts"" } , { 0x14a , ""exif:SubIFD"" } , { 0x14c , ""exif:InkSet"" } , { 0x14d , ""exif:InkNames"" } , { 0x14e , ""exif:NumberOfInks"" } , { 0x150 , ""exif:DotRange"" } , { 0x151 , ""exif:TargetPrinter"" } , { 0x152 , ""exif:ExtraSample"" } , { 0x153 , ""exif:SampleFormat"" } , { 0x154 , ""exif:SMinSampleValue"" } , { 0x155 , ""exif:SMaxSampleValue"" } , { 0x156 , ""exif:TransferRange"" } , { 0x157 , ""exif:ClipPath"" } , { 0x158 , ""exif:XClipPathUnits"" } , { 0x159 , ""exif:YClipPathUnits"" } , { 0x15a , ""exif:Indexed"" } , { 0x15b , ""exif:JPEGTables"" } , { 0x15f , ""exif:OPIProxy"" } , { 0x200 , ""exif:JPEGProc"" } , { 0x201 , ""exif:JPEGInterchangeFormat"" } , { 0x202 , ""exif:JPEGInterchangeFormatLength"" } , { 0x203 , ""exif:JPEGRestartInterval"" } , { 0x205 , ""exif:JPEGLosslessPredictors"" } , { 0x206 , ""exif:JPEGPointTransforms"" } , { 0x207 , ""exif:JPEGQTables"" } , { 0x208 , ""exif:JPEGDCTables"" } , { 0x209 , ""exif:JPEGACTables"" } , { 0x211 , ""exif:YCbCrCoefficients"" } , { 0x212 , ""exif:YCbCrSubSampling"" } , { 0x213 , ""exif:YCbCrPositioning"" } , { 0x214 , ""exif:ReferenceBlackWhite"" } , { 0x2bc , ""exif:ExtensibleMetadataPlatform"" } , { 0x301 , ""exif:Gamma"" } , { 0x302 , ""exif:ICCProfileDescriptor"" } , { 0x303 , ""exif:SRGBRenderingIntent"" } , { 0x320 , ""exif:ImageTitle"" } , { 0x5001 , ""exif:ResolutionXUnit"" } , { 0x5002 , ""exif:ResolutionYUnit"" } , { 0x5003 , ""exif:ResolutionXLengthUnit"" } , { 0x5004 , ""exif:ResolutionYLengthUnit"" } , { 0x5005 , ""exif:PrintFlags"" } , { 0x5006 , ""exif:PrintFlagsVersion"" } , { 0x5007 , ""exif:PrintFlagsCrop"" } , { 0x5008 , ""exif:PrintFlagsBleedWidth"" } , { 0x5009 , ""exif:PrintFlagsBleedWidthScale"" } , { 0x500A , ""exif:HalftoneLPI"" } , { 0x500B , ""exif:HalftoneLPIUnit"" } , { 0x500C , ""exif:HalftoneDegree"" } , { 0x500D , ""exif:HalftoneShape"" } , { 0x500E , ""exif:HalftoneMisc"" } , { 0x500F , ""exif:HalftoneScreen"" } , { 0x5010 , ""exif:JPEGQuality"" } , { 0x5011 , ""exif:GridSize"" } , { 0x5012 , ""exif:ThumbnailFormat"" } , { 0x5013 , ""exif:ThumbnailWidth"" } , { 0x5014 , ""exif:ThumbnailHeight"" } , { 0x5015 , ""exif:ThumbnailColorDepth"" } , { 0x5016 , ""exif:ThumbnailPlanes"" } , { 0x5017 , ""exif:ThumbnailRawBytes"" } , { 0x5018 , ""exif:ThumbnailSize"" } , { 0x5019 , ""exif:ThumbnailCompressedSize"" } , { 0x501a , ""exif:ColorTransferFunction"" } , { 0x501b , ""exif:ThumbnailData"" } , { 0x5020 , ""exif:ThumbnailImageWidth"" } , { 0x5021 , ""exif:ThumbnailImageHeight"" } , { 0x5022 , ""exif:ThumbnailBitsPerSample"" } , { 0x5023 , ""exif:ThumbnailCompression"" } , { 0x5024 , ""exif:ThumbnailPhotometricInterp"" } , { 0x5025 , ""exif:ThumbnailImageDescription"" } , { 0x5026 , ""exif:ThumbnailEquipMake"" } , { 0x5027 , ""exif:ThumbnailEquipModel"" } , { 0x5028 , ""exif:ThumbnailStripOffsets"" } , { 0x5029 , ""exif:ThumbnailOrientation"" } , { 0x502a , ""exif:ThumbnailSamplesPerPixel"" } , { 0x502b , ""exif:ThumbnailRowsPerStrip"" } , { 0x502c , ""exif:ThumbnailStripBytesCount"" } , { 0x502d , ""exif:ThumbnailResolutionX"" } , { 0x502e , ""exif:ThumbnailResolutionY"" } , { 0x502f , ""exif:ThumbnailPlanarConfig"" } , { 0x5030 , ""exif:ThumbnailResolutionUnit"" } , { 0x5031 , ""exif:ThumbnailTransferFunction"" } , { 0x5032 , ""exif:ThumbnailSoftwareUsed"" } , { 0x5033 , ""exif:ThumbnailDateTime"" } , { 0x5034 , ""exif:ThumbnailArtist"" } , { 0x5035 , ""exif:ThumbnailWhitePoint"" } , { 0x5036 , ""exif:ThumbnailPrimaryChromaticities"" } , { 0x5037 , ""exif:ThumbnailYCbCrCoefficients"" } , { 0x5038 , ""exif:ThumbnailYCbCrSubsampling"" } , { 0x5039 , ""exif:ThumbnailYCbCrPositioning"" } , { 0x503A , ""exif:ThumbnailRefBlackWhite"" } , { 0x503B , ""exif:ThumbnailCopyRight"" } , { 0x5090 , ""exif:LuminanceTable"" } , { 0x5091 , ""exif:ChrominanceTable"" } , { 0x5100 , ""exif:FrameDelay"" } , { 0x5101 , ""exif:LoopCount"" } , { 0x5110 , ""exif:PixelUnit"" } , { 0x5111 , ""exif:PixelPerUnitX"" } , { 0x5112 , ""exif:PixelPerUnitY"" } , { 0x5113 , ""exif:PaletteHistogram"" } , { 0x1000 , ""exif:RelatedImageFileFormat"" } , { 0x1001 , ""exif:RelatedImageLength"" } , { 0x1002 , ""exif:RelatedImageWidth"" } , { 0x800d , ""exif:ImageID"" } , { 0x80e3 , ""exif:Matteing"" } , { 0x80e4 , ""exif:DataType"" } , { 0x80e5 , ""exif:ImageDepth"" } , { 0x80e6 , ""exif:TileDepth"" } , { 0x828d , ""exif:CFARepeatPatternDim"" } , { 0x828e , ""exif:CFAPattern2"" } , { 0x828f , ""exif:BatteryLevel"" } , { 0x8298 , ""exif:Copyright"" } , { 0x829a , ""exif:ExposureTime"" } , { 0x829d , ""exif:FNumber"" } , { 0x83bb , ""exif:IPTC/NAA"" } , { 0x84e3 , ""exif:IT8RasterPadding"" } , { 0x84e5 , ""exif:IT8ColorTable"" } , { 0x8649 , ""exif:ImageResourceInformation"" } , { 0x8769 , ""exif:ExifOffset"" } , { 0x8773 , ""exif:InterColorProfile"" } , { 0x8822 , ""exif:ExposureProgram"" } , { 0x8824 , ""exif:SpectralSensitivity"" } , { 0x8825 , ""exif:GPSInfo"" } , { 0x8827 , ""exif:ISOSpeedRatings"" } , { 0x8828 , ""exif:OECF"" } , { 0x8829 , ""exif:Interlace"" } , { 0x882a , ""exif:TimeZoneOffset"" } , { 0x882b , ""exif:SelfTimerMode"" } , { 0x9000 , ""exif:ExifVersion"" } , { 0x9003 , ""exif:DateTimeOriginal"" } , { 0x9004 , ""exif:DateTimeDigitized"" } , { 0x9101 , ""exif:ComponentsConfiguration"" } , { 0x9102 , ""exif:CompressedBitsPerPixel"" } , { 0x9201 , ""exif:ShutterSpeedValue"" } , { 0x9202 , ""exif:ApertureValue"" } , { 0x9203 , ""exif:BrightnessValue"" } , { 0x9204 , ""exif:ExposureBiasValue"" } , { 0x9205 , ""exif:MaxApertureValue"" } , { 0x9206 , ""exif:SubjectDistance"" } , { 0x9207 , ""exif:MeteringMode"" } , { 0x9208 , ""exif:LightSource"" } , { 0x9209 , ""exif:Flash"" } , { 0x920a , ""exif:FocalLength"" } , { 0x920b , ""exif:FlashEnergy"" } , { 0x920c , ""exif:SpatialFrequencyResponse"" } , { 0x920d , ""exif:Noise"" } , { 0x9211 , ""exif:ImageNumber"" } , { 0x9212 , ""exif:SecurityClassification"" } , { 0x9213 , ""exif:ImageHistory"" } , { 0x9214 , ""exif:SubjectArea"" } , { 0x9215 , ""exif:ExposureIndex"" } , { 0x9216 , ""exif:TIFF-EPStandardID"" } , { 0x927c , ""exif:MakerNote"" } , { 0x9C9b , ""exif:WinXP-Title"" } , { 0x9C9c , ""exif:WinXP-Comments"" } , { 0x9C9d , ""exif:WinXP-Author"" } , { 0x9C9e , ""exif:WinXP-Keywords"" } , { 0x9C9f , ""exif:WinXP-Subject"" } , { 0x9286 , ""exif:UserComment"" } , { 0x9290 , ""exif:SubSecTime"" } , { 0x9291 , ""exif:SubSecTimeOriginal"" } , { 0x9292 , ""exif:SubSecTimeDigitized"" } , { 0xa000 , ""exif:FlashPixVersion"" } , { 0xa001 , ""exif:ColorSpace"" } , { 0xa002 , ""exif:ExifImageWidth"" } , { 0xa003 , ""exif:ExifImageLength"" } , { 0xa004 , ""exif:RelatedSoundFile"" } , { 0xa005 , ""exif:InteroperabilityOffset"" } , { 0xa20b , ""exif:FlashEnergy"" } , { 0xa20c , ""exif:SpatialFrequencyResponse"" } , { 0xa20d , ""exif:Noise"" } , { 0xa20e , ""exif:FocalPlaneXResolution"" } , { 0xa20f , ""exif:FocalPlaneYResolution"" } , { 0xa210 , ""exif:FocalPlaneResolutionUnit"" } , { 0xa214 , ""exif:SubjectLocation"" } , { 0xa215 , ""exif:ExposureIndex"" } , { 0xa216 , ""exif:TIFF/EPStandardID"" } , { 0xa217 , ""exif:SensingMethod"" } , { 0xa300 , ""exif:FileSource"" } , { 0xa301 , ""exif:SceneType"" } , { 0xa302 , ""exif:CFAPattern"" } , { 0xa401 , ""exif:CustomRendered"" } , { 0xa402 , ""exif:ExposureMode"" } , { 0xa403 , ""exif:WhiteBalance"" } , { 0xa404 , ""exif:DigitalZoomRatio"" } , { 0xa405 , ""exif:FocalLengthIn35mmFilm"" } , { 0xa406 , ""exif:SceneCaptureType"" } , { 0xa407 , ""exif:GainControl"" } , { 0xa408 , ""exif:Contrast"" } , { 0xa409 , ""exif:Saturation"" } , { 0xa40a , ""exif:Sharpness"" } , { 0xa40b , ""exif:DeviceSettingDescription"" } , { 0xa40c , ""exif:SubjectDistanceRange"" } , { 0xa420 , ""exif:ImageUniqueID"" } , { 0xc4a5 , ""exif:PrintImageMatching"" } , { 0xa500 , ""exif:Gamma"" } , { 0xc640 , ""exif:CR2Slice"" } , { 0x10000 , ""exif:GPSVersionID"" } , { 0x10001 , ""exif:GPSLatitudeRef"" } , { 0x10002 , ""exif:GPSLatitude"" } , { 0x10003 , ""exif:GPSLongitudeRef"" } , { 0x10004 , ""exif:GPSLongitude"" } , { 0x10005 , ""exif:GPSAltitudeRef"" } , { 0x10006 , ""exif:GPSAltitude"" } , { 0x10007 , ""exif:GPSTimeStamp"" } , { 0x10008 , ""exif:GPSSatellites"" } , { 0x10009 , ""exif:GPSStatus"" } , { 0x1000a , ""exif:GPSMeasureMode"" } , { 0x1000b , ""exif:GPSDop"" } , { 0x1000c , ""exif:GPSSpeedRef"" } , { 0x1000d , ""exif:GPSSpeed"" } , { 0x1000e , ""exif:GPSTrackRef"" } , { 0x1000f , ""exif:GPSTrack"" } , { 0x10010 , ""exif:GPSImgDirectionRef"" } , { 0x10011 , ""exif:GPSImgDirection"" } , { 0x10012 , ""exif:GPSMapDatum"" } , { 0x10013 , ""exif:GPSDestLatitudeRef"" } , { 0x10014 , ""exif:GPSDestLatitude"" } , { 0x10015 , ""exif:GPSDestLongitudeRef"" } , { 0x10016 , ""exif:GPSDestLongitude"" } , { 0x10017 , ""exif:GPSDestBearingRef"" } , { 0x10018 , ""exif:GPSDestBearing"" } , { 0x10019 , ""exif:GPSDestDistanceRef"" } , { 0x1001a , ""exif:GPSDestDistance"" } , { 0x1001b , ""exif:GPSProcessingMethod"" } , { 0x1001c , ""exif:GPSAreaInformation"" } , { 0x1001d , ""exif:GPSDateStamp"" } , { 0x1001e , ""exif:GPSDifferential"" } , { 0x00000 , ( const char * ) NULL } } ; const StringInfo * profile ; const unsigned char * directory , * exif ; DirectoryInfo directory_stack [ MaxDirectoryStack ] ; EndianType endian ; MagickBooleanType status ; register ssize_t i ; size_t entry , length , number_entries , tag , tag_value ; SplayTreeInfo * exif_resources ; ssize_t all , id , level , offset , tag_offset ; static int tag_bytes [ ] = { 0 , 1 , 1 , 2 , 4 , 8 , 1 , 1 , 2 , 4 , 8 , 4 , 8 } ; profile = GetImageProfile ( image , ""exif"" ) ; if ( profile == ( const StringInfo * ) NULL ) return ( MagickFalse ) ; if ( ( property == ( const char * ) NULL ) || ( * property == '\\0' ) ) return ( MagickFalse ) ; while ( isspace ( ( int ) ( ( unsigned char ) * property ) ) != 0 ) property ++ ; if ( strlen ( property ) <= 5 ) return ( MagickFalse ) ; all = 0 ; tag = ( ~ 0UL ) ; switch ( * ( property + 5 ) ) { case '*' : { tag = 0 ; all = 1 ; break ; } case '!' : { tag = 0 ; all = 2 ; break ; } case '#' : case '@' : { int c ; size_t n ; tag = ( * ( property + 5 ) == '@' ) ? 1UL : 0UL ; property += 6 ; n = strlen ( property ) ; if ( n != 4 ) return ( MagickFalse ) ; n /= 4 ; do { for ( i = ( ssize_t ) n - 1L ; i >= 0 ; i -- ) { c = ( * property ++ ) ; tag <<= 4 ; if ( ( c >= '0' ) && ( c <= '9' ) ) tag |= ( c - '0' ) ; else if ( ( c >= 'A' ) && ( c <= 'F' ) ) tag |= ( c - ( 'A' - 10 ) ) ; else if ( ( c >= 'a' ) && ( c <= 'f' ) ) tag |= ( c - ( 'a' - 10 ) ) ; else return ( MagickFalse ) ; } } while ( * property != '\\0' ) ; break ; } default : { for ( i = 0 ; ; i ++ ) { if ( EXIFTag [ i ] . tag == 0 ) break ; if ( LocaleCompare ( EXIFTag [ i ] . description , property ) == 0 ) { tag = ( size_t ) EXIFTag [ i ] . tag ; break ; } } break ; } } if ( tag == ( ~ 0UL ) ) return ( MagickFalse ) ; length = GetStringInfoLength ( profile ) ; exif = GetStringInfoDatum ( profile ) ; while ( length != 0 ) { if ( ReadPropertyByte ( & exif , & length ) != 0x45 ) continue ; if ( ReadPropertyByte ( & exif , & length ) != 0x78 ) continue ; if ( ReadPropertyByte ( & exif , & length ) != 0x69 ) continue ; if ( ReadPropertyByte ( & exif , & length ) != 0x66 ) continue ; if ( ReadPropertyByte ( & exif , & length ) != 0x00 ) continue ; if ( ReadPropertyByte ( & exif , & length ) != 0x00 ) continue ; break ; } if ( length < 16 ) return ( MagickFalse ) ; id = ( ssize_t ) ReadPropertySignedShort ( LSBEndian , exif ) ; endian = LSBEndian ; if ( id == 0x4949 ) endian = LSBEndian ; else if ( id == 0x4D4D ) endian = MSBEndian ; else return ( MagickFalse ) ; if ( ReadPropertyUnsignedShort ( endian , exif + 2 ) != 0x002a ) return ( MagickFalse ) ; offset = ( ssize_t ) ReadPropertySignedLong ( endian , exif + 4 ) ; if ( ( offset < 0 ) || ( size_t ) offset >= length ) return ( MagickFalse ) ; status = MagickFalse ; directory = exif + offset ; level = 0 ; entry = 0 ; tag_offset = 0 ; exif_resources = NewSplayTree ( ( int ( * ) ( const void * , const void * ) ) NULL , ( void * ( * ) ( void * ) ) NULL , ( void * ( * ) ( void * ) ) NULL ) ; do { if ( level > 0 ) { level -- ; directory = directory_stack [ level ] . directory ; entry = directory_stack [ level ] . entry ; tag_offset = directory_stack [ level ] . offset ; } if ( ( directory < exif ) || ( directory > ( exif + length - 2 ) ) ) break ; number_entries = ( size_t ) ReadPropertyUnsignedShort ( endian , directory ) ; for ( ; entry < number_entries ; entry ++ ) { register unsigned char * p , * q ; size_t format ; ssize_t number_bytes , components ; q = ( unsigned char * ) ( directory + ( 12 * entry ) + 2 ) ; <S2SV_StartBug> if ( GetValueFromSplayTree ( exif_resources , q ) == q ) <S2SV_EndBug> break ; ( void ) AddValueToSplayTree ( exif_resources , q , q ) ; tag_value = ( size_t ) ReadPropertyUnsignedShort ( endian , q ) + tag_offset ; format = ( size_t ) ReadPropertyUnsignedShort ( endian , q + 2 ) ; if ( format >= ( sizeof ( tag_bytes ) / sizeof ( * tag_bytes ) ) ) break ; <S2SV_StartBug> components = ( ssize_t ) ReadPropertySignedLong ( endian , q + 4 ) ; <S2SV_EndBug> number_bytes = ( size_t ) components * tag_bytes [ format ] ; if ( number_bytes < components ) break ; if ( number_bytes <= 4 ) p = q + 8 ; else { ssize_t offset ; offset = ( ssize_t ) ReadPropertySignedLong ( endian , q + 8 ) ; if ( ( offset < 0 ) || ( size_t ) offset >= length ) continue ; if ( ( ssize_t ) ( offset + number_bytes ) < offset ) continue ; if ( ( size_t ) ( offset + number_bytes ) > length ) continue ; p = ( unsigned char * ) ( exif + offset ) ; } if ( ( all != 0 ) || ( tag == ( size_t ) tag_value ) ) { char buffer [ MagickPathExtent ] , * value ; value = ( char * ) NULL ; * buffer = '\\0' ; switch ( format ) { case EXIF_FMT_BYTE : case EXIF_FMT_UNDEFINED : { EXIFMultipleValues ( 1 , ""%.20g"" , ( double ) ( * ( unsigned char * ) p1 ) ) ; break ; } case EXIF_FMT_SBYTE : { EXIFMultipleValues ( 1 , ""%.20g"" , ( double ) ( * ( signed char * ) p1 ) ) ; break ; } case EXIF_FMT_SSHORT : { EXIFMultipleValues ( 2 , ""%hd"" , ReadPropertySignedShort ( endian , p1 ) ) ; break ; } case EXIF_FMT_USHORT : { EXIFMultipleValues ( 2 , ""%hu"" , ReadPropertyUnsignedShort ( endian , p1 ) ) ; break ; } case EXIF_FMT_ULONG : { EXIFMultipleValues ( 4 , ""%.20g"" , ( double ) ReadPropertyUnsignedLong ( endian , p1 ) ) ; break ; } case EXIF_FMT_SLONG : { EXIFMultipleValues ( 4 , ""%.20g"" , ( double ) ReadPropertySignedLong ( endian , p1 ) ) ; break ; } case EXIF_FMT_URATIONAL : { EXIFMultipleFractions ( 8 , ""%.20g/%.20g"" , ( double ) ReadPropertyUnsignedLong ( endian , p1 ) , ( double ) ReadPropertyUnsignedLong ( endian , p1 + 4 ) ) ; break ; } case EXIF_FMT_SRATIONAL : { EXIFMultipleFractions ( 8 , ""%.20g/%.20g"" , ( double ) ReadPropertySignedLong ( endian , p1 ) , ( double ) ReadPropertySignedLong ( endian , p1 + 4 ) ) ; break ; } case EXIF_FMT_SINGLE : { EXIFMultipleValues ( 4 , ""%f"" , ( double ) * ( float * ) p1 ) ; break ; } case EXIF_FMT_DOUBLE : { EXIFMultipleValues ( 8 , ""%f"" , * ( double * ) p1 ) ; break ; } default : case EXIF_FMT_STRING : { value = ( char * ) NULL ; if ( ~ ( ( size_t ) number_bytes ) >= 1 ) value = ( char * ) AcquireQuantumMemory ( ( size_t ) number_bytes + 1UL , sizeof ( * value ) ) ; if ( value != ( char * ) NULL ) { register ssize_t i ; for ( i = 0 ; i < ( ssize_t ) number_bytes ; i ++ ) { value [ i ] = '.' ; if ( ( isprint ( ( int ) p [ i ] ) != 0 ) || ( p [ i ] == '\\0' ) ) value [ i ] = ( char ) p [ i ] ; } value [ i ] = '\\0' ; } break ; } } if ( value != ( char * ) NULL ) { char * key ; register const char * p ; key = AcquireString ( property ) ; switch ( all ) { case 1 : { const char * description ; register ssize_t i ; description = ""unknown"" ; for ( i = 0 ; ; i ++ ) { if ( EXIFTag [ i ] . tag == 0 ) break ; if ( EXIFTag [ i ] . tag == tag_value ) { description = EXIFTag [ i ] . description ; break ; } } ( void ) FormatLocaleString ( key , MagickPathExtent , ""%s"" , description ) ; if ( level == 2 ) ( void ) SubstituteString ( & key , ""exif:"" , ""exif:thumbnail:"" ) ; break ; } case 2 : { if ( tag_value < 0x10000 ) ( void ) FormatLocaleString ( key , MagickPathExtent , ""#%04lx"" , ( unsigned long ) tag_value ) ; else if ( tag_value < 0x20000 ) ( void ) FormatLocaleString ( key , MagickPathExtent , ""@%04lx"" , ( unsigned long ) ( tag_value & 0xffff ) ) ; else ( void ) FormatLocaleString ( key , MagickPathExtent , ""unknown"" ) ; break ; } default : { if ( level == 2 ) ( void ) SubstituteString ( & key , ""exif:"" , ""exif:thumbnail:"" ) ; } } p = ( const char * ) NULL ; if ( image -> properties != ( void * ) NULL ) p = ( const char * ) GetValueFromSplayTree ( ( SplayTreeInfo * ) image -> properties , key ) ; if ( p == ( const char * ) NULL ) ( void ) SetImageProperty ( ( Image * ) image , key , value , exception ) ; value = DestroyString ( value ) ; key = DestroyString ( key ) ; status = MagickTrue ; } } if ( ( tag_value == TAG_EXIF_OFFSET ) || ( tag_value == TAG_INTEROP_OFFSET ) || ( tag_value == TAG_GPS_OFFSET ) ) { ssize_t offset ; offset = ( ssize_t ) ReadPropertySignedLong ( endian , p ) ; if ( ( ( size_t ) offset < length ) && ( level < ( MaxDirectoryStack - 2 ) ) ) { ssize_t tag_offset1 ; tag_offset1 = ( ssize_t ) ( ( tag_value == TAG_GPS_OFFSET ) ? 0x10000 : 0 ) ; directory_stack [ level ] . directory = directory ; entry ++ ; directory_stack [ level ] . entry = entry ; directory_stack [ level ] . offset = tag_offset ; level ++ ; directory_stack [ level ] . directory = exif + offset ; directory_stack [ level ] . offset = tag_offset1 ; directory_stack [ level ] . entry = 0 ; level ++ ; if ( ( directory + 2 + ( 12 * number_entries ) ) > ( exif + length ) ) break ; offset = ( ssize_t ) ReadPropertySignedLong ( endian , directory + 2 + ( 12 * number_entries ) ) ; if ( ( offset != 0 ) && ( ( size_t ) offset < length ) && ( level < ( MaxDirectoryStack - 2 ) ) ) { directory_stack [ level ] . directory = exif + offset ; directory_stack [ level ] . entry = 0 ; directory_stack [ level ] . offset = tag_offset1 ; level ++ ; } } break ; } } } while ( level > 0 ) ; exif_resources = DestroySplayTree ( exif_resources ) ; return ( status ) ; }",", arg ) \\\n{ <S2SV_ModEnd> ssize_t component ; <S2SV_ModStart> buffer ) ; \\\n} <S2SV_ModEnd> # define EXIFMultipleFractions <S2SV_ModStart> , arg2 ) \\\n{ <S2SV_ModEnd> ssize_t component ; <S2SV_ModStart> buffer ) ; \\\n} <S2SV_ModEnd> typedef struct _DirectoryInfo <S2SV_ModStart> ; if ( q > ( exif + length - 12 ) ) break ; if ( <S2SV_ModStart> + 4 ) ; if ( components < 0 ) break"
14,"static void __net_random_once_deferred ( struct work_struct * w ) { struct __net_random_once_work * work = container_of ( w , struct __net_random_once_work , work ) ; <S2SV_StartBug> if ( ! static_key_enabled ( work -> key ) ) <S2SV_EndBug> static_key_slow_inc ( work -> key ) ; kfree ( work ) ; }",work ) ; BUG_ON <S2SV_ModEnd> ( ! static_key_enabled <S2SV_ModStart> key ) ) ; static_key_slow_dec <S2SV_ModEnd> ( work ->
15,"int genl_register_family ( struct genl_family * family ) { int err , i ; int start = GENL_START_ALLOC , end = GENL_MAX_ID ; err = genl_validate_ops ( family ) ; if ( err ) return err ; genl_lock_all ( ) ; if ( genl_family_find_byname ( family -> name ) ) { err = - EEXIST ; goto errout_locked ; } if ( family == & genl_ctrl ) { start = end = GENL_ID_CTRL ; } else if ( strcmp ( family -> name , ""pmcraid"" ) == 0 ) { start = end = GENL_ID_PMCRAID ; } else if ( strcmp ( family -> name , ""VFS_DQUOT"" ) == 0 ) { start = end = GENL_ID_VFS_DQUOT ; } if ( family -> maxattr && ! family -> parallel_ops ) { family -> attrbuf = kmalloc_array ( family -> maxattr + 1 , sizeof ( struct nlattr * ) , GFP_KERNEL ) ; if ( family -> attrbuf == NULL ) { err = - ENOMEM ; goto errout_locked ; } } else family -> attrbuf = NULL ; family -> id = idr_alloc ( & genl_fam_idr , family , start , end + 1 , GFP_KERNEL ) ; if ( family -> id < 0 ) { err = family -> id ; <S2SV_StartBug> goto errout_locked ; <S2SV_EndBug> } err = genl_validate_assign_mc_groups ( family ) ; if ( err ) goto errout_remove ; genl_unlock_all ( ) ; genl_ctrl_event ( CTRL_CMD_NEWFAMILY , family , NULL , 0 ) ; for ( i = 0 ; i < family -> n_mcgrps ; i ++ ) genl_ctrl_event ( CTRL_CMD_NEWMCAST_GRP , family , & family -> mcgrps [ i ] , family -> mcgrp_offset + i ) ; return 0 ; errout_remove : idr_remove ( & genl_fam_idr , family -> id ) ; <S2SV_StartBug> kfree ( family -> attrbuf ) ; <S2SV_EndBug> errout_locked : genl_unlock_all ( ) ; return err ; }",id ; goto errout_free <S2SV_ModEnd> ; } err <S2SV_ModStart> id ) ; errout_free :
16,"void mwifiex_set_wmm_params ( struct mwifiex_private * priv , struct mwifiex_uap_bss_param * bss_cfg , struct cfg80211_ap_settings * params ) { const u8 * vendor_ie ; const u8 * wmm_ie ; u8 wmm_oui [ ] = { 0x00 , 0x50 , 0xf2 , 0x02 } ; vendor_ie = cfg80211_find_vendor_ie ( WLAN_OUI_MICROSOFT , WLAN_OUI_TYPE_MICROSOFT_WMM , params -> beacon . tail , params -> beacon . tail_len ) ; if ( vendor_ie ) { wmm_ie = vendor_ie ; <S2SV_StartBug> memcpy ( & bss_cfg -> wmm_info , wmm_ie + <S2SV_EndBug> <S2SV_StartBug> sizeof ( struct ieee_types_header ) , * ( wmm_ie + 1 ) ) ; <S2SV_EndBug> priv -> wmm_enabled = 1 ; } else { memset ( & bss_cfg -> wmm_info , 0 , sizeof ( bss_cfg -> wmm_info ) ) ; memcpy ( & bss_cfg -> wmm_info . oui , wmm_oui , sizeof ( wmm_oui ) ) ; bss_cfg -> wmm_info . subtype = MWIFIEX_WMM_SUBTYPE ; bss_cfg -> wmm_info . version = MWIFIEX_WMM_VERSION ; priv -> wmm_enabled = 0 ; } bss_cfg -> qos_info = 0x00 ; return ; }","= vendor_ie ; if ( <S2SV_ModEnd> * ( wmm_ie <S2SV_ModStart> + 1 ) > sizeof ( struct mwifiex_types_wmm_info ) ) return ; memcpy ( & bss_cfg -> wmm_info , wmm_ie + sizeof ( struct ieee_types_header ) , * ( wmm_ie + 1 )"
17,"error_t ssiProcessEchoCommand ( HttpConnection * connection , const char_t * tag , size_t length ) { error_t error ; char_t * separator ; char_t * attribute ; char_t * value ; if ( length < 4 || length >= HTTP_SERVER_BUFFER_SIZE ) return ERROR_INVALID_TAG ; osMemcpy ( connection -> buffer , tag + 4 , length - 4 ) ; connection -> buffer [ length - 4 ] = '\\0' ; <S2SV_StartBug> separator = strchr ( connection -> buffer , '=' ) ; <S2SV_EndBug> if ( ! separator ) return ERROR_INVALID_TAG ; * separator = '\\0' ; attribute = strTrimWhitespace ( connection -> buffer ) ; value = strTrimWhitespace ( separator + 1 ) ; if ( value [ 0 ] == '\\'' || value [ 0 ] == \'\\""\' ) value ++ ; length = osStrlen ( value ) ; if ( length > 0 ) { if ( value [ length - 1 ] == '\\'' || value [ length - 1 ] == \'\\""\' ) value [ length - 1 ] = '\\0' ; } if ( osStrcasecmp ( attribute , ""var"" ) ) return ERROR_INVALID_TAG ; if ( ! osStrcasecmp ( value , ""REMOTE_ADDR"" ) ) { ipAddrToString ( & connection -> socket -> remoteIpAddr , connection -> buffer ) ; } else if ( ! osStrcasecmp ( value , ""REMOTE_PORT"" ) ) { osSprintf ( connection -> buffer , ""%"" PRIu16 , connection -> socket -> remotePort ) ; } else if ( ! osStrcasecmp ( value , ""SERVER_ADDR"" ) ) { ipAddrToString ( & connection -> socket -> localIpAddr , connection -> buffer ) ; } else if ( ! osStrcasecmp ( value , ""SERVER_PORT"" ) ) { osSprintf ( connection -> buffer , ""%"" PRIu16 , connection -> socket -> localPort ) ; } else if ( ! osStrcasecmp ( value , ""REQUEST_METHOD"" ) ) { osStrcpy ( connection -> buffer , connection -> request . method ) ; } else if ( ! osStrcasecmp ( value , ""DOCUMENT_ROOT"" ) ) { osStrcpy ( connection -> buffer , connection -> settings -> rootDirectory ) ; } else if ( ! osStrcasecmp ( value , ""DOCUMENT_URI"" ) ) { osStrcpy ( connection -> buffer , connection -> request . uri ) ; } else if ( ! osStrcasecmp ( value , ""DOCUMENT_NAME"" ) ) { httpGetAbsolutePath ( connection , connection -> request . uri , connection -> buffer , HTTP_SERVER_BUFFER_SIZE ) ; } else if ( ! osStrcasecmp ( value , ""QUERY_STRING"" ) ) { osStrcpy ( connection -> buffer , connection -> request . queryString ) ; } else if ( ! osStrcasecmp ( value , ""AUTH_USER"" ) ) { # if ( HTTP_SERVER_BASIC_AUTH_SUPPORT == ENABLED || HTTP_SERVER_DIGEST_AUTH_SUPPORT == ENABLED ) osStrcpy ( connection -> buffer , connection -> request . auth . user ) ; # else connection -> buffer [ 0 ] = '\\0' ; # endif } else if ( ! osStrcasecmp ( value , ""DATE_GMT"" ) ) { connection -> buffer [ 0 ] = '\\0' ; } else if ( ! osStrcasecmp ( value , ""DATE_LOCAL"" ) ) { connection -> buffer [ 0 ] = '\\0' ; } else { return ERROR_INVALID_TAG ; } length = osStrlen ( connection -> buffer ) ; error = httpWriteStream ( connection , connection -> buffer , length ) ; if ( error ) return error ; return NO_ERROR ; }",; separator = osStrchr <S2SV_ModEnd> ( connection ->
18,"int Util_handle0Escapes ( char * buf ) { int editpos ; int insertpos ; ASSERT ( buf ) ; for ( editpos = insertpos = 0 ; * ( buf + editpos ) != '\\0' ; editpos ++ , insertpos ++ ) { if ( * ( buf + editpos ) == '\\\\' ) { switch ( * ( buf + editpos + 1 ) ) { case '0' : if ( * ( buf + editpos + 2 ) == 'x' ) { <S2SV_StartBug> * ( buf + insertpos ) = x2c ( & buf [ editpos + 3 ] ) ; <S2SV_EndBug> editpos += 4 ; } break ; default : * ( buf + insertpos ) = * ( buf + editpos ) ; } } else { * ( buf + insertpos ) = * ( buf + editpos ) ; } } * ( buf + insertpos ) = '\\0' ; return insertpos ; }",insertpos ) = _x2c <S2SV_ModEnd> ( & buf
19,"static int ext4_ext_handle_uninitialized_extents ( handle_t * handle , struct inode * inode , ext4_lblk_t iblock , unsigned int max_blocks , struct ext4_ext_path * path , int flags , unsigned int allocated , struct buffer_head * bh_result , ext4_fsblk_t newblock ) { int ret = 0 ; int err = 0 ; ext4_io_end_t * io = EXT4_I ( inode ) -> cur_aio_dio ; ext_debug ( ""ext4_ext_handle_uninitialized_extents:<S2SV_blank>inode<S2SV_blank>%lu,<S2SV_blank>logical"" ""block<S2SV_blank>%llu,<S2SV_blank>max_blocks<S2SV_blank>%u,<S2SV_blank>flags<S2SV_blank>%d,<S2SV_blank>allocated<S2SV_blank>%u"" , inode -> i_ino , ( unsigned long long ) iblock , max_blocks , flags , allocated ) ; ext4_ext_show_leaf ( inode , path ) ; <S2SV_StartBug> if ( flags == EXT4_GET_BLOCKS_PRE_IO ) { <S2SV_EndBug> ret = ext4_split_unwritten_extents ( handle , inode , path , iblock , max_blocks , flags ) ; if ( io ) io -> flag = EXT4_IO_UNWRITTEN ; else <S2SV_StartBug> ext4_set_inode_state ( inode , EXT4_STATE_DIO_UNWRITTEN ) ; <S2SV_EndBug> goto out ; } <S2SV_StartBug> if ( flags == EXT4_GET_BLOCKS_CONVERT ) { <S2SV_EndBug> ret = ext4_convert_unwritten_extents_endio ( handle , inode , path ) ; if ( ret >= 0 ) ext4_update_inode_fsync_trans ( handle , inode , 1 ) ; goto out2 ; } if ( flags & EXT4_GET_BLOCKS_UNINIT_EXT ) goto map_out ; if ( ( flags & EXT4_GET_BLOCKS_CREATE ) == 0 ) { set_buffer_unwritten ( bh_result ) ; goto out1 ; } ret = ext4_ext_convert_to_initialized ( handle , inode , path , iblock , max_blocks ) ; if ( ret >= 0 ) ext4_update_inode_fsync_trans ( handle , inode , 1 ) ; out : if ( ret <= 0 ) { err = ret ; goto out2 ; } else allocated = ret ; set_buffer_new ( bh_result ) ; if ( allocated > max_blocks ) { unmap_underlying_metadata_blocks ( inode -> i_sb -> s_bdev , newblock + max_blocks , allocated - max_blocks ) ; allocated = max_blocks ; } if ( flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE ) ext4_da_update_reserve_space ( inode , allocated , 0 ) ; map_out : set_buffer_mapped ( bh_result ) ; out1 : if ( allocated > max_blocks ) allocated = max_blocks ; ext4_ext_show_leaf ( inode , path ) ; bh_result -> b_bdev = inode -> i_sb -> s_bdev ; bh_result -> b_blocknr = newblock ; out2 : if ( path ) { ext4_ext_drop_refs ( path ) ; kfree ( path ) ; } return err ? err : allocated ; }","; if ( ( flags & EXT4_GET_BLOCKS_PRE_IO ) ) <S2SV_ModEnd> { ret = <S2SV_ModStart> inode , EXT4_STATE_DIO_UNWRITTEN ) ; if ( ext4_should_dioread_nolock ( inode ) ) set_buffer_uninit ( bh_result <S2SV_ModStart> } if ( ( flags & EXT4_GET_BLOCKS_CONVERT ) <S2SV_ModEnd> ) { ret"
20,"int usbip_recv_xbuff ( struct usbip_device * ud , struct urb * urb ) { int ret ; int size ; if ( ud -> side == USBIP_STUB ) { if ( usb_pipein ( urb -> pipe ) ) return 0 ; size = urb -> transfer_buffer_length ; } else { if ( usb_pipeout ( urb -> pipe ) ) return 0 ; size = urb -> actual_length ; } if ( ! ( size > 0 ) ) return 0 ; <S2SV_StartBug> ret = usbip_recv ( ud -> tcp_socket , urb -> transfer_buffer , size ) ; <S2SV_EndBug> if ( ret != size ) { dev_err ( & urb -> dev -> dev , ""recv<S2SV_blank>xbuf,<S2SV_blank>%d\\n"" , ret ) ; if ( ud -> side == USBIP_STUB ) { usbip_event_add ( ud , SDEV_EVENT_ERROR_TCP ) ; <S2SV_StartBug> } else { <S2SV_EndBug> usbip_event_add ( ud , VDEV_EVENT_ERROR_TCP ) ; return - EPIPE ; } } <S2SV_StartBug> return ret ; <S2SV_EndBug> }","return 0 ; if ( size > urb -> transfer_buffer_length ) { <S2SV_ModEnd> if ( ud <S2SV_ModStart> SDEV_EVENT_ERROR_TCP ) ; return 0 ; <S2SV_ModStart> ; } } ret = usbip_recv ( ud -> tcp_socket , urb -> transfer_buffer , size ) ; if ( ret != size ) { dev_err ( & urb -> dev -> dev , ""recv<S2SV_blank>xbuf,<S2SV_blank>%d\\n"" , ret ) ; if ( ud -> side == USBIP_STUB ) { usbip_event_add ( ud , SDEV_EVENT_ERROR_TCP ) ; } else { usbip_event_add ( ud , VDEV_EVENT_ERROR_TCP ) ; return - EPIPE ; } }"
21,"static __net_init int setup_net ( struct net * net , struct user_namespace * user_ns ) { const struct pernet_operations * ops , * saved_ops ; int error = 0 ; LIST_HEAD ( net_exit_list ) ; refcount_set ( & net -> count , 1 ) ; refcount_set ( & net -> passive , 1 ) ; <S2SV_StartBug> net -> dev_base_seq = 1 ; <S2SV_EndBug> net -> user_ns = user_ns ; idr_init ( & net -> netns_ids ) ; spin_lock_init ( & net -> nsid_lock ) ; mutex_init ( & net -> ipv4 . ra_mutex ) ; list_for_each_entry ( ops , & pernet_list , list ) { error = ops_init ( ops , net ) ; if ( error < 0 ) goto out_undo ; } down_write ( & net_rwsem ) ; list_add_tail_rcu ( & net -> list , & net_namespace_list ) ; up_write ( & net_rwsem ) ; out : return error ; out_undo : list_add ( & net -> exit_list , & net_exit_list ) ; saved_ops = ops ; list_for_each_entry_continue_reverse ( ops , & pernet_list , list ) ops_exit_list ( ops , & net_exit_list ) ; ops = saved_ops ; list_for_each_entry_continue_reverse ( ops , & pernet_list , list ) ops_free_list ( ops , & net_exit_list ) ; rcu_barrier ( ) ; goto out ; }","1 ) ; get_random_bytes ( & net -> hash_mix , sizeof ( u32 ) ) ;"
22,"static int crypto_report_one ( struct crypto_alg * alg , struct crypto_user_alg * ualg , struct sk_buff * skb ) { <S2SV_StartBug> strlcpy ( ualg -> cru_name , alg -> cra_name , sizeof ( ualg -> cru_name ) ) ; <S2SV_EndBug> <S2SV_StartBug> strlcpy ( ualg -> cru_driver_name , alg -> cra_driver_name , <S2SV_EndBug> sizeof ( ualg -> cru_driver_name ) ) ; <S2SV_StartBug> strlcpy ( ualg -> cru_module_name , module_name ( alg -> cra_module ) , <S2SV_EndBug> sizeof ( ualg -> cru_module_name ) ) ; ualg -> cru_type = 0 ; ualg -> cru_mask = 0 ; ualg -> cru_flags = alg -> cra_flags ; ualg -> cru_refcnt = refcount_read ( & alg -> cra_refcnt ) ; if ( nla_put_u32 ( skb , CRYPTOCFGA_PRIORITY_VAL , alg -> cra_priority ) ) goto nla_put_failure ; if ( alg -> cra_flags & CRYPTO_ALG_LARVAL ) { struct crypto_report_larval rl ; <S2SV_StartBug> strlcpy ( rl . type , ""larval"" , sizeof ( rl . type ) ) ; <S2SV_EndBug> if ( nla_put ( skb , CRYPTOCFGA_REPORT_LARVAL , sizeof ( struct crypto_report_larval ) , & rl ) ) goto nla_put_failure ; goto out ; } if ( alg -> cra_type && alg -> cra_type -> report ) { if ( alg -> cra_type -> report ( skb , alg ) ) goto nla_put_failure ; goto out ; } switch ( alg -> cra_flags & ( CRYPTO_ALG_TYPE_MASK | CRYPTO_ALG_LARVAL ) ) { case CRYPTO_ALG_TYPE_CIPHER : if ( crypto_report_cipher ( skb , alg ) ) goto nla_put_failure ; break ; case CRYPTO_ALG_TYPE_COMPRESS : if ( crypto_report_comp ( skb , alg ) ) goto nla_put_failure ; break ; case CRYPTO_ALG_TYPE_ACOMPRESS : if ( crypto_report_acomp ( skb , alg ) ) goto nla_put_failure ; break ; case CRYPTO_ALG_TYPE_AKCIPHER : if ( crypto_report_akcipher ( skb , alg ) ) goto nla_put_failure ; break ; case CRYPTO_ALG_TYPE_KPP : if ( crypto_report_kpp ( skb , alg ) ) goto nla_put_failure ; break ; } out : return 0 ; nla_put_failure : return - EMSGSIZE ; }",skb ) { strncpy <S2SV_ModEnd> ( ualg -> <S2SV_ModStart> ) ) ; strncpy <S2SV_ModEnd> ( ualg -> <S2SV_ModStart> ) ) ; strncpy <S2SV_ModEnd> ( ualg -> <S2SV_ModStart> crypto_report_larval rl ; strncpy <S2SV_ModEnd> ( rl .
23,"cJSON * cJSON_Parse ( const char * value ) { <S2SV_StartBug> cJSON * c ; <S2SV_EndBug> ep = 0 ; if ( ! ( c = cJSON_New_Item ( ) ) ) return 0 ; if ( ! parse_value ( c , skip ( value ) ) ) { cJSON_Delete ( c ) ; return 0 ; } return c ; }","value ) { return cJSON_ParseWithOpts ( value , 0 , 0 ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>"
24,"static int read_SubStreamsInfo ( struct archive_read * a , struct _7z_substream_info * ss , struct _7z_folder * f , size_t numFolders ) { const unsigned char * p ; uint64_t * usizes ; size_t unpack_streams ; int type ; unsigned i ; uint32_t numDigests ; memset ( ss , 0 , sizeof ( * ss ) ) ; for ( i = 0 ; i < numFolders ; i ++ ) f [ i ] . numUnpackStreams = 1 ; if ( ( p = header_bytes ( a , 1 ) ) == NULL ) return ( - 1 ) ; type = * p ; if ( type == kNumUnPackStream ) { unpack_streams = 0 ; for ( i = 0 ; i < numFolders ; i ++ ) { if ( parse_7zip_uint64 ( a , & ( f [ i ] . numUnpackStreams ) ) < 0 ) return ( - 1 ) ; if ( UMAX_ENTRY < f [ i ] . numUnpackStreams ) return ( - 1 ) ; <S2SV_StartBug> unpack_streams += ( size_t ) f [ i ] . numUnpackStreams ; <S2SV_EndBug> } if ( ( p = header_bytes ( a , 1 ) ) == NULL ) return ( - 1 ) ; type = * p ; } else unpack_streams = numFolders ; ss -> unpack_streams = unpack_streams ; if ( unpack_streams ) { ss -> unpackSizes = calloc ( unpack_streams , sizeof ( * ss -> unpackSizes ) ) ; ss -> digestsDefined = calloc ( unpack_streams , sizeof ( * ss -> digestsDefined ) ) ; ss -> digests = calloc ( unpack_streams , sizeof ( * ss -> digests ) ) ; if ( ss -> unpackSizes == NULL || ss -> digestsDefined == NULL || ss -> digests == NULL ) return ( - 1 ) ; } usizes = ss -> unpackSizes ; for ( i = 0 ; i < numFolders ; i ++ ) { unsigned pack ; uint64_t sum ; if ( f [ i ] . numUnpackStreams == 0 ) continue ; sum = 0 ; if ( type == kSize ) { for ( pack = 1 ; pack < f [ i ] . numUnpackStreams ; pack ++ ) { if ( parse_7zip_uint64 ( a , usizes ) < 0 ) return ( - 1 ) ; sum += * usizes ++ ; } } * usizes ++ = folder_uncompressed_size ( & f [ i ] ) - sum ; } if ( type == kSize ) { if ( ( p = header_bytes ( a , 1 ) ) == NULL ) return ( - 1 ) ; type = * p ; } for ( i = 0 ; i < unpack_streams ; i ++ ) { ss -> digestsDefined [ i ] = 0 ; ss -> digests [ i ] = 0 ; } numDigests = 0 ; for ( i = 0 ; i < numFolders ; i ++ ) { if ( f [ i ] . numUnpackStreams != 1 || ! f [ i ] . digest_defined ) numDigests += ( uint32_t ) f [ i ] . numUnpackStreams ; } if ( type == kCRC ) { struct _7z_digests tmpDigests ; unsigned char * digestsDefined = ss -> digestsDefined ; uint32_t * digests = ss -> digests ; int di = 0 ; memset ( & tmpDigests , 0 , sizeof ( tmpDigests ) ) ; if ( read_Digests ( a , & ( tmpDigests ) , numDigests ) < 0 ) { free_Digest ( & tmpDigests ) ; return ( - 1 ) ; } for ( i = 0 ; i < numFolders ; i ++ ) { if ( f [ i ] . numUnpackStreams == 1 && f [ i ] . digest_defined ) { * digestsDefined ++ = 1 ; * digests ++ = f [ i ] . digest ; } else { unsigned j ; for ( j = 0 ; j < f [ i ] . numUnpackStreams ; j ++ , di ++ ) { * digestsDefined ++ = tmpDigests . defineds [ di ] ; * digests ++ = tmpDigests . digests [ di ] ; } } } free_Digest ( & tmpDigests ) ; if ( ( p = header_bytes ( a , 1 ) ) == NULL ) return ( - 1 ) ; type = * p ; } if ( type != kEnd ) return ( - 1 ) ; return ( 0 ) ; }",1 ) ; if ( unpack_streams > SIZE_MAX - UMAX_ENTRY ) { return ( - 1 ) ; }
25,"void iov_iter_pipe ( struct iov_iter * i , int direction , struct pipe_inode_info * pipe , size_t count ) { <S2SV_StartBug> BUG_ON ( direction != ITER_PIPE ) ; <S2SV_EndBug> i -> type = direction ; i -> pipe = pipe ; i -> idx = ( pipe -> curbuf + pipe -> nrbufs ) & ( pipe -> buffers - 1 ) ; i -> iov_offset = 0 ; i -> count = count ; }",direction != ITER_PIPE ) ; WARN_ON ( pipe -> nrbufs == pipe -> buffers
26,"static int do_remount ( struct path * path , int flags , int mnt_flags , void * data ) { int err ; struct super_block * sb = path -> mnt -> mnt_sb ; struct mount * mnt = real_mount ( path -> mnt ) ; if ( ! check_mnt ( mnt ) ) return - EINVAL ; if ( path -> dentry != path -> mnt -> mnt_root ) return - EINVAL ; err = security_sb_remount ( sb , data ) ; if ( err ) return err ; down_write ( & sb -> s_umount ) ; if ( flags & MS_BIND ) err = change_mount_flags ( path -> mnt , flags ) ; else if ( ! capable ( CAP_SYS_ADMIN ) ) err = - EPERM ; else err = do_remount_sb ( sb , flags , data , 0 ) ; if ( ! err ) { lock_mount_hash ( ) ; <S2SV_StartBug> mnt_flags |= mnt -> mnt . mnt_flags & MNT_PROPAGATION_MASK ; <S2SV_EndBug> mnt -> mnt . mnt_flags = mnt_flags ; touch_mnt_namespace ( mnt -> mnt_ns ) ; unlock_mount_hash ( ) ; } up_write ( & sb -> s_umount ) ; return err ; }",. mnt_flags & ~ MNT_USER_SETTABLE_MASK <S2SV_ModEnd> ; mnt ->
27,"<S2SV_StartBug> static int fsmVerify ( const char * path , rpmfi fi ) <S2SV_EndBug> { int rc ; int saveerrno = errno ; struct stat dsb ; mode_t mode = rpmfiFMode ( fi ) ; rc = fsmStat ( path , 1 , & dsb ) ; if ( rc ) return rc ; if ( S_ISREG ( mode ) ) { char * rmpath = rstrscat ( NULL , path , ""-RPMDELETE"" , NULL ) ; rc = fsmRename ( path , rmpath ) ; if ( ! rc ) ( void ) fsmUnlink ( rmpath ) ; else rc = RPMERR_UNLINK_FAILED ; free ( rmpath ) ; return ( rc ? rc : RPMERR_ENOENT ) ; } else if ( S_ISDIR ( mode ) ) { if ( S_ISDIR ( dsb . st_mode ) ) return 0 ; if ( S_ISLNK ( dsb . st_mode ) ) { <S2SV_StartBug> rc = fsmStat ( path , 0 , & dsb ) ; <S2SV_EndBug> if ( rc == RPMERR_ENOENT ) rc = 0 ; if ( rc ) return rc ; errno = saveerrno ; <S2SV_StartBug> if ( S_ISDIR ( dsb . st_mode ) ) return 0 ; <S2SV_EndBug> } } else if ( S_ISLNK ( mode ) ) { if ( S_ISLNK ( dsb . st_mode ) ) { char buf [ 8 * BUFSIZ ] ; size_t len ; rc = fsmReadLink ( path , buf , 8 * BUFSIZ , & len ) ; errno = saveerrno ; if ( rc ) return rc ; if ( rstreq ( rpmfiFLink ( fi ) , buf ) ) return 0 ; } } else if ( S_ISFIFO ( mode ) ) { if ( S_ISFIFO ( dsb . st_mode ) ) return 0 ; } else if ( S_ISCHR ( mode ) || S_ISBLK ( mode ) ) { if ( ( S_ISCHR ( dsb . st_mode ) || S_ISBLK ( dsb . st_mode ) ) && ( dsb . st_rdev == rpmfiFRdev ( fi ) ) ) return 0 ; } else if ( S_ISSOCK ( mode ) ) { if ( S_ISSOCK ( dsb . st_mode ) ) return 0 ; } rc = fsmUnlink ( path ) ; if ( rc == 0 ) rc = RPMERR_ENOENT ; return ( rc ? rc : RPMERR_ENOENT ) ; }",", rpmfi fi , const struct stat * fsb <S2SV_ModStart> ) ) { uid_t luid = dsb . st_uid ; <S2SV_ModStart> . st_mode ) && ( luid == 0 || luid == fsb -> st_uid ) ) <S2SV_ModEnd> return 0 ;"
28,"void snd_pcm_period_elapsed ( struct snd_pcm_substream * substream ) { struct snd_pcm_runtime * runtime ; unsigned long flags ; if ( PCM_RUNTIME_CHECK ( substream ) ) return ; runtime = substream -> runtime ; snd_pcm_stream_lock_irqsave ( substream , flags ) ; if ( ! snd_pcm_running ( substream ) || snd_pcm_update_hw_ptr0 ( substream , 1 ) < 0 ) goto _end ; # ifdef CONFIG_SND_PCM_TIMER if ( substream -> timer_running ) snd_timer_interrupt ( substream -> timer , 1 ) ; # endif _end : <S2SV_StartBug> snd_pcm_stream_unlock_irqrestore ( substream , flags ) ; <S2SV_EndBug> kill_fasync ( & runtime -> fasync , SIGIO , POLL_IN ) ; <S2SV_StartBug> } <S2SV_EndBug>","endif _end : <S2SV_ModEnd> kill_fasync ( & <S2SV_ModStart> POLL_IN ) ; snd_pcm_stream_unlock_irqrestore ( substream , flags ) ;"
29,"static int filter_frame ( AVFilterLink * inlink , AVFrame * in ) { AVFilterContext * ctx = inlink -> dst ; BoxBlurContext * s = ctx -> priv ; AVFilterLink * outlink = inlink -> dst -> outputs [ 0 ] ; AVFrame * out ; int plane ; int cw = FF_CEIL_RSHIFT ( inlink -> w , s -> hsub ) , ch = FF_CEIL_RSHIFT ( in -> height , s -> vsub ) ; int w [ 4 ] = { inlink -> w , cw , cw , inlink -> w } ; int h [ 4 ] = { in -> height , ch , ch , in -> height } ; out = ff_get_video_buffer ( outlink , outlink -> w , outlink -> h ) ; if ( ! out ) { av_frame_free ( & in ) ; return AVERROR ( ENOMEM ) ; } av_frame_copy_props ( out , in ) ; <S2SV_StartBug> for ( plane = 0 ; in -> data [ plane ] && plane < 4 ; plane ++ ) <S2SV_EndBug> hblur ( out -> data [ plane ] , out -> linesize [ plane ] , in -> data [ plane ] , in -> linesize [ plane ] , w [ plane ] , h [ plane ] , s -> radius [ plane ] , s -> power [ plane ] , s -> temp ) ; <S2SV_StartBug> for ( plane = 0 ; in -> data [ plane ] && plane < 4 ; plane ++ ) <S2SV_EndBug> vblur ( out -> data [ plane ] , out -> linesize [ plane ] , out -> data [ plane ] , out -> linesize [ plane ] , w [ plane ] , h [ plane ] , s -> radius [ plane ] , s -> power [ plane ] , s -> temp ) ; av_frame_free ( & in ) ; return ff_filter_frame ( outlink , out ) ; }",= 0 ; <S2SV_ModEnd> plane < 4 <S2SV_ModStart> plane < 4 && in -> data [ plane ] && in -> linesize [ plane ] <S2SV_ModStart> = 0 ; <S2SV_ModEnd> plane < 4 <S2SV_ModStart> plane < 4 && in -> data [ plane ] && in -> linesize [ plane ]
30,"void ion_free ( struct ion_client * client , struct ion_handle * handle ) { <S2SV_StartBug> bool valid_handle ; <S2SV_EndBug> BUG_ON ( client != handle -> client ) ; mutex_lock ( & client -> lock ) ; <S2SV_StartBug> valid_handle = ion_handle_validate ( client , handle ) ; <S2SV_EndBug> if ( ! valid_handle ) { WARN ( 1 , ""%s:<S2SV_blank>invalid<S2SV_blank>handle<S2SV_blank>passed<S2SV_blank>to<S2SV_blank>free.\\n"" , __func__ ) ; mutex_unlock ( & client -> lock ) ; <S2SV_StartBug> return ; <S2SV_EndBug> } mutex_unlock ( & client -> lock ) ; ion_handle_put ( handle ) ; }","handle ) { <S2SV_ModEnd> BUG_ON ( client <S2SV_ModStart> lock ) ; ion_free_nolock <S2SV_ModEnd> ( client , <S2SV_ModStart> client , handle <S2SV_ModEnd> ) ; mutex_unlock <S2SV_ModStart> lock ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>"
31,"WORD32 ih264d_cavlc_4x4res_block_totalcoeff_2to10 ( UWORD32 u4_isdc , UWORD32 u4_total_coeff_trail_one , dec_bit_stream_t * ps_bitstrm ) { UWORD32 u4_total_zeroes ; WORD32 i ; UWORD32 * pu4_bitstrm_buf = ps_bitstrm -> pu4_buffer ; UWORD32 u4_bitstream_offset = ps_bitstrm -> u4_ofst ; UWORD32 u4_trailing_ones = u4_total_coeff_trail_one & 0xFFFF ; UWORD32 u4_total_coeff = u4_total_coeff_trail_one >> 16 ; <S2SV_StartBug> WORD16 i2_level_arr [ 16 ] ; <S2SV_EndBug> tu_sblk4x4_coeff_data_t * ps_tu_4x4 ; WORD16 * pi2_coeff_data ; dec_struct_t * ps_dec = ( dec_struct_t * ) ps_bitstrm -> pv_codec_handle ; ps_tu_4x4 = ( tu_sblk4x4_coeff_data_t * ) ps_dec -> pv_parse_tu_coeff_data ; ps_tu_4x4 -> u2_sig_coeff_map = 0 ; pi2_coeff_data = & ps_tu_4x4 -> ai2_level [ 0 ] ; i = u4_total_coeff - 1 ; if ( u4_trailing_ones ) { UWORD32 u4_signs , u4_cnt = u4_trailing_ones ; WORD16 ( * ppi2_trlone_lkup ) [ 3 ] = ( WORD16 ( * ) [ 3 ] ) gai2_ih264d_trailing_one_level ; WORD16 * pi2_trlone_lkup ; GETBITS ( u4_signs , u4_bitstream_offset , pu4_bitstrm_buf , u4_cnt ) ; pi2_trlone_lkup = ppi2_trlone_lkup [ ( 1 << u4_cnt ) - 2 + u4_signs ] ; while ( u4_cnt -- ) i2_level_arr [ i -- ] = * pi2_trlone_lkup ++ ; } if ( i >= 0 ) { UWORD32 u4_lev_suffix , u4_suffix_len , u4_lev_suffix_size ; WORD32 u2_lev_code , u2_abs_value ; UWORD32 u4_lev_prefix ; FIND_ONE_IN_STREAM_32 ( u4_lev_prefix , u4_bitstream_offset , pu4_bitstrm_buf ) ; u2_lev_code = MIN ( 15 , u4_lev_prefix ) ; u2_lev_code += ( 3 == u4_trailing_ones ) ? 0 : 2 ; if ( 14 == u4_lev_prefix ) u4_lev_suffix_size = 4 ; else if ( 15 <= u4_lev_prefix ) { u2_lev_code += 15 ; u4_lev_suffix_size = u4_lev_prefix - 3 ; } else u4_lev_suffix_size = 0 ; if ( 16 <= u4_lev_prefix ) { u2_lev_code += ( ( 1 << ( u4_lev_prefix - 3 ) ) - 4096 ) ; } if ( u4_lev_suffix_size ) { GETBITS ( u4_lev_suffix , u4_bitstream_offset , pu4_bitstrm_buf , u4_lev_suffix_size ) ; u2_lev_code += u4_lev_suffix ; } u2_abs_value = ( u2_lev_code + 2 ) >> 1 ; i2_level_arr [ i -- ] = ( u2_lev_code & 1 ) ? - u2_abs_value : u2_abs_value ; u4_suffix_len = ( u2_abs_value > 3 ) ? 2 : 1 ; while ( i >= 0 ) { FIND_ONE_IN_STREAM_32 ( u4_lev_prefix , u4_bitstream_offset , pu4_bitstrm_buf ) ; u4_lev_suffix_size = ( 15 <= u4_lev_prefix ) ? ( u4_lev_prefix - 3 ) : u4_suffix_len ; GETBITS ( u4_lev_suffix , u4_bitstream_offset , pu4_bitstrm_buf , u4_lev_suffix_size ) ; u2_lev_code = ( MIN ( 15 , u4_lev_prefix ) << u4_suffix_len ) + u4_lev_suffix ; if ( 16 <= u4_lev_prefix ) { u2_lev_code += ( ( 1 << ( u4_lev_prefix - 3 ) ) - 4096 ) ; } u2_abs_value = ( u2_lev_code + 2 ) >> 1 ; i2_level_arr [ i -- ] = ( u2_lev_code & 1 ) ? - u2_abs_value : u2_abs_value ; u4_suffix_len += ( u4_suffix_len < 6 ) ? ( u2_abs_value > ( 3 << ( u4_suffix_len - 1 ) ) ) : 0 ; } } { UWORD32 u4_index ; const UWORD8 ( * ppu1_total_zero_lkup ) [ 64 ] = ( const UWORD8 ( * ) [ 64 ] ) gau1_ih264d_table_total_zero_2to10 ; NEXTBITS ( u4_index , u4_bitstream_offset , pu4_bitstrm_buf , 6 ) ; u4_total_zeroes = ppu1_total_zero_lkup [ u4_total_coeff - 2 ] [ u4_index ] ; FLUSHBITS ( u4_bitstream_offset , ( u4_total_zeroes >> 4 ) ) ; u4_total_zeroes &= 0xf ; } { const UWORD8 * pu1_table_runbefore ; UWORD32 u4_run ; WORD32 k ; UWORD32 u4_scan_pos = u4_total_coeff + u4_total_zeroes - 1 + u4_isdc ; WORD32 u4_zeroes_left = u4_total_zeroes ; k = u4_total_coeff - 1 ; while ( ( u4_zeroes_left > 6 ) && k ) { UWORD32 u4_code ; NEXTBITS ( u4_code , u4_bitstream_offset , pu4_bitstrm_buf , 3 ) ; if ( u4_code != 0 ) { FLUSHBITS ( u4_bitstream_offset , 3 ) ; u4_run = ( 7 - u4_code ) ; } else { FIND_ONE_IN_STREAM_LEN ( u4_code , u4_bitstream_offset , pu4_bitstrm_buf , 11 ) ; u4_run = ( 4 + u4_code ) ; } SET_BIT ( ps_tu_4x4 -> u2_sig_coeff_map , u4_scan_pos ) ; * pi2_coeff_data ++ = i2_level_arr [ k -- ] ; u4_zeroes_left -= u4_run ; u4_scan_pos -= ( u4_run + 1 ) ; } pu1_table_runbefore = ( UWORD8 * ) gau1_ih264d_table_run_before ; while ( ( u4_zeroes_left > 0 ) && k ) { UWORD32 u4_code ; NEXTBITS ( u4_code , u4_bitstream_offset , pu4_bitstrm_buf , 3 ) ; u4_code = pu1_table_runbefore [ u4_code + ( u4_zeroes_left << 3 ) ] ; u4_run = u4_code >> 2 ; FLUSHBITS ( u4_bitstream_offset , ( u4_code & 0x03 ) ) ; SET_BIT ( ps_tu_4x4 -> u2_sig_coeff_map , u4_scan_pos ) ; * pi2_coeff_data ++ = i2_level_arr [ k -- ] ; u4_zeroes_left -= u4_run ; u4_scan_pos -= ( u4_run + 1 ) ; } if ( u4_zeroes_left < 0 ) return - 1 ; while ( k >= 0 ) { SET_BIT ( ps_tu_4x4 -> u2_sig_coeff_map , u4_scan_pos ) ; * pi2_coeff_data ++ = i2_level_arr [ k -- ] ; u4_scan_pos -- ; } } { WORD32 offset ; offset = ( UWORD8 * ) pi2_coeff_data - ( UWORD8 * ) ps_tu_4x4 ; offset = ALIGN4 ( offset ) ; ps_dec -> pv_parse_tu_coeff_data = ( void * ) ( ( UWORD8 * ) ps_dec -> pv_parse_tu_coeff_data + offset ) ; } ps_bitstrm -> u4_ofst = u4_bitstream_offset ; return 0 ; }",16 ; WORD16 ai2_level_arr [ 19 ] ; WORD16 * i2_level_arr = & ai2_level_arr [ 3 <S2SV_ModEnd> ] ; tu_sblk4x4_coeff_data_t
32,"static void show_frame ( WriterContext * w , AVFrame * frame , AVStream * stream , AVFormatContext * fmt_ctx ) { AVBPrint pbuf ; char val_str [ 128 ] ; const char * s ; int i ; av_bprint_init ( & pbuf , 1 , AV_BPRINT_SIZE_UNLIMITED ) ; writer_print_section_header ( w , SECTION_ID_FRAME ) ; s = av_get_media_type_string ( stream -> codecpar -> codec_type ) ; if ( s ) print_str ( ""media_type"" , s ) ; else print_str_opt ( ""media_type"" , ""unknown"" ) ; print_int ( ""stream_index"" , stream -> index ) ; print_int ( ""key_frame"" , frame -> key_frame ) ; print_ts ( ""pkt_pts"" , frame -> pts ) ; print_time ( ""pkt_pts_time"" , frame -> pts , & stream -> time_base ) ; print_ts ( ""pkt_dts"" , frame -> pkt_dts ) ; print_time ( ""pkt_dts_time"" , frame -> pkt_dts , & stream -> time_base ) ; print_ts ( ""best_effort_timestamp"" , frame -> best_effort_timestamp ) ; print_time ( ""best_effort_timestamp_time"" , frame -> best_effort_timestamp , & stream -> time_base ) ; print_duration_ts ( ""pkt_duration"" , frame -> pkt_duration ) ; print_duration_time ( ""pkt_duration_time"" , frame -> pkt_duration , & stream -> time_base ) ; if ( frame -> pkt_pos != - 1 ) print_fmt ( ""pkt_pos"" , ""%"" PRId64 , frame -> pkt_pos ) ; else print_str_opt ( ""pkt_pos"" , ""N/A"" ) ; if ( frame -> pkt_size != - 1 ) print_val ( ""pkt_size"" , frame -> pkt_size , unit_byte_str ) ; else print_str_opt ( ""pkt_size"" , ""N/A"" ) ; switch ( stream -> codecpar -> codec_type ) { AVRational sar ; case AVMEDIA_TYPE_VIDEO : print_int ( ""width"" , frame -> width ) ; print_int ( ""height"" , frame -> height ) ; s = av_get_pix_fmt_name ( frame -> format ) ; if ( s ) print_str ( ""pix_fmt"" , s ) ; else print_str_opt ( ""pix_fmt"" , ""unknown"" ) ; sar = av_guess_sample_aspect_ratio ( fmt_ctx , stream , frame ) ; if ( sar . num ) { print_q ( ""sample_aspect_ratio"" , sar , ':' ) ; } else { print_str_opt ( ""sample_aspect_ratio"" , ""N/A"" ) ; } print_fmt ( ""pict_type"" , ""%c"" , av_get_picture_type_char ( frame -> pict_type ) ) ; print_int ( ""coded_picture_number"" , frame -> coded_picture_number ) ; print_int ( ""display_picture_number"" , frame -> display_picture_number ) ; print_int ( ""interlaced_frame"" , frame -> interlaced_frame ) ; print_int ( ""top_field_first"" , frame -> top_field_first ) ; print_int ( ""repeat_pict"" , frame -> repeat_pict ) ; if ( frame -> color_range != AVCOL_RANGE_UNSPECIFIED ) print_str ( ""color_range"" , av_color_range_name ( frame -> color_range ) ) ; else print_str_opt ( ""color_range"" , av_color_range_name ( frame -> color_range ) ) ; if ( frame -> colorspace != AVCOL_SPC_UNSPECIFIED ) print_str ( ""color_space"" , av_color_space_name ( frame -> colorspace ) ) ; else print_str_opt ( ""color_space"" , av_color_space_name ( frame -> colorspace ) ) ; <S2SV_StartBug> if ( frame -> color_primaries != AVCOL_PRI_UNSPECIFIED ) <S2SV_EndBug> print_str ( ""color_primaries"" , av_color_primaries_name ( frame -> color_primaries ) ) ; else print_str_opt ( ""color_primaries"" , av_color_primaries_name ( frame -> color_primaries ) ) ; if ( frame -> color_trc != AVCOL_TRC_UNSPECIFIED ) print_str ( ""color_transfer"" , av_color_transfer_name ( frame -> color_trc ) ) ; else print_str_opt ( ""color_transfer"" , av_color_transfer_name ( frame -> color_trc ) ) ; if ( frame -> chroma_location != AVCHROMA_LOC_UNSPECIFIED ) print_str ( ""chroma_location"" , av_chroma_location_name ( frame -> chroma_location ) ) ; else print_str_opt ( ""chroma_location"" , av_chroma_location_name ( frame -> chroma_location ) ) ; break ; case AVMEDIA_TYPE_AUDIO : s = av_get_sample_fmt_name ( frame -> format ) ; if ( s ) print_str ( ""sample_fmt"" , s ) ; else print_str_opt ( ""sample_fmt"" , ""unknown"" ) ; print_int ( ""nb_samples"" , frame -> nb_samples ) ; print_int ( ""channels"" , frame -> channels ) ; if ( frame -> channel_layout ) { av_bprint_clear ( & pbuf ) ; av_bprint_channel_layout ( & pbuf , frame -> channels , frame -> channel_layout ) ; print_str ( ""channel_layout"" , pbuf . str ) ; } else print_str_opt ( ""channel_layout"" , ""unknown"" ) ; break ; } if ( do_show_frame_tags ) show_tags ( w , frame -> metadata , SECTION_ID_FRAME_TAGS ) ; if ( do_show_log ) show_log ( w , SECTION_ID_FRAME_LOGS , SECTION_ID_FRAME_LOG , do_show_log ) ; if ( frame -> nb_side_data ) { writer_print_section_header ( w , SECTION_ID_FRAME_SIDE_DATA_LIST ) ; for ( i = 0 ; i < frame -> nb_side_data ; i ++ ) { AVFrameSideData * sd = frame -> side_data [ i ] ; const char * name ; writer_print_section_header ( w , SECTION_ID_FRAME_SIDE_DATA ) ; name = av_frame_side_data_name ( sd -> type ) ; print_str ( ""side_data_type"" , name ? name : ""unknown"" ) ; if ( sd -> type == AV_FRAME_DATA_DISPLAYMATRIX && sd -> size >= 9 * 4 ) { writer_print_integers ( w , ""displaymatrix"" , sd -> data , 9 , ""<S2SV_blank>%11d"" , 3 , 4 , 1 ) ; print_int ( ""rotation"" , av_display_rotation_get ( ( int32_t * ) sd -> data ) ) ; } else if ( sd -> type == AV_FRAME_DATA_GOP_TIMECODE && sd -> size >= 8 ) { char tcbuf [ AV_TIMECODE_STR_SIZE ] ; av_timecode_make_mpeg_tc_string ( tcbuf , * ( int64_t * ) ( sd -> data ) ) ; print_str ( ""timecode"" , tcbuf ) ; } else if ( sd -> type == AV_FRAME_DATA_MASTERING_DISPLAY_METADATA ) { AVMasteringDisplayMetadata * metadata = ( AVMasteringDisplayMetadata * ) sd -> data ; if ( metadata -> has_primaries ) { print_q ( ""red_x"" , metadata -> display_primaries [ 0 ] [ 0 ] , '/' ) ; print_q ( ""red_y"" , metadata -> display_primaries [ 0 ] [ 1 ] , '/' ) ; print_q ( ""green_x"" , metadata -> display_primaries [ 1 ] [ 0 ] , '/' ) ; print_q ( ""green_y"" , metadata -> display_primaries [ 1 ] [ 1 ] , '/' ) ; print_q ( ""blue_x"" , metadata -> display_primaries [ 2 ] [ 0 ] , '/' ) ; print_q ( ""blue_y"" , metadata -> display_primaries [ 2 ] [ 1 ] , '/' ) ; print_q ( ""white_point_x"" , metadata -> white_point [ 0 ] , '/' ) ; print_q ( ""white_point_y"" , metadata -> white_point [ 1 ] , '/' ) ; } if ( metadata -> has_luminance ) { print_q ( ""min_luminance"" , metadata -> min_luminance , '/' ) ; print_q ( ""max_luminance"" , metadata -> max_luminance , '/' ) ; } } else if ( sd -> type == AV_FRAME_DATA_CONTENT_LIGHT_LEVEL ) { AVContentLightMetadata * metadata = ( AVContentLightMetadata * ) sd -> data ; print_int ( ""max_content"" , metadata -> MaxCLL ) ; print_int ( ""max_average"" , metadata -> MaxFALL ) ; } else if ( sd -> type == AV_FRAME_DATA_ICC_PROFILE ) { AVDictionaryEntry * tag = av_dict_get ( sd -> metadata , ""name"" , NULL , AV_DICT_MATCH_CASE ) ; if ( tag ) print_str ( tag -> key , tag -> value ) ; print_int ( ""size"" , sd -> size ) ; } writer_print_section_footer ( w ) ; } writer_print_section_footer ( w ) ; } writer_print_section_footer ( w ) ; av_bprint_finalize ( & pbuf , NULL ) ; fflush ( stdout ) ; }",") ) ; print_primaries ( w , <S2SV_ModEnd> frame -> color_primaries <S2SV_ModStart> frame -> color_primaries <S2SV_ModEnd> ) ; if"
33,"static int get_siz ( Jpeg2000DecoderContext * s ) { int i ; int ncomponents ; uint32_t log2_chroma_wh = 0 ; const enum AVPixelFormat * possible_fmts = NULL ; int possible_fmts_nb = 0 ; if ( bytestream2_get_bytes_left ( & s -> g ) < 36 ) return AVERROR_INVALIDDATA ; s -> avctx -> profile = bytestream2_get_be16u ( & s -> g ) ; s -> width = bytestream2_get_be32u ( & s -> g ) ; s -> height = bytestream2_get_be32u ( & s -> g ) ; s -> image_offset_x = bytestream2_get_be32u ( & s -> g ) ; s -> image_offset_y = bytestream2_get_be32u ( & s -> g ) ; s -> tile_width = bytestream2_get_be32u ( & s -> g ) ; s -> tile_height = bytestream2_get_be32u ( & s -> g ) ; s -> tile_offset_x = bytestream2_get_be32u ( & s -> g ) ; s -> tile_offset_y = bytestream2_get_be32u ( & s -> g ) ; ncomponents = bytestream2_get_be16u ( & s -> g ) ; if ( ncomponents <= 0 ) { av_log ( s -> avctx , AV_LOG_ERROR , ""Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>components:<S2SV_blank>%d\\n"" , s -> ncomponents ) ; return AVERROR_INVALIDDATA ; } if ( ncomponents > 4 ) { avpriv_request_sample ( s -> avctx , ""Support<S2SV_blank>for<S2SV_blank>%d<S2SV_blank>components"" , s -> ncomponents ) ; return AVERROR_PATCHWELCOME ; } s -> ncomponents = ncomponents ; if ( s -> tile_width <= 0 || s -> tile_height <= 0 ) { av_log ( s -> avctx , AV_LOG_ERROR , ""Invalid<S2SV_blank>tile<S2SV_blank>dimension<S2SV_blank>%dx%d.\\n"" , s -> tile_width , s -> tile_height ) ; return AVERROR_INVALIDDATA ; } if ( bytestream2_get_bytes_left ( & s -> g ) < 3 * s -> ncomponents ) return AVERROR_INVALIDDATA ; for ( i = 0 ; i < s -> ncomponents ; i ++ ) { uint8_t x = bytestream2_get_byteu ( & s -> g ) ; s -> cbps [ i ] = ( x & 0x7f ) + 1 ; s -> precision = FFMAX ( s -> cbps [ i ] , s -> precision ) ; s -> sgnd [ i ] = ! ! ( x & 0x80 ) ; s -> cdx [ i ] = bytestream2_get_byteu ( & s -> g ) ; s -> cdy [ i ] = bytestream2_get_byteu ( & s -> g ) ; <S2SV_StartBug> if ( ! s -> cdx [ i ] || ! s -> cdy [ i ] ) { <S2SV_EndBug> av_log ( s -> avctx , AV_LOG_ERROR , ""Invalid<S2SV_blank>sample<S2SV_blank>seperation\\n"" ) ; return AVERROR_INVALIDDATA ; } log2_chroma_wh |= s -> cdy [ i ] >> 1 << i * 4 | s -> cdx [ i ] >> 1 << i * 4 + 2 ; } s -> numXtiles = ff_jpeg2000_ceildiv ( s -> width - s -> tile_offset_x , s -> tile_width ) ; s -> numYtiles = ff_jpeg2000_ceildiv ( s -> height - s -> tile_offset_y , s -> tile_height ) ; if ( s -> numXtiles * ( uint64_t ) s -> numYtiles > INT_MAX / sizeof ( * s -> tile ) ) { s -> numXtiles = s -> numYtiles = 0 ; return AVERROR ( EINVAL ) ; } s -> tile = av_mallocz_array ( s -> numXtiles * s -> numYtiles , sizeof ( * s -> tile ) ) ; if ( ! s -> tile ) { s -> numXtiles = s -> numYtiles = 0 ; return AVERROR ( ENOMEM ) ; } for ( i = 0 ; i < s -> numXtiles * s -> numYtiles ; i ++ ) { Jpeg2000Tile * tile = s -> tile + i ; tile -> comp = av_mallocz ( s -> ncomponents * sizeof ( * tile -> comp ) ) ; if ( ! tile -> comp ) return AVERROR ( ENOMEM ) ; } s -> avctx -> width = ff_jpeg2000_ceildivpow2 ( s -> width - s -> image_offset_x , s -> reduction_factor ) ; s -> avctx -> height = ff_jpeg2000_ceildivpow2 ( s -> height - s -> image_offset_y , s -> reduction_factor ) ; if ( s -> avctx -> profile == FF_PROFILE_JPEG2000_DCINEMA_2K || s -> avctx -> profile == FF_PROFILE_JPEG2000_DCINEMA_4K ) { possible_fmts = xyz_pix_fmts ; possible_fmts_nb = FF_ARRAY_ELEMS ( xyz_pix_fmts ) ; } else { switch ( s -> colour_space ) { case 16 : possible_fmts = rgb_pix_fmts ; possible_fmts_nb = FF_ARRAY_ELEMS ( rgb_pix_fmts ) ; break ; case 17 : possible_fmts = gray_pix_fmts ; possible_fmts_nb = FF_ARRAY_ELEMS ( gray_pix_fmts ) ; break ; case 18 : possible_fmts = yuv_pix_fmts ; possible_fmts_nb = FF_ARRAY_ELEMS ( yuv_pix_fmts ) ; break ; default : possible_fmts = all_pix_fmts ; possible_fmts_nb = FF_ARRAY_ELEMS ( all_pix_fmts ) ; break ; } } for ( i = 0 ; i < possible_fmts_nb ; ++ i ) { if ( pix_fmt_match ( possible_fmts [ i ] , ncomponents , s -> precision , log2_chroma_wh , s -> pal8 ) ) { s -> avctx -> pix_fmt = possible_fmts [ i ] ; break ; } } if ( s -> avctx -> pix_fmt == AV_PIX_FMT_NONE ) { av_log ( s -> avctx , AV_LOG_ERROR , ""Unknown<S2SV_blank>pix_fmt,<S2SV_blank>profile:<S2SV_blank>%d,<S2SV_blank>colour_space:<S2SV_blank>%d,<S2SV_blank>"" ""components:<S2SV_blank>%d,<S2SV_blank>precision:<S2SV_blank>%d,<S2SV_blank>"" ""cdx[1]:<S2SV_blank>%d,<S2SV_blank>cdy[1]:<S2SV_blank>%d,<S2SV_blank>cdx[2]:<S2SV_blank>%d,<S2SV_blank>cdy[2]:<S2SV_blank>%d\\n"" , s -> avctx -> profile , s -> colour_space , ncomponents , s -> precision , ncomponents > 2 ? s -> cdx [ 1 ] : 0 , ncomponents > 2 ? s -> cdy [ 1 ] : 0 , ncomponents > 2 ? s -> cdx [ 2 ] : 0 , ncomponents > 2 ? s -> cdy [ 2 ] : 0 ) ; } return 0 ; }",i ] || s -> cdx [ i ] == 3 || s -> cdx [ i ] > 4 || <S2SV_ModStart> [ i ] || s -> cdy [ i ] == 3 || s -> cdy [ i ] > 4
34,"int ParseRiffHeaderConfig ( FILE * infile , char * infilename , char * fourcc , WavpackContext * wpc , WavpackConfig * config ) { int is_rf64 = ! strncmp ( fourcc , ""RF64"" , 4 ) , got_ds64 = 0 ; int64_t total_samples = 0 , infilesize ; RiffChunkHeader riff_chunk_header ; ChunkHeader chunk_header ; WaveHeader WaveHeader ; DS64Chunk ds64_chunk ; uint32_t bcount ; CLEAR ( WaveHeader ) ; CLEAR ( ds64_chunk ) ; infilesize = DoGetFileSize ( infile ) ; if ( ! is_rf64 && infilesize >= 4294967296LL && ! ( config -> qmode & QMODE_IGNORE_LENGTH ) ) { error_line ( ""can\'t<S2SV_blank>handle<S2SV_blank>.WAV<S2SV_blank>files<S2SV_blank>larger<S2SV_blank>than<S2SV_blank>4<S2SV_blank>GB<S2SV_blank>(non-standard)!"" ) ; return WAVPACK_SOFT_ERROR ; } memcpy ( & riff_chunk_header , fourcc , 4 ) ; if ( ( ! DoReadFile ( infile , ( ( char * ) & riff_chunk_header ) + 4 , sizeof ( RiffChunkHeader ) - 4 , & bcount ) || bcount != sizeof ( RiffChunkHeader ) - 4 || strncmp ( riff_chunk_header . formType , ""WAVE"" , 4 ) ) ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.WAV<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & riff_chunk_header , sizeof ( RiffChunkHeader ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } while ( 1 ) { if ( ! DoReadFile ( infile , & chunk_header , sizeof ( ChunkHeader ) , & bcount ) || bcount != sizeof ( ChunkHeader ) ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.WAV<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & chunk_header , sizeof ( ChunkHeader ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackLittleEndianToNative ( & chunk_header , ChunkHeaderFormat ) ; if ( ! strncmp ( chunk_header . ckID , ""ds64"" , 4 ) ) { if ( chunk_header . ckSize < sizeof ( DS64Chunk ) || ! DoReadFile ( infile , & ds64_chunk , sizeof ( DS64Chunk ) , & bcount ) || bcount != sizeof ( DS64Chunk ) ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.WAV<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & ds64_chunk , sizeof ( DS64Chunk ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } got_ds64 = 1 ; WavpackLittleEndianToNative ( & ds64_chunk , DS64ChunkFormat ) ; if ( debug_logging_mode ) error_line ( ""DS64:<S2SV_blank>riffSize<S2SV_blank>=<S2SV_blank>%lld,<S2SV_blank>dataSize<S2SV_blank>=<S2SV_blank>%lld,<S2SV_blank>sampleCount<S2SV_blank>=<S2SV_blank>%lld,<S2SV_blank>table_length<S2SV_blank>=<S2SV_blank>%d"" , ( long long ) ds64_chunk . riffSize64 , ( long long ) ds64_chunk . dataSize64 , ( long long ) ds64_chunk . sampleCount64 , ds64_chunk . tableLength ) ; if ( ds64_chunk . tableLength * sizeof ( CS64Chunk ) != chunk_header . ckSize - sizeof ( DS64Chunk ) ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.WAV<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } while ( ds64_chunk . tableLength -- ) { CS64Chunk cs64_chunk ; if ( ! DoReadFile ( infile , & cs64_chunk , sizeof ( CS64Chunk ) , & bcount ) || bcount != sizeof ( CS64Chunk ) || ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & cs64_chunk , sizeof ( CS64Chunk ) ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } } } else if ( ! strncmp ( chunk_header . ckID , ""fmt<S2SV_blank>"" , 4 ) ) { int supported = TRUE , format ; if ( chunk_header . ckSize < 16 || chunk_header . ckSize > sizeof ( WaveHeader ) || ! DoReadFile ( infile , & WaveHeader , chunk_header . ckSize , & bcount ) || bcount != chunk_header . ckSize ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.WAV<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & WaveHeader , chunk_header . ckSize ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackLittleEndianToNative ( & WaveHeader , WaveHeaderFormat ) ; if ( debug_logging_mode ) { error_line ( ""format<S2SV_blank>tag<S2SV_blank>size<S2SV_blank>=<S2SV_blank>%d"" , chunk_header . ckSize ) ; error_line ( ""FormatTag<S2SV_blank>=<S2SV_blank>%x,<S2SV_blank>NumChannels<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>BitsPerSample<S2SV_blank>=<S2SV_blank>%d"" , WaveHeader . FormatTag , WaveHeader . NumChannels , WaveHeader . BitsPerSample ) ; error_line ( ""BlockAlign<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>SampleRate<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>BytesPerSecond<S2SV_blank>=<S2SV_blank>%d"" , WaveHeader . BlockAlign , WaveHeader . SampleRate , WaveHeader . BytesPerSecond ) ; if ( chunk_header . ckSize > 16 ) error_line ( ""cbSize<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>ValidBitsPerSample<S2SV_blank>=<S2SV_blank>%d"" , WaveHeader . cbSize , WaveHeader . ValidBitsPerSample ) ; if ( chunk_header . ckSize > 20 ) error_line ( ""ChannelMask<S2SV_blank>=<S2SV_blank>%x,<S2SV_blank>SubFormat<S2SV_blank>=<S2SV_blank>%d"" , WaveHeader . ChannelMask , WaveHeader . SubFormat ) ; } if ( chunk_header . ckSize > 16 && WaveHeader . cbSize == 2 ) config -> qmode |= QMODE_ADOBE_MODE ; format = ( WaveHeader . FormatTag == 0xfffe && chunk_header . ckSize == 40 ) ? WaveHeader . SubFormat : WaveHeader . FormatTag ; config -> bits_per_sample = ( chunk_header . ckSize == 40 && WaveHeader . ValidBitsPerSample ) ? WaveHeader . ValidBitsPerSample : WaveHeader . BitsPerSample ; if ( format != 1 && format != 3 ) supported = FALSE ; if ( format == 3 && config -> bits_per_sample != 32 ) supported = FALSE ; if ( ! WaveHeader . NumChannels || WaveHeader . NumChannels > 256 || WaveHeader . BlockAlign / WaveHeader . NumChannels < ( config -> bits_per_sample + 7 ) / 8 || WaveHeader . BlockAlign / WaveHeader . NumChannels > 4 || WaveHeader . BlockAlign % WaveHeader . NumChannels ) supported = FALSE ; if ( config -> bits_per_sample < 1 || config -> bits_per_sample > 32 ) supported = FALSE ; if ( ! supported ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>an<S2SV_blank>unsupported<S2SV_blank>.WAV<S2SV_blank>format!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( chunk_header . ckSize < 40 ) { if ( ! config -> channel_mask && ! ( config -> qmode & QMODE_CHANS_UNASSIGNED ) ) { if ( WaveHeader . NumChannels <= 2 ) config -> channel_mask = 0x5 - WaveHeader . NumChannels ; else if ( WaveHeader . NumChannels <= 18 ) config -> channel_mask = ( 1 << WaveHeader . NumChannels ) - 1 ; else config -> channel_mask = 0x3ffff ; } } else if ( WaveHeader . ChannelMask && ( config -> channel_mask || ( config -> qmode & QMODE_CHANS_UNASSIGNED ) ) ) { error_line ( ""this<S2SV_blank>WAV<S2SV_blank>file<S2SV_blank>already<S2SV_blank>has<S2SV_blank>channel<S2SV_blank>order<S2SV_blank>information!"" ) ; return WAVPACK_SOFT_ERROR ; } else if ( WaveHeader . ChannelMask ) config -> channel_mask = WaveHeader . ChannelMask ; if ( format == 3 ) config -> float_norm_exp = 127 ; else if ( ( config -> qmode & QMODE_ADOBE_MODE ) && WaveHeader . BlockAlign / WaveHeader . NumChannels == 4 ) { if ( WaveHeader . BitsPerSample == 24 ) config -> float_norm_exp = 127 + 23 ; else if ( WaveHeader . BitsPerSample == 32 ) config -> float_norm_exp = 127 + 15 ; } if ( debug_logging_mode ) { if ( config -> float_norm_exp == 127 ) error_line ( ""data<S2SV_blank>format:<S2SV_blank>normalized<S2SV_blank>32-bit<S2SV_blank>floating<S2SV_blank>point"" ) ; else if ( config -> float_norm_exp ) error_line ( ""data<S2SV_blank>format:<S2SV_blank>32-bit<S2SV_blank>floating<S2SV_blank>point<S2SV_blank>(Audition<S2SV_blank>%d:%d<S2SV_blank>float<S2SV_blank>type<S2SV_blank>1)"" , config -> float_norm_exp - 126 , 150 - config -> float_norm_exp ) ; else error_line ( ""data<S2SV_blank>format:<S2SV_blank>%d-bit<S2SV_blank>integers<S2SV_blank>stored<S2SV_blank>in<S2SV_blank>%d<S2SV_blank>byte(s)"" , config -> bits_per_sample , WaveHeader . BlockAlign / WaveHeader . NumChannels ) ; } } else if ( ! strncmp ( chunk_header . ckID , ""data"" , 4 ) ) { int64_t data_chunk_size = ( got_ds64 && chunk_header . ckSize == ( uint32_t ) - 1 ) ? ds64_chunk . dataSize64 : chunk_header . ckSize ; if ( ! WaveHeader . NumChannels || ( is_rf64 && ! got_ds64 ) ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.WAV<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( infilesize && ! ( config -> qmode & QMODE_IGNORE_LENGTH ) && infilesize - data_chunk_size > 16777216 ) { error_line ( ""this<S2SV_blank>.WAV<S2SV_blank>file<S2SV_blank>has<S2SV_blank>over<S2SV_blank>16<S2SV_blank>MB<S2SV_blank>of<S2SV_blank>extra<S2SV_blank>RIFF<S2SV_blank>data,<S2SV_blank>probably<S2SV_blank>is<S2SV_blank>corrupt!"" ) ; return WAVPACK_SOFT_ERROR ; } if ( config -> qmode & QMODE_IGNORE_LENGTH ) { if ( infilesize && DoGetFilePosition ( infile ) != - 1 ) total_samples = ( infilesize - DoGetFilePosition ( infile ) ) / WaveHeader . BlockAlign ; else total_samples = - 1 ; } else { total_samples = data_chunk_size / WaveHeader . BlockAlign ; if ( got_ds64 && total_samples != ds64_chunk . sampleCount64 ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.WAV<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( ! total_samples ) { error_line ( ""this<S2SV_blank>.WAV<S2SV_blank>file<S2SV_blank>has<S2SV_blank>no<S2SV_blank>audio<S2SV_blank>samples,<S2SV_blank>probably<S2SV_blank>is<S2SV_blank>corrupt!"" ) ; return WAVPACK_SOFT_ERROR ; } if ( total_samples > MAX_WAVPACK_SAMPLES ) { error_line ( ""%s<S2SV_blank>has<S2SV_blank>too<S2SV_blank>many<S2SV_blank>samples<S2SV_blank>for<S2SV_blank>WavPack!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } } config -> bytes_per_sample = WaveHeader . BlockAlign / WaveHeader . NumChannels ; config -> num_channels = WaveHeader . NumChannels ; config -> sample_rate = WaveHeader . SampleRate ; break ; } else { int bytes_to_copy = ( chunk_header . ckSize + 1 ) & ~ 1L ; <S2SV_StartBug> char * buff = malloc ( bytes_to_copy ) ; <S2SV_EndBug> if ( debug_logging_mode ) error_line ( ""extra<S2SV_blank>unknown<S2SV_blank>chunk<S2SV_blank>\\""%c%c%c%c\\""<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes"" , chunk_header . ckID [ 0 ] , chunk_header . ckID [ 1 ] , chunk_header . ckID [ 2 ] , chunk_header . ckID [ 3 ] , chunk_header . ckSize ) ; if ( ! DoReadFile ( infile , buff , bytes_to_copy , & bcount ) || bcount != bytes_to_copy || ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , buff , bytes_to_copy ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; free ( buff ) ; return WAVPACK_SOFT_ERROR ; } free ( buff ) ; } } if ( ! WavpackSetConfiguration64 ( wpc , config , total_samples , NULL ) ) { error_line ( ""%s:<S2SV_blank>%s"" , infilename , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } return WAVPACK_NO_ERROR ; }","char * buff ; if ( bytes_to_copy < 0 || bytes_to_copy > 4194304 ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.WAV<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } buff"
35,"static inline int handle_dots ( struct nameidata * nd , int type ) { if ( type == LAST_DOTDOT ) { if ( nd -> flags & LOOKUP_RCU ) { return follow_dotdot_rcu ( nd ) ; } else <S2SV_StartBug> follow_dotdot ( nd ) ; <S2SV_EndBug> } return 0 ; }",; } else return
36,"int main ( int argc , char * * argv ) { int i , n_valid , do_write , do_scrub ; char * c , * dname , * name ; DIR * dir ; FILE * fp ; pdf_t * pdf ; pdf_flag_t flags ; if ( argc < 2 ) usage ( ) ; do_write = do_scrub = flags = 0 ; name = NULL ; for ( i = 1 ; i < argc ; i ++ ) { if ( strncmp ( argv [ i ] , ""-w"" , 2 ) == 0 ) do_write = 1 ; else if ( strncmp ( argv [ i ] , ""-i"" , 2 ) == 0 ) flags |= PDF_FLAG_DISP_CREATOR ; else if ( strncmp ( argv [ i ] , ""-q"" , 2 ) == 0 ) flags |= PDF_FLAG_QUIET ; else if ( strncmp ( argv [ i ] , ""-s"" , 2 ) == 0 ) do_scrub = 1 ; else if ( argv [ i ] [ 0 ] != '-' ) name = argv [ i ] ; else if ( argv [ i ] [ 0 ] == '-' ) usage ( ) ; } if ( ! name ) usage ( ) ; if ( ! ( fp = fopen ( name , ""r"" ) ) ) { ERR ( ""Could<S2SV_blank>not<S2SV_blank>open<S2SV_blank>file<S2SV_blank>\'%s\'\\n"" , argv [ 1 ] ) ; return - 1 ; } else if ( ! pdf_is_pdf ( fp ) ) { ERR ( ""\'%s\'<S2SV_blank>specified<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>PDF\\n"" , name ) ; fclose ( fp ) ; return - 1 ; } if ( ! ( pdf = init_pdf ( fp , name ) ) ) { fclose ( fp ) ; return - 1 ; } for ( i = 0 , n_valid = 0 ; i < pdf -> n_xrefs ; i ++ ) if ( pdf -> xrefs [ i ] . version ) ++ n_valid ; if ( n_valid < 2 ) { if ( ! ( flags & ( PDF_FLAG_QUIET | PDF_FLAG_DISP_CREATOR ) ) ) printf ( ""%s:<S2SV_blank>There<S2SV_blank>is<S2SV_blank>only<S2SV_blank>one<S2SV_blank>version<S2SV_blank>of<S2SV_blank>this<S2SV_blank>PDF\\n"" , pdf -> name ) ; if ( do_write ) { fclose ( fp ) ; pdf_delete ( pdf ) ; return 0 ; } } dname = NULL ; if ( do_write ) { if ( ( c = strrchr ( name , '/' ) ) ) name = c + 1 ; if ( ( c = strrchr ( name , '.' ) ) ) * c = '\\0' ; <S2SV_StartBug> dname = malloc ( strlen ( name ) + 16 ) ; <S2SV_EndBug> sprintf ( dname , ""%s-versions"" , name ) ; if ( ! ( dir = opendir ( dname ) ) ) mkdir ( dname , S_IRWXU ) ; else { ERR ( ""This<S2SV_blank>directory<S2SV_blank>already<S2SV_blank>exists,<S2SV_blank>PDF<S2SV_blank>version<S2SV_blank>extraction<S2SV_blank>will<S2SV_blank>"" ""not<S2SV_blank>occur.\\n"" ) ; fclose ( fp ) ; closedir ( dir ) ; free ( dname ) ; pdf_delete ( pdf ) ; return - 1 ; } for ( i = 0 ; i < pdf -> n_xrefs ; i ++ ) if ( pdf -> xrefs [ i ] . version ) write_version ( fp , name , dname , & pdf -> xrefs [ i ] ) ; } pdf_summarize ( fp , pdf , dname , flags ) ; if ( do_scrub ) scrub_document ( fp , pdf ) ; if ( flags & PDF_FLAG_DISP_CREATOR ) display_creator ( fp , pdf ) ; fclose ( fp ) ; free ( dname ) ; pdf_delete ( pdf ) ; return 0 ; }",; dname = safe_calloc <S2SV_ModEnd> ( strlen (
37,"static int32 makepol ( QPRS_STATE * state ) { int32 val = 0 , type ; int32 lenval = 0 ; char * strval = NULL ; int32 stack [ STACKDEPTH ] ; int32 lenstack = 0 ; uint16 flag = 0 ; <S2SV_StartBug> while ( ( type = gettoken_query ( state , & val , & lenval , & strval , & flag ) ) != END ) <S2SV_EndBug> { switch ( type ) { case VAL : pushval_asis ( state , VAL , strval , lenval , flag ) ; while ( lenstack && ( stack [ lenstack - 1 ] == ( int32 ) '&' || stack [ lenstack - 1 ] == ( int32 ) '!' ) ) { lenstack -- ; pushquery ( state , OPR , stack [ lenstack ] , 0 , 0 , 0 ) ; } break ; case OPR : if ( lenstack && val == ( int32 ) '|' ) pushquery ( state , OPR , val , 0 , 0 , 0 ) ; else { if ( lenstack == STACKDEPTH ) elog ( ERROR , ""stack<S2SV_blank>too<S2SV_blank>short"" ) ; stack [ lenstack ] = val ; lenstack ++ ; } break ; case OPEN : if ( makepol ( state ) == ERR ) return ERR ; while ( lenstack && ( stack [ lenstack - 1 ] == ( int32 ) '&' || stack [ lenstack - 1 ] == ( int32 ) '!' ) ) { lenstack -- ; pushquery ( state , OPR , stack [ lenstack ] , 0 , 0 , 0 ) ; } break ; case CLOSE : while ( lenstack ) { lenstack -- ; pushquery ( state , OPR , stack [ lenstack ] , 0 , 0 , 0 ) ; } ; return END ; break ; case ERR : default : ereport ( ERROR , ( errcode ( ERRCODE_SYNTAX_ERROR ) , errmsg ( ""syntax<S2SV_blank>error"" ) ) ) ; return ERR ; } } while ( lenstack ) { lenstack -- ; pushquery ( state , OPR , stack [ lenstack ] , 0 , 0 , 0 ) ; } ; return END ; }",= 0 ; check_stack_depth ( ) ;
38,"static int dn_create ( struct net * net , struct socket * sock , int protocol , int kern ) { <S2SV_StartBug> struct sock * sk ; <S2SV_EndBug> if ( ! net_eq ( net , & init_net ) ) return - EAFNOSUPPORT ; switch ( sock -> type ) { case SOCK_SEQPACKET : if ( protocol != DNPROTO_NSP ) return - EPROTONOSUPPORT ; break ; case SOCK_STREAM : break ; default : return - ESOCKTNOSUPPORT ; } if ( ( sk = dn_alloc_sock ( net , sock , GFP_KERNEL , kern ) ) == NULL ) return - ENOBUFS ; sk -> sk_protocol = protocol ; return 0 ; }",sock * sk ; if ( protocol < 0 || protocol > SK_PROTOCOL_MAX ) return - EINVAL
39,"<S2SV_StartBug> static void usage ( char * progname ) { <S2SV_EndBug> printf ( ""Usage:\\n"" ) ; printf ( ""%s<S2SV_blank><input_yuv><S2SV_blank><width>x<height><S2SV_blank><target_width>x<target_height><S2SV_blank>"" , <S2SV_StartBug> progname ) ; <S2SV_EndBug> printf ( ""<output_yuv><S2SV_blank>[<frames>]\\n"" ) ; }","void usage ( <S2SV_ModEnd> ) { printf <S2SV_ModStart> ( ""%s<S2SV_blank><input_yuv><S2SV_blank><width>x<height><S2SV_blank><target_width>x<target_height><S2SV_blank>"" , exec_name <S2SV_ModEnd> ) ; printf"
40,"NOEXPORT void transfer ( CLI * c ) { int timeout ; int pending ; # if OPENSSL_VERSION_NUMBER >= 0x10100000L int has_pending = 0 , prev_has_pending ; # endif <S2SV_StartBug> int watchdog = 0 ; <S2SV_EndBug> ssize_t num ; int err ; int sock_open_rd = 1 , sock_open_wr = 1 ; int shutdown_wants_read = 0 , shutdown_wants_write = 0 ; int read_wants_read = 0 , read_wants_write = 0 ; int write_wants_read = 0 , write_wants_write = 0 ; int sock_can_rd , sock_can_wr , ssl_can_rd , ssl_can_wr ; # ifdef USE_WIN32 unsigned long bytes ; # else int bytes ; # endif c -> sock_ptr = c -> ssl_ptr = 0 ; do { read_wants_read |= ! ( SSL_get_shutdown ( c -> ssl ) & SSL_RECEIVED_SHUTDOWN ) && c -> ssl_ptr < BUFFSIZE && ! read_wants_write ; write_wants_write |= ! ( SSL_get_shutdown ( c -> ssl ) & SSL_SENT_SHUTDOWN ) && c -> sock_ptr && ! write_wants_read ; s_poll_init ( c -> fds , 0 ) ; if ( sock_open_rd ) s_poll_add ( c -> fds , c -> sock_rfd -> fd , c -> sock_ptr < BUFFSIZE , 0 ) ; if ( sock_open_wr ) s_poll_add ( c -> fds , c -> sock_wfd -> fd , 0 , c -> ssl_ptr > 0 ) ; if ( SSL_get_shutdown ( c -> ssl ) != ( SSL_SENT_SHUTDOWN | SSL_RECEIVED_SHUTDOWN ) ) { s_poll_add ( c -> fds , c -> ssl_rfd -> fd , read_wants_read || write_wants_read || shutdown_wants_read , 0 ) ; s_poll_add ( c -> fds , c -> ssl_wfd -> fd , 0 , read_wants_write || write_wants_write || shutdown_wants_write ) ; } pending = SSL_pending ( c -> ssl ) ; # if OPENSSL_VERSION_NUMBER >= 0x10100000L prev_has_pending = has_pending ; has_pending = SSL_has_pending ( c -> ssl ) ; pending = pending || ( has_pending && ! prev_has_pending ) ; # endif if ( read_wants_read && pending ) { timeout = 0 ; } else if ( ( sock_open_rd && ! ( SSL_get_shutdown ( c -> ssl ) & SSL_RECEIVED_SHUTDOWN ) ) || c -> ssl_ptr || c -> sock_ptr ) { timeout = c -> opt -> timeout_idle ; } else { timeout = c -> opt -> timeout_close ; } err = s_poll_wait ( c -> fds , timeout , 0 ) ; switch ( err ) { case - 1 : sockerror ( ""transfer:<S2SV_blank>s_poll_wait"" ) ; throw_exception ( c , 1 ) ; case 0 : if ( read_wants_read && pending ) break ; if ( ( sock_open_rd && ! ( SSL_get_shutdown ( c -> ssl ) & SSL_RECEIVED_SHUTDOWN ) ) || c -> ssl_ptr || c -> sock_ptr ) { s_log ( LOG_INFO , ""transfer:<S2SV_blank>s_poll_wait:"" ""<S2SV_blank>TIMEOUTidle<S2SV_blank>exceeded:<S2SV_blank>sending<S2SV_blank>reset"" ) ; s_poll_dump ( c -> fds , LOG_DEBUG ) ; throw_exception ( c , 1 ) ; } s_log ( LOG_ERR , ""transfer:<S2SV_blank>s_poll_wait:"" ""<S2SV_blank>TIMEOUTclose<S2SV_blank>exceeded:<S2SV_blank>closing"" ) ; s_poll_dump ( c -> fds , LOG_DEBUG ) ; return ; } sock_can_rd = s_poll_canread ( c -> fds , c -> sock_rfd -> fd ) ; sock_can_wr = s_poll_canwrite ( c -> fds , c -> sock_wfd -> fd ) ; ssl_can_rd = s_poll_canread ( c -> fds , c -> ssl_rfd -> fd ) ; ssl_can_wr = s_poll_canwrite ( c -> fds , c -> ssl_wfd -> fd ) ; if ( c -> sock_rfd -> fd == c -> sock_wfd -> fd ) { if ( ( sock_can_rd || sock_can_wr ) && s_poll_err ( c -> fds , c -> sock_rfd -> fd ) ) { err = get_socket_error ( c -> sock_rfd -> fd ) ; if ( err ) log_error ( LOG_INFO , err , ""socket<S2SV_blank>fd"" ) ; } } else { if ( sock_can_rd && s_poll_err ( c -> fds , c -> sock_rfd -> fd ) ) { err = get_socket_error ( c -> sock_rfd -> fd ) ; if ( err ) log_error ( LOG_INFO , err , ""socket<S2SV_blank>rfd"" ) ; } if ( sock_can_wr && s_poll_err ( c -> fds , c -> sock_wfd -> fd ) ) { err = get_socket_error ( c -> sock_wfd -> fd ) ; if ( err ) log_error ( LOG_INFO , err , ""socket<S2SV_blank>wfd"" ) ; } } if ( c -> ssl_rfd -> fd == c -> ssl_wfd -> fd ) { if ( ( ssl_can_rd || ssl_can_wr ) && s_poll_err ( c -> fds , c -> ssl_rfd -> fd ) ) { err = get_socket_error ( c -> ssl_rfd -> fd ) ; if ( err ) log_error ( LOG_INFO , err , ""TLS<S2SV_blank>fd"" ) ; } } else { if ( ssl_can_rd && s_poll_err ( c -> fds , c -> ssl_rfd -> fd ) ) { err = get_socket_error ( c -> ssl_rfd -> fd ) ; if ( err ) log_error ( LOG_INFO , err , ""TLS<S2SV_blank>rfd"" ) ; } if ( c -> ssl_rfd -> fd != c -> ssl_wfd -> fd && ssl_can_wr && s_poll_err ( c -> fds , c -> ssl_wfd -> fd ) ) { err = get_socket_error ( c -> ssl_wfd -> fd ) ; if ( err ) log_error ( LOG_INFO , err , ""TLS<S2SV_blank>wfd"" ) ; } } if ( ! ( sock_can_rd || sock_can_wr || ssl_can_rd || ssl_can_wr ) ) { if ( s_poll_hup ( c -> fds , c -> sock_rfd -> fd ) || s_poll_hup ( c -> fds , c -> sock_wfd -> fd ) ) { if ( c -> ssl_ptr ) { s_log ( LOG_ERR , ""Socket<S2SV_blank>closed<S2SV_blank>(HUP)<S2SV_blank>with<S2SV_blank>%ld<S2SV_blank>unsent<S2SV_blank>byte(s)"" , ( long ) c -> ssl_ptr ) ; throw_exception ( c , 1 ) ; } s_log ( LOG_INFO , ""Socket<S2SV_blank>closed<S2SV_blank>(HUP)"" ) ; sock_open_rd = sock_open_wr = 0 ; } else if ( s_poll_hup ( c -> fds , c -> ssl_rfd -> fd ) || s_poll_hup ( c -> fds , c -> ssl_wfd -> fd ) ) { if ( c -> sock_ptr ) { s_log ( LOG_ERR , ""TLS<S2SV_blank>socket<S2SV_blank>closed<S2SV_blank>(HUP)<S2SV_blank>with<S2SV_blank>%ld<S2SV_blank>unsent<S2SV_blank>byte(s)"" , ( long ) c -> sock_ptr ) ; throw_exception ( c , 1 ) ; } s_log ( LOG_INFO , ""TLS<S2SV_blank>socket<S2SV_blank>closed<S2SV_blank>(HUP)"" ) ; SSL_set_shutdown ( c -> ssl , SSL_SENT_SHUTDOWN | SSL_RECEIVED_SHUTDOWN ) ; } } if ( c -> reneg_state == RENEG_DETECTED && ! c -> opt -> option . renegotiation ) { s_log ( LOG_ERR , ""Aborting<S2SV_blank>due<S2SV_blank>to<S2SV_blank>renegotiation<S2SV_blank>request"" ) ; throw_exception ( c , 1 ) ; } if ( shutdown_wants_read || shutdown_wants_write ) { <S2SV_StartBug> num = SSL_shutdown ( c -> ssl ) ; <S2SV_EndBug> if ( num < 0 ) <S2SV_StartBug> err = SSL_get_error ( c -> ssl , ( int ) num ) ; <S2SV_EndBug> else err = SSL_ERROR_NONE ; switch ( err ) { case SSL_ERROR_NONE : s_log ( LOG_INFO , ""SSL_shutdown<S2SV_blank>successfully<S2SV_blank>sent<S2SV_blank>close_notify<S2SV_blank>alert"" ) ; shutdown_wants_read = shutdown_wants_write = 0 ; break ; <S2SV_StartBug> case SSL_ERROR_SYSCALL : <S2SV_EndBug> if ( parse_socket_error ( c , ""SSL_shutdown"" ) ) break ; SSL_set_shutdown ( c -> ssl , SSL_SENT_SHUTDOWN | SSL_RECEIVED_SHUTDOWN ) ; shutdown_wants_read = shutdown_wants_write = 0 ; break ; <S2SV_StartBug> case SSL_ERROR_ZERO_RETURN : <S2SV_EndBug> SSL_set_shutdown ( c -> ssl , SSL_SENT_SHUTDOWN | SSL_RECEIVED_SHUTDOWN ) ; shutdown_wants_read = shutdown_wants_write = 0 ; break ; <S2SV_StartBug> case SSL_ERROR_WANT_WRITE : <S2SV_EndBug> s_log ( LOG_DEBUG , ""SSL_shutdown<S2SV_blank>returned<S2SV_blank>WANT_WRITE:<S2SV_blank>retrying"" ) ; shutdown_wants_read = 0 ; shutdown_wants_write = 1 ; break ; case SSL_ERROR_WANT_READ : s_log ( LOG_DEBUG , ""SSL_shutdown<S2SV_blank>returned<S2SV_blank>WANT_READ:<S2SV_blank>retrying"" ) ; shutdown_wants_read = 1 ; shutdown_wants_write = 0 ; break ; case SSL_ERROR_SSL : sslerror ( ""SSL_shutdown"" ) ; throw_exception ( c , 1 ) ; default : s_log ( LOG_ERR , ""SSL_shutdown/SSL_get_error<S2SV_blank>returned<S2SV_blank>%d"" , err ) ; throw_exception ( c , 1 ) ; } } if ( sock_open_wr && sock_can_wr ) { <S2SV_StartBug> num = writesocket ( c -> sock_wfd -> fd , c -> ssl_buff , c -> ssl_ptr ) ; <S2SV_EndBug> switch ( num ) { case - 1 : if ( parse_socket_error ( c , ""writesocket"" ) ) break ; sock_open_rd = sock_open_wr = 0 ; break ; case 0 : s_log ( LOG_DEBUG , ""writesocket<S2SV_blank>returned<S2SV_blank>0"" ) ; break ; default : memmove ( c -> ssl_buff , c -> ssl_buff + num , c -> ssl_ptr - ( size_t ) num ) ; c -> ssl_ptr -= ( size_t ) num ; memset ( c -> ssl_buff + c -> ssl_ptr , 0 , ( size_t ) num ) ; c -> sock_bytes += ( size_t ) num ; watchdog = 0 ; } } if ( sock_open_rd && sock_can_rd ) { <S2SV_StartBug> num = readsocket ( c -> sock_rfd -> fd , <S2SV_EndBug> c -> sock_buff + c -> sock_ptr , BUFFSIZE - c -> sock_ptr ) ; switch ( num ) { case - 1 : if ( parse_socket_error ( c , ""readsocket"" ) ) break ; sock_open_rd = sock_open_wr = 0 ; break ; case 0 : s_log ( LOG_INFO , ""Read<S2SV_blank>socket<S2SV_blank>closed<S2SV_blank>(readsocket)"" ) ; sock_open_rd = 0 ; break ; default : c -> sock_ptr += ( size_t ) num ; watchdog = 0 ; } } read_wants_read |= ! ( SSL_get_shutdown ( c -> ssl ) & SSL_RECEIVED_SHUTDOWN ) && c -> ssl_ptr < BUFFSIZE && ! read_wants_write ; write_wants_write |= ! ( SSL_get_shutdown ( c -> ssl ) & SSL_SENT_SHUTDOWN ) && c -> sock_ptr && ! write_wants_read ; if ( ( write_wants_read && ssl_can_rd ) || ( write_wants_write && ssl_can_wr ) ) { <S2SV_StartBug> write_wants_read = 0 ; <S2SV_EndBug> write_wants_write = 0 ; <S2SV_StartBug> num = SSL_write ( c -> ssl , c -> sock_buff , ( int ) ( c -> sock_ptr ) ) ; <S2SV_EndBug> <S2SV_StartBug> switch ( err = SSL_get_error ( c -> ssl , ( int ) num ) ) { <S2SV_EndBug> case SSL_ERROR_NONE : if ( num == 0 ) { s_log ( LOG_DEBUG , ""SSL_write<S2SV_blank>returned<S2SV_blank>0"" ) ; break ; } memmove ( c -> sock_buff , c -> sock_buff + num , c -> sock_ptr - ( size_t ) num ) ; c -> sock_ptr -= ( size_t ) num ; memset ( c -> sock_buff + c -> sock_ptr , 0 , ( size_t ) num ) ; c -> ssl_bytes += ( size_t ) num ; watchdog = 0 ; break ; case SSL_ERROR_WANT_WRITE : s_log ( LOG_DEBUG , ""SSL_write<S2SV_blank>returned<S2SV_blank>WANT_WRITE:<S2SV_blank>retrying"" ) ; write_wants_write = 1 ; break ; case SSL_ERROR_WANT_READ : s_log ( LOG_DEBUG , ""SSL_write<S2SV_blank>returned<S2SV_blank>WANT_READ:<S2SV_blank>retrying"" ) ; write_wants_read = 1 ; break ; case SSL_ERROR_WANT_X509_LOOKUP : s_log ( LOG_DEBUG , ""SSL_write<S2SV_blank>returned<S2SV_blank>WANT_X509_LOOKUP:<S2SV_blank>retrying"" ) ; break ; <S2SV_StartBug> case SSL_ERROR_SYSCALL : <S2SV_EndBug> <S2SV_StartBug> if ( num && parse_socket_error ( c , ""SSL_write"" ) ) <S2SV_EndBug> break ; if ( c -> sock_ptr ) { s_log ( LOG_ERR , ""TLS<S2SV_blank>socket<S2SV_blank>closed<S2SV_blank>(SSL_write)<S2SV_blank>with<S2SV_blank>%ld<S2SV_blank>unsent<S2SV_blank>byte(s)"" , ( long ) c -> sock_ptr ) ; throw_exception ( c , 1 ) ; } s_log ( LOG_INFO , ""TLS<S2SV_blank>socket<S2SV_blank>closed<S2SV_blank>(SSL_write)"" ) ; SSL_set_shutdown ( c -> ssl , SSL_SENT_SHUTDOWN | SSL_RECEIVED_SHUTDOWN ) ; break ; <S2SV_StartBug> case SSL_ERROR_ZERO_RETURN : <S2SV_EndBug> <S2SV_StartBug> s_log ( LOG_INFO , ""TLS<S2SV_blank>closed<S2SV_blank>(SSL_write)"" ) ; <S2SV_EndBug> if ( SSL_version ( c -> ssl ) == SSL2_VERSION ) SSL_set_shutdown ( c -> ssl , SSL_SENT_SHUTDOWN | SSL_RECEIVED_SHUTDOWN ) ; break ; <S2SV_StartBug> case SSL_ERROR_SSL : <S2SV_EndBug> sslerror ( ""SSL_write"" ) ; throw_exception ( c , 1 ) ; default : s_log ( LOG_ERR , ""SSL_write/SSL_get_error<S2SV_blank>returned<S2SV_blank>%d"" , err ) ; throw_exception ( c , 1 ) ; } } if ( ( read_wants_read && ( ssl_can_rd || pending ) ) || ( read_wants_write && ssl_can_wr ) ) { read_wants_read = 0 ; read_wants_write = 0 ; num = SSL_read ( c -> ssl , c -> ssl_buff + c -> ssl_ptr , ( int ) ( BUFFSIZE - c -> ssl_ptr ) ) ; switch ( err = SSL_get_error ( c -> ssl , ( int ) num ) ) { case SSL_ERROR_NONE : if ( num == 0 ) { s_log ( LOG_DEBUG , ""SSL_read<S2SV_blank>returned<S2SV_blank>0"" ) ; break ; } c -> ssl_ptr += ( size_t ) num ; watchdog = 0 ; break ; case SSL_ERROR_WANT_WRITE : s_log ( LOG_DEBUG , ""SSL_read<S2SV_blank>returned<S2SV_blank>WANT_WRITE:<S2SV_blank>retrying"" ) ; read_wants_write = 1 ; break ; case SSL_ERROR_WANT_READ : # if 0 s_log ( LOG_DEBUG , ""SSL_read<S2SV_blank>returned<S2SV_blank>WANT_READ:<S2SV_blank>retrying"" ) ; # endif read_wants_read = 1 ; break ; case SSL_ERROR_WANT_X509_LOOKUP : s_log ( LOG_DEBUG , ""SSL_read<S2SV_blank>returned<S2SV_blank>WANT_X509_LOOKUP:<S2SV_blank>retrying"" ) ; break ; case SSL_ERROR_SYSCALL : if ( num && parse_socket_error ( c , ""SSL_read"" ) ) break ; if ( c -> sock_ptr || write_wants_write ) { s_log ( LOG_ERR , ""TLS<S2SV_blank>socket<S2SV_blank>closed<S2SV_blank>(SSL_read)<S2SV_blank>with<S2SV_blank>%ld<S2SV_blank>unsent<S2SV_blank>byte(s)"" , ( long ) c -> sock_ptr ) ; throw_exception ( c , 1 ) ; } s_log ( LOG_INFO , ""TLS<S2SV_blank>socket<S2SV_blank>closed<S2SV_blank>(SSL_read)"" ) ; SSL_set_shutdown ( c -> ssl , SSL_SENT_SHUTDOWN | SSL_RECEIVED_SHUTDOWN ) ; <S2SV_StartBug> break ; <S2SV_EndBug> case SSL_ERROR_ZERO_RETURN : s_log ( LOG_INFO , ""TLS<S2SV_blank>closed<S2SV_blank>(SSL_read)"" ) ; if ( SSL_version ( c -> ssl ) == SSL2_VERSION ) SSL_set_shutdown ( c -> ssl , SSL_SENT_SHUTDOWN | SSL_RECEIVED_SHUTDOWN ) ; break ; case SSL_ERROR_SSL : sslerror ( ""SSL_read"" ) ; throw_exception ( c , 1 ) ; default : s_log ( LOG_ERR , ""SSL_read/SSL_get_error<S2SV_blank>returned<S2SV_blank>%d"" , err ) ; throw_exception ( c , 1 ) ; } } if ( sock_open_rd && s_poll_rdhup ( c -> fds , c -> sock_rfd -> fd ) && ( ioctlsocket ( c -> sock_rfd -> fd , FIONREAD , & bytes ) || ! bytes ) ) { s_log ( LOG_INFO , ""Read<S2SV_blank>socket<S2SV_blank>closed<S2SV_blank>(read<S2SV_blank>hangup)"" ) ; sock_open_rd = 0 ; } if ( sock_open_wr && s_poll_hup ( c -> fds , c -> sock_wfd -> fd ) ) { if ( c -> ssl_ptr ) { s_log ( LOG_ERR , ""Write<S2SV_blank>socket<S2SV_blank>closed<S2SV_blank>(write<S2SV_blank>hangup)<S2SV_blank>with<S2SV_blank>%ld<S2SV_blank>unsent<S2SV_blank>byte(s)"" , ( long ) c -> ssl_ptr ) ; throw_exception ( c , 1 ) ; } s_log ( LOG_INFO , ""Write<S2SV_blank>socket<S2SV_blank>closed<S2SV_blank>(write<S2SV_blank>hangup)"" ) ; sock_open_wr = 0 ; } if ( ! ( SSL_get_shutdown ( c -> ssl ) & SSL_RECEIVED_SHUTDOWN ) && s_poll_rdhup ( c -> fds , c -> ssl_rfd -> fd ) && ( ioctlsocket ( c -> ssl_rfd -> fd , FIONREAD , & bytes ) || ! bytes ) ) { s_log ( LOG_INFO , ""TLS<S2SV_blank>socket<S2SV_blank>closed<S2SV_blank>(read<S2SV_blank>hangup)"" ) ; SSL_set_shutdown ( c -> ssl , SSL_get_shutdown ( c -> ssl ) | SSL_RECEIVED_SHUTDOWN ) ; } if ( ! ( SSL_get_shutdown ( c -> ssl ) & SSL_SENT_SHUTDOWN ) && s_poll_hup ( c -> fds , c -> ssl_wfd -> fd ) ) { if ( c -> sock_ptr || write_wants_write ) { s_log ( LOG_ERR , ""TLS<S2SV_blank>socket<S2SV_blank>closed<S2SV_blank>(write<S2SV_blank>hangup)<S2SV_blank>with<S2SV_blank>%ld<S2SV_blank>unsent<S2SV_blank>byte(s)"" , ( long ) c -> sock_ptr ) ; throw_exception ( c , 1 ) ; } s_log ( LOG_INFO , ""TLS<S2SV_blank>socket<S2SV_blank>closed<S2SV_blank>(write<S2SV_blank>hangup)"" ) ; SSL_set_shutdown ( c -> ssl , SSL_get_shutdown ( c -> ssl ) | SSL_SENT_SHUTDOWN ) ; } if ( sock_open_wr && SSL_get_shutdown ( c -> ssl ) & SSL_RECEIVED_SHUTDOWN && ! c -> ssl_ptr ) { sock_open_wr = 0 ; if ( ! c -> sock_wfd -> is_socket ) { s_log ( LOG_DEBUG , ""Closing<S2SV_blank>the<S2SV_blank>file<S2SV_blank>descriptor"" ) ; sock_open_rd = 0 ; } else if ( ! shutdown ( c -> sock_wfd -> fd , SHUT_WR ) ) { s_log ( LOG_DEBUG , ""Sent<S2SV_blank>socket<S2SV_blank>write<S2SV_blank>shutdown"" ) ; } else { s_log ( LOG_DEBUG , ""Failed<S2SV_blank>to<S2SV_blank>send<S2SV_blank>socket<S2SV_blank>write<S2SV_blank>shutdown"" ) ; sock_open_rd = 0 ; } } if ( ! ( SSL_get_shutdown ( c -> ssl ) & SSL_SENT_SHUTDOWN ) && ! sock_open_rd && ! c -> sock_ptr && ! write_wants_write ) { if ( SSL_version ( c -> ssl ) != SSL2_VERSION ) { s_log ( LOG_DEBUG , ""Sending<S2SV_blank>close_notify<S2SV_blank>alert"" ) ; shutdown_wants_write = 1 ; } else { s_log ( LOG_DEBUG , ""Closing<S2SV_blank>SSLv2<S2SV_blank>socket"" ) ; if ( c -> ssl_rfd -> is_socket ) shutdown ( c -> ssl_rfd -> fd , SHUT_RD ) ; if ( c -> ssl_wfd -> is_socket ) shutdown ( c -> ssl_wfd -> fd , SHUT_WR ) ; SSL_set_shutdown ( c -> ssl , SSL_SENT_SHUTDOWN | SSL_RECEIVED_SHUTDOWN ) ; } } if ( ++ watchdog > 100 ) { s_log ( LOG_ERR , ""transfer()<S2SV_blank>loop<S2SV_blank>executes<S2SV_blank>not<S2SV_blank>transferring<S2SV_blank>any<S2SV_blank>data"" ) ; s_log ( LOG_ERR , ""please<S2SV_blank>report<S2SV_blank>the<S2SV_blank>problem<S2SV_blank>to<S2SV_blank>Michal.Trojnara@stunnel.org"" ) ; stunnel_info ( LOG_ERR ) ; # if OPENSSL_VERSION_NUMBER >= 0x10100000L s_log ( LOG_ERR , ""protocol=%s,<S2SV_blank>SSL_pending=%d,<S2SV_blank>SSL_has_pending=%d"" , SSL_get_version ( c -> ssl ) , SSL_pending ( c -> ssl ) , SSL_has_pending ( c -> ssl ) ) ; # else s_log ( LOG_ERR , ""protocol=%s,<S2SV_blank>SSL_pending=%d"" , SSL_get_version ( c -> ssl ) , SSL_pending ( c -> ssl ) ) ; # endif s_log ( LOG_ERR , ""sock_open_rd=%s,<S2SV_blank>sock_open_wr=%s"" , sock_open_rd ? ""Y"" : ""n"" , sock_open_wr ? ""Y"" : ""n"" ) ; s_log ( LOG_ERR , ""SSL_RECEIVED_SHUTDOWN=%s,<S2SV_blank>SSL_SENT_SHUTDOWN=%s"" , ( SSL_get_shutdown ( c -> ssl ) & SSL_RECEIVED_SHUTDOWN ) ? ""Y"" : ""n"" , ( SSL_get_shutdown ( c -> ssl ) & SSL_SENT_SHUTDOWN ) ? ""Y"" : ""n"" ) ; s_log ( LOG_ERR , ""sock_can_rd=%s,<S2SV_blank>sock_can_wr=%s"" , sock_can_rd ? ""Y"" : ""n"" , sock_can_wr ? ""Y"" : ""n"" ) ; s_log ( LOG_ERR , ""ssl_can_rd=%s,<S2SV_blank>ssl_can_wr=%s"" , ssl_can_rd ? ""Y"" : ""n"" , ssl_can_wr ? ""Y"" : ""n"" ) ; s_log ( LOG_ERR , ""read_wants_read=%s,<S2SV_blank>read_wants_write=%s"" , read_wants_read ? ""Y"" : ""n"" , read_wants_write ? ""Y"" : ""n"" ) ; s_log ( LOG_ERR , ""write_wants_read=%s,<S2SV_blank>write_wants_write=%s"" , write_wants_read ? ""Y"" : ""n"" , write_wants_write ? ""Y"" : ""n"" ) ; s_log ( LOG_ERR , ""shutdown_wants_read=%s,<S2SV_blank>shutdown_wants_write=%s"" , shutdown_wants_read ? ""Y"" : ""n"" , shutdown_wants_write ? ""Y"" : ""n"" ) ; s_log ( LOG_ERR , ""socket<S2SV_blank>input<S2SV_blank>buffer:<S2SV_blank>%ld<S2SV_blank>byte(s),<S2SV_blank>"" ""TLS<S2SV_blank>input<S2SV_blank>buffer:<S2SV_blank>%ld<S2SV_blank>byte(s)"" , ( long ) c -> sock_ptr , ( long ) c -> ssl_ptr ) ; throw_exception ( c , 1 ) ; } } while ( sock_open_wr || ! ( SSL_get_shutdown ( c -> ssl ) & SSL_SENT_SHUTDOWN ) || shutdown_wants_read || shutdown_wants_write ) ; }","watchdog = 0 <S2SV_ModEnd> ; int err <S2SV_ModStart> shutdown_wants_write ) { int <S2SV_ModStart> -> ssl , <S2SV_ModEnd> num ) ; <S2SV_ModStart> break ; case SSL_ERROR_WANT_WRITE : s_log ( LOG_DEBUG , ""SSL_shutdown<S2SV_blank>returned<S2SV_blank>WANT_WRITE:<S2SV_blank>retrying"" ) ; shutdown_wants_read = 0 ; shutdown_wants_write = 1 ; break ; case SSL_ERROR_WANT_READ : s_log ( LOG_DEBUG , ""SSL_shutdown<S2SV_blank>returned<S2SV_blank>WANT_READ:<S2SV_blank>retrying"" ) ; shutdown_wants_read = 1 ; shutdown_wants_write = 0 ; break ; case SSL_ERROR_SSL : sslerror ( ""SSL_shutdown"" ) ; throw_exception ( c , 1 ) ; case SSL_ERROR_ZERO_RETURN : <S2SV_ModEnd> SSL_set_shutdown ( c <S2SV_ModStart> break ; case SSL_ERROR_SYSCALL : if ( parse_socket_error ( c , ""SSL_shutdown"" ) ) break ; <S2SV_ModEnd> SSL_set_shutdown ( c <S2SV_ModStart> ; break ; default : s_log ( LOG_ERR , ""SSL_shutdown/SSL_get_error<S2SV_blank>returned<S2SV_blank>%d"" , err ) ; throw_exception ( c , 1 <S2SV_ModEnd> ) ; } <S2SV_ModStart> sock_can_wr ) { ssize_t <S2SV_ModStart> sock_can_rd ) { ssize_t <S2SV_ModStart> ) ) { int num = SSL_write ( c -> ssl , c -> sock_buff , ( int ) ( c -> sock_ptr ) ) ; <S2SV_ModStart> = 0 ; <S2SV_ModEnd> switch ( err <S2SV_ModStart> -> ssl , <S2SV_ModEnd> num ) ) <S2SV_ModStart> break ; case SSL_ERROR_SSL : sslerror ( ""SSL_write"" ) ; throw_exception ( c , 1 ) ; case SSL_ERROR_ZERO_RETURN : case <S2SV_ModStart> : if ( parse_socket_error ( c , ""SSL_write"" ) && num <S2SV_ModEnd> ) break ; <S2SV_ModStart> ; break ; default : s_log ( LOG_ERR , ""SSL_write/SSL_get_error<S2SV_blank>returned<S2SV_blank>%d"" , err ) ; throw_exception ( c , 1 ) ; } } if ( ( read_wants_read && ( ssl_can_rd || pending ) ) || ( read_wants_write && ssl_can_wr ) ) { int num = SSL_read ( c -> ssl , c -> ssl_buff + c -> ssl_ptr , ( int ) ( BUFFSIZE - c -> ssl_ptr ) ) ; read_wants_read = 0 ; read_wants_write = 0 ; switch ( err = SSL_get_error ( c -> ssl , num ) ) { case SSL_ERROR_NONE : if ( num == 0 ) { s_log ( LOG_DEBUG , ""SSL_read<S2SV_blank>returned<S2SV_blank>0"" ) ; break ; } c -> ssl_ptr += ( size_t ) num ; watchdog = 0 ; break ; case SSL_ERROR_WANT_WRITE : s_log ( LOG_DEBUG , ""SSL_read<S2SV_blank>returned<S2SV_blank>WANT_WRITE:<S2SV_blank>retrying"" ) ; read_wants_write = 1 ; break ; case SSL_ERROR_WANT_READ : # if 0 s_log ( LOG_DEBUG , ""SSL_read<S2SV_blank>returned<S2SV_blank>WANT_READ:<S2SV_blank>retrying"" ) ; # endif read_wants_read = 1 ; break ; case SSL_ERROR_WANT_X509_LOOKUP : s_log ( LOG_DEBUG , ""SSL_read<S2SV_blank>returned<S2SV_blank>WANT_X509_LOOKUP:<S2SV_blank>retrying"" ) ; break ; case SSL_ERROR_SSL : sslerror ( ""SSL_read"" ) ; throw_exception ( c , 1 ) ; <S2SV_ModStart> ( LOG_INFO , ""TLS<S2SV_blank>closed<S2SV_blank>(SSL_read)"" <S2SV_ModEnd> ) ; if <S2SV_ModStart> break ; case SSL_ERROR_SYSCALL : if ( parse_socket_error ( c , ""SSL_read"" ) && num <S2SV_ModEnd> ) break ; <S2SV_ModStart> ) ; break <S2SV_ModEnd> ; default :"
41,"static int mlx5_fw_fatal_reporter_dump ( struct devlink_health_reporter * reporter , struct devlink_fmsg * fmsg , void * priv_ctx ) { struct mlx5_core_dev * dev = devlink_health_reporter_priv ( reporter ) ; u32 crdump_size = dev -> priv . health . crdump_size ; u32 * cr_data ; u32 data_size ; u32 offset ; int err ; if ( ! mlx5_core_is_pf ( dev ) ) return - EPERM ; cr_data = kvmalloc ( crdump_size , GFP_KERNEL ) ; if ( ! cr_data ) return - ENOMEM ; err = mlx5_crdump_collect ( dev , cr_data ) ; if ( err ) <S2SV_StartBug> return err ; <S2SV_EndBug> if ( priv_ctx ) { struct mlx5_fw_reporter_ctx * fw_reporter_ctx = priv_ctx ; err = mlx5_fw_reporter_ctx_pairs_put ( fmsg , fw_reporter_ctx ) ; if ( err ) goto free_data ; } err = devlink_fmsg_arr_pair_nest_start ( fmsg , ""crdump_data"" ) ; if ( err ) goto free_data ; for ( offset = 0 ; offset < crdump_size ; offset += data_size ) { if ( crdump_size - offset < MLX5_CR_DUMP_CHUNK_SIZE ) data_size = crdump_size - offset ; else data_size = MLX5_CR_DUMP_CHUNK_SIZE ; err = devlink_fmsg_binary_put ( fmsg , ( char * ) cr_data + offset , data_size ) ; if ( err ) goto free_data ; } err = devlink_fmsg_arr_pair_nest_end ( fmsg ) ; free_data : kvfree ( cr_data ) ; return err ; }",( err ) goto free_data <S2SV_ModEnd> ; if (
42,"static Browser_Window * window_create ( const char * url ) { Browser_Window * app_data = malloc ( sizeof ( Browser_Window ) ) ; if ( ! app_data ) { info ( ""ERROR:<S2SV_blank>could<S2SV_blank>not<S2SV_blank>create<S2SV_blank>browser<S2SV_blank>window.\\n"" ) ; return NULL ; } app_data -> window = elm_win_add ( NULL , ""minibrowser-window"" , ELM_WIN_BASIC ) ; elm_win_title_set ( app_data -> window , APP_NAME ) ; evas_object_smart_callback_add ( app_data -> window , ""delete,request"" , on_window_deletion , & app_data ) ; Evas_Object * bg = elm_bg_add ( app_data -> window ) ; elm_bg_color_set ( bg , 193 , 192 , 191 ) ; evas_object_size_hint_weight_set ( bg , EVAS_HINT_EXPAND , EVAS_HINT_EXPAND ) ; elm_win_resize_object_add ( app_data -> window , bg ) ; evas_object_show ( bg ) ; Evas_Object * vertical_layout = elm_box_add ( app_data -> window ) ; elm_box_padding_set ( vertical_layout , 0 , 2 ) ; evas_object_size_hint_weight_set ( vertical_layout , EVAS_HINT_EXPAND , EVAS_HINT_EXPAND ) ; elm_win_resize_object_add ( app_data -> window , vertical_layout ) ; evas_object_show ( vertical_layout ) ; Evas_Object * horizontal_layout = elm_box_add ( app_data -> window ) ; elm_box_horizontal_set ( horizontal_layout , EINA_TRUE ) ; evas_object_size_hint_weight_set ( horizontal_layout , EVAS_HINT_EXPAND , 0.0 ) ; evas_object_size_hint_align_set ( horizontal_layout , EVAS_HINT_FILL , 0.0 ) ; elm_box_pack_end ( vertical_layout , horizontal_layout ) ; evas_object_show ( horizontal_layout ) ; app_data -> back_button = create_toolbar_button ( app_data -> window , ""arrow_left"" ) ; evas_object_smart_callback_add ( app_data -> back_button , ""clicked"" , on_back_button_clicked , app_data ) ; elm_object_disabled_set ( app_data -> back_button , EINA_TRUE ) ; evas_object_size_hint_weight_set ( app_data -> back_button , 0.0 , EVAS_HINT_EXPAND ) ; evas_object_size_hint_align_set ( app_data -> back_button , 0.0 , 0.5 ) ; elm_box_pack_end ( horizontal_layout , app_data -> back_button ) ; evas_object_show ( app_data -> back_button ) ; app_data -> forward_button = create_toolbar_button ( app_data -> window , ""arrow_right"" ) ; evas_object_smart_callback_add ( app_data -> forward_button , ""clicked"" , on_forward_button_clicked , app_data ) ; elm_object_disabled_set ( app_data -> forward_button , EINA_TRUE ) ; evas_object_size_hint_weight_set ( app_data -> forward_button , 0.0 , EVAS_HINT_EXPAND ) ; evas_object_size_hint_align_set ( app_data -> forward_button , 0.0 , 0.5 ) ; elm_box_pack_end ( horizontal_layout , app_data -> forward_button ) ; evas_object_show ( app_data -> forward_button ) ; app_data -> url_bar = elm_entry_add ( app_data -> window ) ; elm_entry_scrollable_set ( app_data -> url_bar , EINA_TRUE ) ; elm_entry_scrollbar_policy_set ( app_data -> url_bar , ELM_SCROLLER_POLICY_OFF , ELM_SCROLLER_POLICY_OFF ) ; elm_entry_single_line_set ( app_data -> url_bar , EINA_TRUE ) ; elm_entry_cnp_mode_set ( app_data -> url_bar , ELM_CNP_MODE_PLAINTEXT ) ; elm_entry_text_style_user_push ( app_data -> url_bar , ""DEFAULT=\'font_size=18\'"" ) ; evas_object_smart_callback_add ( app_data -> url_bar , ""activated"" , on_url_bar_activated , app_data ) ; evas_object_smart_callback_add ( app_data -> url_bar , ""clicked"" , on_url_bar_clicked , app_data ) ; evas_object_size_hint_weight_set ( app_data -> url_bar , EVAS_HINT_EXPAND , EVAS_HINT_EXPAND ) ; evas_object_size_hint_align_set ( app_data -> url_bar , EVAS_HINT_FILL , EVAS_HINT_FILL ) ; elm_box_pack_end ( horizontal_layout , app_data -> url_bar ) ; evas_object_show ( app_data -> url_bar ) ; Evas_Object * refresh_button = create_toolbar_button ( app_data -> window , ""refresh"" ) ; evas_object_smart_callback_add ( refresh_button , ""clicked"" , on_refresh_button_clicked , app_data ) ; evas_object_size_hint_weight_set ( refresh_button , 0.0 , EVAS_HINT_EXPAND ) ; evas_object_size_hint_align_set ( refresh_button , 1.0 , 0.5 ) ; elm_box_pack_end ( horizontal_layout , refresh_button ) ; evas_object_show ( refresh_button ) ; Evas_Object * home_button = create_toolbar_button ( app_data -> window , ""home"" ) ; evas_object_smart_callback_add ( home_button , ""clicked"" , on_home_button_clicked , app_data ) ; evas_object_size_hint_weight_set ( home_button , 0.0 , EVAS_HINT_EXPAND ) ; evas_object_size_hint_align_set ( home_button , 1.0 , 0.5 ) ; elm_box_pack_end ( horizontal_layout , home_button ) ; evas_object_show ( home_button ) ; Ewk_View_Smart_Class * ewkViewClass = miniBrowserViewSmartClass ( ) ; ewkViewClass -> run_javascript_alert = on_javascript_alert ; ewkViewClass -> run_javascript_confirm = on_javascript_confirm ; ewkViewClass -> run_javascript_prompt = on_javascript_prompt ; Evas * evas = evas_object_evas_get ( app_data -> window ) ; Evas_Smart * smart = evas_smart_class_new ( & ewkViewClass -> sc ) ; app_data -> webview = ewk_view_smart_add ( evas , smart , ewk_context_default_get ( ) ) ; ewk_view_theme_set ( app_data -> webview , THEME_DIR ""/default.edj"" ) ; Ewk_Settings * settings = ewk_view_settings_get ( app_data -> webview ) ; ewk_settings_file_access_from_file_urls_allowed_set ( settings , EINA_TRUE ) ; ewk_settings_frame_flattening_enabled_set ( settings , frame_flattening_enabled ) ; ewk_settings_developer_extras_enabled_set ( settings , EINA_TRUE ) ; evas_object_smart_callback_add ( app_data -> webview , ""authentication,request"" , on_authentication_request , app_data ) ; evas_object_smart_callback_add ( app_data -> webview , ""close,window"" , on_close_window , app_data ) ; evas_object_smart_callback_add ( app_data -> webview , ""create,window"" , on_new_window , app_data ) ; evas_object_smart_callback_add ( app_data -> webview , ""download,failed"" , on_download_failed , app_data ) ; evas_object_smart_callback_add ( app_data -> webview , ""download,finished"" , on_download_finished , app_data ) ; evas_object_smart_callback_add ( app_data -> webview , ""download,request"" , on_download_request , app_data ) ; evas_object_smart_callback_add ( app_data -> webview , ""file,chooser,request"" , on_file_chooser_request , app_data ) ; evas_object_smart_callback_add ( app_data -> webview , ""icon,changed"" , on_view_icon_changed , app_data ) ; evas_object_smart_callback_add ( app_data -> webview , ""load,error"" , on_error , app_data ) ; evas_object_smart_callback_add ( app_data -> webview , ""load,progress"" , on_progress , app_data ) ; evas_object_smart_callback_add ( app_data -> webview , ""title,changed"" , on_title_changed , app_data ) ; evas_object_smart_callback_add ( app_data -> webview , ""url,changed"" , on_url_changed , app_data ) ; evas_object_smart_callback_add ( app_data -> webview , ""back,forward,list,changed"" , on_back_forward_list_changed , app_data ) ; evas_object_smart_callback_add ( app_data -> webview , ""tooltip,text,set"" , on_tooltip_text_set , app_data ) ; evas_object_smart_callback_add ( app_data -> webview , ""tooltip,text,unset"" , on_tooltip_text_unset , app_data ) ; evas_object_event_callback_add ( app_data -> webview , EVAS_CALLBACK_KEY_DOWN , on_key_down , app_data ) ; evas_object_event_callback_add ( app_data -> webview , EVAS_CALLBACK_MOUSE_DOWN , on_mouse_down , app_data ) ; evas_object_size_hint_weight_set ( app_data -> webview , EVAS_HINT_EXPAND , EVAS_HINT_EXPAND ) ; evas_object_size_hint_align_set ( app_data -> webview , EVAS_HINT_FILL , EVAS_HINT_FILL ) ; elm_box_pack_end ( vertical_layout , app_data -> webview ) ; evas_object_show ( app_data -> webview ) ; if ( url ) ewk_view_url_set ( app_data -> webview , url ) ; <S2SV_StartBug> evas_object_resize ( app_data -> window , DEFAULT_WIDTH , DEFAULT_HEIGHT ) ; <S2SV_EndBug> evas_object_show ( app_data -> window ) ; view_focus_set ( app_data , EINA_TRUE ) ; return app_data ; }","-> window , window_width , window_height <S2SV_ModEnd> ) ; evas_object_show"
43,"static int futex_requeue ( u32 __user * uaddr1 , unsigned int flags , u32 __user * uaddr2 , int nr_wake , int nr_requeue , u32 * cmpval , int requeue_pi ) { union futex_key key1 = FUTEX_KEY_INIT , key2 = FUTEX_KEY_INIT ; int drop_count = 0 , task_count = 0 , ret ; struct futex_pi_state * pi_state = NULL ; struct futex_hash_bucket * hb1 , * hb2 ; struct futex_q * this , * next ; if ( requeue_pi ) { <S2SV_StartBug> if ( refill_pi_state_cache ( ) ) <S2SV_EndBug> return - ENOMEM ; if ( nr_wake != 1 ) return - EINVAL ; } retry : if ( pi_state != NULL ) { free_pi_state ( pi_state ) ; pi_state = NULL ; } ret = get_futex_key ( uaddr1 , flags & FLAGS_SHARED , & key1 , VERIFY_READ ) ; if ( unlikely ( ret != 0 ) ) goto out ; ret = get_futex_key ( uaddr2 , flags & FLAGS_SHARED , & key2 , requeue_pi ? VERIFY_WRITE : VERIFY_READ ) ; if ( unlikely ( ret != 0 ) ) <S2SV_StartBug> goto out_put_key1 ; <S2SV_EndBug> hb1 = hash_futex ( & key1 ) ; hb2 = hash_futex ( & key2 ) ; retry_private : hb_waiters_inc ( hb2 ) ; double_lock_hb ( hb1 , hb2 ) ; if ( likely ( cmpval != NULL ) ) { u32 curval ; ret = get_futex_value_locked ( & curval , uaddr1 ) ; if ( unlikely ( ret ) ) { double_unlock_hb ( hb1 , hb2 ) ; hb_waiters_dec ( hb2 ) ; ret = get_user ( curval , uaddr1 ) ; if ( ret ) goto out_put_keys ; if ( ! ( flags & FLAGS_SHARED ) ) goto retry_private ; put_futex_key ( & key2 ) ; put_futex_key ( & key1 ) ; goto retry ; } if ( curval != * cmpval ) { ret = - EAGAIN ; goto out_unlock ; } } if ( requeue_pi && ( task_count - nr_wake < nr_requeue ) ) { ret = futex_proxy_trylock_atomic ( uaddr2 , hb1 , hb2 , & key1 , & key2 , & pi_state , nr_requeue ) ; if ( ret > 0 ) { WARN_ON ( pi_state ) ; drop_count ++ ; task_count ++ ; ret = lookup_pi_state ( ret , hb2 , & key2 , & pi_state , NULL ) ; } switch ( ret ) { case 0 : break ; case - EFAULT : double_unlock_hb ( hb1 , hb2 ) ; hb_waiters_dec ( hb2 ) ; put_futex_key ( & key2 ) ; put_futex_key ( & key1 ) ; ret = fault_in_user_writeable ( uaddr2 ) ; if ( ! ret ) goto retry ; goto out ; case - EAGAIN : double_unlock_hb ( hb1 , hb2 ) ; hb_waiters_dec ( hb2 ) ; put_futex_key ( & key2 ) ; put_futex_key ( & key1 ) ; cond_resched ( ) ; goto retry ; default : goto out_unlock ; } } plist_for_each_entry_safe ( this , next , & hb1 -> chain , list ) { if ( task_count - nr_wake >= nr_requeue ) break ; if ( ! match_futex ( & this -> key , & key1 ) ) continue ; if ( ( requeue_pi && ! this -> rt_waiter ) || ( ! requeue_pi && this -> rt_waiter ) || this -> pi_state ) { ret = - EINVAL ; break ; } if ( ++ task_count <= nr_wake && ! requeue_pi ) { wake_futex ( this ) ; continue ; } if ( requeue_pi && ! match_futex ( this -> requeue_pi_key , & key2 ) ) { ret = - EINVAL ; break ; } if ( requeue_pi ) { atomic_inc ( & pi_state -> refcount ) ; this -> pi_state = pi_state ; ret = rt_mutex_start_proxy_lock ( & pi_state -> pi_mutex , this -> rt_waiter , this -> task , 1 ) ; if ( ret == 1 ) { requeue_pi_wake_futex ( this , & key2 , hb2 ) ; drop_count ++ ; continue ; } else if ( ret ) { this -> pi_state = NULL ; free_pi_state ( pi_state ) ; goto out_unlock ; } } requeue_futex ( this , hb1 , hb2 , & key2 ) ; drop_count ++ ; } out_unlock : double_unlock_hb ( hb1 , hb2 ) ; hb_waiters_dec ( hb2 ) ; while ( -- drop_count >= 0 ) drop_futex_key_refs ( & key1 ) ; out_put_keys : put_futex_key ( & key2 ) ; out_put_key1 : put_futex_key ( & key1 ) ; out : if ( pi_state != NULL ) free_pi_state ( pi_state ) ; return ret ? ret : task_count ; }","{ if ( uaddr1 == uaddr2 ) return - EINVAL ; if ( <S2SV_ModStart> goto out_put_key1 ; if ( requeue_pi && match_futex ( & key1 , & key2 ) ) { ret = - EINVAL ; goto out_put_keys ; }"
44,"struct sctp_chunk * sctp_process_asconf ( struct sctp_association * asoc , struct sctp_chunk * asconf ) { <S2SV_StartBug> sctp_addiphdr_t * hdr ; <S2SV_EndBug> union sctp_addr_param * addr_param ; sctp_addip_param_t * asconf_param ; struct sctp_chunk * asconf_ack ; __be16 err_code ; int length = 0 ; int chunk_len ; __u32 serial ; <S2SV_StartBug> int all_param_pass = 1 ; <S2SV_EndBug> chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ; hdr = ( sctp_addiphdr_t * ) asconf -> skb -> data ; serial = ntohl ( hdr -> serial ) ; length = sizeof ( sctp_addiphdr_t ) ; addr_param = ( union sctp_addr_param * ) ( asconf -> skb -> data + length ) ; chunk_len -= length ; length = ntohs ( addr_param -> p . length ) ; asconf_param = ( void * ) addr_param + length ; chunk_len -= length ; asconf_ack = sctp_make_asconf_ack ( asoc , serial , chunk_len * 4 ) ; if ( ! asconf_ack ) goto done ; <S2SV_StartBug> while ( chunk_len > 0 ) { <S2SV_EndBug> err_code = sctp_process_asconf_param ( asoc , asconf , <S2SV_StartBug> asconf_param ) ; <S2SV_EndBug> if ( SCTP_ERROR_NO_ERROR != err_code ) <S2SV_StartBug> all_param_pass = 0 ; <S2SV_EndBug> if ( ! all_param_pass ) sctp_add_asconf_response ( asconf_ack , <S2SV_StartBug> asconf_param -> crr_id , err_code , <S2SV_EndBug> asconf_param ) ; if ( SCTP_ERROR_RSRC_LOW == err_code ) goto done ; <S2SV_StartBug> length = ntohs ( asconf_param -> param_hdr . length ) ; <S2SV_EndBug> asconf_param = ( void * ) asconf_param + length ; chunk_len -= length ; } done : asoc -> peer . addip_serial ++ ; if ( asconf_ack ) { sctp_chunk_hold ( asconf_ack ) ; list_add_tail ( & asconf_ack -> transmitted_list , & asoc -> asconf_ack_list ) ; } return asconf_ack ; }","asconf ) { sctp_addip_chunk_t * addip = ( sctp_addip_chunk_t * ) asconf -> chunk_hdr ; bool all_param_pass = true ; union sctp_params param ; <S2SV_ModStart> __u32 serial ; <S2SV_ModEnd> chunk_len = ntohs <S2SV_ModStart> goto done ; sctp_walk_params ( param , addip , addip_hdr . params ) { if ( param . p -> type == SCTP_PARAM_IPV4_ADDRESS || param . p -> type == SCTP_PARAM_IPV6_ADDRESS ) continue ; <S2SV_ModEnd> err_code = sctp_process_asconf_param <S2SV_ModStart> , asconf , param . addip ) ; if ( err_code != SCTP_ERROR_NO_ERROR <S2SV_ModEnd> ) all_param_pass = <S2SV_ModStart> ) all_param_pass = false <S2SV_ModEnd> ; if ( <S2SV_ModStart> ( asconf_ack , param . addip <S2SV_ModEnd> -> crr_id , <S2SV_ModStart> -> crr_id , err_code , param . addip ) ; if ( err_code == SCTP_ERROR_RSRC_LOW <S2SV_ModEnd> ) goto done <S2SV_ModStart> goto done ; <S2SV_ModEnd> } done :"
45,"int main ( int argc , char * argv [ ] ) { static char buff [ 16384 ] ; struct cpio _cpio ; struct cpio * cpio ; const char * errmsg ; int uid , gid ; int opt ; cpio = & _cpio ; memset ( cpio , 0 , sizeof ( * cpio ) ) ; cpio -> buff = buff ; cpio -> buff_size = sizeof ( buff ) ; # if defined ( HAVE_SIGACTION ) && defined ( SIGPIPE ) { struct sigaction sa ; sigemptyset ( & sa . sa_mask ) ; sa . sa_flags = 0 ; sa . sa_handler = SIG_IGN ; sigaction ( SIGPIPE , & sa , NULL ) ; } # endif lafe_setprogname ( * argv , ""bsdcpio"" ) ; # if HAVE_SETLOCALE if ( setlocale ( LC_ALL , """" ) == NULL ) lafe_warnc ( 0 , ""Failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>default<S2SV_blank>locale"" ) ; # endif cpio -> uid_override = - 1 ; cpio -> gid_override = - 1 ; cpio -> argv = argv ; cpio -> argc = argc ; cpio -> mode = '\\0' ; cpio -> verbose = 0 ; cpio -> compress = '\\0' ; cpio -> extract_flags = ARCHIVE_EXTRACT_NO_AUTODIR ; cpio -> extract_flags |= ARCHIVE_EXTRACT_NO_OVERWRITE_NEWER ; cpio -> extract_flags |= ARCHIVE_EXTRACT_SECURE_SYMLINKS ; cpio -> extract_flags |= ARCHIVE_EXTRACT_SECURE_NODOTDOT ; <S2SV_StartBug> cpio -> extract_flags |= ARCHIVE_EXTRACT_PERM ; <S2SV_EndBug> cpio -> extract_flags |= ARCHIVE_EXTRACT_FFLAGS ; cpio -> extract_flags |= ARCHIVE_EXTRACT_ACL ; # if ! defined ( _WIN32 ) && ! defined ( __CYGWIN__ ) if ( geteuid ( ) == 0 ) cpio -> extract_flags |= ARCHIVE_EXTRACT_OWNER ; # endif cpio -> bytes_per_block = 512 ; cpio -> filename = NULL ; cpio -> matching = archive_match_new ( ) ; if ( cpio -> matching == NULL ) lafe_errc ( 1 , 0 , ""Out<S2SV_blank>of<S2SV_blank>memory"" ) ; while ( ( opt = cpio_getopt ( cpio ) ) != - 1 ) { switch ( opt ) { case '0' : cpio -> option_null = 1 ; break ; case 'A' : cpio -> option_append = 1 ; break ; case 'a' : cpio -> option_atime_restore = 1 ; break ; case 'B' : cpio -> bytes_per_block = 5120 ; break ; case OPTION_B64ENCODE : cpio -> add_filter = opt ; break ; case 'C' : cpio -> bytes_per_block = atoi ( cpio -> argument ) ; if ( cpio -> bytes_per_block <= 0 ) lafe_errc ( 1 , 0 , ""Invalid<S2SV_blank>blocksize<S2SV_blank>%s"" , cpio -> argument ) ; break ; case 'c' : cpio -> format = ""odc"" ; break ; case 'd' : cpio -> extract_flags &= ~ ARCHIVE_EXTRACT_NO_AUTODIR ; break ; case 'E' : if ( archive_match_include_pattern_from_file ( cpio -> matching , cpio -> argument , cpio -> option_null ) != ARCHIVE_OK ) lafe_errc ( 1 , 0 , ""Error<S2SV_blank>:<S2SV_blank>%s"" , archive_error_string ( cpio -> matching ) ) ; break ; case 'F' : cpio -> filename = cpio -> argument ; break ; case 'f' : if ( archive_match_exclude_pattern ( cpio -> matching , cpio -> argument ) != ARCHIVE_OK ) lafe_errc ( 1 , 0 , ""Error<S2SV_blank>:<S2SV_blank>%s"" , archive_error_string ( cpio -> matching ) ) ; break ; case OPTION_GRZIP : cpio -> compress = opt ; break ; case 'H' : cpio -> format = cpio -> argument ; break ; case 'h' : long_help ( ) ; break ; case 'I' : cpio -> filename = cpio -> argument ; break ; case 'i' : if ( cpio -> mode != '\\0' ) lafe_errc ( 1 , 0 , ""Cannot<S2SV_blank>use<S2SV_blank>both<S2SV_blank>-i<S2SV_blank>and<S2SV_blank>-%c"" , cpio -> mode ) ; cpio -> mode = opt ; break ; case 'J' : cpio -> compress = opt ; break ; case 'j' : cpio -> compress = opt ; break ; case OPTION_INSECURE : cpio -> extract_flags &= ~ ARCHIVE_EXTRACT_SECURE_SYMLINKS ; <S2SV_StartBug> cpio -> extract_flags &= ~ ARCHIVE_EXTRACT_SECURE_NODOTDOT ; <S2SV_EndBug> break ; case 'L' : cpio -> option_follow_links = 1 ; break ; case 'l' : cpio -> option_link = 1 ; break ; case OPTION_LRZIP : case OPTION_LZ4 : case OPTION_LZMA : case OPTION_LZOP : cpio -> compress = opt ; break ; case 'm' : cpio -> extract_flags |= ARCHIVE_EXTRACT_TIME ; break ; case 'n' : cpio -> option_numeric_uid_gid = 1 ; break ; case OPTION_NO_PRESERVE_OWNER : cpio -> extract_flags &= ~ ARCHIVE_EXTRACT_OWNER ; break ; case 'O' : cpio -> filename = cpio -> argument ; break ; case 'o' : if ( cpio -> mode != '\\0' ) lafe_errc ( 1 , 0 , ""Cannot<S2SV_blank>use<S2SV_blank>both<S2SV_blank>-o<S2SV_blank>and<S2SV_blank>-%c"" , cpio -> mode ) ; cpio -> mode = opt ; break ; case 'p' : if ( cpio -> mode != '\\0' ) lafe_errc ( 1 , 0 , ""Cannot<S2SV_blank>use<S2SV_blank>both<S2SV_blank>-p<S2SV_blank>and<S2SV_blank>-%c"" , cpio -> mode ) ; cpio -> mode = opt ; cpio -> extract_flags &= ~ ARCHIVE_EXTRACT_SECURE_NODOTDOT ; break ; case OPTION_PASSPHRASE : cpio -> passphrase = cpio -> argument ; break ; case OPTION_PRESERVE_OWNER : cpio -> extract_flags |= ARCHIVE_EXTRACT_OWNER ; break ; case OPTION_QUIET : cpio -> quiet = 1 ; break ; case 'R' : errmsg = owner_parse ( cpio -> argument , & uid , & gid ) ; if ( errmsg ) { lafe_warnc ( - 1 , ""%s"" , errmsg ) ; usage ( ) ; } if ( uid != - 1 ) { cpio -> uid_override = uid ; cpio -> uname_override = NULL ; } if ( gid != - 1 ) { cpio -> gid_override = gid ; cpio -> gname_override = NULL ; } break ; case 'r' : cpio -> option_rename = 1 ; break ; case 't' : cpio -> option_list = 1 ; break ; case 'u' : cpio -> extract_flags &= ~ ARCHIVE_EXTRACT_NO_OVERWRITE_NEWER ; break ; case OPTION_UUENCODE : cpio -> add_filter = opt ; break ; case 'v' : cpio -> verbose ++ ; break ; case 'V' : cpio -> dot ++ ; break ; case OPTION_VERSION : version ( ) ; break ; # if 0 case 'W' : break ; # endif case 'y' : cpio -> compress = opt ; break ; case 'Z' : cpio -> compress = opt ; break ; case 'z' : cpio -> compress = opt ; break ; default : usage ( ) ; } } if ( cpio -> option_list && cpio -> mode == '\\0' ) cpio -> mode = 'i' ; if ( cpio -> option_list && cpio -> mode != 'i' ) lafe_errc ( 1 , 0 , ""Option<S2SV_blank>-t<S2SV_blank>requires<S2SV_blank>-i"" ) ; if ( cpio -> option_numeric_uid_gid && ! cpio -> option_list ) lafe_errc ( 1 , 0 , ""Option<S2SV_blank>-n<S2SV_blank>requires<S2SV_blank>-it"" ) ; if ( cpio -> format != NULL && cpio -> mode != 'o' ) lafe_errc ( 1 , 0 , ""Option<S2SV_blank>--format<S2SV_blank>requires<S2SV_blank>-o"" ) ; if ( cpio -> option_link && cpio -> mode != 'p' ) lafe_errc ( 1 , 0 , ""Option<S2SV_blank>-l<S2SV_blank>requires<S2SV_blank>-p"" ) ; if ( cpio -> dot && cpio -> verbose ) cpio -> dot = 0 ; switch ( cpio -> mode ) { case 'o' : if ( cpio -> format == NULL ) cpio -> format = ""odc"" ; mode_out ( cpio ) ; break ; case 'i' : while ( * cpio -> argv != NULL ) { if ( archive_match_include_pattern ( cpio -> matching , * cpio -> argv ) != ARCHIVE_OK ) lafe_errc ( 1 , 0 , ""Error<S2SV_blank>:<S2SV_blank>%s"" , archive_error_string ( cpio -> matching ) ) ; -- cpio -> argc ; ++ cpio -> argv ; } if ( cpio -> option_list ) mode_list ( cpio ) ; else mode_in ( cpio ) ; break ; case 'p' : if ( * cpio -> argv == NULL || * * cpio -> argv == '\\0' ) lafe_errc ( 1 , 0 , ""-p<S2SV_blank>mode<S2SV_blank>requires<S2SV_blank>a<S2SV_blank>target<S2SV_blank>directory"" ) ; mode_pass ( cpio , * cpio -> argv ) ; break ; default : lafe_errc ( 1 , 0 , ""Must<S2SV_blank>specify<S2SV_blank>at<S2SV_blank>least<S2SV_blank>one<S2SV_blank>of<S2SV_blank>-i,<S2SV_blank>-o,<S2SV_blank>or<S2SV_blank>-p"" ) ; } archive_match_free ( cpio -> matching ) ; free_cache ( cpio -> gname_cache ) ; free_cache ( cpio -> uname_cache ) ; free ( cpio -> destdir ) ; passphrase_free ( cpio -> ppbuff ) ; return ( cpio -> return_value ) ; }",-> extract_flags |= ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS ; cpio -> extract_flags |= <S2SV_ModStart> &= ~ ARCHIVE_EXTRACT_SECURE_NODOTDOT ; cpio -> extract_flags &= ~ ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS
46,"static int tok_get ( struct tok_state * tok , char * * p_start , char * * p_end ) { int c ; int blankline , nonascii ; * p_start = * p_end = NULL ; nextline : tok -> start = NULL ; blankline = 0 ; if ( tok -> atbol ) { int col = 0 ; int altcol = 0 ; tok -> atbol = 0 ; for ( ; ; ) { c = tok_nextc ( tok ) ; if ( c == '<S2SV_blank>' ) { col ++ , altcol ++ ; } else if ( c == '\\t' ) { col = ( col / tok -> tabsize + 1 ) * tok -> tabsize ; altcol = ( altcol / ALTTABSIZE + 1 ) * ALTTABSIZE ; } else if ( c == '\\014' ) { col = altcol = 0 ; } else { break ; } } tok_backup ( tok , c ) ; if ( c == '#' || c == '\\n' ) { if ( col == 0 && c == '\\n' && tok -> prompt != NULL ) { blankline = 0 ; } else { blankline = 1 ; } } if ( ! blankline && tok -> level == 0 ) { if ( col == tok -> indstack [ tok -> indent ] ) { if ( altcol != tok -> altindstack [ tok -> indent ] ) { return indenterror ( tok ) ; } } else if ( col > tok -> indstack [ tok -> indent ] ) { if ( tok -> indent + 1 >= MAXINDENT ) { tok -> done = E_TOODEEP ; tok -> cur = tok -> inp ; return ERRORTOKEN ; } if ( altcol <= tok -> altindstack [ tok -> indent ] ) { return indenterror ( tok ) ; } tok -> pendin ++ ; tok -> indstack [ ++ tok -> indent ] = col ; tok -> altindstack [ tok -> indent ] = altcol ; } else { while ( tok -> indent > 0 && col < tok -> indstack [ tok -> indent ] ) { tok -> pendin -- ; tok -> indent -- ; } if ( col != tok -> indstack [ tok -> indent ] ) { tok -> done = E_DEDENT ; tok -> cur = tok -> inp ; return ERRORTOKEN ; } if ( altcol != tok -> altindstack [ tok -> indent ] ) { return indenterror ( tok ) ; } } } } tok -> start = tok -> cur ; if ( tok -> pendin != 0 ) { if ( tok -> pendin < 0 ) { tok -> pendin ++ ; return DEDENT ; } else { tok -> pendin -- ; return INDENT ; } } again : tok -> start = NULL ; do { c = tok_nextc ( tok ) ; } while ( c == '<S2SV_blank>' || c == '\\t' || c == '\\014' ) ; tok -> start = tok -> cur - 1 ; if ( c == '#' ) { <S2SV_StartBug> while ( c != EOF && c != '\\n' ) { <S2SV_EndBug> <S2SV_StartBug> c = tok_nextc ( tok ) ; <S2SV_EndBug> } } if ( c == EOF ) { return tok -> done == E_EOF ? ENDMARKER : ERRORTOKEN ; } nonascii = 0 ; if ( is_potential_identifier_start ( c ) ) { int saw_b = 0 , saw_r = 0 , saw_u = 0 , saw_f = 0 ; while ( 1 ) { if ( ! ( saw_b || saw_u || saw_f ) && ( c == 'b' || c == 'B' ) ) saw_b = 1 ; else if ( ! ( saw_b || saw_u || saw_r || saw_f ) && ( c == 'u' || c == 'U' ) ) { saw_u = 1 ; } else if ( ! ( saw_r || saw_u ) && ( c == 'r' || c == 'R' ) ) { saw_r = 1 ; } else if ( ! ( saw_f || saw_b || saw_u ) && ( c == 'f' || c == 'F' ) ) { saw_f = 1 ; } else { break ; } c = tok_nextc ( tok ) ; if ( c == \'""\' || c == '\\'' ) { goto letter_quote ; } } while ( is_potential_identifier_char ( c ) ) { if ( c >= 128 ) { nonascii = 1 ; } c = tok_nextc ( tok ) ; } tok_backup ( tok , c ) ; if ( nonascii && ! verify_identifier ( tok ) ) { return ERRORTOKEN ; } * p_start = tok -> start ; * p_end = tok -> cur ; return NAME ; } if ( c == '\\n' ) { tok -> atbol = 1 ; if ( blankline || tok -> level > 0 ) { goto nextline ; } * p_start = tok -> start ; * p_end = tok -> cur - 1 ; tok -> cont_line = 0 ; return NEWLINE ; } if ( c == '.' ) { c = tok_nextc ( tok ) ; if ( isdigit ( c ) ) { goto fraction ; } else if ( c == '.' ) { c = tok_nextc ( tok ) ; if ( c == '.' ) { * p_start = tok -> start ; * p_end = tok -> cur ; return ELLIPSIS ; } else { tok_backup ( tok , c ) ; } tok_backup ( tok , '.' ) ; } else { tok_backup ( tok , c ) ; } * p_start = tok -> start ; * p_end = tok -> cur ; return DOT ; } if ( isdigit ( c ) ) { if ( c == '0' ) { c = tok_nextc ( tok ) ; if ( c == 'x' || c == 'X' ) { c = tok_nextc ( tok ) ; do { if ( c == '_' ) { c = tok_nextc ( tok ) ; } if ( ! isxdigit ( c ) ) { tok_backup ( tok , c ) ; return syntaxerror ( tok , ""invalid<S2SV_blank>hexadecimal<S2SV_blank>literal"" ) ; } do { c = tok_nextc ( tok ) ; } while ( isxdigit ( c ) ) ; } while ( c == '_' ) ; } else if ( c == 'o' || c == 'O' ) { c = tok_nextc ( tok ) ; do { if ( c == '_' ) { c = tok_nextc ( tok ) ; } if ( c < '0' || c >= '8' ) { tok_backup ( tok , c ) ; if ( isdigit ( c ) ) { return syntaxerror ( tok , ""invalid<S2SV_blank>digit<S2SV_blank>\'%c\'<S2SV_blank>in<S2SV_blank>octal<S2SV_blank>literal"" , c ) ; } else { return syntaxerror ( tok , ""invalid<S2SV_blank>octal<S2SV_blank>literal"" ) ; } } do { c = tok_nextc ( tok ) ; } while ( '0' <= c && c < '8' ) ; } while ( c == '_' ) ; if ( isdigit ( c ) ) { return syntaxerror ( tok , ""invalid<S2SV_blank>digit<S2SV_blank>\'%c\'<S2SV_blank>in<S2SV_blank>octal<S2SV_blank>literal"" , c ) ; } } else if ( c == 'b' || c == 'B' ) { c = tok_nextc ( tok ) ; do { if ( c == '_' ) { c = tok_nextc ( tok ) ; } if ( c != '0' && c != '1' ) { tok_backup ( tok , c ) ; if ( isdigit ( c ) ) { return syntaxerror ( tok , ""invalid<S2SV_blank>digit<S2SV_blank>\'%c\'<S2SV_blank>in<S2SV_blank>binary<S2SV_blank>literal"" , c ) ; } else { return syntaxerror ( tok , ""invalid<S2SV_blank>binary<S2SV_blank>literal"" ) ; } } do { c = tok_nextc ( tok ) ; } while ( c == '0' || c == '1' ) ; } while ( c == '_' ) ; if ( isdigit ( c ) ) { return syntaxerror ( tok , ""invalid<S2SV_blank>digit<S2SV_blank>\'%c\'<S2SV_blank>in<S2SV_blank>binary<S2SV_blank>literal"" , c ) ; } } else { int nonzero = 0 ; while ( 1 ) { if ( c == '_' ) { c = tok_nextc ( tok ) ; if ( ! isdigit ( c ) ) { tok_backup ( tok , c ) ; return syntaxerror ( tok , ""invalid<S2SV_blank>decimal<S2SV_blank>literal"" ) ; } } if ( c != '0' ) { break ; } c = tok_nextc ( tok ) ; } if ( isdigit ( c ) ) { nonzero = 1 ; c = tok_decimal_tail ( tok ) ; if ( c == 0 ) { return ERRORTOKEN ; } } if ( c == '.' ) { c = tok_nextc ( tok ) ; goto fraction ; } else if ( c == 'e' || c == 'E' ) { goto exponent ; } else if ( c == 'j' || c == 'J' ) { goto imaginary ; } else if ( nonzero ) { tok_backup ( tok , c ) ; return syntaxerror ( tok , ""leading<S2SV_blank>zeros<S2SV_blank>in<S2SV_blank>decimal<S2SV_blank>integer<S2SV_blank>"" ""literals<S2SV_blank>are<S2SV_blank>not<S2SV_blank>permitted;<S2SV_blank>"" ""use<S2SV_blank>an<S2SV_blank>0o<S2SV_blank>prefix<S2SV_blank>for<S2SV_blank>octal<S2SV_blank>integers"" ) ; } } } else { c = tok_decimal_tail ( tok ) ; if ( c == 0 ) { return ERRORTOKEN ; } { if ( c == '.' ) { c = tok_nextc ( tok ) ; fraction : if ( isdigit ( c ) ) { c = tok_decimal_tail ( tok ) ; if ( c == 0 ) { return ERRORTOKEN ; } } } if ( c == 'e' || c == 'E' ) { int e ; exponent : e = c ; c = tok_nextc ( tok ) ; if ( c == '+' || c == '-' ) { c = tok_nextc ( tok ) ; if ( ! isdigit ( c ) ) { tok_backup ( tok , c ) ; return syntaxerror ( tok , ""invalid<S2SV_blank>decimal<S2SV_blank>literal"" ) ; } } else if ( ! isdigit ( c ) ) { tok_backup ( tok , c ) ; tok_backup ( tok , e ) ; * p_start = tok -> start ; * p_end = tok -> cur ; return NUMBER ; } c = tok_decimal_tail ( tok ) ; if ( c == 0 ) { return ERRORTOKEN ; } } if ( c == 'j' || c == 'J' ) { imaginary : c = tok_nextc ( tok ) ; } } } tok_backup ( tok , c ) ; * p_start = tok -> start ; * p_end = tok -> cur ; return NUMBER ; } letter_quote : if ( c == '\\'' || c == \'""\' ) { int quote = c ; int quote_size = 1 ; int end_quote_size = 0 ; tok -> first_lineno = tok -> lineno ; tok -> multi_line_start = tok -> line_start ; c = tok_nextc ( tok ) ; if ( c == quote ) { c = tok_nextc ( tok ) ; if ( c == quote ) { quote_size = 3 ; } else { end_quote_size = 1 ; } } if ( c != quote ) { tok_backup ( tok , c ) ; } while ( end_quote_size != quote_size ) { c = tok_nextc ( tok ) ; if ( c == EOF ) { if ( quote_size == 3 ) { tok -> done = E_EOFS ; } else { tok -> done = E_EOLS ; } tok -> cur = tok -> inp ; return ERRORTOKEN ; } if ( quote_size == 1 && c == '\\n' ) { tok -> done = E_EOLS ; tok -> cur = tok -> inp ; return ERRORTOKEN ; } if ( c == quote ) { end_quote_size += 1 ; } else { end_quote_size = 0 ; if ( c == '\\\\' ) { tok_nextc ( tok ) ; } } } * p_start = tok -> start ; * p_end = tok -> cur ; return STRING ; } if ( c == '\\\\' ) { c = tok_nextc ( tok ) ; if ( c != '\\n' ) { tok -> done = E_LINECONT ; tok -> cur = tok -> inp ; return ERRORTOKEN ; } tok -> cont_line = 1 ; goto again ; } { int c2 = tok_nextc ( tok ) ; int token = PyToken_TwoChars ( c , c2 ) ; if ( token != OP ) { int c3 = tok_nextc ( tok ) ; int token3 = PyToken_ThreeChars ( c , c2 , c3 ) ; if ( token3 != OP ) { token = token3 ; } else { tok_backup ( tok , c3 ) ; } * p_start = tok -> start ; * p_end = tok -> cur ; return token ; } tok_backup ( tok , c2 ) ; } switch ( c ) { case '(' : case '[' : case '{' : # ifndef PGEN if ( tok -> level >= MAXLEVEL ) { return syntaxerror ( tok , ""too<S2SV_blank>many<S2SV_blank>nested<S2SV_blank>parentheses"" ) ; } tok -> parenstack [ tok -> level ] = c ; tok -> parenlinenostack [ tok -> level ] = tok -> lineno ; # endif tok -> level ++ ; break ; case ')' : case ']' : case '}' : # ifndef PGEN if ( ! tok -> level ) { return syntaxerror ( tok , ""unmatched<S2SV_blank>\'%c\'"" , c ) ; } # endif tok -> level -- ; # ifndef PGEN int opening = tok -> parenstack [ tok -> level ] ; if ( ! ( ( opening == '(' && c == ')' ) || ( opening == '[' && c == ']' ) || ( opening == '{' && c == '}' ) ) ) { if ( tok -> parenlinenostack [ tok -> level ] != tok -> lineno ) { return syntaxerror ( tok , ""closing<S2SV_blank>parenthesis<S2SV_blank>\'%c\'<S2SV_blank>does<S2SV_blank>not<S2SV_blank>match<S2SV_blank>"" ""opening<S2SV_blank>parenthesis<S2SV_blank>\'%c\'<S2SV_blank>on<S2SV_blank>line<S2SV_blank>%d"" , c , opening , tok -> parenlinenostack [ tok -> level ] ) ; } else { return syntaxerror ( tok , ""closing<S2SV_blank>parenthesis<S2SV_blank>\'%c\'<S2SV_blank>does<S2SV_blank>not<S2SV_blank>match<S2SV_blank>"" ""opening<S2SV_blank>parenthesis<S2SV_blank>\'%c\'"" , c , opening ) ; } } # endif break ; } * p_start = tok -> start ; * p_end = tok -> cur ; return PyToken_OneChar ( c ) ; }","'#' ) { const char * prefix , * p , * type_start ; <S2SV_ModStart> tok ) ; } if ( tok -> type_comments ) { p = tok -> start ; prefix = type_comment_prefix ; while ( * prefix && p < tok -> cur ) { if ( * prefix == '<S2SV_blank>' ) { while ( * p == '<S2SV_blank>' || * p == '\\t' ) { p ++ ; } } else if ( * prefix == * p ) { p ++ ; } else { break ; } prefix ++ ; } if ( ! * prefix ) { int is_type_ignore = 1 ; tok_backup ( tok , c ) ; type_start = p ; is_type_ignore = tok -> cur >= p + 6 && memcmp ( p , ""ignore"" , 6 ) == 0 ; p += 6 ; while ( is_type_ignore && p < tok -> cur ) { if ( * p == '#' ) break ; is_type_ignore = is_type_ignore && ( * p == '<S2SV_blank>' || * p == '\\t' ) ; p ++ ; } if ( is_type_ignore ) { if ( blankline ) { tok_nextc ( tok ) ; tok -> atbol = 1 ; } return TYPE_IGNORE ; } else { * p_start = ( char * ) type_start ; * p_end = tok -> cur ; return TYPE_COMMENT ; } }"
47,void vp9_restore_layer_context ( VP9_COMP * const cpi ) { <S2SV_StartBug> LAYER_CONTEXT * const lc = get_layer_context ( & cpi -> svc ) ; <S2SV_EndBug> const int old_frame_since_key = cpi -> rc . frames_since_key ; const int old_frame_to_key = cpi -> rc . frames_to_key ; cpi -> rc = lc -> rc ; cpi -> twopass = lc -> twopass ; cpi -> oxcf . target_bandwidth = lc -> target_bandwidth ; <S2SV_StartBug> cpi -> oxcf . starting_buffer_level = lc -> starting_buffer_level ; <S2SV_EndBug> cpi -> oxcf . optimal_buffer_level = lc -> optimal_buffer_level ; cpi -> oxcf . maximum_buffer_size = lc -> maximum_buffer_size ; cpi -> output_framerate = lc -> framerate ; if ( cpi -> svc . number_temporal_layers > 1 ) { cpi -> rc . frames_since_key = old_frame_since_key ; cpi -> rc . frames_to_key = old_frame_to_key ; } },= get_layer_context ( cpi <S2SV_ModEnd> ) ; const <S2SV_ModStart> ; cpi -> alt_ref_source <S2SV_ModEnd> = lc -> <S2SV_ModStart> = lc -> alt_ref_source <S2SV_ModEnd> ; if (
48,"void ksz8851EventHandler ( NetInterface * interface ) { uint16_t status ; uint_t frameCount ; <S2SV_StartBug> status = ksz8851ReadReg ( interface , KSZ8851_REG_ISR ) ; <S2SV_EndBug> if ( ( status & ISR_LCIS ) != 0 ) { <S2SV_StartBug> ksz8851WriteReg ( interface , KSZ8851_REG_ISR , ISR_LCIS ) ; <S2SV_EndBug> <S2SV_StartBug> status = ksz8851ReadReg ( interface , KSZ8851_REG_P1SR ) ; <S2SV_EndBug> if ( ( status & P1SR_LINK_GOOD ) != 0 ) { if ( ( status & P1SR_OPERATION_SPEED ) != 0 ) { interface -> linkSpeed = NIC_LINK_SPEED_100MBPS ; } else { interface -> linkSpeed = NIC_LINK_SPEED_10MBPS ; } <S2SV_StartBug> if ( ( status & P1SR_OPERATION_DUPLEX ) != 0 ) <S2SV_EndBug> { interface -> duplexMode = NIC_FULL_DUPLEX_MODE ; } else { interface -> duplexMode = NIC_HALF_DUPLEX_MODE ; } interface -> linkState = TRUE ; } else { interface -> linkState = FALSE ; } nicNotifyLinkChange ( interface ) ; } <S2SV_StartBug> if ( ( status & ISR_RXIS ) != 0 ) <S2SV_EndBug> { <S2SV_StartBug> ksz8851WriteReg ( interface , KSZ8851_REG_ISR , ISR_RXIS ) ; <S2SV_EndBug> <S2SV_StartBug> frameCount = MSB ( ksz8851ReadReg ( interface , KSZ8851_REG_RXFCTR ) ) ; <S2SV_EndBug> while ( frameCount > 0 ) { ksz8851ReceivePacket ( interface ) ; frameCount -- ; } } <S2SV_StartBug> ksz8851SetBit ( interface , KSZ8851_REG_IER , IER_LCIE | IER_RXIE ) ; <S2SV_EndBug> }","( interface , KSZ8851_ISR ) ; if ( ( status & KSZ8851_ISR_LCIS <S2SV_ModEnd> ) != 0 <S2SV_ModStart> ( interface , KSZ8851_ISR , KSZ8851_ISR_LCIS <S2SV_ModEnd> ) ; status <S2SV_ModStart> ( interface , KSZ8851_P1SR ) ; if ( ( status & KSZ8851_P1SR_LINK_GOOD ) != 0 ) { if ( ( status & KSZ8851_P1SR_OPERATION_SPEED <S2SV_ModEnd> ) != 0 <S2SV_ModStart> ( status & KSZ8851_P1SR_OPERATION_DUPLEX <S2SV_ModEnd> ) != 0 <S2SV_ModStart> ( status & KSZ8851_ISR_RXIS <S2SV_ModEnd> ) != 0 <S2SV_ModStart> ( interface , KSZ8851_ISR , KSZ8851_ISR_RXIS <S2SV_ModEnd> ) ; frameCount <S2SV_ModStart> ( interface , KSZ8851_RXFCTR <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( interface , KSZ8851_IER , KSZ8851_IER_LCIE | KSZ8851_IER_RXIE <S2SV_ModEnd> ) ; }"
49,"PHP_FUNCTION ( imageaffine ) { zval * IM ; gdImagePtr src ; gdImagePtr dst ; gdRect rect ; gdRectPtr pRect = NULL ; zval * z_rect = NULL ; zval * z_affine ; zval * * tmp ; double affine [ 6 ] ; int i , nelems ; zval * * zval_affine_elem = NULL ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , ""ra|a"" , & IM , & z_affine , & z_rect ) == FAILURE ) { return ; } ZEND_FETCH_RESOURCE ( src , gdImagePtr , & IM , - 1 , ""Image"" , le_gd ) ; if ( ( nelems = zend_hash_num_elements ( Z_ARRVAL_P ( z_affine ) ) ) != 6 ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Affine<S2SV_blank>array<S2SV_blank>must<S2SV_blank>have<S2SV_blank>six<S2SV_blank>elements"" ) ; RETURN_FALSE ; } for ( i = 0 ; i < nelems ; i ++ ) { if ( zend_hash_index_find ( Z_ARRVAL_P ( z_affine ) , i , ( void * * ) & zval_affine_elem ) == SUCCESS ) { switch ( Z_TYPE_PP ( zval_affine_elem ) ) { case IS_LONG : affine [ i ] = Z_LVAL_PP ( zval_affine_elem ) ; break ; case IS_DOUBLE : affine [ i ] = Z_DVAL_PP ( zval_affine_elem ) ; break ; case IS_STRING : <S2SV_StartBug> convert_to_double_ex ( zval_affine_elem ) ; <S2SV_EndBug> <S2SV_StartBug> affine [ i ] = Z_DVAL_PP ( zval_affine_elem ) ; <S2SV_EndBug> break ; default : php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Invalid<S2SV_blank>type<S2SV_blank>for<S2SV_blank>element<S2SV_blank>%i"" , i ) ; RETURN_FALSE ; } } } if ( z_rect != NULL ) { if ( zend_hash_find ( HASH_OF ( z_rect ) , ""x"" , sizeof ( ""x"" ) , ( void * * ) & tmp ) != FAILURE ) { <S2SV_StartBug> convert_to_long_ex ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> rect . x = Z_LVAL_PP ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Missing<S2SV_blank>x<S2SV_blank>position"" ) ; RETURN_FALSE ; } if ( zend_hash_find ( HASH_OF ( z_rect ) , ""y"" , sizeof ( ""x"" ) , ( void * * ) & tmp ) != FAILURE ) { <S2SV_StartBug> convert_to_long_ex ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> rect . y = Z_LVAL_PP ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Missing<S2SV_blank>y<S2SV_blank>position"" ) ; RETURN_FALSE ; } if ( zend_hash_find ( HASH_OF ( z_rect ) , ""width"" , sizeof ( ""width"" ) , ( void * * ) & tmp ) != FAILURE ) { <S2SV_StartBug> convert_to_long_ex ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> rect . width = Z_LVAL_PP ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Missing<S2SV_blank>width"" ) ; RETURN_FALSE ; } if ( zend_hash_find ( HASH_OF ( z_rect ) , ""height"" , sizeof ( ""height"" ) , ( void * * ) & tmp ) != FAILURE ) { <S2SV_StartBug> convert_to_long_ex ( tmp ) ; <S2SV_EndBug> <S2SV_StartBug> rect . height = Z_LVAL_PP ( tmp ) ; <S2SV_EndBug> } else { php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Missing<S2SV_blank>height"" ) ; RETURN_FALSE ; } pRect = & rect ; } else { rect . x = - 1 ; rect . y = - 1 ; rect . width = gdImageSX ( src ) ; rect . height = gdImageSY ( src ) ; pRect = NULL ; } if ( gdTransformAffineGetImage ( & dst , src , pRect , affine ) != GD_TRUE ) { RETURN_FALSE ; } if ( dst == NULL ) { RETURN_FALSE ; } else { ZEND_REGISTER_RESOURCE ( return_value , dst , le_gd ) ; } }",case IS_STRING : { zval dval ; dval = * * zval_affine_elem ; zval_copy_ctor ( & dval ) ; convert_to_double ( & dval <S2SV_ModEnd> ) ; affine <S2SV_ModStart> i ] = Z_DVAL ( dval ) ; } <S2SV_ModEnd> break ; default <S2SV_ModStart> FAILURE ) { if ( Z_TYPE_PP ( tmp ) != IS_LONG ) { zval lval ; lval = * * tmp ; zval_copy_ctor ( & lval ) ; convert_to_long ( & lval <S2SV_ModEnd> ) ; rect <S2SV_ModStart> . x = Z_LVAL ( lval ) ; } else { rect . x = <S2SV_ModStart> ) ; } } <S2SV_ModStart> FAILURE ) { if ( Z_TYPE_PP ( tmp ) != IS_LONG ) { zval lval ; lval = * * tmp ; zval_copy_ctor ( & lval ) ; convert_to_long ( & lval <S2SV_ModEnd> ) ; rect <S2SV_ModStart> . y = Z_LVAL ( lval ) ; } else { rect . y = <S2SV_ModStart> ) ; } } <S2SV_ModStart> FAILURE ) { if ( Z_TYPE_PP ( tmp ) != IS_LONG ) { zval lval ; lval = * * tmp ; zval_copy_ctor ( & lval ) ; convert_to_long ( & lval <S2SV_ModEnd> ) ; rect <S2SV_ModStart> . width = Z_LVAL ( lval ) ; } else { rect . width = <S2SV_ModStart> ) ; } } <S2SV_ModStart> FAILURE ) { if ( Z_TYPE_PP ( tmp ) != IS_LONG ) { zval lval ; lval = * * tmp ; zval_copy_ctor ( & lval ) ; convert_to_long ( & lval <S2SV_ModEnd> ) ; rect <S2SV_ModStart> . height = Z_LVAL ( lval ) ; } else { rect . height = <S2SV_ModStart> tmp ) ; }
50,"int vp9_alloc_context_buffers ( VP9_COMMON * cm , int width , int height ) { int new_mi_size ; vp9_set_mb_mi ( cm , width , height ) ; new_mi_size = cm -> mi_stride * calc_mi_size ( cm -> mi_rows ) ; if ( cm -> mi_alloc_size < new_mi_size ) { cm -> free_mi ( cm ) ; if ( cm -> alloc_mi ( cm , new_mi_size ) ) goto fail ; } if ( cm -> seg_map_alloc_size < cm -> mi_rows * cm -> mi_cols ) { free_seg_map ( cm ) ; if ( alloc_seg_map ( cm , cm -> mi_rows * cm -> mi_cols ) ) goto fail ; } if ( cm -> above_context_alloc_cols < cm -> mi_cols ) { vpx_free ( cm -> above_context ) ; cm -> above_context = ( ENTROPY_CONTEXT * ) vpx_calloc ( 2 * mi_cols_aligned_to_sb ( cm -> mi_cols ) * MAX_MB_PLANE , sizeof ( * cm -> above_context ) ) ; if ( ! cm -> above_context ) goto fail ; vpx_free ( cm -> above_seg_context ) ; cm -> above_seg_context = ( PARTITION_CONTEXT * ) vpx_calloc ( mi_cols_aligned_to_sb ( cm -> mi_cols ) , sizeof ( * cm -> above_seg_context ) ) ; if ( ! cm -> above_seg_context ) goto fail ; cm -> above_context_alloc_cols = cm -> mi_cols ; } return 0 ; fail : <S2SV_StartBug> vp9_free_context_buffers ( cm ) ; <S2SV_EndBug> return 1 ; }","; fail : vp9_set_mb_mi ( cm , 0 , 0 ) ;"
51,"static int mincore_pte_range ( pmd_t * pmd , unsigned long addr , unsigned long end , struct mm_walk * walk ) { spinlock_t * ptl ; struct vm_area_struct * vma = walk -> vma ; pte_t * ptep ; unsigned char * vec = walk -> private ; int nr = ( end - addr ) >> PAGE_SHIFT ; ptl = pmd_trans_huge_lock ( pmd , vma ) ; if ( ptl ) { memset ( vec , 1 , nr ) ; spin_unlock ( ptl ) ; goto out ; } if ( pmd_trans_unstable ( pmd ) ) { <S2SV_StartBug> __mincore_unmapped_range ( addr , end , vma , vec ) ; <S2SV_EndBug> goto out ; } ptep = pte_offset_map_lock ( walk -> mm , pmd , addr , & ptl ) ; for ( ; addr != end ; ptep ++ , addr += PAGE_SIZE ) { pte_t pte = * ptep ; if ( pte_none ( pte ) ) <S2SV_StartBug> __mincore_unmapped_range ( addr , addr + PAGE_SIZE , <S2SV_EndBug> vma , vec ) ; else if ( pte_present ( pte ) ) * vec = 1 ; else { swp_entry_t entry = pte_to_swp_entry ( pte ) ; <S2SV_StartBug> if ( non_swap_entry ( entry ) ) { <S2SV_EndBug> * vec = 1 ; } else { # ifdef CONFIG_SWAP * vec = mincore_page ( swap_address_space ( entry ) , swp_offset ( entry ) ) ; # else WARN_ON ( 1 ) ; * vec = 1 ; # endif } } vec ++ ; } pte_unmap_unlock ( ptep - 1 , ptl ) ; out : walk -> private += nr ; cond_resched ( ) ; return 0 ; }",") ) { memset ( vec , 1 , nr <S2SV_ModEnd> ) ; goto <S2SV_ModStart> pte ) ) * vec = 0 <S2SV_ModEnd> ; else if <S2SV_ModStart> pte ) ; * vec = ! ! <S2SV_ModEnd> non_swap_entry ( entry <S2SV_ModStart> ( entry ) ; <S2SV_ModEnd> } vec ++"
52,"static void php_zip_get_from ( INTERNAL_FUNCTION_PARAMETERS , int type ) { struct zip * intern ; zval * self = getThis ( ) ; struct zip_stat sb ; struct zip_file * zf ; zend_long index = - 1 ; zend_long flags = 0 ; zend_long len = 0 ; zend_string * filename ; zend_string * buffer ; int n = 0 ; if ( ! self ) { RETURN_FALSE ; } ZIP_FROM_OBJECT ( intern , self ) ; if ( type == 1 ) { if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , ""P|ll"" , & filename , & len , & flags ) == FAILURE ) { return ; } PHP_ZIP_STAT_PATH ( intern , ZSTR_VAL ( filename ) , ZSTR_LEN ( filename ) , flags , sb ) ; } else { if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , ""l|ll"" , & index , & len , & flags ) == FAILURE ) { return ; } PHP_ZIP_STAT_INDEX ( intern , index , 0 , sb ) ; } if ( sb . size < 1 ) { RETURN_EMPTY_STRING ( ) ; } if ( len < 1 ) { len = sb . size ; } if ( index >= 0 ) { zf = zip_fopen_index ( intern , index , flags ) ; } else { zf = zip_fopen ( intern , ZSTR_VAL ( filename ) , flags ) ; } if ( zf == NULL ) { RETURN_FALSE ; } <S2SV_StartBug> buffer = zend_string_alloc ( len , 0 ) ; <S2SV_EndBug> n = zip_fread ( zf , ZSTR_VAL ( buffer ) , ZSTR_LEN ( buffer ) ) ; if ( n < 1 ) { zend_string_free ( buffer ) ; RETURN_EMPTY_STRING ( ) ; } zip_fclose ( zf ) ; ZSTR_VAL ( buffer ) [ n ] = '\\0' ; ZSTR_LEN ( buffer ) = n ; RETURN_NEW_STR ( buffer ) ; }","} buffer = zend_string_safe_alloc ( 1 , len , 0 <S2SV_ModEnd> , 0 )"
53,"void virtio_config_writew ( VirtIODevice * vdev , uint32_t addr , uint32_t data ) { VirtioDeviceClass * k = VIRTIO_DEVICE_GET_CLASS ( vdev ) ; uint16_t val = data ; <S2SV_StartBug> if ( addr > ( vdev -> config_len - sizeof ( val ) ) ) <S2SV_EndBug> return ; stw_p ( vdev -> config + addr , val ) ; if ( k -> set_config ) { k -> set_config ( vdev , vdev -> config ) ; } }",if ( addr + <S2SV_ModEnd> sizeof ( val <S2SV_ModStart> ( val ) > vdev -> config_len ) { return ; } <S2SV_ModEnd> stw_p ( vdev
54,"void jiffies_to_timespec ( const unsigned long jiffies , struct timespec * value ) { <S2SV_StartBug> u64 nsec = ( u64 ) jiffies * TICK_NSEC ; <S2SV_EndBug> <S2SV_StartBug> value -> tv_sec = div_long_long_rem ( nsec , NSEC_PER_SEC , & value -> tv_nsec ) ; <S2SV_EndBug> }","value ) { u32 rem ; value -> tv_sec = div_u64_rem ( <S2SV_ModEnd> ( u64 ) <S2SV_ModStart> jiffies * TICK_NSEC , NSEC_PER_SEC , & rem ) <S2SV_ModStart> ; value -> tv_nsec = rem <S2SV_ModEnd> ; } <S2SV_null>"
55,"int bpf_check ( struct bpf_prog * * prog , union bpf_attr * attr ) { struct bpf_verifier_env * env ; struct bpf_verifer_log * log ; int ret = - EINVAL ; if ( ARRAY_SIZE ( bpf_verifier_ops ) == 0 ) return - EINVAL ; env = kzalloc ( sizeof ( struct bpf_verifier_env ) , GFP_KERNEL ) ; if ( ! env ) return - ENOMEM ; log = & env -> log ; env -> insn_aux_data = vzalloc ( sizeof ( struct bpf_insn_aux_data ) * ( * prog ) -> len ) ; ret = - ENOMEM ; if ( ! env -> insn_aux_data ) goto err_free_env ; env -> prog = * prog ; env -> ops = bpf_verifier_ops [ env -> prog -> type ] ; mutex_lock ( & bpf_verifier_lock ) ; if ( attr -> log_level || attr -> log_buf || attr -> log_size ) { log -> level = attr -> log_level ; log -> ubuf = ( char __user * ) ( unsigned long ) attr -> log_buf ; log -> len_total = attr -> log_size ; ret = - EINVAL ; if ( log -> len_total < 128 || log -> len_total > UINT_MAX >> 8 || ! log -> level || ! log -> ubuf ) goto err_unlock ; } env -> strict_alignment = ! ! ( attr -> prog_flags & BPF_F_STRICT_ALIGNMENT ) ; if ( ! IS_ENABLED ( CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS ) ) env -> strict_alignment = true ; if ( env -> prog -> aux -> offload ) { ret = bpf_prog_offload_verifier_prep ( env ) ; if ( ret ) goto err_unlock ; } ret = replace_map_fd_with_map_ptr ( env ) ; if ( ret < 0 ) goto skip_full_check ; env -> explored_states = kcalloc ( env -> prog -> len , sizeof ( struct bpf_verifier_state_list * ) , GFP_USER ) ; ret = - ENOMEM ; if ( ! env -> explored_states ) goto skip_full_check ; ret = check_cfg ( env ) ; if ( ret < 0 ) goto skip_full_check ; env -> allow_ptr_leaks = capable ( CAP_SYS_ADMIN ) ; ret = do_check ( env ) ; if ( env -> cur_state ) { free_verifier_state ( env -> cur_state , true ) ; env -> cur_state = NULL ; } skip_full_check : while ( ! pop_stack ( env , NULL , NULL ) ) ; free_states ( env ) ; if ( ret == 0 ) <S2SV_StartBug> ret = convert_ctx_accesses ( env ) ; <S2SV_EndBug> if ( ret == 0 ) ret = fixup_bpf_calls ( env ) ; if ( log -> level && bpf_verifier_log_full ( log ) ) ret = - ENOSPC ; if ( log -> level && ! log -> ubuf ) { ret = - EFAULT ; goto err_release_maps ; } if ( ret == 0 && env -> used_map_cnt ) { env -> prog -> aux -> used_maps = kmalloc_array ( env -> used_map_cnt , sizeof ( env -> used_maps [ 0 ] ) , GFP_KERNEL ) ; if ( ! env -> prog -> aux -> used_maps ) { ret = - ENOMEM ; goto err_release_maps ; } memcpy ( env -> prog -> aux -> used_maps , env -> used_maps , sizeof ( env -> used_maps [ 0 ] ) * env -> used_map_cnt ) ; env -> prog -> aux -> used_map_cnt = env -> used_map_cnt ; convert_pseudo_ld_imm64 ( env ) ; } err_release_maps : if ( ! env -> prog -> aux -> used_maps ) release_maps ( env ) ; * prog = env -> prog ; err_unlock : mutex_unlock ( & bpf_verifier_lock ) ; vfree ( env -> insn_aux_data ) ; err_free_env : kfree ( env ) ; return ret ; }",== 0 ) sanitize_dead_code ( env ) ; if ( ret == 0 )
56,"void * vpx_realloc ( void * memblk , size_t size ) { void * addr , * new_addr = NULL ; int align = DEFAULT_ALIGNMENT ; if ( ! memblk ) new_addr = vpx_malloc ( size ) ; else if ( ! size ) vpx_free ( memblk ) ; else { addr = ( void * ) ( ( ( size_t * ) memblk ) [ - 1 ] ) ; memblk = NULL ; <S2SV_StartBug> # if CONFIG_MEM_MANAGER <S2SV_EndBug> new_addr = vpx_mm_realloc ( addr , size + align + ADDRESS_STORAGE_SIZE ) ; <S2SV_StartBug> # else <S2SV_EndBug> new_addr = VPX_REALLOC_L ( addr , size + align + ADDRESS_STORAGE_SIZE ) ; # endif if ( new_addr ) { addr = new_addr ; new_addr = ( void * ) ( ( ( size_t ) ( ( unsigned char * ) new_addr + ADDRESS_STORAGE_SIZE ) + ( align - 1 ) ) & ( size_t ) - align ) ; ( ( size_t * ) new_addr ) [ - 1 ] = ( size_t ) addr ; } } return new_addr ; }","= NULL ; new_addr = realloc <S2SV_ModEnd> ( addr , <S2SV_ModStart> ADDRESS_STORAGE_SIZE ) ; <S2SV_ModEnd> if ( new_addr"
57,"static void finish_process_as_req ( struct as_req_state * state , krb5_error_code errcode ) { krb5_key_data * server_key ; krb5_keyblock * as_encrypting_key = NULL ; krb5_data * response = NULL ; const char * emsg = 0 ; int did_log = 0 ; loop_respond_fn oldrespond ; void * oldarg ; kdc_realm_t * kdc_active_realm = state -> active_realm ; krb5_audit_state * au_state = state -> au_state ; assert ( state ) ; oldrespond = state -> respond ; oldarg = state -> arg ; if ( errcode ) goto egress ; au_state -> stage = ENCR_REP ; if ( ( errcode = validate_forwardable ( state -> request , * state -> client , * state -> server , state -> kdc_time , & state -> status ) ) ) { errcode += ERROR_TABLE_BASE_krb5 ; goto egress ; } errcode = check_indicators ( kdc_context , state -> server , state -> auth_indicators ) ; if ( errcode ) { state -> status = ""HIGHER_AUTHENTICATION_REQUIRED"" ; goto egress ; } state -> ticket_reply . enc_part2 = & state -> enc_tkt_reply ; if ( ( errcode = krb5_dbe_find_enctype ( kdc_context , state -> server , - 1 , - 1 , 0 , & server_key ) ) ) { state -> status = ""FINDING_SERVER_KEY"" ; goto egress ; } if ( ( errcode = krb5_dbe_decrypt_key_data ( kdc_context , NULL , server_key , & state -> server_keyblock , NULL ) ) ) { state -> status = ""DECRYPT_SERVER_KEY"" ; goto egress ; } state -> reply . msg_type = KRB5_AS_REP ; state -> reply . client = state -> enc_tkt_reply . client ; state -> reply . ticket = & state -> ticket_reply ; state -> reply_encpart . session = & state -> session_key ; if ( ( errcode = fetch_last_req_info ( state -> client , & state -> reply_encpart . last_req ) ) ) { state -> status = ""FETCH_LAST_REQ"" ; goto egress ; } state -> reply_encpart . nonce = state -> request -> nonce ; state -> reply_encpart . key_exp = get_key_exp ( state -> client ) ; state -> reply_encpart . flags = state -> enc_tkt_reply . flags ; state -> reply_encpart . server = state -> ticket_reply . server ; state -> reply_encpart . times = state -> enc_tkt_reply . times ; state -> reply_encpart . times . authtime = state -> authtime = state -> kdc_time ; state -> reply_encpart . caddrs = state -> enc_tkt_reply . caddrs ; state -> reply_encpart . enc_padata = NULL ; errcode = return_padata ( kdc_context , & state -> rock , state -> req_pkt , state -> request , & state -> reply , & state -> client_keyblock , & state -> pa_context ) ; if ( errcode ) { state -> status = ""KDC_RETURN_PADATA"" ; goto egress ; } if ( state -> client_keyblock . enctype == ENCTYPE_NULL ) { state -> status = ""CANT_FIND_CLIENT_KEY"" ; errcode = KRB5KDC_ERR_ETYPE_NOSUPP ; goto egress ; } errcode = handle_authdata ( kdc_context , state -> c_flags , state -> client , state -> server , NULL , state -> local_tgt , & state -> client_keyblock , & state -> server_keyblock , NULL , state -> req_pkt , state -> request , NULL , NULL , state -> auth_indicators , & state -> enc_tkt_reply ) ; if ( errcode ) { krb5_klog_syslog ( LOG_INFO , _ ( ""AS_REQ<S2SV_blank>:<S2SV_blank>handle_authdata<S2SV_blank>(%d)"" ) , errcode ) ; state -> status = ""HANDLE_AUTHDATA"" ; goto egress ; } errcode = krb5_encrypt_tkt_part ( kdc_context , & state -> server_keyblock , & state -> ticket_reply ) ; if ( errcode ) { state -> status = ""ENCRYPT_TICKET"" ; goto egress ; } errcode = kau_make_tkt_id ( kdc_context , & state -> ticket_reply , & au_state -> tkt_out_id ) ; if ( errcode ) { state -> status = ""GENERATE_TICKET_ID"" ; goto egress ; } state -> ticket_reply . enc_part . kvno = server_key -> key_data_kvno ; errcode = kdc_fast_response_handle_padata ( state -> rstate , state -> request , & state -> reply , state -> client_keyblock . enctype ) ; if ( errcode ) { state -> status = ""MAKE_FAST_RESPONSE"" ; goto egress ; } state -> reply . enc_part . enctype = state -> client_keyblock . enctype ; errcode = kdc_fast_handle_reply_key ( state -> rstate , & state -> client_keyblock , & as_encrypting_key ) ; if ( errcode ) { state -> status = ""MAKE_FAST_REPLY_KEY"" ; goto egress ; } errcode = return_enc_padata ( kdc_context , state -> req_pkt , state -> request , as_encrypting_key , state -> server , & state -> reply_encpart , FALSE ) ; if ( errcode ) { state -> status = ""KDC_RETURN_ENC_PADATA"" ; goto egress ; } if ( kdc_fast_hide_client ( state -> rstate ) ) state -> reply . client = ( krb5_principal ) krb5_anonymous_principal ( ) ; errcode = krb5_encode_kdc_rep ( kdc_context , KRB5_AS_REP , & state -> reply_encpart , 0 , as_encrypting_key , & state -> reply , & response ) ; if ( state -> client_key != NULL ) state -> reply . enc_part . kvno = state -> client_key -> key_data_kvno ; if ( errcode ) { state -> status = ""ENCODE_KDC_REP"" ; goto egress ; } memset ( state -> reply . enc_part . ciphertext . data , 0 , state -> reply . enc_part . ciphertext . length ) ; free ( state -> reply . enc_part . ciphertext . data ) ; log_as_req ( kdc_context , state -> local_addr , state -> remote_addr , state -> request , & state -> reply , state -> client , state -> cname , state -> server , state -> sname , state -> authtime , 0 , 0 , 0 ) ; did_log = 1 ; egress : <S2SV_StartBug> if ( errcode != 0 ) <S2SV_EndBug> assert ( state -> status != 0 ) ; au_state -> status = state -> status ; au_state -> reply = & state -> reply ; kau_as_req ( kdc_context , ( errcode || state -> preauth_err ) ? FALSE : TRUE , au_state ) ; kau_free_kdc_req ( au_state ) ; free_padata_context ( kdc_context , state -> pa_context ) ; if ( as_encrypting_key ) krb5_free_keyblock ( kdc_context , as_encrypting_key ) ; if ( errcode ) emsg = krb5_get_error_message ( kdc_context , errcode ) ; if ( state -> status ) { log_as_req ( kdc_context , state -> local_addr , state -> remote_addr , state -> request , & state -> reply , state -> client , state -> cname , state -> server , state -> sname , state -> authtime , state -> status , errcode , emsg ) ; did_log = 1 ; } if ( errcode ) { if ( state -> status == 0 ) { state -> status = emsg ; } if ( errcode != KRB5KDC_ERR_DISCARD ) { errcode -= ERROR_TABLE_BASE_krb5 ; if ( errcode < 0 || errcode > KRB_ERR_MAX ) errcode = KRB_ERR_GENERIC ; errcode = prepare_error_as ( state -> rstate , state -> request , state -> local_tgt , errcode , state -> e_data , state -> typed_e_data , ( ( state -> client != NULL ) ? state -> client -> princ : NULL ) , & response , state -> status ) ; state -> status = 0 ; } } if ( emsg ) krb5_free_error_message ( kdc_context , emsg ) ; if ( state -> enc_tkt_reply . authorization_data != NULL ) krb5_free_authdata ( kdc_context , state -> enc_tkt_reply . authorization_data ) ; if ( state -> server_keyblock . contents != NULL ) krb5_free_keyblock_contents ( kdc_context , & state -> server_keyblock ) ; if ( state -> client_keyblock . contents != NULL ) krb5_free_keyblock_contents ( kdc_context , & state -> client_keyblock ) ; if ( state -> reply . padata != NULL ) krb5_free_pa_data ( kdc_context , state -> reply . padata ) ; if ( state -> reply_encpart . enc_padata ) krb5_free_pa_data ( kdc_context , state -> reply_encpart . enc_padata ) ; if ( state -> cname != NULL ) free ( state -> cname ) ; if ( state -> sname != NULL ) free ( state -> sname ) ; krb5_db_free_principal ( kdc_context , state -> client ) ; krb5_db_free_principal ( kdc_context , state -> server ) ; krb5_db_free_principal ( kdc_context , state -> local_tgt_storage ) ; if ( state -> session_key . contents != NULL ) krb5_free_keyblock_contents ( kdc_context , & state -> session_key ) ; if ( state -> ticket_reply . enc_part . ciphertext . data != NULL ) { memset ( state -> ticket_reply . enc_part . ciphertext . data , 0 , state -> ticket_reply . enc_part . ciphertext . length ) ; free ( state -> ticket_reply . enc_part . ciphertext . data ) ; } krb5_free_pa_data ( kdc_context , state -> e_data ) ; krb5_free_data ( kdc_context , state -> inner_body ) ; kdc_free_rstate ( state -> rstate ) ; krb5_free_kdc_req ( kdc_context , state -> request ) ; k5_free_data_ptr_list ( state -> auth_indicators ) ; assert ( did_log != 0 ) ; free ( state ) ; ( * oldrespond ) ( oldarg , errcode , response ) ; }","errcode != 0 && state -> status == NULL ) state -> status = ""UNKNOWN_REASON"" <S2SV_ModEnd> ; au_state ->"
58,"static Image * ReadVIFFImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define VFF_CM_genericRGB 15 # define VFF_CM_ntscRGB 1 # define VFF_CM_NONE 0 # define VFF_DEP_DECORDER 0x4 # define VFF_DEP_NSORDER 0x8 # define VFF_DES_RAW 0 # define VFF_LOC_IMPLICIT 1 # define VFF_MAPTYP_NONE 0 # define VFF_MAPTYP_1_BYTE 1 # define VFF_MAPTYP_2_BYTE 2 # define VFF_MAPTYP_4_BYTE 4 # define VFF_MAPTYP_FLOAT 5 # define VFF_MAPTYP_DOUBLE 7 # define VFF_MS_NONE 0 # define VFF_MS_ONEPERBAND 1 # define VFF_MS_SHARED 3 # define VFF_TYP_BIT 0 # define VFF_TYP_1_BYTE 1 # define VFF_TYP_2_BYTE 2 # define VFF_TYP_4_BYTE 4 # define VFF_TYP_FLOAT 5 # define VFF_TYP_DOUBLE 9 typedef struct _ViffInfo { unsigned char identifier , file_type , release , version , machine_dependency , reserve [ 3 ] ; char comment [ 512 ] ; unsigned int rows , columns , subrows ; int x_offset , y_offset ; float x_bits_per_pixel , y_bits_per_pixel ; unsigned int location_type , location_dimension , number_of_images , number_data_bands , data_storage_type , data_encode_scheme , map_scheme , map_storage_type , map_rows , map_columns , map_subrows , map_enable , maps_per_cycle , color_space_model ; } ViffInfo ; double min_value , scale_factor , value ; Image * image ; int bit ; MagickBooleanType status ; MagickSizeType number_pixels ; register IndexPacket * indexes ; register ssize_t x ; register PixelPacket * q ; register ssize_t i ; register unsigned char * p ; size_t bytes_per_pixel , max_packets , quantum ; ssize_t count , y ; unsigned char * pixels ; unsigned long lsb_first ; ViffInfo viff_info ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } count = ReadBlob ( image , 1 , & viff_info . identifier ) ; do { if ( ( count != 1 ) || ( ( unsigned char ) viff_info . identifier != 0xab ) ) ThrowReaderException ( CorruptImageError , ""NotAVIFFImage"" ) ; ( void ) ReadBlob ( image , sizeof ( viff_info . file_type ) , & viff_info . file_type ) ; ( void ) ReadBlob ( image , sizeof ( viff_info . release ) , & viff_info . release ) ; ( void ) ReadBlob ( image , sizeof ( viff_info . version ) , & viff_info . version ) ; ( void ) ReadBlob ( image , sizeof ( viff_info . machine_dependency ) , & viff_info . machine_dependency ) ; ( void ) ReadBlob ( image , sizeof ( viff_info . reserve ) , viff_info . reserve ) ; ( void ) ReadBlob ( image , 512 , ( unsigned char * ) viff_info . comment ) ; viff_info . comment [ 511 ] = '\\0' ; if ( strlen ( viff_info . comment ) > 4 ) ( void ) SetImageProperty ( image , ""comment"" , viff_info . comment ) ; if ( ( viff_info . machine_dependency == VFF_DEP_DECORDER ) || ( viff_info . machine_dependency == VFF_DEP_NSORDER ) ) image -> endian = LSBEndian ; else image -> endian = MSBEndian ; viff_info . rows = ReadBlobLong ( image ) ; viff_info . columns = ReadBlobLong ( image ) ; viff_info . subrows = ReadBlobLong ( image ) ; viff_info . x_offset = ReadBlobSignedLong ( image ) ; viff_info . y_offset = ReadBlobSignedLong ( image ) ; viff_info . x_bits_per_pixel = ( float ) ReadBlobLong ( image ) ; viff_info . y_bits_per_pixel = ( float ) ReadBlobLong ( image ) ; viff_info . location_type = ReadBlobLong ( image ) ; viff_info . location_dimension = ReadBlobLong ( image ) ; viff_info . number_of_images = ReadBlobLong ( image ) ; viff_info . number_data_bands = ReadBlobLong ( image ) ; viff_info . data_storage_type = ReadBlobLong ( image ) ; viff_info . data_encode_scheme = ReadBlobLong ( image ) ; viff_info . map_scheme = ReadBlobLong ( image ) ; viff_info . map_storage_type = ReadBlobLong ( image ) ; viff_info . map_rows = ReadBlobLong ( image ) ; viff_info . map_columns = ReadBlobLong ( image ) ; viff_info . map_subrows = ReadBlobLong ( image ) ; viff_info . map_enable = ReadBlobLong ( image ) ; viff_info . maps_per_cycle = ReadBlobLong ( image ) ; viff_info . color_space_model = ReadBlobLong ( image ) ; for ( i = 0 ; i < 420 ; i ++ ) ( void ) ReadBlobByte ( image ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; image -> columns = viff_info . rows ; image -> rows = viff_info . columns ; image -> depth = viff_info . x_bits_per_pixel <= 8 ? 8UL : MAGICKCORE_QUANTUM_DEPTH ; number_pixels = ( MagickSizeType ) viff_info . columns * viff_info . rows ; if ( number_pixels != ( size_t ) number_pixels ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; if ( number_pixels == 0 ) ThrowReaderException ( CoderError , ""ImageColumnOrRowSizeIsNotSupported"" ) ; if ( ( viff_info . number_data_bands < 1 ) || ( viff_info . number_data_bands > 4 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( viff_info . data_storage_type != VFF_TYP_BIT ) && ( viff_info . data_storage_type != VFF_TYP_1_BYTE ) && ( viff_info . data_storage_type != VFF_TYP_2_BYTE ) && ( viff_info . data_storage_type != VFF_TYP_4_BYTE ) && ( viff_info . data_storage_type != VFF_TYP_FLOAT ) && ( viff_info . data_storage_type != VFF_TYP_DOUBLE ) ) ThrowReaderException ( CoderError , ""DataStorageTypeIsNotSupported"" ) ; if ( viff_info . data_encode_scheme != VFF_DES_RAW ) ThrowReaderException ( CoderError , ""DataEncodingSchemeIsNotSupported"" ) ; if ( ( viff_info . map_storage_type != VFF_MAPTYP_NONE ) && ( viff_info . map_storage_type != VFF_MAPTYP_1_BYTE ) && ( viff_info . map_storage_type != VFF_MAPTYP_2_BYTE ) && ( viff_info . map_storage_type != VFF_MAPTYP_4_BYTE ) && ( viff_info . map_storage_type != VFF_MAPTYP_FLOAT ) && ( viff_info . map_storage_type != VFF_MAPTYP_DOUBLE ) ) ThrowReaderException ( CoderError , ""MapStorageTypeIsNotSupported"" ) ; if ( ( viff_info . color_space_model != VFF_CM_NONE ) && ( viff_info . color_space_model != VFF_CM_ntscRGB ) && ( viff_info . color_space_model != VFF_CM_genericRGB ) ) ThrowReaderException ( CoderError , ""ColorspaceModelIsNotSupported"" ) ; if ( viff_info . location_type != VFF_LOC_IMPLICIT ) ThrowReaderException ( CoderError , ""LocationTypeIsNotSupported"" ) ; if ( viff_info . number_of_images != 1 ) ThrowReaderException ( CoderError , ""NumberOfImagesIsNotSupported"" ) ; if ( viff_info . map_rows == 0 ) viff_info . map_scheme = VFF_MS_NONE ; switch ( ( int ) viff_info . map_scheme ) { case VFF_MS_NONE : { if ( viff_info . number_data_bands < 3 ) { if ( viff_info . data_storage_type == VFF_TYP_BIT ) image -> colors = 2 ; else if ( viff_info . data_storage_type == VFF_MAPTYP_1_BYTE ) image -> colors = 256UL ; else image -> colors = image -> depth <= 8 ? 256UL : 65536UL ; if ( AcquireImageColormap ( image , image -> colors ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } break ; } case VFF_MS_ONEPERBAND : case VFF_MS_SHARED : { unsigned char * viff_colormap ; switch ( ( int ) viff_info . map_storage_type ) { case VFF_MAPTYP_1_BYTE : bytes_per_pixel = 1 ; break ; case VFF_MAPTYP_2_BYTE : bytes_per_pixel = 2 ; break ; case VFF_MAPTYP_4_BYTE : bytes_per_pixel = 4 ; break ; case VFF_MAPTYP_FLOAT : bytes_per_pixel = 4 ; break ; case VFF_MAPTYP_DOUBLE : bytes_per_pixel = 8 ; break ; default : bytes_per_pixel = 1 ; break ; } image -> colors = viff_info . map_columns ; if ( AcquireImageColormap ( image , image -> colors ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; if ( viff_info . map_rows > ( viff_info . map_rows * bytes_per_pixel * sizeof ( * viff_colormap ) ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; viff_colormap = ( unsigned char * ) AcquireQuantumMemory ( image -> colors , viff_info . map_rows * bytes_per_pixel * sizeof ( * viff_colormap ) ) ; if ( viff_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) ReadBlob ( image , bytes_per_pixel * image -> colors * viff_info . map_rows , viff_colormap ) ; lsb_first = 1 ; if ( * ( char * ) & lsb_first && ( ( viff_info . machine_dependency != VFF_DEP_DECORDER ) && ( viff_info . machine_dependency != VFF_DEP_NSORDER ) ) ) switch ( ( int ) viff_info . map_storage_type ) { case VFF_MAPTYP_2_BYTE : { MSBOrderShort ( viff_colormap , ( bytes_per_pixel * image -> colors * viff_info . map_rows ) ) ; break ; } case VFF_MAPTYP_4_BYTE : case VFF_MAPTYP_FLOAT : { MSBOrderLong ( viff_colormap , ( bytes_per_pixel * image -> colors * viff_info . map_rows ) ) ; break ; } default : break ; } for ( i = 0 ; i < ( ssize_t ) ( viff_info . map_rows * image -> colors ) ; i ++ ) { switch ( ( int ) viff_info . map_storage_type ) { case VFF_MAPTYP_2_BYTE : value = 1.0 * ( ( short * ) viff_colormap ) [ i ] ; break ; case VFF_MAPTYP_4_BYTE : value = 1.0 * ( ( int * ) viff_colormap ) [ i ] ; break ; case VFF_MAPTYP_FLOAT : value = ( ( float * ) viff_colormap ) [ i ] ; break ; case VFF_MAPTYP_DOUBLE : value = ( ( double * ) viff_colormap ) [ i ] ; break ; default : value = 1.0 * viff_colormap [ i ] ; break ; } if ( i < ( ssize_t ) image -> colors ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( ( unsigned char ) value ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( ( unsigned char ) value ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( ( unsigned char ) value ) ; } else if ( i < ( ssize_t ) ( 2 * image -> colors ) ) image -> colormap [ i % image -> colors ] . green = ScaleCharToQuantum ( ( unsigned char ) value ) ; else if ( i < ( ssize_t ) ( 3 * image -> colors ) ) image -> colormap [ i % image -> colors ] . blue = ScaleCharToQuantum ( ( unsigned char ) value ) ; } viff_colormap = ( unsigned char * ) RelinquishMagickMemory ( viff_colormap ) ; break ; } default : ThrowReaderException ( CoderError , ""ColormapTypeNotSupported"" ) ; } image -> matte = viff_info . number_data_bands == 4 ? MagickTrue : MagickFalse ; image -> storage_class = ( viff_info . number_data_bands < 3 ? PseudoClass : DirectClass ) ; image -> columns = viff_info . rows ; image -> rows = viff_info . columns ; if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } switch ( ( int ) viff_info . data_storage_type ) { case VFF_TYP_2_BYTE : bytes_per_pixel = 2 ; break ; case VFF_TYP_4_BYTE : bytes_per_pixel = 4 ; break ; case VFF_TYP_FLOAT : bytes_per_pixel = 4 ; break ; case VFF_TYP_DOUBLE : bytes_per_pixel = 8 ; break ; default : bytes_per_pixel = 1 ; break ; } if ( viff_info . data_storage_type == VFF_TYP_BIT ) { <S2SV_StartBug> if ( CheckMemoryOverflow ( ( image -> columns + 7UL ) >> 3UL , image -> rows ) != MagickFalse ) <S2SV_EndBug> ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; max_packets = ( ( image -> columns + 7UL ) >> 3UL ) * image -> rows ; } else { <S2SV_StartBug> if ( CheckMemoryOverflow ( number_pixels , viff_info . number_data_bands ) != MagickFalse ) <S2SV_EndBug> ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; max_packets = ( size_t ) ( number_pixels * viff_info . number_data_bands ) ; } pixels = ( unsigned char * ) AcquireQuantumMemory ( MagickMax ( number_pixels , max_packets ) , bytes_per_pixel * sizeof ( * pixels ) ) ; if ( pixels == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) ReadBlob ( image , bytes_per_pixel * max_packets , pixels ) ; lsb_first = 1 ; if ( * ( char * ) & lsb_first && ( ( viff_info . machine_dependency != VFF_DEP_DECORDER ) && ( viff_info . machine_dependency != VFF_DEP_NSORDER ) ) ) switch ( ( int ) viff_info . data_storage_type ) { case VFF_TYP_2_BYTE : { MSBOrderShort ( pixels , bytes_per_pixel * max_packets ) ; break ; } case VFF_TYP_4_BYTE : case VFF_TYP_FLOAT : { MSBOrderLong ( pixels , bytes_per_pixel * max_packets ) ; break ; } default : break ; } min_value = 0.0 ; scale_factor = 1.0 ; if ( ( viff_info . data_storage_type != VFF_TYP_1_BYTE ) && ( viff_info . map_scheme == VFF_MS_NONE ) ) { double max_value ; switch ( ( int ) viff_info . data_storage_type ) { case VFF_TYP_2_BYTE : value = 1.0 * ( ( short * ) pixels ) [ 0 ] ; break ; case VFF_TYP_4_BYTE : value = 1.0 * ( ( int * ) pixels ) [ 0 ] ; break ; case VFF_TYP_FLOAT : value = ( ( float * ) pixels ) [ 0 ] ; break ; case VFF_TYP_DOUBLE : value = ( ( double * ) pixels ) [ 0 ] ; break ; default : value = 1.0 * pixels [ 0 ] ; break ; } max_value = value ; min_value = value ; for ( i = 0 ; i < ( ssize_t ) max_packets ; i ++ ) { switch ( ( int ) viff_info . data_storage_type ) { case VFF_TYP_2_BYTE : value = 1.0 * ( ( short * ) pixels ) [ i ] ; break ; case VFF_TYP_4_BYTE : value = 1.0 * ( ( int * ) pixels ) [ i ] ; break ; case VFF_TYP_FLOAT : value = ( ( float * ) pixels ) [ i ] ; break ; case VFF_TYP_DOUBLE : value = ( ( double * ) pixels ) [ i ] ; break ; default : value = 1.0 * pixels [ i ] ; break ; } if ( value > max_value ) max_value = value ; else if ( value < min_value ) min_value = value ; } if ( ( min_value == 0 ) && ( max_value == 0 ) ) scale_factor = 0 ; else if ( min_value == max_value ) { scale_factor = ( MagickRealType ) QuantumRange / min_value ; min_value = 0 ; } else scale_factor = ( MagickRealType ) QuantumRange / ( max_value - min_value ) ; } p = ( unsigned char * ) pixels ; for ( i = 0 ; i < ( ssize_t ) max_packets ; i ++ ) { switch ( ( int ) viff_info . data_storage_type ) { case VFF_TYP_2_BYTE : value = 1.0 * ( ( short * ) pixels ) [ i ] ; break ; case VFF_TYP_4_BYTE : value = 1.0 * ( ( int * ) pixels ) [ i ] ; break ; case VFF_TYP_FLOAT : value = ( ( float * ) pixels ) [ i ] ; break ; case VFF_TYP_DOUBLE : value = ( ( double * ) pixels ) [ i ] ; break ; default : value = 1.0 * pixels [ i ] ; break ; } if ( viff_info . map_scheme == VFF_MS_NONE ) { value = ( value - min_value ) * scale_factor ; if ( value > QuantumRange ) value = QuantumRange ; else if ( value < 0 ) value = 0 ; } * p = ( unsigned char ) ( ( Quantum ) value ) ; p ++ ; } p = ( unsigned char * ) pixels ; if ( viff_info . data_storage_type == VFF_TYP_BIT ) { if ( image -> storage_class != PseudoClass ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; indexes = GetAuthenticIndexQueue ( image ) ; for ( x = 0 ; x < ( ssize_t ) ( image -> columns - 7 ) ; x += 8 ) { for ( bit = 0 ; bit < 8 ; bit ++ ) { quantum = ( size_t ) ( ( * p ) & ( 0x01 << bit ) ? 0 : 1 ) ; SetPixelRed ( q , quantum == 0 ? 0 : QuantumRange ) ; SetPixelGreen ( q , quantum == 0 ? 0 : QuantumRange ) ; SetPixelBlue ( q , quantum == 0 ? 0 : QuantumRange ) ; if ( image -> storage_class == PseudoClass ) SetPixelIndex ( indexes + x + bit , quantum ) ; } p ++ ; } if ( ( image -> columns % 8 ) != 0 ) { for ( bit = 0 ; bit < ( int ) ( image -> columns % 8 ) ; bit ++ ) { quantum = ( size_t ) ( ( * p ) & ( 0x01 << bit ) ? 0 : 1 ) ; SetPixelRed ( q , quantum == 0 ? 0 : QuantumRange ) ; SetPixelGreen ( q , quantum == 0 ? 0 : QuantumRange ) ; SetPixelBlue ( q , quantum == 0 ? 0 : QuantumRange ) ; if ( image -> storage_class == PseudoClass ) SetPixelIndex ( indexes + x + bit , quantum ) ; } p ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else if ( image -> storage_class == PseudoClass ) for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; indexes = GetAuthenticIndexQueue ( image ) ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) SetPixelIndex ( indexes + x , * p ++ ) ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } else { number_pixels = ( MagickSizeType ) image -> columns * image -> rows ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( q , ScaleCharToQuantum ( * p ) ) ; SetPixelGreen ( q , ScaleCharToQuantum ( * ( p + number_pixels ) ) ) ; SetPixelBlue ( q , ScaleCharToQuantum ( * ( p + 2 * number_pixels ) ) ) ; if ( image -> colors != 0 ) { ssize_t index ; index = ( ssize_t ) GetPixelRed ( q ) ; SetPixelRed ( q , image -> colormap [ ( ssize_t ) ConstrainColormapIndex ( image , index ) ] . red ) ; index = ( ssize_t ) GetPixelGreen ( q ) ; SetPixelGreen ( q , image -> colormap [ ( ssize_t ) ConstrainColormapIndex ( image , index ) ] . green ) ; index = ( ssize_t ) GetPixelRed ( q ) ; SetPixelBlue ( q , image -> colormap [ ( ssize_t ) ConstrainColormapIndex ( image , index ) ] . blue ) ; } SetPixelOpacity ( q , image -> matte != MagickFalse ? QuantumRange - ScaleCharToQuantum ( * ( p + number_pixels * 3 ) ) : OpaqueOpacity ) ; p ++ ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } pixels = ( unsigned char * ) RelinquishMagickMemory ( pixels ) ; if ( image -> storage_class == PseudoClass ) ( void ) SyncImage ( image ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; count = ReadBlob ( image , 1 , & viff_info . identifier ) ; if ( ( count != 0 ) && ( viff_info . identifier == 0xab ) ) { AcquireNextImage ( image_info , image ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( ( count != 0 ) && ( viff_info . identifier == 0xab ) ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }","{ if ( HeapOverflowSanityCheck <S2SV_ModEnd> ( ( image <S2SV_ModStart> { if ( HeapOverflowSanityCheck <S2SV_ModEnd> ( number_pixels ,"
59,"static int newkeys_from_blob ( struct sshbuf * m , struct ssh * ssh , int mode ) { struct sshbuf * b = NULL ; struct sshcomp * comp ; struct sshenc * enc ; struct sshmac * mac ; struct newkeys * newkey = NULL ; size_t keylen , ivlen , maclen ; int r ; if ( ( newkey = calloc ( 1 , sizeof ( * newkey ) ) ) == NULL ) { r = SSH_ERR_ALLOC_FAIL ; goto out ; } if ( ( r = sshbuf_froms ( m , & b ) ) != 0 ) goto out ; # ifdef DEBUG_PK sshbuf_dump ( b , stderr ) ; # endif enc = & newkey -> enc ; mac = & newkey -> mac ; comp = & newkey -> comp ; if ( ( r = sshbuf_get_cstring ( b , & enc -> name , NULL ) ) != 0 || ( r = sshbuf_get ( b , & enc -> cipher , sizeof ( enc -> cipher ) ) ) != 0 || ( r = sshbuf_get_u32 ( b , ( u_int * ) & enc -> enabled ) ) != 0 || ( r = sshbuf_get_u32 ( b , & enc -> block_size ) ) != 0 || ( r = sshbuf_get_string ( b , & enc -> key , & keylen ) ) != 0 || ( r = sshbuf_get_string ( b , & enc -> iv , & ivlen ) ) != 0 ) goto out ; if ( cipher_authlen ( enc -> cipher ) == 0 ) { if ( ( r = sshbuf_get_cstring ( b , & mac -> name , NULL ) ) != 0 ) goto out ; if ( ( r = mac_setup ( mac , mac -> name ) ) != 0 ) goto out ; if ( ( r = sshbuf_get_u32 ( b , ( u_int * ) & mac -> enabled ) ) != 0 || ( r = sshbuf_get_string ( b , & mac -> key , & maclen ) ) != 0 ) goto out ; if ( maclen > mac -> key_len ) { r = SSH_ERR_INVALID_FORMAT ; goto out ; } mac -> key_len = maclen ; } <S2SV_StartBug> if ( ( r = sshbuf_get_u32 ( b , & comp -> type ) ) != 0 || <S2SV_EndBug> ( r = sshbuf_get_u32 ( b , ( u_int * ) & comp -> enabled ) ) != 0 || ( r = sshbuf_get_cstring ( b , & comp -> name , NULL ) ) != 0 ) goto out ; if ( enc -> name == NULL || cipher_by_name ( enc -> name ) != enc -> cipher ) { r = SSH_ERR_INVALID_FORMAT ; goto out ; } if ( sshbuf_len ( b ) != 0 ) { r = SSH_ERR_INVALID_FORMAT ; goto out ; } enc -> key_len = keylen ; enc -> iv_len = ivlen ; ssh -> kex -> newkeys [ mode ] = newkey ; newkey = NULL ; r = 0 ; out : free ( newkey ) ; sshbuf_free ( b ) ; return r ; }",comp -> type <S2SV_ModEnd> ) ) !=
60,"static Image * ReadMATImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image , * image2 = NULL , * rotated_image ; register Quantum * q ; unsigned int status ; MATHeader MATLAB_HDR ; size_t size ; size_t CellType ; QuantumInfo * quantum_info ; ImageInfo * clone_info ; int i ; ssize_t ldblk ; unsigned char * BImgBuff = NULL ; double MinVal , MaxVal ; unsigned z , z2 ; unsigned Frames ; int logging ; int sample_size ; MagickOffsetType filepos = 0x80 ; BlobInfo * blob ; size_t one ; unsigned int ( * ReadBlobXXXLong ) ( Image * image ) ; unsigned short ( * ReadBlobXXXShort ) ( Image * image ) ; void ( * ReadBlobDoublesXXX ) ( Image * image , size_t len , double * data ) ; void ( * ReadBlobFloatsXXX ) ( Image * image , size_t len , float * data ) ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; logging = LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""enter"" ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } quantum_info = ( QuantumInfo * ) NULL ; clone_info = ( ImageInfo * ) NULL ; if ( ReadBlob ( image , 124 , ( unsigned char * ) & MATLAB_HDR . identific ) != 124 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( strncmp ( MATLAB_HDR . identific , ""MATLAB"" , 6 ) != 0 ) { image2 = ReadMATImageV4 ( image_info , image , exception ) ; if ( image2 == NULL ) goto MATLAB_KO ; image = image2 ; goto END_OF_READING ; } MATLAB_HDR . Version = ReadBlobLSBShort ( image ) ; if ( ReadBlob ( image , 2 , ( unsigned char * ) & MATLAB_HDR . EndianIndicator ) != 2 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Endian<S2SV_blank>%c%c"" , MATLAB_HDR . EndianIndicator [ 0 ] , MATLAB_HDR . EndianIndicator [ 1 ] ) ; if ( ! strncmp ( MATLAB_HDR . EndianIndicator , ""IM"" , 2 ) ) { ReadBlobXXXLong = ReadBlobLSBLong ; ReadBlobXXXShort = ReadBlobLSBShort ; ReadBlobDoublesXXX = ReadBlobDoublesLSB ; ReadBlobFloatsXXX = ReadBlobFloatsLSB ; image -> endian = LSBEndian ; } else if ( ! strncmp ( MATLAB_HDR . EndianIndicator , ""MI"" , 2 ) ) { ReadBlobXXXLong = ReadBlobMSBLong ; ReadBlobXXXShort = ReadBlobMSBShort ; ReadBlobDoublesXXX = ReadBlobDoublesMSB ; ReadBlobFloatsXXX = ReadBlobFloatsMSB ; image -> endian = MSBEndian ; } else goto MATLAB_KO ; if ( strncmp ( MATLAB_HDR . identific , ""MATLAB"" , 6 ) ) { MATLAB_KO : if ( ( image != image2 ) && ( image2 != ( Image * ) NULL ) ) image2 = DestroyImage ( image2 ) ; if ( clone_info != ( ImageInfo * ) NULL ) clone_info = DestroyImageInfo ( clone_info ) ; ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } filepos = TellBlob ( image ) ; while ( ! EOFBlob ( image ) ) { Frames = 1 ; ( void ) SeekBlob ( image , filepos , SEEK_SET ) ; MATLAB_HDR . DataType = ReadBlobXXXLong ( image ) ; if ( EOFBlob ( image ) ) break ; MATLAB_HDR . ObjectSize = ReadBlobXXXLong ( image ) ; if ( EOFBlob ( image ) ) break ; if ( ( MagickSizeType ) ( MATLAB_HDR . ObjectSize + filepos ) > GetBlobSize ( image ) ) goto MATLAB_KO ; filepos += MATLAB_HDR . ObjectSize + 4 + 4 ; clone_info = CloneImageInfo ( image_info ) ; image2 = image ; # if defined ( MAGICKCORE_ZLIB_DELEGATE ) if ( MATLAB_HDR . DataType == miCOMPRESSED ) { image2 = decompress_block ( image , & MATLAB_HDR . ObjectSize , clone_info , exception ) ; if ( image2 == NULL ) continue ; MATLAB_HDR . DataType = ReadBlobXXXLong ( image2 ) ; } # endif if ( MATLAB_HDR . DataType != miMATRIX ) { clone_info = DestroyImageInfo ( clone_info ) ; continue ; } MATLAB_HDR . unknown1 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown2 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown5 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . StructureClass = MATLAB_HDR . unknown5 & 0xFF ; MATLAB_HDR . StructureFlag = ( MATLAB_HDR . unknown5 >> 8 ) & 0xFF ; MATLAB_HDR . unknown3 = ReadBlobXXXLong ( image2 ) ; if ( image != image2 ) MATLAB_HDR . unknown4 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown4 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . DimFlag = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . SizeX = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . SizeY = ReadBlobXXXLong ( image2 ) ; switch ( MATLAB_HDR . DimFlag ) { case 8 : z2 = z = 1 ; break ; case 12 : z2 = z = ReadBlobXXXLong ( image2 ) ; ( void ) ReadBlobXXXLong ( image2 ) ; if ( z != 3 ) ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; break ; case 16 : z2 = z = ReadBlobXXXLong ( image2 ) ; if ( z != 3 && z != 1 ) ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; Frames = ReadBlobXXXLong ( image2 ) ; if ( Frames == 0 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; break ; default : if ( clone_info != ( ImageInfo * ) NULL ) clone_info = DestroyImageInfo ( clone_info ) ; if ( ( image != image2 ) && ( image2 != ( Image * ) NULL ) ) image2 = DestroyImage ( image2 ) ; ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; } MATLAB_HDR . Flag1 = ReadBlobXXXShort ( image2 ) ; MATLAB_HDR . NameFlag = ReadBlobXXXShort ( image2 ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""MATLAB_HDR.StructureClass<S2SV_blank>%d"" , MATLAB_HDR . StructureClass ) ; if ( MATLAB_HDR . StructureClass != mxCHAR_CLASS && MATLAB_HDR . StructureClass != mxSINGLE_CLASS && MATLAB_HDR . StructureClass != mxDOUBLE_CLASS && MATLAB_HDR . StructureClass != mxINT8_CLASS && MATLAB_HDR . StructureClass != mxUINT8_CLASS && MATLAB_HDR . StructureClass != mxINT16_CLASS && MATLAB_HDR . StructureClass != mxUINT16_CLASS && MATLAB_HDR . StructureClass != mxINT32_CLASS && MATLAB_HDR . StructureClass != mxUINT32_CLASS && MATLAB_HDR . StructureClass != mxINT64_CLASS && MATLAB_HDR . StructureClass != mxUINT64_CLASS ) ThrowReaderException ( CoderError , ""UnsupportedCellTypeInTheMatrix"" ) ; switch ( MATLAB_HDR . NameFlag ) { case 0 : size = ReadBlobXXXLong ( image2 ) ; size = 4 * ( ssize_t ) ( ( size + 3 + 1 ) / 4 ) ; ( void ) SeekBlob ( image2 , size , SEEK_CUR ) ; break ; case 1 : case 2 : case 3 : case 4 : ( void ) ReadBlob ( image2 , 4 , ( unsigned char * ) & size ) ; break ; default : goto MATLAB_KO ; } CellType = ReadBlobXXXLong ( image2 ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""MATLAB_HDR.CellType:<S2SV_blank>%.20g"" , ( double ) CellType ) ; ( void ) ReadBlob ( image2 , 4 , ( unsigned char * ) & size ) ; NEXT_FRAME : switch ( CellType ) { case miINT8 : case miUINT8 : sample_size = 8 ; if ( MATLAB_HDR . StructureFlag & FLAG_LOGICAL ) image -> depth = 1 ; else image -> depth = 8 ; ldblk = ( ssize_t ) MATLAB_HDR . SizeX ; break ; case miINT16 : case miUINT16 : sample_size = 16 ; image -> depth = 16 ; ldblk = ( ssize_t ) ( 2 * MATLAB_HDR . SizeX ) ; break ; case miINT32 : case miUINT32 : sample_size = 32 ; image -> depth = 32 ; ldblk = ( ssize_t ) ( 4 * MATLAB_HDR . SizeX ) ; break ; case miINT64 : case miUINT64 : sample_size = 64 ; image -> depth = 64 ; ldblk = ( ssize_t ) ( 8 * MATLAB_HDR . SizeX ) ; break ; case miSINGLE : sample_size = 32 ; image -> depth = 32 ; ( void ) SetImageOption ( clone_info , ""quantum:format"" , ""floating-point"" ) ; if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { } ldblk = ( ssize_t ) ( 4 * MATLAB_HDR . SizeX ) ; break ; case miDOUBLE : sample_size = 64 ; image -> depth = 64 ; ( void ) SetImageOption ( clone_info , ""quantum:format"" , ""floating-point"" ) ; DisableMSCWarning ( 4127 ) if ( sizeof ( double ) != 8 ) RestoreMSCWarning ThrowReaderException ( CoderError , ""IncompatibleSizeOfDouble"" ) ; if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { } ldblk = ( ssize_t ) ( 8 * MATLAB_HDR . SizeX ) ; break ; default : if ( ( image != image2 ) && ( image2 != ( Image * ) NULL ) ) image2 = DestroyImage ( image2 ) ; if ( clone_info ) clone_info = DestroyImageInfo ( clone_info ) ; ThrowReaderException ( CoderError , ""UnsupportedCellTypeInTheMatrix"" ) ; } ( void ) sample_size ; image -> columns = MATLAB_HDR . SizeX ; image -> rows = MATLAB_HDR . SizeY ; one = 1 ; image -> colors = one << image -> depth ; if ( image -> columns == 0 || image -> rows == 0 ) goto MATLAB_KO ; if ( ( unsigned long ) ldblk * MATLAB_HDR . SizeY > MATLAB_HDR . ObjectSize ) goto MATLAB_KO ; if ( ( MATLAB_HDR . DimFlag == 8 ) && ( ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) == 0 ) ) { image -> type = GrayscaleType ; SetImageColorspace ( image , GRAYColorspace , exception ) ; } if ( image_info -> ping ) { size_t temp = image -> columns ; image -> columns = image -> rows ; image -> rows = temp ; goto done_reading ; } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) { if ( ( image != image2 ) && ( image2 != ( Image * ) NULL ) ) image2 = DestroyImage ( image2 ) ; return ( DestroyImageList ( image ) ) ; } quantum_info = AcquireQuantumInfo ( clone_info , image ) ; if ( quantum_info == ( QuantumInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; BImgBuff = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ( ldblk ) , sizeof ( double ) ) ; if ( BImgBuff == NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) ResetMagickMemory ( BImgBuff , 0 , ldblk * sizeof ( double ) ) ; MinVal = 0 ; MaxVal = 0 ; if ( CellType == miDOUBLE || CellType == miSINGLE ) { CalcMinMax ( image2 , image_info -> endian , MATLAB_HDR . SizeX , MATLAB_HDR . SizeY , CellType , ldblk , BImgBuff , & quantum_info -> minimum , & quantum_info -> maximum ) ; } if ( z == 1 ) z = 0 ; do { for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { q = GetAuthenticPixels ( image , 0 , MATLAB_HDR . SizeY - i - 1 , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>set<S2SV_blank>image<S2SV_blank>pixels<S2SV_blank>returns<S2SV_blank>unexpected<S2SV_blank>NULL<S2SV_blank>on<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u."" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto done_reading ; } if ( ReadBlob ( image2 , ldblk , ( unsigned char * ) BImgBuff ) != ( ssize_t ) ldblk ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>cannot<S2SV_blank>read<S2SV_blank>scanrow<S2SV_blank>%u<S2SV_blank>from<S2SV_blank>a<S2SV_blank>file."" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto ExitLoop ; } if ( ( CellType == miINT8 || CellType == miUINT8 ) && ( MATLAB_HDR . StructureFlag & FLAG_LOGICAL ) ) { FixLogical ( ( unsigned char * ) BImgBuff , ldblk ) ; if ( ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , z2qtype [ z ] , BImgBuff , exception ) <= 0 ) { ImportQuantumPixelsFailed : if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>ImportQuantumPixels<S2SV_blank>for<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u"" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; break ; } } else { if ( ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , z2qtype [ z ] , BImgBuff , exception ) <= 0 ) goto ImportQuantumPixelsFailed ; if ( z <= 1 && ( CellType == miINT8 || CellType == miINT16 || CellType == miINT32 || CellType == miINT64 ) ) FixSignedValues ( image , q , MATLAB_HDR . SizeX ) ; } if ( ! SyncAuthenticPixels ( image , exception ) ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>sync<S2SV_blank>image<S2SV_blank>pixels<S2SV_blank>for<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u"" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto ExitLoop ; } } } while ( z -- >= 2 ) ; ExitLoop : if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { CellType = ReadBlobXXXLong ( image2 ) ; i = ReadBlobXXXLong ( image2 ) ; if ( CellType == miDOUBLE || CellType == miSINGLE ) { CalcMinMax ( image2 , image_info -> endian , MATLAB_HDR . SizeX , MATLAB_HDR . SizeY , CellType , ldblk , BImgBuff , & MinVal , & MaxVal ) ; } if ( CellType == miDOUBLE ) for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { ReadBlobDoublesXXX ( image2 , ldblk , ( double * ) BImgBuff ) ; InsertComplexDoubleRow ( image , ( double * ) BImgBuff , i , MinVal , MaxVal , exception ) ; } if ( CellType == miSINGLE ) for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { ReadBlobFloatsXXX ( image2 , ldblk , ( float * ) BImgBuff ) ; InsertComplexFloatRow ( image , ( float * ) BImgBuff , i , MinVal , MaxVal , exception ) ; } } if ( ( MATLAB_HDR . DimFlag == 8 ) && ( ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) == 0 ) ) image -> type = GrayscaleType ; if ( image -> depth == 1 ) image -> type = BilevelType ; if ( image2 == image ) image2 = NULL ; rotated_image = RotateImage ( image , 90.0 , exception ) ; if ( rotated_image != ( Image * ) NULL ) { rotated_image -> page . x = 0 ; rotated_image -> page . y = 0 ; blob = rotated_image -> blob ; rotated_image -> blob = image -> blob ; rotated_image -> colors = image -> colors ; image -> blob = blob ; AppendImageToList ( & image , rotated_image ) ; DeleteImageFromList ( & image ) ; } done_reading : if ( image2 != NULL ) if ( image2 != image ) { DeleteImageFromList ( & image2 ) ; if ( clone_info ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } } } AcquireNextImage ( image_info , image , exception ) ; if ( image -> next == ( Image * ) NULL ) break ; image = SyncNextImageInList ( image ) ; image -> columns = image -> rows = 0 ; image -> colors = 0 ; RelinquishMagickMemory ( BImgBuff ) ; BImgBuff = NULL ; if ( -- Frames > 0 ) { z = z2 ; if ( image2 == NULL ) image2 = image ; goto NEXT_FRAME ; } if ( ( image2 != NULL ) && ( image2 != image ) ) { DeleteImageFromList ( & image2 ) ; if ( clone_info ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } } } if ( quantum_info != ( QuantumInfo * ) NULL ) quantum_info = DestroyQuantumInfo ( quantum_info ) ; if ( clone_info ) clone_info = DestroyImageInfo ( clone_info ) ; } RelinquishMagickMemory ( BImgBuff ) ; if ( quantum_info != ( QuantumInfo * ) NULL ) quantum_info = DestroyQuantumInfo ( quantum_info ) ; END_OF_READING : <S2SV_StartBug> if ( clone_info ) <S2SV_EndBug> clone_info = DestroyImageInfo ( clone_info ) ; CloseBlob ( image ) ; { Image * p ; ssize_t scene = 0 ; p = image ; image = NULL ; while ( p != ( Image * ) NULL ) { Image * tmp = p ; if ( ( p -> rows == 0 ) || ( p -> columns == 0 ) ) { p = p -> previous ; <S2SV_StartBug> DeleteImageFromList ( & tmp ) ; <S2SV_EndBug> } else { image = p ; p = p -> previous ; } } for ( p = image ; p != ( Image * ) NULL ; p = p -> next ) p -> scene = scene ++ ; } if ( clone_info != NULL ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } DestroyImageInfo ( clone_info ) ; clone_info = NULL ; } if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""return"" ) ; if ( image == NULL ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) else if ( ( image != image2 ) && ( image2 != ( Image * ) NULL ) ) image2 = DestroyImage ( image2 ) ; return ( image ) ; }",; END_OF_READING : <S2SV_ModEnd> CloseBlob ( image <S2SV_ModStart> -> previous ; if ( tmp == image2 ) image2 = ( Image * ) NULL ;
61,"static struct nfs4_state * nfs4_try_open_cached ( struct nfs4_opendata * opendata ) { struct nfs4_state * state = opendata -> state ; struct nfs_inode * nfsi = NFS_I ( state -> inode ) ; struct nfs_delegation * delegation ; <S2SV_StartBug> int open_mode = opendata -> o_arg . open_flags & ( FMODE_READ | FMODE_WRITE | O_EXCL ) ; <S2SV_EndBug> nfs4_stateid stateid ; int ret = - EAGAIN ; for ( ; ; ) { <S2SV_StartBug> if ( can_open_cached ( state , open_mode ) ) { <S2SV_EndBug> spin_lock ( & state -> owner -> so_lock ) ; <S2SV_StartBug> if ( can_open_cached ( state , open_mode ) ) { <S2SV_EndBug> <S2SV_StartBug> update_open_stateflags ( state , open_mode ) ; <S2SV_EndBug> spin_unlock ( & state -> owner -> so_lock ) ; goto out_return_state ; } spin_unlock ( & state -> owner -> so_lock ) ; } rcu_read_lock ( ) ; delegation = rcu_dereference ( nfsi -> delegation ) ; if ( delegation == NULL || <S2SV_StartBug> ! can_open_delegated ( delegation , open_mode ) ) { <S2SV_EndBug> rcu_read_unlock ( ) ; break ; } memcpy ( stateid . data , delegation -> stateid . data , sizeof ( stateid . data ) ) ; rcu_read_unlock ( ) ; ret = nfs_may_open ( state -> inode , state -> owner -> so_cred , open_mode ) ; if ( ret != 0 ) goto out ; ret = - EAGAIN ; <S2SV_StartBug> if ( update_open_stateid ( state , NULL , & stateid , open_mode ) ) <S2SV_EndBug> goto out_return_state ; } out : return ERR_PTR ( ret ) ; out_return_state : atomic_inc ( & state -> count ) ; return state ; }",". open_flags & O_EXCL ; fmode_t fmode = opendata -> o_arg . fmode <S2SV_ModEnd> ; nfs4_stateid stateid <S2SV_ModStart> ( state , fmode , <S2SV_ModStart> ( state , fmode , <S2SV_ModStart> ( state , fmode <S2SV_ModEnd> ) ; spin_unlock <S2SV_ModStart> ( delegation , fmode <S2SV_ModEnd> ) ) { <S2SV_ModStart> & stateid , fmode <S2SV_ModEnd> ) ) goto"
62,"static long do_get_mempolicy ( int * policy , nodemask_t * nmask , unsigned long addr , unsigned long flags ) { int err ; struct mm_struct * mm = current -> mm ; struct vm_area_struct * vma = NULL ; struct mempolicy * pol = current -> mempolicy ; if ( flags & ~ ( unsigned long ) ( MPOL_F_NODE | MPOL_F_ADDR | MPOL_F_MEMS_ALLOWED ) ) return - EINVAL ; if ( flags & MPOL_F_MEMS_ALLOWED ) { if ( flags & ( MPOL_F_NODE | MPOL_F_ADDR ) ) return - EINVAL ; * policy = 0 ; task_lock ( current ) ; * nmask = cpuset_current_mems_allowed ; task_unlock ( current ) ; return 0 ; } if ( flags & MPOL_F_ADDR ) { down_read ( & mm -> mmap_sem ) ; vma = find_vma_intersection ( mm , addr , addr + 1 ) ; if ( ! vma ) { up_read ( & mm -> mmap_sem ) ; return - EFAULT ; } if ( vma -> vm_ops && vma -> vm_ops -> get_policy ) pol = vma -> vm_ops -> get_policy ( vma , addr ) ; else pol = vma -> vm_policy ; } else if ( addr ) return - EINVAL ; if ( ! pol ) pol = & default_policy ; if ( flags & MPOL_F_NODE ) { if ( flags & MPOL_F_ADDR ) { err = lookup_node ( addr ) ; if ( err < 0 ) goto out ; * policy = err ; } else if ( pol == current -> mempolicy && pol -> mode == MPOL_INTERLEAVE ) { * policy = next_node_in ( current -> il_prev , pol -> v . nodes ) ; } else { err = - EINVAL ; goto out ; } } else { * policy = pol == & default_policy ? MPOL_DEFAULT : pol -> mode ; * policy |= ( pol -> flags & MPOL_MODE_FLAGS ) ; } <S2SV_StartBug> if ( vma ) { <S2SV_EndBug> up_read ( & current -> mm -> mmap_sem ) ; vma = NULL ; } err = 0 ; if ( nmask ) { if ( mpol_store_user_nodemask ( pol ) ) { * nmask = pol -> w . user_nodemask ; } else { task_lock ( current ) ; get_policy_nodemask ( pol , nmask ) ; task_unlock ( current ) ; } } out : mpol_cond_put ( pol ) ; if ( vma ) up_read ( & current -> mm -> mmap_sem ) ; return err ; }",) ; } <S2SV_ModEnd> err = 0
63,"static BOOL gdi_Bitmap_Decompress ( rdpContext * context , rdpBitmap * bitmap , const BYTE * pSrcData , UINT32 DstWidth , UINT32 DstHeight , UINT32 bpp , UINT32 length , BOOL compressed , UINT32 codecId ) { UINT32 SrcSize = length ; rdpGdi * gdi = context -> gdi ; <S2SV_StartBug> bitmap -> compressed = FALSE ; <S2SV_EndBug> bitmap -> format = gdi -> dstFormat ; <S2SV_StartBug> bitmap -> length = DstWidth * DstHeight * GetBytesPerPixel ( bitmap -> format ) ; <S2SV_EndBug> bitmap -> data = ( BYTE * ) _aligned_malloc ( bitmap -> length , 16 ) ; if ( ! bitmap -> data ) return FALSE ; if ( compressed ) { if ( bpp < 32 ) { if ( ! interleaved_decompress ( context -> codecs -> interleaved , pSrcData , SrcSize , DstWidth , DstHeight , bpp , bitmap -> data , bitmap -> format , 0 , 0 , 0 , DstWidth , DstHeight , & gdi -> palette ) ) return FALSE ; } else { if ( ! planar_decompress ( context -> codecs -> planar , pSrcData , SrcSize , DstWidth , DstHeight , bitmap -> data , bitmap -> format , 0 , 0 , 0 , DstWidth , DstHeight , TRUE ) ) return FALSE ; } } else { const UINT32 SrcFormat = gdi_get_pixel_format ( bpp ) ; const size_t sbpp = GetBytesPerPixel ( SrcFormat ) ; const size_t dbpp = GetBytesPerPixel ( bitmap -> format ) ; if ( ( sbpp == 0 ) || ( dbpp == 0 ) ) return FALSE ; else { const size_t dstSize = SrcSize * dbpp / sbpp ; if ( dstSize < bitmap -> length ) return FALSE ; } if ( ! freerdp_image_copy ( bitmap -> data , bitmap -> format , 0 , 0 , 0 , DstWidth , DstHeight , pSrcData , SrcFormat , 0 , 0 , 0 , & gdi -> palette , FREERDP_FLIP_VERTICAL ) ) return FALSE ; } return TRUE ; }",-> gdi ; UINT32 size = DstWidth * DstHeight ; <S2SV_ModStart> -> dstFormat ; if ( ( GetBytesPerPixel ( bitmap -> format ) == 0 ) || ( DstWidth == 0 ) || ( DstHeight == 0 ) || ( DstWidth > UINT32_MAX / DstHeight ) || ( size > ( UINT32_MAX / GetBytesPerPixel ( bitmap -> format ) ) ) ) return FALSE ; size *= GetBytesPerPixel ( bitmap -> format ) ; <S2SV_ModStart> -> length = size <S2SV_ModEnd> ; bitmap ->
64,"static int rc_pick_q_and_bounds_one_pass_vbr ( const VP9_COMP * cpi , int * bottom_index , int * top_index ) { const VP9_COMMON * const cm = & cpi -> common ; const RATE_CONTROL * const rc = & cpi -> rc ; <S2SV_StartBug> const VP9_CONFIG * const oxcf = & cpi -> oxcf ; <S2SV_EndBug> <S2SV_StartBug> int active_best_quality ; <S2SV_EndBug> int active_worst_quality = calc_active_worst_quality_one_pass_vbr ( cpi ) ; int q ; <S2SV_StartBug> if ( frame_is_intra_only ( cm ) ) { <S2SV_EndBug> <S2SV_StartBug> active_best_quality = rc -> best_quality ; <S2SV_EndBug> # if ! CONFIG_MULTIPLE_ARF if ( rc -> this_key_frame_forced ) { int qindex = rc -> last_boosted_qindex ; <S2SV_StartBug> double last_boosted_q = vp9_convert_qindex_to_q ( qindex ) ; <S2SV_EndBug> int delta_qindex = vp9_compute_qdelta ( rc , last_boosted_q , <S2SV_StartBug> last_boosted_q * 0.75 ) ; <S2SV_EndBug> active_best_quality = MAX ( qindex + delta_qindex , rc -> best_quality ) ; <S2SV_StartBug> } else if ( cm -> current_video_frame > 0 ) { <S2SV_EndBug> double q_adj_factor = 1.0 ; double q_val ; <S2SV_StartBug> active_best_quality = get_active_quality ( rc -> avg_frame_qindex [ KEY_FRAME ] , <S2SV_EndBug> <S2SV_StartBug> rc -> kf_boost , <S2SV_EndBug> kf_low , kf_high , kf_low_motion_minq , kf_high_motion_minq ) ; if ( ( cm -> width * cm -> height ) <= ( 352 * 288 ) ) { q_adj_factor -= 0.25 ; } <S2SV_StartBug> q_val = vp9_convert_qindex_to_q ( active_best_quality ) ; <S2SV_EndBug> active_best_quality += vp9_compute_qdelta ( rc , q_val , <S2SV_StartBug> q_val * q_adj_factor ) ; <S2SV_EndBug> } # else double current_q ; current_q = vp9_convert_qindex_to_q ( active_worst_quality ) ; active_best_quality = active_worst_quality + vp9_compute_qdelta ( rc , current_q , current_q * 0.3 ) ; # endif } else if ( ! rc -> is_src_frame_alt_ref && ( cpi -> refresh_golden_frame || cpi -> refresh_alt_ref_frame ) ) { if ( rc -> frames_since_key > 1 && rc -> avg_frame_qindex [ INTER_FRAME ] < active_worst_quality ) { q = rc -> avg_frame_qindex [ INTER_FRAME ] ; } else { q = rc -> avg_frame_qindex [ KEY_FRAME ] ; } <S2SV_StartBug> if ( oxcf -> end_usage == USAGE_CONSTRAINED_QUALITY ) { <S2SV_EndBug> <S2SV_StartBug> if ( q < cpi -> cq_target_quality ) <S2SV_EndBug> q = cpi -> cq_target_quality ; if ( rc -> frames_since_key > 1 ) { active_best_quality = get_active_quality ( q , rc -> gfu_boost , gf_low , gf_high , afq_low_motion_minq , afq_high_motion_minq ) ; } else { active_best_quality = get_active_quality ( q , rc -> gfu_boost , gf_low , gf_high , gf_low_motion_minq , gf_high_motion_minq ) ; } active_best_quality = active_best_quality * 15 / 16 ; <S2SV_StartBug> } else if ( oxcf -> end_usage == USAGE_CONSTANT_QUALITY ) { <S2SV_EndBug> if ( ! cpi -> refresh_alt_ref_frame ) { <S2SV_StartBug> active_best_quality = cpi -> cq_target_quality ; <S2SV_EndBug> } else { if ( rc -> frames_since_key > 1 ) { active_best_quality = get_active_quality ( q , rc -> gfu_boost , gf_low , gf_high , afq_low_motion_minq , afq_high_motion_minq ) ; } else { active_best_quality = get_active_quality ( q , rc -> gfu_boost , gf_low , gf_high , gf_low_motion_minq , gf_high_motion_minq ) ; } } } else { active_best_quality = get_active_quality ( q , rc -> gfu_boost , gf_low , gf_high , gf_low_motion_minq , gf_high_motion_minq ) ; } } else { <S2SV_StartBug> if ( oxcf -> end_usage == USAGE_CONSTANT_QUALITY ) { <S2SV_EndBug> active_best_quality = cpi -> cq_target_quality ; } else { if ( cm -> current_video_frame > 1 ) active_best_quality = inter_minq [ rc -> avg_frame_qindex [ INTER_FRAME ] ] ; else active_best_quality = inter_minq [ rc -> avg_frame_qindex [ KEY_FRAME ] ] ; <S2SV_StartBug> if ( ( oxcf -> end_usage == USAGE_CONSTRAINED_QUALITY ) && <S2SV_EndBug> <S2SV_StartBug> ( active_best_quality < cpi -> cq_target_quality ) ) { <S2SV_EndBug> if ( rc -> rolling_actual_bits < rc -> min_frame_bandwidth ) active_best_quality = oxcf -> cq_level ; else active_best_quality = cpi -> cq_target_quality ; } } } active_best_quality = clamp ( active_best_quality , rc -> best_quality , rc -> worst_quality ) ; active_worst_quality = clamp ( active_worst_quality , active_best_quality , rc -> worst_quality ) ; * top_index = active_worst_quality ; * bottom_index = active_best_quality ; <S2SV_StartBug> # if LIMIT_QRANGE_FOR_ALTREF_AND_KEY <S2SV_EndBug> <S2SV_StartBug> if ( cm -> frame_type == KEY_FRAME && ! rc -> this_key_frame_forced ) { <S2SV_EndBug> if ( ! ( cm -> current_video_frame == 0 ) ) <S2SV_StartBug> * top_index = ( active_worst_quality + active_best_quality * 3 ) / 4 ; <S2SV_EndBug> } else if ( ! rc -> is_src_frame_alt_ref && ( cpi -> refresh_golden_frame || cpi -> refresh_alt_ref_frame ) ) { * top_index = ( active_worst_quality + active_best_quality ) / 2 ; } # endif <S2SV_StartBug> if ( oxcf -> end_usage == USAGE_CONSTANT_QUALITY ) { <S2SV_EndBug> q = active_best_quality ; } else if ( ( cm -> frame_type == KEY_FRAME ) && rc -> this_key_frame_forced ) { q = rc -> last_boosted_qindex ; } else { q = vp9_rc_regulate_q ( cpi , rc -> this_frame_target , active_best_quality , active_worst_quality ) ; if ( q > * top_index ) { if ( rc -> this_frame_target >= rc -> max_frame_bandwidth ) * top_index = q ; else q = * top_index ; } } <S2SV_StartBug> # if CONFIG_MULTIPLE_ARF <S2SV_EndBug> if ( cpi -> multi_arf_enabled && ( cm -> frame_type != KEY_FRAME ) && cpi -> oxcf . end_usage != USAGE_CONSTANT_QUALITY ) { double new_q ; double current_q = vp9_convert_qindex_to_q ( active_worst_quality ) ; int level = cpi -> this_frame_weight ; assert ( level >= 0 ) ; new_q = current_q * ( 1.0 - ( 0.2 * ( cpi -> max_arf_level - level ) ) ) ; q = active_worst_quality + vp9_compute_qdelta ( rc , current_q , new_q ) ; * bottom_index = q ; * top_index = q ; printf ( ""frame:%d<S2SV_blank>q:%d\\n"" , cm -> current_video_frame , q ) ; } # endif assert ( * top_index <= rc -> worst_quality && * top_index >= rc -> best_quality ) ; assert ( * bottom_index <= rc -> worst_quality && * bottom_index >= rc -> best_quality ) ; assert ( q <= rc -> worst_quality && q >= rc -> best_quality ) ; return q ; }","rc ; const VP9EncoderConfig <S2SV_ModEnd> * const oxcf <S2SV_ModStart> -> oxcf ; const int cq_level = get_active_cq_level ( rc , oxcf ) ; <S2SV_ModStart> int q ; int * inter_minq ; ASSIGN_MINQ_TABLE ( cm -> bit_depth , inter_minq ) ; <S2SV_ModStart> ) ) { <S2SV_ModEnd> if ( rc <S2SV_ModStart> vp9_convert_qindex_to_q ( qindex , cm -> bit_depth <S2SV_ModStart> last_boosted_q * 0.75 , cm -> bit_depth <S2SV_ModStart> ; } else <S2SV_ModEnd> { double q_adj_factor <S2SV_ModStart> ; active_best_quality = get_kf_active_quality ( rc , <S2SV_ModEnd> rc -> avg_frame_qindex <S2SV_ModStart> KEY_FRAME ] , cm -> bit_depth <S2SV_ModEnd> ) ; if <S2SV_ModStart> vp9_convert_qindex_to_q ( active_best_quality , cm -> bit_depth <S2SV_ModStart> q_val * q_adj_factor , cm -> bit_depth ) ; } <S2SV_ModEnd> } else if <S2SV_ModStart> ( oxcf -> rc_mode == VPX_CQ <S2SV_ModEnd> ) { if <S2SV_ModStart> ( q < cq_level ) q = cq_level ; active_best_quality = get_gf_active_quality ( rc , q , cm -> bit_depth ) ; <S2SV_ModEnd> active_best_quality = active_best_quality <S2SV_ModStart> ( oxcf -> rc_mode == VPX_Q <S2SV_ModEnd> ) { if <S2SV_ModStart> { active_best_quality = cq_level ; } else { active_best_quality = get_gf_active_quality ( rc , q , cm -> bit_depth ) ; } } else { active_best_quality = get_gf_active_quality ( rc , q , cm -> bit_depth <S2SV_ModEnd> ) ; } <S2SV_ModStart> ( oxcf -> rc_mode == VPX_Q ) { active_best_quality = cq_level <S2SV_ModEnd> ; } else <S2SV_ModStart> ( oxcf -> rc_mode == VPX_CQ <S2SV_ModEnd> ) && ( <S2SV_ModStart> ( active_best_quality < cq_level ) ) { active_best_quality = cq_level <S2SV_ModEnd> ; } } <S2SV_ModStart> # if LIMIT_QRANGE_FOR_ALTREF_AND_KEY { int qdelta = 0 ; vpx_clear_system_state ( ) ; <S2SV_ModStart> rc -> this_key_frame_forced && <S2SV_ModEnd> ! ( cm <S2SV_ModStart> 0 ) ) { qdelta = vp9_compute_qdelta_by_rate ( & cpi -> rc , cm -> frame_type , active_worst_quality , 2.0 , cm -> bit_depth ) ; } else if ( ! rc -> is_src_frame_alt_ref && ( cpi -> refresh_golden_frame || cpi -> refresh_alt_ref_frame ) ) { qdelta = vp9_compute_qdelta_by_rate ( & cpi -> rc , cm -> frame_type , active_worst_quality , 1.75 , cm -> bit_depth ) ; } * top_index = active_worst_quality + qdelta ; * top_index = ( * top_index > * bottom_index ) ? * top_index : * bottom_index <S2SV_ModEnd> ; } # <S2SV_ModStart> ( oxcf -> rc_mode == VPX_Q <S2SV_ModEnd> ) { q <S2SV_ModStart> ; } } <S2SV_ModEnd> assert ( *"
65,"void mp_encode_lua_table_as_array ( lua_State * L , mp_buf * buf , int level ) { # if LUA_VERSION_NUM < 502 size_t len = lua_objlen ( L , - 1 ) , j ; # else size_t len = lua_rawlen ( L , - 1 ) , j ; # endif mp_encode_array ( L , buf , len ) ; <S2SV_StartBug> for ( j = 1 ; j <= len ; j ++ ) { <S2SV_EndBug> lua_pushnumber ( L , j ) ; lua_gettable ( L , - 2 ) ; mp_encode_lua_type ( L , buf , level + 1 ) ; } }","len ) ; luaL_checkstack ( L , 1 , ""in<S2SV_blank>function<S2SV_blank>mp_encode_lua_table_as_array"" ) ;"
66,"static guint32 parse_wbxml_tag ( proto_tree * tree , tvbuff_t * tvb , guint32 offset , guint32 str_tbl , guint8 * level , guint8 * codepage_stag , guint8 * codepage_attr ) { guint32 tvb_len = tvb_reported_length ( tvb ) ; <S2SV_StartBug> guint32 off = offset ; <S2SV_EndBug> guint32 len ; guint str_len ; guint32 ent ; guint32 idx ; guint8 peek ; guint32 tag_len ; guint8 tag_save_known = 0 ; guint8 tag_new_known = 0 ; const char * tag_save_literal ; const char * tag_new_literal ; char * tag_save_buf = NULL ; char * tag_new_buf = NULL ; guint8 parsing_tag_content = FALSE ; tag_save_literal = NULL ; <S2SV_StartBug> DebugLog ( ( ""parse_wbxml_tag<S2SV_blank>(level<S2SV_blank>=<S2SV_blank>%u,<S2SV_blank>offset<S2SV_blank>=<S2SV_blank>%u)\\n"" , * level , offset ) ) ; <S2SV_EndBug> while ( off < tvb_len ) { peek = tvb_get_guint8 ( tvb , off ) ; DebugLog ( ( ""STAG:<S2SV_blank>(top<S2SV_blank>of<S2SV_blank>while)<S2SV_blank>level<S2SV_blank>=<S2SV_blank>%3u,<S2SV_blank>peek<S2SV_blank>=<S2SV_blank>0x%02X,<S2SV_blank>off<S2SV_blank>=<S2SV_blank>%u,<S2SV_blank>tvb_len<S2SV_blank>=<S2SV_blank>%u\\n"" , * level , peek , off , tvb_len ) ) ; if ( ( peek & 0x3F ) < 4 ) switch ( peek ) { case 0x00 : * codepage_stag = tvb_get_guint8 ( tvb , off + 1 ) ; proto_tree_add_text ( tree , tvb , off , 2 , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>|<S2SV_blank>Tag<S2SV_blank><S2SV_blank><S2SV_blank>|<S2SV_blank>T<S2SV_blank>-->%3d<S2SV_blank>"" ""|<S2SV_blank>SWITCH_PAGE<S2SV_blank>(Tag<S2SV_blank>code<S2SV_blank>page)<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|"" , * codepage_stag ) ; off += 2 ; break ; case 0x01 : if ( tag_save_known ) { proto_tree_add_text ( tree , tvb , off , 1 , ""<S2SV_blank><S2SV_blank>%3d<S2SV_blank>|<S2SV_blank>Tag<S2SV_blank><S2SV_blank><S2SV_blank>|<S2SV_blank>T<S2SV_blank>%3d<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank>END<S2SV_blank>(Known<S2SV_blank>Tag<S2SV_blank>0x%02X)<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank>%s</%s>"" , * level , * codepage_stag , tag_save_known , Indent ( * level ) , tag_save_literal ) ; } else { proto_tree_add_text ( tree , tvb , off , 1 , ""<S2SV_blank><S2SV_blank>%3d<S2SV_blank>|<S2SV_blank>Tag<S2SV_blank><S2SV_blank><S2SV_blank>|<S2SV_blank>T<S2SV_blank>%3d<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank>END<S2SV_blank>(Literal<S2SV_blank>Tag)<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank>%s</%s>"" , * level , * codepage_stag , Indent ( * level ) , tag_save_literal ? tag_save_literal : """" ) ; } ( * level ) -- ; off ++ ; DebugLog ( ( ""STAG:<S2SV_blank>level<S2SV_blank>=<S2SV_blank>%u,<S2SV_blank>Return:<S2SV_blank>len<S2SV_blank>=<S2SV_blank>%u\\n"" , * level , off - offset ) ) ; return ( off - offset ) ; case 0x02 : ent = tvb_get_guintvar ( tvb , off + 1 , & len ) ; proto_tree_add_text ( tree , tvb , off , 1 + len , ""<S2SV_blank><S2SV_blank>%3d<S2SV_blank>|<S2SV_blank>Tag<S2SV_blank><S2SV_blank><S2SV_blank>|<S2SV_blank>T<S2SV_blank>%3d<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank>ENTITY<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank>%s\'&#%u;\'"" , * level , * codepage_stag , Indent ( * level ) , ent ) ; off += 1 + len ; break ; case 0x03 : len = tvb_strsize ( tvb , off + 1 ) ; proto_tree_add_text ( tree , tvb , off , 1 + len , ""<S2SV_blank><S2SV_blank>%3d<S2SV_blank>|<S2SV_blank>Tag<S2SV_blank><S2SV_blank><S2SV_blank>|<S2SV_blank>T<S2SV_blank>%3d<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank>STR_I<S2SV_blank>(Inline<S2SV_blank>string)<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank>%s\\\'%s\\\'"" , * level , * codepage_stag , Indent ( * level ) , tvb_format_text ( tvb , off + 1 , len - 1 ) ) ; off += 1 + len ; break ; case 0x40 : case 0x41 : case 0x42 : len = tvb_strsize ( tvb , off + 1 ) ; proto_tree_add_text ( tree , tvb , off , 1 + len , ""<S2SV_blank><S2SV_blank>%3d<S2SV_blank>|<S2SV_blank>Tag<S2SV_blank><S2SV_blank><S2SV_blank>|<S2SV_blank>T<S2SV_blank>%3d<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank>EXT_I_%1x<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(Extension<S2SV_blank>Token)<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank>%s(Inline<S2SV_blank>string<S2SV_blank>extension:<S2SV_blank>\\\'%s\\\')"" , * level , * codepage_stag , peek & 0x0f , Indent ( * level ) , tvb_format_text ( tvb , off + 1 , len - 1 ) ) ; off += 1 + len ; break ; case 0x43 : proto_tree_add_text ( tree , tvb , off , 1 , ""<S2SV_blank><S2SV_blank>%3d<S2SV_blank>|<S2SV_blank>Tag<S2SV_blank><S2SV_blank><S2SV_blank>|<S2SV_blank>T<S2SV_blank>%3d<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank>PI<S2SV_blank>(XML<S2SV_blank>Processing<S2SV_blank>Instruction)<S2SV_blank>"" ""|<S2SV_blank>%s<?xml"" , * level , * codepage_stag , Indent ( * level ) ) ; len = parse_wbxml_attribute_list ( tree , tvb , off , str_tbl , * level , codepage_attr ) ; off += len ; if ( off >= tvb_len ) { DebugLog ( ( ""STAG:<S2SV_blank>level<S2SV_blank>=<S2SV_blank>%u,<S2SV_blank>ThrowException:<S2SV_blank>len<S2SV_blank>=<S2SV_blank>%u<S2SV_blank>(short<S2SV_blank>frame)\\n"" , * level , off - offset ) ) ; THROW ( ReportedBoundsError ) ; } proto_tree_add_text ( tree , tvb , off - 1 , 1 , ""<S2SV_blank><S2SV_blank>%3d<S2SV_blank>|<S2SV_blank>Tag<S2SV_blank><S2SV_blank><S2SV_blank>|<S2SV_blank>T<S2SV_blank>%3d<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank>END<S2SV_blank>(PI)<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank>%s?>"" , * level , * codepage_stag , Indent ( * level ) ) ; break ; case 0x80 : case 0x81 : case 0x82 : idx = tvb_get_guintvar ( tvb , off + 1 , & len ) ; proto_tree_add_text ( tree , tvb , off , 1 + len , ""<S2SV_blank><S2SV_blank>%3d<S2SV_blank>|<S2SV_blank>Tag<S2SV_blank><S2SV_blank><S2SV_blank>|<S2SV_blank>T<S2SV_blank>%3d<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank>EXT_T_%1x<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(Extension<S2SV_blank>Token)<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank>%s(Extension<S2SV_blank>Token,<S2SV_blank>integer<S2SV_blank>value:<S2SV_blank>%u)"" , * level , * codepage_stag , peek & 0x0f , Indent ( * level ) , idx ) ; off += 1 + len ; break ; case 0x83 : idx = tvb_get_guintvar ( tvb , off + 1 , & len ) ; str_len = tvb_strsize ( tvb , str_tbl + idx ) ; proto_tree_add_text ( tree , tvb , off , 1 + len , ""<S2SV_blank><S2SV_blank>%3d<S2SV_blank>|<S2SV_blank>Tag<S2SV_blank><S2SV_blank><S2SV_blank>|<S2SV_blank>T<S2SV_blank>%3d<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank>STR_T<S2SV_blank>(Tableref<S2SV_blank>string)<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank>%s\\\'%s\\\'"" , * level , * codepage_stag , Indent ( * level ) , tvb_format_text ( tvb , str_tbl + idx , str_len - 1 ) ) ; off += 1 + len ; break ; case 0xC0 : case 0xC1 : case 0xC2 : proto_tree_add_text ( tree , tvb , off , 1 , ""<S2SV_blank><S2SV_blank>%3d<S2SV_blank>|<S2SV_blank>Tag<S2SV_blank><S2SV_blank><S2SV_blank>|<S2SV_blank>T<S2SV_blank>%3d<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank>EXT_%1x<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(Extension<S2SV_blank>Token)<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank>%s(Single-byte<S2SV_blank>extension)"" , * level , * codepage_stag , peek & 0x0f , Indent ( * level ) ) ; off ++ ; break ; case 0xC3 : if ( tvb_get_guint8 ( tvb , 0 ) ) { idx = tvb_get_guintvar ( tvb , off + 1 , & len ) ; proto_tree_add_text ( tree , tvb , off , 1 + len + idx , ""<S2SV_blank><S2SV_blank>%3d<S2SV_blank>|<S2SV_blank>Tag<S2SV_blank><S2SV_blank><S2SV_blank>|<S2SV_blank>T<S2SV_blank>%3d<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank>OPAQUE<S2SV_blank>(Opaque<S2SV_blank>data)<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank>%s(%d<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>opaque<S2SV_blank>data)"" , * level , * codepage_stag , Indent ( * level ) , idx ) ; off += 1 + len + idx ; } else { proto_tree_add_text ( tree , tvb , off , 1 , ""<S2SV_blank><S2SV_blank>%3d<S2SV_blank>|<S2SV_blank>Tag<S2SV_blank><S2SV_blank><S2SV_blank>|<S2SV_blank>T<S2SV_blank>%3d<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank>RESERVED_2<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(Invalid<S2SV_blank>Token!)<S2SV_blank>"" ""|<S2SV_blank>WBXML<S2SV_blank>1.0<S2SV_blank>parsing<S2SV_blank>stops<S2SV_blank>here."" , * level , * codepage_stag ) ; off = tvb_len ; DebugLog ( ( ""STAG:<S2SV_blank>level<S2SV_blank>=<S2SV_blank>%u,<S2SV_blank>Return:<S2SV_blank>len<S2SV_blank>=<S2SV_blank>%u\\n"" , * level , off - offset ) ) ; return ( off - offset ) ; } break ; } else { tag_len = 0 ; if ( ( peek & 0x3F ) == 4 ) { DebugLog ( ( ""STAG:<S2SV_blank>LITERAL<S2SV_blank>tag<S2SV_blank>(peek<S2SV_blank>=<S2SV_blank>0x%02X,<S2SV_blank>off<S2SV_blank>=<S2SV_blank>%u)"" ""<S2SV_blank>-<S2SV_blank>TableRef<S2SV_blank>follows!\\n"" , peek , off ) ) ; idx = tvb_get_guintvar ( tvb , off + 1 , & tag_len ) ; str_len = tvb_strsize ( tvb , str_tbl + idx ) ; tag_new_literal = ( const gchar * ) tvb_get_ptr ( tvb , str_tbl + idx , str_len ) ; tag_new_known = 0 ; } else { tag_new_known = peek & 0x3F ; tag_new_buf = wmem_strdup_printf ( wmem_packet_scope ( ) , ""Tag_0x%02X"" , tag_new_known ) ; tag_new_literal = tag_new_buf ; } if ( peek & 0x40 ) { if ( parsing_tag_content ) { DebugLog ( ( ""STAG:<S2SV_blank>Tag<S2SV_blank>in<S2SV_blank>Tag<S2SV_blank>-<S2SV_blank>RECURSE!<S2SV_blank>(off<S2SV_blank>=<S2SV_blank>%u)\\n"" , off ) ) ; ( * level ) ++ ; len = parse_wbxml_tag ( tree , tvb , off , str_tbl , level , codepage_stag , codepage_attr ) ; off += len ; } else { if ( ( peek & 0x3F ) == 4 ) { tag_save_literal = tag_new_literal ; tag_save_known = 0 ; } else { tag_save_known = tag_new_known ; tag_save_buf = wmem_strdup_printf ( wmem_packet_scope ( ) , ""Tag_0x%02X"" , tag_new_known ) ; tag_save_literal = tag_save_buf ; } if ( peek & 0x80 ) { if ( tag_new_known ) { proto_tree_add_text ( tree , tvb , off , 1 , ""<S2SV_blank><S2SV_blank>%3d<S2SV_blank>|<S2SV_blank>Tag<S2SV_blank><S2SV_blank><S2SV_blank>|<S2SV_blank>T<S2SV_blank>%3d<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank><S2SV_blank><S2SV_blank>Known<S2SV_blank>Tag<S2SV_blank>0x%02X<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(AC)<S2SV_blank>"" ""|<S2SV_blank>%s<%s"" , * level , * codepage_stag , tag_new_known , Indent ( * level ) , tag_new_literal ) ; off ++ ; } else { proto_tree_add_text ( tree , tvb , off , 1 , ""<S2SV_blank><S2SV_blank>%3d<S2SV_blank>|<S2SV_blank>Tag<S2SV_blank><S2SV_blank><S2SV_blank>|<S2SV_blank>T<S2SV_blank>%3d<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank>LITERAL_AC<S2SV_blank>(Literal<S2SV_blank>tag)<S2SV_blank><S2SV_blank><S2SV_blank>(AC)<S2SV_blank>"" ""|<S2SV_blank>%s<%s"" , * level , * codepage_stag , Indent ( * level ) , tag_new_literal ) ; off += 1 + tag_len ; } len = parse_wbxml_attribute_list ( tree , tvb , off , str_tbl , * level , codepage_attr ) ; off += len ; if ( off >= tvb_len ) { DebugLog ( ( ""STAG:<S2SV_blank>level<S2SV_blank>=<S2SV_blank>%u,<S2SV_blank>ThrowException:<S2SV_blank>"" ""len<S2SV_blank>=<S2SV_blank>%u<S2SV_blank>(short<S2SV_blank>frame)\\n"" , * level , off - offset ) ) ; THROW ( ReportedBoundsError ) ; } proto_tree_add_text ( tree , tvb , off - 1 , 1 , ""<S2SV_blank><S2SV_blank>%3d<S2SV_blank>|<S2SV_blank>Tag<S2SV_blank><S2SV_blank><S2SV_blank>|<S2SV_blank>T<S2SV_blank>%3d<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank>END<S2SV_blank>(attribute<S2SV_blank>list)<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank>%s>"" , * level , * codepage_stag , Indent ( * level ) ) ; } else { if ( tag_new_known ) { proto_tree_add_text ( tree , tvb , off , 1 , ""<S2SV_blank><S2SV_blank>%3d<S2SV_blank>|<S2SV_blank>Tag<S2SV_blank><S2SV_blank><S2SV_blank>|<S2SV_blank>T<S2SV_blank>%3d<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank><S2SV_blank><S2SV_blank>Known<S2SV_blank>Tag<S2SV_blank>0x%02X<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(.C)<S2SV_blank>"" ""|<S2SV_blank>%s<%s>"" , * level , * codepage_stag , tag_new_known , Indent ( * level ) , tag_new_literal ) ; off ++ ; } else { proto_tree_add_text ( tree , tvb , off , 1 , ""<S2SV_blank><S2SV_blank>%3d<S2SV_blank>|<S2SV_blank>Tag<S2SV_blank><S2SV_blank><S2SV_blank>|<S2SV_blank>T<S2SV_blank>%3d<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank>LITERAL_C<S2SV_blank><S2SV_blank>(Literal<S2SV_blank>Tag)<S2SV_blank><S2SV_blank><S2SV_blank>(.C)<S2SV_blank>"" ""|<S2SV_blank>%s<%s>"" , * level , * codepage_stag , Indent ( * level ) , tag_new_literal ) ; off += 1 + tag_len ; } } parsing_tag_content = TRUE ; DebugLog ( ( ""Tag<S2SV_blank>in<S2SV_blank>Tag<S2SV_blank>-<S2SV_blank>No<S2SV_blank>recursion<S2SV_blank>this<S2SV_blank>time!<S2SV_blank>"" ""(off<S2SV_blank>=<S2SV_blank>%u)\\n"" , off ) ) ; } } else { DebugLog ( ( ""<Tag/><S2SV_blank>in<S2SV_blank>Tag<S2SV_blank>-<S2SV_blank>No<S2SV_blank>recursion!<S2SV_blank>(off<S2SV_blank>=<S2SV_blank>%u)\\n"" , off ) ) ; ( * level ) ++ ; if ( peek & 0x80 ) { if ( tag_new_known ) { proto_tree_add_text ( tree , tvb , off , 1 , ""<S2SV_blank><S2SV_blank>%3d<S2SV_blank>|<S2SV_blank>Tag<S2SV_blank><S2SV_blank><S2SV_blank>|<S2SV_blank>T<S2SV_blank>%3d<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank><S2SV_blank><S2SV_blank>Known<S2SV_blank>Tag<S2SV_blank>0x%02X<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(A.)<S2SV_blank>"" ""|<S2SV_blank>%s<%s"" , * level , * codepage_stag , tag_new_known , Indent ( * level ) , tag_new_literal ) ; off ++ ; len = parse_wbxml_attribute_list ( tree , tvb , off , str_tbl , * level , codepage_attr ) ; off += len ; if ( off >= tvb_len ) { DebugLog ( ( ""STAG:<S2SV_blank>level<S2SV_blank>=<S2SV_blank>%u,<S2SV_blank>ThrowException:<S2SV_blank>"" ""len<S2SV_blank>=<S2SV_blank>%u<S2SV_blank>(short<S2SV_blank>frame)\\n"" , * level , off - offset ) ) ; THROW ( ReportedBoundsError ) ; } proto_tree_add_text ( tree , tvb , off - 1 , 1 , ""<S2SV_blank><S2SV_blank>%3d<S2SV_blank>|<S2SV_blank>Tag<S2SV_blank><S2SV_blank><S2SV_blank>|<S2SV_blank>T<S2SV_blank>%3d<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank>END<S2SV_blank>(Known<S2SV_blank>Tag)<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank>%s/>"" , * level , * codepage_stag , Indent ( * level ) ) ; } else { proto_tree_add_text ( tree , tvb , off , 1 , ""<S2SV_blank><S2SV_blank>%3d<S2SV_blank>|<S2SV_blank>Tag<S2SV_blank><S2SV_blank><S2SV_blank>|<S2SV_blank>T<S2SV_blank>%3d<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank>LITERAL_A<S2SV_blank><S2SV_blank>(Literal<S2SV_blank>Tag)<S2SV_blank><S2SV_blank><S2SV_blank>(A.)<S2SV_blank>"" ""|<S2SV_blank>%s<%s"" , * level , * codepage_stag , Indent ( * level ) , tag_new_literal ) ; off += 1 + tag_len ; len = parse_wbxml_attribute_list ( tree , tvb , off , str_tbl , * level , codepage_attr ) ; off += len ; if ( off >= tvb_len ) { DebugLog ( ( ""STAG:<S2SV_blank>level<S2SV_blank>=<S2SV_blank>%u,<S2SV_blank>ThrowException:<S2SV_blank>"" ""len<S2SV_blank>=<S2SV_blank>%u<S2SV_blank>(short<S2SV_blank>frame)\\n"" , * level , off - offset ) ) ; THROW ( ReportedBoundsError ) ; } proto_tree_add_text ( tree , tvb , off - 1 , 1 , ""<S2SV_blank><S2SV_blank>%3d<S2SV_blank>|<S2SV_blank>Tag<S2SV_blank><S2SV_blank><S2SV_blank>|<S2SV_blank>T<S2SV_blank>%3d<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank>END<S2SV_blank>(Literal<S2SV_blank>Tag)<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank>%s/>"" , * level , * codepage_stag , Indent ( * level ) ) ; } } else { if ( tag_new_known ) { proto_tree_add_text ( tree , tvb , off , 1 , ""<S2SV_blank><S2SV_blank>%3d<S2SV_blank>|<S2SV_blank>Tag<S2SV_blank><S2SV_blank><S2SV_blank>|<S2SV_blank>T<S2SV_blank>%3d<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank><S2SV_blank><S2SV_blank>Known<S2SV_blank>Tag<S2SV_blank>0x%02x<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(..)<S2SV_blank>"" ""|<S2SV_blank>%s<%s<S2SV_blank>/>"" , * level , * codepage_stag , tag_new_known , Indent ( * level ) , tag_new_literal ) ; off ++ ; } else { proto_tree_add_text ( tree , tvb , off , 1 , ""<S2SV_blank><S2SV_blank>%3d<S2SV_blank>|<S2SV_blank>Tag<S2SV_blank><S2SV_blank><S2SV_blank>|<S2SV_blank>T<S2SV_blank>%3d<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank>LITERAL<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(Literal<S2SV_blank>Tag)<S2SV_blank><S2SV_blank><S2SV_blank>(..)<S2SV_blank>"" ""|<S2SV_blank>%s<%s<S2SV_blank>/>"" , * level , * codepage_stag , Indent ( * level ) , tag_new_literal ) ; off += 1 + tag_len ; } } ( * level ) -- ; } } <S2SV_StartBug> } <S2SV_EndBug> DebugLog ( ( ""STAG:<S2SV_blank>level<S2SV_blank>=<S2SV_blank>%u,<S2SV_blank>Return:<S2SV_blank>len<S2SV_blank>=<S2SV_blank>%u<S2SV_blank>(end<S2SV_blank>of<S2SV_blank>function<S2SV_blank>body)\\n"" , * level , off - offset ) ) ; return ( off - offset ) ; }","off = offset , last_off <S2SV_ModStart> offset ) ) ; last_off = off <S2SV_ModStart> ; } } if ( off < last_off ) { THROW ( ReportedBoundsError ) ; } last_off = off ;"
67,"static PyObject * get_value ( PyObject * self , const char * buffer , int * position , int type , int max , PyObject * as_class , unsigned char tz_aware , unsigned char uuid_subtype ) { struct module_state * state = GETSTATE ( self ) ; PyObject * value ; PyObject * error ; switch ( type ) { case 1 : { double d ; if ( max < 8 ) { goto invalid ; } memcpy ( & d , buffer + * position , 8 ) ; value = PyFloat_FromDouble ( d ) ; if ( ! value ) { return NULL ; } * position += 8 ; break ; } case 2 : case 14 : { int value_length = ( ( int * ) ( buffer + * position ) ) [ 0 ] - 1 ; if ( max < value_length ) { goto invalid ; } * position += 4 ; value = PyUnicode_DecodeUTF8 ( buffer + * position , value_length , ""strict"" ) ; if ( ! value ) { return NULL ; } * position += value_length + 1 ; break ; } case 3 : { int size ; memcpy ( & size , buffer + * position , 4 ) ; if ( max < size ) { goto invalid ; } value = elements_to_dict ( self , buffer + * position + 4 , size - 5 , as_class , tz_aware , uuid_subtype ) ; if ( ! value ) { return NULL ; } if ( strcmp ( buffer + * position + 5 , ""$ref"" ) == 0 ) { PyObject * dbref ; PyObject * collection = PyDict_GetItemString ( value , ""$ref"" ) ; PyObject * id = PyDict_GetItemString ( value , ""$id"" ) ; PyObject * database = PyDict_GetItemString ( value , ""$db"" ) ; Py_INCREF ( collection ) ; PyDict_DelItemString ( value , ""$ref"" ) ; <S2SV_StartBug> Py_INCREF ( id ) ; <S2SV_EndBug> <S2SV_StartBug> PyDict_DelItemString ( value , ""$id"" ) ; <S2SV_EndBug> if ( database == NULL ) { database = Py_None ; Py_INCREF ( database ) ; } else { Py_INCREF ( database ) ; PyDict_DelItemString ( value , ""$db"" ) ; } dbref = PyObject_CallFunctionObjArgs ( state -> DBRef , collection , id , database , value , NULL ) ; Py_DECREF ( value ) ; value = dbref ; Py_DECREF ( id ) ; Py_DECREF ( collection ) ; Py_DECREF ( database ) ; if ( ! value ) { return NULL ; } } * position += size ; break ; } case 4 : { int size , end ; memcpy ( & size , buffer + * position , 4 ) ; if ( max < size ) { goto invalid ; } end = * position + size - 1 ; * position += 4 ; value = PyList_New ( 0 ) ; if ( ! value ) { return NULL ; } while ( * position < end ) { PyObject * to_append ; int type = ( int ) buffer [ ( * position ) ++ ] ; int key_size = strlen ( buffer + * position ) ; * position += key_size + 1 ; to_append = get_value ( self , buffer , position , type , max - key_size , as_class , tz_aware , uuid_subtype ) ; if ( ! to_append ) { Py_DECREF ( value ) ; return NULL ; } PyList_Append ( value , to_append ) ; Py_DECREF ( to_append ) ; } ( * position ) ++ ; break ; } case 5 : { PyObject * data ; PyObject * st ; int length , subtype ; memcpy ( & length , buffer + * position , 4 ) ; if ( max < length ) { goto invalid ; } subtype = ( unsigned char ) buffer [ * position + 4 ] ; # if PY_MAJOR_VERSION >= 3 if ( subtype == 0 ) { value = PyBytes_FromStringAndSize ( buffer + * position + 5 , length ) ; * position += length + 5 ; break ; } if ( subtype == 2 ) { data = PyBytes_FromStringAndSize ( buffer + * position + 9 , length - 4 ) ; } else { data = PyBytes_FromStringAndSize ( buffer + * position + 5 , length ) ; } # else if ( subtype == 2 ) { data = PyString_FromStringAndSize ( buffer + * position + 9 , length - 4 ) ; } else { data = PyString_FromStringAndSize ( buffer + * position + 5 , length ) ; } # endif if ( ! data ) { return NULL ; } if ( ( subtype == 3 || subtype == 4 ) && state -> UUID ) { PyObject * kwargs ; PyObject * args = PyTuple_New ( 0 ) ; if ( ! args ) { Py_DECREF ( data ) ; return NULL ; } kwargs = PyDict_New ( ) ; if ( ! kwargs ) { Py_DECREF ( data ) ; Py_DECREF ( args ) ; return NULL ; } assert ( length == 16 ) ; if ( uuid_subtype == CSHARP_LEGACY ) { PyDict_SetItemString ( kwargs , ""bytes_le"" , data ) ; } else { if ( uuid_subtype == JAVA_LEGACY ) { char big_endian [ 16 ] ; _fix_java ( buffer + * position + 5 , big_endian ) ; Py_DECREF ( data ) ; # if PY_MAJOR_VERSION >= 3 data = PyBytes_FromStringAndSize ( big_endian , length ) ; # else data = PyString_FromStringAndSize ( big_endian , length ) ; # endif } PyDict_SetItemString ( kwargs , ""bytes"" , data ) ; } value = PyObject_Call ( state -> UUID , args , kwargs ) ; Py_DECREF ( args ) ; Py_DECREF ( kwargs ) ; Py_DECREF ( data ) ; if ( ! value ) { return NULL ; } * position += length + 5 ; break ; } # if PY_MAJOR_VERSION >= 3 st = PyLong_FromLong ( subtype ) ; # else st = PyInt_FromLong ( subtype ) ; # endif if ( ! st ) { Py_DECREF ( data ) ; return NULL ; } value = PyObject_CallFunctionObjArgs ( state -> Binary , data , st , NULL ) ; Py_DECREF ( st ) ; Py_DECREF ( data ) ; if ( ! value ) { return NULL ; } * position += length + 5 ; break ; } case 6 : case 10 : { value = Py_None ; Py_INCREF ( value ) ; break ; } case 7 : { if ( max < 12 ) { goto invalid ; } # if PY_MAJOR_VERSION >= 3 value = PyObject_CallFunction ( state -> ObjectId , ""y#"" , buffer + * position , 12 ) ; # else value = PyObject_CallFunction ( state -> ObjectId , ""s#"" , buffer + * position , 12 ) ; # endif if ( ! value ) { return NULL ; } * position += 12 ; break ; } case 8 : { value = buffer [ ( * position ) ++ ] ? Py_True : Py_False ; Py_INCREF ( value ) ; break ; } case 9 : { PyObject * naive ; PyObject * replace ; PyObject * args ; PyObject * kwargs ; if ( max < 8 ) { goto invalid ; } naive = datetime_from_millis ( * ( long long * ) ( buffer + * position ) ) ; * position += 8 ; if ( ! tz_aware ) { value = naive ; break ; } if ( ! naive ) { return NULL ; } replace = PyObject_GetAttrString ( naive , ""replace"" ) ; Py_DECREF ( naive ) ; if ( ! replace ) { return NULL ; } args = PyTuple_New ( 0 ) ; if ( ! args ) { Py_DECREF ( replace ) ; return NULL ; } kwargs = PyDict_New ( ) ; if ( ! kwargs ) { Py_DECREF ( replace ) ; Py_DECREF ( args ) ; return NULL ; } if ( PyDict_SetItemString ( kwargs , ""tzinfo"" , state -> UTC ) == - 1 ) { Py_DECREF ( replace ) ; Py_DECREF ( args ) ; Py_DECREF ( kwargs ) ; return NULL ; } value = PyObject_Call ( replace , args , kwargs ) ; Py_DECREF ( replace ) ; Py_DECREF ( args ) ; Py_DECREF ( kwargs ) ; break ; } case 11 : { PyObject * pattern ; int flags_length , flags , i ; int pattern_length = strlen ( buffer + * position ) ; if ( max < pattern_length ) { goto invalid ; } pattern = PyUnicode_DecodeUTF8 ( buffer + * position , pattern_length , ""strict"" ) ; if ( ! pattern ) { return NULL ; } * position += pattern_length + 1 ; flags_length = strlen ( buffer + * position ) ; if ( max < pattern_length + flags_length ) { Py_DECREF ( pattern ) ; goto invalid ; } flags = 0 ; for ( i = 0 ; i < flags_length ; i ++ ) { if ( buffer [ * position + i ] == 'i' ) { flags |= 2 ; } else if ( buffer [ * position + i ] == 'l' ) { flags |= 4 ; } else if ( buffer [ * position + i ] == 'm' ) { flags |= 8 ; } else if ( buffer [ * position + i ] == 's' ) { flags |= 16 ; } else if ( buffer [ * position + i ] == 'u' ) { flags |= 32 ; } else if ( buffer [ * position + i ] == 'x' ) { flags |= 64 ; } } * position += flags_length + 1 ; value = PyObject_CallFunction ( state -> RECompile , ""Oi"" , pattern , flags ) ; Py_DECREF ( pattern ) ; break ; } case 12 : { int collection_length ; PyObject * collection ; PyObject * id ; * position += 4 ; collection_length = strlen ( buffer + * position ) ; if ( max < collection_length ) { goto invalid ; } collection = PyUnicode_DecodeUTF8 ( buffer + * position , collection_length , ""strict"" ) ; if ( ! collection ) { return NULL ; } * position += collection_length + 1 ; if ( max < collection_length + 12 ) { Py_DECREF ( collection ) ; goto invalid ; } id = PyObject_CallFunction ( state -> ObjectId , ""s#"" , buffer + * position , 12 ) ; if ( ! id ) { Py_DECREF ( collection ) ; return NULL ; } * position += 12 ; value = PyObject_CallFunctionObjArgs ( state -> DBRef , collection , id , NULL ) ; Py_DECREF ( collection ) ; Py_DECREF ( id ) ; break ; } case 13 : { PyObject * code ; int value_length = ( ( int * ) ( buffer + * position ) ) [ 0 ] - 1 ; if ( max < value_length ) { goto invalid ; } * position += 4 ; code = PyUnicode_DecodeUTF8 ( buffer + * position , value_length , ""strict"" ) ; if ( ! code ) { return NULL ; } * position += value_length + 1 ; value = PyObject_CallFunctionObjArgs ( state -> Code , code , NULL , NULL ) ; Py_DECREF ( code ) ; break ; } case 15 : { int code_length , scope_size ; PyObject * code ; PyObject * scope ; * position += 8 ; code_length = strlen ( buffer + * position ) ; if ( max < 8 + code_length ) { goto invalid ; } code = PyUnicode_DecodeUTF8 ( buffer + * position , code_length , ""strict"" ) ; if ( ! code ) { return NULL ; } * position += code_length + 1 ; memcpy ( & scope_size , buffer + * position , 4 ) ; scope = elements_to_dict ( self , buffer + * position + 4 , scope_size - 5 , ( PyObject * ) & PyDict_Type , tz_aware , uuid_subtype ) ; if ( ! scope ) { Py_DECREF ( code ) ; return NULL ; } * position += scope_size ; value = PyObject_CallFunctionObjArgs ( state -> Code , code , scope , NULL ) ; Py_DECREF ( code ) ; Py_DECREF ( scope ) ; break ; } case 16 : { int i ; if ( max < 4 ) { goto invalid ; } memcpy ( & i , buffer + * position , 4 ) ; # if PY_MAJOR_VERSION >= 3 value = PyLong_FromLong ( i ) ; # else value = PyInt_FromLong ( i ) ; # endif if ( ! value ) { return NULL ; } * position += 4 ; break ; } case 17 : { unsigned int time , inc ; if ( max < 8 ) { goto invalid ; } memcpy ( & inc , buffer + * position , 4 ) ; memcpy ( & time , buffer + * position + 4 , 4 ) ; value = PyObject_CallFunction ( state -> Timestamp , ""II"" , time , inc ) ; if ( ! value ) { return NULL ; } * position += 8 ; break ; } case 18 : { long long ll ; if ( max < 8 ) { goto invalid ; } memcpy ( & ll , buffer + * position , 8 ) ; value = PyLong_FromLongLong ( ll ) ; if ( ! value ) { return NULL ; } * position += 8 ; break ; } case - 1 : { value = PyObject_CallFunctionObjArgs ( state -> MinKey , NULL ) ; break ; } case 127 : { value = PyObject_CallFunctionObjArgs ( state -> MaxKey , NULL ) ; break ; } default : { PyObject * InvalidDocument = _error ( ""InvalidDocument"" ) ; PyErr_SetString ( InvalidDocument , ""no<S2SV_blank>c<S2SV_blank>decoder<S2SV_blank>for<S2SV_blank>this<S2SV_blank>type<S2SV_blank>yet"" ) ; Py_DECREF ( InvalidDocument ) ; return NULL ; } } return value ; invalid : error = _error ( ""InvalidBSON"" ) ; PyErr_SetNone ( error ) ; Py_DECREF ( error ) ; return NULL ; }","""$ref"" ) ; if ( id == NULL ) { id = Py_None ; <S2SV_ModStart> id ) ; } else { Py_INCREF ( id ) ; <S2SV_ModStart> ""$id"" ) ; }"
68,"static void bgp_capabilities_print ( netdissect_options * ndo , const u_char * opt , int caps_len ) { int cap_type , cap_len , tcap_len , cap_offset ; int i = 0 ; while ( i < caps_len ) { ND_TCHECK2 ( opt [ i ] , BGP_CAP_HEADER_SIZE ) ; cap_type = opt [ i ] ; cap_len = opt [ i + 1 ] ; tcap_len = cap_len ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>length:<S2SV_blank>%u"" , tok2str ( bgp_capcode_values , ""Unknown"" , cap_type ) , cap_type , cap_len ) ) ; ND_TCHECK2 ( opt [ i + 2 ] , cap_len ) ; switch ( cap_type ) { case BGP_CAPCODE_MP : ND_PRINT ( ( ndo , ""\\n\\t\\tAFI<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>SAFI<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( af_values , ""Unknown"" , EXTRACT_16BITS ( opt + i + 2 ) ) , EXTRACT_16BITS ( opt + i + 2 ) , tok2str ( bgp_safi_values , ""Unknown"" , opt [ i + 5 ] ) , opt [ i + 5 ] ) ) ; break ; <S2SV_StartBug> case BGP_CAPCODE_RESTART : <S2SV_EndBug> ND_PRINT ( ( ndo , ""\\n\\t\\tRestart<S2SV_blank>Flags:<S2SV_blank>[%s],<S2SV_blank>Restart<S2SV_blank>Time<S2SV_blank>%us"" , ( ( opt [ i + 2 ] ) & 0x80 ) ? ""R"" : ""none"" , EXTRACT_16BITS ( opt + i + 2 ) & 0xfff ) ) ; tcap_len -= 2 ; cap_offset = 4 ; while ( tcap_len >= 4 ) { ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank><S2SV_blank>AFI<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>SAFI<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>Forwarding<S2SV_blank>state<S2SV_blank>preserved:<S2SV_blank>%s"" , tok2str ( af_values , ""Unknown"" , EXTRACT_16BITS ( opt + i + cap_offset ) ) , EXTRACT_16BITS ( opt + i + cap_offset ) , tok2str ( bgp_safi_values , ""Unknown"" , opt [ i + cap_offset + 2 ] ) , opt [ i + cap_offset + 2 ] , ( ( opt [ i + cap_offset + 3 ] ) & 0x80 ) ? ""yes"" : ""no"" ) ) ; tcap_len -= 4 ; cap_offset += 4 ; } break ; case BGP_CAPCODE_RR : case BGP_CAPCODE_RR_CISCO : break ; case BGP_CAPCODE_AS_NEW : if ( cap_len == 4 ) { ND_PRINT ( ( ndo , ""\\n\\t\\t<S2SV_blank>4<S2SV_blank>Byte<S2SV_blank>AS<S2SV_blank>%s"" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( opt + i + 2 ) ) ) ) ; } break ; case BGP_CAPCODE_ADD_PATH : cap_offset = 2 ; if ( tcap_len == 0 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(bogus)"" ) ) ; break ; } while ( tcap_len > 0 ) { if ( tcap_len < 4 ) { ND_PRINT ( ( ndo , ""\\n\\t\\t(invalid)"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t\\tAFI<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>SAFI<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>Send/Receive:<S2SV_blank>%s"" , tok2str ( af_values , ""Unknown"" , EXTRACT_16BITS ( opt + i + cap_offset ) ) , EXTRACT_16BITS ( opt + i + cap_offset ) , tok2str ( bgp_safi_values , ""Unknown"" , opt [ i + cap_offset + 2 ] ) , opt [ i + cap_offset + 2 ] , tok2str ( bgp_add_path_recvsend , ""Bogus<S2SV_blank>(0x%02x)"" , opt [ i + cap_offset + 3 ] ) ) ) ; tcap_len -= 4 ; cap_offset += 4 ; } break ; default : ND_PRINT ( ( ndo , ""\\n\\t\\tno<S2SV_blank>decoder<S2SV_blank>for<S2SV_blank>Capability<S2SV_blank>%u"" , cap_type ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , & opt [ i + 2 ] , ""\\n\\t\\t"" , cap_len ) ; break ; } if ( ndo -> ndo_vflag > 1 && cap_len > 0 ) { print_unknown_data ( ndo , & opt [ i + 2 ] , ""\\n\\t\\t"" , cap_len ) ; } i += BGP_CAP_HEADER_SIZE + cap_len ; } return ; trunc : ND_PRINT ( ( ndo , ""[|BGP]"" ) ) ; }",case BGP_CAPCODE_RESTART : ND_TCHECK_16BITS ( opt + i + 2 ) ;
69,"static int mpeg4_decode_studio_block ( MpegEncContext * s , int32_t block [ 64 ] , int n ) { Mpeg4DecContext * ctx = s -> avctx -> priv_data ; int cc , dct_dc_size , dct_diff , code , j , idx = 1 , group = 0 , run = 0 , additional_code_len , sign , mismatch ; VLC * cur_vlc = & ctx -> studio_intra_tab [ 0 ] ; uint8_t * const scantable = s -> intra_scantable . permutated ; const uint16_t * quant_matrix ; uint32_t flc ; const int min = - 1 * ( 1 << ( s -> avctx -> bits_per_raw_sample + 6 ) ) ; const int max = ( ( 1 << ( s -> avctx -> bits_per_raw_sample + 6 ) ) - 1 ) ; mismatch = 1 ; memset ( block , 0 , 64 * sizeof ( int32_t ) ) ; if ( n < 4 ) { cc = 0 ; dct_dc_size = get_vlc2 ( & s -> gb , ctx -> studio_luma_dc . table , STUDIO_INTRA_BITS , 2 ) ; quant_matrix = s -> intra_matrix ; } else { cc = ( n & 1 ) + 1 ; if ( ctx -> rgb ) dct_dc_size = get_vlc2 ( & s -> gb , ctx -> studio_luma_dc . table , STUDIO_INTRA_BITS , 2 ) ; else dct_dc_size = get_vlc2 ( & s -> gb , ctx -> studio_chroma_dc . table , STUDIO_INTRA_BITS , 2 ) ; quant_matrix = s -> chroma_intra_matrix ; } if ( dct_dc_size < 0 ) { av_log ( s -> avctx , AV_LOG_ERROR , ""illegal<S2SV_blank>dct_dc_size<S2SV_blank>vlc\\n"" ) ; return AVERROR_INVALIDDATA ; } else if ( dct_dc_size == 0 ) { dct_diff = 0 ; } else { dct_diff = get_xbits ( & s -> gb , dct_dc_size ) ; if ( dct_dc_size > 8 ) { if ( ! check_marker ( s -> avctx , & s -> gb , ""dct_dc_size<S2SV_blank>><S2SV_blank>8"" ) ) return AVERROR_INVALIDDATA ; } } s -> last_dc [ cc ] += dct_diff ; if ( s -> mpeg_quant ) block [ 0 ] = s -> last_dc [ cc ] * ( 8 >> s -> intra_dc_precision ) ; else block [ 0 ] = s -> last_dc [ cc ] * ( 8 >> s -> intra_dc_precision ) * ( 8 >> s -> dct_precision ) ; block [ 0 ] = av_clip ( block [ 0 ] , min , max ) ; mismatch ^= block [ 0 ] ; while ( 1 ) { group = get_vlc2 ( & s -> gb , cur_vlc -> table , STUDIO_INTRA_BITS , 2 ) ; if ( group < 0 ) { av_log ( s -> avctx , AV_LOG_ERROR , ""illegal<S2SV_blank>ac<S2SV_blank>coefficient<S2SV_blank>group<S2SV_blank>vlc\\n"" ) ; return AVERROR_INVALIDDATA ; } additional_code_len = ac_state_tab [ group ] [ 0 ] ; cur_vlc = & ctx -> studio_intra_tab [ ac_state_tab [ group ] [ 1 ] ] ; if ( group == 0 ) { break ; } else if ( group >= 1 && group <= 6 ) { run = 1 << additional_code_len ; if ( additional_code_len ) run += get_bits ( & s -> gb , additional_code_len ) ; idx += run ; continue ; } else if ( group >= 7 && group <= 12 ) { code = get_bits ( & s -> gb , additional_code_len ) ; sign = code & 1 ; code >>= 1 ; run = ( 1 << ( additional_code_len - 1 ) ) + code ; idx += run ; <S2SV_StartBug> j = scantable [ idx ++ ] ; <S2SV_EndBug> block [ j ] = sign ? 1 : - 1 ; } else if ( group >= 13 && group <= 20 ) { <S2SV_StartBug> j = scantable [ idx ++ ] ; <S2SV_EndBug> block [ j ] = get_xbits ( & s -> gb , additional_code_len ) ; <S2SV_StartBug> } else if ( group == 21 ) { <S2SV_EndBug> j = scantable [ idx ++ ] ; additional_code_len = s -> avctx -> bits_per_raw_sample + s -> dct_precision + 4 ; flc = get_bits ( & s -> gb , additional_code_len ) ; if ( flc >> ( additional_code_len - 1 ) ) block [ j ] = - 1 * ( ( flc ^ ( ( 1 << additional_code_len ) - 1 ) ) + 1 ) ; else block [ j ] = flc ; } block [ j ] = ( ( 8 * 2 * block [ j ] * quant_matrix [ j ] * s -> qscale ) >> s -> dct_precision ) / 32 ; block [ j ] = av_clip ( block [ j ] , min , max ) ; mismatch ^= block [ j ] ; } block [ 63 ] ^= mismatch & 1 ; return 0 ; }",+= run ; if ( idx > 63 ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> 20 ) { if ( idx > 63 ) return AVERROR_INVALIDDATA ; <S2SV_ModStart> 21 ) { if ( idx > 63 ) return AVERROR_INVALIDDATA ;
70,"<S2SV_StartBug> static void extend_to_full_distribution ( vp9_prob * probs , vp9_prob p ) { <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( probs , vp9_pareto8_full [ p = 0 ? 0 : p - 1 ] , <S2SV_EndBug> <S2SV_StartBug> MODEL_NODES * sizeof ( vp9_prob ) ) ; <S2SV_EndBug> }","void extend_to_full_distribution ( vpx_prob <S2SV_ModEnd> * probs , <S2SV_ModStart> * probs , vpx_prob <S2SV_ModEnd> p ) { <S2SV_ModStart> p ) { memcpy <S2SV_ModEnd> ( probs , <S2SV_ModStart> * sizeof ( vpx_prob <S2SV_ModEnd> ) ) ;"
71,"png_charp PNGAPI png_get_copyright ( png_structp png_ptr ) { PNG_UNUSED ( png_ptr ) # ifdef PNG_STRING_COPYRIGHT return PNG_STRING_COPYRIGHT # else # ifdef __STDC__ <S2SV_StartBug> return ( ( png_charp ) PNG_STRING_NEWLINE ""libpng<S2SV_blank>version<S2SV_blank>1.2.52<S2SV_blank>-<S2SV_blank>November<S2SV_blank>20,<S2SV_blank>2014"" PNG_STRING_NEWLINE ""Copyright<S2SV_blank>(c)<S2SV_blank>1998-2014<S2SV_blank>Glenn<S2SV_blank>Randers-Pehrson"" PNG_STRING_NEWLINE ""Copyright<S2SV_blank>(c)<S2SV_blank>1996-1997<S2SV_blank>Andreas<S2SV_blank>Dilger"" PNG_STRING_NEWLINE ""Copyright<S2SV_blank>(c)<S2SV_blank>1995-1996<S2SV_blank>Guy<S2SV_blank>Eric<S2SV_blank>Schalnat,<S2SV_blank>Group<S2SV_blank>42,<S2SV_blank>Inc."" PNG_STRING_NEWLINE ) ; <S2SV_EndBug> # else <S2SV_StartBug> return ( ( png_charp ) ""libpng<S2SV_blank>version<S2SV_blank>1.2.52<S2SV_blank>-<S2SV_blank>November<S2SV_blank>20,<S2SV_blank>2014\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Copyright<S2SV_blank>(c)<S2SV_blank>1998-2014<S2SV_blank>Glenn<S2SV_blank>Randers-Pehrson\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Copyright<S2SV_blank>(c)<S2SV_blank>1996-1997<S2SV_blank>Andreas<S2SV_blank>Dilger\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Copyright<S2SV_blank>(c)<S2SV_blank>1995-1996<S2SV_blank>Guy<S2SV_blank>Eric<S2SV_blank>Schalnat,<S2SV_blank>Group<S2SV_blank>42,<S2SV_blank>Inc."" ) ; <S2SV_EndBug> # endif # endif }","png_charp ) PNG_STRING_NEWLINE ""libpng<S2SV_blank>version<S2SV_blank>1.2.54<S2SV_blank>-<S2SV_blank>November<S2SV_blank>12,<S2SV_blank>2015"" PNG_STRING_NEWLINE ""Copyright<S2SV_blank>(c)<S2SV_blank>1998-2015<S2SV_blank>Glenn<S2SV_blank>Randers-Pehrson"" <S2SV_ModEnd> PNG_STRING_NEWLINE ""Copyright<S2SV_blank>(c)<S2SV_blank>1996-1997<S2SV_blank>Andreas<S2SV_blank>Dilger"" PNG_STRING_NEWLINE <S2SV_ModStart> ( png_charp ) ""libpng<S2SV_blank>version<S2SV_blank>1.2.54<S2SV_blank>-<S2SV_blank>November<S2SV_blank>12,<S2SV_blank>2015\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Copyright<S2SV_blank>(c)<S2SV_blank>1998-2015<S2SV_blank>Glenn<S2SV_blank>Randers-Pehrson\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Copyright<S2SV_blank>(c)<S2SV_blank>1996-1997<S2SV_blank>Andreas<S2SV_blank>Dilger\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Copyright<S2SV_blank>(c)<S2SV_blank>1995-1996<S2SV_blank>Guy<S2SV_blank>Eric<S2SV_blank>Schalnat,<S2SV_blank>Group<S2SV_blank>42,<S2SV_blank>Inc."" <S2SV_ModEnd> ) ; #"
72,"static bool handle_client_startup ( PgSocket * client , PktHdr * pkt ) { const char * passwd ; const uint8_t * key ; bool ok ; SBuf * sbuf = & client -> sbuf ; if ( incomplete_pkt ( pkt ) ) { disconnect_client ( client , true , ""client<S2SV_blank>sent<S2SV_blank>partial<S2SV_blank>pkt<S2SV_blank>in<S2SV_blank>startup<S2SV_blank>phase"" ) ; return false ; } if ( client -> wait_for_welcome ) { if ( finish_client_login ( client ) ) { sbuf_prepare_skip ( sbuf , pkt -> len ) ; return true ; } else return false ; } switch ( pkt -> type ) { case PKT_SSLREQ : slog_noise ( client , ""C:<S2SV_blank>req<S2SV_blank>SSL"" ) ; slog_noise ( client , ""P:<S2SV_blank>nak"" ) ; if ( ! sbuf_answer ( & client -> sbuf , ""N"" , 1 ) ) { disconnect_client ( client , false , ""failed<S2SV_blank>to<S2SV_blank>nak<S2SV_blank>SSL"" ) ; return false ; } break ; case PKT_STARTUP_V2 : disconnect_client ( client , true , ""Old<S2SV_blank>V2<S2SV_blank>protocol<S2SV_blank>not<S2SV_blank>supported"" ) ; return false ; case PKT_STARTUP : if ( client -> pool ) { disconnect_client ( client , true , ""client<S2SV_blank>re-sent<S2SV_blank>startup<S2SV_blank>pkt"" ) ; return false ; } if ( ! decide_startup_pool ( client , pkt ) ) return false ; if ( client -> pool -> db -> admin ) { if ( ! admin_pre_login ( client ) ) return false ; } if ( cf_auth_type <= AUTH_TRUST || client -> own_user ) { if ( ! finish_client_login ( client ) ) return false ; } else { if ( ! send_client_authreq ( client ) ) { disconnect_client ( client , false , ""failed<S2SV_blank>to<S2SV_blank>send<S2SV_blank>auth<S2SV_blank>req"" ) ; return false ; } } break ; case 'p' : <S2SV_StartBug> if ( cf_auth_type <= AUTH_TRUST ) { <S2SV_EndBug> disconnect_client ( client , true , ""unrequested<S2SV_blank>passwd<S2SV_blank>pkt"" ) ; return false ; } ok = mbuf_get_string ( & pkt -> data , & passwd ) ; if ( ok && check_client_passwd ( client , passwd ) ) { if ( ! finish_client_login ( client ) ) return false ; } else { disconnect_client ( client , true , ""Auth<S2SV_blank>failed"" ) ; return false ; } break ; case PKT_CANCEL : if ( mbuf_avail_for_read ( & pkt -> data ) == BACKENDKEY_LEN && mbuf_get_bytes ( & pkt -> data , BACKENDKEY_LEN , & key ) ) { memcpy ( client -> cancel_key , key , BACKENDKEY_LEN ) ; accept_cancel_request ( client ) ; } else disconnect_client ( client , false , ""bad<S2SV_blank>cancel<S2SV_blank>request"" ) ; return false ; default : disconnect_client ( client , false , ""bad<S2SV_blank>packet"" ) ; return false ; } sbuf_prepare_skip ( sbuf , pkt -> len ) ; client -> request_time = get_cached_time ( ) ; return true ; }",": if ( ! client -> auth_user ) { disconnect_client ( client , true , ""client<S2SV_blank>password<S2SV_blank>pkt<S2SV_blank>before<S2SV_blank>startup<S2SV_blank>packet"" ) ; return false ; } if ("
73,"int imap_exec ( struct ImapAccountData * adata , const char * cmdstr , ImapCmdFlags flags ) { int rc ; <S2SV_StartBug> rc = cmd_start ( adata , cmdstr , flags ) ; <S2SV_EndBug> if ( rc < 0 ) { cmd_handle_fatal ( adata ) ; return IMAP_EXEC_FATAL ; } if ( flags & IMAP_CMD_QUEUE ) return IMAP_EXEC_SUCCESS ; if ( ( flags & IMAP_CMD_POLL ) && ( C_ImapPollTimeout > 0 ) && ( ( mutt_socket_poll ( adata -> conn , C_ImapPollTimeout ) ) == 0 ) ) { mutt_error ( _ ( ""Connection<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>timed<S2SV_blank>out"" ) , adata -> conn -> account . host ) ; cmd_handle_fatal ( adata ) ; return IMAP_EXEC_FATAL ; } mutt_sig_allow_interrupt ( true ) ; do { rc = imap_cmd_step ( adata ) ; <S2SV_StartBug> } while ( rc == IMAP_RES_CONTINUE ) ; <S2SV_EndBug> mutt_sig_allow_interrupt ( false ) ; if ( rc == IMAP_RES_NO ) return IMAP_EXEC_ERROR ; if ( rc != IMAP_RES_OK ) { if ( adata -> status != IMAP_FATAL ) return IMAP_EXEC_ERROR ; mutt_debug ( LL_DEBUG1 , ""command<S2SV_blank>failed:<S2SV_blank>%s\\n"" , adata -> buf ) ; return IMAP_EXEC_FATAL ; } return IMAP_EXEC_SUCCESS ; }","int rc ; if ( flags & IMAP_CMD_SINGLE ) { if ( adata -> nextcmd != adata -> lastcmd ) imap_exec ( adata , NULL , IMAP_CMD_POLL ) ; } <S2SV_ModStart> adata ) ; if ( ( flags & IMAP_CMD_SINGLE ) && ( adata -> nextcmd == adata -> lastcmd ) ) break ;"
74,"static pngquant_error rwpng_read_image24_libpng ( FILE * infile , png24_image * mainprog_ptr , int verbose ) { png_structp png_ptr = NULL ; png_infop info_ptr = NULL ; png_size_t rowbytes ; int color_type , bit_depth ; png_ptr = png_create_read_struct ( PNG_LIBPNG_VER_STRING , mainprog_ptr , rwpng_error_handler , verbose ? rwpng_warning_stderr_handler : rwpng_warning_silent_handler ) ; if ( ! png_ptr ) { return PNG_OUT_OF_MEMORY_ERROR ; } info_ptr = png_create_info_struct ( png_ptr ) ; if ( ! info_ptr ) { png_destroy_read_struct ( & png_ptr , NULL , NULL ) ; return PNG_OUT_OF_MEMORY_ERROR ; } if ( setjmp ( mainprog_ptr -> jmpbuf ) ) { png_destroy_read_struct ( & png_ptr , & info_ptr , NULL ) ; return LIBPNG_FATAL_ERROR ; } # if defined ( PNG_SKIP_sRGB_CHECK_PROFILE ) && defined ( PNG_SET_OPTION_SUPPORTED ) png_set_option ( png_ptr , PNG_SKIP_sRGB_CHECK_PROFILE , PNG_OPTION_ON ) ; # endif # if PNG_LIBPNG_VER >= 10500 && defined ( PNG_UNKNOWN_CHUNKS_SUPPORTED ) png_set_keep_unknown_chunks ( png_ptr , PNG_HANDLE_CHUNK_IF_SAFE , ( png_const_bytep ) ""pHYs\\0iTXt\\0tEXt\\0zTXt"" , 4 ) ; # endif png_set_read_user_chunk_fn ( png_ptr , & mainprog_ptr -> chunks , read_chunk_callback ) ; struct rwpng_read_data read_data = { infile , 0 } ; png_set_read_fn ( png_ptr , & read_data , user_read_data ) ; png_read_info ( png_ptr , info_ptr ) ; png_get_IHDR ( png_ptr , info_ptr , & mainprog_ptr -> width , & mainprog_ptr -> height , & bit_depth , & color_type , NULL , NULL , NULL ) ; <S2SV_StartBug> if ( mainprog_ptr -> width > INT_MAX / mainprog_ptr -> height ) { <S2SV_EndBug> png_destroy_read_struct ( & png_ptr , & info_ptr , NULL ) ; return PNG_OUT_OF_MEMORY_ERROR ; } if ( ! ( color_type & PNG_COLOR_MASK_ALPHA ) ) { # ifdef PNG_READ_FILLER_SUPPORTED png_set_expand ( png_ptr ) ; png_set_filler ( png_ptr , 65535L , PNG_FILLER_AFTER ) ; # else fprintf ( stderr , ""pngquant<S2SV_blank>readpng:<S2SV_blank><S2SV_blank>image<S2SV_blank>is<S2SV_blank>neither<S2SV_blank>RGBA<S2SV_blank>nor<S2SV_blank>GA\\n"" ) ; png_destroy_read_struct ( & png_ptr , & info_ptr , NULL ) ; mainprog_ptr -> retval = WRONG_INPUT_COLOR_TYPE ; return mainprog_ptr -> retval ; # endif } if ( bit_depth == 16 ) { png_set_strip_16 ( png_ptr ) ; } if ( ! ( color_type & PNG_COLOR_MASK_COLOR ) ) { png_set_gray_to_rgb ( png_ptr ) ; } double gamma = 0.45455 ; if ( png_get_valid ( png_ptr , info_ptr , PNG_INFO_sRGB ) ) { mainprog_ptr -> input_color = RWPNG_SRGB ; mainprog_ptr -> output_color = RWPNG_SRGB ; } else { png_get_gAMA ( png_ptr , info_ptr , & gamma ) ; if ( gamma > 0 && gamma <= 1.0 ) { mainprog_ptr -> input_color = RWPNG_GAMA_ONLY ; mainprog_ptr -> output_color = RWPNG_GAMA_ONLY ; } else { fprintf ( stderr , ""pngquant<S2SV_blank>readpng:<S2SV_blank><S2SV_blank>ignored<S2SV_blank>out-of-range<S2SV_blank>gamma<S2SV_blank>%f\\n"" , gamma ) ; mainprog_ptr -> input_color = RWPNG_NONE ; mainprog_ptr -> output_color = RWPNG_NONE ; gamma = 0.45455 ; } } mainprog_ptr -> gamma = gamma ; png_set_interlace_handling ( png_ptr ) ; png_read_update_info ( png_ptr , info_ptr ) ; rowbytes = png_get_rowbytes ( png_ptr , info_ptr ) ; <S2SV_StartBug> if ( ( mainprog_ptr -> rgba_data = malloc ( rowbytes * mainprog_ptr -> height ) ) == NULL ) { <S2SV_EndBug> fprintf ( stderr , ""pngquant<S2SV_blank>readpng:<S2SV_blank><S2SV_blank>unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>image<S2SV_blank>data\\n"" ) ; png_destroy_read_struct ( & png_ptr , & info_ptr , NULL ) ; return PNG_OUT_OF_MEMORY_ERROR ; } png_bytepp row_pointers = rwpng_create_row_pointers ( info_ptr , png_ptr , mainprog_ptr -> rgba_data , mainprog_ptr -> height , 0 ) ; png_read_image ( png_ptr , row_pointers ) ; png_read_end ( png_ptr , NULL ) ; # if USE_LCMS # if PNG_LIBPNG_VER < 10500 png_charp ProfileData ; # else png_bytep ProfileData ; # endif png_uint_32 ProfileLen ; cmsHPROFILE hInProfile = NULL ; int COLOR_PNG = color_type & PNG_COLOR_MASK_COLOR ; if ( png_get_iCCP ( png_ptr , info_ptr , & ( png_charp ) { 0 } , & ( int ) { 0 } , & ProfileData , & ProfileLen ) ) { hInProfile = cmsOpenProfileFromMem ( ProfileData , ProfileLen ) ; cmsColorSpaceSignature colorspace = cmsGetColorSpace ( hInProfile ) ; if ( colorspace == cmsSigRgbData && COLOR_PNG ) { mainprog_ptr -> input_color = RWPNG_ICCP ; mainprog_ptr -> output_color = RWPNG_SRGB ; } else { if ( colorspace == cmsSigGrayData && ! COLOR_PNG ) { mainprog_ptr -> input_color = RWPNG_ICCP_WARN_GRAY ; mainprog_ptr -> output_color = RWPNG_SRGB ; } cmsCloseProfile ( hInProfile ) ; hInProfile = NULL ; } } if ( hInProfile == NULL && COLOR_PNG && ! png_get_valid ( png_ptr , info_ptr , PNG_INFO_sRGB ) && png_get_valid ( png_ptr , info_ptr , PNG_INFO_gAMA ) && png_get_valid ( png_ptr , info_ptr , PNG_INFO_cHRM ) ) { cmsCIExyY WhitePoint ; cmsCIExyYTRIPLE Primaries ; png_get_cHRM ( png_ptr , info_ptr , & WhitePoint . x , & WhitePoint . y , & Primaries . Red . x , & Primaries . Red . y , & Primaries . Green . x , & Primaries . Green . y , & Primaries . Blue . x , & Primaries . Blue . y ) ; WhitePoint . Y = Primaries . Red . Y = Primaries . Green . Y = Primaries . Blue . Y = 1.0 ; cmsToneCurve * GammaTable [ 3 ] ; GammaTable [ 0 ] = GammaTable [ 1 ] = GammaTable [ 2 ] = cmsBuildGamma ( NULL , 1 / gamma ) ; hInProfile = cmsCreateRGBProfile ( & WhitePoint , & Primaries , GammaTable ) ; cmsFreeToneCurve ( GammaTable [ 0 ] ) ; mainprog_ptr -> input_color = RWPNG_GAMA_CHRM ; mainprog_ptr -> output_color = RWPNG_SRGB ; } if ( hInProfile != NULL ) { cmsHPROFILE hOutProfile = cmsCreate_sRGBProfile ( ) ; cmsHTRANSFORM hTransform = cmsCreateTransform ( hInProfile , TYPE_RGBA_8 , hOutProfile , TYPE_RGBA_8 , INTENT_PERCEPTUAL , omp_get_max_threads ( ) > 1 ? cmsFLAGS_NOCACHE : 0 ) ; # pragma omp parallel for if ( mainprog_ptr -> height * mainprog_ptr -> width > 8000 ) schedule ( static ) for ( unsigned int i = 0 ; i < mainprog_ptr -> height ; i ++ ) { cmsDoTransform ( hTransform , row_pointers [ i ] , row_pointers [ i ] , mainprog_ptr -> width ) ; } cmsDeleteTransform ( hTransform ) ; cmsCloseProfile ( hOutProfile ) ; cmsCloseProfile ( hInProfile ) ; mainprog_ptr -> gamma = 0.45455 ; } # endif png_destroy_read_struct ( & png_ptr , & info_ptr , NULL ) ; mainprog_ptr -> file_size = read_data . bytes_read ; mainprog_ptr -> row_pointers = ( unsigned char * * ) row_pointers ; return SUCCESS ; }","NULL ) ; <S2SV_ModEnd> if ( ! <S2SV_ModStart> ; if ( rowbytes > INT_MAX / mainprog_ptr -> height ) { png_destroy_read_struct ( & png_ptr , & info_ptr , NULL ) ; return PNG_OUT_OF_MEMORY_ERROR ; } if ("
75,"static int ati_remote2_probe ( struct usb_interface * interface , const struct usb_device_id * id ) { struct usb_device * udev = interface_to_usbdev ( interface ) ; struct usb_host_interface * alt = interface -> cur_altsetting ; struct ati_remote2 * ar2 ; int r ; if ( alt -> desc . bInterfaceNumber ) return - ENODEV ; ar2 = kzalloc ( sizeof ( struct ati_remote2 ) , GFP_KERNEL ) ; if ( ! ar2 ) return - ENOMEM ; ar2 -> udev = udev ; <S2SV_StartBug> ar2 -> intf [ 0 ] = interface ; <S2SV_EndBug> ar2 -> ep [ 0 ] = & alt -> endpoint [ 0 ] . desc ; ar2 -> intf [ 1 ] = usb_ifnum_to_if ( udev , 1 ) ; <S2SV_StartBug> r = usb_driver_claim_interface ( & ati_remote2_driver , ar2 -> intf [ 1 ] , ar2 ) ; <S2SV_EndBug> if ( r ) goto fail1 ; alt = ar2 -> intf [ 1 ] -> cur_altsetting ; <S2SV_StartBug> ar2 -> ep [ 1 ] = & alt -> endpoint [ 0 ] . desc ; <S2SV_EndBug> r = ati_remote2_urb_init ( ar2 ) ; if ( r ) <S2SV_StartBug> goto fail2 ; <S2SV_EndBug> ar2 -> channel_mask = channel_mask ; ar2 -> mode_mask = mode_mask ; r = ati_remote2_setup ( ar2 , ar2 -> channel_mask ) ; if ( r ) <S2SV_StartBug> goto fail2 ; <S2SV_EndBug> usb_make_path ( udev , ar2 -> phys , sizeof ( ar2 -> phys ) ) ; strlcat ( ar2 -> phys , ""/input0"" , sizeof ( ar2 -> phys ) ) ; strlcat ( ar2 -> name , ""ATI<S2SV_blank>Remote<S2SV_blank>Wonder<S2SV_blank>II"" , sizeof ( ar2 -> name ) ) ; r = sysfs_create_group ( & udev -> dev . kobj , & ati_remote2_attr_group ) ; if ( r ) <S2SV_StartBug> goto fail2 ; <S2SV_EndBug> r = ati_remote2_input_init ( ar2 ) ; if ( r ) <S2SV_StartBug> goto fail3 ; <S2SV_EndBug> usb_set_intfdata ( interface , ar2 ) ; interface -> needs_remote_wakeup = 1 ; return 0 ; <S2SV_StartBug> fail3 : <S2SV_EndBug> sysfs_remove_group ( & udev -> dev . kobj , & ati_remote2_attr_group ) ; fail2 : <S2SV_StartBug> ati_remote2_urb_cleanup ( ar2 ) ; <S2SV_EndBug> usb_driver_release_interface ( & ati_remote2_driver , ar2 -> intf [ 1 ] ) ; fail1 : kfree ( ar2 ) ; return r ; }","= udev ; if ( alt -> desc . bNumEndpoints < 1 || ! alt -> endpoint ) { dev_err ( & interface -> dev , ""%s():<S2SV_blank>interface<S2SV_blank>0<S2SV_blank>must<S2SV_blank>have<S2SV_blank>an<S2SV_blank>endpoint\\n"" , __func__ ) ; r = - ENODEV ; goto fail1 ; } <S2SV_ModStart> 1 ) ; if ( ( udev -> actconfig -> desc . bNumInterfaces < 2 ) || ! ar2 -> intf [ 1 ] ) { dev_err ( & interface -> dev , ""%s():<S2SV_blank>need<S2SV_blank>2<S2SV_blank>interfaces,<S2SV_blank>found<S2SV_blank>%d\\n"" , __func__ , udev -> actconfig -> desc . bNumInterfaces ) ; r = - ENODEV ; goto fail1 ; } <S2SV_ModStart> -> cur_altsetting ; if ( alt -> desc . bNumEndpoints < 1 || ! alt -> endpoint ) { dev_err ( & interface -> dev , ""%s():<S2SV_blank>interface<S2SV_blank>1<S2SV_blank>must<S2SV_blank>have<S2SV_blank>an<S2SV_blank>endpoint\\n"" , __func__ ) ; r = - ENODEV ; goto fail2 ; } <S2SV_ModStart> r ) goto fail3 <S2SV_ModEnd> ; ar2 -> <S2SV_ModStart> r ) goto fail3 <S2SV_ModEnd> ; usb_make_path ( <S2SV_ModStart> r ) goto fail3 <S2SV_ModEnd> ; r = <S2SV_ModStart> r ) goto fail4 <S2SV_ModEnd> ; usb_set_intfdata ( <S2SV_ModStart> return 0 ; fail4 : sysfs_remove_group ( & udev -> dev . kobj , & ati_remote2_attr_group ) ; fail3 : ati_remote2_urb_cleanup ( ar2 <S2SV_ModEnd> ) ; fail2 <S2SV_ModStart> ; fail2 : <S2SV_ModEnd> usb_driver_release_interface ( &"
76,"WORD32 ih264d_video_decode ( iv_obj_t * dec_hdl , void * pv_api_ip , void * pv_api_op ) { dec_struct_t * ps_dec = ( dec_struct_t * ) ( dec_hdl -> pv_codec_handle ) ; WORD32 i4_err_status = 0 ; UWORD8 * pu1_buf = NULL ; WORD32 buflen ; UWORD32 u4_max_ofst , u4_length_of_start_code = 0 ; UWORD32 bytes_consumed = 0 ; UWORD32 cur_slice_is_nonref = 0 ; UWORD32 u4_next_is_aud ; UWORD32 u4_first_start_code_found = 0 ; WORD32 ret = 0 , api_ret_value = IV_SUCCESS ; WORD32 header_data_left = 0 , frame_data_left = 0 ; UWORD8 * pu1_bitstrm_buf ; ivd_video_decode_ip_t * ps_dec_ip ; ivd_video_decode_op_t * ps_dec_op ; ithread_set_name ( ( void * ) ""Parse_thread"" ) ; ps_dec_ip = ( ivd_video_decode_ip_t * ) pv_api_ip ; ps_dec_op = ( ivd_video_decode_op_t * ) pv_api_op ; { UWORD32 u4_size ; u4_size = ps_dec_op -> u4_size ; memset ( ps_dec_op , 0 , sizeof ( ivd_video_decode_op_t ) ) ; ps_dec_op -> u4_size = u4_size ; } ps_dec -> pv_dec_out = ps_dec_op ; if ( ps_dec -> init_done != 1 ) { return IV_FAIL ; } DATA_SYNC ( ) ; if ( 0 == ps_dec -> u1_flushfrm ) { if ( ps_dec_ip -> pv_stream_buffer == NULL ) { ps_dec_op -> u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM ; ps_dec_op -> u4_error_code |= IVD_DEC_FRM_BS_BUF_NULL ; return IV_FAIL ; } if ( ps_dec_ip -> u4_num_Bytes <= 0 ) { ps_dec_op -> u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM ; ps_dec_op -> u4_error_code |= IVD_DEC_NUMBYTES_INV ; return IV_FAIL ; } } ps_dec -> u1_pic_decode_done = 0 ; ps_dec_op -> u4_num_bytes_consumed = 0 ; ps_dec -> ps_out_buffer = NULL ; if ( ps_dec_ip -> u4_size >= offsetof ( ivd_video_decode_ip_t , s_out_buffer ) ) ps_dec -> ps_out_buffer = & ps_dec_ip -> s_out_buffer ; ps_dec -> u4_fmt_conv_cur_row = 0 ; ps_dec -> u4_output_present = 0 ; ps_dec -> s_disp_op . u4_error_code = 1 ; ps_dec -> u4_fmt_conv_num_rows = FMT_CONV_NUM_ROWS ; if ( 0 == ps_dec -> u4_share_disp_buf && ps_dec -> i4_decode_header == 0 ) { UWORD32 i ; if ( ( ps_dec -> ps_out_buffer -> u4_num_bufs == 0 ) || ( ps_dec -> ps_out_buffer -> u4_num_bufs > IVD_VIDDEC_MAX_IO_BUFFERS ) ) { ps_dec_op -> u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM ; ps_dec_op -> u4_error_code |= IVD_DISP_FRM_ZERO_OP_BUFS ; return IV_FAIL ; } for ( i = 0 ; i < ps_dec -> ps_out_buffer -> u4_num_bufs ; i ++ ) { if ( ps_dec -> ps_out_buffer -> pu1_bufs [ i ] == NULL ) { ps_dec_op -> u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM ; ps_dec_op -> u4_error_code |= IVD_DISP_FRM_OP_BUF_NULL ; return IV_FAIL ; } if ( ps_dec -> ps_out_buffer -> u4_min_out_buf_size [ i ] == 0 ) { ps_dec_op -> u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM ; ps_dec_op -> u4_error_code |= IVD_DISP_FRM_ZERO_OP_BUF_SIZE ; return IV_FAIL ; } } } if ( ps_dec -> u4_total_frames_decoded >= NUM_FRAMES_LIMIT ) { ps_dec_op -> u4_error_code = ERROR_FRAME_LIMIT_OVER ; return IV_FAIL ; } ps_dec -> u4_ts = ps_dec_ip -> u4_ts ; ps_dec_op -> u4_error_code = 0 ; ps_dec_op -> e_pic_type = - 1 ; ps_dec_op -> u4_output_present = 0 ; ps_dec_op -> u4_frame_decoded_flag = 0 ; ps_dec -> i4_frametype = - 1 ; ps_dec -> i4_content_type = - 1 ; ps_dec -> u4_slice_start_code_found = 0 ; if ( ps_dec -> u1_init_dec_flag == 1 && ps_dec -> u4_share_disp_buf == 1 && ps_dec -> u1_flushfrm == 0 ) { UWORD32 i ; WORD32 disp_avail = 0 , free_id ; for ( i = 0 ; i < ps_dec -> u1_pic_bufs ; i ++ ) { if ( 0 == ps_dec -> u4_disp_buf_mapping [ i ] || 1 == ps_dec -> u4_disp_buf_to_be_freed [ i ] ) { disp_avail = 1 ; break ; } } if ( 0 == disp_avail ) { ps_dec_op -> u4_error_code = IVD_DEC_REF_BUF_NULL ; ps_dec_op -> u4_error_code |= ( 1 << IVD_UNSUPPORTEDPARAM ) ; return ( IV_FAIL ) ; } while ( 1 ) { pic_buffer_t * ps_pic_buf ; ps_pic_buf = ( pic_buffer_t * ) ih264_buf_mgr_get_next_free ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , & free_id ) ; if ( ps_pic_buf == NULL ) { UWORD32 i , display_queued = 0 ; for ( i = 0 ; i < ( MAX_DISP_BUFS_NEW ) ; i ++ ) { if ( 0 != ps_dec -> u4_disp_buf_mapping [ i ] ) { display_queued = 1 ; break ; } } if ( 1 == display_queued ) { ps_dec_op -> u4_error_code = IVD_DEC_REF_BUF_NULL ; ps_dec_op -> u4_error_code |= ( 1 << IVD_UNSUPPORTEDPARAM ) ; return ( IV_FAIL ) ; } } else { if ( 1 == ps_dec -> u4_disp_buf_mapping [ free_id ] ) { ih264_buf_mgr_set_status ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , free_id , BUF_MGR_IO ) ; } else { ih264_buf_mgr_release ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , free_id , BUF_MGR_IO ) ; break ; } } } } if ( ps_dec -> u1_flushfrm ) { if ( ps_dec -> u1_init_dec_flag == 0 ) { ps_dec -> u1_flushfrm = 0 ; return ( IV_FAIL ) ; } ih264d_get_next_display_field ( ps_dec , ps_dec -> ps_out_buffer , & ( ps_dec -> s_disp_op ) ) ; if ( 0 == ps_dec -> s_disp_op . u4_error_code ) { if ( check_app_out_buf_size ( ps_dec ) != IV_SUCCESS ) { ps_dec_op -> u4_error_code = IVD_DISP_FRM_ZERO_OP_BUF_SIZE ; return ( IV_FAIL ) ; } ps_dec -> u4_fmt_conv_cur_row = 0 ; ps_dec -> u4_fmt_conv_num_rows = ps_dec -> s_disp_frame_info . u4_y_ht ; ih264d_format_convert ( ps_dec , & ( ps_dec -> s_disp_op ) , ps_dec -> u4_fmt_conv_cur_row , ps_dec -> u4_fmt_conv_num_rows ) ; ps_dec -> u4_fmt_conv_cur_row += ps_dec -> u4_fmt_conv_num_rows ; ps_dec -> u4_output_present = 1 ; } ih264d_release_display_field ( ps_dec , & ( ps_dec -> s_disp_op ) ) ; ps_dec_op -> u4_pic_wd = ( UWORD32 ) ps_dec -> u2_disp_width ; ps_dec_op -> u4_pic_ht = ( UWORD32 ) ps_dec -> u2_disp_height ; ps_dec_op -> u4_new_seq = 0 ; ps_dec_op -> u4_output_present = ps_dec -> u4_output_present ; ps_dec_op -> u4_progressive_frame_flag = ps_dec -> s_disp_op . u4_progressive_frame_flag ; ps_dec_op -> e_output_format = ps_dec -> s_disp_op . e_output_format ; ps_dec_op -> s_disp_frm_buf = ps_dec -> s_disp_op . s_disp_frm_buf ; ps_dec_op -> e4_fld_type = ps_dec -> s_disp_op . e4_fld_type ; ps_dec_op -> u4_ts = ps_dec -> s_disp_op . u4_ts ; ps_dec_op -> u4_disp_buf_id = ps_dec -> s_disp_op . u4_disp_buf_id ; ps_dec_op -> u4_is_ref_flag = - 1 ; ps_dec_op -> e_pic_type = IV_NA_FRAME ; ps_dec_op -> u4_frame_decoded_flag = 0 ; if ( 0 == ps_dec -> s_disp_op . u4_error_code ) { return ( IV_SUCCESS ) ; } else return ( IV_FAIL ) ; } if ( ps_dec -> u1_res_changed == 1 ) { ih264d_init_decoder ( ps_dec ) ; } ps_dec -> u4_prev_nal_skipped = 0 ; ps_dec -> u2_cur_mb_addr = 0 ; ps_dec -> u2_total_mbs_coded = 0 ; ps_dec -> u2_cur_slice_num = 0 ; ps_dec -> cur_dec_mb_num = 0 ; ps_dec -> cur_recon_mb_num = 0 ; ps_dec -> u4_first_slice_in_pic = 1 ; ps_dec -> u1_slice_header_done = 0 ; ps_dec -> u1_dangling_field = 0 ; ps_dec -> u4_dec_thread_created = 0 ; ps_dec -> u4_bs_deblk_thread_created = 0 ; ps_dec -> u4_cur_bs_mb_num = 0 ; ps_dec -> u4_start_recon_deblk = 0 ; ps_dec -> u4_sps_cnt_in_process = 0 ; DEBUG_THREADS_PRINTF ( ""<S2SV_blank>Starting<S2SV_blank>process<S2SV_blank>call\\n"" ) ; ps_dec -> u4_pic_buf_got = 0 ; do { WORD32 buf_size ; pu1_buf = ( UWORD8 * ) ps_dec_ip -> pv_stream_buffer + ps_dec_op -> u4_num_bytes_consumed ; u4_max_ofst = ps_dec_ip -> u4_num_Bytes - ps_dec_op -> u4_num_bytes_consumed ; if ( ( NULL == ps_dec -> pu1_bits_buf_dynamic ) && ( ps_dec -> i4_header_decoded & 1 ) ) { WORD32 size ; void * pv_buf ; void * pv_mem_ctxt = ps_dec -> pv_mem_ctxt ; size = MAX ( 256000 , ps_dec -> u2_pic_wd * ps_dec -> u2_pic_ht * 3 / 2 ) ; <S2SV_StartBug> pv_buf = ps_dec -> pf_aligned_alloc ( pv_mem_ctxt , 128 , size ) ; <S2SV_EndBug> RETURN_IF ( ( NULL == pv_buf ) , IV_FAIL ) ; ps_dec -> pu1_bits_buf_dynamic = pv_buf ; ps_dec -> u4_dynamic_bits_buf_size = size ; } if ( ps_dec -> pu1_bits_buf_dynamic ) { pu1_bitstrm_buf = ps_dec -> pu1_bits_buf_dynamic ; buf_size = ps_dec -> u4_dynamic_bits_buf_size ; } else { pu1_bitstrm_buf = ps_dec -> pu1_bits_buf_static ; buf_size = ps_dec -> u4_static_bits_buf_size ; } u4_next_is_aud = 0 ; buflen = ih264d_find_start_code ( pu1_buf , 0 , u4_max_ofst , & u4_length_of_start_code , & u4_next_is_aud ) ; if ( buflen == - 1 ) buflen = 0 ; buflen = MIN ( buflen , buf_size - 8 ) ; bytes_consumed = buflen + u4_length_of_start_code ; ps_dec_op -> u4_num_bytes_consumed += bytes_consumed ; { UWORD8 u1_firstbyte , u1_nal_ref_idc ; if ( ps_dec -> i4_app_skip_mode == IVD_SKIP_B ) { u1_firstbyte = * ( pu1_buf + u4_length_of_start_code ) ; u1_nal_ref_idc = ( UWORD8 ) ( NAL_REF_IDC ( u1_firstbyte ) ) ; if ( u1_nal_ref_idc == 0 ) { cur_slice_is_nonref = 1 ; continue ; } else { if ( 1 == cur_slice_is_nonref ) { ps_dec_op -> u4_num_bytes_consumed -= bytes_consumed ; ps_dec_op -> e_pic_type = IV_B_FRAME ; ps_dec_op -> u4_error_code = IVD_DEC_FRM_SKIPPED ; ps_dec_op -> u4_error_code |= ( 1 << IVD_UNSUPPORTEDPARAM ) ; ps_dec_op -> u4_frame_decoded_flag = 0 ; ps_dec_op -> u4_size = sizeof ( ivd_video_decode_op_t ) ; ih264d_signal_decode_thread ( ps_dec ) ; if ( ps_dec -> u4_num_cores == 3 ) { ih264d_signal_bs_deblk_thread ( ps_dec ) ; } return ( IV_FAIL ) ; } } } } if ( buflen ) { memcpy ( pu1_bitstrm_buf , pu1_buf + u4_length_of_start_code , buflen ) ; if ( ( buflen + 8 ) < buf_size ) { memset ( pu1_bitstrm_buf + buflen , 0 , 8 ) ; } u4_first_start_code_found = 1 ; } else { if ( u4_first_start_code_found == 0 ) { ps_dec -> i4_error_code = ERROR_START_CODE_NOT_FOUND ; ps_dec_op -> u4_error_code |= 1 << IVD_INSUFFICIENTDATA ; if ( ps_dec -> u4_pic_buf_got == 0 ) { ih264d_fill_output_struct_from_context ( ps_dec , ps_dec_op ) ; ps_dec_op -> u4_error_code = ps_dec -> i4_error_code ; ps_dec_op -> u4_frame_decoded_flag = 0 ; return ( IV_FAIL ) ; } else { ps_dec -> u1_pic_decode_done = 1 ; continue ; } } else { frame_data_left = 0 ; header_data_left = 0 ; continue ; } } ps_dec -> u4_return_to_app = 0 ; ret = ih264d_parse_nal_unit ( dec_hdl , ps_dec_op , pu1_bitstrm_buf , buflen ) ; if ( ret != OK ) { UWORD32 error = ih264d_map_error ( ret ) ; ps_dec_op -> u4_error_code = error | ret ; api_ret_value = IV_FAIL ; if ( ( ret == IVD_RES_CHANGED ) || ( ret == IVD_MEM_ALLOC_FAILED ) || ( ret == ERROR_UNAVAIL_PICBUF_T ) || ( ret == ERROR_UNAVAIL_MVBUF_T ) || ( ret == ERROR_INV_SPS_PPS_T ) || ( ret == IVD_DISP_FRM_ZERO_OP_BUF_SIZE ) ) { ps_dec -> u4_slice_start_code_found = 0 ; break ; } if ( ( ret == ERROR_INCOMPLETE_FRAME ) || ( ret == ERROR_DANGLING_FIELD_IN_PIC ) ) { ps_dec_op -> u4_num_bytes_consumed -= bytes_consumed ; api_ret_value = IV_FAIL ; break ; } if ( ret == ERROR_IN_LAST_SLICE_OF_PIC ) { api_ret_value = IV_FAIL ; break ; } } if ( ps_dec -> u4_return_to_app ) { ps_dec_op -> u4_num_bytes_consumed -= bytes_consumed ; ps_dec_op -> u4_error_code = IVD_DEC_FRM_SKIPPED ; ps_dec_op -> u4_error_code |= ( 1 << IVD_UNSUPPORTEDPARAM ) ; ps_dec_op -> u4_frame_decoded_flag = 0 ; ps_dec_op -> u4_size = sizeof ( ivd_video_decode_op_t ) ; ih264d_signal_decode_thread ( ps_dec ) ; if ( ps_dec -> u4_num_cores == 3 ) { ih264d_signal_bs_deblk_thread ( ps_dec ) ; } return ( IV_FAIL ) ; } header_data_left = ( ( ps_dec -> i4_decode_header == 1 ) && ( ps_dec -> i4_header_decoded != 3 ) && ( ps_dec_op -> u4_num_bytes_consumed < ps_dec_ip -> u4_num_Bytes ) ) ; frame_data_left = ( ( ( ps_dec -> i4_decode_header == 0 ) && ( ( ps_dec -> u1_pic_decode_done == 0 ) || ( u4_next_is_aud == 1 ) ) ) && ( ps_dec_op -> u4_num_bytes_consumed < ps_dec_ip -> u4_num_Bytes ) ) ; } while ( ( header_data_left == 1 ) || ( frame_data_left == 1 ) ) ; if ( ( ps_dec -> u4_pic_buf_got == 1 ) && ( ret != IVD_MEM_ALLOC_FAILED ) && ps_dec -> u2_total_mbs_coded < ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) { WORD32 num_mb_skipped ; WORD32 prev_slice_err ; pocstruct_t temp_poc ; WORD32 ret1 ; WORD32 ht_in_mbs ; ht_in_mbs = ps_dec -> u2_pic_ht >> ( 4 + ps_dec -> ps_cur_slice -> u1_field_pic_flag ) ; num_mb_skipped = ( ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) - ps_dec -> u2_total_mbs_coded ; if ( ps_dec -> u4_first_slice_in_pic && ( ps_dec -> u4_pic_buf_got == 0 ) ) prev_slice_err = 1 ; else prev_slice_err = 2 ; if ( ps_dec -> u4_first_slice_in_pic && ( ps_dec -> u2_total_mbs_coded == 0 ) ) prev_slice_err = 1 ; ret1 = ih264d_mark_err_slice_skip ( ps_dec , num_mb_skipped , ps_dec -> u1_nal_unit_type == IDR_SLICE_NAL , ps_dec -> ps_cur_slice -> u2_frame_num , & temp_poc , prev_slice_err ) ; if ( ( ret1 == ERROR_UNAVAIL_PICBUF_T ) || ( ret1 == ERROR_UNAVAIL_MVBUF_T ) || ( ret1 == ERROR_INV_SPS_PPS_T ) ) { ret = ret1 ; } } if ( ( ret == IVD_RES_CHANGED ) || ( ret == IVD_MEM_ALLOC_FAILED ) || ( ret == ERROR_UNAVAIL_PICBUF_T ) || ( ret == ERROR_UNAVAIL_MVBUF_T ) || ( ret == ERROR_INV_SPS_PPS_T ) ) { ih264d_signal_decode_thread ( ps_dec ) ; if ( ps_dec -> u4_num_cores == 3 ) { ih264d_signal_bs_deblk_thread ( ps_dec ) ; } if ( ret == IVD_RES_CHANGED ) { ps_dec_op -> u4_num_bytes_consumed -= bytes_consumed ; } return IV_FAIL ; } if ( ps_dec -> u1_separate_parse ) { if ( ps_dec -> u4_num_cores == 2 ) { if ( ( ps_dec -> u4_nmb_deblk == 0 ) && ( ps_dec -> u4_start_recon_deblk == 1 ) && ( ps_dec -> ps_cur_sps -> u1_mb_aff_flag == 0 ) ) { UWORD32 u4_num_mbs , u4_max_addr ; tfr_ctxt_t s_tfr_ctxt ; tfr_ctxt_t * ps_tfr_cxt = & s_tfr_ctxt ; pad_mgr_t * ps_pad_mgr = & ps_dec -> s_pad_mgr ; u4_max_addr = ( ps_dec -> u2_frm_wd_in_mbs * ps_dec -> u2_frm_ht_in_mbs ) - 1 ; ps_dec -> u4_cur_bs_mb_num = u4_max_addr + 1 ; ih264d_init_deblk_tfr_ctxt ( ps_dec , ps_pad_mgr , ps_tfr_cxt , ps_dec -> u2_frm_wd_in_mbs , 0 ) ; u4_num_mbs = u4_max_addr - ps_dec -> u4_cur_deblk_mb_num + 1 ; DEBUG_PERF_PRINTF ( ""mbs<S2SV_blank>left<S2SV_blank>for<S2SV_blank>deblocking=<S2SV_blank>%d<S2SV_blank>\\n"" , u4_num_mbs ) ; if ( u4_num_mbs != 0 ) ih264d_check_mb_map_deblk ( ps_dec , u4_num_mbs , ps_tfr_cxt , 1 ) ; ps_dec -> u4_start_recon_deblk = 0 ; } } ih264d_signal_decode_thread ( ps_dec ) ; if ( ps_dec -> u4_num_cores == 3 ) { ih264d_signal_bs_deblk_thread ( ps_dec ) ; } } DATA_SYNC ( ) ; if ( ( ps_dec_op -> u4_error_code & 0xff ) != ERROR_DYNAMIC_RESOLUTION_NOT_SUPPORTED ) { ps_dec_op -> u4_pic_wd = ( UWORD32 ) ps_dec -> u2_disp_width ; ps_dec_op -> u4_pic_ht = ( UWORD32 ) ps_dec -> u2_disp_height ; } if ( ps_dec -> i4_header_decoded != 3 ) { ps_dec_op -> u4_error_code |= ( 1 << IVD_INSUFFICIENTDATA ) ; } if ( ps_dec -> i4_decode_header == 1 && ps_dec -> i4_header_decoded != 3 ) { ps_dec_op -> u4_error_code |= ( 1 << IVD_INSUFFICIENTDATA ) ; } if ( ps_dec -> u4_prev_nal_skipped ) { ps_dec_op -> u4_error_code = IVD_DEC_FRM_SKIPPED ; ps_dec_op -> u4_error_code |= ( 1 << IVD_UNSUPPORTEDPARAM ) ; ps_dec_op -> u4_frame_decoded_flag = 0 ; ps_dec_op -> u4_size = sizeof ( ivd_video_decode_op_t ) ; if ( ps_dec -> u4_num_cores == 3 ) { ih264d_signal_bs_deblk_thread ( ps_dec ) ; } return ( IV_FAIL ) ; } if ( ( ps_dec -> u4_pic_buf_got == 1 ) && ( ERROR_DANGLING_FIELD_IN_PIC != i4_err_status ) ) { if ( ps_dec -> ps_cur_slice -> u1_field_pic_flag ) { if ( 1 == ps_dec -> ps_cur_slice -> u1_bottom_field_flag ) { ps_dec -> u1_top_bottom_decoded |= BOT_FIELD_ONLY ; } else { ps_dec -> u1_top_bottom_decoded |= TOP_FIELD_ONLY ; } } else { ps_dec -> u1_top_bottom_decoded = TOP_FIELD_ONLY | BOT_FIELD_ONLY ; } if ( ( ps_dec -> ps_dec_err_status -> u1_err_flag & REJECT_CUR_PIC ) == 0 ) { ret = ih264d_deblock_display ( ps_dec ) ; } if ( ps_dec -> i4_header_decoded == 3 ) { ps_dec -> u2_total_mbs_coded = ps_dec -> ps_cur_sps -> u2_max_mb_addr + 1 ; } if ( ps_dec -> ps_cur_slice -> u1_nal_unit_type == IDR_SLICE_NAL ) { ps_dec -> i4_frametype = IV_IDR_FRAME ; } else if ( ps_dec -> i4_pic_type == B_SLICE ) { ps_dec -> i4_frametype = IV_B_FRAME ; } else if ( ps_dec -> i4_pic_type == P_SLICE ) { ps_dec -> i4_frametype = IV_P_FRAME ; } else if ( ps_dec -> i4_pic_type == I_SLICE ) { ps_dec -> i4_frametype = IV_I_FRAME ; } else { H264_DEC_DEBUG_PRINT ( ""Shouldn\'t<S2SV_blank>come<S2SV_blank>here\\n"" ) ; } ps_dec -> i4_content_type = ps_dec -> ps_cur_slice -> u1_field_pic_flag ; ps_dec -> u4_total_frames_decoded = ps_dec -> u4_total_frames_decoded + 2 ; ps_dec -> u4_total_frames_decoded = ps_dec -> u4_total_frames_decoded - ps_dec -> ps_cur_slice -> u1_field_pic_flag ; } if ( ps_dec -> u4_num_cores == 3 ) { ih264d_signal_bs_deblk_thread ( ps_dec ) ; } { if ( ( IVD_DECODE_FRAME_OUT == ps_dec -> e_frm_out_mode ) && ps_dec -> u1_init_dec_flag ) { ih264d_get_next_display_field ( ps_dec , ps_dec -> ps_out_buffer , & ( ps_dec -> s_disp_op ) ) ; if ( 0 == ps_dec -> s_disp_op . u4_error_code ) { ps_dec -> u4_fmt_conv_cur_row = 0 ; ps_dec -> u4_output_present = 1 ; } } ih264d_fill_output_struct_from_context ( ps_dec , ps_dec_op ) ; if ( ps_dec -> u4_output_present && ( ps_dec -> u4_fmt_conv_cur_row < ps_dec -> s_disp_frame_info . u4_y_ht ) ) { ps_dec -> u4_fmt_conv_num_rows = ps_dec -> s_disp_frame_info . u4_y_ht - ps_dec -> u4_fmt_conv_cur_row ; ih264d_format_convert ( ps_dec , & ( ps_dec -> s_disp_op ) , ps_dec -> u4_fmt_conv_cur_row , ps_dec -> u4_fmt_conv_num_rows ) ; ps_dec -> u4_fmt_conv_cur_row += ps_dec -> u4_fmt_conv_num_rows ; } ih264d_release_display_field ( ps_dec , & ( ps_dec -> s_disp_op ) ) ; } if ( ps_dec -> i4_decode_header == 1 && ( ps_dec -> i4_header_decoded & 1 ) == 1 ) { ps_dec_op -> u4_progressive_frame_flag = 1 ; if ( ( NULL != ps_dec -> ps_cur_sps ) && ( 1 == ( ps_dec -> ps_cur_sps -> u1_is_valid ) ) ) { if ( ( 0 == ps_dec -> ps_sps -> u1_frame_mbs_only_flag ) && ( 0 == ps_dec -> ps_sps -> u1_mb_aff_flag ) ) ps_dec_op -> u4_progressive_frame_flag = 0 ; } } if ( ( TOP_FIELD_ONLY | BOT_FIELD_ONLY ) == ps_dec -> u1_top_bottom_decoded ) { ps_dec -> u1_top_bottom_decoded = 0 ; } if ( ps_dec -> u4_pic_buf_got == 1 ) { if ( 1 == ps_dec -> u1_last_pic_not_decoded ) { ret = ih264d_end_of_pic_dispbuf_mgr ( ps_dec ) ; if ( ret != OK ) return ret ; ret = ih264d_end_of_pic ( ps_dec ) ; if ( ret != OK ) return ret ; } else { ret = ih264d_end_of_pic ( ps_dec ) ; if ( ret != OK ) return ret ; } } DATA_SYNC ( ) ; H264_DEC_DEBUG_PRINT ( ""The<S2SV_blank>num<S2SV_blank>bytes<S2SV_blank>consumed:<S2SV_blank>%d\\n"" , ps_dec_op -> u4_num_bytes_consumed ) ; return api_ret_value ; }","128 , size + EXTRA_BS_OFFSET"
77,"long follow_hugetlb_page ( struct mm_struct * mm , struct vm_area_struct * vma , struct page * * pages , struct vm_area_struct * * vmas , unsigned long * position , unsigned long * nr_pages , long i , unsigned int flags , int * nonblocking ) { unsigned long pfn_offset ; unsigned long vaddr = * position ; unsigned long remainder = * nr_pages ; struct hstate * h = hstate_vma ( vma ) ; int err = - EFAULT ; while ( vaddr < vma -> vm_end && remainder ) { pte_t * pte ; spinlock_t * ptl = NULL ; int absent ; struct page * page ; if ( fatal_signal_pending ( current ) ) { remainder = 0 ; break ; } pte = huge_pte_offset ( mm , vaddr & huge_page_mask ( h ) , huge_page_size ( h ) ) ; if ( pte ) ptl = huge_pte_lock ( h , mm , pte ) ; absent = ! pte || huge_pte_none ( huge_ptep_get ( pte ) ) ; if ( absent && ( flags & FOLL_DUMP ) && ! hugetlbfs_pagecache_present ( h , vma , vaddr ) ) { if ( pte ) spin_unlock ( ptl ) ; remainder = 0 ; break ; } if ( absent || is_swap_pte ( huge_ptep_get ( pte ) ) || ( ( flags & FOLL_WRITE ) && ! huge_pte_write ( huge_ptep_get ( pte ) ) ) ) { vm_fault_t ret ; unsigned int fault_flags = 0 ; if ( pte ) spin_unlock ( ptl ) ; if ( flags & FOLL_WRITE ) fault_flags |= FAULT_FLAG_WRITE ; if ( nonblocking ) fault_flags |= FAULT_FLAG_ALLOW_RETRY ; if ( flags & FOLL_NOWAIT ) fault_flags |= FAULT_FLAG_ALLOW_RETRY | FAULT_FLAG_RETRY_NOWAIT ; if ( flags & FOLL_TRIED ) { VM_WARN_ON_ONCE ( fault_flags & FAULT_FLAG_ALLOW_RETRY ) ; fault_flags |= FAULT_FLAG_TRIED ; } ret = hugetlb_fault ( mm , vma , vaddr , fault_flags ) ; if ( ret & VM_FAULT_ERROR ) { err = vm_fault_to_errno ( ret , flags ) ; remainder = 0 ; break ; } if ( ret & VM_FAULT_RETRY ) { if ( nonblocking && ! ( fault_flags & FAULT_FLAG_RETRY_NOWAIT ) ) * nonblocking = 0 ; * nr_pages = 0 ; return i ; } continue ; } pfn_offset = ( vaddr & ~ huge_page_mask ( h ) ) >> PAGE_SHIFT ; page = pte_page ( huge_ptep_get ( pte ) ) ; <S2SV_StartBug> same_page : <S2SV_EndBug> if ( pages ) { pages [ i ] = mem_map_offset ( page , pfn_offset ) ; get_page ( pages [ i ] ) ; } if ( vmas ) vmas [ i ] = vma ; vaddr += PAGE_SIZE ; ++ pfn_offset ; -- remainder ; ++ i ; if ( vaddr < vma -> vm_end && remainder && pfn_offset < pages_per_huge_page ( h ) ) { goto same_page ; } spin_unlock ( ptl ) ; } * nr_pages = remainder ; * position = vaddr ; return i ? i : err ; }",) ) ; if ( unlikely ( page_count ( page ) <= 0 ) ) { if ( pages ) { spin_unlock ( ptl ) ; remainder = 0 ; err = - ENOMEM ; break ; } }
78,"static int crypto_ccm_auth ( struct aead_request * req , struct scatterlist * plain , unsigned int cryptlen ) { struct crypto_ccm_req_priv_ctx * pctx = crypto_ccm_reqctx ( req ) ; struct crypto_aead * aead = crypto_aead_reqtfm ( req ) ; struct crypto_ccm_ctx * ctx = crypto_aead_ctx ( aead ) ; AHASH_REQUEST_ON_STACK ( ahreq , ctx -> mac ) ; unsigned int assoclen = req -> assoclen ; struct scatterlist sg [ 3 ] ; <S2SV_StartBug> u8 odata [ 16 ] ; <S2SV_EndBug> u8 idata [ 16 ] ; int ilen , err ; err = format_input ( odata , req , cryptlen ) ; if ( err ) goto out ; sg_init_table ( sg , 3 ) ; sg_set_buf ( & sg [ 0 ] , odata , 16 ) ; if ( assoclen ) { ilen = format_adata ( idata , assoclen ) ; sg_set_buf ( & sg [ 1 ] , idata , ilen ) ; sg_chain ( sg , 3 , req -> src ) ; } else { ilen = 0 ; sg_chain ( sg , 2 , req -> src ) ; } ahash_request_set_tfm ( ahreq , ctx -> mac ) ; ahash_request_set_callback ( ahreq , pctx -> flags , NULL , NULL ) ; ahash_request_set_crypt ( ahreq , sg , NULL , assoclen + ilen + 16 ) ; err = crypto_ahash_init ( ahreq ) ; if ( err ) goto out ; err = crypto_ahash_update ( ahreq ) ; if ( err ) goto out ; ilen = 16 - ( assoclen + ilen ) % 16 ; if ( ilen < 16 ) { memset ( idata , 0 , ilen ) ; sg_init_table ( sg , 2 ) ; sg_set_buf ( & sg [ 0 ] , idata , ilen ) ; if ( plain ) sg_chain ( sg , 2 , plain ) ; plain = sg ; cryptlen += ilen ; } ahash_request_set_crypt ( ahreq , plain , pctx -> odata , cryptlen ) ; err = crypto_ahash_finup ( ahreq ) ; out : return err ; }",] ; u8 * odata = pctx -> odata ; u8 * idata = pctx -> idata <S2SV_ModEnd> ; int ilen
79,"static void command_port_read_callback ( struct urb * urb ) { struct usb_serial_port * command_port = urb -> context ; struct whiteheat_command_private * command_info ; int status = urb -> status ; unsigned char * data = urb -> transfer_buffer ; int result ; command_info = usb_get_serial_port_data ( command_port ) ; if ( ! command_info ) { dev_dbg ( & urb -> dev -> dev , ""%s<S2SV_blank>-<S2SV_blank>command_info<S2SV_blank>is<S2SV_blank>NULL,<S2SV_blank>exiting.\\n"" , __func__ ) ; return ; } <S2SV_StartBug> if ( status ) { <S2SV_EndBug> dev_dbg ( & urb -> dev -> dev , ""%s<S2SV_blank>-<S2SV_blank>nonzero<S2SV_blank>urb<S2SV_blank>status:<S2SV_blank>%d\\n"" , __func__ , status ) ; if ( status != - ENOENT ) command_info -> command_finished = WHITEHEAT_CMD_FAILURE ; wake_up ( & command_info -> wait_command ) ; return ; } usb_serial_debug_data ( & command_port -> dev , __func__ , urb -> actual_length , data ) ; if ( data [ 0 ] == WHITEHEAT_CMD_COMPLETE ) { command_info -> command_finished = WHITEHEAT_CMD_COMPLETE ; wake_up ( & command_info -> wait_command ) ; } else if ( data [ 0 ] == WHITEHEAT_CMD_FAILURE ) { command_info -> command_finished = WHITEHEAT_CMD_FAILURE ; wake_up ( & command_info -> wait_command ) ; } else if ( data [ 0 ] == WHITEHEAT_EVENT ) { dev_dbg ( & urb -> dev -> dev , ""%s<S2SV_blank>-<S2SV_blank>event<S2SV_blank>received\\n"" , __func__ ) ; <S2SV_StartBug> } else if ( data [ 0 ] == WHITEHEAT_GET_DTR_RTS ) { <S2SV_EndBug> memcpy ( command_info -> result_buffer , & data [ 1 ] , <S2SV_StartBug> urb -> actual_length - 1 ) ; <S2SV_EndBug> command_info -> command_finished = WHITEHEAT_CMD_COMPLETE ; wake_up ( & command_info -> wait_command ) ; } else dev_dbg ( & urb -> dev -> dev , ""%s<S2SV_blank>-<S2SV_blank>bad<S2SV_blank>reply<S2SV_blank>from<S2SV_blank>firmware\\n"" , __func__ ) ; result = usb_submit_urb ( command_port -> read_urb , GFP_ATOMIC ) ; if ( result ) dev_dbg ( & urb -> dev -> dev , ""%s<S2SV_blank>-<S2SV_blank>failed<S2SV_blank>resubmitting<S2SV_blank>read<S2SV_blank>urb,<S2SV_blank>error<S2SV_blank>%d\\n"" , __func__ , result ) ; }","} if ( ! urb -> actual_length ) { dev_dbg ( & urb -> dev -> dev , ""%s<S2SV_blank>-<S2SV_blank>empty<S2SV_blank>response,<S2SV_blank>exiting.\\n"" , __func__ ) ; return ; } if ( <S2SV_ModStart> else if ( ( <S2SV_ModStart> == WHITEHEAT_GET_DTR_RTS ) && ( <S2SV_ModEnd> urb -> actual_length <S2SV_ModStart> actual_length - 1 <= sizeof ( command_info -> result_buffer ) ) ) { memcpy ( command_info -> result_buffer , & data [ 1 ] , urb -> actual_length - 1"
80,"static struct buffer_head * ext4_xattr_cache_find ( struct inode * inode , struct ext4_xattr_header * header , <S2SV_StartBug> struct mb_cache_entry * * pce ) <S2SV_EndBug> { __u32 hash = le32_to_cpu ( header -> h_hash ) ; <S2SV_StartBug> struct mb_cache_entry * ce ; <S2SV_EndBug> struct mb_cache * ext4_mb_cache = EXT4_GET_MB_CACHE ( inode ) ; if ( ! header -> h_hash ) return NULL ; ea_idebug ( inode , ""looking<S2SV_blank>for<S2SV_blank>cached<S2SV_blank>blocks<S2SV_blank>[%x]"" , ( int ) hash ) ; <S2SV_StartBug> again : <S2SV_EndBug> <S2SV_StartBug> ce = mb_cache_entry_find_first ( ext4_mb_cache , inode -> i_sb -> s_bdev , <S2SV_EndBug> hash ) ; while ( ce ) { struct buffer_head * bh ; <S2SV_StartBug> if ( IS_ERR ( ce ) ) { <S2SV_EndBug> if ( PTR_ERR ( ce ) == - EAGAIN ) goto again ; break ; } bh = sb_bread ( inode -> i_sb , ce -> e_block ) ; if ( ! bh ) { EXT4_ERROR_INODE ( inode , ""block<S2SV_blank>%lu<S2SV_blank>read<S2SV_blank>error"" , ( unsigned long ) ce -> e_block ) ; } else if ( le32_to_cpu ( BHDR ( bh ) -> h_refcount ) >= EXT4_XATTR_REFCOUNT_MAX ) { ea_idebug ( inode , ""block<S2SV_blank>%lu<S2SV_blank>refcount<S2SV_blank>%d>=%d"" , ( unsigned long ) ce -> e_block , le32_to_cpu ( BHDR ( bh ) -> h_refcount ) , EXT4_XATTR_REFCOUNT_MAX ) ; } else if ( ext4_xattr_cmp ( header , BHDR ( bh ) ) == 0 ) { * pce = ce ; return bh ; } brelse ( bh ) ; <S2SV_StartBug> ce = mb_cache_entry_find_next ( ce , inode -> i_sb -> s_bdev , hash ) ; <S2SV_EndBug> } return NULL ; }","header , struct mb2_cache_entry <S2SV_ModEnd> * * pce <S2SV_ModStart> ) ; struct mb2_cache_entry * ce ; struct mb2_cache <S2SV_ModEnd> * ext4_mb_cache = <S2SV_ModStart> hash ) ; ce = mb2_cache_entry_find_first <S2SV_ModEnd> ( ext4_mb_cache , <S2SV_ModStart> ( ext4_mb_cache , <S2SV_ModEnd> hash ) ; <S2SV_ModStart> * bh ; <S2SV_ModEnd> bh = sb_bread <S2SV_ModStart> ; ce = mb2_cache_entry_find_next ( ext4_mb_cache , ce <S2SV_ModEnd> ) ; }"
81,"int hugetlb_reserve_pages ( struct inode * inode , long from , long to , struct vm_area_struct * vma , vm_flags_t vm_flags ) { long ret , chg ; struct hstate * h = hstate_inode ( inode ) ; <S2SV_StartBug> if ( vm_flags & VM_NORESERVE ) <S2SV_EndBug> return 0 ; if ( ! vma || vma -> vm_flags & VM_MAYSHARE ) chg = region_chg ( & inode -> i_mapping -> private_list , from , to ) ; else { struct resv_map * resv_map = resv_map_alloc ( ) ; if ( ! resv_map ) return - ENOMEM ; chg = to - from ; set_vma_resv_map ( vma , resv_map ) ; set_vma_resv_flags ( vma , HPAGE_RESV_OWNER ) ; } if ( chg < 0 ) return chg ; <S2SV_StartBug> if ( hugetlb_get_quota ( inode -> i_mapping , chg ) ) <S2SV_EndBug> return - ENOSPC ; ret = hugetlb_acct_memory ( h , chg ) ; if ( ret < 0 ) { <S2SV_StartBug> hugetlb_put_quota ( inode -> i_mapping , chg ) ; <S2SV_EndBug> return ret ; } if ( ! vma || vma -> vm_flags & VM_MAYSHARE ) region_add ( & inode -> i_mapping -> private_list , from , to ) ; return 0 ; }","inode ) ; struct hugepage_subpool * spool = subpool_inode ( inode ) ; <S2SV_ModStart> ; if ( hugepage_subpool_get_pages ( spool <S2SV_ModEnd> , chg ) <S2SV_ModStart> 0 ) { hugepage_subpool_put_pages ( spool <S2SV_ModEnd> , chg )"
82,"int mp_pack ( lua_State * L ) { int nargs = lua_gettop ( L ) ; int i ; mp_buf * buf ; if ( nargs == 0 ) return luaL_argerror ( L , 0 , ""MessagePack<S2SV_blank>pack<S2SV_blank>needs<S2SV_blank>input."" ) ; if ( ! lua_checkstack ( L , nargs ) ) return luaL_argerror ( L , 0 , ""Too<S2SV_blank>many<S2SV_blank>arguments<S2SV_blank>for<S2SV_blank>MessagePack<S2SV_blank>pack."" ) ; buf = mp_buf_new ( L ) ; for ( i = 1 ; i <= nargs ; i ++ ) { <S2SV_StartBug> lua_pushvalue ( L , i ) ; <S2SV_EndBug> mp_encode_lua_type ( L , buf , 0 ) ; lua_pushlstring ( L , ( char * ) buf -> b , buf -> len ) ; buf -> free += buf -> len ; buf -> len = 0 ; } mp_buf_free ( L , buf ) ; lua_concat ( L , nargs ) ; return 1 ; }","++ ) { luaL_checkstack ( L , 1 , ""in<S2SV_blank>function<S2SV_blank>mp_check"" ) ;"
83,"static inline void queue_unlock ( struct futex_q * q , struct futex_hash_bucket * hb ) { spin_unlock ( & hb -> lock ) ; <S2SV_StartBug> drop_futex_key_refs ( & q -> key ) ; <S2SV_EndBug> }",lock ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
84,"void Con_Dump_f ( void ) { int l , x , i ; short * line ; fileHandle_t f ; int bufferlen ; char * buffer ; char filename [ MAX_QPATH ] ; if ( Cmd_Argc ( ) != 2 ) { Com_Printf ( ""usage:<S2SV_blank>condump<S2SV_blank><filename>\\n"" ) ; return ; } Q_strncpyz ( filename , Cmd_Argv ( 1 ) , sizeof ( filename ) ) ; <S2SV_StartBug> COM_DefaultExtension ( filename , sizeof ( filename ) , "".txt"" ) ; <S2SV_EndBug> f = FS_FOpenFileWrite ( filename ) ; if ( ! f ) { Com_Printf ( ""ERROR:<S2SV_blank>couldn\'t<S2SV_blank>open<S2SV_blank>%s.\\n"" , filename ) ; return ; } Com_Printf ( ""Dumped<S2SV_blank>console<S2SV_blank>text<S2SV_blank>to<S2SV_blank>%s.\\n"" , filename ) ; for ( l = con . current - con . totallines + 1 ; l <= con . current ; l ++ ) { line = con . text + ( l % con . totallines ) * con . linewidth ; for ( x = 0 ; x < con . linewidth ; x ++ ) if ( ( line [ x ] & 0xff ) != '<S2SV_blank>' ) break ; if ( x != con . linewidth ) break ; } # ifdef _WIN32 bufferlen = con . linewidth + 3 * sizeof ( char ) ; # else bufferlen = con . linewidth + 2 * sizeof ( char ) ; # endif buffer = Hunk_AllocateTempMemory ( bufferlen ) ; buffer [ bufferlen - 1 ] = 0 ; for ( ; l <= con . current ; l ++ ) { line = con . text + ( l % con . totallines ) * con . linewidth ; for ( i = 0 ; i < con . linewidth ; i ++ ) buffer [ i ] = line [ i ] & 0xff ; for ( x = con . linewidth - 1 ; x >= 0 ; x -- ) { if ( buffer [ x ] == '<S2SV_blank>' ) buffer [ x ] = 0 ; else break ; } # ifdef _WIN32 Q_strcat ( buffer , bufferlen , ""\\r\\n"" ) ; # else Q_strcat ( buffer , bufferlen , ""\\n"" ) ; # endif FS_Write ( buffer , strlen ( buffer ) , f ) ; } Hunk_FreeTempMemory ( buffer ) ; FS_FCloseFile ( f ) ; }",""".txt"" ) ; if ( ! COM_CompareExtension ( filename , "".txt"" ) ) { Com_Printf ( ""Con_Dump_f:<S2SV_blank>Only<S2SV_blank>the<S2SV_blank>\\"".txt\\""<S2SV_blank>extension<S2SV_blank>is<S2SV_blank>supported<S2SV_blank>by<S2SV_blank>this<S2SV_blank>command!\\n"" ) ; return ; }"
85,"void ping_unhash ( struct sock * sk ) { struct inet_sock * isk = inet_sk ( sk ) ; pr_debug ( ""ping_unhash(isk=%p,isk->num=%u)\\n"" , isk , isk -> inet_num ) ; <S2SV_StartBug> if ( sk_hashed ( sk ) ) { <S2SV_EndBug> <S2SV_StartBug> write_lock_bh ( & ping_table . lock ) ; <S2SV_EndBug> hlist_nulls_del ( & sk -> sk_nulls_node ) ; sk_nulls_node_init ( & sk -> sk_nulls_node ) ; sock_put ( sk ) ; isk -> inet_num = 0 ; isk -> inet_sport = 0 ; sock_prot_inuse_add ( sock_net ( sk ) , sk -> sk_prot , - 1 ) ; <S2SV_StartBug> write_unlock_bh ( & ping_table . lock ) ; <S2SV_EndBug> } <S2SV_StartBug> } <S2SV_EndBug>",inet_num ) ; write_lock_bh ( & ping_table . lock ) ; <S2SV_ModStart> ) ) { <S2SV_ModEnd> hlist_nulls_del ( & <S2SV_ModStart> 1 ) ; } <S2SV_ModStart> ) ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
86,"static int magicmouse_raw_event ( struct hid_device * hdev , struct hid_report * report , u8 * data , int size ) { struct magicmouse_sc * msc = hid_get_drvdata ( hdev ) ; struct input_dev * input = msc -> input ; int x = 0 , y = 0 , ii , clicks = 0 , npoints ; switch ( data [ 0 ] ) { case TRACKPAD_REPORT_ID : if ( size < 4 || ( ( size - 4 ) % 9 ) != 0 ) return 0 ; npoints = ( size - 4 ) / 9 ; <S2SV_StartBug> msc -> ntouches = 0 ; <S2SV_EndBug> for ( ii = 0 ; ii < npoints ; ii ++ ) magicmouse_emit_touch ( msc , ii , data + ii * 9 + 4 ) ; clicks = data [ 1 ] ; break ; case MOUSE_REPORT_ID : if ( size < 6 || ( ( size - 6 ) % 8 ) != 0 ) return 0 ; <S2SV_StartBug> npoints = ( size - 6 ) / 8 ; <S2SV_EndBug> msc -> ntouches = 0 ; for ( ii = 0 ; ii < npoints ; ii ++ ) magicmouse_emit_touch ( msc , ii , data + ii * 8 + 6 ) ; x = ( int ) ( ( ( data [ 3 ] & 0x0c ) << 28 ) | ( data [ 1 ] << 22 ) ) >> 22 ; y = ( int ) ( ( ( data [ 3 ] & 0x30 ) << 26 ) | ( data [ 2 ] << 22 ) ) >> 22 ; clicks = data [ 3 ] ; break ; case DOUBLE_REPORT_ID : magicmouse_raw_event ( hdev , report , data + 2 , data [ 1 ] ) ; magicmouse_raw_event ( hdev , report , data + 2 + data [ 1 ] , size - 2 - data [ 1 ] ) ; break ; default : return 0 ; } if ( input -> id . product == USB_DEVICE_ID_APPLE_MAGICMOUSE ) { magicmouse_emit_buttons ( msc , clicks & 3 ) ; input_report_rel ( input , REL_X , x ) ; input_report_rel ( input , REL_Y , y ) ; } else { input_report_key ( input , BTN_MOUSE , clicks & 1 ) ; input_mt_report_pointer_emulation ( input , true ) ; } input_sync ( input ) ; return 1 ; }","/ 9 ; if ( npoints > 15 ) { hid_warn ( hdev , ""invalid<S2SV_blank>size<S2SV_blank>value<S2SV_blank>(%d)<S2SV_blank>for<S2SV_blank>TRACKPAD_REPORT_ID\\n"" , size ) ; return 0 ; } <S2SV_ModStart> / 8 ; if ( npoints > 15 ) { hid_warn ( hdev , ""invalid<S2SV_blank>size<S2SV_blank>value<S2SV_blank>(%d)<S2SV_blank>for<S2SV_blank>MOUSE_REPORT_ID\\n"" , size ) ; return 0 ; }"
87,"u_int ieee802_15_4_if_print ( netdissect_options * ndo , const struct pcap_pkthdr * h , const u_char * p ) { u_int caplen = h -> caplen ; <S2SV_StartBug> int hdrlen ; <S2SV_EndBug> uint16_t fc ; uint8_t seq ; <S2SV_StartBug> if ( caplen < 3 ) { <S2SV_EndBug> ND_PRINT ( ( ndo , ""[|802.15.4]<S2SV_blank>%x"" , caplen ) ) ; return caplen ; } fc = EXTRACT_LE_16BITS ( p ) ; hdrlen = extract_header_length ( fc ) ; seq = EXTRACT_LE_8BITS ( p + 2 ) ; p += 3 ; caplen -= 3 ; ND_PRINT ( ( ndo , ""IEEE<S2SV_blank>802.15.4<S2SV_blank>%s<S2SV_blank>packet<S2SV_blank>"" , ftypes [ fc & 0x7 ] ) ) ; if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""seq<S2SV_blank>%02x<S2SV_blank>"" , seq ) ) ; if ( hdrlen == - 1 ) { ND_PRINT ( ( ndo , ""invalid!<S2SV_blank>"" ) ) ; return caplen ; } if ( ! ndo -> ndo_vflag ) { p += hdrlen ; caplen -= hdrlen ; } else { uint16_t panid = 0 ; <S2SV_StartBug> switch ( ( fc >> 10 ) & 0x3 ) { <S2SV_EndBug> case 0x00 : ND_PRINT ( ( ndo , ""none<S2SV_blank>"" ) ) ; break ; case 0x01 : ND_PRINT ( ( ndo , ""reserved<S2SV_blank>destination<S2SV_blank>addressing<S2SV_blank>mode"" ) ) ; return 0 ; case 0x02 : panid = EXTRACT_LE_16BITS ( p ) ; p += 2 ; <S2SV_StartBug> ND_PRINT ( ( ndo , ""%04x:%04x<S2SV_blank>"" , panid , EXTRACT_LE_16BITS ( p ) ) ) ; <S2SV_EndBug> p += 2 ; break ; <S2SV_StartBug> case 0x03 : <S2SV_EndBug> panid = EXTRACT_LE_16BITS ( p ) ; p += 2 ; <S2SV_StartBug> ND_PRINT ( ( ndo , ""%04x:%s<S2SV_blank>"" , panid , le64addr_string ( ndo , p ) ) ) ; <S2SV_EndBug> p += 8 ; <S2SV_StartBug> break ; <S2SV_EndBug> } <S2SV_StartBug> ND_PRINT ( ( ndo , ""<<S2SV_blank>"" ) ) ; <S2SV_EndBug> <S2SV_StartBug> switch ( ( fc >> 14 ) & 0x3 ) { <S2SV_EndBug> <S2SV_StartBug> case 0x00 : <S2SV_EndBug> ND_PRINT ( ( ndo , ""none<S2SV_blank>"" ) ) ; break ; <S2SV_StartBug> case 0x01 : <S2SV_EndBug> ND_PRINT ( ( ndo , ""reserved<S2SV_blank>source<S2SV_blank>addressing<S2SV_blank>mode"" ) ) ; return 0 ; <S2SV_StartBug> case 0x02 : <S2SV_EndBug> <S2SV_StartBug> if ( ! ( fc & ( 1 << 6 ) ) ) { <S2SV_EndBug> panid = EXTRACT_LE_16BITS ( p ) ; p += 2 ; <S2SV_StartBug> } <S2SV_EndBug> ND_PRINT ( ( ndo , ""%04x:%04x<S2SV_blank>"" , panid , EXTRACT_LE_16BITS ( p ) ) ) ; p += 2 ; <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> case 0x03 : <S2SV_EndBug> <S2SV_StartBug> if ( ! ( fc & ( 1 << 6 ) ) ) { <S2SV_EndBug> panid = EXTRACT_LE_16BITS ( p ) ; p += 2 ; <S2SV_StartBug> } <S2SV_EndBug> ND_PRINT ( ( ndo , ""%04x:%s<S2SV_blank>"" , panid , le64addr_string ( ndo , p ) ) ) ; p += 8 ; <S2SV_StartBug> break ; <S2SV_EndBug> } <S2SV_StartBug> caplen -= hdrlen ; <S2SV_EndBug> } if ( ! ndo -> ndo_suppress_default_print ) ND_DEFAULTPRINT ( p , caplen ) ; <S2SV_StartBug> return 0 ; <S2SV_EndBug> }","-> caplen ; u_int <S2SV_ModEnd> hdrlen ; uint16_t <S2SV_ModStart> uint8_t seq ; <S2SV_ModEnd> uint16_t panid = <S2SV_ModStart> = 0 ; if ( caplen < 3 ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return caplen ; } hdrlen = 3 ; fc = EXTRACT_LE_16BITS ( p ) ; seq = EXTRACT_LE_8BITS ( p + 2 ) ; p += 3 ; caplen -= 3 ; ND_PRINT ( ( ndo , ""IEEE<S2SV_blank>802.15.4<S2SV_blank>%s<S2SV_blank>packet<S2SV_blank>"" , ftypes [ FC_FRAME_TYPE ( fc ) ] ) ) ; if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""seq<S2SV_blank>%02x<S2SV_blank>"" , seq ) ) ; switch ( FC_DEST_ADDRESSING_MODE ( fc ) ) { case FC_ADDRESSING_MODE_NONE : if ( fc & FC_PAN_ID_COMPRESSION ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return hdrlen ; } if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""none<S2SV_blank>"" ) ) ; break ; case FC_ADDRESSING_MODE_RESERVED : if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""reserved<S2SV_blank>destination<S2SV_blank>addressing<S2SV_blank>mode"" ) ) ; return hdrlen ; case FC_ADDRESSING_MODE_SHORT : if ( caplen < 2 ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return hdrlen ; } <S2SV_ModEnd> panid = EXTRACT_LE_16BITS <S2SV_ModStart> += 2 ; caplen -= 2 ; hdrlen += 2 ; if ( caplen < 2 ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return hdrlen ; } if ( ndo -> ndo_vflag ) <S2SV_ModStart> EXTRACT_LE_16BITS ( p + 2 ) ) ) ; p += 2 ; caplen -= 2 ; hdrlen <S2SV_ModEnd> += 2 ; <S2SV_ModStart> break ; case FC_ADDRESSING_MODE_LONG : if ( caplen < 2 ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return hdrlen ; } <S2SV_ModEnd> panid = EXTRACT_LE_16BITS <S2SV_ModStart> += 2 ; caplen -= 2 ; hdrlen += 2 ; if ( caplen < 8 ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return hdrlen ; } if ( ndo -> ndo_vflag ) <S2SV_ModStart> ndo , p + 2 <S2SV_ModStart> += 8 ; caplen -= 8 ; hdrlen += 8 ; <S2SV_ModStart> break ; } if ( ndo -> ndo_vflag ) <S2SV_ModStart> ; switch ( FC_SRC_ADDRESSING_MODE ( fc ) <S2SV_ModEnd> ) { case <S2SV_ModStart> ) { case FC_ADDRESSING_MODE_NONE : if ( ndo -> ndo_vflag ) <S2SV_ModEnd> ND_PRINT ( ( <S2SV_ModStart> break ; case FC_ADDRESSING_MODE_RESERVED : if ( ndo -> ndo_vflag ) <S2SV_ModEnd> ND_PRINT ( ( <S2SV_ModStart> 0 ; case FC_ADDRESSING_MODE_SHORT <S2SV_ModEnd> : if ( <S2SV_ModStart> ( fc & FC_PAN_ID_COMPRESSION ) ) { if ( caplen < 2 ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return hdrlen ; } <S2SV_ModEnd> panid = EXTRACT_LE_16BITS <S2SV_ModStart> += 2 ; caplen -= 2 ; hdrlen += 2 ; } if ( caplen < 2 ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return hdrlen ; } if ( ndo -> ndo_vflag ) <S2SV_ModEnd> ND_PRINT ( ( <S2SV_ModStart> += 2 ; caplen -= 2 ; hdrlen += 2 ; <S2SV_ModStart> break ; case FC_ADDRESSING_MODE_LONG <S2SV_ModEnd> : if ( <S2SV_ModStart> ( fc & FC_PAN_ID_COMPRESSION ) ) { if ( caplen < 2 ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return hdrlen ; } <S2SV_ModEnd> panid = EXTRACT_LE_16BITS <S2SV_ModStart> += 2 ; caplen -= 2 ; hdrlen += 2 ; } if ( caplen < 8 ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return hdrlen ; } if ( ndo -> ndo_vflag ) <S2SV_ModEnd> ND_PRINT ( ( <S2SV_ModStart> += 8 ; caplen -= 8 ; hdrlen += 8 ; <S2SV_ModStart> break ; } <S2SV_ModEnd> if ( ! <S2SV_ModStart> ) ; return hdrlen <S2SV_ModEnd> ; } <S2SV_null>"
88,"static int validate_event ( struct pmu_hw_events * hw_events , struct perf_event * event ) { struct arm_pmu * armpmu = to_arm_pmu ( event -> pmu ) ; <S2SV_StartBug> struct pmu * leader_pmu = event -> group_leader -> pmu ; <S2SV_EndBug> if ( event -> pmu != leader_pmu || event -> state < PERF_EVENT_STATE_OFF ) return 1 ; if ( event -> state == PERF_EVENT_STATE_OFF && ! event -> attr . enable_on_exec ) return 1 ; return armpmu -> get_event_idx ( hw_events , event ) >= 0 ; }",group_leader -> pmu ; if ( is_software_event ( event ) ) return 1
89,"static int newque ( struct ipc_namespace * ns , struct ipc_params * params ) { struct msg_queue * msq ; int id , retval ; key_t key = params -> key ; int msgflg = params -> flg ; msq = ipc_rcu_alloc ( sizeof ( * msq ) ) ; if ( ! msq ) return - ENOMEM ; msq -> q_perm . mode = msgflg & S_IRWXUGO ; msq -> q_perm . key = key ; msq -> q_perm . security = NULL ; retval = security_msg_queue_alloc ( msq ) ; if ( retval ) { ipc_rcu_putref ( msq , ipc_rcu_free ) ; return retval ; } <S2SV_StartBug> id = ipc_addid ( & msg_ids ( ns ) , & msq -> q_perm , ns -> msg_ctlmni ) ; <S2SV_EndBug> if ( id < 0 ) { ipc_rcu_putref ( msq , msg_rcu_free ) ; return id ; } <S2SV_StartBug> msq -> q_stime = msq -> q_rtime = 0 ; <S2SV_EndBug> msq -> q_ctime = get_seconds ( ) ; msq -> q_cbytes = msq -> q_qnum = 0 ; msq -> q_qbytes = ns -> msg_ctlmnb ; msq -> q_lspid = msq -> q_lrpid = 0 ; INIT_LIST_HEAD ( & msq -> q_messages ) ; INIT_LIST_HEAD ( & msq -> q_receivers ) ; INIT_LIST_HEAD ( & msq -> q_senders ) ; ipc_unlock_object ( & msq -> q_perm ) ; rcu_read_unlock ( ) ; return msq -> q_perm . id ; }",retval ; } msq -> q_stime = msq -> q_rtime = 0 ; msq -> q_ctime = get_seconds ( ) ; msq -> q_cbytes = msq -> q_qnum = 0 ; msq -> q_qbytes = ns -> msg_ctlmnb ; msq -> q_lspid = msq -> q_lrpid = 0 ; INIT_LIST_HEAD ( & msq -> q_messages ) ; INIT_LIST_HEAD ( & msq -> q_receivers ) ; INIT_LIST_HEAD ( & msq -> q_senders ) ; <S2SV_ModStart> id ; } <S2SV_ModEnd> ipc_unlock_object ( &
90,"static void * vips_foreign_load_start ( VipsImage * out , void * a , void * b ) { VipsForeignLoad * load = VIPS_FOREIGN_LOAD ( b ) ; <S2SV_StartBug> VipsForeignLoadClass * class = VIPS_FOREIGN_LOAD_GET_CLASS ( load ) ; <S2SV_EndBug> if ( ! load -> real ) { if ( ! ( load -> real = vips_foreign_load_temp ( load ) ) ) return ( NULL ) ; # ifdef DEBUG printf ( ""vips_foreign_load_start:<S2SV_blank>triggering<S2SV_blank>->load()\\n"" ) ; # endif load -> real -> progress_signal = load -> out ; g_object_set_qdata ( G_OBJECT ( load -> real ) , vips__foreign_load_operation , load ) ; if ( class -> load ( load ) || <S2SV_StartBug> vips_image_pio_input ( load -> real ) ) <S2SV_EndBug> return ( NULL ) ; if ( ! vips_foreign_load_iscompat ( load -> real , out ) ) <S2SV_StartBug> return ( NULL ) ; <S2SV_EndBug> vips_image_pipelinev ( load -> out , load -> out -> dhint , load -> real , NULL ) ; } return ( vips_region_new ( load -> real ) ) ; }",VIPS_FOREIGN_LOAD_GET_CLASS ( load ) ; if ( load -> error ) return ( NULL <S2SV_ModStart> -> real ) || <S2SV_ModEnd> vips_foreign_load_iscompat ( load <S2SV_ModStart> out ) ) { vips_operation_invalidate ( VIPS_OPERATION ( load ) ) ; load -> error = TRUE ; return ( NULL ) ; } <S2SV_ModEnd> vips_image_pipelinev ( load
91,"void vp8_fix_contexts ( MACROBLOCKD * x ) { if ( x -> mode_info_context -> mbmi . mode != B_PRED && x -> mode_info_context -> mbmi . mode != SPLITMV ) { <S2SV_StartBug> vpx_memset ( x -> above_context , 0 , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( x -> left_context , 0 , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; <S2SV_EndBug> } else { <S2SV_StartBug> vpx_memset ( x -> above_context , 0 , sizeof ( ENTROPY_CONTEXT_PLANES ) - 1 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( x -> left_context , 0 , sizeof ( ENTROPY_CONTEXT_PLANES ) - 1 ) ; <S2SV_EndBug> } }",SPLITMV ) { memset <S2SV_ModEnd> ( x -> <S2SV_ModStart> ) ) ; memset <S2SV_ModEnd> ( x -> <S2SV_ModStart> } else { memset <S2SV_ModEnd> ( x -> <S2SV_ModStart> 1 ) ; memset <S2SV_ModEnd> ( x ->
92,"static krb5_error_code process_db_args ( krb5_context context , char * * db_args , xargs_t * xargs , OPERATION optype ) { int i = 0 ; krb5_error_code st = 0 ; char * arg = NULL , * arg_val = NULL ; char * * dptr = NULL ; unsigned int arg_val_len = 0 ; if ( db_args ) { for ( i = 0 ; db_args [ i ] ; ++ i ) { arg = strtok_r ( db_args [ i ] , ""="" , & arg_val ) ; <S2SV_StartBug> if ( strcmp ( arg , TKTPOLICY_ARG ) == 0 ) { <S2SV_EndBug> dptr = & xargs -> tktpolicydn ; } else { if ( strcmp ( arg , USERDN_ARG ) == 0 ) { if ( optype == MODIFY_PRINCIPAL || xargs -> dn != NULL || xargs -> containerdn != NULL || xargs -> linkdn != NULL ) { st = EINVAL ; k5_setmsg ( context , st , _ ( ""%s<S2SV_blank>option<S2SV_blank>not<S2SV_blank>supported"" ) , arg ) ; goto cleanup ; } dptr = & xargs -> dn ; } else if ( strcmp ( arg , CONTAINERDN_ARG ) == 0 ) { if ( optype == MODIFY_PRINCIPAL || xargs -> dn != NULL || xargs -> containerdn != NULL ) { st = EINVAL ; k5_setmsg ( context , st , _ ( ""%s<S2SV_blank>option<S2SV_blank>not<S2SV_blank>supported"" ) , arg ) ; goto cleanup ; } dptr = & xargs -> containerdn ; } else if ( strcmp ( arg , LINKDN_ARG ) == 0 ) { if ( xargs -> dn != NULL || xargs -> linkdn != NULL ) { st = EINVAL ; k5_setmsg ( context , st , _ ( ""%s<S2SV_blank>option<S2SV_blank>not<S2SV_blank>supported"" ) , arg ) ; goto cleanup ; } dptr = & xargs -> linkdn ; } else { st = EINVAL ; k5_setmsg ( context , st , _ ( ""unknown<S2SV_blank>option:<S2SV_blank>%s"" ) , arg ) ; goto cleanup ; } xargs -> dn_from_kbd = TRUE ; if ( arg_val == NULL || strlen ( arg_val ) == 0 ) { st = EINVAL ; k5_setmsg ( context , st , _ ( ""%s<S2SV_blank>option<S2SV_blank>value<S2SV_blank>missing"" ) , arg ) ; goto cleanup ; } } if ( arg_val == NULL ) { st = EINVAL ; k5_setmsg ( context , st , _ ( ""%s<S2SV_blank>option<S2SV_blank>value<S2SV_blank>missing"" ) , arg ) ; goto cleanup ; } arg_val_len = strlen ( arg_val ) + 1 ; if ( strcmp ( arg , TKTPOLICY_ARG ) == 0 ) { if ( ( st = krb5_ldap_name_to_policydn ( context , arg_val , dptr ) ) != 0 ) goto cleanup ; } else { * dptr = k5memdup ( arg_val , arg_val_len , & st ) ; if ( * dptr == NULL ) goto cleanup ; } } } cleanup : return st ; }","arg_val ) ; arg = ( arg != NULL ) ? arg : """" ;"
93,"int git_pkt_parse_line ( git_pkt * * head , const char * line , const char * * out , size_t bufflen ) { int ret ; int32_t len ; if ( bufflen > 0 && bufflen < PKT_LEN_SIZE ) return GIT_EBUFS ; len = parse_len ( line ) ; if ( len < 0 ) { if ( bufflen >= 4 && ! git__prefixcmp ( line , ""PACK"" ) ) { giterr_clear ( ) ; * out = line ; return pack_pkt ( head ) ; } return ( int ) len ; } if ( bufflen > 0 && bufflen < ( size_t ) len ) return GIT_EBUFS ; <S2SV_StartBug> line += PKT_LEN_SIZE ; <S2SV_EndBug> if ( len == PKT_LEN_SIZE ) { * head = NULL ; * out = line ; return 0 ; } if ( len == 0 ) { * out = line ; return flush_pkt ( head ) ; } len -= PKT_LEN_SIZE ; if ( * line == GIT_SIDE_BAND_DATA ) ret = data_pkt ( head , line , len ) ; else if ( * line == GIT_SIDE_BAND_PROGRESS ) ret = sideband_progress_pkt ( head , line , len ) ; else if ( * line == GIT_SIDE_BAND_ERROR ) ret = sideband_error_pkt ( head , line , len ) ; else if ( ! git__prefixcmp ( line , ""ACK"" ) ) ret = ack_pkt ( head , line , len ) ; else if ( ! git__prefixcmp ( line , ""NAK"" ) ) ret = nak_pkt ( head ) ; else if ( ! git__prefixcmp ( line , ""ERR<S2SV_blank>"" ) ) ret = err_pkt ( head , line , len ) ; else if ( * line == '#' ) ret = comment_pkt ( head , line , len ) ; else if ( ! git__prefixcmp ( line , ""ok"" ) ) ret = ok_pkt ( head , line , len ) ; else if ( ! git__prefixcmp ( line , ""ng"" ) ) ret = ng_pkt ( head , line , len ) ; else if ( ! git__prefixcmp ( line , ""unpack"" ) ) ret = unpack_pkt ( head , line , len ) ; else ret = ref_pkt ( head , line , len ) ; * out = line + len ; return ret ; }",return GIT_EBUFS ; if ( len != 0 && len < PKT_LEN_SIZE ) return GIT_ERROR ;
94,"static struct fileIdentDesc * udf_find_entry ( struct inode * dir , const struct qstr * child , struct udf_fileident_bh * fibh , struct fileIdentDesc * cfi ) { struct fileIdentDesc * fi = NULL ; loff_t f_pos ; int block , flen ; unsigned char * fname = NULL ; unsigned char * nameptr ; uint8_t lfi ; uint16_t liu ; loff_t size ; struct kernel_lb_addr eloc ; uint32_t elen ; sector_t offset ; struct extent_position epos = { } ; struct udf_inode_info * dinfo = UDF_I ( dir ) ; int isdotdot = child -> len == 2 && child -> name [ 0 ] == '.' && child -> name [ 1 ] == '.' ; size = udf_ext0_offset ( dir ) + dir -> i_size ; f_pos = udf_ext0_offset ( dir ) ; fibh -> sbh = fibh -> ebh = NULL ; fibh -> soffset = fibh -> eoffset = f_pos & ( dir -> i_sb -> s_blocksize - 1 ) ; if ( dinfo -> i_alloc_type != ICBTAG_FLAG_AD_IN_ICB ) { if ( inode_bmap ( dir , f_pos >> dir -> i_sb -> s_blocksize_bits , & epos , & eloc , & elen , & offset ) != ( EXT_RECORDED_ALLOCATED >> 30 ) ) goto out_err ; block = udf_get_lb_pblock ( dir -> i_sb , & eloc , offset ) ; if ( ( ++ offset << dir -> i_sb -> s_blocksize_bits ) < elen ) { if ( dinfo -> i_alloc_type == ICBTAG_FLAG_AD_SHORT ) epos . offset -= sizeof ( struct short_ad ) ; else if ( dinfo -> i_alloc_type == ICBTAG_FLAG_AD_LONG ) epos . offset -= sizeof ( struct long_ad ) ; } else offset = 0 ; fibh -> sbh = fibh -> ebh = udf_tread ( dir -> i_sb , block ) ; if ( ! fibh -> sbh ) goto out_err ; } fname = kmalloc ( UDF_NAME_LEN , GFP_NOFS ) ; if ( ! fname ) goto out_err ; while ( f_pos < size ) { fi = udf_fileident_read ( dir , & f_pos , fibh , cfi , & epos , & eloc , & elen , & offset ) ; if ( ! fi ) goto out_err ; liu = le16_to_cpu ( cfi -> lengthOfImpUse ) ; lfi = cfi -> lengthFileIdent ; if ( fibh -> sbh == fibh -> ebh ) { nameptr = fi -> fileIdent + liu ; } else { int poffset ; poffset = fibh -> soffset + sizeof ( struct fileIdentDesc ) + liu + lfi ; if ( poffset >= lfi ) nameptr = ( uint8_t * ) ( fibh -> ebh -> b_data + poffset - lfi ) ; else { nameptr = fname ; memcpy ( nameptr , fi -> fileIdent + liu , lfi - poffset ) ; memcpy ( nameptr + lfi - poffset , fibh -> ebh -> b_data , poffset ) ; } } if ( ( cfi -> fileCharacteristics & FID_FILE_CHAR_DELETED ) != 0 ) { if ( ! UDF_QUERY_FLAG ( dir -> i_sb , UDF_FLAG_UNDELETE ) ) continue ; } if ( ( cfi -> fileCharacteristics & FID_FILE_CHAR_HIDDEN ) != 0 ) { if ( ! UDF_QUERY_FLAG ( dir -> i_sb , UDF_FLAG_UNHIDE ) ) continue ; } if ( ( cfi -> fileCharacteristics & FID_FILE_CHAR_PARENT ) && isdotdot ) goto out_ok ; if ( ! lfi ) continue ; <S2SV_StartBug> flen = udf_get_filename ( dir -> i_sb , nameptr , fname , lfi ) ; <S2SV_EndBug> if ( flen && udf_match ( flen , fname , child -> len , child -> name ) ) goto out_ok ; } out_err : fi = NULL ; if ( fibh -> sbh != fibh -> ebh ) brelse ( fibh -> ebh ) ; brelse ( fibh -> sbh ) ; out_ok : brelse ( epos . bh ) ; kfree ( fname ) ; return fi ; }",", nameptr , lfi , fname , UDF_NAME_LEN <S2SV_ModEnd> ) ; if"
95,"void Triangle ( double x1 , double y1 , double x2 , double y2 , double x3 , double y3 ) { <S2SV_StartBug> outpos += <S2SV_EndBug> sprintf ( outpos , ""\\n<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>m<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>l<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>l<S2SV_blank>h"" , x1 , y1 , x2 , y2 , x3 , y3 ) ; <S2SV_StartBug> } <S2SV_EndBug>","y3 ) { sprintf ( outputbuffer <S2SV_ModEnd> , ""\\n<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>m<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>l<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>l<S2SV_blank>h"" , <S2SV_ModStart> y3 ) ; sendClean ( outputbuffer ) ;"
96,"static Image * ReadHDRImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { char format [ MaxTextExtent ] , keyword [ MaxTextExtent ] , tag [ MaxTextExtent ] , value [ MaxTextExtent ] ; double gamma ; Image * image ; int c ; MagickBooleanType status , value_expected ; register PixelPacket * q ; register unsigned char * p ; register ssize_t i , x ; ssize_t count , y ; unsigned char * end , pixel [ 4 ] , * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image -> columns = 0 ; image -> rows = 0 ; * format = '\\0' ; c = ReadBlobByte ( image ) ; if ( c == EOF ) { image = DestroyImage ( image ) ; return ( ( Image * ) NULL ) ; } while ( isgraph ( c ) && ( image -> columns == 0 ) && ( image -> rows == 0 ) ) { if ( c == ( int ) '#' ) { char * comment ; register char * p ; size_t length ; length = MaxTextExtent ; comment = AcquireString ( ( char * ) NULL ) ; for ( p = comment ; comment != ( char * ) NULL ; p ++ ) { c = ReadBlobByte ( image ) ; if ( ( c == EOF ) || ( c == ( int ) '\\n' ) ) break ; if ( ( size_t ) ( p - comment + 1 ) >= length ) { * p = '\\0' ; length <<= 1 ; comment = ( char * ) ResizeQuantumMemory ( comment , length + MaxTextExtent , sizeof ( * comment ) ) ; if ( comment == ( char * ) NULL ) break ; p = comment + strlen ( comment ) ; } * p = ( char ) c ; } if ( comment == ( char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; * p = '\\0' ; ( void ) SetImageProperty ( image , ""comment"" , comment ) ; comment = DestroyString ( comment ) ; c = ReadBlobByte ( image ) ; } else if ( isalnum ( c ) == MagickFalse ) c = ReadBlobByte ( image ) ; else { register char * p ; p = keyword ; do { if ( ( size_t ) ( p - keyword ) < ( MaxTextExtent - 1 ) ) * p ++ = c ; c = ReadBlobByte ( image ) ; } while ( isalnum ( c ) || ( c == '_' ) ) ; * p = '\\0' ; value_expected = MagickFalse ; while ( ( isspace ( ( int ) ( ( unsigned char ) c ) ) != 0 ) || ( c == '=' ) ) { if ( c == '=' ) value_expected = MagickTrue ; c = ReadBlobByte ( image ) ; } if ( LocaleCompare ( keyword , ""Y"" ) == 0 ) value_expected = MagickTrue ; if ( value_expected == MagickFalse ) continue ; p = value ; while ( ( c != '\\n' ) && ( c != '\\0' ) ) { if ( ( size_t ) ( p - value ) < ( MaxTextExtent - 1 ) ) * p ++ = c ; c = ReadBlobByte ( image ) ; } * p = '\\0' ; switch ( * keyword ) { case 'F' : case 'f' : { if ( LocaleCompare ( keyword , ""format"" ) == 0 ) { ( void ) CopyMagickString ( format , value , MaxTextExtent ) ; break ; } ( void ) FormatLocaleString ( tag , MaxTextExtent , ""hdr:%s"" , keyword ) ; ( void ) SetImageProperty ( image , tag , value ) ; break ; } case 'G' : case 'g' : { if ( LocaleCompare ( keyword , ""gamma"" ) == 0 ) { image -> gamma = StringToDouble ( value , ( char * * ) NULL ) ; break ; } ( void ) FormatLocaleString ( tag , MaxTextExtent , ""hdr:%s"" , keyword ) ; ( void ) SetImageProperty ( image , tag , value ) ; break ; } case 'P' : case 'p' : { if ( LocaleCompare ( keyword , ""primaries"" ) == 0 ) { float chromaticity [ 6 ] , white_point [ 2 ] ; ( void ) sscanf ( value , ""%g<S2SV_blank>%g<S2SV_blank>%g<S2SV_blank>%g<S2SV_blank>%g<S2SV_blank>%g<S2SV_blank>%g<S2SV_blank>%g"" , & chromaticity [ 0 ] , & chromaticity [ 1 ] , & chromaticity [ 2 ] , & chromaticity [ 3 ] , & chromaticity [ 4 ] , & chromaticity [ 5 ] , & white_point [ 0 ] , & white_point [ 1 ] ) ; image -> chromaticity . red_primary . x = chromaticity [ 0 ] ; image -> chromaticity . red_primary . y = chromaticity [ 1 ] ; image -> chromaticity . green_primary . x = chromaticity [ 2 ] ; image -> chromaticity . green_primary . y = chromaticity [ 3 ] ; image -> chromaticity . blue_primary . x = chromaticity [ 4 ] ; image -> chromaticity . blue_primary . y = chromaticity [ 5 ] ; image -> chromaticity . white_point . x = white_point [ 0 ] , image -> chromaticity . white_point . y = white_point [ 1 ] ; break ; } ( void ) FormatLocaleString ( tag , MaxTextExtent , ""hdr:%s"" , keyword ) ; ( void ) SetImageProperty ( image , tag , value ) ; break ; } case 'Y' : case 'y' : { if ( strcmp ( keyword , ""Y"" ) == 0 ) { int height , width ; ( void ) sscanf ( value , ""%d<S2SV_blank>+X<S2SV_blank>%d"" , & height , & width ) ; image -> columns = ( size_t ) width ; image -> rows = ( size_t ) height ; break ; } ( void ) FormatLocaleString ( tag , MaxTextExtent , ""hdr:%s"" , keyword ) ; ( void ) SetImageProperty ( image , tag , value ) ; break ; } default : { ( void ) FormatLocaleString ( tag , MaxTextExtent , ""hdr:%s"" , keyword ) ; ( void ) SetImageProperty ( image , tag , value ) ; break ; } } } if ( ( image -> columns == 0 ) && ( image -> rows == 0 ) ) while ( isspace ( ( int ) ( ( unsigned char ) c ) ) != 0 ) c = ReadBlobByte ( image ) ; } if ( ( LocaleCompare ( format , ""32-bit_rle_rgbe"" ) != 0 ) && ( LocaleCompare ( format , ""32-bit_rle_xyze"" ) != 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( image -> columns == 0 ) || ( image -> rows == 0 ) ) ThrowReaderException ( CorruptImageError , ""NegativeOrZeroImageSize"" ) ; ( void ) SetImageColorspace ( image , RGBColorspace ) ; if ( LocaleCompare ( format , ""32-bit_rle_xyze"" ) == 0 ) ( void ) SetImageColorspace ( image , XYZColorspace ) ; image -> compression = ( image -> columns < 8 ) || ( image -> columns > 0x7ffff ) ? NoCompression : RLECompression ; if ( image_info -> ping != MagickFalse ) { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } <S2SV_StartBug> pixels = ( unsigned char * ) AcquireQuantumMemory ( image -> columns , 4 * <S2SV_EndBug> sizeof ( * pixels ) ) ; if ( pixels == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { if ( image -> compression != RLECompression ) { count = ReadBlob ( image , 4 * image -> columns * sizeof ( * pixels ) , pixels ) ; if ( count != ( ssize_t ) ( 4 * image -> columns * sizeof ( * pixels ) ) ) break ; } else { count = ReadBlob ( image , 4 * sizeof ( * pixel ) , pixel ) ; if ( count != 4 ) break ; if ( ( size_t ) ( ( ( ( size_t ) pixel [ 2 ] ) << 8 ) | pixel [ 3 ] ) != image -> columns ) { ( void ) memcpy ( pixels , pixel , 4 * sizeof ( * pixel ) ) ; count = ReadBlob ( image , 4 * ( image -> columns - 1 ) * sizeof ( * pixels ) , pixels + 4 ) ; image -> compression = NoCompression ; } else { p = pixels ; for ( i = 0 ; i < 4 ; i ++ ) { end = & pixels [ ( i + 1 ) * image -> columns ] ; while ( p < end ) { count = ReadBlob ( image , 2 * sizeof ( * pixel ) , pixel ) ; if ( count < 1 ) break ; if ( pixel [ 0 ] > 128 ) { count = ( ssize_t ) pixel [ 0 ] - 128 ; if ( ( count == 0 ) || ( count > ( ssize_t ) ( end - p ) ) ) break ; while ( count -- > 0 ) * p ++ = pixel [ 1 ] ; } else { count = ( ssize_t ) pixel [ 0 ] ; if ( ( count == 0 ) || ( count > ( ssize_t ) ( end - p ) ) ) break ; * p ++ = pixel [ 1 ] ; if ( -- count > 0 ) { count = ReadBlob ( image , ( size_t ) count * sizeof ( * p ) , p ) ; if ( count < 1 ) break ; p += count ; } } } } } } q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; i = 0 ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( image -> compression == RLECompression ) { pixel [ 0 ] = pixels [ x ] ; pixel [ 1 ] = pixels [ x + image -> columns ] ; pixel [ 2 ] = pixels [ x + 2 * image -> columns ] ; pixel [ 3 ] = pixels [ x + 3 * image -> columns ] ; } else { pixel [ 0 ] = pixels [ i ++ ] ; pixel [ 1 ] = pixels [ i ++ ] ; pixel [ 2 ] = pixels [ i ++ ] ; pixel [ 3 ] = pixels [ i ++ ] ; } SetPixelRed ( q , 0 ) ; SetPixelGreen ( q , 0 ) ; SetPixelBlue ( q , 0 ) ; if ( pixel [ 3 ] != 0 ) { gamma = pow ( 2.0 , pixel [ 3 ] - ( 128.0 + 8.0 ) ) ; SetPixelRed ( q , ClampToQuantum ( QuantumRange * gamma * pixel [ 0 ] ) ) ; SetPixelGreen ( q , ClampToQuantum ( QuantumRange * gamma * pixel [ 1 ] ) ) ; SetPixelBlue ( q , ClampToQuantum ( QuantumRange * gamma * pixel [ 2 ] ) ) ; } q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } pixels = ( unsigned char * ) RelinquishMagickMemory ( pixels ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }",") ; } status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }"
97,"static int sctp_getsockopt_assoc_stats ( struct sock * sk , int len , char __user * optval , int __user * optlen ) { struct sctp_assoc_stats sas ; struct sctp_association * asoc = NULL ; if ( len < sizeof ( sctp_assoc_t ) ) return - EINVAL ; <S2SV_StartBug> if ( copy_from_user ( & sas , optval , len ) ) <S2SV_EndBug> return - EFAULT ; asoc = sctp_id2assoc ( sk , sas . sas_assoc_id ) ; if ( ! asoc ) return - EINVAL ; sas . sas_rtxchunks = asoc -> stats . rtxchunks ; sas . sas_gapcnt = asoc -> stats . gapcnt ; sas . sas_outofseqtsns = asoc -> stats . outofseqtsns ; sas . sas_osacks = asoc -> stats . osacks ; sas . sas_isacks = asoc -> stats . isacks ; sas . sas_octrlchunks = asoc -> stats . octrlchunks ; sas . sas_ictrlchunks = asoc -> stats . ictrlchunks ; sas . sas_oodchunks = asoc -> stats . oodchunks ; sas . sas_iodchunks = asoc -> stats . iodchunks ; sas . sas_ouodchunks = asoc -> stats . ouodchunks ; sas . sas_iuodchunks = asoc -> stats . iuodchunks ; sas . sas_idupchunks = asoc -> stats . idupchunks ; sas . sas_opackets = asoc -> stats . opackets ; sas . sas_ipackets = asoc -> stats . ipackets ; sas . sas_maxrto = asoc -> stats . max_obs_rto ; memcpy ( & sas . sas_obs_rto_ipaddr , & asoc -> stats . obs_rto_ipaddr , sizeof ( struct sockaddr_storage ) ) ; asoc -> stats . max_obs_rto = asoc -> rto_min ; <S2SV_StartBug> len = min_t ( size_t , len , sizeof ( sas ) ) ; <S2SV_EndBug> if ( put_user ( len , optlen ) ) return - EFAULT ; SCTP_DEBUG_PRINTK ( ""sctp_getsockopt_assoc_stat(%d):<S2SV_blank>%d\\n"" , len , sas . sas_assoc_id ) ; if ( copy_to_user ( optval , & sas , len ) ) return - EFAULT ; return 0 ; }","- EINVAL ; len = min_t ( size_t , len , sizeof ( sas ) ) ; <S2SV_ModStart> -> rto_min ; <S2SV_ModEnd> if ( put_user"
98,"static void add_bytes_c ( uint8_t * dst , uint8_t * src , int w ) { long i ; <S2SV_StartBug> for ( i = 0 ; i <= w - sizeof ( long ) ; i += sizeof ( long ) ) { <S2SV_EndBug> long a = * ( long * ) ( src + i ) ; long b = * ( long * ) ( dst + i ) ; * ( long * ) ( dst + i ) = ( ( a & pb_7f ) + ( b & pb_7f ) ) ^ ( ( a ^ b ) & pb_80 ) ; } for ( ; i < w ; i ++ ) dst [ i + 0 ] += src [ i + 0 ] ; }",<= w - ( int )
99,"char * suhosin_encrypt_single_cookie ( char * name , int name_len , char * value , int value_len , char * key TSRMLS_DC ) { <S2SV_StartBug> char buffer [ 4096 ] ; <S2SV_EndBug> char buffer2 [ 4096 ] ; char * buf = buffer , * buf2 = buffer2 , * d , * d_url ; int l ; <S2SV_StartBug> if ( name_len > sizeof ( buffer ) - 2 ) { <S2SV_EndBug> buf = estrndup ( name , name_len ) ; <S2SV_StartBug> } else { <S2SV_EndBug> memcpy ( buf , name , name_len ) ; buf [ name_len ] = 0 ; } name_len = php_url_decode ( buf , name_len ) ; normalize_varname ( buf ) ; name_len = strlen ( buf ) ; if ( SUHOSIN_G ( cookie_plainlist ) ) { if ( zend_hash_exists ( SUHOSIN_G ( cookie_plainlist ) , buf , name_len + 1 ) ) { encrypt_return_plain : <S2SV_StartBug> if ( buf != buffer ) { <S2SV_EndBug> efree ( buf ) ; } return estrndup ( value , value_len ) ; } } else if ( SUHOSIN_G ( cookie_cryptlist ) ) { if ( ! zend_hash_exists ( SUHOSIN_G ( cookie_cryptlist ) , buf , name_len + 1 ) ) { goto encrypt_return_plain ; } } <S2SV_StartBug> if ( strlen ( value ) <= sizeof ( buffer2 ) - 2 ) { <S2SV_EndBug> memcpy ( buf2 , value , value_len ) ; buf2 [ value_len ] = 0 ; } else { buf2 = estrndup ( value , value_len ) ; } value_len = php_url_decode ( buf2 , value_len ) ; d = suhosin_encrypt_string ( buf2 , value_len , buf , name_len , key TSRMLS_CC ) ; d_url = php_url_encode ( d , strlen ( d ) , & l ) ; efree ( d ) ; <S2SV_StartBug> if ( buf != buffer ) { <S2SV_EndBug> efree ( buf ) ; } if ( buf2 != buffer2 ) { efree ( buf2 ) ; } return d_url ; }",") { char * buf , * buf2 <S2SV_ModEnd> , * d <S2SV_ModStart> int l ; <S2SV_ModEnd> buf = estrndup <S2SV_ModStart> name_len ) ; <S2SV_ModEnd> name_len = php_url_decode <S2SV_ModStart> { encrypt_return_plain : efree ( buf ) ; <S2SV_ModEnd> return estrndup ( <S2SV_ModStart> ; } } buf2 = estrndup ( value , value_len ) ; <S2SV_ModEnd> value_len = php_url_decode <S2SV_ModStart> d ) ; efree ( buf ) ; efree ( buf2 ) ; <S2SV_ModEnd> return d_url ;"
100,"static void vmx_complete_atomic_exit ( struct vcpu_vmx * vmx ) { u32 exit_intr_info ; if ( ! ( vmx -> exit_reason == EXIT_REASON_MCE_DURING_VMENTRY || vmx -> exit_reason == EXIT_REASON_EXCEPTION_NMI ) ) return ; vmx -> exit_intr_info = vmcs_read32 ( VM_EXIT_INTR_INFO ) ; exit_intr_info = vmx -> exit_intr_info ; if ( is_machine_check ( exit_intr_info ) ) kvm_machine_check ( ) ; <S2SV_StartBug> if ( ( exit_intr_info & INTR_INFO_INTR_TYPE_MASK ) == INTR_TYPE_NMI_INTR && <S2SV_EndBug> ( exit_intr_info & INTR_INFO_VALID_MASK ) ) { kvm_before_handle_nmi ( & vmx -> vcpu ) ; asm ( ""int<S2SV_blank>$2"" ) ; kvm_after_handle_nmi ( & vmx -> vcpu ) ; } }",; if ( is_nmi ( exit_intr_info <S2SV_ModEnd> ) ) {
101,"static REFERENCE_MODE read_frame_reference_mode ( const VP9_COMMON * cm , <S2SV_StartBug> vp9_reader * r ) { <S2SV_EndBug> if ( is_compound_reference_allowed ( cm ) ) { <S2SV_StartBug> return vp9_read_bit ( r ) ? ( vp9_read_bit ( r ) ? REFERENCE_MODE_SELECT <S2SV_EndBug> : COMPOUND_REFERENCE ) : SINGLE_REFERENCE ; } else { return SINGLE_REFERENCE ; } }","* cm , vpx_reader <S2SV_ModEnd> * r ) <S2SV_ModStart> ) { return vpx_read_bit <S2SV_ModEnd> ( r ) <S2SV_ModStart> ) ? ( vpx_read_bit <S2SV_ModEnd> ( r )"
102,"static const interp_kernel * choose_interp_filter ( int inlength , int outlength ) { int outlength16 = outlength * 16 ; if ( outlength16 >= inlength * 16 ) <S2SV_StartBug> return vp9_filteredinterp_filters1000 ; <S2SV_EndBug> else if ( outlength16 >= inlength * 13 ) <S2SV_StartBug> return vp9_filteredinterp_filters875 ; <S2SV_EndBug> else if ( outlength16 >= inlength * 11 ) <S2SV_StartBug> return vp9_filteredinterp_filters750 ; <S2SV_EndBug> else if ( outlength16 >= inlength * 9 ) <S2SV_StartBug> return vp9_filteredinterp_filters625 ; <S2SV_EndBug> else <S2SV_StartBug> return vp9_filteredinterp_filters500 ; <S2SV_EndBug> }",16 ) return filteredinterp_filters1000 <S2SV_ModEnd> ; else if <S2SV_ModStart> 13 ) return filteredinterp_filters875 <S2SV_ModEnd> ; else if <S2SV_ModStart> 11 ) return filteredinterp_filters750 <S2SV_ModEnd> ; else if <S2SV_ModStart> 9 ) return filteredinterp_filters625 <S2SV_ModEnd> ; else return <S2SV_ModStart> ; else return filteredinterp_filters500 <S2SV_ModEnd> ; } <S2SV_null>
103,"static int rose_parse_national ( unsigned char * p , struct rose_facilities_struct * facilities , int len ) { unsigned char * pt ; unsigned char l , lg , n = 0 ; int fac_national_digis_received = 0 ; do { switch ( * p & 0xC0 ) { case 0x00 : <S2SV_StartBug> p += 2 ; <S2SV_EndBug> n += 2 ; len -= 2 ; break ; case 0x40 : <S2SV_StartBug> if ( * p == FAC_NATIONAL_RAND ) <S2SV_EndBug> facilities -> rand = ( ( p [ 1 ] << 8 ) & 0xFF00 ) + ( ( p [ 2 ] << 0 ) & 0x00FF ) ; p += 3 ; n += 3 ; len -= 3 ; break ; case 0x80 : <S2SV_StartBug> p += 4 ; <S2SV_EndBug> n += 4 ; len -= 4 ; break ; case 0xC0 : <S2SV_StartBug> l = p [ 1 ] ; <S2SV_EndBug> if ( * p == FAC_NATIONAL_DEST_DIGI ) { if ( ! fac_national_digis_received ) { <S2SV_StartBug> memcpy ( & facilities -> source_digis [ 0 ] , p + 2 , AX25_ADDR_LEN ) ; <S2SV_EndBug> facilities -> source_ndigis = 1 ; } } else if ( * p == FAC_NATIONAL_SRC_DIGI ) { if ( ! fac_national_digis_received ) { <S2SV_StartBug> memcpy ( & facilities -> dest_digis [ 0 ] , p + 2 , AX25_ADDR_LEN ) ; <S2SV_EndBug> facilities -> dest_ndigis = 1 ; } } else if ( * p == FAC_NATIONAL_FAIL_CALL ) { <S2SV_StartBug> memcpy ( & facilities -> fail_call , p + 2 , AX25_ADDR_LEN ) ; <S2SV_EndBug> } else if ( * p == FAC_NATIONAL_FAIL_ADD ) { <S2SV_StartBug> memcpy ( & facilities -> fail_addr , p + 3 , ROSE_ADDR_LEN ) ; <S2SV_EndBug> } <S2SV_StartBug> else if ( * p == FAC_NATIONAL_DIGIS ) { <S2SV_EndBug> fac_national_digis_received = 1 ; facilities -> source_ndigis = 0 ; facilities -> dest_ndigis = 0 ; for ( pt = p + 2 , lg = 0 ; lg < l ; pt += AX25_ADDR_LEN , lg += AX25_ADDR_LEN ) { if ( pt [ 6 ] & AX25_HBIT ) { if ( facilities -> dest_ndigis >= ROSE_MAX_DIGIS ) return - 1 ; memcpy ( & facilities -> dest_digis [ facilities -> dest_ndigis ++ ] , pt , AX25_ADDR_LEN ) ; } else { if ( facilities -> source_ndigis >= ROSE_MAX_DIGIS ) return - 1 ; memcpy ( & facilities -> source_digis [ facilities -> source_ndigis ++ ] , pt , AX25_ADDR_LEN ) ; } } } p += l + 2 ; n += l + 2 ; len -= l + 2 ; break ; } } while ( * p != 0x00 && len > 0 ) ; return n ; }",case 0x00 : if ( len < 2 ) return - 1 ; <S2SV_ModStart> : if ( len < 3 ) return - 1 ; if ( <S2SV_ModStart> case 0x80 : if ( len < 4 ) return - 1 ; <S2SV_ModStart> case 0xC0 : if ( len < 2 ) return - 1 ; l = p [ 1 ] ; if ( len < 2 + l ) return - 1 <S2SV_ModEnd> ; if ( <S2SV_ModStart> fac_national_digis_received ) { if ( l < AX25_ADDR_LEN ) return - 1 ; <S2SV_ModStart> fac_national_digis_received ) { if ( l < AX25_ADDR_LEN ) return - 1 ; <S2SV_ModStart> FAC_NATIONAL_FAIL_CALL ) { if ( l < AX25_ADDR_LEN ) return - 1 ; <S2SV_ModStart> FAC_NATIONAL_FAIL_ADD ) { if ( l < 1 + ROSE_ADDR_LEN ) return - 1 ; <S2SV_ModStart> FAC_NATIONAL_DIGIS ) { if ( l % AX25_ADDR_LEN ) return - 1 ;
104,"<S2SV_StartBug> static void update_coef_probs_common ( vp9_writer * const bc , VP9_COMP * cpi , <S2SV_EndBug> TX_SIZE tx_size , <S2SV_StartBug> vp9_coeff_stats * frame_branch_ct ) { <S2SV_EndBug> vp9_coeff_probs_model * new_frame_coef_probs = cpi -> frame_coef_probs [ tx_size ] ; vp9_coeff_probs_model * old_frame_coef_probs = <S2SV_StartBug> cpi -> common . fc . coef_probs [ tx_size ] ; <S2SV_EndBug> const vp9_prob upd = DIFF_UPDATE_PROB ; const int entropy_nodes_update = UNCONSTRAINED_NODES ; int i , j , k , l , t ; switch ( cpi -> sf . use_fast_coef_updates ) { case TWO_LOOP : { int savings = 0 ; int update [ 2 ] = { 0 , 0 } ; for ( i = 0 ; i < PLANE_TYPES ; ++ i ) { for ( j = 0 ; j < REF_TYPES ; ++ j ) { for ( k = 0 ; k < COEF_BANDS ; ++ k ) { for ( l = 0 ; l < BAND_COEFF_CONTEXTS ( k ) ; ++ l ) { for ( t = 0 ; t < entropy_nodes_update ; ++ t ) { <S2SV_StartBug> vp9_prob newp = new_frame_coef_probs [ i ] [ j ] [ k ] [ l ] [ t ] ; <S2SV_EndBug> <S2SV_StartBug> const vp9_prob oldp = old_frame_coef_probs [ i ] [ j ] [ k ] [ l ] [ t ] ; <S2SV_EndBug> int s ; int u = 0 ; if ( t == PIVOT_NODE ) s = vp9_prob_diff_update_savings_search_model ( frame_branch_ct [ i ] [ j ] [ k ] [ l ] [ 0 ] , <S2SV_StartBug> old_frame_coef_probs [ i ] [ j ] [ k ] [ l ] , & newp , upd ) ; <S2SV_EndBug> else s = vp9_prob_diff_update_savings_search ( frame_branch_ct [ i ] [ j ] [ k ] [ l ] [ t ] , oldp , & newp , upd ) ; if ( s > 0 && newp != oldp ) u = 1 ; if ( u ) savings += s - ( int ) ( vp9_cost_zero ( upd ) ) ; else savings -= ( int ) ( vp9_cost_zero ( upd ) ) ; update [ u ] ++ ; } } } } } if ( update [ 1 ] == 0 || savings < 0 ) { <S2SV_StartBug> vp9_write_bit ( bc , 0 ) ; <S2SV_EndBug> return ; } <S2SV_StartBug> vp9_write_bit ( bc , 1 ) ; <S2SV_EndBug> for ( i = 0 ; i < PLANE_TYPES ; ++ i ) { for ( j = 0 ; j < REF_TYPES ; ++ j ) { for ( k = 0 ; k < COEF_BANDS ; ++ k ) { for ( l = 0 ; l < BAND_COEFF_CONTEXTS ( k ) ; ++ l ) { for ( t = 0 ; t < entropy_nodes_update ; ++ t ) { <S2SV_StartBug> vp9_prob newp = new_frame_coef_probs [ i ] [ j ] [ k ] [ l ] [ t ] ; <S2SV_EndBug> vp9_prob * oldp = old_frame_coef_probs [ i ] [ j ] [ k ] [ l ] + t ; <S2SV_StartBug> const vp9_prob upd = DIFF_UPDATE_PROB ; <S2SV_EndBug> int s ; int u = 0 ; if ( t == PIVOT_NODE ) s = vp9_prob_diff_update_savings_search_model ( frame_branch_ct [ i ] [ j ] [ k ] [ l ] [ 0 ] , <S2SV_StartBug> old_frame_coef_probs [ i ] [ j ] [ k ] [ l ] , & newp , upd ) ; <S2SV_EndBug> else s = vp9_prob_diff_update_savings_search ( frame_branch_ct [ i ] [ j ] [ k ] [ l ] [ t ] , * oldp , & newp , upd ) ; if ( s > 0 && newp != * oldp ) u = 1 ; <S2SV_StartBug> vp9_write ( bc , u , upd ) ; <S2SV_EndBug> if ( u ) { vp9_write_prob_diff_update ( bc , newp , * oldp ) ; * oldp = newp ; } } } } } } return ; } <S2SV_StartBug> case ONE_LOOP : <S2SV_EndBug> case ONE_LOOP_REDUCED : { <S2SV_StartBug> const int prev_coef_contexts_to_update = <S2SV_EndBug> cpi -> sf . use_fast_coef_updates == ONE_LOOP_REDUCED ? COEFF_CONTEXTS >> 1 : COEFF_CONTEXTS ; const int coef_band_to_update = cpi -> sf . use_fast_coef_updates == ONE_LOOP_REDUCED ? COEF_BANDS >> 1 : COEF_BANDS ; int updates = 0 ; int noupdates_before_first = 0 ; for ( i = 0 ; i < PLANE_TYPES ; ++ i ) { for ( j = 0 ; j < REF_TYPES ; ++ j ) { for ( k = 0 ; k < COEF_BANDS ; ++ k ) { for ( l = 0 ; l < BAND_COEFF_CONTEXTS ( k ) ; ++ l ) { for ( t = 0 ; t < entropy_nodes_update ; ++ t ) { <S2SV_StartBug> vp9_prob newp = new_frame_coef_probs [ i ] [ j ] [ k ] [ l ] [ t ] ; <S2SV_EndBug> vp9_prob * oldp = old_frame_coef_probs [ i ] [ j ] [ k ] [ l ] + t ; int s ; int u = 0 ; <S2SV_StartBug> if ( l >= prev_coef_contexts_to_update || <S2SV_EndBug> k >= coef_band_to_update ) { u = 0 ; } else { <S2SV_StartBug> if ( t == PIVOT_NODE ) <S2SV_EndBug> s = vp9_prob_diff_update_savings_search_model ( frame_branch_ct [ i ] [ j ] [ k ] [ l ] [ 0 ] , <S2SV_StartBug> old_frame_coef_probs [ i ] [ j ] [ k ] [ l ] , & newp , upd ) ; <S2SV_EndBug> else s = vp9_prob_diff_update_savings_search ( frame_branch_ct [ i ] [ j ] [ k ] [ l ] [ t ] , * oldp , & newp , upd ) ; <S2SV_StartBug> if ( s > 0 && newp != * oldp ) <S2SV_EndBug> u = 1 ; <S2SV_StartBug> } <S2SV_EndBug> updates += u ; if ( u == 0 && updates == 0 ) { noupdates_before_first ++ ; continue ; } if ( u == 1 && updates == 1 ) { int v ; <S2SV_StartBug> vp9_write_bit ( bc , 1 ) ; <S2SV_EndBug> for ( v = 0 ; v < noupdates_before_first ; ++ v ) <S2SV_StartBug> vp9_write ( bc , 0 , upd ) ; <S2SV_EndBug> } <S2SV_StartBug> vp9_write ( bc , u , upd ) ; <S2SV_EndBug> if ( u ) { vp9_write_prob_diff_update ( bc , newp , * oldp ) ; * oldp = newp ; } } } } } } if ( updates == 0 ) { <S2SV_StartBug> vp9_write_bit ( bc , 0 ) ; <S2SV_EndBug> } return ; } default : assert ( 0 ) ; } }","void update_coef_probs_common ( vpx_writer <S2SV_ModEnd> * const bc <S2SV_ModStart> vp9_coeff_stats * frame_branch_ct , vp9_coeff_probs_model * new_coef_probs ) { vp9_coeff_probs_model * old_coef_probs = <S2SV_ModEnd> cpi -> common <S2SV_ModStart> common . fc -> coef_probs [ tx_size ] ; const vpx_prob upd = DIFF_UPDATE_PROB ; const int entropy_nodes_update = UNCONSTRAINED_NODES ; int i , j , k , l , t ; int stepsize = cpi -> sf . coeff_prob_appx_step <S2SV_ModEnd> ; switch ( <S2SV_ModStart> t ) { vpx_prob newp = new_coef_probs <S2SV_ModEnd> [ i ] <S2SV_ModStart> ] ; const vpx_prob oldp = old_coef_probs <S2SV_ModEnd> [ i ] <S2SV_ModStart> 0 ] , old_coef_probs <S2SV_ModEnd> [ i ] <S2SV_ModStart> newp , upd , stepsize <S2SV_ModStart> 0 ) { vpx_write_bit <S2SV_ModEnd> ( bc , <S2SV_ModStart> return ; } vpx_write_bit <S2SV_ModEnd> ( bc , <S2SV_ModStart> t ) { vpx_prob newp = new_coef_probs [ i ] [ j ] [ k ] [ l ] [ t ] ; vpx_prob * oldp = old_coef_probs <S2SV_ModEnd> [ i ] <S2SV_ModStart> t ; const vpx_prob <S2SV_ModEnd> upd = DIFF_UPDATE_PROB <S2SV_ModStart> 0 ] , old_coef_probs <S2SV_ModEnd> [ i ] <S2SV_ModStart> newp , upd , stepsize <S2SV_ModStart> = 1 ; vpx_write <S2SV_ModEnd> ( bc , <S2SV_ModStart> return ; } <S2SV_ModEnd> case ONE_LOOP_REDUCED : <S2SV_ModStart> ONE_LOOP_REDUCED : { int updates = 0 ; int noupdates_before_first = 0 ; for ( i = 0 ; i < PLANE_TYPES ; ++ i ) { for ( j = 0 ; j < REF_TYPES ; ++ j ) { for ( k = 0 ; k < COEF_BANDS <S2SV_ModEnd> ; ++ k <S2SV_ModStart> t ) { vpx_prob newp = new_coef_probs [ i ] [ j ] [ k ] [ l ] [ t ] ; vpx_prob * oldp = old_coef_probs <S2SV_ModEnd> [ i ] <S2SV_ModStart> = 0 ; <S2SV_ModEnd> if ( t <S2SV_ModStart> == PIVOT_NODE ) { <S2SV_ModStart> 0 ] , old_coef_probs <S2SV_ModEnd> [ i ] <S2SV_ModStart> newp , upd , stepsize ) ; } else { <S2SV_ModEnd> s = vp9_prob_diff_update_savings_search <S2SV_ModStart> upd ) ; } <S2SV_ModStart> = 1 ; <S2SV_ModEnd> updates += u <S2SV_ModStart> int v ; vpx_write_bit <S2SV_ModEnd> ( bc , <S2SV_ModStart> ++ v ) vpx_write <S2SV_ModEnd> ( bc , <S2SV_ModStart> ) ; } vpx_write <S2SV_ModEnd> ( bc , <S2SV_ModStart> 0 ) { vpx_write_bit <S2SV_ModEnd> ( bc ,"
105,"static krb5_error_code build_principal_va ( krb5_context context , krb5_principal princ , unsigned int rlen , const char * realm , va_list ap ) { krb5_error_code retval = 0 ; char * r = NULL ; krb5_data * data = NULL ; krb5_int32 count = 0 ; krb5_int32 size = 2 ; char * component = NULL ; data = malloc ( size * sizeof ( krb5_data ) ) ; if ( ! data ) { retval = ENOMEM ; } <S2SV_StartBug> if ( ! retval ) { <S2SV_EndBug> r = strdup ( realm ) ; if ( ! r ) { retval = ENOMEM ; } } while ( ! retval && ( component = va_arg ( ap , char * ) ) ) { if ( count == size ) { krb5_data * new_data = NULL ; size *= 2 ; new_data = realloc ( data , size * sizeof ( krb5_data ) ) ; if ( new_data ) { data = new_data ; } else { retval = ENOMEM ; } } if ( ! retval ) { data [ count ] . length = strlen ( component ) ; data [ count ] . data = strdup ( component ) ; if ( ! data [ count ] . data ) { retval = ENOMEM ; } count ++ ; } } if ( ! retval ) { princ -> type = KRB5_NT_UNKNOWN ; princ -> magic = KV5M_PRINCIPAL ; princ -> realm = make_data ( r , rlen ) ; princ -> data = data ; princ -> length = count ; r = NULL ; data = NULL ; } if ( data ) { while ( -- count >= 0 ) { free ( data [ count ] . data ) ; } free ( data ) ; } free ( r ) ; return retval ; }","! retval ) r = k5memdup0 ( realm , rlen , & retval ) ; <S2SV_ModEnd> while ( !"
106,"<S2SV_StartBug> void vp9_fht16x16_sse2 ( const int16_t * input , int16_t * output , <S2SV_EndBug> int stride , int tx_type ) { __m128i in0 [ 16 ] , in1 [ 16 ] ; switch ( tx_type ) { case DCT_DCT : <S2SV_StartBug> vp9_fdct16x16_sse2 ( input , output , stride ) ; <S2SV_EndBug> break ; case ADST_DCT : load_buffer_16x16 ( input , in0 , in1 , stride ) ; fadst16_sse2 ( in0 , in1 ) ; right_shift_16x16 ( in0 , in1 ) ; fdct16_sse2 ( in0 , in1 ) ; write_buffer_16x16 ( output , in0 , in1 , 16 ) ; break ; case DCT_ADST : load_buffer_16x16 ( input , in0 , in1 , stride ) ; fdct16_sse2 ( in0 , in1 ) ; right_shift_16x16 ( in0 , in1 ) ; fadst16_sse2 ( in0 , in1 ) ; write_buffer_16x16 ( output , in0 , in1 , 16 ) ; break ; case ADST_ADST : load_buffer_16x16 ( input , in0 , in1 , stride ) ; fadst16_sse2 ( in0 , in1 ) ; right_shift_16x16 ( in0 , in1 ) ; fadst16_sse2 ( in0 , in1 ) ; write_buffer_16x16 ( output , in0 , in1 , 16 ) ; break ; default : assert ( 0 ) ; break ; } }","* input , tran_low_t <S2SV_ModEnd> * output , <S2SV_ModStart> case DCT_DCT : vpx_fdct16x16_sse2 <S2SV_ModEnd> ( input ,"
107,"av_cold void ff_idctdsp_init ( IDCTDSPContext * c , AVCodecContext * avctx ) { const unsigned high_bit_depth = avctx -> bits_per_raw_sample > 8 ; if ( avctx -> lowres == 1 ) { c -> idct_put = ff_jref_idct4_put ; c -> idct_add = ff_jref_idct4_add ; c -> idct = ff_j_rev_dct4 ; c -> perm_type = FF_IDCT_PERM_NONE ; } else if ( avctx -> lowres == 2 ) { c -> idct_put = ff_jref_idct2_put ; c -> idct_add = ff_jref_idct2_add ; c -> idct = ff_j_rev_dct2 ; c -> perm_type = FF_IDCT_PERM_NONE ; } else if ( avctx -> lowres == 3 ) { c -> idct_put = ff_jref_idct1_put ; c -> idct_add = ff_jref_idct1_add ; c -> idct = ff_j_rev_dct1 ; c -> perm_type = FF_IDCT_PERM_NONE ; } else { if ( avctx -> bits_per_raw_sample == 10 || avctx -> bits_per_raw_sample == 9 ) { <S2SV_StartBug> if ( avctx -> codec_id == AV_CODEC_ID_MPEG4 && avctx -> profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO ) <S2SV_EndBug> c -> idct_put = ff_simple_idct_put_int32_10bit ; else { c -> idct_put = ff_simple_idct_put_int16_10bit ; c -> idct_add = ff_simple_idct_add_int16_10bit ; c -> idct = ff_simple_idct_int16_10bit ; } c -> perm_type = FF_IDCT_PERM_NONE ; } else if ( avctx -> bits_per_raw_sample == 12 ) { c -> idct_put = ff_simple_idct_put_int16_12bit ; c -> idct_add = ff_simple_idct_add_int16_12bit ; c -> idct = ff_simple_idct_int16_12bit ; c -> perm_type = FF_IDCT_PERM_NONE ; } else { if ( avctx -> idct_algo == FF_IDCT_INT ) { c -> idct_put = ff_jref_idct_put ; c -> idct_add = ff_jref_idct_add ; c -> idct = ff_j_rev_dct ; c -> perm_type = FF_IDCT_PERM_LIBMPEG2 ; # if CONFIG_FAANIDCT } else if ( avctx -> idct_algo == FF_IDCT_FAAN ) { c -> idct_put = ff_faanidct_put ; c -> idct_add = ff_faanidct_add ; c -> idct = ff_faanidct ; c -> perm_type = FF_IDCT_PERM_NONE ; # endif } else { c -> idct_put = ff_simple_idct_put_int16_8bit ; c -> idct_add = ff_simple_idct_add_int16_8bit ; c -> idct = ff_simple_idct_int16_8bit ; c -> perm_type = FF_IDCT_PERM_NONE ; } } } c -> put_pixels_clamped = ff_put_pixels_clamped_c ; c -> put_signed_pixels_clamped = put_signed_pixels_clamped_c ; c -> add_pixels_clamped = ff_add_pixels_clamped_c ; if ( CONFIG_MPEG4_DECODER && avctx -> idct_algo == FF_IDCT_XVID ) ff_xvid_idct_init ( c , avctx ) ; if ( ARCH_AARCH64 ) ff_idctdsp_init_aarch64 ( c , avctx , high_bit_depth ) ; if ( ARCH_ALPHA ) ff_idctdsp_init_alpha ( c , avctx , high_bit_depth ) ; if ( ARCH_ARM ) ff_idctdsp_init_arm ( c , avctx , high_bit_depth ) ; if ( ARCH_PPC ) ff_idctdsp_init_ppc ( c , avctx , high_bit_depth ) ; if ( ARCH_X86 ) ff_idctdsp_init_x86 ( c , avctx , high_bit_depth ) ; if ( ARCH_MIPS ) ff_idctdsp_init_mips ( c , avctx , high_bit_depth ) ; ff_init_scantable_permutation ( c -> idct_permutation , c -> perm_type ) ; }",{ if ( c -> mpeg4_studio_profile <S2SV_ModEnd> ) c ->
108,"static void y4m_convert_mono_420jpeg ( y4m_input * _y4m , unsigned char * _dst , unsigned char * _aux ) { <S2SV_StartBug> int c_sz ; <S2SV_EndBug> _dst += _y4m -> pic_w * _y4m -> pic_h ; c_sz = ( ( _y4m -> pic_w + _y4m -> dst_c_dec_h - 1 ) / _y4m -> dst_c_dec_h ) * ( ( _y4m -> pic_h + _y4m -> dst_c_dec_v - 1 ) / _y4m -> dst_c_dec_v ) ; memset ( _dst , 128 , c_sz * 2 ) ; }",{ int c_sz ; ( void ) _aux
109,"int rpmPackageFilesInstall ( rpmts ts , rpmte te , rpmfiles files , rpmpsm psm , char * * failedFile ) { FD_t payload = rpmtePayload ( te ) ; rpmfi fi = rpmfiNewArchiveReader ( payload , files , RPMFI_ITER_READ_ARCHIVE ) ; rpmfs fs = rpmteGetFileStates ( te ) ; rpmPlugins plugins = rpmtsPlugins ( ts ) ; struct stat sb ; int saveerrno = errno ; int rc = 0 ; int nodigest = ( rpmtsFlags ( ts ) & RPMTRANS_FLAG_NOFILEDIGEST ) ? 1 : 0 ; int nofcaps = ( rpmtsFlags ( ts ) & RPMTRANS_FLAG_NOCAPS ) ? 1 : 0 ; int firsthardlink = - 1 ; int skip ; rpmFileAction action ; char * tid = NULL ; const char * suffix ; char * fpath = NULL ; if ( fi == NULL ) { rc = RPMERR_BAD_MAGIC ; goto exit ; } rasprintf ( & tid , "";%08x"" , ( unsigned ) rpmtsGetTid ( ts ) ) ; rc = fsmMkdirs ( files , fs , plugins ) ; while ( ! rc ) { rc = rpmfiNext ( fi ) ; if ( rc < 0 ) { if ( rc == RPMERR_ITER_END ) rc = 0 ; break ; } action = rpmfsGetAction ( fs , rpmfiFX ( fi ) ) ; skip = XFA_SKIPPING ( action ) ; suffix = S_ISDIR ( rpmfiFMode ( fi ) ) ? NULL : tid ; if ( action != FA_TOUCH ) { fpath = fsmFsPath ( fi , suffix ) ; } else { fpath = fsmFsPath ( fi , """" ) ; } rc = rpmfiStat ( fi , 1 , & sb ) ; fsmDebug ( fpath , action , & sb ) ; if ( rc ) break ; rc = rpmpluginsCallFsmFilePre ( plugins , fi , fpath , sb . st_mode , action ) ; if ( rc ) { skip = 1 ; } else { setFileState ( fs , rpmfiFX ( fi ) ) ; } if ( ! skip ) { int setmeta = 1 ; if ( ! suffix ) { rc = fsmBackup ( fi , action ) ; } if ( ! suffix ) { rc = fsmVerify ( fpath , fi ) ; } else { rc = ( action == FA_TOUCH ) ? 0 : RPMERR_ENOENT ; } if ( S_ISREG ( sb . st_mode ) ) { if ( rc == RPMERR_ENOENT ) { rc = fsmMkfile ( fi , fpath , files , psm , nodigest , & setmeta , & firsthardlink ) ; } } else if ( S_ISDIR ( sb . st_mode ) ) { if ( rc == RPMERR_ENOENT ) { mode_t mode = sb . st_mode ; mode &= ~ 07777 ; mode |= 00700 ; rc = fsmMkdir ( fpath , mode ) ; } } else if ( S_ISLNK ( sb . st_mode ) ) { if ( rc == RPMERR_ENOENT ) { rc = fsmSymlink ( rpmfiFLink ( fi ) , fpath ) ; } } else if ( S_ISFIFO ( sb . st_mode ) ) { if ( rc == RPMERR_ENOENT ) { rc = fsmMkfifo ( fpath , 0000 ) ; } } else if ( S_ISCHR ( sb . st_mode ) || S_ISBLK ( sb . st_mode ) || S_ISSOCK ( sb . st_mode ) ) { if ( rc == RPMERR_ENOENT ) { rc = fsmMknod ( fpath , sb . st_mode , sb . st_rdev ) ; } } else { if ( ! IS_DEV_LOG ( fpath ) ) rc = RPMERR_UNKNOWN_FILETYPE ; } if ( ! rc && setmeta ) { rc = fsmSetmeta ( fpath , fi , plugins , action , & sb , nofcaps ) ; } } else if ( firsthardlink >= 0 && rpmfiArchiveHasContent ( fi ) ) { char * fn = rpmfilesFN ( files , firsthardlink ) ; <S2SV_StartBug> rc = expandRegular ( fi , fn , psm , nodigest , 0 ) ; <S2SV_EndBug> firsthardlink = - 1 ; free ( fn ) ; } if ( rc ) { if ( ! skip ) { if ( suffix && ( action != FA_TOUCH ) ) { ( void ) fsmRemove ( fpath , sb . st_mode ) ; } errno = saveerrno ; } } else { rpmpsmNotify ( psm , RPMCALLBACK_INST_PROGRESS , rpmfiArchiveTell ( fi ) ) ; if ( ! skip ) { if ( suffix ) rc = fsmBackup ( fi , action ) ; if ( ! rc ) rc = fsmCommit ( & fpath , fi , action , suffix ) ; } } if ( rc ) * failedFile = xstrdup ( fpath ) ; rpmpluginsCallFsmFilePost ( plugins , fi , fpath , sb . st_mode , action , rc ) ; fpath = _free ( fpath ) ; } rpmswAdd ( rpmtsOp ( ts , RPMTS_OP_UNCOMPRESS ) , fdOp ( payload , FDSTAT_READ ) ) ; rpmswAdd ( rpmtsOp ( ts , RPMTS_OP_DIGEST ) , fdOp ( payload , FDSTAT_DIGEST ) ) ; exit : rpmfiArchiveClose ( fi ) ; rpmfiFree ( fi ) ; Fclose ( payload ) ; free ( tid ) ; free ( fpath ) ; return rc ; }",", psm , 0 ,"
110,"ssize_t cdf_read_short_sector ( const cdf_stream_t * sst , void * buf , size_t offs , size_t len , const cdf_header_t * h , cdf_secid_t id ) { <S2SV_StartBug> size_t ss = CDF_SEC_SIZE ( h ) ; <S2SV_EndBug> size_t pos = CDF_SHORT_SEC_POS ( h , id ) ; assert ( ss == len ) ; <S2SV_StartBug> if ( pos > ss * sst -> sst_len ) { <S2SV_EndBug> DPRINTF ( ( ""Out<S2SV_blank>of<S2SV_blank>bounds<S2SV_blank>read<S2SV_blank>%"" SIZE_T_FORMAT ""u<S2SV_blank>><S2SV_blank>%"" SIZE_T_FORMAT ""u\\n"" , <S2SV_StartBug> pos , ss * sst -> sst_len ) ) ; <S2SV_EndBug> return - 1 ; } ( void ) memcpy ( ( ( char * ) buf ) + offs , ( ( const char * ) sst -> sst_tab ) + pos , len ) ; return len ; }","size_t ss = CDF_SHORT_SEC_SIZE <S2SV_ModEnd> ( h ) <S2SV_ModStart> ( pos > CDF_SEC_SIZE ( h ) <S2SV_ModEnd> * sst -> <S2SV_ModStart> , pos , CDF_SEC_SIZE ( h ) <S2SV_ModEnd> * sst ->"
111,"static int vivid_fb_ioctl ( struct fb_info * info , unsigned cmd , unsigned long arg ) { struct vivid_dev * dev = ( struct vivid_dev * ) info -> par ; switch ( cmd ) { case FBIOGET_VBLANK : { <S2SV_StartBug> struct fb_vblank vblank ; <S2SV_EndBug> vblank . flags = FB_VBLANK_HAVE_COUNT | FB_VBLANK_HAVE_VCOUNT | FB_VBLANK_HAVE_VSYNC ; vblank . count = 0 ; vblank . vcount = 0 ; vblank . hcount = 0 ; if ( copy_to_user ( ( void __user * ) arg , & vblank , sizeof ( vblank ) ) ) return - EFAULT ; return 0 ; } default : dprintk ( dev , 1 , ""Unknown<S2SV_blank>ioctl<S2SV_blank>%08x\\n"" , cmd ) ; return - EINVAL ; } return 0 ; }","struct fb_vblank vblank ; memset ( & vblank , 0 , sizeof ( vblank ) )"
112,"static void ext4_end_io_work ( struct work_struct * work ) { ext4_io_end_t * io = container_of ( work , ext4_io_end_t , work ) ; struct inode * inode = io -> inode ; <S2SV_StartBug> int ret = 0 ; <S2SV_EndBug> mutex_lock ( & inode -> i_mutex ) ; ret = ext4_end_io_nolock ( io ) ; <S2SV_StartBug> if ( ret >= 0 ) { <S2SV_EndBug> if ( ! list_empty ( & io -> list ) ) list_del_init ( & io -> list ) ; <S2SV_StartBug> ext4_free_io_end ( io ) ; <S2SV_EndBug> } mutex_unlock ( & inode -> i_mutex ) ; <S2SV_StartBug> } <S2SV_EndBug>","-> inode ; struct ext4_inode_info * ei = EXT4_I ( inode ) ; unsigned long flags ; int ret <S2SV_ModEnd> ; mutex_lock ( <S2SV_ModStart> if ( ret < <S2SV_ModEnd> 0 ) { <S2SV_ModStart> 0 ) { mutex_unlock ( & inode -> i_mutex ) ; return ; } spin_lock_irqsave ( & ei -> i_completed_io_lock , flags ) ; <S2SV_ModStart> list ) ; spin_unlock_irqrestore ( & ei -> i_completed_io_lock , flags ) ; <S2SV_ModEnd> mutex_unlock ( & <S2SV_ModStart> i_mutex ) ; ext4_free_io_end ( io ) ;"
113,"bool initiate_stratum ( struct pool * pool ) { bool ret = false , recvd = false , noresume = false , sockd = false ; char s [ RBUFSIZE ] , * sret = NULL , * nonce1 , * sessionid ; json_t * val = NULL , * res_val , * err_val ; json_error_t err ; int n2size ; resend : if ( ! setup_stratum_socket ( pool ) ) { applog ( LOG_INFO , ""setup_stratum_socket()<S2SV_blank>on<S2SV_blank>%s<S2SV_blank>failed"" , get_pool_name ( pool ) ) ; sockd = false ; goto out ; } sockd = true ; if ( recvd ) { clear_sock ( pool ) ; sprintf ( s , ""{\\""id\\"":<S2SV_blank>%d,<S2SV_blank>\\""method\\"":<S2SV_blank>\\""mining.subscribe\\"",<S2SV_blank>\\""params\\"":<S2SV_blank>[]}"" , swork_id ++ ) ; } else { if ( pool -> sessionid ) sprintf ( s , ""{\\""id\\"":<S2SV_blank>%d,<S2SV_blank>\\""method\\"":<S2SV_blank>\\""mining.subscribe\\"",<S2SV_blank>\\""params\\"":<S2SV_blank>[\\"""" PACKAGE ""/"" VERSION ""\\"",<S2SV_blank>\\""%s\\""]}"" , swork_id ++ , pool -> sessionid ) ; else sprintf ( s , ""{\\""id\\"":<S2SV_blank>%d,<S2SV_blank>\\""method\\"":<S2SV_blank>\\""mining.subscribe\\"",<S2SV_blank>\\""params\\"":<S2SV_blank>[\\"""" PACKAGE ""/"" VERSION ""\\""]}"" , swork_id ++ ) ; } if ( __stratum_send ( pool , s , strlen ( s ) ) != SEND_OK ) { applog ( LOG_DEBUG , ""Failed<S2SV_blank>to<S2SV_blank>send<S2SV_blank>s<S2SV_blank>in<S2SV_blank>initiate_stratum"" ) ; goto out ; } if ( ! socket_full ( pool , DEFAULT_SOCKWAIT ) ) { applog ( LOG_DEBUG , ""Timed<S2SV_blank>out<S2SV_blank>waiting<S2SV_blank>for<S2SV_blank>response<S2SV_blank>in<S2SV_blank>initiate_stratum"" ) ; goto out ; } sret = recv_line ( pool ) ; if ( ! sret ) goto out ; recvd = true ; val = JSON_LOADS ( sret , & err ) ; free ( sret ) ; if ( ! val ) { applog ( LOG_INFO , ""JSON<S2SV_blank>decode<S2SV_blank>failed(%d):<S2SV_blank>%s"" , err . line , err . text ) ; goto out ; } res_val = json_object_get ( val , ""result"" ) ; err_val = json_object_get ( val , ""error"" ) ; if ( ! res_val || json_is_null ( res_val ) || ( err_val && ! json_is_null ( err_val ) ) ) { char * ss ; if ( err_val ) ss = json_dumps ( err_val , JSON_INDENT ( 3 ) ) ; else ss = strdup ( ""(unknown<S2SV_blank>reason)"" ) ; applog ( LOG_INFO , ""JSON-RPC<S2SV_blank>decode<S2SV_blank>failed:<S2SV_blank>%s"" , ss ) ; free ( ss ) ; goto out ; } sessionid = get_sessionid ( res_val ) ; if ( ! sessionid ) applog ( LOG_DEBUG , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>sessionid<S2SV_blank>in<S2SV_blank>initiate_stratum"" ) ; nonce1 = json_array_string ( res_val , 1 ) ; if ( ! nonce1 ) { applog ( LOG_INFO , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>nonce1<S2SV_blank>in<S2SV_blank>initiate_stratum"" ) ; free ( sessionid ) ; goto out ; } n2size = json_integer_value ( json_array_get ( res_val , 2 ) ) ; <S2SV_StartBug> if ( ! n2size ) { <S2SV_EndBug> applog ( LOG_INFO , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>n2size<S2SV_blank>in<S2SV_blank>initiate_stratum"" ) ; free ( sessionid ) ; free ( nonce1 ) ; goto out ; } cg_wlock ( & pool -> data_lock ) ; pool -> sessionid = sessionid ; pool -> nonce1 = nonce1 ; pool -> n1_len = strlen ( nonce1 ) / 2 ; free ( pool -> nonce1bin ) ; pool -> nonce1bin = ( unsigned char * ) calloc ( pool -> n1_len , 1 ) ; if ( unlikely ( ! pool -> nonce1bin ) ) quithere ( 1 , ""Failed<S2SV_blank>to<S2SV_blank>calloc<S2SV_blank>pool->nonce1bin"" ) ; hex2bin ( pool -> nonce1bin , pool -> nonce1 , pool -> n1_len ) ; pool -> n2size = n2size ; cg_wunlock ( & pool -> data_lock ) ; if ( sessionid ) applog ( LOG_DEBUG , ""%s<S2SV_blank>stratum<S2SV_blank>session<S2SV_blank>id:<S2SV_blank>%s"" , get_pool_name ( pool ) , pool -> sessionid ) ; ret = true ; out : if ( ret ) { if ( ! pool -> stratum_url ) pool -> stratum_url = pool -> sockaddr_url ; pool -> stratum_active = true ; pool -> swork . diff = 1 ; if ( opt_protocol ) { applog ( LOG_DEBUG , ""%s<S2SV_blank>confirmed<S2SV_blank>mining.subscribe<S2SV_blank>with<S2SV_blank>extranonce1<S2SV_blank>%s<S2SV_blank>extran2size<S2SV_blank>%d"" , get_pool_name ( pool ) , pool -> nonce1 , pool -> n2size ) ; } } else { if ( recvd && ! noresume ) { cg_wlock ( & pool -> data_lock ) ; free ( pool -> sessionid ) ; free ( pool -> nonce1 ) ; pool -> sessionid = pool -> nonce1 = NULL ; cg_wunlock ( & pool -> data_lock ) ; applog ( LOG_DEBUG , ""Failed<S2SV_blank>to<S2SV_blank>resume<S2SV_blank>stratum,<S2SV_blank>trying<S2SV_blank>afresh"" ) ; noresume = true ; json_decref ( val ) ; goto resend ; } applog ( LOG_DEBUG , ""Initiating<S2SV_blank>stratum<S2SV_blank>failed<S2SV_blank>on<S2SV_blank>%s"" , get_pool_name ( pool ) ) ; if ( sockd ) { applog ( LOG_DEBUG , ""Suspending<S2SV_blank>stratum<S2SV_blank>on<S2SV_blank>%s"" , get_pool_name ( pool ) ) ; suspend_stratum ( pool ) ; } } json_decref ( val ) ; return ret ; }",; if ( n2size < 1 ) <S2SV_ModEnd> { applog (
114,"void unix_inflight ( struct file * fp ) { struct sock * s = unix_get_socket ( fp ) ; <S2SV_StartBug> if ( s ) { <S2SV_EndBug> <S2SV_StartBug> struct unix_sock * u = unix_sk ( s ) ; <S2SV_EndBug> spin_lock ( & unix_gc_lock ) ; if ( atomic_long_inc_return ( & u -> inflight ) == 1 ) { BUG_ON ( ! list_empty ( & u -> link ) ) ; list_add_tail ( & u -> link , & gc_inflight_list ) ; } else { BUG_ON ( list_empty ( & u -> link ) ) ; } unix_tot_inflight ++ ; <S2SV_StartBug> spin_unlock ( & unix_gc_lock ) ; <S2SV_EndBug> } <S2SV_StartBug> } <S2SV_EndBug>",fp ) ; spin_lock ( & unix_gc_lock ) ; <S2SV_ModStart> unix_sk ( s <S2SV_ModEnd> ) ; if <S2SV_ModStart> unix_tot_inflight ++ ; } fp -> f_cred -> user -> unix_inflight ++ ; <S2SV_ModStart> ) ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
115,"static BOOL GetStartupData ( HANDLE pipe , STARTUP_DATA * sud ) { size_t size , len ; <S2SV_StartBug> BOOL ret = FALSE ; <S2SV_EndBug> WCHAR * data = NULL ; DWORD bytes , read ; bytes = PeekNamedPipeAsync ( pipe , 1 , & exit_event ) ; if ( bytes == 0 ) { MsgToEventLog ( M_SYSERR , TEXT ( ""PeekNamedPipeAsync<S2SV_blank>failed"" ) ) ; ReturnLastError ( pipe , L""PeekNamedPipeAsync"" ) ; <S2SV_StartBug> goto out ; <S2SV_EndBug> } size = bytes / sizeof ( * data ) ; if ( size == 0 ) { MsgToEventLog ( M_SYSERR , TEXT ( ""malformed<S2SV_blank>startup<S2SV_blank>data:<S2SV_blank>1<S2SV_blank>byte<S2SV_blank>received"" ) ) ; ReturnError ( pipe , ERROR_STARTUP_DATA , L""GetStartupData"" , 1 , & exit_event ) ; <S2SV_StartBug> goto out ; <S2SV_EndBug> } data = malloc ( bytes ) ; if ( data == NULL ) { MsgToEventLog ( M_SYSERR , TEXT ( ""malloc<S2SV_blank>failed"" ) ) ; ReturnLastError ( pipe , L""malloc"" ) ; <S2SV_StartBug> goto out ; <S2SV_EndBug> } read = ReadPipeAsync ( pipe , data , bytes , 1 , & exit_event ) ; if ( bytes != read ) { MsgToEventLog ( M_SYSERR , TEXT ( ""ReadPipeAsync<S2SV_blank>failed"" ) ) ; ReturnLastError ( pipe , L""ReadPipeAsync"" ) ; <S2SV_StartBug> goto out ; <S2SV_EndBug> } if ( data [ size - 1 ] != 0 ) { MsgToEventLog ( M_ERR , TEXT ( ""Startup<S2SV_blank>data<S2SV_blank>is<S2SV_blank>not<S2SV_blank>NULL<S2SV_blank>terminated"" ) ) ; ReturnError ( pipe , ERROR_STARTUP_DATA , L""GetStartupData"" , 1 , & exit_event ) ; <S2SV_StartBug> goto out ; <S2SV_EndBug> } sud -> directory = data ; len = wcslen ( sud -> directory ) + 1 ; size -= len ; if ( size <= 0 ) { MsgToEventLog ( M_ERR , TEXT ( ""Startup<S2SV_blank>data<S2SV_blank>ends<S2SV_blank>at<S2SV_blank>working<S2SV_blank>directory"" ) ) ; ReturnError ( pipe , ERROR_STARTUP_DATA , L""GetStartupData"" , 1 , & exit_event ) ; <S2SV_StartBug> goto out ; <S2SV_EndBug> } sud -> options = sud -> directory + len ; len = wcslen ( sud -> options ) + 1 ; size -= len ; if ( size <= 0 ) { MsgToEventLog ( M_ERR , TEXT ( ""Startup<S2SV_blank>data<S2SV_blank>ends<S2SV_blank>at<S2SV_blank>command<S2SV_blank>line<S2SV_blank>options"" ) ) ; ReturnError ( pipe , ERROR_STARTUP_DATA , L""GetStartupData"" , 1 , & exit_event ) ; <S2SV_StartBug> goto out ; <S2SV_EndBug> } sud -> std_input = sud -> options + len ; <S2SV_StartBug> data = NULL ; <S2SV_EndBug> <S2SV_StartBug> ret = TRUE ; <S2SV_EndBug> out : free ( data ) ; <S2SV_StartBug> return ret ; <S2SV_EndBug> }",", len ; <S2SV_ModEnd> WCHAR * data <S2SV_ModStart> ) ; goto err <S2SV_ModEnd> ; } size <S2SV_ModStart> ) ; goto err <S2SV_ModEnd> ; } data <S2SV_ModStart> ) ; goto err <S2SV_ModEnd> ; } read <S2SV_ModStart> ) ; goto err <S2SV_ModEnd> ; } if <S2SV_ModStart> ) ; goto err <S2SV_ModEnd> ; } sud <S2SV_ModStart> ) ; goto err <S2SV_ModEnd> ; } sud <S2SV_ModStart> ) ; goto err <S2SV_ModEnd> ; } sud <S2SV_ModStart> + len ; return TRUE ; err : sud -> directory <S2SV_ModEnd> = NULL ; <S2SV_ModStart> = NULL ; <S2SV_ModEnd> free ( data <S2SV_ModStart> ) ; return FALSE <S2SV_ModEnd> ; } <S2SV_null>"
116,"static void process_secondary_order ( STREAM s ) { uint16 length ; uint16 flags ; uint8 type ; uint8 * next_order ; <S2SV_StartBug> in_uint16_le ( s , length ) ; <S2SV_EndBug> in_uint16_le ( s , flags ) ; <S2SV_StartBug> in_uint8 ( s , type ) ; <S2SV_EndBug> next_order = s -> p + ( sint16 ) length + 7 ; switch ( type ) { case RDP_ORDER_RAW_BMPCACHE : process_raw_bmpcache ( s ) ; break ; case RDP_ORDER_COLCACHE : process_colcache ( s ) ; break ; case RDP_ORDER_BMPCACHE : process_bmpcache ( s ) ; break ; case RDP_ORDER_FONTCACHE : process_fontcache ( s ) ; break ; case RDP_ORDER_RAW_BMPCACHE2 : process_bmpcache2 ( s , flags , False ) ; break ; case RDP_ORDER_BMPCACHE2 : process_bmpcache2 ( s , flags , True ) ; break ; case RDP_ORDER_BRUSHCACHE : process_brushcache ( s , flags ) ; break ; default : logger ( Graphics , Warning , ""process_secondary_order(),<S2SV_blank>unhandled<S2SV_blank>secondary<S2SV_blank>order<S2SV_blank>%d"" , type ) ; } s -> p = next_order ; }","* next_order ; struct stream packet = * s ; <S2SV_ModStart> type ) ; if ( ! s_check_rem ( s , length + 7 ) ) { rdp_protocol_error ( ""process_secondary_order(),<S2SV_blank>next<S2SV_blank>order<S2SV_blank>pointer<S2SV_blank>would<S2SV_blank>overrun<S2SV_blank>stream"" , & packet ) ; }"
117,"static void set_rate_correction_factor ( VP9_COMP * cpi , double factor ) { <S2SV_StartBug> if ( cpi -> common . frame_type == KEY_FRAME ) { <S2SV_EndBug> <S2SV_StartBug> cpi -> rc . key_frame_rate_correction_factor = factor ; <S2SV_EndBug> } else { if ( ( cpi -> refresh_alt_ref_frame || cpi -> refresh_golden_frame ) && <S2SV_StartBug> ! cpi -> rc . is_src_frame_alt_ref && <S2SV_EndBug> <S2SV_StartBug> ! ( cpi -> use_svc && cpi -> oxcf . end_usage == USAGE_STREAM_FROM_SERVER ) ) <S2SV_EndBug> cpi -> rc . gf_rate_correction_factor = factor ; else <S2SV_StartBug> cpi -> rc . rate_correction_factor = factor ; <S2SV_EndBug> } }","factor ) { RATE_CONTROL * const rc = & cpi -> rc ; factor /= rcf_mult [ cpi -> rc . frame_size_selector ] ; factor = fclamp ( factor , MIN_BPB_FACTOR , MAX_BPB_FACTOR ) ; <S2SV_ModStart> KEY_FRAME ) { rc -> rate_correction_factors [ KF_STD ] = factor ; } else if ( cpi -> oxcf . pass == 2 ) { RATE_FACTOR_LEVEL rf_lvl = cpi -> twopass . gf_group . rf_level [ cpi -> twopass . gf_group . index ] ; rc -> rate_correction_factors [ rf_lvl ] <S2SV_ModEnd> = factor ; <S2SV_ModStart> ) && ! rc -> <S2SV_ModEnd> is_src_frame_alt_ref && ! <S2SV_ModStart> is_src_frame_alt_ref && ! <S2SV_ModEnd> cpi -> use_svc <S2SV_ModStart> -> use_svc && ( <S2SV_ModStart> -> oxcf . rc_mode != VPX_CBR || cpi -> oxcf . gf_cbr_boost_pct > 20 ) ) rc -> rate_correction_factors [ GF_ARF_STD ] <S2SV_ModEnd> = factor ; <S2SV_ModStart> factor ; else rc -> rate_correction_factors [ INTER_NORMAL ] <S2SV_ModEnd> = factor ;"
118,"static int snd_timer_user_open ( struct inode * inode , struct file * file ) { struct snd_timer_user * tu ; int err ; err = nonseekable_open ( inode , file ) ; if ( err < 0 ) return err ; tu = kzalloc ( sizeof ( * tu ) , GFP_KERNEL ) ; if ( tu == NULL ) return - ENOMEM ; spin_lock_init ( & tu -> qlock ) ; init_waitqueue_head ( & tu -> qchange_sleep ) ; <S2SV_StartBug> mutex_init ( & tu -> tread_sem ) ; <S2SV_EndBug> tu -> ticks = 1 ; tu -> queue_size = 128 ; tu -> queue = kmalloc ( tu -> queue_size * sizeof ( struct snd_timer_read ) , GFP_KERNEL ) ; if ( tu -> queue == NULL ) { kfree ( tu ) ; return - ENOMEM ; } file -> private_data = tu ; return 0 ; }",& tu -> ioctl_lock <S2SV_ModEnd> ) ; tu
119,"WORD32 ih264d_parse_decode_slice ( UWORD8 u1_is_idr_slice , UWORD8 u1_nal_ref_idc , dec_struct_t * ps_dec ) { dec_bit_stream_t * ps_bitstrm = ps_dec -> ps_bitstrm ; dec_pic_params_t * ps_pps ; dec_seq_params_t * ps_seq ; dec_slice_params_t * ps_cur_slice = ps_dec -> ps_cur_slice ; pocstruct_t s_tmp_poc ; WORD32 i_delta_poc [ 2 ] ; WORD32 i4_poc = 0 ; UWORD16 u2_first_mb_in_slice , u2_frame_num ; UWORD8 u1_field_pic_flag , u1_redundant_pic_cnt = 0 , u1_slice_type ; UWORD32 u4_idr_pic_id = 0 ; UWORD8 u1_bottom_field_flag , u1_pic_order_cnt_type ; UWORD8 u1_nal_unit_type ; UWORD32 * pu4_bitstrm_buf = ps_bitstrm -> pu4_buffer ; UWORD32 * pu4_bitstrm_ofst = & ps_bitstrm -> u4_ofst ; WORD8 i1_is_end_of_poc ; WORD32 ret , end_of_frame ; WORD32 prev_slice_err , num_mb_skipped ; UWORD8 u1_mbaff ; pocstruct_t * ps_cur_poc ; UWORD32 u4_temp ; WORD32 i_temp ; UWORD32 u4_call_end_of_pic = 0 ; ps_dec -> ps_dpb_cmds -> u1_dpb_commands_read_slc = 0 ; u2_first_mb_in_slice = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u2_first_mb_in_slice > ( ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) ) { return ERROR_CORRUPTED_SLICE ; } if ( ( ( u2_first_mb_in_slice << ps_cur_slice -> u1_mbaff_frame_flag ) <= ps_dec -> u2_cur_mb_addr ) && ( ps_dec -> u4_first_slice_in_pic == 0 ) ) { return ERROR_CORRUPTED_SLICE ; } COPYTHECONTEXT ( ""SH:<S2SV_blank>first_mb_in_slice"" , u2_first_mb_in_slice ) ; u4_temp = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u4_temp > 9 ) return ERROR_INV_SLC_TYPE_T ; u1_slice_type = u4_temp ; COPYTHECONTEXT ( ""SH:<S2SV_blank>slice_type"" , ( u1_slice_type ) ) ; if ( u1_slice_type > 4 ) { u1_slice_type -= 5 ; } { UWORD32 skip ; if ( ( ps_dec -> i4_app_skip_mode == IVD_SKIP_PB ) || ( ps_dec -> i4_dec_skip_mode == IVD_SKIP_PB ) ) { UWORD32 u4_bit_stream_offset = 0 ; if ( ps_dec -> u1_nal_unit_type == IDR_SLICE_NAL ) { skip = 0 ; ps_dec -> i4_dec_skip_mode = IVD_SKIP_NONE ; } else if ( ( I_SLICE == u1_slice_type ) && ( 1 >= ps_dec -> ps_cur_sps -> u1_num_ref_frames ) ) { skip = 0 ; ps_dec -> i4_dec_skip_mode = IVD_SKIP_NONE ; } else { skip = 1 ; } if ( ( 0 == u2_first_mb_in_slice ) && ( 1 == ps_dec -> u4_prev_nal_skipped ) ) { skip = 0 ; } if ( skip ) { ps_dec -> u4_prev_nal_skipped = 1 ; ps_dec -> i4_dec_skip_mode = IVD_SKIP_PB ; return 0 ; } else { if ( 1 == ps_dec -> u4_prev_nal_skipped ) { ps_dec -> u4_return_to_app = 1 ; return 0 ; } } } } u4_temp = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u4_temp & MASK_ERR_PIC_SET_ID ) return ERROR_INV_SLICE_HDR_T ; COPYTHECONTEXT ( ""SH:<S2SV_blank>pic_parameter_set_id"" , u4_temp ) ; ps_pps = & ps_dec -> ps_pps [ u4_temp ] ; if ( FALSE == ps_pps -> u1_is_valid ) { return ERROR_INV_SLICE_HDR_T ; } ps_seq = ps_pps -> ps_sps ; if ( ! ps_seq ) return ERROR_INV_SLICE_HDR_T ; if ( FALSE == ps_seq -> u1_is_valid ) return ERROR_INV_SLICE_HDR_T ; u2_frame_num = ih264d_get_bits_h264 ( ps_bitstrm , ps_seq -> u1_bits_in_frm_num ) ; COPYTHECONTEXT ( ""SH:<S2SV_blank>frame_num"" , u2_frame_num ) ; if ( ! ps_dec -> u1_first_slice_in_stream && ps_dec -> u4_first_slice_in_pic ) { pocstruct_t * ps_prev_poc = & ps_dec -> s_prev_pic_poc ; pocstruct_t * ps_cur_poc = & ps_dec -> s_cur_pic_poc ; ps_dec -> u2_mbx = 0xffff ; ps_dec -> u2_mby = 0 ; if ( ( 0 == u1_is_idr_slice ) && ps_cur_slice -> u1_nal_ref_idc ) ps_dec -> u2_prev_ref_frame_num = ps_cur_slice -> u2_frame_num ; if ( u1_is_idr_slice || ps_cur_slice -> u1_mmco_equalto5 ) ps_dec -> u2_prev_ref_frame_num = 0 ; if ( ps_dec -> ps_cur_sps -> u1_gaps_in_frame_num_value_allowed_flag ) { ih264d_decode_gaps_in_frame_num ( ps_dec , u2_frame_num ) ; } ps_prev_poc -> i4_prev_frame_num_ofst = ps_cur_poc -> i4_prev_frame_num_ofst ; ps_prev_poc -> u2_frame_num = ps_cur_poc -> u2_frame_num ; ps_prev_poc -> u1_mmco_equalto5 = ps_cur_slice -> u1_mmco_equalto5 ; if ( ps_cur_slice -> u1_nal_ref_idc ) { ps_prev_poc -> i4_pic_order_cnt_lsb = ps_cur_poc -> i4_pic_order_cnt_lsb ; ps_prev_poc -> i4_pic_order_cnt_msb = ps_cur_poc -> i4_pic_order_cnt_msb ; ps_prev_poc -> i4_delta_pic_order_cnt_bottom = ps_cur_poc -> i4_delta_pic_order_cnt_bottom ; ps_prev_poc -> i4_delta_pic_order_cnt [ 0 ] = ps_cur_poc -> i4_delta_pic_order_cnt [ 0 ] ; ps_prev_poc -> i4_delta_pic_order_cnt [ 1 ] = ps_cur_poc -> i4_delta_pic_order_cnt [ 1 ] ; ps_prev_poc -> u1_bot_field = ps_cur_poc -> u1_bot_field ; } ps_dec -> u2_total_mbs_coded = 0 ; } if ( ! ps_seq -> u1_frame_mbs_only_flag ) { u1_field_pic_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( ""SH:<S2SV_blank>field_pic_flag"" , u1_field_pic_flag ) ; u1_bottom_field_flag = 0 ; if ( u1_field_pic_flag ) { ps_dec -> pu1_inv_scan = ( UWORD8 * ) gau1_ih264d_inv_scan_fld ; u1_bottom_field_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( ""SH:<S2SV_blank>bottom_field_flag"" , u1_bottom_field_flag ) ; } else { ps_dec -> pu1_inv_scan = ( UWORD8 * ) gau1_ih264d_inv_scan ; } } else { u1_field_pic_flag = 0 ; u1_bottom_field_flag = 0 ; ps_dec -> pu1_inv_scan = ( UWORD8 * ) gau1_ih264d_inv_scan ; } u1_nal_unit_type = SLICE_NAL ; if ( u1_is_idr_slice ) { u1_nal_unit_type = IDR_SLICE_NAL ; u4_idr_pic_id = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u4_idr_pic_id > 65535 ) return ERROR_INV_SLICE_HDR_T ; COPYTHECONTEXT ( ""SH:<S2SV_blank><S2SV_blank>"" , u4_idr_pic_id ) ; } i_delta_poc [ 0 ] = i_delta_poc [ 1 ] = 0 ; s_tmp_poc . i4_pic_order_cnt_lsb = 0 ; s_tmp_poc . i4_delta_pic_order_cnt_bottom = 0 ; u1_pic_order_cnt_type = ps_seq -> u1_pic_order_cnt_type ; if ( u1_pic_order_cnt_type == 0 ) { i_temp = ih264d_get_bits_h264 ( ps_bitstrm , ps_seq -> u1_log2_max_pic_order_cnt_lsb_minus ) ; if ( i_temp < 0 || i_temp >= ps_seq -> i4_max_pic_order_cntLsb ) return ERROR_INV_SLICE_HDR_T ; s_tmp_poc . i4_pic_order_cnt_lsb = i_temp ; COPYTHECONTEXT ( ""SH:<S2SV_blank>pic_order_cnt_lsb"" , s_tmp_poc . i4_pic_order_cnt_lsb ) ; if ( ( ps_pps -> u1_pic_order_present_flag == 1 ) && ( ! u1_field_pic_flag ) ) { s_tmp_poc . i4_delta_pic_order_cnt_bottom = ih264d_sev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; COPYTHECONTEXT ( ""SH:<S2SV_blank>delta_pic_order_cnt_bottom"" , s_tmp_poc . i4_delta_pic_order_cnt_bottom ) ; } } s_tmp_poc . i4_delta_pic_order_cnt [ 0 ] = 0 ; s_tmp_poc . i4_delta_pic_order_cnt [ 1 ] = 0 ; if ( u1_pic_order_cnt_type == 1 && ( ! ps_seq -> u1_delta_pic_order_always_zero_flag ) ) { s_tmp_poc . i4_delta_pic_order_cnt [ 0 ] = ih264d_sev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; COPYTHECONTEXT ( ""SH:<S2SV_blank>delta_pic_order_cnt[0]"" , s_tmp_poc . i4_delta_pic_order_cnt [ 0 ] ) ; if ( ps_pps -> u1_pic_order_present_flag && ! u1_field_pic_flag ) { s_tmp_poc . i4_delta_pic_order_cnt [ 1 ] = ih264d_sev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; COPYTHECONTEXT ( ""SH:<S2SV_blank>delta_pic_order_cnt[1]"" , s_tmp_poc . i4_delta_pic_order_cnt [ 1 ] ) ; } } if ( ps_pps -> u1_redundant_pic_cnt_present_flag ) { u4_temp = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u4_temp > MAX_REDUNDANT_PIC_CNT ) return ERROR_INV_SLICE_HDR_T ; u1_redundant_pic_cnt = u4_temp ; COPYTHECONTEXT ( ""SH:<S2SV_blank>redundant_pic_cnt"" , u1_redundant_pic_cnt ) ; } i1_is_end_of_poc = 1 ; ps_dec -> ps_dec_err_status -> u1_err_flag &= MASK_REJECT_CUR_PIC ; if ( ps_dec -> u4_first_slice_in_pic == 0 ) { i1_is_end_of_poc = ih264d_is_end_of_pic ( u2_frame_num , u1_nal_ref_idc , & s_tmp_poc , & ps_dec -> s_cur_pic_poc , ps_cur_slice , u1_pic_order_cnt_type , u1_nal_unit_type , u4_idr_pic_id , u1_field_pic_flag , u1_bottom_field_flag ) ; if ( i1_is_end_of_poc ) { ps_dec -> u1_first_slice_in_stream = 0 ; return ERROR_INCOMPLETE_FRAME ; } } u1_mbaff = ps_seq -> u1_mb_aff_flag && ( ! u1_field_pic_flag ) ; prev_slice_err = 0 ; if ( i1_is_end_of_poc || ps_dec -> u1_first_slice_in_stream ) { if ( u2_frame_num != ps_dec -> u2_prv_frame_num && ps_dec -> u1_top_bottom_decoded != 0 && ps_dec -> u1_top_bottom_decoded != ( TOP_FIELD_ONLY | BOT_FIELD_ONLY ) ) { ps_dec -> u1_dangling_field = 1 ; if ( ps_dec -> u4_first_slice_in_pic ) { prev_slice_err = 1 ; } else { prev_slice_err = 2 ; } if ( ps_dec -> u1_top_bottom_decoded == TOP_FIELD_ONLY ) ps_cur_slice -> u1_bottom_field_flag = 1 ; else ps_cur_slice -> u1_bottom_field_flag = 0 ; num_mb_skipped = ( ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) - ps_dec -> u2_total_mbs_coded ; ps_cur_poc = & ps_dec -> s_cur_pic_poc ; u1_is_idr_slice = ps_cur_slice -> u1_nal_unit_type == IDR_SLICE_NAL ; } else if ( ps_dec -> u4_first_slice_in_pic ) { if ( u2_first_mb_in_slice > 0 ) { prev_slice_err = 1 ; num_mb_skipped = u2_first_mb_in_slice << u1_mbaff ; ps_cur_poc = & s_tmp_poc ; ps_cur_slice -> u4_idr_pic_id = u4_idr_pic_id ; ps_cur_slice -> u1_field_pic_flag = u1_field_pic_flag ; ps_cur_slice -> u1_bottom_field_flag = u1_bottom_field_flag ; ps_cur_slice -> i4_pic_order_cnt_lsb = s_tmp_poc . i4_pic_order_cnt_lsb ; ps_cur_slice -> u1_nal_unit_type = u1_nal_unit_type ; ps_cur_slice -> u1_redundant_pic_cnt = u1_redundant_pic_cnt ; ps_cur_slice -> u1_nal_ref_idc = u1_nal_ref_idc ; ps_cur_slice -> u1_pic_order_cnt_type = u1_pic_order_cnt_type ; ps_cur_slice -> u1_mbaff_frame_flag = ps_seq -> u1_mb_aff_flag && ( ! u1_field_pic_flag ) ; } } else { prev_slice_err = 2 ; num_mb_skipped = ( ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) - ps_dec -> u2_total_mbs_coded ; ps_cur_poc = & s_tmp_poc ; } } else { if ( ( u2_first_mb_in_slice << u1_mbaff ) > ps_dec -> u2_total_mbs_coded ) { prev_slice_err = 2 ; num_mb_skipped = ( u2_first_mb_in_slice << u1_mbaff ) - ps_dec -> u2_total_mbs_coded ; ps_cur_poc = & s_tmp_poc ; } else if ( ( u2_first_mb_in_slice << u1_mbaff ) < ps_dec -> u2_total_mbs_coded ) { return ERROR_CORRUPTED_SLICE ; } } if ( prev_slice_err ) { ret = ih264d_mark_err_slice_skip ( ps_dec , num_mb_skipped , u1_is_idr_slice , u2_frame_num , ps_cur_poc , prev_slice_err ) ; if ( ps_dec -> u1_dangling_field == 1 ) { ps_dec -> u1_second_field = 1 - ps_dec -> u1_second_field ; ps_dec -> u1_first_slice_in_stream = 0 ; ps_dec -> u1_top_bottom_decoded = TOP_FIELD_ONLY | BOT_FIELD_ONLY ; return ERROR_DANGLING_FIELD_IN_PIC ; } if ( prev_slice_err == 2 ) { ps_dec -> u1_first_slice_in_stream = 0 ; return ERROR_INCOMPLETE_FRAME ; } if ( ps_dec -> u2_total_mbs_coded >= ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) { ps_dec -> u1_first_slice_in_stream = 0 ; return ERROR_IN_LAST_SLICE_OF_PIC ; } if ( ps_dec -> ps_dec_err_status -> u1_err_flag & REJECT_CUR_PIC ) { ih264d_err_pic_dispbuf_mgr ( ps_dec ) ; return ERROR_NEW_FRAME_EXPECTED ; } if ( ret != OK ) return ret ; i1_is_end_of_poc = 0 ; } if ( ps_dec -> u4_first_slice_in_pic == 0 ) { ps_dec -> ps_parse_cur_slice ++ ; ps_dec -> u2_cur_slice_num ++ ; } if ( ( ps_dec -> u1_separate_parse == 0 ) && ( ps_dec -> u4_first_slice_in_pic == 0 ) ) { ps_dec -> ps_decode_cur_slice ++ ; } ps_dec -> u1_slice_header_done = 0 ; if ( u1_field_pic_flag ) { ps_dec -> u2_prv_frame_num = u2_frame_num ; } if ( ps_cur_slice -> u1_mmco_equalto5 ) { WORD32 i4_temp_poc ; WORD32 i4_top_field_order_poc , i4_bot_field_order_poc ; if ( ! ps_cur_slice -> u1_field_pic_flag ) { i4_top_field_order_poc = ps_dec -> ps_cur_pic -> i4_top_field_order_cnt ; i4_bot_field_order_poc = ps_dec -> ps_cur_pic -> i4_bottom_field_order_cnt ; i4_temp_poc = MIN ( i4_top_field_order_poc , i4_bot_field_order_poc ) ; } else if ( ! ps_cur_slice -> u1_bottom_field_flag ) i4_temp_poc = ps_dec -> ps_cur_pic -> i4_top_field_order_cnt ; else i4_temp_poc = ps_dec -> ps_cur_pic -> i4_bottom_field_order_cnt ; ps_dec -> ps_cur_pic -> i4_top_field_order_cnt = i4_temp_poc - ps_dec -> ps_cur_pic -> i4_top_field_order_cnt ; ps_dec -> ps_cur_pic -> i4_bottom_field_order_cnt = i4_temp_poc - ps_dec -> ps_cur_pic -> i4_bottom_field_order_cnt ; ps_dec -> ps_cur_pic -> i4_poc = i4_temp_poc ; ps_dec -> ps_cur_pic -> i4_avg_poc = i4_temp_poc ; } if ( ps_dec -> u4_first_slice_in_pic ) { ret = ih264d_decode_pic_order_cnt ( u1_is_idr_slice , u2_frame_num , & ps_dec -> s_prev_pic_poc , & s_tmp_poc , ps_cur_slice , ps_pps , u1_nal_ref_idc , u1_bottom_field_flag , u1_field_pic_flag , & i4_poc ) ; if ( ret != OK ) return ret ; if ( i4_poc >= ps_dec -> i4_max_poc ) ps_dec -> i4_max_poc = i4_poc ; if ( i4_poc == 0 ) { ps_dec -> i4_prev_max_display_seq = ps_dec -> i4_prev_max_display_seq + ps_dec -> i4_max_poc + ps_dec -> u1_max_dec_frame_buffering + 1 ; ps_dec -> i4_max_poc = 0 ; } } ps_cur_slice -> i4_delta_pic_order_cnt [ 0 ] = i_delta_poc [ 0 ] ; ps_cur_slice -> i4_delta_pic_order_cnt [ 1 ] = i_delta_poc [ 1 ] ; ps_cur_slice -> u4_idr_pic_id = u4_idr_pic_id ; ps_cur_slice -> u2_first_mb_in_slice = u2_first_mb_in_slice ; ps_cur_slice -> u1_field_pic_flag = u1_field_pic_flag ; ps_cur_slice -> u1_bottom_field_flag = u1_bottom_field_flag ; ps_cur_slice -> u1_slice_type = u1_slice_type ; ps_cur_slice -> i4_pic_order_cnt_lsb = s_tmp_poc . i4_pic_order_cnt_lsb ; ps_cur_slice -> u1_nal_unit_type = u1_nal_unit_type ; ps_cur_slice -> u1_redundant_pic_cnt = u1_redundant_pic_cnt ; ps_cur_slice -> u1_nal_ref_idc = u1_nal_ref_idc ; ps_cur_slice -> u1_pic_order_cnt_type = u1_pic_order_cnt_type ; if ( ps_seq -> u1_frame_mbs_only_flag ) ps_cur_slice -> u1_direct_8x8_inference_flag = ps_seq -> u1_direct_8x8_inference_flag ; else ps_cur_slice -> u1_direct_8x8_inference_flag = 1 ; if ( u1_slice_type == B_SLICE ) { ps_cur_slice -> u1_direct_spatial_mv_pred_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( ""SH:<S2SV_blank>direct_spatial_mv_pred_flag"" , ps_cur_slice -> u1_direct_spatial_mv_pred_flag ) ; if ( ps_cur_slice -> u1_direct_spatial_mv_pred_flag ) ps_cur_slice -> pf_decodeDirect = ih264d_decode_spatial_direct ; else ps_cur_slice -> pf_decodeDirect = ih264d_decode_temporal_direct ; if ( ! ( ( ps_pps -> ps_sps -> u1_mb_aff_flag ) && ( ! u1_field_pic_flag ) ) ) ps_dec -> pf_mvpred = ih264d_mvpred_nonmbaffB ; } else { if ( ! ( ( ps_pps -> ps_sps -> u1_mb_aff_flag ) && ( ! u1_field_pic_flag ) ) ) ps_dec -> pf_mvpred = ih264d_mvpred_nonmbaff ; } if ( ps_dec -> u4_first_slice_in_pic ) { if ( u2_first_mb_in_slice == 0 ) { ret = ih264d_start_of_pic ( ps_dec , i4_poc , & s_tmp_poc , u2_frame_num , ps_pps ) ; if ( ret != OK ) return ret ; } ps_dec -> u4_output_present = 0 ; { ih264d_get_next_display_field ( ps_dec , ps_dec -> ps_out_buffer , & ( ps_dec -> s_disp_op ) ) ; if ( 0 != ps_dec -> s_disp_op . u4_error_code ) { ps_dec -> u4_fmt_conv_cur_row = ps_dec -> s_disp_frame_info . u4_y_ht ; } else ps_dec -> u4_output_present = 1 ; } if ( ps_dec -> u1_separate_parse == 1 ) { if ( ps_dec -> u4_dec_thread_created == 0 ) { ithread_create ( ps_dec -> pv_dec_thread_handle , NULL , ( void * ) ih264d_decode_picture_thread , ( void * ) ps_dec ) ; ps_dec -> u4_dec_thread_created = 1 ; } if ( ( ps_dec -> u4_num_cores == 3 ) && ( ( ps_dec -> u4_app_disable_deblk_frm == 0 ) || ps_dec -> i1_recon_in_thread3_flag ) && ( ps_dec -> u4_bs_deblk_thread_created == 0 ) ) { ps_dec -> u4_start_recon_deblk = 0 ; ithread_create ( ps_dec -> pv_bs_deblk_thread_handle , NULL , ( void * ) ih264d_recon_deblk_thread , ( void * ) ps_dec ) ; ps_dec -> u4_bs_deblk_thread_created = 1 ; } } } { UWORD8 uc_nofield_nombaff ; uc_nofield_nombaff = ( ( ps_dec -> ps_cur_slice -> u1_field_pic_flag == 0 ) && ( ps_dec -> ps_cur_slice -> u1_mbaff_frame_flag == 0 ) && ( u1_slice_type != B_SLICE ) && ( ps_dec -> ps_cur_pps -> u1_wted_pred_flag == 0 ) ) ; if ( uc_nofield_nombaff ) { ps_dec -> p_form_mb_part_info = ih264d_form_mb_part_info_bp ; ps_dec -> p_motion_compensate = ih264d_motion_compensate_bp ; } else { ps_dec -> p_form_mb_part_info = ih264d_form_mb_part_info_mp ; ps_dec -> p_motion_compensate = ih264d_motion_compensate_mp ; } } { dec_err_status_t * ps_err = ps_dec -> ps_dec_err_status ; if ( ps_err -> u4_frm_sei_sync == u2_frame_num ) { ps_err -> u1_err_flag = ACCEPT_ALL_PICS ; ps_err -> u4_frm_sei_sync = SYNC_FRM_DEFAULT ; } ps_err -> u4_cur_frm = u2_frame_num ; } { WORD32 i4_skip_b_pic , i4_skip_p_pic ; i4_skip_b_pic = ( ps_dec -> u4_skip_frm_mask & B_SLC_BIT ) && ( B_SLICE == u1_slice_type ) && ( 0 == u1_nal_ref_idc ) ; i4_skip_p_pic = ( ps_dec -> u4_skip_frm_mask & P_SLC_BIT ) && ( P_SLICE == u1_slice_type ) && ( 0 == u1_nal_ref_idc ) ; if ( i4_skip_b_pic ) { ps_dec -> ps_cur_pic -> u4_pack_slc_typ |= B_SLC_BIT ; ps_dec -> u1_last_pic_not_decoded = 1 ; return OK ; } if ( i4_skip_p_pic ) { ps_dec -> ps_cur_pic -> u4_pack_slc_typ |= P_SLC_BIT ; ps_dec -> u1_last_pic_not_decoded = 1 ; return OK ; } } { UWORD16 u2_mb_x , u2_mb_y ; ps_dec -> i4_submb_ofst = ( ( u2_first_mb_in_slice << ps_cur_slice -> u1_mbaff_frame_flag ) * SUB_BLK_SIZE ) - SUB_BLK_SIZE ; if ( u2_first_mb_in_slice ) { UWORD8 u1_mb_aff ; UWORD8 u1_field_pic ; UWORD16 u2_frm_wd_in_mbs ; u2_frm_wd_in_mbs = ps_seq -> u2_frm_wd_in_mbs ; u1_mb_aff = ps_cur_slice -> u1_mbaff_frame_flag ; u1_field_pic = ps_cur_slice -> u1_field_pic_flag ; { UWORD32 x_offset ; UWORD32 y_offset ; UWORD32 u4_frame_stride ; tfr_ctxt_t * ps_trns_addr ; if ( ps_dec -> u1_separate_parse ) { ps_trns_addr = & ps_dec -> s_tran_addrecon_parse ; } else { ps_trns_addr = & ps_dec -> s_tran_addrecon ; } u2_mb_x = MOD ( u2_first_mb_in_slice , u2_frm_wd_in_mbs ) ; u2_mb_y = DIV ( u2_first_mb_in_slice , u2_frm_wd_in_mbs ) ; u2_mb_y <<= u1_mb_aff ; if ( ( u2_mb_x > u2_frm_wd_in_mbs - 1 ) || ( u2_mb_y > ps_dec -> u2_frm_ht_in_mbs - 1 ) ) { return ERROR_CORRUPTED_SLICE ; } u4_frame_stride = ps_dec -> u2_frm_wd_y << u1_field_pic ; x_offset = u2_mb_x << 4 ; y_offset = ( u2_mb_y * u4_frame_stride ) << 4 ; ps_trns_addr -> pu1_dest_y = ps_dec -> s_cur_pic . pu1_buf1 + x_offset + y_offset ; u4_frame_stride = ps_dec -> u2_frm_wd_uv << u1_field_pic ; x_offset >>= 1 ; y_offset = ( u2_mb_y * u4_frame_stride ) << 3 ; x_offset *= YUV420SP_FACTOR ; ps_trns_addr -> pu1_dest_u = ps_dec -> s_cur_pic . pu1_buf2 + x_offset + y_offset ; ps_trns_addr -> pu1_dest_v = ps_dec -> s_cur_pic . pu1_buf3 + x_offset + y_offset ; ps_trns_addr -> pu1_mb_y = ps_trns_addr -> pu1_dest_y ; ps_trns_addr -> pu1_mb_u = ps_trns_addr -> pu1_dest_u ; ps_trns_addr -> pu1_mb_v = ps_trns_addr -> pu1_dest_v ; if ( ps_dec -> u1_separate_parse == 1 ) { ps_dec -> ps_deblk_mbn = ps_dec -> ps_deblk_pic + ( u2_first_mb_in_slice << u1_mb_aff ) ; } else { ps_dec -> ps_deblk_mbn = ps_dec -> ps_deblk_pic + ( u2_first_mb_in_slice << u1_mb_aff ) ; } ps_dec -> u2_cur_mb_addr = ( u2_first_mb_in_slice << u1_mb_aff ) ; ps_dec -> ps_mv_cur = ps_dec -> s_cur_pic . ps_mv + ( ( u2_first_mb_in_slice << u1_mb_aff ) << 4 ) ; } } else { tfr_ctxt_t * ps_trns_addr ; if ( ps_dec -> u1_separate_parse ) { ps_trns_addr = & ps_dec -> s_tran_addrecon_parse ; } else { ps_trns_addr = & ps_dec -> s_tran_addrecon ; } u2_mb_x = 0xffff ; u2_mb_y = 0 ; ps_dec -> u2_cur_mb_addr = 0 ; ps_dec -> ps_deblk_mbn = ps_dec -> ps_deblk_pic ; ps_dec -> ps_mv_cur = ps_dec -> s_cur_pic . ps_mv ; ps_trns_addr -> pu1_dest_y = ps_dec -> s_cur_pic . pu1_buf1 ; ps_trns_addr -> pu1_dest_u = ps_dec -> s_cur_pic . pu1_buf2 ; ps_trns_addr -> pu1_dest_v = ps_dec -> s_cur_pic . pu1_buf3 ; ps_trns_addr -> pu1_mb_y = ps_trns_addr -> pu1_dest_y ; ps_trns_addr -> pu1_mb_u = ps_trns_addr -> pu1_dest_u ; ps_trns_addr -> pu1_mb_v = ps_trns_addr -> pu1_dest_v ; } ps_dec -> ps_part = ps_dec -> ps_parse_part_params ; ps_dec -> u2_mbx = ( MOD ( u2_first_mb_in_slice - 1 , ps_seq -> u2_frm_wd_in_mbs ) ) ; ps_dec -> u2_mby = ( DIV ( u2_first_mb_in_slice - 1 , ps_seq -> u2_frm_wd_in_mbs ) ) ; ps_dec -> u2_mby <<= ps_cur_slice -> u1_mbaff_frame_flag ; ps_dec -> i2_prev_slice_mbx = ps_dec -> u2_mbx ; ps_dec -> i2_prev_slice_mby = ps_dec -> u2_mby ; } ps_bitstrm -> u4_max_ofst += ps_dec -> ps_cur_pps -> u1_entropy_coding_mode ; ps_dec -> u1_B = ( u1_slice_type == B_SLICE ) ; ps_dec -> u4_next_mb_skip = 0 ; ps_dec -> ps_parse_cur_slice -> u4_first_mb_in_slice = ps_dec -> ps_cur_slice -> u2_first_mb_in_slice ; ps_dec -> ps_parse_cur_slice -> slice_type = ps_dec -> ps_cur_slice -> u1_slice_type ; ps_dec -> u4_start_recon_deblk = 1 ; { WORD32 num_entries ; WORD32 size ; UWORD8 * pu1_buf ; num_entries = MAX_FRAMES ; if ( ( 1 >= ps_dec -> ps_cur_sps -> u1_num_ref_frames ) && ( 0 == ps_dec -> i4_display_delay ) ) { num_entries = 1 ; } num_entries = ( ( 2 * num_entries ) + 1 ) ; num_entries *= 2 ; size = num_entries * sizeof ( void * ) ; size += PAD_MAP_IDX_POC * sizeof ( void * ) ; pu1_buf = ( UWORD8 * ) ps_dec -> pv_map_ref_idx_to_poc_buf ; pu1_buf += size * ps_dec -> u2_cur_slice_num ; ps_dec -> ps_parse_cur_slice -> ppv_map_ref_idx_to_poc = ( void * ) pu1_buf ; } if ( ps_dec -> u1_separate_parse ) { ps_dec -> ps_parse_cur_slice -> pv_tu_coeff_data_start = ps_dec -> pv_parse_tu_coeff_data ; } else { ps_dec -> pv_proc_tu_coeff_data = ps_dec -> pv_parse_tu_coeff_data ; } if ( u1_slice_type == I_SLICE ) { ps_dec -> ps_cur_pic -> u4_pack_slc_typ |= I_SLC_BIT ; ret = ih264d_parse_islice ( ps_dec , u2_first_mb_in_slice ) ; if ( ps_dec -> i4_pic_type != B_SLICE && ps_dec -> i4_pic_type != P_SLICE ) ps_dec -> i4_pic_type = I_SLICE ; } else if ( u1_slice_type == P_SLICE ) { ps_dec -> ps_cur_pic -> u4_pack_slc_typ |= P_SLC_BIT ; ret = ih264d_parse_pslice ( ps_dec , u2_first_mb_in_slice ) ; ps_dec -> u1_pr_sl_type = u1_slice_type ; if ( ps_dec -> i4_pic_type != B_SLICE ) ps_dec -> i4_pic_type = P_SLICE ; } else if ( u1_slice_type == B_SLICE ) { ps_dec -> ps_cur_pic -> u4_pack_slc_typ |= B_SLC_BIT ; ret = ih264d_parse_bslice ( ps_dec , u2_first_mb_in_slice ) ; ps_dec -> u1_pr_sl_type = u1_slice_type ; ps_dec -> i4_pic_type = B_SLICE ; } else return ERROR_INV_SLC_TYPE_T ; if ( ps_dec -> u1_slice_header_done ) { ps_dec -> u1_first_slice_in_stream = 0 ; } if ( ret != OK ) return ret ; <S2SV_StartBug> ps_dec -> i2_prev_slice_mbx = ps_dec -> u2_mbx ; <S2SV_EndBug> ps_dec -> i2_prev_slice_mby = ps_dec -> u2_mby ; if ( ps_dec -> u2_total_mbs_coded >= ( ps_seq -> u2_max_mb_addr + 1 ) ) { ps_dec -> u1_pic_decode_done = 1 ; } { dec_err_status_t * ps_err = ps_dec -> ps_dec_err_status ; if ( ( ps_err -> u1_err_flag & REJECT_PB_PICS ) && ( ps_err -> u1_cur_pic_type == PIC_TYPE_I ) ) { ps_err -> u1_err_flag = ACCEPT_ALL_PICS ; } } PRINT_BIN_BIT_RATIO ( ps_dec ) return ret ; }","return ret ; if ( u1_nal_ref_idc != 0 ) { if ( ! ps_dec -> ps_dpb_cmds -> u1_dpb_commands_read ) { memcpy ( ( void * ) ps_dec -> ps_dpb_cmds , ( void * ) ( & ( ps_dec -> s_dpb_cmds_scratch ) ) , sizeof ( dpb_commands_t ) ) ; } }"
120,"static void Np_toString ( js_State * J ) { <S2SV_StartBug> char buf [ 32 ] ; <S2SV_EndBug> js_Object * self = js_toobject ( J , 0 ) ; int radix = js_isundefined ( J , 1 ) ? 10 : js_tointeger ( J , 1 ) ; if ( self -> type != JS_CNUMBER ) js_typeerror ( J , ""not<S2SV_blank>a<S2SV_blank>number"" ) ; if ( radix == 10 ) { js_pushstring ( J , jsV_numbertostring ( J , buf , self -> u . number ) ) ; return ; } if ( radix < 2 || radix > 36 ) js_rangeerror ( J , ""invalid<S2SV_blank>radix"" ) ; { static const char digits [ ] = ""0123456789abcdefghijklmnopqrstuvwxyz"" ; <S2SV_StartBug> char buf [ 100 ] ; <S2SV_EndBug> double number = self -> u . number ; int sign = self -> u . number < 0 ; js_Buffer * sb = NULL ; uint64_t u , limit = ( ( uint64_t ) 1 << 52 ) ; int ndigits , exp , point ; if ( number == 0 ) { js_pushstring ( J , ""0"" ) ; return ; } if ( isnan ( number ) ) { js_pushstring ( J , ""NaN"" ) ; return ; } if ( isinf ( number ) ) { js_pushstring ( J , sign ? ""-Infinity"" : ""Infinity"" ) ; return ; } if ( sign ) number = - number ; exp = 0 ; while ( number * pow ( radix , exp ) > limit ) -- exp ; while ( number * pow ( radix , exp + 1 ) < limit ) ++ exp ; u = number * pow ( radix , exp ) + 0.5 ; while ( u > 0 && ( u % radix ) == 0 ) { u /= radix ; -- exp ; } ndigits = 0 ; while ( u > 0 ) { buf [ ndigits ++ ] = digits [ u % radix ] ; u /= radix ; } point = ndigits - exp ; if ( js_try ( J ) ) { js_free ( J , sb ) ; js_throw ( J ) ; } if ( sign ) js_putc ( J , & sb , '-' ) ; if ( point <= 0 ) { js_putc ( J , & sb , '0' ) ; js_putc ( J , & sb , '.' ) ; while ( point ++ < 0 ) js_putc ( J , & sb , '0' ) ; while ( ndigits -- > 0 ) js_putc ( J , & sb , buf [ ndigits ] ) ; } else { while ( ndigits -- > 0 ) { js_putc ( J , & sb , buf [ ndigits ] ) ; if ( -- point == 0 && ndigits > 0 ) js_putc ( J , & sb , '.' ) ; } while ( point -- > 0 ) js_putc ( J , & sb , '0' ) ; } js_putc ( J , & sb , 0 ) ; js_pushstring ( J , sb -> s ) ; js_endtry ( J ) ; js_free ( J , sb ) ; } }","char buf [ 100 <S2SV_ModEnd> ] ; js_Object <S2SV_ModStart> = ""0123456789abcdefghijklmnopqrstuvwxyz"" ; <S2SV_ModEnd> double number ="
121,"void tcp_sack_option ( struct tcpcb * tp , struct tcphdr * th , u_char * cp , int optlen ) { int tmp_olen ; u_char * tmp_cp ; struct sackhole * cur , * p , * temp ; if ( ! tp -> sack_enable ) return ; if ( ( th -> th_flags & TH_ACK ) == 0 ) return ; if ( SEQ_LT ( th -> th_ack , tp -> snd_una ) || SEQ_GT ( th -> th_ack , tp -> snd_max ) ) return ; if ( optlen <= 2 || ( optlen - 2 ) % TCPOLEN_SACK != 0 ) return ; tmp_cp = cp + 2 ; tmp_olen = optlen - 2 ; tcpstat_inc ( tcps_sack_rcv_opts ) ; if ( tp -> snd_numholes < 0 ) tp -> snd_numholes = 0 ; if ( tp -> t_maxseg == 0 ) panic ( ""tcp_sack_option"" ) ; while ( tmp_olen > 0 ) { struct sackblk sack ; memcpy ( & sack . start , tmp_cp , sizeof ( tcp_seq ) ) ; sack . start = ntohl ( sack . start ) ; memcpy ( & sack . end , tmp_cp + sizeof ( tcp_seq ) , sizeof ( tcp_seq ) ) ; sack . end = ntohl ( sack . end ) ; tmp_olen -= TCPOLEN_SACK ; tmp_cp += TCPOLEN_SACK ; if ( SEQ_LEQ ( sack . end , sack . start ) ) continue ; if ( SEQ_LEQ ( sack . end , tp -> snd_una ) ) continue ; if ( SEQ_GT ( th -> th_ack , tp -> snd_una ) ) { if ( SEQ_LT ( sack . start , th -> th_ack ) ) continue ; } if ( SEQ_GT ( sack . end , tp -> snd_max ) ) continue ; if ( tp -> snd_holes == NULL ) { tp -> snd_holes = ( struct sackhole * ) pool_get ( & sackhl_pool , PR_NOWAIT ) ; if ( tp -> snd_holes == NULL ) { goto done ; } cur = tp -> snd_holes ; cur -> start = th -> th_ack ; cur -> end = sack . start ; cur -> rxmit = cur -> start ; cur -> next = NULL ; tp -> snd_numholes = 1 ; tp -> rcv_lastsack = sack . end ; cur -> dups = min ( tcprexmtthresh , ( ( sack . end - cur -> end ) / tp -> t_maxseg ) ) ; if ( cur -> dups < 1 ) cur -> dups = 1 ; continue ; } p = cur = tp -> snd_holes ; while ( cur ) { if ( SEQ_LEQ ( sack . end , cur -> start ) ) break ; if ( SEQ_GEQ ( sack . start , cur -> end ) ) { cur -> dups ++ ; if ( ( ( sack . end - cur -> end ) / tp -> t_maxseg ) >= tcprexmtthresh ) cur -> dups = tcprexmtthresh ; p = cur ; cur = cur -> next ; continue ; } if ( SEQ_LEQ ( sack . start , cur -> start ) ) { if ( SEQ_GEQ ( sack . end , cur -> end ) ) { if ( p != cur ) { p -> next = cur -> next ; pool_put ( & sackhl_pool , cur ) ; cur = p -> next ; } else { cur = cur -> next ; pool_put ( & sackhl_pool , p ) ; p = cur ; tp -> snd_holes = p ; } tp -> snd_numholes -- ; continue ; } cur -> start = sack . end ; cur -> rxmit = SEQ_MAX ( cur -> rxmit , cur -> start ) ; p = cur ; cur = cur -> next ; continue ; } if ( SEQ_GEQ ( sack . end , cur -> end ) ) { cur -> end = sack . start ; cur -> rxmit = SEQ_MIN ( cur -> rxmit , cur -> end ) ; cur -> dups ++ ; if ( ( ( sack . end - cur -> end ) / tp -> t_maxseg ) >= tcprexmtthresh ) cur -> dups = tcprexmtthresh ; p = cur ; cur = cur -> next ; continue ; } if ( SEQ_LT ( cur -> start , sack . start ) && SEQ_GT ( cur -> end , sack . end ) ) { <S2SV_StartBug> temp = ( struct sackhole * ) <S2SV_EndBug> pool_get ( & sackhl_pool , PR_NOWAIT ) ; if ( temp == NULL ) goto done ; temp -> next = cur -> next ; temp -> start = sack . end ; temp -> end = cur -> end ; temp -> dups = cur -> dups ; temp -> rxmit = SEQ_MAX ( cur -> rxmit , temp -> start ) ; cur -> end = sack . start ; cur -> rxmit = SEQ_MIN ( cur -> rxmit , cur -> end ) ; cur -> dups ++ ; if ( ( ( sack . end - cur -> end ) / tp -> t_maxseg ) >= tcprexmtthresh ) cur -> dups = tcprexmtthresh ; cur -> next = temp ; p = temp ; cur = p -> next ; tp -> snd_numholes ++ ; } } if ( SEQ_LT ( tp -> rcv_lastsack , sack . start ) ) { <S2SV_StartBug> temp = ( struct sackhole * ) <S2SV_EndBug> pool_get ( & sackhl_pool , PR_NOWAIT ) ; if ( temp == NULL ) goto done ; temp -> start = tp -> rcv_lastsack ; temp -> end = sack . start ; temp -> dups = min ( tcprexmtthresh , ( ( sack . end - sack . start ) / tp -> t_maxseg ) ) ; if ( temp -> dups < 1 ) temp -> dups = 1 ; temp -> rxmit = temp -> start ; temp -> next = 0 ; p -> next = temp ; tp -> rcv_lastsack = sack . end ; tp -> snd_numholes ++ ; } } done : return ; }",) ) { if ( tp -> snd_numholes >= TCP_SACKHOLE_LIMIT ) goto done ; <S2SV_ModStart> ) ) { if ( tp -> snd_numholes >= TCP_SACKHOLE_LIMIT ) goto done ;
122,"int oidc_handle_redirect_uri_request ( request_rec * r , oidc_cfg * c , oidc_session_t * session ) { if ( oidc_proto_is_redirect_authorization_response ( r , c ) ) { return oidc_handle_redirect_authorization_response ( r , c , session ) ; } else if ( oidc_proto_is_post_authorization_response ( r , c ) ) { return oidc_handle_post_authorization_response ( r , c , session ) ; } else if ( oidc_is_discovery_response ( r , c ) ) { return oidc_handle_discovery_response ( r , c ) ; } else if ( oidc_util_request_has_parameter ( r , ""logout"" ) ) { return oidc_handle_logout ( r , c , session ) ; } else if ( oidc_util_request_has_parameter ( r , ""jwks"" ) ) { return oidc_handle_jwks ( r , c ) ; } else if ( oidc_util_request_has_parameter ( r , ""session"" ) ) { return oidc_handle_session_management ( r , c , session ) ; } else if ( oidc_util_request_has_parameter ( r , ""refresh"" ) ) { return oidc_handle_refresh_token_request ( r , c , session ) ; } else if ( oidc_util_request_has_parameter ( r , ""request_uri"" ) ) { return oidc_handle_request_uri ( r , c ) ; } else if ( oidc_util_request_has_parameter ( r , ""remove_at_cache"" ) ) { return oidc_handle_remove_at_cache ( r , c ) ; } else if ( ( r -> args == NULL ) || ( apr_strnatcmp ( r -> args , """" ) == 0 ) ) { return oidc_proto_javascript_implicit ( r , c ) ; } if ( oidc_util_request_has_parameter ( r , ""error"" ) ) { oidc_handle_redirect_authorization_response ( r , c , session ) ; } return oidc_util_html_send_error ( r , c -> error_template , ""Invalid<S2SV_blank>Request"" , apr_psprintf ( r -> pool , <S2SV_StartBug> ""The<S2SV_blank>OpenID<S2SV_blank>Connect<S2SV_blank>callback<S2SV_blank>URL<S2SV_blank>received<S2SV_blank>an<S2SV_blank>invalid<S2SV_blank>request:<S2SV_blank>%s"" , <S2SV_EndBug> r -> args ) , HTTP_INTERNAL_SERVER_ERROR ) ; }","-> pool , ""The<S2SV_blank>OpenID<S2SV_blank>Connect<S2SV_blank>callback<S2SV_blank>URL<S2SV_blank>received<S2SV_blank>an<S2SV_blank>invalid<S2SV_blank>request"" ) , <S2SV_ModEnd> HTTP_INTERNAL_SERVER_ERROR ) ;"
123,"int ssl3_get_key_exchange ( SSL * s ) { # ifndef OPENSSL_NO_RSA unsigned char * q , md_buf [ EVP_MAX_MD_SIZE * 2 ] ; # endif EVP_MD_CTX md_ctx ; unsigned char * param , * p ; int al , j , ok ; long i , param_len , n , alg_k , alg_a ; EVP_PKEY * pkey = NULL ; const EVP_MD * md = NULL ; # ifndef OPENSSL_NO_RSA RSA * rsa = NULL ; # endif # ifndef OPENSSL_NO_DH DH * dh = NULL ; # endif # ifndef OPENSSL_NO_ECDH EC_KEY * ecdh = NULL ; BN_CTX * bn_ctx = NULL ; EC_POINT * srvr_ecpoint = NULL ; int curve_nid = 0 ; int encoded_pt_len = 0 ; # endif <S2SV_StartBug> n = s -> method -> ssl_get_message ( s , <S2SV_EndBug> SSL3_ST_CR_KEY_EXCH_A , SSL3_ST_CR_KEY_EXCH_B , - 1 , s -> max_cert_list , & ok ) ; <S2SV_StartBug> if ( ! ok ) return ( ( int ) n ) ; <S2SV_EndBug> if ( s -> s3 -> tmp . message_type != SSL3_MT_SERVER_KEY_EXCHANGE ) { <S2SV_StartBug> # ifndef OPENSSL_NO_PSK <S2SV_EndBug> <S2SV_StartBug> if ( s -> s3 -> tmp . new_cipher -> algorithm_mkey & SSL_kPSK ) <S2SV_EndBug> { s -> session -> sess_cert = ssl_sess_cert_new ( ) ; if ( s -> ctx -> psk_identity_hint ) OPENSSL_free ( s -> ctx -> psk_identity_hint ) ; s -> ctx -> psk_identity_hint = NULL ; } # endif s -> s3 -> tmp . reuse_message = 1 ; return ( 1 ) ; } param = p = ( unsigned char * ) s -> init_msg ; if ( s -> session -> sess_cert != NULL ) { # ifndef OPENSSL_NO_RSA if ( s -> session -> sess_cert -> peer_rsa_tmp != NULL ) { RSA_free ( s -> session -> sess_cert -> peer_rsa_tmp ) ; s -> session -> sess_cert -> peer_rsa_tmp = NULL ; } # endif # ifndef OPENSSL_NO_DH if ( s -> session -> sess_cert -> peer_dh_tmp ) { DH_free ( s -> session -> sess_cert -> peer_dh_tmp ) ; s -> session -> sess_cert -> peer_dh_tmp = NULL ; } # endif # ifndef OPENSSL_NO_ECDH if ( s -> session -> sess_cert -> peer_ecdh_tmp ) { EC_KEY_free ( s -> session -> sess_cert -> peer_ecdh_tmp ) ; s -> session -> sess_cert -> peer_ecdh_tmp = NULL ; } # endif } else { s -> session -> sess_cert = ssl_sess_cert_new ( ) ; } param_len = 0 ; alg_k = s -> s3 -> tmp . new_cipher -> algorithm_mkey ; alg_a = s -> s3 -> tmp . new_cipher -> algorithm_auth ; EVP_MD_CTX_init ( & md_ctx ) ; al = SSL_AD_DECODE_ERROR ; # ifndef OPENSSL_NO_PSK if ( alg_k & SSL_kPSK ) { char tmp_id_hint [ PSK_MAX_IDENTITY_LEN + 1 ] ; param_len = 2 ; if ( param_len > n ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_LENGTH_TOO_SHORT ) ; goto f_err ; } n2s ( p , i ) ; if ( i > PSK_MAX_IDENTITY_LEN ) { al = SSL_AD_HANDSHAKE_FAILURE ; SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_DATA_LENGTH_TOO_LONG ) ; goto f_err ; } if ( i > n - param_len ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_BAD_PSK_IDENTITY_HINT_LENGTH ) ; goto f_err ; } param_len += i ; memcpy ( tmp_id_hint , p , i ) ; memset ( tmp_id_hint + i , 0 , PSK_MAX_IDENTITY_LEN + 1 - i ) ; if ( s -> ctx -> psk_identity_hint != NULL ) OPENSSL_free ( s -> ctx -> psk_identity_hint ) ; s -> ctx -> psk_identity_hint = BUF_strdup ( tmp_id_hint ) ; if ( s -> ctx -> psk_identity_hint == NULL ) { al = SSL_AD_HANDSHAKE_FAILURE ; SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , ERR_R_MALLOC_FAILURE ) ; goto f_err ; } p += i ; n -= param_len ; } else # endif # ifndef OPENSSL_NO_SRP if ( alg_k & SSL_kSRP ) { param_len = 2 ; if ( param_len > n ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_LENGTH_TOO_SHORT ) ; goto f_err ; } n2s ( p , i ) ; if ( i > n - param_len ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_BAD_SRP_N_LENGTH ) ; goto f_err ; } param_len += i ; if ( ! ( s -> srp_ctx . N = BN_bin2bn ( p , i , NULL ) ) ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , ERR_R_BN_LIB ) ; goto err ; } p += i ; if ( 2 > n - param_len ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_LENGTH_TOO_SHORT ) ; goto f_err ; } param_len += 2 ; n2s ( p , i ) ; if ( i > n - param_len ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_BAD_SRP_G_LENGTH ) ; goto f_err ; } param_len += i ; if ( ! ( s -> srp_ctx . g = BN_bin2bn ( p , i , NULL ) ) ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , ERR_R_BN_LIB ) ; goto err ; } p += i ; if ( 1 > n - param_len ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_LENGTH_TOO_SHORT ) ; goto f_err ; } param_len += 1 ; i = ( unsigned int ) ( p [ 0 ] ) ; p ++ ; if ( i > n - param_len ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_BAD_SRP_S_LENGTH ) ; goto f_err ; } param_len += i ; if ( ! ( s -> srp_ctx . s = BN_bin2bn ( p , i , NULL ) ) ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , ERR_R_BN_LIB ) ; goto err ; } p += i ; if ( 2 > n - param_len ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_LENGTH_TOO_SHORT ) ; goto f_err ; } param_len += 2 ; n2s ( p , i ) ; if ( i > n - param_len ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_BAD_SRP_B_LENGTH ) ; goto f_err ; } param_len += i ; if ( ! ( s -> srp_ctx . B = BN_bin2bn ( p , i , NULL ) ) ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , ERR_R_BN_LIB ) ; goto err ; } p += i ; n -= param_len ; if ( ! srp_verify_server_param ( s , & al ) ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_BAD_SRP_PARAMETERS ) ; goto f_err ; } # ifndef OPENSSL_NO_RSA if ( alg_a & SSL_aRSA ) pkey = X509_get_pubkey ( s -> session -> sess_cert -> peer_pkeys [ SSL_PKEY_RSA_ENC ] . x509 ) ; # else if ( 0 ) ; # endif # ifndef OPENSSL_NO_DSA else if ( alg_a & SSL_aDSS ) pkey = X509_get_pubkey ( s -> session -> sess_cert -> peer_pkeys [ SSL_PKEY_DSA_SIGN ] . x509 ) ; # endif } else # endif # ifndef OPENSSL_NO_RSA if ( alg_k & SSL_kRSA ) { if ( ( rsa = RSA_new ( ) ) == NULL ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , ERR_R_MALLOC_FAILURE ) ; goto err ; } param_len = 2 ; if ( param_len > n ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_LENGTH_TOO_SHORT ) ; goto f_err ; } n2s ( p , i ) ; if ( i > n - param_len ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_BAD_RSA_MODULUS_LENGTH ) ; goto f_err ; } param_len += i ; if ( ! ( rsa -> n = BN_bin2bn ( p , i , rsa -> n ) ) ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , ERR_R_BN_LIB ) ; goto err ; } p += i ; if ( 2 > n - param_len ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_LENGTH_TOO_SHORT ) ; goto f_err ; } param_len += 2 ; n2s ( p , i ) ; if ( i > n - param_len ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_BAD_RSA_E_LENGTH ) ; goto f_err ; } param_len += i ; if ( ! ( rsa -> e = BN_bin2bn ( p , i , rsa -> e ) ) ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , ERR_R_BN_LIB ) ; goto err ; } p += i ; n -= param_len ; if ( alg_a & SSL_aRSA ) pkey = X509_get_pubkey ( s -> session -> sess_cert -> peer_pkeys [ SSL_PKEY_RSA_ENC ] . x509 ) ; else { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , ERR_R_INTERNAL_ERROR ) ; goto err ; } s -> session -> sess_cert -> peer_rsa_tmp = rsa ; rsa = NULL ; } # else if ( 0 ) ; # endif # ifndef OPENSSL_NO_DH else if ( alg_k & SSL_kDHE ) { if ( ( dh = DH_new ( ) ) == NULL ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , ERR_R_DH_LIB ) ; goto err ; } param_len = 2 ; if ( param_len > n ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_LENGTH_TOO_SHORT ) ; goto f_err ; } n2s ( p , i ) ; if ( i > n - param_len ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_BAD_DH_P_LENGTH ) ; goto f_err ; } param_len += i ; if ( ! ( dh -> p = BN_bin2bn ( p , i , NULL ) ) ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , ERR_R_BN_LIB ) ; goto err ; } p += i ; if ( 2 > n - param_len ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_LENGTH_TOO_SHORT ) ; goto f_err ; } param_len += 2 ; n2s ( p , i ) ; if ( i > n - param_len ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_BAD_DH_G_LENGTH ) ; goto f_err ; } param_len += i ; if ( ! ( dh -> g = BN_bin2bn ( p , i , NULL ) ) ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , ERR_R_BN_LIB ) ; goto err ; } p += i ; if ( 2 > n - param_len ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_LENGTH_TOO_SHORT ) ; goto f_err ; } param_len += 2 ; n2s ( p , i ) ; if ( i > n - param_len ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_BAD_DH_PUB_KEY_LENGTH ) ; goto f_err ; } param_len += i ; if ( ! ( dh -> pub_key = BN_bin2bn ( p , i , NULL ) ) ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , ERR_R_BN_LIB ) ; goto err ; } p += i ; n -= param_len ; if ( ! ssl_security ( s , SSL_SECOP_TMP_DH , DH_security_bits ( dh ) , 0 , dh ) ) { al = SSL_AD_HANDSHAKE_FAILURE ; SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_DH_KEY_TOO_SMALL ) ; goto f_err ; } # ifndef OPENSSL_NO_RSA if ( alg_a & SSL_aRSA ) pkey = X509_get_pubkey ( s -> session -> sess_cert -> peer_pkeys [ SSL_PKEY_RSA_ENC ] . x509 ) ; # else if ( 0 ) ; # endif # ifndef OPENSSL_NO_DSA else if ( alg_a & SSL_aDSS ) pkey = X509_get_pubkey ( s -> session -> sess_cert -> peer_pkeys [ SSL_PKEY_DSA_SIGN ] . x509 ) ; # endif s -> session -> sess_cert -> peer_dh_tmp = dh ; dh = NULL ; } else if ( ( alg_k & SSL_kDHr ) || ( alg_k & SSL_kDHd ) ) { al = SSL_AD_ILLEGAL_PARAMETER ; SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_TRIED_TO_USE_UNSUPPORTED_CIPHER ) ; goto f_err ; } # endif # ifndef OPENSSL_NO_ECDH else if ( alg_k & SSL_kECDHE ) { EC_GROUP * ngroup ; const EC_GROUP * group ; if ( ( ecdh = EC_KEY_new ( ) ) == NULL ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , ERR_R_MALLOC_FAILURE ) ; goto err ; } param_len = 4 ; if ( param_len > n ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_LENGTH_TOO_SHORT ) ; goto f_err ; } if ( ! tls1_check_curve ( s , p , 3 ) ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_WRONG_CURVE ) ; goto f_err ; } if ( ( curve_nid = tls1_ec_curve_id2nid ( * ( p + 2 ) ) ) == 0 ) { al = SSL_AD_INTERNAL_ERROR ; SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_UNABLE_TO_FIND_ECDH_PARAMETERS ) ; goto f_err ; } ngroup = EC_GROUP_new_by_curve_name ( curve_nid ) ; if ( ngroup == NULL ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , ERR_R_EC_LIB ) ; goto err ; } if ( EC_KEY_set_group ( ecdh , ngroup ) == 0 ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , ERR_R_EC_LIB ) ; goto err ; } EC_GROUP_free ( ngroup ) ; group = EC_KEY_get0_group ( ecdh ) ; if ( SSL_C_IS_EXPORT ( s -> s3 -> tmp . new_cipher ) && ( EC_GROUP_get_degree ( group ) > 163 ) ) { al = SSL_AD_EXPORT_RESTRICTION ; SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_ECGROUP_TOO_LARGE_FOR_CIPHER ) ; goto f_err ; } p += 3 ; if ( ( ( srvr_ecpoint = EC_POINT_new ( group ) ) == NULL ) || ( ( bn_ctx = BN_CTX_new ( ) ) == NULL ) ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , ERR_R_MALLOC_FAILURE ) ; goto err ; } encoded_pt_len = * p ; p += 1 ; if ( ( encoded_pt_len > n - param_len ) || ( EC_POINT_oct2point ( group , srvr_ecpoint , p , encoded_pt_len , bn_ctx ) == 0 ) ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_BAD_ECPOINT ) ; goto f_err ; } param_len += encoded_pt_len ; n -= param_len ; p += encoded_pt_len ; if ( 0 ) ; # ifndef OPENSSL_NO_RSA else if ( alg_a & SSL_aRSA ) pkey = X509_get_pubkey ( s -> session -> sess_cert -> peer_pkeys [ SSL_PKEY_RSA_ENC ] . x509 ) ; # endif # ifndef OPENSSL_NO_ECDSA else if ( alg_a & SSL_aECDSA ) pkey = X509_get_pubkey ( s -> session -> sess_cert -> peer_pkeys [ SSL_PKEY_ECC ] . x509 ) ; # endif EC_KEY_set_public_key ( ecdh , srvr_ecpoint ) ; s -> session -> sess_cert -> peer_ecdh_tmp = ecdh ; ecdh = NULL ; BN_CTX_free ( bn_ctx ) ; bn_ctx = NULL ; EC_POINT_free ( srvr_ecpoint ) ; srvr_ecpoint = NULL ; } else if ( alg_k ) { al = SSL_AD_UNEXPECTED_MESSAGE ; SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_UNEXPECTED_MESSAGE ) ; goto f_err ; } # endif if ( pkey != NULL ) { if ( SSL_USE_SIGALGS ( s ) ) { int rv ; if ( 2 > n ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_LENGTH_TOO_SHORT ) ; goto f_err ; } rv = tls12_check_peer_sigalg ( & md , s , p , pkey ) ; if ( rv == - 1 ) goto err ; else if ( rv == 0 ) { goto f_err ; } # ifdef SSL_DEBUG fprintf ( stderr , ""USING<S2SV_blank>TLSv1.2<S2SV_blank>HASH<S2SV_blank>%s\\n"" , EVP_MD_name ( md ) ) ; # endif p += 2 ; n -= 2 ; } else md = EVP_sha1 ( ) ; if ( 2 > n ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_LENGTH_TOO_SHORT ) ; goto f_err ; } n2s ( p , i ) ; n -= 2 ; j = EVP_PKEY_size ( pkey ) ; if ( ( i != n ) || ( n > j ) || ( n <= 0 ) ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_WRONG_SIGNATURE_LENGTH ) ; goto f_err ; } # ifndef OPENSSL_NO_RSA if ( pkey -> type == EVP_PKEY_RSA && ! SSL_USE_SIGALGS ( s ) ) { int num ; unsigned int size ; j = 0 ; q = md_buf ; for ( num = 2 ; num > 0 ; num -- ) { EVP_MD_CTX_set_flags ( & md_ctx , EVP_MD_CTX_FLAG_NON_FIPS_ALLOW ) ; EVP_DigestInit_ex ( & md_ctx , ( num == 2 ) ? s -> ctx -> md5 : s -> ctx -> sha1 , NULL ) ; EVP_DigestUpdate ( & md_ctx , & ( s -> s3 -> client_random [ 0 ] ) , SSL3_RANDOM_SIZE ) ; EVP_DigestUpdate ( & md_ctx , & ( s -> s3 -> server_random [ 0 ] ) , SSL3_RANDOM_SIZE ) ; EVP_DigestUpdate ( & md_ctx , param , param_len ) ; EVP_DigestFinal_ex ( & md_ctx , q , & size ) ; q += size ; j += size ; } i = RSA_verify ( NID_md5_sha1 , md_buf , j , p , n , pkey -> pkey . rsa ) ; if ( i < 0 ) { al = SSL_AD_DECRYPT_ERROR ; SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_BAD_RSA_DECRYPT ) ; goto f_err ; } if ( i == 0 ) { al = SSL_AD_DECRYPT_ERROR ; SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_BAD_SIGNATURE ) ; goto f_err ; } } else # endif { EVP_VerifyInit_ex ( & md_ctx , md , NULL ) ; EVP_VerifyUpdate ( & md_ctx , & ( s -> s3 -> client_random [ 0 ] ) , SSL3_RANDOM_SIZE ) ; EVP_VerifyUpdate ( & md_ctx , & ( s -> s3 -> server_random [ 0 ] ) , SSL3_RANDOM_SIZE ) ; EVP_VerifyUpdate ( & md_ctx , param , param_len ) ; if ( EVP_VerifyFinal ( & md_ctx , p , ( int ) n , pkey ) <= 0 ) { al = SSL_AD_DECRYPT_ERROR ; SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_BAD_SIGNATURE ) ; goto f_err ; } } } else { if ( ! ( alg_a & ( SSL_aNULL | SSL_aSRP ) ) && ! ( alg_k & SSL_kPSK ) ) { if ( ssl3_check_cert_and_algorithm ( s ) ) SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , ERR_R_INTERNAL_ERROR ) ; goto err ; } if ( n != 0 ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_EXTRA_DATA_IN_MESSAGE ) ; goto f_err ; } } EVP_PKEY_free ( pkey ) ; EVP_MD_CTX_cleanup ( & md_ctx ) ; return ( 1 ) ; f_err : ssl3_send_alert ( s , SSL3_AL_FATAL , al ) ; err : EVP_PKEY_free ( pkey ) ; # ifndef OPENSSL_NO_RSA if ( rsa != NULL ) RSA_free ( rsa ) ; # endif # ifndef OPENSSL_NO_DH if ( dh != NULL ) DH_free ( dh ) ; # endif # ifndef OPENSSL_NO_ECDH BN_CTX_free ( bn_ctx ) ; EC_POINT_free ( srvr_ecpoint ) ; if ( ecdh != NULL ) EC_KEY_free ( ecdh ) ; # endif EVP_MD_CTX_cleanup ( & md_ctx ) ; return ( - 1 ) ; }","; # endif EVP_MD_CTX_init ( & md_ctx ) ; <S2SV_ModStart> ) n ) ; alg_k = s -> s3 -> tmp . new_cipher -> algorithm_mkey <S2SV_ModStart> SSL3_MT_SERVER_KEY_EXCHANGE ) { if ( alg_k & ( SSL_kDHE | SSL_kECDHE ) ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_UNEXPECTED_MESSAGE ) ; al = SSL_AD_UNEXPECTED_MESSAGE ; goto f_err ; } <S2SV_ModStart> OPENSSL_NO_PSK if ( alg_k & SSL_kPSK ) { s -> session -> sess_cert = ssl_sess_cert_new ( ) ; if ( s -> ctx -> psk_identity_hint ) OPENSSL_free ( s -> ctx -> psk_identity_hint ) ; s -> ctx -> psk_identity_hint = NULL ; } # endif s -> s3 -> tmp . reuse_message = 1 ; return ( 1 ) ; } param = p = ( unsigned char * ) s -> init_msg ; if ( s -> session -> sess_cert != NULL ) { # ifndef OPENSSL_NO_RSA if ( s -> session -> sess_cert -> peer_rsa_tmp != NULL ) { RSA_free ( s -> session -> sess_cert -> peer_rsa_tmp ) ; s -> session -> sess_cert -> peer_rsa_tmp = NULL ; } # endif # ifndef OPENSSL_NO_DH if ( s -> session -> sess_cert -> peer_dh_tmp ) { DH_free ( s -> session -> sess_cert -> peer_dh_tmp ) ; s -> session -> sess_cert -> peer_dh_tmp = NULL ; } # endif # ifndef OPENSSL_NO_ECDH if ( s -> session -> sess_cert -> peer_ecdh_tmp ) { EC_KEY_free ( s -> session -> sess_cert -> peer_ecdh_tmp ) ; s -> session -> sess_cert -> peer_ecdh_tmp = NULL ; } # endif } else { s -> session -> sess_cert = ssl_sess_cert_new ( ) ; } param_len = 0 ; alg_a = <S2SV_ModStart> . new_cipher -> algorithm_auth <S2SV_ModEnd> ; al ="
124,"static OPJ_BOOL bmp_read_rle8_data ( FILE * IN , OPJ_UINT8 * pData , OPJ_UINT32 stride , OPJ_UINT32 width , OPJ_UINT32 height ) { <S2SV_StartBug> OPJ_UINT32 x , y ; <S2SV_EndBug> OPJ_UINT8 * pix ; const OPJ_UINT8 * beyond ; beyond = pData + stride * height ; pix = pData ; <S2SV_StartBug> x = y = 0U ; <S2SV_EndBug> while ( y < height ) { int c = getc ( IN ) ; if ( c == EOF ) { return OPJ_FALSE ; } if ( c ) { int j , c1_int ; OPJ_UINT8 c1 ; c1_int = getc ( IN ) ; if ( c1_int == EOF ) { return OPJ_FALSE ; } c1 = ( OPJ_UINT8 ) c1_int ; for ( j = 0 ; ( j < c ) && ( x < width ) && ( ( OPJ_SIZE_T ) pix < ( OPJ_SIZE_T ) beyond ) ; j ++ , x ++ , pix ++ ) { <S2SV_StartBug> * pix = c1 ; <S2SV_EndBug> } } else { c = getc ( IN ) ; if ( c == EOF ) { return OPJ_FALSE ; } if ( c == 0x00 ) { x = 0 ; ++ y ; pix = pData + y * stride + x ; } else if ( c == 0x01 ) { break ; } else if ( c == 0x02 ) { c = getc ( IN ) ; if ( c == EOF ) { return OPJ_FALSE ; } x += ( OPJ_UINT32 ) c ; c = getc ( IN ) ; if ( c == EOF ) { return OPJ_FALSE ; } y += ( OPJ_UINT32 ) c ; pix = pData + y * stride + x ; } else { int j ; for ( j = 0 ; ( j < c ) && ( x < width ) && ( ( OPJ_SIZE_T ) pix < ( OPJ_SIZE_T ) beyond ) ; j ++ , x ++ , pix ++ ) { int c1_int ; OPJ_UINT8 c1 ; c1_int = getc ( IN ) ; if ( c1_int == EOF ) { return OPJ_FALSE ; } c1 = ( OPJ_UINT8 ) c1_int ; * pix = c1 ; <S2SV_StartBug> } <S2SV_EndBug> if ( ( OPJ_UINT32 ) c & 1U ) { c = getc ( IN ) ; if ( c == EOF ) { return OPJ_FALSE ; } } } } } <S2SV_StartBug> return OPJ_TRUE ; <S2SV_EndBug> }","x , y , written <S2SV_ModStart> = y = written = <S2SV_ModStart> pix = c1 ; written ++ <S2SV_ModStart> = c1 ; written ++ ; <S2SV_ModStart> } } } if ( written != width * height ) { fprintf ( stderr , ""warning,<S2SV_blank>image\'s<S2SV_blank>actual<S2SV_blank>size<S2SV_blank>does<S2SV_blank>not<S2SV_blank>match<S2SV_blank>advertized<S2SV_blank>one\\n"" ) ; return OPJ_FALSE ; }"
125,"static bool parse_cmdline ( int argc , char * * argv ) { int c ; bool reopen_log = false ; int signum ; struct utsname uname_buf ; int longindex ; int curind ; bool bad_option = false ; unsigned facility ; mode_t new_umask_val ; struct option long_options [ ] = { { ""use-file"" , required_argument , NULL , 'f' } , # if defined _WITH_VRRP_ && defined _WITH_LVS_ { ""vrrp"" , no_argument , NULL , 'P' } , { ""check"" , no_argument , NULL , 'C' } , # endif # ifdef _WITH_BFD_ { ""no_bfd"" , no_argument , NULL , 'B' } , # endif { ""all"" , no_argument , NULL , 3 } , { ""log-console"" , no_argument , NULL , 'l' } , { ""log-detail"" , no_argument , NULL , 'D' } , { ""log-facility"" , required_argument , NULL , 'S' } , { ""log-file"" , optional_argument , NULL , 'g' } , { ""flush-log-file"" , no_argument , NULL , 2 } , { ""no-syslog"" , no_argument , NULL , 'G' } , { ""umask"" , required_argument , NULL , 'u' } , # ifdef _WITH_VRRP_ { ""release-vips"" , no_argument , NULL , 'X' } , { ""dont-release-vrrp"" , no_argument , NULL , 'V' } , # endif # ifdef _WITH_LVS_ { ""dont-release-ipvs"" , no_argument , NULL , 'I' } , # endif { ""dont-respawn"" , no_argument , NULL , 'R' } , { ""dont-fork"" , no_argument , NULL , 'n' } , { ""dump-conf"" , no_argument , NULL , 'd' } , { ""pid"" , required_argument , NULL , 'p' } , # ifdef _WITH_VRRP_ { ""vrrp_pid"" , required_argument , NULL , 'r' } , # endif # ifdef _WITH_LVS_ { ""checkers_pid"" , required_argument , NULL , 'c' } , { ""address-monitoring"" , no_argument , NULL , 'a' } , # endif # ifdef _WITH_BFD_ { ""bfd_pid"" , required_argument , NULL , 'b' } , # endif # ifdef _WITH_SNMP_ { ""snmp"" , no_argument , NULL , 'x' } , { ""snmp-agent-socket"" , required_argument , NULL , 'A' } , # endif { ""core-dump"" , no_argument , NULL , 'm' } , { ""core-dump-pattern"" , optional_argument , NULL , 'M' } , # ifdef _MEM_CHECK_LOG_ { ""mem-check-log"" , no_argument , NULL , 'L' } , # endif # if HAVE_DECL_CLONE_NEWNET { ""namespace"" , required_argument , NULL , 's' } , # endif { ""config-id"" , required_argument , NULL , 'i' } , { ""signum"" , required_argument , NULL , 4 } , { ""config-test"" , optional_argument , NULL , 't' } , # ifdef _WITH_PERF_ { ""perf"" , optional_argument , NULL , 5 } , # endif # ifdef WITH_DEBUG_OPTIONS { ""debug"" , optional_argument , NULL , 6 } , # endif { ""version"" , no_argument , NULL , 'v' } , { ""help"" , no_argument , NULL , 'h' } , { NULL , 0 , NULL , 0 } } ; curind = optind ; while ( longindex = - 1 , ( c = getopt_long ( argc , argv , "":vhlndu:DRS:f:p:i:mM::g::Gt::"" # if defined _WITH_VRRP_ && defined _WITH_LVS_ ""PC"" # endif # ifdef _WITH_VRRP_ ""r:VX"" # endif # ifdef _WITH_LVS_ ""ac:I"" # endif # ifdef _WITH_BFD_ ""Bb:"" # endif # ifdef _WITH_SNMP_ ""xA:"" # endif # ifdef _MEM_CHECK_LOG_ ""L"" # endif # if HAVE_DECL_CLONE_NEWNET ""s:"" # endif , long_options , & longindex ) ) != - 1 ) { if ( longindex >= 0 && long_options [ longindex ] . has_arg == required_argument && optarg && ! optarg [ 0 ] ) { c = ':' ; optarg = NULL ; } switch ( c ) { case 'v' : fprintf ( stderr , ""%s"" , version_string ) ; # ifdef GIT_COMMIT fprintf ( stderr , "",<S2SV_blank>git<S2SV_blank>commit<S2SV_blank>%s"" , GIT_COMMIT ) ; # endif fprintf ( stderr , ""\\n\\n%s\\n\\n"" , COPYRIGHT_STRING ) ; fprintf ( stderr , ""Built<S2SV_blank>with<S2SV_blank>kernel<S2SV_blank>headers<S2SV_blank>for<S2SV_blank>Linux<S2SV_blank>%d.%d.%d\\n"" , ( LINUX_VERSION_CODE >> 16 ) & 0xff , ( LINUX_VERSION_CODE >> 8 ) & 0xff , ( LINUX_VERSION_CODE ) & 0xff ) ; uname ( & uname_buf ) ; fprintf ( stderr , ""Running<S2SV_blank>on<S2SV_blank>%s<S2SV_blank>%s<S2SV_blank>%s\\n\\n"" , uname_buf . sysname , uname_buf . release , uname_buf . version ) ; fprintf ( stderr , ""configure<S2SV_blank>options:<S2SV_blank>%s\\n\\n"" , KEEPALIVED_CONFIGURE_OPTIONS ) ; fprintf ( stderr , ""Config<S2SV_blank>options:<S2SV_blank>%s\\n\\n"" , CONFIGURATION_OPTIONS ) ; fprintf ( stderr , ""System<S2SV_blank>options:<S2SV_blank>%s\\n"" , SYSTEM_OPTIONS ) ; exit ( 0 ) ; break ; case 'h' : usage ( argv [ 0 ] ) ; exit ( 0 ) ; break ; case 'l' : __set_bit ( LOG_CONSOLE_BIT , & debug ) ; reopen_log = true ; break ; case 'n' : __set_bit ( DONT_FORK_BIT , & debug ) ; break ; case 'd' : __set_bit ( DUMP_CONF_BIT , & debug ) ; break ; # ifdef _WITH_VRRP_ case 'V' : __set_bit ( DONT_RELEASE_VRRP_BIT , & debug ) ; break ; # endif # ifdef _WITH_LVS_ case 'I' : __set_bit ( DONT_RELEASE_IPVS_BIT , & debug ) ; break ; # endif case 'D' : if ( __test_bit ( LOG_DETAIL_BIT , & debug ) ) __set_bit ( LOG_EXTRA_DETAIL_BIT , & debug ) ; else __set_bit ( LOG_DETAIL_BIT , & debug ) ; break ; case 'R' : __set_bit ( DONT_RESPAWN_BIT , & debug ) ; break ; # ifdef _WITH_VRRP_ case 'X' : __set_bit ( RELEASE_VIPS_BIT , & debug ) ; break ; # endif case 'S' : if ( ! read_unsigned ( optarg , & facility , 0 , LOG_FACILITY_MAX , false ) ) fprintf ( stderr , ""Invalid<S2SV_blank>log<S2SV_blank>facility<S2SV_blank>\'%s\'\\n"" , optarg ) ; else { log_facility = LOG_FACILITY [ facility ] . facility ; reopen_log = true ; } break ; case 'g' : if ( optarg && optarg [ 0 ] ) log_file_name = optarg ; else log_file_name = ""/tmp/keepalived.log"" ; open_log_file ( log_file_name , NULL , NULL , NULL ) ; break ; case 'G' : __set_bit ( NO_SYSLOG_BIT , & debug ) ; reopen_log = true ; break ; case 'u' : new_umask_val = set_umask ( optarg ) ; if ( umask_cmdline ) umask_val = new_umask_val ; break ; case 't' : __set_bit ( CONFIG_TEST_BIT , & debug ) ; __set_bit ( DONT_RESPAWN_BIT , & debug ) ; __set_bit ( DONT_FORK_BIT , & debug ) ; __set_bit ( NO_SYSLOG_BIT , & debug ) ; if ( optarg && optarg [ 0 ] ) { <S2SV_StartBug> int fd = open ( optarg , O_WRONLY | O_APPEND | O_CREAT , S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH ) ; <S2SV_EndBug> if ( fd == - 1 ) { fprintf ( stderr , ""Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>config-test<S2SV_blank>log<S2SV_blank>file<S2SV_blank>%s\\n"" , optarg ) ; exit ( EXIT_FAILURE ) ; } dup2 ( fd , STDERR_FILENO ) ; close ( fd ) ; } break ; case 'f' : conf_file = optarg ; break ; case 2 : set_flush_log_file ( ) ; break ; # if defined _WITH_VRRP_ && defined _WITH_LVS_ case 'P' : __clear_bit ( DAEMON_CHECKERS , & daemon_mode ) ; break ; case 'C' : __clear_bit ( DAEMON_VRRP , & daemon_mode ) ; break ; # endif # ifdef _WITH_BFD_ case 'B' : __clear_bit ( DAEMON_BFD , & daemon_mode ) ; break ; # endif case 'p' : main_pidfile = optarg ; break ; # ifdef _WITH_LVS_ case 'c' : checkers_pidfile = optarg ; break ; case 'a' : __set_bit ( LOG_ADDRESS_CHANGES , & debug ) ; break ; # endif # ifdef _WITH_VRRP_ case 'r' : vrrp_pidfile = optarg ; break ; # endif # ifdef _WITH_BFD_ case 'b' : bfd_pidfile = optarg ; break ; # endif # ifdef _WITH_SNMP_ case 'x' : snmp = 1 ; break ; case 'A' : snmp_socket = optarg ; break ; # endif case 'M' : set_core_dump_pattern = true ; if ( optarg && optarg [ 0 ] ) core_dump_pattern = optarg ; case 'm' : create_core_dump = true ; break ; # ifdef _MEM_CHECK_LOG_ case 'L' : __set_bit ( MEM_CHECK_LOG_BIT , & debug ) ; break ; # endif # if HAVE_DECL_CLONE_NEWNET case 's' : override_namespace = MALLOC ( strlen ( optarg ) + 1 ) ; strcpy ( override_namespace , optarg ) ; break ; # endif case 'i' : FREE_PTR ( config_id ) ; config_id = MALLOC ( strlen ( optarg ) + 1 ) ; strcpy ( config_id , optarg ) ; break ; case 4 : signum = get_signum ( optarg ) ; if ( signum == - 1 ) { fprintf ( stderr , ""Unknown<S2SV_blank>sigfunc<S2SV_blank>%s\\n"" , optarg ) ; exit ( 1 ) ; } printf ( ""%d\\n"" , signum ) ; exit ( 0 ) ; break ; case 3 : __set_bit ( RUN_ALL_CHILDREN , & daemon_mode ) ; # ifdef _WITH_VRRP_ __set_bit ( DAEMON_VRRP , & daemon_mode ) ; # endif # ifdef _WITH_LVS_ __set_bit ( DAEMON_CHECKERS , & daemon_mode ) ; # endif # ifdef _WITH_BFD_ __set_bit ( DAEMON_BFD , & daemon_mode ) ; # endif break ; # ifdef _WITH_PERF_ case 5 : if ( optarg && optarg [ 0 ] ) { if ( ! strcmp ( optarg , ""run"" ) ) perf_run = PERF_RUN ; else if ( ! strcmp ( optarg , ""all"" ) ) perf_run = PERF_ALL ; else if ( ! strcmp ( optarg , ""end"" ) ) perf_run = PERF_END ; else log_message ( LOG_INFO , ""Unknown<S2SV_blank>perf<S2SV_blank>start<S2SV_blank>point<S2SV_blank>%s"" , optarg ) ; } else perf_run = PERF_RUN ; break ; # endif # ifdef WITH_DEBUG_OPTIONS case 6 : set_debug_options ( optarg && optarg [ 0 ] ? optarg : NULL ) ; break ; # endif case '?' : if ( optopt && argv [ curind ] [ 1 ] != '-' ) fprintf ( stderr , ""Unknown<S2SV_blank>option<S2SV_blank>-%c\\n"" , optopt ) ; else fprintf ( stderr , ""Unknown<S2SV_blank>option<S2SV_blank>%s\\n"" , argv [ curind ] ) ; bad_option = true ; break ; case ':' : if ( optopt && argv [ curind ] [ 1 ] != '-' ) fprintf ( stderr , ""Missing<S2SV_blank>parameter<S2SV_blank>for<S2SV_blank>option<S2SV_blank>-%c\\n"" , optopt ) ; else fprintf ( stderr , ""Missing<S2SV_blank>parameter<S2SV_blank>for<S2SV_blank>option<S2SV_blank>--%s\\n"" , long_options [ longindex ] . name ) ; bad_option = true ; break ; default : exit ( 1 ) ; break ; } curind = optind ; } if ( optind < argc ) { printf ( ""Unexpected<S2SV_blank>argument(s):<S2SV_blank>"" ) ; while ( optind < argc ) printf ( ""%s<S2SV_blank>"" , argv [ optind ++ ] ) ; printf ( ""\\n"" ) ; } if ( bad_option ) exit ( 1 ) ; return reopen_log ; }",O_APPEND | O_CREAT | O_NOFOLLOW
126,"static void <S2SV_StartBug> l2tp_proto_ver_print ( netdissect_options * ndo , const uint16_t * dat ) <S2SV_EndBug> { ND_PRINT ( ( ndo , ""%u.%u"" , ( EXTRACT_16BITS ( dat ) >> 8 ) , ( EXTRACT_16BITS ( dat ) & 0xff ) ) ) ; }","uint16_t * dat , u_int length ) { if ( length < 2 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; return ; } <S2SV_ModEnd> ND_PRINT ( ("
127,"int kvm_set_msr_common ( struct kvm_vcpu * vcpu , struct msr_data * msr_info ) { bool pr = false ; u32 msr = msr_info -> index ; u64 data = msr_info -> data ; switch ( msr ) { case MSR_AMD64_NB_CFG : case MSR_IA32_UCODE_REV : case MSR_IA32_UCODE_WRITE : case MSR_VM_HSAVE_PA : case MSR_AMD64_PATCH_LOADER : case MSR_AMD64_BU_CFG2 : break ; case MSR_EFER : return set_efer ( vcpu , data ) ; case MSR_K7_HWCR : data &= ~ ( u64 ) 0x40 ; data &= ~ ( u64 ) 0x100 ; data &= ~ ( u64 ) 0x8 ; if ( data != 0 ) { vcpu_unimpl ( vcpu , ""unimplemented<S2SV_blank>HWCR<S2SV_blank>wrmsr:<S2SV_blank>0x%llx\\n"" , data ) ; return 1 ; } break ; case MSR_FAM10H_MMIO_CONF_BASE : if ( data != 0 ) { vcpu_unimpl ( vcpu , ""unimplemented<S2SV_blank>MMIO_CONF_BASE<S2SV_blank>wrmsr:<S2SV_blank>"" ""0x%llx\\n"" , data ) ; return 1 ; } break ; case MSR_IA32_DEBUGCTLMSR : if ( ! data ) { break ; } else if ( data & ~ ( DEBUGCTLMSR_LBR | DEBUGCTLMSR_BTF ) ) { return 1 ; } vcpu_unimpl ( vcpu , ""%s:<S2SV_blank>MSR_IA32_DEBUGCTLMSR<S2SV_blank>0x%llx,<S2SV_blank>nop\\n"" , __func__ , data ) ; break ; case 0x200 ... 0x2ff : return set_msr_mtrr ( vcpu , msr , data ) ; case MSR_IA32_APICBASE : kvm_set_apic_base ( vcpu , data ) ; break ; case APIC_BASE_MSR ... APIC_BASE_MSR + 0x3ff : return kvm_x2apic_msr_write ( vcpu , msr , data ) ; case MSR_IA32_TSCDEADLINE : kvm_set_lapic_tscdeadline_msr ( vcpu , data ) ; break ; case MSR_IA32_TSC_ADJUST : if ( guest_cpuid_has_tsc_adjust ( vcpu ) ) { if ( ! msr_info -> host_initiated ) { u64 adj = data - vcpu -> arch . ia32_tsc_adjust_msr ; kvm_x86_ops -> adjust_tsc_offset ( vcpu , adj , true ) ; } vcpu -> arch . ia32_tsc_adjust_msr = data ; } break ; case MSR_IA32_MISC_ENABLE : vcpu -> arch . ia32_misc_enable_msr = data ; break ; case MSR_KVM_WALL_CLOCK_NEW : case MSR_KVM_WALL_CLOCK : vcpu -> kvm -> arch . wall_clock = data ; kvm_write_wall_clock ( vcpu -> kvm , data ) ; break ; case MSR_KVM_SYSTEM_TIME_NEW : case MSR_KVM_SYSTEM_TIME : { <S2SV_StartBug> kvmclock_reset ( vcpu ) ; <S2SV_EndBug> vcpu -> arch . time = data ; kvm_make_request ( KVM_REQ_CLOCK_UPDATE , vcpu ) ; if ( ! ( data & 1 ) ) break ; <S2SV_StartBug> vcpu -> arch . time_offset = data & ~ ( PAGE_MASK | 1 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( vcpu -> arch . time_offset & <S2SV_EndBug> ( sizeof ( struct pvclock_vcpu_time_info ) - 1 ) ) break ; <S2SV_StartBug> vcpu -> arch . time_page = <S2SV_EndBug> <S2SV_StartBug> gfn_to_page ( vcpu -> kvm , data >> PAGE_SHIFT ) ; <S2SV_EndBug> if ( is_error_page ( vcpu -> arch . time_page ) ) vcpu -> arch . time_page = NULL ; break ; } case MSR_KVM_ASYNC_PF_EN : if ( kvm_pv_enable_async_pf ( vcpu , data ) ) return 1 ; break ; case MSR_KVM_STEAL_TIME : if ( unlikely ( ! sched_info_on ( ) ) ) return 1 ; if ( data & KVM_STEAL_RESERVED_MASK ) return 1 ; if ( kvm_gfn_to_hva_cache_init ( vcpu -> kvm , & vcpu -> arch . st . stime , data & KVM_STEAL_VALID_BITS ) ) return 1 ; vcpu -> arch . st . msr_val = data ; if ( ! ( data & KVM_MSR_ENABLED ) ) break ; vcpu -> arch . st . last_steal = current -> sched_info . run_delay ; preempt_disable ( ) ; accumulate_steal_time ( vcpu ) ; preempt_enable ( ) ; kvm_make_request ( KVM_REQ_STEAL_UPDATE , vcpu ) ; break ; case MSR_KVM_PV_EOI_EN : if ( kvm_lapic_enable_pv_eoi ( vcpu , data ) ) return 1 ; break ; case MSR_IA32_MCG_CTL : case MSR_IA32_MCG_STATUS : case MSR_IA32_MC0_CTL ... MSR_IA32_MC0_CTL + 4 * KVM_MAX_MCE_BANKS - 1 : return set_msr_mce ( vcpu , msr , data ) ; case MSR_K7_EVNTSEL0 : case MSR_K7_EVNTSEL1 : case MSR_K7_EVNTSEL2 : case MSR_K7_EVNTSEL3 : if ( data != 0 ) vcpu_unimpl ( vcpu , ""unimplemented<S2SV_blank>perfctr<S2SV_blank>wrmsr:<S2SV_blank>"" ""0x%x<S2SV_blank>data<S2SV_blank>0x%llx\\n"" , msr , data ) ; break ; case MSR_K7_PERFCTR0 : case MSR_K7_PERFCTR1 : case MSR_K7_PERFCTR2 : case MSR_K7_PERFCTR3 : vcpu_unimpl ( vcpu , ""unimplemented<S2SV_blank>perfctr<S2SV_blank>wrmsr:<S2SV_blank>"" ""0x%x<S2SV_blank>data<S2SV_blank>0x%llx\\n"" , msr , data ) ; break ; case MSR_P6_PERFCTR0 : case MSR_P6_PERFCTR1 : pr = true ; case MSR_P6_EVNTSEL0 : case MSR_P6_EVNTSEL1 : if ( kvm_pmu_msr ( vcpu , msr ) ) return kvm_pmu_set_msr ( vcpu , msr , data ) ; if ( pr || data != 0 ) vcpu_unimpl ( vcpu , ""disabled<S2SV_blank>perfctr<S2SV_blank>wrmsr:<S2SV_blank>"" ""0x%x<S2SV_blank>data<S2SV_blank>0x%llx\\n"" , msr , data ) ; break ; case MSR_K7_CLK_CTL : break ; case HV_X64_MSR_GUEST_OS_ID ... HV_X64_MSR_SINT15 : if ( kvm_hv_msr_partition_wide ( msr ) ) { int r ; mutex_lock ( & vcpu -> kvm -> lock ) ; r = set_msr_hyperv_pw ( vcpu , msr , data ) ; mutex_unlock ( & vcpu -> kvm -> lock ) ; return r ; } else return set_msr_hyperv ( vcpu , msr , data ) ; break ; case MSR_IA32_BBL_CR_CTL3 : vcpu_unimpl ( vcpu , ""ignored<S2SV_blank>wrmsr:<S2SV_blank>0x%x<S2SV_blank>data<S2SV_blank>%llx\\n"" , msr , data ) ; break ; case MSR_AMD64_OSVW_ID_LENGTH : if ( ! guest_cpuid_has_osvw ( vcpu ) ) return 1 ; vcpu -> arch . osvw . length = data ; break ; case MSR_AMD64_OSVW_STATUS : if ( ! guest_cpuid_has_osvw ( vcpu ) ) return 1 ; vcpu -> arch . osvw . status = data ; break ; default : if ( msr && ( msr == vcpu -> kvm -> arch . xen_hvm_config . msr ) ) return xen_hvm_config ( vcpu , data ) ; if ( kvm_pmu_msr ( vcpu , msr ) ) return kvm_pmu_set_msr ( vcpu , msr , data ) ; if ( ! ignore_msrs ) { vcpu_unimpl ( vcpu , ""unhandled<S2SV_blank>wrmsr:<S2SV_blank>0x%x<S2SV_blank>data<S2SV_blank>%llx\\n"" , msr , data ) ; return 1 ; } else { vcpu_unimpl ( vcpu , ""ignored<S2SV_blank>wrmsr:<S2SV_blank>0x%x<S2SV_blank>data<S2SV_blank>%llx\\n"" , msr , data ) ; break ; } } return 0 ; }","MSR_KVM_SYSTEM_TIME : { u64 gpa_offset ; <S2SV_ModStart> ) break ; gpa_offset <S2SV_ModEnd> = data & <S2SV_ModStart> ; if ( gpa_offset <S2SV_ModEnd> & ( sizeof <S2SV_ModStart> ) break ; if ( kvm_gfn_to_hva_cache_init <S2SV_ModEnd> ( vcpu -> <S2SV_ModStart> -> kvm , & vcpu -> arch . pv_time , data & ~ 1ULL ) ) vcpu -> arch . pv_time_enabled = false ; else vcpu -> arch . pv_time_enabled = true <S2SV_ModEnd> ; break ;"
128,"static __u8 * lg_report_fixup ( struct hid_device * hdev , __u8 * rdesc , unsigned int * rsize ) { struct lg_drv_data * drv_data = hid_get_drvdata ( hdev ) ; struct usb_device_descriptor * udesc ; __u16 bcdDevice , rev_maj , rev_min ; <S2SV_StartBug> if ( ( drv_data -> quirks & LG_RDESC ) && * rsize >= 90 && rdesc [ 83 ] == 0x26 && <S2SV_EndBug> rdesc [ 84 ] == 0x8c && rdesc [ 85 ] == 0x02 ) { hid_info ( hdev , ""fixing<S2SV_blank>up<S2SV_blank>Logitech<S2SV_blank>keyboard<S2SV_blank>report<S2SV_blank>descriptor\\n"" ) ; rdesc [ 84 ] = rdesc [ 89 ] = 0x4d ; rdesc [ 85 ] = rdesc [ 90 ] = 0x10 ; } <S2SV_StartBug> if ( ( drv_data -> quirks & LG_RDESC_REL_ABS ) && * rsize >= 50 && <S2SV_EndBug> rdesc [ 32 ] == 0x81 && rdesc [ 33 ] == 0x06 && rdesc [ 49 ] == 0x81 && rdesc [ 50 ] == 0x06 ) { hid_info ( hdev , ""fixing<S2SV_blank>up<S2SV_blank>rel/abs<S2SV_blank>in<S2SV_blank>Logitech<S2SV_blank>report<S2SV_blank>descriptor\\n"" ) ; rdesc [ 33 ] = rdesc [ 50 ] = 0x02 ; } switch ( hdev -> product ) { case USB_DEVICE_ID_LOGITECH_WHEEL : udesc = & ( hid_to_usb_dev ( hdev ) -> descriptor ) ; if ( ! udesc ) { hid_err ( hdev , ""NULL<S2SV_blank>USB<S2SV_blank>device<S2SV_blank>descriptor\\n"" ) ; break ; } bcdDevice = le16_to_cpu ( udesc -> bcdDevice ) ; rev_maj = bcdDevice >> 8 ; rev_min = bcdDevice & 0xff ; if ( rev_maj == 1 && rev_min == 2 && * rsize == DF_RDESC_ORIG_SIZE ) { hid_info ( hdev , ""fixing<S2SV_blank>up<S2SV_blank>Logitech<S2SV_blank>Driving<S2SV_blank>Force<S2SV_blank>report<S2SV_blank>descriptor\\n"" ) ; rdesc = df_rdesc_fixed ; * rsize = sizeof ( df_rdesc_fixed ) ; } break ; case USB_DEVICE_ID_LOGITECH_MOMO_WHEEL : if ( * rsize == MOMO_RDESC_ORIG_SIZE ) { hid_info ( hdev , ""fixing<S2SV_blank>up<S2SV_blank>Logitech<S2SV_blank>Momo<S2SV_blank>Force<S2SV_blank>(Red)<S2SV_blank>report<S2SV_blank>descriptor\\n"" ) ; rdesc = momo_rdesc_fixed ; * rsize = sizeof ( momo_rdesc_fixed ) ; } break ; case USB_DEVICE_ID_LOGITECH_MOMO_WHEEL2 : if ( * rsize == MOMO2_RDESC_ORIG_SIZE ) { hid_info ( hdev , ""fixing<S2SV_blank>up<S2SV_blank>Logitech<S2SV_blank>Momo<S2SV_blank>Racing<S2SV_blank>Force<S2SV_blank>(Black)<S2SV_blank>report<S2SV_blank>descriptor\\n"" ) ; rdesc = momo2_rdesc_fixed ; * rsize = sizeof ( momo2_rdesc_fixed ) ; } break ; case USB_DEVICE_ID_LOGITECH_VIBRATION_WHEEL : if ( * rsize == FV_RDESC_ORIG_SIZE ) { hid_info ( hdev , ""fixing<S2SV_blank>up<S2SV_blank>Logitech<S2SV_blank>Formula<S2SV_blank>Vibration<S2SV_blank>report<S2SV_blank>descriptor\\n"" ) ; rdesc = fv_rdesc_fixed ; * rsize = sizeof ( fv_rdesc_fixed ) ; } break ; case USB_DEVICE_ID_LOGITECH_DFP_WHEEL : if ( * rsize == DFP_RDESC_ORIG_SIZE ) { hid_info ( hdev , ""fixing<S2SV_blank>up<S2SV_blank>Logitech<S2SV_blank>Driving<S2SV_blank>Force<S2SV_blank>Pro<S2SV_blank>report<S2SV_blank>descriptor\\n"" ) ; rdesc = dfp_rdesc_fixed ; * rsize = sizeof ( dfp_rdesc_fixed ) ; } break ; case USB_DEVICE_ID_LOGITECH_WII_WHEEL : if ( * rsize >= 101 && rdesc [ 41 ] == 0x95 && rdesc [ 42 ] == 0x0B && rdesc [ 47 ] == 0x05 && rdesc [ 48 ] == 0x09 ) { hid_info ( hdev , ""fixing<S2SV_blank>up<S2SV_blank>Logitech<S2SV_blank>Speed<S2SV_blank>Force<S2SV_blank>Wireless<S2SV_blank>report<S2SV_blank>descriptor\\n"" ) ; rdesc [ 41 ] = 0x05 ; rdesc [ 42 ] = 0x09 ; rdesc [ 47 ] = 0x95 ; rdesc [ 48 ] = 0x0B ; } break ; } return rdesc ; }",* rsize >= 91 <S2SV_ModEnd> && rdesc [ <S2SV_ModStart> * rsize >= 51 <S2SV_ModEnd> && rdesc [
129,"<S2SV_StartBug> static int enable ( void ) { <S2SV_EndBug> <S2SV_StartBug> LOG_INFO ( ""%s"" , __func__ ) ; <S2SV_EndBug> if ( ! interface_ready ( ) ) return BT_STATUS_NOT_READY ; stack_manager_get_interface ( ) -> start_up_stack_async ( ) ; return BT_STATUS_SUCCESS ; }","int enable ( bool start_restricted <S2SV_ModEnd> ) { LOG_INFO <S2SV_ModStart> { LOG_INFO ( LOG_TAG , ""%s:<S2SV_blank>start<S2SV_blank>restricted<S2SV_blank>=<S2SV_blank>%d"" , __func__ , start_restricted ) ; restricted_mode = start_restricted <S2SV_ModEnd> ; if ("
130,"static ssize_t _consolefs_writev ( oe_fd_t * desc , const struct oe_iovec * iov , int iovcnt ) { ssize_t ret = - 1 ; file_t * file = _cast_file ( desc ) ; void * buf = NULL ; size_t buf_size = 0 ; <S2SV_StartBug> if ( ! file || ( ! iov && iovcnt ) || iovcnt < 0 || iovcnt > OE_IOV_MAX ) <S2SV_EndBug> OE_RAISE_ERRNO ( OE_EINVAL ) ; <S2SV_StartBug> if ( oe_iov_pack ( iov , iovcnt , & buf , & buf_size ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> OE_RAISE_ERRNO ( OE_ENOMEM ) ; <S2SV_EndBug> if ( oe_syscall_writev_ocall ( & ret , file -> host_fd , buf , iovcnt , buf_size ) != OE_OK ) { OE_RAISE_ERRNO ( OE_EINVAL ) ; } <S2SV_StartBug> done : <S2SV_EndBug> if ( buf ) oe_free ( buf ) ; return ret ; }","= 0 ; size_t data_size = 0 ; <S2SV_ModStart> , & buf_size , & data_size <S2SV_ModStart> OE_RAISE_ERRNO ( OE_ENOMEM ) ; if ( data_size > OE_SSIZE_MAX ) OE_RAISE_ERRNO ( OE_EINVAL <S2SV_ModStart> ) ; } if ( ret > ( ssize_t ) data_size ) { ret = - 1 ; OE_RAISE_ERRNO ( OE_EINVAL ) ; }"
131,size_t jsuGetFreeStack ( ) { # ifdef ARM void * frame = __builtin_frame_address ( 0 ) ; size_t stackPos = ( size_t ) ( ( char * ) frame ) ; size_t stackEnd = ( size_t ) ( ( char * ) & LINKER_END_VAR ) ; if ( stackPos < stackEnd ) return 0 ; return stackPos - stackEnd ; # elif defined ( LINUX ) char ptr ; extern void * STACK_BASE ; uint32_t count = ( uint32_t ) ( ( size_t ) STACK_BASE - ( size_t ) & ptr ) ; <S2SV_StartBug> return 1000000 - count ; <S2SV_EndBug> # else return 1000000 ; # endif },ptr ) ; const uint32_t max_stack = 1000000 ; if ( count > max_stack ) return 0 ; return max_stack <S2SV_ModEnd> - count ;
132,"void CleanupOutput ( char * str ) { char * s , * t ; int period = 0 ; s = t = str ; <S2SV_StartBug> while ( * s && * s != '}' ) { <S2SV_EndBug> <S2SV_StartBug> if ( * s == '\\n' ) * s = '<S2SV_blank>' ; <S2SV_EndBug> <S2SV_StartBug> if ( ( * s == '<S2SV_blank>' || * s == '\\n' ) && ( s [ 1 ] == '<S2SV_blank>' || s [ 1 ] == '\\n' ) ) s ++ ; <S2SV_EndBug> else * t ++ = * s ++ ; } while ( * s ) * t ++ = * s ++ ; * t = 0 ; s = t = str ; while ( * s ) { if ( * s == '.' ) { period = 1 ; * t ++ = * s ++ ; } else if ( * s == '-' && s [ 1 ] == '0' && s [ 2 ] == '<S2SV_blank>' ) { s ++ ; } else if ( * s <= '9' && * s >= '0' ) { * t ++ = * s ++ ; } else if ( * s == '\\n' && ( t > str && t [ - 1 ] == '\\n' ) ) { s ++ ; } else if ( period ) { while ( t > str && t [ - 1 ] == '0' ) t -- ; if ( t > str && t [ - 1 ] == '.' ) t -- ; while ( * s == '<S2SV_blank>' && s [ 1 ] == '<S2SV_blank>' ) s ++ ; period = 0 ; * t ++ = * s ++ ; } else if ( * s == '<S2SV_blank>' && s [ 1 ] == '<S2SV_blank>' ) s ++ ; else { period = 0 ; * t ++ = * s ++ ; } } * t = 0 ; s = t = str ; while ( * s ) { if ( * s == '-' && s [ 1 ] == '0' && s [ 2 ] == '<S2SV_blank>' ) { s ++ ; } else * t ++ = * s ++ ; } * t = 0 ; }",( * s <S2SV_ModEnd> ) { if <S2SV_ModStart> == '\\n' ) { <S2SV_ModStart> = '<S2SV_blank>' ; } if ( ( * s == '<S2SV_blank>' ) && ( s [ 1 ] <S2SV_ModEnd> == '<S2SV_blank>' || <S2SV_ModStart> == '<S2SV_blank>' || s [ 1 ] == '\\n' || s [ 1 ] == 0 ) ) { s ++ ; } else { * t ++ = * s ++ ; } } * t = 0 ; s = t = str ; while ( * s ) { if ( * s == '.' ) { period = 1 ; * t ++ = * s ++ ; } else if ( isdigit ( * s ) ) { * t ++ = * s ++ ; } else if ( period ) { while ( t > str && t [ - 1 ] == '0' ) { t -- ; } if ( t > str && t [ - 1 ] == '.' ) { t -- ; if ( t > str && ! isdigit ( t [ - 1 ] ) ) { * t ++ = '0' ; } } period = 0 ; * t ++ = * s ++ ; } else { period = 0 ; * t ++ = * s ++ ; } } * t = 0 ; s = t = str ; while ( * s ) { if ( * s == '-' && s [ 1 ] == '0' && s [ 2 <S2SV_ModEnd> ] == '<S2SV_blank>' <S2SV_ModStart> ] == '<S2SV_blank>' <S2SV_ModEnd> ) { s
133,"static int futex_wait_requeue_pi ( u32 __user * uaddr , unsigned int flags , u32 val , ktime_t * abs_time , u32 bitset , u32 __user * uaddr2 ) { struct hrtimer_sleeper timeout , * to = NULL ; struct rt_mutex_waiter rt_waiter ; struct rt_mutex * pi_mutex = NULL ; struct futex_hash_bucket * hb ; union futex_key key2 = FUTEX_KEY_INIT ; struct futex_q q = futex_q_init ; <S2SV_StartBug> int res , ret ; <S2SV_EndBug> if ( ! bitset ) return - EINVAL ; if ( abs_time ) { to = & timeout ; hrtimer_init_on_stack ( & to -> timer , ( flags & FLAGS_CLOCKRT ) ? CLOCK_REALTIME : CLOCK_MONOTONIC , HRTIMER_MODE_ABS ) ; hrtimer_init_sleeper ( to , current ) ; hrtimer_set_expires_range_ns ( & to -> timer , * abs_time , current -> timer_slack_ns ) ; } debug_rt_mutex_init_waiter ( & rt_waiter ) ; rt_waiter . task = NULL ; ret = get_futex_key ( uaddr2 , flags & FLAGS_SHARED , & key2 , VERIFY_WRITE ) ; if ( unlikely ( ret != 0 ) ) goto out ; q . bitset = bitset ; q . rt_waiter = & rt_waiter ; q . requeue_pi_key = & key2 ; ret = futex_wait_setup ( uaddr , val , flags , & q , & hb ) ; if ( ret ) goto out_key2 ; futex_wait_queue_me ( hb , & q , to ) ; spin_lock ( & hb -> lock ) ; ret = handle_early_requeue_pi_wakeup ( hb , & q , & key2 , to ) ; spin_unlock ( & hb -> lock ) ; if ( ret ) goto out_put_keys ; if ( ! q . rt_waiter ) { if ( q . pi_state && ( q . pi_state -> owner != current ) ) { spin_lock ( q . lock_ptr ) ; ret = fixup_pi_state_owner ( uaddr2 , & q , current ) ; spin_unlock ( q . lock_ptr ) ; } } else { WARN_ON ( ! q . pi_state ) ; pi_mutex = & q . pi_state -> pi_mutex ; ret = rt_mutex_finish_proxy_lock ( pi_mutex , to , & rt_waiter , 1 ) ; debug_rt_mutex_free_waiter ( & rt_waiter ) ; spin_lock ( q . lock_ptr ) ; res = fixup_owner ( uaddr2 , & q , ! ret ) ; if ( res ) ret = ( res < 0 ) ? res : 0 ; unqueue_me_pi ( & q ) ; } if ( ret == - EFAULT ) { if ( pi_mutex && rt_mutex_owner ( pi_mutex ) == current ) rt_mutex_unlock ( pi_mutex ) ; } else if ( ret == - EINTR ) { ret = - EWOULDBLOCK ; } out_put_keys : put_futex_key ( & q . key ) ; out_key2 : put_futex_key ( & key2 ) ; out : if ( to ) { hrtimer_cancel ( & to -> timer ) ; destroy_hrtimer_on_stack ( & to -> timer ) ; } return ret ; }","res , ret ; if ( uaddr == uaddr2 ) return - EINVAL"
134,"<S2SV_StartBug> static void iwl_sta_ucode_activate ( struct iwl_priv * priv , u8 sta_id ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> if ( ! ( priv -> stations [ sta_id ] . used & IWL_STA_DRIVER_ACTIVE ) ) IWL_ERR ( priv , ""ACTIVATE<S2SV_blank>a<S2SV_blank>non<S2SV_blank>DRIVER<S2SV_blank>active<S2SV_blank>station<S2SV_blank>id<S2SV_blank>%u<S2SV_blank>"" ""addr<S2SV_blank>%pM\\n"" , sta_id , priv -> stations [ sta_id ] . sta . sta . addr ) ; if ( priv -> stations [ sta_id ] . used & IWL_STA_UCODE_ACTIVE ) { IWL_DEBUG_ASSOC ( priv , ""STA<S2SV_blank>id<S2SV_blank>%u<S2SV_blank>addr<S2SV_blank>%pM<S2SV_blank>already<S2SV_blank>present<S2SV_blank>in<S2SV_blank>uCode<S2SV_blank>"" ""(according<S2SV_blank>to<S2SV_blank>driver)\\n"" , sta_id , priv -> stations [ sta_id ] . sta . sta . addr ) ; } else { priv -> stations [ sta_id ] . used |= IWL_STA_UCODE_ACTIVE ; IWL_DEBUG_ASSOC ( priv , ""Added<S2SV_blank>STA<S2SV_blank>id<S2SV_blank>%u<S2SV_blank>addr<S2SV_blank>%pM<S2SV_blank>to<S2SV_blank>uCode\\n"" , sta_id , priv -> stations [ sta_id ] . sta . sta . addr ) ; } <S2SV_StartBug> } <S2SV_EndBug>","<S2SV_null> <S2SV_null> static int <S2SV_ModEnd> iwl_sta_ucode_activate ( struct <S2SV_ModStart> sta_id ) { if ( sta_id >= IWLAGN_STATION_COUNT ) { IWL_ERR ( priv , ""invalid<S2SV_blank>sta_id<S2SV_blank>%u"" , sta_id ) ; return - EINVAL ; } <S2SV_ModStart> ) ; } return 0 ;"
135,"static int store_icy ( URLContext * h , int size ) { HTTPContext * s = h -> priv_data ; <S2SV_StartBug> int remaining = s -> icy_metaint - s -> icy_data_read ; <S2SV_EndBug> if ( remaining < 0 ) return AVERROR_INVALIDDATA ; if ( ! remaining ) { uint8_t ch ; int len = http_read_stream_all ( h , & ch , 1 ) ; if ( len < 0 ) return len ; if ( ch > 0 ) { char data [ 255 * 16 + 1 ] ; int ret ; len = ch * 16 ; ret = http_read_stream_all ( h , data , len ) ; if ( ret < 0 ) return ret ; data [ len + 1 ] = 0 ; if ( ( ret = av_opt_set ( s , ""icy_metadata_packet"" , data , 0 ) ) < 0 ) return ret ; update_metadata ( s , data ) ; } s -> icy_data_read = 0 ; remaining = s -> icy_metaint ; } return FFMIN ( size , remaining ) ; }",-> priv_data ; uint64_t remaining ; if ( s -> icy_metaint < s -> icy_data_read ) return AVERROR_INVALIDDATA ; <S2SV_ModEnd> remaining = s <S2SV_ModStart> s -> icy_data_read <S2SV_ModEnd> ; if (
136,"static PyObject * parsenumber ( struct compiling * c , const char * s ) { char * dup , * end ; PyObject * res = NULL ; assert ( s != NULL ) ; if ( strchr ( s , '_' ) == NULL ) { return parsenumber_raw ( c , s ) ; } dup = PyMem_Malloc ( strlen ( s ) + 1 ) ; <S2SV_StartBug> end = dup ; <S2SV_EndBug> for ( ; * s ; s ++ ) { if ( * s != '_' ) { * end ++ = * s ; } } * end = '\\0' ; res = parsenumber_raw ( c , dup ) ; PyMem_Free ( dup ) ; return res ; }",1 ) ; if ( dup == NULL ) { return PyErr_NoMemory ( ) ; }
137,"static int atl2_probe ( struct pci_dev * pdev , const struct pci_device_id * ent ) { struct net_device * netdev ; struct atl2_adapter * adapter ; static int cards_found ; unsigned long mmio_start ; int mmio_len ; int err ; cards_found = 0 ; err = pci_enable_device ( pdev ) ; if ( err ) return err ; if ( pci_set_dma_mask ( pdev , DMA_BIT_MASK ( 32 ) ) && pci_set_consistent_dma_mask ( pdev , DMA_BIT_MASK ( 32 ) ) ) { printk ( KERN_ERR ""atl2:<S2SV_blank>No<S2SV_blank>usable<S2SV_blank>DMA<S2SV_blank>configuration,<S2SV_blank>aborting\\n"" ) ; goto err_dma ; } err = pci_request_regions ( pdev , atl2_driver_name ) ; if ( err ) goto err_pci_reg ; pci_set_master ( pdev ) ; err = - ENOMEM ; netdev = alloc_etherdev ( sizeof ( struct atl2_adapter ) ) ; if ( ! netdev ) goto err_alloc_etherdev ; SET_NETDEV_DEV ( netdev , & pdev -> dev ) ; pci_set_drvdata ( pdev , netdev ) ; adapter = netdev_priv ( netdev ) ; adapter -> netdev = netdev ; adapter -> pdev = pdev ; adapter -> hw . back = adapter ; mmio_start = pci_resource_start ( pdev , 0x0 ) ; mmio_len = pci_resource_len ( pdev , 0x0 ) ; adapter -> hw . mem_rang = ( u32 ) mmio_len ; adapter -> hw . hw_addr = ioremap ( mmio_start , mmio_len ) ; if ( ! adapter -> hw . hw_addr ) { err = - EIO ; goto err_ioremap ; } atl2_setup_pcicmd ( pdev ) ; netdev -> netdev_ops = & atl2_netdev_ops ; netdev -> ethtool_ops = & atl2_ethtool_ops ; netdev -> watchdog_timeo = 5 * HZ ; strncpy ( netdev -> name , pci_name ( pdev ) , sizeof ( netdev -> name ) - 1 ) ; netdev -> mem_start = mmio_start ; netdev -> mem_end = mmio_start + mmio_len ; adapter -> bd_number = cards_found ; adapter -> pci_using_64 = false ; err = atl2_sw_init ( adapter ) ; if ( err ) goto err_sw_init ; err = - EIO ; <S2SV_StartBug> netdev -> hw_features = NETIF_F_SG | NETIF_F_HW_VLAN_CTAG_RX ; <S2SV_EndBug> netdev -> features |= ( NETIF_F_HW_VLAN_CTAG_TX | NETIF_F_HW_VLAN_CTAG_RX ) ; atl2_phy_init ( & adapter -> hw ) ; if ( atl2_reset_hw ( & adapter -> hw ) ) { err = - EIO ; goto err_reset ; } atl2_read_mac_addr ( & adapter -> hw ) ; memcpy ( netdev -> dev_addr , adapter -> hw . mac_addr , netdev -> addr_len ) ; if ( ! is_valid_ether_addr ( netdev -> dev_addr ) ) { err = - EIO ; goto err_eeprom ; } atl2_check_options ( adapter ) ; setup_timer ( & adapter -> watchdog_timer , atl2_watchdog , ( unsigned long ) adapter ) ; setup_timer ( & adapter -> phy_config_timer , atl2_phy_config , ( unsigned long ) adapter ) ; INIT_WORK ( & adapter -> reset_task , atl2_reset_task ) ; INIT_WORK ( & adapter -> link_chg_task , atl2_link_chg_task ) ; strcpy ( netdev -> name , ""eth%d"" ) ; err = register_netdev ( netdev ) ; if ( err ) goto err_register ; netif_carrier_off ( netdev ) ; netif_stop_queue ( netdev ) ; cards_found ++ ; return 0 ; err_reset : err_register : err_sw_init : err_eeprom : iounmap ( adapter -> hw . hw_addr ) ; err_ioremap : free_netdev ( netdev ) ; err_alloc_etherdev : pci_release_regions ( pdev ) ; err_pci_reg : err_dma : pci_disable_device ( pdev ) ; return err ; }",-> hw_features = <S2SV_ModEnd> NETIF_F_HW_VLAN_CTAG_RX ; netdev
138,"void TEMPLATE ( process_block_dec ) ( decoder_info_t * decoder_info , int size , int yposY , int xposY , int sub ) { int width = decoder_info -> width ; int height = decoder_info -> height ; stream_t * stream = decoder_info -> stream ; frame_type_t frame_type = decoder_info -> frame_info . frame_type ; int split_flag = 0 ; if ( yposY >= height || xposY >= width ) return ; int decode_this_size = ( yposY + size <= height ) && ( xposY + size <= width ) ; int decode_rectangular_size = ! decode_this_size && frame_type != I_FRAME ; int bit_start = stream -> bitcnt ; int mode = MODE_SKIP ; block_context_t block_context ; TEMPLATE ( find_block_contexts ) ( yposY , xposY , height , width , size , decoder_info -> deblock_data , & block_context , decoder_info -> use_block_contexts ) ; decoder_info -> block_context = & block_context ; split_flag = decode_super_mode ( decoder_info , size , decode_this_size ) ; mode = decoder_info -> mode ; if ( size == ( 1 << decoder_info -> log2_sb_size ) && ( split_flag || mode != MODE_SKIP ) && decoder_info -> max_delta_qp > 0 ) { int delta_qp = read_delta_qp ( stream ) ; int prev_qp ; if ( yposY == 0 && xposY == 0 ) prev_qp = decoder_info -> frame_info . qp ; else prev_qp = decoder_info -> frame_info . qpb ; decoder_info -> frame_info . qpb = prev_qp + delta_qp ; } decoder_info -> bit_count . super_mode [ decoder_info -> bit_count . stat_frame_type ] += ( stream -> bitcnt - bit_start ) ; <S2SV_StartBug> if ( split_flag ) { <S2SV_EndBug> int new_size = size / 2 ; TEMPLATE ( process_block_dec ) ( decoder_info , new_size , yposY + 0 * new_size , xposY + 0 * new_size , sub ) ; TEMPLATE ( process_block_dec ) ( decoder_info , new_size , yposY + 1 * new_size , xposY + 0 * new_size , sub ) ; TEMPLATE ( process_block_dec ) ( decoder_info , new_size , yposY + 0 * new_size , xposY + 1 * new_size , sub ) ; TEMPLATE ( process_block_dec ) ( decoder_info , new_size , yposY + 1 * new_size , xposY + 1 * new_size , sub ) ; } else if ( decode_this_size || decode_rectangular_size ) { decode_block ( decoder_info , size , yposY , xposY , sub ) ; } }",if ( split_flag && size >= MIN_BLOCK_SIZE
139,"static ssize_t hfi1_file_write ( struct file * fp , const char __user * data , size_t count , loff_t * offset ) { const struct hfi1_cmd __user * ucmd ; struct hfi1_filedata * fd = fp -> private_data ; struct hfi1_ctxtdata * uctxt = fd -> uctxt ; struct hfi1_cmd cmd ; struct hfi1_user_info uinfo ; struct hfi1_tid_info tinfo ; unsigned long addr ; ssize_t consumed = 0 , copy = 0 , ret = 0 ; void * dest = NULL ; __u64 user_val = 0 ; int uctxt_required = 1 ; int must_be_root = 0 ; <S2SV_StartBug> if ( count < sizeof ( cmd ) ) { <S2SV_EndBug> ret = - EINVAL ; goto bail ; } ucmd = ( const struct hfi1_cmd __user * ) data ; if ( copy_from_user ( & cmd , ucmd , sizeof ( cmd ) ) ) { ret = - EFAULT ; goto bail ; } consumed = sizeof ( cmd ) ; switch ( cmd . type ) { case HFI1_CMD_ASSIGN_CTXT : uctxt_required = 0 ; copy = sizeof ( uinfo ) ; dest = & uinfo ; break ; case HFI1_CMD_SDMA_STATUS_UPD : case HFI1_CMD_CREDIT_UPD : copy = 0 ; break ; case HFI1_CMD_TID_UPDATE : case HFI1_CMD_TID_FREE : case HFI1_CMD_TID_INVAL_READ : copy = sizeof ( tinfo ) ; dest = & tinfo ; break ; case HFI1_CMD_USER_INFO : case HFI1_CMD_RECV_CTRL : case HFI1_CMD_POLL_TYPE : case HFI1_CMD_ACK_EVENT : case HFI1_CMD_CTXT_INFO : case HFI1_CMD_SET_PKEY : case HFI1_CMD_CTXT_RESET : copy = 0 ; user_val = cmd . addr ; break ; case HFI1_CMD_EP_INFO : case HFI1_CMD_EP_ERASE_CHIP : case HFI1_CMD_EP_ERASE_RANGE : case HFI1_CMD_EP_READ_RANGE : case HFI1_CMD_EP_WRITE_RANGE : uctxt_required = 0 ; must_be_root = 1 ; copy = 0 ; break ; default : ret = - EINVAL ; goto bail ; } if ( copy ) { if ( copy_from_user ( dest , ( void __user * ) cmd . addr , copy ) ) { ret = - EFAULT ; goto bail ; } consumed += copy ; } if ( uctxt_required && ! uctxt ) { ret = - EINVAL ; goto bail ; } if ( must_be_root && ! capable ( CAP_SYS_ADMIN ) ) { ret = - EPERM ; goto bail ; } switch ( cmd . type ) { case HFI1_CMD_ASSIGN_CTXT : ret = assign_ctxt ( fp , & uinfo ) ; if ( ret < 0 ) goto bail ; ret = setup_ctxt ( fp ) ; if ( ret ) goto bail ; ret = user_init ( fp ) ; break ; case HFI1_CMD_CTXT_INFO : ret = get_ctxt_info ( fp , ( void __user * ) ( unsigned long ) user_val , cmd . len ) ; break ; case HFI1_CMD_USER_INFO : ret = get_base_info ( fp , ( void __user * ) ( unsigned long ) user_val , cmd . len ) ; break ; case HFI1_CMD_SDMA_STATUS_UPD : break ; case HFI1_CMD_CREDIT_UPD : if ( uctxt && uctxt -> sc ) sc_return_credits ( uctxt -> sc ) ; break ; case HFI1_CMD_TID_UPDATE : ret = hfi1_user_exp_rcv_setup ( fp , & tinfo ) ; if ( ! ret ) { addr = ( unsigned long ) cmd . addr + offsetof ( struct hfi1_tid_info , tidcnt ) ; if ( copy_to_user ( ( void __user * ) addr , & tinfo . tidcnt , sizeof ( tinfo . tidcnt ) + sizeof ( tinfo . length ) ) ) ret = - EFAULT ; } break ; case HFI1_CMD_TID_INVAL_READ : ret = hfi1_user_exp_rcv_invalid ( fp , & tinfo ) ; if ( ret ) break ; addr = ( unsigned long ) cmd . addr + offsetof ( struct hfi1_tid_info , tidcnt ) ; if ( copy_to_user ( ( void __user * ) addr , & tinfo . tidcnt , sizeof ( tinfo . tidcnt ) ) ) ret = - EFAULT ; break ; case HFI1_CMD_TID_FREE : ret = hfi1_user_exp_rcv_clear ( fp , & tinfo ) ; if ( ret ) break ; addr = ( unsigned long ) cmd . addr + offsetof ( struct hfi1_tid_info , tidcnt ) ; if ( copy_to_user ( ( void __user * ) addr , & tinfo . tidcnt , sizeof ( tinfo . tidcnt ) ) ) ret = - EFAULT ; break ; case HFI1_CMD_RECV_CTRL : ret = manage_rcvq ( uctxt , fd -> subctxt , ( int ) user_val ) ; break ; case HFI1_CMD_POLL_TYPE : uctxt -> poll_type = ( typeof ( uctxt -> poll_type ) ) user_val ; break ; case HFI1_CMD_ACK_EVENT : ret = user_event_ack ( uctxt , fd -> subctxt , user_val ) ; break ; case HFI1_CMD_SET_PKEY : if ( HFI1_CAP_IS_USET ( PKEY_CHECK ) ) ret = set_ctxt_pkey ( uctxt , fd -> subctxt , user_val ) ; else ret = - EPERM ; break ; case HFI1_CMD_CTXT_RESET : { struct send_context * sc ; struct hfi1_devdata * dd ; if ( ! uctxt || ! uctxt -> dd || ! uctxt -> sc ) { ret = - EINVAL ; break ; } dd = uctxt -> dd ; sc = uctxt -> sc ; wait_event_interruptible_timeout ( sc -> halt_wait , ( sc -> flags & SCF_HALTED ) , msecs_to_jiffies ( SEND_CTXT_HALT_TIMEOUT ) ) ; if ( ! ( sc -> flags & SCF_HALTED ) ) { ret = - ENOLCK ; break ; } if ( sc -> flags & SCF_FROZEN ) { wait_event_interruptible_timeout ( dd -> event_queue , ! ( ACCESS_ONCE ( dd -> flags ) & HFI1_FROZEN ) , msecs_to_jiffies ( SEND_CTXT_HALT_TIMEOUT ) ) ; if ( dd -> flags & HFI1_FROZEN ) { ret = - ENOLCK ; break ; } if ( dd -> flags & HFI1_FORCED_FREEZE ) { ret = - ENODEV ; break ; } sc_disable ( sc ) ; ret = sc_enable ( sc ) ; hfi1_rcvctrl ( dd , HFI1_RCVCTRL_CTXT_ENB , uctxt -> ctxt ) ; } else { ret = sc_restart ( sc ) ; } if ( ! ret ) sc_return_credits ( sc ) ; break ; } case HFI1_CMD_EP_INFO : case HFI1_CMD_EP_ERASE_CHIP : case HFI1_CMD_EP_ERASE_RANGE : case HFI1_CMD_EP_READ_RANGE : case HFI1_CMD_EP_WRITE_RANGE : ret = handle_eprom_command ( fp , & cmd ) ; break ; } if ( ret >= 0 ) ret = consumed ; bail : return ret ; }",; if ( WARN_ON_ONCE ( ! ib_safe_file_access ( fp ) ) ) return - EACCES ; if (
140,"SQLRETURN SQLSetDescFieldW ( SQLHDESC descriptor_handle , SQLSMALLINT rec_number , SQLSMALLINT field_identifier , SQLPOINTER value , SQLINTEGER buffer_length ) { DMHDESC descriptor = ( DMHDESC ) descriptor_handle ; SQLRETURN ret ; SQLCHAR s1 [ 100 + LOG_MESSAGE_LEN ] ; int isStrField = 0 ; if ( ! __validate_desc ( descriptor ) ) { dm_log_write ( __FILE__ , __LINE__ , LOG_INFO , LOG_INFO , ""Error:<S2SV_blank>SQL_INVALID_HANDLE"" ) ; # ifdef WITH_HANDLE_REDIRECT { DMHDESC parent_desc ; parent_desc = find_parent_handle ( descriptor , SQL_HANDLE_DESC ) ; if ( parent_desc ) { dm_log_write ( __FILE__ , __LINE__ , LOG_INFO , LOG_INFO , ""Info:<S2SV_blank>found<S2SV_blank>parent<S2SV_blank>handle"" ) ; if ( CHECK_SQLSETDESCFIELDW ( parent_desc -> connection ) ) { dm_log_write ( __FILE__ , __LINE__ , LOG_INFO , LOG_INFO , ""Info:<S2SV_blank>calling<S2SV_blank>redirected<S2SV_blank>driver<S2SV_blank>function"" ) ; return SQLSETDESCFIELDW ( parent_desc -> connection , descriptor , rec_number , field_identifier , value , buffer_length ) ; } } } # endif return SQL_INVALID_HANDLE ; } function_entry ( descriptor ) ; if ( log_info . log_flag ) { <S2SV_StartBug> sprintf ( descriptor -> msg , ""\\n\\t\\tEntry:\\\n<S2SV_blank>\\n\\t\\t\\tDescriptor<S2SV_blank>=<S2SV_blank>%p\\\n<S2SV_blank>\\n\\t\\t\\tRec<S2SV_blank>Number<S2SV_blank>=<S2SV_blank>%d\\\n<S2SV_blank>\\n\\t\\t\\tField<S2SV_blank>Ident<S2SV_blank>=<S2SV_blank>%s\\\n<S2SV_blank>\\n\\t\\t\\tValue<S2SV_blank>=<S2SV_blank>%p\\\n<S2SV_blank>\\n\\t\\t\\tBuffer<S2SV_blank>Length<S2SV_blank>=<S2SV_blank>%d"" , <S2SV_EndBug> descriptor , rec_number , __desc_attr_as_string ( s1 , field_identifier ) , value , ( int ) buffer_length ) ; dm_log_write ( __FILE__ , __LINE__ , LOG_INFO , LOG_INFO , descriptor -> msg ) ; } thread_protect ( SQL_HANDLE_DESC , descriptor ) ; if ( descriptor -> connection -> state < STATE_C4 ) { dm_log_write ( __FILE__ , __LINE__ , LOG_INFO , LOG_INFO , ""Error:<S2SV_blank>HY010"" ) ; __post_internal_error ( & descriptor -> error , ERROR_HY010 , NULL , descriptor -> connection -> environment -> requested_version ) ; return function_return_nodrv ( SQL_HANDLE_DESC , descriptor , SQL_ERROR ) ; } if ( __check_stmt_from_desc ( descriptor , STATE_S8 ) || __check_stmt_from_desc ( descriptor , STATE_S9 ) || __check_stmt_from_desc ( descriptor , STATE_S10 ) || __check_stmt_from_desc ( descriptor , STATE_S11 ) || __check_stmt_from_desc ( descriptor , STATE_S12 ) || __check_stmt_from_desc ( descriptor , STATE_S13 ) || __check_stmt_from_desc ( descriptor , STATE_S14 ) || __check_stmt_from_desc ( descriptor , STATE_S15 ) ) { dm_log_write ( __FILE__ , __LINE__ , LOG_INFO , LOG_INFO , ""Error:<S2SV_blank>HY010"" ) ; __post_internal_error ( & descriptor -> error , ERROR_HY010 , NULL , descriptor -> connection -> environment -> requested_version ) ; return function_return_nodrv ( SQL_HANDLE_DESC , descriptor , SQL_ERROR ) ; } if ( rec_number < 0 ) { __post_internal_error ( & descriptor -> error , ERROR_07009 , NULL , descriptor -> connection -> environment -> requested_version ) ; return function_return_nodrv ( SQL_HANDLE_DESC , descriptor , SQL_ERROR ) ; } switch ( field_identifier ) { case SQL_DESC_ALLOC_TYPE : case SQL_DESC_ARRAY_SIZE : case SQL_DESC_ARRAY_STATUS_PTR : case SQL_DESC_BIND_OFFSET_PTR : case SQL_DESC_BIND_TYPE : case SQL_DESC_COUNT : case SQL_DESC_ROWS_PROCESSED_PTR : case SQL_DESC_AUTO_UNIQUE_VALUE : case SQL_DESC_CASE_SENSITIVE : case SQL_DESC_CONCISE_TYPE : case SQL_DESC_DATA_PTR : case SQL_DESC_DATETIME_INTERVAL_CODE : case SQL_DESC_DATETIME_INTERVAL_PRECISION : case SQL_DESC_DISPLAY_SIZE : case SQL_DESC_FIXED_PREC_SCALE : case SQL_DESC_INDICATOR_PTR : case SQL_DESC_LENGTH : case SQL_DESC_NULLABLE : case SQL_DESC_NUM_PREC_RADIX : case SQL_DESC_OCTET_LENGTH : case SQL_DESC_OCTET_LENGTH_PTR : case SQL_DESC_PARAMETER_TYPE : case SQL_DESC_PRECISION : case SQL_DESC_ROWVER : case SQL_DESC_SCALE : case SQL_DESC_SEARCHABLE : case SQL_DESC_TYPE : case SQL_DESC_UNNAMED : case SQL_DESC_UNSIGNED : case SQL_DESC_UPDATABLE : isStrField = 0 ; break ; case SQL_DESC_BASE_COLUMN_NAME : case SQL_DESC_BASE_TABLE_NAME : case SQL_DESC_CATALOG_NAME : case SQL_DESC_LABEL : case SQL_DESC_LITERAL_PREFIX : case SQL_DESC_LITERAL_SUFFIX : case SQL_DESC_LOCAL_TYPE_NAME : case SQL_DESC_NAME : case SQL_DESC_SCHEMA_NAME : case SQL_DESC_TABLE_NAME : case SQL_DESC_TYPE_NAME : isStrField = 1 ; break ; default : isStrField = buffer_length != SQL_IS_POINTER && buffer_length != SQL_IS_INTEGER && buffer_length != SQL_IS_UINTEGER && buffer_length != SQL_IS_SMALLINT && buffer_length != SQL_IS_USMALLINT ; } if ( isStrField && buffer_length < 0 && buffer_length != SQL_NTS ) { __post_internal_error ( & descriptor -> error , ERROR_HY090 , NULL , descriptor -> connection -> environment -> requested_version ) ; return function_return_nodrv ( SQL_HANDLE_DESC , descriptor , SQL_ERROR ) ; } <S2SV_StartBug> if ( field_identifier == SQL_DESC_COUNT && ( SQLINTEGER ) value < 0 ) <S2SV_EndBug> { __post_internal_error ( & descriptor -> error , ERROR_07009 , NULL , descriptor -> connection -> environment -> requested_version ) ; return function_return_nodrv ( SQL_HANDLE_DESC , descriptor , SQL_ERROR ) ; } <S2SV_StartBug> if ( field_identifier == SQL_DESC_PARAMETER_TYPE && value != SQL_PARAM_INPUT <S2SV_EndBug> <S2SV_StartBug> && value != SQL_PARAM_OUTPUT && value != SQL_PARAM_INPUT_OUTPUT && <S2SV_EndBug> <S2SV_StartBug> value != SQL_PARAM_INPUT_OUTPUT_STREAM && value != SQL_PARAM_OUTPUT_STREAM ) <S2SV_EndBug> { __post_internal_error ( & descriptor -> error , ERROR_HY105 , NULL , descriptor -> connection -> environment -> requested_version ) ; return function_return_nodrv ( SQL_HANDLE_DESC , descriptor , SQL_ERROR ) ; } if ( descriptor -> connection -> unicode_driver || CHECK_SQLSETDESCFIELDW ( descriptor -> connection ) ) { if ( ! CHECK_SQLSETDESCFIELDW ( descriptor -> connection ) ) { dm_log_write ( __FILE__ , __LINE__ , LOG_INFO , LOG_INFO , ""Error:<S2SV_blank>IM001"" ) ; __post_internal_error ( & descriptor -> error , ERROR_IM001 , NULL , descriptor -> connection -> environment -> requested_version ) ; return function_return_nodrv ( SQL_HANDLE_DESC , descriptor , SQL_ERROR ) ; } ret = SQLSETDESCFIELDW ( descriptor -> connection , descriptor -> driver_desc , rec_number , field_identifier , value , buffer_length ) ; if ( log_info . log_flag ) { sprintf ( descriptor -> msg , ""\\n\\t\\tExit:[%s]"" , __get_return_status ( ret , s1 ) ) ; dm_log_write ( __FILE__ , __LINE__ , LOG_INFO , LOG_INFO , descriptor -> msg ) ; } } else { SQLCHAR * ascii_str = NULL ; if ( ! CHECK_SQLSETDESCFIELD ( descriptor -> connection ) ) { dm_log_write ( __FILE__ , __LINE__ , LOG_INFO , LOG_INFO , ""Error:<S2SV_blank>IM001"" ) ; __post_internal_error ( & descriptor -> error , ERROR_IM001 , NULL , descriptor -> connection -> environment -> requested_version ) ; return function_return_nodrv ( SQL_HANDLE_DESC , descriptor , SQL_ERROR ) ; } switch ( field_identifier ) { case SQL_DESC_NAME : ascii_str = ( SQLCHAR * ) unicode_to_ansi_alloc ( value , buffer_length , descriptor -> connection , NULL ) ; value = ascii_str ; buffer_length = strlen ( ( char * ) ascii_str ) ; break ; default : break ; } ret = SQLSETDESCFIELD ( descriptor -> connection , descriptor -> driver_desc , rec_number , field_identifier , value , buffer_length ) ; if ( log_info . log_flag ) { sprintf ( descriptor -> msg , ""\\n\\t\\tExit:[%s]"" , __get_return_status ( ret , s1 ) ) ; dm_log_write ( __FILE__ , __LINE__ , LOG_INFO , LOG_INFO , descriptor -> msg ) ; } if ( ascii_str ) { free ( ascii_str ) ; } } return function_return ( SQL_HANDLE_DESC , descriptor , ret ) ; }","-> msg , ""\\n\\t\\tEntry:\\\n\\n\\t\\t\\tDescriptor<S2SV_blank>=<S2SV_blank>%p\\\n\\n\\t\\t\\tRec<S2SV_blank>Number<S2SV_blank>=<S2SV_blank>%d\\\n\\n\\t\\t\\tField<S2SV_blank>Ident<S2SV_blank>=<S2SV_blank>%s\\\n\\n\\t\\t\\tValue<S2SV_blank>=<S2SV_blank>%p\\\n\\n\\t\\t\\tBuffer<S2SV_blank>Length<S2SV_blank>=<S2SV_blank>%d"" <S2SV_ModEnd> , descriptor , <S2SV_ModStart> SQL_DESC_COUNT && ( intptr_t <S2SV_ModEnd> ) value < <S2SV_ModStart> == SQL_DESC_PARAMETER_TYPE && ( intptr_t ) <S2SV_ModStart> != SQL_PARAM_INPUT && ( intptr_t ) <S2SV_ModStart> != SQL_PARAM_OUTPUT && ( intptr_t ) <S2SV_ModStart> != SQL_PARAM_INPUT_OUTPUT && ( intptr_t ) <S2SV_ModStart> != SQL_PARAM_INPUT_OUTPUT_STREAM && ( intptr_t )"
141,"static void copy_move_file ( CopyMoveJob * copy_job , GFile * src , GFile * dest_dir , gboolean same_fs , gboolean unique_names , char * * dest_fs_type , SourceInfo * source_info , TransferInfo * transfer_info , GHashTable * debuting_files , GdkPoint * position , gboolean overwrite , gboolean * skipped_file , gboolean readonly_source_fs ) { GFile * dest , * new_dest ; g_autofree gchar * dest_uri = NULL ; GError * error ; GFileCopyFlags flags ; char * primary , * secondary , * details ; int response ; ProgressData pdata ; gboolean would_recurse , is_merge ; CommonJob * job ; gboolean res ; int unique_name_nr ; gboolean handled_invalid_filename ; job = ( CommonJob * ) copy_job ; if ( should_skip_file ( job , src ) ) { * skipped_file = TRUE ; return ; } unique_name_nr = 1 ; handled_invalid_filename = * dest_fs_type != NULL ; if ( unique_names ) { dest = get_unique_target_file ( src , dest_dir , same_fs , * dest_fs_type , unique_name_nr ++ ) ; } else if ( copy_job -> target_name != NULL ) { dest = get_target_file_with_custom_name ( src , dest_dir , * dest_fs_type , same_fs , copy_job -> target_name ) ; } else { dest = get_target_file ( src , dest_dir , * dest_fs_type , same_fs ) ; } if ( test_dir_is_parent ( dest_dir , src ) ) { if ( job -> skip_all_error ) { goto out ; } primary = copy_job -> is_move ? g_strdup ( _ ( ""You<S2SV_blank>cannot<S2SV_blank>move<S2SV_blank>a<S2SV_blank>folder<S2SV_blank>into<S2SV_blank>itself."" ) ) : g_strdup ( _ ( ""You<S2SV_blank>cannot<S2SV_blank>copy<S2SV_blank>a<S2SV_blank>folder<S2SV_blank>into<S2SV_blank>itself."" ) ) ; secondary = g_strdup ( _ ( ""The<S2SV_blank>destination<S2SV_blank>folder<S2SV_blank>is<S2SV_blank>inside<S2SV_blank>the<S2SV_blank>source<S2SV_blank>folder."" ) ) ; response = run_cancel_or_skip_warning ( job , primary , secondary , NULL , source_info -> num_files , source_info -> num_files - transfer_info -> num_files ) ; if ( response == 0 || response == GTK_RESPONSE_DELETE_EVENT ) { abort_job ( job ) ; } else if ( response == 1 ) { job -> skip_all_error = TRUE ; } else if ( response == 2 ) { } else { g_assert_not_reached ( ) ; } goto out ; } if ( test_dir_is_parent ( src , dest ) ) { if ( job -> skip_all_error ) { goto out ; } primary = copy_job -> is_move ? g_strdup ( _ ( ""You<S2SV_blank>cannot<S2SV_blank>move<S2SV_blank>a<S2SV_blank>file<S2SV_blank>over<S2SV_blank>itself."" ) ) : g_strdup ( _ ( ""You<S2SV_blank>cannot<S2SV_blank>copy<S2SV_blank>a<S2SV_blank>file<S2SV_blank>over<S2SV_blank>itself."" ) ) ; secondary = g_strdup ( _ ( ""The<S2SV_blank>source<S2SV_blank>file<S2SV_blank>would<S2SV_blank>be<S2SV_blank>overwritten<S2SV_blank>by<S2SV_blank>the<S2SV_blank>destination."" ) ) ; response = run_cancel_or_skip_warning ( job , primary , secondary , NULL , source_info -> num_files , source_info -> num_files - transfer_info -> num_files ) ; if ( response == 0 || response == GTK_RESPONSE_DELETE_EVENT ) { abort_job ( job ) ; } else if ( response == 1 ) { job -> skip_all_error = TRUE ; } else if ( response == 2 ) { } else { g_assert_not_reached ( ) ; } goto out ; } retry : error = NULL ; flags = G_FILE_COPY_NOFOLLOW_SYMLINKS ; if ( overwrite ) { flags |= G_FILE_COPY_OVERWRITE ; } if ( readonly_source_fs ) { flags |= G_FILE_COPY_TARGET_DEFAULT_PERMS ; } pdata . job = copy_job ; pdata . last_size = 0 ; pdata . source_info = source_info ; pdata . transfer_info = transfer_info ; if ( copy_job -> is_move ) { res = g_file_move ( src , dest , flags , job -> cancellable , copy_file_progress_callback , & pdata , & error ) ; } else { res = g_file_copy ( src , dest , flags , job -> cancellable , copy_file_progress_callback , & pdata , & error ) ; } if ( res ) { GFile * real ; real = map_possibly_volatile_file_to_real ( dest , job -> cancellable , & error ) ; if ( real == NULL ) { res = FALSE ; } else { g_object_unref ( dest ) ; dest = real ; } } if ( res ) { transfer_info -> num_files ++ ; report_copy_progress ( copy_job , source_info , transfer_info ) ; if ( debuting_files ) { dest_uri = g_file_get_uri ( dest ) ; if ( position ) { nautilus_file_changes_queue_schedule_position_set ( dest , * position , job -> screen_num ) ; } else if ( eel_uri_is_desktop ( dest_uri ) ) { nautilus_file_changes_queue_schedule_position_remove ( dest ) ; } g_hash_table_replace ( debuting_files , g_object_ref ( dest ) , GINT_TO_POINTER ( TRUE ) ) ; } if ( copy_job -> is_move ) { nautilus_file_changes_queue_file_moved ( src , dest ) ; } else { nautilus_file_changes_queue_file_added ( dest ) ; } if ( copy_job -> desktop_location != NULL && g_file_equal ( copy_job -> desktop_location , dest_dir ) && is_trusted_desktop_file ( src , job -> cancellable ) ) { <S2SV_StartBug> mark_desktop_file_trusted ( job , <S2SV_EndBug> job -> cancellable , dest , FALSE ) ; } if ( job -> undo_info != NULL ) { nautilus_file_undo_info_ext_add_origin_target_pair ( NAUTILUS_FILE_UNDO_INFO_EXT ( job -> undo_info ) , src , dest ) ; } g_object_unref ( dest ) ; return ; } if ( ! handled_invalid_filename && IS_IO_ERROR ( error , INVALID_FILENAME ) ) { handled_invalid_filename = TRUE ; g_assert ( * dest_fs_type == NULL ) ; * dest_fs_type = query_fs_type ( dest_dir , job -> cancellable ) ; if ( unique_names ) { new_dest = get_unique_target_file ( src , dest_dir , same_fs , * dest_fs_type , unique_name_nr ) ; } else { new_dest = get_target_file ( src , dest_dir , * dest_fs_type , same_fs ) ; } if ( ! g_file_equal ( dest , new_dest ) ) { g_object_unref ( dest ) ; dest = new_dest ; g_error_free ( error ) ; goto retry ; } else { g_object_unref ( new_dest ) ; } } if ( ! overwrite && IS_IO_ERROR ( error , EXISTS ) ) { gboolean is_merge ; FileConflictResponse * response ; g_error_free ( error ) ; if ( unique_names ) { g_object_unref ( dest ) ; dest = get_unique_target_file ( src , dest_dir , same_fs , * dest_fs_type , unique_name_nr ++ ) ; goto retry ; } is_merge = FALSE ; if ( is_dir ( dest ) && is_dir ( src ) ) { is_merge = TRUE ; } if ( ( is_merge && job -> merge_all ) || ( ! is_merge && job -> replace_all ) ) { overwrite = TRUE ; goto retry ; } if ( job -> skip_all_conflict ) { goto out ; } response = handle_copy_move_conflict ( job , src , dest , dest_dir ) ; if ( response -> id == GTK_RESPONSE_CANCEL || response -> id == GTK_RESPONSE_DELETE_EVENT ) { file_conflict_response_free ( response ) ; abort_job ( job ) ; } else if ( response -> id == CONFLICT_RESPONSE_SKIP ) { if ( response -> apply_to_all ) { job -> skip_all_conflict = TRUE ; } file_conflict_response_free ( response ) ; } else if ( response -> id == CONFLICT_RESPONSE_REPLACE ) { if ( response -> apply_to_all ) { if ( is_merge ) { job -> merge_all = TRUE ; } else { job -> replace_all = TRUE ; } } overwrite = TRUE ; file_conflict_response_free ( response ) ; goto retry ; } else if ( response -> id == CONFLICT_RESPONSE_RENAME ) { g_object_unref ( dest ) ; dest = get_target_file_for_display_name ( dest_dir , response -> new_name ) ; file_conflict_response_free ( response ) ; goto retry ; } else { g_assert_not_reached ( ) ; } } else if ( overwrite && IS_IO_ERROR ( error , IS_DIRECTORY ) ) { gboolean existing_file_deleted ; DeleteExistingFileData data ; g_error_free ( error ) ; data . job = job ; data . source = src ; existing_file_deleted = delete_file_recursively ( dest , job -> cancellable , existing_file_removed_callback , & data ) ; if ( existing_file_deleted ) { goto retry ; } } else if ( IS_IO_ERROR ( error , WOULD_RECURSE ) || IS_IO_ERROR ( error , WOULD_MERGE ) ) { is_merge = error -> code == G_IO_ERROR_WOULD_MERGE ; would_recurse = error -> code == G_IO_ERROR_WOULD_RECURSE ; g_error_free ( error ) ; if ( overwrite && would_recurse ) { error = NULL ; if ( ! g_file_delete ( dest , job -> cancellable , & error ) && ! IS_IO_ERROR ( error , NOT_FOUND ) ) { if ( job -> skip_all_error ) { g_error_free ( error ) ; goto out ; } if ( copy_job -> is_move ) { primary = f ( _ ( ""Error<S2SV_blank>while<S2SV_blank>moving<S2SV_blank>%B."" ) , src ) ; } else { primary = f ( _ ( ""Error<S2SV_blank>while<S2SV_blank>copying<S2SV_blank>%B."" ) , src ) ; } secondary = f ( _ ( ""Could<S2SV_blank>not<S2SV_blank>remove<S2SV_blank>the<S2SV_blank>already<S2SV_blank>existing<S2SV_blank>file<S2SV_blank>with<S2SV_blank>the<S2SV_blank>same<S2SV_blank>name<S2SV_blank>in<S2SV_blank>%F."" ) , dest_dir ) ; details = error -> message ; response = run_warning ( job , primary , secondary , details , TRUE , CANCEL , SKIP_ALL , SKIP , NULL ) ; g_error_free ( error ) ; if ( response == 0 || response == GTK_RESPONSE_DELETE_EVENT ) { abort_job ( job ) ; } else if ( response == 1 ) { job -> skip_all_error = TRUE ; } else if ( response == 2 ) { } else { g_assert_not_reached ( ) ; } goto out ; } if ( error ) { g_error_free ( error ) ; error = NULL ; } nautilus_file_changes_queue_file_removed ( dest ) ; } if ( is_merge ) { same_fs = FALSE ; } if ( ! copy_move_directory ( copy_job , src , & dest , same_fs , would_recurse , dest_fs_type , source_info , transfer_info , debuting_files , skipped_file , readonly_source_fs ) ) { g_assert ( * dest_fs_type != NULL ) ; handled_invalid_filename = TRUE ; goto retry ; } g_object_unref ( dest ) ; return ; } else if ( IS_IO_ERROR ( error , CANCELLED ) ) { g_error_free ( error ) ; } else { if ( job -> skip_all_error ) { g_error_free ( error ) ; goto out ; } primary = f ( _ ( ""Error<S2SV_blank>while<S2SV_blank>copying<S2SV_blank>%B."" ) , src ) ; secondary = f ( _ ( ""There<S2SV_blank>was<S2SV_blank>an<S2SV_blank>error<S2SV_blank>copying<S2SV_blank>the<S2SV_blank>file<S2SV_blank>into<S2SV_blank>%F."" ) , dest_dir ) ; details = error -> message ; response = run_cancel_or_skip_warning ( job , primary , secondary , details , source_info -> num_files , source_info -> num_files - transfer_info -> num_files ) ; g_error_free ( error ) ; if ( response == 0 || response == GTK_RESPONSE_DELETE_EVENT ) { abort_job ( job ) ; } else if ( response == 1 ) { job -> skip_all_error = TRUE ; } else if ( response == 2 ) { } else { g_assert_not_reached ( ) ; } } out : * skipped_file = TRUE ; g_object_unref ( dest ) ; }",") ) { mark_desktop_file_executable <S2SV_ModEnd> ( job ,"
142,size_t jsuGetFreeStack ( ) { # ifdef ARM void * frame = __builtin_frame_address ( 0 ) ; size_t stackPos = ( size_t ) ( ( char * ) frame ) ; size_t stackEnd = ( size_t ) ( ( char * ) & LINKER_END_VAR ) ; if ( stackPos < stackEnd ) return 0 ; return stackPos - stackEnd ; # elif defined ( LINUX ) char ptr ; extern void * STACK_BASE ; uint32_t count = ( uint32_t ) ( ( size_t ) STACK_BASE - ( size_t ) & ptr ) ; <S2SV_StartBug> return 1000000 - count ; <S2SV_EndBug> # else return 1000000 ; # endif },ptr ) ; const uint32_t max_stack = 1000000 ; if ( count > max_stack ) return 0 ; return max_stack <S2SV_ModEnd> - count ;
143,"static int ipx_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t size , int flags ) { struct sock * sk = sock -> sk ; struct ipx_sock * ipxs = ipx_sk ( sk ) ; struct sockaddr_ipx * sipx = ( struct sockaddr_ipx * ) msg -> msg_name ; struct ipxhdr * ipx = NULL ; struct sk_buff * skb ; int copied , rc ; lock_sock ( sk ) ; if ( ! ipxs -> port ) { struct sockaddr_ipx uaddr ; uaddr . sipx_port = 0 ; uaddr . sipx_network = 0 ; # ifdef CONFIG_IPX_INTERN rc = - ENETDOWN ; if ( ! ipxs -> intrfc ) goto out ; memcpy ( uaddr . sipx_node , ipxs -> intrfc -> if_node , IPX_NODE_LEN ) ; # endif rc = __ipx_bind ( sock , ( struct sockaddr * ) & uaddr , sizeof ( struct sockaddr_ipx ) ) ; if ( rc ) goto out ; } rc = - ENOTCONN ; if ( sock_flag ( sk , SOCK_ZAPPED ) ) goto out ; skb = skb_recv_datagram ( sk , flags & ~ MSG_DONTWAIT , flags & MSG_DONTWAIT , & rc ) ; if ( ! skb ) goto out ; ipx = ipx_hdr ( skb ) ; copied = ntohs ( ipx -> ipx_pktsize ) - sizeof ( struct ipxhdr ) ; if ( copied > size ) { copied = size ; msg -> msg_flags |= MSG_TRUNC ; } rc = skb_copy_datagram_iovec ( skb , sizeof ( struct ipxhdr ) , msg -> msg_iov , copied ) ; if ( rc ) goto out_free ; if ( skb -> tstamp . tv64 ) sk -> sk_stamp = skb -> tstamp ; <S2SV_StartBug> msg -> msg_namelen = sizeof ( * sipx ) ; <S2SV_EndBug> if ( sipx ) { sipx -> sipx_family = AF_IPX ; sipx -> sipx_port = ipx -> ipx_source . sock ; memcpy ( sipx -> sipx_node , ipx -> ipx_source . node , IPX_NODE_LEN ) ; sipx -> sipx_network = IPX_SKB_CB ( skb ) -> ipx_source_net ; sipx -> sipx_type = ipx -> ipx_type ; sipx -> sipx_zero = 0 ; } rc = copied ; out_free : skb_free_datagram ( sk , skb ) ; out : release_sock ( sk ) ; return rc ; }","-> tstamp ; if ( sipx ) { sipx -> sipx_family = AF_IPX ; sipx -> sipx_port = ipx -> ipx_source . sock ; memcpy ( sipx -> sipx_node , ipx -> ipx_source . node , IPX_NODE_LEN ) ; sipx -> sipx_network = IPX_SKB_CB ( skb ) -> ipx_source_net ; sipx -> sipx_type = ipx -> ipx_type ; sipx -> sipx_zero = 0 ; <S2SV_ModStart> * sipx ) <S2SV_ModEnd> ; } rc"
144,"static Gif_Stream * read_gif ( Gif_Reader * grr , int read_flags , const char * landmark , Gif_ReadErrorHandler handler ) { Gif_Stream * gfs ; Gif_Image * gfi ; Gif_Context gfc ; int unknown_block_type = 0 ; if ( gifgetc ( grr ) != 'G' || gifgetc ( grr ) != 'I' || gifgetc ( grr ) != 'F' ) return 0 ; ( void ) gifgetc ( grr ) ; ( void ) gifgetc ( grr ) ; ( void ) gifgetc ( grr ) ; gfs = Gif_NewStream ( ) ; gfi = Gif_NewImage ( ) ; gfc . stream = gfs ; gfc . prefix = Gif_NewArray ( Gif_Code , GIF_MAX_CODE ) ; gfc . suffix = Gif_NewArray ( uint8_t , GIF_MAX_CODE ) ; gfc . length = Gif_NewArray ( uint16_t , GIF_MAX_CODE ) ; gfc . handler = handler ; gfc . gfi = gfi ; gfc . errors [ 0 ] = gfc . errors [ 1 ] = 0 ; if ( ! gfs || ! gfi || ! gfc . prefix || ! gfc . suffix || ! gfc . length ) goto done ; gfs -> landmark = landmark ; GIF_DEBUG ( ( ""\\nGIF<S2SV_blank>"" ) ) ; if ( ! read_logical_screen_descriptor ( gfs , grr ) ) goto done ; GIF_DEBUG ( ( ""logscrdesc<S2SV_blank>"" ) ) ; while ( ! gifeof ( grr ) ) { uint8_t block = gifgetbyte ( grr ) ; switch ( block ) { case ',' : GIF_DEBUG ( ( ""imageread<S2SV_blank>%d<S2SV_blank>"" , gfs -> nimages ) ) ; gfi -> identifier = last_name ; last_name = 0 ; if ( ! Gif_AddImage ( gfs , gfi ) ) goto done ; else if ( ! read_image ( grr , & gfc , gfi , read_flags ) ) { Gif_RemoveImage ( gfs , gfs -> nimages - 1 ) ; gfi = 0 ; goto done ; } gfc . gfi = gfi = Gif_NewImage ( ) ; if ( ! gfi ) goto done ; break ; case ';' : GIF_DEBUG ( ( ""term\\n"" ) ) ; goto done ; case '!' : block = gifgetbyte ( grr ) ; GIF_DEBUG ( ( ""ext(0x%02X)<S2SV_blank>"" , block ) ) ; switch ( block ) { case 0xF9 : read_graphic_control_extension ( & gfc , gfi , grr ) ; break ; case 0xCE : last_name = suck_data ( last_name , 0 , grr ) ; break ; case 0xFE : if ( ! read_comment_extension ( gfi , grr ) ) goto done ; break ; case 0xFF : read_application_extension ( & gfc , grr ) ; break ; default : read_unknown_extension ( & gfc , grr , block , 0 , 0 ) ; break ; } break ; default : if ( ! unknown_block_type ) { char buf [ 256 ] ; sprintf ( buf , ""unknown<S2SV_blank>block<S2SV_blank>type<S2SV_blank>%d<S2SV_blank>at<S2SV_blank>file<S2SV_blank>offset<S2SV_blank>%u"" , block , grr -> pos - 1 ) ; gif_read_error ( & gfc , 1 , buf ) ; unknown_block_type = 1 ; } break ; } } done : if ( gfs && gfi ) { Gif_Extension * gfex ; gfs -> end_comment = gfi -> comment ; gfi -> comment = 0 ; gfs -> end_extension_list = gfi -> extension_list ; gfi -> extension_list = 0 ; for ( gfex = gfs -> end_extension_list ; gfex ; gfex = gfex -> next ) gfex -> image = NULL ; } Gif_DeleteImage ( gfi ) ; Gif_DeleteArray ( last_name ) ; Gif_DeleteArray ( gfc . prefix ) ; Gif_DeleteArray ( gfc . suffix ) ; Gif_DeleteArray ( gfc . length ) ; gfc . gfi = 0 ; <S2SV_StartBug> if ( gfs ) <S2SV_EndBug> gfs -> errors = gfc . errors [ 1 ] ; if ( gfs && gfc . errors [ 1 ] == 0 && ! ( read_flags & GIF_READ_TRAILING_GARBAGE_OK ) && ! grr -> eofer ( grr ) ) gif_read_error ( & gfc , 0 , ""trailing<S2SV_blank>garbage<S2SV_blank>after<S2SV_blank>GIF<S2SV_blank>ignored"" ) ; gif_read_error ( & gfc , - 1 , 0 ) ; return gfs ; }",= 0 ; last_name = 0 ;
145,"static int sco_sock_bind ( struct socket * sock , struct sockaddr * addr , int addr_len ) { struct sockaddr_sco * sa = ( struct sockaddr_sco * ) addr ; struct sock * sk = sock -> sk ; int err = 0 ; BT_DBG ( ""sk<S2SV_blank>%p<S2SV_blank>%pMR"" , sk , & sa -> sco_bdaddr ) ; <S2SV_StartBug> if ( ! addr || addr -> sa_family != AF_BLUETOOTH ) <S2SV_EndBug> return - EINVAL ; lock_sock ( sk ) ; if ( sk -> sk_state != BT_OPEN ) { err = - EBADFD ; goto done ; } if ( sk -> sk_type != SOCK_SEQPACKET ) { err = - EINVAL ; goto done ; } bacpy ( & sco_pi ( sk ) -> src , & sa -> sco_bdaddr ) ; sk -> sk_state = BT_BOUND ; done : release_sock ( sk ) ; return err ; }",sa_family != AF_BLUETOOTH ) return - EINVAL ; if ( addr_len < sizeof ( struct sockaddr_sco )
146,"int snd_ctl_add ( struct snd_card * card , struct snd_kcontrol * kcontrol ) { struct snd_ctl_elem_id id ; unsigned int idx ; unsigned int count ; int err = - EINVAL ; if ( ! kcontrol ) return err ; if ( snd_BUG_ON ( ! card || ! kcontrol -> info ) ) goto error ; id = kcontrol -> id ; <S2SV_StartBug> down_write ( & card -> controls_rwsem ) ; <S2SV_EndBug> if ( snd_ctl_find_id ( card , & id ) ) { up_write ( & card -> controls_rwsem ) ; dev_err ( card -> dev , ""control<S2SV_blank>%i:%i:%i:%s:%i<S2SV_blank>is<S2SV_blank>already<S2SV_blank>present\\n"" , id . iface , id . device , id . subdevice , id . name , id . index ) ; err = - EBUSY ; goto error ; } if ( snd_ctl_find_hole ( card , kcontrol -> count ) < 0 ) { up_write ( & card -> controls_rwsem ) ; err = - ENOMEM ; goto error ; } list_add_tail ( & kcontrol -> list , & card -> controls ) ; card -> controls_count += kcontrol -> count ; kcontrol -> id . numid = card -> last_numid + 1 ; card -> last_numid += kcontrol -> count ; count = kcontrol -> count ; up_write ( & card -> controls_rwsem ) ; for ( idx = 0 ; idx < count ; idx ++ , id . index ++ , id . numid ++ ) snd_ctl_notify ( card , SNDRV_CTL_EVENT_MASK_ADD , & id ) ; return 0 ; error : snd_ctl_free_one ( kcontrol ) ; return err ; }",-> id ; if ( id . index > UINT_MAX - kcontrol -> count ) goto error ;
147,"EAPI_MAIN int elm_main ( int argc , char * argv [ ] ) { int args = 1 ; unsigned char quitOption = 0 ; <S2SV_StartBug> Browser_Window * window ; <S2SV_EndBug> Ecore_Getopt_Value values [ ] = { ECORE_GETOPT_VALUE_STR ( evas_engine_name ) , <S2SV_StartBug> ECORE_GETOPT_VALUE_BOOL ( quitOption ) , <S2SV_EndBug> ECORE_GETOPT_VALUE_BOOL ( frame_flattening_enabled ) , ECORE_GETOPT_VALUE_BOOL ( quitOption ) , ECORE_GETOPT_VALUE_BOOL ( quitOption ) , ECORE_GETOPT_VALUE_BOOL ( quitOption ) , ECORE_GETOPT_VALUE_NONE } ; if ( ! ewk_init ( ) ) return EXIT_FAILURE ; ewk_view_smart_class_set ( miniBrowserViewSmartClass ( ) ) ; ecore_app_args_set ( argc , ( const char * * ) argv ) ; args = ecore_getopt_parse ( & options , values , argc , argv ) ; if ( args < 0 ) return quit ( EINA_FALSE , ""ERROR:<S2SV_blank>could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>options.\\n"" ) ; if ( quitOption ) return quit ( EINA_TRUE , NULL ) ; if ( evas_engine_name ) elm_config_preferred_engine_set ( evas_engine_name ) ; # if defined ( WTF_USE_ACCELERATED_COMPOSITING ) && defined ( HAVE_ECORE_X ) else { evas_engine_name = ""opengl_x11"" ; elm_config_preferred_engine_set ( evas_engine_name ) ; } # endif Ewk_Context * context = ewk_context_default_get ( ) ; ewk_context_favicon_database_directory_set ( context , NULL ) ; <S2SV_StartBug> if ( args < argc ) { <S2SV_EndBug> char * url = url_from_user_input ( argv [ args ] ) ; window = window_create ( url ) ; free ( url ) ; } else window = window_create ( DEFAULT_URL ) ; if ( ! window ) return quit ( EINA_FALSE , ""ERROR:<S2SV_blank>could<S2SV_blank>not<S2SV_blank>create<S2SV_blank>browser<S2SV_blank>window.\\n"" ) ; windows = eina_list_append ( windows , window ) ; elm_run ( ) ; return quit ( EINA_TRUE , NULL ) ; }","Browser_Window * window ; char * window_size_string = NULL <S2SV_ModStart> evas_engine_name ) , ECORE_GETOPT_VALUE_STR ( window_size_string ) , <S2SV_ModStart> ; if ( window_size_string ) parse_window_size ( window_size_string , & window_width , & window_height ) ; if ("
148,"int perf_output_begin ( struct perf_output_handle * handle , struct perf_event * event , unsigned int size , <S2SV_StartBug> int nmi , int sample ) <S2SV_EndBug> { struct ring_buffer * rb ; unsigned long tail , offset , head ; int have_lost ; struct perf_sample_data sample_data ; struct { struct perf_event_header header ; u64 id ; u64 lost ; } lost_event ; rcu_read_lock ( ) ; if ( event -> parent ) event = event -> parent ; rb = rcu_dereference ( event -> rb ) ; if ( ! rb ) goto out ; handle -> rb = rb ; handle -> event = event ; <S2SV_StartBug> handle -> nmi = nmi ; <S2SV_EndBug> handle -> sample = sample ; if ( ! rb -> nr_pages ) goto out ; have_lost = local_read ( & rb -> lost ) ; if ( have_lost ) { lost_event . header . size = sizeof ( lost_event ) ; perf_event_header__init_id ( & lost_event . header , & sample_data , event ) ; size += lost_event . header . size ; } perf_output_get_handle ( handle ) ; do { tail = ACCESS_ONCE ( rb -> user_page -> data_tail ) ; smp_rmb ( ) ; offset = head = local_read ( & rb -> head ) ; head += size ; if ( unlikely ( ! perf_output_space ( rb , tail , offset , head ) ) ) goto fail ; } while ( local_cmpxchg ( & rb -> head , offset , head ) != offset ) ; if ( head - local_read ( & rb -> wakeup ) > rb -> watermark ) local_add ( rb -> watermark , & rb -> wakeup ) ; handle -> page = offset >> ( PAGE_SHIFT + page_order ( rb ) ) ; handle -> page &= rb -> nr_pages - 1 ; handle -> size = offset & ( ( PAGE_SIZE << page_order ( rb ) ) - 1 ) ; handle -> addr = rb -> data_pages [ handle -> page ] ; handle -> addr += handle -> size ; handle -> size = ( PAGE_SIZE << page_order ( rb ) ) - handle -> size ; if ( have_lost ) { lost_event . header . type = PERF_RECORD_LOST ; lost_event . header . misc = 0 ; lost_event . id = event -> id ; lost_event . lost = local_xchg ( & rb -> lost , 0 ) ; perf_output_put ( handle , lost_event ) ; perf_event__output_id_sample ( event , handle , & sample_data ) ; } return 0 ; fail : local_inc ( & rb -> lost ) ; perf_output_put_handle ( handle ) ; out : rcu_read_unlock ( ) ; return - ENOSPC ; }","size , int <S2SV_ModEnd> sample ) { <S2SV_ModStart> ; handle -> <S2SV_ModEnd> sample = sample"
149,"int do_fpu_inst ( unsigned short inst , struct pt_regs * regs ) { struct task_struct * tsk = current ; struct sh_fpu_soft_struct * fpu = & ( tsk -> thread . xstate -> softfpu ) ; <S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , 0 ) ; <S2SV_EndBug> if ( ! ( task_thread_info ( tsk ) -> status & TS_USEDFPU ) ) { fpu_init ( fpu ) ; task_thread_info ( tsk ) -> status |= TS_USEDFPU ; } return fpu_emulate ( inst , fpu , regs ) ; }","PERF_COUNT_SW_EMULATION_FAULTS , 1 <S2SV_ModEnd> , regs ,"
150,"static l_int32 findNextBorderPixel ( l_int32 w , l_int32 h , l_uint32 * data , l_int32 wpl , l_int32 px , l_int32 py , l_int32 * pqpos , l_int32 * pnpx , l_int32 * pnpy ) { l_int32 qpos , i , pos , npx , npy , val ; l_uint32 * line ; qpos = * pqpos ; for ( i = 1 ; i < 8 ; i ++ ) { pos = ( qpos + i ) % 8 ; npx = px + xpostab [ pos ] ; npy = py + ypostab [ pos ] ; <S2SV_StartBug> line = data + npy * wpl ; <S2SV_EndBug> val = GET_DATA_BIT ( line , npx ) ; if ( val ) { * pnpx = npx ; * pnpy = npy ; * pqpos = qpostab [ pos ] ; return 0 ; } } return 1 ; }",pos ] ; if ( npx < 0 || npx >= w || npy < 0 || npy >= h ) continue ;
151,"static Image * ReadLABELImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { char geometry [ MaxTextExtent ] , * property ; const char * label ; DrawInfo * draw_info ; Image * image ; MagickBooleanType status ; TypeMetric metrics ; size_t height , width ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; ( void ) ResetImagePage ( image , ""0x0+0+0"" ) ; property = InterpretImageProperties ( image_info , image , image_info -> filename ) ; ( void ) SetImageProperty ( image , ""label"" , property ) ; property = DestroyString ( property ) ; label = GetImageProperty ( image , ""label"" ) ; draw_info = CloneDrawInfo ( image_info , ( DrawInfo * ) NULL ) ; draw_info -> text = ConstantString ( label ) ; metrics . width = 0 ; metrics . ascent = 0.0 ; status = GetMultilineTypeMetrics ( image , draw_info , & metrics ) ; if ( ( image -> columns == 0 ) && ( image -> rows == 0 ) ) { <S2SV_StartBug> image -> columns = ( size_t ) ( metrics . width + draw_info -> stroke_width + 0.5 ) ; <S2SV_EndBug> image -> rows = ( size_t ) floor ( metrics . height + draw_info -> stroke_width + 0.5 ) ; } else if ( ( ( image -> columns == 0 ) || ( image -> rows == 0 ) ) || ( fabs ( image_info -> pointsize ) < MagickEpsilon ) ) { double high , low ; for ( ; ; draw_info -> pointsize *= 2.0 ) { ( void ) FormatLocaleString ( geometry , MaxTextExtent , ""%+g%+g"" , - metrics . bounds . x1 , metrics . ascent ) ; if ( draw_info -> gravity == UndefinedGravity ) ( void ) CloneString ( & draw_info -> geometry , geometry ) ; ( void ) GetMultilineTypeMetrics ( image , draw_info , & metrics ) ; width = ( size_t ) floor ( metrics . width + draw_info -> stroke_width + 0.5 ) ; height = ( size_t ) floor ( metrics . height + draw_info -> stroke_width + 0.5 ) ; if ( ( image -> columns != 0 ) && ( image -> rows != 0 ) ) { if ( ( width >= image -> columns ) && ( height >= image -> rows ) ) break ; } else if ( ( ( image -> columns != 0 ) && ( width >= image -> columns ) ) || ( ( image -> rows != 0 ) && ( height >= image -> rows ) ) ) break ; } high = draw_info -> pointsize ; for ( low = 1.0 ; ( high - low ) > 0.5 ; ) { draw_info -> pointsize = ( low + high ) / 2.0 ; ( void ) FormatLocaleString ( geometry , MaxTextExtent , ""%+g%+g"" , - metrics . bounds . x1 , metrics . ascent ) ; if ( draw_info -> gravity == UndefinedGravity ) ( void ) CloneString ( & draw_info -> geometry , geometry ) ; ( void ) GetMultilineTypeMetrics ( image , draw_info , & metrics ) ; width = ( size_t ) floor ( metrics . width + draw_info -> stroke_width + 0.5 ) ; height = ( size_t ) floor ( metrics . height + draw_info -> stroke_width + 0.5 ) ; if ( ( image -> columns != 0 ) && ( image -> rows != 0 ) ) { if ( ( width < image -> columns ) && ( height < image -> rows ) ) low = draw_info -> pointsize + 0.5 ; else high = draw_info -> pointsize - 0.5 ; } else if ( ( ( image -> columns != 0 ) && ( width < image -> columns ) ) || ( ( image -> rows != 0 ) && ( height < image -> rows ) ) ) low = draw_info -> pointsize + 0.5 ; else high = draw_info -> pointsize - 0.5 ; } draw_info -> pointsize = ( low + high ) / 2.0 - 0.5 ; } status = GetMultilineTypeMetrics ( image , draw_info , & metrics ) ; if ( status == MagickFalse ) { draw_info = DestroyDrawInfo ( draw_info ) ; InheritException ( exception , & image -> exception ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } if ( image -> columns == 0 ) <S2SV_StartBug> image -> columns = ( size_t ) ( metrics . width + draw_info -> stroke_width + 0.5 ) ; <S2SV_EndBug> if ( image -> columns == 0 ) <S2SV_StartBug> image -> columns = ( size_t ) ( draw_info -> pointsize + draw_info -> stroke_width + 0.5 ) ; <S2SV_EndBug> if ( image -> rows == 0 ) <S2SV_StartBug> image -> rows = ( size_t ) ( metrics . ascent - metrics . descent + <S2SV_EndBug> draw_info -> stroke_width + 0.5 ) ; if ( image -> rows == 0 ) <S2SV_StartBug> image -> rows = ( size_t ) ( draw_info -> pointsize + draw_info -> stroke_width + 0.5 ) ; <S2SV_EndBug> status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { draw_info = DestroyDrawInfo ( draw_info ) ; InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } if ( SetImageBackgroundColor ( image ) == MagickFalse ) { draw_info = DestroyDrawInfo ( draw_info ) ; InheritException ( exception , & image -> exception ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) FormatLocaleString ( geometry , MaxTextExtent , ""%+g%+g"" , draw_info -> direction == RightToLeftDirection ? image -> columns - metrics . bounds . x2 : 0.0 , draw_info -> gravity == UndefinedGravity ? metrics . ascent : 0.0 ) ; draw_info -> geometry = AcquireString ( geometry ) ; status = AnnotateImage ( image , draw_info ) ; if ( image_info -> pointsize == 0.0 ) { char pointsize [ MaxTextExtent ] ; ( void ) FormatLocaleString ( pointsize , MaxTextExtent , ""%.20g"" , draw_info -> pointsize ) ; ( void ) SetImageProperty ( image , ""label:pointsize"" , pointsize ) ; } draw_info = DestroyDrawInfo ( draw_info ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } return ( GetFirstImageInList ( image ) ) ; }",( size_t ) floor <S2SV_ModStart> ( size_t ) floor <S2SV_ModStart> ( size_t ) floor <S2SV_ModStart> ( size_t ) floor <S2SV_ModStart> ( size_t ) floor
152,"static void ikev2_parent_inI1outR1_continue ( struct pluto_crypto_req_cont * pcrc , struct pluto_crypto_req * r , err_t ugh ) { struct ke_continuation * ke = ( struct ke_continuation * ) pcrc ; struct msg_digest * md = ke -> md ; struct state * const st = md -> st ; stf_status e ; DBG ( DBG_CONTROLMORE , DBG_log ( ""ikev2<S2SV_blank>parent<S2SV_blank>inI1outR1:<S2SV_blank>calculated<S2SV_blank>ke+nonce,<S2SV_blank>sending<S2SV_blank>R1"" ) ) ; if ( st == NULL ) { loglog ( RC_LOG_SERIOUS , ""%s:<S2SV_blank>Request<S2SV_blank>was<S2SV_blank>disconnected<S2SV_blank>from<S2SV_blank>state"" , __FUNCTION__ ) ; if ( ke -> md ) release_md ( ke -> md ) ; return ; } passert ( ugh == NULL ) ; passert ( cur_state == NULL ) ; passert ( st != NULL ) ; passert ( st -> st_suspended_md == ke -> md ) ; set_suspended ( st , NULL ) ; set_cur_state ( st ) ; st -> st_calculating = FALSE ; e = ikev2_parent_inI1outR1_tail ( pcrc , r ) ; if ( ke -> md != NULL ) { complete_v2_state_transition ( & ke -> md , e ) ; if ( ke -> md ) release_md ( ke -> md ) ; } reset_globals ( ) ; <S2SV_StartBug> passert ( GLOBALS_ARE_RESET ( ) ) ; <S2SV_EndBug> }",( ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
153,"static void * etm_setup_aux ( int event_cpu , void * * pages , int nr_pages , bool overwrite ) { int cpu ; cpumask_t * mask ; struct coresight_device * sink ; struct etm_event_data * event_data = NULL ; event_data = alloc_event_data ( event_cpu ) ; if ( ! event_data ) return NULL ; sink = coresight_get_enabled_sink ( true ) ; if ( ! sink ) goto err ; INIT_WORK ( & event_data -> work , free_event_data ) ; mask = & event_data -> mask ; for_each_cpu ( cpu , mask ) { struct coresight_device * csdev ; csdev = per_cpu ( csdev_src , cpu ) ; if ( ! csdev ) goto err ; event_data -> path [ cpu ] = coresight_build_path ( csdev , sink ) ; if ( IS_ERR ( event_data -> path [ cpu ] ) ) goto err ; } if ( ! sink_ops ( sink ) -> alloc_buffer ) goto err ; <S2SV_StartBug> event_data -> snk_config = <S2SV_EndBug> sink_ops ( sink ) -> alloc_buffer ( sink , cpu , pages , nr_pages , overwrite ) ; if ( ! event_data -> snk_config ) goto err ; out : return event_data ; err : etm_free_aux ( event_data ) ; event_data = NULL ; goto out ; }",goto err ; cpu = cpumask_first ( mask ) ;
154,"static int rose_parse_national ( unsigned char * p , struct rose_facilities_struct * facilities , int len ) { unsigned char * pt ; unsigned char l , lg , n = 0 ; int fac_national_digis_received = 0 ; do { switch ( * p & 0xC0 ) { case 0x00 : <S2SV_StartBug> p += 2 ; <S2SV_EndBug> n += 2 ; len -= 2 ; break ; case 0x40 : <S2SV_StartBug> if ( * p == FAC_NATIONAL_RAND ) <S2SV_EndBug> facilities -> rand = ( ( p [ 1 ] << 8 ) & 0xFF00 ) + ( ( p [ 2 ] << 0 ) & 0x00FF ) ; p += 3 ; n += 3 ; len -= 3 ; break ; case 0x80 : <S2SV_StartBug> p += 4 ; <S2SV_EndBug> n += 4 ; len -= 4 ; break ; case 0xC0 : <S2SV_StartBug> l = p [ 1 ] ; <S2SV_EndBug> if ( * p == FAC_NATIONAL_DEST_DIGI ) { if ( ! fac_national_digis_received ) { <S2SV_StartBug> memcpy ( & facilities -> source_digis [ 0 ] , p + 2 , AX25_ADDR_LEN ) ; <S2SV_EndBug> facilities -> source_ndigis = 1 ; } } else if ( * p == FAC_NATIONAL_SRC_DIGI ) { if ( ! fac_national_digis_received ) { <S2SV_StartBug> memcpy ( & facilities -> dest_digis [ 0 ] , p + 2 , AX25_ADDR_LEN ) ; <S2SV_EndBug> facilities -> dest_ndigis = 1 ; } } else if ( * p == FAC_NATIONAL_FAIL_CALL ) { <S2SV_StartBug> memcpy ( & facilities -> fail_call , p + 2 , AX25_ADDR_LEN ) ; <S2SV_EndBug> } else if ( * p == FAC_NATIONAL_FAIL_ADD ) { <S2SV_StartBug> memcpy ( & facilities -> fail_addr , p + 3 , ROSE_ADDR_LEN ) ; <S2SV_EndBug> } <S2SV_StartBug> else if ( * p == FAC_NATIONAL_DIGIS ) { <S2SV_EndBug> fac_national_digis_received = 1 ; facilities -> source_ndigis = 0 ; facilities -> dest_ndigis = 0 ; for ( pt = p + 2 , lg = 0 ; lg < l ; pt += AX25_ADDR_LEN , lg += AX25_ADDR_LEN ) { if ( pt [ 6 ] & AX25_HBIT ) { if ( facilities -> dest_ndigis >= ROSE_MAX_DIGIS ) return - 1 ; memcpy ( & facilities -> dest_digis [ facilities -> dest_ndigis ++ ] , pt , AX25_ADDR_LEN ) ; } else { if ( facilities -> source_ndigis >= ROSE_MAX_DIGIS ) return - 1 ; memcpy ( & facilities -> source_digis [ facilities -> source_ndigis ++ ] , pt , AX25_ADDR_LEN ) ; } } } p += l + 2 ; n += l + 2 ; len -= l + 2 ; break ; } } while ( * p != 0x00 && len > 0 ) ; return n ; }",case 0x00 : if ( len < 2 ) return - 1 ; <S2SV_ModStart> : if ( len < 3 ) return - 1 ; if ( <S2SV_ModStart> case 0x80 : if ( len < 4 ) return - 1 ; <S2SV_ModStart> case 0xC0 : if ( len < 2 ) return - 1 ; l = p [ 1 ] ; if ( len < 2 + l ) return - 1 <S2SV_ModEnd> ; if ( <S2SV_ModStart> fac_national_digis_received ) { if ( l < AX25_ADDR_LEN ) return - 1 ; <S2SV_ModStart> fac_national_digis_received ) { if ( l < AX25_ADDR_LEN ) return - 1 ; <S2SV_ModStart> FAC_NATIONAL_FAIL_CALL ) { if ( l < AX25_ADDR_LEN ) return - 1 ; <S2SV_ModStart> FAC_NATIONAL_FAIL_ADD ) { if ( l < 1 + ROSE_ADDR_LEN ) return - 1 ; <S2SV_ModStart> FAC_NATIONAL_DIGIS ) { if ( l % AX25_ADDR_LEN ) return - 1 ;
155,"static long bcm_char_ioctl ( struct file * filp , UINT cmd , ULONG arg ) { struct bcm_tarang_data * pTarang = filp -> private_data ; void __user * argp = ( void __user * ) arg ; struct bcm_mini_adapter * Adapter = pTarang -> Adapter ; INT Status = STATUS_FAILURE ; int timeout = 0 ; struct bcm_ioctl_buffer IoBuffer ; int bytes ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""Parameters<S2SV_blank>Passed<S2SV_blank>to<S2SV_blank>control<S2SV_blank>IOCTL<S2SV_blank>cmd=0x%X<S2SV_blank>arg=0x%lX"" , cmd , arg ) ; if ( _IOC_TYPE ( cmd ) != BCM_IOCTL ) return - EFAULT ; if ( _IOC_DIR ( cmd ) & _IOC_READ ) Status = ! access_ok ( VERIFY_WRITE , argp , _IOC_SIZE ( cmd ) ) ; else if ( _IOC_DIR ( cmd ) & _IOC_WRITE ) Status = ! access_ok ( VERIFY_READ , argp , _IOC_SIZE ( cmd ) ) ; else if ( _IOC_NONE == ( _IOC_DIR ( cmd ) & _IOC_NONE ) ) Status = STATUS_SUCCESS ; if ( Status ) return - EFAULT ; if ( Adapter -> device_removed ) return - EFAULT ; if ( FALSE == Adapter -> fw_download_done ) { switch ( cmd ) { case IOCTL_MAC_ADDR_REQ : case IOCTL_LINK_REQ : case IOCTL_CM_REQUEST : case IOCTL_SS_INFO_REQ : case IOCTL_SEND_CONTROL_MESSAGE : case IOCTL_IDLE_REQ : case IOCTL_BCM_GPIO_SET_REQUEST : case IOCTL_BCM_GPIO_STATUS_REQUEST : return - EACCES ; default : break ; } } Status = vendorextnIoctl ( Adapter , cmd , arg ) ; if ( Status != CONTINUE_COMMON_PATH ) return Status ; switch ( cmd ) { case IOCTL_BCM_REGISTER_READ_PRIVATE : { struct bcm_rdm_buffer sRdmBuffer = { 0 } ; PCHAR temp_buff ; UINT Bufflen ; u16 temp_value ; if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) return - EFAULT ; if ( IoBuffer . InputLength > sizeof ( sRdmBuffer ) ) return - EINVAL ; if ( copy_from_user ( & sRdmBuffer , IoBuffer . InputBuffer , IoBuffer . InputLength ) ) return - EFAULT ; if ( IoBuffer . OutputLength > USHRT_MAX || IoBuffer . OutputLength == 0 ) { return - EINVAL ; } Bufflen = IoBuffer . OutputLength ; temp_value = 4 - ( Bufflen % 4 ) ; Bufflen += temp_value % 4 ; temp_buff = kmalloc ( Bufflen , GFP_KERNEL ) ; if ( ! temp_buff ) return - ENOMEM ; bytes = rdmalt ( Adapter , ( UINT ) sRdmBuffer . Register , ( PUINT ) temp_buff , Bufflen ) ; if ( bytes > 0 ) { Status = STATUS_SUCCESS ; if ( copy_to_user ( IoBuffer . OutputBuffer , temp_buff , bytes ) ) { kfree ( temp_buff ) ; return - EFAULT ; } } else { Status = bytes ; } kfree ( temp_buff ) ; break ; } case IOCTL_BCM_REGISTER_WRITE_PRIVATE : { struct bcm_wrm_buffer sWrmBuffer = { 0 } ; UINT uiTempVar = 0 ; if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) return - EFAULT ; if ( IoBuffer . InputLength > sizeof ( sWrmBuffer ) ) return - EINVAL ; if ( copy_from_user ( & sWrmBuffer , IoBuffer . InputBuffer , IoBuffer . InputLength ) ) return - EFAULT ; uiTempVar = sWrmBuffer . Register & EEPROM_REJECT_MASK ; if ( ! ( ( Adapter -> pstargetparams -> m_u32Customize ) & VSG_MODE ) && ( ( uiTempVar == EEPROM_REJECT_REG_1 ) || ( uiTempVar == EEPROM_REJECT_REG_2 ) || ( uiTempVar == EEPROM_REJECT_REG_3 ) || ( uiTempVar == EEPROM_REJECT_REG_4 ) ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""EEPROM<S2SV_blank>Access<S2SV_blank>Denied,<S2SV_blank>not<S2SV_blank>in<S2SV_blank>VSG<S2SV_blank>Mode\\n"" ) ; return - EFAULT ; } Status = wrmalt ( Adapter , ( UINT ) sWrmBuffer . Register , ( PUINT ) sWrmBuffer . Data , sizeof ( ULONG ) ) ; if ( Status == STATUS_SUCCESS ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""WRM<S2SV_blank>Done\\n"" ) ; } else { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""WRM<S2SV_blank>Failed\\n"" ) ; Status = - EFAULT ; } break ; } case IOCTL_BCM_REGISTER_READ : case IOCTL_BCM_EEPROM_REGISTER_READ : { struct bcm_rdm_buffer sRdmBuffer = { 0 } ; PCHAR temp_buff = NULL ; UINT uiTempVar = 0 ; if ( ( Adapter -> IdleMode == TRUE ) || ( Adapter -> bShutStatus == TRUE ) || ( Adapter -> bPreparingForLowPowerMode == TRUE ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Device<S2SV_blank>in<S2SV_blank>Idle<S2SV_blank>Mode,<S2SV_blank>Blocking<S2SV_blank>Rdms\\n"" ) ; return - EACCES ; } if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) return - EFAULT ; if ( IoBuffer . InputLength > sizeof ( sRdmBuffer ) ) return - EINVAL ; if ( copy_from_user ( & sRdmBuffer , IoBuffer . InputBuffer , IoBuffer . InputLength ) ) return - EFAULT ; if ( IoBuffer . OutputLength > USHRT_MAX || IoBuffer . OutputLength == 0 ) { return - EINVAL ; } temp_buff = kmalloc ( IoBuffer . OutputLength , GFP_KERNEL ) ; if ( ! temp_buff ) return STATUS_FAILURE ; if ( ( ( ( ULONG ) sRdmBuffer . Register & 0x0F000000 ) != 0x0F000000 ) || ( ( ULONG ) sRdmBuffer . Register & 0x3 ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""RDM<S2SV_blank>Done<S2SV_blank>On<S2SV_blank>invalid<S2SV_blank>Address<S2SV_blank>:<S2SV_blank>%x<S2SV_blank>Access<S2SV_blank>Denied.\\n"" , ( int ) sRdmBuffer . Register ) ; kfree ( temp_buff ) ; return - EINVAL ; } uiTempVar = sRdmBuffer . Register & EEPROM_REJECT_MASK ; bytes = rdmaltWithLock ( Adapter , ( UINT ) sRdmBuffer . Register , ( PUINT ) temp_buff , IoBuffer . OutputLength ) ; if ( bytes > 0 ) { Status = STATUS_SUCCESS ; if ( copy_to_user ( IoBuffer . OutputBuffer , temp_buff , bytes ) ) { kfree ( temp_buff ) ; return - EFAULT ; } } else { Status = bytes ; } kfree ( temp_buff ) ; break ; } case IOCTL_BCM_REGISTER_WRITE : case IOCTL_BCM_EEPROM_REGISTER_WRITE : { struct bcm_wrm_buffer sWrmBuffer = { 0 } ; UINT uiTempVar = 0 ; if ( ( Adapter -> IdleMode == TRUE ) || ( Adapter -> bShutStatus == TRUE ) || ( Adapter -> bPreparingForLowPowerMode == TRUE ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Device<S2SV_blank>in<S2SV_blank>Idle<S2SV_blank>Mode,<S2SV_blank>Blocking<S2SV_blank>Wrms\\n"" ) ; return - EACCES ; } if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) return - EFAULT ; if ( IoBuffer . InputLength > sizeof ( sWrmBuffer ) ) return - EINVAL ; if ( copy_from_user ( & sWrmBuffer , IoBuffer . InputBuffer , IoBuffer . InputLength ) ) return - EFAULT ; if ( ( ( ( ULONG ) sWrmBuffer . Register & 0x0F000000 ) != 0x0F000000 ) || ( ( ULONG ) sWrmBuffer . Register & 0x3 ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""WRM<S2SV_blank>Done<S2SV_blank>On<S2SV_blank>invalid<S2SV_blank>Address<S2SV_blank>:<S2SV_blank>%x<S2SV_blank>Access<S2SV_blank>Denied.\\n"" , ( int ) sWrmBuffer . Register ) ; return - EINVAL ; } uiTempVar = sWrmBuffer . Register & EEPROM_REJECT_MASK ; if ( ! ( ( Adapter -> pstargetparams -> m_u32Customize ) & VSG_MODE ) && ( ( uiTempVar == EEPROM_REJECT_REG_1 ) || ( uiTempVar == EEPROM_REJECT_REG_2 ) || ( uiTempVar == EEPROM_REJECT_REG_3 ) || ( uiTempVar == EEPROM_REJECT_REG_4 ) ) && ( cmd == IOCTL_BCM_REGISTER_WRITE ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""EEPROM<S2SV_blank>Access<S2SV_blank>Denied,<S2SV_blank>not<S2SV_blank>in<S2SV_blank>VSG<S2SV_blank>Mode\\n"" ) ; return - EFAULT ; } Status = wrmaltWithLock ( Adapter , ( UINT ) sWrmBuffer . Register , ( PUINT ) sWrmBuffer . Data , sWrmBuffer . Length ) ; if ( Status == STATUS_SUCCESS ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , OSAL_DBG , DBG_LVL_ALL , ""WRM<S2SV_blank>Done\\n"" ) ; } else { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""WRM<S2SV_blank>Failed\\n"" ) ; Status = - EFAULT ; } break ; } case IOCTL_BCM_GPIO_SET_REQUEST : { UCHAR ucResetValue [ 4 ] ; UINT value = 0 ; UINT uiBit = 0 ; UINT uiOperation = 0 ; struct bcm_gpio_info gpio_info = { 0 } ; if ( ( Adapter -> IdleMode == TRUE ) || ( Adapter -> bShutStatus == TRUE ) || ( Adapter -> bPreparingForLowPowerMode == TRUE ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""GPIO<S2SV_blank>Can\'t<S2SV_blank>be<S2SV_blank>set/clear<S2SV_blank>in<S2SV_blank>Low<S2SV_blank>power<S2SV_blank>Mode"" ) ; return - EACCES ; } if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) return - EFAULT ; if ( IoBuffer . InputLength > sizeof ( gpio_info ) ) return - EINVAL ; if ( copy_from_user ( & gpio_info , IoBuffer . InputBuffer , IoBuffer . InputLength ) ) return - EFAULT ; uiBit = gpio_info . uiGpioNumber ; uiOperation = gpio_info . uiGpioValue ; value = ( 1 << uiBit ) ; if ( IsReqGpioIsLedInNVM ( Adapter , value ) == FALSE ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""Sorry,<S2SV_blank>Requested<S2SV_blank>GPIO<0x%X><S2SV_blank>is<S2SV_blank>not<S2SV_blank>correspond<S2SV_blank>to<S2SV_blank>LED<S2SV_blank>!!!"" , value ) ; Status = - EINVAL ; break ; } if ( uiOperation ) { Status = wrmaltWithLock ( Adapter , BCM_GPIO_OUTPUT_SET_REG , ( PUINT ) ( & value ) , sizeof ( UINT ) ) ; if ( Status == STATUS_SUCCESS ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""Set<S2SV_blank>the<S2SV_blank>GPIO<S2SV_blank>bit\\n"" ) ; } else { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""Failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>the<S2SV_blank>%dth<S2SV_blank>GPIO\\n"" , uiBit ) ; break ; } } else { Status = wrmaltWithLock ( Adapter , BCM_GPIO_OUTPUT_CLR_REG , ( PUINT ) ( & value ) , sizeof ( UINT ) ) ; if ( Status == STATUS_SUCCESS ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""Set<S2SV_blank>the<S2SV_blank>GPIO<S2SV_blank>bit\\n"" ) ; } else { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""Failed<S2SV_blank>to<S2SV_blank>clear<S2SV_blank>the<S2SV_blank>%dth<S2SV_blank>GPIO\\n"" , uiBit ) ; break ; } } bytes = rdmaltWithLock ( Adapter , ( UINT ) GPIO_MODE_REGISTER , ( PUINT ) ucResetValue , sizeof ( UINT ) ) ; if ( bytes < 0 ) { Status = bytes ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""GPIO_MODE_REGISTER<S2SV_blank>read<S2SV_blank>failed"" ) ; break ; } else { Status = STATUS_SUCCESS ; } * ( UINT * ) ucResetValue |= ( 1 << uiBit ) ; Status = wrmaltWithLock ( Adapter , GPIO_MODE_REGISTER , ( PUINT ) ucResetValue , sizeof ( UINT ) ) ; if ( Status == STATUS_SUCCESS ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""Set<S2SV_blank>the<S2SV_blank>GPIO<S2SV_blank>to<S2SV_blank>output<S2SV_blank>Mode\\n"" ) ; } else { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""Failed<S2SV_blank>to<S2SV_blank>put<S2SV_blank>GPIO<S2SV_blank>in<S2SV_blank>Output<S2SV_blank>Mode\\n"" ) ; break ; } } break ; case BCM_LED_THREAD_STATE_CHANGE_REQ : { struct bcm_user_thread_req threadReq = { 0 } ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""User<S2SV_blank>made<S2SV_blank>LED<S2SV_blank>thread<S2SV_blank>InActive"" ) ; if ( ( Adapter -> IdleMode == TRUE ) || ( Adapter -> bShutStatus == TRUE ) || ( Adapter -> bPreparingForLowPowerMode == TRUE ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""GPIO<S2SV_blank>Can\'t<S2SV_blank>be<S2SV_blank>set/clear<S2SV_blank>in<S2SV_blank>Low<S2SV_blank>power<S2SV_blank>Mode"" ) ; Status = - EACCES ; break ; } if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) return - EFAULT ; if ( IoBuffer . InputLength > sizeof ( threadReq ) ) return - EINVAL ; if ( copy_from_user ( & threadReq , IoBuffer . InputBuffer , IoBuffer . InputLength ) ) return - EFAULT ; if ( Adapter -> LEDInfo . led_thread_running ) { if ( threadReq . ThreadState == LED_THREAD_ACTIVATION_REQ ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""Activating<S2SV_blank>thread<S2SV_blank>req"" ) ; Adapter -> DriverState = LED_THREAD_ACTIVE ; } else { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""DeActivating<S2SV_blank>Thread<S2SV_blank>req....."" ) ; Adapter -> DriverState = LED_THREAD_INACTIVE ; } wake_up ( & Adapter -> LEDInfo . notify_led_event ) ; } } break ; case IOCTL_BCM_GPIO_STATUS_REQUEST : { ULONG uiBit = 0 ; UCHAR ucRead [ 4 ] ; struct bcm_gpio_info gpio_info = { 0 } ; if ( ( Adapter -> IdleMode == TRUE ) || ( Adapter -> bShutStatus == TRUE ) || ( Adapter -> bPreparingForLowPowerMode == TRUE ) ) return - EACCES ; if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) return - EFAULT ; if ( IoBuffer . InputLength > sizeof ( gpio_info ) ) return - EINVAL ; if ( copy_from_user ( & gpio_info , IoBuffer . InputBuffer , IoBuffer . InputLength ) ) return - EFAULT ; uiBit = gpio_info . uiGpioNumber ; bytes = rdmaltWithLock ( Adapter , ( UINT ) GPIO_PIN_STATE_REGISTER , ( PUINT ) ucRead , sizeof ( UINT ) ) ; if ( bytes < 0 ) { Status = bytes ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""RDM<S2SV_blank>Failed\\n"" ) ; return Status ; } else { Status = STATUS_SUCCESS ; } } break ; case IOCTL_BCM_GPIO_MULTI_REQUEST : { UCHAR ucResetValue [ 4 ] ; struct bcm_gpio_multi_info gpio_multi_info [ MAX_IDX ] ; struct bcm_gpio_multi_info * pgpio_multi_info = ( struct bcm_gpio_multi_info * ) gpio_multi_info ; memset ( pgpio_multi_info , 0 , MAX_IDX * sizeof ( struct bcm_gpio_multi_info ) ) ; if ( ( Adapter -> IdleMode == TRUE ) || ( Adapter -> bShutStatus == TRUE ) || ( Adapter -> bPreparingForLowPowerMode == TRUE ) ) return - EINVAL ; if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) return - EFAULT ; if ( IoBuffer . InputLength > sizeof ( gpio_multi_info ) ) return - EINVAL ; if ( copy_from_user ( & gpio_multi_info , IoBuffer . InputBuffer , IoBuffer . InputLength ) ) return - EFAULT ; if ( IsReqGpioIsLedInNVM ( Adapter , pgpio_multi_info [ WIMAX_IDX ] . uiGPIOMask ) == FALSE ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""Sorry,<S2SV_blank>Requested<S2SV_blank>GPIO<0x%X><S2SV_blank>is<S2SV_blank>not<S2SV_blank>correspond<S2SV_blank>to<S2SV_blank>NVM<S2SV_blank>LED<S2SV_blank>bit<S2SV_blank>map<0x%X>!!!"" , pgpio_multi_info [ WIMAX_IDX ] . uiGPIOMask , Adapter -> gpioBitMap ) ; Status = - EINVAL ; break ; } if ( ( pgpio_multi_info [ WIMAX_IDX ] . uiGPIOMask ) & ( pgpio_multi_info [ WIMAX_IDX ] . uiGPIOCommand ) ) { * ( UINT * ) ucResetValue = pgpio_multi_info [ WIMAX_IDX ] . uiGPIOMask & pgpio_multi_info [ WIMAX_IDX ] . uiGPIOCommand & pgpio_multi_info [ WIMAX_IDX ] . uiGPIOValue ; if ( * ( UINT * ) ucResetValue ) Status = wrmaltWithLock ( Adapter , BCM_GPIO_OUTPUT_SET_REG , ( PUINT ) ucResetValue , sizeof ( ULONG ) ) ; if ( Status != STATUS_SUCCESS ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""WRM<S2SV_blank>to<S2SV_blank>BCM_GPIO_OUTPUT_SET_REG<S2SV_blank>Failed."" ) ; return Status ; } * ( UINT * ) ucResetValue = ( pgpio_multi_info [ WIMAX_IDX ] . uiGPIOMask & pgpio_multi_info [ WIMAX_IDX ] . uiGPIOCommand & ( ~ ( pgpio_multi_info [ WIMAX_IDX ] . uiGPIOValue ) ) ) ; if ( * ( UINT * ) ucResetValue ) Status = wrmaltWithLock ( Adapter , BCM_GPIO_OUTPUT_CLR_REG , ( PUINT ) ucResetValue , sizeof ( ULONG ) ) ; if ( Status != STATUS_SUCCESS ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""WRM<S2SV_blank>to<S2SV_blank>BCM_GPIO_OUTPUT_CLR_REG<S2SV_blank>Failed."" ) ; return Status ; } } if ( pgpio_multi_info [ WIMAX_IDX ] . uiGPIOMask ) { bytes = rdmaltWithLock ( Adapter , ( UINT ) GPIO_PIN_STATE_REGISTER , ( PUINT ) ucResetValue , sizeof ( UINT ) ) ; if ( bytes < 0 ) { Status = bytes ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""RDM<S2SV_blank>to<S2SV_blank>GPIO_PIN_STATE_REGISTER<S2SV_blank>Failed."" ) ; return Status ; } else { Status = STATUS_SUCCESS ; } pgpio_multi_info [ WIMAX_IDX ] . uiGPIOValue = ( * ( UINT * ) ucResetValue & pgpio_multi_info [ WIMAX_IDX ] . uiGPIOMask ) ; } Status = copy_to_user ( IoBuffer . OutputBuffer , & gpio_multi_info , IoBuffer . OutputLength ) ; if ( Status ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Failed<S2SV_blank>while<S2SV_blank>copying<S2SV_blank>Content<S2SV_blank>to<S2SV_blank>IOBufer<S2SV_blank>for<S2SV_blank>user<S2SV_blank>space<S2SV_blank>err:%d"" , Status ) ; return - EFAULT ; } } break ; case IOCTL_BCM_GPIO_MODE_REQUEST : { UCHAR ucResetValue [ 4 ] ; struct bcm_gpio_multi_mode gpio_multi_mode [ MAX_IDX ] ; struct bcm_gpio_multi_mode * pgpio_multi_mode = ( struct bcm_gpio_multi_mode * ) gpio_multi_mode ; if ( ( Adapter -> IdleMode == TRUE ) || ( Adapter -> bShutStatus == TRUE ) || ( Adapter -> bPreparingForLowPowerMode == TRUE ) ) return - EINVAL ; if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) return - EFAULT ; if ( IoBuffer . InputLength > sizeof ( gpio_multi_mode ) ) return - EINVAL ; if ( copy_from_user ( & gpio_multi_mode , IoBuffer . InputBuffer , IoBuffer . InputLength ) ) return - EFAULT ; bytes = rdmaltWithLock ( Adapter , ( UINT ) GPIO_MODE_REGISTER , ( PUINT ) ucResetValue , sizeof ( UINT ) ) ; if ( bytes < 0 ) { Status = bytes ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Read<S2SV_blank>of<S2SV_blank>GPIO_MODE_REGISTER<S2SV_blank>failed"" ) ; return Status ; } else { Status = STATUS_SUCCESS ; } if ( IsReqGpioIsLedInNVM ( Adapter , pgpio_multi_mode [ WIMAX_IDX ] . uiGPIOMask ) == FALSE ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""Sorry,<S2SV_blank>Requested<S2SV_blank>GPIO<0x%X><S2SV_blank>is<S2SV_blank>not<S2SV_blank>correspond<S2SV_blank>to<S2SV_blank>NVM<S2SV_blank>LED<S2SV_blank>bit<S2SV_blank>map<0x%X>!!!"" , pgpio_multi_mode [ WIMAX_IDX ] . uiGPIOMask , Adapter -> gpioBitMap ) ; Status = - EINVAL ; break ; } if ( pgpio_multi_mode [ WIMAX_IDX ] . uiGPIOMask ) { * ( UINT * ) ucResetValue |= ( pgpio_multi_mode [ WIMAX_IDX ] . uiGPIOMode & pgpio_multi_mode [ WIMAX_IDX ] . uiGPIOMask ) ; * ( UINT * ) ucResetValue &= ~ ( ( ~ pgpio_multi_mode [ WIMAX_IDX ] . uiGPIOMode ) & pgpio_multi_mode [ WIMAX_IDX ] . uiGPIOMask ) ; pgpio_multi_mode [ WIMAX_IDX ] . uiGPIOMode = * ( UINT * ) ucResetValue ; Status = wrmaltWithLock ( Adapter , GPIO_MODE_REGISTER , ( PUINT ) ucResetValue , sizeof ( ULONG ) ) ; if ( Status == STATUS_SUCCESS ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""WRM<S2SV_blank>to<S2SV_blank>GPIO_MODE_REGISTER<S2SV_blank>Done"" ) ; } else { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""WRM<S2SV_blank>to<S2SV_blank>GPIO_MODE_REGISTER<S2SV_blank>Failed"" ) ; Status = - EFAULT ; break ; } } else { pgpio_multi_mode [ WIMAX_IDX ] . uiGPIOMode = * ( UINT * ) ucResetValue ; } Status = copy_to_user ( IoBuffer . OutputBuffer , & gpio_multi_mode , IoBuffer . OutputLength ) ; if ( Status ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Failed<S2SV_blank>while<S2SV_blank>copying<S2SV_blank>Content<S2SV_blank>to<S2SV_blank>IOBufer<S2SV_blank>for<S2SV_blank>user<S2SV_blank>space<S2SV_blank>err:%d"" , Status ) ; return - EFAULT ; } } break ; case IOCTL_MAC_ADDR_REQ : case IOCTL_LINK_REQ : case IOCTL_CM_REQUEST : case IOCTL_SS_INFO_REQ : case IOCTL_SEND_CONTROL_MESSAGE : case IOCTL_IDLE_REQ : { PVOID pvBuffer = NULL ; if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) return - EFAULT ; if ( IoBuffer . InputLength < sizeof ( struct bcm_link_request ) ) return - EINVAL ; if ( IoBuffer . InputLength > MAX_CNTL_PKT_SIZE ) return - EINVAL ; pvBuffer = memdup_user ( IoBuffer . InputBuffer , IoBuffer . InputLength ) ; if ( IS_ERR ( pvBuffer ) ) return PTR_ERR ( pvBuffer ) ; down ( & Adapter -> LowPowerModeSync ) ; Status = wait_event_interruptible_timeout ( Adapter -> lowpower_mode_wait_queue , ! Adapter -> bPreparingForLowPowerMode , ( 1 * HZ ) ) ; if ( Status == - ERESTARTSYS ) goto cntrlEnd ; if ( Adapter -> bPreparingForLowPowerMode ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""Preparing<S2SV_blank>Idle<S2SV_blank>Mode<S2SV_blank>is<S2SV_blank>still<S2SV_blank>True<S2SV_blank>-<S2SV_blank>Hence<S2SV_blank>Rejecting<S2SV_blank>control<S2SV_blank>message\\n"" ) ; Status = STATUS_FAILURE ; goto cntrlEnd ; } Status = CopyBufferToControlPacket ( Adapter , ( PVOID ) pvBuffer ) ; cntrlEnd : up ( & Adapter -> LowPowerModeSync ) ; kfree ( pvBuffer ) ; break ; } case IOCTL_BCM_BUFFER_DOWNLOAD_START : { if ( down_trylock ( & Adapter -> NVMRdmWrmLock ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""IOCTL_BCM_CHIP_RESET<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>as<S2SV_blank>EEPROM<S2SV_blank>Read/Write<S2SV_blank>is<S2SV_blank>in<S2SV_blank>progress\\n"" ) ; return - EACCES ; } BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Starting<S2SV_blank>the<S2SV_blank>firmware<S2SV_blank>download<S2SV_blank>PID<S2SV_blank>=0x%x!!!!\\n"" , current -> pid ) ; if ( down_trylock ( & Adapter -> fw_download_sema ) ) return - EBUSY ; Adapter -> bBinDownloaded = FALSE ; Adapter -> fw_download_process_pid = current -> pid ; Adapter -> bCfgDownloaded = FALSE ; Adapter -> fw_download_done = FALSE ; netif_carrier_off ( Adapter -> dev ) ; netif_stop_queue ( Adapter -> dev ) ; Status = reset_card_proc ( Adapter ) ; if ( Status ) { pr_err ( PFX ""%s:<S2SV_blank>reset_card_proc<S2SV_blank>Failed!\\n"" , Adapter -> dev -> name ) ; up ( & Adapter -> fw_download_sema ) ; up ( & Adapter -> NVMRdmWrmLock ) ; return Status ; } mdelay ( 10 ) ; up ( & Adapter -> NVMRdmWrmLock ) ; return Status ; } case IOCTL_BCM_BUFFER_DOWNLOAD : { struct bcm_firmware_info * psFwInfo = NULL ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Starting<S2SV_blank>the<S2SV_blank>firmware<S2SV_blank>download<S2SV_blank>PID<S2SV_blank>=0x%x!!!!\\n"" , current -> pid ) ; if ( ! down_trylock ( & Adapter -> fw_download_sema ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Invalid<S2SV_blank>way<S2SV_blank>to<S2SV_blank>download<S2SV_blank>buffer.<S2SV_blank>Use<S2SV_blank>Start<S2SV_blank>and<S2SV_blank>then<S2SV_blank>call<S2SV_blank>this!!!\\n"" ) ; up ( & Adapter -> fw_download_sema ) ; Status = - EINVAL ; return Status ; } if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) { up ( & Adapter -> fw_download_sema ) ; return - EFAULT ; } BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Length<S2SV_blank>for<S2SV_blank>FW<S2SV_blank>DLD<S2SV_blank>is<S2SV_blank>:<S2SV_blank>%lx\\n"" , IoBuffer . InputLength ) ; if ( IoBuffer . InputLength > sizeof ( struct bcm_firmware_info ) ) { up ( & Adapter -> fw_download_sema ) ; return - EINVAL ; } psFwInfo = kmalloc ( sizeof ( * psFwInfo ) , GFP_KERNEL ) ; if ( ! psFwInfo ) { up ( & Adapter -> fw_download_sema ) ; return - ENOMEM ; } if ( copy_from_user ( psFwInfo , IoBuffer . InputBuffer , IoBuffer . InputLength ) ) { up ( & Adapter -> fw_download_sema ) ; kfree ( psFwInfo ) ; return - EFAULT ; } if ( ! psFwInfo -> pvMappedFirmwareAddress || ( psFwInfo -> u32FirmwareLength == 0 ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Something<S2SV_blank>else<S2SV_blank>is<S2SV_blank>wrong<S2SV_blank>%lu\\n"" , psFwInfo -> u32FirmwareLength ) ; up ( & Adapter -> fw_download_sema ) ; kfree ( psFwInfo ) ; Status = - EINVAL ; return Status ; } Status = bcm_ioctl_fw_download ( Adapter , psFwInfo ) ; if ( Status != STATUS_SUCCESS ) { if ( psFwInfo -> u32StartingAddress == CONFIG_BEGIN_ADDR ) BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""IOCTL:<S2SV_blank>Configuration<S2SV_blank>File<S2SV_blank>Upload<S2SV_blank>Failed\\n"" ) ; else BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""IOCTL:<S2SV_blank>Firmware<S2SV_blank>File<S2SV_blank>Upload<S2SV_blank>Failed\\n"" ) ; if ( Adapter -> LEDInfo . led_thread_running & BCM_LED_THREAD_RUNNING_ACTIVELY ) { Adapter -> DriverState = DRIVER_INIT ; Adapter -> LEDInfo . bLedInitDone = FALSE ; wake_up ( & Adapter -> LEDInfo . notify_led_event ) ; } } if ( Status != STATUS_SUCCESS ) up ( & Adapter -> fw_download_sema ) ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , OSAL_DBG , DBG_LVL_ALL , ""IOCTL:<S2SV_blank>Firmware<S2SV_blank>File<S2SV_blank>Uploaded\\n"" ) ; kfree ( psFwInfo ) ; return Status ; } case IOCTL_BCM_BUFFER_DOWNLOAD_STOP : { if ( ! down_trylock ( & Adapter -> fw_download_sema ) ) { up ( & Adapter -> fw_download_sema ) ; return - EINVAL ; } if ( down_trylock ( & Adapter -> NVMRdmWrmLock ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""FW<S2SV_blank>download<S2SV_blank>blocked<S2SV_blank>as<S2SV_blank>EEPROM<S2SV_blank>Read/Write<S2SV_blank>is<S2SV_blank>in<S2SV_blank>progress\\n"" ) ; up ( & Adapter -> fw_download_sema ) ; return - EACCES ; } Adapter -> bBinDownloaded = TRUE ; Adapter -> bCfgDownloaded = TRUE ; atomic_set ( & Adapter -> CurrNumFreeTxDesc , 0 ) ; Adapter -> CurrNumRecvDescs = 0 ; Adapter -> downloadDDR = 0 ; Status = run_card_proc ( Adapter ) ; if ( Status ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Firm<S2SV_blank>Download<S2SV_blank>Failed\\n"" ) ; up ( & Adapter -> fw_download_sema ) ; up ( & Adapter -> NVMRdmWrmLock ) ; return Status ; } else { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""Firm<S2SV_blank>Download<S2SV_blank>Over...\\n"" ) ; } mdelay ( 10 ) ; if ( StartInterruptUrb ( ( struct bcm_interface_adapter * ) Adapter -> pvInterfaceAdapter ) ) BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Unable<S2SV_blank>to<S2SV_blank>send<S2SV_blank>interrupt...\\n"" ) ; timeout = 5 * HZ ; Adapter -> waiting_to_fw_download_done = FALSE ; wait_event_timeout ( Adapter -> ioctl_fw_dnld_wait_queue , Adapter -> waiting_to_fw_download_done , timeout ) ; Adapter -> fw_download_process_pid = INVALID_PID ; Adapter -> fw_download_done = TRUE ; atomic_set ( & Adapter -> CurrNumFreeTxDesc , 0 ) ; Adapter -> CurrNumRecvDescs = 0 ; Adapter -> PrevNumRecvDescs = 0 ; atomic_set ( & Adapter -> cntrlpktCnt , 0 ) ; Adapter -> LinkUpStatus = 0 ; Adapter -> LinkStatus = 0 ; if ( Adapter -> LEDInfo . led_thread_running & BCM_LED_THREAD_RUNNING_ACTIVELY ) { Adapter -> DriverState = FW_DOWNLOAD_DONE ; wake_up ( & Adapter -> LEDInfo . notify_led_event ) ; } if ( ! timeout ) Status = - ENODEV ; up ( & Adapter -> fw_download_sema ) ; up ( & Adapter -> NVMRdmWrmLock ) ; return Status ; } case IOCTL_BE_BUCKET_SIZE : Status = 0 ; if ( get_user ( Adapter -> BEBucketSize , ( unsigned long __user * ) arg ) ) Status = - EFAULT ; break ; case IOCTL_RTPS_BUCKET_SIZE : Status = 0 ; if ( get_user ( Adapter -> rtPSBucketSize , ( unsigned long __user * ) arg ) ) Status = - EFAULT ; break ; case IOCTL_CHIP_RESET : { INT NVMAccess = down_trylock ( & Adapter -> NVMRdmWrmLock ) ; if ( NVMAccess ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""<S2SV_blank>IOCTL_BCM_CHIP_RESET<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>as<S2SV_blank>EEPROM<S2SV_blank>Read/Write<S2SV_blank>is<S2SV_blank>in<S2SV_blank>progress\\n"" ) ; return - EACCES ; } down ( & Adapter -> RxAppControlQueuelock ) ; Status = reset_card_proc ( Adapter ) ; flushAllAppQ ( ) ; up ( & Adapter -> RxAppControlQueuelock ) ; up ( & Adapter -> NVMRdmWrmLock ) ; ResetCounters ( Adapter ) ; break ; } case IOCTL_QOS_THRESHOLD : { USHORT uiLoopIndex ; Status = 0 ; for ( uiLoopIndex = 0 ; uiLoopIndex < NO_OF_QUEUES ; uiLoopIndex ++ ) { if ( get_user ( Adapter -> PackInfo [ uiLoopIndex ] . uiThreshold , ( unsigned long __user * ) arg ) ) { Status = - EFAULT ; break ; } } break ; } case IOCTL_DUMP_PACKET_INFO : DumpPackInfo ( Adapter ) ; DumpPhsRules ( & Adapter -> stBCMPhsContext ) ; Status = STATUS_SUCCESS ; break ; case IOCTL_GET_PACK_INFO : if ( copy_to_user ( argp , & Adapter -> PackInfo , sizeof ( struct bcm_packet_info ) * NO_OF_QUEUES ) ) return - EFAULT ; Status = STATUS_SUCCESS ; break ; case IOCTL_BCM_SWITCH_TRANSFER_MODE : { UINT uiData = 0 ; if ( copy_from_user ( & uiData , argp , sizeof ( UINT ) ) ) return - EFAULT ; if ( uiData ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""IOCTL_BCM_SWITCH_TRANSFER_MODE:<S2SV_blank>ETH_PACKET_TUNNELING_MODE\\n"" ) ; Adapter -> TransferMode = ETH_PACKET_TUNNELING_MODE ; } else { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""IOCTL_BCM_SWITCH_TRANSFER_MODE:<S2SV_blank>IP_PACKET_ONLY_MODE\\n"" ) ; Adapter -> TransferMode = IP_PACKET_ONLY_MODE ; } Status = STATUS_SUCCESS ; break ; } case IOCTL_BCM_GET_DRIVER_VERSION : { ulong len ; if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) return - EFAULT ; len = min_t ( ulong , IoBuffer . OutputLength , strlen ( DRV_VERSION ) + 1 ) ; if ( copy_to_user ( IoBuffer . OutputBuffer , DRV_VERSION , len ) ) return - EFAULT ; Status = STATUS_SUCCESS ; break ; } case IOCTL_BCM_GET_CURRENT_STATUS : { struct bcm_link_state link_state ; if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""copy_from_user<S2SV_blank>failed..\\n"" ) ; return - EFAULT ; } if ( IoBuffer . OutputLength != sizeof ( link_state ) ) { Status = - EINVAL ; break ; } memset ( & link_state , 0 , sizeof ( link_state ) ) ; link_state . bIdleMode = Adapter -> IdleMode ; link_state . bShutdownMode = Adapter -> bShutStatus ; link_state . ucLinkStatus = Adapter -> LinkStatus ; if ( copy_to_user ( IoBuffer . OutputBuffer , & link_state , min_t ( size_t , sizeof ( link_state ) , IoBuffer . OutputLength ) ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Copy_to_user<S2SV_blank>Failed..\\n"" ) ; return - EFAULT ; } Status = STATUS_SUCCESS ; break ; } case IOCTL_BCM_SET_MAC_TRACING : { UINT tracing_flag ; if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) return - EFAULT ; if ( copy_from_user ( & tracing_flag , IoBuffer . InputBuffer , sizeof ( UINT ) ) ) return - EFAULT ; if ( tracing_flag ) Adapter -> pTarangs -> MacTracingEnabled = TRUE ; else Adapter -> pTarangs -> MacTracingEnabled = FALSE ; break ; } case IOCTL_BCM_GET_DSX_INDICATION : { ULONG ulSFId = 0 ; if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) return - EFAULT ; if ( IoBuffer . OutputLength < sizeof ( struct bcm_add_indication_alt ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Mismatch<S2SV_blank>req:<S2SV_blank>%lx<S2SV_blank>needed<S2SV_blank>is<S2SV_blank>=0x%zx!!!"" , IoBuffer . OutputLength , sizeof ( struct bcm_add_indication_alt ) ) ; return - EINVAL ; } if ( copy_from_user ( & ulSFId , IoBuffer . InputBuffer , sizeof ( ulSFId ) ) ) return - EFAULT ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""Get<S2SV_blank>DSX<S2SV_blank>Data<S2SV_blank>SF<S2SV_blank>ID<S2SV_blank>is<S2SV_blank>=%lx\\n"" , ulSFId ) ; get_dsx_sf_data_to_application ( Adapter , ulSFId , IoBuffer . OutputBuffer ) ; Status = STATUS_SUCCESS ; } break ; case IOCTL_BCM_GET_HOST_MIBS : { PVOID temp_buff ; if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) return - EFAULT ; if ( IoBuffer . OutputLength != sizeof ( struct bcm_host_stats_mibs ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Length<S2SV_blank>Check<S2SV_blank>failed<S2SV_blank>%lu<S2SV_blank>%zd\\n"" , IoBuffer . OutputLength , sizeof ( struct bcm_host_stats_mibs ) ) ; return - EINVAL ; } temp_buff = kzalloc ( sizeof ( struct bcm_host_stats_mibs ) , GFP_KERNEL ) ; if ( ! temp_buff ) return STATUS_FAILURE ; Status = ProcessGetHostMibs ( Adapter , temp_buff ) ; GetDroppedAppCntrlPktMibs ( temp_buff , pTarang ) ; if ( Status != STATUS_FAILURE ) if ( copy_to_user ( IoBuffer . OutputBuffer , temp_buff , sizeof ( struct bcm_host_stats_mibs ) ) ) { kfree ( temp_buff ) ; return - EFAULT ; } kfree ( temp_buff ) ; break ; } case IOCTL_BCM_WAKE_UP_DEVICE_FROM_IDLE : if ( ( FALSE == Adapter -> bTriedToWakeUpFromlowPowerMode ) && ( TRUE == Adapter -> IdleMode ) ) { Adapter -> usIdleModePattern = ABORT_IDLE_MODE ; Adapter -> bWakeUpDevice = TRUE ; wake_up ( & Adapter -> process_rx_cntrlpkt ) ; } Status = STATUS_SUCCESS ; break ; case IOCTL_BCM_BULK_WRM : { struct bcm_bulk_wrm_buffer * pBulkBuffer ; UINT uiTempVar = 0 ; PCHAR pvBuffer = NULL ; if ( ( Adapter -> IdleMode == TRUE ) || ( Adapter -> bShutStatus == TRUE ) || ( Adapter -> bPreparingForLowPowerMode == TRUE ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Device<S2SV_blank>in<S2SV_blank>Idle/Shutdown<S2SV_blank>Mode,<S2SV_blank>Blocking<S2SV_blank>Wrms\\n"" ) ; Status = - EACCES ; break ; } if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) return - EFAULT ; if ( IoBuffer . InputLength < sizeof ( ULONG ) * 2 ) return - EINVAL ; pvBuffer = memdup_user ( IoBuffer . InputBuffer , IoBuffer . InputLength ) ; if ( IS_ERR ( pvBuffer ) ) return PTR_ERR ( pvBuffer ) ; pBulkBuffer = ( struct bcm_bulk_wrm_buffer * ) pvBuffer ; if ( ( ( ULONG ) pBulkBuffer -> Register & 0x0F000000 ) != 0x0F000000 || ( ( ULONG ) pBulkBuffer -> Register & 0x3 ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""WRM<S2SV_blank>Done<S2SV_blank>On<S2SV_blank>invalid<S2SV_blank>Address<S2SV_blank>:<S2SV_blank>%x<S2SV_blank>Access<S2SV_blank>Denied.\\n"" , ( int ) pBulkBuffer -> Register ) ; kfree ( pvBuffer ) ; Status = - EINVAL ; break ; } uiTempVar = pBulkBuffer -> Register & EEPROM_REJECT_MASK ; if ( ! ( ( Adapter -> pstargetparams -> m_u32Customize ) & VSG_MODE ) && ( ( uiTempVar == EEPROM_REJECT_REG_1 ) || ( uiTempVar == EEPROM_REJECT_REG_2 ) || ( uiTempVar == EEPROM_REJECT_REG_3 ) || ( uiTempVar == EEPROM_REJECT_REG_4 ) ) && ( cmd == IOCTL_BCM_REGISTER_WRITE ) ) { kfree ( pvBuffer ) ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""EEPROM<S2SV_blank>Access<S2SV_blank>Denied,<S2SV_blank>not<S2SV_blank>in<S2SV_blank>VSG<S2SV_blank>Mode\\n"" ) ; Status = - EFAULT ; break ; } if ( pBulkBuffer -> SwapEndian == FALSE ) Status = wrmWithLock ( Adapter , ( UINT ) pBulkBuffer -> Register , ( PCHAR ) pBulkBuffer -> Values , IoBuffer . InputLength - 2 * sizeof ( ULONG ) ) ; else Status = wrmaltWithLock ( Adapter , ( UINT ) pBulkBuffer -> Register , ( PUINT ) pBulkBuffer -> Values , IoBuffer . InputLength - 2 * sizeof ( ULONG ) ) ; if ( Status != STATUS_SUCCESS ) BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""WRM<S2SV_blank>Failed\\n"" ) ; kfree ( pvBuffer ) ; break ; } case IOCTL_BCM_GET_NVM_SIZE : if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) return - EFAULT ; if ( Adapter -> eNVMType == NVM_EEPROM || Adapter -> eNVMType == NVM_FLASH ) { if ( copy_to_user ( IoBuffer . OutputBuffer , & Adapter -> uiNVMDSDSize , sizeof ( UINT ) ) ) return - EFAULT ; } Status = STATUS_SUCCESS ; break ; case IOCTL_BCM_CAL_INIT : { UINT uiSectorSize = 0 ; if ( Adapter -> eNVMType == NVM_FLASH ) { if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) return - EFAULT ; if ( copy_from_user ( & uiSectorSize , IoBuffer . InputBuffer , sizeof ( UINT ) ) ) return - EFAULT ; if ( ( uiSectorSize < MIN_SECTOR_SIZE ) || ( uiSectorSize > MAX_SECTOR_SIZE ) ) { if ( copy_to_user ( IoBuffer . OutputBuffer , & Adapter -> uiSectorSize , sizeof ( UINT ) ) ) return - EFAULT ; } else { if ( IsFlash2x ( Adapter ) ) { if ( copy_to_user ( IoBuffer . OutputBuffer , & Adapter -> uiSectorSize , sizeof ( UINT ) ) ) return - EFAULT ; } else { if ( ( TRUE == Adapter -> bShutStatus ) || ( TRUE == Adapter -> IdleMode ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Device<S2SV_blank>is<S2SV_blank>in<S2SV_blank>Idle/Shutdown<S2SV_blank>Mode\\n"" ) ; return - EACCES ; } Adapter -> uiSectorSize = uiSectorSize ; BcmUpdateSectorSize ( Adapter , Adapter -> uiSectorSize ) ; } } Status = STATUS_SUCCESS ; } else { Status = STATUS_FAILURE ; } } break ; case IOCTL_BCM_SET_DEBUG : # ifdef DEBUG { struct bcm_user_debug_state sUserDebugState ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""In<S2SV_blank>SET_DEBUG<S2SV_blank>ioctl\\n"" ) ; if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) return - EFAULT ; if ( copy_from_user ( & sUserDebugState , IoBuffer . InputBuffer , sizeof ( struct bcm_user_debug_state ) ) ) return - EFAULT ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""IOCTL_BCM_SET_DEBUG:<S2SV_blank>OnOff=%d<S2SV_blank>Type<S2SV_blank>=<S2SV_blank>0x%x<S2SV_blank>"" , sUserDebugState . OnOff , sUserDebugState . Type ) ; sUserDebugState . Subtype = 1 << sUserDebugState . Subtype ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""actual<S2SV_blank>Subtype=0x%x\\n"" , sUserDebugState . Subtype ) ; Adapter -> stDebugState . type |= sUserDebugState . Type ; if ( sUserDebugState . OnOff ) Adapter -> stDebugState . subtype [ sUserDebugState . Type ] |= sUserDebugState . Subtype ; else Adapter -> stDebugState . subtype [ sUserDebugState . Type ] &= ~ sUserDebugState . Subtype ; BCM_SHOW_DEBUG_BITMAP ( Adapter ) ; } # endif break ; case IOCTL_BCM_NVM_READ : case IOCTL_BCM_NVM_WRITE : { struct bcm_nvm_readwrite stNVMReadWrite ; PUCHAR pReadData = NULL ; ULONG ulDSDMagicNumInUsrBuff = 0 ; struct timeval tv0 , tv1 ; memset ( & tv0 , 0 , sizeof ( struct timeval ) ) ; memset ( & tv1 , 0 , sizeof ( struct timeval ) ) ; if ( ( Adapter -> eNVMType == NVM_FLASH ) && ( Adapter -> uiFlashLayoutMajorVersion == 0 ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""The<S2SV_blank>Flash<S2SV_blank>Control<S2SV_blank>Section<S2SV_blank>is<S2SV_blank>Corrupted.<S2SV_blank>Hence<S2SV_blank>Rejection<S2SV_blank>on<S2SV_blank>NVM<S2SV_blank>Read/Write\\n"" ) ; return - EFAULT ; } if ( IsFlash2x ( Adapter ) ) { if ( ( Adapter -> eActiveDSD != DSD0 ) && ( Adapter -> eActiveDSD != DSD1 ) && ( Adapter -> eActiveDSD != DSD2 ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""No<S2SV_blank>DSD<S2SV_blank>is<S2SV_blank>active..hence<S2SV_blank>NVM<S2SV_blank>Command<S2SV_blank>is<S2SV_blank>blocked"" ) ; return STATUS_FAILURE ; } } if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) return - EFAULT ; if ( copy_from_user ( & stNVMReadWrite , ( IOCTL_BCM_NVM_READ == cmd ) ? IoBuffer . OutputBuffer : IoBuffer . InputBuffer , sizeof ( struct bcm_nvm_readwrite ) ) ) return - EFAULT ; if ( stNVMReadWrite . uiNumBytes > Adapter -> uiNVMDSDSize ) return STATUS_FAILURE ; if ( stNVMReadWrite . uiOffset > Adapter -> uiNVMDSDSize - stNVMReadWrite . uiNumBytes ) { return STATUS_FAILURE ; } pReadData = memdup_user ( stNVMReadWrite . pBuffer , stNVMReadWrite . uiNumBytes ) ; if ( IS_ERR ( pReadData ) ) return PTR_ERR ( pReadData ) ; do_gettimeofday ( & tv0 ) ; if ( IOCTL_BCM_NVM_READ == cmd ) { down ( & Adapter -> NVMRdmWrmLock ) ; if ( ( Adapter -> IdleMode == TRUE ) || ( Adapter -> bShutStatus == TRUE ) || ( Adapter -> bPreparingForLowPowerMode == TRUE ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""Device<S2SV_blank>is<S2SV_blank>in<S2SV_blank>Idle/Shutdown<S2SV_blank>Mode\\n"" ) ; up ( & Adapter -> NVMRdmWrmLock ) ; kfree ( pReadData ) ; return - EACCES ; } Status = BeceemNVMRead ( Adapter , ( PUINT ) pReadData , stNVMReadWrite . uiOffset , stNVMReadWrite . uiNumBytes ) ; up ( & Adapter -> NVMRdmWrmLock ) ; if ( Status != STATUS_SUCCESS ) { kfree ( pReadData ) ; return Status ; } if ( copy_to_user ( stNVMReadWrite . pBuffer , pReadData , stNVMReadWrite . uiNumBytes ) ) { kfree ( pReadData ) ; return - EFAULT ; } } else { down ( & Adapter -> NVMRdmWrmLock ) ; if ( ( Adapter -> IdleMode == TRUE ) || ( Adapter -> bShutStatus == TRUE ) || ( Adapter -> bPreparingForLowPowerMode == TRUE ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""Device<S2SV_blank>is<S2SV_blank>in<S2SV_blank>Idle/Shutdown<S2SV_blank>Mode\\n"" ) ; up ( & Adapter -> NVMRdmWrmLock ) ; kfree ( pReadData ) ; return - EACCES ; } Adapter -> bHeaderChangeAllowed = TRUE ; if ( IsFlash2x ( Adapter ) ) { Status = BcmFlash2xCorruptSig ( Adapter , Adapter -> eActiveDSD ) ; if ( Status != STATUS_SUCCESS ) { if ( ( ( stNVMReadWrite . uiOffset + stNVMReadWrite . uiNumBytes ) != Adapter -> uiNVMDSDSize ) || ( stNVMReadWrite . uiNumBytes < SIGNATURE_SIZE ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""DSD<S2SV_blank>Sig<S2SV_blank>is<S2SV_blank>present<S2SV_blank>neither<S2SV_blank>in<S2SV_blank>Flash<S2SV_blank>nor<S2SV_blank>User<S2SV_blank>provided<S2SV_blank>Input.."" ) ; up ( & Adapter -> NVMRdmWrmLock ) ; kfree ( pReadData ) ; return Status ; } ulDSDMagicNumInUsrBuff = ntohl ( * ( PUINT ) ( pReadData + stNVMReadWrite . uiNumBytes - SIGNATURE_SIZE ) ) ; if ( ulDSDMagicNumInUsrBuff != DSD_IMAGE_MAGIC_NUMBER ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""DSD<S2SV_blank>Sig<S2SV_blank>is<S2SV_blank>present<S2SV_blank>neither<S2SV_blank>in<S2SV_blank>Flash<S2SV_blank>nor<S2SV_blank>User<S2SV_blank>provided<S2SV_blank>Input.."" ) ; up ( & Adapter -> NVMRdmWrmLock ) ; kfree ( pReadData ) ; return Status ; } } } Status = BeceemNVMWrite ( Adapter , ( PUINT ) pReadData , stNVMReadWrite . uiOffset , stNVMReadWrite . uiNumBytes , stNVMReadWrite . bVerify ) ; if ( IsFlash2x ( Adapter ) ) BcmFlash2xWriteSig ( Adapter , Adapter -> eActiveDSD ) ; Adapter -> bHeaderChangeAllowed = FALSE ; up ( & Adapter -> NVMRdmWrmLock ) ; if ( Status != STATUS_SUCCESS ) { kfree ( pReadData ) ; return Status ; } } do_gettimeofday ( & tv1 ) ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""<S2SV_blank>timetaken<S2SV_blank>by<S2SV_blank>Write/read<S2SV_blank>:%ld<S2SV_blank>msec\\n"" , ( tv1 . tv_sec - tv0 . tv_sec ) * 1000 + ( tv1 . tv_usec - tv0 . tv_usec ) / 1000 ) ; kfree ( pReadData ) ; return STATUS_SUCCESS ; } case IOCTL_BCM_FLASH2X_SECTION_READ : { struct bcm_flash2x_readwrite sFlash2xRead = { 0 } ; PUCHAR pReadBuff = NULL ; UINT NOB = 0 ; UINT BuffSize = 0 ; UINT ReadBytes = 0 ; UINT ReadOffset = 0 ; void __user * OutPutBuff ; if ( IsFlash2x ( Adapter ) != TRUE ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Flash<S2SV_blank>Does<S2SV_blank>not<S2SV_blank>have<S2SV_blank>2.x<S2SV_blank>map"" ) ; return - EINVAL ; } BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""IOCTL_BCM_FLASH2X_SECTION_READ<S2SV_blank>Called"" ) ; if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) return - EFAULT ; if ( copy_from_user ( & sFlash2xRead , IoBuffer . InputBuffer , sizeof ( struct bcm_flash2x_readwrite ) ) ) return - EFAULT ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""\\nsFlash2xRead.Section<S2SV_blank>:%x"" , sFlash2xRead . Section ) ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""\\nsFlash2xRead.offset<S2SV_blank>:%x"" , sFlash2xRead . offset ) ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""\\nsFlash2xRead.numOfBytes<S2SV_blank>:%x"" , sFlash2xRead . numOfBytes ) ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""\\nsFlash2xRead.bVerify<S2SV_blank>:%x\\n"" , sFlash2xRead . bVerify ) ; if ( validateFlash2xReadWrite ( Adapter , & sFlash2xRead ) == FALSE ) return STATUS_FAILURE ; NOB = sFlash2xRead . numOfBytes ; if ( NOB > Adapter -> uiSectorSize ) BuffSize = Adapter -> uiSectorSize ; else BuffSize = NOB ; ReadOffset = sFlash2xRead . offset ; OutPutBuff = IoBuffer . OutputBuffer ; pReadBuff = ( PCHAR ) kzalloc ( BuffSize , GFP_KERNEL ) ; if ( pReadBuff == NULL ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Memory<S2SV_blank>allocation<S2SV_blank>failed<S2SV_blank>for<S2SV_blank>Flash<S2SV_blank>2.x<S2SV_blank>Read<S2SV_blank>Structure"" ) ; return - ENOMEM ; } down ( & Adapter -> NVMRdmWrmLock ) ; if ( ( Adapter -> IdleMode == TRUE ) || ( Adapter -> bShutStatus == TRUE ) || ( Adapter -> bPreparingForLowPowerMode == TRUE ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""Device<S2SV_blank>is<S2SV_blank>in<S2SV_blank>Idle/Shutdown<S2SV_blank>Mode\\n"" ) ; up ( & Adapter -> NVMRdmWrmLock ) ; kfree ( pReadBuff ) ; return - EACCES ; } while ( NOB ) { if ( NOB > Adapter -> uiSectorSize ) ReadBytes = Adapter -> uiSectorSize ; else ReadBytes = NOB ; Status = BcmFlash2xBulkRead ( Adapter , ( PUINT ) pReadBuff , sFlash2xRead . Section , ReadOffset , ReadBytes ) ; if ( Status ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""Flash<S2SV_blank>2x<S2SV_blank>read<S2SV_blank>err<S2SV_blank>with<S2SV_blank>Status<S2SV_blank>:%d"" , Status ) ; break ; } BCM_DEBUG_PRINT_BUFFER ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , pReadBuff , ReadBytes ) ; Status = copy_to_user ( OutPutBuff , pReadBuff , ReadBytes ) ; if ( Status ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""Copy<S2SV_blank>to<S2SV_blank>use<S2SV_blank>failed<S2SV_blank>with<S2SV_blank>status<S2SV_blank>:%d"" , Status ) ; up ( & Adapter -> NVMRdmWrmLock ) ; kfree ( pReadBuff ) ; return - EFAULT ; } NOB = NOB - ReadBytes ; if ( NOB ) { ReadOffset = ReadOffset + ReadBytes ; OutPutBuff = OutPutBuff + ReadBytes ; } } up ( & Adapter -> NVMRdmWrmLock ) ; kfree ( pReadBuff ) ; } break ; case IOCTL_BCM_FLASH2X_SECTION_WRITE : { struct bcm_flash2x_readwrite sFlash2xWrite = { 0 } ; PUCHAR pWriteBuff ; void __user * InputAddr ; UINT NOB = 0 ; UINT BuffSize = 0 ; UINT WriteOffset = 0 ; UINT WriteBytes = 0 ; if ( IsFlash2x ( Adapter ) != TRUE ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Flash<S2SV_blank>Does<S2SV_blank>not<S2SV_blank>have<S2SV_blank>2.x<S2SV_blank>map"" ) ; return - EINVAL ; } Adapter -> bAllDSDWriteAllow = FALSE ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""IOCTL_BCM_FLASH2X_SECTION_WRITE<S2SV_blank>Called"" ) ; if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) return - EFAULT ; if ( copy_from_user ( & sFlash2xWrite , IoBuffer . InputBuffer , sizeof ( struct bcm_flash2x_readwrite ) ) ) return - EFAULT ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""\\nsFlash2xRead.Section<S2SV_blank>:%x"" , sFlash2xWrite . Section ) ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""\\nsFlash2xRead.offset<S2SV_blank>:%d"" , sFlash2xWrite . offset ) ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""\\nsFlash2xRead.numOfBytes<S2SV_blank>:%x"" , sFlash2xWrite . numOfBytes ) ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""\\nsFlash2xRead.bVerify<S2SV_blank>:%x\\n"" , sFlash2xWrite . bVerify ) ; if ( ( sFlash2xWrite . Section != VSA0 ) && ( sFlash2xWrite . Section != VSA1 ) && ( sFlash2xWrite . Section != VSA2 ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""Only<S2SV_blank>VSA<S2SV_blank>write<S2SV_blank>is<S2SV_blank>allowed"" ) ; return - EINVAL ; } if ( validateFlash2xReadWrite ( Adapter , & sFlash2xWrite ) == FALSE ) return STATUS_FAILURE ; InputAddr = sFlash2xWrite . pDataBuff ; WriteOffset = sFlash2xWrite . offset ; NOB = sFlash2xWrite . numOfBytes ; if ( NOB > Adapter -> uiSectorSize ) BuffSize = Adapter -> uiSectorSize ; else BuffSize = NOB ; pWriteBuff = kmalloc ( BuffSize , GFP_KERNEL ) ; if ( pWriteBuff == NULL ) return - ENOMEM ; WriteBytes = Adapter -> uiSectorSize ; if ( WriteOffset % Adapter -> uiSectorSize ) WriteBytes = Adapter -> uiSectorSize - ( WriteOffset % Adapter -> uiSectorSize ) ; if ( NOB < WriteBytes ) WriteBytes = NOB ; down ( & Adapter -> NVMRdmWrmLock ) ; if ( ( Adapter -> IdleMode == TRUE ) || ( Adapter -> bShutStatus == TRUE ) || ( Adapter -> bPreparingForLowPowerMode == TRUE ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""Device<S2SV_blank>is<S2SV_blank>in<S2SV_blank>Idle/Shutdown<S2SV_blank>Mode\\n"" ) ; up ( & Adapter -> NVMRdmWrmLock ) ; kfree ( pWriteBuff ) ; return - EACCES ; } BcmFlash2xCorruptSig ( Adapter , sFlash2xWrite . Section ) ; do { Status = copy_from_user ( pWriteBuff , InputAddr , WriteBytes ) ; if ( Status ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Copy<S2SV_blank>to<S2SV_blank>user<S2SV_blank>failed<S2SV_blank>with<S2SV_blank>status<S2SV_blank>:%d"" , Status ) ; up ( & Adapter -> NVMRdmWrmLock ) ; kfree ( pWriteBuff ) ; return - EFAULT ; } BCM_DEBUG_PRINT_BUFFER ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , pWriteBuff , WriteBytes ) ; Status = BcmFlash2xBulkWrite ( Adapter , ( PUINT ) pWriteBuff , sFlash2xWrite . Section , WriteOffset , WriteBytes , sFlash2xWrite . bVerify ) ; if ( Status ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Flash<S2SV_blank>2x<S2SV_blank>read<S2SV_blank>err<S2SV_blank>with<S2SV_blank>Status<S2SV_blank>:%d"" , Status ) ; break ; } NOB = NOB - WriteBytes ; if ( NOB ) { WriteOffset = WriteOffset + WriteBytes ; InputAddr = InputAddr + WriteBytes ; if ( NOB > Adapter -> uiSectorSize ) WriteBytes = Adapter -> uiSectorSize ; else WriteBytes = NOB ; } } while ( NOB > 0 ) ; BcmFlash2xWriteSig ( Adapter , sFlash2xWrite . Section ) ; up ( & Adapter -> NVMRdmWrmLock ) ; kfree ( pWriteBuff ) ; } break ; case IOCTL_BCM_GET_FLASH2X_SECTION_BITMAP : { struct bcm_flash2x_bitmap * psFlash2xBitMap ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""IOCTL_BCM_GET_FLASH2X_SECTION_BITMAP<S2SV_blank>Called"" ) ; if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) return - EFAULT ; if ( IoBuffer . OutputLength != sizeof ( struct bcm_flash2x_bitmap ) ) return - EINVAL ; psFlash2xBitMap = kzalloc ( sizeof ( struct bcm_flash2x_bitmap ) , GFP_KERNEL ) ; if ( psFlash2xBitMap == NULL ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Memory<S2SV_blank>is<S2SV_blank>not<S2SV_blank>available"" ) ; return - ENOMEM ; } down ( & Adapter -> NVMRdmWrmLock ) ; if ( ( Adapter -> IdleMode == TRUE ) || ( Adapter -> bShutStatus == TRUE ) || ( Adapter -> bPreparingForLowPowerMode == TRUE ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""Device<S2SV_blank>is<S2SV_blank>in<S2SV_blank>Idle/Shutdown<S2SV_blank>Mode\\n"" ) ; up ( & Adapter -> NVMRdmWrmLock ) ; kfree ( psFlash2xBitMap ) ; return - EACCES ; } BcmGetFlash2xSectionalBitMap ( Adapter , psFlash2xBitMap ) ; up ( & Adapter -> NVMRdmWrmLock ) ; if ( copy_to_user ( IoBuffer . OutputBuffer , psFlash2xBitMap , sizeof ( struct bcm_flash2x_bitmap ) ) ) { kfree ( psFlash2xBitMap ) ; return - EFAULT ; } kfree ( psFlash2xBitMap ) ; } break ; case IOCTL_BCM_SET_ACTIVE_SECTION : { enum bcm_flash2x_section_val eFlash2xSectionVal = 0 ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""IOCTL_BCM_SET_ACTIVE_SECTION<S2SV_blank>Called"" ) ; if ( IsFlash2x ( Adapter ) != TRUE ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Flash<S2SV_blank>Does<S2SV_blank>not<S2SV_blank>have<S2SV_blank>2.x<S2SV_blank>map"" ) ; return - EINVAL ; } Status = copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ; if ( Status ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Copy<S2SV_blank>of<S2SV_blank>IOCTL<S2SV_blank>BUFFER<S2SV_blank>failed"" ) ; return - EFAULT ; } Status = copy_from_user ( & eFlash2xSectionVal , IoBuffer . InputBuffer , sizeof ( INT ) ) ; if ( Status ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Copy<S2SV_blank>of<S2SV_blank>flash<S2SV_blank>section<S2SV_blank>val<S2SV_blank>failed"" ) ; return - EFAULT ; } down ( & Adapter -> NVMRdmWrmLock ) ; if ( ( Adapter -> IdleMode == TRUE ) || ( Adapter -> bShutStatus == TRUE ) || ( Adapter -> bPreparingForLowPowerMode == TRUE ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""Device<S2SV_blank>is<S2SV_blank>in<S2SV_blank>Idle/Shutdown<S2SV_blank>Mode\\n"" ) ; up ( & Adapter -> NVMRdmWrmLock ) ; return - EACCES ; } Status = BcmSetActiveSection ( Adapter , eFlash2xSectionVal ) ; if ( Status ) BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Failed<S2SV_blank>to<S2SV_blank>make<S2SV_blank>it\'s<S2SV_blank>priority<S2SV_blank>Highest.<S2SV_blank>Status<S2SV_blank>%d"" , Status ) ; up ( & Adapter -> NVMRdmWrmLock ) ; } break ; case IOCTL_BCM_IDENTIFY_ACTIVE_SECTION : { Adapter -> bAllDSDWriteAllow = FALSE ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""IOCTL_BCM_IDENTIFY_ACTIVE_SECTION<S2SV_blank>called"" ) ; Status = STATUS_SUCCESS ; } break ; case IOCTL_BCM_COPY_SECTION : { struct bcm_flash2x_copy_section sCopySectStrut = { 0 } ; Status = STATUS_SUCCESS ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""IOCTL_BCM_COPY_SECTION<S2SV_blank><S2SV_blank>Called"" ) ; Adapter -> bAllDSDWriteAllow = FALSE ; if ( IsFlash2x ( Adapter ) != TRUE ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Flash<S2SV_blank>Does<S2SV_blank>not<S2SV_blank>have<S2SV_blank>2.x<S2SV_blank>map"" ) ; return - EINVAL ; } Status = copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ; if ( Status ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Copy<S2SV_blank>of<S2SV_blank>IOCTL<S2SV_blank>BUFFER<S2SV_blank>failed<S2SV_blank>Status<S2SV_blank>:%d"" , Status ) ; return - EFAULT ; } Status = copy_from_user ( & sCopySectStrut , IoBuffer . InputBuffer , sizeof ( struct bcm_flash2x_copy_section ) ) ; if ( Status ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Copy<S2SV_blank>of<S2SV_blank>Copy_Section_Struct<S2SV_blank>failed<S2SV_blank>with<S2SV_blank>Status<S2SV_blank>:%d"" , Status ) ; return - EFAULT ; } BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""Source<S2SV_blank>SEction<S2SV_blank>:%x"" , sCopySectStrut . SrcSection ) ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""Destination<S2SV_blank>SEction<S2SV_blank>:%x"" , sCopySectStrut . DstSection ) ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""offset<S2SV_blank>:%x"" , sCopySectStrut . offset ) ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""NOB<S2SV_blank>:%x"" , sCopySectStrut . numOfBytes ) ; if ( IsSectionExistInFlash ( Adapter , sCopySectStrut . SrcSection ) == FALSE ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Source<S2SV_blank>Section<%x><S2SV_blank>does<S2SV_blank>not<S2SV_blank>exixt<S2SV_blank>in<S2SV_blank>Flash<S2SV_blank>"" , sCopySectStrut . SrcSection ) ; return - EINVAL ; } if ( IsSectionExistInFlash ( Adapter , sCopySectStrut . DstSection ) == FALSE ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Destinatio<S2SV_blank>Section<%x><S2SV_blank>does<S2SV_blank>not<S2SV_blank>exixt<S2SV_blank>in<S2SV_blank>Flash<S2SV_blank>"" , sCopySectStrut . DstSection ) ; return - EINVAL ; } if ( sCopySectStrut . SrcSection == sCopySectStrut . DstSection ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""Source<S2SV_blank>and<S2SV_blank>Destination<S2SV_blank>section<S2SV_blank>should<S2SV_blank>be<S2SV_blank>different"" ) ; return - EINVAL ; } down ( & Adapter -> NVMRdmWrmLock ) ; if ( ( Adapter -> IdleMode == TRUE ) || ( Adapter -> bShutStatus == TRUE ) || ( Adapter -> bPreparingForLowPowerMode == TRUE ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""Device<S2SV_blank>is<S2SV_blank>in<S2SV_blank>Idle/Shutdown<S2SV_blank>Mode\\n"" ) ; up ( & Adapter -> NVMRdmWrmLock ) ; return - EACCES ; } if ( sCopySectStrut . SrcSection == ISO_IMAGE1 || sCopySectStrut . SrcSection == ISO_IMAGE2 ) { if ( IsNonCDLessDevice ( Adapter ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Device<S2SV_blank>is<S2SV_blank>Non-CDLess<S2SV_blank>hence<S2SV_blank>won\'t<S2SV_blank>have<S2SV_blank>ISO<S2SV_blank>!!"" ) ; Status = - EINVAL ; } else if ( sCopySectStrut . numOfBytes == 0 ) { Status = BcmCopyISO ( Adapter , sCopySectStrut ) ; } else { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Partial<S2SV_blank>Copy<S2SV_blank>of<S2SV_blank>ISO<S2SV_blank>section<S2SV_blank>is<S2SV_blank>not<S2SV_blank>Allowed.."" ) ; Status = STATUS_FAILURE ; } up ( & Adapter -> NVMRdmWrmLock ) ; return Status ; } Status = BcmCopySection ( Adapter , sCopySectStrut . SrcSection , sCopySectStrut . DstSection , sCopySectStrut . offset , sCopySectStrut . numOfBytes ) ; up ( & Adapter -> NVMRdmWrmLock ) ; } break ; case IOCTL_BCM_GET_FLASH_CS_INFO : { Status = STATUS_SUCCESS ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""<S2SV_blank>IOCTL_BCM_GET_FLASH_CS_INFO<S2SV_blank>Called"" ) ; Status = copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ; if ( Status ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Copy<S2SV_blank>of<S2SV_blank>IOCTL<S2SV_blank>BUFFER<S2SV_blank>failed"" ) ; return - EFAULT ; } if ( Adapter -> eNVMType != NVM_FLASH ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Connected<S2SV_blank>device<S2SV_blank>does<S2SV_blank>not<S2SV_blank>have<S2SV_blank>flash"" ) ; Status = - EINVAL ; break ; } if ( IsFlash2x ( Adapter ) == TRUE ) { if ( IoBuffer . OutputLength < sizeof ( struct bcm_flash2x_cs_info ) ) return - EINVAL ; if ( copy_to_user ( IoBuffer . OutputBuffer , Adapter -> psFlash2xCSInfo , sizeof ( struct bcm_flash2x_cs_info ) ) ) return - EFAULT ; } else { if ( IoBuffer . OutputLength < sizeof ( struct bcm_flash_cs_info ) ) return - EINVAL ; if ( copy_to_user ( IoBuffer . OutputBuffer , Adapter -> psFlashCSInfo , sizeof ( struct bcm_flash_cs_info ) ) ) return - EFAULT ; } } break ; case IOCTL_BCM_SELECT_DSD : { UINT SectOfset = 0 ; enum bcm_flash2x_section_val eFlash2xSectionVal ; eFlash2xSectionVal = NO_SECTION_VAL ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""IOCTL_BCM_SELECT_DSD<S2SV_blank>Called"" ) ; if ( IsFlash2x ( Adapter ) != TRUE ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Flash<S2SV_blank>Does<S2SV_blank>not<S2SV_blank>have<S2SV_blank>2.x<S2SV_blank>map"" ) ; return - EINVAL ; } Status = copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ; if ( Status ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Copy<S2SV_blank>of<S2SV_blank>IOCTL<S2SV_blank>BUFFER<S2SV_blank>failed"" ) ; return - EFAULT ; } Status = copy_from_user ( & eFlash2xSectionVal , IoBuffer . InputBuffer , sizeof ( INT ) ) ; if ( Status ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Copy<S2SV_blank>of<S2SV_blank>flash<S2SV_blank>section<S2SV_blank>val<S2SV_blank>failed"" ) ; return - EFAULT ; } BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""Read<S2SV_blank>Section<S2SV_blank>:%d"" , eFlash2xSectionVal ) ; if ( ( eFlash2xSectionVal != DSD0 ) && ( eFlash2xSectionVal != DSD1 ) && ( eFlash2xSectionVal != DSD2 ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Passed<S2SV_blank>section<%x><S2SV_blank>is<S2SV_blank>not<S2SV_blank>DSD<S2SV_blank>section"" , eFlash2xSectionVal ) ; return STATUS_FAILURE ; } SectOfset = BcmGetSectionValStartOffset ( Adapter , eFlash2xSectionVal ) ; if ( SectOfset == INVALID_OFFSET ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Provided<S2SV_blank>Section<S2SV_blank>val<S2SV_blank><%d><S2SV_blank>does<S2SV_blank>not<S2SV_blank>exixt<S2SV_blank>in<S2SV_blank>Flash<S2SV_blank>2.x"" , eFlash2xSectionVal ) ; return - EINVAL ; } Adapter -> bAllDSDWriteAllow = TRUE ; Adapter -> ulFlashCalStart = SectOfset ; Adapter -> eActiveDSD = eFlash2xSectionVal ; } Status = STATUS_SUCCESS ; break ; case IOCTL_BCM_NVM_RAW_READ : { struct bcm_nvm_readwrite stNVMRead ; INT NOB ; INT BuffSize ; INT ReadOffset = 0 ; UINT ReadBytes = 0 ; PUCHAR pReadBuff ; void __user * OutPutBuff ; if ( Adapter -> eNVMType != NVM_FLASH ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""NVM<S2SV_blank>TYPE<S2SV_blank>is<S2SV_blank>not<S2SV_blank>Flash"" ) ; return - EINVAL ; } if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""copy_from_user<S2SV_blank>1<S2SV_blank>failed\\n"" ) ; return - EFAULT ; } if ( copy_from_user ( & stNVMRead , IoBuffer . OutputBuffer , sizeof ( struct bcm_nvm_readwrite ) ) ) return - EFAULT ; NOB = stNVMRead . uiNumBytes ; if ( NOB > DEFAULT_BUFF_SIZE ) BuffSize = DEFAULT_BUFF_SIZE ; else BuffSize = NOB ; ReadOffset = stNVMRead . uiOffset ; OutPutBuff = stNVMRead . pBuffer ; pReadBuff = kzalloc ( BuffSize , GFP_KERNEL ) ; if ( pReadBuff == NULL ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Memory<S2SV_blank>allocation<S2SV_blank>failed<S2SV_blank>for<S2SV_blank>Flash<S2SV_blank>2.x<S2SV_blank>Read<S2SV_blank>Structure"" ) ; Status = - ENOMEM ; break ; } down ( & Adapter -> NVMRdmWrmLock ) ; if ( ( Adapter -> IdleMode == TRUE ) || ( Adapter -> bShutStatus == TRUE ) || ( Adapter -> bPreparingForLowPowerMode == TRUE ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""Device<S2SV_blank>is<S2SV_blank>in<S2SV_blank>Idle/Shutdown<S2SV_blank>Mode\\n"" ) ; kfree ( pReadBuff ) ; up ( & Adapter -> NVMRdmWrmLock ) ; return - EACCES ; } Adapter -> bFlashRawRead = TRUE ; while ( NOB ) { if ( NOB > DEFAULT_BUFF_SIZE ) ReadBytes = DEFAULT_BUFF_SIZE ; else ReadBytes = NOB ; Status = BeceemNVMRead ( Adapter , ( PUINT ) pReadBuff , ReadOffset , ReadBytes ) ; if ( Status ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Flash<S2SV_blank>2x<S2SV_blank>read<S2SV_blank>err<S2SV_blank>with<S2SV_blank>Status<S2SV_blank>:%d"" , Status ) ; break ; } BCM_DEBUG_PRINT_BUFFER ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , pReadBuff , ReadBytes ) ; Status = copy_to_user ( OutPutBuff , pReadBuff , ReadBytes ) ; if ( Status ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , ""Copy<S2SV_blank>to<S2SV_blank>use<S2SV_blank>failed<S2SV_blank>with<S2SV_blank>status<S2SV_blank>:%d"" , Status ) ; up ( & Adapter -> NVMRdmWrmLock ) ; kfree ( pReadBuff ) ; return - EFAULT ; } NOB = NOB - ReadBytes ; if ( NOB ) { ReadOffset = ReadOffset + ReadBytes ; OutPutBuff = OutPutBuff + ReadBytes ; } } Adapter -> bFlashRawRead = FALSE ; up ( & Adapter -> NVMRdmWrmLock ) ; kfree ( pReadBuff ) ; break ; } case IOCTL_BCM_CNTRLMSG_MASK : { ULONG RxCntrlMsgBitMask = 0 ; Status = copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ; if ( Status ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""copy<S2SV_blank>of<S2SV_blank>Ioctl<S2SV_blank>buffer<S2SV_blank>is<S2SV_blank>failed<S2SV_blank>from<S2SV_blank>user<S2SV_blank>space"" ) ; return - EFAULT ; } if ( IoBuffer . InputLength != sizeof ( unsigned long ) ) { Status = - EINVAL ; break ; } Status = copy_from_user ( & RxCntrlMsgBitMask , IoBuffer . InputBuffer , IoBuffer . InputLength ) ; if ( Status ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""copy<S2SV_blank>of<S2SV_blank>control<S2SV_blank>bit<S2SV_blank>mask<S2SV_blank>failed<S2SV_blank>from<S2SV_blank>user<S2SV_blank>space"" ) ; return - EFAULT ; } BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""\\n<S2SV_blank>Got<S2SV_blank>user<S2SV_blank>defined<S2SV_blank>cntrl<S2SV_blank>msg<S2SV_blank>bit<S2SV_blank>mask<S2SV_blank>:%lx"" , RxCntrlMsgBitMask ) ; pTarang -> RxCntrlMsgBitMask = RxCntrlMsgBitMask ; } break ; case IOCTL_BCM_GET_DEVICE_DRIVER_INFO : { struct bcm_driver_info DevInfo ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""Called<S2SV_blank>IOCTL_BCM_GET_DEVICE_DRIVER_INFO\\n"" ) ; <S2SV_StartBug> DevInfo . MaxRDMBufferSize = BUFFER_4K ; <S2SV_EndBug> DevInfo . u32DSDStartOffset = EEPROM_CALPARAM_START ; DevInfo . u32RxAlignmentCorrection = 0 ; DevInfo . u32NVMType = Adapter -> eNVMType ; DevInfo . u32InterfaceType = BCM_USB ; if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) return - EFAULT ; if ( IoBuffer . OutputLength < sizeof ( DevInfo ) ) return - EINVAL ; if ( copy_to_user ( IoBuffer . OutputBuffer , & DevInfo , sizeof ( DevInfo ) ) ) return - EFAULT ; } break ; case IOCTL_BCM_TIME_SINCE_NET_ENTRY : { struct bcm_time_elapsed stTimeElapsedSinceNetEntry = { 0 } ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""IOCTL_BCM_TIME_SINCE_NET_ENTRY<S2SV_blank>called"" ) ; if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) return - EFAULT ; if ( IoBuffer . OutputLength < sizeof ( struct bcm_time_elapsed ) ) return - EINVAL ; stTimeElapsedSinceNetEntry . ul64TimeElapsedSinceNetEntry = get_seconds ( ) - Adapter -> liTimeSinceLastNetEntry ; if ( copy_to_user ( IoBuffer . OutputBuffer , & stTimeElapsedSinceNetEntry , sizeof ( struct bcm_time_elapsed ) ) ) return - EFAULT ; } break ; case IOCTL_CLOSE_NOTIFICATION : BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , ""IOCTL_CLOSE_NOTIFICATION"" ) ; break ; default : pr_info ( DRV_NAME "":<S2SV_blank>unknown<S2SV_blank>ioctl<S2SV_blank>cmd=%#x\\n"" , cmd ) ; Status = STATUS_FAILURE ; break ; } return Status ; }","""Called<S2SV_blank>IOCTL_BCM_GET_DEVICE_DRIVER_INFO\\n"" ) ; memset ( & DevInfo , 0 , sizeof ( DevInfo ) ) ;"
156,"unsigned char * ssl_add_serverhello_tlsext ( SSL * s , unsigned char * buf , unsigned char * limit , int * al ) { int extdatalen = 0 ; unsigned char * orig = buf ; unsigned char * ret = buf ; # ifndef OPENSSL_NO_NEXTPROTONEG int next_proto_neg_seen ; # endif # ifndef OPENSSL_NO_EC unsigned long alg_k = s -> s3 -> tmp . new_cipher -> algorithm_mkey ; unsigned long alg_a = s -> s3 -> tmp . new_cipher -> algorithm_auth ; int using_ecc = ( alg_k & SSL_kECDHE ) || ( alg_a & SSL_aECDSA ) ; using_ecc = using_ecc && ( s -> session -> tlsext_ecpointformatlist != NULL ) ; # endif ret += 2 ; if ( ret >= limit ) return NULL ; if ( s -> s3 -> send_connection_binding ) { int el ; if ( ! ssl_add_serverhello_renegotiate_ext ( s , 0 , & el , 0 ) ) { SSLerr ( SSL_F_SSL_ADD_SERVERHELLO_TLSEXT , ERR_R_INTERNAL_ERROR ) ; return NULL ; } if ( CHECKLEN ( ret , 4 + el , limit ) ) return NULL ; s2n ( TLSEXT_TYPE_renegotiate , ret ) ; s2n ( el , ret ) ; if ( ! ssl_add_serverhello_renegotiate_ext ( s , ret , & el , el ) ) { SSLerr ( SSL_F_SSL_ADD_SERVERHELLO_TLSEXT , ERR_R_INTERNAL_ERROR ) ; return NULL ; } ret += el ; } if ( s -> version == SSL3_VERSION ) goto done ; if ( ! s -> hit && s -> servername_done == 1 && s -> session -> tlsext_hostname != NULL ) { if ( CHECKLEN ( ret , 4 , limit ) ) return NULL ; s2n ( TLSEXT_TYPE_server_name , ret ) ; s2n ( 0 , ret ) ; } # ifndef OPENSSL_NO_EC if ( using_ecc ) { const unsigned char * plist ; size_t plistlen ; tls1_get_formatlist ( s , & plist , & plistlen ) ; if ( plistlen > 255 ) { SSLerr ( SSL_F_SSL_ADD_SERVERHELLO_TLSEXT , ERR_R_INTERNAL_ERROR ) ; return NULL ; } if ( CHECKLEN ( ret , 5 + plistlen , limit ) ) return NULL ; s2n ( TLSEXT_TYPE_ec_point_formats , ret ) ; s2n ( plistlen + 1 , ret ) ; * ( ret ++ ) = ( unsigned char ) plistlen ; memcpy ( ret , plist , plistlen ) ; ret += plistlen ; } # endif if ( s -> tlsext_ticket_expected && tls_use_ticket ( s ) ) { if ( CHECKLEN ( ret , 4 , limit ) ) return NULL ; s2n ( TLSEXT_TYPE_session_ticket , ret ) ; s2n ( 0 , ret ) ; } else { s -> tlsext_ticket_expected = 0 ; } if ( s -> tlsext_status_expected ) { if ( CHECKLEN ( ret , 4 , limit ) ) return NULL ; s2n ( TLSEXT_TYPE_status_request , ret ) ; s2n ( 0 , ret ) ; } # ifndef OPENSSL_NO_SRTP if ( SSL_IS_DTLS ( s ) && s -> srtp_profile ) { int el ; if ( ssl_add_serverhello_use_srtp_ext ( s , 0 , & el , 0 ) ) { SSLerr ( SSL_F_SSL_ADD_SERVERHELLO_TLSEXT , ERR_R_INTERNAL_ERROR ) ; return NULL ; } if ( CHECKLEN ( ret , 4 + el , limit ) ) return NULL ; s2n ( TLSEXT_TYPE_use_srtp , ret ) ; s2n ( el , ret ) ; if ( ssl_add_serverhello_use_srtp_ext ( s , ret , & el , el ) ) { SSLerr ( SSL_F_SSL_ADD_SERVERHELLO_TLSEXT , ERR_R_INTERNAL_ERROR ) ; return NULL ; } ret += el ; } # endif if ( ( ( s -> s3 -> tmp . new_cipher -> id & 0xFFFF ) == 0x80 || ( s -> s3 -> tmp . new_cipher -> id & 0xFFFF ) == 0x81 ) && ( SSL_get_options ( s ) & SSL_OP_CRYPTOPRO_TLSEXT_BUG ) ) { const unsigned char cryptopro_ext [ 36 ] = { 0xfd , 0xe8 , 0x00 , 0x20 , 0x30 , 0x1e , 0x30 , 0x08 , 0x06 , 0x06 , 0x2a , 0x85 , 0x03 , 0x02 , 0x02 , 0x09 , 0x30 , 0x08 , 0x06 , 0x06 , 0x2a , 0x85 , 0x03 , 0x02 , 0x02 , 0x16 , 0x30 , 0x08 , 0x06 , 0x06 , 0x2a , 0x85 , 0x03 , 0x02 , 0x02 , 0x17 } ; if ( CHECKLEN ( ret , sizeof ( cryptopro_ext ) , limit ) ) return NULL ; memcpy ( ret , cryptopro_ext , sizeof ( cryptopro_ext ) ) ; ret += sizeof ( cryptopro_ext ) ; } # ifndef OPENSSL_NO_HEARTBEATS if ( SSL_IS_DTLS ( s ) && ( s -> tlsext_heartbeat & SSL_DTLSEXT_HB_ENABLED ) ) { if ( CHECKLEN ( ret , 5 , limit ) ) return NULL ; s2n ( TLSEXT_TYPE_heartbeat , ret ) ; s2n ( 1 , ret ) ; if ( s -> tlsext_heartbeat & SSL_DTLSEXT_HB_DONT_RECV_REQUESTS ) * ( ret ++ ) = SSL_DTLSEXT_HB_DONT_SEND_REQUESTS ; else * ( ret ++ ) = SSL_DTLSEXT_HB_ENABLED ; } # endif # ifndef OPENSSL_NO_NEXTPROTONEG next_proto_neg_seen = s -> s3 -> next_proto_neg_seen ; s -> s3 -> next_proto_neg_seen = 0 ; if ( next_proto_neg_seen && s -> ctx -> next_protos_advertised_cb ) { const unsigned char * npa ; unsigned int npalen ; int r ; r = s -> ctx -> next_protos_advertised_cb ( s , & npa , & npalen , s -> ctx -> next_protos_advertised_cb_arg ) ; if ( r == SSL_TLSEXT_ERR_OK ) { if ( CHECKLEN ( ret , 4 + npalen , limit ) ) return NULL ; s2n ( TLSEXT_TYPE_next_proto_neg , ret ) ; s2n ( npalen , ret ) ; memcpy ( ret , npa , npalen ) ; ret += npalen ; s -> s3 -> next_proto_neg_seen = 1 ; } } # endif if ( ! custom_ext_add ( s , 1 , & ret , limit , al ) ) return NULL ; <S2SV_StartBug> if ( s -> s3 -> flags & TLS1_FLAGS_ENCRYPT_THEN_MAC ) { <S2SV_EndBug> if ( SSL_IS_DTLS ( s ) || s -> s3 -> tmp . new_cipher -> algorithm_mac == SSL_AEAD || s -> s3 -> tmp . new_cipher -> algorithm_enc == SSL_RC4 || s -> s3 -> tmp . new_cipher -> algorithm_enc == SSL_eGOST2814789CNT || s -> s3 -> tmp . new_cipher -> algorithm_enc == SSL_eGOST2814789CNT12 ) <S2SV_StartBug> s -> s3 -> flags &= ~ TLS1_FLAGS_ENCRYPT_THEN_MAC ; <S2SV_EndBug> else { if ( CHECKLEN ( ret , 4 , limit ) ) return NULL ; s2n ( TLSEXT_TYPE_encrypt_then_mac , ret ) ; s2n ( 0 , ret ) ; } } if ( s -> s3 -> flags & TLS1_FLAGS_RECEIVED_EXTMS ) { if ( CHECKLEN ( ret , 4 , limit ) ) return NULL ; s2n ( TLSEXT_TYPE_extended_master_secret , ret ) ; s2n ( 0 , ret ) ; } if ( s -> s3 -> alpn_selected != NULL ) { const unsigned char * selected = s -> s3 -> alpn_selected ; size_t len = s -> s3 -> alpn_selected_len ; if ( CHECKLEN ( ret , 7 + len , limit ) ) return NULL ; s2n ( TLSEXT_TYPE_application_layer_protocol_negotiation , ret ) ; s2n ( 3 + len , ret ) ; s2n ( 1 + len , ret ) ; * ret ++ = len ; memcpy ( ret , selected , len ) ; ret += len ; } done : if ( ( extdatalen = ret - orig - 2 ) == 0 ) return orig ; s2n ( extdatalen , orig ) ; return ret ; }",( s -> tlsext_use_etm <S2SV_ModEnd> ) { if <S2SV_ModStart> ) s -> tlsext_use_etm = 0 <S2SV_ModEnd> ; else {
157,"static unsigned int block_variance ( VP9_COMP * cpi , MACROBLOCK * x , BLOCK_SIZE bs ) { MACROBLOCKD * xd = & x -> e_mbd ; unsigned int var , sse ; int right_overflow = ( xd -> mb_to_right_edge < 0 ) ? ( ( - xd -> mb_to_right_edge ) >> 3 ) : 0 ; int bottom_overflow = ( xd -> mb_to_bottom_edge < 0 ) ? ( ( - xd -> mb_to_bottom_edge ) >> 3 ) : 0 ; if ( right_overflow || bottom_overflow ) { const int bw = 8 * num_8x8_blocks_wide_lookup [ bs ] - right_overflow ; const int bh = 8 * num_8x8_blocks_high_lookup [ bs ] - bottom_overflow ; int avg ; <S2SV_StartBug> variance ( x -> plane [ 0 ] . src . buf , x -> plane [ 0 ] . src . stride , <S2SV_EndBug> <S2SV_StartBug> vp9_64_zeros , 0 , bw , bh , & sse , & avg ) ; <S2SV_EndBug> <S2SV_StartBug> var = sse - ( ( ( int64_t ) avg * avg ) / ( bw * bh ) ) ; <S2SV_EndBug> return ( 256 * var ) / ( bw * bh ) ; } else { <S2SV_StartBug> var = cpi -> fn_ptr [ bs ] . vf ( x -> plane [ 0 ] . src . buf , <S2SV_EndBug> x -> plane [ 0 ] . src . stride , <S2SV_StartBug> vp9_64_zeros , 0 , & sse ) ; <S2SV_EndBug> return ( 256 * var ) >> num_pels_log2_lookup [ bs ] ; } }","int avg ; # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { aq_highbd_8_variance <S2SV_ModEnd> ( x -> <S2SV_ModStart> . stride , CONVERT_TO_BYTEPTR ( vp9_highbd_64_zeros ) , 0 , bw , bh , & sse , & avg ) ; sse >>= 2 * ( xd -> bd - 8 ) ; avg >>= ( xd -> bd - 8 ) ; } else { aq_variance ( x -> plane [ 0 ] . src . buf , x -> plane [ 0 ] . src . stride , <S2SV_ModStart> avg ) ; } # else aq_variance ( x -> plane [ 0 ] . src . buf , x -> plane [ 0 ] . src . stride , vp9_64_zeros , 0 , bw , bh , & sse , & avg ) ; # endif <S2SV_ModStart> } else { # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { <S2SV_ModStart> . stride , CONVERT_TO_BYTEPTR ( vp9_highbd_64_zeros ) , 0 , & sse ) ; } else { var = cpi -> fn_ptr [ bs ] . vf ( x -> plane [ 0 ] . src . buf , x -> plane [ 0 ] . src . stride , <S2SV_ModStart> sse ) ; } # else var = cpi -> fn_ptr [ bs ] . vf ( x -> plane [ 0 ] . src . buf , x -> plane [ 0 ] . src . stride , vp9_64_zeros , 0 , & sse ) ; # endif"
158,"void color_cmyk_to_rgb ( opj_image_t * image ) { float C , M , Y , K ; float sC , sM , sY , sK ; unsigned int w , h , max , i ; w = image -> comps [ 0 ] . w ; h = image -> comps [ 0 ] . h ; <S2SV_StartBug> if ( image -> numcomps < 4 ) return ; <S2SV_EndBug> max = w * h ; sC = 1.0F / ( float ) ( ( 1 << image -> comps [ 0 ] . prec ) - 1 ) ; sM = 1.0F / ( float ) ( ( 1 << image -> comps [ 1 ] . prec ) - 1 ) ; sY = 1.0F / ( float ) ( ( 1 << image -> comps [ 2 ] . prec ) - 1 ) ; sK = 1.0F / ( float ) ( ( 1 << image -> comps [ 3 ] . prec ) - 1 ) ; for ( i = 0 ; i < max ; ++ i ) { C = ( float ) ( image -> comps [ 0 ] . data [ i ] ) * sC ; M = ( float ) ( image -> comps [ 1 ] . data [ i ] ) * sM ; Y = ( float ) ( image -> comps [ 2 ] . data [ i ] ) * sY ; K = ( float ) ( image -> comps [ 3 ] . data [ i ] ) * sK ; C = 1.0F - C ; M = 1.0F - M ; Y = 1.0F - Y ; K = 1.0F - K ; image -> comps [ 0 ] . data [ i ] = ( int ) ( 255.0F * C * K ) ; image -> comps [ 1 ] . data [ i ] = ( int ) ( 255.0F * M * K ) ; image -> comps [ 2 ] . data [ i ] = ( int ) ( 255.0F * Y * K ) ; } free ( image -> comps [ 3 ] . data ) ; image -> comps [ 3 ] . data = NULL ; image -> comps [ 0 ] . prec = 8 ; image -> comps [ 1 ] . prec = 8 ; image -> comps [ 2 ] . prec = 8 ; image -> numcomps -= 1 ; image -> color_space = OPJ_CLRSPC_SRGB ; for ( i = 3 ; i < image -> numcomps ; ++ i ) { memcpy ( & ( image -> comps [ i ] ) , & ( image -> comps [ i + 1 ] ) , sizeof ( image -> comps [ i ] ) ) ; } }","; if ( ( <S2SV_ModStart> < 4 ) || ( image -> comps [ 0 ] . dx != image -> comps [ 1 ] . dx ) || ( image -> comps [ 0 ] . dx != image -> comps [ 2 ] . dx ) || ( image -> comps [ 0 ] . dx != image -> comps [ 3 ] . dx ) || ( image -> comps [ 0 ] . dy != image -> comps [ 1 ] . dy ) || ( image -> comps [ 0 ] . dy != image -> comps [ 2 ] . dy ) || ( image -> comps [ 0 ] . dy != image -> comps [ 3 ] . dy ) ) { fprintf ( stderr , ""%s:%d:color_cmyk_to_rgb\\n\\tCAN<S2SV_blank>NOT<S2SV_blank>CONVERT\\n"" , __FILE__ , __LINE__ ) ; return ; } <S2SV_ModEnd> max = w"
159,"int dccp_rcv_state_process ( struct sock * sk , struct sk_buff * skb , struct dccp_hdr * dh , unsigned int len ) { struct dccp_sock * dp = dccp_sk ( sk ) ; struct dccp_skb_cb * dcb = DCCP_SKB_CB ( skb ) ; const int old_state = sk -> sk_state ; int queued = 0 ; if ( sk -> sk_state == DCCP_LISTEN ) { if ( dh -> dccph_type == DCCP_PKT_REQUEST ) { if ( inet_csk ( sk ) -> icsk_af_ops -> conn_request ( sk , skb ) < 0 ) return 1 ; <S2SV_StartBug> goto discard ; <S2SV_EndBug> } if ( dh -> dccph_type == DCCP_PKT_RESET ) goto discard ; dcb -> dccpd_reset_code = DCCP_RESET_CODE_NO_CONNECTION ; return 1 ; } else if ( sk -> sk_state == DCCP_CLOSED ) { dcb -> dccpd_reset_code = DCCP_RESET_CODE_NO_CONNECTION ; return 1 ; } if ( sk -> sk_state != DCCP_REQUESTING && dccp_check_seqno ( sk , skb ) ) goto discard ; if ( ( dp -> dccps_role != DCCP_ROLE_CLIENT && dh -> dccph_type == DCCP_PKT_RESPONSE ) || ( dp -> dccps_role == DCCP_ROLE_CLIENT && dh -> dccph_type == DCCP_PKT_REQUEST ) || ( sk -> sk_state == DCCP_RESPOND && dh -> dccph_type == DCCP_PKT_DATA ) ) { dccp_send_sync ( sk , dcb -> dccpd_seq , DCCP_PKT_SYNC ) ; goto discard ; } if ( dccp_parse_options ( sk , NULL , skb ) ) return 1 ; if ( dh -> dccph_type == DCCP_PKT_RESET ) { dccp_rcv_reset ( sk , skb ) ; return 0 ; } else if ( dh -> dccph_type == DCCP_PKT_CLOSEREQ ) { if ( dccp_rcv_closereq ( sk , skb ) ) return 0 ; goto discard ; } else if ( dh -> dccph_type == DCCP_PKT_CLOSE ) { if ( dccp_rcv_close ( sk , skb ) ) return 0 ; goto discard ; } switch ( sk -> sk_state ) { case DCCP_REQUESTING : queued = dccp_rcv_request_sent_state_process ( sk , skb , dh , len ) ; if ( queued >= 0 ) return queued ; __kfree_skb ( skb ) ; return 0 ; case DCCP_PARTOPEN : dccp_handle_ackvec_processing ( sk , skb ) ; dccp_deliver_input_to_ccids ( sk , skb ) ; case DCCP_RESPOND : queued = dccp_rcv_respond_partopen_state_process ( sk , skb , dh , len ) ; break ; } if ( dh -> dccph_type == DCCP_PKT_ACK || dh -> dccph_type == DCCP_PKT_DATAACK ) { switch ( old_state ) { case DCCP_PARTOPEN : sk -> sk_state_change ( sk ) ; sk_wake_async ( sk , SOCK_WAKE_IO , POLL_OUT ) ; break ; } } else if ( unlikely ( dh -> dccph_type == DCCP_PKT_SYNC ) ) { dccp_send_sync ( sk , dcb -> dccpd_seq , DCCP_PKT_SYNCACK ) ; goto discard ; } if ( ! queued ) { discard : __kfree_skb ( skb ) ; } return 0 ; }",return 1 ; consume_skb ( skb ) ; return 0 <S2SV_ModEnd> ; } if
160,"static MagickBooleanType ReadPSDLayersInternal ( Image * image , const ImageInfo * image_info , const PSDInfo * psd_info , const MagickBooleanType skip_layers , ExceptionInfo * exception ) { char type [ 4 ] ; LayerInfo * layer_info ; MagickSizeType size ; MagickBooleanType status ; register ssize_t i ; ssize_t count , j , number_layers ; size = GetPSDSize ( psd_info , image ) ; if ( size == 0 ) { ( void ) ReadBlobLong ( image ) ; count = ReadBlob ( image , 4 , ( unsigned char * ) type ) ; ReversePSDString ( image , type , 4 ) ; status = MagickFalse ; if ( ( count == 0 ) || ( LocaleNCompare ( type , ""8BIM"" , 4 ) != 0 ) ) return ( MagickTrue ) ; else { count = ReadBlob ( image , 4 , ( unsigned char * ) type ) ; ReversePSDString ( image , type , 4 ) ; if ( ( count != 0 ) && ( LocaleNCompare ( type , ""Lr16"" , 4 ) == 0 ) ) size = GetPSDSize ( psd_info , image ) ; else return ( MagickTrue ) ; } } status = MagickTrue ; if ( size != 0 ) { layer_info = ( LayerInfo * ) NULL ; number_layers = ( short ) ReadBlobShort ( image ) ; if ( number_layers < 0 ) { number_layers = MagickAbsoluteValue ( number_layers ) ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>negative<S2SV_blank>layer<S2SV_blank>count<S2SV_blank>corrected<S2SV_blank>for"" ) ; image -> alpha_trait = BlendPixelTrait ; } if ( skip_layers != MagickFalse ) return ( MagickTrue ) ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>image<S2SV_blank>contains<S2SV_blank>%.20g<S2SV_blank>layers"" , ( double ) number_layers ) ; if ( number_layers == 0 ) ThrowBinaryException ( CorruptImageError , ""InvalidNumberOfLayers"" , image -> filename ) ; layer_info = ( LayerInfo * ) AcquireQuantumMemory ( ( size_t ) number_layers , sizeof ( * layer_info ) ) ; if ( layer_info == ( LayerInfo * ) NULL ) { if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>allocation<S2SV_blank>of<S2SV_blank>LayerInfo<S2SV_blank>failed"" ) ; ThrowBinaryException ( ResourceLimitError , ""MemoryAllocationFailed"" , image -> filename ) ; } ( void ) ResetMagickMemory ( layer_info , 0 , ( size_t ) number_layers * sizeof ( * layer_info ) ) ; for ( i = 0 ; i < number_layers ; i ++ ) { ssize_t x , y ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>reading<S2SV_blank>layer<S2SV_blank>#%.20g"" , ( double ) i + 1 ) ; layer_info [ i ] . page . y = ReadBlobSignedLong ( image ) ; layer_info [ i ] . page . x = ReadBlobSignedLong ( image ) ; y = ReadBlobSignedLong ( image ) ; x = ReadBlobSignedLong ( image ) ; layer_info [ i ] . page . width = ( size_t ) ( x - layer_info [ i ] . page . x ) ; layer_info [ i ] . page . height = ( size_t ) ( y - layer_info [ i ] . page . y ) ; layer_info [ i ] . channels = ReadBlobShort ( image ) ; if ( layer_info [ i ] . channels > MaxPSDChannels ) { layer_info = DestroyLayerInfo ( layer_info , number_layers ) ; ThrowBinaryException ( CorruptImageError , ""MaximumChannelsExceeded"" , image -> filename ) ; } if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>offset(%.20g,%.20g),<S2SV_blank>size(%.20g,%.20g),<S2SV_blank>channels=%.20g"" , ( double ) layer_info [ i ] . page . x , ( double ) layer_info [ i ] . page . y , ( double ) layer_info [ i ] . page . height , ( double ) layer_info [ i ] . page . width , ( double ) layer_info [ i ] . channels ) ; for ( j = 0 ; j < ( ssize_t ) layer_info [ i ] . channels ; j ++ ) { layer_info [ i ] . channel_info [ j ] . type = ( short ) ReadBlobShort ( image ) ; layer_info [ i ] . channel_info [ j ] . size = ( size_t ) GetPSDSize ( psd_info , image ) ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>channel[%.20g]:<S2SV_blank>type=%.20g,<S2SV_blank>size=%.20g"" , ( double ) j , ( double ) layer_info [ i ] . channel_info [ j ] . type , ( double ) layer_info [ i ] . channel_info [ j ] . size ) ; } count = ReadBlob ( image , 4 , ( unsigned char * ) type ) ; ReversePSDString ( image , type , 4 ) ; if ( ( count == 0 ) || ( LocaleNCompare ( type , ""8BIM"" , 4 ) != 0 ) ) { if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>layer<S2SV_blank>type<S2SV_blank>was<S2SV_blank>%.4s<S2SV_blank>instead<S2SV_blank>of<S2SV_blank>8BIM"" , type ) ; layer_info = DestroyLayerInfo ( layer_info , number_layers ) ; ThrowBinaryException ( CorruptImageError , ""ImproperImageHeader"" , image -> filename ) ; } count = ReadBlob ( image , 4 , ( unsigned char * ) layer_info [ i ] . blendkey ) ; ReversePSDString ( image , layer_info [ i ] . blendkey , 4 ) ; layer_info [ i ] . opacity = ( Quantum ) ScaleCharToQuantum ( ( unsigned char ) ReadBlobByte ( image ) ) ; layer_info [ i ] . clipping = ( unsigned char ) ReadBlobByte ( image ) ; layer_info [ i ] . flags = ( unsigned char ) ReadBlobByte ( image ) ; layer_info [ i ] . visible = ! ( layer_info [ i ] . flags & 0x02 ) ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank><S2SV_blank>blend=%.4s,<S2SV_blank>opacity=%.20g,<S2SV_blank>clipping=%s,<S2SV_blank>flags=%d,<S2SV_blank>visible=%s"" , layer_info [ i ] . blendkey , ( double ) layer_info [ i ] . opacity , layer_info [ i ] . clipping ? ""true"" : ""false"" , layer_info [ i ] . flags , layer_info [ i ] . visible ? ""true"" : ""false"" ) ; ( void ) ReadBlobByte ( image ) ; size = ReadBlobLong ( image ) ; if ( size != 0 ) { MagickSizeType combined_length , length ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>layer<S2SV_blank>contains<S2SV_blank>additional<S2SV_blank>info"" ) ; length = ReadBlobLong ( image ) ; combined_length = length + 4 ; if ( length != 0 ) { layer_info [ i ] . mask . page . y = ReadBlobSignedLong ( image ) ; layer_info [ i ] . mask . page . x = ReadBlobSignedLong ( image ) ; layer_info [ i ] . mask . page . height = ( size_t ) ( ReadBlobSignedLong ( image ) - layer_info [ i ] . mask . page . y ) ; layer_info [ i ] . mask . page . width = ( size_t ) ( ReadBlobSignedLong ( image ) - layer_info [ i ] . mask . page . x ) ; layer_info [ i ] . mask . background = ( unsigned char ) ReadBlobByte ( image ) ; layer_info [ i ] . mask . flags = ( unsigned char ) ReadBlobByte ( image ) ; if ( ! ( layer_info [ i ] . mask . flags & 0x01 ) ) { layer_info [ i ] . mask . page . y = layer_info [ i ] . mask . page . y - layer_info [ i ] . page . y ; layer_info [ i ] . mask . page . x = layer_info [ i ] . mask . page . x - layer_info [ i ] . page . x ; } if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>layer<S2SV_blank>mask:<S2SV_blank>offset(%.20g,%.20g),<S2SV_blank>size(%.20g,%.20g),<S2SV_blank>length=%.20g"" , ( double ) layer_info [ i ] . mask . page . x , ( double ) layer_info [ i ] . mask . page . y , ( double ) layer_info [ i ] . mask . page . width , ( double ) layer_info [ i ] . mask . page . height , ( double ) ( ( MagickOffsetType ) length ) - 18 ) ; if ( DiscardBlobBytes ( image , ( MagickSizeType ) ( length - 18 ) ) == MagickFalse ) { layer_info = DestroyLayerInfo ( layer_info , number_layers ) ; ThrowBinaryException ( CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; } } length = ReadBlobLong ( image ) ; combined_length += length + 4 ; if ( length != 0 ) { if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>layer<S2SV_blank>blending<S2SV_blank>ranges:<S2SV_blank>length=%.20g"" , ( double ) ( ( MagickOffsetType ) length ) ) ; <S2SV_StartBug> for ( j = 0 ; j < ( ssize_t ) length ; j += 8 ) <S2SV_EndBug> { size_t blend_source = ReadBlobLong ( image ) ; size_t blend_dest = ReadBlobLong ( image ) ; if ( EOFBlob ( image ) != MagickFalse ) { layer_info = DestroyLayerInfo ( layer_info , number_layers ) ; ThrowBinaryException ( CorruptImageError , <S2SV_StartBug> ""InsufficientImageDataInFile"" , image -> filename ) ; <S2SV_EndBug> } if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>source(%x),<S2SV_blank>dest(%x)"" , ( unsigned int ) blend_source , ( unsigned int ) blend_dest ) ; } } length = ( MagickSizeType ) ( unsigned char ) ReadBlobByte ( image ) ; combined_length += length + 1 ; if ( length > 0 ) ( void ) ReadBlob ( image , ( size_t ) length ++ , layer_info [ i ] . name ) ; layer_info [ i ] . name [ length ] = '\\0' ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>layer<S2SV_blank>name:<S2SV_blank>%s"" , layer_info [ i ] . name ) ; if ( ( length % 4 ) != 0 ) { length = 4 - ( length % 4 ) ; combined_length += length ; if ( DiscardBlobBytes ( image , length ) == MagickFalse ) { layer_info = DestroyLayerInfo ( layer_info , number_layers ) ; ThrowBinaryException ( CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; } } length = ( MagickSizeType ) size - combined_length ; if ( length > 0 ) { unsigned char * info ; if ( length > GetBlobSize ( image ) ) { layer_info = DestroyLayerInfo ( layer_info , number_layers ) ; ThrowBinaryException ( CorruptImageError , ""InsufficientImageDataInFile"" , image -> filename ) ; } layer_info [ i ] . info = AcquireStringInfo ( ( const size_t ) length ) ; info = GetStringInfoDatum ( layer_info [ i ] . info ) ; ( void ) ReadBlob ( image , ( const size_t ) length , info ) ; } } } for ( i = 0 ; i < number_layers ; i ++ ) { if ( ( layer_info [ i ] . page . width == 0 ) || ( layer_info [ i ] . page . height == 0 ) ) { if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>layer<S2SV_blank>data<S2SV_blank>is<S2SV_blank>empty"" ) ; if ( layer_info [ i ] . info != ( StringInfo * ) NULL ) layer_info [ i ] . info = DestroyStringInfo ( layer_info [ i ] . info ) ; continue ; } layer_info [ i ] . image = CloneImage ( image , layer_info [ i ] . page . width , layer_info [ i ] . page . height , MagickFalse , exception ) ; if ( layer_info [ i ] . image == ( Image * ) NULL ) { layer_info = DestroyLayerInfo ( layer_info , number_layers ) ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>allocation<S2SV_blank>of<S2SV_blank>image<S2SV_blank>for<S2SV_blank>layer<S2SV_blank>%.20g<S2SV_blank>failed"" , ( double ) i ) ; ThrowBinaryException ( ResourceLimitError , ""MemoryAllocationFailed"" , image -> filename ) ; } if ( layer_info [ i ] . info != ( StringInfo * ) NULL ) { ( void ) SetImageProfile ( layer_info [ i ] . image , ""psd:additional-info"" , layer_info [ i ] . info , exception ) ; layer_info [ i ] . info = DestroyStringInfo ( layer_info [ i ] . info ) ; } } if ( image_info -> ping == MagickFalse ) { for ( i = 0 ; i < number_layers ; i ++ ) { if ( layer_info [ i ] . image == ( Image * ) NULL ) { for ( j = 0 ; j < layer_info [ i ] . channels ; j ++ ) { if ( DiscardBlobBytes ( image , ( MagickSizeType ) layer_info [ i ] . channel_info [ j ] . size ) == MagickFalse ) { layer_info = DestroyLayerInfo ( layer_info , number_layers ) ; ThrowBinaryException ( CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; } } continue ; } if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>reading<S2SV_blank>data<S2SV_blank>for<S2SV_blank>layer<S2SV_blank>%.20g"" , ( double ) i ) ; status = ReadPSDLayer ( image , image_info , psd_info , & layer_info [ i ] , exception ) ; if ( status == MagickFalse ) break ; status = SetImageProgress ( image , LoadImagesTag , i , ( MagickSizeType ) number_layers ) ; if ( status == MagickFalse ) break ; } } if ( status != MagickFalse ) { for ( i = 0 ; i < number_layers ; i ++ ) { if ( layer_info [ i ] . image == ( Image * ) NULL ) { for ( j = i ; j < number_layers - 1 ; j ++ ) layer_info [ j ] = layer_info [ j + 1 ] ; number_layers -- ; i -- ; } } if ( number_layers > 0 ) { for ( i = 0 ; i < number_layers ; i ++ ) { if ( i > 0 ) layer_info [ i ] . image -> previous = layer_info [ i - 1 ] . image ; if ( i < ( number_layers - 1 ) ) layer_info [ i ] . image -> next = layer_info [ i + 1 ] . image ; layer_info [ i ] . image -> page = layer_info [ i ] . page ; } image -> next = layer_info [ 0 ] . image ; layer_info [ 0 ] . image -> previous = image ; } layer_info = ( LayerInfo * ) RelinquishMagickMemory ( layer_info ) ; } else layer_info = DestroyLayerInfo ( layer_info , number_layers ) ; } return ( status ) ; }",") ) ; if ( DiscardBlobBytes ( image , length ) == <S2SV_ModEnd> MagickFalse ) { <S2SV_ModStart> ( CorruptImageError , ""UnexpectedEndOfFile"" <S2SV_ModEnd> , image -> <S2SV_ModStart> image -> filename <S2SV_ModEnd> ) ; }"
161,"<S2SV_StartBug> static PixelChannels * * AcquirePixelThreadSet ( const Image * image ) <S2SV_EndBug> { PixelChannels * * pixels ; register ssize_t i ; size_t <S2SV_StartBug> number_threads ; <S2SV_EndBug> number_threads = ( size_t ) GetMagickResourceLimit ( ThreadResource ) ; pixels = ( PixelChannels * * ) AcquireQuantumMemory ( number_threads , sizeof ( * pixels ) ) ; if ( pixels == ( PixelChannels * * ) NULL ) return ( ( PixelChannels * * ) NULL ) ; ( void ) memset ( pixels , 0 , number_threads * sizeof ( * pixels ) ) ; <S2SV_StartBug> for ( i = 0 ; i < ( ssize_t ) number_threads ; i ++ ) <S2SV_EndBug> { register ssize_t j ; <S2SV_StartBug> pixels [ i ] = ( PixelChannels * ) AcquireQuantumMemory ( image -> columns , <S2SV_EndBug> sizeof ( * * pixels ) ) ; if ( pixels [ i ] == ( PixelChannels * ) NULL ) return ( DestroyPixelThreadSet ( pixels ) ) ; <S2SV_StartBug> for ( j = 0 ; j < ( ssize_t ) image -> columns ; j ++ ) <S2SV_EndBug> { register ssize_t k ; for ( k = 0 ; k < MaxPixelChannels ; k ++ ) pixels [ i ] [ j ] . channel [ k ] = 0.0 ; } } return ( pixels ) ; }","const Image * images ) { const Image * next ; <S2SV_ModEnd> PixelChannels * * <S2SV_ModStart> i ; size_t columns , <S2SV_ModStart> ) ) ; columns = images -> columns ; for ( next = images ; next != ( Image * ) NULL ; next = next -> next ) columns = MagickMax ( next -> columns , columns ) ; <S2SV_ModStart> ) AcquireQuantumMemory ( columns , <S2SV_ModEnd> sizeof ( * <S2SV_ModStart> ( ssize_t ) <S2SV_ModEnd> columns ; j"
162,"static int handle_keywordonly_args ( struct compiling * c , const node * n , int start , asdl_seq * kwonlyargs , asdl_seq * kwdefaults ) { PyObject * argname ; node * ch ; expr_ty expression , annotation ; arg_ty arg ; int i = start ; int j = 0 ; if ( kwonlyargs == NULL ) { ast_error ( c , CHILD ( n , start ) , ""named<S2SV_blank>arguments<S2SV_blank>must<S2SV_blank>follow<S2SV_blank>bare<S2SV_blank>*"" ) ; return - 1 ; } assert ( kwdefaults != NULL ) ; while ( i < NCH ( n ) ) { ch = CHILD ( n , i ) ; switch ( TYPE ( ch ) ) { case vfpdef : case tfpdef : if ( i + 1 < NCH ( n ) && TYPE ( CHILD ( n , i + 1 ) ) == EQUAL ) { expression = ast_for_expr ( c , CHILD ( n , i + 2 ) ) ; if ( ! expression ) goto error ; asdl_seq_SET ( kwdefaults , j , expression ) ; i += 2 ; } else { asdl_seq_SET ( kwdefaults , j , NULL ) ; } if ( NCH ( ch ) == 3 ) { annotation = ast_for_expr ( c , CHILD ( ch , 2 ) ) ; if ( ! annotation ) goto error ; } else { annotation = NULL ; } ch = CHILD ( ch , 0 ) ; argname = NEW_IDENTIFIER ( ch ) ; if ( ! argname ) goto error ; if ( forbidden_name ( c , argname , ch , 0 ) ) goto error ; arg = arg ( argname , annotation , NULL , LINENO ( ch ) , ch -> n_col_offset , c -> c_arena ) ; if ( ! arg ) goto error ; asdl_seq_SET ( kwonlyargs , j ++ , arg ) ; i += 1 ; <S2SV_StartBug> if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == COMMA ) <S2SV_EndBug> i += 1 ; break ; case TYPE_COMMENT : arg -> type_comment = NEW_TYPE_COMMENT ( ch ) ; i += 1 ; break ; case DOUBLESTAR : return i ; default : ast_error ( c , ch , ""unexpected<S2SV_blank>node"" ) ; goto error ; } } return i ; error : return - 1 ; }",; if ( <S2SV_ModEnd> TYPE ( CHILD
163,"static const ut8 * r_bin_dwarf_parse_comp_unit ( Sdb * s , const ut8 * obuf , RBinDwarfCompUnit * cu , const RBinDwarfDebugAbbrev * da , size_t offset , const ut8 * debug_str , size_t debug_str_len ) { const ut8 * buf = obuf , * buf_end = obuf + ( cu -> hdr . length - 7 ) ; ut64 abbr_code ; size_t i ; if ( cu -> hdr . length > debug_str_len ) { return NULL ; } while ( buf && buf < buf_end && buf >= obuf ) { if ( cu -> length && cu -> capacity == cu -> length ) { r_bin_dwarf_expand_cu ( cu ) ; } buf = r_uleb128 ( buf , buf_end - buf , & abbr_code ) ; if ( abbr_code > da -> length || ! buf ) { return NULL ; } r_bin_dwarf_init_die ( & cu -> dies [ cu -> length ] ) ; if ( ! abbr_code ) { cu -> dies [ cu -> length ] . abbrev_code = 0 ; cu -> length ++ ; buf ++ ; continue ; } cu -> dies [ cu -> length ] . abbrev_code = abbr_code ; cu -> dies [ cu -> length ] . tag = da -> decls [ abbr_code - 1 ] . tag ; abbr_code += offset ; if ( da -> capacity < abbr_code ) { return NULL ; } for ( i = 0 ; i < da -> decls [ abbr_code - 1 ] . length ; i ++ ) { if ( cu -> dies [ cu -> length ] . length == cu -> dies [ cu -> length ] . capacity ) { r_bin_dwarf_expand_die ( & cu -> dies [ cu -> length ] ) ; } if ( i >= cu -> dies [ cu -> length ] . capacity || i >= da -> decls [ abbr_code - 1 ] . capacity ) { eprintf ( ""Warning:<S2SV_blank>malformed<S2SV_blank>dwarf<S2SV_blank>attribute<S2SV_blank>capacity<S2SV_blank>doesn\'t<S2SV_blank>match<S2SV_blank>length\\n"" ) ; break ; } memset ( & cu -> dies [ cu -> length ] . attr_values [ i ] , 0 , sizeof ( cu -> dies [ cu -> length ] . attr_values [ i ] ) ) ; buf = r_bin_dwarf_parse_attr_value ( buf , buf_end - buf , & da -> decls [ abbr_code - 1 ] . specs [ i ] , & cu -> dies [ cu -> length ] . attr_values [ i ] , & cu -> hdr , debug_str , debug_str_len ) ; if ( cu -> dies [ cu -> length ] . attr_values [ i ] . name == DW_AT_comp_dir ) { const char * name = cu -> dies [ cu -> length ] . attr_values [ i ] . encoding . str_struct . string ; sdb_set ( s , ""DW_AT_comp_dir"" , name , 0 ) ; } cu -> dies [ cu -> length ] . length ++ ; } cu -> length ++ ; } return buf ; }","
"
164,"static void model_rd_for_sb_y ( VP9_COMP * cpi , BLOCK_SIZE bsize , MACROBLOCK * x , MACROBLOCKD * xd , <S2SV_StartBug> int * out_rate_sum , int64_t * out_dist_sum ) { <S2SV_EndBug> unsigned int sse ; int rate ; int64_t dist ; struct macroblock_plane * const p = & x -> plane [ 0 ] ; struct macroblockd_plane * const pd = & xd -> plane [ 0 ] ; <S2SV_StartBug> int var = cpi -> fn_ptr [ bsize ] . vf ( p -> src . buf , p -> src . stride , <S2SV_EndBug> pd -> dst . buf , pd -> dst . stride , & sse ) ; <S2SV_StartBug> vp9_model_rd_from_var_lapndz ( sse + var , 1 << num_pels_log2_lookup [ bsize ] , <S2SV_EndBug> pd -> dequant [ 1 ] >> 3 , & rate , & dist ) ; * out_rate_sum = rate ; * out_dist_sum = dist << 3 ; <S2SV_StartBug> } <S2SV_EndBug>","int64_t * out_dist_sum , unsigned int * var_y , unsigned int * sse_y <S2SV_ModStart> 0 ] ; const int64_t dc_thr = p -> quant_thred [ 0 ] >> 6 ; const int64_t ac_thr = p -> quant_thred [ 1 ] >> 6 ; const uint32_t dc_quant = pd -> dequant [ 0 ] ; const uint32_t ac_quant = pd -> dequant [ 1 ] ; unsigned <S2SV_ModStart> sse ) ; int skip_dc = 0 ; * var_y = var ; * sse_y = sse ; if ( cpi -> common . tx_mode == TX_MODE_SELECT ) { if ( sse > ( var << 2 ) ) xd -> mi [ 0 ] -> mbmi . tx_size = MIN ( max_txsize_lookup [ bsize ] , tx_mode_to_biggest_tx_size [ cpi -> common . tx_mode ] ) ; else xd -> mi [ 0 ] -> mbmi . tx_size = TX_8X8 ; if ( cpi -> oxcf . aq_mode == CYCLIC_REFRESH_AQ && cyclic_refresh_segment_id_boosted ( xd -> mi [ 0 ] -> mbmi . segment_id ) ) xd -> mi [ 0 ] -> mbmi . tx_size = TX_8X8 ; else if ( xd -> mi [ 0 ] -> mbmi . tx_size > TX_16X16 ) xd -> mi [ 0 ] -> mbmi . tx_size = TX_16X16 ; } else { xd -> mi [ 0 ] -> mbmi . tx_size = MIN ( max_txsize_lookup [ bsize ] , tx_mode_to_biggest_tx_size [ cpi -> common . tx_mode ] ) ; } { const BLOCK_SIZE unit_size = txsize_to_bsize [ xd -> mi [ 0 ] -> mbmi . tx_size ] ; const unsigned int num_blk_log2 = ( b_width_log2_lookup [ bsize ] - b_width_log2_lookup [ unit_size ] ) + ( b_height_log2_lookup [ bsize ] - b_height_log2_lookup [ unit_size ] ) ; const unsigned int sse_tx = sse >> num_blk_log2 ; const unsigned int var_tx = var >> num_blk_log2 ; x -> skip_txfm [ 0 ] = SKIP_TXFM_NONE ; if ( var_tx < ac_thr || var == 0 ) { x -> skip_txfm [ 0 ] = SKIP_TXFM_AC_ONLY ; if ( sse_tx - var_tx < dc_thr || sse == var ) x -> skip_txfm [ 0 ] = SKIP_TXFM_AC_DC ; } else { if ( sse_tx - var_tx < dc_thr || sse == var ) skip_dc = 1 ; } } if ( x -> skip_txfm [ 0 ] == SKIP_TXFM_AC_DC ) { * out_rate_sum = 0 ; * out_dist_sum = sse << 4 ; return ; } if ( ! skip_dc ) { # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { <S2SV_ModStart> vp9_model_rd_from_var_lapndz ( sse - var , num_pels_log2_lookup [ bsize ] , dc_quant >> ( xd -> bd - 5 ) , & rate , & dist ) ; } else { vp9_model_rd_from_var_lapndz ( sse - var , num_pels_log2_lookup [ bsize ] , dc_quant >> 3 , & rate , & dist ) ; } # else vp9_model_rd_from_var_lapndz ( sse - var , num_pels_log2_lookup [ bsize ] , dc_quant >> 3 , & rate , & dist ) ; # endif } if ( ! skip_dc ) { * out_rate_sum = rate >> 1 <S2SV_ModEnd> ; * out_dist_sum <S2SV_ModStart> 3 ; } else { * out_rate_sum = 0 ; * out_dist_sum = ( sse - var ) << 4 ; } # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { vp9_model_rd_from_var_lapndz ( var , num_pels_log2_lookup [ bsize ] , ac_quant >> ( xd -> bd - 5 ) , & rate , & dist ) ; } else { vp9_model_rd_from_var_lapndz ( var , num_pels_log2_lookup [ bsize ] , ac_quant >> 3 , & rate , & dist ) ; } # else vp9_model_rd_from_var_lapndz ( var , num_pels_log2_lookup [ bsize ] , ac_quant >> 3 , & rate , & dist ) ; # endif * out_rate_sum += rate ; * out_dist_sum += dist << 4 ; }"
165,"int vp8_full_search_sad_c ( MACROBLOCK * x , BLOCK * b , BLOCKD * d , int_mv * ref_mv , int sad_per_bit , int distance , vp8_variance_fn_ptr_t * fn_ptr , int * mvcost [ 2 ] , int_mv * center_mv ) { unsigned char * what = ( * ( b -> base_src ) + b -> src ) ; int what_stride = b -> src_stride ; unsigned char * in_what ; int pre_stride = x -> e_mbd . pre . y_stride ; unsigned char * base_pre = x -> e_mbd . pre . y_buffer ; int in_what_stride = pre_stride ; int mv_stride = pre_stride ; unsigned char * bestaddress ; int_mv * best_mv = & d -> bmi . mv ; int_mv this_mv ; unsigned int bestsad ; unsigned int thissad ; int r , c ; unsigned char * check_here ; int ref_row = ref_mv -> as_mv . row ; int ref_col = ref_mv -> as_mv . col ; int row_min = ref_row - distance ; int row_max = ref_row + distance ; int col_min = ref_col - distance ; int col_max = ref_col + distance ; int * mvsadcost [ 2 ] ; int_mv fcenter_mv ; mvsadcost [ 0 ] = x -> mvsadcost [ 0 ] ; mvsadcost [ 1 ] = x -> mvsadcost [ 1 ] ; fcenter_mv . as_mv . row = center_mv -> as_mv . row >> 3 ; fcenter_mv . as_mv . col = center_mv -> as_mv . col >> 3 ; in_what = base_pre + d -> offset ; bestaddress = in_what + ( ref_row * pre_stride ) + ref_col ; best_mv -> as_mv . row = ref_row ; best_mv -> as_mv . col = ref_col ; bestsad = fn_ptr -> sdf ( what , what_stride , bestaddress , <S2SV_StartBug> in_what_stride , UINT_MAX ) <S2SV_EndBug> + mvsad_err_cost ( best_mv , & fcenter_mv , mvsadcost , sad_per_bit ) ; if ( col_min < x -> mv_col_min ) col_min = x -> mv_col_min ; if ( col_max > x -> mv_col_max ) col_max = x -> mv_col_max ; if ( row_min < x -> mv_row_min ) row_min = x -> mv_row_min ; if ( row_max > x -> mv_row_max ) row_max = x -> mv_row_max ; for ( r = row_min ; r < row_max ; r ++ ) { this_mv . as_mv . row = r ; check_here = r * mv_stride + in_what + col_min ; for ( c = col_min ; c < col_max ; c ++ ) { <S2SV_StartBug> thissad = fn_ptr -> sdf ( what , what_stride , check_here , in_what_stride , bestsad ) ; <S2SV_EndBug> this_mv . as_mv . col = c ; thissad += mvsad_err_cost ( & this_mv , & fcenter_mv , mvsadcost , sad_per_bit ) ; if ( thissad < bestsad ) { bestsad = thissad ; best_mv -> as_mv . row = r ; best_mv -> as_mv . col = c ; bestaddress = check_here ; } check_here ++ ; } } this_mv . as_mv . row = best_mv -> as_mv . row << 3 ; this_mv . as_mv . col = best_mv -> as_mv . col << 3 ; return fn_ptr -> vf ( what , what_stride , bestaddress , in_what_stride , & thissad ) + mv_err_cost ( & this_mv , center_mv , mvcost , x -> errorperbit ) ; }","bestaddress , in_what_stride <S2SV_ModEnd> ) + mvsad_err_cost <S2SV_ModStart> check_here , in_what_stride <S2SV_ModEnd> ) ; this_mv"
166,"static xmlChar * xmlParseAttValueComplex ( xmlParserCtxtPtr ctxt , int * attlen , int normalize ) { xmlChar limit = 0 ; xmlChar * buf = NULL ; xmlChar * rep = NULL ; int len = 0 ; int buf_size = 0 ; int c , l , in_space = 0 ; xmlChar * current = NULL ; xmlEntityPtr ent ; if ( NXT ( 0 ) == \'""\' ) { ctxt -> instate = XML_PARSER_ATTRIBUTE_VALUE ; limit = \'""\' ; NEXT ; } else if ( NXT ( 0 ) == '\\'' ) { limit = '\\'' ; ctxt -> instate = XML_PARSER_ATTRIBUTE_VALUE ; NEXT ; } else { xmlFatalErr ( ctxt , XML_ERR_ATTRIBUTE_NOT_STARTED , NULL ) ; return ( NULL ) ; } buf_size = XML_PARSER_BUFFER_SIZE ; buf = ( xmlChar * ) xmlMallocAtomic ( buf_size * sizeof ( xmlChar ) ) ; if ( buf == NULL ) goto mem_error ; c = CUR_CHAR ( l ) ; while ( ( NXT ( 0 ) != limit ) && ( IS_CHAR ( c ) ) && ( c != '<' ) ) { if ( c == 0 ) break ; if ( c == '&' ) { in_space = 0 ; if ( NXT ( 1 ) == '#' ) { int val = xmlParseCharRef ( ctxt ) ; if ( val == '&' ) { if ( ctxt -> replaceEntities ) { if ( len > buf_size - 10 ) { growBuffer ( buf , 10 ) ; } buf [ len ++ ] = '&' ; } else { if ( len > buf_size - 10 ) { growBuffer ( buf , 10 ) ; } buf [ len ++ ] = '&' ; buf [ len ++ ] = '#' ; buf [ len ++ ] = '3' ; buf [ len ++ ] = '8' ; buf [ len ++ ] = ';' ; } } else if ( val != 0 ) { if ( len > buf_size - 10 ) { growBuffer ( buf , 10 ) ; } len += xmlCopyChar ( 0 , & buf [ len ] , val ) ; } } else { ent = xmlParseEntityRef ( ctxt ) ; ctxt -> nbentities ++ ; if ( ent != NULL ) ctxt -> nbentities += ent -> owner ; if ( ( ent != NULL ) && ( ent -> etype == XML_INTERNAL_PREDEFINED_ENTITY ) ) { if ( len > buf_size - 10 ) { growBuffer ( buf , 10 ) ; } if ( ( ctxt -> replaceEntities == 0 ) && ( ent -> content [ 0 ] == '&' ) ) { buf [ len ++ ] = '&' ; buf [ len ++ ] = '#' ; buf [ len ++ ] = '3' ; buf [ len ++ ] = '8' ; buf [ len ++ ] = ';' ; } else { buf [ len ++ ] = ent -> content [ 0 ] ; } } else if ( ( ent != NULL ) && ( ctxt -> replaceEntities != 0 ) ) { if ( ent -> etype != XML_INTERNAL_PREDEFINED_ENTITY ) { rep = xmlStringDecodeEntities ( ctxt , ent -> content , XML_SUBSTITUTE_REF , 0 , 0 , 0 ) ; if ( rep != NULL ) { current = rep ; while ( * current != 0 ) { if ( ( * current == 0xD ) || ( * current == 0xA ) || ( * current == 0x9 ) ) { buf [ len ++ ] = 0x20 ; current ++ ; } else buf [ len ++ ] = * current ++ ; if ( len > buf_size - 10 ) { growBuffer ( buf , 10 ) ; } } xmlFree ( rep ) ; rep = NULL ; } } else { if ( len > buf_size - 10 ) { growBuffer ( buf , 10 ) ; } if ( ent -> content != NULL ) buf [ len ++ ] = ent -> content [ 0 ] ; } } else if ( ent != NULL ) { int i = xmlStrlen ( ent -> name ) ; const xmlChar * cur = ent -> name ; if ( ( ent -> etype != XML_INTERNAL_PREDEFINED_ENTITY ) && ( ent -> content != NULL ) ) { rep = xmlStringDecodeEntities ( ctxt , ent -> content , XML_SUBSTITUTE_REF , 0 , 0 , 0 ) ; if ( rep != NULL ) { xmlFree ( rep ) ; rep = NULL ; } } buf [ len ++ ] = '&' ; while ( len > buf_size - i - 10 ) { growBuffer ( buf , i + 10 ) ; } for ( ; i > 0 ; i -- ) buf [ len ++ ] = * cur ++ ; buf [ len ++ ] = ';' ; } } } else { if ( ( c == 0x20 ) || ( c == 0xD ) || ( c == 0xA ) || ( c == 0x9 ) ) { if ( ( len != 0 ) || ( ! normalize ) ) { if ( ( ! normalize ) || ( ! in_space ) ) { COPY_BUF ( l , buf , len , 0x20 ) ; while ( len > buf_size - 10 ) { growBuffer ( buf , 10 ) ; } } in_space = 1 ; } } else { in_space = 0 ; COPY_BUF ( l , buf , len , c ) ; if ( len > buf_size - 10 ) { growBuffer ( buf , 10 ) ; } } NEXTL ( l ) ; } GROW ; c = CUR_CHAR ( l ) ; } if ( ( in_space ) && ( normalize ) ) { <S2SV_StartBug> while ( buf [ len - 1 ] == 0x20 ) len -- ; <S2SV_EndBug> } buf [ len ] = 0 ; if ( RAW == '<' ) { xmlFatalErr ( ctxt , XML_ERR_LT_IN_ATTRIBUTE , NULL ) ; } else if ( RAW != limit ) { if ( ( c != 0 ) && ( ! IS_CHAR ( c ) ) ) { xmlFatalErrMsg ( ctxt , XML_ERR_INVALID_CHAR , ""invalid<S2SV_blank>character<S2SV_blank>in<S2SV_blank>attribute<S2SV_blank>value\\n"" ) ; } else { xmlFatalErrMsg ( ctxt , XML_ERR_ATTRIBUTE_NOT_FINISHED , ""AttValue:<S2SV_blank>\'<S2SV_blank>expected\\n"" ) ; } } else NEXT ; if ( attlen != NULL ) * attlen = len ; return ( buf ) ; mem_error : xmlErrMemory ( ctxt , NULL ) ; if ( buf != NULL ) xmlFree ( buf ) ; if ( rep != NULL ) xmlFree ( rep ) ; return ( NULL ) ; }",{ while ( ( len > 0 ) && ( <S2SV_ModStart> == 0x20 ) )
167,"static long madvise_remove ( struct vm_area_struct * vma , struct vm_area_struct * * prev , unsigned long start , unsigned long end ) { loff_t offset ; int error ; <S2SV_StartBug> * prev = NULL ; <S2SV_EndBug> if ( vma -> vm_flags & ( VM_LOCKED | VM_NONLINEAR | VM_HUGETLB ) ) return - EINVAL ; <S2SV_StartBug> if ( ! vma -> vm_file || ! vma -> vm_file -> f_mapping <S2SV_EndBug> <S2SV_StartBug> || ! vma -> vm_file -> f_mapping -> host ) { <S2SV_EndBug> return - EINVAL ; } if ( ( vma -> vm_flags & ( VM_SHARED | VM_WRITE ) ) != ( VM_SHARED | VM_WRITE ) ) return - EACCES ; offset = ( loff_t ) ( start - vma -> vm_start ) + ( ( loff_t ) vma -> vm_pgoff << PAGE_SHIFT ) ; <S2SV_StartBug> up_read ( & current -> mm -> mmap_sem ) ; <S2SV_EndBug> <S2SV_StartBug> error = do_fallocate ( vma -> vm_file , <S2SV_EndBug> FALLOC_FL_PUNCH_HOLE | FALLOC_FL_KEEP_SIZE , <S2SV_StartBug> offset , end - start ) ; <S2SV_EndBug> down_read ( & current -> mm -> mmap_sem ) ; return error ; }","int error ; struct file * f ; <S2SV_ModStart> - EINVAL ; f = vma -> vm_file ; <S2SV_ModStart> if ( ! f || ! f <S2SV_ModEnd> -> f_mapping || <S2SV_ModStart> f_mapping || ! f <S2SV_ModEnd> -> f_mapping -> <S2SV_ModStart> PAGE_SHIFT ) ; get_file ( f ) ; <S2SV_ModStart> = do_fallocate ( f <S2SV_ModEnd> , FALLOC_FL_PUNCH_HOLE | <S2SV_ModStart> end - start ) ; fput ( f"
168,"int main ( int ac , char * * av ) { int c_flag = 0 , d_flag = 0 , D_flag = 0 , k_flag = 0 , s_flag = 0 ; int sock , fd , ch , result , saved_errno ; u_int nalloc ; char * shell , * format , * pidstr , * agentsocket = NULL ; fd_set * readsetp = NULL , * writesetp = NULL ; struct rlimit rlim ; extern int optind ; extern char * optarg ; pid_t pid ; char pidstrbuf [ 1 + 3 * sizeof pid ] ; struct timeval * tvp = NULL ; size_t len ; mode_t prev_mask ; ssh_malloc_init ( ) ; sanitise_stdfd ( ) ; setegid ( getgid ( ) ) ; setgid ( getgid ( ) ) ; # ifdef WITH_OPENSSL OpenSSL_add_all_algorithms ( ) ; # endif <S2SV_StartBug> while ( ( ch = getopt ( ac , av , ""cDdksE:a:t:"" ) ) != - 1 ) { <S2SV_EndBug> switch ( ch ) { case 'E' : fingerprint_hash = ssh_digest_alg_by_name ( optarg ) ; if ( fingerprint_hash == - 1 ) fatal ( ""Invalid<S2SV_blank>hash<S2SV_blank>algorithm<S2SV_blank>\\""%s\\"""" , optarg ) ; break ; case 'c' : if ( s_flag ) usage ( ) ; c_flag ++ ; break ; case 'k' : <S2SV_StartBug> k_flag ++ ; <S2SV_EndBug> break ; case 's' : if ( c_flag ) usage ( ) ; s_flag ++ ; break ; case 'd' : if ( d_flag || D_flag ) usage ( ) ; d_flag ++ ; break ; case 'D' : if ( d_flag || D_flag ) usage ( ) ; D_flag ++ ; break ; case 'a' : agentsocket = optarg ; break ; case 't' : if ( ( lifetime = convtime ( optarg ) ) == - 1 ) { fprintf ( stderr , ""Invalid<S2SV_blank>lifetime\\n"" ) ; usage ( ) ; } break ; default : usage ( ) ; } } ac -= optind ; av += optind ; if ( ac > 0 && ( c_flag || k_flag || s_flag || d_flag || D_flag ) ) usage ( ) ; <S2SV_StartBug> if ( ac == 0 && ! c_flag && ! s_flag ) { <S2SV_EndBug> shell = getenv ( ""SHELL"" ) ; if ( shell != NULL && ( len = strlen ( shell ) ) > 2 && strncmp ( shell + len - 3 , ""csh"" , 3 ) == 0 ) c_flag = 1 ; } if ( k_flag ) { const char * errstr = NULL ; pidstr = getenv ( SSH_AGENTPID_ENV_NAME ) ; if ( pidstr == NULL ) { fprintf ( stderr , ""%s<S2SV_blank>not<S2SV_blank>set,<S2SV_blank>cannot<S2SV_blank>kill<S2SV_blank>agent\\n"" , SSH_AGENTPID_ENV_NAME ) ; exit ( 1 ) ; } pid = ( int ) strtonum ( pidstr , 2 , INT_MAX , & errstr ) ; if ( errstr ) { fprintf ( stderr , ""%s=\\""%s\\"",<S2SV_blank>which<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>good<S2SV_blank>PID:<S2SV_blank>%s\\n"" , SSH_AGENTPID_ENV_NAME , pidstr , errstr ) ; exit ( 1 ) ; } if ( kill ( pid , SIGTERM ) == - 1 ) { perror ( ""kill"" ) ; exit ( 1 ) ; } format = c_flag ? ""unsetenv<S2SV_blank>%s;\\n"" : ""unset<S2SV_blank>%s;\\n"" ; printf ( format , SSH_AUTHSOCKET_ENV_NAME ) ; printf ( format , SSH_AGENTPID_ENV_NAME ) ; printf ( ""echo<S2SV_blank>Agent<S2SV_blank>pid<S2SV_blank>%ld<S2SV_blank>killed;\\n"" , ( long ) pid ) ; exit ( 0 ) ; } parent_pid = getpid ( ) ; if ( agentsocket == NULL ) { mktemp_proto ( socket_dir , sizeof ( socket_dir ) ) ; if ( mkdtemp ( socket_dir ) == NULL ) { perror ( ""mkdtemp:<S2SV_blank>private<S2SV_blank>socket<S2SV_blank>dir"" ) ; exit ( 1 ) ; } snprintf ( socket_name , sizeof socket_name , ""%s/agent.%ld"" , socket_dir , ( long ) parent_pid ) ; } else { socket_dir [ 0 ] = '\\0' ; strlcpy ( socket_name , agentsocket , sizeof socket_name ) ; } prev_mask = umask ( 0177 ) ; sock = unix_listener ( socket_name , SSH_LISTEN_BACKLOG , 0 ) ; if ( sock < 0 ) { * socket_name = '\\0' ; cleanup_exit ( 1 ) ; } umask ( prev_mask ) ; if ( D_flag || d_flag ) { log_init ( __progname , d_flag ? SYSLOG_LEVEL_DEBUG3 : SYSLOG_LEVEL_INFO , SYSLOG_FACILITY_AUTH , 1 ) ; format = c_flag ? ""setenv<S2SV_blank>%s<S2SV_blank>%s;\\n"" : ""%s=%s;<S2SV_blank>export<S2SV_blank>%s;\\n"" ; printf ( format , SSH_AUTHSOCKET_ENV_NAME , socket_name , SSH_AUTHSOCKET_ENV_NAME ) ; printf ( ""echo<S2SV_blank>Agent<S2SV_blank>pid<S2SV_blank>%ld;\\n"" , ( long ) parent_pid ) ; fflush ( stdout ) ; goto skip ; } pid = fork ( ) ; if ( pid == - 1 ) { perror ( ""fork"" ) ; cleanup_exit ( 1 ) ; } if ( pid != 0 ) { close ( sock ) ; snprintf ( pidstrbuf , sizeof pidstrbuf , ""%ld"" , ( long ) pid ) ; if ( ac == 0 ) { format = c_flag ? ""setenv<S2SV_blank>%s<S2SV_blank>%s;\\n"" : ""%s=%s;<S2SV_blank>export<S2SV_blank>%s;\\n"" ; printf ( format , SSH_AUTHSOCKET_ENV_NAME , socket_name , SSH_AUTHSOCKET_ENV_NAME ) ; printf ( format , SSH_AGENTPID_ENV_NAME , pidstrbuf , SSH_AGENTPID_ENV_NAME ) ; printf ( ""echo<S2SV_blank>Agent<S2SV_blank>pid<S2SV_blank>%ld;\\n"" , ( long ) pid ) ; exit ( 0 ) ; } if ( setenv ( SSH_AUTHSOCKET_ENV_NAME , socket_name , 1 ) == - 1 || setenv ( SSH_AGENTPID_ENV_NAME , pidstrbuf , 1 ) == - 1 ) { perror ( ""setenv"" ) ; exit ( 1 ) ; } execvp ( av [ 0 ] , av ) ; perror ( av [ 0 ] ) ; exit ( 1 ) ; } log_init ( __progname , SYSLOG_LEVEL_INFO , SYSLOG_FACILITY_AUTH , 0 ) ; if ( setsid ( ) == - 1 ) { error ( ""setsid:<S2SV_blank>%s"" , strerror ( errno ) ) ; cleanup_exit ( 1 ) ; } ( void ) chdir ( ""/"" ) ; if ( ( fd = open ( _PATH_DEVNULL , O_RDWR , 0 ) ) != - 1 ) { ( void ) dup2 ( fd , STDIN_FILENO ) ; ( void ) dup2 ( fd , STDOUT_FILENO ) ; ( void ) dup2 ( fd , STDERR_FILENO ) ; if ( fd > 2 ) close ( fd ) ; } rlim . rlim_cur = rlim . rlim_max = 0 ; if ( setrlimit ( RLIMIT_CORE , & rlim ) < 0 ) { error ( ""setrlimit<S2SV_blank>RLIMIT_CORE:<S2SV_blank>%s"" , strerror ( errno ) ) ; cleanup_exit ( 1 ) ; } skip : cleanup_pid = getpid ( ) ; # ifdef ENABLE_PKCS11 pkcs11_init ( 0 ) ; # endif new_socket ( AUTH_SOCKET , sock ) ; if ( ac > 0 ) parent_alive_interval = 10 ; idtab_init ( ) ; signal ( SIGPIPE , SIG_IGN ) ; signal ( SIGINT , ( d_flag | D_flag ) ? cleanup_handler : SIG_IGN ) ; signal ( SIGHUP , cleanup_handler ) ; signal ( SIGTERM , cleanup_handler ) ; nalloc = 0 ; <S2SV_StartBug> if ( pledge ( ""stdio<S2SV_blank>cpath<S2SV_blank>unix<S2SV_blank>id<S2SV_blank>proc<S2SV_blank>exec"" , NULL ) == - 1 ) <S2SV_EndBug> fatal ( ""%s:<S2SV_blank>pledge:<S2SV_blank>%s"" , __progname , strerror ( errno ) ) ; while ( 1 ) { prepare_select ( & readsetp , & writesetp , & max_fd , & nalloc , & tvp ) ; result = select ( max_fd + 1 , readsetp , writesetp , NULL , tvp ) ; saved_errno = errno ; if ( parent_alive_interval != 0 ) check_parent_exists ( ) ; ( void ) reaper ( ) ; if ( result < 0 ) { if ( saved_errno == EINTR ) continue ; fatal ( ""select:<S2SV_blank>%s"" , strerror ( saved_errno ) ) ; } else if ( result > 0 ) after_select ( readsetp , writesetp ) ; } }",", av , ""cDdksE:a:P:t:"" <S2SV_ModEnd> ) ) != <S2SV_ModStart> : k_flag ++ ; break ; case 'P' : if ( pkcs11_whitelist != NULL ) fatal ( ""-P<S2SV_blank>option<S2SV_blank>already<S2SV_blank>specified"" ) ; pkcs11_whitelist = xstrdup ( optarg ) <S2SV_ModStart> ; if ( pkcs11_whitelist == NULL ) pkcs11_whitelist = xstrdup ( DEFAULT_PKCS11_WHITELIST ) ; if ( <S2SV_ModStart> ( pledge ( ""stdio<S2SV_blank>rpath<S2SV_blank>cpath<S2SV_blank>unix<S2SV_blank>id<S2SV_blank>proc<S2SV_blank>exec"" <S2SV_ModEnd> , NULL )"
169,"const char * linkaddr_string ( netdissect_options * ndo , const u_char * ep , const unsigned int type , const unsigned int len ) { register u_int i ; register char * cp ; <S2SV_StartBug> register struct enamemem * tp ; <S2SV_EndBug> if ( len == 0 ) return ( ""<empty>"" ) ; if ( type == LINKADDR_ETHER && len == ETHER_ADDR_LEN ) return ( etheraddr_string ( ndo , ep ) ) ; if ( type == LINKADDR_FRELAY ) return ( q922_string ( ndo , ep , len ) ) ; tp = lookup_bytestring ( ndo , ep , len ) ; <S2SV_StartBug> if ( tp -> e_name ) <S2SV_EndBug> return ( tp -> e_name ) ; tp -> e_name = cp = ( char * ) malloc ( len * 3 ) ; <S2SV_StartBug> if ( tp -> e_name == NULL ) <S2SV_EndBug> ( * ndo -> ndo_error ) ( ndo , ""linkaddr_string:<S2SV_blank>malloc"" ) ; * cp ++ = hex [ * ep >> 4 ] ; * cp ++ = hex [ * ep ++ & 0xf ] ; for ( i = len - 1 ; i > 0 ; -- i ) { * cp ++ = ':' ; * cp ++ = hex [ * ep >> 4 ] ; * cp ++ = hex [ * ep ++ & 0xf ] ; } * cp = '\\0' ; <S2SV_StartBug> return ( tp -> e_name ) ; <S2SV_EndBug> }",; register struct bsnamemem <S2SV_ModEnd> * tp ; <S2SV_ModStart> ( tp -> bs_name ) return ( tp -> bs_name ) ; tp -> bs_name <S2SV_ModEnd> = cp = <S2SV_ModStart> ( tp -> bs_name <S2SV_ModEnd> == NULL ) <S2SV_ModStart> ( tp -> bs_name <S2SV_ModEnd> ) ; }
170,"int ext4_collapse_range ( struct inode * inode , loff_t offset , loff_t len ) { struct super_block * sb = inode -> i_sb ; ext4_lblk_t punch_start , punch_stop ; handle_t * handle ; unsigned int credits ; loff_t new_size , ioffset ; int ret ; if ( ! ext4_test_inode_flag ( inode , EXT4_INODE_EXTENTS ) ) return - EOPNOTSUPP ; if ( offset & ( EXT4_CLUSTER_SIZE ( sb ) - 1 ) || len & ( EXT4_CLUSTER_SIZE ( sb ) - 1 ) ) return - EINVAL ; if ( ! S_ISREG ( inode -> i_mode ) ) return - EINVAL ; trace_ext4_collapse_range ( inode , offset , len ) ; punch_start = offset >> EXT4_BLOCK_SIZE_BITS ( sb ) ; punch_stop = ( offset + len ) >> EXT4_BLOCK_SIZE_BITS ( sb ) ; if ( ext4_should_journal_data ( inode ) ) { ret = ext4_force_commit ( inode -> i_sb ) ; if ( ret ) return ret ; } ioffset = round_down ( offset , PAGE_SIZE ) ; ret = filemap_write_and_wait_range ( inode -> i_mapping , ioffset , LLONG_MAX ) ; if ( ret ) return ret ; mutex_lock ( & inode -> i_mutex ) ; if ( offset + len >= i_size_read ( inode ) ) { ret = - EINVAL ; goto out_mutex ; } if ( ! ext4_test_inode_flag ( inode , EXT4_INODE_EXTENTS ) ) { ret = - EOPNOTSUPP ; goto out_mutex ; } <S2SV_StartBug> truncate_pagecache ( inode , ioffset ) ; <S2SV_EndBug> <S2SV_StartBug> ext4_inode_block_unlocked_dio ( inode ) ; <S2SV_EndBug> inode_dio_wait ( inode ) ; credits = ext4_writepage_trans_blocks ( inode ) ; handle = ext4_journal_start ( inode , EXT4_HT_TRUNCATE , credits ) ; if ( IS_ERR ( handle ) ) { ret = PTR_ERR ( handle ) ; <S2SV_StartBug> goto out_dio ; <S2SV_EndBug> } down_write ( & EXT4_I ( inode ) -> i_data_sem ) ; ext4_discard_preallocations ( inode ) ; ret = ext4_es_remove_extent ( inode , punch_start , EXT_MAX_BLOCKS - punch_start ) ; if ( ret ) { up_write ( & EXT4_I ( inode ) -> i_data_sem ) ; goto out_stop ; } ret = ext4_ext_remove_space ( inode , punch_start , punch_stop - 1 ) ; if ( ret ) { up_write ( & EXT4_I ( inode ) -> i_data_sem ) ; goto out_stop ; } ext4_discard_preallocations ( inode ) ; ret = ext4_ext_shift_extents ( inode , handle , punch_stop , punch_stop - punch_start , SHIFT_LEFT ) ; if ( ret ) { up_write ( & EXT4_I ( inode ) -> i_data_sem ) ; goto out_stop ; } new_size = i_size_read ( inode ) - len ; i_size_write ( inode , new_size ) ; EXT4_I ( inode ) -> i_disksize = new_size ; up_write ( & EXT4_I ( inode ) -> i_data_sem ) ; if ( IS_SYNC ( inode ) ) ext4_handle_sync ( handle ) ; inode -> i_mtime = inode -> i_ctime = ext4_current_time ( inode ) ; ext4_mark_inode_dirty ( handle , inode ) ; out_stop : ext4_journal_stop ( handle ) ; <S2SV_StartBug> out_dio : <S2SV_EndBug> ext4_inode_resume_unlocked_dio ( inode ) ; out_mutex : mutex_unlock ( & inode -> i_mutex ) ; return ret ; }",out_mutex ; } ext4_inode_block_unlocked_dio ( inode ) ; inode_dio_wait ( inode ) ; down_write ( & EXT4_I ( inode ) -> i_mmap_sem ) ; <S2SV_ModStart> ioffset ) ; <S2SV_ModEnd> credits = ext4_writepage_trans_blocks <S2SV_ModStart> ) ; goto out_mmap <S2SV_ModEnd> ; } down_write <S2SV_ModStart> handle ) ; out_mmap : up_write ( & EXT4_I ( inode ) -> i_mmap_sem ) ; <S2SV_ModEnd> ext4_inode_resume_unlocked_dio ( inode
171,"void handle_usb_rx ( const void * msg , size_t len ) { if ( msg_tiny_flag ) { <S2SV_StartBug> uint8_t buf [ 64 ] ; <S2SV_EndBug> memcpy ( buf , msg , sizeof ( buf ) ) ; uint16_t msgId = buf [ 4 ] | ( ( uint16_t ) buf [ 3 ] ) << 8 ; uint32_t msgSize = buf [ 8 ] | ( ( uint32_t ) buf [ 7 ] ) << 8 | ( ( uint32_t ) buf [ 6 ] ) << 16 | ( ( uint32_t ) buf [ 5 ] ) << 24 ; if ( msgSize > 64 - 9 ) { ( * msg_failure ) ( FailureType_Failure_UnexpectedMessage , ""Malformed<S2SV_blank>tiny<S2SV_blank>packet"" ) ; return ; } const MessagesMap_t * entry = message_map_entry ( NORMAL_MSG , msgId , IN_MSG ) ; if ( ! entry ) { ( * msg_failure ) ( FailureType_Failure_UnexpectedMessage , ""Unknown<S2SV_blank>message"" ) ; return ; } tiny_dispatch ( entry , buf + 9 , msgSize ) ; } else { usb_rx_helper ( msg , len , NORMAL_MSG ) ; } }","msg_tiny_flag ) { msg_read_tiny ( msg , len <S2SV_ModEnd> ) ; }"
172,static void hugetlbfs_put_super ( struct super_block * sb ) { struct hugetlbfs_sb_info * sbi = HUGETLBFS_SB ( sb ) ; if ( sbi ) { sb -> s_fs_info = NULL ; <S2SV_StartBug> kfree ( sbi ) ; <S2SV_EndBug> } },= NULL ; if ( sbi -> spool ) hugepage_put_subpool ( sbi -> spool ) ;
173,"static VALUE ossl_cipher_set_key ( VALUE self , VALUE key ) { EVP_CIPHER_CTX * ctx ; int key_len ; StringValue ( key ) ; GetCipher ( self , ctx ) ; key_len = EVP_CIPHER_CTX_key_length ( ctx ) ; if ( RSTRING_LEN ( key ) != key_len ) ossl_raise ( rb_eArgError , ""key<S2SV_blank>must<S2SV_blank>be<S2SV_blank>%d<S2SV_blank>bytes"" , key_len ) ; if ( EVP_CipherInit_ex ( ctx , NULL , NULL , ( unsigned char * ) RSTRING_PTR ( key ) , NULL , - 1 ) != 1 ) ossl_raise ( eCipherError , NULL ) ; <S2SV_StartBug> return key ; <S2SV_EndBug> }","NULL ) ; rb_ivar_set ( self , id_key_set , Qtrue ) ;"
174,"struct sk_buff * * udp_gro_receive ( struct sk_buff * * head , struct sk_buff * skb , struct udphdr * uh ) { struct udp_offload_priv * uo_priv ; struct sk_buff * p , * * pp = NULL ; struct udphdr * uh2 ; unsigned int off = skb_gro_offset ( skb ) ; int flush = 1 ; <S2SV_StartBug> if ( NAPI_GRO_CB ( skb ) -> udp_mark || <S2SV_EndBug> ( skb -> ip_summed != CHECKSUM_PARTIAL && NAPI_GRO_CB ( skb ) -> csum_cnt == 0 && ! NAPI_GRO_CB ( skb ) -> csum_valid ) ) goto out ; <S2SV_StartBug> NAPI_GRO_CB ( skb ) -> udp_mark = 1 ; <S2SV_EndBug> rcu_read_lock ( ) ; uo_priv = rcu_dereference ( udp_offload_base ) ; for ( ; uo_priv != NULL ; uo_priv = rcu_dereference ( uo_priv -> next ) ) { if ( net_eq ( read_pnet ( & uo_priv -> net ) , dev_net ( skb -> dev ) ) && uo_priv -> offload -> port == uh -> dest && uo_priv -> offload -> callbacks . gro_receive ) goto unflush ; } goto out_unlock ; unflush : flush = 0 ; for ( p = * head ; p ; p = p -> next ) { if ( ! NAPI_GRO_CB ( p ) -> same_flow ) continue ; uh2 = ( struct udphdr * ) ( p -> data + off ) ; if ( ( * ( u32 * ) & uh -> source != * ( u32 * ) & uh2 -> source ) || ( ! uh -> check ^ ! uh2 -> check ) ) { NAPI_GRO_CB ( p ) -> same_flow = 0 ; continue ; } } skb_gro_pull ( skb , sizeof ( struct udphdr ) ) ; skb_gro_postpull_rcsum ( skb , uh , sizeof ( struct udphdr ) ) ; NAPI_GRO_CB ( skb ) -> proto = uo_priv -> offload -> ipproto ; pp = uo_priv -> offload -> callbacks . gro_receive ( head , skb , uo_priv -> offload ) ; out_unlock : rcu_read_unlock ( ) ; out : NAPI_GRO_CB ( skb ) -> flush |= flush ; return pp ; }",skb ) -> encap_mark <S2SV_ModEnd> || ( skb <S2SV_ModStart> skb ) -> encap_mark <S2SV_ModEnd> = 1 ;
175,"static int smacker_decode_tree ( BitstreamContext * bc , HuffContext * hc , uint32_t prefix , int length ) { <S2SV_StartBug> if ( ! bitstream_read_bit ( bc ) ) { <S2SV_EndBug> if ( hc -> current >= 256 ) { av_log ( NULL , AV_LOG_ERROR , ""Tree<S2SV_blank>size<S2SV_blank>exceeded!\\n"" ) ; return AVERROR_INVALIDDATA ; } if ( length ) { hc -> bits [ hc -> current ] = prefix ; hc -> lengths [ hc -> current ] = length ; } else { hc -> bits [ hc -> current ] = 0 ; hc -> lengths [ hc -> current ] = 0 ; } hc -> values [ hc -> current ] = bitstream_read ( bc , 8 ) ; hc -> current ++ ; if ( hc -> maxlength < length ) hc -> maxlength = length ; return 0 ; } else { int r ; length ++ ; r = smacker_decode_tree ( bc , hc , prefix , length ) ; if ( r ) return r ; return smacker_decode_tree ( bc , hc , prefix | ( 1 << ( length - 1 ) ) , length ) ; } }","{ if ( length > SMKTREE_DECODE_MAX_RECURSION ) { av_log ( NULL , AV_LOG_ERROR , ""Maximum<S2SV_blank>tree<S2SV_blank>recursion<S2SV_blank>level<S2SV_blank>exceeded.\\n"" ) ; return AVERROR_INVALIDDATA ; } if ("
176,static void veth_setup ( struct net_device * dev ) { <S2SV_StartBug> ether_setup ( dev ) ; <S2SV_EndBug> dev -> netdev_ops = & veth_netdev_ops ; dev -> ethtool_ops = & veth_ethtool_ops ; dev -> features |= NETIF_F_LLTX ; dev -> destructor = veth_dev_free ; dev -> hw_features = NETIF_F_NO_CSUM | NETIF_F_SG | NETIF_F_RXCSUM ; },( dev ) ; dev -> priv_flags &= ~ IFF_TX_SKB_SHARING
177,unsigned long lh_char_hash ( const void * k ) { <S2SV_StartBug> unsigned int h = 0 ; <S2SV_EndBug> <S2SV_StartBug> const char * data = ( const char * ) k ; <S2SV_EndBug> while ( * data != 0 ) h = h * 129 + ( unsigned int ) ( * data ++ ) + LH_PRIME ; return h ; },"k ) { static volatile int random_seed = - 1 ; if ( random_seed == - 1 ) { int seed ; while ( ( seed = json_c_get_random_seed ( ) ) == - 1 ) ; # if defined __GNUC__ __sync_val_compare_and_swap ( & random_seed , - 1 , seed ) ; # elif defined _MSC_VER InterlockedCompareExchange ( & random_seed , seed , - 1 ) ; # else # warning ""racy<S2SV_blank>random<S2SV_blank>seed<S2SV_blank>initializtion<S2SV_blank>if<S2SV_blank>used<S2SV_blank>by<S2SV_blank>multiple<S2SV_blank>threads"" random_seed = seed ; # endif } return hashlittle ( <S2SV_ModEnd> ( const char <S2SV_ModStart> * ) k , strlen ( ( const char * ) k ) , random_seed ) <S2SV_ModEnd> ; } <S2SV_null>"
178,"static void setup_private_mount ( const char * snap_name ) { <S2SV_StartBug> uid_t uid = getuid ( ) ; <S2SV_EndBug> gid_t gid = getgid ( ) ; char tmpdir [ MAX_BUF ] = { 0 } ; sc_must_snprintf ( tmpdir , sizeof ( tmpdir ) , ""/tmp/snap.%s_XXXXXX"" , snap_name ) ; if ( mkdtemp ( tmpdir ) == NULL ) { die ( ""cannot<S2SV_blank>create<S2SV_blank>temporary<S2SV_blank>directory<S2SV_blank>essential<S2SV_blank>for<S2SV_blank>private<S2SV_blank>/tmp"" ) ; } mode_t old_mask = umask ( 0 ) ; char * d = sc_strdup ( tmpdir ) ; sc_must_snprintf ( tmpdir , sizeof ( tmpdir ) , ""%s/tmp"" , d ) ; free ( d ) ; if ( mkdir ( tmpdir , 01777 ) != 0 ) { die ( ""cannot<S2SV_blank>create<S2SV_blank>temporary<S2SV_blank>directory<S2SV_blank>for<S2SV_blank>private<S2SV_blank>/tmp"" ) ; } umask ( old_mask ) ; char * pwd = get_current_dir_name ( ) ; if ( pwd == NULL ) die ( ""cannot<S2SV_blank>get<S2SV_blank>current<S2SV_blank>working<S2SV_blank>directory"" ) ; if ( chdir ( ""/"" ) != 0 ) die ( ""cannot<S2SV_blank>change<S2SV_blank>directory<S2SV_blank>to<S2SV_blank>\'/\'"" ) ; sc_do_mount ( tmpdir , ""/tmp"" , NULL , MS_BIND , NULL ) ; sc_do_mount ( ""none"" , ""/tmp"" , NULL , MS_PRIVATE , NULL ) ; <S2SV_StartBug> if ( chown ( ""/tmp/"" , uid , gid ) < 0 ) { <S2SV_EndBug> die ( ""cannot<S2SV_blank>change<S2SV_blank>ownership<S2SV_blank>of<S2SV_blank>/tmp"" ) ; } if ( chdir ( pwd ) != 0 ) die ( ""cannot<S2SV_blank>change<S2SV_blank>current<S2SV_blank>working<S2SV_blank>directory<S2SV_blank>to<S2SV_blank>the<S2SV_blank>original<S2SV_blank>directory"" ) ; free ( pwd ) ; }","snap_name ) { <S2SV_ModEnd> char tmpdir [ <S2SV_ModStart> ( ""/tmp/"" , 0 , 0 <S2SV_ModEnd> ) < 0"
179,"NORET_TYPE void do_exit ( long code ) { struct task_struct * tsk = current ; int group_dead ; profile_task_exit ( tsk ) ; WARN_ON ( atomic_read ( & tsk -> fs_excl ) ) ; if ( unlikely ( in_interrupt ( ) ) ) panic ( ""Aiee,<S2SV_blank>killing<S2SV_blank>interrupt<S2SV_blank>handler!"" ) ; if ( unlikely ( ! tsk -> pid ) ) panic ( ""Attempted<S2SV_blank>to<S2SV_blank>kill<S2SV_blank>the<S2SV_blank>idle<S2SV_blank>task!"" ) ; tracehook_report_exit ( & code ) ; validate_creds_for_do_exit ( tsk ) ; if ( unlikely ( tsk -> flags & PF_EXITING ) ) { printk ( KERN_ALERT ""Fixing<S2SV_blank>recursive<S2SV_blank>fault<S2SV_blank>but<S2SV_blank>reboot<S2SV_blank>is<S2SV_blank>needed!\\n"" ) ; tsk -> flags |= PF_EXITPIDONE ; set_current_state ( TASK_UNINTERRUPTIBLE ) ; schedule ( ) ; } exit_irq_thread ( ) ; exit_signals ( tsk ) ; smp_mb ( ) ; spin_unlock_wait ( & tsk -> pi_lock ) ; if ( unlikely ( in_atomic ( ) ) ) printk ( KERN_INFO ""note:<S2SV_blank>%s[%d]<S2SV_blank>exited<S2SV_blank>with<S2SV_blank>preempt_count<S2SV_blank>%d\\n"" , current -> comm , task_pid_nr ( current ) , preempt_count ( ) ) ; acct_update_integrals ( tsk ) ; group_dead = atomic_dec_and_test ( & tsk -> signal -> live ) ; if ( group_dead ) { hrtimer_cancel ( & tsk -> signal -> real_timer ) ; exit_itimers ( tsk -> signal ) ; if ( tsk -> mm ) setmax_mm_hiwater_rss ( & tsk -> signal -> maxrss , tsk -> mm ) ; } acct_collect ( code , group_dead ) ; if ( group_dead ) tty_audit_exit ( ) ; if ( unlikely ( tsk -> audit_context ) ) audit_free ( tsk ) ; tsk -> exit_code = code ; taskstats_exit ( tsk , group_dead ) ; exit_mm ( tsk ) ; if ( group_dead ) acct_process ( ) ; trace_sched_process_exit ( tsk ) ; exit_sem ( tsk ) ; exit_files ( tsk ) ; exit_fs ( tsk ) ; check_stack_usage ( ) ; exit_thread ( ) ; cgroup_exit ( tsk , 1 ) ; if ( group_dead && tsk -> signal -> leader ) disassociate_ctty ( 1 ) ; module_put ( task_thread_info ( tsk ) -> exec_domain -> module ) ; proc_exit_connector ( tsk ) ; perf_event_exit_task ( tsk ) ; exit_notify ( tsk , group_dead ) ; # ifdef CONFIG_NUMA mpol_put ( tsk -> mempolicy ) ; tsk -> mempolicy = NULL ; # endif # ifdef CONFIG_FUTEX if ( unlikely ( current -> pi_state_cache ) ) kfree ( current -> pi_state_cache ) ; # endif debug_check_no_locks_held ( tsk ) ; tsk -> flags |= PF_EXITPIDONE ; if ( tsk -> io_context ) <S2SV_StartBug> exit_io_context ( ) ; <S2SV_EndBug> if ( tsk -> splice_pipe ) __free_pipe_info ( tsk -> splice_pipe ) ; validate_creds_for_do_exit ( tsk ) ; preempt_disable ( ) ; exit_rcu ( ) ; tsk -> state = TASK_DEAD ; schedule ( ) ; BUG ( ) ; for ( ; ; ) cpu_relax ( ) ; }",) exit_io_context ( tsk
180,"static bool write_hci_command ( hci_packet_t type , const void * packet , size_t length ) { int sock = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ) ; if ( sock == INVALID_FD ) goto error ; struct sockaddr_in addr ; addr . sin_family = AF_INET ; addr . sin_addr . s_addr = htonl ( 0x7F000001 ) ; addr . sin_port = htons ( 8873 ) ; <S2SV_StartBug> if ( connect ( sock , ( const struct sockaddr * ) & addr , sizeof ( addr ) ) == - 1 ) <S2SV_EndBug> goto error ; <S2SV_StartBug> if ( send ( sock , & type , 1 , 0 ) != 1 ) <S2SV_EndBug> goto error ; <S2SV_StartBug> if ( send ( sock , & length , 2 , 0 ) != 2 ) <S2SV_EndBug> goto error ; <S2SV_StartBug> if ( send ( sock , packet , length , 0 ) != ( ssize_t ) length ) <S2SV_EndBug> goto error ; close ( sock ) ; return true ; error : ; close ( sock ) ; return false ; }","; if ( TEMP_FAILURE_RETRY ( <S2SV_ModStart> addr ) ) ) <S2SV_ModStart> ; if ( TEMP_FAILURE_RETRY ( <S2SV_ModStart> , 0 ) ) <S2SV_ModStart> ; if ( TEMP_FAILURE_RETRY ( <S2SV_ModStart> 2 , 0 ) <S2SV_ModStart> ; if ( TEMP_FAILURE_RETRY ( <S2SV_ModStart> length , 0 )"
181,"GPLOT * gplotRead ( const char * filename ) { <S2SV_StartBug> char buf [ L_BUF_SIZE ] ; <S2SV_EndBug> char * rootname , * title , * xlabel , * ylabel , * ignores ; l_int32 outformat , ret , version , ignore ; FILE * fp ; GPLOT * gplot ; PROCNAME ( ""gplotRead"" ) ; if ( ! filename ) return ( GPLOT * ) ERROR_PTR ( ""filename<S2SV_blank>not<S2SV_blank>defined"" , procName , NULL ) ; if ( ( fp = fopenReadStream ( filename ) ) == NULL ) return ( GPLOT * ) ERROR_PTR ( ""stream<S2SV_blank>not<S2SV_blank>opened"" , procName , NULL ) ; ret = fscanf ( fp , ""Gplot<S2SV_blank>Version<S2SV_blank>%d\\n"" , & version ) ; if ( ret != 1 ) { fclose ( fp ) ; return ( GPLOT * ) ERROR_PTR ( ""not<S2SV_blank>a<S2SV_blank>gplot<S2SV_blank>file"" , procName , NULL ) ; } if ( version != GPLOT_VERSION_NUMBER ) { fclose ( fp ) ; return ( GPLOT * ) ERROR_PTR ( ""invalid<S2SV_blank>gplot<S2SV_blank>version"" , procName , NULL ) ; } <S2SV_StartBug> ignore = fscanf ( fp , ""Rootname:<S2SV_blank>%s\\n"" , buf ) ; <S2SV_EndBug> rootname = stringNew ( buf ) ; ignore = fscanf ( fp , ""Output<S2SV_blank>format:<S2SV_blank>%d\\n"" , & outformat ) ; <S2SV_StartBug> ignores = fgets ( buf , L_BUF_SIZE , fp ) ; <S2SV_EndBug> title = stringNew ( buf + 7 ) ; title [ strlen ( title ) - 1 ] = '\\0' ; <S2SV_StartBug> ignores = fgets ( buf , L_BUF_SIZE , fp ) ; <S2SV_EndBug> xlabel = stringNew ( buf + 14 ) ; xlabel [ strlen ( xlabel ) - 1 ] = '\\0' ; <S2SV_StartBug> ignores = fgets ( buf , L_BUF_SIZE , fp ) ; <S2SV_EndBug> ylabel = stringNew ( buf + 14 ) ; ylabel [ strlen ( ylabel ) - 1 ] = '\\0' ; gplot = gplotCreate ( rootname , outformat , title , xlabel , ylabel ) ; LEPT_FREE ( rootname ) ; LEPT_FREE ( title ) ; LEPT_FREE ( xlabel ) ; LEPT_FREE ( ylabel ) ; if ( ! gplot ) { fclose ( fp ) ; return ( GPLOT * ) ERROR_PTR ( ""gplot<S2SV_blank>not<S2SV_blank>made"" , procName , NULL ) ; } sarrayDestroy ( & gplot -> cmddata ) ; sarrayDestroy ( & gplot -> datanames ) ; sarrayDestroy ( & gplot -> plotdata ) ; sarrayDestroy ( & gplot -> plottitles ) ; numaDestroy ( & gplot -> plotstyles ) ; <S2SV_StartBug> ignore = fscanf ( fp , ""Commandfile<S2SV_blank>name:<S2SV_blank>%s\\n"" , buf ) ; <S2SV_EndBug> stringReplace ( & gplot -> cmdname , buf ) ; ignore = fscanf ( fp , ""\\nCommandfile<S2SV_blank>data:"" ) ; gplot -> cmddata = sarrayReadStream ( fp ) ; ignore = fscanf ( fp , ""\\nDatafile<S2SV_blank>names:"" ) ; gplot -> datanames = sarrayReadStream ( fp ) ; ignore = fscanf ( fp , ""\\nPlot<S2SV_blank>data:"" ) ; gplot -> plotdata = sarrayReadStream ( fp ) ; ignore = fscanf ( fp , ""\\nPlot<S2SV_blank>titles:"" ) ; gplot -> plottitles = sarrayReadStream ( fp ) ; ignore = fscanf ( fp , ""\\nPlot<S2SV_blank>styles:"" ) ; gplot -> plotstyles = numaReadStream ( fp ) ; ignore = fscanf ( fp , ""Number<S2SV_blank>of<S2SV_blank>plots:<S2SV_blank>%d\\n"" , & gplot -> nplots ) ; <S2SV_StartBug> ignore = fscanf ( fp , ""Output<S2SV_blank>file<S2SV_blank>name:<S2SV_blank>%s\\n"" , buf ) ; <S2SV_EndBug> stringReplace ( & gplot -> outname , buf ) ; ignore = fscanf ( fp , ""Axis<S2SV_blank>scaling:<S2SV_blank>%d\\n"" , & gplot -> scaling ) ; fclose ( fp ) ; return gplot ; }","char buf [ L_BUFSIZE <S2SV_ModEnd> ] ; char <S2SV_ModStart> ( fp , ""Rootname:<S2SV_blank>%511s\\n"" <S2SV_ModEnd> , buf ) <S2SV_ModStart> ( buf , L_BUFSIZE <S2SV_ModEnd> , fp ) <S2SV_ModStart> ( buf , L_BUFSIZE <S2SV_ModEnd> , fp ) <S2SV_ModStart> ( buf , L_BUFSIZE <S2SV_ModEnd> , fp ) <S2SV_ModStart> ( fp , ""Commandfile<S2SV_blank>name:<S2SV_blank>%511s\\n"" <S2SV_ModEnd> , buf ) <S2SV_ModStart> ( fp , ""Output<S2SV_blank>file<S2SV_blank>name:<S2SV_blank>%511s\\n"" <S2SV_ModEnd> , buf )"
182,"void virtio_config_writeb ( VirtIODevice * vdev , uint32_t addr , uint32_t data ) { VirtioDeviceClass * k = VIRTIO_DEVICE_GET_CLASS ( vdev ) ; uint8_t val = data ; <S2SV_StartBug> if ( addr > ( vdev -> config_len - sizeof ( val ) ) ) <S2SV_EndBug> return ; stb_p ( vdev -> config + addr , val ) ; if ( k -> set_config ) { k -> set_config ( vdev , vdev -> config ) ; } }",if ( addr + <S2SV_ModEnd> sizeof ( val <S2SV_ModStart> ( val ) > vdev -> config_len ) { return ; } <S2SV_ModEnd> stb_p ( vdev
183,"void gdImageGifCtx ( gdImagePtr im , gdIOCtxPtr out ) { <S2SV_StartBug> gdImagePtr pim = 0 , tim = im ; <S2SV_EndBug> int interlace , BitsPerPixel ; interlace = im -> interlace ; if ( im -> trueColor ) { <S2SV_StartBug> pim = gdImageCreatePaletteFromTrueColor ( im , 1 , 256 ) ; <S2SV_EndBug> if ( ! pim ) { return ; } tim = pim ; } BitsPerPixel = colorstobpp ( tim -> colorsTotal ) ; GIFEncode ( out , tim -> sx , tim -> sy , tim -> interlace , 0 , tim -> transparent , BitsPerPixel , tim -> red , tim -> green , tim -> blue , tim ) ; if ( pim ) { gdImageDestroy ( pim ) ; } <S2SV_StartBug> } <S2SV_EndBug>","out ) { _gdImageGifCtx <S2SV_ModEnd> ( im , <S2SV_ModStart> ( im , out <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>"
184,"int rpmPackageFilesInstall ( rpmts ts , rpmte te , rpmfiles files , rpmpsm psm , char * * failedFile ) { FD_t payload = rpmtePayload ( te ) ; rpmfi fi = rpmfiNewArchiveReader ( payload , files , RPMFI_ITER_READ_ARCHIVE ) ; rpmfs fs = rpmteGetFileStates ( te ) ; rpmPlugins plugins = rpmtsPlugins ( ts ) ; struct stat sb ; int saveerrno = errno ; int rc = 0 ; int nodigest = ( rpmtsFlags ( ts ) & RPMTRANS_FLAG_NOFILEDIGEST ) ? 1 : 0 ; int nofcaps = ( rpmtsFlags ( ts ) & RPMTRANS_FLAG_NOCAPS ) ? 1 : 0 ; int firsthardlink = - 1 ; int skip ; rpmFileAction action ; char * tid = NULL ; const char * suffix ; char * fpath = NULL ; if ( fi == NULL ) { rc = RPMERR_BAD_MAGIC ; goto exit ; } rasprintf ( & tid , "";%08x"" , ( unsigned ) rpmtsGetTid ( ts ) ) ; rc = fsmMkdirs ( files , fs , plugins ) ; while ( ! rc ) { rc = rpmfiNext ( fi ) ; if ( rc < 0 ) { if ( rc == RPMERR_ITER_END ) rc = 0 ; break ; } action = rpmfsGetAction ( fs , rpmfiFX ( fi ) ) ; skip = XFA_SKIPPING ( action ) ; suffix = S_ISDIR ( rpmfiFMode ( fi ) ) ? NULL : tid ; if ( action != FA_TOUCH ) { fpath = fsmFsPath ( fi , suffix ) ; } else { fpath = fsmFsPath ( fi , """" ) ; } rc = rpmfiStat ( fi , 1 , & sb ) ; fsmDebug ( fpath , action , & sb ) ; if ( rc ) break ; rc = rpmpluginsCallFsmFilePre ( plugins , fi , fpath , sb . st_mode , action ) ; if ( rc ) { skip = 1 ; } else { setFileState ( fs , rpmfiFX ( fi ) ) ; } if ( ! skip ) { int setmeta = 1 ; if ( ! suffix ) { rc = fsmBackup ( fi , action ) ; } if ( ! suffix ) { <S2SV_StartBug> rc = fsmVerify ( fpath , fi ) ; <S2SV_EndBug> } else { rc = ( action == FA_TOUCH ) ? 0 : RPMERR_ENOENT ; } if ( S_ISREG ( sb . st_mode ) ) { if ( rc == RPMERR_ENOENT ) { rc = fsmMkfile ( fi , fpath , files , psm , nodigest , & setmeta , & firsthardlink ) ; } } else if ( S_ISDIR ( sb . st_mode ) ) { if ( rc == RPMERR_ENOENT ) { mode_t mode = sb . st_mode ; mode &= ~ 07777 ; mode |= 00700 ; rc = fsmMkdir ( fpath , mode ) ; } } else if ( S_ISLNK ( sb . st_mode ) ) { if ( rc == RPMERR_ENOENT ) { rc = fsmSymlink ( rpmfiFLink ( fi ) , fpath ) ; } } else if ( S_ISFIFO ( sb . st_mode ) ) { if ( rc == RPMERR_ENOENT ) { rc = fsmMkfifo ( fpath , 0000 ) ; } } else if ( S_ISCHR ( sb . st_mode ) || S_ISBLK ( sb . st_mode ) || S_ISSOCK ( sb . st_mode ) ) { if ( rc == RPMERR_ENOENT ) { rc = fsmMknod ( fpath , sb . st_mode , sb . st_rdev ) ; } } else { if ( ! IS_DEV_LOG ( fpath ) ) rc = RPMERR_UNKNOWN_FILETYPE ; } if ( ! rc && setmeta ) { rc = fsmSetmeta ( fpath , fi , plugins , action , & sb , nofcaps ) ; } } else if ( firsthardlink >= 0 && rpmfiArchiveHasContent ( fi ) ) { char * fn = rpmfilesFN ( files , firsthardlink ) ; rc = expandRegular ( fi , fn , psm , 0 , nodigest , 0 ) ; firsthardlink = - 1 ; free ( fn ) ; } if ( rc ) { if ( ! skip ) { if ( suffix && ( action != FA_TOUCH ) ) { ( void ) fsmRemove ( fpath , sb . st_mode ) ; } errno = saveerrno ; } } else { rpmpsmNotify ( psm , RPMCALLBACK_INST_PROGRESS , rpmfiArchiveTell ( fi ) ) ; if ( ! skip ) { if ( suffix ) rc = fsmBackup ( fi , action ) ; if ( ! rc ) rc = fsmCommit ( & fpath , fi , action , suffix ) ; } } if ( rc ) * failedFile = xstrdup ( fpath ) ; rpmpluginsCallFsmFilePost ( plugins , fi , fpath , sb . st_mode , action , rc ) ; fpath = _free ( fpath ) ; } rpmswAdd ( rpmtsOp ( ts , RPMTS_OP_UNCOMPRESS ) , fdOp ( payload , FDSTAT_READ ) ) ; rpmswAdd ( rpmtsOp ( ts , RPMTS_OP_DIGEST ) , fdOp ( payload , FDSTAT_DIGEST ) ) ; exit : rpmfiArchiveClose ( fi ) ; rpmfiFree ( fi ) ; Fclose ( payload ) ; free ( tid ) ; free ( fpath ) ; return rc ; }","fpath , fi , & sb"
185,"int ssl3_get_new_session_ticket ( SSL * s ) { int ok , al , ret = 0 , ticklen ; long n ; const unsigned char * p ; unsigned char * d ; n = s -> method -> ssl_get_message ( s , SSL3_ST_CR_SESSION_TICKET_A , SSL3_ST_CR_SESSION_TICKET_B , SSL3_MT_NEWSESSION_TICKET , 16384 , & ok ) ; if ( ! ok ) return ( ( int ) n ) ; if ( n < 6 ) { al = SSL_AD_DECODE_ERROR ; SSLerr ( SSL_F_SSL3_GET_NEW_SESSION_TICKET , SSL_R_LENGTH_MISMATCH ) ; goto f_err ; } p = d = ( unsigned char * ) s -> init_msg ; <S2SV_StartBug> n2l ( p , s -> session -> tlsext_tick_lifetime_hint ) ; <S2SV_EndBug> n2s ( p , ticklen ) ; if ( ticklen + 6 != n ) { al = SSL_AD_DECODE_ERROR ; SSLerr ( SSL_F_SSL3_GET_NEW_SESSION_TICKET , SSL_R_LENGTH_MISMATCH ) ; goto f_err ; } OPENSSL_free ( s -> session -> tlsext_tick ) ; s -> session -> tlsext_ticklen = 0 ; s -> session -> tlsext_tick = OPENSSL_malloc ( ticklen ) ; if ( ! s -> session -> tlsext_tick ) { SSLerr ( SSL_F_SSL3_GET_NEW_SESSION_TICKET , ERR_R_MALLOC_FAILURE ) ; goto err ; } memcpy ( s -> session -> tlsext_tick , p , ticklen ) ; s -> session -> tlsext_ticklen = ticklen ; EVP_Digest ( p , ticklen , s -> session -> session_id , & s -> session -> session_id_length , EVP_sha256 ( ) , NULL ) ; ret = 1 ; return ( ret ) ; f_err : ssl3_send_alert ( s , SSL3_AL_FATAL , al ) ; err : s -> state = SSL_ST_ERR ; return ( - 1 ) ; }","-> init_msg ; if ( s -> session -> session_id_length > 0 ) { int i = s -> session_ctx -> session_cache_mode ; SSL_SESSION * new_sess ; if ( i & SSL_SESS_CACHE_CLIENT ) { if ( i & SSL_SESS_CACHE_NO_INTERNAL_STORE ) { if ( s -> session_ctx -> remove_session_cb != NULL ) s -> session_ctx -> remove_session_cb ( s -> session_ctx , s -> session ) ; } else { SSL_CTX_remove_session ( s -> session_ctx , s -> session ) ; } } if ( ( new_sess = ssl_session_dup ( s -> session , 0 ) ) == 0 ) { al = SSL_AD_INTERNAL_ERROR ; SSLerr ( SSL_F_SSL3_GET_NEW_SESSION_TICKET , ERR_R_MALLOC_FAILURE ) ; goto f_err ; } SSL_SESSION_free ( s -> session ) ; s -> session = new_sess ; }"
186,"asmlinkage void kernel_unaligned_trap ( struct pt_regs * regs , unsigned int insn ) { enum direction dir = decode_direction ( insn ) ; int size = decode_access_size ( insn ) ; if ( ! ok_for_kernel ( insn ) || dir == both ) { printk ( ""Unsupported<S2SV_blank>unaligned<S2SV_blank>load/store<S2SV_blank>trap<S2SV_blank>for<S2SV_blank>kernel<S2SV_blank>at<S2SV_blank><%08lx>.\\n"" , regs -> pc ) ; unaligned_panic ( ""Wheee.<S2SV_blank>Kernel<S2SV_blank>does<S2SV_blank>fpu/atomic<S2SV_blank>unaligned<S2SV_blank>load/store."" ) ; } else { unsigned long addr = compute_effective_address ( regs , insn ) ; int err ; <S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , 0 , regs , addr ) ; <S2SV_EndBug> switch ( dir ) { case load : err = do_int_load ( fetch_reg_addr ( ( ( insn >> 25 ) & 0x1f ) , regs ) , size , ( unsigned long * ) addr , decode_signedness ( insn ) ) ; break ; case store : err = do_int_store ( ( ( insn >> 25 ) & 0x1f ) , size , ( unsigned long * ) addr , regs ) ; break ; default : panic ( ""Impossible<S2SV_blank>kernel<S2SV_blank>unaligned<S2SV_blank>trap."" ) ; } if ( err ) kernel_mna_trap_fault ( regs , insn ) ; else advance ( regs ) ; } }",", 1 , <S2SV_ModEnd> regs , addr"
187,"static enum led_brightness k90_backlight_get ( struct led_classdev * led_cdev ) { int ret ; struct k90_led * led = container_of ( led_cdev , struct k90_led , cdev ) ; struct device * dev = led -> cdev . dev -> parent ; struct usb_interface * usbif = to_usb_interface ( dev -> parent ) ; struct usb_device * usbdev = interface_to_usbdev ( usbif ) ; int brightness ; <S2SV_StartBug> char data [ 8 ] ; <S2SV_EndBug> ret = usb_control_msg ( usbdev , usb_rcvctrlpipe ( usbdev , 0 ) , K90_REQUEST_STATUS , USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE , 0 , 0 , data , 8 , USB_CTRL_SET_TIMEOUT ) ; if ( ret < 0 ) { dev_warn ( dev , ""Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>K90<S2SV_blank>initial<S2SV_blank>state<S2SV_blank>(error<S2SV_blank>%d).\\n"" , ret ) ; <S2SV_StartBug> return - EIO ; <S2SV_EndBug> } brightness = data [ 4 ] ; if ( brightness < 0 || brightness > 3 ) { dev_warn ( dev , ""Read<S2SV_blank>invalid<S2SV_blank>backlight<S2SV_blank>brightness:<S2SV_blank>%02hhx.\\n"" , data [ 4 ] ) ; <S2SV_StartBug> return - EIO ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> return brightness ; }","brightness ; char * data ; data = kmalloc ( 8 , GFP_KERNEL ) ; if ( ! data ) return - ENOMEM <S2SV_ModEnd> ; ret = <S2SV_ModStart> ret ) ; ret = - EIO ; goto out <S2SV_ModEnd> ; } brightness <S2SV_ModStart> ] ) ; ret = <S2SV_ModEnd> - EIO ; <S2SV_ModStart> - EIO ; goto out ; } ret = brightness ; out : kfree ( data ) ; return ret <S2SV_ModEnd> ; } <S2SV_null>"
188,"static int parse_report ( transport_smart * transport , git_push * push ) { git_pkt * pkt = NULL ; const char * line_end = NULL ; gitno_buffer * buf = & transport -> buffer ; int error , recvd ; git_buf data_pkt_buf = GIT_BUF_INIT ; for ( ; ; ) { if ( buf -> offset > 0 ) error = git_pkt_parse_line ( & pkt , buf -> data , & line_end , buf -> offset ) ; else error = GIT_EBUFS ; if ( error < 0 && error != GIT_EBUFS ) { error = - 1 ; goto done ; } if ( error == GIT_EBUFS ) { if ( ( recvd = gitno_recv ( buf ) ) < 0 ) { error = recvd ; goto done ; } if ( recvd == 0 ) { giterr_set ( GITERR_NET , ""early<S2SV_blank>EOF"" ) ; error = GIT_EEOF ; goto done ; } continue ; } gitno_consume ( buf , line_end ) ; <S2SV_StartBug> error = 0 ; <S2SV_EndBug> if ( pkt == NULL ) continue ; switch ( pkt -> type ) { case GIT_PKT_DATA : error = add_push_report_sideband_pkt ( push , ( git_pkt_data * ) pkt , & data_pkt_buf ) ; break ; case GIT_PKT_ERR : giterr_set ( GITERR_NET , ""report-status:<S2SV_blank>Error<S2SV_blank>reported:<S2SV_blank>%s"" , ( ( git_pkt_err * ) pkt ) -> error ) ; error = - 1 ; break ; case GIT_PKT_PROGRESS : if ( transport -> progress_cb ) { git_pkt_progress * p = ( git_pkt_progress * ) pkt ; error = transport -> progress_cb ( p -> data , p -> len , transport -> message_cb_payload ) ; } break ; default : error = add_push_report_pkt ( push , pkt ) ; break ; } git_pkt_free ( pkt ) ; if ( error == GIT_ITEROVER ) { error = 0 ; if ( data_pkt_buf . size > 0 ) { giterr_set ( GITERR_NET , ""Incomplete<S2SV_blank>pack<S2SV_blank>data<S2SV_blank>pkt-line"" ) ; error = GIT_ERROR ; } goto done ; } if ( error < 0 ) { goto done ; } } done : git_buf_free ( & data_pkt_buf ) ; return error ; }",error = 0 <S2SV_ModEnd> ; switch (
189,"enum ImapAuthRes imap_auth_login ( struct ImapData * idata , const char * method ) { char q_user [ SHORT_STRING ] , q_pass [ SHORT_STRING ] ; char buf [ STRING ] ; int rc ; if ( mutt_bit_isset ( idata -> capabilities , LOGINDISABLED ) ) { mutt_message ( _ ( ""LOGIN<S2SV_blank>disabled<S2SV_blank>on<S2SV_blank>this<S2SV_blank>server."" ) ) ; return IMAP_AUTH_UNAVAIL ; } if ( mutt_account_getuser ( & idata -> conn -> account ) < 0 ) return IMAP_AUTH_FAILURE ; if ( mutt_account_getpass ( & idata -> conn -> account ) < 0 ) return IMAP_AUTH_FAILURE ; mutt_message ( _ ( ""Logging<S2SV_blank>in..."" ) ) ; <S2SV_StartBug> imap_quote_string ( q_user , sizeof ( q_user ) , idata -> conn -> account . user ) ; <S2SV_EndBug> <S2SV_StartBug> imap_quote_string ( q_pass , sizeof ( q_pass ) , idata -> conn -> account . pass ) ; <S2SV_EndBug> if ( DebugLevel < IMAP_LOG_PASS ) mutt_debug ( 2 , ""Sending<S2SV_blank>LOGIN<S2SV_blank>command<S2SV_blank>for<S2SV_blank>%s...\\n"" , idata -> conn -> account . user ) ; snprintf ( buf , sizeof ( buf ) , ""LOGIN<S2SV_blank>%s<S2SV_blank>%s"" , q_user , q_pass ) ; rc = imap_exec ( idata , buf , IMAP_CMD_FAIL_OK | IMAP_CMD_PASS ) ; if ( ! rc ) { mutt_clear_error ( ) ; return IMAP_AUTH_SUCCESS ; } mutt_error ( _ ( ""Login<S2SV_blank>failed."" ) ) ; return IMAP_AUTH_FAILURE ; }","account . user , false <S2SV_ModStart> account . pass , false"
190,"static int xen_netbk_get_extras ( struct xenvif * vif , struct xen_netif_extra_info * extras , int work_to_do ) { struct xen_netif_extra_info extra ; RING_IDX cons = vif -> tx . req_cons ; do { if ( unlikely ( work_to_do -- <= 0 ) ) { <S2SV_StartBug> netdev_dbg ( vif -> dev , ""Missing<S2SV_blank>extra<S2SV_blank>info\\n"" ) ; <S2SV_EndBug> return - EBADR ; } memcpy ( & extra , RING_GET_REQUEST ( & vif -> tx , cons ) , sizeof ( extra ) ) ; if ( unlikely ( ! extra . type || extra . type >= XEN_NETIF_EXTRA_TYPE_MAX ) ) { vif -> tx . req_cons = ++ cons ; <S2SV_StartBug> netdev_dbg ( vif -> dev , <S2SV_EndBug> <S2SV_StartBug> ""Invalid<S2SV_blank>extra<S2SV_blank>type:<S2SV_blank>%d\\n"" , extra . type ) ; <S2SV_EndBug> return - EINVAL ; } memcpy ( & extras [ extra . type - 1 ] , & extra , sizeof ( extra ) ) ; vif -> tx . req_cons = ++ cons ; } while ( extra . flags & XEN_NETIF_EXTRA_FLAG_MORE ) ; return work_to_do ; }",") ) { netdev_err <S2SV_ModEnd> ( vif -> <S2SV_ModStart> dev , ""Missing<S2SV_blank>extra<S2SV_blank>info\\n"" ) ; netbk_fatal_tx_err ( vif <S2SV_ModStart> ++ cons ; netdev_err <S2SV_ModEnd> ( vif -> <S2SV_ModStart> extra . type ) ; netbk_fatal_tx_err ( vif"
191,"int print_calc ( image_desc_t * im ) { long i , ii , validsteps ; double printval ; struct tm tmvdef ; int graphelement = 0 ; long vidx ; int max_ii ; double magfact = - 1 ; char * si_symb = """" ; char * percent_s ; int prline_cnt = 0 ; time_t now = time ( NULL ) ; localtime_r ( & now , & tmvdef ) ; for ( i = 0 ; i < im -> gdes_c ; i ++ ) { vidx = im -> gdes [ i ] . vidx ; switch ( im -> gdes [ i ] . gf ) { case GF_PRINT : case GF_GPRINT : if ( im -> gdes [ vidx ] . gf == GF_VDEF ) { printval = im -> gdes [ vidx ] . vf . val ; localtime_r ( & im -> gdes [ vidx ] . vf . when , & tmvdef ) ; } else { max_ii = ( ( im -> gdes [ vidx ] . end - im -> gdes [ vidx ] . start ) / im -> gdes [ vidx ] . step * im -> gdes [ vidx ] . ds_cnt ) ; printval = DNAN ; validsteps = 0 ; for ( ii = im -> gdes [ vidx ] . ds ; ii < max_ii ; ii += im -> gdes [ vidx ] . ds_cnt ) { if ( ! finite ( im -> gdes [ vidx ] . data [ ii ] ) ) continue ; if ( isnan ( printval ) ) { printval = im -> gdes [ vidx ] . data [ ii ] ; validsteps ++ ; continue ; } switch ( im -> gdes [ i ] . cf ) { case CF_HWPREDICT : case CF_MHWPREDICT : case CF_DEVPREDICT : case CF_DEVSEASONAL : case CF_SEASONAL : case CF_AVERAGE : validsteps ++ ; printval += im -> gdes [ vidx ] . data [ ii ] ; break ; case CF_MINIMUM : printval = min ( printval , im -> gdes [ vidx ] . data [ ii ] ) ; break ; case CF_FAILURES : case CF_MAXIMUM : printval = max ( printval , im -> gdes [ vidx ] . data [ ii ] ) ; break ; case CF_LAST : printval = im -> gdes [ vidx ] . data [ ii ] ; } } if ( im -> gdes [ i ] . cf == CF_AVERAGE || im -> gdes [ i ] . cf > CF_LAST ) { if ( validsteps > 1 ) { printval = ( printval / validsteps ) ; } } } if ( ! im -> gdes [ i ] . strftm && ( percent_s = strstr ( im -> gdes [ i ] . format , ""%S"" ) ) != NULL ) { if ( magfact < 0.0 ) { auto_scale ( im , & printval , & si_symb , & magfact ) ; if ( printval == 0.0 ) magfact = - 1.0 ; } else { printval /= magfact ; } * ( ++ percent_s ) = 's' ; } else if ( ! im -> gdes [ i ] . strftm && strstr ( im -> gdes [ i ] . format , ""%s"" ) != NULL ) { auto_scale ( im , & printval , & si_symb , & magfact ) ; } if ( im -> gdes [ i ] . gf == GF_PRINT ) { rrd_infoval_t prline ; if ( im -> gdes [ i ] . strftm ) { prline . u_str = ( char * ) malloc ( ( FMT_LEG_LEN + 2 ) * sizeof ( char ) ) ; strftime ( prline . u_str , FMT_LEG_LEN , im -> gdes [ i ] . format , & tmvdef ) ; <S2SV_StartBug> } else if ( bad_format ( im -> gdes [ i ] . format ) ) { <S2SV_EndBug> <S2SV_StartBug> rrd_set_error <S2SV_EndBug> ( ""bad<S2SV_blank>format<S2SV_blank>for<S2SV_blank>PRINT<S2SV_blank>in<S2SV_blank>\'%s\'"" , im -> gdes [ i ] . format ) ; return - 1 ; } else { prline . u_str = sprintf_alloc ( im -> gdes [ i ] . format , printval , si_symb ) ; } grinfo_push ( im , sprintf_alloc ( ""print[%ld]"" , prline_cnt ++ ) , RD_I_STR , prline ) ; free ( prline . u_str ) ; } else { if ( im -> gdes [ i ] . strftm ) { strftime ( im -> gdes [ i ] . legend , FMT_LEG_LEN , im -> gdes [ i ] . format , & tmvdef ) ; } else { <S2SV_StartBug> if ( bad_format ( im -> gdes [ i ] . format ) ) { <S2SV_EndBug> <S2SV_StartBug> rrd_set_error <S2SV_EndBug> ( ""bad<S2SV_blank>format<S2SV_blank>for<S2SV_blank>GPRINT<S2SV_blank>in<S2SV_blank>\'%s\'"" , im -> gdes [ i ] . format ) ; return - 1 ; } # ifdef HAVE_SNPRINTF snprintf ( im -> gdes [ i ] . legend , FMT_LEG_LEN - 2 , im -> gdes [ i ] . format , printval , si_symb ) ; # else sprintf ( im -> gdes [ i ] . legend , im -> gdes [ i ] . format , printval , si_symb ) ; # endif } graphelement = 1 ; } break ; case GF_LINE : case GF_AREA : case GF_TICK : graphelement = 1 ; break ; case GF_HRULE : if ( isnan ( im -> gdes [ i ] . yrule ) ) { im -> gdes [ i ] . yrule = im -> gdes [ vidx ] . vf . val ; } ; graphelement = 1 ; break ; case GF_VRULE : if ( im -> gdes [ i ] . xrule == 0 ) { im -> gdes [ i ] . xrule = im -> gdes [ vidx ] . vf . when ; } ; graphelement = 1 ; break ; case GF_COMMENT : case GF_TEXTALIGN : case GF_DEF : case GF_CDEF : case GF_VDEF : # ifdef WITH_PIECHART case GF_PART : # endif case GF_SHIFT : case GF_XPORT : break ; case GF_STACK : rrd_set_error ( ""STACK<S2SV_blank>should<S2SV_blank>already<S2SV_blank>be<S2SV_blank>turned<S2SV_blank>into<S2SV_blank>LINE<S2SV_blank>or<S2SV_blank>AREA<S2SV_blank>here"" ) ; return - 1 ; break ; } } return graphelement ; }",else if ( bad_format_print <S2SV_ModEnd> ( im -> <S2SV_ModStart> ) ) { <S2SV_ModEnd> return - 1 <S2SV_ModStart> { if ( bad_format_print <S2SV_ModEnd> ( im -> <S2SV_ModStart> ) ) { <S2SV_ModEnd> return - 1
192,"void __detach_mounts ( struct dentry * dentry ) { struct mountpoint * mp ; struct mount * mnt ; namespace_lock ( ) ; mp = lookup_mountpoint ( dentry ) ; if ( ! mp ) goto out_unlock ; lock_mount_hash ( ) ; while ( ! hlist_empty ( & mp -> m_list ) ) { mnt = hlist_entry ( mp -> m_list . first , struct mount , mnt_mp_list ) ; <S2SV_StartBug> umount_tree ( mnt , 0 ) ; <S2SV_EndBug> } unlock_mount_hash ( ) ; put_mountpoint ( mp ) ; out_unlock : namespace_unlock ( ) ; }","mnt_mp_list ) ; if ( mnt -> mnt . mnt_flags & MNT_UMOUNT ) { struct mount * p , * tmp ; list_for_each_entry_safe ( p , tmp , & mnt -> mnt_mounts , mnt_child ) { hlist_add_head ( & p -> mnt_umount . s_list , & unmounted ) ; umount_mnt ( p ) ; } } else"
193,"agooCon agoo_con_create ( agooErr err , int sock , uint64_t id , agooBind b ) { agooCon c ; if ( NULL == ( c = ( agooCon ) AGOO_CALLOC ( 1 , sizeof ( struct _agooCon ) ) ) ) { AGOO_ERR_MEM ( err , ""Connection"" ) ; } else { <S2SV_StartBug> c -> sock = sock ; <S2SV_EndBug> c -> id = id ; c -> timeout = dtime ( ) + CON_TIMEOUT ; c -> bind = b ; c -> loop = NULL ; pthread_mutex_init ( & c -> res_lock , 0 ) ; } return c ; }","} else { struct sockaddr_storage addr ; socklen_t len = sizeof ( addr ) ; getpeername ( sock , ( struct sockaddr * ) & addr , & len ) ; if ( addr . ss_family == AF_INET ) { struct sockaddr_in * s = ( struct sockaddr_in * ) & addr ; inet_ntop ( AF_INET , & s -> sin_addr , c -> remote , sizeof ( c -> remote ) ) ; } else { struct sockaddr_in6 * s = ( struct sockaddr_in6 * ) & addr ; inet_ntop ( AF_INET6 , & s -> sin6_addr , c -> remote , sizeof ( c -> remote ) ) ; }"
194,"static int find_best_16x16_intra ( VP9_COMP * cpi , <S2SV_StartBug> MB_PREDICTION_MODE * pbest_mode ) { <S2SV_EndBug> <S2SV_StartBug> MACROBLOCK * const x = & cpi -> mb ; <S2SV_EndBug> MACROBLOCKD * const xd = & x -> e_mbd ; <S2SV_StartBug> MB_PREDICTION_MODE best_mode = - 1 , mode ; <S2SV_EndBug> unsigned int best_err = INT_MAX ; for ( mode = DC_PRED ; mode <= TM_PRED ; mode ++ ) { unsigned int err ; xd -> mi [ 0 ] -> mbmi . mode = mode ; <S2SV_StartBug> vp9_predict_intra_block ( xd , 0 , 2 , TX_16X16 , mode , <S2SV_EndBug> x -> plane [ 0 ] . src . buf , x -> plane [ 0 ] . src . stride , xd -> plane [ 0 ] . dst . buf , xd -> plane [ 0 ] . dst . stride , 0 , 0 , 0 ) ; <S2SV_StartBug> err = vp9_sad16x16 ( x -> plane [ 0 ] . src . buf , x -> plane [ 0 ] . src . stride , <S2SV_EndBug> xd -> plane [ 0 ] . dst . buf , xd -> plane [ 0 ] . dst . stride , best_err ) ; if ( err < best_err ) { best_err = err ; best_mode = mode ; } } if ( pbest_mode ) * pbest_mode = best_mode ; return best_err ; }","* cpi , PREDICTION_MODE <S2SV_ModEnd> * pbest_mode ) <S2SV_ModStart> & cpi -> td . <S2SV_ModStart> -> e_mbd ; PREDICTION_MODE <S2SV_ModEnd> best_mode = - <S2SV_ModStart> ( xd , <S2SV_ModEnd> 2 , TX_16X16 <S2SV_ModStart> ; err = vpx_sad16x16 ( x -> plane [ 0 ] . src . buf , x -> plane [ 0 ] . src . stride , xd -> plane [ 0 ] . dst . buf , xd -> plane [ 0 ] . dst . stride <S2SV_ModEnd> ) ; if"
195,"int main ( int argc , char * argv [ ] ) { int i , c ; FILE * ifp = 0 , * ofp = 0 ; const char * ifp_filename = ""<stdin>"" ; const char * ofp_filename = ""<stdout>"" ; const char * set_font_name = 0 ; struct font_reader fr ; uint32_t rfork_len ; int raw = 0 , macbinary = 1 , applesingle = 0 , appledouble = 0 , binhex = 0 ; Clp_Parser * clp = Clp_NewParser ( argc , ( const char * const * ) argv , sizeof ( options ) / sizeof ( options [ 0 ] ) , options ) ; program_name = Clp_ProgramName ( clp ) ; while ( 1 ) { int opt = Clp_Next ( clp ) ; switch ( opt ) { case RAW_OPT : raw = 1 ; macbinary = applesingle = appledouble = binhex = 0 ; break ; case MACBINARY_OPT : macbinary = 1 ; raw = applesingle = appledouble = binhex = 0 ; break ; case APPLESINGLE_OPT : applesingle = 1 ; raw = macbinary = appledouble = binhex = 0 ; break ; case APPLEDOUBLE_OPT : appledouble = 1 ; raw = macbinary = applesingle = binhex = 0 ; break ; case BINHEX_OPT : binhex = 1 ; raw = macbinary = applesingle = appledouble = 0 ; break ; output_file : case OUTPUT_OPT : if ( ofp ) fatal_error ( ""output<S2SV_blank>file<S2SV_blank>already<S2SV_blank>specified"" ) ; if ( strcmp ( clp -> vstr , ""-"" ) == 0 ) ofp = stdout ; else { ofp_filename = clp -> vstr ; ofp = fopen ( ofp_filename , ""wb"" ) ; if ( ! ofp ) fatal_error ( ""%s:<S2SV_blank>%s"" , ofp_filename , strerror ( errno ) ) ; } break ; case FILENAME_OPT : if ( set_font_name ) fatal_error ( ""Macintosh<S2SV_blank>font<S2SV_blank>filename<S2SV_blank>already<S2SV_blank>specified"" ) ; set_font_name = clp -> vstr ; break ; case HELP_OPT : usage ( ) ; exit ( 0 ) ; break ; case VERSION_OPT : printf ( ""t1mac<S2SV_blank>(LCDF<S2SV_blank>t1utils)<S2SV_blank>%s\\n"" , VERSION ) ; <S2SV_StartBug> printf ( ""Copyright<S2SV_blank>(C)<S2SV_blank>2000-2010<S2SV_blank>Eddie<S2SV_blank>Kohler<S2SV_blank>et<S2SV_blank>al.\\n\\\n<S2SV_blank>This<S2SV_blank>is<S2SV_blank>free<S2SV_blank>software;<S2SV_blank>see<S2SV_blank>the<S2SV_blank>source<S2SV_blank>for<S2SV_blank>copying<S2SV_blank>conditions.\\n\\\n<S2SV_blank>There<S2SV_blank>is<S2SV_blank>NO<S2SV_blank>warranty,<S2SV_blank>not<S2SV_blank>even<S2SV_blank>for<S2SV_blank>merchantability<S2SV_blank>or<S2SV_blank>fitness<S2SV_blank>for<S2SV_blank>a\\n\\\n<S2SV_blank>particular<S2SV_blank>purpose.\\n"" ) ; <S2SV_EndBug> exit ( 0 ) ; break ; case Clp_NotOption : if ( ifp && ofp ) fatal_error ( ""too<S2SV_blank>many<S2SV_blank>arguments"" ) ; else if ( ifp ) goto output_file ; if ( strcmp ( clp -> vstr , ""-"" ) == 0 ) ifp = stdin ; else { ifp_filename = clp -> vstr ; ifp = fopen ( clp -> vstr , ""r"" ) ; if ( ! ifp ) fatal_error ( ""%s:<S2SV_blank>%s"" , clp -> vstr , strerror ( errno ) ) ; } break ; case Clp_Done : goto done ; case Clp_BadOption : short_usage ( ) ; exit ( 1 ) ; break ; } } done : if ( ! ifp ) ifp = stdin ; if ( ! ofp ) ofp = stdout ; # if defined ( _MSDOS ) || defined ( _WIN32 ) _setmode ( _fileno ( ofp ) , _O_BINARY ) ; # endif fr . output_ascii = t1mac_output_ascii ; fr . output_binary = t1mac_output_binary ; fr . output_end = t1mac_output_end ; rfork_f = tmpfile ( ) ; if ( ! rfork_f ) fatal_error ( ""cannot<S2SV_blank>open<S2SV_blank>temorary<S2SV_blank>file:<S2SV_blank>%s"" , strerror ( errno ) ) ; for ( i = 0 ; i < RFORK_HEADERLEN ; i ++ ) putc ( 0 , rfork_f ) ; init_current_post ( ) ; c = getc ( ifp ) ; ungetc ( c , ifp ) ; if ( c == PFB_MARKER ) process_pfb ( ifp , ifp_filename , & fr ) ; else if ( c == '%' ) process_pfa ( ifp , ifp_filename , & fr ) ; else fatal_error ( ""%s<S2SV_blank>does<S2SV_blank>not<S2SV_blank>start<S2SV_blank>with<S2SV_blank>font<S2SV_blank>marker<S2SV_blank>(`%%\'<S2SV_blank>or<S2SV_blank>0x80)"" , ifp_filename ) ; if ( ifp != stdin ) fclose ( ifp ) ; if ( nrsrc == 0 ) error ( ""no<S2SV_blank>POST<S2SV_blank>resources<S2SV_blank>written<S2SV_blank>--<S2SV_blank>are<S2SV_blank>you<S2SV_blank>sure<S2SV_blank>this<S2SV_blank>was<S2SV_blank>a<S2SV_blank>font?"" ) ; output_new_rsrc ( ""ICN#"" , 256 , 32 , ( const char * ) icon_bw_data , 256 ) ; output_new_rsrc ( ""FREF"" , 256 , 32 , ""LWFN\\0\\0\\0"" , 7 ) ; output_new_rsrc ( ""BNDL"" , 256 , 32 , ""T1UT\\0\\0\\0\\1FREF\\0\\0\\0\\0\\1\\0ICN#\\0\\0\\0\\0\\1\\0"" , 28 ) ; output_new_rsrc ( ""icl8"" , 256 , 32 , ( const char * ) icon_8_data , 1024 ) ; output_new_rsrc ( ""icl4"" , 256 , 32 , ( const char * ) icon_4_data , 512 ) ; output_new_rsrc ( ""ics#"" , 256 , 32 , ( const char * ) small_icon_bw_data , 64 ) ; output_new_rsrc ( ""ics8"" , 256 , 32 , ( const char * ) small_icon_8_data , 256 ) ; output_new_rsrc ( ""ics4"" , 256 , 32 , ( const char * ) small_icon_4_data , 128 ) ; output_new_rsrc ( ""T1UT"" , 0 , 0 , ""DConverted<S2SV_blank>by<S2SV_blank>t1mac<S2SV_blank>(t1utils)<S2SV_blank>\\251Eddie<S2SV_blank>Kohler<S2SV_blank>http://www.lcdf.org/type/"" , 69 ) ; rfork_len = complete_rfork ( ) ; if ( ! set_font_name && font_name ) { int part = 0 , len = 0 ; char * x , * s ; for ( x = s = font_name ; * s ; s ++ ) <S2SV_StartBug> if ( isupper ( * s ) || isdigit ( * s ) ) { <S2SV_EndBug> * x ++ = * s ; part ++ ; len = 1 ; <S2SV_StartBug> } else if ( islower ( * s ) ) { <S2SV_EndBug> if ( len < ( part <= 1 ? 5 : 3 ) ) * x ++ = * s ; len ++ ; } * x ++ = 0 ; set_font_name = font_name ; } else if ( ! set_font_name ) set_font_name = ""Unknown<S2SV_blank>Font"" ; if ( macbinary ) output_macbinary ( rfork_f , rfork_len , set_font_name , ofp ) ; else if ( raw ) output_raw ( rfork_f , rfork_len , ofp ) ; else if ( applesingle || appledouble ) output_applesingle ( rfork_f , rfork_len , set_font_name , ofp , appledouble ) ; else if ( binhex ) output_binhex ( rfork_f , rfork_len , set_font_name , ofp ) ; else fatal_error ( ""strange<S2SV_blank>output<S2SV_blank>format"" ) ; fclose ( rfork_f ) ; if ( ofp != stdout ) fclose ( ofp ) ; return 0 ; }","; printf ( ""Copyright<S2SV_blank>(C)<S2SV_blank>2000-2010<S2SV_blank>Eddie<S2SV_blank>Kohler<S2SV_blank>et<S2SV_blank>al.\\n\\\nThis<S2SV_blank>is<S2SV_blank>free<S2SV_blank>software;<S2SV_blank>see<S2SV_blank>the<S2SV_blank>source<S2SV_blank>for<S2SV_blank>copying<S2SV_blank>conditions.\\n\\\nThere<S2SV_blank>is<S2SV_blank>NO<S2SV_blank>warranty,<S2SV_blank>not<S2SV_blank>even<S2SV_blank>for<S2SV_blank>merchantability<S2SV_blank>or<S2SV_blank>fitness<S2SV_blank>for<S2SV_blank>a\\n\\\nparticular<S2SV_blank>purpose.\\n"" <S2SV_ModEnd> ) ; exit <S2SV_ModStart> ( isupper ( ( unsigned char ) <S2SV_ModStart> || isdigit ( ( unsigned char ) <S2SV_ModStart> ( islower ( ( unsigned char )"
196,"int ip6_append_data ( struct sock * sk , int getfrag ( void * from , char * to , int offset , int len , int odd , struct sk_buff * skb ) , void * from , int length , int transhdrlen , int hlimit , int tclass , struct ipv6_txoptions * opt , struct flowi6 * fl6 , struct rt6_info * rt , unsigned int flags , int dontfrag ) { struct inet_sock * inet = inet_sk ( sk ) ; struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct inet_cork * cork ; struct sk_buff * skb ; unsigned int maxfraglen , fragheaderlen ; int exthdrlen ; int hh_len ; int mtu ; int copy ; int err ; int offset = 0 ; int csummode = CHECKSUM_NONE ; __u8 tx_flags = 0 ; if ( flags & MSG_PROBE ) return 0 ; cork = & inet -> cork . base ; if ( skb_queue_empty ( & sk -> sk_write_queue ) ) { if ( opt ) { if ( WARN_ON ( np -> cork . opt ) ) return - EINVAL ; np -> cork . opt = kmalloc ( opt -> tot_len , sk -> sk_allocation ) ; if ( unlikely ( np -> cork . opt == NULL ) ) return - ENOBUFS ; np -> cork . opt -> tot_len = opt -> tot_len ; np -> cork . opt -> opt_flen = opt -> opt_flen ; np -> cork . opt -> opt_nflen = opt -> opt_nflen ; np -> cork . opt -> dst0opt = ip6_opt_dup ( opt -> dst0opt , sk -> sk_allocation ) ; if ( opt -> dst0opt && ! np -> cork . opt -> dst0opt ) return - ENOBUFS ; np -> cork . opt -> dst1opt = ip6_opt_dup ( opt -> dst1opt , sk -> sk_allocation ) ; if ( opt -> dst1opt && ! np -> cork . opt -> dst1opt ) return - ENOBUFS ; np -> cork . opt -> hopopt = ip6_opt_dup ( opt -> hopopt , sk -> sk_allocation ) ; if ( opt -> hopopt && ! np -> cork . opt -> hopopt ) return - ENOBUFS ; np -> cork . opt -> srcrt = ip6_rthdr_dup ( opt -> srcrt , sk -> sk_allocation ) ; if ( opt -> srcrt && ! np -> cork . opt -> srcrt ) return - ENOBUFS ; } dst_hold ( & rt -> dst ) ; cork -> dst = & rt -> dst ; inet -> cork . fl . u . ip6 = * fl6 ; np -> cork . hop_limit = hlimit ; np -> cork . tclass = tclass ; mtu = np -> pmtudisc == IPV6_PMTUDISC_PROBE ? rt -> dst . dev -> mtu : dst_mtu ( rt -> dst . path ) ; if ( np -> frag_size < mtu ) { if ( np -> frag_size ) mtu = np -> frag_size ; } cork -> fragsize = mtu ; if ( dst_allfrag ( rt -> dst . path ) ) cork -> flags |= IPCORK_ALLFRAG ; cork -> length = 0 ; sk -> sk_sndmsg_page = NULL ; sk -> sk_sndmsg_off = 0 ; exthdrlen = rt -> dst . header_len + ( opt ? opt -> opt_flen : 0 ) - rt -> rt6i_nfheader_len ; length += exthdrlen ; transhdrlen += exthdrlen ; } else { rt = ( struct rt6_info * ) cork -> dst ; fl6 = & inet -> cork . fl . u . ip6 ; opt = np -> cork . opt ; transhdrlen = 0 ; exthdrlen = 0 ; mtu = cork -> fragsize ; } hh_len = LL_RESERVED_SPACE ( rt -> dst . dev ) ; fragheaderlen = sizeof ( struct ipv6hdr ) + rt -> rt6i_nfheader_len + ( opt ? opt -> opt_nflen : 0 ) ; maxfraglen = ( ( mtu - fragheaderlen ) & ~ 7 ) + fragheaderlen - sizeof ( struct frag_hdr ) ; if ( mtu <= sizeof ( struct ipv6hdr ) + IPV6_MAXPLEN ) { if ( cork -> length + length > sizeof ( struct ipv6hdr ) + IPV6_MAXPLEN - fragheaderlen ) { ipv6_local_error ( sk , EMSGSIZE , fl6 , mtu - exthdrlen ) ; return - EMSGSIZE ; } } if ( sk -> sk_type == SOCK_DGRAM ) { err = sock_tx_timestamp ( sk , & tx_flags ) ; if ( err ) goto error ; } cork -> length += length ; if ( length > mtu ) { int proto = sk -> sk_protocol ; if ( dontfrag && ( proto == IPPROTO_UDP || proto == IPPROTO_RAW ) ) { ipv6_local_rxpmtu ( sk , fl6 , mtu - exthdrlen ) ; return - EMSGSIZE ; } if ( proto == IPPROTO_UDP && ( rt -> dst . dev -> features & NETIF_F_UFO ) ) { err = ip6_ufo_append_data ( sk , getfrag , from , length , hh_len , fragheaderlen , <S2SV_StartBug> transhdrlen , mtu , flags ) ; <S2SV_EndBug> if ( err ) goto error ; return 0 ; } } if ( ( skb = skb_peek_tail ( & sk -> sk_write_queue ) ) == NULL ) goto alloc_new_skb ; while ( length > 0 ) { copy = ( cork -> length <= mtu && ! ( cork -> flags & IPCORK_ALLFRAG ) ? mtu : maxfraglen ) - skb -> len ; if ( copy < length ) copy = maxfraglen - skb -> len ; if ( copy <= 0 ) { char * data ; unsigned int datalen ; unsigned int fraglen ; unsigned int fraggap ; unsigned int alloclen ; struct sk_buff * skb_prev ; alloc_new_skb : skb_prev = skb ; if ( skb_prev ) fraggap = skb_prev -> len - maxfraglen ; else fraggap = 0 ; datalen = length + fraggap ; if ( datalen > ( cork -> length <= mtu && ! ( cork -> flags & IPCORK_ALLFRAG ) ? mtu : maxfraglen ) - fragheaderlen ) datalen = maxfraglen - fragheaderlen ; fraglen = datalen + fragheaderlen ; if ( ( flags & MSG_MORE ) && ! ( rt -> dst . dev -> features & NETIF_F_SG ) ) alloclen = mtu ; else alloclen = datalen + fragheaderlen ; if ( datalen == length + fraggap ) alloclen += rt -> dst . trailer_len ; alloclen += sizeof ( struct frag_hdr ) ; if ( transhdrlen ) { skb = sock_alloc_send_skb ( sk , alloclen + hh_len , ( flags & MSG_DONTWAIT ) , & err ) ; } else { skb = NULL ; if ( atomic_read ( & sk -> sk_wmem_alloc ) <= 2 * sk -> sk_sndbuf ) skb = sock_wmalloc ( sk , alloclen + hh_len , 1 , sk -> sk_allocation ) ; if ( unlikely ( skb == NULL ) ) err = - ENOBUFS ; else { tx_flags = 0 ; } } if ( skb == NULL ) goto error ; skb -> ip_summed = csummode ; skb -> csum = 0 ; skb_reserve ( skb , hh_len + sizeof ( struct frag_hdr ) ) ; if ( sk -> sk_type == SOCK_DGRAM ) skb_shinfo ( skb ) -> tx_flags = tx_flags ; data = skb_put ( skb , fraglen ) ; skb_set_network_header ( skb , exthdrlen ) ; data += fragheaderlen ; skb -> transport_header = ( skb -> network_header + fragheaderlen ) ; if ( fraggap ) { skb -> csum = skb_copy_and_csum_bits ( skb_prev , maxfraglen , data + transhdrlen , fraggap , 0 ) ; skb_prev -> csum = csum_sub ( skb_prev -> csum , skb -> csum ) ; data += fraggap ; pskb_trim_unique ( skb_prev , maxfraglen ) ; } copy = datalen - transhdrlen - fraggap ; if ( copy < 0 ) { err = - EINVAL ; kfree_skb ( skb ) ; goto error ; } else if ( copy > 0 && getfrag ( from , data + transhdrlen , offset , copy , fraggap , skb ) < 0 ) { err = - EFAULT ; kfree_skb ( skb ) ; goto error ; } offset += copy ; length -= datalen - fraggap ; transhdrlen = 0 ; exthdrlen = 0 ; csummode = CHECKSUM_NONE ; __skb_queue_tail ( & sk -> sk_write_queue , skb ) ; continue ; } if ( copy > length ) copy = length ; if ( ! ( rt -> dst . dev -> features & NETIF_F_SG ) ) { unsigned int off ; off = skb -> len ; if ( getfrag ( from , skb_put ( skb , copy ) , offset , copy , off , skb ) < 0 ) { __skb_trim ( skb , off ) ; err = - EFAULT ; goto error ; } } else { int i = skb_shinfo ( skb ) -> nr_frags ; skb_frag_t * frag = & skb_shinfo ( skb ) -> frags [ i - 1 ] ; struct page * page = sk -> sk_sndmsg_page ; int off = sk -> sk_sndmsg_off ; unsigned int left ; if ( page && ( left = PAGE_SIZE - off ) > 0 ) { if ( copy >= left ) copy = left ; if ( page != frag -> page ) { if ( i == MAX_SKB_FRAGS ) { err = - EMSGSIZE ; goto error ; } get_page ( page ) ; skb_fill_page_desc ( skb , i , page , sk -> sk_sndmsg_off , 0 ) ; frag = & skb_shinfo ( skb ) -> frags [ i ] ; } } else if ( i < MAX_SKB_FRAGS ) { if ( copy > PAGE_SIZE ) copy = PAGE_SIZE ; page = alloc_pages ( sk -> sk_allocation , 0 ) ; if ( page == NULL ) { err = - ENOMEM ; goto error ; } sk -> sk_sndmsg_page = page ; sk -> sk_sndmsg_off = 0 ; skb_fill_page_desc ( skb , i , page , 0 , 0 ) ; frag = & skb_shinfo ( skb ) -> frags [ i ] ; } else { err = - EMSGSIZE ; goto error ; } if ( getfrag ( from , page_address ( frag -> page ) + frag -> page_offset + frag -> size , offset , copy , skb -> len , skb ) < 0 ) { err = - EFAULT ; goto error ; } sk -> sk_sndmsg_off += copy ; frag -> size += copy ; skb -> len += copy ; skb -> data_len += copy ; skb -> truesize += copy ; atomic_add ( copy , & sk -> sk_wmem_alloc ) ; } offset += copy ; length -= copy ; } return 0 ; error : cork -> length -= length ; IP6_INC_STATS ( sock_net ( sk ) , rt -> rt6i_idev , IPSTATS_MIB_OUTDISCARDS ) ; return err ; }","mtu , flags , rt"
197,"<S2SV_StartBug> static vpx_codec_err_t vp8e_set_scalemode ( vpx_codec_alg_priv_t * ctx , <S2SV_EndBug> int ctr_id , va_list args ) { vpx_scaling_mode_t * data = va_arg ( args , vpx_scaling_mode_t * ) ; if ( data ) { int res ; vpx_scaling_mode_t scalemode = * ( vpx_scaling_mode_t * ) data ; res = vp8_set_internal_size ( ctx -> cpi , ( VPX_SCALING ) scalemode . h_scaling_mode , ( VPX_SCALING ) scalemode . v_scaling_mode ) ; if ( ! res ) { ctx -> next_frame_flag |= FRAMEFLAGS_KEY ; return VPX_CODEC_OK ; } else return VPX_CODEC_INVALID_PARAM ; } else return VPX_CODEC_INVALID_PARAM ; }","vpx_codec_alg_priv_t * ctx <S2SV_ModEnd> , va_list args"
198,"static int mwifiex_update_vs_ie ( const u8 * ies , int ies_len , struct mwifiex_ie * * ie_ptr , u16 mask , unsigned int oui , u8 oui_type ) { struct ieee_types_header * vs_ie ; struct mwifiex_ie * ie = * ie_ptr ; const u8 * vendor_ie ; vendor_ie = cfg80211_find_vendor_ie ( oui , oui_type , ies , ies_len ) ; if ( vendor_ie ) { if ( ! * ie_ptr ) { * ie_ptr = kzalloc ( sizeof ( struct mwifiex_ie ) , GFP_KERNEL ) ; if ( ! * ie_ptr ) return - ENOMEM ; ie = * ie_ptr ; } vs_ie = ( struct ieee_types_header * ) vendor_ie ; <S2SV_StartBug> memcpy ( ie -> ie_buffer + le16_to_cpu ( ie -> ie_length ) , <S2SV_EndBug> vs_ie , vs_ie -> len + 2 ) ; le16_unaligned_add_cpu ( & ie -> ie_length , vs_ie -> len + 2 ) ; ie -> mgmt_subtype_mask = cpu_to_le16 ( mask ) ; ie -> ie_index = cpu_to_le16 ( MWIFIEX_AUTO_IDX_MASK ) ; } * ie_ptr = ie ; return 0 ; }",) vendor_ie ; if ( le16_to_cpu ( ie -> ie_length ) + vs_ie -> len + 2 > IEEE_MAX_IE_SIZE ) return - EINVAL ;
199,void usb_serial_console_disconnect ( struct usb_serial * serial ) { <S2SV_StartBug> if ( serial -> port [ 0 ] == usbcons_info . port ) { <S2SV_EndBug> usb_serial_console_exit ( ) ; usb_serial_put ( serial ) ; } },{ if ( serial -> port [ 0 ] &&
200,"PS_SERIALIZER_DECODE_FUNC ( php_binary ) { const char * p ; char * name ; const char * endptr = val + vallen ; zval * current ; int namelen ; int has_value ; php_unserialize_data_t var_hash ; <S2SV_StartBug> PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; <S2SV_EndBug> for ( p = val ; p < endptr ; ) { <S2SV_StartBug> zval * * tmp ; <S2SV_EndBug> namelen = ( ( unsigned char ) ( * p ) ) & ( ~ PS_BIN_UNDEF ) ; if ( namelen < 0 || namelen > PS_BIN_MAX || ( p + namelen ) >= endptr ) { PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; return FAILURE ; } has_value = * p & PS_BIN_UNDEF ? 0 : 1 ; name = estrndup ( p + 1 , namelen ) ; p += namelen + 1 ; if ( zend_hash_find ( & EG ( symbol_table ) , name , namelen + 1 , ( void * * ) & tmp ) == SUCCESS ) { if ( ( Z_TYPE_PP ( tmp ) == IS_ARRAY && Z_ARRVAL_PP ( tmp ) == & EG ( symbol_table ) ) || * tmp == PS ( http_session_vars ) ) { <S2SV_StartBug> efree ( name ) ; <S2SV_EndBug> continue ; } } if ( has_value ) { ALLOC_INIT_ZVAL ( current ) ; if ( php_var_unserialize ( & current , ( const unsigned char * * ) & p , ( const unsigned char * ) endptr , & var_hash TSRMLS_CC ) ) { <S2SV_StartBug> php_set_session_var ( name , namelen , current , & var_hash TSRMLS_CC ) ; <S2SV_EndBug> } else { PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; return FAILURE ; } var_push_dtor_no_addref ( & var_hash , & current ) ; } <S2SV_StartBug> PS_ADD_VARL ( name , namelen ) ; <S2SV_EndBug> efree ( name ) ; } PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; return SUCCESS ; }",php_unserialize_data_t var_hash ; int skip = 0 ; <S2SV_ModStart> * * tmp ; skip = 0 <S2SV_ModStart> ) ) { skip = 1 <S2SV_ModEnd> ; } } <S2SV_ModStart> ) ) { if ( ! skip ) { <S2SV_ModStart> TSRMLS_CC ) ; } <S2SV_ModStart> ) ; } if ( ! skip ) { <S2SV_ModStart> namelen ) ; }
201,"static int check_submodule_url ( const char * url ) { const char * curl_url ; if ( looks_like_command_line_option ( url ) ) return - 1 ; if ( submodule_url_is_relative ( url ) ) { <S2SV_StartBug> char * decoded = url_decode ( url ) ; <S2SV_EndBug> <S2SV_StartBug> int has_nl = ! ! strchr ( decoded , '\\n' ) ; <S2SV_EndBug> free ( decoded ) ; <S2SV_StartBug> if ( has_nl ) <S2SV_EndBug> return - 1 ; } else if ( url_to_curl_url ( url , & curl_url ) ) { struct credential c = CREDENTIAL_INIT ; int ret = credential_from_url_gently ( & c , curl_url , 1 ) ; credential_clear ( & c ) ; return ret ; } return 0 ; }","char * decoded ; const char * next ; int has_nl ; decoded <S2SV_ModStart> url ) ; <S2SV_ModEnd> has_nl = ! <S2SV_ModStart> if ( has_nl ) return - 1 ; if ( count_leading_dotdots ( url , & next ) > 0 && * next == ':'"
202,"static int64_t handle_inter_mode ( VP9_COMP * cpi , MACROBLOCK * x , <S2SV_StartBug> const TileInfo * const tile , <S2SV_EndBug> BLOCK_SIZE bsize , <S2SV_StartBug> int64_t txfm_cache [ ] , <S2SV_EndBug> <S2SV_StartBug> int * rate2 , int64_t * distortion , <S2SV_EndBug> <S2SV_StartBug> int * skippable , <S2SV_EndBug> int * rate_y , int64_t * distortion_y , <S2SV_StartBug> int * rate_uv , int64_t * distortion_uv , <S2SV_EndBug> int * mode_excluded , int * disable_skip , INTERP_FILTER * best_filter , int_mv ( * mode_mv ) [ MAX_REF_FRAMES ] , int mi_row , int mi_col , <S2SV_StartBug> int_mv single_newmv [ MAX_REF_FRAMES ] , <S2SV_EndBug> int64_t * psse , <S2SV_StartBug> const int64_t ref_best_rd ) { <S2SV_EndBug> VP9_COMMON * cm = & cpi -> common ; MACROBLOCKD * xd = & x -> e_mbd ; <S2SV_StartBug> MB_MODE_INFO * mbmi = & xd -> mi [ 0 ] -> mbmi ; <S2SV_EndBug> const int is_comp_pred = has_second_ref ( mbmi ) ; <S2SV_StartBug> const int num_refs = is_comp_pred ? 2 : 1 ; <S2SV_EndBug> const int this_mode = mbmi -> mode ; int_mv * frame_mv = mode_mv [ this_mode ] ; int i ; int refs [ 2 ] = { mbmi -> ref_frame [ 0 ] , ( mbmi -> ref_frame [ 1 ] < 0 ? 0 : mbmi -> ref_frame [ 1 ] ) } ; int_mv cur_mv [ 2 ] ; <S2SV_StartBug> int64_t this_rd = 0 ; <S2SV_EndBug> <S2SV_StartBug> DECLARE_ALIGNED_ARRAY ( 16 , uint8_t , tmp_buf , MAX_MB_PLANE * 64 * 64 ) ; <S2SV_EndBug> int pred_exists = 0 ; int intpel_mv ; <S2SV_StartBug> int64_t rd , best_rd = INT64_MAX ; <S2SV_EndBug> int best_needs_copy = 0 ; uint8_t * orig_dst [ MAX_MB_PLANE ] ; int orig_dst_stride [ MAX_MB_PLANE ] ; <S2SV_StartBug> int rs = 0 ; <S2SV_EndBug> if ( is_comp_pred ) { if ( frame_mv [ refs [ 0 ] ] . as_int == INVALID_MV || frame_mv [ refs [ 1 ] ] . as_int == INVALID_MV ) return INT64_MAX ; <S2SV_StartBug> } <S2SV_EndBug> if ( this_mode == NEWMV ) { int rate_mv ; if ( is_comp_pred ) { frame_mv [ refs [ 0 ] ] . as_int = single_newmv [ refs [ 0 ] ] . as_int ; frame_mv [ refs [ 1 ] ] . as_int = single_newmv [ refs [ 1 ] ] . as_int ; if ( cpi -> sf . comp_inter_joint_search_thresh <= bsize ) { joint_motion_search ( cpi , x , bsize , frame_mv , mi_row , mi_col , single_newmv , & rate_mv ) ; } else { rate_mv = vp9_mv_bit_cost ( & frame_mv [ refs [ 0 ] ] . as_mv , <S2SV_StartBug> & mbmi -> ref_mvs [ refs [ 0 ] ] [ 0 ] . as_mv , <S2SV_EndBug> x -> nmvjointcost , x -> mvcost , MV_COST_WEIGHT ) ; rate_mv += vp9_mv_bit_cost ( & frame_mv [ refs [ 1 ] ] . as_mv , <S2SV_StartBug> & mbmi -> ref_mvs [ refs [ 1 ] ] [ 0 ] . as_mv , <S2SV_EndBug> x -> nmvjointcost , x -> mvcost , MV_COST_WEIGHT ) ; } * rate2 += rate_mv ; } else { int_mv tmp_mv ; <S2SV_StartBug> single_motion_search ( cpi , x , tile , bsize , mi_row , mi_col , <S2SV_EndBug> & tmp_mv , & rate_mv ) ; if ( tmp_mv . as_int == INVALID_MV ) return INT64_MAX ; <S2SV_StartBug> * rate2 += rate_mv ; <S2SV_EndBug> <S2SV_StartBug> frame_mv [ refs [ 0 ] ] . as_int = <S2SV_EndBug> xd -> mi [ 0 ] -> bmi [ 0 ] . as_mv [ 0 ] . as_int = tmp_mv . as_int ; single_newmv [ refs [ 0 ] ] . as_int = tmp_mv . as_int ; } } <S2SV_StartBug> for ( i = 0 ; i < num_refs ; ++ i ) { <S2SV_EndBug> cur_mv [ i ] = frame_mv [ refs [ i ] ] ; if ( this_mode != NEWMV ) clamp_mv2 ( & cur_mv [ i ] . as_mv , xd ) ; if ( mv_check_bounds ( x , & cur_mv [ i ] . as_mv ) ) return INT64_MAX ; mbmi -> mv [ i ] . as_int = cur_mv [ i ] . as_int ; } for ( i = 0 ; i < MAX_MB_PLANE ; i ++ ) { orig_dst [ i ] = xd -> plane [ i ] . dst . buf ; orig_dst_stride [ i ] = xd -> plane [ i ] . dst . stride ; } <S2SV_StartBug> * rate2 += cost_mv_ref ( cpi , this_mode , mbmi -> mode_context [ refs [ 0 ] ] ) ; <S2SV_EndBug> if ( ! ( * mode_excluded ) ) * mode_excluded = is_comp_pred ? cm -> reference_mode == SINGLE_REFERENCE : cm -> reference_mode == COMPOUND_REFERENCE ; pred_exists = 0 ; intpel_mv = ! mv_has_subpel ( & mbmi -> mv [ 0 ] . as_mv ) ; if ( is_comp_pred ) intpel_mv &= ! mv_has_subpel ( & mbmi -> mv [ 1 ] . as_mv ) ; <S2SV_StartBug> cpi -> mask_filter_rd = 0 ; <S2SV_EndBug> for ( i = 0 ; i < SWITCHABLE_FILTER_CONTEXTS ; ++ i ) <S2SV_StartBug> cpi -> rd_filter_cache [ i ] = INT64_MAX ; <S2SV_EndBug> if ( cm -> interp_filter != BILINEAR ) { <S2SV_StartBug> * best_filter = EIGHTTAP ; <S2SV_EndBug> if ( x -> source_variance < cpi -> sf . disable_filter_search_var_thresh ) { <S2SV_StartBug> * best_filter = EIGHTTAP ; <S2SV_EndBug> <S2SV_StartBug> } else { <S2SV_EndBug> int newbest ; int tmp_rate_sum = 0 ; int64_t tmp_dist_sum = 0 ; for ( i = 0 ; i < SWITCHABLE_FILTERS ; ++ i ) { int j ; int64_t rs_rd ; <S2SV_StartBug> mbmi -> interp_filter = i ; <S2SV_EndBug> <S2SV_StartBug> rs = vp9_get_switchable_rate ( x ) ; <S2SV_EndBug> rs_rd = RDCOST ( x -> rdmult , x -> rddiv , rs , 0 ) ; if ( i > 0 && intpel_mv ) { rd = RDCOST ( x -> rdmult , x -> rddiv , tmp_rate_sum , tmp_dist_sum ) ; <S2SV_StartBug> cpi -> rd_filter_cache [ i ] = rd ; <S2SV_EndBug> <S2SV_StartBug> cpi -> rd_filter_cache [ SWITCHABLE_FILTERS ] = <S2SV_EndBug> <S2SV_StartBug> MIN ( cpi -> rd_filter_cache [ SWITCHABLE_FILTERS ] , rd + rs_rd ) ; <S2SV_EndBug> if ( cm -> interp_filter == SWITCHABLE ) rd += rs_rd ; <S2SV_StartBug> cpi -> mask_filter_rd = MAX ( cpi -> mask_filter_rd , rd ) ; <S2SV_EndBug> } else { int rate_sum = 0 ; <S2SV_StartBug> int64_t dist_sum = 0 ; <S2SV_EndBug> if ( ( cm -> interp_filter == SWITCHABLE && ( ! i || best_needs_copy ) ) || ( cm -> interp_filter != SWITCHABLE && ( cm -> interp_filter == mbmi -> interp_filter || ( i == 0 && intpel_mv ) ) ) ) { restore_dst_buf ( xd , orig_dst , orig_dst_stride ) ; } else { for ( j = 0 ; j < MAX_MB_PLANE ; j ++ ) { xd -> plane [ j ] . dst . buf = tmp_buf + j * 64 * 64 ; xd -> plane [ j ] . dst . stride = 64 ; } } vp9_build_inter_predictors_sb ( xd , mi_row , mi_col , bsize ) ; <S2SV_StartBug> model_rd_for_sb ( cpi , bsize , x , xd , & rate_sum , & dist_sum ) ; <S2SV_EndBug> rd = RDCOST ( x -> rdmult , x -> rddiv , rate_sum , dist_sum ) ; <S2SV_StartBug> cpi -> rd_filter_cache [ i ] = rd ; <S2SV_EndBug> <S2SV_StartBug> cpi -> rd_filter_cache [ SWITCHABLE_FILTERS ] = <S2SV_EndBug> <S2SV_StartBug> MIN ( cpi -> rd_filter_cache [ SWITCHABLE_FILTERS ] , rd + rs_rd ) ; <S2SV_EndBug> if ( cm -> interp_filter == SWITCHABLE ) rd += rs_rd ; <S2SV_StartBug> cpi -> mask_filter_rd = MAX ( cpi -> mask_filter_rd , rd ) ; <S2SV_EndBug> if ( i == 0 && intpel_mv ) { tmp_rate_sum = rate_sum ; tmp_dist_sum = dist_sum ; } } if ( i == 0 && cpi -> sf . use_rd_breakout && ref_best_rd < INT64_MAX ) { if ( rd / 2 > ref_best_rd ) { restore_dst_buf ( xd , orig_dst , orig_dst_stride ) ; return INT64_MAX ; } } newbest = i == 0 || rd < best_rd ; if ( newbest ) { best_rd = rd ; <S2SV_StartBug> * best_filter = mbmi -> interp_filter ; <S2SV_EndBug> if ( cm -> interp_filter == SWITCHABLE && i && ! intpel_mv ) best_needs_copy = ! best_needs_copy ; } if ( ( cm -> interp_filter == SWITCHABLE && newbest ) || ( cm -> interp_filter != SWITCHABLE && cm -> interp_filter == mbmi -> interp_filter ) ) { pred_exists = 1 ; <S2SV_StartBug> } <S2SV_EndBug> } restore_dst_buf ( xd , orig_dst , orig_dst_stride ) ; } } mbmi -> interp_filter = cm -> interp_filter != SWITCHABLE ? <S2SV_StartBug> cm -> interp_filter : * best_filter ; <S2SV_EndBug> <S2SV_StartBug> rs = cm -> interp_filter == SWITCHABLE ? vp9_get_switchable_rate ( x ) : 0 ; <S2SV_EndBug> if ( pred_exists ) { if ( best_needs_copy ) { for ( i = 0 ; i < MAX_MB_PLANE ; i ++ ) { xd -> plane [ i ] . dst . buf = tmp_buf + i * 64 * 64 ; xd -> plane [ i ] . dst . stride = 64 ; } } <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> vp9_build_inter_predictors_sb ( xd , mi_row , mi_col , bsize ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> if ( cpi -> sf . use_rd_breakout && ref_best_rd < INT64_MAX ) { <S2SV_StartBug> int tmp_rate ; <S2SV_EndBug> int64_t tmp_dist ; model_rd_for_sb ( cpi , bsize , x , xd , & tmp_rate , & tmp_dist ) ; rd = RDCOST ( x -> rdmult , x -> rddiv , rs + tmp_rate , tmp_dist ) ; if ( rd / 2 > ref_best_rd ) { restore_dst_buf ( xd , orig_dst , orig_dst_stride ) ; return INT64_MAX ; } } if ( cm -> interp_filter == SWITCHABLE ) <S2SV_StartBug> * rate2 += vp9_get_switchable_rate ( x ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! is_comp_pred ) { <S2SV_EndBug> <S2SV_StartBug> if ( ! x -> in_active_map ) { <S2SV_EndBug> if ( psse ) * psse = 0 ; <S2SV_StartBug> * distortion = 0 ; <S2SV_EndBug> x -> skip = 1 ; <S2SV_StartBug> } else if ( cpi -> allow_encode_breakout && x -> encode_breakout ) { <S2SV_EndBug> const BLOCK_SIZE y_size = get_plane_block_size ( bsize , & xd -> plane [ 0 ] ) ; const BLOCK_SIZE uv_size = get_plane_block_size ( bsize , & xd -> plane [ 1 ] ) ; unsigned int var , sse ; unsigned int thresh_ac ; const unsigned int max_thresh = ( cpi -> allow_encode_breakout == ENCODE_BREAKOUT_LIMITED ) ? 128 : 36000 ; const unsigned int min_thresh = MIN ( ( ( unsigned int ) x -> encode_breakout << 4 ) , max_thresh ) ; thresh_ac = ( xd -> plane [ 0 ] . dequant [ 1 ] * xd -> plane [ 0 ] . dequant [ 1 ] ) / 9 ; thresh_ac = clamp ( thresh_ac , min_thresh , max_thresh ) ; var = cpi -> fn_ptr [ y_size ] . vf ( x -> plane [ 0 ] . src . buf , x -> plane [ 0 ] . src . stride , xd -> plane [ 0 ] . dst . buf , xd -> plane [ 0 ] . dst . stride , & sse ) ; thresh_ac >>= 8 - ( b_width_log2_lookup [ bsize ] + b_height_log2_lookup [ bsize ] ) ; if ( sse < thresh_ac || sse == 0 ) { unsigned int thresh_dc ; thresh_dc = ( xd -> plane [ 0 ] . dequant [ 0 ] * xd -> plane [ 0 ] . dequant [ 0 ] >> 6 ) ; if ( ( sse - var ) < thresh_dc || sse == var ) { unsigned int sse_u , sse_v ; unsigned int var_u , var_v ; var_u = cpi -> fn_ptr [ uv_size ] . vf ( x -> plane [ 1 ] . src . buf , x -> plane [ 1 ] . src . stride , xd -> plane [ 1 ] . dst . buf , xd -> plane [ 1 ] . dst . stride , & sse_u ) ; if ( ( sse_u * 4 < thresh_ac || sse_u == 0 ) && ( sse_u - var_u < thresh_dc || sse_u == var_u ) ) { var_v = cpi -> fn_ptr [ uv_size ] . vf ( x -> plane [ 2 ] . src . buf , x -> plane [ 2 ] . src . stride , xd -> plane [ 2 ] . dst . buf , xd -> plane [ 2 ] . dst . stride , & sse_v ) ; if ( ( sse_v * 4 < thresh_ac || sse_v == 0 ) && ( sse_v - var_v < thresh_dc || sse_v == var_v ) ) { x -> skip = 1 ; * rate2 += vp9_cost_bit ( vp9_get_skip_prob ( cm , xd ) , 1 ) ; <S2SV_StartBug> * distortion_uv = ( sse_u + sse_v ) << 4 ; <S2SV_EndBug> * distortion = ( sse << 4 ) + * distortion_uv ; * disable_skip = 1 ; this_rd = RDCOST ( x -> rdmult , x -> rddiv , * rate2 , * distortion ) ; } } } } } } <S2SV_StartBug> if ( ! x -> skip ) { <S2SV_EndBug> int skippable_y , skippable_uv ; int64_t sseuv = INT64_MAX ; int64_t rdcosty = INT64_MAX ; inter_super_block_yrd ( cpi , x , rate_y , distortion_y , & skippable_y , psse , bsize , txfm_cache , ref_best_rd ) ; if ( * rate_y == INT_MAX ) { * rate2 = INT_MAX ; * distortion = INT64_MAX ; restore_dst_buf ( xd , orig_dst , orig_dst_stride ) ; <S2SV_StartBug> return INT64_MAX ; <S2SV_EndBug> } * rate2 += * rate_y ; * distortion += * distortion_y ; rdcosty = RDCOST ( x -> rdmult , x -> rddiv , * rate2 , * distortion ) ; rdcosty = MIN ( rdcosty , RDCOST ( x -> rdmult , x -> rddiv , 0 , * psse ) ) ; super_block_uvrd ( cpi , x , rate_uv , distortion_uv , & skippable_uv , & sseuv , bsize , ref_best_rd - rdcosty ) ; if ( * rate_uv == INT_MAX ) { * rate2 = INT_MAX ; * distortion = INT64_MAX ; restore_dst_buf ( xd , orig_dst , orig_dst_stride ) ; return INT64_MAX ; } * psse += sseuv ; * rate2 += * rate_uv ; * distortion += * distortion_uv ; * skippable = skippable_y && skippable_uv ; } restore_dst_buf ( xd , orig_dst , orig_dst_stride ) ; return this_rd ; }","* x , <S2SV_ModEnd> BLOCK_SIZE bsize , <S2SV_ModStart> BLOCK_SIZE bsize , int * rate2 , int64_t * distortion <S2SV_ModEnd> , int * <S2SV_ModStart> , int * skippable <S2SV_ModEnd> , int * <S2SV_ModStart> , int * rate_y , int * rate_uv <S2SV_ModEnd> , int * <S2SV_ModStart> , int * disable_skip <S2SV_ModEnd> , int_mv ( <S2SV_ModStart> , int_mv single_newmv [ MAX_REF_FRAMES ] , INTERP_FILTER ( * single_filter ) [ MAX_REF_FRAMES ] , int ( * single_skippable ) <S2SV_ModStart> const int64_t ref_best_rd , int64_t * mask_filter , int64_t filter_cache [ ] <S2SV_ModStart> ] -> mbmi ; MB_MODE_INFO_EXT * const mbmi_ext = x -> mbmi_ext <S2SV_ModStart> ; const int <S2SV_ModEnd> this_mode = mbmi <S2SV_ModStart> 2 ] ; # if CONFIG_VP9_HIGHBITDEPTH DECLARE_ALIGNED <S2SV_ModEnd> ( 16 , <S2SV_ModStart> ( 16 , uint16_t , tmp_buf16 [ MAX_MB_PLANE * 64 * 64 ] ) ; uint8_t * tmp_buf ; # else DECLARE_ALIGNED ( 16 , uint8_t , tmp_buf [ <S2SV_ModEnd> MAX_MB_PLANE * 64 <S2SV_ModStart> 64 * 64 ] ) ; # endif <S2SV_ModEnd> int pred_exists = <S2SV_ModStart> int64_t rd , tmp_rd , <S2SV_ModStart> = 0 ; INTERP_FILTER best_filter = SWITCHABLE ; uint8_t skip_txfm [ MAX_MB_PLANE << 2 ] = { 0 } ; int64_t bsse [ MAX_MB_PLANE << 2 ] = { 0 } ; int bsl = mi_width_log2_lookup [ bsize ] ; int pred_filter_search = cpi -> sf . cb_pred_filter_search ? ( ( ( mi_row + mi_col ) >> bsl ) + get_chessboard_index ( cm -> current_video_frame ) ) & 0x1 : 0 ; int skip_txfm_sb = 0 ; int64_t skip_sse_sb = INT64_MAX ; int64_t distortion_y = 0 , distortion_uv = 0 ; # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { tmp_buf = CONVERT_TO_BYTEPTR ( tmp_buf16 ) ; } else { tmp_buf = ( uint8_t * ) tmp_buf16 ; } # endif if ( pred_filter_search ) { INTERP_FILTER af = SWITCHABLE , lf = SWITCHABLE ; if ( xd -> up_available ) af = xd -> mi [ - xd -> mi_stride ] -> mbmi . interp_filter ; if ( xd -> left_available ) lf = xd -> mi [ - 1 ] -> mbmi . interp_filter ; if ( ( this_mode != NEWMV ) || ( af == lf ) ) best_filter = af ; } <S2SV_ModStart> return INT64_MAX ; if ( cpi -> sf . adaptive_mode_search ) { if ( single_filter [ this_mode ] [ refs [ 0 ] ] == single_filter [ this_mode ] [ refs [ 1 ] ] ) best_filter = single_filter [ this_mode ] [ refs [ 0 ] ] ; } <S2SV_ModStart> as_mv , & x -> mbmi_ext <S2SV_ModEnd> -> ref_mvs [ <S2SV_ModStart> as_mv , & x -> mbmi_ext <S2SV_ModEnd> -> ref_mvs [ <S2SV_ModStart> , x , <S2SV_ModEnd> bsize , mi_row <S2SV_ModStart> return INT64_MAX ; frame_mv [ refs [ 0 ] ] . as_int = xd -> mi [ 0 ] -> bmi [ 0 ] . as_mv [ 0 ] . as_int = tmp_mv . as_int ; single_newmv [ refs [ 0 ] ] . as_int = tmp_mv . as_int ; if ( discount_newmv_test ( cpi , this_mode , tmp_mv , mode_mv , refs [ 0 ] ) ) { * rate2 += MAX ( ( rate_mv / NEW_MV_DISCOUNT_FACTOR ) , 1 ) ; } else { <S2SV_ModStart> += rate_mv ; } <S2SV_ModEnd> } } for <S2SV_ModStart> ; i < is_comp_pred + 1 <S2SV_ModEnd> ; ++ i <S2SV_ModStart> stride ; } if ( discount_newmv_test ( cpi , this_mode , frame_mv [ refs [ 0 ] ] , mode_mv , refs [ 0 ] ) ) { * rate2 += MIN ( cost_mv_ref ( cpi , this_mode , mbmi_ext -> mode_context [ refs [ 0 ] ] ) , cost_mv_ref ( cpi , NEARESTMV , mbmi_ext -> mode_context [ refs [ 0 ] ] ) ) ; } else { <S2SV_ModStart> , this_mode , mbmi_ext -> mode_context [ refs [ 0 ] ] ) ; } if ( RDCOST ( x -> rdmult , x -> rddiv , * rate2 , 0 ) > ref_best_rd && mbmi -> mode != NEARESTMV ) return INT64_MAX <S2SV_ModEnd> ; pred_exists = <S2SV_ModStart> as_mv ) ; <S2SV_ModEnd> for ( i <S2SV_ModStart> ++ i ) filter_cache <S2SV_ModEnd> [ i ] <S2SV_ModStart> BILINEAR ) { <S2SV_ModEnd> if ( x <S2SV_ModStart> disable_filter_search_var_thresh ) { <S2SV_ModEnd> best_filter = EIGHTTAP <S2SV_ModStart> ; } else if ( best_filter == SWITCHABLE ) <S2SV_ModStart> int64_t rs_rd ; int tmp_skip_sb = 0 ; int64_t tmp_skip_sse = INT64_MAX ; <S2SV_ModStart> = vp9_get_switchable_rate ( cpi , xd <S2SV_ModEnd> ) ; rs_rd <S2SV_ModStart> tmp_dist_sum ) ; filter_cache <S2SV_ModEnd> [ i ] <S2SV_ModStart> = rd ; filter_cache <S2SV_ModEnd> [ SWITCHABLE_FILTERS ] <S2SV_ModStart> = MIN ( filter_cache <S2SV_ModEnd> [ SWITCHABLE_FILTERS ] <S2SV_ModStart> += rs_rd ; * mask_filter <S2SV_ModEnd> = MAX ( <S2SV_ModStart> = MAX ( * mask_filter <S2SV_ModEnd> , rd ) <S2SV_ModStart> = 0 ; if ( i > 0 && cpi -> sf . adaptive_interp_filter_search && ( cpi -> sf . interp_filter_search_mask & ( 1 << i ) ) ) { rate_sum = INT_MAX ; dist_sum = INT64_MAX ; continue ; } <S2SV_ModStart> , & dist_sum , & tmp_skip_sb , & tmp_skip_sse <S2SV_ModStart> dist_sum ) ; filter_cache <S2SV_ModEnd> [ i ] <S2SV_ModStart> = rd ; filter_cache <S2SV_ModEnd> [ SWITCHABLE_FILTERS ] <S2SV_ModStart> = MIN ( filter_cache <S2SV_ModEnd> [ SWITCHABLE_FILTERS ] <S2SV_ModStart> += rs_rd ; * mask_filter <S2SV_ModEnd> = MAX ( <S2SV_ModStart> = MAX ( * mask_filter <S2SV_ModEnd> , rd ) <S2SV_ModStart> = rd ; <S2SV_ModEnd> best_filter = mbmi <S2SV_ModStart> = 1 ; tmp_rd = best_rd ; skip_txfm_sb = tmp_skip_sb ; skip_sse_sb = tmp_skip_sse ; memcpy ( skip_txfm , x -> skip_txfm , sizeof ( skip_txfm ) ) ; memcpy ( bsse , x -> bsse , sizeof ( bsse ) ) ; <S2SV_ModStart> -> interp_filter : <S2SV_ModEnd> best_filter ; rs <S2SV_ModStart> ? vp9_get_switchable_rate ( cpi , xd <S2SV_ModEnd> ) : 0 <S2SV_ModStart> ; } } rd = tmp_rd + RDCOST ( x -> rdmult , x -> rddiv , rs , 0 ) ; <S2SV_ModStart> } else { int tmp_rate ; int64_t tmp_dist ; <S2SV_ModStart> bsize ) ; model_rd_for_sb ( cpi , bsize , x , xd , & tmp_rate , & tmp_dist , & skip_txfm_sb , & skip_sse_sb ) ; rd = RDCOST ( x -> rdmult , x -> rddiv , rs + tmp_rate , tmp_dist ) ; memcpy ( skip_txfm , x -> skip_txfm , sizeof ( skip_txfm ) ) ; memcpy ( bsse , x -> bsse , sizeof ( bsse ) ) ; } if ( ! is_comp_pred ) single_filter [ this_mode ] [ refs [ 0 ] ] = mbmi -> interp_filter ; if ( cpi -> sf . adaptive_mode_search ) if ( is_comp_pred ) if ( single_skippable [ this_mode ] [ refs [ 0 ] ] && single_skippable [ this_mode ] [ refs [ 1 ] ] ) memset ( skip_txfm , SKIP_TXFM_AC_DC , sizeof ( skip_txfm ) ) ; <S2SV_ModEnd> if ( cpi <S2SV_ModStart> INT64_MAX ) { <S2SV_ModEnd> if ( rd <S2SV_ModStart> * rate2 += rs ; memcpy ( x -> skip_txfm , skip_txfm , sizeof ( skip_txfm ) ) ; memcpy ( x -> bsse , bsse , sizeof ( bsse ) <S2SV_ModEnd> ) ; if <S2SV_ModStart> if ( ! skip_txfm_sb ) { int skippable_y , skippable_uv ; int64_t sseuv = INT64_MAX ; int64_t rdcosty = INT64_MAX ; vp9_subtract_plane ( x , bsize , 0 ) ; super_block_yrd ( cpi , x , rate_y , & distortion_y , & skippable_y , psse , bsize , ref_best_rd ) ; if ( * rate_y == INT_MAX ) { * rate2 = INT_MAX ; * distortion = INT64_MAX ; restore_dst_buf ( xd , orig_dst , orig_dst_stride ) ; return INT64_MAX ; } * rate2 += * rate_y ; * distortion += distortion_y ; rdcosty = RDCOST ( x -> rdmult , x -> rddiv , * rate2 , * distortion ) ; rdcosty = MIN ( rdcosty , RDCOST ( x -> rdmult , x -> rddiv , 0 , * psse ) ) ; <S2SV_ModEnd> if ( ! <S2SV_ModStart> if ( ! super_block_uvrd ( cpi , x , rate_uv , & distortion_uv , & skippable_uv , & sseuv , bsize , ref_best_rd - rdcosty ) ) { * rate2 = INT_MAX ; * distortion = INT64_MAX ; restore_dst_buf ( xd , orig_dst , orig_dst_stride ) ; return INT64_MAX ; } * psse += sseuv ; * rate2 += * rate_uv <S2SV_ModEnd> ; * distortion <S2SV_ModStart> ; * distortion += distortion_uv ; * skippable = skippable_y && skippable_uv ; } else { <S2SV_ModEnd> x -> skip <S2SV_ModStart> = 1 ; * disable_skip <S2SV_ModEnd> = 1 ; <S2SV_ModStart> ) ; * distortion = skip_sse_sb ; <S2SV_ModEnd> } if ( <S2SV_ModStart> if ( ! is_comp_pred ) single_skippable [ this_mode ] [ refs [ 0 ] ] = * skippable <S2SV_ModEnd> ; restore_dst_buf ( <S2SV_ModStart> ) ; return 0 <S2SV_ModEnd> ; } <S2SV_null>"
203,"int ParseWave64HeaderConfig ( FILE * infile , char * infilename , char * fourcc , WavpackContext * wpc , WavpackConfig * config ) { int64_t total_samples = 0 , infilesize ; Wave64ChunkHeader chunk_header ; Wave64FileHeader filehdr ; WaveHeader WaveHeader ; uint32_t bcount ; infilesize = DoGetFileSize ( infile ) ; memcpy ( & filehdr , fourcc , 4 ) ; if ( ! DoReadFile ( infile , ( ( char * ) & filehdr ) + 4 , sizeof ( Wave64FileHeader ) - 4 , & bcount ) || bcount != sizeof ( Wave64FileHeader ) - 4 || memcmp ( filehdr . ckID , riff_guid , sizeof ( riff_guid ) ) || memcmp ( filehdr . formType , wave_guid , sizeof ( wave_guid ) ) ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.W64<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & filehdr , sizeof ( filehdr ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } # if 1 WavpackLittleEndianToNative ( & filehdr , Wave64ChunkHeaderFormat ) ; if ( infilesize && ! ( config -> qmode & QMODE_IGNORE_LENGTH ) && filehdr . ckSize && filehdr . ckSize + 1 && filehdr . ckSize != infilesize ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.W64<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } # endif while ( 1 ) { if ( ! DoReadFile ( infile , & chunk_header , sizeof ( Wave64ChunkHeader ) , & bcount ) || bcount != sizeof ( Wave64ChunkHeader ) ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.W64<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & chunk_header , sizeof ( Wave64ChunkHeader ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackLittleEndianToNative ( & chunk_header , Wave64ChunkHeaderFormat ) ; chunk_header . ckSize -= sizeof ( chunk_header ) ; if ( ! memcmp ( chunk_header . ckID , fmt_guid , sizeof ( fmt_guid ) ) ) { int supported = TRUE , format ; chunk_header . ckSize = ( chunk_header . ckSize + 7 ) & ~ 7L ; if ( chunk_header . ckSize < 16 || chunk_header . ckSize > sizeof ( WaveHeader ) || ! DoReadFile ( infile , & WaveHeader , ( uint32_t ) chunk_header . ckSize , & bcount ) || bcount != chunk_header . ckSize ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.W64<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & WaveHeader , ( uint32_t ) chunk_header . ckSize ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackLittleEndianToNative ( & WaveHeader , WaveHeaderFormat ) ; if ( debug_logging_mode ) { error_line ( ""format<S2SV_blank>tag<S2SV_blank>size<S2SV_blank>=<S2SV_blank>%d"" , chunk_header . ckSize ) ; error_line ( ""FormatTag<S2SV_blank>=<S2SV_blank>%x,<S2SV_blank>NumChannels<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>BitsPerSample<S2SV_blank>=<S2SV_blank>%d"" , WaveHeader . FormatTag , WaveHeader . NumChannels , WaveHeader . BitsPerSample ) ; error_line ( ""BlockAlign<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>SampleRate<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>BytesPerSecond<S2SV_blank>=<S2SV_blank>%d"" , WaveHeader . BlockAlign , WaveHeader . SampleRate , WaveHeader . BytesPerSecond ) ; if ( chunk_header . ckSize > 16 ) error_line ( ""cbSize<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>ValidBitsPerSample<S2SV_blank>=<S2SV_blank>%d"" , WaveHeader . cbSize , WaveHeader . ValidBitsPerSample ) ; if ( chunk_header . ckSize > 20 ) error_line ( ""ChannelMask<S2SV_blank>=<S2SV_blank>%x,<S2SV_blank>SubFormat<S2SV_blank>=<S2SV_blank>%d"" , WaveHeader . ChannelMask , WaveHeader . SubFormat ) ; } if ( chunk_header . ckSize > 16 && WaveHeader . cbSize == 2 ) config -> qmode |= QMODE_ADOBE_MODE ; format = ( WaveHeader . FormatTag == 0xfffe && chunk_header . ckSize == 40 ) ? WaveHeader . SubFormat : WaveHeader . FormatTag ; config -> bits_per_sample = ( chunk_header . ckSize == 40 && WaveHeader . ValidBitsPerSample ) ? WaveHeader . ValidBitsPerSample : WaveHeader . BitsPerSample ; if ( format != 1 && format != 3 ) supported = FALSE ; if ( format == 3 && config -> bits_per_sample != 32 ) supported = FALSE ; if ( ! WaveHeader . NumChannels || WaveHeader . NumChannels > 256 || WaveHeader . BlockAlign / WaveHeader . NumChannels < ( config -> bits_per_sample + 7 ) / 8 || WaveHeader . BlockAlign / WaveHeader . NumChannels > 4 || WaveHeader . BlockAlign % WaveHeader . NumChannels ) supported = FALSE ; if ( config -> bits_per_sample < 1 || config -> bits_per_sample > 32 ) supported = FALSE ; if ( ! supported ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>an<S2SV_blank>unsupported<S2SV_blank>.W64<S2SV_blank>format!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( chunk_header . ckSize < 40 ) { if ( ! config -> channel_mask && ! ( config -> qmode & QMODE_CHANS_UNASSIGNED ) ) { if ( WaveHeader . NumChannels <= 2 ) config -> channel_mask = 0x5 - WaveHeader . NumChannels ; else if ( WaveHeader . NumChannels <= 18 ) config -> channel_mask = ( 1 << WaveHeader . NumChannels ) - 1 ; else config -> channel_mask = 0x3ffff ; } } else if ( WaveHeader . ChannelMask && ( config -> channel_mask || ( config -> qmode & QMODE_CHANS_UNASSIGNED ) ) ) { error_line ( ""this<S2SV_blank>W64<S2SV_blank>file<S2SV_blank>already<S2SV_blank>has<S2SV_blank>channel<S2SV_blank>order<S2SV_blank>information!"" ) ; return WAVPACK_SOFT_ERROR ; } else if ( WaveHeader . ChannelMask ) config -> channel_mask = WaveHeader . ChannelMask ; if ( format == 3 ) config -> float_norm_exp = 127 ; else if ( ( config -> qmode & QMODE_ADOBE_MODE ) && WaveHeader . BlockAlign / WaveHeader . NumChannels == 4 ) { if ( WaveHeader . BitsPerSample == 24 ) config -> float_norm_exp = 127 + 23 ; else if ( WaveHeader . BitsPerSample == 32 ) config -> float_norm_exp = 127 + 15 ; } if ( debug_logging_mode ) { if ( config -> float_norm_exp == 127 ) error_line ( ""data<S2SV_blank>format:<S2SV_blank>normalized<S2SV_blank>32-bit<S2SV_blank>floating<S2SV_blank>point"" ) ; else error_line ( ""data<S2SV_blank>format:<S2SV_blank>%d-bit<S2SV_blank>integers<S2SV_blank>stored<S2SV_blank>in<S2SV_blank>%d<S2SV_blank>byte(s)"" , config -> bits_per_sample , WaveHeader . BlockAlign / WaveHeader . NumChannels ) ; } } else if ( ! memcmp ( chunk_header . ckID , data_guid , sizeof ( data_guid ) ) ) { if ( ! WaveHeader . NumChannels ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.W64<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( ( config -> qmode & QMODE_IGNORE_LENGTH ) || chunk_header . ckSize <= 0 ) { config -> qmode |= QMODE_IGNORE_LENGTH ; if ( infilesize && DoGetFilePosition ( infile ) != - 1 ) total_samples = ( infilesize - DoGetFilePosition ( infile ) ) / WaveHeader . BlockAlign ; else total_samples = - 1 ; } else { if ( infilesize && infilesize - chunk_header . ckSize > 16777216 ) { error_line ( ""this<S2SV_blank>.W64<S2SV_blank>file<S2SV_blank>has<S2SV_blank>over<S2SV_blank>16<S2SV_blank>MB<S2SV_blank>of<S2SV_blank>extra<S2SV_blank>RIFF<S2SV_blank>data,<S2SV_blank>probably<S2SV_blank>is<S2SV_blank>corrupt!"" ) ; return WAVPACK_SOFT_ERROR ; } total_samples = chunk_header . ckSize / WaveHeader . BlockAlign ; if ( ! total_samples ) { error_line ( ""this<S2SV_blank>.W64<S2SV_blank>file<S2SV_blank>has<S2SV_blank>no<S2SV_blank>audio<S2SV_blank>samples,<S2SV_blank>probably<S2SV_blank>is<S2SV_blank>corrupt!"" ) ; return WAVPACK_SOFT_ERROR ; } if ( total_samples > MAX_WAVPACK_SAMPLES ) { error_line ( ""%s<S2SV_blank>has<S2SV_blank>too<S2SV_blank>many<S2SV_blank>samples<S2SV_blank>for<S2SV_blank>WavPack!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } } config -> bytes_per_sample = WaveHeader . BlockAlign / WaveHeader . NumChannels ; config -> num_channels = WaveHeader . NumChannels ; config -> sample_rate = WaveHeader . SampleRate ; break ; } else { int bytes_to_copy = ( chunk_header . ckSize + 7 ) & ~ 7L ; <S2SV_StartBug> char * buff = malloc ( bytes_to_copy ) ; <S2SV_EndBug> if ( debug_logging_mode ) error_line ( ""extra<S2SV_blank>unknown<S2SV_blank>chunk<S2SV_blank>\\""%c%c%c%c\\""<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes"" , chunk_header . ckID [ 0 ] , chunk_header . ckID [ 1 ] , chunk_header . ckID [ 2 ] , chunk_header . ckID [ 3 ] , chunk_header . ckSize ) ; if ( ! DoReadFile ( infile , buff , bytes_to_copy , & bcount ) || bcount != bytes_to_copy || ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , buff , bytes_to_copy ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; free ( buff ) ; return WAVPACK_SOFT_ERROR ; } free ( buff ) ; } } if ( ! WavpackSetConfiguration64 ( wpc , config , total_samples , NULL ) ) { error_line ( ""%s:<S2SV_blank>%s"" , infilename , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } return WAVPACK_NO_ERROR ; }","; char * buff ; if ( bytes_to_copy < 0 || bytes_to_copy > 4194304 ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.W64<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; }"
204,"int jpc_tsfb_synthesize ( jpc_tsfb_t * tsfb , jas_seq2d_t * a ) { <S2SV_StartBug> return ( tsfb -> numlvls > 0 ) ? jpc_tsfb_synthesize2 ( tsfb , <S2SV_EndBug> jas_seq2d_getref ( a , jas_seq2d_xstart ( a ) , jas_seq2d_ystart ( a ) ) , jas_seq2d_xstart ( a ) , jas_seq2d_ystart ( a ) , jas_seq2d_width ( a ) , jas_seq2d_height ( a ) , jas_seq2d_rowstep ( a ) , tsfb -> numlvls - 1 ) : 0 ; }",numlvls > 0 && jas_seq2d_size ( a )
205,"static Image * ReadHALDImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image ; MagickBooleanType status ; size_t cube_size , level ; ssize_t y ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; level = 0 ; if ( * image_info -> filename != '\\0' ) level = StringToUnsignedLong ( image_info -> filename ) ; if ( level < 2 ) level = 8 ; status = MagickTrue ; cube_size = level * level ; image -> columns = ( size_t ) ( level * cube_size ) ; image -> rows = ( size_t ) ( level * cube_size ) ; <S2SV_StartBug> for ( y = 0 ; y < ( ssize_t ) image -> rows ; y += ( ssize_t ) level ) <S2SV_EndBug> { ssize_t blue , green , red ; register PixelPacket * restrict q ; if ( status == MagickFalse ) continue ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , ( size_t ) level , exception ) ; if ( q == ( PixelPacket * ) NULL ) { status = MagickFalse ; continue ; } blue = y / ( ssize_t ) level ; for ( green = 0 ; green < ( ssize_t ) cube_size ; green ++ ) { for ( red = 0 ; red < ( ssize_t ) cube_size ; red ++ ) { SetPixelRed ( q , ClampToQuantum ( ( MagickRealType ) ( QuantumRange * red / ( cube_size - 1.0 ) ) ) ) ; SetPixelGreen ( q , ClampToQuantum ( ( MagickRealType ) ( QuantumRange * green / ( cube_size - 1.0 ) ) ) ) ; SetPixelBlue ( q , ClampToQuantum ( ( MagickRealType ) ( QuantumRange * blue / ( cube_size - 1.0 ) ) ) ) ; SetPixelOpacity ( q , OpaqueOpacity ) ; q ++ ; } } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) status = MagickFalse ; } return ( GetFirstImageInList ( image ) ) ; }","cube_size ) ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }"
206,"<S2SV_StartBug> void vp9_entropy_mv_init ( ) { <S2SV_EndBug> vp9_tokens_from_tree ( mv_joint_encodings , vp9_mv_joint_tree ) ; vp9_tokens_from_tree ( mv_class_encodings , vp9_mv_class_tree ) ; vp9_tokens_from_tree ( mv_class0_encodings , vp9_mv_class0_tree ) ; vp9_tokens_from_tree ( mv_fp_encodings , vp9_mv_fp_tree ) ; }",void vp9_entropy_mv_init ( void
207,"static int l2tp_ip6_recvmsg ( struct kiocb * iocb , struct sock * sk , struct msghdr * msg , size_t len , int noblock , int flags , int * addr_len ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct sockaddr_l2tpip6 * lsa = ( struct sockaddr_l2tpip6 * ) msg -> msg_name ; size_t copied = 0 ; int err = - EOPNOTSUPP ; struct sk_buff * skb ; if ( flags & MSG_OOB ) goto out ; if ( addr_len ) * addr_len = sizeof ( * lsa ) ; if ( flags & MSG_ERRQUEUE ) return ipv6_recv_error ( sk , msg , len ) ; skb = skb_recv_datagram ( sk , flags , noblock , & err ) ; if ( ! skb ) goto out ; copied = skb -> len ; if ( len < copied ) { msg -> msg_flags |= MSG_TRUNC ; copied = len ; } err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; if ( err ) goto done ; sock_recv_timestamp ( msg , sk , skb ) ; if ( lsa ) { lsa -> l2tp_family = AF_INET6 ; lsa -> l2tp_unused = 0 ; lsa -> l2tp_addr = ipv6_hdr ( skb ) -> saddr ; lsa -> l2tp_flowinfo = 0 ; lsa -> l2tp_scope_id = 0 ; <S2SV_StartBug> if ( ipv6_addr_type ( & lsa -> l2tp_addr ) & IPV6_ADDR_LINKLOCAL ) <S2SV_EndBug> lsa -> l2tp_scope_id = IP6CB ( skb ) -> iif ; } if ( np -> rxopt . all ) ip6_datagram_recv_ctl ( sk , msg , skb ) ; if ( flags & MSG_TRUNC ) copied = skb -> len ; done : skb_free_datagram ( sk , skb ) ; out : return err ? err : copied ; }",= 0 ; lsa -> l2tp_conn_id = 0 ;
208,"GPLOT * gplotCreate ( const char * rootname , l_int32 outformat , const char * title , const char * xlabel , const char * ylabel ) { char * newroot ; <S2SV_StartBug> char buf [ L_BUF_SIZE ] ; <S2SV_EndBug> l_int32 badchar ; GPLOT * gplot ; PROCNAME ( ""gplotCreate"" ) ; if ( ! rootname ) return ( GPLOT * ) ERROR_PTR ( ""rootname<S2SV_blank>not<S2SV_blank>defined"" , procName , NULL ) ; if ( outformat != GPLOT_PNG && outformat != GPLOT_PS && outformat != GPLOT_EPS && outformat != GPLOT_LATEX ) return ( GPLOT * ) ERROR_PTR ( ""outformat<S2SV_blank>invalid"" , procName , NULL ) ; stringCheckForChars ( rootname , ""`;&|><\\""?*"" , & badchar ) ; if ( badchar ) return ( GPLOT * ) ERROR_PTR ( ""invalid<S2SV_blank>rootname"" , procName , NULL ) ; if ( ( gplot = ( GPLOT * ) LEPT_CALLOC ( 1 , sizeof ( GPLOT ) ) ) == NULL ) return ( GPLOT * ) ERROR_PTR ( ""gplot<S2SV_blank>not<S2SV_blank>made"" , procName , NULL ) ; gplot -> cmddata = sarrayCreate ( 0 ) ; gplot -> datanames = sarrayCreate ( 0 ) ; gplot -> plotdata = sarrayCreate ( 0 ) ; gplot -> plottitles = sarrayCreate ( 0 ) ; gplot -> plotstyles = numaCreate ( 0 ) ; newroot = genPathname ( rootname , NULL ) ; gplot -> rootname = newroot ; gplot -> outformat = outformat ; <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""%s.cmd"" , rootname ) ; <S2SV_EndBug> gplot -> cmdname = stringNew ( buf ) ; if ( outformat == GPLOT_PNG ) <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""%s.png"" , newroot ) ; <S2SV_EndBug> else if ( outformat == GPLOT_PS ) <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""%s.ps"" , newroot ) ; <S2SV_EndBug> else if ( outformat == GPLOT_EPS ) <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""%s.eps"" , newroot ) ; <S2SV_EndBug> else if ( outformat == GPLOT_LATEX ) <S2SV_StartBug> snprintf ( buf , L_BUF_SIZE , ""%s.tex"" , newroot ) ; <S2SV_EndBug> gplot -> outname = stringNew ( buf ) ; if ( title ) gplot -> title = stringNew ( title ) ; if ( xlabel ) gplot -> xlabel = stringNew ( xlabel ) ; if ( ylabel ) gplot -> ylabel = stringNew ( ylabel ) ; return gplot ; }","char buf [ L_BUFSIZE <S2SV_ModEnd> ] ; l_int32 <S2SV_ModStart> ( buf , L_BUFSIZE <S2SV_ModEnd> , ""%s.cmd"" , <S2SV_ModStart> ( buf , L_BUFSIZE <S2SV_ModEnd> , ""%s.png"" , <S2SV_ModStart> ( buf , L_BUFSIZE <S2SV_ModEnd> , ""%s.ps"" , <S2SV_ModStart> ( buf , L_BUFSIZE <S2SV_ModEnd> , ""%s.eps"" , <S2SV_ModStart> ( buf , L_BUFSIZE <S2SV_ModEnd> , ""%s.tex"" ,"
209,"static int hugetlbfs_statfs ( struct dentry * dentry , struct kstatfs * buf ) { struct hugetlbfs_sb_info * sbinfo = HUGETLBFS_SB ( dentry -> d_sb ) ; struct hstate * h = hstate_inode ( dentry -> d_inode ) ; buf -> f_type = HUGETLBFS_MAGIC ; buf -> f_bsize = huge_page_size ( h ) ; if ( sbinfo ) { spin_lock ( & sbinfo -> stat_lock ) ; <S2SV_StartBug> if ( sbinfo -> max_blocks >= 0 ) { <S2SV_EndBug> <S2SV_StartBug> buf -> f_blocks = sbinfo -> max_blocks ; <S2SV_EndBug> <S2SV_StartBug> buf -> f_bavail = buf -> f_bfree = sbinfo -> free_blocks ; <S2SV_EndBug> buf -> f_files = sbinfo -> max_inodes ; buf -> f_ffree = sbinfo -> free_inodes ; } spin_unlock ( & sbinfo -> stat_lock ) ; } buf -> f_namelen = NAME_MAX ; return 0 ; }",( sbinfo -> spool ) { long free_pages ; spin_lock ( & sbinfo -> spool -> lock ) ; <S2SV_ModEnd> buf -> f_blocks <S2SV_ModStart> = sbinfo -> spool -> max_hpages ; free_pages = sbinfo -> spool -> max_hpages - sbinfo -> spool -> used_hpages <S2SV_ModEnd> ; buf -> <S2SV_ModStart> -> f_bfree = free_pages ; spin_unlock ( & sbinfo -> spool -> lock ) <S2SV_ModEnd> ; buf ->
210,"static inline void header_put_le_int ( SF_PRIVATE * psf , int x ) <S2SV_StartBug> { if ( psf -> headindex < SIGNED_SIZEOF ( psf -> header ) - 4 ) <S2SV_EndBug> <S2SV_StartBug> { psf -> header [ psf -> headindex ++ ] = x ; <S2SV_EndBug> <S2SV_StartBug> psf -> header [ psf -> headindex ++ ] = ( x >> 8 ) ; <S2SV_EndBug> <S2SV_StartBug> psf -> header [ psf -> headindex ++ ] = ( x >> 16 ) ; <S2SV_EndBug> <S2SV_StartBug> psf -> header [ psf -> headindex ++ ] = ( x >> 24 ) ; <S2SV_EndBug> <S2SV_StartBug> } ; <S2SV_EndBug> }",x ) { <S2SV_ModEnd> psf -> header <S2SV_ModStart> psf -> header . ptr [ <S2SV_ModEnd> psf -> header <S2SV_ModStart> psf -> header . indx <S2SV_ModEnd> ++ ] = <S2SV_ModStart> psf -> header . ptr <S2SV_ModStart> [ psf -> header . indx <S2SV_ModEnd> ++ ] = <S2SV_ModStart> psf -> header . ptr <S2SV_ModStart> [ psf -> header . indx <S2SV_ModEnd> ++ ] = <S2SV_ModStart> psf -> header . ptr <S2SV_ModStart> [ psf -> header . indx <S2SV_ModEnd> ++ ] = <S2SV_ModStart> ) ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
211,"krb5_error_code _kdc_as_rep ( kdc_request_t r , krb5_data * reply , const char * from , struct sockaddr * from_addr , int datagram_reply ) { krb5_context context = r -> context ; krb5_kdc_configuration * config = r -> config ; KDC_REQ * req = & r -> req ; KDC_REQ_BODY * b = NULL ; AS_REP rep ; KDCOptions f ; krb5_enctype setype ; krb5_error_code ret = 0 ; Key * skey ; int found_pa = 0 ; int i , flags = HDB_F_FOR_AS_REQ ; METHOD_DATA error_method ; const PA_DATA * pa ; memset ( & rep , 0 , sizeof ( rep ) ) ; error_method . len = 0 ; error_method . val = NULL ; ret = _kdc_fast_unwrap_request ( r ) ; if ( ret ) { _kdc_r_log ( r , 0 , ""FAST<S2SV_blank>unwrap<S2SV_blank>request<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>failed:<S2SV_blank>%d"" , from , ret ) ; goto out ; } b = & req -> req_body ; f = b -> kdc_options ; if ( f . canonicalize ) flags |= HDB_F_CANON ; if ( b -> sname == NULL ) { ret = KRB5KRB_ERR_GENERIC ; _kdc_set_e_text ( r , ""No<S2SV_blank>server<S2SV_blank>in<S2SV_blank>request"" ) ; } else { ret = _krb5_principalname2krb5_principal ( context , & r -> server_princ , * ( b -> sname ) , b -> realm ) ; if ( ret == 0 ) ret = krb5_unparse_name ( context , r -> server_princ , & r -> server_name ) ; } if ( ret ) { kdc_log ( context , config , 0 , ""AS-REQ<S2SV_blank>malformed<S2SV_blank>server<S2SV_blank>name<S2SV_blank>from<S2SV_blank>%s"" , from ) ; goto out ; } if ( b -> cname == NULL ) { ret = KRB5KRB_ERR_GENERIC ; _kdc_set_e_text ( r , ""No<S2SV_blank>client<S2SV_blank>in<S2SV_blank>request"" ) ; } else { ret = _krb5_principalname2krb5_principal ( context , & r -> client_princ , * ( b -> cname ) , b -> realm ) ; if ( ret ) goto out ; ret = krb5_unparse_name ( context , r -> client_princ , & r -> client_name ) ; } if ( ret ) { kdc_log ( context , config , 0 , ""AS-REQ<S2SV_blank>malformed<S2SV_blank>client<S2SV_blank>name<S2SV_blank>from<S2SV_blank>%s"" , from ) ; goto out ; } kdc_log ( context , config , 0 , ""AS-REQ<S2SV_blank>%s<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>%s"" , r -> client_name , from , r -> server_name ) ; if ( _kdc_is_anonymous ( context , r -> client_princ ) ) { if ( ! _kdc_is_anon_request ( b ) ) { kdc_log ( context , config , 0 , ""Anonymous<S2SV_blank>ticket<S2SV_blank>w/o<S2SV_blank>anonymous<S2SV_blank>flag"" ) ; ret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN ; goto out ; } } else if ( _kdc_is_anon_request ( b ) ) { kdc_log ( context , config , 0 , ""Request<S2SV_blank>for<S2SV_blank>a<S2SV_blank>anonymous<S2SV_blank>ticket<S2SV_blank>with<S2SV_blank>non<S2SV_blank>"" ""anonymous<S2SV_blank>client<S2SV_blank>name:<S2SV_blank>%s"" , r -> client_name ) ; ret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN ; goto out ; } ret = _kdc_db_fetch ( context , config , r -> client_princ , HDB_F_GET_CLIENT | flags , NULL , & r -> clientdb , & r -> client ) ; if ( ret == HDB_ERR_NOT_FOUND_HERE ) { kdc_log ( context , config , 5 , ""client<S2SV_blank>%s<S2SV_blank>does<S2SV_blank>not<S2SV_blank>have<S2SV_blank>secrets<S2SV_blank>at<S2SV_blank>this<S2SV_blank>KDC,<S2SV_blank>need<S2SV_blank>to<S2SV_blank>proxy"" , r -> client_name ) ; goto out ; } else if ( ret == HDB_ERR_WRONG_REALM ) { char * fixed_client_name = NULL ; ret = krb5_unparse_name ( context , r -> client -> entry . principal , & fixed_client_name ) ; if ( ret ) { goto out ; } kdc_log ( context , config , 0 , ""WRONG_REALM<S2SV_blank>-<S2SV_blank>%s<S2SV_blank>-><S2SV_blank>%s"" , r -> client_name , fixed_client_name ) ; free ( fixed_client_name ) ; ret = _kdc_fast_mk_error ( context , r , & error_method , r -> armor_crypto , & req -> req_body , KRB5_KDC_ERR_WRONG_REALM , NULL , r -> server_princ , NULL , & r -> client -> entry . principal -> realm , NULL , NULL , reply ) ; goto out ; } else if ( ret ) { const char * msg = krb5_get_error_message ( context , ret ) ; kdc_log ( context , config , 0 , ""UNKNOWN<S2SV_blank>--<S2SV_blank>%s:<S2SV_blank>%s"" , r -> client_name , msg ) ; krb5_free_error_message ( context , msg ) ; ret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN ; goto out ; } ret = _kdc_db_fetch ( context , config , r -> server_princ , HDB_F_GET_SERVER | HDB_F_GET_KRBTGT | flags , NULL , NULL , & r -> server ) ; if ( ret == HDB_ERR_NOT_FOUND_HERE ) { kdc_log ( context , config , 5 , ""target<S2SV_blank>%s<S2SV_blank>does<S2SV_blank>not<S2SV_blank>have<S2SV_blank>secrets<S2SV_blank>at<S2SV_blank>this<S2SV_blank>KDC,<S2SV_blank>need<S2SV_blank>to<S2SV_blank>proxy"" , r -> server_name ) ; goto out ; } else if ( ret ) { const char * msg = krb5_get_error_message ( context , ret ) ; kdc_log ( context , config , 0 , ""UNKNOWN<S2SV_blank>--<S2SV_blank>%s:<S2SV_blank>%s"" , r -> server_name , msg ) ; krb5_free_error_message ( context , msg ) ; ret = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN ; goto out ; } ret = _kdc_find_etype ( context , krb5_principal_is_krbtgt ( context , r -> server_princ ) ? config -> tgt_use_strongest_session_key : config -> svc_use_strongest_session_key , FALSE , r -> client , b -> etype . val , b -> etype . len , & r -> sessionetype , NULL ) ; if ( ret ) { kdc_log ( context , config , 0 , ""Client<S2SV_blank>(%s)<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>has<S2SV_blank>no<S2SV_blank>common<S2SV_blank>enctypes<S2SV_blank>with<S2SV_blank>KDC<S2SV_blank>"" ""to<S2SV_blank>use<S2SV_blank>for<S2SV_blank>the<S2SV_blank>session<S2SV_blank>key"" , r -> client_name , from ) ; goto out ; } if ( req -> padata ) { unsigned int n ; log_patypes ( context , config , req -> padata ) ; for ( n = 0 ; ! found_pa && n < sizeof ( pat ) / sizeof ( pat [ 0 ] ) ; n ++ ) { if ( pat [ n ] . validate == NULL ) continue ; if ( r -> armor_crypto == NULL && ( pat [ n ] . flags & PA_REQ_FAST ) ) continue ; kdc_log ( context , config , 5 , ""Looking<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>pa-data<S2SV_blank>--<S2SV_blank>%s"" , pat [ n ] . name , r -> client_name ) ; i = 0 ; pa = _kdc_find_padata ( req , & i , pat [ n ] . type ) ; if ( pa ) { ret = pat [ n ] . validate ( r , pa ) ; if ( ret != 0 ) { goto out ; } kdc_log ( context , config , 0 , ""%s<S2SV_blank>pre-authentication<S2SV_blank>succeeded<S2SV_blank>--<S2SV_blank>%s"" , pat [ n ] . name , r -> client_name ) ; found_pa = 1 ; r -> et . flags . pre_authent = 1 ; } } } if ( found_pa == 0 ) { Key * ckey = NULL ; size_t n ; for ( n = 0 ; n < sizeof ( pat ) / sizeof ( pat [ 0 ] ) ; n ++ ) { if ( ( pat [ n ] . flags & PA_ANNOUNCE ) == 0 ) continue ; ret = krb5_padata_add ( context , & error_method , pat [ n ] . type , NULL , 0 ) ; if ( ret ) goto out ; } ret = _kdc_find_etype ( context , config -> preauth_use_strongest_session_key , TRUE , r -> client , b -> etype . val , b -> etype . len , NULL , & ckey ) ; if ( ret == 0 ) { if ( older_enctype ( ckey -> key . keytype ) ) { ret = get_pa_etype_info ( context , config , & error_method , ckey ) ; if ( ret ) goto out ; } ret = get_pa_etype_info2 ( context , config , & error_method , ckey ) ; if ( ret ) goto out ; } if ( require_preauth_p ( r ) || _kdc_is_anon_request ( b ) ) { ret = KRB5KDC_ERR_PREAUTH_REQUIRED ; _kdc_set_e_text ( r , ""Need<S2SV_blank>to<S2SV_blank>use<S2SV_blank>PA-ENC-TIMESTAMP/PA-PK-AS-REQ"" ) ; goto out ; } if ( ckey == NULL ) { ret = KRB5KDC_ERR_CLIENT_NOTYET ; _kdc_set_e_text ( r , ""Doesn\'t<S2SV_blank>have<S2SV_blank>a<S2SV_blank>client<S2SV_blank>key<S2SV_blank>available"" ) ; goto out ; } krb5_free_keyblock_contents ( r -> context , & r -> reply_key ) ; ret = krb5_copy_keyblock_contents ( r -> context , & ckey -> key , & r -> reply_key ) ; if ( ret ) goto out ; } if ( r -> clientdb -> hdb_auth_status ) { r -> clientdb -> hdb_auth_status ( context , r -> clientdb , r -> client , HDB_AUTH_SUCCESS ) ; } ret = _kdc_check_access ( context , config , r -> client , r -> client_name , r -> server , r -> server_name , req , & error_method ) ; if ( ret ) goto out ; ret = _kdc_get_preferred_key ( context , config , r -> server , r -> server_name , & setype , & skey ) ; if ( ret ) goto out ; if ( f . renew || f . validate || f . proxy || f . forwarded || f . enc_tkt_in_skey || ( _kdc_is_anon_request ( b ) && ! config -> allow_anonymous ) ) { ret = KRB5KDC_ERR_BADOPTION ; _kdc_set_e_text ( r , ""Bad<S2SV_blank>KDC<S2SV_blank>options"" ) ; goto out ; } rep . pvno = 5 ; rep . msg_type = krb_as_rep ; if ( _kdc_is_anonymous ( context , r -> client_princ ) ) { Realm anon_realm = KRB5_ANON_REALM ; ret = copy_Realm ( & anon_realm , & rep . crealm ) ; } else ret = copy_Realm ( & r -> client -> entry . principal -> realm , & rep . crealm ) ; if ( ret ) goto out ; ret = _krb5_principal2principalname ( & rep . cname , r -> client -> entry . principal ) ; if ( ret ) goto out ; rep . ticket . tkt_vno = 5 ; ret = copy_Realm ( & r -> server -> entry . principal -> realm , & rep . ticket . realm ) ; if ( ret ) goto out ; _krb5_principal2principalname ( & rep . ticket . sname , r -> server -> entry . principal ) ; # define CNT ( sp , t ) ( ( ( sp ) -> sname -> name_type ) == KRB5_NT_ ## t ) if ( CNT ( b , UNKNOWN ) || CNT ( b , PRINCIPAL ) || CNT ( b , SRV_INST ) || CNT ( b , SRV_HST ) || CNT ( b , SRV_XHST ) ) rep . ticket . sname . name_type = b -> sname -> name_type ; # undef CNT r -> et . flags . initial = 1 ; if ( r -> client -> entry . flags . forwardable && r -> server -> entry . flags . forwardable ) r -> et . flags . forwardable = f . forwardable ; else if ( f . forwardable ) { _kdc_set_e_text ( r , ""Ticket<S2SV_blank>may<S2SV_blank>not<S2SV_blank>be<S2SV_blank>forwardable"" ) ; ret = KRB5KDC_ERR_POLICY ; goto out ; } if ( r -> client -> entry . flags . proxiable && r -> server -> entry . flags . proxiable ) r -> et . flags . proxiable = f . proxiable ; else if ( f . proxiable ) { _kdc_set_e_text ( r , ""Ticket<S2SV_blank>may<S2SV_blank>not<S2SV_blank>be<S2SV_blank>proxiable"" ) ; ret = KRB5KDC_ERR_POLICY ; goto out ; } if ( r -> client -> entry . flags . postdate && r -> server -> entry . flags . postdate ) r -> et . flags . may_postdate = f . allow_postdate ; else if ( f . allow_postdate ) { _kdc_set_e_text ( r , ""Ticket<S2SV_blank>may<S2SV_blank>not<S2SV_blank>be<S2SV_blank>postdate"" ) ; ret = KRB5KDC_ERR_POLICY ; goto out ; } if ( ! _kdc_check_addresses ( context , config , b -> addresses , from_addr ) ) { _kdc_set_e_text ( r , ""Bad<S2SV_blank>address<S2SV_blank>list<S2SV_blank>in<S2SV_blank>requested"" ) ; ret = KRB5KRB_AP_ERR_BADADDR ; goto out ; } ret = copy_PrincipalName ( & rep . cname , & r -> et . cname ) ; if ( ret ) goto out ; ret = copy_Realm ( & rep . crealm , & r -> et . crealm ) ; if ( ret ) goto out ; { time_t start ; time_t t ; start = r -> et . authtime = kdc_time ; if ( f . postdated && req -> req_body . from ) { ALLOC ( r -> et . starttime ) ; start = * r -> et . starttime = * req -> req_body . from ; r -> et . flags . invalid = 1 ; r -> et . flags . postdated = 1 ; } _kdc_fix_time ( & b -> till ) ; t = * b -> till ; if ( r -> client -> entry . max_life ) t = start + min ( t - start , * r -> client -> entry . max_life ) ; if ( r -> server -> entry . max_life ) t = start + min ( t - start , * r -> server -> entry . max_life ) ; # if 0 t = min ( t , start + realm -> max_life ) ; # endif r -> et . endtime = t ; if ( f . renewable_ok && r -> et . endtime < * b -> till ) { f . renewable = 1 ; if ( b -> rtime == NULL ) { ALLOC ( b -> rtime ) ; * b -> rtime = 0 ; } if ( * b -> rtime < * b -> till ) * b -> rtime = * b -> till ; } if ( f . renewable && b -> rtime ) { t = * b -> rtime ; if ( t == 0 ) t = MAX_TIME ; if ( r -> client -> entry . max_renew ) t = start + min ( t - start , * r -> client -> entry . max_renew ) ; if ( r -> server -> entry . max_renew ) t = start + min ( t - start , * r -> server -> entry . max_renew ) ; # if 0 t = min ( t , start + realm -> max_renew ) ; # endif ALLOC ( r -> et . renew_till ) ; * r -> et . renew_till = t ; r -> et . flags . renewable = 1 ; } } if ( _kdc_is_anon_request ( b ) ) r -> et . flags . anonymous = 1 ; if ( b -> addresses ) { ALLOC ( r -> et . caddr ) ; copy_HostAddresses ( b -> addresses , r -> et . caddr ) ; } r -> et . transited . tr_type = DOMAIN_X500_COMPRESS ; krb5_data_zero ( & r -> et . transited . contents ) ; r -> ek . last_req . val = malloc ( 2 * sizeof ( * r -> ek . last_req . val ) ) ; if ( r -> ek . last_req . val == NULL ) { ret = ENOMEM ; goto out ; } r -> ek . last_req . len = 0 ; if ( r -> client -> entry . pw_end && ( config -> kdc_warn_pwexpire == 0 || kdc_time + config -> kdc_warn_pwexpire >= * r -> client -> entry . pw_end ) ) { r -> ek . last_req . val [ r -> ek . last_req . len ] . lr_type = LR_PW_EXPTIME ; r -> ek . last_req . val [ r -> ek . last_req . len ] . lr_value = * r -> client -> entry . pw_end ; ++ r -> ek . last_req . len ; } if ( r -> client -> entry . valid_end ) { r -> ek . last_req . val [ r -> ek . last_req . len ] . lr_type = LR_ACCT_EXPTIME ; r -> ek . last_req . val [ r -> ek . last_req . len ] . lr_value = * r -> client -> entry . valid_end ; ++ r -> ek . last_req . len ; } if ( r -> ek . last_req . len == 0 ) { r -> ek . last_req . val [ r -> ek . last_req . len ] . lr_type = LR_NONE ; r -> ek . last_req . val [ r -> ek . last_req . len ] . lr_value = 0 ; ++ r -> ek . last_req . len ; } r -> ek . nonce = b -> nonce ; if ( r -> client -> entry . valid_end || r -> client -> entry . pw_end ) { ALLOC ( r -> ek . key_expiration ) ; if ( r -> client -> entry . valid_end ) { if ( r -> client -> entry . pw_end ) * r -> ek . key_expiration = min ( * r -> client -> entry . valid_end , * r -> client -> entry . pw_end ) ; else * r -> ek . key_expiration = * r -> client -> entry . valid_end ; } else * r -> ek . key_expiration = * r -> client -> entry . pw_end ; } else r -> ek . key_expiration = NULL ; r -> ek . flags = r -> et . flags ; r -> ek . authtime = r -> et . authtime ; if ( r -> et . starttime ) { ALLOC ( r -> ek . starttime ) ; * r -> ek . starttime = * r -> et . starttime ; } r -> ek . endtime = r -> et . endtime ; if ( r -> et . renew_till ) { ALLOC ( r -> ek . renew_till ) ; * r -> ek . renew_till = * r -> et . renew_till ; } ret = copy_Realm ( & rep . ticket . realm , & r -> ek . srealm ) ; if ( ret ) goto out ; ret = copy_PrincipalName ( & rep . ticket . sname , & r -> ek . sname ) ; if ( ret ) goto out ; if ( r -> et . caddr ) { ALLOC ( r -> ek . caddr ) ; copy_HostAddresses ( r -> et . caddr , r -> ek . caddr ) ; } if ( r -> session_key . keytype == ETYPE_NULL ) { ret = krb5_generate_random_keyblock ( context , r -> sessionetype , & r -> session_key ) ; if ( ret ) goto out ; } if ( r -> reply_key . keytype == ETYPE_NULL ) { _kdc_set_e_text ( r , ""Client<S2SV_blank>have<S2SV_blank>no<S2SV_blank>reply<S2SV_blank>key"" ) ; ret = KRB5KDC_ERR_CLIENT_NOTYET ; goto out ; } ret = copy_EncryptionKey ( & r -> session_key , & r -> et . key ) ; if ( ret ) goto out ; ret = copy_EncryptionKey ( & r -> session_key , & r -> ek . key ) ; if ( ret ) goto out ; if ( r -> outpadata . len ) { ALLOC ( rep . padata ) ; if ( rep . padata == NULL ) { ret = ENOMEM ; goto out ; } ret = copy_METHOD_DATA ( & r -> outpadata , rep . padata ) ; if ( ret ) goto out ; } if ( send_pac_p ( context , req ) ) { generate_pac ( r , skey ) ; } _kdc_log_timestamp ( context , config , ""AS-REQ"" , r -> et . authtime , r -> et . starttime , r -> et . endtime , r -> et . renew_till ) ; ret = _kdc_add_KRB5SignedPath ( context , config , r -> server , setype , r -> client -> entry . principal , NULL , NULL , & r -> et ) ; if ( ret ) goto out ; log_as_req ( context , config , r -> reply_key . keytype , setype , b ) ; r -> et . flags . enc_pa_rep = r -> ek . flags . enc_pa_rep = 1 ; i = 0 ; pa = _kdc_find_padata ( req , & i , KRB5_PADATA_REQ_ENC_PA_REP ) ; if ( pa ) { ret = add_enc_pa_rep ( r ) ; if ( ret ) { const char * msg = krb5_get_error_message ( r -> context , ret ) ; _kdc_r_log ( r , 0 , ""add_enc_pa_rep<S2SV_blank>failed:<S2SV_blank>%s:<S2SV_blank>%d"" , msg , ret ) ; krb5_free_error_message ( r -> context , msg ) ; goto out ; } } ret = _kdc_encode_reply ( context , config , r -> armor_crypto , req -> req_body . nonce , & rep , & r -> et , & r -> ek , setype , r -> server -> entry . kvno , & skey -> key , r -> client -> entry . kvno , & r -> reply_key , 0 , & r -> e_text , reply ) ; if ( ret ) goto out ; if ( datagram_reply && reply -> length > config -> max_datagram_reply_length ) { krb5_data_free ( reply ) ; ret = KRB5KRB_ERR_RESPONSE_TOO_BIG ; _kdc_set_e_text ( r , ""Reply<S2SV_blank>packet<S2SV_blank>too<S2SV_blank>large"" ) ; } out : free_AS_REP ( & rep ) ; if ( ret != 0 && ret != HDB_ERR_NOT_FOUND_HERE && reply -> length == 0 ) { ret = _kdc_fast_mk_error ( context , r , & error_method , r -> armor_crypto , & req -> req_body , ret , r -> e_text , r -> server_princ , <S2SV_StartBug> & r -> client_princ -> name , <S2SV_EndBug> <S2SV_StartBug> & r -> client_princ -> realm , <S2SV_EndBug> NULL , NULL , reply ) ; if ( ret ) goto out2 ; } out2 : free_EncTicketPart ( & r -> et ) ; free_EncKDCRepPart ( & r -> ek ) ; free_KDCFastState ( & r -> fast ) ; if ( error_method . len ) free_METHOD_DATA ( & error_method ) ; if ( r -> outpadata . len ) free_METHOD_DATA ( & r -> outpadata ) ; if ( r -> client_princ ) { krb5_free_principal ( context , r -> client_princ ) ; r -> client_princ = NULL ; } if ( r -> client_name ) { free ( r -> client_name ) ; r -> client_name = NULL ; } if ( r -> server_princ ) { krb5_free_principal ( context , r -> server_princ ) ; r -> server_princ = NULL ; } if ( r -> server_name ) { free ( r -> server_name ) ; r -> server_name = NULL ; } if ( r -> client ) _kdc_free_ent ( context , r -> client ) ; if ( r -> server ) _kdc_free_ent ( context , r -> server ) ; if ( r -> armor_crypto ) { krb5_crypto_destroy ( r -> context , r -> armor_crypto ) ; r -> armor_crypto = NULL ; } krb5_free_keyblock_contents ( r -> context , & r -> reply_key ) ; krb5_free_keyblock_contents ( r -> context , & r -> session_key ) ; return ret ; }","-> server_princ , <S2SV_ModEnd> r -> client_princ <S2SV_ModStart> r -> client_princ ? & r -> client_princ -> name : NULL , <S2SV_ModEnd> r -> client_princ <S2SV_ModStart> r -> client_princ ? & r -> client_princ -> realm : NULL <S2SV_ModEnd> , NULL ,"
212,"static void __iov_iter_advance_iov ( struct iov_iter * i , size_t bytes ) { if ( likely ( i -> nr_segs == 1 ) ) { i -> iov_offset += bytes ; } else { const struct iovec * iov = i -> iov ; size_t base = i -> iov_offset ; <S2SV_StartBug> while ( bytes ) { <S2SV_EndBug> int copy = min ( bytes , iov -> iov_len - base ) ; bytes -= copy ; base += copy ; if ( iov -> iov_len == base ) { iov ++ ; base = 0 ; } } i -> iov = iov ; i -> iov_offset = base ; } }",while ( bytes || ! iov -> iov_len
213,"static HB_Bool myanmar_shape_syllable ( HB_Bool openType , HB_ShaperItem * item , HB_Bool invalid ) { # ifndef NO_OPENTYPE const int availableGlyphs = item -> num_glyphs ; # endif const HB_UChar16 * uc = item -> string + item -> item . pos ; int vowel_e = - 1 ; int kinzi = - 1 ; int medial_ra = - 1 ; int base = - 1 ; int i ; int len = 0 ; unsigned short reordered [ 32 ] ; unsigned char properties [ 32 ] ; enum { AboveForm = 0x01 , PreForm = 0x02 , PostForm = 0x04 , BelowForm = 0x08 } ; HB_Bool lastWasVirama = FALSE ; int basePos = - 1 ; memset ( properties , 0 , 32 * sizeof ( unsigned char ) ) ; assert ( item -> item . length < 32 ) ; # ifdef MYANMAR_DEBUG printf ( ""original:"" ) ; for ( i = 0 ; i < ( int ) item -> item . length ; i ++ ) { printf ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%d:<S2SV_blank>%4x"" , i , uc [ i ] ) ; } # endif for ( i = 0 ; i < ( int ) item -> item . length ; ++ i ) { HB_UChar16 chr = uc [ i ] ; if ( chr == Mymr_C_VOWEL_E ) { vowel_e = i ; continue ; } if ( i == 0 && chr == Mymr_C_NGA && i + 2 < ( int ) item -> item . length && uc [ i + 1 ] == Mymr_C_VIRAMA ) { int mc = getMyanmarCharClass ( uc [ i + 2 ] ) ; if ( ( mc & Mymr_CF_CONSONANT ) == Mymr_CF_CONSONANT ) { kinzi = i ; continue ; } } if ( base >= 0 && chr == Mymr_C_VIRAMA && i + 1 < ( int ) item -> item . length && uc [ i + 1 ] == Mymr_C_RA ) { medial_ra = i ; continue ; } if ( base < 0 ) base = i ; } MMDEBUG ( ""\\n<S2SV_blank><S2SV_blank>base=%d,<S2SV_blank>vowel_e=%d,<S2SV_blank>kinzi=%d,<S2SV_blank>medial_ra=%d"" , base , vowel_e , kinzi , medial_ra ) ; if ( vowel_e >= 0 ) { reordered [ 0 ] = Mymr_C_VOWEL_E ; len = 1 ; } if ( medial_ra >= 0 ) { reordered [ len ] = Mymr_C_VIRAMA ; reordered [ len + 1 ] = Mymr_C_RA ; properties [ len ] = PreForm ; properties [ len + 1 ] = PreForm ; len += 2 ; } if ( invalid ) { reordered [ len ] = C_DOTTED_CIRCLE ; ++ len ; } for ( i = 0 ; i < ( int ) item -> item . length ; ++ i ) { hb_uint16 chr = uc [ i ] ; MymrCharClass cc ; if ( i == vowel_e ) continue ; if ( i == medial_ra || i == kinzi ) { ++ i ; continue ; } cc = getMyanmarCharClass ( uc [ i ] ) ; if ( kinzi >= 0 && i > base && ( cc & Mymr_CF_AFTER_KINZI ) ) { reordered [ len ] = Mymr_C_NGA ; <S2SV_StartBug> reordered [ len + 1 ] = Mymr_C_VIRAMA ; <S2SV_EndBug> properties [ len - 1 ] = AboveForm ; properties [ len ] = AboveForm ; len += 2 ; kinzi = - 1 ; } if ( lastWasVirama ) { int prop = 0 ; switch ( cc & Mymr_CF_POS_MASK ) { case Mymr_CF_POS_BEFORE : prop = PreForm ; break ; case Mymr_CF_POS_BELOW : prop = BelowForm ; break ; case Mymr_CF_POS_ABOVE : prop = AboveForm ; break ; case Mymr_CF_POS_AFTER : prop = PostForm ; break ; default : break ; } properties [ len - 1 ] = prop ; properties [ len ] = prop ; if ( basePos >= 0 && basePos == len - 2 ) properties [ len - 2 ] = prop ; } lastWasVirama = ( chr == Mymr_C_VIRAMA ) ; if ( i == base ) basePos = len ; if ( ( chr != Mymr_C_SIGN_ZWNJ && chr != Mymr_C_SIGN_ZWJ ) || ! len ) { reordered [ len ] = chr ; ++ len ; } } if ( kinzi >= 0 ) { reordered [ len ] = Mymr_C_NGA ; reordered [ len + 1 ] = Mymr_C_VIRAMA ; properties [ len ] = AboveForm ; properties [ len + 1 ] = AboveForm ; len += 2 ; } if ( ! item -> font -> klass -> convertStringToGlyphIndices ( item -> font , reordered , len , item -> glyphs , & item -> num_glyphs , item -> item . bidiLevel % 2 ) ) return FALSE ; MMDEBUG ( ""after<S2SV_blank>shaping:<S2SV_blank>len=%d"" , len ) ; for ( i = 0 ; i < len ; i ++ ) { item -> attributes [ i ] . mark = FALSE ; item -> attributes [ i ] . clusterStart = FALSE ; item -> attributes [ i ] . justification = 0 ; item -> attributes [ i ] . zeroWidth = FALSE ; MMDEBUG ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%d:<S2SV_blank>%4x<S2SV_blank>property=%x"" , i , reordered [ i ] , properties [ i ] ) ; } # ifndef NO_OPENTYPE if ( openType ) { hb_uint32 where [ 32 ] ; for ( i = 0 ; i < len ; ++ i ) { where [ i ] = ~ ( PreSubstProperty | BelowSubstProperty | AboveSubstProperty | PostSubstProperty | CligProperty | PositioningProperties ) ; if ( properties [ i ] & PreForm ) where [ i ] &= ~ PreFormProperty ; if ( properties [ i ] & BelowForm ) where [ i ] &= ~ BelowFormProperty ; if ( properties [ i ] & AboveForm ) where [ i ] &= ~ AboveFormProperty ; if ( properties [ i ] & PostForm ) where [ i ] &= ~ PostFormProperty ; } HB_OpenTypeShape ( item , where ) ; if ( ! HB_OpenTypePosition ( item , availableGlyphs , FALSE ) ) return FALSE ; } else # endif { MMDEBUG ( ""Not<S2SV_blank>using<S2SV_blank>openType"" ) ; HB_HeuristicPosition ( item ) ; } item -> attributes [ 0 ] . clusterStart = TRUE ; return TRUE ; }",= Mymr_C_VIRAMA ; if ( len > 0 )
214,"static int gs_usb_probe ( struct usb_interface * intf , const struct usb_device_id * id ) { struct gs_usb * dev ; int rc = - ENOMEM ; unsigned int icount , i ; <S2SV_StartBug> struct gs_host_config hconf = { <S2SV_EndBug> . byte_order = 0x0000beef , } ; <S2SV_StartBug> struct gs_device_config dconf ; <S2SV_EndBug> rc = usb_control_msg ( interface_to_usbdev ( intf ) , usb_sndctrlpipe ( interface_to_usbdev ( intf ) , 0 ) , GS_USB_BREQ_HOST_FORMAT , USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_INTERFACE , 1 , intf -> altsetting [ 0 ] . desc . bInterfaceNumber , <S2SV_StartBug> & hconf , <S2SV_EndBug> <S2SV_StartBug> sizeof ( hconf ) , <S2SV_EndBug> 1000 ) ; <S2SV_StartBug> if ( rc < 0 ) { <S2SV_EndBug> dev_err ( & intf -> dev , ""Couldn\'t<S2SV_blank>send<S2SV_blank>data<S2SV_blank>format<S2SV_blank>(err=%d)\\n"" , rc ) ; return rc ; <S2SV_StartBug> } <S2SV_EndBug> rc = usb_control_msg ( interface_to_usbdev ( intf ) , usb_rcvctrlpipe ( interface_to_usbdev ( intf ) , 0 ) , GS_USB_BREQ_DEVICE_CONFIG , USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_INTERFACE , 1 , intf -> altsetting [ 0 ] . desc . bInterfaceNumber , <S2SV_StartBug> & dconf , <S2SV_EndBug> <S2SV_StartBug> sizeof ( dconf ) , <S2SV_EndBug> 1000 ) ; if ( rc < 0 ) { dev_err ( & intf -> dev , ""Couldn\'t<S2SV_blank>get<S2SV_blank>device<S2SV_blank>config:<S2SV_blank>(err=%d)\\n"" , rc ) ; <S2SV_StartBug> return rc ; <S2SV_EndBug> } icount = dconf . icount + 1 ; dev_info ( & intf -> dev , ""Configuring<S2SV_blank>for<S2SV_blank>%d<S2SV_blank>interfaces\\n"" , icount ) ; if ( icount > GS_MAX_INTF ) { dev_err ( & intf -> dev , ""Driver<S2SV_blank>cannot<S2SV_blank>handle<S2SV_blank>more<S2SV_blank>that<S2SV_blank>%d<S2SV_blank>CAN<S2SV_blank>interfaces\\n"" , GS_MAX_INTF ) ; <S2SV_StartBug> return - EINVAL ; <S2SV_EndBug> } dev = kzalloc ( sizeof ( * dev ) , GFP_KERNEL ) ; <S2SV_StartBug> if ( ! dev ) <S2SV_EndBug> return - ENOMEM ; <S2SV_StartBug> init_usb_anchor ( & dev -> rx_submitted ) ; <S2SV_EndBug> atomic_set ( & dev -> active_channels , 0 ) ; usb_set_intfdata ( intf , dev ) ; dev -> udev = interface_to_usbdev ( intf ) ; for ( i = 0 ; i < icount ; i ++ ) { <S2SV_StartBug> dev -> canch [ i ] = gs_make_candev ( i , intf , & dconf ) ; <S2SV_EndBug> if ( IS_ERR_OR_NULL ( dev -> canch [ i ] ) ) { rc = PTR_ERR ( dev -> canch [ i ] ) ; icount = i ; for ( i = 0 ; i < icount ; i ++ ) gs_destroy_candev ( dev -> canch [ i ] ) ; usb_kill_anchored_urbs ( & dev -> rx_submitted ) ; <S2SV_StartBug> kfree ( dev ) ; <S2SV_EndBug> return rc ; } dev -> canch [ i ] -> parent = dev ; } <S2SV_StartBug> return 0 ; <S2SV_EndBug> }","; struct gs_host_config * hconf <S2SV_ModEnd> ; struct gs_device_config <S2SV_ModStart> ; struct gs_device_config * dconf ; hconf = kmalloc ( sizeof ( * hconf ) , GFP_KERNEL ) ; if ( ! hconf ) return - ENOMEM ; hconf -> byte_order = 0x0000beef <S2SV_ModEnd> ; rc = <S2SV_ModStart> . bInterfaceNumber , <S2SV_ModEnd> hconf , sizeof <S2SV_ModStart> , sizeof ( * <S2SV_ModStart> 1000 ) ; kfree ( hconf ) ; <S2SV_ModStart> rc ; } dconf = kmalloc ( sizeof ( * dconf ) , GFP_KERNEL ) ; if ( ! dconf ) return - ENOMEM ; <S2SV_ModStart> . bInterfaceNumber , <S2SV_ModEnd> dconf , sizeof <S2SV_ModStart> , sizeof ( * <S2SV_ModStart> rc ) ; kfree ( dconf ) ; return rc ; } icount = dconf -> <S2SV_ModEnd> icount + 1 <S2SV_ModStart> GS_MAX_INTF ) ; kfree ( dconf ) ; <S2SV_ModStart> ! dev ) { kfree ( dconf ) ; <S2SV_ModStart> - ENOMEM ; } <S2SV_ModStart> , intf , <S2SV_ModEnd> dconf ) ; <S2SV_ModStart> ; kfree ( dconf ) ; kfree ( <S2SV_ModStart> dev ; } kfree ( dconf ) ;"
215,"static int try_to_unmap_cluster ( unsigned long cursor , unsigned int * mapcount , struct vm_area_struct * vma , struct page * check_page ) { struct mm_struct * mm = vma -> vm_mm ; pmd_t * pmd ; pte_t * pte ; pte_t pteval ; spinlock_t * ptl ; struct page * page ; unsigned long address ; unsigned long mmun_start ; unsigned long mmun_end ; unsigned long end ; int ret = SWAP_AGAIN ; int locked_vma = 0 ; address = ( vma -> vm_start + cursor ) & CLUSTER_MASK ; end = address + CLUSTER_SIZE ; if ( address < vma -> vm_start ) address = vma -> vm_start ; if ( end > vma -> vm_end ) end = vma -> vm_end ; pmd = mm_find_pmd ( mm , address ) ; if ( ! pmd ) return ret ; mmun_start = address ; mmun_end = end ; mmu_notifier_invalidate_range_start ( mm , mmun_start , mmun_end ) ; if ( down_read_trylock ( & vma -> vm_mm -> mmap_sem ) ) { locked_vma = ( vma -> vm_flags & VM_LOCKED ) ; if ( ! locked_vma ) up_read ( & vma -> vm_mm -> mmap_sem ) ; } pte = pte_offset_map_lock ( mm , pmd , address , & ptl ) ; update_hiwater_rss ( mm ) ; for ( ; address < end ; pte ++ , address += PAGE_SIZE ) { if ( ! pte_present ( * pte ) ) continue ; page = vm_normal_page ( vma , address , * pte ) ; BUG_ON ( ! page || PageAnon ( page ) ) ; if ( locked_vma ) { <S2SV_StartBug> mlock_vma_page ( page ) ; <S2SV_EndBug> <S2SV_StartBug> if ( page == check_page ) <S2SV_EndBug> <S2SV_StartBug> ret = SWAP_MLOCK ; <S2SV_EndBug> continue ; } if ( ptep_clear_flush_young_notify ( vma , address , pte ) ) continue ; flush_cache_page ( vma , address , pte_pfn ( * pte ) ) ; pteval = ptep_clear_flush ( vma , address , pte ) ; if ( page -> index != linear_page_index ( vma , address ) ) { pte_t ptfile = pgoff_to_pte ( page -> index ) ; if ( pte_soft_dirty ( pteval ) ) pte_file_mksoft_dirty ( ptfile ) ; set_pte_at ( mm , address , pte , ptfile ) ; } if ( pte_dirty ( pteval ) ) set_page_dirty ( page ) ; page_remove_rmap ( page ) ; page_cache_release ( page ) ; dec_mm_counter ( mm , MM_FILEPAGES ) ; ( * mapcount ) -- ; } pte_unmap_unlock ( pte - 1 , ptl ) ; mmu_notifier_invalidate_range_end ( mm , mmun_start , mmun_end ) ; if ( locked_vma ) up_read ( & vma -> vm_mm -> mmap_sem ) ; return ret ; }",locked_vma ) { <S2SV_ModEnd> if ( page <S2SV_ModStart> == check_page ) { mlock_vma_page ( page ) ; <S2SV_ModStart> = SWAP_MLOCK ; } else if ( trylock_page ( page ) ) { mlock_vma_page ( page ) ; unlock_page ( page ) ; }
216,"static void test_burl_normalize ( void ) { buffer * psrc = buffer_init ( ) ; buffer * ptmp = buffer_init ( ) ; int flags ; flags = HTTP_PARSEOPT_URL_NORMALIZE_UNRESERVED ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""no-slash"" ) , CONST_STR_LEN ( ""no-slash"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/"" ) , CONST_STR_LEN ( ""/"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/abc"" ) , CONST_STR_LEN ( ""/abc"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/abc/"" ) , CONST_STR_LEN ( ""/abc/"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/abc/def"" ) , CONST_STR_LEN ( ""/abc/def"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/abc?"" ) , CONST_STR_LEN ( ""/abc?"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/abc?d"" ) , CONST_STR_LEN ( ""/abc?d"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/abc?d="" ) , CONST_STR_LEN ( ""/abc?d="" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/abc?d=e"" ) , CONST_STR_LEN ( ""/abc?d=e"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/abc?d=e&"" ) , CONST_STR_LEN ( ""/abc?d=e&"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/abc?d=e&f"" ) , CONST_STR_LEN ( ""/abc?d=e&f"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/abc?d=e&f=g"" ) , CONST_STR_LEN ( ""/abc?d=e&f=g"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/abc?d=e&f=g#"" ) , CONST_STR_LEN ( ""/abc?d=e&f=g"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/abc?d=e&f=g#any"" ) , CONST_STR_LEN ( ""/abc?d=e&f=g"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/%2F"" ) , CONST_STR_LEN ( ""/%2F"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/%2f"" ) , CONST_STR_LEN ( ""/%2F"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/%20"" ) , CONST_STR_LEN ( ""/%20"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/%2b"" ) , CONST_STR_LEN ( ""/%2B"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/%2B"" ) , CONST_STR_LEN ( ""/%2B"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/%3a"" ) , CONST_STR_LEN ( ""/%3A"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/%3A"" ) , CONST_STR_LEN ( ""/%3A"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/~test%20_"" ) , CONST_STR_LEN ( ""/~test%20%C3%A4_"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/\\375"" ) , """" , ( size_t ) - 2 ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/\\376"" ) , """" , ( size_t ) - 2 ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/\\377"" ) , """" , ( size_t ) - 2 ) ; flags = HTTP_PARSEOPT_URL_NORMALIZE_REQUIRED ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/"" ) , CONST_STR_LEN ( ""/"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/abc"" ) , CONST_STR_LEN ( ""/abc"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/abc/"" ) , CONST_STR_LEN ( ""/abc/"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/abc/def"" ) , CONST_STR_LEN ( ""/abc/def"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/abc?"" ) , CONST_STR_LEN ( ""/abc?"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/abc?d"" ) , CONST_STR_LEN ( ""/abc?d"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/abc?d="" ) , CONST_STR_LEN ( ""/abc?d="" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/abc?d=e"" ) , CONST_STR_LEN ( ""/abc?d=e"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/abc?d=e&"" ) , CONST_STR_LEN ( ""/abc?d=e&"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/abc?d=e&f"" ) , CONST_STR_LEN ( ""/abc?d=e&f"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/abc?d=e&f=g"" ) , CONST_STR_LEN ( ""/abc?d=e&f=g"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/abc?d=e&f=g#"" ) , CONST_STR_LEN ( ""/abc?d=e&f=g"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/abc?d=e&f=g#any"" ) , CONST_STR_LEN ( ""/abc?d=e&f=g"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/%2F"" ) , CONST_STR_LEN ( ""/%2F"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/%2f"" ) , CONST_STR_LEN ( ""/%2F"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/%20"" ) , CONST_STR_LEN ( ""/%20"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/%2b"" ) , CONST_STR_LEN ( ""/+"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/%2B"" ) , CONST_STR_LEN ( ""/+"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/%3a"" ) , CONST_STR_LEN ( ""/:"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/%3A"" ) , CONST_STR_LEN ( ""/:"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/~test%20_"" ) , CONST_STR_LEN ( ""/~test%20%C3%A4_"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/\\375"" ) , """" , ( size_t ) - 2 ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/\\376"" ) , """" , ( size_t ) - 2 ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/\\377"" ) , """" , ( size_t ) - 2 ) ; flags |= HTTP_PARSEOPT_URL_NORMALIZE_CTRLS_REJECT ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/\\a"" ) , """" , ( size_t ) - 2 ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/\\t"" ) , """" , ( size_t ) - 2 ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/\\r"" ) , """" , ( size_t ) - 2 ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/\\177"" ) , """" , ( size_t ) - 2 ) ; # if defined ( __WIN32 ) || defined ( __CYGWIN__ ) flags |= HTTP_PARSEOPT_URL_NORMALIZE_PATH_BACKSLASH_TRANS ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/a\\\\b"" ) , CONST_STR_LEN ( ""/a/b"" ) ) ; # endif flags |= HTTP_PARSEOPT_URL_NORMALIZE_PATH_2F_DECODE ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/a/b?c=/"" ) , CONST_STR_LEN ( ""/a/b?c=/"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/a/b?c=%2f"" ) , CONST_STR_LEN ( ""/a/b?c=/"" ) ) ; <S2SV_StartBug> run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/a%2fb"" ) , CONST_STR_LEN ( ""/a/b"" ) ) ; <S2SV_EndBug> run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/a%2Fb"" ) , CONST_STR_LEN ( ""/a/b"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/a%2fb?c=/"" ) , CONST_STR_LEN ( ""/a/b?c=/"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/a%2fb?c=%2f"" ) , CONST_STR_LEN ( ""/a/b?c=/"" ) ) ; flags &= ~ HTTP_PARSEOPT_URL_NORMALIZE_PATH_2F_DECODE ; flags |= HTTP_PARSEOPT_URL_NORMALIZE_PATH_2F_REJECT ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/a%2fb"" ) , """" , ( size_t ) - 2 ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/a%2Fb"" ) , """" , ( size_t ) - 2 ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/a/b?c=%2f"" ) , CONST_STR_LEN ( ""/a/b?c=/"" ) ) ; flags &= ~ HTTP_PARSEOPT_URL_NORMALIZE_PATH_2F_REJECT ; flags |= HTTP_PARSEOPT_URL_NORMALIZE_PATH_DOTSEG_REMOVE ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""./a/b"" ) , CONST_STR_LEN ( ""/a/b"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""../a/b"" ) , CONST_STR_LEN ( ""/a/b"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/a/./b"" ) , CONST_STR_LEN ( ""/a/b"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/a/../b"" ) , CONST_STR_LEN ( ""/b"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/a/b/."" ) , CONST_STR_LEN ( ""/a/b/"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/a/b/.."" ) , CONST_STR_LEN ( ""/a/"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/a/../b/.."" ) , CONST_STR_LEN ( ""/"" ) ) ; flags &= ~ HTTP_PARSEOPT_URL_NORMALIZE_PATH_DOTSEG_REMOVE ; flags |= HTTP_PARSEOPT_URL_NORMALIZE_PATH_DOTSEG_REJECT ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""./a/b"" ) , """" , ( size_t ) - 2 ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""../a/b"" ) , """" , ( size_t ) - 2 ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/a/./b"" ) , """" , ( size_t ) - 2 ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/a/../b"" ) , """" , ( size_t ) - 2 ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/a/b/."" ) , """" , ( size_t ) - 2 ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/a/b/.."" ) , """" , ( size_t ) - 2 ) ; flags &= ~ HTTP_PARSEOPT_URL_NORMALIZE_PATH_DOTSEG_REJECT ; flags |= HTTP_PARSEOPT_URL_NORMALIZE_QUERY_20_PLUS ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/a/b?c=d+e"" ) , CONST_STR_LEN ( ""/a/b?c=d+e"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/a/b?c=d%20e"" ) , CONST_STR_LEN ( ""/a/b?c=d+e"" ) ) ; flags &= ~ HTTP_PARSEOPT_URL_NORMALIZE_QUERY_20_PLUS ; buffer_free ( psrc ) ; buffer_free ( ptmp ) ; }",", CONST_STR_LEN ( ""%2f?"" ) , CONST_STR_LEN ( ""/?"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/%2f?"" ) , CONST_STR_LEN ( ""//?"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ("
217,"static Bool FFD_CanHandleURL ( GF_InputService * plug , const char * url ) { Bool has_audio , has_video ; s32 i ; AVFormatContext * ctx ; AVOutputFormat * fmt_out ; Bool ret = GF_FALSE ; <S2SV_StartBug> char * ext , szName [ 1000 ] , szExt [ 20 ] ; <S2SV_EndBug> const char * szExtList ; FFDemux * ffd ; if ( ! plug || ! url ) return GF_FALSE ; if ( ! strnicmp ( url , ""rtsp://"" , 7 ) ) return GF_FALSE ; if ( ! strnicmp ( url , ""rtspu://"" , 8 ) ) return GF_FALSE ; if ( ! strnicmp ( url , ""rtp://"" , 6 ) ) return GF_FALSE ; if ( ! strnicmp ( url , ""plato://"" , 8 ) ) return GF_FALSE ; if ( ! strnicmp ( url , ""udp://"" , 6 ) ) return GF_FALSE ; if ( ! strnicmp ( url , ""tcp://"" , 6 ) ) return GF_FALSE ; if ( ! strnicmp ( url , ""data:"" , 5 ) ) return GF_FALSE ; ffd = ( FFDemux * ) plug -> priv ; <S2SV_StartBug> strcpy ( szName , url ) ; <S2SV_EndBug> ext = strrchr ( szName , '#' ) ; if ( ext ) ext [ 0 ] = 0 ; ext = strrchr ( szName , '?' ) ; if ( ext ) ext [ 0 ] = 0 ; ext = strrchr ( szName , '.' ) ; if ( ext && strlen ( ext ) > 19 ) ext = NULL ; <S2SV_StartBug> if ( ext && strlen ( ext ) > 1 ) { <S2SV_EndBug> strcpy ( szExt , & ext [ 1 ] ) ; strlwr ( szExt ) ; # ifndef FFMPEG_DEMUX_ENABLE_MPEG2TS if ( strstr ( ""ts<S2SV_blank>m2t<S2SV_blank>mts<S2SV_blank>dmb<S2SV_blank>trp"" , szExt ) ) return GF_FALSE ; # endif if ( ! strcmp ( szExt , ""mp4"" ) || ! strcmp ( szExt , ""mpg4"" ) || ! strcmp ( szExt , ""m4a"" ) || ! strcmp ( szExt , ""m21"" ) || ! strcmp ( szExt , ""m4v"" ) || ! strcmp ( szExt , ""m4a"" ) || ! strcmp ( szExt , ""m4s"" ) || ! strcmp ( szExt , ""3gs"" ) || ! strcmp ( szExt , ""3gp"" ) || ! strcmp ( szExt , ""3gpp"" ) || ! strcmp ( szExt , ""3gp2"" ) || ! strcmp ( szExt , ""3g2"" ) || ! strcmp ( szExt , ""mp3"" ) || ! strcmp ( szExt , ""ac3"" ) || ! strcmp ( szExt , ""amr"" ) || ! strcmp ( szExt , ""bt"" ) || ! strcmp ( szExt , ""wrl"" ) || ! strcmp ( szExt , ""x3dv"" ) || ! strcmp ( szExt , ""xmt"" ) || ! strcmp ( szExt , ""xmta"" ) || ! strcmp ( szExt , ""x3d"" ) || ! strcmp ( szExt , ""jpg"" ) || ! strcmp ( szExt , ""jpeg"" ) || ! strcmp ( szExt , ""png"" ) ) return GF_FALSE ; { u32 i ; for ( i = 0 ; FFD_MIME_TYPES [ i ] ; i += 3 ) { if ( gf_service_check_mime_register ( plug , FFD_MIME_TYPES [ i ] , FFD_MIME_TYPES [ i + 1 ] , FFD_MIME_TYPES [ i + 2 ] , ext ) ) return GF_TRUE ; } } } ffd_parse_options ( ffd , url ) ; ctx = NULL ; if ( open_file ( & ctx , szName , NULL , ffd -> options ? & ffd -> options : NULL ) < 0 ) { AVInputFormat * av_in = NULL ; if ( ext && ! strcmp ( szExt , ""cmp"" ) ) av_in = av_find_input_format ( ""m4v"" ) ; if ( open_file ( & ctx , szName , av_in , ffd -> options ? & ffd -> options : NULL ) < 0 ) { return GF_FALSE ; } } if ( ! ctx ) goto exit ; if ( av_find_stream_info ( ctx ) < 0 ) goto exit ; has_video = has_audio = GF_FALSE ; for ( i = 0 ; i < ( s32 ) ctx -> nb_streams ; i ++ ) { AVCodecContext * enc = ctx -> streams [ i ] -> codec ; switch ( enc -> codec_type ) { case AVMEDIA_TYPE_AUDIO : if ( ! has_audio ) has_audio = GF_TRUE ; break ; case AVMEDIA_TYPE_VIDEO : if ( ! has_video ) has_video = GF_TRUE ; break ; default : break ; } } if ( ! has_audio && ! has_video ) goto exit ; ret = GF_TRUE ; # if ( ( LIBAVFORMAT_VERSION_MAJOR == 52 ) && ( LIBAVFORMAT_VERSION_MINOR <= 47 ) ) || ( LIBAVFORMAT_VERSION_MAJOR < 52 ) fmt_out = guess_stream_format ( NULL , url , NULL ) ; # else fmt_out = av_guess_format ( NULL , url , NULL ) ; # endif if ( fmt_out ) gf_service_register_mime ( plug , fmt_out -> mime_type , fmt_out -> extensions , fmt_out -> name ) ; else { ext = strrchr ( szName , '.' ) ; if ( ext ) { strcpy ( szExt , & ext [ 1 ] ) ; strlwr ( szExt ) ; szExtList = gf_modules_get_option ( ( GF_BaseInterface * ) plug , ""MimeTypes"" , ""application/x-ffmpeg"" ) ; if ( ! szExtList ) { gf_service_register_mime ( plug , ""application/x-ffmpeg"" , szExt , ""Other<S2SV_blank>Movies<S2SV_blank>(FFMPEG)"" ) ; } else if ( ! strstr ( szExtList , szExt ) ) { u32 len ; char * buf ; len = ( u32 ) ( strlen ( szExtList ) + strlen ( szExt ) + 10 ) ; buf = ( char * ) gf_malloc ( sizeof ( char ) * len ) ; sprintf ( buf , ""\\""%s<S2SV_blank>"" , szExt ) ; strcat ( buf , & szExtList [ 1 ] ) ; gf_modules_set_option ( ( GF_BaseInterface * ) plug , ""MimeTypes"" , ""application/x-ffmpeg"" , buf ) ; gf_free ( buf ) ; } } } exit : # if FF_API_CLOSE_INPUT_FILE if ( ctx ) av_close_input_file ( ctx ) ; # else if ( ctx ) avformat_close_input ( & ctx ) ; # endif return ret ; }",", szName [ 1024 <S2SV_ModEnd> ] , szExt <S2SV_ModStart> -> priv ; if ( strlen ( url ) >= sizeof ( szName ) ) return GF_FALSE ; <S2SV_ModStart> ) > 1 && strlen ( ext ) <= sizeof ( szExt )"
218,"<S2SV_StartBug> void usage_exit ( ) { <S2SV_EndBug> fprintf ( stderr , ""Usage:<S2SV_blank>%s<S2SV_blank><infile><S2SV_blank><outfile><S2SV_blank><N-M|N/M>\\n"" , exec_name ) ; exit ( EXIT_FAILURE ) ; }",void usage_exit ( void
219,"static void <S2SV_StartBug> l2tp_msgtype_print ( netdissect_options * ndo , const u_char * dat ) <S2SV_EndBug> { <S2SV_StartBug> const uint16_t * ptr = ( const uint16_t * ) dat ; <S2SV_EndBug> ND_PRINT ( ( ndo , ""%s"" , tok2str ( l2tp_msgtype2str , ""MSGTYPE-#%u"" , EXTRACT_16BITS ( ptr ) ) ) ) ; }","u_char * dat , u_int length <S2SV_ModStart> ) dat ; if ( length < 2 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; return ; }"
220,static int check_line_charstring ( void ) { char * p = line ; <S2SV_StartBug> while ( isspace ( * p ) ) <S2SV_EndBug> p ++ ; return ( * p == '/' || ( p [ 0 ] == 'd' && p [ 1 ] == 'u' && p [ 2 ] == 'p' ) ) ; },( isspace ( ( unsigned char )
221,"static int ext4_write_end ( struct file * file , struct address_space * mapping , loff_t pos , unsigned len , unsigned copied , struct page * page , void * fsdata ) { handle_t * handle = ext4_journal_current_handle ( ) ; struct inode * inode = mapping -> host ; loff_t old_size = inode -> i_size ; int ret = 0 , ret2 ; int i_size_changed = 0 ; trace_ext4_write_end ( inode , pos , len , copied ) ; <S2SV_StartBug> if ( ext4_test_inode_state ( inode , EXT4_STATE_ORDERED_MODE ) ) { <S2SV_EndBug> ret = ext4_jbd2_file_inode ( handle , inode ) ; if ( ret ) { unlock_page ( page ) ; put_page ( page ) ; goto errout ; } } if ( ext4_has_inline_data ( inode ) ) { ret = ext4_write_inline_data_end ( inode , pos , len , copied , page ) ; if ( ret < 0 ) goto errout ; copied = ret ; } else copied = block_write_end ( file , mapping , pos , len , copied , page , fsdata ) ; i_size_changed = ext4_update_inode_size ( inode , pos + copied ) ; unlock_page ( page ) ; put_page ( page ) ; if ( old_size < pos ) pagecache_isize_extended ( inode , old_size , pos ) ; if ( i_size_changed ) ext4_mark_inode_dirty ( handle , inode ) ; if ( pos + len > inode -> i_size && ext4_can_truncate ( inode ) ) ext4_orphan_add ( handle , inode ) ; errout : ret2 = ext4_journal_stop ( handle ) ; if ( ! ret ) ret = ret2 ; if ( pos + len > inode -> i_size ) { ext4_truncate_failed_write ( inode ) ; if ( inode -> i_nlink ) ext4_orphan_del ( NULL , inode ) ; } return ret ? ret : copied ; }",; if ( <S2SV_ModEnd> ext4_has_inline_data ( inode
222,"static void GTextFieldSave ( GTextField * gt , int utf8 ) { unichar_t * ret ; char * cret ; FILE * file ; unichar_t * pt ; if ( _ggadget_use_gettext ) { char * temp = GWidgetOpenFile8 ( _ ( ""Save"" ) , NULL , ""*.{txt,py}"" , NULL , NULL ) ; ret = utf82u_copy ( temp ) ; free ( temp ) ; } else ret = GWidgetSaveAsFile ( GStringGetResource ( _STR_Save , NULL ) , NULL , txt , NULL , NULL ) ; if ( ret == NULL ) return ; cret = u2def_copy ( ret ) ; free ( ret ) ; file = fopen ( cret , ""w"" ) ; if ( file == NULL ) { if ( _ggadget_use_gettext ) GWidgetError8 ( _ ( ""Could<S2SV_blank>not<S2SV_blank>open<S2SV_blank>file"" ) , _ ( ""Could<S2SV_blank>not<S2SV_blank>open<S2SV_blank>%.100s"" ) , cret ) ; else GWidgetError ( errort , error , cret ) ; free ( cret ) ; return ; } free ( cret ) ; if ( utf8 ) { putc ( 0xef , file ) ; putc ( 0xbb , file ) ; putc ( 0xbf , file ) ; for ( pt = gt -> text ; * pt ; ++ pt ) { if ( * pt < 0x80 ) putc ( * pt , file ) ; else if ( * pt < 0x800 ) { putc ( 0xc0 | ( * pt >> 6 ) , file ) ; putc ( 0x80 | ( * pt & 0x3f ) , file ) ; } else if ( * pt >= 0xd800 && * pt < 0xdc00 && pt [ 1 ] >= 0xdc00 && pt [ 1 ] < 0xe000 ) { int u = ( ( * pt >> 6 ) & 0xf ) + 1 , y = ( ( * pt & 3 ) << 4 ) | ( ( pt [ 1 ] >> 6 ) & 0xf ) ; putc ( 0xf0 | ( u >> 2 ) , file ) ; putc ( 0x80 | ( ( u & 3 ) << 4 ) | ( ( * pt >> 2 ) & 0xf ) , file ) ; putc ( 0x80 | y , file ) ; putc ( 0x80 | ( pt [ 1 ] & 0x3f ) , file ) ; } else { putc ( 0xe0 | ( * pt >> 12 ) , file ) ; putc ( 0x80 | ( ( * pt >> 6 ) & 0x3f ) , file ) ; putc ( 0x80 | ( * pt & 0x3f ) , file ) ; } } } else { putc ( 0xfeff >> 8 , file ) ; putc ( 0xfeff & 0xff , file ) ; for ( pt = gt -> text ; * pt ; ++ pt ) { putc ( * pt >> 8 , file ) ; putc ( * pt & 0xff , file ) ; } } fclose ( file ) ; <S2SV_StartBug> } <S2SV_EndBug>",file ) ; GTextFieldSaved ( gt ) ;
223,"<S2SV_StartBug> static struct ip_options * tcp_v4_save_options ( struct sock * sk , <S2SV_EndBug> struct sk_buff * skb ) { <S2SV_StartBug> struct ip_options * opt = & ( IPCB ( skb ) -> opt ) ; <S2SV_EndBug> <S2SV_StartBug> struct ip_options * dopt = NULL ; <S2SV_EndBug> if ( opt && opt -> optlen ) { <S2SV_StartBug> int opt_size = optlength ( opt ) ; <S2SV_EndBug> dopt = kmalloc ( opt_size , GFP_ATOMIC ) ; if ( dopt ) { <S2SV_StartBug> if ( ip_options_echo ( dopt , skb ) ) { <S2SV_EndBug> kfree ( dopt ) ; dopt = NULL ; } } } return dopt ; }","<S2SV_null> static struct ip_options_rcu <S2SV_ModEnd> * tcp_v4_save_options ( <S2SV_ModStart> skb ) { const <S2SV_ModStart> ) ; struct ip_options_rcu <S2SV_ModEnd> * dopt = <S2SV_ModStart> int opt_size = sizeof ( * dopt ) + opt -> optlen <S2SV_ModEnd> ; dopt = <S2SV_ModStart> ( ip_options_echo ( & dopt -> opt <S2SV_ModEnd> , skb )"
224,"static int replace_map_fd_with_map_ptr ( struct verifier_env * env ) { struct bpf_insn * insn = env -> prog -> insnsi ; int insn_cnt = env -> prog -> len ; int i , j ; for ( i = 0 ; i < insn_cnt ; i ++ , insn ++ ) { if ( BPF_CLASS ( insn -> code ) == BPF_LDX && ( BPF_MODE ( insn -> code ) != BPF_MEM || insn -> imm != 0 ) ) { verbose ( ""BPF_LDX<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n"" ) ; return - EINVAL ; } if ( BPF_CLASS ( insn -> code ) == BPF_STX && ( ( BPF_MODE ( insn -> code ) != BPF_MEM && BPF_MODE ( insn -> code ) != BPF_XADD ) || insn -> imm != 0 ) ) { verbose ( ""BPF_STX<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n"" ) ; return - EINVAL ; } if ( insn [ 0 ] . code == ( BPF_LD | BPF_IMM | BPF_DW ) ) { struct bpf_map * map ; struct fd f ; if ( i == insn_cnt - 1 || insn [ 1 ] . code != 0 || insn [ 1 ] . dst_reg != 0 || insn [ 1 ] . src_reg != 0 || insn [ 1 ] . off != 0 ) { verbose ( ""invalid<S2SV_blank>bpf_ld_imm64<S2SV_blank>insn\\n"" ) ; return - EINVAL ; } if ( insn -> src_reg == 0 ) goto next_insn ; if ( insn -> src_reg != BPF_PSEUDO_MAP_FD ) { verbose ( ""unrecognized<S2SV_blank>bpf_ld_imm64<S2SV_blank>insn\\n"" ) ; return - EINVAL ; } f = fdget ( insn -> imm ) ; map = __bpf_map_get ( f ) ; if ( IS_ERR ( map ) ) { verbose ( ""fd<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>not<S2SV_blank>pointing<S2SV_blank>to<S2SV_blank>valid<S2SV_blank>bpf_map\\n"" , insn -> imm ) ; return PTR_ERR ( map ) ; } insn [ 0 ] . imm = ( u32 ) ( unsigned long ) map ; insn [ 1 ] . imm = ( ( u64 ) ( unsigned long ) map ) >> 32 ; for ( j = 0 ; j < env -> used_map_cnt ; j ++ ) if ( env -> used_maps [ j ] == map ) { fdput ( f ) ; goto next_insn ; } if ( env -> used_map_cnt >= MAX_USED_MAPS ) { fdput ( f ) ; return - E2BIG ; } <S2SV_StartBug> env -> used_maps [ env -> used_map_cnt ++ ] = map ; <S2SV_EndBug> <S2SV_StartBug> bpf_map_inc ( map , false ) ; <S2SV_EndBug> fdput ( f ) ; next_insn : insn ++ ; i ++ ; } } return 0 ; }","E2BIG ; } map = bpf_map_inc ( map , false ) ; if ( IS_ERR ( map ) ) { fdput ( f ) ; return PTR_ERR ( map ) ; } <S2SV_ModStart> = map ; <S2SV_ModEnd> fdput ( f"
225,"void read_boot ( DOS_FS * fs ) { struct boot_sector b ; unsigned total_sectors ; unsigned short logical_sector_size , sectors ; <S2SV_StartBug> unsigned fat_length ; <S2SV_EndBug> unsigned total_fat_entries ; off_t data_size ; fs_read ( 0 , sizeof ( b ) , & b ) ; logical_sector_size = GET_UNALIGNED_W ( b . sector_size ) ; if ( ! logical_sector_size ) die ( ""Logical<S2SV_blank>sector<S2SV_blank>size<S2SV_blank>is<S2SV_blank>zero."" ) ; if ( logical_sector_size & ( SECTOR_SIZE - 1 ) ) die ( ""Logical<S2SV_blank>sector<S2SV_blank>size<S2SV_blank>(%d<S2SV_blank>bytes)<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>multiple<S2SV_blank>of<S2SV_blank>the<S2SV_blank>physical<S2SV_blank>"" ""sector<S2SV_blank>size."" , logical_sector_size ) ; fs -> cluster_size = b . cluster_size * logical_sector_size ; if ( ! fs -> cluster_size ) die ( ""Cluster<S2SV_blank>size<S2SV_blank>is<S2SV_blank>zero."" ) ; if ( b . fats != 2 && b . fats != 1 ) die ( ""Currently,<S2SV_blank>only<S2SV_blank>1<S2SV_blank>or<S2SV_blank>2<S2SV_blank>FATs<S2SV_blank>are<S2SV_blank>supported,<S2SV_blank>not<S2SV_blank>%d.\\n"" , b . fats ) ; fs -> nfats = b . fats ; sectors = GET_UNALIGNED_W ( b . sectors ) ; total_sectors = sectors ? sectors : le32toh ( b . total_sect ) ; if ( verbose ) printf ( ""Checking<S2SV_blank>we<S2SV_blank>can<S2SV_blank>access<S2SV_blank>the<S2SV_blank>last<S2SV_blank>sector<S2SV_blank>of<S2SV_blank>the<S2SV_blank>filesystem\\n"" ) ; fs_test ( ( off_t ) ( ( total_sectors & ~ 1 ) - 1 ) * logical_sector_size , logical_sector_size ) ; fat_length = le16toh ( b . fat_length ) ? le16toh ( b . fat_length ) : le32toh ( b . fat32_length ) ; <S2SV_StartBug> fs -> fat_start = ( off_t ) le16toh ( b . reserved ) * logical_sector_size ; <S2SV_EndBug> fs -> root_start = ( ( off_t ) le16toh ( b . reserved ) + b . fats * fat_length ) * logical_sector_size ; fs -> root_entries = GET_UNALIGNED_W ( b . dir_entries ) ; fs -> data_start = fs -> root_start + ROUND_TO_MULTIPLE ( fs -> root_entries << MSDOS_DIR_BITS , logical_sector_size ) ; <S2SV_StartBug> data_size = ( off_t ) total_sectors * logical_sector_size - fs -> data_start ; <S2SV_EndBug> fs -> data_clusters = data_size / fs -> cluster_size ; fs -> root_cluster = 0 ; fs -> fsinfo_start = 0 ; fs -> free_clusters = - 1 ; if ( ! b . fat_length && b . fat32_length ) { fs -> fat_bits = 32 ; fs -> root_cluster = le32toh ( b . root_cluster ) ; if ( ! fs -> root_cluster && fs -> root_entries ) printf ( ""Warning:<S2SV_blank>FAT32<S2SV_blank>root<S2SV_blank>dir<S2SV_blank>not<S2SV_blank>in<S2SV_blank>cluster<S2SV_blank>chain!<S2SV_blank>"" ""Compatibility<S2SV_blank>mode...\\n"" ) ; else if ( ! fs -> root_cluster && ! fs -> root_entries ) die ( ""No<S2SV_blank>root<S2SV_blank>directory!"" ) ; else if ( fs -> root_cluster && fs -> root_entries ) printf ( ""Warning:<S2SV_blank>FAT32<S2SV_blank>root<S2SV_blank>dir<S2SV_blank>is<S2SV_blank>in<S2SV_blank>a<S2SV_blank>cluster<S2SV_blank>chain,<S2SV_blank>but<S2SV_blank>"" ""a<S2SV_blank>separate<S2SV_blank>root<S2SV_blank>dir\\n"" ""<S2SV_blank><S2SV_blank>area<S2SV_blank>is<S2SV_blank>defined.<S2SV_blank>Cannot<S2SV_blank>fix<S2SV_blank>this<S2SV_blank>easily.\\n"" ) ; if ( fs -> data_clusters < FAT16_THRESHOLD ) printf ( ""Warning:<S2SV_blank>Filesystem<S2SV_blank>is<S2SV_blank>FAT32<S2SV_blank>according<S2SV_blank>to<S2SV_blank>fat_length<S2SV_blank>"" ""and<S2SV_blank>fat32_length<S2SV_blank>fields,\\n"" ""<S2SV_blank><S2SV_blank>but<S2SV_blank>has<S2SV_blank>only<S2SV_blank>%lu<S2SV_blank>clusters,<S2SV_blank>less<S2SV_blank>than<S2SV_blank>the<S2SV_blank>required<S2SV_blank>"" ""minimum<S2SV_blank>of<S2SV_blank>%d.\\n"" ""<S2SV_blank><S2SV_blank>This<S2SV_blank>may<S2SV_blank>lead<S2SV_blank>to<S2SV_blank>problems<S2SV_blank>on<S2SV_blank>some<S2SV_blank>systems.\\n"" , ( unsigned long ) fs -> data_clusters , FAT16_THRESHOLD ) ; check_fat_state_bit ( fs , & b ) ; fs -> backupboot_start = le16toh ( b . backup_boot ) * logical_sector_size ; check_backup_boot ( fs , & b , logical_sector_size ) ; read_fsinfo ( fs , & b , logical_sector_size ) ; } else if ( ! atari_format ) { fs -> fat_bits = ( fs -> data_clusters >= FAT12_THRESHOLD ) ? 16 : 12 ; if ( fs -> data_clusters >= FAT16_THRESHOLD ) die ( ""Too<S2SV_blank>many<S2SV_blank>clusters<S2SV_blank>(%lu)<S2SV_blank>for<S2SV_blank>FAT16<S2SV_blank>filesystem."" , fs -> data_clusters ) ; check_fat_state_bit ( fs , & b ) ; } else { fs -> fat_bits = 16 ; if ( fs -> data_clusters + 2 > fat_length * logical_sector_size * 8 / 16 || ( total_sectors == 720 || total_sectors == 1440 || total_sectors == 2880 ) ) fs -> fat_bits = 12 ; } fs -> eff_fat_bits = ( fs -> fat_bits == 32 ) ? 28 : fs -> fat_bits ; fs -> fat_size = fat_length * logical_sector_size ; fs -> label = calloc ( 12 , sizeof ( uint8_t ) ) ; if ( fs -> fat_bits == 12 || fs -> fat_bits == 16 ) { struct boot_sector_16 * b16 = ( struct boot_sector_16 * ) & b ; if ( b16 -> extended_sig == 0x29 ) memmove ( fs -> label , b16 -> label , 11 ) ; else fs -> label = NULL ; } else if ( fs -> fat_bits == 32 ) { if ( b . extended_sig == 0x29 ) memmove ( fs -> label , & b . label , 11 ) ; else fs -> label = NULL ; } total_fat_entries = ( uint64_t ) fs -> fat_size * 8 / fs -> fat_bits ; if ( fs -> data_clusters > total_fat_entries - 2 ) die ( ""Filesystem<S2SV_blank>has<S2SV_blank>%u<S2SV_blank>clusters<S2SV_blank>but<S2SV_blank>only<S2SV_blank>space<S2SV_blank>for<S2SV_blank>%u<S2SV_blank>FAT<S2SV_blank>entries."" , fs -> data_clusters , total_fat_entries - 2 ) ; if ( ! fs -> root_entries && ! fs -> root_cluster ) die ( ""Root<S2SV_blank>directory<S2SV_blank>has<S2SV_blank>zero<S2SV_blank>size."" ) ; if ( fs -> root_entries & ( MSDOS_DPS - 1 ) ) die ( ""Root<S2SV_blank>directory<S2SV_blank>(%d<S2SV_blank>entries)<S2SV_blank>doesn\'t<S2SV_blank>span<S2SV_blank>an<S2SV_blank>integral<S2SV_blank>number<S2SV_blank>of<S2SV_blank>"" ""sectors."" , fs -> root_entries ) ; if ( logical_sector_size & ( SECTOR_SIZE - 1 ) ) die ( ""Logical<S2SV_blank>sector<S2SV_blank>size<S2SV_blank>(%d<S2SV_blank>bytes)<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>multiple<S2SV_blank>of<S2SV_blank>the<S2SV_blank>physical<S2SV_blank>"" ""sector<S2SV_blank>size."" , logical_sector_size ) ; # if 0 if ( ! atari_format && ( ! b . secs_track || ! b . heads ) ) die ( ""Invalid<S2SV_blank>disk<S2SV_blank>format<S2SV_blank>in<S2SV_blank>boot<S2SV_blank>sector."" ) ; # endif if ( verbose ) dump_boot ( fs , & b , logical_sector_size ) ; }",", sectors ; off_t <S2SV_ModEnd> fat_length ; unsigned <S2SV_ModStart> fat32_length ) ; if ( ! fat_length ) die ( ""FAT<S2SV_blank>size<S2SV_blank>is<S2SV_blank>zero."" ) ; <S2SV_ModStart> fs -> data_start ; if ( data_size < fs -> cluster_size ) die ( ""Filesystem<S2SV_blank>has<S2SV_blank>no<S2SV_blank>space<S2SV_blank>for<S2SV_blank>any<S2SV_blank>data<S2SV_blank>clusters"" )"
226,"static int xfrm_alloc_replay_state_esn ( struct xfrm_replay_state_esn * * replay_esn , struct xfrm_replay_state_esn * * preplay_esn , struct nlattr * rta ) { struct xfrm_replay_state_esn * p , * pp , * up ; <S2SV_StartBug> if ( ! rta ) <S2SV_EndBug> return 0 ; up = nla_data ( rta ) ; <S2SV_StartBug> p = kmemdup ( up , xfrm_replay_state_esn_len ( up ) , GFP_KERNEL ) ; <S2SV_EndBug> if ( ! p ) return - ENOMEM ; <S2SV_StartBug> pp = kmemdup ( up , xfrm_replay_state_esn_len ( up ) , GFP_KERNEL ) ; <S2SV_EndBug> if ( ! pp ) { kfree ( p ) ; return - ENOMEM ; } <S2SV_StartBug> * replay_esn = p ; <S2SV_EndBug> * preplay_esn = pp ; return 0 ; }","* up ; int klen , ulen ; <S2SV_ModStart> rta ) ; klen = <S2SV_ModEnd> xfrm_replay_state_esn_len ( up <S2SV_ModStart> ( up ) ; ulen = nla_len ( rta ) >= klen ? klen : sizeof ( * up ) ; p = kzalloc ( klen <S2SV_ModStart> ; pp = kzalloc ( klen <S2SV_ModEnd> , GFP_KERNEL ) <S2SV_ModStart> ENOMEM ; } memcpy ( p , up , ulen ) ; memcpy ( pp , up , ulen ) ;"
227,"void jiffies_to_timeval ( const unsigned long jiffies , struct timeval * value ) { <S2SV_StartBug> u64 nsec = ( u64 ) jiffies * TICK_NSEC ; <S2SV_EndBug> long tv_usec ; <S2SV_StartBug> value -> tv_sec = div_long_long_rem ( nsec , NSEC_PER_SEC , & tv_usec ) ; <S2SV_EndBug> tv_usec /= NSEC_PER_USEC ; <S2SV_StartBug> value -> tv_usec = tv_usec ; <S2SV_EndBug> }","value ) { u32 rem ; value -> tv_sec = div_u64_rem ( <S2SV_ModEnd> ( u64 ) <S2SV_ModStart> jiffies * TICK_NSEC , <S2SV_ModEnd> NSEC_PER_SEC , & <S2SV_ModStart> NSEC_PER_SEC , & rem ) <S2SV_ModEnd> ; value -> <S2SV_ModStart> -> tv_usec = rem / NSEC_PER_USEC <S2SV_ModEnd> ; } <S2SV_null>"
228,"static char * isis_print_id ( const uint8_t * cp , int id_len ) { int i ; static char id [ sizeof ( ""xxxx.xxxx.xxxx.yy-zz"" ) ] ; char * pos = id ; <S2SV_StartBug> for ( i = 1 ; i <= SYSTEM_ID_LEN ; i ++ ) { <S2SV_EndBug> snprintf ( pos , sizeof ( id ) - ( pos - id ) , ""%02x"" , * cp ++ ) ; pos += strlen ( pos ) ; if ( i == 2 || i == 4 ) * pos ++ = '.' ; } if ( id_len >= NODE_ID_LEN ) { snprintf ( pos , sizeof ( id ) - ( pos - id ) , "".%02x"" , * cp ++ ) ; pos += strlen ( pos ) ; } if ( id_len == LSP_ID_LEN ) snprintf ( pos , sizeof ( id ) - ( pos - id ) , ""-%02x"" , * cp ) ; return ( id ) ; }",= id ; int sysid_len ; sysid_len = SYSTEM_ID_LEN ; if ( sysid_len > id_len ) sysid_len = id_len ; <S2SV_ModStart> ; i <= sysid_len <S2SV_ModEnd> ; i ++
229,"static float * get_window ( vorb * f , int len ) { len <<= 1 ; if ( len == f -> blocksize_0 ) return f -> window [ 0 ] ; if ( len == f -> blocksize_1 ) return f -> window [ 1 ] ; <S2SV_StartBug> assert ( 0 ) ; <S2SV_EndBug> return NULL ; }",1 ] ; <S2SV_ModEnd> return NULL ;
230,"void mp_encode_lua_table_as_map ( lua_State * L , mp_buf * buf , int level ) { <S2SV_StartBug> size_t len = 0 ; <S2SV_EndBug> lua_pushnil ( L ) ; while ( lua_next ( L , - 2 ) ) { lua_pop ( L , 1 ) ; len ++ ; } mp_encode_map ( L , buf , len ) ; lua_pushnil ( L ) ; while ( lua_next ( L , - 2 ) ) { lua_pushvalue ( L , - 2 ) ; mp_encode_lua_type ( L , buf , level + 1 ) ; mp_encode_lua_type ( L , buf , level + 1 ) ; } }","len = 0 ; luaL_checkstack ( L , 3 , ""in<S2SV_blank>function<S2SV_blank>mp_encode_lua_table_as_map"" )"
231,"void cipso_v4_sock_delattr ( struct sock * sk ) { int hdr_delta ; <S2SV_StartBug> struct ip_options * opt ; <S2SV_EndBug> struct inet_sock * sk_inet ; sk_inet = inet_sk ( sk ) ; <S2SV_StartBug> opt = sk_inet -> opt ; <S2SV_EndBug> <S2SV_StartBug> if ( opt == NULL || opt -> cipso == 0 ) <S2SV_EndBug> return ; <S2SV_StartBug> hdr_delta = cipso_v4_delopt ( & sk_inet -> opt ) ; <S2SV_EndBug> if ( sk_inet -> is_icsk && hdr_delta > 0 ) { struct inet_connection_sock * sk_conn = inet_csk ( sk ) ; sk_conn -> icsk_ext_hdr_len -= hdr_delta ; sk_conn -> icsk_sync_mss ( sk , sk_conn -> icsk_pmtu_cookie ) ; } }","hdr_delta ; struct ip_options_rcu <S2SV_ModEnd> * opt ; <S2SV_ModStart> ; opt = rcu_dereference_protected ( sk_inet -> inet_opt , 1 ) <S2SV_ModEnd> ; if ( <S2SV_ModStart> || opt -> opt . <S2SV_ModStart> & sk_inet -> inet_opt <S2SV_ModEnd> ) ; if"
232,"int dns_packet_is_reply_for ( DnsPacket * p , const DnsResourceKey * key ) { int r ; assert ( p ) ; assert ( key ) ; if ( DNS_PACKET_QR ( p ) != 1 ) return 0 ; r = dns_packet_extract ( p ) ; if ( r < 0 ) return r ; <S2SV_StartBug> if ( p -> question -> n_keys != 1 ) <S2SV_EndBug> return 0 ; return dns_resource_key_equal ( p -> question -> keys [ 0 ] , key ) ; }",; if ( ! p -> question ) return 0 ; if (
233,"static int snd_timer_user_release ( struct inode * inode , struct file * file ) { struct snd_timer_user * tu ; if ( file -> private_data ) { tu = file -> private_data ; file -> private_data = NULL ; <S2SV_StartBug> if ( tu -> timeri ) <S2SV_EndBug> <S2SV_StartBug> snd_timer_close ( tu -> timeri ) ; <S2SV_EndBug> kfree ( tu -> queue ) ; kfree ( tu -> tqueue ) ; kfree ( tu ) ; } return 0 ; }",= NULL ; mutex_lock ( & tu -> ioctl_lock ) ; <S2SV_ModStart> tu -> timeri ) ; mutex_unlock ( & tu -> ioctl_lock
234,"static vpx_codec_err_t vp8_peek_si_internal ( const uint8_t * data , unsigned int data_sz , vpx_codec_stream_info_t * si , vpx_decrypt_cb decrypt_cb , void * decrypt_state ) { vpx_codec_err_t res = VPX_CODEC_OK ; if ( data + data_sz <= data ) { res = VPX_CODEC_INVALID_PARAM ; } else { uint8_t clear_buffer [ 10 ] ; const uint8_t * clear = data ; if ( decrypt_cb ) { int n = MIN ( sizeof ( clear_buffer ) , data_sz ) ; decrypt_cb ( decrypt_state , data , clear_buffer , n ) ; clear = clear_buffer ; } si -> is_kf = 0 ; if ( data_sz >= 10 && ! ( clear [ 0 ] & 0x01 ) ) { si -> is_kf = 1 ; if ( clear [ 3 ] != 0x9d || clear [ 4 ] != 0x01 || clear [ 5 ] != 0x2a ) return VPX_CODEC_UNSUP_BITSTREAM ; si -> w = ( clear [ 6 ] | ( clear [ 7 ] << 8 ) ) & 0x3fff ; si -> h = ( clear [ 8 ] | ( clear [ 9 ] << 8 ) ) & 0x3fff ; <S2SV_StartBug> if ( ! ( si -> h | si -> w ) ) <S2SV_EndBug> <S2SV_StartBug> res = VPX_CODEC_UNSUP_BITSTREAM ; <S2SV_EndBug> } <S2SV_StartBug> else <S2SV_EndBug> { res = VPX_CODEC_UNSUP_BITSTREAM ; } } return res ; }",si -> h && <S2SV_ModEnd> si -> w <S2SV_ModStart> ) res = VPX_CODEC_CORRUPT_FRAME ; } else { res = <S2SV_ModStart> VPX_CODEC_UNSUP_BITSTREAM ; } <S2SV_ModEnd> } return res
235,"<S2SV_StartBug> int xmkstemp ( char * * tmpname , char * dir ) <S2SV_EndBug> { char * localtmp ; <S2SV_StartBug> char * tmpenv ; <S2SV_EndBug> mode_t old_mode ; int fd , rc ; <S2SV_StartBug> if ( dir != NULL ) <S2SV_EndBug> <S2SV_StartBug> tmpenv = dir ; <S2SV_EndBug> else tmpenv = getenv ( ""TMPDIR"" ) ; <S2SV_StartBug> if ( tmpenv ) <S2SV_EndBug> rc = asprintf ( & localtmp , ""%s/%s.XXXXXX"" , tmpenv , <S2SV_StartBug> program_invocation_short_name ) ; <S2SV_EndBug> else rc = asprintf ( & localtmp , ""%s/%s.XXXXXX"" , _PATH_TMP , program_invocation_short_name ) ; if ( rc < 0 ) return - 1 ; old_mode = umask ( 077 ) ; fd = mkostemp ( localtmp , O_RDWR | O_CREAT | O_EXCL | O_CLOEXEC ) ; umask ( old_mode ) ; if ( fd == - 1 ) { free ( localtmp ) ; localtmp = NULL ; } * tmpname = localtmp ; return fd ; }","* tmpname , const <S2SV_ModStart> char * dir , const char * prefix <S2SV_ModStart> * localtmp ; const <S2SV_ModStart> , rc ; <S2SV_ModEnd> tmpenv = dir <S2SV_ModStart> tmpenv = dir ? dir : <S2SV_ModEnd> getenv ( ""TMPDIR"" <S2SV_ModStart> ; if ( ! tmpenv ) tmpenv = _PATH_TMP ; <S2SV_ModEnd> rc = asprintf <S2SV_ModStart> , tmpenv , prefix <S2SV_ModEnd> ) ; if"
236,"int ssl3_read_n ( SSL * s , int n , int max , int extend ) { int i , len , left ; long align = 0 ; unsigned char * pkt ; SSL3_BUFFER * rb ; if ( n <= 0 ) return n ; rb = & ( s -> s3 -> rbuf ) ; if ( rb -> buf == NULL ) if ( ! ssl3_setup_read_buffer ( s ) ) return - 1 ; left = rb -> left ; # if defined ( SSL3_ALIGN_PAYLOAD ) && SSL3_ALIGN_PAYLOAD != 0 align = ( long ) rb -> buf + SSL3_RT_HEADER_LENGTH ; align = ( - align ) & ( SSL3_ALIGN_PAYLOAD - 1 ) ; # endif if ( ! extend ) { if ( left == 0 ) rb -> offset = align ; else if ( align != 0 && left >= SSL3_RT_HEADER_LENGTH ) { pkt = rb -> buf + rb -> offset ; if ( pkt [ 0 ] == SSL3_RT_APPLICATION_DATA && ( pkt [ 3 ] << 8 | pkt [ 4 ] ) >= 128 ) { memmove ( rb -> buf + align , pkt , left ) ; rb -> offset = align ; } } s -> packet = rb -> buf + rb -> offset ; s -> packet_length = 0 ; } if ( SSL_IS_DTLS ( s ) ) { <S2SV_StartBug> if ( left > 0 && n > left ) <S2SV_EndBug> n = left ; } if ( left >= n ) { s -> packet_length += n ; rb -> left = left - n ; rb -> offset += n ; return ( n ) ; } len = s -> packet_length ; pkt = rb -> buf + align ; if ( s -> packet != pkt ) { memmove ( pkt , s -> packet , len + left ) ; s -> packet = pkt ; rb -> offset = len + align ; } if ( n > ( int ) ( rb -> len - rb -> offset ) ) { SSLerr ( SSL_F_SSL3_READ_N , ERR_R_INTERNAL_ERROR ) ; return - 1 ; } if ( ! s -> read_ahead ) max = n ; else { if ( max < n ) max = n ; if ( max > ( int ) ( rb -> len - rb -> offset ) ) max = rb -> len - rb -> offset ; } while ( left < n ) { clear_sys_error ( ) ; if ( s -> rbio != NULL ) { s -> rwstate = SSL_READING ; i = BIO_read ( s -> rbio , pkt + len + left , max - left ) ; } else { SSLerr ( SSL_F_SSL3_READ_N , SSL_R_READ_BIO_NOT_SET ) ; i = - 1 ; } if ( i <= 0 ) { rb -> left = left ; if ( s -> mode & SSL_MODE_RELEASE_BUFFERS && ! SSL_IS_DTLS ( s ) ) if ( len + left == 0 ) ssl3_release_read_buffer ( s ) ; return ( i ) ; } left += i ; if ( SSL_IS_DTLS ( s ) ) { if ( n > left ) n = left ; } } rb -> offset += n ; rb -> left = left - n ; s -> packet_length += n ; s -> rwstate = SSL_NOTHING ; return ( n ) ; }",if ( left == 0 && extend ) return 0 ; if ( left
237,"static struct usmStateReference * usm_malloc_usmStateReference ( void ) { <S2SV_StartBug> struct usmStateReference * retval = ( struct usmStateReference * ) <S2SV_EndBug> calloc ( 1 , sizeof ( struct usmStateReference ) ) ; <S2SV_StartBug> return retval ; <S2SV_EndBug> }",usmStateReference * retval ; retval = <S2SV_ModEnd> calloc ( 1 <S2SV_ModStart> ) ) ; if ( retval ) retval -> refcnt = 1 ;
238,"static int inv_recenter_nonneg ( int v , int m ) { if ( v > 2 * m ) return v ; <S2SV_StartBug> return v % 2 ? m - ( v + 1 ) / 2 : m + v / 2 ; <S2SV_EndBug> }",v ; return ( v & 1 ) <S2SV_ModEnd> ? m - <S2SV_ModStart> ? m - ( <S2SV_ModStart> + 1 ) >> 1 ) <S2SV_ModEnd> : m + <S2SV_ModStart> : m + ( v >> 1 ) <S2SV_ModEnd> ; } <S2SV_null>
239,"static int print_ccp_config_options ( netdissect_options * ndo , const u_char * p , int length ) { int len , opt ; if ( length < 2 ) return 0 ; ND_TCHECK2 ( * p , 2 ) ; len = p [ 1 ] ; opt = p [ 0 ] ; if ( length < len ) return 0 ; if ( len < 2 ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Option<S2SV_blank>(0x%02x),<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>2)"" , tok2str ( ccpconfopts_values , ""Unknown"" , opt ) , opt , len ) ) ; return 0 ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Option<S2SV_blank>(0x%02x),<S2SV_blank>length<S2SV_blank>%u"" , tok2str ( ccpconfopts_values , ""Unknown"" , opt ) , opt , len ) ) ; switch ( opt ) { case CCPOPT_BSDCOMP : if ( len < 3 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>3)"" ) ) ; return len ; } <S2SV_StartBug> ND_TCHECK2 ( * ( p + 2 ) , 1 ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , "":<S2SV_blank>Version:<S2SV_blank>%u,<S2SV_blank>Dictionary<S2SV_blank>Bits:<S2SV_blank>%u"" , p [ 2 ] >> 5 , p [ 2 ] & 0x1f ) ) ; break ; case CCPOPT_MVRCA : if ( len < 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>4)"" ) ) ; return len ; } <S2SV_StartBug> ND_TCHECK2 ( * ( p + 2 ) , 1 ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , "":<S2SV_blank>Features:<S2SV_blank>%u,<S2SV_blank>PxP:<S2SV_blank>%s,<S2SV_blank>History:<S2SV_blank>%u,<S2SV_blank>#CTX-ID:<S2SV_blank>%u"" , ( p [ 2 ] & 0xc0 ) >> 6 , ( p [ 2 ] & 0x20 ) ? ""Enabled"" : ""Disabled"" , p [ 2 ] & 0x1f , p [ 3 ] ) ) ; break ; case CCPOPT_DEFLATE : if ( len < 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>4)"" ) ) ; return len ; } <S2SV_StartBug> ND_TCHECK2 ( * ( p + 2 ) , 1 ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , "":<S2SV_blank>Window:<S2SV_blank>%uK,<S2SV_blank>Method:<S2SV_blank>%s<S2SV_blank>(0x%x),<S2SV_blank>MBZ:<S2SV_blank>%u,<S2SV_blank>CHK:<S2SV_blank>%u"" , ( p [ 2 ] & 0xf0 ) >> 4 , ( ( p [ 2 ] & 0x0f ) == 8 ) ? ""zlib"" : ""unknown"" , p [ 2 ] & 0x0f , ( p [ 3 ] & 0xfc ) >> 2 , p [ 3 ] & 0x03 ) ) ; break ; # if 0 case CCPOPT_OUI : case CCPOPT_PRED1 : case CCPOPT_PRED2 : case CCPOPT_PJUMP : case CCPOPT_HPPPC : case CCPOPT_STACLZS : case CCPOPT_MPPC : case CCPOPT_GFZA : case CCPOPT_V42BIS : case CCPOPT_LZSDCP : case CCPOPT_DEC : case CCPOPT_RESV : break ; # endif default : if ( ndo -> ndo_vflag < 2 ) print_unknown_data ( ndo , & p [ 2 ] , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , len - 2 ) ; break ; } if ( ndo -> ndo_vflag > 1 ) print_unknown_data ( ndo , & p [ 2 ] , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , len - 2 ) ; return len ; trunc : ND_PRINT ( ( ndo , ""[|ccp]"" ) ) ; return 0 ; }",len ; } ND_TCHECK ( p [ 2 ] <S2SV_ModEnd> ) ; ND_PRINT <S2SV_ModStart> len ; } ND_TCHECK ( p [ 3 ] <S2SV_ModEnd> ) ; ND_PRINT <S2SV_ModStart> len ; } ND_TCHECK ( p [ 3 ] <S2SV_ModEnd> ) ; ND_PRINT
240,"stmt_ty FunctionDef ( identifier name , arguments_ty args , asdl_seq * body , asdl_seq * <S2SV_StartBug> decorator_list , expr_ty returns , int lineno , int col_offset , int <S2SV_EndBug> end_lineno , int end_col_offset , PyArena * arena ) { stmt_ty p ; if ( ! name ) { PyErr_SetString ( PyExc_ValueError , ""field<S2SV_blank>name<S2SV_blank>is<S2SV_blank>required<S2SV_blank>for<S2SV_blank>FunctionDef"" ) ; return NULL ; } if ( ! args ) { PyErr_SetString ( PyExc_ValueError , ""field<S2SV_blank>args<S2SV_blank>is<S2SV_blank>required<S2SV_blank>for<S2SV_blank>FunctionDef"" ) ; return NULL ; } p = ( stmt_ty ) PyArena_Malloc ( arena , sizeof ( * p ) ) ; if ( ! p ) return NULL ; p -> kind = FunctionDef_kind ; p -> v . FunctionDef . name = name ; p -> v . FunctionDef . args = args ; p -> v . FunctionDef . body = body ; p -> v . FunctionDef . decorator_list = decorator_list ; <S2SV_StartBug> p -> v . FunctionDef . returns = returns ; <S2SV_EndBug> p -> lineno = lineno ; p -> col_offset = col_offset ; p -> end_lineno = end_lineno ; p -> end_col_offset = end_col_offset ; return p ; }","expr_ty returns , string type_comment , <S2SV_ModStart> returns = returns ; p -> v . FunctionDef . type_comment = type_comment"
241,"struct request * blk_mq_tag_to_rq ( struct blk_mq_tags * tags , unsigned int tag ) { <S2SV_StartBug> struct request * rq = tags -> rqs [ tag ] ; <S2SV_EndBug> <S2SV_StartBug> struct blk_flush_queue * fq = blk_get_flush_queue ( rq -> q , rq -> mq_ctx ) ; <S2SV_EndBug> if ( ! is_flush_request ( rq , fq , tag ) ) return rq ; return fq -> flush_rq ; }",tag ) { return <S2SV_ModEnd> tags -> rqs <S2SV_ModStart> tag ] ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
242,"static int fsck_gitmodules_fn ( const char * var , const char * value , void * vdata ) { struct fsck_gitmodules_data * data = vdata ; const char * subsection , * key ; int subsection_len ; char * name ; if ( parse_config_key ( var , ""submodule"" , & subsection , & subsection_len , & key ) < 0 || ! subsection ) return 0 ; name = xmemdupz ( subsection , subsection_len ) ; if ( check_submodule_name ( name ) < 0 ) data -> ret |= report ( data -> options , data -> obj , FSCK_MSG_GITMODULES_NAME , ""disallowed<S2SV_blank>submodule<S2SV_blank>name:<S2SV_blank>%s"" , name ) ; <S2SV_StartBug> free ( name ) ; <S2SV_EndBug> return 0 ; }","name ) ; if ( ! strcmp ( key , ""url"" ) && value && looks_like_command_line_option ( value ) ) data -> ret |= report ( data -> options , data -> obj , FSCK_MSG_GITMODULES_URL , ""disallowed<S2SV_blank>submodule<S2SV_blank>url:<S2SV_blank>%s"" , value ) ;"
243,"static void read_ref_frames ( VP9_COMMON * const cm , MACROBLOCKD * const xd , <S2SV_StartBug> vp9_reader * r , <S2SV_EndBug> int segment_id , MV_REFERENCE_FRAME ref_frame [ 2 ] ) { <S2SV_StartBug> FRAME_CONTEXT * const fc = & cm -> fc ; <S2SV_EndBug> FRAME_COUNTS * const counts = & cm -> counts ; if ( vp9_segfeature_active ( & cm -> seg , segment_id , SEG_LVL_REF_FRAME ) ) { <S2SV_StartBug> ref_frame [ 0 ] = ( MV_REFERENCE_FRAME ) vp9_get_segdata ( & cm -> seg , segment_id , <S2SV_EndBug> SEG_LVL_REF_FRAME ) ; ref_frame [ 1 ] = NONE ; } else { const REFERENCE_MODE mode = read_block_reference_mode ( cm , xd , r ) ; if ( mode == COMPOUND_REFERENCE ) { const int idx = cm -> ref_frame_sign_bias [ cm -> comp_fixed_ref ] ; const int ctx = vp9_get_pred_context_comp_ref_p ( cm , xd ) ; <S2SV_StartBug> const int bit = vp9_read ( r , fc -> comp_ref_prob [ ctx ] ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! cm -> frame_parallel_decoding_mode ) <S2SV_EndBug> ++ counts -> comp_ref [ ctx ] [ bit ] ; ref_frame [ idx ] = cm -> comp_fixed_ref ; ref_frame [ ! idx ] = cm -> comp_var_ref [ bit ] ; } else if ( mode == SINGLE_REFERENCE ) { const int ctx0 = vp9_get_pred_context_single_ref_p1 ( xd ) ; <S2SV_StartBug> const int bit0 = vp9_read ( r , fc -> single_ref_prob [ ctx0 ] [ 0 ] ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! cm -> frame_parallel_decoding_mode ) <S2SV_EndBug> ++ counts -> single_ref [ ctx0 ] [ 0 ] [ bit0 ] ; if ( bit0 ) { const int ctx1 = vp9_get_pred_context_single_ref_p2 ( xd ) ; <S2SV_StartBug> const int bit1 = vp9_read ( r , fc -> single_ref_prob [ ctx1 ] [ 1 ] ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! cm -> frame_parallel_decoding_mode ) <S2SV_EndBug> ++ counts -> single_ref [ ctx1 ] [ 1 ] [ bit1 ] ; ref_frame [ 0 ] = bit1 ? ALTREF_FRAME : GOLDEN_FRAME ; } else { ref_frame [ 0 ] = LAST_FRAME ; } ref_frame [ 1 ] = NONE ; } else { assert ( 0 && ""Invalid<S2SV_blank>prediction<S2SV_blank>mode."" ) ; } } }","const xd , vpx_reader <S2SV_ModEnd> * r , <S2SV_ModStart> const fc = cm -> fc ; FRAME_COUNTS * counts = xd -> counts ; if ( segfeature_active ( <S2SV_ModStart> & cm -> <S2SV_ModEnd> seg , segment_id <S2SV_ModStart> ( MV_REFERENCE_FRAME ) get_segdata <S2SV_ModEnd> ( & cm <S2SV_ModStart> int bit = vpx_read <S2SV_ModEnd> ( r , <S2SV_ModStart> ; if ( counts <S2SV_ModEnd> ) ++ counts <S2SV_ModStart> int bit0 = vpx_read <S2SV_ModEnd> ( r , <S2SV_ModStart> ; if ( counts <S2SV_ModEnd> ) ++ counts <S2SV_ModStart> int bit1 = vpx_read <S2SV_ModEnd> ( r , <S2SV_ModStart> ; if ( counts <S2SV_ModEnd> ) ++ counts"
244,"const char * WinPKIErrorString ( void ) { static char error_string [ 64 ] ; DWORD error_code = GetLastError ( ) ; <S2SV_StartBug> if ( ( error_code >> 16 ) != 0x8009 ) <S2SV_EndBug> return WindowsErrorString ( ) ; switch ( error_code ) { case NTE_BAD_UID : return ""Bad<S2SV_blank>UID."" ; case CRYPT_E_MSG_ERROR : return ""An<S2SV_blank>error<S2SV_blank>occurred<S2SV_blank>while<S2SV_blank>performing<S2SV_blank>an<S2SV_blank>operation<S2SV_blank>on<S2SV_blank>a<S2SV_blank>cryptographic<S2SV_blank>message."" ; case CRYPT_E_UNKNOWN_ALGO : return ""Unknown<S2SV_blank>cryptographic<S2SV_blank>algorithm."" ; case CRYPT_E_INVALID_MSG_TYPE : return ""Invalid<S2SV_blank>cryptographic<S2SV_blank>message<S2SV_blank>type."" ; case CRYPT_E_HASH_VALUE : return ""The<S2SV_blank>hash<S2SV_blank>value<S2SV_blank>is<S2SV_blank>not<S2SV_blank>correct"" ; case CRYPT_E_ISSUER_SERIALNUMBER : return ""Invalid<S2SV_blank>issuer<S2SV_blank>and/or<S2SV_blank>serial<S2SV_blank>number."" ; case CRYPT_E_BAD_LEN : return ""The<S2SV_blank>length<S2SV_blank>specified<S2SV_blank>for<S2SV_blank>the<S2SV_blank>output<S2SV_blank>data<S2SV_blank>was<S2SV_blank>insufficient."" ; case CRYPT_E_BAD_ENCODE : return ""An<S2SV_blank>error<S2SV_blank>occurred<S2SV_blank>during<S2SV_blank>encode<S2SV_blank>or<S2SV_blank>decode<S2SV_blank>operation."" ; case CRYPT_E_FILE_ERROR : return ""An<S2SV_blank>error<S2SV_blank>occurred<S2SV_blank>while<S2SV_blank>reading<S2SV_blank>or<S2SV_blank>writing<S2SV_blank>to<S2SV_blank>a<S2SV_blank>file."" ; case CRYPT_E_NOT_FOUND : return ""Cannot<S2SV_blank>find<S2SV_blank>object<S2SV_blank>or<S2SV_blank>property."" ; case CRYPT_E_EXISTS : return ""The<S2SV_blank>object<S2SV_blank>or<S2SV_blank>property<S2SV_blank>already<S2SV_blank>exists."" ; case CRYPT_E_NO_PROVIDER : return ""No<S2SV_blank>provider<S2SV_blank>was<S2SV_blank>specified<S2SV_blank>for<S2SV_blank>the<S2SV_blank>store<S2SV_blank>or<S2SV_blank>object."" ; case CRYPT_E_DELETED_PREV : return ""The<S2SV_blank>previous<S2SV_blank>certificate<S2SV_blank>or<S2SV_blank>CRL<S2SV_blank>context<S2SV_blank>was<S2SV_blank>deleted."" ; case CRYPT_E_NO_MATCH : return ""Cannot<S2SV_blank>find<S2SV_blank>the<S2SV_blank>requested<S2SV_blank>object."" ; case CRYPT_E_UNEXPECTED_MSG_TYPE : case CRYPT_E_NO_KEY_PROPERTY : case CRYPT_E_NO_DECRYPT_CERT : return ""Private<S2SV_blank>key<S2SV_blank>or<S2SV_blank>certificate<S2SV_blank>issue"" ; case CRYPT_E_BAD_MSG : return ""Not<S2SV_blank>a<S2SV_blank>cryptographic<S2SV_blank>message."" ; case CRYPT_E_NO_SIGNER : return ""The<S2SV_blank>signed<S2SV_blank>cryptographic<S2SV_blank>message<S2SV_blank>does<S2SV_blank>not<S2SV_blank>have<S2SV_blank>a<S2SV_blank>signer<S2SV_blank>for<S2SV_blank>the<S2SV_blank>specified<S2SV_blank>signer<S2SV_blank>index."" ; case CRYPT_E_REVOKED : return ""The<S2SV_blank>certificate<S2SV_blank>is<S2SV_blank>revoked."" ; case CRYPT_E_NO_REVOCATION_DLL : case CRYPT_E_NO_REVOCATION_CHECK : case CRYPT_E_REVOCATION_OFFLINE : case CRYPT_E_NOT_IN_REVOCATION_DATABASE : return ""Cannot<S2SV_blank>check<S2SV_blank>certificate<S2SV_blank>revocation."" ; case CRYPT_E_INVALID_NUMERIC_STRING : case CRYPT_E_INVALID_PRINTABLE_STRING : case CRYPT_E_INVALID_IA5_STRING : case CRYPT_E_INVALID_X500_STRING : case CRYPT_E_NOT_CHAR_STRING : return ""Invalid<S2SV_blank>string."" ; case CRYPT_E_SECURITY_SETTINGS : return ""The<S2SV_blank>cryptographic<S2SV_blank>operation<S2SV_blank>failed<S2SV_blank>due<S2SV_blank>to<S2SV_blank>a<S2SV_blank>local<S2SV_blank>security<S2SV_blank>option<S2SV_blank>setting."" ; case CRYPT_E_NO_VERIFY_USAGE_CHECK : case CRYPT_E_VERIFY_USAGE_OFFLINE : return ""Cannot<S2SV_blank>complete<S2SV_blank>usage<S2SV_blank>check."" ; case CRYPT_E_NO_TRUSTED_SIGNER : <S2SV_StartBug> return ""None<S2SV_blank>of<S2SV_blank>the<S2SV_blank>signers<S2SV_blank>of<S2SV_blank>the<S2SV_blank>cryptographic<S2SV_blank>message<S2SV_blank>or<S2SV_blank>certificate<S2SV_blank>trust<S2SV_blank>list<S2SV_blank>is<S2SV_blank>trusted."" ; <S2SV_EndBug> default : static_sprintf ( error_string , ""Unknown<S2SV_blank>PKI<S2SV_blank>error<S2SV_blank>0x%08lX"" , error_code ) ; return error_string ; } }","if ( ( ( <S2SV_ModStart> != 0x8009 ) && ( ( error_code >> 16 ) != 0x800B ) ) <S2SV_ModStart> : return ""None<S2SV_blank>of<S2SV_blank>the<S2SV_blank>signers<S2SV_blank>of<S2SV_blank>the<S2SV_blank>cryptographic<S2SV_blank>message<S2SV_blank>or<S2SV_blank>certificate<S2SV_blank>trust<S2SV_blank>list<S2SV_blank>is<S2SV_blank>trusted."" ; case CERT_E_UNTRUSTEDROOT : return ""The<S2SV_blank>root<S2SV_blank>certificate<S2SV_blank>is<S2SV_blank>not<S2SV_blank>trusted."" ; case TRUST_E_NOSIGNATURE : return ""Not<S2SV_blank>digitally<S2SV_blank>signed."" ; case TRUST_E_EXPLICIT_DISTRUST : return ""One<S2SV_blank>of<S2SV_blank>the<S2SV_blank>certificates<S2SV_blank>used<S2SV_blank>was<S2SV_blank>marked<S2SV_blank>as<S2SV_blank>untrusted<S2SV_blank>by<S2SV_blank>the<S2SV_blank>user."""
245,"int install_user_keyrings ( void ) { struct user_struct * user ; const struct cred * cred ; struct key * uid_keyring , * session_keyring ; key_perm_t user_keyring_perm ; char buf [ 20 ] ; int ret ; uid_t uid ; user_keyring_perm = ( KEY_POS_ALL & ~ KEY_POS_SETATTR ) | KEY_USR_ALL ; cred = current_cred ( ) ; user = cred -> user ; uid = from_kuid ( cred -> user_ns , user -> uid ) ; kenter ( ""%p{%u}"" , user , uid ) ; if ( user -> uid_keyring && user -> session_keyring ) { kleave ( ""<S2SV_blank>=<S2SV_blank>0<S2SV_blank>[exist]"" ) ; return 0 ; } mutex_lock ( & key_user_keyring_mutex ) ; ret = 0 ; if ( ! user -> uid_keyring ) { sprintf ( buf , ""_uid.%u"" , uid ) ; uid_keyring = find_keyring_by_name ( buf , true ) ; if ( IS_ERR ( uid_keyring ) ) { uid_keyring = keyring_alloc ( buf , user -> uid , INVALID_GID , cred , user_keyring_perm , <S2SV_StartBug> KEY_ALLOC_IN_QUOTA , <S2SV_EndBug> NULL , NULL ) ; if ( IS_ERR ( uid_keyring ) ) { ret = PTR_ERR ( uid_keyring ) ; goto error ; } } sprintf ( buf , ""_uid_ses.%u"" , uid ) ; session_keyring = find_keyring_by_name ( buf , true ) ; if ( IS_ERR ( session_keyring ) ) { session_keyring = keyring_alloc ( buf , user -> uid , INVALID_GID , cred , user_keyring_perm , <S2SV_StartBug> KEY_ALLOC_IN_QUOTA , <S2SV_EndBug> NULL , NULL ) ; if ( IS_ERR ( session_keyring ) ) { ret = PTR_ERR ( session_keyring ) ; goto error_release ; } ret = key_link ( session_keyring , uid_keyring ) ; if ( ret < 0 ) goto error_release_both ; } user -> uid_keyring = uid_keyring ; user -> session_keyring = session_keyring ; } mutex_unlock ( & key_user_keyring_mutex ) ; kleave ( ""<S2SV_blank>=<S2SV_blank>0"" ) ; return 0 ; error_release_both : key_put ( session_keyring ) ; error_release : key_put ( uid_keyring ) ; error : mutex_unlock ( & key_user_keyring_mutex ) ; kleave ( ""<S2SV_blank>=<S2SV_blank>%d"" , ret ) ; return ret ; }",", user_keyring_perm , KEY_ALLOC_UID_KEYRING | <S2SV_ModStart> , user_keyring_perm , KEY_ALLOC_UID_KEYRING |"
246,"SYSCALL_DEFINE2 ( osf_getdomainname , char __user * , name , int , namelen ) { unsigned len ; int i ; if ( ! access_ok ( VERIFY_WRITE , name , namelen ) ) return - EFAULT ; len = namelen ; <S2SV_StartBug> if ( namelen > 32 ) <S2SV_EndBug> len = 32 ; down_read ( & uts_sem ) ; for ( i = 0 ; i < len ; ++ i ) { __put_user ( utsname ( ) -> domainname [ i ] , name + i ) ; if ( utsname ( ) -> domainname [ i ] == '\\0' ) break ; } up_read ( & uts_sem ) ; return 0 ; }",; if ( len <S2SV_ModEnd> > 32 )
247,"static int read_new_config_info ( WavpackContext * wpc , WavpackMetadata * wpmd ) { int bytecnt = wpmd -> byte_length ; unsigned char * byteptr = wpmd -> data ; wpc -> version_five = 1 ; wpc -> file_format = wpc -> config . qmode = wpc -> channel_layout = 0 ; if ( wpc -> channel_reordering ) { free ( wpc -> channel_reordering ) ; wpc -> channel_reordering = NULL ; } <S2SV_StartBug> if ( bytecnt ) { <S2SV_EndBug> wpc -> file_format = * byteptr ++ ; wpc -> config . qmode = ( wpc -> config . qmode & ~ 0xff ) | * byteptr ++ ; bytecnt -= 2 ; if ( bytecnt ) { int nchans , i ; wpc -> channel_layout = ( int32_t ) * byteptr ++ << 16 ; bytecnt -- ; if ( bytecnt ) { wpc -> channel_layout += nchans = * byteptr ++ ; bytecnt -- ; if ( bytecnt ) { if ( bytecnt > nchans ) return FALSE ; wpc -> channel_reordering = malloc ( nchans ) ; if ( wpc -> channel_reordering ) { for ( i = 0 ; i < nchans ; ++ i ) if ( bytecnt ) { wpc -> channel_reordering [ i ] = * byteptr ++ ; <S2SV_StartBug> bytecnt -- ; <S2SV_EndBug> } else wpc -> channel_reordering [ i ] = i ; } } } else wpc -> channel_layout += wpc -> config . num_channels ; } } return TRUE ; }",if ( bytecnt >= 2 <S2SV_ModStart> byteptr ++ ; if ( wpc -> channel_reordering [ i ] >= nchans ) wpc -> channel_reordering [ i ] = 0 ;
248,"int main ( int argc , char * argv [ ] ) { int i , c ; FILE * ifp = 0 , * ofp = 0 ; const char * ifp_filename = ""<stdin>"" ; const char * ofp_filename = ""<stdout>"" ; const char * set_font_name = 0 ; struct font_reader fr ; uint32_t rfork_len ; int raw = 0 , macbinary = 1 , applesingle = 0 , appledouble = 0 , binhex = 0 ; Clp_Parser * clp = Clp_NewParser ( argc , ( const char * const * ) argv , sizeof ( options ) / sizeof ( options [ 0 ] ) , options ) ; program_name = Clp_ProgramName ( clp ) ; while ( 1 ) { int opt = Clp_Next ( clp ) ; switch ( opt ) { case RAW_OPT : raw = 1 ; macbinary = applesingle = appledouble = binhex = 0 ; break ; case MACBINARY_OPT : macbinary = 1 ; raw = applesingle = appledouble = binhex = 0 ; break ; case APPLESINGLE_OPT : applesingle = 1 ; raw = macbinary = appledouble = binhex = 0 ; break ; case APPLEDOUBLE_OPT : appledouble = 1 ; raw = macbinary = applesingle = binhex = 0 ; break ; case BINHEX_OPT : binhex = 1 ; raw = macbinary = applesingle = appledouble = 0 ; break ; output_file : case OUTPUT_OPT : if ( ofp ) fatal_error ( ""output<S2SV_blank>file<S2SV_blank>already<S2SV_blank>specified"" ) ; if ( strcmp ( clp -> vstr , ""-"" ) == 0 ) ofp = stdout ; else { ofp_filename = clp -> vstr ; ofp = fopen ( ofp_filename , ""wb"" ) ; if ( ! ofp ) fatal_error ( ""%s:<S2SV_blank>%s"" , ofp_filename , strerror ( errno ) ) ; } break ; case FILENAME_OPT : if ( set_font_name ) fatal_error ( ""Macintosh<S2SV_blank>font<S2SV_blank>filename<S2SV_blank>already<S2SV_blank>specified"" ) ; set_font_name = clp -> vstr ; break ; case HELP_OPT : usage ( ) ; exit ( 0 ) ; break ; case VERSION_OPT : printf ( ""t1mac<S2SV_blank>(LCDF<S2SV_blank>t1utils)<S2SV_blank>%s\\n"" , VERSION ) ; <S2SV_StartBug> printf ( ""Copyright<S2SV_blank>(C)<S2SV_blank>2000-2010<S2SV_blank>Eddie<S2SV_blank>Kohler<S2SV_blank>et<S2SV_blank>al.\\n\\\n<S2SV_blank>This<S2SV_blank>is<S2SV_blank>free<S2SV_blank>software;<S2SV_blank>see<S2SV_blank>the<S2SV_blank>source<S2SV_blank>for<S2SV_blank>copying<S2SV_blank>conditions.\\n\\\n<S2SV_blank>There<S2SV_blank>is<S2SV_blank>NO<S2SV_blank>warranty,<S2SV_blank>not<S2SV_blank>even<S2SV_blank>for<S2SV_blank>merchantability<S2SV_blank>or<S2SV_blank>fitness<S2SV_blank>for<S2SV_blank>a\\n\\\n<S2SV_blank>particular<S2SV_blank>purpose.\\n"" ) ; <S2SV_EndBug> exit ( 0 ) ; break ; case Clp_NotOption : if ( ifp && ofp ) fatal_error ( ""too<S2SV_blank>many<S2SV_blank>arguments"" ) ; else if ( ifp ) goto output_file ; if ( strcmp ( clp -> vstr , ""-"" ) == 0 ) ifp = stdin ; else { ifp_filename = clp -> vstr ; ifp = fopen ( clp -> vstr , ""r"" ) ; if ( ! ifp ) fatal_error ( ""%s:<S2SV_blank>%s"" , clp -> vstr , strerror ( errno ) ) ; } break ; case Clp_Done : goto done ; case Clp_BadOption : short_usage ( ) ; exit ( 1 ) ; break ; } } done : if ( ! ifp ) ifp = stdin ; if ( ! ofp ) ofp = stdout ; # if defined ( _MSDOS ) || defined ( _WIN32 ) _setmode ( _fileno ( ofp ) , _O_BINARY ) ; # endif fr . output_ascii = t1mac_output_ascii ; fr . output_binary = t1mac_output_binary ; fr . output_end = t1mac_output_end ; rfork_f = tmpfile ( ) ; if ( ! rfork_f ) fatal_error ( ""cannot<S2SV_blank>open<S2SV_blank>temorary<S2SV_blank>file:<S2SV_blank>%s"" , strerror ( errno ) ) ; for ( i = 0 ; i < RFORK_HEADERLEN ; i ++ ) putc ( 0 , rfork_f ) ; init_current_post ( ) ; c = getc ( ifp ) ; ungetc ( c , ifp ) ; if ( c == PFB_MARKER ) process_pfb ( ifp , ifp_filename , & fr ) ; else if ( c == '%' ) process_pfa ( ifp , ifp_filename , & fr ) ; else fatal_error ( ""%s<S2SV_blank>does<S2SV_blank>not<S2SV_blank>start<S2SV_blank>with<S2SV_blank>font<S2SV_blank>marker<S2SV_blank>(`%%\'<S2SV_blank>or<S2SV_blank>0x80)"" , ifp_filename ) ; if ( ifp != stdin ) fclose ( ifp ) ; if ( nrsrc == 0 ) error ( ""no<S2SV_blank>POST<S2SV_blank>resources<S2SV_blank>written<S2SV_blank>--<S2SV_blank>are<S2SV_blank>you<S2SV_blank>sure<S2SV_blank>this<S2SV_blank>was<S2SV_blank>a<S2SV_blank>font?"" ) ; output_new_rsrc ( ""ICN#"" , 256 , 32 , ( const char * ) icon_bw_data , 256 ) ; output_new_rsrc ( ""FREF"" , 256 , 32 , ""LWFN\\0\\0\\0"" , 7 ) ; output_new_rsrc ( ""BNDL"" , 256 , 32 , ""T1UT\\0\\0\\0\\1FREF\\0\\0\\0\\0\\1\\0ICN#\\0\\0\\0\\0\\1\\0"" , 28 ) ; output_new_rsrc ( ""icl8"" , 256 , 32 , ( const char * ) icon_8_data , 1024 ) ; output_new_rsrc ( ""icl4"" , 256 , 32 , ( const char * ) icon_4_data , 512 ) ; output_new_rsrc ( ""ics#"" , 256 , 32 , ( const char * ) small_icon_bw_data , 64 ) ; output_new_rsrc ( ""ics8"" , 256 , 32 , ( const char * ) small_icon_8_data , 256 ) ; output_new_rsrc ( ""ics4"" , 256 , 32 , ( const char * ) small_icon_4_data , 128 ) ; output_new_rsrc ( ""T1UT"" , 0 , 0 , ""DConverted<S2SV_blank>by<S2SV_blank>t1mac<S2SV_blank>(t1utils)<S2SV_blank>\\251Eddie<S2SV_blank>Kohler<S2SV_blank>http://www.lcdf.org/type/"" , 69 ) ; rfork_len = complete_rfork ( ) ; if ( ! set_font_name && font_name ) { int part = 0 , len = 0 ; char * x , * s ; for ( x = s = font_name ; * s ; s ++ ) <S2SV_StartBug> if ( isupper ( * s ) || isdigit ( * s ) ) { <S2SV_EndBug> * x ++ = * s ; part ++ ; len = 1 ; <S2SV_StartBug> } else if ( islower ( * s ) ) { <S2SV_EndBug> if ( len < ( part <= 1 ? 5 : 3 ) ) * x ++ = * s ; len ++ ; } * x ++ = 0 ; set_font_name = font_name ; } else if ( ! set_font_name ) set_font_name = ""Unknown<S2SV_blank>Font"" ; if ( macbinary ) output_macbinary ( rfork_f , rfork_len , set_font_name , ofp ) ; else if ( raw ) output_raw ( rfork_f , rfork_len , ofp ) ; else if ( applesingle || appledouble ) output_applesingle ( rfork_f , rfork_len , set_font_name , ofp , appledouble ) ; else if ( binhex ) output_binhex ( rfork_f , rfork_len , set_font_name , ofp ) ; else fatal_error ( ""strange<S2SV_blank>output<S2SV_blank>format"" ) ; fclose ( rfork_f ) ; if ( ofp != stdout ) fclose ( ofp ) ; return 0 ; }","; printf ( ""Copyright<S2SV_blank>(C)<S2SV_blank>2000-2010<S2SV_blank>Eddie<S2SV_blank>Kohler<S2SV_blank>et<S2SV_blank>al.\\n\\\nThis<S2SV_blank>is<S2SV_blank>free<S2SV_blank>software;<S2SV_blank>see<S2SV_blank>the<S2SV_blank>source<S2SV_blank>for<S2SV_blank>copying<S2SV_blank>conditions.\\n\\\nThere<S2SV_blank>is<S2SV_blank>NO<S2SV_blank>warranty,<S2SV_blank>not<S2SV_blank>even<S2SV_blank>for<S2SV_blank>merchantability<S2SV_blank>or<S2SV_blank>fitness<S2SV_blank>for<S2SV_blank>a\\n\\\nparticular<S2SV_blank>purpose.\\n"" <S2SV_ModEnd> ) ; exit <S2SV_ModStart> ( isupper ( ( unsigned char ) <S2SV_ModStart> || isdigit ( ( unsigned char ) <S2SV_ModStart> ( islower ( ( unsigned char )"
249,"static int loadImage ( TIFF * in , struct image_data * image , struct dump_opts * dump , unsigned char * * read_ptr ) { uint32 i ; float xres = 0.0 , yres = 0.0 ; <S2SV_StartBug> uint16 nstrips = 0 , ntiles = 0 , planar = 0 ; <S2SV_EndBug> uint16 bps = 0 , spp = 0 , res_unit = 0 ; uint16 orientation = 0 ; uint16 input_compression = 0 , input_photometric = 0 ; uint16 subsampling_horiz , subsampling_vert ; uint32 width = 0 , length = 0 ; uint32 stsize = 0 , tlsize = 0 , buffsize = 0 , scanlinesize = 0 ; uint32 tw = 0 , tl = 0 ; uint32 tile_rowsize = 0 ; unsigned char * read_buff = NULL ; unsigned char * new_buff = NULL ; int readunit = 0 ; static uint32 prev_readsize = 0 ; TIFFGetFieldDefaulted ( in , TIFFTAG_BITSPERSAMPLE , & bps ) ; TIFFGetFieldDefaulted ( in , TIFFTAG_SAMPLESPERPIXEL , & spp ) ; TIFFGetFieldDefaulted ( in , TIFFTAG_PLANARCONFIG , & planar ) ; TIFFGetFieldDefaulted ( in , TIFFTAG_ORIENTATION , & orientation ) ; if ( ! TIFFGetFieldDefaulted ( in , TIFFTAG_PHOTOMETRIC , & input_photometric ) ) TIFFError ( ""loadImage"" , ""Image<S2SV_blank>lacks<S2SV_blank>Photometric<S2SV_blank>interpreation<S2SV_blank>tag"" ) ; if ( ! TIFFGetField ( in , TIFFTAG_IMAGEWIDTH , & width ) ) TIFFError ( ""loadimage"" , ""Image<S2SV_blank>lacks<S2SV_blank>image<S2SV_blank>width<S2SV_blank>tag"" ) ; if ( ! TIFFGetField ( in , TIFFTAG_IMAGELENGTH , & length ) ) TIFFError ( ""loadimage"" , ""Image<S2SV_blank>lacks<S2SV_blank>image<S2SV_blank>length<S2SV_blank>tag"" ) ; TIFFGetFieldDefaulted ( in , TIFFTAG_XRESOLUTION , & xres ) ; TIFFGetFieldDefaulted ( in , TIFFTAG_YRESOLUTION , & yres ) ; if ( ! TIFFGetFieldDefaulted ( in , TIFFTAG_RESOLUTIONUNIT , & res_unit ) ) res_unit = RESUNIT_INCH ; if ( ! TIFFGetField ( in , TIFFTAG_COMPRESSION , & input_compression ) ) input_compression = COMPRESSION_NONE ; # ifdef DEBUG2 char compressionid [ 16 ] ; switch ( input_compression ) { case COMPRESSION_NONE : strcpy ( compressionid , ""None/dump"" ) ; break ; case COMPRESSION_CCITTRLE : strcpy ( compressionid , ""Huffman<S2SV_blank>RLE"" ) ; break ; case COMPRESSION_CCITTFAX3 : strcpy ( compressionid , ""Group3<S2SV_blank>Fax"" ) ; break ; case COMPRESSION_CCITTFAX4 : strcpy ( compressionid , ""Group4<S2SV_blank>Fax"" ) ; break ; case COMPRESSION_LZW : strcpy ( compressionid , ""LZW"" ) ; break ; case COMPRESSION_OJPEG : strcpy ( compressionid , ""Old<S2SV_blank>Jpeg"" ) ; break ; case COMPRESSION_JPEG : strcpy ( compressionid , ""New<S2SV_blank>Jpeg"" ) ; break ; case COMPRESSION_NEXT : strcpy ( compressionid , ""Next<S2SV_blank>RLE"" ) ; break ; case COMPRESSION_CCITTRLEW : strcpy ( compressionid , ""CITTRLEW"" ) ; break ; case COMPRESSION_PACKBITS : strcpy ( compressionid , ""Mac<S2SV_blank>Packbits"" ) ; break ; case COMPRESSION_THUNDERSCAN : strcpy ( compressionid , ""Thunderscan"" ) ; break ; case COMPRESSION_IT8CTPAD : strcpy ( compressionid , ""IT8<S2SV_blank>padded"" ) ; break ; case COMPRESSION_IT8LW : strcpy ( compressionid , ""IT8<S2SV_blank>RLE"" ) ; break ; case COMPRESSION_IT8MP : strcpy ( compressionid , ""IT8<S2SV_blank>mono"" ) ; break ; case COMPRESSION_IT8BL : strcpy ( compressionid , ""IT8<S2SV_blank>lineart"" ) ; break ; case COMPRESSION_PIXARFILM : strcpy ( compressionid , ""Pixar<S2SV_blank>10<S2SV_blank>bit"" ) ; break ; case COMPRESSION_PIXARLOG : strcpy ( compressionid , ""Pixar<S2SV_blank>11bit"" ) ; break ; case COMPRESSION_DEFLATE : strcpy ( compressionid , ""Deflate"" ) ; break ; case COMPRESSION_ADOBE_DEFLATE : strcpy ( compressionid , ""Adobe<S2SV_blank>deflate"" ) ; break ; default : strcpy ( compressionid , ""None/unknown"" ) ; break ; } TIFFError ( ""loadImage"" , ""Input<S2SV_blank>compression<S2SV_blank>%s"" , compressionid ) ; # endif scanlinesize = TIFFScanlineSize ( in ) ; image -> bps = bps ; image -> spp = spp ; image -> planar = planar ; image -> width = width ; image -> length = length ; image -> xres = xres ; image -> yres = yres ; image -> res_unit = res_unit ; image -> compression = input_compression ; image -> photometric = input_photometric ; # ifdef DEBUG2 char photometricid [ 12 ] ; switch ( input_photometric ) { case PHOTOMETRIC_MINISWHITE : strcpy ( photometricid , ""MinIsWhite"" ) ; break ; case PHOTOMETRIC_MINISBLACK : strcpy ( photometricid , ""MinIsBlack"" ) ; break ; case PHOTOMETRIC_RGB : strcpy ( photometricid , ""RGB"" ) ; break ; case PHOTOMETRIC_PALETTE : strcpy ( photometricid , ""Palette"" ) ; break ; case PHOTOMETRIC_MASK : strcpy ( photometricid , ""Mask"" ) ; break ; case PHOTOMETRIC_SEPARATED : strcpy ( photometricid , ""Separated"" ) ; break ; case PHOTOMETRIC_YCBCR : strcpy ( photometricid , ""YCBCR"" ) ; break ; case PHOTOMETRIC_CIELAB : strcpy ( photometricid , ""CIELab"" ) ; break ; case PHOTOMETRIC_ICCLAB : strcpy ( photometricid , ""ICCLab"" ) ; break ; case PHOTOMETRIC_ITULAB : strcpy ( photometricid , ""ITULab"" ) ; break ; case PHOTOMETRIC_LOGL : strcpy ( photometricid , ""LogL"" ) ; break ; case PHOTOMETRIC_LOGLUV : strcpy ( photometricid , ""LOGLuv"" ) ; break ; default : strcpy ( photometricid , ""Unknown"" ) ; break ; } TIFFError ( ""loadImage"" , ""Input<S2SV_blank>photometric<S2SV_blank>interpretation<S2SV_blank>%s"" , photometricid ) ; # endif image -> orientation = orientation ; switch ( orientation ) { case 0 : case ORIENTATION_TOPLEFT : image -> adjustments = 0 ; break ; case ORIENTATION_TOPRIGHT : image -> adjustments = MIRROR_HORIZ ; break ; case ORIENTATION_BOTRIGHT : image -> adjustments = ROTATECW_180 ; break ; case ORIENTATION_BOTLEFT : image -> adjustments = MIRROR_VERT ; break ; case ORIENTATION_LEFTTOP : image -> adjustments = MIRROR_VERT | ROTATECW_90 ; break ; case ORIENTATION_RIGHTTOP : image -> adjustments = ROTATECW_90 ; break ; case ORIENTATION_RIGHTBOT : image -> adjustments = MIRROR_VERT | ROTATECW_270 ; break ; case ORIENTATION_LEFTBOT : image -> adjustments = ROTATECW_270 ; break ; default : image -> adjustments = 0 ; image -> orientation = ORIENTATION_TOPLEFT ; } if ( ( bps == 0 ) || ( spp == 0 ) ) { TIFFError ( ""loadImage"" , ""Invalid<S2SV_blank>samples<S2SV_blank>per<S2SV_blank>pixel<S2SV_blank>(%d)<S2SV_blank>or<S2SV_blank>bits<S2SV_blank>per<S2SV_blank>sample<S2SV_blank>(%d)"" , spp , bps ) ; return ( - 1 ) ; } if ( TIFFIsTiled ( in ) ) { readunit = TILE ; tlsize = TIFFTileSize ( in ) ; ntiles = TIFFNumberOfTiles ( in ) ; TIFFGetField ( in , TIFFTAG_TILEWIDTH , & tw ) ; TIFFGetField ( in , TIFFTAG_TILELENGTH , & tl ) ; tile_rowsize = TIFFTileRowSize ( in ) ; if ( ntiles == 0 || tlsize == 0 || tile_rowsize == 0 ) { TIFFError ( ""loadImage"" , ""File<S2SV_blank>appears<S2SV_blank>to<S2SV_blank>be<S2SV_blank>tiled,<S2SV_blank>but<S2SV_blank>the<S2SV_blank>number<S2SV_blank>of<S2SV_blank>tiles,<S2SV_blank>tile<S2SV_blank>size,<S2SV_blank>or<S2SV_blank>tile<S2SV_blank>rowsize<S2SV_blank>is<S2SV_blank>zero."" ) ; exit ( - 1 ) ; } buffsize = tlsize * ntiles ; if ( tlsize != ( buffsize / ntiles ) ) { TIFFError ( ""loadImage"" , ""Integer<S2SV_blank>overflow<S2SV_blank>when<S2SV_blank>calculating<S2SV_blank>buffer<S2SV_blank>size"" ) ; exit ( - 1 ) ; } if ( buffsize < ( uint32 ) ( ntiles * tl * tile_rowsize ) ) { buffsize = ntiles * tl * tile_rowsize ; if ( ntiles != ( buffsize / tl / tile_rowsize ) ) { TIFFError ( ""loadImage"" , ""Integer<S2SV_blank>overflow<S2SV_blank>when<S2SV_blank>calculating<S2SV_blank>buffer<S2SV_blank>size"" ) ; exit ( - 1 ) ; } # ifdef DEBUG2 TIFFError ( ""loadImage"" , ""Tilesize<S2SV_blank>%u<S2SV_blank>is<S2SV_blank>too<S2SV_blank>small,<S2SV_blank>using<S2SV_blank>ntiles<S2SV_blank>*<S2SV_blank>tilelength<S2SV_blank>*<S2SV_blank>tilerowsize<S2SV_blank>%lu"" , tlsize , ( unsigned long ) buffsize ) ; # endif } if ( dump -> infile != NULL ) dump_info ( dump -> infile , dump -> format , """" , ""Tilesize:<S2SV_blank>%u,<S2SV_blank>Number<S2SV_blank>of<S2SV_blank>Tiles:<S2SV_blank>%u,<S2SV_blank>Tile<S2SV_blank>row<S2SV_blank>size:<S2SV_blank>%u"" , tlsize , ntiles , tile_rowsize ) ; } else { uint32 buffsize_check ; readunit = STRIP ; TIFFGetFieldDefaulted ( in , TIFFTAG_ROWSPERSTRIP , & rowsperstrip ) ; stsize = TIFFStripSize ( in ) ; nstrips = TIFFNumberOfStrips ( in ) ; if ( nstrips == 0 || stsize == 0 ) { TIFFError ( ""loadImage"" , ""File<S2SV_blank>appears<S2SV_blank>to<S2SV_blank>be<S2SV_blank>striped,<S2SV_blank>but<S2SV_blank>the<S2SV_blank>number<S2SV_blank>of<S2SV_blank>stipes<S2SV_blank>or<S2SV_blank>stripe<S2SV_blank>size<S2SV_blank>is<S2SV_blank>zero."" ) ; exit ( - 1 ) ; } buffsize = stsize * nstrips ; if ( stsize != ( buffsize / nstrips ) ) { TIFFError ( ""loadImage"" , ""Integer<S2SV_blank>overflow<S2SV_blank>when<S2SV_blank>calculating<S2SV_blank>buffer<S2SV_blank>size"" ) ; exit ( - 1 ) ; } buffsize_check = ( ( length * width * spp * bps ) + 7 ) ; if ( length != ( ( buffsize_check - 7 ) / width / spp / bps ) ) { TIFFError ( ""loadImage"" , ""Integer<S2SV_blank>overflow<S2SV_blank>detected."" ) ; exit ( - 1 ) ; } if ( buffsize < ( uint32 ) ( ( ( length * width * spp * bps ) + 7 ) / 8 ) ) { buffsize = ( ( length * width * spp * bps ) + 7 ) / 8 ; # ifdef DEBUG2 TIFFError ( ""loadImage"" , ""Stripsize<S2SV_blank>%u<S2SV_blank>is<S2SV_blank>too<S2SV_blank>small,<S2SV_blank>using<S2SV_blank>imagelength<S2SV_blank>*<S2SV_blank>width<S2SV_blank>*<S2SV_blank>spp<S2SV_blank>*<S2SV_blank>bps<S2SV_blank>/<S2SV_blank>8<S2SV_blank>=<S2SV_blank>%lu"" , stsize , ( unsigned long ) buffsize ) ; # endif } if ( dump -> infile != NULL ) dump_info ( dump -> infile , dump -> format , """" , ""Stripsize:<S2SV_blank>%u,<S2SV_blank>Number<S2SV_blank>of<S2SV_blank>Strips:<S2SV_blank>%u,<S2SV_blank>Rows<S2SV_blank>per<S2SV_blank>Strip:<S2SV_blank>%u,<S2SV_blank>Scanline<S2SV_blank>size:<S2SV_blank>%u"" , stsize , nstrips , rowsperstrip , scanlinesize ) ; } if ( input_compression == COMPRESSION_JPEG ) { jpegcolormode = JPEGCOLORMODE_RGB ; TIFFSetField ( in , TIFFTAG_JPEGCOLORMODE , JPEGCOLORMODE_RGB ) ; } else { if ( input_photometric == PHOTOMETRIC_YCBCR ) { TIFFGetFieldDefaulted ( in , TIFFTAG_YCBCRSUBSAMPLING , & subsampling_horiz , & subsampling_vert ) ; if ( subsampling_horiz != 1 || subsampling_vert != 1 ) { TIFFError ( ""loadImage"" , ""Can\'t<S2SV_blank>copy/convert<S2SV_blank>subsampled<S2SV_blank>image<S2SV_blank>with<S2SV_blank>subsampling<S2SV_blank>%d<S2SV_blank>horiz<S2SV_blank>%d<S2SV_blank>vert"" , subsampling_horiz , subsampling_vert ) ; return ( - 1 ) ; } } } read_buff = * read_ptr ; if ( ! read_buff ) <S2SV_StartBug> read_buff = ( unsigned char * ) _TIFFmalloc ( buffsize + 3 ) ; <S2SV_EndBug> <S2SV_StartBug> else <S2SV_EndBug> { if ( prev_readsize < buffsize ) <S2SV_StartBug> { <S2SV_EndBug> new_buff = _TIFFrealloc ( read_buff , buffsize + 3 ) ; if ( ! new_buff ) { free ( read_buff ) ; read_buff = ( unsigned char * ) _TIFFmalloc ( buffsize + 3 ) ; } else read_buff = new_buff ; } } if ( ! read_buff ) { TIFFError ( ""loadImage"" , ""Unable<S2SV_blank>to<S2SV_blank>allocate/reallocate<S2SV_blank>read<S2SV_blank>buffer"" ) ; return ( - 1 ) ; } read_buff [ buffsize ] = 0 ; read_buff [ buffsize + 1 ] = 0 ; read_buff [ buffsize + 2 ] = 0 ; prev_readsize = buffsize ; * read_ptr = read_buff ; switch ( readunit ) { case STRIP : if ( planar == PLANARCONFIG_CONTIG ) { if ( ! ( readContigStripsIntoBuffer ( in , read_buff ) ) ) { TIFFError ( ""loadImage"" , ""Unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>contiguous<S2SV_blank>strips<S2SV_blank>into<S2SV_blank>buffer"" ) ; return ( - 1 ) ; } } else { if ( ! ( readSeparateStripsIntoBuffer ( in , read_buff , length , width , spp , dump ) ) ) { TIFFError ( ""loadImage"" , ""Unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>separate<S2SV_blank>strips<S2SV_blank>into<S2SV_blank>buffer"" ) ; return ( - 1 ) ; } } break ; case TILE : if ( planar == PLANARCONFIG_CONTIG ) { if ( ! ( readContigTilesIntoBuffer ( in , read_buff , length , width , tw , tl , spp , bps ) ) ) { TIFFError ( ""loadImage"" , ""Unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>contiguous<S2SV_blank>tiles<S2SV_blank>into<S2SV_blank>buffer"" ) ; return ( - 1 ) ; } } else { if ( ! ( readSeparateTilesIntoBuffer ( in , read_buff , length , width , tw , tl , spp , bps ) ) ) { TIFFError ( ""loadImage"" , ""Unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>separate<S2SV_blank>tiles<S2SV_blank>into<S2SV_blank>buffer"" ) ; return ( - 1 ) ; } } break ; default : TIFFError ( ""loadImage"" , ""Unsupported<S2SV_blank>image<S2SV_blank>file<S2SV_blank>format"" ) ; return ( - 1 ) ; break ; } if ( ( dump -> infile != NULL ) && ( dump -> level == 2 ) ) { dump_info ( dump -> infile , dump -> format , ""loadImage"" , ""Image<S2SV_blank>width<S2SV_blank>%d,<S2SV_blank>length<S2SV_blank>%d,<S2SV_blank>Raw<S2SV_blank>image<S2SV_blank>data,<S2SV_blank>%4d<S2SV_blank>bytes"" , width , length , buffsize ) ; dump_info ( dump -> infile , dump -> format , """" , ""Bits<S2SV_blank>per<S2SV_blank>sample<S2SV_blank>%d,<S2SV_blank>Samples<S2SV_blank>per<S2SV_blank>pixel<S2SV_blank>%d"" , bps , spp ) ; for ( i = 0 ; i < length ; i ++ ) dump_buffer ( dump -> infile , dump -> format , 1 , scanlinesize , i , read_buff + ( i * scanlinesize ) ) ; } return ( 0 ) ; }","= 0.0 ; uint32 nstrips = 0 , ntiles = 0 ; uint16 <S2SV_ModEnd> planar = 0 <S2SV_ModStart> ! read_buff ) { if ( buffsize > 0xFFFFFFFFU - 3 ) { TIFFError ( ""loadImage"" , ""Unable<S2SV_blank>to<S2SV_blank>allocate/reallocate<S2SV_blank>read<S2SV_blank>buffer"" ) ; return ( - 1 ) ; } <S2SV_ModStart> 3 ) ; } <S2SV_ModStart> buffsize ) { if ( buffsize > 0xFFFFFFFFU - 3 ) { TIFFError ( ""loadImage"" , ""Unable<S2SV_blank>to<S2SV_blank>allocate/reallocate<S2SV_blank>read<S2SV_blank>buffer"" ) ; return ( - 1 ) ; }"
250,"static int __fpu__restore_sig ( void __user * buf , void __user * buf_fx , int size ) { int ia32_fxstate = ( buf != buf_fx ) ; struct task_struct * tsk = current ; struct fpu * fpu = & tsk -> thread . fpu ; int state_size = fpu_kernel_xstate_size ; u64 xfeatures = 0 ; int fx_only = 0 ; ia32_fxstate &= ( IS_ENABLED ( CONFIG_X86_32 ) || IS_ENABLED ( CONFIG_IA32_EMULATION ) ) ; if ( ! buf ) { fpu__clear ( fpu ) ; return 0 ; } if ( ! access_ok ( VERIFY_READ , buf , size ) ) return - EACCES ; fpu__activate_curr ( fpu ) ; if ( ! static_cpu_has ( X86_FEATURE_FPU ) ) return fpregs_soft_set ( current , NULL , 0 , sizeof ( struct user_i387_ia32_struct ) , NULL , buf ) != 0 ; if ( use_xsave ( ) ) { struct _fpx_sw_bytes fx_sw_user ; if ( unlikely ( check_for_xstate ( buf_fx , buf_fx , & fx_sw_user ) ) ) { state_size = sizeof ( struct fxregs_state ) ; fx_only = 1 ; trace_x86_fpu_xstate_check_failed ( fpu ) ; } else { state_size = fx_sw_user . xstate_size ; xfeatures = fx_sw_user . xfeatures ; } } if ( ia32_fxstate ) { struct fpu * fpu = & tsk -> thread . fpu ; struct user_i387_ia32_struct env ; int err = 0 ; fpu__drop ( fpu ) ; <S2SV_StartBug> if ( using_compacted_format ( ) ) <S2SV_EndBug> err = copy_user_to_xstate ( & fpu -> state . xsave , buf_fx ) ; <S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> err = __copy_from_user ( & fpu -> state . xsave , buf_fx , state_size ) ; <S2SV_EndBug> if ( err || __copy_from_user ( & env , buf , sizeof ( env ) ) ) { fpstate_init ( & fpu -> state ) ; trace_x86_fpu_init_state ( fpu ) ; err = - 1 ; } else { sanitize_restored_xstate ( tsk , & env , xfeatures , fx_only ) ; } fpu -> fpstate_active = 1 ; preempt_disable ( ) ; fpu__restore ( fpu ) ; preempt_enable ( ) ; return err ; } else { user_fpu_begin ( ) ; if ( copy_user_to_fpregs_zeroing ( buf_fx , xfeatures , fx_only ) ) { fpu__clear ( fpu ) ; return - 1 ; } } return 0 ; }","( ) ) { <S2SV_ModStart> buf_fx ) ; } else { <S2SV_ModEnd> err = __copy_from_user <S2SV_ModStart> state_size ) ; if ( ! err && state_size > offsetof ( struct xregs_state , header ) && fpu -> state . xsave . header . xcomp_bv ) err = - EINVAL ; }"
251,"static void scsi_free_request ( SCSIRequest * req ) { SCSIDiskReq * r = DO_UPCAST ( SCSIDiskReq , req , req ) ; <S2SV_StartBug> qemu_vfree ( r -> iov . iov_base ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>",req ) ; if ( r -> iov . iov_base ) { <S2SV_ModStart> ) ; } }
252,"error_t ksz8851UpdateMacAddrFilter ( NetInterface * interface ) { uint_t i ; uint_t k ; uint32_t crc ; uint16_t hashTable [ 4 ] ; MacFilterEntry * entry ; TRACE_DEBUG ( ""Updating<S2SV_blank>MAC<S2SV_blank>filter...\\r\\n"" ) ; osMemset ( hashTable , 0 , sizeof ( hashTable ) ) ; for ( i = 0 ; i < MAC_ADDR_FILTER_SIZE ; i ++ ) { entry = & interface -> macAddrFilter [ i ] ; if ( entry -> refCount > 0 ) { crc = ksz8851CalcCrc ( & entry -> addr , sizeof ( MacAddr ) ) ; k = ( crc >> 26 ) & 0x3F ; hashTable [ k / 16 ] |= ( 1 << ( k % 16 ) ) ; } } <S2SV_StartBug> ksz8851WriteReg ( interface , KSZ8851_REG_MAHTR0 , hashTable [ 0 ] ) ; <S2SV_EndBug> ksz8851WriteReg ( interface , KSZ8851_REG_MAHTR1 , hashTable [ 1 ] ) ; <S2SV_StartBug> ksz8851WriteReg ( interface , KSZ8851_REG_MAHTR2 , hashTable [ 2 ] ) ; <S2SV_EndBug> <S2SV_StartBug> ksz8851WriteReg ( interface , KSZ8851_REG_MAHTR3 , hashTable [ 3 ] ) ; <S2SV_EndBug> <S2SV_StartBug> TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>MAHTR0<S2SV_blank>=<S2SV_blank>%04"" PRIX16 ""\\r\\n"" , ksz8851ReadReg ( interface , KSZ8851_REG_MAHTR0 ) ) ; <S2SV_EndBug> <S2SV_StartBug> TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>MAHTR1<S2SV_blank>=<S2SV_blank>%04"" PRIX16 ""\\r\\n"" , ksz8851ReadReg ( interface , KSZ8851_REG_MAHTR1 ) ) ; <S2SV_EndBug> <S2SV_StartBug> TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>MAHTR2<S2SV_blank>=<S2SV_blank>%04"" PRIX16 ""\\r\\n"" , ksz8851ReadReg ( interface , KSZ8851_REG_MAHTR2 ) ) ; <S2SV_EndBug> <S2SV_StartBug> TRACE_DEBUG ( ""<S2SV_blank><S2SV_blank>MAHTR3<S2SV_blank>=<S2SV_blank>%04"" PRIX16 ""\\r\\n"" , ksz8851ReadReg ( interface , KSZ8851_REG_MAHTR3 ) ) ; <S2SV_EndBug> return NO_ERROR ; }","( interface , KSZ8851_MAHTR0 , hashTable [ 0 ] ) ; ksz8851WriteReg ( interface , KSZ8851_MAHTR1 <S2SV_ModEnd> , hashTable [ <S2SV_ModStart> ( interface , KSZ8851_MAHTR2 <S2SV_ModEnd> , hashTable [ <S2SV_ModStart> ( interface , KSZ8851_MAHTR3 <S2SV_ModEnd> , hashTable [ <S2SV_ModStart> ( interface , KSZ8851_MAHTR0 <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( interface , KSZ8851_MAHTR1 <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( interface , KSZ8851_MAHTR2 <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ( interface , KSZ8851_MAHTR3 <S2SV_ModEnd> ) ) ;"
253,"generic_ret * modify_policy_2_svc ( mpol_arg * arg , struct svc_req * rqstp ) { static generic_ret ret ; char * prime_arg ; <S2SV_StartBug> gss_buffer_desc client_name , <S2SV_EndBug> service_name ; OM_uint32 minor_stat ; kadm5_server_handle_t handle ; const char * errmsg = NULL ; xdr_free ( xdr_generic_ret , & ret ) ; if ( ( ret . code = new_server_handle ( arg -> api_version , rqstp , & handle ) ) ) goto exit_func ; if ( ( ret . code = check_handle ( ( void * ) handle ) ) ) goto exit_func ; ret . api_version = handle -> api_version ; if ( setup_gss_names ( rqstp , & client_name , & service_name ) < 0 ) { ret . code = KADM5_FAILURE ; goto exit_func ; } prime_arg = arg -> rec . policy ; if ( CHANGEPW_SERVICE ( rqstp ) || ! kadm5int_acl_check ( handle -> context , rqst2name ( rqstp ) , ACL_MODIFY , NULL , NULL ) ) { log_unauth ( ""kadm5_modify_policy"" , prime_arg , & client_name , & service_name , rqstp ) ; ret . code = KADM5_AUTH_MODIFY ; } else { ret . code = kadm5_modify_policy ( ( void * ) handle , & arg -> rec , arg -> mask ) ; if ( ret . code != 0 ) errmsg = krb5_get_error_message ( handle -> context , ret . code ) ; log_done ( ""kadm5_modify_policy"" , ( ( prime_arg == NULL ) ? ""(null)"" : prime_arg ) , errmsg , & client_name , & service_name , rqstp ) ; if ( errmsg != NULL ) krb5_free_error_message ( handle -> context , errmsg ) ; } <S2SV_StartBug> gss_release_buffer ( & minor_stat , & client_name ) ; <S2SV_EndBug> gss_release_buffer ( & minor_stat , & service_name ) ; exit_func : free_server_handle ( handle ) ; return & ret ; }","; gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <S2SV_ModEnd> ; OM_uint32 minor_stat <S2SV_ModStart> ) ; } exit_func : gss_release_buffer ( & minor_stat , & client_name ) ; gss_release_buffer ( & minor_stat , & service_name ) ; <S2SV_ModEnd> free_server_handle ( handle"
254,"static int start_decoder ( vorb * f ) { uint8 header [ 6 ] , x , y ; int len , i , j , k , max_submaps = 0 ; int longest_floorlist = 0 ; if ( ! start_page ( f ) ) return FALSE ; if ( ! ( f -> page_flag & PAGEFLAG_first_page ) ) return error ( f , VORBIS_invalid_first_page ) ; if ( f -> page_flag & PAGEFLAG_last_page ) return error ( f , VORBIS_invalid_first_page ) ; if ( f -> page_flag & PAGEFLAG_continued_packet ) return error ( f , VORBIS_invalid_first_page ) ; if ( f -> segment_count != 1 ) return error ( f , VORBIS_invalid_first_page ) ; if ( f -> segments [ 0 ] != 30 ) { if ( f -> segments [ 0 ] == 64 && getn ( f , header , 6 ) && header [ 0 ] == 'f' && header [ 1 ] == 'i' && header [ 2 ] == 's' && header [ 3 ] == 'h' && header [ 4 ] == 'e' && header [ 5 ] == 'a' && get8 ( f ) == 'd' && get8 ( f ) == '\\0' ) return error ( f , VORBIS_ogg_skeleton_not_supported ) ; else return error ( f , VORBIS_invalid_first_page ) ; } if ( get8 ( f ) != VORBIS_packet_id ) return error ( f , VORBIS_invalid_first_page ) ; if ( ! getn ( f , header , 6 ) ) return error ( f , VORBIS_unexpected_eof ) ; if ( ! vorbis_validate ( header ) ) return error ( f , VORBIS_invalid_first_page ) ; if ( get32 ( f ) != 0 ) return error ( f , VORBIS_invalid_first_page ) ; f -> channels = get8 ( f ) ; if ( ! f -> channels ) return error ( f , VORBIS_invalid_first_page ) ; if ( f -> channels > STB_VORBIS_MAX_CHANNELS ) return error ( f , VORBIS_too_many_channels ) ; f -> sample_rate = get32 ( f ) ; if ( ! f -> sample_rate ) return error ( f , VORBIS_invalid_first_page ) ; get32 ( f ) ; get32 ( f ) ; get32 ( f ) ; x = get8 ( f ) ; { int log0 , log1 ; log0 = x & 15 ; log1 = x >> 4 ; f -> blocksize_0 = 1 << log0 ; f -> blocksize_1 = 1 << log1 ; if ( log0 < 6 || log0 > 13 ) return error ( f , VORBIS_invalid_setup ) ; if ( log1 < 6 || log1 > 13 ) return error ( f , VORBIS_invalid_setup ) ; if ( log0 > log1 ) return error ( f , VORBIS_invalid_setup ) ; } x = get8 ( f ) ; if ( ! ( x & 1 ) ) return error ( f , VORBIS_invalid_first_page ) ; if ( ! start_page ( f ) ) return FALSE ; if ( ! start_packet ( f ) ) return FALSE ; do { len = next_segment ( f ) ; skip ( f , len ) ; f -> bytes_in_seg = 0 ; } while ( len ) ; if ( ! start_packet ( f ) ) return FALSE ; # ifndef STB_VORBIS_NO_PUSHDATA_API if ( IS_PUSH_MODE ( f ) ) { if ( ! is_whole_packet_present ( f , TRUE ) ) { if ( f -> error == VORBIS_invalid_stream ) f -> error = VORBIS_invalid_setup ; return FALSE ; } } # endif crc32_init ( ) ; if ( get8_packet ( f ) != VORBIS_packet_setup ) return error ( f , VORBIS_invalid_setup ) ; for ( i = 0 ; i < 6 ; ++ i ) header [ i ] = get8_packet ( f ) ; if ( ! vorbis_validate ( header ) ) return error ( f , VORBIS_invalid_setup ) ; f -> codebook_count = get_bits ( f , 8 ) + 1 ; f -> codebooks = ( Codebook * ) setup_malloc ( f , sizeof ( * f -> codebooks ) * f -> codebook_count ) ; if ( f -> codebooks == NULL ) return error ( f , VORBIS_outofmem ) ; memset ( f -> codebooks , 0 , sizeof ( * f -> codebooks ) * f -> codebook_count ) ; for ( i = 0 ; i < f -> codebook_count ; ++ i ) { uint32 * values ; int ordered , sorted_count ; int total = 0 ; uint8 * lengths ; Codebook * c = f -> codebooks + i ; CHECK ( f ) ; x = get_bits ( f , 8 ) ; if ( x != 0x42 ) return error ( f , VORBIS_invalid_setup ) ; x = get_bits ( f , 8 ) ; if ( x != 0x43 ) return error ( f , VORBIS_invalid_setup ) ; x = get_bits ( f , 8 ) ; if ( x != 0x56 ) return error ( f , VORBIS_invalid_setup ) ; x = get_bits ( f , 8 ) ; c -> dimensions = ( get_bits ( f , 8 ) << 8 ) + x ; x = get_bits ( f , 8 ) ; y = get_bits ( f , 8 ) ; c -> entries = ( get_bits ( f , 8 ) << 16 ) + ( y << 8 ) + x ; ordered = get_bits ( f , 1 ) ; c -> sparse = ordered ? 0 : get_bits ( f , 1 ) ; if ( c -> dimensions == 0 && c -> entries != 0 ) return error ( f , VORBIS_invalid_setup ) ; if ( c -> sparse ) lengths = ( uint8 * ) setup_temp_malloc ( f , c -> entries ) ; else lengths = c -> codeword_lengths = ( uint8 * ) setup_malloc ( f , c -> entries ) ; if ( ! lengths ) return error ( f , VORBIS_outofmem ) ; if ( ordered ) { int current_entry = 0 ; int current_length = get_bits ( f , 5 ) + 1 ; while ( current_entry < c -> entries ) { int limit = c -> entries - current_entry ; int n = get_bits ( f , ilog ( limit ) ) ; <S2SV_StartBug> if ( current_entry + n > ( int ) c -> entries ) { return error ( f , VORBIS_invalid_setup ) ; } <S2SV_EndBug> memset ( lengths + current_entry , current_length , n ) ; current_entry += n ; ++ current_length ; } } else { for ( j = 0 ; j < c -> entries ; ++ j ) { int present = c -> sparse ? get_bits ( f , 1 ) : 1 ; if ( present ) { lengths [ j ] = get_bits ( f , 5 ) + 1 ; ++ total ; if ( lengths [ j ] == 32 ) return error ( f , VORBIS_invalid_setup ) ; } else { lengths [ j ] = NO_CODE ; } } } if ( c -> sparse && total >= c -> entries >> 2 ) { if ( c -> entries > ( int ) f -> setup_temp_memory_required ) f -> setup_temp_memory_required = c -> entries ; c -> codeword_lengths = ( uint8 * ) setup_malloc ( f , c -> entries ) ; if ( c -> codeword_lengths == NULL ) return error ( f , VORBIS_outofmem ) ; memcpy ( c -> codeword_lengths , lengths , c -> entries ) ; setup_temp_free ( f , lengths , c -> entries ) ; lengths = c -> codeword_lengths ; c -> sparse = 0 ; } if ( c -> sparse ) { sorted_count = total ; } else { sorted_count = 0 ; # ifndef STB_VORBIS_NO_HUFFMAN_BINARY_SEARCH for ( j = 0 ; j < c -> entries ; ++ j ) if ( lengths [ j ] > STB_VORBIS_FAST_HUFFMAN_LENGTH && lengths [ j ] != NO_CODE ) ++ sorted_count ; # endif } c -> sorted_entries = sorted_count ; values = NULL ; CHECK ( f ) ; if ( ! c -> sparse ) { c -> codewords = ( uint32 * ) setup_malloc ( f , sizeof ( c -> codewords [ 0 ] ) * c -> entries ) ; if ( ! c -> codewords ) return error ( f , VORBIS_outofmem ) ; } else { unsigned int size ; if ( c -> sorted_entries ) { c -> codeword_lengths = ( uint8 * ) setup_malloc ( f , c -> sorted_entries ) ; if ( ! c -> codeword_lengths ) return error ( f , VORBIS_outofmem ) ; c -> codewords = ( uint32 * ) setup_temp_malloc ( f , sizeof ( * c -> codewords ) * c -> sorted_entries ) ; if ( ! c -> codewords ) return error ( f , VORBIS_outofmem ) ; values = ( uint32 * ) setup_temp_malloc ( f , sizeof ( * values ) * c -> sorted_entries ) ; if ( ! values ) return error ( f , VORBIS_outofmem ) ; } size = c -> entries + ( sizeof ( * c -> codewords ) + sizeof ( * values ) ) * c -> sorted_entries ; if ( size > f -> setup_temp_memory_required ) f -> setup_temp_memory_required = size ; } if ( ! compute_codewords ( c , lengths , c -> entries , values ) ) { if ( c -> sparse ) setup_temp_free ( f , values , 0 ) ; return error ( f , VORBIS_invalid_setup ) ; } if ( c -> sorted_entries ) { c -> sorted_codewords = ( uint32 * ) setup_malloc ( f , sizeof ( * c -> sorted_codewords ) * ( c -> sorted_entries + 1 ) ) ; if ( c -> sorted_codewords == NULL ) return error ( f , VORBIS_outofmem ) ; c -> sorted_values = ( int * ) setup_malloc ( f , sizeof ( * c -> sorted_values ) * ( c -> sorted_entries + 1 ) ) ; if ( c -> sorted_values == NULL ) return error ( f , VORBIS_outofmem ) ; ++ c -> sorted_values ; c -> sorted_values [ - 1 ] = - 1 ; compute_sorted_huffman ( c , lengths , values ) ; } if ( c -> sparse ) { setup_temp_free ( f , values , sizeof ( * values ) * c -> sorted_entries ) ; setup_temp_free ( f , c -> codewords , sizeof ( * c -> codewords ) * c -> sorted_entries ) ; setup_temp_free ( f , lengths , c -> entries ) ; c -> codewords = NULL ; } compute_accelerated_huffman ( c ) ; CHECK ( f ) ; c -> lookup_type = get_bits ( f , 4 ) ; if ( c -> lookup_type > 2 ) return error ( f , VORBIS_invalid_setup ) ; if ( c -> lookup_type > 0 ) { uint16 * mults ; c -> minimum_value = float32_unpack ( get_bits ( f , 32 ) ) ; c -> delta_value = float32_unpack ( get_bits ( f , 32 ) ) ; c -> value_bits = get_bits ( f , 4 ) + 1 ; c -> sequence_p = get_bits ( f , 1 ) ; if ( c -> lookup_type == 1 ) { <S2SV_StartBug> c -> lookup_values = lookup1_values ( c -> entries , c -> dimensions ) ; <S2SV_EndBug> } else { c -> lookup_values = c -> entries * c -> dimensions ; } if ( c -> lookup_values == 0 ) return error ( f , VORBIS_invalid_setup ) ; mults = ( uint16 * ) setup_temp_malloc ( f , sizeof ( mults [ 0 ] ) * c -> lookup_values ) ; if ( mults == NULL ) return error ( f , VORBIS_outofmem ) ; for ( j = 0 ; j < ( int ) c -> lookup_values ; ++ j ) { int q = get_bits ( f , c -> value_bits ) ; if ( q == EOP ) { setup_temp_free ( f , mults , sizeof ( mults [ 0 ] ) * c -> lookup_values ) ; return error ( f , VORBIS_invalid_setup ) ; } mults [ j ] = q ; } # ifndef STB_VORBIS_DIVIDES_IN_CODEBOOK if ( c -> lookup_type == 1 ) { int len , sparse = c -> sparse ; float last = 0 ; if ( sparse ) { if ( c -> sorted_entries == 0 ) goto skip ; c -> multiplicands = ( codetype * ) setup_malloc ( f , sizeof ( c -> multiplicands [ 0 ] ) * c -> sorted_entries * c -> dimensions ) ; } else c -> multiplicands = ( codetype * ) setup_malloc ( f , sizeof ( c -> multiplicands [ 0 ] ) * c -> entries * c -> dimensions ) ; if ( c -> multiplicands == NULL ) { setup_temp_free ( f , mults , sizeof ( mults [ 0 ] ) * c -> lookup_values ) ; return error ( f , VORBIS_outofmem ) ; } len = sparse ? c -> sorted_entries : c -> entries ; for ( j = 0 ; j < len ; ++ j ) { unsigned int z = sparse ? c -> sorted_values [ j ] : j ; unsigned int div = 1 ; for ( k = 0 ; k < c -> dimensions ; ++ k ) { int off = ( z / div ) % c -> lookup_values ; float val = mults [ off ] ; val = mults [ off ] * c -> delta_value + c -> minimum_value + last ; c -> multiplicands [ j * c -> dimensions + k ] = val ; if ( c -> sequence_p ) last = val ; if ( k + 1 < c -> dimensions ) { if ( div > UINT_MAX / ( unsigned int ) c -> lookup_values ) { setup_temp_free ( f , mults , sizeof ( mults [ 0 ] ) * c -> lookup_values ) ; return error ( f , VORBIS_invalid_setup ) ; } div *= c -> lookup_values ; } } } c -> lookup_type = 2 ; } else # endif { float last = 0 ; CHECK ( f ) ; c -> multiplicands = ( codetype * ) setup_malloc ( f , sizeof ( c -> multiplicands [ 0 ] ) * c -> lookup_values ) ; if ( c -> multiplicands == NULL ) { setup_temp_free ( f , mults , sizeof ( mults [ 0 ] ) * c -> lookup_values ) ; return error ( f , VORBIS_outofmem ) ; } for ( j = 0 ; j < ( int ) c -> lookup_values ; ++ j ) { float val = mults [ j ] * c -> delta_value + c -> minimum_value + last ; c -> multiplicands [ j ] = val ; if ( c -> sequence_p ) last = val ; } } # ifndef STB_VORBIS_DIVIDES_IN_CODEBOOK skip : ; # endif setup_temp_free ( f , mults , sizeof ( mults [ 0 ] ) * c -> lookup_values ) ; CHECK ( f ) ; } CHECK ( f ) ; } x = get_bits ( f , 6 ) + 1 ; for ( i = 0 ; i < x ; ++ i ) { uint32 z = get_bits ( f , 16 ) ; if ( z != 0 ) return error ( f , VORBIS_invalid_setup ) ; } f -> floor_count = get_bits ( f , 6 ) + 1 ; f -> floor_config = ( Floor * ) setup_malloc ( f , f -> floor_count * sizeof ( * f -> floor_config ) ) ; if ( f -> floor_config == NULL ) return error ( f , VORBIS_outofmem ) ; for ( i = 0 ; i < f -> floor_count ; ++ i ) { f -> floor_types [ i ] = get_bits ( f , 16 ) ; if ( f -> floor_types [ i ] > 1 ) return error ( f , VORBIS_invalid_setup ) ; if ( f -> floor_types [ i ] == 0 ) { Floor0 * g = & f -> floor_config [ i ] . floor0 ; g -> order = get_bits ( f , 8 ) ; g -> rate = get_bits ( f , 16 ) ; g -> bark_map_size = get_bits ( f , 16 ) ; g -> amplitude_bits = get_bits ( f , 6 ) ; g -> amplitude_offset = get_bits ( f , 8 ) ; g -> number_of_books = get_bits ( f , 4 ) + 1 ; for ( j = 0 ; j < g -> number_of_books ; ++ j ) g -> book_list [ j ] = get_bits ( f , 8 ) ; return error ( f , VORBIS_feature_not_supported ) ; } else { stbv__floor_ordering p [ 31 * 8 + 2 ] ; Floor1 * g = & f -> floor_config [ i ] . floor1 ; int max_class = - 1 ; g -> partitions = get_bits ( f , 5 ) ; for ( j = 0 ; j < g -> partitions ; ++ j ) { g -> partition_class_list [ j ] = get_bits ( f , 4 ) ; if ( g -> partition_class_list [ j ] > max_class ) max_class = g -> partition_class_list [ j ] ; } for ( j = 0 ; j <= max_class ; ++ j ) { g -> class_dimensions [ j ] = get_bits ( f , 3 ) + 1 ; g -> class_subclasses [ j ] = get_bits ( f , 2 ) ; if ( g -> class_subclasses [ j ] ) { g -> class_masterbooks [ j ] = get_bits ( f , 8 ) ; if ( g -> class_masterbooks [ j ] >= f -> codebook_count ) return error ( f , VORBIS_invalid_setup ) ; } for ( k = 0 ; k < 1 << g -> class_subclasses [ j ] ; ++ k ) { g -> subclass_books [ j ] [ k ] = get_bits ( f , 8 ) - 1 ; if ( g -> subclass_books [ j ] [ k ] >= f -> codebook_count ) return error ( f , VORBIS_invalid_setup ) ; } } g -> floor1_multiplier = get_bits ( f , 2 ) + 1 ; g -> rangebits = get_bits ( f , 4 ) ; g -> Xlist [ 0 ] = 0 ; g -> Xlist [ 1 ] = 1 << g -> rangebits ; g -> values = 2 ; for ( j = 0 ; j < g -> partitions ; ++ j ) { int c = g -> partition_class_list [ j ] ; for ( k = 0 ; k < g -> class_dimensions [ c ] ; ++ k ) { g -> Xlist [ g -> values ] = get_bits ( f , g -> rangebits ) ; ++ g -> values ; } } for ( j = 0 ; j < g -> values ; ++ j ) { p [ j ] . x = g -> Xlist [ j ] ; p [ j ] . id = j ; } qsort ( p , g -> values , sizeof ( p [ 0 ] ) , point_compare ) ; <S2SV_StartBug> for ( j = 0 ; j < g -> values ; ++ j ) <S2SV_EndBug> g -> sorted_order [ j ] = ( uint8 ) p [ j ] . id ; for ( j = 2 ; j < g -> values ; ++ j ) { int low , hi ; neighbors ( g -> Xlist , j , & low , & hi ) ; g -> neighbors [ j ] [ 0 ] = low ; g -> neighbors [ j ] [ 1 ] = hi ; } if ( g -> values > longest_floorlist ) longest_floorlist = g -> values ; } } f -> residue_count = get_bits ( f , 6 ) + 1 ; f -> residue_config = ( Residue * ) setup_malloc ( f , f -> residue_count * sizeof ( f -> residue_config [ 0 ] ) ) ; if ( f -> residue_config == NULL ) return error ( f , VORBIS_outofmem ) ; memset ( f -> residue_config , 0 , f -> residue_count * sizeof ( f -> residue_config [ 0 ] ) ) ; for ( i = 0 ; i < f -> residue_count ; ++ i ) { uint8 residue_cascade [ 64 ] ; Residue * r = f -> residue_config + i ; f -> residue_types [ i ] = get_bits ( f , 16 ) ; if ( f -> residue_types [ i ] > 2 ) return error ( f , VORBIS_invalid_setup ) ; r -> begin = get_bits ( f , 24 ) ; r -> end = get_bits ( f , 24 ) ; if ( r -> end < r -> begin ) return error ( f , VORBIS_invalid_setup ) ; r -> part_size = get_bits ( f , 24 ) + 1 ; r -> classifications = get_bits ( f , 6 ) + 1 ; r -> classbook = get_bits ( f , 8 ) ; if ( r -> classbook >= f -> codebook_count ) return error ( f , VORBIS_invalid_setup ) ; for ( j = 0 ; j < r -> classifications ; ++ j ) { uint8 high_bits = 0 ; uint8 low_bits = get_bits ( f , 3 ) ; if ( get_bits ( f , 1 ) ) high_bits = get_bits ( f , 5 ) ; residue_cascade [ j ] = high_bits * 8 + low_bits ; } r -> residue_books = ( short ( * ) [ 8 ] ) setup_malloc ( f , sizeof ( r -> residue_books [ 0 ] ) * r -> classifications ) ; if ( r -> residue_books == NULL ) return error ( f , VORBIS_outofmem ) ; for ( j = 0 ; j < r -> classifications ; ++ j ) { for ( k = 0 ; k < 8 ; ++ k ) { if ( residue_cascade [ j ] & ( 1 << k ) ) { r -> residue_books [ j ] [ k ] = get_bits ( f , 8 ) ; if ( r -> residue_books [ j ] [ k ] >= f -> codebook_count ) return error ( f , VORBIS_invalid_setup ) ; } else { r -> residue_books [ j ] [ k ] = - 1 ; } } } r -> classdata = ( uint8 * * ) setup_malloc ( f , sizeof ( * r -> classdata ) * f -> codebooks [ r -> classbook ] . entries ) ; if ( ! r -> classdata ) return error ( f , VORBIS_outofmem ) ; memset ( r -> classdata , 0 , sizeof ( * r -> classdata ) * f -> codebooks [ r -> classbook ] . entries ) ; for ( j = 0 ; j < f -> codebooks [ r -> classbook ] . entries ; ++ j ) { int classwords = f -> codebooks [ r -> classbook ] . dimensions ; int temp = j ; r -> classdata [ j ] = ( uint8 * ) setup_malloc ( f , sizeof ( r -> classdata [ j ] [ 0 ] ) * classwords ) ; if ( r -> classdata [ j ] == NULL ) return error ( f , VORBIS_outofmem ) ; for ( k = classwords - 1 ; k >= 0 ; -- k ) { r -> classdata [ j ] [ k ] = temp % r -> classifications ; temp /= r -> classifications ; } } } f -> mapping_count = get_bits ( f , 6 ) + 1 ; f -> mapping = ( Mapping * ) setup_malloc ( f , f -> mapping_count * sizeof ( * f -> mapping ) ) ; if ( f -> mapping == NULL ) return error ( f , VORBIS_outofmem ) ; memset ( f -> mapping , 0 , f -> mapping_count * sizeof ( * f -> mapping ) ) ; for ( i = 0 ; i < f -> mapping_count ; ++ i ) { Mapping * m = f -> mapping + i ; int mapping_type = get_bits ( f , 16 ) ; if ( mapping_type != 0 ) return error ( f , VORBIS_invalid_setup ) ; m -> chan = ( MappingChannel * ) setup_malloc ( f , f -> channels * sizeof ( * m -> chan ) ) ; if ( m -> chan == NULL ) return error ( f , VORBIS_outofmem ) ; if ( get_bits ( f , 1 ) ) m -> submaps = get_bits ( f , 4 ) + 1 ; else m -> submaps = 1 ; if ( m -> submaps > max_submaps ) max_submaps = m -> submaps ; if ( get_bits ( f , 1 ) ) { <S2SV_StartBug> m -> coupling_steps = get_bits ( f , 8 ) + 1 ; <S2SV_EndBug> for ( k = 0 ; k < m -> coupling_steps ; ++ k ) { m -> chan [ k ] . magnitude = get_bits ( f , ilog ( f -> channels - 1 ) ) ; m -> chan [ k ] . angle = get_bits ( f , ilog ( f -> channels - 1 ) ) ; if ( m -> chan [ k ] . magnitude >= f -> channels ) return error ( f , VORBIS_invalid_setup ) ; if ( m -> chan [ k ] . angle >= f -> channels ) return error ( f , VORBIS_invalid_setup ) ; if ( m -> chan [ k ] . magnitude == m -> chan [ k ] . angle ) return error ( f , VORBIS_invalid_setup ) ; } } else m -> coupling_steps = 0 ; if ( get_bits ( f , 2 ) ) return error ( f , VORBIS_invalid_setup ) ; if ( m -> submaps > 1 ) { for ( j = 0 ; j < f -> channels ; ++ j ) { m -> chan [ j ] . mux = get_bits ( f , 4 ) ; if ( m -> chan [ j ] . mux >= m -> submaps ) return error ( f , VORBIS_invalid_setup ) ; } } else for ( j = 0 ; j < f -> channels ; ++ j ) m -> chan [ j ] . mux = 0 ; for ( j = 0 ; j < m -> submaps ; ++ j ) { get_bits ( f , 8 ) ; m -> submap_floor [ j ] = get_bits ( f , 8 ) ; m -> submap_residue [ j ] = get_bits ( f , 8 ) ; if ( m -> submap_floor [ j ] >= f -> floor_count ) return error ( f , VORBIS_invalid_setup ) ; if ( m -> submap_residue [ j ] >= f -> residue_count ) return error ( f , VORBIS_invalid_setup ) ; } } f -> mode_count = get_bits ( f , 6 ) + 1 ; for ( i = 0 ; i < f -> mode_count ; ++ i ) { Mode * m = f -> mode_config + i ; m -> blockflag = get_bits ( f , 1 ) ; m -> windowtype = get_bits ( f , 16 ) ; m -> transformtype = get_bits ( f , 16 ) ; m -> mapping = get_bits ( f , 8 ) ; if ( m -> windowtype != 0 ) return error ( f , VORBIS_invalid_setup ) ; if ( m -> transformtype != 0 ) return error ( f , VORBIS_invalid_setup ) ; if ( m -> mapping >= f -> mapping_count ) return error ( f , VORBIS_invalid_setup ) ; } flush_packet ( f ) ; f -> previous_length = 0 ; for ( i = 0 ; i < f -> channels ; ++ i ) { f -> channel_buffers [ i ] = ( float * ) setup_malloc ( f , sizeof ( float ) * f -> blocksize_1 ) ; f -> previous_window [ i ] = ( float * ) setup_malloc ( f , sizeof ( float ) * f -> blocksize_1 / 2 ) ; f -> finalY [ i ] = ( int16 * ) setup_malloc ( f , sizeof ( int16 ) * longest_floorlist ) ; if ( f -> channel_buffers [ i ] == NULL || f -> previous_window [ i ] == NULL || f -> finalY [ i ] == NULL ) return error ( f , VORBIS_outofmem ) ; memset ( f -> channel_buffers [ i ] , 0 , sizeof ( float ) * f -> blocksize_1 ) ; # ifdef STB_VORBIS_NO_DEFER_FLOOR f -> floor_buffers [ i ] = ( float * ) setup_malloc ( f , sizeof ( float ) * f -> blocksize_1 / 2 ) ; if ( f -> floor_buffers [ i ] == NULL ) return error ( f , VORBIS_outofmem ) ; # endif } if ( ! init_blocksize ( f , 0 , f -> blocksize_0 ) ) return FALSE ; if ( ! init_blocksize ( f , 1 , f -> blocksize_1 ) ) return FALSE ; f -> blocksize [ 0 ] = f -> blocksize_0 ; f -> blocksize [ 1 ] = f -> blocksize_1 ; # ifdef STB_VORBIS_DIVIDE_TABLE if ( integer_divide_table [ 1 ] [ 1 ] == 0 ) for ( i = 0 ; i < DIVTAB_NUMER ; ++ i ) for ( j = 1 ; j < DIVTAB_DENOM ; ++ j ) integer_divide_table [ i ] [ j ] = i / j ; # endif { uint32 imdct_mem = ( f -> blocksize_1 * sizeof ( float ) >> 1 ) ; uint32 classify_mem ; int i , max_part_read = 0 ; for ( i = 0 ; i < f -> residue_count ; ++ i ) { Residue * r = f -> residue_config + i ; unsigned int actual_size = f -> blocksize_1 / 2 ; unsigned int limit_r_begin = r -> begin < actual_size ? r -> begin : actual_size ; unsigned int limit_r_end = r -> end < actual_size ? r -> end : actual_size ; int n_read = limit_r_end - limit_r_begin ; int part_read = n_read / r -> part_size ; if ( part_read > max_part_read ) max_part_read = part_read ; } # ifndef STB_VORBIS_DIVIDES_IN_RESIDUE classify_mem = f -> channels * ( sizeof ( void * ) + max_part_read * sizeof ( uint8 * ) ) ; # else classify_mem = f -> channels * ( sizeof ( void * ) + max_part_read * sizeof ( int * ) ) ; # endif f -> temp_memory_required = classify_mem ; if ( imdct_mem > f -> temp_memory_required ) f -> temp_memory_required = imdct_mem ; } f -> first_decode = TRUE ; if ( f -> alloc . alloc_buffer ) { assert ( f -> temp_offset == f -> alloc . alloc_buffer_length_in_bytes ) ; if ( f -> setup_offset + sizeof ( * f ) + f -> temp_memory_required > ( unsigned ) f -> temp_offset ) return error ( f , VORBIS_outofmem ) ; } f -> first_audio_page_offset = stb_vorbis_get_file_offset ( f ) ; return TRUE ; }","; if ( current_length >= 32 ) return error ( f , VORBIS_invalid_setup ) ; if ( <S2SV_ModStart> 1 ) { int values = lookup1_values ( c -> entries , c -> dimensions ) ; if ( values < 0 ) return error ( f , VORBIS_invalid_setup ) ; <S2SV_ModStart> -> lookup_values = ( uint32 ) values <S2SV_ModEnd> ; } else <S2SV_ModStart> g -> values - 1 ; ++ j ) if ( p [ j ] . x == p [ j + 1 ] . x ) return error ( f , VORBIS_invalid_setup ) ; for ( j = 0 ; j < g -> values <S2SV_ModStart> ) + 1 ; if ( m -> coupling_steps > f -> channels ) return error ( f , VORBIS_invalid_setup )"
255,"static void sas_eh_handle_sas_errors ( struct Scsi_Host * shost , struct list_head * work_q ) { struct scsi_cmnd * cmd , * n ; enum task_disposition res = TASK_IS_DONE ; int tmf_resp , need_reset ; struct sas_internal * i = to_sas_internal ( shost -> transportt ) ; unsigned long flags ; struct sas_ha_struct * ha = SHOST_TO_SAS_HA ( shost ) ; LIST_HEAD ( done ) ; list_for_each_entry_safe ( cmd , n , work_q , eh_entry ) { struct domain_device * dev = cmd_to_domain_dev ( cmd ) ; struct sas_task * task ; spin_lock_irqsave ( & dev -> done_lock , flags ) ; task = TO_SAS_TASK ( cmd ) ; spin_unlock_irqrestore ( & dev -> done_lock , flags ) ; if ( ! task ) list_move_tail ( & cmd -> eh_entry , & done ) ; } Again : list_for_each_entry_safe ( cmd , n , work_q , eh_entry ) { struct sas_task * task = TO_SAS_TASK ( cmd ) ; list_del_init ( & cmd -> eh_entry ) ; spin_lock_irqsave ( & task -> task_state_lock , flags ) ; need_reset = task -> task_state_flags & SAS_TASK_NEED_DEV_RESET ; spin_unlock_irqrestore ( & task -> task_state_lock , flags ) ; if ( need_reset ) { SAS_DPRINTK ( ""%s:<S2SV_blank>task<S2SV_blank>0x%p<S2SV_blank>requests<S2SV_blank>reset\\n"" , __func__ , task ) ; goto reset ; } SAS_DPRINTK ( ""trying<S2SV_blank>to<S2SV_blank>find<S2SV_blank>task<S2SV_blank>0x%p\\n"" , task ) ; res = sas_scsi_find_task ( task ) ; switch ( res ) { case TASK_IS_DONE : SAS_DPRINTK ( ""%s:<S2SV_blank>task<S2SV_blank>0x%p<S2SV_blank>is<S2SV_blank>done\\n"" , __func__ , task ) ; <S2SV_StartBug> sas_eh_defer_cmd ( cmd ) ; <S2SV_EndBug> continue ; case TASK_IS_ABORTED : SAS_DPRINTK ( ""%s:<S2SV_blank>task<S2SV_blank>0x%p<S2SV_blank>is<S2SV_blank>aborted\\n"" , __func__ , task ) ; <S2SV_StartBug> sas_eh_defer_cmd ( cmd ) ; <S2SV_EndBug> continue ; case TASK_IS_AT_LU : SAS_DPRINTK ( ""task<S2SV_blank>0x%p<S2SV_blank>is<S2SV_blank>at<S2SV_blank>LU:<S2SV_blank>lu<S2SV_blank>recover\\n"" , task ) ; reset : tmf_resp = sas_recover_lu ( task -> dev , cmd ) ; if ( tmf_resp == TMF_RESP_FUNC_COMPLETE ) { SAS_DPRINTK ( ""dev<S2SV_blank>%016llx<S2SV_blank>LU<S2SV_blank>%llx<S2SV_blank>is<S2SV_blank>"" ""recovered\\n"" , SAS_ADDR ( task -> dev ) , cmd -> device -> lun ) ; <S2SV_StartBug> sas_eh_defer_cmd ( cmd ) ; <S2SV_EndBug> sas_scsi_clear_queue_lu ( work_q , cmd ) ; goto Again ; } case TASK_IS_NOT_AT_LU : case TASK_ABORT_FAILED : SAS_DPRINTK ( ""task<S2SV_blank>0x%p<S2SV_blank>is<S2SV_blank>not<S2SV_blank>at<S2SV_blank>LU:<S2SV_blank>I_T<S2SV_blank>recover\\n"" , task ) ; tmf_resp = sas_recover_I_T ( task -> dev ) ; if ( tmf_resp == TMF_RESP_FUNC_COMPLETE || tmf_resp == - ENODEV ) { struct domain_device * dev = task -> dev ; SAS_DPRINTK ( ""I_T<S2SV_blank>%016llx<S2SV_blank>recovered\\n"" , SAS_ADDR ( task -> dev -> sas_addr ) ) ; sas_eh_finish_cmd ( cmd ) ; sas_scsi_clear_queue_I_T ( work_q , dev ) ; goto Again ; } try_to_reset_cmd_device ( cmd ) ; if ( i -> dft -> lldd_clear_nexus_port ) { struct asd_sas_port * port = task -> dev -> port ; SAS_DPRINTK ( ""clearing<S2SV_blank>nexus<S2SV_blank>for<S2SV_blank>port:%d\\n"" , port -> id ) ; res = i -> dft -> lldd_clear_nexus_port ( port ) ; if ( res == TMF_RESP_FUNC_COMPLETE ) { SAS_DPRINTK ( ""clear<S2SV_blank>nexus<S2SV_blank>port:%d<S2SV_blank>"" ""succeeded\\n"" , port -> id ) ; sas_eh_finish_cmd ( cmd ) ; sas_scsi_clear_queue_port ( work_q , port ) ; goto Again ; } } if ( i -> dft -> lldd_clear_nexus_ha ) { SAS_DPRINTK ( ""clear<S2SV_blank>nexus<S2SV_blank>ha\\n"" ) ; res = i -> dft -> lldd_clear_nexus_ha ( ha ) ; if ( res == TMF_RESP_FUNC_COMPLETE ) { SAS_DPRINTK ( ""clear<S2SV_blank>nexus<S2SV_blank>ha<S2SV_blank>"" ""succeeded\\n"" ) ; sas_eh_finish_cmd ( cmd ) ; goto clear_q ; } } SAS_DPRINTK ( ""error<S2SV_blank>from<S2SV_blank><S2SV_blank>device<S2SV_blank>%llx,<S2SV_blank>LUN<S2SV_blank>%llx<S2SV_blank>"" ""couldn\'t<S2SV_blank>be<S2SV_blank>recovered<S2SV_blank>in<S2SV_blank>any<S2SV_blank>way\\n"" , SAS_ADDR ( task -> dev -> sas_addr ) , cmd -> device -> lun ) ; sas_eh_finish_cmd ( cmd ) ; goto clear_q ; } } out : list_splice_tail ( & done , work_q ) ; list_splice_tail_init ( & ha -> eh_ata_q , work_q ) ; return ; clear_q : SAS_DPRINTK ( ""---<S2SV_blank>Exit<S2SV_blank>%s<S2SV_blank>--<S2SV_blank>clear_q\\n"" , __func__ ) ; list_for_each_entry_safe ( cmd , n , work_q , eh_entry ) sas_eh_finish_cmd ( cmd ) ; goto out ; }",task ) ; sas_eh_finish_cmd <S2SV_ModEnd> ( cmd ) <S2SV_ModStart> task ) ; sas_eh_finish_cmd <S2SV_ModEnd> ( cmd ) <S2SV_ModStart> lun ) ; sas_eh_finish_cmd <S2SV_ModEnd> ( cmd )
256,"int wait_for_key_construction ( struct key * key , bool intr ) { int ret ; ret = wait_on_bit ( & key -> flags , KEY_FLAG_USER_CONSTRUCT , intr ? TASK_INTERRUPTIBLE : TASK_UNINTERRUPTIBLE ) ; if ( ret ) return - ERESTARTSYS ; <S2SV_StartBug> if ( test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) { <S2SV_EndBug> smp_rmb ( ) ; return key -> reject_error ; } return key_validate ( key ) ; }",- ERESTARTSYS ; ret = key_read_state ( key ) ; if ( ret < 0 ) return ret ; <S2SV_ModEnd> return key_validate (
257,"static vpx_codec_err_t ctrl_set_reference ( vpx_codec_alg_priv_t * ctx , <S2SV_StartBug> int ctr_id , va_list args ) { <S2SV_EndBug> <S2SV_StartBug> vpx_ref_frame_t * const data = va_arg ( args , vpx_ref_frame_t * ) ; <S2SV_EndBug> if ( data ) { vpx_ref_frame_t * const frame = ( vpx_ref_frame_t * ) data ; YV12_BUFFER_CONFIG sd ; <S2SV_StartBug> image2yuvconfig ( & frame -> img , & sd ) ; <S2SV_EndBug> <S2SV_StartBug> return vp9_set_reference_dec ( & ctx -> pbi -> common , <S2SV_EndBug> ( VP9_REFFRAME ) frame -> frame_type , & sd ) ; } else { return VPX_CODEC_INVALID_PARAM ; } }","* ctx , <S2SV_ModEnd> va_list args ) <S2SV_ModStart> * ) ; if ( ctx -> frame_parallel_decode ) { set_error_detail ( ctx , ""Not<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>frame<S2SV_blank>parallel<S2SV_blank>decode"" ) ; return VPX_CODEC_INCAPABLE ; } <S2SV_ModStart> YV12_BUFFER_CONFIG sd ; VPxWorker * const worker = ctx -> frame_workers ; FrameWorkerData * const frame_worker_data = ( FrameWorkerData * ) worker -> data1 ; <S2SV_ModStart> vp9_set_reference_dec ( & frame_worker_data <S2SV_ModEnd> -> pbi ->"
258,"static UINT printer_process_irp_write ( PRINTER_DEVICE * printer_dev , IRP * irp ) { UINT32 Length ; UINT64 Offset ; rdpPrintJob * printjob = NULL ; UINT error = CHANNEL_RC_OK ; <S2SV_StartBug> Stream_Read_UINT32 ( irp -> input , Length ) ; <S2SV_EndBug> Stream_Read_UINT64 ( irp -> input , Offset ) ; Stream_Seek ( irp -> input , 20 ) ; <S2SV_StartBug> if ( printer_dev -> printer ) <S2SV_EndBug> printjob = printer_dev -> printer -> FindPrintJob ( printer_dev -> printer , irp -> FileId ) ; if ( ! printjob ) { irp -> IoStatus = STATUS_UNSUCCESSFUL ; Length = 0 ; } else { <S2SV_StartBug> error = printjob -> Write ( printjob , Stream_Pointer ( irp -> input ) , Length ) ; <S2SV_EndBug> } if ( error ) { WLog_ERR ( TAG , ""printjob->Write<S2SV_blank>failed<S2SV_blank>with<S2SV_blank>error<S2SV_blank>%"" PRIu32 ""!"" , error ) ; return error ; } Stream_Write_UINT32 ( irp -> output , Length ) ; Stream_Write_UINT8 ( irp -> output , 0 ) ; return irp -> Complete ( irp ) ; }","= CHANNEL_RC_OK ; void * ptr ; if ( Stream_GetRemainingLength ( irp -> input ) < 32 ) return ERROR_INVALID_DATA ; <S2SV_ModStart> 20 ) ; ptr = Stream_Pointer ( irp -> input ) ; if ( ! Stream_SafeSeek ( irp -> input , Length ) ) return ERROR_INVALID_DATA ; <S2SV_ModStart> ( printjob , ptr <S2SV_ModEnd> , Length )"
259,"int wc_SignatureGenerateHash ( enum wc_HashType hash_type , enum wc_SignatureType sig_type , const byte * hash_data , word32 hash_len , byte * sig , word32 * sig_len , const void * key , word32 key_len , WC_RNG * rng ) { <S2SV_StartBug> int ret ; <S2SV_EndBug> ( void ) rng ; if ( hash_data == NULL || hash_len <= 0 || sig == NULL || sig_len == NULL || * sig_len <= 0 || key == NULL || key_len <= 0 ) { return BAD_FUNC_ARG ; } <S2SV_StartBug> if ( ( int ) * sig_len < wc_SignatureGetSize ( sig_type , key , key_len ) ) { <S2SV_EndBug> WOLFSSL_MSG ( ""wc_SignatureGenerate:<S2SV_blank>Invalid<S2SV_blank>sig<S2SV_blank>type/len"" ) ; return BAD_FUNC_ARG ; } ret = wc_HashGetDigestSize ( hash_type ) ; if ( ret < 0 ) { WOLFSSL_MSG ( ""wc_SignatureGenerate:<S2SV_blank>Invalid<S2SV_blank>hash<S2SV_blank>type/len"" ) ; return ret ; } ret = 0 ; switch ( sig_type ) { case WC_SIGNATURE_TYPE_ECC : # if defined ( HAVE_ECC ) && defined ( HAVE_ECC_SIGN ) do { # ifdef WOLFSSL_ASYNC_CRYPT ret = wc_AsyncWait ( ret , & ( ( ecc_key * ) key ) -> asyncDev , WC_ASYNC_FLAG_CALL_AGAIN ) ; # endif if ( ret >= 0 ) ret = wc_ecc_sign_hash ( hash_data , hash_len , sig , sig_len , rng , ( ecc_key * ) key ) ; <S2SV_StartBug> } while ( ret == WC_PENDING_E ) ; <S2SV_EndBug> # else ret = SIG_TYPE_E ; # endif break ; case WC_SIGNATURE_TYPE_RSA_W_ENC : case WC_SIGNATURE_TYPE_RSA : # if ! defined ( NO_RSA ) && ! defined ( WOLFSSL_RSA_PUBLIC_ONLY ) do { # ifdef WOLFSSL_ASYNC_CRYPT ret = wc_AsyncWait ( ret , & ( ( RsaKey * ) key ) -> asyncDev , WC_ASYNC_FLAG_CALL_AGAIN ) ; # endif if ( ret >= 0 ) ret = wc_RsaSSL_Sign ( hash_data , hash_len , sig , * sig_len , ( RsaKey * ) key , rng ) ; } while ( ret == WC_PENDING_E ) ; if ( ret >= 0 ) { * sig_len = ret ; ret = 0 ; } # else ret = SIG_TYPE_E ; # endif break ; case WC_SIGNATURE_TYPE_NONE : default : ret = BAD_FUNC_ARG ; break ; } return ret ; }","rng ) { return wc_SignatureGenerateHash_ex ( hash_type , sig_type , hash_data , hash_len , sig , sig_len <S2SV_ModEnd> , key , <S2SV_ModStart> key , key_len , rng , 1 <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>"
260,"static inline int ip6_ufo_append_data ( struct sock * sk , int getfrag ( void * from , char * to , int offset , int len , int odd , struct sk_buff * skb ) , void * from , int length , int hh_len , int fragheaderlen , int transhdrlen , int mtu , unsigned int flags , struct rt6_info * rt ) { struct sk_buff * skb ; <S2SV_StartBug> int err ; <S2SV_EndBug> if ( ( skb = skb_peek_tail ( & sk -> sk_write_queue ) ) == NULL ) { <S2SV_StartBug> struct frag_hdr fhdr ; <S2SV_EndBug> skb = sock_alloc_send_skb ( sk , hh_len + fragheaderlen + transhdrlen + 20 , ( flags & MSG_DONTWAIT ) , & err ) ; if ( skb == NULL ) return err ; skb_reserve ( skb , hh_len ) ; skb_put ( skb , fragheaderlen + transhdrlen ) ; skb_reset_network_header ( skb ) ; skb -> transport_header = skb -> network_header + fragheaderlen ; skb -> protocol = htons ( ETH_P_IPV6 ) ; <S2SV_StartBug> skb -> ip_summed = CHECKSUM_PARTIAL ; <S2SV_EndBug> skb -> csum = 0 ; skb_shinfo ( skb ) -> gso_size = ( mtu - fragheaderlen - sizeof ( struct frag_hdr ) ) & ~ 7 ; skb_shinfo ( skb ) -> gso_type = SKB_GSO_UDP ; ipv6_select_ident ( & fhdr , rt ) ; skb_shinfo ( skb ) -> ip6_frag_id = fhdr . identification ; <S2SV_StartBug> __skb_queue_tail ( & sk -> sk_write_queue , skb ) ; <S2SV_EndBug> } return skb_append_datato_frags ( sk , skb , getfrag , from , ( length - transhdrlen ) ) ; }","* skb ; struct frag_hdr fhdr ; <S2SV_ModStart> NULL ) { <S2SV_ModEnd> skb = sock_alloc_send_skb <S2SV_ModStart> ; skb -> csum = 0 ; __skb_queue_tail ( & sk -> sk_write_queue , skb ) ; } else if ( skb_is_gso ( skb ) ) { goto append ; } skb -> <S2SV_ModStart> ip_summed = CHECKSUM_PARTIAL <S2SV_ModEnd> ; skb_shinfo ( <S2SV_ModStart> . identification ; append : <S2SV_ModEnd> return skb_append_datato_frags ("
261,"static noinline void key_gc_unused_keys ( struct list_head * keys ) { while ( ! list_empty ( keys ) ) { struct key * key = list_entry ( keys -> next , struct key , graveyard_link ) ; list_del ( & key -> graveyard_link ) ; kdebug ( ""-<S2SV_blank>%u"" , key -> serial ) ; key_check ( key ) ; security_key_free ( key ) ; if ( test_bit ( KEY_FLAG_IN_QUOTA , & key -> flags ) ) { spin_lock ( & key -> user -> lock ) ; key -> user -> qnkeys -- ; key -> user -> qnbytes -= key -> quotalen ; spin_unlock ( & key -> user -> lock ) ; } atomic_dec ( & key -> user -> nkeys ) ; if ( test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) ) atomic_dec ( & key -> user -> nikeys ) ; <S2SV_StartBug> key_user_put ( key -> user ) ; <S2SV_EndBug> if ( key -> type -> destroy ) key -> type -> destroy ( key ) ; kfree ( key -> description ) ; # ifdef KEY_DEBUGGING key -> magic = KEY_DEBUG_MAGIC_X ; # endif kmem_cache_free ( key_jar , key ) ; } }",nikeys ) ; if ( key -> type -> destroy ) key -> type -> destroy ( key ) ; <S2SV_ModStart> key -> user <S2SV_ModEnd> ) ; kfree
262,"static long ion_ioctl ( struct file * filp , unsigned int cmd , unsigned long arg ) { struct ion_client * client = filp -> private_data ; struct ion_device * dev = client -> dev ; struct ion_handle * cleanup_handle = NULL ; int ret = 0 ; unsigned int dir ; union { struct ion_fd_data fd ; struct ion_allocation_data allocation ; struct ion_handle_data handle ; struct ion_custom_data custom ; } data ; dir = ion_ioctl_dir ( cmd ) ; if ( _IOC_SIZE ( cmd ) > sizeof ( data ) ) return - EINVAL ; if ( dir & _IOC_WRITE ) if ( copy_from_user ( & data , ( void __user * ) arg , _IOC_SIZE ( cmd ) ) ) return - EFAULT ; switch ( cmd ) { case ION_IOC_ALLOC : { struct ion_handle * handle ; handle = ion_alloc ( client , data . allocation . len , data . allocation . align , data . allocation . heap_id_mask , data . allocation . flags ) ; if ( IS_ERR ( handle ) ) return PTR_ERR ( handle ) ; data . allocation . handle = handle -> id ; cleanup_handle = handle ; break ; } case ION_IOC_FREE : { struct ion_handle * handle ; <S2SV_StartBug> handle = ion_handle_get_by_id ( client , data . handle . handle ) ; <S2SV_EndBug> <S2SV_StartBug> if ( IS_ERR ( handle ) ) <S2SV_EndBug> return PTR_ERR ( handle ) ; <S2SV_StartBug> ion_free ( client , handle ) ; <S2SV_EndBug> ion_handle_put ( handle ) ; break ; } case ION_IOC_SHARE : case ION_IOC_MAP : { struct ion_handle * handle ; handle = ion_handle_get_by_id ( client , data . handle . handle ) ; if ( IS_ERR ( handle ) ) return PTR_ERR ( handle ) ; data . fd . fd = ion_share_dma_buf_fd ( client , handle ) ; ion_handle_put ( handle ) ; if ( data . fd . fd < 0 ) ret = data . fd . fd ; break ; } case ION_IOC_IMPORT : { struct ion_handle * handle ; handle = ion_import_dma_buf_fd ( client , data . fd . fd ) ; if ( IS_ERR ( handle ) ) ret = PTR_ERR ( handle ) ; else data . handle . handle = handle -> id ; break ; } case ION_IOC_SYNC : { ret = ion_sync_for_device ( client , data . fd . fd ) ; break ; } case ION_IOC_CUSTOM : { if ( ! dev -> custom_ioctl ) return - ENOTTY ; ret = dev -> custom_ioctl ( client , data . custom . cmd , data . custom . arg ) ; break ; } default : return - ENOTTY ; } if ( dir & _IOC_READ ) { if ( copy_to_user ( ( void __user * ) arg , & data , _IOC_SIZE ( cmd ) ) ) { if ( cleanup_handle ) ion_free ( client , cleanup_handle ) ; return - EFAULT ; } } return ret ; }","* handle ; mutex_lock ( & client -> lock ) ; handle = ion_handle_get_by_id_nolock <S2SV_ModEnd> ( client , <S2SV_ModStart> handle ) ) { mutex_unlock ( & client -> lock ) ; <S2SV_ModStart> handle ) ; } ion_free_nolock ( client , handle ) ; ion_handle_put_nolock ( handle ) ; mutex_unlock ( & client -> lock <S2SV_ModEnd> ) ; break"
263,"static int wdm_post_reset ( struct usb_interface * intf ) { struct wdm_device * desc = wdm_find_device ( intf ) ; <S2SV_StartBug> int rv ; <S2SV_EndBug> clear_bit ( WDM_RESETTING , & desc -> flags ) ; rv = recover_from_urb_loss ( desc ) ; mutex_unlock ( & desc -> wlock ) ; mutex_unlock ( & desc -> rlock ) ; return 0 ; }","; int rv ; clear_bit ( WDM_OVERFLOW , & desc -> flags )"
264,"int handle_popc ( u32 insn , struct pt_regs * regs ) { u64 value ; int ret , i , rd = ( ( insn >> 25 ) & 0x1f ) ; int from_kernel = ( regs -> tstate & TSTATE_PRIV ) != 0 ; <S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , 0 ) ; <S2SV_EndBug> if ( insn & 0x2000 ) { maybe_flush_windows ( 0 , 0 , rd , from_kernel ) ; value = sign_extend_imm13 ( insn ) ; } else { maybe_flush_windows ( 0 , insn & 0x1f , rd , from_kernel ) ; value = fetch_reg ( insn & 0x1f , regs ) ; } for ( ret = 0 , i = 0 ; i < 16 ; i ++ ) { ret += popc_helper [ value & 0xf ] ; value >>= 4 ; } if ( rd < 16 ) { if ( rd ) regs -> u_regs [ rd ] = ret ; } else { if ( test_thread_flag ( TIF_32BIT ) ) { struct reg_window32 __user * win32 ; win32 = ( struct reg_window32 __user * ) ( ( unsigned long ) ( ( u32 ) regs -> u_regs [ UREG_FP ] ) ) ; put_user ( ret , & win32 -> locals [ rd - 16 ] ) ; } else { struct reg_window __user * win ; win = ( struct reg_window __user * ) ( regs -> u_regs [ UREG_FP ] + STACK_BIAS ) ; put_user ( ret , & win -> locals [ rd - 16 ] ) ; } } advance ( regs ) ; return 1 ; }","PERF_COUNT_SW_EMULATION_FAULTS , 1 <S2SV_ModEnd> , regs ,"
265,"int jp2_box_put ( jp2_box_t * box , jas_stream_t * out ) { jas_stream_t * tmpstream ; bool extlen ; bool dataflag ; tmpstream = 0 ; dataflag = ! ( box -> info -> flags & ( JP2_BOX_SUPER | JP2_BOX_NODATA ) ) ; if ( dataflag ) { if ( ! ( tmpstream = jas_stream_memopen ( 0 , 0 ) ) ) { goto error ; } if ( box -> ops -> putdata ) { if ( ( * box -> ops -> putdata ) ( box , tmpstream ) ) { goto error ; } } box -> len = jas_stream_tell ( tmpstream ) + JP2_BOX_HDRLEN ( false ) ; jas_stream_rewind ( tmpstream ) ; } extlen = ( box -> len >= ( ( ( uint_fast64_t ) 1 ) << 32 ) ) != 0 ; if ( jp2_putuint32 ( out , extlen ? 1 : box -> len ) ) { goto error ; } if ( jp2_putuint32 ( out , box -> type ) ) { goto error ; } if ( extlen ) { if ( jp2_putuint64 ( out , box -> len ) ) { goto error ; } } if ( dataflag ) { <S2SV_StartBug> if ( jas_stream_copy ( out , tmpstream , box -> len - JP2_BOX_HDRLEN ( false ) ) ) { <S2SV_EndBug> goto error ; } jas_stream_close ( tmpstream ) ; } return 0 ; error : if ( tmpstream ) { jas_stream_close ( tmpstream ) ; } return - 1 ; }",") ) { jas_eprintf ( ""cannot<S2SV_blank>copy<S2SV_blank>box<S2SV_blank>data\\n"" ) ;"
266,"static int do_new_mount ( struct path * path , const char * fstype , int flags , int mnt_flags , const char * name , void * data ) { struct file_system_type * type ; struct user_namespace * user_ns = current -> nsproxy -> mnt_ns -> user_ns ; struct vfsmount * mnt ; int err ; if ( ! fstype ) return - EINVAL ; type = get_fs_type ( fstype ) ; if ( ! type ) return - ENODEV ; if ( user_ns != & init_user_ns ) { if ( ! ( type -> fs_flags & FS_USERNS_MOUNT ) ) { put_filesystem ( type ) ; return - EPERM ; } if ( ! ( type -> fs_flags & FS_USERNS_DEV_MOUNT ) ) { flags |= MS_NODEV ; <S2SV_StartBug> mnt_flags |= MNT_NODEV ; <S2SV_EndBug> } } mnt = vfs_kern_mount ( type , flags , name , data ) ; if ( ! IS_ERR ( mnt ) && ( type -> fs_flags & FS_HAS_SUBTYPE ) && ! mnt -> mnt_sb -> s_subtype ) mnt = fs_set_subtype ( mnt , fstype ) ; put_filesystem ( type ) ; if ( IS_ERR ( mnt ) ) return PTR_ERR ( mnt ) ; err = do_add_mount ( real_mount ( mnt ) , path , mnt_flags ) ; if ( err ) mntput ( mnt ) ; return err ; }",mnt_flags |= MNT_NODEV | MNT_LOCK_NODEV
267,"static void bond_setup ( struct net_device * bond_dev ) { struct bonding * bond = netdev_priv ( bond_dev ) ; rwlock_init ( & bond -> lock ) ; rwlock_init ( & bond -> curr_slave_lock ) ; bond -> params = bonding_defaults ; bond -> dev = bond_dev ; INIT_LIST_HEAD ( & bond -> vlan_list ) ; ether_setup ( bond_dev ) ; bond_dev -> netdev_ops = & bond_netdev_ops ; bond_dev -> ethtool_ops = & bond_ethtool_ops ; bond_set_mode_ops ( bond , bond -> params . mode ) ; bond_dev -> destructor = bond_destructor ; bond_dev -> tx_queue_len = 0 ; bond_dev -> flags |= IFF_MASTER | IFF_MULTICAST ; bond_dev -> priv_flags |= IFF_BONDING ; <S2SV_StartBug> bond_dev -> priv_flags &= ~ IFF_XMIT_DST_RELEASE ; <S2SV_EndBug> bond_dev -> features |= NETIF_F_VLAN_CHALLENGED ; bond_dev -> features |= NETIF_F_LLTX ; bond_dev -> hw_features = BOND_VLAN_FEATURES | NETIF_F_HW_VLAN_TX | NETIF_F_HW_VLAN_RX | NETIF_F_HW_VLAN_FILTER ; bond_dev -> hw_features &= ~ ( NETIF_F_ALL_CSUM & ~ NETIF_F_NO_CSUM ) ; bond_dev -> features |= bond_dev -> hw_features ; }",priv_flags &= ~ ( IFF_XMIT_DST_RELEASE | IFF_TX_SKB_SHARING ) <S2SV_ModEnd> ; bond_dev ->
268,"static apr_byte_t oidc_validate_post_logout_url ( request_rec * r , const char * url , char * * err_str , char * * err_desc ) { apr_uri_t uri ; const char * c_host = NULL ; if ( apr_uri_parse ( r -> pool , url , & uri ) != APR_SUCCESS ) { * err_str = apr_pstrdup ( r -> pool , ""Malformed<S2SV_blank>URL"" ) ; * err_desc = apr_psprintf ( r -> pool , ""Logout<S2SV_blank>URL<S2SV_blank>malformed:<S2SV_blank>%s"" , url ) ; oidc_error ( r , ""%s:<S2SV_blank>%s"" , * err_str , * err_desc ) ; return FALSE ; } c_host = oidc_get_current_url_host ( r ) ; if ( ( uri . hostname != NULL ) && ( ( strstr ( c_host , uri . hostname ) == NULL ) || ( strstr ( uri . hostname , c_host ) == NULL ) ) ) { * err_str = apr_pstrdup ( r -> pool , ""Invalid<S2SV_blank>Request"" ) ; * err_desc = apr_psprintf ( r -> pool , ""logout<S2SV_blank>value<S2SV_blank>\\""%s\\""<S2SV_blank>does<S2SV_blank>not<S2SV_blank>match<S2SV_blank>the<S2SV_blank>hostname<S2SV_blank>of<S2SV_blank>the<S2SV_blank>current<S2SV_blank>request<S2SV_blank>\\""%s\\"""" , apr_uri_unparse ( r -> pool , & uri , 0 ) , c_host ) ; oidc_error ( r , ""%s:<S2SV_blank>%s"" , * err_str , * err_desc ) ; return FALSE ; <S2SV_StartBug> } else if ( strstr ( url , ""/"" ) != url ) { <S2SV_EndBug> * err_str = apr_pstrdup ( r -> pool , ""Malformed<S2SV_blank>URL"" ) ; * err_desc = apr_psprintf ( r -> pool , ""No<S2SV_blank>hostname<S2SV_blank>was<S2SV_blank>parsed<S2SV_blank>and<S2SV_blank>it<S2SV_blank>does<S2SV_blank>not<S2SV_blank>seem<S2SV_blank>to<S2SV_blank>be<S2SV_blank>relative,<S2SV_blank>i.e<S2SV_blank>starting<S2SV_blank>with<S2SV_blank>\'/\':<S2SV_blank>%s"" , url ) ; oidc_error ( r , ""%s:<S2SV_blank>%s"" , * err_str , * err_desc ) ; return FALSE ; } if ( ( ( strstr ( url , ""\\n"" ) != NULL ) || strstr ( url , ""\\r"" ) != NULL ) ) { * err_str = apr_pstrdup ( r -> pool , ""Invalid<S2SV_blank>Request"" ) ; * err_desc = apr_psprintf ( r -> pool , ""logout<S2SV_blank>value<S2SV_blank>\\""%s\\""<S2SV_blank>contains<S2SV_blank>illegal<S2SV_blank>\\""\\n\\""<S2SV_blank>or<S2SV_blank>\\""\\r\\""<S2SV_blank>character(s)"" , url ) ; oidc_error ( r , ""%s:<S2SV_blank>%s"" , * err_str , * err_desc ) ; return FALSE ; } return TRUE ; }",else if ( ( uri . hostname == NULL ) && ( <S2SV_ModStart> != url ) )
269,"int kvm_read_guest_page ( struct kvm * kvm , gfn_t gfn , void * data , int offset , int len ) { int r ; unsigned long addr ; addr = gfn_to_hva ( kvm , gfn ) ; if ( kvm_is_error_hva ( addr ) ) return - EFAULT ; <S2SV_StartBug> r = copy_from_user ( data , ( void __user * ) addr + offset , len ) ; <S2SV_EndBug> if ( r ) return - EFAULT ; return 0 ; }","; r = __copy_from_user <S2SV_ModEnd> ( data ,"
270,static void perf_remove_from_owner ( struct perf_event * event ) { struct task_struct * owner ; rcu_read_lock ( ) ; owner = ACCESS_ONCE ( event -> owner ) ; smp_read_barrier_depends ( ) ; if ( owner ) { get_task_struct ( owner ) ; } rcu_read_unlock ( ) ; if ( owner ) { <S2SV_StartBug> mutex_lock ( & owner -> perf_event_mutex ) ; <S2SV_EndBug> if ( event -> owner ) list_del_init ( & event -> owner_entry ) ; mutex_unlock ( & owner -> perf_event_mutex ) ; put_task_struct ( owner ) ; } },"owner ) { mutex_lock_nested <S2SV_ModEnd> ( & owner <S2SV_ModStart> owner -> perf_event_mutex , SINGLE_DEPTH_NESTING"
271,"static int check_entry_size_and_hooks ( struct ipt_entry * e , struct xt_table_info * newinfo , const unsigned char * base , const unsigned char * limit , const unsigned int * hook_entries , const unsigned int * underflows , unsigned int valid_hooks ) { unsigned int h ; int err ; if ( ( unsigned long ) e % __alignof__ ( struct ipt_entry ) != 0 || ( unsigned char * ) e + sizeof ( struct ipt_entry ) >= limit || ( unsigned char * ) e + e -> next_offset > limit ) { duprintf ( ""Bad<S2SV_blank>offset<S2SV_blank>%p\\n"" , e ) ; return - EINVAL ; } if ( e -> next_offset < sizeof ( struct ipt_entry ) + sizeof ( struct xt_entry_target ) ) { duprintf ( ""checking:<S2SV_blank>element<S2SV_blank>%p<S2SV_blank>size<S2SV_blank>%u\\n"" , e , e -> next_offset ) ; return - EINVAL ; } err = check_entry ( e ) ; if ( err ) return err ; for ( h = 0 ; h < NF_INET_NUMHOOKS ; h ++ ) { if ( ! ( valid_hooks & ( 1 << h ) ) ) continue ; if ( ( unsigned char * ) e - base == hook_entries [ h ] ) newinfo -> hook_entry [ h ] = hook_entries [ h ] ; if ( ( unsigned char * ) e - base == underflows [ h ] ) { if ( ! check_underflow ( e ) ) { <S2SV_StartBug> pr_err ( ""Underflows<S2SV_blank>must<S2SV_blank>be<S2SV_blank>unconditional<S2SV_blank>and<S2SV_blank>"" <S2SV_EndBug> ""use<S2SV_blank>the<S2SV_blank>STANDARD<S2SV_blank>target<S2SV_blank>with<S2SV_blank>"" ""ACCEPT/DROP\\n"" ) ; return - EINVAL ; } newinfo -> underflow [ h ] = underflows [ h ] ; } } e -> counters = ( ( struct xt_counters ) { 0 , 0 } ) ; e -> comefrom = 0 ; return 0 ; }",") ) { pr_debug <S2SV_ModEnd> ( ""Underflows<S2SV_blank>must<S2SV_blank>be<S2SV_blank>unconditional<S2SV_blank>and<S2SV_blank>"" ""use<S2SV_blank>the<S2SV_blank>STANDARD<S2SV_blank>target<S2SV_blank>with<S2SV_blank>"""
272,"<S2SV_StartBug> void usage_exit ( ) { <S2SV_EndBug> fprintf ( stderr , ""Usage:<S2SV_blank>%s<S2SV_blank><infile><S2SV_blank><outfile>\\n"" , exec_name ) ; exit ( EXIT_FAILURE ) ; }",void usage_exit ( void
273,"static int nlmsg_populate_mdb_fill ( struct sk_buff * skb , struct net_device * dev , struct br_mdb_entry * entry , u32 pid , u32 seq , int type , unsigned int flags ) { struct nlmsghdr * nlh ; struct br_port_msg * bpm ; struct nlattr * nest , * nest2 ; nlh = nlmsg_put ( skb , pid , seq , type , sizeof ( * bpm ) , NLM_F_MULTI ) ; if ( ! nlh ) return - EMSGSIZE ; bpm = nlmsg_data ( nlh ) ; <S2SV_StartBug> bpm -> family = AF_BRIDGE ; <S2SV_EndBug> bpm -> ifindex = dev -> ifindex ; nest = nla_nest_start ( skb , MDBA_MDB ) ; if ( nest == NULL ) goto cancel ; nest2 = nla_nest_start ( skb , MDBA_MDB_ENTRY ) ; if ( nest2 == NULL ) goto end ; if ( nla_put ( skb , MDBA_MDB_ENTRY_INFO , sizeof ( * entry ) , entry ) ) goto end ; nla_nest_end ( skb , nest2 ) ; nla_nest_end ( skb , nest ) ; return nlmsg_end ( skb , nlh ) ; end : nla_nest_end ( skb , nest ) ; cancel : nlmsg_cancel ( skb , nlh ) ; return - EMSGSIZE ; }","nlh ) ; memset ( bpm , 0 , sizeof ( * bpm ) ) ;"
274,"static int btrfs_rename ( struct inode * old_dir , struct dentry * old_dentry , struct inode * new_dir , struct dentry * new_dentry ) { struct btrfs_trans_handle * trans ; struct btrfs_root * root = BTRFS_I ( old_dir ) -> root ; struct btrfs_root * dest = BTRFS_I ( new_dir ) -> root ; struct inode * new_inode = new_dentry -> d_inode ; struct inode * old_inode = old_dentry -> d_inode ; struct timespec ctime = CURRENT_TIME ; u64 index = 0 ; u64 root_objectid ; int ret ; u64 old_ino = btrfs_ino ( old_inode ) ; if ( btrfs_ino ( new_dir ) == BTRFS_EMPTY_SUBVOL_DIR_OBJECTID ) return - EPERM ; if ( old_ino != BTRFS_FIRST_FREE_OBJECTID && root != dest ) return - EXDEV ; if ( old_ino == BTRFS_EMPTY_SUBVOL_DIR_OBJECTID || ( new_inode && btrfs_ino ( new_inode ) == BTRFS_FIRST_FREE_OBJECTID ) ) return - ENOTEMPTY ; if ( S_ISDIR ( old_inode -> i_mode ) && new_inode && new_inode -> i_size > BTRFS_EMPTY_DIR_SIZE ) return - ENOTEMPTY ; <S2SV_StartBug> if ( new_inode && S_ISREG ( old_inode -> i_mode ) && new_inode -> i_size && <S2SV_EndBug> old_inode -> i_size > BTRFS_ORDERED_OPERATIONS_FLUSH_LIMIT ) filemap_flush ( old_inode -> i_mapping ) ; if ( old_ino == BTRFS_FIRST_FREE_OBJECTID ) down_read ( & root -> fs_info -> subvol_sem ) ; trans = btrfs_start_transaction ( root , 20 ) ; if ( IS_ERR ( trans ) ) { ret = PTR_ERR ( trans ) ; goto out_notrans ; } if ( dest != root ) btrfs_record_root_in_trans ( trans , dest ) ; ret = btrfs_set_inode_index ( new_dir , & index ) ; if ( ret ) goto out_fail ; if ( unlikely ( old_ino == BTRFS_FIRST_FREE_OBJECTID ) ) { root -> fs_info -> last_trans_log_full_commit = trans -> transid ; } else { ret = btrfs_insert_inode_ref ( trans , dest , new_dentry -> d_name . name , new_dentry -> d_name . len , old_ino , btrfs_ino ( new_dir ) , index ) ; if ( ret ) goto out_fail ; btrfs_pin_log_trans ( root ) ; } if ( new_inode && new_inode -> i_size && S_ISREG ( old_inode -> i_mode ) ) btrfs_add_ordered_operation ( trans , root , old_inode ) ; inode_inc_iversion ( old_dir ) ; inode_inc_iversion ( new_dir ) ; inode_inc_iversion ( old_inode ) ; old_dir -> i_ctime = old_dir -> i_mtime = ctime ; new_dir -> i_ctime = new_dir -> i_mtime = ctime ; old_inode -> i_ctime = ctime ; if ( old_dentry -> d_parent != new_dentry -> d_parent ) btrfs_record_unlink_dir ( trans , old_dir , old_inode , 1 ) ; if ( unlikely ( old_ino == BTRFS_FIRST_FREE_OBJECTID ) ) { root_objectid = BTRFS_I ( old_inode ) -> root -> root_key . objectid ; ret = btrfs_unlink_subvol ( trans , root , old_dir , root_objectid , old_dentry -> d_name . name , old_dentry -> d_name . len ) ; } else { ret = __btrfs_unlink_inode ( trans , root , old_dir , old_dentry -> d_inode , old_dentry -> d_name . name , old_dentry -> d_name . len ) ; if ( ! ret ) ret = btrfs_update_inode ( trans , root , old_inode ) ; } if ( ret ) { btrfs_abort_transaction ( trans , root , ret ) ; goto out_fail ; } if ( new_inode ) { inode_inc_iversion ( new_inode ) ; new_inode -> i_ctime = CURRENT_TIME ; if ( unlikely ( btrfs_ino ( new_inode ) == BTRFS_EMPTY_SUBVOL_DIR_OBJECTID ) ) { root_objectid = BTRFS_I ( new_inode ) -> location . objectid ; ret = btrfs_unlink_subvol ( trans , dest , new_dir , root_objectid , new_dentry -> d_name . name , new_dentry -> d_name . len ) ; BUG_ON ( new_inode -> i_nlink == 0 ) ; } else { ret = btrfs_unlink_inode ( trans , dest , new_dir , new_dentry -> d_inode , new_dentry -> d_name . name , new_dentry -> d_name . len ) ; } if ( ! ret && new_inode -> i_nlink == 0 ) { ret = btrfs_orphan_add ( trans , new_dentry -> d_inode ) ; BUG_ON ( ret ) ; } if ( ret ) { btrfs_abort_transaction ( trans , root , ret ) ; goto out_fail ; } } fixup_inode_flags ( new_dir , old_inode ) ; ret = btrfs_add_link ( trans , new_dir , old_inode , new_dentry -> d_name . name , new_dentry -> d_name . len , 0 , index ) ; if ( ret ) { btrfs_abort_transaction ( trans , root , ret ) ; goto out_fail ; } if ( old_ino != BTRFS_FIRST_FREE_OBJECTID ) { struct dentry * parent = new_dentry -> d_parent ; btrfs_log_new_name ( trans , old_inode , old_dir , parent ) ; btrfs_end_log_trans ( root ) ; } out_fail : btrfs_end_transaction ( trans , root ) ; out_notrans : if ( old_ino == BTRFS_FIRST_FREE_OBJECTID ) up_read ( & root -> fs_info -> subvol_sem ) ; return ret ; }","- ENOTEMPTY ; ret = btrfs_check_dir_item_collision ( root , new_dir -> i_ino , new_dentry -> d_name . name , new_dentry -> d_name . len ) ; if ( ret ) { if ( ret == - EEXIST ) { if ( ! new_inode ) { WARN_ON ( 1 ) ; return ret ; } } else { return ret ; } } ret = 0 ;"
275,"static int ima_lsm_rule_init ( struct ima_measure_rule_entry * entry , char * args , int lsm_rule , int audit_type ) { int result ; if ( entry -> lsm [ lsm_rule ] . rule ) return - EINVAL ; entry -> lsm [ lsm_rule ] . type = audit_type ; result = security_filter_rule_init ( entry -> lsm [ lsm_rule ] . type , Audit_equal , args , & entry -> lsm [ lsm_rule ] . rule ) ; <S2SV_StartBug> return result ; <S2SV_EndBug> }",rule ) ; if ( ! entry -> lsm [ lsm_rule ] . rule ) return - EINVAL ;
276,"static void encode_frame_to_data_rate ( VP8_COMP * cpi , unsigned long * size , unsigned char * dest , unsigned char * dest_end , unsigned int * frame_flags ) { int Q ; int frame_over_shoot_limit ; int frame_under_shoot_limit ; int Loop = 0 ; int loop_count ; VP8_COMMON * cm = & cpi -> common ; int active_worst_qchanged = 0 ; # if ! ( CONFIG_REALTIME_ONLY ) int q_low ; int q_high ; int zbin_oq_high ; int zbin_oq_low = 0 ; int top_index ; int bottom_index ; int overshoot_seen = 0 ; int undershoot_seen = 0 ; # endif int drop_mark = ( int ) ( cpi -> oxcf . drop_frames_water_mark * cpi -> oxcf . optimal_buffer_level / 100 ) ; int drop_mark75 = drop_mark * 2 / 3 ; int drop_mark50 = drop_mark / 4 ; int drop_mark25 = drop_mark / 8 ; vp8_clear_system_state ( ) ; # if CONFIG_MULTITHREAD if ( cpi -> b_lpf_running ) { sem_wait ( & cpi -> h_event_end_lpf ) ; cpi -> b_lpf_running = 0 ; } # endif if ( cpi -> force_next_frame_intra ) { cm -> frame_type = KEY_FRAME ; cpi -> force_next_frame_intra = 0 ; } # if ! ( CONFIG_REALTIME_ONLY ) if ( cpi -> pass == 2 ) { if ( cpi -> common . refresh_alt_ref_frame ) { cpi -> per_frame_bandwidth = cpi -> twopass . gf_bits ; cpi -> target_bandwidth = ( int ) ( cpi -> twopass . gf_bits * cpi -> output_framerate ) ; } } else # endif cpi -> per_frame_bandwidth = ( int ) ( cpi -> target_bandwidth / cpi -> output_framerate ) ; cm -> copy_buffer_to_gf = 0 ; cm -> copy_buffer_to_arf = 0 ; cpi -> mb . zbin_over_quant = 0 ; cpi -> mb . zbin_mode_boost = 0 ; cpi -> mb . zbin_mode_boost_enabled = 1 ; if ( cpi -> pass == 2 ) { if ( cpi -> gfu_boost <= 400 ) { cpi -> mb . zbin_mode_boost_enabled = 0 ; } } if ( cpi -> source_alt_ref_active ) cpi -> common . ref_frame_sign_bias [ ALTREF_FRAME ] = 1 ; else cpi -> common . ref_frame_sign_bias [ ALTREF_FRAME ] = 0 ; if ( ( cm -> current_video_frame == 0 ) || ( cm -> frame_flags & FRAMEFLAGS_KEY ) || ( cpi -> oxcf . auto_key && ( cpi -> frames_since_key % cpi -> key_frame_frequency == 0 ) ) ) { cm -> frame_type = KEY_FRAME ; <S2SV_StartBug> } <S2SV_EndBug> # if CONFIG_MULTI_RES_ENCODING <S2SV_StartBug> if ( cpi -> oxcf . mr_encoder_id ) <S2SV_EndBug> { LOWER_RES_FRAME_INFO * low_res_frame_info <S2SV_StartBug> = ( LOWER_RES_FRAME_INFO * ) cpi -> oxcf . mr_low_res_mode_info ; <S2SV_EndBug> cm -> frame_type = low_res_frame_info -> frame_type ; if ( cm -> frame_type != KEY_FRAME ) { cpi -> mr_low_res_mv_avail = 1 ; cpi -> mr_low_res_mv_avail &= ! ( low_res_frame_info -> is_frame_dropped ) ; if ( cpi -> ref_frame_flags & VP8_LAST_FRAME ) cpi -> mr_low_res_mv_avail &= ( cpi -> current_ref_frames [ LAST_FRAME ] == low_res_frame_info -> low_res_ref_frames [ LAST_FRAME ] ) ; if ( cpi -> ref_frame_flags & VP8_GOLD_FRAME ) cpi -> mr_low_res_mv_avail &= ( cpi -> current_ref_frames [ GOLDEN_FRAME ] == low_res_frame_info -> low_res_ref_frames [ GOLDEN_FRAME ] ) ; <S2SV_StartBug> if ( cpi -> ref_frame_flags & VP8_ALTR_FRAME ) <S2SV_EndBug> <S2SV_StartBug> cpi -> mr_low_res_mv_avail &= ( cpi -> current_ref_frames [ ALTREF_FRAME ] <S2SV_EndBug> == low_res_frame_info -> low_res_ref_frames [ ALTREF_FRAME ] ) ; } } # endif if ( cm -> frame_type == KEY_FRAME ) { int i ; setup_features ( cpi ) ; cpi -> source_alt_ref_active = 0 ; for ( i = 0 ; i < MAX_MODES ; i ++ ) { cpi -> mb . rd_thresh_mult [ i ] = 128 ; <S2SV_StartBug> } <S2SV_EndBug> } # if 0 { cpi -> one_pass_frame_index = cm -> current_video_frame % MAX_LAG_BUFFERS ; cpi -> one_pass_frame_stats [ cpi -> one_pass_frame_index ] . frames_so_far = 0 ; cpi -> one_pass_frame_stats [ cpi -> one_pass_frame_index ] . frame_intra_error = 0.0 ; cpi -> one_pass_frame_stats [ cpi -> one_pass_frame_index ] . frame_coded_error = 0.0 ; cpi -> one_pass_frame_stats [ cpi -> one_pass_frame_index ] . frame_pcnt_inter = 0.0 ; cpi -> one_pass_frame_stats [ cpi -> one_pass_frame_index ] . frame_pcnt_motion = 0.0 ; cpi -> one_pass_frame_stats [ cpi -> one_pass_frame_index ] . frame_mvr = 0.0 ; cpi -> one_pass_frame_stats [ cpi -> one_pass_frame_index ] . frame_mvr_abs = 0.0 ; cpi -> one_pass_frame_stats [ cpi -> one_pass_frame_index ] . frame_mvc = 0.0 ; cpi -> one_pass_frame_stats [ cpi -> one_pass_frame_index ] . frame_mvc_abs = 0.0 ; } # endif update_rd_ref_frame_probs ( cpi ) ; if ( cpi -> drop_frames_allowed ) { if ( ( cpi -> buffer_level > drop_mark ) && ( cpi -> decimation_factor > 0 ) ) cpi -> decimation_factor -- ; if ( cpi -> buffer_level > drop_mark75 && cpi -> decimation_factor > 0 ) cpi -> decimation_factor = 1 ; else if ( cpi -> buffer_level < drop_mark25 && ( cpi -> decimation_factor == 2 || cpi -> decimation_factor == 3 ) ) { cpi -> decimation_factor = 3 ; } else if ( cpi -> buffer_level < drop_mark50 && ( cpi -> decimation_factor == 1 || cpi -> decimation_factor == 2 ) ) { cpi -> decimation_factor = 2 ; } else if ( cpi -> buffer_level < drop_mark75 && ( cpi -> decimation_factor == 0 || cpi -> decimation_factor == 1 ) ) { cpi -> decimation_factor = 1 ; } } if ( cpi -> decimation_factor > 0 ) { switch ( cpi -> decimation_factor ) { case 1 : cpi -> per_frame_bandwidth = cpi -> per_frame_bandwidth * 3 / 2 ; break ; case 2 : cpi -> per_frame_bandwidth = cpi -> per_frame_bandwidth * 5 / 4 ; break ; case 3 : cpi -> per_frame_bandwidth = cpi -> per_frame_bandwidth * 5 / 4 ; break ; } if ( cm -> frame_type == KEY_FRAME ) { cpi -> decimation_count = cpi -> decimation_factor ; } else if ( cpi -> decimation_count > 0 ) { cpi -> decimation_count -- ; cpi -> bits_off_target += cpi -> av_per_frame_bandwidth ; if ( cpi -> bits_off_target > cpi -> oxcf . maximum_buffer_size ) cpi -> bits_off_target = cpi -> oxcf . maximum_buffer_size ; # if CONFIG_MULTI_RES_ENCODING vp8_store_drop_frame_info ( cpi ) ; # endif cm -> current_video_frame ++ ; cpi -> frames_since_key ++ ; cpi -> temporal_pattern_counter ++ ; # if CONFIG_INTERNAL_STATS cpi -> count ++ ; # endif cpi -> buffer_level = cpi -> bits_off_target ; if ( cpi -> oxcf . number_of_layers > 1 ) { unsigned int i ; for ( i = cpi -> current_layer + 1 ; i < cpi -> oxcf . number_of_layers ; i ++ ) { LAYER_CONTEXT * lc = & cpi -> layer_context [ i ] ; lc -> bits_off_target += ( int ) ( lc -> target_bandwidth / lc -> framerate ) ; if ( lc -> bits_off_target > lc -> maximum_buffer_size ) lc -> bits_off_target = lc -> maximum_buffer_size ; lc -> buffer_level = lc -> bits_off_target ; } } return ; } else cpi -> decimation_count = cpi -> decimation_factor ; } else cpi -> decimation_count = 0 ; if ( ! vp8_pick_frame_size ( cpi ) ) { # if CONFIG_MULTI_RES_ENCODING vp8_store_drop_frame_info ( cpi ) ; # endif cm -> current_video_frame ++ ; cpi -> frames_since_key ++ ; cpi -> temporal_pattern_counter ++ ; return ; } if ( ( cpi -> oxcf . end_usage == USAGE_STREAM_FROM_SERVER ) && ( cpi -> buffer_level >= cpi -> oxcf . optimal_buffer_level ) && cpi -> buffered_mode ) { int Adjustment = cpi -> active_worst_quality / 4 ; if ( Adjustment ) { int buff_lvl_step ; if ( cpi -> buffer_level < cpi -> oxcf . maximum_buffer_size ) { buff_lvl_step = ( int ) ( ( cpi -> oxcf . maximum_buffer_size - cpi -> oxcf . optimal_buffer_level ) / Adjustment ) ; if ( buff_lvl_step ) Adjustment = ( int ) ( ( cpi -> buffer_level - cpi -> oxcf . optimal_buffer_level ) / buff_lvl_step ) ; else Adjustment = 0 ; } cpi -> active_worst_quality -= Adjustment ; if ( cpi -> active_worst_quality < cpi -> active_best_quality ) cpi -> active_worst_quality = cpi -> active_best_quality ; } } if ( ( cpi -> pass == 2 ) || ( cpi -> ni_frames > 150 ) ) { vp8_clear_system_state ( ) ; Q = cpi -> active_worst_quality ; if ( cm -> frame_type == KEY_FRAME ) { if ( cpi -> pass == 2 ) { if ( cpi -> gfu_boost > 600 ) cpi -> active_best_quality = kf_low_motion_minq [ Q ] ; else cpi -> active_best_quality = kf_high_motion_minq [ Q ] ; if ( cpi -> this_key_frame_forced ) { if ( cpi -> active_best_quality > cpi -> avg_frame_qindex * 7 / 8 ) cpi -> active_best_quality = cpi -> avg_frame_qindex * 7 / 8 ; else if ( cpi -> active_best_quality < cpi -> avg_frame_qindex >> 2 ) cpi -> active_best_quality = cpi -> avg_frame_qindex >> 2 ; } } else cpi -> active_best_quality = kf_high_motion_minq [ Q ] ; } else if ( cpi -> oxcf . number_of_layers == 1 && ( cm -> refresh_golden_frame || cpi -> common . refresh_alt_ref_frame ) ) { if ( ( cpi -> frames_since_key > 1 ) && ( cpi -> avg_frame_qindex < cpi -> active_worst_quality ) ) { Q = cpi -> avg_frame_qindex ; } if ( ( cpi -> oxcf . end_usage == USAGE_CONSTRAINED_QUALITY ) && ( Q < cpi -> cq_target_quality ) ) { Q = cpi -> cq_target_quality ; } if ( cpi -> pass == 2 ) { if ( cpi -> gfu_boost > 1000 ) cpi -> active_best_quality = gf_low_motion_minq [ Q ] ; else if ( cpi -> gfu_boost < 400 ) cpi -> active_best_quality = gf_high_motion_minq [ Q ] ; else cpi -> active_best_quality = gf_mid_motion_minq [ Q ] ; if ( cpi -> oxcf . end_usage == USAGE_CONSTRAINED_QUALITY ) { cpi -> active_best_quality = cpi -> active_best_quality * 15 / 16 ; } } else cpi -> active_best_quality = gf_high_motion_minq [ Q ] ; } else { cpi -> active_best_quality = inter_minq [ Q ] ; if ( ( cpi -> oxcf . end_usage == USAGE_CONSTRAINED_QUALITY ) && ( cpi -> active_best_quality < cpi -> cq_target_quality ) ) { if ( cpi -> rolling_actual_bits < cpi -> min_frame_bandwidth ) cpi -> active_best_quality = cpi -> oxcf . cq_level ; else cpi -> active_best_quality = cpi -> cq_target_quality ; } } if ( cpi -> oxcf . end_usage == USAGE_STREAM_FROM_SERVER ) { if ( cpi -> buffer_level >= cpi -> oxcf . maximum_buffer_size ) cpi -> active_best_quality = cpi -> best_quality ; else if ( cpi -> buffer_level > cpi -> oxcf . optimal_buffer_level ) { int Fraction = ( int ) ( ( ( cpi -> buffer_level - cpi -> oxcf . optimal_buffer_level ) * 128 ) / ( cpi -> oxcf . maximum_buffer_size - cpi -> oxcf . optimal_buffer_level ) ) ; int min_qadjustment = ( ( cpi -> active_best_quality - cpi -> best_quality ) * Fraction ) / 128 ; cpi -> active_best_quality -= min_qadjustment ; } } } else if ( cpi -> oxcf . end_usage == USAGE_CONSTRAINED_QUALITY ) { if ( ( cm -> frame_type == KEY_FRAME ) || cm -> refresh_golden_frame || cpi -> common . refresh_alt_ref_frame ) { cpi -> active_best_quality = cpi -> best_quality ; } else if ( cpi -> active_best_quality < cpi -> cq_target_quality ) { cpi -> active_best_quality = cpi -> cq_target_quality ; } } if ( cpi -> active_worst_quality > cpi -> worst_quality ) cpi -> active_worst_quality = cpi -> worst_quality ; if ( cpi -> active_best_quality < cpi -> best_quality ) cpi -> active_best_quality = cpi -> best_quality ; if ( cpi -> active_worst_quality < cpi -> active_best_quality ) cpi -> active_worst_quality = cpi -> active_best_quality ; Q = vp8_regulate_q ( cpi , cpi -> this_frame_target ) ; # if ! ( CONFIG_REALTIME_ONLY ) if ( cm -> frame_type == KEY_FRAME ) zbin_oq_high = 0 ; else if ( ( cpi -> oxcf . number_of_layers == 1 ) && ( ( cm -> refresh_alt_ref_frame || ( cm -> refresh_golden_frame && ! cpi -> source_alt_ref_active ) ) ) ) { zbin_oq_high = 16 ; } else zbin_oq_high = ZBIN_OQ_MAX ; # endif if ( cpi -> cyclic_refresh_mode_enabled ) { <S2SV_StartBug> if ( cpi -> current_layer == 0 ) <S2SV_EndBug> cyclic_background_refresh ( cpi , Q , 0 ) ; else disable_segmentation ( cpi ) ; } vp8_compute_frame_size_bounds ( cpi , & frame_under_shoot_limit , & frame_over_shoot_limit ) ; # if ! ( CONFIG_REALTIME_ONLY ) bottom_index = cpi -> active_best_quality ; top_index = cpi -> active_worst_quality ; q_low = cpi -> active_best_quality ; q_high = cpi -> active_worst_quality ; # endif vp8_save_coding_context ( cpi ) ; loop_count = 0 ; <S2SV_StartBug> scale_and_extend_source ( cpi -> un_scaled_source , cpi ) ; <S2SV_EndBug> # if ! ( CONFIG_REALTIME_ONLY ) && CONFIG_POSTPROC && ! ( CONFIG_TEMPORAL_DENOISING ) if ( cpi -> oxcf . noise_sensitivity > 0 ) { unsigned char * src ; int l = 0 ; switch ( cpi -> oxcf . noise_sensitivity ) { case 1 : l = 20 ; break ; case 2 : l = 40 ; break ; case 3 : l = 60 ; break ; case 4 : l = 80 ; break ; case 5 : l = 100 ; break ; case 6 : l = 150 ; break ; } if ( cm -> frame_type == KEY_FRAME ) { <S2SV_StartBug> vp8_de_noise ( cm , cpi -> Source , cpi -> Source , l , 1 , 0 ) ; <S2SV_EndBug> } else { <S2SV_StartBug> vp8_de_noise ( cm , cpi -> Source , cpi -> Source , l , 1 , 0 ) ; <S2SV_EndBug> src = cpi -> Source -> y_buffer ; if ( cpi -> Source -> y_stride < 0 ) { src += cpi -> Source -> y_stride * ( cpi -> Source -> y_height - 1 ) ; } } } # endif # ifdef OUTPUT_YUV_SRC <S2SV_StartBug> vp8_write_yuv_frame ( cpi -> Source ) ; <S2SV_EndBug> # endif do { vp8_clear_system_state ( ) ; vp8_set_quantizer ( cpi , Q ) ; if ( cpi -> common . mb_no_coeff_skip ) { cpi -> prob_skip_false = cpi -> base_skip_false_prob [ Q ] ; if ( cm -> frame_type != KEY_FRAME ) { if ( cpi -> common . refresh_alt_ref_frame ) { if ( cpi -> last_skip_false_probs [ 2 ] != 0 ) cpi -> prob_skip_false = cpi -> last_skip_false_probs [ 2 ] ; } else if ( cpi -> common . refresh_golden_frame ) { if ( cpi -> last_skip_false_probs [ 1 ] != 0 ) cpi -> prob_skip_false = cpi -> last_skip_false_probs [ 1 ] ; } else { if ( cpi -> last_skip_false_probs [ 0 ] != 0 ) cpi -> prob_skip_false = cpi -> last_skip_false_probs [ 0 ] ; } if ( cpi -> prob_skip_false < 5 ) cpi -> prob_skip_false = 5 ; if ( cpi -> prob_skip_false > 250 ) cpi -> prob_skip_false = 250 ; if ( cpi -> oxcf . number_of_layers == 1 && cpi -> is_src_frame_alt_ref ) cpi -> prob_skip_false = 1 ; } # if 0 if ( cpi -> pass != 1 ) { FILE * f = fopen ( ""skip.stt"" , ""a"" ) ; fprintf ( f , ""%d,<S2SV_blank>%d,<S2SV_blank>%4d<S2SV_blank>"" , cpi -> common . refresh_golden_frame , cpi -> common . refresh_alt_ref_frame , cpi -> prob_skip_false ) ; fclose ( f ) ; } # endif } if ( cm -> frame_type == KEY_FRAME ) { if ( resize_key_frame ( cpi ) ) { Q = vp8_regulate_q ( cpi , cpi -> this_frame_target ) ; if ( cpi -> cyclic_refresh_mode_enabled ) { if ( cpi -> current_layer == 0 ) cyclic_background_refresh ( cpi , Q , 0 ) ; else disable_segmentation ( cpi ) ; } <S2SV_StartBug> vp8_set_quantizer ( cpi , Q ) ; <S2SV_EndBug> } vp8_setup_key_frame ( cpi ) ; } # if CONFIG_REALTIME_ONLY & CONFIG_ONTHEFLY_BITPACKING { if ( cpi -> oxcf . error_resilient_mode ) cm -> refresh_entropy_probs = 0 ; if ( cpi -> oxcf . error_resilient_mode & VPX_ERROR_RESILIENT_PARTITIONS ) { if ( cm -> frame_type == KEY_FRAME ) cm -> refresh_entropy_probs = 1 ; } if ( cm -> refresh_entropy_probs == 0 ) { <S2SV_StartBug> vpx_memcpy ( & cm -> lfc , & cm -> fc , sizeof ( cm -> fc ) ) ; <S2SV_EndBug> } vp8_update_coef_context ( cpi ) ; vp8_update_coef_probs ( cpi ) ; vp8_encode_frame ( cpi ) ; } # else <S2SV_StartBug> vp8_encode_frame ( cpi ) ; <S2SV_EndBug> cpi -> projected_frame_size -= vp8_estimate_entropy_savings ( cpi ) ; cpi -> projected_frame_size = ( cpi -> projected_frame_size > 0 ) ? cpi -> projected_frame_size : 0 ; # endif vp8_clear_system_state ( ) ; if ( cpi -> pass != 2 && cpi -> oxcf . auto_key && cm -> frame_type != KEY_FRAME && cpi -> compressor_speed != 2 ) { # if ! ( CONFIG_REALTIME_ONLY ) if ( decide_key_frame ( cpi ) ) { cm -> frame_type = KEY_FRAME ; vp8_pick_frame_size ( cpi ) ; cpi -> source_alt_ref_active = 0 ; setup_features ( cpi ) ; vp8_restore_coding_context ( cpi ) ; Q = vp8_regulate_q ( cpi , cpi -> this_frame_target ) ; vp8_compute_frame_size_bounds ( cpi , & frame_under_shoot_limit , & frame_over_shoot_limit ) ; bottom_index = cpi -> active_best_quality ; top_index = cpi -> active_worst_quality ; q_low = cpi -> active_best_quality ; q_high = cpi -> active_worst_quality ; loop_count ++ ; Loop = 1 ; continue ; } # endif } vp8_clear_system_state ( ) ; if ( frame_over_shoot_limit == 0 ) frame_over_shoot_limit = 1 ; if ( ( ( cpi -> pass != 2 ) || ( cpi -> oxcf . end_usage == USAGE_STREAM_FROM_SERVER ) ) && ( Q == cpi -> active_worst_quality ) && ( cpi -> active_worst_quality < cpi -> worst_quality ) && ( cpi -> projected_frame_size > frame_over_shoot_limit ) ) { int over_size_percent = ( ( cpi -> projected_frame_size - frame_over_shoot_limit ) * 100 ) / frame_over_shoot_limit ; while ( ( cpi -> active_worst_quality < cpi -> worst_quality ) && ( over_size_percent > 0 ) ) { cpi -> active_worst_quality ++ ; over_size_percent = ( int ) ( over_size_percent * 0.96 ) ; } # if ! ( CONFIG_REALTIME_ONLY ) top_index = cpi -> active_worst_quality ; # endif active_worst_qchanged = 1 ; } else active_worst_qchanged = 0 ; # if ! ( CONFIG_REALTIME_ONLY ) if ( ( cm -> frame_type == KEY_FRAME ) && cpi -> this_key_frame_forced ) { int last_q = Q ; int kf_err = vp8_calc_ss_err ( cpi -> Source , & cm -> yv12_fb [ cm -> new_fb_idx ] ) ; if ( kf_err > ( ( cpi -> ambient_err * 7 ) >> 3 ) ) { q_high = ( Q > q_low ) ? ( Q - 1 ) : q_low ; Q = ( q_high + q_low ) >> 1 ; } else if ( kf_err < ( cpi -> ambient_err >> 1 ) ) { q_low = ( Q < q_high ) ? ( Q + 1 ) : q_high ; Q = ( q_high + q_low + 1 ) >> 1 ; } if ( Q > q_high ) Q = q_high ; else if ( Q < q_low ) Q = q_low ; Loop = Q != last_q ; } else if ( recode_loop_test ( cpi , frame_over_shoot_limit , frame_under_shoot_limit , Q , top_index , bottom_index ) ) { int last_q = Q ; int Retries = 0 ; if ( cpi -> projected_frame_size > cpi -> this_frame_target ) { q_low = ( Q < q_high ) ? ( Q + 1 ) : q_high ; if ( cpi -> mb . zbin_over_quant > 0 ) zbin_oq_low = ( cpi -> mb . zbin_over_quant < zbin_oq_high ) ? ( cpi -> mb . zbin_over_quant + 1 ) : zbin_oq_high ; if ( undershoot_seen ) { if ( ! active_worst_qchanged ) vp8_update_rate_correction_factors ( cpi , 1 ) ; Q = ( q_high + q_low + 1 ) / 2 ; if ( Q < MAXQ ) cpi -> mb . zbin_over_quant = 0 ; else { zbin_oq_low = ( cpi -> mb . zbin_over_quant < zbin_oq_high ) ? ( cpi -> mb . zbin_over_quant + 1 ) : zbin_oq_high ; cpi -> mb . zbin_over_quant = ( zbin_oq_high + zbin_oq_low ) / 2 ; } } else { if ( ! active_worst_qchanged ) vp8_update_rate_correction_factors ( cpi , 0 ) ; Q = vp8_regulate_q ( cpi , cpi -> this_frame_target ) ; while ( ( ( Q < q_low ) || ( cpi -> mb . zbin_over_quant < zbin_oq_low ) ) && ( Retries < 10 ) ) { vp8_update_rate_correction_factors ( cpi , 0 ) ; Q = vp8_regulate_q ( cpi , cpi -> this_frame_target ) ; Retries ++ ; } } overshoot_seen = 1 ; } else { if ( cpi -> mb . zbin_over_quant == 0 ) q_high = ( Q > q_low ) ? ( Q - 1 ) : q_low ; else zbin_oq_high = ( cpi -> mb . zbin_over_quant > zbin_oq_low ) ? ( cpi -> mb . zbin_over_quant - 1 ) : zbin_oq_low ; if ( overshoot_seen ) { if ( ! active_worst_qchanged ) vp8_update_rate_correction_factors ( cpi , 1 ) ; Q = ( q_high + q_low ) / 2 ; if ( Q < MAXQ ) cpi -> mb . zbin_over_quant = 0 ; else cpi -> mb . zbin_over_quant = ( zbin_oq_high + zbin_oq_low ) / 2 ; } else { if ( ! active_worst_qchanged ) vp8_update_rate_correction_factors ( cpi , 0 ) ; Q = vp8_regulate_q ( cpi , cpi -> this_frame_target ) ; if ( ( cpi -> oxcf . end_usage == USAGE_CONSTRAINED_QUALITY ) && ( Q < q_low ) ) { q_low = Q ; } while ( ( ( Q > q_high ) || ( cpi -> mb . zbin_over_quant > zbin_oq_high ) ) && ( Retries < 10 ) ) { vp8_update_rate_correction_factors ( cpi , 0 ) ; Q = vp8_regulate_q ( cpi , cpi -> this_frame_target ) ; Retries ++ ; } } undershoot_seen = 1 ; } if ( Q > q_high ) Q = q_high ; else if ( Q < q_low ) Q = q_low ; cpi -> mb . zbin_over_quant = ( cpi -> mb . zbin_over_quant < zbin_oq_low ) ? zbin_oq_low : ( cpi -> mb . zbin_over_quant > zbin_oq_high ) ? zbin_oq_high : cpi -> mb . zbin_over_quant ; Loop = Q != last_q ; } else # endif Loop = 0 ; if ( cpi -> is_src_frame_alt_ref ) Loop = 0 ; if ( Loop == 1 ) { vp8_restore_coding_context ( cpi ) ; loop_count ++ ; # if CONFIG_INTERNAL_STATS cpi -> tot_recode_hits ++ ; # endif } } while ( Loop == 1 ) ; # if 0 { cpi -> one_pass_frame_stats [ cpi -> one_pass_frame_index ] . frame_coded_error = ( double ) cpi -> prediction_error ; cpi -> one_pass_frame_stats [ cpi -> one_pass_frame_index ] . frame_intra_error = ( double ) cpi -> intra_error ; cpi -> one_pass_frame_stats [ cpi -> one_pass_frame_index ] . frame_pcnt_inter = ( double ) ( 100 - cpi -> this_frame_percent_intra ) / 100.0 ; } # endif if ( cpi -> next_key_frame_forced && ( cpi -> twopass . frames_to_key == 0 ) ) { cpi -> ambient_err = vp8_calc_ss_err ( cpi -> Source , & cm -> yv12_fb [ cm -> new_fb_idx ] ) ; } # if CONFIG_MULTI_RES_ENCODING if ( ! cpi -> oxcf . mr_encoder_id && cm -> show_frame ) # else if ( cm -> show_frame ) # endif { int mb_row ; int mb_col ; MODE_INFO * tmp = cm -> mip ; if ( cm -> frame_type != KEY_FRAME ) { for ( mb_row = 0 ; mb_row < cm -> mb_rows + 1 ; mb_row ++ ) { for ( mb_col = 0 ; mb_col < cm -> mb_cols + 1 ; mb_col ++ ) { if ( tmp -> mbmi . ref_frame != INTRA_FRAME ) cpi -> lfmv [ mb_col + mb_row * ( cm -> mode_info_stride + 1 ) ] . as_int = tmp -> mbmi . mv . as_int ; cpi -> lf_ref_frame_sign_bias [ mb_col + mb_row * ( cm -> mode_info_stride + 1 ) ] = cm -> ref_frame_sign_bias [ tmp -> mbmi . ref_frame ] ; cpi -> lf_ref_frame [ mb_col + mb_row * ( cm -> mode_info_stride + 1 ) ] = tmp -> mbmi . ref_frame ; tmp ++ ; } } } } { int mb_row ; int mb_col ; MODE_INFO * tmp = cm -> mi ; cpi -> zeromv_count = 0 ; if ( cm -> frame_type != KEY_FRAME ) { for ( mb_row = 0 ; mb_row < cm -> mb_rows ; mb_row ++ ) { for ( mb_col = 0 ; mb_col < cm -> mb_cols ; mb_col ++ ) { <S2SV_StartBug> if ( tmp -> mbmi . mode == ZEROMV ) <S2SV_EndBug> cpi -> zeromv_count ++ ; tmp ++ ; } tmp ++ ; } } } # if CONFIG_MULTI_RES_ENCODING vp8_cal_dissimilarity ( cpi ) ; # endif if ( cpi -> oxcf . number_of_layers == 1 ) vp8_update_gf_useage_maps ( cpi , cm , & cpi -> mb ) ; if ( cm -> frame_type == KEY_FRAME ) cm -> refresh_last_frame = 1 ; # if 0 { FILE * f = fopen ( ""gfactive.stt"" , ""a"" ) ; fprintf ( f , ""%8d<S2SV_blank>%8d<S2SV_blank>%8d<S2SV_blank>%8d<S2SV_blank>%8d\\n"" , cm -> current_video_frame , ( 100 * cpi -> gf_active_count ) / ( cpi -> common . mb_rows * cpi -> common . mb_cols ) , cpi -> this_iiratio , cpi -> next_iiratio , cm -> refresh_golden_frame ) ; fclose ( f ) ; } # endif if ( ! cpi -> oxcf . error_resilient_mode && cm -> refresh_golden_frame ) cm -> copy_buffer_to_arf = 2 ; else cm -> copy_buffer_to_arf = 0 ; cm -> frame_to_show = & cm -> yv12_fb [ cm -> new_fb_idx ] ; <S2SV_StartBug> # if CONFIG_MULTITHREAD <S2SV_EndBug> if ( cpi -> b_multi_threaded ) { <S2SV_StartBug> sem_post ( & cpi -> h_event_start_lpf ) ; <S2SV_EndBug> cpi -> b_lpf_running = 1 ; } else # endif { vp8_loopfilter_frame ( cpi , cm ) ; } <S2SV_StartBug> update_reference_frames ( cpi ) ; <S2SV_EndBug> # if ! ( CONFIG_REALTIME_ONLY & CONFIG_ONTHEFLY_BITPACKING ) if ( cpi -> oxcf . error_resilient_mode ) { cm -> refresh_entropy_probs = 0 ; } # endif # if CONFIG_MULTITHREAD if ( cpi -> b_multi_threaded ) sem_wait ( & cpi -> h_event_end_lpf ) ; # endif vp8_pack_bitstream ( cpi , dest , dest_end , size ) ; # if CONFIG_MULTITHREAD if ( cpi -> b_lpf_running && cpi -> b_calculate_psnr ) { sem_wait ( & cpi -> h_event_end_lpf ) ; cpi -> b_lpf_running = 0 ; } # endif cm -> last_frame_type = cm -> frame_type ; cpi -> total_byte_count += ( * size ) ; cpi -> projected_frame_size = ( * size ) << 3 ; if ( cpi -> oxcf . number_of_layers > 1 ) { unsigned int i ; for ( i = cpi -> current_layer + 1 ; i < cpi -> oxcf . number_of_layers ; i ++ ) cpi -> layer_context [ i ] . total_byte_count += ( * size ) ; } if ( ! active_worst_qchanged ) vp8_update_rate_correction_factors ( cpi , 2 ) ; cpi -> last_q [ cm -> frame_type ] = cm -> base_qindex ; if ( cm -> frame_type == KEY_FRAME ) { vp8_adjust_key_frame_context ( cpi ) ; } if ( cm -> frame_type != KEY_FRAME ) cpi -> avg_frame_qindex = ( 2 + 3 * cpi -> avg_frame_qindex + cm -> base_qindex ) >> 2 ; if ( ( cm -> frame_type != KEY_FRAME ) && ( ( cpi -> oxcf . number_of_layers > 1 ) || ( ! cm -> refresh_golden_frame && ! cm -> refresh_alt_ref_frame ) ) ) { cpi -> ni_frames ++ ; if ( cpi -> pass == 2 ) { cpi -> ni_tot_qi += Q ; cpi -> ni_av_qi = ( cpi -> ni_tot_qi / cpi -> ni_frames ) ; } else { if ( cpi -> ni_frames > 150 ) { cpi -> ni_tot_qi += Q ; cpi -> ni_av_qi = ( cpi -> ni_tot_qi / cpi -> ni_frames ) ; } else { cpi -> ni_tot_qi += Q ; cpi -> ni_av_qi = ( ( cpi -> ni_tot_qi / cpi -> ni_frames ) + cpi -> worst_quality + 1 ) / 2 ; } if ( Q > cpi -> ni_av_qi ) cpi -> ni_av_qi = Q - 1 ; } } if ( ! cm -> show_frame ) cpi -> bits_off_target -= cpi -> projected_frame_size ; else cpi -> bits_off_target += cpi -> av_per_frame_bandwidth - cpi -> projected_frame_size ; if ( cpi -> bits_off_target > cpi -> oxcf . maximum_buffer_size ) <S2SV_StartBug> cpi -> bits_off_target = cpi -> oxcf . maximum_buffer_size ; <S2SV_EndBug> cpi -> rolling_target_bits = ( ( cpi -> rolling_target_bits * 3 ) + cpi -> this_frame_target + 2 ) / 4 ; cpi -> rolling_actual_bits = ( ( cpi -> rolling_actual_bits * 3 ) + cpi -> projected_frame_size + 2 ) / 4 ; cpi -> long_rolling_target_bits = ( ( cpi -> long_rolling_target_bits * 31 ) + cpi -> this_frame_target + 16 ) / 32 ; cpi -> long_rolling_actual_bits = ( ( cpi -> long_rolling_actual_bits * 31 ) + cpi -> projected_frame_size + 16 ) / 32 ; cpi -> total_actual_bits += cpi -> projected_frame_size ; cpi -> total_target_vs_actual += ( cpi -> this_frame_target - cpi -> projected_frame_size ) ; cpi -> buffer_level = cpi -> bits_off_target ; if ( cpi -> oxcf . number_of_layers > 1 ) { unsigned int i ; for ( i = cpi -> current_layer + 1 ; i < cpi -> oxcf . number_of_layers ; i ++ ) { LAYER_CONTEXT * lc = & cpi -> layer_context [ i ] ; int bits_off_for_this_layer = ( int ) ( lc -> target_bandwidth / lc -> framerate - cpi -> projected_frame_size ) ; lc -> bits_off_target += bits_off_for_this_layer ; if ( lc -> bits_off_target > lc -> maximum_buffer_size ) lc -> bits_off_target = lc -> maximum_buffer_size ; lc -> total_actual_bits += cpi -> projected_frame_size ; lc -> total_target_vs_actual += bits_off_for_this_layer ; lc -> buffer_level = lc -> bits_off_target ; } } if ( cm -> frame_type == KEY_FRAME ) { cpi -> twopass . kf_group_bits += cpi -> this_frame_target - cpi -> projected_frame_size ; if ( cpi -> twopass . kf_group_bits < 0 ) cpi -> twopass . kf_group_bits = 0 ; } else if ( cm -> refresh_golden_frame || cm -> refresh_alt_ref_frame ) { cpi -> twopass . gf_group_bits += cpi -> this_frame_target - cpi -> projected_frame_size ; if ( cpi -> twopass . gf_group_bits < 0 ) cpi -> twopass . gf_group_bits = 0 ; } if ( cm -> frame_type != KEY_FRAME ) { if ( cpi -> common . refresh_alt_ref_frame ) { cpi -> last_skip_false_probs [ 2 ] = cpi -> prob_skip_false ; cpi -> last_skip_probs_q [ 2 ] = cm -> base_qindex ; } else if ( cpi -> common . refresh_golden_frame ) { cpi -> last_skip_false_probs [ 1 ] = cpi -> prob_skip_false ; cpi -> last_skip_probs_q [ 1 ] = cm -> base_qindex ; } else { cpi -> last_skip_false_probs [ 0 ] = cpi -> prob_skip_false ; cpi -> last_skip_probs_q [ 0 ] = cm -> base_qindex ; cpi -> base_skip_false_prob [ cm -> base_qindex ] = cpi -> prob_skip_false ; } } # if 0 && CONFIG_INTERNAL_STATS { FILE * f = fopen ( ""tmp.stt"" , ""a"" ) ; vp8_clear_system_state ( ) ; if ( cpi -> twopass . total_left_stats . coded_error != 0.0 ) fprintf ( f , ""%10d<S2SV_blank>%10d<S2SV_blank>%10d<S2SV_blank>%10d<S2SV_blank>%10d<S2SV_blank>%10"" PRId64 ""<S2SV_blank>%10"" PRId64 ""%10"" PRId64 ""<S2SV_blank>%10d<S2SV_blank>%6d<S2SV_blank>%6d<S2SV_blank>%6d<S2SV_blank>%6d<S2SV_blank>%5d<S2SV_blank>%5d<S2SV_blank>%5d<S2SV_blank>%8d<S2SV_blank>"" ""%8.2lf<S2SV_blank>%"" PRId64 ""<S2SV_blank>%10.3lf<S2SV_blank>%10"" PRId64 ""<S2SV_blank>%8d\\n"" , cpi -> common . current_video_frame , cpi -> this_frame_target , cpi -> projected_frame_size , ( cpi -> projected_frame_size - cpi -> this_frame_target ) , cpi -> total_target_vs_actual , cpi -> buffer_level , ( cpi -> oxcf . starting_buffer_level - cpi -> bits_off_target ) , cpi -> total_actual_bits , cm -> base_qindex , cpi -> active_best_quality , cpi -> active_worst_quality , cpi -> ni_av_qi , cpi -> cq_target_quality , cm -> refresh_golden_frame , cm -> refresh_alt_ref_frame , cm -> frame_type , cpi -> gfu_boost , cpi -> twopass . est_max_qcorrection_factor , cpi -> twopass . bits_left , cpi -> twopass . total_left_stats . coded_error , ( double ) cpi -> twopass . bits_left / cpi -> twopass . total_left_stats . coded_error , cpi -> tot_recode_hits ) ; else fprintf ( f , ""%10d<S2SV_blank>%10d<S2SV_blank>%10d<S2SV_blank>%10d<S2SV_blank>%10d<S2SV_blank>%10"" PRId64 ""<S2SV_blank>%10"" PRId64 ""%10"" PRId64 ""<S2SV_blank>%10d<S2SV_blank>%6d<S2SV_blank>%6d<S2SV_blank>%6d<S2SV_blank>%6d<S2SV_blank>%5d<S2SV_blank>%5d<S2SV_blank>%5d<S2SV_blank>%8d<S2SV_blank>"" ""%8.2lf<S2SV_blank>%"" PRId64 ""<S2SV_blank>%10.3lf<S2SV_blank>%8d\\n"" , cpi -> common . current_video_frame , cpi -> this_frame_target , cpi -> projected_frame_size , ( cpi -> projected_frame_size - cpi -> this_frame_target ) , cpi -> total_target_vs_actual , cpi -> buffer_level , ( cpi -> oxcf . starting_buffer_level - cpi -> bits_off_target ) , cpi -> total_actual_bits , cm -> base_qindex , cpi -> active_best_quality , cpi -> active_worst_quality , cpi -> ni_av_qi , cpi -> cq_target_quality , cm -> refresh_golden_frame , cm -> refresh_alt_ref_frame , cm -> frame_type , cpi -> gfu_boost , cpi -> twopass . est_max_qcorrection_factor , cpi -> twopass . bits_left , cpi -> twopass . total_left_stats . coded_error , cpi -> tot_recode_hits ) ; fclose ( f ) ; { FILE * fmodes = fopen ( ""Modes.stt"" , ""a"" ) ; fprintf ( fmodes , ""%6d:%1d:%1d:%1d<S2SV_blank>"" , cpi -> common . current_video_frame , cm -> frame_type , cm -> refresh_golden_frame , cm -> refresh_alt_ref_frame ) ; fprintf ( fmodes , ""\\n"" ) ; fclose ( fmodes ) ; } } # endif if ( cm -> refresh_golden_frame == 1 ) cm -> frame_flags = cm -> frame_flags | FRAMEFLAGS_GOLDEN ; else cm -> frame_flags = cm -> frame_flags & ~ FRAMEFLAGS_GOLDEN ; if ( cm -> refresh_alt_ref_frame == 1 ) cm -> frame_flags = cm -> frame_flags | FRAMEFLAGS_ALTREF ; else cm -> frame_flags = cm -> frame_flags & ~ FRAMEFLAGS_ALTREF ; if ( cm -> refresh_last_frame & cm -> refresh_golden_frame ) cpi -> gold_is_last = 1 ; else if ( cm -> refresh_last_frame ^ cm -> refresh_golden_frame ) cpi -> gold_is_last = 0 ; if ( cm -> refresh_last_frame & cm -> refresh_alt_ref_frame ) cpi -> alt_is_last = 1 ; else if ( cm -> refresh_last_frame ^ cm -> refresh_alt_ref_frame ) cpi -> alt_is_last = 0 ; if ( cm -> refresh_alt_ref_frame & cm -> refresh_golden_frame ) cpi -> gold_is_alt = 1 ; else if ( cm -> refresh_alt_ref_frame ^ cm -> refresh_golden_frame ) cpi -> gold_is_alt = 0 ; cpi -> ref_frame_flags = VP8_ALTR_FRAME | VP8_GOLD_FRAME | VP8_LAST_FRAME ; if ( cpi -> gold_is_last ) cpi -> ref_frame_flags &= ~ VP8_GOLD_FRAME ; if ( cpi -> alt_is_last ) cpi -> ref_frame_flags &= ~ VP8_ALTR_FRAME ; if ( cpi -> gold_is_alt ) cpi -> ref_frame_flags &= ~ VP8_ALTR_FRAME ; if ( ! cpi -> oxcf . error_resilient_mode ) { if ( cpi -> oxcf . play_alternate && cm -> refresh_alt_ref_frame && ( cm -> frame_type != KEY_FRAME ) ) update_alt_ref_frame_stats ( cpi ) ; else update_golden_frame_stats ( cpi ) ; } if ( cm -> frame_type == KEY_FRAME ) { * frame_flags = cm -> frame_flags | FRAMEFLAGS_KEY ; cm -> frame_type = INTER_FRAME ; cpi -> last_frame_percent_intra = 100 ; } else { * frame_flags = cm -> frame_flags & ~ FRAMEFLAGS_KEY ; cpi -> last_frame_percent_intra = cpi -> this_frame_percent_intra ; } cpi -> mb . e_mbd . update_mb_segmentation_map = 0 ; cpi -> mb . e_mbd . update_mb_segmentation_data = 0 ; cpi -> mb . e_mbd . mode_ref_lf_delta_update = 0 ; if ( cm -> show_frame ) { cm -> current_video_frame ++ ; cpi -> frames_since_key ++ ; cpi -> temporal_pattern_counter ++ ; } # if 0 { char filename [ 512 ] ; FILE * recon_file ; sprintf ( filename , ""enc%04d.yuv"" , ( int ) cm -> current_video_frame ) ; recon_file = fopen ( filename , ""wb"" ) ; fwrite ( cm -> yv12_fb [ cm -> lst_fb_idx ] . buffer_alloc , cm -> yv12_fb [ cm -> lst_fb_idx ] . frame_size , 1 , recon_file ) ; fclose ( recon_file ) ; } # endif }","= KEY_FRAME ; # if CONFIG_TEMPORAL_DENOISING if ( cpi -> oxcf . noise_sensitivity == 4 ) { vp8_denoiser_set_parameters ( & cpi -> denoiser , kDenoiserOnYUV ) ; } # endif } # if <S2SV_ModEnd> CONFIG_MULTI_RES_ENCODING if ( <S2SV_ModStart> -> oxcf . mr_total_resolutions > 1 ) <S2SV_ModEnd> { LOWER_RES_FRAME_INFO * <S2SV_ModStart> . mr_low_res_mode_info ; if ( cpi -> oxcf . mr_encoder_id ) { <S2SV_ModStart> ] ) ; } } if ( cm -> frame_type == KEY_FRAME ) { if ( cpi -> oxcf . mr_encoder_id ) { if ( cpi -> common . current_video_frame == 0 && cpi -> buffer_level == 0 ) { unsigned int i ; cpi -> bits_off_target = cpi -> oxcf . starting_buffer_level ; cpi -> buffer_level = cpi -> oxcf . starting_buffer_level ; for ( i = 0 ; i < cpi -> oxcf . number_of_layers ; i ++ ) { LAYER_CONTEXT * lc = & cpi -> layer_context [ i ] ; lc -> bits_off_target = lc -> starting_buffer_level ; lc -> buffer_level = lc -> starting_buffer_level ; } } cpi -> common . current_video_frame = low_res_frame_info -> key_frame_counter_value ; } else { low_res_frame_info -> key_frame_counter_value = cpi -> common . current_video_frame ; } } } # endif cpi -> closest_reference_frame = LAST_FRAME ; if ( cm -> frame_type != KEY_FRAME ) { int i ; MV_REFERENCE_FRAME closest_ref = INTRA_FRAME ; if ( cpi -> ref_frame_flags & VP8_LAST_FRAME ) { closest_ref = LAST_FRAME ; } else if ( cpi -> ref_frame_flags & VP8_GOLD_FRAME ) { closest_ref = GOLDEN_FRAME ; } else <S2SV_ModStart> & VP8_ALTR_FRAME ) { closest_ref = ALTREF_FRAME ; } for ( i = 1 ; i <= 3 ; i ++ ) { vpx_ref_frame_type_t ref_frame_type = ( vpx_ref_frame_type_t ) ( ( i == 3 ) ? 4 : i ) ; if ( cpi -> ref_frame_flags & ref_frame_type ) { if ( ( cm -> current_video_frame - <S2SV_ModEnd> cpi -> current_ref_frames <S2SV_ModStart> -> current_ref_frames [ i ] ) < ( cm -> current_video_frame - cpi -> current_ref_frames [ closest_ref ] ) ) { closest_ref = i ; } } } cpi -> closest_reference_frame = closest_ref ; } <S2SV_ModEnd> if ( cm <S2SV_ModStart> 128 ; } memset ( cpi -> consec_zero_last , 0 , cm -> mb_rows * cm -> mb_cols ) ; memset ( cpi -> consec_zero_last_mvbias , 0 , ( cpi -> common . mb_rows * cpi -> common . mb_cols ) ) ; <S2SV_ModStart> cyclic_refresh_mode_enabled ) { int disable_cr_gf = ( cpi -> oxcf . screen_content_mode == 2 && cm -> refresh_golden_frame ) ; <S2SV_ModStart> current_layer == 0 && cpi -> force_maxqp == 0 && ! disable_cr_gf <S2SV_ModStart> cpi ) ; # if CONFIG_TEMPORAL_DENOISING && CONFIG_POSTPROC if ( cpi -> oxcf . noise_sensitivity >= 3 ) { if ( cpi -> denoiser . denoise_pars . spatial_blur != 0 ) { vp8_de_noise ( cm , cpi -> Source , cpi -> Source , cpi -> denoiser . denoise_pars . spatial_blur , 1 , 0 , 0 ) ; } } # endif <S2SV_ModStart> 1 , 0 , 1 <S2SV_ModStart> 1 , 0 , 1 <S2SV_ModStart> OUTPUT_YUV_SRC vp8_write_yuv_frame ( yuv_file , <S2SV_ModStart> ) ; } memset ( cpi -> consec_zero_last , 0 , cm -> mb_rows * cm -> mb_cols ) ; memset ( cpi -> consec_zero_last_mvbias , 0 , ( cpi -> common . mb_rows * cpi -> common . mb_cols ) ) ; <S2SV_ModStart> 0 ) { memcpy <S2SV_ModEnd> ( & cm <S2SV_ModStart> cpi ) ; if ( cpi -> oxcf . screen_content_mode == 2 ) { if ( vp8_drop_encodedframe_overshoot ( cpi , Q ) ) return ; } <S2SV_ModStart> mode == ZEROMV && tmp -> mbmi . ref_frame == LAST_FRAME <S2SV_ModStart> ; # if CONFIG_TEMPORAL_DENOISING if ( cpi -> oxcf . noise_sensitivity > 0 && cpi -> oxcf . noise_sensitivity < 4 && ! cpi -> oxcf . screen_content_mode && cpi -> frames_since_key % 8 == 0 && cm -> frame_type != KEY_FRAME ) { cpi -> mse_source_denoised = measure_square_diff_partial ( <S2SV_ModEnd> & cpi -> <S2SV_ModStart> & cpi -> denoiser . yv12_running_avg [ INTRA_FRAME ] , cpi -> Source , cpi ) ; } if ( cpi -> oxcf . noise_sensitivity == 4 && ! cpi -> oxcf . screen_content_mode && cpi -> frames_since_key % 8 == 0 && cm -> frame_type != KEY_FRAME ) { process_denoiser_mode_change ( cpi ) ; } # endif # if CONFIG_MULTITHREAD if ( cpi -> b_multi_threaded ) { sem_post ( & cpi -> h_event_start_lpf ) ; cpi -> b_lpf_running = 1 ; } else # endif <S2SV_ModEnd> { vp8_loopfilter_frame ( <S2SV_ModStart> cpi ) ; # ifdef OUTPUT_YUV_DENOISED vp8_write_yuv_frame ( yuv_denoised_file , & cpi -> denoiser . yv12_running_avg [ INTRA_FRAME ] ) ; # endif <S2SV_ModStart> -> bits_off_target = cpi -> oxcf . maximum_buffer_size ; if ( cpi -> drop_frames_allowed == 0 && cpi -> oxcf . screen_content_mode && cpi -> bits_off_target < - cpi -> oxcf . maximum_buffer_size ) cpi -> bits_off_target = -"
277,"long keyctl_chown_key ( key_serial_t id , uid_t user , gid_t group ) { struct key_user * newowner , * zapowner = NULL ; struct key * key ; key_ref_t key_ref ; long ret ; kuid_t uid ; kgid_t gid ; uid = make_kuid ( current_user_ns ( ) , user ) ; gid = make_kgid ( current_user_ns ( ) , group ) ; ret = - EINVAL ; if ( ( user != ( uid_t ) - 1 ) && ! uid_valid ( uid ) ) goto error ; if ( ( group != ( gid_t ) - 1 ) && ! gid_valid ( gid ) ) goto error ; ret = 0 ; if ( user == ( uid_t ) - 1 && group == ( gid_t ) - 1 ) goto error ; key_ref = lookup_user_key ( id , KEY_LOOKUP_CREATE | KEY_LOOKUP_PARTIAL , KEY_NEED_SETATTR ) ; if ( IS_ERR ( key_ref ) ) { ret = PTR_ERR ( key_ref ) ; goto error ; } key = key_ref_to_ptr ( key_ref ) ; ret = - EACCES ; down_write ( & key -> sem ) ; if ( ! capable ( CAP_SYS_ADMIN ) ) { if ( user != ( uid_t ) - 1 && ! uid_eq ( key -> uid , uid ) ) goto error_put ; if ( group != ( gid_t ) - 1 && ! gid_eq ( gid , key -> gid ) && ! in_group_p ( gid ) ) goto error_put ; } if ( user != ( uid_t ) - 1 && ! uid_eq ( uid , key -> uid ) ) { ret = - ENOMEM ; newowner = key_user_lookup ( uid ) ; if ( ! newowner ) goto error_put ; if ( test_bit ( KEY_FLAG_IN_QUOTA , & key -> flags ) ) { unsigned maxkeys = uid_eq ( uid , GLOBAL_ROOT_UID ) ? key_quota_root_maxkeys : key_quota_maxkeys ; unsigned maxbytes = uid_eq ( uid , GLOBAL_ROOT_UID ) ? key_quota_root_maxbytes : key_quota_maxbytes ; spin_lock ( & newowner -> lock ) ; if ( newowner -> qnkeys + 1 >= maxkeys || newowner -> qnbytes + key -> quotalen >= maxbytes || newowner -> qnbytes + key -> quotalen < newowner -> qnbytes ) goto quota_overrun ; newowner -> qnkeys ++ ; newowner -> qnbytes += key -> quotalen ; spin_unlock ( & newowner -> lock ) ; spin_lock ( & key -> user -> lock ) ; key -> user -> qnkeys -- ; key -> user -> qnbytes -= key -> quotalen ; spin_unlock ( & key -> user -> lock ) ; } atomic_dec ( & key -> user -> nkeys ) ; atomic_inc ( & newowner -> nkeys ) ; <S2SV_StartBug> if ( test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) ) { <S2SV_EndBug> atomic_dec ( & key -> user -> nikeys ) ; atomic_inc ( & newowner -> nikeys ) ; } zapowner = key -> user ; key -> user = newowner ; key -> uid = uid ; } if ( group != ( gid_t ) - 1 ) key -> gid = gid ; ret = 0 ; error_put : up_write ( & key -> sem ) ; key_put ( key ) ; if ( zapowner ) key_user_put ( zapowner ) ; error : return ret ; quota_overrun : spin_unlock ( & newowner -> lock ) ; zapowner = newowner ; ret = - EDQUOT ; goto error_put ; }",; if ( key -> state != KEY_IS_UNINSTANTIATED <S2SV_ModEnd> ) { atomic_dec
278,"Bool rfbOptPamAuth ( void ) { SecTypeData * s ; for ( s = secTypes ; s -> name != NULL ; s ++ ) { if ( ( ! strcmp ( s -> name , ""unixlogin"" ) || <S2SV_StartBug> ! strcmp ( & s -> name [ strlen ( s -> name ) - 5 ] , ""plain"" ) ) && s -> enabled ) <S2SV_EndBug> return TRUE ; } return FALSE ; }","""unixlogin"" ) || strstr <S2SV_ModEnd> ( s -> <S2SV_ModStart> s -> name <S2SV_ModEnd> , ""plain"" )"
279,"int btrfs_search_slot ( struct btrfs_trans_handle * trans , struct btrfs_root * root , struct btrfs_key * key , struct btrfs_path * p , int ins_len , int cow ) { struct extent_buffer * b ; int slot ; int ret ; int err ; int level ; int lowest_unlock = 1 ; int root_lock ; int write_lock_level = 0 ; u8 lowest_level = 0 ; int min_write_lock_level ; int prev_cmp ; lowest_level = p -> lowest_level ; WARN_ON ( lowest_level && ins_len > 0 ) ; WARN_ON ( p -> nodes [ 0 ] != NULL ) ; BUG_ON ( ! cow && ins_len ) ; if ( ins_len < 0 ) { lowest_unlock = 2 ; write_lock_level = 2 ; } else if ( ins_len > 0 ) { write_lock_level = 1 ; } if ( ! cow ) write_lock_level = - 1 ; if ( cow && ( p -> keep_locks || p -> lowest_level ) ) write_lock_level = BTRFS_MAX_LEVEL ; min_write_lock_level = write_lock_level ; again : prev_cmp = - 1 ; root_lock = BTRFS_READ_LOCK ; level = 0 ; if ( p -> search_commit_root ) { if ( p -> need_commit_sem ) down_read ( & root -> fs_info -> commit_root_sem ) ; b = root -> commit_root ; extent_buffer_get ( b ) ; level = btrfs_header_level ( b ) ; if ( p -> need_commit_sem ) up_read ( & root -> fs_info -> commit_root_sem ) ; if ( ! p -> skip_locking ) btrfs_tree_read_lock ( b ) ; } else { if ( p -> skip_locking ) { b = btrfs_root_node ( root ) ; level = btrfs_header_level ( b ) ; } else { b = btrfs_read_lock_root_node ( root ) ; level = btrfs_header_level ( b ) ; if ( level <= write_lock_level ) { btrfs_tree_read_unlock ( b ) ; free_extent_buffer ( b ) ; b = btrfs_lock_root_node ( root ) ; root_lock = BTRFS_WRITE_LOCK ; level = btrfs_header_level ( b ) ; } } } p -> nodes [ level ] = b ; if ( ! p -> skip_locking ) p -> locks [ level ] = root_lock ; while ( b ) { level = btrfs_header_level ( b ) ; if ( cow ) { if ( ! should_cow_block ( trans , root , b ) ) goto cow_done ; if ( level > write_lock_level || ( level + 1 > write_lock_level && level + 1 < BTRFS_MAX_LEVEL && p -> nodes [ level + 1 ] ) ) { write_lock_level = level + 1 ; btrfs_release_path ( p ) ; goto again ; } btrfs_set_path_blocking ( p ) ; err = btrfs_cow_block ( trans , root , b , p -> nodes [ level + 1 ] , p -> slots [ level + 1 ] , & b ) ; if ( err ) { ret = err ; goto done ; } } cow_done : p -> nodes [ level ] = b ; btrfs_clear_path_blocking ( p , NULL , 0 ) ; if ( ! ins_len && ! p -> keep_locks ) { int u = level + 1 ; if ( u < BTRFS_MAX_LEVEL && p -> locks [ u ] ) { btrfs_tree_unlock_rw ( p -> nodes [ u ] , p -> locks [ u ] ) ; p -> locks [ u ] = 0 ; } } ret = key_search ( b , key , level , & prev_cmp , & slot ) ; if ( level != 0 ) { int dec = 0 ; if ( ret && slot > 0 ) { dec = 1 ; slot -= 1 ; } p -> slots [ level ] = slot ; err = setup_nodes_for_search ( trans , root , p , b , level , ins_len , & write_lock_level ) ; if ( err == - EAGAIN ) goto again ; if ( err ) { ret = err ; goto done ; } b = p -> nodes [ level ] ; slot = p -> slots [ level ] ; if ( slot == 0 && ins_len && write_lock_level < level + 1 ) { write_lock_level = level + 1 ; btrfs_release_path ( p ) ; goto again ; } unlock_up ( p , level , lowest_unlock , min_write_lock_level , & write_lock_level ) ; if ( level == lowest_level ) { if ( dec ) p -> slots [ level ] ++ ; goto done ; } err = read_block_for_search ( trans , root , p , & b , level , slot , key , 0 ) ; if ( err == - EAGAIN ) goto again ; if ( err ) { ret = err ; goto done ; } if ( ! p -> skip_locking ) { level = btrfs_header_level ( b ) ; if ( level <= write_lock_level ) { err = btrfs_try_tree_write_lock ( b ) ; if ( ! err ) { btrfs_set_path_blocking ( p ) ; btrfs_tree_lock ( b ) ; btrfs_clear_path_blocking ( p , b , BTRFS_WRITE_LOCK ) ; } p -> locks [ level ] = BTRFS_WRITE_LOCK ; } else { err = btrfs_try_tree_read_lock ( b ) ; if ( ! err ) { btrfs_set_path_blocking ( p ) ; btrfs_tree_read_lock ( b ) ; btrfs_clear_path_blocking ( p , b , BTRFS_READ_LOCK ) ; } p -> locks [ level ] = BTRFS_READ_LOCK ; } p -> nodes [ level ] = b ; } } else { p -> slots [ level ] = slot ; if ( ins_len > 0 && btrfs_leaf_free_space ( root , b ) < ins_len ) { if ( write_lock_level < 1 ) { write_lock_level = 1 ; btrfs_release_path ( p ) ; goto again ; } btrfs_set_path_blocking ( p ) ; err = split_leaf ( trans , root , key , p , ins_len , ret == 0 ) ; btrfs_clear_path_blocking ( p , NULL , 0 ) ; BUG_ON ( err > 0 ) ; if ( err ) { ret = err ; goto done ; } } if ( ! p -> search_for_split ) unlock_up ( p , level , lowest_unlock , min_write_lock_level , & write_lock_level ) ; goto done ; } } ret = 1 ; done : if ( ! p -> leave_spinning ) btrfs_set_path_blocking ( p ) ; <S2SV_StartBug> if ( ret < 0 ) <S2SV_EndBug> btrfs_release_path ( p ) ; return ret ; }",ret < 0 && ! p -> skip_release_on_error
280,"void vp8_plane_add_noise_c ( unsigned char * Start , char * noise , char blackclamp [ 16 ] , char whiteclamp [ 16 ] , char bothclamp [ 16 ] , unsigned int Width , unsigned int Height , int Pitch ) { <S2SV_StartBug> unsigned int i , j ; <S2SV_EndBug> for ( i = 0 ; i < Height ; i ++ ) { unsigned char * Pos = Start + i * Pitch ; char * Ref = ( char * ) ( noise + ( rand ( ) & 0xff ) ) ; for ( j = 0 ; j < Width ; j ++ ) { if ( Pos [ j ] < blackclamp [ 0 ] ) Pos [ j ] = blackclamp [ 0 ] ; if ( Pos [ j ] > 255 + whiteclamp [ 0 ] ) Pos [ j ] = 255 + whiteclamp [ 0 ] ; Pos [ j ] += Ref [ j ] ; } } }","i , j ; ( void ) bothclamp"
281,"static void sctp_sock_migrate ( struct sock * oldsk , struct sock * newsk , struct sctp_association * assoc , sctp_socket_type_t type ) { struct sctp_sock * oldsp = sctp_sk ( oldsk ) ; struct sctp_sock * newsp = sctp_sk ( newsk ) ; struct sctp_bind_bucket * pp ; struct sctp_endpoint * newep = newsp -> ep ; struct sk_buff * skb , * tmp ; struct sctp_ulpevent * event ; int flags = 0 ; newsk -> sk_sndbuf = oldsk -> sk_sndbuf ; newsk -> sk_rcvbuf = oldsk -> sk_rcvbuf ; inet_sk_copy_descendant ( newsk , oldsk ) ; newsp -> ep = newep ; newsp -> hmac = NULL ; pp = sctp_sk ( oldsk ) -> bind_hash ; sk_add_bind_node ( newsk , & pp -> owner ) ; sctp_sk ( newsk ) -> bind_hash = pp ; inet_sk ( newsk ) -> num = inet_sk ( oldsk ) -> num ; if ( PF_INET6 == assoc -> base . sk -> sk_family ) flags = SCTP_ADDR6_ALLOWED ; if ( assoc -> peer . ipv4_address ) flags |= SCTP_ADDR4_PEERSUPP ; if ( assoc -> peer . ipv6_address ) flags |= SCTP_ADDR6_PEERSUPP ; sctp_bind_addr_copy ( & newsp -> ep -> base . bind_addr , & oldsp -> ep -> base . bind_addr , SCTP_SCOPE_GLOBAL , GFP_KERNEL , flags ) ; sctp_skb_for_each ( skb , & oldsk -> sk_receive_queue , tmp ) { event = sctp_skb2event ( skb ) ; if ( event -> asoc == assoc ) { <S2SV_StartBug> sctp_sock_rfree ( skb ) ; <S2SV_EndBug> __skb_unlink ( skb , & oldsk -> sk_receive_queue ) ; __skb_queue_tail ( & newsk -> sk_receive_queue , skb ) ; <S2SV_StartBug> sctp_skb_set_owner_r ( skb , newsk ) ; <S2SV_EndBug> } } skb_queue_head_init ( & newsp -> pd_lobby ) ; sctp_sk ( newsk ) -> pd_mode = assoc -> ulpq . pd_mode ; if ( sctp_sk ( oldsk ) -> pd_mode ) { struct sk_buff_head * queue ; if ( assoc -> ulpq . pd_mode ) { queue = & newsp -> pd_lobby ; } else queue = & newsk -> sk_receive_queue ; sctp_skb_for_each ( skb , & oldsp -> pd_lobby , tmp ) { event = sctp_skb2event ( skb ) ; if ( event -> asoc == assoc ) { <S2SV_StartBug> sctp_sock_rfree ( skb ) ; <S2SV_EndBug> __skb_unlink ( skb , & oldsp -> pd_lobby ) ; __skb_queue_tail ( queue , skb ) ; <S2SV_StartBug> sctp_skb_set_owner_r ( skb , newsk ) ; <S2SV_EndBug> } } if ( assoc -> ulpq . pd_mode ) <S2SV_StartBug> sctp_clear_pd ( oldsk ) ; <S2SV_EndBug> } newsp -> type = type ; sctp_lock_sock ( newsk ) ; sctp_assoc_migrate ( assoc , newsk ) ; if ( sctp_state ( assoc , CLOSED ) && sctp_style ( newsk , TCP ) ) newsk -> sk_shutdown |= RCV_SHUTDOWN ; newsk -> sk_state = SCTP_SS_ESTABLISHED ; sctp_release_sock ( newsk ) ; }","assoc ) { sctp_sock_rfree_frag <S2SV_ModEnd> ( skb ) <S2SV_ModStart> skb ) ; sctp_skb_set_owner_r_frag <S2SV_ModEnd> ( skb , <S2SV_ModStart> assoc ) { sctp_sock_rfree_frag <S2SV_ModEnd> ( skb ) <S2SV_ModStart> skb ) ; sctp_skb_set_owner_r_frag <S2SV_ModEnd> ( skb , <S2SV_ModStart> sctp_clear_pd ( oldsk ) ; } sctp_skb_for_each ( skb , & assoc -> ulpq . reasm , tmp ) { sctp_sock_rfree_frag ( skb ) ; sctp_skb_set_owner_r_frag ( skb , newsk ) ; } sctp_skb_for_each ( skb , & assoc -> ulpq . lobby , tmp ) { sctp_sock_rfree_frag ( skb ) ; sctp_skb_set_owner_r_frag ( skb , newsk"
282,"static int btrfs_rename ( struct inode * old_dir , struct dentry * old_dentry , struct inode * new_dir , struct dentry * new_dentry ) { struct btrfs_trans_handle * trans ; struct btrfs_root * root = BTRFS_I ( old_dir ) -> root ; struct btrfs_root * dest = BTRFS_I ( new_dir ) -> root ; struct inode * new_inode = new_dentry -> d_inode ; struct inode * old_inode = old_dentry -> d_inode ; struct timespec ctime = CURRENT_TIME ; u64 index = 0 ; u64 root_objectid ; int ret ; u64 old_ino = btrfs_ino ( old_inode ) ; if ( btrfs_ino ( new_dir ) == BTRFS_EMPTY_SUBVOL_DIR_OBJECTID ) return - EPERM ; if ( old_ino != BTRFS_FIRST_FREE_OBJECTID && root != dest ) return - EXDEV ; if ( old_ino == BTRFS_EMPTY_SUBVOL_DIR_OBJECTID || ( new_inode && btrfs_ino ( new_inode ) == BTRFS_FIRST_FREE_OBJECTID ) ) return - ENOTEMPTY ; if ( S_ISDIR ( old_inode -> i_mode ) && new_inode && new_inode -> i_size > BTRFS_EMPTY_DIR_SIZE ) return - ENOTEMPTY ; <S2SV_StartBug> if ( new_inode && S_ISREG ( old_inode -> i_mode ) && new_inode -> i_size && <S2SV_EndBug> old_inode -> i_size > BTRFS_ORDERED_OPERATIONS_FLUSH_LIMIT ) filemap_flush ( old_inode -> i_mapping ) ; if ( old_ino == BTRFS_FIRST_FREE_OBJECTID ) down_read ( & root -> fs_info -> subvol_sem ) ; trans = btrfs_start_transaction ( root , 20 ) ; if ( IS_ERR ( trans ) ) { ret = PTR_ERR ( trans ) ; goto out_notrans ; } if ( dest != root ) btrfs_record_root_in_trans ( trans , dest ) ; ret = btrfs_set_inode_index ( new_dir , & index ) ; if ( ret ) goto out_fail ; if ( unlikely ( old_ino == BTRFS_FIRST_FREE_OBJECTID ) ) { root -> fs_info -> last_trans_log_full_commit = trans -> transid ; } else { ret = btrfs_insert_inode_ref ( trans , dest , new_dentry -> d_name . name , new_dentry -> d_name . len , old_ino , btrfs_ino ( new_dir ) , index ) ; if ( ret ) goto out_fail ; btrfs_pin_log_trans ( root ) ; } if ( new_inode && new_inode -> i_size && S_ISREG ( old_inode -> i_mode ) ) btrfs_add_ordered_operation ( trans , root , old_inode ) ; inode_inc_iversion ( old_dir ) ; inode_inc_iversion ( new_dir ) ; inode_inc_iversion ( old_inode ) ; old_dir -> i_ctime = old_dir -> i_mtime = ctime ; new_dir -> i_ctime = new_dir -> i_mtime = ctime ; old_inode -> i_ctime = ctime ; if ( old_dentry -> d_parent != new_dentry -> d_parent ) btrfs_record_unlink_dir ( trans , old_dir , old_inode , 1 ) ; if ( unlikely ( old_ino == BTRFS_FIRST_FREE_OBJECTID ) ) { root_objectid = BTRFS_I ( old_inode ) -> root -> root_key . objectid ; ret = btrfs_unlink_subvol ( trans , root , old_dir , root_objectid , old_dentry -> d_name . name , old_dentry -> d_name . len ) ; } else { ret = __btrfs_unlink_inode ( trans , root , old_dir , old_dentry -> d_inode , old_dentry -> d_name . name , old_dentry -> d_name . len ) ; if ( ! ret ) ret = btrfs_update_inode ( trans , root , old_inode ) ; } if ( ret ) { btrfs_abort_transaction ( trans , root , ret ) ; goto out_fail ; } if ( new_inode ) { inode_inc_iversion ( new_inode ) ; new_inode -> i_ctime = CURRENT_TIME ; if ( unlikely ( btrfs_ino ( new_inode ) == BTRFS_EMPTY_SUBVOL_DIR_OBJECTID ) ) { root_objectid = BTRFS_I ( new_inode ) -> location . objectid ; ret = btrfs_unlink_subvol ( trans , dest , new_dir , root_objectid , new_dentry -> d_name . name , new_dentry -> d_name . len ) ; BUG_ON ( new_inode -> i_nlink == 0 ) ; } else { ret = btrfs_unlink_inode ( trans , dest , new_dir , new_dentry -> d_inode , new_dentry -> d_name . name , new_dentry -> d_name . len ) ; } if ( ! ret && new_inode -> i_nlink == 0 ) { ret = btrfs_orphan_add ( trans , new_dentry -> d_inode ) ; BUG_ON ( ret ) ; } if ( ret ) { btrfs_abort_transaction ( trans , root , ret ) ; goto out_fail ; } } fixup_inode_flags ( new_dir , old_inode ) ; ret = btrfs_add_link ( trans , new_dir , old_inode , new_dentry -> d_name . name , new_dentry -> d_name . len , 0 , index ) ; if ( ret ) { btrfs_abort_transaction ( trans , root , ret ) ; goto out_fail ; } if ( old_ino != BTRFS_FIRST_FREE_OBJECTID ) { struct dentry * parent = new_dentry -> d_parent ; btrfs_log_new_name ( trans , old_inode , old_dir , parent ) ; btrfs_end_log_trans ( root ) ; } out_fail : btrfs_end_transaction ( trans , root ) ; out_notrans : if ( old_ino == BTRFS_FIRST_FREE_OBJECTID ) up_read ( & root -> fs_info -> subvol_sem ) ; return ret ; }","- ENOTEMPTY ; ret = btrfs_check_dir_item_collision ( root , new_dir -> i_ino , new_dentry -> d_name . name , new_dentry -> d_name . len ) ; if ( ret ) { if ( ret == - EEXIST ) { if ( ! new_inode ) { WARN_ON ( 1 ) ; return ret ; } } else { return ret ; } } ret = 0 ;"
283,"static int r_core_cmd_subst_i ( RCore * core , char * cmd , char * colon ) { const char * quotestr = ""`"" ; const char * tick = NULL ; char * ptr , * ptr2 , * str ; char * arroba = NULL ; int i , ret = 0 , pipefd ; bool usemyblock = false ; int scr_html = - 1 ; int scr_color = - 1 ; bool eos = false ; bool haveQuote = false ; if ( ! cmd ) { return 0 ; } cmd = r_str_trim_head_tail ( cmd ) ; switch ( * cmd ) { case '.' : if ( cmd [ 1 ] == \'""\' ) { return r_cmd_call ( core -> rcmd , cmd ) ; } break ; case \'""\' : for ( ; * cmd ; ) { int pipefd = - 1 ; ut64 oseek = UT64_MAX ; char * line , * p ; haveQuote = * cmd == \'""\' ; if ( haveQuote ) { cmd ++ ; <S2SV_StartBug> p = find_eoq ( cmd + 1 ) ; <S2SV_EndBug> if ( ! p || ! * p ) { eprintf ( ""Missing<S2SV_blank>\\""<S2SV_blank>in<S2SV_blank>(%s)."" , cmd ) ; return false ; } * p ++ = 0 ; if ( ! * p ) { eos = true ; } } else { char * sc = strchr ( cmd , ';' ) ; if ( sc ) { * sc = 0 ; } r_core_cmd0 ( core , cmd ) ; if ( ! sc ) { break ; } cmd = sc + 1 ; continue ; } if ( p [ 0 ] ) { if ( p [ 0 ] == '@' ) { p -- ; } while ( p [ 1 ] == ';' || IS_WHITESPACE ( p [ 1 ] ) ) { p ++ ; } if ( p [ 1 ] == '@' || ( p [ 1 ] && p [ 2 ] == '@' ) ) { char * q = strchr ( p + 1 , \'""\' ) ; if ( q ) { * q = 0 ; } haveQuote = q != NULL ; oseek = core -> offset ; r_core_seek ( core , r_num_math ( core -> num , p + 2 ) , 1 ) ; if ( q ) { * p = \'""\' ; p = q ; } else { p = strchr ( p + 1 , ';' ) ; } } if ( p && * p && p [ 1 ] == '>' ) { str = p + 2 ; while ( * str == '>' ) { str ++ ; } while ( IS_WHITESPACE ( * str ) ) { str ++ ; } r_cons_flush ( ) ; pipefd = r_cons_pipe_open ( str , 1 , p [ 2 ] == '>' ) ; } } line = strdup ( cmd ) ; line = r_str_replace ( line , ""\\\\\\"""" , ""\\"""" , true ) ; if ( p && * p && p [ 1 ] == '|' ) { str = p + 2 ; while ( IS_WHITESPACE ( * str ) ) { str ++ ; } r_core_cmd_pipe ( core , cmd , str ) ; } else { r_cmd_call ( core -> rcmd , line ) ; } free ( line ) ; if ( oseek != UT64_MAX ) { r_core_seek ( core , oseek , 1 ) ; oseek = UT64_MAX ; } if ( pipefd != - 1 ) { r_cons_flush ( ) ; r_cons_pipe_close ( pipefd ) ; } if ( ! p ) { break ; } if ( eos ) { break ; } if ( haveQuote ) { if ( * p == ';' ) { cmd = p + 1 ; } else { if ( * p == \'""\' ) { cmd = p + 1 ; } else { * p = \'""\' ; cmd = p ; } } } else { cmd = p + 1 ; } } return true ; case '(' : if ( cmd [ 1 ] != '*' ) { return r_cmd_call ( core -> rcmd , cmd ) ; } } if ( * cmd != '#' ) { ptr = ( char * ) r_str_lastbut ( cmd , '#' , quotestr ) ; if ( ptr && ( ptr [ 1 ] == '<S2SV_blank>' || ptr [ 1 ] == '\\t' ) ) { * ptr = '\\0' ; } } if ( * cmd != '#' ) { ptr = ( char * ) r_str_lastbut ( cmd , ';' , quotestr ) ; if ( colon && ptr ) { int ret ; * ptr = '\\0' ; if ( r_core_cmd_subst ( core , cmd ) == - 1 ) { return - 1 ; } cmd = ptr + 1 ; ret = r_core_cmd_subst ( core , cmd ) ; * ptr = ';' ; return ret ; } } ptr = ( char * ) r_str_lastbut ( cmd , '|' , quotestr ) ; if ( ptr ) { char * ptr2 = strchr ( cmd , '`' ) ; if ( ! ptr2 || ( ptr2 && ptr2 > ptr ) ) { if ( ! tick || ( tick && tick > ptr ) ) { * ptr = '\\0' ; cmd = r_str_clean ( cmd ) ; if ( ! strcmp ( ptr + 1 , ""?"" ) ) { eprintf ( ""Usage:<S2SV_blank><r2command><S2SV_blank>|<S2SV_blank><program|H|>\\n"" ) ; eprintf ( ""<S2SV_blank>pd|?<S2SV_blank><S2SV_blank><S2SV_blank>-<S2SV_blank>show<S2SV_blank>this<S2SV_blank>help\\n"" ) ; eprintf ( ""<S2SV_blank>pd|<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>-<S2SV_blank>disable<S2SV_blank>scr.html<S2SV_blank>and<S2SV_blank>scr.color\\n"" ) ; eprintf ( ""<S2SV_blank>pd|H<S2SV_blank><S2SV_blank><S2SV_blank>-<S2SV_blank>enable<S2SV_blank>scr.html,<S2SV_blank>respect<S2SV_blank>scr.color\\n"" ) ; return ret ; } else if ( ! strcmp ( ptr + 1 , ""H"" ) ) { scr_html = r_config_get_i ( core -> config , ""scr.html"" ) ; r_config_set_i ( core -> config , ""scr.html"" , true ) ; } else if ( ptr [ 1 ] ) { int value = core -> num -> value ; if ( * cmd ) { r_core_cmd_pipe ( core , cmd , ptr + 1 ) ; } else { r_io_system ( core -> io , ptr + 1 ) ; } core -> num -> value = value ; return 0 ; } else { scr_html = r_config_get_i ( core -> config , ""scr.html"" ) ; r_config_set_i ( core -> config , ""scr.html"" , 0 ) ; scr_color = r_config_get_i ( core -> config , ""scr.color"" ) ; r_config_set_i ( core -> config , ""scr.color"" , false ) ; } } } } ptr = ( char * ) r_str_lastbut ( cmd , '&' , quotestr ) ; while ( ptr && ptr [ 1 ] == '&' ) { * ptr = '\\0' ; ret = r_cmd_call ( core -> rcmd , cmd ) ; if ( ret == - 1 ) { eprintf ( ""command<S2SV_blank>error(%s)\\n"" , cmd ) ; if ( scr_html != - 1 ) { r_config_set_i ( core -> config , ""scr.html"" , scr_html ) ; } if ( scr_color != - 1 ) { r_config_set_i ( core -> config , ""scr.color"" , scr_color ) ; } return ret ; } for ( cmd = ptr + 2 ; cmd && * cmd == '<S2SV_blank>' ; cmd ++ ) ; ptr = strchr ( cmd , '&' ) ; } free ( core -> oobi ) ; core -> oobi = NULL ; ptr = strstr ( cmd , ""?*"" ) ; if ( ptr ) { char * prech = ptr - 1 ; if ( * prech != '~' ) { ptr [ 1 ] = 0 ; if ( * cmd != '#' && strlen ( cmd ) < 5 ) { r_cons_break_push ( NULL , NULL ) ; recursive_help ( core , cmd ) ; r_cons_break_pop ( ) ; r_cons_grep_parsecmd ( ptr + 2 , ""`"" ) ; if ( scr_html != - 1 ) { r_config_set_i ( core -> config , ""scr.html"" , scr_html ) ; } if ( scr_color != - 1 ) { r_config_set_i ( core -> config , ""scr.color"" , scr_color ) ; } return 0 ; } } } # if 0 ptr = strchr ( cmd , '<' ) ; if ( ptr ) { ptr [ 0 ] = '\\0' ; if ( r_cons_singleton ( ) -> is_interactive ) { if ( ptr [ 1 ] == '<' ) { for ( str = ptr + 2 ; str [ 0 ] == '<S2SV_blank>' ; str ++ ) { } eprintf ( ""==><S2SV_blank>Reading<S2SV_blank>from<S2SV_blank>stdin<S2SV_blank>until<S2SV_blank>\'%s\'\\n"" , str ) ; free ( core -> oobi ) ; core -> oobi = malloc ( 1 ) ; if ( core -> oobi ) { core -> oobi [ 0 ] = '\\0' ; } core -> oobi_len = 0 ; for ( ; ; ) { char buf [ 1024 ] ; int ret ; write ( 1 , ""><S2SV_blank>"" , 2 ) ; fgets ( buf , sizeof ( buf ) - 1 , stdin ) ; if ( feof ( stdin ) ) { break ; } if ( * buf ) buf [ strlen ( buf ) - 1 ] = '\\0' ; ret = strlen ( buf ) ; core -> oobi_len += ret ; core -> oobi = realloc ( core -> oobi , core -> oobi_len + 1 ) ; if ( core -> oobi ) { if ( ! strcmp ( buf , str ) ) { break ; } strcat ( ( char * ) core -> oobi , buf ) ; } } } else { for ( str = ptr + 1 ; * str == '<S2SV_blank>' ; str ++ ) { } if ( ! * str ) { goto next ; } eprintf ( ""Slurping<S2SV_blank>file<S2SV_blank>\'%s\'\\n"" , str ) ; free ( core -> oobi ) ; core -> oobi = ( ut8 * ) r_file_slurp ( str , & core -> oobi_len ) ; if ( ! core -> oobi ) { eprintf ( ""cannot<S2SV_blank>open<S2SV_blank>file\\n"" ) ; } else if ( ptr == cmd ) { return r_core_cmd_buffer ( core , ( const char * ) core -> oobi ) ; } } } else { eprintf ( ""Cannot<S2SV_blank>slurp<S2SV_blank>with<S2SV_blank><<<S2SV_blank>in<S2SV_blank>non-interactive<S2SV_blank>mode\\n"" ) ; return 0 ; } } next : # endif ptr = strchr ( cmd , '>' ) ; if ( ptr ) { int fdn = 1 ; int pipecolor = r_config_get_i ( core -> config , ""scr.pipecolor"" ) ; int use_editor = false ; int ocolor = r_config_get_i ( core -> config , ""scr.color"" ) ; * ptr = '\\0' ; str = r_str_trim_head_tail ( ptr + 1 + ( ptr [ 1 ] == '>' ) ) ; if ( ! * str ) { eprintf ( ""No<S2SV_blank>output?\\n"" ) ; goto next2 ; } if ( ptr > ( cmd + 1 ) && ISWHITECHAR ( ptr [ - 2 ] ) ) { char * fdnum = ptr - 1 ; if ( * fdnum == 'H' ) { scr_html = r_config_get_i ( core -> config , ""scr.html"" ) ; r_config_set_i ( core -> config , ""scr.html"" , true ) ; pipecolor = true ; * fdnum = 0 ; } else { if ( IS_DIGIT ( * fdnum ) ) { fdn = * fdnum - '0' ; } * fdnum = 0 ; } } r_cons_set_interactive ( false ) ; if ( ! strcmp ( str , ""-"" ) ) { use_editor = true ; str = r_file_temp ( ""dumpedit"" ) ; r_config_set ( core -> config , ""scr.color"" , ""false"" ) ; } if ( fdn > 0 ) { pipefd = r_cons_pipe_open ( str , fdn , ptr [ 1 ] == '>' ) ; if ( pipefd != - 1 ) { if ( ! pipecolor ) { r_config_set_i ( core -> config , ""scr.color"" , 0 ) ; } ret = r_core_cmd_subst ( core , cmd ) ; r_cons_flush ( ) ; r_cons_pipe_close ( pipefd ) ; } } r_cons_set_last_interactive ( ) ; if ( ! pipecolor ) { r_config_set_i ( core -> config , ""scr.color"" , ocolor ) ; } if ( use_editor ) { const char * editor = r_config_get ( core -> config , ""cfg.editor"" ) ; if ( editor && * editor ) { r_sys_cmdf ( ""%s<S2SV_blank>\'%s\'"" , editor , str ) ; r_file_rm ( str ) ; } else { eprintf ( ""No<S2SV_blank>cfg.editor<S2SV_blank>configured\\n"" ) ; } r_config_set_i ( core -> config , ""scr.color"" , ocolor ) ; free ( str ) ; } if ( scr_html != - 1 ) { r_config_set_i ( core -> config , ""scr.html"" , scr_html ) ; } if ( scr_color != - 1 ) { r_config_set_i ( core -> config , ""scr.color"" , scr_color ) ; } return ret ; } next2 : ptr = strchr ( cmd , '`' ) ; if ( ptr ) { int empty = 0 ; int oneline = 1 ; if ( ptr [ 1 ] == '`' ) { memmove ( ptr , ptr + 1 , strlen ( ptr ) ) ; oneline = 0 ; empty = 1 ; } ptr2 = strchr ( ptr + 1 , '`' ) ; if ( empty ) { } else if ( ! ptr2 ) { eprintf ( ""parse:<S2SV_blank>Missing<S2SV_blank>backtick<S2SV_blank>in<S2SV_blank>expression.\\n"" ) ; goto fail ; } else { int value = core -> num -> value ; * ptr = '\\0' ; * ptr2 = '\\0' ; if ( ptr [ 1 ] == '!' ) { str = r_core_cmd_str_pipe ( core , ptr + 1 ) ; } else { str = r_core_cmd_str ( core , ptr + 1 ) ; } if ( ! str ) { goto fail ; } if ( * str == '|' || * str == '*' ) { eprintf ( ""r_core_cmd_subst_i:<S2SV_blank>invalid<S2SV_blank>backticked<S2SV_blank>command\\n"" ) ; free ( str ) ; goto fail ; } if ( oneline && str ) { for ( i = 0 ; str [ i ] ; i ++ ) { if ( str [ i ] == '\\n' ) { str [ i ] = '<S2SV_blank>' ; } } } str = r_str_append ( str , ptr2 + 1 ) ; cmd = r_str_append ( strdup ( cmd ) , str ) ; core -> num -> value = value ; ret = r_core_cmd_subst ( core , cmd ) ; free ( cmd ) ; if ( scr_html != - 1 ) { r_config_set_i ( core -> config , ""scr.html"" , scr_html ) ; } free ( str ) ; return ret ; } } core -> fixedblock = false ; if ( r_str_endswith ( cmd , ""~?"" ) && cmd [ 2 ] == '\\0' ) { r_cons_grep_help ( ) ; return true ; } if ( * cmd != '.' ) { r_cons_grep_parsecmd ( cmd , quotestr ) ; } if ( * cmd != '(' && * cmd != \'""\' ) { ptr = strchr ( cmd , '@' ) ; if ( ptr == cmd + 1 && * cmd == '?' ) { ptr = NULL ; } } else { ptr = NULL ; } core -> tmpseek = ptr ? true : false ; int rc = 0 ; if ( ptr ) { char * f , * ptr2 = strchr ( ptr + 1 , '!' ) ; ut64 addr = UT64_MAX ; const char * tmpbits = NULL ; const char * offstr = NULL ; ut64 tmpbsz = core -> blocksize ; char * tmpeval = NULL ; ut64 tmpoff = core -> offset ; char * tmpasm = NULL ; int tmpfd = - 1 ; int sz , len ; ut8 * buf ; * ptr = '\\0' ; for ( ptr ++ ; * ptr == '<S2SV_blank>' ; ptr ++ ) { } if ( * ptr && ptr [ 1 ] == ':' ) { } else { ptr -- ; } arroba = ( ptr [ 0 ] && ptr [ 1 ] && ptr [ 2 ] ) ? strchr ( ptr + 2 , '@' ) : NULL ; repeat_arroba : if ( arroba ) { * arroba = 0 ; } if ( ptr [ 1 ] == '?' ) { helpCmdAt ( core ) ; } else if ( ptr [ 0 ] && ptr [ 1 ] == ':' && ptr [ 2 ] ) { usemyblock = true ; switch ( ptr [ 0 ] ) { case 'f' : f = r_file_slurp ( ptr + 2 , & sz ) ; if ( f ) { buf = malloc ( sz ) ; if ( buf ) { free ( core -> block ) ; core -> block = buf ; core -> blocksize = sz ; memcpy ( core -> block , f , sz ) ; } else { eprintf ( ""cannot<S2SV_blank>alloc<S2SV_blank>%d"" , sz ) ; } free ( f ) ; } else { eprintf ( ""cannot<S2SV_blank>open<S2SV_blank>\'%s\'\\n"" , ptr + 3 ) ; } break ; case 'r' : if ( ptr [ 1 ] == ':' ) { ut64 regval ; char * mander = strdup ( ptr + 2 ) ; char * sep = findSeparator ( mander ) ; if ( sep ) { char ch = * sep ; * sep = 0 ; regval = r_debug_reg_get ( core -> dbg , mander ) ; * sep = ch ; char * numexpr = r_str_newf ( ""0x%"" PFMT64x ""%s"" , regval , sep ) ; regval = r_num_math ( core -> num , numexpr ) ; free ( numexpr ) ; } else { regval = r_debug_reg_get ( core -> dbg , ptr + 2 ) ; } r_core_seek ( core , regval , 1 ) ; free ( mander ) ; } break ; case 'b' : tmpbits = strdup ( r_config_get ( core -> config , ""asm.bits"" ) ) ; r_config_set_i ( core -> config , ""asm.bits"" , r_num_math ( core -> num , ptr + 2 ) ) ; break ; case 'i' : { ut64 addr = r_num_math ( core -> num , ptr + 2 ) ; if ( addr ) { r_core_cmdf ( core , ""so<S2SV_blank>%s"" , ptr + 2 ) ; } } break ; case 'e' : tmpeval = parse_tmp_evals ( core , ptr + 2 ) ; break ; case 'x' : if ( ptr [ 1 ] == ':' ) { buf = malloc ( strlen ( ptr + 2 ) + 1 ) ; if ( buf ) { len = r_hex_str2bin ( ptr + 2 , buf ) ; r_core_block_size ( core , R_ABS ( len ) ) ; memcpy ( core -> block , buf , core -> blocksize ) ; core -> fixedblock = true ; free ( buf ) ; } else { eprintf ( ""cannot<S2SV_blank>allocate\\n"" ) ; } } else { eprintf ( ""Invalid<S2SV_blank>@x:<S2SV_blank>syntax\\n"" ) ; } break ; case 'k' : { char * out = sdb_querys ( core -> sdb , NULL , 0 , ptr + ( ( ptr [ 1 ] ) ? 2 : 1 ) ) ; if ( out ) { r_core_seek ( core , r_num_math ( core -> num , out ) , 1 ) ; free ( out ) ; } } break ; case 'o' : if ( ptr [ 1 ] == ':' ) { tmpfd = core -> io -> raised ; r_io_raise ( core -> io , atoi ( ptr + 2 ) ) ; } break ; case 'a' : if ( ptr [ 1 ] == ':' ) { char * q = strchr ( ptr + 2 , ':' ) ; tmpasm = strdup ( r_config_get ( core -> config , ""asm.arch"" ) ) ; if ( q ) { * q ++ = 0 ; tmpbits = r_config_get ( core -> config , ""asm.bits"" ) ; r_config_set ( core -> config , ""asm.bits"" , q ) ; } r_config_set ( core -> config , ""asm.arch"" , ptr + 2 ) ; } else { eprintf ( ""Usage:<S2SV_blank>pd<S2SV_blank>10<S2SV_blank>@a:arm:32\\n"" ) ; } break ; case 's' : len = strlen ( ptr + 2 ) ; r_core_block_size ( core , len ) ; memcpy ( core -> block , ptr + 2 , len ) ; break ; default : goto ignore ; } * ptr = '@' ; goto next_arroba ; } ignore : ptr = r_str_trim_head ( ptr + 1 ) ; ptr -- ; cmd = r_str_clean ( cmd ) ; if ( ptr2 ) { if ( strlen ( ptr + 1 ) == 13 && strlen ( ptr2 + 1 ) == 6 && ! memcmp ( ptr + 1 , ""0x"" , 2 ) && ! memcmp ( ptr2 + 1 , ""0x"" , 2 ) ) { } else if ( strlen ( ptr + 1 ) == 9 && strlen ( ptr2 + 1 ) == 4 ) { } else { * ptr2 = '\\0' ; if ( ! ptr2 [ 1 ] ) { goto fail ; } r_core_block_size ( core , r_num_math ( core -> num , ptr2 + 1 ) ) ; } } offstr = r_str_trim_head ( ptr + 1 ) ; addr = r_num_math ( core -> num , offstr ) ; if ( isalpha ( ( unsigned char ) ptr [ 1 ] ) && ! addr ) { if ( ! r_flag_get ( core -> flags , ptr + 1 ) ) { eprintf ( ""Invalid<S2SV_blank>address<S2SV_blank>(%s)\\n"" , ptr + 1 ) ; goto fail ; } } else { char ch = * offstr ; if ( ch == '-' || ch == '+' ) { addr = core -> offset + addr ; } } next_arroba : if ( arroba ) { ptr = arroba ; arroba = NULL ; goto repeat_arroba ; } if ( ptr [ 1 ] == '@' ) { if ( ptr [ 2 ] == '@' ) { char * rule = ptr + 3 ; while ( * rule && * rule == '<S2SV_blank>' ) rule ++ ; ret = r_core_cmd_foreach3 ( core , cmd , rule ) ; } else { ret = r_core_cmd_foreach ( core , cmd , ptr + 2 ) ; } } else { bool tmpseek = false ; const char * fromvars [ ] = { ""anal.from"" , ""diff.from"" , ""graph.from"" , ""io.buffer.from"" , ""lines.from"" , ""search.from"" , ""zoom.from"" , NULL } ; const char * tovars [ ] = { ""anal.to"" , ""diff.to"" , ""graph.to"" , ""io.buffer.to"" , ""lines.to"" , ""search.to"" , ""zoom.to"" , NULL } ; ut64 curfrom [ R_ARRAY_SIZE ( fromvars ) - 1 ] , curto [ R_ARRAY_SIZE ( tovars ) - 1 ] ; if ( ptr [ 1 ] == '.' && ptr [ 2 ] == '.' ) { char * range = ptr + 3 ; char * p = strchr ( range , '<S2SV_blank>' ) ; if ( ! p ) { eprintf ( ""Usage:<S2SV_blank>/<S2SV_blank>ABCD<S2SV_blank>@..0x1000<S2SV_blank>0x3000\\n"" ) ; free ( tmpeval ) ; free ( tmpasm ) ; goto fail ; } * p = '\\x00' ; ut64 from = r_num_math ( core -> num , range ) ; ut64 to = r_num_math ( core -> num , p + 1 ) ; for ( i = 0 ; fromvars [ i ] ; i ++ ) { curfrom [ i ] = r_config_get_i ( core -> config , fromvars [ i ] ) ; } for ( i = 0 ; tovars [ i ] ; i ++ ) { curto [ i ] = r_config_get_i ( core -> config , tovars [ i ] ) ; } for ( i = 0 ; fromvars [ i ] ; i ++ ) { r_config_set_i ( core -> config , fromvars [ i ] , from ) ; } for ( i = 0 ; tovars [ i ] ; i ++ ) { r_config_set_i ( core -> config , tovars [ i ] , to ) ; } tmpseek = true ; } if ( usemyblock ) { if ( addr != UT64_MAX ) { core -> offset = addr ; } ret = r_cmd_call ( core -> rcmd , r_str_trim_head ( cmd ) ) ; } else { if ( addr != UT64_MAX ) { if ( ! ptr [ 1 ] || r_core_seek ( core , addr , 1 ) ) { r_core_block_read ( core ) ; ret = r_cmd_call ( core -> rcmd , r_str_trim_head ( cmd ) ) ; } else { ret = 0 ; } } } if ( tmpseek ) { for ( i = 0 ; fromvars [ i ] ; i ++ ) { r_config_set_i ( core -> config , fromvars [ i ] , curfrom [ i ] ) ; } for ( i = 0 ; tovars [ i ] ; i ++ ) { r_config_set_i ( core -> config , tovars [ i ] , curto [ i ] ) ; } } } if ( ptr2 ) { * ptr2 = '!' ; r_core_block_size ( core , tmpbsz ) ; } if ( tmpasm ) { r_config_set ( core -> config , ""asm.arch"" , tmpasm ) ; tmpasm = NULL ; } if ( tmpfd != - 1 ) { r_io_raise ( core -> io , tmpfd ) ; } if ( tmpbits ) { r_config_set ( core -> config , ""asm.bits"" , tmpbits ) ; tmpbits = NULL ; } if ( tmpeval ) { r_core_cmd0 ( core , tmpeval ) ; R_FREE ( tmpeval ) ; } r_core_seek ( core , tmpoff , 1 ) ; * ptr = '@' ; rc = ret ; goto beach ; } rc = cmd ? r_cmd_call ( core -> rcmd , r_str_trim_head ( cmd ) ) : false ; beach : if ( scr_html != - 1 ) { r_cons_flush ( ) ; r_config_set_i ( core -> config , ""scr.html"" , scr_html ) ; } if ( scr_color != - 1 ) { r_config_set_i ( core -> config , ""scr.color"" , scr_color ) ; } core -> fixedblock = false ; return rc ; fail : rc = - 1 ; goto beach ; }",; p = cmd [ 0 ] ? <S2SV_ModStart> + 1 ) : NULL
284,"static struct bpf_verifier_state * push_stack ( struct bpf_verifier_env * env , <S2SV_StartBug> int insn_idx , int prev_insn_idx ) <S2SV_EndBug> { struct bpf_verifier_state * cur = env -> cur_state ; struct bpf_verifier_stack_elem * elem ; int err ; elem = kzalloc ( sizeof ( struct bpf_verifier_stack_elem ) , GFP_KERNEL ) ; if ( ! elem ) goto err ; elem -> insn_idx = insn_idx ; elem -> prev_insn_idx = prev_insn_idx ; elem -> next = env -> head ; env -> head = elem ; env -> stack_size ++ ; err = copy_verifier_state ( & elem -> st , cur ) ; if ( err ) <S2SV_StartBug> goto err ; <S2SV_EndBug> if ( env -> stack_size > BPF_COMPLEXITY_LIMIT_STACK ) { verbose ( env , ""BPF<S2SV_blank>program<S2SV_blank>is<S2SV_blank>too<S2SV_blank>complex\\n"" ) ; goto err ; } return & elem -> st ; err : free_verifier_state ( env -> cur_state , true ) ; env -> cur_state = NULL ; while ( ! pop_stack ( env , NULL , NULL ) ) ; return NULL ; }",", int prev_insn_idx , bool speculative <S2SV_ModStart> ) goto err ; elem -> st . speculative |= speculative"
285,"int main ( int argc , char * * argv ) { int fd = xopen ( ""/dev/null"" , O_RDWR ) ; while ( fd < 2 ) fd = xdup ( fd ) ; if ( fd > 2 ) close ( fd ) ; if ( argc < 8 ) { error_msg_and_die ( ""Usage:<S2SV_blank>%s<S2SV_blank>SIGNO<S2SV_blank>CORE_SIZE_LIMIT<S2SV_blank>PID<S2SV_blank>UID<S2SV_blank>GID<S2SV_blank>TIME<S2SV_blank>BINARY_NAME<S2SV_blank>[HOSTNAME]"" , argv [ 0 ] ) ; } if ( strchr ( argv [ 1 ] , '<S2SV_blank>' ) ) { int i ; for ( i = 1 ; argv [ i ] ; i ++ ) { strchrnul ( argv [ i ] , '<S2SV_blank>' ) [ 0 ] = '\\0' ; } } logmode = LOGMODE_JOURNAL ; load_abrt_conf ( ) ; bool setting_MakeCompatCore ; bool setting_SaveBinaryImage ; { map_string_t * settings = new_map_string ( ) ; load_abrt_plugin_conf_file ( ""CCpp.conf"" , settings ) ; const char * value ; value = get_map_string_item_or_NULL ( settings , ""MakeCompatCore"" ) ; setting_MakeCompatCore = value && string_to_bool ( value ) ; value = get_map_string_item_or_NULL ( settings , ""SaveBinaryImage"" ) ; setting_SaveBinaryImage = value && string_to_bool ( value ) ; value = get_map_string_item_or_NULL ( settings , ""VerboseLog"" ) ; if ( value ) g_verbose = xatoi_positive ( value ) ; free_map_string ( settings ) ; } errno = 0 ; const char * signal_str = argv [ 1 ] ; int signal_no = xatoi_positive ( signal_str ) ; off_t ulimit_c = strtoull ( argv [ 2 ] , NULL , 10 ) ; if ( ulimit_c < 0 ) { ulimit_c = ~ ( ( off_t ) 1 << ( sizeof ( off_t ) * 8 - 1 ) ) ; } const char * pid_str = argv [ 3 ] ; pid_t pid = xatoi_positive ( argv [ 3 ] ) ; uid_t uid = xatoi_positive ( argv [ 4 ] ) ; if ( errno || pid <= 0 ) { perror_msg_and_die ( ""PID<S2SV_blank>\'%s\'<S2SV_blank>or<S2SV_blank>limit<S2SV_blank>\'%s\'<S2SV_blank>is<S2SV_blank>bogus"" , argv [ 3 ] , argv [ 2 ] ) ; } { char * s = xmalloc_fopen_fgetline_fclose ( VAR_RUN ""/abrt/saved_core_pattern"" ) ; if ( s && s [ 0 ] != '|' ) core_basename = s ; else free ( s ) ; } struct utsname uts ; if ( ! argv [ 8 ] ) { uname ( & uts ) ; argv [ 8 ] = uts . nodename ; } char path [ PATH_MAX ] ; int src_fd_binary = - 1 ; char * executable = get_executable ( pid , setting_SaveBinaryImage ? & src_fd_binary : NULL ) ; if ( executable && strstr ( executable , ""/abrt-hook-ccpp"" ) ) { error_msg_and_die ( ""PID<S2SV_blank>%lu<S2SV_blank>is<S2SV_blank>\'%s\',<S2SV_blank>not<S2SV_blank>dumping<S2SV_blank>it<S2SV_blank>to<S2SV_blank>avoid<S2SV_blank>recursion"" , ( long ) pid , executable ) ; } user_pwd = get_cwd ( pid ) ; log_notice ( ""user_pwd:\'%s\'"" , user_pwd ) ; sprintf ( path , ""/proc/%lu/status"" , ( long ) pid ) ; proc_pid_status = xmalloc_xopen_read_close ( path , NULL ) ; uid_t fsuid = uid ; uid_t tmp_fsuid = get_fsuid ( ) ; int suid_policy = dump_suid_policy ( ) ; if ( tmp_fsuid != uid ) { fsuid = 0 ; if ( suid_policy == DUMP_SUID_UNSAFE ) { fsuid = tmp_fsuid ; } } if ( setting_MakeCompatCore && ulimit_c != 0 ) user_core_fd = open_user_core ( uid , fsuid , pid , & argv [ 1 ] ) ; if ( executable == NULL ) { error_msg ( ""Can\'t<S2SV_blank>read<S2SV_blank>/proc/%lu/exe<S2SV_blank>link"" , ( long ) pid ) ; goto create_user_core ; } const char * signame = NULL ; switch ( signal_no ) { case SIGILL : signame = ""ILL"" ; break ; case SIGFPE : signame = ""FPE"" ; break ; case SIGSEGV : signame = ""SEGV"" ; break ; case SIGBUS : signame = ""BUS"" ; break ; case SIGABRT : signame = ""ABRT"" ; break ; case SIGTRAP : signame = ""TRAP"" ; break ; default : goto create_user_core ; } if ( ! daemon_is_ok ( ) ) { log ( ""abrtd<S2SV_blank>is<S2SV_blank>not<S2SV_blank>running.<S2SV_blank>If<S2SV_blank>it<S2SV_blank>crashed,<S2SV_blank>"" ""/proc/sys/kernel/core_pattern<S2SV_blank>contains<S2SV_blank>a<S2SV_blank>stale<S2SV_blank>value,<S2SV_blank>"" ""consider<S2SV_blank>resetting<S2SV_blank>it<S2SV_blank>to<S2SV_blank>\'core\'"" ) ; goto create_user_core ; } if ( g_settings_nMaxCrashReportsSize > 0 ) { if ( low_free_space ( g_settings_nMaxCrashReportsSize , g_settings_dump_location ) ) goto create_user_core ; } snprintf ( path , sizeof ( path ) , ""%s/last-ccpp"" , g_settings_dump_location ) ; if ( check_recent_crash_file ( path , executable ) ) { goto create_user_core ; } const char * last_slash = strrchr ( executable , '/' ) ; if ( last_slash && strncmp ( ++ last_slash , ""abrt"" , 4 ) == 0 ) { snprintf ( path , sizeof ( path ) , ""%s/%s-coredump"" , g_settings_dump_location , last_slash ) ; int abrt_core_fd = xopen3 ( path , O_WRONLY | O_CREAT | O_TRUNC , 0600 ) ; off_t core_size = copyfd_eof ( STDIN_FILENO , abrt_core_fd , COPYFD_SPARSE ) ; if ( core_size < 0 || fsync ( abrt_core_fd ) != 0 ) { unlink ( path ) ; error_msg_and_die ( ""Error<S2SV_blank>saving<S2SV_blank>\'%s\'"" , path ) ; } log ( ""Saved<S2SV_blank>core<S2SV_blank>dump<S2SV_blank>of<S2SV_blank>pid<S2SV_blank>%lu<S2SV_blank>(%s)<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>(%llu<S2SV_blank>bytes)"" , ( long ) pid , executable , path , ( long long ) core_size ) ; return 0 ; } unsigned path_len = snprintf ( path , sizeof ( path ) , ""%s/ccpp-%s-%lu.new"" , g_settings_dump_location , iso_date_string ( NULL ) , ( long ) pid ) ; if ( path_len >= ( sizeof ( path ) - sizeof ( ""/"" FILENAME_COREDUMP ) ) ) { goto create_user_core ; } dd = dd_create ( path , fsuid , DEFAULT_DUMP_DIR_MODE ) ; if ( dd ) { char * rootdir = get_rootdir ( pid ) ; dd_create_basic_files ( dd , fsuid , ( rootdir && strcmp ( rootdir , ""/"" ) != 0 ) ? rootdir : NULL ) ; char source_filename [ sizeof ( ""/proc/%lu/somewhat_long_name"" ) + sizeof ( long ) * 3 ] ; int source_base_ofs = sprintf ( source_filename , ""/proc/%lu/smaps"" , ( long ) pid ) ; source_base_ofs -= strlen ( ""smaps"" ) ; char * dest_filename = concat_path_file ( dd -> dd_dirname , ""also_somewhat_longish_name"" ) ; char * dest_base = strrchr ( dest_filename , '/' ) + 1 ; strcpy ( source_filename + source_base_ofs , ""maps"" ) ; strcpy ( dest_base , FILENAME_MAPS ) ; <S2SV_StartBug> copy_file ( source_filename , dest_filename , DEFAULT_DUMP_DIR_MODE ) ; <S2SV_EndBug> <S2SV_StartBug> IGNORE_RESULT ( chown ( dest_filename , dd -> dd_uid , dd -> dd_gid ) ) ; <S2SV_EndBug> strcpy ( source_filename + source_base_ofs , ""limits"" ) ; strcpy ( dest_base , FILENAME_LIMITS ) ; <S2SV_StartBug> copy_file ( source_filename , dest_filename , DEFAULT_DUMP_DIR_MODE ) ; <S2SV_EndBug> <S2SV_StartBug> IGNORE_RESULT ( chown ( dest_filename , dd -> dd_uid , dd -> dd_gid ) ) ; <S2SV_EndBug> strcpy ( source_filename + source_base_ofs , ""cgroup"" ) ; strcpy ( dest_base , FILENAME_CGROUP ) ; <S2SV_StartBug> copy_file ( source_filename , dest_filename , DEFAULT_DUMP_DIR_MODE ) ; <S2SV_EndBug> <S2SV_StartBug> IGNORE_RESULT ( chown ( dest_filename , dd -> dd_uid , dd -> dd_gid ) ) ; <S2SV_EndBug> strcpy ( dest_base , FILENAME_OPEN_FDS ) ; <S2SV_StartBug> if ( dump_fd_info ( dest_filename , source_filename , source_base_ofs ) ) <S2SV_EndBug> <S2SV_StartBug> IGNORE_RESULT ( chown ( dest_filename , dd -> dd_uid , dd -> dd_gid ) ) ; <S2SV_EndBug> free ( dest_filename ) ; dd_save_text ( dd , FILENAME_ANALYZER , ""CCpp"" ) ; dd_save_text ( dd , FILENAME_TYPE , ""CCpp"" ) ; dd_save_text ( dd , FILENAME_EXECUTABLE , executable ) ; dd_save_text ( dd , FILENAME_PID , pid_str ) ; dd_save_text ( dd , FILENAME_PROC_PID_STATUS , proc_pid_status ) ; if ( user_pwd ) dd_save_text ( dd , FILENAME_PWD , user_pwd ) ; if ( rootdir ) { if ( strcmp ( rootdir , ""/"" ) != 0 ) dd_save_text ( dd , FILENAME_ROOTDIR , rootdir ) ; } char * reason = xasprintf ( ""%s<S2SV_blank>killed<S2SV_blank>by<S2SV_blank>SIG%s"" , last_slash , signame ? signame : signal_str ) ; dd_save_text ( dd , FILENAME_REASON , reason ) ; free ( reason ) ; char * cmdline = get_cmdline ( pid ) ; dd_save_text ( dd , FILENAME_CMDLINE , cmdline ? : """" ) ; free ( cmdline ) ; char * environ = get_environ ( pid ) ; dd_save_text ( dd , FILENAME_ENVIRON , environ ? : """" ) ; free ( environ ) ; char * fips_enabled = xmalloc_fopen_fgetline_fclose ( ""/proc/sys/crypto/fips_enabled"" ) ; if ( fips_enabled ) { if ( strcmp ( fips_enabled , ""0"" ) != 0 ) dd_save_text ( dd , ""fips_enabled"" , fips_enabled ) ; free ( fips_enabled ) ; } dd_save_text ( dd , FILENAME_ABRT_VERSION , VERSION ) ; if ( src_fd_binary > 0 ) { strcpy ( path + path_len , ""/"" FILENAME_BINARY ) ; int dst_fd = create_or_die ( path ) ; off_t sz = copyfd_eof ( src_fd_binary , dst_fd , COPYFD_SPARSE ) ; if ( fsync ( dst_fd ) != 0 || close ( dst_fd ) != 0 || sz < 0 ) { dd_delete ( dd ) ; error_msg_and_die ( ""Error<S2SV_blank>saving<S2SV_blank>\'%s\'"" , path ) ; } close ( src_fd_binary ) ; } strcpy ( path + path_len , ""/"" FILENAME_COREDUMP ) ; int abrt_core_fd = create_or_die ( path ) ; off_t core_size = copyfd_sparse ( STDIN_FILENO , abrt_core_fd , user_core_fd , ulimit_c ) ; if ( fsync ( abrt_core_fd ) != 0 || close ( abrt_core_fd ) != 0 || core_size < 0 ) { unlink ( path ) ; dd_delete ( dd ) ; if ( user_core_fd >= 0 ) { xchdir ( user_pwd ) ; unlink ( core_basename ) ; } error_msg_and_die ( ""Error<S2SV_blank>writing<S2SV_blank>\'%s\'"" , path ) ; } if ( user_core_fd >= 0 && ( fsync ( user_core_fd ) != 0 || close ( user_core_fd ) != 0 || ( ulimit_c == 0 || core_size > ulimit_c ) ) ) { xchdir ( user_pwd ) ; unlink ( core_basename ) ; } { char * java_log = xasprintf ( ""/tmp/jvm-%lu/hs_error.log"" , ( long ) pid ) ; int src_fd = open ( java_log , O_RDONLY ) ; free ( java_log ) ; if ( src_fd < 0 ) { java_log = xasprintf ( ""%s/hs_err_pid%lu.log"" , user_pwd , ( long ) pid ) ; src_fd = open ( java_log , O_RDONLY ) ; free ( java_log ) ; } if ( src_fd >= 0 ) { strcpy ( path + path_len , ""/hs_err.log"" ) ; int dst_fd = create_or_die ( path ) ; off_t sz = copyfd_eof ( src_fd , dst_fd , COPYFD_SPARSE ) ; if ( close ( dst_fd ) != 0 || sz < 0 ) { dd_delete ( dd ) ; error_msg_and_die ( ""Error<S2SV_blank>saving<S2SV_blank>\'%s\'"" , path ) ; } close ( src_fd ) ; } } dd_close ( dd ) ; path [ path_len ] = '\\0' ; char * newpath = xstrndup ( path , path_len - ( sizeof ( "".new"" ) - 1 ) ) ; if ( rename ( path , newpath ) == 0 ) strcpy ( path , newpath ) ; free ( newpath ) ; log ( ""Saved<S2SV_blank>core<S2SV_blank>dump<S2SV_blank>of<S2SV_blank>pid<S2SV_blank>%lu<S2SV_blank>(%s)<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>(%llu<S2SV_blank>bytes)"" , ( long ) pid , executable , path , ( long long ) core_size ) ; notify_new_path ( path ) ; if ( g_settings_nMaxCrashReportsSize > 0 ) { unsigned maxsize = g_settings_nMaxCrashReportsSize + g_settings_nMaxCrashReportsSize / 4 ; maxsize |= 63 ; trim_problem_dirs ( g_settings_dump_location , maxsize * ( double ) ( 1024 * 1024 ) , path ) ; } free ( rootdir ) ; return 0 ; } create_user_core : if ( user_core_fd >= 0 ) { off_t core_size = copyfd_size ( STDIN_FILENO , user_core_fd , ulimit_c , COPYFD_SPARSE ) ; if ( fsync ( user_core_fd ) != 0 || close ( user_core_fd ) != 0 || core_size < 0 ) { perror_msg ( ""Error<S2SV_blank>writing<S2SV_blank>\'%s\'"" , full_core_basename ) ; xchdir ( user_pwd ) ; unlink ( core_basename ) ; return 1 ; } if ( ulimit_c == 0 || core_size > ulimit_c ) { xchdir ( user_pwd ) ; unlink ( core_basename ) ; return 1 ; } log ( ""Saved<S2SV_blank>core<S2SV_blank>dump<S2SV_blank>of<S2SV_blank>pid<S2SV_blank>%lu<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>(%llu<S2SV_blank>bytes)"" , ( long ) pid , full_core_basename , ( long long ) core_size ) ; } return 0 ; }","FILENAME_MAPS ) ; copy_file_ext <S2SV_ModEnd> ( source_filename , <S2SV_ModStart> , dest_filename , 0640 <S2SV_ModEnd> , dd -> <S2SV_ModStart> dd -> dd_gid , O_RDONLY , O_WRONLY | O_CREAT | O_TRUNC | O_EXCL <S2SV_ModEnd> ) ; strcpy <S2SV_ModStart> FILENAME_LIMITS ) ; copy_file_ext <S2SV_ModEnd> ( source_filename , <S2SV_ModStart> , dest_filename , 0640 <S2SV_ModEnd> , dd -> <S2SV_ModStart> dd -> dd_gid , O_RDONLY , O_WRONLY | O_CREAT | O_TRUNC | O_EXCL <S2SV_ModEnd> ) ; strcpy <S2SV_ModStart> FILENAME_CGROUP ) ; copy_file_ext <S2SV_ModEnd> ( source_filename , <S2SV_ModStart> , dest_filename , 0640 <S2SV_ModEnd> , dd -> <S2SV_ModStart> dd -> dd_gid , O_RDONLY , O_WRONLY | O_CREAT | O_TRUNC | O_EXCL <S2SV_ModEnd> ) ; strcpy <S2SV_ModStart> FILENAME_OPEN_FDS ) ; <S2SV_ModEnd> dump_fd_info ( dest_filename <S2SV_ModStart> source_filename , source_base_ofs <S2SV_ModEnd> , dd -> <S2SV_ModStart> dd -> dd_gid <S2SV_ModEnd> ) ; free"
286,"static int raw_recvmsg ( struct kiocb * iocb , struct sock * sk , struct msghdr * msg , size_t len , int noblock , int flags , int * addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; size_t copied = 0 ; int err = - EOPNOTSUPP ; struct sockaddr_in * sin = ( struct sockaddr_in * ) msg -> msg_name ; struct sk_buff * skb ; if ( flags & MSG_OOB ) <S2SV_StartBug> goto out ; <S2SV_EndBug> if ( addr_len ) * addr_len = sizeof ( * sin ) ; if ( flags & MSG_ERRQUEUE ) { err = ip_recv_error ( sk , msg , len ) ; goto out ; } skb = skb_recv_datagram ( sk , flags , noblock , & err ) ; if ( ! skb ) goto out ; copied = skb -> len ; if ( len < copied ) { msg -> msg_flags |= MSG_TRUNC ; copied = len ; } err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; if ( err ) goto done ; sock_recv_ts_and_drops ( msg , sk , skb ) ; if ( sin ) { sin -> sin_family = AF_INET ; sin -> sin_addr . s_addr = ip_hdr ( skb ) -> saddr ; sin -> sin_port = 0 ; memset ( & sin -> sin_zero , 0 , sizeof ( sin -> sin_zero ) ) ; <S2SV_StartBug> } <S2SV_EndBug> if ( inet -> cmsg_flags ) ip_cmsg_recv ( msg , skb ) ; if ( flags & MSG_TRUNC ) copied = skb -> len ; done : skb_free_datagram ( sk , skb ) ; out : if ( err ) return err ; return copied ; }",) goto out <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) ) ; * addr_len = sizeof ( * sin ) ;
287,"static int _gd2GetHeader ( gdIOCtxPtr in , int * sx , int * sy , int * cs , int * vers , int * fmt , int * ncx , int * ncy , t_chunk_info * * chunkIdx ) { int i ; int ch ; char id [ 5 ] ; t_chunk_info * cidx ; int sidx ; int nc ; GD2_DBG ( php_gd_error ( ""Reading<S2SV_blank>gd2<S2SV_blank>header<S2SV_blank>info"" ) ) ; for ( i = 0 ; i < 4 ; i ++ ) { ch = gdGetC ( in ) ; if ( ch == EOF ) { goto fail1 ; } id [ i ] = ch ; } id [ 4 ] = 0 ; GD2_DBG ( php_gd_error ( ""Got<S2SV_blank>file<S2SV_blank>code:<S2SV_blank>%s"" , id ) ) ; if ( strcmp ( id , GD2_ID ) != 0 ) { GD2_DBG ( php_gd_error ( ""Not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>gd2<S2SV_blank>file"" ) ) ; goto fail1 ; } if ( gdGetWord ( vers , in ) != 1 ) { goto fail1 ; } GD2_DBG ( php_gd_error ( ""Version:<S2SV_blank>%d"" , * vers ) ) ; if ( ( * vers != 1 ) && ( * vers != 2 ) ) { GD2_DBG ( php_gd_error ( ""Bad<S2SV_blank>version:<S2SV_blank>%d"" , * vers ) ) ; goto fail1 ; } if ( ! gdGetWord ( sx , in ) ) { GD2_DBG ( php_gd_error ( ""Could<S2SV_blank>not<S2SV_blank>get<S2SV_blank>x-size"" ) ) ; goto fail1 ; } if ( ! gdGetWord ( sy , in ) ) { GD2_DBG ( php_gd_error ( ""Could<S2SV_blank>not<S2SV_blank>get<S2SV_blank>y-size"" ) ) ; goto fail1 ; } GD2_DBG ( php_gd_error ( ""Image<S2SV_blank>is<S2SV_blank>%dx%d"" , * sx , * sy ) ) ; if ( gdGetWord ( cs , in ) != 1 ) { goto fail1 ; } GD2_DBG ( php_gd_error ( ""ChunkSize:<S2SV_blank>%d"" , * cs ) ) ; if ( ( * cs < GD2_CHUNKSIZE_MIN ) || ( * cs > GD2_CHUNKSIZE_MAX ) ) { GD2_DBG ( php_gd_error ( ""Bad<S2SV_blank>chunk<S2SV_blank>size:<S2SV_blank>%d"" , * cs ) ) ; goto fail1 ; } if ( gdGetWord ( fmt , in ) != 1 ) { goto fail1 ; } GD2_DBG ( php_gd_error ( ""Format:<S2SV_blank>%d"" , * fmt ) ) ; if ( ( * fmt != GD2_FMT_RAW ) && ( * fmt != GD2_FMT_COMPRESSED ) && ( * fmt != GD2_FMT_TRUECOLOR_RAW ) && ( * fmt != GD2_FMT_TRUECOLOR_COMPRESSED ) ) { GD2_DBG ( php_gd_error ( ""Bad<S2SV_blank>data<S2SV_blank>format:<S2SV_blank>%d"" , * fmt ) ) ; goto fail1 ; } if ( gdGetWord ( ncx , in ) != 1 ) { goto fail1 ; } GD2_DBG ( php_gd_error ( ""%d<S2SV_blank>Chunks<S2SV_blank>Wide"" , * ncx ) ) ; if ( gdGetWord ( ncy , in ) != 1 ) { goto fail1 ; } GD2_DBG ( php_gd_error ( ""%d<S2SV_blank>Chunks<S2SV_blank>vertically"" , * ncy ) ) ; if ( gd2_compressed ( * fmt ) ) { nc = ( * ncx ) * ( * ncy ) ; GD2_DBG ( php_gd_error ( ""Reading<S2SV_blank>%d<S2SV_blank>chunk<S2SV_blank>index<S2SV_blank>entries"" , nc ) ) ; <S2SV_StartBug> sidx = sizeof ( t_chunk_info ) * nc ; <S2SV_EndBug> if ( sidx <= 0 ) { goto fail1 ; } <S2SV_StartBug> cidx = gdCalloc ( sidx , 1 ) ; <S2SV_EndBug> for ( i = 0 ; i < nc ; i ++ ) { if ( gdGetInt ( & cidx [ i ] . offset , in ) != 1 ) { gdFree ( cidx ) ; goto fail1 ; } if ( gdGetInt ( & cidx [ i ] . size , in ) != 1 ) { gdFree ( cidx ) ; goto fail1 ; } if ( cidx [ i ] . offset < 0 || cidx [ i ] . size < 0 ) { gdFree ( cidx ) ; goto fail1 ; } } * chunkIdx = cidx ; } GD2_DBG ( php_gd_error ( ""gd2<S2SV_blank>header<S2SV_blank>complete"" ) ) ; return 1 ; fail1 : return 0 ; }",") ) ; if ( overflow2 ( sidx , nc ) ) { goto fail1 ; } <S2SV_ModStart> 1 ) ; if ( cidx == NULL ) { goto fail1 ; }"
288,"static int l2cap_parse_conf_req ( struct sock * sk , void * data ) { struct l2cap_pinfo * pi = l2cap_pi ( sk ) ; struct l2cap_conf_rsp * rsp = data ; void * ptr = rsp -> data ; void * req = pi -> conf_req ; int len = pi -> conf_len ; int type , hint , olen ; unsigned long val ; struct l2cap_conf_rfc rfc = { . mode = L2CAP_MODE_BASIC } ; u16 mtu = L2CAP_DEFAULT_MTU ; u16 result = L2CAP_CONF_SUCCESS ; BT_DBG ( ""sk<S2SV_blank>%p"" , sk ) ; while ( len >= L2CAP_CONF_OPT_SIZE ) { len -= l2cap_get_conf_opt ( & req , & type , & olen , & val ) ; hint = type & L2CAP_CONF_HINT ; type &= L2CAP_CONF_MASK ; switch ( type ) { case L2CAP_CONF_MTU : mtu = val ; break ; case L2CAP_CONF_FLUSH_TO : pi -> flush_to = val ; break ; case L2CAP_CONF_QOS : break ; case L2CAP_CONF_RFC : if ( olen == sizeof ( rfc ) ) memcpy ( & rfc , ( void * ) val , olen ) ; break ; default : if ( hint ) break ; result = L2CAP_CONF_UNKNOWN ; * ( ( u8 * ) ptr ++ ) = type ; break ; } } <S2SV_StartBug> if ( result == L2CAP_CONF_SUCCESS ) { <S2SV_EndBug> <S2SV_StartBug> if ( rfc . mode == L2CAP_MODE_BASIC ) { <S2SV_EndBug> <S2SV_StartBug> if ( mtu < pi -> omtu ) <S2SV_EndBug> result = L2CAP_CONF_UNACCEPT ; <S2SV_StartBug> else { <S2SV_EndBug> pi -> omtu = mtu ; pi -> conf_state |= L2CAP_CONF_OUTPUT_DONE ; <S2SV_StartBug> } <S2SV_EndBug> l2cap_add_conf_opt ( & ptr , L2CAP_CONF_MTU , 2 , pi -> omtu ) ; } else { result = L2CAP_CONF_UNACCEPT ; memset ( & rfc , 0 , sizeof ( rfc ) ) ; rfc . mode = L2CAP_MODE_BASIC ; l2cap_add_conf_opt ( & ptr , L2CAP_CONF_RFC , sizeof ( rfc ) , ( unsigned long ) & rfc ) ; } } rsp -> scid = cpu_to_le16 ( pi -> dcid ) ; rsp -> result = cpu_to_le16 ( result ) ; rsp -> flags = cpu_to_le16 ( 0x0000 ) ; return ptr - data ; }","} if ( pi -> num_conf_rsp || pi -> num_conf_req ) goto done ; switch ( pi -> mode ) { case L2CAP_MODE_STREAMING : case L2CAP_MODE_ERTM : pi -> conf_state |= L2CAP_CONF_STATE2_DEVICE ; if ( ! l2cap_mode_supported ( pi -> mode , pi -> conn -> feat_mask ) ) return - ECONNREFUSED ; break ; default : pi -> mode = l2cap_select_mode ( rfc . mode , pi -> conn -> feat_mask ) ; break ; } done : if ( pi -> mode != rfc . mode ) { result = L2CAP_CONF_UNACCEPT ; rfc . mode = pi -> mode ; if ( pi -> num_conf_rsp == 1 ) return - ECONNREFUSED ; l2cap_add_conf_opt ( & ptr , L2CAP_CONF_RFC , sizeof ( rfc ) , ( unsigned long ) & rfc ) ; } if ( <S2SV_ModStart> { if ( mtu < L2CAP_DEFAULT_MIN_MTU ) result = L2CAP_CONF_UNACCEPT ; else { <S2SV_ModEnd> pi -> omtu <S2SV_ModStart> pi -> omtu = mtu ; pi -> conf_state |= L2CAP_CONF_MTU_DONE ; } l2cap_add_conf_opt ( & ptr , L2CAP_CONF_MTU , 2 , pi -> omtu ) ; switch ( rfc . mode ) { case L2CAP_MODE_BASIC : pi -> fcs = L2CAP_FCS_NONE ; pi -> conf_state |= L2CAP_CONF_MODE_DONE ; break ; case L2CAP_MODE_ERTM : pi -> remote_tx_win = rfc . txwin_size ; pi -> remote_max_tx = rfc . max_transmit ; pi -> max_pdu_size = rfc . max_pdu_size ; rfc . retrans_timeout = L2CAP_DEFAULT_RETRANS_TO ; rfc . monitor_timeout = L2CAP_DEFAULT_MONITOR_TO ; pi -> conf_state |= L2CAP_CONF_MODE_DONE ; break ; case L2CAP_MODE_STREAMING : pi -> remote_tx_win = rfc . txwin_size ; pi -> max_pdu_size = rfc . max_pdu_size ; pi -> conf_state |= L2CAP_CONF_MODE_DONE ; break ; default : <S2SV_ModEnd> result = L2CAP_CONF_UNACCEPT <S2SV_ModStart> = L2CAP_CONF_UNACCEPT ; memset ( & rfc , 0 , sizeof ( rfc ) ) ; rfc . mode = pi -> mode ; } l2cap_add_conf_opt ( & ptr , L2CAP_CONF_RFC , sizeof ( rfc ) , ( unsigned long ) & rfc ) ; if ( result == L2CAP_CONF_SUCCESS ) <S2SV_ModEnd> pi -> conf_state <S2SV_ModStart> |= L2CAP_CONF_OUTPUT_DONE ; <S2SV_ModEnd> } rsp ->"
289,"static int inv_remap_prob ( int v , int m ) { <S2SV_StartBug> static int inv_map_table [ MAX_PROB - 1 ] = { <S2SV_EndBug> <S2SV_StartBug> 6 , 19 , 32 , 45 , 58 , 71 , 84 , 97 , 110 , 123 , 136 , 149 , 162 , 175 , 188 , <S2SV_EndBug> 201 , 214 , 227 , 240 , 253 , 0 , 1 , 2 , 3 , 4 , 5 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 33 , 34 , 35 , 36 , 37 , 38 , 39 , 40 , 41 , 42 , 43 , 44 , 46 , 47 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 59 , 60 , 61 , 62 , 63 , 64 , 65 , 66 , 67 , 68 , 69 , 70 , 72 , 73 , 74 , 75 , 76 , 77 , 78 , 79 , 80 , 81 , 82 , 83 , 85 , 86 , 87 , 88 , 89 , 90 , 91 , 92 , 93 , 94 , 95 , 96 , 98 , 99 , 100 , 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 , 119 , 120 , 121 , 122 , 124 , 125 , 126 , 127 , 128 , 129 , 130 , 131 , 132 , 133 , 134 , 135 , 137 , 138 , 139 , 140 , 141 , 142 , 143 , 144 , 145 , 146 , 147 , 148 , 150 , 151 , 152 , 153 , 154 , 155 , 156 , 157 , 158 , 159 , 160 , 161 , 163 , 164 , 165 , 166 , 167 , 168 , 169 , 170 , 171 , 172 , 173 , 174 , 176 , 177 , 178 , 179 , 180 , 181 , 182 , 183 , 184 , 185 , 186 , 187 , 189 , 190 , 191 , 192 , 193 , 194 , 195 , 196 , 197 , 198 , 199 , 200 , 202 , 203 , 204 , 205 , 206 , 207 , 208 , 209 , 210 , 211 , 212 , 213 , 215 , 216 , 217 , 218 , 219 , 220 , 221 , 222 , 223 , 224 , 225 , 226 , 228 , 229 , 230 , 231 , 232 , 233 , 234 , 235 , 236 , 237 , 238 , 239 , 241 , 242 , 243 , 244 , 245 , 246 , 247 , 248 , 249 , 250 , 251 , 252 } ; v = clamp ( v , 0 , 253 ) ; v = inv_map_table [ v ] ; m -- ; if ( ( m << 1 ) <= MAX_PROB ) { <S2SV_StartBug> return 1 + inv_recenter_nonneg ( v + 1 , m ) ; <S2SV_EndBug> } else { <S2SV_StartBug> return MAX_PROB - inv_recenter_nonneg ( v + 1 , MAX_PROB - 1 - m ) ; <S2SV_EndBug> } }","inv_map_table [ MAX_PROB <S2SV_ModEnd> ] = { <S2SV_ModStart> ] = { 7 , 20 , 33 , 46 , 59 , 72 , 85 , 98 , 111 , 124 , 137 , 150 , 163 , 176 , 189 , 202 , 215 , 228 , 241 , 254 , 1 , 2 , 3 , 4 , 5 , 6 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 34 , 35 , 36 , 37 , 38 , 39 , 40 , 41 , 42 , 43 , 44 , 45 , 47 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 60 , 61 , 62 , 63 , 64 , 65 , 66 , 67 , 68 , 69 , 70 , 71 , 73 , 74 , 75 , 76 , 77 , 78 , 79 , 80 , 81 , 82 , 83 , 84 , 86 , 87 , 88 , 89 , 90 , 91 , 92 , 93 , 94 , 95 , 96 , 97 , 99 , 100 , 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 112 , 113 , 114 , 115 , 116 , 117 , 118 , 119 , 120 , 121 , 122 , 123 , 125 , 126 , 127 , 128 , 129 , 130 , 131 , 132 , 133 , 134 , 135 , 136 , 138 , 139 , 140 , 141 , 142 , 143 , 144 , 145 , 146 , 147 , 148 , 149 , 151 , 152 , 153 , 154 , 155 , 156 , 157 , 158 , 159 , 160 , 161 , 162 , 164 , 165 , 166 , 167 , 168 , 169 , 170 , 171 , 172 , 173 , 174 , 175 , 177 , 178 , 179 , 180 , 181 , 182 , 183 , 184 , 185 , 186 , 187 , 188 , 190 , 191 , 192 , 193 , 194 , 195 , 196 , 197 , 198 , 199 , 200 , 201 , 203 , 204 , 205 , 206 , 207 , 208 , 209 , 210 , 211 , 212 , 213 , 214 , 216 , 217 , 218 , 219 , 220 , 221 , 222 , 223 , 224 , 225 , 226 , 227 , 229 , 230 , 231 , 232 , 233 , 234 , 235 , 236 , 237 , 238 , 239 , 240 , 242 , 243 , 244 , 245 , 246 , 247 , 248 , 249 , 250 , 251 , 252 , 253 , 253 } ; assert ( v < ( int ) ( sizeof ( inv_map_table ) / sizeof ( inv_map_table [ 0 ] ) ) <S2SV_ModEnd> ) ; v <S2SV_ModStart> inv_recenter_nonneg ( v <S2SV_ModEnd> , m ) <S2SV_ModStart> inv_recenter_nonneg ( v <S2SV_ModEnd> , MAX_PROB -"
290,"int tcp_rcv_state_process ( struct sock * sk , struct sk_buff * skb , const struct tcphdr * th , unsigned int len ) { struct tcp_sock * tp = tcp_sk ( sk ) ; struct inet_connection_sock * icsk = inet_csk ( sk ) ; int queued = 0 ; int res ; tp -> rx_opt . saw_tstamp = 0 ; switch ( sk -> sk_state ) { case TCP_CLOSE : goto discard ; case TCP_LISTEN : if ( th -> ack ) return 1 ; if ( th -> rst ) goto discard ; if ( th -> syn ) { <S2SV_StartBug> if ( icsk -> icsk_af_ops -> conn_request ( sk , skb ) < 0 ) <S2SV_EndBug> return 1 ; kfree_skb ( skb ) ; return 0 ; } goto discard ; case TCP_SYN_SENT : queued = tcp_rcv_synsent_state_process ( sk , skb , th , len ) ; if ( queued >= 0 ) return queued ; tcp_urg ( sk , skb , th ) ; __kfree_skb ( skb ) ; tcp_data_snd_check ( sk ) ; return 0 ; } res = tcp_validate_incoming ( sk , skb , th , 0 ) ; if ( res <= 0 ) return - res ; if ( th -> ack ) { int acceptable = tcp_ack ( sk , skb , FLAG_SLOWPATH ) > 0 ; switch ( sk -> sk_state ) { case TCP_SYN_RECV : if ( acceptable ) { tp -> copied_seq = tp -> rcv_nxt ; smp_mb ( ) ; tcp_set_state ( sk , TCP_ESTABLISHED ) ; sk -> sk_state_change ( sk ) ; if ( sk -> sk_socket ) sk_wake_async ( sk , SOCK_WAKE_IO , POLL_OUT ) ; tp -> snd_una = TCP_SKB_CB ( skb ) -> ack_seq ; tp -> snd_wnd = ntohs ( th -> window ) << tp -> rx_opt . snd_wscale ; tcp_init_wl ( tp , TCP_SKB_CB ( skb ) -> seq ) ; if ( tp -> rx_opt . tstamp_ok ) tp -> advmss -= TCPOLEN_TSTAMP_ALIGNED ; icsk -> icsk_af_ops -> rebuild_header ( sk ) ; tcp_init_metrics ( sk ) ; tcp_init_congestion_control ( sk ) ; tp -> lsndtime = tcp_time_stamp ; tcp_mtup_init ( sk ) ; tcp_initialize_rcv_mss ( sk ) ; tcp_init_buffer_space ( sk ) ; tcp_fast_path_on ( tp ) ; } else { return 1 ; } break ; case TCP_FIN_WAIT1 : if ( tp -> snd_una == tp -> write_seq ) { tcp_set_state ( sk , TCP_FIN_WAIT2 ) ; sk -> sk_shutdown |= SEND_SHUTDOWN ; dst_confirm ( __sk_dst_get ( sk ) ) ; if ( ! sock_flag ( sk , SOCK_DEAD ) ) sk -> sk_state_change ( sk ) ; else { int tmo ; if ( tp -> linger2 < 0 || ( TCP_SKB_CB ( skb ) -> end_seq != TCP_SKB_CB ( skb ) -> seq && after ( TCP_SKB_CB ( skb ) -> end_seq - th -> fin , tp -> rcv_nxt ) ) ) { tcp_done ( sk ) ; NET_INC_STATS_BH ( sock_net ( sk ) , LINUX_MIB_TCPABORTONDATA ) ; return 1 ; } tmo = tcp_fin_time ( sk ) ; if ( tmo > TCP_TIMEWAIT_LEN ) { inet_csk_reset_keepalive_timer ( sk , tmo - TCP_TIMEWAIT_LEN ) ; } else if ( th -> fin || sock_owned_by_user ( sk ) ) { inet_csk_reset_keepalive_timer ( sk , tmo ) ; } else { tcp_time_wait ( sk , TCP_FIN_WAIT2 , tmo ) ; goto discard ; } } } break ; case TCP_CLOSING : if ( tp -> snd_una == tp -> write_seq ) { tcp_time_wait ( sk , TCP_TIME_WAIT , 0 ) ; goto discard ; } break ; case TCP_LAST_ACK : if ( tp -> snd_una == tp -> write_seq ) { tcp_update_metrics ( sk ) ; tcp_done ( sk ) ; goto discard ; } break ; } } else goto discard ; tcp_urg ( sk , skb , th ) ; switch ( sk -> sk_state ) { case TCP_CLOSE_WAIT : case TCP_CLOSING : case TCP_LAST_ACK : if ( ! before ( TCP_SKB_CB ( skb ) -> seq , tp -> rcv_nxt ) ) break ; case TCP_FIN_WAIT1 : case TCP_FIN_WAIT2 : if ( sk -> sk_shutdown & RCV_SHUTDOWN ) { if ( TCP_SKB_CB ( skb ) -> end_seq != TCP_SKB_CB ( skb ) -> seq && after ( TCP_SKB_CB ( skb ) -> end_seq - th -> fin , tp -> rcv_nxt ) ) { NET_INC_STATS_BH ( sock_net ( sk ) , LINUX_MIB_TCPABORTONDATA ) ; tcp_reset ( sk ) ; return 1 ; } } case TCP_ESTABLISHED : tcp_data_queue ( sk , skb ) ; queued = 1 ; break ; } if ( sk -> sk_state != TCP_CLOSE ) { tcp_data_snd_check ( sk ) ; tcp_ack_snd_check ( sk ) ; } if ( ! queued ) { discard : __kfree_skb ( skb ) ; } return 0 ; }",{ if ( th -> fin ) goto discard ; if (
291,"long keyctl_read_key ( key_serial_t keyid , char __user * buffer , size_t buflen ) { struct key * key ; key_ref_t key_ref ; long ret ; key_ref = lookup_user_key ( keyid , 0 , 0 ) ; if ( IS_ERR ( key_ref ) ) { ret = - ENOKEY ; goto error ; } key = key_ref_to_ptr ( key_ref ) ; ret = key_permission ( key_ref , KEY_NEED_READ ) ; if ( ret == 0 ) goto can_read_key ; if ( ret != - EACCES ) goto error ; if ( ! is_key_possessed ( key_ref ) ) { ret = - EACCES ; goto error2 ; } can_read_key : <S2SV_StartBug> ret = key_validate ( key ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ret == 0 ) { <S2SV_EndBug> ret = - EOPNOTSUPP ; <S2SV_StartBug> if ( key -> type -> read ) { <S2SV_EndBug> down_read ( & key -> sem ) ; <S2SV_StartBug> ret = key -> type -> read ( key , buffer , buflen ) ; <S2SV_EndBug> up_read ( & key -> sem ) ; } } error2 : key_put ( key ) ; error : return ret ; }",": ret = - EOPNOTSUPP ; if ( key -> type -> read ) { down_read ( & key -> sem ) ; ret = <S2SV_ModStart> == 0 ) ret = <S2SV_ModEnd> key -> type <S2SV_ModStart> type -> read ( key , buffer , buflen ) ; up_read <S2SV_ModEnd> ( & key <S2SV_ModStart> sem ) ; <S2SV_ModEnd> } error2 :"
292,"static int llc_ui_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { struct sockaddr_llc * uaddr = ( struct sockaddr_llc * ) msg -> msg_name ; const int nonblock = flags & MSG_DONTWAIT ; struct sk_buff * skb = NULL ; struct sock * sk = sock -> sk ; struct llc_sock * llc = llc_sk ( sk ) ; unsigned long cpu_flags ; size_t copied = 0 ; u32 peek_seq = 0 ; u32 * seq ; unsigned long used ; int target ; <S2SV_StartBug> long timeo ; <S2SV_EndBug> lock_sock ( sk ) ; copied = - ENOTCONN ; if ( unlikely ( sk -> sk_type == SOCK_STREAM && sk -> sk_state == TCP_LISTEN ) ) goto out ; timeo = sock_rcvtimeo ( sk , nonblock ) ; seq = & llc -> copied_seq ; if ( flags & MSG_PEEK ) { peek_seq = llc -> copied_seq ; seq = & peek_seq ; } target = sock_rcvlowat ( sk , flags & MSG_WAITALL , len ) ; copied = 0 ; do { u32 offset ; if ( signal_pending ( current ) ) { if ( copied ) break ; copied = timeo ? sock_intr_errno ( timeo ) : - EAGAIN ; break ; } skb = skb_peek ( & sk -> sk_receive_queue ) ; if ( skb ) { offset = * seq ; goto found_ok_skb ; } if ( copied >= target && ! sk -> sk_backlog . tail ) break ; if ( copied ) { if ( sk -> sk_err || sk -> sk_state == TCP_CLOSE || ( sk -> sk_shutdown & RCV_SHUTDOWN ) || ! timeo || ( flags & MSG_PEEK ) ) break ; } else { if ( sock_flag ( sk , SOCK_DONE ) ) break ; if ( sk -> sk_err ) { copied = sock_error ( sk ) ; break ; } if ( sk -> sk_shutdown & RCV_SHUTDOWN ) break ; if ( sk -> sk_type == SOCK_STREAM && sk -> sk_state == TCP_CLOSE ) { if ( ! sock_flag ( sk , SOCK_DONE ) ) { copied = - ENOTCONN ; break ; } break ; } if ( ! timeo ) { copied = - EAGAIN ; break ; } } if ( copied >= target ) { release_sock ( sk ) ; lock_sock ( sk ) ; } else sk_wait_data ( sk , & timeo ) ; if ( ( flags & MSG_PEEK ) && peek_seq != llc -> copied_seq ) { net_dbg_ratelimited ( ""LLC(%s:%d):<S2SV_blank>Application<S2SV_blank>bug,<S2SV_blank>race<S2SV_blank>in<S2SV_blank>MSG_PEEK\\n"" , current -> comm , task_pid_nr ( current ) ) ; peek_seq = llc -> copied_seq ; } continue ; found_ok_skb : used = skb -> len - offset ; if ( len < used ) used = len ; if ( ! ( flags & MSG_TRUNC ) ) { int rc = skb_copy_datagram_iovec ( skb , offset , msg -> msg_iov , used ) ; if ( rc ) { if ( ! copied ) copied = - EFAULT ; break ; } } * seq += used ; copied += used ; len -= used ; if ( sk -> sk_type != SOCK_STREAM ) goto copy_uaddr ; if ( ! ( flags & MSG_PEEK ) ) { spin_lock_irqsave ( & sk -> sk_receive_queue . lock , cpu_flags ) ; sk_eat_skb ( sk , skb , false ) ; spin_unlock_irqrestore ( & sk -> sk_receive_queue . lock , cpu_flags ) ; * seq = 0 ; } if ( used + offset < skb -> len ) continue ; } while ( len > 0 ) ; out : release_sock ( sk ) ; return copied ; copy_uaddr : if ( uaddr != NULL && skb != NULL ) { memcpy ( uaddr , llc_ui_skb_cb ( skb ) , sizeof ( * uaddr ) ) ; msg -> msg_namelen = sizeof ( * uaddr ) ; } if ( llc_sk ( sk ) -> cmsg_flags ) llc_cmsg_rcv ( msg , skb ) ; if ( ! ( flags & MSG_PEEK ) ) { spin_lock_irqsave ( & sk -> sk_receive_queue . lock , cpu_flags ) ; sk_eat_skb ( sk , skb , false ) ; spin_unlock_irqrestore ( & sk -> sk_receive_queue . lock , cpu_flags ) ; * seq = 0 ; } goto out ; }",; long timeo ; msg -> msg_namelen = 0
293,"STATIC struct posix_acl * xfs_acl_from_disk ( struct xfs_acl * aclp ) { struct posix_acl_entry * acl_e ; struct posix_acl * acl ; struct xfs_acl_entry * ace ; <S2SV_StartBug> int count , i ; <S2SV_EndBug> count = be32_to_cpu ( aclp -> acl_cnt ) ; if ( count > XFS_ACL_MAX_ENTRIES ) return ERR_PTR ( - EFSCORRUPTED ) ; acl = posix_acl_alloc ( count , GFP_KERNEL ) ; if ( ! acl ) return ERR_PTR ( - ENOMEM ) ; for ( i = 0 ; i < count ; i ++ ) { acl_e = & acl -> a_entries [ i ] ; ace = & aclp -> acl_entry [ i ] ; acl_e -> e_tag = be32_to_cpu ( ace -> ae_tag ) ; acl_e -> e_perm = be16_to_cpu ( ace -> ae_perm ) ; switch ( acl_e -> e_tag ) { case ACL_USER : case ACL_GROUP : acl_e -> e_id = be32_to_cpu ( ace -> ae_id ) ; break ; case ACL_USER_OBJ : case ACL_GROUP_OBJ : case ACL_MASK : case ACL_OTHER : acl_e -> e_id = ACL_UNDEFINED_ID ; break ; default : goto fail ; } } return acl ; fail : posix_acl_release ( acl ) ; return ERR_PTR ( - EINVAL ) ; }",* ace ; unsigned
294,"static vpx_codec_err_t ctrl_set_dbg_options ( vpx_codec_alg_priv_t * ctx , <S2SV_StartBug> int ctrl_id , va_list args ) { <S2SV_EndBug> <S2SV_StartBug> # if CONFIG_POSTPROC_VISUALIZER && CONFIG_POSTPROC <S2SV_EndBug> int data = va_arg ( args , int ) ; # define MAP ( id , var ) case id : var = data ; break ; switch ( ctrl_id ) { MAP ( VP8_SET_DBG_COLOR_REF_FRAME , ctx -> dbg_color_ref_frame_flag ) ; MAP ( VP8_SET_DBG_COLOR_MB_MODES , ctx -> dbg_color_mb_modes_flag ) ; MAP ( VP8_SET_DBG_COLOR_B_MODES , ctx -> dbg_color_b_modes_flag ) ; MAP ( VP8_SET_DBG_DISPLAY_MV , ctx -> dbg_display_mv_flag ) ; } return VPX_CODEC_OK ; # else return VPX_CODEC_INCAPABLE ; <S2SV_StartBug> # endif <S2SV_EndBug> }","* ctx , <S2SV_ModEnd> va_list args ) <S2SV_ModStart> args ) { ( void ) ctx ; ( void ) args ; <S2SV_ModEnd> return VPX_CODEC_INCAPABLE ; <S2SV_ModStart> return VPX_CODEC_INCAPABLE ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>"
295,"struct pci_vdev * pci_get_vdev_info ( int slot ) { struct businfo * bi ; struct slotinfo * si ; struct pci_vdev * dev = NULL ; bi = pci_businfo [ 0 ] ; <S2SV_StartBug> assert ( bi != NULL ) ; <S2SV_EndBug> si = & bi -> slotinfo [ slot ] ; if ( si != NULL ) dev = si -> si_funcs [ 0 ] . fi_devi ; else fprintf ( stderr , ""slot=%d<S2SV_blank>is<S2SV_blank>empty!\\n"" , slot ) ; return dev ; }",0 ] ; if ( bi == NULL ) return NULL <S2SV_ModEnd> ; si =
296,"static int ati_remote2_probe ( struct usb_interface * interface , const struct usb_device_id * id ) { struct usb_device * udev = interface_to_usbdev ( interface ) ; struct usb_host_interface * alt = interface -> cur_altsetting ; struct ati_remote2 * ar2 ; int r ; if ( alt -> desc . bInterfaceNumber ) return - ENODEV ; ar2 = kzalloc ( sizeof ( struct ati_remote2 ) , GFP_KERNEL ) ; if ( ! ar2 ) return - ENOMEM ; ar2 -> udev = udev ; <S2SV_StartBug> ar2 -> intf [ 0 ] = interface ; <S2SV_EndBug> ar2 -> ep [ 0 ] = & alt -> endpoint [ 0 ] . desc ; ar2 -> intf [ 1 ] = usb_ifnum_to_if ( udev , 1 ) ; <S2SV_StartBug> r = usb_driver_claim_interface ( & ati_remote2_driver , ar2 -> intf [ 1 ] , ar2 ) ; <S2SV_EndBug> if ( r ) goto fail1 ; alt = ar2 -> intf [ 1 ] -> cur_altsetting ; <S2SV_StartBug> ar2 -> ep [ 1 ] = & alt -> endpoint [ 0 ] . desc ; <S2SV_EndBug> r = ati_remote2_urb_init ( ar2 ) ; if ( r ) <S2SV_StartBug> goto fail2 ; <S2SV_EndBug> ar2 -> channel_mask = channel_mask ; ar2 -> mode_mask = mode_mask ; r = ati_remote2_setup ( ar2 , ar2 -> channel_mask ) ; if ( r ) <S2SV_StartBug> goto fail2 ; <S2SV_EndBug> usb_make_path ( udev , ar2 -> phys , sizeof ( ar2 -> phys ) ) ; strlcat ( ar2 -> phys , ""/input0"" , sizeof ( ar2 -> phys ) ) ; strlcat ( ar2 -> name , ""ATI<S2SV_blank>Remote<S2SV_blank>Wonder<S2SV_blank>II"" , sizeof ( ar2 -> name ) ) ; r = sysfs_create_group ( & udev -> dev . kobj , & ati_remote2_attr_group ) ; if ( r ) <S2SV_StartBug> goto fail2 ; <S2SV_EndBug> r = ati_remote2_input_init ( ar2 ) ; if ( r ) <S2SV_StartBug> goto fail3 ; <S2SV_EndBug> usb_set_intfdata ( interface , ar2 ) ; interface -> needs_remote_wakeup = 1 ; return 0 ; <S2SV_StartBug> fail3 : <S2SV_EndBug> sysfs_remove_group ( & udev -> dev . kobj , & ati_remote2_attr_group ) ; fail2 : <S2SV_StartBug> ati_remote2_urb_cleanup ( ar2 ) ; <S2SV_EndBug> usb_driver_release_interface ( & ati_remote2_driver , ar2 -> intf [ 1 ] ) ; fail1 : kfree ( ar2 ) ; return r ; }","= udev ; if ( alt -> desc . bNumEndpoints < 1 || ! alt -> endpoint ) { dev_err ( & interface -> dev , ""%s():<S2SV_blank>interface<S2SV_blank>0<S2SV_blank>must<S2SV_blank>have<S2SV_blank>an<S2SV_blank>endpoint\\n"" , __func__ ) ; r = - ENODEV ; goto fail1 ; } <S2SV_ModStart> 1 ) ; if ( ( udev -> actconfig -> desc . bNumInterfaces < 2 ) || ! ar2 -> intf [ 1 ] ) { dev_err ( & interface -> dev , ""%s():<S2SV_blank>need<S2SV_blank>2<S2SV_blank>interfaces,<S2SV_blank>found<S2SV_blank>%d\\n"" , __func__ , udev -> actconfig -> desc . bNumInterfaces ) ; r = - ENODEV ; goto fail1 ; } <S2SV_ModStart> -> cur_altsetting ; if ( alt -> desc . bNumEndpoints < 1 || ! alt -> endpoint ) { dev_err ( & interface -> dev , ""%s():<S2SV_blank>interface<S2SV_blank>1<S2SV_blank>must<S2SV_blank>have<S2SV_blank>an<S2SV_blank>endpoint\\n"" , __func__ ) ; r = - ENODEV ; goto fail2 ; } <S2SV_ModStart> r ) goto fail3 <S2SV_ModEnd> ; ar2 -> <S2SV_ModStart> r ) goto fail3 <S2SV_ModEnd> ; usb_make_path ( <S2SV_ModStart> r ) goto fail3 <S2SV_ModEnd> ; r = <S2SV_ModStart> r ) goto fail4 <S2SV_ModEnd> ; usb_set_intfdata ( <S2SV_ModStart> return 0 ; fail4 : sysfs_remove_group ( & udev -> dev . kobj , & ati_remote2_attr_group ) ; fail3 : ati_remote2_urb_cleanup ( ar2 <S2SV_ModEnd> ) ; fail2 <S2SV_ModStart> ; fail2 : <S2SV_ModEnd> usb_driver_release_interface ( &"
297,"generic_ret * create_principal3_2_svc ( cprinc3_arg * arg , struct svc_req * rqstp ) { static generic_ret ret ; char * prime_arg ; <S2SV_StartBug> gss_buffer_desc client_name , service_name ; <S2SV_EndBug> OM_uint32 minor_stat ; kadm5_server_handle_t handle ; restriction_t * rp ; const char * errmsg = NULL ; xdr_free ( xdr_generic_ret , & ret ) ; if ( ( ret . code = new_server_handle ( arg -> api_version , rqstp , & handle ) ) ) goto exit_func ; if ( ( ret . code = check_handle ( ( void * ) handle ) ) ) goto exit_func ; ret . api_version = handle -> api_version ; if ( setup_gss_names ( rqstp , & client_name , & service_name ) < 0 ) { ret . code = KADM5_FAILURE ; goto exit_func ; } if ( krb5_unparse_name ( handle -> context , arg -> rec . principal , & prime_arg ) ) { ret . code = KADM5_BAD_PRINCIPAL ; goto exit_func ; } if ( CHANGEPW_SERVICE ( rqstp ) || ! kadm5int_acl_check ( handle -> context , rqst2name ( rqstp ) , ACL_ADD , arg -> rec . principal , & rp ) || kadm5int_acl_impose_restrictions ( handle -> context , & arg -> rec , & arg -> mask , rp ) ) { ret . code = KADM5_AUTH_ADD ; log_unauth ( ""kadm5_create_principal"" , prime_arg , & client_name , & service_name , rqstp ) ; } else { ret . code = kadm5_create_principal_3 ( ( void * ) handle , & arg -> rec , arg -> mask , arg -> n_ks_tuple , arg -> ks_tuple , arg -> passwd ) ; if ( ret . code != 0 ) errmsg = krb5_get_error_message ( handle -> context , ret . code ) ; log_done ( ""kadm5_create_principal"" , prime_arg , errmsg , & client_name , & service_name , rqstp ) ; if ( errmsg != NULL ) krb5_free_error_message ( handle -> context , errmsg ) ; } free ( prime_arg ) ; <S2SV_StartBug> gss_release_buffer ( & minor_stat , & client_name ) ; <S2SV_EndBug> gss_release_buffer ( & minor_stat , & service_name ) ; exit_func : free_server_handle ( handle ) ; return & ret ; }","; gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <S2SV_ModEnd> ; OM_uint32 minor_stat <S2SV_ModStart> prime_arg ) ; exit_func : gss_release_buffer ( & minor_stat , & client_name ) ; gss_release_buffer ( & minor_stat , & service_name ) ; <S2SV_ModEnd> free_server_handle ( handle"
298,"static int proc_connectinfo ( struct usb_dev_state * ps , void __user * arg ) { <S2SV_StartBug> struct usbdevfs_connectinfo ci = { <S2SV_EndBug> <S2SV_StartBug> . devnum = ps -> dev -> devnum , <S2SV_EndBug> . slow = ps -> dev -> speed == USB_SPEED_LOW <S2SV_StartBug> } ; <S2SV_EndBug> if ( copy_to_user ( arg , & ci , sizeof ( ci ) ) ) return - EFAULT ; return 0 ; }","struct usbdevfs_connectinfo ci ; memset ( & ci , 0 , sizeof ( ci ) ) ; ci <S2SV_ModEnd> . devnum = <S2SV_ModStart> dev -> devnum ; ci <S2SV_ModEnd> . slow = <S2SV_ModStart> speed == USB_SPEED_LOW <S2SV_ModEnd> ; if ("
299,"static void on_page_prepare ( GtkNotebook * assistant , GtkWidget * page , gpointer user_data ) { if ( ! is_processing_finished ( ) ) { show_next_step_button ( ) ; clear_warnings ( ) ; } gtk_widget_hide ( g_btn_detail ) ; gtk_widget_hide ( g_btn_onfail ) ; if ( ! g_expert_mode ) gtk_widget_hide ( g_btn_repeat ) ; save_items_from_notepad ( ) ; <S2SV_StartBug> save_text_from_text_view ( g_tv_comment , FILENAME_COMMENT ) ; <S2SV_EndBug> if ( pages [ PAGENO_SUMMARY ] . page_widget == page ) { if ( ! g_expert_mode ) { int n = select_next_page_no ( pages [ PAGENO_SUMMARY ] . page_no , NULL ) ; log_info ( ""switching<S2SV_blank>to<S2SV_blank>page_no:%d"" , n ) ; gtk_notebook_set_current_page ( assistant , n ) ; return ; } } if ( pages [ PAGENO_EDIT_ELEMENTS ] . page_widget == page ) { if ( highlight_forbidden ( ) ) { add_sensitive_data_warning ( ) ; show_warnings ( ) ; gtk_expander_set_expanded ( g_exp_search , TRUE ) ; } else gtk_toggle_button_set_active ( GTK_TOGGLE_BUTTON ( g_rb_custom_search ) , TRUE ) ; show_warnings ( ) ; } if ( pages [ PAGENO_REVIEW_DATA ] . page_widget == page ) { update_ls_details_checkboxes ( g_event_selected ) ; gtk_widget_set_sensitive ( g_btn_next , gtk_toggle_button_get_active ( g_tb_approve_bt ) ) ; } if ( pages [ PAGENO_EDIT_COMMENT ] . page_widget == page ) { gtk_widget_show ( g_btn_detail ) ; gtk_widget_set_sensitive ( g_btn_next , false ) ; on_comment_changed ( gtk_text_view_get_buffer ( g_tv_comment ) , NULL ) ; } if ( pages [ PAGENO_EVENT_PROGRESS ] . page_widget == page ) { log_info ( ""g_event_selected:\'%s\'"" , g_event_selected ) ; if ( g_event_selected && g_event_selected [ 0 ] ) { clear_warnings ( ) ; start_event_run ( g_event_selected ) ; } } if ( pages [ PAGENO_EVENT_SELECTOR ] . page_widget == page ) { if ( ! g_expert_mode && ! g_auto_event_list ) hide_next_step_button ( ) ; } }","g_tv_comment , FILENAME_COMMENT ) ; problem_data_reload_from_dump_dir ( ) ; update_gui_state_from_problem_data ( 0"
300,"char * Util_urlDecode ( char * url ) { if ( url && * url ) { register int x , y ; for ( x = 0 , y = 0 ; url [ y ] ; x ++ , y ++ ) { <S2SV_StartBug> if ( ( url [ x ] = url [ y ] ) == '+' ) <S2SV_EndBug> url [ x ] = '<S2SV_blank>' ; <S2SV_StartBug> else if ( url [ x ] == '%' ) { <S2SV_EndBug> <S2SV_StartBug> if ( ! ( url [ x + 1 ] && url [ x + 2 ] ) ) <S2SV_EndBug> break ; <S2SV_StartBug> url [ x ] = x2c ( url + y + 1 ) ; <S2SV_EndBug> <S2SV_StartBug> y += 2 ; <S2SV_EndBug> } } url [ x ] = 0 ; } return url ; }",{ if ( <S2SV_ModEnd> url [ y <S2SV_ModStart> [ y ] <S2SV_ModEnd> == '+' ) <S2SV_ModStart> == '+' ) { <S2SV_ModStart> = '<S2SV_blank>' ; } <S2SV_ModStart> ( url [ y <S2SV_ModEnd> ] == '%' <S2SV_ModStart> if ( ! url [ y <S2SV_ModEnd> + 1 ] <S2SV_ModStart> + 1 ] || ! url [ y <S2SV_ModEnd> + 2 ] <S2SV_ModStart> + 2 ] <S2SV_ModEnd> ) break ; <S2SV_ModStart> x ] = _x2c <S2SV_ModEnd> ( url + <S2SV_ModStart> y += 2 ; } else { url [ x ] = url [ y ]
301,"krb5_error_code _kdc_as_rep ( kdc_request_t r , krb5_data * reply , const char * from , struct sockaddr * from_addr , int datagram_reply ) { krb5_context context = r -> context ; krb5_kdc_configuration * config = r -> config ; KDC_REQ * req = & r -> req ; KDC_REQ_BODY * b = NULL ; AS_REP rep ; KDCOptions f ; krb5_enctype setype ; krb5_error_code ret = 0 ; Key * skey ; int found_pa = 0 ; int i , flags = HDB_F_FOR_AS_REQ ; METHOD_DATA error_method ; const PA_DATA * pa ; memset ( & rep , 0 , sizeof ( rep ) ) ; error_method . len = 0 ; error_method . val = NULL ; ret = _kdc_fast_unwrap_request ( r ) ; if ( ret ) { _kdc_r_log ( r , 0 , ""FAST<S2SV_blank>unwrap<S2SV_blank>request<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>failed:<S2SV_blank>%d"" , from , ret ) ; goto out ; } b = & req -> req_body ; f = b -> kdc_options ; if ( f . canonicalize ) flags |= HDB_F_CANON ; if ( b -> sname == NULL ) { ret = KRB5KRB_ERR_GENERIC ; _kdc_set_e_text ( r , ""No<S2SV_blank>server<S2SV_blank>in<S2SV_blank>request"" ) ; } else { ret = _krb5_principalname2krb5_principal ( context , & r -> server_princ , * ( b -> sname ) , b -> realm ) ; if ( ret == 0 ) ret = krb5_unparse_name ( context , r -> server_princ , & r -> server_name ) ; } if ( ret ) { kdc_log ( context , config , 0 , ""AS-REQ<S2SV_blank>malformed<S2SV_blank>server<S2SV_blank>name<S2SV_blank>from<S2SV_blank>%s"" , from ) ; goto out ; } if ( b -> cname == NULL ) { ret = KRB5KRB_ERR_GENERIC ; _kdc_set_e_text ( r , ""No<S2SV_blank>client<S2SV_blank>in<S2SV_blank>request"" ) ; } else { ret = _krb5_principalname2krb5_principal ( context , & r -> client_princ , * ( b -> cname ) , b -> realm ) ; if ( ret ) goto out ; ret = krb5_unparse_name ( context , r -> client_princ , & r -> client_name ) ; } if ( ret ) { kdc_log ( context , config , 0 , ""AS-REQ<S2SV_blank>malformed<S2SV_blank>client<S2SV_blank>name<S2SV_blank>from<S2SV_blank>%s"" , from ) ; goto out ; } kdc_log ( context , config , 0 , ""AS-REQ<S2SV_blank>%s<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>%s"" , r -> client_name , from , r -> server_name ) ; if ( _kdc_is_anonymous ( context , r -> client_princ ) ) { if ( ! _kdc_is_anon_request ( b ) ) { kdc_log ( context , config , 0 , ""Anonymous<S2SV_blank>ticket<S2SV_blank>w/o<S2SV_blank>anonymous<S2SV_blank>flag"" ) ; ret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN ; goto out ; } } else if ( _kdc_is_anon_request ( b ) ) { kdc_log ( context , config , 0 , ""Request<S2SV_blank>for<S2SV_blank>a<S2SV_blank>anonymous<S2SV_blank>ticket<S2SV_blank>with<S2SV_blank>non<S2SV_blank>"" ""anonymous<S2SV_blank>client<S2SV_blank>name:<S2SV_blank>%s"" , r -> client_name ) ; ret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN ; goto out ; } ret = _kdc_db_fetch ( context , config , r -> client_princ , HDB_F_GET_CLIENT | flags , NULL , & r -> clientdb , & r -> client ) ; if ( ret == HDB_ERR_NOT_FOUND_HERE ) { kdc_log ( context , config , 5 , ""client<S2SV_blank>%s<S2SV_blank>does<S2SV_blank>not<S2SV_blank>have<S2SV_blank>secrets<S2SV_blank>at<S2SV_blank>this<S2SV_blank>KDC,<S2SV_blank>need<S2SV_blank>to<S2SV_blank>proxy"" , r -> client_name ) ; goto out ; } else if ( ret == HDB_ERR_WRONG_REALM ) { char * fixed_client_name = NULL ; ret = krb5_unparse_name ( context , r -> client -> entry . principal , & fixed_client_name ) ; if ( ret ) { goto out ; } kdc_log ( context , config , 0 , ""WRONG_REALM<S2SV_blank>-<S2SV_blank>%s<S2SV_blank>-><S2SV_blank>%s"" , r -> client_name , fixed_client_name ) ; free ( fixed_client_name ) ; ret = _kdc_fast_mk_error ( context , r , & error_method , r -> armor_crypto , & req -> req_body , KRB5_KDC_ERR_WRONG_REALM , NULL , r -> server_princ , NULL , & r -> client -> entry . principal -> realm , NULL , NULL , reply ) ; goto out ; } else if ( ret ) { const char * msg = krb5_get_error_message ( context , ret ) ; kdc_log ( context , config , 0 , ""UNKNOWN<S2SV_blank>--<S2SV_blank>%s:<S2SV_blank>%s"" , r -> client_name , msg ) ; krb5_free_error_message ( context , msg ) ; ret = KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN ; goto out ; } ret = _kdc_db_fetch ( context , config , r -> server_princ , HDB_F_GET_SERVER | HDB_F_GET_KRBTGT | flags , NULL , NULL , & r -> server ) ; if ( ret == HDB_ERR_NOT_FOUND_HERE ) { kdc_log ( context , config , 5 , ""target<S2SV_blank>%s<S2SV_blank>does<S2SV_blank>not<S2SV_blank>have<S2SV_blank>secrets<S2SV_blank>at<S2SV_blank>this<S2SV_blank>KDC,<S2SV_blank>need<S2SV_blank>to<S2SV_blank>proxy"" , r -> server_name ) ; goto out ; } else if ( ret ) { const char * msg = krb5_get_error_message ( context , ret ) ; kdc_log ( context , config , 0 , ""UNKNOWN<S2SV_blank>--<S2SV_blank>%s:<S2SV_blank>%s"" , r -> server_name , msg ) ; krb5_free_error_message ( context , msg ) ; ret = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN ; goto out ; } ret = _kdc_find_etype ( context , krb5_principal_is_krbtgt ( context , r -> server_princ ) ? config -> tgt_use_strongest_session_key : config -> svc_use_strongest_session_key , FALSE , r -> client , b -> etype . val , b -> etype . len , & r -> sessionetype , NULL ) ; if ( ret ) { kdc_log ( context , config , 0 , ""Client<S2SV_blank>(%s)<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>has<S2SV_blank>no<S2SV_blank>common<S2SV_blank>enctypes<S2SV_blank>with<S2SV_blank>KDC<S2SV_blank>"" ""to<S2SV_blank>use<S2SV_blank>for<S2SV_blank>the<S2SV_blank>session<S2SV_blank>key"" , r -> client_name , from ) ; goto out ; } if ( req -> padata ) { unsigned int n ; log_patypes ( context , config , req -> padata ) ; for ( n = 0 ; ! found_pa && n < sizeof ( pat ) / sizeof ( pat [ 0 ] ) ; n ++ ) { if ( pat [ n ] . validate == NULL ) continue ; if ( r -> armor_crypto == NULL && ( pat [ n ] . flags & PA_REQ_FAST ) ) continue ; kdc_log ( context , config , 5 , ""Looking<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>pa-data<S2SV_blank>--<S2SV_blank>%s"" , pat [ n ] . name , r -> client_name ) ; i = 0 ; pa = _kdc_find_padata ( req , & i , pat [ n ] . type ) ; if ( pa ) { ret = pat [ n ] . validate ( r , pa ) ; if ( ret != 0 ) { goto out ; } kdc_log ( context , config , 0 , ""%s<S2SV_blank>pre-authentication<S2SV_blank>succeeded<S2SV_blank>--<S2SV_blank>%s"" , pat [ n ] . name , r -> client_name ) ; found_pa = 1 ; r -> et . flags . pre_authent = 1 ; } } } if ( found_pa == 0 ) { Key * ckey = NULL ; size_t n ; for ( n = 0 ; n < sizeof ( pat ) / sizeof ( pat [ 0 ] ) ; n ++ ) { if ( ( pat [ n ] . flags & PA_ANNOUNCE ) == 0 ) continue ; ret = krb5_padata_add ( context , & error_method , pat [ n ] . type , NULL , 0 ) ; if ( ret ) goto out ; } ret = _kdc_find_etype ( context , config -> preauth_use_strongest_session_key , TRUE , r -> client , b -> etype . val , b -> etype . len , NULL , & ckey ) ; if ( ret == 0 ) { if ( older_enctype ( ckey -> key . keytype ) ) { ret = get_pa_etype_info ( context , config , & error_method , ckey ) ; if ( ret ) goto out ; } ret = get_pa_etype_info2 ( context , config , & error_method , ckey ) ; if ( ret ) goto out ; } if ( require_preauth_p ( r ) || _kdc_is_anon_request ( b ) ) { ret = KRB5KDC_ERR_PREAUTH_REQUIRED ; _kdc_set_e_text ( r , ""Need<S2SV_blank>to<S2SV_blank>use<S2SV_blank>PA-ENC-TIMESTAMP/PA-PK-AS-REQ"" ) ; goto out ; } if ( ckey == NULL ) { ret = KRB5KDC_ERR_CLIENT_NOTYET ; _kdc_set_e_text ( r , ""Doesn\'t<S2SV_blank>have<S2SV_blank>a<S2SV_blank>client<S2SV_blank>key<S2SV_blank>available"" ) ; goto out ; } krb5_free_keyblock_contents ( r -> context , & r -> reply_key ) ; ret = krb5_copy_keyblock_contents ( r -> context , & ckey -> key , & r -> reply_key ) ; if ( ret ) goto out ; } if ( r -> clientdb -> hdb_auth_status ) { r -> clientdb -> hdb_auth_status ( context , r -> clientdb , r -> client , HDB_AUTH_SUCCESS ) ; } ret = _kdc_check_access ( context , config , r -> client , r -> client_name , r -> server , r -> server_name , req , & error_method ) ; if ( ret ) goto out ; ret = _kdc_get_preferred_key ( context , config , r -> server , r -> server_name , & setype , & skey ) ; if ( ret ) goto out ; if ( f . renew || f . validate || f . proxy || f . forwarded || f . enc_tkt_in_skey || ( _kdc_is_anon_request ( b ) && ! config -> allow_anonymous ) ) { ret = KRB5KDC_ERR_BADOPTION ; _kdc_set_e_text ( r , ""Bad<S2SV_blank>KDC<S2SV_blank>options"" ) ; goto out ; } rep . pvno = 5 ; rep . msg_type = krb_as_rep ; if ( _kdc_is_anonymous ( context , r -> client_princ ) ) { Realm anon_realm = KRB5_ANON_REALM ; ret = copy_Realm ( & anon_realm , & rep . crealm ) ; } else ret = copy_Realm ( & r -> client -> entry . principal -> realm , & rep . crealm ) ; if ( ret ) goto out ; ret = _krb5_principal2principalname ( & rep . cname , r -> client -> entry . principal ) ; if ( ret ) goto out ; rep . ticket . tkt_vno = 5 ; ret = copy_Realm ( & r -> server -> entry . principal -> realm , & rep . ticket . realm ) ; if ( ret ) goto out ; _krb5_principal2principalname ( & rep . ticket . sname , r -> server -> entry . principal ) ; # define CNT ( sp , t ) ( ( ( sp ) -> sname -> name_type ) == KRB5_NT_ ## t ) if ( CNT ( b , UNKNOWN ) || CNT ( b , PRINCIPAL ) || CNT ( b , SRV_INST ) || CNT ( b , SRV_HST ) || CNT ( b , SRV_XHST ) ) rep . ticket . sname . name_type = b -> sname -> name_type ; # undef CNT r -> et . flags . initial = 1 ; if ( r -> client -> entry . flags . forwardable && r -> server -> entry . flags . forwardable ) r -> et . flags . forwardable = f . forwardable ; else if ( f . forwardable ) { _kdc_set_e_text ( r , ""Ticket<S2SV_blank>may<S2SV_blank>not<S2SV_blank>be<S2SV_blank>forwardable"" ) ; ret = KRB5KDC_ERR_POLICY ; goto out ; } if ( r -> client -> entry . flags . proxiable && r -> server -> entry . flags . proxiable ) r -> et . flags . proxiable = f . proxiable ; else if ( f . proxiable ) { _kdc_set_e_text ( r , ""Ticket<S2SV_blank>may<S2SV_blank>not<S2SV_blank>be<S2SV_blank>proxiable"" ) ; ret = KRB5KDC_ERR_POLICY ; goto out ; } if ( r -> client -> entry . flags . postdate && r -> server -> entry . flags . postdate ) r -> et . flags . may_postdate = f . allow_postdate ; else if ( f . allow_postdate ) { _kdc_set_e_text ( r , ""Ticket<S2SV_blank>may<S2SV_blank>not<S2SV_blank>be<S2SV_blank>postdate"" ) ; ret = KRB5KDC_ERR_POLICY ; goto out ; } if ( ! _kdc_check_addresses ( context , config , b -> addresses , from_addr ) ) { _kdc_set_e_text ( r , ""Bad<S2SV_blank>address<S2SV_blank>list<S2SV_blank>in<S2SV_blank>requested"" ) ; ret = KRB5KRB_AP_ERR_BADADDR ; goto out ; } ret = copy_PrincipalName ( & rep . cname , & r -> et . cname ) ; if ( ret ) goto out ; ret = copy_Realm ( & rep . crealm , & r -> et . crealm ) ; if ( ret ) goto out ; { time_t start ; time_t t ; start = r -> et . authtime = kdc_time ; if ( f . postdated && req -> req_body . from ) { ALLOC ( r -> et . starttime ) ; start = * r -> et . starttime = * req -> req_body . from ; r -> et . flags . invalid = 1 ; r -> et . flags . postdated = 1 ; } _kdc_fix_time ( & b -> till ) ; t = * b -> till ; if ( r -> client -> entry . max_life ) t = start + min ( t - start , * r -> client -> entry . max_life ) ; if ( r -> server -> entry . max_life ) t = start + min ( t - start , * r -> server -> entry . max_life ) ; # if 0 t = min ( t , start + realm -> max_life ) ; # endif r -> et . endtime = t ; if ( f . renewable_ok && r -> et . endtime < * b -> till ) { f . renewable = 1 ; if ( b -> rtime == NULL ) { ALLOC ( b -> rtime ) ; * b -> rtime = 0 ; } if ( * b -> rtime < * b -> till ) * b -> rtime = * b -> till ; } if ( f . renewable && b -> rtime ) { t = * b -> rtime ; if ( t == 0 ) t = MAX_TIME ; if ( r -> client -> entry . max_renew ) t = start + min ( t - start , * r -> client -> entry . max_renew ) ; if ( r -> server -> entry . max_renew ) t = start + min ( t - start , * r -> server -> entry . max_renew ) ; # if 0 t = min ( t , start + realm -> max_renew ) ; # endif ALLOC ( r -> et . renew_till ) ; * r -> et . renew_till = t ; r -> et . flags . renewable = 1 ; } } if ( _kdc_is_anon_request ( b ) ) r -> et . flags . anonymous = 1 ; if ( b -> addresses ) { ALLOC ( r -> et . caddr ) ; copy_HostAddresses ( b -> addresses , r -> et . caddr ) ; } r -> et . transited . tr_type = DOMAIN_X500_COMPRESS ; krb5_data_zero ( & r -> et . transited . contents ) ; r -> ek . last_req . val = malloc ( 2 * sizeof ( * r -> ek . last_req . val ) ) ; if ( r -> ek . last_req . val == NULL ) { ret = ENOMEM ; goto out ; } r -> ek . last_req . len = 0 ; if ( r -> client -> entry . pw_end && ( config -> kdc_warn_pwexpire == 0 || kdc_time + config -> kdc_warn_pwexpire >= * r -> client -> entry . pw_end ) ) { r -> ek . last_req . val [ r -> ek . last_req . len ] . lr_type = LR_PW_EXPTIME ; r -> ek . last_req . val [ r -> ek . last_req . len ] . lr_value = * r -> client -> entry . pw_end ; ++ r -> ek . last_req . len ; } if ( r -> client -> entry . valid_end ) { r -> ek . last_req . val [ r -> ek . last_req . len ] . lr_type = LR_ACCT_EXPTIME ; r -> ek . last_req . val [ r -> ek . last_req . len ] . lr_value = * r -> client -> entry . valid_end ; ++ r -> ek . last_req . len ; } if ( r -> ek . last_req . len == 0 ) { r -> ek . last_req . val [ r -> ek . last_req . len ] . lr_type = LR_NONE ; r -> ek . last_req . val [ r -> ek . last_req . len ] . lr_value = 0 ; ++ r -> ek . last_req . len ; } r -> ek . nonce = b -> nonce ; if ( r -> client -> entry . valid_end || r -> client -> entry . pw_end ) { ALLOC ( r -> ek . key_expiration ) ; if ( r -> client -> entry . valid_end ) { if ( r -> client -> entry . pw_end ) * r -> ek . key_expiration = min ( * r -> client -> entry . valid_end , * r -> client -> entry . pw_end ) ; else * r -> ek . key_expiration = * r -> client -> entry . valid_end ; } else * r -> ek . key_expiration = * r -> client -> entry . pw_end ; } else r -> ek . key_expiration = NULL ; r -> ek . flags = r -> et . flags ; r -> ek . authtime = r -> et . authtime ; if ( r -> et . starttime ) { ALLOC ( r -> ek . starttime ) ; * r -> ek . starttime = * r -> et . starttime ; } r -> ek . endtime = r -> et . endtime ; if ( r -> et . renew_till ) { ALLOC ( r -> ek . renew_till ) ; * r -> ek . renew_till = * r -> et . renew_till ; } ret = copy_Realm ( & rep . ticket . realm , & r -> ek . srealm ) ; if ( ret ) goto out ; ret = copy_PrincipalName ( & rep . ticket . sname , & r -> ek . sname ) ; if ( ret ) goto out ; if ( r -> et . caddr ) { ALLOC ( r -> ek . caddr ) ; copy_HostAddresses ( r -> et . caddr , r -> ek . caddr ) ; } if ( r -> session_key . keytype == ETYPE_NULL ) { ret = krb5_generate_random_keyblock ( context , r -> sessionetype , & r -> session_key ) ; if ( ret ) goto out ; } if ( r -> reply_key . keytype == ETYPE_NULL ) { _kdc_set_e_text ( r , ""Client<S2SV_blank>have<S2SV_blank>no<S2SV_blank>reply<S2SV_blank>key"" ) ; ret = KRB5KDC_ERR_CLIENT_NOTYET ; goto out ; } ret = copy_EncryptionKey ( & r -> session_key , & r -> et . key ) ; if ( ret ) goto out ; ret = copy_EncryptionKey ( & r -> session_key , & r -> ek . key ) ; if ( ret ) goto out ; if ( r -> outpadata . len ) { ALLOC ( rep . padata ) ; if ( rep . padata == NULL ) { ret = ENOMEM ; goto out ; } ret = copy_METHOD_DATA ( & r -> outpadata , rep . padata ) ; if ( ret ) goto out ; } if ( send_pac_p ( context , req ) ) { generate_pac ( r , skey ) ; } _kdc_log_timestamp ( context , config , ""AS-REQ"" , r -> et . authtime , r -> et . starttime , r -> et . endtime , r -> et . renew_till ) ; ret = _kdc_add_KRB5SignedPath ( context , config , r -> server , setype , r -> client -> entry . principal , NULL , NULL , & r -> et ) ; if ( ret ) goto out ; log_as_req ( context , config , r -> reply_key . keytype , setype , b ) ; r -> et . flags . enc_pa_rep = r -> ek . flags . enc_pa_rep = 1 ; i = 0 ; pa = _kdc_find_padata ( req , & i , KRB5_PADATA_REQ_ENC_PA_REP ) ; if ( pa ) { ret = add_enc_pa_rep ( r ) ; if ( ret ) { const char * msg = krb5_get_error_message ( r -> context , ret ) ; _kdc_r_log ( r , 0 , ""add_enc_pa_rep<S2SV_blank>failed:<S2SV_blank>%s:<S2SV_blank>%d"" , msg , ret ) ; krb5_free_error_message ( r -> context , msg ) ; goto out ; } } ret = _kdc_encode_reply ( context , config , r -> armor_crypto , req -> req_body . nonce , & rep , & r -> et , & r -> ek , setype , r -> server -> entry . kvno , & skey -> key , r -> client -> entry . kvno , & r -> reply_key , 0 , & r -> e_text , reply ) ; if ( ret ) goto out ; if ( datagram_reply && reply -> length > config -> max_datagram_reply_length ) { krb5_data_free ( reply ) ; ret = KRB5KRB_ERR_RESPONSE_TOO_BIG ; _kdc_set_e_text ( r , ""Reply<S2SV_blank>packet<S2SV_blank>too<S2SV_blank>large"" ) ; } out : free_AS_REP ( & rep ) ; if ( ret != 0 && ret != HDB_ERR_NOT_FOUND_HERE && reply -> length == 0 ) { ret = _kdc_fast_mk_error ( context , r , & error_method , r -> armor_crypto , & req -> req_body , ret , r -> e_text , r -> server_princ , <S2SV_StartBug> & r -> client_princ -> name , <S2SV_EndBug> <S2SV_StartBug> & r -> client_princ -> realm , <S2SV_EndBug> NULL , NULL , reply ) ; if ( ret ) goto out2 ; } out2 : free_EncTicketPart ( & r -> et ) ; free_EncKDCRepPart ( & r -> ek ) ; free_KDCFastState ( & r -> fast ) ; if ( error_method . len ) free_METHOD_DATA ( & error_method ) ; if ( r -> outpadata . len ) free_METHOD_DATA ( & r -> outpadata ) ; if ( r -> client_princ ) { krb5_free_principal ( context , r -> client_princ ) ; r -> client_princ = NULL ; } if ( r -> client_name ) { free ( r -> client_name ) ; r -> client_name = NULL ; } if ( r -> server_princ ) { krb5_free_principal ( context , r -> server_princ ) ; r -> server_princ = NULL ; } if ( r -> server_name ) { free ( r -> server_name ) ; r -> server_name = NULL ; } if ( r -> client ) _kdc_free_ent ( context , r -> client ) ; if ( r -> server ) _kdc_free_ent ( context , r -> server ) ; if ( r -> armor_crypto ) { krb5_crypto_destroy ( r -> context , r -> armor_crypto ) ; r -> armor_crypto = NULL ; } krb5_free_keyblock_contents ( r -> context , & r -> reply_key ) ; krb5_free_keyblock_contents ( r -> context , & r -> session_key ) ; return ret ; }","-> server_princ , <S2SV_ModEnd> r -> client_princ <S2SV_ModStart> r -> client_princ ? & r -> client_princ -> name : NULL , <S2SV_ModEnd> r -> client_princ <S2SV_ModStart> r -> client_princ ? & r -> client_princ -> realm : NULL <S2SV_ModEnd> , NULL ,"
302,void snd_usb_mixer_disconnect ( struct usb_mixer_interface * mixer ) { <S2SV_StartBug> usb_kill_urb ( mixer -> urb ) ; <S2SV_EndBug> usb_kill_urb ( mixer -> rc_urb ) ; <S2SV_StartBug> } <S2SV_EndBug>,mixer ) { if ( mixer -> disconnected ) return ; if ( mixer -> urb ) <S2SV_ModStart> urb ) ; if ( mixer -> rc_urb ) <S2SV_ModStart> rc_urb ) ; mixer -> disconnected = true ;
303,"static stmt_ty ast_for_classdef ( struct compiling * c , const node * n , asdl_seq * decorator_seq ) { PyObject * classname ; asdl_seq * s ; expr_ty call ; REQ ( n , classdef ) ; if ( NCH ( n ) == 4 ) { s = ast_for_suite ( c , CHILD ( n , 3 ) ) ; if ( ! s ) return NULL ; classname = NEW_IDENTIFIER ( CHILD ( n , 1 ) ) ; if ( ! classname ) return NULL ; if ( forbidden_name ( c , classname , CHILD ( n , 3 ) , 0 ) ) return NULL ; return ClassDef ( classname , NULL , NULL , s , decorator_seq , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; } if ( TYPE ( CHILD ( n , 3 ) ) == RPAR ) { s = ast_for_suite ( c , CHILD ( n , 5 ) ) ; if ( ! s ) return NULL ; classname = NEW_IDENTIFIER ( CHILD ( n , 1 ) ) ; if ( ! classname ) return NULL ; if ( forbidden_name ( c , classname , CHILD ( n , 3 ) , 0 ) ) return NULL ; return ClassDef ( classname , NULL , NULL , s , decorator_seq , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; } { PyObject * dummy_name ; expr_ty dummy ; dummy_name = NEW_IDENTIFIER ( CHILD ( n , 1 ) ) ; if ( ! dummy_name ) return NULL ; dummy = Name ( dummy_name , Load , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; <S2SV_StartBug> call = ast_for_call ( c , CHILD ( n , 3 ) , dummy ) ; <S2SV_EndBug> if ( ! call ) return NULL ; } s = ast_for_suite ( c , CHILD ( n , 6 ) ) ; if ( ! s ) return NULL ; classname = NEW_IDENTIFIER ( CHILD ( n , 1 ) ) ; if ( ! classname ) return NULL ; if ( forbidden_name ( c , classname , CHILD ( n , 1 ) , 0 ) ) return NULL ; return ClassDef ( classname , call -> v . Call . args , call -> v . Call . keywords , s , decorator_seq , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; }",") , dummy , false"
304,"struct bio * bio_map_user_iov ( struct request_queue * q , const struct iov_iter * iter , gfp_t gfp_mask ) { int j ; int nr_pages = 0 ; struct page * * pages ; struct bio * bio ; int cur_page = 0 ; int ret , offset ; struct iov_iter i ; <S2SV_StartBug> struct iovec iov ; <S2SV_EndBug> iov_for_each ( iov , i , * iter ) { unsigned long uaddr = ( unsigned long ) iov . iov_base ; unsigned long len = iov . iov_len ; unsigned long end = ( uaddr + len + PAGE_SIZE - 1 ) >> PAGE_SHIFT ; unsigned long start = uaddr >> PAGE_SHIFT ; if ( end < start ) return ERR_PTR ( - EINVAL ) ; nr_pages += end - start ; if ( uaddr & queue_dma_alignment ( q ) ) return ERR_PTR ( - EINVAL ) ; } if ( ! nr_pages ) return ERR_PTR ( - EINVAL ) ; bio = bio_kmalloc ( gfp_mask , nr_pages ) ; if ( ! bio ) return ERR_PTR ( - ENOMEM ) ; ret = - ENOMEM ; pages = kcalloc ( nr_pages , sizeof ( struct page * ) , gfp_mask ) ; if ( ! pages ) goto out ; iov_for_each ( iov , i , * iter ) { unsigned long uaddr = ( unsigned long ) iov . iov_base ; unsigned long len = iov . iov_len ; unsigned long end = ( uaddr + len + PAGE_SIZE - 1 ) >> PAGE_SHIFT ; unsigned long start = uaddr >> PAGE_SHIFT ; const int local_nr_pages = end - start ; const int page_limit = cur_page + local_nr_pages ; ret = get_user_pages_fast ( uaddr , local_nr_pages , ( iter -> type & WRITE ) != WRITE , & pages [ cur_page ] ) ; <S2SV_StartBug> if ( ret < local_nr_pages ) { <S2SV_EndBug> ret = - EFAULT ; goto out_unmap ; } offset = offset_in_page ( uaddr ) ; for ( j = cur_page ; j < page_limit ; j ++ ) { unsigned int bytes = PAGE_SIZE - offset ; unsigned short prev_bi_vcnt = bio -> bi_vcnt ; if ( len <= 0 ) break ; if ( bytes > len ) bytes = len ; if ( bio_add_pc_page ( q , bio , pages [ j ] , bytes , offset ) < bytes ) break ; if ( bio -> bi_vcnt == prev_bi_vcnt ) put_page ( pages [ j ] ) ; len -= bytes ; offset = 0 ; } cur_page = j ; while ( j < page_limit ) put_page ( pages [ j ++ ] ) ; } kfree ( pages ) ; bio_set_flag ( bio , BIO_USER_MAPPED ) ; bio_get ( bio ) ; return bio ; out_unmap : <S2SV_StartBug> for ( j = 0 ; j < nr_pages ; j ++ ) { <S2SV_EndBug> if ( ! pages [ j ] ) break ; put_page ( pages [ j ] ) ; } out : kfree ( pages ) ; bio_put ( bio ) ; return ERR_PTR ( ret ) ; }","struct iovec iov ; struct bio_vec * bvec <S2SV_ModStart> ; if ( unlikely ( <S2SV_ModStart> < local_nr_pages ) ) { for ( j = cur_page ; j < page_limit ; j ++ ) { if ( ! pages [ j ] ) break ; put_page ( pages [ j ] ) ; } <S2SV_ModEnd> ret = - <S2SV_ModStart> ; out_unmap : bio_for_each_segment_all ( bvec , bio , j ) { put_page ( bvec -> bv_page <S2SV_ModEnd> ) ; }"
305,"static long aio_read_events_ring ( struct kioctx * ctx , struct io_event __user * event , long nr ) { struct aio_ring * ring ; unsigned head , tail , pos ; long ret = 0 ; int copy_ret ; mutex_lock ( & ctx -> ring_lock ) ; ring = kmap_atomic ( ctx -> ring_pages [ 0 ] ) ; head = ring -> head ; tail = ring -> tail ; kunmap_atomic ( ring ) ; pr_debug ( ""h%u<S2SV_blank>t%u<S2SV_blank>m%u\\n"" , head , tail , ctx -> nr_events ) ; if ( head == tail ) goto out ; <S2SV_StartBug> while ( ret < nr ) { <S2SV_EndBug> long avail ; struct io_event * ev ; struct page * page ; avail = ( head <= tail ? tail : ctx -> nr_events ) - head ; if ( head == tail ) break ; avail = min ( avail , nr - ret ) ; avail = min_t ( long , avail , AIO_EVENTS_PER_PAGE - ( ( head + AIO_EVENTS_OFFSET ) % AIO_EVENTS_PER_PAGE ) ) ; pos = head + AIO_EVENTS_OFFSET ; page = ctx -> ring_pages [ pos / AIO_EVENTS_PER_PAGE ] ; pos %= AIO_EVENTS_PER_PAGE ; ev = kmap ( page ) ; copy_ret = copy_to_user ( event + ret , ev + pos , sizeof ( * ev ) * avail ) ; kunmap ( page ) ; if ( unlikely ( copy_ret ) ) { ret = - EFAULT ; goto out ; } ret += avail ; head += avail ; head %= ctx -> nr_events ; } ring = kmap_atomic ( ctx -> ring_pages [ 0 ] ) ; ring -> head = head ; kunmap_atomic ( ring ) ; flush_dcache_page ( ctx -> ring_pages [ 0 ] ) ; pr_debug ( ""%li<S2SV_blank><S2SV_blank>h%u<S2SV_blank>t%u\\n"" , ret , head , tail ) ; out : mutex_unlock ( & ctx -> ring_lock ) ; return ret ; }",goto out ; head %= ctx -> nr_events ; tail %= ctx -> nr_events ;
306,"static int copy_to_user_auth ( struct xfrm_algo_auth * auth , struct sk_buff * skb ) { struct xfrm_algo * algo ; struct nlattr * nla ; nla = nla_reserve ( skb , XFRMA_ALG_AUTH , sizeof ( * algo ) + ( auth -> alg_key_len + 7 ) / 8 ) ; if ( ! nla ) return - EMSGSIZE ; algo = nla_data ( nla ) ; <S2SV_StartBug> strcpy ( algo -> alg_name , auth -> alg_name ) ; <S2SV_EndBug> memcpy ( algo -> alg_key , auth -> alg_key , ( auth -> alg_key_len + 7 ) / 8 ) ; algo -> alg_key_len = auth -> alg_key_len ; return 0 ; }","nla ) ; strncpy <S2SV_ModEnd> ( algo -> <S2SV_ModStart> auth -> alg_name , sizeof ( algo -> alg_name )"
307,"static BT_HDR * create_pbuf ( UINT16 len , UINT8 * data ) { <S2SV_StartBug> BT_HDR * p_buf = GKI_getbuf ( ( UINT16 ) ( len + BTA_HH_MIN_OFFSET + sizeof ( BT_HDR ) ) ) ; <S2SV_EndBug> if ( p_buf ) { UINT8 * pbuf_data ; p_buf -> len = len ; p_buf -> offset = BTA_HH_MIN_OFFSET ; pbuf_data = ( UINT8 * ) ( p_buf + 1 ) + p_buf -> offset ; memcpy ( pbuf_data , data , len ) ; } return p_buf ; }","data ) { UINT16 buflen = <S2SV_ModEnd> ( UINT16 ) <S2SV_ModStart> BT_HDR ) ) ; if ( buflen < len ) { android_errorWriteWithInfoLog ( 0x534e4554 , ""28672558"" , - 1 , NULL , 0 ) ; return NULL ; } BT_HDR * p_buf = GKI_getbuf ( buflen"
308,"void color_sycc_to_rgb ( opj_image_t * img ) { if ( img -> numcomps < 3 ) { img -> color_space = OPJ_CLRSPC_GRAY ; return ; } if ( ( img -> comps [ 0 ] . dx == 1 ) && ( img -> comps [ 1 ] . dx == 2 ) && ( img -> comps [ 2 ] . dx == 2 ) && ( img -> comps [ 0 ] . dy == 1 ) && ( img -> comps [ 1 ] . dy == 2 ) && ( img -> comps [ 2 ] . dy == 2 ) ) { sycc420_to_rgb ( img ) ; } else if ( ( img -> comps [ 0 ] . dx == 1 ) && ( img -> comps [ 1 ] . dx == 2 ) && ( img -> comps [ 2 ] . dx == 2 ) && ( img -> comps [ 0 ] . dy == 1 ) && ( img -> comps [ 1 ] . dy == 1 ) && ( img -> comps [ 2 ] . dy == 1 ) ) { sycc422_to_rgb ( img ) ; } else if ( ( img -> comps [ 0 ] . dx == 1 ) && ( img -> comps [ 1 ] . dx == 1 ) && ( img -> comps [ 2 ] . dx == 1 ) && ( img -> comps [ 0 ] . dy == 1 ) && ( img -> comps [ 1 ] . dy == 1 ) && ( img -> comps [ 2 ] . dy == 1 ) ) { sycc444_to_rgb ( img ) ; } else { fprintf ( stderr , ""%s:%d:color_sycc_to_rgb\\n\\tCAN<S2SV_blank>NOT<S2SV_blank>CONVERT\\n"" , __FILE__ , __LINE__ ) ; return ; } <S2SV_StartBug> img -> color_space = OPJ_CLRSPC_SRGB ; <S2SV_EndBug> }",return ; } <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
309,"int sas_discover_end_dev ( struct domain_device * dev ) { int res ; res = sas_notify_lldd_dev_found ( dev ) ; if ( res ) return res ; <S2SV_StartBug> sas_discover_event ( dev -> port , DISCE_PROBE ) ; <S2SV_EndBug> return 0 ; }",return res ; <S2SV_ModEnd> return 0 ;
310,"void hostap_setup_dev ( struct net_device * dev , local_info_t * local , int type ) { struct hostap_interface * iface ; iface = netdev_priv ( dev ) ; <S2SV_StartBug> ether_setup ( dev ) ; <S2SV_EndBug> if ( iface ) { iface -> wireless_data . spy_data = & iface -> spy_data ; dev -> wireless_data = & iface -> wireless_data ; } dev -> wireless_handlers = & hostap_iw_handler_def ; dev -> watchdog_timeo = TX_TIMEOUT ; switch ( type ) { case HOSTAP_INTERFACE_AP : dev -> tx_queue_len = 0 ; dev -> netdev_ops = & hostap_mgmt_netdev_ops ; dev -> type = ARPHRD_IEEE80211 ; dev -> header_ops = & hostap_80211_ops ; break ; case HOSTAP_INTERFACE_MASTER : dev -> netdev_ops = & hostap_master_ops ; break ; default : dev -> tx_queue_len = 0 ; dev -> netdev_ops = & hostap_netdev_ops ; } dev -> mtu = local -> mtu ; SET_ETHTOOL_OPS ( dev , & prism2_ethtool_ops ) ; }",( dev ) ; dev -> priv_flags &= ~ IFF_TX_SKB_SHARING
311,"static int accept_server_socket ( int sfd ) { struct sockaddr_un remote ; struct pollfd pfd ; int fd ; socklen_t len = sizeof ( struct sockaddr_un ) ; BTIF_TRACE_EVENT ( ""accept<S2SV_blank>fd<S2SV_blank>%d"" , sfd ) ; pfd . fd = sfd ; pfd . events = POLLIN ; <S2SV_StartBug> if ( poll ( & pfd , 1 , 0 ) == 0 ) <S2SV_EndBug> { BTIF_TRACE_EVENT ( ""accept<S2SV_blank>poll<S2SV_blank>timeout"" ) ; return - 1 ; } <S2SV_StartBug> if ( ( fd = accept ( sfd , ( struct sockaddr * ) & remote , & len ) ) == - 1 ) <S2SV_EndBug> { BTIF_TRACE_ERROR ( ""sock<S2SV_blank>accept<S2SV_blank>failed<S2SV_blank>(%s)"" , strerror ( errno ) ) ; return - 1 ; } return fd ; }","; if ( TEMP_FAILURE_RETRY ( <S2SV_ModStart> 1 , 0 ) <S2SV_ModStart> ( fd = TEMP_FAILURE_RETRY ( <S2SV_ModStart> , & len )"
312,"static krb5_error_code s4u_identify_user ( krb5_context context , krb5_creds * in_creds , krb5_data * subject_cert , krb5_principal * canon_user ) { krb5_error_code code ; krb5_preauthtype ptypes [ 1 ] = { KRB5_PADATA_S4U_X509_USER } ; krb5_creds creds ; int use_master = 0 ; krb5_get_init_creds_opt * opts = NULL ; krb5_principal_data client ; krb5_s4u_userid userid ; * canon_user = NULL ; if ( in_creds -> client == NULL && subject_cert == NULL ) { return EINVAL ; } if ( in_creds -> client != NULL && in_creds -> client -> type != KRB5_NT_ENTERPRISE_PRINCIPAL ) { int anonymous ; anonymous = krb5_principal_compare ( context , in_creds -> client , krb5_anonymous_principal ( ) ) ; return krb5_copy_principal ( context , anonymous ? in_creds -> server : in_creds -> client , canon_user ) ; } memset ( & creds , 0 , sizeof ( creds ) ) ; memset ( & userid , 0 , sizeof ( userid ) ) ; if ( subject_cert != NULL ) userid . subject_cert = * subject_cert ; code = krb5_get_init_creds_opt_alloc ( context , & opts ) ; if ( code != 0 ) goto cleanup ; krb5_get_init_creds_opt_set_tkt_life ( opts , 15 ) ; krb5_get_init_creds_opt_set_renew_life ( opts , 0 ) ; krb5_get_init_creds_opt_set_forwardable ( opts , 0 ) ; krb5_get_init_creds_opt_set_proxiable ( opts , 0 ) ; krb5_get_init_creds_opt_set_canonicalize ( opts , 1 ) ; krb5_get_init_creds_opt_set_preauth_list ( opts , ptypes , 1 ) ; if ( in_creds -> client != NULL ) { client = * in_creds -> client ; client . realm = in_creds -> server -> realm ; } else { client . magic = KV5M_PRINCIPAL ; client . realm = in_creds -> server -> realm ; client . data = NULL ; client . length = 0 ; client . type = KRB5_NT_ENTERPRISE_PRINCIPAL ; } code = k5_get_init_creds ( context , & creds , & client , NULL , NULL , 0 , NULL , opts , krb5_get_as_key_noop , & userid , & use_master , NULL ) ; <S2SV_StartBug> if ( code == 0 || code == KRB5_PREAUTH_FAILED ) { <S2SV_EndBug> * canon_user = userid . user ; userid . user = NULL ; code = 0 ; } cleanup : krb5_free_cred_contents ( context , & creds ) ; if ( opts != NULL ) krb5_get_init_creds_opt_free ( context , opts ) ; if ( userid . user != NULL ) krb5_free_principal ( context , userid . user ) ; return code ; }",; if ( ! code <S2SV_ModEnd> || code == <S2SV_ModStart> code == KRB5_PREAUTH_FAILED || code == KRB5KDC_ERR_KEY_EXP
313,"static ssize_t driver_override_store ( struct device * dev , struct device_attribute * attr , const char * buf , size_t count ) { struct platform_device * pdev = to_platform_device ( dev ) ; <S2SV_StartBug> char * driver_override , * old = pdev -> driver_override , * cp ; <S2SV_EndBug> if ( count > PATH_MAX ) return - EINVAL ; driver_override = kstrndup ( buf , count , GFP_KERNEL ) ; if ( ! driver_override ) return - ENOMEM ; cp = strchr ( driver_override , '\\n' ) ; if ( cp ) * cp = '\\0' ; <S2SV_StartBug> if ( strlen ( driver_override ) ) { <S2SV_EndBug> pdev -> driver_override = driver_override ; } else { kfree ( driver_override ) ; pdev -> driver_override = NULL ; } <S2SV_StartBug> kfree ( old ) ; <S2SV_EndBug> return count ; }",", * old <S2SV_ModEnd> , * cp <S2SV_ModStart> = '\\0' ; device_lock ( dev ) ; old = pdev -> driver_override ; <S2SV_ModStart> NULL ; } device_unlock ( dev ) ;"
314,"static int handle_emulation_failure ( struct kvm_vcpu * vcpu ) { int r = EMULATE_DONE ; ++ vcpu -> stat . insn_emulation_fail ; trace_kvm_emulate_insn_failed ( vcpu ) ; <S2SV_StartBug> if ( ! is_guest_mode ( vcpu ) ) { <S2SV_EndBug> vcpu -> run -> exit_reason = KVM_EXIT_INTERNAL_ERROR ; vcpu -> run -> internal . suberror = KVM_INTERNAL_ERROR_EMULATION ; vcpu -> run -> internal . ndata = 0 ; r = EMULATE_FAIL ; } kvm_queue_exception ( vcpu , UD_VECTOR ) ; return r ; }",( vcpu ) && kvm_x86_ops -> get_cpl ( vcpu ) == 0
315,"int read_xattrs_from_disk ( int fd , struct squashfs_super_block * sBlk , int flag , long long * table_start ) { <S2SV_StartBug> int res , bytes , i , indexes , index_bytes , ids ; <S2SV_EndBug> long long * index , start , end ; struct squashfs_xattr_table id_table ; TRACE ( ""read_xattrs_from_disk\\n"" ) ; if ( sBlk -> xattr_id_table_start == SQUASHFS_INVALID_BLK ) return SQUASHFS_INVALID_BLK ; res = read_fs_bytes ( fd , sBlk -> xattr_id_table_start , sizeof ( id_table ) , & id_table ) ; if ( res == 0 ) return 0 ; SQUASHFS_INSWAP_XATTR_TABLE ( & id_table ) ; <S2SV_StartBug> if ( flag ) { <S2SV_EndBug> * table_start = id_table . xattr_table_start ; <S2SV_StartBug> return id_table . xattr_ids ; <S2SV_EndBug> } ids = id_table . xattr_ids ; xattr_table_start = id_table . xattr_table_start ; index_bytes = SQUASHFS_XATTR_BLOCK_BYTES ( ids ) ; indexes = SQUASHFS_XATTR_BLOCKS ( ids ) ; index = malloc ( index_bytes ) ; if ( index == NULL ) MEM_ERROR ( ) ; <S2SV_StartBug> res = read_fs_bytes ( fd , sBlk -> xattr_id_table_start + sizeof ( id_table ) , <S2SV_EndBug> index_bytes , index ) ; if ( res == 0 ) goto failed1 ; SQUASHFS_INSWAP_LONG_LONGS ( index , indexes ) ; <S2SV_StartBug> bytes = SQUASHFS_XATTR_BYTES ( ids ) ; <S2SV_EndBug> xattr_ids = malloc ( bytes ) ; if ( xattr_ids == NULL ) MEM_ERROR ( ) ; for ( i = 0 ; i < indexes ; i ++ ) { int expected = ( i + 1 ) != indexes ? SQUASHFS_METADATA_SIZE : bytes & ( SQUASHFS_METADATA_SIZE - 1 ) ; int length = read_block ( fd , index [ i ] , NULL , expected , ( ( unsigned char * ) xattr_ids ) + <S2SV_StartBug> ( i * SQUASHFS_METADATA_SIZE ) ) ; <S2SV_EndBug> TRACE ( ""Read<S2SV_blank>xattr<S2SV_blank>id<S2SV_blank>table<S2SV_blank>block<S2SV_blank>%d,<S2SV_blank>from<S2SV_blank>0x%llx,<S2SV_blank>length<S2SV_blank>"" ""%d\\n"" , i , index [ i ] , length ) ; if ( length == 0 ) { ERROR ( ""Failed<S2SV_blank>to<S2SV_blank>read<S2SV_blank>xattr<S2SV_blank>id<S2SV_blank>table<S2SV_blank>block<S2SV_blank>%d,<S2SV_blank>"" ""from<S2SV_blank>0x%llx,<S2SV_blank>length<S2SV_blank>%d\\n"" , i , index [ i ] , length ) ; goto failed2 ; } } start = xattr_table_start ; end = index [ 0 ] ; for ( i = 0 ; start < end ; i ++ ) { int length ; xattrs = realloc ( xattrs , ( i + 1 ) * SQUASHFS_METADATA_SIZE ) ; if ( xattrs == NULL ) MEM_ERROR ( ) ; save_xattr_block ( start , i * SQUASHFS_METADATA_SIZE ) ; length = read_block ( fd , start , & start , 0 , ( ( unsigned char * ) xattrs ) + ( i * SQUASHFS_METADATA_SIZE ) ) ; TRACE ( ""Read<S2SV_blank>xattr<S2SV_blank>block<S2SV_blank>%d,<S2SV_blank>length<S2SV_blank>%d\\n"" , i , length ) ; if ( length == 0 ) { ERROR ( ""Failed<S2SV_blank>to<S2SV_blank>read<S2SV_blank>xattr<S2SV_blank>block<S2SV_blank>%d\\n"" , i ) ; goto failed3 ; } if ( start != end && length != SQUASHFS_METADATA_SIZE ) { ERROR ( ""Xattr<S2SV_blank>block<S2SV_blank>%d<S2SV_blank>should<S2SV_blank>be<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>in<S2SV_blank>length,<S2SV_blank>"" ""it<S2SV_blank>is<S2SV_blank>%d<S2SV_blank>bytes\\n"" , i , SQUASHFS_METADATA_SIZE , length ) ; goto failed3 ; } } for ( i = 0 ; i < ids ; i ++ ) SQUASHFS_INSWAP_XATTR_ID ( & xattr_ids [ i ] ) ; free ( index ) ; return ids ; failed3 : free ( xattrs ) ; failed2 : free ( xattr_ids ) ; failed1 : free ( index ) ; return 0 ; }","int res , i , indexes , index_bytes ; unsigned int ids ; long long bytes <S2SV_ModEnd> ; long long <S2SV_ModStart> id_table ) ; ids = id_table . xattr_ids ; xattr_table_start <S2SV_ModEnd> = id_table . <S2SV_ModStart> . xattr_table_start ; index_bytes = SQUASHFS_XATTR_BLOCK_BYTES ( ( long long ) ids ) ; indexes = SQUASHFS_XATTR_BLOCKS ( ( long long ) ids ) ; if ( index_bytes != ( sBlk -> bytes_used - ( <S2SV_ModEnd> sBlk -> xattr_id_table_start <S2SV_ModStart> ( id_table ) ) ) ) { ERROR ( ""read_xattrs_from_disk:<S2SV_blank>Bad<S2SV_blank>xattr_ids<S2SV_blank>count<S2SV_blank>in<S2SV_blank>super<S2SV_blank>block\\n"" ) ; return 0 ; } if ( table_start != NULL ) * table_start = id_table . xattr_table_start ; if ( flag ) return id_table . xattr_ids ; index = malloc ( index_bytes ) ; if ( index == NULL ) MEM_ERROR ( ) ; res = read_fs_bytes ( fd , sBlk -> xattr_id_table_start + sizeof ( id_table ) <S2SV_ModStart> = SQUASHFS_XATTR_BYTES ( ( long long ) <S2SV_ModStart> ) + ( ( long long )"
316,"static void rose_loopback_timer ( unsigned long param ) { struct sk_buff * skb ; struct net_device * dev ; rose_address * dest ; struct sock * sk ; unsigned short frametype ; unsigned int lci_i , lci_o ; <S2SV_StartBug> while ( ( skb = skb_dequeue ( & loopback_queue ) ) != NULL ) { <S2SV_EndBug> lci_i = ( ( skb -> data [ 0 ] << 8 ) & 0xF00 ) + ( ( skb -> data [ 1 ] << 0 ) & 0x0FF ) ; frametype = skb -> data [ 2 ] ; <S2SV_StartBug> dest = ( rose_address * ) ( skb -> data + 4 ) ; <S2SV_EndBug> lci_o = ROSE_DEFAULT_MAXVC + 1 - lci_i ; skb_reset_transport_header ( skb ) ; sk = rose_find_socket ( lci_o , rose_loopback_neigh ) ; if ( sk ) { if ( rose_process_rx_frame ( sk , skb ) == 0 ) kfree_skb ( skb ) ; continue ; } if ( frametype == ROSE_CALL_REQUEST ) { if ( ( dev = rose_dev_get ( dest ) ) != NULL ) { if ( rose_rx_call_request ( skb , dev , rose_loopback_neigh , lci_o ) == 0 ) kfree_skb ( skb ) ; } else { kfree_skb ( skb ) ; } } else { kfree_skb ( skb ) ; } } }",NULL ) { if ( skb -> len < ROSE_MIN_LEN ) { kfree_skb ( skb ) ; continue ; } <S2SV_ModStart> 2 ] ; if ( frametype == ROSE_CALL_REQUEST && ( skb -> len <= ROSE_CALL_REQ_FACILITIES_OFF || skb -> data [ ROSE_CALL_REQ_ADDR_LEN_OFF ] != ROSE_CALL_REQ_ADDR_LEN_VAL ) ) { kfree_skb ( skb ) ; continue ; } <S2SV_ModStart> -> data + ROSE_CALL_REQ_DEST_ADDR_OFF <S2SV_ModEnd> ) ; lci_o
317,"static int telnet_parse ( netdissect_options * ndo , const u_char * sp , u_int length , int print ) { int i , x ; u_int c ; const u_char * osp , * p ; # define FETCH ( c , sp , length ) do { if ( length < 1 ) goto pktend ; ND_TCHECK ( * sp ) ; c = * sp ++ ; length -- ; } while ( 0 ) osp = sp ; FETCH ( c , sp , length ) ; if ( c != IAC ) goto pktend ; FETCH ( c , sp , length ) ; if ( c == IAC ) { if ( print ) ND_PRINT ( ( ndo , ""IAC<S2SV_blank>IAC"" ) ) ; goto done ; } i = c - TELCMD_FIRST ; if ( i < 0 || i > IAC - TELCMD_FIRST ) goto pktend ; switch ( c ) { case DONT : case DO : case WONT : case WILL : case SB : FETCH ( x , sp , length ) ; if ( x >= 0 && x < NTELOPTS ) { if ( print ) ND_PRINT ( ( ndo , ""%s<S2SV_blank>%s"" , telcmds [ i ] , telopts [ x ] ) ) ; } else { if ( print ) ND_PRINT ( ( ndo , ""%s<S2SV_blank>%#x"" , telcmds [ i ] , x ) ) ; } if ( c != SB ) break ; p = sp ; while ( length > ( u_int ) ( p + 1 - sp ) ) { ND_TCHECK2 ( * p , 2 ) ; if ( p [ 0 ] == IAC && p [ 1 ] == SE ) break ; p ++ ; } <S2SV_StartBug> if ( * p != IAC ) <S2SV_EndBug> goto pktend ; switch ( x ) { case TELOPT_AUTHENTICATION : if ( p <= sp ) break ; FETCH ( c , sp , length ) ; if ( print ) ND_PRINT ( ( ndo , ""<S2SV_blank>%s"" , STR_OR_ID ( c , authcmd ) ) ) ; if ( p <= sp ) break ; FETCH ( c , sp , length ) ; if ( print ) ND_PRINT ( ( ndo , ""<S2SV_blank>%s"" , STR_OR_ID ( c , authtype ) ) ) ; break ; case TELOPT_ENCRYPT : if ( p <= sp ) break ; FETCH ( c , sp , length ) ; if ( print ) ND_PRINT ( ( ndo , ""<S2SV_blank>%s"" , STR_OR_ID ( c , enccmd ) ) ) ; if ( p <= sp ) break ; FETCH ( c , sp , length ) ; if ( print ) ND_PRINT ( ( ndo , ""<S2SV_blank>%s"" , STR_OR_ID ( c , enctype ) ) ) ; break ; default : if ( p <= sp ) break ; FETCH ( c , sp , length ) ; if ( print ) ND_PRINT ( ( ndo , ""<S2SV_blank>%s"" , STR_OR_ID ( c , cmds ) ) ) ; break ; } while ( p > sp ) { FETCH ( x , sp , length ) ; if ( print ) ND_PRINT ( ( ndo , ""<S2SV_blank>%#x"" , x ) ) ; } if ( print ) ND_PRINT ( ( ndo , ""<S2SV_blank>SE"" ) ) ; sp += 2 ; break ; default : if ( print ) ND_PRINT ( ( ndo , ""%s"" , telcmds [ i ] ) ) ; goto done ; } done : return sp - osp ; trunc : ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; pktend : return - 1 ; # undef FETCH }",++ ; } ND_TCHECK ( * p ) ;
318,"static void tg3_read_vpd ( struct tg3 * tp ) { u8 * vpd_data ; unsigned int block_end , rosize , len ; u32 vpdlen ; int j , i = 0 ; vpd_data = ( u8 * ) tg3_vpd_readblock ( tp , & vpdlen ) ; if ( ! vpd_data ) goto out_no_vpd ; i = pci_vpd_find_tag ( vpd_data , 0 , vpdlen , PCI_VPD_LRDT_RO_DATA ) ; if ( i < 0 ) goto out_not_found ; rosize = pci_vpd_lrdt_size ( & vpd_data [ i ] ) ; block_end = i + PCI_VPD_LRDT_TAG_SIZE + rosize ; i += PCI_VPD_LRDT_TAG_SIZE ; if ( block_end > vpdlen ) goto out_not_found ; j = pci_vpd_find_info_keyword ( vpd_data , i , rosize , PCI_VPD_RO_KEYWORD_MFR_ID ) ; if ( j > 0 ) { len = pci_vpd_info_field_size ( & vpd_data [ j ] ) ; j += PCI_VPD_INFO_FLD_HDR_SIZE ; if ( j + len > block_end || len != 4 || memcmp ( & vpd_data [ j ] , ""1028"" , 4 ) ) goto partno ; j = pci_vpd_find_info_keyword ( vpd_data , i , rosize , PCI_VPD_RO_KEYWORD_VENDOR0 ) ; if ( j < 0 ) goto partno ; len = pci_vpd_info_field_size ( & vpd_data [ j ] ) ; j += PCI_VPD_INFO_FLD_HDR_SIZE ; if ( j + len > block_end ) goto partno ; <S2SV_StartBug> memcpy ( tp -> fw_ver , & vpd_data [ j ] , len ) ; <S2SV_EndBug> <S2SV_StartBug> strncat ( tp -> fw_ver , ""<S2SV_blank>bc<S2SV_blank>"" , vpdlen - len - 1 ) ; <S2SV_EndBug> } partno : i = pci_vpd_find_info_keyword ( vpd_data , i , rosize , PCI_VPD_RO_KEYWORD_PARTNO ) ; if ( i < 0 ) goto out_not_found ; len = pci_vpd_info_field_size ( & vpd_data [ i ] ) ; i += PCI_VPD_INFO_FLD_HDR_SIZE ; if ( len > TG3_BPN_SIZE || ( len + i ) > vpdlen ) goto out_not_found ; memcpy ( tp -> board_part_number , & vpd_data [ i ] , len ) ; out_not_found : kfree ( vpd_data ) ; if ( tp -> board_part_number [ 0 ] ) return ; out_no_vpd : if ( tg3_asic_rev ( tp ) == ASIC_REV_5717 ) { if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_5717 || tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_5717_C ) strcpy ( tp -> board_part_number , ""BCM5717"" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_5718 ) strcpy ( tp -> board_part_number , ""BCM5718"" ) ; else goto nomatch ; } else if ( tg3_asic_rev ( tp ) == ASIC_REV_57780 ) { if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57780 ) strcpy ( tp -> board_part_number , ""BCM57780"" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57760 ) strcpy ( tp -> board_part_number , ""BCM57760"" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57790 ) strcpy ( tp -> board_part_number , ""BCM57790"" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57788 ) strcpy ( tp -> board_part_number , ""BCM57788"" ) ; else goto nomatch ; } else if ( tg3_asic_rev ( tp ) == ASIC_REV_57765 ) { if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57761 ) strcpy ( tp -> board_part_number , ""BCM57761"" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57765 ) strcpy ( tp -> board_part_number , ""BCM57765"" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57781 ) strcpy ( tp -> board_part_number , ""BCM57781"" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57785 ) strcpy ( tp -> board_part_number , ""BCM57785"" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57791 ) strcpy ( tp -> board_part_number , ""BCM57791"" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57795 ) strcpy ( tp -> board_part_number , ""BCM57795"" ) ; else goto nomatch ; } else if ( tg3_asic_rev ( tp ) == ASIC_REV_57766 ) { if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57762 ) strcpy ( tp -> board_part_number , ""BCM57762"" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57766 ) strcpy ( tp -> board_part_number , ""BCM57766"" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57782 ) strcpy ( tp -> board_part_number , ""BCM57782"" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57786 ) strcpy ( tp -> board_part_number , ""BCM57786"" ) ; else goto nomatch ; } else if ( tg3_asic_rev ( tp ) == ASIC_REV_5906 ) { strcpy ( tp -> board_part_number , ""BCM95906"" ) ; } else { nomatch : strcpy ( tp -> board_part_number , ""none"" ) ; } }","goto partno ; if ( len >= sizeof <S2SV_ModEnd> ( tp -> <S2SV_ModStart> tp -> fw_ver ) ) len = sizeof <S2SV_ModEnd> ( tp -> <S2SV_ModStart> tp -> fw_ver ) - 1 ; memset ( tp -> fw_ver , 0 , sizeof ( tp -> fw_ver ) ) ; snprintf ( tp -> fw_ver , sizeof ( tp -> fw_ver ) , ""%.*s<S2SV_blank>bc<S2SV_blank>"" , len , & vpd_data [ j ] <S2SV_ModEnd> ) ; }"
319,"static int inet6_create ( struct net * net , struct socket * sock , int protocol , int kern ) { struct inet_sock * inet ; struct ipv6_pinfo * np ; struct sock * sk ; struct inet_protosw * answer ; struct proto * answer_prot ; unsigned char answer_flags ; int try_loading_module = 0 ; <S2SV_StartBug> int err ; <S2SV_EndBug> lookup_protocol : err = - ESOCKTNOSUPPORT ; rcu_read_lock ( ) ; list_for_each_entry_rcu ( answer , & inetsw6 [ sock -> type ] , list ) { err = 0 ; if ( protocol == answer -> protocol ) { if ( protocol != IPPROTO_IP ) break ; } else { if ( IPPROTO_IP == protocol ) { protocol = answer -> protocol ; break ; } if ( IPPROTO_IP == answer -> protocol ) break ; } err = - EPROTONOSUPPORT ; } if ( err ) { if ( try_loading_module < 2 ) { rcu_read_unlock ( ) ; if ( ++ try_loading_module == 1 ) request_module ( ""net-pf-%d-proto-%d-type-%d"" , PF_INET6 , protocol , sock -> type ) ; else request_module ( ""net-pf-%d-proto-%d"" , PF_INET6 , protocol ) ; goto lookup_protocol ; } else goto out_rcu_unlock ; } err = - EPERM ; if ( sock -> type == SOCK_RAW && ! kern && ! ns_capable ( net -> user_ns , CAP_NET_RAW ) ) goto out_rcu_unlock ; sock -> ops = answer -> ops ; answer_prot = answer -> prot ; answer_flags = answer -> flags ; rcu_read_unlock ( ) ; WARN_ON ( ! answer_prot -> slab ) ; err = - ENOBUFS ; sk = sk_alloc ( net , PF_INET6 , GFP_KERNEL , answer_prot , kern ) ; if ( ! sk ) goto out ; sock_init_data ( sock , sk ) ; err = 0 ; if ( INET_PROTOSW_REUSE & answer_flags ) sk -> sk_reuse = SK_CAN_REUSE ; inet = inet_sk ( sk ) ; inet -> is_icsk = ( INET_PROTOSW_ICSK & answer_flags ) != 0 ; if ( SOCK_RAW == sock -> type ) { inet -> inet_num = protocol ; if ( IPPROTO_RAW == protocol ) inet -> hdrincl = 1 ; } sk -> sk_destruct = inet_sock_destruct ; sk -> sk_family = PF_INET6 ; sk -> sk_protocol = protocol ; sk -> sk_backlog_rcv = answer -> prot -> backlog_rcv ; inet_sk ( sk ) -> pinet6 = np = inet6_sk_generic ( sk ) ; np -> hop_limit = - 1 ; np -> mcast_hops = IPV6_DEFAULT_MCASTHOPS ; np -> mc_loop = 1 ; np -> pmtudisc = IPV6_PMTUDISC_WANT ; np -> autoflowlabel = ip6_default_np_autolabel ( sock_net ( sk ) ) ; sk -> sk_ipv6only = net -> ipv6 . sysctl . bindv6only ; inet -> uc_ttl = - 1 ; inet -> mc_loop = 1 ; inet -> mc_ttl = 1 ; inet -> mc_index = 0 ; inet -> mc_list = NULL ; inet -> rcv_tos = 0 ; if ( net -> ipv4 . sysctl_ip_no_pmtu_disc ) inet -> pmtudisc = IP_PMTUDISC_DONT ; else inet -> pmtudisc = IP_PMTUDISC_WANT ; sk_refcnt_debug_inc ( sk ) ; if ( inet -> inet_num ) { inet -> inet_sport = htons ( inet -> inet_num ) ; sk -> sk_prot -> hash ( sk ) ; } if ( sk -> sk_prot -> init ) { err = sk -> sk_prot -> init ( sk ) ; if ( err ) { sk_common_release ( sk ) ; goto out ; } } out : return err ; out_rcu_unlock : rcu_read_unlock ( ) ; goto out ; }",; int err ; if ( protocol < 0 || protocol >= IPPROTO_MAX ) return - EINVAL
320,"<S2SV_StartBug> static struct btrfs_dir_item * btrfs_match_dir_item_name ( struct btrfs_root * root , <S2SV_EndBug> struct btrfs_path * path , const char * name , int name_len ) { struct btrfs_dir_item * dir_item ; unsigned long name_ptr ; u32 total_len ; u32 cur = 0 ; u32 this_len ; struct extent_buffer * leaf ; leaf = path -> nodes [ 0 ] ; dir_item = btrfs_item_ptr ( leaf , path -> slots [ 0 ] , struct btrfs_dir_item ) ; if ( verify_dir_item ( root , leaf , dir_item ) ) return NULL ; total_len = btrfs_item_size_nr ( leaf , path -> slots [ 0 ] ) ; while ( cur < total_len ) { this_len = sizeof ( * dir_item ) + btrfs_dir_name_len ( leaf , dir_item ) + btrfs_dir_data_len ( leaf , dir_item ) ; name_ptr = ( unsigned long ) ( dir_item + 1 ) ; if ( btrfs_dir_name_len ( leaf , dir_item ) == name_len && memcmp_extent_buffer ( leaf , name , name_ptr , name_len ) == 0 ) return dir_item ; cur += this_len ; dir_item = ( struct btrfs_dir_item * ) ( ( char * ) dir_item + this_len ) ; } return NULL ; }",<S2SV_null> <S2SV_null> <S2SV_null> <S2SV_ModEnd> struct btrfs_dir_item *
321,"<S2SV_StartBug> static void ip6_append_data_mtu ( int * mtu , <S2SV_EndBug> int * maxfraglen , unsigned int fragheaderlen , struct sk_buff * skb , <S2SV_StartBug> struct rt6_info * rt ) <S2SV_EndBug> { if ( ! ( rt -> dst . flags & DST_XFRM_TUNNEL ) ) { if ( skb == NULL ) { * mtu = * mtu - rt -> dst . header_len ; } else { <S2SV_StartBug> * mtu = dst_mtu ( rt -> dst . path ) ; <S2SV_EndBug> } * maxfraglen = ( ( * mtu - fragheaderlen ) & ~ 7 ) + fragheaderlen - sizeof ( struct frag_hdr ) ; } }","void ip6_append_data_mtu ( unsigned <S2SV_ModStart> rt6_info * rt , bool pmtuprobe <S2SV_ModStart> * mtu = min ( * mtu , pmtuprobe ? rt -> dst . dev -> mtu : <S2SV_ModStart> dst . path )"
322,"static void alpha_perf_event_irq_handler ( unsigned long la_ptr , struct pt_regs * regs ) { struct cpu_hw_events * cpuc ; struct perf_sample_data data ; struct perf_event * event ; struct hw_perf_event * hwc ; int idx , j ; __get_cpu_var ( irq_pmi_count ) ++ ; cpuc = & __get_cpu_var ( cpu_hw_events ) ; wrperfmon ( PERFMON_CMD_DISABLE , cpuc -> idx_mask ) ; if ( unlikely ( la_ptr >= alpha_pmu -> num_pmcs ) ) { irq_err_count ++ ; pr_warning ( ""PMI:<S2SV_blank>silly<S2SV_blank>index<S2SV_blank>%ld\\n"" , la_ptr ) ; wrperfmon ( PERFMON_CMD_ENABLE , cpuc -> idx_mask ) ; return ; } idx = la_ptr ; perf_sample_data_init ( & data , 0 ) ; for ( j = 0 ; j < cpuc -> n_events ; j ++ ) { if ( cpuc -> current_idx [ j ] == idx ) break ; } if ( unlikely ( j == cpuc -> n_events ) ) { wrperfmon ( PERFMON_CMD_ENABLE , cpuc -> idx_mask ) ; return ; } event = cpuc -> event [ j ] ; if ( unlikely ( ! event ) ) { irq_err_count ++ ; pr_warning ( ""PMI:<S2SV_blank>No<S2SV_blank>event<S2SV_blank>at<S2SV_blank>index<S2SV_blank>%d!\\n"" , idx ) ; wrperfmon ( PERFMON_CMD_ENABLE , cpuc -> idx_mask ) ; return ; } hwc = & event -> hw ; alpha_perf_event_update ( event , hwc , idx , alpha_pmu -> pmc_max_period [ idx ] + 1 ) ; data . period = event -> hw . last_period ; if ( alpha_perf_event_set_period ( event , hwc , idx ) ) { <S2SV_StartBug> if ( perf_event_overflow ( event , 1 , & data , regs ) ) { <S2SV_EndBug> alpha_pmu_stop ( event , 0 ) ; } } wrperfmon ( PERFMON_CMD_ENABLE , cpuc -> idx_mask ) ; return ; }","( event , <S2SV_ModEnd> & data ,"
323,"Datum varbit_in ( PG_FUNCTION_ARGS ) { char * input_string = PG_GETARG_CSTRING ( 0 ) ; # ifdef NOT_USED Oid typelem = PG_GETARG_OID ( 1 ) ; # endif int32 atttypmod = PG_GETARG_INT32 ( 2 ) ; VarBit * result ; char * sp ; bits8 * r ; int len , bitlen , slen ; bool bit_not_hex ; int bc ; bits8 x = 0 ; if ( input_string [ 0 ] == 'b' || input_string [ 0 ] == 'B' ) { bit_not_hex = true ; sp = input_string + 1 ; } else if ( input_string [ 0 ] == 'x' || input_string [ 0 ] == 'X' ) { bit_not_hex = false ; sp = input_string + 1 ; } else { bit_not_hex = true ; sp = input_string ; } slen = strlen ( sp ) ; if ( bit_not_hex ) bitlen = slen ; else <S2SV_StartBug> bitlen = slen * 4 ; <S2SV_EndBug> if ( atttypmod <= 0 ) atttypmod = bitlen ; else if ( bitlen > atttypmod ) ereport ( ERROR , ( errcode ( ERRCODE_STRING_DATA_RIGHT_TRUNCATION ) , errmsg ( ""bit<S2SV_blank>string<S2SV_blank>too<S2SV_blank>long<S2SV_blank>for<S2SV_blank>type<S2SV_blank>bit<S2SV_blank>varying(%d)"" , atttypmod ) ) ) ; len = VARBITTOTALLEN ( bitlen ) ; result = ( VarBit * ) palloc0 ( len ) ; SET_VARSIZE ( result , len ) ; VARBITLEN ( result ) = Min ( bitlen , atttypmod ) ; r = VARBITS ( result ) ; if ( bit_not_hex ) { x = HIGHBIT ; for ( ; * sp ; sp ++ ) { if ( * sp == '1' ) * r |= x ; else if ( * sp != '0' ) ereport ( ERROR , ( errcode ( ERRCODE_INVALID_TEXT_REPRESENTATION ) , errmsg ( ""\\""%c\\""<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>binary<S2SV_blank>digit"" , * sp ) ) ) ; x >>= 1 ; if ( x == 0 ) { x = HIGHBIT ; r ++ ; } } } else { for ( bc = 0 ; * sp ; sp ++ ) { if ( * sp >= '0' && * sp <= '9' ) x = ( bits8 ) ( * sp - '0' ) ; else if ( * sp >= 'A' && * sp <= 'F' ) x = ( bits8 ) ( * sp - 'A' ) + 10 ; else if ( * sp >= 'a' && * sp <= 'f' ) x = ( bits8 ) ( * sp - 'a' ) + 10 ; else ereport ( ERROR , ( errcode ( ERRCODE_INVALID_TEXT_REPRESENTATION ) , errmsg ( ""\\""%c\\""<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>hexadecimal<S2SV_blank>digit"" , * sp ) ) ) ; if ( bc ) { * r ++ |= x ; bc = 0 ; } else { * r = x << 4 ; bc = 1 ; } } } PG_RETURN_VARBIT_P ( result ) ; }","slen ; else { if ( slen > VARBITMAXLEN / 4 ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""bit<S2SV_blank>string<S2SV_blank>length<S2SV_blank>exceeds<S2SV_blank>the<S2SV_blank>maximum<S2SV_blank>allowed<S2SV_blank>(%d)"" , VARBITMAXLEN ) ) ) ; <S2SV_ModStart> * 4 ; }"
324,"static int unix_dgram_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct net * net = sock_net ( sk ) ; struct unix_sock * u = unix_sk ( sk ) ; struct sockaddr_un * sunaddr = msg -> msg_name ; struct sock * other = NULL ; int namelen = 0 ; int err ; unsigned int hash ; struct sk_buff * skb ; long timeo ; struct scm_cookie tmp_scm ; int max_level ; int data_len = 0 ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; <S2SV_StartBug> err = scm_send ( sock , msg , siocb -> scm ) ; <S2SV_EndBug> if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out ; if ( msg -> msg_namelen ) { err = unix_mkname ( sunaddr , msg -> msg_namelen , & hash ) ; if ( err < 0 ) goto out ; namelen = err ; } else { sunaddr = NULL ; err = - ENOTCONN ; other = unix_peer_get ( sk ) ; if ( ! other ) goto out ; } if ( test_bit ( SOCK_PASSCRED , & sock -> flags ) && ! u -> addr && ( err = unix_autobind ( sock ) ) != 0 ) goto out ; err = - EMSGSIZE ; if ( len > sk -> sk_sndbuf - 32 ) goto out ; if ( len > SKB_MAX_ALLOC ) data_len = min_t ( size_t , len - SKB_MAX_ALLOC , MAX_SKB_FRAGS * PAGE_SIZE ) ; skb = sock_alloc_send_pskb ( sk , len - data_len , data_len , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out ; err = unix_scm_to_skb ( siocb -> scm , skb , true ) ; if ( err < 0 ) goto out_free ; max_level = err + 1 ; unix_get_secdata ( siocb -> scm , skb ) ; skb_put ( skb , len - data_len ) ; skb -> data_len = data_len ; skb -> len = len ; err = skb_copy_datagram_from_iovec ( skb , 0 , msg -> msg_iov , 0 , len ) ; if ( err ) goto out_free ; timeo = sock_sndtimeo ( sk , msg -> msg_flags & MSG_DONTWAIT ) ; restart : if ( ! other ) { err = - ECONNRESET ; if ( sunaddr == NULL ) goto out_free ; other = unix_find_other ( net , sunaddr , namelen , sk -> sk_type , hash , & err ) ; if ( other == NULL ) goto out_free ; } if ( sk_filter ( other , skb ) < 0 ) { err = len ; goto out_free ; } unix_state_lock ( other ) ; err = - EPERM ; if ( ! unix_may_send ( sk , other ) ) goto out_unlock ; if ( sock_flag ( other , SOCK_DEAD ) ) { unix_state_unlock ( other ) ; sock_put ( other ) ; err = 0 ; unix_state_lock ( sk ) ; if ( unix_peer ( sk ) == other ) { unix_peer ( sk ) = NULL ; unix_state_unlock ( sk ) ; unix_dgram_disconnected ( sk , other ) ; sock_put ( other ) ; err = - ECONNREFUSED ; } else { unix_state_unlock ( sk ) ; } other = NULL ; if ( err ) goto out_free ; goto restart ; } err = - EPIPE ; if ( other -> sk_shutdown & RCV_SHUTDOWN ) goto out_unlock ; if ( sk -> sk_type != SOCK_SEQPACKET ) { err = security_unix_may_send ( sk -> sk_socket , other -> sk_socket ) ; if ( err ) goto out_unlock ; } if ( unix_peer ( other ) != sk && unix_recvq_full ( other ) ) { if ( ! timeo ) { err = - EAGAIN ; goto out_unlock ; } timeo = unix_wait_for_peer ( other , timeo ) ; err = sock_intr_errno ( timeo ) ; if ( signal_pending ( current ) ) goto out_free ; goto restart ; } if ( sock_flag ( other , SOCK_RCVTSTAMP ) ) __net_timestamp ( skb ) ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , len ) ; sock_put ( other ) ; scm_destroy ( siocb -> scm ) ; return len ; out_unlock : unix_state_unlock ( other ) ; out_free : kfree_skb ( skb ) ; out : if ( other ) sock_put ( other ) ; scm_destroy ( siocb -> scm ) ; return err ; }","siocb -> scm , false"
325,"void jp2_box_dump ( jp2_box_t * box , FILE * out ) { jp2_boxinfo_t * boxinfo ; boxinfo = jp2_boxinfolookup ( box -> type ) ; assert ( boxinfo ) ; fprintf ( out , ""JP2<S2SV_blank>box:<S2SV_blank>"" ) ; fprintf ( out , ""type=%c%s%c<S2SV_blank>(0x%08"" PRIxFAST32 "");<S2SV_blank>length=%"" PRIuFAST32 ""\\n"" , \'""\' , boxinfo -> name , \'""\' , box -> type , box -> len ) ; if ( box -> ops -> dumpdata ) { ( * box -> ops -> dumpdata ) ( box , out ) ; } }","
"
326,"<S2SV_StartBug> static int udp_push_pending_frames ( struct sock * sk ) <S2SV_EndBug> { struct udp_sock * up = udp_sk ( sk ) ; struct inet_sock * inet = inet_sk ( sk ) ; struct flowi4 * fl4 = & inet -> cork . fl . u . ip4 ; struct sk_buff * skb ; int err = 0 ; skb = ip_finish_skb ( sk , fl4 ) ; if ( ! skb ) goto out ; err = udp_send_skb ( skb , fl4 ) ; out : up -> len = 0 ; up -> pending = 0 ; return err ; }",<S2SV_null> <S2SV_null> <S2SV_null> <S2SV_ModEnd> int udp_push_pending_frames (
327,"static int mount_autodev ( const char * name , const struct lxc_rootfs * rootfs , const char * lxcpath ) { int ret ; size_t clen ; char * path ; INFO ( ""Mounting<S2SV_blank>container<S2SV_blank>/dev"" ) ; clen = ( rootfs -> path ? strlen ( rootfs -> mount ) : 0 ) + 9 ; path = alloca ( clen ) ; ret = snprintf ( path , clen , ""%s/dev"" , rootfs -> path ? rootfs -> mount : """" ) ; if ( ret < 0 || ret >= clen ) return - 1 ; if ( ! dir_exists ( path ) ) { WARN ( ""No<S2SV_blank>/dev<S2SV_blank>in<S2SV_blank>container."" ) ; WARN ( ""Proceeding<S2SV_blank>without<S2SV_blank>autodev<S2SV_blank>setup"" ) ; return 0 ; } <S2SV_StartBug> if ( mount ( ""none"" , path , ""tmpfs"" , 0 , ""size=100000,mode=755"" ) ) { <S2SV_EndBug> SYSERROR ( ""Failed<S2SV_blank>mounting<S2SV_blank>tmpfs<S2SV_blank>onto<S2SV_blank>%s\\n"" , path ) ; return false ; } INFO ( ""Mounted<S2SV_blank>tmpfs<S2SV_blank>onto<S2SV_blank>%s"" , path ) ; ret = snprintf ( path , clen , ""%s/dev/pts"" , rootfs -> path ? rootfs -> mount : """" ) ; if ( ret < 0 || ret >= clen ) return - 1 ; if ( ! dir_exists ( path ) ) { ret = mkdir ( path , S_IRWXU | S_IRGRP | S_IXGRP | S_IROTH | S_IXOTH ) ; if ( ret ) { SYSERROR ( ""Failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>/dev/pts<S2SV_blank>in<S2SV_blank>container"" ) ; return - 1 ; } } INFO ( ""Mounted<S2SV_blank>container<S2SV_blank>/dev"" ) ; return 0 ; }","} if ( safe_mount <S2SV_ModEnd> ( ""none"" , <S2SV_ModStart> 0 , ""size=100000,mode=755"" , rootfs -> path ? rootfs -> mount : NULL"
328,"PHPAPI int php_var_unserialize ( UNSERIALIZE_PARAMETER ) { const unsigned char * cursor , * limit , * marker , * start ; zval * * rval_ref ; limit = max ; cursor = * p ; if ( YYCURSOR >= YYLIMIT ) { return 0 ; } if ( var_hash && cursor [ 0 ] != 'R' ) { var_push ( var_hash , rval ) ; } start = cursor ; <S2SV_StartBug> # line 495 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> { YYCTYPE yych ; static const unsigned char yybm [ ] = { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 128 , 128 , 128 , 128 , 128 , 128 , 128 , 128 , 128 , 128 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , } ; if ( ( YYLIMIT - YYCURSOR ) < 7 ) YYFILL ( 7 ) ; yych = * YYCURSOR ; switch ( yych ) { case 'C' : case 'O' : goto yy13 ; case 'N' : goto yy5 ; case 'R' : goto yy2 ; case 'S' : goto yy10 ; case 'a' : goto yy11 ; case 'b' : goto yy6 ; case 'd' : goto yy8 ; case 'i' : goto yy7 ; case 'o' : goto yy12 ; case 'r' : goto yy4 ; case 's' : goto yy9 ; case '}' : goto yy14 ; default : goto yy16 ; } yy2 : yych = * ( YYMARKER = ++ YYCURSOR ) ; if ( yych == ':' ) goto yy95 ; yy3 : <S2SV_StartBug> # line 860 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> { return 0 ; } <S2SV_StartBug> # line 557 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> yy4 : yych = * ( YYMARKER = ++ YYCURSOR ) ; if ( yych == ':' ) goto yy89 ; goto yy3 ; yy5 : yych = * ++ YYCURSOR ; if ( yych == ';' ) goto yy87 ; goto yy3 ; yy6 : yych = * ( YYMARKER = ++ YYCURSOR ) ; if ( yych == ':' ) goto yy83 ; goto yy3 ; yy7 : yych = * ( YYMARKER = ++ YYCURSOR ) ; if ( yych == ':' ) goto yy77 ; goto yy3 ; yy8 : yych = * ( YYMARKER = ++ YYCURSOR ) ; if ( yych == ':' ) goto yy53 ; goto yy3 ; yy9 : yych = * ( YYMARKER = ++ YYCURSOR ) ; if ( yych == ':' ) goto yy46 ; goto yy3 ; yy10 : yych = * ( YYMARKER = ++ YYCURSOR ) ; if ( yych == ':' ) goto yy39 ; goto yy3 ; yy11 : yych = * ( YYMARKER = ++ YYCURSOR ) ; if ( yych == ':' ) goto yy32 ; goto yy3 ; yy12 : yych = * ( YYMARKER = ++ YYCURSOR ) ; if ( yych == ':' ) goto yy25 ; goto yy3 ; yy13 : yych = * ( YYMARKER = ++ YYCURSOR ) ; if ( yych == ':' ) goto yy17 ; goto yy3 ; yy14 : ++ YYCURSOR ; <S2SV_StartBug> # line 854 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> { php_error_docref ( NULL TSRMLS_CC , E_NOTICE , ""Unexpected<S2SV_blank>end<S2SV_blank>of<S2SV_blank>serialized<S2SV_blank>data"" ) ; return 0 ; } <S2SV_StartBug> # line 606 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> yy16 : yych = * ++ YYCURSOR ; goto yy3 ; yy17 : yych = * ++ YYCURSOR ; if ( yybm [ 0 + yych ] & 128 ) { goto yy20 ; } if ( yych == '+' ) goto yy19 ; yy18 : YYCURSOR = YYMARKER ; goto yy3 ; yy19 : yych = * ++ YYCURSOR ; if ( yybm [ 0 + yych ] & 128 ) { goto yy20 ; } goto yy18 ; yy20 : ++ YYCURSOR ; if ( ( YYLIMIT - YYCURSOR ) < 2 ) YYFILL ( 2 ) ; yych = * YYCURSOR ; if ( yybm [ 0 + yych ] & 128 ) { goto yy20 ; } if ( yych <= '/' ) goto yy18 ; if ( yych >= ';' ) goto yy18 ; yych = * ++ YYCURSOR ; if ( yych != \'""\' ) goto yy18 ; ++ YYCURSOR ; <S2SV_StartBug> # line 707 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> { size_t len , len2 , len3 , maxlen ; long elements ; char * class_name ; zend_class_entry * ce ; zend_class_entry * * pce ; int incomplete_class = 0 ; int custom_object = 0 ; zval * user_func ; zval * retval_ptr ; zval * * args [ 1 ] ; zval * arg_func_name ; if ( ! var_hash ) return 0 ; if ( * start == 'C' ) { custom_object = 1 ; } INIT_PZVAL ( * rval ) ; len2 = len = parse_uiv ( start + 2 ) ; maxlen = max - YYCURSOR ; if ( maxlen < len || len == 0 ) { * p = start + 2 ; return 0 ; } class_name = ( char * ) YYCURSOR ; YYCURSOR += len ; if ( * ( YYCURSOR ) != \'""\' ) { * p = YYCURSOR ; return 0 ; } if ( * ( YYCURSOR + 1 ) != ':' ) { * p = YYCURSOR + 1 ; return 0 ; } len3 = strspn ( class_name , ""0123456789_abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\\177\\200\\201\\202\\203\\204\\205\\206\\207\\210\\211\\212\\213\\214\\215\\216\\217\\220\\221\\222\\223\\224\\225\\226\\227\\230\\231\\232\\233\\234\\235\\236\\237\\240\\241\\242\\243\\244\\245\\246\\247\\250\\251\\252\\253\\254\\255\\256\\257\\260\\261\\262\\263\\264\\265\\266\\267\\270\\271\\272\\273\\274\\275\\276\\277\\300\\301\\302\\303\\304\\305\\306\\307\\310\\311\\312\\313\\314\\315\\316\\317\\320\\321\\322\\323\\324\\325\\326\\327\\330\\331\\332\\333\\334\\335\\336\\337\\340\\341\\342\\343\\344\\345\\346\\347\\350\\351\\352\\353\\354\\355\\356\\357\\360\\361\\362\\363\\364\\365\\366\\367\\370\\371\\372\\373\\374\\375\\376\\377\\\\"" ) ; if ( len3 != len ) { * p = YYCURSOR + len3 - len ; return 0 ; } class_name = estrndup ( class_name , len ) ; do { BG ( serialize_lock ) ++ ; if ( zend_lookup_class ( class_name , len2 , & pce TSRMLS_CC ) == SUCCESS ) { BG ( serialize_lock ) -- ; if ( EG ( exception ) ) { efree ( class_name ) ; return 0 ; } ce = * pce ; break ; } BG ( serialize_lock ) -- ; if ( EG ( exception ) ) { efree ( class_name ) ; return 0 ; } if ( ( PG ( unserialize_callback_func ) == NULL ) || ( PG ( unserialize_callback_func ) [ 0 ] == '\\0' ) ) { incomplete_class = 1 ; ce = PHP_IC_ENTRY ; break ; } MAKE_STD_ZVAL ( user_func ) ; ZVAL_STRING ( user_func , PG ( unserialize_callback_func ) , 1 ) ; args [ 0 ] = & arg_func_name ; MAKE_STD_ZVAL ( arg_func_name ) ; ZVAL_STRING ( arg_func_name , class_name , 1 ) ; BG ( serialize_lock ) ++ ; if ( call_user_function_ex ( CG ( function_table ) , NULL , user_func , & retval_ptr , 1 , args , 0 , NULL TSRMLS_CC ) != SUCCESS ) { BG ( serialize_lock ) -- ; if ( EG ( exception ) ) { efree ( class_name ) ; zval_ptr_dtor ( & user_func ) ; zval_ptr_dtor ( & arg_func_name ) ; return 0 ; } php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""defined<S2SV_blank>(%s)<S2SV_blank>but<S2SV_blank>not<S2SV_blank>found"" , user_func -> value . str . val ) ; incomplete_class = 1 ; ce = PHP_IC_ENTRY ; zval_ptr_dtor ( & user_func ) ; zval_ptr_dtor ( & arg_func_name ) ; break ; } BG ( serialize_lock ) -- ; if ( retval_ptr ) { zval_ptr_dtor ( & retval_ptr ) ; } if ( EG ( exception ) ) { efree ( class_name ) ; zval_ptr_dtor ( & user_func ) ; zval_ptr_dtor ( & arg_func_name ) ; return 0 ; } if ( zend_lookup_class ( class_name , len2 , & pce TSRMLS_CC ) == SUCCESS ) { ce = * pce ; } else { php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Function<S2SV_blank>%s()<S2SV_blank>hasn\'t<S2SV_blank>defined<S2SV_blank>the<S2SV_blank>class<S2SV_blank>it<S2SV_blank>was<S2SV_blank>called<S2SV_blank>for"" , user_func -> value . str . val ) ; incomplete_class = 1 ; ce = PHP_IC_ENTRY ; } zval_ptr_dtor ( & user_func ) ; zval_ptr_dtor ( & arg_func_name ) ; break ; } while ( 1 ) ; * p = YYCURSOR ; if ( custom_object ) { int ret ; ret = object_custom ( UNSERIALIZE_PASSTHRU , ce ) ; if ( ret && incomplete_class ) { php_store_class_name ( * rval , class_name , len2 ) ; } efree ( class_name ) ; return ret ; } elements = object_common1 ( UNSERIALIZE_PASSTHRU , ce ) ; if ( incomplete_class ) { php_store_class_name ( * rval , class_name , len2 ) ; } efree ( class_name ) ; return object_common2 ( UNSERIALIZE_PASSTHRU , elements ) ; } <S2SV_StartBug> # line 784 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> yy25 : yych = * ++ YYCURSOR ; if ( yych <= ',' ) { if ( yych != '+' ) goto yy18 ; } else { if ( yych <= '-' ) goto yy26 ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy27 ; goto yy18 ; } yy26 : yych = * ++ YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych >= ':' ) goto yy18 ; yy27 : ++ YYCURSOR ; if ( ( YYLIMIT - YYCURSOR ) < 2 ) YYFILL ( 2 ) ; yych = * YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy27 ; if ( yych >= ';' ) goto yy18 ; yych = * ++ YYCURSOR ; if ( yych != \'""\' ) goto yy18 ; ++ YYCURSOR ; <S2SV_StartBug> # line 698 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> { if ( ! var_hash ) return 0 ; INIT_PZVAL ( * rval ) ; return object_common2 ( UNSERIALIZE_PASSTHRU , object_common1 ( UNSERIALIZE_PASSTHRU , ZEND_STANDARD_CLASS_DEF_PTR ) ) ; } <S2SV_StartBug> # line 818 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> yy32 : yych = * ++ YYCURSOR ; if ( yych == '+' ) goto yy33 ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy34 ; goto yy18 ; yy33 : yych = * ++ YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych >= ':' ) goto yy18 ; yy34 : ++ YYCURSOR ; if ( ( YYLIMIT - YYCURSOR ) < 2 ) YYFILL ( 2 ) ; yych = * YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy34 ; if ( yych >= ';' ) goto yy18 ; yych = * ++ YYCURSOR ; if ( yych != '{' ) goto yy18 ; ++ YYCURSOR ; <S2SV_StartBug> # line 677 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> { long elements = parse_iv ( start + 2 ) ; * p = YYCURSOR ; if ( ! var_hash ) return 0 ; if ( elements < 0 ) { return 0 ; } INIT_PZVAL ( * rval ) ; array_init_size ( * rval , elements ) ; if ( ! process_nested_data ( UNSERIALIZE_PASSTHRU , Z_ARRVAL_PP ( rval ) , elements , 0 ) ) { return 0 ; } return finish_nested_data ( UNSERIALIZE_PASSTHRU ) ; } <S2SV_StartBug> # line 860 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> yy39 : yych = * ++ YYCURSOR ; if ( yych == '+' ) goto yy40 ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy41 ; goto yy18 ; yy40 : yych = * ++ YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych >= ':' ) goto yy18 ; yy41 : ++ YYCURSOR ; if ( ( YYLIMIT - YYCURSOR ) < 2 ) YYFILL ( 2 ) ; yych = * YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy41 ; if ( yych >= ';' ) goto yy18 ; yych = * ++ YYCURSOR ; if ( yych != \'""\' ) goto yy18 ; ++ YYCURSOR ; <S2SV_StartBug> # line 642 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> { size_t len , maxlen ; char * str ; len = parse_uiv ( start + 2 ) ; maxlen = max - YYCURSOR ; if ( maxlen < len ) { * p = start + 2 ; return 0 ; } if ( ( str = unserialize_str ( & YYCURSOR , & len , maxlen ) ) == NULL ) { return 0 ; } if ( * ( YYCURSOR ) != \'""\' ) { efree ( str ) ; * p = YYCURSOR ; return 0 ; } if ( * ( YYCURSOR + 1 ) != ';' ) { efree ( str ) ; * p = YYCURSOR + 1 ; return 0 ; } YYCURSOR += 2 ; * p = YYCURSOR ; INIT_PZVAL ( * rval ) ; ZVAL_STRINGL ( * rval , str , len , 0 ) ; return 1 ; } <S2SV_StartBug> # line 916 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> yy46 : yych = * ++ YYCURSOR ; if ( yych == '+' ) goto yy47 ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy48 ; goto yy18 ; yy47 : yych = * ++ YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych >= ':' ) goto yy18 ; yy48 : ++ YYCURSOR ; if ( ( YYLIMIT - YYCURSOR ) < 2 ) YYFILL ( 2 ) ; yych = * YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy48 ; if ( yych >= ';' ) goto yy18 ; yych = * ++ YYCURSOR ; if ( yych != \'""\' ) goto yy18 ; ++ YYCURSOR ; <S2SV_StartBug> # line 609 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> { size_t len , maxlen ; char * str ; len = parse_uiv ( start + 2 ) ; maxlen = max - YYCURSOR ; if ( maxlen < len ) { * p = start + 2 ; return 0 ; } str = ( char * ) YYCURSOR ; YYCURSOR += len ; if ( * ( YYCURSOR ) != \'""\' ) { * p = YYCURSOR ; return 0 ; } if ( * ( YYCURSOR + 1 ) != ';' ) { * p = YYCURSOR + 1 ; return 0 ; } YYCURSOR += 2 ; * p = YYCURSOR ; INIT_PZVAL ( * rval ) ; ZVAL_STRINGL ( * rval , str , len , 1 ) ; return 1 ; } <S2SV_StartBug> # line 970 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> yy53 : yych = * ++ YYCURSOR ; if ( yych <= '/' ) { if ( yych <= ',' ) { if ( yych == '+' ) goto yy57 ; goto yy18 ; } else { if ( yych <= '-' ) goto yy55 ; if ( yych <= '.' ) goto yy60 ; goto yy18 ; } } else { if ( yych <= 'I' ) { if ( yych <= '9' ) goto yy58 ; if ( yych <= 'H' ) goto yy18 ; goto yy56 ; } else { if ( yych != 'N' ) goto yy18 ; } } yych = * ++ YYCURSOR ; if ( yych == 'A' ) goto yy76 ; goto yy18 ; yy55 : yych = * ++ YYCURSOR ; if ( yych <= '/' ) { if ( yych == '.' ) goto yy60 ; goto yy18 ; } else { if ( yych <= '9' ) goto yy58 ; if ( yych != 'I' ) goto yy18 ; } yy56 : yych = * ++ YYCURSOR ; if ( yych == 'N' ) goto yy72 ; goto yy18 ; yy57 : yych = * ++ YYCURSOR ; if ( yych == '.' ) goto yy60 ; if ( yych <= '/' ) goto yy18 ; if ( yych >= ':' ) goto yy18 ; yy58 : ++ YYCURSOR ; if ( ( YYLIMIT - YYCURSOR ) < 4 ) YYFILL ( 4 ) ; yych = * YYCURSOR ; if ( yych <= ':' ) { if ( yych <= '.' ) { if ( yych <= '-' ) goto yy18 ; goto yy70 ; } else { if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy58 ; goto yy18 ; } } else { if ( yych <= 'E' ) { if ( yych <= ';' ) goto yy63 ; if ( yych <= 'D' ) goto yy18 ; goto yy65 ; } else { if ( yych == 'e' ) goto yy65 ; goto yy18 ; } } yy60 : yych = * ++ YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych >= ':' ) goto yy18 ; yy61 : ++ YYCURSOR ; if ( ( YYLIMIT - YYCURSOR ) < 4 ) YYFILL ( 4 ) ; yych = * YYCURSOR ; if ( yych <= ';' ) { if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy61 ; if ( yych <= ':' ) goto yy18 ; } else { if ( yych <= 'E' ) { if ( yych <= 'D' ) goto yy18 ; goto yy65 ; } else { if ( yych == 'e' ) goto yy65 ; goto yy18 ; } } yy63 : ++ YYCURSOR ; <S2SV_StartBug> # line 599 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> { # if SIZEOF_LONG == 4 use_double : # endif * p = YYCURSOR ; INIT_PZVAL ( * rval ) ; ZVAL_DOUBLE ( * rval , zend_strtod ( ( const char * ) start + 2 , NULL ) ) ; return 1 ; } <S2SV_StartBug> # line 1068 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> yy65 : yych = * ++ YYCURSOR ; if ( yych <= ',' ) { if ( yych != '+' ) goto yy18 ; } else { if ( yych <= '-' ) goto yy66 ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy67 ; goto yy18 ; } yy66 : yych = * ++ YYCURSOR ; if ( yych <= ',' ) { if ( yych == '+' ) goto yy69 ; goto yy18 ; } else { if ( yych <= '-' ) goto yy69 ; if ( yych <= '/' ) goto yy18 ; if ( yych >= ':' ) goto yy18 ; } yy67 : ++ YYCURSOR ; if ( YYLIMIT <= YYCURSOR ) YYFILL ( 1 ) ; yych = * YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy67 ; if ( yych == ';' ) goto yy63 ; goto yy18 ; yy69 : yych = * ++ YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy67 ; goto yy18 ; yy70 : ++ YYCURSOR ; if ( ( YYLIMIT - YYCURSOR ) < 4 ) YYFILL ( 4 ) ; yych = * YYCURSOR ; if ( yych <= ';' ) { if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy70 ; if ( yych <= ':' ) goto yy18 ; goto yy63 ; } else { if ( yych <= 'E' ) { if ( yych <= 'D' ) goto yy18 ; goto yy65 ; } else { if ( yych == 'e' ) goto yy65 ; goto yy18 ; } } yy72 : yych = * ++ YYCURSOR ; if ( yych != 'F' ) goto yy18 ; yy73 : yych = * ++ YYCURSOR ; if ( yych != ';' ) goto yy18 ; ++ YYCURSOR ; <S2SV_StartBug> # line 584 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> { * p = YYCURSOR ; INIT_PZVAL ( * rval ) ; if ( ! strncmp ( start + 2 , ""NAN"" , 3 ) ) { ZVAL_DOUBLE ( * rval , php_get_nan ( ) ) ; } else if ( ! strncmp ( start + 2 , ""INF"" , 3 ) ) { ZVAL_DOUBLE ( * rval , php_get_inf ( ) ) ; } else if ( ! strncmp ( start + 2 , ""-INF"" , 4 ) ) { ZVAL_DOUBLE ( * rval , - php_get_inf ( ) ) ; } return 1 ; } <S2SV_StartBug> # line 1142 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> yy76 : yych = * ++ YYCURSOR ; if ( yych == 'N' ) goto yy73 ; goto yy18 ; yy77 : yych = * ++ YYCURSOR ; if ( yych <= ',' ) { if ( yych != '+' ) goto yy18 ; } else { if ( yych <= '-' ) goto yy78 ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy79 ; goto yy18 ; } yy78 : yych = * ++ YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych >= ':' ) goto yy18 ; yy79 : ++ YYCURSOR ; if ( YYLIMIT <= YYCURSOR ) YYFILL ( 1 ) ; yych = * YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy79 ; if ( yych != ';' ) goto yy18 ; ++ YYCURSOR ; <S2SV_StartBug> # line 557 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> { # if SIZEOF_LONG == 4 int digits = YYCURSOR - start - 3 ; if ( start [ 2 ] == '-' || start [ 2 ] == '+' ) { digits -- ; } if ( digits >= MAX_LENGTH_OF_LONG - 1 ) { if ( digits == MAX_LENGTH_OF_LONG - 1 ) { int cmp = strncmp ( YYCURSOR - MAX_LENGTH_OF_LONG , long_min_digits , MAX_LENGTH_OF_LONG - 1 ) ; if ( ! ( cmp < 0 || ( cmp == 0 && start [ 2 ] == '-' ) ) ) { goto use_double ; } } else { goto use_double ; } } # endif * p = YYCURSOR ; INIT_PZVAL ( * rval ) ; ZVAL_LONG ( * rval , parse_iv ( start + 2 ) ) ; return 1 ; } <S2SV_StartBug> # line 1196 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> yy83 : yych = * ++ YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych >= '2' ) goto yy18 ; yych = * ++ YYCURSOR ; if ( yych != ';' ) goto yy18 ; ++ YYCURSOR ; <S2SV_StartBug> # line 550 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> { * p = YYCURSOR ; INIT_PZVAL ( * rval ) ; ZVAL_BOOL ( * rval , parse_iv ( start + 2 ) ) ; return 1 ; } <S2SV_StartBug> # line 1211 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> yy87 : ++ YYCURSOR ; <S2SV_StartBug> # line 543 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> { * p = YYCURSOR ; INIT_PZVAL ( * rval ) ; ZVAL_NULL ( * rval ) ; return 1 ; } <S2SV_StartBug> # line 1221 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> yy89 : yych = * ++ YYCURSOR ; if ( yych <= ',' ) { if ( yych != '+' ) goto yy18 ; } else { if ( yych <= '-' ) goto yy90 ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy91 ; goto yy18 ; } yy90 : yych = * ++ YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych >= ':' ) goto yy18 ; yy91 : ++ YYCURSOR ; if ( YYLIMIT <= YYCURSOR ) YYFILL ( 1 ) ; yych = * YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy91 ; if ( yych != ';' ) goto yy18 ; ++ YYCURSOR ; <S2SV_StartBug> # line 520 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> { long id ; * p = YYCURSOR ; if ( ! var_hash ) return 0 ; id = parse_iv ( start + 2 ) - 1 ; if ( id == - 1 || var_access ( var_hash , id , & rval_ref ) != SUCCESS ) { return 0 ; } if ( * rval == * rval_ref ) return 0 ; if ( * rval != NULL ) { var_push_dtor_no_addref ( var_hash , rval ) ; } * rval = * rval_ref ; Z_ADDREF_PP ( rval ) ; Z_UNSET_ISREF_PP ( rval ) ; return 1 ; } <S2SV_StartBug> # line 1267 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> yy95 : yych = * ++ YYCURSOR ; if ( yych <= ',' ) { if ( yych != '+' ) goto yy18 ; } else { if ( yych <= '-' ) goto yy96 ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy97 ; goto yy18 ; } yy96 : yych = * ++ YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych >= ':' ) goto yy18 ; yy97 : ++ YYCURSOR ; if ( YYLIMIT <= YYCURSOR ) YYFILL ( 1 ) ; yych = * YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy97 ; if ( yych != ';' ) goto yy18 ; ++ YYCURSOR ; <S2SV_StartBug> # line 499 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> { long id ; * p = YYCURSOR ; if ( ! var_hash ) return 0 ; id = parse_iv ( start + 2 ) - 1 ; if ( id == - 1 || var_access ( var_hash , id , & rval_ref ) != SUCCESS ) { return 0 ; } if ( * rval != NULL ) { var_push_dtor_no_addref ( var_hash , rval ) ; } * rval = * rval_ref ; Z_ADDREF_PP ( rval ) ; Z_SET_ISREF_PP ( rval ) ; return 1 ; } <S2SV_StartBug> # line 1311 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> } <S2SV_StartBug> # line 862 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> return 0 ; }","; # line 496 <S2SV_ModEnd> ""ext/standard/var_unserializer.c"" { YYCTYPE <S2SV_ModStart> : # line 861 <S2SV_ModEnd> ""ext/standard/var_unserializer.re"" { return <S2SV_ModStart> } # line 558 <S2SV_ModEnd> ""ext/standard/var_unserializer.c"" yy4 : <S2SV_ModStart> ; # line 855 <S2SV_ModEnd> ""ext/standard/var_unserializer.re"" { php_error_docref <S2SV_ModStart> } # line 607 <S2SV_ModEnd> ""ext/standard/var_unserializer.c"" yy16 : <S2SV_ModStart> ; # line 708 <S2SV_ModEnd> ""ext/standard/var_unserializer.re"" { size_t <S2SV_ModStart> } # line 785 <S2SV_ModEnd> ""ext/standard/var_unserializer.c"" yy25 : <S2SV_ModStart> ; # line 699 <S2SV_ModEnd> ""ext/standard/var_unserializer.re"" { if <S2SV_ModStart> } # line 819 <S2SV_ModEnd> ""ext/standard/var_unserializer.c"" yy32 : <S2SV_ModStart> ; # line 678 <S2SV_ModEnd> ""ext/standard/var_unserializer.re"" { long <S2SV_ModStart> } # line 861 <S2SV_ModEnd> ""ext/standard/var_unserializer.c"" yy39 : <S2SV_ModStart> ; # line 643 <S2SV_ModEnd> ""ext/standard/var_unserializer.re"" { size_t <S2SV_ModStart> } # line 917 <S2SV_ModEnd> ""ext/standard/var_unserializer.c"" yy46 : <S2SV_ModStart> ; # line 610 <S2SV_ModEnd> ""ext/standard/var_unserializer.re"" { size_t <S2SV_ModStart> } # line 971 <S2SV_ModEnd> ""ext/standard/var_unserializer.c"" yy53 : <S2SV_ModStart> ; # line 600 <S2SV_ModEnd> ""ext/standard/var_unserializer.re"" { # <S2SV_ModStart> } # line 1069 <S2SV_ModEnd> ""ext/standard/var_unserializer.c"" yy65 : <S2SV_ModStart> ; # line 585 <S2SV_ModEnd> ""ext/standard/var_unserializer.re"" { * <S2SV_ModStart> } # line 1143 <S2SV_ModEnd> ""ext/standard/var_unserializer.c"" yy76 : <S2SV_ModStart> ; # line 558 <S2SV_ModEnd> ""ext/standard/var_unserializer.re"" { # <S2SV_ModStart> } # line 1197 <S2SV_ModEnd> ""ext/standard/var_unserializer.c"" yy83 : <S2SV_ModStart> ; # line 551 <S2SV_ModEnd> ""ext/standard/var_unserializer.re"" { * <S2SV_ModStart> } # line 1212 <S2SV_ModEnd> ""ext/standard/var_unserializer.c"" yy87 : <S2SV_ModStart> ; # line 544 <S2SV_ModEnd> ""ext/standard/var_unserializer.re"" { * <S2SV_ModStart> } # line 1222 <S2SV_ModEnd> ""ext/standard/var_unserializer.c"" yy89 : <S2SV_ModStart> ; # line 521 <S2SV_ModEnd> ""ext/standard/var_unserializer.re"" { long <S2SV_ModStart> } # line 1268 <S2SV_ModEnd> ""ext/standard/var_unserializer.c"" yy95 : <S2SV_ModStart> ; # line 500 <S2SV_ModEnd> ""ext/standard/var_unserializer.re"" { long <S2SV_ModStart> } # line 1312 <S2SV_ModEnd> ""ext/standard/var_unserializer.c"" } # <S2SV_ModStart> } # line 863 <S2SV_ModEnd> ""ext/standard/var_unserializer.re"" return 0"
329,"static struct task_struct * copy_process ( unsigned long clone_flags , unsigned long stack_start , struct pt_regs * regs , unsigned long stack_size , int __user * child_tidptr , struct pid * pid , int trace ) { int retval ; struct task_struct * p ; int cgroup_callbacks_done = 0 ; if ( ( clone_flags & ( CLONE_NEWNS | CLONE_FS ) ) == ( CLONE_NEWNS | CLONE_FS ) ) return ERR_PTR ( - EINVAL ) ; if ( ( clone_flags & CLONE_THREAD ) && ! ( clone_flags & CLONE_SIGHAND ) ) return ERR_PTR ( - EINVAL ) ; if ( ( clone_flags & CLONE_SIGHAND ) && ! ( clone_flags & CLONE_VM ) ) return ERR_PTR ( - EINVAL ) ; if ( ( clone_flags & CLONE_PARENT ) && current -> signal -> flags & SIGNAL_UNKILLABLE ) return ERR_PTR ( - EINVAL ) ; retval = security_task_create ( clone_flags ) ; if ( retval ) goto fork_out ; retval = - ENOMEM ; p = dup_task_struct ( current ) ; if ( ! p ) goto fork_out ; ftrace_graph_init_task ( p ) ; rt_mutex_init_task ( p ) ; # ifdef CONFIG_PROVE_LOCKING DEBUG_LOCKS_WARN_ON ( ! p -> hardirqs_enabled ) ; DEBUG_LOCKS_WARN_ON ( ! p -> softirqs_enabled ) ; # endif retval = - EAGAIN ; if ( atomic_read ( & p -> real_cred -> user -> processes ) >= p -> signal -> rlim [ RLIMIT_NPROC ] . rlim_cur ) { if ( ! capable ( CAP_SYS_ADMIN ) && ! capable ( CAP_SYS_RESOURCE ) && p -> real_cred -> user != INIT_USER ) goto bad_fork_free ; } retval = copy_creds ( p , clone_flags ) ; if ( retval < 0 ) goto bad_fork_free ; retval = - EAGAIN ; if ( nr_threads >= max_threads ) goto bad_fork_cleanup_count ; if ( ! try_module_get ( task_thread_info ( p ) -> exec_domain -> module ) ) goto bad_fork_cleanup_count ; p -> did_exec = 0 ; delayacct_tsk_init ( p ) ; copy_flags ( clone_flags , p ) ; INIT_LIST_HEAD ( & p -> children ) ; INIT_LIST_HEAD ( & p -> sibling ) ; rcu_copy_process ( p ) ; p -> vfork_done = NULL ; spin_lock_init ( & p -> alloc_lock ) ; init_sigpending ( & p -> pending ) ; p -> utime = cputime_zero ; p -> stime = cputime_zero ; p -> gtime = cputime_zero ; p -> utimescaled = cputime_zero ; p -> stimescaled = cputime_zero ; p -> prev_utime = cputime_zero ; p -> prev_stime = cputime_zero ; p -> default_timer_slack_ns = current -> timer_slack_ns ; task_io_accounting_init ( & p -> ioac ) ; acct_clear_integrals ( p ) ; posix_cpu_timers_init ( p ) ; p -> lock_depth = - 1 ; do_posix_clock_monotonic_gettime ( & p -> start_time ) ; p -> real_start_time = p -> start_time ; monotonic_to_bootbased ( & p -> real_start_time ) ; p -> io_context = NULL ; p -> audit_context = NULL ; cgroup_fork ( p ) ; # ifdef CONFIG_NUMA p -> mempolicy = mpol_dup ( p -> mempolicy ) ; if ( IS_ERR ( p -> mempolicy ) ) { retval = PTR_ERR ( p -> mempolicy ) ; p -> mempolicy = NULL ; goto bad_fork_cleanup_cgroup ; } mpol_fix_fork_child_flag ( p ) ; # endif # ifdef CONFIG_TRACE_IRQFLAGS p -> irq_events = 0 ; # ifdef __ARCH_WANT_INTERRUPTS_ON_CTXSW p -> hardirqs_enabled = 1 ; # else p -> hardirqs_enabled = 0 ; # endif p -> hardirq_enable_ip = 0 ; p -> hardirq_enable_event = 0 ; p -> hardirq_disable_ip = _THIS_IP_ ; p -> hardirq_disable_event = 0 ; p -> softirqs_enabled = 1 ; p -> softirq_enable_ip = _THIS_IP_ ; p -> softirq_enable_event = 0 ; p -> softirq_disable_ip = 0 ; p -> softirq_disable_event = 0 ; p -> hardirq_context = 0 ; p -> softirq_context = 0 ; # endif # ifdef CONFIG_LOCKDEP p -> lockdep_depth = 0 ; p -> curr_chain_key = 0 ; p -> lockdep_recursion = 0 ; # endif # ifdef CONFIG_DEBUG_MUTEXES p -> blocked_on = NULL ; # endif p -> bts = NULL ; p -> stack_start = stack_start ; sched_fork ( p , clone_flags ) ; retval = perf_event_init_task ( p ) ; if ( retval ) goto bad_fork_cleanup_policy ; if ( ( retval = audit_alloc ( p ) ) ) goto bad_fork_cleanup_policy ; if ( ( retval = copy_semundo ( clone_flags , p ) ) ) goto bad_fork_cleanup_audit ; if ( ( retval = copy_files ( clone_flags , p ) ) ) goto bad_fork_cleanup_semundo ; if ( ( retval = copy_fs ( clone_flags , p ) ) ) goto bad_fork_cleanup_files ; if ( ( retval = copy_sighand ( clone_flags , p ) ) ) goto bad_fork_cleanup_fs ; if ( ( retval = copy_signal ( clone_flags , p ) ) ) goto bad_fork_cleanup_sighand ; if ( ( retval = copy_mm ( clone_flags , p ) ) ) goto bad_fork_cleanup_signal ; if ( ( retval = copy_namespaces ( clone_flags , p ) ) ) goto bad_fork_cleanup_mm ; if ( ( retval = copy_io ( clone_flags , p ) ) ) goto bad_fork_cleanup_namespaces ; retval = copy_thread ( clone_flags , stack_start , stack_size , p , regs ) ; if ( retval ) goto bad_fork_cleanup_io ; if ( pid != & init_struct_pid ) { retval = - ENOMEM ; pid = alloc_pid ( p -> nsproxy -> pid_ns ) ; if ( ! pid ) goto bad_fork_cleanup_io ; if ( clone_flags & CLONE_NEWPID ) { retval = pid_ns_prepare_proc ( p -> nsproxy -> pid_ns ) ; if ( retval < 0 ) goto bad_fork_free_pid ; } } p -> pid = pid_nr ( pid ) ; p -> tgid = p -> pid ; if ( clone_flags & CLONE_THREAD ) p -> tgid = current -> tgid ; if ( current -> nsproxy != p -> nsproxy ) { retval = ns_cgroup_clone ( p , pid ) ; if ( retval ) goto bad_fork_free_pid ; } p -> set_child_tid = ( clone_flags & CLONE_CHILD_SETTID ) ? child_tidptr : NULL ; p -> clear_child_tid = ( clone_flags & CLONE_CHILD_CLEARTID ) ? child_tidptr : NULL ; # ifdef CONFIG_FUTEX p -> robust_list = NULL ; # ifdef CONFIG_COMPAT p -> compat_robust_list = NULL ; # endif INIT_LIST_HEAD ( & p -> pi_state_list ) ; p -> pi_state_cache = NULL ; # endif if ( ( clone_flags & ( CLONE_VM | CLONE_VFORK ) ) == CLONE_VM ) p -> sas_ss_sp = p -> sas_ss_size = 0 ; clear_tsk_thread_flag ( p , TIF_SYSCALL_TRACE ) ; # ifdef TIF_SYSCALL_EMU clear_tsk_thread_flag ( p , TIF_SYSCALL_EMU ) ; # endif clear_all_latency_tracing ( p ) ; p -> exit_signal = ( clone_flags & CLONE_THREAD ) ? - 1 : ( clone_flags & CSIGNAL ) ; p -> pdeath_signal = 0 ; p -> exit_state = 0 ; p -> group_leader = p ; INIT_LIST_HEAD ( & p -> thread_group ) ; cgroup_fork_callbacks ( p ) ; cgroup_callbacks_done = 1 ; write_lock_irq ( & tasklist_lock ) ; p -> cpus_allowed = current -> cpus_allowed ; p -> rt . nr_cpus_allowed = current -> rt . nr_cpus_allowed ; if ( unlikely ( ! cpu_isset ( task_cpu ( p ) , p -> cpus_allowed ) || ! cpu_online ( task_cpu ( p ) ) ) ) set_task_cpu ( p , smp_processor_id ( ) ) ; if ( clone_flags & ( CLONE_PARENT | CLONE_THREAD ) ) { p -> real_parent = current -> real_parent ; p -> parent_exec_id = current -> parent_exec_id ; } else { p -> real_parent = current ; p -> parent_exec_id = current -> self_exec_id ; } spin_lock ( & current -> sighand -> siglock ) ; recalc_sigpending ( ) ; if ( signal_pending ( current ) ) { spin_unlock ( & current -> sighand -> siglock ) ; write_unlock_irq ( & tasklist_lock ) ; retval = - ERESTARTNOINTR ; goto bad_fork_free_pid ; } if ( clone_flags & CLONE_THREAD ) { atomic_inc ( & current -> signal -> count ) ; atomic_inc ( & current -> signal -> live ) ; p -> group_leader = current -> group_leader ; list_add_tail_rcu ( & p -> thread_group , & p -> group_leader -> thread_group ) ; } if ( likely ( p -> pid ) ) { list_add_tail ( & p -> sibling , & p -> real_parent -> children ) ; tracehook_finish_clone ( p , clone_flags , trace ) ; if ( thread_group_leader ( p ) ) { if ( clone_flags & CLONE_NEWPID ) p -> nsproxy -> pid_ns -> child_reaper = p ; p -> signal -> leader_pid = pid ; tty_kref_put ( p -> signal -> tty ) ; p -> signal -> tty = tty_kref_get ( current -> signal -> tty ) ; attach_pid ( p , PIDTYPE_PGID , task_pgrp ( current ) ) ; attach_pid ( p , PIDTYPE_SID , task_session ( current ) ) ; list_add_tail_rcu ( & p -> tasks , & init_task . tasks ) ; __get_cpu_var ( process_counts ) ++ ; } attach_pid ( p , PIDTYPE_PID , pid ) ; nr_threads ++ ; } total_forks ++ ; spin_unlock ( & current -> sighand -> siglock ) ; write_unlock_irq ( & tasklist_lock ) ; proc_fork_connector ( p ) ; cgroup_post_fork ( p ) ; perf_event_fork ( p ) ; return p ; bad_fork_free_pid : if ( pid != & init_struct_pid ) free_pid ( pid ) ; bad_fork_cleanup_io : <S2SV_StartBug> put_io_context ( p -> io_context ) ; <S2SV_EndBug> bad_fork_cleanup_namespaces : exit_task_namespaces ( p ) ; bad_fork_cleanup_mm : if ( p -> mm ) mmput ( p -> mm ) ; bad_fork_cleanup_signal : if ( ! ( clone_flags & CLONE_THREAD ) ) __cleanup_signal ( p -> signal ) ; bad_fork_cleanup_sighand : __cleanup_sighand ( p -> sighand ) ; bad_fork_cleanup_fs : exit_fs ( p ) ; bad_fork_cleanup_files : exit_files ( p ) ; bad_fork_cleanup_semundo : exit_sem ( p ) ; bad_fork_cleanup_audit : audit_free ( p ) ; bad_fork_cleanup_policy : perf_event_free_task ( p ) ; # ifdef CONFIG_NUMA mpol_put ( p -> mempolicy ) ; bad_fork_cleanup_cgroup : # endif cgroup_exit ( p , cgroup_callbacks_done ) ; delayacct_tsk_free ( p ) ; module_put ( task_thread_info ( p ) -> exec_domain -> module ) ; bad_fork_cleanup_count : atomic_dec ( & p -> cred -> user -> processes ) ; exit_creds ( p ) ; bad_fork_free : free_task ( p ) ; fork_out : return ERR_PTR ( retval ) ; }",; bad_fork_cleanup_io : if <S2SV_ModEnd> ( p -> <S2SV_ModStart> p -> io_context ) exit_io_context ( p
330,"<S2SV_StartBug> void kvm_lapic_set_vapic_addr ( struct kvm_vcpu * vcpu , gpa_t vapic_addr ) <S2SV_EndBug> { <S2SV_StartBug> vcpu -> arch . apic -> vapic_addr = vapic_addr ; <S2SV_EndBug> if ( vapic_addr ) __set_bit ( KVM_APIC_CHECK_VAPIC , & vcpu -> arch . apic_attention ) ; <S2SV_StartBug> else <S2SV_EndBug> __clear_bit ( KVM_APIC_CHECK_VAPIC , & vcpu -> arch . apic_attention ) ; <S2SV_StartBug> } <S2SV_EndBug>","<S2SV_null> <S2SV_null> <S2SV_null> int <S2SV_ModEnd> kvm_lapic_set_vapic_addr ( struct <S2SV_ModStart> vapic_addr ) { if ( vapic_addr ) { if ( kvm_gfn_to_hva_cache_init ( vcpu -> kvm , & <S2SV_ModStart> . apic -> vapic_cache , vapic_addr , sizeof ( u32 ) ) ) return - EINVAL ; <S2SV_ModEnd> __set_bit ( KVM_APIC_CHECK_VAPIC <S2SV_ModStart> apic_attention ) ; } else { <S2SV_ModEnd> __clear_bit ( KVM_APIC_CHECK_VAPIC <S2SV_ModStart> ) ; } vcpu -> arch . apic -> vapic_addr = vapic_addr ; return 0 ; }"
331,"static int timer_start ( Unit * u ) { Timer * t = TIMER ( u ) ; TimerValue * v ; assert ( t ) ; assert ( t -> state == TIMER_DEAD || t -> state == TIMER_FAILED ) ; if ( UNIT_TRIGGER ( u ) -> load_state != UNIT_LOADED ) return - ENOENT ; t -> last_trigger = DUAL_TIMESTAMP_NULL ; LIST_FOREACH ( value , v , t -> values ) if ( v -> base == TIMER_ACTIVE ) v -> disabled = false ; if ( t -> stamp_path ) { struct stat st ; if ( stat ( t -> stamp_path , & st ) >= 0 ) t -> last_trigger . realtime = timespec_load ( & st . st_atim ) ; else if ( errno == ENOENT ) <S2SV_StartBug> touch_file ( t -> stamp_path , true , USEC_INFINITY , UID_INVALID , GID_INVALID , 0 ) ; <S2SV_EndBug> } t -> result = TIMER_SUCCESS ; timer_enter_waiting ( t , true ) ; return 1 ; }",", GID_INVALID , MODE_INVALID <S2SV_ModEnd> ) ; }"
332,"static void llc_sap_rcv ( struct llc_sap * sap , struct sk_buff * skb , struct sock * sk ) { struct llc_sap_state_ev * ev = llc_sap_ev ( skb ) ; ev -> type = LLC_SAP_EV_TYPE_PDU ; ev -> reason = 0 ; <S2SV_StartBug> skb -> sk = sk ; <S2SV_EndBug> llc_sap_state_process ( sap , skb ) ; }",= 0 ; skb_orphan ( skb ) ; sock_hold ( sk ) ; <S2SV_ModStart> sk = sk ; skb -> destructor = sock_efree
333,"int hsr_dev_finalize ( struct net_device * hsr_dev , struct net_device * slave [ 2 ] , unsigned char multicast_spec , u8 protocol_version ) { struct hsr_priv * hsr ; struct hsr_port * port ; int res ; hsr = netdev_priv ( hsr_dev ) ; INIT_LIST_HEAD ( & hsr -> ports ) ; INIT_LIST_HEAD ( & hsr -> node_db ) ; INIT_LIST_HEAD ( & hsr -> self_node_db ) ; ether_addr_copy ( hsr_dev -> dev_addr , slave [ 0 ] -> dev_addr ) ; res = hsr_create_self_node ( & hsr -> self_node_db , hsr_dev -> dev_addr , slave [ 1 ] -> dev_addr ) ; if ( res < 0 ) return res ; spin_lock_init ( & hsr -> seqnr_lock ) ; hsr -> sequence_nr = HSR_SEQNR_START ; hsr -> sup_sequence_nr = HSR_SUP_SEQNR_START ; timer_setup ( & hsr -> announce_timer , hsr_announce , 0 ) ; timer_setup ( & hsr -> prune_timer , hsr_prune_nodes , 0 ) ; ether_addr_copy ( hsr -> sup_multicast_addr , def_multicast_addr ) ; hsr -> sup_multicast_addr [ ETH_ALEN - 1 ] = multicast_spec ; hsr -> protVersion = protocol_version ; netif_carrier_off ( hsr_dev ) ; res = hsr_add_port ( hsr , hsr_dev , HSR_PT_MASTER ) ; if ( res ) <S2SV_StartBug> return res ; <S2SV_EndBug> res = register_netdevice ( hsr_dev ) ; if ( res ) goto fail ; res = hsr_add_port ( hsr , slave [ 0 ] , HSR_PT_SLAVE_A ) ; if ( res ) goto fail ; res = hsr_add_port ( hsr , slave [ 1 ] , HSR_PT_SLAVE_B ) ; if ( res ) goto fail ; mod_timer ( & hsr -> prune_timer , jiffies + msecs_to_jiffies ( PRUNE_PERIOD ) ) ; return 0 ; fail : hsr_for_each_port ( hsr , port ) hsr_del_port ( port ) ; <S2SV_StartBug> return res ; <S2SV_EndBug> }",( res ) goto err_add_port <S2SV_ModEnd> ; res = <S2SV_ModStart> port ) ; err_add_port : hsr_del_node ( & hsr -> self_node_db ) ;
334,"static void init_encode_frame_mb_context ( VP8_COMP * cpi ) { MACROBLOCK * const x = & cpi -> mb ; VP8_COMMON * const cm = & cpi -> common ; MACROBLOCKD * const xd = & x -> e_mbd ; x -> gf_active_ptr = ( signed char * ) cpi -> gf_active_flags ; x -> mb_activity_ptr = cpi -> mb_activity_map ; x -> act_zbin_adj = 0 ; x -> partition_info = x -> pi ; xd -> mode_info_context = cm -> mi ; xd -> mode_info_stride = cm -> mode_info_stride ; xd -> frame_type = cm -> frame_type ; if ( cm -> frame_type == KEY_FRAME ) vp8_init_mbmode_probs ( cm ) ; x -> src = * cpi -> Source ; xd -> pre = cm -> yv12_fb [ cm -> lst_fb_idx ] ; xd -> dst = cm -> yv12_fb [ cm -> new_fb_idx ] ; vp8_setup_intra_recon ( & cm -> yv12_fb [ cm -> new_fb_idx ] ) ; vp8_build_block_offsets ( x ) ; xd -> mode_info_context -> mbmi . mode = DC_PRED ; xd -> mode_info_context -> mbmi . uv_mode = DC_PRED ; xd -> left_context = & cm -> left_context ; x -> mvc = cm -> fc . mvc ; <S2SV_StartBug> vpx_memset ( cm -> above_context , 0 , <S2SV_EndBug> sizeof ( ENTROPY_CONTEXT_PLANES ) * cm -> mb_cols ) ; if ( cpi -> ref_frame_flags == VP8_LAST_FRAME ) vp8_calc_ref_frame_costs ( x -> ref_frame_cost , cpi -> prob_intra_coded , 255 , 128 ) ; else if ( ( cpi -> oxcf . number_of_layers > 1 ) && ( cpi -> ref_frame_flags == VP8_GOLD_FRAME ) ) vp8_calc_ref_frame_costs ( x -> ref_frame_cost , cpi -> prob_intra_coded , 1 , 255 ) ; else if ( ( cpi -> oxcf . number_of_layers > 1 ) && ( cpi -> ref_frame_flags == VP8_ALTR_FRAME ) ) vp8_calc_ref_frame_costs ( x -> ref_frame_cost , cpi -> prob_intra_coded , 1 , 1 ) ; else vp8_calc_ref_frame_costs ( x -> ref_frame_cost , cpi -> prob_intra_coded , cpi -> prob_last_coded , cpi -> prob_gf_coded ) ; xd -> fullpixel_mask = 0xffffffff ; if ( cm -> full_pixel ) xd -> fullpixel_mask = 0xfffffff8 ; vp8_zero ( x -> coef_counts ) ; vp8_zero ( x -> ymode_count ) ; vp8_zero ( x -> uv_mode_count ) x -> prediction_error = 0 ; x -> intra_error = 0 ; vp8_zero ( x -> count_mb_ref_frame_usage ) ; }",. mvc ; memset <S2SV_ModEnd> ( cm ->
335,"struct se_portal_group * tcm_loop_make_naa_tpg ( struct se_wwn * wwn , struct config_group * group , const char * name ) { struct tcm_loop_hba * tl_hba = container_of ( wwn , struct tcm_loop_hba , tl_hba_wwn ) ; struct tcm_loop_tpg * tl_tpg ; char * tpgt_str , * end_ptr ; int ret ; unsigned short int tpgt ; tpgt_str = strstr ( name , ""tpgt_"" ) ; if ( ! tpgt_str ) { printk ( KERN_ERR ""Unable<S2SV_blank>to<S2SV_blank>locate<S2SV_blank>\\""tpgt_#\\""<S2SV_blank>directory"" ""<S2SV_blank>group\\n"" ) ; return ERR_PTR ( - EINVAL ) ; } tpgt_str += 5 ; tpgt = ( unsigned short int ) simple_strtoul ( tpgt_str , & end_ptr , 0 ) ; <S2SV_StartBug> if ( tpgt > TL_TPGS_PER_HBA ) { <S2SV_EndBug> printk ( KERN_ERR ""Passed<S2SV_blank>tpgt:<S2SV_blank>%hu<S2SV_blank>exceeds<S2SV_blank>TL_TPGS_PER_HBA:"" ""<S2SV_blank>%u\\n"" , tpgt , TL_TPGS_PER_HBA ) ; return ERR_PTR ( - EINVAL ) ; } tl_tpg = & tl_hba -> tl_hba_tpgs [ tpgt ] ; tl_tpg -> tl_hba = tl_hba ; tl_tpg -> tl_tpgt = tpgt ; ret = core_tpg_register ( & tcm_loop_fabric_configfs -> tf_ops , wwn , & tl_tpg -> tl_se_tpg , tl_tpg , TRANSPORT_TPG_TYPE_NORMAL ) ; if ( ret < 0 ) return ERR_PTR ( - ENOMEM ) ; printk ( KERN_INFO ""TCM_Loop_ConfigFS:<S2SV_blank>Allocated<S2SV_blank>Emulated<S2SV_blank>%s"" ""<S2SV_blank>Target<S2SV_blank>Port<S2SV_blank>%s,t,0x%04x\\n"" , tcm_loop_dump_proto_id ( tl_hba ) , config_item_name ( & wwn -> wwn_group . cg_item ) , tpgt ) ; return & tl_tpg -> tl_se_tpg ; }",if ( tpgt >= <S2SV_ModEnd> TL_TPGS_PER_HBA ) {
336,"static struct bpf_verifier_state * push_stack ( struct bpf_verifier_env * env , <S2SV_StartBug> int insn_idx , int prev_insn_idx ) <S2SV_EndBug> { struct bpf_verifier_state * cur = env -> cur_state ; struct bpf_verifier_stack_elem * elem ; int err ; elem = kzalloc ( sizeof ( struct bpf_verifier_stack_elem ) , GFP_KERNEL ) ; if ( ! elem ) goto err ; elem -> insn_idx = insn_idx ; elem -> prev_insn_idx = prev_insn_idx ; elem -> next = env -> head ; env -> head = elem ; env -> stack_size ++ ; err = copy_verifier_state ( & elem -> st , cur ) ; if ( err ) <S2SV_StartBug> goto err ; <S2SV_EndBug> if ( env -> stack_size > BPF_COMPLEXITY_LIMIT_STACK ) { verbose ( env , ""BPF<S2SV_blank>program<S2SV_blank>is<S2SV_blank>too<S2SV_blank>complex\\n"" ) ; goto err ; } return & elem -> st ; err : free_verifier_state ( env -> cur_state , true ) ; env -> cur_state = NULL ; while ( ! pop_stack ( env , NULL , NULL ) ) ; return NULL ; }",", int prev_insn_idx , bool speculative <S2SV_ModStart> ) goto err ; elem -> st . speculative |= speculative"
337,"void vp8_setup_intra_recon ( YV12_BUFFER_CONFIG * ybf ) { int i ; <S2SV_StartBug> vpx_memset ( ybf -> y_buffer - 1 - ybf -> y_stride , 127 , ybf -> y_width + 5 ) ; <S2SV_EndBug> for ( i = 0 ; i < ybf -> y_height ; i ++ ) ybf -> y_buffer [ ybf -> y_stride * i - 1 ] = ( unsigned char ) 129 ; <S2SV_StartBug> vpx_memset ( ybf -> u_buffer - 1 - ybf -> uv_stride , 127 , ybf -> uv_width + 5 ) ; <S2SV_EndBug> for ( i = 0 ; i < ybf -> uv_height ; i ++ ) ybf -> u_buffer [ ybf -> uv_stride * i - 1 ] = ( unsigned char ) 129 ; <S2SV_StartBug> vpx_memset ( ybf -> v_buffer - 1 - ybf -> uv_stride , 127 , ybf -> uv_width + 5 ) ; <S2SV_EndBug> for ( i = 0 ; i < ybf -> uv_height ; i ++ ) ybf -> v_buffer [ ybf -> uv_stride * i - 1 ] = ( unsigned char ) 129 ; }",int i ; memset <S2SV_ModEnd> ( ybf -> <S2SV_ModStart> ) 129 ; memset <S2SV_ModEnd> ( ybf -> <S2SV_ModStart> ) 129 ; memset <S2SV_ModEnd> ( ybf ->
338,"static void sas_discover_domain ( struct work_struct * work ) { struct domain_device * dev ; int error = 0 ; struct sas_discovery_event * ev = to_sas_discovery_event ( work ) ; struct asd_sas_port * port = ev -> port ; clear_bit ( DISCE_DISCOVER_DOMAIN , & port -> disc . pending ) ; if ( port -> port_dev ) return ; error = sas_get_port_device ( port ) ; if ( error ) return ; dev = port -> port_dev ; SAS_DPRINTK ( ""DOING<S2SV_blank>DISCOVERY<S2SV_blank>on<S2SV_blank>port<S2SV_blank>%d,<S2SV_blank>pid:%d\\n"" , port -> id , task_pid_nr ( current ) ) ; switch ( dev -> dev_type ) { case SAS_END_DEVICE : error = sas_discover_end_dev ( dev ) ; break ; case SAS_EDGE_EXPANDER_DEVICE : case SAS_FANOUT_EXPANDER_DEVICE : error = sas_discover_root_expander ( dev ) ; break ; case SAS_SATA_DEV : case SAS_SATA_PM : # ifdef CONFIG_SCSI_SAS_ATA error = sas_discover_sata ( dev ) ; break ; # else SAS_DPRINTK ( ""ATA<S2SV_blank>device<S2SV_blank>seen<S2SV_blank>but<S2SV_blank>CONFIG_SCSI_SAS_ATA=N<S2SV_blank>so<S2SV_blank>cannot<S2SV_blank>attach\\n"" ) ; # endif default : error = - ENXIO ; SAS_DPRINTK ( ""unhandled<S2SV_blank>device<S2SV_blank>%d\\n"" , dev -> dev_type ) ; break ; } if ( error ) { sas_rphy_free ( dev -> rphy ) ; list_del_init ( & dev -> disco_list_node ) ; spin_lock_irq ( & port -> dev_list_lock ) ; list_del_init ( & dev -> dev_list_node ) ; spin_unlock_irq ( & port -> dev_list_lock ) ; sas_put_device ( dev ) ; port -> port_dev = NULL ; } <S2SV_StartBug> SAS_DPRINTK ( ""DONE<S2SV_blank>DISCOVERY<S2SV_blank>on<S2SV_blank>port<S2SV_blank>%d,<S2SV_blank>pid:%d,<S2SV_blank>result:%d\\n"" , port -> id , <S2SV_EndBug> task_pid_nr ( current ) , error ) ; }",NULL ; } sas_probe_devices ( port ) ;
339,"static INT AirPDcapDecryptWPABroadcastKey ( const EAPOL_RSN_KEY * pEAPKey , guint8 * decryption_key , PAIRPDCAP_SEC_ASSOCIATION sa , guint eapol_len ) { guint8 key_version ; guint8 * key_data ; guint8 * szEncryptedKey ; guint16 key_bytes_len = 0 ; guint16 key_len ; static AIRPDCAP_KEY_ITEM dummy_key ; AIRPDCAP_SEC_ASSOCIATION * tmp_sa ; key_version = AIRPDCAP_EAP_KEY_DESCR_VER ( pEAPKey -> key_information [ 1 ] ) ; if ( key_version == AIRPDCAP_WPA_KEY_VER_NOT_CCMP ) { key_bytes_len = pntoh16 ( pEAPKey -> key_length ) ; } else if ( key_version == AIRPDCAP_WPA_KEY_VER_AES_CCMP ) { key_bytes_len = pntoh16 ( pEAPKey -> key_data_len ) ; if ( key_bytes_len < 16 ) { return AIRPDCAP_RET_NO_VALID_HANDSHAKE ; } } <S2SV_StartBug> if ( key_bytes_len < GROUP_KEY_MIN_LEN || key_bytes_len > eapol_len - sizeof ( EAPOL_RSN_KEY ) ) { <S2SV_EndBug> return AIRPDCAP_RET_NO_VALID_HANDSHAKE ; } key_data = ( guint8 * ) pEAPKey + sizeof ( EAPOL_RSN_KEY ) ; szEncryptedKey = ( guint8 * ) g_memdup ( key_data , key_bytes_len ) ; DEBUG_DUMP ( ""Encrypted<S2SV_blank>Broadcast<S2SV_blank>key:"" , szEncryptedKey , key_bytes_len ) ; DEBUG_DUMP ( ""KeyIV:"" , pEAPKey -> key_iv , 16 ) ; DEBUG_DUMP ( ""decryption_key:"" , decryption_key , 16 ) ; tmp_sa = ( AIRPDCAP_SEC_ASSOCIATION * ) g_malloc ( sizeof ( AIRPDCAP_SEC_ASSOCIATION ) ) ; memcpy ( tmp_sa , sa , sizeof ( AIRPDCAP_SEC_ASSOCIATION ) ) ; sa -> next = tmp_sa ; if ( key_version == AIRPDCAP_WPA_KEY_VER_NOT_CCMP ) { guint8 new_key [ 32 ] ; guint8 dummy [ 256 ] ; rc4_state_struct rc4_state ; sa -> wpa . key_ver = ( key_bytes_len >= TKIP_GROUP_KEY_LEN ) ? AIRPDCAP_WPA_KEY_VER_NOT_CCMP : AIRPDCAP_WPA_KEY_VER_AES_CCMP ; memcpy ( new_key , pEAPKey -> key_iv , 16 ) ; memcpy ( new_key + 16 , decryption_key , 16 ) ; DEBUG_DUMP ( ""FullDecrKey:"" , new_key , 32 ) ; crypt_rc4_init ( & rc4_state , new_key , sizeof ( new_key ) ) ; crypt_rc4 ( & rc4_state , dummy , 256 ) ; crypt_rc4 ( & rc4_state , szEncryptedKey , key_bytes_len ) ; } else if ( key_version == AIRPDCAP_WPA_KEY_VER_AES_CCMP ) { guint8 key_found ; guint8 key_length ; guint16 key_index ; guint8 * decrypted_data ; decrypted_data = AES_unwrap ( decryption_key , 16 , szEncryptedKey , key_bytes_len ) ; key_found = FALSE ; key_index = 0 ; while ( key_index < ( key_bytes_len - 6 ) && ! key_found ) { guint8 rsn_id ; guint32 type ; rsn_id = decrypted_data [ key_index ] ; type = ( ( decrypted_data [ key_index + 2 ] << 24 ) + ( decrypted_data [ key_index + 3 ] << 16 ) + ( decrypted_data [ key_index + 4 ] << 8 ) + ( decrypted_data [ key_index + 5 ] ) ) ; if ( rsn_id == 0xdd && type == 0x000fac01 ) { key_found = TRUE ; } else { key_index += decrypted_data [ key_index + 1 ] + 2 ; } } if ( key_found ) { key_length = decrypted_data [ key_index + 1 ] - 6 ; if ( key_index + 8 >= key_bytes_len || key_length > key_bytes_len - key_index - 8 ) { g_free ( decrypted_data ) ; g_free ( szEncryptedKey ) ; return AIRPDCAP_RET_NO_VALID_HANDSHAKE ; } memcpy ( szEncryptedKey , decrypted_data + key_index + 8 , key_length ) ; } else { g_free ( decrypted_data ) ; g_free ( szEncryptedKey ) ; return AIRPDCAP_RET_NO_VALID_HANDSHAKE ; } if ( key_length == TKIP_GROUP_KEY_LEN ) sa -> wpa . key_ver = AIRPDCAP_WPA_KEY_VER_NOT_CCMP ; else sa -> wpa . key_ver = AIRPDCAP_WPA_KEY_VER_AES_CCMP ; g_free ( decrypted_data ) ; } key_len = ( sa -> wpa . key_ver == AIRPDCAP_WPA_KEY_VER_NOT_CCMP ) ? TKIP_GROUP_KEY_LEN : CCMP_GROUP_KEY_LEN ; if ( key_len > key_bytes_len ) { g_free ( szEncryptedKey ) ; return AIRPDCAP_RET_NO_VALID_HANDSHAKE ; } DEBUG_DUMP ( ""Broadcast<S2SV_blank>key:"" , szEncryptedKey , key_len ) ; sa -> key = & dummy_key ; sa -> validKey = TRUE ; memset ( sa -> wpa . ptk , 0 , sizeof ( sa -> wpa . ptk ) ) ; memcpy ( sa -> wpa . ptk + 32 , szEncryptedKey , key_len ) ; g_free ( szEncryptedKey ) ; return AIRPDCAP_RET_SUCCESS_HANDSHAKE ; }",} if ( ( <S2SV_ModStart> key_bytes_len < GROUP_KEY_MIN_LEN ) || ( eapol_len < sizeof ( EAPOL_RSN_KEY ) ) || ( <S2SV_ModEnd> key_bytes_len > eapol_len <S2SV_ModStart> sizeof ( EAPOL_RSN_KEY )
340,"static gboolean side_in_cb ( GSocket * socket , GIOCondition condition , gpointer user_data ) { ProxySide * side = user_data ; FlatpakProxyClient * client = side -> client ; GError * error = NULL ; Buffer * buffer ; gboolean retval = G_SOURCE_CONTINUE ; g_object_ref ( client ) ; while ( ! side -> closed ) { if ( ! side -> got_first_byte ) buffer = buffer_new ( 1 , NULL ) ; else if ( ! client -> authenticated ) buffer = buffer_new ( 64 , NULL ) ; else buffer = side -> current_read_buffer ; if ( ! buffer_read ( side , buffer , socket ) ) { if ( buffer != side -> current_read_buffer ) buffer_unref ( buffer ) ; break ; } if ( ! client -> authenticated ) { if ( buffer -> pos > 0 ) { gboolean found_auth_end = FALSE ; gsize extra_data ; buffer -> size = buffer -> pos ; if ( ! side -> got_first_byte ) { buffer -> send_credentials = TRUE ; side -> got_first_byte = TRUE ; } else if ( side == & client -> client_side ) { gssize auth_end = find_auth_end ( client , buffer ) ; if ( auth_end >= 0 ) { found_auth_end = TRUE ; buffer -> size = auth_end ; extra_data = buffer -> pos - buffer -> size ; if ( extra_data > 0 ) side -> extra_input_data = g_bytes_new ( buffer -> data + buffer -> size , extra_data ) ; } <S2SV_StartBug> } <S2SV_EndBug> got_buffer_from_side ( side , buffer ) ; if ( found_auth_end ) client -> authenticated = TRUE ; } else { buffer_unref ( buffer ) ; } } else if ( buffer -> pos == buffer -> size ) { if ( buffer == & side -> header_buffer ) { gssize required ; required = g_dbus_message_bytes_needed ( buffer -> data , buffer -> size , & error ) ; if ( required < 0 ) { g_warning ( ""Invalid<S2SV_blank>message<S2SV_blank>header<S2SV_blank>read"" ) ; side_closed ( side ) ; } else { side -> current_read_buffer = buffer_new ( required , buffer ) ; } } else { got_buffer_from_side ( side , buffer ) ; side -> header_buffer . pos = 0 ; side -> current_read_buffer = & side -> header_buffer ; } } } if ( side -> closed ) { side -> in_source = NULL ; retval = G_SOURCE_REMOVE ; } g_object_unref ( client ) ; return retval ; }",") ; } else if ( auth_end == FIND_AUTH_END_ABORT ) { buffer_unref ( buffer ) ; if ( client -> proxy -> log_messages ) g_print ( ""Invalid<S2SV_blank>AUTH<S2SV_blank>line,<S2SV_blank>aborting\\n"" ) ; side_closed ( side ) ; break ; }"
341,"int ext2_xattr_get ( struct inode * inode , int name_index , const char * name , void * buffer , size_t buffer_size ) { struct buffer_head * bh = NULL ; struct ext2_xattr_entry * entry ; size_t name_len , size ; char * end ; <S2SV_StartBug> int error ; <S2SV_EndBug> ea_idebug ( inode , ""name=%d.%s,<S2SV_blank>buffer=%p,<S2SV_blank>buffer_size=%ld"" , name_index , name , buffer , ( long ) buffer_size ) ; if ( name == NULL ) return - EINVAL ; name_len = strlen ( name ) ; if ( name_len > 255 ) return - ERANGE ; down_read ( & EXT2_I ( inode ) -> xattr_sem ) ; error = - ENODATA ; if ( ! EXT2_I ( inode ) -> i_file_acl ) goto cleanup ; ea_idebug ( inode , ""reading<S2SV_blank>block<S2SV_blank>%d"" , EXT2_I ( inode ) -> i_file_acl ) ; bh = sb_bread ( inode -> i_sb , EXT2_I ( inode ) -> i_file_acl ) ; error = - EIO ; if ( ! bh ) goto cleanup ; ea_bdebug ( bh , ""b_count=%d,<S2SV_blank>refcount=%d"" , atomic_read ( & ( bh -> b_count ) ) , le32_to_cpu ( HDR ( bh ) -> h_refcount ) ) ; end = bh -> b_data + bh -> b_size ; if ( HDR ( bh ) -> h_magic != cpu_to_le32 ( EXT2_XATTR_MAGIC ) || HDR ( bh ) -> h_blocks != cpu_to_le32 ( 1 ) ) { bad_block : ext2_error ( inode -> i_sb , ""ext2_xattr_get"" , ""inode<S2SV_blank>%ld:<S2SV_blank>bad<S2SV_blank>block<S2SV_blank>%d"" , inode -> i_ino , EXT2_I ( inode ) -> i_file_acl ) ; error = - EIO ; goto cleanup ; } entry = FIRST_ENTRY ( bh ) ; while ( ! IS_LAST_ENTRY ( entry ) ) { struct ext2_xattr_entry * next = EXT2_XATTR_NEXT ( entry ) ; if ( ( char * ) next >= end ) goto bad_block ; if ( name_index == entry -> e_name_index && name_len == entry -> e_name_len && memcmp ( name , entry -> e_name , name_len ) == 0 ) goto found ; entry = next ; } <S2SV_StartBug> if ( ext2_xattr_cache_insert ( bh ) ) <S2SV_EndBug> ea_idebug ( inode , ""cache<S2SV_blank>insert<S2SV_blank>failed"" ) ; error = - ENODATA ; goto cleanup ; found : if ( entry -> e_value_block != 0 ) goto bad_block ; size = le32_to_cpu ( entry -> e_value_size ) ; if ( size > inode -> i_sb -> s_blocksize || le16_to_cpu ( entry -> e_value_offs ) + size > inode -> i_sb -> s_blocksize ) goto bad_block ; <S2SV_StartBug> if ( ext2_xattr_cache_insert ( bh ) ) <S2SV_EndBug> ea_idebug ( inode , ""cache<S2SV_blank>insert<S2SV_blank>failed"" ) ; if ( buffer ) { error = - ERANGE ; if ( size > buffer_size ) goto cleanup ; memcpy ( buffer , bh -> b_data + le16_to_cpu ( entry -> e_value_offs ) , size ) ; } error = size ; cleanup : brelse ( bh ) ; up_read ( & EXT2_I ( inode ) -> xattr_sem ) ; return error ; }","; int error ; struct mb2_cache * ext2_mb_cache = EXT2_SB ( inode -> i_sb ) -> s_mb_cache <S2SV_ModStart> ( ext2_xattr_cache_insert ( ext2_mb_cache , <S2SV_ModStart> ( ext2_xattr_cache_insert ( ext2_mb_cache ,"
342,"static int decode_zbuf ( AVBPrint * bp , const uint8_t * data , const uint8_t * data_end ) { z_stream zstream ; unsigned char * buf ; unsigned buf_size ; int ret ; zstream . zalloc = ff_png_zalloc ; zstream . zfree = ff_png_zfree ; zstream . opaque = NULL ; if ( inflateInit ( & zstream ) != Z_OK ) return AVERROR_EXTERNAL ; zstream . next_in = ( unsigned char * ) data ; zstream . avail_in = data_end - data ; av_bprint_init ( bp , 0 , - 1 ) ; while ( zstream . avail_in > 0 ) { <S2SV_StartBug> av_bprint_get_buffer ( bp , 1 , & buf , & buf_size ) ; <S2SV_EndBug> if ( ! buf_size ) { ret = AVERROR ( ENOMEM ) ; goto fail ; } zstream . next_out = buf ; <S2SV_StartBug> zstream . avail_out = buf_size ; <S2SV_EndBug> ret = inflate ( & zstream , Z_PARTIAL_FLUSH ) ; if ( ret != Z_OK && ret != Z_STREAM_END ) { ret = AVERROR_EXTERNAL ; goto fail ; } bp -> len += zstream . next_out - buf ; if ( ret == Z_STREAM_END ) break ; } inflateEnd ( & zstream ) ; bp -> str [ bp -> len ] = 0 ; return 0 ; fail : inflateEnd ( & zstream ) ; av_bprint_finalize ( bp , NULL ) ; return ret ; }","( bp , 2 , & buf , & buf_size ) ; if ( buf_size < 2 <S2SV_ModEnd> ) { ret <S2SV_ModStart> avail_out = buf_size - 1"
343,"static unsigned create_oops_dump_dirs ( GList * oops_list , unsigned oops_cnt ) { unsigned countdown = MAX_DUMPED_DD_COUNT ; log_notice ( ""Saving<S2SV_blank>%u<S2SV_blank>oopses<S2SV_blank>as<S2SV_blank>problem<S2SV_blank>dirs"" , oops_cnt >= countdown ? countdown : oops_cnt ) ; char * cmdline_str = xmalloc_fopen_fgetline_fclose ( ""/proc/cmdline"" ) ; char * fips_enabled = xmalloc_fopen_fgetline_fclose ( ""/proc/sys/crypto/fips_enabled"" ) ; char * proc_modules = xmalloc_open_read_close ( ""/proc/modules"" , NULL ) ; char * suspend_stats = xmalloc_open_read_close ( ""/sys/kernel/debug/suspend_stats"" , NULL ) ; time_t t = time ( NULL ) ; const char * iso_date = iso_date_string ( & t ) ; uid_t my_euid = ( uid_t ) - 1L ; mode_t mode = DEFAULT_DUMP_DIR_MODE | S_IROTH ; if ( ! world_readable_dump ) { mode = DEFAULT_DUMP_DIR_MODE ; my_euid = geteuid ( ) ; } <S2SV_StartBug> pid_t my_pid = getpid ( ) ; <S2SV_EndBug> unsigned idx = 0 ; unsigned errors = 0 ; while ( idx < oops_cnt ) { char base [ sizeof ( ""oops-YYYY-MM-DD-hh:mm:ss-%lu-%lu"" ) + 2 * sizeof ( long ) * 3 ] ; sprintf ( base , ""oops-%s-%lu-%lu"" , iso_date , ( long ) my_pid , ( long ) idx ) ; char * path = concat_path_file ( debug_dumps_dir , base ) ; struct dump_dir * dd = dd_create ( path , my_euid , mode ) ; if ( dd ) { dd_create_basic_files ( dd , my_euid , NULL ) ; save_oops_data_in_dump_dir ( dd , ( char * ) g_list_nth_data ( oops_list , idx ++ ) , proc_modules ) ; dd_save_text ( dd , FILENAME_ABRT_VERSION , VERSION ) ; dd_save_text ( dd , FILENAME_ANALYZER , ""Kerneloops"" ) ; dd_save_text ( dd , FILENAME_TYPE , ""Kerneloops"" ) ; if ( cmdline_str ) dd_save_text ( dd , FILENAME_CMDLINE , cmdline_str ) ; if ( proc_modules ) dd_save_text ( dd , ""proc_modules"" , proc_modules ) ; if ( fips_enabled && strcmp ( fips_enabled , ""0"" ) != 0 ) dd_save_text ( dd , ""fips_enabled"" , fips_enabled ) ; if ( suspend_stats ) dd_save_text ( dd , ""suspend_stats"" , suspend_stats ) ; dd_close ( dd ) ; notify_new_path ( path ) ; } else errors ++ ; free ( path ) ; if ( -- countdown == 0 ) break ; if ( dd && throttle_dd_creation ) sleep ( 1 ) ; } free ( cmdline_str ) ; free ( proc_modules ) ; free ( fips_enabled ) ; free ( suspend_stats ) ; return errors ; }",") ; } if ( g_settings_privatereports ) { if ( world_readable_dump ) log ( ""Not<S2SV_blank>going<S2SV_blank>to<S2SV_blank>make<S2SV_blank>dump<S2SV_blank>directories<S2SV_blank>world<S2SV_blank>readable<S2SV_blank>because<S2SV_blank>PrivateReports<S2SV_blank>is<S2SV_blank>on"" ) ; mode = DEFAULT_DUMP_DIR_MODE ; my_euid = 0 ; }"
344,"void vrrp_print_stats ( void ) { <S2SV_StartBug> FILE * file ; <S2SV_EndBug> <S2SV_StartBug> file = fopen ( stats_file , ""w"" ) ; <S2SV_EndBug> if ( ! file ) { log_message ( LOG_INFO , ""Can\'t<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>(%d:<S2SV_blank>%s)"" , stats_file , errno , strerror ( errno ) ) ; return ; } list l = vrrp_data -> vrrp ; element e ; vrrp_t * vrrp ; <S2SV_StartBug> for ( e = LIST_HEAD ( l ) ; e ; ELEMENT_NEXT ( e ) ) { <S2SV_EndBug> vrrp = ELEMENT_DATA ( e ) ; fprintf ( file , ""VRRP<S2SV_blank>Instance:<S2SV_blank>%s\\n"" , vrrp -> iname ) ; fprintf ( file , ""<S2SV_blank><S2SV_blank>Advertisements:\\n"" ) ; fprintf ( file , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Received:<S2SV_blank>%"" PRIu64 ""\\n"" , vrrp -> stats -> advert_rcvd ) ; fprintf ( file , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Sent:<S2SV_blank>%d\\n"" , vrrp -> stats -> advert_sent ) ; fprintf ( file , ""<S2SV_blank><S2SV_blank>Became<S2SV_blank>master:<S2SV_blank>%d\\n"" , vrrp -> stats -> become_master ) ; fprintf ( file , ""<S2SV_blank><S2SV_blank>Released<S2SV_blank>master:<S2SV_blank>%d\\n"" , vrrp -> stats -> release_master ) ; fprintf ( file , ""<S2SV_blank><S2SV_blank>Packet<S2SV_blank>Errors:\\n"" ) ; fprintf ( file , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Length:<S2SV_blank>%"" PRIu64 ""\\n"" , vrrp -> stats -> packet_len_err ) ; fprintf ( file , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>TTL:<S2SV_blank>%"" PRIu64 ""\\n"" , vrrp -> stats -> ip_ttl_err ) ; fprintf ( file , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Invalid<S2SV_blank>Type:<S2SV_blank>%"" PRIu64 ""\\n"" , vrrp -> stats -> invalid_type_rcvd ) ; fprintf ( file , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Advertisement<S2SV_blank>Interval:<S2SV_blank>%"" PRIu64 ""\\n"" , vrrp -> stats -> advert_interval_err ) ; fprintf ( file , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Address<S2SV_blank>List:<S2SV_blank>%"" PRIu64 ""\\n"" , vrrp -> stats -> addr_list_err ) ; fprintf ( file , ""<S2SV_blank><S2SV_blank>Authentication<S2SV_blank>Errors:\\n"" ) ; fprintf ( file , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Invalid<S2SV_blank>Type:<S2SV_blank>%d\\n"" , vrrp -> stats -> invalid_authtype ) ; # ifdef _WITH_VRRP_AUTH_ fprintf ( file , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Type<S2SV_blank>Mismatch:<S2SV_blank>%d\\n"" , vrrp -> stats -> authtype_mismatch ) ; fprintf ( file , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Failure:<S2SV_blank>%d\\n"" , vrrp -> stats -> auth_failure ) ; # endif fprintf ( file , ""<S2SV_blank><S2SV_blank>Priority<S2SV_blank>Zero:\\n"" ) ; fprintf ( file , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Received:<S2SV_blank>%"" PRIu64 ""\\n"" , vrrp -> stats -> pri_zero_rcvd ) ; fprintf ( file , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Sent:<S2SV_blank>%"" PRIu64 ""\\n"" , vrrp -> stats -> pri_zero_sent ) ; } fclose ( file ) ; }","FILE * file = fopen_safe <S2SV_ModEnd> ( stats_file , <S2SV_ModStart> , ""w"" ) <S2SV_ModEnd> ; element e <S2SV_ModStart> * vrrp ; if ( ! file ) { log_message ( LOG_INFO , ""Can\'t<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>(%d:<S2SV_blank>%s)"" , stats_file , errno , strerror ( errno ) ) ; return ; } LIST_FOREACH ( vrrp_data -> vrrp , vrrp , e ) { <S2SV_ModEnd> fprintf ( file"
345,"static Sdb * store_versioninfo_gnu_verdef ( ELFOBJ * bin , Elf_ ( Shdr ) * shdr , int sz ) { const char * section_name = """" ; const char * link_section_name = """" ; char * end = NULL ; Elf_ ( Shdr ) * link_shdr = NULL ; ut8 dfs [ sizeof ( Elf_ ( Verdef ) ) ] = { 0 } ; Sdb * sdb ; int cnt , i ; if ( shdr -> sh_link > bin -> ehdr . e_shnum ) { return false ; } link_shdr = & bin -> shdr [ shdr -> sh_link ] ; if ( shdr -> sh_size < 1 || shdr -> sh_size > SIZE_MAX ) { return false ; } Elf_ ( Verdef ) * defs = calloc ( shdr -> sh_size , sizeof ( char ) ) ; if ( ! defs ) { return false ; } if ( bin -> shstrtab && shdr -> sh_name < bin -> shstrtab_size ) { section_name = & bin -> shstrtab [ shdr -> sh_name ] ; } if ( link_shdr && bin -> shstrtab && link_shdr -> sh_name < bin -> shstrtab_size ) { link_section_name = & bin -> shstrtab [ link_shdr -> sh_name ] ; } if ( ! defs ) { bprintf ( ""Warning:<S2SV_blank>Cannot<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>(Check<S2SV_blank>Elf_(Verdef))\\n"" ) ; return NULL ; } sdb = sdb_new0 ( ) ; end = ( char * ) defs + shdr -> sh_size ; sdb_set ( sdb , ""section_name"" , section_name , 0 ) ; sdb_num_set ( sdb , ""entries"" , shdr -> sh_info , 0 ) ; sdb_num_set ( sdb , ""addr"" , shdr -> sh_addr , 0 ) ; sdb_num_set ( sdb , ""offset"" , shdr -> sh_offset , 0 ) ; sdb_num_set ( sdb , ""link"" , shdr -> sh_link , 0 ) ; sdb_set ( sdb , ""link_section_name"" , link_section_name , 0 ) ; for ( cnt = 0 , i = 0 ; i >= 0 && cnt < shdr -> sh_info && ( end - ( char * ) defs > i ) ; ++ cnt ) { Sdb * sdb_verdef = sdb_new0 ( ) ; char * vstart = ( ( char * ) defs ) + i ; char key [ 32 ] = { 0 } ; Elf_ ( Verdef ) * verdef = ( Elf_ ( Verdef ) * ) vstart ; Elf_ ( Verdaux ) aux = { 0 } ; int j = 0 ; int isum = 0 ; r_buf_read_at ( bin -> b , shdr -> sh_offset + i , dfs , sizeof ( Elf_ ( Verdef ) ) ) ; verdef -> vd_version = READ16 ( dfs , j ) verdef -> vd_flags = READ16 ( dfs , j ) verdef -> vd_ndx = READ16 ( dfs , j ) verdef -> vd_cnt = READ16 ( dfs , j ) verdef -> vd_hash = READ32 ( dfs , j ) verdef -> vd_aux = READ32 ( dfs , j ) verdef -> vd_next = READ32 ( dfs , j ) int vdaux = verdef -> vd_aux ; <S2SV_StartBug> if ( vdaux < 1 || ( char * ) UINTPTR_MAX - vstart < vdaux ) { <S2SV_EndBug> sdb_free ( sdb_verdef ) ; goto out_error ; } vstart += vdaux ; if ( vstart > end || end - vstart < sizeof ( Elf_ ( Verdaux ) ) ) { sdb_free ( sdb_verdef ) ; goto out_error ; } j = 0 ; aux . vda_name = READ32 ( vstart , j ) aux . vda_next = READ32 ( vstart , j ) isum = i + verdef -> vd_aux ; if ( aux . vda_name > bin -> dynstr_size ) { sdb_free ( sdb_verdef ) ; goto out_error ; } sdb_num_set ( sdb_verdef , ""idx"" , i , 0 ) ; sdb_num_set ( sdb_verdef , ""vd_version"" , verdef -> vd_version , 0 ) ; sdb_num_set ( sdb_verdef , ""vd_ndx"" , verdef -> vd_ndx , 0 ) ; sdb_num_set ( sdb_verdef , ""vd_cnt"" , verdef -> vd_cnt , 0 ) ; sdb_set ( sdb_verdef , ""vda_name"" , & bin -> dynstr [ aux . vda_name ] , 0 ) ; sdb_set ( sdb_verdef , ""flags"" , get_ver_flags ( verdef -> vd_flags ) , 0 ) ; for ( j = 1 ; j < verdef -> vd_cnt ; ++ j ) { int k ; Sdb * sdb_parent = sdb_new0 ( ) ; isum += aux . vda_next ; vstart += aux . vda_next ; if ( vstart > end || end - vstart < sizeof ( Elf_ ( Verdaux ) ) ) { sdb_free ( sdb_verdef ) ; sdb_free ( sdb_parent ) ; goto out_error ; } k = 0 ; aux . vda_name = READ32 ( vstart , k ) aux . vda_next = READ32 ( vstart , k ) if ( aux . vda_name > bin -> dynstr_size ) { sdb_free ( sdb_verdef ) ; sdb_free ( sdb_parent ) ; goto out_error ; } sdb_num_set ( sdb_parent , ""idx"" , isum , 0 ) ; sdb_num_set ( sdb_parent , ""parent"" , j , 0 ) ; sdb_set ( sdb_parent , ""vda_name"" , & bin -> dynstr [ aux . vda_name ] , 0 ) ; snprintf ( key , sizeof ( key ) , ""parent%d"" , j - 1 ) ; sdb_ns_set ( sdb_verdef , key , sdb_parent ) ; } snprintf ( key , sizeof ( key ) , ""verdef%d"" , cnt ) ; sdb_ns_set ( sdb , key , sdb_verdef ) ; if ( ! verdef -> vd_next ) { sdb_free ( sdb_verdef ) ; goto out_error ; } if ( ( st32 ) verdef -> vd_next < 1 ) { eprintf ( ""Warning:<S2SV_blank>Invalid<S2SV_blank>vd_next<S2SV_blank>in<S2SV_blank>the<S2SV_blank>ELF<S2SV_blank>version\\n"" ) ; break ; } i += verdef -> vd_next ; } free ( defs ) ; return sdb ; out_error : free ( defs ) ; sdb_free ( sdb ) ; return NULL ; }",< 1 || vstart + vdaux < vstart <S2SV_ModEnd> ) { sdb_free
346,"static int decode_multicast_vpn ( netdissect_options * ndo , const u_char * pptr , char * buf , u_int buflen ) { uint8_t route_type , route_length , addr_length , sg_length ; u_int offset ; ND_TCHECK2 ( pptr [ 0 ] , 2 ) ; route_type = * pptr ++ ; route_length = * pptr ++ ; snprintf ( buf , buflen , ""Route-Type:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>length:<S2SV_blank>%u"" , tok2str ( bgp_multicast_vpn_route_type_values , ""Unknown"" , route_type ) , route_type , route_length ) ; switch ( route_type ) { case BGP_MULTICAST_VPN_ROUTE_TYPE_INTRA_AS_I_PMSI : ND_TCHECK2 ( pptr [ 0 ] , BGP_VPN_RD_LEN ) ; offset = strlen ( buf ) ; snprintf ( buf + offset , buflen - offset , "",<S2SV_blank>RD:<S2SV_blank>%s,<S2SV_blank>Originator<S2SV_blank>%s"" , bgp_vpn_rd_print ( ndo , pptr ) , bgp_vpn_ip_print ( ndo , pptr + BGP_VPN_RD_LEN , ( route_length - BGP_VPN_RD_LEN ) << 3 ) ) ; break ; case BGP_MULTICAST_VPN_ROUTE_TYPE_INTER_AS_I_PMSI : ND_TCHECK2 ( pptr [ 0 ] , BGP_VPN_RD_LEN + 4 ) ; offset = strlen ( buf ) ; snprintf ( buf + offset , buflen - offset , "",<S2SV_blank>RD:<S2SV_blank>%s,<S2SV_blank>Source-AS<S2SV_blank>%s"" , bgp_vpn_rd_print ( ndo , pptr ) , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( pptr + BGP_VPN_RD_LEN ) ) ) ; break ; case BGP_MULTICAST_VPN_ROUTE_TYPE_S_PMSI : ND_TCHECK2 ( pptr [ 0 ] , BGP_VPN_RD_LEN ) ; offset = strlen ( buf ) ; snprintf ( buf + offset , buflen - offset , "",<S2SV_blank>RD:<S2SV_blank>%s"" , bgp_vpn_rd_print ( ndo , pptr ) ) ; pptr += BGP_VPN_RD_LEN ; sg_length = bgp_vpn_sg_print ( ndo , pptr , buf , buflen ) ; addr_length = route_length - sg_length ; ND_TCHECK2 ( pptr [ 0 ] , addr_length ) ; offset = strlen ( buf ) ; snprintf ( buf + offset , buflen - offset , "",<S2SV_blank>Originator<S2SV_blank>%s"" , bgp_vpn_ip_print ( ndo , pptr , addr_length << 3 ) ) ; break ; case BGP_MULTICAST_VPN_ROUTE_TYPE_SOURCE_ACTIVE : ND_TCHECK2 ( pptr [ 0 ] , BGP_VPN_RD_LEN ) ; offset = strlen ( buf ) ; snprintf ( buf + offset , buflen - offset , "",<S2SV_blank>RD:<S2SV_blank>%s"" , bgp_vpn_rd_print ( ndo , pptr ) ) ; pptr += BGP_VPN_RD_LEN ; bgp_vpn_sg_print ( ndo , pptr , buf , buflen ) ; break ; case BGP_MULTICAST_VPN_ROUTE_TYPE_SHARED_TREE_JOIN : case BGP_MULTICAST_VPN_ROUTE_TYPE_SOURCE_TREE_JOIN : <S2SV_StartBug> ND_TCHECK2 ( pptr [ 0 ] , BGP_VPN_RD_LEN ) ; <S2SV_EndBug> offset = strlen ( buf ) ; snprintf ( buf + offset , buflen - offset , "",<S2SV_blank>RD:<S2SV_blank>%s,<S2SV_blank>Source-AS<S2SV_blank>%s"" , bgp_vpn_rd_print ( ndo , pptr ) , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( pptr + BGP_VPN_RD_LEN ) ) ) ; <S2SV_StartBug> pptr += BGP_VPN_RD_LEN ; <S2SV_EndBug> bgp_vpn_sg_print ( ndo , pptr , buf , buflen ) ; break ; case BGP_MULTICAST_VPN_ROUTE_TYPE_INTRA_AS_SEG_LEAF : default : break ; } return route_length + 2 ; trunc : return - 2 ; }","] , BGP_VPN_RD_LEN + 4 <S2SV_ModStart> pptr += BGP_VPN_RD_LEN + 4"
347,"static void parse_hid_report_descriptor ( struct gtco * device , char * report , int length ) { struct device * ddev = & device -> intf -> dev ; int x , i = 0 ; __u8 prefix ; __u8 size ; __u8 tag ; __u8 type ; __u8 data = 0 ; __u16 data16 = 0 ; __u32 data32 = 0 ; int inputnum = 0 ; __u32 usage = 0 ; __u32 globalval [ TAG_GLOB_MAX ] ; __u32 oldval [ TAG_GLOB_MAX ] ; char maintype = 'x' ; char globtype [ 12 ] ; int indent = 0 ; char indentstr [ 10 ] = """" ; dev_dbg ( ddev , ""======>>>>>>PARSE<<<<<<======\\n"" ) ; while ( i < length ) { <S2SV_StartBug> prefix = report [ i ] ; <S2SV_EndBug> i ++ ; size = PREF_SIZE ( prefix ) ; switch ( size ) { case 1 : data = report [ i ] ; break ; case 2 : data16 = get_unaligned_le16 ( & report [ i ] ) ; break ; <S2SV_StartBug> case 3 : <S2SV_EndBug> size = 4 ; data32 = get_unaligned_le32 ( & report [ i ] ) ; break ; } i += size ; tag = PREF_TAG ( prefix ) ; type = PREF_TYPE ( prefix ) ; switch ( type ) { case TYPE_MAIN : strcpy ( globtype , """" ) ; switch ( tag ) { case TAG_MAIN_INPUT : maintype = 'I' ; if ( data == 2 ) strcpy ( globtype , ""Variable"" ) ; else if ( data == 3 ) strcpy ( globtype , ""Var|Const"" ) ; dev_dbg ( ddev , "":::::<S2SV_blank>Saving<S2SV_blank>Report:<S2SV_blank>%d<S2SV_blank>input<S2SV_blank>#%d<S2SV_blank>Max:<S2SV_blank>0x%X(%d)<S2SV_blank>Min:0x%X(%d)<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bits\\n"" , globalval [ TAG_GLOB_REPORT_ID ] , inputnum , globalval [ TAG_GLOB_LOG_MAX ] , globalval [ TAG_GLOB_LOG_MAX ] , globalval [ TAG_GLOB_LOG_MIN ] , globalval [ TAG_GLOB_LOG_MIN ] , globalval [ TAG_GLOB_REPORT_SZ ] * globalval [ TAG_GLOB_REPORT_CNT ] ) ; switch ( inputnum ) { case 0 : dev_dbg ( ddev , ""GER:<S2SV_blank>X<S2SV_blank>Usage:<S2SV_blank>0x%x\\n"" , usage ) ; if ( device -> max_X == 0 ) { device -> max_X = globalval [ TAG_GLOB_LOG_MAX ] ; device -> min_X = globalval [ TAG_GLOB_LOG_MIN ] ; } break ; case 1 : dev_dbg ( ddev , ""GER:<S2SV_blank>Y<S2SV_blank>Usage:<S2SV_blank>0x%x\\n"" , usage ) ; if ( device -> max_Y == 0 ) { device -> max_Y = globalval [ TAG_GLOB_LOG_MAX ] ; device -> min_Y = globalval [ TAG_GLOB_LOG_MIN ] ; } break ; default : if ( usage == DIGITIZER_USAGE_TILT_X ) { if ( device -> maxtilt_X == 0 ) { device -> maxtilt_X = globalval [ TAG_GLOB_LOG_MAX ] ; device -> mintilt_X = globalval [ TAG_GLOB_LOG_MIN ] ; } } if ( usage == DIGITIZER_USAGE_TILT_Y ) { if ( device -> maxtilt_Y == 0 ) { device -> maxtilt_Y = globalval [ TAG_GLOB_LOG_MAX ] ; device -> mintilt_Y = globalval [ TAG_GLOB_LOG_MIN ] ; } } if ( usage == DIGITIZER_USAGE_TIP_PRESSURE ) { if ( device -> maxpressure == 0 ) { device -> maxpressure = globalval [ TAG_GLOB_LOG_MAX ] ; device -> minpressure = globalval [ TAG_GLOB_LOG_MIN ] ; } } break ; } inputnum ++ ; break ; case TAG_MAIN_OUTPUT : maintype = 'O' ; break ; case TAG_MAIN_FEATURE : maintype = 'F' ; break ; case TAG_MAIN_COL_START : maintype = 'S' ; if ( data == 0 ) { dev_dbg ( ddev , ""======>>>>>><S2SV_blank>Physical\\n"" ) ; strcpy ( globtype , ""Physical"" ) ; } else dev_dbg ( ddev , ""======>>>>>>\\n"" ) ; indent ++ ; for ( x = 0 ; x < indent ; x ++ ) indentstr [ x ] = '-' ; indentstr [ x ] = 0 ; for ( x = 0 ; x < TAG_GLOB_MAX ; x ++ ) oldval [ x ] = globalval [ x ] ; break ; case TAG_MAIN_COL_END : dev_dbg ( ddev , ""<<<<<<======\\n"" ) ; maintype = 'E' ; indent -- ; for ( x = 0 ; x < indent ; x ++ ) indentstr [ x ] = '-' ; indentstr [ x ] = 0 ; for ( x = 0 ; x < TAG_GLOB_MAX ; x ++ ) globalval [ x ] = oldval [ x ] ; break ; } switch ( size ) { case 1 : dev_dbg ( ddev , ""%sMAINTAG:(%d)<S2SV_blank>%c<S2SV_blank>SIZE:<S2SV_blank>%d<S2SV_blank>Data:<S2SV_blank>%s<S2SV_blank>0x%x\\n"" , indentstr , tag , maintype , size , globtype , data ) ; break ; case 2 : dev_dbg ( ddev , ""%sMAINTAG:(%d)<S2SV_blank>%c<S2SV_blank>SIZE:<S2SV_blank>%d<S2SV_blank>Data:<S2SV_blank>%s<S2SV_blank>0x%x\\n"" , indentstr , tag , maintype , size , globtype , data16 ) ; break ; case 4 : dev_dbg ( ddev , ""%sMAINTAG:(%d)<S2SV_blank>%c<S2SV_blank>SIZE:<S2SV_blank>%d<S2SV_blank>Data:<S2SV_blank>%s<S2SV_blank>0x%x\\n"" , indentstr , tag , maintype , size , globtype , data32 ) ; break ; } break ; case TYPE_GLOBAL : switch ( tag ) { case TAG_GLOB_USAGE : if ( device -> usage == 0 ) device -> usage = data ; strcpy ( globtype , ""USAGE"" ) ; break ; case TAG_GLOB_LOG_MIN : strcpy ( globtype , ""LOG_MIN"" ) ; break ; case TAG_GLOB_LOG_MAX : strcpy ( globtype , ""LOG_MAX"" ) ; break ; case TAG_GLOB_PHYS_MIN : strcpy ( globtype , ""PHYS_MIN"" ) ; break ; case TAG_GLOB_PHYS_MAX : strcpy ( globtype , ""PHYS_MAX"" ) ; break ; case TAG_GLOB_UNIT_EXP : strcpy ( globtype , ""EXP"" ) ; break ; case TAG_GLOB_UNIT : strcpy ( globtype , ""UNIT"" ) ; break ; case TAG_GLOB_REPORT_SZ : strcpy ( globtype , ""REPORT_SZ"" ) ; break ; case TAG_GLOB_REPORT_ID : strcpy ( globtype , ""REPORT_ID"" ) ; inputnum = 0 ; break ; case TAG_GLOB_REPORT_CNT : strcpy ( globtype , ""REPORT_CNT"" ) ; break ; case TAG_GLOB_PUSH : strcpy ( globtype , ""PUSH"" ) ; break ; case TAG_GLOB_POP : strcpy ( globtype , ""POP"" ) ; break ; } if ( tag < TAG_GLOB_MAX ) { switch ( size ) { case 1 : dev_dbg ( ddev , ""%sGLOBALTAG:%s(%d)<S2SV_blank>SIZE:<S2SV_blank>%d<S2SV_blank>Data:<S2SV_blank>0x%x\\n"" , indentstr , globtype , tag , size , data ) ; globalval [ tag ] = data ; break ; case 2 : dev_dbg ( ddev , ""%sGLOBALTAG:%s(%d)<S2SV_blank>SIZE:<S2SV_blank>%d<S2SV_blank>Data:<S2SV_blank>0x%x\\n"" , indentstr , globtype , tag , size , data16 ) ; globalval [ tag ] = data16 ; break ; case 4 : dev_dbg ( ddev , ""%sGLOBALTAG:%s(%d)<S2SV_blank>SIZE:<S2SV_blank>%d<S2SV_blank>Data:<S2SV_blank>0x%x\\n"" , indentstr , globtype , tag , size , data32 ) ; globalval [ tag ] = data32 ; break ; } } else { dev_dbg ( ddev , ""%sGLOBALTAG:<S2SV_blank>ILLEGAL<S2SV_blank>TAG:%d<S2SV_blank>SIZE:<S2SV_blank>%d\\n"" , indentstr , tag , size ) ; } break ; case TYPE_LOCAL : switch ( tag ) { case TAG_GLOB_USAGE : strcpy ( globtype , ""USAGE"" ) ; usage = data ; break ; case TAG_GLOB_LOG_MIN : strcpy ( globtype , ""MIN"" ) ; break ; case TAG_GLOB_LOG_MAX : strcpy ( globtype , ""MAX"" ) ; break ; default : strcpy ( globtype , ""UNKNOWN"" ) ; break ; } switch ( size ) { case 1 : dev_dbg ( ddev , ""%sLOCALTAG:(%d)<S2SV_blank>%s<S2SV_blank>SIZE:<S2SV_blank>%d<S2SV_blank>Data:<S2SV_blank>0x%x\\n"" , indentstr , tag , globtype , size , data ) ; break ; case 2 : dev_dbg ( ddev , ""%sLOCALTAG:(%d)<S2SV_blank>%s<S2SV_blank>SIZE:<S2SV_blank>%d<S2SV_blank>Data:<S2SV_blank>0x%x\\n"" , indentstr , tag , globtype , size , data16 ) ; break ; case 4 : dev_dbg ( ddev , ""%sLOCALTAG:(%d)<S2SV_blank>%s<S2SV_blank>SIZE:<S2SV_blank>%d<S2SV_blank>Data:<S2SV_blank>0x%x\\n"" , indentstr , tag , globtype , size , data32 ) ; break ; } break ; } } }","report [ i ++ ] ; size = ( 1U << PREF_SIZE ( prefix ) ) >> 1 ; if ( i + size > length ) { dev_err ( ddev , ""Not<S2SV_blank>enough<S2SV_blank>data<S2SV_blank>(need<S2SV_blank>%d,<S2SV_blank>have<S2SV_blank>%d)\\n"" , i + size , length ) ; break ; } <S2SV_ModEnd> switch ( size <S2SV_ModStart> break ; case 4 : <S2SV_ModEnd> data32 = get_unaligned_le32"
348,"int jas_stream_write ( jas_stream_t * stream , const void * buf , int cnt ) { int n ; <S2SV_StartBug> const char * bufptr ; <S2SV_EndBug> bufptr = buf ; n = 0 ; while ( n < cnt ) { if ( jas_stream_putc ( stream , * bufptr ) == EOF ) { return n ; } ++ bufptr ; ++ n ; } return n ; }","* bufptr ; if ( cnt < 0 ) { jas_deprecated ( ""negative<S2SV_blank>count<S2SV_blank>for<S2SV_blank>jas_stream_write"" ) ; }"
349,"static int renameUnmapSelectCb ( Walker * pWalker , Select * p ) { Parse * pParse = pWalker -> pParse ; int i ; if ( pParse -> nErr ) return WRC_Abort ; <S2SV_StartBug> if ( ALWAYS ( p -> pEList ) ) { <S2SV_EndBug> ExprList * pList = p -> pEList ; for ( i = 0 ; i < pList -> nExpr ; i ++ ) { if ( pList -> a [ i ] . zName ) { sqlite3RenameTokenRemap ( pParse , 0 , ( void * ) pList -> a [ i ] . zName ) ; } } } if ( ALWAYS ( p -> pSrc ) ) { SrcList * pSrc = p -> pSrc ; for ( i = 0 ; i < pSrc -> nSrc ; i ++ ) { sqlite3RenameTokenRemap ( pParse , 0 , ( void * ) pSrc -> a [ i ] . zName ) ; } } renameWalkWith ( pWalker , p ) ; return WRC_Continue ; }",; if ( p -> selFlags & SF_View ) return WRC_Prune ; if (
350,"static int uhid_write ( int fd , const struct uhid_event * ev ) { <S2SV_StartBug> ssize_t ret = write ( fd , ev , sizeof ( * ev ) ) ; <S2SV_EndBug> if ( ret < 0 ) { int rtn = - errno ; APPL_TRACE_ERROR ( ""%s:<S2SV_blank>Cannot<S2SV_blank>write<S2SV_blank>to<S2SV_blank>uhid:%s"" , __FUNCTION__ , strerror ( errno ) ) ; return rtn ; } else if ( ret != ( ssize_t ) sizeof ( * ev ) ) { APPL_TRACE_ERROR ( ""%s:<S2SV_blank>Wrong<S2SV_blank>size<S2SV_blank>written<S2SV_blank>to<S2SV_blank>uhid:<S2SV_blank>%zd<S2SV_blank>!=<S2SV_blank>%zu"" , __FUNCTION__ , ret , sizeof ( * ev ) ) ; return - EFAULT ; } return 0 ; }",ssize_t ret = TEMP_FAILURE_RETRY ( <S2SV_ModStart> ( * ev )
351,"static bool ResolveStateAndPredicate ( ExprDef * expr , enum xkb_match_operation * pred_rtrn , xkb_mod_mask_t * mods_rtrn , CompatInfo * info ) { if ( expr == NULL ) { * pred_rtrn = MATCH_ANY_OR_NONE ; * mods_rtrn = MOD_REAL_MASK_ALL ; return true ; } * pred_rtrn = MATCH_EXACTLY ; if ( expr -> expr . op == EXPR_ACTION_DECL ) { const char * pred_txt = xkb_atom_text ( info -> ctx , expr -> action . name ) ; <S2SV_StartBug> if ( ! LookupString ( symInterpretMatchMaskNames , pred_txt , pred_rtrn ) ) { <S2SV_EndBug> log_err ( info -> ctx , ""Illegal<S2SV_blank>modifier<S2SV_blank>predicate<S2SV_blank>\\""%s\\"";<S2SV_blank>Ignored\\n"" , pred_txt ) ; return false ; } expr = expr -> action . args ; } else if ( expr -> expr . op == EXPR_IDENT ) { const char * pred_txt = xkb_atom_text ( info -> ctx , expr -> ident . ident ) ; if ( pred_txt && istreq ( pred_txt , ""any"" ) ) { * pred_rtrn = MATCH_ANY ; * mods_rtrn = MOD_REAL_MASK_ALL ; return true ; } } return ExprResolveModMask ( info -> ctx , expr , MOD_REAL , & info -> mods , mods_rtrn ) ; }",", pred_rtrn ) || ! expr -> action . args"
352,"static void kvp_respond_to_host ( char * key , char * value , int error ) { struct hv_kvp_msg * kvp_msg ; struct hv_kvp_msg_enumerate * kvp_data ; char * key_name ; struct icmsg_hdr * icmsghdrp ; int keylen , valuelen ; u32 buf_len ; struct vmbus_channel * channel ; u64 req_id ; if ( ! kvp_transaction . active ) { pr_warn ( ""KVP:<S2SV_blank>Transaction<S2SV_blank>not<S2SV_blank>active\\n"" ) ; return ; } buf_len = kvp_transaction . recv_len ; channel = kvp_transaction . recv_channel ; req_id = kvp_transaction . recv_req_id ; kvp_transaction . active = false ; if ( channel -> onchannel_callback == NULL ) return ; icmsghdrp = ( struct icmsg_hdr * ) & recv_buffer [ sizeof ( struct vmbuspipe_hdr ) ] ; kvp_msg = ( struct hv_kvp_msg * ) & recv_buffer [ sizeof ( struct vmbuspipe_hdr ) + sizeof ( struct icmsg_hdr ) ] ; kvp_data = & kvp_msg -> kvp_data ; key_name = key ; if ( error ) { icmsghdrp -> status = HV_E_FAIL ; goto response_done ; } <S2SV_StartBug> keylen = utf8s_to_utf16s ( key_name , strlen ( key_name ) , <S2SV_EndBug> <S2SV_StartBug> ( wchar_t * ) kvp_data -> data . key ) ; <S2SV_EndBug> kvp_data -> data . key_size = 2 * ( keylen + 1 ) ; <S2SV_StartBug> valuelen = utf8s_to_utf16s ( value , strlen ( value ) , <S2SV_EndBug> <S2SV_StartBug> ( wchar_t * ) kvp_data -> data . value ) ; <S2SV_EndBug> kvp_data -> data . value_size = 2 * ( valuelen + 1 ) ; kvp_data -> data . value_type = REG_SZ ; icmsghdrp -> status = HV_S_OK ; response_done : icmsghdrp -> icflags = ICMSGHDRFLAG_TRANSACTION | ICMSGHDRFLAG_RESPONSE ; vmbus_sendpacket ( channel , recv_buffer , buf_len , req_id , VM_PKT_DATA_INBAND , 0 ) ; }","key_name ) , UTF16_HOST_ENDIAN , <S2SV_ModStart> data . key , HV_KVP_EXCHANGE_MAX_KEY_SIZE / 2 <S2SV_ModStart> value ) , UTF16_HOST_ENDIAN , <S2SV_ModStart> data . value , HV_KVP_EXCHANGE_MAX_VALUE_SIZE / 2"
353,"static void xen_netbk_fill_frags ( struct xen_netbk * netbk , struct sk_buff * skb ) { struct skb_shared_info * shinfo = skb_shinfo ( skb ) ; int nr_frags = shinfo -> nr_frags ; int i ; for ( i = 0 ; i < nr_frags ; i ++ ) { skb_frag_t * frag = shinfo -> frags + i ; struct xen_netif_tx_request * txp ; struct page * page ; u16 pending_idx ; pending_idx = frag_get_pending_idx ( frag ) ; txp = & netbk -> pending_tx_info [ pending_idx ] . req ; page = virt_to_page ( idx_to_kaddr ( netbk , pending_idx ) ) ; __skb_fill_page_desc ( skb , i , page , txp -> offset , txp -> size ) ; skb -> len += txp -> size ; skb -> data_len += txp -> size ; skb -> truesize += txp -> size ; get_page ( netbk -> mmap_pages [ pending_idx ] ) ; <S2SV_StartBug> xen_netbk_idx_release ( netbk , pending_idx ) ; <S2SV_EndBug> } }","netbk , pending_idx , XEN_NETIF_RSP_OKAY"
354,"int snd_usbmidi_create ( struct snd_card * card , struct usb_interface * iface , struct list_head * midi_list , const struct snd_usb_audio_quirk * quirk ) { struct snd_usb_midi * umidi ; struct snd_usb_midi_endpoint_info endpoints [ MIDI_MAX_ENDPOINTS ] ; int out_ports , in_ports ; int i , err ; umidi = kzalloc ( sizeof ( * umidi ) , GFP_KERNEL ) ; if ( ! umidi ) return - ENOMEM ; umidi -> dev = interface_to_usbdev ( iface ) ; umidi -> card = card ; umidi -> iface = iface ; umidi -> quirk = quirk ; umidi -> usb_protocol_ops = & snd_usbmidi_standard_ops ; spin_lock_init ( & umidi -> disc_lock ) ; init_rwsem ( & umidi -> disc_rwsem ) ; mutex_init ( & umidi -> mutex ) ; umidi -> usb_id = USB_ID ( le16_to_cpu ( umidi -> dev -> descriptor . idVendor ) , le16_to_cpu ( umidi -> dev -> descriptor . idProduct ) ) ; setup_timer ( & umidi -> error_timer , snd_usbmidi_error_timer , ( unsigned long ) umidi ) ; memset ( endpoints , 0 , sizeof ( endpoints ) ) ; switch ( quirk ? quirk -> type : QUIRK_MIDI_STANDARD_INTERFACE ) { case QUIRK_MIDI_STANDARD_INTERFACE : err = snd_usbmidi_get_ms_info ( umidi , endpoints ) ; if ( umidi -> usb_id == USB_ID ( 0x0763 , 0x0150 ) ) umidi -> usb_protocol_ops = & snd_usbmidi_maudio_broken_running_status_ops ; break ; case QUIRK_MIDI_US122L : umidi -> usb_protocol_ops = & snd_usbmidi_122l_ops ; case QUIRK_MIDI_FIXED_ENDPOINT : memcpy ( & endpoints [ 0 ] , quirk -> data , sizeof ( struct snd_usb_midi_endpoint_info ) ) ; err = snd_usbmidi_detect_endpoints ( umidi , & endpoints [ 0 ] , 1 ) ; break ; case QUIRK_MIDI_YAMAHA : err = snd_usbmidi_detect_yamaha ( umidi , & endpoints [ 0 ] ) ; break ; case QUIRK_MIDI_ROLAND : err = snd_usbmidi_detect_roland ( umidi , & endpoints [ 0 ] ) ; break ; case QUIRK_MIDI_MIDIMAN : umidi -> usb_protocol_ops = & snd_usbmidi_midiman_ops ; memcpy ( & endpoints [ 0 ] , quirk -> data , sizeof ( struct snd_usb_midi_endpoint_info ) ) ; err = 0 ; break ; case QUIRK_MIDI_NOVATION : umidi -> usb_protocol_ops = & snd_usbmidi_novation_ops ; err = snd_usbmidi_detect_per_port_endpoints ( umidi , endpoints ) ; break ; case QUIRK_MIDI_RAW_BYTES : umidi -> usb_protocol_ops = & snd_usbmidi_raw_ops ; if ( umidi -> usb_id == USB_ID ( 0x07fd , 0x0001 ) ) usb_set_interface ( umidi -> dev , 0 , 0 ) ; err = snd_usbmidi_detect_per_port_endpoints ( umidi , endpoints ) ; break ; case QUIRK_MIDI_EMAGIC : umidi -> usb_protocol_ops = & snd_usbmidi_emagic_ops ; memcpy ( & endpoints [ 0 ] , quirk -> data , sizeof ( struct snd_usb_midi_endpoint_info ) ) ; err = snd_usbmidi_detect_endpoints ( umidi , & endpoints [ 0 ] , 1 ) ; break ; case QUIRK_MIDI_CME : umidi -> usb_protocol_ops = & snd_usbmidi_cme_ops ; err = snd_usbmidi_detect_per_port_endpoints ( umidi , endpoints ) ; break ; case QUIRK_MIDI_AKAI : umidi -> usb_protocol_ops = & snd_usbmidi_akai_ops ; err = snd_usbmidi_detect_per_port_endpoints ( umidi , endpoints ) ; endpoints [ 1 ] . out_cables = 0 ; break ; case QUIRK_MIDI_FTDI : umidi -> usb_protocol_ops = & snd_usbmidi_ftdi_ops ; err = usb_control_msg ( umidi -> dev , usb_sndctrlpipe ( umidi -> dev , 0 ) , 3 , 0x40 , 0x60 , 0 , NULL , 0 , 1000 ) ; if ( err < 0 ) break ; err = snd_usbmidi_detect_per_port_endpoints ( umidi , endpoints ) ; break ; case QUIRK_MIDI_CH345 : umidi -> usb_protocol_ops = & snd_usbmidi_ch345_broken_sysex_ops ; err = snd_usbmidi_detect_per_port_endpoints ( umidi , endpoints ) ; break ; default : dev_err ( & umidi -> dev -> dev , ""invalid<S2SV_blank>quirk<S2SV_blank>type<S2SV_blank>%d\\n"" , quirk -> type ) ; err = - ENXIO ; break ; } if ( err < 0 ) { kfree ( umidi ) ; return err ; } out_ports = 0 ; in_ports = 0 ; for ( i = 0 ; i < MIDI_MAX_ENDPOINTS ; ++ i ) { out_ports += hweight16 ( endpoints [ i ] . out_cables ) ; in_ports += hweight16 ( endpoints [ i ] . in_cables ) ; } err = snd_usbmidi_create_rawmidi ( umidi , out_ports , in_ports ) ; if ( err < 0 ) { kfree ( umidi ) ; return err ; } if ( quirk && quirk -> type == QUIRK_MIDI_MIDIMAN ) err = snd_usbmidi_create_endpoints_midiman ( umidi , & endpoints [ 0 ] ) ; else err = snd_usbmidi_create_endpoints ( umidi , endpoints ) ; if ( err < 0 ) { <S2SV_StartBug> snd_usbmidi_free ( umidi ) ; <S2SV_EndBug> return err ; } usb_autopm_get_interface_no_resume ( umidi -> iface ) ; list_add_tail ( & umidi -> list , midi_list ) ; return 0 ; }",0 ) { <S2SV_ModEnd> return err ;
355,"static int adjust_insn_aux_data ( struct bpf_verifier_env * env , u32 prog_len , u32 off , u32 cnt ) { <S2SV_StartBug> struct bpf_insn_aux_data * new_data , * old_data = env -> insn_aux_data ; <S2SV_EndBug> if ( cnt == 1 ) return 0 ; new_data = vzalloc ( sizeof ( struct bpf_insn_aux_data ) * prog_len ) ; if ( ! new_data ) return - ENOMEM ; memcpy ( new_data , old_data , sizeof ( struct bpf_insn_aux_data ) * off ) ; memcpy ( new_data + off + cnt - 1 , old_data + off , sizeof ( struct bpf_insn_aux_data ) * ( prog_len - off - cnt + 1 ) ) ; <S2SV_StartBug> env -> insn_aux_data = new_data ; <S2SV_EndBug> vfree ( old_data ) ; return 0 ; }",env -> insn_aux_data ; int i <S2SV_ModStart> ) ) ; for ( i = off ; i < off + cnt - 1 ; i ++ ) new_data [ i ] . seen = true ;
356,"int _fep_open_control_socket ( Fep * fep ) { struct sockaddr_un sun ; char * path ; int fd ; ssize_t sun_len ; fd = socket ( AF_UNIX , SOCK_STREAM , 0 ) ; if ( fd < 0 ) { perror ( ""socket"" ) ; return - 1 ; } path = create_socket_name ( ""fep-XXXXXX/control"" ) ; if ( strlen ( path ) + 1 >= sizeof ( sun . sun_path ) ) { fep_log ( FEP_LOG_LEVEL_WARNING , ""unix<S2SV_blank>domain<S2SV_blank>socket<S2SV_blank>path<S2SV_blank>too<S2SV_blank>long:<S2SV_blank>%d<S2SV_blank>+<S2SV_blank>1<S2SV_blank>>=<S2SV_blank>%d"" , strlen ( path ) , sizeof ( sun . sun_path ) ) ; free ( path ) ; return - 1 ; } memset ( & sun , 0 , sizeof ( sun ) ) ; sun . sun_family = AF_UNIX ; <S2SV_StartBug> # ifdef __linux__ <S2SV_EndBug> <S2SV_StartBug> sun . sun_path [ 0 ] = '\\0' ; <S2SV_EndBug> memcpy ( sun . sun_path + 1 , path , strlen ( path ) ) ; <S2SV_StartBug> sun_len = offsetof ( struct sockaddr_un , sun_path ) + strlen ( path ) + 1 ; <S2SV_EndBug> remove_control_socket ( path ) ; # else memcpy ( sun . sun_path , path , strlen ( path ) ) ; sun_len = sizeof ( struct sockaddr_un ) ; # endif if ( bind ( fd , ( const struct sockaddr * ) & sun , sun_len ) < 0 ) { perror ( ""bind"" ) ; free ( path ) ; close ( fd ) ; return - 1 ; } if ( listen ( fd , 5 ) < 0 ) { perror ( ""listen"" ) ; free ( path ) ; close ( fd ) ; return - 1 ; } fep -> server = fd ; fep -> control_socket_path = path ; return 0 ; }","= AF_UNIX ; memcpy ( <S2SV_ModEnd> sun . sun_path <S2SV_ModStart> sun . sun_path <S2SV_ModEnd> , path , <S2SV_ModStart> ; sun_len = sizeof <S2SV_ModEnd> ( struct sockaddr_un <S2SV_ModStart> ( struct sockaddr_un ) ; <S2SV_ModEnd> if ( bind"
357,"struct crypto_template * crypto_lookup_template ( const char * name ) { <S2SV_StartBug> return try_then_request_module ( __crypto_lookup_template ( name ) , ""%s"" , <S2SV_EndBug> name ) ; }","name ) , ""crypto-%s"" <S2SV_ModEnd> , name )"
358,"static struct net_device * _init_airo_card ( unsigned short irq , int port , int is_pcmcia , struct pci_dev * pci , struct device * dmdev ) { struct net_device * dev ; struct airo_info * ai ; int i , rc ; CapabilityRid cap_rid ; dev = alloc_netdev ( sizeof ( * ai ) , """" , ether_setup ) ; if ( ! dev ) { airo_print_err ( """" , ""Couldn\'t<S2SV_blank>alloc_etherdev"" ) ; return NULL ; } ai = dev -> ml_priv = netdev_priv ( dev ) ; ai -> wifidev = NULL ; ai -> flags = 1 << FLAG_RADIO_DOWN ; ai -> jobs = 0 ; ai -> dev = dev ; if ( pci && ( pci -> device == 0x5000 || pci -> device == 0xa504 ) ) { airo_print_dbg ( """" , ""Found<S2SV_blank>an<S2SV_blank>MPI350<S2SV_blank>card"" ) ; set_bit ( FLAG_MPI , & ai -> flags ) ; } spin_lock_init ( & ai -> aux_lock ) ; sema_init ( & ai -> sem , 1 ) ; ai -> config . len = 0 ; ai -> pci = pci ; init_waitqueue_head ( & ai -> thr_wait ) ; ai -> tfm = NULL ; add_airo_dev ( ai ) ; if ( airo_networks_allocate ( ai ) ) goto err_out_free ; airo_networks_initialize ( ai ) ; skb_queue_head_init ( & ai -> txq ) ; if ( test_bit ( FLAG_MPI , & ai -> flags ) ) dev -> netdev_ops = & mpi_netdev_ops ; else dev -> netdev_ops = & airo_netdev_ops ; dev -> wireless_handlers = & airo_handler_def ; ai -> wireless_data . spy_data = & ai -> spy_data ; dev -> wireless_data = & ai -> wireless_data ; dev -> irq = irq ; dev -> base_addr = port ; <S2SV_StartBug> SET_NETDEV_DEV ( dev , dmdev ) ; <S2SV_EndBug> reset_card ( dev , 1 ) ; msleep ( 400 ) ; if ( ! is_pcmcia ) { if ( ! request_region ( dev -> base_addr , 64 , DRV_NAME ) ) { rc = - EBUSY ; airo_print_err ( dev -> name , ""Couldn\'t<S2SV_blank>request<S2SV_blank>region"" ) ; goto err_out_nets ; } } if ( test_bit ( FLAG_MPI , & ai -> flags ) ) { if ( mpi_map_card ( ai , pci ) ) { airo_print_err ( """" , ""Could<S2SV_blank>not<S2SV_blank>map<S2SV_blank>memory"" ) ; goto err_out_res ; } } if ( probe ) { if ( setup_card ( ai , dev -> dev_addr , 1 ) != SUCCESS ) { airo_print_err ( dev -> name , ""MAC<S2SV_blank>could<S2SV_blank>not<S2SV_blank>be<S2SV_blank>enabled"" ) ; rc = - EIO ; goto err_out_map ; } } else if ( ! test_bit ( FLAG_MPI , & ai -> flags ) ) { ai -> bap_read = fast_bap_read ; set_bit ( FLAG_FLASHING , & ai -> flags ) ; } strcpy ( dev -> name , ""eth%d"" ) ; rc = register_netdev ( dev ) ; if ( rc ) { airo_print_err ( dev -> name , ""Couldn\'t<S2SV_blank>register_netdev"" ) ; goto err_out_map ; } ai -> wifidev = init_wifidev ( ai , dev ) ; if ( ! ai -> wifidev ) goto err_out_reg ; rc = readCapabilityRid ( ai , & cap_rid , 1 ) ; if ( rc != SUCCESS ) { rc = - EIO ; goto err_out_wifi ; } ai -> wep_capable = ( cap_rid . softCap & cpu_to_le16 ( 0x02 ) ) ? 1 : 0 ; ai -> max_wep_idx = ( cap_rid . softCap & cpu_to_le16 ( 0x80 ) ) ? 3 : 0 ; airo_print_info ( dev -> name , ""Firmware<S2SV_blank>version<S2SV_blank>%x.%x.%02d"" , ( ( le16_to_cpu ( cap_rid . softVer ) >> 8 ) & 0xF ) , ( le16_to_cpu ( cap_rid . softVer ) & 0xFF ) , le16_to_cpu ( cap_rid . softSubVer ) ) ; if ( le16_to_cpu ( cap_rid . softVer ) > 0x530 || ( le16_to_cpu ( cap_rid . softVer ) == 0x530 && le16_to_cpu ( cap_rid . softSubVer ) >= 17 ) ) { airo_print_info ( ai -> dev -> name , ""WPA<S2SV_blank>supported."" ) ; set_bit ( FLAG_WPA_CAPABLE , & ai -> flags ) ; ai -> bssListFirst = RID_WPA_BSSLISTFIRST ; ai -> bssListNext = RID_WPA_BSSLISTNEXT ; ai -> bssListRidLen = sizeof ( BSSListRid ) ; } else { airo_print_info ( ai -> dev -> name , ""WPA<S2SV_blank>unsupported<S2SV_blank>with<S2SV_blank>firmware<S2SV_blank>"" ""versions<S2SV_blank>older<S2SV_blank>than<S2SV_blank>5.30.17."" ) ; ai -> bssListFirst = RID_BSSLISTFIRST ; ai -> bssListNext = RID_BSSLISTNEXT ; ai -> bssListRidLen = sizeof ( BSSListRid ) - sizeof ( BSSListRidExtra ) ; } set_bit ( FLAG_REGISTERED , & ai -> flags ) ; airo_print_info ( dev -> name , ""MAC<S2SV_blank>enabled<S2SV_blank>%pM"" , dev -> dev_addr ) ; if ( probe && ! test_bit ( FLAG_MPI , & ai -> flags ) ) for ( i = 0 ; i < MAX_FIDS ; i ++ ) ai -> fids [ i ] = transmit_allocate ( ai , AIRO_DEF_MTU , i >= MAX_FIDS / 2 ) ; if ( setup_proc_entry ( dev , dev -> ml_priv ) < 0 ) goto err_out_wifi ; return dev ; err_out_wifi : unregister_netdev ( ai -> wifidev ) ; free_netdev ( ai -> wifidev ) ; err_out_reg : unregister_netdev ( dev ) ; err_out_map : if ( test_bit ( FLAG_MPI , & ai -> flags ) && pci ) { pci_free_consistent ( pci , PCI_SHARED_LEN , ai -> shared , ai -> shared_dma ) ; iounmap ( ai -> pciaux ) ; iounmap ( ai -> pcimem ) ; mpi_unmap_card ( ai -> pci ) ; } err_out_res : if ( ! is_pcmcia ) release_region ( dev -> base_addr , 64 ) ; err_out_nets : airo_networks_free ( ai ) ; err_out_free : del_airo_dev ( ai ) ; free_netdev ( dev ) ; return NULL ; }",= port ; dev -> priv_flags &= ~ IFF_TX_SKB_SHARING ;
359,"int yyparse ( void * yyscanner , YR_COMPILER * compiler ) { int yychar ; YY_INITIAL_VALUE ( static YYSTYPE yyval_default ; ) YYSTYPE yylval YY_INITIAL_VALUE ( = yyval_default ) ; int yynerrs ; int yystate ; int yyerrstatus ; yytype_int16 yyssa [ YYINITDEPTH ] ; yytype_int16 * yyss ; yytype_int16 * yyssp ; YYSTYPE yyvsa [ YYINITDEPTH ] ; YYSTYPE * yyvs ; YYSTYPE * yyvsp ; YYSIZE_T yystacksize ; int yyn ; int yyresult ; int yytoken = 0 ; YYSTYPE yyval ; # if YYERROR_VERBOSE char yymsgbuf [ 128 ] ; char * yymsg = yymsgbuf ; YYSIZE_T yymsg_alloc = sizeof yymsgbuf ; # endif # define YYPOPSTACK ( N ) ( yyvsp -= ( N ) , yyssp -= ( N ) ) int yylen = 0 ; yyssp = yyss = yyssa ; yyvsp = yyvs = yyvsa ; yystacksize = YYINITDEPTH ; YYDPRINTF ( ( stderr , ""Starting<S2SV_blank>parse\\n"" ) ) ; yystate = 0 ; yyerrstatus = 0 ; yynerrs = 0 ; yychar = YYEMPTY ; goto yysetstate ; yynewstate : yyssp ++ ; yysetstate : * yyssp = yystate ; if ( yyss + yystacksize - 1 <= yyssp ) { YYSIZE_T yysize = yyssp - yyss + 1 ; # ifdef yyoverflow { YYSTYPE * yyvs1 = yyvs ; yytype_int16 * yyss1 = yyss ; yyoverflow ( YY_ ( ""memory<S2SV_blank>exhausted"" ) , & yyss1 , yysize * sizeof ( * yyssp ) , & yyvs1 , yysize * sizeof ( * yyvsp ) , & yystacksize ) ; yyss = yyss1 ; yyvs = yyvs1 ; } # else # ifndef YYSTACK_RELOCATE goto yyexhaustedlab ; # else if ( YYMAXDEPTH <= yystacksize ) goto yyexhaustedlab ; yystacksize *= 2 ; if ( YYMAXDEPTH < yystacksize ) yystacksize = YYMAXDEPTH ; { yytype_int16 * yyss1 = yyss ; union yyalloc * yyptr = ( union yyalloc * ) YYSTACK_ALLOC ( YYSTACK_BYTES ( yystacksize ) ) ; if ( ! yyptr ) goto yyexhaustedlab ; YYSTACK_RELOCATE ( yyss_alloc , yyss ) ; YYSTACK_RELOCATE ( yyvs_alloc , yyvs ) ; # undef YYSTACK_RELOCATE if ( yyss1 != yyssa ) YYSTACK_FREE ( yyss1 ) ; } # endif # endif yyssp = yyss + yysize - 1 ; yyvsp = yyvs + yysize - 1 ; YYDPRINTF ( ( stderr , ""Stack<S2SV_blank>size<S2SV_blank>increased<S2SV_blank>to<S2SV_blank>%lu\\n"" , ( unsigned long int ) yystacksize ) ) ; if ( yyss + yystacksize - 1 <= yyssp ) YYABORT ; } YYDPRINTF ( ( stderr , ""Entering<S2SV_blank>state<S2SV_blank>%d\\n"" , yystate ) ) ; if ( yystate == YYFINAL ) YYACCEPT ; goto yybackup ; yybackup : yyn = yypact [ yystate ] ; if ( yypact_value_is_default ( yyn ) ) goto yydefault ; if ( yychar == YYEMPTY ) { YYDPRINTF ( ( stderr , ""Reading<S2SV_blank>a<S2SV_blank>token:<S2SV_blank>"" ) ) ; yychar = yylex ( & yylval , yyscanner , compiler ) ; } if ( yychar <= YYEOF ) { yychar = yytoken = YYEOF ; YYDPRINTF ( ( stderr , ""Now<S2SV_blank>at<S2SV_blank>end<S2SV_blank>of<S2SV_blank>input.\\n"" ) ) ; } else { yytoken = YYTRANSLATE ( yychar ) ; YY_SYMBOL_PRINT ( ""Next<S2SV_blank>token<S2SV_blank>is"" , yytoken , & yylval , & yylloc ) ; } yyn += yytoken ; if ( yyn < 0 || YYLAST < yyn || yycheck [ yyn ] != yytoken ) goto yydefault ; yyn = yytable [ yyn ] ; if ( yyn <= 0 ) { if ( yytable_value_is_error ( yyn ) ) goto yyerrlab ; yyn = - yyn ; goto yyreduce ; } if ( yyerrstatus ) yyerrstatus -- ; YY_SYMBOL_PRINT ( ""Shifting"" , yytoken , & yylval , & yylloc ) ; yychar = YYEMPTY ; yystate = yyn ; YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN * ++ yyvsp = yylval ; YY_IGNORE_MAYBE_UNINITIALIZED_END goto yynewstate ; yydefault : yyn = yydefact [ yystate ] ; if ( yyn == 0 ) goto yyerrlab ; goto yyreduce ; yyreduce : yylen = yyr2 [ yyn ] ; yyval = yyvsp [ 1 - yylen ] ; YY_REDUCE_PRINT ( yyn ) ; switch ( yyn ) { case 8 : # line 230 ""grammar.y"" { int result = yr_parser_reduce_import ( yyscanner , ( yyvsp [ 0 ] . sized_string ) ) ; yr_free ( ( yyvsp [ 0 ] . sized_string ) ) ; ERROR_IF ( result != ERROR_SUCCESS ) ; } # line 1661 ""grammar.c"" break ; case 9 : # line 242 ""grammar.y"" { YR_RULE * rule = yr_parser_reduce_rule_declaration_phase_1 ( yyscanner , ( int32_t ) ( yyvsp [ - 2 ] . integer ) , ( yyvsp [ 0 ] . c_string ) ) ; ERROR_IF ( rule == NULL ) ; ( yyval . rule ) = rule ; } # line 1674 ""grammar.c"" break ; case 10 : # line 251 ""grammar.y"" { YR_RULE * rule = ( yyvsp [ - 4 ] . rule ) ; rule -> tags = ( yyvsp [ - 3 ] . c_string ) ; rule -> metas = ( yyvsp [ - 1 ] . meta ) ; rule -> strings = ( yyvsp [ 0 ] . string ) ; } # line 1686 ""grammar.c"" break ; case 11 : # line 259 ""grammar.y"" { YR_RULE * rule = ( yyvsp [ - 7 ] . rule ) ; compiler -> last_result = yr_parser_reduce_rule_declaration_phase_2 ( yyscanner , rule ) ; yr_free ( ( yyvsp [ - 8 ] . c_string ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } # line 1701 ""grammar.c"" break ; case 12 : # line 274 ""grammar.y"" { ( yyval . meta ) = NULL ; } # line 1709 ""grammar.c"" break ; case 13 : # line 278 ""grammar.y"" { YR_META null_meta ; memset ( & null_meta , 0xFF , sizeof ( YR_META ) ) ; null_meta . type = META_TYPE_NULL ; compiler -> last_result = yr_arena_write_data ( compiler -> metas_arena , & null_meta , sizeof ( YR_META ) , NULL ) ; ( yyval . meta ) = ( yyvsp [ 0 ] . meta ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } # line 1736 ""grammar.c"" break ; case 14 : # line 305 ""grammar.y"" { ( yyval . string ) = NULL ; } # line 1744 ""grammar.c"" break ; case 15 : # line 309 ""grammar.y"" { YR_STRING null_string ; memset ( & null_string , 0xFF , sizeof ( YR_STRING ) ) ; null_string . g_flags = STRING_GFLAGS_NULL ; compiler -> last_result = yr_arena_write_data ( compiler -> strings_arena , & null_string , sizeof ( YR_STRING ) , NULL ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . string ) = ( yyvsp [ 0 ] . string ) ; } # line 1771 ""grammar.c"" break ; case 17 : # line 340 ""grammar.y"" { ( yyval . integer ) = 0 ; } # line 1777 ""grammar.c"" break ; case 18 : # line 341 ""grammar.y"" { ( yyval . integer ) = ( yyvsp [ - 1 ] . integer ) | ( yyvsp [ 0 ] . integer ) ; } # line 1783 ""grammar.c"" break ; case 19 : # line 346 ""grammar.y"" { ( yyval . integer ) = RULE_GFLAGS_PRIVATE ; } # line 1789 ""grammar.c"" break ; case 20 : # line 347 ""grammar.y"" { ( yyval . integer ) = RULE_GFLAGS_GLOBAL ; } # line 1795 ""grammar.c"" break ; case 21 : # line 353 ""grammar.y"" { ( yyval . c_string ) = NULL ; } # line 1803 ""grammar.c"" break ; case 22 : # line 357 ""grammar.y"" { compiler -> last_result = yr_arena_write_string ( yyget_extra ( yyscanner ) -> sz_arena , """" , NULL ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . c_string ) = ( yyvsp [ 0 ] . c_string ) ; } # line 1821 ""grammar.c"" break ; case 23 : # line 375 ""grammar.y"" { char * identifier ; compiler -> last_result = yr_arena_write_string ( yyget_extra ( yyscanner ) -> sz_arena , ( yyvsp [ 0 ] . c_string ) , & identifier ) ; yr_free ( ( yyvsp [ 0 ] . c_string ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . c_string ) = identifier ; } # line 1838 ""grammar.c"" break ; case 24 : # line 388 ""grammar.y"" { char * tag_name = ( yyvsp [ - 1 ] . c_string ) ; size_t tag_length = tag_name != NULL ? strlen ( tag_name ) : 0 ; while ( tag_length > 0 ) { if ( strcmp ( tag_name , ( yyvsp [ 0 ] . c_string ) ) == 0 ) { yr_compiler_set_error_extra_info ( compiler , tag_name ) ; compiler -> last_result = ERROR_DUPLICATED_TAG_IDENTIFIER ; break ; } tag_name = ( char * ) yr_arena_next_address ( yyget_extra ( yyscanner ) -> sz_arena , tag_name , tag_length + 1 ) ; tag_length = tag_name != NULL ? strlen ( tag_name ) : 0 ; } if ( compiler -> last_result == ERROR_SUCCESS ) compiler -> last_result = yr_arena_write_string ( yyget_extra ( yyscanner ) -> sz_arena , ( yyvsp [ 0 ] . c_string ) , NULL ) ; yr_free ( ( yyvsp [ 0 ] . c_string ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . c_string ) = ( yyvsp [ - 1 ] . c_string ) ; } # line 1874 ""grammar.c"" break ; case 25 : # line 424 ""grammar.y"" { ( yyval . meta ) = ( yyvsp [ 0 ] . meta ) ; } # line 1880 ""grammar.c"" break ; case 26 : # line 425 ""grammar.y"" { ( yyval . meta ) = ( yyvsp [ - 1 ] . meta ) ; } # line 1886 ""grammar.c"" break ; case 27 : # line 431 ""grammar.y"" { SIZED_STRING * sized_string = ( yyvsp [ 0 ] . sized_string ) ; ( yyval . meta ) = yr_parser_reduce_meta_declaration ( yyscanner , META_TYPE_STRING , ( yyvsp [ - 2 ] . c_string ) , sized_string -> c_string , 0 ) ; yr_free ( ( yyvsp [ - 2 ] . c_string ) ) ; yr_free ( ( yyvsp [ 0 ] . sized_string ) ) ; ERROR_IF ( ( yyval . meta ) == NULL ) ; } # line 1906 ""grammar.c"" break ; case 28 : # line 447 ""grammar.y"" { ( yyval . meta ) = yr_parser_reduce_meta_declaration ( yyscanner , META_TYPE_INTEGER , ( yyvsp [ - 2 ] . c_string ) , NULL , ( yyvsp [ 0 ] . integer ) ) ; yr_free ( ( yyvsp [ - 2 ] . c_string ) ) ; ERROR_IF ( ( yyval . meta ) == NULL ) ; } # line 1923 ""grammar.c"" break ; case 29 : # line 460 ""grammar.y"" { ( yyval . meta ) = yr_parser_reduce_meta_declaration ( yyscanner , META_TYPE_INTEGER , ( yyvsp [ - 3 ] . c_string ) , NULL , - ( yyvsp [ 0 ] . integer ) ) ; yr_free ( ( yyvsp [ - 3 ] . c_string ) ) ; ERROR_IF ( ( yyval . meta ) == NULL ) ; } # line 1940 ""grammar.c"" break ; case 30 : # line 473 ""grammar.y"" { ( yyval . meta ) = yr_parser_reduce_meta_declaration ( yyscanner , META_TYPE_BOOLEAN , ( yyvsp [ - 2 ] . c_string ) , NULL , TRUE ) ; yr_free ( ( yyvsp [ - 2 ] . c_string ) ) ; ERROR_IF ( ( yyval . meta ) == NULL ) ; } # line 1957 ""grammar.c"" break ; case 31 : # line 486 ""grammar.y"" { ( yyval . meta ) = yr_parser_reduce_meta_declaration ( yyscanner , META_TYPE_BOOLEAN , ( yyvsp [ - 2 ] . c_string ) , NULL , FALSE ) ; yr_free ( ( yyvsp [ - 2 ] . c_string ) ) ; ERROR_IF ( ( yyval . meta ) == NULL ) ; } # line 1974 ""grammar.c"" break ; case 32 : # line 502 ""grammar.y"" { ( yyval . string ) = ( yyvsp [ 0 ] . string ) ; } # line 1980 ""grammar.c"" break ; case 33 : # line 503 ""grammar.y"" { ( yyval . string ) = ( yyvsp [ - 1 ] . string ) ; } # line 1986 ""grammar.c"" break ; case 34 : # line 509 ""grammar.y"" { compiler -> error_line = yyget_lineno ( yyscanner ) ; } # line 1994 ""grammar.c"" break ; case 35 : # line 513 ""grammar.y"" { ( yyval . string ) = yr_parser_reduce_string_declaration ( yyscanner , ( int32_t ) ( yyvsp [ 0 ] . integer ) , ( yyvsp [ - 4 ] . c_string ) , ( yyvsp [ - 1 ] . sized_string ) ) ; yr_free ( ( yyvsp [ - 4 ] . c_string ) ) ; yr_free ( ( yyvsp [ - 1 ] . sized_string ) ) ; ERROR_IF ( ( yyval . string ) == NULL ) ; compiler -> error_line = 0 ; } # line 2009 ""grammar.c"" break ; case 36 : # line 524 ""grammar.y"" { compiler -> error_line = yyget_lineno ( yyscanner ) ; } # line 2017 ""grammar.c"" break ; case 37 : # line 528 ""grammar.y"" { ( yyval . string ) = yr_parser_reduce_string_declaration ( yyscanner , ( int32_t ) ( yyvsp [ 0 ] . integer ) | STRING_GFLAGS_REGEXP , ( yyvsp [ - 4 ] . c_string ) , ( yyvsp [ - 1 ] . sized_string ) ) ; yr_free ( ( yyvsp [ - 4 ] . c_string ) ) ; yr_free ( ( yyvsp [ - 1 ] . sized_string ) ) ; ERROR_IF ( ( yyval . string ) == NULL ) ; compiler -> error_line = 0 ; } # line 2033 ""grammar.c"" break ; case 38 : # line 540 ""grammar.y"" { ( yyval . string ) = yr_parser_reduce_string_declaration ( yyscanner , STRING_GFLAGS_HEXADECIMAL , ( yyvsp [ - 2 ] . c_string ) , ( yyvsp [ 0 ] . sized_string ) ) ; yr_free ( ( yyvsp [ - 2 ] . c_string ) ) ; yr_free ( ( yyvsp [ 0 ] . sized_string ) ) ; ERROR_IF ( ( yyval . string ) == NULL ) ; } # line 2047 ""grammar.c"" break ; case 39 : # line 553 ""grammar.y"" { ( yyval . integer ) = 0 ; } # line 2053 ""grammar.c"" break ; case 40 : # line 554 ""grammar.y"" { ( yyval . integer ) = ( yyvsp [ - 1 ] . integer ) | ( yyvsp [ 0 ] . integer ) ; } # line 2059 ""grammar.c"" break ; case 41 : # line 559 ""grammar.y"" { ( yyval . integer ) = STRING_GFLAGS_WIDE ; } # line 2065 ""grammar.c"" break ; case 42 : # line 560 ""grammar.y"" { ( yyval . integer ) = STRING_GFLAGS_ASCII ; } # line 2071 ""grammar.c"" break ; case 43 : # line 561 ""grammar.y"" { ( yyval . integer ) = STRING_GFLAGS_NO_CASE ; } # line 2077 ""grammar.c"" break ; case 44 : # line 562 ""grammar.y"" { ( yyval . integer ) = STRING_GFLAGS_FULL_WORD ; } # line 2083 ""grammar.c"" break ; case 45 : # line 568 ""grammar.y"" { int var_index = yr_parser_lookup_loop_variable ( yyscanner , ( yyvsp [ 0 ] . c_string ) ) ; if ( var_index >= 0 ) { compiler -> last_result = yr_parser_emit_with_arg ( yyscanner , OP_PUSH_M , LOOP_LOCAL_VARS * var_index , NULL , NULL ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = UNDEFINED ; ( yyval . expression ) . identifier = compiler -> loop_identifier [ var_index ] ; } else { YR_OBJECT * object = ( YR_OBJECT * ) yr_hash_table_lookup ( compiler -> objects_table , ( yyvsp [ 0 ] . c_string ) , NULL ) ; if ( object == NULL ) { char * ns = compiler -> current_namespace -> name ; object = ( YR_OBJECT * ) yr_hash_table_lookup ( compiler -> objects_table , ( yyvsp [ 0 ] . c_string ) , ns ) ; } if ( object != NULL ) { char * id ; compiler -> last_result = yr_arena_write_string ( compiler -> sz_arena , ( yyvsp [ 0 ] . c_string ) , & id ) ; if ( compiler -> last_result == ERROR_SUCCESS ) compiler -> last_result = yr_parser_emit_with_arg_reloc ( yyscanner , OP_OBJ_LOAD , id , NULL , NULL ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_OBJECT ; ( yyval . expression ) . value . object = object ; ( yyval . expression ) . identifier = object -> identifier ; } else { YR_RULE * rule = ( YR_RULE * ) yr_hash_table_lookup ( compiler -> rules_table , ( yyvsp [ 0 ] . c_string ) , compiler -> current_namespace -> name ) ; if ( rule != NULL ) { compiler -> last_result = yr_parser_emit_with_arg_reloc ( yyscanner , OP_PUSH_RULE , rule , NULL , NULL ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; ( yyval . expression ) . value . integer = UNDEFINED ; ( yyval . expression ) . identifier = rule -> identifier ; } else { yr_compiler_set_error_extra_info ( compiler , ( yyvsp [ 0 ] . c_string ) ) ; compiler -> last_result = ERROR_UNDEFINED_IDENTIFIER ; } } } yr_free ( ( yyvsp [ 0 ] . c_string ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } # line 2172 ""grammar.c"" break ; case 46 : # line 653 ""grammar.y"" { YR_OBJECT * field = NULL ; if ( ( yyvsp [ - 2 ] . expression ) . type == EXPRESSION_TYPE_OBJECT && ( yyvsp [ - 2 ] . expression ) . value . object -> type == OBJECT_TYPE_STRUCTURE ) { field = yr_object_lookup_field ( ( yyvsp [ - 2 ] . expression ) . value . object , ( yyvsp [ 0 ] . c_string ) ) ; if ( field != NULL ) { char * ident ; compiler -> last_result = yr_arena_write_string ( compiler -> sz_arena , ( yyvsp [ 0 ] . c_string ) , & ident ) ; if ( compiler -> last_result == ERROR_SUCCESS ) compiler -> last_result = yr_parser_emit_with_arg_reloc ( yyscanner , OP_OBJ_FIELD , ident , NULL , NULL ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_OBJECT ; ( yyval . expression ) . value . object = field ; ( yyval . expression ) . identifier = field -> identifier ; } else { yr_compiler_set_error_extra_info ( compiler , ( yyvsp [ 0 ] . c_string ) ) ; compiler -> last_result = ERROR_INVALID_FIELD_NAME ; } } else { yr_compiler_set_error_extra_info ( compiler , ( yyvsp [ - 2 ] . expression ) . identifier ) ; compiler -> last_result = ERROR_NOT_A_STRUCTURE ; } yr_free ( ( yyvsp [ 0 ] . c_string ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } # line 2222 ""grammar.c"" break ; case 47 : # line 699 ""grammar.y"" { YR_OBJECT_ARRAY * array ; YR_OBJECT_DICTIONARY * dict ; if ( ( yyvsp [ - 3 ] . expression ) . type == EXPRESSION_TYPE_OBJECT && ( yyvsp [ - 3 ] . expression ) . value . object -> type == OBJECT_TYPE_ARRAY ) { if ( ( yyvsp [ - 1 ] . expression ) . type != EXPRESSION_TYPE_INTEGER ) { yr_compiler_set_error_extra_info ( compiler , ""array<S2SV_blank>indexes<S2SV_blank>must<S2SV_blank>be<S2SV_blank>of<S2SV_blank>integer<S2SV_blank>type"" ) ; compiler -> last_result = ERROR_WRONG_TYPE ; } ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; compiler -> last_result = yr_parser_emit ( yyscanner , OP_INDEX_ARRAY , NULL ) ; array = ( YR_OBJECT_ARRAY * ) ( yyvsp [ - 3 ] . expression ) . value . object ; ( yyval . expression ) . type = EXPRESSION_TYPE_OBJECT ; ( yyval . expression ) . value . object = array -> prototype_item ; ( yyval . expression ) . identifier = array -> identifier ; } else if ( ( yyvsp [ - 3 ] . expression ) . type == EXPRESSION_TYPE_OBJECT && ( yyvsp [ - 3 ] . expression ) . value . object -> type == OBJECT_TYPE_DICTIONARY ) { if ( ( yyvsp [ - 1 ] . expression ) . type != EXPRESSION_TYPE_STRING ) { yr_compiler_set_error_extra_info ( compiler , ""dictionary<S2SV_blank>keys<S2SV_blank>must<S2SV_blank>be<S2SV_blank>of<S2SV_blank>string<S2SV_blank>type"" ) ; compiler -> last_result = ERROR_WRONG_TYPE ; } ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; compiler -> last_result = yr_parser_emit ( yyscanner , OP_LOOKUP_DICT , NULL ) ; dict = ( YR_OBJECT_DICTIONARY * ) ( yyvsp [ - 3 ] . expression ) . value . object ; ( yyval . expression ) . type = EXPRESSION_TYPE_OBJECT ; ( yyval . expression ) . value . object = dict -> prototype_item ; ( yyval . expression ) . identifier = dict -> identifier ; } else { yr_compiler_set_error_extra_info ( compiler , ( yyvsp [ - 3 ] . expression ) . identifier ) ; compiler -> last_result = ERROR_NOT_INDEXABLE ; } ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } # line 2283 ""grammar.c"" break ; case 48 : # line 757 ""grammar.y"" { YR_OBJECT_FUNCTION * function ; char * args_fmt ; if ( ( yyvsp [ - 3 ] . expression ) . type == EXPRESSION_TYPE_OBJECT && ( yyvsp [ - 3 ] . expression ) . value . object -> type == OBJECT_TYPE_FUNCTION ) { compiler -> last_result = yr_parser_check_types ( compiler , ( YR_OBJECT_FUNCTION * ) ( yyvsp [ - 3 ] . expression ) . value . object , ( yyvsp [ - 1 ] . c_string ) ) ; if ( compiler -> last_result == ERROR_SUCCESS ) compiler -> last_result = yr_arena_write_string ( compiler -> sz_arena , ( yyvsp [ - 1 ] . c_string ) , & args_fmt ) ; if ( compiler -> last_result == ERROR_SUCCESS ) compiler -> last_result = yr_parser_emit_with_arg_reloc ( yyscanner , OP_CALL , args_fmt , NULL , NULL ) ; function = ( YR_OBJECT_FUNCTION * ) ( yyvsp [ - 3 ] . expression ) . value . object ; ( yyval . expression ) . type = EXPRESSION_TYPE_OBJECT ; ( yyval . expression ) . value . object = function -> return_obj ; ( yyval . expression ) . identifier = function -> identifier ; } else { yr_compiler_set_error_extra_info ( compiler , ( yyvsp [ - 3 ] . expression ) . identifier ) ; compiler -> last_result = ERROR_NOT_A_FUNCTION ; } yr_free ( ( yyvsp [ - 1 ] . c_string ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } # line 2328 ""grammar.c"" break ; case 49 : # line 801 ""grammar.y"" { ( yyval . c_string ) = yr_strdup ( """" ) ; } # line 2334 ""grammar.c"" break ; case 50 : # line 802 ""grammar.y"" { ( yyval . c_string ) = ( yyvsp [ 0 ] . c_string ) ; } # line 2340 ""grammar.c"" break ; case 51 : # line 807 ""grammar.y"" { ( yyval . c_string ) = ( char * ) yr_malloc ( MAX_FUNCTION_ARGS + 1 ) ; switch ( ( yyvsp [ 0 ] . expression ) . type ) { case EXPRESSION_TYPE_INTEGER : strlcpy ( ( yyval . c_string ) , ""i"" , MAX_FUNCTION_ARGS ) ; break ; case EXPRESSION_TYPE_FLOAT : strlcpy ( ( yyval . c_string ) , ""f"" , MAX_FUNCTION_ARGS ) ; break ; case EXPRESSION_TYPE_BOOLEAN : strlcpy ( ( yyval . c_string ) , ""b"" , MAX_FUNCTION_ARGS ) ; break ; case EXPRESSION_TYPE_STRING : strlcpy ( ( yyval . c_string ) , ""s"" , MAX_FUNCTION_ARGS ) ; break ; case EXPRESSION_TYPE_REGEXP : strlcpy ( ( yyval . c_string ) , ""r"" , MAX_FUNCTION_ARGS ) ; break ; } ERROR_IF ( ( yyval . c_string ) == NULL ) ; } # line 2369 ""grammar.c"" break ; case 52 : # line 832 ""grammar.y"" { if ( strlen ( ( yyvsp [ - 2 ] . c_string ) ) == MAX_FUNCTION_ARGS ) { compiler -> last_result = ERROR_TOO_MANY_ARGUMENTS ; } else { switch ( ( yyvsp [ 0 ] . expression ) . type ) { case EXPRESSION_TYPE_INTEGER : strlcat ( ( yyvsp [ - 2 ] . c_string ) , ""i"" , MAX_FUNCTION_ARGS ) ; break ; case EXPRESSION_TYPE_FLOAT : strlcat ( ( yyvsp [ - 2 ] . c_string ) , ""f"" , MAX_FUNCTION_ARGS ) ; break ; case EXPRESSION_TYPE_BOOLEAN : strlcat ( ( yyvsp [ - 2 ] . c_string ) , ""b"" , MAX_FUNCTION_ARGS ) ; break ; case EXPRESSION_TYPE_STRING : strlcat ( ( yyvsp [ - 2 ] . c_string ) , ""s"" , MAX_FUNCTION_ARGS ) ; break ; case EXPRESSION_TYPE_REGEXP : strlcat ( ( yyvsp [ - 2 ] . c_string ) , ""r"" , MAX_FUNCTION_ARGS ) ; break ; } } ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . c_string ) = ( yyvsp [ - 2 ] . c_string ) ; } # line 2405 ""grammar.c"" break ; case 53 : # line 868 ""grammar.y"" { SIZED_STRING * sized_string = ( yyvsp [ 0 ] . sized_string ) ; RE * re ; RE_ERROR error ; int re_flags = 0 ; if ( sized_string -> flags & SIZED_STRING_FLAGS_NO_CASE ) re_flags |= RE_FLAGS_NO_CASE ; if ( sized_string -> flags & SIZED_STRING_FLAGS_DOT_ALL ) re_flags |= RE_FLAGS_DOT_ALL ; compiler -> last_result = yr_re_compile ( sized_string -> c_string , re_flags , compiler -> re_code_arena , & re , & error ) ; yr_free ( ( yyvsp [ 0 ] . sized_string ) ) ; if ( compiler -> last_result == ERROR_INVALID_REGULAR_EXPRESSION ) yr_compiler_set_error_extra_info ( compiler , error . message ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; if ( compiler -> last_result == ERROR_SUCCESS ) compiler -> last_result = yr_parser_emit_with_arg_reloc ( yyscanner , OP_PUSH , re -> root_node -> forward_code , NULL , NULL ) ; yr_re_destroy ( re ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_REGEXP ; } # line 2451 ""grammar.c"" break ; case 54 : # line 914 ""grammar.y"" { if ( ( yyvsp [ 0 ] . expression ) . type == EXPRESSION_TYPE_STRING ) { if ( ( yyvsp [ 0 ] . expression ) . value . sized_string != NULL ) { yywarning ( yyscanner , ""Using<S2SV_blank>literal<S2SV_blank>string<S2SV_blank>\\""%s\\""<S2SV_blank>in<S2SV_blank>a<S2SV_blank>boolean<S2SV_blank>operation."" , ( yyvsp [ 0 ] . expression ) . value . sized_string -> c_string ) ; } compiler -> last_result = yr_parser_emit ( yyscanner , OP_STR_TO_BOOL , NULL ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } # line 2474 ""grammar.c"" break ; case 55 : # line 936 ""grammar.y"" { compiler -> last_result = yr_parser_emit_with_arg ( yyscanner , OP_PUSH , 1 , NULL , NULL ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } # line 2487 ""grammar.c"" break ; case 56 : # line 945 ""grammar.y"" { compiler -> last_result = yr_parser_emit_with_arg ( yyscanner , OP_PUSH , 0 , NULL , NULL ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } # line 2500 ""grammar.c"" break ; case 57 : # line 954 ""grammar.y"" { CHECK_TYPE ( ( yyvsp [ - 2 ] . expression ) , EXPRESSION_TYPE_STRING , ""matches"" ) ; CHECK_TYPE ( ( yyvsp [ 0 ] . expression ) , EXPRESSION_TYPE_REGEXP , ""matches"" ) ; if ( compiler -> last_result == ERROR_SUCCESS ) compiler -> last_result = yr_parser_emit ( yyscanner , OP_MATCHES , NULL ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } # line 2519 ""grammar.c"" break ; case 58 : # line 969 ""grammar.y"" { CHECK_TYPE ( ( yyvsp [ - 2 ] . expression ) , EXPRESSION_TYPE_STRING , ""contains"" ) ; CHECK_TYPE ( ( yyvsp [ 0 ] . expression ) , EXPRESSION_TYPE_STRING , ""contains"" ) ; compiler -> last_result = yr_parser_emit ( yyscanner , OP_CONTAINS , NULL ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } # line 2535 ""grammar.c"" break ; case 59 : # line 981 ""grammar.y"" { int result = yr_parser_reduce_string_identifier ( yyscanner , ( yyvsp [ 0 ] . c_string ) , OP_FOUND , UNDEFINED ) ; yr_free ( ( yyvsp [ 0 ] . c_string ) ) ; ERROR_IF ( result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } # line 2553 ""grammar.c"" break ; case 60 : # line 995 ""grammar.y"" { CHECK_TYPE ( ( yyvsp [ 0 ] . expression ) , EXPRESSION_TYPE_INTEGER , ""at"" ) ; compiler -> last_result = yr_parser_reduce_string_identifier ( yyscanner , ( yyvsp [ - 2 ] . c_string ) , OP_FOUND_AT , ( yyvsp [ 0 ] . expression ) . value . integer ) ; yr_free ( ( yyvsp [ - 2 ] . c_string ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } # line 2570 ""grammar.c"" break ; case 61 : # line 1008 ""grammar.y"" { compiler -> last_result = yr_parser_reduce_string_identifier ( yyscanner , ( yyvsp [ - 2 ] . c_string ) , OP_FOUND_IN , UNDEFINED ) ; yr_free ( ( yyvsp [ - 2 ] . c_string ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } # line 2585 ""grammar.c"" break ; case 62 : # line 1019 ""grammar.y"" { <S2SV_StartBug> int var_index ; <S2SV_EndBug> if ( compiler -> loop_depth == MAX_LOOP_NESTING ) compiler -> last_result = ERROR_LOOP_NESTING_LIMIT_EXCEEDED ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; var_index = yr_parser_lookup_loop_variable ( yyscanner , ( yyvsp [ - 1 ] . c_string ) ) ; if ( var_index >= 0 ) { yr_compiler_set_error_extra_info ( compiler , ( yyvsp [ - 1 ] . c_string ) ) ; compiler -> last_result = ERROR_DUPLICATED_LOOP_IDENTIFIER ; } ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; compiler -> last_result = yr_parser_emit_with_arg ( yyscanner , OP_PUSH , UNDEFINED , NULL , NULL ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } <S2SV_StartBug> # line 2619 ""grammar.c"" <S2SV_EndBug> break ; <S2SV_StartBug> case 63 : <S2SV_EndBug> # line 1049 ""grammar.y"" { int mem_offset = LOOP_LOCAL_VARS * compiler -> loop_depth ; uint8_t * addr ; yr_parser_emit_with_arg ( yyscanner , OP_CLEAR_M , mem_offset + 1 , NULL , NULL ) ; yr_parser_emit_with_arg ( yyscanner , OP_CLEAR_M , mem_offset + 2 , NULL , NULL ) ; if ( ( yyvsp [ - 1 ] . integer ) == INTEGER_SET_ENUMERATION ) { yr_parser_emit_with_arg ( yyscanner , OP_POP_M , mem_offset , & addr , NULL ) ; } else { yr_parser_emit_with_arg ( yyscanner , OP_POP_M , mem_offset + 3 , & addr , NULL ) ; yr_parser_emit_with_arg ( yyscanner , OP_POP_M , mem_offset , NULL , NULL ) ; } compiler -> loop_address [ compiler -> loop_depth ] = addr ; compiler -> loop_identifier [ compiler -> loop_depth ] = ( yyvsp [ - 4 ] . c_string ) ; compiler -> loop_depth ++ ; } <S2SV_StartBug> # line 2658 ""grammar.c"" <S2SV_EndBug> break ; <S2SV_StartBug> case 64 : <S2SV_EndBug> # line 1084 ""grammar.y"" { int mem_offset ; compiler -> loop_depth -- ; mem_offset = LOOP_LOCAL_VARS * compiler -> loop_depth ; yr_parser_emit_with_arg ( yyscanner , OP_ADD_M , mem_offset + 1 , NULL , NULL ) ; yr_parser_emit_with_arg ( yyscanner , OP_INCR_M , mem_offset + 2 , NULL , NULL ) ; if ( ( yyvsp [ - 5 ] . integer ) == INTEGER_SET_ENUMERATION ) { yr_parser_emit_with_arg_reloc ( yyscanner , OP_JNUNDEF , compiler -> loop_address [ compiler -> loop_depth ] , NULL , NULL ) ; } else { yr_parser_emit_with_arg ( yyscanner , OP_INCR_M , mem_offset , NULL , NULL ) ; yr_parser_emit_with_arg ( yyscanner , OP_PUSH_M , mem_offset , NULL , NULL ) ; yr_parser_emit_with_arg ( yyscanner , OP_PUSH_M , mem_offset + 3 , NULL , NULL ) ; yr_parser_emit_with_arg_reloc ( yyscanner , OP_JLE , compiler -> loop_address [ compiler -> loop_depth ] , NULL , NULL ) ; yr_parser_emit ( yyscanner , OP_POP , NULL ) ; yr_parser_emit ( yyscanner , OP_POP , NULL ) ; } yr_parser_emit ( yyscanner , OP_POP , NULL ) ; yr_parser_emit_with_arg ( yyscanner , OP_SWAPUNDEF , mem_offset + 2 , NULL , NULL ) ; yr_parser_emit_with_arg ( yyscanner , OP_PUSH_M , mem_offset + 1 , NULL , NULL ) ; yr_parser_emit ( yyscanner , OP_INT_LE , NULL ) ; compiler -> loop_identifier [ compiler -> loop_depth ] = NULL ; yr_free ( ( yyvsp [ - 8 ] . c_string ) ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 2741 ""grammar.c"" <S2SV_EndBug> break ; <S2SV_StartBug> case 65 : <S2SV_EndBug> # line 1163 ""grammar.y"" { int mem_offset = LOOP_LOCAL_VARS * compiler -> loop_depth ; uint8_t * addr ; if ( compiler -> loop_depth == MAX_LOOP_NESTING ) compiler -> last_result = ERROR_LOOP_NESTING_LIMIT_EXCEEDED ; if ( compiler -> loop_for_of_mem_offset != - 1 ) compiler -> last_result = ERROR_NESTED_FOR_OF_LOOP ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; yr_parser_emit_with_arg ( yyscanner , OP_CLEAR_M , mem_offset + 1 , NULL , NULL ) ; yr_parser_emit_with_arg ( yyscanner , OP_CLEAR_M , mem_offset + 2 , NULL , NULL ) ; yr_parser_emit_with_arg ( yyscanner , OP_POP_M , mem_offset , & addr , NULL ) ; compiler -> loop_for_of_mem_offset = mem_offset ; compiler -> loop_address [ compiler -> loop_depth ] = addr ; compiler -> loop_identifier [ compiler -> loop_depth ] = NULL ; compiler -> loop_depth ++ ; } <S2SV_StartBug> # line 2775 ""grammar.c"" <S2SV_EndBug> break ; <S2SV_StartBug> case 66 : <S2SV_EndBug> # line 1193 ""grammar.y"" { int mem_offset ; compiler -> loop_depth -- ; compiler -> loop_for_of_mem_offset = - 1 ; mem_offset = LOOP_LOCAL_VARS * compiler -> loop_depth ; yr_parser_emit_with_arg ( yyscanner , OP_ADD_M , mem_offset + 1 , NULL , NULL ) ; yr_parser_emit_with_arg ( yyscanner , OP_INCR_M , mem_offset + 2 , NULL , NULL ) ; yr_parser_emit_with_arg_reloc ( yyscanner , OP_JNUNDEF , compiler -> loop_address [ compiler -> loop_depth ] , NULL , NULL ) ; yr_parser_emit ( yyscanner , OP_POP , NULL ) ; yr_parser_emit_with_arg ( yyscanner , OP_SWAPUNDEF , mem_offset + 2 , NULL , NULL ) ; yr_parser_emit_with_arg ( yyscanner , OP_PUSH_M , mem_offset + 1 , NULL , NULL ) ; yr_parser_emit ( yyscanner , OP_INT_LE , NULL ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 2828 ""grammar.c"" <S2SV_EndBug> break ; case 67 : # line 1242 ""grammar.y"" { yr_parser_emit ( yyscanner , OP_OF , NULL ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } # line 2838 ""grammar.c"" break ; case 68 : <S2SV_StartBug> # line 1248 ""grammar.y"" <S2SV_EndBug> { <S2SV_StartBug> yr_parser_emit ( yyscanner , OP_NOT , NULL ) ; <S2SV_EndBug> ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 2848 ""grammar.c"" <S2SV_EndBug> break ; case 69 : <S2SV_StartBug> # line 1254 ""grammar.y"" <S2SV_EndBug> { YR_FIXUP * fixup ; void * jmp_destination_addr ; compiler -> last_result = yr_parser_emit_with_arg_reloc ( yyscanner , OP_JFALSE , 0 , NULL , & jmp_destination_addr ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; fixup = ( YR_FIXUP * ) yr_malloc ( sizeof ( YR_FIXUP ) ) ; if ( fixup == NULL ) compiler -> last_error = ERROR_INSUFFICIENT_MEMORY ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; fixup -> address = jmp_destination_addr ; fixup -> next = compiler -> fixup_stack_head ; compiler -> fixup_stack_head = fixup ; } <S2SV_StartBug> # line 2878 ""grammar.c"" <S2SV_EndBug> break ; <S2SV_StartBug> case 70 : <S2SV_EndBug> # line 1280 ""grammar.y"" { YR_FIXUP * fixup ; uint8_t * and_addr ; compiler -> last_result = yr_arena_reserve_memory ( compiler -> code_arena , 2 ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; compiler -> last_result = yr_parser_emit ( yyscanner , OP_AND , & and_addr ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; fixup = compiler -> fixup_stack_head ; * ( void * * ) ( fixup -> address ) = ( void * ) ( and_addr + 1 ) ; compiler -> fixup_stack_head = fixup -> next ; yr_free ( fixup ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 2918 ""grammar.c"" <S2SV_EndBug> break ; <S2SV_StartBug> case 71 : <S2SV_EndBug> # line 1316 ""grammar.y"" { YR_FIXUP * fixup ; void * jmp_destination_addr ; compiler -> last_result = yr_parser_emit_with_arg_reloc ( yyscanner , OP_JTRUE , 0 , NULL , & jmp_destination_addr ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; fixup = ( YR_FIXUP * ) yr_malloc ( sizeof ( YR_FIXUP ) ) ; if ( fixup == NULL ) compiler -> last_error = ERROR_INSUFFICIENT_MEMORY ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; fixup -> address = jmp_destination_addr ; fixup -> next = compiler -> fixup_stack_head ; compiler -> fixup_stack_head = fixup ; } <S2SV_StartBug> # line 2947 ""grammar.c"" <S2SV_EndBug> break ; <S2SV_StartBug> case 72 : <S2SV_EndBug> # line 1341 ""grammar.y"" { YR_FIXUP * fixup ; uint8_t * or_addr ; compiler -> last_result = yr_arena_reserve_memory ( compiler -> code_arena , 2 ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; compiler -> last_result = yr_parser_emit ( yyscanner , OP_OR , & or_addr ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; fixup = compiler -> fixup_stack_head ; * ( void * * ) ( fixup -> address ) = ( void * ) ( or_addr + 1 ) ; compiler -> fixup_stack_head = fixup -> next ; yr_free ( fixup ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 2987 ""grammar.c"" <S2SV_EndBug> break ; <S2SV_StartBug> case 73 : <S2SV_EndBug> # line 1377 ""grammar.y"" { compiler -> last_result = yr_parser_reduce_operation ( yyscanner , ""<"" , ( yyvsp [ - 2 ] . expression ) , ( yyvsp [ 0 ] . expression ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 3000 ""grammar.c"" <S2SV_EndBug> break ; <S2SV_StartBug> case 74 : <S2SV_EndBug> # line 1386 ""grammar.y"" { compiler -> last_result = yr_parser_reduce_operation ( yyscanner , "">"" , ( yyvsp [ - 2 ] . expression ) , ( yyvsp [ 0 ] . expression ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 3013 ""grammar.c"" <S2SV_EndBug> break ; <S2SV_StartBug> case 75 : <S2SV_EndBug> # line 1395 ""grammar.y"" { compiler -> last_result = yr_parser_reduce_operation ( yyscanner , ""<="" , ( yyvsp [ - 2 ] . expression ) , ( yyvsp [ 0 ] . expression ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 3026 ""grammar.c"" <S2SV_EndBug> break ; <S2SV_StartBug> case 76 : <S2SV_EndBug> # line 1404 ""grammar.y"" { compiler -> last_result = yr_parser_reduce_operation ( yyscanner , "">="" , ( yyvsp [ - 2 ] . expression ) , ( yyvsp [ 0 ] . expression ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 3039 ""grammar.c"" <S2SV_EndBug> break ; <S2SV_StartBug> case 77 : <S2SV_EndBug> # line 1413 ""grammar.y"" { compiler -> last_result = yr_parser_reduce_operation ( yyscanner , ""=="" , ( yyvsp [ - 2 ] . expression ) , ( yyvsp [ 0 ] . expression ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 3052 ""grammar.c"" <S2SV_EndBug> break ; <S2SV_StartBug> case 78 : <S2SV_EndBug> # line 1422 ""grammar.y"" { compiler -> last_result = yr_parser_reduce_operation ( yyscanner , ""!="" , ( yyvsp [ - 2 ] . expression ) , ( yyvsp [ 0 ] . expression ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 3065 ""grammar.c"" <S2SV_EndBug> break ; case 79 : # line 1431 ""grammar.y"" { ( yyval . expression ) = ( yyvsp [ 0 ] . expression ) ; } # line 3073 ""grammar.c"" break ; case 80 : <S2SV_StartBug> # line 1435 ""grammar.y"" <S2SV_EndBug> { ( yyval . expression ) = ( yyvsp [ - 1 ] . expression ) ; } <S2SV_StartBug> # line 3081 ""grammar.c"" <S2SV_EndBug> break ; case 81 : # line 1442 ""grammar.y"" { ( yyval . integer ) = INTEGER_SET_ENUMERATION ; } # line 3087 ""grammar.c"" break ; case 82 : <S2SV_StartBug> # line 1443 ""grammar.y"" <S2SV_EndBug> <S2SV_StartBug> { ( yyval . integer ) = INTEGER_SET_RANGE ; } <S2SV_EndBug> # line 3093 ""grammar.c"" break ; case 83 : <S2SV_StartBug> # line 1449 ""grammar.y"" <S2SV_EndBug> { if ( ( yyvsp [ - 3 ] . expression ) . type != EXPRESSION_TYPE_INTEGER ) { yr_compiler_set_error_extra_info ( compiler , ""wrong<S2SV_blank>type<S2SV_blank>for<S2SV_blank>range\'s<S2SV_blank>lower<S2SV_blank>bound"" ) ; compiler -> last_result = ERROR_WRONG_TYPE ; } if ( ( yyvsp [ - 1 ] . expression ) . type != EXPRESSION_TYPE_INTEGER ) { yr_compiler_set_error_extra_info ( compiler , ""wrong<S2SV_blank>type<S2SV_blank>for<S2SV_blank>range\'s<S2SV_blank>upper<S2SV_blank>bound"" ) ; compiler -> last_result = ERROR_WRONG_TYPE ; } ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } <S2SV_StartBug> # line 3115 ""grammar.c"" <S2SV_EndBug> break ; <S2SV_StartBug> case 84 : <S2SV_EndBug> # line 1471 ""grammar.y"" { if ( ( yyvsp [ 0 ] . expression ) . type != EXPRESSION_TYPE_INTEGER ) { yr_compiler_set_error_extra_info ( compiler , ""wrong<S2SV_blank>type<S2SV_blank>for<S2SV_blank>enumeration<S2SV_blank>item"" ) ; compiler -> last_result = ERROR_WRONG_TYPE ; } ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } <S2SV_StartBug> # line 3131 ""grammar.c"" <S2SV_EndBug> break ; <S2SV_StartBug> case 85 : <S2SV_EndBug> # line 1483 ""grammar.y"" { if ( ( yyvsp [ 0 ] . expression ) . type != EXPRESSION_TYPE_INTEGER ) { yr_compiler_set_error_extra_info ( compiler , ""wrong<S2SV_blank>type<S2SV_blank>for<S2SV_blank>enumeration<S2SV_blank>item"" ) ; compiler -> last_result = ERROR_WRONG_TYPE ; } ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } <S2SV_StartBug> # line 3146 ""grammar.c"" <S2SV_EndBug> break ; case 86 : # line 1498 ""grammar.y"" { yr_parser_emit_with_arg ( yyscanner , OP_PUSH , UNDEFINED , NULL , NULL ) ; } # line 3155 ""grammar.c"" break ; <S2SV_StartBug> case 88 : <S2SV_EndBug> # line 1504 ""grammar.y"" { yr_parser_emit_with_arg ( yyscanner , OP_PUSH , UNDEFINED , NULL , NULL ) ; yr_parser_emit_pushes_for_strings ( yyscanner , ""$*"" ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } <S2SV_StartBug> # line 3166 ""grammar.c"" <S2SV_EndBug> break ; <S2SV_StartBug> case 91 : <S2SV_EndBug> # line 1521 ""grammar.y"" { yr_parser_emit_pushes_for_strings ( yyscanner , ( yyvsp [ 0 ] . c_string ) ) ; yr_free ( ( yyvsp [ 0 ] . c_string ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } <S2SV_StartBug> # line 3177 ""grammar.c"" <S2SV_EndBug> break ; <S2SV_StartBug> case 92 : <S2SV_EndBug> # line 1528 ""grammar.y"" { yr_parser_emit_pushes_for_strings ( yyscanner , ( yyvsp [ 0 ] . c_string ) ) ; yr_free ( ( yyvsp [ 0 ] . c_string ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } <S2SV_StartBug> # line 3188 ""grammar.c"" <S2SV_EndBug> break ; case 94 : # line 1540 ""grammar.y"" { yr_parser_emit_with_arg ( yyscanner , OP_PUSH , UNDEFINED , NULL , NULL ) ; } # line 3196 ""grammar.c"" break ; case 95 : <S2SV_StartBug> # line 1544 ""grammar.y"" <S2SV_EndBug> { <S2SV_StartBug> yr_parser_emit_with_arg ( yyscanner , OP_PUSH , 1 , NULL , NULL ) ; <S2SV_EndBug> } # line 3204 ""grammar.c"" break ; case 96 : <S2SV_StartBug> # line 1552 ""grammar.y"" <S2SV_EndBug> { ( yyval . expression ) = ( yyvsp [ - 1 ] . expression ) ; } <S2SV_StartBug> # line 3212 ""grammar.c"" <S2SV_EndBug> break ; <S2SV_StartBug> case 97 : <S2SV_EndBug> # line 1556 ""grammar.y"" { compiler -> last_result = yr_parser_emit ( yyscanner , OP_FILESIZE , NULL ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = UNDEFINED ; } <S2SV_StartBug> # line 3226 ""grammar.c"" <S2SV_EndBug> break ; <S2SV_StartBug> case 98 : <S2SV_EndBug> # line 1566 ""grammar.y"" { yywarning ( yyscanner , ""Using<S2SV_blank>deprecated<S2SV_blank>\\""entrypoint\\""<S2SV_blank>keyword.<S2SV_blank>Use<S2SV_blank>the<S2SV_blank>\\""entry_point\\""<S2SV_blank>"" ""function<S2SV_blank>from<S2SV_blank>PE<S2SV_blank>module<S2SV_blank>instead."" ) ; compiler -> last_result = yr_parser_emit ( yyscanner , OP_ENTRYPOINT , NULL ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = UNDEFINED ; } <S2SV_StartBug> # line 3244 ""grammar.c"" <S2SV_EndBug> break ; <S2SV_StartBug> case 99 : <S2SV_EndBug> # line 1580 ""grammar.y"" { CHECK_TYPE ( ( yyvsp [ - 1 ] . expression ) , EXPRESSION_TYPE_INTEGER , ""intXXXX<S2SV_blank>or<S2SV_blank>uintXXXX"" ) ; compiler -> last_result = yr_parser_emit ( yyscanner , ( uint8_t ) ( OP_READ_INT + ( yyvsp [ - 3 ] . integer ) ) , NULL ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = UNDEFINED ; } <S2SV_StartBug> # line 3264 ""grammar.c"" <S2SV_EndBug> break ; <S2SV_StartBug> case 100 : <S2SV_EndBug> # line 1596 ""grammar.y"" { compiler -> last_result = yr_parser_emit_with_arg ( yyscanner , OP_PUSH , ( yyvsp [ 0 ] . integer ) , NULL , NULL ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = ( yyvsp [ 0 ] . integer ) ; } <S2SV_StartBug> # line 3278 ""grammar.c"" <S2SV_EndBug> break ; <S2SV_StartBug> case 101 : <S2SV_EndBug> # line 1606 ""grammar.y"" { compiler -> last_result = yr_parser_emit_with_arg_double ( yyscanner , OP_PUSH , ( yyvsp [ 0 ] . double_ ) , NULL , NULL ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_FLOAT ; } <S2SV_StartBug> # line 3291 ""grammar.c"" <S2SV_EndBug> break ; <S2SV_StartBug> case 102 : <S2SV_EndBug> # line 1615 ""grammar.y"" { SIZED_STRING * sized_string ; compiler -> last_result = yr_arena_write_data ( compiler -> sz_arena , ( yyvsp [ 0 ] . sized_string ) , ( yyvsp [ 0 ] . sized_string ) -> length + sizeof ( SIZED_STRING ) , ( void * * ) & sized_string ) ; yr_free ( ( yyvsp [ 0 ] . sized_string ) ) ; if ( compiler -> last_result == ERROR_SUCCESS ) compiler -> last_result = yr_parser_emit_with_arg_reloc ( yyscanner , OP_PUSH , sized_string , NULL , NULL ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_STRING ; ( yyval . expression ) . value . sized_string = sized_string ; } <S2SV_StartBug> # line 3320 ""grammar.c"" <S2SV_EndBug> break ; <S2SV_StartBug> case 103 : <S2SV_EndBug> # line 1640 ""grammar.y"" { compiler -> last_result = yr_parser_reduce_string_identifier ( yyscanner , ( yyvsp [ 0 ] . c_string ) , OP_COUNT , UNDEFINED ) ; yr_free ( ( yyvsp [ 0 ] . c_string ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = UNDEFINED ; } <S2SV_StartBug> # line 3336 ""grammar.c"" <S2SV_EndBug> break ; <S2SV_StartBug> case 104 : <S2SV_EndBug> # line 1652 ""grammar.y"" { compiler -> last_result = yr_parser_reduce_string_identifier ( yyscanner , ( yyvsp [ - 3 ] . c_string ) , OP_OFFSET , UNDEFINED ) ; yr_free ( ( yyvsp [ - 3 ] . c_string ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = UNDEFINED ; } <S2SV_StartBug> # line 3352 ""grammar.c"" <S2SV_EndBug> break ; <S2SV_StartBug> case 105 : <S2SV_EndBug> # line 1664 ""grammar.y"" { compiler -> last_result = yr_parser_emit_with_arg ( yyscanner , OP_PUSH , 1 , NULL , NULL ) ; if ( compiler -> last_result == ERROR_SUCCESS ) compiler -> last_result = yr_parser_reduce_string_identifier ( yyscanner , ( yyvsp [ 0 ] . c_string ) , OP_OFFSET , UNDEFINED ) ; yr_free ( ( yyvsp [ 0 ] . c_string ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = UNDEFINED ; } <S2SV_StartBug> # line 3372 ""grammar.c"" <S2SV_EndBug> break ; <S2SV_StartBug> case 106 : <S2SV_EndBug> # line 1680 ""grammar.y"" { compiler -> last_result = yr_parser_reduce_string_identifier ( yyscanner , ( yyvsp [ - 3 ] . c_string ) , OP_LENGTH , UNDEFINED ) ; yr_free ( ( yyvsp [ - 3 ] . c_string ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = UNDEFINED ; } <S2SV_StartBug> # line 3388 ""grammar.c"" <S2SV_EndBug> break ; <S2SV_StartBug> case 107 : <S2SV_EndBug> # line 1692 ""grammar.y"" { compiler -> last_result = yr_parser_emit_with_arg ( yyscanner , OP_PUSH , 1 , NULL , NULL ) ; if ( compiler -> last_result == ERROR_SUCCESS ) compiler -> last_result = yr_parser_reduce_string_identifier ( yyscanner , ( yyvsp [ 0 ] . c_string ) , OP_LENGTH , UNDEFINED ) ; yr_free ( ( yyvsp [ 0 ] . c_string ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = UNDEFINED ; } <S2SV_StartBug> # line 3408 ""grammar.c"" <S2SV_EndBug> break ; <S2SV_StartBug> case 108 : <S2SV_EndBug> # line 1708 ""grammar.y"" { if ( ( yyvsp [ 0 ] . expression ) . type == EXPRESSION_TYPE_INTEGER ) { ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = UNDEFINED ; } else if ( ( yyvsp [ 0 ] . expression ) . type == EXPRESSION_TYPE_BOOLEAN ) { ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; ( yyval . expression ) . value . integer = UNDEFINED ; } else if ( ( yyvsp [ 0 ] . expression ) . type == EXPRESSION_TYPE_OBJECT ) { compiler -> last_result = yr_parser_emit ( yyscanner , OP_OBJ_VALUE , NULL ) ; switch ( ( yyvsp [ 0 ] . expression ) . value . object -> type ) { case OBJECT_TYPE_INTEGER : ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = UNDEFINED ; break ; case OBJECT_TYPE_FLOAT : ( yyval . expression ) . type = EXPRESSION_TYPE_FLOAT ; break ; case OBJECT_TYPE_STRING : ( yyval . expression ) . type = EXPRESSION_TYPE_STRING ; ( yyval . expression ) . value . sized_string = NULL ; break ; default : yr_compiler_set_error_extra_info_fmt ( compiler , ""wrong<S2SV_blank>usage<S2SV_blank>of<S2SV_blank>identifier<S2SV_blank>\\""%s\\"""" , ( yyvsp [ 0 ] . expression ) . identifier ) ; compiler -> last_result = ERROR_WRONG_TYPE ; } } else { assert ( FALSE ) ; } ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } <S2SV_StartBug> # line 3457 ""grammar.c"" <S2SV_EndBug> break ; <S2SV_StartBug> case 109 : <S2SV_EndBug> # line 1753 ""grammar.y"" { CHECK_TYPE ( ( yyvsp [ 0 ] . expression ) , EXPRESSION_TYPE_INTEGER | EXPRESSION_TYPE_FLOAT , ""-"" ) ; if ( ( yyvsp [ 0 ] . expression ) . type == EXPRESSION_TYPE_INTEGER ) { ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = ( ( yyvsp [ 0 ] . expression ) . value . integer == UNDEFINED ) ? UNDEFINED : - ( ( yyvsp [ 0 ] . expression ) . value . integer ) ; compiler -> last_result = yr_parser_emit ( yyscanner , OP_INT_MINUS , NULL ) ; } else if ( ( yyvsp [ 0 ] . expression ) . type == EXPRESSION_TYPE_FLOAT ) { ( yyval . expression ) . type = EXPRESSION_TYPE_FLOAT ; compiler -> last_result = yr_parser_emit ( yyscanner , OP_DBL_MINUS , NULL ) ; } ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } <S2SV_StartBug> # line 3480 ""grammar.c"" <S2SV_EndBug> break ; <S2SV_StartBug> case 110 : <S2SV_EndBug> # line 1772 ""grammar.y"" { compiler -> last_result = yr_parser_reduce_operation ( yyscanner , ""+"" , ( yyvsp [ - 2 ] . expression ) , ( yyvsp [ 0 ] . expression ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; if ( ( yyvsp [ - 2 ] . expression ) . type == EXPRESSION_TYPE_INTEGER && ( yyvsp [ 0 ] . expression ) . type == EXPRESSION_TYPE_INTEGER ) { ( yyval . expression ) . value . integer = OPERATION ( + , ( yyvsp [ - 2 ] . expression ) . value . integer , ( yyvsp [ 0 ] . expression ) . value . integer ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; } else { ( yyval . expression ) . type = EXPRESSION_TYPE_FLOAT ; } } <S2SV_StartBug> # line 3502 ""grammar.c"" <S2SV_EndBug> break ; <S2SV_StartBug> case 111 : <S2SV_EndBug> # line 1790 ""grammar.y"" { compiler -> last_result = yr_parser_reduce_operation ( yyscanner , ""-"" , ( yyvsp [ - 2 ] . expression ) , ( yyvsp [ 0 ] . expression ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; if ( ( yyvsp [ - 2 ] . expression ) . type == EXPRESSION_TYPE_INTEGER && ( yyvsp [ 0 ] . expression ) . type == EXPRESSION_TYPE_INTEGER ) { ( yyval . expression ) . value . integer = OPERATION ( - , ( yyvsp [ - 2 ] . expression ) . value . integer , ( yyvsp [ 0 ] . expression ) . value . integer ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; } else { ( yyval . expression ) . type = EXPRESSION_TYPE_FLOAT ; } } <S2SV_StartBug> # line 3524 ""grammar.c"" <S2SV_EndBug> break ; <S2SV_StartBug> case 112 : <S2SV_EndBug> # line 1808 ""grammar.y"" { compiler -> last_result = yr_parser_reduce_operation ( yyscanner , ""*"" , ( yyvsp [ - 2 ] . expression ) , ( yyvsp [ 0 ] . expression ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; if ( ( yyvsp [ - 2 ] . expression ) . type == EXPRESSION_TYPE_INTEGER && ( yyvsp [ 0 ] . expression ) . type == EXPRESSION_TYPE_INTEGER ) { ( yyval . expression ) . value . integer = OPERATION ( * , ( yyvsp [ - 2 ] . expression ) . value . integer , ( yyvsp [ 0 ] . expression ) . value . integer ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; } else { ( yyval . expression ) . type = EXPRESSION_TYPE_FLOAT ; } } <S2SV_StartBug> # line 3546 ""grammar.c"" <S2SV_EndBug> break ; <S2SV_StartBug> case 113 : <S2SV_EndBug> # line 1826 ""grammar.y"" { compiler -> last_result = yr_parser_reduce_operation ( yyscanner , ""\\\\"" , ( yyvsp [ - 2 ] . expression ) , ( yyvsp [ 0 ] . expression ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; if ( ( yyvsp [ - 2 ] . expression ) . type == EXPRESSION_TYPE_INTEGER && ( yyvsp [ 0 ] . expression ) . type == EXPRESSION_TYPE_INTEGER ) { if ( ( yyvsp [ 0 ] . expression ) . value . integer != 0 ) { ( yyval . expression ) . value . integer = OPERATION ( / , ( yyvsp [ - 2 ] . expression ) . value . integer , ( yyvsp [ 0 ] . expression ) . value . integer ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; } else { compiler -> last_result = ERROR_DIVISION_BY_ZERO ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } } else { ( yyval . expression ) . type = EXPRESSION_TYPE_FLOAT ; } } <S2SV_StartBug> # line 3576 ""grammar.c"" <S2SV_EndBug> break ; <S2SV_StartBug> case 114 : <S2SV_EndBug> # line 1852 ""grammar.y"" { CHECK_TYPE ( ( yyvsp [ - 2 ] . expression ) , EXPRESSION_TYPE_INTEGER , ""%"" ) ; CHECK_TYPE ( ( yyvsp [ 0 ] . expression ) , EXPRESSION_TYPE_INTEGER , ""%"" ) ; yr_parser_emit ( yyscanner , OP_MOD , NULL ) ; if ( ( yyvsp [ 0 ] . expression ) . value . integer != 0 ) { ( yyval . expression ) . value . integer = OPERATION ( % , ( yyvsp [ - 2 ] . expression ) . value . integer , ( yyvsp [ 0 ] . expression ) . value . integer ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; } else { compiler -> last_result = ERROR_DIVISION_BY_ZERO ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } } <S2SV_StartBug> # line 3598 ""grammar.c"" <S2SV_EndBug> break ; <S2SV_StartBug> case 115 : <S2SV_EndBug> # line 1870 ""grammar.y"" { CHECK_TYPE ( ( yyvsp [ - 2 ] . expression ) , EXPRESSION_TYPE_INTEGER , ""^"" ) ; CHECK_TYPE ( ( yyvsp [ 0 ] . expression ) , EXPRESSION_TYPE_INTEGER , ""^"" ) ; yr_parser_emit ( yyscanner , OP_BITWISE_XOR , NULL ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = OPERATION ( ^ , ( yyvsp [ - 2 ] . expression ) . value . integer , ( yyvsp [ 0 ] . expression ) . value . integer ) ; } <S2SV_StartBug> # line 3612 ""grammar.c"" <S2SV_EndBug> break ; <S2SV_StartBug> case 116 : <S2SV_EndBug> # line 1880 ""grammar.y"" { CHECK_TYPE ( ( yyvsp [ - 2 ] . expression ) , EXPRESSION_TYPE_INTEGER , ""^"" ) ; CHECK_TYPE ( ( yyvsp [ 0 ] . expression ) , EXPRESSION_TYPE_INTEGER , ""^"" ) ; yr_parser_emit ( yyscanner , OP_BITWISE_AND , NULL ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = OPERATION ( & , ( yyvsp [ - 2 ] . expression ) . value . integer , ( yyvsp [ 0 ] . expression ) . value . integer ) ; } <S2SV_StartBug> # line 3626 ""grammar.c"" <S2SV_EndBug> break ; <S2SV_StartBug> case 117 : <S2SV_EndBug> # line 1890 ""grammar.y"" { CHECK_TYPE ( ( yyvsp [ - 2 ] . expression ) , EXPRESSION_TYPE_INTEGER , ""|"" ) ; CHECK_TYPE ( ( yyvsp [ 0 ] . expression ) , EXPRESSION_TYPE_INTEGER , ""|"" ) ; yr_parser_emit ( yyscanner , OP_BITWISE_OR , NULL ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = OPERATION ( | , ( yyvsp [ - 2 ] . expression ) . value . integer , ( yyvsp [ 0 ] . expression ) . value . integer ) ; } <S2SV_StartBug> # line 3640 ""grammar.c"" <S2SV_EndBug> break ; <S2SV_StartBug> case 118 : <S2SV_EndBug> # line 1900 ""grammar.y"" { CHECK_TYPE ( ( yyvsp [ 0 ] . expression ) , EXPRESSION_TYPE_INTEGER , ""~"" ) ; yr_parser_emit ( yyscanner , OP_BITWISE_NOT , NULL ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = ( ( yyvsp [ 0 ] . expression ) . value . integer == UNDEFINED ) ? UNDEFINED : ~ ( ( yyvsp [ 0 ] . expression ) . value . integer ) ; } <S2SV_StartBug> # line 3654 ""grammar.c"" <S2SV_EndBug> break ; <S2SV_StartBug> case 119 : <S2SV_EndBug> # line 1910 ""grammar.y"" { CHECK_TYPE ( ( yyvsp [ - 2 ] . expression ) , EXPRESSION_TYPE_INTEGER , ""<<"" ) ; CHECK_TYPE ( ( yyvsp [ 0 ] . expression ) , EXPRESSION_TYPE_INTEGER , ""<<"" ) ; yr_parser_emit ( yyscanner , OP_SHL , NULL ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = OPERATION ( << , ( yyvsp [ - 2 ] . expression ) . value . integer , ( yyvsp [ 0 ] . expression ) . value . integer ) ; } <S2SV_StartBug> # line 3668 ""grammar.c"" <S2SV_EndBug> break ; <S2SV_StartBug> case 120 : <S2SV_EndBug> # line 1920 ""grammar.y"" { CHECK_TYPE ( ( yyvsp [ - 2 ] . expression ) , EXPRESSION_TYPE_INTEGER , "">>"" ) ; CHECK_TYPE ( ( yyvsp [ 0 ] . expression ) , EXPRESSION_TYPE_INTEGER , "">>"" ) ; yr_parser_emit ( yyscanner , OP_SHR , NULL ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = OPERATION ( >> , ( yyvsp [ - 2 ] . expression ) . value . integer , ( yyvsp [ 0 ] . expression ) . value . integer ) ; } <S2SV_StartBug> # line 3682 ""grammar.c"" <S2SV_EndBug> break ; <S2SV_StartBug> case 121 : <S2SV_EndBug> # line 1930 ""grammar.y"" { ( yyval . expression ) = ( yyvsp [ 0 ] . expression ) ; } <S2SV_StartBug> # line 3690 ""grammar.c"" <S2SV_EndBug> break ; <S2SV_StartBug> # line 3694 ""grammar.c"" <S2SV_EndBug> default : break ; } YY_SYMBOL_PRINT ( ""-><S2SV_blank>$$<S2SV_blank>="" , yyr1 [ yyn ] , & yyval , & yyloc ) ; YYPOPSTACK ( yylen ) ; yylen = 0 ; YY_STACK_PRINT ( yyss , yyssp ) ; * ++ yyvsp = yyval ; yyn = yyr1 [ yyn ] ; yystate = yypgoto [ yyn - YYNTOKENS ] + * yyssp ; if ( 0 <= yystate && yystate <= YYLAST && yycheck [ yystate ] == * yyssp ) yystate = yytable [ yystate ] ; else yystate = yydefgoto [ yyn - YYNTOKENS ] ; goto yynewstate ; yyerrlab : yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE ( yychar ) ; if ( ! yyerrstatus ) { ++ yynerrs ; # if ! YYERROR_VERBOSE yyerror ( yyscanner , compiler , YY_ ( ""syntax<S2SV_blank>error"" ) ) ; # else # define YYSYNTAX_ERROR yysyntax_error ( & yymsg_alloc , & yymsg , yyssp , yytoken ) { char const * yymsgp = YY_ ( ""syntax<S2SV_blank>error"" ) ; int yysyntax_error_status ; yysyntax_error_status = YYSYNTAX_ERROR ; if ( yysyntax_error_status == 0 ) yymsgp = yymsg ; else if ( yysyntax_error_status == 1 ) { if ( yymsg != yymsgbuf ) YYSTACK_FREE ( yymsg ) ; yymsg = ( char * ) YYSTACK_ALLOC ( yymsg_alloc ) ; if ( ! yymsg ) { yymsg = yymsgbuf ; yymsg_alloc = sizeof yymsgbuf ; yysyntax_error_status = 2 ; } else { yysyntax_error_status = YYSYNTAX_ERROR ; yymsgp = yymsg ; } } yyerror ( yyscanner , compiler , yymsgp ) ; if ( yysyntax_error_status == 2 ) goto yyexhaustedlab ; } # undef YYSYNTAX_ERROR # endif } if ( yyerrstatus == 3 ) { if ( yychar <= YYEOF ) { if ( yychar == YYEOF ) YYABORT ; } else { yydestruct ( ""Error:<S2SV_blank>discarding"" , yytoken , & yylval , yyscanner , compiler ) ; yychar = YYEMPTY ; } } goto yyerrlab1 ; yyerrorlab : if ( 0 ) goto yyerrorlab ; YYPOPSTACK ( yylen ) ; yylen = 0 ; YY_STACK_PRINT ( yyss , yyssp ) ; yystate = * yyssp ; goto yyerrlab1 ; yyerrlab1 : yyerrstatus = 3 ; for ( ; ; ) { yyn = yypact [ yystate ] ; if ( ! yypact_value_is_default ( yyn ) ) { yyn += YYTERROR ; if ( 0 <= yyn && yyn <= YYLAST && yycheck [ yyn ] == YYTERROR ) { yyn = yytable [ yyn ] ; if ( 0 < yyn ) break ; } } if ( yyssp == yyss ) YYABORT ; yydestruct ( ""Error:<S2SV_blank>popping"" , yystos [ yystate ] , yyvsp , yyscanner , compiler ) ; YYPOPSTACK ( 1 ) ; yystate = * yyssp ; YY_STACK_PRINT ( yyss , yyssp ) ; } YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN * ++ yyvsp = yylval ; YY_IGNORE_MAYBE_UNINITIALIZED_END YY_SYMBOL_PRINT ( ""Shifting"" , yystos [ yyn ] , yyvsp , yylsp ) ; yystate = yyn ; goto yynewstate ; yyacceptlab : yyresult = 0 ; goto yyreturn ; yyabortlab : yyresult = 1 ; goto yyreturn ; # if ! defined yyoverflow || YYERROR_VERBOSE yyexhaustedlab : yyerror ( yyscanner , compiler , YY_ ( ""memory<S2SV_blank>exhausted"" ) ) ; yyresult = 2 ; # endif yyreturn : if ( yychar != YYEMPTY ) { yytoken = YYTRANSLATE ( yychar ) ; yydestruct ( ""Cleanup:<S2SV_blank>discarding<S2SV_blank>lookahead"" , yytoken , & yylval , yyscanner , compiler ) ; } YYPOPSTACK ( yylen ) ; YY_STACK_PRINT ( yyss , yyssp ) ; while ( yyssp != yyss ) { yydestruct ( ""Cleanup:<S2SV_blank>popping"" , yystos [ * yyssp ] , yyvsp , yyscanner , compiler ) ; YYPOPSTACK ( 1 ) ; } # ifndef yyoverflow if ( yyss != yyssa ) YYSTACK_FREE ( yyss ) ; # endif # if YYERROR_VERBOSE if ( yymsg != yymsgbuf ) YYSTACK_FREE ( yymsg ) ; # endif return yyresult ; }","1019 ""grammar.y"" { compiler -> loop_depth -- ; compiler -> loop_identifier [ compiler -> loop_depth ] = NULL ; } # line 2594 ""grammar.c"" break ; case 63 : # line 1024 ""grammar.y"" { <S2SV_ModStart> } # line 2628 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> break ; case 64 : # line 1054 <S2SV_ModEnd> ""grammar.y"" { int <S2SV_ModStart> } # line 2667 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> break ; case 65 : # line 1089 <S2SV_ModEnd> ""grammar.y"" { int <S2SV_ModStart> } # line 2750 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> break ; case 66 : # line 1168 <S2SV_ModEnd> ""grammar.y"" { int <S2SV_ModStart> } # line 2784 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> break ; case 67 : # line 1198 <S2SV_ModEnd> ""grammar.y"" { int <S2SV_ModStart> } # line 2837 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1247 <S2SV_ModEnd> ""grammar.y"" { yr_parser_emit <S2SV_ModStart> ( yyscanner , OP_OF <S2SV_ModEnd> , NULL ) <S2SV_ModStart> } # line 2847 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1253 ""grammar.y"" { yr_parser_emit ( yyscanner , OP_NOT , NULL ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } # line 2857 ""grammar.c"" break ; case 70 : # line 1259 <S2SV_ModEnd> ""grammar.y"" { YR_FIXUP <S2SV_ModStart> } # line 2887 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> break ; case 71 : # line 1285 <S2SV_ModEnd> ""grammar.y"" { YR_FIXUP <S2SV_ModStart> } # line 2927 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> break ; case 72 : # line 1321 <S2SV_ModEnd> ""grammar.y"" { YR_FIXUP <S2SV_ModStart> } # line 2956 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> break ; case 73 : # line 1346 <S2SV_ModEnd> ""grammar.y"" { YR_FIXUP <S2SV_ModStart> } # line 2996 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> break ; case 74 : # line 1382 <S2SV_ModEnd> ""grammar.y"" { compiler <S2SV_ModStart> } # line 3009 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> break ; case 75 : # line 1391 <S2SV_ModEnd> ""grammar.y"" { compiler <S2SV_ModStart> } # line 3022 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> break ; case 76 : # line 1400 <S2SV_ModEnd> ""grammar.y"" { compiler <S2SV_ModStart> } # line 3035 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> break ; case 77 : # line 1409 <S2SV_ModEnd> ""grammar.y"" { compiler <S2SV_ModStart> } # line 3048 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> break ; case 78 : # line 1418 <S2SV_ModEnd> ""grammar.y"" { compiler <S2SV_ModStart> } # line 3061 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> break ; case 79 : # line 1427 <S2SV_ModEnd> ""grammar.y"" { compiler <S2SV_ModStart> } # line 3074 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1436 ""grammar.y"" { ( yyval . expression ) = ( yyvsp [ 0 ] . expression ) ; } # line 3082 ""grammar.c"" break ; case 81 : # line 1440 <S2SV_ModEnd> ""grammar.y"" { ( <S2SV_ModStart> } # line 3090 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1447 <S2SV_ModEnd> ""grammar.y"" { ( <S2SV_ModStart> integer ) = INTEGER_SET_ENUMERATION ; } # line 3096 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1448 ""grammar.y"" { ( yyval . integer ) = INTEGER_SET_RANGE ; } # line 3102 ""grammar.c"" break ; case 84 : # line 1454 <S2SV_ModEnd> ""grammar.y"" { if <S2SV_ModStart> } # line 3124 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> break ; case 85 : # line 1476 <S2SV_ModEnd> ""grammar.y"" { if <S2SV_ModStart> } # line 3140 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> break ; case 86 : # line 1488 <S2SV_ModEnd> ""grammar.y"" { if <S2SV_ModStart> } # line <S2SV_ModEnd> 3155 ""grammar.c"" break <S2SV_ModStart> break ; case 87 : # line 1503 ""grammar.y"" { yr_parser_emit_with_arg ( yyscanner , OP_PUSH , UNDEFINED , NULL , NULL ) ; } # line 3164 ""grammar.c"" break ; case 89 : # line 1509 <S2SV_ModEnd> ""grammar.y"" { yr_parser_emit_with_arg <S2SV_ModStart> } # line 3175 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> break ; case 92 : # line 1526 <S2SV_ModEnd> ""grammar.y"" { yr_parser_emit_pushes_for_strings <S2SV_ModStart> } # line 3186 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> break ; case 93 : # line 1533 <S2SV_ModEnd> ""grammar.y"" { yr_parser_emit_pushes_for_strings <S2SV_ModStart> } # line 3197 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1545 <S2SV_ModEnd> ""grammar.y"" { yr_parser_emit_with_arg <S2SV_ModStart> , OP_PUSH , UNDEFINED , NULL , NULL ) ; } # line 3205 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> : # line 1549 ""grammar.y"" { yr_parser_emit_with_arg ( yyscanner , OP_PUSH , 1 , NULL , NULL ) ; } # line 3213 ""grammar.c"" break ; case 97 : # line 1557 <S2SV_ModEnd> ""grammar.y"" { ( <S2SV_ModStart> } # line 3221 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> break ; case 98 : # line 1561 <S2SV_ModEnd> ""grammar.y"" { compiler <S2SV_ModStart> } # line 3235 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> break ; case 99 : # line 1571 <S2SV_ModEnd> ""grammar.y"" { yywarning <S2SV_ModStart> } # line 3253 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> break ; case 100 : # line 1585 <S2SV_ModEnd> ""grammar.y"" { CHECK_TYPE <S2SV_ModStart> } # line 3273 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> break ; case 101 : # line 1601 <S2SV_ModEnd> ""grammar.y"" { compiler <S2SV_ModStart> } # line 3287 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> break ; case 102 : # line 1611 <S2SV_ModEnd> ""grammar.y"" { compiler <S2SV_ModStart> } # line 3300 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> break ; case 103 : # line 1620 <S2SV_ModEnd> ""grammar.y"" { SIZED_STRING <S2SV_ModStart> } # line 3329 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> break ; case 104 : # line 1645 <S2SV_ModEnd> ""grammar.y"" { compiler <S2SV_ModStart> } # line 3345 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> break ; case 105 : # line 1657 <S2SV_ModEnd> ""grammar.y"" { compiler <S2SV_ModStart> } # line 3361 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> break ; case 106 : # line 1669 <S2SV_ModEnd> ""grammar.y"" { compiler <S2SV_ModStart> } # line 3381 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> break ; case 107 : # line 1685 <S2SV_ModEnd> ""grammar.y"" { compiler <S2SV_ModStart> } # line 3397 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> break ; case 108 : # line 1697 <S2SV_ModEnd> ""grammar.y"" { compiler <S2SV_ModStart> } # line 3417 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> break ; case 109 : # line 1713 <S2SV_ModEnd> ""grammar.y"" { if <S2SV_ModStart> } # line 3466 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> break ; case 110 : # line 1758 <S2SV_ModEnd> ""grammar.y"" { CHECK_TYPE <S2SV_ModStart> } # line 3489 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> break ; case 111 : # line 1777 <S2SV_ModEnd> ""grammar.y"" { compiler <S2SV_ModStart> } # line 3511 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> break ; case 112 : # line 1795 <S2SV_ModEnd> ""grammar.y"" { compiler <S2SV_ModStart> } # line 3533 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> break ; case 113 : # line 1813 <S2SV_ModEnd> ""grammar.y"" { compiler <S2SV_ModStart> } # line 3555 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> break ; case 114 : # line 1831 <S2SV_ModEnd> ""grammar.y"" { compiler <S2SV_ModStart> } # line 3585 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> break ; case 115 : # line 1857 <S2SV_ModEnd> ""grammar.y"" { CHECK_TYPE <S2SV_ModStart> } # line 3607 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> break ; case 116 : # line 1875 <S2SV_ModEnd> ""grammar.y"" { CHECK_TYPE <S2SV_ModStart> } # line 3621 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> break ; case 117 : # line 1885 <S2SV_ModEnd> ""grammar.y"" { CHECK_TYPE <S2SV_ModStart> } # line 3635 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> break ; case 118 : # line 1895 <S2SV_ModEnd> ""grammar.y"" { CHECK_TYPE <S2SV_ModStart> } # line 3649 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> break ; case 119 : # line 1905 <S2SV_ModEnd> ""grammar.y"" { CHECK_TYPE <S2SV_ModStart> } # line 3663 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> break ; case 120 : # line 1915 <S2SV_ModEnd> ""grammar.y"" { CHECK_TYPE <S2SV_ModStart> } # line 3677 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> break ; case 121 : # line 1925 <S2SV_ModEnd> ""grammar.y"" { CHECK_TYPE <S2SV_ModStart> } # line 3691 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> break ; case 122 : # line 1935 <S2SV_ModEnd> ""grammar.y"" { ( <S2SV_ModStart> } # line 3699 <S2SV_ModEnd> ""grammar.c"" break ; <S2SV_ModStart> ; # line 3703 <S2SV_ModEnd> ""grammar.c"" default :"
360,"static void call_bind_status ( struct rpc_task * task ) { int status = - EIO ; if ( task -> tk_status >= 0 ) { dprint_status ( task ) ; task -> tk_status = 0 ; task -> tk_action = call_connect ; return ; } switch ( task -> tk_status ) { case - ENOMEM : dprintk ( ""RPC:<S2SV_blank>%5u<S2SV_blank>rpcbind<S2SV_blank>out<S2SV_blank>of<S2SV_blank>memory\\n"" , task -> tk_pid ) ; rpc_delay ( task , HZ >> 2 ) ; goto retry_timeout ; case - EACCES : dprintk ( ""RPC:<S2SV_blank>%5u<S2SV_blank>remote<S2SV_blank>rpcbind:<S2SV_blank>RPC<S2SV_blank>program/version<S2SV_blank>"" ""unavailable\\n"" , task -> tk_pid ) ; if ( task -> tk_msg . rpc_proc -> p_proc == 0 ) { status = - EOPNOTSUPP ; break ; } <S2SV_StartBug> rpc_delay ( task , 3 * HZ ) ; <S2SV_EndBug> goto retry_timeout ; case - ETIMEDOUT : dprintk ( ""RPC:<S2SV_blank>%5u<S2SV_blank>rpcbind<S2SV_blank>request<S2SV_blank>timed<S2SV_blank>out\\n"" , task -> tk_pid ) ; goto retry_timeout ; case - EPFNOSUPPORT : dprintk ( ""RPC:<S2SV_blank>%5u<S2SV_blank>unrecognized<S2SV_blank>remote<S2SV_blank>rpcbind<S2SV_blank>service\\n"" , task -> tk_pid ) ; break ; case - EPROTONOSUPPORT : dprintk ( ""RPC:<S2SV_blank>%5u<S2SV_blank>remote<S2SV_blank>rpcbind<S2SV_blank>version<S2SV_blank>unavailable,<S2SV_blank>retrying\\n"" , task -> tk_pid ) ; task -> tk_status = 0 ; task -> tk_action = call_bind ; return ; case - ECONNREFUSED : case - ECONNRESET : case - ENOTCONN : case - EHOSTDOWN : case - EHOSTUNREACH : case - ENETUNREACH : case - EPIPE : dprintk ( ""RPC:<S2SV_blank>%5u<S2SV_blank>remote<S2SV_blank>rpcbind<S2SV_blank>unreachable:<S2SV_blank>%d\\n"" , task -> tk_pid , task -> tk_status ) ; if ( ! RPC_IS_SOFTCONN ( task ) ) { rpc_delay ( task , 5 * HZ ) ; goto retry_timeout ; } status = task -> tk_status ; break ; default : dprintk ( ""RPC:<S2SV_blank>%5u<S2SV_blank>unrecognized<S2SV_blank>rpcbind<S2SV_blank>error<S2SV_blank>(%d)\\n"" , task -> tk_pid , - task -> tk_status ) ; } rpc_exit ( task , status ) ; return ; retry_timeout : task -> tk_action = call_timeout ; }",break ; } if ( task -> tk_rebind_retry == 0 ) break ; task -> tk_rebind_retry -- ;
361,"static gboolean handle_spawn ( PortalFlatpak * object , GDBusMethodInvocation * invocation , GUnixFDList * fd_list , const gchar * arg_cwd_path , const gchar * const * arg_argv , GVariant * arg_fds , GVariant * arg_envs , guint arg_flags , GVariant * arg_options ) { g_autoptr ( GError ) error = NULL ; ChildSetupData child_setup_data = { NULL } ; GPid pid ; PidData * pid_data ; InstanceIdReadData * instance_id_read_data = NULL ; gsize i , j , n_fds , n_envs ; const gint * fds = NULL ; gint fds_len = 0 ; g_autofree FdMapEntry * fd_map = NULL ; gchar * * env ; gint32 max_fd ; GKeyFile * app_info ; g_autoptr ( GPtrArray ) flatpak_argv = g_ptr_array_new_with_free_func ( g_free ) ; g_autofree char * app_id = NULL ; g_autofree char * branch = NULL ; g_autofree char * arch = NULL ; g_autofree char * app_commit = NULL ; g_autofree char * runtime_ref = NULL ; g_auto ( GStrv ) runtime_parts = NULL ; g_autofree char * runtime_commit = NULL ; g_autofree char * instance_path = NULL ; g_auto ( GStrv ) extra_args = NULL ; g_auto ( GStrv ) shares = NULL ; g_auto ( GStrv ) sockets = NULL ; g_auto ( GStrv ) devices = NULL ; g_auto ( GStrv ) sandbox_expose = NULL ; g_auto ( GStrv ) sandbox_expose_ro = NULL ; g_autoptr ( GVariant ) sandbox_expose_fd = NULL ; g_autoptr ( GVariant ) sandbox_expose_fd_ro = NULL ; g_autoptr ( GOutputStream ) instance_id_out_stream = NULL ; guint sandbox_flags = 0 ; gboolean sandboxed ; gboolean expose_pids ; gboolean share_pids ; gboolean notify_start ; <S2SV_StartBug> gboolean devel ; <S2SV_EndBug> <S2SV_StartBug> child_setup_data . instance_id_fd = - 1 ; <S2SV_EndBug> if ( fd_list != NULL ) fds = g_unix_fd_list_peek_fds ( fd_list , & fds_len ) ; app_info = g_object_get_data ( G_OBJECT ( invocation ) , ""app-info"" ) ; g_assert ( app_info != NULL ) ; app_id = g_key_file_get_string ( app_info , FLATPAK_METADATA_GROUP_APPLICATION , FLATPAK_METADATA_KEY_NAME , NULL ) ; g_assert ( app_id != NULL ) ; g_debug ( ""spawn()<S2SV_blank>called<S2SV_blank>from<S2SV_blank>app:<S2SV_blank>\'%s\'"" , app_id ) ; if ( * app_id == 0 ) { g_dbus_method_invocation_return_error ( invocation , G_DBUS_ERROR , G_DBUS_ERROR_INVALID_ARGS , ""org.freedesktop.portal.Flatpak.Spawn<S2SV_blank>only<S2SV_blank>works<S2SV_blank>in<S2SV_blank>a<S2SV_blank>flatpak"" ) ; return G_DBUS_METHOD_INVOCATION_HANDLED ; } if ( * arg_cwd_path == 0 ) arg_cwd_path = NULL ; if ( arg_argv == NULL || * arg_argv == NULL ) { g_dbus_method_invocation_return_error ( invocation , G_DBUS_ERROR , G_DBUS_ERROR_INVALID_ARGS , ""No<S2SV_blank>command<S2SV_blank>given"" ) ; return G_DBUS_METHOD_INVOCATION_HANDLED ; } if ( ( arg_flags & ~ FLATPAK_SPAWN_FLAGS_ALL ) != 0 ) { g_dbus_method_invocation_return_error ( invocation , G_DBUS_ERROR , G_DBUS_ERROR_INVALID_ARGS , ""Unsupported<S2SV_blank>flags<S2SV_blank>enabled:<S2SV_blank>0x%x"" , arg_flags & ~ FLATPAK_SPAWN_FLAGS_ALL ) ; return G_DBUS_METHOD_INVOCATION_HANDLED ; } runtime_ref = g_key_file_get_string ( app_info , FLATPAK_METADATA_GROUP_APPLICATION , FLATPAK_METADATA_KEY_RUNTIME , NULL ) ; if ( runtime_ref == NULL ) { g_dbus_method_invocation_return_error ( invocation , G_DBUS_ERROR , G_DBUS_ERROR_INVALID_ARGS , ""No<S2SV_blank>runtime<S2SV_blank>found"" ) ; return G_DBUS_METHOD_INVOCATION_HANDLED ; } runtime_parts = g_strsplit ( runtime_ref , ""/"" , - 1 ) ; branch = g_key_file_get_string ( app_info , FLATPAK_METADATA_GROUP_INSTANCE , FLATPAK_METADATA_KEY_BRANCH , NULL ) ; instance_path = g_key_file_get_string ( app_info , FLATPAK_METADATA_GROUP_INSTANCE , FLATPAK_METADATA_KEY_INSTANCE_PATH , NULL ) ; arch = g_key_file_get_string ( app_info , FLATPAK_METADATA_GROUP_INSTANCE , FLATPAK_METADATA_KEY_ARCH , NULL ) ; extra_args = g_key_file_get_string_list ( app_info , FLATPAK_METADATA_GROUP_INSTANCE , FLATPAK_METADATA_KEY_EXTRA_ARGS , NULL , NULL ) ; app_commit = g_key_file_get_string ( app_info , FLATPAK_METADATA_GROUP_INSTANCE , FLATPAK_METADATA_KEY_APP_COMMIT , NULL ) ; runtime_commit = g_key_file_get_string ( app_info , FLATPAK_METADATA_GROUP_INSTANCE , FLATPAK_METADATA_KEY_RUNTIME_COMMIT , NULL ) ; shares = g_key_file_get_string_list ( app_info , FLATPAK_METADATA_GROUP_CONTEXT , FLATPAK_METADATA_KEY_SHARED , NULL , NULL ) ; sockets = g_key_file_get_string_list ( app_info , FLATPAK_METADATA_GROUP_CONTEXT , FLATPAK_METADATA_KEY_SOCKETS , NULL , NULL ) ; devices = g_key_file_get_string_list ( app_info , FLATPAK_METADATA_GROUP_CONTEXT , FLATPAK_METADATA_KEY_DEVICES , NULL , NULL ) ; devel = g_key_file_get_boolean ( app_info , FLATPAK_METADATA_GROUP_INSTANCE , FLATPAK_METADATA_KEY_DEVEL , NULL ) ; g_variant_lookup ( arg_options , ""sandbox-expose"" , ""^as"" , & sandbox_expose ) ; g_variant_lookup ( arg_options , ""sandbox-expose-ro"" , ""^as"" , & sandbox_expose_ro ) ; g_variant_lookup ( arg_options , ""sandbox-flags"" , ""u"" , & sandbox_flags ) ; sandbox_expose_fd = g_variant_lookup_value ( arg_options , ""sandbox-expose-fd"" , G_VARIANT_TYPE ( ""ah"" ) ) ; sandbox_expose_fd_ro = g_variant_lookup_value ( arg_options , ""sandbox-expose-fd-ro"" , G_VARIANT_TYPE ( ""ah"" ) ) ; if ( ( sandbox_flags & ~ FLATPAK_SPAWN_SANDBOX_FLAGS_ALL ) != 0 ) { g_dbus_method_invocation_return_error ( invocation , G_DBUS_ERROR , G_DBUS_ERROR_INVALID_ARGS , ""Unsupported<S2SV_blank>sandbox<S2SV_blank>flags<S2SV_blank>enabled:<S2SV_blank>0x%x"" , arg_flags & ~ FLATPAK_SPAWN_SANDBOX_FLAGS_ALL ) ; return G_DBUS_METHOD_INVOCATION_HANDLED ; } if ( instance_path == NULL && ( ( sandbox_expose != NULL && sandbox_expose [ 0 ] != NULL ) || ( sandbox_expose_ro != NULL && sandbox_expose_ro [ 0 ] != NULL ) ) ) { g_dbus_method_invocation_return_error ( invocation , G_DBUS_ERROR , G_DBUS_ERROR_INVALID_ARGS , ""Invalid<S2SV_blank>sandbox<S2SV_blank>expose,<S2SV_blank>caller<S2SV_blank>has<S2SV_blank>no<S2SV_blank>instance<S2SV_blank>path"" ) ; return G_DBUS_METHOD_INVOCATION_HANDLED ; } for ( i = 0 ; sandbox_expose != NULL && sandbox_expose [ i ] != NULL ; i ++ ) { const char * expose = sandbox_expose [ i ] ; g_debug ( ""exposing<S2SV_blank>%s"" , expose ) ; if ( ! is_valid_expose ( expose , & error ) ) { g_dbus_method_invocation_return_gerror ( invocation , error ) ; return G_DBUS_METHOD_INVOCATION_HANDLED ; } } for ( i = 0 ; sandbox_expose_ro != NULL && sandbox_expose_ro [ i ] != NULL ; i ++ ) { const char * expose = sandbox_expose_ro [ i ] ; g_debug ( ""exposing<S2SV_blank>%s"" , expose ) ; if ( ! is_valid_expose ( expose , & error ) ) { g_dbus_method_invocation_return_gerror ( invocation , error ) ; return G_DBUS_METHOD_INVOCATION_HANDLED ; } } g_debug ( ""Running<S2SV_blank>spawn<S2SV_blank>command<S2SV_blank>%s"" , arg_argv [ 0 ] ) ; n_fds = 0 ; if ( fds != NULL ) n_fds = g_variant_n_children ( arg_fds ) ; fd_map = g_new0 ( FdMapEntry , n_fds ) ; child_setup_data . fd_map = fd_map ; child_setup_data . fd_map_len = n_fds ; max_fd = - 1 ; for ( i = 0 ; i < n_fds ; i ++ ) { gint32 handle , dest_fd ; int handle_fd ; g_variant_get_child ( arg_fds , i , ""{uh}"" , & dest_fd , & handle ) ; if ( handle >= fds_len || handle < 0 ) { g_dbus_method_invocation_return_error ( invocation , G_DBUS_ERROR , G_DBUS_ERROR_INVALID_ARGS , ""No<S2SV_blank>file<S2SV_blank>descriptor<S2SV_blank>for<S2SV_blank>handle<S2SV_blank>%d"" , handle ) ; return G_DBUS_METHOD_INVOCATION_HANDLED ; } handle_fd = fds [ handle ] ; fd_map [ i ] . to = dest_fd ; fd_map [ i ] . from = handle_fd ; fd_map [ i ] . final = fd_map [ i ] . to ; if ( ( dest_fd == 0 || dest_fd == 1 || dest_fd == 2 ) && ! child_setup_data . set_tty && isatty ( handle_fd ) ) { child_setup_data . set_tty = TRUE ; child_setup_data . tty = handle_fd ; } max_fd = MAX ( max_fd , fd_map [ i ] . to ) ; max_fd = MAX ( max_fd , fd_map [ i ] . from ) ; } for ( i = 0 ; i < n_fds ; i ++ ) { int to_fd = fd_map [ i ] . to ; gboolean conflict = FALSE ; for ( j = i + 1 ; j < n_fds ; j ++ ) { int from_fd = fd_map [ j ] . from ; if ( from_fd == to_fd ) { conflict = TRUE ; break ; } } if ( conflict ) fd_map [ i ] . to = ++ max_fd ; } if ( arg_flags & FLATPAK_SPAWN_FLAGS_CLEAR_ENV ) { char * empty [ ] = { NULL } ; env = g_strdupv ( empty ) ; } else env = g_get_environ ( ) ; n_envs = g_variant_n_children ( arg_envs ) ; for ( i = 0 ; i < n_envs ; i ++ ) { const char * var = NULL ; const char * val = NULL ; g_variant_get_child ( arg_envs , i , ""{&s&s}"" , & var , & val ) ; env = g_environ_setenv ( env , var , val , TRUE ) ; } g_ptr_array_add ( flatpak_argv , g_strdup ( ""flatpak"" ) ) ; g_ptr_array_add ( flatpak_argv , g_strdup ( ""run"" ) ) ; sandboxed = ( arg_flags & FLATPAK_SPAWN_FLAGS_SANDBOX ) != 0 ; if ( sandboxed ) { g_ptr_array_add ( flatpak_argv , g_strdup ( ""--sandbox"" ) ) ; if ( sandbox_flags & FLATPAK_SPAWN_SANDBOX_FLAGS_SHARE_DISPLAY ) { if ( sockets != NULL && g_strv_contains ( ( const char * const * ) sockets , ""wayland"" ) ) g_ptr_array_add ( flatpak_argv , g_strdup ( ""--socket=wayland"" ) ) ; if ( sockets != NULL && g_strv_contains ( ( const char * const * ) sockets , ""fallback-x11"" ) ) g_ptr_array_add ( flatpak_argv , g_strdup ( ""--socket=fallback-x11"" ) ) ; if ( sockets != NULL && g_strv_contains ( ( const char * const * ) sockets , ""x11"" ) ) g_ptr_array_add ( flatpak_argv , g_strdup ( ""--socket=x11"" ) ) ; if ( shares != NULL && g_strv_contains ( ( const char * const * ) shares , ""ipc"" ) && sockets != NULL && ( g_strv_contains ( ( const char * const * ) sockets , ""fallback-x11"" ) || g_strv_contains ( ( const char * const * ) sockets , ""x11"" ) ) ) g_ptr_array_add ( flatpak_argv , g_strdup ( ""--share=ipc"" ) ) ; } if ( sandbox_flags & FLATPAK_SPAWN_SANDBOX_FLAGS_SHARE_SOUND ) { if ( sockets != NULL && g_strv_contains ( ( const char * const * ) sockets , ""pulseaudio"" ) ) g_ptr_array_add ( flatpak_argv , g_strdup ( ""--socket=pulseaudio"" ) ) ; } if ( sandbox_flags & FLATPAK_SPAWN_SANDBOX_FLAGS_SHARE_GPU ) { if ( devices != NULL && ( g_strv_contains ( ( const char * const * ) devices , ""dri"" ) || g_strv_contains ( ( const char * const * ) devices , ""all"" ) ) ) g_ptr_array_add ( flatpak_argv , g_strdup ( ""--device=dri"" ) ) ; } if ( sandbox_flags & FLATPAK_SPAWN_SANDBOX_FLAGS_ALLOW_DBUS ) g_ptr_array_add ( flatpak_argv , g_strdup ( ""--session-bus"" ) ) ; if ( sandbox_flags & FLATPAK_SPAWN_SANDBOX_FLAGS_ALLOW_A11Y ) g_ptr_array_add ( flatpak_argv , g_strdup ( ""--a11y-bus"" ) ) ; } else { for ( i = 0 ; extra_args != NULL && extra_args [ i ] != NULL ; i ++ ) <S2SV_StartBug> g_ptr_array_add ( flatpak_argv , g_strdup ( extra_args [ i ] ) ) ; <S2SV_EndBug> } expose_pids = ( arg_flags & FLATPAK_SPAWN_FLAGS_EXPOSE_PIDS ) != 0 ; share_pids = ( arg_flags & FLATPAK_SPAWN_FLAGS_SHARE_PIDS ) != 0 ; if ( expose_pids || share_pids ) { g_autofree char * instance_id = NULL ; int sender_pid1 = 0 ; if ( ! ( supports & FLATPAK_SPAWN_SUPPORT_FLAGS_EXPOSE_PIDS ) ) { g_dbus_method_invocation_return_error ( invocation , G_DBUS_ERROR , G_DBUS_ERROR_NOT_SUPPORTED , ""Expose<S2SV_blank>pids<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>with<S2SV_blank>setuid<S2SV_blank>bwrap"" ) ; return G_DBUS_METHOD_INVOCATION_HANDLED ; } instance_id = g_key_file_get_string ( app_info , FLATPAK_METADATA_GROUP_INSTANCE , FLATPAK_METADATA_KEY_INSTANCE_ID , NULL ) ; if ( instance_id ) { g_autoptr ( FlatpakInstance ) instance = flatpak_instance_new_for_id ( instance_id ) ; sender_pid1 = flatpak_instance_get_child_pid ( instance ) ; } if ( sender_pid1 == 0 ) { g_dbus_method_invocation_return_error ( invocation , G_DBUS_ERROR , G_DBUS_ERROR_INVALID_ARGS , ""Could<S2SV_blank>not<S2SV_blank>find<S2SV_blank>requesting<S2SV_blank>pid"" ) ; return G_DBUS_METHOD_INVOCATION_HANDLED ; } g_ptr_array_add ( flatpak_argv , g_strdup_printf ( ""--parent-pid=%d"" , sender_pid1 ) ) ; if ( share_pids ) g_ptr_array_add ( flatpak_argv , g_strdup ( ""--parent-share-pids"" ) ) ; else g_ptr_array_add ( flatpak_argv , g_strdup ( ""--parent-expose-pids"" ) ) ; } notify_start = ( arg_flags & FLATPAK_SPAWN_FLAGS_NOTIFY_START ) != 0 ; if ( notify_start ) { int pipe_fds [ 2 ] ; if ( pipe ( pipe_fds ) == - 1 ) { int errsv = errno ; g_dbus_method_invocation_return_error ( invocation , G_IO_ERROR , g_io_error_from_errno ( errsv ) , ""Failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>instance<S2SV_blank>ID<S2SV_blank>pipe:<S2SV_blank>%s"" , g_strerror ( errsv ) ) ; return G_DBUS_METHOD_INVOCATION_HANDLED ; } GInputStream * in_stream = G_INPUT_STREAM ( g_unix_input_stream_new ( pipe_fds [ 0 ] , TRUE ) ) ; instance_id_out_stream = G_OUTPUT_STREAM ( g_unix_output_stream_new ( pipe_fds [ 1 ] , TRUE ) ) ; instance_id_read_data = g_new0 ( InstanceIdReadData , 1 ) ; g_input_stream_read_async ( in_stream , instance_id_read_data -> buffer , INSTANCE_ID_BUFFER_SIZE - 1 , G_PRIORITY_DEFAULT , NULL , instance_id_read_finish , instance_id_read_data ) ; g_ptr_array_add ( flatpak_argv , g_strdup_printf ( ""--instance-id-fd=%d"" , pipe_fds [ 1 ] ) ) ; child_setup_data . instance_id_fd = pipe_fds [ 1 ] ; } if ( devel ) g_ptr_array_add ( flatpak_argv , g_strdup ( ""--devel"" ) ) ; if ( shares != NULL && g_strv_contains ( ( const char * const * ) shares , ""network"" ) && ! ( arg_flags & FLATPAK_SPAWN_FLAGS_NO_NETWORK ) ) g_ptr_array_add ( flatpak_argv , g_strdup ( ""--share=network"" ) ) ; else g_ptr_array_add ( flatpak_argv , g_strdup ( ""--unshare=network"" ) ) ; if ( instance_path ) { for ( i = 0 ; sandbox_expose != NULL && sandbox_expose [ i ] != NULL ; i ++ ) g_ptr_array_add ( flatpak_argv , filesystem_sandbox_arg ( instance_path , sandbox_expose [ i ] , FALSE ) ) ; for ( i = 0 ; sandbox_expose_ro != NULL && sandbox_expose_ro [ i ] != NULL ; i ++ ) g_ptr_array_add ( flatpak_argv , filesystem_sandbox_arg ( instance_path , sandbox_expose_ro [ i ] , TRUE ) ) ; } for ( i = 0 ; sandbox_expose_ro != NULL && sandbox_expose_ro [ i ] != NULL ; i ++ ) { const char * expose = sandbox_expose_ro [ i ] ; g_debug ( ""exposing<S2SV_blank>%s"" , expose ) ; } if ( sandbox_expose_fd != NULL ) { gsize len = g_variant_n_children ( sandbox_expose_fd ) ; for ( i = 0 ; i < len ; i ++ ) { gint32 handle ; g_variant_get_child ( sandbox_expose_fd , i , ""h"" , & handle ) ; if ( handle >= 0 && handle < fds_len ) { int handle_fd = fds [ handle ] ; g_autofree char * path = NULL ; gboolean writable = FALSE ; path = get_path_for_fd ( handle_fd , & writable , & error ) ; if ( path ) { g_ptr_array_add ( flatpak_argv , filesystem_arg ( path , ! writable ) ) ; } else { g_debug ( ""unable<S2SV_blank>to<S2SV_blank>get<S2SV_blank>path<S2SV_blank>for<S2SV_blank>sandbox-exposed<S2SV_blank>fd<S2SV_blank>%d,<S2SV_blank>ignoring:<S2SV_blank>%s"" , handle_fd , error -> message ) ; g_clear_error ( & error ) ; } } else { g_dbus_method_invocation_return_error ( invocation , G_DBUS_ERROR , G_DBUS_ERROR_INVALID_ARGS , ""No<S2SV_blank>file<S2SV_blank>descriptor<S2SV_blank>for<S2SV_blank>handle<S2SV_blank>%d"" , handle ) ; return G_DBUS_METHOD_INVOCATION_HANDLED ; } } } if ( sandbox_expose_fd_ro != NULL ) { gsize len = g_variant_n_children ( sandbox_expose_fd_ro ) ; for ( i = 0 ; i < len ; i ++ ) { gint32 handle ; g_variant_get_child ( sandbox_expose_fd_ro , i , ""h"" , & handle ) ; if ( handle >= 0 && handle < fds_len ) { int handle_fd = fds [ handle ] ; g_autofree char * path = NULL ; gboolean writable = FALSE ; path = get_path_for_fd ( handle_fd , & writable , & error ) ; if ( path ) { g_ptr_array_add ( flatpak_argv , filesystem_arg ( path , TRUE ) ) ; } else { g_debug ( ""unable<S2SV_blank>to<S2SV_blank>get<S2SV_blank>path<S2SV_blank>for<S2SV_blank>sandbox-exposed<S2SV_blank>fd<S2SV_blank>%d,<S2SV_blank>ignoring:<S2SV_blank>%s"" , handle_fd , error -> message ) ; g_clear_error ( & error ) ; } } else { g_dbus_method_invocation_return_error ( invocation , G_DBUS_ERROR , G_DBUS_ERROR_INVALID_ARGS , ""No<S2SV_blank>file<S2SV_blank>descriptor<S2SV_blank>for<S2SV_blank>handle<S2SV_blank>%d"" , handle ) ; return G_DBUS_METHOD_INVOCATION_HANDLED ; } } } g_ptr_array_add ( flatpak_argv , g_strdup_printf ( ""--runtime=%s"" , runtime_parts [ 1 ] ) ) ; g_ptr_array_add ( flatpak_argv , g_strdup_printf ( ""--runtime-version=%s"" , runtime_parts [ 3 ] ) ) ; if ( ( arg_flags & FLATPAK_SPAWN_FLAGS_LATEST_VERSION ) == 0 ) { if ( app_commit ) g_ptr_array_add ( flatpak_argv , g_strdup_printf ( ""--commit=%s"" , app_commit ) ) ; if ( runtime_commit ) g_ptr_array_add ( flatpak_argv , g_strdup_printf ( ""--runtime-commit=%s"" , runtime_commit ) ) ; } if ( arg_cwd_path != NULL ) g_ptr_array_add ( flatpak_argv , g_strdup_printf ( ""--cwd=%s"" , arg_cwd_path ) ) ; if ( arg_argv [ 0 ] [ 0 ] != 0 ) g_ptr_array_add ( flatpak_argv , g_strdup_printf ( ""--command=%s"" , arg_argv [ 0 ] ) ) ; g_ptr_array_add ( flatpak_argv , g_strdup_printf ( ""%s/%s/%s"" , app_id , arch ? arch : """" , branch ? branch : """" ) ) ; for ( i = 1 ; arg_argv [ i ] != NULL ; i ++ ) g_ptr_array_add ( flatpak_argv , g_strdup ( arg_argv [ i ] ) ) ; g_ptr_array_add ( flatpak_argv , NULL ) ; if ( opt_verbose ) { g_autoptr ( GString ) cmd = g_string_new ( """" ) ; for ( i = 0 ; flatpak_argv -> pdata [ i ] != NULL ; i ++ ) { if ( i > 0 ) g_string_append ( cmd , ""<S2SV_blank>"" ) ; g_string_append ( cmd , flatpak_argv -> pdata [ i ] ) ; } g_debug ( ""Starting:<S2SV_blank>%s\\n"" , cmd -> str ) ; } if ( ! g_spawn_async_with_pipes ( NULL , ( char * * ) flatpak_argv -> pdata , env , G_SPAWN_SEARCH_PATH | G_SPAWN_DO_NOT_REAP_CHILD | G_SPAWN_LEAVE_DESCRIPTORS_OPEN , child_setup_func , & child_setup_data , & pid , NULL , NULL , NULL , & error ) ) { gint code = G_DBUS_ERROR_FAILED ; if ( g_error_matches ( error , G_SPAWN_ERROR , G_SPAWN_ERROR_ACCES ) ) code = G_DBUS_ERROR_ACCESS_DENIED ; else if ( g_error_matches ( error , G_SPAWN_ERROR , G_SPAWN_ERROR_NOENT ) ) code = G_DBUS_ERROR_FILE_NOT_FOUND ; g_dbus_method_invocation_return_error ( invocation , G_DBUS_ERROR , code , ""Failed<S2SV_blank>to<S2SV_blank>start<S2SV_blank>command:<S2SV_blank>%s"" , error -> message ) ; return G_DBUS_METHOD_INVOCATION_HANDLED ; } if ( instance_id_read_data ) instance_id_read_data -> pid = pid ; pid_data = g_new0 ( PidData , 1 ) ; pid_data -> pid = pid ; pid_data -> client = g_strdup ( g_dbus_method_invocation_get_sender ( invocation ) ) ; pid_data -> watch_bus = ( arg_flags & FLATPAK_SPAWN_FLAGS_WATCH_BUS ) != 0 ; pid_data -> expose_or_share_pids = ( expose_pids || share_pids ) ; pid_data -> child_watch = g_child_watch_add_full ( G_PRIORITY_DEFAULT , pid , child_watch_died , pid_data , NULL ) ; g_debug ( ""Client<S2SV_blank>Pid<S2SV_blank>is<S2SV_blank>%d"" , pid_data -> pid ) ; g_hash_table_replace ( client_pid_data_hash , GUINT_TO_POINTER ( pid_data -> pid ) , pid_data ) ; portal_flatpak_complete_spawn ( object , invocation , NULL , pid ) ; return G_DBUS_METHOD_INVOCATION_HANDLED ; }","; gboolean devel ; g_autoptr ( GString ) env_string = g_string_new ( """" ) <S2SV_ModStart> child_setup_data . instance_id_fd = - 1 ; child_setup_data . env_fd <S2SV_ModStart> i ++ ) { if ( g_str_has_prefix ( extra_args [ i ] , ""--env="" ) ) { const char * var_val = extra_args [ i ] + strlen ( ""--env="" ) ; if ( var_val [ 0 ] == '\\0' || var_val [ 0 ] == '=' ) { g_warning ( ""Environment<S2SV_blank>variable<S2SV_blank>in<S2SV_blank>extra-args<S2SV_blank>has<S2SV_blank>empty<S2SV_blank>name"" ) ; continue ; } if ( strchr ( var_val , '=' ) == NULL ) { g_warning ( ""Environment<S2SV_blank>variable<S2SV_blank>in<S2SV_blank>extra-args<S2SV_blank>has<S2SV_blank>no<S2SV_blank>value"" ) ; continue ; } g_string_append ( env_string , var_val ) ; g_string_append_c ( env_string , '\\0' ) ; } else { <S2SV_ModStart> [ i ] ) ) ; } } } if ( env_string -> len > 0 ) { g_auto ( GLnxTmpfile ) env_tmpf = { 0 , } ; if ( ! flatpak_buffer_to_sealed_memfd_or_tmpfile ( & env_tmpf , ""environ"" , env_string -> str , env_string -> len , & error ) ) { g_dbus_method_invocation_return_gerror ( invocation , error ) ; return G_DBUS_METHOD_INVOCATION_HANDLED ; } child_setup_data . env_fd = glnx_steal_fd ( & env_tmpf . fd ) ; g_ptr_array_add ( flatpak_argv , g_strdup_printf ( ""--env-fd=%d"" , child_setup_data . env_fd"
362,"static void change_port_settings ( struct tty_struct * tty , struct edgeport_port * edge_port , struct ktermios * old_termios ) { struct device * dev = & edge_port -> port -> dev ; struct ump_uart_config * config ; int baud ; unsigned cflag ; int status ; int port_number = edge_port -> port -> port_number ; config = kmalloc ( sizeof ( * config ) , GFP_KERNEL ) ; if ( ! config ) { tty -> termios = * old_termios ; return ; } cflag = tty -> termios . c_cflag ; config -> wFlags = 0 ; config -> wFlags |= UMP_MASK_UART_FLAGS_RECEIVE_MS_INT ; config -> wFlags |= UMP_MASK_UART_FLAGS_AUTO_START_ON_ERR ; config -> bUartMode = ( __u8 ) ( edge_port -> bUartMode ) ; switch ( cflag & CSIZE ) { case CS5 : config -> bDataBits = UMP_UART_CHAR5BITS ; dev_dbg ( dev , ""%s<S2SV_blank>-<S2SV_blank>data<S2SV_blank>bits<S2SV_blank>=<S2SV_blank>5\\n"" , __func__ ) ; break ; case CS6 : config -> bDataBits = UMP_UART_CHAR6BITS ; dev_dbg ( dev , ""%s<S2SV_blank>-<S2SV_blank>data<S2SV_blank>bits<S2SV_blank>=<S2SV_blank>6\\n"" , __func__ ) ; break ; case CS7 : config -> bDataBits = UMP_UART_CHAR7BITS ; dev_dbg ( dev , ""%s<S2SV_blank>-<S2SV_blank>data<S2SV_blank>bits<S2SV_blank>=<S2SV_blank>7\\n"" , __func__ ) ; break ; default : case CS8 : config -> bDataBits = UMP_UART_CHAR8BITS ; dev_dbg ( dev , ""%s<S2SV_blank>-<S2SV_blank>data<S2SV_blank>bits<S2SV_blank>=<S2SV_blank>8\\n"" , __func__ ) ; break ; } if ( cflag & PARENB ) { if ( cflag & PARODD ) { config -> wFlags |= UMP_MASK_UART_FLAGS_PARITY ; config -> bParity = UMP_UART_ODDPARITY ; dev_dbg ( dev , ""%s<S2SV_blank>-<S2SV_blank>parity<S2SV_blank>=<S2SV_blank>odd\\n"" , __func__ ) ; } else { config -> wFlags |= UMP_MASK_UART_FLAGS_PARITY ; config -> bParity = UMP_UART_EVENPARITY ; dev_dbg ( dev , ""%s<S2SV_blank>-<S2SV_blank>parity<S2SV_blank>=<S2SV_blank>even\\n"" , __func__ ) ; } } else { config -> bParity = UMP_UART_NOPARITY ; dev_dbg ( dev , ""%s<S2SV_blank>-<S2SV_blank>parity<S2SV_blank>=<S2SV_blank>none\\n"" , __func__ ) ; } if ( cflag & CSTOPB ) { config -> bStopBits = UMP_UART_STOPBIT2 ; dev_dbg ( dev , ""%s<S2SV_blank>-<S2SV_blank>stop<S2SV_blank>bits<S2SV_blank>=<S2SV_blank>2\\n"" , __func__ ) ; } else { config -> bStopBits = UMP_UART_STOPBIT1 ; dev_dbg ( dev , ""%s<S2SV_blank>-<S2SV_blank>stop<S2SV_blank>bits<S2SV_blank>=<S2SV_blank>1\\n"" , __func__ ) ; } if ( cflag & CRTSCTS ) { config -> wFlags |= UMP_MASK_UART_FLAGS_OUT_X_CTS_FLOW ; config -> wFlags |= UMP_MASK_UART_FLAGS_RTS_FLOW ; dev_dbg ( dev , ""%s<S2SV_blank>-<S2SV_blank>RTS/CTS<S2SV_blank>is<S2SV_blank>enabled\\n"" , __func__ ) ; } else { dev_dbg ( dev , ""%s<S2SV_blank>-<S2SV_blank>RTS/CTS<S2SV_blank>is<S2SV_blank>disabled\\n"" , __func__ ) ; restart_read ( edge_port ) ; } config -> cXon = START_CHAR ( tty ) ; config -> cXoff = STOP_CHAR ( tty ) ; if ( I_IXOFF ( tty ) ) { config -> wFlags |= UMP_MASK_UART_FLAGS_IN_X ; dev_dbg ( dev , ""%s<S2SV_blank>-<S2SV_blank>INBOUND<S2SV_blank>XON/XOFF<S2SV_blank>is<S2SV_blank>enabled,<S2SV_blank>XON<S2SV_blank>=<S2SV_blank>%2x,<S2SV_blank>XOFF<S2SV_blank>=<S2SV_blank>%2x\\n"" , __func__ , config -> cXon , config -> cXoff ) ; } else dev_dbg ( dev , ""%s<S2SV_blank>-<S2SV_blank>INBOUND<S2SV_blank>XON/XOFF<S2SV_blank>is<S2SV_blank>disabled\\n"" , __func__ ) ; if ( I_IXON ( tty ) ) { config -> wFlags |= UMP_MASK_UART_FLAGS_OUT_X ; dev_dbg ( dev , ""%s<S2SV_blank>-<S2SV_blank>OUTBOUND<S2SV_blank>XON/XOFF<S2SV_blank>is<S2SV_blank>enabled,<S2SV_blank>XON<S2SV_blank>=<S2SV_blank>%2x,<S2SV_blank>XOFF<S2SV_blank>=<S2SV_blank>%2x\\n"" , __func__ , config -> cXon , config -> cXoff ) ; } else dev_dbg ( dev , ""%s<S2SV_blank>-<S2SV_blank>OUTBOUND<S2SV_blank>XON/XOFF<S2SV_blank>is<S2SV_blank>disabled\\n"" , __func__ ) ; tty -> termios . c_cflag &= ~ CMSPAR ; baud = tty_get_baud_rate ( tty ) ; if ( ! baud ) { baud = 9600 ; <S2SV_StartBug> } else <S2SV_EndBug> <S2SV_StartBug> tty_encode_baud_rate ( tty , baud , baud ) ; <S2SV_EndBug> edge_port -> baud_rate = baud ; config -> wBaudRate = ( __u16 ) ( ( 461550L + baud / 2 ) / baud ) ; dev_dbg ( dev , ""%s<S2SV_blank>-<S2SV_blank>baud<S2SV_blank>rate<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>wBaudRate<S2SV_blank>=<S2SV_blank>%d\\n"" , __func__ , baud , config -> wBaudRate ) ; dev_dbg ( dev , ""wBaudRate:<S2SV_blank><S2SV_blank><S2SV_blank>%d\\n"" , ( int ) ( 461550L / config -> wBaudRate ) ) ; dev_dbg ( dev , ""wFlags:<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>0x%x\\n"" , config -> wFlags ) ; dev_dbg ( dev , ""bDataBits:<S2SV_blank><S2SV_blank><S2SV_blank>%d\\n"" , config -> bDataBits ) ; dev_dbg ( dev , ""bParity:<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%d\\n"" , config -> bParity ) ; dev_dbg ( dev , ""bStopBits:<S2SV_blank><S2SV_blank><S2SV_blank>%d\\n"" , config -> bStopBits ) ; dev_dbg ( dev , ""cXon:<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%d\\n"" , config -> cXon ) ; dev_dbg ( dev , ""cXoff:<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%d\\n"" , config -> cXoff ) ; dev_dbg ( dev , ""bUartMode:<S2SV_blank><S2SV_blank><S2SV_blank>%d\\n"" , config -> bUartMode ) ; cpu_to_be16s ( & config -> wFlags ) ; cpu_to_be16s ( & config -> wBaudRate ) ; status = send_cmd ( edge_port -> port -> serial -> dev , UMPC_SET_CONFIG , ( __u8 ) ( UMPM_UART1_PORT + port_number ) , 0 , ( __u8 * ) config , sizeof ( * config ) ) ; if ( status ) dev_dbg ( dev , ""%s<S2SV_blank>-<S2SV_blank>error<S2SV_blank>%d<S2SV_blank>when<S2SV_blank>trying<S2SV_blank>to<S2SV_blank>write<S2SV_blank>config<S2SV_blank>to<S2SV_blank>device\\n"" , __func__ , status ) ; kfree ( config ) ; }","; } else { baud = min ( baud , 461550 ) ; <S2SV_ModStart> baud ) ; }"
363,"void dev_load ( struct net * net , const char * name ) { struct net_device * dev ; <S2SV_StartBug> rcu_read_lock ( ) ; <S2SV_EndBug> dev = dev_get_by_name_rcu ( net , name ) ; rcu_read_unlock ( ) ; <S2SV_StartBug> if ( ! dev && capable ( CAP_NET_ADMIN ) ) <S2SV_EndBug> <S2SV_StartBug> request_module ( ""%s"" , name ) ; <S2SV_EndBug> }","* dev ; int no_module ; <S2SV_ModStart> ( ) ; no_module = ! dev ; if ( no_module <S2SV_ModEnd> && capable ( <S2SV_ModStart> CAP_NET_ADMIN ) ) no_module = request_module ( ""netdev-%s"" , name ) ; if ( no_module && capable ( CAP_SYS_MODULE ) ) { if ( ! <S2SV_ModStart> , name ) ) pr_err ( ""Loading<S2SV_blank>kernel<S2SV_blank>module<S2SV_blank>for<S2SV_blank>a<S2SV_blank>network<S2SV_blank>device<S2SV_blank>"" ""with<S2SV_blank>CAP_SYS_MODULE<S2SV_blank>(deprecated).<S2SV_blank><S2SV_blank>Use<S2SV_blank>CAP_NET_ADMIN<S2SV_blank>and<S2SV_blank>alias<S2SV_blank>netdev-%s<S2SV_blank>"" ""instead\\n"" , name ) ; } } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>"
364,"void mono_gc_init ( void ) { InitializeCriticalSection ( & handle_section ) ; InitializeCriticalSection ( & allocator_section ) ; <S2SV_StartBug> InitializeCriticalSection ( & finalizer_mutex ) ; <S2SV_EndBug> MONO_GC_REGISTER_ROOT_FIXED ( gc_handles [ HANDLE_NORMAL ] . entries ) ; MONO_GC_REGISTER_ROOT_FIXED ( gc_handles [ HANDLE_PINNED ] . entries ) ; mono_gc_base_init ( ) ; if ( mono_gc_is_disabled ( ) ) { gc_disabled = TRUE ; return ; } finalizer_event = CreateEvent ( NULL , FALSE , FALSE , NULL ) ; pending_done_event = CreateEvent ( NULL , TRUE , FALSE , NULL ) ; shutdown_event = CreateEvent ( NULL , TRUE , FALSE , NULL ) ; if ( finalizer_event == NULL || pending_done_event == NULL || shutdown_event == NULL ) { g_assert_not_reached ( ) ; } # ifdef MONO_HAS_SEMAPHORES MONO_SEM_INIT ( & finalizer_sem , 0 ) ; # endif gc_thread = mono_thread_create_internal ( mono_domain_get ( ) , finalizer_thread , NULL , FALSE ) ; ves_icall_System_Threading_Thread_SetName_internal ( gc_thread , mono_string_new ( mono_domain_get ( ) , ""Finalizer"" ) ) ; }",( & finalizer_mutex ) ; InitializeCriticalSection ( & reference_queue_mutex
365,"static VALUE ossl_cipher_update ( int argc , VALUE * argv , VALUE self ) { EVP_CIPHER_CTX * ctx ; unsigned char * in ; long in_len , out_len ; VALUE data , str ; rb_scan_args ( argc , argv , ""11"" , & data , & str ) ; <S2SV_StartBug> StringValue ( data ) ; <S2SV_EndBug> in = ( unsigned char * ) RSTRING_PTR ( data ) ; if ( ( in_len = RSTRING_LEN ( data ) ) == 0 ) ossl_raise ( rb_eArgError , ""data<S2SV_blank>must<S2SV_blank>not<S2SV_blank>be<S2SV_blank>empty"" ) ; GetCipher ( self , ctx ) ; out_len = in_len + EVP_CIPHER_CTX_block_size ( ctx ) ; if ( out_len <= 0 ) { ossl_raise ( rb_eRangeError , ""data<S2SV_blank>too<S2SV_blank>big<S2SV_blank>to<S2SV_blank>make<S2SV_blank>output<S2SV_blank>buffer:<S2SV_blank>%ld<S2SV_blank>bytes"" , in_len ) ; } if ( NIL_P ( str ) ) { str = rb_str_new ( 0 , out_len ) ; } else { StringValue ( str ) ; rb_str_resize ( str , out_len ) ; } if ( ! ossl_cipher_update_long ( ctx , ( unsigned char * ) RSTRING_PTR ( str ) , & out_len , in , in_len ) ) ossl_raise ( eCipherError , NULL ) ; assert ( out_len < RSTRING_LEN ( str ) ) ; rb_str_set_len ( str , out_len ) ; return str ; }","str ) ; if ( ! RTEST ( rb_attr_get ( self , id_key_set ) ) ) ossl_raise ( eCipherError , ""key<S2SV_blank>not<S2SV_blank>set"" ) ;"
366,"static int test_candidate_kf ( VP8_COMP * cpi , FIRSTPASS_STATS * last_frame , FIRSTPASS_STATS * this_frame , FIRSTPASS_STATS * next_frame ) { int is_viable_kf = 0 ; if ( ( this_frame -> pcnt_second_ref < 0.10 ) && ( next_frame -> pcnt_second_ref < 0.10 ) && ( ( this_frame -> pcnt_inter < 0.05 ) || ( ( ( this_frame -> pcnt_inter - this_frame -> pcnt_neutral ) < .25 ) && ( ( this_frame -> intra_error / DOUBLE_DIVIDE_CHECK ( this_frame -> coded_error ) ) < 2.5 ) && ( ( fabs ( last_frame -> coded_error - this_frame -> coded_error ) / DOUBLE_DIVIDE_CHECK ( this_frame -> coded_error ) > .40 ) || ( fabs ( last_frame -> intra_error - this_frame -> intra_error ) / DOUBLE_DIVIDE_CHECK ( this_frame -> intra_error ) > .40 ) || ( ( next_frame -> intra_error / DOUBLE_DIVIDE_CHECK ( next_frame -> coded_error ) ) > 3.5 ) ) ) ) ) { int i ; FIRSTPASS_STATS * start_pos ; FIRSTPASS_STATS local_next_frame ; double boost_score = 0.0 ; double old_boost_score = 0.0 ; double decay_accumulator = 1.0 ; double next_iiratio ; <S2SV_StartBug> vpx_memcpy ( & local_next_frame , next_frame , sizeof ( * next_frame ) ) ; <S2SV_EndBug> start_pos = cpi -> twopass . stats_in ; for ( i = 0 ; i < 16 ; i ++ ) { next_iiratio = ( IIKFACTOR1 * local_next_frame . intra_error / DOUBLE_DIVIDE_CHECK ( local_next_frame . coded_error ) ) ; if ( next_iiratio > RMAX ) next_iiratio = RMAX ; if ( local_next_frame . pcnt_inter > 0.85 ) decay_accumulator = decay_accumulator * local_next_frame . pcnt_inter ; else decay_accumulator = decay_accumulator * ( ( 0.85 + local_next_frame . pcnt_inter ) / 2.0 ) ; boost_score += ( decay_accumulator * next_iiratio ) ; if ( ( local_next_frame . pcnt_inter < 0.05 ) || ( next_iiratio < 1.5 ) || ( ( ( local_next_frame . pcnt_inter - local_next_frame . pcnt_neutral ) < 0.20 ) && ( next_iiratio < 3.0 ) ) || ( ( boost_score - old_boost_score ) < 0.5 ) || ( local_next_frame . intra_error < 200 ) ) { break ; } old_boost_score = boost_score ; if ( EOF == input_stats ( cpi , & local_next_frame ) ) break ; } if ( boost_score > 5.0 && ( i > 3 ) ) is_viable_kf = 1 ; else { reset_fpf_position ( cpi , start_pos ) ; is_viable_kf = 0 ; } } return is_viable_kf ; }",double next_iiratio ; memcpy <S2SV_ModEnd> ( & local_next_frame
367,"static ssize_t _epoll_writev ( oe_fd_t * desc , const struct oe_iovec * iov , int iovcnt ) { ssize_t ret = - 1 ; epoll_t * file = _cast_epoll ( desc ) ; void * buf = NULL ; size_t buf_size = 0 ; <S2SV_StartBug> if ( ! file || ( iovcnt && ! iov ) || iovcnt < 0 || iovcnt > OE_IOV_MAX ) <S2SV_EndBug> OE_RAISE_ERRNO ( OE_EINVAL ) ; <S2SV_StartBug> if ( oe_iov_pack ( iov , iovcnt , & buf , & buf_size ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> OE_RAISE_ERRNO ( OE_ENOMEM ) ; <S2SV_EndBug> if ( oe_syscall_writev_ocall ( & ret , file -> host_fd , buf , iovcnt , buf_size ) != OE_OK ) { OE_RAISE_ERRNO ( OE_EINVAL ) ; } <S2SV_StartBug> done : <S2SV_EndBug> if ( buf ) oe_free ( buf ) ; return ret ; }","= 0 ; size_t data_size = 0 ; <S2SV_ModStart> , & buf_size , & data_size <S2SV_ModStart> OE_RAISE_ERRNO ( OE_ENOMEM ) ; if ( data_size > OE_SSIZE_MAX ) OE_RAISE_ERRNO ( OE_EINVAL <S2SV_ModStart> ) ; } if ( ret > ( ssize_t ) data_size ) { ret = - 1 ; OE_RAISE_ERRNO ( OE_EINVAL ) ; }"
368,"void * vpx_calloc ( size_t num , size_t size ) { void * x ; x = vpx_memalign ( DEFAULT_ALIGNMENT , num * size ) ; if ( x ) <S2SV_StartBug> VPX_MEMSET_L ( x , 0 , num * size ) ; <S2SV_EndBug> return x ; }","( x ) memset <S2SV_ModEnd> ( x ,"
369,"static arguments_ty ast_for_arguments ( struct compiling * c , const node * n ) { int i , j , k , nposargs = 0 , nkwonlyargs = 0 ; int nposdefaults = 0 , found_default = 0 ; asdl_seq * posargs , * posdefaults , * kwonlyargs , * kwdefaults ; arg_ty vararg = NULL , kwarg = NULL ; arg_ty arg = NULL ; node * ch ; if ( TYPE ( n ) == parameters ) { if ( NCH ( n ) == 2 ) return arguments ( NULL , NULL , NULL , NULL , NULL , NULL , c -> c_arena ) ; n = CHILD ( n , 1 ) ; } assert ( TYPE ( n ) == typedargslist || TYPE ( n ) == varargslist ) ; for ( i = 0 ; i < NCH ( n ) ; i ++ ) { ch = CHILD ( n , i ) ; if ( TYPE ( ch ) == STAR ) { i ++ ; if ( i < NCH ( n ) && ( TYPE ( CHILD ( n , i ) ) == tfpdef || TYPE ( CHILD ( n , i ) ) == vfpdef ) ) { i ++ ; } break ; } if ( TYPE ( ch ) == DOUBLESTAR ) break ; if ( TYPE ( ch ) == vfpdef || TYPE ( ch ) == tfpdef ) nposargs ++ ; if ( TYPE ( ch ) == EQUAL ) nposdefaults ++ ; } for ( ; i < NCH ( n ) ; ++ i ) { ch = CHILD ( n , i ) ; if ( TYPE ( ch ) == DOUBLESTAR ) break ; if ( TYPE ( ch ) == tfpdef || TYPE ( ch ) == vfpdef ) nkwonlyargs ++ ; } posargs = ( nposargs ? _Ta3_asdl_seq_new ( nposargs , c -> c_arena ) : NULL ) ; if ( ! posargs && nposargs ) return NULL ; kwonlyargs = ( nkwonlyargs ? _Ta3_asdl_seq_new ( nkwonlyargs , c -> c_arena ) : NULL ) ; if ( ! kwonlyargs && nkwonlyargs ) return NULL ; posdefaults = ( nposdefaults ? _Ta3_asdl_seq_new ( nposdefaults , c -> c_arena ) : NULL ) ; if ( ! posdefaults && nposdefaults ) return NULL ; kwdefaults = ( nkwonlyargs ? _Ta3_asdl_seq_new ( nkwonlyargs , c -> c_arena ) : NULL ) ; if ( ! kwdefaults && nkwonlyargs ) return NULL ; i = 0 ; j = 0 ; k = 0 ; while ( i < NCH ( n ) ) { ch = CHILD ( n , i ) ; switch ( TYPE ( ch ) ) { case tfpdef : case vfpdef : if ( i + 1 < NCH ( n ) && TYPE ( CHILD ( n , i + 1 ) ) == EQUAL ) { expr_ty expression = ast_for_expr ( c , CHILD ( n , i + 2 ) ) ; if ( ! expression ) return NULL ; assert ( posdefaults != NULL ) ; asdl_seq_SET ( posdefaults , j ++ , expression ) ; i += 2 ; found_default = 1 ; } else if ( found_default ) { ast_error ( c , n , ""non-default<S2SV_blank>argument<S2SV_blank>follows<S2SV_blank>default<S2SV_blank>argument"" ) ; return NULL ; } arg = ast_for_arg ( c , ch ) ; if ( ! arg ) return NULL ; asdl_seq_SET ( posargs , k ++ , arg ) ; i += 1 ; if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == COMMA ) i += 1 ; break ; case STAR : if ( i + 1 >= NCH ( n ) || ( i + 2 == NCH ( n ) && ( TYPE ( CHILD ( n , i + 1 ) ) == COMMA || TYPE ( CHILD ( n , i + 1 ) ) == TYPE_COMMENT ) ) ) { ast_error ( c , CHILD ( n , i ) , ""named<S2SV_blank>arguments<S2SV_blank>must<S2SV_blank>follow<S2SV_blank>bare<S2SV_blank>*"" ) ; return NULL ; } ch = CHILD ( n , i + 1 ) ; if ( TYPE ( ch ) == COMMA ) { int res = 0 ; i += 2 ; if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == TYPE_COMMENT ) { ast_error ( c , CHILD ( n , i ) , ""bare<S2SV_blank>*<S2SV_blank>has<S2SV_blank>associated<S2SV_blank>type<S2SV_blank>comment"" ) ; return NULL ; } res = handle_keywordonly_args ( c , n , i , kwonlyargs , kwdefaults ) ; if ( res == - 1 ) return NULL ; i = res ; } else { vararg = ast_for_arg ( c , ch ) ; if ( ! vararg ) return NULL ; i += 2 ; if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == COMMA ) i += 1 ; if ( i < NCH ( n ) && TYPE ( CHILD ( n , i ) ) == TYPE_COMMENT ) { vararg -> type_comment = NEW_TYPE_COMMENT ( CHILD ( n , i ) ) ; if ( ! vararg -> type_comment ) return NULL ; i += 1 ; } if ( i < NCH ( n ) && ( TYPE ( CHILD ( n , i ) ) == tfpdef || TYPE ( CHILD ( n , i ) ) == vfpdef ) ) { int res = 0 ; res = handle_keywordonly_args ( c , n , i , kwonlyargs , kwdefaults ) ; if ( res == - 1 ) return NULL ; i = res ; } } break ; case DOUBLESTAR : ch = CHILD ( n , i + 1 ) ; assert ( TYPE ( ch ) == tfpdef || TYPE ( ch ) == vfpdef ) ; kwarg = ast_for_arg ( c , ch ) ; if ( ! kwarg ) return NULL ; i += 2 ; <S2SV_StartBug> if ( TYPE ( CHILD ( n , i ) ) == COMMA ) <S2SV_EndBug> i += 1 ; break ; case TYPE_COMMENT : assert ( i ) ; if ( kwarg ) arg = kwarg ; arg -> type_comment = NEW_TYPE_COMMENT ( ch ) ; if ( ! arg -> type_comment ) return NULL ; i += 1 ; break ; default : PyErr_Format ( PyExc_SystemError , ""unexpected<S2SV_blank>node<S2SV_blank>in<S2SV_blank>varargslist:<S2SV_blank>%d<S2SV_blank>@<S2SV_blank>%d"" , TYPE ( ch ) , i ) ; return NULL ; } } return arguments ( posargs , vararg , kwonlyargs , kwdefaults , kwarg , posdefaults , c -> c_arena ) ; }",; if ( i < NCH ( n ) &&
370,"int oidc_oauth_check_userid ( request_rec * r , oidc_cfg * c ) { if ( ! ap_is_initial_req ( r ) ) { if ( r -> main != NULL ) r -> user = r -> main -> user ; else if ( r -> prev != NULL ) r -> user = r -> prev -> user ; if ( r -> user != NULL ) { oidc_debug ( r , ""recycling<S2SV_blank>user<S2SV_blank>\'%s\'<S2SV_blank>from<S2SV_blank>initial<S2SV_blank>request<S2SV_blank>for<S2SV_blank>sub-request"" , r -> user ) ; return OK ; } } else if ( ( c -> redirect_uri != NULL ) && ( oidc_util_request_matches_url ( r , c -> redirect_uri ) ) ) { if ( oidc_util_request_has_parameter ( r , ""jwks"" ) ) { return oidc_handle_jwks ( r , c ) ; } } const char * access_token = NULL ; if ( oidc_oauth_get_bearer_token ( r , & access_token ) == FALSE ) return oidc_oauth_return_www_authenticate ( r , ""invalid_request"" , ""No<S2SV_blank>bearer<S2SV_blank>token<S2SV_blank>found<S2SV_blank>in<S2SV_blank>the<S2SV_blank>request"" ) ; json_t * token = NULL ; char * s_token = NULL ; if ( c -> oauth . introspection_endpoint_url != NULL ) { if ( oidc_oauth_resolve_access_token ( r , c , access_token , & token , & s_token ) == FALSE ) return oidc_oauth_return_www_authenticate ( r , ""invalid_token"" , ""Reference<S2SV_blank>token<S2SV_blank>could<S2SV_blank>not<S2SV_blank>be<S2SV_blank>introspected"" ) ; } else { if ( oidc_oauth_validate_jwt_access_token ( r , c , access_token , & token , & s_token ) == FALSE ) return oidc_oauth_return_www_authenticate ( r , ""invalid_token"" , ""JWT<S2SV_blank>token<S2SV_blank>could<S2SV_blank>not<S2SV_blank>be<S2SV_blank>validated"" ) ; } if ( token == NULL ) { oidc_error ( r , ""could<S2SV_blank>not<S2SV_blank>resolve<S2SV_blank>claims<S2SV_blank>(token<S2SV_blank>==<S2SV_blank>NULL)"" ) ; return oidc_oauth_return_www_authenticate ( r , ""invalid_token"" , ""No<S2SV_blank>claims<S2SV_blank>could<S2SV_blank>be<S2SV_blank>parsed<S2SV_blank>from<S2SV_blank>the<S2SV_blank>token"" ) ; } oidc_request_state_set ( r , OIDC_CLAIMS_SESSION_KEY , ( const char * ) s_token ) ; if ( oidc_oauth_set_remote_user ( r , c , token ) == FALSE ) { oidc_error ( r , ""remote<S2SV_blank>user<S2SV_blank>could<S2SV_blank>not<S2SV_blank>be<S2SV_blank>set,<S2SV_blank>aborting<S2SV_blank>with<S2SV_blank>HTTP_UNAUTHORIZED"" ) ; return oidc_oauth_return_www_authenticate ( r , ""invalid_token"" , ""Could<S2SV_blank>not<S2SV_blank>set<S2SV_blank>remote<S2SV_blank>user"" ) ; } <S2SV_StartBug> char * authn_header = oidc_cfg_dir_authn_header ( r ) ; <S2SV_EndBug> int pass_headers = oidc_cfg_dir_pass_info_in_headers ( r ) ; int pass_envvars = oidc_cfg_dir_pass_info_in_envvars ( r ) ; if ( ( r -> user != NULL ) && ( authn_header != NULL ) ) { oidc_debug ( r , ""setting<S2SV_blank>authn<S2SV_blank>header<S2SV_blank>(%s)<S2SV_blank>to:<S2SV_blank>%s"" , authn_header , r -> user ) ; apr_table_set ( r -> headers_in , authn_header , r -> user ) ; } oidc_util_set_app_infos ( r , token , c -> claim_prefix , c -> claim_delimiter , pass_headers , pass_envvars ) ; if ( access_token != NULL ) { oidc_util_set_app_info ( r , ""access_token"" , access_token , OIDC_DEFAULT_HEADER_PREFIX , pass_headers , pass_envvars ) ; } json_decref ( token ) ; return OK ; }",) ; } oidc_scrub_headers ( r ) ;
371,"unsigned int oom_badness ( struct task_struct * p , struct mem_cgroup * mem , const nodemask_t * nodemask , unsigned long totalpages ) { <S2SV_StartBug> int points ; <S2SV_EndBug> if ( oom_unkillable_task ( p , mem , nodemask ) ) return 0 ; p = find_lock_task_mm ( p ) ; if ( ! p ) return 0 ; if ( atomic_read ( & p -> mm -> oom_disable_count ) ) { task_unlock ( p ) ; return 0 ; } if ( ! totalpages ) totalpages = 1 ; points = get_mm_rss ( p -> mm ) + p -> mm -> nr_ptes ; points += get_mm_counter ( p -> mm , MM_SWAPENTS ) ; points *= 1000 ; points /= totalpages ; task_unlock ( p ) ; if ( has_capability_noaudit ( p , CAP_SYS_ADMIN ) ) points -= 30 ; points += p -> signal -> oom_score_adj ; if ( points <= 0 ) return 1 ; return ( points < 1000 ) ? points : 1000 ; }",totalpages ) { long <S2SV_ModEnd> points ; if
372,"static void cmdloop ( void ) { int c ; int usinguid , havepartition , havenamespace , recursive ; static struct buf tag , cmd , arg1 , arg2 , arg3 ; char * p , shut [ MAX_MAILBOX_PATH + 1 ] , cmdname [ 100 ] ; const char * err ; const char * commandmintimer ; double commandmintimerd = 0.0 ; struct sync_reserve_list * reserve_list = sync_reserve_list_create ( SYNC_MESSAGE_LIST_HASH_SIZE ) ; struct applepushserviceargs applepushserviceargs ; prot_printf ( imapd_out , ""*<S2SV_blank>OK<S2SV_blank>[CAPABILITY<S2SV_blank>"" ) ; capa_response ( CAPA_PREAUTH ) ; prot_printf ( imapd_out , ""]"" ) ; if ( config_serverinfo ) prot_printf ( imapd_out , ""<S2SV_blank>%s"" , config_servername ) ; if ( config_serverinfo == IMAP_ENUM_SERVERINFO_ON ) { prot_printf ( imapd_out , ""<S2SV_blank>Cyrus<S2SV_blank>IMAP<S2SV_blank>%s"" , cyrus_version ( ) ) ; } prot_printf ( imapd_out , ""<S2SV_blank>server<S2SV_blank>ready\\r\\n"" ) ; cmd_cancelled ( ) ; motd_file ( ) ; commandmintimer = config_getstring ( IMAPOPT_COMMANDMINTIMER ) ; cmdtime_settimer ( commandmintimer ? 1 : 0 ) ; if ( commandmintimer ) { commandmintimerd = atof ( commandmintimer ) ; } for ( ; ; ) { index_release ( imapd_index ) ; prot_flush ( imapd_out ) ; if ( backend_current ) prot_flush ( backend_current -> out ) ; proc_register ( config_ident , imapd_clienthost , imapd_userid , index_mboxname ( imapd_index ) , NULL ) ; if ( ! imapd_userisadmin && imapd_userid && ( shutdown_file ( shut , sizeof ( shut ) ) || userdeny ( imapd_userid , config_ident , shut , sizeof ( shut ) ) ) ) { for ( p = shut ; * p == '[' ; p ++ ) ; prot_printf ( imapd_out , ""*<S2SV_blank>BYE<S2SV_blank>[ALERT]<S2SV_blank>%s\\r\\n"" , p ) ; telemetry_rusage ( imapd_userid ) ; shut_down ( 0 ) ; } signals_poll ( ) ; if ( ! proxy_check_input ( protin , imapd_in , imapd_out , backend_current ? backend_current -> in : NULL , NULL , 0 ) ) { continue ; } c = getword ( imapd_in , & tag ) ; if ( c == EOF ) { if ( ( err = prot_error ( imapd_in ) ) != NULL && strcmp ( err , PROT_EOF_STRING ) ) { syslog ( LOG_WARNING , ""%s,<S2SV_blank>closing<S2SV_blank>connection"" , err ) ; prot_printf ( imapd_out , ""*<S2SV_blank>BYE<S2SV_blank>%s\\r\\n"" , err ) ; } goto done ; } if ( c != '<S2SV_blank>' || ! imparse_isatom ( tag . s ) || ( tag . s [ 0 ] == '*' && ! tag . s [ 1 ] ) ) { prot_printf ( imapd_out , ""*<S2SV_blank>BAD<S2SV_blank>Invalid<S2SV_blank>tag\\r\\n"" ) ; eatline ( imapd_in , c ) ; continue ; } c = getword ( imapd_in , & cmd ) ; if ( ! cmd . s [ 0 ] ) { prot_printf ( imapd_out , ""%s<S2SV_blank>BAD<S2SV_blank>Null<S2SV_blank>command\\r\\n"" , tag . s ) ; eatline ( imapd_in , c ) ; continue ; } lcase ( cmd . s ) ; xstrncpy ( cmdname , cmd . s , 99 ) ; cmd . s [ 0 ] = toupper ( ( unsigned char ) cmd . s [ 0 ] ) ; if ( config_getswitch ( IMAPOPT_CHATTY ) ) syslog ( LOG_NOTICE , ""command:<S2SV_blank>%s<S2SV_blank>%s"" , tag . s , cmd . s ) ; proc_register ( config_ident , imapd_clienthost , imapd_userid , index_mboxname ( imapd_index ) , cmd . s ) ; if ( referral_kick ) { kick_mupdate ( ) ; referral_kick = 0 ; } if ( plaintextloginalert ) { prot_printf ( imapd_out , ""*<S2SV_blank>OK<S2SV_blank>[ALERT]<S2SV_blank>%s\\r\\n"" , plaintextloginalert ) ; plaintextloginalert = NULL ; } if ( ! imapd_userid && ! strchr ( ""AELNCIS"" , cmd . s [ 0 ] ) ) goto nologin ; cmdtime_starttimer ( ) ; switch ( cmd . s [ 0 ] ) { case 'A' : if ( ! strcmp ( cmd . s , ""Authenticate"" ) ) { int haveinitresp = 0 ; if ( c != '<S2SV_blank>' ) goto missingargs ; c = getword ( imapd_in , & arg1 ) ; if ( ! imparse_isatom ( arg1 . s ) ) { prot_printf ( imapd_out , ""%s<S2SV_blank>BAD<S2SV_blank>Invalid<S2SV_blank>authenticate<S2SV_blank>mechanism\\r\\n"" , tag . s ) ; eatline ( imapd_in , c ) ; continue ; } if ( c == '<S2SV_blank>' ) { haveinitresp = 1 ; c = getword ( imapd_in , & arg2 ) ; if ( c == EOF ) goto missingargs ; } if ( c == '\\r' ) c = prot_getc ( imapd_in ) ; if ( c != '\\n' ) goto extraargs ; if ( imapd_userid ) { prot_printf ( imapd_out , ""%s<S2SV_blank>BAD<S2SV_blank>Already<S2SV_blank>authenticated\\r\\n"" , tag . s ) ; continue ; } cmd_authenticate ( tag . s , arg1 . s , haveinitresp ? arg2 . s : NULL ) ; snmp_increment ( AUTHENTICATE_COUNT , 1 ) ; } else if ( ! imapd_userid ) goto nologin ; else if ( ! strcmp ( cmd . s , ""Append"" ) ) { if ( c != '<S2SV_blank>' ) goto missingargs ; c = getastring ( imapd_in , imapd_out , & arg1 ) ; if ( c != '<S2SV_blank>' ) goto missingargs ; cmd_append ( tag . s , arg1 . s , NULL ) ; snmp_increment ( APPEND_COUNT , 1 ) ; } else goto badcmd ; break ; case 'C' : if ( ! strcmp ( cmd . s , ""Capability"" ) ) { if ( c == '\\r' ) c = prot_getc ( imapd_in ) ; if ( c != '\\n' ) goto extraargs ; cmd_capability ( tag . s ) ; snmp_increment ( CAPABILITY_COUNT , 1 ) ; } else if ( ! imapd_userid ) goto nologin ; # ifdef HAVE_ZLIB else if ( ! strcmp ( cmd . s , ""Compress"" ) ) { if ( c != '<S2SV_blank>' ) goto missingargs ; c = getword ( imapd_in , & arg1 ) ; if ( c == EOF ) goto missingargs ; if ( c == '\\r' ) c = prot_getc ( imapd_in ) ; if ( c != '\\n' ) goto extraargs ; cmd_compress ( tag . s , arg1 . s ) ; snmp_increment ( COMPRESS_COUNT , 1 ) ; } # endif else if ( ! strcmp ( cmd . s , ""Check"" ) ) { if ( ! imapd_index && ! backend_current ) goto nomailbox ; if ( c == '\\r' ) c = prot_getc ( imapd_in ) ; if ( c != '\\n' ) goto extraargs ; cmd_noop ( tag . s , cmd . s ) ; snmp_increment ( CHECK_COUNT , 1 ) ; } else if ( ! strcmp ( cmd . s , ""Copy"" ) ) { if ( ! imapd_index && ! backend_current ) goto nomailbox ; usinguid = 0 ; if ( c != '<S2SV_blank>' ) goto missingargs ; copy : c = getword ( imapd_in , & arg1 ) ; if ( c == '\\r' ) goto missingargs ; if ( c != '<S2SV_blank>' || ! imparse_issequence ( arg1 . s ) ) goto badsequence ; c = getastring ( imapd_in , imapd_out , & arg2 ) ; if ( c == EOF ) goto missingargs ; if ( c == '\\r' ) c = prot_getc ( imapd_in ) ; if ( c != '\\n' ) goto extraargs ; cmd_copy ( tag . s , arg1 . s , arg2 . s , usinguid , 0 ) ; snmp_increment ( COPY_COUNT , 1 ) ; } else if ( ! strcmp ( cmd . s , ""Create"" ) ) { struct dlist * extargs = NULL ; if ( c != '<S2SV_blank>' ) goto missingargs ; c = getastring ( imapd_in , imapd_out , & arg1 ) ; if ( c == EOF ) goto missingargs ; if ( c == '<S2SV_blank>' ) { c = parsecreateargs ( & extargs ) ; if ( c == EOF ) goto badpartition ; } if ( c == '\\r' ) c = prot_getc ( imapd_in ) ; if ( c != '\\n' ) goto extraargs ; cmd_create ( tag . s , arg1 . s , extargs , 0 ) ; dlist_free ( & extargs ) ; snmp_increment ( CREATE_COUNT , 1 ) ; } else if ( ! strcmp ( cmd . s , ""Close"" ) ) { if ( ! imapd_index && ! backend_current ) goto nomailbox ; if ( c == '\\r' ) c = prot_getc ( imapd_in ) ; if ( c != '\\n' ) goto extraargs ; cmd_close ( tag . s , cmd . s ) ; snmp_increment ( CLOSE_COUNT , 1 ) ; } else goto badcmd ; break ; case 'D' : if ( ! strcmp ( cmd . s , ""Delete"" ) ) { if ( c != '<S2SV_blank>' ) goto missingargs ; c = getastring ( imapd_in , imapd_out , & arg1 ) ; if ( c == EOF ) goto missingargs ; if ( c == '\\r' ) c = prot_getc ( imapd_in ) ; if ( c != '\\n' ) goto extraargs ; cmd_delete ( tag . s , arg1 . s , 0 , 0 ) ; snmp_increment ( DELETE_COUNT , 1 ) ; } else if ( ! strcmp ( cmd . s , ""Deleteacl"" ) ) { if ( c != '<S2SV_blank>' ) goto missingargs ; c = getastring ( imapd_in , imapd_out , & arg1 ) ; if ( c != '<S2SV_blank>' ) goto missingargs ; c = getastring ( imapd_in , imapd_out , & arg2 ) ; if ( c == EOF ) goto missingargs ; if ( c == '\\r' ) c = prot_getc ( imapd_in ) ; if ( c != '\\n' ) goto extraargs ; cmd_setacl ( tag . s , arg1 . s , arg2 . s , NULL ) ; snmp_increment ( DELETEACL_COUNT , 1 ) ; } else if ( ! strcmp ( cmd . s , ""Dump"" ) ) { int uid_start = 0 ; if ( c != '<S2SV_blank>' ) goto missingargs ; c = getastring ( imapd_in , imapd_out , & arg1 ) ; if ( c == '<S2SV_blank>' ) { c = getastring ( imapd_in , imapd_out , & arg2 ) ; if ( ! imparse_isnumber ( arg2 . s ) ) goto extraargs ; uid_start = atoi ( arg2 . s ) ; } if ( c == '\\r' ) c = prot_getc ( imapd_in ) ; if ( c != '\\n' ) goto extraargs ; cmd_dump ( tag . s , arg1 . s , uid_start ) ; } else goto badcmd ; break ; case 'E' : if ( ! imapd_userid ) goto nologin ; else if ( ! strcmp ( cmd . s , ""Enable"" ) ) { if ( c != '<S2SV_blank>' ) goto missingargs ; cmd_enable ( tag . s ) ; } else if ( ! strcmp ( cmd . s , ""Expunge"" ) ) { if ( ! imapd_index && ! backend_current ) goto nomailbox ; if ( c == '\\r' ) c = prot_getc ( imapd_in ) ; if ( c != '\\n' ) goto extraargs ; cmd_expunge ( tag . s , 0 ) ; snmp_increment ( EXPUNGE_COUNT , 1 ) ; } else if ( ! strcmp ( cmd . s , ""Examine"" ) ) { if ( c != '<S2SV_blank>' ) goto missingargs ; c = getastring ( imapd_in , imapd_out , & arg1 ) ; if ( c == EOF ) goto missingargs ; prot_ungetc ( c , imapd_in ) ; cmd_select ( tag . s , cmd . s , arg1 . s ) ; snmp_increment ( EXAMINE_COUNT , 1 ) ; } else goto badcmd ; break ; case 'F' : if ( ! strcmp ( cmd . s , ""Fetch"" ) ) { if ( ! imapd_index && ! backend_current ) goto nomailbox ; usinguid = 0 ; if ( c != '<S2SV_blank>' ) goto missingargs ; fetch : c = getword ( imapd_in , & arg1 ) ; if ( c == '\\r' ) goto missingargs ; if ( c != '<S2SV_blank>' || ! imparse_issequence ( arg1 . s ) ) goto badsequence ; cmd_fetch ( tag . s , arg1 . s , usinguid ) ; snmp_increment ( FETCH_COUNT , 1 ) ; } else goto badcmd ; break ; case 'G' : if ( ! strcmp ( cmd . s , ""Getacl"" ) ) { if ( c != '<S2SV_blank>' ) goto missingargs ; c = getastring ( imapd_in , imapd_out , & arg1 ) ; if ( c == EOF ) goto missingargs ; if ( c == '\\r' ) c = prot_getc ( imapd_in ) ; if ( c != '\\n' ) goto extraargs ; cmd_getacl ( tag . s , arg1 . s ) ; snmp_increment ( GETACL_COUNT , 1 ) ; } else if ( ! strcmp ( cmd . s , ""Getannotation"" ) ) { if ( c != '<S2SV_blank>' ) goto missingargs ; c = getastring ( imapd_in , imapd_out , & arg1 ) ; if ( c != '<S2SV_blank>' ) goto missingargs ; cmd_getannotation ( tag . s , arg1 . s ) ; snmp_increment ( GETANNOTATION_COUNT , 1 ) ; } else if ( ! strcmp ( cmd . s , ""Getmetadata"" ) ) { if ( c != '<S2SV_blank>' ) goto missingargs ; cmd_getmetadata ( tag . s ) ; snmp_increment ( GETANNOTATION_COUNT , 1 ) ; } else if ( ! strcmp ( cmd . s , ""Getquota"" ) ) { if ( c != '<S2SV_blank>' ) goto missingargs ; c = getastring ( imapd_in , imapd_out , & arg1 ) ; if ( c == EOF ) goto missingargs ; if ( c == '\\r' ) c = prot_getc ( imapd_in ) ; if ( c != '\\n' ) goto extraargs ; cmd_getquota ( tag . s , arg1 . s ) ; snmp_increment ( GETQUOTA_COUNT , 1 ) ; } else if ( ! strcmp ( cmd . s , ""Getquotaroot"" ) ) { if ( c != '<S2SV_blank>' ) goto missingargs ; c = getastring ( imapd_in , imapd_out , & arg1 ) ; if ( c == EOF ) goto missingargs ; if ( c == '\\r' ) c = prot_getc ( imapd_in ) ; if ( c != '\\n' ) goto extraargs ; cmd_getquotaroot ( tag . s , arg1 . s ) ; snmp_increment ( GETQUOTAROOT_COUNT , 1 ) ; } # ifdef HAVE_SSL else if ( ! strcmp ( cmd . s , ""Genurlauth"" ) ) { if ( c != '<S2SV_blank>' ) goto missingargs ; cmd_genurlauth ( tag . s ) ; } # endif else goto badcmd ; break ; case 'I' : if ( ! strcmp ( cmd . s , ""Id"" ) ) { if ( c != '<S2SV_blank>' ) goto missingargs ; cmd_id ( tag . s ) ; snmp_increment ( ID_COUNT , 1 ) ; } else if ( ! imapd_userid ) goto nologin ; else if ( ! strcmp ( cmd . s , ""Idle"" ) && idle_enabled ( ) ) { if ( c == '\\r' ) c = prot_getc ( imapd_in ) ; if ( c != '\\n' ) goto extraargs ; cmd_idle ( tag . s ) ; snmp_increment ( IDLE_COUNT , 1 ) ; } else goto badcmd ; break ; case 'L' : if ( ! strcmp ( cmd . s , ""Login"" ) ) { if ( c != '<S2SV_blank>' ) goto missingargs ; c = getastring ( imapd_in , imapd_out , & arg1 ) ; if ( c != '<S2SV_blank>' ) goto missingargs ; cmd_login ( tag . s , arg1 . s ) ; snmp_increment ( LOGIN_COUNT , 1 ) ; } else if ( ! strcmp ( cmd . s , ""Logout"" ) ) { if ( c == '\\r' ) c = prot_getc ( imapd_in ) ; if ( c != '\\n' ) goto extraargs ; snmp_increment ( LOGOUT_COUNT , 1 ) ; if ( backend_current ) imapd_check ( NULL , 0 ) ; prot_printf ( imapd_out , ""*<S2SV_blank>BYE<S2SV_blank>%s\\r\\n"" , error_message ( IMAP_BYE_LOGOUT ) ) ; prot_printf ( imapd_out , ""%s<S2SV_blank>OK<S2SV_blank>%s\\r\\n"" , tag . s , error_message ( IMAP_OK_COMPLETED ) ) ; if ( imapd_userid && * imapd_userid ) { telemetry_rusage ( imapd_userid ) ; } goto done ; } else if ( ! imapd_userid ) goto nologin ; else if ( ! strcmp ( cmd . s , ""List"" ) ) { struct listargs listargs ; if ( c != '<S2SV_blank>' ) goto missingargs ; memset ( & listargs , 0 , sizeof ( struct listargs ) ) ; listargs . ret = LIST_RET_CHILDREN ; getlistargs ( tag . s , & listargs ) ; if ( listargs . pat . count ) cmd_list ( tag . s , & listargs ) ; snmp_increment ( LIST_COUNT , 1 ) ; } else if ( ! strcmp ( cmd . s , ""Lsub"" ) ) { struct listargs listargs ; c = getastring ( imapd_in , imapd_out , & arg1 ) ; if ( c != '<S2SV_blank>' ) goto missingargs ; c = getastring ( imapd_in , imapd_out , & arg2 ) ; if ( c == '\\r' ) c = prot_getc ( imapd_in ) ; if ( c != '\\n' ) goto extraargs ; memset ( & listargs , 0 , sizeof ( struct listargs ) ) ; listargs . cmd = LIST_CMD_LSUB ; listargs . sel = LIST_SEL_SUBSCRIBED ; if ( ! strcasecmpsafe ( imapd_magicplus , ""+dav"" ) ) listargs . sel |= LIST_SEL_DAV ; listargs . ref = arg1 . s ; strarray_append ( & listargs . pat , arg2 . s ) ; cmd_list ( tag . s , & listargs ) ; snmp_increment ( LSUB_COUNT , 1 ) ; } else if ( ! strcmp ( cmd . s , ""Listrights"" ) ) { c = getastring ( imapd_in , imapd_out , & arg1 ) ; if ( c != '<S2SV_blank>' ) goto missingargs ; c = getastring ( imapd_in , imapd_out , & arg2 ) ; if ( c == '\\r' ) c = prot_getc ( imapd_in ) ; if ( c != '\\n' ) goto extraargs ; cmd_listrights ( tag . s , arg1 . s , arg2 . s ) ; snmp_increment ( LISTRIGHTS_COUNT , 1 ) ; } else if ( ! strcmp ( cmd . s , ""Localappend"" ) ) { if ( c != '<S2SV_blank>' ) goto missingargs ; c = getastring ( imapd_in , imapd_out , & arg1 ) ; if ( c != '<S2SV_blank>' ) goto missingargs ; c = getastring ( imapd_in , imapd_out , & arg2 ) ; if ( c != '<S2SV_blank>' ) goto missingargs ; cmd_append ( tag . s , arg1 . s , * arg2 . s ? arg2 . s : NULL ) ; snmp_increment ( APPEND_COUNT , 1 ) ; } else if ( ! strcmp ( cmd . s , ""Localcreate"" ) ) { struct dlist * extargs = NULL ; if ( c != '<S2SV_blank>' ) goto missingargs ; c = getastring ( imapd_in , imapd_out , & arg1 ) ; if ( c == EOF ) goto missingargs ; if ( c == '<S2SV_blank>' ) { c = parsecreateargs ( & extargs ) ; if ( c == EOF ) goto badpartition ; } if ( c == '\\r' ) c = prot_getc ( imapd_in ) ; if ( c != '\\n' ) goto extraargs ; cmd_create ( tag . s , arg1 . s , extargs , 1 ) ; dlist_free ( & extargs ) ; } else if ( ! strcmp ( cmd . s , ""Localdelete"" ) ) { if ( c != '<S2SV_blank>' ) goto missingargs ; c = getastring ( imapd_in , imapd_out , & arg1 ) ; if ( c == EOF ) goto missingargs ; if ( c == '\\r' ) c = prot_getc ( imapd_in ) ; if ( c != '\\n' ) goto extraargs ; cmd_delete ( tag . s , arg1 . s , 1 , 1 ) ; } else goto badcmd ; break ; case 'M' : if ( ! strcmp ( cmd . s , ""Myrights"" ) ) { if ( c != '<S2SV_blank>' ) goto missingargs ; c = getastring ( imapd_in , imapd_out , & arg1 ) ; if ( c == EOF ) goto missingargs ; if ( c == '\\r' ) c = prot_getc ( imapd_in ) ; if ( c != '\\n' ) goto extraargs ; cmd_myrights ( tag . s , arg1 . s ) ; } else if ( ! strcmp ( cmd . s , ""Mupdatepush"" ) ) { if ( c != '<S2SV_blank>' ) goto missingargs ; c = getastring ( imapd_in , imapd_out , & arg1 ) ; if ( c == EOF ) goto missingargs ; if ( c == '\\r' ) c = prot_getc ( imapd_in ) ; if ( c != '\\n' ) goto extraargs ; cmd_mupdatepush ( tag . s , arg1 . s ) ; } else if ( ! strcmp ( cmd . s , ""Move"" ) ) { if ( ! imapd_index && ! backend_current ) goto nomailbox ; usinguid = 0 ; if ( c != '<S2SV_blank>' ) goto missingargs ; move : c = getword ( imapd_in , & arg1 ) ; if ( c == '\\r' ) goto missingargs ; if ( c != '<S2SV_blank>' || ! imparse_issequence ( arg1 . s ) ) goto badsequence ; c = getastring ( imapd_in , imapd_out , & arg2 ) ; if ( c == EOF ) goto missingargs ; if ( c == '\\r' ) c = prot_getc ( imapd_in ) ; if ( c != '\\n' ) goto extraargs ; cmd_copy ( tag . s , arg1 . s , arg2 . s , usinguid , 1 ) ; snmp_increment ( COPY_COUNT , 1 ) ; } else goto badcmd ; break ; case 'N' : if ( ! strcmp ( cmd . s , ""Noop"" ) ) { if ( c == '\\r' ) c = prot_getc ( imapd_in ) ; if ( c != '\\n' ) goto extraargs ; cmd_noop ( tag . s , cmd . s ) ; } else if ( ! imapd_userid ) goto nologin ; else if ( ! strcmp ( cmd . s , ""Namespace"" ) ) { if ( c == '\\r' ) c = prot_getc ( imapd_in ) ; if ( c != '\\n' ) goto extraargs ; cmd_namespace ( tag . s ) ; } else goto badcmd ; break ; case 'R' : if ( ! strcmp ( cmd . s , ""Rename"" ) ) { havepartition = 0 ; if ( c != '<S2SV_blank>' ) goto missingargs ; c = getastring ( imapd_in , imapd_out , & arg1 ) ; if ( c != '<S2SV_blank>' ) goto missingargs ; c = getastring ( imapd_in , imapd_out , & arg2 ) ; if ( c == EOF ) goto missingargs ; if ( c == '<S2SV_blank>' ) { havepartition = 1 ; c = getword ( imapd_in , & arg3 ) ; if ( ! imparse_isatom ( arg3 . s ) ) goto badpartition ; } if ( c == '\\r' ) c = prot_getc ( imapd_in ) ; if ( c != '\\n' ) goto extraargs ; cmd_rename ( tag . s , arg1 . s , arg2 . s , havepartition ? arg3 . s : 0 ) ; } else if ( ! strcmp ( cmd . s , ""Reconstruct"" ) ) { recursive = 0 ; if ( c != '<S2SV_blank>' ) goto missingargs ; c = getastring ( imapd_in , imapd_out , & arg1 ) ; if ( c == '<S2SV_blank>' ) { c = getword ( imapd_in , & arg2 ) ; if ( ! imparse_isatom ( arg2 . s ) ) goto extraargs ; else if ( ! strcasecmp ( arg2 . s , ""RECURSIVE"" ) ) recursive = 1 ; else goto extraargs ; } if ( c == '\\r' ) c = prot_getc ( imapd_in ) ; if ( c != '\\n' ) goto extraargs ; cmd_reconstruct ( tag . s , arg1 . s , recursive ) ; } else if ( ! strcmp ( cmd . s , ""Rlist"" ) ) { struct listargs listargs ; c = getastring ( imapd_in , imapd_out , & arg1 ) ; if ( c != '<S2SV_blank>' ) goto missingargs ; c = getastring ( imapd_in , imapd_out , & arg2 ) ; if ( c == '\\r' ) c = prot_getc ( imapd_in ) ; if ( c != '\\n' ) goto extraargs ; memset ( & listargs , 0 , sizeof ( struct listargs ) ) ; listargs . sel = LIST_SEL_REMOTE ; listargs . ret = LIST_RET_CHILDREN ; listargs . ref = arg1 . s ; strarray_append ( & listargs . pat , arg2 . s ) ; cmd_list ( tag . s , & listargs ) ; } else if ( ! strcmp ( cmd . s , ""Rlsub"" ) ) { struct listargs listargs ; c = getastring ( imapd_in , imapd_out , & arg1 ) ; if ( c != '<S2SV_blank>' ) goto missingargs ; c = getastring ( imapd_in , imapd_out , & arg2 ) ; if ( c == '\\r' ) c = prot_getc ( imapd_in ) ; if ( c != '\\n' ) goto extraargs ; memset ( & listargs , 0 , sizeof ( struct listargs ) ) ; listargs . cmd = LIST_CMD_LSUB ; listargs . sel = LIST_SEL_REMOTE | LIST_SEL_SUBSCRIBED ; listargs . ref = arg1 . s ; strarray_append ( & listargs . pat , arg2 . s ) ; cmd_list ( tag . s , & listargs ) ; } # ifdef HAVE_SSL else if ( ! strcmp ( cmd . s , ""Resetkey"" ) ) { int have_mbox = 0 , have_mech = 0 ; if ( c == '<S2SV_blank>' ) { have_mbox = 1 ; c = getastring ( imapd_in , imapd_out , & arg1 ) ; if ( c == EOF ) goto missingargs ; if ( c == '<S2SV_blank>' ) { have_mech = 1 ; c = getword ( imapd_in , & arg2 ) ; } } if ( c == '\\r' ) c = prot_getc ( imapd_in ) ; if ( c != '\\n' ) goto extraargs ; cmd_resetkey ( tag . s , have_mbox ? arg1 . s : 0 , have_mech ? arg2 . s : 0 ) ; } # endif else goto badcmd ; break ; case 'S' : if ( ! strcmp ( cmd . s , ""Starttls"" ) ) { if ( ! tls_enabled ( ) ) { goto badcmd ; } if ( c == '\\r' ) c = prot_getc ( imapd_in ) ; if ( c != '\\n' ) goto extraargs ; prot_flush ( imapd_in ) ; if ( imapd_userid != NULL ) { prot_printf ( imapd_out , ""%s<S2SV_blank>BAD<S2SV_blank>Can\'t<S2SV_blank>Starttls<S2SV_blank>after<S2SV_blank>authentication\\r\\n"" , tag . s ) ; continue ; } if ( imapd_compress_done == 1 ) { prot_printf ( imapd_out , ""%s<S2SV_blank>BAD<S2SV_blank>Can\'t<S2SV_blank>Starttls<S2SV_blank>after<S2SV_blank>Compress\\r\\n"" , tag . s ) ; continue ; } if ( imapd_starttls_done == 1 ) { prot_printf ( imapd_out , ""%s<S2SV_blank>BAD<S2SV_blank>Already<S2SV_blank>did<S2SV_blank>a<S2SV_blank>successful<S2SV_blank>Starttls\\r\\n"" , tag . s ) ; continue ; } cmd_starttls ( tag . s , 0 ) ; snmp_increment ( STARTTLS_COUNT , 1 ) ; continue ; } if ( ! imapd_userid ) { goto nologin ; } else if ( ! strcmp ( cmd . s , ""Store"" ) ) { if ( ! imapd_index && ! backend_current ) goto nomailbox ; usinguid = 0 ; if ( c != '<S2SV_blank>' ) goto missingargs ; store : c = getword ( imapd_in , & arg1 ) ; if ( c != '<S2SV_blank>' || ! imparse_issequence ( arg1 . s ) ) goto badsequence ; cmd_store ( tag . s , arg1 . s , usinguid ) ; snmp_increment ( STORE_COUNT , 1 ) ; } else if ( ! strcmp ( cmd . s , ""Select"" ) ) { if ( c != '<S2SV_blank>' ) goto missingargs ; c = getastring ( imapd_in , imapd_out , & arg1 ) ; if ( c == EOF ) goto missingargs ; prot_ungetc ( c , imapd_in ) ; cmd_select ( tag . s , cmd . s , arg1 . s ) ; snmp_increment ( SELECT_COUNT , 1 ) ; } else if ( ! strcmp ( cmd . s , ""Search"" ) ) { if ( ! imapd_index && ! backend_current ) goto nomailbox ; usinguid = 0 ; if ( c != '<S2SV_blank>' ) goto missingargs ; search : cmd_search ( tag . s , usinguid ) ; snmp_increment ( SEARCH_COUNT , 1 ) ; } else if ( ! strcmp ( cmd . s , ""Subscribe"" ) ) { if ( c != '<S2SV_blank>' ) goto missingargs ; havenamespace = 0 ; c = getastring ( imapd_in , imapd_out , & arg1 ) ; if ( c == '<S2SV_blank>' ) { havenamespace = 1 ; c = getastring ( imapd_in , imapd_out , & arg2 ) ; } if ( c == EOF ) goto missingargs ; if ( c == '\\r' ) c = prot_getc ( imapd_in ) ; if ( c != '\\n' ) goto extraargs ; if ( havenamespace ) { cmd_changesub ( tag . s , arg1 . s , arg2 . s , 1 ) ; } else { cmd_changesub ( tag . s , ( char * ) 0 , arg1 . s , 1 ) ; } snmp_increment ( SUBSCRIBE_COUNT , 1 ) ; } else if ( ! strcmp ( cmd . s , ""Setacl"" ) ) { if ( c != '<S2SV_blank>' ) goto missingargs ; c = getastring ( imapd_in , imapd_out , & arg1 ) ; if ( c != '<S2SV_blank>' ) goto missingargs ; c = getastring ( imapd_in , imapd_out , & arg2 ) ; if ( c != '<S2SV_blank>' ) goto missingargs ; c = getastring ( imapd_in , imapd_out , & arg3 ) ; if ( c == EOF ) goto missingargs ; if ( c == '\\r' ) c = prot_getc ( imapd_in ) ; if ( c != '\\n' ) goto extraargs ; cmd_setacl ( tag . s , arg1 . s , arg2 . s , arg3 . s ) ; snmp_increment ( SETACL_COUNT , 1 ) ; } else if ( ! strcmp ( cmd . s , ""Setannotation"" ) ) { if ( c != '<S2SV_blank>' ) goto missingargs ; c = getastring ( imapd_in , imapd_out , & arg1 ) ; if ( c != '<S2SV_blank>' ) goto missingargs ; cmd_setannotation ( tag . s , arg1 . s ) ; snmp_increment ( SETANNOTATION_COUNT , 1 ) ; } else if ( ! strcmp ( cmd . s , ""Setmetadata"" ) ) { if ( c != '<S2SV_blank>' ) goto missingargs ; c = getastring ( imapd_in , imapd_out , & arg1 ) ; if ( c != '<S2SV_blank>' ) goto missingargs ; cmd_setmetadata ( tag . s , arg1 . s ) ; snmp_increment ( SETANNOTATION_COUNT , 1 ) ; } else if ( ! strcmp ( cmd . s , ""Setquota"" ) ) { if ( c != '<S2SV_blank>' ) goto missingargs ; c = getastring ( imapd_in , imapd_out , & arg1 ) ; if ( c != '<S2SV_blank>' ) goto missingargs ; cmd_setquota ( tag . s , arg1 . s ) ; snmp_increment ( SETQUOTA_COUNT , 1 ) ; } else if ( ! strcmp ( cmd . s , ""Sort"" ) ) { if ( ! imapd_index && ! backend_current ) goto nomailbox ; usinguid = 0 ; if ( c != '<S2SV_blank>' ) goto missingargs ; sort : cmd_sort ( tag . s , usinguid ) ; snmp_increment ( SORT_COUNT , 1 ) ; } else if ( ! strcmp ( cmd . s , ""Status"" ) ) { if ( c != '<S2SV_blank>' ) goto missingargs ; c = getastring ( imapd_in , imapd_out , & arg1 ) ; if ( c != '<S2SV_blank>' ) goto missingargs ; cmd_status ( tag . s , arg1 . s ) ; snmp_increment ( STATUS_COUNT , 1 ) ; } else if ( ! strcmp ( cmd . s , ""Scan"" ) ) { struct listargs listargs ; c = getastring ( imapd_in , imapd_out , & arg1 ) ; if ( c != '<S2SV_blank>' ) goto missingargs ; c = getastring ( imapd_in , imapd_out , & arg2 ) ; if ( c != '<S2SV_blank>' ) goto missingargs ; c = getastring ( imapd_in , imapd_out , & arg3 ) ; if ( c == '\\r' ) c = prot_getc ( imapd_in ) ; if ( c != '\\n' ) goto extraargs ; memset ( & listargs , 0 , sizeof ( struct listargs ) ) ; listargs . ref = arg1 . s ; strarray_append ( & listargs . pat , arg2 . s ) ; listargs . scan = arg3 . s ; cmd_list ( tag . s , & listargs ) ; snmp_increment ( SCAN_COUNT , 1 ) ; } else if ( ! strcmp ( cmd . s , ""Syncapply"" ) ) { <S2SV_StartBug> struct dlist * kl = sync_parseline ( imapd_in ) ; <S2SV_EndBug> if ( kl ) { cmd_syncapply ( tag . s , kl , reserve_list ) ; dlist_free ( & kl ) ; } else goto extraargs ; } else if ( ! strcmp ( cmd . s , ""Syncget"" ) ) { <S2SV_StartBug> struct dlist * kl = sync_parseline ( imapd_in ) ; <S2SV_EndBug> if ( kl ) { cmd_syncget ( tag . s , kl ) ; dlist_free ( & kl ) ; } else goto extraargs ; } else if ( ! strcmp ( cmd . s , ""Syncrestart"" ) ) { <S2SV_StartBug> if ( c == '\\r' ) c = prot_getc ( imapd_in ) ; <S2SV_EndBug> if ( c != '\\n' ) goto extraargs ; cmd_syncrestart ( tag . s , & reserve_list , 1 ) ; } <S2SV_StartBug> else if ( ! strcmp ( cmd . s , ""Syncrestore"" ) ) { <S2SV_EndBug> struct dlist * kl = sync_parseline ( imapd_in ) ; if ( kl ) { cmd_syncrestore ( tag . s , kl , reserve_list ) ; dlist_free ( & kl ) ; } else goto extraargs ; } else goto badcmd ; break ; case 'T' : if ( ! strcmp ( cmd . s , ""Thread"" ) ) { if ( ! imapd_index && ! backend_current ) goto nomailbox ; usinguid = 0 ; if ( c != '<S2SV_blank>' ) goto missingargs ; thread : cmd_thread ( tag . s , usinguid ) ; snmp_increment ( THREAD_COUNT , 1 ) ; } else goto badcmd ; break ; case 'U' : if ( ! strcmp ( cmd . s , ""Uid"" ) ) { if ( ! imapd_index && ! backend_current ) goto nomailbox ; usinguid = 1 ; if ( c != '<S2SV_blank>' ) goto missingargs ; c = getword ( imapd_in , & arg1 ) ; if ( c != '<S2SV_blank>' ) goto missingargs ; lcase ( arg1 . s ) ; xstrncpy ( cmdname , arg1 . s , 99 ) ; if ( ! strcmp ( arg1 . s , ""fetch"" ) ) { goto fetch ; } else if ( ! strcmp ( arg1 . s , ""store"" ) ) { goto store ; } else if ( ! strcmp ( arg1 . s , ""search"" ) ) { goto search ; } else if ( ! strcmp ( arg1 . s , ""sort"" ) ) { goto sort ; } else if ( ! strcmp ( arg1 . s , ""thread"" ) ) { goto thread ; } else if ( ! strcmp ( arg1 . s , ""copy"" ) ) { goto copy ; } else if ( ! strcmp ( arg1 . s , ""move"" ) ) { goto move ; } else if ( ! strcmp ( arg1 . s , ""xmove"" ) ) { goto move ; } else if ( ! strcmp ( arg1 . s , ""expunge"" ) ) { c = getword ( imapd_in , & arg1 ) ; if ( ! imparse_issequence ( arg1 . s ) ) goto badsequence ; if ( c == '\\r' ) c = prot_getc ( imapd_in ) ; if ( c != '\\n' ) goto extraargs ; cmd_expunge ( tag . s , arg1 . s ) ; snmp_increment ( EXPUNGE_COUNT , 1 ) ; } else if ( ! strcmp ( arg1 . s , ""xrunannotator"" ) ) { goto xrunannotator ; } else { prot_printf ( imapd_out , ""%s<S2SV_blank>BAD<S2SV_blank>Unrecognized<S2SV_blank>UID<S2SV_blank>subcommand\\r\\n"" , tag . s ) ; eatline ( imapd_in , c ) ; } } else if ( ! strcmp ( cmd . s , ""Unsubscribe"" ) ) { if ( c != '<S2SV_blank>' ) goto missingargs ; havenamespace = 0 ; c = getastring ( imapd_in , imapd_out , & arg1 ) ; if ( c == '<S2SV_blank>' ) { havenamespace = 1 ; c = getastring ( imapd_in , imapd_out , & arg2 ) ; } if ( c == EOF ) goto missingargs ; if ( c == '\\r' ) c = prot_getc ( imapd_in ) ; if ( c != '\\n' ) goto extraargs ; if ( havenamespace ) { cmd_changesub ( tag . s , arg1 . s , arg2 . s , 0 ) ; } else { cmd_changesub ( tag . s , ( char * ) 0 , arg1 . s , 0 ) ; } snmp_increment ( UNSUBSCRIBE_COUNT , 1 ) ; } else if ( ! strcmp ( cmd . s , ""Unselect"" ) ) { if ( ! imapd_index && ! backend_current ) goto nomailbox ; if ( c == '\\r' ) c = prot_getc ( imapd_in ) ; if ( c != '\\n' ) goto extraargs ; cmd_close ( tag . s , cmd . s ) ; snmp_increment ( UNSELECT_COUNT , 1 ) ; } else if ( ! strcmp ( cmd . s , ""Undump"" ) ) { if ( c != '<S2SV_blank>' ) goto missingargs ; c = getastring ( imapd_in , imapd_out , & arg1 ) ; if ( c != '<S2SV_blank>' ) goto missingargs ; cmd_undump ( tag . s , arg1 . s ) ; } # ifdef HAVE_SSL else if ( ! strcmp ( cmd . s , ""Urlfetch"" ) ) { if ( c != '<S2SV_blank>' ) goto missingargs ; cmd_urlfetch ( tag . s ) ; } # endif else goto badcmd ; break ; case 'X' : if ( ! strcmp ( cmd . s , ""Xbackup"" ) ) { int havechannel = 0 ; if ( ! config_getswitch ( IMAPOPT_XBACKUP_ENABLED ) ) goto badcmd ; if ( c != '<S2SV_blank>' ) goto missingargs ; c = getastring ( imapd_in , imapd_out , & arg1 ) ; if ( c == '<S2SV_blank>' ) { havechannel = 1 ; c = getword ( imapd_in , & arg2 ) ; if ( c == EOF ) goto missingargs ; } if ( c == '\\r' ) c = prot_getc ( imapd_in ) ; if ( c != '\\n' ) goto extraargs ; cmd_xbackup ( tag . s , arg1 . s , havechannel ? arg2 . s : NULL ) ; } else if ( ! strcmp ( cmd . s , ""Xconvfetch"" ) ) { cmd_xconvfetch ( tag . s ) ; } else if ( ! strcmp ( cmd . s , ""Xconvmultisort"" ) ) { if ( c != '<S2SV_blank>' ) goto missingargs ; if ( ! imapd_index && ! backend_current ) goto nomailbox ; cmd_xconvmultisort ( tag . s ) ; } else if ( ! strcmp ( cmd . s , ""Xconvsort"" ) ) { if ( c != '<S2SV_blank>' ) goto missingargs ; if ( ! imapd_index && ! backend_current ) goto nomailbox ; cmd_xconvsort ( tag . s , 0 ) ; } else if ( ! strcmp ( cmd . s , ""Xconvupdates"" ) ) { if ( c != '<S2SV_blank>' ) goto missingargs ; if ( ! imapd_index && ! backend_current ) goto nomailbox ; cmd_xconvsort ( tag . s , 1 ) ; } else if ( ! strcmp ( cmd . s , ""Xfer"" ) ) { int havepartition = 0 ; if ( c != '<S2SV_blank>' ) goto missingargs ; c = getastring ( imapd_in , imapd_out , & arg1 ) ; if ( c != '<S2SV_blank>' ) goto missingargs ; c = getastring ( imapd_in , imapd_out , & arg2 ) ; if ( c == '<S2SV_blank>' ) { c = getastring ( imapd_in , imapd_out , & arg3 ) ; if ( ! imparse_isatom ( arg3 . s ) ) goto badpartition ; havepartition = 1 ; } if ( c == '\\r' ) c = prot_getc ( imapd_in ) ; if ( c != '\\n' ) goto extraargs ; cmd_xfer ( tag . s , arg1 . s , arg2 . s , ( havepartition ? arg3 . s : NULL ) ) ; } else if ( ! strcmp ( cmd . s , ""Xconvmeta"" ) ) { cmd_xconvmeta ( tag . s ) ; } else if ( ! strcmp ( cmd . s , ""Xlist"" ) ) { struct listargs listargs ; if ( c != '<S2SV_blank>' ) goto missingargs ; memset ( & listargs , 0 , sizeof ( struct listargs ) ) ; listargs . cmd = LIST_CMD_XLIST ; listargs . ret = LIST_RET_CHILDREN | LIST_RET_SPECIALUSE ; getlistargs ( tag . s , & listargs ) ; if ( listargs . pat . count ) cmd_list ( tag . s , & listargs ) ; snmp_increment ( LIST_COUNT , 1 ) ; } else if ( ! strcmp ( cmd . s , ""Xmove"" ) ) { if ( ! imapd_index && ! backend_current ) goto nomailbox ; usinguid = 0 ; if ( c != '<S2SV_blank>' ) goto missingargs ; goto move ; } else if ( ! strcmp ( cmd . s , ""Xrunannotator"" ) ) { if ( ! imapd_index && ! backend_current ) goto nomailbox ; usinguid = 0 ; if ( c != '<S2SV_blank>' ) goto missingargs ; xrunannotator : c = getword ( imapd_in , & arg1 ) ; if ( ! arg1 . len || ! imparse_issequence ( arg1 . s ) ) goto badsequence ; cmd_xrunannotator ( tag . s , arg1 . s , usinguid ) ; } else if ( ! strcmp ( cmd . s , ""Xsnippets"" ) ) { if ( c != '<S2SV_blank>' ) goto missingargs ; if ( ! imapd_index && ! backend_current ) goto nomailbox ; cmd_xsnippets ( tag . s ) ; } else if ( ! strcmp ( cmd . s , ""Xstats"" ) ) { cmd_xstats ( tag . s , c ) ; } else if ( ! strcmp ( cmd . s , ""Xwarmup"" ) ) { if ( c != '<S2SV_blank>' ) goto missingargs ; cmd_xwarmup ( tag . s ) ; } else if ( ! strcmp ( cmd . s , ""Xkillmy"" ) ) { if ( c != '<S2SV_blank>' ) goto missingargs ; c = getastring ( imapd_in , imapd_out , & arg1 ) ; if ( c == EOF ) goto missingargs ; if ( c == '\\r' ) c = prot_getc ( imapd_in ) ; if ( c != '\\n' ) goto extraargs ; cmd_xkillmy ( tag . s , arg1 . s ) ; } else if ( ! strcmp ( cmd . s , ""Xforever"" ) ) { if ( c == '\\r' ) c = prot_getc ( imapd_in ) ; if ( c != '\\n' ) goto extraargs ; cmd_xforever ( tag . s ) ; } else if ( ! strcmp ( cmd . s , ""Xmeid"" ) ) { if ( c != '<S2SV_blank>' ) goto missingargs ; c = getastring ( imapd_in , imapd_out , & arg1 ) ; if ( c == EOF ) goto missingargs ; if ( c == '\\r' ) c = prot_getc ( imapd_in ) ; if ( c != '\\n' ) goto extraargs ; cmd_xmeid ( tag . s , arg1 . s ) ; } else if ( apns_enabled && ! strcmp ( cmd . s , ""Xapplepushservice"" ) ) { if ( c != '<S2SV_blank>' ) goto missingargs ; memset ( & applepushserviceargs , 0 , sizeof ( struct applepushserviceargs ) ) ; do { c = getastring ( imapd_in , imapd_out , & arg1 ) ; if ( c == EOF ) goto aps_missingargs ; if ( ! strcmp ( arg1 . s , ""mailboxes"" ) ) { c = prot_getc ( imapd_in ) ; if ( c != '(' ) goto aps_missingargs ; c = prot_getc ( imapd_in ) ; if ( c != ')' ) { prot_ungetc ( c , imapd_in ) ; do { c = getastring ( imapd_in , imapd_out , & arg2 ) ; if ( c == EOF ) break ; strarray_push ( & applepushserviceargs . mailboxes , arg2 . s ) ; } while ( c == '<S2SV_blank>' ) ; } if ( c != ')' ) goto aps_missingargs ; c = prot_getc ( imapd_in ) ; } else { c = getastring ( imapd_in , imapd_out , & arg2 ) ; if ( ! strcmp ( arg1 . s , ""aps-version"" ) ) { if ( ! imparse_isnumber ( arg2 . s ) ) goto aps_extraargs ; applepushserviceargs . aps_version = atoi ( arg2 . s ) ; } else if ( ! strcmp ( arg1 . s , ""aps-account-id"" ) ) buf_copy ( & applepushserviceargs . aps_account_id , & arg2 ) ; else if ( ! strcmp ( arg1 . s , ""aps-device-token"" ) ) buf_copy ( & applepushserviceargs . aps_device_token , & arg2 ) ; else if ( ! strcmp ( arg1 . s , ""aps-subtopic"" ) ) buf_copy ( & applepushserviceargs . aps_subtopic , & arg2 ) ; else goto aps_extraargs ; } } while ( c == '<S2SV_blank>' ) ; if ( c == '\\r' ) c = prot_getc ( imapd_in ) ; if ( c != '\\n' ) goto aps_extraargs ; cmd_xapplepushservice ( tag . s , & applepushserviceargs ) ; } else goto badcmd ; break ; default : badcmd : prot_printf ( imapd_out , ""%s<S2SV_blank>BAD<S2SV_blank>Unrecognized<S2SV_blank>command\\r\\n"" , tag . s ) ; eatline ( imapd_in , c ) ; } if ( commandmintimer && strcmp ( ""idle"" , cmdname ) ) { double cmdtime , nettime ; const char * mboxname = index_mboxname ( imapd_index ) ; if ( ! mboxname ) mboxname = ""<none>"" ; cmdtime_endtimer ( & cmdtime , & nettime ) ; if ( cmdtime >= commandmintimerd ) { syslog ( LOG_NOTICE , ""cmdtimer:<S2SV_blank>\'%s\'<S2SV_blank>\'%s\'<S2SV_blank>\'%s\'<S2SV_blank>\'%f\'<S2SV_blank>\'%f\'<S2SV_blank>\'%f\'"" , imapd_userid ? imapd_userid : ""<none>"" , cmdname , mboxname , cmdtime , nettime , cmdtime + nettime ) ; } } continue ; nologin : prot_printf ( imapd_out , ""%s<S2SV_blank>BAD<S2SV_blank>Please<S2SV_blank>login<S2SV_blank>first\\r\\n"" , tag . s ) ; eatline ( imapd_in , c ) ; continue ; nomailbox : prot_printf ( imapd_out , ""%s<S2SV_blank>BAD<S2SV_blank>Please<S2SV_blank>select<S2SV_blank>a<S2SV_blank>mailbox<S2SV_blank>first\\r\\n"" , tag . s ) ; eatline ( imapd_in , c ) ; continue ; aps_missingargs : buf_free ( & applepushserviceargs . aps_account_id ) ; buf_free ( & applepushserviceargs . aps_device_token ) ; buf_free ( & applepushserviceargs . aps_subtopic ) ; strarray_fini ( & applepushserviceargs . mailboxes ) ; missingargs : prot_printf ( imapd_out , ""%s<S2SV_blank>BAD<S2SV_blank>Missing<S2SV_blank>required<S2SV_blank>argument<S2SV_blank>to<S2SV_blank>%s\\r\\n"" , tag . s , cmd . s ) ; eatline ( imapd_in , c ) ; continue ; aps_extraargs : buf_free ( & applepushserviceargs . aps_account_id ) ; buf_free ( & applepushserviceargs . aps_device_token ) ; buf_free ( & applepushserviceargs . aps_subtopic ) ; strarray_fini ( & applepushserviceargs . mailboxes ) ; extraargs : prot_printf ( imapd_out , ""%s<S2SV_blank>BAD<S2SV_blank>Unexpected<S2SV_blank>extra<S2SV_blank>arguments<S2SV_blank>to<S2SV_blank>%s\\r\\n"" , tag . s , cmd . s ) ; eatline ( imapd_in , c ) ; continue ; badsequence : prot_printf ( imapd_out , ""%s<S2SV_blank>BAD<S2SV_blank>Invalid<S2SV_blank>sequence<S2SV_blank>in<S2SV_blank>%s\\r\\n"" , tag . s , cmd . s ) ; eatline ( imapd_in , c ) ; continue ; badpartition : prot_printf ( imapd_out , ""%s<S2SV_blank>BAD<S2SV_blank>Invalid<S2SV_blank>partition<S2SV_blank>name<S2SV_blank>in<S2SV_blank>%s\\r\\n"" , tag . s , cmd . s ) ; eatline ( imapd_in , c ) ; continue ; } done : cmd_syncrestart ( NULL , & reserve_list , 0 ) ; }",) ) { if ( ! imapd_userisadmin ) goto badcmd ; <S2SV_ModStart> ) ) { if ( ! imapd_userisadmin ) goto badcmd ; <S2SV_ModStart> { if ( ! imapd_userisadmin ) goto badcmd ; if ( <S2SV_ModStart> ) ) { if ( ! imapd_userisadmin ) goto badcmd ;
373,"static long media_device_enum_entities ( struct media_device * mdev , struct media_entity_desc __user * uent ) { struct media_entity * ent ; struct media_entity_desc u_ent ; <S2SV_StartBug> if ( copy_from_user ( & u_ent . id , & uent -> id , sizeof ( u_ent . id ) ) ) <S2SV_EndBug> return - EFAULT ; ent = find_entity ( mdev , u_ent . id ) ; if ( ent == NULL ) return - EINVAL ; u_ent . id = ent -> id ; if ( ent -> name ) { strncpy ( u_ent . name , ent -> name , sizeof ( u_ent . name ) ) ; u_ent . name [ sizeof ( u_ent . name ) - 1 ] = '\\0' ; } else { memset ( u_ent . name , 0 , sizeof ( u_ent . name ) ) ; } u_ent . type = ent -> type ; u_ent . revision = ent -> revision ; u_ent . flags = ent -> flags ; u_ent . group_id = ent -> group_id ; u_ent . pads = ent -> num_pads ; u_ent . links = ent -> num_links - ent -> num_backlinks ; memcpy ( & u_ent . raw , & ent -> info , sizeof ( ent -> info ) ) ; if ( copy_to_user ( uent , & u_ent , sizeof ( u_ent ) ) ) return - EFAULT ; return 0 ; }","media_entity_desc u_ent ; memset ( & u_ent , 0 , sizeof ( u_ent ) ) ;"
374,"static int validate_user_key ( struct fscrypt_info * crypt_info , struct fscrypt_context * ctx , u8 * raw_key , const char * prefix ) { char * description ; struct key * keyring_key ; struct fscrypt_key * master_key ; const struct user_key_payload * ukp ; int res ; description = kasprintf ( GFP_NOFS , ""%s%*phN"" , prefix , FS_KEY_DESCRIPTOR_SIZE , ctx -> master_key_descriptor ) ; if ( ! description ) return - ENOMEM ; keyring_key = request_key ( & key_type_logon , description , NULL ) ; kfree ( description ) ; if ( IS_ERR ( keyring_key ) ) return PTR_ERR ( keyring_key ) ; <S2SV_StartBug> if ( keyring_key -> type != & key_type_logon ) { <S2SV_EndBug> printk_once ( KERN_WARNING ""%s:<S2SV_blank>key<S2SV_blank>type<S2SV_blank>must<S2SV_blank>be<S2SV_blank>logon\\n"" , __func__ ) ; res = - ENOKEY ; goto out ; } <S2SV_StartBug> down_read ( & keyring_key -> sem ) ; <S2SV_EndBug> <S2SV_StartBug> ukp = user_key_payload ( keyring_key ) ; <S2SV_EndBug> if ( ukp -> datalen != sizeof ( struct fscrypt_key ) ) { res = - EINVAL ; up_read ( & keyring_key -> sem ) ; goto out ; } master_key = ( struct fscrypt_key * ) ukp -> data ; BUILD_BUG_ON ( FS_AES_128_ECB_KEY_SIZE != FS_KEY_DERIVATION_NONCE_SIZE ) ; if ( master_key -> size != FS_AES_256_XTS_KEY_SIZE ) { printk_once ( KERN_WARNING ""%s:<S2SV_blank>key<S2SV_blank>size<S2SV_blank>incorrect:<S2SV_blank>%d\\n"" , __func__ , master_key -> size ) ; res = - ENOKEY ; up_read ( & keyring_key -> sem ) ; goto out ; } res = derive_key_aes ( ctx -> nonce , master_key -> raw , raw_key ) ; up_read ( & keyring_key -> sem ) ; if ( res ) goto out ; crypt_info -> ci_keyring_key = keyring_key ; return 0 ; out : key_put ( keyring_key ) ; return res ; }","keyring_key ) ; down_read ( & keyring_key -> sem ) ; <S2SV_ModStart> out ; } ukp = user_key_payload ( keyring_key ) ; if ( ukp -> datalen != sizeof ( struct fscrypt_key ) ) { res = - EINVAL ; goto out ; } master_key = ( struct fscrypt_key * ) ukp -> data ; BUILD_BUG_ON ( FS_AES_128_ECB_KEY_SIZE != FS_KEY_DERIVATION_NONCE_SIZE ) ; if ( master_key -> size != FS_AES_256_XTS_KEY_SIZE ) { printk_once ( KERN_WARNING ""%s:<S2SV_blank>key<S2SV_blank>size<S2SV_blank>incorrect:<S2SV_blank>%d\\n"" , __func__ , master_key -> size ) ; res = - ENOKEY ; goto out ; } res = derive_key_aes ( ctx -> nonce , master_key -> raw , raw_key ) ; out : up_read <S2SV_ModEnd> ( & keyring_key <S2SV_ModStart> sem ) ; key_put ( keyring_key ) ; return <S2SV_ModEnd> res ; }"
375,"PHPAPI int php_var_unserialize ( UNSERIALIZE_PARAMETER ) { const unsigned char * cursor , * limit , * marker , * start ; zval * * rval_ref ; limit = max ; cursor = * p ; if ( YYCURSOR >= YYLIMIT ) { return 0 ; } if ( var_hash && cursor [ 0 ] != 'R' ) { var_push ( var_hash , rval ) ; } start = cursor ; <S2SV_StartBug> # line 495 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> { YYCTYPE yych ; static const unsigned char yybm [ ] = { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 128 , 128 , 128 , 128 , 128 , 128 , 128 , 128 , 128 , 128 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , } ; if ( ( YYLIMIT - YYCURSOR ) < 7 ) YYFILL ( 7 ) ; yych = * YYCURSOR ; switch ( yych ) { case 'C' : case 'O' : goto yy13 ; case 'N' : goto yy5 ; case 'R' : goto yy2 ; case 'S' : goto yy10 ; case 'a' : goto yy11 ; case 'b' : goto yy6 ; case 'd' : goto yy8 ; case 'i' : goto yy7 ; case 'o' : goto yy12 ; case 'r' : goto yy4 ; case 's' : goto yy9 ; case '}' : goto yy14 ; default : goto yy16 ; } yy2 : yych = * ( YYMARKER = ++ YYCURSOR ) ; if ( yych == ':' ) goto yy95 ; yy3 : <S2SV_StartBug> # line 860 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> { return 0 ; } <S2SV_StartBug> # line 557 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> yy4 : yych = * ( YYMARKER = ++ YYCURSOR ) ; if ( yych == ':' ) goto yy89 ; goto yy3 ; yy5 : yych = * ++ YYCURSOR ; if ( yych == ';' ) goto yy87 ; goto yy3 ; yy6 : yych = * ( YYMARKER = ++ YYCURSOR ) ; if ( yych == ':' ) goto yy83 ; goto yy3 ; yy7 : yych = * ( YYMARKER = ++ YYCURSOR ) ; if ( yych == ':' ) goto yy77 ; goto yy3 ; yy8 : yych = * ( YYMARKER = ++ YYCURSOR ) ; if ( yych == ':' ) goto yy53 ; goto yy3 ; yy9 : yych = * ( YYMARKER = ++ YYCURSOR ) ; if ( yych == ':' ) goto yy46 ; goto yy3 ; yy10 : yych = * ( YYMARKER = ++ YYCURSOR ) ; if ( yych == ':' ) goto yy39 ; goto yy3 ; yy11 : yych = * ( YYMARKER = ++ YYCURSOR ) ; if ( yych == ':' ) goto yy32 ; goto yy3 ; yy12 : yych = * ( YYMARKER = ++ YYCURSOR ) ; if ( yych == ':' ) goto yy25 ; goto yy3 ; yy13 : yych = * ( YYMARKER = ++ YYCURSOR ) ; if ( yych == ':' ) goto yy17 ; goto yy3 ; yy14 : ++ YYCURSOR ; <S2SV_StartBug> # line 854 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> { php_error_docref ( NULL TSRMLS_CC , E_NOTICE , ""Unexpected<S2SV_blank>end<S2SV_blank>of<S2SV_blank>serialized<S2SV_blank>data"" ) ; return 0 ; } <S2SV_StartBug> # line 606 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> yy16 : yych = * ++ YYCURSOR ; goto yy3 ; yy17 : yych = * ++ YYCURSOR ; if ( yybm [ 0 + yych ] & 128 ) { goto yy20 ; } if ( yych == '+' ) goto yy19 ; yy18 : YYCURSOR = YYMARKER ; goto yy3 ; yy19 : yych = * ++ YYCURSOR ; if ( yybm [ 0 + yych ] & 128 ) { goto yy20 ; } goto yy18 ; yy20 : ++ YYCURSOR ; if ( ( YYLIMIT - YYCURSOR ) < 2 ) YYFILL ( 2 ) ; yych = * YYCURSOR ; if ( yybm [ 0 + yych ] & 128 ) { goto yy20 ; } if ( yych <= '/' ) goto yy18 ; if ( yych >= ';' ) goto yy18 ; yych = * ++ YYCURSOR ; if ( yych != \'""\' ) goto yy18 ; ++ YYCURSOR ; <S2SV_StartBug> # line 707 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> { size_t len , len2 , len3 , maxlen ; long elements ; char * class_name ; zend_class_entry * ce ; zend_class_entry * * pce ; int incomplete_class = 0 ; int custom_object = 0 ; zval * user_func ; zval * retval_ptr ; zval * * args [ 1 ] ; zval * arg_func_name ; if ( ! var_hash ) return 0 ; if ( * start == 'C' ) { custom_object = 1 ; } INIT_PZVAL ( * rval ) ; len2 = len = parse_uiv ( start + 2 ) ; maxlen = max - YYCURSOR ; if ( maxlen < len || len == 0 ) { * p = start + 2 ; return 0 ; } class_name = ( char * ) YYCURSOR ; YYCURSOR += len ; if ( * ( YYCURSOR ) != \'""\' ) { * p = YYCURSOR ; return 0 ; } if ( * ( YYCURSOR + 1 ) != ':' ) { * p = YYCURSOR + 1 ; return 0 ; } len3 = strspn ( class_name , ""0123456789_abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\\177\\200\\201\\202\\203\\204\\205\\206\\207\\210\\211\\212\\213\\214\\215\\216\\217\\220\\221\\222\\223\\224\\225\\226\\227\\230\\231\\232\\233\\234\\235\\236\\237\\240\\241\\242\\243\\244\\245\\246\\247\\250\\251\\252\\253\\254\\255\\256\\257\\260\\261\\262\\263\\264\\265\\266\\267\\270\\271\\272\\273\\274\\275\\276\\277\\300\\301\\302\\303\\304\\305\\306\\307\\310\\311\\312\\313\\314\\315\\316\\317\\320\\321\\322\\323\\324\\325\\326\\327\\330\\331\\332\\333\\334\\335\\336\\337\\340\\341\\342\\343\\344\\345\\346\\347\\350\\351\\352\\353\\354\\355\\356\\357\\360\\361\\362\\363\\364\\365\\366\\367\\370\\371\\372\\373\\374\\375\\376\\377\\\\"" ) ; if ( len3 != len ) { * p = YYCURSOR + len3 - len ; return 0 ; } class_name = estrndup ( class_name , len ) ; do { BG ( serialize_lock ) ++ ; if ( zend_lookup_class ( class_name , len2 , & pce TSRMLS_CC ) == SUCCESS ) { BG ( serialize_lock ) -- ; if ( EG ( exception ) ) { efree ( class_name ) ; return 0 ; } ce = * pce ; break ; } BG ( serialize_lock ) -- ; if ( EG ( exception ) ) { efree ( class_name ) ; return 0 ; } if ( ( PG ( unserialize_callback_func ) == NULL ) || ( PG ( unserialize_callback_func ) [ 0 ] == '\\0' ) ) { incomplete_class = 1 ; ce = PHP_IC_ENTRY ; break ; } MAKE_STD_ZVAL ( user_func ) ; ZVAL_STRING ( user_func , PG ( unserialize_callback_func ) , 1 ) ; args [ 0 ] = & arg_func_name ; MAKE_STD_ZVAL ( arg_func_name ) ; ZVAL_STRING ( arg_func_name , class_name , 1 ) ; BG ( serialize_lock ) ++ ; if ( call_user_function_ex ( CG ( function_table ) , NULL , user_func , & retval_ptr , 1 , args , 0 , NULL TSRMLS_CC ) != SUCCESS ) { BG ( serialize_lock ) -- ; if ( EG ( exception ) ) { efree ( class_name ) ; zval_ptr_dtor ( & user_func ) ; zval_ptr_dtor ( & arg_func_name ) ; return 0 ; } php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""defined<S2SV_blank>(%s)<S2SV_blank>but<S2SV_blank>not<S2SV_blank>found"" , user_func -> value . str . val ) ; incomplete_class = 1 ; ce = PHP_IC_ENTRY ; zval_ptr_dtor ( & user_func ) ; zval_ptr_dtor ( & arg_func_name ) ; break ; } BG ( serialize_lock ) -- ; if ( retval_ptr ) { zval_ptr_dtor ( & retval_ptr ) ; } if ( EG ( exception ) ) { efree ( class_name ) ; zval_ptr_dtor ( & user_func ) ; zval_ptr_dtor ( & arg_func_name ) ; return 0 ; } if ( zend_lookup_class ( class_name , len2 , & pce TSRMLS_CC ) == SUCCESS ) { ce = * pce ; } else { php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Function<S2SV_blank>%s()<S2SV_blank>hasn\'t<S2SV_blank>defined<S2SV_blank>the<S2SV_blank>class<S2SV_blank>it<S2SV_blank>was<S2SV_blank>called<S2SV_blank>for"" , user_func -> value . str . val ) ; incomplete_class = 1 ; ce = PHP_IC_ENTRY ; } zval_ptr_dtor ( & user_func ) ; zval_ptr_dtor ( & arg_func_name ) ; break ; } while ( 1 ) ; * p = YYCURSOR ; if ( custom_object ) { int ret ; ret = object_custom ( UNSERIALIZE_PASSTHRU , ce ) ; if ( ret && incomplete_class ) { php_store_class_name ( * rval , class_name , len2 ) ; } efree ( class_name ) ; return ret ; } elements = object_common1 ( UNSERIALIZE_PASSTHRU , ce ) ; if ( incomplete_class ) { php_store_class_name ( * rval , class_name , len2 ) ; } efree ( class_name ) ; return object_common2 ( UNSERIALIZE_PASSTHRU , elements ) ; } <S2SV_StartBug> # line 784 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> yy25 : yych = * ++ YYCURSOR ; if ( yych <= ',' ) { if ( yych != '+' ) goto yy18 ; } else { if ( yych <= '-' ) goto yy26 ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy27 ; goto yy18 ; } yy26 : yych = * ++ YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych >= ':' ) goto yy18 ; yy27 : ++ YYCURSOR ; if ( ( YYLIMIT - YYCURSOR ) < 2 ) YYFILL ( 2 ) ; yych = * YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy27 ; if ( yych >= ';' ) goto yy18 ; yych = * ++ YYCURSOR ; if ( yych != \'""\' ) goto yy18 ; ++ YYCURSOR ; <S2SV_StartBug> # line 698 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> { if ( ! var_hash ) return 0 ; INIT_PZVAL ( * rval ) ; return object_common2 ( UNSERIALIZE_PASSTHRU , object_common1 ( UNSERIALIZE_PASSTHRU , ZEND_STANDARD_CLASS_DEF_PTR ) ) ; } <S2SV_StartBug> # line 818 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> yy32 : yych = * ++ YYCURSOR ; if ( yych == '+' ) goto yy33 ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy34 ; goto yy18 ; yy33 : yych = * ++ YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych >= ':' ) goto yy18 ; yy34 : ++ YYCURSOR ; if ( ( YYLIMIT - YYCURSOR ) < 2 ) YYFILL ( 2 ) ; yych = * YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy34 ; if ( yych >= ';' ) goto yy18 ; yych = * ++ YYCURSOR ; if ( yych != '{' ) goto yy18 ; ++ YYCURSOR ; <S2SV_StartBug> # line 677 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> { long elements = parse_iv ( start + 2 ) ; * p = YYCURSOR ; if ( ! var_hash ) return 0 ; if ( elements < 0 ) { return 0 ; } INIT_PZVAL ( * rval ) ; array_init_size ( * rval , elements ) ; if ( ! process_nested_data ( UNSERIALIZE_PASSTHRU , Z_ARRVAL_PP ( rval ) , elements , 0 ) ) { return 0 ; } return finish_nested_data ( UNSERIALIZE_PASSTHRU ) ; } <S2SV_StartBug> # line 860 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> yy39 : yych = * ++ YYCURSOR ; if ( yych == '+' ) goto yy40 ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy41 ; goto yy18 ; yy40 : yych = * ++ YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych >= ':' ) goto yy18 ; yy41 : ++ YYCURSOR ; if ( ( YYLIMIT - YYCURSOR ) < 2 ) YYFILL ( 2 ) ; yych = * YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy41 ; if ( yych >= ';' ) goto yy18 ; yych = * ++ YYCURSOR ; if ( yych != \'""\' ) goto yy18 ; ++ YYCURSOR ; <S2SV_StartBug> # line 642 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> { size_t len , maxlen ; char * str ; len = parse_uiv ( start + 2 ) ; maxlen = max - YYCURSOR ; if ( maxlen < len ) { * p = start + 2 ; return 0 ; } if ( ( str = unserialize_str ( & YYCURSOR , & len , maxlen ) ) == NULL ) { return 0 ; } if ( * ( YYCURSOR ) != \'""\' ) { efree ( str ) ; * p = YYCURSOR ; return 0 ; } if ( * ( YYCURSOR + 1 ) != ';' ) { efree ( str ) ; * p = YYCURSOR + 1 ; return 0 ; } YYCURSOR += 2 ; * p = YYCURSOR ; INIT_PZVAL ( * rval ) ; ZVAL_STRINGL ( * rval , str , len , 0 ) ; return 1 ; } <S2SV_StartBug> # line 916 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> yy46 : yych = * ++ YYCURSOR ; if ( yych == '+' ) goto yy47 ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy48 ; goto yy18 ; yy47 : yych = * ++ YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych >= ':' ) goto yy18 ; yy48 : ++ YYCURSOR ; if ( ( YYLIMIT - YYCURSOR ) < 2 ) YYFILL ( 2 ) ; yych = * YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy48 ; if ( yych >= ';' ) goto yy18 ; yych = * ++ YYCURSOR ; if ( yych != \'""\' ) goto yy18 ; ++ YYCURSOR ; <S2SV_StartBug> # line 609 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> { size_t len , maxlen ; char * str ; len = parse_uiv ( start + 2 ) ; maxlen = max - YYCURSOR ; if ( maxlen < len ) { * p = start + 2 ; return 0 ; } str = ( char * ) YYCURSOR ; YYCURSOR += len ; if ( * ( YYCURSOR ) != \'""\' ) { * p = YYCURSOR ; return 0 ; } if ( * ( YYCURSOR + 1 ) != ';' ) { * p = YYCURSOR + 1 ; return 0 ; } YYCURSOR += 2 ; * p = YYCURSOR ; INIT_PZVAL ( * rval ) ; ZVAL_STRINGL ( * rval , str , len , 1 ) ; return 1 ; } <S2SV_StartBug> # line 970 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> yy53 : yych = * ++ YYCURSOR ; if ( yych <= '/' ) { if ( yych <= ',' ) { if ( yych == '+' ) goto yy57 ; goto yy18 ; } else { if ( yych <= '-' ) goto yy55 ; if ( yych <= '.' ) goto yy60 ; goto yy18 ; } } else { if ( yych <= 'I' ) { if ( yych <= '9' ) goto yy58 ; if ( yych <= 'H' ) goto yy18 ; goto yy56 ; } else { if ( yych != 'N' ) goto yy18 ; } } yych = * ++ YYCURSOR ; if ( yych == 'A' ) goto yy76 ; goto yy18 ; yy55 : yych = * ++ YYCURSOR ; if ( yych <= '/' ) { if ( yych == '.' ) goto yy60 ; goto yy18 ; } else { if ( yych <= '9' ) goto yy58 ; if ( yych != 'I' ) goto yy18 ; } yy56 : yych = * ++ YYCURSOR ; if ( yych == 'N' ) goto yy72 ; goto yy18 ; yy57 : yych = * ++ YYCURSOR ; if ( yych == '.' ) goto yy60 ; if ( yych <= '/' ) goto yy18 ; if ( yych >= ':' ) goto yy18 ; yy58 : ++ YYCURSOR ; if ( ( YYLIMIT - YYCURSOR ) < 4 ) YYFILL ( 4 ) ; yych = * YYCURSOR ; if ( yych <= ':' ) { if ( yych <= '.' ) { if ( yych <= '-' ) goto yy18 ; goto yy70 ; } else { if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy58 ; goto yy18 ; } } else { if ( yych <= 'E' ) { if ( yych <= ';' ) goto yy63 ; if ( yych <= 'D' ) goto yy18 ; goto yy65 ; } else { if ( yych == 'e' ) goto yy65 ; goto yy18 ; } } yy60 : yych = * ++ YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych >= ':' ) goto yy18 ; yy61 : ++ YYCURSOR ; if ( ( YYLIMIT - YYCURSOR ) < 4 ) YYFILL ( 4 ) ; yych = * YYCURSOR ; if ( yych <= ';' ) { if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy61 ; if ( yych <= ':' ) goto yy18 ; } else { if ( yych <= 'E' ) { if ( yych <= 'D' ) goto yy18 ; goto yy65 ; } else { if ( yych == 'e' ) goto yy65 ; goto yy18 ; } } yy63 : ++ YYCURSOR ; <S2SV_StartBug> # line 599 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> { # if SIZEOF_LONG == 4 use_double : # endif * p = YYCURSOR ; INIT_PZVAL ( * rval ) ; ZVAL_DOUBLE ( * rval , zend_strtod ( ( const char * ) start + 2 , NULL ) ) ; return 1 ; } <S2SV_StartBug> # line 1068 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> yy65 : yych = * ++ YYCURSOR ; if ( yych <= ',' ) { if ( yych != '+' ) goto yy18 ; } else { if ( yych <= '-' ) goto yy66 ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy67 ; goto yy18 ; } yy66 : yych = * ++ YYCURSOR ; if ( yych <= ',' ) { if ( yych == '+' ) goto yy69 ; goto yy18 ; } else { if ( yych <= '-' ) goto yy69 ; if ( yych <= '/' ) goto yy18 ; if ( yych >= ':' ) goto yy18 ; } yy67 : ++ YYCURSOR ; if ( YYLIMIT <= YYCURSOR ) YYFILL ( 1 ) ; yych = * YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy67 ; if ( yych == ';' ) goto yy63 ; goto yy18 ; yy69 : yych = * ++ YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy67 ; goto yy18 ; yy70 : ++ YYCURSOR ; if ( ( YYLIMIT - YYCURSOR ) < 4 ) YYFILL ( 4 ) ; yych = * YYCURSOR ; if ( yych <= ';' ) { if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy70 ; if ( yych <= ':' ) goto yy18 ; goto yy63 ; } else { if ( yych <= 'E' ) { if ( yych <= 'D' ) goto yy18 ; goto yy65 ; } else { if ( yych == 'e' ) goto yy65 ; goto yy18 ; } } yy72 : yych = * ++ YYCURSOR ; if ( yych != 'F' ) goto yy18 ; yy73 : yych = * ++ YYCURSOR ; if ( yych != ';' ) goto yy18 ; ++ YYCURSOR ; <S2SV_StartBug> # line 584 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> { * p = YYCURSOR ; INIT_PZVAL ( * rval ) ; if ( ! strncmp ( start + 2 , ""NAN"" , 3 ) ) { ZVAL_DOUBLE ( * rval , php_get_nan ( ) ) ; } else if ( ! strncmp ( start + 2 , ""INF"" , 3 ) ) { ZVAL_DOUBLE ( * rval , php_get_inf ( ) ) ; } else if ( ! strncmp ( start + 2 , ""-INF"" , 4 ) ) { ZVAL_DOUBLE ( * rval , - php_get_inf ( ) ) ; } return 1 ; } <S2SV_StartBug> # line 1142 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> yy76 : yych = * ++ YYCURSOR ; if ( yych == 'N' ) goto yy73 ; goto yy18 ; yy77 : yych = * ++ YYCURSOR ; if ( yych <= ',' ) { if ( yych != '+' ) goto yy18 ; } else { if ( yych <= '-' ) goto yy78 ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy79 ; goto yy18 ; } yy78 : yych = * ++ YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych >= ':' ) goto yy18 ; yy79 : ++ YYCURSOR ; if ( YYLIMIT <= YYCURSOR ) YYFILL ( 1 ) ; yych = * YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy79 ; if ( yych != ';' ) goto yy18 ; ++ YYCURSOR ; <S2SV_StartBug> # line 557 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> { # if SIZEOF_LONG == 4 int digits = YYCURSOR - start - 3 ; if ( start [ 2 ] == '-' || start [ 2 ] == '+' ) { digits -- ; } if ( digits >= MAX_LENGTH_OF_LONG - 1 ) { if ( digits == MAX_LENGTH_OF_LONG - 1 ) { int cmp = strncmp ( YYCURSOR - MAX_LENGTH_OF_LONG , long_min_digits , MAX_LENGTH_OF_LONG - 1 ) ; if ( ! ( cmp < 0 || ( cmp == 0 && start [ 2 ] == '-' ) ) ) { goto use_double ; } } else { goto use_double ; } } # endif * p = YYCURSOR ; INIT_PZVAL ( * rval ) ; ZVAL_LONG ( * rval , parse_iv ( start + 2 ) ) ; return 1 ; } <S2SV_StartBug> # line 1196 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> yy83 : yych = * ++ YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych >= '2' ) goto yy18 ; yych = * ++ YYCURSOR ; if ( yych != ';' ) goto yy18 ; ++ YYCURSOR ; <S2SV_StartBug> # line 550 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> { * p = YYCURSOR ; INIT_PZVAL ( * rval ) ; ZVAL_BOOL ( * rval , parse_iv ( start + 2 ) ) ; return 1 ; } <S2SV_StartBug> # line 1211 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> yy87 : ++ YYCURSOR ; <S2SV_StartBug> # line 543 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> { * p = YYCURSOR ; INIT_PZVAL ( * rval ) ; ZVAL_NULL ( * rval ) ; return 1 ; } <S2SV_StartBug> # line 1221 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> yy89 : yych = * ++ YYCURSOR ; if ( yych <= ',' ) { if ( yych != '+' ) goto yy18 ; } else { if ( yych <= '-' ) goto yy90 ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy91 ; goto yy18 ; } yy90 : yych = * ++ YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych >= ':' ) goto yy18 ; yy91 : ++ YYCURSOR ; if ( YYLIMIT <= YYCURSOR ) YYFILL ( 1 ) ; yych = * YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy91 ; if ( yych != ';' ) goto yy18 ; ++ YYCURSOR ; <S2SV_StartBug> # line 520 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> { long id ; * p = YYCURSOR ; if ( ! var_hash ) return 0 ; id = parse_iv ( start + 2 ) - 1 ; if ( id == - 1 || var_access ( var_hash , id , & rval_ref ) != SUCCESS ) { return 0 ; } if ( * rval == * rval_ref ) return 0 ; if ( * rval != NULL ) { var_push_dtor_no_addref ( var_hash , rval ) ; } * rval = * rval_ref ; Z_ADDREF_PP ( rval ) ; Z_UNSET_ISREF_PP ( rval ) ; return 1 ; } <S2SV_StartBug> # line 1267 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> yy95 : yych = * ++ YYCURSOR ; if ( yych <= ',' ) { if ( yych != '+' ) goto yy18 ; } else { if ( yych <= '-' ) goto yy96 ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy97 ; goto yy18 ; } yy96 : yych = * ++ YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych >= ':' ) goto yy18 ; yy97 : ++ YYCURSOR ; if ( YYLIMIT <= YYCURSOR ) YYFILL ( 1 ) ; yych = * YYCURSOR ; if ( yych <= '/' ) goto yy18 ; if ( yych <= '9' ) goto yy97 ; if ( yych != ';' ) goto yy18 ; ++ YYCURSOR ; <S2SV_StartBug> # line 499 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> { long id ; * p = YYCURSOR ; if ( ! var_hash ) return 0 ; id = parse_iv ( start + 2 ) - 1 ; if ( id == - 1 || var_access ( var_hash , id , & rval_ref ) != SUCCESS ) { return 0 ; } if ( * rval != NULL ) { var_push_dtor_no_addref ( var_hash , rval ) ; } * rval = * rval_ref ; Z_ADDREF_PP ( rval ) ; Z_SET_ISREF_PP ( rval ) ; return 1 ; } <S2SV_StartBug> # line 1311 ""ext/standard/var_unserializer.c"" <S2SV_EndBug> } <S2SV_StartBug> # line 862 ""ext/standard/var_unserializer.re"" <S2SV_EndBug> return 0 ; }","; # line 496 <S2SV_ModEnd> ""ext/standard/var_unserializer.c"" { YYCTYPE <S2SV_ModStart> : # line 861 <S2SV_ModEnd> ""ext/standard/var_unserializer.re"" { return <S2SV_ModStart> } # line 558 <S2SV_ModEnd> ""ext/standard/var_unserializer.c"" yy4 : <S2SV_ModStart> ; # line 855 <S2SV_ModEnd> ""ext/standard/var_unserializer.re"" { php_error_docref <S2SV_ModStart> } # line 607 <S2SV_ModEnd> ""ext/standard/var_unserializer.c"" yy16 : <S2SV_ModStart> ; # line 708 <S2SV_ModEnd> ""ext/standard/var_unserializer.re"" { size_t <S2SV_ModStart> } # line 785 <S2SV_ModEnd> ""ext/standard/var_unserializer.c"" yy25 : <S2SV_ModStart> ; # line 699 <S2SV_ModEnd> ""ext/standard/var_unserializer.re"" { if <S2SV_ModStart> } # line 819 <S2SV_ModEnd> ""ext/standard/var_unserializer.c"" yy32 : <S2SV_ModStart> ; # line 678 <S2SV_ModEnd> ""ext/standard/var_unserializer.re"" { long <S2SV_ModStart> } # line 861 <S2SV_ModEnd> ""ext/standard/var_unserializer.c"" yy39 : <S2SV_ModStart> ; # line 643 <S2SV_ModEnd> ""ext/standard/var_unserializer.re"" { size_t <S2SV_ModStart> } # line 917 <S2SV_ModEnd> ""ext/standard/var_unserializer.c"" yy46 : <S2SV_ModStart> ; # line 610 <S2SV_ModEnd> ""ext/standard/var_unserializer.re"" { size_t <S2SV_ModStart> } # line 971 <S2SV_ModEnd> ""ext/standard/var_unserializer.c"" yy53 : <S2SV_ModStart> ; # line 600 <S2SV_ModEnd> ""ext/standard/var_unserializer.re"" { # <S2SV_ModStart> } # line 1069 <S2SV_ModEnd> ""ext/standard/var_unserializer.c"" yy65 : <S2SV_ModStart> ; # line 585 <S2SV_ModEnd> ""ext/standard/var_unserializer.re"" { * <S2SV_ModStart> } # line 1143 <S2SV_ModEnd> ""ext/standard/var_unserializer.c"" yy76 : <S2SV_ModStart> ; # line 558 <S2SV_ModEnd> ""ext/standard/var_unserializer.re"" { # <S2SV_ModStart> } # line 1197 <S2SV_ModEnd> ""ext/standard/var_unserializer.c"" yy83 : <S2SV_ModStart> ; # line 551 <S2SV_ModEnd> ""ext/standard/var_unserializer.re"" { * <S2SV_ModStart> } # line 1212 <S2SV_ModEnd> ""ext/standard/var_unserializer.c"" yy87 : <S2SV_ModStart> ; # line 544 <S2SV_ModEnd> ""ext/standard/var_unserializer.re"" { * <S2SV_ModStart> } # line 1222 <S2SV_ModEnd> ""ext/standard/var_unserializer.c"" yy89 : <S2SV_ModStart> ; # line 521 <S2SV_ModEnd> ""ext/standard/var_unserializer.re"" { long <S2SV_ModStart> } # line 1268 <S2SV_ModEnd> ""ext/standard/var_unserializer.c"" yy95 : <S2SV_ModStart> ; # line 500 <S2SV_ModEnd> ""ext/standard/var_unserializer.re"" { long <S2SV_ModStart> } # line 1312 <S2SV_ModEnd> ""ext/standard/var_unserializer.c"" } # <S2SV_ModStart> } # line 863 <S2SV_ModEnd> ""ext/standard/var_unserializer.re"" return 0"
376,"void read_boot ( DOS_FS * fs ) { struct boot_sector b ; unsigned total_sectors ; unsigned short logical_sector_size , sectors ; <S2SV_StartBug> unsigned fat_length ; <S2SV_EndBug> unsigned total_fat_entries ; off_t data_size ; fs_read ( 0 , sizeof ( b ) , & b ) ; logical_sector_size = GET_UNALIGNED_W ( b . sector_size ) ; if ( ! logical_sector_size ) die ( ""Logical<S2SV_blank>sector<S2SV_blank>size<S2SV_blank>is<S2SV_blank>zero."" ) ; if ( logical_sector_size & ( SECTOR_SIZE - 1 ) ) die ( ""Logical<S2SV_blank>sector<S2SV_blank>size<S2SV_blank>(%d<S2SV_blank>bytes)<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>multiple<S2SV_blank>of<S2SV_blank>the<S2SV_blank>physical<S2SV_blank>"" ""sector<S2SV_blank>size."" , logical_sector_size ) ; fs -> cluster_size = b . cluster_size * logical_sector_size ; if ( ! fs -> cluster_size ) die ( ""Cluster<S2SV_blank>size<S2SV_blank>is<S2SV_blank>zero."" ) ; if ( b . fats != 2 && b . fats != 1 ) die ( ""Currently,<S2SV_blank>only<S2SV_blank>1<S2SV_blank>or<S2SV_blank>2<S2SV_blank>FATs<S2SV_blank>are<S2SV_blank>supported,<S2SV_blank>not<S2SV_blank>%d.\\n"" , b . fats ) ; fs -> nfats = b . fats ; sectors = GET_UNALIGNED_W ( b . sectors ) ; total_sectors = sectors ? sectors : le32toh ( b . total_sect ) ; if ( verbose ) printf ( ""Checking<S2SV_blank>we<S2SV_blank>can<S2SV_blank>access<S2SV_blank>the<S2SV_blank>last<S2SV_blank>sector<S2SV_blank>of<S2SV_blank>the<S2SV_blank>filesystem\\n"" ) ; fs_test ( ( off_t ) ( ( total_sectors & ~ 1 ) - 1 ) * logical_sector_size , logical_sector_size ) ; fat_length = le16toh ( b . fat_length ) ? le16toh ( b . fat_length ) : le32toh ( b . fat32_length ) ; <S2SV_StartBug> fs -> fat_start = ( off_t ) le16toh ( b . reserved ) * logical_sector_size ; <S2SV_EndBug> fs -> root_start = ( ( off_t ) le16toh ( b . reserved ) + b . fats * fat_length ) * logical_sector_size ; fs -> root_entries = GET_UNALIGNED_W ( b . dir_entries ) ; fs -> data_start = fs -> root_start + ROUND_TO_MULTIPLE ( fs -> root_entries << MSDOS_DIR_BITS , logical_sector_size ) ; <S2SV_StartBug> data_size = ( off_t ) total_sectors * logical_sector_size - fs -> data_start ; <S2SV_EndBug> fs -> data_clusters = data_size / fs -> cluster_size ; fs -> root_cluster = 0 ; fs -> fsinfo_start = 0 ; fs -> free_clusters = - 1 ; if ( ! b . fat_length && b . fat32_length ) { fs -> fat_bits = 32 ; fs -> root_cluster = le32toh ( b . root_cluster ) ; if ( ! fs -> root_cluster && fs -> root_entries ) printf ( ""Warning:<S2SV_blank>FAT32<S2SV_blank>root<S2SV_blank>dir<S2SV_blank>not<S2SV_blank>in<S2SV_blank>cluster<S2SV_blank>chain!<S2SV_blank>"" ""Compatibility<S2SV_blank>mode...\\n"" ) ; else if ( ! fs -> root_cluster && ! fs -> root_entries ) die ( ""No<S2SV_blank>root<S2SV_blank>directory!"" ) ; else if ( fs -> root_cluster && fs -> root_entries ) printf ( ""Warning:<S2SV_blank>FAT32<S2SV_blank>root<S2SV_blank>dir<S2SV_blank>is<S2SV_blank>in<S2SV_blank>a<S2SV_blank>cluster<S2SV_blank>chain,<S2SV_blank>but<S2SV_blank>"" ""a<S2SV_blank>separate<S2SV_blank>root<S2SV_blank>dir\\n"" ""<S2SV_blank><S2SV_blank>area<S2SV_blank>is<S2SV_blank>defined.<S2SV_blank>Cannot<S2SV_blank>fix<S2SV_blank>this<S2SV_blank>easily.\\n"" ) ; if ( fs -> data_clusters < FAT16_THRESHOLD ) printf ( ""Warning:<S2SV_blank>Filesystem<S2SV_blank>is<S2SV_blank>FAT32<S2SV_blank>according<S2SV_blank>to<S2SV_blank>fat_length<S2SV_blank>"" ""and<S2SV_blank>fat32_length<S2SV_blank>fields,\\n"" ""<S2SV_blank><S2SV_blank>but<S2SV_blank>has<S2SV_blank>only<S2SV_blank>%lu<S2SV_blank>clusters,<S2SV_blank>less<S2SV_blank>than<S2SV_blank>the<S2SV_blank>required<S2SV_blank>"" ""minimum<S2SV_blank>of<S2SV_blank>%d.\\n"" ""<S2SV_blank><S2SV_blank>This<S2SV_blank>may<S2SV_blank>lead<S2SV_blank>to<S2SV_blank>problems<S2SV_blank>on<S2SV_blank>some<S2SV_blank>systems.\\n"" , ( unsigned long ) fs -> data_clusters , FAT16_THRESHOLD ) ; check_fat_state_bit ( fs , & b ) ; fs -> backupboot_start = le16toh ( b . backup_boot ) * logical_sector_size ; check_backup_boot ( fs , & b , logical_sector_size ) ; read_fsinfo ( fs , & b , logical_sector_size ) ; } else if ( ! atari_format ) { fs -> fat_bits = ( fs -> data_clusters >= FAT12_THRESHOLD ) ? 16 : 12 ; if ( fs -> data_clusters >= FAT16_THRESHOLD ) die ( ""Too<S2SV_blank>many<S2SV_blank>clusters<S2SV_blank>(%lu)<S2SV_blank>for<S2SV_blank>FAT16<S2SV_blank>filesystem."" , fs -> data_clusters ) ; check_fat_state_bit ( fs , & b ) ; } else { fs -> fat_bits = 16 ; if ( fs -> data_clusters + 2 > fat_length * logical_sector_size * 8 / 16 || ( total_sectors == 720 || total_sectors == 1440 || total_sectors == 2880 ) ) fs -> fat_bits = 12 ; } fs -> eff_fat_bits = ( fs -> fat_bits == 32 ) ? 28 : fs -> fat_bits ; fs -> fat_size = fat_length * logical_sector_size ; fs -> label = calloc ( 12 , sizeof ( uint8_t ) ) ; if ( fs -> fat_bits == 12 || fs -> fat_bits == 16 ) { struct boot_sector_16 * b16 = ( struct boot_sector_16 * ) & b ; if ( b16 -> extended_sig == 0x29 ) memmove ( fs -> label , b16 -> label , 11 ) ; else fs -> label = NULL ; } else if ( fs -> fat_bits == 32 ) { if ( b . extended_sig == 0x29 ) memmove ( fs -> label , & b . label , 11 ) ; else fs -> label = NULL ; } total_fat_entries = ( uint64_t ) fs -> fat_size * 8 / fs -> fat_bits ; if ( fs -> data_clusters > total_fat_entries - 2 ) die ( ""Filesystem<S2SV_blank>has<S2SV_blank>%u<S2SV_blank>clusters<S2SV_blank>but<S2SV_blank>only<S2SV_blank>space<S2SV_blank>for<S2SV_blank>%u<S2SV_blank>FAT<S2SV_blank>entries."" , fs -> data_clusters , total_fat_entries - 2 ) ; if ( ! fs -> root_entries && ! fs -> root_cluster ) die ( ""Root<S2SV_blank>directory<S2SV_blank>has<S2SV_blank>zero<S2SV_blank>size."" ) ; if ( fs -> root_entries & ( MSDOS_DPS - 1 ) ) die ( ""Root<S2SV_blank>directory<S2SV_blank>(%d<S2SV_blank>entries)<S2SV_blank>doesn\'t<S2SV_blank>span<S2SV_blank>an<S2SV_blank>integral<S2SV_blank>number<S2SV_blank>of<S2SV_blank>"" ""sectors."" , fs -> root_entries ) ; if ( logical_sector_size & ( SECTOR_SIZE - 1 ) ) die ( ""Logical<S2SV_blank>sector<S2SV_blank>size<S2SV_blank>(%d<S2SV_blank>bytes)<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>multiple<S2SV_blank>of<S2SV_blank>the<S2SV_blank>physical<S2SV_blank>"" ""sector<S2SV_blank>size."" , logical_sector_size ) ; # if 0 if ( ! atari_format && ( ! b . secs_track || ! b . heads ) ) die ( ""Invalid<S2SV_blank>disk<S2SV_blank>format<S2SV_blank>in<S2SV_blank>boot<S2SV_blank>sector."" ) ; # endif if ( verbose ) dump_boot ( fs , & b , logical_sector_size ) ; }",", sectors ; off_t <S2SV_ModEnd> fat_length ; unsigned <S2SV_ModStart> fat32_length ) ; if ( ! fat_length ) die ( ""FAT<S2SV_blank>size<S2SV_blank>is<S2SV_blank>zero."" ) ; <S2SV_ModStart> fs -> data_start ; if ( data_size < fs -> cluster_size ) die ( ""Filesystem<S2SV_blank>has<S2SV_blank>no<S2SV_blank>space<S2SV_blank>for<S2SV_blank>any<S2SV_blank>data<S2SV_blank>clusters"" )"
377,"int tcp_v4_rcv ( struct sk_buff * skb ) { struct net * net = dev_net ( skb -> dev ) ; const struct iphdr * iph ; const struct tcphdr * th ; bool refcounted ; struct sock * sk ; int ret ; if ( skb -> pkt_type != PACKET_HOST ) goto discard_it ; __TCP_INC_STATS ( net , TCP_MIB_INSEGS ) ; if ( ! pskb_may_pull ( skb , sizeof ( struct tcphdr ) ) ) goto discard_it ; th = ( const struct tcphdr * ) skb -> data ; if ( unlikely ( th -> doff < sizeof ( struct tcphdr ) / 4 ) ) goto bad_packet ; if ( ! pskb_may_pull ( skb , th -> doff * 4 ) ) goto discard_it ; if ( skb_checksum_init ( skb , IPPROTO_TCP , inet_compute_pseudo ) ) goto csum_error ; th = ( const struct tcphdr * ) skb -> data ; iph = ip_hdr ( skb ) ; memmove ( & TCP_SKB_CB ( skb ) -> header . h4 , IPCB ( skb ) , sizeof ( struct inet_skb_parm ) ) ; barrier ( ) ; TCP_SKB_CB ( skb ) -> seq = ntohl ( th -> seq ) ; TCP_SKB_CB ( skb ) -> end_seq = ( TCP_SKB_CB ( skb ) -> seq + th -> syn + th -> fin + skb -> len - th -> doff * 4 ) ; TCP_SKB_CB ( skb ) -> ack_seq = ntohl ( th -> ack_seq ) ; TCP_SKB_CB ( skb ) -> tcp_flags = tcp_flag_byte ( th ) ; TCP_SKB_CB ( skb ) -> tcp_tw_isn = 0 ; TCP_SKB_CB ( skb ) -> ip_dsfield = ipv4_get_dsfield ( iph ) ; TCP_SKB_CB ( skb ) -> sacked = 0 ; lookup : sk = __inet_lookup_skb ( & tcp_hashinfo , skb , __tcp_hdrlen ( th ) , th -> source , th -> dest , & refcounted ) ; if ( ! sk ) goto no_tcp_socket ; process : if ( sk -> sk_state == TCP_TIME_WAIT ) goto do_time_wait ; if ( sk -> sk_state == TCP_NEW_SYN_RECV ) { struct request_sock * req = inet_reqsk ( sk ) ; struct sock * nsk ; sk = req -> rsk_listener ; if ( unlikely ( tcp_v4_inbound_md5_hash ( sk , skb ) ) ) { sk_drops_add ( sk , skb ) ; reqsk_put ( req ) ; goto discard_it ; } if ( unlikely ( sk -> sk_state != TCP_LISTEN ) ) { inet_csk_reqsk_queue_drop_and_put ( sk , req ) ; goto lookup ; } sock_hold ( sk ) ; refcounted = true ; nsk = tcp_check_req ( sk , skb , req , false ) ; if ( ! nsk ) { reqsk_put ( req ) ; goto discard_and_relse ; } if ( nsk == sk ) { reqsk_put ( req ) ; } else if ( tcp_child_process ( sk , nsk , skb ) ) { tcp_v4_send_reset ( nsk , skb ) ; goto discard_and_relse ; } else { sock_put ( sk ) ; return 0 ; } } if ( unlikely ( iph -> ttl < inet_sk ( sk ) -> min_ttl ) ) { __NET_INC_STATS ( net , LINUX_MIB_TCPMINTTLDROP ) ; goto discard_and_relse ; } if ( ! xfrm4_policy_check ( sk , XFRM_POLICY_IN , skb ) ) goto discard_and_relse ; if ( tcp_v4_inbound_md5_hash ( sk , skb ) ) goto discard_and_relse ; nf_reset ( skb ) ; <S2SV_StartBug> if ( sk_filter ( sk , skb ) ) <S2SV_EndBug> <S2SV_StartBug> goto discard_and_relse ; <S2SV_EndBug> skb -> dev = NULL ; if ( sk -> sk_state == TCP_LISTEN ) { ret = tcp_v4_do_rcv ( sk , skb ) ; goto put_and_return ; } sk_incoming_cpu_update ( sk ) ; bh_lock_sock_nested ( sk ) ; tcp_segs_in ( tcp_sk ( sk ) , skb ) ; ret = 0 ; if ( ! sock_owned_by_user ( sk ) ) { if ( ! tcp_prequeue ( sk , skb ) ) ret = tcp_v4_do_rcv ( sk , skb ) ; } else if ( tcp_add_backlog ( sk , skb ) ) { goto discard_and_relse ; } bh_unlock_sock ( sk ) ; put_and_return : if ( refcounted ) sock_put ( sk ) ; return ret ; no_tcp_socket : if ( ! xfrm4_policy_check ( NULL , XFRM_POLICY_IN , skb ) ) goto discard_it ; if ( tcp_checksum_complete ( skb ) ) { csum_error : __TCP_INC_STATS ( net , TCP_MIB_CSUMERRORS ) ; bad_packet : __TCP_INC_STATS ( net , TCP_MIB_INERRS ) ; } else { tcp_v4_send_reset ( NULL , skb ) ; } discard_it : kfree_skb ( skb ) ; return 0 ; discard_and_relse : sk_drops_add ( sk , skb ) ; if ( refcounted ) sock_put ( sk ) ; goto discard_it ; do_time_wait : if ( ! xfrm4_policy_check ( NULL , XFRM_POLICY_IN , skb ) ) { inet_twsk_put ( inet_twsk ( sk ) ) ; goto discard_it ; } if ( tcp_checksum_complete ( skb ) ) { inet_twsk_put ( inet_twsk ( sk ) ) ; goto csum_error ; } switch ( tcp_timewait_state_process ( inet_twsk ( sk ) , skb , th ) ) { case TCP_TW_SYN : { struct sock * sk2 = inet_lookup_listener ( dev_net ( skb -> dev ) , & tcp_hashinfo , skb , __tcp_hdrlen ( th ) , iph -> saddr , th -> source , iph -> daddr , th -> dest , inet_iif ( skb ) ) ; if ( sk2 ) { inet_twsk_deschedule_put ( inet_twsk ( sk ) ) ; sk = sk2 ; refcounted = false ; goto process ; } } case TCP_TW_ACK : tcp_v4_timewait_ack ( sk , skb ) ; break ; case TCP_TW_RST : tcp_v4_send_reset ( sk , skb ) ; inet_twsk_deschedule_put ( inet_twsk ( sk ) ) ; goto discard_it ; case TCP_TW_SUCCESS : ; } goto discard_it ; }","; if ( tcp_filter <S2SV_ModEnd> ( sk , <S2SV_ModStart> ) goto discard_and_relse ; th = ( const struct tcphdr * ) skb -> data ; iph = ip_hdr ( skb )"
378,"static int juniper_parse_header ( netdissect_options * ndo , const u_char * p , const struct pcap_pkthdr * h , struct juniper_l2info_t * l2info ) { const struct juniper_cookie_table_t * lp = juniper_cookie_table ; u_int idx , jnx_ext_len , jnx_header_len = 0 ; uint8_t tlv_type , tlv_len ; uint32_t control_word ; int tlv_value ; const u_char * tptr ; l2info -> header_len = 0 ; l2info -> cookie_len = 0 ; l2info -> proto = 0 ; l2info -> length = h -> len ; l2info -> caplen = h -> caplen ; ND_TCHECK2 ( p [ 0 ] , 4 ) ; l2info -> flags = p [ 3 ] ; l2info -> direction = p [ 3 ] & JUNIPER_BPF_PKT_IN ; if ( EXTRACT_24BITS ( p ) != JUNIPER_MGC_NUMBER ) { ND_PRINT ( ( ndo , ""no<S2SV_blank>magic-number<S2SV_blank>found!"" ) ) ; return 0 ; } if ( ndo -> ndo_eflag ) ND_PRINT ( ( ndo , ""%3s<S2SV_blank>"" , tok2str ( juniper_direction_values , ""---"" , l2info -> direction ) ) ) ; jnx_header_len = 4 ; if ( ndo -> ndo_vflag > 1 ) ND_PRINT ( ( ndo , ""\\n\\tJuniper<S2SV_blank>PCAP<S2SV_blank>Flags<S2SV_blank>[%s]"" , bittok2str ( jnx_flag_values , ""none"" , l2info -> flags ) ) ) ; if ( ( l2info -> flags & JUNIPER_BPF_EXT ) == JUNIPER_BPF_EXT ) { tptr = p + jnx_header_len ; ND_TCHECK2 ( tptr [ 0 ] , 2 ) ; jnx_ext_len = EXTRACT_16BITS ( tptr ) ; jnx_header_len += 2 ; tptr += 2 ; jnx_header_len += jnx_ext_len ; if ( ndo -> ndo_vflag > 1 ) ND_PRINT ( ( ndo , "",<S2SV_blank>PCAP<S2SV_blank>Extension(s)<S2SV_blank>total<S2SV_blank>length<S2SV_blank>%u"" , jnx_ext_len ) ) ; ND_TCHECK2 ( tptr [ 0 ] , jnx_ext_len ) ; while ( jnx_ext_len > JUNIPER_EXT_TLV_OVERHEAD ) { tlv_type = * ( tptr ++ ) ; tlv_len = * ( tptr ++ ) ; tlv_value = 0 ; if ( tlv_type == 0 || tlv_len == 0 ) break ; if ( tlv_len + JUNIPER_EXT_TLV_OVERHEAD > jnx_ext_len ) goto trunc ; if ( ndo -> ndo_vflag > 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Extension<S2SV_blank>TLV<S2SV_blank>#%u,<S2SV_blank>length<S2SV_blank>%u,<S2SV_blank>value<S2SV_blank>"" , tok2str ( jnx_ext_tlv_values , ""Unknown"" , tlv_type ) , tlv_type , tlv_len ) ) ; tlv_value = juniper_read_tlv_value ( tptr , tlv_type , tlv_len ) ; switch ( tlv_type ) { case JUNIPER_EXT_TLV_IFD_NAME : break ; case JUNIPER_EXT_TLV_IFD_MEDIATYPE : case JUNIPER_EXT_TLV_TTP_IFD_MEDIATYPE : if ( tlv_value != - 1 ) { if ( ndo -> ndo_vflag > 1 ) ND_PRINT ( ( ndo , ""%s<S2SV_blank>(%u)"" , tok2str ( juniper_ifmt_values , ""Unknown"" , tlv_value ) , tlv_value ) ) ; } break ; case JUNIPER_EXT_TLV_IFL_ENCAPS : case JUNIPER_EXT_TLV_TTP_IFL_ENCAPS : if ( tlv_value != - 1 ) { if ( ndo -> ndo_vflag > 1 ) ND_PRINT ( ( ndo , ""%s<S2SV_blank>(%u)"" , tok2str ( juniper_ifle_values , ""Unknown"" , tlv_value ) , tlv_value ) ) ; } break ; case JUNIPER_EXT_TLV_IFL_IDX : case JUNIPER_EXT_TLV_IFL_UNIT : case JUNIPER_EXT_TLV_IFD_IDX : default : if ( tlv_value != - 1 ) { if ( ndo -> ndo_vflag > 1 ) ND_PRINT ( ( ndo , ""%u"" , tlv_value ) ) ; } break ; } tptr += tlv_len ; jnx_ext_len -= tlv_len + JUNIPER_EXT_TLV_OVERHEAD ; } if ( ndo -> ndo_vflag > 1 ) ND_PRINT ( ( ndo , ""\\n\\t-----original<S2SV_blank>packet-----\\n\\t"" ) ) ; } if ( ( l2info -> flags & JUNIPER_BPF_NO_L2 ) == JUNIPER_BPF_NO_L2 ) { if ( ndo -> ndo_eflag ) ND_PRINT ( ( ndo , ""no-L2-hdr,<S2SV_blank>"" ) ) ; ND_TCHECK2 ( p [ jnx_header_len + 4 ] , 1 ) ; if ( ip_heuristic_guess ( ndo , p + jnx_header_len + 4 , l2info -> length - ( jnx_header_len + 4 ) ) == 0 ) ND_PRINT ( ( ndo , ""no<S2SV_blank>IP-hdr<S2SV_blank>found!"" ) ) ; l2info -> header_len = jnx_header_len + 4 ; return 0 ; } l2info -> header_len = jnx_header_len ; p += l2info -> header_len ; l2info -> length -= l2info -> header_len ; l2info -> caplen -= l2info -> header_len ; <S2SV_StartBug> while ( lp -> s != NULL ) { <S2SV_EndBug> if ( lp -> pictype == l2info -> pictype ) { l2info -> cookie_len += lp -> cookie_len ; switch ( p [ 0 ] ) { case LS_COOKIE_ID : l2info -> cookie_type = LS_COOKIE_ID ; l2info -> cookie_len += 2 ; break ; case AS_COOKIE_ID : l2info -> cookie_type = AS_COOKIE_ID ; l2info -> cookie_len = 8 ; break ; default : l2info -> bundle = l2info -> cookie [ 0 ] ; break ; } # ifdef DLT_JUNIPER_MFR if ( l2info -> pictype == DLT_JUNIPER_MFR && ( p [ 0 ] & MFR_BE_MASK ) == MFR_BE_MASK ) { l2info -> cookie_len = 0 ; } # endif l2info -> header_len += l2info -> cookie_len ; l2info -> length -= l2info -> cookie_len ; l2info -> caplen -= l2info -> cookie_len ; if ( ndo -> ndo_eflag ) ND_PRINT ( ( ndo , ""%s-PIC,<S2SV_blank>cookie-len<S2SV_blank>%u"" , lp -> s , l2info -> cookie_len ) ) ; if ( l2info -> cookie_len > 0 ) { ND_TCHECK2 ( p [ 0 ] , l2info -> cookie_len ) ; if ( ndo -> ndo_eflag ) ND_PRINT ( ( ndo , "",<S2SV_blank>cookie<S2SV_blank>0x"" ) ) ; for ( idx = 0 ; idx < l2info -> cookie_len ; idx ++ ) { l2info -> cookie [ idx ] = p [ idx ] ; if ( ndo -> ndo_eflag ) ND_PRINT ( ( ndo , ""%02x"" , p [ idx ] ) ) ; } } if ( ndo -> ndo_eflag ) ND_PRINT ( ( ndo , "":<S2SV_blank>"" ) ) ; l2info -> proto = EXTRACT_16BITS ( p + l2info -> cookie_len ) ; break ; } ++ lp ; } p += l2info -> cookie_len ; switch ( l2info -> pictype ) { # ifdef DLT_JUNIPER_MLPPP case DLT_JUNIPER_MLPPP : switch ( l2info -> cookie_type ) { case LS_COOKIE_ID : l2info -> bundle = l2info -> cookie [ 1 ] ; break ; case AS_COOKIE_ID : l2info -> bundle = ( EXTRACT_16BITS ( & l2info -> cookie [ 6 ] ) >> 3 ) & 0xfff ; l2info -> proto = ( l2info -> cookie [ 5 ] ) & JUNIPER_LSQ_L3_PROTO_MASK ; break ; default : l2info -> bundle = l2info -> cookie [ 0 ] ; break ; } break ; # endif # ifdef DLT_JUNIPER_MLFR case DLT_JUNIPER_MLFR : switch ( l2info -> cookie_type ) { case LS_COOKIE_ID : <S2SV_StartBug> l2info -> bundle = l2info -> cookie [ 1 ] ; <S2SV_EndBug> l2info -> proto = EXTRACT_16BITS ( p ) ; l2info -> header_len += 2 ; l2info -> length -= 2 ; l2info -> caplen -= 2 ; break ; case AS_COOKIE_ID : l2info -> bundle = ( EXTRACT_16BITS ( & l2info -> cookie [ 6 ] ) >> 3 ) & 0xfff ; l2info -> proto = ( l2info -> cookie [ 5 ] ) & JUNIPER_LSQ_L3_PROTO_MASK ; break ; default : l2info -> bundle = l2info -> cookie [ 0 ] ; l2info -> header_len += 2 ; l2info -> length -= 2 ; l2info -> caplen -= 2 ; break ; } break ; # endif # ifdef DLT_JUNIPER_MFR case DLT_JUNIPER_MFR : switch ( l2info -> cookie_type ) { case LS_COOKIE_ID : <S2SV_StartBug> l2info -> bundle = l2info -> cookie [ 1 ] ; <S2SV_EndBug> l2info -> proto = EXTRACT_16BITS ( p ) ; l2info -> header_len += 2 ; l2info -> length -= 2 ; l2info -> caplen -= 2 ; break ; case AS_COOKIE_ID : l2info -> bundle = ( EXTRACT_16BITS ( & l2info -> cookie [ 6 ] ) >> 3 ) & 0xfff ; l2info -> proto = ( l2info -> cookie [ 5 ] ) & JUNIPER_LSQ_L3_PROTO_MASK ; break ; default : l2info -> bundle = l2info -> cookie [ 0 ] ; break ; } break ; # endif # ifdef DLT_JUNIPER_ATM2 case DLT_JUNIPER_ATM2 : ND_TCHECK2 ( p [ 0 ] , 4 ) ; if ( l2info -> cookie [ 7 ] & ATM2_PKT_TYPE_MASK ) { control_word = EXTRACT_32BITS ( p ) ; switch ( control_word ) { case 0 : case 0x08000000 : case 0x08380000 : l2info -> header_len += 4 ; break ; default : break ; } if ( ndo -> ndo_eflag ) ND_PRINT ( ( ndo , ""control-word<S2SV_blank>0x%08x<S2SV_blank>"" , control_word ) ) ; } break ; # endif # ifdef DLT_JUNIPER_GGSN case DLT_JUNIPER_GGSN : break ; # endif # ifdef DLT_JUNIPER_ATM1 case DLT_JUNIPER_ATM1 : break ; # endif # ifdef DLT_JUNIPER_PPP case DLT_JUNIPER_PPP : break ; # endif # ifdef DLT_JUNIPER_CHDLC case DLT_JUNIPER_CHDLC : break ; # endif # ifdef DLT_JUNIPER_ETHER case DLT_JUNIPER_ETHER : break ; # endif # ifdef DLT_JUNIPER_FRELAY case DLT_JUNIPER_FRELAY : break ; # endif default : ND_PRINT ( ( ndo , ""Unknown<S2SV_blank>Juniper<S2SV_blank>DLT_<S2SV_blank>type<S2SV_blank>%u:<S2SV_blank>"" , l2info -> pictype ) ) ; break ; } if ( ndo -> ndo_eflag > 1 ) ND_PRINT ( ( ndo , ""hlen<S2SV_blank>%u,<S2SV_blank>proto<S2SV_blank>0x%04x,<S2SV_blank>"" , l2info -> header_len , l2info -> proto ) ) ; return 1 ; trunc : ND_PRINT ( ( ndo , ""[|juniper_hdr],<S2SV_blank>length<S2SV_blank>%u"" , h -> len ) ) ; return 0 ; }","-> header_len ; ND_TCHECK ( p [ 0 ] ) ; <S2SV_ModStart> case LS_COOKIE_ID : ND_TCHECK2 ( p [ 0 ] , 2 ) ; <S2SV_ModStart> case LS_COOKIE_ID : ND_TCHECK2 ( p [ 0 ] , 2 ) ;"
379,const char * cJSON_GetErrorPtr ( void ) { <S2SV_StartBug> return ep ; <S2SV_EndBug> },) { return global_ep <S2SV_ModEnd> ; } <S2SV_null>
380,"WORD32 ih264d_parse_decode_slice ( UWORD8 u1_is_idr_slice , UWORD8 u1_nal_ref_idc , dec_struct_t * ps_dec ) { dec_bit_stream_t * ps_bitstrm = ps_dec -> ps_bitstrm ; dec_pic_params_t * ps_pps ; dec_seq_params_t * ps_seq ; dec_slice_params_t * ps_cur_slice = ps_dec -> ps_cur_slice ; pocstruct_t s_tmp_poc ; WORD32 i_delta_poc [ 2 ] ; WORD32 i4_poc = 0 ; UWORD16 u2_first_mb_in_slice , u2_frame_num ; UWORD8 u1_field_pic_flag , u1_redundant_pic_cnt = 0 , u1_slice_type ; UWORD32 u4_idr_pic_id = 0 ; UWORD8 u1_bottom_field_flag , u1_pic_order_cnt_type ; UWORD8 u1_nal_unit_type ; UWORD32 * pu4_bitstrm_buf = ps_bitstrm -> pu4_buffer ; UWORD32 * pu4_bitstrm_ofst = & ps_bitstrm -> u4_ofst ; WORD8 i1_is_end_of_poc ; WORD32 ret , end_of_frame ; WORD32 prev_slice_err , num_mb_skipped ; UWORD8 u1_mbaff ; pocstruct_t * ps_cur_poc ; UWORD32 u4_temp ; WORD32 i_temp ; UWORD32 u4_call_end_of_pic = 0 ; ps_dec -> ps_dpb_cmds -> u1_dpb_commands_read_slc = 0 ; u2_first_mb_in_slice = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u2_first_mb_in_slice > ( ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) ) { return ERROR_CORRUPTED_SLICE ; } if ( ( ( u2_first_mb_in_slice << ps_cur_slice -> u1_mbaff_frame_flag ) <= ps_dec -> u2_cur_mb_addr ) && ( ps_dec -> u4_first_slice_in_pic == 0 ) ) { return ERROR_CORRUPTED_SLICE ; } COPYTHECONTEXT ( ""SH:<S2SV_blank>first_mb_in_slice"" , u2_first_mb_in_slice ) ; u4_temp = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u4_temp > 9 ) return ERROR_INV_SLC_TYPE_T ; u1_slice_type = u4_temp ; COPYTHECONTEXT ( ""SH:<S2SV_blank>slice_type"" , ( u1_slice_type ) ) ; ps_dec -> u1_sl_typ_5_9 = 0 ; if ( u1_slice_type > 4 ) { u1_slice_type -= 5 ; ps_dec -> u1_sl_typ_5_9 = 1 ; } { UWORD32 skip ; if ( ( ps_dec -> i4_app_skip_mode == IVD_SKIP_PB ) || ( ps_dec -> i4_dec_skip_mode == IVD_SKIP_PB ) ) { UWORD32 u4_bit_stream_offset = 0 ; if ( ps_dec -> u1_nal_unit_type == IDR_SLICE_NAL ) { skip = 0 ; ps_dec -> i4_dec_skip_mode = IVD_SKIP_NONE ; } else if ( ( I_SLICE == u1_slice_type ) && ( 1 >= ps_dec -> ps_cur_sps -> u1_num_ref_frames ) ) { skip = 0 ; ps_dec -> i4_dec_skip_mode = IVD_SKIP_NONE ; } else { skip = 1 ; } if ( ( 0 == u2_first_mb_in_slice ) && ( 1 == ps_dec -> u4_prev_nal_skipped ) ) { skip = 0 ; } if ( skip ) { ps_dec -> u4_prev_nal_skipped = 1 ; ps_dec -> i4_dec_skip_mode = IVD_SKIP_PB ; return 0 ; } else { if ( 1 == ps_dec -> u4_prev_nal_skipped ) { ps_dec -> u4_return_to_app = 1 ; return 0 ; } } } } u4_temp = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u4_temp & MASK_ERR_PIC_SET_ID ) <S2SV_StartBug> return ERROR_INV_SPS_PPS_T ; <S2SV_EndBug> COPYTHECONTEXT ( ""SH:<S2SV_blank>pic_parameter_set_id"" , u4_temp ) ; ps_pps = & ps_dec -> ps_pps [ u4_temp ] ; if ( FALSE == ps_pps -> u1_is_valid ) { <S2SV_StartBug> return ERROR_INV_SPS_PPS_T ; <S2SV_EndBug> } ps_seq = ps_pps -> ps_sps ; if ( ! ps_seq ) <S2SV_StartBug> return ERROR_INV_SPS_PPS_T ; <S2SV_EndBug> if ( FALSE == ps_seq -> u1_is_valid ) <S2SV_StartBug> return ERROR_INV_SPS_PPS_T ; <S2SV_EndBug> u2_frame_num = ih264d_get_bits_h264 ( ps_bitstrm , ps_seq -> u1_bits_in_frm_num ) ; COPYTHECONTEXT ( ""SH:<S2SV_blank>frame_num"" , u2_frame_num ) ; if ( ! ps_seq -> u1_frame_mbs_only_flag ) { u1_field_pic_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( ""SH:<S2SV_blank>field_pic_flag"" , u1_field_pic_flag ) ; u1_bottom_field_flag = 0 ; if ( u1_field_pic_flag ) { ps_dec -> pu1_inv_scan = ( UWORD8 * ) gau1_ih264d_inv_scan_fld ; u1_bottom_field_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( ""SH:<S2SV_blank>bottom_field_flag"" , u1_bottom_field_flag ) ; } else { ps_dec -> pu1_inv_scan = ( UWORD8 * ) gau1_ih264d_inv_scan ; } } else { u1_field_pic_flag = 0 ; u1_bottom_field_flag = 0 ; ps_dec -> pu1_inv_scan = ( UWORD8 * ) gau1_ih264d_inv_scan ; } u1_nal_unit_type = SLICE_NAL ; if ( u1_is_idr_slice ) { if ( 0 == u1_field_pic_flag ) { ps_dec -> u1_top_bottom_decoded = TOP_FIELD_ONLY | BOT_FIELD_ONLY ; } u1_nal_unit_type = IDR_SLICE_NAL ; u4_idr_pic_id = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u4_idr_pic_id > 65535 ) <S2SV_StartBug> return ERROR_INV_SPS_PPS_T ; <S2SV_EndBug> COPYTHECONTEXT ( ""SH:<S2SV_blank><S2SV_blank>"" , u4_idr_pic_id ) ; } i_delta_poc [ 0 ] = i_delta_poc [ 1 ] = 0 ; s_tmp_poc . i4_pic_order_cnt_lsb = 0 ; s_tmp_poc . i4_delta_pic_order_cnt_bottom = 0 ; u1_pic_order_cnt_type = ps_seq -> u1_pic_order_cnt_type ; if ( u1_pic_order_cnt_type == 0 ) { i_temp = ih264d_get_bits_h264 ( ps_bitstrm , ps_seq -> u1_log2_max_pic_order_cnt_lsb_minus ) ; if ( i_temp < 0 || i_temp >= ps_seq -> i4_max_pic_order_cntLsb ) <S2SV_StartBug> return ERROR_INV_SPS_PPS_T ; <S2SV_EndBug> s_tmp_poc . i4_pic_order_cnt_lsb = i_temp ; COPYTHECONTEXT ( ""SH:<S2SV_blank>pic_order_cnt_lsb"" , s_tmp_poc . i4_pic_order_cnt_lsb ) ; if ( ( ps_pps -> u1_pic_order_present_flag == 1 ) && ( ! u1_field_pic_flag ) ) { s_tmp_poc . i4_delta_pic_order_cnt_bottom = ih264d_sev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; COPYTHECONTEXT ( ""SH:<S2SV_blank>delta_pic_order_cnt_bottom"" , s_tmp_poc . i4_delta_pic_order_cnt_bottom ) ; } } s_tmp_poc . i4_delta_pic_order_cnt [ 0 ] = 0 ; s_tmp_poc . i4_delta_pic_order_cnt [ 1 ] = 0 ; if ( u1_pic_order_cnt_type == 1 && ( ! ps_seq -> u1_delta_pic_order_always_zero_flag ) ) { s_tmp_poc . i4_delta_pic_order_cnt [ 0 ] = ih264d_sev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; COPYTHECONTEXT ( ""SH:<S2SV_blank>delta_pic_order_cnt[0]"" , s_tmp_poc . i4_delta_pic_order_cnt [ 0 ] ) ; if ( ps_pps -> u1_pic_order_present_flag && ! u1_field_pic_flag ) { s_tmp_poc . i4_delta_pic_order_cnt [ 1 ] = ih264d_sev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; COPYTHECONTEXT ( ""SH:<S2SV_blank>delta_pic_order_cnt[1]"" , s_tmp_poc . i4_delta_pic_order_cnt [ 1 ] ) ; } } if ( ps_pps -> u1_redundant_pic_cnt_present_flag ) { u4_temp = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u4_temp > MAX_REDUNDANT_PIC_CNT ) <S2SV_StartBug> return ERROR_INV_SPS_PPS_T ; <S2SV_EndBug> u1_redundant_pic_cnt = u4_temp ; COPYTHECONTEXT ( ""SH:<S2SV_blank>redundant_pic_cnt"" , u1_redundant_pic_cnt ) ; } i1_is_end_of_poc = 0 ; if ( ! ps_dec -> u1_first_slice_in_stream ) { i1_is_end_of_poc = ih264d_is_end_of_pic ( u2_frame_num , u1_nal_ref_idc , & s_tmp_poc , & ps_dec -> s_cur_pic_poc , ps_cur_slice , u1_pic_order_cnt_type , u1_nal_unit_type , u4_idr_pic_id , u1_field_pic_flag , u1_bottom_field_flag ) ; if ( ( ps_dec -> u4_first_slice_in_pic == 2 ) && ( i1_is_end_of_poc == 0 ) ) { ps_dec -> ps_dec_err_status -> u1_err_flag |= REJECT_CUR_PIC ; i1_is_end_of_poc = 1 ; } else { ps_dec -> ps_dec_err_status -> u1_err_flag &= MASK_REJECT_CUR_PIC ; } } u1_mbaff = ps_seq -> u1_mb_aff_flag && ( ! u1_field_pic_flag ) ; prev_slice_err = 0 ; if ( i1_is_end_of_poc || ps_dec -> u1_first_slice_in_stream ) { if ( u2_frame_num != ps_dec -> u2_prv_frame_num && ps_dec -> u1_top_bottom_decoded != 0 && ps_dec -> u1_top_bottom_decoded != ( TOP_FIELD_ONLY | BOT_FIELD_ONLY ) ) { ps_dec -> u1_dangling_field = 1 ; if ( ps_dec -> u4_first_slice_in_pic ) { prev_slice_err = 1 ; } else { prev_slice_err = 2 ; } if ( ps_dec -> u1_top_bottom_decoded == TOP_FIELD_ONLY ) ps_cur_slice -> u1_bottom_field_flag = 1 ; else ps_cur_slice -> u1_bottom_field_flag = 0 ; num_mb_skipped = ( ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) - ps_dec -> u2_total_mbs_coded ; ps_cur_poc = & ps_dec -> s_cur_pic_poc ; u1_is_idr_slice = ps_cur_slice -> u1_nal_unit_type == IDR_SLICE_NAL ; } else if ( ps_dec -> u4_first_slice_in_pic == 2 ) { if ( u2_first_mb_in_slice > 0 ) { prev_slice_err = 1 ; num_mb_skipped = u2_first_mb_in_slice << u1_mbaff ; ps_cur_poc = & s_tmp_poc ; ps_cur_slice -> u4_idr_pic_id = u4_idr_pic_id ; ps_cur_slice -> u1_field_pic_flag = u1_field_pic_flag ; ps_cur_slice -> u1_bottom_field_flag = u1_bottom_field_flag ; ps_cur_slice -> i4_pic_order_cnt_lsb = s_tmp_poc . i4_pic_order_cnt_lsb ; ps_cur_slice -> u1_nal_unit_type = u1_nal_unit_type ; ps_cur_slice -> u1_redundant_pic_cnt = u1_redundant_pic_cnt ; ps_cur_slice -> u1_nal_ref_idc = u1_nal_ref_idc ; ps_cur_slice -> u1_pic_order_cnt_type = u1_pic_order_cnt_type ; ps_cur_slice -> u1_mbaff_frame_flag = ps_seq -> u1_mb_aff_flag && ( ! u1_field_pic_flag ) ; } } else { if ( ps_dec -> u4_first_slice_in_pic ) { prev_slice_err = 1 ; num_mb_skipped = u2_first_mb_in_slice << u1_mbaff ; } else { prev_slice_err = 2 ; num_mb_skipped = ( ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) - ps_dec -> u2_total_mbs_coded ; } ps_cur_poc = & s_tmp_poc ; } } else { if ( ( u2_first_mb_in_slice << u1_mbaff ) > ps_dec -> u2_total_mbs_coded ) { prev_slice_err = 2 ; num_mb_skipped = ( u2_first_mb_in_slice << u1_mbaff ) - ps_dec -> u2_total_mbs_coded ; ps_cur_poc = & s_tmp_poc ; } else if ( ( u2_first_mb_in_slice << u1_mbaff ) < ps_dec -> u2_total_mbs_coded ) { return ERROR_CORRUPTED_SLICE ; } } if ( prev_slice_err ) { ret = ih264d_mark_err_slice_skip ( ps_dec , num_mb_skipped , u1_is_idr_slice , u2_frame_num , ps_cur_poc , prev_slice_err ) ; if ( ps_dec -> u1_dangling_field == 1 ) { ps_dec -> u1_second_field = 1 - ps_dec -> u1_second_field ; ps_cur_slice -> u1_bottom_field_flag = u1_bottom_field_flag ; ps_dec -> u2_prv_frame_num = u2_frame_num ; ps_dec -> u1_first_slice_in_stream = 0 ; return ERROR_DANGLING_FIELD_IN_PIC ; } if ( prev_slice_err == 2 ) { ps_dec -> u1_first_slice_in_stream = 0 ; return ERROR_INCOMPLETE_FRAME ; } if ( ps_dec -> u2_total_mbs_coded >= ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) { ps_dec -> u1_first_slice_in_stream = 0 ; return ERROR_IN_LAST_SLICE_OF_PIC ; } if ( ps_dec -> ps_dec_err_status -> u1_err_flag & REJECT_CUR_PIC ) { ih264d_err_pic_dispbuf_mgr ( ps_dec ) ; return ERROR_NEW_FRAME_EXPECTED ; } if ( ret != OK ) return ret ; i1_is_end_of_poc = 0 ; } if ( ps_dec -> u4_first_slice_in_pic == 0 ) { ps_dec -> ps_parse_cur_slice ++ ; ps_dec -> u2_cur_slice_num ++ ; } if ( ( ps_dec -> u1_separate_parse == 0 ) && ( ps_dec -> u4_first_slice_in_pic == 0 ) ) { ps_dec -> ps_decode_cur_slice ++ ; } ps_dec -> u1_slice_header_done = 0 ; if ( ! ps_dec -> u1_first_slice_in_stream ) { UWORD8 uc_mbs_exceed = 0 ; if ( ps_dec -> u2_total_mbs_coded == ( ps_dec -> ps_cur_sps -> u2_max_mb_addr + 1 ) ) { if ( ps_dec -> u4_first_slice_in_pic == 0 ) uc_mbs_exceed = 1 ; } if ( i1_is_end_of_poc || uc_mbs_exceed ) { if ( 1 == ps_dec -> u1_last_pic_not_decoded ) { ret = ih264d_end_of_pic_dispbuf_mgr ( ps_dec ) ; if ( ret != OK ) return ret ; ret = ih264d_end_of_pic ( ps_dec , u1_is_idr_slice , u2_frame_num ) ; if ( ret != OK ) return ret ; # if WIN32 H264_DEC_DEBUG_PRINT ( ""<S2SV_blank>------<S2SV_blank>PIC<S2SV_blank>SKIPPED<S2SV_blank>------\\n"" ) ; # endif return RET_LAST_SKIP ; } else { ret = ih264d_end_of_pic ( ps_dec , u1_is_idr_slice , u2_frame_num ) ; if ( ret != OK ) return ret ; } } } if ( u1_field_pic_flag ) { ps_dec -> u2_prv_frame_num = u2_frame_num ; } if ( ps_cur_slice -> u1_mmco_equalto5 ) { WORD32 i4_temp_poc ; WORD32 i4_top_field_order_poc , i4_bot_field_order_poc ; if ( ! ps_cur_slice -> u1_field_pic_flag ) { i4_top_field_order_poc = ps_dec -> ps_cur_pic -> i4_top_field_order_cnt ; i4_bot_field_order_poc = ps_dec -> ps_cur_pic -> i4_bottom_field_order_cnt ; i4_temp_poc = MIN ( i4_top_field_order_poc , i4_bot_field_order_poc ) ; } else if ( ! ps_cur_slice -> u1_bottom_field_flag ) i4_temp_poc = ps_dec -> ps_cur_pic -> i4_top_field_order_cnt ; else i4_temp_poc = ps_dec -> ps_cur_pic -> i4_bottom_field_order_cnt ; ps_dec -> ps_cur_pic -> i4_top_field_order_cnt = i4_temp_poc - ps_dec -> ps_cur_pic -> i4_top_field_order_cnt ; ps_dec -> ps_cur_pic -> i4_bottom_field_order_cnt = i4_temp_poc - ps_dec -> ps_cur_pic -> i4_bottom_field_order_cnt ; ps_dec -> ps_cur_pic -> i4_poc = i4_temp_poc ; ps_dec -> ps_cur_pic -> i4_avg_poc = i4_temp_poc ; } if ( ps_dec -> u4_first_slice_in_pic == 2 ) { ret = ih264d_decode_pic_order_cnt ( u1_is_idr_slice , u2_frame_num , & ps_dec -> s_prev_pic_poc , & s_tmp_poc , ps_cur_slice , ps_pps , u1_nal_ref_idc , u1_bottom_field_flag , u1_field_pic_flag , & i4_poc ) ; if ( ret != OK ) return ret ; if ( i4_poc >= ps_dec -> i4_max_poc ) ps_dec -> i4_max_poc = i4_poc ; if ( i4_poc == 0 ) { ps_dec -> i4_prev_max_display_seq = ps_dec -> i4_prev_max_display_seq + ps_dec -> i4_max_poc + ps_dec -> u1_max_dec_frame_buffering + 1 ; ps_dec -> i4_max_poc = 0 ; } } ps_cur_slice -> i4_delta_pic_order_cnt [ 0 ] = i_delta_poc [ 0 ] ; ps_cur_slice -> i4_delta_pic_order_cnt [ 1 ] = i_delta_poc [ 1 ] ; ps_cur_slice -> u4_idr_pic_id = u4_idr_pic_id ; ps_cur_slice -> u2_first_mb_in_slice = u2_first_mb_in_slice ; ps_cur_slice -> u1_field_pic_flag = u1_field_pic_flag ; ps_cur_slice -> u1_bottom_field_flag = u1_bottom_field_flag ; ps_cur_slice -> u1_slice_type = u1_slice_type ; ps_cur_slice -> i4_pic_order_cnt_lsb = s_tmp_poc . i4_pic_order_cnt_lsb ; ps_cur_slice -> u1_nal_unit_type = u1_nal_unit_type ; ps_cur_slice -> u1_redundant_pic_cnt = u1_redundant_pic_cnt ; ps_cur_slice -> u1_nal_ref_idc = u1_nal_ref_idc ; ps_cur_slice -> u1_pic_order_cnt_type = u1_pic_order_cnt_type ; if ( ps_seq -> u1_frame_mbs_only_flag ) ps_cur_slice -> u1_direct_8x8_inference_flag = ps_seq -> u1_direct_8x8_inference_flag ; else ps_cur_slice -> u1_direct_8x8_inference_flag = 1 ; if ( u1_slice_type == B_SLICE ) { ps_cur_slice -> u1_direct_spatial_mv_pred_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( ""SH:<S2SV_blank>direct_spatial_mv_pred_flag"" , ps_cur_slice -> u1_direct_spatial_mv_pred_flag ) ; if ( ps_cur_slice -> u1_direct_spatial_mv_pred_flag ) ps_cur_slice -> pf_decodeDirect = ih264d_decode_spatial_direct ; else ps_cur_slice -> pf_decodeDirect = ih264d_decode_temporal_direct ; if ( ! ( ( ps_pps -> ps_sps -> u1_mb_aff_flag ) && ( ! u1_field_pic_flag ) ) ) ps_dec -> pf_mvpred = ih264d_mvpred_nonmbaffB ; } else { if ( ! ( ( ps_pps -> ps_sps -> u1_mb_aff_flag ) && ( ! u1_field_pic_flag ) ) ) ps_dec -> pf_mvpred = ih264d_mvpred_nonmbaff ; } if ( ps_dec -> u4_first_slice_in_pic == 2 ) { if ( u2_first_mb_in_slice == 0 ) { ret = ih264d_start_of_pic ( ps_dec , i4_poc , & s_tmp_poc , u2_frame_num , ps_pps ) ; if ( ret != OK ) return ret ; } ps_dec -> u4_output_present = 0 ; { ih264d_get_next_display_field ( ps_dec , ps_dec -> ps_out_buffer , & ( ps_dec -> s_disp_op ) ) ; if ( 0 != ps_dec -> s_disp_op . u4_error_code ) { ps_dec -> u4_fmt_conv_cur_row = ps_dec -> s_disp_frame_info . u4_y_ht ; } else ps_dec -> u4_output_present = 1 ; } if ( ps_dec -> u1_separate_parse == 1 ) { if ( ps_dec -> u4_dec_thread_created == 0 ) { ithread_create ( ps_dec -> pv_dec_thread_handle , NULL , ( void * ) ih264d_decode_picture_thread , ( void * ) ps_dec ) ; ps_dec -> u4_dec_thread_created = 1 ; } if ( ( ps_dec -> u4_num_cores == 3 ) && ( ( ps_dec -> u4_app_disable_deblk_frm == 0 ) || ps_dec -> i1_recon_in_thread3_flag ) && ( ps_dec -> u4_bs_deblk_thread_created == 0 ) ) { ps_dec -> u4_start_recon_deblk = 0 ; ithread_create ( ps_dec -> pv_bs_deblk_thread_handle , NULL , ( void * ) ih264d_recon_deblk_thread , ( void * ) ps_dec ) ; ps_dec -> u4_bs_deblk_thread_created = 1 ; } } } { UWORD8 uc_nofield_nombaff ; uc_nofield_nombaff = ( ( ps_dec -> ps_cur_slice -> u1_field_pic_flag == 0 ) && ( ps_dec -> ps_cur_slice -> u1_mbaff_frame_flag == 0 ) && ( u1_slice_type != B_SLICE ) && ( ps_dec -> ps_cur_pps -> u1_wted_pred_flag == 0 ) ) ; if ( uc_nofield_nombaff ) { ps_dec -> p_form_mb_part_info = ih264d_form_mb_part_info_bp ; ps_dec -> p_motion_compensate = ih264d_motion_compensate_bp ; } else { ps_dec -> p_form_mb_part_info = ih264d_form_mb_part_info_mp ; ps_dec -> p_motion_compensate = ih264d_motion_compensate_mp ; } } { dec_err_status_t * ps_err = ps_dec -> ps_dec_err_status ; if ( ps_err -> u4_frm_sei_sync == u2_frame_num ) { ps_err -> u1_err_flag = ACCEPT_ALL_PICS ; ps_err -> u4_frm_sei_sync = SYNC_FRM_DEFAULT ; } ps_err -> u4_cur_frm = u2_frame_num ; } { WORD32 i4_skip_b_pic , i4_skip_p_pic ; i4_skip_b_pic = ( ps_dec -> u4_skip_frm_mask & B_SLC_BIT ) && ( B_SLICE == u1_slice_type ) && ( 0 == u1_nal_ref_idc ) ; i4_skip_p_pic = ( ps_dec -> u4_skip_frm_mask & P_SLC_BIT ) && ( P_SLICE == u1_slice_type ) && ( 0 == u1_nal_ref_idc ) ; if ( i4_skip_b_pic ) { ps_dec -> ps_cur_pic -> u4_pack_slc_typ |= B_SLC_BIT ; ps_dec -> u1_last_pic_not_decoded = 1 ; return OK ; } if ( i4_skip_p_pic ) { ps_dec -> ps_cur_pic -> u4_pack_slc_typ |= P_SLC_BIT ; ps_dec -> u1_last_pic_not_decoded = 1 ; return OK ; } } { UWORD16 u2_mb_x , u2_mb_y ; ps_dec -> i4_submb_ofst = ( ( u2_first_mb_in_slice << ps_cur_slice -> u1_mbaff_frame_flag ) * SUB_BLK_SIZE ) - SUB_BLK_SIZE ; if ( u2_first_mb_in_slice ) { UWORD8 u1_mb_aff ; UWORD8 u1_field_pic ; UWORD16 u2_frm_wd_in_mbs ; u2_frm_wd_in_mbs = ps_seq -> u2_frm_wd_in_mbs ; u1_mb_aff = ps_cur_slice -> u1_mbaff_frame_flag ; u1_field_pic = ps_cur_slice -> u1_field_pic_flag ; { UWORD32 x_offset ; UWORD32 y_offset ; UWORD32 u4_frame_stride ; tfr_ctxt_t * ps_trns_addr ; if ( ps_dec -> u1_separate_parse ) { ps_trns_addr = & ps_dec -> s_tran_addrecon_parse ; } else { ps_trns_addr = & ps_dec -> s_tran_addrecon ; } u2_mb_x = MOD ( u2_first_mb_in_slice , u2_frm_wd_in_mbs ) ; u2_mb_y = DIV ( u2_first_mb_in_slice , u2_frm_wd_in_mbs ) ; u2_mb_y <<= u1_mb_aff ; if ( ( u2_mb_x > u2_frm_wd_in_mbs - 1 ) || ( u2_mb_y > ps_dec -> u2_frm_ht_in_mbs - 1 ) ) { return ERROR_CORRUPTED_SLICE ; } u4_frame_stride = ps_dec -> u2_frm_wd_y << u1_field_pic ; x_offset = u2_mb_x << 4 ; y_offset = ( u2_mb_y * u4_frame_stride ) << 4 ; ps_trns_addr -> pu1_dest_y = ps_dec -> s_cur_pic . pu1_buf1 + x_offset + y_offset ; u4_frame_stride = ps_dec -> u2_frm_wd_uv << u1_field_pic ; x_offset >>= 1 ; y_offset = ( u2_mb_y * u4_frame_stride ) << 3 ; x_offset *= YUV420SP_FACTOR ; ps_trns_addr -> pu1_dest_u = ps_dec -> s_cur_pic . pu1_buf2 + x_offset + y_offset ; ps_trns_addr -> pu1_dest_v = ps_dec -> s_cur_pic . pu1_buf3 + x_offset + y_offset ; ps_trns_addr -> pu1_mb_y = ps_trns_addr -> pu1_dest_y ; ps_trns_addr -> pu1_mb_u = ps_trns_addr -> pu1_dest_u ; ps_trns_addr -> pu1_mb_v = ps_trns_addr -> pu1_dest_v ; if ( ps_dec -> u1_separate_parse == 1 ) { ps_dec -> ps_deblk_mbn = ps_dec -> ps_deblk_pic + ( u2_first_mb_in_slice << u1_mb_aff ) ; } else { ps_dec -> ps_deblk_mbn = ps_dec -> ps_deblk_pic + ( u2_first_mb_in_slice << u1_mb_aff ) ; } ps_dec -> u2_cur_mb_addr = ( u2_first_mb_in_slice << u1_mb_aff ) ; ps_dec -> ps_mv_cur = ps_dec -> s_cur_pic . ps_mv + ( ( u2_first_mb_in_slice << u1_mb_aff ) << 4 ) ; } } else { tfr_ctxt_t * ps_trns_addr ; if ( ps_dec -> u1_separate_parse ) { ps_trns_addr = & ps_dec -> s_tran_addrecon_parse ; } else { ps_trns_addr = & ps_dec -> s_tran_addrecon ; } u2_mb_x = 0xffff ; u2_mb_y = 0 ; ps_dec -> u2_cur_mb_addr = 0 ; ps_dec -> ps_deblk_mbn = ps_dec -> ps_deblk_pic ; ps_dec -> ps_mv_cur = ps_dec -> s_cur_pic . ps_mv ; ps_trns_addr -> pu1_dest_y = ps_dec -> s_cur_pic . pu1_buf1 ; ps_trns_addr -> pu1_dest_u = ps_dec -> s_cur_pic . pu1_buf2 ; ps_trns_addr -> pu1_dest_v = ps_dec -> s_cur_pic . pu1_buf3 ; ps_trns_addr -> pu1_mb_y = ps_trns_addr -> pu1_dest_y ; ps_trns_addr -> pu1_mb_u = ps_trns_addr -> pu1_dest_u ; ps_trns_addr -> pu1_mb_v = ps_trns_addr -> pu1_dest_v ; } ps_dec -> ps_part = ps_dec -> ps_parse_part_params ; ps_dec -> u2_mbx = ( MOD ( u2_first_mb_in_slice - 1 , ps_seq -> u2_frm_wd_in_mbs ) ) ; ps_dec -> u2_mby = ( DIV ( u2_first_mb_in_slice - 1 , ps_seq -> u2_frm_wd_in_mbs ) ) ; ps_dec -> u2_mby <<= ps_cur_slice -> u1_mbaff_frame_flag ; ps_dec -> i2_prev_slice_mbx = ps_dec -> u2_mbx ; ps_dec -> i2_prev_slice_mby = ps_dec -> u2_mby ; } ps_bitstrm -> u4_max_ofst += ps_dec -> ps_cur_pps -> u1_entropy_coding_mode ; ps_dec -> u1_B = ( u1_slice_type == B_SLICE ) ; ps_dec -> u4_next_mb_skip = 0 ; ps_dec -> ps_parse_cur_slice -> u4_first_mb_in_slice = ps_dec -> ps_cur_slice -> u2_first_mb_in_slice ; ps_dec -> ps_parse_cur_slice -> slice_type = ps_dec -> ps_cur_slice -> u1_slice_type ; ps_dec -> u4_start_recon_deblk = 1 ; { WORD32 num_entries ; WORD32 size ; UWORD8 * pu1_buf ; num_entries = MIN ( MAX_FRAMES , ps_dec -> u4_num_ref_frames_at_init ) ; num_entries = 2 * ( ( 2 * num_entries ) + 1 ) ; size = num_entries * sizeof ( void * ) ; size += PAD_MAP_IDX_POC * sizeof ( void * ) ; pu1_buf = ( UWORD8 * ) ps_dec -> pv_map_ref_idx_to_poc_buf ; pu1_buf += size * ps_dec -> u2_cur_slice_num ; ps_dec -> ps_parse_cur_slice -> ppv_map_ref_idx_to_poc = ( void * ) pu1_buf ; } if ( ps_dec -> u1_separate_parse ) { ps_dec -> ps_parse_cur_slice -> pv_tu_coeff_data_start = ps_dec -> pv_parse_tu_coeff_data ; } else { ps_dec -> pv_proc_tu_coeff_data = ps_dec -> pv_parse_tu_coeff_data ; } if ( u1_slice_type == I_SLICE ) { ps_dec -> ps_cur_pic -> u4_pack_slc_typ |= I_SLC_BIT ; ret = ih264d_parse_islice ( ps_dec , u2_first_mb_in_slice ) ; if ( ps_dec -> i4_pic_type != B_SLICE && ps_dec -> i4_pic_type != P_SLICE ) ps_dec -> i4_pic_type = I_SLICE ; } else if ( u1_slice_type == P_SLICE ) { ps_dec -> ps_cur_pic -> u4_pack_slc_typ |= P_SLC_BIT ; ret = ih264d_parse_pslice ( ps_dec , u2_first_mb_in_slice ) ; ps_dec -> u1_pr_sl_type = u1_slice_type ; if ( ps_dec -> i4_pic_type != B_SLICE ) ps_dec -> i4_pic_type = P_SLICE ; } else if ( u1_slice_type == B_SLICE ) { ps_dec -> ps_cur_pic -> u4_pack_slc_typ |= B_SLC_BIT ; ret = ih264d_parse_bslice ( ps_dec , u2_first_mb_in_slice ) ; ps_dec -> u1_pr_sl_type = u1_slice_type ; ps_dec -> i4_pic_type = B_SLICE ; } else return ERROR_INV_SLC_TYPE_T ; if ( ps_dec -> u1_slice_header_done ) { ps_dec -> u4_first_slice_in_pic = 0 ; ps_dec -> u1_first_slice_in_stream = 0 ; } if ( ret != OK ) return ret ; ps_dec -> i2_prev_slice_mbx = ps_dec -> u2_mbx ; ps_dec -> i2_prev_slice_mby = ps_dec -> u2_mby ; if ( ps_dec -> u2_total_mbs_coded >= ( ps_seq -> u2_max_mb_addr + 1 ) ) { ps_dec -> u1_pic_decode_done = 1 ; } { dec_err_status_t * ps_err = ps_dec -> ps_dec_err_status ; if ( ( ps_err -> u1_err_flag & REJECT_PB_PICS ) && ( ps_err -> u1_cur_pic_type == PIC_TYPE_I ) ) { ps_err -> u1_err_flag = ACCEPT_ALL_PICS ; } } PRINT_BIN_BIT_RATIO ( ps_dec ) return ret ; }",MASK_ERR_PIC_SET_ID ) return ERROR_INV_SLICE_HDR_T <S2SV_ModEnd> ; COPYTHECONTEXT ( <S2SV_ModStart> ) { return ERROR_INV_SLICE_HDR_T <S2SV_ModEnd> ; } ps_seq <S2SV_ModStart> ps_seq ) return ERROR_INV_SLICE_HDR_T <S2SV_ModEnd> ; if ( <S2SV_ModStart> u1_is_valid ) return ERROR_INV_SLICE_HDR_T <S2SV_ModEnd> ; u2_frame_num = <S2SV_ModStart> 65535 ) return ERROR_INV_SLICE_HDR_T <S2SV_ModEnd> ; COPYTHECONTEXT ( <S2SV_ModStart> i4_max_pic_order_cntLsb ) return ERROR_INV_SLICE_HDR_T <S2SV_ModEnd> ; s_tmp_poc . <S2SV_ModStart> MAX_REDUNDANT_PIC_CNT ) return ERROR_INV_SLICE_HDR_T <S2SV_ModEnd> ; u1_redundant_pic_cnt =
381,"WORD32 ixheaacd_real_synth_filt ( ia_esbr_hbe_txposer_struct * ptr_hbe_txposer , WORD32 num_columns , FLOAT32 qmf_buf_real [ ] [ 64 ] , FLOAT32 qmf_buf_imag [ ] [ 64 ] ) { WORD32 i , j , k , l , idx ; FLOAT32 g [ 640 ] ; FLOAT32 w [ 640 ] ; FLOAT32 synth_out [ 128 ] ; FLOAT32 accu_r ; WORD32 synth_size = ptr_hbe_txposer -> synth_size ; FLOAT32 * ptr_cos_tab_trans_qmf = ( FLOAT32 * ) & ixheaacd_cos_table_trans_qmf [ 0 ] [ 0 ] + ptr_hbe_txposer -> k_start * 32 ; FLOAT32 * buffer = ptr_hbe_txposer -> synth_buf ; for ( idx = 0 ; idx < num_columns ; idx ++ ) { FLOAT32 loc_qmf_buf [ 64 ] ; FLOAT32 * synth_buf_r = loc_qmf_buf ; FLOAT32 * out_buf = ptr_hbe_txposer -> ptr_input_buf + ( idx + 1 ) * ptr_hbe_txposer -> synth_size ; FLOAT32 * synth_cos_tab = ptr_hbe_txposer -> synth_cos_tab ; const FLOAT32 * interp_window_coeff = ptr_hbe_txposer -> synth_wind_coeff ; if ( ptr_hbe_txposer -> k_start < 0 ) return - 1 ; for ( k = 0 ; k < synth_size ; k ++ ) { WORD32 ki = ptr_hbe_txposer -> k_start + k ; synth_buf_r [ k ] = ( FLOAT32 ) ( ptr_cos_tab_trans_qmf [ ( k << 1 ) + 0 ] * qmf_buf_real [ idx ] [ ki ] + ptr_cos_tab_trans_qmf [ ( k << 1 ) + 1 ] * qmf_buf_imag [ idx ] [ ki ] ) ; synth_buf_r [ k + ptr_hbe_txposer -> synth_size ] = 0 ; } for ( l = ( 20 * synth_size - 1 ) ; l >= 2 * synth_size ; l -- ) { buffer [ l ] = buffer [ l - 2 * synth_size ] ; } if ( synth_size == 20 ) { FLOAT32 * psynth_cos_tab = synth_cos_tab ; for ( l = 0 ; l < ( synth_size + 1 ) ; l ++ ) { accu_r = 0.0 ; for ( k = 0 ; k < synth_size ; k ++ ) { accu_r += synth_buf_r [ k ] * psynth_cos_tab [ k ] ; } buffer [ 0 + l ] = accu_r ; buffer [ synth_size - l ] = accu_r ; psynth_cos_tab = psynth_cos_tab + synth_size ; } for ( l = ( synth_size + 1 ) ; l < ( 2 * synth_size - synth_size / 2 ) ; l ++ ) { accu_r = 0.0 ; for ( k = 0 ; k < synth_size ; k ++ ) { accu_r += synth_buf_r [ k ] * psynth_cos_tab [ k ] ; } buffer [ 0 + l ] = accu_r ; buffer [ 3 * synth_size - l ] = - accu_r ; psynth_cos_tab = psynth_cos_tab + synth_size ; } accu_r = 0.0 ; for ( k = 0 ; k < synth_size ; k ++ ) { accu_r += synth_buf_r [ k ] * psynth_cos_tab [ k ] ; } buffer [ 3 * synth_size >> 1 ] = accu_r ; } else { FLOAT32 tmp ; FLOAT32 * ptr_u = synth_out ; WORD32 kmax = ( synth_size >> 1 ) ; FLOAT32 * syn_buf = & buffer [ kmax ] ; kmax += synth_size ; <S2SV_StartBug> if ( ixheaacd_real_synth_fft != NULL ) <S2SV_EndBug> <S2SV_StartBug> ( * ixheaacd_real_synth_fft ) ( synth_buf_r , synth_out , synth_size * 2 ) ; <S2SV_EndBug> else return - 1 ; for ( k = 0 ; k < kmax ; k ++ ) { tmp = ( ( * ptr_u ++ ) * ( * synth_cos_tab ++ ) ) ; tmp -= ( ( * ptr_u ++ ) * ( * synth_cos_tab ++ ) ) ; * syn_buf ++ = tmp ; } syn_buf = & buffer [ 0 ] ; kmax -= synth_size ; for ( k = 0 ; k < kmax ; k ++ ) { tmp = ( ( * ptr_u ++ ) * ( * synth_cos_tab ++ ) ) ; tmp -= ( ( * ptr_u ++ ) * ( * synth_cos_tab ++ ) ) ; * syn_buf ++ = tmp ; } } for ( i = 0 ; i < 5 ; i ++ ) { memcpy ( & g [ ( 2 * i + 0 ) * synth_size ] , & buffer [ ( 4 * i + 0 ) * synth_size ] , sizeof ( FLOAT32 ) * synth_size ) ; memcpy ( & g [ ( 2 * i + 1 ) * synth_size ] , & buffer [ ( 4 * i + 3 ) * synth_size ] , sizeof ( FLOAT32 ) * synth_size ) ; } for ( k = 0 ; k < 10 * synth_size ; k ++ ) { w [ k ] = g [ k ] * interp_window_coeff [ k ] ; } for ( i = 0 ; i < synth_size ; i ++ ) { accu_r = 0.0 ; for ( j = 0 ; j < 10 ; j ++ ) { accu_r = accu_r + w [ synth_size * j + i ] ; } out_buf [ i ] = ( FLOAT32 ) accu_r ; } } return 0 ; }","; if ( ptr_hbe_txposer -> <S2SV_ModStart> ) ( * ( ptr_hbe_txposer -> ixheaacd_real_synth_fft ) ) <S2SV_ModEnd> ( synth_buf_r ,"
382,"static u32 apic_get_tmcct ( struct kvm_lapic * apic ) { ktime_t remaining ; s64 ns ; u32 tmcct ; ASSERT ( apic != NULL ) ; <S2SV_StartBug> if ( kvm_apic_get_reg ( apic , APIC_TMICT ) == 0 ) <S2SV_EndBug> return 0 ; remaining = hrtimer_get_remaining ( & apic -> lapic_timer . timer ) ; if ( ktime_to_ns ( remaining ) < 0 ) remaining = ktime_set ( 0 , 0 ) ; ns = mod_64 ( ktime_to_ns ( remaining ) , apic -> lapic_timer . period ) ; tmcct = div64_u64 ( ns , ( APIC_BUS_CYCLE_NS * apic -> divide_count ) ) ; return tmcct ; }",", APIC_TMICT ) == 0 || apic -> lapic_timer . period"
383,"int saa7164_bus_get ( struct saa7164_dev * dev , struct tmComResInfo * msg , void * buf , int peekonly ) { struct tmComResBusInfo * bus = & dev -> bus ; u32 bytes_to_read , write_distance , curr_grp , curr_gwp , new_grp , buf_size , space_rem ; struct tmComResInfo msg_tmp ; int ret = SAA_ERR_BAD_PARAMETER ; saa7164_bus_verify ( dev ) ; if ( msg == NULL ) return ret ; if ( msg -> size > dev -> bus . m_wMaxReqSize ) { printk ( KERN_ERR ""%s()<S2SV_blank>Exceeded<S2SV_blank>dev->bus.m_wMaxReqSize\\n"" , __func__ ) ; return ret ; } if ( ( peekonly == 0 ) && ( msg -> size > 0 ) && ( buf == NULL ) ) { printk ( KERN_ERR ""%s()<S2SV_blank>Missing<S2SV_blank>msg<S2SV_blank>buf,<S2SV_blank>size<S2SV_blank>should<S2SV_blank>be<S2SV_blank>%d<S2SV_blank>bytes\\n"" , __func__ , msg -> size ) ; return ret ; } mutex_lock ( & bus -> lock ) ; curr_gwp = saa7164_readl ( bus -> m_dwGetWritePos ) ; curr_grp = saa7164_readl ( bus -> m_dwGetReadPos ) ; if ( curr_gwp == curr_grp ) { ret = SAA_ERR_EMPTY ; goto out ; } bytes_to_read = sizeof ( * msg ) ; write_distance = 0 ; if ( curr_gwp >= curr_grp ) write_distance = curr_gwp - curr_grp ; else write_distance = curr_gwp + bus -> m_dwSizeGetRing - curr_grp ; if ( bytes_to_read > write_distance ) { printk ( KERN_ERR ""%s()<S2SV_blank>No<S2SV_blank>message/response<S2SV_blank>found\\n"" , __func__ ) ; ret = SAA_ERR_INVALID_COMMAND ; goto out ; } new_grp = curr_grp + bytes_to_read ; if ( new_grp > bus -> m_dwSizeGetRing ) { new_grp -= bus -> m_dwSizeGetRing ; space_rem = bus -> m_dwSizeGetRing - curr_grp ; memcpy_fromio ( & msg_tmp , bus -> m_pdwGetRing + curr_grp , space_rem ) ; memcpy_fromio ( ( u8 * ) & msg_tmp + space_rem , bus -> m_pdwGetRing , bytes_to_read - space_rem ) ; } else { memcpy_fromio ( & msg_tmp , bus -> m_pdwGetRing + curr_grp , bytes_to_read ) ; } msg_tmp . size = le16_to_cpu ( ( __force __le16 ) msg_tmp . size ) ; msg_tmp . command = le32_to_cpu ( ( __force __le32 ) msg_tmp . command ) ; msg_tmp . controlselector = le16_to_cpu ( ( __force __le16 ) msg_tmp . controlselector ) ; <S2SV_StartBug> if ( peekonly ) { <S2SV_EndBug> <S2SV_StartBug> memcpy ( msg , & msg_tmp , sizeof ( * msg ) ) ; <S2SV_EndBug> goto peekout ; } if ( ( msg_tmp . id != msg -> id ) || ( msg_tmp . command != msg -> command ) || ( msg_tmp . controlselector != msg -> controlselector ) || ( msg_tmp . seqno != msg -> seqno ) || ( msg_tmp . size != msg -> size ) ) { printk ( KERN_ERR ""%s()<S2SV_blank>Unexpected<S2SV_blank>msg<S2SV_blank>miss-match\\n"" , __func__ ) ; saa7164_bus_dumpmsg ( dev , msg , buf ) ; saa7164_bus_dumpmsg ( dev , & msg_tmp , NULL ) ; ret = SAA_ERR_INVALID_COMMAND ; goto out ; } buf_size = msg -> size ; bytes_to_read = sizeof ( * msg ) + msg -> size ; write_distance = 0 ; if ( curr_gwp >= curr_grp ) write_distance = curr_gwp - curr_grp ; else write_distance = curr_gwp + bus -> m_dwSizeGetRing - curr_grp ; if ( bytes_to_read > write_distance ) { printk ( KERN_ERR ""%s()<S2SV_blank>Invalid<S2SV_blank>bus<S2SV_blank>state,<S2SV_blank>missing<S2SV_blank>msg<S2SV_blank>or<S2SV_blank>mangled<S2SV_blank>ring,<S2SV_blank>faulty<S2SV_blank>H/W<S2SV_blank>/<S2SV_blank>bad<S2SV_blank>code?\\n"" , __func__ ) ; ret = SAA_ERR_INVALID_COMMAND ; goto out ; } new_grp = curr_grp + bytes_to_read ; if ( new_grp > bus -> m_dwSizeGetRing ) { new_grp -= bus -> m_dwSizeGetRing ; space_rem = bus -> m_dwSizeGetRing - curr_grp ; if ( space_rem < sizeof ( * msg ) ) { <S2SV_StartBug> memcpy_fromio ( msg , bus -> m_pdwGetRing + curr_grp , space_rem ) ; <S2SV_EndBug> memcpy_fromio ( ( u8 * ) msg + space_rem , bus -> m_pdwGetRing , <S2SV_StartBug> sizeof ( * msg ) - space_rem ) ; <S2SV_EndBug> if ( buf ) <S2SV_StartBug> memcpy_fromio ( buf , bus -> m_pdwGetRing + sizeof ( * msg ) - <S2SV_EndBug> space_rem , buf_size ) ; <S2SV_StartBug> } else if ( space_rem == sizeof ( * msg ) ) { <S2SV_EndBug> memcpy_fromio ( msg , bus -> m_pdwGetRing + curr_grp , sizeof ( * msg ) ) ; if ( buf ) memcpy_fromio ( buf , bus -> m_pdwGetRing , buf_size ) ; } else { memcpy_fromio ( msg , bus -> m_pdwGetRing + curr_grp , sizeof ( * msg ) ) ; if ( buf ) { memcpy_fromio ( buf , bus -> m_pdwGetRing + curr_grp + sizeof ( * msg ) , space_rem - sizeof ( * msg ) ) ; memcpy_fromio ( buf + space_rem - sizeof ( * msg ) , bus -> m_pdwGetRing , bytes_to_read - space_rem ) ; } } } else { memcpy_fromio ( msg , bus -> m_pdwGetRing + curr_grp , sizeof ( * msg ) ) ; if ( buf ) memcpy_fromio ( buf , bus -> m_pdwGetRing + curr_grp + sizeof ( * msg ) , buf_size ) ; } msg -> size = le16_to_cpu ( ( __force __le16 ) msg -> size ) ; msg -> command = le32_to_cpu ( ( __force __le32 ) msg -> command ) ; msg -> controlselector = le16_to_cpu ( ( __force __le16 ) msg -> controlselector ) ; saa7164_writel ( bus -> m_dwGetReadPos , new_grp ) ; peekout : ret = SAA_OK ; out : mutex_unlock ( & bus -> lock ) ; saa7164_bus_verify ( dev ) ; return ret ; }","controlselector ) ; memcpy ( msg , & msg_tmp , sizeof ( * msg ) ) ; <S2SV_ModStart> peekonly ) { <S2SV_ModEnd> goto peekout ; <S2SV_ModStart> ) ) { if ( buf ) memcpy_fromio ( buf <S2SV_ModEnd> , bus -> <S2SV_ModStart> -> m_pdwGetRing + sizeof ( * msg ) - space_rem , buf_size ) ; } else if ( space_rem == sizeof ( * msg ) ) { if ( buf ) memcpy_fromio ( buf <S2SV_ModEnd> , bus -> <S2SV_ModStart> -> m_pdwGetRing , buf_size ) ; } else { if ( buf ) { <S2SV_ModEnd> memcpy_fromio ( buf <S2SV_ModStart> -> m_pdwGetRing + curr_grp + sizeof ( * msg ) , space_rem - sizeof ( * msg ) ) ; memcpy_fromio ( buf + space_rem - sizeof ( * msg ) , bus -> m_pdwGetRing , bytes_to_read - space_rem ) ; } } } else { if ( buf ) memcpy_fromio ( buf , bus -> m_pdwGetRing + curr_grp + sizeof ( * msg ) , <S2SV_ModEnd> buf_size ) ; <S2SV_ModStart> ) ; } <S2SV_ModEnd> saa7164_writel ( bus"
384,"static void jas_stream_initbuf ( jas_stream_t * stream , int bufmode , char * buf , int bufsize ) { assert ( ! stream -> bufbase_ ) ; if ( bufmode != JAS_STREAM_UNBUF ) { if ( ! buf ) { if ( ( stream -> bufbase_ = jas_malloc ( JAS_STREAM_BUFSIZE + JAS_STREAM_MAXPUTBACK ) ) ) { stream -> bufmode_ |= JAS_STREAM_FREEBUF ; stream -> bufsize_ = JAS_STREAM_BUFSIZE ; } else { stream -> bufbase_ = stream -> tinybuf_ ; stream -> bufsize_ = 1 ; } } else { assert ( bufsize > JAS_STREAM_MAXPUTBACK ) ; <S2SV_StartBug> stream -> bufbase_ = JAS_CAST ( uchar * , buf ) ; <S2SV_EndBug> stream -> bufsize_ = bufsize - JAS_STREAM_MAXPUTBACK ; } } else { assert ( ! buf ) ; stream -> bufbase_ = stream -> tinybuf_ ; stream -> bufsize_ = 1 ; } stream -> bufstart_ = & stream -> bufbase_ [ JAS_STREAM_MAXPUTBACK ] ; stream -> ptr_ = stream -> bufstart_ ; stream -> cnt_ = 0 ; stream -> bufmode_ |= bufmode & JAS_STREAM_BUFMODEMASK ; }","= JAS_CAST ( jas_uchar <S2SV_ModEnd> * , buf"
385,"struct pipe_inode_info * alloc_pipe_info ( void ) { struct pipe_inode_info * pipe ; pipe = kzalloc ( sizeof ( struct pipe_inode_info ) , GFP_KERNEL ) ; if ( pipe ) { <S2SV_StartBug> pipe -> bufs = kzalloc ( sizeof ( struct pipe_buffer ) * PIPE_DEF_BUFFERS , GFP_KERNEL ) ; <S2SV_EndBug> if ( pipe -> bufs ) { init_waitqueue_head ( & pipe -> wait ) ; pipe -> r_counter = pipe -> w_counter = 1 ; <S2SV_StartBug> pipe -> buffers = PIPE_DEF_BUFFERS ; <S2SV_EndBug> mutex_init ( & pipe -> mutex ) ; return pipe ; } <S2SV_StartBug> kfree ( pipe ) ; <S2SV_EndBug> } return NULL ; }","pipe ) { unsigned long pipe_bufs = PIPE_DEF_BUFFERS ; struct user_struct * user = get_current_user ( ) ; if ( ! too_many_pipe_buffers_hard ( user ) ) { if ( too_many_pipe_buffers_soft ( user ) ) pipe_bufs = 1 ; <S2SV_ModStart> pipe_buffer ) * pipe_bufs <S2SV_ModEnd> , GFP_KERNEL ) <S2SV_ModStart> GFP_KERNEL ) ; } <S2SV_ModStart> -> buffers = pipe_bufs ; pipe -> user = user ; account_pipe_buffers ( pipe , 0 , pipe_bufs ) <S2SV_ModEnd> ; mutex_init ( <S2SV_ModStart> pipe ; } free_uid ( user ) ;"
386,"static int do_devinfo_ioctl ( struct comedi_device * dev , struct comedi_devinfo __user * arg , struct file * file ) { struct comedi_devinfo devinfo ; const unsigned minor = iminor ( file -> f_dentry -> d_inode ) ; struct comedi_device_file_info * dev_file_info = comedi_get_device_file_info ( minor ) ; struct comedi_subdevice * read_subdev = comedi_get_read_subdevice ( dev_file_info ) ; struct comedi_subdevice * write_subdev = comedi_get_write_subdevice ( dev_file_info ) ; memset ( & devinfo , 0 , sizeof ( devinfo ) ) ; devinfo . version_code = COMEDI_VERSION_CODE ; devinfo . n_subdevs = dev -> n_subdevices ; <S2SV_StartBug> memcpy ( devinfo . driver_name , dev -> driver -> driver_name , COMEDI_NAMELEN ) ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( devinfo . board_name , dev -> board_name , COMEDI_NAMELEN ) ; <S2SV_EndBug> if ( read_subdev ) devinfo . read_subdevice = read_subdev - dev -> subdevices ; else devinfo . read_subdevice = - 1 ; if ( write_subdev ) devinfo . write_subdevice = write_subdev - dev -> subdevices ; else devinfo . write_subdevice = - 1 ; if ( copy_to_user ( arg , & devinfo , sizeof ( struct comedi_devinfo ) ) ) return - EFAULT ; return 0 ; }",-> n_subdevices ; strlcpy <S2SV_ModEnd> ( devinfo . <S2SV_ModStart> COMEDI_NAMELEN ) ; strlcpy <S2SV_ModEnd> ( devinfo .
387,"static int pcd_detect ( void ) { char id [ 18 ] ; int k , unit ; struct pcd_unit * cd ; printk ( ""%s:<S2SV_blank>%s<S2SV_blank>version<S2SV_blank>%s,<S2SV_blank>major<S2SV_blank>%d,<S2SV_blank>nice<S2SV_blank>%d\\n"" , name , name , PCD_VERSION , major , nice ) ; par_drv = pi_register_driver ( name ) ; if ( ! par_drv ) { pr_err ( ""failed<S2SV_blank>to<S2SV_blank>register<S2SV_blank>%s<S2SV_blank>driver\\n"" , name ) ; return - 1 ; } k = 0 ; if ( pcd_drive_count == 0 ) { cd = pcd ; if ( pi_init ( cd -> pi , 1 , - 1 , - 1 , - 1 , - 1 , - 1 , pcd_buffer , PI_PCD , verbose , cd -> name ) ) { if ( ! pcd_probe ( cd , - 1 , id ) && cd -> disk ) { cd -> present = 1 ; k ++ ; } else pi_release ( cd -> pi ) ; } } else { for ( unit = 0 , cd = pcd ; unit < PCD_UNITS ; unit ++ , cd ++ ) { int * conf = * drives [ unit ] ; if ( ! conf [ D_PRT ] ) continue ; if ( ! pi_init ( cd -> pi , 0 , conf [ D_PRT ] , conf [ D_MOD ] , conf [ D_UNI ] , conf [ D_PRO ] , conf [ D_DLY ] , pcd_buffer , PI_PCD , verbose , cd -> name ) ) continue ; if ( ! pcd_probe ( cd , conf [ D_SLV ] , id ) && cd -> disk ) { cd -> present = 1 ; k ++ ; } else pi_release ( cd -> pi ) ; } } if ( k ) return 0 ; printk ( ""%s:<S2SV_blank>No<S2SV_blank>CD-ROM<S2SV_blank>drive<S2SV_blank>found\\n"" , name ) ; for ( unit = 0 , cd = pcd ; unit < PCD_UNITS ; unit ++ , cd ++ ) { <S2SV_StartBug> blk_cleanup_queue ( cd -> disk -> queue ) ; <S2SV_EndBug> cd -> disk -> queue = NULL ; blk_mq_free_tag_set ( & cd -> tag_set ) ; put_disk ( cd -> disk ) ; } pi_unregister_driver ( par_drv ) ; return - 1 ; }",++ ) { if ( ! cd -> disk ) continue ;
388,"static void send_ssi_file ( struct mg_connection * conn , const char * path , struct mg_file * filep , int include_level ) { char buf [ MG_BUF_LEN ] ; int ch , offset , len , in_tag , in_ssi_tag ; if ( include_level > 10 ) { mg_cry_internal ( conn , ""SSI<S2SV_blank>#include<S2SV_blank>level<S2SV_blank>is<S2SV_blank>too<S2SV_blank>deep<S2SV_blank>(%s)"" , path ) ; return ; } in_tag = in_ssi_tag = len = offset = 0 ; while ( ( ch = mg_fgetc ( filep , offset ++ ) ) != EOF ) { if ( in_tag ) { if ( ch == '>' ) { buf [ len ++ ] = '>' ; if ( in_ssi_tag ) { buf [ len ] = 0 ; <S2SV_StartBug> if ( ! memcmp ( buf + 5 , ""include"" , 7 ) ) { <S2SV_EndBug> do_ssi_include ( conn , path , buf + 12 , include_level + 1 ) ; # if ! defined ( NO_POPEN ) <S2SV_StartBug> } else if ( ! memcmp ( buf + 5 , ""exec"" , 4 ) ) { <S2SV_EndBug> do_ssi_exec ( conn , buf + 9 ) ; # endif } else { mg_cry_internal ( conn , ""%s:<S2SV_blank>unknown<S2SV_blank>SSI<S2SV_blank>"" ""command:<S2SV_blank>\\""%s\\"""" , path , buf ) ; } len = 0 ; in_ssi_tag = in_tag = 0 ; } else { ( void ) mg_write ( conn , buf , ( size_t ) len ) ; len = 0 ; in_tag = 0 ; } } else { buf [ len ++ ] = ( char ) ( ch & 0xff ) ; if ( ( len == 5 ) && ! memcmp ( buf , ""<!--#"" , 5 ) ) { in_ssi_tag = 1 ; } if ( ( len + 2 ) > ( int ) sizeof ( buf ) ) { mg_cry_internal ( conn , ""%s:<S2SV_blank>tag<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large"" , path ) ; return ; } } } else { if ( ch == '<' ) { in_tag = 1 ; if ( len > 0 ) { ( void ) mg_write ( conn , buf , ( size_t ) len ) ; } len = 1 ; buf [ 0 ] = '<' ; } else { buf [ len ++ ] = ( char ) ( ch & 0xff ) ; if ( len == ( int ) sizeof ( buf ) ) { mg_write ( conn , buf , ( size_t ) len ) ; len = 0 ; } } } } if ( len > 0 ) { mg_write ( conn , buf , ( size_t ) len ) ; } }",; if ( ( len > 12 ) && <S2SV_ModStart> else if ( ( len > 9 ) &&
389,"int copy_creds ( struct task_struct * p , unsigned long clone_flags ) { # ifdef CONFIG_KEYS struct thread_group_cred * tgcred ; # endif struct cred * new ; int ret ; <S2SV_StartBug> if ( <S2SV_EndBug> # ifdef CONFIG_KEYS ! p -> cred -> thread_keyring && # endif clone_flags & CLONE_THREAD ) { p -> real_cred = get_cred ( p -> cred ) ; get_cred ( p -> cred ) ; alter_cred_subscribers ( p -> cred , 2 ) ; kdebug ( ""share_creds(%p{%d,%d})"" , p -> cred , atomic_read ( & p -> cred -> usage ) , read_cred_subscribers ( p -> cred ) ) ; atomic_inc ( & p -> cred -> user -> processes ) ; return 0 ; } new = prepare_creds ( ) ; if ( ! new ) return - ENOMEM ; if ( clone_flags & CLONE_NEWUSER ) { ret = create_user_ns ( new ) ; if ( ret < 0 ) goto error_put ; } new -> user_ns = new -> user -> user_ns ; # ifdef CONFIG_KEYS if ( new -> thread_keyring ) { key_put ( new -> thread_keyring ) ; new -> thread_keyring = NULL ; if ( clone_flags & CLONE_THREAD ) install_thread_keyring_to_cred ( new ) ; } if ( ! ( clone_flags & CLONE_THREAD ) ) { tgcred = kmalloc ( sizeof ( * tgcred ) , GFP_KERNEL ) ; if ( ! tgcred ) { ret = - ENOMEM ; goto error_put ; } atomic_set ( & tgcred -> usage , 1 ) ; spin_lock_init ( & tgcred -> lock ) ; tgcred -> process_keyring = NULL ; tgcred -> session_keyring = key_get ( new -> tgcred -> session_keyring ) ; release_tgcred ( new ) ; new -> tgcred = tgcred ; } # endif atomic_inc ( & new -> user -> processes ) ; p -> cred = p -> real_cred = get_cred ( new ) ; alter_cred_subscribers ( new , 2 ) ; validate_creds ( new ) ; return 0 ; error_put : put_cred ( new ) ; return ret ; }",int ret ; p -> replacement_session_keyring = NULL ;
390,"int dwg_encode_add_object ( Dwg_Object * restrict obj , Bit_Chain * restrict dat , unsigned long address ) { int error = 0 ; unsigned long oldpos ; unsigned long end_address = address + obj -> size ; oldpos = bit_position ( dat ) ; assert ( address ) ; dat -> byte = address ; dat -> bit = 0 ; LOG_INFO ( ""Object<S2SV_blank>number:<S2SV_blank>%lu"" , ( unsigned long ) obj -> index ) ; if ( obj -> size > 0x100000 ) { LOG_ERROR ( ""Object<S2SV_blank>size<S2SV_blank>%u<S2SV_blank>overflow"" , obj -> size ) ; return DWG_ERR_VALUEOUTOFBOUNDS ; } while ( dat -> byte + obj -> size >= dat -> size ) bit_chain_alloc ( dat ) ; bit_write_MS ( dat , obj -> size ) ; obj -> address = dat -> byte ; PRE ( R_2010 ) { bit_write_BS ( dat , obj -> type ) ; LOG_INFO ( "",<S2SV_blank>Size:<S2SV_blank>%d<S2SV_blank>[MS],<S2SV_blank>Type:<S2SV_blank>%d<S2SV_blank>[BS]\\n"" , obj -> size , obj -> type ) } LATER_VERSIONS { if ( ! obj -> handlestream_size && obj -> bitsize ) obj -> handlestream_size = obj -> size * 8 - obj -> bitsize ; bit_write_UMC ( dat , obj -> handlestream_size ) ; obj -> address = dat -> byte ; bit_write_BOT ( dat , obj -> type ) ; LOG_INFO ( "",<S2SV_blank>Size:<S2SV_blank>%d<S2SV_blank>[MS],<S2SV_blank>Hdlsize:<S2SV_blank>%lu<S2SV_blank>[UMC],<S2SV_blank>Type:<S2SV_blank>%d<S2SV_blank>[BOT]\\n"" , obj -> size , ( unsigned long ) obj -> handlestream_size , obj -> type ) } switch ( obj -> type ) { case DWG_TYPE_TEXT : error = dwg_encode_TEXT ( dat , obj ) ; break ; case DWG_TYPE_ATTRIB : error = dwg_encode_ATTRIB ( dat , obj ) ; break ; case DWG_TYPE_ATTDEF : error = dwg_encode_ATTDEF ( dat , obj ) ; break ; case DWG_TYPE_BLOCK : error = dwg_encode_BLOCK ( dat , obj ) ; break ; case DWG_TYPE_ENDBLK : error = dwg_encode_ENDBLK ( dat , obj ) ; break ; case DWG_TYPE_SEQEND : error = dwg_encode_SEQEND ( dat , obj ) ; break ; case DWG_TYPE_INSERT : error = dwg_encode_INSERT ( dat , obj ) ; break ; case DWG_TYPE_MINSERT : error = dwg_encode_MINSERT ( dat , obj ) ; break ; case DWG_TYPE_VERTEX_2D : error = dwg_encode_VERTEX_2D ( dat , obj ) ; break ; case DWG_TYPE_VERTEX_3D : error = dwg_encode_VERTEX_3D ( dat , obj ) ; break ; case DWG_TYPE_VERTEX_MESH : error = dwg_encode_VERTEX_MESH ( dat , obj ) ; break ; case DWG_TYPE_VERTEX_PFACE : error = dwg_encode_VERTEX_PFACE ( dat , obj ) ; break ; case DWG_TYPE_VERTEX_PFACE_FACE : error = dwg_encode_VERTEX_PFACE_FACE ( dat , obj ) ; break ; case DWG_TYPE_POLYLINE_2D : error = dwg_encode_POLYLINE_2D ( dat , obj ) ; break ; case DWG_TYPE_POLYLINE_3D : error = dwg_encode_POLYLINE_3D ( dat , obj ) ; break ; case DWG_TYPE_ARC : error = dwg_encode_ARC ( dat , obj ) ; break ; case DWG_TYPE_CIRCLE : error = dwg_encode_CIRCLE ( dat , obj ) ; break ; case DWG_TYPE_LINE : error = dwg_encode_LINE ( dat , obj ) ; break ; case DWG_TYPE_DIMENSION_ORDINATE : error = dwg_encode_DIMENSION_ORDINATE ( dat , obj ) ; break ; case DWG_TYPE_DIMENSION_LINEAR : error = dwg_encode_DIMENSION_LINEAR ( dat , obj ) ; break ; case DWG_TYPE_DIMENSION_ALIGNED : error = dwg_encode_DIMENSION_ALIGNED ( dat , obj ) ; break ; case DWG_TYPE_DIMENSION_ANG3PT : error = dwg_encode_DIMENSION_ANG3PT ( dat , obj ) ; break ; case DWG_TYPE_DIMENSION_ANG2LN : error = dwg_encode_DIMENSION_ANG2LN ( dat , obj ) ; break ; case DWG_TYPE_DIMENSION_RADIUS : error = dwg_encode_DIMENSION_RADIUS ( dat , obj ) ; break ; case DWG_TYPE_DIMENSION_DIAMETER : error = dwg_encode_DIMENSION_DIAMETER ( dat , obj ) ; break ; case DWG_TYPE_POINT : error = dwg_encode_POINT ( dat , obj ) ; break ; case DWG_TYPE__3DFACE : error = dwg_encode__3DFACE ( dat , obj ) ; break ; case DWG_TYPE_POLYLINE_PFACE : error = dwg_encode_POLYLINE_PFACE ( dat , obj ) ; break ; case DWG_TYPE_POLYLINE_MESH : error = dwg_encode_POLYLINE_MESH ( dat , obj ) ; break ; case DWG_TYPE_SOLID : error = dwg_encode_SOLID ( dat , obj ) ; break ; case DWG_TYPE_TRACE : error = dwg_encode_TRACE ( dat , obj ) ; break ; case DWG_TYPE_SHAPE : error = dwg_encode_SHAPE ( dat , obj ) ; break ; case DWG_TYPE_VIEWPORT : error = dwg_encode_VIEWPORT ( dat , obj ) ; break ; case DWG_TYPE_ELLIPSE : error = dwg_encode_ELLIPSE ( dat , obj ) ; break ; case DWG_TYPE_SPLINE : error = dwg_encode_SPLINE ( dat , obj ) ; break ; case DWG_TYPE_REGION : error = dwg_encode_REGION ( dat , obj ) ; break ; case DWG_TYPE__3DSOLID : error = dwg_encode__3DSOLID ( dat , obj ) ; break ; case DWG_TYPE_BODY : error = dwg_encode_BODY ( dat , obj ) ; break ; case DWG_TYPE_RAY : error = dwg_encode_RAY ( dat , obj ) ; break ; case DWG_TYPE_XLINE : error = dwg_encode_XLINE ( dat , obj ) ; break ; case DWG_TYPE_DICTIONARY : error = dwg_encode_DICTIONARY ( dat , obj ) ; break ; case DWG_TYPE_MTEXT : error = dwg_encode_MTEXT ( dat , obj ) ; break ; case DWG_TYPE_LEADER : error = dwg_encode_LEADER ( dat , obj ) ; break ; case DWG_TYPE_TOLERANCE : error = dwg_encode_TOLERANCE ( dat , obj ) ; break ; case DWG_TYPE_MLINE : error = dwg_encode_MLINE ( dat , obj ) ; break ; case DWG_TYPE_BLOCK_CONTROL : error = dwg_encode_BLOCK_CONTROL ( dat , obj ) ; break ; case DWG_TYPE_BLOCK_HEADER : error = dwg_encode_BLOCK_HEADER ( dat , obj ) ; break ; case DWG_TYPE_LAYER_CONTROL : error = dwg_encode_LAYER_CONTROL ( dat , obj ) ; break ; case DWG_TYPE_LAYER : error = dwg_encode_LAYER ( dat , obj ) ; break ; case DWG_TYPE_STYLE_CONTROL : error = dwg_encode_STYLE_CONTROL ( dat , obj ) ; break ; case DWG_TYPE_STYLE : error = dwg_encode_STYLE ( dat , obj ) ; break ; case DWG_TYPE_LTYPE_CONTROL : error = dwg_encode_LTYPE_CONTROL ( dat , obj ) ; break ; case DWG_TYPE_LTYPE : error = dwg_encode_LTYPE ( dat , obj ) ; break ; case DWG_TYPE_VIEW_CONTROL : error = dwg_encode_VIEW_CONTROL ( dat , obj ) ; break ; case DWG_TYPE_VIEW : error = dwg_encode_VIEW ( dat , obj ) ; break ; case DWG_TYPE_UCS_CONTROL : error = dwg_encode_UCS_CONTROL ( dat , obj ) ; break ; case DWG_TYPE_UCS : error = dwg_encode_UCS ( dat , obj ) ; break ; case DWG_TYPE_VPORT_CONTROL : error = dwg_encode_VPORT_CONTROL ( dat , obj ) ; break ; case DWG_TYPE_VPORT : error = dwg_encode_VPORT ( dat , obj ) ; break ; case DWG_TYPE_APPID_CONTROL : error = dwg_encode_APPID_CONTROL ( dat , obj ) ; break ; case DWG_TYPE_APPID : error = dwg_encode_APPID ( dat , obj ) ; break ; case DWG_TYPE_DIMSTYLE_CONTROL : error = dwg_encode_DIMSTYLE_CONTROL ( dat , obj ) ; break ; case DWG_TYPE_DIMSTYLE : error = dwg_encode_DIMSTYLE ( dat , obj ) ; break ; case DWG_TYPE_VPORT_ENTITY_CONTROL : error = dwg_encode_VPORT_ENTITY_CONTROL ( dat , obj ) ; break ; case DWG_TYPE_VPORT_ENTITY_HEADER : error = dwg_encode_VPORT_ENTITY_HEADER ( dat , obj ) ; break ; case DWG_TYPE_GROUP : error = dwg_encode_GROUP ( dat , obj ) ; break ; case DWG_TYPE_MLINESTYLE : error = dwg_encode_MLINESTYLE ( dat , obj ) ; ( void ) dwg_encode_get_class ( obj -> parent , obj ) ; break ; case DWG_TYPE_OLE2FRAME : error = dwg_encode_OLE2FRAME ( dat , obj ) ; ( void ) dwg_encode_get_class ( obj -> parent , obj ) ; break ; case DWG_TYPE_DUMMY : error = dwg_encode_DUMMY ( dat , obj ) ; break ; case DWG_TYPE_LONG_TRANSACTION : error = dwg_encode_LONG_TRANSACTION ( dat , obj ) ; break ; case DWG_TYPE_LWPOLYLINE : error = dwg_encode_LWPOLYLINE ( dat , obj ) ; ( void ) dwg_encode_get_class ( obj -> parent , obj ) ; break ; case DWG_TYPE_HATCH : error = dwg_encode_HATCH ( dat , obj ) ; ( void ) dwg_encode_get_class ( obj -> parent , obj ) ; break ; case DWG_TYPE_XRECORD : error = dwg_encode_XRECORD ( dat , obj ) ; ( void ) dwg_encode_get_class ( obj -> parent , obj ) ; break ; case DWG_TYPE_PLACEHOLDER : error = dwg_encode_PLACEHOLDER ( dat , obj ) ; ( void ) dwg_encode_get_class ( obj -> parent , obj ) ; break ; case DWG_TYPE_OLEFRAME : error = dwg_encode_OLEFRAME ( dat , obj ) ; ( void ) dwg_encode_get_class ( obj -> parent , obj ) ; break ; case DWG_TYPE_VBA_PROJECT : LOG_ERROR ( ""Unhandled<S2SV_blank>Object<S2SV_blank>VBA_PROJECT.<S2SV_blank>Has<S2SV_blank>its<S2SV_blank>own<S2SV_blank>section"" ) ; break ; case DWG_TYPE_LAYOUT : error |= dwg_encode_LAYOUT ( dat , obj ) ; ( void ) dwg_encode_get_class ( obj -> parent , obj ) ; break ; case DWG_TYPE_PROXY_ENTITY : error = dwg_encode_PROXY_ENTITY ( dat , obj ) ; break ; case DWG_TYPE_PROXY_OBJECT : error = dwg_encode_PROXY_OBJECT ( dat , obj ) ; break ; default : if ( obj -> type == obj -> parent -> layout_type && obj -> fixedtype == DWG_TYPE_LAYOUT ) { error = dwg_encode_LAYOUT ( dat , obj ) ; ( void ) dwg_encode_get_class ( obj -> parent , obj ) ; } else if ( ( error = dwg_encode_variable_type ( obj -> parent , dat , obj ) ) & DWG_ERR_UNHANDLEDCLASS ) { Dwg_Data * dwg = obj -> parent ; int is_entity ; int i = obj -> type - 500 ; Dwg_Class * klass = dwg_encode_get_class ( dwg , obj ) ; assert ( address ) ; dat -> byte = address ; dat -> bit = 0 ; bit_write_MS ( dat , obj -> size ) ; if ( dat -> version >= R_2010 ) { bit_write_UMC ( dat , obj -> handlestream_size ) ; bit_write_BOT ( dat , obj -> type ) ; } else bit_write_BS ( dat , obj -> type ) ; if ( klass && obj -> supertype == DWG_SUPERTYPE_UNKNOWN ) is_entity = dwg_class_is_entity ( klass ) ; else is_entity = obj -> supertype == DWG_SUPERTYPE_ENTITY ; <S2SV_StartBug> if ( klass && ! is_entity ) <S2SV_EndBug> <S2SV_StartBug> error = dwg_encode_UNKNOWN_OBJ ( dat , obj ) ; <S2SV_EndBug> <S2SV_StartBug> else if ( klass ) <S2SV_EndBug> error = dwg_encode_UNKNOWN_ENT ( dat , obj ) ; else { LOG_WARN ( ""Unknown<S2SV_blank>object,<S2SV_blank>skipping<S2SV_blank>eed/reactors/xdic"" ) ; error = DWG_ERR_UNHANDLEDCLASS ; SINCE ( R_2000 ) { bit_write_RL ( dat , obj -> bitsize ) ; LOG_INFO ( ""bitsize:<S2SV_blank>"" FORMAT_RL ""<S2SV_blank>[RL]<S2SV_blank>(@%lu.%u)\\n"" , obj -> bitsize , dat -> byte - 4 , dat -> bit ) ; } bit_write_H ( dat , & obj -> handle ) ; LOG_INFO ( ""handle:<S2SV_blank>"" FORMAT_H ""<S2SV_blank>[H<S2SV_blank>5]\\n"" , ARGS_H ( obj -> handle ) ) ; bit_write_TF ( dat , obj -> tio . unknown , obj -> size ) ; } } } if ( ! obj -> size ) { BITCODE_BL pos = bit_position ( dat ) ; assert ( address ) ; obj -> size = dat -> byte - address - 2 ; if ( dat -> bit ) obj -> size ++ ; if ( ! obj -> bitsize ) { LOG_TRACE ( ""-bitsize<S2SV_blank>calc<S2SV_blank>from<S2SV_blank>address<S2SV_blank>(no<S2SV_blank>handle)<S2SV_blank>@%lu.%u\\n"" , dat -> byte , dat -> bit ) ; obj -> bitsize = pos - ( obj -> address * 8 ) ; } bit_set_position ( dat , address * 8 ) ; if ( obj -> size > 0x7fff ) LOG_ERROR ( ""Unhandled<S2SV_blank>size<S2SV_blank>%u<S2SV_blank>><S2SV_blank>0x7fff"" , ( unsigned ) obj -> size ) ; bit_write_MS ( dat , obj -> size ) ; LOG_TRACE ( ""-size:<S2SV_blank>%u<S2SV_blank>[MS]<S2SV_blank>@%lu\\n"" , obj -> size , address ) ; SINCE ( R_2013 ) { if ( ! obj -> handlestream_size && obj -> bitsize ) obj -> handlestream_size = obj -> size * 8 - obj -> bitsize ; bit_write_UMC ( dat , obj -> handlestream_size ) ; LOG_TRACE ( ""-handlestream_size:<S2SV_blank>%lu<S2SV_blank>[UMC]\\n"" , obj -> handlestream_size ) ; } SINCE ( R_2000 ) { if ( obj -> bitsize_pos && obj -> bitsize ) { bit_set_position ( dat , obj -> bitsize_pos ) ; bit_write_RL ( dat , obj -> bitsize ) ; LOG_TRACE ( ""-bitsize:<S2SV_blank>%u<S2SV_blank>[RL]<S2SV_blank>@%lu.%lu\\n"" , obj -> bitsize , obj -> bitsize_pos / 8 , obj -> bitsize_pos % 8 ) ; } } bit_set_position ( dat , pos ) ; } if ( dat -> bit ) LOG_TRACE ( ""padding:<S2SV_blank>+%d<S2SV_blank>[*B]\\n"" , 8 - dat -> bit ) while ( dat -> bit ) bit_write_B ( dat , 1 ) ; end_address = obj -> address + obj -> size ; if ( end_address != dat -> byte ) { if ( obj -> size ) LOG_WARN ( ""Wrong<S2SV_blank>object<S2SV_blank>size:<S2SV_blank>%lu<S2SV_blank>+<S2SV_blank>%u<S2SV_blank>=<S2SV_blank>%lu<S2SV_blank>!=<S2SV_blank>%lu:<S2SV_blank>%ld<S2SV_blank>off"" , obj -> address , obj -> size , end_address , dat -> byte , ( long ) ( end_address - dat -> byte ) ) ; dat -> byte = end_address ; } assert ( ! dat -> bit ) ; bit_write_CRC ( dat , address , 0xC0C1 ) ; return error ; }","; if ( <S2SV_ModEnd> is_entity ) error <S2SV_ModStart> ) error = dwg_encode_UNKNOWN_ENT ( dat , obj ) ; else error = <S2SV_ModStart> obj ) ; <S2SV_ModEnd> } } if"
391,"static void * load_bytes ( RBinFile * arch , const ut8 * buf , ut64 sz , ut64 loaddr , Sdb * sdb ) { if ( ! buf || ! sz || sz == UT64_MAX ) { return NULL ; } RBuffer * tbuf = r_buf_new ( ) ; <S2SV_StartBug> r_buf_set_bytes ( tbuf , buf , sz ) ; <S2SV_EndBug> struct r_bin_bflt_obj * res = r_bin_bflt_new_buf ( tbuf ) ; r_buf_free ( tbuf ) ; return res ? res : NULL ; }",( ) ; if ( ! tbuf ) { return NULL ; }
392,"static guint32 parse_wbxml_attribute_list ( proto_tree * tree , tvbuff_t * tvb , guint32 offset , guint32 str_tbl , guint8 level , guint8 * codepage_attr ) { guint32 tvb_len = tvb_reported_length ( tvb ) ; <S2SV_StartBug> guint32 off = offset ; <S2SV_EndBug> guint32 len ; guint str_len ; guint32 ent ; guint32 idx ; guint8 peek ; <S2SV_StartBug> DebugLog ( ( ""parse_wbxml_attr<S2SV_blank>(level<S2SV_blank>=<S2SV_blank>%u,<S2SV_blank>offset<S2SV_blank>=<S2SV_blank>%u)\\n"" , level , offset ) ) ; <S2SV_EndBug> while ( off < tvb_len ) { peek = tvb_get_guint8 ( tvb , off ) ; DebugLog ( ( ""ATTR:<S2SV_blank>(top<S2SV_blank>of<S2SV_blank>while)<S2SV_blank>level<S2SV_blank>=<S2SV_blank>%3u,<S2SV_blank>peek<S2SV_blank>=<S2SV_blank>0x%02X,<S2SV_blank>"" ""off<S2SV_blank>=<S2SV_blank>%u,<S2SV_blank>tvb_len<S2SV_blank>=<S2SV_blank>%u\\n"" , level , peek , off , tvb_len ) ) ; if ( ( peek & 0x3F ) < 5 ) switch ( peek ) { case 0x00 : * codepage_attr = tvb_get_guint8 ( tvb , off + 1 ) ; proto_tree_add_text ( tree , tvb , off , 2 , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>|<S2SV_blank><S2SV_blank>Attr<S2SV_blank>|<S2SV_blank>A<S2SV_blank>-->%3d<S2SV_blank>"" ""|<S2SV_blank>SWITCH_PAGE<S2SV_blank>(Attr<S2SV_blank>code<S2SV_blank>page)<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>|"" , * codepage_attr ) ; off += 2 ; break ; case 0x01 : off ++ ; DebugLog ( ( ""ATTR:<S2SV_blank>level<S2SV_blank>=<S2SV_blank>%u,<S2SV_blank>Return:<S2SV_blank>len<S2SV_blank>=<S2SV_blank>%u\\n"" , level , off - offset ) ) ; return ( off - offset ) ; case 0x02 : ent = tvb_get_guintvar ( tvb , off + 1 , & len ) ; proto_tree_add_text ( tree , tvb , off , 1 + len , ""<S2SV_blank><S2SV_blank>%3d<S2SV_blank>|<S2SV_blank><S2SV_blank>Attr<S2SV_blank>|<S2SV_blank>A<S2SV_blank>%3d<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank>ENTITY<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s\'&#%u;\'"" , level , * codepage_attr , Indent ( level ) , ent ) ; off += 1 + len ; break ; case 0x03 : len = tvb_strsize ( tvb , off + 1 ) ; proto_tree_add_text ( tree , tvb , off , 1 + len , ""<S2SV_blank><S2SV_blank>%3d<S2SV_blank>|<S2SV_blank><S2SV_blank>Attr<S2SV_blank>|<S2SV_blank>A<S2SV_blank>%3d<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank>STR_I<S2SV_blank>(Inline<S2SV_blank>string)<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s\\\'%s\\\'"" , level , * codepage_attr , Indent ( level ) , tvb_format_text ( tvb , off + 1 , len - 1 ) ) ; off += 1 + len ; break ; case 0x04 : idx = tvb_get_guintvar ( tvb , off + 1 , & len ) ; str_len = tvb_strsize ( tvb , str_tbl + idx ) ; proto_tree_add_text ( tree , tvb , off , 1 + len , ""<S2SV_blank><S2SV_blank>%3d<S2SV_blank>|<S2SV_blank><S2SV_blank>Attr<S2SV_blank>|<S2SV_blank>A<S2SV_blank>%3d<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank>LITERAL<S2SV_blank>(Literal<S2SV_blank>Attribute)<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank><S2SV_blank><S2SV_blank>%s<%s<S2SV_blank>/>"" , level , * codepage_attr , Indent ( level ) , tvb_format_text ( tvb , str_tbl + idx , str_len - 1 ) ) ; off += 1 + len ; break ; case 0x40 : case 0x41 : case 0x42 : len = tvb_strsize ( tvb , off + 1 ) ; proto_tree_add_text ( tree , tvb , off , 1 + len , ""<S2SV_blank><S2SV_blank>%3d<S2SV_blank>|<S2SV_blank><S2SV_blank>Attr<S2SV_blank>|<S2SV_blank>A<S2SV_blank>%3d<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank>EXT_I_%1x<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(Extension<S2SV_blank>Token)<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s(Inline<S2SV_blank>string<S2SV_blank>extension:<S2SV_blank>\\\'%s\\\')"" , level , * codepage_attr , peek & 0x0f , Indent ( level ) , tvb_format_text ( tvb , off + 1 , len - 1 ) ) ; off += 1 + len ; break ; case 0x80 : case 0x81 : case 0x82 : idx = tvb_get_guintvar ( tvb , off + 1 , & len ) ; proto_tree_add_text ( tree , tvb , off , 1 + len , ""<S2SV_blank><S2SV_blank>%3d<S2SV_blank>|<S2SV_blank><S2SV_blank>Attr<S2SV_blank>|<S2SV_blank>A<S2SV_blank>%3d<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank>EXT_T_%1x<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(Extension<S2SV_blank>Token)<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s(Extension<S2SV_blank>Token,<S2SV_blank>integer<S2SV_blank>value:<S2SV_blank>%u)"" , level , * codepage_attr , peek & 0x0f , Indent ( level ) , idx ) ; off += 1 + len ; break ; case 0x83 : idx = tvb_get_guintvar ( tvb , off + 1 , & len ) ; str_len = tvb_strsize ( tvb , str_tbl + idx ) ; proto_tree_add_text ( tree , tvb , off , 1 + len , ""<S2SV_blank><S2SV_blank>%3d<S2SV_blank>|<S2SV_blank><S2SV_blank>Attr<S2SV_blank>|<S2SV_blank>A<S2SV_blank>%3d<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank>STR_T<S2SV_blank>(Tableref<S2SV_blank>string)<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s\\\'%s\\\'"" , level , * codepage_attr , Indent ( level ) , tvb_format_text ( tvb , str_tbl + idx , str_len - 1 ) ) ; off += 1 + len ; break ; case 0xC0 : case 0xC1 : case 0xC2 : proto_tree_add_text ( tree , tvb , off , 1 , ""<S2SV_blank><S2SV_blank>%3d<S2SV_blank>|<S2SV_blank><S2SV_blank>Attr<S2SV_blank>|<S2SV_blank>A<S2SV_blank>%3d<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank>EXT_%1x<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(Extension<S2SV_blank>Token)<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s(Single-byte<S2SV_blank>extension)"" , level , * codepage_attr , peek & 0x0f , Indent ( level ) ) ; off ++ ; break ; case 0xC3 : if ( tvb_get_guint8 ( tvb , 0 ) ) { idx = tvb_get_guintvar ( tvb , off + 1 , & len ) ; proto_tree_add_text ( tree , tvb , off , 1 + len + idx , ""<S2SV_blank><S2SV_blank>%3d<S2SV_blank>|<S2SV_blank><S2SV_blank>Attr<S2SV_blank>|<S2SV_blank>A<S2SV_blank>%3d<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank>OPAQUE<S2SV_blank>(Opaque<S2SV_blank>data)<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s(%d<S2SV_blank>bytes<S2SV_blank>of<S2SV_blank>opaque<S2SV_blank>data)"" , level , * codepage_attr , Indent ( level ) , idx ) ; off += 1 + len + idx ; } else { proto_tree_add_text ( tree , tvb , off , 1 , ""<S2SV_blank><S2SV_blank>%3d<S2SV_blank>|<S2SV_blank><S2SV_blank>Attr<S2SV_blank>|<S2SV_blank>A<S2SV_blank>%3d<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank>RESERVED_2<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(Invalid<S2SV_blank>Token!)<S2SV_blank>"" ""|<S2SV_blank>WBXML<S2SV_blank>1.0<S2SV_blank>parsing<S2SV_blank>stops<S2SV_blank>here."" , level , * codepage_attr ) ; off = tvb_len ; DebugLog ( ( ""ATTR:<S2SV_blank>level<S2SV_blank>=<S2SV_blank>%u,<S2SV_blank>Return:<S2SV_blank>len<S2SV_blank>=<S2SV_blank>%u\\n"" , level , off - offset ) ) ; return ( off - offset ) ; } break ; default : proto_tree_add_text ( tree , tvb , off , 1 , ""<S2SV_blank><S2SV_blank>%3d<S2SV_blank>|<S2SV_blank><S2SV_blank>Attr<S2SV_blank>|<S2SV_blank>A<S2SV_blank>%3d<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank>%-10s<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(Invalid<S2SV_blank>Token!)<S2SV_blank>"" ""|<S2SV_blank>WBXML<S2SV_blank>parsing<S2SV_blank>stops<S2SV_blank>here."" , level , * codepage_attr , val_to_str_ext ( peek , & vals_wbxml1x_global_tokens_ext , ""(unknown<S2SV_blank>0x%x)"" ) ) ; off = tvb_len ; break ; } else { if ( peek & 0x80 ) { proto_tree_add_text ( tree , tvb , off , 1 , ""<S2SV_blank><S2SV_blank>%3d<S2SV_blank>|<S2SV_blank><S2SV_blank>Attr<S2SV_blank>|<S2SV_blank>A<S2SV_blank>%3d<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank><S2SV_blank><S2SV_blank>Known<S2SV_blank>attrValue<S2SV_blank>0x%02X<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%sattrValue_0x%02X"" , level , * codepage_attr , peek & 0x7f , Indent ( level ) , peek ) ; off ++ ; } else { proto_tree_add_text ( tree , tvb , off , 1 , ""<S2SV_blank><S2SV_blank>%3d<S2SV_blank>|<S2SV_blank><S2SV_blank>Attr<S2SV_blank>|<S2SV_blank>A<S2SV_blank>%3d<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank><S2SV_blank><S2SV_blank>Known<S2SV_blank>attrStart<S2SV_blank>0x%02X<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ""|<S2SV_blank><S2SV_blank><S2SV_blank>%sattrStart_0x%02X"" , level , * codepage_attr , peek & 0x7f , Indent ( level ) , peek ) ; off ++ ; } } <S2SV_StartBug> } <S2SV_EndBug> DebugLog ( ( ""ATTR:<S2SV_blank>level<S2SV_blank>=<S2SV_blank>%u,<S2SV_blank>Return:<S2SV_blank>len<S2SV_blank>=<S2SV_blank>%u<S2SV_blank>(end<S2SV_blank>of<S2SV_blank>function<S2SV_blank>body)\\n"" , level , off - offset ) ) ; return ( off - offset ) ; }","off = offset , last_off <S2SV_ModStart> offset ) ) ; last_off = off <S2SV_ModStart> ; } } if ( off < last_off ) { THROW ( ReportedBoundsError ) ; } last_off = off ;"
393,"static const u_char * ikev2_n_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { const struct ikev2_n * p ; struct ikev2_n n ; const u_char * cp ; <S2SV_StartBug> u_char showspi , showdata , showsomedata ; <S2SV_EndBug> const char * notify_name ; uint32_t type ; p = ( const struct ikev2_n * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & n , ext , sizeof ( n ) ) ; ikev2_pay_print ( ndo , NPSTR ( ISAKMP_NPTYPE_N ) , n . h . critical ) ; showspi = 1 ; <S2SV_StartBug> showdata = 0 ; <S2SV_EndBug> showsomedata = 0 ; notify_name = NULL ; ND_PRINT ( ( ndo , ""<S2SV_blank>prot_id=%s"" , PROTOIDSTR ( n . prot_id ) ) ) ; type = ntohs ( n . type ) ; switch ( type ) { case IV2_NOTIFY_UNSUPPORTED_CRITICAL_PAYLOAD : notify_name = ""unsupported_critical_payload"" ; showspi = 0 ; break ; case IV2_NOTIFY_INVALID_IKE_SPI : notify_name = ""invalid_ike_spi"" ; showspi = 1 ; break ; case IV2_NOTIFY_INVALID_MAJOR_VERSION : notify_name = ""invalid_major_version"" ; showspi = 0 ; break ; case IV2_NOTIFY_INVALID_SYNTAX : notify_name = ""invalid_syntax"" ; showspi = 1 ; break ; case IV2_NOTIFY_INVALID_MESSAGE_ID : notify_name = ""invalid_message_id"" ; showspi = 1 ; break ; case IV2_NOTIFY_INVALID_SPI : notify_name = ""invalid_spi"" ; showspi = 1 ; break ; case IV2_NOTIFY_NO_PROPOSAL_CHOSEN : notify_name = ""no_protocol_chosen"" ; showspi = 1 ; break ; case IV2_NOTIFY_INVALID_KE_PAYLOAD : notify_name = ""invalid_ke_payload"" ; showspi = 1 ; break ; case IV2_NOTIFY_AUTHENTICATION_FAILED : notify_name = ""authentication_failed"" ; showspi = 1 ; break ; case IV2_NOTIFY_SINGLE_PAIR_REQUIRED : notify_name = ""single_pair_required"" ; showspi = 1 ; break ; case IV2_NOTIFY_NO_ADDITIONAL_SAS : notify_name = ""no_additional_sas"" ; showspi = 0 ; break ; case IV2_NOTIFY_INTERNAL_ADDRESS_FAILURE : notify_name = ""internal_address_failure"" ; showspi = 0 ; break ; case IV2_NOTIFY_FAILED_CP_REQUIRED : notify_name = ""failed:cp_required"" ; showspi = 0 ; break ; case IV2_NOTIFY_INVALID_SELECTORS : notify_name = ""invalid_selectors"" ; showspi = 0 ; break ; case IV2_NOTIFY_INITIAL_CONTACT : notify_name = ""initial_contact"" ; showspi = 0 ; break ; case IV2_NOTIFY_SET_WINDOW_SIZE : notify_name = ""set_window_size"" ; showspi = 0 ; break ; case IV2_NOTIFY_ADDITIONAL_TS_POSSIBLE : notify_name = ""additional_ts_possible"" ; showspi = 0 ; break ; case IV2_NOTIFY_IPCOMP_SUPPORTED : notify_name = ""ipcomp_supported"" ; showspi = 0 ; break ; case IV2_NOTIFY_NAT_DETECTION_SOURCE_IP : notify_name = ""nat_detection_source_ip"" ; showspi = 1 ; break ; case IV2_NOTIFY_NAT_DETECTION_DESTINATION_IP : notify_name = ""nat_detection_destination_ip"" ; showspi = 1 ; break ; case IV2_NOTIFY_COOKIE : notify_name = ""cookie"" ; showspi = 1 ; <S2SV_StartBug> showsomedata = 1 ; <S2SV_EndBug> showdata = 0 ; break ; case IV2_NOTIFY_USE_TRANSPORT_MODE : notify_name = ""use_transport_mode"" ; showspi = 0 ; break ; case IV2_NOTIFY_HTTP_CERT_LOOKUP_SUPPORTED : notify_name = ""http_cert_lookup_supported"" ; showspi = 0 ; break ; case IV2_NOTIFY_REKEY_SA : notify_name = ""rekey_sa"" ; showspi = 1 ; break ; case IV2_NOTIFY_ESP_TFC_PADDING_NOT_SUPPORTED : notify_name = ""tfc_padding_not_supported"" ; showspi = 0 ; break ; case IV2_NOTIFY_NON_FIRST_FRAGMENTS_ALSO : notify_name = ""non_first_fragment_also"" ; showspi = 0 ; break ; default : if ( type < 8192 ) { notify_name = ""error"" ; } else if ( type < 16384 ) { notify_name = ""private-error"" ; } else if ( type < 40960 ) { notify_name = ""status"" ; } else { notify_name = ""private-status"" ; } } if ( notify_name ) { ND_PRINT ( ( ndo , ""<S2SV_blank>type=%u(%s)"" , type , notify_name ) ) ; } if ( showspi && n . spi_size ) { ND_PRINT ( ( ndo , ""<S2SV_blank>spi="" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( p + 1 ) , n . spi_size ) ) goto trunc ; } cp = ( const u_char * ) ( p + 1 ) + n . spi_size ; <S2SV_StartBug> if ( 3 < ndo -> ndo_vflag ) { <S2SV_EndBug> showdata = 1 ; } <S2SV_StartBug> if ( ( showdata || ( showsomedata && ep - cp < 30 ) ) && cp < ep ) { <S2SV_EndBug> ND_PRINT ( ( ndo , ""<S2SV_blank>data=("" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( cp ) , ep - cp ) ) goto trunc ; ND_PRINT ( ( ndo , "")"" ) ) ; <S2SV_StartBug> } else if ( showsomedata && cp < ep ) { <S2SV_EndBug> <S2SV_StartBug> if ( ! ike_show_somedata ( ndo , cp , ep ) ) goto trunc ; <S2SV_EndBug> } return ( const u_char * ) ext + item_len ; trunc : ND_PRINT ( ( ndo , ""<S2SV_blank>[|%s]"" , NPSTR ( ISAKMP_NPTYPE_N ) ) ) ; return NULL ; }","; u_char showspi <S2SV_ModEnd> , showsomedata ; <S2SV_ModStart> = 1 ; <S2SV_ModEnd> showsomedata = 0 <S2SV_ModStart> showsomedata = 1 <S2SV_ModEnd> ; break ; <S2SV_ModStart> ; if ( cp < ep ) { if ( <S2SV_ModEnd> ndo -> ndo_vflag <S2SV_ModStart> ndo -> ndo_vflag > 3 <S2SV_ModEnd> || ( showsomedata <S2SV_ModStart> 30 ) ) <S2SV_ModEnd> { ND_PRINT ( <S2SV_ModStart> if ( showsomedata <S2SV_ModEnd> ) { if <S2SV_ModStart> goto trunc ; }"
394,void grubfs_free ( GrubFS * gf ) { if ( gf ) { <S2SV_StartBug> if ( gf -> file && gf -> file -> device ) <S2SV_EndBug> <S2SV_StartBug> free ( gf -> file -> device -> disk ) ; <S2SV_EndBug> free ( gf -> file ) ; free ( gf ) ; } },-> device ) { <S2SV_ModStart> disk ) ; }
395,"NOEXPORT void print_cipher ( CLI * c ) { SSL_CIPHER * cipher ; # ifndef OPENSSL_NO_COMP const COMP_METHOD * compression , * expansion ; # endif if ( c -> opt -> log_level < LOG_INFO ) return ; s_log ( LOG_INFO , ""TLS<S2SV_blank>%s:<S2SV_blank>%s"" , c -> opt -> option . client ? ""connected"" : ""accepted"" , SSL_session_reused ( c -> ssl ) && ! c -> flag . psk ? ""previous<S2SV_blank>session<S2SV_blank>reused"" : ""new<S2SV_blank>session<S2SV_blank>negotiated"" ) ; cipher = ( SSL_CIPHER * ) SSL_get_current_cipher ( c -> ssl ) ; s_log ( LOG_INFO , ""%s<S2SV_blank>ciphersuite:<S2SV_blank>%s<S2SV_blank>(%d-bit<S2SV_blank>encryption)"" , SSL_get_version ( c -> ssl ) , SSL_CIPHER_get_name ( cipher ) , SSL_CIPHER_get_bits ( cipher , NULL ) ) ; <S2SV_StartBug> # ifndef OPENSSL_NO_COMP <S2SV_EndBug> compression = SSL_get_current_compression ( c -> ssl ) ; expansion = SSL_get_current_expansion ( c -> ssl ) ; s_log ( compression || expansion ? LOG_INFO : LOG_DEBUG , ""Compression:<S2SV_blank>%s,<S2SV_blank>expansion:<S2SV_blank>%s"" , compression ? SSL_COMP_get_name ( compression ) : ""null"" , expansion ? SSL_COMP_get_name ( expansion ) : ""null"" ) ; # endif }",) ; # if OPENSSL_VERSION_NUMBER >= 0x10101000L print_tmp_key ( c -> ssl ) ; # endif #
396,"static void stellaris_enet_unrealize ( DeviceState * dev , Error * * errp ) { stellaris_enet_state * s = STELLARIS_ENET ( dev ) ; <S2SV_StartBug> unregister_savevm ( DEVICE ( s ) , ""stellaris_enet"" , s ) ; <S2SV_EndBug> memory_region_destroy ( & s -> mmio ) ; }",dev ) ; <S2SV_ModEnd> memory_region_destroy ( &
397,"static inline int xfrm_replay_verify_len ( struct xfrm_replay_state_esn * replay_esn , struct nlattr * rp ) { struct xfrm_replay_state_esn * up ; int ulen ; if ( ! replay_esn || ! rp ) return 0 ; up = nla_data ( rp ) ; ulen = xfrm_replay_state_esn_len ( up ) ; <S2SV_StartBug> if ( nla_len ( rp ) < ulen || xfrm_replay_state_esn_len ( replay_esn ) != ulen ) <S2SV_EndBug> return - EINVAL ; if ( up -> replay_window > up -> bmp_len * sizeof ( __u32 ) * 8 ) return - EINVAL ; return 0 ; }",) != ulen || replay_esn -> bmp_len != up -> bmp_len
398,"int add_packetdata ( struct mt_packet * packet , unsigned char * data , unsigned short length ) { <S2SV_StartBug> if ( packet -> size + length > MT_PACKET_LEN ) { <S2SV_EndBug> fprintf ( stderr , _ ( ""add_control_packet:<S2SV_blank>ERROR,<S2SV_blank>too<S2SV_blank>large<S2SV_blank>packet.<S2SV_blank>Exceeds<S2SV_blank>%d<S2SV_blank>bytes\\n"" ) , MT_PACKET_LEN ) ; return - 1 ; } memcpy ( packet -> data + packet -> size , data , length ) ; packet -> size += length ; return length ; }",{ if ( length > MT_PACKET_LEN - <S2SV_ModStart> packet -> size <S2SV_ModEnd> ) { fprintf
399,void vp9_save_layer_context ( VP9_COMP * const cpi ) { <S2SV_StartBug> const VP9_CONFIG * const oxcf = & cpi -> oxcf ; <S2SV_EndBug> <S2SV_StartBug> LAYER_CONTEXT * const lc = get_layer_context ( & cpi -> svc ) ; <S2SV_EndBug> lc -> rc = cpi -> rc ; lc -> twopass = cpi -> twopass ; lc -> target_bandwidth = ( int ) oxcf -> target_bandwidth ; <S2SV_StartBug> lc -> starting_buffer_level = oxcf -> starting_buffer_level ; <S2SV_EndBug> lc -> optimal_buffer_level = oxcf -> optimal_buffer_level ; lc -> maximum_buffer_size = oxcf -> maximum_buffer_size ; <S2SV_StartBug> lc -> framerate = cpi -> output_framerate ; <S2SV_EndBug> },) { const VP9EncoderConfig <S2SV_ModEnd> * const oxcf <S2SV_ModStart> = get_layer_context ( cpi <S2SV_ModEnd> ) ; lc <S2SV_ModStart> ; lc -> alt_ref_source <S2SV_ModEnd> = cpi -> <S2SV_ModStart> = cpi -> alt_ref_source <S2SV_ModEnd> ; } <S2SV_null>
400,"void br_mdb_notify ( struct net_device * dev , struct net_bridge_port * port , struct br_ip * group , int type ) { <S2SV_StartBug> struct br_mdb_entry entry ; <S2SV_EndBug> entry . ifindex = port -> dev -> ifindex ; entry . addr . proto = group -> proto ; entry . addr . u . ip4 = group -> u . ip4 ; # if IS_ENABLED ( CONFIG_IPV6 ) entry . addr . u . ip6 = group -> u . ip6 ; # endif __br_mdb_notify ( dev , & entry , type ) ; }","struct br_mdb_entry entry ; memset ( & entry , 0 , sizeof ( entry ) )"
401,"int raptor_turtle_writer_set_option ( raptor_turtle_writer * turtle_writer , raptor_option option , int value ) { if ( value < 0 || ! raptor_option_is_valid_for_area ( option , RAPTOR_OPTION_AREA_TURTLE_WRITER ) ) return 1 ; switch ( option ) { case RAPTOR_OPTION_WRITER_AUTO_INDENT : if ( value ) turtle_writer -> flags |= TURTLE_WRITER_AUTO_INDENT ; else turtle_writer -> flags &= ~ TURTLE_WRITER_AUTO_INDENT ; break ; case RAPTOR_OPTION_WRITER_INDENT_WIDTH : turtle_writer -> indent = value ; break ; case RAPTOR_OPTION_WRITER_AUTO_EMPTY : case RAPTOR_OPTION_WRITER_XML_VERSION : case RAPTOR_OPTION_WRITER_XML_DECLARATION : break ; case RAPTOR_OPTION_SCANNING : case RAPTOR_OPTION_ALLOW_NON_NS_ATTRIBUTES : case RAPTOR_OPTION_ALLOW_OTHER_PARSETYPES : case RAPTOR_OPTION_ALLOW_BAGID : case RAPTOR_OPTION_ALLOW_RDF_TYPE_RDF_LIST : case RAPTOR_OPTION_NORMALIZE_LANGUAGE : case RAPTOR_OPTION_NON_NFC_FATAL : case RAPTOR_OPTION_WARN_OTHER_PARSETYPES : case RAPTOR_OPTION_CHECK_RDF_ID : case RAPTOR_OPTION_HTML_TAG_SOUP : case RAPTOR_OPTION_MICROFORMATS : case RAPTOR_OPTION_HTML_LINK : case RAPTOR_OPTION_WWW_TIMEOUT : case RAPTOR_OPTION_STRICT : case RAPTOR_OPTION_NO_NET : case RAPTOR_OPTION_NO_FILE : <S2SV_StartBug> case RAPTOR_OPTION_RELATIVE_URIS : <S2SV_EndBug> case RAPTOR_OPTION_RESOURCE_BORDER : case RAPTOR_OPTION_LITERAL_BORDER : case RAPTOR_OPTION_BNODE_BORDER : case RAPTOR_OPTION_RESOURCE_FILL : case RAPTOR_OPTION_LITERAL_FILL : case RAPTOR_OPTION_BNODE_FILL : case RAPTOR_OPTION_JSON_CALLBACK : case RAPTOR_OPTION_JSON_EXTRA_DATA : case RAPTOR_OPTION_RSS_TRIPLES : case RAPTOR_OPTION_ATOM_ENTRY_URI : case RAPTOR_OPTION_PREFIX_ELEMENTS : case RAPTOR_OPTION_WRITE_BASE_URI : case RAPTOR_OPTION_WWW_HTTP_CACHE_CONTROL : case RAPTOR_OPTION_WWW_HTTP_USER_AGENT : case RAPTOR_OPTION_WWW_CERT_FILENAME : case RAPTOR_OPTION_WWW_CERT_TYPE : case RAPTOR_OPTION_WWW_CERT_PASSPHRASE : case RAPTOR_OPTION_WWW_SSL_VERIFY_PEER : case RAPTOR_OPTION_WWW_SSL_VERIFY_HOST : default : return - 1 ; break ; } return 0 ; }",RAPTOR_OPTION_NO_FILE : case RAPTOR_OPTION_LOAD_EXTERNAL_ENTITIES : case
402,"static int l2cap_sock_listen ( struct socket * sock , int backlog ) { struct sock * sk = sock -> sk ; int err = 0 ; BT_DBG ( ""sk<S2SV_blank>%p<S2SV_blank>backlog<S2SV_blank>%d"" , sk , backlog ) ; lock_sock ( sk ) ; if ( sk -> sk_state != BT_BOUND || sock -> type != SOCK_SEQPACKET ) { err = - EBADFD ; goto done ; } switch ( l2cap_pi ( sk ) -> mode ) { case L2CAP_MODE_BASIC : break ; case L2CAP_MODE_ERTM : <S2SV_StartBug> if ( enable_ertm ) <S2SV_EndBug> break ; default : err = - ENOTSUPP ; goto done ; } if ( ! l2cap_pi ( sk ) -> psm ) { bdaddr_t * src = & bt_sk ( sk ) -> src ; u16 psm ; err = - EINVAL ; write_lock_bh ( & l2cap_sk_list . lock ) ; for ( psm = 0x1001 ; psm < 0x1100 ; psm += 2 ) if ( ! __l2cap_get_sock_by_addr ( cpu_to_le16 ( psm ) , src ) ) { l2cap_pi ( sk ) -> psm = cpu_to_le16 ( psm ) ; l2cap_pi ( sk ) -> sport = cpu_to_le16 ( psm ) ; err = 0 ; break ; } write_unlock_bh ( & l2cap_sk_list . lock ) ; if ( err < 0 ) goto done ; } sk -> sk_max_ack_backlog = backlog ; sk -> sk_ack_backlog = 0 ; sk -> sk_state = BT_LISTEN ; done : release_sock ( sk ) ; return err ; }",case L2CAP_MODE_ERTM : case L2CAP_MODE_STREAMING :
403,"static int check_dual_ref_flags ( VP9_COMP * cpi ) { const int ref_flags = cpi -> ref_frame_flags ; <S2SV_StartBug> if ( vp9_segfeature_active ( & cpi -> common . seg , 1 , SEG_LVL_REF_FRAME ) ) { <S2SV_EndBug> return 0 ; } else { return ( ! ! ( ref_flags & VP9_GOLD_FLAG ) + ! ! ( ref_flags & VP9_LAST_FLAG ) + ! ! ( ref_flags & VP9_ALT_FLAG ) ) >= 2 ; } }",; if ( segfeature_active <S2SV_ModEnd> ( & cpi
404,"int ldbm_back_bind ( Slapi_PBlock * pb ) { backend * be ; ldbm_instance * inst ; ber_tag_t method ; struct berval * cred ; struct ldbminfo * li ; struct backentry * e ; Slapi_Attr * attr ; Slapi_Value * * bvals ; entry_address * addr ; back_txn txn = { NULL } ; int rc = SLAPI_BIND_SUCCESS ; int result_sent = 0 ; slapi_pblock_get ( pb , SLAPI_BACKEND , & be ) ; slapi_pblock_get ( pb , SLAPI_PLUGIN_PRIVATE , & li ) ; slapi_pblock_get ( pb , SLAPI_TARGET_ADDRESS , & addr ) ; slapi_pblock_get ( pb , SLAPI_BIND_METHOD , & method ) ; slapi_pblock_get ( pb , SLAPI_BIND_CREDENTIALS , & cred ) ; slapi_pblock_get ( pb , SLAPI_TXN , & txn . back_txn_txn ) ; if ( ! txn . back_txn_txn ) { dblayer_txn_init ( li , & txn ) ; slapi_pblock_set ( pb , SLAPI_TXN , txn . back_txn_txn ) ; } inst = ( ldbm_instance * ) be -> be_instance_info ; if ( inst -> inst_ref_count ) { slapi_counter_increment ( inst -> inst_ref_count ) ; } else { slapi_log_err ( SLAPI_LOG_ERR , ""ldbm_back_bind"" , ""instance<S2SV_blank>%s<S2SV_blank>does<S2SV_blank>not<S2SV_blank>exist.\\n"" , inst -> inst_name ) ; return ( SLAPI_BIND_FAIL ) ; } if ( method == LDAP_AUTH_SIMPLE && cred -> bv_len == 0 ) { rc = SLAPI_BIND_ANONYMOUS ; goto bail ; } if ( ( e = find_entry ( pb , be , addr , & txn , & result_sent ) ) == NULL ) { rc = SLAPI_BIND_FAIL ; if ( ! result_sent ) { slapi_send_ldap_result ( pb , LDAP_INAPPROPRIATE_AUTH , NULL , NULL , 0 , NULL ) ; } goto bail ; } switch ( method ) { case LDAP_AUTH_SIMPLE : { Slapi_Value cv ; if ( slapi_entry_attr_find ( e -> ep_entry , ""userpassword"" , & attr ) != 0 ) { <S2SV_StartBug> slapi_send_ldap_result ( pb , LDAP_INAPPROPRIATE_AUTH , NULL , <S2SV_EndBug> NULL , 0 , NULL ) ; CACHE_RETURN ( & inst -> inst_cache , & e ) ; rc = SLAPI_BIND_FAIL ; goto bail ; } bvals = attr_get_present_values ( attr ) ; slapi_value_init_berval ( & cv , cred ) ; if ( slapi_pw_find_sv ( bvals , & cv ) != 0 ) { slapi_pblock_set ( pb , SLAPI_PB_RESULT_TEXT , ""Invalid<S2SV_blank>credentials"" ) ; slapi_send_ldap_result ( pb , LDAP_INVALID_CREDENTIALS , NULL , NULL , 0 , NULL ) ; CACHE_RETURN ( & inst -> inst_cache , & e ) ; value_done ( & cv ) ; rc = SLAPI_BIND_FAIL ; goto bail ; } value_done ( & cv ) ; } break ; default : slapi_send_ldap_result ( pb , LDAP_STRONG_AUTH_NOT_SUPPORTED , NULL , ""auth<S2SV_blank>method<S2SV_blank>not<S2SV_blank>supported"" , 0 , NULL ) ; CACHE_RETURN ( & inst -> inst_cache , & e ) ; rc = SLAPI_BIND_FAIL ; goto bail ; } CACHE_RETURN ( & inst -> inst_cache , & e ) ; bail : if ( inst -> inst_ref_count ) { slapi_counter_decrement ( inst -> inst_ref_count ) ; } return rc ; }","0 ) { slapi_pblock_set ( pb , SLAPI_PB_RESULT_TEXT , ""Entry<S2SV_blank>does<S2SV_blank>not<S2SV_blank>have<S2SV_blank>userpassword<S2SV_blank>set"" ) ; <S2SV_ModStart> ( pb , LDAP_INVALID_CREDENTIALS , NULL , <S2SV_ModEnd> NULL , 0"
405,"WORD32 ih264d_video_decode ( iv_obj_t * dec_hdl , void * pv_api_ip , void * pv_api_op ) { dec_struct_t * ps_dec = ( dec_struct_t * ) ( dec_hdl -> pv_codec_handle ) ; WORD32 i4_err_status = 0 ; UWORD8 * pu1_buf = NULL ; WORD32 buflen ; UWORD32 u4_max_ofst , u4_length_of_start_code = 0 ; UWORD32 bytes_consumed = 0 ; UWORD32 cur_slice_is_nonref = 0 ; UWORD32 u4_next_is_aud ; UWORD32 u4_first_start_code_found = 0 ; WORD32 ret = 0 , api_ret_value = IV_SUCCESS ; WORD32 header_data_left = 0 , frame_data_left = 0 ; UWORD8 * pu1_bitstrm_buf ; ivd_video_decode_ip_t * ps_dec_ip ; ivd_video_decode_op_t * ps_dec_op ; ithread_set_name ( ( void * ) ""Parse_thread"" ) ; ps_dec_ip = ( ivd_video_decode_ip_t * ) pv_api_ip ; ps_dec_op = ( ivd_video_decode_op_t * ) pv_api_op ; { UWORD32 u4_size ; u4_size = ps_dec_op -> u4_size ; memset ( ps_dec_op , 0 , sizeof ( ivd_video_decode_op_t ) ) ; ps_dec_op -> u4_size = u4_size ; } ps_dec -> pv_dec_out = ps_dec_op ; ps_dec -> process_called = 1 ; if ( ps_dec -> init_done != 1 ) { return IV_FAIL ; } DATA_SYNC ( ) ; if ( 0 == ps_dec -> u1_flushfrm ) { if ( ps_dec_ip -> pv_stream_buffer == NULL ) { ps_dec_op -> u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM ; ps_dec_op -> u4_error_code |= IVD_DEC_FRM_BS_BUF_NULL ; return IV_FAIL ; } if ( ps_dec_ip -> u4_num_Bytes <= 0 ) { ps_dec_op -> u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM ; ps_dec_op -> u4_error_code |= IVD_DEC_NUMBYTES_INV ; return IV_FAIL ; } } ps_dec -> u1_pic_decode_done = 0 ; ps_dec_op -> u4_num_bytes_consumed = 0 ; ps_dec -> ps_out_buffer = NULL ; if ( ps_dec_ip -> u4_size >= offsetof ( ivd_video_decode_ip_t , s_out_buffer ) ) ps_dec -> ps_out_buffer = & ps_dec_ip -> s_out_buffer ; ps_dec -> u4_fmt_conv_cur_row = 0 ; ps_dec -> u4_output_present = 0 ; ps_dec -> s_disp_op . u4_error_code = 1 ; ps_dec -> u4_fmt_conv_num_rows = FMT_CONV_NUM_ROWS ; ps_dec -> u4_stop_threads = 0 ; if ( 0 == ps_dec -> u4_share_disp_buf && ps_dec -> i4_decode_header == 0 ) { UWORD32 i ; if ( ps_dec -> ps_out_buffer -> u4_num_bufs == 0 ) { ps_dec_op -> u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM ; ps_dec_op -> u4_error_code |= IVD_DISP_FRM_ZERO_OP_BUFS ; return IV_FAIL ; } for ( i = 0 ; i < ps_dec -> ps_out_buffer -> u4_num_bufs ; i ++ ) { if ( ps_dec -> ps_out_buffer -> pu1_bufs [ i ] == NULL ) { ps_dec_op -> u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM ; ps_dec_op -> u4_error_code |= IVD_DISP_FRM_OP_BUF_NULL ; return IV_FAIL ; } if ( ps_dec -> ps_out_buffer -> u4_min_out_buf_size [ i ] == 0 ) { ps_dec_op -> u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM ; ps_dec_op -> u4_error_code |= IVD_DISP_FRM_ZERO_OP_BUF_SIZE ; return IV_FAIL ; } } } if ( ps_dec -> u4_total_frames_decoded >= NUM_FRAMES_LIMIT ) { ps_dec_op -> u4_error_code = ERROR_FRAME_LIMIT_OVER ; return IV_FAIL ; } ps_dec -> u4_ts = ps_dec_ip -> u4_ts ; ps_dec_op -> u4_error_code = 0 ; ps_dec_op -> e_pic_type = - 1 ; ps_dec_op -> u4_output_present = 0 ; ps_dec_op -> u4_frame_decoded_flag = 0 ; ps_dec -> i4_frametype = - 1 ; ps_dec -> i4_content_type = - 1 ; ps_dec -> u4_slice_start_code_found = 0 ; if ( ps_dec -> u1_init_dec_flag == 1 && ps_dec -> u4_share_disp_buf == 1 && ps_dec -> u1_flushfrm == 0 ) { UWORD32 i ; WORD32 disp_avail = 0 , free_id ; for ( i = 0 ; i < ps_dec -> u1_pic_bufs ; i ++ ) { if ( 0 == ps_dec -> u4_disp_buf_mapping [ i ] || 1 == ps_dec -> u4_disp_buf_to_be_freed [ i ] ) { disp_avail = 1 ; break ; } } if ( 0 == disp_avail ) { ps_dec_op -> u4_error_code = IVD_DEC_REF_BUF_NULL ; ps_dec_op -> u4_error_code |= ( 1 << IVD_UNSUPPORTEDPARAM ) ; return ( IV_FAIL ) ; } while ( 1 ) { pic_buffer_t * ps_pic_buf ; ps_pic_buf = ( pic_buffer_t * ) ih264_buf_mgr_get_next_free ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , & free_id ) ; if ( ps_pic_buf == NULL ) { UWORD32 i , display_queued = 0 ; for ( i = 0 ; i < ( MAX_DISP_BUFS_NEW ) ; i ++ ) { if ( 0 != ps_dec -> u4_disp_buf_mapping [ i ] ) { display_queued = 1 ; break ; } } if ( 1 == display_queued ) { ps_dec_op -> u4_error_code = IVD_DEC_REF_BUF_NULL ; ps_dec_op -> u4_error_code |= ( 1 << IVD_UNSUPPORTEDPARAM ) ; return ( IV_FAIL ) ; } } else { if ( 1 == ps_dec -> u4_disp_buf_mapping [ free_id ] ) { ih264_buf_mgr_set_status ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , free_id , BUF_MGR_IO ) ; } else { ih264_buf_mgr_release ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , free_id , BUF_MGR_IO ) ; break ; } } } } if ( ps_dec -> u1_flushfrm && ps_dec -> u1_init_dec_flag ) { ih264d_get_next_display_field ( ps_dec , ps_dec -> ps_out_buffer , & ( ps_dec -> s_disp_op ) ) ; if ( 0 == ps_dec -> s_disp_op . u4_error_code ) { ps_dec -> u4_fmt_conv_cur_row = 0 ; ps_dec -> u4_fmt_conv_num_rows = ps_dec -> s_disp_frame_info . u4_y_ht ; ih264d_format_convert ( ps_dec , & ( ps_dec -> s_disp_op ) , ps_dec -> u4_fmt_conv_cur_row , ps_dec -> u4_fmt_conv_num_rows ) ; ps_dec -> u4_fmt_conv_cur_row += ps_dec -> u4_fmt_conv_num_rows ; ps_dec -> u4_output_present = 1 ; } ih264d_release_display_field ( ps_dec , & ( ps_dec -> s_disp_op ) ) ; ps_dec_op -> u4_pic_wd = ( UWORD32 ) ps_dec -> u2_disp_width ; ps_dec_op -> u4_pic_ht = ( UWORD32 ) ps_dec -> u2_disp_height ; ps_dec_op -> u4_new_seq = 0 ; ps_dec_op -> u4_output_present = ps_dec -> u4_output_present ; ps_dec_op -> u4_progressive_frame_flag = ps_dec -> s_disp_op . u4_progressive_frame_flag ; ps_dec_op -> e_output_format = ps_dec -> s_disp_op . e_output_format ; ps_dec_op -> s_disp_frm_buf = ps_dec -> s_disp_op . s_disp_frm_buf ; ps_dec_op -> e4_fld_type = ps_dec -> s_disp_op . e4_fld_type ; ps_dec_op -> u4_ts = ps_dec -> s_disp_op . u4_ts ; ps_dec_op -> u4_disp_buf_id = ps_dec -> s_disp_op . u4_disp_buf_id ; ps_dec_op -> u4_is_ref_flag = - 1 ; ps_dec_op -> e_pic_type = IV_NA_FRAME ; ps_dec_op -> u4_frame_decoded_flag = 0 ; if ( 0 == ps_dec -> s_disp_op . u4_error_code ) { return ( IV_SUCCESS ) ; } else return ( IV_FAIL ) ; } if ( ps_dec -> u1_res_changed == 1 ) { ih264d_init_decoder ( ps_dec ) ; } ps_dec -> u4_prev_nal_skipped = 0 ; ps_dec -> u2_cur_mb_addr = 0 ; ps_dec -> u2_total_mbs_coded = 0 ; ps_dec -> u2_cur_slice_num = 0 ; ps_dec -> cur_dec_mb_num = 0 ; ps_dec -> cur_recon_mb_num = 0 ; <S2SV_StartBug> ps_dec -> u4_first_slice_in_pic = 2 ; <S2SV_EndBug> ps_dec -> u1_first_pb_nal_in_pic = 1 ; ps_dec -> u1_slice_header_done = 0 ; ps_dec -> u1_dangling_field = 0 ; ps_dec -> u4_dec_thread_created = 0 ; ps_dec -> u4_bs_deblk_thread_created = 0 ; ps_dec -> u4_cur_bs_mb_num = 0 ; ps_dec -> u4_start_recon_deblk = 0 ; DEBUG_THREADS_PRINTF ( ""<S2SV_blank>Starting<S2SV_blank>process<S2SV_blank>call\\n"" ) ; ps_dec -> u4_pic_buf_got = 0 ; do { pu1_buf = ( UWORD8 * ) ps_dec_ip -> pv_stream_buffer + ps_dec_op -> u4_num_bytes_consumed ; u4_max_ofst = ps_dec_ip -> u4_num_Bytes - ps_dec_op -> u4_num_bytes_consumed ; pu1_bitstrm_buf = ps_dec -> ps_mem_tab [ MEM_REC_BITSBUF ] . pv_base ; u4_next_is_aud = 0 ; buflen = ih264d_find_start_code ( pu1_buf , 0 , u4_max_ofst , & u4_length_of_start_code , & u4_next_is_aud ) ; if ( buflen == - 1 ) buflen = 0 ; buflen = MIN ( buflen , ( WORD32 ) ( ps_dec -> ps_mem_tab [ MEM_REC_BITSBUF ] . u4_mem_size - 8 ) ) ; bytes_consumed = buflen + u4_length_of_start_code ; ps_dec_op -> u4_num_bytes_consumed += bytes_consumed ; if ( buflen >= MAX_NAL_UNIT_SIZE ) { ih264d_fill_output_struct_from_context ( ps_dec , ps_dec_op ) ; H264_DEC_DEBUG_PRINT ( ""\\nNal<S2SV_blank>Size<S2SV_blank>exceeded<S2SV_blank>%d,<S2SV_blank>Processing<S2SV_blank>Stopped..\\n"" , MAX_NAL_UNIT_SIZE ) ; ps_dec -> i4_error_code = 1 << IVD_CORRUPTEDDATA ; ps_dec_op -> e_pic_type = - 1 ; ih264d_signal_decode_thread ( ps_dec ) ; if ( ps_dec -> u4_pic_buf_got == 0 ) { if ( ps_dec -> i4_header_decoded == 3 ) { ps_dec -> u2_total_mbs_coded = ps_dec -> ps_cur_sps -> u2_max_mb_addr + 1 ; } if ( ps_dec -> u4_num_cores == 3 ) { ih264d_signal_bs_deblk_thread ( ps_dec ) ; } return IV_FAIL ; } else { ps_dec -> u1_pic_decode_done = 1 ; continue ; } } { UWORD8 u1_firstbyte , u1_nal_ref_idc ; if ( ps_dec -> i4_app_skip_mode == IVD_SKIP_B ) { u1_firstbyte = * ( pu1_buf + u4_length_of_start_code ) ; u1_nal_ref_idc = ( UWORD8 ) ( NAL_REF_IDC ( u1_firstbyte ) ) ; if ( u1_nal_ref_idc == 0 ) { cur_slice_is_nonref = 1 ; continue ; } else { if ( 1 == cur_slice_is_nonref ) { ps_dec_op -> u4_num_bytes_consumed -= bytes_consumed ; ps_dec_op -> e_pic_type = IV_B_FRAME ; ps_dec_op -> u4_error_code = IVD_DEC_FRM_SKIPPED ; ps_dec_op -> u4_error_code |= ( 1 << IVD_UNSUPPORTEDPARAM ) ; ps_dec_op -> u4_frame_decoded_flag = 0 ; ps_dec_op -> u4_size = sizeof ( ivd_video_decode_op_t ) ; ih264d_signal_decode_thread ( ps_dec ) ; if ( ps_dec -> u4_num_cores == 3 ) { ih264d_signal_bs_deblk_thread ( ps_dec ) ; } return ( IV_FAIL ) ; } } } } if ( buflen ) { memcpy ( pu1_bitstrm_buf , pu1_buf + u4_length_of_start_code , buflen ) ; u4_first_start_code_found = 1 ; } else { if ( u4_first_start_code_found == 0 ) { ps_dec -> i4_error_code = ERROR_START_CODE_NOT_FOUND ; ps_dec_op -> u4_error_code |= 1 << IVD_INSUFFICIENTDATA ; if ( ps_dec -> u4_pic_buf_got == 0 ) { ih264d_fill_output_struct_from_context ( ps_dec , ps_dec_op ) ; ps_dec_op -> u4_error_code = ps_dec -> i4_error_code ; ps_dec_op -> u4_frame_decoded_flag = 0 ; return ( IV_FAIL ) ; } else { ps_dec -> u1_pic_decode_done = 1 ; continue ; } } else { frame_data_left = 0 ; header_data_left = 0 ; continue ; } } ps_dec -> u4_return_to_app = 0 ; ret = ih264d_parse_nal_unit ( dec_hdl , ps_dec_op , pu1_bitstrm_buf , buflen ) ; if ( ret != OK ) { UWORD32 error = ih264d_map_error ( ret ) ; ps_dec_op -> u4_error_code = error | ret ; api_ret_value = IV_FAIL ; if ( ( ret == IVD_RES_CHANGED ) || ( ret == IVD_STREAM_WIDTH_HEIGHT_NOT_SUPPORTED ) || ( ret == ERROR_UNAVAIL_PICBUF_T ) || ( ret == ERROR_UNAVAIL_MVBUF_T ) || ( ret == ERROR_INV_SPS_PPS_T ) ) { ps_dec -> u4_slice_start_code_found = 0 ; break ; } if ( ( ret == ERROR_INCOMPLETE_FRAME ) || ( ret == ERROR_DANGLING_FIELD_IN_PIC ) ) { ps_dec_op -> u4_num_bytes_consumed -= bytes_consumed ; api_ret_value = IV_FAIL ; break ; } if ( ret == ERROR_IN_LAST_SLICE_OF_PIC ) { api_ret_value = IV_FAIL ; break ; } } if ( ps_dec -> u4_return_to_app ) { ps_dec_op -> u4_num_bytes_consumed -= bytes_consumed ; ps_dec_op -> u4_error_code = IVD_DEC_FRM_SKIPPED ; ps_dec_op -> u4_error_code |= ( 1 << IVD_UNSUPPORTEDPARAM ) ; ps_dec_op -> u4_frame_decoded_flag = 0 ; ps_dec_op -> u4_size = sizeof ( ivd_video_decode_op_t ) ; ih264d_signal_decode_thread ( ps_dec ) ; if ( ps_dec -> u4_num_cores == 3 ) { ih264d_signal_bs_deblk_thread ( ps_dec ) ; } return ( IV_FAIL ) ; } header_data_left = ( ( ps_dec -> i4_decode_header == 1 ) && ( ps_dec -> i4_header_decoded != 3 ) && ( ps_dec_op -> u4_num_bytes_consumed < ps_dec_ip -> u4_num_Bytes ) ) ; frame_data_left = ( ( ( ps_dec -> i4_decode_header == 0 ) && ( ( ps_dec -> u1_pic_decode_done == 0 ) || ( u4_next_is_aud == 1 ) ) ) && ( ps_dec_op -> u4_num_bytes_consumed < ps_dec_ip -> u4_num_Bytes ) ) ; } while ( ( header_data_left == 1 ) || ( frame_data_left == 1 ) ) ; if ( ( ps_dec -> u4_slice_start_code_found == 1 ) && ps_dec -> u2_total_mbs_coded < ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) { WORD32 num_mb_skipped ; WORD32 prev_slice_err ; pocstruct_t temp_poc ; WORD32 ret1 ; WORD32 ht_in_mbs ; ht_in_mbs = ps_dec -> u2_pic_ht >> ( 4 + ps_dec -> ps_cur_slice -> u1_field_pic_flag ) ; num_mb_skipped = ( ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) - ps_dec -> u2_total_mbs_coded ; if ( ps_dec -> u4_first_slice_in_pic && ( ps_dec -> u4_pic_buf_got == 0 ) ) prev_slice_err = 1 ; else prev_slice_err = 2 ; if ( ps_dec -> u4_first_slice_in_pic && ( ps_dec -> u2_total_mbs_coded == 0 ) ) prev_slice_err = 1 ; ret1 = ih264d_mark_err_slice_skip ( ps_dec , num_mb_skipped , ps_dec -> u1_nal_unit_type == IDR_SLICE_NAL , ps_dec -> ps_cur_slice -> u2_frame_num , & temp_poc , prev_slice_err ) ; if ( ( ret1 == ERROR_UNAVAIL_PICBUF_T ) || ( ret1 == ERROR_UNAVAIL_MVBUF_T ) || ( ret1 == ERROR_INV_SPS_PPS_T ) ) { ret = ret1 ; } } if ( ( ret == IVD_RES_CHANGED ) || ( ret == IVD_STREAM_WIDTH_HEIGHT_NOT_SUPPORTED ) || ( ret == ERROR_UNAVAIL_PICBUF_T ) || ( ret == ERROR_UNAVAIL_MVBUF_T ) || ( ret == ERROR_INV_SPS_PPS_T ) ) { ih264d_signal_decode_thread ( ps_dec ) ; if ( ps_dec -> u4_num_cores == 3 ) { ih264d_signal_bs_deblk_thread ( ps_dec ) ; } if ( ret == IVD_RES_CHANGED ) { ps_dec_op -> u4_num_bytes_consumed -= bytes_consumed ; } return IV_FAIL ; } if ( ps_dec -> u1_separate_parse ) { if ( ps_dec -> u4_num_cores == 2 ) { if ( ( ps_dec -> u4_nmb_deblk == 0 ) && ( ps_dec -> u4_start_recon_deblk == 1 ) && ( ps_dec -> ps_cur_sps -> u1_mb_aff_flag == 0 ) ) { UWORD32 u4_num_mbs , u4_max_addr ; tfr_ctxt_t s_tfr_ctxt ; tfr_ctxt_t * ps_tfr_cxt = & s_tfr_ctxt ; pad_mgr_t * ps_pad_mgr = & ps_dec -> s_pad_mgr ; u4_max_addr = ( ps_dec -> u2_frm_wd_in_mbs * ps_dec -> u2_frm_ht_in_mbs ) - 1 ; ps_dec -> u4_cur_bs_mb_num = u4_max_addr + 1 ; ih264d_init_deblk_tfr_ctxt ( ps_dec , ps_pad_mgr , ps_tfr_cxt , ps_dec -> u2_frm_wd_in_mbs , 0 ) ; u4_num_mbs = u4_max_addr - ps_dec -> u4_cur_deblk_mb_num + 1 ; DEBUG_PERF_PRINTF ( ""mbs<S2SV_blank>left<S2SV_blank>for<S2SV_blank>deblocking=<S2SV_blank>%d<S2SV_blank>\\n"" , u4_num_mbs ) ; if ( u4_num_mbs != 0 ) ih264d_check_mb_map_deblk ( ps_dec , u4_num_mbs , ps_tfr_cxt , 1 ) ; ps_dec -> u4_start_recon_deblk = 0 ; } } ih264d_signal_decode_thread ( ps_dec ) ; if ( ps_dec -> u4_num_cores == 3 ) { ih264d_signal_bs_deblk_thread ( ps_dec ) ; } } DATA_SYNC ( ) ; if ( ( ps_dec_op -> u4_error_code & 0xff ) != ERROR_DYNAMIC_RESOLUTION_NOT_SUPPORTED ) { ps_dec_op -> u4_pic_wd = ( UWORD32 ) ps_dec -> u2_disp_width ; ps_dec_op -> u4_pic_ht = ( UWORD32 ) ps_dec -> u2_disp_height ; } if ( ps_dec -> i4_header_decoded != 3 ) { ps_dec_op -> u4_error_code |= ( 1 << IVD_INSUFFICIENTDATA ) ; } if ( ps_dec -> i4_decode_header == 1 && ps_dec -> i4_header_decoded != 3 ) { ps_dec_op -> u4_error_code |= ( 1 << IVD_INSUFFICIENTDATA ) ; } if ( ps_dec -> u4_prev_nal_skipped ) { ps_dec_op -> u4_error_code = IVD_DEC_FRM_SKIPPED ; ps_dec_op -> u4_error_code |= ( 1 << IVD_UNSUPPORTEDPARAM ) ; ps_dec_op -> u4_frame_decoded_flag = 0 ; ps_dec_op -> u4_size = sizeof ( ivd_video_decode_op_t ) ; if ( ps_dec -> u4_num_cores == 3 ) { ih264d_signal_bs_deblk_thread ( ps_dec ) ; } return ( IV_FAIL ) ; } if ( ( ps_dec -> u4_slice_start_code_found == 1 ) && ( ERROR_DANGLING_FIELD_IN_PIC != i4_err_status ) ) { if ( ps_dec -> ps_cur_slice -> u1_field_pic_flag ) { if ( 1 == ps_dec -> ps_cur_slice -> u1_bottom_field_flag ) { ps_dec -> u1_top_bottom_decoded |= BOT_FIELD_ONLY ; } else { ps_dec -> u1_top_bottom_decoded |= TOP_FIELD_ONLY ; } } if ( ( ( ps_dec -> ps_dec_err_status -> u1_err_flag & REJECT_CUR_PIC ) == 0 ) && ( ps_dec -> u4_pic_buf_got == 1 ) ) { ret = ih264d_deblock_display ( ps_dec ) ; } if ( ps_dec -> i4_header_decoded == 3 ) { ps_dec -> u2_total_mbs_coded = ps_dec -> ps_cur_sps -> u2_max_mb_addr + 1 ; } if ( ps_dec -> ps_cur_slice -> u1_nal_unit_type == IDR_SLICE_NAL ) { ps_dec -> i4_frametype = IV_IDR_FRAME ; } else if ( ps_dec -> i4_pic_type == B_SLICE ) { ps_dec -> i4_frametype = IV_B_FRAME ; } else if ( ps_dec -> i4_pic_type == P_SLICE ) { ps_dec -> i4_frametype = IV_P_FRAME ; } else if ( ps_dec -> i4_pic_type == I_SLICE ) { ps_dec -> i4_frametype = IV_I_FRAME ; } else { H264_DEC_DEBUG_PRINT ( ""Shouldn\'t<S2SV_blank>come<S2SV_blank>here\\n"" ) ; } ps_dec -> i4_content_type = ps_dec -> ps_cur_slice -> u1_field_pic_flag ; ps_dec -> u4_total_frames_decoded = ps_dec -> u4_total_frames_decoded + 2 ; ps_dec -> u4_total_frames_decoded = ps_dec -> u4_total_frames_decoded - ps_dec -> ps_cur_slice -> u1_field_pic_flag ; } if ( ps_dec -> u4_num_cores == 3 ) { ih264d_signal_bs_deblk_thread ( ps_dec ) ; } { if ( ( 0 == ps_dec -> u4_num_reorder_frames_at_init ) && ps_dec -> u1_init_dec_flag ) { ih264d_get_next_display_field ( ps_dec , ps_dec -> ps_out_buffer , & ( ps_dec -> s_disp_op ) ) ; if ( 0 == ps_dec -> s_disp_op . u4_error_code ) { ps_dec -> u4_fmt_conv_cur_row = 0 ; ps_dec -> u4_output_present = 1 ; } } ih264d_fill_output_struct_from_context ( ps_dec , ps_dec_op ) ; if ( ps_dec -> u4_output_present && ( ps_dec -> u4_fmt_conv_cur_row < ps_dec -> s_disp_frame_info . u4_y_ht ) ) { ps_dec -> u4_fmt_conv_num_rows = ps_dec -> s_disp_frame_info . u4_y_ht - ps_dec -> u4_fmt_conv_cur_row ; ih264d_format_convert ( ps_dec , & ( ps_dec -> s_disp_op ) , ps_dec -> u4_fmt_conv_cur_row , ps_dec -> u4_fmt_conv_num_rows ) ; ps_dec -> u4_fmt_conv_cur_row += ps_dec -> u4_fmt_conv_num_rows ; } ih264d_release_display_field ( ps_dec , & ( ps_dec -> s_disp_op ) ) ; } if ( ps_dec -> i4_decode_header == 1 && ( ps_dec -> i4_header_decoded & 1 ) == 1 ) { ps_dec_op -> u4_progressive_frame_flag = 1 ; if ( ( NULL != ps_dec -> ps_cur_sps ) && ( 1 == ( ps_dec -> ps_cur_sps -> u1_is_valid ) ) ) { if ( ( 0 == ps_dec -> ps_sps -> u1_frame_mbs_only_flag ) && ( 0 == ps_dec -> ps_sps -> u1_mb_aff_flag ) ) ps_dec_op -> u4_progressive_frame_flag = 0 ; } } if ( ( TOP_FIELD_ONLY | BOT_FIELD_ONLY ) == ps_dec -> u1_top_bottom_decoded ) { ps_dec -> u1_top_bottom_decoded = 0 ; } if ( ps_dec -> u4_pic_buf_got == 1 ) { if ( 1 == ps_dec -> u1_last_pic_not_decoded ) { ret = ih264d_end_of_pic_dispbuf_mgr ( ps_dec ) ; if ( ret != OK ) return ret ; ret = ih264d_end_of_pic ( ps_dec ) ; if ( ret != OK ) return ret ; } else { ret = ih264d_end_of_pic ( ps_dec ) ; if ( ret != OK ) return ret ; } } DATA_SYNC ( ) ; H264_DEC_DEBUG_PRINT ( ""The<S2SV_blank>num<S2SV_blank>bytes<S2SV_blank>consumed:<S2SV_blank>%d\\n"" , ps_dec_op -> u4_num_bytes_consumed ) ; return api_ret_value ; }",-> u4_first_slice_in_pic = 1 <S2SV_ModEnd> ; ps_dec ->
406,"MagickExport const char * GetMagickFeatures ( void ) { return ""DPC"" <S2SV_StartBug> # if defined ( MAGICKCORE_BUILD_MODULES ) || defined ( _DLL ) <S2SV_EndBug> ""<S2SV_blank>Modules"" # endif # if defined ( MAGICKCORE_HDRI_SUPPORT ) <S2SV_StartBug> ""<S2SV_blank>HDRI"" <S2SV_EndBug> # endif # if defined ( MAGICKCORE_OPENCL_SUPPORT ) ""<S2SV_blank>OpenCL"" # endif # if defined ( MAGICKCORE_OPENMP_SUPPORT ) ""<S2SV_blank>OpenMP"" # endif <S2SV_StartBug> ; <S2SV_EndBug> }","if defined ( MAGICKCORE_WINDOWS_SUPPORT ) && defined ( _DEBUG ) ""<S2SV_blank>Debug"" # endif # if defined ( MAGICKCORE_CIPHER_SUPPORT ) ""<S2SV_blank>Cipher"" <S2SV_ModEnd> # endif # <S2SV_ModStart> MAGICKCORE_HDRI_SUPPORT ) ""<S2SV_blank>HDRI"" # endif # if defined ( MAGICKCORE_BUILD_MODULES ) || defined ( _DLL ) ""<S2SV_blank>Modules"" <S2SV_ModStart> ""<S2SV_blank>OpenMP"" # endif # if defined ( ZERO_CONFIGURATION_SUPPORT ) ""<S2SV_blank>Zero-configuration"" # endif"
407,"static int protocol_client_msg ( VncState * vs , uint8_t * data , size_t len ) { int i ; uint16_t limit ; VncDisplay * vd = vs -> vd ; if ( data [ 0 ] > 3 ) { update_displaychangelistener ( & vd -> dcl , VNC_REFRESH_INTERVAL_BASE ) ; } switch ( data [ 0 ] ) { case VNC_MSG_CLIENT_SET_PIXEL_FORMAT : if ( len == 1 ) return 20 ; set_pixel_format ( vs , read_u8 ( data , 4 ) , read_u8 ( data , 5 ) , read_u8 ( data , 6 ) , read_u8 ( data , 7 ) , read_u16 ( data , 8 ) , read_u16 ( data , 10 ) , read_u16 ( data , 12 ) , read_u8 ( data , 14 ) , read_u8 ( data , 15 ) , read_u8 ( data , 16 ) ) ; break ; case VNC_MSG_CLIENT_SET_ENCODINGS : if ( len == 1 ) return 4 ; if ( len == 4 ) { limit = read_u16 ( data , 2 ) ; if ( limit > 0 ) return 4 + ( limit * 4 ) ; } else limit = read_u16 ( data , 2 ) ; for ( i = 0 ; i < limit ; i ++ ) { int32_t val = read_s32 ( data , 4 + ( i * 4 ) ) ; memcpy ( data + 4 + ( i * 4 ) , & val , sizeof ( val ) ) ; } set_encodings ( vs , ( int32_t * ) ( data + 4 ) , limit ) ; break ; case VNC_MSG_CLIENT_FRAMEBUFFER_UPDATE_REQUEST : if ( len == 1 ) return 10 ; framebuffer_update_request ( vs , read_u8 ( data , 1 ) , read_u16 ( data , 2 ) , read_u16 ( data , 4 ) , read_u16 ( data , 6 ) , read_u16 ( data , 8 ) ) ; break ; case VNC_MSG_CLIENT_KEY_EVENT : if ( len == 1 ) return 8 ; key_event ( vs , read_u8 ( data , 1 ) , read_u32 ( data , 4 ) ) ; break ; case VNC_MSG_CLIENT_POINTER_EVENT : if ( len == 1 ) return 6 ; pointer_event ( vs , read_u8 ( data , 1 ) , read_u16 ( data , 2 ) , read_u16 ( data , 4 ) ) ; break ; case VNC_MSG_CLIENT_CUT_TEXT : <S2SV_StartBug> if ( len == 1 ) <S2SV_EndBug> <S2SV_StartBug> return 8 ; <S2SV_EndBug> if ( len == 8 ) { <S2SV_StartBug> uint32_t dlen = read_u32 ( data , 4 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( dlen > 0 ) <S2SV_EndBug> <S2SV_StartBug> return 8 + dlen ; <S2SV_EndBug> } client_cut_text ( vs , read_u32 ( data , 4 ) , data + 8 ) ; break ; case VNC_MSG_CLIENT_QEMU : if ( len == 1 ) return 2 ; switch ( read_u8 ( data , 1 ) ) { case VNC_MSG_CLIENT_QEMU_EXT_KEY_EVENT : if ( len == 2 ) return 12 ; ext_key_event ( vs , read_u16 ( data , 2 ) , read_u32 ( data , 4 ) , read_u32 ( data , 8 ) ) ; break ; case VNC_MSG_CLIENT_QEMU_AUDIO : if ( len == 2 ) return 4 ; switch ( read_u16 ( data , 2 ) ) { case VNC_MSG_CLIENT_QEMU_AUDIO_ENABLE : audio_add ( vs ) ; break ; case VNC_MSG_CLIENT_QEMU_AUDIO_DISABLE : audio_del ( vs ) ; break ; case VNC_MSG_CLIENT_QEMU_AUDIO_SET_FORMAT : if ( len == 4 ) return 10 ; switch ( read_u8 ( data , 4 ) ) { case 0 : vs -> as . fmt = AUD_FMT_U8 ; break ; case 1 : vs -> as . fmt = AUD_FMT_S8 ; break ; case 2 : vs -> as . fmt = AUD_FMT_U16 ; break ; case 3 : vs -> as . fmt = AUD_FMT_S16 ; break ; case 4 : vs -> as . fmt = AUD_FMT_U32 ; break ; case 5 : vs -> as . fmt = AUD_FMT_S32 ; break ; default : printf ( ""Invalid<S2SV_blank>audio<S2SV_blank>format<S2SV_blank>%d\\n"" , read_u8 ( data , 4 ) ) ; vnc_client_error ( vs ) ; break ; } vs -> as . nchannels = read_u8 ( data , 5 ) ; if ( vs -> as . nchannels != 1 && vs -> as . nchannels != 2 ) { printf ( ""Invalid<S2SV_blank>audio<S2SV_blank>channel<S2SV_blank>coount<S2SV_blank>%d\\n"" , read_u8 ( data , 5 ) ) ; vnc_client_error ( vs ) ; break ; } vs -> as . freq = read_u32 ( data , 6 ) ; break ; default : printf ( ""Invalid<S2SV_blank>audio<S2SV_blank>message<S2SV_blank>%d\\n"" , read_u8 ( data , 4 ) ) ; vnc_client_error ( vs ) ; break ; } break ; default : printf ( ""Msg:<S2SV_blank>%d\\n"" , read_u16 ( data , 0 ) ) ; vnc_client_error ( vs ) ; break ; } break ; default : printf ( ""Msg:<S2SV_blank>%d\\n"" , data [ 0 ] ) ; vnc_client_error ( vs ) ; break ; } vnc_read_when ( vs , protocol_client_msg , 1 ) ; return 0 ; }","== 1 ) { <S2SV_ModStart> return 8 ; } <S2SV_ModStart> 4 ) ; if ( dlen > ( 1 << 20 ) ) { error_report ( ""vnc:<S2SV_blank>client_cut_text<S2SV_blank>msg<S2SV_blank>payload<S2SV_blank>has<S2SV_blank>%u<S2SV_blank>bytes"" ""<S2SV_blank>which<S2SV_blank>exceeds<S2SV_blank>our<S2SV_blank>limit<S2SV_blank>of<S2SV_blank>1MB."" , dlen ) ; vnc_client_error ( vs ) ; break ; } <S2SV_ModStart> > 0 ) { <S2SV_ModStart> + dlen ; }"
408,"static void print_attr_string ( netdissect_options * ndo , register const u_char * data , u_int length , u_short attr_code ) { register u_int i ; ND_TCHECK2 ( data [ 0 ] , length ) ; switch ( attr_code ) { case TUNNEL_PASS : if ( length < 3 ) <S2SV_StartBug> { <S2SV_EndBug> ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; return ; } if ( * data && ( * data <= 0x1F ) ) ND_PRINT ( ( ndo , ""Tag[%u]<S2SV_blank>"" , * data ) ) ; else ND_PRINT ( ( ndo , ""Tag[Unused]<S2SV_blank>"" ) ) ; data ++ ; length -- ; ND_PRINT ( ( ndo , ""Salt<S2SV_blank>%u<S2SV_blank>"" , EXTRACT_16BITS ( data ) ) ) ; data += 2 ; length -= 2 ; break ; case TUNNEL_CLIENT_END : case TUNNEL_SERVER_END : case TUNNEL_PRIV_GROUP : case TUNNEL_ASSIGN_ID : case TUNNEL_CLIENT_AUTH : case TUNNEL_SERVER_AUTH : if ( * data <= 0x1F ) { if ( length < 1 ) <S2SV_StartBug> { <S2SV_EndBug> ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; return ; } if ( * data ) ND_PRINT ( ( ndo , ""Tag[%u]<S2SV_blank>"" , * data ) ) ; else ND_PRINT ( ( ndo , ""Tag[Unused]<S2SV_blank>"" ) ) ; data ++ ; length -- ; } break ; <S2SV_StartBug> case EGRESS_VLAN_NAME : <S2SV_EndBug> ND_PRINT ( ( ndo , ""%s<S2SV_blank>(0x%02x)<S2SV_blank>"" , tok2str ( rfc4675_tagged , ""Unknown<S2SV_blank>tag"" , * data ) , * data ) ) ; data ++ ; length -- ; break ; } <S2SV_StartBug> for ( i = 0 ; * data && i < length ; i ++ , data ++ ) <S2SV_EndBug> ND_PRINT ( ( ndo , ""%c"" , ( * data < 32 || * data > 126 ) ? '.' : * data ) ) ; return ; trunc : ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; }","< 3 ) goto trunc ; <S2SV_ModEnd> if ( * <S2SV_ModStart> < 1 ) goto trunc ; if ( * data ) ND_PRINT ( ( ndo , ""Tag[%u]<S2SV_blank>"" , * data ) ) ; else ND_PRINT ( ( ndo , ""Tag[Unused]<S2SV_blank>"" ) ) ; data ++ ; length -- ; } <S2SV_ModEnd> break ; case <S2SV_ModStart> case EGRESS_VLAN_NAME : if ( length < 1 ) goto trunc ; <S2SV_ModStart> = 0 ; i < length && * data <S2SV_ModEnd> ; i ++"
409,"int ssl3_accept ( SSL * s ) { BUF_MEM * buf ; unsigned long alg_k , Time = ( unsigned long ) time ( NULL ) ; void ( * cb ) ( const SSL * ssl , int type , int val ) = NULL ; int ret = - 1 ; int new_state , state , skip = 0 ; RAND_add ( & Time , sizeof ( Time ) , 0 ) ; ERR_clear_error ( ) ; clear_sys_error ( ) ; if ( s -> info_callback != NULL ) cb = s -> info_callback ; else if ( s -> ctx -> info_callback != NULL ) cb = s -> ctx -> info_callback ; s -> in_handshake ++ ; if ( ! SSL_in_init ( s ) || SSL_in_before ( s ) ) SSL_clear ( s ) ; if ( s -> cert == NULL ) { SSLerr ( SSL_F_SSL3_ACCEPT , SSL_R_NO_CERTIFICATE_SET ) ; return ( - 1 ) ; } # ifndef OPENSSL_NO_HEARTBEATS if ( s -> tlsext_hb_pending ) { s -> tlsext_hb_pending = 0 ; s -> tlsext_hb_seq ++ ; } # endif for ( ; ; ) { state = s -> state ; switch ( s -> state ) { case SSL_ST_RENEGOTIATE : s -> renegotiate = 1 ; case SSL_ST_BEFORE : case SSL_ST_ACCEPT : case SSL_ST_BEFORE | SSL_ST_ACCEPT : case SSL_ST_OK | SSL_ST_ACCEPT : s -> server = 1 ; if ( cb != NULL ) cb ( s , SSL_CB_HANDSHAKE_START , 1 ) ; if ( ( s -> version >> 8 ) != 3 ) { SSLerr ( SSL_F_SSL3_ACCEPT , ERR_R_INTERNAL_ERROR ) ; return - 1 ; } if ( ! ssl_security ( s , SSL_SECOP_VERSION , 0 , s -> version , NULL ) ) { SSLerr ( SSL_F_SSL3_ACCEPT , SSL_R_VERSION_TOO_LOW ) ; return - 1 ; } s -> type = SSL_ST_ACCEPT ; if ( s -> init_buf == NULL ) { if ( ( buf = BUF_MEM_new ( ) ) == NULL ) { ret = - 1 ; goto end ; } if ( ! BUF_MEM_grow ( buf , SSL3_RT_MAX_PLAIN_LENGTH ) ) { BUF_MEM_free ( buf ) ; ret = - 1 ; goto end ; } s -> init_buf = buf ; } if ( ! ssl3_setup_buffers ( s ) ) { ret = - 1 ; goto end ; } s -> init_num = 0 ; s -> s3 -> flags &= ~ TLS1_FLAGS_SKIP_CERT_VERIFY ; s -> s3 -> flags &= ~ SSL3_FLAGS_CCS_OK ; s -> s3 -> change_cipher_spec = 0 ; if ( s -> state != SSL_ST_RENEGOTIATE ) { if ( ! ssl_init_wbio_buffer ( s , 1 ) ) { ret = - 1 ; goto end ; } ssl3_init_finished_mac ( s ) ; s -> state = SSL3_ST_SR_CLNT_HELLO_A ; s -> ctx -> stats . sess_accept ++ ; } else if ( ! s -> s3 -> send_connection_binding && ! ( s -> options & SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION ) ) { SSLerr ( SSL_F_SSL3_ACCEPT , SSL_R_UNSAFE_LEGACY_RENEGOTIATION_DISABLED ) ; ssl3_send_alert ( s , SSL3_AL_FATAL , SSL_AD_HANDSHAKE_FAILURE ) ; ret = - 1 ; goto end ; } else { s -> ctx -> stats . sess_accept_renegotiate ++ ; s -> state = SSL3_ST_SW_HELLO_REQ_A ; } break ; case SSL3_ST_SW_HELLO_REQ_A : case SSL3_ST_SW_HELLO_REQ_B : s -> shutdown = 0 ; ret = ssl3_send_hello_request ( s ) ; if ( ret <= 0 ) goto end ; s -> s3 -> tmp . next_state = SSL3_ST_SW_HELLO_REQ_C ; s -> state = SSL3_ST_SW_FLUSH ; s -> init_num = 0 ; ssl3_init_finished_mac ( s ) ; break ; case SSL3_ST_SW_HELLO_REQ_C : s -> state = SSL_ST_OK ; break ; case SSL3_ST_SR_CLNT_HELLO_A : case SSL3_ST_SR_CLNT_HELLO_B : case SSL3_ST_SR_CLNT_HELLO_C : ret = ssl3_get_client_hello ( s ) ; if ( ret <= 0 ) goto end ; # ifndef OPENSSL_NO_SRP s -> state = SSL3_ST_SR_CLNT_HELLO_D ; case SSL3_ST_SR_CLNT_HELLO_D : { int al ; if ( ( ret = ssl_check_srp_ext_ClientHello ( s , & al ) ) < 0 ) { s -> rwstate = SSL_X509_LOOKUP ; goto end ; } if ( ret != SSL_ERROR_NONE ) { ssl3_send_alert ( s , SSL3_AL_FATAL , al ) ; if ( al != TLS1_AD_UNKNOWN_PSK_IDENTITY ) SSLerr ( SSL_F_SSL3_ACCEPT , SSL_R_CLIENTHELLO_TLSEXT ) ; ret = SSL_TLSEXT_ERR_ALERT_FATAL ; ret = - 1 ; goto end ; } } # endif s -> renegotiate = 2 ; s -> state = SSL3_ST_SW_SRVR_HELLO_A ; s -> init_num = 0 ; break ; case SSL3_ST_SW_SRVR_HELLO_A : case SSL3_ST_SW_SRVR_HELLO_B : ret = ssl3_send_server_hello ( s ) ; if ( ret <= 0 ) goto end ; # ifndef OPENSSL_NO_TLSEXT if ( s -> hit ) { if ( s -> tlsext_ticket_expected ) s -> state = SSL3_ST_SW_SESSION_TICKET_A ; else s -> state = SSL3_ST_SW_CHANGE_A ; } # else if ( s -> hit ) s -> state = SSL3_ST_SW_CHANGE_A ; # endif else s -> state = SSL3_ST_SW_CERT_A ; s -> init_num = 0 ; break ; case SSL3_ST_SW_CERT_A : case SSL3_ST_SW_CERT_B : if ( ! ( s -> s3 -> tmp . new_cipher -> algorithm_auth & ( SSL_aNULL | SSL_aKRB5 | SSL_aSRP ) ) && ! ( s -> s3 -> tmp . new_cipher -> algorithm_mkey & SSL_kPSK ) ) { ret = ssl3_send_server_certificate ( s ) ; if ( ret <= 0 ) goto end ; # ifndef OPENSSL_NO_TLSEXT if ( s -> tlsext_status_expected ) s -> state = SSL3_ST_SW_CERT_STATUS_A ; else s -> state = SSL3_ST_SW_KEY_EXCH_A ; } else { skip = 1 ; s -> state = SSL3_ST_SW_KEY_EXCH_A ; } # else } else skip = 1 ; s -> state = SSL3_ST_SW_KEY_EXCH_A ; # endif s -> init_num = 0 ; break ; case SSL3_ST_SW_KEY_EXCH_A : case SSL3_ST_SW_KEY_EXCH_B : alg_k = s -> s3 -> tmp . new_cipher -> algorithm_mkey ; <S2SV_StartBug> if ( ( s -> options & SSL_OP_EPHEMERAL_RSA ) <S2SV_EndBug> # ifndef OPENSSL_NO_KRB5 && ! ( alg_k & SSL_kKRB5 ) # endif ) <S2SV_StartBug> s -> s3 -> tmp . use_rsa_tmp = 1 ; <S2SV_EndBug> else s -> s3 -> tmp . use_rsa_tmp = 0 ; if ( s -> s3 -> tmp . use_rsa_tmp # ifndef OPENSSL_NO_PSK || ( ( alg_k & SSL_kPSK ) && s -> ctx -> psk_identity_hint ) # endif # ifndef OPENSSL_NO_SRP || ( alg_k & SSL_kSRP ) # endif || ( alg_k & SSL_kDHE ) || ( alg_k & SSL_kECDHE ) || ( ( alg_k & SSL_kRSA ) && ( s -> cert -> pkeys [ SSL_PKEY_RSA_ENC ] . privatekey == NULL || ( SSL_C_IS_EXPORT ( s -> s3 -> tmp . new_cipher ) && EVP_PKEY_size ( s -> cert -> pkeys [ SSL_PKEY_RSA_ENC ] . privatekey ) * 8 > SSL_C_EXPORT_PKEYLENGTH ( s -> s3 -> tmp . new_cipher ) ) ) ) ) { ret = ssl3_send_server_key_exchange ( s ) ; if ( ret <= 0 ) goto end ; } else skip = 1 ; s -> state = SSL3_ST_SW_CERT_REQ_A ; s -> init_num = 0 ; break ; case SSL3_ST_SW_CERT_REQ_A : case SSL3_ST_SW_CERT_REQ_B : if ( ! ( s -> verify_mode & SSL_VERIFY_PEER ) || ( ( s -> session -> peer != NULL ) && ( s -> verify_mode & SSL_VERIFY_CLIENT_ONCE ) ) || ( ( s -> s3 -> tmp . new_cipher -> algorithm_auth & SSL_aNULL ) && ! ( s -> verify_mode & SSL_VERIFY_FAIL_IF_NO_PEER_CERT ) ) || ( s -> s3 -> tmp . new_cipher -> algorithm_auth & SSL_aKRB5 ) || ( s -> s3 -> tmp . new_cipher -> algorithm_auth & SSL_aSRP ) || ( s -> s3 -> tmp . new_cipher -> algorithm_mkey & SSL_kPSK ) ) { skip = 1 ; s -> s3 -> tmp . cert_request = 0 ; s -> state = SSL3_ST_SW_SRVR_DONE_A ; if ( s -> s3 -> handshake_buffer ) if ( ! ssl3_digest_cached_records ( s ) ) return - 1 ; } else { s -> s3 -> tmp . cert_request = 1 ; ret = ssl3_send_certificate_request ( s ) ; if ( ret <= 0 ) goto end ; # ifndef NETSCAPE_HANG_BUG s -> state = SSL3_ST_SW_SRVR_DONE_A ; # else s -> state = SSL3_ST_SW_FLUSH ; s -> s3 -> tmp . next_state = SSL3_ST_SR_CERT_A ; # endif s -> init_num = 0 ; } break ; case SSL3_ST_SW_SRVR_DONE_A : case SSL3_ST_SW_SRVR_DONE_B : ret = ssl3_send_server_done ( s ) ; if ( ret <= 0 ) goto end ; s -> s3 -> tmp . next_state = SSL3_ST_SR_CERT_A ; s -> state = SSL3_ST_SW_FLUSH ; s -> init_num = 0 ; break ; case SSL3_ST_SW_FLUSH : s -> rwstate = SSL_WRITING ; if ( BIO_flush ( s -> wbio ) <= 0 ) { ret = - 1 ; goto end ; } s -> rwstate = SSL_NOTHING ; s -> state = s -> s3 -> tmp . next_state ; break ; case SSL3_ST_SR_CERT_A : case SSL3_ST_SR_CERT_B : if ( s -> s3 -> tmp . cert_request ) { ret = ssl3_get_client_certificate ( s ) ; if ( ret <= 0 ) goto end ; } s -> init_num = 0 ; s -> state = SSL3_ST_SR_KEY_EXCH_A ; break ; case SSL3_ST_SR_KEY_EXCH_A : case SSL3_ST_SR_KEY_EXCH_B : ret = ssl3_get_client_key_exchange ( s ) ; if ( ret <= 0 ) goto end ; if ( ret == 2 ) { # if defined ( OPENSSL_NO_TLSEXT ) || defined ( OPENSSL_NO_NEXTPROTONEG ) s -> state = SSL3_ST_SR_FINISHED_A ; # else if ( s -> s3 -> next_proto_neg_seen ) s -> state = SSL3_ST_SR_NEXT_PROTO_A ; else s -> state = SSL3_ST_SR_FINISHED_A ; # endif s -> init_num = 0 ; } else if ( SSL_USE_SIGALGS ( s ) ) { s -> state = SSL3_ST_SR_CERT_VRFY_A ; s -> init_num = 0 ; if ( ! s -> session -> peer ) break ; if ( ! s -> s3 -> handshake_buffer ) { SSLerr ( SSL_F_SSL3_ACCEPT , ERR_R_INTERNAL_ERROR ) ; return - 1 ; } s -> s3 -> flags |= TLS1_FLAGS_KEEP_HANDSHAKE ; if ( ! ssl3_digest_cached_records ( s ) ) return - 1 ; } else { int offset = 0 ; int dgst_num ; s -> state = SSL3_ST_SR_CERT_VRFY_A ; s -> init_num = 0 ; if ( s -> s3 -> handshake_buffer ) if ( ! ssl3_digest_cached_records ( s ) ) return - 1 ; for ( dgst_num = 0 ; dgst_num < SSL_MAX_DIGEST ; dgst_num ++ ) if ( s -> s3 -> handshake_dgst [ dgst_num ] ) { int dgst_size ; s -> method -> ssl3_enc -> cert_verify_mac ( s , EVP_MD_CTX_type ( s -> s3 -> handshake_dgst [ dgst_num ] ) , & ( s -> s3 -> tmp . cert_verify_md [ offset ] ) ) ; dgst_size = EVP_MD_CTX_size ( s -> s3 -> handshake_dgst [ dgst_num ] ) ; if ( dgst_size < 0 ) { ret = - 1 ; goto end ; } offset += dgst_size ; } } break ; case SSL3_ST_SR_CERT_VRFY_A : case SSL3_ST_SR_CERT_VRFY_B : if ( ! s -> s3 -> change_cipher_spec ) s -> s3 -> flags |= SSL3_FLAGS_CCS_OK ; ret = ssl3_get_cert_verify ( s ) ; if ( ret <= 0 ) goto end ; # if defined ( OPENSSL_NO_TLSEXT ) || defined ( OPENSSL_NO_NEXTPROTONEG ) s -> state = SSL3_ST_SR_FINISHED_A ; # else if ( s -> s3 -> next_proto_neg_seen ) s -> state = SSL3_ST_SR_NEXT_PROTO_A ; else s -> state = SSL3_ST_SR_FINISHED_A ; # endif s -> init_num = 0 ; break ; # if ! defined ( OPENSSL_NO_TLSEXT ) && ! defined ( OPENSSL_NO_NEXTPROTONEG ) case SSL3_ST_SR_NEXT_PROTO_A : case SSL3_ST_SR_NEXT_PROTO_B : if ( ! s -> s3 -> change_cipher_spec ) s -> s3 -> flags |= SSL3_FLAGS_CCS_OK ; ret = ssl3_get_next_proto ( s ) ; if ( ret <= 0 ) goto end ; s -> init_num = 0 ; s -> state = SSL3_ST_SR_FINISHED_A ; break ; # endif case SSL3_ST_SR_FINISHED_A : case SSL3_ST_SR_FINISHED_B : if ( ! s -> s3 -> change_cipher_spec ) s -> s3 -> flags |= SSL3_FLAGS_CCS_OK ; ret = ssl3_get_finished ( s , SSL3_ST_SR_FINISHED_A , SSL3_ST_SR_FINISHED_B ) ; if ( ret <= 0 ) goto end ; if ( s -> hit ) s -> state = SSL_ST_OK ; # ifndef OPENSSL_NO_TLSEXT else if ( s -> tlsext_ticket_expected ) s -> state = SSL3_ST_SW_SESSION_TICKET_A ; # endif else s -> state = SSL3_ST_SW_CHANGE_A ; s -> init_num = 0 ; break ; # ifndef OPENSSL_NO_TLSEXT case SSL3_ST_SW_SESSION_TICKET_A : case SSL3_ST_SW_SESSION_TICKET_B : ret = ssl3_send_newsession_ticket ( s ) ; if ( ret <= 0 ) goto end ; s -> state = SSL3_ST_SW_CHANGE_A ; s -> init_num = 0 ; break ; case SSL3_ST_SW_CERT_STATUS_A : case SSL3_ST_SW_CERT_STATUS_B : ret = ssl3_send_cert_status ( s ) ; if ( ret <= 0 ) goto end ; s -> state = SSL3_ST_SW_KEY_EXCH_A ; s -> init_num = 0 ; break ; # endif case SSL3_ST_SW_CHANGE_A : case SSL3_ST_SW_CHANGE_B : s -> session -> cipher = s -> s3 -> tmp . new_cipher ; if ( ! s -> method -> ssl3_enc -> setup_key_block ( s ) ) { ret = - 1 ; goto end ; } ret = ssl3_send_change_cipher_spec ( s , SSL3_ST_SW_CHANGE_A , SSL3_ST_SW_CHANGE_B ) ; if ( ret <= 0 ) goto end ; s -> state = SSL3_ST_SW_FINISHED_A ; s -> init_num = 0 ; if ( ! s -> method -> ssl3_enc -> change_cipher_state ( s , SSL3_CHANGE_CIPHER_SERVER_WRITE ) ) { ret = - 1 ; goto end ; } break ; case SSL3_ST_SW_FINISHED_A : case SSL3_ST_SW_FINISHED_B : ret = ssl3_send_finished ( s , SSL3_ST_SW_FINISHED_A , SSL3_ST_SW_FINISHED_B , s -> method -> ssl3_enc -> server_finished_label , s -> method -> ssl3_enc -> server_finished_label_len ) ; if ( ret <= 0 ) goto end ; s -> state = SSL3_ST_SW_FLUSH ; if ( s -> hit ) { # if defined ( OPENSSL_NO_TLSEXT ) || defined ( OPENSSL_NO_NEXTPROTONEG ) s -> s3 -> tmp . next_state = SSL3_ST_SR_FINISHED_A ; # else if ( s -> s3 -> next_proto_neg_seen ) { s -> s3 -> tmp . next_state = SSL3_ST_SR_NEXT_PROTO_A ; } else s -> s3 -> tmp . next_state = SSL3_ST_SR_FINISHED_A ; # endif } else s -> s3 -> tmp . next_state = SSL_ST_OK ; s -> init_num = 0 ; break ; case SSL_ST_OK : ssl3_cleanup_key_block ( s ) ; BUF_MEM_free ( s -> init_buf ) ; s -> init_buf = NULL ; ssl_free_wbio_buffer ( s ) ; s -> init_num = 0 ; if ( s -> renegotiate == 2 ) { s -> renegotiate = 0 ; s -> new_session = 0 ; ssl_update_cache ( s , SSL_SESS_CACHE_SERVER ) ; s -> ctx -> stats . sess_accept_good ++ ; s -> handshake_func = ssl3_accept ; if ( cb != NULL ) cb ( s , SSL_CB_HANDSHAKE_DONE , 1 ) ; } ret = 1 ; goto end ; default : SSLerr ( SSL_F_SSL3_ACCEPT , SSL_R_UNKNOWN_STATE ) ; ret = - 1 ; goto end ; } if ( ! s -> s3 -> tmp . reuse_message && ! skip ) { if ( s -> debug ) { if ( ( ret = BIO_flush ( s -> wbio ) ) <= 0 ) goto end ; } if ( ( cb != NULL ) && ( s -> state != state ) ) { new_state = s -> state ; s -> state = state ; cb ( s , SSL_CB_ACCEPT_LOOP , 1 ) ; s -> state = new_state ; } } skip = 0 ; } end : s -> in_handshake -- ; if ( cb != NULL ) cb ( s , SSL_CB_ACCEPT_EXIT , ret ) ; return ( ret ) ; }",-> algorithm_mkey ; <S2SV_ModEnd> s -> s3 <S2SV_ModStart> . use_rsa_tmp = 0 ; if ( <S2SV_ModEnd> # ifndef OPENSSL_NO_PSK
410,"void vqp_print ( netdissect_options * ndo , register const u_char * pptr , register u_int len ) { const struct vqp_common_header_t * vqp_common_header ; const struct vqp_obj_tlv_t * vqp_obj_tlv ; const u_char * tptr ; uint16_t vqp_obj_len ; uint32_t vqp_obj_type ; <S2SV_StartBug> int tlen ; <S2SV_EndBug> uint8_t nitems ; tptr = pptr ; tlen = len ; vqp_common_header = ( const struct vqp_common_header_t * ) pptr ; <S2SV_StartBug> ND_TCHECK ( * vqp_common_header ) ; <S2SV_EndBug> if ( VQP_EXTRACT_VERSION ( vqp_common_header -> version ) != VQP_VERSION ) { ND_PRINT ( ( ndo , ""VQP<S2SV_blank>version<S2SV_blank>%u<S2SV_blank>packet<S2SV_blank>not<S2SV_blank>supported"" , VQP_EXTRACT_VERSION ( vqp_common_header -> version ) ) ) ; return ; } if ( ndo -> ndo_vflag < 1 ) { ND_PRINT ( ( ndo , ""VQPv%u<S2SV_blank>%s<S2SV_blank>Message,<S2SV_blank>error-code<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>length<S2SV_blank>%u"" , VQP_EXTRACT_VERSION ( vqp_common_header -> version ) , tok2str ( vqp_msg_type_values , ""unknown<S2SV_blank>(%u)"" , vqp_common_header -> msg_type ) , tok2str ( vqp_error_code_values , ""unknown<S2SV_blank>(%u)"" , vqp_common_header -> error_code ) , vqp_common_header -> error_code , len ) ) ; return ; } nitems = vqp_common_header -> nitems ; ND_PRINT ( ( ndo , ""\\n\\tVQPv%u,<S2SV_blank>%s<S2SV_blank>Message,<S2SV_blank>error-code<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>seq<S2SV_blank>0x%08x,<S2SV_blank>items<S2SV_blank>%u,<S2SV_blank>length<S2SV_blank>%u"" , VQP_EXTRACT_VERSION ( vqp_common_header -> version ) , tok2str ( vqp_msg_type_values , ""unknown<S2SV_blank>(%u)"" , vqp_common_header -> msg_type ) , tok2str ( vqp_error_code_values , ""unknown<S2SV_blank>(%u)"" , vqp_common_header -> error_code ) , vqp_common_header -> error_code , EXTRACT_32BITS ( & vqp_common_header -> sequence ) , nitems , len ) ) ; tptr += sizeof ( const struct vqp_common_header_t ) ; tlen -= sizeof ( const struct vqp_common_header_t ) ; while ( nitems > 0 && tlen > 0 ) { vqp_obj_tlv = ( const struct vqp_obj_tlv_t * ) tptr ; <S2SV_StartBug> vqp_obj_type = EXTRACT_32BITS ( vqp_obj_tlv -> obj_type ) ; <S2SV_EndBug> vqp_obj_len = EXTRACT_16BITS ( vqp_obj_tlv -> obj_length ) ; tptr += sizeof ( struct vqp_obj_tlv_t ) ; tlen -= sizeof ( struct vqp_obj_tlv_t ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Object<S2SV_blank>(0x%08x),<S2SV_blank>length<S2SV_blank>%u,<S2SV_blank>value:<S2SV_blank>"" , tok2str ( vqp_obj_values , ""Unknown"" , vqp_obj_type ) , vqp_obj_type , vqp_obj_len ) ) ; if ( vqp_obj_type == 0 || vqp_obj_len == 0 ) { return ; } ND_TCHECK2 ( * tptr , vqp_obj_len ) ; <S2SV_StartBug> switch ( vqp_obj_type ) { <S2SV_EndBug> case VQP_OBJ_IP_ADDRESS : <S2SV_StartBug> ND_PRINT ( ( ndo , ""%s<S2SV_blank>(0x%08x)"" , ipaddr_string ( ndo , tptr ) , EXTRACT_32BITS ( tptr ) ) ) ; <S2SV_EndBug> break ; case VQP_OBJ_PORT_NAME : case VQP_OBJ_VLAN_NAME : case VQP_OBJ_VTP_DOMAIN : case VQP_OBJ_ETHERNET_PKT : safeputs ( ndo , tptr , vqp_obj_len ) ; break ; case VQP_OBJ_MAC_ADDRESS : <S2SV_StartBug> case VQP_OBJ_MAC_NULL : <S2SV_EndBug> ND_PRINT ( ( ndo , ""%s"" , etheraddr_string ( ndo , tptr ) ) ) ; break ; default : if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , vqp_obj_len ) ; break ; } tptr += vqp_obj_len ; tlen -= vqp_obj_len ; nitems -- ; } return ; trunc : ND_PRINT ( ( ndo , ""\\n\\t[|VQP]"" ) ) ; }",uint32_t vqp_obj_type ; u_int <S2SV_ModEnd> tlen ; uint8_t <S2SV_ModStart> * vqp_common_header ) ; if ( sizeof ( struct vqp_common_header_t ) > tlen ) goto trunc <S2SV_ModStart> ) tptr ; ND_TCHECK ( * vqp_obj_tlv ) ; if ( sizeof ( struct vqp_obj_tlv_t ) > tlen ) goto trunc ; <S2SV_ModStart> vqp_obj_len ) ; if ( vqp_obj_len > tlen ) goto trunc ; <S2SV_ModStart> case VQP_OBJ_IP_ADDRESS : if ( vqp_obj_len != 4 ) goto trunc ; <S2SV_ModStart> case VQP_OBJ_MAC_NULL : if ( vqp_obj_len != ETHER_ADDR_LEN ) goto trunc ;
411,"<S2SV_StartBug> TPM_RC tpm_kdfa ( TSS2_SYS_CONTEXT * sapi_context , TPMI_ALG_HASH hashAlg , <S2SV_EndBug> TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { <S2SV_StartBug> TPM2B_DIGEST tmpResult ; <S2SV_EndBug> TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; <S2SV_StartBug> TPM_RC rval ; <S2SV_EndBug> int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; <S2SV_StartBug> while ( resultKey -> t . size < bytes ) <S2SV_EndBug> { <S2SV_StartBug> i_Swizzled = string_bytes_endian_convert_32 ( i ) ; <S2SV_EndBug> * ( UINT32 * ) tpm2b_i_2Ptr = i_Swizzled ; j = 0 ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2b_i_2 . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bLabel . b ) ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextU ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) contextV ; bufferList [ j ++ ] = ( TPM2B_DIGEST * ) & ( tpm2bBits . b ) ; <S2SV_StartBug> bufferList [ j ++ ] = ( TPM2B_DIGEST * ) 0 ; <S2SV_EndBug> <S2SV_StartBug> rval = tpm_hmac ( sapi_context , hashAlg , key , ( TPM2B * * ) & ( bufferList [ 0 ] ) , & tmpResult ) ; <S2SV_EndBug> <S2SV_StartBug> if ( rval != TPM_RC_SUCCESS ) <S2SV_EndBug> { return ( rval ) ; } bool res = string_bytes_concat_buffer ( resultKey , & ( tmpResult . b ) ) ; if ( ! res ) { <S2SV_StartBug> return TSS2_SYS_RC_BAD_VALUE ; <S2SV_EndBug> } } resultKey -> t . size = bytes ; return TPM_RC_SUCCESS ; }","TPM_RC tpm_kdfa ( <S2SV_ModEnd> TPMI_ALG_HASH hashAlg , <S2SV_ModStart> ) { TPM2B_DIGEST <S2SV_ModEnd> tpm2bLabel , tpm2bBits <S2SV_ModStart> ; TPM_RC rval = TPM_RC_SUCCESS <S2SV_ModStart> = 1 ; const EVP_MD * md = tpm_algorithm_to_openssl_digest ( hashAlg ) ; if ( ! md ) { LOG_ERR ( ""Algorithm<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>for<S2SV_blank>hmac:<S2SV_blank>%x"" , hashAlg ) ; return TPM_RC_HASH ; } HMAC_CTX ctx ; HMAC_CTX_init ( & ctx ) ; int rc = HMAC_Init_ex ( & ctx , key -> buffer , key -> size , md , NULL ) ; if ( ! rc ) { LOG_ERR ( ""HMAC<S2SV_blank>Init<S2SV_blank>failed:<S2SV_blank>%s"" , ERR_error_string ( rc , NULL ) ) ; return TPM_RC_MEMORY ; } <S2SV_ModStart> bytes ) { TPM2B_DIGEST tmpResult ; <S2SV_ModStart> bufferList [ j ] = ( TPM2B_DIGEST * ) 0 ; int c ; for ( c = 0 ; c < j ; c ++ ) { TPM2B_DIGEST * digest = bufferList [ c ] ; int rc = HMAC_Update ( & ctx , digest -> b . buffer , digest -> b . size ) ; if ( ! rc ) { LOG_ERR ( ""HMAC<S2SV_blank>Update<S2SV_blank>failed:<S2SV_blank>%s"" , ERR_error_string ( rc , NULL ) ) <S2SV_ModEnd> ; rval = <S2SV_ModStart> ; rval = TPM_RC_MEMORY ; goto err ; } } unsigned size = sizeof ( tmpResult . t . buffer ) ; int rc = HMAC_Final ( & ctx , tmpResult . t . buffer , & size <S2SV_ModEnd> ) ; if <S2SV_ModStart> ; if ( ! rc ) { LOG_ERR ( ""HMAC<S2SV_blank>Final<S2SV_blank>failed:<S2SV_blank>%s"" , ERR_error_string ( rc , NULL ) ) ; rval = TPM_RC_MEMORY ; goto err ; } tmpResult . t . size = size ; <S2SV_ModEnd> bool res = <S2SV_ModStart> res ) { rval = TSS2_SYS_RC_BAD_VALUE ; goto err ; } } resultKey -> t . size = bytes ; err : HMAC_CTX_cleanup ( & ctx ) ; return rval <S2SV_ModEnd> ; } <S2SV_null>"
412,"static const u_char * ikev2_ke_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep _U_ , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct ikev2_ke ke ; const struct ikev2_ke * k ; k = ( const struct ikev2_ke * ) ext ; <S2SV_StartBug> ND_TCHECK ( * ext ) ; <S2SV_EndBug> UNALIGNED_MEMCPY ( & ke , ext , sizeof ( ke ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , ke . h . critical ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>len=%u<S2SV_blank>group=%s"" , ntohs ( ke . h . len ) - 8 , STR_OR_ID ( ntohs ( ke . ke_group ) , dh_p_map ) ) ) ; if ( 2 < ndo -> ndo_vflag && 8 < ntohs ( ke . h . len ) ) { ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( k + 1 ) , ntohs ( ke . h . len ) - 8 ) ) goto trunc ; } return ( const u_char * ) ext + ntohs ( ke . h . len ) ; trunc : ND_PRINT ( ( ndo , ""<S2SV_blank>[|%s]"" , NPSTR ( tpay ) ) ) ; return NULL ; }",ND_TCHECK ( * k <S2SV_ModEnd> ) ; UNALIGNED_MEMCPY
413,"static int udf_encode_fh ( struct inode * inode , __u32 * fh , int * lenp , struct inode * parent ) { int len = * lenp ; struct kernel_lb_addr location = UDF_I ( inode ) -> i_location ; struct fid * fid = ( struct fid * ) fh ; int type = FILEID_UDF_WITHOUT_PARENT ; if ( parent && ( len < 5 ) ) { * lenp = 5 ; return 255 ; } else if ( len < 3 ) { * lenp = 3 ; return 255 ; } * lenp = 3 ; fid -> udf . block = location . logicalBlockNum ; fid -> udf . partref = location . partitionReferenceNum ; <S2SV_StartBug> fid -> udf . generation = inode -> i_generation ; <S2SV_EndBug> if ( parent ) { location = UDF_I ( parent ) -> i_location ; fid -> udf . parent_block = location . logicalBlockNum ; fid -> udf . parent_partref = location . partitionReferenceNum ; fid -> udf . parent_generation = inode -> i_generation ; * lenp = 5 ; type = FILEID_UDF_WITH_PARENT ; } return type ; }",-> udf . parent_partref = 0 ; fid -> udf .
414,"static int l2cap_sock_getname ( struct socket * sock , struct sockaddr * addr , int * len , int peer ) { struct sockaddr_l2 * la = ( struct sockaddr_l2 * ) addr ; struct sock * sk = sock -> sk ; struct l2cap_chan * chan = l2cap_pi ( sk ) -> chan ; <S2SV_StartBug> BT_DBG ( ""sock<S2SV_blank>%p,<S2SV_blank>sk<S2SV_blank>%p"" , sock , sk ) ; <S2SV_EndBug> addr -> sa_family = AF_BLUETOOTH ; * len = sizeof ( struct sockaddr_l2 ) ; if ( peer ) { la -> l2_psm = chan -> psm ; bacpy ( & la -> l2_bdaddr , & bt_sk ( sk ) -> dst ) ; la -> l2_cid = cpu_to_le16 ( chan -> dcid ) ; } else { la -> l2_psm = chan -> sport ; bacpy ( & la -> l2_bdaddr , & bt_sk ( sk ) -> src ) ; la -> l2_cid = cpu_to_le16 ( chan -> scid ) ; } return 0 ; }","sock , sk ) ; memset ( la , 0 , sizeof ( struct sockaddr_l2 )"
415,"static void start_auth_request ( PgSocket * client , const char * username ) { int res ; PktBuf * buf ; <S2SV_StartBug> client -> auth_user = client -> db -> auth_user ; <S2SV_EndBug> client -> pool = get_pool ( client -> db , client -> db -> auth_user ) ; if ( ! find_server ( client ) ) { client -> wait_for_user_conn = true ; return ; } slog_noise ( client , ""Doing<S2SV_blank>auth_conn<S2SV_blank>query"" ) ; client -> wait_for_user_conn = false ; client -> wait_for_user = true ; if ( ! sbuf_pause ( & client -> sbuf ) ) { release_server ( client -> link ) ; disconnect_client ( client , true , ""pause<S2SV_blank>failed"" ) ; return ; } client -> link -> ready = 0 ; res = 0 ; buf = pktbuf_dynamic ( 512 ) ; if ( buf ) { pktbuf_write_ExtQuery ( buf , cf_auth_query , 1 , username ) ; res = pktbuf_send_immediate ( buf , client -> link ) ; pktbuf_free ( buf ) ; } if ( ! res ) disconnect_server ( client -> link , false , ""unable<S2SV_blank>to<S2SV_blank>send<S2SV_blank>login<S2SV_blank>query"" ) ; }",; client -> <S2SV_ModEnd> pool = get_pool
416,"IV_API_CALL_STATUS_T impeg2d_api_entity ( iv_obj_t * ps_dechdl , void * pv_api_ip , void * pv_api_op ) { iv_obj_t * ps_dec_handle ; dec_state_t * ps_dec_state ; dec_state_multi_core_t * ps_dec_state_multi_core ; impeg2d_video_decode_ip_t * ps_dec_ip ; impeg2d_video_decode_op_t * ps_dec_op ; WORD32 bytes_remaining ; pic_buf_t * ps_disp_pic ; ps_dec_ip = ( impeg2d_video_decode_ip_t * ) pv_api_ip ; ps_dec_op = ( impeg2d_video_decode_op_t * ) pv_api_op ; memset ( ps_dec_op , 0 , sizeof ( impeg2d_video_decode_op_t ) ) ; ps_dec_op -> s_ivd_video_decode_op_t . u4_size = sizeof ( impeg2d_video_decode_op_t ) ; ps_dec_op -> s_ivd_video_decode_op_t . u4_output_present = 0 ; bytes_remaining = ps_dec_ip -> s_ivd_video_decode_ip_t . u4_num_Bytes ; ps_dec_handle = ( iv_obj_t * ) ps_dechdl ; if ( ps_dechdl == NULL ) { return ( IV_FAIL ) ; } ps_dec_state_multi_core = ps_dec_handle -> pv_codec_handle ; ps_dec_state = ps_dec_state_multi_core -> ps_dec_state [ 0 ] ; ps_dec_state -> ps_disp_frm_buf = & ( ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf ) ; if ( 0 == ps_dec_state -> u4_share_disp_buf ) { ps_dec_state -> ps_disp_frm_buf -> pv_y_buf = ps_dec_ip -> s_ivd_video_decode_ip_t . s_out_buffer . pu1_bufs [ 0 ] ; ps_dec_state -> ps_disp_frm_buf -> pv_u_buf = ps_dec_ip -> s_ivd_video_decode_ip_t . s_out_buffer . pu1_bufs [ 1 ] ; ps_dec_state -> ps_disp_frm_buf -> pv_v_buf = ps_dec_ip -> s_ivd_video_decode_ip_t . s_out_buffer . pu1_bufs [ 2 ] ; } ps_dec_state -> ps_disp_pic = NULL ; ps_dec_state -> i4_frame_decoded = 0 ; ps_dec_op -> s_ivd_video_decode_op_t . u4_num_bytes_consumed = 0 ; ps_dec_op -> s_ivd_video_decode_op_t . u4_error_code = IV_SUCCESS ; if ( ( ps_dec_ip -> s_ivd_video_decode_ip_t . pv_stream_buffer == NULL ) && ( ps_dec_state -> u1_flushfrm == 0 ) ) { ps_dec_op -> s_ivd_video_decode_op_t . u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM ; ps_dec_op -> s_ivd_video_decode_op_t . u4_error_code |= IVD_DEC_FRM_BS_BUF_NULL ; return IV_FAIL ; } if ( ps_dec_state -> u4_num_frames_decoded > NUM_FRAMES_LIMIT ) { ps_dec_op -> s_ivd_video_decode_op_t . u4_error_code = IMPEG2D_SAMPLE_VERSION_LIMIT_ERR ; return ( IV_FAIL ) ; } if ( ( ( 0 == ps_dec_state -> u2_header_done ) || ( ps_dec_state -> u2_decode_header == 1 ) ) && ( ps_dec_state -> u1_flushfrm == 0 ) ) { impeg2d_dec_hdr ( ps_dec_state , ps_dec_ip , ps_dec_op ) ; bytes_remaining -= ps_dec_op -> s_ivd_video_decode_op_t . u4_num_bytes_consumed ; } <S2SV_StartBug> if ( ( 1 != ps_dec_state -> u2_decode_header ) && ( ( bytes_remaining > 0 ) || ps_dec_state -> u1_flushfrm ) ) <S2SV_EndBug> { if ( ps_dec_state -> u1_flushfrm ) { if ( ps_dec_state -> aps_ref_pics [ 1 ] != NULL ) { impeg2_disp_mgr_add ( & ps_dec_state -> s_disp_mgr , ps_dec_state -> aps_ref_pics [ 1 ] , ps_dec_state -> aps_ref_pics [ 1 ] -> i4_buf_id ) ; impeg2_buf_mgr_release ( ps_dec_state -> pv_pic_buf_mg , ps_dec_state -> aps_ref_pics [ 1 ] -> i4_buf_id , BUF_MGR_REF ) ; impeg2_buf_mgr_release ( ps_dec_state -> pv_pic_buf_mg , ps_dec_state -> aps_ref_pics [ 0 ] -> i4_buf_id , BUF_MGR_REF ) ; ps_dec_state -> aps_ref_pics [ 1 ] = NULL ; ps_dec_state -> aps_ref_pics [ 0 ] = NULL ; } else if ( ps_dec_state -> aps_ref_pics [ 0 ] != NULL ) { impeg2_disp_mgr_add ( & ps_dec_state -> s_disp_mgr , ps_dec_state -> aps_ref_pics [ 0 ] , ps_dec_state -> aps_ref_pics [ 0 ] -> i4_buf_id ) ; impeg2_buf_mgr_release ( ps_dec_state -> pv_pic_buf_mg , ps_dec_state -> aps_ref_pics [ 0 ] -> i4_buf_id , BUF_MGR_REF ) ; ps_dec_state -> aps_ref_pics [ 0 ] = NULL ; } ps_dec_ip -> s_ivd_video_decode_ip_t . u4_size = sizeof ( impeg2d_video_decode_ip_t ) ; ps_dec_op -> s_ivd_video_decode_op_t . u4_size = sizeof ( impeg2d_video_decode_op_t ) ; ps_disp_pic = impeg2_disp_mgr_get ( & ps_dec_state -> s_disp_mgr , & ps_dec_state -> i4_disp_buf_id ) ; ps_dec_state -> ps_disp_pic = ps_disp_pic ; if ( ps_disp_pic == NULL ) { ps_dec_op -> s_ivd_video_decode_op_t . u4_output_present = 0 ; } else { WORD32 fmt_conv ; if ( 0 == ps_dec_state -> u4_share_disp_buf ) { ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . pv_y_buf = ps_dec_ip -> s_ivd_video_decode_ip_t . s_out_buffer . pu1_bufs [ 0 ] ; ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . pv_u_buf = ps_dec_ip -> s_ivd_video_decode_ip_t . s_out_buffer . pu1_bufs [ 1 ] ; ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . pv_v_buf = ps_dec_ip -> s_ivd_video_decode_ip_t . s_out_buffer . pu1_bufs [ 2 ] ; fmt_conv = 1 ; } else { ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . pv_y_buf = ps_disp_pic -> pu1_y ; if ( IV_YUV_420P == ps_dec_state -> i4_chromaFormat ) { ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . pv_u_buf = ps_disp_pic -> pu1_u ; ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . pv_v_buf = ps_disp_pic -> pu1_v ; fmt_conv = 0 ; } else { UWORD8 * pu1_buf ; pu1_buf = ps_dec_state -> as_disp_buffers [ ps_disp_pic -> i4_buf_id ] . pu1_bufs [ 1 ] ; ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . pv_u_buf = pu1_buf ; pu1_buf = ps_dec_state -> as_disp_buffers [ ps_disp_pic -> i4_buf_id ] . pu1_bufs [ 2 ] ; ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . pv_v_buf = pu1_buf ; fmt_conv = 1 ; } } if ( fmt_conv == 1 ) { iv_yuv_buf_t * ps_dst ; ps_dst = & ( ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf ) ; if ( ps_dec_state -> u4_deinterlace && ( 0 == ps_dec_state -> u2_progressive_frame ) ) { impeg2d_deinterlace ( ps_dec_state , ps_disp_pic , ps_dst , 0 , ps_dec_state -> u2_vertical_size ) ; } else { impeg2d_format_convert ( ps_dec_state , ps_disp_pic , ps_dst , 0 , ps_dec_state -> u2_vertical_size ) ; } } if ( ps_dec_state -> u4_deinterlace ) { if ( ps_dec_state -> ps_deint_pic ) { impeg2_buf_mgr_release ( ps_dec_state -> pv_pic_buf_mg , ps_dec_state -> ps_deint_pic -> i4_buf_id , MPEG2_BUF_MGR_DEINT ) ; } ps_dec_state -> ps_deint_pic = ps_disp_pic ; } if ( 0 == ps_dec_state -> u4_share_disp_buf ) impeg2_buf_mgr_release ( ps_dec_state -> pv_pic_buf_mg , ps_disp_pic -> i4_buf_id , BUF_MGR_DISP ) ; ps_dec_op -> s_ivd_video_decode_op_t . u4_pic_ht = ps_dec_state -> u2_vertical_size ; ps_dec_op -> s_ivd_video_decode_op_t . u4_pic_wd = ps_dec_state -> u2_horizontal_size ; ps_dec_op -> s_ivd_video_decode_op_t . u4_output_present = 1 ; ps_dec_op -> s_ivd_video_decode_op_t . u4_disp_buf_id = ps_disp_pic -> i4_buf_id ; ps_dec_op -> s_ivd_video_decode_op_t . u4_ts = ps_disp_pic -> u4_ts ; ps_dec_op -> s_ivd_video_decode_op_t . e_output_format = ( IV_COLOR_FORMAT_T ) ps_dec_state -> i4_chromaFormat ; ps_dec_op -> s_ivd_video_decode_op_t . u4_is_ref_flag = ( B_PIC != ps_dec_state -> e_pic_type ) ; ps_dec_op -> s_ivd_video_decode_op_t . u4_progressive_frame_flag = IV_PROGRESSIVE ; ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . u4_y_wd = ps_dec_state -> u2_horizontal_size ; ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . u4_y_strd = ps_dec_state -> u4_frm_buf_stride ; ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . u4_y_ht = ps_dec_state -> u2_vertical_size ; ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . u4_u_wd = ps_dec_state -> u2_horizontal_size >> 1 ; ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . u4_u_strd = ps_dec_state -> u4_frm_buf_stride >> 1 ; ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . u4_u_ht = ps_dec_state -> u2_vertical_size >> 1 ; ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . u4_v_wd = ps_dec_state -> u2_horizontal_size >> 1 ; ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . u4_v_strd = ps_dec_state -> u4_frm_buf_stride >> 1 ; ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . u4_v_ht = ps_dec_state -> u2_vertical_size >> 1 ; ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . u4_size = sizeof ( ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf ) ; switch ( ps_dec_state -> i4_chromaFormat ) { case IV_YUV_420SP_UV : case IV_YUV_420SP_VU : ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . u4_u_wd = ps_dec_state -> u2_horizontal_size ; ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . u4_u_strd = ps_dec_state -> u4_frm_buf_stride ; break ; case IV_YUV_422ILE : ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . u4_u_wd = 0 ; ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . u4_u_ht = 0 ; ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . u4_v_wd = 0 ; ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . u4_v_ht = 0 ; break ; default : break ; } } if ( ps_dec_op -> s_ivd_video_decode_op_t . u4_output_present ) { if ( 1 == ps_dec_op -> s_ivd_video_decode_op_t . u4_output_present ) { INSERT_LOGO ( ps_dec_ip -> s_ivd_video_decode_ip_t . s_out_buffer . pu1_bufs [ 0 ] , ps_dec_ip -> s_ivd_video_decode_ip_t . s_out_buffer . pu1_bufs [ 1 ] , ps_dec_ip -> s_ivd_video_decode_ip_t . s_out_buffer . pu1_bufs [ 2 ] , ps_dec_state -> u4_frm_buf_stride , ps_dec_state -> u2_horizontal_size , ps_dec_state -> u2_vertical_size , ps_dec_state -> i4_chromaFormat , ps_dec_state -> u2_horizontal_size , ps_dec_state -> u2_vertical_size ) ; } return ( IV_SUCCESS ) ; } else { ps_dec_state -> u1_flushfrm = 0 ; return ( IV_FAIL ) ; } } else if ( ps_dec_state -> u1_flushfrm == 0 ) { ps_dec_ip -> s_ivd_video_decode_ip_t . u4_size = sizeof ( impeg2d_video_decode_ip_t ) ; ps_dec_op -> s_ivd_video_decode_op_t . u4_size = sizeof ( impeg2d_video_decode_op_t ) ; if ( ps_dec_ip -> s_ivd_video_decode_ip_t . u4_num_Bytes < 4 ) { ps_dec_op -> s_ivd_video_decode_op_t . u4_num_bytes_consumed = ps_dec_ip -> s_ivd_video_decode_ip_t . u4_num_Bytes ; return ( IV_FAIL ) ; } if ( 1 == ps_dec_state -> u4_share_disp_buf ) { if ( 0 == impeg2_buf_mgr_check_free ( ps_dec_state -> pv_pic_buf_mg ) ) { ps_dec_op -> s_ivd_video_decode_op_t . u4_error_code = ( IMPEG2D_ERROR_CODES_T ) IVD_DEC_REF_BUF_NULL ; return IV_FAIL ; } } ps_dec_op -> s_ivd_video_decode_op_t . e_output_format = ( IV_COLOR_FORMAT_T ) ps_dec_state -> i4_chromaFormat ; ps_dec_op -> s_ivd_video_decode_op_t . u4_is_ref_flag = ( B_PIC != ps_dec_state -> e_pic_type ) ; ps_dec_op -> s_ivd_video_decode_op_t . u4_progressive_frame_flag = IV_PROGRESSIVE ; if ( 0 == ps_dec_state -> u4_frm_buf_stride ) { ps_dec_state -> u4_frm_buf_stride = ( ps_dec_state -> u2_horizontal_size ) ; } ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . u4_y_wd = ps_dec_state -> u2_horizontal_size ; ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . u4_y_strd = ps_dec_state -> u4_frm_buf_stride ; ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . u4_y_ht = ps_dec_state -> u2_vertical_size ; ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . u4_u_wd = ps_dec_state -> u2_horizontal_size >> 1 ; ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . u4_u_strd = ps_dec_state -> u4_frm_buf_stride >> 1 ; ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . u4_u_ht = ps_dec_state -> u2_vertical_size >> 1 ; ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . u4_v_wd = ps_dec_state -> u2_horizontal_size >> 1 ; ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . u4_v_strd = ps_dec_state -> u4_frm_buf_stride >> 1 ; ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . u4_v_ht = ps_dec_state -> u2_vertical_size >> 1 ; ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . u4_size = sizeof ( ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf ) ; switch ( ps_dec_state -> i4_chromaFormat ) { case IV_YUV_420SP_UV : case IV_YUV_420SP_VU : ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . u4_u_wd = ps_dec_state -> u2_horizontal_size ; ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . u4_u_strd = ps_dec_state -> u4_frm_buf_stride ; break ; case IV_YUV_422ILE : ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . u4_u_wd = 0 ; ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . u4_u_ht = 0 ; ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . u4_v_wd = 0 ; ps_dec_op -> s_ivd_video_decode_op_t . s_disp_frm_buf . u4_v_ht = 0 ; break ; default : break ; } if ( ps_dec_state -> u1_flushfrm == 0 ) { ps_dec_state -> u1_flushcnt = 0 ; impeg2d_dec_frm ( ps_dec_state , ps_dec_ip , ps_dec_op ) ; if ( IVD_ERROR_NONE == ps_dec_op -> s_ivd_video_decode_op_t . u4_error_code ) { if ( ps_dec_state -> u1_first_frame_done == 0 ) { ps_dec_state -> u1_first_frame_done = 1 ; } if ( ps_dec_state -> ps_disp_pic ) { ps_dec_op -> s_ivd_video_decode_op_t . u4_output_present = 1 ; switch ( ps_dec_state -> ps_disp_pic -> e_pic_type ) { case I_PIC : ps_dec_op -> s_ivd_video_decode_op_t . e_pic_type = IV_I_FRAME ; break ; case P_PIC : ps_dec_op -> s_ivd_video_decode_op_t . e_pic_type = IV_P_FRAME ; break ; case B_PIC : ps_dec_op -> s_ivd_video_decode_op_t . e_pic_type = IV_B_FRAME ; break ; case D_PIC : ps_dec_op -> s_ivd_video_decode_op_t . e_pic_type = IV_I_FRAME ; break ; default : ps_dec_op -> s_ivd_video_decode_op_t . e_pic_type = IV_FRAMETYPE_DEFAULT ; break ; } } else { ps_dec_op -> s_ivd_video_decode_op_t . u4_output_present = 0 ; ps_dec_op -> s_ivd_video_decode_op_t . e_pic_type = IV_NA_FRAME ; } ps_dec_state -> u4_num_frames_decoded ++ ; } } else { ps_dec_state -> u1_flushcnt ++ ; } } if ( ps_dec_state -> ps_disp_pic ) { ps_dec_op -> s_ivd_video_decode_op_t . u4_disp_buf_id = ps_dec_state -> ps_disp_pic -> i4_buf_id ; ps_dec_op -> s_ivd_video_decode_op_t . u4_ts = ps_dec_state -> ps_disp_pic -> u4_ts ; if ( 0 == ps_dec_state -> u4_share_disp_buf ) { impeg2_buf_mgr_release ( ps_dec_state -> pv_pic_buf_mg , ps_dec_state -> ps_disp_pic -> i4_buf_id , BUF_MGR_DISP ) ; } } if ( ps_dec_state -> u4_deinterlace ) { if ( ps_dec_state -> ps_deint_pic ) { impeg2_buf_mgr_release ( ps_dec_state -> pv_pic_buf_mg , ps_dec_state -> ps_deint_pic -> i4_buf_id , MPEG2_BUF_MGR_DEINT ) ; } ps_dec_state -> ps_deint_pic = ps_dec_state -> ps_disp_pic ; } if ( 1 == ps_dec_op -> s_ivd_video_decode_op_t . u4_output_present ) { INSERT_LOGO ( ps_dec_ip -> s_ivd_video_decode_ip_t . s_out_buffer . pu1_bufs [ 0 ] , ps_dec_ip -> s_ivd_video_decode_ip_t . s_out_buffer . pu1_bufs [ 1 ] , ps_dec_ip -> s_ivd_video_decode_ip_t . s_out_buffer . pu1_bufs [ 2 ] , ps_dec_state -> u4_frm_buf_stride , ps_dec_state -> u2_horizontal_size , ps_dec_state -> u2_vertical_size , ps_dec_state -> i4_chromaFormat , ps_dec_state -> u2_horizontal_size , ps_dec_state -> u2_vertical_size ) ; } } ps_dec_op -> s_ivd_video_decode_op_t . u4_progressive_frame_flag = 1 ; ps_dec_op -> s_ivd_video_decode_op_t . e4_fld_type = ps_dec_state -> s_disp_op . e4_fld_type ; if ( ps_dec_op -> s_ivd_video_decode_op_t . u4_error_code ) return IV_FAIL ; else return IV_SUCCESS ; }",u2_decode_header ) && ( <S2SV_ModStart> bytes_remaining > 0 ) && ( 1 == ps_dec_state -> u2_header_done )
417,"static void nfs4_open_confirm_release ( void * calldata ) { struct nfs4_opendata * data = calldata ; struct nfs4_state * state = NULL ; if ( data -> cancelled == 0 ) goto out_free ; if ( ! data -> rpc_done ) goto out_free ; state = nfs4_opendata_to_nfs4_state ( data ) ; if ( ! IS_ERR ( state ) ) <S2SV_StartBug> nfs4_close_state ( & data -> path , state , data -> o_arg . open_flags ) ; <S2SV_EndBug> out_free : nfs4_opendata_put ( data ) ; }",-> o_arg . fmode <S2SV_ModEnd> ) ; out_free
418,"<S2SV_StartBug> static void duplicate_mode_info_in_sb ( VP9_COMMON * const cm , <S2SV_EndBug> <S2SV_StartBug> MACROBLOCKD * const xd , <S2SV_EndBug> int mi_row , int mi_col , BLOCK_SIZE bsize ) { const int block_width = num_8x8_blocks_wide_lookup [ bsize ] ; const int block_height = num_8x8_blocks_high_lookup [ bsize ] ; int i , j ; for ( j = 0 ; j < block_height ; ++ j ) for ( i = 0 ; i < block_width ; ++ i ) { if ( mi_row + j < cm -> mi_rows && mi_col + i < cm -> mi_cols ) xd -> mi [ j * xd -> mi_stride + i ] = xd -> mi [ 0 ] ; } }","( VP9_COMMON * <S2SV_ModEnd> cm , MACROBLOCKD <S2SV_ModStart> , MACROBLOCKD * <S2SV_ModEnd> xd , int"
419,"static int irda_recvmsg_stream ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t size , int flags ) { struct sock * sk = sock -> sk ; struct irda_sock * self = irda_sk ( sk ) ; int noblock = flags & MSG_DONTWAIT ; size_t copied = 0 ; int target , err ; long timeo ; IRDA_DEBUG ( 3 , ""%s()\\n"" , __func__ ) ; if ( ( err = sock_error ( sk ) ) < 0 ) return err ; if ( sock -> flags & __SO_ACCEPTCON ) return - EINVAL ; err = - EOPNOTSUPP ; if ( flags & MSG_OOB ) return - EOPNOTSUPP ; err = 0 ; target = sock_rcvlowat ( sk , flags & MSG_WAITALL , size ) ; timeo = sock_rcvtimeo ( sk , noblock ) ; <S2SV_StartBug> msg -> msg_namelen = 0 ; <S2SV_EndBug> do { int chunk ; struct sk_buff * skb = skb_dequeue ( & sk -> sk_receive_queue ) ; if ( skb == NULL ) { DEFINE_WAIT ( wait ) ; err = 0 ; if ( copied >= target ) break ; prepare_to_wait_exclusive ( sk_sleep ( sk ) , & wait , TASK_INTERRUPTIBLE ) ; err = sock_error ( sk ) ; if ( err ) ; else if ( sk -> sk_shutdown & RCV_SHUTDOWN ) ; else if ( noblock ) err = - EAGAIN ; else if ( signal_pending ( current ) ) err = sock_intr_errno ( timeo ) ; else if ( sk -> sk_state != TCP_ESTABLISHED ) err = - ENOTCONN ; else if ( skb_peek ( & sk -> sk_receive_queue ) == NULL ) schedule ( ) ; finish_wait ( sk_sleep ( sk ) , & wait ) ; if ( err ) return err ; if ( sk -> sk_shutdown & RCV_SHUTDOWN ) break ; continue ; } chunk = min_t ( unsigned int , skb -> len , size ) ; if ( memcpy_toiovec ( msg -> msg_iov , skb -> data , chunk ) ) { skb_queue_head ( & sk -> sk_receive_queue , skb ) ; if ( copied == 0 ) copied = - EFAULT ; break ; } copied += chunk ; size -= chunk ; if ( ! ( flags & MSG_PEEK ) ) { skb_pull ( skb , chunk ) ; if ( skb -> len ) { IRDA_DEBUG ( 1 , ""%s(),<S2SV_blank>back<S2SV_blank>on<S2SV_blank>q!\\n"" , __func__ ) ; skb_queue_head ( & sk -> sk_receive_queue , skb ) ; break ; } kfree_skb ( skb ) ; } else { IRDA_DEBUG ( 0 , ""%s()<S2SV_blank>questionable!?\\n"" , __func__ ) ; skb_queue_head ( & sk -> sk_receive_queue , skb ) ; break ; } } while ( size ) ; if ( self -> rx_flow == FLOW_STOP ) { if ( ( atomic_read ( & sk -> sk_rmem_alloc ) << 2 ) <= sk -> sk_rcvbuf ) { IRDA_DEBUG ( 2 , ""%s(),<S2SV_blank>Starting<S2SV_blank>IrTTP\\n"" , __func__ ) ; self -> rx_flow = FLOW_START ; irttp_flow_request ( self -> tsap , FLOW_START ) ; } } return copied ; }",noblock ) ; <S2SV_ModEnd> do { int
420,static void timerfd_remove_cancel ( struct timerfd_ctx * ctx ) { <S2SV_StartBug> if ( ctx -> might_cancel ) { <S2SV_EndBug> ctx -> might_cancel = false ; <S2SV_StartBug> spin_lock ( & cancel_lock ) ; <S2SV_EndBug> <S2SV_StartBug> list_del_rcu ( & ctx -> clist ) ; <S2SV_EndBug> <S2SV_StartBug> spin_unlock ( & cancel_lock ) ; <S2SV_EndBug> } <S2SV_StartBug> } <S2SV_EndBug>,ctx ) { <S2SV_ModEnd> spin_lock ( & <S2SV_ModStart> spin_lock ( & ctx -> <S2SV_ModStart> cancel_lock ) ; __timerfd_remove_cancel ( ctx <S2SV_ModEnd> ) ; spin_unlock <S2SV_ModStart> spin_unlock ( & ctx -> <S2SV_ModStart> ) ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
421,"<S2SV_StartBug> int xt_check_entry_offsets ( const void * base , <S2SV_EndBug> unsigned int target_offset , unsigned int next_offset ) { <S2SV_StartBug> const struct xt_entry_target * t ; <S2SV_EndBug> <S2SV_StartBug> const char * e = base ; <S2SV_EndBug> if ( target_offset + sizeof ( * t ) > next_offset ) return - EINVAL ; t = ( void * ) ( e + target_offset ) ; if ( t -> u . target_size < sizeof ( * t ) ) return - EINVAL ; if ( target_offset + t -> u . target_size > next_offset ) return - EINVAL ; if ( strcmp ( t -> u . user . name , XT_STANDARD_TARGET ) == 0 && target_offset + sizeof ( struct xt_standard_target ) != next_offset ) return - EINVAL ; return 0 ; }","void * base , const char * elems <S2SV_ModStart> next_offset ) { long size_of_base_struct = elems - ( const char * ) base ; <S2SV_ModStart> e = base ; if ( target_offset < size_of_base_struct ) return - EINVAL"
422,"static int llc_ui_getname ( struct socket * sock , struct sockaddr * uaddr , int * uaddrlen , int peer ) { struct sockaddr_llc sllc ; struct sock * sk = sock -> sk ; struct llc_sock * llc = llc_sk ( sk ) ; <S2SV_StartBug> int rc = 0 ; <S2SV_EndBug> memset ( & sllc , 0 , sizeof ( sllc ) ) ; lock_sock ( sk ) ; if ( sock_flag ( sk , SOCK_ZAPPED ) ) goto out ; <S2SV_StartBug> * uaddrlen = sizeof ( sllc ) ; <S2SV_EndBug> memset ( uaddr , 0 , * uaddrlen ) ; if ( peer ) { rc = - ENOTCONN ; if ( sk -> sk_state != TCP_ESTABLISHED ) goto out ; if ( llc -> dev ) sllc . sllc_arphrd = llc -> dev -> type ; sllc . sllc_sap = llc -> daddr . lsap ; memcpy ( & sllc . sllc_mac , & llc -> daddr . mac , IFHWADDRLEN ) ; } else { rc = - EINVAL ; if ( ! llc -> sap ) goto out ; sllc . sllc_sap = llc -> sap -> laddr . lsap ; if ( llc -> dev ) { sllc . sllc_arphrd = llc -> dev -> type ; memcpy ( & sllc . sllc_mac , llc -> dev -> dev_addr , IFHWADDRLEN ) ; } } rc = 0 ; sllc . sllc_family = AF_LLC ; memcpy ( uaddr , & sllc , sizeof ( sllc ) ) ; out : release_sock ( sk ) ; return rc ; }","int rc = - EBADF ; memset ( & sllc , 0 <S2SV_ModEnd> , sizeof ( <S2SV_ModStart> sizeof ( sllc <S2SV_ModEnd> ) ; if"
423,"void preproc_mount_mnt_dir ( void ) { if ( ! tmpfs_mounted ) { if ( arg_debug ) printf ( ""Mounting<S2SV_blank>tmpfs<S2SV_blank>on<S2SV_blank>%s<S2SV_blank>directory\\n"" , RUN_MNT_DIR ) ; if ( mount ( ""tmpfs"" , RUN_MNT_DIR , ""tmpfs"" , MS_NOSUID | MS_STRICTATIME , ""mode=755,gid=0"" ) < 0 ) errExit ( ""mounting<S2SV_blank>/run/firejail/mnt"" ) ; tmpfs_mounted = 1 ; fs_logger2 ( ""tmpfs"" , RUN_MNT_DIR ) ; # ifdef HAVE_SECCOMP <S2SV_StartBug> if ( arg_seccomp_block_secondary ) <S2SV_EndBug> copy_file ( PATH_SECCOMP_BLOCK_SECONDARY , RUN_SECCOMP_BLOCK_SECONDARY , getuid ( ) , getgid ( ) , 0644 ) ; else { copy_file ( PATH_SECCOMP_32 , RUN_SECCOMP_32 , getuid ( ) , getgid ( ) , 0644 ) ; } if ( arg_allow_debuggers ) copy_file ( PATH_SECCOMP_DEFAULT_DEBUG , RUN_SECCOMP_CFG , getuid ( ) , getgid ( ) , 0644 ) ; else copy_file ( PATH_SECCOMP_DEFAULT , RUN_SECCOMP_CFG , getuid ( ) , getgid ( ) , 0644 ) ; if ( arg_memory_deny_write_execute ) copy_file ( PATH_SECCOMP_MDWX , RUN_SECCOMP_MDWX , getuid ( ) , getgid ( ) , 0644 ) ; create_empty_file_as_root ( RUN_SECCOMP_PROTOCOL , 0644 ) ; if ( set_perms ( RUN_SECCOMP_PROTOCOL , getuid ( ) , getgid ( ) , 0644 ) ) errExit ( ""set_perms"" ) ; create_empty_file_as_root ( RUN_SECCOMP_POSTEXEC , 0644 ) ; if ( set_perms ( RUN_SECCOMP_POSTEXEC , getuid ( ) , getgid ( ) , 0644 ) ) errExit ( ""set_perms"" ) ; # endif } }","# ifdef HAVE_SECCOMP create_empty_dir_as_root ( RUN_SECCOMP_DIR , 0755 ) ;"
424,"int expand_downwards ( struct vm_area_struct * vma , unsigned long address ) { struct mm_struct * mm = vma -> vm_mm ; struct vm_area_struct * prev ; <S2SV_StartBug> int error ; <S2SV_EndBug> address &= PAGE_MASK ; <S2SV_StartBug> error = security_mmap_addr ( address ) ; <S2SV_EndBug> if ( error ) return error ; prev = vma -> vm_prev ; if ( prev && ! ( prev -> vm_flags & VM_GROWSDOWN ) && ( prev -> vm_flags & ( VM_WRITE | VM_READ | VM_EXEC ) ) ) { if ( address - prev -> vm_end < stack_guard_gap ) return - ENOMEM ; } if ( unlikely ( anon_vma_prepare ( vma ) ) ) return - ENOMEM ; anon_vma_lock_write ( vma -> anon_vma ) ; if ( address < vma -> vm_start ) { unsigned long size , grow ; size = vma -> vm_end - address ; grow = ( vma -> vm_start - address ) >> PAGE_SHIFT ; error = - ENOMEM ; if ( grow <= vma -> vm_pgoff ) { error = acct_stack_growth ( vma , size , grow ) ; if ( ! error ) { spin_lock ( & mm -> page_table_lock ) ; if ( vma -> vm_flags & VM_LOCKED ) mm -> locked_vm += grow ; vm_stat_account ( mm , vma -> vm_flags , grow ) ; anon_vma_interval_tree_pre_update_vma ( vma ) ; vma -> vm_start = address ; vma -> vm_pgoff -= grow ; anon_vma_interval_tree_post_update_vma ( vma ) ; vma_gap_update ( vma ) ; spin_unlock ( & mm -> page_table_lock ) ; perf_event_mmap ( vma ) ; } } } anon_vma_unlock_write ( vma -> anon_vma ) ; khugepaged_enter_vma_merge ( vma , vma -> vm_flags ) ; validate_mm ( mm ) ; return error ; }",; int error = 0 <S2SV_ModStart> &= PAGE_MASK ; if ( address < mmap_min_addr ) return - EPERM <S2SV_ModEnd> ; prev =
425,"static int mobility_opt_print ( netdissect_options * ndo , const u_char * bp , const unsigned len ) { unsigned i , optlen ; for ( i = 0 ; i < len ; i += optlen ) { ND_TCHECK ( bp [ i ] ) ; if ( bp [ i ] == IP6MOPT_PAD1 ) optlen = 1 ; else { if ( i + 1 < len ) { ND_TCHECK ( bp [ i + 1 ] ) ; optlen = bp [ i + 1 ] + 2 ; } else goto trunc ; } if ( i + optlen > len ) goto trunc ; ND_TCHECK ( bp [ i + optlen ] ) ; switch ( bp [ i ] ) { case IP6MOPT_PAD1 : ND_PRINT ( ( ndo , ""(pad1)"" ) ) ; break ; case IP6MOPT_PADN : if ( len - i < IP6MOPT_MINLEN ) { ND_PRINT ( ( ndo , ""(padn:<S2SV_blank>trunc)"" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""(padn)"" ) ) ; break ; case IP6MOPT_REFRESH : if ( len - i < IP6MOPT_REFRESH_MINLEN ) { ND_PRINT ( ( ndo , ""(refresh:<S2SV_blank>trunc)"" ) ) ; goto trunc ; } ND_TCHECK_16BITS ( & bp [ i + 2 ] ) ; ND_PRINT ( ( ndo , ""(refresh:<S2SV_blank>%u)"" , EXTRACT_16BITS ( & bp [ i + 2 ] ) << 2 ) ) ; break ; case IP6MOPT_ALTCOA : if ( len - i < IP6MOPT_ALTCOA_MINLEN ) { ND_PRINT ( ( ndo , ""(altcoa:<S2SV_blank>trunc)"" ) ) ; goto trunc ; } <S2SV_StartBug> ND_PRINT ( ( ndo , ""(alt-CoA:<S2SV_blank>%s)"" , ip6addr_string ( ndo , & bp [ i + 2 ] ) ) ) ; <S2SV_EndBug> break ; case IP6MOPT_NONCEID : if ( len - i < IP6MOPT_NONCEID_MINLEN ) { ND_PRINT ( ( ndo , ""(ni:<S2SV_blank>trunc)"" ) ) ; goto trunc ; } ND_TCHECK_16BITS ( & bp [ i + 2 ] ) ; ND_TCHECK_16BITS ( & bp [ i + 4 ] ) ; ND_PRINT ( ( ndo , ""(ni:<S2SV_blank>ho=0x%04x<S2SV_blank>co=0x%04x)"" , EXTRACT_16BITS ( & bp [ i + 2 ] ) , EXTRACT_16BITS ( & bp [ i + 4 ] ) ) ) ; break ; case IP6MOPT_AUTH : if ( len - i < IP6MOPT_AUTH_MINLEN ) { ND_PRINT ( ( ndo , ""(auth:<S2SV_blank>trunc)"" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""(auth)"" ) ) ; break ; default : if ( len - i < IP6MOPT_MINLEN ) { ND_PRINT ( ( ndo , ""(sopt_type<S2SV_blank>%u:<S2SV_blank>trunc)"" , bp [ i ] ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""(type-0x%02x:<S2SV_blank>len=%u)"" , bp [ i ] , bp [ i + 1 ] ) ) ; break ; } } return 0 ; trunc : return 1 ; }",trunc ; } ND_TCHECK_128BITS ( & bp [ i + 2 ] ) ;
426,"int main ( int argc , char * * argv ) { int frame_cnt = 0 ; FILE * outfile = NULL ; vpx_codec_ctx_t codec ; const VpxInterface * decoder = NULL ; VpxVideoReader * reader = NULL ; const VpxVideoInfo * info = NULL ; int n = 0 ; int m = 0 ; int is_range = 0 ; char * nptr = NULL ; exec_name = argv [ 0 ] ; if ( argc != 4 ) die ( ""Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>arguments."" ) ; reader = vpx_video_reader_open ( argv [ 1 ] ) ; if ( ! reader ) die ( ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading."" , argv [ 1 ] ) ; if ( ! ( outfile = fopen ( argv [ 2 ] , ""wb"" ) ) ) die ( ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>writing."" , argv [ 2 ] ) ; n = strtol ( argv [ 3 ] , & nptr , 0 ) ; m = strtol ( nptr + 1 , NULL , 0 ) ; is_range = ( * nptr == '-' ) ; if ( ! n || ! m || ( * nptr != '-' && * nptr != '/' ) ) die ( ""Couldn\'t<S2SV_blank>parse<S2SV_blank>pattern<S2SV_blank>%s.\\n"" , argv [ 3 ] ) ; info = vpx_video_reader_get_info ( reader ) ; decoder = get_vpx_decoder_by_fourcc ( info -> codec_fourcc ) ; if ( ! decoder ) die ( ""Unknown<S2SV_blank>input<S2SV_blank>codec."" ) ; <S2SV_StartBug> printf ( ""Using<S2SV_blank>%s\\n"" , vpx_codec_iface_name ( decoder -> interface ( ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( vpx_codec_dec_init ( & codec , decoder -> interface ( ) , NULL , 0 ) ) <S2SV_EndBug> die_codec ( & codec , ""Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>decoder."" ) ; while ( vpx_video_reader_read_frame ( reader ) ) { vpx_codec_iter_t iter = NULL ; vpx_image_t * img = NULL ; size_t frame_size = 0 ; int skip ; const unsigned char * frame = vpx_video_reader_get_frame ( reader , & frame_size ) ; if ( vpx_codec_decode ( & codec , frame , ( unsigned int ) frame_size , NULL , 0 ) ) die_codec ( & codec , ""Failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>frame."" ) ; ++ frame_cnt ; skip = ( is_range && frame_cnt >= n && frame_cnt <= m ) || ( ! is_range && m - ( frame_cnt - 1 ) % m <= n ) ; if ( ! skip ) { putc ( '.' , stdout ) ; while ( ( img = vpx_codec_get_frame ( & codec , & iter ) ) != NULL ) vpx_img_write ( img , outfile ) ; } else { putc ( 'X' , stdout ) ; } fflush ( stdout ) ; } printf ( ""Processed<S2SV_blank>%d<S2SV_blank>frames.\\n"" , frame_cnt ) ; if ( vpx_codec_destroy ( & codec ) ) die_codec ( & codec , ""Failed<S2SV_blank>to<S2SV_blank>destroy<S2SV_blank>codec."" ) ; printf ( ""Play:<S2SV_blank>ffplay<S2SV_blank>-f<S2SV_blank>rawvideo<S2SV_blank>-pix_fmt<S2SV_blank>yuv420p<S2SV_blank>-s<S2SV_blank>%dx%d<S2SV_blank>%s\\n"" , info -> frame_width , info -> frame_height , argv [ 2 ] ) ; vpx_video_reader_close ( reader ) ; fclose ( outfile ) ; return EXIT_SUCCESS ; }","( decoder -> codec_interface <S2SV_ModEnd> ( ) ) <S2SV_ModStart> , decoder -> codec_interface <S2SV_ModEnd> ( ) ,"
427,"__be32 ipv6_select_ident ( struct net * net , const struct in6_addr * daddr , const struct in6_addr * saddr ) { <S2SV_StartBug> static u32 ip6_idents_hashrnd __read_mostly ; <S2SV_EndBug> u32 id ; net_get_random_once ( & ip6_idents_hashrnd , sizeof ( ip6_idents_hashrnd ) ) ; <S2SV_StartBug> id = __ipv6_select_ident ( net , ip6_idents_hashrnd , daddr , saddr ) ; <S2SV_EndBug> return htonl ( id ) ; }","saddr ) { u32 id <S2SV_ModEnd> ; id = <S2SV_ModStart> __ipv6_select_ident ( net <S2SV_ModEnd> , daddr ,"
428,"static void rx_cache_insert ( netdissect_options * ndo , const u_char * bp , const struct ip * ip , int dport ) { struct rx_cache_entry * rxent ; const struct rx_header * rxh = ( const struct rx_header * ) bp ; if ( ndo -> ndo_snapend - bp + 1 <= ( int ) ( sizeof ( struct rx_header ) + sizeof ( int32_t ) ) ) return ; rxent = & rx_cache [ rx_cache_next ] ; if ( ++ rx_cache_next >= RX_CACHE_SIZE ) rx_cache_next = 0 ; rxent -> callnum = EXTRACT_32BITS ( & rxh -> callNumber ) ; UNALIGNED_MEMCPY ( & rxent -> client , & ip -> ip_src , sizeof ( uint32_t ) ) ; UNALIGNED_MEMCPY ( & rxent -> server , & ip -> ip_dst , sizeof ( uint32_t ) ) ; rxent -> dport = dport ; <S2SV_StartBug> rxent -> serviceId = EXTRACT_32BITS ( & rxh -> serviceId ) ; <S2SV_EndBug> rxent -> opcode = EXTRACT_32BITS ( bp + sizeof ( struct rx_header ) ) ; }",-> serviceId = EXTRACT_16BITS <S2SV_ModEnd> ( & rxh
429,"<S2SV_StartBug> void vp9_model_to_full_probs ( const vp9_prob * model , vp9_prob * full ) { <S2SV_EndBug> if ( full != model ) <S2SV_StartBug> vpx_memcpy ( full , model , sizeof ( vp9_prob ) * UNCONSTRAINED_NODES ) ; <S2SV_EndBug> extend_to_full_distribution ( & full [ UNCONSTRAINED_NODES ] , model [ PIVOT_NODE ] ) ; }","vp9_model_to_full_probs ( const vpx_prob <S2SV_ModEnd> * model , <S2SV_ModStart> * model , vpx_prob <S2SV_ModEnd> * full ) <S2SV_ModStart> != model ) memcpy <S2SV_ModEnd> ( full , <S2SV_ModStart> , sizeof ( vpx_prob <S2SV_ModEnd> ) * UNCONSTRAINED_NODES"
430,cJSON * cJSON_CreateArray ( void ) { cJSON * item = cJSON_New_Item ( ) ; if ( item ) item -> type = cJSON_Array ; return item ; },"
"
431,"static int xfrm_dump_policy_done ( struct netlink_callback * cb ) { <S2SV_StartBug> struct xfrm_policy_walk * walk = ( struct xfrm_policy_walk * ) & cb -> args [ 1 ] ; <S2SV_EndBug> struct net * net = sock_net ( cb -> skb -> sk ) ; xfrm_policy_walk_done ( walk , net ) ; return 0 ; }",xfrm_policy_walk * ) <S2SV_ModEnd> cb -> args <S2SV_ModStart> cb -> args <S2SV_ModEnd> ; struct net
432,"static void n_tty_set_termios ( struct tty_struct * tty , struct ktermios * old ) { struct n_tty_data * ldata = tty -> disc_data ; <S2SV_StartBug> if ( ! old || ( old -> c_lflag ^ tty -> termios . c_lflag ) & ICANON ) { <S2SV_EndBug> bitmap_zero ( ldata -> read_flags , N_TTY_BUF_SIZE ) ; ldata -> line_start = ldata -> read_tail ; if ( ! L_ICANON ( tty ) || ! read_cnt ( ldata ) ) { ldata -> canon_head = ldata -> read_tail ; ldata -> push = 0 ; } else { set_bit ( ( ldata -> read_head - 1 ) & ( N_TTY_BUF_SIZE - 1 ) , ldata -> read_flags ) ; ldata -> canon_head = ldata -> read_head ; ldata -> push = 1 ; } ldata -> commit_head = ldata -> read_head ; ldata -> erasing = 0 ; ldata -> lnext = 0 ; } ldata -> icanon = ( L_ICANON ( tty ) != 0 ) ; if ( I_ISTRIP ( tty ) || I_IUCLC ( tty ) || I_IGNCR ( tty ) || I_ICRNL ( tty ) || I_INLCR ( tty ) || L_ICANON ( tty ) || I_IXON ( tty ) || L_ISIG ( tty ) || L_ECHO ( tty ) || I_PARMRK ( tty ) ) { bitmap_zero ( ldata -> char_map , 256 ) ; if ( I_IGNCR ( tty ) || I_ICRNL ( tty ) ) set_bit ( '\\r' , ldata -> char_map ) ; if ( I_INLCR ( tty ) ) set_bit ( '\\n' , ldata -> char_map ) ; if ( L_ICANON ( tty ) ) { set_bit ( ERASE_CHAR ( tty ) , ldata -> char_map ) ; set_bit ( KILL_CHAR ( tty ) , ldata -> char_map ) ; set_bit ( EOF_CHAR ( tty ) , ldata -> char_map ) ; set_bit ( '\\n' , ldata -> char_map ) ; set_bit ( EOL_CHAR ( tty ) , ldata -> char_map ) ; if ( L_IEXTEN ( tty ) ) { set_bit ( WERASE_CHAR ( tty ) , ldata -> char_map ) ; set_bit ( LNEXT_CHAR ( tty ) , ldata -> char_map ) ; set_bit ( EOL2_CHAR ( tty ) , ldata -> char_map ) ; if ( L_ECHO ( tty ) ) set_bit ( REPRINT_CHAR ( tty ) , ldata -> char_map ) ; } } if ( I_IXON ( tty ) ) { set_bit ( START_CHAR ( tty ) , ldata -> char_map ) ; set_bit ( STOP_CHAR ( tty ) , ldata -> char_map ) ; } if ( L_ISIG ( tty ) ) { set_bit ( INTR_CHAR ( tty ) , ldata -> char_map ) ; set_bit ( QUIT_CHAR ( tty ) , ldata -> char_map ) ; set_bit ( SUSP_CHAR ( tty ) , ldata -> char_map ) ; } clear_bit ( __DISABLED_CHAR , ldata -> char_map ) ; ldata -> raw = 0 ; ldata -> real_raw = 0 ; } else { ldata -> raw = 1 ; if ( ( I_IGNBRK ( tty ) || ( ! I_BRKINT ( tty ) && ! I_PARMRK ( tty ) ) ) && ( I_IGNPAR ( tty ) || ! I_INPCK ( tty ) ) && ( tty -> driver -> flags & TTY_DRIVER_REAL_RAW ) ) ldata -> real_raw = 1 ; else ldata -> real_raw = 0 ; } if ( ! I_IXON ( tty ) && old && ( old -> c_iflag & IXON ) && ! tty -> flow_stopped ) { start_tty ( tty ) ; process_echoes ( tty ) ; } wake_up_interruptible ( & tty -> write_wait ) ; wake_up_interruptible ( & tty -> read_wait ) ; }",c_lflag ) & ( ICANON | EXTPROC ) <S2SV_ModEnd> ) { bitmap_zero
433,"static ssize_t <S2SV_StartBug> pipe_write ( struct kiocb * iocb , const struct iovec * _iov , <S2SV_EndBug> unsigned long nr_segs , loff_t ppos ) { struct file * filp = iocb -> ki_filp ; struct pipe_inode_info * pipe = filp -> private_data ; <S2SV_StartBug> ssize_t ret ; <S2SV_EndBug> <S2SV_StartBug> int do_wakeup ; <S2SV_EndBug> struct iovec * iov = ( struct iovec * ) _iov ; <S2SV_StartBug> size_t total_len ; <S2SV_EndBug> ssize_t chars ; <S2SV_StartBug> total_len = iov_length ( iov , nr_segs ) ; <S2SV_EndBug> if ( unlikely ( total_len == 0 ) ) <S2SV_StartBug> return 0 ; <S2SV_EndBug> do_wakeup = 0 ; ret = 0 ; __pipe_lock ( pipe ) ; if ( ! pipe -> readers ) { send_sig ( SIGPIPE , current , 0 ) ; ret = - EPIPE ; goto out ; } chars = total_len & ( PAGE_SIZE - 1 ) ; if ( pipe -> nrbufs && chars != 0 ) { int lastbuf = ( pipe -> curbuf + pipe -> nrbufs - 1 ) & ( pipe -> buffers - 1 ) ; struct pipe_buffer * buf = pipe -> bufs + lastbuf ; const struct pipe_buf_operations * ops = buf -> ops ; int offset = buf -> offset + buf -> len ; if ( ops -> can_merge && offset + chars <= PAGE_SIZE ) { <S2SV_StartBug> int error , atomic = 1 ; <S2SV_EndBug> void * addr ; error = ops -> confirm ( pipe , buf ) ; if ( error ) goto out ; <S2SV_StartBug> iov_fault_in_pages_read ( iov , chars ) ; <S2SV_EndBug> redo1 : if ( atomic ) addr = kmap_atomic ( buf -> page ) ; else addr = kmap ( buf -> page ) ; error = pipe_iov_copy_from_user ( offset + addr , iov , chars , atomic ) ; if ( atomic ) kunmap_atomic ( addr ) ; else kunmap ( buf -> page ) ; ret = error ; do_wakeup = 1 ; if ( error ) { if ( atomic ) { atomic = 0 ; goto redo1 ; } goto out ; <S2SV_StartBug> } <S2SV_EndBug> buf -> len += chars ; <S2SV_StartBug> total_len -= chars ; <S2SV_EndBug> ret = chars ; if ( ! total_len ) goto out ; } } for ( ; ; ) { int bufs ; if ( ! pipe -> readers ) { send_sig ( SIGPIPE , current , 0 ) ; if ( ! ret ) ret = - EPIPE ; break ; } bufs = pipe -> nrbufs ; if ( bufs < pipe -> buffers ) { int newbuf = ( pipe -> curbuf + bufs ) & ( pipe -> buffers - 1 ) ; struct pipe_buffer * buf = pipe -> bufs + newbuf ; struct page * page = pipe -> tmp_page ; <S2SV_StartBug> char * src ; <S2SV_EndBug> int error , atomic = 1 ; if ( ! page ) { page = alloc_page ( GFP_HIGHUSER ) ; if ( unlikely ( ! page ) ) { ret = ret ? : - ENOMEM ; break ; } pipe -> tmp_page = page ; } do_wakeup = 1 ; <S2SV_StartBug> chars = PAGE_SIZE ; <S2SV_EndBug> if ( chars > total_len ) chars = total_len ; iov_fault_in_pages_read ( iov , chars ) ; redo2 : if ( atomic ) src = kmap_atomic ( page ) ; else src = kmap ( page ) ; error = pipe_iov_copy_from_user ( src , iov , chars , atomic ) ; if ( atomic ) kunmap_atomic ( src ) ; else kunmap ( page ) ; <S2SV_StartBug> if ( unlikely ( error ) ) { <S2SV_EndBug> if ( atomic ) { atomic = 0 ; goto redo2 ; } if ( ! ret ) ret = error ; break ; } <S2SV_StartBug> ret += chars ; <S2SV_EndBug> buf -> page = page ; buf -> ops = & anon_pipe_buf_ops ; buf -> offset = 0 ; <S2SV_StartBug> buf -> len = chars ; <S2SV_EndBug> buf -> flags = 0 ; if ( is_packetized ( filp ) ) { buf -> ops = & packet_pipe_buf_ops ; buf -> flags = PIPE_BUF_FLAG_PACKET ; } pipe -> nrbufs = ++ bufs ; pipe -> tmp_page = NULL ; <S2SV_StartBug> total_len -= chars ; <S2SV_EndBug> if ( ! total_len ) break ; } if ( bufs < pipe -> buffers ) continue ; if ( filp -> f_flags & O_NONBLOCK ) { if ( ! ret ) ret = - EAGAIN ; break ; } if ( signal_pending ( current ) ) { if ( ! ret ) ret = - ERESTARTSYS ; break ; } if ( do_wakeup ) { wake_up_interruptible_sync_poll ( & pipe -> wait , POLLIN | POLLRDNORM ) ; kill_fasync ( & pipe -> fasync_readers , SIGIO , POLL_IN ) ; do_wakeup = 0 ; } pipe -> waiting_writers ++ ; pipe_wait ( pipe ) ; pipe -> waiting_writers -- ; } out : __pipe_unlock ( pipe ) ; if ( do_wakeup ) { wake_up_interruptible_sync_poll ( & pipe -> wait , POLLIN | POLLRDNORM ) ; kill_fasync ( & pipe -> fasync_readers , SIGIO , POLL_IN ) ; } if ( ret > 0 && sb_start_write_trylock ( file_inode ( filp ) -> i_sb ) ) { int err = file_update_time ( filp ) ; if ( err ) ret = err ; sb_end_write ( file_inode ( filp ) -> i_sb ) ; } return ret ; }","* iocb , struct iov_iter * from <S2SV_ModEnd> ) { struct <S2SV_ModStart> ; ssize_t ret = 0 <S2SV_ModStart> ; int do_wakeup = 0 <S2SV_ModEnd> ; size_t total_len <S2SV_ModStart> ; size_t total_len = iov_iter_count ( from ) <S2SV_ModStart> ssize_t chars ; <S2SV_ModEnd> if ( unlikely <S2SV_ModStart> ) ) return <S2SV_ModEnd> 0 ; __pipe_lock <S2SV_ModStart> { int error <S2SV_ModEnd> = ops -> <S2SV_ModStart> goto out ; ret = copy_page_from_iter ( buf -> page , offset , chars , from ) ; if ( unlikely ( ret < chars ) ) { error = - EFAULT ; <S2SV_ModEnd> goto out ; <S2SV_ModStart> out ; } do_wakeup = 1 ; <S2SV_ModStart> += chars ; ret = chars ; if ( ! iov_iter_count ( from ) <S2SV_ModEnd> ) goto out <S2SV_ModStart> -> tmp_page ; int copied <S2SV_ModEnd> ; if ( <S2SV_ModStart> = 1 ; copied = copy_page_from_iter ( page , 0 , PAGE_SIZE , from <S2SV_ModEnd> ) ; if <S2SV_ModStart> ( unlikely ( copied < PAGE_SIZE && iov_iter_count ( from ) ) ) { if ( ! ret ) ret = - EFAULT <S2SV_ModEnd> ; break ; <S2SV_ModStart> } ret += copied <S2SV_ModEnd> ; buf -> <S2SV_ModStart> -> len = copied <S2SV_ModEnd> ; buf -> <S2SV_ModStart> = NULL ; if ( ! iov_iter_count ( from ) <S2SV_ModEnd> ) break ;"
434,"static void rd_release_device_space ( struct rd_dev * rd_dev ) { <S2SV_StartBug> u32 i , j , page_count = 0 , sg_per_table ; <S2SV_EndBug> struct rd_dev_sg_table * sg_table ; struct page * pg ; struct scatterlist * sg ; if ( ! rd_dev -> sg_table_array || ! rd_dev -> sg_table_count ) return ; <S2SV_StartBug> sg_table = rd_dev -> sg_table_array ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < rd_dev -> sg_table_count ; i ++ ) { <S2SV_EndBug> sg = sg_table [ i ] . sg_table ; sg_per_table = sg_table [ i ] . rd_sg_count ; for ( j = 0 ; j < sg_per_table ; j ++ ) { pg = sg_page ( & sg [ j ] ) ; if ( pg ) { __free_page ( pg ) ; page_count ++ ; } } kfree ( sg ) ; } pr_debug ( ""CORE_RD[%u]<S2SV_blank>-<S2SV_blank>Released<S2SV_blank>device<S2SV_blank>space<S2SV_blank>for<S2SV_blank>Ramdisk"" ""<S2SV_blank>Device<S2SV_blank>ID:<S2SV_blank>%u,<S2SV_blank>pages<S2SV_blank>%u<S2SV_blank>in<S2SV_blank>%u<S2SV_blank>tables<S2SV_blank>total<S2SV_blank>bytes<S2SV_blank>%lu\\n"" , rd_dev -> rd_host -> rd_host_id , rd_dev -> rd_dev_id , page_count , rd_dev -> sg_table_count , ( unsigned long ) page_count * PAGE_SIZE ) ; <S2SV_StartBug> kfree ( sg_table ) ; <S2SV_EndBug> rd_dev -> sg_table_array = NULL ; rd_dev -> sg_table_count = 0 ; }",") { u32 page_count <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) return ; page_count = rd_release_sgl_table ( rd_dev , <S2SV_ModEnd> rd_dev -> sg_table_array <S2SV_ModStart> rd_dev -> sg_table_array , <S2SV_ModEnd> rd_dev -> sg_table_count <S2SV_ModStart> rd_dev -> sg_table_count ) ; <S2SV_ModEnd> pr_debug ( ""CORE_RD[%u]<S2SV_blank>-<S2SV_blank>Released<S2SV_blank>device<S2SV_blank>space<S2SV_blank>for<S2SV_blank>Ramdisk"" <S2SV_ModStart> PAGE_SIZE ) ; <S2SV_ModEnd> rd_dev -> sg_table_array"
435,"static int tiffcp ( TIFF * in , TIFF * out ) { <S2SV_StartBug> uint16 bitspersample , samplesperpixel = 1 ; <S2SV_EndBug> uint16 input_compression , input_photometric = PHOTOMETRIC_MINISBLACK ; copyFunc cf ; uint32 width , length ; struct cpTag * p ; CopyField ( TIFFTAG_IMAGEWIDTH , width ) ; CopyField ( TIFFTAG_IMAGELENGTH , length ) ; CopyField ( TIFFTAG_BITSPERSAMPLE , bitspersample ) ; CopyField ( TIFFTAG_SAMPLESPERPIXEL , samplesperpixel ) ; if ( compression != ( uint16 ) - 1 ) TIFFSetField ( out , TIFFTAG_COMPRESSION , compression ) ; else CopyField ( TIFFTAG_COMPRESSION , compression ) ; TIFFGetFieldDefaulted ( in , TIFFTAG_COMPRESSION , & input_compression ) ; TIFFGetFieldDefaulted ( in , TIFFTAG_PHOTOMETRIC , & input_photometric ) ; if ( input_compression == COMPRESSION_JPEG ) { TIFFSetField ( in , TIFFTAG_JPEGCOLORMODE , JPEGCOLORMODE_RGB ) ; } else if ( input_photometric == PHOTOMETRIC_YCBCR ) { uint16 subsamplinghor , subsamplingver ; TIFFGetFieldDefaulted ( in , TIFFTAG_YCBCRSUBSAMPLING , & subsamplinghor , & subsamplingver ) ; if ( subsamplinghor != 1 || subsamplingver != 1 ) { fprintf ( stderr , ""tiffcp:<S2SV_blank>%s:<S2SV_blank>Can\'t<S2SV_blank>copy/convert<S2SV_blank>subsampled<S2SV_blank>image.\\n"" , TIFFFileName ( in ) ) ; return FALSE ; } } if ( compression == COMPRESSION_JPEG ) { if ( input_photometric == PHOTOMETRIC_RGB && jpegcolormode == JPEGCOLORMODE_RGB ) TIFFSetField ( out , TIFFTAG_PHOTOMETRIC , PHOTOMETRIC_YCBCR ) ; else TIFFSetField ( out , TIFFTAG_PHOTOMETRIC , input_photometric ) ; } else if ( compression == COMPRESSION_SGILOG || compression == COMPRESSION_SGILOG24 ) TIFFSetField ( out , TIFFTAG_PHOTOMETRIC , samplesperpixel == 1 ? PHOTOMETRIC_LOGL : PHOTOMETRIC_LOGLUV ) ; else if ( input_compression == COMPRESSION_JPEG && samplesperpixel == 3 ) { TIFFSetField ( out , TIFFTAG_PHOTOMETRIC , PHOTOMETRIC_RGB ) ; } else CopyTag ( TIFFTAG_PHOTOMETRIC , 1 , TIFF_SHORT ) ; if ( fillorder != 0 ) TIFFSetField ( out , TIFFTAG_FILLORDER , fillorder ) ; else CopyTag ( TIFFTAG_FILLORDER , 1 , TIFF_SHORT ) ; TIFFGetFieldDefaulted ( in , TIFFTAG_ORIENTATION , & orientation ) ; switch ( orientation ) { case ORIENTATION_BOTRIGHT : case ORIENTATION_RIGHTBOT : TIFFWarning ( TIFFFileName ( in ) , ""using<S2SV_blank>bottom-left<S2SV_blank>orientation"" ) ; orientation = ORIENTATION_BOTLEFT ; case ORIENTATION_LEFTBOT : case ORIENTATION_BOTLEFT : break ; case ORIENTATION_TOPRIGHT : case ORIENTATION_RIGHTTOP : default : TIFFWarning ( TIFFFileName ( in ) , ""using<S2SV_blank>top-left<S2SV_blank>orientation"" ) ; orientation = ORIENTATION_TOPLEFT ; case ORIENTATION_LEFTTOP : case ORIENTATION_TOPLEFT : break ; } TIFFSetField ( out , TIFFTAG_ORIENTATION , orientation ) ; if ( outtiled == - 1 ) outtiled = TIFFIsTiled ( in ) ; if ( outtiled ) { if ( tilewidth == ( uint32 ) - 1 ) TIFFGetField ( in , TIFFTAG_TILEWIDTH , & tilewidth ) ; if ( tilelength == ( uint32 ) - 1 ) TIFFGetField ( in , TIFFTAG_TILELENGTH , & tilelength ) ; TIFFDefaultTileSize ( out , & tilewidth , & tilelength ) ; TIFFSetField ( out , TIFFTAG_TILEWIDTH , tilewidth ) ; TIFFSetField ( out , TIFFTAG_TILELENGTH , tilelength ) ; } else { if ( rowsperstrip == ( uint32 ) 0 ) { if ( ! TIFFGetField ( in , TIFFTAG_ROWSPERSTRIP , & rowsperstrip ) ) { rowsperstrip = TIFFDefaultStripSize ( out , rowsperstrip ) ; } if ( rowsperstrip > length && rowsperstrip != ( uint32 ) - 1 ) rowsperstrip = length ; } else if ( rowsperstrip == ( uint32 ) - 1 ) rowsperstrip = length ; TIFFSetField ( out , TIFFTAG_ROWSPERSTRIP , rowsperstrip ) ; } if ( config != ( uint16 ) - 1 ) TIFFSetField ( out , TIFFTAG_PLANARCONFIG , config ) ; else CopyField ( TIFFTAG_PLANARCONFIG , config ) ; if ( samplesperpixel <= 4 ) CopyTag ( TIFFTAG_TRANSFERFUNCTION , 4 , TIFF_SHORT ) ; CopyTag ( TIFFTAG_COLORMAP , 4 , TIFF_SHORT ) ; switch ( compression ) { case COMPRESSION_JPEG : TIFFSetField ( out , TIFFTAG_JPEGQUALITY , quality ) ; TIFFSetField ( out , TIFFTAG_JPEGCOLORMODE , jpegcolormode ) ; break ; case COMPRESSION_JBIG : CopyTag ( TIFFTAG_FAXRECVPARAMS , 1 , TIFF_LONG ) ; CopyTag ( TIFFTAG_FAXRECVTIME , 1 , TIFF_LONG ) ; CopyTag ( TIFFTAG_FAXSUBADDRESS , 1 , TIFF_ASCII ) ; CopyTag ( TIFFTAG_FAXDCS , 1 , TIFF_ASCII ) ; break ; case COMPRESSION_LZW : case COMPRESSION_ADOBE_DEFLATE : case COMPRESSION_DEFLATE : case COMPRESSION_LZMA : if ( predictor != ( uint16 ) - 1 ) TIFFSetField ( out , TIFFTAG_PREDICTOR , predictor ) ; else CopyField ( TIFFTAG_PREDICTOR , predictor ) ; if ( preset != - 1 ) { if ( compression == COMPRESSION_ADOBE_DEFLATE || compression == COMPRESSION_DEFLATE ) TIFFSetField ( out , TIFFTAG_ZIPQUALITY , preset ) ; else if ( compression == COMPRESSION_LZMA ) TIFFSetField ( out , TIFFTAG_LZMAPRESET , preset ) ; } break ; case COMPRESSION_CCITTFAX3 : case COMPRESSION_CCITTFAX4 : if ( compression == COMPRESSION_CCITTFAX3 ) { if ( g3opts != ( uint32 ) - 1 ) TIFFSetField ( out , TIFFTAG_GROUP3OPTIONS , g3opts ) ; else CopyField ( TIFFTAG_GROUP3OPTIONS , g3opts ) ; } else CopyTag ( TIFFTAG_GROUP4OPTIONS , 1 , TIFF_LONG ) ; CopyTag ( TIFFTAG_BADFAXLINES , 1 , TIFF_LONG ) ; CopyTag ( TIFFTAG_CLEANFAXDATA , 1 , TIFF_LONG ) ; CopyTag ( TIFFTAG_CONSECUTIVEBADFAXLINES , 1 , TIFF_LONG ) ; CopyTag ( TIFFTAG_FAXRECVPARAMS , 1 , TIFF_LONG ) ; CopyTag ( TIFFTAG_FAXRECVTIME , 1 , TIFF_LONG ) ; CopyTag ( TIFFTAG_FAXSUBADDRESS , 1 , TIFF_ASCII ) ; break ; } { uint32 len32 ; void * * data ; if ( TIFFGetField ( in , TIFFTAG_ICCPROFILE , & len32 , & data ) ) TIFFSetField ( out , TIFFTAG_ICCPROFILE , len32 , data ) ; } { uint16 ninks ; const char * inknames ; if ( TIFFGetField ( in , TIFFTAG_NUMBEROFINKS , & ninks ) ) { TIFFSetField ( out , TIFFTAG_NUMBEROFINKS , ninks ) ; if ( TIFFGetField ( in , TIFFTAG_INKNAMES , & inknames ) ) { int inknameslen = strlen ( inknames ) + 1 ; const char * cp = inknames ; while ( ninks > 1 ) { cp = strchr ( cp , '\\0' ) ; cp ++ ; inknameslen += ( strlen ( cp ) + 1 ) ; ninks -- ; } TIFFSetField ( out , TIFFTAG_INKNAMES , inknameslen , inknames ) ; } } } { unsigned short pg0 , pg1 ; if ( pageInSeq == 1 ) { if ( pageNum < 0 ) { if ( TIFFGetField ( in , TIFFTAG_PAGENUMBER , & pg0 , & pg1 ) ) TIFFSetField ( out , TIFFTAG_PAGENUMBER , pg0 , pg1 ) ; } else TIFFSetField ( out , TIFFTAG_PAGENUMBER , pageNum ++ , 0 ) ; } else { if ( TIFFGetField ( in , TIFFTAG_PAGENUMBER , & pg0 , & pg1 ) ) { if ( pageNum < 0 ) TIFFSetField ( out , TIFFTAG_PAGENUMBER , pg0 , pg1 ) ; else TIFFSetField ( out , TIFFTAG_PAGENUMBER , pageNum ++ , 0 ) ; } } } for ( p = tags ; p < & tags [ NTAGS ] ; p ++ ) CopyTag ( p -> tag , p -> count , p -> type ) ; cf = pickCopyFunc ( in , out , bitspersample , samplesperpixel ) ; return ( cf ? ( * cf ) ( in , out , length , width , samplesperpixel ) : FALSE ) ; }",{ uint16 bitspersample = 1
436,"void vp8mt_de_alloc_temp_buffers ( VP8D_COMP * pbi , int mb_rows ) { int i ; <S2SV_StartBug> if ( pbi -> b_multithreaded_rd ) <S2SV_EndBug> { vpx_free ( pbi -> mt_current_mb_col ) ; pbi -> mt_current_mb_col = NULL ; if ( pbi -> mt_yabove_row ) <S2SV_StartBug> { <S2SV_EndBug> for ( i = 0 ; i < mb_rows ; i ++ ) { vpx_free ( pbi -> mt_yabove_row [ i ] ) ; pbi -> mt_yabove_row [ i ] = NULL ; } vpx_free ( pbi -> mt_yabove_row ) ; pbi -> mt_yabove_row = NULL ; } if ( pbi -> mt_uabove_row ) <S2SV_StartBug> { <S2SV_EndBug> for ( i = 0 ; i < mb_rows ; i ++ ) { vpx_free ( pbi -> mt_uabove_row [ i ] ) ; pbi -> mt_uabove_row [ i ] = NULL ; } vpx_free ( pbi -> mt_uabove_row ) ; pbi -> mt_uabove_row = NULL ; } if ( pbi -> mt_vabove_row ) <S2SV_StartBug> { <S2SV_EndBug> for ( i = 0 ; i < mb_rows ; i ++ ) { vpx_free ( pbi -> mt_vabove_row [ i ] ) ; pbi -> mt_vabove_row [ i ] = NULL ; } vpx_free ( pbi -> mt_vabove_row ) ; pbi -> mt_vabove_row = NULL ; } if ( pbi -> mt_yleft_col ) <S2SV_StartBug> { <S2SV_EndBug> for ( i = 0 ; i < mb_rows ; i ++ ) { vpx_free ( pbi -> mt_yleft_col [ i ] ) ; pbi -> mt_yleft_col [ i ] = NULL ; } vpx_free ( pbi -> mt_yleft_col ) ; pbi -> mt_yleft_col = NULL ; } if ( pbi -> mt_uleft_col ) <S2SV_StartBug> { <S2SV_EndBug> for ( i = 0 ; i < mb_rows ; i ++ ) { vpx_free ( pbi -> mt_uleft_col [ i ] ) ; pbi -> mt_uleft_col [ i ] = NULL ; } vpx_free ( pbi -> mt_uleft_col ) ; pbi -> mt_uleft_col = NULL ; } if ( pbi -> mt_vleft_col ) <S2SV_StartBug> { <S2SV_EndBug> for ( i = 0 ; i < mb_rows ; i ++ ) { vpx_free ( pbi -> mt_vleft_col [ i ] ) ; pbi -> mt_vleft_col [ i ] = NULL ; } vpx_free ( pbi -> mt_vleft_col ) ; pbi -> mt_vleft_col = NULL ; } } <S2SV_StartBug> } <S2SV_EndBug>",int i ; <S2SV_ModEnd> vpx_free ( pbi <S2SV_ModStart> -> mt_yabove_row ) { for ( i = 0 ; i < mb_rows ; ++ i ) <S2SV_ModEnd> { vpx_free ( <S2SV_ModStart> -> mt_uabove_row ) { for ( i = 0 ; i < mb_rows ; ++ i ) <S2SV_ModEnd> { vpx_free ( <S2SV_ModStart> -> mt_vabove_row ) { for ( i = 0 ; i < mb_rows ; ++ i ) <S2SV_ModEnd> { vpx_free ( <S2SV_ModStart> -> mt_yleft_col ) { for ( i = 0 ; i < mb_rows ; ++ i ) <S2SV_ModEnd> { vpx_free ( <S2SV_ModStart> -> mt_uleft_col ) { for ( i = 0 ; i < mb_rows ; ++ i ) <S2SV_ModEnd> { vpx_free ( <S2SV_ModStart> -> mt_vleft_col ) { for ( i = 0 ; i < mb_rows ; ++ i ) <S2SV_ModEnd> { vpx_free ( <S2SV_ModStart> ; } } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
437,"FepClient * fep_client_open ( const char * address ) { FepClient * client ; struct sockaddr_un sun ; ssize_t sun_len ; int retval ; if ( ! address ) address = getenv ( ""LIBFEP_CONTROL_SOCK"" ) ; if ( ! address ) return NULL ; if ( strlen ( address ) + 1 >= sizeof ( sun . sun_path ) ) { fep_log ( FEP_LOG_LEVEL_WARNING , ""unix<S2SV_blank>domain<S2SV_blank>socket<S2SV_blank>path<S2SV_blank>too<S2SV_blank>long:<S2SV_blank>%d<S2SV_blank>+<S2SV_blank>1<S2SV_blank>>=<S2SV_blank>%d"" , strlen ( address ) , sizeof ( sun . sun_path ) ) ; free ( address ) ; return NULL ; } client = xzalloc ( sizeof ( FepClient ) ) ; client -> filter_running = false ; client -> messages = NULL ; memset ( & sun , 0 , sizeof ( struct sockaddr_un ) ) ; sun . sun_family = AF_UNIX ; <S2SV_StartBug> # ifdef __linux__ <S2SV_EndBug> <S2SV_StartBug> sun . sun_path [ 0 ] = '\\0' ; <S2SV_EndBug> memcpy ( sun . sun_path + 1 , address , strlen ( address ) ) ; <S2SV_StartBug> sun_len = offsetof ( struct sockaddr_un , sun_path ) + strlen ( address ) + 1 ; <S2SV_EndBug> # else memcpy ( sun . sun_path , address , strlen ( address ) ) ; sun_len = sizeof ( struct sockaddr_un ) ; # endif client -> control = socket ( AF_UNIX , SOCK_STREAM , 0 ) ; if ( client -> control < 0 ) { free ( client ) ; return NULL ; } retval = connect ( client -> control , ( const struct sockaddr * ) & sun , sun_len ) ; if ( retval < 0 ) { close ( client -> control ) ; free ( client ) ; return NULL ; } return client ; }","= AF_UNIX ; memcpy ( <S2SV_ModEnd> sun . sun_path <S2SV_ModStart> sun . sun_path <S2SV_ModEnd> , address , <S2SV_ModStart> ; sun_len = sizeof <S2SV_ModEnd> ( struct sockaddr_un <S2SV_ModStart> ( struct sockaddr_un ) ; <S2SV_ModEnd> client -> control"
438,"static int crypto_report_cipher ( struct sk_buff * skb , struct crypto_alg * alg ) { struct crypto_report_cipher rcipher ; <S2SV_StartBug> snprintf ( rcipher . type , CRYPTO_MAX_ALG_NAME , ""%s"" , ""cipher"" ) ; <S2SV_EndBug> rcipher . blocksize = alg -> cra_blocksize ; rcipher . min_keysize = alg -> cra_cipher . cia_min_keysize ; rcipher . max_keysize = alg -> cra_cipher . cia_max_keysize ; if ( nla_put ( skb , CRYPTOCFGA_REPORT_CIPHER , sizeof ( struct crypto_report_cipher ) , & rcipher ) ) goto nla_put_failure ; return 0 ; nla_put_failure : return - EMSGSIZE ; }","crypto_report_cipher rcipher ; strncpy <S2SV_ModEnd> ( rcipher . <S2SV_ModStart> . type , ""cipher"" , sizeof ( rcipher . type ) <S2SV_ModEnd> ) ; rcipher"
439,"static void dhcp6opt_print ( netdissect_options * ndo , const u_char * cp , const u_char * ep ) { const struct dhcp6opt * dh6o ; const u_char * tp ; size_t i ; uint16_t opttype ; size_t optlen ; uint8_t auth_proto ; u_int authinfolen , authrealmlen ; int remain_len ; int label_len ; uint16_t subopt_code ; uint16_t subopt_len ; if ( cp == ep ) return ; while ( cp < ep ) { if ( ep < cp + sizeof ( * dh6o ) ) goto trunc ; dh6o = ( const struct dhcp6opt * ) cp ; ND_TCHECK ( * dh6o ) ; optlen = EXTRACT_16BITS ( & dh6o -> dh6opt_len ) ; if ( ep < cp + sizeof ( * dh6o ) + optlen ) goto trunc ; opttype = EXTRACT_16BITS ( & dh6o -> dh6opt_type ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>(%s"" , tok2str ( dh6opt_str , ""opt_%u"" , opttype ) ) ) ; ND_TCHECK2 ( * ( cp + sizeof ( * dh6o ) ) , optlen ) ; switch ( opttype ) { case DH6OPT_CLIENTID : case DH6OPT_SERVERID : if ( optlen < 2 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>?)"" ) ) ; break ; } tp = ( const u_char * ) ( dh6o + 1 ) ; switch ( EXTRACT_16BITS ( tp ) ) { case 1 : if ( optlen >= 2 + 6 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>hwaddr/time<S2SV_blank>type<S2SV_blank>%u<S2SV_blank>time<S2SV_blank>%u<S2SV_blank>"" , EXTRACT_16BITS ( & tp [ 2 ] ) , EXTRACT_32BITS ( & tp [ 4 ] ) ) ) ; for ( i = 8 ; i < optlen ; i ++ ) ND_PRINT ( ( ndo , ""%02x"" , tp [ i ] ) ) ; ND_PRINT ( ( ndo , "")"" ) ) ; } else { ND_PRINT ( ( ndo , ""<S2SV_blank>?)"" ) ) ; } break ; case 2 : if ( optlen >= 2 + 8 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>vid<S2SV_blank>"" ) ) ; for ( i = 2 ; i < 2 + 8 ; i ++ ) ND_PRINT ( ( ndo , ""%02x"" , tp [ i ] ) ) ; ND_PRINT ( ( ndo , "")"" ) ) ; } else { ND_PRINT ( ( ndo , ""<S2SV_blank>?)"" ) ) ; } break ; case 3 : if ( optlen >= 2 + 2 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>hwaddr<S2SV_blank>type<S2SV_blank>%u<S2SV_blank>"" , EXTRACT_16BITS ( & tp [ 2 ] ) ) ) ; for ( i = 4 ; i < optlen ; i ++ ) ND_PRINT ( ( ndo , ""%02x"" , tp [ i ] ) ) ; ND_PRINT ( ( ndo , "")"" ) ) ; } else { ND_PRINT ( ( ndo , ""<S2SV_blank>?)"" ) ) ; } break ; default : ND_PRINT ( ( ndo , ""<S2SV_blank>type<S2SV_blank>%d)"" , EXTRACT_16BITS ( tp ) ) ) ; break ; } break ; case DH6OPT_IA_ADDR : if ( optlen < 24 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>?)"" ) ) ; break ; } tp = ( const u_char * ) ( dh6o + 1 ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%s"" , ip6addr_string ( ndo , & tp [ 0 ] ) ) ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>pltime:%u<S2SV_blank>vltime:%u"" , EXTRACT_32BITS ( & tp [ 16 ] ) , EXTRACT_32BITS ( & tp [ 20 ] ) ) ) ; if ( optlen > 24 ) { dhcp6opt_print ( ndo , tp + 24 , tp + optlen ) ; } ND_PRINT ( ( ndo , "")"" ) ) ; break ; case DH6OPT_ORO : case DH6OPT_ERO : if ( optlen % 2 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>?)"" ) ) ; break ; } tp = ( const u_char * ) ( dh6o + 1 ) ; for ( i = 0 ; i < optlen ; i += 2 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>%s"" , tok2str ( dh6opt_str , ""opt_%u"" , EXTRACT_16BITS ( & tp [ i ] ) ) ) ) ; } ND_PRINT ( ( ndo , "")"" ) ) ; break ; case DH6OPT_PREFERENCE : if ( optlen != 1 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>?)"" ) ) ; break ; } tp = ( const u_char * ) ( dh6o + 1 ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%d)"" , * tp ) ) ; break ; case DH6OPT_ELAPSED_TIME : if ( optlen != 2 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>?)"" ) ) ; break ; } tp = ( const u_char * ) ( dh6o + 1 ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%d)"" , EXTRACT_16BITS ( tp ) ) ) ; break ; case DH6OPT_RELAY_MSG : ND_PRINT ( ( ndo , ""<S2SV_blank>("" ) ) ; tp = ( const u_char * ) ( dh6o + 1 ) ; dhcp6_print ( ndo , tp , optlen ) ; ND_PRINT ( ( ndo , "")"" ) ) ; break ; case DH6OPT_AUTH : if ( optlen < 11 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>?)"" ) ) ; break ; } tp = ( const u_char * ) ( dh6o + 1 ) ; auth_proto = * tp ; switch ( auth_proto ) { case DH6OPT_AUTHPROTO_DELAYED : ND_PRINT ( ( ndo , ""<S2SV_blank>proto:<S2SV_blank>delayed"" ) ) ; break ; case DH6OPT_AUTHPROTO_RECONFIG : ND_PRINT ( ( ndo , ""<S2SV_blank>proto:<S2SV_blank>reconfigure"" ) ) ; break ; default : ND_PRINT ( ( ndo , ""<S2SV_blank>proto:<S2SV_blank>%d"" , auth_proto ) ) ; break ; } tp ++ ; switch ( * tp ) { case DH6OPT_AUTHALG_HMACMD5 : ND_PRINT ( ( ndo , "",<S2SV_blank>alg:<S2SV_blank>HMAC-MD5"" ) ) ; break ; default : ND_PRINT ( ( ndo , "",<S2SV_blank>alg:<S2SV_blank>%d"" , * tp ) ) ; break ; } tp ++ ; switch ( * tp ) { case DH6OPT_AUTHRDM_MONOCOUNTER : ND_PRINT ( ( ndo , "",<S2SV_blank>RDM:<S2SV_blank>mono"" ) ) ; break ; default : ND_PRINT ( ( ndo , "",<S2SV_blank>RDM:<S2SV_blank>%d"" , * tp ) ) ; break ; } tp ++ ; ND_PRINT ( ( ndo , "",<S2SV_blank>RD:"" ) ) ; for ( i = 0 ; i < 4 ; i ++ , tp += 2 ) ND_PRINT ( ( ndo , ""<S2SV_blank>%04x"" , EXTRACT_16BITS ( tp ) ) ) ; authinfolen = optlen - 11 ; switch ( auth_proto ) { case DH6OPT_AUTHPROTO_DELAYED : if ( authinfolen == 0 ) break ; if ( authinfolen < 20 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>??"" ) ) ; break ; } authrealmlen = authinfolen - 20 ; if ( authrealmlen > 0 ) { ND_PRINT ( ( ndo , "",<S2SV_blank>realm:<S2SV_blank>"" ) ) ; } for ( i = 0 ; i < authrealmlen ; i ++ , tp ++ ) ND_PRINT ( ( ndo , ""%02x"" , * tp ) ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>key<S2SV_blank>ID:<S2SV_blank>%08x"" , EXTRACT_32BITS ( tp ) ) ) ; tp += 4 ; ND_PRINT ( ( ndo , "",<S2SV_blank>HMAC-MD5:"" ) ) ; for ( i = 0 ; i < 4 ; i ++ , tp += 4 ) ND_PRINT ( ( ndo , ""<S2SV_blank>%08x"" , EXTRACT_32BITS ( tp ) ) ) ; break ; case DH6OPT_AUTHPROTO_RECONFIG : if ( authinfolen != 17 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>??"" ) ) ; break ; } switch ( * tp ++ ) { case DH6OPT_AUTHRECONFIG_KEY : ND_PRINT ( ( ndo , ""<S2SV_blank>reconfig-key"" ) ) ; break ; case DH6OPT_AUTHRECONFIG_HMACMD5 : ND_PRINT ( ( ndo , ""<S2SV_blank>type:<S2SV_blank>HMAC-MD5"" ) ) ; break ; default : ND_PRINT ( ( ndo , ""<S2SV_blank>type:<S2SV_blank>??"" ) ) ; break ; } ND_PRINT ( ( ndo , ""<S2SV_blank>value:"" ) ) ; for ( i = 0 ; i < 4 ; i ++ , tp += 4 ) ND_PRINT ( ( ndo , ""<S2SV_blank>%08x"" , EXTRACT_32BITS ( tp ) ) ) ; break ; default : ND_PRINT ( ( ndo , ""<S2SV_blank>??"" ) ) ; break ; } ND_PRINT ( ( ndo , "")"" ) ) ; break ; case DH6OPT_RAPID_COMMIT : ND_PRINT ( ( ndo , "")"" ) ) ; break ; case DH6OPT_INTERFACE_ID : case DH6OPT_SUBSCRIBER_ID : tp = ( const u_char * ) ( dh6o + 1 ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ; for ( i = 0 ; i < optlen && i < 10 ; i ++ ) ND_PRINT ( ( ndo , ""%02x"" , tp [ i ] ) ) ; ND_PRINT ( ( ndo , ""...)"" ) ) ; break ; <S2SV_StartBug> case DH6OPT_RECONF_MSG : <S2SV_EndBug> tp = ( const u_char * ) ( dh6o + 1 ) ; switch ( * tp ) { case DH6_RENEW : ND_PRINT ( ( ndo , ""<S2SV_blank>for<S2SV_blank>renew)"" ) ) ; break ; case DH6_INFORM_REQ : ND_PRINT ( ( ndo , ""<S2SV_blank>for<S2SV_blank>inf-req)"" ) ) ; break ; default : ND_PRINT ( ( ndo , ""<S2SV_blank>for<S2SV_blank>?\\?\\?(%02x))"" , * tp ) ) ; break ; } break ; case DH6OPT_RECONF_ACCEPT : ND_PRINT ( ( ndo , "")"" ) ) ; break ; case DH6OPT_SIP_SERVER_A : case DH6OPT_DNS_SERVERS : case DH6OPT_SNTP_SERVERS : case DH6OPT_NIS_SERVERS : case DH6OPT_NISP_SERVERS : case DH6OPT_BCMCS_SERVER_A : case DH6OPT_PANA_AGENT : case DH6OPT_LQ_CLIENT_LINK : if ( optlen % 16 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>?)"" ) ) ; break ; } tp = ( const u_char * ) ( dh6o + 1 ) ; for ( i = 0 ; i < optlen ; i += 16 ) ND_PRINT ( ( ndo , ""<S2SV_blank>%s"" , ip6addr_string ( ndo , & tp [ i ] ) ) ) ; ND_PRINT ( ( ndo , "")"" ) ) ; break ; case DH6OPT_SIP_SERVER_D : case DH6OPT_DOMAIN_LIST : tp = ( const u_char * ) ( dh6o + 1 ) ; while ( tp < cp + sizeof ( * dh6o ) + optlen ) { ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ; if ( ( tp = ns_nprint ( ndo , tp , cp + sizeof ( * dh6o ) + optlen ) ) == NULL ) goto trunc ; } ND_PRINT ( ( ndo , "")"" ) ) ; break ; case DH6OPT_STATUS_CODE : if ( optlen < 2 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>?)"" ) ) ; break ; } tp = ( const u_char * ) ( dh6o + 1 ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%s)"" , dhcp6stcode ( EXTRACT_16BITS ( & tp [ 0 ] ) ) ) ) ; break ; case DH6OPT_IA_NA : case DH6OPT_IA_PD : if ( optlen < 12 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>?)"" ) ) ; break ; } tp = ( const u_char * ) ( dh6o + 1 ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>IAID:%u<S2SV_blank>T1:%u<S2SV_blank>T2:%u"" , EXTRACT_32BITS ( & tp [ 0 ] ) , EXTRACT_32BITS ( & tp [ 4 ] ) , EXTRACT_32BITS ( & tp [ 8 ] ) ) ) ; if ( optlen > 12 ) { dhcp6opt_print ( ndo , tp + 12 , tp + optlen ) ; } ND_PRINT ( ( ndo , "")"" ) ) ; break ; case DH6OPT_IA_TA : if ( optlen < 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>?)"" ) ) ; break ; } tp = ( const u_char * ) ( dh6o + 1 ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>IAID:%u"" , EXTRACT_32BITS ( tp ) ) ) ; if ( optlen > 4 ) { dhcp6opt_print ( ndo , tp + 4 , tp + optlen ) ; } ND_PRINT ( ( ndo , "")"" ) ) ; break ; case DH6OPT_IA_PD_PREFIX : if ( optlen < 25 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>?)"" ) ) ; break ; } tp = ( const u_char * ) ( dh6o + 1 ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%s/%d"" , ip6addr_string ( ndo , & tp [ 9 ] ) , tp [ 8 ] ) ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>pltime:%u<S2SV_blank>vltime:%u"" , EXTRACT_32BITS ( & tp [ 0 ] ) , EXTRACT_32BITS ( & tp [ 4 ] ) ) ) ; if ( optlen > 25 ) { dhcp6opt_print ( ndo , tp + 25 , tp + optlen ) ; } ND_PRINT ( ( ndo , "")"" ) ) ; break ; case DH6OPT_LIFETIME : case DH6OPT_CLT_TIME : if ( optlen != 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>?)"" ) ) ; break ; } tp = ( const u_char * ) ( dh6o + 1 ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%d)"" , EXTRACT_32BITS ( tp ) ) ) ; break ; case DH6OPT_REMOTE_ID : if ( optlen < 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>?)"" ) ) ; break ; } tp = ( const u_char * ) ( dh6o + 1 ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%d<S2SV_blank>"" , EXTRACT_32BITS ( tp ) ) ) ; for ( i = 4 ; i < optlen && i < 14 ; i ++ ) ND_PRINT ( ( ndo , ""%02x"" , tp [ i ] ) ) ; ND_PRINT ( ( ndo , ""...)"" ) ) ; break ; case DH6OPT_LQ_QUERY : if ( optlen < 17 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>?)"" ) ) ; break ; } tp = ( const u_char * ) ( dh6o + 1 ) ; switch ( * tp ) { case 1 : ND_PRINT ( ( ndo , ""<S2SV_blank>by-address"" ) ) ; break ; case 2 : ND_PRINT ( ( ndo , ""<S2SV_blank>by-clientID"" ) ) ; break ; default : ND_PRINT ( ( ndo , ""<S2SV_blank>type_%d"" , ( int ) * tp ) ) ; break ; } ND_PRINT ( ( ndo , ""<S2SV_blank>%s"" , ip6addr_string ( ndo , & tp [ 1 ] ) ) ) ; if ( optlen > 17 ) { dhcp6opt_print ( ndo , tp + 17 , tp + optlen ) ; } ND_PRINT ( ( ndo , "")"" ) ) ; break ; case DH6OPT_CLIENT_DATA : tp = ( const u_char * ) ( dh6o + 1 ) ; if ( optlen > 0 ) { dhcp6opt_print ( ndo , tp , tp + optlen ) ; } ND_PRINT ( ( ndo , "")"" ) ) ; break ; case DH6OPT_LQ_RELAY_DATA : if ( optlen < 16 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>?)"" ) ) ; break ; } tp = ( const u_char * ) ( dh6o + 1 ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%s<S2SV_blank>"" , ip6addr_string ( ndo , & tp [ 0 ] ) ) ) ; for ( i = 16 ; i < optlen && i < 26 ; i ++ ) ND_PRINT ( ( ndo , ""%02x"" , tp [ i ] ) ) ; ND_PRINT ( ( ndo , ""...)"" ) ) ; break ; case DH6OPT_NTP_SERVER : if ( optlen < 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>?)"" ) ) ; break ; } tp = ( const u_char * ) ( dh6o + 1 ) ; while ( tp < cp + sizeof ( * dh6o ) + optlen - 4 ) { subopt_code = EXTRACT_16BITS ( tp ) ; tp += 2 ; subopt_len = EXTRACT_16BITS ( tp ) ; tp += 2 ; if ( tp + subopt_len > cp + sizeof ( * dh6o ) + optlen ) goto trunc ; ND_PRINT ( ( ndo , ""<S2SV_blank>subopt:%d"" , subopt_code ) ) ; switch ( subopt_code ) { case DH6OPT_NTP_SUBOPTION_SRV_ADDR : case DH6OPT_NTP_SUBOPTION_MC_ADDR : if ( subopt_len != 16 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>?"" ) ) ; break ; } ND_PRINT ( ( ndo , ""<S2SV_blank>%s"" , ip6addr_string ( ndo , & tp [ 0 ] ) ) ) ; break ; case DH6OPT_NTP_SUBOPTION_SRV_FQDN : ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ; if ( ns_nprint ( ndo , tp , tp + subopt_len ) == NULL ) goto trunc ; break ; default : ND_PRINT ( ( ndo , ""<S2SV_blank>?"" ) ) ; break ; } tp += subopt_len ; } ND_PRINT ( ( ndo , "")"" ) ) ; break ; case DH6OPT_AFTR_NAME : if ( optlen < 3 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>?)"" ) ) ; break ; } tp = ( const u_char * ) ( dh6o + 1 ) ; remain_len = optlen ; ND_PRINT ( ( ndo , ""<S2SV_blank>"" ) ) ; while ( remain_len && * tp ) { label_len = * tp ++ ; if ( label_len < remain_len - 1 ) { ( void ) fn_printn ( ndo , tp , label_len , NULL ) ; tp += label_len ; remain_len -= ( label_len + 1 ) ; if ( * tp ) ND_PRINT ( ( ndo , ""."" ) ) ; } else { ND_PRINT ( ( ndo , ""<S2SV_blank>?"" ) ) ; break ; } } ND_PRINT ( ( ndo , "")"" ) ) ; break ; case DH6OPT_NEW_POSIX_TIMEZONE : case DH6OPT_NEW_TZDB_TIMEZONE : case DH6OPT_MUDURL : if ( optlen < 5 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>?)"" ) ) ; break ; } tp = ( const u_char * ) ( dh6o + 1 ) ; ND_PRINT ( ( ndo , ""="" ) ) ; ( void ) fn_printn ( ndo , tp , ( u_int ) optlen , NULL ) ; ND_PRINT ( ( ndo , "")"" ) ) ; break ; default : ND_PRINT ( ( ndo , "")"" ) ) ; break ; } cp += sizeof ( * dh6o ) + optlen ; } return ; trunc : ND_PRINT ( ( ndo , ""[|dhcp6ext]"" ) ) ; }","case DH6OPT_RECONF_MSG : if ( optlen != 1 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>?)"" ) ) ; break ; }"
440,"int keepalived_main ( int argc , char * * argv ) { bool report_stopped = true ; struct utsname uname_buf ; char * end ; set_time_now ( ) ; save_cmd_line_options ( argc , argv ) ; debug = 0 ; # ifndef _DEBUG_ prog_type = PROG_TYPE_PARENT ; # endif # ifdef _WITH_VRRP_ __set_bit ( DAEMON_VRRP , & daemon_mode ) ; # endif # ifdef _WITH_LVS_ __set_bit ( DAEMON_CHECKERS , & daemon_mode ) ; # endif # ifdef _WITH_BFD_ __set_bit ( DAEMON_BFD , & daemon_mode ) ; <S2SV_StartBug> # endif <S2SV_EndBug> openlog ( PACKAGE_NAME , LOG_PID , log_facility ) ; # ifdef _MEM_CHECK_ mem_log_init ( PACKAGE_NAME , ""Parent<S2SV_blank>process"" ) ; # endif if ( uname ( & uname_buf ) ) log_message ( LOG_INFO , ""Unable<S2SV_blank>to<S2SV_blank>get<S2SV_blank>uname()<S2SV_blank>information<S2SV_blank>-<S2SV_blank>error<S2SV_blank>%d"" , errno ) ; else { os_major = ( unsigned ) strtoul ( uname_buf . release , & end , 10 ) ; if ( * end != '.' ) os_major = 0 ; else { os_minor = ( unsigned ) strtoul ( end + 1 , & end , 10 ) ; if ( * end != '.' ) os_major = 0 ; else { if ( ! isdigit ( end [ 1 ] ) ) os_major = 0 ; else os_release = ( unsigned ) strtoul ( end + 1 , & end , 10 ) ; } } if ( ! os_major ) log_message ( LOG_INFO , ""Unable<S2SV_blank>to<S2SV_blank>parse<S2SV_blank>kernel<S2SV_blank>version<S2SV_blank>%s"" , uname_buf . release ) ; if ( ! config_id ) { end = strchrnul ( uname_buf . nodename , '.' ) ; config_id = MALLOC ( ( size_t ) ( end - uname_buf . nodename ) + 1 ) ; strncpy ( config_id , uname_buf . nodename , ( size_t ) ( end - uname_buf . nodename ) ) ; config_id [ end - uname_buf . nodename ] = '\\0' ; } } if ( parse_cmdline ( argc , argv ) ) { closelog ( ) ; if ( ! __test_bit ( NO_SYSLOG_BIT , & debug ) ) openlog ( PACKAGE_NAME , LOG_PID | ( ( __test_bit ( LOG_CONSOLE_BIT , & debug ) ) ? LOG_CONS : 0 ) , log_facility ) ; } if ( __test_bit ( LOG_CONSOLE_BIT , & debug ) ) enable_console_log ( ) ; # ifdef GIT_COMMIT log_message ( LOG_INFO , ""Starting<S2SV_blank>%s,<S2SV_blank>git<S2SV_blank>commit<S2SV_blank>%s"" , version_string , GIT_COMMIT ) ; # else log_message ( LOG_INFO , ""Starting<S2SV_blank>%s"" , version_string ) ; # endif core_dump_init ( ) ; if ( os_major ) { if ( KERNEL_VERSION ( os_major , os_minor , os_release ) < LINUX_VERSION_CODE ) { log_message ( LOG_INFO , ""WARNING<S2SV_blank>-<S2SV_blank>keepalived<S2SV_blank>was<S2SV_blank>build<S2SV_blank>for<S2SV_blank>newer<S2SV_blank>Linux<S2SV_blank>%d.%d.%d,<S2SV_blank>running<S2SV_blank>on<S2SV_blank>%s<S2SV_blank>%s<S2SV_blank>%s"" , ( LINUX_VERSION_CODE >> 16 ) & 0xff , ( LINUX_VERSION_CODE >> 8 ) & 0xff , ( LINUX_VERSION_CODE ) & 0xff , uname_buf . sysname , uname_buf . release , uname_buf . version ) ; } else { log_message ( LOG_INFO , ""Running<S2SV_blank>on<S2SV_blank>%s<S2SV_blank>%s<S2SV_blank>%s<S2SV_blank>(built<S2SV_blank>for<S2SV_blank>Linux<S2SV_blank>%d.%d.%d)"" , uname_buf . sysname , uname_buf . release , uname_buf . version , ( LINUX_VERSION_CODE >> 16 ) & 0xff , ( LINUX_VERSION_CODE >> 8 ) & 0xff , ( LINUX_VERSION_CODE ) & 0xff ) ; } } # ifndef _DEBUG_ log_command_line ( 0 ) ; # endif if ( ! check_conf_file ( conf_file ) ) { if ( __test_bit ( CONFIG_TEST_BIT , & debug ) ) config_test_exit ( ) ; goto end ; } global_data = alloc_global_data ( ) ; <S2SV_StartBug> read_config_file ( ) ; <S2SV_EndBug> init_global_data ( global_data , NULL ) ; # if HAVE_DECL_CLONE_NEWNET if ( override_namespace ) { if ( global_data -> network_namespace ) { log_message ( LOG_INFO , ""Overriding<S2SV_blank>config<S2SV_blank>net_namespace<S2SV_blank>\'%s\'<S2SV_blank>with<S2SV_blank>command<S2SV_blank>line<S2SV_blank>namespace<S2SV_blank>\'%s\'"" , global_data -> network_namespace , override_namespace ) ; FREE ( global_data -> network_namespace ) ; } global_data -> network_namespace = override_namespace ; override_namespace = NULL ; } # endif if ( ! __test_bit ( CONFIG_TEST_BIT , & debug ) && ( global_data -> instance_name # if HAVE_DECL_CLONE_NEWNET || global_data -> network_namespace # endif ) ) { if ( ( syslog_ident = make_syslog_ident ( PACKAGE_NAME ) ) ) { log_message ( LOG_INFO , ""Changing<S2SV_blank>syslog<S2SV_blank>ident<S2SV_blank>to<S2SV_blank>%s"" , syslog_ident ) ; closelog ( ) ; openlog ( syslog_ident , LOG_PID | ( ( __test_bit ( LOG_CONSOLE_BIT , & debug ) ) ? LOG_CONS : 0 ) , log_facility ) ; } else log_message ( LOG_INFO , ""Unable<S2SV_blank>to<S2SV_blank>change<S2SV_blank>syslog<S2SV_blank>ident"" ) ; use_pid_dir = true ; open_log_file ( log_file_name , NULL , # if HAVE_DECL_CLONE_NEWNET global_data -> network_namespace , # else NULL , # endif global_data -> instance_name ) ; } set_child_finder_name ( find_keepalived_child_name ) ; if ( ! __test_bit ( CONFIG_TEST_BIT , & debug ) ) { if ( use_pid_dir ) { create_pid_dir ( ) ; } } # if HAVE_DECL_CLONE_NEWNET if ( global_data -> network_namespace ) { if ( global_data -> network_namespace && ! set_namespaces ( global_data -> network_namespace ) ) { log_message ( LOG_ERR , ""Unable<S2SV_blank>to<S2SV_blank>set<S2SV_blank>network<S2SV_blank>namespace<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>exiting"" , global_data -> network_namespace ) ; goto end ; } } # endif if ( ! __test_bit ( CONFIG_TEST_BIT , & debug ) ) { if ( global_data -> instance_name ) { if ( ! main_pidfile && ( main_pidfile = make_pidfile_name ( KEEPALIVED_PID_DIR KEEPALIVED_PID_FILE , global_data -> instance_name , PID_EXTENSION ) ) ) free_main_pidfile = true ; # ifdef _WITH_LVS_ if ( ! checkers_pidfile && ( checkers_pidfile = make_pidfile_name ( KEEPALIVED_PID_DIR CHECKERS_PID_FILE , global_data -> instance_name , PID_EXTENSION ) ) ) free_checkers_pidfile = true ; # endif # ifdef _WITH_VRRP_ if ( ! vrrp_pidfile && ( vrrp_pidfile = make_pidfile_name ( KEEPALIVED_PID_DIR VRRP_PID_FILE , global_data -> instance_name , PID_EXTENSION ) ) ) free_vrrp_pidfile = true ; # endif # ifdef _WITH_BFD_ if ( ! bfd_pidfile && ( bfd_pidfile = make_pidfile_name ( KEEPALIVED_PID_DIR VRRP_PID_FILE , global_data -> instance_name , PID_EXTENSION ) ) ) free_bfd_pidfile = true ; # endif } if ( use_pid_dir ) { if ( ! main_pidfile ) main_pidfile = KEEPALIVED_PID_DIR KEEPALIVED_PID_FILE PID_EXTENSION ; # ifdef _WITH_LVS_ if ( ! checkers_pidfile ) checkers_pidfile = KEEPALIVED_PID_DIR CHECKERS_PID_FILE PID_EXTENSION ; # endif # ifdef _WITH_VRRP_ if ( ! vrrp_pidfile ) vrrp_pidfile = KEEPALIVED_PID_DIR VRRP_PID_FILE PID_EXTENSION ; # endif # ifdef _WITH_BFD_ if ( ! bfd_pidfile ) bfd_pidfile = KEEPALIVED_PID_DIR BFD_PID_FILE PID_EXTENSION ; # endif } else { if ( ! main_pidfile ) main_pidfile = PID_DIR KEEPALIVED_PID_FILE PID_EXTENSION ; # ifdef _WITH_LVS_ if ( ! checkers_pidfile ) checkers_pidfile = PID_DIR CHECKERS_PID_FILE PID_EXTENSION ; # endif # ifdef _WITH_VRRP_ if ( ! vrrp_pidfile ) vrrp_pidfile = PID_DIR VRRP_PID_FILE PID_EXTENSION ; # endif # ifdef _WITH_BFD_ if ( ! bfd_pidfile ) bfd_pidfile = PID_DIR BFD_PID_FILE PID_EXTENSION ; # endif } if ( keepalived_running ( daemon_mode ) ) { log_message ( LOG_INFO , ""daemon<S2SV_blank>is<S2SV_blank>already<S2SV_blank>running"" ) ; report_stopped = false ; goto end ; } } if ( ! __test_bit ( DONT_FORK_BIT , & debug ) && xdaemon ( false , false , true ) > 0 ) { closelog ( ) ; FREE_PTR ( config_id ) ; FREE_PTR ( orig_core_dump_pattern ) ; close_std_fd ( ) ; exit ( 0 ) ; } <S2SV_StartBug> umask ( 0 ) ; <S2SV_EndBug> # ifdef _MEM_CHECK_ enable_mem_log_termination ( ) ; # endif if ( __test_bit ( CONFIG_TEST_BIT , & debug ) ) { validate_config ( ) ; config_test_exit ( ) ; } if ( ! pidfile_write ( main_pidfile , getpid ( ) ) ) goto end ; master = thread_make_master ( ) ; signal_init ( ) ; if ( ! start_keepalived ( ) ) log_message ( LOG_INFO , ""Warning<S2SV_blank>-<S2SV_blank>keepalived<S2SV_blank>has<S2SV_blank>no<S2SV_blank>configuration<S2SV_blank>to<S2SV_blank>run"" ) ; initialise_debug_options ( ) ; # ifdef THREAD_DUMP register_parent_thread_addresses ( ) ; # endif launch_thread_scheduler ( master ) ; stop_keepalived ( ) ; # ifdef THREAD_DUMP deregister_thread_addresses ( ) ; # endif end : if ( report_stopped ) { # ifdef GIT_COMMIT log_message ( LOG_INFO , ""Stopped<S2SV_blank>%s,<S2SV_blank>git<S2SV_blank>commit<S2SV_blank>%s"" , version_string , GIT_COMMIT ) ; # else log_message ( LOG_INFO , ""Stopped<S2SV_blank>%s"" , version_string ) ; # endif } # if HAVE_DECL_CLONE_NEWNET if ( global_data && global_data -> network_namespace ) clear_namespaces ( ) ; # endif if ( use_pid_dir ) remove_pid_dir ( ) ; if ( orig_core_dump_pattern ) update_core_dump_pattern ( orig_core_dump_pattern ) ; free_parent_mallocs_startup ( false ) ; free_parent_mallocs_exit ( ) ; free_global_data ( global_data ) ; closelog ( ) ; # ifndef _MEM_CHECK_LOG_ FREE_PTR ( syslog_ident ) ; # else if ( syslog_ident ) free ( syslog_ident ) ; # endif close_std_fd ( ) ; exit ( KEEPALIVED_EXIT_OK ) ; }",; # endif umask ( 022 ) ; <S2SV_ModStart> ( ) ; global_data -> umask = umask_val ; <S2SV_ModStart> ) ; } <S2SV_ModEnd> # ifdef _MEM_CHECK_
441,"static int mp_capable_print ( netdissect_options * ndo , const u_char * opt , u_int opt_len , u_char flags ) { const struct mp_capable * mpc = ( const struct mp_capable * ) opt ; <S2SV_StartBug> if ( ! ( opt_len == 12 && flags & TH_SYN ) && <S2SV_EndBug> ! ( opt_len == 20 && ( flags & ( TH_SYN | TH_ACK ) ) == TH_ACK ) ) return 0 ; if ( MP_CAPABLE_OPT_VERSION ( mpc -> sub_ver ) != 0 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>Unknown<S2SV_blank>Version<S2SV_blank>(%d)"" , MP_CAPABLE_OPT_VERSION ( mpc -> sub_ver ) ) ) ; return 1 ; } if ( mpc -> flags & MP_CAPABLE_C ) ND_PRINT ( ( ndo , ""<S2SV_blank>csum"" ) ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>{0x%"" PRIx64 , EXTRACT_64BITS ( mpc -> sender_key ) ) ) ; if ( opt_len == 20 ) ND_PRINT ( ( ndo , "",0x%"" PRIx64 , EXTRACT_64BITS ( mpc -> receiver_key ) ) ) ; ND_PRINT ( ( ndo , ""}"" ) ) ; return 1 ; }",== 12 && ( <S2SV_ModStart> flags & TH_SYN )
442,"<S2SV_StartBug> static void encode_unsigned_max ( struct vp9_write_bit_buffer * wb , <S2SV_EndBug> int data , int max ) { <S2SV_StartBug> vp9_wb_write_literal ( wb , data , get_unsigned_bits ( max ) ) ; <S2SV_EndBug> }","encode_unsigned_max ( struct vpx_write_bit_buffer <S2SV_ModEnd> * wb , <S2SV_ModStart> max ) { vpx_wb_write_literal <S2SV_ModEnd> ( wb ,"
443,"int hfsplus_rename_cat ( u32 cnid , struct inode * src_dir , struct qstr * src_name , struct inode * dst_dir , struct qstr * dst_name ) { struct super_block * sb = src_dir -> i_sb ; struct hfs_find_data src_fd , dst_fd ; hfsplus_cat_entry entry ; int entry_size , type ; int err ; dprint ( DBG_CAT_MOD , ""rename_cat:<S2SV_blank>%u<S2SV_blank>-<S2SV_blank>%lu,%s<S2SV_blank>-<S2SV_blank>%lu,%s\\n"" , cnid , src_dir -> i_ino , src_name -> name , dst_dir -> i_ino , dst_name -> name ) ; err = hfs_find_init ( HFSPLUS_SB ( sb ) -> cat_tree , & src_fd ) ; if ( err ) return err ; dst_fd = src_fd ; hfsplus_cat_build_key ( sb , src_fd . search_key , src_dir -> i_ino , src_name ) ; err = hfs_brec_find ( & src_fd ) ; if ( err ) goto out ; <S2SV_StartBug> hfs_bnode_read ( src_fd . bnode , & entry , src_fd . entryoffset , <S2SV_EndBug> src_fd . entrylength ) ; hfsplus_cat_build_key ( sb , dst_fd . search_key , dst_dir -> i_ino , dst_name ) ; err = hfs_brec_find ( & dst_fd ) ; if ( err != - ENOENT ) { if ( ! err ) err = - EEXIST ; goto out ; } err = hfs_brec_insert ( & dst_fd , & entry , src_fd . entrylength ) ; if ( err ) goto out ; dst_dir -> i_size ++ ; dst_dir -> i_mtime = dst_dir -> i_ctime = CURRENT_TIME_SEC ; hfsplus_cat_build_key ( sb , src_fd . search_key , src_dir -> i_ino , src_name ) ; err = hfs_brec_find ( & src_fd ) ; if ( err ) goto out ; err = hfs_brec_remove ( & src_fd ) ; if ( err ) goto out ; src_dir -> i_size -- ; src_dir -> i_mtime = src_dir -> i_ctime = CURRENT_TIME_SEC ; hfsplus_cat_build_key ( sb , src_fd . search_key , cnid , NULL ) ; err = hfs_brec_find ( & src_fd ) ; if ( err ) goto out ; type = hfs_bnode_read_u16 ( src_fd . bnode , src_fd . entryoffset ) ; err = hfs_brec_remove ( & src_fd ) ; if ( err ) goto out ; hfsplus_cat_build_key ( sb , dst_fd . search_key , cnid , NULL ) ; entry_size = hfsplus_fill_cat_thread ( sb , & entry , type , dst_dir -> i_ino , dst_name ) ; err = hfs_brec_find ( & dst_fd ) ; if ( err != - ENOENT ) { if ( ! err ) err = - EEXIST ; goto out ; } err = hfs_brec_insert ( & dst_fd , & entry , entry_size ) ; hfsplus_mark_inode_dirty ( dst_dir , HFSPLUS_I_CAT_DIRTY ) ; hfsplus_mark_inode_dirty ( src_dir , HFSPLUS_I_CAT_DIRTY ) ; out : hfs_bnode_put ( dst_fd . bnode ) ; hfs_find_exit ( & src_fd ) ; return err ; }",goto out ; if ( src_fd . entrylength > sizeof ( entry ) || src_fd . entrylength < 0 ) { err = - EIO ; goto out ; }
444,"void xmlParsePEReference ( xmlParserCtxtPtr ctxt ) { const xmlChar * name ; xmlEntityPtr entity = NULL ; xmlParserInputPtr input ; if ( RAW != '%' ) return ; NEXT ; name = xmlParseName ( ctxt ) ; if ( name == NULL ) { xmlFatalErrMsg ( ctxt , XML_ERR_PEREF_NO_NAME , ""PEReference:<S2SV_blank>no<S2SV_blank>name\\n"" ) ; return ; } if ( xmlParserDebugEntities ) xmlGenericError ( xmlGenericErrorContext , ""PEReference:<S2SV_blank>%s\\n"" , name ) ; if ( RAW != ';' ) { xmlFatalErr ( ctxt , XML_ERR_PEREF_SEMICOL_MISSING , NULL ) ; return ; } NEXT ; ctxt -> nbentities ++ ; if ( ( ctxt -> sax != NULL ) && ( ctxt -> sax -> getParameterEntity != NULL ) ) entity = ctxt -> sax -> getParameterEntity ( ctxt -> userData , name ) ; if ( ctxt -> instate == XML_PARSER_EOF ) return ; if ( entity == NULL ) { if ( ( ctxt -> standalone == 1 ) || ( ( ctxt -> hasExternalSubset == 0 ) && ( ctxt -> hasPErefs == 0 ) ) ) { xmlFatalErrMsgStr ( ctxt , XML_ERR_UNDECLARED_ENTITY , ""PEReference:<S2SV_blank>%%%s;<S2SV_blank>not<S2SV_blank>found\\n"" , name ) ; } else { if ( ( ctxt -> validate ) && ( ctxt -> vctxt . error != NULL ) ) { xmlValidityError ( ctxt , XML_WAR_UNDECLARED_ENTITY , ""PEReference:<S2SV_blank>%%%s;<S2SV_blank>not<S2SV_blank>found\\n"" , name , NULL ) ; } else xmlWarningMsg ( ctxt , XML_WAR_UNDECLARED_ENTITY , ""PEReference:<S2SV_blank>%%%s;<S2SV_blank>not<S2SV_blank>found\\n"" , name , NULL ) ; ctxt -> valid = 0 ; } xmlParserEntityCheck ( ctxt , 0 , NULL , 0 ) ; } else { if ( ( entity -> etype != XML_INTERNAL_PARAMETER_ENTITY ) && ( entity -> etype != XML_EXTERNAL_PARAMETER_ENTITY ) ) { xmlWarningMsg ( ctxt , XML_WAR_UNDECLARED_ENTITY , ""Internal:<S2SV_blank>%%%s;<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>parameter<S2SV_blank>entity\\n"" , name , NULL ) ; } else { xmlChar start [ 4 ] ; xmlCharEncoding enc ; if ( ( entity -> etype == XML_EXTERNAL_PARAMETER_ENTITY ) && ( ( ctxt -> options & XML_PARSE_NOENT ) == 0 ) && ( ( ctxt -> options & XML_PARSE_DTDVALID ) == 0 ) && ( ( ctxt -> options & XML_PARSE_DTDLOAD ) == 0 ) && ( ( ctxt -> options & XML_PARSE_DTDATTR ) == 0 ) && ( ctxt -> replaceEntities == 0 ) && ( ctxt -> validate == 0 ) ) return ; input = xmlNewEntityInputStream ( ctxt , entity ) ; <S2SV_StartBug> if ( xmlPushInput ( ctxt , input ) < 0 ) <S2SV_EndBug> return ; if ( entity -> etype == XML_EXTERNAL_PARAMETER_ENTITY ) { GROW if ( ctxt -> instate == XML_PARSER_EOF ) return ; if ( ( ctxt -> input -> end - ctxt -> input -> cur ) >= 4 ) { start [ 0 ] = RAW ; start [ 1 ] = NXT ( 1 ) ; start [ 2 ] = NXT ( 2 ) ; start [ 3 ] = NXT ( 3 ) ; enc = xmlDetectCharEncoding ( start , 4 ) ; if ( enc != XML_CHAR_ENCODING_NONE ) { xmlSwitchEncoding ( ctxt , enc ) ; } } if ( ( CMP5 ( CUR_PTR , '<' , '?' , 'x' , 'm' , 'l' ) ) && ( IS_BLANK_CH ( NXT ( 5 ) ) ) ) { xmlParseTextDecl ( ctxt ) ; } } } } ctxt -> hasPErefs = 1 ; }",< 0 ) { xmlFreeInputStream ( input ) ; return ; } <S2SV_ModEnd> if ( entity
445,"int lookup ( struct sip_msg * _m , char * _t , char * _f , char * _s ) { unsigned int flags ; urecord_t * r ; str aor , uri ; ucontact_t * ptr , * it ; int res ; int ret ; str path_dst ; str flags_s ; pv_value_t val ; int_str istr ; str sip_instance = { 0 , 0 } , call_id = { 0 , 0 } ; flags = 0 ; if ( _f && _f [ 0 ] != 0 ) { if ( fixup_get_svalue ( _m , ( gparam_p ) _f , & flags_s ) != 0 ) { LM_ERR ( ""invalid<S2SV_blank>owner<S2SV_blank>uri<S2SV_blank>parameter"" ) ; return - 1 ; } for ( res = 0 ; res < flags_s . len ; res ++ ) { switch ( flags_s . s [ res ] ) { case 'm' : flags |= REG_LOOKUP_METHODFILTER_FLAG ; break ; case 'b' : flags |= REG_LOOKUP_NOBRANCH_FLAG ; break ; default : LM_WARN ( ""unsuported<S2SV_blank>flag<S2SV_blank>%c<S2SV_blank>\\n"" , flags_s . s [ res ] ) ; } } } if ( _s ) { if ( pv_get_spec_value ( _m , ( pv_spec_p ) _s , & val ) != 0 ) { LM_ERR ( ""failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>PV<S2SV_blank>value\\n"" ) ; return - 1 ; } if ( ( val . flags & PV_VAL_STR ) == 0 ) { LM_ERR ( ""PV<S2SV_blank>vals<S2SV_blank>is<S2SV_blank>not<S2SV_blank>string\\n"" ) ; return - 1 ; } uri = val . rs ; } else { if ( _m -> new_uri . s ) uri = _m -> new_uri ; else uri = _m -> first_line . u . request . uri ; } if ( extract_aor ( & uri , & aor , & sip_instance , & call_id ) < 0 ) { LM_ERR ( ""failed<S2SV_blank>to<S2SV_blank>extract<S2SV_blank>address<S2SV_blank>of<S2SV_blank>record\\n"" ) ; return - 3 ; } get_act_time ( ) ; ul . lock_udomain ( ( udomain_t * ) _t , & aor ) ; res = ul . get_urecord ( ( udomain_t * ) _t , & aor , & r ) ; if ( res > 0 ) { LM_DBG ( ""\'%.*s\'<S2SV_blank>Not<S2SV_blank>found<S2SV_blank>in<S2SV_blank>usrloc\\n"" , aor . len , ZSW ( aor . s ) ) ; ul . unlock_udomain ( ( udomain_t * ) _t , & aor ) ; return - 1 ; } ptr = r -> contacts ; ret = - 1 ; search_valid_contact : while ( ( ptr ) && ! ( VALID_CONTACT ( ptr , act_time ) && ( ret = - 2 ) && allowed_method ( _m , ptr , flags ) ) ) ptr = ptr -> next ; if ( ptr == 0 ) { LM_DBG ( ""nothing<S2SV_blank>found<S2SV_blank>!\\n"" ) ; goto done ; } if ( sip_instance . len && sip_instance . s ) { LM_DBG ( ""ruri<S2SV_blank>has<S2SV_blank>gruu<S2SV_blank>in<S2SV_blank>lookup\\n"" ) ; if ( ptr -> instance . len - 2 != sip_instance . len || memcmp ( ptr -> instance . s + 1 , sip_instance . s , sip_instance . len ) ) { LM_DBG ( ""no<S2SV_blank>match<S2SV_blank>to<S2SV_blank>sip<S2SV_blank>instace<S2SV_blank>-<S2SV_blank>[%.*s]<S2SV_blank>-<S2SV_blank>[%.*s]\\n"" , ptr -> instance . len - 2 , ptr -> instance . s + 1 , sip_instance . len , sip_instance . s ) ; ptr = ptr -> next ; goto search_valid_contact ; } LM_DBG ( ""matched<S2SV_blank>sip<S2SV_blank>instace\\n"" ) ; } if ( call_id . len && call_id . s ) { if ( ptr -> callid . len != call_id . len || memcmp ( ptr -> callid . s , call_id . s , call_id . len ) ) { LM_DBG ( ""no<S2SV_blank>match<S2SV_blank>to<S2SV_blank>call<S2SV_blank>id<S2SV_blank>-<S2SV_blank>[%.*s]<S2SV_blank>-<S2SV_blank>[%.*s]\\n"" , ptr -> callid . len , ptr -> callid . s , call_id . len , call_id . s ) ; ptr = ptr -> next ; goto search_valid_contact ; } it = ptr -> next ; while ( it ) { if ( VALID_CONTACT ( it , act_time ) ) { if ( it -> instance . len - 2 == sip_instance . len && memcmp ( it -> instance . s + 1 , sip_instance . s , sip_instance . len ) == 0 ) if ( it -> last_modified > ptr -> last_modified ) { break ; } } <S2SV_StartBug> } <S2SV_EndBug> if ( it != NULL ) { ret = - 1 ; goto done ; } } LM_DBG ( ""found<S2SV_blank>a<S2SV_blank>complete<S2SV_blank>match\\n"" ) ; ret = 1 ; if ( ptr ) { LM_DBG ( ""setting<S2SV_blank>as<S2SV_blank>ruri<S2SV_blank><%.*s>\\n"" , ptr -> c . len , ptr -> c . s ) ; if ( set_ruri ( _m , & ptr -> c ) < 0 ) { LM_ERR ( ""unable<S2SV_blank>to<S2SV_blank>rewrite<S2SV_blank>Request-URI\\n"" ) ; ret = - 3 ; goto done ; } if ( ptr -> path . s && ptr -> path . len ) { if ( get_path_dst_uri ( & ptr -> path , & path_dst ) < 0 ) { LM_ERR ( ""failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>dst_uri<S2SV_blank>for<S2SV_blank>Path\\n"" ) ; ret = - 3 ; goto done ; } if ( set_path_vector ( _m , & ptr -> path ) < 0 ) { LM_ERR ( ""failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>path<S2SV_blank>vector\\n"" ) ; ret = - 3 ; goto done ; } if ( set_dst_uri ( _m , & path_dst ) < 0 ) { LM_ERR ( ""failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>dst_uri<S2SV_blank>of<S2SV_blank>Path\\n"" ) ; ret = - 3 ; goto done ; } } else if ( ptr -> received . s && ptr -> received . len ) { if ( set_dst_uri ( _m , & ptr -> received ) < 0 ) { ret = - 3 ; goto done ; } } set_ruri_q ( ptr -> q ) ; setbflag ( 0 , ptr -> cflags ) ; if ( ptr -> sock ) _m -> force_send_socket = ptr -> sock ; if ( attr_avp_name != - 1 ) { istr . s = ptr -> attr ; if ( add_avp_last ( AVP_VAL_STR , attr_avp_name , istr ) != 0 ) { LM_ERR ( ""Failed<S2SV_blank>to<S2SV_blank>populate<S2SV_blank>attr<S2SV_blank>avp!\\n"" ) ; } } ptr = ptr -> next ; } if ( flags & REG_LOOKUP_NOBRANCH_FLAG || ( sip_instance . len && sip_instance . s ) ) goto done ; LM_DBG ( ""looking<S2SV_blank>for<S2SV_blank>branches\\n"" ) ; for ( ; ptr ; ptr = ptr -> next ) { if ( VALID_CONTACT ( ptr , act_time ) && allowed_method ( _m , ptr , flags ) ) { path_dst . len = 0 ; if ( ptr -> path . s && ptr -> path . len && get_path_dst_uri ( & ptr -> path , & path_dst ) < 0 ) { LM_ERR ( ""failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>dst_uri<S2SV_blank>for<S2SV_blank>Path\\n"" ) ; continue ; } LM_DBG ( ""setting<S2SV_blank>branch<S2SV_blank><%.*s>\\n"" , ptr -> c . len , ptr -> c . s ) ; if ( append_branch ( _m , & ptr -> c , path_dst . len ? & path_dst : & ptr -> received , & ptr -> path , ptr -> q , ptr -> cflags , ptr -> sock ) == - 1 ) { LM_ERR ( ""failed<S2SV_blank>to<S2SV_blank>append<S2SV_blank>a<S2SV_blank>branch\\n"" ) ; continue ; } if ( attr_avp_name != - 1 ) { istr . s = ptr -> attr ; if ( add_avp_last ( AVP_VAL_STR , attr_avp_name , istr ) != 0 ) { LM_ERR ( ""Failed<S2SV_blank>to<S2SV_blank>populate<S2SV_blank>attr<S2SV_blank>avp!\\n"" ) ; } } } } done : ul . release_urecord ( r ) ; ul . unlock_udomain ( ( udomain_t * ) _t , & aor ) ; return ret ; }",; } } it = it -> next ;
446,"static int isis_print_mt_port_cap_subtlv ( netdissect_options * ndo , const uint8_t * tptr , int len ) { int stlv_type , stlv_len ; const struct isis_subtlv_spb_mcid * subtlv_spb_mcid ; int i ; while ( len > 2 ) { <S2SV_StartBug> stlv_type = * ( tptr ++ ) ; <S2SV_EndBug> stlv_len = * ( tptr ++ ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s<S2SV_blank>subTLV<S2SV_blank>#%u,<S2SV_blank>length:<S2SV_blank>%u"" , tok2str ( isis_mt_port_cap_subtlv_values , ""unknown"" , stlv_type ) , stlv_type , stlv_len ) ) ; <S2SV_StartBug> len = len - 2 ; <S2SV_EndBug> switch ( stlv_type ) { case ISIS_SUBTLV_SPB_MCID : { <S2SV_StartBug> ND_TCHECK2 ( * ( tptr ) , ISIS_SUBTLV_SPB_MCID_MIN_LEN ) ; <S2SV_EndBug> subtlv_spb_mcid = ( const struct isis_subtlv_spb_mcid * ) tptr ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>MCID:<S2SV_blank>"" ) ) ; isis_print_mcid ( ndo , & ( subtlv_spb_mcid -> mcid ) ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>AUX-MCID:<S2SV_blank>"" ) ) ; isis_print_mcid ( ndo , & ( subtlv_spb_mcid -> aux_mcid ) ) ; <S2SV_StartBug> tptr = tptr + sizeof ( struct isis_subtlv_spb_mcid ) ; <S2SV_EndBug> len = len - sizeof ( struct isis_subtlv_spb_mcid ) ; break ; } case ISIS_SUBTLV_SPB_DIGEST : { <S2SV_StartBug> ND_TCHECK2 ( * ( tptr ) , ISIS_SUBTLV_SPB_DIGEST_MIN_LEN ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>RES:<S2SV_blank>%d<S2SV_blank>V:<S2SV_blank>%d<S2SV_blank>A:<S2SV_blank>%d<S2SV_blank>D:<S2SV_blank>%d"" , ( * ( tptr ) >> 5 ) , ( ( ( * tptr ) >> 4 ) & 0x01 ) , ( ( * ( tptr ) >> 2 ) & 0x03 ) , ( ( * tptr ) & 0x03 ) ) ) ; tptr ++ ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Digest:<S2SV_blank>"" ) ) ; for ( i = 1 ; i <= 8 ; i ++ ) { ND_PRINT ( ( ndo , ""%08x<S2SV_blank>"" , EXTRACT_32BITS ( tptr ) ) ) ; if ( i % 4 == 0 && i != 8 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ) ) ; tptr = tptr + 4 ; } len = len - ISIS_SUBTLV_SPB_DIGEST_MIN_LEN ; <S2SV_StartBug> break ; <S2SV_EndBug> } case ISIS_SUBTLV_SPB_BVID : { <S2SV_StartBug> ND_TCHECK2 ( * ( tptr ) , stlv_len ) ; <S2SV_EndBug> while ( len >= ISIS_SUBTLV_SPB_BVID_MIN_LEN ) { <S2SV_StartBug> ND_TCHECK2 ( * ( tptr ) , ISIS_SUBTLV_SPB_BVID_MIN_LEN ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>ECT:<S2SV_blank>%08x"" , EXTRACT_32BITS ( tptr ) ) ) ; tptr = tptr + 4 ; ND_PRINT ( ( ndo , ""<S2SV_blank>BVID:<S2SV_blank>%d,<S2SV_blank>U:%01x<S2SV_blank>M:%01x<S2SV_blank>"" , ( EXTRACT_16BITS ( tptr ) >> 4 ) , ( EXTRACT_16BITS ( tptr ) >> 3 ) & 0x01 , ( EXTRACT_16BITS ( tptr ) >> 2 ) & 0x01 ) ) ; tptr = tptr + 2 ; len = len - ISIS_SUBTLV_SPB_BVID_MIN_LEN ; <S2SV_StartBug> } <S2SV_EndBug> break ; } default : break ; } <S2SV_StartBug> } <S2SV_EndBug> return 0 ; trunc : ND_PRINT ( ( ndo , ""\\n\\t\\t"" ) ) ; ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; return ( 1 ) ; }","2 ) { ND_TCHECK2 ( * tptr , 2 ) ; <S2SV_ModStart> len - 2 ; if ( len < stlv_len ) goto trunc ; ND_TCHECK2 ( * ( tptr ) , stlv_len ) <S2SV_ModStart> ISIS_SUBTLV_SPB_MCID : { if ( stlv_len < ISIS_SUBTLV_SPB_MCID_MIN_LEN ) goto trunc <S2SV_ModEnd> ; subtlv_spb_mcid = <S2SV_ModStart> = tptr + ISIS_SUBTLV_SPB_MCID_MIN_LEN ; len = len - ISIS_SUBTLV_SPB_MCID_MIN_LEN ; stlv_len = stlv_len - ISIS_SUBTLV_SPB_MCID_MIN_LEN <S2SV_ModEnd> ; break ; <S2SV_ModStart> ISIS_SUBTLV_SPB_DIGEST : { if ( stlv_len < ISIS_SUBTLV_SPB_DIGEST_MIN_LEN ) goto trunc <S2SV_ModEnd> ; ND_PRINT ( <S2SV_ModStart> - ISIS_SUBTLV_SPB_DIGEST_MIN_LEN ; stlv_len = stlv_len - ISIS_SUBTLV_SPB_DIGEST_MIN_LEN ; <S2SV_ModStart> ISIS_SUBTLV_SPB_BVID : { while ( stlv_len <S2SV_ModEnd> >= ISIS_SUBTLV_SPB_BVID_MIN_LEN ) <S2SV_ModStart> ISIS_SUBTLV_SPB_BVID_MIN_LEN ) { <S2SV_ModEnd> ND_PRINT ( ( <S2SV_ModStart> - ISIS_SUBTLV_SPB_BVID_MIN_LEN ; stlv_len = stlv_len - ISIS_SUBTLV_SPB_BVID_MIN_LEN ; <S2SV_ModStart> break ; } tptr += stlv_len ; len -= stlv_len ;"
447,"static int snd_usb_create_streams ( struct snd_usb_audio * chip , int ctrlif ) { struct usb_device * dev = chip -> dev ; struct usb_host_interface * host_iface ; struct usb_interface_descriptor * altsd ; void * control_header ; <S2SV_StartBug> int i , protocol ; <S2SV_EndBug> host_iface = & usb_ifnum_to_if ( dev , ctrlif ) -> altsetting [ 0 ] ; control_header = snd_usb_find_csint_desc ( host_iface -> extra , host_iface -> extralen , NULL , UAC_HEADER ) ; altsd = get_iface_desc ( host_iface ) ; protocol = altsd -> bInterfaceProtocol ; if ( ! control_header ) { dev_err ( & dev -> dev , ""cannot<S2SV_blank>find<S2SV_blank>UAC_HEADER\\n"" ) ; return - EINVAL ; } <S2SV_StartBug> switch ( protocol ) { <S2SV_EndBug> default : dev_warn ( & dev -> dev , ""unknown<S2SV_blank>interface<S2SV_blank>protocol<S2SV_blank>%#02x,<S2SV_blank>assuming<S2SV_blank>v1\\n"" , protocol ) ; case UAC_VERSION_1 : { struct uac1_ac_header_descriptor * h1 = control_header ; <S2SV_StartBug> if ( ! h1 -> bInCollection ) { <S2SV_EndBug> <S2SV_StartBug> dev_info ( & dev -> dev , ""skipping<S2SV_blank>empty<S2SV_blank>audio<S2SV_blank>interface<S2SV_blank>(v1)\\n"" ) ; <S2SV_EndBug> return - EINVAL ; } if ( h1 -> bLength < sizeof ( * h1 ) + h1 -> bInCollection ) { dev_err ( & dev -> dev , ""invalid<S2SV_blank>UAC_HEADER<S2SV_blank>(v1)\\n"" ) ; return - EINVAL ; } for ( i = 0 ; i < h1 -> bInCollection ; i ++ ) snd_usb_create_stream ( chip , ctrlif , h1 -> baInterfaceNr [ i ] ) ; break ; } case UAC_VERSION_2 : { struct usb_interface_assoc_descriptor * assoc = usb_ifnum_to_if ( dev , ctrlif ) -> intf_assoc ; if ( ! assoc ) { struct usb_interface * iface = usb_ifnum_to_if ( dev , ctrlif + 1 ) ; if ( iface && iface -> intf_assoc && iface -> intf_assoc -> bFunctionClass == USB_CLASS_AUDIO && iface -> intf_assoc -> bFunctionProtocol == UAC_VERSION_2 ) assoc = iface -> intf_assoc ; } if ( ! assoc ) { dev_err ( & dev -> dev , ""Audio<S2SV_blank>class<S2SV_blank>v2<S2SV_blank>interfaces<S2SV_blank>need<S2SV_blank>an<S2SV_blank>interface<S2SV_blank>association\\n"" ) ; return - EINVAL ; } for ( i = 0 ; i < assoc -> bInterfaceCount ; i ++ ) { int intf = assoc -> bFirstInterface + i ; if ( intf != ctrlif ) snd_usb_create_stream ( chip , ctrlif , intf ) ; } break ; } } return 0 ; }","i , protocol ; int rest_bytes <S2SV_ModStart> EINVAL ; } rest_bytes = ( void * ) ( host_iface -> extra + host_iface -> extralen ) - control_header ; if ( rest_bytes <= 0 ) { dev_err ( & dev -> dev , ""invalid<S2SV_blank>control<S2SV_blank>header\\n"" ) ; return - EINVAL ; } <S2SV_ModStart> ; if ( rest_bytes < sizeof ( * h1 ) ) { dev_err ( & dev -> dev , ""too<S2SV_blank>short<S2SV_blank>v1<S2SV_blank>buffer<S2SV_blank>descriptor\\n"" ) ; return - EINVAL ; } if ( <S2SV_ModStart> dev , ""skipping<S2SV_blank>empty<S2SV_blank>audio<S2SV_blank>interface<S2SV_blank>(v1)\\n"" ) ; return - EINVAL ; } if ( rest_bytes < h1 -> bLength ) { dev_err ( & dev -> dev , ""invalid<S2SV_blank>buffer<S2SV_blank>length<S2SV_blank>(v1)\\n"""
448,"static struct key * construct_key_and_link ( struct keyring_search_context * ctx , const char * callout_info , size_t callout_len , void * aux , struct key * dest_keyring , unsigned long flags ) { struct key_user * user ; struct key * key ; int ret ; kenter ( """" ) ; if ( ctx -> index_key . type == & key_type_keyring ) return ERR_PTR ( - EPERM ) ; <S2SV_StartBug> user = key_user_lookup ( current_fsuid ( ) ) ; <S2SV_EndBug> if ( ! user ) <S2SV_StartBug> return ERR_PTR ( - ENOMEM ) ; <S2SV_EndBug> construct_get_dest_keyring ( & dest_keyring ) ; ret = construct_alloc_key ( ctx , dest_keyring , flags , user , & key ) ; key_user_put ( user ) ; if ( ret == 0 ) { ret = construct_key ( key , callout_info , callout_len , aux , dest_keyring ) ; if ( ret < 0 ) { kdebug ( ""cons<S2SV_blank>failed"" ) ; goto construction_failed ; } } else if ( ret == - EINPROGRESS ) { ret = 0 ; } else { <S2SV_StartBug> goto couldnt_alloc_key ; <S2SV_EndBug> } key_put ( dest_keyring ) ; kleave ( ""<S2SV_blank>=<S2SV_blank>key<S2SV_blank>%d"" , key_serial ( key ) ) ; return key ; construction_failed : key_negate_and_link ( key , key_negative_timeout , NULL , NULL ) ; key_put ( key ) ; <S2SV_StartBug> couldnt_alloc_key : <S2SV_EndBug> <S2SV_StartBug> key_put ( dest_keyring ) ; <S2SV_EndBug> kleave ( ""<S2SV_blank>=<S2SV_blank>%d"" , ret ) ; return ERR_PTR ( ret ) ; }",EPERM ) ; ret = construct_get_dest_keyring ( & dest_keyring ) ; if ( ret ) goto error ; <S2SV_ModStart> ! user ) { ret = - ENOMEM ; goto error_put_dest_keyring ; } <S2SV_ModEnd> ret = construct_alloc_key <S2SV_ModStart> else { goto error_put_dest_keyring <S2SV_ModEnd> ; } key_put <S2SV_ModStart> key ) ; error_put_dest_keyring <S2SV_ModEnd> : key_put ( <S2SV_ModStart> dest_keyring ) ; error :
449,"static void rd_auto_partition_range ( VP9_COMP * cpi , const TileInfo * const tile , <S2SV_StartBug> int mi_row , int mi_col , <S2SV_EndBug> BLOCK_SIZE * min_block_size , BLOCK_SIZE * max_block_size ) { VP9_COMMON * const cm = & cpi -> common ; <S2SV_StartBug> MACROBLOCKD * const xd = & cpi -> mb . e_mbd ; <S2SV_EndBug> <S2SV_StartBug> MODE_INFO * * mi_8x8 = xd -> mi ; <S2SV_EndBug> <S2SV_StartBug> const int left_in_image = xd -> left_available && mi_8x8 [ - 1 ] ; <S2SV_EndBug> const int above_in_image = xd -> up_available && <S2SV_StartBug> mi_8x8 [ - xd -> mi_stride ] ; <S2SV_EndBug> <S2SV_StartBug> MODE_INFO * * above_sb64_mi_8x8 ; <S2SV_EndBug> MODE_INFO * * left_sb64_mi_8x8 ; int row8x8_remaining = tile -> mi_row_end - mi_row ; <S2SV_StartBug> int col8x8_remaining = tile -> mi_col_end - mi_col ; <S2SV_EndBug> int bh , bw ; BLOCK_SIZE min_size = BLOCK_4X4 ; <S2SV_StartBug> BLOCK_SIZE max_size = BLOCK_64X64 ; <S2SV_EndBug> if ( left_in_image || above_in_image || cm -> frame_type != KEY_FRAME ) { min_size = BLOCK_64X64 ; max_size = BLOCK_4X4 ; if ( cm -> frame_type != KEY_FRAME ) { <S2SV_StartBug> MODE_INFO * * const prev_mi = <S2SV_EndBug> & cm -> prev_mi_grid_visible [ mi_row * xd -> mi_stride + mi_col ] ; <S2SV_StartBug> get_sb_partition_size_range ( cpi , prev_mi , & min_size , & max_size ) ; <S2SV_EndBug> } if ( left_in_image ) { <S2SV_StartBug> left_sb64_mi_8x8 = & mi_8x8 [ - MI_BLOCK_SIZE ] ; <S2SV_EndBug> <S2SV_StartBug> get_sb_partition_size_range ( cpi , left_sb64_mi_8x8 , <S2SV_EndBug> & min_size , & max_size ) ; } if ( above_in_image ) { <S2SV_StartBug> above_sb64_mi_8x8 = & mi_8x8 [ - xd -> mi_stride * MI_BLOCK_SIZE ] ; <S2SV_EndBug> <S2SV_StartBug> get_sb_partition_size_range ( cpi , above_sb64_mi_8x8 , <S2SV_EndBug> & min_size , & max_size ) ; } if ( cpi -> sf . auto_min_max_partition_size == RELAXED_NEIGHBORING_MIN_MAX ) { min_size = min_partition_size [ min_size ] ; max_size = max_partition_size [ max_size ] ; } } max_size = find_partition_size ( max_size , row8x8_remaining , col8x8_remaining , & bh , & bw ) ; <S2SV_StartBug> min_size = MIN ( min_size , max_size ) ; <S2SV_EndBug> if ( cpi -> sf . use_square_partition_only && next_square_size [ max_size ] < min_size ) { min_size = next_square_size [ max_size ] ; } * min_block_size = min_size ; * max_block_size = max_size ; }","const tile , MACROBLOCKD * const xd , <S2SV_ModStart> -> common ; <S2SV_ModEnd> MODE_INFO * * <S2SV_ModStart> MODE_INFO * * mi <S2SV_ModEnd> = xd -> <S2SV_ModStart> -> left_available && mi <S2SV_ModEnd> [ - 1 <S2SV_ModStart> -> up_available && mi <S2SV_ModEnd> [ - xd <S2SV_ModStart> mi_stride ] ; const <S2SV_ModEnd> int row8x8_remaining = <S2SV_ModStart> - mi_row ; const <S2SV_ModStart> max_size = BLOCK_64X64 ; int bs_hist [ BLOCK_SIZES ] = { 0 } <S2SV_ModStart> MODE_INFO * * <S2SV_ModEnd> prev_mi = & <S2SV_ModStart> ; get_sb_partition_size_range ( xd <S2SV_ModEnd> , prev_mi , <S2SV_ModStart> , & max_size , bs_hist <S2SV_ModStart> left_in_image ) { MODE_INFO * * left_sb64_mi = & mi <S2SV_ModEnd> [ - MI_BLOCK_SIZE <S2SV_ModStart> ; get_sb_partition_size_range ( xd , left_sb64_mi , & min_size , & max_size , bs_hist <S2SV_ModEnd> ) ; } <S2SV_ModStart> above_in_image ) { MODE_INFO * * above_sb64_mi = & mi <S2SV_ModEnd> [ - xd <S2SV_ModStart> ; get_sb_partition_size_range ( xd , above_sb64_mi , & min_size , & max_size , bs_hist <S2SV_ModEnd> ) ; } <S2SV_ModStart> bw ) ; if ( vp9_active_edge_sb ( cpi , mi_row , mi_col ) ) { min_size = BLOCK_4X4 ; } else { <S2SV_ModStart> = MIN ( cpi -> sf . rd_auto_partition_min_limit , MIN ( min_size , max_size ) ) ; } <S2SV_ModEnd> if ( cpi"
450,"void init_global_keywords ( bool global_active ) { install_keyword_root ( ""linkbeat_use_polling"" , use_polling_handler , global_active ) ; # if HAVE_DECL_CLONE_NEWNET install_keyword_root ( ""net_namespace"" , & net_namespace_handler , global_active ) ; install_keyword_root ( ""namespace_with_ipsets"" , & namespace_ipsets_handler , global_active ) ; # endif install_keyword_root ( ""use_pid_dir"" , & use_pid_dir_handler , global_active ) ; install_keyword_root ( ""instance"" , & instance_handler , global_active ) ; install_keyword_root ( ""child_wait_time"" , & child_wait_handler , global_active ) ; install_keyword_root ( ""global_defs"" , NULL , global_active ) ; install_keyword ( ""router_id"" , & routerid_handler ) ; install_keyword ( ""notification_email_from"" , & emailfrom_handler ) ; install_keyword ( ""smtp_server"" , & smtpserver_handler ) ; install_keyword ( ""smtp_helo_name"" , & smtphelo_handler ) ; install_keyword ( ""smtp_connect_timeout"" , & smtpto_handler ) ; install_keyword ( ""notification_email"" , & email_handler ) ; install_keyword ( ""smtp_alert"" , & smtp_alert_handler ) ; # ifdef _WITH_VRRP_ install_keyword ( ""smtp_alert_vrrp"" , & smtp_alert_vrrp_handler ) ; # endif # ifdef _WITH_LVS_ install_keyword ( ""smtp_alert_checker"" , & smtp_alert_checker_handler ) ; # endif # ifdef _WITH_VRRP_ install_keyword ( ""dynamic_interfaces"" , & dynamic_interfaces_handler ) ; install_keyword ( ""no_email_faults"" , & no_email_faults_handler ) ; install_keyword ( ""default_interface"" , & default_interface_handler ) ; # endif # ifdef _WITH_LVS_ install_keyword ( ""lvs_timeouts"" , & lvs_timeouts ) ; install_keyword ( ""lvs_flush"" , & lvs_flush_handler ) ; # ifdef _WITH_VRRP_ install_keyword ( ""lvs_sync_daemon"" , & lvs_syncd_handler ) ; # endif # endif # ifdef _WITH_VRRP_ install_keyword ( ""vrrp_mcast_group4"" , & vrrp_mcast_group4_handler ) ; install_keyword ( ""vrrp_mcast_group6"" , & vrrp_mcast_group6_handler ) ; install_keyword ( ""vrrp_garp_master_delay"" , & vrrp_garp_delay_handler ) ; install_keyword ( ""vrrp_garp_master_repeat"" , & vrrp_garp_rep_handler ) ; install_keyword ( ""vrrp_garp_master_refresh"" , & vrrp_garp_refresh_handler ) ; install_keyword ( ""vrrp_garp_master_refresh_repeat"" , & vrrp_garp_refresh_rep_handler ) ; install_keyword ( ""vrrp_garp_lower_prio_delay"" , & vrrp_garp_lower_prio_delay_handler ) ; install_keyword ( ""vrrp_garp_lower_prio_repeat"" , & vrrp_garp_lower_prio_rep_handler ) ; install_keyword ( ""vrrp_garp_interval"" , & vrrp_garp_interval_handler ) ; install_keyword ( ""vrrp_gna_interval"" , & vrrp_gna_interval_handler ) ; install_keyword ( ""vrrp_lower_prio_no_advert"" , & vrrp_lower_prio_no_advert_handler ) ; install_keyword ( ""vrrp_higher_prio_send_advert"" , & vrrp_higher_prio_send_advert_handler ) ; install_keyword ( ""vrrp_version"" , & vrrp_version_handler ) ; install_keyword ( ""vrrp_iptables"" , & vrrp_iptables_handler ) ; # ifdef _HAVE_LIBIPSET_ install_keyword ( ""vrrp_ipsets"" , & vrrp_ipsets_handler ) ; # endif install_keyword ( ""vrrp_check_unicast_src"" , & vrrp_check_unicast_src_handler ) ; install_keyword ( ""vrrp_skip_check_adv_addr"" , & vrrp_check_adv_addr_handler ) ; install_keyword ( ""vrrp_strict"" , & vrrp_strict_handler ) ; install_keyword ( ""vrrp_priority"" , & vrrp_prio_handler ) ; install_keyword ( ""vrrp_no_swap"" , & vrrp_no_swap_handler ) ; # ifdef _HAVE_SCHED_RT_ install_keyword ( ""vrrp_rt_priority"" , & vrrp_rt_priority_handler ) ; # if HAVE_DECL_RLIMIT_RTTIME == 1 install_keyword ( ""vrrp_rlimit_rtime"" , & vrrp_rt_rlimit_handler ) ; # endif # endif # endif install_keyword ( ""notify_fifo"" , & global_notify_fifo ) ; install_keyword ( ""notify_fifo_script"" , & global_notify_fifo_script ) ; # ifdef _WITH_VRRP_ install_keyword ( ""vrrp_notify_fifo"" , & vrrp_notify_fifo ) ; install_keyword ( ""vrrp_notify_fifo_script"" , & vrrp_notify_fifo_script ) ; # endif # ifdef _WITH_LVS_ install_keyword ( ""lvs_notify_fifo"" , & lvs_notify_fifo ) ; install_keyword ( ""lvs_notify_fifo_script"" , & lvs_notify_fifo_script ) ; install_keyword ( ""checker_priority"" , & checker_prio_handler ) ; install_keyword ( ""checker_no_swap"" , & checker_no_swap_handler ) ; # ifdef _HAVE_SCHED_RT_ install_keyword ( ""checker_rt_priority"" , & checker_rt_priority_handler ) ; # if HAVE_DECL_RLIMIT_RTTIME == 1 install_keyword ( ""checker_rlimit_rtime"" , & checker_rt_rlimit_handler ) ; # endif # endif # endif # ifdef _WITH_BFD_ install_keyword ( ""bfd_priority"" , & bfd_prio_handler ) ; install_keyword ( ""bfd_no_swap"" , & bfd_no_swap_handler ) ; # ifdef _HAVE_SCHED_RT_ install_keyword ( ""bfd_rt_priority"" , & bfd_rt_priority_handler ) ; # if HAVE_DECL_RLIMIT_RTTIME == 1 install_keyword ( ""bfd_rlimit_rtime"" , & bfd_rt_rlimit_handler ) ; # endif # endif # endif # ifdef _WITH_SNMP_ install_keyword ( ""snmp_socket"" , & snmp_socket_handler ) ; install_keyword ( ""enable_traps"" , & trap_handler ) ; # ifdef _WITH_SNMP_VRRP_ install_keyword ( ""enable_snmp_vrrp"" , & snmp_vrrp_handler ) ; install_keyword ( ""enable_snmp_keepalived"" , & snmp_vrrp_handler ) ; # endif # ifdef _WITH_SNMP_RFC_ install_keyword ( ""enable_snmp_rfc"" , & snmp_rfc_handler ) ; # endif # ifdef _WITH_SNMP_RFCV2_ install_keyword ( ""enable_snmp_rfcv2"" , & snmp_rfcv2_handler ) ; # endif # ifdef _WITH_SNMP_RFCV3_ install_keyword ( ""enable_snmp_rfcv3"" , & snmp_rfcv3_handler ) ; # endif # ifdef _WITH_SNMP_CHECKER_ install_keyword ( ""enable_snmp_checker"" , & snmp_checker_handler ) ; # endif # endif # ifdef _WITH_DBUS_ install_keyword ( ""enable_dbus"" , & enable_dbus_handler ) ; install_keyword ( ""dbus_service_name"" , & dbus_service_name_handler ) ; # endif install_keyword ( ""script_user"" , & script_user_handler ) ; install_keyword ( ""enable_script_security"" , & script_security_handler ) ; # ifdef _WITH_VRRP_ install_keyword ( ""vrrp_netlink_cmd_rcv_bufs"" , & vrrp_netlink_cmd_rcv_bufs_handler ) ; install_keyword ( ""vrrp_netlink_cmd_rcv_bufs_force"" , & vrrp_netlink_cmd_rcv_bufs_force_handler ) ; install_keyword ( ""vrrp_netlink_monitor_rcv_bufs"" , & vrrp_netlink_monitor_rcv_bufs_handler ) ; install_keyword ( ""vrrp_netlink_monitor_rcv_bufs_force"" , & vrrp_netlink_monitor_rcv_bufs_force_handler ) ; # endif # ifdef _WITH_LVS_ install_keyword ( ""lvs_netlink_cmd_rcv_bufs"" , & lvs_netlink_cmd_rcv_bufs_handler ) ; install_keyword ( ""lvs_netlink_cmd_rcv_bufs_force"" , & lvs_netlink_cmd_rcv_bufs_force_handler ) ; install_keyword ( ""lvs_netlink_monitor_rcv_bufs"" , & lvs_netlink_monitor_rcv_bufs_handler ) ; install_keyword ( ""lvs_netlink_monitor_rcv_bufs_force"" , & lvs_netlink_monitor_rcv_bufs_force_handler ) ; # endif # ifdef _WITH_LVS_ install_keyword ( ""rs_init_notifies"" , & rs_init_notifies_handler ) ; install_keyword ( ""no_checker_emails"" , & no_checker_emails_handler ) ; # endif # ifdef _WITH_VRRP_ install_keyword ( ""vrrp_rx_bufs_policy"" , & vrrp_rx_bufs_policy_handler ) ; install_keyword ( ""vrrp_rx_bufs_multiplier"" , & vrrp_rx_bufs_multiplier_handler ) ; # endif <S2SV_StartBug> } <S2SV_EndBug>","; # endif install_keyword ( ""umask"" , & umask_handler ) ;"
451,"static long aio_read_events_ring ( struct kioctx * ctx , struct io_event __user * event , long nr ) { struct aio_ring * ring ; unsigned head , tail , pos ; long ret = 0 ; int copy_ret ; mutex_lock ( & ctx -> ring_lock ) ; ring = kmap_atomic ( ctx -> ring_pages [ 0 ] ) ; head = ring -> head ; tail = ring -> tail ; kunmap_atomic ( ring ) ; pr_debug ( ""h%u<S2SV_blank>t%u<S2SV_blank>m%u\\n"" , head , tail , ctx -> nr_events ) ; if ( head == tail ) goto out ; <S2SV_StartBug> while ( ret < nr ) { <S2SV_EndBug> long avail ; struct io_event * ev ; struct page * page ; avail = ( head <= tail ? tail : ctx -> nr_events ) - head ; if ( head == tail ) break ; avail = min ( avail , nr - ret ) ; avail = min_t ( long , avail , AIO_EVENTS_PER_PAGE - ( ( head + AIO_EVENTS_OFFSET ) % AIO_EVENTS_PER_PAGE ) ) ; pos = head + AIO_EVENTS_OFFSET ; page = ctx -> ring_pages [ pos / AIO_EVENTS_PER_PAGE ] ; pos %= AIO_EVENTS_PER_PAGE ; ev = kmap ( page ) ; copy_ret = copy_to_user ( event + ret , ev + pos , sizeof ( * ev ) * avail ) ; kunmap ( page ) ; if ( unlikely ( copy_ret ) ) { ret = - EFAULT ; goto out ; } ret += avail ; head += avail ; head %= ctx -> nr_events ; } ring = kmap_atomic ( ctx -> ring_pages [ 0 ] ) ; ring -> head = head ; kunmap_atomic ( ring ) ; flush_dcache_page ( ctx -> ring_pages [ 0 ] ) ; pr_debug ( ""%li<S2SV_blank><S2SV_blank>h%u<S2SV_blank>t%u\\n"" , ret , head , tail ) ; out : mutex_unlock ( & ctx -> ring_lock ) ; return ret ; }",goto out ; head %= ctx -> nr_events ; tail %= ctx -> nr_events ;
452,"static void nfs4_open_release ( void * calldata ) { struct nfs4_opendata * data = calldata ; struct nfs4_state * state = NULL ; if ( data -> cancelled == 0 ) goto out_free ; if ( data -> rpc_status != 0 || ! data -> rpc_done ) goto out_free ; if ( data -> o_res . rflags & NFS4_OPEN_RESULT_CONFIRM ) goto out_free ; state = nfs4_opendata_to_nfs4_state ( data ) ; if ( ! IS_ERR ( state ) ) <S2SV_StartBug> nfs4_close_state ( & data -> path , state , data -> o_arg . open_flags ) ; <S2SV_EndBug> out_free : nfs4_opendata_put ( data ) ; }",-> o_arg . fmode <S2SV_ModEnd> ) ; out_free
453,"static void exif_mnote_data_canon_load ( ExifMnoteData * ne , const unsigned char * buf , unsigned int buf_size ) { ExifMnoteDataCanon * n = ( ExifMnoteDataCanon * ) ne ; ExifShort c ; size_t i , tcount , o , datao ; if ( ! n || ! buf || ! buf_size ) { exif_log ( ne -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteCanon"" , ""Short<S2SV_blank>MakerNote"" ) ; return ; } datao = 6 + n -> offset ; <S2SV_StartBug> if ( ( datao + 2 < datao ) || ( datao + 2 < 2 ) || ( datao + 2 > buf_size ) ) { <S2SV_EndBug> exif_log ( ne -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteCanon"" , ""Short<S2SV_blank>MakerNote"" ) ; return ; } c = exif_get_short ( buf + datao , n -> order ) ; datao += 2 ; exif_mnote_data_canon_clear ( n ) ; n -> entries = exif_mem_alloc ( ne -> mem , sizeof ( MnoteCanonEntry ) * c ) ; if ( ! n -> entries ) { EXIF_LOG_NO_MEMORY ( ne -> log , ""ExifMnoteCanon"" , sizeof ( MnoteCanonEntry ) * c ) ; return ; } tcount = 0 ; for ( i = c , o = datao ; i ; -- i , o += 12 ) { size_t s ; <S2SV_StartBug> if ( ( o + 12 < o ) || ( o + 12 < 12 ) || ( o + 12 > buf_size ) ) { <S2SV_EndBug> exif_log ( ne -> log , EXIF_LOG_CODE_CORRUPT_DATA , <S2SV_StartBug> ""ExifMnoteCanon"" , ""Short<S2SV_blank>MakerNote"" ) ; <S2SV_EndBug> break ; } n -> entries [ tcount ] . tag = exif_get_short ( buf + o , n -> order ) ; <S2SV_StartBug> n -> entries [ tcount ] . format = exif_get_short ( buf + o + 2 , n -> order ) ; <S2SV_EndBug> <S2SV_StartBug> n -> entries [ tcount ] . components = exif_get_long ( buf + o + 4 , n -> order ) ; <S2SV_EndBug> n -> entries [ tcount ] . order = n -> order ; exif_log ( ne -> log , EXIF_LOG_CODE_DEBUG , ""ExifMnoteCanon"" , ""Loading<S2SV_blank>entry<S2SV_blank>0x%x<S2SV_blank>(\'%s\')..."" , n -> entries [ tcount ] . tag , mnote_canon_tag_get_name ( n -> entries [ tcount ] . tag ) ) ; s = exif_format_get_size ( n -> entries [ tcount ] . format ) * n -> entries [ tcount ] . components ; n -> entries [ tcount ] . size = s ; if ( ! s ) { exif_log ( ne -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteCanon"" , ""Invalid<S2SV_blank>zero-length<S2SV_blank>tag<S2SV_blank>size"" ) ; continue ; } else { size_t dataofs = o + 8 ; if ( s > 4 ) dataofs = exif_get_long ( buf + dataofs , n -> order ) + 6 ; <S2SV_StartBug> if ( ( dataofs + s < s ) || ( dataofs + s < dataofs ) || ( dataofs + s > buf_size ) ) { <S2SV_EndBug> exif_log ( ne -> log , EXIF_LOG_CODE_DEBUG , ""ExifMnoteCanon"" , ""Tag<S2SV_blank>data<S2SV_blank>past<S2SV_blank>end<S2SV_blank>of<S2SV_blank>buffer<S2SV_blank>(%u<S2SV_blank>><S2SV_blank>%u)"" , ( unsigned ) ( dataofs + s ) , buf_size ) ; continue ; } n -> entries [ tcount ] . data = exif_mem_alloc ( ne -> mem , s ) ; if ( ! n -> entries [ tcount ] . data ) { EXIF_LOG_NO_MEMORY ( ne -> log , ""ExifMnoteCanon"" , s ) ; continue ; } memcpy ( n -> entries [ tcount ] . data , buf + dataofs , s ) ; } ++ tcount ; } n -> count = tcount ; }","; if ( CHECKOVERFLOW ( datao , buf_size , 2 <S2SV_ModEnd> ) ) { <S2SV_ModStart> ; if ( CHECKOVERFLOW ( o , buf_size , 12 ) ) { exif_log ( ne -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteCanon"" , ""Short<S2SV_blank>MakerNote"" ) ; break ; } n -> entries [ tcount ] . tag = exif_get_short ( buf + o , n -> order ) ; n -> entries [ tcount ] . format = exif_get_short ( buf + o + 2 , n -> order ) ; n -> entries [ tcount ] . components = exif_get_long ( buf + o + 4 , n -> order ) ; n -> entries [ tcount ] . order = n -> order ; exif_log ( ne -> log , EXIF_LOG_CODE_DEBUG , ""ExifMnoteCanon"" , ""Loading<S2SV_blank>entry<S2SV_blank>0x%x<S2SV_blank>(\'%s\')..."" , n -> entries [ tcount ] . tag , mnote_canon_tag_get_name ( n -> entries [ tcount ] . tag ) ) ; if ( exif_format_get_size ( n -> entries [ tcount ] . format ) && buf_size / exif_format_get_size ( n -> entries [ tcount ] . format ) < n -> entries [ tcount ] . components <S2SV_ModEnd> ) { exif_log <S2SV_ModStart> , ""ExifMnoteCanon"" , ""Tag<S2SV_blank>size<S2SV_blank>overflow<S2SV_blank>detected<S2SV_blank>(%u<S2SV_blank>*<S2SV_blank>%lu)"" , exif_format_get_size ( <S2SV_ModEnd> n -> entries <S2SV_ModStart> ] . format ) , <S2SV_ModEnd> n -> entries <S2SV_ModStart> ] . components ) ; continue ; } <S2SV_ModEnd> s = exif_format_get_size <S2SV_ModStart> ; if ( CHECKOVERFLOW ( dataofs , buf_size , s ) ) { exif_log ( ne -> log , EXIF_LOG_CODE_DEBUG , ""ExifMnoteCanon"" , ""Tag<S2SV_blank>data<S2SV_blank>past<S2SV_blank>end<S2SV_blank>of<S2SV_blank>buffer<S2SV_blank>(%u<S2SV_blank>><S2SV_blank>%u)"" , ( unsigned ) <S2SV_ModEnd> ( dataofs + <S2SV_ModStart> dataofs + s ) , buf_size ) ; continue ; } n -> entries [ tcount ] . data = exif_mem_alloc ( ne -> mem , s ) ; if ( ! n -> entries [ tcount ] . data ) { EXIF_LOG_NO_MEMORY ( ne -> log , ""ExifMnoteCanon"" , s ) ; continue ; } memcpy ( n -> entries [ tcount ] . data , buf + dataofs <S2SV_ModEnd> , s )"
454,"static void sample_to_timespec ( const clockid_t which_clock , union cpu_time_count cpu , struct timespec * tp ) { <S2SV_StartBug> if ( CPUCLOCK_WHICH ( which_clock ) == CPUCLOCK_SCHED ) { <S2SV_EndBug> <S2SV_StartBug> tp -> tv_sec = div_long_long_rem ( cpu . sched , <S2SV_EndBug> NSEC_PER_SEC , & tp -> tv_nsec ) ; } else { cputime_to_timespec ( cpu . cpu , tp ) ; } <S2SV_StartBug> } <S2SV_EndBug>",== CPUCLOCK_SCHED ) * tp = ns_to_timespec <S2SV_ModEnd> ( cpu . <S2SV_ModStart> cpu . sched ) ; else <S2SV_ModEnd> cputime_to_timespec ( cpu <S2SV_ModStart> ) ; } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>
455,"static int do_new_mount ( struct path * path , const char * fstype , int flags , int mnt_flags , const char * name , void * data ) { struct file_system_type * type ; struct user_namespace * user_ns = current -> nsproxy -> mnt_ns -> user_ns ; struct vfsmount * mnt ; int err ; if ( ! fstype ) return - EINVAL ; type = get_fs_type ( fstype ) ; if ( ! type ) return - ENODEV ; if ( user_ns != & init_user_ns ) { if ( ! ( type -> fs_flags & FS_USERNS_MOUNT ) ) { put_filesystem ( type ) ; return - EPERM ; } if ( ! ( type -> fs_flags & FS_USERNS_DEV_MOUNT ) ) { flags |= MS_NODEV ; <S2SV_StartBug> mnt_flags |= MNT_NODEV ; <S2SV_EndBug> } } mnt = vfs_kern_mount ( type , flags , name , data ) ; if ( ! IS_ERR ( mnt ) && ( type -> fs_flags & FS_HAS_SUBTYPE ) && ! mnt -> mnt_sb -> s_subtype ) mnt = fs_set_subtype ( mnt , fstype ) ; put_filesystem ( type ) ; if ( IS_ERR ( mnt ) ) return PTR_ERR ( mnt ) ; err = do_add_mount ( real_mount ( mnt ) , path , mnt_flags ) ; if ( err ) mntput ( mnt ) ; return err ; }",mnt_flags |= MNT_NODEV | MNT_LOCK_NODEV
456,"TEE_Result syscall_cryp_derive_key ( unsigned long state , const struct utee_attribute * usr_params , unsigned long param_count , unsigned long derived_key ) { TEE_Result res = TEE_ERROR_NOT_SUPPORTED ; struct tee_ta_session * sess ; struct tee_obj * ko ; struct tee_obj * so ; struct tee_cryp_state * cs ; struct tee_cryp_obj_secret * sk ; const struct tee_cryp_obj_type_props * type_props ; TEE_Attribute * params = NULL ; struct user_ta_ctx * utc ; res = tee_ta_get_current_session ( & sess ) ; if ( res != TEE_SUCCESS ) return res ; utc = to_user_ta_ctx ( sess -> ctx ) ; res = tee_svc_cryp_get_state ( sess , tee_svc_uref_to_vaddr ( state ) , & cs ) ; if ( res != TEE_SUCCESS ) return res ; <S2SV_StartBug> params = malloc ( sizeof ( TEE_Attribute ) * param_count ) ; <S2SV_EndBug> if ( ! params ) return TEE_ERROR_OUT_OF_MEMORY ; res = copy_in_attrs ( utc , usr_params , param_count , params ) ; if ( res != TEE_SUCCESS ) goto out ; res = tee_obj_get ( utc , cs -> key1 , & ko ) ; if ( res != TEE_SUCCESS ) goto out ; res = tee_obj_get ( utc , tee_svc_uref_to_vaddr ( derived_key ) , & so ) ; if ( res != TEE_SUCCESS ) goto out ; sk = so -> attr ; type_props = tee_svc_find_type_props ( so -> info . objectType ) ; if ( ! type_props ) { res = TEE_ERROR_NOT_SUPPORTED ; goto out ; } if ( cs -> algo == TEE_ALG_DH_DERIVE_SHARED_SECRET ) { size_t alloc_size ; struct bignum * pub ; struct bignum * ss ; if ( param_count != 1 || params [ 0 ] . attributeID != TEE_ATTR_DH_PUBLIC_VALUE ) { res = TEE_ERROR_BAD_PARAMETERS ; goto out ; } alloc_size = params [ 0 ] . content . ref . length * 8 ; pub = crypto_bignum_allocate ( alloc_size ) ; ss = crypto_bignum_allocate ( alloc_size ) ; if ( pub && ss ) { crypto_bignum_bin2bn ( params [ 0 ] . content . ref . buffer , params [ 0 ] . content . ref . length , pub ) ; res = crypto_acipher_dh_shared_secret ( ko -> attr , pub , ss ) ; if ( res == TEE_SUCCESS ) { sk -> key_size = crypto_bignum_num_bytes ( ss ) ; crypto_bignum_bn2bin ( ss , ( uint8_t * ) ( sk + 1 ) ) ; so -> info . handleFlags |= TEE_HANDLE_FLAG_INITIALIZED ; set_attribute ( so , type_props , TEE_ATTR_SECRET_VALUE ) ; } } else { res = TEE_ERROR_OUT_OF_MEMORY ; } crypto_bignum_free ( pub ) ; crypto_bignum_free ( ss ) ; } else if ( TEE_ALG_GET_MAIN_ALG ( cs -> algo ) == TEE_MAIN_ALGO_ECDH ) { size_t alloc_size ; struct ecc_public_key key_public ; uint8_t * pt_secret ; unsigned long pt_secret_len ; if ( param_count != 2 || params [ 0 ] . attributeID != TEE_ATTR_ECC_PUBLIC_VALUE_X || params [ 1 ] . attributeID != TEE_ATTR_ECC_PUBLIC_VALUE_Y ) { res = TEE_ERROR_BAD_PARAMETERS ; goto out ; } switch ( cs -> algo ) { case TEE_ALG_ECDH_P192 : alloc_size = 192 ; break ; case TEE_ALG_ECDH_P224 : alloc_size = 224 ; break ; case TEE_ALG_ECDH_P256 : alloc_size = 256 ; break ; case TEE_ALG_ECDH_P384 : alloc_size = 384 ; break ; case TEE_ALG_ECDH_P521 : alloc_size = 521 ; break ; default : res = TEE_ERROR_NOT_IMPLEMENTED ; goto out ; } res = crypto_acipher_alloc_ecc_public_key ( & key_public , alloc_size ) ; if ( res != TEE_SUCCESS ) goto out ; key_public . curve = ( ( struct ecc_keypair * ) ko -> attr ) -> curve ; crypto_bignum_bin2bn ( params [ 0 ] . content . ref . buffer , params [ 0 ] . content . ref . length , key_public . x ) ; crypto_bignum_bin2bn ( params [ 1 ] . content . ref . buffer , params [ 1 ] . content . ref . length , key_public . y ) ; pt_secret = ( uint8_t * ) ( sk + 1 ) ; pt_secret_len = sk -> alloc_size ; res = crypto_acipher_ecc_shared_secret ( ko -> attr , & key_public , pt_secret , & pt_secret_len ) ; if ( res == TEE_SUCCESS ) { sk -> key_size = pt_secret_len ; so -> info . handleFlags |= TEE_HANDLE_FLAG_INITIALIZED ; set_attribute ( so , type_props , TEE_ATTR_SECRET_VALUE ) ; } crypto_acipher_free_ecc_public_key ( & key_public ) ; } # if defined ( CFG_CRYPTO_HKDF ) else if ( TEE_ALG_GET_MAIN_ALG ( cs -> algo ) == TEE_MAIN_ALGO_HKDF ) { void * salt , * info ; size_t salt_len , info_len , okm_len ; uint32_t hash_id = TEE_ALG_GET_DIGEST_HASH ( cs -> algo ) ; struct tee_cryp_obj_secret * ik = ko -> attr ; const uint8_t * ikm = ( const uint8_t * ) ( ik + 1 ) ; res = get_hkdf_params ( params , param_count , & salt , & salt_len , & info , & info_len , & okm_len ) ; if ( res != TEE_SUCCESS ) goto out ; if ( okm_len > ik -> alloc_size ) { res = TEE_ERROR_BAD_PARAMETERS ; goto out ; } res = tee_cryp_hkdf ( hash_id , ikm , ik -> key_size , salt , salt_len , info , info_len , ( uint8_t * ) ( sk + 1 ) , okm_len ) ; if ( res == TEE_SUCCESS ) { sk -> key_size = okm_len ; so -> info . handleFlags |= TEE_HANDLE_FLAG_INITIALIZED ; set_attribute ( so , type_props , TEE_ATTR_SECRET_VALUE ) ; } } # endif # if defined ( CFG_CRYPTO_CONCAT_KDF ) else if ( TEE_ALG_GET_MAIN_ALG ( cs -> algo ) == TEE_MAIN_ALGO_CONCAT_KDF ) { void * info ; size_t info_len , derived_key_len ; uint32_t hash_id = TEE_ALG_GET_DIGEST_HASH ( cs -> algo ) ; struct tee_cryp_obj_secret * ss = ko -> attr ; const uint8_t * shared_secret = ( const uint8_t * ) ( ss + 1 ) ; res = get_concat_kdf_params ( params , param_count , & info , & info_len , & derived_key_len ) ; if ( res != TEE_SUCCESS ) goto out ; if ( derived_key_len > ss -> alloc_size ) { res = TEE_ERROR_BAD_PARAMETERS ; goto out ; } res = tee_cryp_concat_kdf ( hash_id , shared_secret , ss -> key_size , info , info_len , ( uint8_t * ) ( sk + 1 ) , derived_key_len ) ; if ( res == TEE_SUCCESS ) { sk -> key_size = derived_key_len ; so -> info . handleFlags |= TEE_HANDLE_FLAG_INITIALIZED ; set_attribute ( so , type_props , TEE_ATTR_SECRET_VALUE ) ; } } # endif # if defined ( CFG_CRYPTO_PBKDF2 ) else if ( TEE_ALG_GET_MAIN_ALG ( cs -> algo ) == TEE_MAIN_ALGO_PBKDF2 ) { void * salt ; size_t salt_len , iteration_count , derived_key_len ; uint32_t hash_id = TEE_ALG_GET_DIGEST_HASH ( cs -> algo ) ; struct tee_cryp_obj_secret * ss = ko -> attr ; const uint8_t * password = ( const uint8_t * ) ( ss + 1 ) ; res = get_pbkdf2_params ( params , param_count , & salt , & salt_len , & derived_key_len , & iteration_count ) ; if ( res != TEE_SUCCESS ) goto out ; if ( derived_key_len > ss -> alloc_size ) { res = TEE_ERROR_BAD_PARAMETERS ; goto out ; } res = tee_cryp_pbkdf2 ( hash_id , password , ss -> key_size , salt , salt_len , iteration_count , ( uint8_t * ) ( sk + 1 ) , derived_key_len ) ; if ( res == TEE_SUCCESS ) { sk -> key_size = derived_key_len ; so -> info . handleFlags |= TEE_HANDLE_FLAG_INITIALIZED ; set_attribute ( so , type_props , TEE_ATTR_SECRET_VALUE ) ; } } # endif else res = TEE_ERROR_NOT_SUPPORTED ; out : free ( params ) ; return res ; }","return res ; size_t alloc_size = 0 ; if ( MUL_OVERFLOW ( sizeof ( TEE_Attribute ) , param_count , & alloc_size ) ) return TEE_ERROR_OVERFLOW ; <S2SV_ModStart> = malloc ( alloc_size <S2SV_ModEnd> ) ; if"
457,"<S2SV_StartBug> void vp9_diff_update_prob ( vp9_reader * r , vp9_prob * p ) { <S2SV_EndBug> <S2SV_StartBug> if ( vp9_read ( r , DIFF_UPDATE_PROB ) ) { <S2SV_EndBug> const int delp = decode_term_subexp ( r ) ; <S2SV_StartBug> * p = ( vp9_prob ) inv_remap_prob ( delp , * p ) ; <S2SV_EndBug> } }","void vp9_diff_update_prob ( vpx_reader <S2SV_ModEnd> * r , <S2SV_ModStart> * r , vpx_prob <S2SV_ModEnd> * p ) <S2SV_ModStart> { if ( vpx_read <S2SV_ModEnd> ( r , <S2SV_ModStart> p = ( vpx_prob <S2SV_ModEnd> ) inv_remap_prob ("
458,"<S2SV_StartBug> struct nfs_open_context * nfs_find_open_context ( struct inode * inode , struct rpc_cred * cred , int mode ) <S2SV_EndBug> { struct nfs_inode * nfsi = NFS_I ( inode ) ; struct nfs_open_context * pos , * ctx = NULL ; spin_lock ( & inode -> i_lock ) ; list_for_each_entry ( pos , & nfsi -> open_files , list ) { if ( cred != NULL && pos -> cred != cred ) continue ; if ( ( pos -> mode & mode ) == mode ) { ctx = get_nfs_open_context ( pos ) ; break ; } } spin_unlock ( & inode -> i_lock ) ; return ctx ; }","* cred , fmode_t <S2SV_ModEnd> mode ) {"
459,"static int cypress_open ( struct tty_struct * tty , struct usb_serial_port * port ) { struct cypress_private * priv = usb_get_serial_port_data ( port ) ; struct usb_serial * serial = port -> serial ; unsigned long flags ; int result = 0 ; if ( ! priv -> comm_is_ok ) return - EIO ; usb_clear_halt ( serial -> dev , 0x81 ) ; usb_clear_halt ( serial -> dev , 0x02 ) ; spin_lock_irqsave ( & priv -> lock , flags ) ; priv -> bytes_in = 0 ; priv -> bytes_out = 0 ; priv -> cmd_count = 0 ; priv -> rx_flags = 0 ; spin_unlock_irqrestore ( & priv -> lock , flags ) ; cypress_send ( port ) ; if ( tty ) cypress_set_termios ( tty , port , & priv -> tmp_termios ) ; <S2SV_StartBug> if ( ! port -> interrupt_in_urb ) { <S2SV_EndBug> dev_err ( & port -> dev , ""%s<S2SV_blank>-<S2SV_blank>interrupt_in_urb<S2SV_blank>is<S2SV_blank>empty!\\n"" , __func__ ) ; return - 1 ; } usb_fill_int_urb ( port -> interrupt_in_urb , serial -> dev , usb_rcvintpipe ( serial -> dev , port -> interrupt_in_endpointAddress ) , port -> interrupt_in_urb -> transfer_buffer , port -> interrupt_in_urb -> transfer_buffer_length , cypress_read_int_callback , port , priv -> read_urb_interval ) ; result = usb_submit_urb ( port -> interrupt_in_urb , GFP_KERNEL ) ; if ( result ) { dev_err ( & port -> dev , ""%s<S2SV_blank>-<S2SV_blank>failed<S2SV_blank>submitting<S2SV_blank>read<S2SV_blank>urb,<S2SV_blank>error<S2SV_blank>%d\\n"" , __func__ , result ) ; cypress_set_dead ( port ) ; } return result ; }",tmp_termios ) ; <S2SV_ModEnd> usb_fill_int_urb ( port
460,"int btsock_thread_add_fd ( int h , int fd , int type , int flags , uint32_t user_id ) { if ( h < 0 || h >= MAX_THREAD ) { APPL_TRACE_ERROR ( ""invalid<S2SV_blank>bt<S2SV_blank>thread<S2SV_blank>handle:%d"" , h ) ; return FALSE ; } if ( ts [ h ] . cmd_fdw == - 1 ) { APPL_TRACE_ERROR ( ""cmd<S2SV_blank>socket<S2SV_blank>is<S2SV_blank>not<S2SV_blank>created.<S2SV_blank>socket<S2SV_blank>thread<S2SV_blank>may<S2SV_blank>not<S2SV_blank>initialized"" ) ; return FALSE ; } if ( flags & SOCK_THREAD_ADD_FD_SYNC ) { if ( ts [ h ] . thread_id == pthread_self ( ) ) { flags &= ~ SOCK_THREAD_ADD_FD_SYNC ; add_poll ( h , fd , type , flags , user_id ) ; return TRUE ; } APPL_TRACE_DEBUG ( ""THREAD_ADD_FD_SYNC<S2SV_blank>is<S2SV_blank>not<S2SV_blank>called<S2SV_blank>in<S2SV_blank>poll<S2SV_blank>thread,<S2SV_blank>fallback<S2SV_blank>to<S2SV_blank>async"" ) ; } sock_cmd_t cmd = { CMD_ADD_FD , fd , type , flags , user_id } ; APPL_TRACE_DEBUG ( ""adding<S2SV_blank>fd:%d,<S2SV_blank>flags:0x%x"" , fd , flags ) ; <S2SV_StartBug> return send ( ts [ h ] . cmd_fdw , & cmd , sizeof ( cmd ) , 0 ) == sizeof ( cmd ) ; <S2SV_EndBug> }",") ; return TEMP_FAILURE_RETRY ( <S2SV_ModStart> , 0 ) )"
461,"static int cac_cac1_get_certificate ( sc_card_t * card , u8 * * out_buf , size_t * out_len ) { u8 buf [ CAC_MAX_SIZE ] ; u8 * out_ptr ; size_t size = 0 ; size_t left = 0 ; <S2SV_StartBug> size_t len , next_len ; <S2SV_EndBug> sc_apdu_t apdu ; int r = SC_SUCCESS ; SC_FUNC_CALLED ( card -> ctx , SC_LOG_DEBUG_VERBOSE ) ; size = left = * out_buf ? * out_len : sizeof ( buf ) ; out_ptr = * out_buf ? * out_buf : buf ; sc_format_apdu ( card , & apdu , SC_APDU_CASE_2_SHORT , CAC_INS_GET_CERTIFICATE , 0 , 0 ) ; <S2SV_StartBug> next_len = MIN ( left , 100 ) ; <S2SV_EndBug> <S2SV_StartBug> for ( ; left > 0 ; left -= len , out_ptr += len ) { <S2SV_EndBug> len = next_len ; apdu . resp = out_ptr ; apdu . le = len ; apdu . resplen = left ; r = sc_transmit_apdu ( card , & apdu ) ; if ( r < 0 ) { break ; } if ( apdu . resplen == 0 ) { r = SC_ERROR_INTERNAL ; break ; } if ( apdu . sw1 != 0x63 || apdu . sw2 < 1 ) { r = sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ; left -= len ; break ; } <S2SV_StartBug> next_len = MIN ( left , apdu . sw2 ) ; <S2SV_EndBug> } if ( r < 0 ) { SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , r ) ; } r = size - left ; if ( * out_buf == NULL ) { * out_buf = malloc ( r ) ; if ( * out_buf == NULL ) { SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , SC_ERROR_OUT_OF_MEMORY ) ; } memcpy ( * out_buf , buf , r ) ; } * out_len = r ; SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_VERBOSE , r ) ; }",; size_t len <S2SV_ModEnd> ; sc_apdu_t apdu <S2SV_ModStart> 0 ) ; len <S2SV_ModEnd> = MIN ( <S2SV_ModStart> > 0 ; ) { <S2SV_ModEnd> apdu . resp <S2SV_ModStart> break ; } left -= len ; out_ptr += len ; len <S2SV_ModEnd> = MIN (
462,"static void ProcessRadioRxDone ( void ) { LoRaMacHeader_t macHdr ; ApplyCFListParams_t applyCFList ; GetPhyParams_t getPhy ; PhyParam_t phyParam ; LoRaMacCryptoStatus_t macCryptoStatus = LORAMAC_CRYPTO_ERROR ; LoRaMacMessageData_t macMsgData ; LoRaMacMessageJoinAccept_t macMsgJoinAccept ; uint8_t * payload = RxDoneParams . Payload ; uint16_t size = RxDoneParams . Size ; int16_t rssi = RxDoneParams . Rssi ; int8_t snr = RxDoneParams . Snr ; uint8_t pktHeaderLen = 0 ; uint32_t downLinkCounter = 0 ; uint32_t address = MacCtx . NvmCtx -> DevAddr ; uint8_t multicast = 0 ; AddressIdentifier_t addrID = UNICAST_DEV_ADDR ; FCntIdentifier_t fCntID ; MacCtx . McpsConfirm . AckReceived = false ; MacCtx . McpsIndication . Rssi = rssi ; MacCtx . McpsIndication . Snr = snr ; MacCtx . McpsIndication . RxSlot = MacCtx . RxSlot ; MacCtx . McpsIndication . Port = 0 ; MacCtx . McpsIndication . Multicast = 0 ; MacCtx . McpsIndication . FramePending = 0 ; MacCtx . McpsIndication . Buffer = NULL ; MacCtx . McpsIndication . BufferSize = 0 ; MacCtx . McpsIndication . RxData = false ; MacCtx . McpsIndication . AckReceived = false ; MacCtx . McpsIndication . DownLinkCounter = 0 ; MacCtx . McpsIndication . McpsIndication = MCPS_UNCONFIRMED ; MacCtx . McpsIndication . DevAddress = 0 ; MacCtx . McpsIndication . DeviceTimeAnsReceived = false ; Radio . Sleep ( ) ; TimerStop ( & MacCtx . RxWindowTimer2 ) ; if ( LoRaMacClassBRxBeacon ( payload , size ) == true ) { MacCtx . MlmeIndication . BeaconInfo . Rssi = rssi ; MacCtx . MlmeIndication . BeaconInfo . Snr = snr ; return ; } if ( MacCtx . NvmCtx -> DeviceClass == CLASS_B ) { if ( LoRaMacClassBIsPingExpected ( ) == true ) { LoRaMacClassBSetPingSlotState ( PINGSLOT_STATE_CALC_PING_OFFSET ) ; LoRaMacClassBPingSlotTimerEvent ( NULL ) ; MacCtx . McpsIndication . RxSlot = RX_SLOT_WIN_CLASS_B_PING_SLOT ; } else if ( LoRaMacClassBIsMulticastExpected ( ) == true ) { LoRaMacClassBSetMulticastSlotState ( PINGSLOT_STATE_CALC_PING_OFFSET ) ; LoRaMacClassBMulticastSlotTimerEvent ( NULL ) ; MacCtx . McpsIndication . RxSlot = RX_SLOT_WIN_CLASS_B_MULTICAST_SLOT ; } } macHdr . Value = payload [ pktHeaderLen ++ ] ; switch ( macHdr . Bits . MType ) { <S2SV_StartBug> case FRAME_TYPE_JOIN_ACCEPT : <S2SV_EndBug> macMsgJoinAccept . Buffer = payload ; macMsgJoinAccept . BufSize = size ; if ( MacCtx . NvmCtx -> NetworkActivation != ACTIVATION_TYPE_NONE ) { MacCtx . McpsIndication . Status = LORAMAC_EVENT_INFO_STATUS_ERROR ; PrepareRxDoneAbort ( ) ; return ; } macCryptoStatus = LoRaMacCryptoHandleJoinAccept ( JOIN_REQ , SecureElementGetJoinEui ( ) , & macMsgJoinAccept ) ; if ( LORAMAC_CRYPTO_SUCCESS == macCryptoStatus ) { MacCtx . NvmCtx -> NetID = ( uint32_t ) macMsgJoinAccept . NetID [ 0 ] ; MacCtx . NvmCtx -> NetID |= ( ( uint32_t ) macMsgJoinAccept . NetID [ 1 ] << 8 ) ; MacCtx . NvmCtx -> NetID |= ( ( uint32_t ) macMsgJoinAccept . NetID [ 2 ] << 16 ) ; MacCtx . NvmCtx -> DevAddr = macMsgJoinAccept . DevAddr ; MacCtx . NvmCtx -> MacParams . Rx1DrOffset = macMsgJoinAccept . DLSettings . Bits . RX1DRoffset ; MacCtx . NvmCtx -> MacParams . Rx2Channel . Datarate = macMsgJoinAccept . DLSettings . Bits . RX2DataRate ; MacCtx . NvmCtx -> MacParams . RxCChannel . Datarate = macMsgJoinAccept . DLSettings . Bits . RX2DataRate ; MacCtx . NvmCtx -> MacParams . ReceiveDelay1 = macMsgJoinAccept . RxDelay ; if ( MacCtx . NvmCtx -> MacParams . ReceiveDelay1 == 0 ) { MacCtx . NvmCtx -> MacParams . ReceiveDelay1 = 1 ; } MacCtx . NvmCtx -> MacParams . ReceiveDelay1 *= 1000 ; MacCtx . NvmCtx -> MacParams . ReceiveDelay2 = MacCtx . NvmCtx -> MacParams . ReceiveDelay1 + 1000 ; MacCtx . NvmCtx -> Version . Fields . Minor = 0 ; applyCFList . Payload = macMsgJoinAccept . CFList ; applyCFList . Size = size - 17 ; RegionApplyCFList ( MacCtx . NvmCtx -> Region , & applyCFList ) ; MacCtx . NvmCtx -> NetworkActivation = ACTIVATION_TYPE_OTAA ; if ( LoRaMacConfirmQueueIsCmdActive ( MLME_JOIN ) == true ) { LoRaMacConfirmQueueSetStatus ( LORAMAC_EVENT_INFO_STATUS_OK , MLME_JOIN ) ; } } else { if ( LoRaMacConfirmQueueIsCmdActive ( MLME_JOIN ) == true ) { LoRaMacConfirmQueueSetStatus ( LORAMAC_EVENT_INFO_STATUS_JOIN_FAIL , MLME_JOIN ) ; } } break ; case FRAME_TYPE_DATA_CONFIRMED_DOWN : MacCtx . McpsIndication . McpsIndication = MCPS_CONFIRMED ; case FRAME_TYPE_DATA_UNCONFIRMED_DOWN : getPhy . UplinkDwellTime = MacCtx . NvmCtx -> MacParams . DownlinkDwellTime ; getPhy . Datarate = MacCtx . McpsIndication . RxDatarate ; getPhy . Attribute = PHY_MAX_PAYLOAD ; phyParam = RegionGetPhyParam ( MacCtx . NvmCtx -> Region , & getPhy ) ; <S2SV_StartBug> if ( MAX ( 0 , ( int16_t ) ( ( int16_t ) size - ( int16_t ) LORA_MAC_FRMPAYLOAD_OVERHEAD ) ) > ( int16_t ) phyParam . Value ) <S2SV_EndBug> { MacCtx . McpsIndication . Status = LORAMAC_EVENT_INFO_STATUS_ERROR ; PrepareRxDoneAbort ( ) ; return ; } macMsgData . Buffer = payload ; macMsgData . BufSize = size ; macMsgData . FRMPayload = MacCtx . RxPayload ; macMsgData . FRMPayloadSize = LORAMAC_PHY_MAXPAYLOAD ; if ( LORAMAC_PARSER_SUCCESS != LoRaMacParserData ( & macMsgData ) ) { MacCtx . McpsIndication . Status = LORAMAC_EVENT_INFO_STATUS_ERROR ; PrepareRxDoneAbort ( ) ; return ; } MacCtx . McpsIndication . DevAddress = macMsgData . FHDR . DevAddr ; FType_t fType ; if ( LORAMAC_STATUS_OK != DetermineFrameType ( & macMsgData , & fType ) ) { MacCtx . McpsIndication . Status = LORAMAC_EVENT_INFO_STATUS_ERROR ; PrepareRxDoneAbort ( ) ; return ; } multicast = 0 ; downLinkCounter = 0 ; for ( uint8_t i = 0 ; i < LORAMAC_MAX_MC_CTX ; i ++ ) { if ( ( MacCtx . NvmCtx -> MulticastChannelList [ i ] . ChannelParams . Address == macMsgData . FHDR . DevAddr ) && ( MacCtx . NvmCtx -> MulticastChannelList [ i ] . ChannelParams . IsEnabled == true ) ) { multicast = 1 ; addrID = MacCtx . NvmCtx -> MulticastChannelList [ i ] . ChannelParams . GroupID ; downLinkCounter = * ( MacCtx . NvmCtx -> MulticastChannelList [ i ] . DownLinkCounter ) ; address = MacCtx . NvmCtx -> MulticastChannelList [ i ] . ChannelParams . Address ; if ( MacCtx . NvmCtx -> DeviceClass == CLASS_C ) { MacCtx . McpsIndication . RxSlot = RX_SLOT_WIN_CLASS_C_MULTICAST ; } break ; } } if ( ( multicast == 1 ) && ( ( fType != FRAME_TYPE_D ) || ( macMsgData . FHDR . FCtrl . Bits . Ack == true ) || ( macMsgData . FHDR . FCtrl . Bits . AdrAckReq == true ) ) ) { MacCtx . McpsIndication . Status = LORAMAC_EVENT_INFO_STATUS_ERROR ; PrepareRxDoneAbort ( ) ; return ; } getPhy . Attribute = PHY_MAX_FCNT_GAP ; phyParam = RegionGetPhyParam ( MacCtx . NvmCtx -> Region , & getPhy ) ; macCryptoStatus = GetFCntDown ( addrID , fType , & macMsgData , MacCtx . NvmCtx -> Version , phyParam . Value , & fCntID , & downLinkCounter ) ; if ( macCryptoStatus != LORAMAC_CRYPTO_SUCCESS ) { if ( macCryptoStatus == LORAMAC_CRYPTO_FAIL_FCNT_DUPLICATED ) { MacCtx . McpsIndication . Status = LORAMAC_EVENT_INFO_STATUS_DOWNLINK_REPEATED ; if ( ( MacCtx . NvmCtx -> Version . Fields . Minor == 0 ) && ( macHdr . Bits . MType == FRAME_TYPE_DATA_CONFIRMED_DOWN ) && ( MacCtx . NvmCtx -> LastRxMic == macMsgData . MIC ) ) { MacCtx . NvmCtx -> SrvAckRequested = true ; } } else if ( macCryptoStatus == LORAMAC_CRYPTO_FAIL_MAX_GAP_FCNT ) { MacCtx . McpsIndication . Status = LORAMAC_EVENT_INFO_STATUS_DOWNLINK_TOO_MANY_FRAMES_LOSS ; } else { MacCtx . McpsIndication . Status = LORAMAC_EVENT_INFO_STATUS_ERROR ; } MacCtx . McpsIndication . DownLinkCounter = downLinkCounter ; PrepareRxDoneAbort ( ) ; return ; } macCryptoStatus = LoRaMacCryptoUnsecureMessage ( addrID , address , fCntID , downLinkCounter , & macMsgData ) ; if ( macCryptoStatus != LORAMAC_CRYPTO_SUCCESS ) { if ( macCryptoStatus == LORAMAC_CRYPTO_FAIL_ADDRESS ) { MacCtx . McpsIndication . Status = LORAMAC_EVENT_INFO_STATUS_ADDRESS_FAIL ; } else { MacCtx . McpsIndication . Status = LORAMAC_EVENT_INFO_STATUS_MIC_FAIL ; } PrepareRxDoneAbort ( ) ; return ; } MacCtx . McpsIndication . Status = LORAMAC_EVENT_INFO_STATUS_OK ; MacCtx . McpsIndication . Multicast = multicast ; MacCtx . McpsIndication . FramePending = macMsgData . FHDR . FCtrl . Bits . FPending ; MacCtx . McpsIndication . Buffer = NULL ; MacCtx . McpsIndication . BufferSize = 0 ; MacCtx . McpsIndication . DownLinkCounter = downLinkCounter ; MacCtx . McpsIndication . AckReceived = macMsgData . FHDR . FCtrl . Bits . Ack ; MacCtx . McpsConfirm . Status = LORAMAC_EVENT_INFO_STATUS_OK ; MacCtx . McpsConfirm . AckReceived = macMsgData . FHDR . FCtrl . Bits . Ack ; if ( ( MacCtx . McpsIndication . RxSlot == RX_SLOT_WIN_1 ) || ( MacCtx . McpsIndication . RxSlot == RX_SLOT_WIN_2 ) ) { MacCtx . NvmCtx -> AdrAckCounter = 0 ; } if ( multicast == 1 ) { MacCtx . McpsIndication . McpsIndication = MCPS_MULTICAST ; } else { if ( macHdr . Bits . MType == FRAME_TYPE_DATA_CONFIRMED_DOWN ) { MacCtx . NvmCtx -> SrvAckRequested = true ; if ( MacCtx . NvmCtx -> Version . Fields . Minor == 0 ) { MacCtx . NvmCtx -> LastRxMic = macMsgData . MIC ; } MacCtx . McpsIndication . McpsIndication = MCPS_CONFIRMED ; } else { MacCtx . NvmCtx -> SrvAckRequested = false ; MacCtx . McpsIndication . McpsIndication = MCPS_UNCONFIRMED ; } } RemoveMacCommands ( MacCtx . McpsIndication . RxSlot , macMsgData . FHDR . FCtrl , MacCtx . McpsConfirm . McpsRequest ) ; switch ( fType ) { case FRAME_TYPE_A : { ProcessMacCommands ( macMsgData . FHDR . FOpts , 0 , macMsgData . FHDR . FCtrl . Bits . FOptsLen , snr , MacCtx . McpsIndication . RxSlot ) ; MacCtx . McpsIndication . Port = macMsgData . FPort ; MacCtx . McpsIndication . Buffer = macMsgData . FRMPayload ; MacCtx . McpsIndication . BufferSize = macMsgData . FRMPayloadSize ; MacCtx . McpsIndication . RxData = true ; break ; } case FRAME_TYPE_B : { ProcessMacCommands ( macMsgData . FHDR . FOpts , 0 , macMsgData . FHDR . FCtrl . Bits . FOptsLen , snr , MacCtx . McpsIndication . RxSlot ) ; MacCtx . McpsIndication . Port = macMsgData . FPort ; break ; } case FRAME_TYPE_C : { ProcessMacCommands ( macMsgData . FRMPayload , 0 , macMsgData . FRMPayloadSize , snr , MacCtx . McpsIndication . RxSlot ) ; MacCtx . McpsIndication . Port = macMsgData . FPort ; break ; } case FRAME_TYPE_D : { MacCtx . McpsIndication . Port = macMsgData . FPort ; MacCtx . McpsIndication . Buffer = macMsgData . FRMPayload ; MacCtx . McpsIndication . BufferSize = macMsgData . FRMPayloadSize ; MacCtx . McpsIndication . RxData = true ; break ; } default : MacCtx . McpsIndication . Status = LORAMAC_EVENT_INFO_STATUS_ERROR ; PrepareRxDoneAbort ( ) ; break ; } MacCtx . MacFlags . Bits . McpsInd = 1 ; break ; case FRAME_TYPE_PROPRIETARY : memcpy1 ( MacCtx . RxPayload , & payload [ pktHeaderLen ] , size - pktHeaderLen ) ; MacCtx . McpsIndication . McpsIndication = MCPS_PROPRIETARY ; MacCtx . McpsIndication . Status = LORAMAC_EVENT_INFO_STATUS_OK ; MacCtx . McpsIndication . Buffer = MacCtx . RxPayload ; MacCtx . McpsIndication . BufferSize = size - pktHeaderLen ; MacCtx . MacFlags . Bits . McpsInd = 1 ; break ; default : MacCtx . McpsIndication . Status = LORAMAC_EVENT_INFO_STATUS_ERROR ; PrepareRxDoneAbort ( ) ; break ; } if ( MacCtx . NodeAckRequested == true ) { if ( MacCtx . McpsConfirm . AckReceived == true ) { OnAckTimeoutTimerEvent ( NULL ) ; } } else { if ( MacCtx . NvmCtx -> DeviceClass == CLASS_C ) { OnAckTimeoutTimerEvent ( NULL ) ; } } MacCtx . MacFlags . Bits . MacDone = 1 ; UpdateRxSlotIdleState ( ) ; }",case FRAME_TYPE_JOIN_ACCEPT : if ( size < LORAMAC_JOIN_ACCEPT_FRAME_MIN_SIZE ) { MacCtx . McpsIndication . Status = LORAMAC_EVENT_INFO_STATUS_ERROR ; PrepareRxDoneAbort ( ) ; return ; } <S2SV_ModStart> ; if ( ( <S2SV_ModStart> ( int16_t ) LORAMAC_FRAME_PAYLOAD_OVERHEAD_SIZE <S2SV_ModEnd> ) ) > <S2SV_ModStart> phyParam . Value ) || ( size < LORAMAC_FRAME_PAYLOAD_MIN_SIZE )
463,"static int attach_child_main ( void * data ) { struct attach_clone_payload * payload = ( struct attach_clone_payload * ) data ; int ipc_socket = payload -> ipc_socket ; <S2SV_StartBug> lxc_attach_options_t * options = payload -> options ; <S2SV_EndBug> struct lxc_proc_context_info * init_ctx = payload -> init_ctx ; # if HAVE_SYS_PERSONALITY_H long new_personality ; # endif int ret ; int status ; int expected ; long flags ; int fd ; uid_t new_uid ; gid_t new_gid ; expected = 0 ; status = - 1 ; ret = lxc_read_nointr_expect ( ipc_socket , & status , sizeof ( status ) , & expected ) ; if ( ret <= 0 ) { ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>notification<S2SV_blank>from<S2SV_blank>initial<S2SV_blank>process<S2SV_blank>(0)"" ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } if ( ! ( options -> namespaces & CLONE_NEWNS ) && ( options -> attach_flags & LXC_ATTACH_REMOUNT_PROC_SYS ) ) { ret = lxc_attach_remount_sys_proc ( ) ; if ( ret < 0 ) { shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } } # if HAVE_SYS_PERSONALITY_H if ( options -> personality < 0 ) new_personality = init_ctx -> personality ; else new_personality = options -> personality ; if ( options -> attach_flags & LXC_ATTACH_SET_PERSONALITY ) { ret = personality ( new_personality ) ; if ( ret < 0 ) { SYSERROR ( ""could<S2SV_blank>not<S2SV_blank>ensure<S2SV_blank>correct<S2SV_blank>architecture"" ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } } # endif if ( options -> attach_flags & LXC_ATTACH_DROP_CAPABILITIES ) { ret = lxc_attach_drop_privs ( init_ctx ) ; if ( ret < 0 ) { ERROR ( ""could<S2SV_blank>not<S2SV_blank>drop<S2SV_blank>privileges"" ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } } ret = lxc_attach_set_environment ( options -> env_policy , options -> extra_env_vars , options -> extra_keep_env ) ; if ( ret < 0 ) { ERROR ( ""could<S2SV_blank>not<S2SV_blank>set<S2SV_blank>initial<S2SV_blank>environment<S2SV_blank>for<S2SV_blank>attached<S2SV_blank>process"" ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } new_uid = 0 ; new_gid = 0 ; if ( options -> namespaces & CLONE_NEWUSER ) lxc_attach_get_init_uidgid ( & new_uid , & new_gid ) ; if ( options -> uid != ( uid_t ) - 1 ) new_uid = options -> uid ; if ( options -> gid != ( gid_t ) - 1 ) new_gid = options -> gid ; if ( options -> stdin_fd && isatty ( options -> stdin_fd ) ) { if ( setsid ( ) < 0 ) { SYSERROR ( ""unable<S2SV_blank>to<S2SV_blank>setsid"" ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } if ( ioctl ( options -> stdin_fd , TIOCSCTTY , ( char * ) NULL ) < 0 ) { SYSERROR ( ""unable<S2SV_blank>to<S2SV_blank>TIOCSTTY"" ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } } if ( ( new_gid != 0 || options -> namespaces & CLONE_NEWUSER ) ) { if ( setgid ( new_gid ) || setgroups ( 0 , NULL ) ) { SYSERROR ( ""switching<S2SV_blank>to<S2SV_blank>container<S2SV_blank>gid"" ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } } if ( ( new_uid != 0 || options -> namespaces & CLONE_NEWUSER ) && setuid ( new_uid ) ) { SYSERROR ( ""switching<S2SV_blank>to<S2SV_blank>container<S2SV_blank>uid"" ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } status = 1 ; ret = lxc_write_nointr ( ipc_socket , & status , sizeof ( status ) ) ; if ( ret != sizeof ( status ) ) { ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>notify<S2SV_blank>initial<S2SV_blank>process<S2SV_blank>for<S2SV_blank>initialization<S2SV_blank>(1)"" ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } expected = 2 ; status = - 1 ; ret = lxc_read_nointr_expect ( ipc_socket , & status , sizeof ( status ) , & expected ) ; if ( ret <= 0 ) { ERROR ( ""error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>final<S2SV_blank>notification<S2SV_blank>from<S2SV_blank>initial<S2SV_blank>process<S2SV_blank>(2)"" ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } shutdown ( ipc_socket , SHUT_RDWR ) ; close ( ipc_socket ) ; <S2SV_StartBug> if ( ( options -> namespaces & CLONE_NEWNS ) && ( options -> attach_flags & LXC_ATTACH_LSM ) ) { <S2SV_EndBug> int on_exec ; <S2SV_StartBug> int proc_mounted ; <S2SV_EndBug> on_exec = options -> attach_flags & LXC_ATTACH_LSM_EXEC ? 1 : 0 ; <S2SV_StartBug> proc_mounted = mount_proc_if_needed ( ""/"" ) ; <S2SV_EndBug> if ( proc_mounted == - 1 ) { ERROR ( ""Error<S2SV_blank>mounting<S2SV_blank>a<S2SV_blank>sane<S2SV_blank>/proc"" ) ; rexit ( - 1 ) ; } <S2SV_StartBug> ret = lsm_process_label_set ( init_ctx -> lsm_label , <S2SV_EndBug> init_ctx -> container -> lxc_conf , 0 , on_exec ) ; if ( proc_mounted ) umount ( ""/proc"" ) ; if ( ret < 0 ) { rexit ( - 1 ) ; } } if ( init_ctx -> container && init_ctx -> container -> lxc_conf && lxc_seccomp_load ( init_ctx -> container -> lxc_conf ) != 0 ) { ERROR ( ""Loading<S2SV_blank>seccomp<S2SV_blank>policy"" ) ; rexit ( - 1 ) ; } lxc_proc_put_context_info ( init_ctx ) ; if ( options -> stdin_fd >= 0 && options -> stdin_fd != 0 ) dup2 ( options -> stdin_fd , 0 ) ; if ( options -> stdout_fd >= 0 && options -> stdout_fd != 1 ) dup2 ( options -> stdout_fd , 1 ) ; if ( options -> stderr_fd >= 0 && options -> stderr_fd != 2 ) dup2 ( options -> stderr_fd , 2 ) ; if ( options -> stdin_fd > 2 ) close ( options -> stdin_fd ) ; if ( options -> stdout_fd > 2 ) close ( options -> stdout_fd ) ; if ( options -> stderr_fd > 2 ) close ( options -> stderr_fd ) ; for ( fd = 0 ; fd <= 2 ; fd ++ ) { flags = fcntl ( fd , F_GETFL ) ; if ( flags < 0 ) continue ; if ( flags & FD_CLOEXEC ) { if ( fcntl ( fd , F_SETFL , flags & ~ FD_CLOEXEC ) < 0 ) { SYSERROR ( ""Unable<S2SV_blank>to<S2SV_blank>clear<S2SV_blank>CLOEXEC<S2SV_blank>from<S2SV_blank>fd"" ) ; } } } <S2SV_StartBug> rexit ( payload -> exec_function ( payload -> exec_payload ) ) ; <S2SV_EndBug> }","-> ipc_socket ; int procfd = payload -> procfd ; <S2SV_ModStart> & LXC_ATTACH_LSM ) && init_ctx -> lsm_label <S2SV_ModStart> int on_exec ; <S2SV_ModEnd> on_exec = options <S2SV_ModStart> : 0 ; if ( lsm_set_label_at ( procfd , on_exec , <S2SV_ModEnd> init_ctx -> lsm_label <S2SV_ModStart> init_ctx -> lsm_label ) <S2SV_ModEnd> < 0 ) <S2SV_ModStart> } } } close ( procfd ) ;"
464,"SYSCALL_DEFINE1 ( inotify_init1 , int , flags ) { <S2SV_StartBug> struct fsnotify_group * group ; <S2SV_EndBug> struct user_struct * user ; int ret ; BUILD_BUG_ON ( IN_CLOEXEC != O_CLOEXEC ) ; BUILD_BUG_ON ( IN_NONBLOCK != O_NONBLOCK ) ; if ( flags & ~ ( IN_CLOEXEC | IN_NONBLOCK ) ) return - EINVAL ; <S2SV_StartBug> user = get_current_user ( ) ; <S2SV_EndBug> if ( unlikely ( atomic_read ( & user -> inotify_devs ) >= inotify_max_user_instances ) ) { ret = - EMFILE ; goto out_free_uid ; } <S2SV_StartBug> group = inotify_new_group ( user , inotify_max_queued_events ) ; <S2SV_EndBug> <S2SV_StartBug> if ( IS_ERR ( group ) ) { <S2SV_EndBug> <S2SV_StartBug> ret = PTR_ERR ( group ) ; <S2SV_EndBug> goto out_free_uid ; } atomic_inc ( & user -> inotify_devs ) ; ret = anon_inode_getfd ( ""inotify"" , & inotify_fops , group , O_RDONLY | flags ) ; <S2SV_StartBug> if ( ret >= 0 ) <S2SV_EndBug> return ret ; <S2SV_StartBug> fsnotify_put_group ( group ) ; <S2SV_EndBug> atomic_dec ( & user -> inotify_devs ) ; out_free_uid : free_uid ( user ) ; return ret ; }",fsnotify_group * group <S2SV_ModEnd> ; int ret <S2SV_ModStart> - EINVAL ; <S2SV_ModEnd> group = inotify_new_group <S2SV_ModStart> = inotify_new_group ( <S2SV_ModEnd> inotify_max_queued_events ) ; <S2SV_ModStart> group ) ) return <S2SV_ModEnd> PTR_ERR ( group <S2SV_ModStart> PTR_ERR ( group <S2SV_ModEnd> ) ; ret <S2SV_ModStart> if ( ret < 0 ) <S2SV_ModEnd> fsnotify_put_group ( group <S2SV_ModStart> fsnotify_put_group ( group <S2SV_ModEnd> ) ; return
465,"static size_t consume_init_expr ( ut8 * buf , ut8 * max , ut8 eoc , void * out , ut32 * offset ) { ut32 i = 0 ; while ( buf + i < max && buf [ i ] != eoc ) { <S2SV_StartBug> i += 1 ; <S2SV_EndBug> } if ( buf [ i ] != eoc ) { return 0 ; } if ( offset ) { * offset += i + 1 ; } return i + 1 ; }",) { i ++ <S2SV_ModEnd> ; } if
466,"<S2SV_StartBug> static vpx_codec_err_t vp8e_use_reference ( vpx_codec_alg_priv_t * ctx , <S2SV_EndBug> int ctr_id , va_list args ) { int reference_flag = va_arg ( args , int ) ; vp8_use_as_reference ( ctx -> cpi , reference_flag ) ; return VPX_CODEC_OK ; }","vpx_codec_alg_priv_t * ctx <S2SV_ModEnd> , va_list args"
467,"static struct super_block * alloc_super ( struct file_system_type * type , int flags ) { struct super_block * s = kzalloc ( sizeof ( struct super_block ) , GFP_USER ) ; static const struct super_operations default_op ; int i ; if ( ! s ) return NULL ; if ( security_sb_alloc ( s ) ) goto fail ; <S2SV_StartBug> # ifdef CONFIG_SMP <S2SV_EndBug> s -> s_files = alloc_percpu ( struct list_head ) ; if ( ! s -> s_files ) goto fail ; <S2SV_StartBug> for_each_possible_cpu ( i ) <S2SV_EndBug> INIT_LIST_HEAD ( per_cpu_ptr ( s -> s_files , i ) ) ; # else INIT_LIST_HEAD ( & s -> s_files ) ; # endif for ( i = 0 ; i < SB_FREEZE_LEVELS ; i ++ ) { if ( percpu_counter_init ( & s -> s_writers . counter [ i ] , 0 ) < 0 ) goto fail ; <S2SV_StartBug> lockdep_init_map ( & s -> s_writers . lock_map [ i ] , sb_writers_name [ i ] , <S2SV_EndBug> & type -> s_writers_key [ i ] , 0 ) ; } init_waitqueue_head ( & s -> s_writers . wait ) ; init_waitqueue_head ( & s -> s_writers . wait_unfrozen ) ; s -> s_flags = flags ; s -> s_bdi = & default_backing_dev_info ; INIT_HLIST_NODE ( & s -> s_instances ) ; INIT_HLIST_BL_HEAD ( & s -> s_anon ) ; INIT_LIST_HEAD ( & s -> s_inodes ) ; <S2SV_StartBug> if ( list_lru_init ( & s -> s_dentry_lru ) ) <S2SV_EndBug> goto fail ; <S2SV_StartBug> if ( list_lru_init ( & s -> s_inode_lru ) ) <S2SV_EndBug> goto fail ; INIT_LIST_HEAD ( & s -> s_mounts ) ; init_rwsem ( & s -> s_umount ) ; lockdep_set_class ( & s -> s_umount , & type -> s_umount_key ) ; down_write_nested ( & s -> s_umount , SINGLE_DEPTH_NESTING ) ; s -> s_count = 1 ; atomic_set ( & s -> s_active , 1 ) ; mutex_init ( & s -> s_vfs_rename_mutex ) ; lockdep_set_class ( & s -> s_vfs_rename_mutex , & type -> s_vfs_rename_key ) ; mutex_init ( & s -> s_dquot . dqio_mutex ) ; mutex_init ( & s -> s_dquot . dqonoff_mutex ) ; init_rwsem ( & s -> s_dquot . dqptr_sem ) ; s -> s_maxbytes = MAX_NON_LFS ; s -> s_op = & default_op ; s -> s_time_gran = 1000000000 ; s -> cleancache_poolid = - 1 ; s -> s_shrink . seeks = DEFAULT_SEEKS ; s -> s_shrink . scan_objects = super_cache_scan ; s -> s_shrink . count_objects = super_cache_count ; s -> s_shrink . batch = 1024 ; s -> s_shrink . flags = SHRINKER_NUMA_AWARE ; return s ; fail : destroy_super ( s ) ; return NULL ; }","goto fail ; for ( i = 0 ; i < SB_FREEZE_LEVELS ; i ++ ) { if ( percpu_counter_init ( & s -> s_writers . counter [ i ] , 0 ) < 0 <S2SV_ModEnd> ) goto fail <S2SV_ModStart> goto fail ; lockdep_init_map ( & s -> s_writers . lock_map [ i ] , sb_writers_name [ i ] , & type -> s_writers_key [ i ] , 0 ) ; } init_waitqueue_head ( & s -> s_writers . wait ) ; init_waitqueue_head ( & s -> s_writers . wait_unfrozen ) ; s -> s_flags = flags ; s -> s_bdi = & default_backing_dev_info ; INIT_HLIST_NODE ( & s -> s_instances ) ; INIT_HLIST_BL_HEAD ( & s -> s_anon ) ; INIT_LIST_HEAD ( & s -> s_inodes ) ; if ( list_lru_init ( & s -> s_dentry_lru ) <S2SV_ModEnd> ) goto fail <S2SV_ModStart> goto fail ; <S2SV_ModEnd> if ( list_lru_init <S2SV_ModStart> & s -> s_inode_lru <S2SV_ModEnd> ) ) goto <S2SV_ModStart> goto fail ; <S2SV_ModEnd> INIT_LIST_HEAD ( &"
468,"static ssize_t __nfs4_get_acl_uncached ( struct inode * inode , void * buf , size_t buflen ) { <S2SV_StartBug> struct page * pages [ NFS4ACL_MAXPAGES ] ; <S2SV_EndBug> struct nfs_getaclargs args = { . fh = NFS_FH ( inode ) , . acl_pages = pages , . acl_len = buflen , } ; struct nfs_getaclres res = { . acl_len = buflen , } ; void * resp_buf ; struct rpc_message msg = { . rpc_proc = & nfs4_procedures [ NFSPROC4_CLNT_GETACL ] , . rpc_argp = & args , . rpc_resp = & res , } ; <S2SV_StartBug> struct page * localpage = NULL ; <S2SV_EndBug> int ret ; if ( buflen < PAGE_SIZE ) { localpage = alloc_page ( GFP_KERNEL ) ; resp_buf = page_address ( localpage ) ; if ( localpage == NULL ) <S2SV_StartBug> return - ENOMEM ; <S2SV_EndBug> args . acl_pages [ 0 ] = localpage ; args . acl_pgbase = 0 ; args . acl_len = PAGE_SIZE ; } else { resp_buf = buf ; buf_to_pages ( buf , buflen , args . acl_pages , & args . acl_pgbase ) ; } ret = nfs4_call_sync ( NFS_SERVER ( inode ) -> client , NFS_SERVER ( inode ) , & msg , & args . seq_args , & res . seq_res , 0 ) ; if ( ret ) goto out_free ; <S2SV_StartBug> if ( res . acl_len > args . acl_len ) <S2SV_EndBug> <S2SV_StartBug> nfs4_write_cached_acl ( inode , NULL , res . acl_len ) ; <S2SV_EndBug> else <S2SV_StartBug> nfs4_write_cached_acl ( inode , resp_buf , res . acl_len ) ; <S2SV_EndBug> if ( buf ) { ret = - ERANGE ; <S2SV_StartBug> if ( res . acl_len > buflen ) <S2SV_EndBug> goto out_free ; <S2SV_StartBug> if ( localpage ) <S2SV_EndBug> <S2SV_StartBug> memcpy ( buf , resp_buf , res . acl_len ) ; <S2SV_EndBug> } ret = res . acl_len ; out_free : <S2SV_StartBug> if ( localpage ) <S2SV_EndBug> <S2SV_StartBug> __free_page ( localpage ) ; <S2SV_EndBug> return ret ; }","[ NFS4ACL_MAXPAGES ] = { NULL , } <S2SV_ModStart> , } ; int ret = - ENOMEM , npages , i , acl_len = 0 ; npages = ( buflen + PAGE_SIZE - 1 ) >> PAGE_SHIFT ; if ( npages == 0 ) npages = 1 ; for ( i = 0 ; i < npages ; i ++ ) { pages [ i ] = alloc_page ( GFP_KERNEL ) ; if ( ! pages [ i ] ) goto out_free ; } if ( npages > 1 ) { args . acl_scratch = alloc_page ( GFP_KERNEL ) ; if ( ! args . acl_scratch ) goto out_free ; } args . acl_len = npages * PAGE_SIZE ; args . acl_pgbase = 0 ; if ( buf <S2SV_ModEnd> == NULL ) <S2SV_ModStart> == NULL ) res . acl_flags |= NFS4_ACL_LEN_REQUEST ; resp_buf = page_address ( pages [ 0 ] ) ; dprintk ( ""%s<S2SV_blank><S2SV_blank>buf<S2SV_blank>%p<S2SV_blank>buflen<S2SV_blank>%ld<S2SV_blank>npages<S2SV_blank>%d<S2SV_blank>args.acl_len<S2SV_blank>%ld\\n"" , __func__ , buf , buflen , npages , args . acl_len ) ; <S2SV_ModEnd> ret = nfs4_call_sync <S2SV_ModStart> goto out_free ; acl_len = res . acl_len - res . acl_data_offset ; if ( <S2SV_ModEnd> acl_len > args <S2SV_ModStart> , NULL , <S2SV_ModEnd> acl_len ) ; <S2SV_ModStart> inode , resp_buf + res . acl_data_offset , <S2SV_ModEnd> acl_len ) ; <S2SV_ModStart> ; if ( <S2SV_ModEnd> acl_len > buflen <S2SV_ModStart> goto out_free ; _copy_from_pages <S2SV_ModEnd> ( buf , <S2SV_ModStart> ( buf , pages , res . acl_data_offset , res . acl_len ) ; } ret = <S2SV_ModEnd> acl_len ; out_free <S2SV_ModStart> ; out_free : for ( i = 0 ; i < npages ; i ++ ) if ( pages [ i ] <S2SV_ModEnd> ) __free_page ( <S2SV_ModStart> ) __free_page ( pages [ i ] ) ; if ( args . acl_scratch ) __free_page ( args . acl_scratch <S2SV_ModEnd> ) ; return"
469,"int nfc_llcp_send_cc ( struct nfc_llcp_sock * sock ) { struct nfc_llcp_local * local ; struct sk_buff * skb ; u8 * miux_tlv = NULL , miux_tlv_length ; u8 * rw_tlv = NULL , rw_tlv_length , rw ; int err ; u16 size = 0 ; __be16 miux ; pr_debug ( ""Sending<S2SV_blank>CC\\n"" ) ; local = sock -> local ; if ( local == NULL ) return - ENODEV ; miux = be16_to_cpu ( sock -> miux ) > LLCP_MAX_MIUX ? local -> miux : sock -> miux ; rw = sock -> rw > LLCP_MAX_RW ? local -> rw : sock -> rw ; miux_tlv = nfc_llcp_build_tlv ( LLCP_TLV_MIUX , ( u8 * ) & miux , 0 , & miux_tlv_length ) ; <S2SV_StartBug> size += miux_tlv_length ; <S2SV_EndBug> rw_tlv = nfc_llcp_build_tlv ( LLCP_TLV_RW , & rw , 0 , & rw_tlv_length ) ; <S2SV_StartBug> size += rw_tlv_length ; <S2SV_EndBug> skb = llcp_allocate_pdu ( sock , LLCP_PDU_CC , size ) ; if ( skb == NULL ) { err = - ENOMEM ; goto error_tlv ; } llcp_add_tlv ( skb , miux_tlv , miux_tlv_length ) ; llcp_add_tlv ( skb , rw_tlv , rw_tlv_length ) ; skb_queue_tail ( & local -> tx_queue , skb ) ; err = 0 ; error_tlv : if ( err ) pr_err ( ""error<S2SV_blank>%d\\n"" , err ) ; kfree ( miux_tlv ) ; kfree ( rw_tlv ) ; return err ; }",miux_tlv_length ) ; if ( ! miux_tlv ) { err = - ENOMEM ; goto error_tlv ; } <S2SV_ModStart> rw_tlv_length ) ; if ( ! rw_tlv ) { err = - ENOMEM ; goto error_tlv ; }
470,"gprinc_ret * get_principal_2_svc ( gprinc_arg * arg , struct svc_req * rqstp ) { static gprinc_ret ret ; char * prime_arg , * funcname ; <S2SV_StartBug> gss_buffer_desc client_name , <S2SV_EndBug> service_name ; OM_uint32 minor_stat ; kadm5_server_handle_t handle ; const char * errmsg = NULL ; xdr_free ( xdr_gprinc_ret , & ret ) ; if ( ( ret . code = new_server_handle ( arg -> api_version , rqstp , & handle ) ) ) goto exit_func ; if ( ( ret . code = check_handle ( ( void * ) handle ) ) ) goto exit_func ; ret . api_version = handle -> api_version ; funcname = ""kadm5_get_principal"" ; if ( setup_gss_names ( rqstp , & client_name , & service_name ) < 0 ) { ret . code = KADM5_FAILURE ; goto exit_func ; } if ( krb5_unparse_name ( handle -> context , arg -> princ , & prime_arg ) ) { ret . code = KADM5_BAD_PRINCIPAL ; goto exit_func ; } if ( ! cmp_gss_krb5_name ( handle , rqst2name ( rqstp ) , arg -> princ ) && ( CHANGEPW_SERVICE ( rqstp ) || ! kadm5int_acl_check ( handle -> context , rqst2name ( rqstp ) , ACL_INQUIRE , arg -> princ , NULL ) ) ) { ret . code = KADM5_AUTH_GET ; log_unauth ( funcname , prime_arg , & client_name , & service_name , rqstp ) ; } else { ret . code = kadm5_get_principal ( handle , arg -> princ , & ret . rec , arg -> mask ) ; if ( ret . code != 0 ) errmsg = krb5_get_error_message ( handle -> context , ret . code ) ; log_done ( funcname , prime_arg , errmsg , & client_name , & service_name , rqstp ) ; if ( errmsg != NULL ) krb5_free_error_message ( handle -> context , errmsg ) ; } free ( prime_arg ) ; <S2SV_StartBug> gss_release_buffer ( & minor_stat , & client_name ) ; <S2SV_EndBug> gss_release_buffer ( & minor_stat , & service_name ) ; <S2SV_StartBug> exit_func : <S2SV_EndBug> free_server_handle ( handle ) ; return & ret ; }",; gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <S2SV_ModEnd> ; OM_uint32 minor_stat <S2SV_ModStart> prime_arg ) ; exit_func : <S2SV_ModStart> service_name ) ; <S2SV_ModEnd> free_server_handle ( handle
471,"static int cleanup_pathname ( struct archive_write_disk * a ) { char * dest , * src ; char separator = '\\0' ; dest = src = a -> name ; if ( * src == '\\0' ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC , ""Invalid<S2SV_blank>empty<S2SV_blank>pathname"" ) ; return ( ARCHIVE_FAILED ) ; } # if defined ( __CYGWIN__ ) cleanup_pathname_win ( a ) ; # endif if ( * src == '/' ) <S2SV_StartBug> separator = * src ++ ; <S2SV_EndBug> for ( ; ; ) { if ( src [ 0 ] == '\\0' ) { break ; } else if ( src [ 0 ] == '/' ) { src ++ ; continue ; } else if ( src [ 0 ] == '.' ) { if ( src [ 1 ] == '\\0' ) { break ; } else if ( src [ 1 ] == '/' ) { src += 2 ; continue ; } else if ( src [ 1 ] == '.' ) { if ( src [ 2 ] == '/' || src [ 2 ] == '\\0' ) { if ( a -> flags & ARCHIVE_EXTRACT_SECURE_NODOTDOT ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC , ""Path<S2SV_blank>contains<S2SV_blank>\'..\'"" ) ; return ( ARCHIVE_FAILED ) ; } } } } if ( separator ) * dest ++ = '/' ; while ( * src != '\\0' && * src != '/' ) { * dest ++ = * src ++ ; } if ( * src == '\\0' ) break ; separator = * src ++ ; } if ( dest == a -> name ) { if ( separator ) * dest ++ = '/' ; else * dest ++ = '.' ; } * dest = '\\0' ; return ( ARCHIVE_OK ) ; }","== '/' ) { if ( a -> flags & ARCHIVE_EXTRACT_SECURE_NOABSOLUTEPATHS ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC , ""Path<S2SV_blank>is<S2SV_blank>absolute"" ) ; return ( ARCHIVE_FAILED ) ; } separator = * src ++ ; } <S2SV_ModEnd> for ( ;"
472,"static int handle_exception ( struct kvm_vcpu * vcpu ) { struct vcpu_vmx * vmx = to_vmx ( vcpu ) ; struct kvm_run * kvm_run = vcpu -> run ; u32 intr_info , ex_no , error_code ; unsigned long cr2 , rip , dr6 ; u32 vect_info ; enum emulation_result er ; vect_info = vmx -> idt_vectoring_info ; intr_info = vmx -> exit_intr_info ; if ( is_machine_check ( intr_info ) ) return handle_machine_check ( vcpu ) ; <S2SV_StartBug> if ( ( intr_info & INTR_INFO_INTR_TYPE_MASK ) == INTR_TYPE_NMI_INTR ) <S2SV_EndBug> return 1 ; if ( is_no_device ( intr_info ) ) { vmx_fpu_activate ( vcpu ) ; return 1 ; } if ( is_invalid_opcode ( intr_info ) ) { if ( is_guest_mode ( vcpu ) ) { kvm_queue_exception ( vcpu , UD_VECTOR ) ; return 1 ; } er = emulate_instruction ( vcpu , EMULTYPE_TRAP_UD ) ; if ( er != EMULATE_DONE ) kvm_queue_exception ( vcpu , UD_VECTOR ) ; return 1 ; } error_code = 0 ; if ( intr_info & INTR_INFO_DELIVER_CODE_MASK ) error_code = vmcs_read32 ( VM_EXIT_INTR_ERROR_CODE ) ; if ( ( vect_info & VECTORING_INFO_VALID_MASK ) && ! ( is_page_fault ( intr_info ) && ! ( error_code & PFERR_RSVD_MASK ) ) ) { vcpu -> run -> exit_reason = KVM_EXIT_INTERNAL_ERROR ; vcpu -> run -> internal . suberror = KVM_INTERNAL_ERROR_SIMUL_EX ; vcpu -> run -> internal . ndata = 3 ; vcpu -> run -> internal . data [ 0 ] = vect_info ; vcpu -> run -> internal . data [ 1 ] = intr_info ; vcpu -> run -> internal . data [ 2 ] = error_code ; return 0 ; } if ( is_page_fault ( intr_info ) ) { BUG_ON ( enable_ept ) ; cr2 = vmcs_readl ( EXIT_QUALIFICATION ) ; trace_kvm_page_fault ( cr2 , error_code ) ; if ( kvm_event_needs_reinjection ( vcpu ) ) kvm_mmu_unprotect_page_virt ( vcpu , cr2 ) ; return kvm_mmu_page_fault ( vcpu , cr2 , error_code , NULL , 0 ) ; } ex_no = intr_info & INTR_INFO_VECTOR_MASK ; if ( vmx -> rmode . vm86_active && rmode_exception ( vcpu , ex_no ) ) return handle_rmode_exception ( vcpu , ex_no , error_code ) ; switch ( ex_no ) { case AC_VECTOR : kvm_queue_exception_e ( vcpu , AC_VECTOR , error_code ) ; return 1 ; case DB_VECTOR : dr6 = vmcs_readl ( EXIT_QUALIFICATION ) ; if ( ! ( vcpu -> guest_debug & ( KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP ) ) ) { vcpu -> arch . dr6 &= ~ 15 ; vcpu -> arch . dr6 |= dr6 | DR6_RTM ; if ( ! ( dr6 & ~ DR6_RESERVED ) ) skip_emulated_instruction ( vcpu ) ; kvm_queue_exception ( vcpu , DB_VECTOR ) ; return 1 ; } kvm_run -> debug . arch . dr6 = dr6 | DR6_FIXED_1 ; kvm_run -> debug . arch . dr7 = vmcs_readl ( GUEST_DR7 ) ; case BP_VECTOR : vmx -> vcpu . arch . event_exit_inst_len = vmcs_read32 ( VM_EXIT_INSTRUCTION_LEN ) ; kvm_run -> exit_reason = KVM_EXIT_DEBUG ; rip = kvm_rip_read ( vcpu ) ; kvm_run -> debug . arch . pc = vmcs_readl ( GUEST_CS_BASE ) + rip ; kvm_run -> debug . arch . exception = ex_no ; break ; default : kvm_run -> exit_reason = KVM_EXIT_EXCEPTION ; kvm_run -> ex . exception = ex_no ; kvm_run -> ex . error_code = error_code ; break ; } return 0 ; }",; if ( is_nmi ( intr_info ) <S2SV_ModEnd> ) return 1
473,"void __sock_recv_timestamp ( struct msghdr * msg , struct sock * sk , struct sk_buff * skb ) { int need_software_tstamp = sock_flag ( sk , SOCK_RCVTSTAMP ) ; struct scm_timestamping tss ; int empty = 1 ; struct skb_shared_hwtstamps * shhwtstamps = skb_hwtstamps ( skb ) ; if ( need_software_tstamp && skb -> tstamp == 0 ) __net_timestamp ( skb ) ; if ( need_software_tstamp ) { if ( ! sock_flag ( sk , SOCK_RCVTSTAMPNS ) ) { struct timeval tv ; skb_get_timestamp ( skb , & tv ) ; put_cmsg ( msg , SOL_SOCKET , SCM_TIMESTAMP , sizeof ( tv ) , & tv ) ; } else { struct timespec ts ; skb_get_timestampns ( skb , & ts ) ; put_cmsg ( msg , SOL_SOCKET , SCM_TIMESTAMPNS , sizeof ( ts ) , & ts ) ; } } memset ( & tss , 0 , sizeof ( tss ) ) ; if ( ( sk -> sk_tsflags & SOF_TIMESTAMPING_SOFTWARE ) && ktime_to_timespec_cond ( skb -> tstamp , tss . ts + 0 ) ) empty = 0 ; if ( shhwtstamps && ( sk -> sk_tsflags & SOF_TIMESTAMPING_RAW_HARDWARE ) && ktime_to_timespec_cond ( shhwtstamps -> hwtstamp , tss . ts + 2 ) ) empty = 0 ; if ( ! empty ) { put_cmsg ( msg , SOL_SOCKET , SCM_TIMESTAMPING , sizeof ( tss ) , & tss ) ; <S2SV_StartBug> if ( skb -> len && ( sk -> sk_tsflags & SOF_TIMESTAMPING_OPT_STATS ) ) <S2SV_EndBug> put_cmsg ( msg , SOL_SOCKET , SCM_TIMESTAMPING_OPT_STATS , skb -> len , skb -> data ) ; } }",; if ( skb_is_err_queue ( skb ) &&
474,"static PyMemoTable * PyMemoTable_Copy ( PyMemoTable * self ) { <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> PyMemoTable * new = PyMemoTable_New ( ) ; if ( new == NULL ) return NULL ; new -> mt_used = self -> mt_used ; new -> mt_allocated = self -> mt_allocated ; new -> mt_mask = self -> mt_mask ; PyMem_FREE ( new -> mt_table ) ; new -> mt_table = PyMem_NEW ( PyMemoEntry , self -> mt_allocated ) ; if ( new -> mt_table == NULL ) { PyMem_FREE ( new ) ; PyErr_NoMemory ( ) ; return NULL ; } <S2SV_StartBug> for ( i = 0 ; i < self -> mt_allocated ; i ++ ) { <S2SV_EndBug> Py_XINCREF ( self -> mt_table [ i ] . me_key ) ; } memcpy ( new -> mt_table , self -> mt_table , sizeof ( PyMemoEntry ) * self -> mt_allocated ) ; return new ; }",self ) { <S2SV_ModEnd> PyMemoTable * new <S2SV_ModStart> } for ( size_t
475,"static int handle_emulation_failure ( struct kvm_vcpu * vcpu ) <S2SV_StartBug> { <S2SV_EndBug> ++ vcpu -> stat . insn_emulation_fail ; <S2SV_StartBug> trace_kvm_emulate_insn_failed ( vcpu ) ; <S2SV_EndBug> vcpu -> run -> exit_reason = KVM_EXIT_INTERNAL_ERROR ; vcpu -> run -> internal . suberror = KVM_INTERNAL_ERROR_EMULATION ; vcpu -> run -> internal . ndata = 0 ; <S2SV_StartBug> kvm_queue_exception ( vcpu , UD_VECTOR ) ; <S2SV_EndBug> <S2SV_StartBug> return EMULATE_FAIL ; <S2SV_EndBug> }",vcpu ) { int r = EMULATE_DONE ; <S2SV_ModStart> vcpu ) ; if ( ! is_guest_mode ( vcpu ) ) { <S2SV_ModStart> = 0 ; r = EMULATE_FAIL ; } <S2SV_ModStart> ) ; return r <S2SV_ModEnd> ; } <S2SV_null>
476,"struct sk_buff * skb_segment ( struct sk_buff * head_skb , netdev_features_t features ) { struct sk_buff * segs = NULL ; struct sk_buff * tail = NULL ; struct sk_buff * list_skb = skb_shinfo ( head_skb ) -> frag_list ; skb_frag_t * frag = skb_shinfo ( head_skb ) -> frags ; unsigned int mss = skb_shinfo ( head_skb ) -> gso_size ; <S2SV_StartBug> unsigned int doffset = head_skb -> data - skb_mac_header ( head_skb ) ; <S2SV_EndBug> unsigned int offset = doffset ; unsigned int tnl_hlen = skb_tnl_header_len ( head_skb ) ; unsigned int headroom ; unsigned int len ; __be16 proto ; bool csum ; int sg = ! ! ( features & NETIF_F_SG ) ; int nfrags = skb_shinfo ( head_skb ) -> nr_frags ; int err = - ENOMEM ; int i = 0 ; int pos ; proto = skb_network_protocol ( head_skb ) ; if ( unlikely ( ! proto ) ) return ERR_PTR ( - EINVAL ) ; csum = ! ! can_checksum_protocol ( features , proto ) ; __skb_push ( head_skb , doffset ) ; headroom = skb_headroom ( head_skb ) ; pos = skb_headlen ( head_skb ) ; do { struct sk_buff * nskb ; skb_frag_t * nskb_frag ; int hsize ; int size ; len = head_skb -> len - offset ; if ( len > mss ) len = mss ; hsize = skb_headlen ( head_skb ) - offset ; if ( hsize < 0 ) hsize = 0 ; if ( hsize > len || ! sg ) hsize = len ; if ( ! hsize && i >= nfrags && skb_headlen ( list_skb ) && ( skb_headlen ( list_skb ) == len || sg ) ) { BUG_ON ( skb_headlen ( list_skb ) > len ) ; i = 0 ; nfrags = skb_shinfo ( list_skb ) -> nr_frags ; frag = skb_shinfo ( list_skb ) -> frags ; <S2SV_StartBug> pos += skb_headlen ( list_skb ) ; <S2SV_EndBug> while ( pos < offset + len ) { BUG_ON ( i >= nfrags ) ; size = skb_frag_size ( frag ) ; if ( pos + size > offset + len ) break ; i ++ ; pos += size ; frag ++ ; } nskb = skb_clone ( list_skb , GFP_ATOMIC ) ; list_skb = list_skb -> next ; if ( unlikely ( ! nskb ) ) goto err ; if ( unlikely ( pskb_trim ( nskb , len ) ) ) { kfree_skb ( nskb ) ; goto err ; } hsize = skb_end_offset ( nskb ) ; if ( skb_cow_head ( nskb , doffset + headroom ) ) { kfree_skb ( nskb ) ; goto err ; } nskb -> truesize += skb_end_offset ( nskb ) - hsize ; skb_release_head_state ( nskb ) ; __skb_push ( nskb , doffset ) ; } else { nskb = __alloc_skb ( hsize + doffset + headroom , GFP_ATOMIC , skb_alloc_rx_flag ( head_skb ) , NUMA_NO_NODE ) ; if ( unlikely ( ! nskb ) ) goto err ; skb_reserve ( nskb , headroom ) ; __skb_put ( nskb , doffset ) ; } if ( segs ) tail -> next = nskb ; else segs = nskb ; tail = nskb ; __copy_skb_header ( nskb , head_skb ) ; nskb -> mac_len = head_skb -> mac_len ; skb_headers_offset_update ( nskb , skb_headroom ( nskb ) - headroom ) ; skb_copy_from_linear_data_offset ( head_skb , - tnl_hlen , nskb -> data - tnl_hlen , doffset + tnl_hlen ) ; if ( nskb -> len == len + doffset ) goto perform_csum_check ; if ( ! sg ) { nskb -> ip_summed = CHECKSUM_NONE ; nskb -> csum = skb_copy_and_csum_bits ( head_skb , offset , skb_put ( nskb , len ) , len , 0 ) ; continue ; } nskb_frag = skb_shinfo ( nskb ) -> frags ; skb_copy_from_linear_data_offset ( head_skb , offset , skb_put ( nskb , hsize ) , hsize ) ; skb_shinfo ( nskb ) -> tx_flags = skb_shinfo ( head_skb ) -> tx_flags & SKBTX_SHARED_FRAG ; while ( pos < offset + len ) { if ( i >= nfrags ) { BUG_ON ( skb_headlen ( list_skb ) ) ; i = 0 ; nfrags = skb_shinfo ( list_skb ) -> nr_frags ; frag = skb_shinfo ( list_skb ) -> frags ; <S2SV_StartBug> BUG_ON ( ! nfrags ) ; <S2SV_EndBug> list_skb = list_skb -> next ; } if ( unlikely ( skb_shinfo ( nskb ) -> nr_frags >= MAX_SKB_FRAGS ) ) { net_warn_ratelimited ( ""skb_segment:<S2SV_blank>too<S2SV_blank>many<S2SV_blank>frags:<S2SV_blank>%u<S2SV_blank>%u\\n"" , pos , mss ) ; goto err ; } <S2SV_StartBug> * nskb_frag = * frag ; <S2SV_EndBug> __skb_frag_ref ( nskb_frag ) ; size = skb_frag_size ( nskb_frag ) ; if ( pos < offset ) { nskb_frag -> page_offset += offset - pos ; skb_frag_size_sub ( nskb_frag , offset - pos ) ; } skb_shinfo ( nskb ) -> nr_frags ++ ; if ( pos + size <= offset + len ) { i ++ ; frag ++ ; pos += size ; } else { skb_frag_size_sub ( nskb_frag , pos + size - ( offset + len ) ) ; goto skip_fraglist ; } nskb_frag ++ ; } skip_fraglist : nskb -> data_len = len - hsize ; nskb -> len += nskb -> data_len ; nskb -> truesize += nskb -> data_len ; perform_csum_check : if ( ! csum ) { nskb -> csum = skb_checksum ( nskb , doffset , nskb -> len - doffset , 0 ) ; nskb -> ip_summed = CHECKSUM_NONE ; } } while ( ( offset += len ) < head_skb -> len ) ; return segs ; err : kfree_skb_list ( segs ) ; return ERR_PTR ( err ) ; }","( head_skb ) ; struct sk_buff * frag_skb = head_skb <S2SV_ModStart> -> frags ; frag_skb = list_skb ; <S2SV_ModStart> -> frags ; frag_skb = list_skb ; <S2SV_ModStart> err ; } if ( unlikely ( skb_orphan_frags ( frag_skb , GFP_ATOMIC ) ) ) goto err ;"
477,"static target_ulong disas_insn ( CPUX86State * env , DisasContext * s , target_ulong pc_start ) { int b , prefixes ; int shift ; TCGMemOp ot , aflag , dflag ; int modrm , reg , rm , mod , op , opreg , val ; target_ulong next_eip , tval ; int rex_w , rex_r ; s -> pc_start = s -> pc = pc_start ; prefixes = 0 ; s -> override = - 1 ; rex_w = - 1 ; rex_r = 0 ; # ifdef TARGET_X86_64 s -> rex_x = 0 ; s -> rex_b = 0 ; x86_64_hregs = 0 ; # endif s -> rip_offset = 0 ; s -> vex_l = 0 ; s -> vex_v = 0 ; <S2SV_StartBug> next_byte : <S2SV_EndBug> b = cpu_ldub_code ( env , s -> pc ) ; s -> pc ++ ; switch ( b ) { case 0xf3 : prefixes |= PREFIX_REPZ ; goto next_byte ; case 0xf2 : prefixes |= PREFIX_REPNZ ; goto next_byte ; case 0xf0 : prefixes |= PREFIX_LOCK ; goto next_byte ; case 0x2e : s -> override = R_CS ; goto next_byte ; case 0x36 : s -> override = R_SS ; goto next_byte ; case 0x3e : s -> override = R_DS ; goto next_byte ; case 0x26 : s -> override = R_ES ; goto next_byte ; case 0x64 : s -> override = R_FS ; goto next_byte ; case 0x65 : s -> override = R_GS ; goto next_byte ; case 0x66 : prefixes |= PREFIX_DATA ; goto next_byte ; case 0x67 : prefixes |= PREFIX_ADR ; goto next_byte ; # ifdef TARGET_X86_64 case 0x40 ... 0x4f : if ( CODE64 ( s ) ) { rex_w = ( b >> 3 ) & 1 ; rex_r = ( b & 0x4 ) << 1 ; s -> rex_x = ( b & 0x2 ) << 2 ; REX_B ( s ) = ( b & 0x1 ) << 3 ; x86_64_hregs = 1 ; goto next_byte ; } break ; # endif case 0xc5 : case 0xc4 : if ( s -> code32 && ! s -> vm86 ) { static const int pp_prefix [ 4 ] = { 0 , PREFIX_DATA , PREFIX_REPZ , PREFIX_REPNZ } ; int vex3 , vex2 = cpu_ldub_code ( env , s -> pc ) ; if ( ! CODE64 ( s ) && ( vex2 & 0xc0 ) != 0xc0 ) { break ; } s -> pc ++ ; if ( prefixes & ( PREFIX_REPZ | PREFIX_REPNZ | PREFIX_LOCK | PREFIX_DATA ) ) { goto illegal_op ; } # ifdef TARGET_X86_64 if ( x86_64_hregs ) { goto illegal_op ; } # endif rex_r = ( ~ vex2 >> 4 ) & 8 ; if ( b == 0xc5 ) { vex3 = vex2 ; b = cpu_ldub_code ( env , s -> pc ++ ) ; } else { # ifdef TARGET_X86_64 s -> rex_x = ( ~ vex2 >> 3 ) & 8 ; s -> rex_b = ( ~ vex2 >> 2 ) & 8 ; # endif vex3 = cpu_ldub_code ( env , s -> pc ++ ) ; rex_w = ( vex3 >> 7 ) & 1 ; switch ( vex2 & 0x1f ) { case 0x01 : b = cpu_ldub_code ( env , s -> pc ++ ) | 0x100 ; break ; case 0x02 : b = 0x138 ; break ; case 0x03 : b = 0x13a ; break ; default : goto unknown_op ; } } s -> vex_v = ( ~ vex3 >> 3 ) & 0xf ; s -> vex_l = ( vex3 >> 2 ) & 1 ; prefixes |= pp_prefix [ vex3 & 3 ] | PREFIX_VEX ; } break ; } if ( CODE64 ( s ) ) { dflag = ( rex_w > 0 ? MO_64 : prefixes & PREFIX_DATA ? MO_16 : MO_32 ) ; aflag = ( prefixes & PREFIX_ADR ? MO_32 : MO_64 ) ; } else { if ( s -> code32 ^ ( ( prefixes & PREFIX_DATA ) != 0 ) ) { dflag = MO_32 ; } else { dflag = MO_16 ; } if ( s -> code32 ^ ( ( prefixes & PREFIX_ADR ) != 0 ) ) { aflag = MO_32 ; } else { aflag = MO_16 ; } } s -> prefix = prefixes ; s -> aflag = aflag ; s -> dflag = dflag ; reswitch : switch ( b ) { case 0x0f : b = cpu_ldub_code ( env , s -> pc ++ ) | 0x100 ; goto reswitch ; case 0x00 ... 0x05 : case 0x08 ... 0x0d : case 0x10 ... 0x15 : case 0x18 ... 0x1d : case 0x20 ... 0x25 : case 0x28 ... 0x2d : case 0x30 ... 0x35 : case 0x38 ... 0x3d : { int op , f , val ; op = ( b >> 3 ) & 7 ; f = ( b >> 1 ) & 3 ; ot = mo_b_d ( b , dflag ) ; switch ( f ) { case 0 : modrm = cpu_ldub_code ( env , s -> pc ++ ) ; reg = ( ( modrm >> 3 ) & 7 ) | rex_r ; mod = ( modrm >> 6 ) & 3 ; rm = ( modrm & 7 ) | REX_B ( s ) ; if ( mod != 3 ) { gen_lea_modrm ( env , s , modrm ) ; opreg = OR_TMP0 ; } else if ( op == OP_XORL && rm == reg ) { xor_zero : set_cc_op ( s , CC_OP_CLR ) ; tcg_gen_movi_tl ( cpu_T0 , 0 ) ; gen_op_mov_reg_v ( ot , reg , cpu_T0 ) ; break ; } else { opreg = rm ; } gen_op_mov_v_reg ( ot , cpu_T1 , reg ) ; gen_op ( s , op , ot , opreg ) ; break ; case 1 : modrm = cpu_ldub_code ( env , s -> pc ++ ) ; mod = ( modrm >> 6 ) & 3 ; reg = ( ( modrm >> 3 ) & 7 ) | rex_r ; rm = ( modrm & 7 ) | REX_B ( s ) ; if ( mod != 3 ) { gen_lea_modrm ( env , s , modrm ) ; gen_op_ld_v ( s , ot , cpu_T1 , cpu_A0 ) ; } else if ( op == OP_XORL && rm == reg ) { goto xor_zero ; } else { gen_op_mov_v_reg ( ot , cpu_T1 , rm ) ; } gen_op ( s , op , ot , reg ) ; break ; case 2 : val = insn_get ( env , s , ot ) ; tcg_gen_movi_tl ( cpu_T1 , val ) ; gen_op ( s , op , ot , OR_EAX ) ; break ; } } break ; case 0x82 : if ( CODE64 ( s ) ) goto illegal_op ; case 0x80 : case 0x81 : case 0x83 : { int val ; ot = mo_b_d ( b , dflag ) ; modrm = cpu_ldub_code ( env , s -> pc ++ ) ; mod = ( modrm >> 6 ) & 3 ; rm = ( modrm & 7 ) | REX_B ( s ) ; op = ( modrm >> 3 ) & 7 ; if ( mod != 3 ) { if ( b == 0x83 ) s -> rip_offset = 1 ; else s -> rip_offset = insn_const_size ( ot ) ; gen_lea_modrm ( env , s , modrm ) ; opreg = OR_TMP0 ; } else { opreg = rm ; } switch ( b ) { default : case 0x80 : case 0x81 : case 0x82 : val = insn_get ( env , s , ot ) ; break ; case 0x83 : val = ( int8_t ) insn_get ( env , s , MO_8 ) ; break ; } tcg_gen_movi_tl ( cpu_T1 , val ) ; gen_op ( s , op , ot , opreg ) ; } break ; case 0x40 ... 0x47 : ot = dflag ; gen_inc ( s , ot , OR_EAX + ( b & 7 ) , 1 ) ; break ; case 0x48 ... 0x4f : ot = dflag ; gen_inc ( s , ot , OR_EAX + ( b & 7 ) , - 1 ) ; break ; case 0xf6 : case 0xf7 : ot = mo_b_d ( b , dflag ) ; modrm = cpu_ldub_code ( env , s -> pc ++ ) ; mod = ( modrm >> 6 ) & 3 ; rm = ( modrm & 7 ) | REX_B ( s ) ; op = ( modrm >> 3 ) & 7 ; if ( mod != 3 ) { if ( op == 0 ) { s -> rip_offset = insn_const_size ( ot ) ; } gen_lea_modrm ( env , s , modrm ) ; if ( ! ( s -> prefix & PREFIX_LOCK ) || op != 2 ) { gen_op_ld_v ( s , ot , cpu_T0 , cpu_A0 ) ; } } else { gen_op_mov_v_reg ( ot , cpu_T0 , rm ) ; } switch ( op ) { case 0 : val = insn_get ( env , s , ot ) ; tcg_gen_movi_tl ( cpu_T1 , val ) ; gen_op_testl_T0_T1_cc ( ) ; set_cc_op ( s , CC_OP_LOGICB + ot ) ; break ; case 2 : if ( s -> prefix & PREFIX_LOCK ) { if ( mod == 3 ) { goto illegal_op ; } tcg_gen_movi_tl ( cpu_T0 , ~ 0 ) ; tcg_gen_atomic_xor_fetch_tl ( cpu_T0 , cpu_A0 , cpu_T0 , s -> mem_index , ot | MO_LE ) ; } else { tcg_gen_not_tl ( cpu_T0 , cpu_T0 ) ; if ( mod != 3 ) { gen_op_st_v ( s , ot , cpu_T0 , cpu_A0 ) ; } else { gen_op_mov_reg_v ( ot , rm , cpu_T0 ) ; } } break ; case 3 : if ( s -> prefix & PREFIX_LOCK ) { TCGLabel * label1 ; TCGv a0 , t0 , t1 , t2 ; if ( mod == 3 ) { goto illegal_op ; } a0 = tcg_temp_local_new ( ) ; t0 = tcg_temp_local_new ( ) ; label1 = gen_new_label ( ) ; tcg_gen_mov_tl ( a0 , cpu_A0 ) ; tcg_gen_mov_tl ( t0 , cpu_T0 ) ; gen_set_label ( label1 ) ; t1 = tcg_temp_new ( ) ; t2 = tcg_temp_new ( ) ; tcg_gen_mov_tl ( t2 , t0 ) ; tcg_gen_neg_tl ( t1 , t0 ) ; tcg_gen_atomic_cmpxchg_tl ( t0 , a0 , t0 , t1 , s -> mem_index , ot | MO_LE ) ; tcg_temp_free ( t1 ) ; tcg_gen_brcond_tl ( TCG_COND_NE , t0 , t2 , label1 ) ; tcg_temp_free ( t2 ) ; tcg_temp_free ( a0 ) ; tcg_gen_mov_tl ( cpu_T0 , t0 ) ; tcg_temp_free ( t0 ) ; } else { tcg_gen_neg_tl ( cpu_T0 , cpu_T0 ) ; if ( mod != 3 ) { gen_op_st_v ( s , ot , cpu_T0 , cpu_A0 ) ; } else { gen_op_mov_reg_v ( ot , rm , cpu_T0 ) ; } } gen_op_update_neg_cc ( ) ; set_cc_op ( s , CC_OP_SUBB + ot ) ; break ; case 4 : switch ( ot ) { case MO_8 : gen_op_mov_v_reg ( MO_8 , cpu_T1 , R_EAX ) ; tcg_gen_ext8u_tl ( cpu_T0 , cpu_T0 ) ; tcg_gen_ext8u_tl ( cpu_T1 , cpu_T1 ) ; tcg_gen_mul_tl ( cpu_T0 , cpu_T0 , cpu_T1 ) ; gen_op_mov_reg_v ( MO_16 , R_EAX , cpu_T0 ) ; tcg_gen_mov_tl ( cpu_cc_dst , cpu_T0 ) ; tcg_gen_andi_tl ( cpu_cc_src , cpu_T0 , 0xff00 ) ; set_cc_op ( s , CC_OP_MULB ) ; break ; case MO_16 : gen_op_mov_v_reg ( MO_16 , cpu_T1 , R_EAX ) ; tcg_gen_ext16u_tl ( cpu_T0 , cpu_T0 ) ; tcg_gen_ext16u_tl ( cpu_T1 , cpu_T1 ) ; tcg_gen_mul_tl ( cpu_T0 , cpu_T0 , cpu_T1 ) ; gen_op_mov_reg_v ( MO_16 , R_EAX , cpu_T0 ) ; tcg_gen_mov_tl ( cpu_cc_dst , cpu_T0 ) ; tcg_gen_shri_tl ( cpu_T0 , cpu_T0 , 16 ) ; gen_op_mov_reg_v ( MO_16 , R_EDX , cpu_T0 ) ; tcg_gen_mov_tl ( cpu_cc_src , cpu_T0 ) ; set_cc_op ( s , CC_OP_MULW ) ; break ; default : case MO_32 : tcg_gen_trunc_tl_i32 ( cpu_tmp2_i32 , cpu_T0 ) ; tcg_gen_trunc_tl_i32 ( cpu_tmp3_i32 , cpu_regs [ R_EAX ] ) ; tcg_gen_mulu2_i32 ( cpu_tmp2_i32 , cpu_tmp3_i32 , cpu_tmp2_i32 , cpu_tmp3_i32 ) ; tcg_gen_extu_i32_tl ( cpu_regs [ R_EAX ] , cpu_tmp2_i32 ) ; tcg_gen_extu_i32_tl ( cpu_regs [ R_EDX ] , cpu_tmp3_i32 ) ; tcg_gen_mov_tl ( cpu_cc_dst , cpu_regs [ R_EAX ] ) ; tcg_gen_mov_tl ( cpu_cc_src , cpu_regs [ R_EDX ] ) ; set_cc_op ( s , CC_OP_MULL ) ; break ; # ifdef TARGET_X86_64 case MO_64 : tcg_gen_mulu2_i64 ( cpu_regs [ R_EAX ] , cpu_regs [ R_EDX ] , cpu_T0 , cpu_regs [ R_EAX ] ) ; tcg_gen_mov_tl ( cpu_cc_dst , cpu_regs [ R_EAX ] ) ; tcg_gen_mov_tl ( cpu_cc_src , cpu_regs [ R_EDX ] ) ; set_cc_op ( s , CC_OP_MULQ ) ; break ; # endif } break ; case 5 : switch ( ot ) { case MO_8 : gen_op_mov_v_reg ( MO_8 , cpu_T1 , R_EAX ) ; tcg_gen_ext8s_tl ( cpu_T0 , cpu_T0 ) ; tcg_gen_ext8s_tl ( cpu_T1 , cpu_T1 ) ; tcg_gen_mul_tl ( cpu_T0 , cpu_T0 , cpu_T1 ) ; gen_op_mov_reg_v ( MO_16 , R_EAX , cpu_T0 ) ; tcg_gen_mov_tl ( cpu_cc_dst , cpu_T0 ) ; tcg_gen_ext8s_tl ( cpu_tmp0 , cpu_T0 ) ; tcg_gen_sub_tl ( cpu_cc_src , cpu_T0 , cpu_tmp0 ) ; set_cc_op ( s , CC_OP_MULB ) ; break ; case MO_16 : gen_op_mov_v_reg ( MO_16 , cpu_T1 , R_EAX ) ; tcg_gen_ext16s_tl ( cpu_T0 , cpu_T0 ) ; tcg_gen_ext16s_tl ( cpu_T1 , cpu_T1 ) ; tcg_gen_mul_tl ( cpu_T0 , cpu_T0 , cpu_T1 ) ; gen_op_mov_reg_v ( MO_16 , R_EAX , cpu_T0 ) ; tcg_gen_mov_tl ( cpu_cc_dst , cpu_T0 ) ; tcg_gen_ext16s_tl ( cpu_tmp0 , cpu_T0 ) ; tcg_gen_sub_tl ( cpu_cc_src , cpu_T0 , cpu_tmp0 ) ; tcg_gen_shri_tl ( cpu_T0 , cpu_T0 , 16 ) ; gen_op_mov_reg_v ( MO_16 , R_EDX , cpu_T0 ) ; set_cc_op ( s , CC_OP_MULW ) ; break ; default : case MO_32 : tcg_gen_trunc_tl_i32 ( cpu_tmp2_i32 , cpu_T0 ) ; tcg_gen_trunc_tl_i32 ( cpu_tmp3_i32 , cpu_regs [ R_EAX ] ) ; tcg_gen_muls2_i32 ( cpu_tmp2_i32 , cpu_tmp3_i32 , cpu_tmp2_i32 , cpu_tmp3_i32 ) ; tcg_gen_extu_i32_tl ( cpu_regs [ R_EAX ] , cpu_tmp2_i32 ) ; tcg_gen_extu_i32_tl ( cpu_regs [ R_EDX ] , cpu_tmp3_i32 ) ; tcg_gen_sari_i32 ( cpu_tmp2_i32 , cpu_tmp2_i32 , 31 ) ; tcg_gen_mov_tl ( cpu_cc_dst , cpu_regs [ R_EAX ] ) ; tcg_gen_sub_i32 ( cpu_tmp2_i32 , cpu_tmp2_i32 , cpu_tmp3_i32 ) ; tcg_gen_extu_i32_tl ( cpu_cc_src , cpu_tmp2_i32 ) ; set_cc_op ( s , CC_OP_MULL ) ; break ; # ifdef TARGET_X86_64 case MO_64 : tcg_gen_muls2_i64 ( cpu_regs [ R_EAX ] , cpu_regs [ R_EDX ] , cpu_T0 , cpu_regs [ R_EAX ] ) ; tcg_gen_mov_tl ( cpu_cc_dst , cpu_regs [ R_EAX ] ) ; tcg_gen_sari_tl ( cpu_cc_src , cpu_regs [ R_EAX ] , 63 ) ; tcg_gen_sub_tl ( cpu_cc_src , cpu_cc_src , cpu_regs [ R_EDX ] ) ; set_cc_op ( s , CC_OP_MULQ ) ; break ; # endif } break ; case 6 : switch ( ot ) { case MO_8 : gen_helper_divb_AL ( cpu_env , cpu_T0 ) ; break ; case MO_16 : gen_helper_divw_AX ( cpu_env , cpu_T0 ) ; break ; default : case MO_32 : gen_helper_divl_EAX ( cpu_env , cpu_T0 ) ; break ; # ifdef TARGET_X86_64 case MO_64 : gen_helper_divq_EAX ( cpu_env , cpu_T0 ) ; break ; # endif } break ; case 7 : switch ( ot ) { case MO_8 : gen_helper_idivb_AL ( cpu_env , cpu_T0 ) ; break ; case MO_16 : gen_helper_idivw_AX ( cpu_env , cpu_T0 ) ; break ; default : case MO_32 : gen_helper_idivl_EAX ( cpu_env , cpu_T0 ) ; break ; # ifdef TARGET_X86_64 case MO_64 : gen_helper_idivq_EAX ( cpu_env , cpu_T0 ) ; break ; # endif } break ; default : goto unknown_op ; } break ; case 0xfe : case 0xff : ot = mo_b_d ( b , dflag ) ; modrm = cpu_ldub_code ( env , s -> pc ++ ) ; mod = ( modrm >> 6 ) & 3 ; rm = ( modrm & 7 ) | REX_B ( s ) ; op = ( modrm >> 3 ) & 7 ; if ( op >= 2 && b == 0xfe ) { goto unknown_op ; } if ( CODE64 ( s ) ) { if ( op == 2 || op == 4 ) { ot = MO_64 ; } else if ( op == 3 || op == 5 ) { ot = dflag != MO_16 ? MO_32 + ( rex_w == 1 ) : MO_16 ; } else if ( op == 6 ) { ot = mo_pushpop ( s , dflag ) ; } } if ( mod != 3 ) { gen_lea_modrm ( env , s , modrm ) ; if ( op >= 2 && op != 3 && op != 5 ) gen_op_ld_v ( s , ot , cpu_T0 , cpu_A0 ) ; } else { gen_op_mov_v_reg ( ot , cpu_T0 , rm ) ; } switch ( op ) { case 0 : if ( mod != 3 ) opreg = OR_TMP0 ; else opreg = rm ; gen_inc ( s , ot , opreg , 1 ) ; break ; case 1 : if ( mod != 3 ) opreg = OR_TMP0 ; else opreg = rm ; gen_inc ( s , ot , opreg , - 1 ) ; break ; case 2 : if ( dflag == MO_16 ) { tcg_gen_ext16u_tl ( cpu_T0 , cpu_T0 ) ; } next_eip = s -> pc - s -> cs_base ; tcg_gen_movi_tl ( cpu_T1 , next_eip ) ; gen_push_v ( s , cpu_T1 ) ; gen_op_jmp_v ( cpu_T0 ) ; gen_bnd_jmp ( s ) ; gen_eob ( s ) ; break ; case 3 : gen_op_ld_v ( s , ot , cpu_T1 , cpu_A0 ) ; gen_add_A0_im ( s , 1 << ot ) ; gen_op_ld_v ( s , MO_16 , cpu_T0 , cpu_A0 ) ; do_lcall : if ( s -> pe && ! s -> vm86 ) { tcg_gen_trunc_tl_i32 ( cpu_tmp2_i32 , cpu_T0 ) ; gen_helper_lcall_protected ( cpu_env , cpu_tmp2_i32 , cpu_T1 , tcg_const_i32 ( dflag - 1 ) , tcg_const_tl ( s -> pc - s -> cs_base ) ) ; } else { tcg_gen_trunc_tl_i32 ( cpu_tmp2_i32 , cpu_T0 ) ; gen_helper_lcall_real ( cpu_env , cpu_tmp2_i32 , cpu_T1 , tcg_const_i32 ( dflag - 1 ) , tcg_const_i32 ( s -> pc - s -> cs_base ) ) ; } gen_eob ( s ) ; break ; case 4 : if ( dflag == MO_16 ) { tcg_gen_ext16u_tl ( cpu_T0 , cpu_T0 ) ; } gen_op_jmp_v ( cpu_T0 ) ; gen_bnd_jmp ( s ) ; gen_eob ( s ) ; break ; case 5 : gen_op_ld_v ( s , ot , cpu_T1 , cpu_A0 ) ; gen_add_A0_im ( s , 1 << ot ) ; gen_op_ld_v ( s , MO_16 , cpu_T0 , cpu_A0 ) ; do_ljmp : if ( s -> pe && ! s -> vm86 ) { tcg_gen_trunc_tl_i32 ( cpu_tmp2_i32 , cpu_T0 ) ; gen_helper_ljmp_protected ( cpu_env , cpu_tmp2_i32 , cpu_T1 , tcg_const_tl ( s -> pc - s -> cs_base ) ) ; } else { gen_op_movl_seg_T0_vm ( R_CS ) ; gen_op_jmp_v ( cpu_T1 ) ; } gen_eob ( s ) ; break ; case 6 : gen_push_v ( s , cpu_T0 ) ; break ; default : goto unknown_op ; } break ; case 0x84 : case 0x85 : ot = mo_b_d ( b , dflag ) ; modrm = cpu_ldub_code ( env , s -> pc ++ ) ; reg = ( ( modrm >> 3 ) & 7 ) | rex_r ; gen_ldst_modrm ( env , s , modrm , ot , OR_TMP0 , 0 ) ; gen_op_mov_v_reg ( ot , cpu_T1 , reg ) ; gen_op_testl_T0_T1_cc ( ) ; set_cc_op ( s , CC_OP_LOGICB + ot ) ; break ; case 0xa8 : case 0xa9 : ot = mo_b_d ( b , dflag ) ; val = insn_get ( env , s , ot ) ; gen_op_mov_v_reg ( ot , cpu_T0 , OR_EAX ) ; tcg_gen_movi_tl ( cpu_T1 , val ) ; gen_op_testl_T0_T1_cc ( ) ; set_cc_op ( s , CC_OP_LOGICB + ot ) ; break ; case 0x98 : switch ( dflag ) { # ifdef TARGET_X86_64 case MO_64 : gen_op_mov_v_reg ( MO_32 , cpu_T0 , R_EAX ) ; tcg_gen_ext32s_tl ( cpu_T0 , cpu_T0 ) ; gen_op_mov_reg_v ( MO_64 , R_EAX , cpu_T0 ) ; break ; # endif case MO_32 : gen_op_mov_v_reg ( MO_16 , cpu_T0 , R_EAX ) ; tcg_gen_ext16s_tl ( cpu_T0 , cpu_T0 ) ; gen_op_mov_reg_v ( MO_32 , R_EAX , cpu_T0 ) ; break ; case MO_16 : gen_op_mov_v_reg ( MO_8 , cpu_T0 , R_EAX ) ; tcg_gen_ext8s_tl ( cpu_T0 , cpu_T0 ) ; gen_op_mov_reg_v ( MO_16 , R_EAX , cpu_T0 ) ; break ; default : tcg_abort ( ) ; } break ; case 0x99 : switch ( dflag ) { # ifdef TARGET_X86_64 case MO_64 : gen_op_mov_v_reg ( MO_64 , cpu_T0 , R_EAX ) ; tcg_gen_sari_tl ( cpu_T0 , cpu_T0 , 63 ) ; gen_op_mov_reg_v ( MO_64 , R_EDX , cpu_T0 ) ; break ; # endif case MO_32 : gen_op_mov_v_reg ( MO_32 , cpu_T0 , R_EAX ) ; tcg_gen_ext32s_tl ( cpu_T0 , cpu_T0 ) ; tcg_gen_sari_tl ( cpu_T0 , cpu_T0 , 31 ) ; gen_op_mov_reg_v ( MO_32 , R_EDX , cpu_T0 ) ; break ; case MO_16 : gen_op_mov_v_reg ( MO_16 , cpu_T0 , R_EAX ) ; tcg_gen_ext16s_tl ( cpu_T0 , cpu_T0 ) ; tcg_gen_sari_tl ( cpu_T0 , cpu_T0 , 15 ) ; gen_op_mov_reg_v ( MO_16 , R_EDX , cpu_T0 ) ; break ; default : tcg_abort ( ) ; } break ; case 0x1af : case 0x69 : case 0x6b : ot = dflag ; modrm = cpu_ldub_code ( env , s -> pc ++ ) ; reg = ( ( modrm >> 3 ) & 7 ) | rex_r ; if ( b == 0x69 ) s -> rip_offset = insn_const_size ( ot ) ; else if ( b == 0x6b ) s -> rip_offset = 1 ; gen_ldst_modrm ( env , s , modrm , ot , OR_TMP0 , 0 ) ; if ( b == 0x69 ) { val = insn_get ( env , s , ot ) ; tcg_gen_movi_tl ( cpu_T1 , val ) ; } else if ( b == 0x6b ) { val = ( int8_t ) insn_get ( env , s , MO_8 ) ; tcg_gen_movi_tl ( cpu_T1 , val ) ; } else { gen_op_mov_v_reg ( ot , cpu_T1 , reg ) ; } switch ( ot ) { # ifdef TARGET_X86_64 case MO_64 : tcg_gen_muls2_i64 ( cpu_regs [ reg ] , cpu_T1 , cpu_T0 , cpu_T1 ) ; tcg_gen_mov_tl ( cpu_cc_dst , cpu_regs [ reg ] ) ; tcg_gen_sari_tl ( cpu_cc_src , cpu_cc_dst , 63 ) ; tcg_gen_sub_tl ( cpu_cc_src , cpu_cc_src , cpu_T1 ) ; break ; # endif case MO_32 : tcg_gen_trunc_tl_i32 ( cpu_tmp2_i32 , cpu_T0 ) ; tcg_gen_trunc_tl_i32 ( cpu_tmp3_i32 , cpu_T1 ) ; tcg_gen_muls2_i32 ( cpu_tmp2_i32 , cpu_tmp3_i32 , cpu_tmp2_i32 , cpu_tmp3_i32 ) ; tcg_gen_extu_i32_tl ( cpu_regs [ reg ] , cpu_tmp2_i32 ) ; tcg_gen_sari_i32 ( cpu_tmp2_i32 , cpu_tmp2_i32 , 31 ) ; tcg_gen_mov_tl ( cpu_cc_dst , cpu_regs [ reg ] ) ; tcg_gen_sub_i32 ( cpu_tmp2_i32 , cpu_tmp2_i32 , cpu_tmp3_i32 ) ; tcg_gen_extu_i32_tl ( cpu_cc_src , cpu_tmp2_i32 ) ; break ; default : tcg_gen_ext16s_tl ( cpu_T0 , cpu_T0 ) ; tcg_gen_ext16s_tl ( cpu_T1 , cpu_T1 ) ; tcg_gen_mul_tl ( cpu_T0 , cpu_T0 , cpu_T1 ) ; tcg_gen_mov_tl ( cpu_cc_dst , cpu_T0 ) ; tcg_gen_ext16s_tl ( cpu_tmp0 , cpu_T0 ) ; tcg_gen_sub_tl ( cpu_cc_src , cpu_T0 , cpu_tmp0 ) ; gen_op_mov_reg_v ( ot , reg , cpu_T0 ) ; break ; } set_cc_op ( s , CC_OP_MULB + ot ) ; break ; case 0x1c0 : case 0x1c1 : ot = mo_b_d ( b , dflag ) ; modrm = cpu_ldub_code ( env , s -> pc ++ ) ; reg = ( ( modrm >> 3 ) & 7 ) | rex_r ; mod = ( modrm >> 6 ) & 3 ; gen_op_mov_v_reg ( ot , cpu_T0 , reg ) ; if ( mod == 3 ) { rm = ( modrm & 7 ) | REX_B ( s ) ; gen_op_mov_v_reg ( ot , cpu_T1 , rm ) ; tcg_gen_add_tl ( cpu_T0 , cpu_T0 , cpu_T1 ) ; gen_op_mov_reg_v ( ot , reg , cpu_T1 ) ; gen_op_mov_reg_v ( ot , rm , cpu_T0 ) ; } else { gen_lea_modrm ( env , s , modrm ) ; if ( s -> prefix & PREFIX_LOCK ) { tcg_gen_atomic_fetch_add_tl ( cpu_T1 , cpu_A0 , cpu_T0 , s -> mem_index , ot | MO_LE ) ; tcg_gen_add_tl ( cpu_T0 , cpu_T0 , cpu_T1 ) ; } else { gen_op_ld_v ( s , ot , cpu_T1 , cpu_A0 ) ; tcg_gen_add_tl ( cpu_T0 , cpu_T0 , cpu_T1 ) ; gen_op_st_v ( s , ot , cpu_T0 , cpu_A0 ) ; } gen_op_mov_reg_v ( ot , reg , cpu_T1 ) ; } gen_op_update2_cc ( ) ; set_cc_op ( s , CC_OP_ADDB + ot ) ; break ; case 0x1b0 : case 0x1b1 : { TCGv oldv , newv , cmpv ; ot = mo_b_d ( b , dflag ) ; modrm = cpu_ldub_code ( env , s -> pc ++ ) ; reg = ( ( modrm >> 3 ) & 7 ) | rex_r ; mod = ( modrm >> 6 ) & 3 ; oldv = tcg_temp_new ( ) ; newv = tcg_temp_new ( ) ; cmpv = tcg_temp_new ( ) ; gen_op_mov_v_reg ( ot , newv , reg ) ; tcg_gen_mov_tl ( cmpv , cpu_regs [ R_EAX ] ) ; if ( s -> prefix & PREFIX_LOCK ) { if ( mod == 3 ) { goto illegal_op ; } gen_lea_modrm ( env , s , modrm ) ; tcg_gen_atomic_cmpxchg_tl ( oldv , cpu_A0 , cmpv , newv , s -> mem_index , ot | MO_LE ) ; gen_op_mov_reg_v ( ot , R_EAX , oldv ) ; } else { if ( mod == 3 ) { rm = ( modrm & 7 ) | REX_B ( s ) ; gen_op_mov_v_reg ( ot , oldv , rm ) ; } else { gen_lea_modrm ( env , s , modrm ) ; gen_op_ld_v ( s , ot , oldv , cpu_A0 ) ; rm = 0 ; } gen_extu ( ot , oldv ) ; gen_extu ( ot , cmpv ) ; tcg_gen_movcond_tl ( TCG_COND_EQ , newv , oldv , cmpv , newv , oldv ) ; if ( mod == 3 ) { gen_op_mov_reg_v ( ot , R_EAX , oldv ) ; gen_op_mov_reg_v ( ot , rm , newv ) ; } else { gen_op_st_v ( s , ot , newv , cpu_A0 ) ; gen_op_mov_reg_v ( ot , R_EAX , oldv ) ; } } tcg_gen_mov_tl ( cpu_cc_src , oldv ) ; tcg_gen_mov_tl ( cpu_cc_srcT , cmpv ) ; tcg_gen_sub_tl ( cpu_cc_dst , cmpv , oldv ) ; set_cc_op ( s , CC_OP_SUBB + ot ) ; tcg_temp_free ( oldv ) ; tcg_temp_free ( newv ) ; tcg_temp_free ( cmpv ) ; } break ; case 0x1c7 : modrm = cpu_ldub_code ( env , s -> pc ++ ) ; mod = ( modrm >> 6 ) & 3 ; if ( ( mod == 3 ) || ( ( modrm & 0x38 ) != 0x8 ) ) goto illegal_op ; # ifdef TARGET_X86_64 if ( dflag == MO_64 ) { if ( ! ( s -> cpuid_ext_features & CPUID_EXT_CX16 ) ) goto illegal_op ; gen_lea_modrm ( env , s , modrm ) ; if ( ( s -> prefix & PREFIX_LOCK ) && parallel_cpus ) { gen_helper_cmpxchg16b ( cpu_env , cpu_A0 ) ; } else { gen_helper_cmpxchg16b_unlocked ( cpu_env , cpu_A0 ) ; } } else # endif { if ( ! ( s -> cpuid_features & CPUID_CX8 ) ) goto illegal_op ; gen_lea_modrm ( env , s , modrm ) ; if ( ( s -> prefix & PREFIX_LOCK ) && parallel_cpus ) { gen_helper_cmpxchg8b ( cpu_env , cpu_A0 ) ; } else { gen_helper_cmpxchg8b_unlocked ( cpu_env , cpu_A0 ) ; } } set_cc_op ( s , CC_OP_EFLAGS ) ; break ; case 0x50 ... 0x57 : gen_op_mov_v_reg ( MO_32 , cpu_T0 , ( b & 7 ) | REX_B ( s ) ) ; gen_push_v ( s , cpu_T0 ) ; break ; case 0x58 ... 0x5f : ot = gen_pop_T0 ( s ) ; gen_pop_update ( s , ot ) ; gen_op_mov_reg_v ( ot , ( b & 7 ) | REX_B ( s ) , cpu_T0 ) ; break ; case 0x60 : if ( CODE64 ( s ) ) goto illegal_op ; gen_pusha ( s ) ; break ; case 0x61 : if ( CODE64 ( s ) ) goto illegal_op ; gen_popa ( s ) ; break ; case 0x68 : case 0x6a : ot = mo_pushpop ( s , dflag ) ; if ( b == 0x68 ) val = insn_get ( env , s , ot ) ; else val = ( int8_t ) insn_get ( env , s , MO_8 ) ; tcg_gen_movi_tl ( cpu_T0 , val ) ; gen_push_v ( s , cpu_T0 ) ; break ; case 0x8f : modrm = cpu_ldub_code ( env , s -> pc ++ ) ; mod = ( modrm >> 6 ) & 3 ; ot = gen_pop_T0 ( s ) ; if ( mod == 3 ) { gen_pop_update ( s , ot ) ; rm = ( modrm & 7 ) | REX_B ( s ) ; gen_op_mov_reg_v ( ot , rm , cpu_T0 ) ; } else { s -> popl_esp_hack = 1 << ot ; gen_ldst_modrm ( env , s , modrm , ot , OR_TMP0 , 1 ) ; s -> popl_esp_hack = 0 ; gen_pop_update ( s , ot ) ; } break ; case 0xc8 : { int level ; val = cpu_lduw_code ( env , s -> pc ) ; s -> pc += 2 ; level = cpu_ldub_code ( env , s -> pc ++ ) ; gen_enter ( s , val , level ) ; } break ; case 0xc9 : gen_leave ( s ) ; break ; case 0x06 : case 0x0e : case 0x16 : case 0x1e : if ( CODE64 ( s ) ) goto illegal_op ; gen_op_movl_T0_seg ( b >> 3 ) ; gen_push_v ( s , cpu_T0 ) ; break ; case 0x1a0 : case 0x1a8 : gen_op_movl_T0_seg ( ( b >> 3 ) & 7 ) ; gen_push_v ( s , cpu_T0 ) ; break ; case 0x07 : case 0x17 : case 0x1f : if ( CODE64 ( s ) ) goto illegal_op ; reg = b >> 3 ; ot = gen_pop_T0 ( s ) ; gen_movl_seg_T0 ( s , reg ) ; gen_pop_update ( s , ot ) ; if ( s -> is_jmp ) { gen_jmp_im ( s -> pc - s -> cs_base ) ; if ( reg == R_SS ) { s -> tf = 0 ; gen_eob_inhibit_irq ( s , true ) ; } else { gen_eob ( s ) ; } } break ; case 0x1a1 : case 0x1a9 : ot = gen_pop_T0 ( s ) ; gen_movl_seg_T0 ( s , ( b >> 3 ) & 7 ) ; gen_pop_update ( s , ot ) ; if ( s -> is_jmp ) { gen_jmp_im ( s -> pc - s -> cs_base ) ; gen_eob ( s ) ; } break ; case 0x88 : case 0x89 : ot = mo_b_d ( b , dflag ) ; modrm = cpu_ldub_code ( env , s -> pc ++ ) ; reg = ( ( modrm >> 3 ) & 7 ) | rex_r ; gen_ldst_modrm ( env , s , modrm , ot , reg , 1 ) ; break ; case 0xc6 : case 0xc7 : ot = mo_b_d ( b , dflag ) ; modrm = cpu_ldub_code ( env , s -> pc ++ ) ; mod = ( modrm >> 6 ) & 3 ; if ( mod != 3 ) { s -> rip_offset = insn_const_size ( ot ) ; gen_lea_modrm ( env , s , modrm ) ; } val = insn_get ( env , s , ot ) ; tcg_gen_movi_tl ( cpu_T0 , val ) ; if ( mod != 3 ) { gen_op_st_v ( s , ot , cpu_T0 , cpu_A0 ) ; } else { gen_op_mov_reg_v ( ot , ( modrm & 7 ) | REX_B ( s ) , cpu_T0 ) ; } break ; case 0x8a : case 0x8b : ot = mo_b_d ( b , dflag ) ; modrm = cpu_ldub_code ( env , s -> pc ++ ) ; reg = ( ( modrm >> 3 ) & 7 ) | rex_r ; gen_ldst_modrm ( env , s , modrm , ot , OR_TMP0 , 0 ) ; gen_op_mov_reg_v ( ot , reg , cpu_T0 ) ; break ; case 0x8e : modrm = cpu_ldub_code ( env , s -> pc ++ ) ; reg = ( modrm >> 3 ) & 7 ; if ( reg >= 6 || reg == R_CS ) goto illegal_op ; gen_ldst_modrm ( env , s , modrm , MO_16 , OR_TMP0 , 0 ) ; gen_movl_seg_T0 ( s , reg ) ; if ( s -> is_jmp ) { gen_jmp_im ( s -> pc - s -> cs_base ) ; if ( reg == R_SS ) { s -> tf = 0 ; gen_eob_inhibit_irq ( s , true ) ; } else { gen_eob ( s ) ; } } break ; case 0x8c : modrm = cpu_ldub_code ( env , s -> pc ++ ) ; reg = ( modrm >> 3 ) & 7 ; mod = ( modrm >> 6 ) & 3 ; if ( reg >= 6 ) goto illegal_op ; gen_op_movl_T0_seg ( reg ) ; ot = mod == 3 ? dflag : MO_16 ; gen_ldst_modrm ( env , s , modrm , ot , OR_TMP0 , 1 ) ; break ; case 0x1b6 : case 0x1b7 : case 0x1be : case 0x1bf : { TCGMemOp d_ot ; TCGMemOp s_ot ; d_ot = dflag ; ot = ( b & 1 ) + MO_8 ; s_ot = b & 8 ? MO_SIGN | ot : ot ; modrm = cpu_ldub_code ( env , s -> pc ++ ) ; reg = ( ( modrm >> 3 ) & 7 ) | rex_r ; mod = ( modrm >> 6 ) & 3 ; rm = ( modrm & 7 ) | REX_B ( s ) ; if ( mod == 3 ) { if ( s_ot == MO_SB && byte_reg_is_xH ( rm ) ) { tcg_gen_sextract_tl ( cpu_T0 , cpu_regs [ rm - 4 ] , 8 , 8 ) ; } else { gen_op_mov_v_reg ( ot , cpu_T0 , rm ) ; switch ( s_ot ) { case MO_UB : tcg_gen_ext8u_tl ( cpu_T0 , cpu_T0 ) ; break ; case MO_SB : tcg_gen_ext8s_tl ( cpu_T0 , cpu_T0 ) ; break ; case MO_UW : tcg_gen_ext16u_tl ( cpu_T0 , cpu_T0 ) ; break ; default : case MO_SW : tcg_gen_ext16s_tl ( cpu_T0 , cpu_T0 ) ; break ; } } gen_op_mov_reg_v ( d_ot , reg , cpu_T0 ) ; } else { gen_lea_modrm ( env , s , modrm ) ; gen_op_ld_v ( s , s_ot , cpu_T0 , cpu_A0 ) ; gen_op_mov_reg_v ( d_ot , reg , cpu_T0 ) ; } } break ; case 0x8d : modrm = cpu_ldub_code ( env , s -> pc ++ ) ; mod = ( modrm >> 6 ) & 3 ; if ( mod == 3 ) goto illegal_op ; reg = ( ( modrm >> 3 ) & 7 ) | rex_r ; { AddressParts a = gen_lea_modrm_0 ( env , s , modrm ) ; TCGv ea = gen_lea_modrm_1 ( a ) ; gen_lea_v_seg ( s , s -> aflag , ea , - 1 , - 1 ) ; gen_op_mov_reg_v ( dflag , reg , cpu_A0 ) ; } break ; case 0xa0 : case 0xa1 : case 0xa2 : case 0xa3 : { target_ulong offset_addr ; ot = mo_b_d ( b , dflag ) ; switch ( s -> aflag ) { # ifdef TARGET_X86_64 case MO_64 : offset_addr = cpu_ldq_code ( env , s -> pc ) ; s -> pc += 8 ; break ; # endif default : offset_addr = insn_get ( env , s , s -> aflag ) ; break ; } tcg_gen_movi_tl ( cpu_A0 , offset_addr ) ; gen_add_A0_ds_seg ( s ) ; if ( ( b & 2 ) == 0 ) { gen_op_ld_v ( s , ot , cpu_T0 , cpu_A0 ) ; gen_op_mov_reg_v ( ot , R_EAX , cpu_T0 ) ; } else { gen_op_mov_v_reg ( ot , cpu_T0 , R_EAX ) ; gen_op_st_v ( s , ot , cpu_T0 , cpu_A0 ) ; } } break ; case 0xd7 : tcg_gen_mov_tl ( cpu_A0 , cpu_regs [ R_EBX ] ) ; tcg_gen_ext8u_tl ( cpu_T0 , cpu_regs [ R_EAX ] ) ; tcg_gen_add_tl ( cpu_A0 , cpu_A0 , cpu_T0 ) ; gen_extu ( s -> aflag , cpu_A0 ) ; gen_add_A0_ds_seg ( s ) ; gen_op_ld_v ( s , MO_8 , cpu_T0 , cpu_A0 ) ; gen_op_mov_reg_v ( MO_8 , R_EAX , cpu_T0 ) ; break ; case 0xb0 ... 0xb7 : val = insn_get ( env , s , MO_8 ) ; tcg_gen_movi_tl ( cpu_T0 , val ) ; gen_op_mov_reg_v ( MO_8 , ( b & 7 ) | REX_B ( s ) , cpu_T0 ) ; break ; case 0xb8 ... 0xbf : # ifdef TARGET_X86_64 if ( dflag == MO_64 ) { uint64_t tmp ; tmp = cpu_ldq_code ( env , s -> pc ) ; s -> pc += 8 ; reg = ( b & 7 ) | REX_B ( s ) ; tcg_gen_movi_tl ( cpu_T0 , tmp ) ; gen_op_mov_reg_v ( MO_64 , reg , cpu_T0 ) ; } else # endif { ot = dflag ; val = insn_get ( env , s , ot ) ; reg = ( b & 7 ) | REX_B ( s ) ; tcg_gen_movi_tl ( cpu_T0 , val ) ; gen_op_mov_reg_v ( ot , reg , cpu_T0 ) ; } break ; case 0x91 ... 0x97 : do_xchg_reg_eax : ot = dflag ; reg = ( b & 7 ) | REX_B ( s ) ; rm = R_EAX ; goto do_xchg_reg ; case 0x86 : case 0x87 : ot = mo_b_d ( b , dflag ) ; modrm = cpu_ldub_code ( env , s -> pc ++ ) ; reg = ( ( modrm >> 3 ) & 7 ) | rex_r ; mod = ( modrm >> 6 ) & 3 ; if ( mod == 3 ) { rm = ( modrm & 7 ) | REX_B ( s ) ; do_xchg_reg : gen_op_mov_v_reg ( ot , cpu_T0 , reg ) ; gen_op_mov_v_reg ( ot , cpu_T1 , rm ) ; gen_op_mov_reg_v ( ot , rm , cpu_T0 ) ; gen_op_mov_reg_v ( ot , reg , cpu_T1 ) ; } else { gen_lea_modrm ( env , s , modrm ) ; gen_op_mov_v_reg ( ot , cpu_T0 , reg ) ; tcg_gen_atomic_xchg_tl ( cpu_T1 , cpu_A0 , cpu_T0 , s -> mem_index , ot | MO_LE ) ; gen_op_mov_reg_v ( ot , reg , cpu_T1 ) ; } break ; case 0xc4 : op = R_ES ; goto do_lxx ; case 0xc5 : op = R_DS ; goto do_lxx ; case 0x1b2 : op = R_SS ; goto do_lxx ; case 0x1b4 : op = R_FS ; goto do_lxx ; case 0x1b5 : op = R_GS ; do_lxx : ot = dflag != MO_16 ? MO_32 : MO_16 ; modrm = cpu_ldub_code ( env , s -> pc ++ ) ; reg = ( ( modrm >> 3 ) & 7 ) | rex_r ; mod = ( modrm >> 6 ) & 3 ; if ( mod == 3 ) goto illegal_op ; gen_lea_modrm ( env , s , modrm ) ; gen_op_ld_v ( s , ot , cpu_T1 , cpu_A0 ) ; gen_add_A0_im ( s , 1 << ot ) ; gen_op_ld_v ( s , MO_16 , cpu_T0 , cpu_A0 ) ; gen_movl_seg_T0 ( s , op ) ; gen_op_mov_reg_v ( ot , reg , cpu_T1 ) ; if ( s -> is_jmp ) { gen_jmp_im ( s -> pc - s -> cs_base ) ; gen_eob ( s ) ; } break ; case 0xc0 : case 0xc1 : shift = 2 ; grp2 : { ot = mo_b_d ( b , dflag ) ; modrm = cpu_ldub_code ( env , s -> pc ++ ) ; mod = ( modrm >> 6 ) & 3 ; op = ( modrm >> 3 ) & 7 ; if ( mod != 3 ) { if ( shift == 2 ) { s -> rip_offset = 1 ; } gen_lea_modrm ( env , s , modrm ) ; opreg = OR_TMP0 ; } else { opreg = ( modrm & 7 ) | REX_B ( s ) ; } if ( shift == 0 ) { gen_shift ( s , op , ot , opreg , OR_ECX ) ; } else { if ( shift == 2 ) { shift = cpu_ldub_code ( env , s -> pc ++ ) ; } gen_shifti ( s , op , ot , opreg , shift ) ; } } break ; case 0xd0 : case 0xd1 : shift = 1 ; goto grp2 ; case 0xd2 : case 0xd3 : shift = 0 ; goto grp2 ; case 0x1a4 : op = 0 ; shift = 1 ; goto do_shiftd ; case 0x1a5 : op = 0 ; shift = 0 ; goto do_shiftd ; case 0x1ac : op = 1 ; shift = 1 ; goto do_shiftd ; case 0x1ad : op = 1 ; shift = 0 ; do_shiftd : ot = dflag ; modrm = cpu_ldub_code ( env , s -> pc ++ ) ; mod = ( modrm >> 6 ) & 3 ; rm = ( modrm & 7 ) | REX_B ( s ) ; reg = ( ( modrm >> 3 ) & 7 ) | rex_r ; if ( mod != 3 ) { gen_lea_modrm ( env , s , modrm ) ; opreg = OR_TMP0 ; } else { opreg = rm ; } gen_op_mov_v_reg ( ot , cpu_T1 , reg ) ; if ( shift ) { TCGv imm = tcg_const_tl ( cpu_ldub_code ( env , s -> pc ++ ) ) ; gen_shiftd_rm_T1 ( s , ot , opreg , op , imm ) ; tcg_temp_free ( imm ) ; } else { gen_shiftd_rm_T1 ( s , ot , opreg , op , cpu_regs [ R_ECX ] ) ; } break ; case 0xd8 ... 0xdf : if ( s -> flags & ( HF_EM_MASK | HF_TS_MASK ) ) { gen_exception ( s , EXCP07_PREX , pc_start - s -> cs_base ) ; break ; } modrm = cpu_ldub_code ( env , s -> pc ++ ) ; mod = ( modrm >> 6 ) & 3 ; rm = modrm & 7 ; op = ( ( b & 7 ) << 3 ) | ( ( modrm >> 3 ) & 7 ) ; if ( mod != 3 ) { gen_lea_modrm ( env , s , modrm ) ; switch ( op ) { case 0x00 ... 0x07 : case 0x10 ... 0x17 : case 0x20 ... 0x27 : case 0x30 ... 0x37 : { int op1 ; op1 = op & 7 ; switch ( op >> 4 ) { case 0 : tcg_gen_qemu_ld_i32 ( cpu_tmp2_i32 , cpu_A0 , s -> mem_index , MO_LEUL ) ; gen_helper_flds_FT0 ( cpu_env , cpu_tmp2_i32 ) ; break ; case 1 : tcg_gen_qemu_ld_i32 ( cpu_tmp2_i32 , cpu_A0 , s -> mem_index , MO_LEUL ) ; gen_helper_fildl_FT0 ( cpu_env , cpu_tmp2_i32 ) ; break ; case 2 : tcg_gen_qemu_ld_i64 ( cpu_tmp1_i64 , cpu_A0 , s -> mem_index , MO_LEQ ) ; gen_helper_fldl_FT0 ( cpu_env , cpu_tmp1_i64 ) ; break ; case 3 : default : tcg_gen_qemu_ld_i32 ( cpu_tmp2_i32 , cpu_A0 , s -> mem_index , MO_LESW ) ; gen_helper_fildl_FT0 ( cpu_env , cpu_tmp2_i32 ) ; break ; } gen_helper_fp_arith_ST0_FT0 ( op1 ) ; if ( op1 == 3 ) { gen_helper_fpop ( cpu_env ) ; } } break ; case 0x08 : case 0x0a : case 0x0b : case 0x18 ... 0x1b : case 0x28 ... 0x2b : case 0x38 ... 0x3b : switch ( op & 7 ) { case 0 : switch ( op >> 4 ) { case 0 : tcg_gen_qemu_ld_i32 ( cpu_tmp2_i32 , cpu_A0 , s -> mem_index , MO_LEUL ) ; gen_helper_flds_ST0 ( cpu_env , cpu_tmp2_i32 ) ; break ; case 1 : tcg_gen_qemu_ld_i32 ( cpu_tmp2_i32 , cpu_A0 , s -> mem_index , MO_LEUL ) ; gen_helper_fildl_ST0 ( cpu_env , cpu_tmp2_i32 ) ; break ; case 2 : tcg_gen_qemu_ld_i64 ( cpu_tmp1_i64 , cpu_A0 , s -> mem_index , MO_LEQ ) ; gen_helper_fldl_ST0 ( cpu_env , cpu_tmp1_i64 ) ; break ; case 3 : default : tcg_gen_qemu_ld_i32 ( cpu_tmp2_i32 , cpu_A0 , s -> mem_index , MO_LESW ) ; gen_helper_fildl_ST0 ( cpu_env , cpu_tmp2_i32 ) ; break ; } break ; case 1 : switch ( op >> 4 ) { case 1 : gen_helper_fisttl_ST0 ( cpu_tmp2_i32 , cpu_env ) ; tcg_gen_qemu_st_i32 ( cpu_tmp2_i32 , cpu_A0 , s -> mem_index , MO_LEUL ) ; break ; case 2 : gen_helper_fisttll_ST0 ( cpu_tmp1_i64 , cpu_env ) ; tcg_gen_qemu_st_i64 ( cpu_tmp1_i64 , cpu_A0 , s -> mem_index , MO_LEQ ) ; break ; case 3 : default : gen_helper_fistt_ST0 ( cpu_tmp2_i32 , cpu_env ) ; tcg_gen_qemu_st_i32 ( cpu_tmp2_i32 , cpu_A0 , s -> mem_index , MO_LEUW ) ; break ; } gen_helper_fpop ( cpu_env ) ; break ; default : switch ( op >> 4 ) { case 0 : gen_helper_fsts_ST0 ( cpu_tmp2_i32 , cpu_env ) ; tcg_gen_qemu_st_i32 ( cpu_tmp2_i32 , cpu_A0 , s -> mem_index , MO_LEUL ) ; break ; case 1 : gen_helper_fistl_ST0 ( cpu_tmp2_i32 , cpu_env ) ; tcg_gen_qemu_st_i32 ( cpu_tmp2_i32 , cpu_A0 , s -> mem_index , MO_LEUL ) ; break ; case 2 : gen_helper_fstl_ST0 ( cpu_tmp1_i64 , cpu_env ) ; tcg_gen_qemu_st_i64 ( cpu_tmp1_i64 , cpu_A0 , s -> mem_index , MO_LEQ ) ; break ; case 3 : default : gen_helper_fist_ST0 ( cpu_tmp2_i32 , cpu_env ) ; tcg_gen_qemu_st_i32 ( cpu_tmp2_i32 , cpu_A0 , s -> mem_index , MO_LEUW ) ; break ; } if ( ( op & 7 ) == 3 ) gen_helper_fpop ( cpu_env ) ; break ; } break ; case 0x0c : gen_helper_fldenv ( cpu_env , cpu_A0 , tcg_const_i32 ( dflag - 1 ) ) ; break ; case 0x0d : tcg_gen_qemu_ld_i32 ( cpu_tmp2_i32 , cpu_A0 , s -> mem_index , MO_LEUW ) ; gen_helper_fldcw ( cpu_env , cpu_tmp2_i32 ) ; break ; case 0x0e : gen_helper_fstenv ( cpu_env , cpu_A0 , tcg_const_i32 ( dflag - 1 ) ) ; break ; case 0x0f : gen_helper_fnstcw ( cpu_tmp2_i32 , cpu_env ) ; tcg_gen_qemu_st_i32 ( cpu_tmp2_i32 , cpu_A0 , s -> mem_index , MO_LEUW ) ; break ; case 0x1d : gen_helper_fldt_ST0 ( cpu_env , cpu_A0 ) ; break ; case 0x1f : gen_helper_fstt_ST0 ( cpu_env , cpu_A0 ) ; gen_helper_fpop ( cpu_env ) ; break ; case 0x2c : gen_helper_frstor ( cpu_env , cpu_A0 , tcg_const_i32 ( dflag - 1 ) ) ; break ; case 0x2e : gen_helper_fsave ( cpu_env , cpu_A0 , tcg_const_i32 ( dflag - 1 ) ) ; break ; case 0x2f : gen_helper_fnstsw ( cpu_tmp2_i32 , cpu_env ) ; tcg_gen_qemu_st_i32 ( cpu_tmp2_i32 , cpu_A0 , s -> mem_index , MO_LEUW ) ; break ; case 0x3c : gen_helper_fbld_ST0 ( cpu_env , cpu_A0 ) ; break ; case 0x3e : gen_helper_fbst_ST0 ( cpu_env , cpu_A0 ) ; gen_helper_fpop ( cpu_env ) ; break ; case 0x3d : tcg_gen_qemu_ld_i64 ( cpu_tmp1_i64 , cpu_A0 , s -> mem_index , MO_LEQ ) ; gen_helper_fildll_ST0 ( cpu_env , cpu_tmp1_i64 ) ; break ; case 0x3f : gen_helper_fistll_ST0 ( cpu_tmp1_i64 , cpu_env ) ; tcg_gen_qemu_st_i64 ( cpu_tmp1_i64 , cpu_A0 , s -> mem_index , MO_LEQ ) ; gen_helper_fpop ( cpu_env ) ; break ; default : goto unknown_op ; } } else { opreg = rm ; switch ( op ) { case 0x08 : gen_helper_fpush ( cpu_env ) ; gen_helper_fmov_ST0_STN ( cpu_env , tcg_const_i32 ( ( opreg + 1 ) & 7 ) ) ; break ; case 0x09 : case 0x29 : case 0x39 : gen_helper_fxchg_ST0_STN ( cpu_env , tcg_const_i32 ( opreg ) ) ; break ; case 0x0a : switch ( rm ) { case 0 : gen_helper_fwait ( cpu_env ) ; break ; default : goto unknown_op ; } break ; case 0x0c : switch ( rm ) { case 0 : gen_helper_fchs_ST0 ( cpu_env ) ; break ; case 1 : gen_helper_fabs_ST0 ( cpu_env ) ; break ; case 4 : gen_helper_fldz_FT0 ( cpu_env ) ; gen_helper_fcom_ST0_FT0 ( cpu_env ) ; break ; case 5 : gen_helper_fxam_ST0 ( cpu_env ) ; break ; default : goto unknown_op ; } break ; case 0x0d : { switch ( rm ) { case 0 : gen_helper_fpush ( cpu_env ) ; gen_helper_fld1_ST0 ( cpu_env ) ; break ; case 1 : gen_helper_fpush ( cpu_env ) ; gen_helper_fldl2t_ST0 ( cpu_env ) ; break ; case 2 : gen_helper_fpush ( cpu_env ) ; gen_helper_fldl2e_ST0 ( cpu_env ) ; break ; case 3 : gen_helper_fpush ( cpu_env ) ; gen_helper_fldpi_ST0 ( cpu_env ) ; break ; case 4 : gen_helper_fpush ( cpu_env ) ; gen_helper_fldlg2_ST0 ( cpu_env ) ; break ; case 5 : gen_helper_fpush ( cpu_env ) ; gen_helper_fldln2_ST0 ( cpu_env ) ; break ; case 6 : gen_helper_fpush ( cpu_env ) ; gen_helper_fldz_ST0 ( cpu_env ) ; break ; default : goto unknown_op ; } } break ; case 0x0e : switch ( rm ) { case 0 : gen_helper_f2xm1 ( cpu_env ) ; break ; case 1 : gen_helper_fyl2x ( cpu_env ) ; break ; case 2 : gen_helper_fptan ( cpu_env ) ; break ; case 3 : gen_helper_fpatan ( cpu_env ) ; break ; case 4 : gen_helper_fxtract ( cpu_env ) ; break ; case 5 : gen_helper_fprem1 ( cpu_env ) ; break ; case 6 : gen_helper_fdecstp ( cpu_env ) ; break ; default : case 7 : gen_helper_fincstp ( cpu_env ) ; break ; } break ; case 0x0f : switch ( rm ) { case 0 : gen_helper_fprem ( cpu_env ) ; break ; case 1 : gen_helper_fyl2xp1 ( cpu_env ) ; break ; case 2 : gen_helper_fsqrt ( cpu_env ) ; break ; case 3 : gen_helper_fsincos ( cpu_env ) ; break ; case 5 : gen_helper_fscale ( cpu_env ) ; break ; case 4 : gen_helper_frndint ( cpu_env ) ; break ; case 6 : gen_helper_fsin ( cpu_env ) ; break ; default : case 7 : gen_helper_fcos ( cpu_env ) ; break ; } break ; case 0x00 : case 0x01 : case 0x04 ... 0x07 : case 0x20 : case 0x21 : case 0x24 ... 0x27 : case 0x30 : case 0x31 : case 0x34 ... 0x37 : { int op1 ; op1 = op & 7 ; if ( op >= 0x20 ) { gen_helper_fp_arith_STN_ST0 ( op1 , opreg ) ; if ( op >= 0x30 ) gen_helper_fpop ( cpu_env ) ; } else { gen_helper_fmov_FT0_STN ( cpu_env , tcg_const_i32 ( opreg ) ) ; gen_helper_fp_arith_ST0_FT0 ( op1 ) ; } } break ; case 0x02 : case 0x22 : gen_helper_fmov_FT0_STN ( cpu_env , tcg_const_i32 ( opreg ) ) ; gen_helper_fcom_ST0_FT0 ( cpu_env ) ; break ; case 0x03 : case 0x23 : case 0x32 : gen_helper_fmov_FT0_STN ( cpu_env , tcg_const_i32 ( opreg ) ) ; gen_helper_fcom_ST0_FT0 ( cpu_env ) ; gen_helper_fpop ( cpu_env ) ; break ; case 0x15 : switch ( rm ) { case 1 : gen_helper_fmov_FT0_STN ( cpu_env , tcg_const_i32 ( 1 ) ) ; gen_helper_fucom_ST0_FT0 ( cpu_env ) ; gen_helper_fpop ( cpu_env ) ; gen_helper_fpop ( cpu_env ) ; break ; default : goto unknown_op ; } break ; case 0x1c : switch ( rm ) { case 0 : break ; case 1 : break ; case 2 : gen_helper_fclex ( cpu_env ) ; break ; case 3 : gen_helper_fninit ( cpu_env ) ; break ; case 4 : break ; default : goto unknown_op ; } break ; case 0x1d : if ( ! ( s -> cpuid_features & CPUID_CMOV ) ) { goto illegal_op ; } gen_update_cc_op ( s ) ; gen_helper_fmov_FT0_STN ( cpu_env , tcg_const_i32 ( opreg ) ) ; gen_helper_fucomi_ST0_FT0 ( cpu_env ) ; set_cc_op ( s , CC_OP_EFLAGS ) ; break ; case 0x1e : if ( ! ( s -> cpuid_features & CPUID_CMOV ) ) { goto illegal_op ; } gen_update_cc_op ( s ) ; gen_helper_fmov_FT0_STN ( cpu_env , tcg_const_i32 ( opreg ) ) ; gen_helper_fcomi_ST0_FT0 ( cpu_env ) ; set_cc_op ( s , CC_OP_EFLAGS ) ; break ; case 0x28 : gen_helper_ffree_STN ( cpu_env , tcg_const_i32 ( opreg ) ) ; break ; case 0x2a : gen_helper_fmov_STN_ST0 ( cpu_env , tcg_const_i32 ( opreg ) ) ; break ; case 0x2b : case 0x0b : case 0x3a : case 0x3b : gen_helper_fmov_STN_ST0 ( cpu_env , tcg_const_i32 ( opreg ) ) ; gen_helper_fpop ( cpu_env ) ; break ; case 0x2c : gen_helper_fmov_FT0_STN ( cpu_env , tcg_const_i32 ( opreg ) ) ; gen_helper_fucom_ST0_FT0 ( cpu_env ) ; break ; case 0x2d : gen_helper_fmov_FT0_STN ( cpu_env , tcg_const_i32 ( opreg ) ) ; gen_helper_fucom_ST0_FT0 ( cpu_env ) ; gen_helper_fpop ( cpu_env ) ; break ; case 0x33 : switch ( rm ) { case 1 : gen_helper_fmov_FT0_STN ( cpu_env , tcg_const_i32 ( 1 ) ) ; gen_helper_fcom_ST0_FT0 ( cpu_env ) ; gen_helper_fpop ( cpu_env ) ; gen_helper_fpop ( cpu_env ) ; break ; default : goto unknown_op ; } break ; case 0x38 : gen_helper_ffree_STN ( cpu_env , tcg_const_i32 ( opreg ) ) ; gen_helper_fpop ( cpu_env ) ; break ; case 0x3c : switch ( rm ) { case 0 : gen_helper_fnstsw ( cpu_tmp2_i32 , cpu_env ) ; tcg_gen_extu_i32_tl ( cpu_T0 , cpu_tmp2_i32 ) ; gen_op_mov_reg_v ( MO_16 , R_EAX , cpu_T0 ) ; break ; default : goto unknown_op ; } break ; case 0x3d : if ( ! ( s -> cpuid_features & CPUID_CMOV ) ) { goto illegal_op ; } gen_update_cc_op ( s ) ; gen_helper_fmov_FT0_STN ( cpu_env , tcg_const_i32 ( opreg ) ) ; gen_helper_fucomi_ST0_FT0 ( cpu_env ) ; gen_helper_fpop ( cpu_env ) ; set_cc_op ( s , CC_OP_EFLAGS ) ; break ; case 0x3e : if ( ! ( s -> cpuid_features & CPUID_CMOV ) ) { goto illegal_op ; } gen_update_cc_op ( s ) ; gen_helper_fmov_FT0_STN ( cpu_env , tcg_const_i32 ( opreg ) ) ; gen_helper_fcomi_ST0_FT0 ( cpu_env ) ; gen_helper_fpop ( cpu_env ) ; set_cc_op ( s , CC_OP_EFLAGS ) ; break ; case 0x10 ... 0x13 : case 0x18 ... 0x1b : { int op1 ; TCGLabel * l1 ; static const uint8_t fcmov_cc [ 8 ] = { ( JCC_B << 1 ) , ( JCC_Z << 1 ) , ( JCC_BE << 1 ) , ( JCC_P << 1 ) , } ; if ( ! ( s -> cpuid_features & CPUID_CMOV ) ) { goto illegal_op ; } op1 = fcmov_cc [ op & 3 ] | ( ( ( op >> 3 ) & 1 ) ^ 1 ) ; l1 = gen_new_label ( ) ; gen_jcc1_noeob ( s , op1 , l1 ) ; gen_helper_fmov_ST0_STN ( cpu_env , tcg_const_i32 ( opreg ) ) ; gen_set_label ( l1 ) ; } break ; default : goto unknown_op ; } } break ; case 0xa4 : case 0xa5 : ot = mo_b_d ( b , dflag ) ; if ( prefixes & ( PREFIX_REPZ | PREFIX_REPNZ ) ) { gen_repz_movs ( s , ot , pc_start - s -> cs_base , s -> pc - s -> cs_base ) ; } else { gen_movs ( s , ot ) ; } break ; case 0xaa : case 0xab : ot = mo_b_d ( b , dflag ) ; if ( prefixes & ( PREFIX_REPZ | PREFIX_REPNZ ) ) { gen_repz_stos ( s , ot , pc_start - s -> cs_base , s -> pc - s -> cs_base ) ; } else { gen_stos ( s , ot ) ; } break ; case 0xac : case 0xad : ot = mo_b_d ( b , dflag ) ; if ( prefixes & ( PREFIX_REPZ | PREFIX_REPNZ ) ) { gen_repz_lods ( s , ot , pc_start - s -> cs_base , s -> pc - s -> cs_base ) ; } else { gen_lods ( s , ot ) ; } break ; case 0xae : case 0xaf : ot = mo_b_d ( b , dflag ) ; if ( prefixes & PREFIX_REPNZ ) { gen_repz_scas ( s , ot , pc_start - s -> cs_base , s -> pc - s -> cs_base , 1 ) ; } else if ( prefixes & PREFIX_REPZ ) { gen_repz_scas ( s , ot , pc_start - s -> cs_base , s -> pc - s -> cs_base , 0 ) ; } else { gen_scas ( s , ot ) ; } break ; case 0xa6 : case 0xa7 : ot = mo_b_d ( b , dflag ) ; if ( prefixes & PREFIX_REPNZ ) { gen_repz_cmps ( s , ot , pc_start - s -> cs_base , s -> pc - s -> cs_base , 1 ) ; } else if ( prefixes & PREFIX_REPZ ) { gen_repz_cmps ( s , ot , pc_start - s -> cs_base , s -> pc - s -> cs_base , 0 ) ; } else { gen_cmps ( s , ot ) ; } break ; case 0x6c : case 0x6d : ot = mo_b_d32 ( b , dflag ) ; tcg_gen_ext16u_tl ( cpu_T0 , cpu_regs [ R_EDX ] ) ; gen_check_io ( s , ot , pc_start - s -> cs_base , SVM_IOIO_TYPE_MASK | svm_is_rep ( prefixes ) | 4 ) ; if ( prefixes & ( PREFIX_REPZ | PREFIX_REPNZ ) ) { gen_repz_ins ( s , ot , pc_start - s -> cs_base , s -> pc - s -> cs_base ) ; } else { gen_ins ( s , ot ) ; if ( s -> tb -> cflags & CF_USE_ICOUNT ) { gen_jmp ( s , s -> pc - s -> cs_base ) ; } } break ; case 0x6e : case 0x6f : ot = mo_b_d32 ( b , dflag ) ; tcg_gen_ext16u_tl ( cpu_T0 , cpu_regs [ R_EDX ] ) ; gen_check_io ( s , ot , pc_start - s -> cs_base , svm_is_rep ( prefixes ) | 4 ) ; if ( prefixes & ( PREFIX_REPZ | PREFIX_REPNZ ) ) { gen_repz_outs ( s , ot , pc_start - s -> cs_base , s -> pc - s -> cs_base ) ; } else { gen_outs ( s , ot ) ; if ( s -> tb -> cflags & CF_USE_ICOUNT ) { gen_jmp ( s , s -> pc - s -> cs_base ) ; } } break ; case 0xe4 : case 0xe5 : ot = mo_b_d32 ( b , dflag ) ; val = cpu_ldub_code ( env , s -> pc ++ ) ; tcg_gen_movi_tl ( cpu_T0 , val ) ; gen_check_io ( s , ot , pc_start - s -> cs_base , SVM_IOIO_TYPE_MASK | svm_is_rep ( prefixes ) ) ; if ( s -> tb -> cflags & CF_USE_ICOUNT ) { gen_io_start ( ) ; } tcg_gen_movi_i32 ( cpu_tmp2_i32 , val ) ; gen_helper_in_func ( ot , cpu_T1 , cpu_tmp2_i32 ) ; gen_op_mov_reg_v ( ot , R_EAX , cpu_T1 ) ; gen_bpt_io ( s , cpu_tmp2_i32 , ot ) ; if ( s -> tb -> cflags & CF_USE_ICOUNT ) { gen_io_end ( ) ; gen_jmp ( s , s -> pc - s -> cs_base ) ; } break ; case 0xe6 : case 0xe7 : ot = mo_b_d32 ( b , dflag ) ; val = cpu_ldub_code ( env , s -> pc ++ ) ; tcg_gen_movi_tl ( cpu_T0 , val ) ; gen_check_io ( s , ot , pc_start - s -> cs_base , svm_is_rep ( prefixes ) ) ; gen_op_mov_v_reg ( ot , cpu_T1 , R_EAX ) ; if ( s -> tb -> cflags & CF_USE_ICOUNT ) { gen_io_start ( ) ; } tcg_gen_movi_i32 ( cpu_tmp2_i32 , val ) ; tcg_gen_trunc_tl_i32 ( cpu_tmp3_i32 , cpu_T1 ) ; gen_helper_out_func ( ot , cpu_tmp2_i32 , cpu_tmp3_i32 ) ; gen_bpt_io ( s , cpu_tmp2_i32 , ot ) ; if ( s -> tb -> cflags & CF_USE_ICOUNT ) { gen_io_end ( ) ; gen_jmp ( s , s -> pc - s -> cs_base ) ; } break ; case 0xec : case 0xed : ot = mo_b_d32 ( b , dflag ) ; tcg_gen_ext16u_tl ( cpu_T0 , cpu_regs [ R_EDX ] ) ; gen_check_io ( s , ot , pc_start - s -> cs_base , SVM_IOIO_TYPE_MASK | svm_is_rep ( prefixes ) ) ; if ( s -> tb -> cflags & CF_USE_ICOUNT ) { gen_io_start ( ) ; } tcg_gen_trunc_tl_i32 ( cpu_tmp2_i32 , cpu_T0 ) ; gen_helper_in_func ( ot , cpu_T1 , cpu_tmp2_i32 ) ; gen_op_mov_reg_v ( ot , R_EAX , cpu_T1 ) ; gen_bpt_io ( s , cpu_tmp2_i32 , ot ) ; if ( s -> tb -> cflags & CF_USE_ICOUNT ) { gen_io_end ( ) ; gen_jmp ( s , s -> pc - s -> cs_base ) ; } break ; case 0xee : case 0xef : ot = mo_b_d32 ( b , dflag ) ; tcg_gen_ext16u_tl ( cpu_T0 , cpu_regs [ R_EDX ] ) ; gen_check_io ( s , ot , pc_start - s -> cs_base , svm_is_rep ( prefixes ) ) ; gen_op_mov_v_reg ( ot , cpu_T1 , R_EAX ) ; if ( s -> tb -> cflags & CF_USE_ICOUNT ) { gen_io_start ( ) ; } tcg_gen_trunc_tl_i32 ( cpu_tmp2_i32 , cpu_T0 ) ; tcg_gen_trunc_tl_i32 ( cpu_tmp3_i32 , cpu_T1 ) ; gen_helper_out_func ( ot , cpu_tmp2_i32 , cpu_tmp3_i32 ) ; gen_bpt_io ( s , cpu_tmp2_i32 , ot ) ; if ( s -> tb -> cflags & CF_USE_ICOUNT ) { gen_io_end ( ) ; gen_jmp ( s , s -> pc - s -> cs_base ) ; } break ; case 0xc2 : val = cpu_ldsw_code ( env , s -> pc ) ; s -> pc += 2 ; ot = gen_pop_T0 ( s ) ; gen_stack_update ( s , val + ( 1 << ot ) ) ; gen_op_jmp_v ( cpu_T0 ) ; gen_bnd_jmp ( s ) ; gen_eob ( s ) ; break ; case 0xc3 : ot = gen_pop_T0 ( s ) ; gen_pop_update ( s , ot ) ; gen_op_jmp_v ( cpu_T0 ) ; gen_bnd_jmp ( s ) ; gen_eob ( s ) ; break ; case 0xca : val = cpu_ldsw_code ( env , s -> pc ) ; s -> pc += 2 ; do_lret : if ( s -> pe && ! s -> vm86 ) { gen_update_cc_op ( s ) ; gen_jmp_im ( pc_start - s -> cs_base ) ; gen_helper_lret_protected ( cpu_env , tcg_const_i32 ( dflag - 1 ) , tcg_const_i32 ( val ) ) ; } else { gen_stack_A0 ( s ) ; gen_op_ld_v ( s , dflag , cpu_T0 , cpu_A0 ) ; gen_op_jmp_v ( cpu_T0 ) ; gen_add_A0_im ( s , 1 << dflag ) ; gen_op_ld_v ( s , dflag , cpu_T0 , cpu_A0 ) ; gen_op_movl_seg_T0_vm ( R_CS ) ; gen_stack_update ( s , val + ( 2 << dflag ) ) ; } gen_eob ( s ) ; break ; case 0xcb : val = 0 ; goto do_lret ; case 0xcf : gen_svm_check_intercept ( s , pc_start , SVM_EXIT_IRET ) ; if ( ! s -> pe ) { gen_helper_iret_real ( cpu_env , tcg_const_i32 ( dflag - 1 ) ) ; set_cc_op ( s , CC_OP_EFLAGS ) ; } else if ( s -> vm86 ) { if ( s -> iopl != 3 ) { gen_exception ( s , EXCP0D_GPF , pc_start - s -> cs_base ) ; } else { gen_helper_iret_real ( cpu_env , tcg_const_i32 ( dflag - 1 ) ) ; set_cc_op ( s , CC_OP_EFLAGS ) ; } } else { gen_helper_iret_protected ( cpu_env , tcg_const_i32 ( dflag - 1 ) , tcg_const_i32 ( s -> pc - s -> cs_base ) ) ; set_cc_op ( s , CC_OP_EFLAGS ) ; } gen_eob ( s ) ; break ; case 0xe8 : { if ( dflag != MO_16 ) { tval = ( int32_t ) insn_get ( env , s , MO_32 ) ; } else { tval = ( int16_t ) insn_get ( env , s , MO_16 ) ; } next_eip = s -> pc - s -> cs_base ; tval += next_eip ; if ( dflag == MO_16 ) { tval &= 0xffff ; } else if ( ! CODE64 ( s ) ) { tval &= 0xffffffff ; } tcg_gen_movi_tl ( cpu_T0 , next_eip ) ; gen_push_v ( s , cpu_T0 ) ; gen_bnd_jmp ( s ) ; gen_jmp ( s , tval ) ; } break ; case 0x9a : { unsigned int selector , offset ; if ( CODE64 ( s ) ) goto illegal_op ; ot = dflag ; offset = insn_get ( env , s , ot ) ; selector = insn_get ( env , s , MO_16 ) ; tcg_gen_movi_tl ( cpu_T0 , selector ) ; tcg_gen_movi_tl ( cpu_T1 , offset ) ; } goto do_lcall ; case 0xe9 : if ( dflag != MO_16 ) { tval = ( int32_t ) insn_get ( env , s , MO_32 ) ; } else { tval = ( int16_t ) insn_get ( env , s , MO_16 ) ; } tval += s -> pc - s -> cs_base ; if ( dflag == MO_16 ) { tval &= 0xffff ; } else if ( ! CODE64 ( s ) ) { tval &= 0xffffffff ; } gen_bnd_jmp ( s ) ; gen_jmp ( s , tval ) ; break ; case 0xea : { unsigned int selector , offset ; if ( CODE64 ( s ) ) goto illegal_op ; ot = dflag ; offset = insn_get ( env , s , ot ) ; selector = insn_get ( env , s , MO_16 ) ; tcg_gen_movi_tl ( cpu_T0 , selector ) ; tcg_gen_movi_tl ( cpu_T1 , offset ) ; } goto do_ljmp ; case 0xeb : tval = ( int8_t ) insn_get ( env , s , MO_8 ) ; tval += s -> pc - s -> cs_base ; if ( dflag == MO_16 ) { tval &= 0xffff ; } gen_jmp ( s , tval ) ; break ; case 0x70 ... 0x7f : tval = ( int8_t ) insn_get ( env , s , MO_8 ) ; goto do_jcc ; case 0x180 ... 0x18f : if ( dflag != MO_16 ) { tval = ( int32_t ) insn_get ( env , s , MO_32 ) ; } else { tval = ( int16_t ) insn_get ( env , s , MO_16 ) ; } do_jcc : next_eip = s -> pc - s -> cs_base ; tval += next_eip ; if ( dflag == MO_16 ) { tval &= 0xffff ; } gen_bnd_jmp ( s ) ; gen_jcc ( s , b , tval , next_eip ) ; break ; case 0x190 ... 0x19f : modrm = cpu_ldub_code ( env , s -> pc ++ ) ; gen_setcc1 ( s , b , cpu_T0 ) ; gen_ldst_modrm ( env , s , modrm , MO_8 , OR_TMP0 , 1 ) ; break ; case 0x140 ... 0x14f : if ( ! ( s -> cpuid_features & CPUID_CMOV ) ) { goto illegal_op ; } ot = dflag ; modrm = cpu_ldub_code ( env , s -> pc ++ ) ; reg = ( ( modrm >> 3 ) & 7 ) | rex_r ; gen_cmovcc1 ( env , s , ot , b , modrm , reg ) ; break ; case 0x9c : gen_svm_check_intercept ( s , pc_start , SVM_EXIT_PUSHF ) ; if ( s -> vm86 && s -> iopl != 3 ) { gen_exception ( s , EXCP0D_GPF , pc_start - s -> cs_base ) ; } else { gen_update_cc_op ( s ) ; gen_helper_read_eflags ( cpu_T0 , cpu_env ) ; gen_push_v ( s , cpu_T0 ) ; } break ; case 0x9d : gen_svm_check_intercept ( s , pc_start , SVM_EXIT_POPF ) ; if ( s -> vm86 && s -> iopl != 3 ) { gen_exception ( s , EXCP0D_GPF , pc_start - s -> cs_base ) ; } else { ot = gen_pop_T0 ( s ) ; if ( s -> cpl == 0 ) { if ( dflag != MO_16 ) { gen_helper_write_eflags ( cpu_env , cpu_T0 , tcg_const_i32 ( ( TF_MASK | AC_MASK | ID_MASK | NT_MASK | IF_MASK | IOPL_MASK ) ) ) ; } else { gen_helper_write_eflags ( cpu_env , cpu_T0 , tcg_const_i32 ( ( TF_MASK | AC_MASK | ID_MASK | NT_MASK | IF_MASK | IOPL_MASK ) & 0xffff ) ) ; } } else { if ( s -> cpl <= s -> iopl ) { if ( dflag != MO_16 ) { gen_helper_write_eflags ( cpu_env , cpu_T0 , tcg_const_i32 ( ( TF_MASK | AC_MASK | ID_MASK | NT_MASK | IF_MASK ) ) ) ; } else { gen_helper_write_eflags ( cpu_env , cpu_T0 , tcg_const_i32 ( ( TF_MASK | AC_MASK | ID_MASK | NT_MASK | IF_MASK ) & 0xffff ) ) ; } } else { if ( dflag != MO_16 ) { gen_helper_write_eflags ( cpu_env , cpu_T0 , tcg_const_i32 ( ( TF_MASK | AC_MASK | ID_MASK | NT_MASK ) ) ) ; } else { gen_helper_write_eflags ( cpu_env , cpu_T0 , tcg_const_i32 ( ( TF_MASK | AC_MASK | ID_MASK | NT_MASK ) & 0xffff ) ) ; } } } gen_pop_update ( s , ot ) ; set_cc_op ( s , CC_OP_EFLAGS ) ; gen_jmp_im ( s -> pc - s -> cs_base ) ; gen_eob ( s ) ; } break ; case 0x9e : if ( CODE64 ( s ) && ! ( s -> cpuid_ext3_features & CPUID_EXT3_LAHF_LM ) ) goto illegal_op ; gen_op_mov_v_reg ( MO_8 , cpu_T0 , R_AH ) ; gen_compute_eflags ( s ) ; tcg_gen_andi_tl ( cpu_cc_src , cpu_cc_src , CC_O ) ; tcg_gen_andi_tl ( cpu_T0 , cpu_T0 , CC_S | CC_Z | CC_A | CC_P | CC_C ) ; tcg_gen_or_tl ( cpu_cc_src , cpu_cc_src , cpu_T0 ) ; break ; case 0x9f : if ( CODE64 ( s ) && ! ( s -> cpuid_ext3_features & CPUID_EXT3_LAHF_LM ) ) goto illegal_op ; gen_compute_eflags ( s ) ; tcg_gen_ori_tl ( cpu_T0 , cpu_cc_src , 0x02 ) ; gen_op_mov_reg_v ( MO_8 , R_AH , cpu_T0 ) ; break ; case 0xf5 : gen_compute_eflags ( s ) ; tcg_gen_xori_tl ( cpu_cc_src , cpu_cc_src , CC_C ) ; break ; case 0xf8 : gen_compute_eflags ( s ) ; tcg_gen_andi_tl ( cpu_cc_src , cpu_cc_src , ~ CC_C ) ; break ; case 0xf9 : gen_compute_eflags ( s ) ; tcg_gen_ori_tl ( cpu_cc_src , cpu_cc_src , CC_C ) ; break ; case 0xfc : tcg_gen_movi_i32 ( cpu_tmp2_i32 , 1 ) ; tcg_gen_st_i32 ( cpu_tmp2_i32 , cpu_env , offsetof ( CPUX86State , df ) ) ; break ; case 0xfd : tcg_gen_movi_i32 ( cpu_tmp2_i32 , - 1 ) ; tcg_gen_st_i32 ( cpu_tmp2_i32 , cpu_env , offsetof ( CPUX86State , df ) ) ; break ; case 0x1ba : ot = dflag ; modrm = cpu_ldub_code ( env , s -> pc ++ ) ; op = ( modrm >> 3 ) & 7 ; mod = ( modrm >> 6 ) & 3 ; rm = ( modrm & 7 ) | REX_B ( s ) ; if ( mod != 3 ) { s -> rip_offset = 1 ; gen_lea_modrm ( env , s , modrm ) ; if ( ! ( s -> prefix & PREFIX_LOCK ) ) { gen_op_ld_v ( s , ot , cpu_T0 , cpu_A0 ) ; } } else { gen_op_mov_v_reg ( ot , cpu_T0 , rm ) ; } val = cpu_ldub_code ( env , s -> pc ++ ) ; tcg_gen_movi_tl ( cpu_T1 , val ) ; if ( op < 4 ) goto unknown_op ; op -= 4 ; goto bt_op ; case 0x1a3 : op = 0 ; goto do_btx ; case 0x1ab : op = 1 ; goto do_btx ; case 0x1b3 : op = 2 ; goto do_btx ; case 0x1bb : op = 3 ; do_btx : ot = dflag ; modrm = cpu_ldub_code ( env , s -> pc ++ ) ; reg = ( ( modrm >> 3 ) & 7 ) | rex_r ; mod = ( modrm >> 6 ) & 3 ; rm = ( modrm & 7 ) | REX_B ( s ) ; gen_op_mov_v_reg ( MO_32 , cpu_T1 , reg ) ; if ( mod != 3 ) { AddressParts a = gen_lea_modrm_0 ( env , s , modrm ) ; gen_exts ( ot , cpu_T1 ) ; tcg_gen_sari_tl ( cpu_tmp0 , cpu_T1 , 3 + ot ) ; tcg_gen_shli_tl ( cpu_tmp0 , cpu_tmp0 , ot ) ; tcg_gen_add_tl ( cpu_A0 , gen_lea_modrm_1 ( a ) , cpu_tmp0 ) ; gen_lea_v_seg ( s , s -> aflag , cpu_A0 , a . def_seg , s -> override ) ; if ( ! ( s -> prefix & PREFIX_LOCK ) ) { gen_op_ld_v ( s , ot , cpu_T0 , cpu_A0 ) ; } } else { gen_op_mov_v_reg ( ot , cpu_T0 , rm ) ; } bt_op : tcg_gen_andi_tl ( cpu_T1 , cpu_T1 , ( 1 << ( 3 + ot ) ) - 1 ) ; tcg_gen_movi_tl ( cpu_tmp0 , 1 ) ; tcg_gen_shl_tl ( cpu_tmp0 , cpu_tmp0 , cpu_T1 ) ; if ( s -> prefix & PREFIX_LOCK ) { switch ( op ) { case 0 : gen_op_ld_v ( s , ot , cpu_T0 , cpu_A0 ) ; break ; case 1 : tcg_gen_atomic_fetch_or_tl ( cpu_T0 , cpu_A0 , cpu_tmp0 , s -> mem_index , ot | MO_LE ) ; break ; case 2 : tcg_gen_not_tl ( cpu_tmp0 , cpu_tmp0 ) ; tcg_gen_atomic_fetch_and_tl ( cpu_T0 , cpu_A0 , cpu_tmp0 , s -> mem_index , ot | MO_LE ) ; break ; default : case 3 : tcg_gen_atomic_fetch_xor_tl ( cpu_T0 , cpu_A0 , cpu_tmp0 , s -> mem_index , ot | MO_LE ) ; break ; } tcg_gen_shr_tl ( cpu_tmp4 , cpu_T0 , cpu_T1 ) ; } else { tcg_gen_shr_tl ( cpu_tmp4 , cpu_T0 , cpu_T1 ) ; switch ( op ) { case 0 : break ; case 1 : tcg_gen_or_tl ( cpu_T0 , cpu_T0 , cpu_tmp0 ) ; break ; case 2 : tcg_gen_andc_tl ( cpu_T0 , cpu_T0 , cpu_tmp0 ) ; break ; default : case 3 : tcg_gen_xor_tl ( cpu_T0 , cpu_T0 , cpu_tmp0 ) ; break ; } if ( op != 0 ) { if ( mod != 3 ) { gen_op_st_v ( s , ot , cpu_T0 , cpu_A0 ) ; } else { gen_op_mov_reg_v ( ot , rm , cpu_T0 ) ; } } } switch ( s -> cc_op ) { case CC_OP_MULB ... CC_OP_MULQ : case CC_OP_ADDB ... CC_OP_ADDQ : case CC_OP_ADCB ... CC_OP_ADCQ : case CC_OP_SUBB ... CC_OP_SUBQ : case CC_OP_SBBB ... CC_OP_SBBQ : case CC_OP_LOGICB ... CC_OP_LOGICQ : case CC_OP_INCB ... CC_OP_INCQ : case CC_OP_DECB ... CC_OP_DECQ : case CC_OP_SHLB ... CC_OP_SHLQ : case CC_OP_SARB ... CC_OP_SARQ : case CC_OP_BMILGB ... CC_OP_BMILGQ : tcg_gen_mov_tl ( cpu_cc_src , cpu_tmp4 ) ; set_cc_op ( s , ( ( s -> cc_op - CC_OP_MULB ) & 3 ) + CC_OP_SARB ) ; break ; default : gen_compute_eflags ( s ) ; tcg_gen_deposit_tl ( cpu_cc_src , cpu_cc_src , cpu_tmp4 , ctz32 ( CC_C ) , 1 ) ; break ; } break ; case 0x1bc : case 0x1bd : ot = dflag ; modrm = cpu_ldub_code ( env , s -> pc ++ ) ; reg = ( ( modrm >> 3 ) & 7 ) | rex_r ; gen_ldst_modrm ( env , s , modrm , ot , OR_TMP0 , 0 ) ; gen_extu ( ot , cpu_T0 ) ; if ( ( prefixes & PREFIX_REPZ ) && ( b & 1 ? s -> cpuid_ext3_features & CPUID_EXT3_ABM : s -> cpuid_7_0_ebx_features & CPUID_7_0_EBX_BMI1 ) ) { int size = 8 << ot ; tcg_gen_mov_tl ( cpu_cc_src , cpu_T0 ) ; if ( b & 1 ) { tcg_gen_clzi_tl ( cpu_T0 , cpu_T0 , TARGET_LONG_BITS ) ; tcg_gen_subi_tl ( cpu_T0 , cpu_T0 , TARGET_LONG_BITS - size ) ; } else { tcg_gen_ctzi_tl ( cpu_T0 , cpu_T0 , size ) ; } gen_op_update1_cc ( ) ; set_cc_op ( s , CC_OP_BMILGB + ot ) ; } else { tcg_gen_mov_tl ( cpu_cc_dst , cpu_T0 ) ; set_cc_op ( s , CC_OP_LOGICB + ot ) ; if ( b & 1 ) { tcg_gen_xori_tl ( cpu_T1 , cpu_regs [ reg ] , TARGET_LONG_BITS - 1 ) ; tcg_gen_clz_tl ( cpu_T0 , cpu_T0 , cpu_T1 ) ; tcg_gen_xori_tl ( cpu_T0 , cpu_T0 , TARGET_LONG_BITS - 1 ) ; } else { tcg_gen_ctz_tl ( cpu_T0 , cpu_T0 , cpu_regs [ reg ] ) ; } } gen_op_mov_reg_v ( ot , reg , cpu_T0 ) ; break ; case 0x27 : if ( CODE64 ( s ) ) goto illegal_op ; gen_update_cc_op ( s ) ; gen_helper_daa ( cpu_env ) ; set_cc_op ( s , CC_OP_EFLAGS ) ; break ; case 0x2f : if ( CODE64 ( s ) ) goto illegal_op ; gen_update_cc_op ( s ) ; gen_helper_das ( cpu_env ) ; set_cc_op ( s , CC_OP_EFLAGS ) ; break ; case 0x37 : if ( CODE64 ( s ) ) goto illegal_op ; gen_update_cc_op ( s ) ; gen_helper_aaa ( cpu_env ) ; set_cc_op ( s , CC_OP_EFLAGS ) ; break ; case 0x3f : if ( CODE64 ( s ) ) goto illegal_op ; gen_update_cc_op ( s ) ; gen_helper_aas ( cpu_env ) ; set_cc_op ( s , CC_OP_EFLAGS ) ; break ; case 0xd4 : if ( CODE64 ( s ) ) goto illegal_op ; val = cpu_ldub_code ( env , s -> pc ++ ) ; if ( val == 0 ) { gen_exception ( s , EXCP00_DIVZ , pc_start - s -> cs_base ) ; } else { gen_helper_aam ( cpu_env , tcg_const_i32 ( val ) ) ; set_cc_op ( s , CC_OP_LOGICB ) ; } break ; case 0xd5 : if ( CODE64 ( s ) ) goto illegal_op ; val = cpu_ldub_code ( env , s -> pc ++ ) ; gen_helper_aad ( cpu_env , tcg_const_i32 ( val ) ) ; set_cc_op ( s , CC_OP_LOGICB ) ; break ; case 0x90 : if ( prefixes & PREFIX_LOCK ) { goto illegal_op ; } if ( REX_B ( s ) ) { goto do_xchg_reg_eax ; } if ( prefixes & PREFIX_REPZ ) { gen_update_cc_op ( s ) ; gen_jmp_im ( pc_start - s -> cs_base ) ; gen_helper_pause ( cpu_env , tcg_const_i32 ( s -> pc - pc_start ) ) ; s -> is_jmp = DISAS_TB_JUMP ; } break ; case 0x9b : if ( ( s -> flags & ( HF_MP_MASK | HF_TS_MASK ) ) == ( HF_MP_MASK | HF_TS_MASK ) ) { gen_exception ( s , EXCP07_PREX , pc_start - s -> cs_base ) ; } else { gen_helper_fwait ( cpu_env ) ; } break ; case 0xcc : gen_interrupt ( s , EXCP03_INT3 , pc_start - s -> cs_base , s -> pc - s -> cs_base ) ; break ; case 0xcd : val = cpu_ldub_code ( env , s -> pc ++ ) ; if ( s -> vm86 && s -> iopl != 3 ) { gen_exception ( s , EXCP0D_GPF , pc_start - s -> cs_base ) ; } else { gen_interrupt ( s , val , pc_start - s -> cs_base , s -> pc - s -> cs_base ) ; } break ; case 0xce : if ( CODE64 ( s ) ) goto illegal_op ; gen_update_cc_op ( s ) ; gen_jmp_im ( pc_start - s -> cs_base ) ; gen_helper_into ( cpu_env , tcg_const_i32 ( s -> pc - pc_start ) ) ; break ; # ifdef WANT_ICEBP case 0xf1 : gen_svm_check_intercept ( s , pc_start , SVM_EXIT_ICEBP ) ; # if 1 gen_debug ( s , pc_start - s -> cs_base ) ; # else tb_flush ( CPU ( x86_env_get_cpu ( env ) ) ) ; qemu_set_log ( CPU_LOG_INT | CPU_LOG_TB_IN_ASM ) ; # endif break ; # endif case 0xfa : if ( ! s -> vm86 ) { if ( s -> cpl <= s -> iopl ) { gen_helper_cli ( cpu_env ) ; } else { gen_exception ( s , EXCP0D_GPF , pc_start - s -> cs_base ) ; } } else { if ( s -> iopl == 3 ) { gen_helper_cli ( cpu_env ) ; } else { gen_exception ( s , EXCP0D_GPF , pc_start - s -> cs_base ) ; } } break ; case 0xfb : if ( s -> vm86 ? s -> iopl == 3 : s -> cpl <= s -> iopl ) { gen_helper_sti ( cpu_env ) ; gen_jmp_im ( s -> pc - s -> cs_base ) ; gen_eob_inhibit_irq ( s , true ) ; } else { gen_exception ( s , EXCP0D_GPF , pc_start - s -> cs_base ) ; } break ; case 0x62 : if ( CODE64 ( s ) ) goto illegal_op ; ot = dflag ; modrm = cpu_ldub_code ( env , s -> pc ++ ) ; reg = ( modrm >> 3 ) & 7 ; mod = ( modrm >> 6 ) & 3 ; if ( mod == 3 ) goto illegal_op ; gen_op_mov_v_reg ( ot , cpu_T0 , reg ) ; gen_lea_modrm ( env , s , modrm ) ; tcg_gen_trunc_tl_i32 ( cpu_tmp2_i32 , cpu_T0 ) ; if ( ot == MO_16 ) { gen_helper_boundw ( cpu_env , cpu_A0 , cpu_tmp2_i32 ) ; } else { gen_helper_boundl ( cpu_env , cpu_A0 , cpu_tmp2_i32 ) ; } break ; case 0x1c8 ... 0x1cf : reg = ( b & 7 ) | REX_B ( s ) ; # ifdef TARGET_X86_64 if ( dflag == MO_64 ) { gen_op_mov_v_reg ( MO_64 , cpu_T0 , reg ) ; tcg_gen_bswap64_i64 ( cpu_T0 , cpu_T0 ) ; gen_op_mov_reg_v ( MO_64 , reg , cpu_T0 ) ; } else # endif { gen_op_mov_v_reg ( MO_32 , cpu_T0 , reg ) ; tcg_gen_ext32u_tl ( cpu_T0 , cpu_T0 ) ; tcg_gen_bswap32_tl ( cpu_T0 , cpu_T0 ) ; gen_op_mov_reg_v ( MO_32 , reg , cpu_T0 ) ; } break ; case 0xd6 : if ( CODE64 ( s ) ) goto illegal_op ; gen_compute_eflags_c ( s , cpu_T0 ) ; tcg_gen_neg_tl ( cpu_T0 , cpu_T0 ) ; gen_op_mov_reg_v ( MO_8 , R_EAX , cpu_T0 ) ; break ; case 0xe0 : case 0xe1 : case 0xe2 : case 0xe3 : { TCGLabel * l1 , * l2 , * l3 ; tval = ( int8_t ) insn_get ( env , s , MO_8 ) ; next_eip = s -> pc - s -> cs_base ; tval += next_eip ; if ( dflag == MO_16 ) { tval &= 0xffff ; } l1 = gen_new_label ( ) ; l2 = gen_new_label ( ) ; l3 = gen_new_label ( ) ; b &= 3 ; switch ( b ) { case 0 : case 1 : gen_op_add_reg_im ( s -> aflag , R_ECX , - 1 ) ; gen_op_jz_ecx ( s -> aflag , l3 ) ; gen_jcc1 ( s , ( JCC_Z << 1 ) | ( b ^ 1 ) , l1 ) ; break ; case 2 : gen_op_add_reg_im ( s -> aflag , R_ECX , - 1 ) ; gen_op_jnz_ecx ( s -> aflag , l1 ) ; break ; default : case 3 : gen_op_jz_ecx ( s -> aflag , l1 ) ; break ; } gen_set_label ( l3 ) ; gen_jmp_im ( next_eip ) ; tcg_gen_br ( l2 ) ; gen_set_label ( l1 ) ; gen_jmp_im ( tval ) ; gen_set_label ( l2 ) ; gen_eob ( s ) ; } break ; case 0x130 : case 0x132 : if ( s -> cpl != 0 ) { gen_exception ( s , EXCP0D_GPF , pc_start - s -> cs_base ) ; } else { gen_update_cc_op ( s ) ; gen_jmp_im ( pc_start - s -> cs_base ) ; if ( b & 2 ) { gen_helper_rdmsr ( cpu_env ) ; } else { gen_helper_wrmsr ( cpu_env ) ; } } break ; case 0x131 : gen_update_cc_op ( s ) ; gen_jmp_im ( pc_start - s -> cs_base ) ; if ( s -> tb -> cflags & CF_USE_ICOUNT ) { gen_io_start ( ) ; } gen_helper_rdtsc ( cpu_env ) ; if ( s -> tb -> cflags & CF_USE_ICOUNT ) { gen_io_end ( ) ; gen_jmp ( s , s -> pc - s -> cs_base ) ; } break ; case 0x133 : gen_update_cc_op ( s ) ; gen_jmp_im ( pc_start - s -> cs_base ) ; gen_helper_rdpmc ( cpu_env ) ; break ; case 0x134 : if ( CODE64 ( s ) && env -> cpuid_vendor1 != CPUID_VENDOR_INTEL_1 ) goto illegal_op ; if ( ! s -> pe ) { gen_exception ( s , EXCP0D_GPF , pc_start - s -> cs_base ) ; } else { gen_helper_sysenter ( cpu_env ) ; gen_eob ( s ) ; } break ; case 0x135 : if ( CODE64 ( s ) && env -> cpuid_vendor1 != CPUID_VENDOR_INTEL_1 ) goto illegal_op ; if ( ! s -> pe ) { gen_exception ( s , EXCP0D_GPF , pc_start - s -> cs_base ) ; } else { gen_helper_sysexit ( cpu_env , tcg_const_i32 ( dflag - 1 ) ) ; gen_eob ( s ) ; } break ; # ifdef TARGET_X86_64 case 0x105 : gen_update_cc_op ( s ) ; gen_jmp_im ( pc_start - s -> cs_base ) ; gen_helper_syscall ( cpu_env , tcg_const_i32 ( s -> pc - pc_start ) ) ; gen_eob_worker ( s , false , true ) ; break ; case 0x107 : if ( ! s -> pe ) { gen_exception ( s , EXCP0D_GPF , pc_start - s -> cs_base ) ; } else { gen_helper_sysret ( cpu_env , tcg_const_i32 ( dflag - 1 ) ) ; if ( s -> lma ) { set_cc_op ( s , CC_OP_EFLAGS ) ; } gen_eob_worker ( s , false , true ) ; } break ; # endif case 0x1a2 : gen_update_cc_op ( s ) ; gen_jmp_im ( pc_start - s -> cs_base ) ; gen_helper_cpuid ( cpu_env ) ; break ; case 0xf4 : if ( s -> cpl != 0 ) { gen_exception ( s , EXCP0D_GPF , pc_start - s -> cs_base ) ; } else { gen_update_cc_op ( s ) ; gen_jmp_im ( pc_start - s -> cs_base ) ; gen_helper_hlt ( cpu_env , tcg_const_i32 ( s -> pc - pc_start ) ) ; s -> is_jmp = DISAS_TB_JUMP ; } break ; case 0x100 : modrm = cpu_ldub_code ( env , s -> pc ++ ) ; mod = ( modrm >> 6 ) & 3 ; op = ( modrm >> 3 ) & 7 ; switch ( op ) { case 0 : if ( ! s -> pe || s -> vm86 ) goto illegal_op ; gen_svm_check_intercept ( s , pc_start , SVM_EXIT_LDTR_READ ) ; tcg_gen_ld32u_tl ( cpu_T0 , cpu_env , offsetof ( CPUX86State , ldt . selector ) ) ; ot = mod == 3 ? dflag : MO_16 ; gen_ldst_modrm ( env , s , modrm , ot , OR_TMP0 , 1 ) ; break ; case 2 : if ( ! s -> pe || s -> vm86 ) goto illegal_op ; if ( s -> cpl != 0 ) { gen_exception ( s , EXCP0D_GPF , pc_start - s -> cs_base ) ; } else { gen_svm_check_intercept ( s , pc_start , SVM_EXIT_LDTR_WRITE ) ; gen_ldst_modrm ( env , s , modrm , MO_16 , OR_TMP0 , 0 ) ; tcg_gen_trunc_tl_i32 ( cpu_tmp2_i32 , cpu_T0 ) ; gen_helper_lldt ( cpu_env , cpu_tmp2_i32 ) ; } break ; case 1 : if ( ! s -> pe || s -> vm86 ) goto illegal_op ; gen_svm_check_intercept ( s , pc_start , SVM_EXIT_TR_READ ) ; tcg_gen_ld32u_tl ( cpu_T0 , cpu_env , offsetof ( CPUX86State , tr . selector ) ) ; ot = mod == 3 ? dflag : MO_16 ; gen_ldst_modrm ( env , s , modrm , ot , OR_TMP0 , 1 ) ; break ; case 3 : if ( ! s -> pe || s -> vm86 ) goto illegal_op ; if ( s -> cpl != 0 ) { gen_exception ( s , EXCP0D_GPF , pc_start - s -> cs_base ) ; } else { gen_svm_check_intercept ( s , pc_start , SVM_EXIT_TR_WRITE ) ; gen_ldst_modrm ( env , s , modrm , MO_16 , OR_TMP0 , 0 ) ; tcg_gen_trunc_tl_i32 ( cpu_tmp2_i32 , cpu_T0 ) ; gen_helper_ltr ( cpu_env , cpu_tmp2_i32 ) ; } break ; case 4 : case 5 : if ( ! s -> pe || s -> vm86 ) goto illegal_op ; gen_ldst_modrm ( env , s , modrm , MO_16 , OR_TMP0 , 0 ) ; gen_update_cc_op ( s ) ; if ( op == 4 ) { gen_helper_verr ( cpu_env , cpu_T0 ) ; } else { gen_helper_verw ( cpu_env , cpu_T0 ) ; } set_cc_op ( s , CC_OP_EFLAGS ) ; break ; default : goto unknown_op ; } break ; case 0x101 : modrm = cpu_ldub_code ( env , s -> pc ++ ) ; switch ( modrm ) { CASE_MODRM_MEM_OP ( 0 ) : gen_svm_check_intercept ( s , pc_start , SVM_EXIT_GDTR_READ ) ; gen_lea_modrm ( env , s , modrm ) ; tcg_gen_ld32u_tl ( cpu_T0 , cpu_env , offsetof ( CPUX86State , gdt . limit ) ) ; gen_op_st_v ( s , MO_16 , cpu_T0 , cpu_A0 ) ; gen_add_A0_im ( s , 2 ) ; tcg_gen_ld_tl ( cpu_T0 , cpu_env , offsetof ( CPUX86State , gdt . base ) ) ; if ( dflag == MO_16 ) { tcg_gen_andi_tl ( cpu_T0 , cpu_T0 , 0xffffff ) ; } gen_op_st_v ( s , CODE64 ( s ) + MO_32 , cpu_T0 , cpu_A0 ) ; break ; case 0xc8 : if ( ! ( s -> cpuid_ext_features & CPUID_EXT_MONITOR ) || s -> cpl != 0 ) { goto illegal_op ; } gen_update_cc_op ( s ) ; gen_jmp_im ( pc_start - s -> cs_base ) ; tcg_gen_mov_tl ( cpu_A0 , cpu_regs [ R_EAX ] ) ; gen_extu ( s -> aflag , cpu_A0 ) ; gen_add_A0_ds_seg ( s ) ; gen_helper_monitor ( cpu_env , cpu_A0 ) ; break ; case 0xc9 : if ( ! ( s -> cpuid_ext_features & CPUID_EXT_MONITOR ) || s -> cpl != 0 ) { goto illegal_op ; } gen_update_cc_op ( s ) ; gen_jmp_im ( pc_start - s -> cs_base ) ; gen_helper_mwait ( cpu_env , tcg_const_i32 ( s -> pc - pc_start ) ) ; gen_eob ( s ) ; break ; case 0xca : if ( ! ( s -> cpuid_7_0_ebx_features & CPUID_7_0_EBX_SMAP ) || s -> cpl != 0 ) { goto illegal_op ; } gen_helper_clac ( cpu_env ) ; gen_jmp_im ( s -> pc - s -> cs_base ) ; gen_eob ( s ) ; break ; case 0xcb : if ( ! ( s -> cpuid_7_0_ebx_features & CPUID_7_0_EBX_SMAP ) || s -> cpl != 0 ) { goto illegal_op ; } gen_helper_stac ( cpu_env ) ; gen_jmp_im ( s -> pc - s -> cs_base ) ; gen_eob ( s ) ; break ; CASE_MODRM_MEM_OP ( 1 ) : gen_svm_check_intercept ( s , pc_start , SVM_EXIT_IDTR_READ ) ; gen_lea_modrm ( env , s , modrm ) ; tcg_gen_ld32u_tl ( cpu_T0 , cpu_env , offsetof ( CPUX86State , idt . limit ) ) ; gen_op_st_v ( s , MO_16 , cpu_T0 , cpu_A0 ) ; gen_add_A0_im ( s , 2 ) ; tcg_gen_ld_tl ( cpu_T0 , cpu_env , offsetof ( CPUX86State , idt . base ) ) ; if ( dflag == MO_16 ) { tcg_gen_andi_tl ( cpu_T0 , cpu_T0 , 0xffffff ) ; } gen_op_st_v ( s , CODE64 ( s ) + MO_32 , cpu_T0 , cpu_A0 ) ; break ; case 0xd0 : if ( ( s -> cpuid_ext_features & CPUID_EXT_XSAVE ) == 0 || ( s -> prefix & ( PREFIX_LOCK | PREFIX_DATA | PREFIX_REPZ | PREFIX_REPNZ ) ) ) { goto illegal_op ; } tcg_gen_trunc_tl_i32 ( cpu_tmp2_i32 , cpu_regs [ R_ECX ] ) ; gen_helper_xgetbv ( cpu_tmp1_i64 , cpu_env , cpu_tmp2_i32 ) ; tcg_gen_extr_i64_tl ( cpu_regs [ R_EAX ] , cpu_regs [ R_EDX ] , cpu_tmp1_i64 ) ; break ; case 0xd1 : if ( ( s -> cpuid_ext_features & CPUID_EXT_XSAVE ) == 0 || ( s -> prefix & ( PREFIX_LOCK | PREFIX_DATA | PREFIX_REPZ | PREFIX_REPNZ ) ) ) { goto illegal_op ; } if ( s -> cpl != 0 ) { gen_exception ( s , EXCP0D_GPF , pc_start - s -> cs_base ) ; break ; } tcg_gen_concat_tl_i64 ( cpu_tmp1_i64 , cpu_regs [ R_EAX ] , cpu_regs [ R_EDX ] ) ; tcg_gen_trunc_tl_i32 ( cpu_tmp2_i32 , cpu_regs [ R_ECX ] ) ; gen_helper_xsetbv ( cpu_env , cpu_tmp2_i32 , cpu_tmp1_i64 ) ; gen_jmp_im ( s -> pc - s -> cs_base ) ; gen_eob ( s ) ; break ; case 0xd8 : if ( ! ( s -> flags & HF_SVME_MASK ) || ! s -> pe ) { goto illegal_op ; } if ( s -> cpl != 0 ) { gen_exception ( s , EXCP0D_GPF , pc_start - s -> cs_base ) ; break ; } gen_update_cc_op ( s ) ; gen_jmp_im ( pc_start - s -> cs_base ) ; gen_helper_vmrun ( cpu_env , tcg_const_i32 ( s -> aflag - 1 ) , tcg_const_i32 ( s -> pc - pc_start ) ) ; tcg_gen_exit_tb ( 0 ) ; s -> is_jmp = DISAS_TB_JUMP ; break ; case 0xd9 : if ( ! ( s -> flags & HF_SVME_MASK ) ) { goto illegal_op ; } gen_update_cc_op ( s ) ; gen_jmp_im ( pc_start - s -> cs_base ) ; gen_helper_vmmcall ( cpu_env ) ; break ; case 0xda : if ( ! ( s -> flags & HF_SVME_MASK ) || ! s -> pe ) { goto illegal_op ; } if ( s -> cpl != 0 ) { gen_exception ( s , EXCP0D_GPF , pc_start - s -> cs_base ) ; break ; } gen_update_cc_op ( s ) ; gen_jmp_im ( pc_start - s -> cs_base ) ; gen_helper_vmload ( cpu_env , tcg_const_i32 ( s -> aflag - 1 ) ) ; break ; case 0xdb : if ( ! ( s -> flags & HF_SVME_MASK ) || ! s -> pe ) { goto illegal_op ; } if ( s -> cpl != 0 ) { gen_exception ( s , EXCP0D_GPF , pc_start - s -> cs_base ) ; break ; } gen_update_cc_op ( s ) ; gen_jmp_im ( pc_start - s -> cs_base ) ; gen_helper_vmsave ( cpu_env , tcg_const_i32 ( s -> aflag - 1 ) ) ; break ; case 0xdc : if ( ( ! ( s -> flags & HF_SVME_MASK ) && ! ( s -> cpuid_ext3_features & CPUID_EXT3_SKINIT ) ) || ! s -> pe ) { goto illegal_op ; } if ( s -> cpl != 0 ) { gen_exception ( s , EXCP0D_GPF , pc_start - s -> cs_base ) ; break ; } gen_update_cc_op ( s ) ; gen_jmp_im ( pc_start - s -> cs_base ) ; gen_helper_stgi ( cpu_env ) ; break ; case 0xdd : if ( ! ( s -> flags & HF_SVME_MASK ) || ! s -> pe ) { goto illegal_op ; } if ( s -> cpl != 0 ) { gen_exception ( s , EXCP0D_GPF , pc_start - s -> cs_base ) ; break ; } gen_update_cc_op ( s ) ; gen_jmp_im ( pc_start - s -> cs_base ) ; gen_helper_clgi ( cpu_env ) ; break ; case 0xde : if ( ( ! ( s -> flags & HF_SVME_MASK ) && ! ( s -> cpuid_ext3_features & CPUID_EXT3_SKINIT ) ) || ! s -> pe ) { goto illegal_op ; } gen_update_cc_op ( s ) ; gen_jmp_im ( pc_start - s -> cs_base ) ; gen_helper_skinit ( cpu_env ) ; break ; case 0xdf : if ( ! ( s -> flags & HF_SVME_MASK ) || ! s -> pe ) { goto illegal_op ; } if ( s -> cpl != 0 ) { gen_exception ( s , EXCP0D_GPF , pc_start - s -> cs_base ) ; break ; } gen_update_cc_op ( s ) ; gen_jmp_im ( pc_start - s -> cs_base ) ; gen_helper_invlpga ( cpu_env , tcg_const_i32 ( s -> aflag - 1 ) ) ; break ; CASE_MODRM_MEM_OP ( 2 ) : if ( s -> cpl != 0 ) { gen_exception ( s , EXCP0D_GPF , pc_start - s -> cs_base ) ; break ; } gen_svm_check_intercept ( s , pc_start , SVM_EXIT_GDTR_WRITE ) ; gen_lea_modrm ( env , s , modrm ) ; gen_op_ld_v ( s , MO_16 , cpu_T1 , cpu_A0 ) ; gen_add_A0_im ( s , 2 ) ; gen_op_ld_v ( s , CODE64 ( s ) + MO_32 , cpu_T0 , cpu_A0 ) ; if ( dflag == MO_16 ) { tcg_gen_andi_tl ( cpu_T0 , cpu_T0 , 0xffffff ) ; } tcg_gen_st_tl ( cpu_T0 , cpu_env , offsetof ( CPUX86State , gdt . base ) ) ; tcg_gen_st32_tl ( cpu_T1 , cpu_env , offsetof ( CPUX86State , gdt . limit ) ) ; break ; CASE_MODRM_MEM_OP ( 3 ) : if ( s -> cpl != 0 ) { gen_exception ( s , EXCP0D_GPF , pc_start - s -> cs_base ) ; break ; } gen_svm_check_intercept ( s , pc_start , SVM_EXIT_IDTR_WRITE ) ; gen_lea_modrm ( env , s , modrm ) ; gen_op_ld_v ( s , MO_16 , cpu_T1 , cpu_A0 ) ; gen_add_A0_im ( s , 2 ) ; gen_op_ld_v ( s , CODE64 ( s ) + MO_32 , cpu_T0 , cpu_A0 ) ; if ( dflag == MO_16 ) { tcg_gen_andi_tl ( cpu_T0 , cpu_T0 , 0xffffff ) ; } tcg_gen_st_tl ( cpu_T0 , cpu_env , offsetof ( CPUX86State , idt . base ) ) ; tcg_gen_st32_tl ( cpu_T1 , cpu_env , offsetof ( CPUX86State , idt . limit ) ) ; break ; CASE_MODRM_OP ( 4 ) : gen_svm_check_intercept ( s , pc_start , SVM_EXIT_READ_CR0 ) ; tcg_gen_ld_tl ( cpu_T0 , cpu_env , offsetof ( CPUX86State , cr [ 0 ] ) ) ; if ( CODE64 ( s ) ) { mod = ( modrm >> 6 ) & 3 ; ot = ( mod != 3 ? MO_16 : s -> dflag ) ; } else { ot = MO_16 ; } gen_ldst_modrm ( env , s , modrm , ot , OR_TMP0 , 1 ) ; break ; case 0xee : if ( prefixes & PREFIX_LOCK ) { goto illegal_op ; } tcg_gen_trunc_tl_i32 ( cpu_tmp2_i32 , cpu_regs [ R_ECX ] ) ; gen_helper_rdpkru ( cpu_tmp1_i64 , cpu_env , cpu_tmp2_i32 ) ; tcg_gen_extr_i64_tl ( cpu_regs [ R_EAX ] , cpu_regs [ R_EDX ] , cpu_tmp1_i64 ) ; break ; case 0xef : if ( prefixes & PREFIX_LOCK ) { goto illegal_op ; } tcg_gen_concat_tl_i64 ( cpu_tmp1_i64 , cpu_regs [ R_EAX ] , cpu_regs [ R_EDX ] ) ; tcg_gen_trunc_tl_i32 ( cpu_tmp2_i32 , cpu_regs [ R_ECX ] ) ; gen_helper_wrpkru ( cpu_env , cpu_tmp2_i32 , cpu_tmp1_i64 ) ; break ; CASE_MODRM_OP ( 6 ) : if ( s -> cpl != 0 ) { gen_exception ( s , EXCP0D_GPF , pc_start - s -> cs_base ) ; break ; } gen_svm_check_intercept ( s , pc_start , SVM_EXIT_WRITE_CR0 ) ; gen_ldst_modrm ( env , s , modrm , MO_16 , OR_TMP0 , 0 ) ; gen_helper_lmsw ( cpu_env , cpu_T0 ) ; gen_jmp_im ( s -> pc - s -> cs_base ) ; gen_eob ( s ) ; break ; CASE_MODRM_MEM_OP ( 7 ) : if ( s -> cpl != 0 ) { gen_exception ( s , EXCP0D_GPF , pc_start - s -> cs_base ) ; break ; } gen_update_cc_op ( s ) ; gen_jmp_im ( pc_start - s -> cs_base ) ; gen_lea_modrm ( env , s , modrm ) ; gen_helper_invlpg ( cpu_env , cpu_A0 ) ; gen_jmp_im ( s -> pc - s -> cs_base ) ; gen_eob ( s ) ; break ; case 0xf8 : # ifdef TARGET_X86_64 if ( CODE64 ( s ) ) { if ( s -> cpl != 0 ) { gen_exception ( s , EXCP0D_GPF , pc_start - s -> cs_base ) ; } else { tcg_gen_mov_tl ( cpu_T0 , cpu_seg_base [ R_GS ] ) ; tcg_gen_ld_tl ( cpu_seg_base [ R_GS ] , cpu_env , offsetof ( CPUX86State , kernelgsbase ) ) ; tcg_gen_st_tl ( cpu_T0 , cpu_env , offsetof ( CPUX86State , kernelgsbase ) ) ; } break ; } # endif goto illegal_op ; case 0xf9 : if ( ! ( s -> cpuid_ext2_features & CPUID_EXT2_RDTSCP ) ) { goto illegal_op ; } gen_update_cc_op ( s ) ; gen_jmp_im ( pc_start - s -> cs_base ) ; if ( s -> tb -> cflags & CF_USE_ICOUNT ) { gen_io_start ( ) ; } gen_helper_rdtscp ( cpu_env ) ; if ( s -> tb -> cflags & CF_USE_ICOUNT ) { gen_io_end ( ) ; gen_jmp ( s , s -> pc - s -> cs_base ) ; } break ; default : goto unknown_op ; } break ; case 0x108 : case 0x109 : if ( s -> cpl != 0 ) { gen_exception ( s , EXCP0D_GPF , pc_start - s -> cs_base ) ; } else { gen_svm_check_intercept ( s , pc_start , ( b & 2 ) ? SVM_EXIT_INVD : SVM_EXIT_WBINVD ) ; } break ; case 0x63 : # ifdef TARGET_X86_64 if ( CODE64 ( s ) ) { int d_ot ; d_ot = dflag ; modrm = cpu_ldub_code ( env , s -> pc ++ ) ; reg = ( ( modrm >> 3 ) & 7 ) | rex_r ; mod = ( modrm >> 6 ) & 3 ; rm = ( modrm & 7 ) | REX_B ( s ) ; if ( mod == 3 ) { gen_op_mov_v_reg ( MO_32 , cpu_T0 , rm ) ; if ( d_ot == MO_64 ) { tcg_gen_ext32s_tl ( cpu_T0 , cpu_T0 ) ; } gen_op_mov_reg_v ( d_ot , reg , cpu_T0 ) ; } else { gen_lea_modrm ( env , s , modrm ) ; gen_op_ld_v ( s , MO_32 | MO_SIGN , cpu_T0 , cpu_A0 ) ; gen_op_mov_reg_v ( d_ot , reg , cpu_T0 ) ; } } else # endif { TCGLabel * label1 ; TCGv t0 , t1 , t2 , a0 ; if ( ! s -> pe || s -> vm86 ) goto illegal_op ; t0 = tcg_temp_local_new ( ) ; t1 = tcg_temp_local_new ( ) ; t2 = tcg_temp_local_new ( ) ; ot = MO_16 ; modrm = cpu_ldub_code ( env , s -> pc ++ ) ; reg = ( modrm >> 3 ) & 7 ; mod = ( modrm >> 6 ) & 3 ; rm = modrm & 7 ; if ( mod != 3 ) { gen_lea_modrm ( env , s , modrm ) ; gen_op_ld_v ( s , ot , t0 , cpu_A0 ) ; a0 = tcg_temp_local_new ( ) ; tcg_gen_mov_tl ( a0 , cpu_A0 ) ; } else { gen_op_mov_v_reg ( ot , t0 , rm ) ; TCGV_UNUSED ( a0 ) ; } gen_op_mov_v_reg ( ot , t1 , reg ) ; tcg_gen_andi_tl ( cpu_tmp0 , t0 , 3 ) ; tcg_gen_andi_tl ( t1 , t1 , 3 ) ; tcg_gen_movi_tl ( t2 , 0 ) ; label1 = gen_new_label ( ) ; tcg_gen_brcond_tl ( TCG_COND_GE , cpu_tmp0 , t1 , label1 ) ; tcg_gen_andi_tl ( t0 , t0 , ~ 3 ) ; tcg_gen_or_tl ( t0 , t0 , t1 ) ; tcg_gen_movi_tl ( t2 , CC_Z ) ; gen_set_label ( label1 ) ; if ( mod != 3 ) { gen_op_st_v ( s , ot , t0 , a0 ) ; tcg_temp_free ( a0 ) ; } else { gen_op_mov_reg_v ( ot , rm , t0 ) ; } gen_compute_eflags ( s ) ; tcg_gen_andi_tl ( cpu_cc_src , cpu_cc_src , ~ CC_Z ) ; tcg_gen_or_tl ( cpu_cc_src , cpu_cc_src , t2 ) ; tcg_temp_free ( t0 ) ; tcg_temp_free ( t1 ) ; tcg_temp_free ( t2 ) ; } break ; case 0x102 : case 0x103 : { TCGLabel * label1 ; TCGv t0 ; if ( ! s -> pe || s -> vm86 ) goto illegal_op ; ot = dflag != MO_16 ? MO_32 : MO_16 ; modrm = cpu_ldub_code ( env , s -> pc ++ ) ; reg = ( ( modrm >> 3 ) & 7 ) | rex_r ; gen_ldst_modrm ( env , s , modrm , MO_16 , OR_TMP0 , 0 ) ; t0 = tcg_temp_local_new ( ) ; gen_update_cc_op ( s ) ; if ( b == 0x102 ) { gen_helper_lar ( t0 , cpu_env , cpu_T0 ) ; } else { gen_helper_lsl ( t0 , cpu_env , cpu_T0 ) ; } tcg_gen_andi_tl ( cpu_tmp0 , cpu_cc_src , CC_Z ) ; label1 = gen_new_label ( ) ; tcg_gen_brcondi_tl ( TCG_COND_EQ , cpu_tmp0 , 0 , label1 ) ; gen_op_mov_reg_v ( ot , reg , t0 ) ; gen_set_label ( label1 ) ; set_cc_op ( s , CC_OP_EFLAGS ) ; tcg_temp_free ( t0 ) ; } break ; case 0x118 : modrm = cpu_ldub_code ( env , s -> pc ++ ) ; mod = ( modrm >> 6 ) & 3 ; op = ( modrm >> 3 ) & 7 ; switch ( op ) { case 0 : case 1 : case 2 : case 3 : if ( mod == 3 ) goto illegal_op ; gen_nop_modrm ( env , s , modrm ) ; break ; default : gen_nop_modrm ( env , s , modrm ) ; break ; } break ; case 0x11a : modrm = cpu_ldub_code ( env , s -> pc ++ ) ; if ( s -> flags & HF_MPX_EN_MASK ) { mod = ( modrm >> 6 ) & 3 ; reg = ( ( modrm >> 3 ) & 7 ) | rex_r ; if ( prefixes & PREFIX_REPZ ) { if ( reg >= 4 || ( prefixes & PREFIX_LOCK ) || s -> aflag == MO_16 ) { goto illegal_op ; } gen_bndck ( env , s , modrm , TCG_COND_LTU , cpu_bndl [ reg ] ) ; } else if ( prefixes & PREFIX_REPNZ ) { if ( reg >= 4 || ( prefixes & PREFIX_LOCK ) || s -> aflag == MO_16 ) { goto illegal_op ; } TCGv_i64 notu = tcg_temp_new_i64 ( ) ; tcg_gen_not_i64 ( notu , cpu_bndu [ reg ] ) ; gen_bndck ( env , s , modrm , TCG_COND_GTU , notu ) ; tcg_temp_free_i64 ( notu ) ; } else if ( prefixes & PREFIX_DATA ) { if ( reg >= 4 || s -> aflag == MO_16 ) { goto illegal_op ; } if ( mod == 3 ) { int reg2 = ( modrm & 7 ) | REX_B ( s ) ; if ( reg2 >= 4 || ( prefixes & PREFIX_LOCK ) ) { goto illegal_op ; } if ( s -> flags & HF_MPX_IU_MASK ) { tcg_gen_mov_i64 ( cpu_bndl [ reg ] , cpu_bndl [ reg2 ] ) ; tcg_gen_mov_i64 ( cpu_bndu [ reg ] , cpu_bndu [ reg2 ] ) ; } } else { gen_lea_modrm ( env , s , modrm ) ; if ( CODE64 ( s ) ) { tcg_gen_qemu_ld_i64 ( cpu_bndl [ reg ] , cpu_A0 , s -> mem_index , MO_LEQ ) ; tcg_gen_addi_tl ( cpu_A0 , cpu_A0 , 8 ) ; tcg_gen_qemu_ld_i64 ( cpu_bndu [ reg ] , cpu_A0 , s -> mem_index , MO_LEQ ) ; } else { tcg_gen_qemu_ld_i64 ( cpu_bndl [ reg ] , cpu_A0 , s -> mem_index , MO_LEUL ) ; tcg_gen_addi_tl ( cpu_A0 , cpu_A0 , 4 ) ; tcg_gen_qemu_ld_i64 ( cpu_bndu [ reg ] , cpu_A0 , s -> mem_index , MO_LEUL ) ; } gen_set_hflag ( s , HF_MPX_IU_MASK ) ; } } else if ( mod != 3 ) { AddressParts a = gen_lea_modrm_0 ( env , s , modrm ) ; if ( reg >= 4 || ( prefixes & PREFIX_LOCK ) || s -> aflag == MO_16 || a . base < - 1 ) { goto illegal_op ; } if ( a . base >= 0 ) { tcg_gen_addi_tl ( cpu_A0 , cpu_regs [ a . base ] , a . disp ) ; } else { tcg_gen_movi_tl ( cpu_A0 , 0 ) ; } gen_lea_v_seg ( s , s -> aflag , cpu_A0 , a . def_seg , s -> override ) ; if ( a . index >= 0 ) { tcg_gen_mov_tl ( cpu_T0 , cpu_regs [ a . index ] ) ; } else { tcg_gen_movi_tl ( cpu_T0 , 0 ) ; } if ( CODE64 ( s ) ) { gen_helper_bndldx64 ( cpu_bndl [ reg ] , cpu_env , cpu_A0 , cpu_T0 ) ; tcg_gen_ld_i64 ( cpu_bndu [ reg ] , cpu_env , offsetof ( CPUX86State , mmx_t0 . MMX_Q ( 0 ) ) ) ; } else { gen_helper_bndldx32 ( cpu_bndu [ reg ] , cpu_env , cpu_A0 , cpu_T0 ) ; tcg_gen_ext32u_i64 ( cpu_bndl [ reg ] , cpu_bndu [ reg ] ) ; tcg_gen_shri_i64 ( cpu_bndu [ reg ] , cpu_bndu [ reg ] , 32 ) ; } gen_set_hflag ( s , HF_MPX_IU_MASK ) ; } } gen_nop_modrm ( env , s , modrm ) ; break ; case 0x11b : modrm = cpu_ldub_code ( env , s -> pc ++ ) ; if ( s -> flags & HF_MPX_EN_MASK ) { mod = ( modrm >> 6 ) & 3 ; reg = ( ( modrm >> 3 ) & 7 ) | rex_r ; if ( mod != 3 && ( prefixes & PREFIX_REPZ ) ) { if ( reg >= 4 || ( prefixes & PREFIX_LOCK ) || s -> aflag == MO_16 ) { goto illegal_op ; } AddressParts a = gen_lea_modrm_0 ( env , s , modrm ) ; if ( a . base >= 0 ) { tcg_gen_extu_tl_i64 ( cpu_bndl [ reg ] , cpu_regs [ a . base ] ) ; if ( ! CODE64 ( s ) ) { tcg_gen_ext32u_i64 ( cpu_bndl [ reg ] , cpu_bndl [ reg ] ) ; } } else if ( a . base == - 1 ) { tcg_gen_movi_i64 ( cpu_bndl [ reg ] , 0 ) ; } else { goto illegal_op ; } tcg_gen_not_tl ( cpu_A0 , gen_lea_modrm_1 ( a ) ) ; if ( ! CODE64 ( s ) ) { tcg_gen_ext32u_tl ( cpu_A0 , cpu_A0 ) ; } tcg_gen_extu_tl_i64 ( cpu_bndu [ reg ] , cpu_A0 ) ; gen_set_hflag ( s , HF_MPX_IU_MASK ) ; break ; } else if ( prefixes & PREFIX_REPNZ ) { if ( reg >= 4 || ( prefixes & PREFIX_LOCK ) || s -> aflag == MO_16 ) { goto illegal_op ; } gen_bndck ( env , s , modrm , TCG_COND_GTU , cpu_bndu [ reg ] ) ; } else if ( prefixes & PREFIX_DATA ) { if ( reg >= 4 || s -> aflag == MO_16 ) { goto illegal_op ; } if ( mod == 3 ) { int reg2 = ( modrm & 7 ) | REX_B ( s ) ; if ( reg2 >= 4 || ( prefixes & PREFIX_LOCK ) ) { goto illegal_op ; } if ( s -> flags & HF_MPX_IU_MASK ) { tcg_gen_mov_i64 ( cpu_bndl [ reg2 ] , cpu_bndl [ reg ] ) ; tcg_gen_mov_i64 ( cpu_bndu [ reg2 ] , cpu_bndu [ reg ] ) ; } } else { gen_lea_modrm ( env , s , modrm ) ; if ( CODE64 ( s ) ) { tcg_gen_qemu_st_i64 ( cpu_bndl [ reg ] , cpu_A0 , s -> mem_index , MO_LEQ ) ; tcg_gen_addi_tl ( cpu_A0 , cpu_A0 , 8 ) ; tcg_gen_qemu_st_i64 ( cpu_bndu [ reg ] , cpu_A0 , s -> mem_index , MO_LEQ ) ; } else { tcg_gen_qemu_st_i64 ( cpu_bndl [ reg ] , cpu_A0 , s -> mem_index , MO_LEUL ) ; tcg_gen_addi_tl ( cpu_A0 , cpu_A0 , 4 ) ; tcg_gen_qemu_st_i64 ( cpu_bndu [ reg ] , cpu_A0 , s -> mem_index , MO_LEUL ) ; } } } else if ( mod != 3 ) { AddressParts a = gen_lea_modrm_0 ( env , s , modrm ) ; if ( reg >= 4 || ( prefixes & PREFIX_LOCK ) || s -> aflag == MO_16 || a . base < - 1 ) { goto illegal_op ; } if ( a . base >= 0 ) { tcg_gen_addi_tl ( cpu_A0 , cpu_regs [ a . base ] , a . disp ) ; } else { tcg_gen_movi_tl ( cpu_A0 , 0 ) ; } gen_lea_v_seg ( s , s -> aflag , cpu_A0 , a . def_seg , s -> override ) ; if ( a . index >= 0 ) { tcg_gen_mov_tl ( cpu_T0 , cpu_regs [ a . index ] ) ; } else { tcg_gen_movi_tl ( cpu_T0 , 0 ) ; } if ( CODE64 ( s ) ) { gen_helper_bndstx64 ( cpu_env , cpu_A0 , cpu_T0 , cpu_bndl [ reg ] , cpu_bndu [ reg ] ) ; } else { gen_helper_bndstx32 ( cpu_env , cpu_A0 , cpu_T0 , cpu_bndl [ reg ] , cpu_bndu [ reg ] ) ; } } } gen_nop_modrm ( env , s , modrm ) ; break ; case 0x119 : case 0x11c ... 0x11f : modrm = cpu_ldub_code ( env , s -> pc ++ ) ; gen_nop_modrm ( env , s , modrm ) ; break ; case 0x120 : case 0x122 : if ( s -> cpl != 0 ) { gen_exception ( s , EXCP0D_GPF , pc_start - s -> cs_base ) ; } else { modrm = cpu_ldub_code ( env , s -> pc ++ ) ; rm = ( modrm & 7 ) | REX_B ( s ) ; reg = ( ( modrm >> 3 ) & 7 ) | rex_r ; if ( CODE64 ( s ) ) ot = MO_64 ; else ot = MO_32 ; if ( ( prefixes & PREFIX_LOCK ) && ( reg == 0 ) && ( s -> cpuid_ext3_features & CPUID_EXT3_CR8LEG ) ) { reg = 8 ; } switch ( reg ) { case 0 : case 2 : case 3 : case 4 : case 8 : gen_update_cc_op ( s ) ; gen_jmp_im ( pc_start - s -> cs_base ) ; if ( b & 2 ) { gen_op_mov_v_reg ( ot , cpu_T0 , rm ) ; gen_helper_write_crN ( cpu_env , tcg_const_i32 ( reg ) , cpu_T0 ) ; gen_jmp_im ( s -> pc - s -> cs_base ) ; gen_eob ( s ) ; } else { gen_helper_read_crN ( cpu_T0 , cpu_env , tcg_const_i32 ( reg ) ) ; gen_op_mov_reg_v ( ot , rm , cpu_T0 ) ; } break ; default : goto unknown_op ; } } break ; case 0x121 : case 0x123 : if ( s -> cpl != 0 ) { gen_exception ( s , EXCP0D_GPF , pc_start - s -> cs_base ) ; } else { modrm = cpu_ldub_code ( env , s -> pc ++ ) ; rm = ( modrm & 7 ) | REX_B ( s ) ; reg = ( ( modrm >> 3 ) & 7 ) | rex_r ; if ( CODE64 ( s ) ) ot = MO_64 ; else ot = MO_32 ; if ( reg >= 8 ) { goto illegal_op ; } if ( b & 2 ) { gen_svm_check_intercept ( s , pc_start , SVM_EXIT_WRITE_DR0 + reg ) ; gen_op_mov_v_reg ( ot , cpu_T0 , rm ) ; tcg_gen_movi_i32 ( cpu_tmp2_i32 , reg ) ; gen_helper_set_dr ( cpu_env , cpu_tmp2_i32 , cpu_T0 ) ; gen_jmp_im ( s -> pc - s -> cs_base ) ; gen_eob ( s ) ; } else { gen_svm_check_intercept ( s , pc_start , SVM_EXIT_READ_DR0 + reg ) ; tcg_gen_movi_i32 ( cpu_tmp2_i32 , reg ) ; gen_helper_get_dr ( cpu_T0 , cpu_env , cpu_tmp2_i32 ) ; gen_op_mov_reg_v ( ot , rm , cpu_T0 ) ; } } break ; case 0x106 : if ( s -> cpl != 0 ) { gen_exception ( s , EXCP0D_GPF , pc_start - s -> cs_base ) ; } else { gen_svm_check_intercept ( s , pc_start , SVM_EXIT_WRITE_CR0 ) ; gen_helper_clts ( cpu_env ) ; gen_jmp_im ( s -> pc - s -> cs_base ) ; gen_eob ( s ) ; } break ; case 0x1c3 : if ( ! ( s -> cpuid_features & CPUID_SSE2 ) ) goto illegal_op ; ot = mo_64_32 ( dflag ) ; modrm = cpu_ldub_code ( env , s -> pc ++ ) ; mod = ( modrm >> 6 ) & 3 ; if ( mod == 3 ) goto illegal_op ; reg = ( ( modrm >> 3 ) & 7 ) | rex_r ; gen_ldst_modrm ( env , s , modrm , ot , reg , 1 ) ; break ; case 0x1ae : modrm = cpu_ldub_code ( env , s -> pc ++ ) ; switch ( modrm ) { CASE_MODRM_MEM_OP ( 0 ) : if ( ! ( s -> cpuid_features & CPUID_FXSR ) || ( prefixes & PREFIX_LOCK ) ) { goto illegal_op ; } if ( ( s -> flags & HF_EM_MASK ) || ( s -> flags & HF_TS_MASK ) ) { gen_exception ( s , EXCP07_PREX , pc_start - s -> cs_base ) ; break ; } gen_lea_modrm ( env , s , modrm ) ; gen_helper_fxsave ( cpu_env , cpu_A0 ) ; break ; CASE_MODRM_MEM_OP ( 1 ) : if ( ! ( s -> cpuid_features & CPUID_FXSR ) || ( prefixes & PREFIX_LOCK ) ) { goto illegal_op ; } if ( ( s -> flags & HF_EM_MASK ) || ( s -> flags & HF_TS_MASK ) ) { gen_exception ( s , EXCP07_PREX , pc_start - s -> cs_base ) ; break ; } gen_lea_modrm ( env , s , modrm ) ; gen_helper_fxrstor ( cpu_env , cpu_A0 ) ; break ; CASE_MODRM_MEM_OP ( 2 ) : if ( ( s -> flags & HF_EM_MASK ) || ! ( s -> flags & HF_OSFXSR_MASK ) ) { goto illegal_op ; } if ( s -> flags & HF_TS_MASK ) { gen_exception ( s , EXCP07_PREX , pc_start - s -> cs_base ) ; break ; } gen_lea_modrm ( env , s , modrm ) ; tcg_gen_qemu_ld_i32 ( cpu_tmp2_i32 , cpu_A0 , s -> mem_index , MO_LEUL ) ; gen_helper_ldmxcsr ( cpu_env , cpu_tmp2_i32 ) ; break ; CASE_MODRM_MEM_OP ( 3 ) : if ( ( s -> flags & HF_EM_MASK ) || ! ( s -> flags & HF_OSFXSR_MASK ) ) { goto illegal_op ; } if ( s -> flags & HF_TS_MASK ) { gen_exception ( s , EXCP07_PREX , pc_start - s -> cs_base ) ; break ; } gen_lea_modrm ( env , s , modrm ) ; tcg_gen_ld32u_tl ( cpu_T0 , cpu_env , offsetof ( CPUX86State , mxcsr ) ) ; gen_op_st_v ( s , MO_32 , cpu_T0 , cpu_A0 ) ; break ; CASE_MODRM_MEM_OP ( 4 ) : if ( ( s -> cpuid_ext_features & CPUID_EXT_XSAVE ) == 0 || ( prefixes & ( PREFIX_LOCK | PREFIX_DATA | PREFIX_REPZ | PREFIX_REPNZ ) ) ) { goto illegal_op ; } gen_lea_modrm ( env , s , modrm ) ; tcg_gen_concat_tl_i64 ( cpu_tmp1_i64 , cpu_regs [ R_EAX ] , cpu_regs [ R_EDX ] ) ; gen_helper_xsave ( cpu_env , cpu_A0 , cpu_tmp1_i64 ) ; break ; CASE_MODRM_MEM_OP ( 5 ) : if ( ( s -> cpuid_ext_features & CPUID_EXT_XSAVE ) == 0 || ( prefixes & ( PREFIX_LOCK | PREFIX_DATA | PREFIX_REPZ | PREFIX_REPNZ ) ) ) { goto illegal_op ; } gen_lea_modrm ( env , s , modrm ) ; tcg_gen_concat_tl_i64 ( cpu_tmp1_i64 , cpu_regs [ R_EAX ] , cpu_regs [ R_EDX ] ) ; gen_helper_xrstor ( cpu_env , cpu_A0 , cpu_tmp1_i64 ) ; gen_update_cc_op ( s ) ; gen_jmp_im ( s -> pc - s -> cs_base ) ; gen_eob ( s ) ; break ; CASE_MODRM_MEM_OP ( 6 ) : if ( prefixes & PREFIX_LOCK ) { goto illegal_op ; } if ( prefixes & PREFIX_DATA ) { if ( ! ( s -> cpuid_7_0_ebx_features & CPUID_7_0_EBX_CLWB ) ) { goto illegal_op ; } gen_nop_modrm ( env , s , modrm ) ; } else { if ( ( s -> cpuid_ext_features & CPUID_EXT_XSAVE ) == 0 || ( s -> cpuid_xsave_features & CPUID_XSAVE_XSAVEOPT ) == 0 || ( prefixes & ( PREFIX_REPZ | PREFIX_REPNZ ) ) ) { goto illegal_op ; } gen_lea_modrm ( env , s , modrm ) ; tcg_gen_concat_tl_i64 ( cpu_tmp1_i64 , cpu_regs [ R_EAX ] , cpu_regs [ R_EDX ] ) ; gen_helper_xsaveopt ( cpu_env , cpu_A0 , cpu_tmp1_i64 ) ; } break ; CASE_MODRM_MEM_OP ( 7 ) : if ( prefixes & PREFIX_LOCK ) { goto illegal_op ; } if ( prefixes & PREFIX_DATA ) { if ( ! ( s -> cpuid_7_0_ebx_features & CPUID_7_0_EBX_CLFLUSHOPT ) ) { goto illegal_op ; } } else { if ( ( s -> prefix & ( PREFIX_REPZ | PREFIX_REPNZ ) ) || ! ( s -> cpuid_features & CPUID_CLFLUSH ) ) { goto illegal_op ; } } gen_nop_modrm ( env , s , modrm ) ; break ; case 0xc0 ... 0xc7 : case 0xc8 ... 0xc8 : case 0xd0 ... 0xd7 : case 0xd8 ... 0xd8 : if ( CODE64 ( s ) && ( prefixes & PREFIX_REPZ ) && ! ( prefixes & PREFIX_LOCK ) && ( s -> cpuid_7_0_ebx_features & CPUID_7_0_EBX_FSGSBASE ) ) { TCGv base , treg , src , dst ; tcg_gen_movi_i32 ( cpu_tmp2_i32 , CR4_FSGSBASE_MASK ) ; gen_helper_cr4_testbit ( cpu_env , cpu_tmp2_i32 ) ; base = cpu_seg_base [ modrm & 8 ? R_GS : R_FS ] ; treg = cpu_regs [ ( modrm & 7 ) | REX_B ( s ) ] ; if ( modrm & 0x10 ) { dst = base , src = treg ; } else { dst = treg , src = base ; } if ( s -> dflag == MO_32 ) { tcg_gen_ext32u_tl ( dst , src ) ; } else { tcg_gen_mov_tl ( dst , src ) ; } break ; } goto unknown_op ; case 0xf8 : if ( prefixes & PREFIX_DATA ) { if ( ! ( s -> cpuid_7_0_ebx_features & CPUID_7_0_EBX_PCOMMIT ) || ( prefixes & PREFIX_LOCK ) ) { goto illegal_op ; } break ; } case 0xf9 ... 0xff : if ( ! ( s -> cpuid_features & CPUID_SSE ) || ( prefixes & PREFIX_LOCK ) ) { goto illegal_op ; } tcg_gen_mb ( TCG_MO_ST_ST | TCG_BAR_SC ) ; break ; case 0xe8 ... 0xef : if ( ! ( s -> cpuid_features & CPUID_SSE ) || ( prefixes & PREFIX_LOCK ) ) { goto illegal_op ; } tcg_gen_mb ( TCG_MO_LD_LD | TCG_BAR_SC ) ; break ; case 0xf0 ... 0xf7 : if ( ! ( s -> cpuid_features & CPUID_SSE2 ) || ( prefixes & PREFIX_LOCK ) ) { goto illegal_op ; } tcg_gen_mb ( TCG_MO_ALL | TCG_BAR_SC ) ; break ; default : goto unknown_op ; } break ; case 0x10d : modrm = cpu_ldub_code ( env , s -> pc ++ ) ; mod = ( modrm >> 6 ) & 3 ; if ( mod == 3 ) goto illegal_op ; gen_nop_modrm ( env , s , modrm ) ; break ; case 0x1aa : gen_svm_check_intercept ( s , pc_start , SVM_EXIT_RSM ) ; if ( ! ( s -> flags & HF_SMM_MASK ) ) goto illegal_op ; gen_update_cc_op ( s ) ; gen_jmp_im ( s -> pc - s -> cs_base ) ; gen_helper_rsm ( cpu_env ) ; gen_eob ( s ) ; break ; case 0x1b8 : if ( ( prefixes & ( PREFIX_REPZ | PREFIX_LOCK | PREFIX_REPNZ ) ) != PREFIX_REPZ ) goto illegal_op ; if ( ! ( s -> cpuid_ext_features & CPUID_EXT_POPCNT ) ) goto illegal_op ; modrm = cpu_ldub_code ( env , s -> pc ++ ) ; reg = ( ( modrm >> 3 ) & 7 ) | rex_r ; if ( s -> prefix & PREFIX_DATA ) { ot = MO_16 ; } else { ot = mo_64_32 ( dflag ) ; } gen_ldst_modrm ( env , s , modrm , ot , OR_TMP0 , 0 ) ; gen_extu ( ot , cpu_T0 ) ; tcg_gen_mov_tl ( cpu_cc_src , cpu_T0 ) ; tcg_gen_ctpop_tl ( cpu_T0 , cpu_T0 ) ; gen_op_mov_reg_v ( ot , reg , cpu_T0 ) ; set_cc_op ( s , CC_OP_POPCNT ) ; break ; case 0x10e ... 0x10f : s -> prefix &= ~ ( PREFIX_REPZ | PREFIX_REPNZ | PREFIX_DATA ) ; case 0x110 ... 0x117 : case 0x128 ... 0x12f : case 0x138 ... 0x13a : case 0x150 ... 0x179 : case 0x17c ... 0x17f : case 0x1c2 : case 0x1c4 ... 0x1c6 : case 0x1d0 ... 0x1fe : gen_sse ( env , s , b , pc_start , rex_r ) ; break ; default : goto unknown_op ; } return s -> pc ; illegal_op : gen_illegal_opcode ( s ) ; return s -> pc ; unknown_op : gen_unknown_opcode ( env , s ) ; return s -> pc ; }",; next_byte : if ( s -> pc - pc_start > 14 ) { goto illegal_op ; }
478,"static Image * ReadMPCImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { char cache_filename [ MagickPathExtent ] , id [ MagickPathExtent ] , keyword [ MagickPathExtent ] , * options ; const unsigned char * p ; GeometryInfo geometry_info ; Image * image ; int c ; LinkedListInfo * profiles ; MagickBooleanType status ; MagickOffsetType offset ; MagickStatusType flags ; register ssize_t i ; size_t depth , length ; ssize_t count ; StringInfo * profile ; unsigned int signature ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) CopyMagickString ( cache_filename , image -> filename , MagickPathExtent ) ; AppendImageFormat ( ""cache"" , cache_filename ) ; c = ReadBlobByte ( image ) ; if ( c == EOF ) { image = DestroyImage ( image ) ; return ( ( Image * ) NULL ) ; } * id = '\\0' ; ( void ) ResetMagickMemory ( keyword , 0 , sizeof ( keyword ) ) ; offset = 0 ; do { profiles = ( LinkedListInfo * ) NULL ; length = MagickPathExtent ; options = AcquireString ( ( char * ) NULL ) ; signature = GetMagickSignature ( ( const StringInfo * ) NULL ) ; image -> depth = 8 ; image -> compression = NoCompression ; while ( ( isgraph ( c ) != MagickFalse ) && ( c != ( int ) ':' ) ) { register char * p ; if ( c == ( int ) '{' ) { char * comment ; length = MagickPathExtent ; comment = AcquireString ( ( char * ) NULL ) ; for ( p = comment ; comment != ( char * ) NULL ; p ++ ) { c = ReadBlobByte ( image ) ; if ( c == ( int ) '\\\\' ) c = ReadBlobByte ( image ) ; else if ( ( c == EOF ) || ( c == ( int ) '}' ) ) break ; if ( ( size_t ) ( p - comment + 1 ) >= length ) { * p = '\\0' ; length <<= 1 ; comment = ( char * ) ResizeQuantumMemory ( comment , length + MagickPathExtent , sizeof ( * comment ) ) ; if ( comment == ( char * ) NULL ) break ; p = comment + strlen ( comment ) ; } * p = ( char ) c ; } if ( comment == ( char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; * p = '\\0' ; ( void ) SetImageProperty ( image , ""comment"" , comment , exception ) ; comment = DestroyString ( comment ) ; c = ReadBlobByte ( image ) ; } else if ( isalnum ( c ) != MagickFalse ) { length = MagickPathExtent ; p = keyword ; do { if ( c == ( int ) '=' ) break ; if ( ( size_t ) ( p - keyword ) < ( MagickPathExtent - 1 ) ) * p ++ = ( char ) c ; c = ReadBlobByte ( image ) ; } while ( c != EOF ) ; * p = '\\0' ; p = options ; while ( isspace ( ( int ) ( ( unsigned char ) c ) ) != 0 ) c = ReadBlobByte ( image ) ; if ( c == ( int ) '=' ) { c = ReadBlobByte ( image ) ; while ( ( c != ( int ) '}' ) && ( c != EOF ) ) { if ( ( size_t ) ( p - options + 1 ) >= length ) { * p = '\\0' ; length <<= 1 ; options = ( char * ) ResizeQuantumMemory ( options , length + MagickPathExtent , sizeof ( * options ) ) ; if ( options == ( char * ) NULL ) break ; p = options + strlen ( options ) ; } * p ++ = ( char ) c ; c = ReadBlobByte ( image ) ; if ( c == '\\\\' ) { c = ReadBlobByte ( image ) ; if ( c == ( int ) '}' ) { * p ++ = ( char ) c ; c = ReadBlobByte ( image ) ; } } if ( * options != '{' ) if ( isspace ( ( int ) ( ( unsigned char ) c ) ) != 0 ) break ; } if ( options == ( char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } * p = '\\0' ; if ( * options == '{' ) ( void ) CopyMagickString ( options , options + 1 , strlen ( options ) ) ; switch ( * keyword ) { case 'a' : case 'A' : { if ( LocaleCompare ( keyword , ""alpha-trait"" ) == 0 ) { ssize_t alpha_trait ; alpha_trait = ParseCommandOption ( MagickPixelTraitOptions , MagickFalse , options ) ; if ( alpha_trait < 0 ) break ; image -> alpha_trait = ( PixelTrait ) alpha_trait ; break ; } ( void ) SetImageProperty ( image , keyword , options , exception ) ; break ; } case 'b' : case 'B' : { if ( LocaleCompare ( keyword , ""background-color"" ) == 0 ) { ( void ) QueryColorCompliance ( options , AllCompliance , & image -> background_color , exception ) ; break ; } if ( LocaleCompare ( keyword , ""blue-primary"" ) == 0 ) { flags = ParseGeometry ( options , & geometry_info ) ; image -> chromaticity . blue_primary . x = geometry_info . rho ; image -> chromaticity . blue_primary . y = geometry_info . sigma ; if ( ( flags & SigmaValue ) == 0 ) image -> chromaticity . blue_primary . y = image -> chromaticity . blue_primary . x ; break ; } if ( LocaleCompare ( keyword , ""border-color"" ) == 0 ) { ( void ) QueryColorCompliance ( options , AllCompliance , & image -> border_color , exception ) ; break ; } ( void ) SetImageProperty ( image , keyword , options , exception ) ; break ; } case 'c' : case 'C' : { if ( LocaleCompare ( keyword , ""class"" ) == 0 ) { ssize_t storage_class ; storage_class = ParseCommandOption ( MagickClassOptions , MagickFalse , options ) ; if ( storage_class < 0 ) break ; image -> storage_class = ( ClassType ) storage_class ; break ; } if ( LocaleCompare ( keyword , ""colors"" ) == 0 ) { image -> colors = StringToUnsignedLong ( options ) ; break ; } if ( LocaleCompare ( keyword , ""colorspace"" ) == 0 ) { ssize_t colorspace ; colorspace = ParseCommandOption ( MagickColorspaceOptions , MagickFalse , options ) ; if ( colorspace < 0 ) break ; image -> colorspace = ( ColorspaceType ) colorspace ; break ; } if ( LocaleCompare ( keyword , ""compression"" ) == 0 ) { ssize_t compression ; compression = ParseCommandOption ( MagickCompressOptions , MagickFalse , options ) ; if ( compression < 0 ) break ; image -> compression = ( CompressionType ) compression ; break ; } if ( LocaleCompare ( keyword , ""columns"" ) == 0 ) { image -> columns = StringToUnsignedLong ( options ) ; break ; } ( void ) SetImageProperty ( image , keyword , options , exception ) ; break ; } case 'd' : case 'D' : { if ( LocaleCompare ( keyword , ""delay"" ) == 0 ) { image -> delay = StringToUnsignedLong ( options ) ; break ; } if ( LocaleCompare ( keyword , ""depth"" ) == 0 ) { image -> depth = StringToUnsignedLong ( options ) ; break ; } if ( LocaleCompare ( keyword , ""dispose"" ) == 0 ) { ssize_t dispose ; dispose = ParseCommandOption ( MagickDisposeOptions , MagickFalse , options ) ; if ( dispose < 0 ) break ; image -> dispose = ( DisposeType ) dispose ; break ; } ( void ) SetImageProperty ( image , keyword , options , exception ) ; break ; } case 'e' : case 'E' : { if ( LocaleCompare ( keyword , ""endian"" ) == 0 ) { ssize_t endian ; endian = ParseCommandOption ( MagickEndianOptions , MagickFalse , options ) ; if ( endian < 0 ) break ; image -> endian = ( EndianType ) endian ; break ; } if ( LocaleCompare ( keyword , ""error"" ) == 0 ) { image -> error . mean_error_per_pixel = StringToDouble ( options , ( char * * ) NULL ) ; break ; } ( void ) SetImageProperty ( image , keyword , options , exception ) ; break ; } case 'g' : case 'G' : { if ( LocaleCompare ( keyword , ""gamma"" ) == 0 ) { image -> gamma = StringToDouble ( options , ( char * * ) NULL ) ; break ; } if ( LocaleCompare ( keyword , ""green-primary"" ) == 0 ) { flags = ParseGeometry ( options , & geometry_info ) ; image -> chromaticity . green_primary . x = geometry_info . rho ; image -> chromaticity . green_primary . y = geometry_info . sigma ; if ( ( flags & SigmaValue ) == 0 ) image -> chromaticity . green_primary . y = image -> chromaticity . green_primary . x ; break ; } ( void ) SetImageProperty ( image , keyword , options , exception ) ; break ; } case 'i' : case 'I' : { if ( LocaleCompare ( keyword , ""id"" ) == 0 ) { ( void ) CopyMagickString ( id , options , MagickPathExtent ) ; break ; } if ( LocaleCompare ( keyword , ""iterations"" ) == 0 ) { image -> iterations = StringToUnsignedLong ( options ) ; break ; } ( void ) SetImageProperty ( image , keyword , options , exception ) ; break ; } case 'm' : case 'M' : { if ( LocaleCompare ( keyword , ""magick-signature"" ) == 0 ) { signature = ( unsigned int ) StringToUnsignedLong ( options ) ; break ; } if ( LocaleCompare ( keyword , ""mattecolor"" ) == 0 ) { ( void ) QueryColorCompliance ( options , AllCompliance , & image -> matte_color , exception ) ; break ; } if ( LocaleCompare ( keyword , ""maximum-error"" ) == 0 ) { image -> error . normalized_maximum_error = StringToDouble ( options , ( char * * ) NULL ) ; break ; } if ( LocaleCompare ( keyword , ""mean-error"" ) == 0 ) { image -> error . normalized_mean_error = StringToDouble ( options , ( char * * ) NULL ) ; break ; } if ( LocaleCompare ( keyword , ""montage"" ) == 0 ) { ( void ) CloneString ( & image -> montage , options ) ; break ; } ( void ) SetImageProperty ( image , keyword , options , exception ) ; break ; } case 'n' : case 'N' : { if ( LocaleCompare ( keyword , ""number-channels"" ) == 0 ) { image -> number_channels = StringToUnsignedLong ( options ) ; break ; } if ( LocaleCompare ( keyword , ""number-meta-channels"" ) == 0 ) { image -> number_meta_channels = StringToUnsignedLong ( options ) ; <S2SV_StartBug> break ; <S2SV_EndBug> } break ; } case 'o' : case 'O' : { if ( LocaleCompare ( keyword , ""orientation"" ) == 0 ) { ssize_t orientation ; orientation = ParseCommandOption ( MagickOrientationOptions , MagickFalse , options ) ; if ( orientation < 0 ) break ; image -> orientation = ( OrientationType ) orientation ; break ; } ( void ) SetImageProperty ( image , keyword , options , exception ) ; break ; } case 'p' : case 'P' : { if ( LocaleCompare ( keyword , ""page"" ) == 0 ) { char * geometry ; geometry = GetPageGeometry ( options ) ; ( void ) ParseAbsoluteGeometry ( geometry , & image -> page ) ; geometry = DestroyString ( geometry ) ; break ; } if ( LocaleCompare ( keyword , ""pixel-intensity"" ) == 0 ) { ssize_t intensity ; intensity = ParseCommandOption ( MagickPixelIntensityOptions , MagickFalse , options ) ; if ( intensity < 0 ) break ; image -> intensity = ( PixelIntensityMethod ) intensity ; break ; } if ( ( LocaleNCompare ( keyword , ""profile:"" , 8 ) == 0 ) || ( LocaleNCompare ( keyword , ""profile-"" , 8 ) == 0 ) ) { if ( profiles == ( LinkedListInfo * ) NULL ) profiles = NewLinkedList ( 0 ) ; ( void ) AppendValueToLinkedList ( profiles , AcquireString ( keyword + 8 ) ) ; profile = BlobToStringInfo ( ( const void * ) NULL , ( size_t ) StringToLong ( options ) ) ; if ( profile == ( StringInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) SetImageProfile ( image , keyword + 8 , profile , exception ) ; profile = DestroyStringInfo ( profile ) ; break ; } ( void ) SetImageProperty ( image , keyword , options , exception ) ; break ; } case 'q' : case 'Q' : { if ( LocaleCompare ( keyword , ""quality"" ) == 0 ) { image -> quality = StringToUnsignedLong ( options ) ; break ; } ( void ) SetImageProperty ( image , keyword , options , exception ) ; break ; } case 'r' : case 'R' : { if ( LocaleCompare ( keyword , ""red-primary"" ) == 0 ) { flags = ParseGeometry ( options , & geometry_info ) ; image -> chromaticity . red_primary . x = geometry_info . rho ; if ( ( flags & SigmaValue ) != 0 ) image -> chromaticity . red_primary . y = geometry_info . sigma ; break ; } if ( LocaleCompare ( keyword , ""rendering-intent"" ) == 0 ) { ssize_t rendering_intent ; rendering_intent = ParseCommandOption ( MagickIntentOptions , MagickFalse , options ) ; if ( rendering_intent < 0 ) break ; image -> rendering_intent = ( RenderingIntent ) rendering_intent ; break ; } if ( LocaleCompare ( keyword , ""resolution"" ) == 0 ) { flags = ParseGeometry ( options , & geometry_info ) ; image -> resolution . x = geometry_info . rho ; image -> resolution . y = geometry_info . sigma ; if ( ( flags & SigmaValue ) == 0 ) image -> resolution . y = image -> resolution . x ; break ; } if ( LocaleCompare ( keyword , ""rows"" ) == 0 ) { image -> rows = StringToUnsignedLong ( options ) ; break ; } ( void ) SetImageProperty ( image , keyword , options , exception ) ; break ; } case 's' : case 'S' : { if ( LocaleCompare ( keyword , ""scene"" ) == 0 ) { image -> scene = StringToUnsignedLong ( options ) ; break ; } ( void ) SetImageProperty ( image , keyword , options , exception ) ; break ; } case 't' : case 'T' : { if ( LocaleCompare ( keyword , ""ticks-per-second"" ) == 0 ) { image -> ticks_per_second = ( ssize_t ) StringToLong ( options ) ; break ; } if ( LocaleCompare ( keyword , ""tile-offset"" ) == 0 ) { char * geometry ; geometry = GetPageGeometry ( options ) ; ( void ) ParseAbsoluteGeometry ( geometry , & image -> tile_offset ) ; geometry = DestroyString ( geometry ) ; } if ( LocaleCompare ( keyword , ""type"" ) == 0 ) { ssize_t type ; type = ParseCommandOption ( MagickTypeOptions , MagickFalse , options ) ; if ( type < 0 ) break ; image -> type = ( ImageType ) type ; break ; } ( void ) SetImageProperty ( image , keyword , options , exception ) ; break ; } case 'u' : case 'U' : { if ( LocaleCompare ( keyword , ""units"" ) == 0 ) { ssize_t units ; units = ParseCommandOption ( MagickResolutionOptions , MagickFalse , options ) ; if ( units < 0 ) break ; image -> units = ( ResolutionType ) units ; break ; } ( void ) SetImageProperty ( image , keyword , options , exception ) ; break ; } case 'w' : case 'W' : { if ( LocaleCompare ( keyword , ""white-point"" ) == 0 ) { flags = ParseGeometry ( options , & geometry_info ) ; image -> chromaticity . white_point . x = geometry_info . rho ; image -> chromaticity . white_point . y = geometry_info . sigma ; if ( ( flags & SigmaValue ) == 0 ) image -> chromaticity . white_point . y = image -> chromaticity . white_point . x ; break ; } ( void ) SetImageProperty ( image , keyword , options , exception ) ; break ; } default : { ( void ) SetImageProperty ( image , keyword , options , exception ) ; break ; } } } else c = ReadBlobByte ( image ) ; while ( isspace ( ( int ) ( ( unsigned char ) c ) ) != 0 ) c = ReadBlobByte ( image ) ; } options = DestroyString ( options ) ; ( void ) ReadBlobByte ( image ) ; if ( ( LocaleCompare ( id , ""MagickCache"" ) != 0 ) || ( image -> storage_class == UndefinedClass ) || ( image -> compression == UndefinedCompression ) || ( image -> columns == 0 ) || ( image -> rows == 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( signature != GetMagickSignature ( ( const StringInfo * ) NULL ) ) ThrowReaderException ( CacheError , ""IncompatibleAPI"" ) ; if ( image -> montage != ( char * ) NULL ) { register char * p ; length = MagickPathExtent ; image -> directory = AcquireString ( ( char * ) NULL ) ; p = image -> directory ; do { * p = '\\0' ; if ( ( strlen ( image -> directory ) + MagickPathExtent ) >= length ) { length <<= 1 ; image -> directory = ( char * ) ResizeQuantumMemory ( image -> directory , length + MagickPathExtent , sizeof ( * image -> directory ) ) ; if ( image -> directory == ( char * ) NULL ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; p = image -> directory + strlen ( image -> directory ) ; } c = ReadBlobByte ( image ) ; * p ++ = ( char ) c ; } while ( c != ( int ) '\\0' ) ; } if ( profiles != ( LinkedListInfo * ) NULL ) { const char * name ; const StringInfo * profile ; register unsigned char * p ; ResetLinkedListIterator ( profiles ) ; name = ( const char * ) GetNextValueInLinkedList ( profiles ) ; while ( name != ( const char * ) NULL ) { profile = GetImageProfile ( image , name ) ; if ( profile != ( StringInfo * ) NULL ) { p = GetStringInfoDatum ( profile ) ; count = ReadBlob ( image , GetStringInfoLength ( profile ) , p ) ; } name = ( const char * ) GetNextValueInLinkedList ( profiles ) ; } profiles = DestroyLinkedList ( profiles , RelinquishMagickMemory ) ; } depth = GetImageQuantumDepth ( image , MagickFalse ) ; if ( image -> storage_class == PseudoClass ) { image -> colormap = ( PixelInfo * ) AcquireQuantumMemory ( image -> colors + 1 , sizeof ( * image -> colormap ) ) ; if ( image -> colormap == ( PixelInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; if ( image -> colors != 0 ) { size_t packet_size ; unsigned char * colormap ; packet_size = ( size_t ) ( 3UL * depth / 8UL ) ; colormap = ( unsigned char * ) AcquireQuantumMemory ( image -> colors , packet_size * sizeof ( * colormap ) ) ; if ( colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , packet_size * image -> colors , colormap ) ; if ( count != ( ssize_t ) ( packet_size * image -> colors ) ) { colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; } p = colormap ; switch ( depth ) { default : colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; ThrowReaderException ( CorruptImageError , ""ImageDepthNotSupported"" ) ; case 8 : { unsigned char pixel ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { p = PushCharPixel ( p , & pixel ) ; image -> colormap [ i ] . red = ScaleCharToQuantum ( pixel ) ; p = PushCharPixel ( p , & pixel ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( pixel ) ; p = PushCharPixel ( p , & pixel ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( pixel ) ; } break ; } case 16 : { unsigned short pixel ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { p = PushShortPixel ( MSBEndian , p , & pixel ) ; image -> colormap [ i ] . red = ScaleShortToQuantum ( pixel ) ; p = PushShortPixel ( MSBEndian , p , & pixel ) ; image -> colormap [ i ] . green = ScaleShortToQuantum ( pixel ) ; p = PushShortPixel ( MSBEndian , p , & pixel ) ; image -> colormap [ i ] . blue = ScaleShortToQuantum ( pixel ) ; } break ; } case 32 : { unsigned int pixel ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { p = PushLongPixel ( MSBEndian , p , & pixel ) ; image -> colormap [ i ] . red = ScaleLongToQuantum ( pixel ) ; p = PushLongPixel ( MSBEndian , p , & pixel ) ; image -> colormap [ i ] . green = ScaleLongToQuantum ( pixel ) ; p = PushLongPixel ( MSBEndian , p , & pixel ) ; image -> colormap [ i ] . blue = ScaleLongToQuantum ( pixel ) ; } break ; } } colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; } } if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; if ( ( AcquireMagickResource ( WidthResource , image -> columns ) == MagickFalse ) || ( AcquireMagickResource ( HeightResource , image -> rows ) == MagickFalse ) ) ThrowReaderException ( ImageError , ""WidthOrHeightExceedsLimit"" ) ; status = PersistPixelCache ( image , cache_filename , MagickTrue , & offset , exception ) ; if ( status == MagickFalse ) ThrowReaderException ( CacheError , ""UnableToPersistPixelCache"" ) ; do { c = ReadBlobByte ( image ) ; } while ( ( isgraph ( c ) == MagickFalse ) && ( c != EOF ) ) ; if ( c != EOF ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( c != EOF ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }","options ) ; if ( image -> number_meta_channels > MaxPixelChannels ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;"
479,"void impeg2d_dec_pic_data_thread ( dec_state_t * ps_dec ) { WORD32 i4_continue_decode ; WORD32 i4_cur_row , temp ; UWORD32 u4_bits_read ; WORD32 i4_dequeue_job ; IMPEG2D_ERROR_CODES_T e_error ; i4_cur_row = ps_dec -> u2_mb_y + 1 ; i4_continue_decode = 1 ; i4_dequeue_job = 1 ; do { if ( i4_cur_row > ps_dec -> u2_num_vert_mb ) { i4_continue_decode = 0 ; break ; } { if ( ( ps_dec -> i4_num_cores > 1 ) && ( i4_dequeue_job ) ) { job_t s_job ; IV_API_CALL_STATUS_T e_ret ; UWORD8 * pu1_buf ; e_ret = impeg2_jobq_dequeue ( ps_dec -> pv_jobq , & s_job , sizeof ( s_job ) , 1 , 1 ) ; if ( e_ret != IV_SUCCESS ) break ; if ( CMD_PROCESS == s_job . i4_cmd ) { pu1_buf = ps_dec -> pu1_inp_bits_buf + s_job . i4_bistream_ofst ; impeg2d_bit_stream_init ( & ( ps_dec -> s_bit_stream ) , pu1_buf , ( ps_dec -> u4_num_inp_bytes - s_job . i4_bistream_ofst ) + 8 ) ; i4_cur_row = s_job . i2_start_mb_y ; ps_dec -> i4_start_mb_y = s_job . i2_start_mb_y ; ps_dec -> i4_end_mb_y = s_job . i2_end_mb_y ; ps_dec -> u2_mb_x = 0 ; ps_dec -> u2_mb_y = ps_dec -> i4_start_mb_y ; ps_dec -> u2_num_mbs_left = ( ps_dec -> i4_end_mb_y - ps_dec -> i4_start_mb_y ) * ps_dec -> u2_num_horiz_mb ; } else { WORD32 start_row ; WORD32 num_rows ; start_row = s_job . i2_start_mb_y << 4 ; num_rows = MIN ( ( s_job . i2_end_mb_y << 4 ) , ps_dec -> u2_vertical_size ) ; num_rows -= start_row ; impeg2d_format_convert ( ps_dec , ps_dec -> ps_disp_pic , ps_dec -> ps_disp_frm_buf , start_row , num_rows ) ; break ; } } e_error = impeg2d_dec_slice ( ps_dec ) ; if ( ( IMPEG2D_ERROR_CODES_T ) IVD_ERROR_NONE != e_error ) { impeg2d_next_start_code ( ps_dec ) ; } } while ( 1 ) { u4_bits_read = impeg2d_bit_stream_nxt ( & ps_dec -> s_bit_stream , START_CODE_LEN ) ; temp = u4_bits_read & 0xFF ; i4_continue_decode = ( ( ( u4_bits_read >> 8 ) == 0x01 ) && ( temp ) && ( temp <= 0xAF ) ) ; <S2SV_StartBug> if ( i4_continue_decode ) <S2SV_EndBug> { if ( ( temp - 1 ) == i4_cur_row ) { i4_dequeue_job = 0 ; break ; } if ( temp < ps_dec -> i4_end_mb_y ) { i4_cur_row = ps_dec -> u2_mb_y ; } else { i4_dequeue_job = 1 ; } break ; } else break ; } } while ( i4_continue_decode ) ; if ( ps_dec -> i4_num_cores > 1 ) { while ( 1 ) { job_t s_job ; IV_API_CALL_STATUS_T e_ret ; e_ret = impeg2_jobq_dequeue ( ps_dec -> pv_jobq , & s_job , sizeof ( s_job ) , 1 , 1 ) ; if ( e_ret != IV_SUCCESS ) break ; if ( CMD_FMTCONV == s_job . i4_cmd ) { WORD32 start_row ; WORD32 num_rows ; start_row = s_job . i2_start_mb_y << 4 ; num_rows = MIN ( ( s_job . i2_end_mb_y << 4 ) , ps_dec -> u2_vertical_size ) ; num_rows -= start_row ; impeg2d_format_convert ( ps_dec , ps_dec -> ps_disp_pic , ps_dec -> ps_disp_frm_buf , start_row , num_rows ) ; } } } else { if ( ( NULL != ps_dec -> ps_disp_pic ) && ( ( 0 == ps_dec -> u4_share_disp_buf ) || ( IV_YUV_420P != ps_dec -> i4_chromaFormat ) ) ) impeg2d_format_convert ( ps_dec , ps_dec -> ps_disp_pic , ps_dec -> ps_disp_frm_buf , 0 , ps_dec -> u2_vertical_size ) ; } }","; if ( 1 == ps_dec -> i4_num_cores && 0 == ps_dec -> u2_num_mbs_left ) { i4_continue_decode = 0 ; android_errorWriteLog ( 0x534e4554 , ""26070014"" ) ; } if ("
480,"static int udf_readdir ( struct file * file , struct dir_context * ctx ) { struct inode * dir = file_inode ( file ) ; struct udf_inode_info * iinfo = UDF_I ( dir ) ; struct udf_fileident_bh fibh = { . sbh = NULL , . ebh = NULL } ; struct fileIdentDesc * fi = NULL ; struct fileIdentDesc cfi ; int block , iblock ; loff_t nf_pos ; int flen ; unsigned char * fname = NULL ; unsigned char * nameptr ; uint16_t liu ; uint8_t lfi ; loff_t size = udf_ext0_offset ( dir ) + dir -> i_size ; struct buffer_head * tmp , * bha [ 16 ] ; struct kernel_lb_addr eloc ; uint32_t elen ; sector_t offset ; int i , num , ret = 0 ; struct extent_position epos = { NULL , 0 , { 0 , 0 } } ; if ( ctx -> pos == 0 ) { if ( ! dir_emit_dot ( file , ctx ) ) return 0 ; ctx -> pos = 1 ; } nf_pos = ( ctx -> pos - 1 ) << 2 ; if ( nf_pos >= size ) goto out ; fname = kmalloc ( UDF_NAME_LEN , GFP_NOFS ) ; if ( ! fname ) { ret = - ENOMEM ; goto out ; } if ( nf_pos == 0 ) nf_pos = udf_ext0_offset ( dir ) ; fibh . soffset = fibh . eoffset = nf_pos & ( dir -> i_sb -> s_blocksize - 1 ) ; if ( iinfo -> i_alloc_type != ICBTAG_FLAG_AD_IN_ICB ) { if ( inode_bmap ( dir , nf_pos >> dir -> i_sb -> s_blocksize_bits , & epos , & eloc , & elen , & offset ) != ( EXT_RECORDED_ALLOCATED >> 30 ) ) { ret = - ENOENT ; goto out ; } block = udf_get_lb_pblock ( dir -> i_sb , & eloc , offset ) ; if ( ( ++ offset << dir -> i_sb -> s_blocksize_bits ) < elen ) { if ( iinfo -> i_alloc_type == ICBTAG_FLAG_AD_SHORT ) epos . offset -= sizeof ( struct short_ad ) ; else if ( iinfo -> i_alloc_type == ICBTAG_FLAG_AD_LONG ) epos . offset -= sizeof ( struct long_ad ) ; } else { offset = 0 ; } if ( ! ( fibh . sbh = fibh . ebh = udf_tread ( dir -> i_sb , block ) ) ) { ret = - EIO ; goto out ; } if ( ! ( offset & ( ( 16 >> ( dir -> i_sb -> s_blocksize_bits - 9 ) ) - 1 ) ) ) { i = 16 >> ( dir -> i_sb -> s_blocksize_bits - 9 ) ; if ( i + offset > ( elen >> dir -> i_sb -> s_blocksize_bits ) ) i = ( elen >> dir -> i_sb -> s_blocksize_bits ) - offset ; for ( num = 0 ; i > 0 ; i -- ) { block = udf_get_lb_pblock ( dir -> i_sb , & eloc , offset + i ) ; tmp = udf_tgetblk ( dir -> i_sb , block ) ; if ( tmp && ! buffer_uptodate ( tmp ) && ! buffer_locked ( tmp ) ) bha [ num ++ ] = tmp ; else brelse ( tmp ) ; } if ( num ) { ll_rw_block ( READA , num , bha ) ; for ( i = 0 ; i < num ; i ++ ) brelse ( bha [ i ] ) ; } } } while ( nf_pos < size ) { struct kernel_lb_addr tloc ; ctx -> pos = ( nf_pos >> 2 ) + 1 ; fi = udf_fileident_read ( dir , & nf_pos , & fibh , & cfi , & epos , & eloc , & elen , & offset ) ; if ( ! fi ) goto out ; liu = le16_to_cpu ( cfi . lengthOfImpUse ) ; lfi = cfi . lengthFileIdent ; if ( fibh . sbh == fibh . ebh ) { nameptr = fi -> fileIdent + liu ; } else { int poffset ; poffset = fibh . soffset + sizeof ( struct fileIdentDesc ) + liu + lfi ; if ( poffset >= lfi ) { nameptr = ( char * ) ( fibh . ebh -> b_data + poffset - lfi ) ; } else { nameptr = fname ; memcpy ( nameptr , fi -> fileIdent + liu , lfi - poffset ) ; memcpy ( nameptr + lfi - poffset , fibh . ebh -> b_data , poffset ) ; } } if ( ( cfi . fileCharacteristics & FID_FILE_CHAR_DELETED ) != 0 ) { if ( ! UDF_QUERY_FLAG ( dir -> i_sb , UDF_FLAG_UNDELETE ) ) continue ; } if ( ( cfi . fileCharacteristics & FID_FILE_CHAR_HIDDEN ) != 0 ) { if ( ! UDF_QUERY_FLAG ( dir -> i_sb , UDF_FLAG_UNHIDE ) ) continue ; } if ( cfi . fileCharacteristics & FID_FILE_CHAR_PARENT ) { if ( ! dir_emit_dotdot ( file , ctx ) ) goto out ; continue ; } <S2SV_StartBug> flen = udf_get_filename ( dir -> i_sb , nameptr , fname , lfi ) ; <S2SV_EndBug> if ( ! flen ) continue ; tloc = lelb_to_cpu ( cfi . icb . extLocation ) ; iblock = udf_get_lb_pblock ( dir -> i_sb , & tloc , 0 ) ; if ( ! dir_emit ( ctx , fname , flen , iblock , DT_UNKNOWN ) ) goto out ; } ctx -> pos = ( nf_pos >> 2 ) + 1 ; out : if ( fibh . sbh != fibh . ebh ) brelse ( fibh . ebh ) ; brelse ( fibh . sbh ) ; brelse ( epos . bh ) ; kfree ( fname ) ; return ret ; }",", nameptr , lfi , fname , UDF_NAME_LEN <S2SV_ModEnd> ) ; if"
481,"<S2SV_StartBug> static void xen_netbk_idx_release ( struct xen_netbk * netbk , u16 pending_idx ) <S2SV_EndBug> { struct xenvif * vif ; struct pending_tx_info * pending_tx_info ; pending_ring_idx_t index ; if ( netbk -> mmap_pages [ pending_idx ] == NULL ) return ; pending_tx_info = & netbk -> pending_tx_info [ pending_idx ] ; vif = pending_tx_info -> vif ; <S2SV_StartBug> make_tx_response ( vif , & pending_tx_info -> req , XEN_NETIF_RSP_OKAY ) ; <S2SV_EndBug> index = pending_index ( netbk -> pending_prod ++ ) ; netbk -> pending_ring [ index ] = pending_idx ; xenvif_put ( vif ) ; netbk -> mmap_pages [ pending_idx ] -> mapping = 0 ; put_page ( netbk -> mmap_pages [ pending_idx ] ) ; netbk -> mmap_pages [ pending_idx ] = NULL ; }",", u16 pending_idx , u8 status <S2SV_ModStart> -> req , status <S2SV_ModEnd> ) ; index"
482,"void bandwidth_pid ( pid_t pid , const char * command , const char * dev , int down , int up ) { EUID_ASSERT ( ) ; EUID_ROOT ( ) ; char * comm = pid_proc_comm ( pid ) ; EUID_USER ( ) ; if ( ! comm ) { fprintf ( stderr , ""Error:<S2SV_blank>cannot<S2SV_blank>find<S2SV_blank>sandbox\\n"" ) ; exit ( 1 ) ; } if ( strcmp ( comm , ""firejail"" ) != 0 ) { fprintf ( stderr , ""Error:<S2SV_blank>cannot<S2SV_blank>find<S2SV_blank>sandbox\\n"" ) ; exit ( 1 ) ; } free ( comm ) ; char * name ; if ( asprintf ( & name , ""/run/firejail/network/%d-netmap"" , pid ) == - 1 ) errExit ( ""asprintf"" ) ; struct stat s ; if ( stat ( name , & s ) == - 1 ) { fprintf ( stderr , ""Error:<S2SV_blank>the<S2SV_blank>sandbox<S2SV_blank>doesn\'t<S2SV_blank>use<S2SV_blank>a<S2SV_blank>new<S2SV_blank>network<S2SV_blank>namespace\\n"" ) ; exit ( 1 ) ; } pid_t child ; if ( find_child ( pid , & child ) == - 1 ) { fprintf ( stderr , ""Error:<S2SV_blank>cannot<S2SV_blank>join<S2SV_blank>the<S2SV_blank>network<S2SV_blank>namespace\\n"" ) ; exit ( 1 ) ; } EUID_ROOT ( ) ; if ( join_namespace ( child , ""net"" ) ) { fprintf ( stderr , ""Error:<S2SV_blank>cannot<S2SV_blank>join<S2SV_blank>the<S2SV_blank>network<S2SV_blank>namespace\\n"" ) ; exit ( 1 ) ; } if ( strcmp ( command , ""set"" ) == 0 ) bandwidth_set ( pid , dev , down , up ) ; else if ( strcmp ( command , ""clear"" ) == 0 ) bandwidth_remove ( pid , dev ) ; char * devname = NULL ; if ( dev ) { char * fname ; if ( asprintf ( & fname , ""%s/%d-netmap"" , RUN_FIREJAIL_NETWORK_DIR , ( int ) pid ) == - 1 ) errExit ( ""asprintf"" ) ; FILE * fp = fopen ( fname , ""r"" ) ; if ( ! fp ) { fprintf ( stderr , ""Error:<S2SV_blank>cannot<S2SV_blank>read<S2SV_blank>network<S2SV_blank>map<S2SV_blank>file<S2SV_blank>%s\\n"" , fname ) ; exit ( 1 ) ; } char buf [ 1024 ] ; int len = strlen ( dev ) ; while ( fgets ( buf , 1024 , fp ) ) { char * ptr = strchr ( buf , '\\n' ) ; if ( ptr ) * ptr = '\\0' ; if ( * buf == '\\0' ) break ; if ( strncmp ( buf , dev , len ) == 0 && buf [ len ] == ':' ) { devname = strdup ( buf + len + 1 ) ; if ( ! devname ) errExit ( ""strdup"" ) ; if ( if_nametoindex ( devname ) == 0 ) { fprintf ( stderr , ""Error:<S2SV_blank>cannot<S2SV_blank>find<S2SV_blank>network<S2SV_blank>device<S2SV_blank>%s\\n"" , devname ) ; exit ( 1 ) ; } break ; } } free ( fname ) ; fclose ( fp ) ; } char * cmd = NULL ; if ( devname ) { if ( strcmp ( command , ""set"" ) == 0 ) { if ( asprintf ( & cmd , ""%s/firejail/fshaper.sh<S2SV_blank>--%s<S2SV_blank>%s<S2SV_blank>%d<S2SV_blank>%d"" , LIBDIR , command , devname , down , up ) == - 1 ) errExit ( ""asprintf"" ) ; } else { if ( asprintf ( & cmd , ""%s/firejail/fshaper.sh<S2SV_blank>--%s<S2SV_blank>%s"" , LIBDIR , command , devname ) == - 1 ) errExit ( ""asprintf"" ) ; } } else { if ( asprintf ( & cmd , ""%s/firejail/fshaper.sh<S2SV_blank>--%s"" , LIBDIR , command ) == - 1 ) errExit ( ""asprintf"" ) ; } assert ( cmd ) ; environ = NULL ; if ( setreuid ( 0 , 0 ) ) errExit ( ""setreuid"" ) ; if ( setregid ( 0 , 0 ) ) errExit ( ""setregid"" ) ; <S2SV_StartBug> if ( ! cfg . shell ) <S2SV_EndBug> cfg . shell = guess_shell ( ) ; if ( ! cfg . shell ) { fprintf ( stderr , ""Error:<S2SV_blank>no<S2SV_blank>POSIX<S2SV_blank>shell<S2SV_blank>found,<S2SV_blank>please<S2SV_blank>use<S2SV_blank>--shell<S2SV_blank>command<S2SV_blank>line<S2SV_blank>option\\n"" ) ; exit ( 1 ) ; } char * arg [ 4 ] ; <S2SV_StartBug> arg [ 0 ] = cfg . shell ; <S2SV_EndBug> arg [ 1 ] = ""-c"" ; arg [ 2 ] = cmd ; arg [ 3 ] = NULL ; clearenv ( ) ; execvp ( arg [ 0 ] , arg ) ; errExit ( ""execvp"" ) ; }","""setregid"" ) ; <S2SV_ModEnd> char * arg <S2SV_ModStart> 0 ] = ""/bin/sh"" <S2SV_ModEnd> ; arg ["
483,"<S2SV_StartBug> int64_t vp9_rd_pick_inter_mode_sb ( VP9_COMP * cpi , MACROBLOCK * x , <S2SV_EndBug> <S2SV_StartBug> const TileInfo * const tile , <S2SV_EndBug> int mi_row , int mi_col , <S2SV_StartBug> int * returnrate , <S2SV_EndBug> int64_t * returndistortion , BLOCK_SIZE bsize , PICK_MODE_CONTEXT * ctx , int64_t best_rd_so_far ) { VP9_COMMON * const cm = & cpi -> common ; <S2SV_StartBug> MACROBLOCKD * const xd = & x -> e_mbd ; <S2SV_EndBug> <S2SV_StartBug> MB_MODE_INFO * const mbmi = & xd -> mi [ 0 ] -> mbmi ; <S2SV_EndBug> const struct segmentation * const seg = & cm -> seg ; <S2SV_StartBug> MB_PREDICTION_MODE this_mode ; <S2SV_EndBug> MV_REFERENCE_FRAME ref_frame , second_ref_frame ; unsigned char segment_id = mbmi -> segment_id ; <S2SV_StartBug> int comp_pred , i ; <S2SV_EndBug> int_mv frame_mv [ MB_MODE_COUNT ] [ MAX_REF_FRAMES ] ; struct buf_2d yv12_mb [ 4 ] [ MAX_MB_PLANE ] ; <S2SV_StartBug> int_mv single_newmv [ MAX_REF_FRAMES ] = { { 0 } } ; <S2SV_EndBug> static const int flag_list [ 4 ] = { 0 , VP9_LAST_FLAG , VP9_GOLD_FLAG , VP9_ALT_FLAG } ; int64_t best_rd = best_rd_so_far ; <S2SV_StartBug> int64_t best_tx_rd [ TX_MODES ] ; <S2SV_EndBug> int64_t best_tx_diff [ TX_MODES ] ; int64_t best_pred_diff [ REFERENCE_MODES ] ; int64_t best_pred_rd [ REFERENCE_MODES ] ; int64_t best_filter_rd [ SWITCHABLE_FILTER_CONTEXTS ] ; int64_t best_filter_diff [ SWITCHABLE_FILTER_CONTEXTS ] ; <S2SV_StartBug> MB_MODE_INFO best_mbmode = { 0 } ; <S2SV_EndBug> <S2SV_StartBug> int mode_index , best_mode_index = 0 ; <S2SV_EndBug> unsigned int ref_costs_single [ MAX_REF_FRAMES ] , ref_costs_comp [ MAX_REF_FRAMES ] ; <S2SV_StartBug> vp9_prob comp_mode_p ; <S2SV_EndBug> int64_t best_intra_rd = INT64_MAX ; <S2SV_StartBug> int64_t best_inter_rd = INT64_MAX ; <S2SV_EndBug> <S2SV_StartBug> MB_PREDICTION_MODE best_intra_mode = DC_PRED ; <S2SV_EndBug> MV_REFERENCE_FRAME best_inter_ref_frame = LAST_FRAME ; INTERP_FILTER tmp_best_filter = SWITCHABLE ; int rate_uv_intra [ TX_SIZES ] , rate_uv_tokenonly [ TX_SIZES ] ; int64_t dist_uv [ TX_SIZES ] ; int skip_uv [ TX_SIZES ] ; <S2SV_StartBug> MB_PREDICTION_MODE mode_uv [ TX_SIZES ] ; <S2SV_EndBug> <S2SV_StartBug> int64_t mode_distortions [ MB_MODE_COUNT ] = { - 1 } ; <S2SV_EndBug> <S2SV_StartBug> int intra_cost_penalty = 20 * vp9_dc_quant ( cm -> base_qindex , cm -> y_dc_delta_q ) ; <S2SV_EndBug> const int bws = num_8x8_blocks_wide_lookup [ bsize ] / 2 ; const int bhs = num_8x8_blocks_high_lookup [ bsize ] / 2 ; int best_skip2 = 0 ; <S2SV_StartBug> int mode_skip_mask = 0 ; <S2SV_EndBug> <S2SV_StartBug> int mode_skip_start = cpi -> sf . mode_skip_start + 1 ; <S2SV_EndBug> <S2SV_StartBug> const int * const rd_threshes = cpi -> rd_threshes [ segment_id ] [ bsize ] ; <S2SV_EndBug> <S2SV_StartBug> const int * const rd_thresh_freq_fact = cpi -> rd_thresh_freq_fact [ bsize ] ; <S2SV_EndBug> <S2SV_StartBug> const int mode_search_skip_flags = cpi -> sf . mode_search_skip_flags ; <S2SV_EndBug> const int intra_y_mode_mask = cpi -> sf . intra_y_mode_mask [ max_txsize_lookup [ bsize ] ] ; int disable_inter_mode_mask = cpi -> sf . disable_inter_mode_mask [ bsize ] ; x -> skip_encode = cpi -> sf . skip_encode_frame && x -> q_index < QIDX_SKIP_THRESH ; <S2SV_StartBug> estimate_ref_frame_costs ( cpi , segment_id , ref_costs_single , ref_costs_comp , <S2SV_EndBug> & comp_mode_p ) ; for ( i = 0 ; i < REFERENCE_MODES ; ++ i ) best_pred_rd [ i ] = INT64_MAX ; <S2SV_StartBug> for ( i = 0 ; i < TX_MODES ; i ++ ) <S2SV_EndBug> best_tx_rd [ i ] = INT64_MAX ; for ( i = 0 ; i < SWITCHABLE_FILTER_CONTEXTS ; i ++ ) best_filter_rd [ i ] = INT64_MAX ; for ( i = 0 ; i < TX_SIZES ; i ++ ) rate_uv_intra [ i ] = INT_MAX ; for ( i = 0 ; i < MAX_REF_FRAMES ; ++ i ) x -> pred_sse [ i ] = INT_MAX ; <S2SV_StartBug> * returnrate = INT_MAX ; <S2SV_EndBug> for ( ref_frame = LAST_FRAME ; ref_frame <= ALTREF_FRAME ; ++ ref_frame ) { x -> pred_mv_sad [ ref_frame ] = INT_MAX ; if ( cpi -> ref_frame_flags & flag_list [ ref_frame ] ) { <S2SV_StartBug> vp9_setup_buffer_inter ( cpi , x , tile , <S2SV_EndBug> ref_frame , bsize , mi_row , mi_col , frame_mv [ NEARESTMV ] , frame_mv [ NEARMV ] , yv12_mb ) ; } frame_mv [ NEWMV ] [ ref_frame ] . as_int = INVALID_MV ; frame_mv [ ZEROMV ] [ ref_frame ] . as_int = 0 ; } for ( ref_frame = LAST_FRAME ; ref_frame <= ALTREF_FRAME ; ++ ref_frame ) { <S2SV_StartBug> static const int ref_frame_mask_all [ ] = { <S2SV_EndBug> 0x0 , 0x123291 , 0x25c444 , 0x39b722 } ; static const int ref_frame_mask_fixedmv [ ] = { 0x0 , 0x121281 , 0x24c404 , 0x080102 } ; if ( ! ( cpi -> ref_frame_flags & flag_list [ ref_frame ] ) ) { <S2SV_StartBug> mode_skip_mask |= ref_frame_mask_all [ ref_frame ] ; <S2SV_EndBug> <S2SV_StartBug> } else if ( cpi -> sf . reference_masking ) { <S2SV_EndBug> for ( i = LAST_FRAME ; i <= ALTREF_FRAME ; ++ i ) { if ( ( x -> pred_mv_sad [ ref_frame ] >> 2 ) > x -> pred_mv_sad [ i ] ) { <S2SV_StartBug> mode_skip_mask |= ref_frame_mask_fixedmv [ ref_frame ] ; <S2SV_EndBug> break ; } } } <S2SV_StartBug> if ( vp9_segfeature_active ( seg , segment_id , SEG_LVL_REF_FRAME ) && <S2SV_EndBug> <S2SV_StartBug> vp9_get_segdata ( seg , segment_id , SEG_LVL_REF_FRAME ) != ( int ) ref_frame ) { <S2SV_EndBug> <S2SV_StartBug> mode_skip_mask |= ref_frame_mask_all [ ref_frame ] ; <S2SV_EndBug> } } if ( vp9_segfeature_active ( seg , segment_id , SEG_LVL_SKIP ) ) { const int inter_non_zero_mode_mask = 0x1F7F7 ; mode_skip_mask |= inter_non_zero_mode_mask ; } <S2SV_StartBug> if ( ! vp9_segfeature_active ( seg , segment_id , SEG_LVL_REF_FRAME ) ) { <S2SV_EndBug> if ( cpi -> rc . is_src_frame_alt_ref && ( cpi -> oxcf . arnr_max_frames == 0 ) ) { <S2SV_StartBug> const int altref_zero_mask = <S2SV_EndBug> ~ ( ( 1 << THR_NEARESTA ) | ( 1 << THR_NEARA ) | ( 1 << THR_ZEROA ) ) ; mode_skip_mask |= altref_zero_mask ; if ( frame_mv [ NEARMV ] [ ALTREF_FRAME ] . as_int != 0 ) <S2SV_StartBug> mode_skip_mask |= ( 1 << THR_NEARA ) ; <S2SV_EndBug> if ( frame_mv [ NEARESTMV ] [ ALTREF_FRAME ] . as_int != 0 ) <S2SV_StartBug> mode_skip_mask |= ( 1 << THR_NEARESTA ) ; <S2SV_EndBug> } } if ( ( mi_row + bhs ) > cm -> mi_rows || ( mi_col + bws ) > cm -> mi_cols ) { const int new_modes_mask = ( 1 << THR_NEWMV ) | ( 1 << THR_NEWG ) | ( 1 << THR_NEWA ) | ( 1 << THR_COMP_NEWLA ) | ( 1 << THR_COMP_NEWGA ) ; mode_skip_mask |= new_modes_mask ; } <S2SV_StartBug> if ( bsize > cpi -> sf . max_intra_bsize ) { <S2SV_EndBug> <S2SV_StartBug> mode_skip_mask |= 0xFF30808 ; <S2SV_EndBug> } if ( ! x -> in_active_map ) { <S2SV_StartBug> int mode_index ; <S2SV_EndBug> assert ( cpi -> ref_frame_flags & VP9_LAST_FLAG ) ; if ( frame_mv [ NEARESTMV ] [ LAST_FRAME ] . as_int == 0 ) mode_index = THR_NEARESTMV ; else if ( frame_mv [ NEARMV ] [ LAST_FRAME ] . as_int == 0 ) mode_index = THR_NEARMV ; else mode_index = THR_ZEROMV ; mode_skip_mask = ~ ( 1 << mode_index ) ; mode_skip_start = MAX_MODES ; disable_inter_mode_mask = 0 ; } for ( mode_index = 0 ; mode_index < MAX_MODES ; ++ mode_index ) { int mode_excluded = 0 ; int64_t this_rd = INT64_MAX ; int disable_skip = 0 ; int compmode_cost = 0 ; int rate2 = 0 , rate_y = 0 , rate_uv = 0 ; int64_t distortion2 = 0 , distortion_y = 0 , distortion_uv = 0 ; int skippable = 0 ; <S2SV_StartBug> int64_t tx_cache [ TX_MODES ] ; <S2SV_EndBug> int i ; int this_skip2 = 0 ; int64_t total_sse = INT64_MAX ; int early_term = 0 ; <S2SV_StartBug> if ( mode_index == mode_skip_start ) { <S2SV_EndBug> <S2SV_StartBug> switch ( vp9_mode_order [ best_mode_index ] . ref_frame [ 0 ] ) { <S2SV_EndBug> case INTRA_FRAME : break ; case LAST_FRAME : <S2SV_StartBug> mode_skip_mask |= LAST_FRAME_MODE_MASK ; <S2SV_EndBug> break ; case GOLDEN_FRAME : <S2SV_StartBug> mode_skip_mask |= GOLDEN_FRAME_MODE_MASK ; <S2SV_EndBug> break ; case ALTREF_FRAME : <S2SV_StartBug> mode_skip_mask |= ALT_REF_MODE_MASK ; <S2SV_EndBug> break ; case NONE : case MAX_REF_FRAMES : assert ( 0 && ""Invalid<S2SV_blank>Reference<S2SV_blank>frame"" ) ; <S2SV_StartBug> } <S2SV_EndBug> } <S2SV_StartBug> if ( mode_skip_mask & ( 1 << mode_index ) ) <S2SV_EndBug> continue ; <S2SV_StartBug> if ( best_rd < ( ( int64_t ) rd_threshes [ mode_index ] * <S2SV_EndBug> rd_thresh_freq_fact [ mode_index ] >> 5 ) || rd_threshes [ mode_index ] == INT_MAX ) continue ; <S2SV_StartBug> this_mode = vp9_mode_order [ mode_index ] . mode ; <S2SV_EndBug> ref_frame = vp9_mode_order [ mode_index ] . ref_frame [ 0 ] ; if ( ref_frame != INTRA_FRAME && disable_inter_mode_mask & ( 1 << INTER_OFFSET ( this_mode ) ) ) continue ; second_ref_frame = vp9_mode_order [ mode_index ] . ref_frame [ 1 ] ; comp_pred = second_ref_frame > INTRA_FRAME ; if ( comp_pred ) { <S2SV_StartBug> if ( ( mode_search_skip_flags & FLAG_SKIP_COMP_BESTINTRA ) && <S2SV_EndBug> <S2SV_StartBug> vp9_mode_order [ best_mode_index ] . ref_frame [ 0 ] == INTRA_FRAME ) <S2SV_EndBug> continue ; if ( ( mode_search_skip_flags & FLAG_SKIP_COMP_REFMISMATCH ) && ref_frame != best_inter_ref_frame && second_ref_frame != best_inter_ref_frame ) continue ; mode_excluded = cm -> reference_mode == SINGLE_REFERENCE ; } else { if ( ref_frame != INTRA_FRAME ) mode_excluded = cm -> reference_mode == COMPOUND_REFERENCE ; } if ( ref_frame == INTRA_FRAME ) { <S2SV_StartBug> if ( ! ( intra_y_mode_mask & ( 1 << this_mode ) ) ) <S2SV_EndBug> continue ; if ( this_mode != DC_PRED ) { const unsigned int skip_intra_var_thresh = 64 ; if ( ( mode_search_skip_flags & FLAG_SKIP_INTRA_LOWVAR ) && x -> source_variance < skip_intra_var_thresh ) continue ; if ( ( mode_search_skip_flags & FLAG_SKIP_INTRA_BESTINTER ) && ( this_mode >= D45_PRED && this_mode <= TM_PRED ) ) { <S2SV_StartBug> if ( vp9_mode_order [ best_mode_index ] . ref_frame [ 0 ] > INTRA_FRAME ) <S2SV_EndBug> continue ; } if ( mode_search_skip_flags & FLAG_SKIP_INTRA_DIRMISMATCH ) { if ( conditional_skipintra ( this_mode , best_intra_mode ) ) continue ; } } } else { <S2SV_StartBug> if ( x -> in_active_map && <S2SV_EndBug> ! vp9_segfeature_active ( & cm -> seg , mbmi -> segment_id , SEG_LVL_SKIP ) ) <S2SV_StartBug> if ( ! check_best_zero_mv ( cpi , mbmi -> mode_context , frame_mv , <S2SV_EndBug> disable_inter_mode_mask , this_mode , ref_frame , second_ref_frame ) ) continue ; } mbmi -> mode = this_mode ; mbmi -> uv_mode = x -> in_active_map ? DC_PRED : this_mode ; mbmi -> ref_frame [ 0 ] = ref_frame ; mbmi -> ref_frame [ 1 ] = second_ref_frame ; mbmi -> interp_filter = cm -> interp_filter == SWITCHABLE ? EIGHTTAP : cm -> interp_filter ; <S2SV_StartBug> x -> skip = 0 ; <S2SV_EndBug> set_ref_ptrs ( cm , xd , ref_frame , second_ref_frame ) ; for ( i = 0 ; i < MAX_MB_PLANE ; i ++ ) { xd -> plane [ i ] . pre [ 0 ] = yv12_mb [ ref_frame ] [ i ] ; if ( comp_pred ) xd -> plane [ i ] . pre [ 1 ] = yv12_mb [ second_ref_frame ] [ i ] ; } <S2SV_StartBug> for ( i = 0 ; i < TX_MODES ; ++ i ) <S2SV_EndBug> tx_cache [ i ] = INT64_MAX ; # ifdef MODE_TEST_HIT_STATS cpi -> mode_test_hits [ bsize ] ++ ; # endif if ( ref_frame == INTRA_FRAME ) { TX_SIZE uv_tx ; <S2SV_StartBug> intra_super_block_yrd ( cpi , x , & rate_y , & distortion_y , & skippable , NULL , <S2SV_EndBug> <S2SV_StartBug> bsize , tx_cache , best_rd ) ; <S2SV_EndBug> if ( rate_y == INT_MAX ) continue ; <S2SV_StartBug> uv_tx = get_uv_tx_size_impl ( mbmi -> tx_size , bsize ) ; <S2SV_EndBug> if ( rate_uv_intra [ uv_tx ] == INT_MAX ) { <S2SV_StartBug> choose_intra_uv_mode ( cpi , ctx , bsize , uv_tx , <S2SV_EndBug> & rate_uv_intra [ uv_tx ] , & rate_uv_tokenonly [ uv_tx ] , & dist_uv [ uv_tx ] , & skip_uv [ uv_tx ] , & mode_uv [ uv_tx ] ) ; } rate_uv = rate_uv_tokenonly [ uv_tx ] ; distortion_uv = dist_uv [ uv_tx ] ; skippable = skippable && skip_uv [ uv_tx ] ; mbmi -> uv_mode = mode_uv [ uv_tx ] ; <S2SV_StartBug> rate2 = rate_y + x -> mbmode_cost [ mbmi -> mode ] + rate_uv_intra [ uv_tx ] ; <S2SV_EndBug> if ( this_mode != DC_PRED && this_mode != TM_PRED ) rate2 += intra_cost_penalty ; distortion2 = distortion_y + distortion_uv ; } else { <S2SV_StartBug> this_rd = handle_inter_mode ( cpi , x , tile , bsize , <S2SV_EndBug> tx_cache , & rate2 , & distortion2 , & skippable , <S2SV_StartBug> & rate_y , & distortion_y , <S2SV_EndBug> & rate_uv , & distortion_uv , & mode_excluded , & disable_skip , <S2SV_StartBug> & tmp_best_filter , frame_mv , <S2SV_EndBug> mi_row , mi_col , <S2SV_StartBug> single_newmv , & total_sse , best_rd ) ; <S2SV_EndBug> if ( this_rd == INT64_MAX ) continue ; compmode_cost = vp9_cost_bit ( comp_mode_p , comp_pred ) ; if ( cm -> reference_mode == REFERENCE_MODE_SELECT ) rate2 += compmode_cost ; } if ( comp_pred ) { rate2 += ref_costs_comp [ ref_frame ] ; } else { rate2 += ref_costs_single [ ref_frame ] ; } if ( ! disable_skip ) { <S2SV_StartBug> const int mb_skip_allowed = ! vp9_segfeature_active ( seg , segment_id , <S2SV_EndBug> SEG_LVL_SKIP ) ; if ( skippable ) { rate2 -= ( rate_y + rate_uv ) ; <S2SV_StartBug> rate_uv = 0 ; <S2SV_EndBug> if ( mb_skip_allowed ) { int prob_skip_cost ; vp9_prob skip_prob = vp9_get_skip_prob ( cm , xd ) ; if ( skip_prob ) { prob_skip_cost = vp9_cost_bit ( skip_prob , 1 ) ; rate2 += prob_skip_cost ; } } <S2SV_StartBug> } else if ( mb_skip_allowed && ref_frame != INTRA_FRAME && ! xd -> lossless ) { <S2SV_EndBug> if ( RDCOST ( x -> rdmult , x -> rddiv , rate_y + rate_uv , distortion2 ) < RDCOST ( x -> rdmult , x -> rddiv , 0 , total_sse ) ) { rate2 += vp9_cost_bit ( vp9_get_skip_prob ( cm , xd ) , 0 ) ; } else { rate2 += vp9_cost_bit ( vp9_get_skip_prob ( cm , xd ) , 1 ) ; distortion2 = total_sse ; assert ( total_sse >= 0 ) ; rate2 -= ( rate_y + rate_uv ) ; <S2SV_StartBug> rate_y = 0 ; <S2SV_EndBug> rate_uv = 0 ; this_skip2 = 1 ; } <S2SV_StartBug> } else if ( mb_skip_allowed ) { <S2SV_EndBug> rate2 += vp9_cost_bit ( vp9_get_skip_prob ( cm , xd ) , 0 ) ; } this_rd = RDCOST ( x -> rdmult , x -> rddiv , rate2 , distortion2 ) ; } <S2SV_StartBug> if ( ref_frame == INTRA_FRAME ) { <S2SV_EndBug> if ( this_rd < best_intra_rd ) { best_intra_rd = this_rd ; best_intra_mode = mbmi -> mode ; } <S2SV_StartBug> } else { <S2SV_EndBug> if ( ! comp_pred && ! mode_excluded && this_rd < best_inter_rd ) { best_inter_rd = this_rd ; best_inter_ref_frame = ref_frame ; } } if ( ! disable_skip && ref_frame == INTRA_FRAME ) { for ( i = 0 ; i < REFERENCE_MODES ; ++ i ) best_pred_rd [ i ] = MIN ( best_pred_rd [ i ] , this_rd ) ; for ( i = 0 ; i < SWITCHABLE_FILTER_CONTEXTS ; i ++ ) <S2SV_StartBug> best_filter_rd [ i ] = MIN ( best_filter_rd [ i ] , this_rd ) ; <S2SV_EndBug> } if ( mode_distortions [ this_mode ] == - 1 || distortion2 < mode_distortions [ this_mode ] ) { mode_distortions [ this_mode ] = distortion2 ; } if ( this_rd < best_rd || x -> skip ) { int max_plane = MAX_MB_PLANE ; if ( ! mode_excluded ) { best_mode_index = mode_index ; if ( ref_frame == INTRA_FRAME ) { mbmi -> mv [ 0 ] . as_int = 0 ; max_plane = 1 ; } <S2SV_StartBug> * returnrate = rate2 ; <S2SV_EndBug> <S2SV_StartBug> * returndistortion = distortion2 ; <S2SV_EndBug> best_rd = this_rd ; best_mbmode = * mbmi ; best_skip2 = this_skip2 ; <S2SV_StartBug> if ( ! x -> select_txfm_size ) <S2SV_EndBug> <S2SV_StartBug> swap_block_ptr ( x , ctx , max_plane ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( ctx -> zcoeff_blk , x -> zcoeff_blk [ mbmi -> tx_size ] , <S2SV_EndBug> <S2SV_StartBug> sizeof ( uint8_t ) * ctx -> num_4x4_blk ) ; <S2SV_EndBug> if ( ( mode_search_skip_flags & FLAG_EARLY_TERMINATE ) && ( mode_index > MIN_EARLY_TERM_INDEX ) ) { <S2SV_StartBug> const int qstep = xd -> plane [ 0 ] . dequant [ 1 ] ; <S2SV_EndBug> <S2SV_StartBug> int scale = 4 ; <S2SV_EndBug> if ( x -> source_variance < UINT_MAX ) { const int var_adjust = ( x -> source_variance < 16 ) ; scale -= var_adjust ; } if ( ref_frame > INTRA_FRAME && distortion2 * scale < qstep * qstep ) { early_term = 1 ; } } } } if ( ! disable_skip && ref_frame != INTRA_FRAME ) { int64_t single_rd , hybrid_rd , single_rate , hybrid_rate ; if ( cm -> reference_mode == REFERENCE_MODE_SELECT ) { single_rate = rate2 - compmode_cost ; hybrid_rate = rate2 ; } else { single_rate = rate2 ; hybrid_rate = rate2 + compmode_cost ; } single_rd = RDCOST ( x -> rdmult , x -> rddiv , single_rate , distortion2 ) ; hybrid_rd = RDCOST ( x -> rdmult , x -> rddiv , hybrid_rate , distortion2 ) ; if ( ! comp_pred ) { <S2SV_StartBug> if ( single_rd < best_pred_rd [ SINGLE_REFERENCE ] ) { <S2SV_EndBug> best_pred_rd [ SINGLE_REFERENCE ] = single_rd ; <S2SV_StartBug> } <S2SV_EndBug> } else { <S2SV_StartBug> if ( single_rd < best_pred_rd [ COMPOUND_REFERENCE ] ) { <S2SV_EndBug> best_pred_rd [ COMPOUND_REFERENCE ] = single_rd ; <S2SV_StartBug> } <S2SV_EndBug> } if ( hybrid_rd < best_pred_rd [ REFERENCE_MODE_SELECT ] ) best_pred_rd [ REFERENCE_MODE_SELECT ] = hybrid_rd ; if ( ! mode_excluded && cm -> interp_filter != BILINEAR ) { <S2SV_StartBug> int64_t ref = cpi -> rd_filter_cache [ cm -> interp_filter == SWITCHABLE ? <S2SV_EndBug> SWITCHABLE_FILTERS : cm -> interp_filter ] ; for ( i = 0 ; i < SWITCHABLE_FILTER_CONTEXTS ; i ++ ) { int64_t adj_rd ; if ( ref == INT64_MAX ) adj_rd = 0 ; <S2SV_StartBug> else if ( cpi -> rd_filter_cache [ i ] == INT64_MAX ) <S2SV_EndBug> <S2SV_StartBug> adj_rd = cpi -> mask_filter_rd - ref + 10 ; <S2SV_EndBug> else <S2SV_StartBug> adj_rd = cpi -> rd_filter_cache [ i ] - ref ; <S2SV_EndBug> adj_rd += this_rd ; best_filter_rd [ i ] = MIN ( best_filter_rd [ i ] , adj_rd ) ; } <S2SV_StartBug> } <S2SV_EndBug> } if ( bsize < BLOCK_32X32 ) { if ( bsize < BLOCK_16X16 ) tx_cache [ ALLOW_16X16 ] = tx_cache [ ALLOW_8X8 ] ; tx_cache [ ALLOW_32X32 ] = tx_cache [ ALLOW_16X16 ] ; } if ( ! mode_excluded && this_rd != INT64_MAX ) { for ( i = 0 ; i < TX_MODES && tx_cache [ i ] < INT64_MAX ; i ++ ) { int64_t adj_rd = INT64_MAX ; adj_rd = this_rd + tx_cache [ i ] - tx_cache [ cm -> tx_mode ] ; if ( adj_rd < best_tx_rd [ i ] ) best_tx_rd [ i ] = adj_rd ; } } if ( early_term ) break ; if ( x -> skip && ! comp_pred ) break ; } <S2SV_StartBug> if ( best_rd >= best_rd_so_far ) <S2SV_EndBug> return INT64_MAX ; if ( cpi -> sf . use_uv_intra_rd_estimate ) { <S2SV_StartBug> if ( vp9_mode_order [ best_mode_index ] . ref_frame [ 0 ] == INTRA_FRAME ) { <S2SV_EndBug> TX_SIZE uv_tx_size ; * mbmi = best_mbmode ; <S2SV_StartBug> uv_tx_size = get_uv_tx_size ( mbmi ) ; <S2SV_EndBug> rd_pick_intra_sbuv_mode ( cpi , x , ctx , & rate_uv_intra [ uv_tx_size ] , & rate_uv_tokenonly [ uv_tx_size ] , & dist_uv [ uv_tx_size ] , & skip_uv [ uv_tx_size ] , bsize < BLOCK_8X8 ? BLOCK_8X8 : bsize , uv_tx_size ) ; } } assert ( ( cm -> interp_filter == SWITCHABLE ) || ( cm -> interp_filter == best_mbmode . interp_filter ) || ! is_inter_block ( & best_mbmode ) ) ; <S2SV_StartBug> if ( cpi -> sf . adaptive_rd_thresh ) { <S2SV_EndBug> for ( mode_index = 0 ; mode_index < MAX_MODES ; ++ mode_index ) { int * const fact = & cpi -> rd_thresh_freq_fact [ bsize ] [ mode_index ] ; if ( mode_index == best_mode_index ) { * fact -= ( * fact >> 3 ) ; } else { * fact = MIN ( * fact + RD_THRESH_INC , cpi -> sf . adaptive_rd_thresh * RD_THRESH_MAX_FACT ) ; } } } * mbmi = best_mbmode ; x -> skip |= best_skip2 ; for ( i = 0 ; i < REFERENCE_MODES ; ++ i ) { if ( best_pred_rd [ i ] == INT64_MAX ) best_pred_diff [ i ] = INT_MIN ; else best_pred_diff [ i ] = best_rd - best_pred_rd [ i ] ; } if ( ! x -> skip ) { for ( i = 0 ; i < SWITCHABLE_FILTER_CONTEXTS ; i ++ ) { if ( best_filter_rd [ i ] == INT64_MAX ) best_filter_diff [ i ] = 0 ; else best_filter_diff [ i ] = best_rd - best_filter_rd [ i ] ; } if ( cm -> interp_filter == SWITCHABLE ) assert ( best_filter_diff [ SWITCHABLE_FILTERS ] == 0 ) ; <S2SV_StartBug> for ( i = 0 ; i < TX_MODES ; i ++ ) { <S2SV_EndBug> if ( best_tx_rd [ i ] == INT64_MAX ) best_tx_diff [ i ] = 0 ; else best_tx_diff [ i ] = best_rd - best_tx_rd [ i ] ; } } else { vp9_zero ( best_filter_diff ) ; vp9_zero ( best_tx_diff ) ; } if ( ! x -> in_active_map ) { assert ( mbmi -> ref_frame [ 0 ] == LAST_FRAME ) ; assert ( mbmi -> ref_frame [ 1 ] == NONE ) ; assert ( mbmi -> mode == NEARESTMV || mbmi -> mode == NEARMV || mbmi -> mode == ZEROMV ) ; assert ( frame_mv [ mbmi -> mode ] [ LAST_FRAME ] . as_int == 0 ) ; assert ( mbmi -> mode == mbmi -> uv_mode ) ; } set_ref_ptrs ( cm , xd , mbmi -> ref_frame [ 0 ] , mbmi -> ref_frame [ 1 ] ) ; store_coding_context ( x , ctx , best_mode_index , & mbmi -> ref_mvs [ mbmi -> ref_frame [ 0 ] ] [ 0 ] , & mbmi -> ref_mvs [ mbmi -> ref_frame [ 1 ] < 0 ? 0 : mbmi -> ref_frame [ 1 ] ] [ 0 ] , best_pred_diff , best_tx_diff , best_filter_diff ) ; return best_rd ; }","<S2SV_null> <S2SV_null> <S2SV_null> void <S2SV_ModEnd> vp9_rd_pick_inter_mode_sb ( VP9_COMP <S2SV_ModStart> * cpi , TileDataEnc * tile_data , <S2SV_ModStart> * x , <S2SV_ModEnd> int mi_row , <S2SV_ModStart> int mi_col , RD_COST * rd_cost , <S2SV_ModEnd> BLOCK_SIZE bsize , <S2SV_ModStart> -> common ; TileInfo * const tile_info = & tile_data -> tile_info ; RD_OPT * const rd_opt = & cpi -> rd ; SPEED_FEATURES * const sf = & cpi -> sf ; <S2SV_ModStart> ] -> mbmi ; MB_MODE_INFO_EXT * const mbmi_ext = x -> mbmi_ext <S2SV_ModStart> -> seg ; PREDICTION_MODE <S2SV_ModEnd> this_mode ; MV_REFERENCE_FRAME <S2SV_ModStart> comp_pred , i , k <S2SV_ModStart> 0 } } ; INTERP_FILTER single_inter_filter [ MB_MODE_COUNT ] [ MAX_REF_FRAMES ] ; int single_skippable [ MB_MODE_COUNT ] [ MAX_REF_FRAMES ] <S2SV_ModStart> best_rd_so_far ; int64_t <S2SV_ModEnd> best_pred_diff [ REFERENCE_MODES <S2SV_ModStart> ; MB_MODE_INFO best_mbmode ; int best_mode_skippable = 0 ; int midx <S2SV_ModEnd> , best_mode_index = <S2SV_ModStart> , best_mode_index = - 1 <S2SV_ModEnd> ; unsigned int <S2SV_ModStart> MAX_REF_FRAMES ] ; vpx_prob <S2SV_ModEnd> comp_mode_p ; int64_t <S2SV_ModStart> = INT64_MAX ; unsigned int best_pred_sse = UINT_MAX ; PREDICTION_MODE <S2SV_ModEnd> best_intra_mode = DC_PRED <S2SV_ModStart> best_intra_mode = DC_PRED <S2SV_ModEnd> ; int rate_uv_intra <S2SV_ModStart> TX_SIZES ] ; PREDICTION_MODE <S2SV_ModEnd> mode_uv [ TX_SIZES <S2SV_ModStart> TX_SIZES ] ; const <S2SV_ModEnd> int intra_cost_penalty = <S2SV_ModStart> int intra_cost_penalty = vp9_get_intra_cost_penalty ( <S2SV_ModEnd> cm -> base_qindex <S2SV_ModStart> cm -> y_dc_delta_q , cm -> bit_depth ) <S2SV_ModEnd> ; int best_skip2 <S2SV_ModStart> = 0 ; uint8_t ref_frame_skip_mask [ 2 ] = { 0 } ; uint16_t mode_skip_mask [ MAX_REF_FRAMES ] = { 0 } <S2SV_ModEnd> ; int mode_skip_start <S2SV_ModStart> int mode_skip_start = sf -> <S2SV_ModEnd> mode_skip_start + 1 <S2SV_ModStart> const rd_threshes = rd_opt -> threshes <S2SV_ModEnd> [ segment_id ] <S2SV_ModStart> const rd_thresh_freq_fact = tile_data -> thresh_freq_fact [ bsize ] ; int64_t mode_threshold [ MAX_MODES ] ; int * mode_map = tile_data -> mode_map <S2SV_ModEnd> [ bsize ] <S2SV_ModStart> int mode_search_skip_flags = sf -> mode_search_skip_flags ; int64_t mask_filter = 0 ; int64_t filter_cache [ SWITCHABLE_FILTER_CONTEXTS ] ; vp9_zero ( best_mbmode ) ; x -> skip_encode = sf -> <S2SV_ModEnd> skip_encode_frame && x <S2SV_ModStart> < QIDX_SKIP_THRESH ; for ( i = 0 ; i < SWITCHABLE_FILTER_CONTEXTS ; ++ i ) filter_cache [ i ] = INT64_MAX ; estimate_ref_frame_costs ( cm , xd <S2SV_ModEnd> , segment_id , <S2SV_ModStart> ; i < <S2SV_ModEnd> SWITCHABLE_FILTER_CONTEXTS ; i <S2SV_ModStart> = INT_MAX ; for ( i = 0 ; i < MB_MODE_COUNT ; ++ i ) { for ( k = 0 ; k < MAX_REF_FRAMES ; ++ k ) { single_inter_filter [ i ] [ k ] = SWITCHABLE ; single_skippable [ i ] [ k ] = 0 ; } } rd_cost -> rate <S2SV_ModEnd> = INT_MAX ; <S2SV_ModStart> ] ) { assert ( get_ref_frame_buffer <S2SV_ModEnd> ( cpi , <S2SV_ModStart> ( cpi , ref_frame ) != NULL ) ; setup_buffer_inter ( cpi , x , <S2SV_ModEnd> ref_frame , bsize <S2SV_ModStart> ref_frame ) { <S2SV_ModEnd> if ( ! <S2SV_ModStart> ) ) { ref_frame_skip_mask [ 0 ] |= ( 1 << ref_frame ) ; ref_frame_skip_mask [ 1 ] |= SECOND_REF_FRAME_MASK <S2SV_ModEnd> ; } else <S2SV_ModStart> else if ( sf -> <S2SV_ModEnd> reference_masking ) { <S2SV_ModStart> ) { mode_skip_mask [ ref_frame ] |= INTER_NEAREST_NEAR_ZERO <S2SV_ModEnd> ; break ; <S2SV_ModStart> } if ( segfeature_active <S2SV_ModEnd> ( seg , <S2SV_ModStart> SEG_LVL_REF_FRAME ) && get_segdata <S2SV_ModEnd> ( seg , <S2SV_ModStart> ref_frame ) { ref_frame_skip_mask [ 0 ] |= ( 1 << ref_frame ) ; ref_frame_skip_mask [ 1 ] |= SECOND_REF_FRAME_MASK ; } <S2SV_ModEnd> } if ( <S2SV_ModStart> if ( ! segfeature_active <S2SV_ModEnd> ( seg , <S2SV_ModStart> ) ) { ref_frame_skip_mask [ 0 ] = ( 1 << LAST_FRAME ) | ( 1 << GOLDEN_FRAME ) ; ref_frame_skip_mask [ 1 ] = SECOND_REF_FRAME_MASK ; mode_skip_mask [ ALTREF_FRAME ] = ~ INTER_NEAREST_NEAR_ZERO <S2SV_ModEnd> ; if ( <S2SV_ModStart> 0 ) mode_skip_mask [ ALTREF_FRAME ] <S2SV_ModStart> ( 1 << NEARMV <S2SV_ModEnd> ) ; if <S2SV_ModStart> 0 ) mode_skip_mask [ ALTREF_FRAME ] <S2SV_ModStart> ( 1 << NEARESTMV ) ; } } if ( cpi -> rc . is_src_frame_alt_ref ) { if ( sf -> alt_ref_search_fp ) { mode_skip_mask [ ALTREF_FRAME ] = 0 ; ref_frame_skip_mask [ 0 ] = ~ ( 1 << ALTREF_FRAME ) ; ref_frame_skip_mask [ 1 ] = SECOND_REF_FRAME_MASK ; } } if ( sf -> alt_ref_search_fp ) if ( ! cm -> show_frame && x -> pred_mv_sad [ GOLDEN_FRAME ] < INT_MAX ) if ( x -> pred_mv_sad [ ALTREF_FRAME ] > ( x -> pred_mv_sad [ GOLDEN_FRAME ] << 1 ) ) mode_skip_mask [ ALTREF_FRAME ] |= INTER_ALL ; if ( sf -> adaptive_mode_search ) { if ( cm -> show_frame && ! cpi -> rc . is_src_frame_alt_ref && cpi -> rc . frames_since_golden >= 3 ) if ( x -> pred_mv_sad [ GOLDEN_FRAME ] > ( x -> pred_mv_sad [ LAST_FRAME ] << 1 ) ) mode_skip_mask [ GOLDEN_FRAME ] |= INTER_ALL <S2SV_ModEnd> ; } if <S2SV_ModStart> ( bsize > sf -> <S2SV_ModEnd> max_intra_bsize ) { <S2SV_ModStart> max_intra_bsize ) { ref_frame_skip_mask [ 0 ] |= ( 1 << INTRA_FRAME ) ; ref_frame_skip_mask [ 1 ] |= ( 1 << INTRA_FRAME ) ; } mode_skip_mask [ INTRA_FRAME ] |= ~ ( sf -> intra_y_mode_mask [ max_txsize_lookup [ bsize ] ] ) ; for ( i = 0 ; i <= LAST_NEW_MV_INDEX ; ++ i ) mode_threshold [ i ] = 0 ; for ( i = LAST_NEW_MV_INDEX + 1 ; i < MAX_MODES ; ++ i ) mode_threshold [ i ] = ( ( int64_t ) rd_threshes [ i ] * rd_thresh_freq_fact [ i ] ) >> 5 ; midx = sf -> schedule_mode_search ? mode_skip_start : 0 ; while ( midx > 4 ) { uint8_t end_pos = 0 ; for ( i = 5 ; i < midx ; ++ i ) { if ( mode_threshold [ mode_map [ i - 1 ] ] > mode_threshold [ mode_map [ i ] ] ) { uint8_t tmp = mode_map [ i ] ; mode_map [ i ] = mode_map [ i - 1 ] ; mode_map [ i - 1 ] = tmp ; end_pos = i ; } } midx = end_pos ; } for ( midx = 0 ; midx < MAX_MODES ; ++ midx <S2SV_ModEnd> ) { int <S2SV_ModStart> { int mode_index = mode_map [ midx ] ; <S2SV_ModEnd> int mode_excluded = <S2SV_ModStart> = 0 ; <S2SV_ModEnd> int this_skip2 = <S2SV_ModStart> = 0 ; this_mode = vp9_mode_order [ mode_index ] . mode ; ref_frame = vp9_mode_order [ mode_index ] . ref_frame [ 0 ] ; second_ref_frame = vp9_mode_order [ mode_index ] . ref_frame [ 1 ] ; if ( midx == mode_skip_start && best_mode_index >= 0 <S2SV_ModEnd> ) { switch <S2SV_ModStart> { switch ( best_mbmode <S2SV_ModEnd> . ref_frame [ <S2SV_ModStart> case LAST_FRAME : ref_frame_skip_mask [ 0 ] |= LAST_FRAME_MODE_MASK ; ref_frame_skip_mask [ 1 ] |= SECOND_REF_FRAME_MASK <S2SV_ModEnd> ; break ; <S2SV_ModStart> case GOLDEN_FRAME : ref_frame_skip_mask [ 0 ] |= GOLDEN_FRAME_MODE_MASK ; ref_frame_skip_mask [ 1 ] |= SECOND_REF_FRAME_MASK <S2SV_ModEnd> ; break ; <S2SV_ModStart> case ALTREF_FRAME : ref_frame_skip_mask [ 0 ] <S2SV_ModEnd> |= ALT_REF_MODE_MASK ; <S2SV_ModStart> ""Invalid<S2SV_blank>Reference<S2SV_blank>frame"" ) ; break ; } } if ( ( ref_frame_skip_mask [ 0 ] & ( 1 << ref_frame ) ) && ( ref_frame_skip_mask [ 1 ] & ( 1 << MAX ( 0 , second_ref_frame ) ) ) ) continue ; <S2SV_ModEnd> if ( mode_skip_mask <S2SV_ModStart> if ( mode_skip_mask [ ref_frame ] <S2SV_ModStart> ( 1 << this_mode ) ) continue ; if ( best_mode_skippable && sf -> schedule_mode_search ) mode_threshold [ mode_index ] <<= 1 <S2SV_ModEnd> ; if ( <S2SV_ModStart> ( best_rd < mode_threshold <S2SV_ModEnd> [ mode_index ] <S2SV_ModStart> [ mode_index ] ) continue ; if ( sf -> motion_field_mode_search ) { const int mi_width = MIN ( num_8x8_blocks_wide_lookup [ bsize ] , tile_info -> mi_col_end - mi_col ) ; const int mi_height = MIN ( num_8x8_blocks_high_lookup [ bsize ] , tile_info -> mi_row_end - mi_row ) ; const int bsl = mi_width_log2_lookup [ bsize ] ; int cb_partition_search_ctrl = ( ( ( mi_row + mi_col ) >> bsl ) + get_chessboard_index ( cm -> current_video_frame ) ) & 0x1 ; MB_MODE_INFO * ref_mbmi ; int const_motion = 1 ; int skip_ref_frame = ! cb_partition_search_ctrl ; MV_REFERENCE_FRAME rf = NONE ; int_mv ref_mv ; ref_mv . as_int = INVALID_MV ; if ( ( mi_row - 1 ) >= tile_info -> mi_row_start ) { ref_mv = xd -> mi [ - xd -> mi_stride ] -> mbmi . mv [ 0 ] ; rf = xd -> mi [ - xd -> mi_stride ] -> mbmi . ref_frame [ 0 ] ; for ( i = 0 ; i < mi_width ; ++ i ) { ref_mbmi = & xd -> mi [ - xd -> mi_stride + i ] -> mbmi ; const_motion &= ( ref_mv . as_int == ref_mbmi -> mv [ 0 ] . as_int ) && ( ref_frame == ref_mbmi -> ref_frame [ 0 ] ) ; skip_ref_frame &= ( rf == ref_mbmi -> ref_frame [ 0 ] ) ; } } if ( ( mi_col - 1 ) >= tile_info -> mi_col_start ) { if ( ref_mv . as_int == INVALID_MV ) ref_mv = xd -> mi [ - 1 ] -> mbmi . mv [ 0 ] ; if ( rf == NONE ) rf = xd -> mi [ - 1 ] -> mbmi . ref_frame [ 0 ] ; for ( i = 0 ; i < mi_height ; ++ i ) { ref_mbmi = & xd -> mi [ i * xd -> mi_stride - 1 ] -> mbmi ; const_motion &= ( ref_mv . as_int == ref_mbmi -> mv [ 0 ] . as_int ) && ( ref_frame == ref_mbmi -> ref_frame [ 0 ] ) ; skip_ref_frame &= ( rf == ref_mbmi -> ref_frame [ 0 ] ) ; } } if ( skip_ref_frame && this_mode != NEARESTMV && this_mode != NEWMV ) if ( rf > INTRA_FRAME ) if ( ref_frame != rf ) continue ; if ( const_motion ) if ( this_mode == NEARMV || this_mode == ZEROMV <S2SV_ModEnd> ) continue ; <S2SV_ModStart> ) continue ; } <S2SV_ModEnd> comp_pred = second_ref_frame <S2SV_ModStart> { if ( ! cpi -> allow_comp_inter_inter ) continue ; if ( ! ( cpi -> ref_frame_flags & flag_list [ second_ref_frame ] ) ) continue ; if ( segfeature_active ( seg , segment_id , SEG_LVL_REF_FRAME ) ) continue ; if ( <S2SV_ModStart> FLAG_SKIP_COMP_BESTINTRA ) && best_mode_index >= 0 && best_mbmode <S2SV_ModEnd> . ref_frame [ <S2SV_ModStart> ] == INTRA_FRAME <S2SV_ModEnd> ) continue ; <S2SV_ModStart> { if ( sf -> adaptive_mode_search ) if ( ( x -> source_variance << num_pels_log2_lookup [ bsize ] ) > best_pred_sse <S2SV_ModEnd> ) continue ; <S2SV_ModStart> { if ( best_mode_index >= 0 && best_mbmode <S2SV_ModEnd> . ref_frame [ <S2SV_ModStart> } else { const MV_REFERENCE_FRAME ref_frames [ 2 ] = { ref_frame , second_ref_frame } ; <S2SV_ModEnd> if ( ! <S2SV_ModStart> ( cpi , mbmi_ext -> mode_context , frame_mv , this_mode , ref_frames ) ) continue ; } mbmi -> mode = this_mode ; mbmi -> uv_mode = DC_PRED <S2SV_ModEnd> ; mbmi -> <S2SV_ModStart> -> interp_filter ; mbmi -> mv [ 0 ] . as_int = mbmi -> mv [ 1 ] . as_int = 0 ; <S2SV_ModStart> ] ; } <S2SV_ModEnd> if ( ref_frame <S2SV_ModStart> TX_SIZE uv_tx ; struct macroblockd_plane * const pd = & xd -> plane [ 1 ] ; memset ( x -> skip_txfm , 0 , sizeof ( x -> skip_txfm ) ) ; super_block_yrd <S2SV_ModEnd> ( cpi , <S2SV_ModStart> NULL , bsize <S2SV_ModEnd> , best_rd ) <S2SV_ModStart> tx_size , bsize , pd -> subsampling_x , pd -> subsampling_y <S2SV_ModStart> choose_intra_uv_mode ( cpi , x <S2SV_ModStart> = rate_y + cpi <S2SV_ModEnd> -> mbmode_cost [ <S2SV_ModStart> , x , bsize <S2SV_ModEnd> , & rate2 <S2SV_ModStart> rate_y , & rate_uv , <S2SV_ModEnd> & disable_skip , <S2SV_ModStart> & disable_skip , <S2SV_ModEnd> frame_mv , mi_row <S2SV_ModStart> mi_col , single_newmv , single_inter_filter , single_skippable <S2SV_ModStart> total_sse , best_rd , & mask_filter , filter_cache <S2SV_ModStart> disable_skip ) { <S2SV_ModEnd> if ( skippable <S2SV_ModStart> rate_uv ) ; rate2 += vp9_cost_bit ( vp9_get_skip_prob ( cm , xd ) , 1 ) ; <S2SV_ModEnd> } else if <S2SV_ModStart> else if ( <S2SV_ModEnd> ref_frame != INTRA_FRAME <S2SV_ModStart> rate_uv ) ; <S2SV_ModEnd> this_skip2 = 1 <S2SV_ModStart> } } else <S2SV_ModEnd> { rate2 += <S2SV_ModStart> ) ; } rd_variance_adjustment ( cpi , x , bsize , & this_rd , ref_frame , x -> source_variance ) ; <S2SV_ModStart> ; } } <S2SV_ModEnd> if ( ! <S2SV_ModStart> , this_rd ) <S2SV_ModEnd> ; } if <S2SV_ModStart> 1 ; } else { best_pred_sse = x -> pred_sse [ ref_frame ] ; } rd_cost -> rate <S2SV_ModEnd> = rate2 ; <S2SV_ModStart> = rate2 ; rd_cost -> dist = distortion2 ; rd_cost -> rdcost = this_rd <S2SV_ModEnd> ; best_rd = <S2SV_ModStart> = this_skip2 ; best_mode_skippable = skippable ; <S2SV_ModStart> ! x -> select_tx_size <S2SV_ModEnd> ) swap_block_ptr ( <S2SV_ModStart> , ctx , 1 , 0 , 0 , <S2SV_ModStart> max_plane ) ; memcpy <S2SV_ModEnd> ( ctx -> <S2SV_ModStart> , sizeof ( ctx -> zcoeff_blk [ 0 ] <S2SV_ModEnd> ) * ctx <S2SV_ModStart> ) ) { <S2SV_ModEnd> int qstep = <S2SV_ModStart> = 4 ; # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { qstep >>= ( xd -> bd - 8 ) ; } # endif <S2SV_ModStart> SINGLE_REFERENCE ] ) <S2SV_ModEnd> best_pred_rd [ SINGLE_REFERENCE <S2SV_ModStart> = single_rd ; <S2SV_ModEnd> } else { <S2SV_ModStart> COMPOUND_REFERENCE ] ) <S2SV_ModEnd> best_pred_rd [ COMPOUND_REFERENCE <S2SV_ModStart> = single_rd ; <S2SV_ModEnd> } if ( <S2SV_ModStart> int64_t ref = filter_cache <S2SV_ModEnd> [ cm -> <S2SV_ModStart> else if ( filter_cache <S2SV_ModEnd> [ i ] <S2SV_ModStart> ) adj_rd = mask_filter <S2SV_ModEnd> - ref + <S2SV_ModStart> else adj_rd = filter_cache <S2SV_ModEnd> [ i ] <S2SV_ModStart> ) ; } <S2SV_ModEnd> } } if <S2SV_ModStart> } if ( best_mbmode . mode == NEWMV ) { const MV_REFERENCE_FRAME refs [ 2 ] = { best_mbmode . ref_frame [ 0 ] , best_mbmode . ref_frame [ 1 ] } ; int comp_pred_mode = refs [ 1 ] > INTRA_FRAME ; if ( frame_mv [ NEARESTMV ] [ refs [ 0 ] ] . as_int == best_mbmode . mv [ 0 ] . as_int && ( ( comp_pred_mode && frame_mv [ NEARESTMV ] [ refs [ 1 ] ] . as_int == best_mbmode . mv [ 1 ] . as_int ) || ! comp_pred_mode ) ) best_mbmode . mode = NEARESTMV ; else if ( frame_mv [ NEARMV ] [ refs [ 0 ] ] . as_int == best_mbmode . mv [ 0 ] . as_int && ( ( comp_pred_mode && frame_mv [ NEARMV ] [ refs [ 1 ] ] . as_int == best_mbmode . mv [ 1 ] . as_int ) || ! comp_pred_mode ) ) best_mbmode . mode = NEARMV ; else if ( best_mbmode . mv [ 0 ] . as_int == 0 && ( ( comp_pred_mode && best_mbmode . mv [ 1 ] . as_int == 0 ) || ! comp_pred_mode ) ) best_mbmode . mode = ZEROMV ; } if ( best_mode_index < 0 || <S2SV_ModStart> >= best_rd_so_far ) { rd_cost -> rate = INT_MAX ; rd_cost -> rdcost = INT64_MAX ; return ; } if ( sf -> <S2SV_ModEnd> use_uv_intra_rd_estimate ) { <S2SV_ModStart> { if ( best_mbmode <S2SV_ModEnd> . ref_frame [ <S2SV_ModStart> get_uv_tx_size ( mbmi , & xd -> plane [ 1 ] <S2SV_ModStart> ; if ( ! cpi -> rc . is_src_frame_alt_ref ) vp9_update_rd_thresh_fact ( tile_data -> thresh_freq_fact , sf -> adaptive_rd_thresh , bsize , best_mode_index ) ; <S2SV_ModEnd> * mbmi = <S2SV_ModStart> 0 ) ; } else { vp9_zero ( best_filter_diff ) ; } x -> skip |= best_mode_skippable ; if ( ! x -> skip && ! x -> select_tx_size ) { int has_high_freq_coeff = 0 ; int plane ; int max_plane = is_inter_block ( & xd -> mi [ 0 ] -> mbmi ) ? MAX_MB_PLANE : 1 ; for ( plane = 0 ; plane < max_plane ; ++ plane ) { x -> plane [ plane ] . eobs = ctx -> eobs_pbuf [ plane ] [ 1 ] ; has_high_freq_coeff |= vp9_has_high_freq_in_plane ( x , bsize , plane ) ; } for ( plane = max_plane ; plane < MAX_MB_PLANE ; ++ plane ) { x -> plane [ plane ] . eobs = ctx -> eobs_pbuf [ plane ] [ 2 ] ; has_high_freq_coeff |= vp9_has_high_freq_in_plane ( x , bsize , plane ) ; } best_mode_skippable |= ! has_high_freq_coeff ; } assert ( best_mode_index >= 0 ) ; store_coding_context ( x , ctx , best_mode_index , best_pred_diff , best_filter_diff , best_mode_skippable ) <S2SV_ModEnd> ; } <S2SV_null>"
484,"static GsfInfileTar * tar_directory_for_file ( GsfInfileTar * dir , const char * name , gboolean last ) { const char * s = name ; while ( 1 ) { const char * s0 = s ; char * dirname ; while ( 1 ) { if ( * s == 0 ) { if ( last && s != s0 ) break ; else return dir ; } if ( * s == '/' ) break ; s ++ ; } dirname = g_strndup ( s0 , s - s0 ) ; while ( * s == '/' ) s ++ ; if ( strcmp ( dirname , ""."" ) != 0 ) { GsfInput * subdir = gsf_infile_child_by_name ( GSF_INFILE ( dir ) , dirname ) ; if ( subdir ) { <S2SV_StartBug> g_object_unref ( subdir ) ; <S2SV_EndBug> <S2SV_StartBug> dir = GSF_INFILE_TAR ( subdir ) ; <S2SV_EndBug> } else dir = tar_create_dir ( dir , dirname ) ; } g_free ( dirname ) ; } }",subdir ) { dir = GSF_IS_INFILE_TAR ( subdir ) ? GSF_INFILE_TAR ( subdir ) : dir ; <S2SV_ModStart> subdir ) ; <S2SV_ModEnd> } else dir
485,"struct parsed_tag * parse_tag ( char * * s , int internal ) { struct parsed_tag * tag = NULL ; int tag_id ; char tagname [ MAX_TAG_LEN ] , attrname [ MAX_TAG_LEN ] ; char * p , * q ; <S2SV_StartBug> int i , attr_id = 0 , nattr ; <S2SV_EndBug> q = ( * s ) + 1 ; p = tagname ; if ( * q == '/' ) { * ( p ++ ) = * ( q ++ ) ; SKIP_BLANKS ( q ) ; } while ( * q && ! IS_SPACE ( * q ) && ! ( tagname [ 0 ] != '/' && * q == '/' ) && * q != '>' && p - tagname < MAX_TAG_LEN - 1 ) { * ( p ++ ) = TOLOWER ( * q ) ; q ++ ; } * p = '\\0' ; while ( * q && ! IS_SPACE ( * q ) && ! ( tagname [ 0 ] != '/' && * q == '/' ) && * q != '>' ) q ++ ; tag_id = getHash_si ( & tagtable , tagname , HTML_UNKNOWN ) ; if ( tag_id == HTML_UNKNOWN || ( ! internal && TagMAP [ tag_id ] . flag & TFLG_INT ) ) goto skip_parse_tagarg ; tag = New ( struct parsed_tag ) ; bzero ( tag , sizeof ( struct parsed_tag ) ) ; tag -> tagid = tag_id ; if ( ( nattr = TagMAP [ tag_id ] . max_attribute ) > 0 ) { tag -> attrid = NewAtom_N ( unsigned char , nattr ) ; tag -> value = New_N ( char * , nattr ) ; tag -> map = NewAtom_N ( unsigned char , MAX_TAGATTR ) ; memset ( tag -> map , MAX_TAGATTR , MAX_TAGATTR ) ; memset ( tag -> attrid , ATTR_UNKNOWN , nattr ) ; for ( i = 0 ; i < nattr ; i ++ ) tag -> map [ TagMAP [ tag_id ] . accept_attribute [ i ] ] = i ; } SKIP_BLANKS ( q ) ; while ( 1 ) { Str value = NULL , value_tmp = NULL ; if ( * q == '>' || * q == '\\0' ) goto done_parse_tag ; p = attrname ; while ( * q && * q != '=' && ! IS_SPACE ( * q ) && * q != '>' && p - attrname < MAX_TAG_LEN - 1 ) { * ( p ++ ) = TOLOWER ( * q ) ; q ++ ; } * p = '\\0' ; while ( * q && * q != '=' && ! IS_SPACE ( * q ) && * q != '>' ) q ++ ; SKIP_BLANKS ( q ) ; if ( * q == '=' ) { value_tmp = Strnew ( ) ; q ++ ; SKIP_BLANKS ( q ) ; if ( * q == \'""\' ) { q ++ ; while ( * q && * q != \'""\' ) { Strcat_char ( value_tmp , * q ) ; if ( ! tag -> need_reconstruct && is_html_quote ( * q ) ) tag -> need_reconstruct = TRUE ; q ++ ; } if ( * q == \'""\' ) q ++ ; } else if ( * q == '\\'' ) { q ++ ; while ( * q && * q != '\\'' ) { Strcat_char ( value_tmp , * q ) ; if ( ! tag -> need_reconstruct && is_html_quote ( * q ) ) tag -> need_reconstruct = TRUE ; q ++ ; } if ( * q == '\\'' ) q ++ ; } else if ( * q ) { while ( * q && ! IS_SPACE ( * q ) && * q != '>' ) { Strcat_char ( value_tmp , * q ) ; if ( ! tag -> need_reconstruct && is_html_quote ( * q ) ) tag -> need_reconstruct = TRUE ; q ++ ; } } } for ( i = 0 ; i < nattr ; i ++ ) { if ( ( tag ) -> attrid [ i ] == ATTR_UNKNOWN && strcmp ( AttrMAP [ TagMAP [ tag_id ] . accept_attribute [ i ] ] . name , attrname ) == 0 ) { attr_id = TagMAP [ tag_id ] . accept_attribute [ i ] ; break ; } } if ( value_tmp ) { int j , hidden = FALSE ; for ( j = 0 ; j < i ; j ++ ) { if ( tag -> attrid [ j ] == ATTR_TYPE && tag -> value [ j ] && strcmp ( ""hidden"" , tag -> value [ j ] ) == 0 ) { hidden = TRUE ; break ; } } if ( ( tag_id == HTML_INPUT || tag_id == HTML_INPUT_ALT ) && attr_id == ATTR_VALUE && hidden ) { value = value_tmp ; } else { char * x ; value = Strnew ( ) ; for ( x = value_tmp -> ptr ; * x ; x ++ ) { if ( * x != '\\n' ) Strcat_char ( value , * x ) ; } } } if ( i != nattr ) { if ( ! internal && ( ( AttrMAP [ attr_id ] . flag & AFLG_INT ) || ( value && AttrMAP [ attr_id ] . vtype == VTYPE_METHOD && ! strcasecmp ( value -> ptr , ""internal"" ) ) ) ) { tag -> need_reconstruct = TRUE ; continue ; } tag -> attrid [ i ] = attr_id ; if ( value ) tag -> value [ i ] = html_unquote ( value -> ptr ) ; else tag -> value [ i ] = NULL ; } else { tag -> need_reconstruct = TRUE ; } } skip_parse_tagarg : while ( * q != '>' && * q ) q ++ ; done_parse_tag : if ( * q == '>' ) q ++ ; * s = q ; return tag ; }","0 , nattr ; tagname [ 0 ] = '\\0'"
486,"static inline void schedule_debug ( struct task_struct * prev ) { # ifdef CONFIG_SCHED_STACK_END_CHECK <S2SV_StartBug> BUG_ON ( task_stack_end_corrupted ( prev ) ) ; <S2SV_EndBug> # endif if ( unlikely ( in_atomic_preempt_off ( ) ) ) { __schedule_bug ( prev ) ; preempt_count_set ( PREEMPT_DISABLED ) ; } rcu_sleep_check ( ) ; profile_hit ( SCHED_PROFILING , __builtin_return_address ( 0 ) ) ; schedstat_inc ( this_rq ( ) , sched_count ) ; }","# ifdef CONFIG_SCHED_STACK_END_CHECK if <S2SV_ModEnd> ( task_stack_end_corrupted ( <S2SV_ModStart> ( prev ) ) panic ( ""corrupted<S2SV_blank>stack<S2SV_blank>end<S2SV_blank>detected<S2SV_blank>inside<S2SV_blank>scheduler\\n"""
487,"void processRequest ( struct reqelem * req ) { ssize_t n ; unsigned int l , m ; unsigned char buf [ 2048 ] ; const unsigned char * p ; int type ; struct device * d = devlist ; unsigned char rbuf [ 4096 ] ; unsigned char * rp = rbuf + 1 ; unsigned char nrep = 0 ; time_t t ; struct service * newserv = NULL ; struct service * serv ; n = read ( req -> socket , buf , sizeof ( buf ) ) ; if ( n < 0 ) { if ( errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK ) return ; syslog ( LOG_ERR , ""(s=%d)<S2SV_blank>processRequest():<S2SV_blank>read():<S2SV_blank>%m"" , req -> socket ) ; goto error ; } if ( n == 0 ) { syslog ( LOG_INFO , ""(s=%d)<S2SV_blank>request<S2SV_blank>connection<S2SV_blank>closed"" , req -> socket ) ; goto error ; } t = time ( NULL ) ; type = buf [ 0 ] ; p = buf + 1 ; DECODELENGTH_CHECKLIMIT ( l , p , buf + n ) ; if ( p + l > buf + n ) { syslog ( LOG_WARNING , ""bad<S2SV_blank>request<S2SV_blank>(length<S2SV_blank>encoding)"" ) ; goto error ; } if ( l == 0 && type != 3 ) { syslog ( LOG_WARNING , ""bad<S2SV_blank>request<S2SV_blank>(length=0)"" ) ; goto error ; } syslog ( LOG_INFO , ""(s=%d)<S2SV_blank>request<S2SV_blank>type=%d<S2SV_blank>str=\'%.*s\'"" , req -> socket , type , l , p ) ; switch ( type ) { case 1 : case 2 : case 3 : while ( d && ( nrep < 255 ) ) { if ( d -> t < t ) { syslog ( LOG_INFO , ""outdated<S2SV_blank>device"" ) ; } else { if ( d -> headers [ HEADER_LOCATION ] . l + d -> headers [ HEADER_NT ] . l + d -> headers [ HEADER_USN ] . l + 6 + ( rp - rbuf ) >= ( int ) sizeof ( rbuf ) ) break ; if ( ( type == 1 && 0 == memcmp ( d -> headers [ HEADER_NT ] . p , p , l ) ) || ( type == 2 && 0 == memcmp ( d -> headers [ HEADER_USN ] . p , p , l ) ) || ( type == 3 ) ) { m = d -> headers [ HEADER_LOCATION ] . l ; CODELENGTH ( m , rp ) ; memcpy ( rp , d -> headers [ HEADER_LOCATION ] . p , d -> headers [ HEADER_LOCATION ] . l ) ; rp += d -> headers [ HEADER_LOCATION ] . l ; m = d -> headers [ HEADER_NT ] . l ; CODELENGTH ( m , rp ) ; memcpy ( rp , d -> headers [ HEADER_NT ] . p , d -> headers [ HEADER_NT ] . l ) ; rp += d -> headers [ HEADER_NT ] . l ; m = d -> headers [ HEADER_USN ] . l ; CODELENGTH ( m , rp ) ; memcpy ( rp , d -> headers [ HEADER_USN ] . p , d -> headers [ HEADER_USN ] . l ) ; rp += d -> headers [ HEADER_USN ] . l ; nrep ++ ; } } d = d -> next ; } for ( serv = servicelisthead . lh_first ; serv && ( nrep < 255 ) ; serv = serv -> entries . le_next ) { if ( strlen ( serv -> location ) + strlen ( serv -> st ) + strlen ( serv -> usn ) + 6 + ( rp - rbuf ) >= sizeof ( rbuf ) ) break ; if ( ( type == 1 && 0 == strncmp ( serv -> st , ( const char * ) p , l ) ) || ( type == 2 && 0 == strncmp ( serv -> usn , ( const char * ) p , l ) ) || ( type == 3 ) ) { m = strlen ( serv -> location ) ; CODELENGTH ( m , rp ) ; memcpy ( rp , serv -> location , m ) ; rp += m ; m = strlen ( serv -> st ) ; CODELENGTH ( m , rp ) ; memcpy ( rp , serv -> st , m ) ; rp += m ; m = strlen ( serv -> usn ) ; CODELENGTH ( m , rp ) ; memcpy ( rp , serv -> usn , m ) ; rp += m ; nrep ++ ; } } rbuf [ 0 ] = nrep ; syslog ( LOG_DEBUG , ""(s=%d)<S2SV_blank>response<S2SV_blank>:<S2SV_blank>%d<S2SV_blank>device%s"" , req -> socket , nrep , ( nrep > 1 ) ? ""s"" : """" ) ; if ( write ( req -> socket , rbuf , rp - rbuf ) < 0 ) { syslog ( LOG_ERR , ""(s=%d)<S2SV_blank>write:<S2SV_blank>%m"" , req -> socket ) ; goto error ; } break ; case 4 : newserv = malloc ( sizeof ( struct service ) ) ; if ( ! newserv ) { syslog ( LOG_ERR , ""cannot<S2SV_blank>allocate<S2SV_blank>memory"" ) ; goto error ; } <S2SV_StartBug> if ( containsForbiddenChars ( p , l ) ) { <S2SV_EndBug> syslog ( LOG_ERR , ""bad<S2SV_blank>request<S2SV_blank>(st<S2SV_blank>contains<S2SV_blank>forbidden<S2SV_blank>chars)"" ) ; goto error ; } newserv -> st = malloc ( l + 1 ) ; if ( ! newserv -> st ) { syslog ( LOG_ERR , ""cannot<S2SV_blank>allocate<S2SV_blank>memory"" ) ; goto error ; } memcpy ( newserv -> st , p , l ) ; newserv -> st [ l ] = '\\0' ; p += l ; if ( p >= buf + n ) { syslog ( LOG_WARNING , ""bad<S2SV_blank>request<S2SV_blank>(missing<S2SV_blank>usn)"" ) ; goto error ; } DECODELENGTH_CHECKLIMIT ( l , p , buf + n ) ; if ( p + l > buf + n ) { syslog ( LOG_WARNING , ""bad<S2SV_blank>request<S2SV_blank>(length<S2SV_blank>encoding)"" ) ; goto error ; } if ( containsForbiddenChars ( p , l ) ) { syslog ( LOG_ERR , ""bad<S2SV_blank>request<S2SV_blank>(usn<S2SV_blank>contains<S2SV_blank>forbidden<S2SV_blank>chars)"" ) ; goto error ; } syslog ( LOG_INFO , ""usn=\'%.*s\'"" , l , p ) ; newserv -> usn = malloc ( l + 1 ) ; if ( ! newserv -> usn ) { syslog ( LOG_ERR , ""cannot<S2SV_blank>allocate<S2SV_blank>memory"" ) ; goto error ; } memcpy ( newserv -> usn , p , l ) ; newserv -> usn [ l ] = '\\0' ; p += l ; DECODELENGTH_CHECKLIMIT ( l , p , buf + n ) ; if ( p + l > buf + n ) { syslog ( LOG_WARNING , ""bad<S2SV_blank>request<S2SV_blank>(length<S2SV_blank>encoding)"" ) ; goto error ; } if ( containsForbiddenChars ( p , l ) ) { syslog ( LOG_ERR , ""bad<S2SV_blank>request<S2SV_blank>(server<S2SV_blank>contains<S2SV_blank>forbidden<S2SV_blank>chars)"" ) ; goto error ; } syslog ( LOG_INFO , ""server=\'%.*s\'"" , l , p ) ; newserv -> server = malloc ( l + 1 ) ; if ( ! newserv -> server ) { syslog ( LOG_ERR , ""cannot<S2SV_blank>allocate<S2SV_blank>memory"" ) ; goto error ; } memcpy ( newserv -> server , p , l ) ; newserv -> server [ l ] = '\\0' ; p += l ; DECODELENGTH_CHECKLIMIT ( l , p , buf + n ) ; if ( p + l > buf + n ) { syslog ( LOG_WARNING , ""bad<S2SV_blank>request<S2SV_blank>(length<S2SV_blank>encoding)"" ) ; goto error ; } if ( containsForbiddenChars ( p , l ) ) { syslog ( LOG_ERR , ""bad<S2SV_blank>request<S2SV_blank>(location<S2SV_blank>contains<S2SV_blank>forbidden<S2SV_blank>chars)"" ) ; goto error ; } syslog ( LOG_INFO , ""location=\'%.*s\'"" , l , p ) ; newserv -> location = malloc ( l + 1 ) ; if ( ! newserv -> location ) { syslog ( LOG_ERR , ""cannot<S2SV_blank>allocate<S2SV_blank>memory"" ) ; goto error ; } memcpy ( newserv -> location , p , l ) ; newserv -> location [ l ] = '\\0' ; for ( serv = servicelisthead . lh_first ; serv ; serv = serv -> entries . le_next ) { if ( 0 == strcmp ( newserv -> usn , serv -> usn ) && 0 == strcmp ( newserv -> st , serv -> st ) ) { syslog ( LOG_INFO , ""Service<S2SV_blank>allready<S2SV_blank>in<S2SV_blank>the<S2SV_blank>list.<S2SV_blank>Updating..."" ) ; free ( newserv -> st ) ; free ( newserv -> usn ) ; free ( serv -> server ) ; serv -> server = newserv -> server ; free ( serv -> location ) ; serv -> location = newserv -> location ; free ( newserv ) ; newserv = NULL ; return ; } } LIST_INSERT_HEAD ( & servicelisthead , newserv , entries ) ; newserv = NULL ; break ; default : syslog ( LOG_WARNING , ""Unknown<S2SV_blank>request<S2SV_blank>type<S2SV_blank>%d"" , type ) ; rbuf [ 0 ] = '\\0' ; if ( write ( req -> socket , rbuf , 1 ) < 0 ) { syslog ( LOG_ERR , ""(s=%d)<S2SV_blank>write:<S2SV_blank>%m"" , req -> socket ) ; goto error ; } } return ; error : if ( newserv ) { free ( newserv -> st ) ; free ( newserv -> usn ) ; free ( newserv -> server ) ; free ( newserv -> location ) ; free ( newserv ) ; newserv = NULL ; } close ( req -> socket ) ; req -> socket = - 1 ; return ; }","error ; } memset ( newserv , 0 , sizeof ( struct service ) ) ;"
488,"static void scsi_write_data ( SCSIRequest * req ) { SCSIDiskReq * r = DO_UPCAST ( SCSIDiskReq , req , req ) ; SCSIDiskState * s = DO_UPCAST ( SCSIDiskState , qdev , r -> req . dev ) ; uint32_t n ; assert ( r -> req . aiocb == NULL ) ; if ( r -> req . cmd . mode != SCSI_XFER_TO_DEV ) { DPRINTF ( ""Data<S2SV_blank>transfer<S2SV_blank>direction<S2SV_blank>invalid\\n"" ) ; scsi_write_complete ( r , - EINVAL ) ; return ; } <S2SV_StartBug> n = r -> iov . iov_len / 512 ; <S2SV_EndBug> if ( n ) { if ( s -> tray_open ) { scsi_write_complete ( r , - ENOMEDIUM ) ; } <S2SV_StartBug> qemu_iovec_init_external ( & r -> qiov , & r -> iov , 1 ) ; <S2SV_EndBug> bdrv_acct_start ( s -> bs , & r -> acct , n * BDRV_SECTOR_SIZE , BDRV_ACCT_WRITE ) ; r -> req . aiocb = bdrv_aio_writev ( s -> bs , r -> sector , & r -> qiov , n , scsi_write_complete , r ) ; if ( r -> req . aiocb == NULL ) { scsi_write_complete ( r , - ENOMEM ) ; } } else { scsi_write_complete ( r , 0 ) ; } }",= r -> qiov . size <S2SV_ModEnd> / 512 ; <S2SV_ModStart> ) ; } <S2SV_ModEnd> bdrv_acct_start ( s
489,"static int connection_edge_process_relay_cell ( cell_t * cell , circuit_t * circ , edge_connection_t * conn , crypt_path_t * layer_hint ) { static int num_seen = 0 ; relay_header_t rh ; unsigned domain = layer_hint ? LD_APP : LD_EXIT ; int reason ; int optimistic_data = 0 ; tor_assert ( cell ) ; tor_assert ( circ ) ; relay_header_unpack ( & rh , cell -> payload ) ; num_seen ++ ; log_debug ( domain , ""Now<S2SV_blank>seen<S2SV_blank>%d<S2SV_blank>relay<S2SV_blank>cells<S2SV_blank>here<S2SV_blank>(command<S2SV_blank>%d,<S2SV_blank>stream<S2SV_blank>%d)."" , num_seen , rh . command , rh . stream_id ) ; if ( rh . length > RELAY_PAYLOAD_SIZE ) { log_fn ( LOG_PROTOCOL_WARN , LD_PROTOCOL , ""Relay<S2SV_blank>cell<S2SV_blank>length<S2SV_blank>field<S2SV_blank>too<S2SV_blank>long.<S2SV_blank>Closing<S2SV_blank>circuit."" ) ; return - END_CIRC_REASON_TORPROTOCOL ; } if ( rh . stream_id == 0 ) { switch ( rh . command ) { case RELAY_COMMAND_BEGIN : case RELAY_COMMAND_CONNECTED : case RELAY_COMMAND_DATA : case RELAY_COMMAND_END : case RELAY_COMMAND_RESOLVE : case RELAY_COMMAND_RESOLVED : case RELAY_COMMAND_BEGIN_DIR : log_fn ( LOG_PROTOCOL_WARN , LD_PROTOCOL , ""Relay<S2SV_blank>command<S2SV_blank>%d<S2SV_blank>with<S2SV_blank>zero<S2SV_blank>"" ""stream_id.<S2SV_blank>Dropping."" , ( int ) rh . command ) ; return 0 ; default : ; } } if ( conn && ! connection_state_is_open ( TO_CONN ( conn ) ) ) { if ( conn -> base_ . type == CONN_TYPE_EXIT && ( conn -> base_ . state == EXIT_CONN_STATE_CONNECTING || conn -> base_ . state == EXIT_CONN_STATE_RESOLVING ) && rh . command == RELAY_COMMAND_DATA ) { optimistic_data = 1 ; } else { return connection_edge_process_relay_cell_not_open ( & rh , cell , circ , conn , layer_hint ) ; } } switch ( rh . command ) { case RELAY_COMMAND_DROP : return 0 ; case RELAY_COMMAND_BEGIN : case RELAY_COMMAND_BEGIN_DIR : if ( layer_hint && circ -> purpose != CIRCUIT_PURPOSE_S_REND_JOINED ) { log_fn ( LOG_PROTOCOL_WARN , LD_APP , ""Relay<S2SV_blank>begin<S2SV_blank>request<S2SV_blank>unsupported<S2SV_blank>at<S2SV_blank>AP.<S2SV_blank>Dropping."" ) ; return 0 ; } if ( circ -> purpose == CIRCUIT_PURPOSE_S_REND_JOINED && layer_hint != TO_ORIGIN_CIRCUIT ( circ ) -> cpath -> prev ) { log_fn ( LOG_PROTOCOL_WARN , LD_APP , ""Relay<S2SV_blank>begin<S2SV_blank>request<S2SV_blank>to<S2SV_blank>Hidden<S2SV_blank>Service<S2SV_blank>"" ""from<S2SV_blank>intermediary<S2SV_blank>node.<S2SV_blank>Dropping."" ) ; return 0 ; } if ( conn ) { log_fn ( LOG_PROTOCOL_WARN , domain , ""Begin<S2SV_blank>cell<S2SV_blank>for<S2SV_blank>known<S2SV_blank>stream.<S2SV_blank>Dropping."" ) ; return 0 ; } <S2SV_StartBug> if ( rh . command == RELAY_COMMAND_BEGIN_DIR ) { <S2SV_EndBug> static uint64_t next_id = 0 ; circ -> dirreq_id = ++ next_id ; TO_OR_CIRCUIT ( circ ) -> p_chan -> dirreq_id = circ -> dirreq_id ; } return connection_exit_begin_conn ( cell , circ ) ; case RELAY_COMMAND_DATA : ++ stats_n_data_cells_received ; if ( ( layer_hint && -- layer_hint -> deliver_window < 0 ) || ( ! layer_hint && -- circ -> deliver_window < 0 ) ) { log_fn ( LOG_PROTOCOL_WARN , LD_PROTOCOL , ""(relay<S2SV_blank>data)<S2SV_blank>circ<S2SV_blank>deliver_window<S2SV_blank>below<S2SV_blank>0.<S2SV_blank>Killing."" ) ; if ( conn ) { connection_edge_end ( conn , END_STREAM_REASON_TORPROTOCOL ) ; connection_mark_for_close ( TO_CONN ( conn ) ) ; } return - END_CIRC_REASON_TORPROTOCOL ; } log_debug ( domain , ""circ<S2SV_blank>deliver_window<S2SV_blank>now<S2SV_blank>%d."" , layer_hint ? layer_hint -> deliver_window : circ -> deliver_window ) ; circuit_consider_sending_sendme ( circ , layer_hint ) ; if ( ! conn ) { log_info ( domain , ""data<S2SV_blank>cell<S2SV_blank>dropped,<S2SV_blank>unknown<S2SV_blank>stream<S2SV_blank>(streamid<S2SV_blank>%d)."" , rh . stream_id ) ; return 0 ; } if ( -- conn -> deliver_window < 0 ) { log_fn ( LOG_PROTOCOL_WARN , LD_PROTOCOL , ""(relay<S2SV_blank>data)<S2SV_blank>conn<S2SV_blank>deliver_window<S2SV_blank>below<S2SV_blank>0.<S2SV_blank>Killing."" ) ; return - END_CIRC_REASON_TORPROTOCOL ; } stats_n_data_bytes_received += rh . length ; connection_write_to_buf ( ( char * ) ( cell -> payload + RELAY_HEADER_SIZE ) , rh . length , TO_CONN ( conn ) ) ; if ( ! optimistic_data ) { connection_edge_consider_sending_sendme ( conn ) ; } return 0 ; case RELAY_COMMAND_END : reason = rh . length > 0 ? get_uint8 ( cell -> payload + RELAY_HEADER_SIZE ) : END_STREAM_REASON_MISC ; if ( ! conn ) { log_info ( domain , ""end<S2SV_blank>cell<S2SV_blank>(%s)<S2SV_blank>dropped,<S2SV_blank>unknown<S2SV_blank>stream."" , stream_end_reason_to_string ( reason ) ) ; return 0 ; } log_info ( domain , TOR_SOCKET_T_FORMAT "":<S2SV_blank>end<S2SV_blank>cell<S2SV_blank>(%s)<S2SV_blank>for<S2SV_blank>stream<S2SV_blank>%d.<S2SV_blank>"" ""Removing<S2SV_blank>stream."" , conn -> base_ . s , stream_end_reason_to_string ( reason ) , conn -> stream_id ) ; if ( conn -> base_ . type == CONN_TYPE_AP ) { entry_connection_t * entry_conn = EDGE_TO_ENTRY_CONN ( conn ) ; if ( entry_conn -> socks_request && ! entry_conn -> socks_request -> has_finished ) log_warn ( LD_BUG , ""open<S2SV_blank>stream<S2SV_blank>hasn\'t<S2SV_blank>sent<S2SV_blank>socks<S2SV_blank>answer<S2SV_blank>yet?<S2SV_blank>Closing."" ) ; } conn -> edge_has_sent_end = 1 ; if ( ! conn -> end_reason ) conn -> end_reason = reason | END_STREAM_REASON_FLAG_REMOTE ; if ( ! conn -> base_ . marked_for_close ) { connection_mark_and_flush ( TO_CONN ( conn ) ) ; } return 0 ; case RELAY_COMMAND_EXTEND : case RELAY_COMMAND_EXTEND2 : { static uint64_t total_n_extend = 0 , total_nonearly = 0 ; total_n_extend ++ ; if ( rh . stream_id ) { log_fn ( LOG_PROTOCOL_WARN , domain , ""\'extend\'<S2SV_blank>cell<S2SV_blank>received<S2SV_blank>for<S2SV_blank>non-zero<S2SV_blank>stream.<S2SV_blank>Dropping."" ) ; return 0 ; } if ( cell -> command != CELL_RELAY_EARLY && ! networkstatus_get_param ( NULL , ""AllowNonearlyExtend"" , 0 , 0 , 1 ) ) { # define EARLY_WARNING_INTERVAL 3600 static ratelim_t early_warning_limit = RATELIM_INIT ( EARLY_WARNING_INTERVAL ) ; char * m ; if ( cell -> command == CELL_RELAY ) { ++ total_nonearly ; if ( ( m = rate_limit_log ( & early_warning_limit , approx_time ( ) ) ) ) { double percentage = ( ( double ) total_nonearly ) / total_n_extend ; percentage *= 100 ; log_fn ( LOG_PROTOCOL_WARN , domain , ""EXTEND<S2SV_blank>cell<S2SV_blank>received,<S2SV_blank>"" ""but<S2SV_blank>not<S2SV_blank>via<S2SV_blank>RELAY_EARLY.<S2SV_blank>Dropping.%s"" , m ) ; log_fn ( LOG_PROTOCOL_WARN , domain , ""<S2SV_blank><S2SV_blank>(We<S2SV_blank>have<S2SV_blank>dropped<S2SV_blank>%.02f%%<S2SV_blank>of<S2SV_blank>"" ""all<S2SV_blank>EXTEND<S2SV_blank>cells<S2SV_blank>for<S2SV_blank>this<S2SV_blank>reason)"" , percentage ) ; tor_free ( m ) ; } } else { log_fn ( LOG_WARN , domain , ""EXTEND<S2SV_blank>cell<S2SV_blank>received,<S2SV_blank>in<S2SV_blank>a<S2SV_blank>cell<S2SV_blank>with<S2SV_blank>type<S2SV_blank>%d!<S2SV_blank>Dropping."" , cell -> command ) ; } return 0 ; } return circuit_extend ( cell , circ ) ; } case RELAY_COMMAND_EXTENDED : case RELAY_COMMAND_EXTENDED2 : if ( ! layer_hint ) { log_fn ( LOG_PROTOCOL_WARN , LD_PROTOCOL , ""\'extended\'<S2SV_blank>unsupported<S2SV_blank>at<S2SV_blank>non-origin.<S2SV_blank>Dropping."" ) ; return 0 ; } log_debug ( domain , ""Got<S2SV_blank>an<S2SV_blank>extended<S2SV_blank>cell!<S2SV_blank>Yay."" ) ; { extended_cell_t extended_cell ; if ( extended_cell_parse ( & extended_cell , rh . command , ( const uint8_t * ) cell -> payload + RELAY_HEADER_SIZE , rh . length ) < 0 ) { log_warn ( LD_PROTOCOL , ""Can\'t<S2SV_blank>parse<S2SV_blank>EXTENDED<S2SV_blank>cell;<S2SV_blank>killing<S2SV_blank>circuit."" ) ; return - END_CIRC_REASON_TORPROTOCOL ; } if ( ( reason = circuit_finish_handshake ( TO_ORIGIN_CIRCUIT ( circ ) , & extended_cell . created_cell ) ) < 0 ) { log_warn ( domain , ""circuit_finish_handshake<S2SV_blank>failed."" ) ; return reason ; } } if ( ( reason = circuit_send_next_onion_skin ( TO_ORIGIN_CIRCUIT ( circ ) ) ) < 0 ) { log_info ( domain , ""circuit_send_next_onion_skin()<S2SV_blank>failed."" ) ; return reason ; } return 0 ; case RELAY_COMMAND_TRUNCATE : if ( layer_hint ) { log_fn ( LOG_PROTOCOL_WARN , LD_APP , ""\'truncate\'<S2SV_blank>unsupported<S2SV_blank>at<S2SV_blank>origin.<S2SV_blank>Dropping."" ) ; return 0 ; } if ( circ -> n_hop ) { if ( circ -> n_chan ) log_warn ( LD_BUG , ""n_chan<S2SV_blank>and<S2SV_blank>n_hop<S2SV_blank>set<S2SV_blank>on<S2SV_blank>the<S2SV_blank>same<S2SV_blank>circuit!"" ) ; extend_info_free ( circ -> n_hop ) ; circ -> n_hop = NULL ; tor_free ( circ -> n_chan_create_cell ) ; circuit_set_state ( circ , CIRCUIT_STATE_OPEN ) ; } if ( circ -> n_chan ) { uint8_t trunc_reason = get_uint8 ( cell -> payload + RELAY_HEADER_SIZE ) ; circuit_clear_cell_queue ( circ , circ -> n_chan ) ; channel_send_destroy ( circ -> n_circ_id , circ -> n_chan , trunc_reason ) ; circuit_set_n_circid_chan ( circ , 0 , NULL ) ; } log_debug ( LD_EXIT , ""Processed<S2SV_blank>\'truncate\',<S2SV_blank>replying."" ) ; { char payload [ 1 ] ; payload [ 0 ] = ( char ) END_CIRC_REASON_REQUESTED ; relay_send_command_from_edge ( 0 , circ , RELAY_COMMAND_TRUNCATED , payload , sizeof ( payload ) , NULL ) ; } return 0 ; case RELAY_COMMAND_TRUNCATED : if ( ! layer_hint ) { log_fn ( LOG_PROTOCOL_WARN , LD_EXIT , ""\'truncated\'<S2SV_blank>unsupported<S2SV_blank>at<S2SV_blank>non-origin.<S2SV_blank>Dropping."" ) ; return 0 ; } circuit_truncated ( TO_ORIGIN_CIRCUIT ( circ ) , layer_hint , get_uint8 ( cell -> payload + RELAY_HEADER_SIZE ) ) ; return 0 ; case RELAY_COMMAND_CONNECTED : if ( conn ) { log_fn ( LOG_PROTOCOL_WARN , LD_PROTOCOL , ""\'connected\'<S2SV_blank>unsupported<S2SV_blank>while<S2SV_blank>open.<S2SV_blank>Closing<S2SV_blank>circ."" ) ; return - END_CIRC_REASON_TORPROTOCOL ; } log_info ( domain , ""\'connected\'<S2SV_blank>received,<S2SV_blank>no<S2SV_blank>conn<S2SV_blank>attached<S2SV_blank>anymore.<S2SV_blank>Ignoring."" ) ; return 0 ; case RELAY_COMMAND_SENDME : if ( ! rh . stream_id ) { if ( layer_hint ) { if ( layer_hint -> package_window + CIRCWINDOW_INCREMENT > CIRCWINDOW_START_MAX ) { log_fn ( LOG_PROTOCOL_WARN , LD_PROTOCOL , ""Unexpected<S2SV_blank>sendme<S2SV_blank>cell<S2SV_blank>from<S2SV_blank>exit<S2SV_blank>relay.<S2SV_blank>"" ""Closing<S2SV_blank>circ."" ) ; return - END_CIRC_REASON_TORPROTOCOL ; } layer_hint -> package_window += CIRCWINDOW_INCREMENT ; log_debug ( LD_APP , ""circ-level<S2SV_blank>sendme<S2SV_blank>at<S2SV_blank>origin,<S2SV_blank>packagewindow<S2SV_blank>%d."" , layer_hint -> package_window ) ; circuit_resume_edge_reading ( circ , layer_hint ) ; } else { if ( circ -> package_window + CIRCWINDOW_INCREMENT > CIRCWINDOW_START_MAX ) { log_fn ( LOG_PROTOCOL_WARN , LD_PROTOCOL , ""Unexpected<S2SV_blank>sendme<S2SV_blank>cell<S2SV_blank>from<S2SV_blank>client.<S2SV_blank>"" ""Closing<S2SV_blank>circ<S2SV_blank>(window<S2SV_blank>%d)."" , circ -> package_window ) ; return - END_CIRC_REASON_TORPROTOCOL ; } circ -> package_window += CIRCWINDOW_INCREMENT ; log_debug ( LD_APP , ""circ-level<S2SV_blank>sendme<S2SV_blank>at<S2SV_blank>non-origin,<S2SV_blank>packagewindow<S2SV_blank>%d."" , circ -> package_window ) ; circuit_resume_edge_reading ( circ , layer_hint ) ; } return 0 ; } if ( ! conn ) { log_info ( domain , ""sendme<S2SV_blank>cell<S2SV_blank>dropped,<S2SV_blank>unknown<S2SV_blank>stream<S2SV_blank>(streamid<S2SV_blank>%d)."" , rh . stream_id ) ; return 0 ; } conn -> package_window += STREAMWINDOW_INCREMENT ; log_debug ( domain , ""stream-level<S2SV_blank>sendme,<S2SV_blank>packagewindow<S2SV_blank>now<S2SV_blank>%d."" , conn -> package_window ) ; if ( circuit_queue_streams_are_blocked ( circ ) ) { return 0 ; } connection_start_reading ( TO_CONN ( conn ) ) ; if ( connection_edge_package_raw_inbuf ( conn , 1 , NULL ) < 0 ) { connection_mark_for_close ( TO_CONN ( conn ) ) ; return 0 ; } return 0 ; case RELAY_COMMAND_RESOLVE : if ( layer_hint ) { log_fn ( LOG_PROTOCOL_WARN , LD_APP , ""resolve<S2SV_blank>request<S2SV_blank>unsupported<S2SV_blank>at<S2SV_blank>AP;<S2SV_blank>dropping."" ) ; return 0 ; } else if ( conn ) { log_fn ( LOG_PROTOCOL_WARN , domain , ""resolve<S2SV_blank>request<S2SV_blank>for<S2SV_blank>known<S2SV_blank>stream;<S2SV_blank>dropping."" ) ; return 0 ; } else if ( circ -> purpose != CIRCUIT_PURPOSE_OR ) { log_fn ( LOG_PROTOCOL_WARN , domain , ""resolve<S2SV_blank>request<S2SV_blank>on<S2SV_blank>circ<S2SV_blank>with<S2SV_blank>purpose<S2SV_blank>%d;<S2SV_blank>dropping"" , circ -> purpose ) ; return 0 ; } connection_exit_begin_resolve ( cell , TO_OR_CIRCUIT ( circ ) ) ; return 0 ; case RELAY_COMMAND_RESOLVED : if ( conn ) { log_fn ( LOG_PROTOCOL_WARN , domain , ""\'resolved\'<S2SV_blank>unsupported<S2SV_blank>while<S2SV_blank>open.<S2SV_blank>Closing<S2SV_blank>circ."" ) ; return - END_CIRC_REASON_TORPROTOCOL ; } log_info ( domain , ""\'resolved\'<S2SV_blank>received,<S2SV_blank>no<S2SV_blank>conn<S2SV_blank>attached<S2SV_blank>anymore.<S2SV_blank>Ignoring."" ) ; return 0 ; case RELAY_COMMAND_ESTABLISH_INTRO : case RELAY_COMMAND_ESTABLISH_RENDEZVOUS : case RELAY_COMMAND_INTRODUCE1 : case RELAY_COMMAND_INTRODUCE2 : case RELAY_COMMAND_INTRODUCE_ACK : case RELAY_COMMAND_RENDEZVOUS1 : case RELAY_COMMAND_RENDEZVOUS2 : case RELAY_COMMAND_INTRO_ESTABLISHED : case RELAY_COMMAND_RENDEZVOUS_ESTABLISHED : rend_process_relay_cell ( circ , layer_hint , rh . command , rh . length , cell -> payload + RELAY_HEADER_SIZE ) ; return 0 ; } log_fn ( LOG_PROTOCOL_WARN , LD_PROTOCOL , ""Received<S2SV_blank>unknown<S2SV_blank>relay<S2SV_blank>command<S2SV_blank>%d.<S2SV_blank>Perhaps<S2SV_blank>the<S2SV_blank>other<S2SV_blank>side<S2SV_blank>is<S2SV_blank>using<S2SV_blank>"" ""a<S2SV_blank>newer<S2SV_blank>version<S2SV_blank>of<S2SV_blank>Tor?<S2SV_blank>Dropping."" , rh . command ) ; return 0 ; }",command == RELAY_COMMAND_BEGIN_DIR && circ -> purpose != CIRCUIT_PURPOSE_S_REND_JOINED
490,"static PyObject * decode_bytes_with_escapes ( struct compiling * c , const node * n , const char * s , size_t len ) { <S2SV_StartBug> return PyBytes_DecodeEscape ( s , len , NULL , 0 , NULL ) ; <S2SV_EndBug> }","len ) { const char * first_invalid_escape ; PyObject * result = _PyBytes_DecodeEscape <S2SV_ModEnd> ( s , <S2SV_ModStart> 0 , NULL , & first_invalid_escape ) ; if ( result == NULL ) return NULL ; if ( first_invalid_escape != NULL ) { if ( warn_invalid_escape_sequence ( c , n , * first_invalid_escape ) < 0 ) { Py_DECREF ( result ) ; return NULL ; } } return result <S2SV_ModEnd> ; } <S2SV_null>"
491,"static int vp8_rdcost_mby ( MACROBLOCK * mb ) { int cost = 0 ; int b ; MACROBLOCKD * x = & mb -> e_mbd ; ENTROPY_CONTEXT_PLANES t_above , t_left ; ENTROPY_CONTEXT * ta ; ENTROPY_CONTEXT * tl ; <S2SV_StartBug> vpx_memcpy ( & t_above , mb -> e_mbd . above_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( & t_left , mb -> e_mbd . left_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; <S2SV_EndBug> ta = ( ENTROPY_CONTEXT * ) & t_above ; tl = ( ENTROPY_CONTEXT * ) & t_left ; for ( b = 0 ; b < 16 ; b ++ ) cost += cost_coeffs ( mb , x -> block + b , PLANE_TYPE_Y_NO_DC , ta + vp8_block2above [ b ] , tl + vp8_block2left [ b ] ) ; cost += cost_coeffs ( mb , x -> block + 24 , PLANE_TYPE_Y2 , ta + vp8_block2above [ 24 ] , tl + vp8_block2left [ 24 ] ) ; return cost ; }",* tl ; memcpy <S2SV_ModEnd> ( & t_above <S2SV_ModStart> ) ) ; memcpy <S2SV_ModEnd> ( & t_left
492,"static int ExecuteSQL ( SQLHDBC hDbc , char * szSQL , char cDelimiter , int bColumnNames , int bHTMLTable ) { SQLHSTMT hStmt ; SQLTCHAR szSepLine [ 32001 ] ; SQLTCHAR szUcSQL [ 32001 ] ; SQLSMALLINT cols ; SQLINTEGER ret ; SQLLEN nRows = 0 ; szSepLine [ 0 ] = 0 ; ansi_to_unicode ( szSQL , szUcSQL ) ; if ( SQLAllocStmt ( hDbc , & hStmt ) != SQL_SUCCESS ) { if ( bVerbose ) DumpODBCLog ( hEnv , hDbc , 0 ) ; fprintf ( stderr , ""[ISQL]ERROR:<S2SV_blank>Could<S2SV_blank>not<S2SV_blank>SQLAllocStmt\\n"" ) ; return 0 ; } if ( buseED ) { ret = SQLExecDirect ( hStmt , szUcSQL , SQL_NTS ) ; if ( ret == SQL_NO_DATA ) { fprintf ( stderr , ""[ISQL]INFO:<S2SV_blank>SQLExecDirect<S2SV_blank>returned<S2SV_blank>SQL_NO_DATA\\n"" ) ; } else if ( ret == SQL_SUCCESS_WITH_INFO ) { if ( bVerbose ) DumpODBCLog ( hEnv , hDbc , hStmt ) ; fprintf ( stderr , ""[ISQL]INFO:<S2SV_blank>SQLExecDirect<S2SV_blank>returned<S2SV_blank>SQL_SUCCESS_WITH_INFO\\n"" ) ; } else if ( ret != SQL_SUCCESS ) { if ( bVerbose ) DumpODBCLog ( hEnv , hDbc , hStmt ) ; fprintf ( stderr , ""[ISQL]ERROR:<S2SV_blank>Could<S2SV_blank>not<S2SV_blank>SQLExecDirect\\n"" ) ; SQLFreeStmt ( hStmt , SQL_DROP ) ; <S2SV_StartBug> free ( szSepLine ) ; <S2SV_EndBug> return 0 ; } } else { if ( SQLPrepare ( hStmt , szUcSQL , SQL_NTS ) != SQL_SUCCESS ) { if ( bVerbose ) DumpODBCLog ( hEnv , hDbc , hStmt ) ; fprintf ( stderr , ""[ISQL]ERROR:<S2SV_blank>Could<S2SV_blank>not<S2SV_blank>SQLPrepare\\n"" ) ; SQLFreeStmt ( hStmt , SQL_DROP ) ; return 0 ; } ret = SQLExecute ( hStmt ) ; if ( ret == SQL_NO_DATA ) { fprintf ( stderr , ""[ISQL]INFO:<S2SV_blank>SQLExecute<S2SV_blank>returned<S2SV_blank>SQL_NO_DATA\\n"" ) ; } else if ( ret == SQL_SUCCESS_WITH_INFO ) { if ( bVerbose ) DumpODBCLog ( hEnv , hDbc , hStmt ) ; fprintf ( stderr , ""[ISQL]INFO:<S2SV_blank>SQLExecute<S2SV_blank>returned<S2SV_blank>SQL_SUCCESS_WITH_INFO\\n"" ) ; } else if ( ret != SQL_SUCCESS ) { if ( bVerbose ) DumpODBCLog ( hEnv , hDbc , hStmt ) ; fprintf ( stderr , ""[ISQL]ERROR:<S2SV_blank>Could<S2SV_blank>not<S2SV_blank>SQLExecute\\n"" ) ; SQLFreeStmt ( hStmt , SQL_DROP ) ; return 0 ; } } do { if ( SQLNumResultCols ( hStmt , & cols ) != SQL_SUCCESS ) { if ( bVerbose ) DumpODBCLog ( hEnv , hDbc , hStmt ) ; fprintf ( stderr , ""[ISQL]ERROR:<S2SV_blank>Could<S2SV_blank>not<S2SV_blank>SQLNumResultCols\\n"" ) ; SQLFreeStmt ( hStmt , SQL_DROP ) ; return 0 ; } if ( cols > 0 ) { if ( bHTMLTable ) WriteHeaderHTMLTable ( hStmt ) ; else if ( cDelimiter == 0 ) UWriteHeaderNormal ( hStmt , szSepLine ) ; else if ( cDelimiter && bColumnNames ) WriteHeaderDelimited ( hStmt , cDelimiter ) ; if ( bHTMLTable ) WriteBodyHTMLTable ( hStmt ) ; else if ( cDelimiter == 0 ) nRows = WriteBodyNormal ( hStmt ) ; else WriteBodyDelimited ( hStmt , cDelimiter ) ; } if ( bHTMLTable ) WriteFooterHTMLTable ( hStmt ) ; else if ( cDelimiter == 0 ) UWriteFooterNormal ( hStmt , szSepLine , nRows ) ; } while ( SQL_SUCCEEDED ( SQLMoreResults ( hStmt ) ) ) ; SQLFreeStmt ( hStmt , SQL_DROP ) ; return 1 ; }",SQL_DROP ) ; <S2SV_ModEnd> return 0 ;
493,"static VALUE cState_space_before_set ( VALUE self , VALUE space_before ) { unsigned long len ; GET_STATE ( self ) ; Check_Type ( space_before , T_STRING ) ; len = RSTRING_LEN ( space_before ) ; if ( len == 0 ) { if ( state -> space_before ) { ruby_xfree ( state -> space_before ) ; state -> space_before = NULL ; state -> space_before_len = 0 ; } } else { if ( state -> space_before ) ruby_xfree ( state -> space_before ) ; <S2SV_StartBug> state -> space_before = strdup ( RSTRING_PTR ( space_before ) ) ; <S2SV_EndBug> state -> space_before_len = len ; } return Qnil ; }","-> space_before = fstrndup <S2SV_ModEnd> ( RSTRING_PTR ( <S2SV_ModStart> ( space_before ) , len"
494,"static int snd_ctl_elem_user_put ( struct snd_kcontrol * kcontrol , struct snd_ctl_elem_value * ucontrol ) { int change ; <S2SV_StartBug> struct user_element * ue = kcontrol -> private_data ; <S2SV_EndBug> change = memcmp ( & ucontrol -> value , ue -> elem_data , ue -> elem_data_size ) != 0 ; if ( change ) memcpy ( ue -> elem_data , & ucontrol -> value , ue -> elem_data_size ) ; <S2SV_StartBug> return change ; <S2SV_EndBug> }",kcontrol -> private_data ; mutex_lock ( & ue -> card -> user_ctl_lock ) <S2SV_ModStart> elem_data_size ) ; mutex_unlock ( & ue -> card -> user_ctl_lock ) ;
495,"int main ( int argc , char * argv [ ] ) { FILE * iplist = NULL ; plist_t root_node = NULL ; char * plist_out = NULL ; uint32_t size = 0 ; int read_size = 0 ; char * plist_entire = NULL ; struct stat filestats ; options_t * options = parse_arguments ( argc , argv ) ; if ( ! options ) { print_usage ( argc , argv ) ; return 0 ; } iplist = fopen ( options -> in_file , ""rb"" ) ; if ( ! iplist ) { free ( options ) ; return 1 ; } <S2SV_StartBug> stat ( options -> in_file , & filestats ) ; <S2SV_EndBug> plist_entire = ( char * ) malloc ( sizeof ( char ) * ( filestats . st_size + 1 ) ) ; read_size = fread ( plist_entire , sizeof ( char ) , filestats . st_size , iplist ) ; fclose ( iplist ) ; if ( memcmp ( plist_entire , ""bplist00"" , 8 ) == 0 ) { plist_from_bin ( plist_entire , read_size , & root_node ) ; plist_to_xml ( root_node , & plist_out , & size ) ; } else { plist_from_xml ( plist_entire , read_size , & root_node ) ; plist_to_bin ( root_node , & plist_out , & size ) ; } plist_free ( root_node ) ; free ( plist_entire ) ; if ( plist_out ) { if ( options -> out_file != NULL ) { FILE * oplist = fopen ( options -> out_file , ""wb"" ) ; if ( ! oplist ) { free ( options ) ; return 1 ; } fwrite ( plist_out , size , sizeof ( char ) , oplist ) ; fclose ( oplist ) ; } else fwrite ( plist_out , size , sizeof ( char ) , stdout ) ; free ( plist_out ) ; } else printf ( ""ERROR:<S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>convert<S2SV_blank>input<S2SV_blank>file.\\n"" ) ; free ( options ) ; return 0 ; }","filestats ) ; if ( filestats . st_size < 8 ) { printf ( ""ERROR:<S2SV_blank>Input<S2SV_blank>file<S2SV_blank>is<S2SV_blank>too<S2SV_blank>small<S2SV_blank>to<S2SV_blank>contain<S2SV_blank>valid<S2SV_blank>plist<S2SV_blank>data.\\n"" ) ; return - 1 ; }"
496,"static int fb_mmap ( struct file * file , struct vm_area_struct * vma ) { struct fb_info * info = file_fb_info ( file ) ; struct fb_ops * fb ; <S2SV_StartBug> unsigned long off ; <S2SV_EndBug> unsigned long start ; u32 len ; if ( ! info ) return - ENODEV ; <S2SV_StartBug> if ( vma -> vm_pgoff > ( ~ 0UL >> PAGE_SHIFT ) ) <S2SV_EndBug> return - EINVAL ; <S2SV_StartBug> off = vma -> vm_pgoff << PAGE_SHIFT ; <S2SV_EndBug> fb = info -> fbops ; if ( ! fb ) return - ENODEV ; mutex_lock ( & info -> mm_lock ) ; <S2SV_StartBug> if ( fb -> fb_mmap ) { <S2SV_EndBug> int res ; res = fb -> fb_mmap ( info , vma ) ; mutex_unlock ( & info -> mm_lock ) ; return res ; } start = info -> fix . smem_start ; len = PAGE_ALIGN ( ( start & ~ PAGE_MASK ) + info -> fix . smem_len ) ; if ( off >= len ) { off -= len ; if ( info -> var . accel_flags ) { mutex_unlock ( & info -> mm_lock ) ; return - EINVAL ; } start = info -> fix . mmio_start ; len = PAGE_ALIGN ( ( start & ~ PAGE_MASK ) + info -> fix . mmio_len ) ; } mutex_unlock ( & info -> mm_lock ) ; start &= PAGE_MASK ; if ( ( vma -> vm_end - vma -> vm_start + off ) > len ) return - EINVAL ; off += start ; vma -> vm_pgoff = off >> PAGE_SHIFT ; vma -> vm_page_prot = vm_get_page_prot ( vma -> vm_flags ) ; <S2SV_StartBug> fb_pgprotect ( file , vma , off ) ; <S2SV_EndBug> if ( io_remap_pfn_range ( vma , vma -> vm_start , off >> PAGE_SHIFT , vma -> vm_end - vma -> vm_start , vma -> vm_page_prot ) ) return - EAGAIN ; return 0 ; }","; unsigned long mmio_pgoff <S2SV_ModEnd> ; unsigned long <S2SV_ModStart> - ENODEV ; fb = info -> fbops ; if ( ! fb ) return - ENODEV ; mutex_lock ( & info -> mm_lock ) ; if ( fb -> fb_mmap ) { int res ; res = fb -> fb_mmap ( info , vma ) ; mutex_unlock ( & info -> mm_lock ) ; return res ; } start = info -> fix . smem_start ; len = info -> fix . smem_len ; mmio_pgoff = PAGE_ALIGN ( ( start & ~ PAGE_MASK ) + len ) >> PAGE_SHIFT ; if ( <S2SV_ModEnd> vma -> vm_pgoff <S2SV_ModStart> vma -> vm_pgoff >= mmio_pgoff ) { vma -> vm_pgoff -= mmio_pgoff ; start = info -> fix . mmio_start ; len = info -> fix . mmio_len ; } mutex_unlock <S2SV_ModEnd> ( & info <S2SV_ModStart> mm_lock ) ; <S2SV_ModEnd> vma -> vm_page_prot <S2SV_ModStart> , vma , start ) ; return vm_iomap_memory ( vma , start , len ) <S2SV_ModEnd> ; } <S2SV_null>"
497,"PyObject * ast2obj_mod ( void * _o ) { mod_ty o = ( mod_ty ) _o ; PyObject * result = NULL , * value = NULL ; if ( ! o ) { Py_RETURN_NONE ; } switch ( o -> kind ) { case Module_kind : result = PyType_GenericNew ( Module_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . Module . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; <S2SV_StartBug> break ; <S2SV_EndBug> case Interactive_kind : result = PyType_GenericNew ( Interactive_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . Interactive . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Expression_kind : result = PyType_GenericNew ( Expression_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . Expression . body ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; <S2SV_StartBug> case Suite_kind : <S2SV_EndBug> result = PyType_GenericNew ( Suite_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . Suite . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; } return result ; failed : Py_XDECREF ( value ) ; Py_XDECREF ( result ) ; return NULL ; }","value ) ; value = ast2obj_list ( o -> v . Module . type_ignores , ast2obj_type_ignore ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_type_ignores , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; <S2SV_ModStart> break ; case FunctionType_kind : result = PyType_GenericNew ( FunctionType_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . FunctionType . argtypes , ast2obj_expr ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_argtypes , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> v . FunctionType . returns ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_returns , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case"
498,"static Image * ReadYCBCRImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { const unsigned char * pixels ; Image * canvas_image , * image ; MagickBooleanType status ; MagickOffsetType scene ; QuantumInfo * quantum_info ; QuantumType quantum_type ; register const Quantum * p ; register ssize_t i , x ; register Quantum * q ; size_t length ; ssize_t count , y ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; if ( ( image -> columns == 0 ) || ( image -> rows == 0 ) ) ThrowReaderException ( OptionError , ""MustSpecifyImageSize"" ) ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; SetImageColorspace ( image , YCbCrColorspace , exception ) ; if ( image_info -> interlace != PartitionInterlace ) { status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } if ( DiscardBlobBytes ( image , image -> offset ) == MagickFalse ) ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; } canvas_image = CloneImage ( image , image -> extract_info . width , 1 , MagickFalse , exception ) ; ( void ) SetImageVirtualPixelMethod ( canvas_image , BlackVirtualPixelMethod , exception ) ; quantum_info = AcquireQuantumInfo ( image_info , canvas_image ) ; if ( quantum_info == ( QuantumInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; quantum_type = RGBQuantum ; if ( LocaleCompare ( image_info -> magick , ""YCbCrA"" ) == 0 ) { quantum_type = RGBAQuantum ; image -> alpha_trait = BlendPixelTrait ; } pixels = ( const unsigned char * ) NULL ; if ( image_info -> number_scenes != 0 ) while ( image -> scene < image_info -> scene ) { image -> scene ++ ; length = GetQuantumExtent ( canvas_image , quantum_info , quantum_type ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { pixels = ( const unsigned char * ) ReadBlobStream ( image , length , GetQuantumPixels ( quantum_info ) , & count ) ; if ( count != ( ssize_t ) length ) break ; } } count = 0 ; length = 0 ; scene = 0 ; do { if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) { <S2SV_StartBug> quantum_info = DestroyQuantumInfo ( quantum_info ) ; <S2SV_EndBug> return ( DestroyImageList ( image ) ) ; } SetImageColorspace ( image , YCbCrColorspace , exception ) ; switch ( image_info -> interlace ) { case NoInterlace : default : { if ( scene == 0 ) { length = GetQuantumExtent ( canvas_image , quantum_info , quantum_type ) ; pixels = ( const unsigned char * ) ReadBlobStream ( image , length , GetQuantumPixels ( quantum_info ) , & count ) ; } for ( y = 0 ; y < ( ssize_t ) image -> extract_info . height ; y ++ ) { if ( count != ( ssize_t ) length ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } q = GetAuthenticPixels ( canvas_image , 0 , 0 , canvas_image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; length = ImportQuantumPixels ( canvas_image , ( CacheView * ) NULL , quantum_info , quantum_type , pixels , exception ) ; if ( SyncAuthenticPixels ( canvas_image , exception ) == MagickFalse ) break ; if ( ( ( y - image -> extract_info . y ) >= 0 ) && ( ( y - image -> extract_info . y ) < ( ssize_t ) image -> rows ) ) { p = GetVirtualPixels ( canvas_image , canvas_image -> extract_info . x , 0 , canvas_image -> columns , 1 , exception ) ; q = QueueAuthenticPixels ( image , 0 , y - image -> extract_info . y , image -> columns , 1 , exception ) ; if ( ( p == ( const Quantum * ) NULL ) || ( q == ( Quantum * ) NULL ) ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( image , GetPixelRed ( canvas_image , p ) , q ) ; SetPixelGreen ( image , GetPixelGreen ( canvas_image , p ) , q ) ; SetPixelBlue ( image , GetPixelBlue ( canvas_image , p ) , q ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , GetPixelAlpha ( canvas_image , p ) , q ) ; p += GetPixelChannels ( canvas_image ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } pixels = ( const unsigned char * ) ReadBlobStream ( image , length , GetQuantumPixels ( quantum_info ) , & count ) ; } break ; } case LineInterlace : { static QuantumType quantum_types [ 4 ] = { RedQuantum , GreenQuantum , BlueQuantum , OpacityQuantum } ; if ( scene == 0 ) { length = GetQuantumExtent ( canvas_image , quantum_info , RedQuantum ) ; pixels = ( const unsigned char * ) ReadBlobStream ( image , length , GetQuantumPixels ( quantum_info ) , & count ) ; } for ( y = 0 ; y < ( ssize_t ) image -> extract_info . height ; y ++ ) { for ( i = 0 ; i < ( image -> alpha_trait != UndefinedPixelTrait ? 4 : 3 ) ; i ++ ) { if ( count != ( ssize_t ) length ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } quantum_type = quantum_types [ i ] ; q = GetAuthenticPixels ( canvas_image , 0 , 0 , canvas_image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; length = ImportQuantumPixels ( canvas_image , ( CacheView * ) NULL , quantum_info , quantum_type , pixels , exception ) ; if ( SyncAuthenticPixels ( canvas_image , exception ) == MagickFalse ) break ; if ( ( ( y - image -> extract_info . y ) >= 0 ) && ( ( y - image -> extract_info . y ) < ( ssize_t ) image -> rows ) ) { p = GetVirtualPixels ( canvas_image , canvas_image -> extract_info . x , 0 , canvas_image -> columns , 1 , exception ) ; q = GetAuthenticPixels ( image , 0 , y - image -> extract_info . y , image -> columns , 1 , exception ) ; if ( ( p == ( const Quantum * ) NULL ) || ( q == ( Quantum * ) NULL ) ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { switch ( quantum_type ) { case RedQuantum : { SetPixelRed ( image , GetPixelRed ( canvas_image , p ) , q ) ; break ; } case GreenQuantum : { SetPixelGreen ( image , GetPixelGreen ( canvas_image , p ) , q ) ; break ; } case BlueQuantum : { SetPixelBlue ( image , GetPixelBlue ( canvas_image , p ) , q ) ; break ; } case OpacityQuantum : { SetPixelAlpha ( image , GetPixelAlpha ( canvas_image , p ) , q ) ; break ; } default : break ; } p += GetPixelChannels ( canvas_image ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } pixels = ( const unsigned char * ) ReadBlobStream ( image , length , GetQuantumPixels ( quantum_info ) , & count ) ; } if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } break ; } case PlaneInterlace : { if ( scene == 0 ) { length = GetQuantumExtent ( canvas_image , quantum_info , RedQuantum ) ; pixels = ( const unsigned char * ) ReadBlobStream ( image , length , GetQuantumPixels ( quantum_info ) , & count ) ; } for ( y = 0 ; y < ( ssize_t ) image -> extract_info . height ; y ++ ) { if ( count != ( ssize_t ) length ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } q = GetAuthenticPixels ( canvas_image , 0 , 0 , canvas_image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; length = ImportQuantumPixels ( canvas_image , ( CacheView * ) NULL , quantum_info , RedQuantum , pixels , exception ) ; if ( SyncAuthenticPixels ( canvas_image , exception ) == MagickFalse ) break ; if ( ( ( y - image -> extract_info . y ) >= 0 ) && ( ( y - image -> extract_info . y ) < ( ssize_t ) image -> rows ) ) { p = GetVirtualPixels ( canvas_image , canvas_image -> extract_info . x , 0 , canvas_image -> columns , 1 , exception ) ; q = GetAuthenticPixels ( image , 0 , y - image -> extract_info . y , image -> columns , 1 , exception ) ; if ( ( p == ( const Quantum * ) NULL ) || ( q == ( Quantum * ) NULL ) ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( image , GetPixelRed ( canvas_image , p ) , q ) ; p += GetPixelChannels ( canvas_image ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } pixels = ( const unsigned char * ) ReadBlobStream ( image , length , GetQuantumPixels ( quantum_info ) , & count ) ; } if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , 1 , 5 ) ; if ( status == MagickFalse ) break ; } for ( y = 0 ; y < ( ssize_t ) image -> extract_info . height ; y ++ ) { if ( count != ( ssize_t ) length ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } q = GetAuthenticPixels ( canvas_image , 0 , 0 , canvas_image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; length = ImportQuantumPixels ( canvas_image , ( CacheView * ) NULL , quantum_info , GreenQuantum , pixels , exception ) ; if ( SyncAuthenticPixels ( canvas_image , exception ) == MagickFalse ) break ; if ( ( ( y - image -> extract_info . y ) >= 0 ) && ( ( y - image -> extract_info . y ) < ( ssize_t ) image -> rows ) ) { p = GetVirtualPixels ( canvas_image , canvas_image -> extract_info . x , 0 , canvas_image -> columns , 1 , exception ) ; q = GetAuthenticPixels ( image , 0 , y - image -> extract_info . y , image -> columns , 1 , exception ) ; if ( ( p == ( const Quantum * ) NULL ) || ( q == ( Quantum * ) NULL ) ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelGreen ( image , GetPixelGreen ( canvas_image , p ) , q ) ; p += GetPixelChannels ( canvas_image ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } pixels = ( const unsigned char * ) ReadBlobStream ( image , length , GetQuantumPixels ( quantum_info ) , & count ) ; } if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , 2 , 5 ) ; if ( status == MagickFalse ) break ; } for ( y = 0 ; y < ( ssize_t ) image -> extract_info . height ; y ++ ) { if ( count != ( ssize_t ) length ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } q = GetAuthenticPixels ( canvas_image , 0 , 0 , canvas_image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; length = ImportQuantumPixels ( canvas_image , ( CacheView * ) NULL , quantum_info , BlueQuantum , pixels , exception ) ; if ( SyncAuthenticPixels ( canvas_image , exception ) == MagickFalse ) break ; if ( ( ( y - image -> extract_info . y ) >= 0 ) && ( ( y - image -> extract_info . y ) < ( ssize_t ) image -> rows ) ) { p = GetVirtualPixels ( canvas_image , canvas_image -> extract_info . x , 0 , canvas_image -> columns , 1 , exception ) ; q = GetAuthenticPixels ( image , 0 , y - image -> extract_info . y , image -> columns , 1 , exception ) ; if ( ( p == ( const Quantum * ) NULL ) || ( q == ( Quantum * ) NULL ) ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelBlue ( image , GetPixelBlue ( canvas_image , p ) , q ) ; p += GetPixelChannels ( canvas_image ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } pixels = ( const unsigned char * ) ReadBlobStream ( image , length , GetQuantumPixels ( quantum_info ) , & count ) ; } if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , 3 , 5 ) ; if ( status == MagickFalse ) break ; } if ( image -> alpha_trait != UndefinedPixelTrait ) { for ( y = 0 ; y < ( ssize_t ) image -> extract_info . height ; y ++ ) { if ( count != ( ssize_t ) length ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } q = GetAuthenticPixels ( canvas_image , 0 , 0 , canvas_image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; length = ImportQuantumPixels ( canvas_image , ( CacheView * ) NULL , quantum_info , AlphaQuantum , pixels , exception ) ; if ( SyncAuthenticPixels ( canvas_image , exception ) == MagickFalse ) break ; if ( ( ( y - image -> extract_info . y ) >= 0 ) && ( ( y - image -> extract_info . y ) < ( ssize_t ) image -> rows ) ) { p = GetVirtualPixels ( canvas_image , canvas_image -> extract_info . x , 0 , canvas_image -> columns , 1 , exception ) ; q = GetAuthenticPixels ( image , 0 , y - image -> extract_info . y , image -> columns , 1 , exception ) ; if ( ( p == ( const Quantum * ) NULL ) || ( q == ( Quantum * ) NULL ) ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelAlpha ( image , GetPixelAlpha ( canvas_image , p ) , q ) ; p += GetPixelChannels ( canvas_image ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } pixels = ( const unsigned char * ) ReadBlobStream ( image , length , GetQuantumPixels ( quantum_info ) , & count ) ; } if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , 4 , 5 ) ; if ( status == MagickFalse ) break ; } } if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , 5 , 5 ) ; if ( status == MagickFalse ) break ; } break ; } case PartitionInterlace : { AppendImageFormat ( ""Y"" , image -> filename ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { canvas_image = DestroyImageList ( canvas_image ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } if ( DiscardBlobBytes ( image , image -> offset ) == MagickFalse ) ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; length = GetQuantumExtent ( canvas_image , quantum_info , RedQuantum ) ; for ( i = 0 ; i < ( ssize_t ) scene ; i ++ ) for ( y = 0 ; y < ( ssize_t ) image -> extract_info . height ; y ++ ) { pixels = ( const unsigned char * ) ReadBlobStream ( image , length , GetQuantumPixels ( quantum_info ) , & count ) ; if ( count != ( ssize_t ) length ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } } pixels = ( const unsigned char * ) ReadBlobStream ( image , length , GetQuantumPixels ( quantum_info ) , & count ) ; for ( y = 0 ; y < ( ssize_t ) image -> extract_info . height ; y ++ ) { if ( count != ( ssize_t ) length ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } q = GetAuthenticPixels ( canvas_image , 0 , 0 , canvas_image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; length = ImportQuantumPixels ( canvas_image , ( CacheView * ) NULL , quantum_info , RedQuantum , pixels , exception ) ; if ( SyncAuthenticPixels ( canvas_image , exception ) == MagickFalse ) break ; if ( ( ( y - image -> extract_info . y ) >= 0 ) && ( ( y - image -> extract_info . y ) < ( ssize_t ) image -> rows ) ) { p = GetVirtualPixels ( canvas_image , canvas_image -> extract_info . x , 0 , canvas_image -> columns , 1 , exception ) ; q = GetAuthenticPixels ( image , 0 , y - image -> extract_info . y , image -> columns , 1 , exception ) ; if ( ( p == ( const Quantum * ) NULL ) || ( q == ( Quantum * ) NULL ) ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( image , GetPixelRed ( canvas_image , p ) , q ) ; p += GetPixelChannels ( canvas_image ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } pixels = ( const unsigned char * ) ReadBlobStream ( image , length , GetQuantumPixels ( quantum_info ) , & count ) ; } if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , 1 , 5 ) ; if ( status == MagickFalse ) break ; } ( void ) CloseBlob ( image ) ; AppendImageFormat ( ""Cb"" , image -> filename ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { canvas_image = DestroyImageList ( canvas_image ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } length = GetQuantumExtent ( canvas_image , quantum_info , GreenQuantum ) ; for ( i = 0 ; i < ( ssize_t ) scene ; i ++ ) for ( y = 0 ; y < ( ssize_t ) image -> extract_info . height ; y ++ ) { pixels = ( const unsigned char * ) ReadBlobStream ( image , length , GetQuantumPixels ( quantum_info ) , & count ) ; if ( count != ( ssize_t ) length ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } } pixels = ( const unsigned char * ) ReadBlobStream ( image , length , GetQuantumPixels ( quantum_info ) , & count ) ; for ( y = 0 ; y < ( ssize_t ) image -> extract_info . height ; y ++ ) { if ( count != ( ssize_t ) length ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } q = GetAuthenticPixels ( canvas_image , 0 , 0 , canvas_image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; length = ImportQuantumPixels ( canvas_image , ( CacheView * ) NULL , quantum_info , GreenQuantum , pixels , exception ) ; if ( SyncAuthenticPixels ( canvas_image , exception ) == MagickFalse ) break ; if ( ( ( y - image -> extract_info . y ) >= 0 ) && ( ( y - image -> extract_info . y ) < ( ssize_t ) image -> rows ) ) { p = GetVirtualPixels ( canvas_image , canvas_image -> extract_info . x , 0 , canvas_image -> columns , 1 , exception ) ; q = GetAuthenticPixels ( image , 0 , y - image -> extract_info . y , image -> columns , 1 , exception ) ; if ( ( p == ( const Quantum * ) NULL ) || ( q == ( Quantum * ) NULL ) ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelGreen ( image , GetPixelGreen ( canvas_image , p ) , q ) ; p += GetPixelChannels ( canvas_image ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } pixels = ( const unsigned char * ) ReadBlobStream ( image , length , GetQuantumPixels ( quantum_info ) , & count ) ; } if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , 2 , 5 ) ; if ( status == MagickFalse ) break ; } ( void ) CloseBlob ( image ) ; AppendImageFormat ( ""Cr"" , image -> filename ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { canvas_image = DestroyImageList ( canvas_image ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } length = GetQuantumExtent ( canvas_image , quantum_info , BlueQuantum ) ; for ( i = 0 ; i < ( ssize_t ) scene ; i ++ ) for ( y = 0 ; y < ( ssize_t ) image -> extract_info . height ; y ++ ) { pixels = ( const unsigned char * ) ReadBlobStream ( image , length , GetQuantumPixels ( quantum_info ) , & count ) ; if ( count != ( ssize_t ) length ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } } pixels = ( const unsigned char * ) ReadBlobStream ( image , length , GetQuantumPixels ( quantum_info ) , & count ) ; for ( y = 0 ; y < ( ssize_t ) image -> extract_info . height ; y ++ ) { if ( count != ( ssize_t ) length ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } q = GetAuthenticPixels ( canvas_image , 0 , 0 , canvas_image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; length = ImportQuantumPixels ( canvas_image , ( CacheView * ) NULL , quantum_info , BlueQuantum , pixels , exception ) ; if ( SyncAuthenticPixels ( canvas_image , exception ) == MagickFalse ) break ; if ( ( ( y - image -> extract_info . y ) >= 0 ) && ( ( y - image -> extract_info . y ) < ( ssize_t ) image -> rows ) ) { p = GetVirtualPixels ( canvas_image , canvas_image -> extract_info . x , 0 , canvas_image -> columns , 1 , exception ) ; q = GetAuthenticPixels ( image , 0 , y - image -> extract_info . y , image -> columns , 1 , exception ) ; if ( ( p == ( const Quantum * ) NULL ) || ( q == ( Quantum * ) NULL ) ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelBlue ( image , GetPixelBlue ( canvas_image , p ) , q ) ; p += GetPixelChannels ( canvas_image ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } pixels = ( const unsigned char * ) ReadBlobStream ( image , length , GetQuantumPixels ( quantum_info ) , & count ) ; } if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , 3 , 5 ) ; if ( status == MagickFalse ) break ; } if ( image -> alpha_trait != UndefinedPixelTrait ) { ( void ) CloseBlob ( image ) ; AppendImageFormat ( ""A"" , image -> filename ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { canvas_image = DestroyImageList ( canvas_image ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } length = GetQuantumExtent ( canvas_image , quantum_info , AlphaQuantum ) ; for ( i = 0 ; i < ( ssize_t ) scene ; i ++ ) for ( y = 0 ; y < ( ssize_t ) image -> extract_info . height ; y ++ ) { pixels = ( const unsigned char * ) ReadBlobStream ( image , length , GetQuantumPixels ( quantum_info ) , & count ) ; if ( count != ( ssize_t ) length ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } } pixels = ( const unsigned char * ) ReadBlobStream ( image , length , GetQuantumPixels ( quantum_info ) , & count ) ; for ( y = 0 ; y < ( ssize_t ) image -> extract_info . height ; y ++ ) { if ( count != ( ssize_t ) length ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } q = GetAuthenticPixels ( canvas_image , 0 , 0 , canvas_image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; length = ImportQuantumPixels ( canvas_image , ( CacheView * ) NULL , quantum_info , BlueQuantum , pixels , exception ) ; if ( SyncAuthenticPixels ( canvas_image , exception ) == MagickFalse ) break ; if ( ( ( y - image -> extract_info . y ) >= 0 ) && ( ( y - image -> extract_info . y ) < ( ssize_t ) image -> rows ) ) { p = GetVirtualPixels ( canvas_image , canvas_image -> extract_info . x , 0 , canvas_image -> columns , 1 , exception ) ; q = GetAuthenticPixels ( image , 0 , y - image -> extract_info . y , image -> columns , 1 , exception ) ; if ( ( p == ( const Quantum * ) NULL ) || ( q == ( Quantum * ) NULL ) ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelAlpha ( image , GetPixelAlpha ( canvas_image , p ) , q ) ; p += GetPixelChannels ( canvas_image ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } pixels = ( const unsigned char * ) ReadBlobStream ( image , length , GetQuantumPixels ( quantum_info ) , & count ) ; } if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , 4 , 5 ) ; if ( status == MagickFalse ) break ; } } if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , 5 , 5 ) ; if ( status == MagickFalse ) break ; } break ; } } SetQuantumImageType ( image , quantum_type ) ; if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; if ( count == ( ssize_t ) length ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } scene ++ ; } while ( count == ( ssize_t ) length ) ; quantum_info = DestroyQuantumInfo ( quantum_info ) ; canvas_image = DestroyImage ( canvas_image ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }",DestroyQuantumInfo ( quantum_info ) ; canvas_image = DestroyImage ( canvas_image
499,"static int l2tp_ip_bind ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct sockaddr_l2tpip * addr = ( struct sockaddr_l2tpip * ) uaddr ; struct net * net = sock_net ( sk ) ; int ret ; int chk_addr_ret ; <S2SV_StartBug> if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) <S2SV_EndBug> return - EINVAL ; <S2SV_StartBug> if ( addr_len < sizeof ( struct sockaddr_l2tpip ) ) <S2SV_EndBug> return - EINVAL ; <S2SV_StartBug> if ( addr -> l2tp_family != AF_INET ) <S2SV_EndBug> return - EINVAL ; ret = - EADDRINUSE ; read_lock_bh ( & l2tp_ip_lock ) ; if ( __l2tp_ip_bind_lookup ( net , addr -> l2tp_addr . s_addr , sk -> sk_bound_dev_if , addr -> l2tp_conn_id ) ) goto out_in_use ; read_unlock_bh ( & l2tp_ip_lock ) ; <S2SV_StartBug> lock_sock ( sk ) ; <S2SV_EndBug> if ( sk -> sk_state != TCP_CLOSE || addr_len < sizeof ( struct sockaddr_l2tpip ) ) goto out ; chk_addr_ret = inet_addr_type ( net , addr -> l2tp_addr . s_addr ) ; ret = - EADDRNOTAVAIL ; if ( addr -> l2tp_addr . s_addr && chk_addr_ret != RTN_LOCAL && chk_addr_ret != RTN_MULTICAST && chk_addr_ret != RTN_BROADCAST ) goto out ; if ( addr -> l2tp_addr . s_addr ) inet -> inet_rcv_saddr = inet -> inet_saddr = addr -> l2tp_addr . s_addr ; if ( chk_addr_ret == RTN_MULTICAST || chk_addr_ret == RTN_BROADCAST ) inet -> inet_saddr = 0 ; sk_dst_reset ( sk ) ; l2tp_ip_sk ( sk ) -> conn_id = addr -> l2tp_conn_id ; write_lock_bh ( & l2tp_ip_lock ) ; sk_add_bind_node ( sk , & l2tp_ip_bind_table ) ; sk_del_node_init ( sk ) ; write_unlock_bh ( & l2tp_ip_lock ) ; ret = 0 ; sock_reset_flag ( sk , SOCK_ZAPPED ) ; out : release_sock ( sk ) ; return ret ; out_in_use : read_unlock_bh ( & l2tp_ip_lock ) ; return ret ; }","; if ( addr_len < sizeof ( struct sockaddr_l2tpip <S2SV_ModEnd> ) ) return <S2SV_ModStart> ; if ( addr -> l2tp_family != AF_INET <S2SV_ModEnd> ) return - <S2SV_ModStart> - EINVAL ; <S2SV_ModEnd> ret = - <S2SV_ModStart> ( sk ) ; if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) goto out"
500,"void vtp_print ( netdissect_options * ndo , const u_char * pptr , u_int length ) { int type , len , tlv_len , tlv_value , mgmtd_len ; const u_char * tptr ; const struct vtp_vlan_ * vtp_vlan ; if ( length < VTP_HEADER_LEN ) goto trunc ; tptr = pptr ; ND_TCHECK2 ( * tptr , VTP_HEADER_LEN ) ; type = * ( tptr + 1 ) ; ND_PRINT ( ( ndo , ""VTPv%u,<S2SV_blank>Message<S2SV_blank>%s<S2SV_blank>(0x%02x),<S2SV_blank>length<S2SV_blank>%u"" , * tptr , tok2str ( vtp_message_type_values , ""Unknown<S2SV_blank>message<S2SV_blank>type"" , type ) , type , length ) ) ; if ( ndo -> ndo_vflag < 1 ) { return ; } ND_PRINT ( ( ndo , ""\\n\\tDomain<S2SV_blank>name:<S2SV_blank>"" ) ) ; mgmtd_len = * ( tptr + 3 ) ; if ( mgmtd_len < 1 || mgmtd_len > 32 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>[invalid<S2SV_blank>MgmtD<S2SV_blank>Len<S2SV_blank>%d]"" , mgmtd_len ) ) ; return ; } fn_printzp ( ndo , tptr + 4 , mgmtd_len , NULL ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>%s:<S2SV_blank>%u"" , tok2str ( vtp_header_values , ""Unknown"" , type ) , * ( tptr + 2 ) ) ) ; tptr += VTP_HEADER_LEN ; switch ( type ) { case VTP_SUMMARY_ADV : ND_TCHECK2 ( * tptr , 8 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Config<S2SV_blank>Rev<S2SV_blank>%x,<S2SV_blank>Updater<S2SV_blank>%s"" , EXTRACT_32BITS ( tptr ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; tptr += 8 ; ND_TCHECK2 ( * tptr , VTP_UPDATE_TIMESTAMP_LEN ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>Timestamp<S2SV_blank>0x%08x<S2SV_blank>0x%08x<S2SV_blank>0x%08x"" , EXTRACT_32BITS ( tptr ) , EXTRACT_32BITS ( tptr + 4 ) , EXTRACT_32BITS ( tptr + 8 ) ) ) ; tptr += VTP_UPDATE_TIMESTAMP_LEN ; ND_TCHECK2 ( * tptr , VTP_MD5_DIGEST_LEN ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>MD5<S2SV_blank>digest:<S2SV_blank>%08x%08x%08x%08x"" , EXTRACT_32BITS ( tptr ) , EXTRACT_32BITS ( tptr + 4 ) , EXTRACT_32BITS ( tptr + 8 ) , EXTRACT_32BITS ( tptr + 12 ) ) ) ; tptr += VTP_MD5_DIGEST_LEN ; break ; case VTP_SUBSET_ADV : <S2SV_StartBug> ND_PRINT ( ( ndo , "",<S2SV_blank>Config<S2SV_blank>Rev<S2SV_blank>%x"" , EXTRACT_32BITS ( tptr ) ) ) ; <S2SV_EndBug> tptr += 4 ; <S2SV_StartBug> while ( tptr < ( pptr + length ) ) { <S2SV_EndBug> len = * tptr ; if ( len == 0 ) break ; ND_TCHECK2 ( * tptr , len ) ; vtp_vlan = ( const struct vtp_vlan_ * ) tptr ; ND_TCHECK ( * vtp_vlan ) ; ND_PRINT ( ( ndo , ""\\n\\tVLAN<S2SV_blank>info<S2SV_blank>status<S2SV_blank>%s,<S2SV_blank>type<S2SV_blank>%s,<S2SV_blank>VLAN-id<S2SV_blank>%u,<S2SV_blank>MTU<S2SV_blank>%u,<S2SV_blank>SAID<S2SV_blank>0x%08x,<S2SV_blank>Name<S2SV_blank>"" , tok2str ( vtp_vlan_status , ""Unknown"" , vtp_vlan -> status ) , tok2str ( vtp_vlan_type_values , ""Unknown"" , vtp_vlan -> type ) , EXTRACT_16BITS ( & vtp_vlan -> vlanid ) , EXTRACT_16BITS ( & vtp_vlan -> mtu ) , EXTRACT_32BITS ( & vtp_vlan -> index ) ) ) ; fn_printzp ( ndo , tptr + VTP_VLAN_INFO_OFFSET , vtp_vlan -> name_len , NULL ) ; len -= VTP_VLAN_INFO_OFFSET + 4 * ( ( vtp_vlan -> name_len + 3 ) / 4 ) ; tptr += VTP_VLAN_INFO_OFFSET + 4 * ( ( vtp_vlan -> name_len + 3 ) / 4 ) ; while ( len > 0 ) { type = * tptr ; tlv_len = * ( tptr + 1 ) ; ND_PRINT ( ( ndo , ""\\n\\t\\t%s<S2SV_blank>(0x%04x)<S2SV_blank>TLV"" , tok2str ( vtp_vlan_tlv_values , ""Unknown"" , type ) , type ) ) ; if ( type == 0 || tlv_len == 0 ) { return ; } ND_TCHECK2 ( * tptr , tlv_len * 2 + 2 ) ; tlv_value = EXTRACT_16BITS ( tptr + 2 ) ; switch ( type ) { case VTP_VLAN_STE_HOP_COUNT : ND_PRINT ( ( ndo , "",<S2SV_blank>%u"" , tlv_value ) ) ; break ; case VTP_VLAN_PRUNING : ND_PRINT ( ( ndo , "",<S2SV_blank>%s<S2SV_blank>(%u)"" , tlv_value == 1 ? ""Enabled"" : ""Disabled"" , tlv_value ) ) ; break ; case VTP_VLAN_STP_TYPE : ND_PRINT ( ( ndo , "",<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( vtp_stp_type_values , ""Unknown"" , tlv_value ) , tlv_value ) ) ; break ; case VTP_VLAN_BRIDGE_TYPE : ND_PRINT ( ( ndo , "",<S2SV_blank>%s<S2SV_blank>(%u)"" , tlv_value == 1 ? ""SRB"" : ""SRT"" , tlv_value ) ) ; break ; case VTP_VLAN_BACKUP_CRF_MODE : ND_PRINT ( ( ndo , "",<S2SV_blank>%s<S2SV_blank>(%u)"" , tlv_value == 1 ? ""Backup"" : ""Not<S2SV_blank>backup"" , tlv_value ) ) ; break ; case VTP_VLAN_SOURCE_ROUTING_RING_NUMBER : case VTP_VLAN_SOURCE_ROUTING_BRIDGE_NUMBER : case VTP_VLAN_PARENT_VLAN : case VTP_VLAN_TRANS_BRIDGED_VLAN : case VTP_VLAN_ARP_HOP_COUNT : default : print_unknown_data ( ndo , tptr , ""\\n\\t\\t<S2SV_blank><S2SV_blank>"" , 2 + tlv_len * 2 ) ; break ; } len -= 2 + tlv_len * 2 ; tptr += 2 + tlv_len * 2 ; } } break ; case VTP_ADV_REQUEST : ND_TCHECK2 ( * tptr , 4 ) ; ND_PRINT ( ( ndo , ""\\n\\tStart<S2SV_blank>value:<S2SV_blank>%u"" , EXTRACT_32BITS ( tptr ) ) ) ; break ; case VTP_JOIN_MESSAGE : break ; default : break ; } return ; trunc : ND_PRINT ( ( ndo , ""[|vtp]"" ) ) ; }",case VTP_SUBSET_ADV : ND_TCHECK_32BITS ( tptr ) ; <S2SV_ModStart> ) ) { ND_TCHECK_8BITS ( tptr ) ;
501,"int wasm_dis ( WasmOp * op , const unsigned char * buf , int buf_len ) { op -> len = 1 ; op -> op = buf [ 0 ] ; <S2SV_StartBug> if ( op -> op > 0xbf ) return 1 ; <S2SV_EndBug> WasmOpDef * opdef = & opcodes [ op -> op ] ; switch ( op -> op ) { case WASM_OP_TRAP : case WASM_OP_NOP : case WASM_OP_ELSE : case WASM_OP_RETURN : case WASM_OP_DROP : case WASM_OP_SELECT : case WASM_OP_I32EQZ : case WASM_OP_I32EQ : case WASM_OP_I32NE : case WASM_OP_I32LTS : case WASM_OP_I32LTU : case WASM_OP_I32GTS : case WASM_OP_I32GTU : case WASM_OP_I32LES : case WASM_OP_I32LEU : case WASM_OP_I32GES : case WASM_OP_I32GEU : case WASM_OP_I64EQZ : case WASM_OP_I64EQ : case WASM_OP_I64NE : case WASM_OP_I64LTS : case WASM_OP_I64LTU : case WASM_OP_I64GTS : case WASM_OP_I64GTU : case WASM_OP_I64LES : case WASM_OP_I64LEU : case WASM_OP_I64GES : case WASM_OP_I64GEU : case WASM_OP_F32EQ : case WASM_OP_F32NE : case WASM_OP_F32LT : case WASM_OP_F32GT : case WASM_OP_F32LE : case WASM_OP_F32GE : case WASM_OP_F64EQ : case WASM_OP_F64NE : case WASM_OP_F64LT : case WASM_OP_F64GT : case WASM_OP_F64LE : case WASM_OP_F64GE : case WASM_OP_I32CLZ : case WASM_OP_I32CTZ : case WASM_OP_I32POPCNT : case WASM_OP_I32ADD : case WASM_OP_I32SUB : case WASM_OP_I32MUL : case WASM_OP_I32DIVS : case WASM_OP_I32DIVU : case WASM_OP_I32REMS : case WASM_OP_I32REMU : case WASM_OP_I32AND : case WASM_OP_I32OR : case WASM_OP_I32XOR : case WASM_OP_I32SHL : case WASM_OP_I32SHRS : case WASM_OP_I32SHRU : case WASM_OP_I32ROTL : case WASM_OP_I32ROTR : case WASM_OP_I64CLZ : case WASM_OP_I64CTZ : case WASM_OP_I64POPCNT : case WASM_OP_I64ADD : case WASM_OP_I64SUB : case WASM_OP_I64MUL : case WASM_OP_I64DIVS : case WASM_OP_I64DIVU : case WASM_OP_I64REMS : case WASM_OP_I64REMU : case WASM_OP_I64AND : case WASM_OP_I64OR : case WASM_OP_I64XOR : case WASM_OP_I64SHL : case WASM_OP_I64SHRS : case WASM_OP_I64SHRU : case WASM_OP_I64ROTL : case WASM_OP_I64ROTR : case WASM_OP_F32ABS : case WASM_OP_F32NEG : case WASM_OP_F32CEIL : case WASM_OP_F32FLOOR : case WASM_OP_F32TRUNC : case WASM_OP_F32NEAREST : case WASM_OP_F32SQRT : case WASM_OP_F32ADD : case WASM_OP_F32SUB : case WASM_OP_F32MUL : case WASM_OP_F32DIV : case WASM_OP_F32MIN : case WASM_OP_F32MAX : case WASM_OP_F32COPYSIGN : case WASM_OP_F64ABS : case WASM_OP_F64NEG : case WASM_OP_F64CEIL : case WASM_OP_F64FLOOR : case WASM_OP_F64TRUNC : case WASM_OP_F64NEAREST : case WASM_OP_F64SQRT : case WASM_OP_F64ADD : case WASM_OP_F64SUB : case WASM_OP_F64MUL : case WASM_OP_F64DIV : case WASM_OP_F64MIN : case WASM_OP_F64MAX : case WASM_OP_F64COPYSIGN : case WASM_OP_I32WRAPI64 : case WASM_OP_I32TRUNCSF32 : case WASM_OP_I32TRUNCUF32 : case WASM_OP_I32TRUNCSF64 : case WASM_OP_I32TRUNCUF64 : case WASM_OP_I64EXTENDSI32 : case WASM_OP_I64EXTENDUI32 : case WASM_OP_I64TRUNCSF32 : case WASM_OP_I64TRUNCUF32 : case WASM_OP_I64TRUNCSF64 : case WASM_OP_I64TRUNCUF64 : case WASM_OP_F32CONVERTSI32 : case WASM_OP_F32CONVERTUI32 : case WASM_OP_F32CONVERTSI64 : case WASM_OP_F32CONVERTUI64 : case WASM_OP_F32DEMOTEF64 : case WASM_OP_F64CONVERTSI32 : case WASM_OP_F64CONVERTUI32 : case WASM_OP_F64CONVERTSI64 : case WASM_OP_F64CONVERTUI64 : case WASM_OP_F64PROMOTEF32 : case WASM_OP_I32REINTERPRETF32 : case WASM_OP_I64REINTERPRETF64 : case WASM_OP_F32REINTERPRETI32 : case WASM_OP_F64REINTERPRETI64 : case WASM_OP_END : { snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s"" , opdef -> txt ) ; } break ; case WASM_OP_BLOCK : case WASM_OP_LOOP : case WASM_OP_IF : { st32 val = 0 ; size_t n = read_i32_leb128 ( buf + 1 , buf + buf_len , & val ) ; if ( ! ( n > 0 && n < buf_len ) ) goto err ; switch ( 0x80 - val ) { case R_BIN_WASM_VALUETYPE_EMPTY : snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s"" , opdef -> txt ) ; break ; case R_BIN_WASM_VALUETYPE_i32 : snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>(result<S2SV_blank>i32)"" , opdef -> txt ) ; break ; case R_BIN_WASM_VALUETYPE_i64 : snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>(result<S2SV_blank>i64)"" , opdef -> txt ) ; break ; case R_BIN_WASM_VALUETYPE_f32 : snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>(result<S2SV_blank>f32)"" , opdef -> txt ) ; break ; case R_BIN_WASM_VALUETYPE_f64 : snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>(result<S2SV_blank>f64)"" , opdef -> txt ) ; break ; default : snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>(result<S2SV_blank>?)"" , opdef -> txt ) ; break ; } op -> len += n ; } break ; case WASM_OP_BR : case WASM_OP_BRIF : case WASM_OP_CALL : { ut32 val = 0 ; size_t n = read_u32_leb128 ( buf + 1 , buf + buf_len , & val ) ; if ( ! ( n > 0 && n < buf_len ) ) goto err ; snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>%d"" , opdef -> txt , val ) ; op -> len += n ; } break ; case WASM_OP_BRTABLE : { ut32 count = 0 , * table = NULL , def = 0 ; size_t n = read_u32_leb128 ( buf + 1 , buf + buf_len , & count ) ; <S2SV_StartBug> if ( ! ( n > 0 && n < buf_len ) ) goto err ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( table = calloc ( count , sizeof ( ut32 ) ) ) ) goto err ; <S2SV_EndBug> int i = 0 ; op -> len += n ; for ( i = 0 ; i < count ; i ++ ) { n = read_u32_leb128 ( buf + op -> len , buf + buf_len , & table [ i ] ) ; <S2SV_StartBug> if ( ! ( op -> len + n <= buf_len ) ) goto beach ; <S2SV_EndBug> <S2SV_StartBug> op -> len += n ; <S2SV_EndBug> } n = read_u32_leb128 ( buf + op -> len , buf + buf_len , & def ) ; <S2SV_StartBug> if ( ! ( n > 0 && n + op -> len < buf_len ) ) goto beach ; <S2SV_EndBug> op -> len += n ; snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>%d<S2SV_blank>"" , opdef -> txt , count ) ; <S2SV_StartBug> for ( i = 0 ; i < count && strlen ( op -> txt ) < R_ASM_BUFSIZE ; i ++ ) { <S2SV_EndBug> <S2SV_StartBug> snprintf ( op -> txt + strlen ( op -> txt ) , R_ASM_BUFSIZE , ""%d<S2SV_blank>"" , table [ i ] ) ; <S2SV_EndBug> } snprintf ( op -> txt + strlen ( op -> txt ) , R_ASM_BUFSIZE , ""%d"" , def ) ; free ( table ) ; break ; beach : free ( table ) ; goto err ; } break ; case WASM_OP_CALLINDIRECT : { ut32 val = 0 , reserved = 0 ; size_t n = read_u32_leb128 ( buf + 1 , buf + buf_len , & val ) ; if ( ! ( n > 0 && n < buf_len ) ) goto err ; op -> len += n ; n = read_u32_leb128 ( buf + op -> len , buf + buf_len , & reserved ) ; if ( ! ( n == 1 && op -> len + n <= buf_len ) ) goto err ; reserved &= 0x1 ; snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>%d<S2SV_blank>%d"" , opdef -> txt , val , reserved ) ; op -> len += n ; } break ; case WASM_OP_GETLOCAL : case WASM_OP_SETLOCAL : case WASM_OP_TEELOCAL : case WASM_OP_GETGLOBAL : case WASM_OP_SETGLOBAL : { ut32 val = 0 ; size_t n = read_u32_leb128 ( buf + 1 , buf + buf_len , & val ) ; if ( ! ( n > 0 && n < buf_len ) ) goto err ; snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>%d"" , opdef -> txt , val ) ; op -> len += n ; } break ; case WASM_OP_I32LOAD : case WASM_OP_I64LOAD : case WASM_OP_F32LOAD : case WASM_OP_F64LOAD : case WASM_OP_I32LOAD8S : case WASM_OP_I32LOAD8U : case WASM_OP_I32LOAD16S : case WASM_OP_I32LOAD16U : case WASM_OP_I64LOAD8S : case WASM_OP_I64LOAD8U : case WASM_OP_I64LOAD16S : case WASM_OP_I64LOAD16U : case WASM_OP_I64LOAD32S : case WASM_OP_I64LOAD32U : case WASM_OP_I32STORE : case WASM_OP_I64STORE : case WASM_OP_F32STORE : case WASM_OP_F64STORE : case WASM_OP_I32STORE8 : case WASM_OP_I32STORE16 : case WASM_OP_I64STORE8 : case WASM_OP_I64STORE16 : case WASM_OP_I64STORE32 : { ut32 flag = 0 , offset = 0 ; size_t n = read_u32_leb128 ( buf + 1 , buf + buf_len , & flag ) ; if ( ! ( n > 0 && n < buf_len ) ) goto err ; op -> len += n ; n = read_u32_leb128 ( buf + op -> len , buf + buf_len , & offset ) ; if ( ! ( n > 0 && op -> len + n <= buf_len ) ) goto err ; snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>%d<S2SV_blank>%d"" , opdef -> txt , flag , offset ) ; op -> len += n ; } break ; case WASM_OP_CURRENTMEMORY : case WASM_OP_GROWMEMORY : { ut32 reserved = 0 ; size_t n = read_u32_leb128 ( buf + 1 , buf + buf_len , & reserved ) ; if ( ! ( n == 1 && n < buf_len ) ) goto err ; reserved &= 0x1 ; snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>%d"" , opdef -> txt , reserved ) ; op -> len += n ; } break ; case WASM_OP_I32CONST : { st32 val = 0 ; size_t n = read_i32_leb128 ( buf + 1 , buf + buf_len , & val ) ; if ( ! ( n > 0 && n < buf_len ) ) goto err ; snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>%"" PFMT32d , opdef -> txt , val ) ; op -> len += n ; } break ; case WASM_OP_I64CONST : { st64 val = 0 ; size_t n = read_i64_leb128 ( buf + 1 , buf + buf_len , & val ) ; if ( ! ( n > 0 && n < buf_len ) ) goto err ; snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>%"" PFMT64d , opdef -> txt , val ) ; op -> len += n ; } break ; case WASM_OP_F32CONST : { ut32 val = 0 ; size_t n = read_u32_leb128 ( buf + 1 , buf + buf_len , & val ) ; if ( ! ( n > 0 && n < buf_len ) ) goto err ; long double d = ( long double ) val ; snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>%"" LDBLFMT , opdef -> txt , d ) ; op -> len += n ; } break ; case WASM_OP_F64CONST : { ut64 val = 0 ; size_t n = read_u64_leb128 ( buf + 1 , buf + buf_len , & val ) ; if ( ! ( n > 0 && n < buf_len ) ) goto err ; long double d = ( long double ) val ; snprintf ( op -> txt , R_ASM_BUFSIZE , ""%s<S2SV_blank>%"" LDBLFMT , opdef -> txt , d ) ; op -> len += n ; } break ; default : goto err ; } return op -> len ; err : op -> len = 1 ; snprintf ( op -> txt , R_ASM_BUFSIZE , ""invalid"" ) ; return op -> len ; }","> 0xbf ) { <S2SV_ModStart> return 1 ; } <S2SV_ModStart> buf_len ) ) { <S2SV_ModStart> goto err ; } <S2SV_ModStart> ) ) ) { <S2SV_ModStart> goto err ; } <S2SV_ModStart> buf_len ) ) { <S2SV_ModStart> goto beach ; } <S2SV_ModStart> buf_len ) ) { <S2SV_ModStart> goto beach ; } <S2SV_ModStart> -> txt ) + 10 <S2SV_ModStart> ++ ) { int optxtlen = strlen ( op -> txt ) ; <S2SV_ModStart> -> txt + optxtlen , R_ASM_BUFSIZE - optxtlen <S2SV_ModEnd> , ""%d<S2SV_blank>"" ,"
502,"static void ecryptfs_decode_from_filename ( unsigned char * dst , size_t * dst_size , const unsigned char * src , size_t src_size ) { u8 current_bit_offset = 0 ; size_t src_byte_offset = 0 ; size_t dst_byte_offset = 0 ; if ( dst == NULL ) { ( * dst_size ) = ecryptfs_max_decoded_size ( src_size ) ; goto out ; } while ( src_byte_offset < src_size ) { unsigned char src_byte = filename_rev_map [ ( int ) src [ src_byte_offset ] ] ; switch ( current_bit_offset ) { case 0 : dst [ dst_byte_offset ] = ( src_byte << 2 ) ; current_bit_offset = 6 ; break ; case 6 : dst [ dst_byte_offset ++ ] |= ( src_byte >> 4 ) ; dst [ dst_byte_offset ] = ( ( src_byte & 0xF ) << 4 ) ; current_bit_offset = 4 ; break ; case 4 : dst [ dst_byte_offset ++ ] |= ( src_byte >> 2 ) ; dst [ dst_byte_offset ] = ( src_byte << 6 ) ; current_bit_offset = 2 ; break ; case 2 : dst [ dst_byte_offset ++ ] |= ( src_byte ) ; <S2SV_StartBug> dst [ dst_byte_offset ] = 0 ; <S2SV_EndBug> current_bit_offset = 0 ; break ; } src_byte_offset ++ ; } ( * dst_size ) = dst_byte_offset ; out : return ; }",src_byte ) ; <S2SV_ModEnd> current_bit_offset = 0
503,"static int zipfileUpdate ( sqlite3_vtab * pVtab , int nVal , sqlite3_value * * apVal , sqlite_int64 * pRowid ) { ZipfileTab * pTab = ( ZipfileTab * ) pVtab ; int rc = SQLITE_OK ; ZipfileEntry * pNew = 0 ; u32 mode = 0 ; u32 mTime = 0 ; i64 sz = 0 ; const char * zPath = 0 ; int nPath = 0 ; const u8 * pData = 0 ; int nData = 0 ; int iMethod = 0 ; u8 * pFree = 0 ; char * zFree = 0 ; ZipfileEntry * pOld = 0 ; ZipfileEntry * pOld2 = 0 ; int bUpdate = 0 ; int bIsDir = 0 ; u32 iCrc32 = 0 ; if ( pTab -> pWriteFd == 0 ) { rc = zipfileBegin ( pVtab ) ; if ( rc != SQLITE_OK ) return rc ; } if ( sqlite3_value_type ( apVal [ 0 ] ) != SQLITE_NULL ) { const char * zDelete = ( const char * ) sqlite3_value_text ( apVal [ 0 ] ) ; int nDelete = ( int ) strlen ( zDelete ) ; if ( nVal > 1 ) { const char * zUpdate = ( const char * ) sqlite3_value_text ( apVal [ 1 ] ) ; if ( zUpdate && zipfileComparePath ( zUpdate , zDelete , nDelete ) != 0 ) { bUpdate = 1 ; } } for ( pOld = pTab -> pFirstEntry ; 1 ; pOld = pOld -> pNext ) { if ( zipfileComparePath ( pOld -> cds . zFile , zDelete , nDelete ) == 0 ) { break ; } assert ( pOld -> pNext ) ; } } if ( nVal > 1 ) { if ( sqlite3_value_type ( apVal [ 5 ] ) != SQLITE_NULL ) { zipfileTableErr ( pTab , ""sz<S2SV_blank>must<S2SV_blank>be<S2SV_blank>NULL"" ) ; rc = SQLITE_CONSTRAINT ; } if ( sqlite3_value_type ( apVal [ 6 ] ) != SQLITE_NULL ) { zipfileTableErr ( pTab , ""rawdata<S2SV_blank>must<S2SV_blank>be<S2SV_blank>NULL"" ) ; rc = SQLITE_CONSTRAINT ; } if ( rc == SQLITE_OK ) { if ( sqlite3_value_type ( apVal [ 7 ] ) == SQLITE_NULL ) { bIsDir = 1 ; } else { const u8 * aIn = sqlite3_value_blob ( apVal [ 7 ] ) ; int nIn = sqlite3_value_bytes ( apVal [ 7 ] ) ; int bAuto = sqlite3_value_type ( apVal [ 8 ] ) == SQLITE_NULL ; iMethod = sqlite3_value_int ( apVal [ 8 ] ) ; sz = nIn ; pData = aIn ; nData = nIn ; if ( iMethod != 0 && iMethod != 8 ) { zipfileTableErr ( pTab , ""unknown<S2SV_blank>compression<S2SV_blank>method:<S2SV_blank>%d"" , iMethod ) ; rc = SQLITE_CONSTRAINT ; } else { if ( bAuto || iMethod ) { int nCmp ; rc = zipfileDeflate ( aIn , nIn , & pFree , & nCmp , & pTab -> base . zErrMsg ) ; if ( rc == SQLITE_OK ) { if ( iMethod || nCmp < nIn ) { iMethod = 8 ; pData = pFree ; nData = nCmp ; } } } iCrc32 = crc32 ( 0 , aIn , nIn ) ; } } } if ( rc == SQLITE_OK ) { rc = zipfileGetMode ( apVal [ 3 ] , bIsDir , & mode , & pTab -> base . zErrMsg ) ; } if ( rc == SQLITE_OK ) { zPath = ( const char * ) sqlite3_value_text ( apVal [ 2 ] ) ; if ( zPath == 0 ) zPath = """" ; nPath = ( int ) strlen ( zPath ) ; mTime = zipfileGetTime ( apVal [ 4 ] ) ; } if ( rc == SQLITE_OK && bIsDir ) { if ( zPath [ nPath - 1 ] != '/' ) { zFree = sqlite3_mprintf ( ""%s/"" , zPath ) ; if ( zFree == 0 ) { rc = SQLITE_NOMEM ; } zPath = ( const char * ) zFree ; <S2SV_StartBug> nPath ++ ; <S2SV_EndBug> } } if ( ( pOld == 0 || bUpdate ) && rc == SQLITE_OK ) { ZipfileEntry * p ; for ( p = pTab -> pFirstEntry ; p ; p = p -> pNext ) { if ( zipfileComparePath ( p -> cds . zFile , zPath , nPath ) == 0 ) { switch ( sqlite3_vtab_on_conflict ( pTab -> db ) ) { case SQLITE_IGNORE : { goto zipfile_update_done ; } case SQLITE_REPLACE : { pOld2 = p ; break ; } default : { zipfileTableErr ( pTab , ""duplicate<S2SV_blank>name:<S2SV_blank>\\""%s\\"""" , zPath ) ; rc = SQLITE_CONSTRAINT ; break ; } } break ; } } } if ( rc == SQLITE_OK ) { pNew = zipfileNewEntry ( zPath ) ; if ( pNew == 0 ) { rc = SQLITE_NOMEM ; } else { pNew -> cds . iVersionMadeBy = ZIPFILE_NEWENTRY_MADEBY ; pNew -> cds . iVersionExtract = ZIPFILE_NEWENTRY_REQUIRED ; pNew -> cds . flags = ZIPFILE_NEWENTRY_FLAGS ; pNew -> cds . iCompression = ( u16 ) iMethod ; zipfileMtimeToDos ( & pNew -> cds , mTime ) ; pNew -> cds . crc32 = iCrc32 ; pNew -> cds . szCompressed = nData ; pNew -> cds . szUncompressed = ( u32 ) sz ; pNew -> cds . iExternalAttr = ( mode << 16 ) ; pNew -> cds . iOffset = ( u32 ) pTab -> szCurrent ; pNew -> cds . nFile = ( u16 ) nPath ; pNew -> mUnixTime = ( u32 ) mTime ; rc = zipfileAppendEntry ( pTab , pNew , pData , nData ) ; zipfileAddEntry ( pTab , pOld , pNew ) ; } } } if ( rc == SQLITE_OK && ( pOld || pOld2 ) ) { ZipfileCsr * pCsr ; for ( pCsr = pTab -> pCsrList ; pCsr ; pCsr = pCsr -> pCsrNext ) { if ( pCsr -> pCurrent && ( pCsr -> pCurrent == pOld || pCsr -> pCurrent == pOld2 ) ) { pCsr -> pCurrent = pCsr -> pCurrent -> pNext ; pCsr -> bNoop = 1 ; } } zipfileRemoveEntryFromList ( pTab , pOld ) ; zipfileRemoveEntryFromList ( pTab , pOld2 ) ; } zipfile_update_done : sqlite3_free ( pFree ) ; sqlite3_free ( zFree ) ; return rc ; }",zFree ; nPath = ( int ) strlen ( zPath ) <S2SV_ModEnd> ; } }
504,"void bn_mul_comba8 ( BN_ULONG * r , BN_ULONG * a , BN_ULONG * b ) { <S2SV_StartBug> BN_ULONG t1 , t2 ; <S2SV_EndBug> BN_ULONG c1 , c2 , c3 ; c1 = 0 ; c2 = 0 ; c3 = 0 ; mul_add_c ( a [ 0 ] , b [ 0 ] , c1 , c2 , c3 ) ; r [ 0 ] = c1 ; c1 = 0 ; mul_add_c ( a [ 0 ] , b [ 1 ] , c2 , c3 , c1 ) ; mul_add_c ( a [ 1 ] , b [ 0 ] , c2 , c3 , c1 ) ; r [ 1 ] = c2 ; c2 = 0 ; mul_add_c ( a [ 2 ] , b [ 0 ] , c3 , c1 , c2 ) ; mul_add_c ( a [ 1 ] , b [ 1 ] , c3 , c1 , c2 ) ; mul_add_c ( a [ 0 ] , b [ 2 ] , c3 , c1 , c2 ) ; r [ 2 ] = c3 ; c3 = 0 ; mul_add_c ( a [ 0 ] , b [ 3 ] , c1 , c2 , c3 ) ; mul_add_c ( a [ 1 ] , b [ 2 ] , c1 , c2 , c3 ) ; mul_add_c ( a [ 2 ] , b [ 1 ] , c1 , c2 , c3 ) ; mul_add_c ( a [ 3 ] , b [ 0 ] , c1 , c2 , c3 ) ; r [ 3 ] = c1 ; c1 = 0 ; mul_add_c ( a [ 4 ] , b [ 0 ] , c2 , c3 , c1 ) ; mul_add_c ( a [ 3 ] , b [ 1 ] , c2 , c3 , c1 ) ; mul_add_c ( a [ 2 ] , b [ 2 ] , c2 , c3 , c1 ) ; mul_add_c ( a [ 1 ] , b [ 3 ] , c2 , c3 , c1 ) ; mul_add_c ( a [ 0 ] , b [ 4 ] , c2 , c3 , c1 ) ; r [ 4 ] = c2 ; c2 = 0 ; mul_add_c ( a [ 0 ] , b [ 5 ] , c3 , c1 , c2 ) ; mul_add_c ( a [ 1 ] , b [ 4 ] , c3 , c1 , c2 ) ; mul_add_c ( a [ 2 ] , b [ 3 ] , c3 , c1 , c2 ) ; mul_add_c ( a [ 3 ] , b [ 2 ] , c3 , c1 , c2 ) ; mul_add_c ( a [ 4 ] , b [ 1 ] , c3 , c1 , c2 ) ; mul_add_c ( a [ 5 ] , b [ 0 ] , c3 , c1 , c2 ) ; r [ 5 ] = c3 ; c3 = 0 ; mul_add_c ( a [ 6 ] , b [ 0 ] , c1 , c2 , c3 ) ; mul_add_c ( a [ 5 ] , b [ 1 ] , c1 , c2 , c3 ) ; mul_add_c ( a [ 4 ] , b [ 2 ] , c1 , c2 , c3 ) ; mul_add_c ( a [ 3 ] , b [ 3 ] , c1 , c2 , c3 ) ; mul_add_c ( a [ 2 ] , b [ 4 ] , c1 , c2 , c3 ) ; mul_add_c ( a [ 1 ] , b [ 5 ] , c1 , c2 , c3 ) ; mul_add_c ( a [ 0 ] , b [ 6 ] , c1 , c2 , c3 ) ; r [ 6 ] = c1 ; c1 = 0 ; mul_add_c ( a [ 0 ] , b [ 7 ] , c2 , c3 , c1 ) ; mul_add_c ( a [ 1 ] , b [ 6 ] , c2 , c3 , c1 ) ; mul_add_c ( a [ 2 ] , b [ 5 ] , c2 , c3 , c1 ) ; mul_add_c ( a [ 3 ] , b [ 4 ] , c2 , c3 , c1 ) ; mul_add_c ( a [ 4 ] , b [ 3 ] , c2 , c3 , c1 ) ; mul_add_c ( a [ 5 ] , b [ 2 ] , c2 , c3 , c1 ) ; mul_add_c ( a [ 6 ] , b [ 1 ] , c2 , c3 , c1 ) ; mul_add_c ( a [ 7 ] , b [ 0 ] , c2 , c3 , c1 ) ; r [ 7 ] = c2 ; c2 = 0 ; mul_add_c ( a [ 7 ] , b [ 1 ] , c3 , c1 , c2 ) ; mul_add_c ( a [ 6 ] , b [ 2 ] , c3 , c1 , c2 ) ; mul_add_c ( a [ 5 ] , b [ 3 ] , c3 , c1 , c2 ) ; mul_add_c ( a [ 4 ] , b [ 4 ] , c3 , c1 , c2 ) ; mul_add_c ( a [ 3 ] , b [ 5 ] , c3 , c1 , c2 ) ; mul_add_c ( a [ 2 ] , b [ 6 ] , c3 , c1 , c2 ) ; mul_add_c ( a [ 1 ] , b [ 7 ] , c3 , c1 , c2 ) ; r [ 8 ] = c3 ; c3 = 0 ; mul_add_c ( a [ 2 ] , b [ 7 ] , c1 , c2 , c3 ) ; mul_add_c ( a [ 3 ] , b [ 6 ] , c1 , c2 , c3 ) ; mul_add_c ( a [ 4 ] , b [ 5 ] , c1 , c2 , c3 ) ; mul_add_c ( a [ 5 ] , b [ 4 ] , c1 , c2 , c3 ) ; mul_add_c ( a [ 6 ] , b [ 3 ] , c1 , c2 , c3 ) ; mul_add_c ( a [ 7 ] , b [ 2 ] , c1 , c2 , c3 ) ; r [ 9 ] = c1 ; c1 = 0 ; mul_add_c ( a [ 7 ] , b [ 3 ] , c2 , c3 , c1 ) ; mul_add_c ( a [ 6 ] , b [ 4 ] , c2 , c3 , c1 ) ; mul_add_c ( a [ 5 ] , b [ 5 ] , c2 , c3 , c1 ) ; mul_add_c ( a [ 4 ] , b [ 6 ] , c2 , c3 , c1 ) ; mul_add_c ( a [ 3 ] , b [ 7 ] , c2 , c3 , c1 ) ; r [ 10 ] = c2 ; c2 = 0 ; mul_add_c ( a [ 4 ] , b [ 7 ] , c3 , c1 , c2 ) ; mul_add_c ( a [ 5 ] , b [ 6 ] , c3 , c1 , c2 ) ; mul_add_c ( a [ 6 ] , b [ 5 ] , c3 , c1 , c2 ) ; mul_add_c ( a [ 7 ] , b [ 4 ] , c3 , c1 , c2 ) ; r [ 11 ] = c3 ; c3 = 0 ; mul_add_c ( a [ 7 ] , b [ 5 ] , c1 , c2 , c3 ) ; mul_add_c ( a [ 6 ] , b [ 6 ] , c1 , c2 , c3 ) ; mul_add_c ( a [ 5 ] , b [ 7 ] , c1 , c2 , c3 ) ; r [ 12 ] = c1 ; c1 = 0 ; mul_add_c ( a [ 6 ] , b [ 7 ] , c2 , c3 , c1 ) ; mul_add_c ( a [ 7 ] , b [ 6 ] , c2 , c3 , c1 ) ; r [ 13 ] = c2 ; c2 = 0 ; mul_add_c ( a [ 7 ] , b [ 7 ] , c3 , c1 , c2 ) ; r [ 14 ] = c3 ; r [ 15 ] = c1 ; }",") { BN_ULONG <S2SV_ModEnd> c1 , c2"
505,"static int get_registers ( pegasus_t * pegasus , __u16 indx , __u16 size , void * data ) { <S2SV_StartBug> int ret ; <S2SV_EndBug> ret = usb_control_msg ( pegasus -> usb , usb_rcvctrlpipe ( pegasus -> usb , 0 ) , PEGASUS_REQ_GET_REGS , PEGASUS_REQT_READ , 0 , <S2SV_StartBug> indx , data , size , 1000 ) ; <S2SV_EndBug> if ( ret < 0 ) netif_dbg ( pegasus , drv , pegasus -> net , ""%s<S2SV_blank>returned<S2SV_blank>%d\\n"" , __func__ , ret ) ; <S2SV_StartBug> return ret ; <S2SV_EndBug> }","data ) { u8 * buf ; int ret ; buf = kmalloc ( size , GFP_NOIO ) ; if ( ! buf ) return - ENOMEM <S2SV_ModEnd> ; ret = <S2SV_ModStart> , indx , buf <S2SV_ModEnd> , size , <S2SV_ModStart> ret ) ; else if ( ret <= size ) memcpy ( data , buf , ret ) ; kfree ( buf ) ;"
506,"static GstFlowReturn gst_asf_demux_process_ext_content_desc ( GstASFDemux * demux , guint8 * data , guint64 size ) { GstTagList * taglist ; guint16 blockcount , i ; gboolean content3D = FALSE ; struct { const gchar * interleave_name ; GstASF3DMode interleaving_type ; } stereoscopic_layout_map [ ] = { { ""SideBySideRF"" , GST_ASF_3D_SIDE_BY_SIDE_HALF_RL } , { ""SideBySideLF"" , GST_ASF_3D_SIDE_BY_SIDE_HALF_LR } , { ""OverUnderRT"" , GST_ASF_3D_TOP_AND_BOTTOM_HALF_RL } , { ""OverUnderLT"" , GST_ASF_3D_TOP_AND_BOTTOM_HALF_LR } , { ""DualStream"" , GST_ASF_3D_DUAL_STREAM } } ; GST_INFO_OBJECT ( demux , ""object<S2SV_blank>is<S2SV_blank>an<S2SV_blank>extended<S2SV_blank>content<S2SV_blank>description"" ) ; taglist = gst_tag_list_new_empty ( ) ; if ( size < 2 ) goto not_enough_data ; blockcount = gst_asf_demux_get_uint16 ( & data , & size ) ; for ( i = 1 ; i <= blockcount ; ++ i ) { const gchar * gst_tag_name ; guint16 datatype ; guint16 value_len ; guint16 name_len ; GValue tag_value = { 0 , } ; gsize in , out ; gchar * name ; gchar * name_utf8 = NULL ; gchar * value ; if ( ! gst_asf_demux_get_string ( & name , & name_len , & data , & size ) ) goto not_enough_data ; if ( size < 2 ) { g_free ( name ) ; goto not_enough_data ; } datatype = gst_asf_demux_get_uint16 ( & data , & size ) ; if ( ! gst_asf_demux_get_string ( & value , & value_len , & data , & size ) ) { g_free ( name ) ; goto not_enough_data ; } name_utf8 = g_convert ( name , name_len , ""UTF-8"" , ""UTF-16LE"" , & in , & out , NULL ) ; if ( name_utf8 != NULL ) { GST_DEBUG ( ""Found<S2SV_blank>tag/metadata<S2SV_blank>%s"" , name_utf8 ) ; gst_tag_name = gst_asf_demux_get_gst_tag_from_tag_name ( name_utf8 ) ; GST_DEBUG ( ""gst_tag_name<S2SV_blank>%s"" , GST_STR_NULL ( gst_tag_name ) ) ; switch ( datatype ) { case ASF_DEMUX_DATA_TYPE_UTF16LE_STRING : { gchar * value_utf8 ; value_utf8 = g_convert ( value , value_len , ""UTF-8"" , ""UTF-16LE"" , & in , & out , NULL ) ; if ( value_utf8 != NULL && * value_utf8 != '\\0' ) { GST_DEBUG ( ""string<S2SV_blank>value<S2SV_blank>%s"" , value_utf8 ) ; value_utf8 [ out ] = '\\0' ; if ( gst_tag_name != NULL ) { if ( strcmp ( gst_tag_name , GST_TAG_DATE_TIME ) == 0 ) { guint year = atoi ( value_utf8 ) ; if ( year > 0 ) { g_value_init ( & tag_value , GST_TYPE_DATE_TIME ) ; g_value_take_boxed ( & tag_value , gst_date_time_new_y ( year ) ) ; } } else if ( strcmp ( gst_tag_name , GST_TAG_GENRE ) == 0 ) { guint id3v1_genre_id ; const gchar * genre_str ; if ( sscanf ( value_utf8 , ""(%u)"" , & id3v1_genre_id ) == 1 && ( ( genre_str = gst_tag_id3_genre_get ( id3v1_genre_id ) ) ) ) { GST_DEBUG ( ""Genre:<S2SV_blank>%s<S2SV_blank>-><S2SV_blank>%s"" , value_utf8 , genre_str ) ; g_free ( value_utf8 ) ; value_utf8 = g_strdup ( genre_str ) ; } } else { GType tag_type ; tag_type = gst_tag_get_type ( gst_tag_name ) ; g_value_init ( & tag_value , tag_type ) ; if ( ! gst_value_deserialize ( & tag_value , value_utf8 ) ) { GValue from_val = { 0 , } ; g_value_init ( & from_val , G_TYPE_STRING ) ; g_value_set_string ( & from_val , value_utf8 ) ; if ( ! g_value_transform ( & from_val , & tag_value ) ) { GST_WARNING_OBJECT ( demux , ""Could<S2SV_blank>not<S2SV_blank>transform<S2SV_blank>string<S2SV_blank>tag<S2SV_blank>to<S2SV_blank>"" ""%s<S2SV_blank>tag<S2SV_blank>type<S2SV_blank>%s"" , gst_tag_name , g_type_name ( tag_type ) ) ; g_value_unset ( & tag_value ) ; } g_value_unset ( & from_val ) ; } } } else { GST_DEBUG ( ""Setting<S2SV_blank>metadata"" ) ; g_value_init ( & tag_value , G_TYPE_STRING ) ; g_value_set_string ( & tag_value , value_utf8 ) ; if ( content3D ) { guint i ; if ( strncmp ( ""StereoscopicLayout"" , name_utf8 , strlen ( name_utf8 ) ) == 0 ) { for ( i = 0 ; i < G_N_ELEMENTS ( stereoscopic_layout_map ) ; i ++ ) { if ( g_str_equal ( stereoscopic_layout_map [ i ] . interleave_name , value_utf8 ) ) { demux -> asf_3D_mode = stereoscopic_layout_map [ i ] . interleaving_type ; GST_INFO ( ""find<S2SV_blank>interleave<S2SV_blank>type<S2SV_blank>%u"" , demux -> asf_3D_mode ) ; } } } GST_INFO_OBJECT ( demux , ""3d<S2SV_blank>type<S2SV_blank>is<S2SV_blank>%u"" , demux -> asf_3D_mode ) ; } else { demux -> asf_3D_mode = GST_ASF_3D_NONE ; GST_INFO_OBJECT ( demux , ""None<S2SV_blank>3d<S2SV_blank>type"" ) ; } } } else if ( value_utf8 == NULL ) { GST_WARNING ( ""Failed<S2SV_blank>to<S2SV_blank>convert<S2SV_blank>string<S2SV_blank>value<S2SV_blank>to<S2SV_blank>UTF8,<S2SV_blank>skipping"" ) ; } else { GST_DEBUG ( ""Skipping<S2SV_blank>empty<S2SV_blank>string<S2SV_blank>value<S2SV_blank>for<S2SV_blank>%s"" , GST_STR_NULL ( gst_tag_name ) ) ; } g_free ( value_utf8 ) ; break ; } case ASF_DEMUX_DATA_TYPE_BYTE_ARRAY : { if ( gst_tag_name ) { if ( ! g_str_equal ( gst_tag_name , GST_TAG_IMAGE ) ) { GST_FIXME ( ""Unhandled<S2SV_blank>byte<S2SV_blank>array<S2SV_blank>tag<S2SV_blank>%s"" , GST_STR_NULL ( gst_tag_name ) ) ; break ; } else { asf_demux_parse_picture_tag ( taglist , ( guint8 * ) value , value_len ) ; } } break ; } case ASF_DEMUX_DATA_TYPE_DWORD : { <S2SV_StartBug> guint uint_val = GST_READ_UINT32_LE ( value ) ; <S2SV_EndBug> g_value_init ( & tag_value , G_TYPE_UINT ) ; if ( ! strcmp ( name_utf8 , ""WM/Track"" ) ) ++ uint_val ; g_value_set_uint ( & tag_value , uint_val ) ; break ; } case ASF_DEMUX_DATA_TYPE_BOOL : { <S2SV_StartBug> gboolean bool_val = GST_READ_UINT32_LE ( value ) ; <S2SV_EndBug> if ( strncmp ( ""Stereoscopic"" , name_utf8 , strlen ( name_utf8 ) ) == 0 ) { if ( bool_val ) { GST_INFO_OBJECT ( demux , ""This<S2SV_blank>is<S2SV_blank>3D<S2SV_blank>contents"" ) ; content3D = TRUE ; } else { GST_INFO_OBJECT ( demux , ""This<S2SV_blank>is<S2SV_blank>not<S2SV_blank>3D<S2SV_blank>contenst"" ) ; content3D = FALSE ; } } break ; } default : { GST_DEBUG ( ""Skipping<S2SV_blank>tag<S2SV_blank>%s<S2SV_blank>of<S2SV_blank>type<S2SV_blank>%d"" , gst_tag_name , datatype ) ; break ; } } if ( G_IS_VALUE ( & tag_value ) ) { if ( gst_tag_name ) { GstTagMergeMode merge_mode = GST_TAG_MERGE_APPEND ; if ( strcmp ( name_utf8 , ""WM/TrackNumber"" ) == 0 ) merge_mode = GST_TAG_MERGE_REPLACE ; gst_tag_list_add_values ( taglist , merge_mode , gst_tag_name , & tag_value , NULL ) ; } else { GST_DEBUG ( ""Setting<S2SV_blank>global<S2SV_blank>metadata<S2SV_blank>%s"" , name_utf8 ) ; gst_structure_set_value ( demux -> global_metadata , name_utf8 , & tag_value ) ; } g_value_unset ( & tag_value ) ; } } g_free ( name ) ; g_free ( value ) ; g_free ( name_utf8 ) ; } gst_asf_demux_add_global_tags ( demux , taglist ) ; return GST_FLOW_OK ; not_enough_data : { GST_WARNING ( ""Unexpected<S2SV_blank>end<S2SV_blank>of<S2SV_blank>data<S2SV_blank>parsing<S2SV_blank>ext<S2SV_blank>content<S2SV_blank>desc<S2SV_blank>object"" ) ; gst_tag_list_unref ( taglist ) ; return GST_FLOW_OK ; } }",{ guint uint_val ; if ( value_len < 4 ) break ; uint_val <S2SV_ModStart> { gboolean bool_val ; if ( value_len < 4 ) break ; bool_val
507,"static int nsv_read_chunk ( AVFormatContext * s , int fill_header ) { NSVContext * nsv = s -> priv_data ; AVIOContext * pb = s -> pb ; AVStream * st [ 2 ] = { NULL , NULL } ; NSVStream * nst ; AVPacket * pkt ; int i , err = 0 ; uint8_t auxcount ; uint32_t vsize ; uint16_t asize ; <S2SV_StartBug> uint16_t auxsize ; <S2SV_EndBug> if ( nsv -> ahead [ 0 ] . data || nsv -> ahead [ 1 ] . data ) return 0 ; null_chunk_retry : if ( pb -> eof_reached ) return - 1 ; for ( i = 0 ; i < NSV_MAX_RESYNC_TRIES && nsv -> state < NSV_FOUND_NSVS && ! err ; i ++ ) err = nsv_resync ( s ) ; if ( err < 0 ) return err ; if ( nsv -> state == NSV_FOUND_NSVS ) err = nsv_parse_NSVs_header ( s ) ; if ( err < 0 ) return err ; if ( nsv -> state != NSV_HAS_READ_NSVS && nsv -> state != NSV_FOUND_BEEF ) return - 1 ; auxcount = avio_r8 ( pb ) ; vsize = avio_rl16 ( pb ) ; asize = avio_rl16 ( pb ) ; vsize = ( vsize << 4 ) | ( auxcount >> 4 ) ; auxcount &= 0x0f ; av_log ( s , AV_LOG_TRACE , ""NSV<S2SV_blank>CHUNK<S2SV_blank>%"" PRIu8 ""<S2SV_blank>aux,<S2SV_blank>%"" PRIu32 ""<S2SV_blank>bytes<S2SV_blank>video,<S2SV_blank>%"" PRIu16 ""<S2SV_blank>bytes<S2SV_blank>audio\\n"" , auxcount , vsize , asize ) ; for ( i = 0 ; i < auxcount ; i ++ ) { uint32_t av_unused auxtag ; auxsize = avio_rl16 ( pb ) ; auxtag = avio_rl32 ( pb ) ; avio_skip ( pb , auxsize ) ; vsize -= auxsize + sizeof ( uint16_t ) + sizeof ( uint32_t ) ; } if ( pb -> eof_reached ) return - 1 ; if ( ! vsize && ! asize ) { nsv -> state = NSV_UNSYNC ; goto null_chunk_retry ; } if ( s -> nb_streams > 0 ) st [ s -> streams [ 0 ] -> id ] = s -> streams [ 0 ] ; if ( s -> nb_streams > 1 ) st [ s -> streams [ 1 ] -> id ] = s -> streams [ 1 ] ; if ( vsize && st [ NSV_ST_VIDEO ] ) { nst = st [ NSV_ST_VIDEO ] -> priv_data ; pkt = & nsv -> ahead [ NSV_ST_VIDEO ] ; <S2SV_StartBug> av_get_packet ( pb , pkt , vsize ) ; <S2SV_EndBug> pkt -> stream_index = st [ NSV_ST_VIDEO ] -> index ; pkt -> dts = nst -> frame_offset ; pkt -> flags |= nsv -> state == NSV_HAS_READ_NSVS ? AV_PKT_FLAG_KEY : 0 ; for ( i = 0 ; i < FFMIN ( 8 , vsize ) ; i ++ ) av_log ( s , AV_LOG_TRACE , ""NSV<S2SV_blank>video:<S2SV_blank>[%d]<S2SV_blank>=<S2SV_blank>%02"" PRIx8 ""\\n"" , i , pkt -> data [ i ] ) ; } if ( st [ NSV_ST_VIDEO ] ) ( ( NSVStream * ) st [ NSV_ST_VIDEO ] -> priv_data ) -> frame_offset ++ ; if ( asize && st [ NSV_ST_AUDIO ] ) { nst = st [ NSV_ST_AUDIO ] -> priv_data ; pkt = & nsv -> ahead [ NSV_ST_AUDIO ] ; if ( asize && st [ NSV_ST_AUDIO ] -> codecpar -> codec_tag == MKTAG ( 'P' , 'C' , 'M' , '<S2SV_blank>' ) ) { uint8_t bps ; uint8_t channels ; uint16_t samplerate ; bps = avio_r8 ( pb ) ; channels = avio_r8 ( pb ) ; samplerate = avio_rl16 ( pb ) ; if ( ! channels || ! samplerate ) return AVERROR_INVALIDDATA ; asize -= 4 ; av_log ( s , AV_LOG_TRACE , ""NSV<S2SV_blank>RAWAUDIO:<S2SV_blank>bps<S2SV_blank>%"" PRIu8 "",<S2SV_blank>nchan<S2SV_blank>%"" PRIu8 "",<S2SV_blank>srate<S2SV_blank>%"" PRIu16 ""\\n"" , bps , channels , samplerate ) ; if ( fill_header ) { st [ NSV_ST_AUDIO ] -> need_parsing = AVSTREAM_PARSE_NONE ; if ( bps != 16 ) { av_log ( s , AV_LOG_TRACE , ""NSV<S2SV_blank>AUDIO<S2SV_blank>bit/sample<S2SV_blank>!=<S2SV_blank>16<S2SV_blank>(%"" PRIu8 "")!!!\\n"" , bps ) ; } bps /= channels ; if ( bps == 8 ) st [ NSV_ST_AUDIO ] -> codecpar -> codec_id = AV_CODEC_ID_PCM_U8 ; samplerate /= 4 ; channels = 1 ; st [ NSV_ST_AUDIO ] -> codecpar -> channels = channels ; st [ NSV_ST_AUDIO ] -> codecpar -> sample_rate = samplerate ; av_log ( s , AV_LOG_TRACE , ""NSV<S2SV_blank>RAWAUDIO:<S2SV_blank>bps<S2SV_blank>%"" PRIu8 "",<S2SV_blank>nchan<S2SV_blank>%"" PRIu8 "",<S2SV_blank>srate<S2SV_blank>%"" PRIu16 ""\\n"" , bps , channels , samplerate ) ; } } <S2SV_StartBug> av_get_packet ( pb , pkt , asize ) ; <S2SV_EndBug> pkt -> stream_index = st [ NSV_ST_AUDIO ] -> index ; pkt -> flags |= nsv -> state == NSV_HAS_READ_NSVS ? AV_PKT_FLAG_KEY : 0 ; if ( nsv -> state == NSV_HAS_READ_NSVS && st [ NSV_ST_VIDEO ] ) { pkt -> dts = ( ( ( NSVStream * ) st [ NSV_ST_VIDEO ] -> priv_data ) -> frame_offset - 1 ) ; pkt -> dts *= ( int64_t ) 1000 * nsv -> framerate . den ; pkt -> dts += ( int64_t ) nsv -> avsync * nsv -> framerate . num ; av_log ( s , AV_LOG_TRACE , ""NSV<S2SV_blank>AUDIO:<S2SV_blank>sync:%"" PRId16 "",<S2SV_blank>dts:%"" PRId64 , nsv -> avsync , pkt -> dts ) ; } nst -> frame_offset ++ ; } nsv -> state = NSV_UNSYNC ; return 0 ; }","; uint16_t auxsize ; int ret <S2SV_ModStart> NSV_ST_VIDEO ] ; if ( ( ret = <S2SV_ModStart> , vsize ) ) < 0 ) return ret <S2SV_ModStart> ; } } if ( ( ret = <S2SV_ModStart> , asize ) ) < 0 ) return ret"
508,"bool bt_att_cancel ( struct bt_att * att , unsigned int id ) { const struct queue_entry * entry ; struct att_send_op * op ; if ( ! att || ! id ) return false ; for ( entry = queue_get_entries ( att -> chans ) ; entry ; entry = entry -> next ) { struct bt_att_chan * chan = entry -> data ; if ( bt_att_chan_cancel ( chan , id ) ) return true ; } <S2SV_StartBug> op = queue_remove_if ( att -> req_queue , match_op_id , UINT_TO_PTR ( id ) ) ; <S2SV_EndBug> if ( op ) goto done ; op = queue_remove_if ( att -> ind_queue , match_op_id , UINT_TO_PTR ( id ) ) ; if ( op ) goto done ; op = queue_remove_if ( att -> write_queue , match_op_id , UINT_TO_PTR ( id ) ) ; if ( op ) goto done ; if ( ! op ) return false ; done : destroy_att_send_op ( op ) ; wakeup_writer ( att ) ; return true ; }","true ; } if ( att -> in_disc ) return bt_att_disc_cancel ( att , id ) ;"
509,"generic_ret * setkey_principal_2_svc ( setkey_arg * arg , struct svc_req * rqstp ) { static generic_ret ret ; char * prime_arg ; <S2SV_StartBug> gss_buffer_desc client_name , <S2SV_EndBug> service_name ; OM_uint32 minor_stat ; kadm5_server_handle_t handle ; const char * errmsg = NULL ; xdr_free ( xdr_generic_ret , & ret ) ; if ( ( ret . code = new_server_handle ( arg -> api_version , rqstp , & handle ) ) ) goto exit_func ; if ( ( ret . code = check_handle ( ( void * ) handle ) ) ) goto exit_func ; ret . api_version = handle -> api_version ; if ( setup_gss_names ( rqstp , & client_name , & service_name ) < 0 ) { ret . code = KADM5_FAILURE ; goto exit_func ; } if ( krb5_unparse_name ( handle -> context , arg -> princ , & prime_arg ) ) { ret . code = KADM5_BAD_PRINCIPAL ; goto exit_func ; } if ( ! ( CHANGEPW_SERVICE ( rqstp ) ) && kadm5int_acl_check ( handle -> context , rqst2name ( rqstp ) , ACL_SETKEY , arg -> princ , NULL ) ) { ret . code = kadm5_setkey_principal ( ( void * ) handle , arg -> princ , arg -> keyblocks , arg -> n_keys ) ; } else { log_unauth ( ""kadm5_setkey_principal"" , prime_arg , & client_name , & service_name , rqstp ) ; ret . code = KADM5_AUTH_SETKEY ; } if ( ret . code != KADM5_AUTH_SETKEY ) { if ( ret . code != 0 ) errmsg = krb5_get_error_message ( handle -> context , ret . code ) ; log_done ( ""kadm5_setkey_principal"" , prime_arg , errmsg , & client_name , & service_name , rqstp ) ; if ( errmsg != NULL ) krb5_free_error_message ( handle -> context , errmsg ) ; } free ( prime_arg ) ; <S2SV_StartBug> gss_release_buffer ( & minor_stat , & client_name ) ; <S2SV_EndBug> gss_release_buffer ( & minor_stat , & service_name ) ; <S2SV_StartBug> exit_func : <S2SV_EndBug> free_server_handle ( handle ) ; return & ret ; }",; gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER <S2SV_ModEnd> ; OM_uint32 minor_stat <S2SV_ModStart> prime_arg ) ; exit_func : <S2SV_ModStart> service_name ) ; <S2SV_ModEnd> free_server_handle ( handle
510,"static void sycc444_to_rgb ( opj_image_t * img ) { int * d0 , * d1 , * d2 , * r , * g , * b ; const int * y , * cb , * cr ; <S2SV_StartBug> unsigned int maxw , maxh , max , i ; <S2SV_EndBug> int offset , upb ; upb = ( int ) img -> comps [ 0 ] . prec ; offset = 1 << ( upb - 1 ) ; upb = ( 1 << upb ) - 1 ; <S2SV_StartBug> maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; <S2SV_EndBug> max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; <S2SV_StartBug> d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; <S2SV_EndBug> <S2SV_StartBug> d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; <S2SV_EndBug> <S2SV_StartBug> d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; <S2SV_EndBug> if ( r == NULL || g == NULL || b == NULL ) goto fails ; for ( i = 0U ; i < max ; ++ i ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ cb ; ++ cr ; ++ r ; ++ g ; ++ b ; } free ( img -> comps [ 0 ] . data ) ; img -> comps [ 0 ] . data = d0 ; free ( img -> comps [ 1 ] . data ) ; img -> comps [ 1 ] . data = d1 ; free ( img -> comps [ 2 ] . data ) ; img -> comps [ 2 ] . data = d2 ; <S2SV_StartBug> return ; <S2SV_EndBug> fails : <S2SV_StartBug> if ( r ) free ( r ) ; <S2SV_EndBug> if ( g ) free ( g ) ; if ( b ) free ( b ) ; }","* cr ; size_t <S2SV_ModEnd> maxw , maxh <S2SV_ModStart> maxw = ( size_t <S2SV_ModEnd> ) img -> <S2SV_ModStart> maxh = ( size_t <S2SV_ModEnd> ) img -> <S2SV_ModStart> int ) * <S2SV_ModEnd> max ) ; <S2SV_ModStart> int ) * <S2SV_ModEnd> max ) ; <S2SV_ModStart> int ) * <S2SV_ModEnd> max ) ; <S2SV_ModStart> = d2 ; img -> color_space = OPJ_CLRSPC_SRGB ; <S2SV_ModStart> ; fails : free ( r ) ; free ( g ) ; <S2SV_ModEnd> free ( b"
511,"static int asn1_decode_entry ( sc_context_t * ctx , struct sc_asn1_entry * entry , const u8 * obj , size_t objlen , int depth ) { void * parm = entry -> parm ; int ( * callback_func ) ( sc_context_t * nctx , void * arg , const u8 * nobj , size_t nobjlen , int ndepth ) ; size_t * len = ( size_t * ) entry -> arg ; int r = 0 ; callback_func = parm ; sc_debug ( ctx , SC_LOG_DEBUG_ASN1 , ""%*.*sdecoding<S2SV_blank>\'%s\',<S2SV_blank>raw<S2SV_blank>data:%s%s\\n"" , depth , depth , """" , entry -> name , sc_dump_hex ( obj , objlen > 16 ? 16 : objlen ) , objlen > 16 ? ""..."" : """" ) ; switch ( entry -> type ) { case SC_ASN1_STRUCT : if ( parm != NULL ) r = asn1_decode ( ctx , ( struct sc_asn1_entry * ) parm , obj , objlen , NULL , NULL , 0 , depth + 1 ) ; break ; case SC_ASN1_NULL : break ; case SC_ASN1_BOOLEAN : if ( parm != NULL ) { if ( objlen != 1 ) { sc_debug ( ctx , SC_LOG_DEBUG_ASN1 , ""invalid<S2SV_blank>ASN.1<S2SV_blank>object<S2SV_blank>length:<S2SV_blank>%"" SC_FORMAT_LEN_SIZE_T ""u\\n"" , objlen ) ; r = SC_ERROR_INVALID_ASN1_OBJECT ; } else * ( ( int * ) parm ) = obj [ 0 ] ? 1 : 0 ; } break ; case SC_ASN1_INTEGER : case SC_ASN1_ENUMERATED : if ( parm != NULL ) { r = sc_asn1_decode_integer ( obj , objlen , ( int * ) entry -> parm ) ; sc_debug ( ctx , SC_LOG_DEBUG_ASN1 , ""%*.*sdecoding<S2SV_blank>\'%s\'<S2SV_blank>returned<S2SV_blank>%d\\n"" , depth , depth , """" , entry -> name , * ( ( int * ) entry -> parm ) ) ; } break ; case SC_ASN1_BIT_STRING_NI : case SC_ASN1_BIT_STRING : if ( parm != NULL ) { int invert = entry -> type == SC_ASN1_BIT_STRING ? 1 : 0 ; assert ( len != NULL ) ; if ( objlen < 1 ) { r = SC_ERROR_INVALID_ASN1_OBJECT ; break ; } if ( entry -> flags & SC_ASN1_ALLOC ) { u8 * * buf = ( u8 * * ) parm ; * buf = malloc ( objlen - 1 ) ; if ( * buf == NULL ) { r = SC_ERROR_OUT_OF_MEMORY ; break ; } * len = objlen - 1 ; parm = * buf ; } r = decode_bit_string ( obj , objlen , ( u8 * ) parm , * len , invert ) ; if ( r >= 0 ) { * len = r ; r = 0 ; } } break ; case SC_ASN1_BIT_FIELD : if ( parm != NULL ) r = decode_bit_field ( obj , objlen , ( u8 * ) parm , * len ) ; break ; case SC_ASN1_OCTET_STRING : if ( parm != NULL ) { size_t c ; assert ( len != NULL ) ; if ( ( entry -> flags & SC_ASN1_UNSIGNED ) <S2SV_StartBug> && obj [ 0 ] == 0x00 && objlen > 1 ) { <S2SV_EndBug> objlen -- ; obj ++ ; } if ( entry -> flags & SC_ASN1_ALLOC ) { u8 * * buf = ( u8 * * ) parm ; * buf = malloc ( objlen ) ; if ( * buf == NULL ) { r = SC_ERROR_OUT_OF_MEMORY ; break ; } c = * len = objlen ; parm = * buf ; } else c = objlen > * len ? * len : objlen ; memcpy ( parm , obj , c ) ; * len = c ; } break ; case SC_ASN1_GENERALIZEDTIME : if ( parm != NULL ) { size_t c ; assert ( len != NULL ) ; if ( entry -> flags & SC_ASN1_ALLOC ) { u8 * * buf = ( u8 * * ) parm ; * buf = malloc ( objlen ) ; if ( * buf == NULL ) { r = SC_ERROR_OUT_OF_MEMORY ; break ; } c = * len = objlen ; parm = * buf ; } else c = objlen > * len ? * len : objlen ; memcpy ( parm , obj , c ) ; * len = c ; } break ; case SC_ASN1_OBJECT : if ( parm != NULL ) r = sc_asn1_decode_object_id ( obj , objlen , ( struct sc_object_id * ) parm ) ; break ; case SC_ASN1_PRINTABLESTRING : case SC_ASN1_UTF8STRING : if ( parm != NULL ) { assert ( len != NULL ) ; if ( entry -> flags & SC_ASN1_ALLOC ) { u8 * * buf = ( u8 * * ) parm ; * buf = malloc ( objlen + 1 ) ; if ( * buf == NULL ) { r = SC_ERROR_OUT_OF_MEMORY ; break ; } * len = objlen + 1 ; parm = * buf ; } r = sc_asn1_decode_utf8string ( obj , objlen , ( u8 * ) parm , len ) ; if ( entry -> flags & SC_ASN1_ALLOC ) { * len -= 1 ; } } break ; case SC_ASN1_PATH : if ( entry -> parm != NULL ) r = asn1_decode_path ( ctx , obj , objlen , ( sc_path_t * ) parm , depth ) ; break ; case SC_ASN1_PKCS15_ID : if ( entry -> parm != NULL ) { struct sc_pkcs15_id * id = ( struct sc_pkcs15_id * ) parm ; size_t c = objlen > sizeof ( id -> value ) ? sizeof ( id -> value ) : objlen ; memcpy ( id -> value , obj , c ) ; id -> len = c ; } break ; case SC_ASN1_PKCS15_OBJECT : if ( entry -> parm != NULL ) r = asn1_decode_p15_object ( ctx , obj , objlen , ( struct sc_asn1_pkcs15_object * ) parm , depth ) ; break ; case SC_ASN1_ALGORITHM_ID : if ( entry -> parm != NULL ) r = sc_asn1_decode_algorithm_id ( ctx , obj , objlen , ( struct sc_algorithm_id * ) parm , depth ) ; break ; case SC_ASN1_SE_INFO : if ( entry -> parm != NULL ) r = asn1_decode_se_info ( ctx , obj , objlen , ( sc_pkcs15_sec_env_info_t * * * ) entry -> parm , len , depth ) ; break ; case SC_ASN1_CALLBACK : if ( entry -> parm != NULL ) r = callback_func ( ctx , entry -> arg , obj , objlen , depth ) ; break ; default : sc_debug ( ctx , SC_LOG_DEBUG_ASN1 , ""invalid<S2SV_blank>ASN.1<S2SV_blank>type:<S2SV_blank>%d\\n"" , entry -> type ) ; return SC_ERROR_INVALID_ASN1_OBJECT ; } if ( r ) { sc_debug ( ctx , SC_LOG_DEBUG_ASN1 , ""decoding<S2SV_blank>of<S2SV_blank>ASN.1<S2SV_blank>object<S2SV_blank>\'%s\'<S2SV_blank>failed:<S2SV_blank>%s\\n"" , entry -> name , sc_strerror ( r ) ) ; return r ; } entry -> flags |= SC_ASN1_PRESENT ; return 0 ; }",SC_ASN1_UNSIGNED ) && objlen > 1 && <S2SV_ModStart> ] == 0x00 <S2SV_ModEnd> ) { objlen
512,"static struct page * follow_pmd_mask ( struct vm_area_struct * vma , unsigned long address , pud_t * pudp , unsigned int flags , struct follow_page_context * ctx ) { pmd_t * pmd , pmdval ; spinlock_t * ptl ; struct page * page ; struct mm_struct * mm = vma -> vm_mm ; pmd = pmd_offset ( pudp , address ) ; pmdval = READ_ONCE ( * pmd ) ; if ( pmd_none ( pmdval ) ) return no_page_table ( vma , flags ) ; if ( pmd_huge ( pmdval ) && vma -> vm_flags & VM_HUGETLB ) { page = follow_huge_pmd ( mm , address , pmd , flags ) ; if ( page ) return page ; return no_page_table ( vma , flags ) ; } if ( is_hugepd ( __hugepd ( pmd_val ( pmdval ) ) ) ) { page = follow_huge_pd ( vma , address , __hugepd ( pmd_val ( pmdval ) ) , flags , PMD_SHIFT ) ; if ( page ) return page ; return no_page_table ( vma , flags ) ; } retry : if ( ! pmd_present ( pmdval ) ) { if ( likely ( ! ( flags & FOLL_MIGRATION ) ) ) return no_page_table ( vma , flags ) ; VM_BUG_ON ( thp_migration_supported ( ) && ! is_pmd_migration_entry ( pmdval ) ) ; if ( is_pmd_migration_entry ( pmdval ) ) pmd_migration_entry_wait ( mm , pmd ) ; pmdval = READ_ONCE ( * pmd ) ; if ( pmd_none ( pmdval ) ) return no_page_table ( vma , flags ) ; goto retry ; } if ( pmd_devmap ( pmdval ) ) { ptl = pmd_lock ( mm , pmd ) ; page = follow_devmap_pmd ( vma , address , pmd , flags , & ctx -> pgmap ) ; spin_unlock ( ptl ) ; if ( page ) return page ; } if ( likely ( ! pmd_trans_huge ( pmdval ) ) ) return follow_page_pte ( vma , address , pmd , flags , & ctx -> pgmap ) ; if ( ( flags & FOLL_NUMA ) && pmd_protnone ( pmdval ) ) return no_page_table ( vma , flags ) ; retry_locked : ptl = pmd_lock ( mm , pmd ) ; if ( unlikely ( pmd_none ( * pmd ) ) ) { spin_unlock ( ptl ) ; return no_page_table ( vma , flags ) ; } if ( unlikely ( ! pmd_present ( * pmd ) ) ) { spin_unlock ( ptl ) ; if ( likely ( ! ( flags & FOLL_MIGRATION ) ) ) return no_page_table ( vma , flags ) ; pmd_migration_entry_wait ( mm , pmd ) ; goto retry_locked ; } if ( unlikely ( ! pmd_trans_huge ( * pmd ) ) ) { spin_unlock ( ptl ) ; return follow_page_pte ( vma , address , pmd , flags , & ctx -> pgmap ) ; } if ( flags & FOLL_SPLIT ) { int ret ; page = pmd_page ( * pmd ) ; if ( is_huge_zero_page ( page ) ) { spin_unlock ( ptl ) ; ret = 0 ; split_huge_pmd ( vma , pmd , address ) ; if ( pmd_trans_unstable ( pmd ) ) ret = - EBUSY ; } else { <S2SV_StartBug> get_page ( page ) ; <S2SV_EndBug> spin_unlock ( ptl ) ; lock_page ( page ) ; ret = split_huge_page ( page ) ; unlock_page ( page ) ; put_page ( page ) ; if ( pmd_none ( * pmd ) ) return no_page_table ( vma , flags ) ; } return ret ? ERR_PTR ( ret ) : follow_page_pte ( vma , address , pmd , flags , & ctx -> pgmap ) ; } page = follow_trans_huge_pmd ( vma , address , pmd , flags ) ; spin_unlock ( ptl ) ; ctx -> page_mask = HPAGE_PMD_NR - 1 ; return page ; }",} else { if ( unlikely ( ! try_get_page ( page ) ) ) { spin_unlock ( ptl ) ; return ERR_PTR ( - ENOMEM ) ; } <S2SV_ModEnd> spin_unlock ( ptl
513,void pid_ns_release_proc ( struct pid_namespace * ns ) { <S2SV_StartBug> mntput ( ns -> proc_mnt ) ; <S2SV_EndBug> },ns ) { kern_unmount <S2SV_ModEnd> ( ns ->
514,"static int reverseSamplesBytes ( uint16 spp , uint16 bps , uint32 width , uint8 * src , uint8 * dst ) { int i ; uint32 col , bytes_per_pixel , col_offset ; uint8 bytebuff1 ; unsigned char swapbuff [ 32 ] ; if ( ( src == NULL ) || ( dst == NULL ) ) { TIFFError ( ""reverseSamplesBytes"" , ""Invalid<S2SV_blank>input<S2SV_blank>or<S2SV_blank>output<S2SV_blank>buffer"" ) ; return ( 1 ) ; } bytes_per_pixel = ( ( bps * spp ) + 7 ) / 8 ; <S2SV_StartBug> switch ( bps / 8 ) <S2SV_EndBug> { case 8 : case 4 : case 3 : case 2 : for ( col = 0 ; col < ( width / 2 ) ; col ++ ) { col_offset = col * bytes_per_pixel ; _TIFFmemcpy ( swapbuff , src + col_offset , bytes_per_pixel ) ; _TIFFmemcpy ( src + col_offset , dst - col_offset - bytes_per_pixel , bytes_per_pixel ) ; _TIFFmemcpy ( dst - col_offset - bytes_per_pixel , swapbuff , bytes_per_pixel ) ; } break ; case 1 : for ( col = 0 ; col < ( width / 2 ) ; col ++ ) { for ( i = 0 ; i < spp ; i ++ ) { bytebuff1 = * src ; * src ++ = * ( dst - spp + i ) ; * ( dst - spp + i ) = bytebuff1 ; } dst -= spp ; } break ; default : TIFFError ( ""reverseSamplesBytes"" , ""Unsupported<S2SV_blank>bit<S2SV_blank>depth<S2SV_blank>%d"" , bps ) ; return ( 1 ) ; } return ( 0 ) ; }","/ 8 ; if ( bytes_per_pixel > sizeof ( swapbuff ) ) { TIFFError ( ""reverseSamplesBytes"" , ""bytes_per_pixel<S2SV_blank>too<S2SV_blank>large"" ) ; return ( 1 ) ; }"
515,"static void encode_frame ( struct stream_state * stream , struct VpxEncoderConfig * global , struct vpx_image * img , unsigned int frames_in ) { vpx_codec_pts_t frame_start , next_frame_start ; struct vpx_codec_enc_cfg * cfg = & stream -> config . cfg ; struct vpx_usec_timer timer ; frame_start = ( cfg -> g_timebase . den * ( int64_t ) ( frames_in - 1 ) * global -> framerate . den ) / cfg -> g_timebase . num / global -> framerate . num ; next_frame_start = ( cfg -> g_timebase . den * ( int64_t ) ( frames_in ) * global -> framerate . den ) / cfg -> g_timebase . num / global -> framerate . num ; <S2SV_StartBug> if ( img && ( img -> d_w != cfg -> g_w || img -> d_h != cfg -> g_h ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( ! stream -> img ) <S2SV_EndBug> <S2SV_StartBug> stream -> img = vpx_img_alloc ( NULL , VPX_IMG_FMT_I420 , <S2SV_EndBug> cfg -> g_w , cfg -> g_h , 16 ) ; I420Scale ( img -> planes [ VPX_PLANE_Y ] , img -> stride [ VPX_PLANE_Y ] , img -> planes [ VPX_PLANE_U ] , img -> stride [ VPX_PLANE_U ] , img -> planes [ VPX_PLANE_V ] , img -> stride [ VPX_PLANE_V ] , img -> d_w , img -> d_h , stream -> img -> planes [ VPX_PLANE_Y ] , stream -> img -> stride [ VPX_PLANE_Y ] , stream -> img -> planes [ VPX_PLANE_U ] , stream -> img -> stride [ VPX_PLANE_U ] , stream -> img -> planes [ VPX_PLANE_V ] , stream -> img -> stride [ VPX_PLANE_V ] , stream -> img -> d_w , stream -> img -> d_h , kFilterBox ) ; <S2SV_StartBug> img = stream -> img ; <S2SV_EndBug> } vpx_usec_timer_start ( & timer ) ; vpx_codec_encode ( & stream -> encoder , img , frame_start , ( unsigned long ) ( next_frame_start - frame_start ) , 0 , global -> deadline ) ; vpx_usec_timer_mark ( & timer ) ; stream -> cx_time += vpx_usec_timer_elapsed ( & timer ) ; ctx_exit_on_error ( & stream -> encoder , ""Stream<S2SV_blank>%d:<S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>encode<S2SV_blank>frame"" , stream -> index ) ; }",". num ; # if CONFIG_VP9_HIGHBITDEPTH if ( img ) { if ( ( img -> fmt & VPX_IMG_FMT_HIGHBITDEPTH ) <S2SV_ModEnd> && ( img <S2SV_ModStart> { if ( img -> fmt != VPX_IMG_FMT_I42016 ) { fprintf ( stderr , ""%s<S2SV_blank>can<S2SV_blank>only<S2SV_blank>scale<S2SV_blank>4:2:0<S2SV_blank>inputs\\n"" , exec_name ) ; exit ( EXIT_FAILURE ) ; } # if CONFIG_LIBYUV if ( <S2SV_ModStart> -> img ) { <S2SV_ModStart> ( NULL , VPX_IMG_FMT_I42016 , cfg -> g_w , cfg -> g_h , 16 ) ; } I420Scale_16 ( ( uint16 * ) img -> planes [ VPX_PLANE_Y ] , img -> stride [ VPX_PLANE_Y ] / 2 , ( uint16 * ) img -> planes [ VPX_PLANE_U ] , img -> stride [ VPX_PLANE_U ] / 2 , ( uint16 * ) img -> planes [ VPX_PLANE_V ] , img -> stride [ VPX_PLANE_V ] / 2 , img -> d_w , img -> d_h , ( uint16 * ) stream -> img -> planes [ VPX_PLANE_Y ] , stream -> img -> stride [ VPX_PLANE_Y ] / 2 , ( uint16 * ) stream -> img -> planes [ VPX_PLANE_U ] , stream -> img -> stride [ VPX_PLANE_U ] / 2 , ( uint16 * ) stream -> img -> planes [ VPX_PLANE_V ] , stream -> img -> stride [ VPX_PLANE_V ] / 2 , stream -> img -> d_w , stream -> img -> d_h , kFilterBox ) ; img = stream -> img ; # else stream -> encoder . err = 1 ; ctx_exit_on_error ( & stream -> encoder , ""Stream<S2SV_blank>%d:<S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>encode<S2SV_blank>frame.\\n"" ""Scaling<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>this<S2SV_blank>configuration.<S2SV_blank>\\n"" ""To<S2SV_blank>enable,<S2SV_blank>configure<S2SV_blank>with<S2SV_blank>--enable-libyuv\\n"" , stream -> index ) ; # endif } } # endif if ( img && ( img -> d_w != cfg -> g_w || img -> d_h != cfg -> g_h ) ) { if ( img -> fmt != VPX_IMG_FMT_I420 && img -> fmt != VPX_IMG_FMT_YV12 ) { fprintf ( stderr , ""%s<S2SV_blank>can<S2SV_blank>only<S2SV_blank>scale<S2SV_blank>4:2:0<S2SV_blank>8bpp<S2SV_blank>inputs\\n"" , exec_name ) ; exit ( EXIT_FAILURE ) ; } # if CONFIG_LIBYUV if ( ! stream -> img ) stream -> img = vpx_img_alloc ( NULL , VPX_IMG_FMT_I420 <S2SV_ModEnd> , cfg -> <S2SV_ModStart> -> img ; # else stream -> encoder . err = 1 ; ctx_exit_on_error ( & stream -> encoder , ""Stream<S2SV_blank>%d:<S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>encode<S2SV_blank>frame.\\n"" ""Scaling<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>this<S2SV_blank>configuration.<S2SV_blank>\\n"" ""To<S2SV_blank>enable,<S2SV_blank>configure<S2SV_blank>with<S2SV_blank>--enable-libyuv\\n"" , stream -> index ) ; # endif"
516,static int snd_compress_check_input ( struct snd_compr_params * params ) { if ( params -> buffer . fragment_size == 0 || <S2SV_StartBug> params -> buffer . fragments > SIZE_MAX / params -> buffer . fragment_size ) <S2SV_EndBug> return - EINVAL ; if ( params -> codec . id == 0 || params -> codec . id > SND_AUDIOCODEC_MAX ) return - EINVAL ; if ( params -> codec . ch_in == 0 || params -> codec . ch_out == 0 ) return - EINVAL ; return 0 ; },. fragments > INT_MAX <S2SV_ModEnd> / params ->
517,static void l2tp_eth_dev_setup ( struct net_device * dev ) { ether_setup ( dev ) ; <S2SV_StartBug> dev -> netdev_ops = & l2tp_eth_netdev_ops ; <S2SV_EndBug> dev -> destructor = free_netdev ; },; dev -> priv_flags &= ~ IFF_TX_SKB_SHARING ; dev ->
518,"static int cxusb_ctrl_msg ( struct dvb_usb_device * d , u8 cmd , u8 * wbuf , int wlen , u8 * rbuf , int rlen ) { struct cxusb_state * st = d -> priv ; <S2SV_StartBug> int ret , wo ; <S2SV_EndBug> if ( 1 + wlen > MAX_XFER_SIZE ) { warn ( ""i2c<S2SV_blank>wr:<S2SV_blank>len=%d<S2SV_blank>is<S2SV_blank>too<S2SV_blank>big!\\n"" , wlen ) ; return - EOPNOTSUPP ; } <S2SV_StartBug> wo = ( rbuf == NULL || rlen == 0 ) ; <S2SV_EndBug> mutex_lock ( & d -> data_mutex ) ; st -> data [ 0 ] = cmd ; memcpy ( & st -> data [ 1 ] , wbuf , wlen ) ; <S2SV_StartBug> if ( wo ) <S2SV_EndBug> ret = dvb_usb_generic_write ( d , st -> data , 1 + wlen ) ; else ret = dvb_usb_generic_rw ( d , st -> data , 1 + wlen , <S2SV_StartBug> rbuf , rlen , 0 ) ; <S2SV_EndBug> mutex_unlock ( & d -> data_mutex ) ; return ret ; }","; int ret <S2SV_ModEnd> ; if ( <S2SV_ModStart> EOPNOTSUPP ; } if ( rlen > MAX_XFER_SIZE ) { warn ( ""i2c<S2SV_blank>rd:<S2SV_blank>len=%d<S2SV_blank>is<S2SV_blank>too<S2SV_blank>big!\\n"" , rlen ) ; return - EOPNOTSUPP ; } <S2SV_ModEnd> mutex_lock ( & <S2SV_ModStart> wlen ) ; <S2SV_ModEnd> ret = dvb_usb_generic_rw <S2SV_ModStart> + wlen , st -> data <S2SV_ModEnd> , rlen , <S2SV_ModStart> rlen , 0 ) ; if ( ! ret && rbuf && rlen ) memcpy ( rbuf , st -> data , rlen"
519,"static int multipath_ioctl ( struct dm_target * ti , unsigned int cmd , unsigned long arg ) { struct multipath * m = ( struct multipath * ) ti -> private ; struct block_device * bdev = NULL ; fmode_t mode = 0 ; unsigned long flags ; int r = 0 ; spin_lock_irqsave ( & m -> lock , flags ) ; if ( ! m -> current_pgpath ) __choose_pgpath ( m , 0 ) ; if ( m -> current_pgpath ) { bdev = m -> current_pgpath -> path . dev -> bdev ; mode = m -> current_pgpath -> path . dev -> mode ; } if ( m -> queue_io ) r = - EAGAIN ; else if ( ! bdev ) r = - EIO ; spin_unlock_irqrestore ( & m -> lock , flags ) ; <S2SV_StartBug> return r ? : __blkdev_driver_ioctl ( bdev , mode , cmd , arg ) ; <S2SV_EndBug> }","flags ) ; if ( ! r && ti -> len != i_size_read ( bdev -> bd_inode ) >> SECTOR_SHIFT ) r = scsi_verify_blk_ioctl ( NULL , cmd ) ;"
520,"void messageAddArgument ( message * m , const char * arg ) { int offset ; char * p ; assert ( m != NULL ) ; if ( arg == NULL ) return ; while ( isspace ( * arg ) ) arg ++ ; if ( * arg == '\\0' ) return ; cli_dbgmsg ( ""messageAddArgument,<S2SV_blank>arg=\'%s\'\\n"" , arg ) ; if ( ! usefulArg ( arg ) ) return ; for ( offset = 0 ; offset < m -> numberOfArguments ; offset ++ ) if ( m -> mimeArguments [ offset ] == NULL ) break ; else if ( strcasecmp ( arg , m -> mimeArguments [ offset ] ) == 0 ) return ; if ( offset == m -> numberOfArguments ) { char * * q ; m -> numberOfArguments ++ ; q = ( char * * ) cli_realloc ( m -> mimeArguments , m -> numberOfArguments * sizeof ( char * ) ) ; if ( q == NULL ) { m -> numberOfArguments -- ; return ; } m -> mimeArguments = q ; } p = m -> mimeArguments [ offset ] = rfc2231 ( arg ) ; if ( ! p ) { cli_dbgmsg ( ""messageAddArgument,<S2SV_blank>error<S2SV_blank>from<S2SV_blank>rfc2231()\\n"" ) ; return ; } if ( strchr ( p , '=' ) == NULL ) { if ( strncmp ( p , ""filename"" , 8 ) == 0 ) { <S2SV_StartBug> cli_dbgmsg ( ""Possible<S2SV_blank>data<S2SV_blank>corruption<S2SV_blank>fixed\\n"" ) ; <S2SV_EndBug> p [ 8 ] = '=' ; } else { <S2SV_StartBug> if ( * p ) <S2SV_EndBug> cli_dbgmsg ( ""messageAddArgument,<S2SV_blank>\'%s\'<S2SV_blank>contains<S2SV_blank>no<S2SV_blank>\'=\'\\n"" , p ) ; free ( m -> mimeArguments [ offset ] ) ; m -> mimeArguments [ offset ] = NULL ; return ; } } if ( ( strncasecmp ( p , ""filename="" , 9 ) == 0 ) || ( strncasecmp ( p , ""name="" , 5 ) == 0 ) ) if ( messageGetMimeType ( m ) == NOMIME ) { cli_dbgmsg ( ""Force<S2SV_blank>mime<S2SV_blank>encoding<S2SV_blank>to<S2SV_blank>application\\n"" ) ; messageSetMimeType ( m , ""application"" ) ; } }","0 ) { if ( strlen ( p ) > 8 ) { <S2SV_ModStart> } else { cli_dbgmsg ( ""Possible<S2SV_blank>data<S2SV_blank>corruption<S2SV_blank>not<S2SV_blank>fixed\\n"" ) ; } } else {"
521,"static int netlink_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct netlink_sock * nlk = nlk_sk ( sk ) ; struct sockaddr_nl * addr = msg -> msg_name ; u32 dst_pid ; u32 dst_group ; struct sk_buff * skb ; int err ; struct scm_cookie scm ; if ( msg -> msg_flags & MSG_OOB ) return - EOPNOTSUPP ; if ( NULL == siocb -> scm ) siocb -> scm = & scm ; err = scm_send ( sock , msg , siocb -> scm , true ) ; if ( err < 0 ) return err ; if ( msg -> msg_namelen ) { err = - EINVAL ; if ( addr -> nl_family != AF_NETLINK ) goto out ; dst_pid = addr -> nl_pid ; dst_group = ffs ( addr -> nl_groups ) ; err = - EPERM ; <S2SV_StartBug> if ( dst_group && ! netlink_capable ( sock , NL_NONROOT_SEND ) ) <S2SV_EndBug> goto out ; } else { dst_pid = nlk -> dst_pid ; dst_group = nlk -> dst_group ; } if ( ! nlk -> pid ) { err = netlink_autobind ( sock ) ; if ( err ) goto out ; } err = - EMSGSIZE ; if ( len > sk -> sk_sndbuf - 32 ) goto out ; err = - ENOBUFS ; skb = alloc_skb ( len , GFP_KERNEL ) ; if ( skb == NULL ) goto out ; NETLINK_CB ( skb ) . pid = nlk -> pid ; NETLINK_CB ( skb ) . dst_group = dst_group ; memcpy ( NETLINK_CREDS ( skb ) , & siocb -> scm -> creds , sizeof ( struct ucred ) ) ; err = - EFAULT ; if ( memcpy_fromiovec ( skb_put ( skb , len ) , msg -> msg_iov , len ) ) { kfree_skb ( skb ) ; goto out ; } err = security_netlink_send ( sk , skb ) ; if ( err ) { kfree_skb ( skb ) ; goto out ; } if ( dst_group ) { atomic_inc ( & skb -> users ) ; netlink_broadcast ( sk , skb , dst_pid , dst_group , GFP_KERNEL ) ; } err = netlink_unicast ( sk , skb , dst_pid , msg -> msg_flags & MSG_DONTWAIT ) ; out : scm_destroy ( siocb -> scm ) ; return err ; }",; if ( ( dst_group || dst_pid ) <S2SV_ModEnd> && ! netlink_capable
522,"int hfsplus_set_posix_acl ( struct inode * inode , struct posix_acl * acl , int type ) { int err ; char * xattr_name ; size_t size = 0 ; char * value = NULL ; hfs_dbg ( ACL_MOD , ""[%s]:<S2SV_blank>ino<S2SV_blank>%lu\\n"" , __func__ , inode -> i_ino ) ; switch ( type ) { case ACL_TYPE_ACCESS : xattr_name = XATTR_NAME_POSIX_ACL_ACCESS ; if ( acl ) { <S2SV_StartBug> err = posix_acl_equiv_mode ( acl , & inode -> i_mode ) ; <S2SV_EndBug> if ( err < 0 ) return err ; } err = 0 ; break ; case ACL_TYPE_DEFAULT : xattr_name = XATTR_NAME_POSIX_ACL_DEFAULT ; if ( ! S_ISDIR ( inode -> i_mode ) ) return acl ? - EACCES : 0 ; break ; default : return - EINVAL ; } if ( acl ) { size = posix_acl_xattr_size ( acl -> a_count ) ; if ( unlikely ( size > HFSPLUS_MAX_INLINE_DATA_SIZE ) ) return - ENOMEM ; value = ( char * ) hfsplus_alloc_attr_entry ( ) ; if ( unlikely ( ! value ) ) return - ENOMEM ; err = posix_acl_to_xattr ( & init_user_ns , acl , value , size ) ; if ( unlikely ( err < 0 ) ) goto end_set_acl ; } err = __hfsplus_setxattr ( inode , xattr_name , value , size , 0 ) ; end_set_acl : hfsplus_destroy_attr_entry ( ( hfsplus_attr_entry * ) value ) ; if ( ! err ) set_cached_acl ( inode , type , acl ) ; return err ; }","{ err = posix_acl_update_mode ( inode <S2SV_ModEnd> , & inode <S2SV_ModStart> inode -> i_mode , & acl ) ; if ( err <S2SV_ModEnd> ) return err"
523,"static int Downmix_Command ( effect_handle_t self , uint32_t cmdCode , uint32_t cmdSize , void * pCmdData , uint32_t * replySize , void * pReplyData ) { downmix_module_t * pDwmModule = ( downmix_module_t * ) self ; downmix_object_t * pDownmixer ; if ( pDwmModule == NULL || pDwmModule -> context . state == DOWNMIX_STATE_UNINITIALIZED ) { return - EINVAL ; } pDownmixer = ( downmix_object_t * ) & pDwmModule -> context ; ALOGV ( ""Downmix_Command<S2SV_blank>command<S2SV_blank>%"" PRIu32 ""<S2SV_blank>cmdSize<S2SV_blank>%"" PRIu32 , cmdCode , cmdSize ) ; switch ( cmdCode ) { case EFFECT_CMD_INIT : if ( pReplyData == NULL || replySize == NULL || * replySize != sizeof ( int ) ) { return - EINVAL ; } * ( int * ) pReplyData = Downmix_Init ( pDwmModule ) ; break ; case EFFECT_CMD_SET_CONFIG : if ( pCmdData == NULL || cmdSize != sizeof ( effect_config_t ) || pReplyData == NULL || replySize == NULL || * replySize != sizeof ( int ) ) { return - EINVAL ; } * ( int * ) pReplyData = Downmix_Configure ( pDwmModule , ( effect_config_t * ) pCmdData , false ) ; break ; case EFFECT_CMD_RESET : Downmix_Reset ( pDownmixer , false ) ; break ; case EFFECT_CMD_GET_PARAM : ALOGV ( ""Downmix_Command<S2SV_blank>EFFECT_CMD_GET_PARAM<S2SV_blank>pCmdData<S2SV_blank>%p,<S2SV_blank>*replySize<S2SV_blank>%"" PRIu32 "",<S2SV_blank>pReplyData:<S2SV_blank>%p"" , pCmdData , * replySize , pReplyData ) ; if ( pCmdData == NULL || cmdSize < ( int ) ( sizeof ( effect_param_t ) + sizeof ( int32_t ) ) || pReplyData == NULL || replySize == NULL || * replySize < ( int ) sizeof ( effect_param_t ) + 2 * sizeof ( int32_t ) ) { return - EINVAL ; } effect_param_t * rep = ( effect_param_t * ) pReplyData ; memcpy ( pReplyData , pCmdData , sizeof ( effect_param_t ) + sizeof ( int32_t ) ) ; ALOGV ( ""Downmix_Command<S2SV_blank>EFFECT_CMD_GET_PARAM<S2SV_blank>param<S2SV_blank>%"" PRId32 "",<S2SV_blank>replySize<S2SV_blank>%"" PRIu32 , * ( int32_t * ) rep -> data , rep -> vsize ) ; rep -> status = Downmix_getParameter ( pDownmixer , * ( int32_t * ) rep -> data , & rep -> vsize , rep -> data + sizeof ( int32_t ) ) ; * replySize = sizeof ( effect_param_t ) + sizeof ( int32_t ) + rep -> vsize ; break ; case EFFECT_CMD_SET_PARAM : ALOGV ( ""Downmix_Command<S2SV_blank>EFFECT_CMD_SET_PARAM<S2SV_blank>cmdSize<S2SV_blank>%d<S2SV_blank>pCmdData<S2SV_blank>%p,<S2SV_blank>*replySize<S2SV_blank>%"" PRIu32 "",<S2SV_blank>pReplyData<S2SV_blank>%p"" , cmdSize , pCmdData , * replySize , pReplyData ) ; if ( pCmdData == NULL || ( cmdSize < ( int ) ( sizeof ( effect_param_t ) + sizeof ( int32_t ) ) ) || pReplyData == NULL || replySize == NULL || * replySize != ( int ) sizeof ( int32_t ) ) { return - EINVAL ; } effect_param_t * cmd = ( effect_param_t * ) pCmdData ; <S2SV_StartBug> * ( int * ) pReplyData = Downmix_setParameter ( pDownmixer , * ( int32_t * ) cmd -> data , <S2SV_EndBug> cmd -> vsize , cmd -> data + sizeof ( int32_t ) ) ; break ; case EFFECT_CMD_SET_PARAM_DEFERRED : ALOGW ( ""Downmix_Command<S2SV_blank>command<S2SV_blank>EFFECT_CMD_SET_PARAM_DEFERRED<S2SV_blank>not<S2SV_blank>supported,<S2SV_blank>FIXME"" ) ; break ; case EFFECT_CMD_SET_PARAM_COMMIT : ALOGW ( ""Downmix_Command<S2SV_blank>command<S2SV_blank>EFFECT_CMD_SET_PARAM_COMMIT<S2SV_blank>not<S2SV_blank>supported,<S2SV_blank>FIXME"" ) ; break ; case EFFECT_CMD_ENABLE : if ( pReplyData == NULL || replySize == NULL || * replySize != sizeof ( int ) ) { return - EINVAL ; } if ( pDownmixer -> state != DOWNMIX_STATE_INITIALIZED ) { return - ENOSYS ; } pDownmixer -> state = DOWNMIX_STATE_ACTIVE ; ALOGV ( ""EFFECT_CMD_ENABLE()<S2SV_blank>OK"" ) ; * ( int * ) pReplyData = 0 ; break ; case EFFECT_CMD_DISABLE : if ( pReplyData == NULL || replySize == NULL || * replySize != sizeof ( int ) ) { return - EINVAL ; } if ( pDownmixer -> state != DOWNMIX_STATE_ACTIVE ) { return - ENOSYS ; } pDownmixer -> state = DOWNMIX_STATE_INITIALIZED ; ALOGV ( ""EFFECT_CMD_DISABLE()<S2SV_blank>OK"" ) ; * ( int * ) pReplyData = 0 ; break ; case EFFECT_CMD_SET_DEVICE : if ( pCmdData == NULL || cmdSize != ( int ) sizeof ( uint32_t ) ) { return - EINVAL ; } ALOGV ( ""Downmix_Command<S2SV_blank>EFFECT_CMD_SET_DEVICE:<S2SV_blank>0x%08"" PRIx32 , * ( uint32_t * ) pCmdData ) ; break ; case EFFECT_CMD_SET_VOLUME : { if ( pCmdData == NULL || cmdSize != ( int ) sizeof ( uint32_t ) * 2 ) { return - EINVAL ; } ALOGW ( ""Downmix_Command<S2SV_blank>command<S2SV_blank>EFFECT_CMD_SET_VOLUME<S2SV_blank>not<S2SV_blank>supported,<S2SV_blank>FIXME"" ) ; float left = ( float ) ( * ( uint32_t * ) pCmdData ) / ( 1 << 24 ) ; float right = ( float ) ( * ( ( uint32_t * ) pCmdData + 1 ) ) / ( 1 << 24 ) ; ALOGV ( ""Downmix_Command<S2SV_blank>EFFECT_CMD_SET_VOLUME:<S2SV_blank>left<S2SV_blank>%f,<S2SV_blank>right<S2SV_blank>%f<S2SV_blank>"" , left , right ) ; break ; } case EFFECT_CMD_SET_AUDIO_MODE : if ( pCmdData == NULL || cmdSize != ( int ) sizeof ( uint32_t ) ) { return - EINVAL ; } ALOGV ( ""Downmix_Command<S2SV_blank>EFFECT_CMD_SET_AUDIO_MODE:<S2SV_blank>%"" PRIu32 , * ( uint32_t * ) pCmdData ) ; break ; case EFFECT_CMD_SET_CONFIG_REVERSE : case EFFECT_CMD_SET_INPUT_DEVICE : break ; default : ALOGW ( ""Downmix_Command<S2SV_blank>invalid<S2SV_blank>command<S2SV_blank>%"" PRIu32 , cmdCode ) ; return - EINVAL ; } return 0 ; }",") pCmdData ; if ( cmd -> psize != sizeof ( int32_t ) ) { android_errorWriteLog ( 0x534e4554 , ""63662938"" ) ; return - EINVAL ; }"
524,"<S2SV_StartBug> static void choose_intra_uv_mode ( VP9_COMP * cpi , PICK_MODE_CONTEXT * ctx , <S2SV_EndBug> BLOCK_SIZE bsize , TX_SIZE max_tx_size , int * rate_uv , int * rate_uv_tokenonly , int64_t * dist_uv , int * skip_uv , <S2SV_StartBug> MB_PREDICTION_MODE * mode_uv ) { <S2SV_EndBug> <S2SV_StartBug> MACROBLOCK * const x = & cpi -> mb ; <S2SV_EndBug> if ( cpi -> sf . use_uv_intra_rd_estimate ) { rd_sbuv_dcpred ( cpi , x , rate_uv , rate_uv_tokenonly , dist_uv , skip_uv , bsize < BLOCK_8X8 ? BLOCK_8X8 : bsize ) ; } else { rd_pick_intra_sbuv_mode ( cpi , x , ctx , rate_uv , rate_uv_tokenonly , dist_uv , skip_uv , bsize < BLOCK_8X8 ? BLOCK_8X8 : bsize , max_tx_size ) ; } * mode_uv = x -> e_mbd . mi [ 0 ] -> mbmi . uv_mode ; }","* cpi , MACROBLOCK * const x , <S2SV_ModStart> * skip_uv , PREDICTION_MODE <S2SV_ModEnd> * mode_uv ) <S2SV_ModStart> mode_uv ) { <S2SV_ModEnd> if ( cpi"
525,"<S2SV_StartBug> void nfs4_close_state ( struct path * path , struct nfs4_state * state , mode_t mode ) <S2SV_EndBug> { <S2SV_StartBug> __nfs4_close ( path , state , mode , 0 ) ; <S2SV_EndBug> }","* state , fmode_t fmode <S2SV_ModEnd> ) { __nfs4_close <S2SV_ModStart> , state , fmode <S2SV_ModEnd> , 0 )"
526,"static struct dentry * aio_mount ( struct file_system_type * fs_type , int flags , const char * dev_name , void * data ) { static const struct dentry_operations ops = { . d_dname = simple_dname , } ; <S2SV_StartBug> return mount_pseudo ( fs_type , ""aio:"" , NULL , & ops , AIO_RING_MAGIC ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>",", } ; struct dentry * root = <S2SV_ModEnd> mount_pseudo ( fs_type <S2SV_ModStart> AIO_RING_MAGIC ) ; if ( ! IS_ERR ( root ) ) root -> d_sb -> s_iflags |= SB_I_NOEXEC ; return root ;"
527,"static void cpStripToTile ( uint8 * out , uint8 * in , <S2SV_StartBug> uint32 rows , uint32 cols , int outskew , int inskew ) <S2SV_EndBug> { while ( rows -- > 0 ) { uint32 j = cols ; while ( j -- > 0 ) * out ++ = * in ++ ; out += outskew ; in += inskew ; } }","int outskew , int64 <S2SV_ModEnd> inskew ) {"
528,"void xmlrpc_char_encode ( char * outbuffer , const char * s1 ) { long unsigned int i ; unsigned char c ; char buf2 [ 15 ] ; mowgli_string_t * s = mowgli_string_create ( ) ; * buf2 = '\\0' ; * outbuffer = '\\0' ; if ( ( ! ( s1 ) || ( * ( s1 ) == '\\0' ) ) ) { return ; } for ( i = 0 ; s1 [ i ] != '\\0' ; i ++ ) { c = s1 [ i ] ; if ( c > 127 ) { snprintf ( buf2 , sizeof buf2 , ""&#%d;"" , c ) ; s -> append ( s , buf2 , strlen ( buf2 ) ) ; } else if ( c == '&' ) { s -> append ( s , ""&amp;"" , 5 ) ; } else if ( c == '<' ) { s -> append ( s , ""&lt;"" , 4 ) ; } else if ( c == '>' ) { s -> append ( s , ""&gt;"" , 4 ) ; } else if ( c == \'""\' ) { s -> append ( s , ""&quot;"" , 6 ) ; } else { s -> append_char ( s , c ) ; } } <S2SV_StartBug> memcpy ( outbuffer , s -> str , XMLRPC_BUFSIZE ) ; <S2SV_EndBug> }","; } } s -> append_char ( s , 0 ) ; strncpy <S2SV_ModEnd> ( outbuffer ,"
529,"static int nl80211_start_sched_scan ( struct sk_buff * skb , struct genl_info * info ) { struct cfg80211_sched_scan_request * request ; struct cfg80211_registered_device * rdev = info -> user_ptr [ 0 ] ; struct net_device * dev = info -> user_ptr [ 1 ] ; struct nlattr * attr ; struct wiphy * wiphy ; int err , tmp , n_ssids = 0 , n_channels , i ; u32 interval ; enum ieee80211_band band ; size_t ie_len ; if ( ! ( rdev -> wiphy . flags & WIPHY_FLAG_SUPPORTS_SCHED_SCAN ) || ! rdev -> ops -> sched_scan_start ) return - EOPNOTSUPP ; if ( ! is_valid_ie_attr ( info -> attrs [ NL80211_ATTR_IE ] ) ) return - EINVAL ; if ( rdev -> sched_scan_req ) return - EINPROGRESS ; if ( ! info -> attrs [ NL80211_ATTR_SCHED_SCAN_INTERVAL ] ) return - EINVAL ; interval = nla_get_u32 ( info -> attrs [ NL80211_ATTR_SCHED_SCAN_INTERVAL ] ) ; if ( interval == 0 ) return - EINVAL ; wiphy = & rdev -> wiphy ; if ( info -> attrs [ NL80211_ATTR_SCAN_FREQUENCIES ] ) { n_channels = validate_scan_freqs ( info -> attrs [ NL80211_ATTR_SCAN_FREQUENCIES ] ) ; if ( ! n_channels ) return - EINVAL ; } else { n_channels = 0 ; for ( band = 0 ; band < IEEE80211_NUM_BANDS ; band ++ ) if ( wiphy -> bands [ band ] ) n_channels += wiphy -> bands [ band ] -> n_channels ; } if ( info -> attrs [ NL80211_ATTR_SCAN_SSIDS ] ) nla_for_each_nested ( attr , info -> attrs [ NL80211_ATTR_SCAN_SSIDS ] , tmp ) n_ssids ++ ; if ( n_ssids > wiphy -> max_scan_ssids ) return - EINVAL ; if ( info -> attrs [ NL80211_ATTR_IE ] ) ie_len = nla_len ( info -> attrs [ NL80211_ATTR_IE ] ) ; else ie_len = 0 ; if ( ie_len > wiphy -> max_scan_ie_len ) return - EINVAL ; request = kzalloc ( sizeof ( * request ) + sizeof ( * request -> ssids ) * n_ssids + sizeof ( * request -> channels ) * n_channels + ie_len , GFP_KERNEL ) ; if ( ! request ) return - ENOMEM ; if ( n_ssids ) request -> ssids = ( void * ) & request -> channels [ n_channels ] ; request -> n_ssids = n_ssids ; if ( ie_len ) { if ( request -> ssids ) request -> ie = ( void * ) ( request -> ssids + n_ssids ) ; else request -> ie = ( void * ) ( request -> channels + n_channels ) ; } i = 0 ; if ( info -> attrs [ NL80211_ATTR_SCAN_FREQUENCIES ] ) { nla_for_each_nested ( attr , info -> attrs [ NL80211_ATTR_SCAN_FREQUENCIES ] , tmp ) { struct ieee80211_channel * chan ; chan = ieee80211_get_channel ( wiphy , nla_get_u32 ( attr ) ) ; if ( ! chan ) { err = - EINVAL ; goto out_free ; } if ( chan -> flags & IEEE80211_CHAN_DISABLED ) continue ; request -> channels [ i ] = chan ; i ++ ; } } else { for ( band = 0 ; band < IEEE80211_NUM_BANDS ; band ++ ) { int j ; if ( ! wiphy -> bands [ band ] ) continue ; for ( j = 0 ; j < wiphy -> bands [ band ] -> n_channels ; j ++ ) { struct ieee80211_channel * chan ; chan = & wiphy -> bands [ band ] -> channels [ j ] ; if ( chan -> flags & IEEE80211_CHAN_DISABLED ) continue ; request -> channels [ i ] = chan ; i ++ ; } } } if ( ! i ) { err = - EINVAL ; goto out_free ; } request -> n_channels = i ; i = 0 ; if ( info -> attrs [ NL80211_ATTR_SCAN_SSIDS ] ) { nla_for_each_nested ( attr , info -> attrs [ NL80211_ATTR_SCAN_SSIDS ] , tmp ) { <S2SV_StartBug> if ( request -> ssids [ i ] . ssid_len > <S2SV_EndBug> IEEE80211_MAX_SSID_LEN ) { err = - EINVAL ; goto out_free ; } memcpy ( request -> ssids [ i ] . ssid , nla_data ( attr ) , nla_len ( attr ) ) ; <S2SV_StartBug> request -> ssids [ i ] . ssid_len = nla_len ( attr ) ; <S2SV_EndBug> i ++ ; } } if ( info -> attrs [ NL80211_ATTR_IE ] ) { request -> ie_len = nla_len ( info -> attrs [ NL80211_ATTR_IE ] ) ; memcpy ( ( void * ) request -> ie , nla_data ( info -> attrs [ NL80211_ATTR_IE ] ) , request -> ie_len ) ; } request -> dev = dev ; request -> wiphy = & rdev -> wiphy ; request -> interval = interval ; err = rdev -> ops -> sched_scan_start ( & rdev -> wiphy , dev , request ) ; if ( ! err ) { rdev -> sched_scan_req = request ; nl80211_send_sched_scan ( rdev , dev , NL80211_CMD_START_SCHED_SCAN ) ; goto out ; } out_free : kfree ( request ) ; out : return err ; }",tmp ) { request -> ssids [ i ] . ssid_len = nla_len ( attr ) ; <S2SV_ModStart> ) ) ; <S2SV_ModEnd> i ++ ;
530,"u_int ieee802_15_4_if_print ( netdissect_options * ndo , const struct pcap_pkthdr * h , const u_char * p ) { u_int caplen = h -> caplen ; u_int hdrlen ; uint16_t fc ; uint8_t seq ; uint16_t panid = 0 ; if ( caplen < 3 ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return caplen ; } hdrlen = 3 ; fc = EXTRACT_LE_16BITS ( p ) ; seq = EXTRACT_LE_8BITS ( p + 2 ) ; p += 3 ; caplen -= 3 ; ND_PRINT ( ( ndo , ""IEEE<S2SV_blank>802.15.4<S2SV_blank>%s<S2SV_blank>packet<S2SV_blank>"" , ftypes [ FC_FRAME_TYPE ( fc ) ] ) ) ; if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""seq<S2SV_blank>%02x<S2SV_blank>"" , seq ) ) ; switch ( FC_DEST_ADDRESSING_MODE ( fc ) ) { case FC_ADDRESSING_MODE_NONE : if ( fc & FC_PAN_ID_COMPRESSION ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return hdrlen ; } if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""none<S2SV_blank>"" ) ) ; break ; case FC_ADDRESSING_MODE_RESERVED : if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""reserved<S2SV_blank>destination<S2SV_blank>addressing<S2SV_blank>mode"" ) ) ; return hdrlen ; case FC_ADDRESSING_MODE_SHORT : if ( caplen < 2 ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return hdrlen ; } panid = EXTRACT_LE_16BITS ( p ) ; p += 2 ; caplen -= 2 ; hdrlen += 2 ; if ( caplen < 2 ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return hdrlen ; } if ( ndo -> ndo_vflag ) <S2SV_StartBug> ND_PRINT ( ( ndo , ""%04x:%04x<S2SV_blank>"" , panid , EXTRACT_LE_16BITS ( p + 2 ) ) ) ; <S2SV_EndBug> p += 2 ; caplen -= 2 ; hdrlen += 2 ; break ; case FC_ADDRESSING_MODE_LONG : if ( caplen < 2 ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return hdrlen ; } panid = EXTRACT_LE_16BITS ( p ) ; p += 2 ; caplen -= 2 ; hdrlen += 2 ; if ( caplen < 8 ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return hdrlen ; } if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""%04x:%s<S2SV_blank>"" , panid , le64addr_string ( ndo , p ) ) ) ; p += 8 ; caplen -= 8 ; hdrlen += 8 ; break ; } if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""<<S2SV_blank>"" ) ) ; switch ( FC_SRC_ADDRESSING_MODE ( fc ) ) { case FC_ADDRESSING_MODE_NONE : if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""none<S2SV_blank>"" ) ) ; break ; case FC_ADDRESSING_MODE_RESERVED : if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""reserved<S2SV_blank>source<S2SV_blank>addressing<S2SV_blank>mode"" ) ) ; return 0 ; case FC_ADDRESSING_MODE_SHORT : if ( ! ( fc & FC_PAN_ID_COMPRESSION ) ) { if ( caplen < 2 ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return hdrlen ; } panid = EXTRACT_LE_16BITS ( p ) ; p += 2 ; caplen -= 2 ; hdrlen += 2 ; } if ( caplen < 2 ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return hdrlen ; } if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""%04x:%04x<S2SV_blank>"" , panid , EXTRACT_LE_16BITS ( p ) ) ) ; p += 2 ; caplen -= 2 ; hdrlen += 2 ; break ; case FC_ADDRESSING_MODE_LONG : if ( ! ( fc & FC_PAN_ID_COMPRESSION ) ) { if ( caplen < 2 ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return hdrlen ; } panid = EXTRACT_LE_16BITS ( p ) ; p += 2 ; caplen -= 2 ; hdrlen += 2 ; } if ( caplen < 8 ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return hdrlen ; } if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""%04x:%s<S2SV_blank>"" , panid , le64addr_string ( ndo , p ) ) ) ; p += 8 ; caplen -= 8 ; hdrlen += 8 ; break ; } if ( ! ndo -> ndo_suppress_default_print ) ND_DEFAULTPRINT ( p , caplen ) ; return hdrlen ; }",EXTRACT_LE_16BITS ( p <S2SV_ModEnd> ) ) )
531,"int cdf_read_property_info ( const cdf_stream_t * sst , const cdf_header_t * h , uint32_t offs , cdf_property_info_t * * info , size_t * count , size_t * maxcount ) { const cdf_section_header_t * shp ; cdf_section_header_t sh ; const uint8_t * p , * q , * e ; int16_t s16 ; int32_t s32 ; uint32_t u32 ; int64_t s64 ; uint64_t u64 ; cdf_timestamp_t tp ; size_t i , o , o4 , nelements , j ; cdf_property_info_t * inp ; if ( offs > UINT32_MAX / 4 ) { errno = EFTYPE ; goto out ; } shp = CAST ( const cdf_section_header_t * , ( const void * ) ( ( const char * ) sst -> sst_tab + offs ) ) ; if ( cdf_check_stream_offset ( sst , h , shp , sizeof ( * shp ) , __LINE__ ) == - 1 ) goto out ; sh . sh_len = CDF_TOLE4 ( shp -> sh_len ) ; # define CDF_SHLEN_LIMIT ( UINT32_MAX / 8 ) if ( sh . sh_len > CDF_SHLEN_LIMIT ) { errno = EFTYPE ; goto out ; } sh . sh_properties = CDF_TOLE4 ( shp -> sh_properties ) ; # define CDF_PROP_LIMIT ( UINT32_MAX / ( 4 * sizeof ( * inp ) ) ) if ( sh . sh_properties > CDF_PROP_LIMIT ) goto out ; DPRINTF ( ( ""section<S2SV_blank>len:<S2SV_blank>%u<S2SV_blank>properties<S2SV_blank>%u\\n"" , sh . sh_len , sh . sh_properties ) ) ; if ( * maxcount ) { if ( * maxcount > CDF_PROP_LIMIT ) goto out ; * maxcount += sh . sh_properties ; inp = CAST ( cdf_property_info_t * , realloc ( * info , * maxcount * sizeof ( * inp ) ) ) ; } else { * maxcount = sh . sh_properties ; inp = CAST ( cdf_property_info_t * , malloc ( * maxcount * sizeof ( * inp ) ) ) ; } if ( inp == NULL ) goto out ; * info = inp ; inp += * count ; * count += sh . sh_properties ; p = CAST ( const uint8_t * , ( const void * ) ( ( const char * ) ( const void * ) sst -> sst_tab + offs + sizeof ( sh ) ) ) ; e = CAST ( const uint8_t * , ( const void * ) ( ( ( const char * ) ( const void * ) shp ) + sh . sh_len ) ) ; if ( cdf_check_stream_offset ( sst , h , e , 0 , __LINE__ ) == - 1 ) goto out ; for ( i = 0 ; i < sh . sh_properties ; i ++ ) { q = ( const uint8_t * ) ( const void * ) ( ( const char * ) ( const void * ) p + CDF_GETUINT32 ( p , ( i << 1 ) + 1 ) ) - 2 * sizeof ( uint32_t ) ; if ( q > e ) { DPRINTF ( ( ""Ran<S2SV_blank>of<S2SV_blank>the<S2SV_blank>end<S2SV_blank>%p<S2SV_blank>><S2SV_blank>%p\\n"" , q , e ) ) ; goto out ; } inp [ i ] . pi_id = CDF_GETUINT32 ( p , i << 1 ) ; inp [ i ] . pi_type = CDF_GETUINT32 ( q , 0 ) ; DPRINTF ( ( ""%d)<S2SV_blank>id=%x<S2SV_blank>type=%x<S2SV_blank>offs=%x,%d\\n"" , i , inp [ i ] . pi_id , inp [ i ] . pi_type , q - p , CDF_GETUINT32 ( p , ( i << 1 ) + 1 ) ) ) ; if ( inp [ i ] . pi_type & CDF_VECTOR ) { nelements = CDF_GETUINT32 ( q , 1 ) ; o = 2 ; } else { nelements = 1 ; o = 1 ; } o4 = o * sizeof ( uint32_t ) ; if ( inp [ i ] . pi_type & ( CDF_ARRAY | CDF_BYREF | CDF_RESERVED ) ) goto unknown ; switch ( inp [ i ] . pi_type & CDF_TYPEMASK ) { case CDF_NULL : case CDF_EMPTY : break ; case CDF_SIGNED16 : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & s16 , & q [ o4 ] , sizeof ( s16 ) ) ; inp [ i ] . pi_s16 = CDF_TOLE2 ( s16 ) ; break ; case CDF_SIGNED32 : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & s32 , & q [ o4 ] , sizeof ( s32 ) ) ; inp [ i ] . pi_s32 = CDF_TOLE4 ( ( uint32_t ) s32 ) ; break ; case CDF_BOOL : case CDF_UNSIGNED32 : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & u32 , & q [ o4 ] , sizeof ( u32 ) ) ; inp [ i ] . pi_u32 = CDF_TOLE4 ( u32 ) ; break ; case CDF_SIGNED64 : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & s64 , & q [ o4 ] , sizeof ( s64 ) ) ; inp [ i ] . pi_s64 = CDF_TOLE8 ( ( uint64_t ) s64 ) ; break ; case CDF_UNSIGNED64 : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & u64 , & q [ o4 ] , sizeof ( u64 ) ) ; inp [ i ] . pi_u64 = CDF_TOLE8 ( ( uint64_t ) u64 ) ; break ; case CDF_LENGTH32_STRING : case CDF_LENGTH32_WSTRING : if ( nelements > 1 ) { size_t nelem = inp - * info ; if ( * maxcount > CDF_PROP_LIMIT || nelements > CDF_PROP_LIMIT ) goto out ; * maxcount += nelements ; inp = CAST ( cdf_property_info_t * , realloc ( * info , * maxcount * sizeof ( * inp ) ) ) ; if ( inp == NULL ) goto out ; * info = inp ; inp = * info + nelem ; } DPRINTF ( ( ""nelements<S2SV_blank>=<S2SV_blank>%d\\n"" , nelements ) ) ; for ( j = 0 ; j < nelements ; j ++ , i ++ ) { uint32_t l = CDF_GETUINT32 ( q , o ) ; inp [ i ] . pi_str . s_len = l ; inp [ i ] . pi_str . s_buf = ( const char * ) ( const void * ) ( & q [ o4 + sizeof ( l ) ] ) ; DPRINTF ( ( ""l<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>r<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>s<S2SV_blank>=<S2SV_blank>%s\\n"" , l , CDF_ROUND ( l , sizeof ( l ) ) , inp [ i ] . pi_str . s_buf ) ) ; l = 4 + ( uint32_t ) CDF_ROUND ( l , sizeof ( l ) ) ; o += l >> 2 ; <S2SV_StartBug> o4 = o * sizeof ( uint32_t ) ; <S2SV_EndBug> } i -- ; break ; case CDF_FILETIME : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & tp , & q [ o4 ] , sizeof ( tp ) ) ; inp [ i ] . pi_tp = CDF_TOLE8 ( ( uint64_t ) tp ) ; break ; case CDF_CLIPBOARD : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; break ; default : unknown : DPRINTF ( ( ""Don\'t<S2SV_blank>know<S2SV_blank>how<S2SV_blank>to<S2SV_blank>deal<S2SV_blank>with<S2SV_blank>%x\\n"" , inp [ i ] . pi_type ) ) ; goto out ; } } return 0 ; out : free ( * info ) ; return - 1 ; }",>> 2 ; if ( q + o >= e ) goto out ;
532,"int read_yuv_frame ( struct VpxInputContext * input_ctx , vpx_image_t * yuv_frame ) { FILE * f = input_ctx -> file ; struct FileTypeDetectionBuffer * detect = & input_ctx -> detect ; int plane = 0 ; int shortread = 0 ; <S2SV_StartBug> for ( plane = 0 ; plane < 3 ; ++ plane ) { <S2SV_EndBug> uint8_t * ptr ; <S2SV_StartBug> const int w = ( plane ? ( 1 + yuv_frame -> d_w ) / 2 : yuv_frame -> d_w ) ; <S2SV_EndBug> <S2SV_StartBug> const int h = ( plane ? ( 1 + yuv_frame -> d_h ) / 2 : yuv_frame -> d_h ) ; <S2SV_EndBug> int r ; switch ( plane ) { case 1 : ptr = yuv_frame -> planes [ yuv_frame -> fmt == VPX_IMG_FMT_YV12 ? VPX_PLANE_V : VPX_PLANE_U ] ; break ; case 2 : ptr = yuv_frame -> planes [ yuv_frame -> fmt == VPX_IMG_FMT_YV12 ? VPX_PLANE_U : VPX_PLANE_V ] ; break ; default : ptr = yuv_frame -> planes [ plane ] ; } for ( r = 0 ; r < h ; ++ r ) { <S2SV_StartBug> size_t needed = w ; <S2SV_EndBug> size_t buf_position = 0 ; const size_t left = detect -> buf_read - detect -> position ; if ( left > 0 ) { const size_t more = ( left < needed ) ? left : needed ; memcpy ( ptr , detect -> buf + detect -> position , more ) ; buf_position = more ; needed -= more ; detect -> position += more ; } if ( needed > 0 ) { shortread |= ( fread ( ptr + buf_position , 1 , needed , f ) < needed ) ; } ptr += yuv_frame -> stride [ plane ] ; } } return shortread ; }","= 0 ; const int bytespp = ( yuv_frame -> fmt & VPX_IMG_FMT_HIGHBITDEPTH ) ? 2 : 1 ; <S2SV_ModStart> int w = vpx_img_plane_width ( yuv_frame , plane <S2SV_ModEnd> ) ; const <S2SV_ModStart> int h = vpx_img_plane_height ( yuv_frame , plane <S2SV_ModEnd> ) ; int <S2SV_ModStart> needed = w * bytespp"
533,"unsigned int get_random_int ( void ) { <S2SV_StartBug> struct keydata * keyptr ; <S2SV_EndBug> __u32 * hash = get_cpu_var ( get_random_int_hash ) ; <S2SV_StartBug> int ret ; <S2SV_EndBug> keyptr = get_keyptr ( ) ; hash [ 0 ] += current -> pid + jiffies + get_cycles ( ) ; <S2SV_StartBug> ret = half_md4_transform ( hash , keyptr -> secret ) ; <S2SV_EndBug> put_cpu_var ( get_random_int_hash ) ; return ret ; }","void ) { <S2SV_ModEnd> __u32 * hash <S2SV_ModStart> get_random_int_hash ) ; unsigned int ret <S2SV_ModEnd> ; hash [ <S2SV_ModStart> ( ) ; md5_transform <S2SV_ModEnd> ( hash , <S2SV_ModStart> ( hash , random_int_secret ) ; ret = hash [ 0 ] <S2SV_ModEnd> ; put_cpu_var ("
534,"void luaD_call ( lua_State * L , StkId func , int nresults ) { lua_CFunction f ; retry : switch ( ttypetag ( s2v ( func ) ) ) { case LUA_VCCL : f = clCvalue ( s2v ( func ) ) -> f ; goto Cfunc ; case LUA_VLCF : f = fvalue ( s2v ( func ) ) ; Cfunc : { int n ; <S2SV_StartBug> CallInfo * ci = next_ci ( L ) ; <S2SV_EndBug> checkstackp ( L , LUA_MINSTACK , func ) ; ci -> nresults = nresults ; ci -> callstatus = CIST_C ; ci -> top = L -> top + LUA_MINSTACK ; <S2SV_StartBug> ci -> func = func ; <S2SV_EndBug> L -> ci = ci ; lua_assert ( ci -> top <= L -> stack_last ) ; if ( L -> hookmask & LUA_MASKCALL ) { int narg = cast_int ( L -> top - func ) - 1 ; luaD_hook ( L , LUA_HOOKCALL , - 1 , 1 , narg ) ; } lua_unlock ( L ) ; n = ( * f ) ( L ) ; lua_lock ( L ) ; api_checknelems ( L , n ) ; luaD_poscall ( L , ci , n ) ; break ; } case LUA_VLCL : { <S2SV_StartBug> CallInfo * ci = next_ci ( L ) ; <S2SV_EndBug> Proto * p = clLvalue ( s2v ( func ) ) -> p ; int narg = cast_int ( L -> top - func ) - 1 ; int nfixparams = p -> numparams ; int fsize = p -> maxstacksize ; <S2SV_StartBug> checkstackp ( L , fsize , func ) ; <S2SV_EndBug> ci -> nresults = nresults ; ci -> u . l . savedpc = p -> code ; ci -> callstatus = 0 ; ci -> top = func + 1 + fsize ; ci -> func = func ; L -> ci = ci ; for ( ; narg < nfixparams ; narg ++ ) setnilvalue ( s2v ( L -> top ++ ) ) ; lua_assert ( ci -> top <= L -> stack_last ) ; luaV_execute ( L , ci ) ; break ; } default : { <S2SV_StartBug> checkstackp ( L , 1 , func ) ; <S2SV_EndBug> luaD_tryfuncTM ( L , func ) ; goto retry ; } } }","CallInfo * ci ; checkstackGCp ( L , LUA_MINSTACK , func ) ; L -> ci = ci <S2SV_ModStart> next_ci ( L <S2SV_ModEnd> ) ; ci <S2SV_ModStart> func = func <S2SV_ModEnd> ; lua_assert ( <S2SV_ModStart> CallInfo * ci <S2SV_ModEnd> ; Proto * <S2SV_ModStart> -> maxstacksize ; checkstackGCp <S2SV_ModEnd> ( L , <S2SV_ModStart> fsize , func ) ; L -> ci = ci = next_ci ( L <S2SV_ModStart> default : { checkstackGCp <S2SV_ModEnd> ( L ,"
535,"static void sgi_timer_get ( struct k_itimer * timr , struct itimerspec * cur_setting ) { if ( timr -> it . mmtimer . clock == TIMER_OFF ) { cur_setting -> it_interval . tv_nsec = 0 ; cur_setting -> it_interval . tv_sec = 0 ; cur_setting -> it_value . tv_nsec = 0 ; cur_setting -> it_value . tv_sec = 0 ; return ; } <S2SV_StartBug> ns_to_timespec ( cur_setting -> it_interval , timr -> it . mmtimer . incr * sgi_clock_period ) ; <S2SV_EndBug> <S2SV_StartBug> ns_to_timespec ( cur_setting -> it_value , ( timr -> it . mmtimer . expires - rtc_time ( ) ) * sgi_clock_period ) ; <S2SV_EndBug> <S2SV_StartBug> return ; <S2SV_EndBug> }",return ; } <S2SV_ModEnd> cur_setting -> it_interval <S2SV_ModStart> cur_setting -> it_interval = ns_to_timespec ( <S2SV_ModEnd> timr -> it <S2SV_ModStart> sgi_clock_period ) ; <S2SV_ModEnd> cur_setting -> it_value <S2SV_ModStart> cur_setting -> it_value = ns_to_timespec ( <S2SV_ModEnd> ( timr -> <S2SV_ModStart> sgi_clock_period ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
536,"int snd_usbmidi_create ( struct snd_card * card , struct usb_interface * iface , struct list_head * midi_list , const struct snd_usb_audio_quirk * quirk ) { struct snd_usb_midi * umidi ; struct snd_usb_midi_endpoint_info endpoints [ MIDI_MAX_ENDPOINTS ] ; int out_ports , in_ports ; int i , err ; umidi = kzalloc ( sizeof ( * umidi ) , GFP_KERNEL ) ; if ( ! umidi ) return - ENOMEM ; umidi -> dev = interface_to_usbdev ( iface ) ; umidi -> card = card ; umidi -> iface = iface ; umidi -> quirk = quirk ; umidi -> usb_protocol_ops = & snd_usbmidi_standard_ops ; spin_lock_init ( & umidi -> disc_lock ) ; init_rwsem ( & umidi -> disc_rwsem ) ; mutex_init ( & umidi -> mutex ) ; umidi -> usb_id = USB_ID ( le16_to_cpu ( umidi -> dev -> descriptor . idVendor ) , le16_to_cpu ( umidi -> dev -> descriptor . idProduct ) ) ; setup_timer ( & umidi -> error_timer , snd_usbmidi_error_timer , ( unsigned long ) umidi ) ; memset ( endpoints , 0 , sizeof ( endpoints ) ) ; switch ( quirk ? quirk -> type : QUIRK_MIDI_STANDARD_INTERFACE ) { case QUIRK_MIDI_STANDARD_INTERFACE : err = snd_usbmidi_get_ms_info ( umidi , endpoints ) ; if ( umidi -> usb_id == USB_ID ( 0x0763 , 0x0150 ) ) umidi -> usb_protocol_ops = & snd_usbmidi_maudio_broken_running_status_ops ; break ; case QUIRK_MIDI_US122L : umidi -> usb_protocol_ops = & snd_usbmidi_122l_ops ; case QUIRK_MIDI_FIXED_ENDPOINT : memcpy ( & endpoints [ 0 ] , quirk -> data , sizeof ( struct snd_usb_midi_endpoint_info ) ) ; err = snd_usbmidi_detect_endpoints ( umidi , & endpoints [ 0 ] , 1 ) ; break ; case QUIRK_MIDI_YAMAHA : err = snd_usbmidi_detect_yamaha ( umidi , & endpoints [ 0 ] ) ; break ; case QUIRK_MIDI_ROLAND : err = snd_usbmidi_detect_roland ( umidi , & endpoints [ 0 ] ) ; break ; case QUIRK_MIDI_MIDIMAN : umidi -> usb_protocol_ops = & snd_usbmidi_midiman_ops ; memcpy ( & endpoints [ 0 ] , quirk -> data , sizeof ( struct snd_usb_midi_endpoint_info ) ) ; err = 0 ; break ; case QUIRK_MIDI_NOVATION : umidi -> usb_protocol_ops = & snd_usbmidi_novation_ops ; err = snd_usbmidi_detect_per_port_endpoints ( umidi , endpoints ) ; break ; case QUIRK_MIDI_RAW_BYTES : umidi -> usb_protocol_ops = & snd_usbmidi_raw_ops ; if ( umidi -> usb_id == USB_ID ( 0x07fd , 0x0001 ) ) usb_set_interface ( umidi -> dev , 0 , 0 ) ; err = snd_usbmidi_detect_per_port_endpoints ( umidi , endpoints ) ; break ; case QUIRK_MIDI_EMAGIC : umidi -> usb_protocol_ops = & snd_usbmidi_emagic_ops ; memcpy ( & endpoints [ 0 ] , quirk -> data , sizeof ( struct snd_usb_midi_endpoint_info ) ) ; err = snd_usbmidi_detect_endpoints ( umidi , & endpoints [ 0 ] , 1 ) ; break ; case QUIRK_MIDI_CME : umidi -> usb_protocol_ops = & snd_usbmidi_cme_ops ; err = snd_usbmidi_detect_per_port_endpoints ( umidi , endpoints ) ; break ; case QUIRK_MIDI_AKAI : umidi -> usb_protocol_ops = & snd_usbmidi_akai_ops ; err = snd_usbmidi_detect_per_port_endpoints ( umidi , endpoints ) ; endpoints [ 1 ] . out_cables = 0 ; break ; case QUIRK_MIDI_FTDI : umidi -> usb_protocol_ops = & snd_usbmidi_ftdi_ops ; err = usb_control_msg ( umidi -> dev , usb_sndctrlpipe ( umidi -> dev , 0 ) , 3 , 0x40 , 0x60 , 0 , NULL , 0 , 1000 ) ; if ( err < 0 ) break ; err = snd_usbmidi_detect_per_port_endpoints ( umidi , endpoints ) ; break ; case QUIRK_MIDI_CH345 : umidi -> usb_protocol_ops = & snd_usbmidi_ch345_broken_sysex_ops ; err = snd_usbmidi_detect_per_port_endpoints ( umidi , endpoints ) ; break ; default : dev_err ( & umidi -> dev -> dev , ""invalid<S2SV_blank>quirk<S2SV_blank>type<S2SV_blank>%d\\n"" , quirk -> type ) ; err = - ENXIO ; break ; } if ( err < 0 ) { kfree ( umidi ) ; return err ; } out_ports = 0 ; in_ports = 0 ; for ( i = 0 ; i < MIDI_MAX_ENDPOINTS ; ++ i ) { out_ports += hweight16 ( endpoints [ i ] . out_cables ) ; in_ports += hweight16 ( endpoints [ i ] . in_cables ) ; } err = snd_usbmidi_create_rawmidi ( umidi , out_ports , in_ports ) ; if ( err < 0 ) { kfree ( umidi ) ; return err ; } if ( quirk && quirk -> type == QUIRK_MIDI_MIDIMAN ) err = snd_usbmidi_create_endpoints_midiman ( umidi , & endpoints [ 0 ] ) ; else err = snd_usbmidi_create_endpoints ( umidi , endpoints ) ; if ( err < 0 ) { <S2SV_StartBug> snd_usbmidi_free ( umidi ) ; <S2SV_EndBug> return err ; } usb_autopm_get_interface_no_resume ( umidi -> iface ) ; list_add_tail ( & umidi -> list , midi_list ) ; return 0 ; }",0 ) { <S2SV_ModEnd> return err ;
537,"static void icmp6_nodeinfo_print ( netdissect_options * ndo , u_int icmp6len , const u_char * bp , const u_char * ep ) { const struct icmp6_nodeinfo * ni6 ; const struct icmp6_hdr * dp ; const u_char * cp ; size_t siz , i ; int needcomma ; if ( ep < bp ) return ; dp = ( const struct icmp6_hdr * ) bp ; ni6 = ( const struct icmp6_nodeinfo * ) bp ; siz = ep - bp ; switch ( ni6 -> ni_type ) { case ICMP6_NI_QUERY : if ( siz == sizeof ( * dp ) + 4 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>who-are-you<S2SV_blank>request"" ) ) ; break ; } ND_PRINT ( ( ndo , ""<S2SV_blank>node<S2SV_blank>information<S2SV_blank>query"" ) ) ; ND_TCHECK2 ( * dp , sizeof ( * ni6 ) ) ; ni6 = ( const struct icmp6_nodeinfo * ) dp ; ND_PRINT ( ( ndo , ""<S2SV_blank>("" ) ) ; switch ( EXTRACT_16BITS ( & ni6 -> ni_qtype ) ) { case NI_QTYPE_NOOP : ND_PRINT ( ( ndo , ""noop"" ) ) ; break ; case NI_QTYPE_SUPTYPES : ND_PRINT ( ( ndo , ""supported<S2SV_blank>qtypes"" ) ) ; i = EXTRACT_16BITS ( & ni6 -> ni_flags ) ; if ( i ) ND_PRINT ( ( ndo , ""<S2SV_blank>[%s]"" , ( i & 0x01 ) ? ""C"" : """" ) ) ; break ; case NI_QTYPE_FQDN : ND_PRINT ( ( ndo , ""DNS<S2SV_blank>name"" ) ) ; break ; case NI_QTYPE_NODEADDR : ND_PRINT ( ( ndo , ""node<S2SV_blank>addresses"" ) ) ; i = ni6 -> ni_flags ; if ( ! i ) break ; ND_PRINT ( ( ndo , ""<S2SV_blank>[%s%s%s%s%s%s]"" , ( i & NI_NODEADDR_FLAG_ANYCAST ) ? ""a"" : """" , ( i & NI_NODEADDR_FLAG_GLOBAL ) ? ""G"" : """" , ( i & NI_NODEADDR_FLAG_SITELOCAL ) ? ""S"" : """" , ( i & NI_NODEADDR_FLAG_LINKLOCAL ) ? ""L"" : """" , ( i & NI_NODEADDR_FLAG_COMPAT ) ? ""C"" : """" , ( i & NI_NODEADDR_FLAG_ALL ) ? ""A"" : """" ) ) ; break ; default : ND_PRINT ( ( ndo , ""unknown"" ) ) ; break ; } if ( ni6 -> ni_qtype == NI_QTYPE_NOOP || ni6 -> ni_qtype == NI_QTYPE_SUPTYPES ) { if ( siz != sizeof ( * ni6 ) ) if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "",<S2SV_blank>invalid<S2SV_blank>len"" ) ) ; ND_PRINT ( ( ndo , "")"" ) ) ; break ; } if ( siz == sizeof ( * ni6 ) ) { ND_PRINT ( ( ndo , "",<S2SV_blank>03<S2SV_blank>draft"" ) ) ; ND_PRINT ( ( ndo , "")"" ) ) ; break ; } switch ( ni6 -> ni_code ) { case ICMP6_NI_SUBJ_IPV6 : if ( ! ND_TTEST2 ( * dp , sizeof ( * ni6 ) + sizeof ( struct in6_addr ) ) ) break ; if ( siz != sizeof ( * ni6 ) + sizeof ( struct in6_addr ) ) { if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "",<S2SV_blank>invalid<S2SV_blank>subject<S2SV_blank>len"" ) ) ; break ; } ND_PRINT ( ( ndo , "",<S2SV_blank>subject=%s"" , ip6addr_string ( ndo , ni6 + 1 ) ) ) ; break ; case ICMP6_NI_SUBJ_FQDN : ND_PRINT ( ( ndo , "",<S2SV_blank>subject=DNS<S2SV_blank>name"" ) ) ; cp = ( const u_char * ) ( ni6 + 1 ) ; if ( cp [ 0 ] == ep - cp - 1 ) { if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "",<S2SV_blank>03<S2SV_blank>draft"" ) ) ; cp ++ ; ND_PRINT ( ( ndo , "",<S2SV_blank>\\"""" ) ) ; while ( cp < ep ) { safeputchar ( ndo , * cp ) ; cp ++ ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; } else dnsname_print ( ndo , cp , ep ) ; break ; case ICMP6_NI_SUBJ_IPV4 : if ( ! ND_TTEST2 ( * dp , sizeof ( * ni6 ) + sizeof ( struct in_addr ) ) ) break ; if ( siz != sizeof ( * ni6 ) + sizeof ( struct in_addr ) ) { if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "",<S2SV_blank>invalid<S2SV_blank>subject<S2SV_blank>len"" ) ) ; break ; } ND_PRINT ( ( ndo , "",<S2SV_blank>subject=%s"" , ipaddr_string ( ndo , ni6 + 1 ) ) ) ; break ; default : ND_PRINT ( ( ndo , "",<S2SV_blank>unknown<S2SV_blank>subject"" ) ) ; break ; } ND_PRINT ( ( ndo , "")"" ) ) ; break ; case ICMP6_NI_REPLY : if ( icmp6len > siz ) { ND_PRINT ( ( ndo , ""[|icmp6:<S2SV_blank>node<S2SV_blank>information<S2SV_blank>reply]"" ) ) ; break ; } needcomma = 0 ; ND_TCHECK2 ( * dp , sizeof ( * ni6 ) ) ; ni6 = ( const struct icmp6_nodeinfo * ) dp ; ND_PRINT ( ( ndo , ""<S2SV_blank>node<S2SV_blank>information<S2SV_blank>reply"" ) ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>("" ) ) ; switch ( ni6 -> ni_code ) { case ICMP6_NI_SUCCESS : if ( ndo -> ndo_vflag ) { ND_PRINT ( ( ndo , ""success"" ) ) ; needcomma ++ ; } break ; case ICMP6_NI_REFUSED : ND_PRINT ( ( ndo , ""refused"" ) ) ; needcomma ++ ; if ( siz != sizeof ( * ni6 ) ) if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "",<S2SV_blank>invalid<S2SV_blank>length"" ) ) ; break ; case ICMP6_NI_UNKNOWN : ND_PRINT ( ( ndo , ""unknown"" ) ) ; needcomma ++ ; if ( siz != sizeof ( * ni6 ) ) if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "",<S2SV_blank>invalid<S2SV_blank>length"" ) ) ; break ; } if ( ni6 -> ni_code != ICMP6_NI_SUCCESS ) { ND_PRINT ( ( ndo , "")"" ) ) ; break ; } switch ( EXTRACT_16BITS ( & ni6 -> ni_qtype ) ) { case NI_QTYPE_NOOP : if ( needcomma ) ND_PRINT ( ( ndo , "",<S2SV_blank>"" ) ) ; ND_PRINT ( ( ndo , ""noop"" ) ) ; if ( siz != sizeof ( * ni6 ) ) if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "",<S2SV_blank>invalid<S2SV_blank>length"" ) ) ; break ; case NI_QTYPE_SUPTYPES : if ( needcomma ) ND_PRINT ( ( ndo , "",<S2SV_blank>"" ) ) ; ND_PRINT ( ( ndo , ""supported<S2SV_blank>qtypes"" ) ) ; i = EXTRACT_16BITS ( & ni6 -> ni_flags ) ; if ( i ) ND_PRINT ( ( ndo , ""<S2SV_blank>[%s]"" , ( i & 0x01 ) ? ""C"" : """" ) ) ; break ; case NI_QTYPE_FQDN : if ( needcomma ) ND_PRINT ( ( ndo , "",<S2SV_blank>"" ) ) ; ND_PRINT ( ( ndo , ""DNS<S2SV_blank>name"" ) ) ; cp = ( const u_char * ) ( ni6 + 1 ) + 4 ; ND_TCHECK ( cp [ 0 ] ) ; if ( cp [ 0 ] == ep - cp - 1 ) { if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "",<S2SV_blank>03<S2SV_blank>draft"" ) ) ; cp ++ ; ND_PRINT ( ( ndo , "",<S2SV_blank>\\"""" ) ) ; while ( cp < ep ) { safeputchar ( ndo , * cp ) ; cp ++ ; } ND_PRINT ( ( ndo , ""\\"""" ) ) ; } else dnsname_print ( ndo , cp , ep ) ; if ( ( EXTRACT_16BITS ( & ni6 -> ni_flags ) & 0x01 ) != 0 ) ND_PRINT ( ( ndo , ""<S2SV_blank>[TTL=%u]"" , EXTRACT_32BITS ( ni6 + 1 ) ) ) ; break ; case NI_QTYPE_NODEADDR : if ( needcomma ) ND_PRINT ( ( ndo , "",<S2SV_blank>"" ) ) ; ND_PRINT ( ( ndo , ""node<S2SV_blank>addresses"" ) ) ; i = sizeof ( * ni6 ) ; while ( i < siz ) { if ( i + sizeof ( struct in6_addr ) + sizeof ( int32_t ) > siz ) break ; ND_PRINT ( ( ndo , ""<S2SV_blank>%s"" , ip6addr_string ( ndo , bp + i ) ) ) ; i += sizeof ( struct in6_addr ) ; ND_PRINT ( ( ndo , ""(%d)"" , ( int32_t ) EXTRACT_32BITS ( bp + i ) ) ) ; i += sizeof ( int32_t ) ; } i = ni6 -> ni_flags ; if ( ! i ) break ; ND_PRINT ( ( ndo , ""<S2SV_blank>[%s%s%s%s%s%s%s]"" , ( i & NI_NODEADDR_FLAG_ANYCAST ) ? ""a"" : """" , ( i & NI_NODEADDR_FLAG_GLOBAL ) ? ""G"" : """" , ( i & NI_NODEADDR_FLAG_SITELOCAL ) ? ""S"" : """" , ( i & NI_NODEADDR_FLAG_LINKLOCAL ) ? ""L"" : """" , ( i & NI_NODEADDR_FLAG_COMPAT ) ? ""C"" : """" , ( i & NI_NODEADDR_FLAG_ALL ) ? ""A"" : """" , ( i & NI_NODEADDR_FLAG_TRUNCATE ) ? ""T"" : """" ) ) ; break ; default : if ( needcomma ) ND_PRINT ( ( ndo , "",<S2SV_blank>"" ) ) ; ND_PRINT ( ( ndo , ""unknown"" ) ) ; break ; } ND_PRINT ( ( ndo , "")"" ) ) ; break ; } return ; trunc : <S2SV_StartBug> ND_PRINT ( ( ndo , ""[|icmp6]"" ) ) ; <S2SV_EndBug> }","( ndo , ""%s"" , icmp6_tstr <S2SV_ModEnd> ) ) ;"
538,"int key_update ( key_ref_t key_ref , const void * payload , size_t plen ) { struct key_preparsed_payload prep ; struct key * key = key_ref_to_ptr ( key_ref ) ; int ret ; key_check ( key ) ; ret = key_permission ( key_ref , KEY_NEED_WRITE ) ; if ( ret < 0 ) return ret ; if ( ! key -> type -> update ) return - EOPNOTSUPP ; memset ( & prep , 0 , sizeof ( prep ) ) ; prep . data = payload ; prep . datalen = plen ; prep . quotalen = key -> type -> def_datalen ; prep . expiry = TIME_T_MAX ; if ( key -> type -> preparse ) { ret = key -> type -> preparse ( & prep ) ; if ( ret < 0 ) goto error ; } down_write ( & key -> sem ) ; ret = key -> type -> update ( key , & prep ) ; if ( ret == 0 ) <S2SV_StartBug> clear_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ; <S2SV_EndBug> up_write ( & key -> sem ) ; error : if ( key -> type -> preparse ) key -> type -> free_preparse ( & prep ) ; return ret ; }","== 0 ) mark_key_instantiated ( key , 0 <S2SV_ModEnd> ) ; up_write"
539,"int common_timer_set ( struct k_itimer * timr , int flags , struct itimerspec64 * new_setting , struct itimerspec64 * old_setting ) { const struct k_clock * kc = timr -> kclock ; bool sigev_none ; ktime_t expires ; if ( old_setting ) common_timer_get ( timr , old_setting ) ; timr -> it_interval = 0 ; if ( kc -> timer_try_to_cancel ( timr ) < 0 ) return TIMER_RETRY ; timr -> it_active = 0 ; timr -> it_requeue_pending = ( timr -> it_requeue_pending + 2 ) & ~ REQUEUE_PENDING ; timr -> it_overrun_last = 0 ; if ( ! new_setting -> it_value . tv_sec && ! new_setting -> it_value . tv_nsec ) return 0 ; timr -> it_interval = timespec64_to_ktime ( new_setting -> it_interval ) ; expires = timespec64_to_ktime ( new_setting -> it_value ) ; <S2SV_StartBug> sigev_none = ( timr -> it_sigev_notify & ~ SIGEV_THREAD_ID ) == SIGEV_NONE ; <S2SV_EndBug> kc -> timer_arm ( timr , expires , flags & TIMER_ABSTIME , sigev_none ) ; timr -> it_active = ! sigev_none ; return 0 ; }",; sigev_none = <S2SV_ModEnd> timr -> it_sigev_notify <S2SV_ModStart> timr -> it_sigev_notify <S2SV_ModEnd> == SIGEV_NONE ;
540,"void initServer ( ) { int j ; signal ( SIGHUP , SIG_IGN ) ; signal ( SIGPIPE , SIG_IGN ) ; setupSigSegvAction ( ) ; if ( server . syslog_enabled ) { openlog ( server . syslog_ident , LOG_PID | LOG_NDELAY | LOG_NOWAIT , server . syslog_facility ) ; } server . mainthread = pthread_self ( ) ; server . clients = listCreate ( ) ; server . slaves = listCreate ( ) ; server . monitors = listCreate ( ) ; server . unblocked_clients = listCreate ( ) ; createSharedObjects ( ) ; server . el = aeCreateEventLoop ( ) ; server . db = zmalloc ( sizeof ( redisDb ) * server . dbnum ) ; server . ipfd = anetTcpServer ( server . neterr , server . port , server . bindaddr ) ; if ( server . ipfd == ANET_ERR ) { redisLog ( REDIS_WARNING , ""Opening<S2SV_blank>port:<S2SV_blank>%s"" , server . neterr ) ; exit ( 1 ) ; } if ( server . unixsocket != NULL ) { unlink ( server . unixsocket ) ; server . sofd = anetUnixServer ( server . neterr , server . unixsocket ) ; if ( server . sofd == ANET_ERR ) { redisLog ( REDIS_WARNING , ""Opening<S2SV_blank>socket:<S2SV_blank>%s"" , server . neterr ) ; exit ( 1 ) ; } } if ( server . ipfd < 0 && server . sofd < 0 ) { redisLog ( REDIS_WARNING , ""Configured<S2SV_blank>to<S2SV_blank>not<S2SV_blank>listen<S2SV_blank>anywhere,<S2SV_blank>exiting."" ) ; exit ( 1 ) ; } for ( j = 0 ; j < server . dbnum ; j ++ ) { server . db [ j ] . dict = dictCreate ( & dbDictType , NULL ) ; server . db [ j ] . expires = dictCreate ( & keyptrDictType , NULL ) ; server . db [ j ] . blocking_keys = dictCreate ( & keylistDictType , NULL ) ; server . db [ j ] . watched_keys = dictCreate ( & keylistDictType , NULL ) ; <S2SV_StartBug> if ( server . vm_enabled ) <S2SV_EndBug> server . db [ j ] . io_keys = dictCreate ( & keylistDictType , NULL ) ; server . db [ j ] . id = j ; } server . pubsub_channels = dictCreate ( & keylistDictType , NULL ) ; server . pubsub_patterns = listCreate ( ) ; listSetFreeMethod ( server . pubsub_patterns , freePubsubPattern ) ; listSetMatchMethod ( server . pubsub_patterns , listMatchPubsubPattern ) ; server . cronloops = 0 ; server . bgsavechildpid = - 1 ; server . bgrewritechildpid = - 1 ; server . bgrewritebuf = sdsempty ( ) ; server . aofbuf = sdsempty ( ) ; server . lastsave = time ( NULL ) ; server . dirty = 0 ; server . stat_numcommands = 0 ; server . stat_numconnections = 0 ; server . stat_expiredkeys = 0 ; server . stat_evictedkeys = 0 ; server . stat_starttime = time ( NULL ) ; server . stat_keyspace_misses = 0 ; server . stat_keyspace_hits = 0 ; server . unixtime = time ( NULL ) ; aeCreateTimeEvent ( server . el , 1 , serverCron , NULL , NULL ) ; if ( server . ipfd > 0 && aeCreateFileEvent ( server . el , server . ipfd , AE_READABLE , acceptTcpHandler , NULL ) == AE_ERR ) oom ( ""creating<S2SV_blank>file<S2SV_blank>event"" ) ; if ( server . sofd > 0 && aeCreateFileEvent ( server . el , server . sofd , AE_READABLE , acceptUnixHandler , NULL ) == AE_ERR ) oom ( ""creating<S2SV_blank>file<S2SV_blank>event"" ) ; if ( server . appendonly ) { server . appendfd = open ( server . appendfilename , O_WRONLY | O_APPEND | O_CREAT , 0644 ) ; if ( server . appendfd == - 1 ) { redisLog ( REDIS_WARNING , ""Can\'t<S2SV_blank>open<S2SV_blank>the<S2SV_blank>append-only<S2SV_blank>file:<S2SV_blank>%s"" , strerror ( errno ) ) ; exit ( 1 ) ; } } <S2SV_StartBug> if ( server . vm_enabled ) vmInit ( ) ; <S2SV_EndBug> }",( server . ds_enabled <S2SV_ModEnd> ) server . <S2SV_ModStart> ( server . ds_enabled ) dsInit <S2SV_ModEnd> ( ) ;
541,"void test_re ( ) { assert_true_rule ( ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/ssi/<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}"" , ""mississippi\\tmississippi.mississippi\\nmississippi"" ) ; assert_true_rule ( ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/ssi(s|p)/<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}"" , ""mississippi\\tmississippi.mississippi\\nmississippi"" ) ; assert_true_rule ( ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/ssim*/<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}"" , ""mississippi\\tmississippi.mississippi\\nmississippi"" ) ; assert_true_rule ( ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/ssa?/<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}"" , ""mississippi\\tmississippi.mississippi\\nmississippi"" ) ; assert_true_rule ( ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/Miss/<S2SV_blank>nocase<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}"" , ""mississippi\\tmississippi.mississippi\\nmississippi"" ) ; assert_true_rule ( ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/(M|N)iss/<S2SV_blank>nocase<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}"" , ""mississippi\\tmississippi.mississippi\\nmississippi"" ) ; assert_true_rule ( ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/[M-N]iss/<S2SV_blank>nocase<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}"" , ""mississippi\\tmississippi.mississippi\\nmississippi"" ) ; assert_true_rule ( ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/(Mi|ssi)ssippi/<S2SV_blank>nocase<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}"" , ""mississippi\\tmississippi.mississippi\\nmississippi"" ) ; assert_true_rule ( ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/ppi\\\\tmi/<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}"" , ""mississippi\\tmississippi.mississippi\\nmississippi"" ) ; assert_true_rule ( ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/ppi\\\\.mi/<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}"" , ""mississippi\\tmississippi.mississippi\\nmississippi"" ) ; assert_true_rule ( ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/^mississippi/<S2SV_blank>fullword<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}"" , ""mississippi\\tmississippi.mississippi\\nmississippi"" ) ; assert_true_rule ( ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/mississippi.*mississippi$/s<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}"" , ""mississippi\\tmississippi.mississippi\\nmississippi"" ) ; assert_false_rule ( ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/^ssi/<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}"" , ""mississippi"" ) ; assert_false_rule ( ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/ssi$/<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}"" , ""mississippi"" ) ; assert_false_rule ( ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/ssissi/<S2SV_blank>fullword<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}"" , ""mississippi"" ) ; assert_false_rule ( ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/^[isp]+/<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}"" , ""mississippi"" ) ; assert_true_rule_blob ( ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/a.{1,2}b/<S2SV_blank>wide<S2SV_blank>condition:<S2SV_blank>!a<S2SV_blank>==<S2SV_blank>6<S2SV_blank>}"" , ""a\\0x\\0b\\0"" ) ; assert_true_rule_blob ( ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/a.{1,2}b/<S2SV_blank>wide<S2SV_blank>condition:<S2SV_blank>!a<S2SV_blank>==<S2SV_blank>8<S2SV_blank>}"" , ""a\\0x\\0x\\0b\\0"" ) ; <S2SV_StartBug> assert_regexp_syntax_error ( "")"" ) ; <S2SV_EndBug> assert_true_regexp ( ""abc"" , ""abc"" , ""abc"" ) ; assert_false_regexp ( ""abc"" , ""xbc"" ) ; assert_false_regexp ( ""abc"" , ""axc"" ) ; assert_false_regexp ( ""abc"" , ""abx"" ) ; assert_true_regexp ( ""abc"" , ""xabcx"" , ""abc"" ) ; assert_true_regexp ( ""abc"" , ""ababc"" , ""abc"" ) ; assert_true_regexp ( ""a.c"" , ""abc"" , ""abc"" ) ; assert_false_regexp ( ""a.b"" , ""a\\nb"" ) ; assert_false_regexp ( ""a.*b"" , ""acc\\nccb"" ) ; assert_false_regexp ( ""a.{4,5}b"" , ""acc\\nccb"" ) ; assert_true_regexp ( ""a.b"" , ""a\\rb"" , ""a\\rb"" ) ; assert_true_regexp ( ""ab*c"" , ""abc"" , ""abc"" ) ; assert_true_regexp ( ""ab*c"" , ""ac"" , ""ac"" ) ; assert_true_regexp ( ""ab*bc"" , ""abc"" , ""abc"" ) ; assert_true_regexp ( ""ab*bc"" , ""abbc"" , ""abbc"" ) ; assert_true_regexp ( ""a.*bb"" , ""abbbb"" , ""abbbb"" ) ; assert_true_regexp ( ""a.*?bbb"" , ""abbbbbb"" , ""abbb"" ) ; assert_true_regexp ( ""a.*c"" , ""ac"" , ""ac"" ) ; assert_true_regexp ( ""a.*c"" , ""axyzc"" , ""axyzc"" ) ; assert_true_regexp ( ""ab+c"" , ""abbc"" , ""abbc"" ) ; assert_false_regexp ( ""ab+c"" , ""ac"" ) ; assert_true_regexp ( ""ab+"" , ""abbbb"" , ""abbbb"" ) ; assert_true_regexp ( ""ab+?"" , ""abbbb"" , ""ab"" ) ; assert_false_regexp ( ""ab+bc"" , ""abc"" ) ; assert_false_regexp ( ""ab+bc"" , ""abq"" ) ; assert_true_regexp ( ""a+b+c"" , ""aabbabc"" , ""abc"" ) ; assert_false_regexp ( ""ab?bc"" , ""abbbbc"" ) ; assert_true_regexp ( ""ab?c"" , ""abc"" , ""abc"" ) ; assert_true_regexp ( ""ab*?"" , ""abbb"" , ""a"" ) ; assert_true_regexp ( ""ab?c"" , ""ac"" , ""ac"" ) ; assert_true_regexp ( ""ab??"" , ""ab"" , ""a"" ) ; assert_true_regexp ( ""a(b|x)c"" , ""abc"" , ""abc"" ) ; assert_true_regexp ( ""a(b|x)c"" , ""axc"" , ""axc"" ) ; assert_true_regexp ( ""a(b|.)c"" , ""axc"" , ""axc"" ) ; assert_true_regexp ( ""a(b|x|y)c"" , ""ayc"" , ""ayc"" ) ; assert_true_regexp ( ""(a+|b)*"" , ""ab"" , ""ab"" ) ; assert_true_regexp ( ""a|b|c|d|e"" , ""e"" , ""e"" ) ; assert_true_regexp ( ""(a|b|c|d|e)f"" , ""ef"" , ""ef"" ) ; assert_true_regexp ( "".b{2}"" , ""abb"" , ""abb"" ) ; assert_true_regexp ( "".b{2,3}"" , ""abbb"" , ""abbb"" ) ; assert_true_regexp ( "".b{2,3}?"" , ""abbb"" , ""abb"" ) ; assert_true_regexp ( ""ab{2,3}c"" , ""abbbc"" , ""abbbc"" ) ; assert_true_regexp ( ""ab{2,3}?c"" , ""abbbc"" , ""abbbc"" ) ; assert_true_regexp ( "".b{2,3}cccc"" , ""abbbcccc"" , ""abbbcccc"" ) ; assert_true_regexp ( "".b{2,3}?cccc"" , ""abbbcccc"" , ""bbbcccc"" ) ; assert_true_regexp ( ""a.b{2,3}cccc"" , ""aabbbcccc"" , ""aabbbcccc"" ) ; assert_true_regexp ( ""ab{2,3}c"" , ""abbbc"" , ""abbbc"" ) ; assert_true_regexp ( ""ab{2,3}?c"" , ""abbbc"" , ""abbbc"" ) ; assert_true_regexp ( ""ab{0,1}?c"" , ""abc"" , ""abc"" ) ; assert_true_regexp ( ""a{0,1}?bc"" , ""abc"" , ""abc"" ) ; assert_true_regexp ( ""a{0,1}bc"" , ""bbc"" , ""bc"" ) ; assert_true_regexp ( ""a{0,1}?bc"" , ""abc"" , ""bc"" ) ; assert_true_regexp ( ""aa{0,1}?bc"" , ""abc"" , ""abc"" ) ; assert_true_regexp ( ""aa{0,1}?bc"" , ""abc"" , ""abc"" ) ; assert_true_regexp ( ""aa{0,1}bc"" , ""abc"" , ""abc"" ) ; assert_true_regexp ( ""ab{1}c"" , ""abc"" , ""abc"" ) ; assert_true_regexp ( ""ab{1,2}c"" , ""abbc"" , ""abbc"" ) ; assert_true_regexp ( ""ab{1,}c"" , ""abbbc"" , ""abbbc"" ) ; assert_false_regexp ( ""ab{1,}b"" , ""ab"" ) ; assert_false_regexp ( ""ab{1}c"" , ""abbc"" ) ; assert_true_regexp ( ""ab{0,}c"" , ""ac"" , ""ac"" ) ; assert_true_regexp ( ""ab{1,1}c"" , ""abc"" , ""abc"" ) ; assert_true_regexp ( ""ab{0,}c"" , ""abbbc"" , ""abbbc"" ) ; assert_true_regexp ( ""ab{,3}c"" , ""abbbc"" , ""abbbc"" ) ; assert_false_regexp ( ""ab{,2}c"" , ""abbbc"" ) ; assert_false_regexp ( ""ab{4,5}bc"" , ""abbbbc"" ) ; assert_true_regexp ( ""ab{0,1}"" , ""abbbbb"" , ""ab"" ) ; assert_true_regexp ( ""ab{0,2}"" , ""abbbbb"" , ""abb"" ) ; assert_true_regexp ( ""ab{0,3}"" , ""abbbbb"" , ""abbb"" ) ; assert_true_regexp ( ""ab{0,4}"" , ""abbbbb"" , ""abbbb"" ) ; assert_true_regexp ( ""ab{1,1}"" , ""abbbbb"" , ""ab"" ) ; assert_true_regexp ( ""ab{1,2}"" , ""abbbbb"" , ""abb"" ) ; assert_true_regexp ( ""ab{1,3}"" , ""abbbbb"" , ""abbb"" ) ; assert_true_regexp ( ""ab{2,2}"" , ""abbbbb"" , ""abb"" ) ; assert_true_regexp ( ""ab{2,3}"" , ""abbbbb"" , ""abbb"" ) ; assert_true_regexp ( ""ab{1,3}?"" , ""abbbbb"" , ""ab"" ) ; assert_true_regexp ( ""ab{0,1}?"" , ""abbbbb"" , ""a"" ) ; assert_true_regexp ( ""ab{0,2}?"" , ""abbbbb"" , ""a"" ) ; assert_true_regexp ( ""ab{0,3}?"" , ""abbbbb"" , ""a"" ) ; assert_true_regexp ( ""ab{0,4}?"" , ""abbbbb"" , ""a"" ) ; assert_true_regexp ( ""ab{1,1}?"" , ""abbbbb"" , ""ab"" ) ; assert_true_regexp ( ""ab{1,2}?"" , ""abbbbb"" , ""ab"" ) ; assert_true_regexp ( ""ab{1,3}?"" , ""abbbbb"" , ""ab"" ) ; assert_true_regexp ( ""ab{2,2}?"" , ""abbbbb"" , ""abb"" ) ; assert_true_regexp ( ""ab{2,3}?"" , ""abbbbb"" , ""abb"" ) ; assert_true_regexp ( "".(abc){0,1}"" , ""xabcabcabcabc"" , ""xabc"" ) ; assert_true_regexp ( "".(abc){0,2}"" , ""xabcabcabcabc"" , ""xabcabc"" ) ; assert_true_regexp ( ""x{1,2}abcd"" , ""xxxxabcd"" , ""xxabcd"" ) ; assert_true_regexp ( ""x{1,2}abcd"" , ""xxxxabcd"" , ""xxabcd"" ) ; assert_true_regexp ( ""ab{.*}"" , ""ab{c}"" , ""ab{c}"" ) ; assert_true_regexp ( "".(aa){1,2}"" , ""aaaaaaaaaa"" , ""aaaaa"" ) ; assert_true_regexp ( ""a.(bc.){2}"" , ""aabcabca"" , ""aabcabca"" ) ; assert_true_regexp ( ""(ab{1,2}c){1,3}"" , ""abbcabc"" , ""abbcabc"" ) ; assert_true_regexp ( ""ab(c|cc){1,3}d"" , ""abccccccd"" , ""abccccccd"" ) ; assert_true_regexp ( ""a[bx]c"" , ""abc"" , ""abc"" ) ; assert_true_regexp ( ""a[bx]c"" , ""axc"" , ""axc"" ) ; assert_true_regexp ( ""a[0-9]*b"" , ""ab"" , ""ab"" ) ; assert_true_regexp ( ""a[0-9]*b"" , ""a0123456789b"" , ""a0123456789b"" ) ; assert_true_regexp ( ""[0-9a-f]+"" , ""0123456789abcdef"" , ""0123456789abcdef"" ) ; assert_true_regexp ( ""[0-9a-f]+"" , ""xyz0123456789xyz"" , ""0123456789"" ) ; assert_true_regexp ( ""a[\\\\s\\\\S]b"" , ""a<S2SV_blank>b"" , ""a<S2SV_blank>b"" ) ; assert_true_regexp ( ""a[\\\\d\\\\D]b"" , ""a1b"" , ""a1b"" ) ; assert_false_regexp ( ""[x-z]+"" , ""abc"" ) ; assert_true_regexp ( ""a[-]?c"" , ""ac"" , ""ac"" ) ; assert_true_regexp ( ""a[-b]"" , ""a-"" , ""a-"" ) ; assert_true_regexp ( ""a[-b]"" , ""ab"" , ""ab"" ) ; assert_true_regexp ( ""a[b-]"" , ""a-"" , ""a-"" ) ; assert_true_regexp ( ""a[b-]"" , ""ab"" , ""ab"" ) ; assert_true_regexp ( ""[a-c-e]"" , ""b"" , ""b"" ) ; assert_true_regexp ( ""[a-c-e]"" , ""-"" , ""-"" ) ; assert_false_regexp ( ""[a-c-e]"" , ""d"" ) ; assert_regexp_syntax_error ( ""[b-a]"" ) ; assert_regexp_syntax_error ( ""(abc"" ) ; assert_regexp_syntax_error ( ""abc)"" ) ; assert_regexp_syntax_error ( ""a[]b"" ) ; assert_true_regexp ( ""a[\\\\-b]"" , ""a-"" , ""a-"" ) ; assert_true_regexp ( ""a[\\\\-b]"" , ""ab"" , ""ab"" ) ; assert_true_regexp ( ""a]"" , ""a]"" , ""a]"" ) ; assert_true_regexp ( ""a[]]b"" , ""a]b"" , ""a]b"" ) ; assert_true_regexp ( ""a[\\\\]]b"" , ""a]b"" , ""a]b"" ) ; assert_true_regexp ( ""a[^bc]d"" , ""aed"" , ""aed"" ) ; assert_false_regexp ( ""a[^bc]d"" , ""abd"" ) ; assert_true_regexp ( ""a[^-b]c"" , ""adc"" , ""adc"" ) ; assert_false_regexp ( ""a[^-b]c"" , ""a-c"" ) ; assert_false_regexp ( ""a[^]b]c"" , ""a]c"" ) ; assert_true_regexp ( ""a[^]b]c"" , ""adc"" , ""adc"" ) ; assert_true_regexp ( ""[^ab]*"" , ""cde"" , ""cde"" ) ; assert_regexp_syntax_error ( "")("" ) ; assert_true_regexp ( ""a\\\\sb"" , ""a<S2SV_blank>b"" , ""a<S2SV_blank>b"" ) ; assert_true_regexp ( ""a\\\\sb"" , ""a\\tb"" , ""a\\tb"" ) ; assert_true_regexp ( ""a\\\\sb"" , ""a\\rb"" , ""a\\rb"" ) ; assert_true_regexp ( ""a\\\\sb"" , ""a\\nb"" , ""a\\nb"" ) ; assert_true_regexp ( ""a\\\\sb"" , ""a\\vb"" , ""a\\vb"" ) ; assert_true_regexp ( ""a\\\\sb"" , ""a\\fb"" , ""a\\fb"" ) ; assert_false_regexp ( ""a\\\\Sb"" , ""a<S2SV_blank>b"" ) ; assert_false_regexp ( ""a\\\\Sb"" , ""a\\tb"" ) ; assert_false_regexp ( ""a\\\\Sb"" , ""a\\rb"" ) ; assert_false_regexp ( ""a\\\\Sb"" , ""a\\nb"" ) ; assert_false_regexp ( ""a\\\\Sb"" , ""a\\vb"" ) ; assert_false_regexp ( ""a\\\\Sb"" , ""a\\fb"" ) ; assert_true_regexp ( ""\\\\n\\\\r\\\\t\\\\f\\\\a"" , ""\\n\\r\\t\\f\\a"" , ""\\n\\r\\t\\f\\a"" ) ; assert_true_regexp ( ""[\\\\n][\\\\r][\\\\t][\\\\f][\\\\a]"" , ""\\n\\r\\t\\f\\a"" , ""\\n\\r\\t\\f\\a"" ) ; assert_true_regexp ( ""\\\\x01\\\\x02\\\\x03"" , ""\\x01\\x02\\x03"" , ""\\x01\\x02\\x03"" ) ; assert_true_regexp ( ""[\\\\x01-\\\\x03]+"" , ""\\x01\\x02\\x03"" , ""\\x01\\x02\\x03"" ) ; assert_false_regexp ( ""[\\\\x00-\\\\x02]+"" , ""\\x03\\x04\\x05"" ) ; assert_true_regexp ( ""[\\\\x5D]"" , ""]"" , ""]"" ) ; assert_true_regexp ( ""[\\\\0x5A-\\\\x5D]"" , ""\\x5B"" , ""\\x5B"" ) ; assert_true_regexp ( ""[\\\\x5D-\\\\x5F]"" , ""\\x5E"" , ""\\x5E"" ) ; assert_true_regexp ( ""[\\\\x5C-\\\\x5F]"" , ""\\x5E"" , ""\\x5E"" ) ; assert_true_regexp ( ""[\\\\x5D-\\\\x5F]"" , ""\\x5E"" , ""\\x5E"" ) ; assert_true_regexp ( ""a\\\\wc"" , ""abc"" , ""abc"" ) ; assert_true_regexp ( ""a\\\\wc"" , ""a_c"" , ""a_c"" ) ; assert_true_regexp ( ""a\\\\wc"" , ""a0c"" , ""a0c"" ) ; assert_false_regexp ( ""a\\\\wc"" , ""a*c"" ) ; assert_true_regexp ( ""\\\\w+"" , ""--ab_cd0123--"" , ""ab_cd0123"" ) ; assert_true_regexp ( ""[\\\\w]+"" , ""--ab_cd0123--"" , ""ab_cd0123"" ) ; assert_true_regexp ( ""\\\\D+"" , ""1234abc5678"" , ""abc"" ) ; assert_true_regexp ( ""[\\\\d]+"" , ""0123456789"" , ""0123456789"" ) ; assert_true_regexp ( ""[\\\\D]+"" , ""1234abc5678"" , ""abc"" ) ; assert_true_regexp ( ""[\\\\da-fA-F]+"" , ""123abc"" , ""123abc"" ) ; assert_false_regexp ( ""^(ab|cd)e"" , ""abcde"" ) ; assert_true_regexp ( ""(abc|)ef"" , ""abcdef"" , ""ef"" ) ; assert_true_regexp ( ""(abc|)ef"" , ""abcef"" , ""abcef"" ) ; assert_true_regexp ( ""\\\\babc"" , ""abc"" , ""abc"" ) ; assert_true_regexp ( ""abc\\\\b"" , ""abc"" , ""abc"" ) ; assert_false_regexp ( ""\\\\babc"" , ""1abc"" ) ; assert_false_regexp ( ""abc\\\\b"" , ""abc1"" ) ; assert_true_regexp ( ""abc\\\\s\\\\b"" , ""abc<S2SV_blank>x"" , ""abc<S2SV_blank>"" ) ; assert_false_regexp ( ""abc\\\\s\\\\b"" , ""abc<S2SV_blank><S2SV_blank>"" ) ; assert_true_regexp ( ""\\\\babc\\\\b"" , ""<S2SV_blank>abc<S2SV_blank>"" , ""abc"" ) ; assert_true_regexp ( ""\\\\b\\\\w\\\\w\\\\w\\\\b"" , ""<S2SV_blank>abc<S2SV_blank>"" , ""abc"" ) ; assert_true_regexp ( ""\\\\w\\\\w\\\\w\\\\b"" , ""abcd"" , ""bcd"" ) ; assert_true_regexp ( ""\\\\b\\\\w\\\\w\\\\w"" , ""abcd"" , ""abc"" ) ; assert_false_regexp ( ""\\\\b\\\\w\\\\w\\\\w\\\\b"" , ""abcd"" ) ; assert_false_regexp ( ""\\\\Babc"" , ""abc"" ) ; assert_false_regexp ( ""abc\\\\B"" , ""abc"" ) ; assert_true_regexp ( ""\\\\Babc"" , ""1abc"" , ""abc"" ) ; assert_true_regexp ( ""abc\\\\B"" , ""abc1"" , ""abc"" ) ; assert_false_regexp ( ""abc\\\\s\\\\B"" , ""abc<S2SV_blank>x"" ) ; assert_true_regexp ( ""abc\\\\s\\\\B"" , ""abc<S2SV_blank><S2SV_blank>"" , ""abc<S2SV_blank>"" ) ; assert_true_regexp ( ""\\\\w\\\\w\\\\w\\\\B"" , ""abcd"" , ""abc"" ) ; assert_true_regexp ( ""\\\\B\\\\w\\\\w\\\\w"" , ""abcd"" , ""bcd"" ) ; assert_false_regexp ( ""\\\\B\\\\w\\\\w\\\\w\\\\B"" , ""abcd"" ) ; assert_regexp_syntax_error ( ""(|abc)ef"" ) ; assert_true_regexp ( ""((a)(b)c)(d)"" , ""abcd"" , ""abcd"" ) ; assert_true_regexp ( ""(a|b)c*d"" , ""abcd"" , ""bcd"" ) ; assert_true_regexp ( ""(ab|ab*)bc"" , ""abc"" , ""abc"" ) ; assert_true_regexp ( ""a([bc]*)c*"" , ""abc"" , ""abc"" ) ; assert_true_regexp ( ""a([bc]*)c*"" , ""ac"" , ""ac"" ) ; assert_true_regexp ( ""a([bc]*)c*"" , ""a"" , ""a"" ) ; assert_true_regexp ( ""a([bc]*)(c*d)"" , ""abcd"" , ""abcd"" ) ; assert_true_regexp ( ""a([bc]+)(c*d)"" , ""abcd"" , ""abcd"" ) ; assert_true_regexp ( ""a([bc]*)(c+d)"" , ""abcd"" , ""abcd"" ) ; assert_true_regexp ( ""a[bcd]*dcdcde"" , ""adcdcde"" , ""adcdcde"" ) ; assert_false_regexp ( ""a[bcd]+dcdcde"" , ""adcdcde"" ) ; assert_true_regexp ( ""\\\\((.*),<S2SV_blank>(.*)\\\\)"" , ""(a,<S2SV_blank>b)"" , ""(a,<S2SV_blank>b)"" ) ; assert_true_regexp ( ""abc|123$"" , ""abcx"" , ""abc"" ) ; assert_false_regexp ( ""abc|123$"" , ""123x"" ) ; assert_true_regexp ( ""abc|^123"" , ""123"" , ""123"" ) ; assert_false_regexp ( ""abc|^123"" , ""x123"" ) ; assert_true_regexp ( ""^abc$"" , ""abc"" , ""abc"" ) ; assert_false_regexp ( ""^abc$"" , ""abcc"" ) ; assert_true_regexp ( ""^abc"" , ""abcc"" , ""abc"" ) ; assert_false_regexp ( ""^abc$"" , ""aabc"" ) ; assert_false_regexp ( ""abc^"" , ""abc"" ) ; assert_false_regexp ( ""ab^c"" , ""abc"" ) ; assert_false_regexp ( ""a^bcdef"" , ""abcdef"" ) assert_true_regexp ( ""abc$"" , ""aabc"" , ""abc"" ) ; assert_false_regexp ( ""$abc"" , ""abc"" ) ; assert_true_regexp ( ""(a|a$)bcd"" , ""abcd"" , ""abcd"" ) ; assert_false_regexp ( ""(a$|a$)bcd"" , ""abcd"" ) ; assert_false_regexp ( ""(abc$|ab$)"" , ""abcd"" ) ; assert_true_regexp ( ""^a(bc+|b[eh])g|.h$"" , ""abhg"" , ""abhg"" ) ; assert_true_regexp ( ""(bc+d$|ef*g.|h?i(j|k))"" , ""effgz"" , ""effgz"" ) ; assert_true_regexp ( ""(bc+d$|ef*g.|h?i(j|k))"" , ""ij"" , ""ij"" ) ; assert_false_regexp ( ""(bc+d$|ef*g.|h?i(j|k))"" , ""effg"" ) ; assert_false_regexp ( ""(bc+d$|ef*g.|h?i(j|k))"" , ""bcdd"" ) ; assert_true_regexp ( ""(bc+d$|ef*g.|h?i(j|k))"" , ""reffgz"" , ""effgz"" ) ; assert_true_regexp ( ""whatever|<S2SV_blank><S2SV_blank><S2SV_blank>x.<S2SV_blank><S2SV_blank><S2SV_blank>x"" , ""<S2SV_blank><S2SV_blank><S2SV_blank>xy<S2SV_blank><S2SV_blank><S2SV_blank>x"" , ""<S2SV_blank><S2SV_blank><S2SV_blank>xy<S2SV_blank><S2SV_blank><S2SV_blank>x"" ) ; assert_regexp_syntax_error ( ""\\\\x0"" ) ; assert_regexp_syntax_error ( ""\\\\x"" ) ; assert_regexp_syntax_error ( ""x{0,0}"" ) ; assert_regexp_syntax_error ( ""x{0}"" ) ; assert_regexp_syntax_error ( ""\\\\xxy"" ) ; assert_error ( ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/a\\\\/<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}"" , ERROR_SYNTAX_ERROR ) ; assert_error ( ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/[a\\\\/<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}"" , ERROR_SYNTAX_ERROR ) ; assert_true_rule_blob ( <S2SV_StartBug> ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/MZ.{300,}t/<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>!a<S2SV_blank>==<S2SV_blank>317<S2SV_blank>}"" , <S2SV_EndBug> PE32_FILE ) ; assert_true_rule_blob ( <S2SV_StartBug> ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/MZ.{300,}?t/<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>!a<S2SV_blank>==<S2SV_blank>314<S2SV_blank>}"" , <S2SV_EndBug> PE32_FILE ) ; }","""a\\0x\\0x\\0b\\0"" ) ; assert_true_rule_blob ( ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/\\\\babc/<S2SV_blank>wide<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}"" , ""a\\0b\\0c\\0"" ) ; assert_true_rule_blob ( ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/\\\\babc/<S2SV_blank>wide<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}"" , ""\\0a\\0b\\0c\\0"" ) ; assert_true_rule_blob ( ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/\\\\babc/<S2SV_blank>wide<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}"" , ""\\ta\\0b\\0c\\0"" ) ; assert_false_rule_blob ( ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/\\\\babc/<S2SV_blank>wide<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}"" , ""x\\0a\\0b\\0c\\0"" ) ; assert_true_rule_blob ( ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/\\\\babc/<S2SV_blank>wide<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}"" , ""x\\ta\\0b\\0c\\0"" ) ; assert_true_rule_blob ( ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/abc\\\\b/<S2SV_blank>wide<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}"" , ""a\\0b\\0c\\0"" ) ; assert_true_rule_blob ( ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/abc\\\\b/<S2SV_blank>wide<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}"" , ""a\\0b\\0c\\0\\0"" ) ; assert_true_rule_blob ( ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/abc\\\\b/<S2SV_blank>wide<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}"" , ""a\\0b\\0c\\0\\t"" ) ; assert_false_rule_blob ( ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/abc\\\\b/<S2SV_blank>wide<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}"" , ""a\\0b\\0c\\0x\\0"" ) ; assert_true_rule_blob ( ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/abc\\\\b/<S2SV_blank>wide<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}"" , ""a\\0b\\0c\\0b\\t"" ) ; assert_false_rule_blob ( ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/\\\\b/<S2SV_blank>wide<S2SV_blank>condition:<S2SV_blank>$a<S2SV_blank>}"" , ""abc"" ) ; <S2SV_ModStart> ; assert_true_rule_blob ( ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/MZ.{300,}t/<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>!a<S2SV_blank>==<S2SV_blank>317<S2SV_blank>}"" <S2SV_ModEnd> , PE32_FILE ) <S2SV_ModStart> ; assert_true_rule_blob ( ""rule<S2SV_blank>test<S2SV_blank>{<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>strings:<S2SV_blank>$a<S2SV_blank>=<S2SV_blank>/MZ.{300,}?t/<S2SV_blank>\\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>condition:<S2SV_blank>!a<S2SV_blank>==<S2SV_blank>314<S2SV_blank>}"" <S2SV_ModEnd> , PE32_FILE )"
542,"static void start_daemon ( ) { struct usb_sock_t * usb_sock ; if ( g_options . noprinter_mode == 0 ) { usb_sock = usb_open ( ) ; if ( usb_sock == NULL ) goto cleanup_usb ; } else usb_sock = NULL ; uint16_t desired_port = g_options . desired_port ; <S2SV_StartBug> struct tcp_sock_t * tcp_socket ; <S2SV_EndBug> <S2SV_StartBug> while ( ( tcp_socket = tcp_open ( desired_port ) ) == NULL && <S2SV_EndBug> <S2SV_StartBug> g_options . only_desired_port == 0 ) { <S2SV_EndBug> desired_port ++ ; if ( desired_port == 1 || desired_port == 0 ) desired_port = 49152 ; <S2SV_StartBug> } <S2SV_EndBug> if ( tcp_socket == NULL ) goto cleanup_tcp ; <S2SV_StartBug> uint16_t real_port = tcp_port_number_get ( tcp_socket ) ; <S2SV_EndBug> if ( desired_port != 0 && g_options . only_desired_port == 1 && desired_port != real_port ) { ERR ( ""Received<S2SV_blank>port<S2SV_blank>number<S2SV_blank>did<S2SV_blank>not<S2SV_blank>match<S2SV_blank>requested<S2SV_blank>port<S2SV_blank>number."" ""<S2SV_blank>The<S2SV_blank>requested<S2SV_blank>port<S2SV_blank>number<S2SV_blank>may<S2SV_blank>be<S2SV_blank>too<S2SV_blank>high."" ) ; goto cleanup_tcp ; } printf ( ""%u|"" , real_port ) ; fflush ( stdout ) ; <S2SV_StartBug> uint16_t pid ; <S2SV_EndBug> if ( ! g_options . nofork_mode && ( pid = fork ( ) ) > 0 ) { printf ( ""%u|"" , pid ) ; exit ( 0 ) ; } if ( usb_can_callback ( usb_sock ) ) usb_register_callback ( usb_sock ) ; for ( ; ; ) { struct service_thread_param * args = calloc ( 1 , sizeof ( * args ) ) ; if ( args == NULL ) { ERR ( ""Failed<S2SV_blank>to<S2SV_blank>alloc<S2SV_blank>space<S2SV_blank>for<S2SV_blank>thread<S2SV_blank>args"" ) ; goto cleanup_thread ; } args -> usb_sock = usb_sock ; <S2SV_StartBug> args -> tcp = tcp_conn_accept ( tcp_socket ) ; <S2SV_EndBug> if ( args -> tcp == NULL ) { ERR ( ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>tcp<S2SV_blank>connection"" ) ; goto cleanup_thread ; } int status = pthread_create ( & args -> thread_handle , NULL , & service_connection , args ) ; if ( status ) { ERR ( ""Failed<S2SV_blank>to<S2SV_blank>spawn<S2SV_blank>thread,<S2SV_blank>error<S2SV_blank>%d"" , status ) ; goto cleanup_thread ; } continue ; cleanup_thread : if ( args != NULL ) { if ( args -> tcp != NULL ) tcp_conn_close ( args -> tcp ) ; free ( args ) ; } break ; } cleanup_tcp : if ( tcp_socket != NULL ) tcp_close ( tcp_socket ) ; <S2SV_StartBug> cleanup_usb : <S2SV_EndBug> if ( usb_sock != NULL ) usb_close ( usb_sock ) ; return ; }","tcp_sock_t * tcp_socket = NULL , * tcp6_socket = NULL ; for ( ; ; ) { <S2SV_ModEnd> tcp_socket = tcp_open <S2SV_ModStart> ( desired_port ) ; tcp6_socket = tcp6_open ( desired_port ) ; if ( tcp_socket || tcp6_socket || <S2SV_ModEnd> g_options . only_desired_port <S2SV_ModStart> g_options . only_desired_port ) break ; <S2SV_ModEnd> desired_port ++ ; <S2SV_ModStart> = 49152 ; NOTE ( ""Access<S2SV_blank>to<S2SV_blank>desired<S2SV_blank>port<S2SV_blank>failed,<S2SV_blank>trying<S2SV_blank>alternative<S2SV_blank>port<S2SV_blank>%d"" , desired_port ) ; } if ( tcp_socket == NULL && tcp6_socket <S2SV_ModEnd> == NULL ) <S2SV_ModStart> ; uint16_t real_port ; if ( tcp_socket ) real_port <S2SV_ModStart> tcp_port_number_get ( tcp_socket ) ; else real_port = tcp_port_number_get ( tcp6_socket <S2SV_ModStart> stdout ) ; NOTE ( ""Port:<S2SV_blank>%d,<S2SV_blank>IPv4<S2SV_blank>%savailable,<S2SV_blank>IPv6<S2SV_blank>%savailable"" , real_port , tcp_socket ? """" : ""not<S2SV_blank>"" , tcp6_socket ? """" : ""not<S2SV_blank>"" ) ; <S2SV_ModStart> -> tcp = tcp_conn_select ( tcp_socket , tcp6_socket <S2SV_ModEnd> ) ; if <S2SV_ModStart> tcp_socket ) ; if ( tcp6_socket != NULL ) tcp_close ( tcp6_socket ) ;"
543,"static int do_dentry_open ( struct file * f , int ( * open ) ( struct inode * , struct file * ) , const struct cred * cred ) { static const struct file_operations empty_fops = { } ; struct inode * inode ; int error ; f -> f_mode = OPEN_FMODE ( f -> f_flags ) | FMODE_LSEEK | FMODE_PREAD | FMODE_PWRITE ; if ( unlikely ( f -> f_flags & O_PATH ) ) f -> f_mode = FMODE_PATH ; path_get ( & f -> f_path ) ; inode = f -> f_inode = f -> f_path . dentry -> d_inode ; if ( f -> f_mode & FMODE_WRITE ) { error = __get_file_write_access ( inode , f -> f_path . mnt ) ; if ( error ) goto cleanup_file ; if ( ! special_file ( inode -> i_mode ) ) file_take_write ( f ) ; } f -> f_mapping = inode -> i_mapping ; <S2SV_StartBug> file_sb_list_add ( f , inode -> i_sb ) ; <S2SV_EndBug> if ( unlikely ( f -> f_mode & FMODE_PATH ) ) { f -> f_op = & empty_fops ; return 0 ; } f -> f_op = fops_get ( inode -> i_fop ) ; if ( unlikely ( WARN_ON ( ! f -> f_op ) ) ) { error = - ENODEV ; goto cleanup_all ; } error = security_file_open ( f , cred ) ; if ( error ) goto cleanup_all ; error = break_lease ( inode , f -> f_flags ) ; if ( error ) goto cleanup_all ; if ( ! open ) open = f -> f_op -> open ; if ( open ) { error = open ( inode , f ) ; if ( error ) goto cleanup_all ; } if ( ( f -> f_mode & ( FMODE_READ | FMODE_WRITE ) ) == FMODE_READ ) i_readcount_inc ( inode ) ; f -> f_flags &= ~ ( O_CREAT | O_EXCL | O_NOCTTY | O_TRUNC ) ; file_ra_state_init ( & f -> f_ra , f -> f_mapping -> host -> i_mapping ) ; return 0 ; cleanup_all : fops_put ( f -> f_op ) ; <S2SV_StartBug> file_sb_list_del ( f ) ; <S2SV_EndBug> if ( f -> f_mode & FMODE_WRITE ) { put_write_access ( inode ) ; if ( ! special_file ( inode -> i_mode ) ) { file_reset_write ( f ) ; __mnt_drop_write ( f -> f_path . mnt ) ; } } cleanup_file : path_put ( & f -> f_path ) ; f -> f_path . mnt = NULL ; f -> f_path . dentry = NULL ; f -> f_inode = NULL ; return error ; }",-> i_mapping ; <S2SV_ModEnd> if ( unlikely <S2SV_ModStart> f_op ) ; <S2SV_ModEnd> if ( f
544,"struct sk_buff * __skb_recv_datagram ( struct sock * sk , unsigned int flags , int * peeked , int * off , int * err ) { struct sk_buff * skb ; long timeo ; int error = sock_error ( sk ) ; if ( error ) goto no_packet ; timeo = sock_rcvtimeo ( sk , flags & MSG_DONTWAIT ) ; do { unsigned long cpu_flags ; struct sk_buff_head * queue = & sk -> sk_receive_queue ; spin_lock_irqsave ( & queue -> lock , cpu_flags ) ; skb_queue_walk ( queue , skb ) { * peeked = skb -> peeked ; if ( flags & MSG_PEEK ) { <S2SV_StartBug> if ( * off >= skb -> len ) { <S2SV_EndBug> * off -= skb -> len ; continue ; } skb -> peeked = 1 ; atomic_inc ( & skb -> users ) ; } else __skb_unlink ( skb , queue ) ; spin_unlock_irqrestore ( & queue -> lock , cpu_flags ) ; return skb ; } spin_unlock_irqrestore ( & queue -> lock , cpu_flags ) ; error = - EAGAIN ; if ( ! timeo ) goto no_packet ; } while ( ! wait_for_packet ( sk , err , & timeo ) ) ; return NULL ; no_packet : * err = error ; return NULL ; }",skb -> len && skb -> len
545,"static void babel_print_v2 ( netdissect_options * ndo , const u_char * cp , u_int length ) { u_int i ; u_short bodylen ; u_char v4_prefix [ 16 ] = { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0xFF , 0xFF , 0 , 0 , 0 , 0 } ; u_char v6_prefix [ 16 ] = { 0 } ; ND_TCHECK2 ( * cp , 4 ) ; if ( length < 4 ) goto invalid ; bodylen = EXTRACT_16BITS ( cp + 2 ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>(%u)"" , bodylen ) ) ; i = 0 ; while ( i < bodylen ) { const u_char * message ; u_int type , len ; message = cp + 4 + i ; ND_TCHECK2 ( * message , 1 ) ; if ( ( type = message [ 0 ] ) == MESSAGE_PAD1 ) { ND_PRINT ( ( ndo , ndo -> ndo_vflag ? ""\\n\\tPad<S2SV_blank>1"" : ""<S2SV_blank>pad1"" ) ) ; i += 1 ; continue ; } ND_TCHECK2 ( * message , 2 ) ; ICHECK ( i , 2 ) ; len = message [ 1 ] ; ND_TCHECK2 ( * message , 2 + len ) ; ICHECK ( i , 2 + len ) ; switch ( type ) { case MESSAGE_PADN : { if ( ! ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""<S2SV_blank>padN"" ) ) ; else ND_PRINT ( ( ndo , ""\\n\\tPad<S2SV_blank>%d"" , len + 2 ) ) ; } break ; case MESSAGE_ACK_REQ : { u_short nonce , interval ; if ( ! ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""<S2SV_blank>ack-req"" ) ) ; else { ND_PRINT ( ( ndo , ""\\n\\tAcknowledgment<S2SV_blank>Request<S2SV_blank>"" ) ) ; if ( len < 6 ) goto invalid ; nonce = EXTRACT_16BITS ( message + 4 ) ; interval = EXTRACT_16BITS ( message + 6 ) ; ND_PRINT ( ( ndo , ""%04x<S2SV_blank>%s"" , nonce , format_interval ( interval ) ) ) ; } } break ; case MESSAGE_ACK : { u_short nonce ; if ( ! ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""<S2SV_blank>ack"" ) ) ; else { ND_PRINT ( ( ndo , ""\\n\\tAcknowledgment<S2SV_blank>"" ) ) ; if ( len < 2 ) goto invalid ; nonce = EXTRACT_16BITS ( message + 2 ) ; ND_PRINT ( ( ndo , ""%04x"" , nonce ) ) ; } } break ; case MESSAGE_HELLO : { u_short seqno , interval ; if ( ! ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""<S2SV_blank>hello"" ) ) ; else { ND_PRINT ( ( ndo , ""\\n\\tHello<S2SV_blank>"" ) ) ; if ( len < 6 ) goto invalid ; seqno = EXTRACT_16BITS ( message + 4 ) ; interval = EXTRACT_16BITS ( message + 6 ) ; ND_PRINT ( ( ndo , ""seqno<S2SV_blank>%u<S2SV_blank>interval<S2SV_blank>%s"" , seqno , format_interval ( interval ) ) ) ; if ( len > 6 ) subtlvs_print ( ndo , message + 8 , message + 2 + len , type ) ; } } break ; case MESSAGE_IHU : { unsigned short txcost , interval ; if ( ! ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""<S2SV_blank>ihu"" ) ) ; else { u_char address [ 16 ] ; int rc ; ND_PRINT ( ( ndo , ""\\n\\tIHU<S2SV_blank>"" ) ) ; if ( len < 6 ) goto invalid ; txcost = EXTRACT_16BITS ( message + 4 ) ; interval = EXTRACT_16BITS ( message + 6 ) ; rc = network_address ( message [ 2 ] , message + 8 , len - 6 , address ) ; if ( rc < 0 ) { ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; break ; } ND_PRINT ( ( ndo , ""%s<S2SV_blank>txcost<S2SV_blank>%u<S2SV_blank>interval<S2SV_blank>%s"" , format_address ( ndo , address ) , txcost , format_interval ( interval ) ) ) ; if ( ( u_int ) rc < len - 6 ) subtlvs_print ( ndo , message + 8 + rc , message + 2 + len , type ) ; } } break ; case MESSAGE_ROUTER_ID : { if ( ! ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""<S2SV_blank>router-id"" ) ) ; else { ND_PRINT ( ( ndo , ""\\n\\tRouter<S2SV_blank>Id"" ) ) ; if ( len < 10 ) goto invalid ; ND_PRINT ( ( ndo , ""<S2SV_blank>%s"" , format_id ( message + 4 ) ) ) ; } } break ; case MESSAGE_NH : { if ( ! ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""<S2SV_blank>nh"" ) ) ; else { int rc ; u_char nh [ 16 ] ; ND_PRINT ( ( ndo , ""\\n\\tNext<S2SV_blank>Hop"" ) ) ; if ( len < 2 ) goto invalid ; rc = network_address ( message [ 2 ] , message + 4 , len - 2 , nh ) ; if ( rc < 0 ) goto invalid ; ND_PRINT ( ( ndo , ""<S2SV_blank>%s"" , format_address ( ndo , nh ) ) ) ; } } break ; case MESSAGE_UPDATE : { if ( ! ndo -> ndo_vflag ) { ND_PRINT ( ( ndo , ""<S2SV_blank>update"" ) ) ; <S2SV_StartBug> if ( len < 1 ) <S2SV_EndBug> ND_PRINT ( ( ndo , ""/truncated"" ) ) ; else ND_PRINT ( ( ndo , ""%s%s%s"" , ( message [ 3 ] & 0x80 ) ? ""/prefix"" : """" , ( message [ 3 ] & 0x40 ) ? ""/id"" : """" , ( message [ 3 ] & 0x3f ) ? ""/unknown"" : """" ) ) ; } else { u_short interval , seqno , metric ; u_char plen ; int rc ; u_char prefix [ 16 ] ; ND_PRINT ( ( ndo , ""\\n\\tUpdate"" ) ) ; if ( len < 10 ) goto invalid ; plen = message [ 4 ] + ( message [ 2 ] == 1 ? 96 : 0 ) ; rc = network_prefix ( message [ 2 ] , message [ 4 ] , message [ 5 ] , message + 12 , message [ 2 ] == 1 ? v4_prefix : v6_prefix , len - 10 , prefix ) ; if ( rc < 0 ) goto invalid ; interval = EXTRACT_16BITS ( message + 6 ) ; seqno = EXTRACT_16BITS ( message + 8 ) ; metric = EXTRACT_16BITS ( message + 10 ) ; ND_PRINT ( ( ndo , ""%s%s%s<S2SV_blank>%s<S2SV_blank>metric<S2SV_blank>%u<S2SV_blank>seqno<S2SV_blank>%u<S2SV_blank>interval<S2SV_blank>%s"" , ( message [ 3 ] & 0x80 ) ? ""/prefix"" : """" , ( message [ 3 ] & 0x40 ) ? ""/id"" : """" , ( message [ 3 ] & 0x3f ) ? ""/unknown"" : """" , format_prefix ( ndo , prefix , plen ) , metric , seqno , format_interval_update ( interval ) ) ) ; if ( message [ 3 ] & 0x80 ) { if ( message [ 2 ] == 1 ) memcpy ( v4_prefix , prefix , 16 ) ; else memcpy ( v6_prefix , prefix , 16 ) ; } if ( ( u_int ) rc < len - 10 ) subtlvs_print ( ndo , message + 12 + rc , message + 2 + len , type ) ; } } break ; case MESSAGE_REQUEST : { if ( ! ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""<S2SV_blank>request"" ) ) ; else { int rc ; u_char prefix [ 16 ] , plen ; ND_PRINT ( ( ndo , ""\\n\\tRequest<S2SV_blank>"" ) ) ; if ( len < 2 ) goto invalid ; plen = message [ 3 ] + ( message [ 2 ] == 1 ? 96 : 0 ) ; rc = network_prefix ( message [ 2 ] , message [ 3 ] , 0 , message + 4 , NULL , len - 2 , prefix ) ; if ( rc < 0 ) goto invalid ; ND_PRINT ( ( ndo , ""for<S2SV_blank>%s"" , message [ 2 ] == 0 ? ""any"" : format_prefix ( ndo , prefix , plen ) ) ) ; } } break ; case MESSAGE_MH_REQUEST : { if ( ! ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""<S2SV_blank>mh-request"" ) ) ; else { int rc ; u_short seqno ; u_char prefix [ 16 ] , plen ; ND_PRINT ( ( ndo , ""\\n\\tMH-Request<S2SV_blank>"" ) ) ; if ( len < 14 ) goto invalid ; seqno = EXTRACT_16BITS ( message + 4 ) ; rc = network_prefix ( message [ 2 ] , message [ 3 ] , 0 , message + 16 , NULL , len - 14 , prefix ) ; if ( rc < 0 ) goto invalid ; plen = message [ 3 ] + ( message [ 2 ] == 1 ? 96 : 0 ) ; ND_PRINT ( ( ndo , ""(%u<S2SV_blank>hops)<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>seqno<S2SV_blank>%u<S2SV_blank>id<S2SV_blank>%s"" , message [ 6 ] , format_prefix ( ndo , prefix , plen ) , seqno , format_id ( message + 8 ) ) ) ; } } break ; case MESSAGE_TSPC : if ( ! ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""<S2SV_blank>tspc"" ) ) ; else { ND_PRINT ( ( ndo , ""\\n\\tTS/PC<S2SV_blank>"" ) ) ; if ( len < 6 ) goto invalid ; ND_PRINT ( ( ndo , ""timestamp<S2SV_blank>%u<S2SV_blank>packetcounter<S2SV_blank>%u"" , EXTRACT_32BITS ( message + 4 ) , EXTRACT_16BITS ( message + 2 ) ) ) ; } break ; case MESSAGE_HMAC : { if ( ! ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""<S2SV_blank>hmac"" ) ) ; else { unsigned j ; ND_PRINT ( ( ndo , ""\\n\\tHMAC<S2SV_blank>"" ) ) ; if ( len < 18 ) goto invalid ; ND_PRINT ( ( ndo , ""key-id<S2SV_blank>%u<S2SV_blank>digest-%u<S2SV_blank>"" , EXTRACT_16BITS ( message + 2 ) , len - 2 ) ) ; for ( j = 0 ; j < len - 2 ; j ++ ) ND_PRINT ( ( ndo , ""%02X"" , message [ 4 + j ] ) ) ; } } break ; case MESSAGE_UPDATE_SRC_SPECIFIC : { if ( ! ndo -> ndo_vflag ) { ND_PRINT ( ( ndo , ""<S2SV_blank>ss-update"" ) ) ; } else { u_char prefix [ 16 ] , src_prefix [ 16 ] ; u_short interval , seqno , metric ; u_char ae , plen , src_plen , omitted ; int rc ; int parsed_len = 10 ; ND_PRINT ( ( ndo , ""\\n\\tSS-Update"" ) ) ; if ( len < 10 ) goto invalid ; ae = message [ 2 ] ; src_plen = message [ 3 ] ; plen = message [ 4 ] ; omitted = message [ 5 ] ; interval = EXTRACT_16BITS ( message + 6 ) ; seqno = EXTRACT_16BITS ( message + 8 ) ; metric = EXTRACT_16BITS ( message + 10 ) ; rc = network_prefix ( ae , plen , omitted , message + 2 + parsed_len , ae == 1 ? v4_prefix : v6_prefix , len - parsed_len , prefix ) ; if ( rc < 0 ) goto invalid ; if ( ae == 1 ) plen += 96 ; parsed_len += rc ; rc = network_prefix ( ae , src_plen , 0 , message + 2 + parsed_len , NULL , len - parsed_len , src_prefix ) ; if ( rc < 0 ) goto invalid ; if ( ae == 1 ) src_plen += 96 ; parsed_len += rc ; ND_PRINT ( ( ndo , ""<S2SV_blank>%s<S2SV_blank>from"" , format_prefix ( ndo , prefix , plen ) ) ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>%s<S2SV_blank>metric<S2SV_blank>%u<S2SV_blank>seqno<S2SV_blank>%u<S2SV_blank>interval<S2SV_blank>%s"" , format_prefix ( ndo , src_prefix , src_plen ) , metric , seqno , format_interval_update ( interval ) ) ) ; if ( ( u_int ) parsed_len < len ) subtlvs_print ( ndo , message + 2 + parsed_len , message + 2 + len , type ) ; } } break ; case MESSAGE_REQUEST_SRC_SPECIFIC : { if ( ! ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""<S2SV_blank>ss-request"" ) ) ; else { int rc , parsed_len = 3 ; u_char ae , plen , src_plen , prefix [ 16 ] , src_prefix [ 16 ] ; ND_PRINT ( ( ndo , ""\\n\\tSS-Request<S2SV_blank>"" ) ) ; if ( len < 3 ) goto invalid ; ae = message [ 2 ] ; plen = message [ 3 ] ; src_plen = message [ 4 ] ; rc = network_prefix ( ae , plen , 0 , message + 2 + parsed_len , NULL , len - parsed_len , prefix ) ; if ( rc < 0 ) goto invalid ; if ( ae == 1 ) plen += 96 ; parsed_len += rc ; rc = network_prefix ( ae , src_plen , 0 , message + 2 + parsed_len , NULL , len - parsed_len , src_prefix ) ; if ( rc < 0 ) goto invalid ; if ( ae == 1 ) src_plen += 96 ; parsed_len += rc ; if ( ae == 0 ) { ND_PRINT ( ( ndo , ""for<S2SV_blank>any"" ) ) ; } else { ND_PRINT ( ( ndo , ""for<S2SV_blank>(%s,<S2SV_blank>"" , format_prefix ( ndo , prefix , plen ) ) ) ; ND_PRINT ( ( ndo , ""%s)"" , format_prefix ( ndo , src_prefix , src_plen ) ) ) ; } } } break ; case MESSAGE_MH_REQUEST_SRC_SPECIFIC : { if ( ! ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""<S2SV_blank>ss-mh-request"" ) ) ; else { int rc , parsed_len = 14 ; u_short seqno ; u_char ae , plen , src_plen , prefix [ 16 ] , src_prefix [ 16 ] , hopc ; const u_char * router_id = NULL ; ND_PRINT ( ( ndo , ""\\n\\tSS-MH-Request<S2SV_blank>"" ) ) ; if ( len < 14 ) goto invalid ; ae = message [ 2 ] ; plen = message [ 3 ] ; seqno = EXTRACT_16BITS ( message + 4 ) ; hopc = message [ 6 ] ; src_plen = message [ 7 ] ; router_id = message + 8 ; rc = network_prefix ( ae , plen , 0 , message + 2 + parsed_len , NULL , len - parsed_len , prefix ) ; if ( rc < 0 ) goto invalid ; if ( ae == 1 ) plen += 96 ; parsed_len += rc ; rc = network_prefix ( ae , src_plen , 0 , message + 2 + parsed_len , NULL , len - parsed_len , src_prefix ) ; if ( rc < 0 ) goto invalid ; if ( ae == 1 ) src_plen += 96 ; ND_PRINT ( ( ndo , ""(%u<S2SV_blank>hops)<S2SV_blank>for<S2SV_blank>(%s,<S2SV_blank>"" , hopc , format_prefix ( ndo , prefix , plen ) ) ) ; ND_PRINT ( ( ndo , ""%s)<S2SV_blank>seqno<S2SV_blank>%u<S2SV_blank>id<S2SV_blank>%s"" , format_prefix ( ndo , src_prefix , src_plen ) , seqno , format_id ( router_id ) ) ) ; } } break ; default : if ( ! ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""<S2SV_blank>unknown"" ) ) ; else ND_PRINT ( ( ndo , ""\\n\\tUnknown<S2SV_blank>message<S2SV_blank>type<S2SV_blank>%d"" , type ) ) ; } i += len + 2 ; } return ; trunc : ND_PRINT ( ( ndo , ""<S2SV_blank>%s"" , tstr ) ) ; return ; invalid : ND_PRINT ( ( ndo , ""%s"" , istr ) ) ; return ; }",( len < 10 <S2SV_ModEnd> ) ND_PRINT (
546,"static int trusted_update ( struct key * key , struct key_preparsed_payload * prep ) { struct trusted_key_payload * p ; struct trusted_key_payload * new_p ; struct trusted_key_options * new_o ; size_t datalen = prep -> datalen ; char * datablob ; int ret = 0 ; <S2SV_StartBug> if ( test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) <S2SV_EndBug> return - ENOKEY ; p = key -> payload . data [ 0 ] ; if ( ! p -> migratable ) return - EPERM ; if ( datalen <= 0 || datalen > 32767 || ! prep -> data ) return - EINVAL ; datablob = kmalloc ( datalen + 1 , GFP_KERNEL ) ; if ( ! datablob ) return - ENOMEM ; new_o = trusted_options_alloc ( ) ; if ( ! new_o ) { ret = - ENOMEM ; goto out ; } new_p = trusted_payload_alloc ( key ) ; if ( ! new_p ) { ret = - ENOMEM ; goto out ; } memcpy ( datablob , prep -> data , datalen ) ; datablob [ datalen ] = '\\0' ; ret = datablob_parse ( datablob , new_p , new_o ) ; if ( ret != Opt_update ) { ret = - EINVAL ; kzfree ( new_p ) ; goto out ; } if ( ! new_o -> keyhandle ) { ret = - EINVAL ; kzfree ( new_p ) ; goto out ; } new_p -> migratable = p -> migratable ; new_p -> key_len = p -> key_len ; memcpy ( new_p -> key , p -> key , p -> key_len ) ; dump_payload ( p ) ; dump_payload ( new_p ) ; ret = key_seal ( new_p , new_o ) ; if ( ret < 0 ) { pr_info ( ""trusted_key:<S2SV_blank>key_seal<S2SV_blank>failed<S2SV_blank>(%d)\\n"" , ret ) ; kzfree ( new_p ) ; goto out ; } if ( new_o -> pcrlock ) { ret = pcrlock ( new_o -> pcrlock ) ; if ( ret < 0 ) { pr_info ( ""trusted_key:<S2SV_blank>pcrlock<S2SV_blank>failed<S2SV_blank>(%d)\\n"" , ret ) ; kzfree ( new_p ) ; goto out ; } } rcu_assign_keypointer ( key , new_p ) ; call_rcu ( & p -> rcu , trusted_rcu_free ) ; out : kzfree ( datablob ) ; kzfree ( new_o ) ; return ret ; }",; if ( key_is_negative ( key <S2SV_ModEnd> ) ) return
547,"static int f2fs_mpage_readpages ( struct address_space * mapping , struct list_head * pages , struct page * page , unsigned nr_pages , bool is_readahead ) { struct bio * bio = NULL ; sector_t last_block_in_bio = 0 ; struct inode * inode = mapping -> host ; struct f2fs_map_blocks map ; int ret = 0 ; map . m_pblk = 0 ; map . m_lblk = 0 ; map . m_len = 0 ; map . m_flags = 0 ; map . m_next_pgofs = NULL ; map . m_next_extent = NULL ; map . m_seg_type = NO_CHECK_TYPE ; map . m_may_create = false ; for ( ; nr_pages ; nr_pages -- ) { if ( pages ) { page = list_last_entry ( pages , struct page , lru ) ; prefetchw ( & page -> flags ) ; list_del ( & page -> lru ) ; if ( add_to_page_cache_lru ( page , mapping , <S2SV_StartBug> page -> index , <S2SV_EndBug> readahead_gfp_mask ( mapping ) ) ) goto next_page ; } ret = f2fs_read_single_page ( inode , page , nr_pages , & map , & bio , & last_block_in_bio , is_readahead ) ; if ( ret ) { SetPageError ( page ) ; zero_user_segment ( page , 0 , PAGE_SIZE ) ; unlock_page ( page ) ; } next_page : if ( pages ) put_page ( page ) ; } BUG_ON ( pages && ! list_empty ( pages ) ) ; if ( bio ) __submit_bio ( F2FS_I_SB ( inode ) , bio , DATA ) ; return pages ? 0 : ret ; }",", mapping , page_index ( page ) <S2SV_ModEnd> , readahead_gfp_mask ("
548,"void fslib_copy_libs ( const char * full_path ) { assert ( full_path ) ; if ( arg_debug || arg_debug_private_lib ) printf ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>fslib_copy_libs<S2SV_blank>%s\\n"" , full_path ) ; if ( access ( full_path , R_OK ) ) { if ( arg_debug || arg_debug_private_lib ) printf ( ""cannot<S2SV_blank>find<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>private-lib,<S2SV_blank>skipping...\\n"" , full_path ) ; return ; } unlink ( RUN_LIB_FILE ) ; create_empty_file_as_root ( RUN_LIB_FILE , 0644 ) ; if ( chown ( RUN_LIB_FILE , getuid ( ) , getgid ( ) ) ) errExit ( ""chown"" ) ; if ( arg_debug || arg_debug_private_lib ) printf ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>running<S2SV_blank>fldd<S2SV_blank>%s\\n"" , full_path ) ; sbox_run ( SBOX_USER | SBOX_SECCOMP | SBOX_CAPS_NONE , 3 , PATH_FLDD , full_path , RUN_LIB_FILE ) ; FILE * fp = fopen ( RUN_LIB_FILE , ""r"" ) ; if ( ! fp ) errExit ( ""fopen"" ) ; char buf [ MAXBUF ] ; while ( fgets ( buf , MAXBUF , fp ) ) { char * ptr = strchr ( buf , '\\n' ) ; if ( ptr ) * ptr = '\\0' ; fslib_duplicate ( buf ) ; } fclose ( fp ) ; <S2SV_StartBug> } <S2SV_EndBug>",fp ) ; unlink ( RUN_LIB_FILE ) ;
549,"static int userns_install ( struct nsproxy * nsproxy , void * ns ) { struct user_namespace * user_ns = ns ; struct cred * cred ; if ( user_ns == current_user_ns ( ) ) return - EINVAL ; <S2SV_StartBug> if ( atomic_read ( & current -> mm -> mm_users ) > 1 ) <S2SV_EndBug> return - EINVAL ; if ( ! ns_capable ( user_ns , CAP_SYS_ADMIN ) ) return - EPERM ; cred = prepare_creds ( ) ; if ( ! cred ) return - ENOMEM ; put_user_ns ( cred -> user_ns ) ; set_cred_user_ns ( cred , get_user_ns ( user_ns ) ) ; return commit_creds ( cred ) ; }",mm_users ) > 1 ) return - EINVAL ; if ( current -> fs -> users !=
550,"static int aac_send_raw_srb ( struct aac_dev * dev , void __user * arg ) { struct fib * srbfib ; int status ; struct aac_srb * srbcmd = NULL ; struct user_aac_srb * user_srbcmd = NULL ; struct user_aac_srb __user * user_srb = arg ; struct aac_srb_reply __user * user_reply ; struct aac_srb_reply * reply ; u32 fibsize = 0 ; u32 flags = 0 ; s32 rcode = 0 ; u32 data_dir ; void __user * sg_user [ 32 ] ; void * sg_list [ 32 ] ; u32 sg_indx = 0 ; u32 byte_count = 0 ; u32 actual_fibsize64 , actual_fibsize = 0 ; int i ; if ( dev -> in_reset ) { dprintk ( ( KERN_DEBUG ""aacraid:<S2SV_blank>send<S2SV_blank>raw<S2SV_blank>srb<S2SV_blank>-EBUSY\\n"" ) ) ; return - EBUSY ; } if ( ! capable ( CAP_SYS_ADMIN ) ) { dprintk ( ( KERN_DEBUG ""aacraid:<S2SV_blank>No<S2SV_blank>permission<S2SV_blank>to<S2SV_blank>send<S2SV_blank>raw<S2SV_blank>srb\\n"" ) ) ; return - EPERM ; } if ( ! ( srbfib = aac_fib_alloc ( dev ) ) ) { return - ENOMEM ; } aac_fib_init ( srbfib ) ; srbfib -> hw_fib_va -> header . XferState &= ~ cpu_to_le32 ( FastResponseCapable ) ; srbcmd = ( struct aac_srb * ) fib_data ( srbfib ) ; memset ( sg_list , 0 , sizeof ( sg_list ) ) ; if ( copy_from_user ( & fibsize , & user_srb -> count , sizeof ( u32 ) ) ) { dprintk ( ( KERN_DEBUG ""aacraid:<S2SV_blank>Could<S2SV_blank>not<S2SV_blank>copy<S2SV_blank>data<S2SV_blank>size<S2SV_blank>from<S2SV_blank>user\\n"" ) ) ; rcode = - EFAULT ; goto cleanup ; } <S2SV_StartBug> if ( fibsize > ( dev -> max_fib_size - sizeof ( struct aac_fibhdr ) ) ) { <S2SV_EndBug> rcode = - EINVAL ; goto cleanup ; } user_srbcmd = kmalloc ( fibsize , GFP_KERNEL ) ; if ( ! user_srbcmd ) { dprintk ( ( KERN_DEBUG ""aacraid:<S2SV_blank>Could<S2SV_blank>not<S2SV_blank>make<S2SV_blank>a<S2SV_blank>copy<S2SV_blank>of<S2SV_blank>the<S2SV_blank>srb\\n"" ) ) ; rcode = - ENOMEM ; goto cleanup ; } if ( copy_from_user ( user_srbcmd , user_srb , fibsize ) ) { dprintk ( ( KERN_DEBUG ""aacraid:<S2SV_blank>Could<S2SV_blank>not<S2SV_blank>copy<S2SV_blank>srb<S2SV_blank>from<S2SV_blank>user\\n"" ) ) ; rcode = - EFAULT ; goto cleanup ; } user_reply = arg + fibsize ; flags = user_srbcmd -> flags ; srbcmd -> function = cpu_to_le32 ( SRBF_ExecuteScsi ) ; srbcmd -> channel = cpu_to_le32 ( user_srbcmd -> channel ) ; srbcmd -> id = cpu_to_le32 ( user_srbcmd -> id ) ; srbcmd -> lun = cpu_to_le32 ( user_srbcmd -> lun ) ; srbcmd -> timeout = cpu_to_le32 ( user_srbcmd -> timeout ) ; srbcmd -> flags = cpu_to_le32 ( flags ) ; srbcmd -> retry_limit = 0 ; srbcmd -> cdb_size = cpu_to_le32 ( user_srbcmd -> cdb_size ) ; memcpy ( srbcmd -> cdb , user_srbcmd -> cdb , sizeof ( srbcmd -> cdb ) ) ; switch ( flags & ( SRB_DataIn | SRB_DataOut ) ) { case SRB_DataOut : data_dir = DMA_TO_DEVICE ; break ; case ( SRB_DataIn | SRB_DataOut ) : data_dir = DMA_BIDIRECTIONAL ; break ; case SRB_DataIn : data_dir = DMA_FROM_DEVICE ; break ; default : data_dir = DMA_NONE ; } if ( user_srbcmd -> sg . count > ARRAY_SIZE ( sg_list ) ) { dprintk ( ( KERN_DEBUG ""aacraid:<S2SV_blank>too<S2SV_blank>many<S2SV_blank>sg<S2SV_blank>entries<S2SV_blank>%d\\n"" , le32_to_cpu ( srbcmd -> sg . count ) ) ) ; rcode = - EINVAL ; goto cleanup ; } actual_fibsize = sizeof ( struct aac_srb ) - sizeof ( struct sgentry ) + ( ( user_srbcmd -> sg . count & 0xff ) * sizeof ( struct sgentry ) ) ; actual_fibsize64 = actual_fibsize + ( user_srbcmd -> sg . count & 0xff ) * ( sizeof ( struct sgentry64 ) - sizeof ( struct sgentry ) ) ; if ( ( actual_fibsize != fibsize ) && ( actual_fibsize64 != fibsize ) ) { dprintk ( ( KERN_DEBUG ""aacraid:<S2SV_blank>Bad<S2SV_blank>Size<S2SV_blank>specified<S2SV_blank>in<S2SV_blank>"" ""Raw<S2SV_blank>SRB<S2SV_blank>command<S2SV_blank>calculated<S2SV_blank>fibsize=%lu;%lu<S2SV_blank>"" ""user_srbcmd->sg.count=%d<S2SV_blank>aac_srb=%lu<S2SV_blank>sgentry=%lu;%lu<S2SV_blank>"" ""issued<S2SV_blank>fibsize=%d\\n"" , actual_fibsize , actual_fibsize64 , user_srbcmd -> sg . count , sizeof ( struct aac_srb ) , sizeof ( struct sgentry ) , sizeof ( struct sgentry64 ) , fibsize ) ) ; rcode = - EINVAL ; goto cleanup ; } if ( ( data_dir == DMA_NONE ) && user_srbcmd -> sg . count ) { dprintk ( ( KERN_DEBUG ""aacraid:<S2SV_blank>SG<S2SV_blank>with<S2SV_blank>no<S2SV_blank>direction<S2SV_blank>specified<S2SV_blank>in<S2SV_blank>Raw<S2SV_blank>SRB<S2SV_blank>command\\n"" ) ) ; rcode = - EINVAL ; goto cleanup ; } byte_count = 0 ; if ( dev -> adapter_info . options & AAC_OPT_SGMAP_HOST64 ) { struct user_sgmap64 * upsg = ( struct user_sgmap64 * ) & user_srbcmd -> sg ; struct sgmap64 * psg = ( struct sgmap64 * ) & srbcmd -> sg ; if ( actual_fibsize64 == fibsize ) { actual_fibsize = actual_fibsize64 ; for ( i = 0 ; i < upsg -> count ; i ++ ) { u64 addr ; void * p ; if ( upsg -> sg [ i ] . count > ( ( dev -> adapter_info . options & AAC_OPT_NEW_COMM ) ? ( dev -> scsi_host_ptr -> max_sectors << 9 ) : 65536 ) ) { rcode = - EINVAL ; goto cleanup ; } p = kmalloc ( upsg -> sg [ i ] . count , GFP_KERNEL | __GFP_DMA ) ; if ( ! p ) { dprintk ( ( KERN_DEBUG ""aacraid:<S2SV_blank>Could<S2SV_blank>not<S2SV_blank>allocate<S2SV_blank>SG<S2SV_blank>buffer<S2SV_blank>-<S2SV_blank>size<S2SV_blank>=<S2SV_blank>%d<S2SV_blank>buffer<S2SV_blank>number<S2SV_blank>%d<S2SV_blank>of<S2SV_blank>%d\\n"" , upsg -> sg [ i ] . count , i , upsg -> count ) ) ; rcode = - ENOMEM ; goto cleanup ; } addr = ( u64 ) upsg -> sg [ i ] . addr [ 0 ] ; addr += ( ( u64 ) upsg -> sg [ i ] . addr [ 1 ] ) << 32 ; sg_user [ i ] = ( void __user * ) ( uintptr_t ) addr ; sg_list [ i ] = p ; sg_indx = i ; if ( flags & SRB_DataOut ) { if ( copy_from_user ( p , sg_user [ i ] , upsg -> sg [ i ] . count ) ) { dprintk ( ( KERN_DEBUG ""aacraid:<S2SV_blank>Could<S2SV_blank>not<S2SV_blank>copy<S2SV_blank>sg<S2SV_blank>data<S2SV_blank>from<S2SV_blank>user\\n"" ) ) ; rcode = - EFAULT ; goto cleanup ; } } addr = pci_map_single ( dev -> pdev , p , upsg -> sg [ i ] . count , data_dir ) ; psg -> sg [ i ] . addr [ 0 ] = cpu_to_le32 ( addr & 0xffffffff ) ; psg -> sg [ i ] . addr [ 1 ] = cpu_to_le32 ( addr >> 32 ) ; byte_count += upsg -> sg [ i ] . count ; psg -> sg [ i ] . count = cpu_to_le32 ( upsg -> sg [ i ] . count ) ; } } else { struct user_sgmap * usg ; usg = kmalloc ( actual_fibsize - sizeof ( struct aac_srb ) + sizeof ( struct sgmap ) , GFP_KERNEL ) ; if ( ! usg ) { dprintk ( ( KERN_DEBUG ""aacraid:<S2SV_blank>Allocation<S2SV_blank>error<S2SV_blank>in<S2SV_blank>Raw<S2SV_blank>SRB<S2SV_blank>command\\n"" ) ) ; rcode = - ENOMEM ; goto cleanup ; } memcpy ( usg , upsg , actual_fibsize - sizeof ( struct aac_srb ) + sizeof ( struct sgmap ) ) ; actual_fibsize = actual_fibsize64 ; for ( i = 0 ; i < usg -> count ; i ++ ) { u64 addr ; void * p ; if ( usg -> sg [ i ] . count > ( ( dev -> adapter_info . options & AAC_OPT_NEW_COMM ) ? ( dev -> scsi_host_ptr -> max_sectors << 9 ) : 65536 ) ) { kfree ( usg ) ; rcode = - EINVAL ; goto cleanup ; } p = kmalloc ( usg -> sg [ i ] . count , GFP_KERNEL | __GFP_DMA ) ; if ( ! p ) { dprintk ( ( KERN_DEBUG ""aacraid:<S2SV_blank>Could<S2SV_blank>not<S2SV_blank>allocate<S2SV_blank>SG<S2SV_blank>buffer<S2SV_blank>-<S2SV_blank>size<S2SV_blank>=<S2SV_blank>%d<S2SV_blank>buffer<S2SV_blank>number<S2SV_blank>%d<S2SV_blank>of<S2SV_blank>%d\\n"" , usg -> sg [ i ] . count , i , usg -> count ) ) ; kfree ( usg ) ; rcode = - ENOMEM ; goto cleanup ; } sg_user [ i ] = ( void __user * ) ( uintptr_t ) usg -> sg [ i ] . addr ; sg_list [ i ] = p ; sg_indx = i ; if ( flags & SRB_DataOut ) { if ( copy_from_user ( p , sg_user [ i ] , upsg -> sg [ i ] . count ) ) { kfree ( usg ) ; dprintk ( ( KERN_DEBUG ""aacraid:<S2SV_blank>Could<S2SV_blank>not<S2SV_blank>copy<S2SV_blank>sg<S2SV_blank>data<S2SV_blank>from<S2SV_blank>user\\n"" ) ) ; rcode = - EFAULT ; goto cleanup ; } } addr = pci_map_single ( dev -> pdev , p , usg -> sg [ i ] . count , data_dir ) ; psg -> sg [ i ] . addr [ 0 ] = cpu_to_le32 ( addr & 0xffffffff ) ; psg -> sg [ i ] . addr [ 1 ] = cpu_to_le32 ( addr >> 32 ) ; byte_count += usg -> sg [ i ] . count ; psg -> sg [ i ] . count = cpu_to_le32 ( usg -> sg [ i ] . count ) ; } kfree ( usg ) ; } srbcmd -> count = cpu_to_le32 ( byte_count ) ; psg -> count = cpu_to_le32 ( sg_indx + 1 ) ; status = aac_fib_send ( ScsiPortCommand64 , srbfib , actual_fibsize , FsaNormal , 1 , 1 , NULL , NULL ) ; } else { struct user_sgmap * upsg = & user_srbcmd -> sg ; struct sgmap * psg = & srbcmd -> sg ; if ( actual_fibsize64 == fibsize ) { struct user_sgmap64 * usg = ( struct user_sgmap64 * ) upsg ; for ( i = 0 ; i < upsg -> count ; i ++ ) { uintptr_t addr ; void * p ; if ( usg -> sg [ i ] . count > ( ( dev -> adapter_info . options & AAC_OPT_NEW_COMM ) ? ( dev -> scsi_host_ptr -> max_sectors << 9 ) : 65536 ) ) { rcode = - EINVAL ; goto cleanup ; } p = kmalloc ( usg -> sg [ i ] . count , GFP_KERNEL | __GFP_DMA ) ; if ( ! p ) { dprintk ( ( KERN_DEBUG ""aacraid:<S2SV_blank>Could<S2SV_blank>not<S2SV_blank>allocate<S2SV_blank>SG<S2SV_blank>buffer<S2SV_blank>-<S2SV_blank>size<S2SV_blank>=<S2SV_blank>%d<S2SV_blank>buffer<S2SV_blank>number<S2SV_blank>%d<S2SV_blank>of<S2SV_blank>%d\\n"" , usg -> sg [ i ] . count , i , usg -> count ) ) ; rcode = - ENOMEM ; goto cleanup ; } addr = ( u64 ) usg -> sg [ i ] . addr [ 0 ] ; addr += ( ( u64 ) usg -> sg [ i ] . addr [ 1 ] ) << 32 ; sg_user [ i ] = ( void __user * ) addr ; sg_list [ i ] = p ; sg_indx = i ; if ( flags & SRB_DataOut ) { if ( copy_from_user ( p , sg_user [ i ] , usg -> sg [ i ] . count ) ) { dprintk ( ( KERN_DEBUG ""aacraid:<S2SV_blank>Could<S2SV_blank>not<S2SV_blank>copy<S2SV_blank>sg<S2SV_blank>data<S2SV_blank>from<S2SV_blank>user\\n"" ) ) ; rcode = - EFAULT ; goto cleanup ; } } addr = pci_map_single ( dev -> pdev , p , usg -> sg [ i ] . count , data_dir ) ; psg -> sg [ i ] . addr = cpu_to_le32 ( addr & 0xffffffff ) ; byte_count += usg -> sg [ i ] . count ; psg -> sg [ i ] . count = cpu_to_le32 ( usg -> sg [ i ] . count ) ; } } else { for ( i = 0 ; i < upsg -> count ; i ++ ) { dma_addr_t addr ; void * p ; if ( upsg -> sg [ i ] . count > ( ( dev -> adapter_info . options & AAC_OPT_NEW_COMM ) ? ( dev -> scsi_host_ptr -> max_sectors << 9 ) : 65536 ) ) { rcode = - EINVAL ; goto cleanup ; } p = kmalloc ( upsg -> sg [ i ] . count , GFP_KERNEL ) ; if ( ! p ) { dprintk ( ( KERN_DEBUG ""aacraid:<S2SV_blank>Could<S2SV_blank>not<S2SV_blank>allocate<S2SV_blank>SG<S2SV_blank>buffer<S2SV_blank>-<S2SV_blank>size<S2SV_blank>=<S2SV_blank>%d<S2SV_blank>buffer<S2SV_blank>number<S2SV_blank>%d<S2SV_blank>of<S2SV_blank>%d\\n"" , upsg -> sg [ i ] . count , i , upsg -> count ) ) ; rcode = - ENOMEM ; goto cleanup ; } sg_user [ i ] = ( void __user * ) ( uintptr_t ) upsg -> sg [ i ] . addr ; sg_list [ i ] = p ; sg_indx = i ; if ( flags & SRB_DataOut ) { if ( copy_from_user ( p , sg_user [ i ] , upsg -> sg [ i ] . count ) ) { dprintk ( ( KERN_DEBUG ""aacraid:<S2SV_blank>Could<S2SV_blank>not<S2SV_blank>copy<S2SV_blank>sg<S2SV_blank>data<S2SV_blank>from<S2SV_blank>user\\n"" ) ) ; rcode = - EFAULT ; goto cleanup ; } } addr = pci_map_single ( dev -> pdev , p , upsg -> sg [ i ] . count , data_dir ) ; psg -> sg [ i ] . addr = cpu_to_le32 ( addr ) ; byte_count += upsg -> sg [ i ] . count ; psg -> sg [ i ] . count = cpu_to_le32 ( upsg -> sg [ i ] . count ) ; } } srbcmd -> count = cpu_to_le32 ( byte_count ) ; psg -> count = cpu_to_le32 ( sg_indx + 1 ) ; status = aac_fib_send ( ScsiPortCommand , srbfib , actual_fibsize , FsaNormal , 1 , 1 , NULL , NULL ) ; } if ( status == - ERESTARTSYS ) { rcode = - ERESTARTSYS ; goto cleanup ; } if ( status != 0 ) { dprintk ( ( KERN_DEBUG ""aacraid:<S2SV_blank>Could<S2SV_blank>not<S2SV_blank>send<S2SV_blank>raw<S2SV_blank>srb<S2SV_blank>fib<S2SV_blank>to<S2SV_blank>hba\\n"" ) ) ; rcode = - ENXIO ; goto cleanup ; } if ( flags & SRB_DataIn ) { for ( i = 0 ; i <= sg_indx ; i ++ ) { byte_count = le32_to_cpu ( ( dev -> adapter_info . options & AAC_OPT_SGMAP_HOST64 ) ? ( ( struct sgmap64 * ) & srbcmd -> sg ) -> sg [ i ] . count : srbcmd -> sg . sg [ i ] . count ) ; if ( copy_to_user ( sg_user [ i ] , sg_list [ i ] , byte_count ) ) { dprintk ( ( KERN_DEBUG ""aacraid:<S2SV_blank>Could<S2SV_blank>not<S2SV_blank>copy<S2SV_blank>sg<S2SV_blank>data<S2SV_blank>to<S2SV_blank>user\\n"" ) ) ; rcode = - EFAULT ; goto cleanup ; } } } reply = ( struct aac_srb_reply * ) fib_data ( srbfib ) ; if ( copy_to_user ( user_reply , reply , sizeof ( struct aac_srb_reply ) ) ) { dprintk ( ( KERN_DEBUG ""aacraid:<S2SV_blank>Could<S2SV_blank>not<S2SV_blank>copy<S2SV_blank>reply<S2SV_blank>to<S2SV_blank>user\\n"" ) ) ; rcode = - EFAULT ; goto cleanup ; } cleanup : kfree ( user_srbcmd ) ; for ( i = 0 ; i <= sg_indx ; i ++ ) { kfree ( sg_list [ i ] ) ; } if ( rcode != - ERESTARTSYS ) { aac_fib_complete ( srbfib ) ; aac_fib_free ( srbfib ) ; } return rcode ; }",} if ( ( fibsize < ( sizeof ( struct user_aac_srb ) - sizeof ( struct user_sgentry ) ) ) || ( <S2SV_ModStart> ( struct aac_fibhdr )
551,"void pointZZ_pDouble ( PointZZ_p * rop , const PointZZ_p * op , const CurveZZ_p * curve ) { <S2SV_StartBug> mpz_t numer , denom , lambda ; <S2SV_EndBug> mpz_inits ( numer , denom , lambda , NULL ) ; mpz_mul ( numer , op -> x , op -> x ) ; mpz_mul_ui ( numer , numer , 3 ) ; mpz_add ( numer , numer , curve -> a ) ; mpz_mul_ui ( denom , op -> y , 2 ) ; mpz_invert ( denom , denom , curve -> p ) ; mpz_mul ( lambda , numer , denom ) ; mpz_mod ( lambda , lambda , curve -> p ) ; mpz_mul ( rop -> x , lambda , lambda ) ; mpz_sub ( rop -> x , rop -> x , op -> x ) ; mpz_sub ( rop -> x , rop -> x , op -> x ) ; mpz_mod ( rop -> x , rop -> x , curve -> p ) ; mpz_sub ( rop -> y , op -> x , rop -> x ) ; mpz_mul ( rop -> y , lambda , rop -> y ) ; mpz_sub ( rop -> y , rop -> y , op -> y ) ; mpz_mod ( rop -> y , rop -> y , curve -> p ) ; mpz_clears ( numer , denom , lambda , NULL ) ; }",curve ) { if ( pointZZ_pIsIdentityElement ( op ) ) { return pointZZ_pSetToIdentityElement ( rop ) ; }
552,"void vp8_update_gf_useage_maps ( VP8_COMP * cpi , VP8_COMMON * cm , MACROBLOCK * x ) { int mb_row , mb_col ; MODE_INFO * this_mb_mode_info = cm -> mi ; x -> gf_active_ptr = ( signed char * ) cpi -> gf_active_flags ; if ( ( cm -> frame_type == KEY_FRAME ) || ( cm -> refresh_golden_frame ) ) { <S2SV_StartBug> vpx_memset ( cpi -> gf_active_flags , 1 , ( cm -> mb_rows * cm -> mb_cols ) ) ; <S2SV_EndBug> cpi -> gf_active_count = cm -> mb_rows * cm -> mb_cols ; } else { for ( mb_row = 0 ; mb_row < cm -> mb_rows ; mb_row ++ ) { for ( mb_col = 0 ; mb_col < cm -> mb_cols ; mb_col ++ ) { if ( ( this_mb_mode_info -> mbmi . ref_frame == GOLDEN_FRAME ) || ( this_mb_mode_info -> mbmi . ref_frame == ALTREF_FRAME ) ) { if ( * ( x -> gf_active_ptr ) == 0 ) { * ( x -> gf_active_ptr ) = 1 ; cpi -> gf_active_count ++ ; } } else if ( ( this_mb_mode_info -> mbmi . mode != ZEROMV ) && * ( x -> gf_active_ptr ) ) { * ( x -> gf_active_ptr ) = 0 ; cpi -> gf_active_count -- ; } x -> gf_active_ptr ++ ; this_mb_mode_info ++ ; } this_mb_mode_info ++ ; } } }",) ) { memset <S2SV_ModEnd> ( cpi ->
553,"<S2SV_StartBug> void * H264SwDecMalloc ( u32 size ) <S2SV_EndBug> { # if defined ( CHECK_MEMORY_USAGE ) static u32 numBytes = 0 ; <S2SV_StartBug> numBytes += size ; <S2SV_EndBug> DEBUG ( ( ""Allocated<S2SV_blank>%d<S2SV_blank>bytes,<S2SV_blank>total<S2SV_blank>%d\\n"" , size , numBytes ) ) ; # endif <S2SV_StartBug> return malloc ( size ) ; <S2SV_EndBug> }","( u32 size , u32 num ) { if ( size > UINT32_MAX / num ) { return NULL ; } <S2SV_ModEnd> # if defined <S2SV_ModStart> numBytes += size * num <S2SV_ModStart> malloc ( size * num"
554,"static int readContigStripsIntoBuffer ( TIFF * in , uint8 * buf ) { uint8 * bufp = buf ; int32 bytes_read = 0 ; uint32 strip , nstrips = TIFFNumberOfStrips ( in ) ; uint32 stripsize = TIFFStripSize ( in ) ; uint32 rows = 0 ; uint32 rps = TIFFGetFieldDefaulted ( in , TIFFTAG_ROWSPERSTRIP , & rps ) ; tsize_t scanline_size = TIFFScanlineSize ( in ) ; if ( scanline_size == 0 ) { TIFFError ( """" , ""TIFF<S2SV_blank>scanline<S2SV_blank>size<S2SV_blank>is<S2SV_blank>zero!"" ) ; return 0 ; } for ( strip = 0 ; strip < nstrips ; strip ++ ) { bytes_read = TIFFReadEncodedStrip ( in , strip , bufp , - 1 ) ; rows = bytes_read / scanline_size ; if ( ( strip < ( nstrips - 1 ) ) && ( bytes_read != ( int32 ) stripsize ) ) TIFFError ( """" , ""Strip<S2SV_blank>%d:<S2SV_blank>read<S2SV_blank>%lu<S2SV_blank>bytes,<S2SV_blank>strip<S2SV_blank>size<S2SV_blank>%lu"" , ( int ) strip + 1 , ( unsigned long ) bytes_read , ( unsigned long ) stripsize ) ; if ( bytes_read < 0 && ! ignore ) { TIFFError ( """" , ""Error<S2SV_blank>reading<S2SV_blank>strip<S2SV_blank>%lu<S2SV_blank>after<S2SV_blank>%lu<S2SV_blank>rows"" , ( unsigned long ) strip , ( unsigned long ) rows ) ; return 0 ; } <S2SV_StartBug> bufp += bytes_read ; <S2SV_EndBug> } return 1 ; }",} bufp += stripsize <S2SV_ModEnd> ; } return
555,"struct resource_pool * dce100_create_resource_pool ( uint8_t num_virtual_links , struct dc * dc ) { struct dce110_resource_pool * pool = kzalloc ( sizeof ( struct dce110_resource_pool ) , GFP_KERNEL ) ; if ( ! pool ) return NULL ; if ( construct ( num_virtual_links , dc , pool ) ) return & pool -> base ; <S2SV_StartBug> BREAK_TO_DEBUGGER ( ) ; <S2SV_EndBug> return NULL ; }",-> base ; kfree ( pool ) ;
556,"static __inline__ int scm_check_creds ( struct ucred * creds ) { const struct cred * cred = current_cred ( ) ; kuid_t uid = make_kuid ( cred -> user_ns , creds -> uid ) ; kgid_t gid = make_kgid ( cred -> user_ns , creds -> gid ) ; if ( ! uid_valid ( uid ) || ! gid_valid ( gid ) ) return - EINVAL ; <S2SV_StartBug> if ( ( creds -> pid == task_tgid_vnr ( current ) || nsown_capable ( CAP_SYS_ADMIN ) ) && <S2SV_EndBug> ( ( uid_eq ( uid , cred -> uid ) || uid_eq ( uid , cred -> euid ) || uid_eq ( uid , cred -> suid ) ) || nsown_capable ( CAP_SETUID ) ) && ( ( gid_eq ( gid , cred -> gid ) || gid_eq ( gid , cred -> egid ) || gid_eq ( gid , cred -> sgid ) ) || nsown_capable ( CAP_SETGID ) ) ) { return 0 ; } return - EPERM ; }","current ) || ns_capable ( current -> nsproxy -> pid_ns -> user_ns , <S2SV_ModEnd> CAP_SYS_ADMIN ) )"
557,"static int adjust_scalar_min_max_vals ( struct bpf_verifier_env * env , struct bpf_insn * insn , struct bpf_reg_state * dst_reg , struct bpf_reg_state src_reg ) { struct bpf_reg_state * regs = cur_regs ( env ) ; u8 opcode = BPF_OP ( insn -> code ) ; bool src_known , dst_known ; s64 smin_val , smax_val ; u64 umin_val , umax_val ; if ( BPF_CLASS ( insn -> code ) != BPF_ALU64 ) { <S2SV_StartBug> coerce_reg_to_32 ( dst_reg ) ; <S2SV_EndBug> <S2SV_StartBug> coerce_reg_to_32 ( & src_reg ) ; <S2SV_EndBug> } smin_val = src_reg . smin_value ; smax_val = src_reg . smax_value ; umin_val = src_reg . umin_value ; umax_val = src_reg . umax_value ; src_known = tnum_is_const ( src_reg . var_off ) ; dst_known = tnum_is_const ( dst_reg -> var_off ) ; switch ( opcode ) { case BPF_ADD : if ( signed_add_overflows ( dst_reg -> smin_value , smin_val ) || signed_add_overflows ( dst_reg -> smax_value , smax_val ) ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value += smin_val ; dst_reg -> smax_value += smax_val ; } if ( dst_reg -> umin_value + umin_val < umin_val || dst_reg -> umax_value + umax_val < umax_val ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value += umin_val ; dst_reg -> umax_value += umax_val ; } dst_reg -> var_off = tnum_add ( dst_reg -> var_off , src_reg . var_off ) ; break ; case BPF_SUB : if ( signed_sub_overflows ( dst_reg -> smin_value , smax_val ) || signed_sub_overflows ( dst_reg -> smax_value , smin_val ) ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value -= smax_val ; dst_reg -> smax_value -= smin_val ; } if ( dst_reg -> umin_value < umax_val ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value -= umax_val ; dst_reg -> umax_value -= umin_val ; } dst_reg -> var_off = tnum_sub ( dst_reg -> var_off , src_reg . var_off ) ; break ; case BPF_MUL : dst_reg -> var_off = tnum_mul ( dst_reg -> var_off , src_reg . var_off ) ; if ( smin_val < 0 || dst_reg -> smin_value < 0 ) { __mark_reg_unbounded ( dst_reg ) ; __update_reg_bounds ( dst_reg ) ; break ; } if ( umax_val > U32_MAX || dst_reg -> umax_value > U32_MAX ) { __mark_reg_unbounded ( dst_reg ) ; __update_reg_bounds ( dst_reg ) ; break ; } dst_reg -> umin_value *= umin_val ; dst_reg -> umax_value *= umax_val ; if ( dst_reg -> umax_value > S64_MAX ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } break ; case BPF_AND : if ( src_known && dst_known ) { __mark_reg_known ( dst_reg , dst_reg -> var_off . value & src_reg . var_off . value ) ; break ; } dst_reg -> var_off = tnum_and ( dst_reg -> var_off , src_reg . var_off ) ; dst_reg -> umin_value = dst_reg -> var_off . value ; dst_reg -> umax_value = min ( dst_reg -> umax_value , umax_val ) ; if ( dst_reg -> smin_value < 0 || smin_val < 0 ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } __update_reg_bounds ( dst_reg ) ; break ; case BPF_OR : if ( src_known && dst_known ) { __mark_reg_known ( dst_reg , dst_reg -> var_off . value | src_reg . var_off . value ) ; break ; } dst_reg -> var_off = tnum_or ( dst_reg -> var_off , src_reg . var_off ) ; dst_reg -> umin_value = max ( dst_reg -> umin_value , umin_val ) ; dst_reg -> umax_value = dst_reg -> var_off . value | dst_reg -> var_off . mask ; if ( dst_reg -> smin_value < 0 || smin_val < 0 ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } __update_reg_bounds ( dst_reg ) ; break ; case BPF_LSH : if ( umax_val > 63 ) { mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; if ( dst_reg -> umax_value > 1ULL << ( 63 - umax_val ) ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value <<= umin_val ; dst_reg -> umax_value <<= umax_val ; } if ( src_known ) dst_reg -> var_off = tnum_lshift ( dst_reg -> var_off , umin_val ) ; else dst_reg -> var_off = tnum_lshift ( tnum_unknown , umin_val ) ; __update_reg_bounds ( dst_reg ) ; break ; case BPF_RSH : if ( umax_val > 63 ) { mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; if ( src_known ) dst_reg -> var_off = tnum_rshift ( dst_reg -> var_off , umin_val ) ; else dst_reg -> var_off = tnum_rshift ( tnum_unknown , umin_val ) ; dst_reg -> umin_value >>= umax_val ; dst_reg -> umax_value >>= umin_val ; __update_reg_bounds ( dst_reg ) ; break ; default : mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } __reg_deduce_bounds ( dst_reg ) ; __reg_bound_offset ( dst_reg ) ; return 0 ; }","BPF_ALU64 ) { coerce_reg_to_size ( dst_reg , 4 ) ; coerce_reg_to_size <S2SV_ModEnd> ( & src_reg <S2SV_ModStart> ( & src_reg , 4"
558,"static void request_key_auth_describe ( const struct key * key , struct seq_file * m ) { struct request_key_auth * rka = key -> payload . data [ 0 ] ; seq_puts ( m , ""key:"" ) ; seq_puts ( m , key -> description ) ; <S2SV_StartBug> if ( key_is_instantiated ( key ) ) <S2SV_EndBug> seq_printf ( m , ""<S2SV_blank>pid:%d<S2SV_blank>ci:%zu"" , rka -> pid , rka -> callout_len ) ; }",; if ( key_is_positive <S2SV_ModEnd> ( key )
559,"static int snd_timer_user_tselect ( struct file * file , struct snd_timer_select __user * _tselect ) { struct snd_timer_user * tu ; struct snd_timer_select tselect ; char str [ 32 ] ; int err = 0 ; tu = file -> private_data ; if ( tu -> timeri ) { snd_timer_close ( tu -> timeri ) ; tu -> timeri = NULL ; } if ( copy_from_user ( & tselect , _tselect , sizeof ( tselect ) ) ) { err = - EFAULT ; goto __err ; } sprintf ( str , ""application<S2SV_blank>%i"" , current -> pid ) ; if ( tselect . id . dev_class != SNDRV_TIMER_CLASS_SLAVE ) tselect . id . dev_sclass = SNDRV_TIMER_SCLASS_APPLICATION ; err = snd_timer_open ( & tu -> timeri , str , & tselect . id , current -> pid ) ; if ( err < 0 ) goto __err ; <S2SV_StartBug> kfree ( tu -> queue ) ; <S2SV_EndBug> tu -> queue = NULL ; kfree ( tu -> tqueue ) ; tu -> tqueue = NULL ; if ( tu -> tread ) { tu -> tqueue = kmalloc ( tu -> queue_size * sizeof ( struct snd_timer_tread ) , GFP_KERNEL ) ; if ( tu -> tqueue == NULL ) err = - ENOMEM ; } else { tu -> queue = kmalloc ( tu -> queue_size * sizeof ( struct snd_timer_read ) , GFP_KERNEL ) ; if ( tu -> queue == NULL ) err = - ENOMEM ; } if ( err < 0 ) { snd_timer_close ( tu -> timeri ) ; tu -> timeri = NULL ; } else { tu -> timeri -> flags |= SNDRV_TIMER_IFLG_FAST ; tu -> timeri -> callback = tu -> tread ? snd_timer_user_tinterrupt : snd_timer_user_interrupt ; tu -> timeri -> ccallback = snd_timer_user_ccallback ; tu -> timeri -> callback_data = ( void * ) tu ; tu -> timeri -> disconnect = snd_timer_user_disconnect ; } __err : return err ; }",goto __err ; tu -> qhead = tu -> qtail = tu -> qused = 0 ;
560,"static int ext4_ext_split ( handle_t * handle , struct inode * inode , unsigned int flags , struct ext4_ext_path * path , struct ext4_extent * newext , int at ) { struct buffer_head * bh = NULL ; int depth = ext_depth ( inode ) ; struct ext4_extent_header * neh ; struct ext4_extent_idx * fidx ; int i = at , k , m , a ; ext4_fsblk_t newblock , oldblock ; __le32 border ; ext4_fsblk_t * ablocks = NULL ; int err = 0 ; <S2SV_StartBug> if ( unlikely ( path [ depth ] . p_ext > EXT_MAX_EXTENT ( path [ depth ] . p_hdr ) ) ) { <S2SV_EndBug> EXT4_ERROR_INODE ( inode , ""p_ext<S2SV_blank>><S2SV_blank>EXT_MAX_EXTENT!"" ) ; return - EFSCORRUPTED ; } if ( path [ depth ] . p_ext != EXT_MAX_EXTENT ( path [ depth ] . p_hdr ) ) { border = path [ depth ] . p_ext [ 1 ] . ee_block ; ext_debug ( ""leaf<S2SV_blank>will<S2SV_blank>be<S2SV_blank>split."" ""<S2SV_blank>next<S2SV_blank>leaf<S2SV_blank>starts<S2SV_blank>at<S2SV_blank>%d\\n"" , le32_to_cpu ( border ) ) ; } else { border = newext -> ee_block ; ext_debug ( ""leaf<S2SV_blank>will<S2SV_blank>be<S2SV_blank>added."" ""<S2SV_blank>next<S2SV_blank>leaf<S2SV_blank>starts<S2SV_blank>at<S2SV_blank>%d\\n"" , le32_to_cpu ( border ) ) ; } ablocks = kcalloc ( depth , sizeof ( ext4_fsblk_t ) , GFP_NOFS ) ; if ( ! ablocks ) return - ENOMEM ; ext_debug ( ""allocate<S2SV_blank>%d<S2SV_blank>blocks<S2SV_blank>for<S2SV_blank>indexes/leaf\\n"" , depth - at ) ; for ( a = 0 ; a < depth - at ; a ++ ) { newblock = ext4_ext_new_meta_block ( handle , inode , path , newext , & err , flags ) ; if ( newblock == 0 ) goto cleanup ; ablocks [ a ] = newblock ; } newblock = ablocks [ -- a ] ; if ( unlikely ( newblock == 0 ) ) { EXT4_ERROR_INODE ( inode , ""newblock<S2SV_blank>==<S2SV_blank>0!"" ) ; err = - EFSCORRUPTED ; goto cleanup ; } bh = sb_getblk_gfp ( inode -> i_sb , newblock , __GFP_MOVABLE | GFP_NOFS ) ; if ( unlikely ( ! bh ) ) { err = - ENOMEM ; goto cleanup ; } lock_buffer ( bh ) ; err = ext4_journal_get_create_access ( handle , bh ) ; if ( err ) goto cleanup ; neh = ext_block_hdr ( bh ) ; neh -> eh_entries = 0 ; neh -> eh_max = cpu_to_le16 ( ext4_ext_space_block ( inode , 0 ) ) ; neh -> eh_magic = EXT4_EXT_MAGIC ; neh -> eh_depth = 0 ; if ( unlikely ( path [ depth ] . p_hdr -> eh_entries != path [ depth ] . p_hdr -> eh_max ) ) { EXT4_ERROR_INODE ( inode , ""eh_entries<S2SV_blank>%d<S2SV_blank>!=<S2SV_blank>eh_max<S2SV_blank>%d!"" , path [ depth ] . p_hdr -> eh_entries , path [ depth ] . p_hdr -> eh_max ) ; err = - EFSCORRUPTED ; goto cleanup ; } m = EXT_MAX_EXTENT ( path [ depth ] . p_hdr ) - path [ depth ] . p_ext ++ ; ext4_ext_show_move ( inode , path , newblock , depth ) ; if ( m ) { struct ext4_extent * ex ; ex = EXT_FIRST_EXTENT ( neh ) ; memmove ( ex , path [ depth ] . p_ext , sizeof ( struct ext4_extent ) * m ) ; le16_add_cpu ( & neh -> eh_entries , m ) ; } <S2SV_StartBug> ext4_extent_block_csum_set ( inode , neh ) ; <S2SV_EndBug> set_buffer_uptodate ( bh ) ; unlock_buffer ( bh ) ; err = ext4_handle_dirty_metadata ( handle , inode , bh ) ; if ( err ) goto cleanup ; brelse ( bh ) ; bh = NULL ; if ( m ) { err = ext4_ext_get_access ( handle , inode , path + depth ) ; if ( err ) goto cleanup ; le16_add_cpu ( & path [ depth ] . p_hdr -> eh_entries , - m ) ; err = ext4_ext_dirty ( handle , inode , path + depth ) ; if ( err ) goto cleanup ; } k = depth - at - 1 ; if ( unlikely ( k < 0 ) ) { EXT4_ERROR_INODE ( inode , ""k<S2SV_blank>%d<S2SV_blank><<S2SV_blank>0!"" , k ) ; err = - EFSCORRUPTED ; goto cleanup ; } if ( k ) ext_debug ( ""create<S2SV_blank>%d<S2SV_blank>intermediate<S2SV_blank>indices\\n"" , k ) ; i = depth - 1 ; while ( k -- ) { oldblock = newblock ; newblock = ablocks [ -- a ] ; bh = sb_getblk ( inode -> i_sb , newblock ) ; if ( unlikely ( ! bh ) ) { err = - ENOMEM ; goto cleanup ; } lock_buffer ( bh ) ; err = ext4_journal_get_create_access ( handle , bh ) ; if ( err ) goto cleanup ; neh = ext_block_hdr ( bh ) ; neh -> eh_entries = cpu_to_le16 ( 1 ) ; neh -> eh_magic = EXT4_EXT_MAGIC ; neh -> eh_max = cpu_to_le16 ( ext4_ext_space_block_idx ( inode , 0 ) ) ; neh -> eh_depth = cpu_to_le16 ( depth - i ) ; fidx = EXT_FIRST_INDEX ( neh ) ; fidx -> ei_block = border ; ext4_idx_store_pblock ( fidx , oldblock ) ; ext_debug ( ""int.index<S2SV_blank>at<S2SV_blank>%d<S2SV_blank>(block<S2SV_blank>%llu):<S2SV_blank>%u<S2SV_blank>-><S2SV_blank>%llu\\n"" , i , newblock , le32_to_cpu ( border ) , oldblock ) ; if ( unlikely ( EXT_MAX_INDEX ( path [ i ] . p_hdr ) != EXT_LAST_INDEX ( path [ i ] . p_hdr ) ) ) { EXT4_ERROR_INODE ( inode , ""EXT_MAX_INDEX<S2SV_blank>!=<S2SV_blank>EXT_LAST_INDEX<S2SV_blank>ee_block<S2SV_blank>%d!"" , le32_to_cpu ( path [ i ] . p_ext -> ee_block ) ) ; err = - EFSCORRUPTED ; goto cleanup ; } m = EXT_MAX_INDEX ( path [ i ] . p_hdr ) - path [ i ] . p_idx ++ ; ext_debug ( ""cur<S2SV_blank>0x%p,<S2SV_blank>last<S2SV_blank>0x%p\\n"" , path [ i ] . p_idx , EXT_MAX_INDEX ( path [ i ] . p_hdr ) ) ; ext4_ext_show_move ( inode , path , newblock , i ) ; if ( m ) { memmove ( ++ fidx , path [ i ] . p_idx , sizeof ( struct ext4_extent_idx ) * m ) ; le16_add_cpu ( & neh -> eh_entries , m ) ; } <S2SV_StartBug> ext4_extent_block_csum_set ( inode , neh ) ; <S2SV_EndBug> set_buffer_uptodate ( bh ) ; unlock_buffer ( bh ) ; err = ext4_handle_dirty_metadata ( handle , inode , bh ) ; if ( err ) goto cleanup ; brelse ( bh ) ; bh = NULL ; if ( m ) { err = ext4_ext_get_access ( handle , inode , path + i ) ; if ( err ) goto cleanup ; le16_add_cpu ( & path [ i ] . p_hdr -> eh_entries , - m ) ; err = ext4_ext_dirty ( handle , inode , path + i ) ; if ( err ) goto cleanup ; } i -- ; } err = ext4_ext_insert_index ( handle , inode , path + at , le32_to_cpu ( border ) , newblock ) ; cleanup : if ( bh ) { if ( buffer_locked ( bh ) ) unlock_buffer ( bh ) ; brelse ( bh ) ; } if ( err ) { for ( i = 0 ; i < depth ; i ++ ) { if ( ! ablocks [ i ] ) continue ; ext4_free_blocks ( handle , inode , NULL , ablocks [ i ] , 1 , EXT4_FREE_BLOCKS_METADATA ) ; } } kfree ( ablocks ) ; return err ; }","= 0 ; size_t ext_size = 0 ; <S2SV_ModStart> ) ; } ext_size = sizeof ( struct ext4_extent_header ) + sizeof ( struct ext4_extent ) * le16_to_cpu ( neh -> eh_entries ) ; memset ( bh -> b_data + ext_size , 0 , inode -> i_sb -> s_blocksize - ext_size ) ; <S2SV_ModStart> ) ; } ext_size = sizeof ( struct ext4_extent_header ) + ( sizeof ( struct ext4_extent ) * le16_to_cpu ( neh -> eh_entries ) ) ; memset ( bh -> b_data + ext_size , 0 , inode -> i_sb -> s_blocksize - ext_size ) ;"
561,"int iwl_pcie_ctxt_info_gen3_init ( struct iwl_trans * trans , const struct fw_img * fw ) { struct iwl_trans_pcie * trans_pcie = IWL_TRANS_GET_PCIE_TRANS ( trans ) ; struct iwl_context_info_gen3 * ctxt_info_gen3 ; struct iwl_prph_scratch * prph_scratch ; struct iwl_prph_scratch_ctrl_cfg * prph_sc_ctrl ; struct iwl_prph_info * prph_info ; void * iml_img ; u32 control_flags = 0 ; int ret ; int cmdq_size = max_t ( u32 , IWL_CMD_QUEUE_SIZE , trans -> cfg -> min_txq_size ) ; prph_scratch = dma_alloc_coherent ( trans -> dev , sizeof ( * prph_scratch ) , & trans_pcie -> prph_scratch_dma_addr , GFP_KERNEL ) ; if ( ! prph_scratch ) return - ENOMEM ; prph_sc_ctrl = & prph_scratch -> ctrl_cfg ; prph_sc_ctrl -> version . version = 0 ; prph_sc_ctrl -> version . mac_id = cpu_to_le16 ( ( u16 ) iwl_read32 ( trans , CSR_HW_REV ) ) ; prph_sc_ctrl -> version . size = cpu_to_le16 ( sizeof ( * prph_scratch ) / 4 ) ; control_flags = IWL_PRPH_SCRATCH_RB_SIZE_4K | IWL_PRPH_SCRATCH_MTR_MODE | ( IWL_PRPH_MTR_FORMAT_256B & IWL_PRPH_SCRATCH_MTR_FORMAT ) | IWL_PRPH_SCRATCH_EARLY_DEBUG_EN | IWL_PRPH_SCRATCH_EDBG_DEST_DRAM ; prph_sc_ctrl -> control . control_flags = cpu_to_le32 ( control_flags ) ; prph_sc_ctrl -> rbd_cfg . free_rbd_addr = cpu_to_le64 ( trans_pcie -> rxq -> bd_dma ) ; if ( ! iwl_trans_dbg_ini_valid ( trans ) ) iwl_pcie_alloc_fw_monitor ( trans , 0 ) ; if ( trans -> dbg . num_blocks ) { prph_sc_ctrl -> hwm_cfg . hwm_base_addr = cpu_to_le64 ( trans -> dbg . fw_mon [ 0 ] . physical ) ; prph_sc_ctrl -> hwm_cfg . hwm_size = cpu_to_le32 ( trans -> dbg . fw_mon [ 0 ] . size ) ; } ret = iwl_pcie_init_fw_sec ( trans , fw , & prph_scratch -> dram ) ; <S2SV_StartBug> if ( ret ) { <S2SV_EndBug> dma_free_coherent ( trans -> dev , sizeof ( * prph_scratch ) , prph_scratch , trans_pcie -> prph_scratch_dma_addr ) ; return ret ; } prph_info = dma_alloc_coherent ( trans -> dev , sizeof ( * prph_info ) , & trans_pcie -> prph_info_dma_addr , GFP_KERNEL ) ; <S2SV_StartBug> if ( ! prph_info ) <S2SV_EndBug> return - ENOMEM ; <S2SV_StartBug> ctxt_info_gen3 = dma_alloc_coherent ( trans -> dev , <S2SV_EndBug> sizeof ( * ctxt_info_gen3 ) , & trans_pcie -> ctxt_info_dma_addr , GFP_KERNEL ) ; if ( ! ctxt_info_gen3 ) return - ENOMEM ; ctxt_info_gen3 -> prph_info_base_addr = cpu_to_le64 ( trans_pcie -> prph_info_dma_addr ) ; ctxt_info_gen3 -> prph_scratch_base_addr = cpu_to_le64 ( trans_pcie -> prph_scratch_dma_addr ) ; ctxt_info_gen3 -> prph_scratch_size = cpu_to_le32 ( sizeof ( * prph_scratch ) ) ; ctxt_info_gen3 -> cr_head_idx_arr_base_addr = cpu_to_le64 ( trans_pcie -> rxq -> rb_stts_dma ) ; ctxt_info_gen3 -> tr_tail_idx_arr_base_addr = cpu_to_le64 ( trans_pcie -> rxq -> tr_tail_dma ) ; ctxt_info_gen3 -> cr_tail_idx_arr_base_addr = cpu_to_le64 ( trans_pcie -> rxq -> cr_tail_dma ) ; ctxt_info_gen3 -> cr_idx_arr_size = cpu_to_le16 ( IWL_NUM_OF_COMPLETION_RINGS ) ; ctxt_info_gen3 -> tr_idx_arr_size = cpu_to_le16 ( IWL_NUM_OF_TRANSFER_RINGS ) ; ctxt_info_gen3 -> mtr_base_addr = cpu_to_le64 ( trans_pcie -> txq [ trans_pcie -> cmd_queue ] -> dma_addr ) ; ctxt_info_gen3 -> mcr_base_addr = cpu_to_le64 ( trans_pcie -> rxq -> used_bd_dma ) ; ctxt_info_gen3 -> mtr_size = cpu_to_le16 ( TFD_QUEUE_CB_SIZE ( cmdq_size ) ) ; ctxt_info_gen3 -> mcr_size = cpu_to_le16 ( RX_QUEUE_CB_SIZE ( MQ_RX_TABLE_SIZE ) ) ; trans_pcie -> ctxt_info_gen3 = ctxt_info_gen3 ; trans_pcie -> prph_info = prph_info ; trans_pcie -> prph_scratch = prph_scratch ; iml_img = dma_alloc_coherent ( trans -> dev , trans -> iml_len , & trans_pcie -> iml_dma_addr , GFP_KERNEL ) ; if ( ! iml_img ) return - ENOMEM ; memcpy ( iml_img , trans -> iml , trans -> iml_len ) ; iwl_enable_fw_load_int_ctx_info ( trans ) ; iwl_write64 ( trans , CSR_CTXT_INFO_ADDR , trans_pcie -> ctxt_info_dma_addr ) ; iwl_write64 ( trans , CSR_IML_DATA_ADDR , trans_pcie -> iml_dma_addr ) ; iwl_write32 ( trans , CSR_IML_SIZE_ADDR , trans -> iml_len ) ; iwl_set_bit ( trans , CSR_CTXT_INFO_BOOT_CTRL , CSR_AUTO_FUNC_BOOT_ENA ) ; if ( trans -> trans_cfg -> device_family >= IWL_DEVICE_FAMILY_AX210 ) iwl_write_umac_prph ( trans , UREG_CPU_INIT_RUN , 1 ) ; else iwl_set_bit ( trans , CSR_GP_CNTRL , CSR_AUTO_FUNC_INIT ) ; return 0 ; <S2SV_StartBug> } <S2SV_EndBug>","( ret ) goto err_free_prph_scratch ; <S2SV_ModEnd> prph_info = dma_alloc_coherent <S2SV_ModStart> ( ! prph_info ) { ret = - ENOMEM ; goto err_free_prph_scratch ; } ctxt_info_gen3 = dma_alloc_coherent ( trans -> dev , sizeof ( * ctxt_info_gen3 ) , & trans_pcie -> ctxt_info_dma_addr , GFP_KERNEL ) ; if ( ! ctxt_info_gen3 ) { ret = - ENOMEM ; goto err_free_prph_info ; } ctxt_info_gen3 -> prph_info_base_addr = cpu_to_le64 ( trans_pcie -> prph_info_dma_addr ) ; ctxt_info_gen3 -> prph_scratch_base_addr = cpu_to_le64 ( trans_pcie -> prph_scratch_dma_addr ) ; ctxt_info_gen3 -> prph_scratch_size = cpu_to_le32 ( sizeof ( * prph_scratch ) ) ; ctxt_info_gen3 -> cr_head_idx_arr_base_addr = cpu_to_le64 ( trans_pcie -> rxq -> rb_stts_dma ) ; ctxt_info_gen3 -> tr_tail_idx_arr_base_addr = cpu_to_le64 ( trans_pcie -> rxq -> tr_tail_dma ) ; ctxt_info_gen3 -> cr_tail_idx_arr_base_addr = cpu_to_le64 ( trans_pcie -> rxq -> cr_tail_dma ) ; ctxt_info_gen3 -> cr_idx_arr_size = cpu_to_le16 ( IWL_NUM_OF_COMPLETION_RINGS ) ; ctxt_info_gen3 -> tr_idx_arr_size = cpu_to_le16 ( IWL_NUM_OF_TRANSFER_RINGS ) ; ctxt_info_gen3 -> mtr_base_addr = cpu_to_le64 ( trans_pcie -> txq [ trans_pcie -> cmd_queue ] -> dma_addr ) ; ctxt_info_gen3 -> mcr_base_addr = cpu_to_le64 ( trans_pcie -> rxq -> used_bd_dma ) ; ctxt_info_gen3 -> mtr_size = cpu_to_le16 ( TFD_QUEUE_CB_SIZE ( cmdq_size ) ) ; ctxt_info_gen3 -> mcr_size = cpu_to_le16 ( RX_QUEUE_CB_SIZE ( MQ_RX_TABLE_SIZE ) ) ; trans_pcie -> ctxt_info_gen3 = ctxt_info_gen3 ; trans_pcie -> prph_info = prph_info ; trans_pcie -> prph_scratch = prph_scratch ; iml_img = dma_alloc_coherent ( trans -> dev , trans -> iml_len , & trans_pcie -> iml_dma_addr , GFP_KERNEL ) ; if ( ! iml_img <S2SV_ModStart> - ENOMEM ; <S2SV_ModEnd> memcpy ( iml_img <S2SV_ModStart> return 0 ; err_free_prph_info : dma_free_coherent ( trans -> dev , sizeof ( * prph_info ) , prph_info , trans_pcie -> prph_info_dma_addr ) ; err_free_prph_scratch : dma_free_coherent ( trans -> dev , sizeof ( * prph_scratch ) , prph_scratch , trans_pcie -> prph_scratch_dma_addr ) ; return ret ;"
562,"static int get_siz ( Jpeg2000DecoderContext * s ) { int i ; int ncomponents ; uint32_t log2_chroma_wh = 0 ; const enum AVPixelFormat * possible_fmts = NULL ; int possible_fmts_nb = 0 ; if ( bytestream2_get_bytes_left ( & s -> g ) < 36 ) return AVERROR_INVALIDDATA ; s -> avctx -> profile = bytestream2_get_be16u ( & s -> g ) ; s -> width = bytestream2_get_be32u ( & s -> g ) ; s -> height = bytestream2_get_be32u ( & s -> g ) ; s -> image_offset_x = bytestream2_get_be32u ( & s -> g ) ; s -> image_offset_y = bytestream2_get_be32u ( & s -> g ) ; s -> tile_width = bytestream2_get_be32u ( & s -> g ) ; s -> tile_height = bytestream2_get_be32u ( & s -> g ) ; s -> tile_offset_x = bytestream2_get_be32u ( & s -> g ) ; s -> tile_offset_y = bytestream2_get_be32u ( & s -> g ) ; ncomponents = bytestream2_get_be16u ( & s -> g ) ; if ( ncomponents <= 0 ) { av_log ( s -> avctx , AV_LOG_ERROR , ""Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>components:<S2SV_blank>%d\\n"" , s -> ncomponents ) ; return AVERROR_INVALIDDATA ; } if ( ncomponents > 4 ) { avpriv_request_sample ( s -> avctx , ""Support<S2SV_blank>for<S2SV_blank>%d<S2SV_blank>components"" , s -> ncomponents ) ; return AVERROR_PATCHWELCOME ; } s -> ncomponents = ncomponents ; if ( s -> tile_width <= 0 || s -> tile_height <= 0 ) { av_log ( s -> avctx , AV_LOG_ERROR , ""Invalid<S2SV_blank>tile<S2SV_blank>dimension<S2SV_blank>%dx%d.\\n"" , s -> tile_width , s -> tile_height ) ; return AVERROR_INVALIDDATA ; } if ( bytestream2_get_bytes_left ( & s -> g ) < 3 * s -> ncomponents ) return AVERROR_INVALIDDATA ; for ( i = 0 ; i < s -> ncomponents ; i ++ ) { uint8_t x = bytestream2_get_byteu ( & s -> g ) ; s -> cbps [ i ] = ( x & 0x7f ) + 1 ; s -> precision = FFMAX ( s -> cbps [ i ] , s -> precision ) ; s -> sgnd [ i ] = ! ! ( x & 0x80 ) ; s -> cdx [ i ] = bytestream2_get_byteu ( & s -> g ) ; s -> cdy [ i ] = bytestream2_get_byteu ( & s -> g ) ; <S2SV_StartBug> if ( ! s -> cdx [ i ] || ! s -> cdy [ i ] ) { <S2SV_EndBug> av_log ( s -> avctx , AV_LOG_ERROR , ""Invalid<S2SV_blank>sample<S2SV_blank>seperation\\n"" ) ; return AVERROR_INVALIDDATA ; } log2_chroma_wh |= s -> cdy [ i ] >> 1 << i * 4 | s -> cdx [ i ] >> 1 << i * 4 + 2 ; } s -> numXtiles = ff_jpeg2000_ceildiv ( s -> width - s -> tile_offset_x , s -> tile_width ) ; s -> numYtiles = ff_jpeg2000_ceildiv ( s -> height - s -> tile_offset_y , s -> tile_height ) ; if ( s -> numXtiles * ( uint64_t ) s -> numYtiles > INT_MAX / sizeof ( * s -> tile ) ) { s -> numXtiles = s -> numYtiles = 0 ; return AVERROR ( EINVAL ) ; } s -> tile = av_mallocz_array ( s -> numXtiles * s -> numYtiles , sizeof ( * s -> tile ) ) ; if ( ! s -> tile ) { s -> numXtiles = s -> numYtiles = 0 ; return AVERROR ( ENOMEM ) ; } for ( i = 0 ; i < s -> numXtiles * s -> numYtiles ; i ++ ) { Jpeg2000Tile * tile = s -> tile + i ; tile -> comp = av_mallocz ( s -> ncomponents * sizeof ( * tile -> comp ) ) ; if ( ! tile -> comp ) return AVERROR ( ENOMEM ) ; } s -> avctx -> width = ff_jpeg2000_ceildivpow2 ( s -> width - s -> image_offset_x , s -> reduction_factor ) ; s -> avctx -> height = ff_jpeg2000_ceildivpow2 ( s -> height - s -> image_offset_y , s -> reduction_factor ) ; if ( s -> avctx -> profile == FF_PROFILE_JPEG2000_DCINEMA_2K || s -> avctx -> profile == FF_PROFILE_JPEG2000_DCINEMA_4K ) { possible_fmts = xyz_pix_fmts ; possible_fmts_nb = FF_ARRAY_ELEMS ( xyz_pix_fmts ) ; } else { switch ( s -> colour_space ) { case 16 : possible_fmts = rgb_pix_fmts ; possible_fmts_nb = FF_ARRAY_ELEMS ( rgb_pix_fmts ) ; break ; case 17 : possible_fmts = gray_pix_fmts ; possible_fmts_nb = FF_ARRAY_ELEMS ( gray_pix_fmts ) ; break ; case 18 : possible_fmts = yuv_pix_fmts ; possible_fmts_nb = FF_ARRAY_ELEMS ( yuv_pix_fmts ) ; break ; default : possible_fmts = all_pix_fmts ; possible_fmts_nb = FF_ARRAY_ELEMS ( all_pix_fmts ) ; break ; } } for ( i = 0 ; i < possible_fmts_nb ; ++ i ) { if ( pix_fmt_match ( possible_fmts [ i ] , ncomponents , s -> precision , log2_chroma_wh , s -> pal8 ) ) { s -> avctx -> pix_fmt = possible_fmts [ i ] ; break ; } } if ( s -> avctx -> pix_fmt == AV_PIX_FMT_NONE ) { av_log ( s -> avctx , AV_LOG_ERROR , ""Unknown<S2SV_blank>pix_fmt,<S2SV_blank>profile:<S2SV_blank>%d,<S2SV_blank>colour_space:<S2SV_blank>%d,<S2SV_blank>"" ""components:<S2SV_blank>%d,<S2SV_blank>precision:<S2SV_blank>%d,<S2SV_blank>"" ""cdx[1]:<S2SV_blank>%d,<S2SV_blank>cdy[1]:<S2SV_blank>%d,<S2SV_blank>cdx[2]:<S2SV_blank>%d,<S2SV_blank>cdy[2]:<S2SV_blank>%d\\n"" , s -> avctx -> profile , s -> colour_space , ncomponents , s -> precision , ncomponents > 2 ? s -> cdx [ 1 ] : 0 , ncomponents > 2 ? s -> cdy [ 1 ] : 0 , ncomponents > 2 ? s -> cdx [ 2 ] : 0 , ncomponents > 2 ? s -> cdy [ 2 ] : 0 ) ; } return 0 ; }",i ] || s -> cdx [ i ] == 3 || s -> cdx [ i ] > 4 || <S2SV_ModStart> [ i ] || s -> cdy [ i ] == 3 || s -> cdy [ i ] > 4
563,"static int ndp_sock_recv ( struct ndp * ndp ) { struct ndp_msg * msg ; enum ndp_msg_type msg_type ; size_t len ; int err ; msg = ndp_msg_alloc ( ) ; if ( ! msg ) return - ENOMEM ; len = ndp_msg_payload_maxlen ( msg ) ; err = myrecvfrom6 ( ndp -> sock , msg -> buf , & len , 0 , <S2SV_StartBug> & msg -> addrto , & msg -> ifindex ) ; <S2SV_EndBug> if ( err ) { err ( ndp , ""Failed<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>message"" ) ; goto free_msg ; } <S2SV_StartBug> dbg ( ndp , ""rcvd<S2SV_blank>from:<S2SV_blank>%s,<S2SV_blank>ifindex:<S2SV_blank>%u"" , <S2SV_EndBug> <S2SV_StartBug> str_in6_addr ( & msg -> addrto ) , msg -> ifindex ) ; <S2SV_EndBug> if ( len < sizeof ( * msg -> icmp6_hdr ) ) { warn ( ndp , ""rcvd<S2SV_blank>icmp6<S2SV_blank>packet<S2SV_blank>too<S2SV_blank>short<S2SV_blank>(%luB)"" , len ) ; err = 0 ; goto free_msg ; } err = ndp_msg_type_by_raw_type ( & msg_type , msg -> icmp6_hdr -> icmp6_type ) ; if ( err ) { err = 0 ; goto free_msg ; } ndp_msg_init ( msg , msg_type ) ; ndp_msg_payload_len_set ( msg , len ) ; if ( ! ndp_msg_check_valid ( msg ) ) { warn ( ndp , ""rcvd<S2SV_blank>invalid<S2SV_blank>ND<S2SV_blank>message"" ) ; err = 0 ; goto free_msg ; } dbg ( ndp , ""rcvd<S2SV_blank>%s,<S2SV_blank>len:<S2SV_blank>%zuB"" , ndp_msg_type_info ( msg_type ) -> strabbr , len ) ; if ( ! ndp_msg_check_opts ( msg ) ) { err = 0 ; goto free_msg ; } err = ndp_call_handlers ( ndp , msg ) ; ; free_msg : ndp_msg_destroy ( msg ) ; return err ; }","msg -> ifindex , & msg -> hoplimit <S2SV_ModStart> ( ndp , ""rcvd<S2SV_blank>from:<S2SV_blank>%s,<S2SV_blank>ifindex:<S2SV_blank>%u,<S2SV_blank>hoplimit:<S2SV_blank>%d"" <S2SV_ModEnd> , str_in6_addr ( <S2SV_ModStart> msg -> ifindex , msg -> hoplimit ) ; if ( msg -> hoplimit != 255 ) { warn ( ndp , ""ignoring<S2SV_blank>packet<S2SV_blank>with<S2SV_blank>bad<S2SV_blank>hop<S2SV_blank>limit<S2SV_blank>(%d)"" , msg -> hoplimit ) ; err = 0 ; goto free_msg ; } <S2SV_ModEnd> if ( len"
564,"static int udf_read_inode ( struct inode * inode , bool hidden_inode ) { struct buffer_head * bh = NULL ; struct fileEntry * fe ; struct extendedFileEntry * efe ; uint16_t ident ; struct udf_inode_info * iinfo = UDF_I ( inode ) ; struct udf_sb_info * sbi = UDF_SB ( inode -> i_sb ) ; struct kernel_lb_addr * iloc = & iinfo -> i_location ; unsigned int link_count ; unsigned int indirections = 0 ; int bs = inode -> i_sb -> s_blocksize ; int ret = - EIO ; reread : if ( iloc -> logicalBlockNum >= sbi -> s_partmaps [ iloc -> partitionReferenceNum ] . s_partition_len ) { udf_debug ( ""block=%d,<S2SV_blank>partition=%d<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range\\n"" , iloc -> logicalBlockNum , iloc -> partitionReferenceNum ) ; return - EIO ; } bh = udf_read_ptagged ( inode -> i_sb , iloc , 0 , & ident ) ; if ( ! bh ) { udf_err ( inode -> i_sb , ""(ino<S2SV_blank>%ld)<S2SV_blank>failed<S2SV_blank>!bh\\n"" , inode -> i_ino ) ; return - EIO ; } if ( ident != TAG_IDENT_FE && ident != TAG_IDENT_EFE && ident != TAG_IDENT_USE ) { udf_err ( inode -> i_sb , ""(ino<S2SV_blank>%ld)<S2SV_blank>failed<S2SV_blank>ident=%d\\n"" , inode -> i_ino , ident ) ; goto out ; } fe = ( struct fileEntry * ) bh -> b_data ; efe = ( struct extendedFileEntry * ) bh -> b_data ; if ( fe -> icbTag . strategyType == cpu_to_le16 ( 4096 ) ) { struct buffer_head * ibh ; ibh = udf_read_ptagged ( inode -> i_sb , iloc , 1 , & ident ) ; if ( ident == TAG_IDENT_IE && ibh ) { struct kernel_lb_addr loc ; struct indirectEntry * ie ; ie = ( struct indirectEntry * ) ibh -> b_data ; loc = lelb_to_cpu ( ie -> indirectICB . extLocation ) ; if ( ie -> indirectICB . extLength ) { brelse ( ibh ) ; memcpy ( & iinfo -> i_location , & loc , sizeof ( struct kernel_lb_addr ) ) ; if ( ++ indirections > UDF_MAX_ICB_NESTING ) { udf_err ( inode -> i_sb , ""too<S2SV_blank>many<S2SV_blank>ICBs<S2SV_blank>in<S2SV_blank>ICB<S2SV_blank>hierarchy"" ""<S2SV_blank>(max<S2SV_blank>%d<S2SV_blank>supported)\\n"" , UDF_MAX_ICB_NESTING ) ; goto out ; } brelse ( bh ) ; goto reread ; } } brelse ( ibh ) ; } else if ( fe -> icbTag . strategyType != cpu_to_le16 ( 4 ) ) { udf_err ( inode -> i_sb , ""unsupported<S2SV_blank>strategy<S2SV_blank>type:<S2SV_blank>%d\\n"" , le16_to_cpu ( fe -> icbTag . strategyType ) ) ; goto out ; } if ( fe -> icbTag . strategyType == cpu_to_le16 ( 4 ) ) iinfo -> i_strat4096 = 0 ; else iinfo -> i_strat4096 = 1 ; iinfo -> i_alloc_type = le16_to_cpu ( fe -> icbTag . flags ) & ICBTAG_FLAG_AD_MASK ; iinfo -> i_unique = 0 ; iinfo -> i_lenEAttr = 0 ; iinfo -> i_lenExtents = 0 ; iinfo -> i_lenAlloc = 0 ; iinfo -> i_next_alloc_block = 0 ; iinfo -> i_next_alloc_goal = 0 ; if ( fe -> descTag . tagIdent == cpu_to_le16 ( TAG_IDENT_EFE ) ) { iinfo -> i_efe = 1 ; iinfo -> i_use = 0 ; ret = udf_alloc_i_data ( inode , bs - sizeof ( struct extendedFileEntry ) ) ; if ( ret ) goto out ; memcpy ( iinfo -> i_ext . i_data , bh -> b_data + sizeof ( struct extendedFileEntry ) , bs - sizeof ( struct extendedFileEntry ) ) ; } else if ( fe -> descTag . tagIdent == cpu_to_le16 ( TAG_IDENT_FE ) ) { iinfo -> i_efe = 0 ; iinfo -> i_use = 0 ; ret = udf_alloc_i_data ( inode , bs - sizeof ( struct fileEntry ) ) ; if ( ret ) goto out ; memcpy ( iinfo -> i_ext . i_data , bh -> b_data + sizeof ( struct fileEntry ) , bs - sizeof ( struct fileEntry ) ) ; } else if ( fe -> descTag . tagIdent == cpu_to_le16 ( TAG_IDENT_USE ) ) { iinfo -> i_efe = 0 ; iinfo -> i_use = 1 ; iinfo -> i_lenAlloc = le32_to_cpu ( ( ( struct unallocSpaceEntry * ) bh -> b_data ) -> lengthAllocDescs ) ; ret = udf_alloc_i_data ( inode , bs - sizeof ( struct unallocSpaceEntry ) ) ; if ( ret ) goto out ; memcpy ( iinfo -> i_ext . i_data , bh -> b_data + sizeof ( struct unallocSpaceEntry ) , bs - sizeof ( struct unallocSpaceEntry ) ) ; return 0 ; } ret = - EIO ; read_lock ( & sbi -> s_cred_lock ) ; i_uid_write ( inode , le32_to_cpu ( fe -> uid ) ) ; if ( ! uid_valid ( inode -> i_uid ) || UDF_QUERY_FLAG ( inode -> i_sb , UDF_FLAG_UID_IGNORE ) || UDF_QUERY_FLAG ( inode -> i_sb , UDF_FLAG_UID_SET ) ) inode -> i_uid = UDF_SB ( inode -> i_sb ) -> s_uid ; i_gid_write ( inode , le32_to_cpu ( fe -> gid ) ) ; if ( ! gid_valid ( inode -> i_gid ) || UDF_QUERY_FLAG ( inode -> i_sb , UDF_FLAG_GID_IGNORE ) || UDF_QUERY_FLAG ( inode -> i_sb , UDF_FLAG_GID_SET ) ) inode -> i_gid = UDF_SB ( inode -> i_sb ) -> s_gid ; if ( fe -> icbTag . fileType != ICBTAG_FILE_TYPE_DIRECTORY && sbi -> s_fmode != UDF_INVALID_MODE ) inode -> i_mode = sbi -> s_fmode ; else if ( fe -> icbTag . fileType == ICBTAG_FILE_TYPE_DIRECTORY && sbi -> s_dmode != UDF_INVALID_MODE ) inode -> i_mode = sbi -> s_dmode ; else inode -> i_mode = udf_convert_permissions ( fe ) ; inode -> i_mode &= ~ sbi -> s_umask ; read_unlock ( & sbi -> s_cred_lock ) ; link_count = le16_to_cpu ( fe -> fileLinkCount ) ; if ( ! link_count ) { if ( ! hidden_inode ) { ret = - ESTALE ; goto out ; } link_count = 1 ; } set_nlink ( inode , link_count ) ; inode -> i_size = le64_to_cpu ( fe -> informationLength ) ; iinfo -> i_lenExtents = inode -> i_size ; if ( iinfo -> i_efe == 0 ) { inode -> i_blocks = le64_to_cpu ( fe -> logicalBlocksRecorded ) << ( inode -> i_sb -> s_blocksize_bits - 9 ) ; if ( ! udf_disk_stamp_to_time ( & inode -> i_atime , fe -> accessTime ) ) inode -> i_atime = sbi -> s_record_time ; if ( ! udf_disk_stamp_to_time ( & inode -> i_mtime , fe -> modificationTime ) ) inode -> i_mtime = sbi -> s_record_time ; if ( ! udf_disk_stamp_to_time ( & inode -> i_ctime , fe -> attrTime ) ) inode -> i_ctime = sbi -> s_record_time ; iinfo -> i_unique = le64_to_cpu ( fe -> uniqueID ) ; iinfo -> i_lenEAttr = le32_to_cpu ( fe -> lengthExtendedAttr ) ; iinfo -> i_lenAlloc = le32_to_cpu ( fe -> lengthAllocDescs ) ; iinfo -> i_checkpoint = le32_to_cpu ( fe -> checkpoint ) ; } else { inode -> i_blocks = le64_to_cpu ( efe -> logicalBlocksRecorded ) << ( inode -> i_sb -> s_blocksize_bits - 9 ) ; if ( ! udf_disk_stamp_to_time ( & inode -> i_atime , efe -> accessTime ) ) inode -> i_atime = sbi -> s_record_time ; if ( ! udf_disk_stamp_to_time ( & inode -> i_mtime , efe -> modificationTime ) ) inode -> i_mtime = sbi -> s_record_time ; if ( ! udf_disk_stamp_to_time ( & iinfo -> i_crtime , efe -> createTime ) ) iinfo -> i_crtime = sbi -> s_record_time ; if ( ! udf_disk_stamp_to_time ( & inode -> i_ctime , efe -> attrTime ) ) inode -> i_ctime = sbi -> s_record_time ; iinfo -> i_unique = le64_to_cpu ( efe -> uniqueID ) ; iinfo -> i_lenEAttr = le32_to_cpu ( efe -> lengthExtendedAttr ) ; iinfo -> i_lenAlloc = le32_to_cpu ( efe -> lengthAllocDescs ) ; iinfo -> i_checkpoint = le32_to_cpu ( efe -> checkpoint ) ; } inode -> i_generation = iinfo -> i_unique ; <S2SV_StartBug> if ( iinfo -> i_alloc_type == ICBTAG_FLAG_AD_IN_ICB ) { <S2SV_EndBug> if ( iinfo -> i_lenAlloc != inode -> i_size ) goto out ; if ( inode -> i_size > bs - udf_file_entry_alloc_offset ( inode ) ) goto out ; } switch ( fe -> icbTag . fileType ) { case ICBTAG_FILE_TYPE_DIRECTORY : inode -> i_op = & udf_dir_inode_operations ; inode -> i_fop = & udf_dir_operations ; inode -> i_mode |= S_IFDIR ; inc_nlink ( inode ) ; break ; case ICBTAG_FILE_TYPE_REALTIME : case ICBTAG_FILE_TYPE_REGULAR : case ICBTAG_FILE_TYPE_UNDEF : case ICBTAG_FILE_TYPE_VAT20 : if ( iinfo -> i_alloc_type == ICBTAG_FLAG_AD_IN_ICB ) inode -> i_data . a_ops = & udf_adinicb_aops ; else inode -> i_data . a_ops = & udf_aops ; inode -> i_op = & udf_file_inode_operations ; inode -> i_fop = & udf_file_operations ; inode -> i_mode |= S_IFREG ; break ; case ICBTAG_FILE_TYPE_BLOCK : inode -> i_mode |= S_IFBLK ; break ; case ICBTAG_FILE_TYPE_CHAR : inode -> i_mode |= S_IFCHR ; break ; case ICBTAG_FILE_TYPE_FIFO : init_special_inode ( inode , inode -> i_mode | S_IFIFO , 0 ) ; break ; case ICBTAG_FILE_TYPE_SOCKET : init_special_inode ( inode , inode -> i_mode | S_IFSOCK , 0 ) ; break ; case ICBTAG_FILE_TYPE_SYMLINK : inode -> i_data . a_ops = & udf_symlink_aops ; inode -> i_op = & udf_symlink_inode_operations ; inode -> i_mode = S_IFLNK | S_IRWXUGO ; break ; case ICBTAG_FILE_TYPE_MAIN : udf_debug ( ""METADATA<S2SV_blank>FILE-----\\n"" ) ; break ; case ICBTAG_FILE_TYPE_MIRROR : udf_debug ( ""METADATA<S2SV_blank>MIRROR<S2SV_blank>FILE-----\\n"" ) ; break ; case ICBTAG_FILE_TYPE_BITMAP : udf_debug ( ""METADATA<S2SV_blank>BITMAP<S2SV_blank>FILE-----\\n"" ) ; break ; default : udf_err ( inode -> i_sb , ""(ino<S2SV_blank>%ld)<S2SV_blank>failed<S2SV_blank>unknown<S2SV_blank>file<S2SV_blank>type=%d\\n"" , inode -> i_ino , fe -> icbTag . fileType ) ; goto out ; } if ( S_ISCHR ( inode -> i_mode ) || S_ISBLK ( inode -> i_mode ) ) { struct deviceSpec * dsea = ( struct deviceSpec * ) udf_get_extendedattr ( inode , 12 , 1 ) ; if ( dsea ) { init_special_inode ( inode , inode -> i_mode , MKDEV ( le32_to_cpu ( dsea -> majorDeviceIdent ) , le32_to_cpu ( dsea -> minorDeviceIdent ) ) ) ; } else goto out ; } ret = 0 ; out : brelse ( bh ) ; return ret ; }",( iinfo -> i_lenEAttr > bs || iinfo -> i_lenAlloc > bs ) goto out ; if ( udf_file_entry_alloc_offset ( inode ) + iinfo -> i_lenAlloc > bs ) goto out ; if ( iinfo ->
565,"static int bmpr_read_rle ( struct iwbmprcontext * rctx ) { int retval = 0 ; if ( ! ( rctx -> compression == IWBMP_BI_RLE8 && rctx -> bitcount == 8 ) && ! ( rctx -> compression == IWBMP_BI_RLE4 && rctx -> bitcount == 4 ) ) { iw_set_error ( rctx -> ctx , ""Compression<S2SV_blank>type<S2SV_blank>incompatible<S2SV_blank>with<S2SV_blank>image<S2SV_blank>type"" ) ; <S2SV_StartBug> } <S2SV_EndBug> if ( rctx -> topdown ) { <S2SV_StartBug> iw_set_error ( rctx -> ctx , ""Compression<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>with<S2SV_blank>top-down<S2SV_blank>images"" ) ; <S2SV_EndBug> } rctx -> img -> imgtype = IW_IMGTYPE_RGBA ; rctx -> img -> bit_depth = 8 ; rctx -> img -> bpr = iw_calc_bytesperrow ( rctx -> width , 32 ) ; rctx -> img -> pixels = ( iw_byte * ) iw_malloc_large ( rctx -> ctx , rctx -> img -> bpr , rctx -> img -> height ) ; if ( ! rctx -> img -> pixels ) goto done ; if ( ! bmpr_read_rle_internal ( rctx ) ) goto done ; if ( ! bmpr_has_transparency ( rctx -> img ) ) { bmpr_strip_alpha ( rctx -> img ) ; } retval = 1 ; done : return retval ; }","""Compression<S2SV_blank>type<S2SV_blank>incompatible<S2SV_blank>with<S2SV_blank>image<S2SV_blank>type"" ) ; goto done ; <S2SV_ModStart> , ""Compression<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>with<S2SV_blank>top-down<S2SV_blank>images"" ) ; goto done"
566,"void vp9_default_coef_probs ( VP9_COMMON * cm ) { <S2SV_StartBug> vp9_copy ( cm -> fc . coef_probs [ TX_4X4 ] , default_coef_probs_4x4 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_copy ( cm -> fc . coef_probs [ TX_8X8 ] , default_coef_probs_8x8 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_copy ( cm -> fc . coef_probs [ TX_16X16 ] , default_coef_probs_16x16 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_copy ( cm -> fc . coef_probs [ TX_32X32 ] , default_coef_probs_32x32 ) ; <S2SV_EndBug> }",cm -> fc -> <S2SV_ModEnd> coef_probs [ TX_4X4 <S2SV_ModStart> cm -> fc -> <S2SV_ModEnd> coef_probs [ TX_8X8 <S2SV_ModStart> cm -> fc -> <S2SV_ModEnd> coef_probs [ TX_16X16 <S2SV_ModStart> cm -> fc -> <S2SV_ModEnd> coef_probs [ TX_32X32
567,"int cib_remote_perform_op ( cib_t * cib , const char * op , const char * host , const char * section , xmlNode * data , xmlNode * * output_data , int call_options , const char * name ) { int rc = pcmk_ok ; <S2SV_StartBug> xmlNode * op_msg = NULL ; <S2SV_EndBug> xmlNode * op_reply = NULL ; cib_remote_opaque_t * private = cib -> variant_opaque ; <S2SV_StartBug> if ( sync_timer == NULL ) { <S2SV_EndBug> sync_timer = calloc ( 1 , sizeof ( struct timer_rec_s ) ) ; } if ( cib -> state == cib_disconnected ) { return - ENOTCONN ; } if ( output_data != NULL ) { * output_data = NULL ; } if ( op == NULL ) { crm_err ( ""No<S2SV_blank>operation<S2SV_blank>specified"" ) ; return - EINVAL ; } cib -> call_id ++ ; if ( cib -> call_id < 1 ) { cib -> call_id = 1 ; } op_msg = cib_create_op ( cib -> call_id , private -> callback . token , op , host , section , data , call_options , NULL ) ; if ( op_msg == NULL ) { return - EPROTO ; } crm_trace ( ""Sending<S2SV_blank>%s<S2SV_blank>message<S2SV_blank>to<S2SV_blank>CIB<S2SV_blank>service"" , op ) ; <S2SV_StartBug> crm_send_remote_msg ( private -> command . session , op_msg , private -> command . encrypted ) ; <S2SV_EndBug> free_xml ( op_msg ) ; if ( ( call_options & cib_discard_reply ) ) { crm_trace ( ""Discarding<S2SV_blank>reply"" ) ; return pcmk_ok ; } else if ( ! ( call_options & cib_sync_call ) ) { return cib -> call_id ; } crm_trace ( ""Waiting<S2SV_blank>for<S2SV_blank>a<S2SV_blank>syncronous<S2SV_blank>reply"" ) ; <S2SV_StartBug> if ( cib -> call_timeout > 0 ) { <S2SV_EndBug> timer_expired = FALSE ; sync_timer -> call_id = cib -> call_id ; sync_timer -> timeout = cib -> call_timeout * 1000 ; sync_timer -> ref = g_timeout_add ( sync_timer -> timeout , cib_timeout_handler , sync_timer ) ; } while ( timer_expired == FALSE ) { int reply_id = - 1 ; int msg_id = cib -> call_id ; <S2SV_StartBug> op_reply = crm_recv_remote_msg ( private -> command . session , private -> command . encrypted ) ; <S2SV_EndBug> if ( op_reply == NULL ) { break ; } <S2SV_StartBug> crm_element_value_int ( op_reply , F_CIB_CALLID , & reply_id ) ; <S2SV_EndBug> CRM_CHECK ( reply_id > 0 , free_xml ( op_reply ) ; if ( sync_timer -> ref > 0 ) { g_source_remove ( sync_timer -> ref ) ; sync_timer -> ref = 0 ; } return - ENOMSG ) ; if ( reply_id == msg_id ) { break ; } else if ( reply_id < msg_id ) { crm_debug ( ""Received<S2SV_blank>old<S2SV_blank>reply:<S2SV_blank>%d<S2SV_blank>(wanted<S2SV_blank>%d)"" , reply_id , msg_id ) ; crm_log_xml_trace ( op_reply , ""Old<S2SV_blank>reply"" ) ; } else if ( ( reply_id - 10000 ) > msg_id ) { crm_debug ( ""Received<S2SV_blank>old<S2SV_blank>reply:<S2SV_blank>%d<S2SV_blank>(wanted<S2SV_blank>%d)"" , reply_id , msg_id ) ; crm_log_xml_trace ( op_reply , ""Old<S2SV_blank>reply"" ) ; } else { crm_err ( ""Received<S2SV_blank>a<S2SV_blank>__future__<S2SV_blank>reply:"" ""<S2SV_blank>%d<S2SV_blank>(wanted<S2SV_blank>%d)"" , reply_id , msg_id ) ; } free_xml ( op_reply ) ; op_reply = NULL ; <S2SV_StartBug> } <S2SV_EndBug> if ( sync_timer -> ref > 0 ) { g_source_remove ( sync_timer -> ref ) ; sync_timer -> ref = 0 ; } if ( timer_expired ) { return - ETIME ; } if ( op_reply == NULL ) { crm_err ( ""No<S2SV_blank>reply<S2SV_blank>message<S2SV_blank>-<S2SV_blank>empty"" ) ; return - ENOMSG ; } crm_trace ( ""Syncronous<S2SV_blank>reply<S2SV_blank>received"" ) ; if ( crm_element_value_int ( op_reply , F_CIB_RC , & rc ) != 0 ) { rc = - EPROTO ; } if ( rc == - pcmk_err_diff_resync ) { rc = pcmk_ok ; } if ( rc == pcmk_ok || rc == - EPERM ) { crm_log_xml_debug ( op_reply , ""passed"" ) ; } else { crm_err ( ""Call<S2SV_blank>failed:<S2SV_blank>%s"" , pcmk_strerror ( rc ) ) ; crm_log_xml_warn ( op_reply , ""failed"" ) ; } if ( output_data == NULL ) { } else if ( ! ( call_options & cib_discard_reply ) ) { xmlNode * tmp = get_message_xml ( op_reply , F_CIB_CALLDATA ) ; if ( tmp == NULL ) { crm_trace ( ""No<S2SV_blank>output<S2SV_blank>in<S2SV_blank>reply<S2SV_blank>to<S2SV_blank>\\""%s\\""<S2SV_blank>command<S2SV_blank>%d"" , op , cib -> call_id - 1 ) ; } else { * output_data = copy_xml ( tmp ) ; } } free_xml ( op_reply ) ; return rc ; }","= pcmk_ok ; int disconnected = 0 ; int remaining_time = 0 ; time_t start_time ; <S2SV_ModStart> -> variant_opaque ; <S2SV_ModEnd> if ( cib <S2SV_ModStart> op ) ; if ( ! ( call_options & cib_sync_call ) ) { <S2SV_ModStart> ( private -> callback . session , op_msg , private -> command . encrypted ) ; } else { crm_send_remote_msg ( private -> command . <S2SV_ModEnd> session , op_msg <S2SV_ModStart> encrypted ) ; } <S2SV_ModStart> ""Waiting<S2SV_blank>for<S2SV_blank>a<S2SV_blank>syncronous<S2SV_blank>reply"" ) ; start_time = time ( NULL ) ; remaining_time = <S2SV_ModEnd> cib -> call_timeout <S2SV_ModStart> cib -> call_timeout ? cib -> call_timeout : 60 ; while ( remaining_time > 0 && ! disconnected <S2SV_ModEnd> ) { int <S2SV_ModStart> -> call_id ; <S2SV_ModEnd> crm_recv_remote_msg ( private <S2SV_ModStart> . session , & <S2SV_ModStart> -> command . recv_buf , private -> command . encrypted , remaining_time * 1000 , & disconnected ) ; op_reply = crm_parse_remote_buffer ( & private -> command . recv_buf ) ; if ( ! op_reply <S2SV_ModEnd> ) { break <S2SV_ModStart> , & reply_id <S2SV_ModEnd> ) ; if <S2SV_ModStart> = NULL ; remaining_time = time ( NULL ) - start_time ; } if ( disconnected ) { crm_err ( ""Disconnected<S2SV_blank>while<S2SV_blank>waiting<S2SV_blank>for<S2SV_blank>reply."" ) ; return - ENOTCONN ; } else <S2SV_ModEnd> if ( op_reply"
568,"static int llcp_sock_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { int noblock = flags & MSG_DONTWAIT ; struct sock * sk = sock -> sk ; unsigned int copied , rlen ; struct sk_buff * skb , * cskb ; int err = 0 ; <S2SV_StartBug> pr_debug ( ""%p<S2SV_blank>%zu\\n"" , sk , len ) ; <S2SV_EndBug> lock_sock ( sk ) ; if ( sk -> sk_state == LLCP_CLOSED && skb_queue_empty ( & sk -> sk_receive_queue ) ) { release_sock ( sk ) ; return 0 ; } release_sock ( sk ) ; if ( flags & ( MSG_OOB ) ) return - EOPNOTSUPP ; skb = skb_recv_datagram ( sk , flags , noblock , & err ) ; if ( ! skb ) { pr_err ( ""Recv<S2SV_blank>datagram<S2SV_blank>failed<S2SV_blank>state<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>%d"" , sk -> sk_state , err , sock_error ( sk ) ) ; if ( sk -> sk_shutdown & RCV_SHUTDOWN ) return 0 ; return err ; } rlen = skb -> len ; copied = min_t ( unsigned int , rlen , len ) ; cskb = skb ; if ( skb_copy_datagram_iovec ( cskb , 0 , msg -> msg_iov , copied ) ) { if ( ! ( flags & MSG_PEEK ) ) skb_queue_head ( & sk -> sk_receive_queue , skb ) ; return - EFAULT ; } sock_recv_timestamp ( msg , sk , skb ) ; if ( sk -> sk_type == SOCK_DGRAM && msg -> msg_name ) { struct nfc_llcp_ui_cb * ui_cb = nfc_llcp_ui_skb_cb ( skb ) ; struct sockaddr_nfc_llcp * sockaddr = ( struct sockaddr_nfc_llcp * ) msg -> msg_name ; msg -> msg_namelen = sizeof ( struct sockaddr_nfc_llcp ) ; pr_debug ( ""Datagram<S2SV_blank>socket<S2SV_blank>%d<S2SV_blank>%d\\n"" , ui_cb -> dsap , ui_cb -> ssap ) ; <S2SV_StartBug> sockaddr -> sa_family = AF_NFC ; <S2SV_EndBug> sockaddr -> nfc_protocol = NFC_PROTO_NFC_DEP ; sockaddr -> dsap = ui_cb -> dsap ; sockaddr -> ssap = ui_cb -> ssap ; } if ( ! ( flags & MSG_PEEK ) ) { if ( sk -> sk_type == SOCK_STREAM || sk -> sk_type == SOCK_DGRAM || sk -> sk_type == SOCK_RAW ) { skb_pull ( skb , copied ) ; if ( skb -> len ) { skb_queue_head ( & sk -> sk_receive_queue , skb ) ; goto done ; } } kfree_skb ( skb ) ; } done : if ( sk -> sk_type == SOCK_SEQPACKET && ( flags & MSG_TRUNC ) ) copied = rlen ; return copied ; }",", len ) ; msg -> msg_namelen = 0 <S2SV_ModStart> ssap ) ; memset ( sockaddr , 0 , sizeof ( * sockaddr ) ) ;"
569,"static int ghash_final ( struct shash_desc * desc , u8 * dst ) { struct ghash_desc_ctx * dctx = shash_desc_ctx ( desc ) ; struct ghash_ctx * ctx = crypto_shash_ctx ( desc -> tfm ) ; u8 * buf = dctx -> buffer ; <S2SV_StartBug> ghash_flush ( ctx , dctx ) ; <S2SV_EndBug> memcpy ( dst , buf , GHASH_BLOCK_SIZE ) ; return 0 ; }",-> buffer ; if ( ! ctx -> gf128 ) return - ENOKEY ;
570,"LPSTR tr_esc_str ( LPCSTR arg , bool format ) { <S2SV_StartBug> LPSTR tmp = NULL ; <S2SV_EndBug> size_t cs = 0 , x , ds , len ; size_t s ; if ( NULL == arg ) return NULL ; s = strlen ( arg ) ; while ( ( s > 0 ) && isspace ( arg [ s - 1 ] ) ) s -- ; ds = s + 1 ; if ( s ) <S2SV_StartBug> tmp = ( LPSTR ) realloc ( tmp , ds * sizeof ( CHAR ) ) ; <S2SV_EndBug> if ( NULL == tmp ) { fprintf ( stderr , ""Could<S2SV_blank>not<S2SV_blank>allocate<S2SV_blank>string<S2SV_blank>buffer.\\n"" ) ; exit ( - 2 ) ; } memset ( tmp , 0 , ds * sizeof ( CHAR ) ) ; for ( x = 0 ; x < s ; x ++ ) { switch ( arg [ x ] ) { case '<' : len = format ? 13 : 4 ; ds += len - 1 ; <S2SV_StartBug> tmp = ( LPSTR ) realloc ( tmp , ds * sizeof ( CHAR ) ) ; <S2SV_EndBug> if ( NULL == tmp ) { fprintf ( stderr , ""Could<S2SV_blank>not<S2SV_blank>reallocate<S2SV_blank>string<S2SV_blank>buffer.\\n"" ) ; exit ( - 3 ) ; } if ( format ) strncpy ( & tmp [ cs ] , ""<replaceable>"" , len ) ; else strncpy ( & tmp [ cs ] , ""&lt;"" , len ) ; cs += len ; break ; case '>' : len = format ? 14 : 4 ; ds += len - 1 ; <S2SV_StartBug> tmp = ( LPSTR ) realloc ( tmp , ds * sizeof ( CHAR ) ) ; <S2SV_EndBug> if ( NULL == tmp ) { fprintf ( stderr , ""Could<S2SV_blank>not<S2SV_blank>reallocate<S2SV_blank>string<S2SV_blank>buffer.\\n"" ) ; exit ( - 4 ) ; } if ( format ) strncpy ( & tmp [ cs ] , ""</replaceable>"" , len ) ; else strncpy ( & tmp [ cs ] , ""&lt;"" , len ) ; cs += len ; break ; case '\\'' : ds += 5 ; <S2SV_StartBug> tmp = ( LPSTR ) realloc ( tmp , ds * sizeof ( CHAR ) ) ; <S2SV_EndBug> if ( NULL == tmp ) { fprintf ( stderr , ""Could<S2SV_blank>not<S2SV_blank>reallocate<S2SV_blank>string<S2SV_blank>buffer.\\n"" ) ; exit ( - 5 ) ; } tmp [ cs ++ ] = '&' ; tmp [ cs ++ ] = 'a' ; tmp [ cs ++ ] = 'p' ; tmp [ cs ++ ] = 'o' ; tmp [ cs ++ ] = 's' ; tmp [ cs ++ ] = ';' ; break ; case \'""\' : ds += 5 ; <S2SV_StartBug> tmp = ( LPSTR ) realloc ( tmp , ds * sizeof ( CHAR ) ) ; <S2SV_EndBug> if ( NULL == tmp ) { fprintf ( stderr , ""Could<S2SV_blank>not<S2SV_blank>reallocate<S2SV_blank>string<S2SV_blank>buffer.\\n"" ) ; exit ( - 6 ) ; } tmp [ cs ++ ] = '&' ; tmp [ cs ++ ] = 'q' ; tmp [ cs ++ ] = 'u' ; tmp [ cs ++ ] = 'o' ; tmp [ cs ++ ] = 't' ; tmp [ cs ++ ] = ';' ; break ; case '&' : ds += 4 ; <S2SV_StartBug> tmp = ( LPSTR ) realloc ( tmp , ds * sizeof ( CHAR ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( NULL == tmp ) <S2SV_EndBug> { fprintf ( stderr , ""Could<S2SV_blank>not<S2SV_blank>reallocate<S2SV_blank>string<S2SV_blank>buffer.\\n"" ) ; exit ( - 7 ) ; } tmp [ cs ++ ] = '&' ; tmp [ cs ++ ] = 'a' ; tmp [ cs ++ ] = 'm' ; tmp [ cs ++ ] = 'p' ; tmp [ cs ++ ] = ';' ; break ; default : tmp [ cs ++ ] = arg [ x ] ; break ; } tmp [ ds - 1 ] = '\\0' ; } return tmp ; }",{ LPSTR tmp = NULL ; LPSTR tmp2 <S2SV_ModStart> ( s ) { tmp2 <S2SV_ModEnd> = ( LPSTR <S2SV_ModStart> ) ) ; if ( ! tmp2 ) free ( tmp ) ; tmp = tmp2 ; } <S2SV_ModStart> - 1 ; tmp2 <S2SV_ModEnd> = ( LPSTR <S2SV_ModStart> CHAR ) ) ; if ( ! tmp2 ) free ( tmp ) ; tmp = tmp2 <S2SV_ModStart> - 1 ; tmp2 <S2SV_ModEnd> = ( LPSTR <S2SV_ModStart> CHAR ) ) ; if ( ! tmp2 ) free ( tmp ) ; tmp = tmp2 <S2SV_ModStart> += 5 ; tmp2 <S2SV_ModEnd> = ( LPSTR <S2SV_ModStart> CHAR ) ) ; if ( ! tmp2 ) free ( tmp ) ; tmp = tmp2 <S2SV_ModStart> += 5 ; tmp2 <S2SV_ModEnd> = ( LPSTR <S2SV_ModStart> CHAR ) ) ; if ( ! tmp2 ) free ( tmp ) ; tmp = tmp2 <S2SV_ModStart> += 4 ; tmp2 <S2SV_ModEnd> = ( LPSTR <S2SV_ModStart> ; if ( ! tmp2 ) free ( tmp ) ; tmp = tmp2 ; if (
571,"static int choose_filters ( struct archive_read * a ) { <S2SV_StartBug> int number_bidders , i , bid , best_bid ; <S2SV_EndBug> struct archive_read_filter_bidder * bidder , * best_bidder ; struct archive_read_filter * filter ; ssize_t avail ; int r ; <S2SV_StartBug> for ( ; ; ) { <S2SV_EndBug> number_bidders = sizeof ( a -> bidders ) / sizeof ( a -> bidders [ 0 ] ) ; best_bid = 0 ; best_bidder = NULL ; bidder = a -> bidders ; for ( i = 0 ; i < number_bidders ; i ++ , bidder ++ ) { if ( bidder -> bid != NULL ) { bid = ( bidder -> bid ) ( bidder , a -> filter ) ; if ( bid > best_bid ) { best_bid = bid ; best_bidder = bidder ; } } } if ( best_bidder == NULL ) { __archive_read_filter_ahead ( a -> filter , 1 , & avail ) ; if ( avail < 0 ) { __archive_read_close_filters ( a ) ; __archive_read_free_filters ( a ) ; return ( ARCHIVE_FATAL ) ; } a -> archive . compression_name = a -> filter -> name ; a -> archive . compression_code = a -> filter -> code ; return ( ARCHIVE_OK ) ; } filter = ( struct archive_read_filter * ) calloc ( 1 , sizeof ( * filter ) ) ; if ( filter == NULL ) return ( ARCHIVE_FATAL ) ; filter -> bidder = best_bidder ; filter -> archive = a ; filter -> upstream = a -> filter ; a -> filter = filter ; r = ( best_bidder -> init ) ( a -> filter ) ; if ( r != ARCHIVE_OK ) { __archive_read_close_filters ( a ) ; __archive_read_free_filters ( a ) ; return ( ARCHIVE_FATAL ) ; } } <S2SV_StartBug> } <S2SV_EndBug>","bid , best_bid , n <S2SV_ModStart> ; for ( n = 0 ; n < 25 ; ++ n <S2SV_ModEnd> ) { number_bidders <S2SV_ModStart> ; } } archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , ""Input<S2SV_blank>requires<S2SV_blank>too<S2SV_blank>many<S2SV_blank>filters<S2SV_blank>for<S2SV_blank>decoding"" ) ; return ( ARCHIVE_FATAL ) ;"
572,"sds sdsMakeRoomFor ( sds s , size_t addlen ) { void * sh , * newsh ; size_t avail = sdsavail ( s ) ; size_t len , newlen ; char type , oldtype = s [ - 1 ] & SDS_TYPE_MASK ; int hdrlen ; if ( avail >= addlen ) return s ; len = sdslen ( s ) ; sh = ( char * ) s - sdsHdrSize ( oldtype ) ; newlen = ( len + addlen ) ; <S2SV_StartBug> if ( newlen < SDS_MAX_PREALLOC ) <S2SV_EndBug> newlen *= 2 ; else newlen += SDS_MAX_PREALLOC ; type = sdsReqType ( newlen ) ; if ( type == SDS_TYPE_5 ) type = SDS_TYPE_8 ; <S2SV_StartBug> hdrlen = sdsHdrSize ( type ) ; <S2SV_EndBug> if ( oldtype == type ) { newsh = s_realloc ( sh , hdrlen + newlen + 1 ) ; if ( newsh == NULL ) return NULL ; s = ( char * ) newsh + hdrlen ; } else { newsh = s_malloc ( hdrlen + newlen + 1 ) ; if ( newsh == NULL ) return NULL ; memcpy ( ( char * ) newsh + hdrlen , s , len + 1 ) ; s_free ( sh ) ; s = ( char * ) newsh + hdrlen ; s [ - 1 ] = type ; sdssetlen ( s , len ) ; } sdssetalloc ( s , newlen ) ; return s ; }",addlen ) ; assert ( newlen > len ) ; <S2SV_ModStart> sdsHdrSize ( type ) ; assert ( hdrlen + newlen + 1 > len
573,"static void icmp_reply ( struct icmp_bxm * icmp_param , struct sk_buff * skb ) { struct ipcm_cookie ipc ; struct rtable * rt = skb_rtable ( skb ) ; struct net * net = dev_net ( rt -> dst . dev ) ; struct sock * sk ; struct inet_sock * inet ; __be32 daddr ; <S2SV_StartBug> if ( ip_options_echo ( & icmp_param -> replyopts , skb ) ) <S2SV_EndBug> return ; sk = icmp_xmit_lock ( net ) ; if ( sk == NULL ) return ; inet = inet_sk ( sk ) ; icmp_param -> data . icmph . checksum = 0 ; inet -> tos = ip_hdr ( skb ) -> tos ; daddr = ipc . addr = rt -> rt_src ; ipc . opt = NULL ; ipc . tx_flags = 0 ; <S2SV_StartBug> if ( icmp_param -> replyopts . optlen ) { <S2SV_EndBug> <S2SV_StartBug> ipc . opt = & icmp_param -> replyopts ; <S2SV_EndBug> if ( ipc . opt -> srr ) <S2SV_StartBug> daddr = icmp_param -> replyopts . faddr ; <S2SV_EndBug> } { struct flowi4 fl4 = { . daddr = daddr , . saddr = rt -> rt_spec_dst , . flowi4_tos = RT_TOS ( ip_hdr ( skb ) -> tos ) , . flowi4_proto = IPPROTO_ICMP , } ; security_skb_classify_flow ( skb , flowi4_to_flowi ( & fl4 ) ) ; rt = ip_route_output_key ( net , & fl4 ) ; if ( IS_ERR ( rt ) ) goto out_unlock ; } if ( icmpv4_xrlim_allow ( net , rt , icmp_param -> data . icmph . type , icmp_param -> data . icmph . code ) ) icmp_push_reply ( icmp_param , & ipc , & rt ) ; ip_rt_put ( rt ) ; out_unlock : icmp_xmit_unlock ( sk ) ; }",icmp_param -> replyopts . opt . opt <S2SV_ModStart> -> replyopts . opt . opt . <S2SV_ModStart> icmp_param -> replyopts . opt ; if ( ipc . opt -> opt . <S2SV_ModEnd> srr ) daddr <S2SV_ModStart> icmp_param -> replyopts . opt . opt
574,"static Image * ReadBMPImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { BMPInfo bmp_info ; Image * image ; MagickBooleanType status ; MagickOffsetType offset , start_position ; MemoryInfo * pixel_info ; Quantum index ; register Quantum * q ; register ssize_t i , x ; register unsigned char * p ; size_t bit , bytes_per_line , length ; ssize_t count , y ; unsigned char magick [ 12 ] , * pixels ; unsigned int blue , green , offset_bits , red ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) memset ( & bmp_info , 0 , sizeof ( bmp_info ) ) ; bmp_info . ba_offset = 0 ; start_position = 0 ; offset_bits = 0 ; count = ReadBlob ( image , 2 , magick ) ; if ( count != 2 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; do { PixelInfo quantum_bits ; PixelPacket shift ; start_position = TellBlob ( image ) - 2 ; bmp_info . ba_offset = 0 ; while ( LocaleNCompare ( ( char * ) magick , ""BA"" , 2 ) == 0 ) { bmp_info . file_size = ReadBlobLSBLong ( image ) ; bmp_info . ba_offset = ReadBlobLSBLong ( image ) ; bmp_info . offset_bits = ReadBlobLSBLong ( image ) ; count = ReadBlob ( image , 2 , magick ) ; if ( count != 2 ) break ; } if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Magick:<S2SV_blank>%c%c"" , magick [ 0 ] , magick [ 1 ] ) ; if ( ( count != 2 ) || ( ( LocaleNCompare ( ( char * ) magick , ""BM"" , 2 ) != 0 ) && ( LocaleNCompare ( ( char * ) magick , ""CI"" , 2 ) != 0 ) ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; bmp_info . file_size = ReadBlobLSBLong ( image ) ; ( void ) ReadBlobLSBLong ( image ) ; bmp_info . offset_bits = ReadBlobLSBLong ( image ) ; bmp_info . size = ReadBlobLSBLong ( image ) ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>BMP<S2SV_blank>size:<S2SV_blank>%u"" , bmp_info . size ) ; if ( bmp_info . size == 12 ) { ( void ) CopyMagickString ( image -> magick , ""BMP2"" , MagickPathExtent ) ; bmp_info . width = ( ssize_t ) ( ( short ) ReadBlobLSBShort ( image ) ) ; bmp_info . height = ( ssize_t ) ( ( short ) ReadBlobLSBShort ( image ) ) ; bmp_info . planes = ReadBlobLSBShort ( image ) ; bmp_info . bits_per_pixel = ReadBlobLSBShort ( image ) ; bmp_info . x_pixels = 0 ; bmp_info . y_pixels = 0 ; bmp_info . number_colors = 0 ; bmp_info . compression = BI_RGB ; bmp_info . image_size = 0 ; bmp_info . alpha_mask = 0 ; if ( image -> debug != MagickFalse ) { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Format:<S2SV_blank>OS/2<S2SV_blank>Bitmap"" ) ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Geometry:<S2SV_blank>%.20gx%.20g"" , ( double ) bmp_info . width , ( double ) bmp_info . height ) ; } } else { if ( bmp_info . size < 40 ) ThrowReaderException ( CorruptImageError , ""NonOS2HeaderSizeError"" ) ; bmp_info . width = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; bmp_info . height = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; bmp_info . planes = ReadBlobLSBShort ( image ) ; bmp_info . bits_per_pixel = ReadBlobLSBShort ( image ) ; bmp_info . compression = ReadBlobLSBLong ( image ) ; bmp_info . image_size = ReadBlobLSBLong ( image ) ; bmp_info . x_pixels = ReadBlobLSBLong ( image ) ; bmp_info . y_pixels = ReadBlobLSBLong ( image ) ; bmp_info . number_colors = ReadBlobLSBLong ( image ) ; <S2SV_StartBug> if ( bmp_info . number_colors > GetBlobSize ( image ) ) <S2SV_EndBug> ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; bmp_info . colors_important = ReadBlobLSBLong ( image ) ; if ( image -> debug != MagickFalse ) { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Format:<S2SV_blank>MS<S2SV_blank>Windows<S2SV_blank>bitmap"" ) ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Geometry:<S2SV_blank>%.20gx%.20g"" , ( double ) bmp_info . width , ( double ) bmp_info . height ) ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Bits<S2SV_blank>per<S2SV_blank>pixel:<S2SV_blank>%.20g"" , ( double ) bmp_info . bits_per_pixel ) ; switch ( bmp_info . compression ) { case BI_RGB : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_RGB"" ) ; break ; } case BI_RLE4 : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_RLE4"" ) ; break ; } case BI_RLE8 : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_RLE8"" ) ; break ; } case BI_BITFIELDS : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_BITFIELDS"" ) ; break ; } case BI_PNG : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_PNG"" ) ; break ; } case BI_JPEG : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>BI_JPEG"" ) ; break ; } default : { ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Compression:<S2SV_blank>UNKNOWN<S2SV_blank>(%u)"" , bmp_info . compression ) ; } } ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Number<S2SV_blank>of<S2SV_blank>colors:<S2SV_blank>%u"" , bmp_info . number_colors ) ; } bmp_info . red_mask = ReadBlobLSBLong ( image ) ; bmp_info . green_mask = ReadBlobLSBLong ( image ) ; bmp_info . blue_mask = ReadBlobLSBLong ( image ) ; if ( bmp_info . size > 40 ) { double gamma ; bmp_info . alpha_mask = ReadBlobLSBLong ( image ) ; bmp_info . colorspace = ReadBlobLSBSignedLong ( image ) ; # define BMP_DENOM ( ( double ) 0x40000000 ) bmp_info . red_primary . x = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . red_primary . y = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . red_primary . z = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . green_primary . x = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . green_primary . y = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . green_primary . z = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . blue_primary . x = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . blue_primary . y = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; bmp_info . blue_primary . z = ( double ) ReadBlobLSBLong ( image ) / BMP_DENOM ; gamma = bmp_info . red_primary . x + bmp_info . red_primary . y + bmp_info . red_primary . z ; gamma = PerceptibleReciprocal ( gamma ) ; bmp_info . red_primary . x *= gamma ; bmp_info . red_primary . y *= gamma ; image -> chromaticity . red_primary . x = bmp_info . red_primary . x ; image -> chromaticity . red_primary . y = bmp_info . red_primary . y ; gamma = bmp_info . green_primary . x + bmp_info . green_primary . y + bmp_info . green_primary . z ; gamma = PerceptibleReciprocal ( gamma ) ; bmp_info . green_primary . x *= gamma ; bmp_info . green_primary . y *= gamma ; image -> chromaticity . green_primary . x = bmp_info . green_primary . x ; image -> chromaticity . green_primary . y = bmp_info . green_primary . y ; gamma = bmp_info . blue_primary . x + bmp_info . blue_primary . y + bmp_info . blue_primary . z ; gamma = PerceptibleReciprocal ( gamma ) ; bmp_info . blue_primary . x *= gamma ; bmp_info . blue_primary . y *= gamma ; image -> chromaticity . blue_primary . x = bmp_info . blue_primary . x ; image -> chromaticity . blue_primary . y = bmp_info . blue_primary . y ; bmp_info . gamma_scale . x = ( double ) ReadBlobLSBLong ( image ) / 0x10000 ; bmp_info . gamma_scale . y = ( double ) ReadBlobLSBLong ( image ) / 0x10000 ; bmp_info . gamma_scale . z = ( double ) ReadBlobLSBLong ( image ) / 0x10000 ; image -> gamma = ( bmp_info . gamma_scale . x + bmp_info . gamma_scale . y + bmp_info . gamma_scale . z ) / 3.0 ; } else ( void ) CopyMagickString ( image -> magick , ""BMP3"" , MagickPathExtent ) ; if ( bmp_info . size > 108 ) { size_t intent ; intent = ReadBlobLSBLong ( image ) ; switch ( ( int ) intent ) { case LCS_GM_BUSINESS : { image -> rendering_intent = SaturationIntent ; break ; } case LCS_GM_GRAPHICS : { image -> rendering_intent = RelativeIntent ; break ; } case LCS_GM_IMAGES : { image -> rendering_intent = PerceptualIntent ; break ; } case LCS_GM_ABS_COLORIMETRIC : { image -> rendering_intent = AbsoluteIntent ; break ; } } ( void ) ReadBlobLSBLong ( image ) ; ( void ) ReadBlobLSBLong ( image ) ; ( void ) ReadBlobLSBLong ( image ) ; } } if ( ( MagickSizeType ) bmp_info . file_size > GetBlobSize ( image ) ) ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , CorruptImageError , ""LengthAndFilesizeDoNotMatch"" , ""`%s\'"" , image -> filename ) ; else if ( ( MagickSizeType ) bmp_info . file_size < GetBlobSize ( image ) ) ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , CorruptImageWarning , ""LengthAndFilesizeDoNotMatch"" , ""`%s\'"" , image -> filename ) ; if ( bmp_info . width <= 0 ) ThrowReaderException ( CorruptImageError , ""NegativeOrZeroImageSize"" ) ; if ( bmp_info . height == 0 ) ThrowReaderException ( CorruptImageError , ""NegativeOrZeroImageSize"" ) ; if ( bmp_info . planes != 1 ) ThrowReaderException ( CorruptImageError , ""StaticPlanesValueNotEqualToOne"" ) ; if ( ( bmp_info . bits_per_pixel != 1 ) && ( bmp_info . bits_per_pixel != 4 ) && ( bmp_info . bits_per_pixel != 8 ) && ( bmp_info . bits_per_pixel != 16 ) && ( bmp_info . bits_per_pixel != 24 ) && ( bmp_info . bits_per_pixel != 32 ) ) ThrowReaderException ( CorruptImageError , ""UnrecognizedBitsPerPixel"" ) ; if ( bmp_info . bits_per_pixel < 16 && bmp_info . number_colors > ( 1U << bmp_info . bits_per_pixel ) ) ThrowReaderException ( CorruptImageError , ""UnrecognizedNumberOfColors"" ) ; if ( ( bmp_info . compression == 1 ) && ( bmp_info . bits_per_pixel != 8 ) ) ThrowReaderException ( CorruptImageError , ""UnrecognizedBitsPerPixel"" ) ; if ( ( bmp_info . compression == 2 ) && ( bmp_info . bits_per_pixel != 4 ) ) ThrowReaderException ( CorruptImageError , ""UnrecognizedBitsPerPixel"" ) ; if ( ( bmp_info . compression == 3 ) && ( bmp_info . bits_per_pixel < 16 ) ) ThrowReaderException ( CorruptImageError , ""UnrecognizedBitsPerPixel"" ) ; switch ( bmp_info . compression ) { case BI_RGB : image -> compression = NoCompression ; break ; case BI_RLE8 : case BI_RLE4 : image -> compression = RLECompression ; break ; case BI_BITFIELDS : break ; case BI_JPEG : ThrowReaderException ( CoderError , ""JPEGCompressNotSupported"" ) ; case BI_PNG : ThrowReaderException ( CoderError , ""PNGCompressNotSupported"" ) ; default : ThrowReaderException ( CorruptImageError , ""UnrecognizedImageCompression"" ) ; } image -> columns = ( size_t ) MagickAbsoluteValue ( bmp_info . width ) ; image -> rows = ( size_t ) MagickAbsoluteValue ( bmp_info . height ) ; image -> depth = bmp_info . bits_per_pixel <= 8 ? bmp_info . bits_per_pixel : 8 ; image -> alpha_trait = ( ( bmp_info . alpha_mask != 0 ) && ( bmp_info . compression == BI_BITFIELDS ) ) ? BlendPixelTrait : UndefinedPixelTrait ; if ( bmp_info . bits_per_pixel < 16 ) { size_t one ; image -> storage_class = PseudoClass ; image -> colors = bmp_info . number_colors ; one = 1 ; if ( image -> colors == 0 ) image -> colors = one << bmp_info . bits_per_pixel ; } image -> resolution . x = ( double ) bmp_info . x_pixels / 100.0 ; image -> resolution . y = ( double ) bmp_info . y_pixels / 100.0 ; image -> units = PixelsPerCentimeterResolution ; if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; if ( image -> storage_class == PseudoClass ) { unsigned char * bmp_colormap ; size_t packet_size ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Reading<S2SV_blank>colormap<S2SV_blank>of<S2SV_blank>%.20g<S2SV_blank>colors"" , ( double ) image -> colors ) ; if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; bmp_colormap = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) image -> colors , 4 * sizeof ( * bmp_colormap ) ) ; if ( bmp_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; if ( ( bmp_info . size == 12 ) || ( bmp_info . size == 64 ) ) packet_size = 3 ; else packet_size = 4 ; offset = SeekBlob ( image , start_position + 14 + bmp_info . size , SEEK_SET ) ; if ( offset < 0 ) { bmp_colormap = ( unsigned char * ) RelinquishMagickMemory ( bmp_colormap ) ; ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } count = ReadBlob ( image , packet_size * image -> colors , bmp_colormap ) ; if ( count != ( ssize_t ) ( packet_size * image -> colors ) ) { bmp_colormap = ( unsigned char * ) RelinquishMagickMemory ( bmp_colormap ) ; ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; } p = bmp_colormap ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . blue = ( MagickRealType ) ScaleCharToQuantum ( * p ++ ) ; image -> colormap [ i ] . green = ( MagickRealType ) ScaleCharToQuantum ( * p ++ ) ; image -> colormap [ i ] . red = ( MagickRealType ) ScaleCharToQuantum ( * p ++ ) ; if ( packet_size == 4 ) p ++ ; } bmp_colormap = ( unsigned char * ) RelinquishMagickMemory ( bmp_colormap ) ; } if ( bmp_info . offset_bits == offset_bits ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; offset_bits = bmp_info . offset_bits ; offset = SeekBlob ( image , start_position + bmp_info . offset_bits , SEEK_SET ) ; if ( offset < 0 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( bmp_info . compression == BI_RLE4 ) bmp_info . bits_per_pixel <<= 1 ; bytes_per_line = 4 * ( ( image -> columns * bmp_info . bits_per_pixel + 31 ) / 32 ) ; length = ( size_t ) bytes_per_line * image -> rows ; if ( ( bmp_info . compression == BI_RGB ) || ( bmp_info . compression == BI_BITFIELDS ) ) { if ( ( MagickSizeType ) length > GetBlobSize ( image ) ) ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; pixel_info = AcquireVirtualMemory ( image -> rows , MagickMax ( bytes_per_line , image -> columns + 256UL ) * sizeof ( * pixels ) ) ; if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Reading<S2SV_blank>pixels<S2SV_blank>(%.20g<S2SV_blank>bytes)"" , ( double ) length ) ; count = ReadBlob ( image , length , pixels ) ; if ( count != ( ssize_t ) length ) { pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; } } else { pixel_info = AcquireVirtualMemory ( image -> rows , MagickMax ( bytes_per_line , image -> columns + 256UL ) * sizeof ( * pixels ) ) ; if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ; status = DecodeImage ( image , bmp_info . compression , pixels , image -> columns * image -> rows ) ; if ( status == MagickFalse ) { pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnableToRunlengthDecodeImage"" ) ; } } if ( bmp_info . compression == BI_RGB ) { if ( ( image -> alpha_trait == UndefinedPixelTrait ) && ( bmp_info . size == 40 ) && ( bmp_info . bits_per_pixel == 32 ) ) { bytes_per_line = 4 * ( image -> columns ) ; for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( * ( p + 3 ) != 0 ) { image -> alpha_trait = BlendPixelTrait ; y = - 1 ; break ; } p += 4 ; } } } bmp_info . alpha_mask = image -> alpha_trait != UndefinedPixelTrait ? 0xff000000U : 0U ; bmp_info . red_mask = 0x00ff0000U ; bmp_info . green_mask = 0x0000ff00U ; bmp_info . blue_mask = 0x000000ffU ; if ( bmp_info . bits_per_pixel == 16 ) { bmp_info . red_mask = 0x00007c00U ; bmp_info . green_mask = 0x000003e0U ; bmp_info . blue_mask = 0x0000001fU ; } } ( void ) memset ( & shift , 0 , sizeof ( shift ) ) ; ( void ) memset ( & quantum_bits , 0 , sizeof ( quantum_bits ) ) ; if ( ( bmp_info . bits_per_pixel == 16 ) || ( bmp_info . bits_per_pixel == 32 ) ) { register unsigned int sample ; if ( bmp_info . red_mask != 0 ) while ( ( ( bmp_info . red_mask << shift . red ) & 0x80000000UL ) == 0 ) { shift . red ++ ; if ( shift . red >= 32U ) break ; } if ( bmp_info . green_mask != 0 ) while ( ( ( bmp_info . green_mask << shift . green ) & 0x80000000UL ) == 0 ) { shift . green ++ ; if ( shift . green >= 32U ) break ; } if ( bmp_info . blue_mask != 0 ) while ( ( ( bmp_info . blue_mask << shift . blue ) & 0x80000000UL ) == 0 ) { shift . blue ++ ; if ( shift . blue >= 32U ) break ; } if ( bmp_info . alpha_mask != 0 ) while ( ( ( bmp_info . alpha_mask << shift . alpha ) & 0x80000000UL ) == 0 ) { shift . alpha ++ ; if ( shift . alpha >= 32U ) break ; } sample = shift . red ; while ( ( ( bmp_info . red_mask << sample ) & 0x80000000UL ) != 0 ) { sample ++ ; if ( sample >= 32U ) break ; } quantum_bits . red = ( MagickRealType ) ( sample - shift . red ) ; sample = shift . green ; while ( ( ( bmp_info . green_mask << sample ) & 0x80000000UL ) != 0 ) { sample ++ ; if ( sample >= 32U ) break ; } quantum_bits . green = ( MagickRealType ) ( sample - shift . green ) ; sample = shift . blue ; while ( ( ( bmp_info . blue_mask << sample ) & 0x80000000UL ) != 0 ) { sample ++ ; if ( sample >= 32U ) break ; } quantum_bits . blue = ( MagickRealType ) ( sample - shift . blue ) ; sample = shift . alpha ; while ( ( ( bmp_info . alpha_mask << sample ) & 0x80000000UL ) != 0 ) { sample ++ ; if ( sample >= 32U ) break ; } quantum_bits . alpha = ( MagickRealType ) ( sample - shift . alpha ) ; } switch ( bmp_info . bits_per_pixel ) { case 1 : { for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 7 ) ; x += 8 ) { for ( bit = 0 ; bit < 8 ; bit ++ ) { index = ( Quantum ) ( ( ( * p ) & ( 0x80 >> bit ) ) != 0 ? 0x01 : 0x00 ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( ( image -> columns % 8 ) != 0 ) { for ( bit = 0 ; bit < ( image -> columns % 8 ) ; bit ++ ) { index = ( Quantum ) ( ( ( * p ) & ( 0x80 >> bit ) ) != 0 ? 0x01 : 0x00 ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image , exception ) ; break ; } case 4 : { for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 1 ) ; x += 2 ) { ValidateColormapValue ( image , ( ssize_t ) ( ( * p >> 4 ) & 0x0f ) , & index , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; ValidateColormapValue ( image , ( ssize_t ) ( * p & 0x0f ) , & index , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; p ++ ; } if ( ( image -> columns % 2 ) != 0 ) { ValidateColormapValue ( image , ( ssize_t ) ( ( * p >> 4 ) & 0xf ) , & index , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; p ++ ; x ++ ; } if ( x < ( ssize_t ) image -> columns ) break ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image , exception ) ; break ; } case 8 : { if ( ( bmp_info . compression == BI_RLE8 ) || ( bmp_info . compression == BI_RLE4 ) ) bytes_per_line = image -> columns ; for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = ( ssize_t ) image -> columns ; x != 0 ; -- x ) { ValidateColormapValue ( image , ( ssize_t ) * p ++ , & index , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; offset = ( MagickOffsetType ) ( image -> rows - y - 1 ) ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image , exception ) ; break ; } case 16 : { unsigned int alpha , pixel ; if ( ( bmp_info . compression != BI_RGB ) && ( bmp_info . compression != BI_BITFIELDS ) ) { pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnrecognizedImageCompression"" ) ; } bytes_per_line = 2 * ( image -> columns + image -> columns % 2 ) ; image -> storage_class = DirectClass ; for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { pixel = ( unsigned int ) ( * p ++ ) ; pixel |= ( * p ++ ) << 8 ; red = ( ( pixel & bmp_info . red_mask ) << shift . red ) >> 16 ; if ( quantum_bits . red == 5 ) red |= ( ( red & 0xe000 ) >> 5 ) ; if ( quantum_bits . red <= 8 ) red |= ( ( red & 0xff00 ) >> 8 ) ; green = ( ( pixel & bmp_info . green_mask ) << shift . green ) >> 16 ; if ( quantum_bits . green == 5 ) green |= ( ( green & 0xe000 ) >> 5 ) ; if ( quantum_bits . green == 6 ) green |= ( ( green & 0xc000 ) >> 6 ) ; if ( quantum_bits . green <= 8 ) green |= ( ( green & 0xff00 ) >> 8 ) ; blue = ( ( pixel & bmp_info . blue_mask ) << shift . blue ) >> 16 ; if ( quantum_bits . blue == 5 ) blue |= ( ( blue & 0xe000 ) >> 5 ) ; if ( quantum_bits . blue <= 8 ) blue |= ( ( blue & 0xff00 ) >> 8 ) ; SetPixelRed ( image , ScaleShortToQuantum ( ( unsigned short ) red ) , q ) ; SetPixelGreen ( image , ScaleShortToQuantum ( ( unsigned short ) green ) , q ) ; SetPixelBlue ( image , ScaleShortToQuantum ( ( unsigned short ) blue ) , q ) ; SetPixelAlpha ( image , OpaqueAlpha , q ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) { alpha = ( ( pixel & bmp_info . alpha_mask ) << shift . alpha ) >> 16 ; if ( quantum_bits . alpha <= 8 ) alpha |= ( ( alpha & 0xff00 ) >> 8 ) ; SetPixelAlpha ( image , ScaleShortToQuantum ( ( unsigned short ) alpha ) , q ) ; } q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; offset = ( MagickOffsetType ) ( image -> rows - y - 1 ) ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ; if ( status == MagickFalse ) break ; } } break ; } case 24 : { bytes_per_line = 4 * ( ( image -> columns * 24 + 31 ) / 32 ) ; for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelAlpha ( image , OpaqueAlpha , q ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; offset = ( MagickOffsetType ) ( image -> rows - y - 1 ) ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ; if ( status == MagickFalse ) break ; } } break ; } case 32 : { if ( ( bmp_info . compression != BI_RGB ) && ( bmp_info . compression != BI_BITFIELDS ) ) { pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""UnrecognizedImageCompression"" ) ; } bytes_per_line = 4 * ( image -> columns ) ; for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { unsigned int alpha , pixel ; p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { pixel = ( unsigned int ) ( * p ++ ) ; pixel |= ( ( unsigned int ) * p ++ << 8 ) ; pixel |= ( ( unsigned int ) * p ++ << 16 ) ; pixel |= ( ( unsigned int ) * p ++ << 24 ) ; red = ( ( pixel & bmp_info . red_mask ) << shift . red ) >> 16 ; if ( quantum_bits . red == 8 ) red |= ( red >> 8 ) ; green = ( ( pixel & bmp_info . green_mask ) << shift . green ) >> 16 ; if ( quantum_bits . green == 8 ) green |= ( green >> 8 ) ; blue = ( ( pixel & bmp_info . blue_mask ) << shift . blue ) >> 16 ; if ( quantum_bits . blue == 8 ) blue |= ( blue >> 8 ) ; SetPixelRed ( image , ScaleShortToQuantum ( ( unsigned short ) red ) , q ) ; SetPixelGreen ( image , ScaleShortToQuantum ( ( unsigned short ) green ) , q ) ; SetPixelBlue ( image , ScaleShortToQuantum ( ( unsigned short ) blue ) , q ) ; SetPixelAlpha ( image , OpaqueAlpha , q ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) { alpha = ( ( pixel & bmp_info . alpha_mask ) << shift . alpha ) >> 16 ; if ( quantum_bits . alpha == 8 ) alpha |= ( alpha >> 8 ) ; SetPixelAlpha ( image , ScaleShortToQuantum ( ( unsigned short ) alpha ) , q ) ; } q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; offset = ( MagickOffsetType ) ( image -> rows - y - 1 ) ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) ( image -> rows - y ) , image -> rows ) ; if ( status == MagickFalse ) break ; } } break ; } default : { pixel_info = RelinquishVirtualMemory ( pixel_info ) ; ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } } pixel_info = RelinquishVirtualMemory ( pixel_info ) ; if ( y > 0 ) break ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( bmp_info . height < 0 ) { Image * flipped_image ; flipped_image = FlipImage ( image , exception ) ; if ( flipped_image != ( Image * ) NULL ) { DuplicateBlob ( flipped_image , image ) ; ReplaceImageInList ( & image , flipped_image ) ; image = flipped_image ; } } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; <S2SV_StartBug> * magick = '\\0' ; <S2SV_EndBug> <S2SV_StartBug> if ( bmp_info . ba_offset != 0 ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> offset = SeekBlob ( image , ( MagickOffsetType ) bmp_info . ba_offset , SEEK_SET ) ; <S2SV_StartBug> if ( offset < 0 ) <S2SV_EndBug> ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; <S2SV_StartBug> } <S2SV_EndBug> count = ReadBlob ( image , 2 , magick ) ; if ( ( count == 2 ) && ( IsBMP ( magick , 2 ) != MagickFalse ) ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { status = MagickFalse ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( IsBMP ( magick , 2 ) != MagickFalse ) ; ( void ) CloseBlob ( image ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; return ( GetFirstImageInList ( image ) ) ; }","; if ( ( MagickSizeType ) <S2SV_ModStart> ) break ; offset = ( MagickOffsetType ) <S2SV_ModEnd> bmp_info . ba_offset <S2SV_ModStart> bmp_info . ba_offset ; if ( offset <S2SV_ModStart> != 0 ) if ( <S2SV_ModEnd> ( offset < <S2SV_ModStart> ( offset < TellBlob ( image ) ) || ( SeekBlob ( image , offset , SEEK_SET ) != offset ) <S2SV_ModEnd> ) ThrowReaderException ( <S2SV_ModStart> ""ImproperImageHeader"" ) ; * magick = '\\0' ; <S2SV_ModEnd> count = ReadBlob"
575,"void rpki_rtr_print ( netdissect_options * ndo , register const u_char * pptr , register u_int len ) { <S2SV_StartBug> u_int tlen , pdu_type , pdu_len ; <S2SV_EndBug> const u_char * tptr ; const rpki_rtr_pdu * pdu_header ; tptr = pptr ; tlen = len ; if ( ! ndo -> ndo_vflag ) { ND_PRINT ( ( ndo , "",<S2SV_blank>RPKI-RTR"" ) ) ; return ; } <S2SV_StartBug> while ( tlen >= sizeof ( rpki_rtr_pdu ) ) { <S2SV_EndBug> ND_TCHECK2 ( * tptr , sizeof ( rpki_rtr_pdu ) ) ; pdu_header = ( const rpki_rtr_pdu * ) tptr ; pdu_type = pdu_header -> pdu_type ; pdu_len = EXTRACT_32BITS ( pdu_header -> length ) ; ND_TCHECK2 ( * tptr , pdu_len ) ; if ( ! pdu_type || ! pdu_len ) { break ; } if ( tlen < pdu_len ) { goto trunc ; } <S2SV_StartBug> if ( rpki_rtr_pdu_print ( ndo , tptr , 8 ) ) <S2SV_EndBug> goto trunc ; tlen -= pdu_len ; <S2SV_StartBug> tptr += pdu_len ; <S2SV_EndBug> } <S2SV_StartBug> return ; <S2SV_EndBug> trunc : ND_PRINT ( ( ndo , ""\\n\\t%s"" , tstr ) ) ; }","len ) { <S2SV_ModEnd> if ( ! <S2SV_ModStart> } while ( len ) { u_int pdu_len = <S2SV_ModEnd> rpki_rtr_pdu_print ( ndo <S2SV_ModStart> ( ndo , pptr , len , 1 <S2SV_ModEnd> , 8 ) <S2SV_ModStart> , 8 ) ; len <S2SV_ModEnd> -= pdu_len ; <S2SV_ModStart> -= pdu_len ; pptr <S2SV_ModEnd> += pdu_len ; <S2SV_ModStart> pdu_len ; } <S2SV_ModEnd> } <S2SV_null> <S2SV_null>"
576,"static int isis_print_is_reach_subtlv ( netdissect_options * ndo , const uint8_t * tptr , u_int subt , u_int subl , const char * ident ) { u_int te_class , priority_level , gmpls_switch_cap ; union { float f ; uint32_t i ; } bw ; ND_PRINT ( ( ndo , ""%s%s<S2SV_blank>subTLV<S2SV_blank>#%u,<S2SV_blank>length:<S2SV_blank>%u"" , ident , tok2str ( isis_ext_is_reach_subtlv_values , ""unknown"" , subt ) , subt , subl ) ) ; ND_TCHECK2 ( * tptr , subl ) ; switch ( subt ) { case ISIS_SUBTLV_EXT_IS_REACH_ADMIN_GROUP : case ISIS_SUBTLV_EXT_IS_REACH_LINK_LOCAL_REMOTE_ID : case ISIS_SUBTLV_EXT_IS_REACH_LINK_REMOTE_ID : if ( subl >= 4 ) { ND_PRINT ( ( ndo , "",<S2SV_blank>0x%08x"" , EXTRACT_32BITS ( tptr ) ) ) ; if ( subl == 8 ) ND_PRINT ( ( ndo , "",<S2SV_blank>0x%08x"" , EXTRACT_32BITS ( tptr + 4 ) ) ) ; } break ; case ISIS_SUBTLV_EXT_IS_REACH_IPV4_INTF_ADDR : case ISIS_SUBTLV_EXT_IS_REACH_IPV4_NEIGHBOR_ADDR : if ( subl >= sizeof ( struct in_addr ) ) ND_PRINT ( ( ndo , "",<S2SV_blank>%s"" , ipaddr_string ( ndo , tptr ) ) ) ; break ; case ISIS_SUBTLV_EXT_IS_REACH_MAX_LINK_BW : case ISIS_SUBTLV_EXT_IS_REACH_RESERVABLE_BW : if ( subl >= 4 ) { bw . i = EXTRACT_32BITS ( tptr ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>%.3f<S2SV_blank>Mbps"" , bw . f * 8 / 1000000 ) ) ; } break ; case ISIS_SUBTLV_EXT_IS_REACH_UNRESERVED_BW : if ( subl >= 32 ) { for ( te_class = 0 ; te_class < 8 ; te_class ++ ) { bw . i = EXTRACT_32BITS ( tptr ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>TE-Class<S2SV_blank>%u:<S2SV_blank>%.3f<S2SV_blank>Mbps"" , ident , te_class , bw . f * 8 / 1000000 ) ) ; tptr += 4 ; } } break ; case ISIS_SUBTLV_EXT_IS_REACH_BW_CONSTRAINTS : case ISIS_SUBTLV_EXT_IS_REACH_BW_CONSTRAINTS_OLD : <S2SV_StartBug> ND_PRINT ( ( ndo , ""%sBandwidth<S2SV_blank>Constraints<S2SV_blank>Model<S2SV_blank>ID:<S2SV_blank>%s<S2SV_blank>(%u)"" , <S2SV_EndBug> ident , tok2str ( diffserv_te_bc_values , ""unknown"" , * tptr ) , * tptr ) ) ; tptr ++ ; for ( te_class = 0 ; te_class < ( subl - 1 ) / 4 ; te_class ++ ) { <S2SV_StartBug> ND_TCHECK2 ( * tptr , 4 ) ; <S2SV_EndBug> bw . i = EXTRACT_32BITS ( tptr ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Bandwidth<S2SV_blank>constraint<S2SV_blank>CT%u:<S2SV_blank>%.3f<S2SV_blank>Mbps"" , ident , te_class , bw . f * 8 / 1000000 ) ) ; tptr += 4 ; } break ; case ISIS_SUBTLV_EXT_IS_REACH_TE_METRIC : if ( subl >= 3 ) ND_PRINT ( ( ndo , "",<S2SV_blank>%u"" , EXTRACT_24BITS ( tptr ) ) ) ; break ; case ISIS_SUBTLV_EXT_IS_REACH_LINK_ATTRIBUTE : if ( subl == 2 ) { ND_PRINT ( ( ndo , "",<S2SV_blank>[<S2SV_blank>%s<S2SV_blank>]<S2SV_blank>(0x%04x)"" , bittok2str ( isis_subtlv_link_attribute_values , ""Unknown"" , EXTRACT_16BITS ( tptr ) ) , EXTRACT_16BITS ( tptr ) ) ) ; } break ; case ISIS_SUBTLV_EXT_IS_REACH_LINK_PROTECTION_TYPE : if ( subl >= 2 ) { ND_PRINT ( ( ndo , "",<S2SV_blank>%s,<S2SV_blank>Priority<S2SV_blank>%u"" , bittok2str ( gmpls_link_prot_values , ""none"" , * tptr ) , * ( tptr + 1 ) ) ) ; } break ; case ISIS_SUBTLV_SPB_METRIC : if ( subl >= 6 ) { ND_PRINT ( ( ndo , "",<S2SV_blank>LM:<S2SV_blank>%u"" , EXTRACT_24BITS ( tptr ) ) ) ; tptr = tptr + 3 ; ND_PRINT ( ( ndo , "",<S2SV_blank>P:<S2SV_blank>%u"" , * ( tptr ) ) ) ; tptr ++ ; ND_PRINT ( ( ndo , "",<S2SV_blank>P-ID:<S2SV_blank>%u"" , EXTRACT_16BITS ( tptr ) ) ) ; } break ; case ISIS_SUBTLV_EXT_IS_REACH_INTF_SW_CAP_DESCR : if ( subl >= 36 ) { gmpls_switch_cap = * tptr ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Interface<S2SV_blank>Switching<S2SV_blank>Capability:%s"" , ident , tok2str ( gmpls_switch_cap_values , ""Unknown"" , gmpls_switch_cap ) ) ) ; ND_PRINT ( ( ndo , "",<S2SV_blank>LSP<S2SV_blank>Encoding:<S2SV_blank>%s"" , tok2str ( gmpls_encoding_values , ""Unknown"" , * ( tptr + 1 ) ) ) ) ; tptr += 4 ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Max<S2SV_blank>LSP<S2SV_blank>Bandwidth:"" , ident ) ) ; for ( priority_level = 0 ; priority_level < 8 ; priority_level ++ ) { bw . i = EXTRACT_32BITS ( tptr ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>priority<S2SV_blank>level<S2SV_blank>%d:<S2SV_blank>%.3f<S2SV_blank>Mbps"" , ident , priority_level , bw . f * 8 / 1000000 ) ) ; tptr += 4 ; } subl -= 36 ; switch ( gmpls_switch_cap ) { case GMPLS_PSC1 : case GMPLS_PSC2 : case GMPLS_PSC3 : case GMPLS_PSC4 : ND_TCHECK2 ( * tptr , 6 ) ; bw . i = EXTRACT_32BITS ( tptr ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Min<S2SV_blank>LSP<S2SV_blank>Bandwidth:<S2SV_blank>%.3f<S2SV_blank>Mbps"" , ident , bw . f * 8 / 1000000 ) ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Interface<S2SV_blank>MTU:<S2SV_blank>%u"" , ident , EXTRACT_16BITS ( tptr + 4 ) ) ) ; break ; case GMPLS_TSC : ND_TCHECK2 ( * tptr , 8 ) ; bw . i = EXTRACT_32BITS ( tptr ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Min<S2SV_blank>LSP<S2SV_blank>Bandwidth:<S2SV_blank>%.3f<S2SV_blank>Mbps"" , ident , bw . f * 8 / 1000000 ) ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank><S2SV_blank>Indication<S2SV_blank>%s"" , ident , tok2str ( gmpls_switch_cap_tsc_indication_values , ""Unknown<S2SV_blank>(%u)"" , * ( tptr + 4 ) ) ) ) ; break ; default : if ( subl > 0 ) { if ( ! print_unknown_data ( ndo , tptr , ""\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , subl ) ) return ( 0 ) ; } } } break ; default : if ( ! print_unknown_data ( ndo , tptr , ""\\n\\t\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , subl ) ) return ( 0 ) ; break ; } return ( 1 ) ; trunc : return ( 0 ) ; }",case ISIS_SUBTLV_EXT_IS_REACH_BW_CONSTRAINTS_OLD : if ( subl == 0 ) break ; <S2SV_ModStart> ++ ) { <S2SV_ModEnd> bw . i
577,static void settings_init ( void ) { settings . use_cas = true ; settings . access = 0700 ; settings . port = 11211 ; <S2SV_StartBug> settings . udpport = 11211 ; <S2SV_EndBug> settings . inter = NULL ; settings . maxbytes = 64 * 1024 * 1024 ; settings . maxconns = 1024 ; settings . verbose = 0 ; settings . oldest_live = 0 ; settings . oldest_cas = 0 ; settings . evict_to_free = 1 ; settings . socketpath = NULL ; settings . factor = 1.25 ; settings . chunk_size = 48 ; settings . num_threads = 4 ; settings . num_threads_per_udp = 0 ; settings . prefix_delimiter = ':' ; settings . detail_enabled = 0 ; settings . reqs_per_event = 20 ; settings . backlog = 1024 ; settings . binding_protocol = negotiating_prot ; settings . item_size_max = 1024 * 1024 ; settings . slab_page_size = 1024 * 1024 ; settings . slab_chunk_size_max = settings . slab_page_size / 2 ; settings . sasl = false ; settings . maxconns_fast = true ; settings . lru_crawler = false ; settings . lru_crawler_sleep = 100 ; settings . lru_crawler_tocrawl = 0 ; settings . lru_maintainer_thread = false ; settings . lru_segmented = true ; settings . hot_lru_pct = 20 ; settings . warm_lru_pct = 40 ; settings . hot_max_factor = 0.2 ; settings . warm_max_factor = 2.0 ; settings . inline_ascii_response = false ; settings . temp_lru = false ; settings . temporary_ttl = 61 ; settings . idle_timeout = 0 ; settings . hashpower_init = 0 ; settings . slab_reassign = true ; settings . slab_automove = 1 ; settings . slab_automove_ratio = 0.8 ; settings . slab_automove_window = 30 ; settings . shutdown_command = false ; settings . tail_repair_time = TAIL_REPAIR_TIME_DEFAULT ; settings . flush_enabled = true ; settings . dump_enabled = true ; settings . crawls_persleep = 1000 ; settings . logger_watcher_buf_size = LOGGER_WATCHER_BUF_SIZE ; settings . logger_buf_size = LOGGER_BUF_SIZE ; settings . drop_privileges = true ; # ifdef MEMCACHED_DEBUG settings . relaxed_privileges = false ; # endif },. udpport = 0 <S2SV_ModEnd> ; settings .
578,"int main ( int argc , char * argv [ ] ) { int i , fails_count = 0 ; CU_pSuite cryptoUtilsTestSuite , parserTestSuite ; CU_pSuite * suites [ ] = { & cryptoUtilsTestSuite , & parserTestSuite , NULL } ; if ( argc > 1 ) { if ( argv [ 1 ] [ 0 ] == '-' ) { if ( strcmp ( argv [ 1 ] , ""-verbose"" ) == 0 ) { verbose = 1 ; } else { printf ( ""Usage:\\n<S2SV_blank>%s<S2SV_blank>[-verbose]<S2SV_blank>to<S2SV_blank>enable<S2SV_blank>extensive<S2SV_blank>logging\\n"" , argv [ 0 ] ) ; return 1 ; } } else { printf ( ""Usage:\\n<S2SV_blank>%s<S2SV_blank>[-verbose]<S2SV_blank>to<S2SV_blank>enable<S2SV_blank>extensive<S2SV_blank>logging\\n"" , argv [ 0 ] ) ; return 1 ; } } # ifdef HAVE_LIBXML2 xmlInitParser ( ) ; # endif if ( CUE_SUCCESS != CU_initialize_registry ( ) ) { return CU_get_error ( ) ; } cryptoUtilsTestSuite = CU_add_suite ( ""Bzrtp<S2SV_blank>Crypto<S2SV_blank>Utils"" , NULL , NULL ) ; CU_add_test ( cryptoUtilsTestSuite , ""zrtpKDF"" , test_zrtpKDF ) ; CU_add_test ( cryptoUtilsTestSuite , ""CRC32"" , test_CRC32 ) ; CU_add_test ( cryptoUtilsTestSuite , ""algo<S2SV_blank>agreement"" , test_algoAgreement ) ; CU_add_test ( cryptoUtilsTestSuite , ""context<S2SV_blank>algo<S2SV_blank>setter<S2SV_blank>and<S2SV_blank>getter"" , test_algoSetterGetter ) ; CU_add_test ( cryptoUtilsTestSuite , ""adding<S2SV_blank>mandatory<S2SV_blank>crypto<S2SV_blank>algorithms<S2SV_blank>if<S2SV_blank>needed"" , test_addMandatoryCryptoTypesIfNeeded ) ; parserTestSuite = CU_add_suite ( ""Bzrtp<S2SV_blank>ZRTP<S2SV_blank>Packet<S2SV_blank>Parser"" , NULL , NULL ) ; CU_add_test ( parserTestSuite , ""Parse"" , test_parser ) ; <S2SV_StartBug> CU_add_test ( parserTestSuite , ""Parse<S2SV_blank>Exchange"" , test_parserComplete ) ; <S2SV_EndBug> CU_add_test ( parserTestSuite , ""State<S2SV_blank>machine"" , test_stateMachine ) ; for ( i = 0 ; suites [ i ] ; i ++ ) { CU_basic_run_suite ( * suites [ i ] ) ; fails_count += CU_get_number_of_tests_failed ( ) ; } CU_cleanup_registry ( ) ; # ifdef HAVE_LIBXML2 xmlCleanupParser ( ) ; # endif return ( fails_count == 0 ? 0 : 1 ) ; }","( parserTestSuite , ""Parse<S2SV_blank>hvi<S2SV_blank>check<S2SV_blank>fail"" , test_parser_hvi ) ; CU_add_test ( parserTestSuite ,"
579,"static int load_misc_binary ( struct linux_binprm * bprm ) { Node * fmt ; struct file * interp_file = NULL ; char iname [ BINPRM_BUF_SIZE ] ; const char * iname_addr = iname ; int retval ; int fd_binary = - 1 ; retval = - ENOEXEC ; if ( ! enabled ) goto _ret ; read_lock ( & entries_lock ) ; fmt = check_file ( bprm ) ; if ( fmt ) strlcpy ( iname , fmt -> interpreter , BINPRM_BUF_SIZE ) ; read_unlock ( & entries_lock ) ; if ( ! fmt ) goto _ret ; if ( ! ( fmt -> flags & MISC_FMT_PRESERVE_ARGV0 ) ) { retval = remove_arg_zero ( bprm ) ; if ( retval ) goto _ret ; } if ( fmt -> flags & MISC_FMT_OPEN_BINARY ) { fd_binary = get_unused_fd ( ) ; if ( fd_binary < 0 ) { retval = fd_binary ; goto _ret ; } fd_install ( fd_binary , bprm -> file ) ; would_dump ( bprm , bprm -> file ) ; allow_write_access ( bprm -> file ) ; bprm -> file = NULL ; bprm -> interp_flags |= BINPRM_FLAGS_EXECFD ; bprm -> interp_data = fd_binary ; } else { allow_write_access ( bprm -> file ) ; fput ( bprm -> file ) ; bprm -> file = NULL ; } retval = copy_strings_kernel ( 1 , & bprm -> interp , bprm ) ; if ( retval < 0 ) goto _error ; bprm -> argc ++ ; retval = copy_strings_kernel ( 1 , & iname_addr , bprm ) ; if ( retval < 0 ) goto _error ; bprm -> argc ++ ; <S2SV_StartBug> bprm -> interp = iname ; <S2SV_EndBug> interp_file = open_exec ( iname ) ; retval = PTR_ERR ( interp_file ) ; if ( IS_ERR ( interp_file ) ) goto _error ; bprm -> file = interp_file ; if ( fmt -> flags & MISC_FMT_CREDENTIALS ) { memset ( bprm -> buf , 0 , BINPRM_BUF_SIZE ) ; retval = kernel_read ( bprm -> file , 0 , bprm -> buf , BINPRM_BUF_SIZE ) ; } else retval = prepare_binprm ( bprm ) ; if ( retval < 0 ) goto _error ; retval = search_binary_handler ( bprm ) ; if ( retval < 0 ) goto _error ; _ret : return retval ; _error : if ( fd_binary > 0 ) sys_close ( fd_binary ) ; bprm -> interp_flags = 0 ; bprm -> interp_data = 0 ; goto _ret ; }","argc ++ ; retval = bprm_change_interp ( iname , bprm ) ; if ( retval < 0 ) goto _error <S2SV_ModEnd> ; interp_file ="
580,"YY_DECL { yy_state_type yy_current_state ; char * yy_cp , * yy_bp ; int yy_act ; struct yyguts_t * yyg = ( struct yyguts_t * ) yyscanner ; yylval = yylval_param ; if ( ! yyg -> yy_init ) { yyg -> yy_init = 1 ; # ifdef YY_USER_INIT YY_USER_INIT ; # endif if ( ! yyg -> yy_start ) yyg -> yy_start = 1 ; if ( ! yyin ) yyin = stdin ; if ( ! yyout ) yyout = stdout ; if ( ! YY_CURRENT_BUFFER ) { re_yyensure_buffer_stack ( yyscanner ) ; YY_CURRENT_BUFFER_LVALUE = re_yy_create_buffer ( yyin , YY_BUF_SIZE , yyscanner ) ; } re_yy_load_buffer_state ( yyscanner ) ; } { # line 99 ""re_lexer.l"" # line 863 ""re_lexer.c"" while ( 1 ) { yy_cp = yyg -> yy_c_buf_p ; * yy_cp = yyg -> yy_hold_char ; yy_bp = yy_cp ; yy_current_state = yyg -> yy_start ; yy_match : do { YY_CHAR yy_c = yy_ec [ YY_SC_TO_UI ( * yy_cp ) ] ; if ( yy_accept [ yy_current_state ] ) { yyg -> yy_last_accepting_state = yy_current_state ; yyg -> yy_last_accepting_cpos = yy_cp ; } while ( yy_chk [ yy_base [ yy_current_state ] + yy_c ] != yy_current_state ) { yy_current_state = ( int ) yy_def [ yy_current_state ] ; if ( yy_current_state >= 45 ) yy_c = yy_meta [ ( unsigned int ) yy_c ] ; } yy_current_state = yy_nxt [ yy_base [ yy_current_state ] + ( unsigned int ) yy_c ] ; ++ yy_cp ; } while ( yy_current_state != 44 ) ; yy_cp = yyg -> yy_last_accepting_cpos ; yy_current_state = yyg -> yy_last_accepting_state ; yy_find_action : yy_act = yy_accept [ yy_current_state ] ; YY_DO_BEFORE_ACTION ; if ( yy_act != YY_END_OF_BUFFER && yy_rule_can_match_eol [ yy_act ] ) { yy_size_t yyl ; for ( yyl = 0 ; yyl < yyleng ; ++ yyl ) if ( yytext [ yyl ] == '\\n' ) do { yylineno ++ ; yycolumn = 0 ; } while ( 0 ) ; } do_action : switch ( yy_act ) { case 0 : * yy_cp = yyg -> yy_hold_char ; yy_cp = yyg -> yy_last_accepting_cpos ; yy_current_state = yyg -> yy_last_accepting_state ; goto yy_find_action ; case 1 : YY_RULE_SETUP # line 101 ""re_lexer.l"" { int hi_bound ; int lo_bound = atoi ( yytext + 1 ) ; char * comma = strchr ( yytext , ',' ) ; if ( comma - yytext == strlen ( yytext ) - 2 ) hi_bound = INT16_MAX ; else hi_bound = atoi ( comma + 1 ) ; if ( hi_bound > INT16_MAX ) { yyerror ( yyscanner , lex_env , ""repeat<S2SV_blank>interval<S2SV_blank>too<S2SV_blank>large"" ) ; yyterminate ( ) ; } if ( hi_bound < lo_bound || hi_bound < 0 || lo_bound < 0 ) { yyerror ( yyscanner , lex_env , ""bad<S2SV_blank>repeat<S2SV_blank>interval"" ) ; yyterminate ( ) ; } yylval -> range = ( hi_bound << 16 ) | lo_bound ; return _RANGE_ ; } YY_BREAK case 2 : YY_RULE_SETUP # line 135 ""re_lexer.l"" { int value = atoi ( yytext + 1 ) ; if ( value > INT16_MAX ) { yyerror ( yyscanner , lex_env , ""repeat<S2SV_blank>interval<S2SV_blank>too<S2SV_blank>large"" ) ; yyterminate ( ) ; } yylval -> range = ( value << 16 ) | value ; return _RANGE_ ; } YY_BREAK case 3 : YY_RULE_SETUP # line 153 ""re_lexer.l"" { BEGIN ( char_class ) ; memset ( LEX_ENV -> class_vector , 0 , 32 ) ; LEX_ENV -> negated_class = TRUE ; } YY_BREAK case 4 : YY_RULE_SETUP # line 162 ""re_lexer.l"" { BEGIN ( char_class ) ; memset ( LEX_ENV -> class_vector , 0 , 32 ) ; LEX_ENV -> negated_class = TRUE ; LEX_ENV -> class_vector [ ']' / 8 ] |= 1 << ']' % 8 ; } YY_BREAK case 5 : YY_RULE_SETUP # line 175 ""re_lexer.l"" { BEGIN ( char_class ) ; memset ( LEX_ENV -> class_vector , 0 , 32 ) ; LEX_ENV -> negated_class = FALSE ; LEX_ENV -> class_vector [ ']' / 8 ] |= 1 << ']' % 8 ; } YY_BREAK case 6 : YY_RULE_SETUP # line 188 ""re_lexer.l"" { BEGIN ( char_class ) ; memset ( LEX_ENV -> class_vector , 0 , 32 ) ; LEX_ENV -> negated_class = FALSE ; } YY_BREAK case 7 : YY_RULE_SETUP # line 198 ""re_lexer.l"" { yylval -> integer = yytext [ 0 ] ; return _CHAR_ ; } YY_BREAK case 8 : YY_RULE_SETUP # line 207 ""re_lexer.l"" { return _WORD_CHAR_ ; } YY_BREAK case 9 : YY_RULE_SETUP # line 212 ""re_lexer.l"" { return _NON_WORD_CHAR_ ; } YY_BREAK case 10 : YY_RULE_SETUP # line 217 ""re_lexer.l"" { return _SPACE_ ; } YY_BREAK case 11 : YY_RULE_SETUP # line 222 ""re_lexer.l"" { return _NON_SPACE_ ; } YY_BREAK case 12 : YY_RULE_SETUP # line 227 ""re_lexer.l"" { return _DIGIT_ ; } YY_BREAK case 13 : YY_RULE_SETUP # line 232 ""re_lexer.l"" { return _NON_DIGIT_ ; } YY_BREAK case 14 : YY_RULE_SETUP # line 237 ""re_lexer.l"" { return _WORD_BOUNDARY_ ; } YY_BREAK case 15 : YY_RULE_SETUP # line 241 ""re_lexer.l"" { return _NON_WORD_BOUNDARY_ ; } YY_BREAK case 16 : YY_RULE_SETUP # line 246 ""re_lexer.l"" { yyerror ( yyscanner , lex_env , ""backreferences<S2SV_blank>are<S2SV_blank>not<S2SV_blank>allowed"" ) ; yyterminate ( ) ; } YY_BREAK case 17 : YY_RULE_SETUP # line 253 ""re_lexer.l"" { uint8_t c ; if ( read_escaped_char ( yyscanner , & c ) ) { yylval -> integer = c ; return _CHAR_ ; } else { <S2SV_StartBug> yyerror ( yyscanner , lex_env , ""unexpected<S2SV_blank>end<S2SV_blank>of<S2SV_blank>buffer"" ) ; <S2SV_EndBug> yyterminate ( ) ; } } YY_BREAK case 18 : YY_RULE_SETUP # line 270 ""re_lexer.l"" { int i ; yylval -> class_vector = ( uint8_t * ) yr_malloc ( 32 ) ; memcpy ( yylval -> class_vector , LEX_ENV -> class_vector , 32 ) ; if ( LEX_ENV -> negated_class ) { for ( i = 0 ; i < 32 ; i ++ ) yylval -> class_vector [ i ] = ~ yylval -> class_vector [ i ] ; } BEGIN ( INITIAL ) ; return _CLASS_ ; } YY_BREAK case 19 : YY_RULE_SETUP # line 291 ""re_lexer.l"" { uint16_t c ; uint8_t start = yytext [ 0 ] ; uint8_t end = yytext [ 2 ] ; if ( start == '\\\\' ) { start = escaped_char_value ( yytext ) ; if ( yytext [ 1 ] == 'x' ) end = yytext [ 5 ] ; else end = yytext [ 3 ] ; } if ( end == '\\\\' ) { if ( ! read_escaped_char ( yyscanner , & end ) ) { <S2SV_StartBug> yyerror ( yyscanner , lex_env , ""unexpected<S2SV_blank>end<S2SV_blank>of<S2SV_blank>buffer"" ) ; <S2SV_EndBug> yyterminate ( ) ; } } if ( end < start ) { yyerror ( yyscanner , lex_env , ""bad<S2SV_blank>character<S2SV_blank>range"" ) ; yyterminate ( ) ; } for ( c = start ; c <= end ; c ++ ) { LEX_ENV -> class_vector [ c / 8 ] |= 1 << c % 8 ; } } YY_BREAK case 20 : YY_RULE_SETUP # line 333 ""re_lexer.l"" { int i ; for ( i = 0 ; i < 32 ; i ++ ) LEX_ENV -> class_vector [ i ] |= word_chars [ i ] ; } YY_BREAK case 21 : YY_RULE_SETUP # line 342 ""re_lexer.l"" { int i ; for ( i = 0 ; i < 32 ; i ++ ) LEX_ENV -> class_vector [ i ] |= ~ word_chars [ i ] ; } YY_BREAK case 22 : YY_RULE_SETUP # line 351 ""re_lexer.l"" { LEX_ENV -> class_vector [ '<S2SV_blank>' / 8 ] |= 1 << '<S2SV_blank>' % 8 ; LEX_ENV -> class_vector [ '\\t' / 8 ] |= 1 << '\\t' % 8 ; } YY_BREAK case 23 : YY_RULE_SETUP # line 358 ""re_lexer.l"" { int i ; for ( i = 0 ; i < 32 ; i ++ ) { if ( i == '<S2SV_blank>' / 8 ) LEX_ENV -> class_vector [ i ] |= ~ ( 1 << '<S2SV_blank>' % 8 ) ; else if ( i == '\\t' / 8 ) LEX_ENV -> class_vector [ i ] |= ~ ( 1 << '\\t' % 8 ) ; else LEX_ENV -> class_vector [ i ] = 0xFF ; } } YY_BREAK case 24 : YY_RULE_SETUP # line 374 ""re_lexer.l"" { char c ; for ( c = '0' ; c <= '9' ; c ++ ) LEX_ENV -> class_vector [ c / 8 ] |= 1 << c % 8 ; } YY_BREAK case 25 : YY_RULE_SETUP # line 383 ""re_lexer.l"" { int i ; for ( i = 0 ; i < 32 ; i ++ ) { if ( i == 6 ) continue ; if ( i == 7 ) LEX_ENV -> class_vector [ i ] |= 0xFC ; else LEX_ENV -> class_vector [ i ] = 0xFF ; } } YY_BREAK case 26 : YY_RULE_SETUP # line 403 ""re_lexer.l"" { uint8_t c ; if ( read_escaped_char ( yyscanner , & c ) ) { LEX_ENV -> class_vector [ c / 8 ] |= 1 << c % 8 ; } else { <S2SV_StartBug> yyerror ( yyscanner , lex_env , ""unexpected<S2SV_blank>end<S2SV_blank>of<S2SV_blank>buffer"" ) ; <S2SV_EndBug> yyterminate ( ) ; } } YY_BREAK case 27 : YY_RULE_SETUP # line 419 ""re_lexer.l"" { if ( yytext [ 0 ] >= 32 && yytext [ 0 ] < 127 ) { LEX_ENV -> class_vector [ yytext [ 0 ] / 8 ] |= 1 << yytext [ 0 ] % 8 ; } else { yyerror ( yyscanner , lex_env , ""non-ascii<S2SV_blank>character"" ) ; yyterminate ( ) ; } } YY_BREAK case YY_STATE_EOF ( char_class ) : # line 436 ""re_lexer.l"" { yyerror ( yyscanner , lex_env , ""missing<S2SV_blank>terminating<S2SV_blank>]<S2SV_blank>for<S2SV_blank>character<S2SV_blank>class"" ) ; yyterminate ( ) ; } YY_BREAK case 28 : YY_RULE_SETUP # line 445 ""re_lexer.l"" { if ( yytext [ 0 ] >= 32 && yytext [ 0 ] < 127 ) { return yytext [ 0 ] ; } else { yyerror ( yyscanner , lex_env , ""non-ascii<S2SV_blank>character"" ) ; yyterminate ( ) ; } } YY_BREAK case YY_STATE_EOF ( INITIAL ) : # line 459 ""re_lexer.l"" { yyterminate ( ) ; } YY_BREAK case 29 : YY_RULE_SETUP # line 464 ""re_lexer.l"" ECHO ; YY_BREAK # line 1358 ""re_lexer.c"" case YY_END_OF_BUFFER : { int yy_amount_of_matched_text = ( int ) ( yy_cp - yyg -> yytext_ptr ) - 1 ; * yy_cp = yyg -> yy_hold_char ; YY_RESTORE_YY_MORE_OFFSET if ( YY_CURRENT_BUFFER_LVALUE -> yy_buffer_status == YY_BUFFER_NEW ) { yyg -> yy_n_chars = YY_CURRENT_BUFFER_LVALUE -> yy_n_chars ; YY_CURRENT_BUFFER_LVALUE -> yy_input_file = yyin ; YY_CURRENT_BUFFER_LVALUE -> yy_buffer_status = YY_BUFFER_NORMAL ; } if ( yyg -> yy_c_buf_p <= & YY_CURRENT_BUFFER_LVALUE -> yy_ch_buf [ yyg -> yy_n_chars ] ) { yy_state_type yy_next_state ; yyg -> yy_c_buf_p = yyg -> yytext_ptr + yy_amount_of_matched_text ; yy_current_state = yy_get_previous_state ( yyscanner ) ; yy_next_state = yy_try_NUL_trans ( yy_current_state , yyscanner ) ; yy_bp = yyg -> yytext_ptr + YY_MORE_ADJ ; if ( yy_next_state ) { yy_cp = ++ yyg -> yy_c_buf_p ; yy_current_state = yy_next_state ; goto yy_match ; } else { yy_cp = yyg -> yy_last_accepting_cpos ; yy_current_state = yyg -> yy_last_accepting_state ; goto yy_find_action ; } } else switch ( yy_get_next_buffer ( yyscanner ) ) { case EOB_ACT_END_OF_FILE : { yyg -> yy_did_buffer_switch_on_eof = 0 ; if ( re_yywrap ( yyscanner ) ) { yyg -> yy_c_buf_p = yyg -> yytext_ptr + YY_MORE_ADJ ; yy_act = YY_STATE_EOF ( YY_START ) ; goto do_action ; } else { if ( ! yyg -> yy_did_buffer_switch_on_eof ) YY_NEW_FILE ; } break ; } case EOB_ACT_CONTINUE_SCAN : yyg -> yy_c_buf_p = yyg -> yytext_ptr + yy_amount_of_matched_text ; yy_current_state = yy_get_previous_state ( yyscanner ) ; yy_cp = yyg -> yy_c_buf_p ; yy_bp = yyg -> yytext_ptr + YY_MORE_ADJ ; goto yy_match ; case EOB_ACT_LAST_MATCH : yyg -> yy_c_buf_p = & YY_CURRENT_BUFFER_LVALUE -> yy_ch_buf [ yyg -> yy_n_chars ] ; yy_current_state = yy_get_previous_state ( yyscanner ) ; yy_cp = yyg -> yy_c_buf_p ; yy_bp = yyg -> yytext_ptr + YY_MORE_ADJ ; goto yy_find_action ; } break ; } default : YY_FATAL_ERROR ( ""fatal<S2SV_blank>flex<S2SV_blank>scanner<S2SV_blank>internal<S2SV_blank>error--no<S2SV_blank>action<S2SV_blank>found"" ) ; } } } }",", lex_env , ""illegal<S2SV_blank>escape<S2SV_blank>sequence"" <S2SV_ModEnd> ) ; yyterminate <S2SV_ModStart> , lex_env , ""illegal<S2SV_blank>escape<S2SV_blank>sequence"" <S2SV_ModEnd> ) ; yyterminate <S2SV_ModStart> , lex_env , ""illegal<S2SV_blank>escape<S2SV_blank>sequence"" <S2SV_ModEnd> ) ; yyterminate"
581,"void vp8_pick_inter_mode ( VP8_COMP * cpi , MACROBLOCK * x , int recon_yoffset , int recon_uvoffset , int * returnrate , int * returndistortion , int * returnintra , int mb_row , int mb_col ) { BLOCK * b = & x -> block [ 0 ] ; BLOCKD * d = & x -> e_mbd . block [ 0 ] ; MACROBLOCKD * xd = & x -> e_mbd ; MB_MODE_INFO best_mbmode ; int_mv best_ref_mv_sb [ 2 ] ; int_mv mode_mv_sb [ 2 ] [ MB_MODE_COUNT ] ; int_mv best_ref_mv ; int_mv * mode_mv ; MB_PREDICTION_MODE this_mode ; int num00 ; int mdcounts [ 4 ] ; int best_rd = INT_MAX ; int rd_adjustment = 100 ; int best_intra_rd = INT_MAX ; int mode_index ; int rate ; int rate2 ; int distortion2 ; int bestsme = INT_MAX ; int best_mode_index = 0 ; <S2SV_StartBug> unsigned int sse = INT_MAX , best_rd_sse = INT_MAX ; <S2SV_EndBug> # if CONFIG_TEMPORAL_DENOISING <S2SV_StartBug> unsigned int zero_mv_sse = INT_MAX , best_sse = INT_MAX ; <S2SV_EndBug> # endif <S2SV_StartBug> int sf_improved_mv_pred = cpi -> sf . improved_mv_pred ; <S2SV_EndBug> int_mv mvp ; int near_sadidx [ 8 ] = { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 } ; int saddone = 0 ; int sr = 0 ; unsigned char * plane [ 4 ] [ 3 ] ; int ref_frame_map [ 4 ] ; int sign_bias = 0 ; <S2SV_StartBug> # if CONFIG_MULTI_RES_ENCODING <S2SV_EndBug> int dissim = INT_MAX ; int parent_ref_frame = 0 ; <S2SV_StartBug> int parent_ref_valid = cpi -> oxcf . mr_encoder_id && cpi -> mr_low_res_mv_avail ; <S2SV_EndBug> int_mv parent_ref_mv ; MB_PREDICTION_MODE parent_mode = 0 ; if ( parent_ref_valid ) { int parent_ref_flag ; get_lower_res_motion_info ( cpi , xd , & dissim , & parent_ref_frame , & parent_mode , & parent_ref_mv , mb_row , mb_col ) ; parent_ref_flag = 0 ; if ( parent_ref_frame == LAST_FRAME ) parent_ref_flag = ( cpi -> ref_frame_flags & VP8_LAST_FRAME ) ; else if ( parent_ref_frame == GOLDEN_FRAME ) <S2SV_StartBug> parent_ref_flag = ( cpi -> ref_frame_flags & VP8_GOLD_FRAME ) ; <S2SV_EndBug> else if ( parent_ref_frame == ALTREF_FRAME ) parent_ref_flag = ( cpi -> ref_frame_flags & VP8_ALTR_FRAME ) ; if ( parent_ref_frame && ! parent_ref_flag ) parent_ref_valid = 0 ; <S2SV_StartBug> } <S2SV_EndBug> # endif <S2SV_StartBug> mode_mv = mode_mv_sb [ sign_bias ] ; <S2SV_EndBug> best_ref_mv . as_int = 0 ; <S2SV_StartBug> vpx_memset ( mode_mv_sb , 0 , sizeof ( mode_mv_sb ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( & best_mbmode , 0 , sizeof ( best_mbmode ) ) ; <S2SV_EndBug> # if CONFIG_MULTI_RES_ENCODING if ( parent_ref_valid && parent_ref_frame && dissim < 8 ) { ref_frame_map [ 0 ] = - 1 ; ref_frame_map [ 1 ] = parent_ref_frame ; ref_frame_map [ 2 ] = - 1 ; ref_frame_map [ 3 ] = - 1 ; } else # endif get_reference_search_order ( cpi , ref_frame_map ) ; if ( ref_frame_map [ 1 ] > 0 ) { sign_bias = vp8_find_near_mvs_bias ( & x -> e_mbd , x -> e_mbd . mode_info_context , mode_mv_sb , best_ref_mv_sb , mdcounts , ref_frame_map [ 1 ] , cpi -> common . ref_frame_sign_bias ) ; mode_mv = mode_mv_sb [ sign_bias ] ; best_ref_mv . as_int = best_ref_mv_sb [ sign_bias ] . as_int ; } <S2SV_StartBug> get_predictor_pointers ( cpi , plane , recon_yoffset , recon_uvoffset ) ; <S2SV_EndBug> x -> mbs_tested_so_far ++ ; * returnintra = INT_MAX ; x -> skip = 0 ; x -> e_mbd . mode_info_context -> mbmi . ref_frame = INTRA_FRAME ; <S2SV_StartBug> calculate_zeromv_rd_adjustment ( cpi , x , & rd_adjustment ) ; <S2SV_EndBug> for ( mode_index = 0 ; mode_index < MAX_MODES ; mode_index ++ ) { int frame_cost ; int this_rd = INT_MAX ; int this_ref_frame = ref_frame_map [ vp8_ref_frame_order [ mode_index ] ] ; if ( best_rd <= x -> rd_threshes [ mode_index ] ) continue ; if ( this_ref_frame < 0 ) continue ; x -> e_mbd . mode_info_context -> mbmi . ref_frame = this_ref_frame ; if ( x -> e_mbd . mode_info_context -> mbmi . ref_frame ) { x -> e_mbd . pre . y_buffer = plane [ this_ref_frame ] [ 0 ] ; x -> e_mbd . pre . u_buffer = plane [ this_ref_frame ] [ 1 ] ; x -> e_mbd . pre . v_buffer = plane [ this_ref_frame ] [ 2 ] ; if ( sign_bias != cpi -> common . ref_frame_sign_bias [ this_ref_frame ] ) { sign_bias = cpi -> common . ref_frame_sign_bias [ this_ref_frame ] ; mode_mv = mode_mv_sb [ sign_bias ] ; best_ref_mv . as_int = best_ref_mv_sb [ sign_bias ] . as_int ; } # if CONFIG_MULTI_RES_ENCODING if ( parent_ref_valid ) { if ( vp8_mode_order [ mode_index ] == NEARESTMV && mode_mv [ NEARESTMV ] . as_int == 0 ) continue ; if ( vp8_mode_order [ mode_index ] == NEARMV && mode_mv [ NEARMV ] . as_int == 0 ) continue ; if ( vp8_mode_order [ mode_index ] == NEWMV && parent_mode == ZEROMV && best_ref_mv . as_int == 0 ) continue ; else if ( vp8_mode_order [ mode_index ] == NEWMV && dissim == 0 && best_ref_mv . as_int == parent_ref_mv . as_int ) continue ; } # endif } if ( x -> mode_test_hit_counts [ mode_index ] && ( cpi -> mode_check_freq [ mode_index ] > 1 ) ) { if ( x -> mbs_tested_so_far <= ( cpi -> mode_check_freq [ mode_index ] * x -> mode_test_hit_counts [ mode_index ] ) ) { x -> rd_thresh_mult [ mode_index ] += 4 ; if ( x -> rd_thresh_mult [ mode_index ] > MAX_THRESHMULT ) x -> rd_thresh_mult [ mode_index ] = MAX_THRESHMULT ; x -> rd_threshes [ mode_index ] = ( cpi -> rd_baseline_thresh [ mode_index ] >> 7 ) * x -> rd_thresh_mult [ mode_index ] ; continue ; } } x -> mode_test_hit_counts [ mode_index ] ++ ; rate2 = 0 ; distortion2 = 0 ; this_mode = vp8_mode_order [ mode_index ] ; x -> e_mbd . mode_info_context -> mbmi . mode = this_mode ; x -> e_mbd . mode_info_context -> mbmi . uv_mode = DC_PRED ; frame_cost = x -> ref_frame_cost [ x -> e_mbd . mode_info_context -> mbmi . ref_frame ] ; rate2 += frame_cost ; if ( cpi -> is_src_frame_alt_ref && ( cpi -> oxcf . arnr_max_frames == 0 ) ) { if ( this_mode != ZEROMV || x -> e_mbd . mode_info_context -> mbmi . ref_frame != ALTREF_FRAME ) continue ; } switch ( this_mode ) { case B_PRED : distortion2 = best_rd_sse ; pick_intra4x4mby_modes ( x , & rate , & distortion2 ) ; if ( distortion2 == INT_MAX ) { this_rd = INT_MAX ; } else { rate2 += rate ; <S2SV_StartBug> distortion2 = vp8_variance16x16 ( <S2SV_EndBug> * ( b -> base_src ) , b -> src_stride , x -> e_mbd . predictor , 16 , & sse ) ; this_rd = RDCOST ( x -> rdmult , x -> rddiv , rate2 , distortion2 ) ; if ( this_rd < best_intra_rd ) { best_intra_rd = this_rd ; * returnintra = distortion2 ; } } break ; case SPLITMV : break ; case DC_PRED : case V_PRED : case H_PRED : case TM_PRED : vp8_build_intra_predictors_mby_s ( xd , xd -> dst . y_buffer - xd -> dst . y_stride , xd -> dst . y_buffer - 1 , xd -> dst . y_stride , xd -> predictor , 16 ) ; <S2SV_StartBug> distortion2 = vp8_variance16x16 <S2SV_EndBug> ( * ( b -> base_src ) , b -> src_stride , x -> e_mbd . predictor , 16 , & sse ) ; rate2 += x -> mbmode_cost [ x -> e_mbd . frame_type ] [ x -> e_mbd . mode_info_context -> mbmi . mode ] ; this_rd = RDCOST ( x -> rdmult , x -> rddiv , rate2 , distortion2 ) ; if ( this_rd < best_intra_rd ) { best_intra_rd = this_rd ; * returnintra = distortion2 ; } break ; case NEWMV : { int thissme ; int step_param ; int further_steps ; int n = 0 ; int sadpb = x -> sadperbit16 ; int_mv mvp_full ; int col_min = ( ( best_ref_mv . as_mv . col + 7 ) >> 3 ) - MAX_FULL_PEL_VAL ; int row_min = ( ( best_ref_mv . as_mv . row + 7 ) >> 3 ) - MAX_FULL_PEL_VAL ; int col_max = ( best_ref_mv . as_mv . col >> 3 ) + MAX_FULL_PEL_VAL ; int row_max = ( best_ref_mv . as_mv . row >> 3 ) + MAX_FULL_PEL_VAL ; int tmp_col_min = x -> mv_col_min ; int tmp_col_max = x -> mv_col_max ; int tmp_row_min = x -> mv_row_min ; int tmp_row_max = x -> mv_row_max ; int speed_adjust = ( cpi -> Speed > 5 ) ? ( ( cpi -> Speed >= 8 ) ? 3 : 2 ) : 1 ; step_param = cpi -> sf . first_step + speed_adjust ; # if CONFIG_MULTI_RES_ENCODING <S2SV_StartBug> if ( cpi -> oxcf . mr_encoder_id && ! parent_ref_valid ) <S2SV_EndBug> sf_improved_mv_pred = 0 ; <S2SV_StartBug> if ( parent_ref_valid && parent_ref_frame ) <S2SV_EndBug> { mvp . as_int = parent_ref_mv . as_int ; mvp_full . as_mv . col = parent_ref_mv . as_mv . col >> 3 ; mvp_full . as_mv . row = parent_ref_mv . as_mv . row >> 3 ; if ( dissim <= 32 ) step_param += 3 ; else if ( dissim <= 128 ) step_param += 2 ; else step_param += 1 ; } else # endif { if ( sf_improved_mv_pred ) { if ( ! saddone ) { vp8_cal_sad ( cpi , xd , x , recon_yoffset , & near_sadidx [ 0 ] ) ; saddone = 1 ; } vp8_mv_pred ( cpi , & x -> e_mbd , x -> e_mbd . mode_info_context , & mvp , x -> e_mbd . mode_info_context -> mbmi . ref_frame , cpi -> common . ref_frame_sign_bias , & sr , & near_sadidx [ 0 ] ) ; sr += speed_adjust ; if ( sr > step_param ) step_param = sr ; mvp_full . as_mv . col = mvp . as_mv . col >> 3 ; mvp_full . as_mv . row = mvp . as_mv . row >> 3 ; } else { mvp . as_int = best_ref_mv . as_int ; mvp_full . as_mv . col = best_ref_mv . as_mv . col >> 3 ; mvp_full . as_mv . row = best_ref_mv . as_mv . row >> 3 ; } } # if CONFIG_MULTI_RES_ENCODING <S2SV_StartBug> if ( parent_ref_valid && parent_ref_frame && dissim <= 2 && <S2SV_EndBug> MAX ( abs ( best_ref_mv . as_mv . row - parent_ref_mv . as_mv . row ) , abs ( best_ref_mv . as_mv . col - parent_ref_mv . as_mv . col ) ) <= 4 ) { d -> bmi . mv . as_int = mvp_full . as_int ; mode_mv [ NEWMV ] . as_int = mvp_full . as_int ; cpi -> find_fractional_mv_step ( x , b , d , & d -> bmi . mv , & best_ref_mv , x -> errorperbit , & cpi -> fn_ptr [ BLOCK_16X16 ] , cpi -> mb . mvcost , & distortion2 , & sse ) ; } else # endif { if ( x -> mv_col_min < col_min ) x -> mv_col_min = col_min ; if ( x -> mv_col_max > col_max ) x -> mv_col_max = col_max ; if ( x -> mv_row_min < row_min ) x -> mv_row_min = row_min ; if ( x -> mv_row_max > row_max ) x -> mv_row_max = row_max ; further_steps = ( cpi -> Speed >= 8 ) ? 0 : ( cpi -> sf . max_step_search_steps - 1 - step_param ) ; if ( cpi -> sf . search_method == HEX ) { # if CONFIG_MULTI_RES_ENCODING <S2SV_StartBug> if ( ! parent_ref_valid ) <S2SV_EndBug> step_param = 0 ; # endif bestsme = vp8_hex_search ( x , b , d , & mvp_full , & d -> bmi . mv , step_param , sadpb , & cpi -> fn_ptr [ BLOCK_16X16 ] , x -> mvsadcost , x -> mvcost , & best_ref_mv ) ; mode_mv [ NEWMV ] . as_int = d -> bmi . mv . as_int ; } else { bestsme = cpi -> diamond_search_sad ( x , b , d , & mvp_full , & d -> bmi . mv , step_param , sadpb , & num00 , & cpi -> fn_ptr [ BLOCK_16X16 ] , x -> mvcost , & best_ref_mv ) ; mode_mv [ NEWMV ] . as_int = d -> bmi . mv . as_int ; n = num00 ; num00 = 0 ; while ( n < further_steps ) { n ++ ; if ( num00 ) num00 -- ; else { thissme = cpi -> diamond_search_sad ( x , b , d , & mvp_full , & d -> bmi . mv , step_param + n , sadpb , & num00 , & cpi -> fn_ptr [ BLOCK_16X16 ] , x -> mvcost , & best_ref_mv ) ; if ( thissme < bestsme ) { bestsme = thissme ; mode_mv [ NEWMV ] . as_int = d -> bmi . mv . as_int ; } else { d -> bmi . mv . as_int = mode_mv [ NEWMV ] . as_int ; } } } } x -> mv_col_min = tmp_col_min ; x -> mv_col_max = tmp_col_max ; x -> mv_row_min = tmp_row_min ; x -> mv_row_max = tmp_row_max ; if ( bestsme < INT_MAX ) cpi -> find_fractional_mv_step ( x , b , d , & d -> bmi . mv , & best_ref_mv , x -> errorperbit , & cpi -> fn_ptr [ BLOCK_16X16 ] , cpi -> mb . mvcost , & distortion2 , & sse ) ; } mode_mv [ NEWMV ] . as_int = d -> bmi . mv . as_int ; <S2SV_StartBug> rate2 += vp8_mv_bit_cost ( & mode_mv [ NEWMV ] , & best_ref_mv , <S2SV_EndBug> cpi -> mb . mvcost , 128 ) ; } case NEARESTMV : case NEARMV : if ( mode_mv [ this_mode ] . as_int == 0 ) continue ; case ZEROMV : if ( ( ( mode_mv [ this_mode ] . as_mv . row >> 3 ) < x -> mv_row_min ) || ( ( mode_mv [ this_mode ] . as_mv . row >> 3 ) > x -> mv_row_max ) || ( ( mode_mv [ this_mode ] . as_mv . col >> 3 ) < x -> mv_col_min ) || ( ( mode_mv [ this_mode ] . as_mv . col >> 3 ) > x -> mv_col_max ) ) continue ; rate2 += vp8_cost_mv_ref ( this_mode , mdcounts ) ; x -> e_mbd . mode_info_context -> mbmi . mv . as_int = mode_mv [ this_mode ] . as_int ; this_rd = evaluate_inter_mode ( & sse , rate2 , & distortion2 , cpi , x , rd_adjustment ) ; break ; default : break ; } # if CONFIG_TEMPORAL_DENOISING if ( cpi -> oxcf . noise_sensitivity ) <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> if ( this_mode == ZEROMV && sse < zero_mv_sse ) <S2SV_EndBug> { zero_mv_sse = sse ; x -> best_zeromv_reference_frame = x -> e_mbd . mode_info_context -> mbmi . ref_frame ; } if ( x -> e_mbd . mode_info_context -> mbmi . mode == NEWMV && <S2SV_StartBug> sse < best_sse ) <S2SV_EndBug> { best_sse = sse ; x -> best_sse_inter_mode = NEWMV ; x -> best_sse_mv = x -> e_mbd . mode_info_context -> mbmi . mv ; x -> need_to_clamp_best_mvs = x -> e_mbd . mode_info_context -> mbmi . need_to_clamp_mvs ; x -> best_reference_frame = x -> e_mbd . mode_info_context -> mbmi . ref_frame ; } } # endif if ( this_rd < best_rd || x -> skip ) { best_mode_index = mode_index ; * returnrate = rate2 ; * returndistortion = distortion2 ; best_rd_sse = sse ; best_rd = this_rd ; <S2SV_StartBug> vpx_memcpy ( & best_mbmode , & x -> e_mbd . mode_info_context -> mbmi , <S2SV_EndBug> sizeof ( MB_MODE_INFO ) ) ; x -> rd_thresh_mult [ mode_index ] = ( x -> rd_thresh_mult [ mode_index ] >= ( MIN_THRESHMULT + 2 ) ) ? x -> rd_thresh_mult [ mode_index ] - 2 : MIN_THRESHMULT ; x -> rd_threshes [ mode_index ] = ( cpi -> rd_baseline_thresh [ mode_index ] >> 7 ) * x -> rd_thresh_mult [ mode_index ] ; } else { x -> rd_thresh_mult [ mode_index ] += 4 ; if ( x -> rd_thresh_mult [ mode_index ] > MAX_THRESHMULT ) x -> rd_thresh_mult [ mode_index ] = MAX_THRESHMULT ; x -> rd_threshes [ mode_index ] = ( cpi -> rd_baseline_thresh [ mode_index ] >> 7 ) * x -> rd_thresh_mult [ mode_index ] ; } if ( x -> skip ) break ; } if ( ( cpi -> rd_baseline_thresh [ best_mode_index ] > 0 ) && ( cpi -> rd_baseline_thresh [ best_mode_index ] < ( INT_MAX >> 2 ) ) ) { int best_adjustment = ( x -> rd_thresh_mult [ best_mode_index ] >> 3 ) ; x -> rd_thresh_mult [ best_mode_index ] = ( x -> rd_thresh_mult [ best_mode_index ] >= ( MIN_THRESHMULT + best_adjustment ) ) ? x -> rd_thresh_mult [ best_mode_index ] - best_adjustment : MIN_THRESHMULT ; x -> rd_threshes [ best_mode_index ] = ( cpi -> rd_baseline_thresh [ best_mode_index ] >> 7 ) * x -> rd_thresh_mult [ best_mode_index ] ; } { int this_rdbin = ( * returndistortion >> 7 ) ; if ( this_rdbin >= 1024 ) { this_rdbin = 1023 ; } x -> error_bins [ this_rdbin ] ++ ; } # if CONFIG_TEMPORAL_DENOISING if ( cpi -> oxcf . noise_sensitivity ) { <S2SV_StartBug> if ( x -> best_sse_inter_mode == DC_PRED ) <S2SV_EndBug> { x -> best_sse_inter_mode = best_mbmode . mode ; x -> best_sse_mv = best_mbmode . mv ; x -> need_to_clamp_best_mvs = best_mbmode . need_to_clamp_mvs ; x -> best_reference_frame = best_mbmode . ref_frame ; best_sse = best_rd_sse ; } <S2SV_StartBug> vp8_denoiser_denoise_mb ( & cpi -> denoiser , x , best_sse , zero_mv_sse , <S2SV_EndBug> <S2SV_StartBug> recon_yoffset , recon_uvoffset ) ; <S2SV_EndBug> <S2SV_StartBug> if ( best_mbmode . ref_frame == INTRA_FRAME && <S2SV_EndBug> x -> best_zeromv_reference_frame != INTRA_FRAME ) { int this_rd = 0 ; int this_ref_frame = x -> best_zeromv_reference_frame ; <S2SV_StartBug> rate2 = x -> ref_frame_cost [ this_ref_frame ] + <S2SV_EndBug> vp8_cost_mv_ref ( ZEROMV , mdcounts ) ; distortion2 = 0 ; x -> e_mbd . mode_info_context -> mbmi . ref_frame = this_ref_frame ; x -> e_mbd . pre . y_buffer = plane [ this_ref_frame ] [ 0 ] ; x -> e_mbd . pre . u_buffer = plane [ this_ref_frame ] [ 1 ] ; x -> e_mbd . pre . v_buffer = plane [ this_ref_frame ] [ 2 ] ; x -> e_mbd . mode_info_context -> mbmi . mode = ZEROMV ; x -> e_mbd . mode_info_context -> mbmi . uv_mode = DC_PRED ; x -> e_mbd . mode_info_context -> mbmi . mv . as_int = 0 ; this_rd = evaluate_inter_mode ( & sse , rate2 , & distortion2 , cpi , x , rd_adjustment ) ; if ( this_rd < best_rd ) { <S2SV_StartBug> vpx_memcpy ( & best_mbmode , & x -> e_mbd . mode_info_context -> mbmi , <S2SV_EndBug> sizeof ( MB_MODE_INFO ) ) ; } } } # endif if ( cpi -> is_src_frame_alt_ref && ( best_mbmode . mode != ZEROMV || best_mbmode . ref_frame != ALTREF_FRAME ) ) { x -> e_mbd . mode_info_context -> mbmi . mode = ZEROMV ; x -> e_mbd . mode_info_context -> mbmi . ref_frame = ALTREF_FRAME ; x -> e_mbd . mode_info_context -> mbmi . mv . as_int = 0 ; x -> e_mbd . mode_info_context -> mbmi . uv_mode = DC_PRED ; x -> e_mbd . mode_info_context -> mbmi . mb_skip_coeff = ( cpi -> common . mb_no_coeff_skip ) ; x -> e_mbd . mode_info_context -> mbmi . partitioning = 0 ; return ; } if ( ! x -> skip ) <S2SV_StartBug> vpx_memcpy ( & x -> e_mbd . mode_info_context -> mbmi , & best_mbmode , <S2SV_EndBug> sizeof ( MB_MODE_INFO ) ) ; if ( best_mbmode . mode <= B_PRED ) { pick_intra_mbuv_mode ( x ) ; } if ( sign_bias != cpi -> common . ref_frame_sign_bias [ xd -> mode_info_context -> mbmi . ref_frame ] ) best_ref_mv . as_int = best_ref_mv_sb [ ! sign_bias ] . as_int ; update_mvcount ( x , & best_ref_mv ) ; }","int sse = UINT_MAX <S2SV_ModEnd> , best_rd_sse = <S2SV_ModStart> , best_rd_sse = UINT_MAX <S2SV_ModEnd> ; # if <S2SV_ModStart> int zero_mv_sse = UINT_MAX <S2SV_ModEnd> , best_sse = <S2SV_ModStart> , best_sse = UINT_MAX <S2SV_ModEnd> ; # endif <S2SV_ModStart> . improved_mv_pred ; # if CONFIG_MULTI_RES_ENCODING int dissim = INT_MAX ; int parent_ref_frame = 0 ; int_mv parent_ref_mv ; MB_PREDICTION_MODE parent_mode = 0 ; int parent_ref_valid = 0 ; # endif <S2SV_ModStart> = 0 ; int dot_artifact_candidate = 0 ; get_predictor_pointers ( cpi , plane , recon_yoffset , recon_uvoffset ) ; if ( cpi -> ref_frame_flags & VP8_LAST_FRAME ) { unsigned char * target_y = x -> src . y_buffer ; unsigned char * target_u = x -> block [ 16 ] . src + * x -> block [ 16 ] . base_src ; unsigned char * target_v = x -> block [ 20 ] . src + * x -> block [ 20 ] . base_src ; int stride = x -> src . y_stride ; int stride_uv = x -> block [ 16 ] . src_stride ; # if CONFIG_TEMPORAL_DENOISING if ( cpi -> oxcf . noise_sensitivity ) { const int uv_denoise = ( cpi -> oxcf . noise_sensitivity >= 2 ) ? 1 : 0 ; target_y = cpi -> denoiser . yv12_running_avg [ LAST_FRAME ] . y_buffer + recon_yoffset ; stride = cpi -> denoiser . yv12_running_avg [ LAST_FRAME ] . y_stride ; if ( uv_denoise ) { target_u = cpi -> denoiser . yv12_running_avg [ LAST_FRAME ] . u_buffer + recon_uvoffset ; target_v = cpi -> denoiser . yv12_running_avg [ LAST_FRAME ] . v_buffer + recon_uvoffset ; stride_uv = cpi -> denoiser . yv12_running_avg [ LAST_FRAME ] . uv_stride ; } } # endif dot_artifact_candidate = check_dot_artifact_candidate ( cpi , x , target_y , stride , plane [ LAST_FRAME ] [ 0 ] , mb_row , mb_col , 0 ) ; if ( ! dot_artifact_candidate ) { dot_artifact_candidate = check_dot_artifact_candidate ( cpi , x , target_u , stride_uv , plane [ LAST_FRAME ] [ 1 ] , mb_row , mb_col , 1 ) ; if ( ! dot_artifact_candidate ) { dot_artifact_candidate = check_dot_artifact_candidate ( cpi , x , target_v , stride_uv , plane [ LAST_FRAME ] [ 2 ] , mb_row , mb_col , 2 ) ; } } } # if CONFIG_MULTI_RES_ENCODING <S2SV_ModEnd> parent_ref_valid = cpi <S2SV_ModStart> cpi -> mr_low_res_mv_avail <S2SV_ModEnd> ; if ( <S2SV_ModStart> ref_frame_flags & VP8_GOLD_FRAME <S2SV_ModEnd> ) ; if <S2SV_ModStart> = 0 ; if ( dot_artifact_candidate ) parent_ref_valid = 0 ; <S2SV_ModStart> } # endif { const int y = x -> src . y_buffer [ 7 * x -> src . y_stride + 7 ] ; const int cb = x -> src . u_buffer [ 3 * x -> src . uv_stride + 3 ] ; const int cr = x -> src . v_buffer [ 3 * x -> src . uv_stride + 3 ] ; x -> is_skin = 0 ; if ( ! cpi -> oxcf . screen_content_mode ) x -> is_skin = is_skin_color ( y , cb , cr ) ; } # if CONFIG_TEMPORAL_DENOISING if ( cpi -> oxcf . noise_sensitivity ) { } # endif <S2SV_ModStart> = 0 ; memset <S2SV_ModEnd> ( mode_mv_sb , <S2SV_ModStart> ) ) ; memset <S2SV_ModEnd> ( & best_mbmode <S2SV_ModStart> as_int ; } <S2SV_ModEnd> x -> mbs_tested_so_far <S2SV_ModStart> = INTRA_FRAME ; if ( cpi -> Speed < 12 ) { <S2SV_ModStart> rd_adjustment ) ; } # if CONFIG_TEMPORAL_DENOISING if ( cpi -> oxcf . noise_sensitivity ) { rd_adjustment = ( int ) ( rd_adjustment * cpi -> denoiser . denoise_pars . pickmode_mv_bias / 100 ) ; } # endif if ( dot_artifact_candidate ) { rd_adjustment = 150 ; } <S2SV_ModStart> ; distortion2 = vpx_variance16x16 <S2SV_ModEnd> ( * ( <S2SV_ModStart> ; distortion2 = vpx_variance16x16 <S2SV_ModEnd> ( * ( <S2SV_ModStart> oxcf . mr_encoder_id <S2SV_ModEnd> ) sf_improved_mv_pred = <S2SV_ModStart> ( parent_ref_valid && ( parent_ref_frame == this_ref_frame ) <S2SV_ModEnd> ) { mvp <S2SV_ModStart> ( parent_ref_valid && ( parent_ref_frame == this_ref_frame ) <S2SV_ModEnd> && dissim <= <S2SV_ModStart> ( ! parent_ref_valid || ( parent_ref_frame != this_ref_frame ) <S2SV_ModStart> . as_int ; vp8_clamp_mv2 ( & mode_mv [ this_mode ] , xd ) ; <S2SV_ModStart> noise_sensitivity ) { int skip_old_reference = ( ( this_ref_frame != LAST_FRAME ) && ( cpi -> common . current_video_frame - cpi -> current_ref_frames [ this_ref_frame ] > MAX_GF_ARF_DENOISE_RANGE ) ) ? 1 : 0 ; <S2SV_ModStart> sse < zero_mv_sse && ! skip_old_reference <S2SV_ModStart> sse < best_sse && ! skip_old_reference <S2SV_ModStart> = this_rd ; memcpy <S2SV_ModEnd> ( & best_mbmode <S2SV_ModStart> noise_sensitivity ) { int block_index = mb_row * cpi -> common . mb_cols + mb_col ; int reevaluate = 0 ; int is_noisy = 0 ; <S2SV_ModStart> best_rd_sse ; } if ( cpi -> oxcf . noise_sensitivity == 4 ) { if ( cpi -> denoiser . nmse_source_diff > 70 * cpi -> denoiser . threshold_aggressive_mode / 100 ) is_noisy = 1 ; } else { if ( cpi -> mse_source_denoised > 1000 ) is_noisy = 1 ; } x -> increase_denoising = 0 ; if ( ! x -> is_skin && x -> best_sse_inter_mode == ZEROMV && ( x -> best_reference_frame == LAST_FRAME || x -> best_reference_frame == cpi -> closest_reference_frame ) && cpi -> consec_zero_last [ block_index ] >= 20 && is_noisy ) { x -> increase_denoising = 1 ; } x -> denoise_zeromv = 0 ; <S2SV_ModStart> recon_yoffset , recon_uvoffset , & cpi -> common . lf_info , mb_row , mb_col , block_index ) ; reevaluate = <S2SV_ModEnd> ( best_mbmode . <S2SV_ModStart> ref_frame == INTRA_FRAME ) || ( best_mbmode . mode != ZEROMV && x -> denoise_zeromv && cpi -> mse_source_denoised > 2000 ) ; if ( ! dot_artifact_candidate && reevaluate <S2SV_ModStart> -> best_zeromv_reference_frame ; rd_adjustment = 100 ; <S2SV_ModStart> best_rd ) { memcpy <S2SV_ModEnd> ( & best_mbmode <S2SV_ModStart> -> skip ) memcpy <S2SV_ModEnd> ( & x"
582,"static int tun_set_iff ( struct net * net , struct file * file , struct ifreq * ifr ) { struct tun_struct * tun ; struct tun_file * tfile = file -> private_data ; struct net_device * dev ; int err ; if ( tfile -> detached ) return - EINVAL ; dev = __dev_get_by_name ( net , ifr -> ifr_name ) ; if ( dev ) { if ( ifr -> ifr_flags & IFF_TUN_EXCL ) return - EBUSY ; if ( ( ifr -> ifr_flags & IFF_TUN ) && dev -> netdev_ops == & tun_netdev_ops ) tun = netdev_priv ( dev ) ; else if ( ( ifr -> ifr_flags & IFF_TAP ) && dev -> netdev_ops == & tap_netdev_ops ) tun = netdev_priv ( dev ) ; else return - EINVAL ; if ( ! ! ( ifr -> ifr_flags & IFF_MULTI_QUEUE ) != ! ! ( tun -> flags & IFF_MULTI_QUEUE ) ) return - EINVAL ; if ( tun_not_capable ( tun ) ) return - EPERM ; err = security_tun_dev_open ( tun -> security ) ; if ( err < 0 ) return err ; err = tun_attach ( tun , file , ifr -> ifr_flags & IFF_NOFILTER ) ; if ( err < 0 ) return err ; if ( tun -> flags & IFF_MULTI_QUEUE && ( tun -> numqueues + tun -> numdisabled > 1 ) ) { return 0 ; } } else { char * name ; unsigned long flags = 0 ; int queues = ifr -> ifr_flags & IFF_MULTI_QUEUE ? MAX_TAP_QUEUES : 1 ; if ( ! ns_capable ( net -> user_ns , CAP_NET_ADMIN ) ) return - EPERM ; err = security_tun_dev_create ( ) ; if ( err < 0 ) return err ; if ( ifr -> ifr_flags & IFF_TUN ) { flags |= IFF_TUN ; name = ""tun%d"" ; } else if ( ifr -> ifr_flags & IFF_TAP ) { flags |= IFF_TAP ; name = ""tap%d"" ; } else return - EINVAL ; if ( * ifr -> ifr_name ) name = ifr -> ifr_name ; dev = alloc_netdev_mqs ( sizeof ( struct tun_struct ) , name , NET_NAME_UNKNOWN , tun_setup , queues , queues ) ; if ( ! dev ) return - ENOMEM ; err = dev_get_valid_name ( net , dev , name ) ; <S2SV_StartBug> if ( err ) <S2SV_EndBug> goto err_free_dev ; dev_net_set ( dev , net ) ; dev -> rtnl_link_ops = & tun_link_ops ; dev -> ifindex = tfile -> ifindex ; dev -> sysfs_groups [ 0 ] = & tun_attr_group ; tun = netdev_priv ( dev ) ; tun -> dev = dev ; tun -> flags = flags ; tun -> txflt . count = 0 ; tun -> vnet_hdr_sz = sizeof ( struct virtio_net_hdr ) ; tun -> align = NET_SKB_PAD ; tun -> filter_attached = false ; tun -> sndbuf = tfile -> socket . sk -> sk_sndbuf ; tun -> rx_batched = 0 ; tun -> pcpu_stats = netdev_alloc_pcpu_stats ( struct tun_pcpu_stats ) ; if ( ! tun -> pcpu_stats ) { err = - ENOMEM ; goto err_free_dev ; } spin_lock_init ( & tun -> lock ) ; err = security_tun_dev_alloc_security ( & tun -> security ) ; if ( err < 0 ) goto err_free_stat ; tun_net_init ( dev ) ; tun_flow_init ( tun ) ; dev -> hw_features = NETIF_F_SG | NETIF_F_FRAGLIST | TUN_USER_FEATURES | NETIF_F_HW_VLAN_CTAG_TX | NETIF_F_HW_VLAN_STAG_TX ; dev -> features = dev -> hw_features | NETIF_F_LLTX ; dev -> vlan_features = dev -> features & ~ ( NETIF_F_HW_VLAN_CTAG_TX | NETIF_F_HW_VLAN_STAG_TX ) ; INIT_LIST_HEAD ( & tun -> disabled ) ; err = tun_attach ( tun , file , false ) ; if ( err < 0 ) goto err_free_flow ; err = register_netdevice ( tun -> dev ) ; if ( err < 0 ) goto err_detach ; } netif_carrier_on ( tun -> dev ) ; tun_debug ( KERN_INFO , tun , ""tun_set_iff\\n"" ) ; tun -> flags = ( tun -> flags & ~ TUN_FEATURES ) | ( ifr -> ifr_flags & TUN_FEATURES ) ; if ( netif_running ( tun -> dev ) ) netif_tx_wake_all_queues ( tun -> dev ) ; strcpy ( ifr -> ifr_name , tun -> dev -> name ) ; return 0 ; err_detach : tun_detach_all ( dev ) ; goto err_free_dev ; err_free_flow : tun_flow_uninit ( tun ) ; security_tun_dev_free_security ( tun -> security ) ; err_free_stat : free_percpu ( tun -> pcpu_stats ) ; err_free_dev : free_netdev ( dev ) ; return err ; }",if ( err < 0
583,"static struct page * follow_page_pte ( struct vm_area_struct * vma , unsigned long address , pmd_t * pmd , unsigned int flags , struct dev_pagemap * * pgmap ) { struct mm_struct * mm = vma -> vm_mm ; struct page * page ; spinlock_t * ptl ; pte_t * ptep , pte ; retry : if ( unlikely ( pmd_bad ( * pmd ) ) ) return no_page_table ( vma , flags ) ; ptep = pte_offset_map_lock ( mm , pmd , address , & ptl ) ; pte = * ptep ; if ( ! pte_present ( pte ) ) { swp_entry_t entry ; if ( likely ( ! ( flags & FOLL_MIGRATION ) ) ) goto no_page ; if ( pte_none ( pte ) ) goto no_page ; entry = pte_to_swp_entry ( pte ) ; if ( ! is_migration_entry ( entry ) ) goto no_page ; pte_unmap_unlock ( ptep , ptl ) ; migration_entry_wait ( mm , pmd , address ) ; goto retry ; } if ( ( flags & FOLL_NUMA ) && pte_protnone ( pte ) ) goto no_page ; if ( ( flags & FOLL_WRITE ) && ! can_follow_write_pte ( pte , flags ) ) { pte_unmap_unlock ( ptep , ptl ) ; return NULL ; } page = vm_normal_page ( vma , address , pte ) ; if ( ! page && pte_devmap ( pte ) && ( flags & FOLL_GET ) ) { * pgmap = get_dev_pagemap ( pte_pfn ( pte ) , * pgmap ) ; if ( * pgmap ) page = pte_page ( pte ) ; else goto no_page ; } else if ( unlikely ( ! page ) ) { if ( flags & FOLL_DUMP ) { page = ERR_PTR ( - EFAULT ) ; goto out ; } if ( is_zero_pfn ( pte_pfn ( pte ) ) ) { page = pte_page ( pte ) ; } else { int ret ; ret = follow_pfn_pte ( vma , address , ptep , flags ) ; page = ERR_PTR ( ret ) ; goto out ; } } if ( flags & FOLL_SPLIT && PageTransCompound ( page ) ) { int ret ; get_page ( page ) ; pte_unmap_unlock ( ptep , ptl ) ; lock_page ( page ) ; ret = split_huge_page ( page ) ; unlock_page ( page ) ; put_page ( page ) ; if ( ret ) return ERR_PTR ( ret ) ; goto retry ; } if ( flags & FOLL_GET ) <S2SV_StartBug> get_page ( page ) ; <S2SV_EndBug> if ( flags & FOLL_TOUCH ) { if ( ( flags & FOLL_WRITE ) && ! pte_dirty ( pte ) && ! PageDirty ( page ) ) set_page_dirty ( page ) ; mark_page_accessed ( page ) ; } if ( ( flags & FOLL_MLOCK ) && ( vma -> vm_flags & VM_LOCKED ) ) { if ( PageTransCompound ( page ) ) goto out ; if ( page -> mapping && trylock_page ( page ) ) { lru_add_drain ( ) ; mlock_vma_page ( page ) ; unlock_page ( page ) ; } } out : pte_unmap_unlock ( ptep , ptl ) ; return page ; no_page : pte_unmap_unlock ( ptep , ptl ) ; if ( ! pte_none ( pte ) ) return NULL ; return no_page_table ( vma , flags ) ; }",& FOLL_GET ) { if ( unlikely ( ! try_get_page ( page ) ) ) { page = ERR_PTR ( - ENOMEM ) ; goto out ; } } <S2SV_ModEnd> if ( flags
584,"void vp9_rc_compute_frame_size_bounds ( const VP9_COMP * cpi , <S2SV_StartBug> int this_frame_target , <S2SV_EndBug> int * frame_under_shoot_limit , int * frame_over_shoot_limit ) { <S2SV_StartBug> if ( cpi -> oxcf . end_usage == USAGE_CONSTANT_QUALITY ) { <S2SV_EndBug> * frame_under_shoot_limit = 0 ; * frame_over_shoot_limit = INT_MAX ; } else { <S2SV_StartBug> int recode_tolerance = <S2SV_EndBug> <S2SV_StartBug> ( cpi -> sf . recode_tolerance * this_frame_target ) / 100 ; <S2SV_EndBug> <S2SV_StartBug> * frame_over_shoot_limit = this_frame_target + recode_tolerance ; <S2SV_EndBug> * frame_under_shoot_limit = this_frame_target - recode_tolerance ; <S2SV_StartBug> * frame_over_shoot_limit += 200 ; <S2SV_EndBug> * frame_under_shoot_limit -= 200 ; if ( * frame_under_shoot_limit < 0 ) * frame_under_shoot_limit = 0 ; <S2SV_StartBug> if ( * frame_over_shoot_limit > cpi -> rc . max_frame_bandwidth ) { <S2SV_EndBug> * frame_over_shoot_limit = cpi -> rc . max_frame_bandwidth ; } } <S2SV_StartBug> } <S2SV_EndBug>","cpi , int frame_target <S2SV_ModEnd> , int * <S2SV_ModStart> -> oxcf . rc_mode == VPX_Q <S2SV_ModEnd> ) { * <S2SV_ModStart> } else { const int tolerance <S2SV_ModEnd> = ( cpi <S2SV_ModStart> . recode_tolerance * frame_target <S2SV_ModEnd> ) / 100 <S2SV_ModStart> 100 ; * frame_under_shoot_limit = MAX ( frame_target - tolerance - 200 , 0 ) <S2SV_ModEnd> ; * frame_over_shoot_limit <S2SV_ModStart> ; * frame_over_shoot_limit = MIN ( frame_target + tolerance + 200 , <S2SV_ModEnd> cpi -> rc <S2SV_ModStart> . max_frame_bandwidth ) <S2SV_ModEnd> ; } } <S2SV_ModStart> ; } } <S2SV_ModEnd> <S2SV_null> <S2SV_null> <S2SV_null>"
585,"int sc_pkcs15_decode_prkdf_entry ( struct sc_pkcs15_card * p15card , struct sc_pkcs15_object * obj , const u8 * * buf , size_t * buflen ) { sc_context_t * ctx = p15card -> card -> ctx ; struct sc_pkcs15_prkey_info info ; int r , i , gostr3410_params [ 3 ] ; struct sc_pkcs15_keyinfo_gostparams * keyinfo_gostparams ; size_t usage_len = sizeof ( info . usage ) ; size_t af_len = sizeof ( info . access_flags ) ; struct sc_asn1_entry asn1_com_key_attr [ C_ASN1_COM_KEY_ATTR_SIZE ] ; struct sc_asn1_entry asn1_com_prkey_attr [ C_ASN1_COM_PRKEY_ATTR_SIZE ] ; struct sc_asn1_entry asn1_rsakey_attr [ C_ASN1_RSAKEY_ATTR_SIZE ] ; struct sc_asn1_entry asn1_prk_rsa_attr [ C_ASN1_PRK_RSA_ATTR_SIZE ] ; struct sc_asn1_entry asn1_dsakey_attr [ C_ASN1_DSAKEY_ATTR_SIZE ] ; struct sc_asn1_entry asn1_prk_dsa_attr [ C_ASN1_PRK_DSA_ATTR_SIZE ] ; struct sc_asn1_entry asn1_dsakey_i_p_attr [ C_ASN1_DSAKEY_I_P_ATTR_SIZE ] ; struct sc_asn1_entry asn1_dsakey_value_attr [ C_ASN1_DSAKEY_VALUE_ATTR_SIZE ] ; struct sc_asn1_entry asn1_gostr3410key_attr [ C_ASN1_GOSTR3410KEY_ATTR_SIZE ] ; struct sc_asn1_entry asn1_prk_gostr3410_attr [ C_ASN1_PRK_GOSTR3410_ATTR_SIZE ] ; struct sc_asn1_entry asn1_ecckey_attr [ C_ASN1_ECCKEY_ATTR ] ; struct sc_asn1_entry asn1_prk_ecc_attr [ C_ASN1_PRK_ECC_ATTR ] ; struct sc_asn1_entry asn1_prkey [ C_ASN1_PRKEY_SIZE ] ; struct sc_asn1_entry asn1_supported_algorithms [ C_ASN1_SUPPORTED_ALGORITHMS_SIZE ] ; struct sc_asn1_pkcs15_object rsa_prkey_obj = { obj , asn1_com_key_attr , asn1_com_prkey_attr , asn1_prk_rsa_attr } ; struct sc_asn1_pkcs15_object dsa_prkey_obj = { obj , asn1_com_key_attr , asn1_com_prkey_attr , asn1_prk_dsa_attr } ; struct sc_asn1_pkcs15_object gostr3410_prkey_obj = { obj , asn1_com_key_attr , asn1_com_prkey_attr , asn1_prk_gostr3410_attr } ; struct sc_asn1_pkcs15_object ecc_prkey_obj = { obj , asn1_com_key_attr , asn1_com_prkey_attr , asn1_prk_ecc_attr } ; sc_copy_asn1_entry ( c_asn1_prkey , asn1_prkey ) ; sc_copy_asn1_entry ( c_asn1_supported_algorithms , asn1_supported_algorithms ) ; sc_copy_asn1_entry ( c_asn1_prk_rsa_attr , asn1_prk_rsa_attr ) ; sc_copy_asn1_entry ( c_asn1_rsakey_attr , asn1_rsakey_attr ) ; sc_copy_asn1_entry ( c_asn1_prk_dsa_attr , asn1_prk_dsa_attr ) ; sc_copy_asn1_entry ( c_asn1_dsakey_attr , asn1_dsakey_attr ) ; sc_copy_asn1_entry ( c_asn1_dsakey_value_attr , asn1_dsakey_value_attr ) ; sc_copy_asn1_entry ( c_asn1_dsakey_i_p_attr , asn1_dsakey_i_p_attr ) ; sc_copy_asn1_entry ( c_asn1_prk_gostr3410_attr , asn1_prk_gostr3410_attr ) ; sc_copy_asn1_entry ( c_asn1_gostr3410key_attr , asn1_gostr3410key_attr ) ; sc_copy_asn1_entry ( c_asn1_prk_ecc_attr , asn1_prk_ecc_attr ) ; sc_copy_asn1_entry ( c_asn1_ecckey_attr , asn1_ecckey_attr ) ; sc_copy_asn1_entry ( c_asn1_com_prkey_attr , asn1_com_prkey_attr ) ; sc_copy_asn1_entry ( c_asn1_com_key_attr , asn1_com_key_attr ) ; sc_format_asn1_entry ( asn1_prkey + 0 , & rsa_prkey_obj , NULL , 0 ) ; sc_format_asn1_entry ( asn1_prkey + 1 , & ecc_prkey_obj , NULL , 0 ) ; sc_format_asn1_entry ( asn1_prkey + 2 , & dsa_prkey_obj , NULL , 0 ) ; sc_format_asn1_entry ( asn1_prkey + 3 , & gostr3410_prkey_obj , NULL , 0 ) ; sc_format_asn1_entry ( asn1_prk_rsa_attr + 0 , asn1_rsakey_attr , NULL , 0 ) ; sc_format_asn1_entry ( asn1_prk_dsa_attr + 0 , asn1_dsakey_attr , NULL , 0 ) ; sc_format_asn1_entry ( asn1_prk_gostr3410_attr + 0 , asn1_gostr3410key_attr , NULL , 0 ) ; sc_format_asn1_entry ( asn1_prk_ecc_attr + 0 , asn1_ecckey_attr , NULL , 0 ) ; sc_format_asn1_entry ( asn1_rsakey_attr + 0 , & info . path , NULL , 0 ) ; sc_format_asn1_entry ( asn1_rsakey_attr + 1 , & info . modulus_length , NULL , 0 ) ; sc_format_asn1_entry ( asn1_dsakey_attr + 0 , asn1_dsakey_value_attr , NULL , 0 ) ; sc_format_asn1_entry ( asn1_dsakey_value_attr + 0 , & info . path , NULL , 0 ) ; sc_format_asn1_entry ( asn1_dsakey_value_attr + 1 , asn1_dsakey_i_p_attr , NULL , 0 ) ; sc_format_asn1_entry ( asn1_dsakey_i_p_attr + 0 , & info . path , NULL , 0 ) ; sc_format_asn1_entry ( asn1_gostr3410key_attr + 0 , & info . path , NULL , 0 ) ; sc_format_asn1_entry ( asn1_gostr3410key_attr + 1 , & gostr3410_params [ 0 ] , NULL , 0 ) ; sc_format_asn1_entry ( asn1_gostr3410key_attr + 2 , & gostr3410_params [ 1 ] , NULL , 0 ) ; sc_format_asn1_entry ( asn1_gostr3410key_attr + 3 , & gostr3410_params [ 2 ] , NULL , 0 ) ; sc_format_asn1_entry ( asn1_ecckey_attr + 0 , & info . path , NULL , 0 ) ; sc_format_asn1_entry ( asn1_ecckey_attr + 1 , & info . field_length , NULL , 0 ) ; sc_format_asn1_entry ( asn1_com_key_attr + 0 , & info . id , NULL , 0 ) ; sc_format_asn1_entry ( asn1_com_key_attr + 1 , & info . usage , & usage_len , 0 ) ; sc_format_asn1_entry ( asn1_com_key_attr + 2 , & info . native , NULL , 0 ) ; sc_format_asn1_entry ( asn1_com_key_attr + 3 , & info . access_flags , & af_len , 0 ) ; sc_format_asn1_entry ( asn1_com_key_attr + 4 , & info . key_reference , NULL , 0 ) ; for ( i = 0 ; i < SC_MAX_SUPPORTED_ALGORITHMS && ( asn1_supported_algorithms + i ) -> name ; i ++ ) sc_format_asn1_entry ( asn1_supported_algorithms + i , & info . algo_refs [ i ] , NULL , 0 ) ; sc_format_asn1_entry ( asn1_com_key_attr + 5 , asn1_supported_algorithms , NULL , 0 ) ; sc_format_asn1_entry ( asn1_com_prkey_attr + 0 , & info . subject . value , & info . subject . len , 0 ) ; memset ( & info , 0 , sizeof ( info ) ) ; info . key_reference = - 1 ; info . native = 1 ; memset ( gostr3410_params , 0 , sizeof ( gostr3410_params ) ) ; r = sc_asn1_decode_choice ( ctx , asn1_prkey , * buf , * buflen , buf , buflen ) ; if ( r < 0 ) { <S2SV_StartBug> if ( asn1_com_prkey_attr -> flags & SC_ASN1_PRESENT && <S2SV_EndBug> asn1_com_prkey_attr [ 0 ] . flags & SC_ASN1_PRESENT ) { free ( asn1_com_prkey_attr [ 0 ] . parm ) ; } } if ( r == SC_ERROR_ASN1_END_OF_CONTENTS ) return r ; LOG_TEST_RET ( ctx , r , ""PrKey<S2SV_blank>DF<S2SV_blank>ASN.1<S2SV_blank>decoding<S2SV_blank>failed"" ) ; if ( asn1_prkey [ 0 ] . flags & SC_ASN1_PRESENT ) { obj -> type = SC_PKCS15_TYPE_PRKEY_RSA ; } else if ( asn1_prkey [ 1 ] . flags & SC_ASN1_PRESENT ) { obj -> type = SC_PKCS15_TYPE_PRKEY_EC ; } else if ( asn1_prkey [ 2 ] . flags & SC_ASN1_PRESENT ) { obj -> type = SC_PKCS15_TYPE_PRKEY_DSA ; if ( asn1_dsakey_i_p_attr [ 0 ] . flags & SC_ASN1_PRESENT ) info . path . type = SC_PATH_TYPE_PATH_PROT ; } else if ( asn1_prkey [ 3 ] . flags & SC_ASN1_PRESENT ) { obj -> type = SC_PKCS15_TYPE_PRKEY_GOSTR3410 ; assert ( info . modulus_length == 0 ) ; info . modulus_length = SC_PKCS15_GOSTR3410_KEYSIZE ; assert ( info . params . len == 0 ) ; info . params . len = sizeof ( struct sc_pkcs15_keyinfo_gostparams ) ; info . params . data = malloc ( info . params . len ) ; if ( info . params . data == NULL ) LOG_FUNC_RETURN ( ctx , SC_ERROR_OUT_OF_MEMORY ) ; assert ( sizeof ( * keyinfo_gostparams ) == info . params . len ) ; keyinfo_gostparams = info . params . data ; keyinfo_gostparams -> gostr3410 = gostr3410_params [ 0 ] ; keyinfo_gostparams -> gostr3411 = gostr3410_params [ 1 ] ; keyinfo_gostparams -> gost28147 = gostr3410_params [ 2 ] ; } else { sc_log ( ctx , ""Neither<S2SV_blank>RSA<S2SV_blank>or<S2SV_blank>DSA<S2SV_blank>or<S2SV_blank>GOSTR3410<S2SV_blank>or<S2SV_blank>ECC<S2SV_blank>key<S2SV_blank>in<S2SV_blank>PrKDF<S2SV_blank>entry."" ) ; LOG_FUNC_RETURN ( ctx , SC_ERROR_INVALID_ASN1_OBJECT ) ; } if ( ! p15card -> app || ! p15card -> app -> ddo . aid . len ) { r = sc_pkcs15_make_absolute_path ( & p15card -> file_app -> path , & info . path ) ; if ( r < 0 ) { sc_pkcs15_free_key_params ( & info . params ) ; return r ; } } else { info . path . aid = p15card -> app -> ddo . aid ; } sc_log ( ctx , ""PrivKey<S2SV_blank>path<S2SV_blank>\'%s\'"" , sc_print_path ( & info . path ) ) ; if ( info . key_reference < - 1 ) info . key_reference += 256 ; if ( ( obj -> flags & SC_PKCS15_CO_FLAG_PRIVATE ) && ( obj -> auth_id . len == 0 ) ) { sc_log ( ctx , ""Private<S2SV_blank>key<S2SV_blank>%s<S2SV_blank>has<S2SV_blank>no<S2SV_blank>auth<S2SV_blank>ID<S2SV_blank>-<S2SV_blank>checking<S2SV_blank>AccessControlRules"" , sc_pkcs15_print_id ( & info . id ) ) ; for ( i = 0 ; i < SC_PKCS15_MAX_ACCESS_RULES ; i ++ ) { if ( obj -> access_rules [ i ] . access_mode & ( SC_PKCS15_ACCESS_RULE_MODE_EXECUTE | SC_PKCS15_ACCESS_RULE_MODE_PSO_CDS | SC_PKCS15_ACCESS_RULE_MODE_PSO_DECRYPT | SC_PKCS15_ACCESS_RULE_MODE_INT_AUTH ) ) { if ( obj -> access_rules [ i ] . auth_id . len != 0 ) { obj -> auth_id = obj -> access_rules [ i ] . auth_id ; sc_log ( ctx , ""Auth<S2SV_blank>ID<S2SV_blank>found<S2SV_blank>-<S2SV_blank>%s"" , sc_pkcs15_print_id ( & obj -> auth_id ) ) ; break ; } } } if ( i == SC_PKCS15_MAX_ACCESS_RULES ) sc_log ( ctx , ""Warning:<S2SV_blank>No<S2SV_blank>auth<S2SV_blank>ID<S2SV_blank>found"" ) ; } obj -> data = malloc ( sizeof ( info ) ) ; if ( obj -> data == NULL ) { sc_pkcs15_free_key_params ( & info . params ) ; LOG_FUNC_RETURN ( ctx , SC_ERROR_OUT_OF_MEMORY ) ; } memcpy ( obj -> data , & info , sizeof ( info ) ) ; sc_log ( ctx , ""Key<S2SV_blank>Subject<S2SV_blank>%s"" , sc_dump_hex ( info . subject . value , info . subject . len ) ) ; sc_log ( ctx , ""Key<S2SV_blank>path<S2SV_blank>%s"" , sc_print_path ( & info . path ) ) ; return 0 ; }",0 ) { free ( info . subject . value ) ; <S2SV_ModEnd> } if (
586,"int snd_ctl_add ( struct snd_card * card , struct snd_kcontrol * kcontrol ) { struct snd_ctl_elem_id id ; unsigned int idx ; unsigned int count ; int err = - EINVAL ; if ( ! kcontrol ) return err ; if ( snd_BUG_ON ( ! card || ! kcontrol -> info ) ) goto error ; id = kcontrol -> id ; <S2SV_StartBug> down_write ( & card -> controls_rwsem ) ; <S2SV_EndBug> if ( snd_ctl_find_id ( card , & id ) ) { up_write ( & card -> controls_rwsem ) ; dev_err ( card -> dev , ""control<S2SV_blank>%i:%i:%i:%s:%i<S2SV_blank>is<S2SV_blank>already<S2SV_blank>present\\n"" , id . iface , id . device , id . subdevice , id . name , id . index ) ; err = - EBUSY ; goto error ; } if ( snd_ctl_find_hole ( card , kcontrol -> count ) < 0 ) { up_write ( & card -> controls_rwsem ) ; err = - ENOMEM ; goto error ; } list_add_tail ( & kcontrol -> list , & card -> controls ) ; card -> controls_count += kcontrol -> count ; kcontrol -> id . numid = card -> last_numid + 1 ; card -> last_numid += kcontrol -> count ; count = kcontrol -> count ; up_write ( & card -> controls_rwsem ) ; for ( idx = 0 ; idx < count ; idx ++ , id . index ++ , id . numid ++ ) snd_ctl_notify ( card , SNDRV_CTL_EVENT_MASK_ADD , & id ) ; return 0 ; error : snd_ctl_free_one ( kcontrol ) ; return err ; }",-> id ; if ( id . index > UINT_MAX - kcontrol -> count ) goto error ;
587,"long FS_FOpenFileRead ( const char * filename , fileHandle_t * file , qboolean uniqueFILE ) { searchpath_t * search ; long len ; <S2SV_StartBug> if ( ! fs_searchpaths ) <S2SV_EndBug> Com_Error ( ERR_FATAL , ""Filesystem<S2SV_blank>call<S2SV_blank>made<S2SV_blank>without<S2SV_blank>initialization"" ) ; <S2SV_StartBug> for ( search = fs_searchpaths ; search ; search = search -> next ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> len = FS_FOpenFileReadDir ( filename , search , file , uniqueFILE , qfalse ) ; if ( file == NULL ) { if ( len > 0 ) return len ; } else { if ( len >= 0 && * file ) return len ; } } # ifdef FS_MISSING if ( missingFiles ) fprintf ( missingFiles , ""%s\\n"" , filename ) ; # endif if ( file ) { * file = 0 ; return - 1 ; } else { return 0 ; } }","long len ; qboolean isLocalConfig ; <S2SV_ModStart> ""Filesystem<S2SV_blank>call<S2SV_blank>made<S2SV_blank>without<S2SV_blank>initialization"" ) ; isLocalConfig = ! strcmp ( filename , ""autoexec.cfg"" ) || ! strcmp ( filename , Q3CONFIG_CFG ) ; <S2SV_ModStart> next ) { if ( isLocalConfig && search -> pack ) continue ;"
588,"<S2SV_StartBug> void usage_exit ( ) { <S2SV_EndBug> fprintf ( stderr , ""Usage:<S2SV_blank>%s<S2SV_blank><codec><S2SV_blank><width><S2SV_blank><height><S2SV_blank><infile><S2SV_blank><outfile>\\n"" , exec_name ) ; exit ( EXIT_FAILURE ) ; }",void usage_exit ( void
589,"static arg_ty ast_for_arg ( struct compiling * c , const node * n ) { identifier name ; expr_ty annotation = NULL ; node * ch ; arg_ty ret ; assert ( TYPE ( n ) == tfpdef || TYPE ( n ) == vfpdef ) ; ch = CHILD ( n , 0 ) ; name = NEW_IDENTIFIER ( ch ) ; if ( ! name ) return NULL ; if ( forbidden_name ( c , name , ch , 0 ) ) return NULL ; if ( NCH ( n ) == 3 && TYPE ( CHILD ( n , 1 ) ) == COLON ) { annotation = ast_for_expr ( c , CHILD ( n , 2 ) ) ; if ( ! annotation ) return NULL ; } <S2SV_StartBug> ret = arg ( name , annotation , LINENO ( n ) , n -> n_col_offset , <S2SV_EndBug> n -> n_end_lineno , n -> n_end_col_offset , c -> c_arena ) ; if ( ! ret ) return NULL ; return ret ; }",", annotation , NULL ,"
590,"static gboolean export_desktop_file ( const char * app , const char * branch , const char * arch , GKeyFile * metadata , const char * const * previous_ids , int parent_fd , const char * name , struct stat * stat_buf , char * * target , GCancellable * cancellable , GError * * error ) { gboolean ret = FALSE ; glnx_autofd int desktop_fd = - 1 ; g_autofree char * tmpfile_name = g_strdup_printf ( ""export-desktop-XXXXXX"" ) ; g_autoptr ( GOutputStream ) out_stream = NULL ; g_autofree gchar * data = NULL ; gsize data_len ; g_autofree gchar * new_data = NULL ; gsize new_data_len ; g_autoptr ( GKeyFile ) keyfile = NULL ; g_autofree gchar * old_exec = NULL ; gint old_argc ; g_auto ( GStrv ) old_argv = NULL ; g_auto ( GStrv ) groups = NULL ; GString * new_exec = NULL ; g_autofree char * escaped_app = maybe_quote ( app ) ; g_autofree char * escaped_branch = maybe_quote ( branch ) ; g_autofree char * escaped_arch = maybe_quote ( arch ) ; int i ; if ( ! flatpak_openat_noatime ( parent_fd , name , & desktop_fd , cancellable , error ) ) goto out ; if ( ! read_fd ( desktop_fd , stat_buf , & data , & data_len , error ) ) goto out ; keyfile = g_key_file_new ( ) ; if ( ! g_key_file_load_from_data ( keyfile , data , data_len , G_KEY_FILE_KEEP_TRANSLATIONS , error ) ) goto out ; if ( g_str_has_suffix ( name , "".service"" ) ) { g_autofree gchar * dbus_name = NULL ; g_autofree gchar * expected_dbus_name = g_strndup ( name , strlen ( name ) - strlen ( "".service"" ) ) ; dbus_name = g_key_file_get_string ( keyfile , ""D-BUS<S2SV_blank>Service"" , ""Name"" , NULL ) ; if ( dbus_name == NULL || strcmp ( dbus_name , expected_dbus_name ) != 0 ) { return flatpak_fail_error ( error , FLATPAK_ERROR_EXPORT_FAILED , _ ( ""D-Bus<S2SV_blank>service<S2SV_blank>file<S2SV_blank>\'%s\'<S2SV_blank>has<S2SV_blank>wrong<S2SV_blank>name"" ) , name ) ; } } if ( g_str_has_suffix ( name , "".desktop"" ) ) { gsize length ; g_auto ( GStrv ) tags = g_key_file_get_string_list ( metadata , ""Application"" , ""tags"" , & length , NULL ) ; if ( tags != NULL ) { g_key_file_set_string_list ( keyfile , G_KEY_FILE_DESKTOP_GROUP , ""X-Flatpak-Tags"" , ( const char * const * ) tags , length ) ; } g_key_file_set_string ( keyfile , G_KEY_FILE_DESKTOP_GROUP , ""X-Flatpak"" , app ) ; if ( previous_ids != NULL ) { const char * X_FLATPAK_RENAMED_FROM = ""X-Flatpak-RenamedFrom"" ; g_auto ( GStrv ) renamed_from = g_key_file_get_string_list ( keyfile , G_KEY_FILE_DESKTOP_GROUP , X_FLATPAK_RENAMED_FROM , NULL , NULL ) ; g_autoptr ( GPtrArray ) merged = g_ptr_array_new_with_free_func ( g_free ) ; g_autoptr ( GHashTable ) seen = g_hash_table_new ( g_str_hash , g_str_equal ) ; const char * new_suffix ; for ( i = 0 ; renamed_from != NULL && renamed_from [ i ] != NULL ; i ++ ) { if ( ! g_hash_table_contains ( seen , renamed_from [ i ] ) ) { gchar * copy = g_strdup ( renamed_from [ i ] ) ; g_hash_table_insert ( seen , copy , copy ) ; g_ptr_array_add ( merged , g_steal_pointer ( & copy ) ) ; } } g_assert ( g_str_has_prefix ( name , app ) ) ; new_suffix = name + strlen ( app ) ; for ( i = 0 ; previous_ids [ i ] != NULL ; i ++ ) { g_autofree gchar * previous_desktop = g_strconcat ( previous_ids [ i ] , new_suffix , NULL ) ; if ( ! g_hash_table_contains ( seen , previous_desktop ) ) { g_hash_table_insert ( seen , previous_desktop , previous_desktop ) ; g_ptr_array_add ( merged , g_steal_pointer ( & previous_desktop ) ) ; } } if ( merged -> len > 0 ) { g_ptr_array_add ( merged , NULL ) ; g_key_file_set_string_list ( keyfile , G_KEY_FILE_DESKTOP_GROUP , X_FLATPAK_RENAMED_FROM , ( const char * const * ) merged -> pdata , merged -> len - 1 ) ; } } } groups = g_key_file_get_groups ( keyfile , NULL ) ; for ( i = 0 ; groups [ i ] != NULL ; i ++ ) { g_auto ( GStrv ) flatpak_run_opts = g_key_file_get_string_list ( keyfile , groups [ i ] , ""X-Flatpak-RunOptions"" , NULL , NULL ) ; g_autofree char * flatpak_run_args = format_flatpak_run_args_from_run_opts ( flatpak_run_opts ) ; g_key_file_remove_key ( keyfile , groups [ i ] , ""X-Flatpak-RunOptions"" , NULL ) ; g_key_file_remove_key ( keyfile , groups [ i ] , ""TryExec"" , NULL ) ; g_key_file_remove_key ( keyfile , groups [ i ] , ""X-GNOME-Bugzilla-ExtraInfoScript"" , NULL ) ; new_exec = g_string_new ( """" ) ; g_string_append_printf ( new_exec , FLATPAK_BINDIR ""/flatpak<S2SV_blank>run<S2SV_blank>--branch=%s<S2SV_blank>--arch=%s"" , escaped_branch , escaped_arch ) ; if ( flatpak_run_args != NULL ) g_string_append_printf ( new_exec , ""%s"" , flatpak_run_args ) ; old_exec = g_key_file_get_string ( keyfile , groups [ i ] , ""Exec"" , NULL ) ; if ( old_exec && g_shell_parse_argv ( old_exec , & old_argc , & old_argv , NULL ) && old_argc >= 1 ) { int j ; g_autofree char * command = maybe_quote ( old_argv [ 0 ] ) ; g_string_append_printf ( new_exec , ""<S2SV_blank>--command=%s"" , command ) ; for ( j = 1 ; j < old_argc ; j ++ ) { if ( strcasecmp ( old_argv [ j ] , ""%f"" ) == 0 || strcasecmp ( old_argv [ j ] , ""%u"" ) == 0 ) { g_string_append ( new_exec , ""<S2SV_blank>--file-forwarding"" ) ; break ; } } g_string_append ( new_exec , ""<S2SV_blank>"" ) ; g_string_append ( new_exec , escaped_app ) ; for ( j = 1 ; j < old_argc ; j ++ ) { g_autofree char * arg = maybe_quote ( old_argv [ j ] ) ; if ( strcasecmp ( arg , ""%f"" ) == 0 ) g_string_append_printf ( new_exec , ""<S2SV_blank>@@<S2SV_blank>%s<S2SV_blank>@@"" , arg ) ; else if ( strcasecmp ( arg , ""%u"" ) == 0 ) g_string_append_printf ( new_exec , ""<S2SV_blank>@@u<S2SV_blank>%s<S2SV_blank>@@"" , arg ) ; <S2SV_StartBug> else if ( strcmp ( arg , ""@@"" ) == 0 || strcmp ( arg , ""@@u"" ) == 0 ) <S2SV_EndBug> g_print ( _ ( ""Skipping<S2SV_blank>invalid<S2SV_blank>Exec<S2SV_blank>argument<S2SV_blank>%s\\n"" ) , arg ) ; else g_string_append_printf ( new_exec , ""<S2SV_blank>%s"" , arg ) ; } } else { g_string_append ( new_exec , ""<S2SV_blank>"" ) ; g_string_append ( new_exec , escaped_app ) ; } g_key_file_set_string ( keyfile , groups [ i ] , G_KEY_FILE_DESKTOP_KEY_EXEC , new_exec -> str ) ; } new_data = g_key_file_to_data ( keyfile , & new_data_len , error ) ; if ( new_data == NULL ) goto out ; if ( ! flatpak_open_in_tmpdir_at ( parent_fd , 0755 , tmpfile_name , & out_stream , cancellable , error ) ) goto out ; if ( ! g_output_stream_write_all ( out_stream , new_data , new_data_len , NULL , cancellable , error ) ) goto out ; if ( ! g_output_stream_close ( out_stream , cancellable , error ) ) goto out ; if ( target ) * target = g_steal_pointer ( & tmpfile_name ) ; ret = TRUE ; out : if ( new_exec != NULL ) g_string_free ( new_exec , TRUE ) ; return ret ; }","else if ( g_str_has_prefix <S2SV_ModEnd> ( arg , <S2SV_ModStart> , ""@@"" ) <S2SV_ModEnd> ) g_print ("
591,"void vp9_update_spatial_layer_framerate ( VP9_COMP * const cpi , double framerate ) { <S2SV_StartBug> const VP9_CONFIG * const oxcf = & cpi -> oxcf ; <S2SV_EndBug> <S2SV_StartBug> LAYER_CONTEXT * const lc = get_layer_context ( & cpi -> svc ) ; <S2SV_EndBug> RATE_CONTROL * const lrc = & lc -> rc ; lc -> framerate = framerate ; <S2SV_StartBug> lrc -> av_per_frame_bandwidth = ( int ) ( lc -> target_bandwidth / lc -> framerate ) ; <S2SV_EndBug> <S2SV_StartBug> lrc -> min_frame_bandwidth = ( int ) ( lrc -> av_per_frame_bandwidth * <S2SV_EndBug> oxcf -> two_pass_vbrmin_section / 100 ) ; <S2SV_StartBug> lrc -> max_frame_bandwidth = ( int ) ( ( ( int64_t ) lrc -> av_per_frame_bandwidth * <S2SV_EndBug> oxcf -> two_pass_vbrmax_section ) / 100 ) ; <S2SV_StartBug> lrc -> max_gf_interval = 16 ; <S2SV_EndBug> lrc -> static_scene_max_gf_interval = cpi -> key_frame_frequency >> 1 ; if ( oxcf -> play_alternate && oxcf -> lag_in_frames ) { if ( lrc -> max_gf_interval > oxcf -> lag_in_frames - 1 ) lrc -> max_gf_interval = oxcf -> lag_in_frames - 1 ; if ( lrc -> static_scene_max_gf_interval > oxcf -> lag_in_frames - 1 ) lrc -> static_scene_max_gf_interval = oxcf -> lag_in_frames - 1 ; } if ( lrc -> max_gf_interval > lrc -> static_scene_max_gf_interval ) lrc -> max_gf_interval = lrc -> static_scene_max_gf_interval ; }",") { const VP9EncoderConfig <S2SV_ModEnd> * const oxcf <S2SV_ModStart> = get_layer_context ( cpi <S2SV_ModEnd> ) ; RATE_CONTROL <S2SV_ModStart> ; lrc -> avg_frame_bandwidth <S2SV_ModEnd> = ( int <S2SV_ModStart> ( lrc -> avg_frame_bandwidth <S2SV_ModEnd> * oxcf -> <S2SV_ModStart> ) lrc -> avg_frame_bandwidth <S2SV_ModEnd> * oxcf -> <S2SV_ModStart> 100 ) ; vp9_rc_set_gf_interval_range ( cpi , lrc ) <S2SV_ModEnd> ; } <S2SV_null>"
592,"void choose_windows ( s ) const char * s ; { <S2SV_StartBug> register int i ; <S2SV_EndBug> for ( i = 0 ; winchoices [ i ] . procs ; i ++ ) { if ( '+' == winchoices [ i ] . procs -> name [ 0 ] ) continue ; if ( '-' == winchoices [ i ] . procs -> name [ 0 ] ) continue ; if ( ! strcmpi ( s , winchoices [ i ] . procs -> name ) ) { windowprocs = * winchoices [ i ] . procs ; if ( last_winchoice && last_winchoice -> ini_routine ) ( * last_winchoice -> ini_routine ) ( WININIT_UNDO ) ; if ( winchoices [ i ] . ini_routine ) ( * winchoices [ i ] . ini_routine ) ( WININIT ) ; last_winchoice = & winchoices [ i ] ; return ; } } if ( ! windowprocs . win_raw_print ) windowprocs . win_raw_print = def_raw_print ; if ( ! windowprocs . win_wait_synch ) windowprocs . win_wait_synch = def_wait_synch ; if ( ! winchoices [ 0 ] . procs ) { <S2SV_StartBug> raw_printf ( ""No<S2SV_blank>window<S2SV_blank>types?"" ) ; <S2SV_EndBug> nh_terminate ( EXIT_FAILURE ) ; <S2SV_StartBug> } <S2SV_EndBug> if ( ! winchoices [ 1 ] . procs ) { config_error_add ( ""Window<S2SV_blank>type<S2SV_blank>%s<S2SV_blank>not<S2SV_blank>recognized.<S2SV_blank><S2SV_blank>The<S2SV_blank>only<S2SV_blank>choice<S2SV_blank>is:<S2SV_blank>%s"" , s , winchoices [ 0 ] . procs -> name ) ; } else { char buf [ BUFSZ ] ; boolean first = TRUE ; buf [ 0 ] = '\\0' ; for ( i = 0 ; winchoices [ i ] . procs ; i ++ ) { if ( '+' == winchoices [ i ] . procs -> name [ 0 ] ) continue ; if ( '-' == winchoices [ i ] . procs -> name [ 0 ] ) continue ; Sprintf ( eos ( buf ) , ""%s%s"" , first ? """" : "",<S2SV_blank>"" , winchoices [ i ] . procs -> name ) ; first = FALSE ; } config_error_add ( ""Window<S2SV_blank>type<S2SV_blank>%s<S2SV_blank>not<S2SV_blank>recognized.<S2SV_blank><S2SV_blank>Choices<S2SV_blank>are:<S2SV_blank><S2SV_blank>%s"" , s , buf ) ; } <S2SV_StartBug> if ( windowprocs . win_raw_print == def_raw_print <S2SV_EndBug> || WINDOWPORT ( ""safe-startup"" ) ) nh_terminate ( EXIT_SUCCESS ) ; }","s ; { int i ; char * tmps = 0 <S2SV_ModEnd> ; for ( <S2SV_ModStart> { raw_printf ( ""No<S2SV_blank>window<S2SV_blank>types<S2SV_blank>supported?"" <S2SV_ModEnd> ) ; nh_terminate <S2SV_ModStart> ) ; } # define WINDOW_TYPE_MAXLEN 50 if ( strlen ( s ) >= WINDOW_TYPE_MAXLEN ) { tmps = ( char * ) alloc ( WINDOW_TYPE_MAXLEN ) ; ( void ) strncpy ( tmps , s , WINDOW_TYPE_MAXLEN - 1 ) ; tmps [ WINDOW_TYPE_MAXLEN - 1 ] = '\\0' ; s = tmps ; } # undef WINDOW_TYPE_MAXLEN <S2SV_ModStart> } if ( tmps ) free ( ( genericptr_t ) tmps ) ; if ("
593,"IHEVCD_ERROR_T ihevcd_parse_slice_data ( codec_t * ps_codec ) { IHEVCD_ERROR_T ret = ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ; WORD32 end_of_slice_flag ; sps_t * ps_sps ; pps_t * ps_pps ; slice_header_t * ps_slice_hdr ; WORD32 end_of_pic ; tile_t * ps_tile , * ps_tile_prev ; WORD32 i ; WORD32 ctb_addr ; WORD32 tile_idx ; WORD32 cabac_init_idc ; WORD32 ctb_size ; WORD32 num_ctb_in_row ; WORD32 num_min4x4_in_ctb ; WORD32 slice_qp ; WORD32 slice_start_ctb_idx ; WORD32 tile_start_ctb_idx ; ps_slice_hdr = ps_codec -> s_parse . ps_slice_hdr_base ; ps_pps = ps_codec -> s_parse . ps_pps_base ; ps_sps = ps_codec -> s_parse . ps_sps_base ; ps_slice_hdr += ( ps_codec -> s_parse . i4_cur_slice_idx & ( MAX_SLICE_HDR_CNT - 1 ) ) ; ps_pps += ps_slice_hdr -> i1_pps_id ; ps_sps += ps_pps -> i1_sps_id ; if ( 0 != ps_codec -> s_parse . i4_cur_slice_idx ) { if ( ! ps_slice_hdr -> i1_dependent_slice_flag ) { ps_codec -> s_parse . i4_cur_independent_slice_idx = ps_codec -> s_parse . i4_cur_slice_idx & ( MAX_SLICE_HDR_CNT - 1 ) ; } } ctb_size = 1 << ps_sps -> i1_log2_ctb_size ; num_min4x4_in_ctb = ( ctb_size / 4 ) * ( ctb_size / 4 ) ; num_ctb_in_row = ps_sps -> i2_pic_wd_in_ctb ; if ( 0 == ps_codec -> i4_slice_error ) { ps_codec -> s_parse . i4_ctb_x = ps_slice_hdr -> i2_ctb_x ; ps_codec -> s_parse . i4_ctb_y = ps_slice_hdr -> i2_ctb_y ; } ps_codec -> s_parse . ps_pps = ps_pps ; ps_codec -> s_parse . ps_sps = ps_sps ; ps_codec -> s_parse . ps_slice_hdr = ps_slice_hdr ; ihevcd_get_tile_pos ( ps_pps , ps_sps , ps_codec -> s_parse . i4_ctb_x , ps_codec -> s_parse . i4_ctb_y , & ps_codec -> s_parse . i4_ctb_tile_x , & ps_codec -> s_parse . i4_ctb_tile_y , & tile_idx ) ; ps_codec -> s_parse . ps_tile = ps_pps -> ps_tile + tile_idx ; ps_codec -> s_parse . i4_cur_tile_idx = tile_idx ; ps_tile = ps_codec -> s_parse . ps_tile ; if ( tile_idx ) ps_tile_prev = ps_tile - 1 ; else ps_tile_prev = ps_tile ; if ( 0 == ps_codec -> i4_slice_error ) { if ( 1 == ps_slice_hdr -> i1_dependent_slice_flag ) { if ( ( 0 == ps_codec -> s_parse . i4_ctb_tile_x ) && ( 0 == ps_codec -> s_parse . i4_ctb_tile_y ) ) { ps_codec -> s_parse . i4_ctb_slice_x = 0 ; ps_codec -> s_parse . i4_ctb_slice_y = 0 ; } } if ( ! ps_slice_hdr -> i1_dependent_slice_flag ) { ps_codec -> s_parse . i4_ctb_slice_x = 0 ; ps_codec -> s_parse . i4_ctb_slice_y = 0 ; } } if ( ( 0 == ps_codec -> s_parse . i4_ctb_y ) && ( 0 == ps_codec -> s_parse . i4_ctb_x ) ) { ret = ihevcd_parse_pic_init ( ps_codec ) ; RETURN_IF ( ( ret != ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ) , ret ) ; ps_codec -> s_parse . pu4_pic_tu_idx [ 0 ] = 0 ; ps_codec -> s_parse . pu4_pic_pu_idx [ 0 ] = 0 ; ps_codec -> s_parse . i4_cur_independent_slice_idx = 0 ; ps_codec -> s_parse . i4_ctb_tile_x = 0 ; ps_codec -> s_parse . i4_ctb_tile_y = 0 ; } { mv_buf_t * ps_mv_buf = ps_codec -> s_parse . ps_cur_mv_buf ; if ( ps_slice_hdr -> i1_num_ref_idx_l1_active != 0 ) { for ( i = 0 ; i < ps_slice_hdr -> i1_num_ref_idx_l1_active ; i ++ ) { ps_mv_buf -> ai4_l1_collocated_poc [ ( ps_codec -> s_parse . i4_cur_slice_idx & ( MAX_SLICE_HDR_CNT - 1 ) ) ] [ i ] = ( ( pic_buf_t * ) ps_slice_hdr -> as_ref_pic_list1 [ i ] . pv_pic_buf ) -> i4_abs_poc ; ps_mv_buf -> ai1_l1_collocated_poc_lt [ ( ps_codec -> s_parse . i4_cur_slice_idx & ( MAX_SLICE_HDR_CNT - 1 ) ) ] [ i ] = ( ( pic_buf_t * ) ps_slice_hdr -> as_ref_pic_list1 [ i ] . pv_pic_buf ) -> u1_used_as_ref ; } } if ( ps_slice_hdr -> i1_num_ref_idx_l0_active != 0 ) { for ( i = 0 ; i < ps_slice_hdr -> i1_num_ref_idx_l0_active ; i ++ ) { ps_mv_buf -> ai4_l0_collocated_poc [ ( ps_codec -> s_parse . i4_cur_slice_idx & ( MAX_SLICE_HDR_CNT - 1 ) ) ] [ i ] = ( ( pic_buf_t * ) ps_slice_hdr -> as_ref_pic_list0 [ i ] . pv_pic_buf ) -> i4_abs_poc ; ps_mv_buf -> ai1_l0_collocated_poc_lt [ ( ps_codec -> s_parse . i4_cur_slice_idx & ( MAX_SLICE_HDR_CNT - 1 ) ) ] [ i ] = ( ( pic_buf_t * ) ps_slice_hdr -> as_ref_pic_list0 [ i ] . pv_pic_buf ) -> u1_used_as_ref ; } } } if ( ( 0 == ps_codec -> s_parse . i4_ctb_slice_x ) || ( 0 == ps_codec -> s_parse . i4_ctb_slice_y ) ) { WORD32 cur_poc , ref_list_poc , flag = 1 ; cur_poc = ps_slice_hdr -> i4_abs_pic_order_cnt ; for ( i = 0 ; i < ps_slice_hdr -> i1_num_ref_idx_l0_active ; i ++ ) { ref_list_poc = ( ( mv_buf_t * ) ps_slice_hdr -> as_ref_pic_list0 [ i ] . pv_mv_buf ) -> i4_abs_poc ; if ( ref_list_poc > cur_poc ) { flag = 0 ; break ; } } if ( flag && ( ps_slice_hdr -> i1_slice_type == BSLICE ) ) { for ( i = 0 ; i < ps_slice_hdr -> i1_num_ref_idx_l1_active ; i ++ ) { ref_list_poc = ( ( mv_buf_t * ) ps_slice_hdr -> as_ref_pic_list1 [ i ] . pv_mv_buf ) -> i4_abs_poc ; if ( ref_list_poc > cur_poc ) { flag = 0 ; break ; } } } ps_slice_hdr -> i1_low_delay_flag = flag ; } if ( ps_slice_hdr -> i1_slice_type == ISLICE ) { cabac_init_idc = 0 ; } else if ( ps_slice_hdr -> i1_slice_type == PSLICE ) { cabac_init_idc = ps_slice_hdr -> i1_cabac_init_flag ? 2 : 1 ; } else { cabac_init_idc = ps_slice_hdr -> i1_cabac_init_flag ? 1 : 2 ; } slice_qp = ps_slice_hdr -> i1_slice_qp_delta + ps_pps -> i1_pic_init_qp ; slice_qp = CLIP3 ( slice_qp , 0 , 51 ) ; if ( ( 0 == ps_slice_hdr -> i1_dependent_slice_flag ) || ( ( 1 == ps_slice_hdr -> i1_dependent_slice_flag ) && ( ( 0 == ps_codec -> s_parse . i4_ctb_tile_x ) && ( 0 == ps_codec -> s_parse . i4_ctb_tile_y ) ) ) ) { ps_codec -> s_parse . u4_qp = slice_qp ; } if ( ( 1 == ps_slice_hdr -> i1_dependent_slice_flag ) && ( ! ( ( ps_codec -> s_parse . i4_ctb_tile_x == 0 ) && ( ps_codec -> s_parse . i4_ctb_tile_y == 0 ) ) ) ) { if ( ( 0 == ps_pps -> i1_entropy_coding_sync_enabled_flag ) || ( ps_pps -> i1_entropy_coding_sync_enabled_flag && ( 0 != ps_codec -> s_parse . i4_ctb_x ) ) ) { ihevcd_cabac_reset ( & ps_codec -> s_parse . s_cabac , & ps_codec -> s_parse . s_bitstrm ) ; } } else if ( ( 0 == ps_pps -> i1_entropy_coding_sync_enabled_flag ) || ( ps_pps -> i1_entropy_coding_sync_enabled_flag && ( 0 != ps_codec -> s_parse . i4_ctb_x ) ) ) { <S2SV_StartBug> ihevcd_cabac_init ( & ps_codec -> s_parse . s_cabac , <S2SV_EndBug> & ps_codec -> s_parse . s_bitstrm , slice_qp , cabac_init_idc , & gau1_ihevc_cab_ctxts [ cabac_init_idc ] [ slice_qp ] [ 0 ] ) ; <S2SV_StartBug> } <S2SV_EndBug> do { { WORD32 cur_ctb_idx = ps_codec -> s_parse . i4_ctb_x + ps_codec -> s_parse . i4_ctb_y * ( ps_sps -> i2_pic_wd_in_ctb ) ; if ( 1 == ps_codec -> i4_num_cores && 0 == cur_ctb_idx % RESET_TU_BUF_NCTB ) { ps_codec -> s_parse . ps_tu = ps_codec -> s_parse . ps_pic_tu ; ps_codec -> s_parse . i4_pic_tu_idx = 0 ; } } end_of_pic = 0 ; ps_codec -> s_parse . i4_ctb_num_pcm_blks = 0 ; if ( ( ( 0 == ps_codec -> s_parse . i4_ctb_tile_x ) && ( 0 == ps_codec -> s_parse . i4_ctb_tile_y ) ) && ( ! ( ( ps_tile -> u1_pos_x == 0 ) && ( ps_tile -> u1_pos_y == 0 ) ) ) && ( ! ( ( 0 == ps_codec -> s_parse . i4_ctb_slice_x ) && ( 0 == ps_codec -> s_parse . i4_ctb_slice_y ) ) ) ) { slice_qp = ps_slice_hdr -> i1_slice_qp_delta + ps_pps -> i1_pic_init_qp ; slice_qp = CLIP3 ( slice_qp , 0 , 51 ) ; ps_codec -> s_parse . u4_qp = slice_qp ; ihevcd_get_tile_pos ( ps_pps , ps_sps , ps_codec -> s_parse . i4_ctb_x , ps_codec -> s_parse . i4_ctb_y , & ps_codec -> s_parse . i4_ctb_tile_x , & ps_codec -> s_parse . i4_ctb_tile_y , & tile_idx ) ; ps_codec -> s_parse . ps_tile = ps_pps -> ps_tile + tile_idx ; ps_codec -> s_parse . i4_cur_tile_idx = tile_idx ; ps_tile_prev = ps_tile - 1 ; tile_start_ctb_idx = ps_tile -> u1_pos_x + ps_tile -> u1_pos_y * ( ps_sps -> i2_pic_wd_in_ctb ) ; slice_start_ctb_idx = ps_slice_hdr -> i2_ctb_x + ps_slice_hdr -> i2_ctb_y * ( ps_sps -> i2_pic_wd_in_ctb ) ; if ( slice_start_ctb_idx < tile_start_ctb_idx ) { ps_codec -> s_parse . i4_ctb_slice_y = ps_tile -> u1_pos_y - ps_slice_hdr -> i2_ctb_y ; if ( ! ( ( ( ps_slice_hdr -> i2_ctb_x + ps_tile_prev -> u2_wd ) % ps_sps -> i2_pic_wd_in_ctb ) == ps_tile -> u1_pos_x ) ) { if ( ps_slice_hdr -> i2_ctb_y <= ps_tile -> u1_pos_y ) { if ( ps_slice_hdr -> i2_ctb_x > ps_tile -> u1_pos_x ) { ps_codec -> s_parse . i4_ctb_slice_y -= 1 ; } } } } { <S2SV_StartBug> ihevcd_cabac_init ( & ps_codec -> s_parse . s_cabac , <S2SV_EndBug> & ps_codec -> s_parse . s_bitstrm , slice_qp , cabac_init_idc , & gau1_ihevc_cab_ctxts [ cabac_init_idc ] [ slice_qp ] [ 0 ] ) ; <S2SV_StartBug> } <S2SV_EndBug> } if ( 0 == ps_codec -> s_parse . i4_ctb_tile_x ) { if ( 1 < ps_codec -> i4_num_cores ) { proc_job_t s_job ; IHEVCD_ERROR_T ret ; s_job . i4_cmd = CMD_PROCESS ; s_job . i2_ctb_cnt = ( WORD16 ) ps_tile -> u2_wd ; s_job . i2_ctb_x = ( WORD16 ) ps_codec -> s_parse . i4_ctb_x ; s_job . i2_ctb_y = ( WORD16 ) ps_codec -> s_parse . i4_ctb_y ; s_job . i2_slice_idx = ( WORD16 ) ps_codec -> s_parse . i4_cur_slice_idx ; s_job . i4_tu_coeff_data_ofst = ( UWORD8 * ) ps_codec -> s_parse . pv_tu_coeff_data - ( UWORD8 * ) ps_codec -> s_parse . pv_pic_tu_coeff_data ; ret = ihevcd_jobq_queue ( ( jobq_t * ) ps_codec -> s_parse . pv_proc_jobq , & s_job , sizeof ( proc_job_t ) , 1 ) ; if ( ret != ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ) return ret ; } else { process_ctxt_t * ps_proc = & ps_codec -> as_process [ 0 ] ; WORD32 tu_coeff_data_ofst = ( UWORD8 * ) ps_codec -> s_parse . pv_tu_coeff_data - ( UWORD8 * ) ps_codec -> s_parse . pv_pic_tu_coeff_data ; ps_proc -> i4_ctb_cnt = ps_tile -> u2_wd ; ps_proc -> i4_ctb_x = ps_codec -> s_parse . i4_ctb_x ; ps_proc -> i4_ctb_y = ps_codec -> s_parse . i4_ctb_y ; ps_proc -> i4_cur_slice_idx = ps_codec -> s_parse . i4_cur_slice_idx ; ihevcd_init_proc_ctxt ( ps_proc , tu_coeff_data_ofst ) ; } } if ( ps_pps -> i1_entropy_coding_sync_enabled_flag ) { if ( 0 == ps_codec -> s_parse . i4_ctb_x ) { WORD32 default_ctxt = 0 ; if ( ( 0 == ps_codec -> s_parse . i4_ctb_slice_y ) && ( ! ps_slice_hdr -> i1_dependent_slice_flag ) ) default_ctxt = 1 ; if ( 1 == ps_sps -> i2_pic_wd_in_ctb ) default_ctxt = 1 ; ps_codec -> s_parse . u4_qp = slice_qp ; if ( default_ctxt ) { <S2SV_StartBug> ihevcd_cabac_init ( & ps_codec -> s_parse . s_cabac , <S2SV_EndBug> & ps_codec -> s_parse . s_bitstrm , slice_qp , cabac_init_idc , & gau1_ihevc_cab_ctxts [ cabac_init_idc ] [ slice_qp ] [ 0 ] ) ; <S2SV_StartBug> } <S2SV_EndBug> else { <S2SV_StartBug> ihevcd_cabac_init ( & ps_codec -> s_parse . s_cabac , <S2SV_EndBug> & ps_codec -> s_parse . s_bitstrm , slice_qp , cabac_init_idc , <S2SV_StartBug> ( const UWORD8 * ) & ps_codec -> s_parse . s_cabac . au1_ctxt_models_sync ) ; <S2SV_EndBug> } } } if ( 0 == ps_codec -> i4_slice_error ) { if ( ps_slice_hdr -> i1_slice_sao_luma_flag || ps_slice_hdr -> i1_slice_sao_chroma_flag ) ihevcd_parse_sao ( ps_codec ) ; } else { sao_t * ps_sao = ps_codec -> s_parse . ps_pic_sao + ps_codec -> s_parse . i4_ctb_x + ps_codec -> s_parse . i4_ctb_y * ps_sps -> i2_pic_wd_in_ctb ; ps_sao -> b3_y_type_idx = 0 ; ps_sao -> b3_cb_type_idx = 0 ; ps_sao -> b3_cr_type_idx = 0 ; } { WORD32 ctb_indx ; ctb_indx = ps_codec -> s_parse . i4_ctb_x + ps_sps -> i2_pic_wd_in_ctb * ps_codec -> s_parse . i4_ctb_y ; ps_codec -> s_parse . s_bs_ctxt . pu1_pic_qp_const_in_ctb [ ctb_indx >> 3 ] |= ( 1 << ( ctb_indx & 7 ) ) ; { UWORD16 * pu1_slice_idx = ps_codec -> s_parse . pu1_slice_idx ; pu1_slice_idx [ ctb_indx ] = ps_codec -> s_parse . i4_cur_independent_slice_idx ; } } if ( 0 == ps_codec -> i4_slice_error ) { ihevcd_parse_coding_quadtree ( ps_codec , ( ps_codec -> s_parse . i4_ctb_x << ps_sps -> i1_log2_ctb_size ) , ( ps_codec -> s_parse . i4_ctb_y << ps_sps -> i1_log2_ctb_size ) , ps_sps -> i1_log2_ctb_size , 0 ) ; } else { tu_t * ps_tu = ps_codec -> s_parse . ps_tu ; pu_t * ps_pu = ps_codec -> s_parse . ps_pu ; ps_tu -> b1_cb_cbf = 0 ; ps_tu -> b1_cr_cbf = 0 ; ps_tu -> b1_y_cbf = 0 ; ps_tu -> b4_pos_x = 0 ; ps_tu -> b4_pos_y = 0 ; ps_tu -> b1_transquant_bypass = 0 ; ps_tu -> b3_size = ( ps_sps -> i1_log2_ctb_size - 2 ) ; ps_tu -> b7_qp = ps_codec -> s_parse . u4_qp ; ps_tu -> b3_chroma_intra_mode_idx = INTRA_PRED_CHROMA_IDX_NONE ; ps_tu -> b6_luma_intra_mode = INTRA_PRED_NONE ; ps_tu -> b1_first_tu_in_cu = 1 ; ps_codec -> s_parse . ps_tu ++ ; ps_codec -> s_parse . s_cu . i4_tu_cnt ++ ; ps_codec -> s_parse . i4_pic_tu_idx ++ ; ps_codec -> s_parse . s_cu . i4_pred_mode = PRED_MODE_SKIP ; ps_codec -> s_parse . s_cu . i4_part_mode = PART_2Nx2N ; ps_pu -> b2_part_idx = 0 ; ps_pu -> b4_pos_x = 0 ; ps_pu -> b4_pos_y = 0 ; ps_pu -> b4_wd = ( ctb_size >> 2 ) - 1 ; ps_pu -> b4_ht = ( ctb_size >> 2 ) - 1 ; ps_pu -> b1_intra_flag = 0 ; ps_pu -> b3_part_mode = ps_codec -> s_parse . s_cu . i4_part_mode ; ps_pu -> b1_merge_flag = 1 ; ps_pu -> b3_merge_idx = 0 ; ps_codec -> s_parse . ps_pu ++ ; ps_codec -> s_parse . i4_pic_pu_idx ++ ; } if ( 0 == ps_codec -> i4_slice_error ) end_of_slice_flag = ihevcd_cabac_decode_terminate ( & ps_codec -> s_parse . s_cabac , & ps_codec -> s_parse . s_bitstrm ) ; else end_of_slice_flag = 0 ; AEV_TRACE ( ""end_of_slice_flag"" , end_of_slice_flag , ps_codec -> s_parse . s_cabac . u4_range ) ; if ( ps_pps -> i1_tiles_enabled_flag || ps_pps -> i1_entropy_coding_sync_enabled_flag ) { WORD32 end_of_tile = 0 ; WORD32 end_of_tile_row = 0 ; if ( ps_pps -> i1_entropy_coding_sync_enabled_flag || ps_pps -> i1_tiles_enabled_flag ) { if ( 1 == ps_codec -> s_parse . i4_ctb_x ) { WORD32 size = sizeof ( ps_codec -> s_parse . s_cabac . au1_ctxt_models ) ; memcpy ( & ps_codec -> s_parse . s_cabac . au1_ctxt_models_sync , & ps_codec -> s_parse . s_cabac . au1_ctxt_models , size ) ; } } if ( ( ps_codec -> s_parse . i4_ctb_tile_x + 1 ) == ( ps_tile -> u2_wd ) ) { end_of_tile_row = 1 ; if ( ( ps_codec -> s_parse . i4_ctb_tile_y + 1 ) == ps_tile -> u2_ht ) end_of_tile = 1 ; } if ( ( 0 == end_of_slice_flag ) && ( ( ps_pps -> i1_tiles_enabled_flag && end_of_tile ) || ( ps_pps -> i1_entropy_coding_sync_enabled_flag && end_of_tile_row ) ) ) { WORD32 end_of_sub_stream_one_bit ; end_of_sub_stream_one_bit = ihevcd_cabac_decode_terminate ( & ps_codec -> s_parse . s_cabac , & ps_codec -> s_parse . s_bitstrm ) ; AEV_TRACE ( ""end_of_sub_stream_one_bit"" , end_of_sub_stream_one_bit , ps_codec -> s_parse . s_cabac . u4_range ) ; if ( ps_codec -> s_parse . s_bitstrm . u4_bit_ofst % 8 ) ihevcd_bits_flush_to_byte_boundary ( & ps_codec -> s_parse . s_bitstrm ) ; UNUSED ( end_of_sub_stream_one_bit ) ; } } { WORD32 ctb_indx ; ctb_addr = ps_codec -> s_parse . i4_ctb_y * num_ctb_in_row + ps_codec -> s_parse . i4_ctb_x ; ctb_indx = ++ ctb_addr ; if ( ( ps_tile -> u2_wd == ( ps_codec -> s_parse . i4_ctb_tile_x + 1 ) ) && ( ps_tile -> u2_wd != ps_sps -> i2_pic_wd_in_ctb ) ) { ctb_indx = ( ps_sps -> i2_pic_wd_in_ctb * ( ps_codec -> s_parse . i4_ctb_tile_y + 1 + ps_tile -> u1_pos_y ) ) + ps_tile -> u1_pos_x ; if ( ps_tile -> u2_ht == ( ps_codec -> s_parse . i4_ctb_tile_y + 1 ) ) { if ( ( ps_tile -> u2_wd + ps_tile -> u1_pos_x == ps_sps -> i2_pic_wd_in_ctb ) && ( ( ps_tile -> u2_ht + ps_tile -> u1_pos_y == ps_sps -> i2_pic_ht_in_ctb ) ) ) { ctb_indx = ctb_addr ; } else { tile_t * ps_next_tile = ps_codec -> s_parse . ps_tile + 1 ; ctb_indx = ps_next_tile -> u1_pos_x + ( ps_next_tile -> u1_pos_y * ps_sps -> i2_pic_wd_in_ctb ) ; } } } ps_codec -> s_parse . pu4_pic_pu_idx [ ctb_indx ] = ps_codec -> s_parse . i4_pic_pu_idx ; ps_codec -> s_parse . i4_next_pu_ctb_cnt = ctb_indx ; ps_codec -> s_parse . pu1_pu_map += num_min4x4_in_ctb ; if ( 1 == ps_codec -> i4_num_cores ) { ctb_indx = ( 0 == ctb_addr % RESET_TU_BUF_NCTB ) ? RESET_TU_BUF_NCTB : ctb_addr % RESET_TU_BUF_NCTB ; if ( ( ps_tile -> u2_wd == ( ps_codec -> s_parse . i4_ctb_tile_x + 1 ) ) && ( ps_tile -> u2_wd != ps_sps -> i2_pic_wd_in_ctb ) ) { ctb_indx = ( ps_sps -> i2_pic_wd_in_ctb * ( ps_codec -> s_parse . i4_ctb_tile_y + 1 + ps_tile -> u1_pos_y ) ) + ps_tile -> u1_pos_x ; if ( ps_tile -> u2_ht == ( ps_codec -> s_parse . i4_ctb_tile_y + 1 ) ) { if ( ( ps_tile -> u2_wd + ps_tile -> u1_pos_x == ps_sps -> i2_pic_wd_in_ctb ) && ( ( ps_tile -> u2_ht + ps_tile -> u1_pos_y == ps_sps -> i2_pic_ht_in_ctb ) ) ) { ctb_indx = ( 0 == ctb_addr % RESET_TU_BUF_NCTB ) ? RESET_TU_BUF_NCTB : ctb_addr % RESET_TU_BUF_NCTB ; } else { tile_t * ps_next_tile = ps_codec -> s_parse . ps_tile + 1 ; ctb_indx = ps_next_tile -> u1_pos_x + ( ps_next_tile -> u1_pos_y * ps_sps -> i2_pic_wd_in_ctb ) ; } } } ps_codec -> s_parse . i4_next_tu_ctb_cnt = ctb_indx ; ps_codec -> s_parse . pu4_pic_tu_idx [ ctb_indx ] = ps_codec -> s_parse . i4_pic_tu_idx ; } else { ctb_indx = ctb_addr ; if ( ( ps_tile -> u2_wd == ( ps_codec -> s_parse . i4_ctb_tile_x + 1 ) ) && ( ps_tile -> u2_wd != ps_sps -> i2_pic_wd_in_ctb ) ) { ctb_indx = ( ps_sps -> i2_pic_wd_in_ctb * ( ps_codec -> s_parse . i4_ctb_tile_y + 1 + ps_tile -> u1_pos_y ) ) + ps_tile -> u1_pos_x ; if ( ps_tile -> u2_ht == ( ps_codec -> s_parse . i4_ctb_tile_y + 1 ) ) { if ( ( ps_tile -> u2_wd + ps_tile -> u1_pos_x == ps_sps -> i2_pic_wd_in_ctb ) && ( ( ps_tile -> u2_ht + ps_tile -> u1_pos_y == ps_sps -> i2_pic_ht_in_ctb ) ) ) { ctb_indx = ctb_addr ; } else { tile_t * ps_next_tile = ps_codec -> s_parse . ps_tile + 1 ; ctb_indx = ps_next_tile -> u1_pos_x + ( ps_next_tile -> u1_pos_y * ps_sps -> i2_pic_wd_in_ctb ) ; } } } ps_codec -> s_parse . i4_next_tu_ctb_cnt = ctb_indx ; ps_codec -> s_parse . pu4_pic_tu_idx [ ctb_indx ] = ps_codec -> s_parse . i4_pic_tu_idx ; } ps_codec -> s_parse . pu1_tu_map += num_min4x4_in_ctb ; } if ( ( 0 != ps_codec -> i4_disable_deblk_pic ) && ( 1 == ps_slice_hdr -> i1_slice_disable_deblocking_filter_flag ) ) { bs_ctxt_t * ps_bs_ctxt = & ps_codec -> s_parse . s_bs_ctxt ; WORD32 log2_ctb_size = ps_sps -> i1_log2_ctb_size ; UWORD8 * pu1_qp ; WORD32 qp_strd ; WORD32 u4_qp_const_in_ctb ; WORD32 cur_ctb_idx ; WORD32 next_ctb_idx ; WORD32 cur_tu_idx ; WORD32 i4_ctb_tu_cnt ; tu_t * ps_tu ; cur_ctb_idx = ps_codec -> s_parse . i4_ctb_x + ps_sps -> i2_pic_wd_in_ctb * ps_codec -> s_parse . i4_ctb_y ; qp_strd = ps_sps -> i2_pic_wd_in_ctb << ( log2_ctb_size - 3 ) ; pu1_qp = ps_bs_ctxt -> pu1_pic_qp + ( ( ps_codec -> s_parse . i4_ctb_x + ps_codec -> s_parse . i4_ctb_y * qp_strd ) << ( log2_ctb_size - 3 ) ) ; u4_qp_const_in_ctb = ps_bs_ctxt -> pu1_pic_qp_const_in_ctb [ cur_ctb_idx >> 3 ] & ( 1 << ( cur_ctb_idx & 7 ) ) ; next_ctb_idx = ps_codec -> s_parse . i4_next_tu_ctb_cnt ; if ( 1 == ps_codec -> i4_num_cores ) { i4_ctb_tu_cnt = ps_codec -> s_parse . pu4_pic_tu_idx [ next_ctb_idx ] - ps_codec -> s_parse . pu4_pic_tu_idx [ cur_ctb_idx % RESET_TU_BUF_NCTB ] ; cur_tu_idx = ps_codec -> s_parse . pu4_pic_tu_idx [ cur_ctb_idx % RESET_TU_BUF_NCTB ] ; } else { i4_ctb_tu_cnt = ps_codec -> s_parse . pu4_pic_tu_idx [ next_ctb_idx ] - ps_codec -> s_parse . pu4_pic_tu_idx [ cur_ctb_idx ] ; cur_tu_idx = ps_codec -> s_parse . pu4_pic_tu_idx [ cur_ctb_idx ] ; } ps_tu = & ps_codec -> s_parse . ps_pic_tu [ cur_tu_idx ] ; if ( u4_qp_const_in_ctb ) { pu1_qp [ 0 ] = ps_tu -> b7_qp ; } else { for ( i = 0 ; i < i4_ctb_tu_cnt ; i ++ , ps_tu ++ ) { WORD32 start_pos_x ; WORD32 start_pos_y ; WORD32 tu_size ; start_pos_x = ps_tu -> b4_pos_x ; start_pos_y = ps_tu -> b4_pos_y ; tu_size = 1 << ( ps_tu -> b3_size + 2 ) ; tu_size >>= 2 ; if ( 0 == ( start_pos_x & 1 ) && 0 == ( start_pos_y & 1 ) ) { WORD32 row , col ; for ( row = start_pos_y ; row < start_pos_y + tu_size ; row += 2 ) { for ( col = start_pos_x ; col < start_pos_x + tu_size ; col += 2 ) { pu1_qp [ ( row >> 1 ) * qp_strd + ( col >> 1 ) ] = ps_tu -> b7_qp ; } } } } } } if ( ps_codec -> i4_num_cores <= MV_PRED_NUM_CORES_THRESHOLD ) { WORD8 u1_top_ctb_avail = 1 ; WORD8 u1_left_ctb_avail = 1 ; WORD8 u1_top_lt_ctb_avail = 1 ; WORD8 u1_top_rt_ctb_avail = 1 ; WORD16 i2_wd_in_ctb ; tile_start_ctb_idx = ps_tile -> u1_pos_x + ps_tile -> u1_pos_y * ( ps_sps -> i2_pic_wd_in_ctb ) ; slice_start_ctb_idx = ps_slice_hdr -> i2_ctb_x + ps_slice_hdr -> i2_ctb_y * ( ps_sps -> i2_pic_wd_in_ctb ) ; if ( ( slice_start_ctb_idx < tile_start_ctb_idx ) ) { i2_wd_in_ctb = ps_sps -> i2_pic_wd_in_ctb ; } else { i2_wd_in_ctb = ps_tile -> u2_wd ; } if ( ( 0 == ps_codec -> s_parse . i4_ctb_y ) || ( 0 == ps_codec -> s_parse . i4_ctb_tile_y ) ) { u1_top_ctb_avail = 0 ; u1_top_lt_ctb_avail = 0 ; u1_top_rt_ctb_avail = 0 ; } if ( ( 0 == ps_codec -> s_parse . i4_ctb_x ) || ( 0 == ps_codec -> s_parse . i4_ctb_tile_x ) ) { u1_left_ctb_avail = 0 ; u1_top_lt_ctb_avail = 0 ; if ( ( 0 == ps_codec -> s_parse . i4_ctb_slice_y ) || ( 0 == ps_codec -> s_parse . i4_ctb_tile_y ) ) { u1_top_ctb_avail = 0 ; if ( ( i2_wd_in_ctb - 1 ) != ps_codec -> s_parse . i4_ctb_slice_x ) { u1_top_rt_ctb_avail = 0 ; } } } else if ( ps_codec -> s_parse . i4_ctb_x > 0 ) { if ( ( 0 == ps_codec -> s_parse . i4_ctb_slice_y ) || ( 0 == ps_codec -> s_parse . i4_ctb_tile_y ) ) { u1_top_ctb_avail = 0 ; u1_top_lt_ctb_avail = 0 ; if ( 0 == ps_codec -> s_parse . i4_ctb_slice_x ) { u1_left_ctb_avail = 0 ; } if ( ( i2_wd_in_ctb - 1 ) != ps_codec -> s_parse . i4_ctb_slice_x ) { u1_top_rt_ctb_avail = 0 ; } } else if ( ( 1 == ps_codec -> s_parse . i4_ctb_slice_y ) && ( 0 == ps_codec -> s_parse . i4_ctb_slice_x ) ) { u1_top_lt_ctb_avail = 0 ; } } if ( ( ( ps_sps -> i2_pic_wd_in_ctb - 1 ) == ps_codec -> s_parse . i4_ctb_x ) || ( ( ps_tile -> u2_wd - 1 ) == ps_codec -> s_parse . i4_ctb_tile_x ) ) { u1_top_rt_ctb_avail = 0 ; } if ( PSLICE == ps_slice_hdr -> i1_slice_type || BSLICE == ps_slice_hdr -> i1_slice_type ) { mv_ctxt_t s_mv_ctxt ; process_ctxt_t * ps_proc ; UWORD32 * pu4_ctb_top_pu_idx ; UWORD32 * pu4_ctb_left_pu_idx ; UWORD32 * pu4_ctb_top_left_pu_idx ; WORD32 i4_ctb_pu_cnt ; WORD32 cur_ctb_idx ; WORD32 next_ctb_idx ; WORD32 cur_pu_idx ; ps_proc = & ps_codec -> as_process [ ( ps_codec -> i4_num_cores == 1 ) ? 1 : ( ps_codec -> i4_num_cores - 1 ) ] ; cur_ctb_idx = ps_codec -> s_parse . i4_ctb_x + ps_codec -> s_parse . i4_ctb_y * ( ps_sps -> i2_pic_wd_in_ctb ) ; next_ctb_idx = ps_codec -> s_parse . i4_next_pu_ctb_cnt ; i4_ctb_pu_cnt = ps_codec -> s_parse . pu4_pic_pu_idx [ next_ctb_idx ] - ps_codec -> s_parse . pu4_pic_pu_idx [ cur_ctb_idx ] ; cur_pu_idx = ps_codec -> s_parse . pu4_pic_pu_idx [ cur_ctb_idx ] ; pu4_ctb_top_pu_idx = ps_proc -> pu4_pic_pu_idx_top + ( ps_codec -> s_parse . i4_ctb_x * ctb_size / MIN_PU_SIZE ) ; pu4_ctb_left_pu_idx = ps_proc -> pu4_pic_pu_idx_left ; pu4_ctb_top_left_pu_idx = & ps_proc -> u4_ctb_top_left_pu_idx ; { s_mv_ctxt . ps_pps = ps_pps ; s_mv_ctxt . ps_sps = ps_sps ; s_mv_ctxt . ps_slice_hdr = ps_slice_hdr ; s_mv_ctxt . i4_ctb_x = ps_codec -> s_parse . i4_ctb_x ; s_mv_ctxt . i4_ctb_y = ps_codec -> s_parse . i4_ctb_y ; s_mv_ctxt . ps_pu = & ps_codec -> s_parse . ps_pic_pu [ cur_pu_idx ] ; s_mv_ctxt . ps_pic_pu = ps_codec -> s_parse . ps_pic_pu ; s_mv_ctxt . ps_tile = ps_tile ; s_mv_ctxt . pu4_pic_pu_idx_map = ps_proc -> pu4_pic_pu_idx_map ; s_mv_ctxt . pu4_pic_pu_idx = ps_codec -> s_parse . pu4_pic_pu_idx ; s_mv_ctxt . pu1_pic_pu_map = ps_codec -> s_parse . pu1_pic_pu_map ; s_mv_ctxt . i4_ctb_pu_cnt = i4_ctb_pu_cnt ; s_mv_ctxt . i4_ctb_start_pu_idx = cur_pu_idx ; s_mv_ctxt . u1_top_ctb_avail = u1_top_ctb_avail ; s_mv_ctxt . u1_top_rt_ctb_avail = u1_top_rt_ctb_avail ; s_mv_ctxt . u1_top_lt_ctb_avail = u1_top_lt_ctb_avail ; s_mv_ctxt . u1_left_ctb_avail = u1_left_ctb_avail ; } ihevcd_get_mv_ctb ( & s_mv_ctxt , pu4_ctb_top_pu_idx , pu4_ctb_left_pu_idx , pu4_ctb_top_left_pu_idx ) ; } else { WORD32 num_minpu_in_ctb = ( ctb_size / MIN_PU_SIZE ) * ( ctb_size / MIN_PU_SIZE ) ; UWORD8 * pu1_pic_pu_map_ctb = ps_codec -> s_parse . pu1_pic_pu_map + ( ps_codec -> s_parse . i4_ctb_x + ps_codec -> s_parse . i4_ctb_y * ps_sps -> i2_pic_wd_in_ctb ) * num_minpu_in_ctb ; process_ctxt_t * ps_proc = & ps_codec -> as_process [ ( ps_codec -> i4_num_cores == 1 ) ? 1 : ( ps_codec -> i4_num_cores - 1 ) ] ; WORD32 row , col ; WORD32 pu_cnt ; WORD32 num_pu_per_ctb ; WORD32 cur_ctb_idx ; WORD32 next_ctb_idx ; WORD32 ctb_start_pu_idx ; UWORD32 * pu4_nbr_pu_idx = ps_proc -> pu4_pic_pu_idx_map ; WORD32 nbr_pu_idx_strd = MAX_CTB_SIZE / MIN_PU_SIZE + 2 ; pu_t * ps_pu ; for ( row = 0 ; row < ctb_size / MIN_PU_SIZE ; row ++ ) { for ( col = 0 ; col < ctb_size / MIN_PU_SIZE ; col ++ ) { pu1_pic_pu_map_ctb [ row * ctb_size / MIN_PU_SIZE + col ] = 0 ; } } cur_ctb_idx = ps_codec -> s_parse . i4_ctb_x + ps_codec -> s_parse . i4_ctb_y * ( ps_sps -> i2_pic_wd_in_ctb ) ; next_ctb_idx = ps_codec -> s_parse . i4_next_pu_ctb_cnt ; num_pu_per_ctb = ps_codec -> s_parse . pu4_pic_pu_idx [ next_ctb_idx ] - ps_codec -> s_parse . pu4_pic_pu_idx [ cur_ctb_idx ] ; ctb_start_pu_idx = ps_codec -> s_parse . pu4_pic_pu_idx [ cur_ctb_idx ] ; ps_pu = & ps_codec -> s_parse . ps_pic_pu [ ctb_start_pu_idx ] ; for ( pu_cnt = 0 ; pu_cnt < num_pu_per_ctb ; pu_cnt ++ , ps_pu ++ ) { UWORD32 cur_pu_idx ; WORD32 pu_ht = ( ps_pu -> b4_ht + 1 ) << 2 ; WORD32 pu_wd = ( ps_pu -> b4_wd + 1 ) << 2 ; cur_pu_idx = ctb_start_pu_idx + pu_cnt ; for ( row = 0 ; row < pu_ht / MIN_PU_SIZE ; row ++ ) for ( col = 0 ; col < pu_wd / MIN_PU_SIZE ; col ++ ) pu4_nbr_pu_idx [ ( 1 + ps_pu -> b4_pos_x + col ) + ( 1 + ps_pu -> b4_pos_y + row ) * nbr_pu_idx_strd ] = cur_pu_idx ; } { WORD32 rows_remaining = ps_sps -> i2_pic_height_in_luma_samples - ( ps_codec -> s_parse . i4_ctb_y << ps_sps -> i1_log2_ctb_size ) ; WORD32 ctb_size_left = MIN ( ctb_size , rows_remaining ) ; ps_proc -> u4_ctb_top_left_pu_idx = ps_proc -> pu4_pic_pu_idx_top [ ( ps_codec -> s_parse . i4_ctb_x * ctb_size / MIN_PU_SIZE ) + ctb_size / MIN_PU_SIZE - 1 ] ; for ( i = 0 ; i < ctb_size / MIN_PU_SIZE ; i ++ ) { ps_proc -> pu4_pic_pu_idx_left [ i ] = pu4_nbr_pu_idx [ ( ctb_size / MIN_PU_SIZE ) + ( i + 1 ) * nbr_pu_idx_strd ] ; ps_proc -> pu4_pic_pu_idx_top [ ( ps_codec -> s_parse . i4_ctb_x * ctb_size / MIN_PU_SIZE ) + i ] = pu4_nbr_pu_idx [ ( ctb_size_left / MIN_PU_SIZE ) * nbr_pu_idx_strd + i + 1 ] ; } } } if ( 0 == ps_codec -> i4_disable_deblk_pic ) { if ( ( 0 == ps_codec -> i4_slice_error ) ) { WORD32 i4_ctb_tu_cnt ; WORD32 cur_ctb_idx , next_ctb_idx ; WORD32 cur_pu_idx ; WORD32 cur_tu_idx ; process_ctxt_t * ps_proc ; ps_proc = & ps_codec -> as_process [ ( ps_codec -> i4_num_cores == 1 ) ? 1 : ( ps_codec -> i4_num_cores - 1 ) ] ; cur_ctb_idx = ps_codec -> s_parse . i4_ctb_x + ps_codec -> s_parse . i4_ctb_y * ( ps_sps -> i2_pic_wd_in_ctb ) ; cur_pu_idx = ps_codec -> s_parse . pu4_pic_pu_idx [ cur_ctb_idx ] ; next_ctb_idx = ps_codec -> s_parse . i4_next_tu_ctb_cnt ; if ( 1 == ps_codec -> i4_num_cores ) { i4_ctb_tu_cnt = ps_codec -> s_parse . pu4_pic_tu_idx [ next_ctb_idx ] - ps_codec -> s_parse . pu4_pic_tu_idx [ cur_ctb_idx % RESET_TU_BUF_NCTB ] ; cur_tu_idx = ps_codec -> s_parse . pu4_pic_tu_idx [ cur_ctb_idx % RESET_TU_BUF_NCTB ] ; } else { i4_ctb_tu_cnt = ps_codec -> s_parse . pu4_pic_tu_idx [ next_ctb_idx ] - ps_codec -> s_parse . pu4_pic_tu_idx [ cur_ctb_idx ] ; cur_tu_idx = ps_codec -> s_parse . pu4_pic_tu_idx [ cur_ctb_idx ] ; } ps_codec -> s_parse . s_bs_ctxt . ps_pps = ps_codec -> s_parse . ps_pps ; ps_codec -> s_parse . s_bs_ctxt . ps_sps = ps_codec -> s_parse . ps_sps ; ps_codec -> s_parse . s_bs_ctxt . ps_codec = ps_codec ; ps_codec -> s_parse . s_bs_ctxt . i4_ctb_tu_cnt = i4_ctb_tu_cnt ; ps_codec -> s_parse . s_bs_ctxt . i4_ctb_x = ps_codec -> s_parse . i4_ctb_x ; ps_codec -> s_parse . s_bs_ctxt . i4_ctb_y = ps_codec -> s_parse . i4_ctb_y ; ps_codec -> s_parse . s_bs_ctxt . i4_ctb_tile_x = ps_codec -> s_parse . i4_ctb_tile_x ; ps_codec -> s_parse . s_bs_ctxt . i4_ctb_tile_y = ps_codec -> s_parse . i4_ctb_tile_y ; ps_codec -> s_parse . s_bs_ctxt . i4_ctb_slice_x = ps_codec -> s_parse . i4_ctb_slice_x ; ps_codec -> s_parse . s_bs_ctxt . i4_ctb_slice_y = ps_codec -> s_parse . i4_ctb_slice_y ; ps_codec -> s_parse . s_bs_ctxt . ps_tu = & ps_codec -> s_parse . ps_pic_tu [ cur_tu_idx ] ; ps_codec -> s_parse . s_bs_ctxt . ps_pu = & ps_codec -> s_parse . ps_pic_pu [ cur_pu_idx ] ; ps_codec -> s_parse . s_bs_ctxt . pu4_pic_pu_idx_map = ps_proc -> pu4_pic_pu_idx_map ; ps_codec -> s_parse . s_bs_ctxt . i4_next_pu_ctb_cnt = ps_codec -> s_parse . i4_next_pu_ctb_cnt ; ps_codec -> s_parse . s_bs_ctxt . i4_next_tu_ctb_cnt = ps_codec -> s_parse . i4_next_tu_ctb_cnt ; ps_codec -> s_parse . s_bs_ctxt . pu1_slice_idx = ps_codec -> s_parse . pu1_slice_idx ; ps_codec -> s_parse . s_bs_ctxt . ps_slice_hdr = ps_codec -> s_parse . ps_slice_hdr ; ps_codec -> s_parse . s_bs_ctxt . ps_tile = ps_codec -> s_parse . ps_tile ; if ( ISLICE == ps_slice_hdr -> i1_slice_type ) { ihevcd_ctb_boundary_strength_islice ( & ps_codec -> s_parse . s_bs_ctxt ) ; } else { ihevcd_ctb_boundary_strength_pbslice ( & ps_codec -> s_parse . s_bs_ctxt ) ; } } if ( 0 != ps_slice_hdr -> i1_slice_disable_deblocking_filter_flag ) { WORD32 bs_strd = ( ps_sps -> i2_pic_wd_in_ctb + 1 ) * ( ctb_size * ctb_size / 8 / 16 ) ; UWORD32 * pu4_vert_bs = ( UWORD32 * ) ( ( UWORD8 * ) ps_codec -> s_parse . s_bs_ctxt . pu4_pic_vert_bs + ps_codec -> s_parse . i4_ctb_x * ( ctb_size * ctb_size / 8 / 16 ) + ps_codec -> s_parse . i4_ctb_y * bs_strd ) ; UWORD32 * pu4_horz_bs = ( UWORD32 * ) ( ( UWORD8 * ) ps_codec -> s_parse . s_bs_ctxt . pu4_pic_horz_bs + ps_codec -> s_parse . i4_ctb_x * ( ctb_size * ctb_size / 8 / 16 ) + ps_codec -> s_parse . i4_ctb_y * bs_strd ) ; memset ( pu4_vert_bs , 0 , ( ctb_size / 8 ) * ( ctb_size / 4 ) / 8 * 2 ) ; memset ( pu4_horz_bs , 0 , ( ctb_size / 8 ) * ( ctb_size / 4 ) / 8 * 2 ) ; } } } DATA_SYNC ( ) ; { sps_t * ps_sps = ps_codec -> s_parse . ps_sps ; UWORD8 * pu1_buf ; WORD32 idx ; idx = ( ps_codec -> s_parse . i4_ctb_x ) ; idx += ( ( ps_codec -> s_parse . i4_ctb_y ) * ps_sps -> i2_pic_wd_in_ctb ) ; pu1_buf = ( ps_codec -> pu1_parse_map + idx ) ; * pu1_buf = 1 ; } ps_codec -> s_parse . i4_ctb_tile_x ++ ; ps_codec -> s_parse . i4_ctb_x ++ ; ps_codec -> s_parse . i4_ctb_slice_x ++ ; if ( ps_pps -> i1_tiles_enabled_flag ) { tile_start_ctb_idx = ps_tile -> u1_pos_x + ps_tile -> u1_pos_y * ( ps_sps -> i2_pic_wd_in_ctb ) ; slice_start_ctb_idx = ps_slice_hdr -> i2_ctb_x + ps_slice_hdr -> i2_ctb_y * ( ps_sps -> i2_pic_wd_in_ctb ) ; if ( ( slice_start_ctb_idx < tile_start_ctb_idx ) ) { if ( ps_codec -> s_parse . i4_ctb_slice_x == ( ps_tile -> u1_pos_x + ps_tile -> u2_wd ) ) { ps_codec -> s_parse . i4_ctb_slice_y ++ ; ps_codec -> s_parse . i4_ctb_slice_x = ps_tile -> u1_pos_x ; } } else if ( ps_codec -> s_parse . i4_ctb_slice_x == ( ps_tile -> u2_wd ) ) { ps_codec -> s_parse . i4_ctb_slice_y ++ ; ps_codec -> s_parse . i4_ctb_slice_x = 0 ; } } else { if ( ps_codec -> s_parse . i4_ctb_slice_x == ps_tile -> u2_wd ) { ps_codec -> s_parse . i4_ctb_slice_y ++ ; ps_codec -> s_parse . i4_ctb_slice_x = 0 ; } } if ( ps_codec -> s_parse . i4_ctb_tile_x == ( ps_tile -> u2_wd ) ) { ps_codec -> s_parse . i4_ctb_tile_x = 0 ; ps_codec -> s_parse . i4_ctb_x = ps_tile -> u1_pos_x ; ps_codec -> s_parse . i4_ctb_tile_y ++ ; ps_codec -> s_parse . i4_ctb_y ++ ; if ( ps_codec -> s_parse . i4_ctb_tile_y == ( ps_tile -> u2_ht ) ) { ps_codec -> s_parse . i4_ctb_tile_y = 0 ; ps_codec -> s_parse . i4_ctb_tile_x = 0 ; ps_codec -> s_parse . ps_tile ++ ; if ( ( ps_tile -> u2_ht + ps_tile -> u1_pos_y == ps_sps -> i2_pic_ht_in_ctb ) && ( ps_tile -> u2_wd + ps_tile -> u1_pos_x == ps_sps -> i2_pic_wd_in_ctb ) ) { end_of_pic = 1 ; ps_codec -> s_parse . i4_ctb_x = 0 ; ps_codec -> s_parse . i4_ctb_y = ps_sps -> i2_pic_ht_in_ctb ; } else { ps_tile = ps_codec -> s_parse . ps_tile ; ps_codec -> s_parse . i4_ctb_x = ps_tile -> u1_pos_x ; ps_codec -> s_parse . i4_ctb_y = ps_tile -> u1_pos_y ; ps_codec -> s_parse . i4_ctb_tile_y = 0 ; ps_codec -> s_parse . i4_ctb_tile_x = 0 ; ps_codec -> s_parse . i4_ctb_slice_x = ps_tile -> u1_pos_x ; ps_codec -> s_parse . i4_ctb_slice_y = ps_tile -> u1_pos_y ; } } } ps_codec -> s_parse . i4_next_ctb_indx = ps_codec -> s_parse . i4_ctb_x + ps_codec -> s_parse . i4_ctb_y * ps_sps -> i2_pic_wd_in_ctb ; if ( ps_codec -> i4_slice_error ) { slice_header_t * ps_slice_hdr_next = ps_slice_hdr + 1 ; WORD32 next_slice_addr = ps_slice_hdr_next -> i2_ctb_x + ps_slice_hdr_next -> i2_ctb_y * ps_sps -> i2_pic_wd_in_ctb ; if ( ps_codec -> s_parse . i4_next_ctb_indx == next_slice_addr ) end_of_slice_flag = 1 ; } if ( ( 1 == ps_codec -> i4_num_cores ) && ( ps_codec -> s_parse . i4_ctb_tile_x == 0 ) ) { process_ctxt_t * ps_proc = & ps_codec -> as_process [ 0 ] ; ps_proc -> i4_ctb_cnt = ps_proc -> ps_tile -> u2_wd ; ihevcd_process ( ps_proc ) ; } if ( ( UWORD8 * ) ps_codec -> s_parse . s_bitstrm . pu1_buf_max + BITSTRM_OFF_THRS < ( ( UWORD8 * ) ps_codec -> s_parse . s_bitstrm . pu4_buf + ( ps_codec -> s_parse . s_bitstrm . u4_bit_ofst / 8 ) ) ) { if ( 0 == ps_codec -> i4_slice_error ) end_of_slice_flag = 1 ; } if ( end_of_pic ) break ; } while ( ! end_of_slice_flag ) ; <S2SV_StartBug> if ( 0 == end_of_pic ) <S2SV_EndBug> { while ( 1 ) { WORD32 parse_slice_idx ; parse_slice_idx = ps_codec -> s_parse . i4_cur_slice_idx ; parse_slice_idx ++ ; { if ( ( 1 == ps_codec -> i4_num_cores ) || ( 0 != ( parse_slice_idx & ( MAX_SLICE_HDR_CNT - 1 ) ) ) ) { ps_codec -> s_parse . i4_cur_slice_idx = parse_slice_idx ; break ; } else { WORD32 ctb_indx = 0 ; while ( ctb_indx != ps_sps -> i4_pic_size_in_ctb ) { WORD32 parse_status = * ( ps_codec -> pu1_parse_map + ctb_indx ) ; volatile WORD32 proc_status = * ( ps_codec -> pu1_proc_map + ctb_indx ) & 1 ; if ( parse_status == proc_status ) ctb_indx ++ ; } ps_codec -> s_parse . i4_cur_slice_idx = parse_slice_idx ; break ; } } } } else { # if FRAME_ILF_PAD if ( FRAME_ILF_PAD && 1 == ps_codec -> i4_num_cores ) { if ( ps_slice_hdr -> i4_abs_pic_order_cnt == 0 ) { DUMP_PRE_ILF ( ps_codec -> as_process [ 0 ] . pu1_cur_pic_luma , ps_codec -> as_process [ 0 ] . pu1_cur_pic_chroma , ps_sps -> i2_pic_width_in_luma_samples , ps_sps -> i2_pic_height_in_luma_samples , ps_codec -> i4_strd ) ; DUMP_BS ( ps_codec -> as_process [ 0 ] . s_bs_ctxt . pu4_pic_vert_bs , ps_codec -> as_process [ 0 ] . s_bs_ctxt . pu4_pic_horz_bs , ps_sps -> i2_pic_wd_in_ctb * ( ctb_size * ctb_size / 8 / 16 ) * ps_sps -> i2_pic_ht_in_ctb , ( ps_sps -> i2_pic_wd_in_ctb + 1 ) * ( ctb_size * ctb_size / 8 / 16 ) * ps_sps -> i2_pic_ht_in_ctb ) ; DUMP_QP ( ps_codec -> as_process [ 0 ] . s_bs_ctxt . pu1_pic_qp , ( ps_sps -> i2_pic_height_in_luma_samples * ps_sps -> i2_pic_width_in_luma_samples ) / ( MIN_CU_SIZE * MIN_CU_SIZE ) ) ; DUMP_QP_CONST_IN_CTB ( ps_codec -> as_process [ 0 ] . s_bs_ctxt . pu1_pic_qp_const_in_ctb , ( ps_sps -> i2_pic_height_in_luma_samples * ps_sps -> i2_pic_width_in_luma_samples ) / ( MIN_CTB_SIZE * MIN_CTB_SIZE ) / 8 ) ; DUMP_NO_LOOP_FILTER ( ps_codec -> as_process [ 0 ] . pu1_pic_no_loop_filter_flag , ( ps_sps -> i2_pic_width_in_luma_samples / MIN_CU_SIZE ) * ( ps_sps -> i2_pic_height_in_luma_samples / MIN_CU_SIZE ) / 8 ) ; DUMP_OFFSETS ( ps_slice_hdr -> i1_beta_offset_div2 , ps_slice_hdr -> i1_tc_offset_div2 , ps_pps -> i1_pic_cb_qp_offset , ps_pps -> i1_pic_cr_qp_offset ) ; } ps_codec -> s_parse . s_deblk_ctxt . ps_pps = ps_codec -> s_parse . ps_pps ; ps_codec -> s_parse . s_deblk_ctxt . ps_sps = ps_codec -> s_parse . ps_sps ; ps_codec -> s_parse . s_deblk_ctxt . ps_codec = ps_codec ; ps_codec -> s_parse . s_deblk_ctxt . ps_slice_hdr = ps_codec -> s_parse . ps_slice_hdr ; ps_codec -> s_parse . s_deblk_ctxt . is_chroma_yuv420sp_vu = ( ps_codec -> e_ref_chroma_fmt == IV_YUV_420SP_VU ) ; ps_codec -> s_parse . s_sao_ctxt . ps_pps = ps_codec -> s_parse . ps_pps ; ps_codec -> s_parse . s_sao_ctxt . ps_sps = ps_codec -> s_parse . ps_sps ; ps_codec -> s_parse . s_sao_ctxt . ps_codec = ps_codec ; ps_codec -> s_parse . s_sao_ctxt . ps_slice_hdr = ps_codec -> s_parse . ps_slice_hdr ; ihevcd_ilf_pad_frame ( & ps_codec -> s_parse . s_deblk_ctxt , & ps_codec -> s_parse . s_sao_ctxt ) ; } # endif ps_codec -> s_parse . i4_end_of_frame = 1 ; } return ret ; }",) ) { ret = <S2SV_ModStart> ] ) ; if ( ret != ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ) { ps_codec -> i4_slice_error = 1 ; end_of_slice_flag = 1 ; ret = ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ; } <S2SV_ModStart> } } { ret = <S2SV_ModStart> ] ) ; if ( ret != ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ) { ps_codec -> i4_slice_error = 1 ; end_of_slice_flag = 1 ; ret = ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ; } <S2SV_ModStart> default_ctxt ) { ret = <S2SV_ModStart> ] ) ; if ( ret != ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ) { ps_codec -> i4_slice_error = 1 ; end_of_slice_flag = 1 ; ret = ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ; } <S2SV_ModStart> } else { ret = <S2SV_ModStart> au1_ctxt_models_sync ) ; if ( ret != ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ) { ps_codec -> i4_slice_error = 1 ; end_of_slice_flag = 1 ; ret = ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ; } <S2SV_ModStart> end_of_slice_flag ) ; ps_codec -> i4_slice_error = 0 ;
594,"static ngx_int_t ngx_http_auth_spnego_handler ( ngx_http_request_t * r ) { ngx_int_t ret = NGX_DECLINED ; ngx_http_auth_spnego_ctx_t * ctx ; ngx_http_auth_spnego_loc_conf_t * alcf ; alcf = ngx_http_get_module_loc_conf ( r , ngx_http_auth_spnego_module ) ; if ( alcf -> protect == 0 ) { return NGX_DECLINED ; } ctx = ngx_http_get_module_ctx ( r , ngx_http_auth_spnego_module ) ; if ( NULL == ctx ) { ctx = ngx_palloc ( r -> pool , sizeof ( ngx_http_auth_spnego_ctx_t ) ) ; if ( NULL == ctx ) { return NGX_HTTP_INTERNAL_SERVER_ERROR ; } ctx -> token . len = 0 ; ctx -> token . data = NULL ; ctx -> head = 0 ; ctx -> ret = NGX_HTTP_UNAUTHORIZED ; ngx_http_set_ctx ( r , ctx , ngx_http_auth_spnego_module ) ; } spnego_debug3 ( ""SSO<S2SV_blank>auth<S2SV_blank>handling<S2SV_blank>IN:<S2SV_blank>token.len=%d,<S2SV_blank>head=%d,<S2SV_blank>ret=%d"" , ctx -> token . len , ctx -> head , ctx -> ret ) ; if ( ctx -> token . len && ctx -> head ) { spnego_debug1 ( ""Found<S2SV_blank>token<S2SV_blank>and<S2SV_blank>head,<S2SV_blank>returning<S2SV_blank>%d"" , ctx -> ret ) ; return ctx -> ret ; } if ( NULL != r -> headers_in . user . data ) { spnego_debug0 ( ""User<S2SV_blank>header<S2SV_blank>set"" ) ; return NGX_OK ; } spnego_debug0 ( ""Begin<S2SV_blank>auth"" ) ; if ( alcf -> allow_basic ) { spnego_debug0 ( ""Detect<S2SV_blank>basic<S2SV_blank>auth"" ) ; ret = ngx_http_auth_basic_user ( r ) ; if ( NGX_OK == ret ) { spnego_debug0 ( ""Basic<S2SV_blank>auth<S2SV_blank>credentials<S2SV_blank>supplied<S2SV_blank>by<S2SV_blank>client"" ) ; <S2SV_StartBug> if ( NGX_DECLINED == ngx_http_auth_spnego_basic ( r , ctx , alcf ) ) { <S2SV_EndBug> spnego_debug0 ( ""Basic<S2SV_blank>auth<S2SV_blank>failed"" ) ; if ( NGX_ERROR == ngx_http_auth_spnego_headers_basic_only ( r , ctx , alcf ) ) { spnego_debug0 ( ""Error<S2SV_blank>setting<S2SV_blank>headers"" ) ; return ( ctx -> ret = NGX_HTTP_INTERNAL_SERVER_ERROR ) ; } return ( ctx -> ret = NGX_HTTP_UNAUTHORIZED ) ; } if ( ! ngx_spnego_authorized_principal ( r , & r -> headers_in . user , alcf ) ) { spnego_debug0 ( ""User<S2SV_blank>not<S2SV_blank>authorized"" ) ; return ( ctx -> ret = NGX_HTTP_FORBIDDEN ) ; } spnego_debug0 ( ""Basic<S2SV_blank>auth<S2SV_blank>succeeded"" ) ; return ( ctx -> ret = NGX_OK ) ; } } spnego_debug0 ( ""Detect<S2SV_blank>SPNEGO<S2SV_blank>token"" ) ; ret = ngx_http_auth_spnego_token ( r , ctx ) ; if ( NGX_OK == ret ) { spnego_debug0 ( ""Client<S2SV_blank>sent<S2SV_blank>a<S2SV_blank>reasonable<S2SV_blank>Negotiate<S2SV_blank>header"" ) ; ret = ngx_http_auth_spnego_auth_user_gss ( r , ctx , alcf ) ; if ( NGX_ERROR == ret ) { spnego_debug0 ( ""GSSAPI<S2SV_blank>failed"" ) ; return ( ctx -> ret = NGX_HTTP_INTERNAL_SERVER_ERROR ) ; } if ( NGX_DECLINED == ret ) { spnego_debug0 ( ""GSSAPI<S2SV_blank>failed"" ) ; if ( ! alcf -> allow_basic ) { return ( ctx -> ret = NGX_HTTP_FORBIDDEN ) ; } if ( NGX_ERROR == ngx_http_auth_spnego_headers_basic_only ( r , ctx , alcf ) ) { spnego_debug0 ( ""Error<S2SV_blank>setting<S2SV_blank>headers"" ) ; return ( ctx -> ret = NGX_HTTP_INTERNAL_SERVER_ERROR ) ; } return ( ctx -> ret = NGX_HTTP_UNAUTHORIZED ) ; } if ( ! ngx_spnego_authorized_principal ( r , & r -> headers_in . user , alcf ) ) { spnego_debug0 ( ""User<S2SV_blank>not<S2SV_blank>authorized"" ) ; return ( ctx -> ret = NGX_HTTP_FORBIDDEN ) ; } spnego_debug0 ( ""GSSAPI<S2SV_blank>auth<S2SV_blank>succeeded"" ) ; } ngx_str_t * token_out_b64 = NULL ; switch ( ret ) { case NGX_DECLINED : ctx -> ret = NGX_HTTP_UNAUTHORIZED ; break ; case NGX_OK : ctx -> ret = NGX_OK ; token_out_b64 = & ctx -> token_out_b64 ; break ; case NGX_ERROR : default : ctx -> ret = NGX_HTTP_INTERNAL_SERVER_ERROR ; break ; } if ( NGX_ERROR == ngx_http_auth_spnego_headers ( r , ctx , token_out_b64 , alcf ) ) { spnego_debug0 ( ""Error<S2SV_blank>setting<S2SV_blank>headers"" ) ; ctx -> ret = NGX_HTTP_INTERNAL_SERVER_ERROR ; } spnego_debug3 ( ""SSO<S2SV_blank>auth<S2SV_blank>handling<S2SV_blank>OUT:<S2SV_blank>token.len=%d,<S2SV_blank>head=%d,<S2SV_blank>ret=%d"" , ctx -> token . len , ctx -> head , ctx -> ret ) ; return ctx -> ret ; }",; if ( NGX_OK != <S2SV_ModEnd> ngx_http_auth_spnego_basic ( r
595,"static int mobility_opt_print ( netdissect_options * ndo , const u_char * bp , const unsigned len ) { unsigned i , optlen ; for ( i = 0 ; i < len ; i += optlen ) { ND_TCHECK ( bp [ i ] ) ; if ( bp [ i ] == IP6MOPT_PAD1 ) optlen = 1 ; else { if ( i + 1 < len ) { ND_TCHECK ( bp [ i + 1 ] ) ; optlen = bp [ i + 1 ] + 2 ; } else goto trunc ; } if ( i + optlen > len ) goto trunc ; ND_TCHECK ( bp [ i + optlen ] ) ; switch ( bp [ i ] ) { case IP6MOPT_PAD1 : ND_PRINT ( ( ndo , ""(pad1)"" ) ) ; break ; case IP6MOPT_PADN : if ( len - i < IP6MOPT_MINLEN ) { ND_PRINT ( ( ndo , ""(padn:<S2SV_blank>trunc)"" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""(padn)"" ) ) ; break ; case IP6MOPT_REFRESH : if ( len - i < IP6MOPT_REFRESH_MINLEN ) { ND_PRINT ( ( ndo , ""(refresh:<S2SV_blank>trunc)"" ) ) ; goto trunc ; } ND_TCHECK_16BITS ( & bp [ i + 2 ] ) ; ND_PRINT ( ( ndo , ""(refresh:<S2SV_blank>%u)"" , EXTRACT_16BITS ( & bp [ i + 2 ] ) << 2 ) ) ; break ; case IP6MOPT_ALTCOA : if ( len - i < IP6MOPT_ALTCOA_MINLEN ) { ND_PRINT ( ( ndo , ""(altcoa:<S2SV_blank>trunc)"" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""(alt-CoA:<S2SV_blank>%s)"" , ip6addr_string ( ndo , & bp [ i + 2 ] ) ) ) ; break ; case IP6MOPT_NONCEID : if ( len - i < IP6MOPT_NONCEID_MINLEN ) { ND_PRINT ( ( ndo , ""(ni:<S2SV_blank>trunc)"" ) ) ; goto trunc ; } <S2SV_StartBug> ND_PRINT ( ( ndo , ""(ni:<S2SV_blank>ho=0x%04x<S2SV_blank>co=0x%04x)"" , <S2SV_EndBug> EXTRACT_16BITS ( & bp [ i + 2 ] ) , EXTRACT_16BITS ( & bp [ i + 4 ] ) ) ) ; break ; case IP6MOPT_AUTH : if ( len - i < IP6MOPT_AUTH_MINLEN ) { ND_PRINT ( ( ndo , ""(auth:<S2SV_blank>trunc)"" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""(auth)"" ) ) ; break ; default : if ( len - i < IP6MOPT_MINLEN ) { ND_PRINT ( ( ndo , ""(sopt_type<S2SV_blank>%u:<S2SV_blank>trunc)"" , bp [ i ] ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""(type-0x%02x:<S2SV_blank>len=%u)"" , bp [ i ] , bp [ i + 1 ] ) ) ; break ; } } return 0 ; trunc : return 1 ; }",trunc ; } ND_TCHECK_16BITS ( & bp [ i + 2 ] ) ; ND_TCHECK_16BITS ( & bp [ i + 4 ] ) ;
596,"static unsigned long vp8_priv_sz ( const vpx_codec_dec_cfg_t * si , vpx_codec_flags_t flags ) { ( void ) si ; <S2SV_StartBug> return sizeof ( vpx_codec_alg_priv_t ) ; <S2SV_EndBug> }",) si ; ( void ) flags ;
597,"static int dtls1_process_record ( SSL * s ) { int i , al ; int enc_err ; SSL_SESSION * sess ; SSL3_RECORD * rr ; unsigned int mac_size ; unsigned char md [ EVP_MAX_MD_SIZE ] ; rr = & ( s -> s3 -> rrec ) ; sess = s -> session ; rr -> input = & ( s -> packet [ DTLS1_RT_HEADER_LENGTH ] ) ; if ( rr -> length > SSL3_RT_MAX_ENCRYPTED_LENGTH ) { al = SSL_AD_RECORD_OVERFLOW ; SSLerr ( SSL_F_DTLS1_PROCESS_RECORD , SSL_R_ENCRYPTED_LENGTH_TOO_LONG ) ; goto f_err ; } rr -> data = rr -> input ; rr -> orig_len = rr -> length ; enc_err = s -> method -> ssl3_enc -> enc ( s , 0 ) ; if ( enc_err == 0 ) { rr -> length = 0 ; s -> packet_length = 0 ; goto err ; } # ifdef TLS_DEBUG printf ( ""dec<S2SV_blank>%d\\n"" , rr -> length ) ; { unsigned int z ; for ( z = 0 ; z < rr -> length ; z ++ ) printf ( ""%02X%c"" , rr -> data [ z ] , ( ( z + 1 ) % 16 ) ? '<S2SV_blank>' : '\\n' ) ; } printf ( ""\\n"" ) ; # endif if ( ( sess != NULL ) && ( s -> enc_read_ctx != NULL ) && ( EVP_MD_CTX_md ( s -> read_hash ) != NULL ) ) { unsigned char * mac = NULL ; unsigned char mac_tmp [ EVP_MAX_MD_SIZE ] ; mac_size = EVP_MD_CTX_size ( s -> read_hash ) ; OPENSSL_assert ( mac_size <= EVP_MAX_MD_SIZE ) ; if ( rr -> orig_len < mac_size || ( EVP_CIPHER_CTX_mode ( s -> enc_read_ctx ) == EVP_CIPH_CBC_MODE && rr -> orig_len < mac_size + 1 ) ) { al = SSL_AD_DECODE_ERROR ; SSLerr ( SSL_F_DTLS1_PROCESS_RECORD , SSL_R_LENGTH_TOO_SHORT ) ; goto f_err ; } if ( EVP_CIPHER_CTX_mode ( s -> enc_read_ctx ) == EVP_CIPH_CBC_MODE ) { mac = mac_tmp ; ssl3_cbc_copy_mac ( mac_tmp , rr , mac_size ) ; rr -> length -= mac_size ; } else { rr -> length -= mac_size ; mac = & rr -> data [ rr -> length ] ; } i = s -> method -> ssl3_enc -> mac ( s , md , 0 ) ; if ( i < 0 || mac == NULL || CRYPTO_memcmp ( md , mac , ( size_t ) mac_size ) != 0 ) enc_err = - 1 ; if ( rr -> length > SSL3_RT_MAX_COMPRESSED_LENGTH + mac_size ) enc_err = - 1 ; } if ( enc_err < 0 ) { rr -> length = 0 ; s -> packet_length = 0 ; goto err ; } if ( s -> expand != NULL ) { if ( rr -> length > SSL3_RT_MAX_COMPRESSED_LENGTH ) { al = SSL_AD_RECORD_OVERFLOW ; SSLerr ( SSL_F_DTLS1_PROCESS_RECORD , SSL_R_COMPRESSED_LENGTH_TOO_LONG ) ; goto f_err ; } if ( ! ssl3_do_uncompress ( s ) ) { al = SSL_AD_DECOMPRESSION_FAILURE ; SSLerr ( SSL_F_DTLS1_PROCESS_RECORD , SSL_R_BAD_DECOMPRESSION ) ; goto f_err ; } } if ( rr -> length > SSL3_RT_MAX_PLAIN_LENGTH ) { al = SSL_AD_RECORD_OVERFLOW ; SSLerr ( SSL_F_DTLS1_PROCESS_RECORD , SSL_R_DATA_LENGTH_TOO_LONG ) ; goto f_err ; } rr -> off = 0 ; s -> packet_length = 0 ; <S2SV_StartBug> dtls1_record_bitmap_update ( s , & ( s -> d1 -> bitmap ) ) ; <S2SV_EndBug> return ( 1 ) ; f_err : ssl3_send_alert ( s , SSL3_AL_FATAL , al ) ; err : return ( 0 ) ; }",= 0 ; <S2SV_ModEnd> return ( 1
598,"static Image * ReadPDBImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { unsigned char attributes , tag [ 3 ] ; Image * image ; IndexPacket index ; MagickBooleanType status ; PDBImage pdb_image ; PDBInfo pdb_info ; register IndexPacket * indexes ; register ssize_t x ; register PixelPacket * q ; register unsigned char * p ; size_t bits_per_pixel , num_pad_bytes , one , packets ; ssize_t count , img_offset , comment_offset = 0 , y ; unsigned char * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } count = ReadBlob ( image , sizeof ( pdb_info . name ) , ( unsigned char * ) pdb_info . name ) ; if ( count != sizeof ( pdb_info . name ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; pdb_info . attributes = ( short ) ReadBlobMSBShort ( image ) ; pdb_info . version = ( short ) ReadBlobMSBShort ( image ) ; pdb_info . create_time = ReadBlobMSBLong ( image ) ; pdb_info . modify_time = ReadBlobMSBLong ( image ) ; pdb_info . archive_time = ReadBlobMSBLong ( image ) ; pdb_info . modify_number = ReadBlobMSBLong ( image ) ; pdb_info . application_info = ReadBlobMSBLong ( image ) ; pdb_info . sort_info = ReadBlobMSBLong ( image ) ; ( void ) ReadBlob ( image , 4 , ( unsigned char * ) pdb_info . type ) ; ( void ) ReadBlob ( image , 4 , ( unsigned char * ) pdb_info . id ) ; pdb_info . seed = ReadBlobMSBLong ( image ) ; pdb_info . next_record = ReadBlobMSBLong ( image ) ; pdb_info . number_records = ( short ) ReadBlobMSBShort ( image ) ; if ( ( memcmp ( pdb_info . type , ""vIMG"" , 4 ) != 0 ) || ( memcmp ( pdb_info . id , ""View"" , 4 ) != 0 ) ) if ( pdb_info . next_record != 0 ) ThrowReaderException ( CoderError , ""MultipleRecordListNotSupported"" ) ; img_offset = ( ssize_t ) ( ( int ) ReadBlobMSBLong ( image ) ) ; attributes = ( unsigned char ) ( ( int ) ReadBlobByte ( image ) ) ; ( void ) attributes ; count = ReadBlob ( image , 3 , ( unsigned char * ) tag ) ; if ( count != 3 || memcmp ( tag , ""\\x6f\\x80\\x00"" , 3 ) != 0 ) ThrowReaderException ( CorruptImageError , ""CorruptImage"" ) ; if ( pdb_info . number_records > 1 ) { comment_offset = ( ssize_t ) ( ( int ) ReadBlobMSBLong ( image ) ) ; attributes = ( unsigned char ) ( ( int ) ReadBlobByte ( image ) ) ; count = ReadBlob ( image , 3 , ( unsigned char * ) tag ) ; if ( count != 3 || memcmp ( tag , ""\\x6f\\x80\\x01"" , 3 ) != 0 ) ThrowReaderException ( CorruptImageError , ""CorruptImage"" ) ; } num_pad_bytes = ( size_t ) ( img_offset - TellBlob ( image ) ) ; while ( num_pad_bytes -- != 0 ) { int c ; c = ReadBlobByte ( image ) ; if ( c == EOF ) break ; } count = ReadBlob ( image , sizeof ( pdb_image . name ) , ( unsigned char * ) pdb_image . name ) ; if ( count != sizeof ( pdb_image . name ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; pdb_image . version = ReadBlobByte ( image ) ; pdb_image . type = ( unsigned char ) ReadBlobByte ( image ) ; pdb_image . reserved_1 = ReadBlobMSBLong ( image ) ; pdb_image . note = ReadBlobMSBLong ( image ) ; pdb_image . x_last = ( short ) ReadBlobMSBShort ( image ) ; pdb_image . y_last = ( short ) ReadBlobMSBShort ( image ) ; pdb_image . reserved_2 = ReadBlobMSBLong ( image ) ; pdb_image . x_anchor = ReadBlobMSBShort ( image ) ; pdb_image . y_anchor = ReadBlobMSBShort ( image ) ; pdb_image . width = ( short ) ReadBlobMSBShort ( image ) ; pdb_image . height = ( short ) ReadBlobMSBShort ( image ) ; image -> columns = ( size_t ) pdb_image . width ; image -> rows = ( size_t ) pdb_image . height ; image -> depth = 8 ; image -> storage_class = PseudoClass ; bits_per_pixel = pdb_image . type == 0 ? 2UL : pdb_image . type == 2 ? 4UL : 1UL ; one = 1 ; if ( AcquireImageColormap ( image , one << bits_per_pixel ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; if ( image_info -> ping != MagickFalse ) { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } packets = ( bits_per_pixel * image -> columns + 7 ) / 8 ; <S2SV_StartBug> pixels = ( unsigned char * ) AcquireQuantumMemory ( packets + 256UL , image -> rows * <S2SV_EndBug> sizeof ( * pixels ) ) ; if ( pixels == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; switch ( pdb_image . version & 0x07 ) { case 0 : { image -> compression = NoCompression ; count = ( ssize_t ) ReadBlob ( image , packets * image -> rows , pixels ) ; break ; } case 1 : { image -> compression = RLECompression ; if ( ! DecodeImage ( image , pixels , packets * image -> rows ) ) ThrowReaderException ( CorruptImageError , ""RLEDecoderError"" ) ; break ; } default : ThrowReaderException ( CorruptImageError , ""UnrecognizedImageCompressionType"" ) ; } p = pixels ; switch ( bits_per_pixel ) { case 1 : { int bit ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; indexes = GetAuthenticIndexQueue ( image ) ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 7 ) ; x += 8 ) { for ( bit = 0 ; bit < 8 ; bit ++ ) { index = ( IndexPacket ) ( * p & ( 0x80 >> bit ) ? 0x00 : 0x01 ) ; SetPixelIndex ( indexes + x + bit , index ) ; } p ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } ( void ) SyncImage ( image ) ; break ; } case 2 : { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; indexes = GetAuthenticIndexQueue ( image ) ; for ( x = 0 ; x < ( ssize_t ) image -> columns - 3 ; x += 4 ) { index = ConstrainColormapIndex ( image , 3UL - ( ( * p >> 6 ) & 0x03 ) ) ; SetPixelIndex ( indexes + x , index ) ; index = ConstrainColormapIndex ( image , 3UL - ( ( * p >> 4 ) & 0x03 ) ) ; SetPixelIndex ( indexes + x + 1 , index ) ; index = ConstrainColormapIndex ( image , 3UL - ( ( * p >> 2 ) & 0x03 ) ) ; SetPixelIndex ( indexes + x + 2 , index ) ; index = ConstrainColormapIndex ( image , 3UL - ( ( * p ) & 0x03 ) ) ; SetPixelIndex ( indexes + x + 3 , index ) ; p ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } ( void ) SyncImage ( image ) ; break ; } case 4 : { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; indexes = GetAuthenticIndexQueue ( image ) ; for ( x = 0 ; x < ( ssize_t ) image -> columns - 1 ; x += 2 ) { index = ConstrainColormapIndex ( image , 15UL - ( ( * p >> 4 ) & 0x0f ) ) ; SetPixelIndex ( indexes + x , index ) ; index = ConstrainColormapIndex ( image , 15UL - ( ( * p ) & 0x0f ) ) ; SetPixelIndex ( indexes + x + 1 , index ) ; p ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } ( void ) SyncImage ( image ) ; break ; } default : ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } pixels = ( unsigned char * ) RelinquishMagickMemory ( pixels ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; if ( pdb_info . number_records > 1 ) { char * comment ; int c ; register char * p ; size_t length ; num_pad_bytes = ( size_t ) ( comment_offset - TellBlob ( image ) ) ; while ( num_pad_bytes -- ) ReadBlobByte ( image ) ; c = ReadBlobByte ( image ) ; length = MaxTextExtent ; comment = AcquireString ( ( char * ) NULL ) ; for ( p = comment ; c != EOF ; p ++ ) { if ( ( size_t ) ( p - comment + MaxTextExtent ) >= length ) { * p = '\\0' ; length <<= 1 ; length += MaxTextExtent ; comment = ( char * ) ResizeQuantumMemory ( comment , length + MaxTextExtent , sizeof ( * comment ) ) ; if ( comment == ( char * ) NULL ) break ; p = comment + strlen ( comment ) ; } * p = c ; c = ReadBlobByte ( image ) ; } * p = '\\0' ; if ( comment == ( char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) SetImageProperty ( image , ""comment"" , comment ) ; comment = DestroyString ( comment ) ; } ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }","( packets + 257UL <S2SV_ModEnd> , image ->"
599,"static void pipe_advance ( struct iov_iter * i , size_t size ) { struct pipe_inode_info * pipe = i -> pipe ; <S2SV_StartBug> struct pipe_buffer * buf ; <S2SV_EndBug> int idx = i -> idx ; size_t off = i -> iov_offset , orig_sz ; if ( unlikely ( i -> count < size ) ) size = i -> count ; <S2SV_StartBug> orig_sz = size ; <S2SV_EndBug> if ( size ) { <S2SV_StartBug> if ( off ) <S2SV_EndBug> <S2SV_StartBug> size += off - pipe -> bufs [ idx ] . offset ; <S2SV_EndBug> while ( 1 ) { buf = & pipe -> bufs [ idx ] ; <S2SV_StartBug> if ( size <= buf -> len ) <S2SV_EndBug> break ; <S2SV_StartBug> size -= buf -> len ; <S2SV_EndBug> idx = next_idx ( idx , pipe ) ; } <S2SV_StartBug> buf -> len = size ; <S2SV_EndBug> i -> idx = idx ; <S2SV_StartBug> off = i -> iov_offset = buf -> offset + size ; <S2SV_EndBug> } if ( off ) idx = next_idx ( idx , pipe ) ; if ( pipe -> nrbufs ) { int unused = ( pipe -> curbuf + pipe -> nrbufs ) & ( pipe -> buffers - 1 ) ; while ( idx != unused ) { pipe_buf_release ( pipe , & pipe -> bufs [ idx ] ) ; idx = next_idx ( idx , pipe ) ; pipe -> nrbufs -- ; } } <S2SV_StartBug> i -> count -= orig_sz ; <S2SV_EndBug> }","-> pipe ; <S2SV_ModEnd> if ( unlikely <S2SV_ModStart> -> count ; <S2SV_ModEnd> if ( size <S2SV_ModStart> size ) { struct pipe_buffer * buf ; size_t off = i -> iov_offset , left = size ; int idx = i -> idx ; <S2SV_ModStart> ( off ) left <S2SV_ModEnd> += off - <S2SV_ModStart> ; if ( left <S2SV_ModEnd> <= buf -> <S2SV_ModStart> ) break ; left <S2SV_ModEnd> -= buf -> <S2SV_ModStart> ) ; } <S2SV_ModEnd> i -> idx <S2SV_ModStart> = idx ; <S2SV_ModEnd> i -> iov_offset <S2SV_ModStart> -> offset + left ; <S2SV_ModEnd> } i -> <S2SV_ModStart> -> count -= size ; pipe_truncate ( i ) <S2SV_ModEnd> ; } <S2SV_null>"
600,"static int cqspi_setup_flash ( struct cqspi_st * cqspi , struct device_node * np ) { struct platform_device * pdev = cqspi -> pdev ; struct device * dev = & pdev -> dev ; struct cqspi_flash_pdata * f_pdata ; struct spi_nor * nor ; struct mtd_info * mtd ; unsigned int cs ; int i , ret ; for_each_available_child_of_node ( dev -> of_node , np ) { if ( of_property_read_u32 ( np , ""reg"" , & cs ) ) { dev_err ( dev , ""Couldn\'t<S2SV_blank>determine<S2SV_blank>chip<S2SV_blank>select.\\n"" ) ; goto err ; } <S2SV_StartBug> if ( cs > CQSPI_MAX_CHIPSELECT ) { <S2SV_EndBug> dev_err ( dev , ""Chip<S2SV_blank>select<S2SV_blank>%d<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range.\\n"" , cs ) ; goto err ; } f_pdata = & cqspi -> f_pdata [ cs ] ; f_pdata -> cqspi = cqspi ; f_pdata -> cs = cs ; ret = cqspi_of_get_flash_pdata ( pdev , f_pdata , np ) ; if ( ret ) goto err ; nor = & f_pdata -> nor ; mtd = & nor -> mtd ; mtd -> priv = nor ; nor -> dev = dev ; spi_nor_set_flash_node ( nor , np ) ; nor -> priv = f_pdata ; nor -> read_reg = cqspi_read_reg ; nor -> write_reg = cqspi_write_reg ; nor -> read = cqspi_read ; nor -> write = cqspi_write ; nor -> erase = cqspi_erase ; nor -> prepare = cqspi_prep ; nor -> unprepare = cqspi_unprep ; mtd -> name = devm_kasprintf ( dev , GFP_KERNEL , ""%s.%d"" , dev_name ( dev ) , cs ) ; if ( ! mtd -> name ) { ret = - ENOMEM ; goto err ; } ret = spi_nor_scan ( nor , NULL , SPI_NOR_QUAD ) ; if ( ret ) goto err ; ret = mtd_device_register ( mtd , NULL , 0 ) ; if ( ret ) goto err ; f_pdata -> registered = true ; } return 0 ; err : for ( i = 0 ; i < CQSPI_MAX_CHIPSELECT ; i ++ ) if ( cqspi -> f_pdata [ i ] . registered ) mtd_device_unregister ( & cqspi -> f_pdata [ i ] . nor . mtd ) ; return ret ; }",if ( cs >= <S2SV_ModEnd> CQSPI_MAX_CHIPSELECT ) {
601,"int kvm_iommu_map_pages ( struct kvm * kvm , struct kvm_memory_slot * slot ) { gfn_t gfn , end_gfn ; pfn_t pfn ; int r = 0 ; struct iommu_domain * domain = kvm -> arch . iommu_domain ; int flags ; if ( ! domain ) return 0 ; gfn = slot -> base_gfn ; end_gfn = gfn + slot -> npages ; flags = IOMMU_READ ; if ( ! ( slot -> flags & KVM_MEM_READONLY ) ) flags |= IOMMU_WRITE ; if ( ! kvm -> arch . iommu_noncoherent ) flags |= IOMMU_CACHE ; while ( gfn < end_gfn ) { unsigned long page_size ; if ( iommu_iova_to_phys ( domain , gfn_to_gpa ( gfn ) ) ) { gfn += 1 ; continue ; } page_size = kvm_host_page_size ( kvm , gfn ) ; while ( ( gfn + ( page_size >> PAGE_SHIFT ) ) > end_gfn ) page_size >>= 1 ; while ( ( gfn << PAGE_SHIFT ) & ( page_size - 1 ) ) page_size >>= 1 ; while ( __gfn_to_hva_memslot ( slot , gfn ) & ( page_size - 1 ) ) page_size >>= 1 ; pfn = kvm_pin_pages ( slot , gfn , page_size ) ; if ( is_error_noslot_pfn ( pfn ) ) { gfn += 1 ; continue ; } r = iommu_map ( domain , gfn_to_gpa ( gfn ) , pfn_to_hpa ( pfn ) , page_size , flags ) ; if ( r ) { printk ( KERN_ERR ""kvm_iommu_map_address:"" ""iommu<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>map<S2SV_blank>pfn=%llx\\n"" , pfn ) ; <S2SV_StartBug> goto unmap_pages ; <S2SV_EndBug> } gfn += page_size >> PAGE_SHIFT ; } return 0 ; unmap_pages : <S2SV_StartBug> kvm_iommu_put_pages ( kvm , slot -> base_gfn , gfn ) ; <S2SV_EndBug> return r ; }","pfn ) ; kvm_unpin_pages ( kvm , pfn , page_size ) ; <S2SV_ModStart> base_gfn , gfn - slot -> base_gfn"
602,"<S2SV_StartBug> struct key * find_keyring_by_name ( const char * name , bool skip_perm_check ) <S2SV_EndBug> { struct key * keyring ; int bucket ; if ( ! name ) return ERR_PTR ( - EINVAL ) ; bucket = keyring_hash ( name ) ; read_lock ( & keyring_name_lock ) ; if ( keyring_name_hash [ bucket ] . next ) { list_for_each_entry ( keyring , & keyring_name_hash [ bucket ] , name_link ) { if ( ! kuid_has_mapping ( current_user_ns ( ) , keyring -> user -> uid ) ) continue ; if ( test_bit ( KEY_FLAG_REVOKED , & keyring -> flags ) ) continue ; if ( strcmp ( keyring -> description , name ) != 0 ) continue ; <S2SV_StartBug> if ( ! skip_perm_check && <S2SV_EndBug> key_permission ( make_key_ref ( keyring , 0 ) , KEY_NEED_SEARCH ) < 0 ) <S2SV_StartBug> continue ; <S2SV_EndBug> if ( ! refcount_inc_not_zero ( & keyring -> usage ) ) continue ; keyring -> last_used_at = current_kernel_time ( ) . tv_sec ; goto out ; } } keyring = ERR_PTR ( - ENOKEY ) ; out : read_unlock ( & keyring_name_lock ) ; return keyring ; }","name , bool uid_keyring <S2SV_ModEnd> ) { struct <S2SV_ModStart> ; if ( uid_keyring ) { if ( ! test_bit ( KEY_FLAG_UID_KEYRING , & keyring -> flags ) ) continue ; } else { if ( <S2SV_ModEnd> key_permission ( make_key_ref <S2SV_ModStart> ) continue ; }"
603,"int yr_execute_code ( YR_RULES * rules , YR_SCAN_CONTEXT * context , int timeout , time_t start_time ) { int64_t mem [ MEM_SIZE ] ; int32_t sp = 0 ; uint8_t * ip = rules -> code_start ; YR_VALUE args [ MAX_FUNCTION_ARGS ] ; YR_VALUE * stack ; YR_VALUE r1 ; YR_VALUE r2 ; YR_VALUE r3 ; # ifdef PROFILING_ENABLED YR_RULE * current_rule = NULL ; # endif YR_RULE * rule ; YR_MATCH * match ; YR_OBJECT_FUNCTION * function ; <S2SV_StartBug> char * identifier ; <S2SV_EndBug> char * args_fmt ; int i ; int found ; int count ; int result = ERROR_SUCCESS ; int stop = FALSE ; int cycle = 0 ; int tidx = context -> tidx ; int stack_size ; # ifdef PROFILING_ENABLED clock_t start = clock ( ) ; # endif yr_get_configuration ( YR_CONFIG_STACK_SIZE , ( void * ) & stack_size ) ; stack = ( YR_VALUE * ) yr_malloc ( stack_size * sizeof ( YR_VALUE ) ) ; if ( stack == NULL ) <S2SV_StartBug> return ERROR_INSUFFICIENT_MEMORY ; <S2SV_EndBug> while ( ! stop ) { switch ( * ip ) { case OP_NOP : break ; case OP_HALT : assert ( sp == 0 ) ; stop = TRUE ; break ; case OP_PUSH : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; push ( r1 ) ; break ; case OP_POP : pop ( r1 ) ; break ; case OP_CLEAR_M : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; mem [ r1 . i ] = 0 ; break ; case OP_ADD_M : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; pop ( r2 ) ; if ( ! is_undef ( r2 ) ) mem [ r1 . i ] += r2 . i ; break ; case OP_INCR_M : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; mem [ r1 . i ] ++ ; break ; case OP_PUSH_M : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; r1 . i = mem [ r1 . i ] ; push ( r1 ) ; break ; case OP_POP_M : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; pop ( r2 ) ; mem [ r1 . i ] = r2 . i ; break ; case OP_SWAPUNDEF : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; pop ( r2 ) ; if ( is_undef ( r2 ) ) { r1 . i = mem [ r1 . i ] ; push ( r1 ) ; } else { push ( r2 ) ; } break ; case OP_JNUNDEF : pop ( r1 ) ; push ( r1 ) ; ip = jmp_if ( ! is_undef ( r1 ) , ip ) ; break ; case OP_JLE : pop ( r2 ) ; pop ( r1 ) ; push ( r1 ) ; push ( r2 ) ; ip = jmp_if ( r1 . i <= r2 . i , ip ) ; break ; case OP_JTRUE : pop ( r1 ) ; push ( r1 ) ; ip = jmp_if ( ! is_undef ( r1 ) && r1 . i , ip ) ; break ; case OP_JFALSE : pop ( r1 ) ; push ( r1 ) ; ip = jmp_if ( is_undef ( r1 ) || ! r1 . i , ip ) ; break ; case OP_AND : pop ( r2 ) ; pop ( r1 ) ; if ( is_undef ( r1 ) || is_undef ( r2 ) ) r1 . i = 0 ; else r1 . i = r1 . i && r2 . i ; push ( r1 ) ; break ; case OP_OR : pop ( r2 ) ; pop ( r1 ) ; if ( is_undef ( r1 ) ) { push ( r2 ) ; } else if ( is_undef ( r2 ) ) { push ( r1 ) ; } else { r1 . i = r1 . i || r2 . i ; push ( r1 ) ; } break ; case OP_NOT : pop ( r1 ) ; if ( is_undef ( r1 ) ) r1 . i = UNDEFINED ; else r1 . i = ! r1 . i ; push ( r1 ) ; break ; case OP_MOD : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; if ( r2 . i != 0 ) r1 . i = r1 . i % r2 . i ; else r1 . i = UNDEFINED ; push ( r1 ) ; break ; case OP_SHR : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i >> r2 . i ; push ( r1 ) ; break ; case OP_SHL : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i << r2 . i ; push ( r1 ) ; break ; case OP_BITWISE_NOT : pop ( r1 ) ; ensure_defined ( r1 ) ; r1 . i = ~ r1 . i ; push ( r1 ) ; break ; case OP_BITWISE_AND : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i & r2 . i ; push ( r1 ) ; break ; case OP_BITWISE_OR : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i | r2 . i ; push ( r1 ) ; break ; case OP_BITWISE_XOR : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i ^ r2 . i ; push ( r1 ) ; break ; case OP_PUSH_RULE : rule = * ( YR_RULE * * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; r1 . i = rule -> t_flags [ tidx ] & RULE_TFLAGS_MATCH ? 1 : 0 ; push ( r1 ) ; break ; case OP_INIT_RULE : # ifdef PROFILING_ENABLED current_rule = * ( YR_RULE * * ) ( ip + 1 ) ; # endif ip += sizeof ( uint64_t ) ; break ; case OP_MATCH_RULE : pop ( r1 ) ; rule = * ( YR_RULE * * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; if ( ! is_undef ( r1 ) && r1 . i ) rule -> t_flags [ tidx ] |= RULE_TFLAGS_MATCH ; else if ( RULE_IS_GLOBAL ( rule ) ) rule -> ns -> t_flags [ tidx ] |= NAMESPACE_TFLAGS_UNSATISFIED_GLOBAL ; # ifdef PROFILING_ENABLED rule -> clock_ticks += clock ( ) - start ; start = clock ( ) ; # endif <S2SV_StartBug> break ; <S2SV_EndBug> case OP_OBJ_LOAD : identifier = * ( char * * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; r1 . o = ( YR_OBJECT * ) yr_hash_table_lookup ( context -> objects_table , identifier , NULL ) ; assert ( r1 . o != NULL ) ; push ( r1 ) ; break ; case OP_OBJ_FIELD : identifier = * ( char * * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; pop ( r1 ) ; ensure_defined ( r1 ) ; r1 . o = yr_object_lookup_field ( r1 . o , identifier ) ; assert ( r1 . o != NULL ) ; push ( r1 ) ; break ; case OP_OBJ_VALUE : pop ( r1 ) ; ensure_defined ( r1 ) ; switch ( r1 . o -> type ) { case OBJECT_TYPE_INTEGER : r1 . i = ( ( YR_OBJECT_INTEGER * ) r1 . o ) -> value ; break ; case OBJECT_TYPE_FLOAT : if ( isnan ( ( ( YR_OBJECT_DOUBLE * ) r1 . o ) -> value ) ) r1 . i = UNDEFINED ; else r1 . d = ( ( YR_OBJECT_DOUBLE * ) r1 . o ) -> value ; break ; case OBJECT_TYPE_STRING : if ( ( ( YR_OBJECT_STRING * ) r1 . o ) -> value == NULL ) r1 . i = UNDEFINED ; else r1 . p = ( ( YR_OBJECT_STRING * ) r1 . o ) -> value ; break ; default : assert ( FALSE ) ; } push ( r1 ) ; break ; case OP_INDEX_ARRAY : pop ( r1 ) ; pop ( r2 ) ; ensure_defined ( r1 ) ; ensure_defined ( r2 ) ; assert ( r2 . o -> type == OBJECT_TYPE_ARRAY ) ; r1 . o = yr_object_array_get_item ( r2 . o , 0 , ( int ) r1 . i ) ; if ( r1 . o == NULL ) r1 . i = UNDEFINED ; push ( r1 ) ; break ; case OP_LOOKUP_DICT : pop ( r1 ) ; pop ( r2 ) ; ensure_defined ( r1 ) ; ensure_defined ( r2 ) ; assert ( r2 . o -> type == OBJECT_TYPE_DICTIONARY ) ; r1 . o = yr_object_dict_get_item ( r2 . o , 0 , r1 . ss -> c_string ) ; if ( r1 . o == NULL ) r1 . i = UNDEFINED ; push ( r1 ) ; break ; case OP_CALL : args_fmt = * ( char * * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; i = ( int ) strlen ( args_fmt ) ; count = 0 ; while ( i > 0 ) { pop ( r1 ) ; if ( is_undef ( r1 ) ) count ++ ; args [ i - 1 ] = r1 ; i -- ; } pop ( r2 ) ; ensure_defined ( r2 ) ; if ( count > 0 ) { r1 . i = UNDEFINED ; push ( r1 ) ; break ; } function = ( YR_OBJECT_FUNCTION * ) r2 . o ; result = ERROR_INTERNAL_FATAL_ERROR ; for ( i = 0 ; i < MAX_OVERLOADED_FUNCTIONS ; i ++ ) { if ( function -> prototypes [ i ] . arguments_fmt == NULL ) break ; if ( strcmp ( function -> prototypes [ i ] . arguments_fmt , args_fmt ) == 0 ) { result = function -> prototypes [ i ] . code ( args , context , function ) ; break ; } } assert ( i < MAX_OVERLOADED_FUNCTIONS ) ; if ( result == ERROR_SUCCESS ) <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> r1 . o = function -> return_obj ; <S2SV_EndBug> push ( r1 ) ; } else { stop = TRUE ; } break ; case OP_FOUND : pop ( r1 ) ; r1 . i = r1 . s -> matches [ tidx ] . tail != NULL ? 1 : 0 ; push ( r1 ) ; break ; case OP_FOUND_AT : pop ( r2 ) ; pop ( r1 ) ; if ( is_undef ( r1 ) ) { r1 . i = 0 ; push ( r1 ) ; break ; } match = r2 . s -> matches [ tidx ] . head ; r3 . i = FALSE ; while ( match != NULL ) { if ( r1 . i == match -> base + match -> offset ) { r3 . i = TRUE ; break ; } if ( r1 . i < match -> base + match -> offset ) break ; match = match -> next ; } push ( r3 ) ; break ; case OP_FOUND_IN : pop ( r3 ) ; pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r1 ) ; ensure_defined ( r2 ) ; match = r3 . s -> matches [ tidx ] . head ; r3 . i = FALSE ; while ( match != NULL && ! r3 . i ) { if ( match -> base + match -> offset >= r1 . i && match -> base + match -> offset <= r2 . i ) { r3 . i = TRUE ; } if ( match -> base + match -> offset > r2 . i ) break ; match = match -> next ; } push ( r3 ) ; break ; case OP_COUNT : pop ( r1 ) ; r1 . i = r1 . s -> matches [ tidx ] . count ; push ( r1 ) ; break ; case OP_OFFSET : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r1 ) ; match = r2 . s -> matches [ tidx ] . head ; i = 1 ; r3 . i = UNDEFINED ; while ( match != NULL && r3 . i == UNDEFINED ) { if ( r1 . i == i ) r3 . i = match -> base + match -> offset ; i ++ ; match = match -> next ; } push ( r3 ) ; break ; case OP_LENGTH : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r1 ) ; match = r2 . s -> matches [ tidx ] . head ; i = 1 ; r3 . i = UNDEFINED ; while ( match != NULL && r3 . i == UNDEFINED ) { if ( r1 . i == i ) r3 . i = match -> match_length ; i ++ ; match = match -> next ; } push ( r3 ) ; break ; case OP_OF : found = 0 ; count = 0 ; pop ( r1 ) ; while ( ! is_undef ( r1 ) ) { if ( r1 . s -> matches [ tidx ] . tail != NULL ) found ++ ; count ++ ; pop ( r1 ) ; } pop ( r2 ) ; if ( is_undef ( r2 ) ) r1 . i = found >= count ? 1 : 0 ; else r1 . i = found >= r2 . i ? 1 : 0 ; push ( r1 ) ; break ; case OP_FILESIZE : r1 . i = context -> file_size ; push ( r1 ) ; break ; case OP_ENTRYPOINT : r1 . i = context -> entry_point ; push ( r1 ) ; break ; case OP_INT8 : pop ( r1 ) ; r1 . i = read_int8_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_INT16 : pop ( r1 ) ; r1 . i = read_int16_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_INT32 : pop ( r1 ) ; r1 . i = read_int32_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_UINT8 : pop ( r1 ) ; r1 . i = read_uint8_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_UINT16 : pop ( r1 ) ; r1 . i = read_uint16_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_UINT32 : pop ( r1 ) ; r1 . i = read_uint32_t_little_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_INT8BE : pop ( r1 ) ; r1 . i = read_int8_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_INT16BE : pop ( r1 ) ; r1 . i = read_int16_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_INT32BE : pop ( r1 ) ; r1 . i = read_int32_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_UINT8BE : pop ( r1 ) ; r1 . i = read_uint8_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_UINT16BE : pop ( r1 ) ; r1 . i = read_uint16_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_UINT32BE : pop ( r1 ) ; r1 . i = read_uint32_t_big_endian ( context -> iterator , ( size_t ) r1 . i ) ; push ( r1 ) ; break ; case OP_CONTAINS : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r1 ) ; ensure_defined ( r2 ) ; r1 . i = memmem ( r1 . ss -> c_string , r1 . ss -> length , r2 . ss -> c_string , r2 . ss -> length ) != NULL ; push ( r1 ) ; break ; case OP_IMPORT : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; result = yr_modules_load ( ( char * ) r1 . p , context ) ; if ( result != ERROR_SUCCESS ) stop = TRUE ; break ; case OP_MATCHES : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; if ( r1 . ss -> length == 0 ) { r1 . i = FALSE ; push ( r1 ) ; break ; } result = yr_re_exec ( ( uint8_t * ) r2 . re -> code , ( uint8_t * ) r1 . ss -> c_string , r1 . ss -> length , 0 , r2 . re -> flags | RE_FLAGS_SCAN , NULL , NULL , & found ) ; if ( result != ERROR_SUCCESS ) stop = TRUE ; r1 . i = found >= 0 ; push ( r1 ) ; break ; case OP_INT_TO_DBL : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; r2 = stack [ sp - r1 . i ] ; if ( is_undef ( r2 ) ) stack [ sp - r1 . i ] . i = UNDEFINED ; else stack [ sp - r1 . i ] . d = ( double ) r2 . i ; break ; case OP_STR_TO_BOOL : pop ( r1 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . ss -> length > 0 ; push ( r1 ) ; break ; case OP_INT_EQ : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i == r2 . i ; push ( r1 ) ; break ; case OP_INT_NEQ : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i != r2 . i ; push ( r1 ) ; break ; case OP_INT_LT : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i < r2 . i ; push ( r1 ) ; break ; case OP_INT_GT : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i > r2 . i ; push ( r1 ) ; break ; case OP_INT_LE : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i <= r2 . i ; push ( r1 ) ; break ; case OP_INT_GE : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i >= r2 . i ; push ( r1 ) ; break ; case OP_INT_ADD : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i + r2 . i ; push ( r1 ) ; break ; case OP_INT_SUB : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i - r2 . i ; push ( r1 ) ; break ; case OP_INT_MUL : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . i * r2 . i ; push ( r1 ) ; break ; case OP_INT_DIV : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; if ( r2 . i != 0 ) r1 . i = r1 . i / r2 . i ; else r1 . i = UNDEFINED ; push ( r1 ) ; break ; case OP_INT_MINUS : pop ( r1 ) ; ensure_defined ( r1 ) ; r1 . i = - r1 . i ; push ( r1 ) ; break ; case OP_DBL_LT : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . d < r2 . d ; push ( r1 ) ; break ; case OP_DBL_GT : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . d > r2 . d ; push ( r1 ) ; break ; case OP_DBL_LE : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . d <= r2 . d ; push ( r1 ) ; break ; case OP_DBL_GE : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . d >= r2 . d ; push ( r1 ) ; break ; case OP_DBL_EQ : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . d == r2 . d ; push ( r1 ) ; break ; case OP_DBL_NEQ : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . i = r1 . d != r2 . d ; push ( r1 ) ; break ; case OP_DBL_ADD : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . d = r1 . d + r2 . d ; push ( r1 ) ; break ; case OP_DBL_SUB : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . d = r1 . d - r2 . d ; push ( r1 ) ; break ; case OP_DBL_MUL : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . d = r1 . d * r2 . d ; push ( r1 ) ; break ; case OP_DBL_DIV : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r2 ) ; ensure_defined ( r1 ) ; r1 . d = r1 . d / r2 . d ; push ( r1 ) ; break ; case OP_DBL_MINUS : pop ( r1 ) ; ensure_defined ( r1 ) ; r1 . d = - r1 . d ; push ( r1 ) ; break ; case OP_STR_EQ : case OP_STR_NEQ : case OP_STR_LT : case OP_STR_LE : case OP_STR_GT : case OP_STR_GE : pop ( r2 ) ; pop ( r1 ) ; ensure_defined ( r1 ) ; ensure_defined ( r2 ) ; switch ( * ip ) { case OP_STR_EQ : r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) == 0 ) ; break ; case OP_STR_NEQ : r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) != 0 ) ; break ; case OP_STR_LT : r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) < 0 ) ; break ; case OP_STR_LE : r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) <= 0 ) ; break ; case OP_STR_GT : r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) > 0 ) ; break ; case OP_STR_GE : r1 . i = ( sized_string_cmp ( r1 . ss , r2 . ss ) >= 0 ) ; break ; } push ( r1 ) ; break ; default : assert ( FALSE ) ; } if ( timeout > 0 ) { if ( ++ cycle == 10 ) { if ( difftime ( time ( NULL ) , start_time ) > timeout ) { # ifdef PROFILING_ENABLED assert ( current_rule != NULL ) ; current_rule -> clock_ticks += clock ( ) - start ; # endif result = ERROR_SCAN_TIMEOUT ; stop = TRUE ; } cycle = 0 ; } } ip ++ ; } <S2SV_StartBug> yr_modules_unload_all ( context ) ; <S2SV_EndBug> yr_free ( stack ) ; return result ; }","* function ; YR_OBJECT * * obj_ptr ; YR_ARENA * obj_arena ; <S2SV_ModStart> ) return ERROR_INSUFFICIENT_MEMORY ; FAIL_ON_ERROR_WITH_CLEANUP ( yr_arena_create ( 1024 , 0 , & obj_arena ) , yr_free ( stack ) ) <S2SV_ModStart> ; # endif assert ( sp == 0 ) ; <S2SV_ModStart> == ERROR_SUCCESS ) result = yr_object_copy ( function -> return_obj , & <S2SV_ModEnd> r1 . o <S2SV_ModStart> r1 . o ) ; if ( result == ERROR_SUCCESS ) result = yr_arena_write_data ( obj_arena , & r1 . o , sizeof ( r1 . o ) , NULL ) ; stop = ( result != ERROR_SUCCESS ) ; push ( r1 ) ; <S2SV_ModEnd> break ; case <S2SV_ModStart> ++ ; } obj_ptr = ( YR_OBJECT * * ) yr_arena_base_address ( obj_arena ) ; while ( obj_ptr != NULL ) { yr_object_destroy ( * obj_ptr ) ; obj_ptr = ( YR_OBJECT * * ) yr_arena_next_address ( obj_arena , obj_ptr , sizeof ( YR_OBJECT * ) ) ; } yr_arena_destroy ( obj_arena ) ;"
604,"vpx_codec_err_t vpx_codec_get_stream_info ( vpx_codec_ctx_t * ctx , vpx_codec_stream_info_t * si ) { vpx_codec_err_t res ; if ( ! ctx || ! si || si -> sz < sizeof ( vpx_codec_stream_info_t ) ) res = VPX_CODEC_INVALID_PARAM ; else if ( ! ctx -> iface || ! ctx -> priv ) res = VPX_CODEC_ERROR ; else { si -> w = 0 ; si -> h = 0 ; <S2SV_StartBug> res = ctx -> iface -> dec . get_si ( ctx -> priv -> alg_priv , si ) ; <S2SV_EndBug> } return SAVE_STATUS ( ctx , res ) ; }",". get_si ( get_alg_priv ( ctx ) <S2SV_ModEnd> , si )"
605,"<S2SV_StartBug> static void nsc_encode_subsampling ( NSC_CONTEXT * context ) <S2SV_EndBug> { UINT16 x ; UINT16 y ; <S2SV_StartBug> BYTE * co_dst ; <S2SV_EndBug> BYTE * cg_dst ; INT8 * co_src0 ; INT8 * co_src1 ; INT8 * cg_src0 ; INT8 * cg_src1 ; UINT32 tempWidth ; <S2SV_StartBug> UINT32 tempHeight ; <S2SV_EndBug> tempWidth = ROUND_UP_TO ( context -> width , 8 ) ; tempHeight = ROUND_UP_TO ( context -> height , 2 ) ; <S2SV_StartBug> for ( y = 0 ; y < tempHeight >> 1 ; y ++ ) <S2SV_EndBug> { <S2SV_StartBug> co_dst = context -> priv -> PlaneBuffers [ 1 ] + y * ( tempWidth >> 1 ) ; <S2SV_EndBug> <S2SV_StartBug> cg_dst = context -> priv -> PlaneBuffers [ 2 ] + y * ( tempWidth >> 1 ) ; <S2SV_EndBug> <S2SV_StartBug> co_src0 = ( INT8 * ) context -> priv -> PlaneBuffers [ 1 ] + ( y << 1 ) * tempWidth ; <S2SV_EndBug> <S2SV_StartBug> co_src1 = co_src0 + tempWidth ; <S2SV_EndBug> <S2SV_StartBug> cg_src0 = ( INT8 * ) context -> priv -> PlaneBuffers [ 2 ] + ( y << 1 ) * tempWidth ; <S2SV_EndBug> <S2SV_StartBug> cg_src1 = cg_src0 + tempWidth ; <S2SV_EndBug> for ( x = 0 ; x < tempWidth >> 1 ; x ++ ) { * co_dst ++ = ( BYTE ) ( ( ( INT16 ) * co_src0 + ( INT16 ) * ( co_src0 + 1 ) + ( INT16 ) * co_src1 + ( INT16 ) * ( co_src1 + 1 ) ) >> 2 ) ; * cg_dst ++ = ( BYTE ) ( ( ( INT16 ) * cg_src0 + ( INT16 ) * ( cg_src0 + 1 ) + ( INT16 ) * cg_src1 + ( INT16 ) * ( cg_src1 + 1 ) ) >> 2 ) ; co_src0 += 2 ; co_src1 += 2 ; cg_src0 += 2 ; cg_src1 += 2 ; } } <S2SV_StartBug> } <S2SV_EndBug>",<S2SV_null> <S2SV_null> static BOOL <S2SV_ModEnd> nsc_encode_subsampling ( NSC_CONTEXT <S2SV_ModStart> UINT16 y ; <S2SV_ModEnd> UINT32 tempWidth ; <S2SV_ModStart> ; UINT32 tempHeight ; if ( ! context ) return FALSE <S2SV_ModStart> 2 ) ; if ( tempHeight == 0 ) return FALSE ; if ( tempWidth > context -> priv -> PlaneBuffersLength / tempHeight ) return FALSE ; <S2SV_ModStart> ++ ) { BYTE * <S2SV_ModStart> 1 ) ; BYTE * <S2SV_ModStart> 1 ) ; const INT8 * <S2SV_ModStart> * tempWidth ; const INT8 * <S2SV_ModStart> + tempWidth ; const INT8 * <S2SV_ModStart> * tempWidth ; const INT8 * <S2SV_ModStart> ; } } return TRUE ;
606,"static ngx_int_t <S2SV_StartBug> ngx_http_lua_copy_request_headers ( ngx_http_request_t * sr , ngx_http_request_t * r ) <S2SV_EndBug> { <S2SV_StartBug> ngx_table_elt_t * header ; <S2SV_EndBug> ngx_list_part_t * part ; <S2SV_StartBug> ngx_uint_t i ; <S2SV_EndBug> if ( ngx_list_init ( & sr -> headers_in . headers , sr -> pool , 20 , sizeof ( ngx_table_elt_t ) ) != NGX_OK ) { return NGX_ERROR ; } <S2SV_StartBug> dd ( ""before:<S2SV_blank>parent<S2SV_blank>req<S2SV_blank>headers<S2SV_blank>count:<S2SV_blank>%d"" , <S2SV_EndBug> <S2SV_StartBug> ( int ) r -> headers_in . headers . part . nelts ) ; <S2SV_EndBug> part = & r -> headers_in . headers . part ; header = part -> elts ; for ( i = 0 ; ; i ++ ) { if ( i >= part -> nelts ) { <S2SV_StartBug> if ( part -> next == NULL ) { <S2SV_EndBug> break ; } part = part -> next ; header = part -> elts ; i = 0 ; } dd ( ""setting<S2SV_blank>request<S2SV_blank>header<S2SV_blank>%.*s:<S2SV_blank>%.*s"" , ( int ) header [ i ] . key . len , header [ i ] . key . data , ( int ) header [ i ] . value . len , header [ i ] . value . data ) ; if ( ngx_http_lua_set_input_header ( sr , header [ i ] . key , header [ i ] . value , 0 ) == NGX_ERROR ) { return NGX_ERROR ; } <S2SV_StartBug> } <S2SV_EndBug> dd ( ""after:<S2SV_blank>parent<S2SV_blank>req<S2SV_blank>headers<S2SV_blank>count:<S2SV_blank>%d"" , <S2SV_StartBug> ( int ) r -> headers_in . headers . part . nelts ) ; <S2SV_EndBug> return NGX_OK ; }",", ngx_http_request_t * pr , int pr_not_chunked <S2SV_ModEnd> ) { ngx_table_elt_t <S2SV_ModStart> { ngx_table_elt_t * clh , * <S2SV_ModStart> ; ngx_uint_t i ; u_char * p ; off_t len ; dd ( ""before:<S2SV_blank>parent<S2SV_blank>req<S2SV_blank>headers<S2SV_blank>count:<S2SV_blank>%d"" , ( int ) pr -> headers_in . headers . part . nelts ) <S2SV_ModStart> NGX_ERROR ; } if ( sr -> request_body && ! pr_not_chunked ) { len = sr -> request_body -> buf ? ngx_buf_size ( sr -> request_body -> buf ) : 0 ; clh = ngx_list_push ( & sr <S2SV_ModEnd> -> headers_in . <S2SV_ModStart> headers_in . headers ) ; if ( clh <S2SV_ModEnd> == NULL ) <S2SV_ModStart> == NULL ) <S2SV_ModEnd> { return NGX_ERROR <S2SV_ModStart> NGX_ERROR ; } clh -> hash = ngx_http_lua_content_length_hash ; clh -> key = ngx_http_lua_content_length_header_key ; clh -> lowcase_key = ngx_pnalloc ( sr -> pool , clh -> key . len ) ; if ( clh -> lowcase_key == NULL ) { return NGX_ERROR ; } ngx_strlow ( clh -> lowcase_key , clh -> key . data , clh -> key . len ) ; p = ngx_palloc ( sr -> pool , NGX_OFF_T_LEN ) ; if ( p == NULL ) { return NGX_ERROR ; } clh -> value . data = p ; clh -> value . len = ngx_sprintf ( clh -> value . data , ""%O"" , len ) - clh -> value . data ; sr -> headers_in . content_length = clh ; sr -> headers_in . content_length_n = len ; dd ( ""sr<S2SV_blank>crafted<S2SV_blank>content-length:<S2SV_blank>%.*s"" , ( int ) sr -> headers_in . content_length -> value . len , sr -> headers_in . content_length -> value . data ) ; } part = & pr -> headers_in . headers . part ; header = part -> elts ; for ( i = 0 ; ; i ++ ) { if ( i >= part -> nelts ) { if ( part -> next == NULL ) { break ; } part = part -> next ; header = part -> elts ; i = 0 ; } if ( ! pr_not_chunked && header [ i ] . key . len == sizeof ( ""Content-Length"" ) - 1 && ngx_strncasecmp ( header [ i ] . key . data , ( u_char * ) ""Content-Length"" , sizeof ( ""Content-Length"" ) - 1 ) == 0 ) { continue ; } dd ( ""sr<S2SV_blank>copied<S2SV_blank>req<S2SV_blank>header<S2SV_blank>%.*s:<S2SV_blank>%.*s"" , ( int ) header [ i ] . key . len , header [ i ] . key . data , ( int ) header [ i ] . value . len , header [ i ] . value . data ) ; if ( ngx_http_lua_set_input_header ( sr , header [ i ] . key , header [ i ] . value , 0 ) == NGX_ERROR ) { return NGX_ERROR ; } } dd ( <S2SV_ModEnd> ""after:<S2SV_blank>parent<S2SV_blank>req<S2SV_blank>headers<S2SV_blank>count:<S2SV_blank>%d"" , ( <S2SV_ModStart> ( int ) pr <S2SV_ModEnd> -> headers_in ."
607,"static unsigned int do_16x16_motion_iteration ( VP9_COMP * cpi , const MV * ref_mv , MV * dst_mv , int mb_row , int mb_col ) { <S2SV_StartBug> MACROBLOCK * const x = & cpi -> mb ; <S2SV_EndBug> MACROBLOCKD * const xd = & x -> e_mbd ; <S2SV_StartBug> vp9_variance_fn_ptr_t v_fn_ptr = cpi -> fn_ptr [ BLOCK_16X16 ] ; <S2SV_EndBug> const int tmp_col_min = x -> mv_col_min ; const int tmp_col_max = x -> mv_col_max ; const int tmp_row_min = x -> mv_row_min ; const int tmp_row_max = x -> mv_row_max ; MV ref_full ; <S2SV_StartBug> int step_param = cpi -> sf . reduce_first_step_size + <S2SV_EndBug> ( cpi -> speed < 8 ? ( cpi -> speed > 5 ? 1 : 0 ) : 2 ) ; <S2SV_StartBug> step_param = MIN ( step_param , ( cpi -> sf . max_step_search_steps - 2 ) ) ; <S2SV_EndBug> vp9_set_mv_search_range ( x , ref_mv ) ; ref_full . col = ref_mv -> col >> 3 ; ref_full . row = ref_mv -> row >> 3 ; <S2SV_StartBug> vp9_hex_search ( x , & ref_full , step_param , x -> errorperbit , 0 , & v_fn_ptr , 0 , <S2SV_EndBug> ref_mv , dst_mv ) ; { int distortion ; unsigned int sse ; cpi -> find_fractional_mv_step ( x , dst_mv , ref_mv , cpi -> common . allow_high_precision_mv , x -> errorperbit , <S2SV_StartBug> & v_fn_ptr , 0 , cpi -> sf . subpel_iters_per_step , NULL , NULL , & distortion , <S2SV_EndBug> <S2SV_StartBug> & sse ) ; <S2SV_EndBug> } xd -> mi [ 0 ] -> mbmi . mode = NEWMV ; xd -> mi [ 0 ] -> mbmi . mv [ 0 ] . as_mv = * dst_mv ; vp9_build_inter_predictors_sby ( xd , mb_row , mb_col , BLOCK_16X16 ) ; x -> mv_col_min = tmp_col_min ; x -> mv_col_max = tmp_col_max ; x -> mv_row_min = tmp_row_min ; x -> mv_row_max = tmp_row_max ; <S2SV_StartBug> return vp9_sad16x16 ( x -> plane [ 0 ] . src . buf , x -> plane [ 0 ] . src . stride , <S2SV_EndBug> <S2SV_StartBug> xd -> plane [ 0 ] . dst . buf , xd -> plane [ 0 ] . dst . stride , <S2SV_EndBug> INT_MAX ) ; }","& cpi -> td . <S2SV_ModStart> -> e_mbd ; const MV_SPEED_FEATURES * const mv_sf = & cpi -> sf . mv ; const <S2SV_ModStart> ref_full ; int cost_list [ 5 ] ; int step_param = mv_sf -> reduce_first_step_size <S2SV_ModEnd> ; step_param = <S2SV_ModStart> ( step_param , MAX_MVSEARCH_STEPS - 2 <S2SV_ModEnd> ) ; vp9_set_mv_search_range <S2SV_ModStart> , 0 , cond_cost_list ( cpi , cost_list ) , <S2SV_ModStart> , 0 , mv_sf -> subpel_iters_per_step , cond_cost_list ( cpi , cost_list ) , <S2SV_ModEnd> NULL , NULL <S2SV_ModStart> , & sse , NULL , 0 , 0 <S2SV_ModStart> tmp_row_max ; return vpx_sad16x16 <S2SV_ModEnd> ( x -> <S2SV_ModStart> dst . stride <S2SV_ModEnd> ) ; }"
608,"<S2SV_StartBug> int secure_decrypt ( void * data , unsigned int data_length , int is_signed ) <S2SV_EndBug> { <S2SV_StartBug> at91_aes_key_size_t key_size ; <S2SV_EndBug> unsigned int cmac_key [ 8 ] , cipher_key [ 8 ] ; unsigned int iv [ AT91_AES_IV_SIZE_WORD ] ; unsigned int computed_cmac [ AT91_AES_BLOCK_SIZE_WORD ] ; unsigned int fixed_length ; const unsigned int * cmac ; int rc = - 1 ; <S2SV_StartBug> init_keys ( & key_size , cipher_key , cmac_key , iv ) ; <S2SV_EndBug> at91_aes_init ( ) ; if ( is_signed ) { if ( at91_aes_cmac ( data_length , data , computed_cmac , key_size , cmac_key ) ) goto exit ; fixed_length = at91_aes_roundup ( data_length ) ; cmac = ( const unsigned int * ) ( ( char * ) data + fixed_length ) ; if ( ! consttime_memequal ( cmac , computed_cmac , AT91_AES_BLOCK_SIZE_BYTE ) ) goto exit ; } if ( at91_aes_cbc ( data_length , data , data , 0 , key_size , cipher_key , iv ) ) goto exit ; rc = 0 ; exit : at91_aes_cleanup ( ) ; <S2SV_StartBug> memset ( cmac_key , 0 , sizeof ( cmac_key ) ) ; <S2SV_EndBug> memset ( cipher_key , 0 , sizeof ( cipher_key ) ) ; memset ( iv , 0 , sizeof ( iv ) ) ; return rc ; }","<S2SV_null> <S2SV_null> <S2SV_null> static <S2SV_ModStart> { at91_aes_key_size_t key_size <S2SV_ModEnd> ; unsigned int <S2SV_ModStart> - 1 ; # if defined ( CONFIG_AES_KEY_SIZE_128 ) key_size = AT91_AES_KEY_SIZE_128 ; # elif defined ( CONFIG_AES_KEY_SIZE_192 ) key_size = AT91_AES_KEY_SIZE_192 ; # elif defined ( CONFIG_AES_KEY_SIZE_256 ) key_size = AT91_AES_KEY_SIZE_256 ; # else # error ""bad<S2SV_blank>AES<S2SV_blank>key<S2SV_blank>size"" # endif <S2SV_ModEnd> at91_aes_init ( ) <S2SV_ModStart> ( ) ; <S2SV_ModEnd> return rc ;"
609,"int cdf_read_property_info ( const cdf_stream_t * sst , const cdf_header_t * h , uint32_t offs , cdf_property_info_t * * info , size_t * count , size_t * maxcount ) { const cdf_section_header_t * shp ; cdf_section_header_t sh ; const uint8_t * p , * q , * e ; int16_t s16 ; int32_t s32 ; uint32_t u32 ; int64_t s64 ; uint64_t u64 ; cdf_timestamp_t tp ; size_t i , o , o4 , nelements , j ; cdf_property_info_t * inp ; if ( offs > UINT32_MAX / 4 ) { errno = EFTYPE ; goto out ; } shp = CAST ( const cdf_section_header_t * , ( const void * ) ( ( const char * ) sst -> sst_tab + offs ) ) ; if ( cdf_check_stream_offset ( sst , h , shp , sizeof ( * shp ) , __LINE__ ) == - 1 ) goto out ; sh . sh_len = CDF_TOLE4 ( shp -> sh_len ) ; # define CDF_SHLEN_LIMIT ( UINT32_MAX / 8 ) if ( sh . sh_len > CDF_SHLEN_LIMIT ) { errno = EFTYPE ; goto out ; } sh . sh_properties = CDF_TOLE4 ( shp -> sh_properties ) ; # define CDF_PROP_LIMIT ( UINT32_MAX / ( 4 * sizeof ( * inp ) ) ) if ( sh . sh_properties > CDF_PROP_LIMIT ) goto out ; DPRINTF ( ( ""section<S2SV_blank>len:<S2SV_blank>%u<S2SV_blank>properties<S2SV_blank>%u\\n"" , sh . sh_len , sh . sh_properties ) ) ; if ( * maxcount ) { if ( * maxcount > CDF_PROP_LIMIT ) goto out ; * maxcount += sh . sh_properties ; inp = CAST ( cdf_property_info_t * , realloc ( * info , * maxcount * sizeof ( * inp ) ) ) ; } else { * maxcount = sh . sh_properties ; inp = CAST ( cdf_property_info_t * , malloc ( * maxcount * sizeof ( * inp ) ) ) ; } if ( inp == NULL ) goto out ; * info = inp ; inp += * count ; * count += sh . sh_properties ; p = CAST ( const uint8_t * , ( const void * ) ( ( const char * ) ( const void * ) sst -> sst_tab + offs + sizeof ( sh ) ) ) ; e = CAST ( const uint8_t * , ( const void * ) ( ( ( const char * ) ( const void * ) shp ) + sh . sh_len ) ) ; if ( cdf_check_stream_offset ( sst , h , e , 0 , __LINE__ ) == - 1 ) goto out ; for ( i = 0 ; i < sh . sh_properties ; i ++ ) { size_t ofs = CDF_GETUINT32 ( p , ( i << 1 ) + 1 ) ; q = ( const uint8_t * ) ( const void * ) ( ( const char * ) ( const void * ) p + ofs - 2 * sizeof ( uint32_t ) ) ; if ( q > e ) { DPRINTF ( ( ""Ran<S2SV_blank>of<S2SV_blank>the<S2SV_blank>end<S2SV_blank>%p<S2SV_blank>><S2SV_blank>%p\\n"" , q , e ) ) ; goto out ; } inp [ i ] . pi_id = CDF_GETUINT32 ( p , i << 1 ) ; inp [ i ] . pi_type = CDF_GETUINT32 ( q , 0 ) ; DPRINTF ( ( ""%"" SIZE_T_FORMAT ""u)<S2SV_blank>id=%x<S2SV_blank>type=%x<S2SV_blank>offs=0x%tx,0x%x\\n"" , i , inp [ i ] . pi_id , inp [ i ] . pi_type , q - p , offs ) ) ; if ( inp [ i ] . pi_type & CDF_VECTOR ) { nelements = CDF_GETUINT32 ( q , 1 ) ; <S2SV_StartBug> o = 2 ; <S2SV_EndBug> } else { nelements = 1 ; o = 1 ; } o4 = o * sizeof ( uint32_t ) ; if ( inp [ i ] . pi_type & ( CDF_ARRAY | CDF_BYREF | CDF_RESERVED ) ) goto unknown ; switch ( inp [ i ] . pi_type & CDF_TYPEMASK ) { case CDF_NULL : case CDF_EMPTY : break ; case CDF_SIGNED16 : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & s16 , & q [ o4 ] , sizeof ( s16 ) ) ; inp [ i ] . pi_s16 = CDF_TOLE2 ( s16 ) ; break ; case CDF_SIGNED32 : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & s32 , & q [ o4 ] , sizeof ( s32 ) ) ; inp [ i ] . pi_s32 = CDF_TOLE4 ( ( uint32_t ) s32 ) ; break ; case CDF_BOOL : case CDF_UNSIGNED32 : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & u32 , & q [ o4 ] , sizeof ( u32 ) ) ; inp [ i ] . pi_u32 = CDF_TOLE4 ( u32 ) ; break ; case CDF_SIGNED64 : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & s64 , & q [ o4 ] , sizeof ( s64 ) ) ; inp [ i ] . pi_s64 = CDF_TOLE8 ( ( uint64_t ) s64 ) ; break ; case CDF_UNSIGNED64 : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & u64 , & q [ o4 ] , sizeof ( u64 ) ) ; inp [ i ] . pi_u64 = CDF_TOLE8 ( ( uint64_t ) u64 ) ; break ; case CDF_FLOAT : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & u32 , & q [ o4 ] , sizeof ( u32 ) ) ; u32 = CDF_TOLE4 ( u32 ) ; memcpy ( & inp [ i ] . pi_f , & u32 , sizeof ( inp [ i ] . pi_f ) ) ; break ; case CDF_DOUBLE : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & u64 , & q [ o4 ] , sizeof ( u64 ) ) ; u64 = CDF_TOLE8 ( ( uint64_t ) u64 ) ; memcpy ( & inp [ i ] . pi_d , & u64 , sizeof ( inp [ i ] . pi_d ) ) ; break ; case CDF_LENGTH32_STRING : case CDF_LENGTH32_WSTRING : if ( nelements > 1 ) { size_t nelem = inp - * info ; if ( * maxcount > CDF_PROP_LIMIT || nelements > CDF_PROP_LIMIT ) goto out ; * maxcount += nelements ; inp = CAST ( cdf_property_info_t * , realloc ( * info , * maxcount * sizeof ( * inp ) ) ) ; if ( inp == NULL ) goto out ; * info = inp ; inp = * info + nelem ; } DPRINTF ( ( ""nelements<S2SV_blank>=<S2SV_blank>%"" SIZE_T_FORMAT ""u\\n"" , nelements ) ) ; <S2SV_StartBug> for ( j = 0 ; j < nelements ; j ++ , i ++ ) { <S2SV_EndBug> uint32_t l = CDF_GETUINT32 ( q , o ) ; inp [ i ] . pi_str . s_len = l ; inp [ i ] . pi_str . s_buf = ( const char * ) ( const void * ) ( & q [ o4 + sizeof ( l ) ] ) ; DPRINTF ( ( ""l<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>r<S2SV_blank>=<S2SV_blank>%"" SIZE_T_FORMAT ""u,<S2SV_blank>s<S2SV_blank>=<S2SV_blank>%s\\n"" , l , CDF_ROUND ( l , sizeof ( l ) ) , inp [ i ] . pi_str . s_buf ) ) ; if ( l & 1 ) l ++ ; o += l >> 1 ; if ( q + o >= e ) goto out ; o4 = o * sizeof ( uint32_t ) ; } i -- ; break ; case CDF_FILETIME : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & tp , & q [ o4 ] , sizeof ( tp ) ) ; inp [ i ] . pi_tp = CDF_TOLE8 ( ( uint64_t ) tp ) ; break ; case CDF_CLIPBOARD : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; break ; default : unknown : DPRINTF ( ( ""Don\'t<S2SV_blank>know<S2SV_blank>how<S2SV_blank>to<S2SV_blank>deal<S2SV_blank>with<S2SV_blank>%x\\n"" , inp [ i ] . pi_type ) ) ; break ; } } return 0 ; out : free ( * info ) ; return - 1 ; }","1 ) ; if ( nelements == 0 ) { DPRINTF ( ( ""CDF_VECTOR<S2SV_blank>with<S2SV_blank>nelements<S2SV_blank>==<S2SV_blank>0\\n"" ) ) ; goto out ; } <S2SV_ModStart> j < nelements && i < sh . sh_properties ; <S2SV_ModEnd> j ++ ,"
610,"static void update_bar_address ( struct vmctx * ctx , struct pci_vdev * dev , uint64_t addr , int idx , int type , bool ignore_reg_unreg ) { bool decode = false ; uint64_t orig_addr = dev -> bar [ idx ] . addr ; if ( ! ignore_reg_unreg ) { if ( dev -> bar [ idx ] . type == PCIBAR_IO ) decode = porten ( dev ) ; else decode = memen ( dev ) ; } if ( decode ) unregister_bar ( dev , idx ) ; switch ( type ) { case PCIBAR_IO : case PCIBAR_MEM32 : dev -> bar [ idx ] . addr = addr ; break ; case PCIBAR_MEM64 : dev -> bar [ idx ] . addr &= ~ 0xffffffffUL ; dev -> bar [ idx ] . addr |= addr ; break ; case PCIBAR_MEMHI64 : dev -> bar [ idx ] . addr &= 0xffffffff ; dev -> bar [ idx ] . addr |= addr ; break ; default : <S2SV_StartBug> assert ( 0 ) ; <S2SV_EndBug> } if ( decode ) register_bar ( dev , idx ) ; if ( dev -> dev_ops -> vdev_update_bar_map && decode ) dev -> dev_ops -> vdev_update_bar_map ( ctx , dev , idx , orig_addr ) ; }","; default : pr_err ( ""%s:<S2SV_blank>invalid<S2SV_blank>bar<S2SV_blank>type<S2SV_blank>%d\\n"" , __func__ , type ) ; return <S2SV_ModEnd> ; } if"
611,"static Image * ReadGIFImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define BitSet ( byte , bit ) ( ( ( byte ) & ( bit ) ) == ( bit ) ) # define LSBFirstOrder ( x , y ) ( ( ( y ) << 8 ) | ( x ) ) Image * image , * meta_image ; int number_extensionss = 0 ; MagickBooleanType status ; RectangleInfo page ; register ssize_t i ; register unsigned char * p ; size_t delay , dispose , duration , global_colors , image_count , iterations , one ; ssize_t count , opacity ; unsigned char background , c , flag , * global_colormap , header [ MaxTextExtent ] , magick [ 12 ] ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } count = ReadBlob ( image , 6 , magick ) ; if ( ( count != 6 ) || ( ( LocaleNCompare ( ( char * ) magick , ""GIF87"" , 5 ) != 0 ) && ( LocaleNCompare ( ( char * ) magick , ""GIF89"" , 5 ) != 0 ) ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; page . width = ReadBlobLSBShort ( image ) ; page . height = ReadBlobLSBShort ( image ) ; flag = ( unsigned char ) ReadBlobByte ( image ) ; background = ( unsigned char ) ReadBlobByte ( image ) ; c = ( unsigned char ) ReadBlobByte ( image ) ; one = 1 ; global_colors = one << ( ( ( size_t ) flag & 0x07 ) + 1 ) ; global_colormap = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) MagickMax ( global_colors , 256 ) , 3UL * sizeof ( * global_colormap ) ) ; if ( global_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; if ( BitSet ( ( int ) flag , 0x80 ) != 0 ) count = ReadBlob ( image , ( size_t ) ( 3 * global_colors ) , global_colormap ) ; delay = 0 ; dispose = 0 ; duration = 0 ; iterations = 1 ; opacity = ( - 1 ) ; image_count = 0 ; meta_image = AcquireImage ( image_info ) ; for ( ; ; ) { count = ReadBlob ( image , 1 , & c ) ; if ( count != 1 ) break ; if ( c == ( unsigned char ) ';' ) break ; if ( c == ( unsigned char ) '!' ) { count = ReadBlob ( image , 1 , & c ) ; if ( count != 1 ) { global_colormap = ( unsigned char * ) RelinquishMagickMemory ( global_colormap ) ; ThrowReaderException ( CorruptImageError , ""UnableToReadExtensionBlock"" ) ; } switch ( c ) { case 0xf9 : { while ( ReadBlobBlock ( image , header ) != 0 ) ; dispose = ( size_t ) ( header [ 0 ] >> 2 ) ; delay = ( size_t ) ( ( header [ 2 ] << 8 ) | header [ 1 ] ) ; if ( ( ssize_t ) ( header [ 0 ] & 0x01 ) == 0x01 ) opacity = ( ssize_t ) header [ 3 ] ; break ; } case 0xfe : { char * comments ; size_t length ; comments = AcquireString ( ( char * ) NULL ) ; for ( length = 0 ; ; length += count ) { count = ( ssize_t ) ReadBlobBlock ( image , header ) ; if ( count == 0 ) break ; header [ count ] = '\\0' ; ( void ) ConcatenateString ( & comments , ( const char * ) header ) ; } ( void ) SetImageProperty ( meta_image , ""comment"" , comments ) ; comments = DestroyString ( comments ) ; break ; } case 0xff : { MagickBooleanType loop ; loop = MagickFalse ; if ( ReadBlobBlock ( image , header ) != 0 ) loop = LocaleNCompare ( ( char * ) header , ""NETSCAPE2.0"" , 11 ) == 0 ? MagickTrue : MagickFalse ; if ( loop != MagickFalse ) { while ( ReadBlobBlock ( image , header ) != 0 ) iterations = ( size_t ) ( ( header [ 2 ] << 8 ) | header [ 1 ] ) ; break ; } else { char name [ MaxTextExtent ] ; int block_length , info_length , reserved_length ; MagickBooleanType i8bim , icc , iptc , magick ; StringInfo * profile ; unsigned char * info ; icc = LocaleNCompare ( ( char * ) header , ""ICCRGBG1012"" , 11 ) == 0 ? MagickTrue : MagickFalse ; magick = LocaleNCompare ( ( char * ) header , ""ImageMagick"" , 11 ) == 0 ? MagickTrue : MagickFalse ; i8bim = LocaleNCompare ( ( char * ) header , ""MGK8BIM0000"" , 11 ) == 0 ? MagickTrue : MagickFalse ; iptc = LocaleNCompare ( ( char * ) header , ""MGKIPTC0000"" , 11 ) == 0 ? MagickTrue : MagickFalse ; number_extensionss ++ ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Reading<S2SV_blank>GIF<S2SV_blank>application<S2SV_blank>extension"" ) ; info = ( unsigned char * ) AcquireQuantumMemory ( 255UL , sizeof ( * info ) ) ; reserved_length = 255 ; for ( info_length = 0 ; ; ) { block_length = ( int ) ReadBlobBlock ( image , & info [ info_length ] ) ; if ( block_length == 0 ) break ; info_length += block_length ; if ( info_length > ( reserved_length - 255 ) ) { reserved_length += 4096 ; info = ( unsigned char * ) ResizeQuantumMemory ( info , ( size_t ) reserved_length , sizeof ( * info ) ) ; if ( info == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } } profile = BlobToStringInfo ( info , ( size_t ) info_length ) ; if ( profile == ( StringInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; if ( i8bim != MagickFalse ) ( void ) CopyMagickString ( name , ""8bim"" , sizeof ( name ) ) ; else if ( icc != MagickFalse ) ( void ) CopyMagickString ( name , ""icc"" , sizeof ( name ) ) ; else if ( iptc != MagickFalse ) ( void ) CopyMagickString ( name , ""iptc"" , sizeof ( name ) ) ; else if ( magick != MagickFalse ) { ( void ) CopyMagickString ( name , ""magick"" , sizeof ( name ) ) ; image -> gamma = StringToDouble ( ( char * ) info + 6 , ( char * * ) NULL ) ; } else ( void ) FormatLocaleString ( name , sizeof ( name ) , ""gif:%.11s"" , header ) ; info = ( unsigned char * ) RelinquishMagickMemory ( info ) ; if ( magick == MagickFalse ) ( void ) SetImageProfile ( meta_image , name , profile ) ; profile = DestroyStringInfo ( profile ) ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>profile<S2SV_blank>name=%s"" , name ) ; } break ; } default : { while ( ReadBlobBlock ( image , header ) != 0 ) ; break ; } } } if ( c != ( unsigned char ) ',' ) continue ; if ( image_count != 0 ) { AcquireNextImage ( image_info , image ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; global_colormap = ( unsigned char * ) RelinquishMagickMemory ( global_colormap ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; } image_count ++ ; meta_image -> scene = image -> scene ; CloneImageProperties ( image , meta_image ) ; DestroyImageProperties ( meta_image ) ; CloneImageProfiles ( image , meta_image ) ; DestroyImageProfiles ( meta_image ) ; image -> storage_class = PseudoClass ; image -> compression = LZWCompression ; page . x = ( ssize_t ) ReadBlobLSBShort ( image ) ; page . y = ( ssize_t ) ReadBlobLSBShort ( image ) ; image -> columns = ReadBlobLSBShort ( image ) ; image -> rows = ReadBlobLSBShort ( image ) ; image -> depth = 8 ; flag = ( unsigned char ) ReadBlobByte ( image ) ; image -> interlace = BitSet ( ( int ) flag , 0x40 ) != 0 ? GIFInterlace : NoInterlace ; image -> colors = BitSet ( ( int ) flag , 0x80 ) == 0 ? global_colors : one << ( ( size_t ) ( flag & 0x07 ) + 1 ) ; if ( opacity >= ( ssize_t ) image -> colors ) opacity = ( - 1 ) ; image -> page . width = page . width ; image -> page . height = page . height ; image -> page . y = page . y ; image -> page . x = page . x ; image -> delay = delay ; image -> iterations = iterations ; image -> ticks_per_second = 100 ; image -> dispose = ( DisposeType ) dispose ; image -> matte = opacity >= 0 ? MagickTrue : MagickFalse ; delay = 0 ; dispose = 0 ; if ( ( image -> columns == 0 ) || ( image -> rows == 0 ) ) { global_colormap = ( unsigned char * ) RelinquishMagickMemory ( global_colormap ) ; ThrowReaderException ( CorruptImageError , ""NegativeOrZeroImageSize"" ) ; } if ( AcquireImageColormap ( image , image -> colors ) == MagickFalse ) { global_colormap = ( unsigned char * ) RelinquishMagickMemory ( global_colormap ) ; ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } if ( BitSet ( ( int ) flag , 0x80 ) == 0 ) { p = global_colormap ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( * p ++ ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( * p ++ ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( * p ++ ) ; if ( i == opacity ) { image -> colormap [ i ] . opacity = ( Quantum ) TransparentOpacity ; image -> transparent_color = image -> colormap [ opacity ] ; } } image -> background_color = image -> colormap [ MagickMin ( background , image -> colors - 1 ) ] ; } else { unsigned char * colormap ; colormap = ( unsigned char * ) AcquireQuantumMemory ( image -> colors , 3 * sizeof ( * colormap ) ) ; if ( colormap == ( unsigned char * ) NULL ) { global_colormap = ( unsigned char * ) RelinquishMagickMemory ( global_colormap ) ; ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } count = ReadBlob ( image , ( 3 * image -> colors ) * sizeof ( * colormap ) , colormap ) ; if ( count != ( ssize_t ) ( 3 * image -> colors ) ) { global_colormap = ( unsigned char * ) RelinquishMagickMemory ( global_colormap ) ; colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; ThrowReaderException ( CorruptImageError , ""InsufficientImageDataInFile"" ) ; } p = colormap ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( * p ++ ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( * p ++ ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( * p ++ ) ; if ( i == opacity ) image -> colormap [ i ] . opacity = ( Quantum ) TransparentOpacity ; } colormap = ( unsigned char * ) RelinquishMagickMemory ( colormap ) ; } if ( image -> gamma == 1.0 ) { for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) if ( IsGrayPixel ( image -> colormap + i ) == MagickFalse ) break ; ( void ) SetImageColorspace ( image , i == ( ssize_t ) image -> colors ? GRAYColorspace : RGBColorspace ) ; } if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; <S2SV_StartBug> if ( image_info -> ping != MagickFalse ) <S2SV_EndBug> status = PingGIFImage ( image ) ; else status = DecodeImage ( image , opacity ) ; if ( ( image_info -> ping == MagickFalse ) && ( status == MagickFalse ) ) { global_colormap = ( unsigned char * ) RelinquishMagickMemory ( global_colormap ) ; ThrowReaderException ( CorruptImageError , ""CorruptImage"" ) ; } duration += image -> delay * image -> iterations ; if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; opacity = ( - 1 ) ; status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) image -> scene - 1 , image -> scene ) ; if ( status == MagickFalse ) break ; } image -> duration = duration ; meta_image = DestroyImage ( meta_image ) ; global_colormap = ( unsigned char * ) RelinquishMagickMemory ( global_colormap ) ; if ( ( image -> columns == 0 ) || ( image -> rows == 0 ) ) ThrowReaderException ( CorruptImageError , ""NegativeOrZeroImageSize"" ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }",") break ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; }"
612,"static int adis_update_scan_mode_burst ( struct iio_dev * indio_dev , const unsigned long * scan_mask ) { struct adis * adis = iio_device_get_drvdata ( indio_dev ) ; unsigned int burst_length ; u8 * tx ; burst_length = ( indio_dev -> num_channels - 1 ) * sizeof ( u16 ) ; burst_length += adis -> burst -> extra_len ; adis -> xfer = kcalloc ( 2 , sizeof ( * adis -> xfer ) , GFP_KERNEL ) ; if ( ! adis -> xfer ) return - ENOMEM ; adis -> buffer = kzalloc ( burst_length + sizeof ( u16 ) , GFP_KERNEL ) ; <S2SV_StartBug> if ( ! adis -> buffer ) <S2SV_EndBug> return - ENOMEM ; <S2SV_StartBug> tx = adis -> buffer + burst_length ; <S2SV_EndBug> tx [ 0 ] = ADIS_READ_REG ( adis -> burst -> reg_cmd ) ; tx [ 1 ] = 0 ; adis -> xfer [ 0 ] . tx_buf = tx ; adis -> xfer [ 0 ] . bits_per_word = 8 ; adis -> xfer [ 0 ] . len = 2 ; adis -> xfer [ 1 ] . rx_buf = adis -> buffer ; adis -> xfer [ 1 ] . bits_per_word = 8 ; adis -> xfer [ 1 ] . len = burst_length ; spi_message_init ( & adis -> msg ) ; spi_message_add_tail ( & adis -> xfer [ 0 ] , & adis -> msg ) ; spi_message_add_tail ( & adis -> xfer [ 1 ] , & adis -> msg ) ; return 0 ; }",-> buffer ) { kfree ( adis -> xfer ) ; adis -> xfer = NULL ; <S2SV_ModStart> - ENOMEM ; }
613,"static int adjust_ptr_min_max_vals ( struct bpf_verifier_env * env , struct bpf_insn * insn , const struct bpf_reg_state * ptr_reg , const struct bpf_reg_state * off_reg ) { struct bpf_reg_state * regs = cur_regs ( env ) , * dst_reg ; bool known = tnum_is_const ( off_reg -> var_off ) ; s64 smin_val = off_reg -> smin_value , smax_val = off_reg -> smax_value , smin_ptr = ptr_reg -> smin_value , smax_ptr = ptr_reg -> smax_value ; u64 umin_val = off_reg -> umin_value , umax_val = off_reg -> umax_value , umin_ptr = ptr_reg -> umin_value , umax_ptr = ptr_reg -> umax_value ; u8 opcode = BPF_OP ( insn -> code ) ; u32 dst = insn -> dst_reg ; dst_reg = & regs [ dst ] ; if ( WARN_ON_ONCE ( known && ( smin_val != smax_val ) ) ) { print_verifier_state ( env , env -> cur_state ) ; verbose ( env , ""verifier<S2SV_blank>internal<S2SV_blank>error:<S2SV_blank>known<S2SV_blank>but<S2SV_blank>bad<S2SV_blank>sbounds\\n"" ) ; return - EINVAL ; } if ( WARN_ON_ONCE ( known && ( umin_val != umax_val ) ) ) { print_verifier_state ( env , env -> cur_state ) ; verbose ( env , ""verifier<S2SV_blank>internal<S2SV_blank>error:<S2SV_blank>known<S2SV_blank>but<S2SV_blank>bad<S2SV_blank>ubounds\\n"" ) ; return - EINVAL ; } if ( BPF_CLASS ( insn -> code ) != BPF_ALU64 ) { if ( ! env -> allow_ptr_leaks ) verbose ( env , ""R%d<S2SV_blank>32-bit<S2SV_blank>pointer<S2SV_blank>arithmetic<S2SV_blank>prohibited\\n"" , dst ) ; return - EACCES ; } if ( ptr_reg -> type == PTR_TO_MAP_VALUE_OR_NULL ) { if ( ! env -> allow_ptr_leaks ) verbose ( env , ""R%d<S2SV_blank>pointer<S2SV_blank>arithmetic<S2SV_blank>on<S2SV_blank>PTR_TO_MAP_VALUE_OR_NULL<S2SV_blank>prohibited,<S2SV_blank>null-check<S2SV_blank>it<S2SV_blank>first\\n"" , dst ) ; return - EACCES ; } if ( ptr_reg -> type == CONST_PTR_TO_MAP ) { if ( ! env -> allow_ptr_leaks ) verbose ( env , ""R%d<S2SV_blank>pointer<S2SV_blank>arithmetic<S2SV_blank>on<S2SV_blank>CONST_PTR_TO_MAP<S2SV_blank>prohibited\\n"" , dst ) ; return - EACCES ; } if ( ptr_reg -> type == PTR_TO_PACKET_END ) { if ( ! env -> allow_ptr_leaks ) verbose ( env , ""R%d<S2SV_blank>pointer<S2SV_blank>arithmetic<S2SV_blank>on<S2SV_blank>PTR_TO_PACKET_END<S2SV_blank>prohibited\\n"" , dst ) ; return - EACCES ; } dst_reg -> type = ptr_reg -> type ; <S2SV_StartBug> dst_reg -> id = ptr_reg -> id ; <S2SV_EndBug> switch ( opcode ) { case BPF_ADD : if ( known && ( ptr_reg -> off + smin_val == ( s64 ) ( s32 ) ( ptr_reg -> off + smin_val ) ) ) { dst_reg -> smin_value = smin_ptr ; dst_reg -> smax_value = smax_ptr ; dst_reg -> umin_value = umin_ptr ; dst_reg -> umax_value = umax_ptr ; dst_reg -> var_off = ptr_reg -> var_off ; dst_reg -> off = ptr_reg -> off + smin_val ; dst_reg -> range = ptr_reg -> range ; break ; } if ( signed_add_overflows ( smin_ptr , smin_val ) || signed_add_overflows ( smax_ptr , smax_val ) ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = smin_ptr + smin_val ; dst_reg -> smax_value = smax_ptr + smax_val ; } if ( umin_ptr + umin_val < umin_ptr || umax_ptr + umax_val < umax_ptr ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value = umin_ptr + umin_val ; dst_reg -> umax_value = umax_ptr + umax_val ; } dst_reg -> var_off = tnum_add ( ptr_reg -> var_off , off_reg -> var_off ) ; dst_reg -> off = ptr_reg -> off ; if ( reg_is_pkt_pointer ( ptr_reg ) ) { dst_reg -> id = ++ env -> id_gen ; dst_reg -> range = 0 ; } break ; case BPF_SUB : if ( dst_reg == off_reg ) { if ( ! env -> allow_ptr_leaks ) verbose ( env , ""R%d<S2SV_blank>tried<S2SV_blank>to<S2SV_blank>subtract<S2SV_blank>pointer<S2SV_blank>from<S2SV_blank>scalar\\n"" , dst ) ; return - EACCES ; } if ( ptr_reg -> type == PTR_TO_STACK ) { if ( ! env -> allow_ptr_leaks ) verbose ( env , ""R%d<S2SV_blank>subtraction<S2SV_blank>from<S2SV_blank>stack<S2SV_blank>pointer<S2SV_blank>prohibited\\n"" , dst ) ; return - EACCES ; } if ( known && ( ptr_reg -> off - smin_val == ( s64 ) ( s32 ) ( ptr_reg -> off - smin_val ) ) ) { dst_reg -> smin_value = smin_ptr ; dst_reg -> smax_value = smax_ptr ; dst_reg -> umin_value = umin_ptr ; dst_reg -> umax_value = umax_ptr ; dst_reg -> var_off = ptr_reg -> var_off ; dst_reg -> id = ptr_reg -> id ; dst_reg -> off = ptr_reg -> off - smin_val ; dst_reg -> range = ptr_reg -> range ; break ; } if ( signed_sub_overflows ( smin_ptr , smax_val ) || signed_sub_overflows ( smax_ptr , smin_val ) ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = smin_ptr - smax_val ; dst_reg -> smax_value = smax_ptr - smin_val ; } if ( umin_ptr < umax_val ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value = umin_ptr - umax_val ; dst_reg -> umax_value = umax_ptr - umin_val ; } dst_reg -> var_off = tnum_sub ( ptr_reg -> var_off , off_reg -> var_off ) ; dst_reg -> off = ptr_reg -> off ; if ( reg_is_pkt_pointer ( ptr_reg ) ) { dst_reg -> id = ++ env -> id_gen ; if ( smin_val < 0 ) dst_reg -> range = 0 ; } break ; case BPF_AND : case BPF_OR : case BPF_XOR : if ( ! env -> allow_ptr_leaks ) verbose ( env , ""R%d<S2SV_blank>bitwise<S2SV_blank>operator<S2SV_blank>%s<S2SV_blank>on<S2SV_blank>pointer<S2SV_blank>prohibited\\n"" , dst , bpf_alu_string [ opcode >> 4 ] ) ; return - EACCES ; default : if ( ! env -> allow_ptr_leaks ) verbose ( env , ""R%d<S2SV_blank>pointer<S2SV_blank>arithmetic<S2SV_blank>with<S2SV_blank>%s<S2SV_blank>operator<S2SV_blank>prohibited\\n"" , dst , bpf_alu_string [ opcode >> 4 ] ) ; return - EACCES ; } <S2SV_StartBug> __update_reg_bounds ( dst_reg ) ; <S2SV_EndBug> __reg_deduce_bounds ( dst_reg ) ; __reg_bound_offset ( dst_reg ) ; return 0 ; }","ptr_reg -> id ; if ( ! check_reg_sane_offset ( env , off_reg , ptr_reg -> type ) || ! check_reg_sane_offset ( env , ptr_reg , ptr_reg -> type ) ) return - EINVAL <S2SV_ModStart> EACCES ; } if ( ! check_reg_sane_offset ( env , dst_reg , ptr_reg -> type ) ) return - EINVAL ;"
614,"void Com_WriteConfig_f ( void ) { char filename [ MAX_QPATH ] ; if ( Cmd_Argc ( ) != 2 ) { <S2SV_StartBug> Com_Printf ( ""Usage:<S2SV_blank>writeconfig<S2SV_blank><filename>\\n"" ) ; <S2SV_EndBug> return ; } Q_strncpyz ( filename , Cmd_Argv ( 1 ) , sizeof ( filename ) ) ; COM_DefaultExtension ( filename , sizeof ( filename ) , "".cfg"" ) ; Com_Printf ( ""Writing<S2SV_blank>%s.\\n"" , filename ) ; Com_WriteConfigToFile ( filename ) ; }","Com_Printf ( ""Usage:<S2SV_blank>writeconfig<S2SV_blank><filename>\\n"" ) ; return ; } if ( ! COM_CompareExtension ( filename , "".cfg"" ) ) { Com_Printf ( ""Com_WriteConfig_f:<S2SV_blank>Only<S2SV_blank>the<S2SV_blank>\\"".cfg\\""<S2SV_blank>extension<S2SV_blank>is<S2SV_blank>supported<S2SV_blank>by<S2SV_blank>this<S2SV_blank>command!\\n"""
615,"static int adev_open_output_stream ( struct audio_hw_device * dev , audio_io_handle_t handle , audio_devices_t devices , audio_output_flags_t flags , struct audio_config * config , struct audio_stream_out * * stream_out , const char * address ) { struct a2dp_audio_device * a2dp_dev = ( struct a2dp_audio_device * ) dev ; struct a2dp_stream_out * out ; int ret = 0 ; int i ; UNUSED ( address ) ; UNUSED ( handle ) ; UNUSED ( devices ) ; UNUSED ( flags ) ; INFO ( ""opening<S2SV_blank>output"" ) ; out = ( struct a2dp_stream_out * ) calloc ( 1 , sizeof ( struct a2dp_stream_out ) ) ; if ( ! out ) return - ENOMEM ; out -> stream . common . get_sample_rate = out_get_sample_rate ; out -> stream . common . set_sample_rate = out_set_sample_rate ; out -> stream . common . get_buffer_size = out_get_buffer_size ; out -> stream . common . get_channels = out_get_channels ; out -> stream . common . get_format = out_get_format ; out -> stream . common . set_format = out_set_format ; out -> stream . common . standby = out_standby ; out -> stream . common . dump = out_dump ; out -> stream . common . set_parameters = out_set_parameters ; out -> stream . common . get_parameters = out_get_parameters ; out -> stream . common . add_audio_effect = out_add_audio_effect ; out -> stream . common . remove_audio_effect = out_remove_audio_effect ; out -> stream . get_latency = out_get_latency ; out -> stream . set_volume = out_set_volume ; out -> stream . write = out_write ; out -> stream . get_render_position = out_get_render_position ; out -> stream . get_presentation_position = out_get_presentation_position ; a2dp_stream_common_init ( & out -> common ) ; out -> common . cfg . channel_flags = AUDIO_STREAM_DEFAULT_CHANNEL_FLAG ; out -> common . cfg . format = AUDIO_STREAM_DEFAULT_FORMAT ; out -> common . cfg . rate = AUDIO_STREAM_DEFAULT_RATE ; if ( config ) { config -> format = out_get_format ( ( const struct audio_stream * ) & out -> stream ) ; config -> sample_rate = out_get_sample_rate ( ( const struct audio_stream * ) & out -> stream ) ; config -> channel_mask = out_get_channels ( ( const struct audio_stream * ) & out -> stream ) ; } * stream_out = & out -> stream ; a2dp_dev -> output = out ; a2dp_open_ctrl_path ( & out -> common ) ; if ( out -> common . ctrl_fd == AUDIO_SKT_DISCONNECTED ) { ERROR ( ""ctrl<S2SV_blank>socket<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>connect<S2SV_blank>(%s)"" , strerror ( errno ) ) ; ret = - 1 ; goto err_open ; } DEBUG ( ""success"" ) ; <S2SV_StartBug> usleep ( 250000 ) ; <S2SV_EndBug> return 0 ; err_open : free ( out ) ; * stream_out = NULL ; a2dp_dev -> output = NULL ; ERROR ( ""failed"" ) ; return ret ; }","""success"" ) ; TEMP_FAILURE_RETRY ( <S2SV_ModStart> usleep ( 250000 )"
616,"<S2SV_StartBug> static void update_mv_probs ( vp9_prob * p , int n , vp9_reader * r ) { <S2SV_EndBug> int i ; for ( i = 0 ; i < n ; ++ i ) <S2SV_StartBug> if ( vp9_read ( r , MV_UPDATE_PROB ) ) <S2SV_EndBug> <S2SV_StartBug> p [ i ] = ( vp9_read_literal ( r , 7 ) << 1 ) | 1 ; <S2SV_EndBug> }","void update_mv_probs ( vpx_prob <S2SV_ModEnd> * p , <S2SV_ModStart> int n , vpx_reader <S2SV_ModEnd> * r ) <S2SV_ModStart> ) if ( vpx_read <S2SV_ModEnd> ( r , <S2SV_ModStart> ] = ( vpx_read_literal <S2SV_ModEnd> ( r ,"
617,"static int get_core_reg ( struct kvm_vcpu * vcpu , const struct kvm_one_reg * reg ) { __u32 __user * uaddr = ( __u32 __user * ) ( unsigned long ) reg -> addr ; struct kvm_regs * regs = vcpu_gp_regs ( vcpu ) ; int nr_regs = sizeof ( * regs ) / sizeof ( __u32 ) ; u32 off ; off = core_reg_offset_from_id ( reg -> id ) ; if ( off >= nr_regs || ( off + ( KVM_REG_SIZE ( reg -> id ) / sizeof ( __u32 ) ) ) >= nr_regs ) return - ENOENT ; <S2SV_StartBug> if ( copy_to_user ( uaddr , ( ( u32 * ) regs ) + off , KVM_REG_SIZE ( reg -> id ) ) ) <S2SV_EndBug> return - EFAULT ; return 0 ; }",; if ( validate_core_offset ( reg ) ) return - EINVAL ; if (
618,void mk_request_free ( struct session_request * sr ) { if ( sr -> fd_file > 0 ) { <S2SV_StartBug> mk_vhost_close ( sr ) ; <S2SV_EndBug> } if ( sr -> headers . location ) { mk_mem_free ( sr -> headers . location ) ; } if ( sr -> uri_processed . data != sr -> uri . data ) { mk_ptr_free ( & sr -> uri_processed ) ; } if ( sr -> real_path . data != sr -> real_path_static ) { mk_ptr_free ( & sr -> real_path ) ; } },0 ) { if ( sr -> fd_is_fdt == MK_TRUE ) { <S2SV_ModStart> sr ) ; } else { close ( sr -> fd_file ) ; }
619,"GF_Err urn_Read ( GF_Box * s , GF_BitStream * bs ) { u32 i , to_read ; char * tmpName ; GF_DataEntryURNBox * ptr = ( GF_DataEntryURNBox * ) s ; if ( ! ptr -> size ) return GF_OK ; to_read = ( u32 ) ptr -> size ; tmpName = ( char * ) gf_malloc ( sizeof ( char ) * to_read ) ; if ( ! tmpName ) return GF_OUT_OF_MEM ; gf_bs_read_data ( bs , tmpName , to_read ) ; i = 0 ; <S2SV_StartBug> while ( ( tmpName [ i ] != 0 ) && ( i < to_read ) ) { <S2SV_EndBug> i ++ ; } if ( i == to_read ) { gf_free ( tmpName ) ; return GF_ISOM_INVALID_FILE ; } if ( i == to_read - 1 ) { ptr -> nameURN = tmpName ; ptr -> location = NULL ; return GF_OK ; } ptr -> nameURN = ( char * ) gf_malloc ( sizeof ( char ) * ( i + 1 ) ) ; if ( ! ptr -> nameURN ) { gf_free ( tmpName ) ; return GF_OUT_OF_MEM ; } ptr -> location = ( char * ) gf_malloc ( sizeof ( char ) * ( to_read - i - 1 ) ) ; if ( ! ptr -> location ) { gf_free ( tmpName ) ; gf_free ( ptr -> nameURN ) ; ptr -> nameURN = NULL ; return GF_OUT_OF_MEM ; } memcpy ( ptr -> nameURN , tmpName , i + 1 ) ; memcpy ( ptr -> location , tmpName + i + 1 , ( to_read - i - 1 ) ) ; gf_free ( tmpName ) ; return GF_OK ; }",; while ( ( i < to_read ) && <S2SV_ModStart> != 0 ) <S2SV_ModEnd> ) { i
620,"static int ext4_split_extent_at ( handle_t * handle , struct inode * inode , struct ext4_ext_path * path , ext4_lblk_t split , int split_flag , int flags ) { ext4_fsblk_t newblock ; ext4_lblk_t ee_block ; struct ext4_extent * ex , newex , orig_ex ; struct ext4_extent * ex2 = NULL ; unsigned int ee_len , depth ; <S2SV_StartBug> int err = 0 ; <S2SV_EndBug> ext_debug ( ""ext4_split_extents_at:<S2SV_blank>inode<S2SV_blank>%lu,<S2SV_blank>logical"" ""block<S2SV_blank>%llu\\n"" , inode -> i_ino , ( unsigned long long ) split ) ; ext4_ext_show_leaf ( inode , path ) ; depth = ext_depth ( inode ) ; ex = path [ depth ] . p_ext ; ee_block = le32_to_cpu ( ex -> ee_block ) ; ee_len = ext4_ext_get_actual_len ( ex ) ; newblock = split - ee_block + ext4_ext_pblock ( ex ) ; BUG_ON ( split < ee_block || split >= ( ee_block + ee_len ) ) ; err = ext4_ext_get_access ( handle , inode , path + depth ) ; if ( err ) goto out ; if ( split == ee_block ) { if ( split_flag & EXT4_EXT_MARK_UNINIT2 ) ext4_ext_mark_uninitialized ( ex ) ; else ext4_ext_mark_initialized ( ex ) ; if ( ! ( flags & EXT4_GET_BLOCKS_PRE_IO ) ) ext4_ext_try_to_merge ( handle , inode , path , ex ) ; err = ext4_ext_dirty ( handle , inode , path + path -> p_depth ) ; goto out ; } memcpy ( & orig_ex , ex , sizeof ( orig_ex ) ) ; ex -> ee_len = cpu_to_le16 ( split - ee_block ) ; if ( split_flag & EXT4_EXT_MARK_UNINIT1 ) ext4_ext_mark_uninitialized ( ex ) ; err = ext4_ext_dirty ( handle , inode , path + depth ) ; if ( err ) goto fix_extent_len ; ex2 = & newex ; ex2 -> ee_block = cpu_to_le32 ( split ) ; ex2 -> ee_len = cpu_to_le16 ( ee_len - ( split - ee_block ) ) ; ext4_ext_store_pblock ( ex2 , newblock ) ; if ( split_flag & EXT4_EXT_MARK_UNINIT2 ) ext4_ext_mark_uninitialized ( ex2 ) ; err = ext4_ext_insert_extent ( handle , inode , path , & newex , flags ) ; if ( err == - ENOSPC && ( EXT4_EXT_MAY_ZEROOUT & split_flag ) ) { <S2SV_StartBug> err = ext4_ext_zeroout ( inode , & orig_ex ) ; <S2SV_EndBug> if ( err ) goto fix_extent_len ; ex -> ee_len = cpu_to_le16 ( ee_len ) ; ext4_ext_try_to_merge ( handle , inode , path , ex ) ; err = ext4_ext_dirty ( handle , inode , path + path -> p_depth ) ; goto out ; } else if ( err ) goto fix_extent_len ; out : ext4_ext_show_leaf ( inode , path ) ; return err ; fix_extent_len : ex -> ee_len = orig_ex . ee_len ; ext4_ext_dirty ( handle , inode , path + depth ) ; return err ; }","err = 0 ; BUG_ON ( ( split_flag & ( EXT4_EXT_DATA_VALID1 | EXT4_EXT_DATA_VALID2 ) ) == ( EXT4_EXT_DATA_VALID1 | EXT4_EXT_DATA_VALID2 ) ) <S2SV_ModStart> ) ) { if ( split_flag & ( EXT4_EXT_DATA_VALID1 | EXT4_EXT_DATA_VALID2 ) ) { if ( split_flag & EXT4_EXT_DATA_VALID1 ) err = ext4_ext_zeroout ( inode , ex2 ) ; else err = ext4_ext_zeroout ( inode , ex ) ; } else"
621,"static __inline__ void jiffies_to_compat_timeval ( unsigned long jiffies , struct compat_timeval * value ) { u64 nsec = ( u64 ) jiffies * TICK_NSEC ; <S2SV_StartBug> long rem ; <S2SV_EndBug> <S2SV_StartBug> value -> tv_sec = div_long_long_rem ( nsec , NSEC_PER_SEC , & rem ) ; <S2SV_EndBug> value -> tv_usec = rem / NSEC_PER_USEC ; }","* TICK_NSEC ; u32 <S2SV_ModEnd> rem ; value <S2SV_ModStart> -> tv_sec = div_u64_rem <S2SV_ModEnd> ( nsec ,"
622,"static int __sock_diag_rcv_msg ( struct sk_buff * skb , struct nlmsghdr * nlh ) { int err ; struct sock_diag_req * req = nlmsg_data ( nlh ) ; const struct sock_diag_handler * hndl ; if ( nlmsg_len ( nlh ) < sizeof ( * req ) ) return - EINVAL ; <S2SV_StartBug> hndl = sock_diag_lock_handler ( req -> sdiag_family ) ; <S2SV_EndBug> if ( hndl == NULL ) err = - ENOENT ; else err = hndl -> dump ( skb , nlh ) ; sock_diag_unlock_handler ( hndl ) ; return err ; }",- EINVAL ; if ( req -> sdiag_family >= AF_MAX ) return - EINVAL ;
623,"static int pppol2tp_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { int err ; struct sk_buff * skb ; struct sock * sk = sock -> sk ; err = - EIO ; if ( sk -> sk_state & PPPOX_BOUND ) <S2SV_StartBug> goto end ; <S2SV_EndBug> msg -> msg_namelen = 0 ; err = 0 ; skb = skb_recv_datagram ( sk , flags & ~ MSG_DONTWAIT , flags & MSG_DONTWAIT , & err ) ; if ( ! skb ) goto end ; if ( len > skb -> len ) len = skb -> len ; else if ( len < skb -> len ) msg -> msg_flags |= MSG_TRUNC ; err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , len ) ; if ( likely ( err == 0 ) ) err = len ; kfree_skb ( skb ) ; end : return err ; }",) goto end <S2SV_ModEnd> ; err =
624,"static void <S2SV_StartBug> l2tp_bearer_type_print ( netdissect_options * ndo , const u_char * dat ) <S2SV_EndBug> { <S2SV_StartBug> const uint32_t * ptr = ( const uint32_t * ) dat ; <S2SV_EndBug> if ( EXTRACT_32BITS ( ptr ) & L2TP_BEARER_TYPE_ANALOG_MASK ) { ND_PRINT ( ( ndo , ""A"" ) ) ; } if ( EXTRACT_32BITS ( ptr ) & L2TP_BEARER_TYPE_DIGITAL_MASK ) { ND_PRINT ( ( ndo , ""D"" ) ) ; } }","u_char * dat , u_int length <S2SV_ModStart> ) dat ; if ( length < 4 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; return ; }"
625,"static void yydestruct ( const char * yymsg , int yytype , YYSTYPE * yyvaluep , void * yyscanner , HEX_LEX_ENVIRONMENT * lex_env ) { YYUSE ( yyvaluep ) ; YYUSE ( yyscanner ) ; YYUSE ( lex_env ) ; if ( ! yymsg ) yymsg = ""Deleting"" ; YY_SYMBOL_PRINT ( yymsg , yytype , yyvaluep , yylocationp ) ; YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN switch ( yytype ) { case 16 : <S2SV_StartBug> # line 94 ""hex_grammar.y"" <S2SV_EndBug> { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1023 ""hex_grammar.c"" break ; case 17 : <S2SV_StartBug> # line 95 ""hex_grammar.y"" <S2SV_EndBug> { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1029 ""hex_grammar.c"" break ; case 18 : <S2SV_StartBug> # line 96 ""hex_grammar.y"" <S2SV_EndBug> { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1035 ""hex_grammar.c"" break ; case 19 : <S2SV_StartBug> # line 97 ""hex_grammar.y"" <S2SV_EndBug> { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1041 ""hex_grammar.c"" break ; case 21 : <S2SV_StartBug> # line 100 ""hex_grammar.y"" <S2SV_EndBug> { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1047 ""hex_grammar.c"" break ; case 22 : <S2SV_StartBug> # line 99 ""hex_grammar.y"" <S2SV_EndBug> { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1053 ""hex_grammar.c"" break ; case 23 : <S2SV_StartBug> # line 98 ""hex_grammar.y"" <S2SV_EndBug> { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1059 ""hex_grammar.c"" break ; default : break ; } YY_IGNORE_MAYBE_UNINITIALIZED_END }",": # line 101 ""hex_grammar.y"" { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1030 <S2SV_ModEnd> ""hex_grammar.c"" break ; <S2SV_ModStart> : # line 102 ""hex_grammar.y"" { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1036 <S2SV_ModEnd> ""hex_grammar.c"" break ; <S2SV_ModStart> : # line 103 ""hex_grammar.y"" { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1042 <S2SV_ModEnd> ""hex_grammar.c"" break ; <S2SV_ModStart> : # line 104 ""hex_grammar.y"" { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1048 <S2SV_ModEnd> ""hex_grammar.c"" break ; <S2SV_ModStart> : # line 107 ""hex_grammar.y"" { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1054 <S2SV_ModEnd> ""hex_grammar.c"" break ; <S2SV_ModStart> : # line 106 ""hex_grammar.y"" { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1060 <S2SV_ModEnd> ""hex_grammar.c"" break ; <S2SV_ModStart> : # line 105 ""hex_grammar.y"" { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1066 <S2SV_ModEnd> ""hex_grammar.c"" break ;"
626,"static bool assoc_array_insert_into_terminal_node ( struct assoc_array_edit * edit , const struct assoc_array_ops * ops , const void * index_key , struct assoc_array_walk_result * result ) { struct assoc_array_shortcut * shortcut , * new_s0 ; struct assoc_array_node * node , * new_n0 , * new_n1 , * side ; struct assoc_array_ptr * ptr ; unsigned long dissimilarity , base_seg , blank ; size_t keylen ; bool have_meta ; int level , diff ; int slot , next_slot , free_slot , i , j ; node = result -> terminal_node . node ; level = result -> terminal_node . level ; edit -> segment_cache [ ASSOC_ARRAY_FAN_OUT ] = result -> terminal_node . slot ; pr_devel ( ""-->%s()\\n"" , __func__ ) ; free_slot = - 1 ; for ( i = 0 ; i < ASSOC_ARRAY_FAN_OUT ; i ++ ) { ptr = node -> slots [ i ] ; if ( ! ptr ) { free_slot = i ; continue ; } <S2SV_StartBug> if ( ops -> compare_object ( assoc_array_ptr_to_leaf ( ptr ) , index_key ) ) { <S2SV_EndBug> pr_devel ( ""replace<S2SV_blank>in<S2SV_blank>slot<S2SV_blank>%d\\n"" , i ) ; edit -> leaf_p = & node -> slots [ i ] ; edit -> dead_leaf = node -> slots [ i ] ; pr_devel ( ""<--%s()<S2SV_blank>=<S2SV_blank>ok<S2SV_blank>[replace]\\n"" , __func__ ) ; return true ; } } if ( free_slot >= 0 ) { pr_devel ( ""insert<S2SV_blank>in<S2SV_blank>free<S2SV_blank>slot<S2SV_blank>%d\\n"" , free_slot ) ; edit -> leaf_p = & node -> slots [ free_slot ] ; edit -> adjust_count_on = node ; pr_devel ( ""<--%s()<S2SV_blank>=<S2SV_blank>ok<S2SV_blank>[insert]\\n"" , __func__ ) ; return true ; } new_n0 = kzalloc ( sizeof ( struct assoc_array_node ) , GFP_KERNEL ) ; if ( ! new_n0 ) return false ; edit -> new_meta [ 0 ] = assoc_array_node_to_ptr ( new_n0 ) ; new_n1 = kzalloc ( sizeof ( struct assoc_array_node ) , GFP_KERNEL ) ; if ( ! new_n1 ) return false ; edit -> new_meta [ 1 ] = assoc_array_node_to_ptr ( new_n1 ) ; pr_devel ( ""no<S2SV_blank>spare<S2SV_blank>slots\\n"" ) ; have_meta = false ; for ( i = 0 ; i < ASSOC_ARRAY_FAN_OUT ; i ++ ) { ptr = node -> slots [ i ] ; if ( assoc_array_ptr_is_meta ( ptr ) ) { edit -> segment_cache [ i ] = 0xff ; have_meta = true ; continue ; } base_seg = ops -> get_object_key_chunk ( assoc_array_ptr_to_leaf ( ptr ) , level ) ; base_seg >>= level & ASSOC_ARRAY_KEY_CHUNK_MASK ; edit -> segment_cache [ i ] = base_seg & ASSOC_ARRAY_FAN_MASK ; } if ( have_meta ) { pr_devel ( ""have<S2SV_blank>meta\\n"" ) ; goto split_node ; } dissimilarity = 0 ; base_seg = edit -> segment_cache [ 0 ] ; for ( i = 1 ; i < ASSOC_ARRAY_FAN_OUT ; i ++ ) dissimilarity |= edit -> segment_cache [ i ] ^ base_seg ; pr_devel ( ""only<S2SV_blank>leaves;<S2SV_blank>dissimilarity=%lx\\n"" , dissimilarity ) ; if ( ( dissimilarity & ASSOC_ARRAY_FAN_MASK ) == 0 ) { if ( ( edit -> segment_cache [ ASSOC_ARRAY_FAN_OUT ] ^ base_seg ) == 0 ) goto all_leaves_cluster_together ; goto present_leaves_cluster_but_not_new_leaf ; } split_node : pr_devel ( ""split<S2SV_blank>node\\n"" ) ; edit -> set [ 0 ] . to = assoc_array_node_to_ptr ( new_n0 ) ; new_n0 -> back_pointer = node -> back_pointer ; new_n0 -> parent_slot = node -> parent_slot ; new_n1 -> back_pointer = assoc_array_node_to_ptr ( new_n0 ) ; new_n1 -> parent_slot = - 1 ; do_split_node : pr_devel ( ""do_split_node\\n"" ) ; new_n0 -> nr_leaves_on_branch = node -> nr_leaves_on_branch ; new_n1 -> nr_leaves_on_branch = 0 ; for ( i = 0 ; i < ASSOC_ARRAY_FAN_OUT ; i ++ ) { slot = edit -> segment_cache [ i ] ; if ( slot != 0xff ) for ( j = i + 1 ; j < ASSOC_ARRAY_FAN_OUT + 1 ; j ++ ) if ( edit -> segment_cache [ j ] == slot ) goto found_slot_for_multiple_occupancy ; } found_slot_for_multiple_occupancy : pr_devel ( ""same<S2SV_blank>slot:<S2SV_blank>%x<S2SV_blank>%x<S2SV_blank>[%02x]\\n"" , i , j , slot ) ; BUG_ON ( i >= ASSOC_ARRAY_FAN_OUT ) ; BUG_ON ( j >= ASSOC_ARRAY_FAN_OUT + 1 ) ; BUG_ON ( slot >= ASSOC_ARRAY_FAN_OUT ) ; new_n1 -> parent_slot = slot ; for ( i = 0 ; i < ASSOC_ARRAY_FAN_OUT ; i ++ ) if ( assoc_array_ptr_is_meta ( node -> slots [ i ] ) ) new_n0 -> slots [ i ] = node -> slots [ i ] ; else new_n0 -> slots [ i ] = NULL ; BUG_ON ( new_n0 -> slots [ slot ] != NULL ) ; new_n0 -> slots [ slot ] = assoc_array_node_to_ptr ( new_n1 ) ; free_slot = - 1 ; next_slot = 0 ; for ( i = 0 ; i < ASSOC_ARRAY_FAN_OUT ; i ++ ) { if ( assoc_array_ptr_is_meta ( node -> slots [ i ] ) ) continue ; if ( edit -> segment_cache [ i ] == slot ) { new_n1 -> slots [ next_slot ++ ] = node -> slots [ i ] ; new_n1 -> nr_leaves_on_branch ++ ; } else { do { free_slot ++ ; } while ( new_n0 -> slots [ free_slot ] != NULL ) ; new_n0 -> slots [ free_slot ] = node -> slots [ i ] ; } } pr_devel ( ""filtered:<S2SV_blank>f=%x<S2SV_blank>n=%x\\n"" , free_slot , next_slot ) ; if ( edit -> segment_cache [ ASSOC_ARRAY_FAN_OUT ] != slot ) { do { free_slot ++ ; } while ( new_n0 -> slots [ free_slot ] != NULL ) ; edit -> leaf_p = & new_n0 -> slots [ free_slot ] ; edit -> adjust_count_on = new_n0 ; } else { edit -> leaf_p = & new_n1 -> slots [ next_slot ++ ] ; edit -> adjust_count_on = new_n1 ; } BUG_ON ( next_slot <= 1 ) ; edit -> set_backpointers_to = assoc_array_node_to_ptr ( new_n0 ) ; for ( i = 0 ; i < ASSOC_ARRAY_FAN_OUT ; i ++ ) { if ( edit -> segment_cache [ i ] == 0xff ) { ptr = node -> slots [ i ] ; BUG_ON ( assoc_array_ptr_is_leaf ( ptr ) ) ; if ( assoc_array_ptr_is_node ( ptr ) ) { side = assoc_array_ptr_to_node ( ptr ) ; edit -> set_backpointers [ i ] = & side -> back_pointer ; } else { shortcut = assoc_array_ptr_to_shortcut ( ptr ) ; edit -> set_backpointers [ i ] = & shortcut -> back_pointer ; } } } ptr = node -> back_pointer ; if ( ! ptr ) edit -> set [ 0 ] . ptr = & edit -> array -> root ; else if ( assoc_array_ptr_is_node ( ptr ) ) edit -> set [ 0 ] . ptr = & assoc_array_ptr_to_node ( ptr ) -> slots [ node -> parent_slot ] ; else edit -> set [ 0 ] . ptr = & assoc_array_ptr_to_shortcut ( ptr ) -> next_node ; edit -> excised_meta [ 0 ] = assoc_array_node_to_ptr ( node ) ; pr_devel ( ""<--%s()<S2SV_blank>=<S2SV_blank>ok<S2SV_blank>[split<S2SV_blank>node]\\n"" , __func__ ) ; return true ; present_leaves_cluster_but_not_new_leaf : pr_devel ( ""present<S2SV_blank>leaves<S2SV_blank>cluster<S2SV_blank>but<S2SV_blank>not<S2SV_blank>new<S2SV_blank>leaf\\n"" ) ; new_n0 -> back_pointer = node -> back_pointer ; new_n0 -> parent_slot = node -> parent_slot ; new_n0 -> nr_leaves_on_branch = node -> nr_leaves_on_branch ; new_n1 -> back_pointer = assoc_array_node_to_ptr ( new_n0 ) ; new_n1 -> parent_slot = edit -> segment_cache [ 0 ] ; new_n1 -> nr_leaves_on_branch = node -> nr_leaves_on_branch ; edit -> adjust_count_on = new_n0 ; for ( i = 0 ; i < ASSOC_ARRAY_FAN_OUT ; i ++ ) new_n1 -> slots [ i ] = node -> slots [ i ] ; new_n0 -> slots [ edit -> segment_cache [ 0 ] ] = assoc_array_node_to_ptr ( new_n0 ) ; edit -> leaf_p = & new_n0 -> slots [ edit -> segment_cache [ ASSOC_ARRAY_FAN_OUT ] ] ; edit -> set [ 0 ] . ptr = & assoc_array_ptr_to_node ( node -> back_pointer ) -> slots [ node -> parent_slot ] ; edit -> set [ 0 ] . to = assoc_array_node_to_ptr ( new_n0 ) ; edit -> excised_meta [ 0 ] = assoc_array_node_to_ptr ( node ) ; pr_devel ( ""<--%s()<S2SV_blank>=<S2SV_blank>ok<S2SV_blank>[insert<S2SV_blank>node<S2SV_blank>before]\\n"" , __func__ ) ; return true ; all_leaves_cluster_together : pr_devel ( ""all<S2SV_blank>leaves<S2SV_blank>cluster<S2SV_blank>together\\n"" ) ; diff = INT_MAX ; for ( i = 0 ; i < ASSOC_ARRAY_FAN_OUT ; i ++ ) { int x = ops -> diff_objects ( assoc_array_ptr_to_leaf ( node -> slots [ i ] ) , index_key ) ; if ( x < diff ) { BUG_ON ( x < 0 ) ; diff = x ; } } BUG_ON ( diff == INT_MAX ) ; BUG_ON ( diff < level + ASSOC_ARRAY_LEVEL_STEP ) ; keylen = round_up ( diff , ASSOC_ARRAY_KEY_CHUNK_SIZE ) ; keylen >>= ASSOC_ARRAY_KEY_CHUNK_SHIFT ; new_s0 = kzalloc ( sizeof ( struct assoc_array_shortcut ) + keylen * sizeof ( unsigned long ) , GFP_KERNEL ) ; if ( ! new_s0 ) return false ; edit -> new_meta [ 2 ] = assoc_array_shortcut_to_ptr ( new_s0 ) ; edit -> set [ 0 ] . to = assoc_array_shortcut_to_ptr ( new_s0 ) ; new_s0 -> back_pointer = node -> back_pointer ; new_s0 -> parent_slot = node -> parent_slot ; new_s0 -> next_node = assoc_array_node_to_ptr ( new_n0 ) ; new_n0 -> back_pointer = assoc_array_shortcut_to_ptr ( new_s0 ) ; new_n0 -> parent_slot = 0 ; new_n1 -> back_pointer = assoc_array_node_to_ptr ( new_n0 ) ; new_n1 -> parent_slot = - 1 ; new_s0 -> skip_to_level = level = diff & ~ ASSOC_ARRAY_LEVEL_STEP_MASK ; pr_devel ( ""skip_to_level<S2SV_blank>=<S2SV_blank>%d<S2SV_blank>[diff<S2SV_blank>%d]\\n"" , level , diff ) ; BUG_ON ( level <= 0 ) ; for ( i = 0 ; i < keylen ; i ++ ) new_s0 -> index_key [ i ] = ops -> get_key_chunk ( index_key , i * ASSOC_ARRAY_KEY_CHUNK_SIZE ) ; blank = ULONG_MAX << ( level & ASSOC_ARRAY_KEY_CHUNK_MASK ) ; pr_devel ( ""blank<S2SV_blank>off<S2SV_blank>[%zu]<S2SV_blank>%d:<S2SV_blank>%lx\\n"" , keylen - 1 , level , blank ) ; new_s0 -> index_key [ keylen - 1 ] &= ~ blank ; for ( i = 0 ; i < ASSOC_ARRAY_FAN_OUT ; i ++ ) { ptr = node -> slots [ i ] ; base_seg = ops -> get_object_key_chunk ( assoc_array_ptr_to_leaf ( ptr ) , level ) ; base_seg >>= level & ASSOC_ARRAY_KEY_CHUNK_MASK ; edit -> segment_cache [ i ] = base_seg & ASSOC_ARRAY_FAN_MASK ; } base_seg = ops -> get_key_chunk ( index_key , level ) ; base_seg >>= level & ASSOC_ARRAY_KEY_CHUNK_MASK ; edit -> segment_cache [ ASSOC_ARRAY_FAN_OUT ] = base_seg & ASSOC_ARRAY_FAN_MASK ; goto do_split_node ; }",} if ( assoc_array_ptr_is_leaf ( ptr ) &&
627,"static int chmd_read_headers ( struct mspack_system * sys , struct mspack_file * fh , struct mschmd_header * chm , int entire ) { unsigned int section , name_len , x , errors , num_chunks ; unsigned char buf [ 0x54 ] , * chunk = NULL , * name , * p , * end ; struct mschmd_file * fi , * link = NULL ; off_t offset , length ; int num_entries ; chm -> files = NULL ; chm -> sysfiles = NULL ; chm -> chunk_cache = NULL ; chm -> sec0 . base . chm = chm ; chm -> sec0 . base . id = 0 ; chm -> sec1 . base . chm = chm ; chm -> sec1 . base . id = 1 ; chm -> sec1 . content = NULL ; chm -> sec1 . control = NULL ; chm -> sec1 . spaninfo = NULL ; chm -> sec1 . rtable = NULL ; if ( sys -> read ( fh , & buf [ 0 ] , chmhead_SIZEOF ) != chmhead_SIZEOF ) { return MSPACK_ERR_READ ; } if ( EndGetI32 ( & buf [ chmhead_Signature ] ) != 0x46535449 ) { return MSPACK_ERR_SIGNATURE ; } if ( memcmp ( & buf [ chmhead_GUID1 ] , & guids [ 0 ] , 32L ) != 0 ) { D ( ( ""incorrect<S2SV_blank>GUIDs"" ) ) return MSPACK_ERR_SIGNATURE ; } chm -> version = EndGetI32 ( & buf [ chmhead_Version ] ) ; chm -> timestamp = EndGetM32 ( & buf [ chmhead_Timestamp ] ) ; chm -> language = EndGetI32 ( & buf [ chmhead_LanguageID ] ) ; if ( chm -> version > 3 ) { sys -> message ( fh , ""WARNING;<S2SV_blank>CHM<S2SV_blank>version<S2SV_blank>><S2SV_blank>3"" ) ; } if ( sys -> read ( fh , & buf [ 0 ] , chmhst3_SIZEOF ) != chmhst3_SIZEOF ) { return MSPACK_ERR_READ ; } if ( read_off64 ( & offset , & buf [ chmhst_OffsetHS0 ] , sys , fh ) || read_off64 ( & chm -> dir_offset , & buf [ chmhst_OffsetHS1 ] , sys , fh ) || read_off64 ( & chm -> sec0 . offset , & buf [ chmhst3_OffsetCS0 ] , sys , fh ) ) { return MSPACK_ERR_DATAFORMAT ; } if ( sys -> seek ( fh , offset , MSPACK_SYS_SEEK_START ) ) { return MSPACK_ERR_SEEK ; } if ( sys -> read ( fh , & buf [ 0 ] , chmhs0_SIZEOF ) != chmhs0_SIZEOF ) { return MSPACK_ERR_READ ; } if ( read_off64 ( & chm -> length , & buf [ chmhs0_FileLen ] , sys , fh ) ) { return MSPACK_ERR_DATAFORMAT ; } if ( sys -> seek ( fh , chm -> dir_offset , MSPACK_SYS_SEEK_START ) ) { return MSPACK_ERR_SEEK ; } if ( sys -> read ( fh , & buf [ 0 ] , chmhs1_SIZEOF ) != chmhs1_SIZEOF ) { return MSPACK_ERR_READ ; } chm -> dir_offset = sys -> tell ( fh ) ; chm -> chunk_size = EndGetI32 ( & buf [ chmhs1_ChunkSize ] ) ; chm -> density = EndGetI32 ( & buf [ chmhs1_Density ] ) ; chm -> depth = EndGetI32 ( & buf [ chmhs1_Depth ] ) ; chm -> index_root = EndGetI32 ( & buf [ chmhs1_IndexRoot ] ) ; chm -> num_chunks = EndGetI32 ( & buf [ chmhs1_NumChunks ] ) ; chm -> first_pmgl = EndGetI32 ( & buf [ chmhs1_FirstPMGL ] ) ; chm -> last_pmgl = EndGetI32 ( & buf [ chmhs1_LastPMGL ] ) ; if ( chm -> version < 3 ) { chm -> sec0 . offset = chm -> dir_offset + ( chm -> chunk_size * chm -> num_chunks ) ; } if ( chm -> sec0 . offset > chm -> length ) { D ( ( ""content<S2SV_blank>section<S2SV_blank>begins<S2SV_blank>after<S2SV_blank>file<S2SV_blank>has<S2SV_blank>ended"" ) ) return MSPACK_ERR_DATAFORMAT ; } if ( chm -> chunk_size < ( pmgl_Entries + 2 ) ) { D ( ( ""chunk<S2SV_blank>size<S2SV_blank>not<S2SV_blank>large<S2SV_blank>enough"" ) ) return MSPACK_ERR_DATAFORMAT ; } if ( chm -> num_chunks == 0 ) { D ( ( ""no<S2SV_blank>chunks"" ) ) return MSPACK_ERR_DATAFORMAT ; } if ( chm -> num_chunks > 100000 ) { D ( ( ""more<S2SV_blank>than<S2SV_blank>100,000<S2SV_blank>chunks"" ) ) return MSPACK_ERR_DATAFORMAT ; } if ( ( off_t ) chm -> chunk_size * ( off_t ) chm -> num_chunks > chm -> length ) { D ( ( ""chunks<S2SV_blank>larger<S2SV_blank>than<S2SV_blank>entire<S2SV_blank>file"" ) ) return MSPACK_ERR_DATAFORMAT ; } if ( ( chm -> chunk_size & ( chm -> chunk_size - 1 ) ) != 0 ) { sys -> message ( fh , ""WARNING;<S2SV_blank>chunk<S2SV_blank>size<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>power<S2SV_blank>of<S2SV_blank>two"" ) ; } if ( chm -> first_pmgl != 0 ) { sys -> message ( fh , ""WARNING;<S2SV_blank>first<S2SV_blank>PMGL<S2SV_blank>chunk<S2SV_blank>is<S2SV_blank>not<S2SV_blank>zero"" ) ; } if ( chm -> first_pmgl > chm -> last_pmgl ) { D ( ( ""first<S2SV_blank>pmgl<S2SV_blank>chunk<S2SV_blank>is<S2SV_blank>after<S2SV_blank>last<S2SV_blank>pmgl<S2SV_blank>chunk"" ) ) return MSPACK_ERR_DATAFORMAT ; } if ( chm -> index_root != 0xFFFFFFFF && chm -> index_root >= chm -> num_chunks ) { D ( ( ""index_root<S2SV_blank>outside<S2SV_blank>valid<S2SV_blank>range"" ) ) return MSPACK_ERR_DATAFORMAT ; } if ( ! entire ) { return MSPACK_ERR_OK ; } if ( ( x = chm -> first_pmgl ) != 0 ) { if ( sys -> seek ( fh , ( off_t ) ( x * chm -> chunk_size ) , MSPACK_SYS_SEEK_CUR ) ) { return MSPACK_ERR_SEEK ; } } num_chunks = chm -> last_pmgl - x + 1 ; if ( ! ( chunk = ( unsigned char * ) sys -> alloc ( sys , ( size_t ) chm -> chunk_size ) ) ) { return MSPACK_ERR_NOMEMORY ; } errors = 0 ; while ( num_chunks -- ) { if ( sys -> read ( fh , chunk , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) { sys -> free ( chunk ) ; return MSPACK_ERR_READ ; } if ( EndGetI32 ( & chunk [ pmgl_Signature ] ) != 0x4C474D50 ) continue ; if ( EndGetI32 ( & chunk [ pmgl_QuickRefSize ] ) < 2 ) { sys -> message ( fh , ""WARNING;<S2SV_blank>PMGL<S2SV_blank>quickref<S2SV_blank>area<S2SV_blank>is<S2SV_blank>too<S2SV_blank>small"" ) ; } if ( EndGetI32 ( & chunk [ pmgl_QuickRefSize ] ) > ( ( int ) chm -> chunk_size - pmgl_Entries ) ) { sys -> message ( fh , ""WARNING;<S2SV_blank>PMGL<S2SV_blank>quickref<S2SV_blank>area<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large"" ) ; } p = & chunk [ pmgl_Entries ] ; end = & chunk [ chm -> chunk_size - 2 ] ; num_entries = EndGetI16 ( end ) ; while ( num_entries -- ) { READ_ENCINT ( name_len ) ; if ( name_len > ( unsigned int ) ( end - p ) ) goto chunk_end ; name = p ; p += name_len ; READ_ENCINT ( section ) ; READ_ENCINT ( offset ) ; READ_ENCINT ( length ) ; if ( name_len < 2 || ! name [ 0 ] || ! name [ 1 ] ) continue ; if ( ( offset == 0 ) && ( length == 0 ) ) { if ( ( name_len > 0 ) && ( name [ name_len - 1 ] == '/' ) ) continue ; } if ( section > 1 ) { sys -> message ( fh , ""invalid<S2SV_blank>section<S2SV_blank>number<S2SV_blank>\'%u\'."" , section ) ; continue ; } if ( ! ( fi = ( struct mschmd_file * ) sys -> alloc ( sys , sizeof ( struct mschmd_file ) + name_len + 1 ) ) ) { sys -> free ( chunk ) ; return MSPACK_ERR_NOMEMORY ; } fi -> next = NULL ; fi -> filename = ( char * ) & fi [ 1 ] ; fi -> section = ( ( section == 0 ) ? ( struct mschmd_section * ) ( & chm -> sec0 ) : ( struct mschmd_section * ) ( & chm -> sec1 ) ) ; fi -> offset = offset ; fi -> length = length ; sys -> copy ( name , fi -> filename , ( size_t ) name_len ) ; fi -> filename [ name_len ] = '\\0' ; if ( name [ 0 ] == ':' && name [ 1 ] == ':' ) { <S2SV_StartBug> if ( memcmp ( & name [ 2 ] , & content_name [ 2 ] , 31L ) == 0 ) { <S2SV_EndBug> <S2SV_StartBug> if ( memcmp ( & name [ 33 ] , & content_name [ 33 ] , 8L ) == 0 ) { <S2SV_EndBug> <S2SV_StartBug> chm -> sec1 . content = fi ; <S2SV_EndBug> } <S2SV_StartBug> else if ( memcmp ( & name [ 33 ] , & control_name [ 33 ] , 11L ) == 0 ) { <S2SV_EndBug> <S2SV_StartBug> chm -> sec1 . control = fi ; <S2SV_EndBug> } <S2SV_StartBug> else if ( memcmp ( & name [ 33 ] , & spaninfo_name [ 33 ] , 8L ) == 0 ) { <S2SV_EndBug> <S2SV_StartBug> chm -> sec1 . spaninfo = fi ; <S2SV_EndBug> } else if ( memcmp ( & name [ 33 ] , & rtable_name [ 33 ] , 72L ) == 0 ) { chm -> sec1 . rtable = fi ; <S2SV_StartBug> } <S2SV_EndBug> } fi -> next = chm -> sysfiles ; chm -> sysfiles = fi ; } else { if ( link ) link -> next = fi ; else chm -> files = fi ; link = fi ; } } chunk_end : if ( num_entries >= 0 ) { D ( ( ""chunk<S2SV_blank>ended<S2SV_blank>before<S2SV_blank>all<S2SV_blank>entries<S2SV_blank>could<S2SV_blank>be<S2SV_blank>read"" ) ) errors ++ ; } } sys -> free ( chunk ) ; return ( errors > 0 ) ? MSPACK_ERR_DATAFORMAT : MSPACK_ERR_OK ; }","{ if ( name_len == 40 && memcmp ( name , content_name , 40 <S2SV_ModEnd> ) == 0 <S2SV_ModStart> 0 ) { chm -> sec1 . content = fi ; } else if ( name_len == 44 && memcmp ( name , control_name , 44 <S2SV_ModEnd> ) == 0 <S2SV_ModStart> -> sec1 . control <S2SV_ModEnd> = fi ; <S2SV_ModStart> else if ( name_len == 41 && memcmp ( name , spaninfo_name , 41 <S2SV_ModEnd> ) == 0 <S2SV_ModStart> -> sec1 . spaninfo <S2SV_ModEnd> = fi ; <S2SV_ModStart> else if ( name_len == 105 && memcmp ( name , rtable_name , 105 <S2SV_ModEnd> ) == 0 <S2SV_ModStart> -> sec1 . <S2SV_ModEnd> rtable = fi <S2SV_ModStart> = fi ; <S2SV_ModEnd> } fi ->"
628,"int main ( int argc , char * * argv ) { setlocale ( LC_ALL , """" ) ; # if ENABLE_NLS bindtextdomain ( PACKAGE , LOCALEDIR ) ; textdomain ( PACKAGE ) ; # endif abrt_init ( argv ) ; const char * program_usage_string = _ ( ""&<S2SV_blank>[-y]<S2SV_blank>[-i<S2SV_blank>BUILD_IDS_FILE|-i<S2SV_blank>-]<S2SV_blank>[-e<S2SV_blank>PATH[:PATH]...]\\n"" ""\\t[-r<S2SV_blank>REPO]\\n"" ""\\n"" ""Installs<S2SV_blank>debuginfo<S2SV_blank>packages<S2SV_blank>for<S2SV_blank>all<S2SV_blank>build-ids<S2SV_blank>listed<S2SV_blank>in<S2SV_blank>BUILD_IDS_FILE<S2SV_blank>to\\n"" ""ABRT<S2SV_blank>system<S2SV_blank>cache."" ) ; enum { OPT_v = 1 << 0 , OPT_y = 1 << 1 , OPT_i = 1 << 2 , OPT_e = 1 << 3 , OPT_r = 1 << 4 , OPT_s = 1 << 5 , } ; const char * build_ids = ""build_ids"" ; const char * exact = NULL ; const char * repo = NULL ; const char * size_mb = NULL ; struct options program_options [ ] = { OPT__VERBOSE ( & g_verbose ) , OPT_BOOL ( 'y' , ""yes"" , NULL , _ ( ""Noninteractive,<S2SV_blank>assume<S2SV_blank>\'Yes\'<S2SV_blank>to<S2SV_blank>all<S2SV_blank>questions"" ) ) , OPT_STRING ( 'i' , ""ids"" , & build_ids , ""BUILD_IDS_FILE"" , _ ( ""-<S2SV_blank>means<S2SV_blank>STDIN,<S2SV_blank>default:<S2SV_blank>build_ids"" ) ) , OPT_STRING ( 'e' , ""exact"" , & exact , ""EXACT"" , _ ( ""Download<S2SV_blank>only<S2SV_blank>specified<S2SV_blank>files"" ) ) , OPT_STRING ( 'r' , ""repo"" , & repo , ""REPO"" , _ ( ""Pattern<S2SV_blank>to<S2SV_blank>use<S2SV_blank>when<S2SV_blank>searching<S2SV_blank>for<S2SV_blank>repos,<S2SV_blank>default:<S2SV_blank>*debug*"" ) ) , OPT_STRING ( 's' , ""size_mb"" , & size_mb , ""SIZE_MB"" , _ ( ""Ignored<S2SV_blank>option"" ) ) , OPT_END ( ) } ; const unsigned opts = parse_opts ( argc , argv , program_options , program_usage_string ) ; const gid_t egid = getegid ( ) ; const gid_t rgid = getgid ( ) ; const uid_t euid = geteuid ( ) ; const gid_t ruid = getuid ( ) ; char * build_ids_self_fd = NULL ; if ( strcmp ( ""-"" , build_ids ) != 0 ) { if ( setregid ( egid , rgid ) < 0 ) perror_msg_and_die ( ""setregid(egid,<S2SV_blank>rgid)"" ) ; if ( setreuid ( euid , ruid ) < 0 ) perror_msg_and_die ( ""setreuid(euid,<S2SV_blank>ruid)"" ) ; const int build_ids_fd = open ( build_ids , O_RDONLY ) ; if ( setregid ( rgid , egid ) < 0 ) perror_msg_and_die ( ""setregid(rgid,<S2SV_blank>egid)"" ) ; if ( setreuid ( ruid , euid ) < 0 ) perror_msg_and_die ( ""setreuid(ruid,<S2SV_blank>euid)"" ) ; if ( build_ids_fd < 0 ) perror_msg_and_die ( ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>file<S2SV_blank>\'%s\'"" , build_ids ) ; build_ids_self_fd = xasprintf ( ""/proc/self/fd/%d"" , build_ids_fd ) ; } <S2SV_StartBug> const char * args [ 11 ] ; <S2SV_EndBug> { const char * verbs [ ] = { """" , ""-v"" , ""-vv"" , ""-vvv"" } ; unsigned i = 0 ; args [ i ++ ] = EXECUTABLE ; args [ i ++ ] = ""--ids"" ; args [ i ++ ] = ( build_ids_self_fd != NULL ) ? build_ids_self_fd : ""-"" ; if ( g_verbose > 0 ) args [ i ++ ] = verbs [ g_verbose <= 3 ? g_verbose : 3 ] ; if ( ( opts & OPT_y ) ) args [ i ++ ] = ""-y"" ; if ( ( opts & OPT_e ) ) { args [ i ++ ] = ""--exact"" ; args [ i ++ ] = exact ; } if ( ( opts & OPT_r ) ) { args [ i ++ ] = ""--repo"" ; args [ i ++ ] = repo ; } <S2SV_StartBug> args [ i ++ ] = ""--"" ; <S2SV_EndBug> args [ i ] = NULL ; } if ( egid != rgid ) IGNORE_RESULT ( setregid ( egid , egid ) ) ; if ( euid != ruid ) { IGNORE_RESULT ( setreuid ( euid , euid ) ) ; # if 1 static const char * whitelist [ ] = { ""REPORT_CLIENT_SLAVE"" , ""LANG"" , } ; const size_t wlsize = sizeof ( whitelist ) / sizeof ( char * ) ; char * setlist [ sizeof ( whitelist ) / sizeof ( char * ) ] = { 0 } ; char * p = NULL ; for ( size_t i = 0 ; i < wlsize ; i ++ ) if ( ( p = getenv ( whitelist [ i ] ) ) != NULL ) setlist [ i ] = xstrdup ( p ) ; clearenv ( ) ; for ( size_t i = 0 ; i < wlsize ; i ++ ) if ( setlist [ i ] != NULL ) { xsetenv ( whitelist [ i ] , setlist [ i ] ) ; free ( setlist [ i ] ) ; } # else static const char forbid [ ] = ""LD_LIBRARY_PATH"" ""\\0"" ""LD_PRELOAD"" ""\\0"" ""LD_TRACE_LOADED_OBJECTS"" ""\\0"" ""LD_BIND_NOW"" ""\\0"" ""LD_AOUT_LIBRARY_PATH"" ""\\0"" ""LD_AOUT_PRELOAD"" ""\\0"" ""LD_NOWARN"" ""\\0"" ""LD_KEEPDIR"" ""\\0"" ; const char * p = forbid ; do { unsetenv ( p ) ; p += strlen ( p ) + 1 ; } while ( * p ) ; # endif char path_env [ ] = ""PATH=/usr/sbin:/sbin:/usr/bin:/bin:"" BIN_DIR "":"" SBIN_DIR ; if ( euid != 0 ) strcpy ( path_env , ""PATH=/usr/bin:/bin:"" BIN_DIR ) ; putenv ( path_env ) ; umask ( 0022 ) ; } <S2SV_StartBug> execvp ( EXECUTABLE , ( char * * ) args ) ; <S2SV_EndBug> error_msg_and_die ( ""Can\'t<S2SV_blank>execute<S2SV_blank>%s"" , EXECUTABLE ) ; <S2SV_StartBug> } <S2SV_EndBug>",") ; } char tmp_directory [ ] = LARGE_DATA_TMP_DIR ""/abrt-tmp-debuginfo.XXXXXX"" ; if ( mkdtemp ( tmp_directory ) == NULL ) perror_msg_and_die ( ""Failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>working<S2SV_blank>directory"" ) ; log_info ( ""Created<S2SV_blank>working<S2SV_blank>directory:<S2SV_blank>%s"" , tmp_directory ) ; const char * args [ 13 <S2SV_ModEnd> ] ; { <S2SV_ModStart> ++ ] = ""--tmpdir"" ; args [ i ++ ] = tmp_directory ; args [ i ++ ] = <S2SV_ModStart> ) ; } pid_t pid = fork ( ) ; if ( pid < 0 ) perror_msg_and_die ( ""fork"" ) ; if ( pid == 0 ) { <S2SV_ModStart> ) ; } int status ; if ( safe_waitpid ( pid , & status , 0 ) < 0 ) perror_msg_and_die ( ""waitpid"" ) ; if ( rmdir ( tmp_directory ) >= 0 ) log_info ( ""Removed<S2SV_blank>working<S2SV_blank>directory:<S2SV_blank>%s"" , tmp_directory ) ; else if ( errno != ENOENT ) perror_msg ( ""Failed<S2SV_blank>to<S2SV_blank>remove<S2SV_blank>working<S2SV_blank>directory"" ) ; if ( WIFEXITED ( status ) ) return WEXITSTATUS ( status ) ; if ( WIFSIGNALED ( status ) ) error_msg_and_die ( ""Child<S2SV_blank>terminated<S2SV_blank>with<S2SV_blank>signal<S2SV_blank>%d"" , WTERMSIG ( status ) ) ; error_msg_and_die ( ""Child<S2SV_blank>exit<S2SV_blank>failed"" ) ; }"
629,"struct sock * dccp_v4_request_recv_sock ( struct sock * sk , struct sk_buff * skb , struct request_sock * req , struct dst_entry * dst ) { struct inet_request_sock * ireq ; struct inet_sock * newinet ; struct sock * newsk ; if ( sk_acceptq_is_full ( sk ) ) goto exit_overflow ; if ( dst == NULL && ( dst = inet_csk_route_req ( sk , req ) ) == NULL ) goto exit ; newsk = dccp_create_openreq_child ( sk , req , skb ) ; if ( newsk == NULL ) goto exit_nonewsk ; sk_setup_caps ( newsk , dst ) ; newinet = inet_sk ( newsk ) ; ireq = inet_rsk ( req ) ; newinet -> inet_daddr = ireq -> rmt_addr ; newinet -> inet_rcv_saddr = ireq -> loc_addr ; newinet -> inet_saddr = ireq -> loc_addr ; <S2SV_StartBug> newinet -> opt = ireq -> opt ; <S2SV_EndBug> ireq -> opt = NULL ; newinet -> mc_index = inet_iif ( skb ) ; newinet -> mc_ttl = ip_hdr ( skb ) -> ttl ; newinet -> inet_id = jiffies ; dccp_sync_mss ( newsk , dst_mtu ( dst ) ) ; if ( __inet_inherit_port ( sk , newsk ) < 0 ) { sock_put ( newsk ) ; goto exit ; } __inet_hash_nolisten ( newsk , NULL ) ; return newsk ; exit_overflow : NET_INC_STATS_BH ( sock_net ( sk ) , LINUX_MIB_LISTENOVERFLOWS ) ; exit_nonewsk : dst_release ( dst ) ; exit : NET_INC_STATS_BH ( sock_net ( sk ) , LINUX_MIB_LISTENDROPS ) ; return NULL ; }",; newinet -> inet_opt <S2SV_ModEnd> = ireq ->
630,"u_int fr_print ( netdissect_options * ndo , register const u_char * p , u_int length ) { int ret ; uint16_t extracted_ethertype ; u_int dlci ; u_int addr_len ; uint16_t nlpid ; u_int hdr_len ; uint8_t flags [ 4 ] ; ret = parse_q922_addr ( ndo , p , & dlci , & addr_len , flags , length ) ; if ( ret == - 1 ) goto trunc ; if ( ret == 0 ) { ND_PRINT ( ( ndo , ""Q.922,<S2SV_blank>invalid<S2SV_blank>address"" ) ) ; return 0 ; } ND_TCHECK ( p [ addr_len ] ) ; if ( length < addr_len + 1 ) goto trunc ; if ( p [ addr_len ] != LLC_UI && dlci != 0 ) { if ( ! ND_TTEST2 ( p [ addr_len ] , 2 ) || length < addr_len + 2 ) { ND_PRINT ( ( ndo , ""UI<S2SV_blank>%02x!<S2SV_blank>"" , p [ addr_len ] ) ) ; } else { extracted_ethertype = EXTRACT_16BITS ( p + addr_len ) ; if ( ndo -> ndo_eflag ) fr_hdr_print ( ndo , length , addr_len , dlci , flags , extracted_ethertype ) ; if ( ethertype_print ( ndo , extracted_ethertype , p + addr_len + ETHERTYPE_LEN , length - addr_len - ETHERTYPE_LEN , ndo -> ndo_snapend - p - addr_len - ETHERTYPE_LEN , NULL , NULL ) == 0 ) ND_PRINT ( ( ndo , ""UI<S2SV_blank>%02x!<S2SV_blank>"" , p [ addr_len ] ) ) ; else return addr_len + 2 ; } } ND_TCHECK ( p [ addr_len + 1 ] ) ; if ( length < addr_len + 2 ) goto trunc ; if ( p [ addr_len + 1 ] == 0 ) { if ( addr_len != 3 ) ND_PRINT ( ( ndo , ""Pad!<S2SV_blank>"" ) ) ; hdr_len = addr_len + 1 + 1 + 1 ; } else { if ( addr_len == 3 ) ND_PRINT ( ( ndo , ""No<S2SV_blank>pad!<S2SV_blank>"" ) ) ; hdr_len = addr_len + 1 + 1 ; } ND_TCHECK ( p [ hdr_len - 1 ] ) ; if ( length < hdr_len ) goto trunc ; nlpid = p [ hdr_len - 1 ] ; if ( ndo -> ndo_eflag ) fr_hdr_print ( ndo , length , addr_len , dlci , flags , nlpid ) ; p += hdr_len ; length -= hdr_len ; switch ( nlpid ) { case NLPID_IP : ip_print ( ndo , p , length ) ; break ; case NLPID_IP6 : ip6_print ( ndo , p , length ) ; break ; case NLPID_CLNP : case NLPID_ESIS : case NLPID_ISIS : <S2SV_StartBug> isoclns_print ( ndo , p - 1 , length + 1 , ndo -> ndo_snapend - p + 1 ) ; <S2SV_EndBug> break ; case NLPID_SNAP : if ( snap_print ( ndo , p , length , ndo -> ndo_snapend - p , NULL , NULL , 0 ) == 0 ) { if ( ! ndo -> ndo_eflag ) fr_hdr_print ( ndo , length + hdr_len , hdr_len , dlci , flags , nlpid ) ; if ( ! ndo -> ndo_suppress_default_print ) ND_DEFAULTPRINT ( p - hdr_len , length + hdr_len ) ; } break ; case NLPID_Q933 : q933_print ( ndo , p , length ) ; break ; case NLPID_MFR : frf15_print ( ndo , p , length ) ; break ; case NLPID_PPP : ppp_print ( ndo , p , length ) ; break ; default : if ( ! ndo -> ndo_eflag ) fr_hdr_print ( ndo , length + hdr_len , addr_len , dlci , flags , nlpid ) ; if ( ! ndo -> ndo_xflag ) ND_DEFAULTPRINT ( p , length ) ; } return hdr_len ; trunc : ND_PRINT ( ( ndo , ""[|fr]"" ) ) ; return 0 ; }","length + 1 ) ; break ; case NLPID_SNAP : if ( snap_print ( ndo , p , length <S2SV_ModStart> ndo_snapend - p <S2SV_ModEnd> , NULL ,"
631,"int luaopen_x509 ( lua_State * L ) { auxiliar_newclass ( L , ""openssl.x509"" , x509_funcs ) ; lua_newtable ( L ) ; luaL_setfuncs ( L , R , 0 ) ; openssl_register_xname ( L ) ; lua_setfield ( L , - 2 , ""name"" ) ; openssl_register_xattribute ( L ) ; lua_setfield ( L , - 2 , ""attribute"" ) ; openssl_register_xextension ( L ) ; lua_setfield ( L , - 2 , ""extension"" ) ; openssl_register_xstore ( L ) ; lua_setfield ( L , - 2 , ""store"" ) ; openssl_register_xalgor ( L ) ; lua_setfield ( L , - 2 , ""algor"" ) ; luaopen_x509_req ( L ) ; lua_setfield ( L , - 2 , ""req"" ) ; luaopen_x509_crl ( L ) ; lua_setfield ( L , - 2 , ""crl"" ) ; lua_pushliteral ( L , ""version"" ) ; lua_pushliteral ( L , MYVERSION ) ; lua_settable ( L , - 3 ) ; <S2SV_StartBug> return 1 ; <S2SV_EndBug> }","3 ) ; # if OPENSSL_VERSION_NUMBER > 0x10002000L lua_pushliteral ( L , ""check_flag"" ) ; lua_newtable ( L ) ; auxiliar_enumerate ( L , - 1 , check_flags_const ) ; lua_settable ( L , - 3 ) ; # endif"
632,"void perf_event_enable ( struct perf_event * event ) { <S2SV_StartBug> struct perf_event_context * ctx = event -> ctx ; <S2SV_EndBug> struct task_struct * task = ctx -> task ; if ( ! task ) { cpu_function_call ( event -> cpu , __perf_event_enable , event ) ; return ; } raw_spin_lock_irq ( & ctx -> lock ) ; if ( event -> state >= PERF_EVENT_STATE_INACTIVE ) goto out ; if ( event -> state == PERF_EVENT_STATE_ERROR ) event -> state = PERF_EVENT_STATE_OFF ; retry : if ( ! ctx -> is_active ) { __perf_event_mark_enabled ( event ) ; <S2SV_StartBug> goto out ; <S2SV_EndBug> } raw_spin_unlock_irq ( & ctx -> lock ) ; if ( ! task_function_call ( task , __perf_event_enable , event ) ) return ; raw_spin_lock_irq ( & ctx -> lock ) ; if ( ctx -> is_active && event -> state == PERF_EVENT_STATE_OFF ) { task = ctx -> task ; goto retry ; } out : raw_spin_unlock_irq ( & ctx -> lock ) ; }","perf_event_context * ctx ; ctx = perf_event_ctx_lock <S2SV_ModEnd> ( event ) <S2SV_ModStart> event ) ; _perf_event_enable ( event ) ; perf_event_ctx_unlock ( event , ctx <S2SV_ModEnd> ) ; }"
633,"static int <S2SV_StartBug> validate_event ( struct pmu_hw_events * hw_events , <S2SV_EndBug> struct perf_event * event ) { <S2SV_StartBug> struct arm_pmu * armpmu = to_arm_pmu ( event -> pmu ) ; <S2SV_EndBug> struct hw_perf_event fake_event = event -> hw ; struct pmu * leader_pmu = event -> group_leader -> pmu ; if ( is_software_event ( event ) ) return 1 ; <S2SV_StartBug> if ( event -> pmu != leader_pmu || event -> state < PERF_EVENT_STATE_OFF ) <S2SV_EndBug> return 1 ; if ( event -> state == PERF_EVENT_STATE_OFF && ! event -> attr . enable_on_exec ) return 1 ; <S2SV_StartBug> return armpmu -> get_event_idx ( hw_events , & fake_event ) >= 0 ; <S2SV_EndBug> }","int validate_event ( struct pmu * pmu , <S2SV_ModStart> arm_pmu * armpmu <S2SV_ModEnd> ; struct hw_perf_event <S2SV_ModStart> -> pmu != pmu ) return 0 ; if ( event -> pmu != <S2SV_ModStart> return 1 ; armpmu = to_arm_pmu ( event -> pmu ) ;"
634,"static BOOL GetStartupData ( HANDLE pipe , STARTUP_DATA * sud ) { size_t size , len ; <S2SV_StartBug> BOOL ret = FALSE ; <S2SV_EndBug> WCHAR * data = NULL ; DWORD bytes , read ; bytes = PeekNamedPipeAsync ( pipe , 1 , & exit_event ) ; if ( bytes == 0 ) { MsgToEventLog ( M_SYSERR , TEXT ( ""PeekNamedPipeAsync<S2SV_blank>failed"" ) ) ; ReturnLastError ( pipe , L""PeekNamedPipeAsync"" ) ; <S2SV_StartBug> goto out ; <S2SV_EndBug> } size = bytes / sizeof ( * data ) ; if ( size == 0 ) { MsgToEventLog ( M_SYSERR , TEXT ( ""malformed<S2SV_blank>startup<S2SV_blank>data:<S2SV_blank>1<S2SV_blank>byte<S2SV_blank>received"" ) ) ; ReturnError ( pipe , ERROR_STARTUP_DATA , L""GetStartupData"" , 1 , & exit_event ) ; <S2SV_StartBug> goto out ; <S2SV_EndBug> } data = malloc ( bytes ) ; if ( data == NULL ) { MsgToEventLog ( M_SYSERR , TEXT ( ""malloc<S2SV_blank>failed"" ) ) ; ReturnLastError ( pipe , L""malloc"" ) ; <S2SV_StartBug> goto out ; <S2SV_EndBug> } read = ReadPipeAsync ( pipe , data , bytes , 1 , & exit_event ) ; if ( bytes != read ) { MsgToEventLog ( M_SYSERR , TEXT ( ""ReadPipeAsync<S2SV_blank>failed"" ) ) ; ReturnLastError ( pipe , L""ReadPipeAsync"" ) ; <S2SV_StartBug> goto out ; <S2SV_EndBug> } if ( data [ size - 1 ] != 0 ) { MsgToEventLog ( M_ERR , TEXT ( ""Startup<S2SV_blank>data<S2SV_blank>is<S2SV_blank>not<S2SV_blank>NULL<S2SV_blank>terminated"" ) ) ; ReturnError ( pipe , ERROR_STARTUP_DATA , L""GetStartupData"" , 1 , & exit_event ) ; <S2SV_StartBug> goto out ; <S2SV_EndBug> } sud -> directory = data ; len = wcslen ( sud -> directory ) + 1 ; size -= len ; if ( size <= 0 ) { MsgToEventLog ( M_ERR , TEXT ( ""Startup<S2SV_blank>data<S2SV_blank>ends<S2SV_blank>at<S2SV_blank>working<S2SV_blank>directory"" ) ) ; ReturnError ( pipe , ERROR_STARTUP_DATA , L""GetStartupData"" , 1 , & exit_event ) ; <S2SV_StartBug> goto out ; <S2SV_EndBug> } sud -> options = sud -> directory + len ; len = wcslen ( sud -> options ) + 1 ; size -= len ; if ( size <= 0 ) { MsgToEventLog ( M_ERR , TEXT ( ""Startup<S2SV_blank>data<S2SV_blank>ends<S2SV_blank>at<S2SV_blank>command<S2SV_blank>line<S2SV_blank>options"" ) ) ; ReturnError ( pipe , ERROR_STARTUP_DATA , L""GetStartupData"" , 1 , & exit_event ) ; <S2SV_StartBug> goto out ; <S2SV_EndBug> } sud -> std_input = sud -> options + len ; <S2SV_StartBug> data = NULL ; <S2SV_EndBug> <S2SV_StartBug> ret = TRUE ; <S2SV_EndBug> out : free ( data ) ; <S2SV_StartBug> return ret ; <S2SV_EndBug> }",", len ; <S2SV_ModEnd> WCHAR * data <S2SV_ModStart> ) ; goto err <S2SV_ModEnd> ; } size <S2SV_ModStart> ) ; goto err <S2SV_ModEnd> ; } data <S2SV_ModStart> ) ; goto err <S2SV_ModEnd> ; } read <S2SV_ModStart> ) ; goto err <S2SV_ModEnd> ; } if <S2SV_ModStart> ) ; goto err <S2SV_ModEnd> ; } sud <S2SV_ModStart> ) ; goto err <S2SV_ModEnd> ; } sud <S2SV_ModStart> ) ; goto err <S2SV_ModEnd> ; } sud <S2SV_ModStart> + len ; return TRUE ; err : sud -> directory <S2SV_ModEnd> = NULL ; <S2SV_ModStart> = NULL ; <S2SV_ModEnd> free ( data <S2SV_ModStart> ) ; return FALSE <S2SV_ModEnd> ; } <S2SV_null>"
635,"static int adjust_ptr_min_max_vals ( struct bpf_verifier_env * env , struct bpf_insn * insn , const struct bpf_reg_state * ptr_reg , const struct bpf_reg_state * off_reg ) { struct bpf_verifier_state * vstate = env -> cur_state ; struct bpf_func_state * state = vstate -> frame [ vstate -> curframe ] ; struct bpf_reg_state * regs = state -> regs , * dst_reg ; bool known = tnum_is_const ( off_reg -> var_off ) ; s64 smin_val = off_reg -> smin_value , smax_val = off_reg -> smax_value , smin_ptr = ptr_reg -> smin_value , smax_ptr = ptr_reg -> smax_value ; u64 umin_val = off_reg -> umin_value , umax_val = off_reg -> umax_value , umin_ptr = ptr_reg -> umin_value , umax_ptr = ptr_reg -> umax_value ; u32 dst = insn -> dst_reg , src = insn -> src_reg ; <S2SV_StartBug> u8 opcode = BPF_OP ( insn -> code ) ; <S2SV_EndBug> dst_reg = & regs [ dst ] ; if ( ( known && ( smin_val != smax_val || umin_val != umax_val ) ) || smin_val > smax_val || umin_val > umax_val ) { __mark_reg_unknown ( dst_reg ) ; return 0 ; } if ( BPF_CLASS ( insn -> code ) != BPF_ALU64 ) { verbose ( env , ""R%d<S2SV_blank>32-bit<S2SV_blank>pointer<S2SV_blank>arithmetic<S2SV_blank>prohibited\\n"" , dst ) ; return - EACCES ; } switch ( ptr_reg -> type ) { case PTR_TO_MAP_VALUE_OR_NULL : verbose ( env , ""R%d<S2SV_blank>pointer<S2SV_blank>arithmetic<S2SV_blank>on<S2SV_blank>%s<S2SV_blank>prohibited,<S2SV_blank>null-check<S2SV_blank>it<S2SV_blank>first\\n"" , dst , reg_type_str [ ptr_reg -> type ] ) ; return - EACCES ; case CONST_PTR_TO_MAP : case PTR_TO_PACKET_END : case PTR_TO_SOCKET : case PTR_TO_SOCKET_OR_NULL : verbose ( env , ""R%d<S2SV_blank>pointer<S2SV_blank>arithmetic<S2SV_blank>on<S2SV_blank>%s<S2SV_blank>prohibited\\n"" , dst , reg_type_str [ ptr_reg -> type ] ) ; return - EACCES ; case PTR_TO_MAP_VALUE : if ( ! env -> allow_ptr_leaks && ! known && ( smin_val < 0 ) != ( smax_val < 0 ) ) { verbose ( env , ""R%d<S2SV_blank>has<S2SV_blank>unknown<S2SV_blank>scalar<S2SV_blank>with<S2SV_blank>mixed<S2SV_blank>signed<S2SV_blank>bounds,<S2SV_blank>pointer<S2SV_blank>arithmetic<S2SV_blank>with<S2SV_blank>it<S2SV_blank>prohibited<S2SV_blank>for<S2SV_blank>!root\\n"" , off_reg == dst_reg ? dst : src ) ; return - EACCES ; } default : break ; } dst_reg -> type = ptr_reg -> type ; dst_reg -> id = ptr_reg -> id ; if ( ! check_reg_sane_offset ( env , off_reg , ptr_reg -> type ) || ! check_reg_sane_offset ( env , ptr_reg , ptr_reg -> type ) ) return - EINVAL ; switch ( opcode ) { case BPF_ADD : <S2SV_StartBug> if ( known && ( ptr_reg -> off + smin_val == <S2SV_EndBug> ( s64 ) ( s32 ) ( ptr_reg -> off + smin_val ) ) ) { dst_reg -> smin_value = smin_ptr ; dst_reg -> smax_value = smax_ptr ; dst_reg -> umin_value = umin_ptr ; dst_reg -> umax_value = umax_ptr ; dst_reg -> var_off = ptr_reg -> var_off ; dst_reg -> off = ptr_reg -> off + smin_val ; dst_reg -> raw = ptr_reg -> raw ; break ; } if ( signed_add_overflows ( smin_ptr , smin_val ) || signed_add_overflows ( smax_ptr , smax_val ) ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = smin_ptr + smin_val ; dst_reg -> smax_value = smax_ptr + smax_val ; } if ( umin_ptr + umin_val < umin_ptr || umax_ptr + umax_val < umax_ptr ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value = umin_ptr + umin_val ; dst_reg -> umax_value = umax_ptr + umax_val ; } dst_reg -> var_off = tnum_add ( ptr_reg -> var_off , off_reg -> var_off ) ; dst_reg -> off = ptr_reg -> off ; dst_reg -> raw = ptr_reg -> raw ; if ( reg_is_pkt_pointer ( ptr_reg ) ) { dst_reg -> id = ++ env -> id_gen ; dst_reg -> raw = 0 ; } break ; case BPF_SUB : <S2SV_StartBug> if ( dst_reg == off_reg ) { <S2SV_EndBug> verbose ( env , ""R%d<S2SV_blank>tried<S2SV_blank>to<S2SV_blank>subtract<S2SV_blank>pointer<S2SV_blank>from<S2SV_blank>scalar\\n"" , dst ) ; return - EACCES ; } if ( ptr_reg -> type == PTR_TO_STACK ) { verbose ( env , ""R%d<S2SV_blank>subtraction<S2SV_blank>from<S2SV_blank>stack<S2SV_blank>pointer<S2SV_blank>prohibited\\n"" , dst ) ; return - EACCES ; } if ( known && ( ptr_reg -> off - smin_val == ( s64 ) ( s32 ) ( ptr_reg -> off - smin_val ) ) ) { dst_reg -> smin_value = smin_ptr ; dst_reg -> smax_value = smax_ptr ; dst_reg -> umin_value = umin_ptr ; dst_reg -> umax_value = umax_ptr ; dst_reg -> var_off = ptr_reg -> var_off ; dst_reg -> id = ptr_reg -> id ; dst_reg -> off = ptr_reg -> off - smin_val ; dst_reg -> raw = ptr_reg -> raw ; break ; } if ( signed_sub_overflows ( smin_ptr , smax_val ) || signed_sub_overflows ( smax_ptr , smin_val ) ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = smin_ptr - smax_val ; dst_reg -> smax_value = smax_ptr - smin_val ; } if ( umin_ptr < umax_val ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value = umin_ptr - umax_val ; dst_reg -> umax_value = umax_ptr - umin_val ; } dst_reg -> var_off = tnum_sub ( ptr_reg -> var_off , off_reg -> var_off ) ; dst_reg -> off = ptr_reg -> off ; dst_reg -> raw = ptr_reg -> raw ; if ( reg_is_pkt_pointer ( ptr_reg ) ) { dst_reg -> id = ++ env -> id_gen ; if ( smin_val < 0 ) dst_reg -> raw = 0 ; } break ; case BPF_AND : case BPF_OR : case BPF_XOR : verbose ( env , ""R%d<S2SV_blank>bitwise<S2SV_blank>operator<S2SV_blank>%s<S2SV_blank>on<S2SV_blank>pointer<S2SV_blank>prohibited\\n"" , dst , bpf_alu_string [ opcode >> 4 ] ) ; return - EACCES ; default : verbose ( env , ""R%d<S2SV_blank>pointer<S2SV_blank>arithmetic<S2SV_blank>with<S2SV_blank>%s<S2SV_blank>operator<S2SV_blank>prohibited\\n"" , dst , bpf_alu_string [ opcode >> 4 ] ) ; return - EACCES ; } if ( ! check_reg_sane_offset ( env , dst_reg , ptr_reg -> type ) ) return - EINVAL ; __update_reg_bounds ( dst_reg ) ; __reg_deduce_bounds ( dst_reg ) ; __reg_bound_offset ( dst_reg ) ; if ( ! env -> allow_ptr_leaks ) { if ( dst_reg -> type == PTR_TO_MAP_VALUE && check_map_access ( env , dst , dst_reg -> off , 1 , false ) ) { verbose ( env , ""R%d<S2SV_blank>pointer<S2SV_blank>arithmetic<S2SV_blank>of<S2SV_blank>map<S2SV_blank>value<S2SV_blank>goes<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range,<S2SV_blank>"" ""prohibited<S2SV_blank>for<S2SV_blank>!root\\n"" , dst ) ; return - EACCES ; } else if ( dst_reg -> type == PTR_TO_STACK && check_stack_access ( env , dst_reg , dst_reg -> off + dst_reg -> var_off . value , 1 ) ) { verbose ( env , ""R%d<S2SV_blank>stack<S2SV_blank>pointer<S2SV_blank>arithmetic<S2SV_blank>goes<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range,<S2SV_blank>"" ""prohibited<S2SV_blank>for<S2SV_blank>!root\\n"" , dst ) ; return - EACCES ; } } return 0 ; }","-> code ) ; int ret <S2SV_ModStart> case BPF_ADD : ret = sanitize_ptr_alu ( env , insn , ptr_reg , dst_reg , smin_val < 0 ) ; if ( ret < 0 ) { verbose ( env , ""R%d<S2SV_blank>tried<S2SV_blank>to<S2SV_blank>add<S2SV_blank>from<S2SV_blank>different<S2SV_blank>maps<S2SV_blank>or<S2SV_blank>paths\\n"" , dst ) ; return ret ; } <S2SV_ModStart> case BPF_SUB : ret = sanitize_ptr_alu ( env , insn , ptr_reg , dst_reg , smin_val < 0 ) ; if ( ret < 0 ) { verbose ( env , ""R%d<S2SV_blank>tried<S2SV_blank>to<S2SV_blank>sub<S2SV_blank>from<S2SV_blank>different<S2SV_blank>maps<S2SV_blank>or<S2SV_blank>paths\\n"" , dst ) ; return ret ; }"
636,"static int ext4_xattr_block_set ( handle_t * handle , struct inode * inode , struct ext4_xattr_info * i , struct ext4_xattr_block_find * bs ) { struct super_block * sb = inode -> i_sb ; struct buffer_head * new_bh = NULL ; struct ext4_xattr_search * s = & bs -> s ; <S2SV_StartBug> struct mb_cache_entry * ce = NULL ; <S2SV_EndBug> int error = 0 ; <S2SV_StartBug> struct mb_cache * ext4_mb_cache = EXT4_GET_MB_CACHE ( inode ) ; <S2SV_EndBug> # define header ( x ) ( ( struct ext4_xattr_header * ) ( x ) ) if ( i -> value && i -> value_len > sb -> s_blocksize ) return - ENOSPC ; if ( s -> base ) { <S2SV_StartBug> ce = mb_cache_entry_get ( ext4_mb_cache , bs -> bh -> b_bdev , <S2SV_EndBug> bs -> bh -> b_blocknr ) ; BUFFER_TRACE ( bs -> bh , ""get_write_access"" ) ; error = ext4_journal_get_write_access ( handle , bs -> bh ) ; if ( error ) goto cleanup ; lock_buffer ( bs -> bh ) ; if ( header ( s -> base ) -> h_refcount == cpu_to_le32 ( 1 ) ) { <S2SV_StartBug> if ( ce ) { <S2SV_EndBug> mb_cache_entry_free ( ce ) ; ce = NULL ; } ea_bdebug ( bs -> bh , ""modifying<S2SV_blank>in-place"" ) ; error = ext4_xattr_set_entry ( i , s ) ; if ( ! error ) { if ( ! IS_LAST_ENTRY ( s -> first ) ) ext4_xattr_rehash ( header ( s -> base ) , s -> here ) ; ext4_xattr_cache_insert ( ext4_mb_cache , bs -> bh ) ; } unlock_buffer ( bs -> bh ) ; if ( error == - EFSCORRUPTED ) goto bad_block ; if ( ! error ) error = ext4_handle_dirty_xattr_block ( handle , inode , bs -> bh ) ; if ( error ) goto cleanup ; goto inserted ; } else { int offset = ( char * ) s -> here - bs -> bh -> b_data ; unlock_buffer ( bs -> bh ) ; <S2SV_StartBug> if ( ce ) { <S2SV_EndBug> mb_cache_entry_release ( ce ) ; ce = NULL ; } ea_bdebug ( bs -> bh , ""cloning"" ) ; s -> base = kmalloc ( bs -> bh -> b_size , GFP_NOFS ) ; error = - ENOMEM ; if ( s -> base == NULL ) goto cleanup ; memcpy ( s -> base , BHDR ( bs -> bh ) , bs -> bh -> b_size ) ; s -> first = ENTRY ( header ( s -> base ) + 1 ) ; header ( s -> base ) -> h_refcount = cpu_to_le32 ( 1 ) ; s -> here = ENTRY ( s -> base + offset ) ; s -> end = s -> base + bs -> bh -> b_size ; } } else { s -> base = kzalloc ( sb -> s_blocksize , GFP_NOFS ) ; error = - ENOMEM ; if ( s -> base == NULL ) goto cleanup ; header ( s -> base ) -> h_magic = cpu_to_le32 ( EXT4_XATTR_MAGIC ) ; header ( s -> base ) -> h_blocks = cpu_to_le32 ( 1 ) ; header ( s -> base ) -> h_refcount = cpu_to_le32 ( 1 ) ; s -> first = ENTRY ( header ( s -> base ) + 1 ) ; s -> here = ENTRY ( header ( s -> base ) + 1 ) ; s -> end = s -> base + sb -> s_blocksize ; } error = ext4_xattr_set_entry ( i , s ) ; if ( error == - EFSCORRUPTED ) goto bad_block ; if ( error ) goto cleanup ; if ( ! IS_LAST_ENTRY ( s -> first ) ) ext4_xattr_rehash ( header ( s -> base ) , s -> here ) ; inserted : if ( ! IS_LAST_ENTRY ( s -> first ) ) { new_bh = ext4_xattr_cache_find ( inode , header ( s -> base ) , & ce ) ; if ( new_bh ) { if ( new_bh == bs -> bh ) ea_bdebug ( new_bh , ""keeping"" ) ; else { error = dquot_alloc_block ( inode , EXT4_C2B ( EXT4_SB ( sb ) , 1 ) ) ; if ( error ) goto cleanup ; BUFFER_TRACE ( new_bh , ""get_write_access"" ) ; error = ext4_journal_get_write_access ( handle , new_bh ) ; if ( error ) goto cleanup_dquot ; lock_buffer ( new_bh ) ; <S2SV_StartBug> le32_add_cpu ( & BHDR ( new_bh ) -> h_refcount , 1 ) ; <S2SV_EndBug> ea_bdebug ( new_bh , ""reusing;<S2SV_blank>refcount<S2SV_blank>now=%d"" , le32_to_cpu ( BHDR ( new_bh ) -> h_refcount ) ) ; unlock_buffer ( new_bh ) ; error = ext4_handle_dirty_xattr_block ( handle , inode , new_bh ) ; if ( error ) goto cleanup_dquot ; } <S2SV_StartBug> mb_cache_entry_release ( ce ) ; <S2SV_EndBug> ce = NULL ; } else if ( bs -> bh && s -> base == bs -> bh -> b_data ) { ea_bdebug ( bs -> bh , ""keeping<S2SV_blank>this<S2SV_blank>block"" ) ; new_bh = bs -> bh ; get_bh ( new_bh ) ; } else { ext4_fsblk_t goal , block ; goal = ext4_group_first_block_no ( sb , EXT4_I ( inode ) -> i_block_group ) ; if ( ! ( ext4_test_inode_flag ( inode , EXT4_INODE_EXTENTS ) ) ) goal = goal & EXT4_MAX_BLOCK_FILE_PHYS ; block = ext4_new_meta_blocks ( handle , inode , goal , 0 , NULL , & error ) ; if ( error ) goto cleanup ; if ( ! ( ext4_test_inode_flag ( inode , EXT4_INODE_EXTENTS ) ) ) BUG_ON ( block > EXT4_MAX_BLOCK_FILE_PHYS ) ; ea_idebug ( inode , ""creating<S2SV_blank>block<S2SV_blank>%llu"" , ( unsigned long long ) block ) ; new_bh = sb_getblk ( sb , block ) ; if ( unlikely ( ! new_bh ) ) { error = - ENOMEM ; getblk_failed : ext4_free_blocks ( handle , inode , NULL , block , 1 , EXT4_FREE_BLOCKS_METADATA ) ; goto cleanup ; } lock_buffer ( new_bh ) ; error = ext4_journal_get_create_access ( handle , new_bh ) ; if ( error ) { unlock_buffer ( new_bh ) ; error = - EIO ; goto getblk_failed ; } memcpy ( new_bh -> b_data , s -> base , new_bh -> b_size ) ; set_buffer_uptodate ( new_bh ) ; unlock_buffer ( new_bh ) ; ext4_xattr_cache_insert ( ext4_mb_cache , new_bh ) ; error = ext4_handle_dirty_xattr_block ( handle , inode , new_bh ) ; if ( error ) goto cleanup ; } } EXT4_I ( inode ) -> i_file_acl = new_bh ? new_bh -> b_blocknr : 0 ; if ( bs -> bh && bs -> bh != new_bh ) ext4_xattr_release_block ( handle , inode , bs -> bh ) ; error = 0 ; cleanup : if ( ce ) <S2SV_StartBug> mb_cache_entry_release ( ce ) ; <S2SV_EndBug> brelse ( new_bh ) ; if ( ! ( bs -> bh && s -> base == bs -> bh -> b_data ) ) kfree ( s -> base ) ; return error ; cleanup_dquot : dquot_free_block ( inode , EXT4_C2B ( EXT4_SB ( sb ) , 1 ) ) ; goto cleanup ; bad_block : EXT4_ERROR_INODE ( inode , ""bad<S2SV_blank>block<S2SV_blank>%llu"" , EXT4_I ( inode ) -> i_file_acl ) ; goto cleanup ; # undef header }","s ; struct mb2_cache_entry <S2SV_ModEnd> * ce = <S2SV_ModStart> 0 ; struct mb2_cache <S2SV_ModEnd> * ext4_mb_cache = <S2SV_ModStart> base ) { <S2SV_ModEnd> BUFFER_TRACE ( bs <S2SV_ModStart> ) ) { __u32 hash = le32_to_cpu ( BHDR ( bs -> bh ) -> h_hash ) ; mb2_cache_entry_delete_block ( ext4_mb_cache , hash , bs -> bh -> b_blocknr ) ; <S2SV_ModEnd> ea_bdebug ( bs <S2SV_ModStart> bh ) ; <S2SV_ModEnd> ea_bdebug ( bs <S2SV_ModStart> new_bh ) ; if ( hlist_bl_unhashed ( & ce -> e_hash_list ) ) { unlock_buffer ( new_bh ) ; dquot_free_block ( inode , EXT4_C2B ( EXT4_SB ( sb ) , 1 ) ) ; brelse ( new_bh ) ; mb2_cache_entry_put ( ext4_mb_cache , ce ) ; ce = NULL ; new_bh = NULL ; goto inserted ; } <S2SV_ModStart> cleanup_dquot ; } mb2_cache_entry_touch ( ext4_mb_cache , ce ) ; mb2_cache_entry_put ( ext4_mb_cache , <S2SV_ModEnd> ce ) ; <S2SV_ModStart> ( ce ) mb2_cache_entry_put ( ext4_mb_cache , <S2SV_ModEnd> ce ) ;"
637,"void vp9_iht4x4_16_add_sse2 ( const int16_t * input , uint8_t * dest , int stride , int tx_type ) { __m128i in [ 2 ] ; const __m128i zero = _mm_setzero_si128 ( ) ; const __m128i eight = _mm_set1_epi16 ( 8 ) ; in [ 0 ] = _mm_loadu_si128 ( ( const __m128i * ) ( input ) ) ; in [ 1 ] = _mm_loadu_si128 ( ( const __m128i * ) ( input + 8 ) ) ; switch ( tx_type ) { case 0 : idct4_sse2 ( in ) ; idct4_sse2 ( in ) ; break ; case 1 : idct4_sse2 ( in ) ; iadst4_sse2 ( in ) ; break ; case 2 : iadst4_sse2 ( in ) ; idct4_sse2 ( in ) ; break ; case 3 : iadst4_sse2 ( in ) ; iadst4_sse2 ( in ) ; break ; default : assert ( 0 ) ; break ; } in [ 0 ] = _mm_add_epi16 ( in [ 0 ] , eight ) ; in [ 1 ] = _mm_add_epi16 ( in [ 1 ] , eight ) ; in [ 0 ] = _mm_srai_epi16 ( in [ 0 ] , 4 ) ; in [ 1 ] = _mm_srai_epi16 ( in [ 1 ] , 4 ) ; { __m128i d0 = _mm_cvtsi32_si128 ( * ( const int * ) ( dest ) ) ; __m128i d2 = _mm_cvtsi32_si128 ( * ( const int * ) ( dest + stride * 2 ) ) ; d0 = _mm_unpacklo_epi32 ( d0 , _mm_cvtsi32_si128 ( * ( const int * ) ( dest + stride ) ) ) ; d2 = _mm_unpacklo_epi32 ( d2 , _mm_cvtsi32_si128 ( * ( const int * ) ( dest + stride * 3 ) ) ) ; d0 = _mm_unpacklo_epi8 ( d0 , zero ) ; d2 = _mm_unpacklo_epi8 ( d2 , zero ) ; d0 = _mm_add_epi16 ( d0 , in [ 0 ] ) ; d2 = _mm_add_epi16 ( d2 , in [ 1 ] ) ; d0 = _mm_packus_epi16 ( d0 , d2 ) ; * ( int * ) dest = _mm_cvtsi128_si32 ( d0 ) ; d0 = _mm_srli_si128 ( d0 , 4 ) ; * ( int * ) ( dest + stride ) = _mm_cvtsi128_si32 ( d0 ) ; d0 = _mm_srli_si128 ( d0 , 4 ) ; * ( int * ) ( dest + stride * 2 ) = _mm_cvtsi128_si32 ( d0 ) ; d0 = _mm_srli_si128 ( d0 , 4 ) ; * ( int * ) ( dest + stride * 3 ) = _mm_cvtsi128_si32 ( d0 ) ; } }","
"
638,"static int myrecvfrom6 ( int sockfd , void * buf , size_t * buflen , int flags , <S2SV_StartBug> struct in6_addr * addr , uint32_t * ifindex ) <S2SV_EndBug> { struct sockaddr_in6 sin6 ; <S2SV_StartBug> unsigned char cbuf [ CMSG_SPACE ( sizeof ( struct in6_pktinfo ) ) ] ; <S2SV_EndBug> struct iovec iovec ; struct msghdr msghdr ; struct cmsghdr * cmsghdr ; ssize_t len ; iovec . iov_len = * buflen ; iovec . iov_base = buf ; memset ( & msghdr , 0 , sizeof ( msghdr ) ) ; msghdr . msg_name = & sin6 ; msghdr . msg_namelen = sizeof ( sin6 ) ; msghdr . msg_iov = & iovec ; msghdr . msg_iovlen = 1 ; msghdr . msg_control = cbuf ; msghdr . msg_controllen = sizeof ( cbuf ) ; len = recvmsg ( sockfd , & msghdr , flags ) ; if ( len == - 1 ) return - errno ; * buflen = len ; * ifindex = sin6 . sin6_scope_id ; for ( cmsghdr = CMSG_FIRSTHDR ( & msghdr ) ; cmsghdr ; cmsghdr = CMSG_NXTHDR ( & msghdr , cmsghdr ) ) { <S2SV_StartBug> if ( cmsghdr -> cmsg_level == IPPROTO_IPV6 && <S2SV_EndBug> <S2SV_StartBug> cmsghdr -> cmsg_type == IPV6_PKTINFO && <S2SV_EndBug> cmsghdr -> cmsg_len == CMSG_LEN ( sizeof ( struct in6_pktinfo ) ) ) { struct in6_pktinfo * pktinfo ; pktinfo = ( struct in6_pktinfo * ) CMSG_DATA ( cmsghdr ) ; * ifindex = pktinfo -> ipi6_ifindex ; } <S2SV_StartBug> } <S2SV_EndBug> * addr = sin6 . sin6_addr ; return 0 ; }","uint32_t * ifindex , int * hoplimit <S2SV_ModStart> char cbuf [ 2 * <S2SV_ModStart> cmsghdr -> cmsg_level != IPPROTO_IPV6 ) continue ; switch ( <S2SV_ModEnd> cmsghdr -> cmsg_type <S2SV_ModStart> cmsghdr -> cmsg_type ) { case IPV6_PKTINFO : if ( <S2SV_ModEnd> cmsghdr -> cmsg_len <S2SV_ModStart> ipi6_ifindex ; } break ; case IPV6_HOPLIMIT : if ( cmsghdr -> cmsg_len == CMSG_LEN ( sizeof ( int ) ) ) { int * val ; val = ( int * ) CMSG_DATA ( cmsghdr ) ; * hoplimit = * val ; } break ; }"
639,"int touch_file ( const char * path , bool parents , usec_t stamp , uid_t uid , gid_t gid , mode_t mode ) { _cleanup_close_ int fd ; int r ; assert ( path ) ; if ( parents ) mkdir_parents ( path , 0755 ) ; fd = open ( path , O_WRONLY | O_CREAT | O_CLOEXEC | O_NOCTTY , mode > 0 ? mode : 0644 ) ; if ( fd < 0 ) return - errno ; <S2SV_StartBug> if ( mode > 0 ) { <S2SV_EndBug> r = fchmod ( fd , mode ) ; if ( r < 0 ) return - errno ; } if ( uid != UID_INVALID || gid != GID_INVALID ) { r = fchown ( fd , uid , gid ) ; if ( r < 0 ) return - errno ; } if ( stamp != USEC_INFINITY ) { struct timespec ts [ 2 ] ; timespec_store ( & ts [ 0 ] , stamp ) ; ts [ 1 ] = ts [ 0 ] ; r = futimens ( fd , ts ) ; } else r = futimens ( fd , NULL ) ; if ( r < 0 ) return - errno ; return 0 ; }",if ( mode != MODE_INVALID <S2SV_ModEnd> ) { r
640,"static long ext4_zero_range ( struct file * file , loff_t offset , loff_t len , int mode ) { struct inode * inode = file_inode ( file ) ; handle_t * handle = NULL ; unsigned int max_blocks ; loff_t new_size = 0 ; int ret = 0 ; int flags ; int credits ; int partial_begin , partial_end ; loff_t start , end ; ext4_lblk_t lblk ; <S2SV_StartBug> struct address_space * mapping = inode -> i_mapping ; <S2SV_EndBug> unsigned int blkbits = inode -> i_blkbits ; trace_ext4_zero_range ( inode , offset , len , mode ) ; if ( ! S_ISREG ( inode -> i_mode ) ) return - EINVAL ; if ( ext4_should_journal_data ( inode ) ) { ret = ext4_force_commit ( inode -> i_sb ) ; if ( ret ) return ret ; } <S2SV_StartBug> if ( mapping -> nrpages && mapping_tagged ( mapping , PAGECACHE_TAG_DIRTY ) ) { <S2SV_EndBug> ret = filemap_write_and_wait_range ( mapping , offset , offset + len - 1 ) ; if ( ret ) return ret ; } start = round_up ( offset , 1 << blkbits ) ; end = round_down ( ( offset + len ) , 1 << blkbits ) ; if ( start < offset || end > offset + len ) return - EINVAL ; partial_begin = offset & ( ( 1 << blkbits ) - 1 ) ; partial_end = ( offset + len ) & ( ( 1 << blkbits ) - 1 ) ; lblk = start >> blkbits ; max_blocks = ( end >> blkbits ) ; if ( max_blocks < lblk ) max_blocks = 0 ; else max_blocks -= lblk ; mutex_lock ( & inode -> i_mutex ) ; if ( ! ( ext4_test_inode_flag ( inode , EXT4_INODE_EXTENTS ) ) ) { ret = - EOPNOTSUPP ; goto out_mutex ; } if ( ! ( mode & FALLOC_FL_KEEP_SIZE ) && offset + len > i_size_read ( inode ) ) { new_size = offset + len ; ret = inode_newsize_ok ( inode , new_size ) ; if ( ret ) goto out_mutex ; } flags = EXT4_GET_BLOCKS_CREATE_UNWRIT_EXT ; if ( mode & FALLOC_FL_KEEP_SIZE ) flags |= EXT4_GET_BLOCKS_KEEP_SIZE ; if ( partial_begin || partial_end ) { ret = ext4_alloc_file_blocks ( file , round_down ( offset , 1 << blkbits ) >> blkbits , ( round_up ( ( offset + len ) , 1 << blkbits ) - round_down ( offset , 1 << blkbits ) ) >> blkbits , new_size , flags , mode ) ; if ( ret ) goto out_mutex ; } if ( max_blocks > 0 ) { flags |= ( EXT4_GET_BLOCKS_CONVERT_UNWRITTEN | EXT4_EX_NOCACHE ) ; <S2SV_StartBug> truncate_pagecache_range ( inode , start , end - 1 ) ; <S2SV_EndBug> inode -> i_mtime = inode -> i_ctime = ext4_current_time ( inode ) ; <S2SV_StartBug> ext4_inode_block_unlocked_dio ( inode ) ; <S2SV_EndBug> inode_dio_wait ( inode ) ; ret = ext4_alloc_file_blocks ( file , lblk , max_blocks , new_size , <S2SV_StartBug> flags , mode ) ; <S2SV_EndBug> if ( ret ) goto out_dio ; } if ( ! partial_begin && ! partial_end ) goto out_dio ; credits = ( 2 * ext4_ext_index_trans_blocks ( inode , 2 ) ) + 1 ; if ( ext4_should_journal_data ( inode ) ) credits += 2 ; handle = ext4_journal_start ( inode , EXT4_HT_MISC , credits ) ; if ( IS_ERR ( handle ) ) { ret = PTR_ERR ( handle ) ; ext4_std_error ( inode -> i_sb , ret ) ; goto out_dio ; } inode -> i_mtime = inode -> i_ctime = ext4_current_time ( inode ) ; if ( new_size ) { ext4_update_inode_size ( inode , new_size ) ; } else { if ( ( offset + len ) > i_size_read ( inode ) ) ext4_set_inode_flag ( inode , EXT4_INODE_EOFBLOCKS ) ; } ext4_mark_inode_dirty ( handle , inode ) ; ret = ext4_zero_partial_blocks ( handle , inode , offset , len ) ; if ( file -> f_flags & O_SYNC ) ext4_handle_sync ( handle ) ; ext4_journal_stop ( handle ) ; out_dio : ext4_inode_resume_unlocked_dio ( inode ) ; out_mutex : mutex_unlock ( & inode -> i_mutex ) ; return ret ; }","ext4_lblk_t lblk ; <S2SV_ModEnd> unsigned int blkbits <S2SV_ModStart> ret ; } <S2SV_ModEnd> start = round_up <S2SV_ModStart> EXT4_EX_NOCACHE ) ; ext4_inode_block_unlocked_dio ( inode ) ; inode_dio_wait ( inode ) ; down_write ( & EXT4_I ( inode ) -> i_mmap_sem ) ; <S2SV_ModStart> inode ) ; <S2SV_ModEnd> ret = ext4_alloc_file_blocks <S2SV_ModStart> flags , mode ) ; up_write ( & EXT4_I ( inode ) -> i_mmap_sem"
641,"static void tg3_read_vpd ( struct tg3 * tp ) { u8 * vpd_data ; unsigned int block_end , rosize , len ; u32 vpdlen ; int j , i = 0 ; vpd_data = ( u8 * ) tg3_vpd_readblock ( tp , & vpdlen ) ; if ( ! vpd_data ) goto out_no_vpd ; i = pci_vpd_find_tag ( vpd_data , 0 , vpdlen , PCI_VPD_LRDT_RO_DATA ) ; if ( i < 0 ) goto out_not_found ; rosize = pci_vpd_lrdt_size ( & vpd_data [ i ] ) ; block_end = i + PCI_VPD_LRDT_TAG_SIZE + rosize ; i += PCI_VPD_LRDT_TAG_SIZE ; if ( block_end > vpdlen ) goto out_not_found ; j = pci_vpd_find_info_keyword ( vpd_data , i , rosize , PCI_VPD_RO_KEYWORD_MFR_ID ) ; if ( j > 0 ) { len = pci_vpd_info_field_size ( & vpd_data [ j ] ) ; j += PCI_VPD_INFO_FLD_HDR_SIZE ; if ( j + len > block_end || len != 4 || memcmp ( & vpd_data [ j ] , ""1028"" , 4 ) ) goto partno ; j = pci_vpd_find_info_keyword ( vpd_data , i , rosize , PCI_VPD_RO_KEYWORD_VENDOR0 ) ; if ( j < 0 ) goto partno ; len = pci_vpd_info_field_size ( & vpd_data [ j ] ) ; j += PCI_VPD_INFO_FLD_HDR_SIZE ; if ( j + len > block_end ) goto partno ; <S2SV_StartBug> memcpy ( tp -> fw_ver , & vpd_data [ j ] , len ) ; <S2SV_EndBug> <S2SV_StartBug> strncat ( tp -> fw_ver , ""<S2SV_blank>bc<S2SV_blank>"" , vpdlen - len - 1 ) ; <S2SV_EndBug> } partno : i = pci_vpd_find_info_keyword ( vpd_data , i , rosize , PCI_VPD_RO_KEYWORD_PARTNO ) ; if ( i < 0 ) goto out_not_found ; len = pci_vpd_info_field_size ( & vpd_data [ i ] ) ; i += PCI_VPD_INFO_FLD_HDR_SIZE ; if ( len > TG3_BPN_SIZE || ( len + i ) > vpdlen ) goto out_not_found ; memcpy ( tp -> board_part_number , & vpd_data [ i ] , len ) ; out_not_found : kfree ( vpd_data ) ; if ( tp -> board_part_number [ 0 ] ) return ; out_no_vpd : if ( tg3_asic_rev ( tp ) == ASIC_REV_5717 ) { if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_5717 || tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_5717_C ) strcpy ( tp -> board_part_number , ""BCM5717"" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_5718 ) strcpy ( tp -> board_part_number , ""BCM5718"" ) ; else goto nomatch ; } else if ( tg3_asic_rev ( tp ) == ASIC_REV_57780 ) { if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57780 ) strcpy ( tp -> board_part_number , ""BCM57780"" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57760 ) strcpy ( tp -> board_part_number , ""BCM57760"" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57790 ) strcpy ( tp -> board_part_number , ""BCM57790"" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57788 ) strcpy ( tp -> board_part_number , ""BCM57788"" ) ; else goto nomatch ; } else if ( tg3_asic_rev ( tp ) == ASIC_REV_57765 ) { if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57761 ) strcpy ( tp -> board_part_number , ""BCM57761"" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57765 ) strcpy ( tp -> board_part_number , ""BCM57765"" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57781 ) strcpy ( tp -> board_part_number , ""BCM57781"" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57785 ) strcpy ( tp -> board_part_number , ""BCM57785"" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57791 ) strcpy ( tp -> board_part_number , ""BCM57791"" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57795 ) strcpy ( tp -> board_part_number , ""BCM57795"" ) ; else goto nomatch ; } else if ( tg3_asic_rev ( tp ) == ASIC_REV_57766 ) { if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57762 ) strcpy ( tp -> board_part_number , ""BCM57762"" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57766 ) strcpy ( tp -> board_part_number , ""BCM57766"" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57782 ) strcpy ( tp -> board_part_number , ""BCM57782"" ) ; else if ( tp -> pdev -> device == TG3PCI_DEVICE_TIGON3_57786 ) strcpy ( tp -> board_part_number , ""BCM57786"" ) ; else goto nomatch ; } else if ( tg3_asic_rev ( tp ) == ASIC_REV_5906 ) { strcpy ( tp -> board_part_number , ""BCM95906"" ) ; } else { nomatch : strcpy ( tp -> board_part_number , ""none"" ) ; } }","goto partno ; if ( len >= sizeof <S2SV_ModEnd> ( tp -> <S2SV_ModStart> tp -> fw_ver ) ) len = sizeof <S2SV_ModEnd> ( tp -> <S2SV_ModStart> tp -> fw_ver ) - 1 ; memset ( tp -> fw_ver , 0 , sizeof ( tp -> fw_ver ) ) ; snprintf ( tp -> fw_ver , sizeof ( tp -> fw_ver ) , ""%.*s<S2SV_blank>bc<S2SV_blank>"" , len , & vpd_data [ j ] <S2SV_ModEnd> ) ; }"
642,"static int mountpoint_last ( struct nameidata * nd , struct path * path ) { int error = 0 ; struct dentry * dentry ; struct dentry * dir = nd -> path . dentry ; if ( nd -> flags & LOOKUP_RCU ) { if ( unlazy_walk ( nd , NULL ) ) { error = - ECHILD ; goto out ; } } nd -> flags &= ~ LOOKUP_PARENT ; if ( unlikely ( nd -> last_type != LAST_NORM ) ) { error = handle_dots ( nd , nd -> last_type ) ; if ( error ) goto out ; dentry = dget ( nd -> path . dentry ) ; goto done ; } mutex_lock ( & dir -> d_inode -> i_mutex ) ; dentry = d_lookup ( dir , & nd -> last ) ; if ( ! dentry ) { dentry = d_alloc ( dir , & nd -> last ) ; if ( ! dentry ) { error = - ENOMEM ; mutex_unlock ( & dir -> d_inode -> i_mutex ) ; goto out ; } dentry = lookup_real ( dir -> d_inode , dentry , nd -> flags ) ; error = PTR_ERR ( dentry ) ; if ( IS_ERR ( dentry ) ) { mutex_unlock ( & dir -> d_inode -> i_mutex ) ; goto out ; } } mutex_unlock ( & dir -> d_inode -> i_mutex ) ; done : if ( ! dentry -> d_inode || d_is_negative ( dentry ) ) { error = - ENOENT ; dput ( dentry ) ; goto out ; } path -> dentry = dentry ; <S2SV_StartBug> path -> mnt = mntget ( nd -> path . mnt ) ; <S2SV_EndBug> if ( should_follow_link ( dentry , nd -> flags & LOOKUP_FOLLOW ) ) return 1 ; <S2SV_StartBug> follow_mount ( path ) ; <S2SV_EndBug> error = 0 ; out : terminate_walk ( nd ) ; return error ; }",-> mnt = <S2SV_ModEnd> nd -> path <S2SV_ModStart> path . mnt <S2SV_ModEnd> ; if ( <S2SV_ModStart> return 1 ; mntget ( path -> mnt ) ;
643,"static ssize_t wdm_read ( struct file * file , char __user * buffer , size_t count , loff_t * ppos ) { int rv , cntr ; int i = 0 ; struct wdm_device * desc = file -> private_data ; rv = mutex_lock_interruptible ( & desc -> rlock ) ; if ( rv < 0 ) return - ERESTARTSYS ; cntr = ACCESS_ONCE ( desc -> length ) ; if ( cntr == 0 ) { desc -> read = 0 ; retry : if ( test_bit ( WDM_DISCONNECTING , & desc -> flags ) ) { rv = - ENODEV ; goto err ; } <S2SV_StartBug> i ++ ; <S2SV_EndBug> if ( file -> f_flags & O_NONBLOCK ) { if ( ! test_bit ( WDM_READ , & desc -> flags ) ) { rv = cntr ? cntr : - EAGAIN ; goto err ; } rv = 0 ; } else { rv = wait_event_interruptible ( desc -> wait , test_bit ( WDM_READ , & desc -> flags ) ) ; } if ( test_bit ( WDM_DISCONNECTING , & desc -> flags ) ) { rv = - ENODEV ; goto err ; } if ( test_bit ( WDM_RESETTING , & desc -> flags ) ) { rv = - EIO ; goto err ; } usb_mark_last_busy ( interface_to_usbdev ( desc -> intf ) ) ; if ( rv < 0 ) { rv = - ERESTARTSYS ; goto err ; } spin_lock_irq ( & desc -> iuspin ) ; if ( desc -> rerr ) { desc -> rerr = 0 ; spin_unlock_irq ( & desc -> iuspin ) ; rv = - EIO ; goto err ; } if ( ! test_bit ( WDM_READ , & desc -> flags ) ) { spin_unlock_irq ( & desc -> iuspin ) ; goto retry ; } if ( ! desc -> reslength ) { dev_dbg ( & desc -> intf -> dev , ""%s:<S2SV_blank>zero<S2SV_blank>length<S2SV_blank>-<S2SV_blank>clearing<S2SV_blank>WDM_READ\\n"" , __func__ ) ; clear_bit ( WDM_READ , & desc -> flags ) ; spin_unlock_irq ( & desc -> iuspin ) ; goto retry ; } cntr = desc -> length ; spin_unlock_irq ( & desc -> iuspin ) ; } if ( cntr > count ) cntr = count ; rv = copy_to_user ( buffer , desc -> ubuf , cntr ) ; if ( rv > 0 ) { rv = - EFAULT ; goto err ; } spin_lock_irq ( & desc -> iuspin ) ; for ( i = 0 ; i < desc -> length - cntr ; i ++ ) desc -> ubuf [ i ] = desc -> ubuf [ i + cntr ] ; desc -> length -= cntr ; if ( ! desc -> length ) clear_bit ( WDM_READ , & desc -> flags ) ; spin_unlock_irq ( & desc -> iuspin ) ; rv = cntr ; err : mutex_unlock ( & desc -> rlock ) ; return rv ; }","err ; } if ( test_bit ( WDM_OVERFLOW , & desc -> flags ) ) { clear_bit ( WDM_OVERFLOW , & desc -> flags ) ; rv = - ENOBUFS ; goto err ; }"
644,"uint16_t enc28j60ReadPhyReg ( NetInterface * interface , uint16_t address ) { uint16_t data ; <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_MIREGADR , address & REG_ADDR_MASK ) ; <S2SV_EndBug> <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_MICMD , MICMD_MIIRD ) ; <S2SV_EndBug> <S2SV_StartBug> while ( ( enc28j60ReadReg ( interface , ENC28J60_REG_MISTAT ) & MISTAT_BUSY ) != 0 ) <S2SV_EndBug> { } <S2SV_StartBug> enc28j60WriteReg ( interface , ENC28J60_REG_MICMD , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> data = enc28j60ReadReg ( interface , ENC28J60_REG_MIRDL ) ; <S2SV_EndBug> <S2SV_StartBug> data |= enc28j60ReadReg ( interface , ENC28J60_REG_MIRDH ) << 8 ; <S2SV_EndBug> return data ; }","( interface , ENC28J60_MIREGADR <S2SV_ModEnd> , address & <S2SV_ModStart> ( interface , ENC28J60_MICMD , ENC28J60_MICMD_MIIRD <S2SV_ModEnd> ) ; while <S2SV_ModStart> ( interface , ENC28J60_MISTAT ) & ENC28J60_MISTAT_BUSY <S2SV_ModEnd> ) != 0 <S2SV_ModStart> ( interface , ENC28J60_MICMD <S2SV_ModEnd> , 0 ) <S2SV_ModStart> ( interface , ENC28J60_MIRDL <S2SV_ModEnd> ) ; data <S2SV_ModStart> ( interface , ENC28J60_MIRDH <S2SV_ModEnd> ) << 8"
645,"static void sas_revalidate_domain ( struct work_struct * work ) { int res = 0 ; struct sas_discovery_event * ev = to_sas_discovery_event ( work ) ; struct asd_sas_port * port = ev -> port ; struct sas_ha_struct * ha = port -> ha ; struct domain_device * ddev = port -> port_dev ; mutex_lock ( & ha -> disco_mutex ) ; if ( test_bit ( SAS_HA_ATA_EH_ACTIVE , & ha -> state ) ) { SAS_DPRINTK ( ""REVALIDATION<S2SV_blank>DEFERRED<S2SV_blank>on<S2SV_blank>port<S2SV_blank>%d,<S2SV_blank>pid:%d\\n"" , port -> id , task_pid_nr ( current ) ) ; goto out ; } clear_bit ( DISCE_REVALIDATE_DOMAIN , & port -> disc . pending ) ; SAS_DPRINTK ( ""REVALIDATING<S2SV_blank>DOMAIN<S2SV_blank>on<S2SV_blank>port<S2SV_blank>%d,<S2SV_blank>pid:%d\\n"" , port -> id , task_pid_nr ( current ) ) ; if ( ddev && ( ddev -> dev_type == SAS_FANOUT_EXPANDER_DEVICE || ddev -> dev_type == SAS_EDGE_EXPANDER_DEVICE ) ) res = sas_ex_revalidate_domain ( ddev ) ; SAS_DPRINTK ( ""done<S2SV_blank>REVALIDATING<S2SV_blank>DOMAIN<S2SV_blank>on<S2SV_blank>port<S2SV_blank>%d,<S2SV_blank>pid:%d,<S2SV_blank>res<S2SV_blank>0x%x\\n"" , port -> id , task_pid_nr ( current ) , res ) ; out : mutex_unlock ( & ha -> disco_mutex ) ; <S2SV_StartBug> } <S2SV_EndBug>",disco_mutex ) ; sas_destruct_devices ( port ) ; sas_destruct_ports ( port ) ; sas_probe_devices ( port ) ;
646,"static int <S2SV_StartBug> mptctl_readtest ( unsigned long arg ) <S2SV_EndBug> { struct mpt_ioctl_test __user * uarg = ( void __user * ) arg ; struct mpt_ioctl_test karg ; <S2SV_StartBug> MPT_ADAPTER * ioc ; <S2SV_EndBug> int iocnum ; if ( copy_from_user ( & karg , uarg , sizeof ( struct mpt_ioctl_test ) ) ) { printk ( KERN_ERR MYNAM ""%s@%d::mptctl_readtest<S2SV_blank>-<S2SV_blank>"" ""Unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>in<S2SV_blank>mpt_ioctl_test<S2SV_blank>struct<S2SV_blank>@<S2SV_blank>%p\\n"" , __FILE__ , __LINE__ , uarg ) ; return - EFAULT ; } <S2SV_StartBug> if ( ( ( iocnum = mpt_verify_adapter ( karg . hdr . iocnum , & ioc ) ) < 0 ) || <S2SV_EndBug> ( ioc == NULL ) ) { printk ( KERN_DEBUG MYNAM ""%s::mptctl_readtest()<S2SV_blank>@%d<S2SV_blank>-<S2SV_blank>ioc%d<S2SV_blank>not<S2SV_blank>found!\\n"" , __FILE__ , __LINE__ , iocnum ) ; return - ENODEV ; } dctlprintk ( ioc , printk ( MYIOC_s_DEBUG_FMT ""mptctl_readtest<S2SV_blank>called.\\n"" , ioc -> name ) ) ; # ifdef MFCNT karg . chip_type = ioc -> mfcnt ; # else karg . chip_type = ioc -> pcidev -> device ; # endif strncpy ( karg . name , ioc -> name , MPT_MAX_NAME ) ; karg . name [ MPT_MAX_NAME - 1 ] = '\\0' ; strncpy ( karg . product , ioc -> prod_name , MPT_PRODUCT_LENGTH ) ; karg . product [ MPT_PRODUCT_LENGTH - 1 ] = '\\0' ; if ( copy_to_user ( ( char __user * ) arg , & karg , sizeof ( struct mpt_ioctl_test ) ) ) { printk ( MYIOC_s_ERR_FMT ""%s@%d::mptctl_readtest<S2SV_blank>-<S2SV_blank>"" ""Unable<S2SV_blank>to<S2SV_blank>write<S2SV_blank>out<S2SV_blank>mpt_ioctl_test<S2SV_blank>struct<S2SV_blank>@<S2SV_blank>%p\\n"" , ioc -> name , __FILE__ , __LINE__ , uarg ) ; return - EFAULT ; } return 0 ; }","int mptctl_readtest ( MPT_ADAPTER * ioc , <S2SV_ModStart> mpt_ioctl_test karg ; <S2SV_ModEnd> if ( copy_from_user <S2SV_ModStart> EFAULT ; } <S2SV_ModEnd> dctlprintk ( ioc"
647,"<S2SV_StartBug> static void choose_partitioning ( VP9_COMP * cpi , <S2SV_EndBug> const TileInfo * const tile , <S2SV_StartBug> int mi_row , int mi_col ) { <S2SV_EndBug> VP9_COMMON * const cm = & cpi -> common ; <S2SV_StartBug> MACROBLOCK * x = & cpi -> mb ; <S2SV_EndBug> <S2SV_StartBug> MACROBLOCKD * xd = & cpi -> mb . e_mbd ; <S2SV_EndBug> <S2SV_StartBug> int i , j , k ; <S2SV_EndBug> <S2SV_StartBug> v64x64 vt ; <S2SV_EndBug> uint8_t * s ; const uint8_t * d ; int sp ; int dp ; int pixels_wide = 64 , pixels_high = 64 ; <S2SV_StartBug> int_mv nearest_mv , near_mv ; <S2SV_EndBug> const YV12_BUFFER_CONFIG * yv12 = get_ref_frame_buffer ( cpi , LAST_FRAME ) ; <S2SV_StartBug> const struct scale_factors * const sf = & cm -> frame_refs [ LAST_FRAME - 1 ] . sf ; <S2SV_EndBug> vp9_zero ( vt ) ; <S2SV_StartBug> set_offsets ( cpi , tile , mi_row , mi_col , BLOCK_64X64 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( xd -> mb_to_right_edge < 0 ) <S2SV_EndBug> pixels_wide += ( xd -> mb_to_right_edge >> 3 ) ; if ( xd -> mb_to_bottom_edge < 0 ) pixels_high += ( xd -> mb_to_bottom_edge >> 3 ) ; s = x -> plane [ 0 ] . src . buf ; sp = x -> plane [ 0 ] . src . stride ; if ( cm -> frame_type != KEY_FRAME ) { <S2SV_StartBug> vp9_setup_pre_planes ( xd , 0 , yv12 , mi_row , mi_col , sf ) ; <S2SV_EndBug> xd -> mi [ 0 ] -> mbmi . ref_frame [ 0 ] = LAST_FRAME ; xd -> mi [ 0 ] -> mbmi . sb_type = BLOCK_64X64 ; vp9_find_best_ref_mvs ( xd , cm -> allow_high_precision_mv , xd -> mi [ 0 ] -> mbmi . ref_mvs [ LAST_FRAME ] , & nearest_mv , & near_mv ) ; xd -> mi [ 0 ] -> mbmi . mv [ 0 ] = nearest_mv ; vp9_build_inter_predictors_sby ( xd , mi_row , mi_col , BLOCK_64X64 ) ; d = xd -> plane [ 0 ] . dst . buf ; <S2SV_StartBug> dp = xd -> plane [ 0 ] . dst . stride ; <S2SV_EndBug> } else { d = VP9_VAR_OFFS ; dp = 0 ; } for ( i = 0 ; i < 4 ; i ++ ) { const int x32_idx = ( ( i & 1 ) << 5 ) ; const int y32_idx = ( ( i >> 1 ) << 5 ) ; <S2SV_StartBug> for ( j = 0 ; j < 4 ; j ++ ) { <S2SV_EndBug> const int x16_idx = x32_idx + ( ( j & 1 ) << 4 ) ; <S2SV_StartBug> const int y16_idx = y32_idx + ( ( j >> 1 ) << 4 ) ; <S2SV_EndBug> v16x16 * vst = & vt . split [ i ] . split [ j ] ; <S2SV_StartBug> for ( k = 0 ; k < 4 ; k ++ ) { <S2SV_EndBug> <S2SV_StartBug> int x_idx = x16_idx + ( ( k & 1 ) << 3 ) ; <S2SV_EndBug> <S2SV_StartBug> int y_idx = y16_idx + ( ( k >> 1 ) << 3 ) ; <S2SV_EndBug> <S2SV_StartBug> unsigned int sse = 0 ; <S2SV_EndBug> int sum = 0 ; if ( x_idx < pixels_wide && y_idx < pixels_high ) vp9_get_sse_sum_8x8 ( s + y_idx * sp + x_idx , sp , d + y_idx * dp + x_idx , dp , & sse , & sum ) ; fill_variance ( sse , sum , 64 , & vst -> split [ k ] . part_variances . none ) ; } } } for ( i = 0 ; i < 4 ; i ++ ) { <S2SV_StartBug> for ( j = 0 ; j < 4 ; j ++ ) { <S2SV_EndBug> <S2SV_StartBug> fill_variance_tree ( & vt . split [ i ] . split [ j ] , BLOCK_16X16 ) ; <S2SV_EndBug> } <S2SV_StartBug> fill_variance_tree ( & vt . split [ i ] , BLOCK_32X32 ) ; <S2SV_EndBug> } <S2SV_StartBug> fill_variance_tree ( & vt , BLOCK_64X64 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! set_vt_partitioning ( cpi , & vt , tile , BLOCK_64X64 , <S2SV_EndBug> <S2SV_StartBug> mi_row , mi_col , 8 ) ) { <S2SV_EndBug> for ( i = 0 ; i < 4 ; ++ i ) { const int x32_idx = ( ( i & 1 ) << 2 ) ; const int y32_idx = ( ( i >> 1 ) << 2 ) ; <S2SV_StartBug> if ( ! set_vt_partitioning ( cpi , & vt . split [ i ] , tile , BLOCK_32X32 , <S2SV_EndBug> <S2SV_StartBug> ( mi_row + y32_idx ) , ( mi_col + x32_idx ) , 4 ) ) { <S2SV_EndBug> for ( j = 0 ; j < 4 ; ++ j ) { const int x16_idx = ( ( j & 1 ) << 1 ) ; const int y16_idx = ( ( j >> 1 ) << 1 ) ; <S2SV_StartBug> # define DISABLE_8X8_VAR_BASED_PARTITION <S2SV_EndBug> # ifdef DISABLE_8X8_VAR_BASED_PARTITION <S2SV_StartBug> if ( mi_row + y32_idx + y16_idx + 1 < cm -> mi_rows && <S2SV_EndBug> <S2SV_StartBug> mi_row + x32_idx + x16_idx + 1 < cm -> mi_cols ) { <S2SV_EndBug> set_block_size ( cpi , tile , ( mi_row + y32_idx + y16_idx ) , ( mi_col + x32_idx + x16_idx ) , BLOCK_16X16 ) ; } else { for ( k = 0 ; k < 4 ; ++ k ) { const int x8_idx = ( k & 1 ) ; const int y8_idx = ( k >> 1 ) ; <S2SV_StartBug> set_block_size ( cpi , tile , <S2SV_EndBug> ( mi_row + y32_idx + y16_idx + y8_idx ) , ( mi_col + x32_idx + x16_idx + x8_idx ) , BLOCK_8X8 ) ; } } # else <S2SV_StartBug> if ( ! set_vt_partitioning ( cpi , & vt . split [ i ] . split [ j ] , tile , <S2SV_EndBug> BLOCK_16X16 , <S2SV_StartBug> ( mi_row + y32_idx + y16_idx ) , <S2SV_EndBug> <S2SV_StartBug> ( mi_col + x32_idx + x16_idx ) , 2 ) ) { <S2SV_EndBug> for ( k = 0 ; k < 4 ; ++ k ) { const int x8_idx = ( k & 1 ) ; const int y8_idx = ( k >> 1 ) ; <S2SV_StartBug> set_block_size ( cpi , tile , <S2SV_EndBug> ( mi_row + y32_idx + y16_idx + y8_idx ) , ( mi_col + x32_idx + x16_idx + x8_idx ) , BLOCK_8X8 ) ; } } <S2SV_StartBug> # endif <S2SV_EndBug> } } } } }","<S2SV_null> <S2SV_null> static int <S2SV_ModEnd> choose_partitioning ( VP9_COMP <S2SV_ModStart> const tile , <S2SV_ModEnd> MACROBLOCK * x <S2SV_ModStart> MACROBLOCK * x , int mi_row , int mi_col ) { VP9_COMMON * const cm = & cpi -> common <S2SV_ModEnd> ; MACROBLOCKD * <S2SV_ModStart> xd = & x -> <S2SV_ModEnd> e_mbd ; int <S2SV_ModStart> j , k , m <S2SV_ModStart> ; v64x64 vt ; v16x16 vt2 [ 16 ] ; int force_split [ 21 ] <S2SV_ModStart> = 64 ; int64_t thresholds [ 4 ] = { cpi -> vbp_thresholds [ 0 ] , cpi -> vbp_thresholds [ 1 ] , cpi -> vbp_thresholds [ 2 ] , cpi -> vbp_thresholds [ 3 ] } ; const int is_key_frame = ( cm -> frame_type == KEY_FRAME ) ; const int use_4x4_partition = is_key_frame ; const int low_res = ( cm -> width <= 352 && cm -> height <= 288 ) ; int variance4x4downsample [ 16 ] ; int segment_id = CR_SEGMENT_ID_BASE ; if ( cpi -> oxcf . aq_mode == CYCLIC_REFRESH_AQ && cm -> seg . enabled ) { const uint8_t * const map = cm -> seg . update_map ? cpi -> segmentation_map : cm -> last_frame_seg_map ; segment_id = get_segment_id ( cm , map , BLOCK_64X64 , mi_row , mi_col ) ; if ( cyclic_refresh_segment_id_boosted ( segment_id ) ) { int q = vp9_get_qindex ( & cm -> seg , segment_id , cm -> base_qindex ) ; set_vbp_thresholds ( cpi , thresholds , q ) ; } } set_offsets ( cpi , tile , x , mi_row , mi_col , BLOCK_64X64 ) ; if ( xd -> mb_to_right_edge < 0 ) pixels_wide += ( xd -> mb_to_right_edge >> 3 ) ; if ( xd -> mb_to_bottom_edge < 0 ) pixels_high += ( xd -> mb_to_bottom_edge >> 3 ) ; s = x -> plane [ 0 ] . src . buf ; sp = x -> plane [ 0 ] . src . stride ; if ( ! is_key_frame && ! ( is_one_pass_cbr_svc ( cpi ) && cpi -> svc . layer_context [ cpi -> svc . temporal_layer_id ] . is_key_frame ) ) { MB_MODE_INFO * mbmi = & xd -> mi [ 0 ] -> mbmi ; unsigned int uv_sad <S2SV_ModEnd> ; const YV12_BUFFER_CONFIG <S2SV_ModStart> ) ; const YV12_BUFFER_CONFIG * yv12_g = NULL ; unsigned int y_sad , y_sad_g ; const BLOCK_SIZE bsize = BLOCK_32X32 + ( mi_col + 4 < cm -> mi_cols ) * 2 + ( mi_row + 4 < cm -> mi_rows ) ; assert ( yv12 != NULL ) ; if ( ! ( is_one_pass_cbr_svc ( cpi ) && cpi -> svc . spatial_layer_id ) ) { yv12_g = get_ref_frame_buffer ( cpi , GOLDEN_FRAME ) ; } if ( yv12_g && yv12_g != yv12 && ( cpi -> ref_frame_flags & VP9_GOLD_FLAG ) ) { vp9_setup_pre_planes ( xd , 0 , yv12_g , mi_row , mi_col , & cm -> frame_refs [ GOLDEN_FRAME - 1 ] . sf ) ; y_sad_g = cpi -> fn_ptr [ bsize ] . sdf ( x -> plane [ 0 ] . src . buf , x -> plane [ 0 ] . src . stride , xd -> plane [ 0 ] . pre [ 0 ] . buf , xd -> plane [ 0 ] . pre [ 0 ] . stride ) ; } else { y_sad_g = UINT_MAX ; } vp9_setup_pre_planes ( xd , 0 , yv12 , mi_row , mi_col , <S2SV_ModEnd> & cm -> <S2SV_ModStart> ] . sf ) ; mbmi -> ref_frame [ 0 ] = LAST_FRAME ; mbmi -> ref_frame [ 1 ] = NONE ; mbmi -> sb_type = BLOCK_64X64 ; mbmi -> mv [ 0 ] . as_int = 0 ; mbmi -> interp_filter = BILINEAR ; y_sad = vp9_int_pro_motion_estimation ( cpi , x , bsize <S2SV_ModEnd> , mi_row , <S2SV_ModStart> mi_row , mi_col ) ; if ( y_sad_g < y_sad ) { vp9_setup_pre_planes ( xd , 0 , yv12_g , mi_row , mi_col , & cm -> frame_refs [ GOLDEN_FRAME - 1 ] . sf ) ; mbmi -> ref_frame [ 0 ] = GOLDEN_FRAME ; mbmi -> mv [ 0 ] . as_int = 0 ; y_sad = y_sad_g ; } else { x -> pred_mv [ LAST_FRAME ] = mbmi -> mv [ 0 ] . as_mv ; } vp9_build_inter_predictors_sb ( xd , mi_row , mi_col <S2SV_ModStart> BLOCK_64X64 ) ; for ( i = 1 ; i <= 2 ; ++ i ) { struct macroblock_plane * p = & x -> plane [ i ] ; struct macroblockd_plane * pd = & xd -> plane [ i ] ; const BLOCK_SIZE bs = get_plane_block_size ( bsize , pd ) ; if ( bs == BLOCK_INVALID ) uv_sad = UINT_MAX ; else uv_sad = cpi -> fn_ptr [ bs ] . sdf ( p -> src . buf , p -> src . stride , pd -> dst . buf , pd -> dst . stride ) ; x -> color_sensitivity [ i - 1 ] = uv_sad > ( y_sad >> 2 ) ; } d = xd -> plane [ 0 ] . dst . buf ; dp = xd -> plane [ 0 ] . dst . stride ; if ( segment_id == CR_SEGMENT_ID_BASE && y_sad < cpi -> vbp_threshold_sad ) { const int block_width = num_8x8_blocks_wide_lookup [ BLOCK_64X64 ] ; const int block_height = num_8x8_blocks_high_lookup [ BLOCK_64X64 ] ; if ( mi_col + block_width / 2 < cm -> mi_cols && mi_row + block_height / 2 < cm -> mi_rows ) { set_block_size ( cpi , x , xd <S2SV_ModEnd> , mi_row , <S2SV_ModStart> , mi_col , BLOCK_64X64 ) ; return 0 ; } } } else { d = VP9_VAR_OFFS <S2SV_ModEnd> ; dp = <S2SV_ModStart> ; dp = 0 ; # if CONFIG_VP9_HIGHBITDEPTH if ( xd -> cur_buf -> flags & YV12_FLAG_HIGHBITDEPTH ) { switch ( xd -> bd ) { case 10 : d = CONVERT_TO_BYTEPTR ( VP9_HIGH_VAR_OFFS_10 ) ; break ; case 12 : d = CONVERT_TO_BYTEPTR ( VP9_HIGH_VAR_OFFS_12 ) ; break ; case 8 : default : d = CONVERT_TO_BYTEPTR ( VP9_HIGH_VAR_OFFS_8 ) ; break ; } } # endif } force_split [ 0 ] = 0 ; <S2SV_ModEnd> for ( i <S2SV_ModStart> 5 ) ; const int i2 = i << 2 ; force_split [ i + 1 ] = 0 ; <S2SV_ModStart> << 4 ) ; const int split_index = 5 + i2 + j <S2SV_ModStart> j ] ; force_split [ split_index ] = 0 ; variance4x4downsample [ i2 + j ] = 0 ; if ( ! is_key_frame ) { fill_variance_8x8avg ( s , sp , d , dp , x16_idx , y16_idx , vst , # if CONFIG_VP9_HIGHBITDEPTH xd -> cur_buf -> flags , # endif pixels_wide , pixels_high , is_key_frame ) ; fill_variance_tree ( & vt . split [ i ] . split [ j ] , BLOCK_16X16 ) ; get_variance ( & vt . split [ i ] . split [ j ] . part_variances . none ) ; if ( vt . split [ i ] . split [ j ] . part_variances . none . variance > thresholds [ 2 ] ) { force_split [ split_index ] = 1 ; force_split [ i + 1 ] = 1 ; force_split [ 0 ] = 1 ; } else if ( vt . split [ i ] . split [ j ] . part_variances . none . variance > thresholds [ 1 ] && ! cyclic_refresh_segment_id_boosted ( segment_id ) ) { int minmax = compute_minmax_8x8 ( s , sp , d , dp , x16_idx , y16_idx , # if CONFIG_VP9_HIGHBITDEPTH xd -> cur_buf -> flags , # endif pixels_wide , pixels_high ) ; if ( minmax > cpi -> vbp_threshold_minmax ) { force_split [ split_index ] = 1 ; force_split [ i + 1 ] = 1 ; force_split [ 0 ] = 1 ; } } } if ( is_key_frame || ( low_res && ! cpi -> use_svc && vt . split [ i ] . split [ j ] . part_variances . none . variance > ( thresholds [ 1 ] << 1 ) ) ) { force_split [ split_index ] = 0 ; variance4x4downsample [ i2 + j ] = 1 ; <S2SV_ModStart> ) { int x8_idx <S2SV_ModEnd> = x16_idx + <S2SV_ModStart> ) ; int y8_idx <S2SV_ModEnd> = y16_idx + <S2SV_ModStart> 3 ) ; v8x8 * vst2 = is_key_frame ? & vst -> split [ k ] : & vt2 [ i2 + j ] . split [ k ] ; fill_variance_4x4avg ( s , sp , d , dp , x8_idx , y8_idx , vst2 , # if CONFIG_VP9_HIGHBITDEPTH xd -> cur_buf -> flags , # endif pixels_wide , pixels_high , is_key_frame ) ; } <S2SV_ModEnd> } } } <S2SV_ModStart> ++ ) { const int i2 = i << 2 ; <S2SV_ModStart> ++ ) { if ( variance4x4downsample [ i2 + j ] == 1 ) { v16x16 * vtemp = ( ! is_key_frame ) ? & vt2 [ i2 + j ] : & vt . split [ i ] . split [ j ] ; for ( m = 0 ; m < 4 ; m ++ ) <S2SV_ModStart> fill_variance_tree ( & vtemp -> split [ m ] , BLOCK_8X8 ) ; fill_variance_tree ( vtemp , BLOCK_16X16 ) ; } } fill_variance_tree ( & <S2SV_ModStart> [ i ] , BLOCK_32X32 ) ; if ( ! force_split [ i + 1 ] ) { get_variance ( & vt <S2SV_ModStart> . split [ i ] . part_variances . none ) ; if ( vt . split [ i ] . part_variances . none . variance > thresholds [ 1 ] ) { force_split [ i + 1 ] = 1 ; force_split [ 0 ] = 1 ; } } } if ( ! force_split [ 0 ] ) { <S2SV_ModEnd> fill_variance_tree ( & <S2SV_ModStart> ( & vt , BLOCK_64X64 ) ; get_variance <S2SV_ModEnd> ( & vt <S2SV_ModStart> ( & vt . part_variances . none ) ; } if ( mi_col + 8 > cm -> mi_cols || mi_row + 8 > cm -> mi_rows || <S2SV_ModEnd> ! set_vt_partitioning ( <S2SV_ModStart> ( cpi , x , xd , <S2SV_ModStart> & vt , <S2SV_ModEnd> BLOCK_64X64 , mi_row <S2SV_ModStart> , mi_col , thresholds [ 0 ] , BLOCK_16X16 , force_split [ 0 ] <S2SV_ModEnd> ) ) { <S2SV_ModStart> 2 ) ; const int i2 = i << 2 ; <S2SV_ModStart> ( cpi , x , xd , <S2SV_ModStart> i ] , <S2SV_ModEnd> BLOCK_32X32 , ( <S2SV_ModStart> x32_idx ) , thresholds [ 1 ] , BLOCK_16X16 , force_split [ i + 1 ] <S2SV_ModEnd> ) ) { <S2SV_ModStart> 1 ) ; v16x16 * vtemp = ( ! is_key_frame && variance4x4downsample [ i2 + j ] == 1 ) ? & vt2 [ i2 + j ] : & vt . split [ i ] . split [ j ] ; if ( ! set_vt_partitioning ( cpi , x , xd , vtemp , BLOCK_16X16 , <S2SV_ModEnd> mi_row + y32_idx <S2SV_ModStart> y32_idx + y16_idx , mi_col <S2SV_ModEnd> + x32_idx + <S2SV_ModStart> x32_idx + x16_idx , thresholds [ 2 ] , cpi -> vbp_bsize_min , force_split [ 5 + i2 + j ] ) ) <S2SV_ModEnd> { for ( <S2SV_ModStart> 1 ) ; if ( use_4x4_partition ) { <S2SV_ModEnd> if ( ! <S2SV_ModStart> ( cpi , x , xd , & vtemp -> split [ k ] , BLOCK_8X8 , <S2SV_ModEnd> mi_row + y32_idx <S2SV_ModStart> y32_idx + y16_idx + y8_idx , <S2SV_ModEnd> mi_col + x32_idx <S2SV_ModStart> x32_idx + x16_idx + x8_idx , thresholds [ 3 ] , BLOCK_8X8 , 0 ) ) { set_block_size ( cpi , x , xd , ( mi_row + y32_idx + y16_idx + y8_idx ) , ( mi_col + x32_idx + x16_idx + x8_idx ) , BLOCK_4X4 ) ; } } else { <S2SV_ModEnd> set_block_size ( cpi <S2SV_ModStart> ( cpi , x , xd <S2SV_ModEnd> , ( mi_row <S2SV_ModStart> ; } } } } } } } return 0 ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>"
648,"static int parse_rock_ridge_inode_internal ( struct iso_directory_record * de , <S2SV_StartBug> struct inode * inode , int regard_xa ) <S2SV_EndBug> { int symlink_len = 0 ; <S2SV_StartBug> int cnt , sig ; <S2SV_EndBug> struct inode * reloc ; struct rock_ridge * rr ; int rootflag ; struct rock_state rs ; int ret = 0 ; if ( ! ISOFS_SB ( inode -> i_sb ) -> s_rock ) return 0 ; init_rock_state ( & rs , inode ) ; setup_rock_ridge ( de , inode , & rs ) ; <S2SV_StartBug> if ( regard_xa ) { <S2SV_EndBug> rs . chr += 14 ; rs . len -= 14 ; if ( rs . len < 0 ) rs . len = 0 ; } repeat : while ( rs . len > 2 ) { rr = ( struct rock_ridge * ) rs . chr ; if ( rr -> len < 3 ) goto out ; sig = isonum_721 ( rs . chr ) ; if ( rock_check_overflow ( & rs , sig ) ) goto eio ; rs . chr += rr -> len ; rs . len -= rr -> len ; if ( rs . len < 0 ) goto out ; switch ( sig ) { # ifndef CONFIG_ZISOFS case SIG ( 'R' , 'R' ) : if ( ( rr -> u . RR . flags [ 0 ] & ( RR_PX | RR_TF | RR_SL | RR_CL ) ) == 0 ) goto out ; break ; # endif case SIG ( 'S' , 'P' ) : if ( check_sp ( rr , inode ) ) goto out ; break ; case SIG ( 'C' , 'E' ) : rs . cont_extent = isonum_733 ( rr -> u . CE . extent ) ; rs . cont_offset = isonum_733 ( rr -> u . CE . offset ) ; rs . cont_size = isonum_733 ( rr -> u . CE . size ) ; break ; case SIG ( 'E' , 'R' ) : ISOFS_SB ( inode -> i_sb ) -> s_rock = 1 ; printk ( KERN_DEBUG ""ISO<S2SV_blank>9660<S2SV_blank>Extensions:<S2SV_blank>"" ) ; { int p ; for ( p = 0 ; p < rr -> u . ER . len_id ; p ++ ) printk ( ""%c"" , rr -> u . ER . data [ p ] ) ; } printk ( ""\\n"" ) ; break ; case SIG ( 'P' , 'X' ) : inode -> i_mode = isonum_733 ( rr -> u . PX . mode ) ; set_nlink ( inode , isonum_733 ( rr -> u . PX . n_links ) ) ; i_uid_write ( inode , isonum_733 ( rr -> u . PX . uid ) ) ; i_gid_write ( inode , isonum_733 ( rr -> u . PX . gid ) ) ; break ; case SIG ( 'P' , 'N' ) : { int high , low ; high = isonum_733 ( rr -> u . PN . dev_high ) ; low = isonum_733 ( rr -> u . PN . dev_low ) ; if ( ( low & ~ 0xff ) && high == 0 ) { inode -> i_rdev = MKDEV ( low >> 8 , low & 0xff ) ; } else { inode -> i_rdev = MKDEV ( high , low ) ; } } break ; case SIG ( 'T' , 'F' ) : cnt = 0 ; if ( rr -> u . TF . flags & TF_CREATE ) { inode -> i_ctime . tv_sec = iso_date ( rr -> u . TF . times [ cnt ++ ] . time , 0 ) ; inode -> i_ctime . tv_nsec = 0 ; } if ( rr -> u . TF . flags & TF_MODIFY ) { inode -> i_mtime . tv_sec = iso_date ( rr -> u . TF . times [ cnt ++ ] . time , 0 ) ; inode -> i_mtime . tv_nsec = 0 ; } if ( rr -> u . TF . flags & TF_ACCESS ) { inode -> i_atime . tv_sec = iso_date ( rr -> u . TF . times [ cnt ++ ] . time , 0 ) ; inode -> i_atime . tv_nsec = 0 ; } if ( rr -> u . TF . flags & TF_ATTRIBUTES ) { inode -> i_ctime . tv_sec = iso_date ( rr -> u . TF . times [ cnt ++ ] . time , 0 ) ; inode -> i_ctime . tv_nsec = 0 ; } break ; case SIG ( 'S' , 'L' ) : { int slen ; struct SL_component * slp ; struct SL_component * oldslp ; slen = rr -> len - 5 ; slp = & rr -> u . SL . link ; inode -> i_size = symlink_len ; while ( slen > 1 ) { rootflag = 0 ; switch ( slp -> flags & ~ 1 ) { case 0 : inode -> i_size += slp -> len ; break ; case 2 : inode -> i_size += 1 ; break ; case 4 : inode -> i_size += 2 ; break ; case 8 : rootflag = 1 ; inode -> i_size += 1 ; break ; default : printk ( ""Symlink<S2SV_blank>component<S2SV_blank>flag<S2SV_blank>"" ""not<S2SV_blank>implemented\\n"" ) ; } slen -= slp -> len + 2 ; oldslp = slp ; slp = ( struct SL_component * ) ( ( ( char * ) slp ) + slp -> len + 2 ) ; if ( slen < 2 ) { if ( ( ( rr -> u . SL . flags & 1 ) != 0 ) && ( ( oldslp -> flags & 1 ) == 0 ) ) inode -> i_size += 1 ; break ; } if ( ! rootflag && ( oldslp -> flags & 1 ) == 0 ) inode -> i_size += 1 ; } } symlink_len = inode -> i_size ; break ; case SIG ( 'R' , 'E' ) : printk ( KERN_WARNING ""Attempt<S2SV_blank>to<S2SV_blank>read<S2SV_blank>inode<S2SV_blank>for<S2SV_blank>"" ""relocated<S2SV_blank>directory\\n"" ) ; goto out ; case SIG ( 'C' , 'L' ) : <S2SV_StartBug> ISOFS_I ( inode ) -> i_first_extent = <S2SV_EndBug> isonum_733 ( rr -> u . CL . location ) ; reloc = <S2SV_StartBug> isofs_iget ( inode -> i_sb , <S2SV_EndBug> <S2SV_StartBug> ISOFS_I ( inode ) -> i_first_extent , <S2SV_EndBug> 0 ) ; if ( IS_ERR ( reloc ) ) { ret = PTR_ERR ( reloc ) ; goto out ; } inode -> i_mode = reloc -> i_mode ; set_nlink ( inode , reloc -> i_nlink ) ; inode -> i_uid = reloc -> i_uid ; inode -> i_gid = reloc -> i_gid ; inode -> i_rdev = reloc -> i_rdev ; inode -> i_size = reloc -> i_size ; inode -> i_blocks = reloc -> i_blocks ; inode -> i_atime = reloc -> i_atime ; inode -> i_ctime = reloc -> i_ctime ; inode -> i_mtime = reloc -> i_mtime ; iput ( reloc ) ; break ; # ifdef CONFIG_ZISOFS case SIG ( 'Z' , 'F' ) : { int algo ; if ( ISOFS_SB ( inode -> i_sb ) -> s_nocompress ) break ; algo = isonum_721 ( rr -> u . ZF . algorithm ) ; if ( algo == SIG ( 'p' , 'z' ) ) { int block_shift = isonum_711 ( & rr -> u . ZF . parms [ 1 ] ) ; if ( block_shift > 17 ) { printk ( KERN_WARNING ""isofs:<S2SV_blank>"" ""Can\'t<S2SV_blank>handle<S2SV_blank>ZF<S2SV_blank>block<S2SV_blank>"" ""size<S2SV_blank>of<S2SV_blank>2^%d\\n"" , block_shift ) ; } else { ISOFS_I ( inode ) -> i_file_format = isofs_file_compressed ; ISOFS_I ( inode ) -> i_format_parm [ 0 ] = isonum_711 ( & rr -> u . ZF . parms [ 0 ] ) ; ISOFS_I ( inode ) -> i_format_parm [ 1 ] = isonum_711 ( & rr -> u . ZF . parms [ 1 ] ) ; inode -> i_size = isonum_733 ( rr -> u . ZF . real_size ) ; } } else { printk ( KERN_WARNING ""isofs:<S2SV_blank>Unknown<S2SV_blank>ZF<S2SV_blank>compression<S2SV_blank>"" ""algorithm:<S2SV_blank>%c%c\\n"" , rr -> u . ZF . algorithm [ 0 ] , rr -> u . ZF . algorithm [ 1 ] ) ; } break ; } # endif default : break ; } } ret = rock_continue ( & rs ) ; if ( ret == 0 ) goto repeat ; if ( ret == 1 ) ret = 0 ; out : kfree ( rs . buffer ) ; return ret ; eio : ret = - EIO ; goto out ; }","inode , int flags <S2SV_ModEnd> ) { int <S2SV_ModStart> cnt , sig ; unsigned int reloc_block <S2SV_ModStart> ; if ( flags & RR_REGARD_XA <S2SV_ModEnd> ) { rs <S2SV_ModStart> 'L' ) : if ( flags & RR_RELOC_DE ) { printk ( KERN_ERR ""ISOFS:<S2SV_blank>Recursive<S2SV_blank>directory<S2SV_blank>relocation<S2SV_blank>"" ""is<S2SV_blank>not<S2SV_blank>supported\\n"" ) ; goto eio ; } reloc_block = isonum_733 ( rr -> u . CL . location ) ; if ( reloc_block == <S2SV_ModStart> inode ) -> i_iget5_block && ISOFS_I ( inode ) -> i_iget5_offset == 0 ) { printk ( KERN_ERR ""ISOFS:<S2SV_blank>Directory<S2SV_blank>relocation<S2SV_blank>points<S2SV_blank>to<S2SV_blank>"" ""itself\\n"" ) ; goto eio ; } ISOFS_I ( inode ) -> i_first_extent = reloc_block <S2SV_ModEnd> ; reloc = <S2SV_ModStart> ; reloc = isofs_iget_reloc <S2SV_ModEnd> ( inode -> <S2SV_ModStart> -> i_sb , reloc_block , <S2SV_ModEnd> 0 ) ;"
649,"static enum hrtimer_restart perf_swevent_hrtimer ( struct hrtimer * hrtimer ) { enum hrtimer_restart ret = HRTIMER_RESTART ; struct perf_sample_data data ; struct pt_regs * regs ; struct perf_event * event ; u64 period ; event = container_of ( hrtimer , struct perf_event , hw . hrtimer ) ; if ( event -> state != PERF_EVENT_STATE_ACTIVE ) return HRTIMER_NORESTART ; event -> pmu -> read ( event ) ; perf_sample_data_init ( & data , 0 ) ; data . period = event -> hw . last_period ; regs = get_irq_regs ( ) ; if ( regs && ! perf_exclude_event ( event , regs ) ) { if ( ! ( event -> attr . exclude_idle && current -> pid == 0 ) ) <S2SV_StartBug> if ( perf_event_overflow ( event , 0 , & data , regs ) ) <S2SV_EndBug> ret = HRTIMER_NORESTART ; } period = max_t ( u64 , 10000 , event -> hw . sample_period ) ; hrtimer_forward_now ( hrtimer , ns_to_ktime ( period ) ) ; return ret ; }","( event , <S2SV_ModEnd> & data ,"
650,"static int persistent_prepare_exception ( struct dm_exception_store * store , struct dm_exception * e ) { <S2SV_StartBug> struct pstore * ps = get_info ( store ) ; <S2SV_EndBug> uint32_t stride ; chunk_t next_free ; sector_t size = get_dev_size ( dm_snap_cow ( store -> snap ) -> bdev ) ; if ( size < ( ( ps -> next_free + 1 ) * store -> chunk_size ) ) return - ENOSPC ; e -> new_chunk = ps -> next_free ; <S2SV_StartBug> stride = ( ps -> exceptions_per_area + 1 ) ; <S2SV_EndBug> next_free = ++ ps -> next_free ; if ( sector_div ( next_free , stride ) == 1 ) <S2SV_StartBug> ps -> next_free ++ ; <S2SV_EndBug> atomic_inc ( & ps -> pending_count ) ; return 0 ; }",( store ) <S2SV_ModEnd> ; sector_t size <S2SV_ModStart> -> next_free ; <S2SV_ModEnd> ps -> next_free <S2SV_ModStart> -> next_free ++ ; skip_metadata ( ps )
651,"static int htc_setup_complete ( struct htc_target * target ) { struct sk_buff * skb ; struct htc_comp_msg * comp_msg ; int ret = 0 ; unsigned long time_left ; skb = alloc_skb ( 50 + sizeof ( struct htc_frame_hdr ) , GFP_ATOMIC ) ; if ( ! skb ) { dev_err ( target -> dev , ""failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>send<S2SV_blank>buffer\\n"" ) ; return - ENOMEM ; } skb_reserve ( skb , sizeof ( struct htc_frame_hdr ) ) ; comp_msg = skb_put ( skb , sizeof ( struct htc_comp_msg ) ) ; comp_msg -> msg_id = cpu_to_be16 ( HTC_MSG_SETUP_COMPLETE_ID ) ; target -> htc_flags |= HTC_OP_START_WAIT ; ret = htc_issue_send ( target , skb , skb -> len , 0 , ENDPOINT0 ) ; if ( ret ) goto err ; time_left = wait_for_completion_timeout ( & target -> cmd_wait , HZ ) ; if ( ! time_left ) { dev_err ( target -> dev , ""HTC<S2SV_blank>start<S2SV_blank>timeout\\n"" ) ; <S2SV_StartBug> return - ETIMEDOUT ; <S2SV_EndBug> } return 0 ; err : kfree_skb ( skb ) ; return - EINVAL ; }","""HTC<S2SV_blank>start<S2SV_blank>timeout\\n"" ) ; kfree_skb ( skb ) ;"
652,"u_int ieee802_15_4_if_print ( netdissect_options * ndo , const struct pcap_pkthdr * h , const u_char * p ) { u_int caplen = h -> caplen ; u_int hdrlen ; uint16_t fc ; uint8_t seq ; uint16_t panid = 0 ; if ( caplen < 3 ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return caplen ; } hdrlen = 3 ; fc = EXTRACT_LE_16BITS ( p ) ; seq = EXTRACT_LE_8BITS ( p + 2 ) ; p += 3 ; caplen -= 3 ; ND_PRINT ( ( ndo , ""IEEE<S2SV_blank>802.15.4<S2SV_blank>%s<S2SV_blank>packet<S2SV_blank>"" , ftypes [ FC_FRAME_TYPE ( fc ) ] ) ) ; if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""seq<S2SV_blank>%02x<S2SV_blank>"" , seq ) ) ; switch ( FC_DEST_ADDRESSING_MODE ( fc ) ) { case FC_ADDRESSING_MODE_NONE : if ( fc & FC_PAN_ID_COMPRESSION ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return hdrlen ; } if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""none<S2SV_blank>"" ) ) ; break ; case FC_ADDRESSING_MODE_RESERVED : if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""reserved<S2SV_blank>destination<S2SV_blank>addressing<S2SV_blank>mode"" ) ) ; return hdrlen ; case FC_ADDRESSING_MODE_SHORT : if ( caplen < 2 ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return hdrlen ; } panid = EXTRACT_LE_16BITS ( p ) ; p += 2 ; caplen -= 2 ; hdrlen += 2 ; if ( caplen < 2 ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return hdrlen ; } if ( ndo -> ndo_vflag ) <S2SV_StartBug> ND_PRINT ( ( ndo , ""%04x:%04x<S2SV_blank>"" , panid , EXTRACT_LE_16BITS ( p + 2 ) ) ) ; <S2SV_EndBug> p += 2 ; caplen -= 2 ; hdrlen += 2 ; break ; case FC_ADDRESSING_MODE_LONG : if ( caplen < 2 ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return hdrlen ; } panid = EXTRACT_LE_16BITS ( p ) ; p += 2 ; caplen -= 2 ; hdrlen += 2 ; if ( caplen < 8 ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return hdrlen ; } if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""%04x:%s<S2SV_blank>"" , panid , le64addr_string ( ndo , p ) ) ) ; p += 8 ; caplen -= 8 ; hdrlen += 8 ; break ; } if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""<<S2SV_blank>"" ) ) ; switch ( FC_SRC_ADDRESSING_MODE ( fc ) ) { case FC_ADDRESSING_MODE_NONE : if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""none<S2SV_blank>"" ) ) ; break ; case FC_ADDRESSING_MODE_RESERVED : if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""reserved<S2SV_blank>source<S2SV_blank>addressing<S2SV_blank>mode"" ) ) ; return 0 ; case FC_ADDRESSING_MODE_SHORT : if ( ! ( fc & FC_PAN_ID_COMPRESSION ) ) { if ( caplen < 2 ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return hdrlen ; } panid = EXTRACT_LE_16BITS ( p ) ; p += 2 ; caplen -= 2 ; hdrlen += 2 ; } if ( caplen < 2 ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return hdrlen ; } if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""%04x:%04x<S2SV_blank>"" , panid , EXTRACT_LE_16BITS ( p ) ) ) ; p += 2 ; caplen -= 2 ; hdrlen += 2 ; break ; case FC_ADDRESSING_MODE_LONG : if ( ! ( fc & FC_PAN_ID_COMPRESSION ) ) { if ( caplen < 2 ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return hdrlen ; } panid = EXTRACT_LE_16BITS ( p ) ; p += 2 ; caplen -= 2 ; hdrlen += 2 ; } if ( caplen < 8 ) { ND_PRINT ( ( ndo , ""[|802.15.4]"" ) ) ; return hdrlen ; } if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""%04x:%s<S2SV_blank>"" , panid , le64addr_string ( ndo , p ) ) ) ; p += 8 ; caplen -= 8 ; hdrlen += 8 ; break ; } if ( ! ndo -> ndo_suppress_default_print ) ND_DEFAULTPRINT ( p , caplen ) ; return hdrlen ; }",EXTRACT_LE_16BITS ( p <S2SV_ModEnd> ) ) )
653,"stmt_ty AsyncFunctionDef ( identifier name , arguments_ty args , asdl_seq * body , asdl_seq <S2SV_StartBug> * decorator_list , expr_ty returns , int lineno , int col_offset , <S2SV_EndBug> int end_lineno , int end_col_offset , PyArena * arena ) { stmt_ty p ; if ( ! name ) { PyErr_SetString ( PyExc_ValueError , ""field<S2SV_blank>name<S2SV_blank>is<S2SV_blank>required<S2SV_blank>for<S2SV_blank>AsyncFunctionDef"" ) ; return NULL ; } if ( ! args ) { PyErr_SetString ( PyExc_ValueError , ""field<S2SV_blank>args<S2SV_blank>is<S2SV_blank>required<S2SV_blank>for<S2SV_blank>AsyncFunctionDef"" ) ; return NULL ; } p = ( stmt_ty ) PyArena_Malloc ( arena , sizeof ( * p ) ) ; if ( ! p ) return NULL ; p -> kind = AsyncFunctionDef_kind ; p -> v . AsyncFunctionDef . name = name ; p -> v . AsyncFunctionDef . args = args ; p -> v . AsyncFunctionDef . body = body ; p -> v . AsyncFunctionDef . decorator_list = decorator_list ; <S2SV_StartBug> p -> v . AsyncFunctionDef . returns = returns ; <S2SV_EndBug> p -> lineno = lineno ; p -> col_offset = col_offset ; p -> end_lineno = end_lineno ; p -> end_col_offset = end_col_offset ; return p ; }","expr_ty returns , string type_comment , int <S2SV_ModEnd> lineno , int <S2SV_ModStart> returns = returns ; p -> v . AsyncFunctionDef . type_comment = type_comment"
654,static void dtls1_clear_queues ( SSL * s ) { pitem * item = NULL ; hm_fragment * frag = NULL ; DTLS1_RECORD_DATA * rdata ; while ( ( item = pqueue_pop ( s -> d1 -> unprocessed_rcds . q ) ) != NULL ) { rdata = ( DTLS1_RECORD_DATA * ) item -> data ; if ( rdata -> rbuf . buf ) { OPENSSL_free ( rdata -> rbuf . buf ) ; } OPENSSL_free ( item -> data ) ; pitem_free ( item ) ; } while ( ( item = pqueue_pop ( s -> d1 -> processed_rcds . q ) ) != NULL ) { rdata = ( DTLS1_RECORD_DATA * ) item -> data ; if ( rdata -> rbuf . buf ) { OPENSSL_free ( rdata -> rbuf . buf ) ; } OPENSSL_free ( item -> data ) ; pitem_free ( item ) ; } while ( ( item = pqueue_pop ( s -> d1 -> buffered_messages ) ) != NULL ) { frag = ( hm_fragment * ) item -> data ; OPENSSL_free ( frag -> fragment ) ; OPENSSL_free ( frag ) ; pitem_free ( item ) ; } while ( ( item = pqueue_pop ( s -> d1 -> sent_messages ) ) != NULL ) { frag = ( hm_fragment * ) item -> data ; OPENSSL_free ( frag -> fragment ) ; OPENSSL_free ( frag ) ; pitem_free ( item ) ; } while ( ( item = pqueue_pop ( s -> d1 -> buffered_app_data . q ) ) != NULL ) { <S2SV_StartBug> frag = ( hm_fragment * ) item -> data ; <S2SV_EndBug> OPENSSL_free ( frag -> fragment ) ; OPENSSL_free ( frag ) ; pitem_free ( item ) ; } },NULL ) { rdata = ( DTLS1_RECORD_DATA * ) item -> data ; if ( rdata -> rbuf . buf ) { OPENSSL_free ( rdata -> rbuf . buf ) ; } OPENSSL_free ( item -> data <S2SV_ModEnd> ) ; pitem_free
655,"static int asn1_decode_entry ( sc_context_t * ctx , struct sc_asn1_entry * entry , const u8 * obj , size_t objlen , int depth ) { void * parm = entry -> parm ; int ( * callback_func ) ( sc_context_t * nctx , void * arg , const u8 * nobj , size_t nobjlen , int ndepth ) ; size_t * len = ( size_t * ) entry -> arg ; int r = 0 ; callback_func = parm ; sc_debug ( ctx , SC_LOG_DEBUG_ASN1 , ""%*.*sdecoding<S2SV_blank>\'%s\',<S2SV_blank>raw<S2SV_blank>data:%s%s\\n"" , depth , depth , """" , entry -> name , sc_dump_hex ( obj , objlen > 16 ? 16 : objlen ) , objlen > 16 ? ""..."" : """" ) ; switch ( entry -> type ) { case SC_ASN1_STRUCT : if ( parm != NULL ) r = asn1_decode ( ctx , ( struct sc_asn1_entry * ) parm , obj , objlen , NULL , NULL , 0 , depth + 1 ) ; break ; case SC_ASN1_NULL : break ; case SC_ASN1_BOOLEAN : if ( parm != NULL ) { if ( objlen != 1 ) { sc_debug ( ctx , SC_LOG_DEBUG_ASN1 , ""invalid<S2SV_blank>ASN.1<S2SV_blank>object<S2SV_blank>length:<S2SV_blank>%"" SC_FORMAT_LEN_SIZE_T ""u\\n"" , objlen ) ; r = SC_ERROR_INVALID_ASN1_OBJECT ; } else * ( ( int * ) parm ) = obj [ 0 ] ? 1 : 0 ; } break ; case SC_ASN1_INTEGER : case SC_ASN1_ENUMERATED : if ( parm != NULL ) { r = sc_asn1_decode_integer ( obj , objlen , ( int * ) entry -> parm ) ; sc_debug ( ctx , SC_LOG_DEBUG_ASN1 , ""%*.*sdecoding<S2SV_blank>\'%s\'<S2SV_blank>returned<S2SV_blank>%d\\n"" , depth , depth , """" , entry -> name , * ( ( int * ) entry -> parm ) ) ; } break ; case SC_ASN1_BIT_STRING_NI : case SC_ASN1_BIT_STRING : if ( parm != NULL ) { int invert = entry -> type == SC_ASN1_BIT_STRING ? 1 : 0 ; assert ( len != NULL ) ; if ( objlen < 1 ) { r = SC_ERROR_INVALID_ASN1_OBJECT ; break ; } if ( entry -> flags & SC_ASN1_ALLOC ) { u8 * * buf = ( u8 * * ) parm ; * buf = malloc ( objlen - 1 ) ; if ( * buf == NULL ) { r = SC_ERROR_OUT_OF_MEMORY ; break ; } * len = objlen - 1 ; parm = * buf ; } r = decode_bit_string ( obj , objlen , ( u8 * ) parm , * len , invert ) ; if ( r >= 0 ) { * len = r ; r = 0 ; } } break ; case SC_ASN1_BIT_FIELD : if ( parm != NULL ) r = decode_bit_field ( obj , objlen , ( u8 * ) parm , * len ) ; break ; case SC_ASN1_OCTET_STRING : if ( parm != NULL ) { size_t c ; assert ( len != NULL ) ; if ( ( entry -> flags & SC_ASN1_UNSIGNED ) <S2SV_StartBug> && obj [ 0 ] == 0x00 && objlen > 1 ) { <S2SV_EndBug> objlen -- ; obj ++ ; } if ( entry -> flags & SC_ASN1_ALLOC ) { u8 * * buf = ( u8 * * ) parm ; * buf = malloc ( objlen ) ; if ( * buf == NULL ) { r = SC_ERROR_OUT_OF_MEMORY ; break ; } c = * len = objlen ; parm = * buf ; } else c = objlen > * len ? * len : objlen ; memcpy ( parm , obj , c ) ; * len = c ; } break ; case SC_ASN1_GENERALIZEDTIME : if ( parm != NULL ) { size_t c ; assert ( len != NULL ) ; if ( entry -> flags & SC_ASN1_ALLOC ) { u8 * * buf = ( u8 * * ) parm ; * buf = malloc ( objlen ) ; if ( * buf == NULL ) { r = SC_ERROR_OUT_OF_MEMORY ; break ; } c = * len = objlen ; parm = * buf ; } else c = objlen > * len ? * len : objlen ; memcpy ( parm , obj , c ) ; * len = c ; } break ; case SC_ASN1_OBJECT : if ( parm != NULL ) r = sc_asn1_decode_object_id ( obj , objlen , ( struct sc_object_id * ) parm ) ; break ; case SC_ASN1_PRINTABLESTRING : case SC_ASN1_UTF8STRING : if ( parm != NULL ) { assert ( len != NULL ) ; if ( entry -> flags & SC_ASN1_ALLOC ) { u8 * * buf = ( u8 * * ) parm ; * buf = malloc ( objlen + 1 ) ; if ( * buf == NULL ) { r = SC_ERROR_OUT_OF_MEMORY ; break ; } * len = objlen + 1 ; parm = * buf ; } r = sc_asn1_decode_utf8string ( obj , objlen , ( u8 * ) parm , len ) ; if ( entry -> flags & SC_ASN1_ALLOC ) { * len -= 1 ; } } break ; case SC_ASN1_PATH : if ( entry -> parm != NULL ) r = asn1_decode_path ( ctx , obj , objlen , ( sc_path_t * ) parm , depth ) ; break ; case SC_ASN1_PKCS15_ID : if ( entry -> parm != NULL ) { struct sc_pkcs15_id * id = ( struct sc_pkcs15_id * ) parm ; size_t c = objlen > sizeof ( id -> value ) ? sizeof ( id -> value ) : objlen ; memcpy ( id -> value , obj , c ) ; id -> len = c ; } break ; case SC_ASN1_PKCS15_OBJECT : if ( entry -> parm != NULL ) r = asn1_decode_p15_object ( ctx , obj , objlen , ( struct sc_asn1_pkcs15_object * ) parm , depth ) ; break ; case SC_ASN1_ALGORITHM_ID : if ( entry -> parm != NULL ) r = sc_asn1_decode_algorithm_id ( ctx , obj , objlen , ( struct sc_algorithm_id * ) parm , depth ) ; break ; case SC_ASN1_SE_INFO : if ( entry -> parm != NULL ) r = asn1_decode_se_info ( ctx , obj , objlen , ( sc_pkcs15_sec_env_info_t * * * ) entry -> parm , len , depth ) ; break ; case SC_ASN1_CALLBACK : if ( entry -> parm != NULL ) r = callback_func ( ctx , entry -> arg , obj , objlen , depth ) ; break ; default : sc_debug ( ctx , SC_LOG_DEBUG_ASN1 , ""invalid<S2SV_blank>ASN.1<S2SV_blank>type:<S2SV_blank>%d\\n"" , entry -> type ) ; return SC_ERROR_INVALID_ASN1_OBJECT ; } if ( r ) { sc_debug ( ctx , SC_LOG_DEBUG_ASN1 , ""decoding<S2SV_blank>of<S2SV_blank>ASN.1<S2SV_blank>object<S2SV_blank>\'%s\'<S2SV_blank>failed:<S2SV_blank>%s\\n"" , entry -> name , sc_strerror ( r ) ) ; return r ; } entry -> flags |= SC_ASN1_PRESENT ; return 0 ; }",SC_ASN1_UNSIGNED ) && objlen > 1 && <S2SV_ModStart> ] == 0x00 <S2SV_ModEnd> ) { objlen
656,"static int do_video_set_spu_palette ( unsigned int fd , unsigned int cmd , struct compat_video_spu_palette __user * up ) { struct video_spu_palette __user * up_native ; compat_uptr_t palp ; int length , err ; err = get_user ( palp , & up -> palette ) ; <S2SV_StartBug> err |= get_user ( length , & up -> length ) ; <S2SV_EndBug> up_native = compat_alloc_user_space ( sizeof ( struct video_spu_palette ) ) ; err = put_user ( compat_ptr ( palp ) , & up_native -> palette ) ; err |= put_user ( length , & up_native -> length ) ; if ( err ) return - EFAULT ; err = sys_ioctl ( fd , cmd , ( unsigned long ) up_native ) ; return err ; }",-> length ) ; if ( err ) return - EFAULT
657,"int blk_rq_map_user_iov ( struct request_queue * q , struct request * rq , struct rq_map_data * map_data , const struct iov_iter * iter , gfp_t gfp_mask ) { bool copy = false ; unsigned long align = q -> dma_pad_mask | queue_dma_alignment ( q ) ; struct bio * bio = NULL ; struct iov_iter i ; int ret ; <S2SV_StartBug> if ( map_data ) <S2SV_EndBug> copy = true ; else if ( iov_iter_alignment ( iter ) & align ) copy = true ; else if ( queue_virt_boundary ( q ) ) copy = queue_virt_boundary ( q ) & iov_iter_gap_alignment ( iter ) ; i = * iter ; do { ret = __blk_rq_map_user_iov ( rq , map_data , & i , gfp_mask , copy ) ; if ( ret ) goto unmap_rq ; if ( ! bio ) bio = rq -> bio ; } while ( iov_iter_count ( & i ) ) ; if ( ! bio_flagged ( bio , BIO_USER_MAPPED ) ) rq -> cmd_flags |= REQ_COPY_USER ; return 0 ; unmap_rq : __blk_rq_unmap_user ( bio ) ; <S2SV_StartBug> rq -> bio = NULL ; <S2SV_EndBug> return - EINVAL ; }",; if ( ! iter_is_iovec ( iter ) ) goto fail ; if ( <S2SV_ModStart> bio ) ; fail :
658,"static int do_ipv6_setsockopt ( struct sock * sk , int level , int optname , char __user * optval , unsigned int optlen ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct net * net = sock_net ( sk ) ; int val , valbool ; int retv = - ENOPROTOOPT ; bool needs_rtnl = setsockopt_needs_rtnl ( optname ) ; if ( ! optval ) val = 0 ; else { if ( optlen >= sizeof ( int ) ) { if ( get_user ( val , ( int __user * ) optval ) ) return - EFAULT ; } else val = 0 ; } valbool = ( val != 0 ) ; if ( ip6_mroute_opt ( optname ) ) return ip6_mroute_setsockopt ( sk , optname , optval , optlen ) ; if ( needs_rtnl ) rtnl_lock ( ) ; lock_sock ( sk ) ; switch ( optname ) { case IPV6_ADDRFORM : if ( optlen < sizeof ( int ) ) goto e_inval ; if ( val == PF_INET ) { struct ipv6_txoptions * opt ; struct sk_buff * pktopt ; if ( sk -> sk_type == SOCK_RAW ) break ; if ( sk -> sk_protocol == IPPROTO_UDP || sk -> sk_protocol == IPPROTO_UDPLITE ) { struct udp_sock * up = udp_sk ( sk ) ; if ( up -> pending == AF_INET6 ) { retv = - EBUSY ; break ; } } else if ( sk -> sk_protocol != IPPROTO_TCP ) break ; if ( sk -> sk_state != TCP_ESTABLISHED ) { retv = - ENOTCONN ; break ; } if ( ipv6_only_sock ( sk ) || ! ipv6_addr_v4mapped ( & sk -> sk_v6_daddr ) ) { retv = - EADDRNOTAVAIL ; break ; } fl6_free_socklist ( sk ) ; ipv6_sock_mc_close ( sk ) ; sk_refcnt_debug_dec ( sk ) ; if ( sk -> sk_protocol == IPPROTO_TCP ) { struct inet_connection_sock * icsk = inet_csk ( sk ) ; local_bh_disable ( ) ; sock_prot_inuse_add ( net , sk -> sk_prot , - 1 ) ; sock_prot_inuse_add ( net , & tcp_prot , 1 ) ; local_bh_enable ( ) ; sk -> sk_prot = & tcp_prot ; icsk -> icsk_af_ops = & ipv4_specific ; sk -> sk_socket -> ops = & inet_stream_ops ; sk -> sk_family = PF_INET ; tcp_sync_mss ( sk , icsk -> icsk_pmtu_cookie ) ; } else { struct proto * prot = & udp_prot ; if ( sk -> sk_protocol == IPPROTO_UDPLITE ) prot = & udplite_prot ; local_bh_disable ( ) ; sock_prot_inuse_add ( net , sk -> sk_prot , - 1 ) ; sock_prot_inuse_add ( net , prot , 1 ) ; local_bh_enable ( ) ; sk -> sk_prot = prot ; sk -> sk_socket -> ops = & inet_dgram_ops ; sk -> sk_family = PF_INET ; } <S2SV_StartBug> opt = xchg ( & np -> opt , NULL ) ; <S2SV_EndBug> if ( opt ) <S2SV_StartBug> sock_kfree_s ( sk , opt , opt -> tot_len ) ; <S2SV_EndBug> pktopt = xchg ( & np -> pktoptions , NULL ) ; kfree_skb ( pktopt ) ; sk -> sk_destruct = inet_sock_destruct ; sk_refcnt_debug_inc ( sk ) ; module_put ( THIS_MODULE ) ; retv = 0 ; break ; } goto e_inval ; case IPV6_V6ONLY : if ( optlen < sizeof ( int ) || inet_sk ( sk ) -> inet_num ) goto e_inval ; sk -> sk_ipv6only = valbool ; retv = 0 ; break ; case IPV6_RECVPKTINFO : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> rxopt . bits . rxinfo = valbool ; retv = 0 ; break ; case IPV6_2292PKTINFO : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> rxopt . bits . rxoinfo = valbool ; retv = 0 ; break ; case IPV6_RECVHOPLIMIT : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> rxopt . bits . rxhlim = valbool ; retv = 0 ; break ; case IPV6_2292HOPLIMIT : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> rxopt . bits . rxohlim = valbool ; retv = 0 ; break ; case IPV6_RECVRTHDR : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> rxopt . bits . srcrt = valbool ; retv = 0 ; break ; case IPV6_2292RTHDR : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> rxopt . bits . osrcrt = valbool ; retv = 0 ; break ; case IPV6_RECVHOPOPTS : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> rxopt . bits . hopopts = valbool ; retv = 0 ; break ; case IPV6_2292HOPOPTS : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> rxopt . bits . ohopopts = valbool ; retv = 0 ; break ; case IPV6_RECVDSTOPTS : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> rxopt . bits . dstopts = valbool ; retv = 0 ; break ; case IPV6_2292DSTOPTS : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> rxopt . bits . odstopts = valbool ; retv = 0 ; break ; case IPV6_TCLASS : if ( optlen < sizeof ( int ) ) goto e_inval ; if ( val < - 1 || val > 0xff ) goto e_inval ; if ( val == - 1 ) val = 0 ; np -> tclass = val ; retv = 0 ; break ; case IPV6_RECVTCLASS : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> rxopt . bits . rxtclass = valbool ; retv = 0 ; break ; case IPV6_FLOWINFO : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> rxopt . bits . rxflow = valbool ; retv = 0 ; break ; case IPV6_RECVPATHMTU : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> rxopt . bits . rxpmtu = valbool ; retv = 0 ; break ; case IPV6_TRANSPARENT : if ( valbool && ! ns_capable ( net -> user_ns , CAP_NET_ADMIN ) && ! ns_capable ( net -> user_ns , CAP_NET_RAW ) ) { retv = - EPERM ; break ; } if ( optlen < sizeof ( int ) ) goto e_inval ; inet_sk ( sk ) -> transparent = valbool ; retv = 0 ; break ; case IPV6_RECVORIGDSTADDR : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> rxopt . bits . rxorigdstaddr = valbool ; retv = 0 ; break ; case IPV6_HOPOPTS : case IPV6_RTHDRDSTOPTS : case IPV6_RTHDR : case IPV6_DSTOPTS : { struct ipv6_txoptions * opt ; if ( optlen == 0 ) optval = NULL ; else if ( ! optval ) goto e_inval ; else if ( optlen < sizeof ( struct ipv6_opt_hdr ) || optlen & 0x7 || optlen > 8 * 255 ) goto e_inval ; retv = - EPERM ; if ( optname != IPV6_RTHDR && ! ns_capable ( net -> user_ns , CAP_NET_RAW ) ) break ; <S2SV_StartBug> opt = ipv6_renew_options ( sk , np -> opt , optname , <S2SV_EndBug> ( struct ipv6_opt_hdr __user * ) optval , optlen ) ; if ( IS_ERR ( opt ) ) { retv = PTR_ERR ( opt ) ; break ; } retv = - EINVAL ; if ( optname == IPV6_RTHDR && opt && opt -> srcrt ) { struct ipv6_rt_hdr * rthdr = opt -> srcrt ; switch ( rthdr -> type ) { # if IS_ENABLED ( CONFIG_IPV6_MIP6 ) case IPV6_SRCRT_TYPE_2 : if ( rthdr -> hdrlen != 2 || rthdr -> segments_left != 1 ) goto sticky_done ; break ; # endif default : goto sticky_done ; } } retv = 0 ; opt = ipv6_update_options ( sk , opt ) ; sticky_done : if ( opt ) <S2SV_StartBug> sock_kfree_s ( sk , opt , opt -> tot_len ) ; <S2SV_EndBug> break ; } case IPV6_PKTINFO : { struct in6_pktinfo pkt ; if ( optlen == 0 ) goto e_inval ; else if ( optlen < sizeof ( struct in6_pktinfo ) || ! optval ) goto e_inval ; if ( copy_from_user ( & pkt , optval , sizeof ( struct in6_pktinfo ) ) ) { retv = - EFAULT ; break ; } if ( sk -> sk_bound_dev_if && pkt . ipi6_ifindex != sk -> sk_bound_dev_if ) goto e_inval ; np -> sticky_pktinfo . ipi6_ifindex = pkt . ipi6_ifindex ; np -> sticky_pktinfo . ipi6_addr = pkt . ipi6_addr ; retv = 0 ; break ; } case IPV6_2292PKTOPTIONS : { struct ipv6_txoptions * opt = NULL ; struct msghdr msg ; struct flowi6 fl6 ; int junk ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; if ( optlen == 0 ) goto update ; retv = - EINVAL ; if ( optlen > 64 * 1024 ) break ; opt = sock_kmalloc ( sk , sizeof ( * opt ) + optlen , GFP_KERNEL ) ; retv = - ENOBUFS ; if ( ! opt ) break ; memset ( opt , 0 , sizeof ( * opt ) ) ; <S2SV_StartBug> opt -> tot_len = sizeof ( * opt ) + optlen ; <S2SV_EndBug> retv = - EFAULT ; if ( copy_from_user ( opt + 1 , optval , optlen ) ) goto done ; msg . msg_controllen = optlen ; msg . msg_control = ( void * ) ( opt + 1 ) ; retv = ip6_datagram_send_ctl ( net , sk , & msg , & fl6 , opt , & junk , & junk , & junk ) ; if ( retv ) goto done ; update : retv = 0 ; opt = ipv6_update_options ( sk , opt ) ; done : if ( opt ) <S2SV_StartBug> sock_kfree_s ( sk , opt , opt -> tot_len ) ; <S2SV_EndBug> break ; } case IPV6_UNICAST_HOPS : if ( optlen < sizeof ( int ) ) goto e_inval ; if ( val > 255 || val < - 1 ) goto e_inval ; np -> hop_limit = val ; retv = 0 ; break ; case IPV6_MULTICAST_HOPS : if ( sk -> sk_type == SOCK_STREAM ) break ; if ( optlen < sizeof ( int ) ) goto e_inval ; if ( val > 255 || val < - 1 ) goto e_inval ; np -> mcast_hops = ( val == - 1 ? IPV6_DEFAULT_MCASTHOPS : val ) ; retv = 0 ; break ; case IPV6_MULTICAST_LOOP : if ( optlen < sizeof ( int ) ) goto e_inval ; if ( val != valbool ) goto e_inval ; np -> mc_loop = valbool ; retv = 0 ; break ; case IPV6_UNICAST_IF : { struct net_device * dev = NULL ; int ifindex ; if ( optlen != sizeof ( int ) ) goto e_inval ; ifindex = ( __force int ) ntohl ( ( __force __be32 ) val ) ; if ( ifindex == 0 ) { np -> ucast_oif = 0 ; retv = 0 ; break ; } dev = dev_get_by_index ( net , ifindex ) ; retv = - EADDRNOTAVAIL ; if ( ! dev ) break ; dev_put ( dev ) ; retv = - EINVAL ; if ( sk -> sk_bound_dev_if ) break ; np -> ucast_oif = ifindex ; retv = 0 ; break ; } case IPV6_MULTICAST_IF : if ( sk -> sk_type == SOCK_STREAM ) break ; if ( optlen < sizeof ( int ) ) goto e_inval ; if ( val ) { struct net_device * dev ; if ( sk -> sk_bound_dev_if && sk -> sk_bound_dev_if != val ) goto e_inval ; dev = dev_get_by_index ( net , val ) ; if ( ! dev ) { retv = - ENODEV ; break ; } dev_put ( dev ) ; } np -> mcast_oif = val ; retv = 0 ; break ; case IPV6_ADD_MEMBERSHIP : case IPV6_DROP_MEMBERSHIP : { struct ipv6_mreq mreq ; if ( optlen < sizeof ( struct ipv6_mreq ) ) goto e_inval ; retv = - EPROTO ; if ( inet_sk ( sk ) -> is_icsk ) break ; retv = - EFAULT ; if ( copy_from_user ( & mreq , optval , sizeof ( struct ipv6_mreq ) ) ) break ; if ( optname == IPV6_ADD_MEMBERSHIP ) retv = ipv6_sock_mc_join ( sk , mreq . ipv6mr_ifindex , & mreq . ipv6mr_multiaddr ) ; else retv = ipv6_sock_mc_drop ( sk , mreq . ipv6mr_ifindex , & mreq . ipv6mr_multiaddr ) ; break ; } case IPV6_JOIN_ANYCAST : case IPV6_LEAVE_ANYCAST : { struct ipv6_mreq mreq ; if ( optlen < sizeof ( struct ipv6_mreq ) ) goto e_inval ; retv = - EFAULT ; if ( copy_from_user ( & mreq , optval , sizeof ( struct ipv6_mreq ) ) ) break ; if ( optname == IPV6_JOIN_ANYCAST ) retv = ipv6_sock_ac_join ( sk , mreq . ipv6mr_ifindex , & mreq . ipv6mr_acaddr ) ; else retv = ipv6_sock_ac_drop ( sk , mreq . ipv6mr_ifindex , & mreq . ipv6mr_acaddr ) ; break ; } case MCAST_JOIN_GROUP : case MCAST_LEAVE_GROUP : { struct group_req greq ; struct sockaddr_in6 * psin6 ; if ( optlen < sizeof ( struct group_req ) ) goto e_inval ; retv = - EFAULT ; if ( copy_from_user ( & greq , optval , sizeof ( struct group_req ) ) ) break ; if ( greq . gr_group . ss_family != AF_INET6 ) { retv = - EADDRNOTAVAIL ; break ; } psin6 = ( struct sockaddr_in6 * ) & greq . gr_group ; if ( optname == MCAST_JOIN_GROUP ) retv = ipv6_sock_mc_join ( sk , greq . gr_interface , & psin6 -> sin6_addr ) ; else retv = ipv6_sock_mc_drop ( sk , greq . gr_interface , & psin6 -> sin6_addr ) ; break ; } case MCAST_JOIN_SOURCE_GROUP : case MCAST_LEAVE_SOURCE_GROUP : case MCAST_BLOCK_SOURCE : case MCAST_UNBLOCK_SOURCE : { struct group_source_req greqs ; int omode , add ; if ( optlen < sizeof ( struct group_source_req ) ) goto e_inval ; if ( copy_from_user ( & greqs , optval , sizeof ( greqs ) ) ) { retv = - EFAULT ; break ; } if ( greqs . gsr_group . ss_family != AF_INET6 || greqs . gsr_source . ss_family != AF_INET6 ) { retv = - EADDRNOTAVAIL ; break ; } if ( optname == MCAST_BLOCK_SOURCE ) { omode = MCAST_EXCLUDE ; add = 1 ; } else if ( optname == MCAST_UNBLOCK_SOURCE ) { omode = MCAST_EXCLUDE ; add = 0 ; } else if ( optname == MCAST_JOIN_SOURCE_GROUP ) { struct sockaddr_in6 * psin6 ; psin6 = ( struct sockaddr_in6 * ) & greqs . gsr_group ; retv = ipv6_sock_mc_join ( sk , greqs . gsr_interface , & psin6 -> sin6_addr ) ; if ( retv && retv != - EADDRINUSE ) break ; omode = MCAST_INCLUDE ; add = 1 ; } else { omode = MCAST_INCLUDE ; add = 0 ; } retv = ip6_mc_source ( add , omode , sk , & greqs ) ; break ; } case MCAST_MSFILTER : { struct group_filter * gsf ; if ( optlen < GROUP_FILTER_SIZE ( 0 ) ) goto e_inval ; if ( optlen > sysctl_optmem_max ) { retv = - ENOBUFS ; break ; } gsf = kmalloc ( optlen , GFP_KERNEL ) ; if ( ! gsf ) { retv = - ENOBUFS ; break ; } retv = - EFAULT ; if ( copy_from_user ( gsf , optval , optlen ) ) { kfree ( gsf ) ; break ; } if ( gsf -> gf_numsrc >= 0x1ffffffU || gsf -> gf_numsrc > sysctl_mld_max_msf ) { kfree ( gsf ) ; retv = - ENOBUFS ; break ; } if ( GROUP_FILTER_SIZE ( gsf -> gf_numsrc ) > optlen ) { kfree ( gsf ) ; retv = - EINVAL ; break ; } retv = ip6_mc_msfilter ( sk , gsf ) ; kfree ( gsf ) ; break ; } case IPV6_ROUTER_ALERT : if ( optlen < sizeof ( int ) ) goto e_inval ; retv = ip6_ra_control ( sk , val ) ; break ; case IPV6_MTU_DISCOVER : if ( optlen < sizeof ( int ) ) goto e_inval ; if ( val < IPV6_PMTUDISC_DONT || val > IPV6_PMTUDISC_OMIT ) goto e_inval ; np -> pmtudisc = val ; retv = 0 ; break ; case IPV6_MTU : if ( optlen < sizeof ( int ) ) goto e_inval ; if ( val && val < IPV6_MIN_MTU ) goto e_inval ; np -> frag_size = val ; retv = 0 ; break ; case IPV6_RECVERR : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> recverr = valbool ; if ( ! val ) skb_queue_purge ( & sk -> sk_error_queue ) ; retv = 0 ; break ; case IPV6_FLOWINFO_SEND : if ( optlen < sizeof ( int ) ) goto e_inval ; np -> sndflow = valbool ; retv = 0 ; break ; case IPV6_FLOWLABEL_MGR : retv = ipv6_flowlabel_opt ( sk , optval , optlen ) ; break ; case IPV6_IPSEC_POLICY : case IPV6_XFRM_POLICY : retv = - EPERM ; if ( ! ns_capable ( net -> user_ns , CAP_NET_ADMIN ) ) break ; retv = xfrm_user_policy ( sk , optname , optval , optlen ) ; break ; case IPV6_ADDR_PREFERENCES : { unsigned int pref = 0 ; unsigned int prefmask = ~ 0 ; if ( optlen < sizeof ( int ) ) goto e_inval ; retv = - EINVAL ; switch ( val & ( IPV6_PREFER_SRC_PUBLIC | IPV6_PREFER_SRC_TMP | IPV6_PREFER_SRC_PUBTMP_DEFAULT ) ) { case IPV6_PREFER_SRC_PUBLIC : pref |= IPV6_PREFER_SRC_PUBLIC ; break ; case IPV6_PREFER_SRC_TMP : pref |= IPV6_PREFER_SRC_TMP ; break ; case IPV6_PREFER_SRC_PUBTMP_DEFAULT : break ; case 0 : goto pref_skip_pubtmp ; default : goto e_inval ; } prefmask &= ~ ( IPV6_PREFER_SRC_PUBLIC | IPV6_PREFER_SRC_TMP ) ; pref_skip_pubtmp : switch ( val & ( IPV6_PREFER_SRC_HOME | IPV6_PREFER_SRC_COA ) ) { case IPV6_PREFER_SRC_HOME : break ; case IPV6_PREFER_SRC_COA : pref |= IPV6_PREFER_SRC_COA ; case 0 : goto pref_skip_coa ; default : goto e_inval ; } prefmask &= ~ IPV6_PREFER_SRC_COA ; pref_skip_coa : switch ( val & ( IPV6_PREFER_SRC_CGA | IPV6_PREFER_SRC_NONCGA ) ) { case IPV6_PREFER_SRC_CGA : case IPV6_PREFER_SRC_NONCGA : case 0 : break ; default : goto e_inval ; } np -> srcprefs = ( np -> srcprefs & prefmask ) | pref ; retv = 0 ; break ; } case IPV6_MINHOPCOUNT : if ( optlen < sizeof ( int ) ) goto e_inval ; if ( val < 0 || val > 255 ) goto e_inval ; np -> min_hopcount = val ; retv = 0 ; break ; case IPV6_DONTFRAG : np -> dontfrag = valbool ; retv = 0 ; break ; case IPV6_AUTOFLOWLABEL : np -> autoflowlabel = valbool ; retv = 0 ; break ; } release_sock ( sk ) ; if ( needs_rtnl ) rtnl_unlock ( ) ; return retv ; e_inval : release_sock ( sk ) ; if ( needs_rtnl ) rtnl_unlock ( ) ; return - EINVAL ; }","= xchg ( ( __force struct ipv6_txoptions * * ) <S2SV_ModStart> ( opt ) { atomic_sub ( opt -> tot_len , & sk -> sk_omem_alloc ) ; txopt_put ( opt ) ; } <S2SV_ModEnd> pktopt = xchg <S2SV_ModStart> ; opt = rcu_dereference_protected ( np -> opt , sock_owned_by_user ( sk ) ) ; opt = <S2SV_ModStart> ( sk , <S2SV_ModEnd> opt , optname <S2SV_ModStart> ( opt ) { atomic_sub ( opt -> tot_len , & sk -> sk_omem_alloc ) ; txopt_put ( opt ) ; } <S2SV_ModEnd> break ; } <S2SV_ModStart> ) ) ; atomic_set ( & opt -> refcnt , 1 ) ; <S2SV_ModStart> ( opt ) { atomic_sub ( opt -> tot_len , & sk -> sk_omem_alloc ) ; txopt_put ( opt ) ; } <S2SV_ModEnd> break ; }"
659,"static int nsv_read_chunk ( AVFormatContext * s , int fill_header ) { NSVContext * nsv = s -> priv_data ; AVIOContext * pb = s -> pb ; AVStream * st [ 2 ] = { NULL , NULL } ; NSVStream * nst ; AVPacket * pkt ; int i , err = 0 ; uint8_t auxcount ; uint32_t vsize ; uint16_t asize ; <S2SV_StartBug> uint16_t auxsize ; <S2SV_EndBug> if ( nsv -> ahead [ 0 ] . data || nsv -> ahead [ 1 ] . data ) return 0 ; null_chunk_retry : if ( pb -> eof_reached ) return - 1 ; for ( i = 0 ; i < NSV_MAX_RESYNC_TRIES && nsv -> state < NSV_FOUND_NSVS && ! err ; i ++ ) err = nsv_resync ( s ) ; if ( err < 0 ) return err ; if ( nsv -> state == NSV_FOUND_NSVS ) err = nsv_parse_NSVs_header ( s ) ; if ( err < 0 ) return err ; if ( nsv -> state != NSV_HAS_READ_NSVS && nsv -> state != NSV_FOUND_BEEF ) return - 1 ; auxcount = avio_r8 ( pb ) ; vsize = avio_rl16 ( pb ) ; asize = avio_rl16 ( pb ) ; vsize = ( vsize << 4 ) | ( auxcount >> 4 ) ; auxcount &= 0x0f ; av_log ( s , AV_LOG_TRACE , ""NSV<S2SV_blank>CHUNK<S2SV_blank>%"" PRIu8 ""<S2SV_blank>aux,<S2SV_blank>%"" PRIu32 ""<S2SV_blank>bytes<S2SV_blank>video,<S2SV_blank>%"" PRIu16 ""<S2SV_blank>bytes<S2SV_blank>audio\\n"" , auxcount , vsize , asize ) ; for ( i = 0 ; i < auxcount ; i ++ ) { uint32_t av_unused auxtag ; auxsize = avio_rl16 ( pb ) ; auxtag = avio_rl32 ( pb ) ; avio_skip ( pb , auxsize ) ; vsize -= auxsize + sizeof ( uint16_t ) + sizeof ( uint32_t ) ; } if ( pb -> eof_reached ) return - 1 ; if ( ! vsize && ! asize ) { nsv -> state = NSV_UNSYNC ; goto null_chunk_retry ; } if ( s -> nb_streams > 0 ) st [ s -> streams [ 0 ] -> id ] = s -> streams [ 0 ] ; if ( s -> nb_streams > 1 ) st [ s -> streams [ 1 ] -> id ] = s -> streams [ 1 ] ; if ( vsize && st [ NSV_ST_VIDEO ] ) { nst = st [ NSV_ST_VIDEO ] -> priv_data ; pkt = & nsv -> ahead [ NSV_ST_VIDEO ] ; <S2SV_StartBug> av_get_packet ( pb , pkt , vsize ) ; <S2SV_EndBug> pkt -> stream_index = st [ NSV_ST_VIDEO ] -> index ; pkt -> dts = nst -> frame_offset ; pkt -> flags |= nsv -> state == NSV_HAS_READ_NSVS ? AV_PKT_FLAG_KEY : 0 ; for ( i = 0 ; i < FFMIN ( 8 , vsize ) ; i ++ ) av_log ( s , AV_LOG_TRACE , ""NSV<S2SV_blank>video:<S2SV_blank>[%d]<S2SV_blank>=<S2SV_blank>%02"" PRIx8 ""\\n"" , i , pkt -> data [ i ] ) ; } if ( st [ NSV_ST_VIDEO ] ) ( ( NSVStream * ) st [ NSV_ST_VIDEO ] -> priv_data ) -> frame_offset ++ ; if ( asize && st [ NSV_ST_AUDIO ] ) { nst = st [ NSV_ST_AUDIO ] -> priv_data ; pkt = & nsv -> ahead [ NSV_ST_AUDIO ] ; if ( asize && st [ NSV_ST_AUDIO ] -> codecpar -> codec_tag == MKTAG ( 'P' , 'C' , 'M' , '<S2SV_blank>' ) ) { uint8_t bps ; uint8_t channels ; uint16_t samplerate ; bps = avio_r8 ( pb ) ; channels = avio_r8 ( pb ) ; samplerate = avio_rl16 ( pb ) ; if ( ! channels || ! samplerate ) return AVERROR_INVALIDDATA ; asize -= 4 ; av_log ( s , AV_LOG_TRACE , ""NSV<S2SV_blank>RAWAUDIO:<S2SV_blank>bps<S2SV_blank>%"" PRIu8 "",<S2SV_blank>nchan<S2SV_blank>%"" PRIu8 "",<S2SV_blank>srate<S2SV_blank>%"" PRIu16 ""\\n"" , bps , channels , samplerate ) ; if ( fill_header ) { st [ NSV_ST_AUDIO ] -> need_parsing = AVSTREAM_PARSE_NONE ; if ( bps != 16 ) { av_log ( s , AV_LOG_TRACE , ""NSV<S2SV_blank>AUDIO<S2SV_blank>bit/sample<S2SV_blank>!=<S2SV_blank>16<S2SV_blank>(%"" PRIu8 "")!!!\\n"" , bps ) ; } bps /= channels ; if ( bps == 8 ) st [ NSV_ST_AUDIO ] -> codecpar -> codec_id = AV_CODEC_ID_PCM_U8 ; samplerate /= 4 ; channels = 1 ; st [ NSV_ST_AUDIO ] -> codecpar -> channels = channels ; st [ NSV_ST_AUDIO ] -> codecpar -> sample_rate = samplerate ; av_log ( s , AV_LOG_TRACE , ""NSV<S2SV_blank>RAWAUDIO:<S2SV_blank>bps<S2SV_blank>%"" PRIu8 "",<S2SV_blank>nchan<S2SV_blank>%"" PRIu8 "",<S2SV_blank>srate<S2SV_blank>%"" PRIu16 ""\\n"" , bps , channels , samplerate ) ; } } <S2SV_StartBug> av_get_packet ( pb , pkt , asize ) ; <S2SV_EndBug> pkt -> stream_index = st [ NSV_ST_AUDIO ] -> index ; pkt -> flags |= nsv -> state == NSV_HAS_READ_NSVS ? AV_PKT_FLAG_KEY : 0 ; if ( nsv -> state == NSV_HAS_READ_NSVS && st [ NSV_ST_VIDEO ] ) { pkt -> dts = ( ( ( NSVStream * ) st [ NSV_ST_VIDEO ] -> priv_data ) -> frame_offset - 1 ) ; pkt -> dts *= ( int64_t ) 1000 * nsv -> framerate . den ; pkt -> dts += ( int64_t ) nsv -> avsync * nsv -> framerate . num ; av_log ( s , AV_LOG_TRACE , ""NSV<S2SV_blank>AUDIO:<S2SV_blank>sync:%"" PRId16 "",<S2SV_blank>dts:%"" PRId64 , nsv -> avsync , pkt -> dts ) ; } nst -> frame_offset ++ ; } nsv -> state = NSV_UNSYNC ; return 0 ; }","; uint16_t auxsize ; int ret <S2SV_ModStart> NSV_ST_VIDEO ] ; if ( ( ret = <S2SV_ModStart> , vsize ) ) < 0 ) return ret <S2SV_ModStart> ; } } if ( ( ret = <S2SV_ModStart> , asize ) ) < 0 ) return ret"
660,"static RList * r_bin_wasm_get_global_entries ( RBinWasmObj * bin , RBinWasmSection * sec ) { RList * ret = NULL ; RBinWasmGlobalEntry * ptr = NULL ; <S2SV_StartBug> int buflen = bin -> buf -> length ; <S2SV_EndBug> if ( sec -> payload_data + 32 > buflen ) { return NULL ; } if ( ! ( ret = r_list_newf ( ( RListFree ) free ) ) ) { return NULL ; } ut8 * buf = bin -> buf -> buf + ( ut32 ) sec -> payload_data ; ut32 len = sec -> payload_len ; ut32 count = sec -> count ; ut32 i = 0 , r = 0 ; while ( i < len && len < buflen && r < count ) { if ( ! ( ptr = R_NEW0 ( RBinWasmGlobalEntry ) ) ) { return ret ; } if ( len + 8 > buflen || ! ( consume_u8 ( buf + i , buf + len , ( ut8 * ) & ptr -> content_type , & i ) ) ) { goto beach ; } if ( len + 8 > buflen || ! ( consume_u8 ( buf + i , buf + len , & ptr -> mutability , & i ) ) ) { goto beach ; } if ( len + 8 > buflen || ! ( consume_init_expr ( buf + i , buf + len , R_BIN_WASM_END_OF_CODE , NULL , & i ) ) ) { goto beach ; } r_list_append ( ret , ptr ) ; r ++ ; } return ret ; beach : free ( ptr ) ; return ret ; }",= NULL ; if ( ! ( ret = r_list_newf ( ( RListFree ) free ) ) ) { return NULL ; } ut8 * buf = bin -> buf -> buf + ( ut32 ) sec -> payload_data ; <S2SV_ModStart> buf -> length - <S2SV_ModEnd> ( ut32 )
661,"static int decode_slice_header ( H264Context * h , H264Context * h0 ) { unsigned int first_mb_in_slice ; unsigned int pps_id ; int ret ; unsigned int slice_type , tmp , i , j ; int last_pic_structure , last_pic_droppable ; int must_reinit ; int needs_reinit = 0 ; int field_pic_flag , bottom_field_flag ; h -> me . qpel_put = h -> h264qpel . put_h264_qpel_pixels_tab ; h -> me . qpel_avg = h -> h264qpel . avg_h264_qpel_pixels_tab ; first_mb_in_slice = get_ue_golomb_long ( & h -> gb ) ; if ( first_mb_in_slice == 0 ) { if ( h0 -> current_slice && FIELD_PICTURE ( h ) ) { field_end ( h , 1 ) ; } h0 -> current_slice = 0 ; if ( ! h0 -> first_field ) { if ( h -> cur_pic_ptr && ! h -> droppable ) { ff_thread_report_progress ( & h -> cur_pic_ptr -> tf , INT_MAX , h -> picture_structure == PICT_BOTTOM_FIELD ) ; } h -> cur_pic_ptr = NULL ; } } slice_type = get_ue_golomb_31 ( & h -> gb ) ; if ( slice_type > 9 ) { av_log ( h -> avctx , AV_LOG_ERROR , ""slice<S2SV_blank>type<S2SV_blank>too<S2SV_blank>large<S2SV_blank>(%d)<S2SV_blank>at<S2SV_blank>%d<S2SV_blank>%d\\n"" , slice_type , h -> mb_x , h -> mb_y ) ; return AVERROR_INVALIDDATA ; } if ( slice_type > 4 ) { slice_type -= 5 ; h -> slice_type_fixed = 1 ; } else h -> slice_type_fixed = 0 ; slice_type = golomb_to_pict_type [ slice_type ] ; h -> slice_type = slice_type ; h -> slice_type_nos = slice_type & 3 ; h -> pict_type = h -> slice_type ; pps_id = get_ue_golomb ( & h -> gb ) ; if ( pps_id >= MAX_PPS_COUNT ) { av_log ( h -> avctx , AV_LOG_ERROR , ""pps_id<S2SV_blank>%d<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range\\n"" , pps_id ) ; return AVERROR_INVALIDDATA ; } if ( ! h0 -> pps_buffers [ pps_id ] ) { av_log ( h -> avctx , AV_LOG_ERROR , ""non-existing<S2SV_blank>PPS<S2SV_blank>%u<S2SV_blank>referenced\\n"" , pps_id ) ; return AVERROR_INVALIDDATA ; } h -> pps = * h0 -> pps_buffers [ pps_id ] ; if ( ! h0 -> sps_buffers [ h -> pps . sps_id ] ) { av_log ( h -> avctx , AV_LOG_ERROR , ""non-existing<S2SV_blank>SPS<S2SV_blank>%u<S2SV_blank>referenced\\n"" , h -> pps . sps_id ) ; return AVERROR_INVALIDDATA ; } if ( h -> pps . sps_id != h -> current_sps_id || h0 -> sps_buffers [ h -> pps . sps_id ] -> new ) { h0 -> sps_buffers [ h -> pps . sps_id ] -> new = 0 ; h -> current_sps_id = h -> pps . sps_id ; h -> sps = * h0 -> sps_buffers [ h -> pps . sps_id ] ; if ( h -> mb_width != h -> sps . mb_width || h -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) || h -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc ) needs_reinit = 1 ; if ( h -> bit_depth_luma != h -> sps . bit_depth_luma || h -> chroma_format_idc != h -> sps . chroma_format_idc ) { h -> bit_depth_luma = h -> sps . bit_depth_luma ; h -> chroma_format_idc = h -> sps . chroma_format_idc ; needs_reinit = 1 ; } if ( ( ret = h264_set_parameter_from_sps ( h ) ) < 0 ) return ret ; } h -> avctx -> profile = ff_h264_get_profile ( & h -> sps ) ; h -> avctx -> level = h -> sps . level_idc ; h -> avctx -> refs = h -> sps . ref_frame_count ; must_reinit = ( h -> context_initialized && ( 16 * h -> sps . mb_width != h -> avctx -> coded_width || 16 * h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) != h -> avctx -> coded_height || h -> avctx -> bits_per_raw_sample != h -> sps . bit_depth_luma || h -> cur_chroma_format_idc != h -> sps . chroma_format_idc || av_cmp_q ( h -> sps . sar , h -> avctx -> sample_aspect_ratio ) || h -> mb_width != h -> sps . mb_width || h -> mb_height != h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) ) ) ; if ( h0 -> avctx -> pix_fmt != get_pixel_format ( h0 , 0 ) ) must_reinit = 1 ; h -> mb_width = h -> sps . mb_width ; h -> mb_height = h -> sps . mb_height * ( 2 - h -> sps . frame_mbs_only_flag ) ; h -> mb_num = h -> mb_width * h -> mb_height ; h -> mb_stride = h -> mb_width + 1 ; h -> b_stride = h -> mb_width * 4 ; h -> chroma_y_shift = h -> sps . chroma_format_idc <= 1 ; h -> width = 16 * h -> mb_width ; h -> height = 16 * h -> mb_height ; ret = init_dimensions ( h ) ; if ( ret < 0 ) return ret ; if ( h -> sps . video_signal_type_present_flag ) { h -> avctx -> color_range = h -> sps . full_range > 0 ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG ; if ( h -> sps . colour_description_present_flag ) { if ( h -> avctx -> colorspace != h -> sps . colorspace ) needs_reinit = 1 ; h -> avctx -> color_primaries = h -> sps . color_primaries ; h -> avctx -> color_trc = h -> sps . color_trc ; h -> avctx -> colorspace = h -> sps . colorspace ; } } if ( h -> context_initialized && ( h -> width != h -> avctx -> coded_width || h -> height != h -> avctx -> coded_height || must_reinit || needs_reinit ) ) { if ( h != h0 ) { av_log ( h -> avctx , AV_LOG_ERROR , ""changing<S2SV_blank>width/height<S2SV_blank>on<S2SV_blank>"" ""slice<S2SV_blank>%d\\n"" , h0 -> current_slice + 1 ) ; return AVERROR_INVALIDDATA ; } flush_change ( h ) ; if ( ( ret = get_pixel_format ( h , 1 ) ) < 0 ) return ret ; h -> avctx -> pix_fmt = ret ; av_log ( h -> avctx , AV_LOG_INFO , ""Reinit<S2SV_blank>context<S2SV_blank>to<S2SV_blank>%dx%d,<S2SV_blank>"" ""pix_fmt:<S2SV_blank>%s\\n"" , h -> width , h -> height , av_get_pix_fmt_name ( h -> avctx -> pix_fmt ) ) ; if ( ( ret = h264_slice_header_init ( h , 1 ) ) < 0 ) { av_log ( h -> avctx , AV_LOG_ERROR , ""h264_slice_header_init()<S2SV_blank>failed\\n"" ) ; return ret ; } } if ( ! h -> context_initialized ) { if ( h != h0 ) { av_log ( h -> avctx , AV_LOG_ERROR , ""Cannot<S2SV_blank>(re-)initialize<S2SV_blank>context<S2SV_blank>during<S2SV_blank>parallel<S2SV_blank>decoding.\\n"" ) ; return AVERROR_PATCHWELCOME ; } if ( ( ret = get_pixel_format ( h , 1 ) ) < 0 ) return ret ; h -> avctx -> pix_fmt = ret ; if ( ( ret = h264_slice_header_init ( h , 0 ) ) < 0 ) { av_log ( h -> avctx , AV_LOG_ERROR , ""h264_slice_header_init()<S2SV_blank>failed\\n"" ) ; return ret ; } } if ( h == h0 && h -> dequant_coeff_pps != pps_id ) { h -> dequant_coeff_pps = pps_id ; init_dequant_tables ( h ) ; } h -> frame_num = get_bits ( & h -> gb , h -> sps . log2_max_frame_num ) ; h -> mb_mbaff = 0 ; h -> mb_aff_frame = 0 ; last_pic_structure = h0 -> picture_structure ; last_pic_droppable = h0 -> droppable ; h -> droppable = h -> nal_ref_idc == 0 ; if ( h -> sps . frame_mbs_only_flag ) { h -> picture_structure = PICT_FRAME ; } else { if ( ! h -> sps . direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B ) { av_log ( h -> avctx , AV_LOG_ERROR , ""This<S2SV_blank>stream<S2SV_blank>was<S2SV_blank>generated<S2SV_blank>by<S2SV_blank>a<S2SV_blank>broken<S2SV_blank>encoder,<S2SV_blank>invalid<S2SV_blank>8x8<S2SV_blank>inference\\n"" ) ; return - 1 ; } field_pic_flag = get_bits1 ( & h -> gb ) ; if ( field_pic_flag ) { bottom_field_flag = get_bits1 ( & h -> gb ) ; h -> picture_structure = PICT_TOP_FIELD + bottom_field_flag ; } else { h -> picture_structure = PICT_FRAME ; h -> mb_aff_frame = h -> sps . mb_aff ; } } h -> mb_field_decoding_flag = h -> picture_structure != PICT_FRAME ; if ( h0 -> current_slice != 0 ) { if ( last_pic_structure != h -> picture_structure || last_pic_droppable != h -> droppable ) { av_log ( h -> avctx , AV_LOG_ERROR , ""Changing<S2SV_blank>field<S2SV_blank>mode<S2SV_blank>(%d<S2SV_blank>-><S2SV_blank>%d)<S2SV_blank>between<S2SV_blank>slices<S2SV_blank>is<S2SV_blank>not<S2SV_blank>allowed\\n"" , last_pic_structure , h -> picture_structure ) ; h -> picture_structure = last_pic_structure ; h -> droppable = last_pic_droppable ; return AVERROR_INVALIDDATA ; } else if ( ! h0 -> cur_pic_ptr ) { av_log ( h -> avctx , AV_LOG_ERROR , ""unset<S2SV_blank>cur_pic_ptr<S2SV_blank>on<S2SV_blank>%d.<S2SV_blank>slice\\n"" , h0 -> current_slice + 1 ) ; return AVERROR_INVALIDDATA ; } } else { if ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 ) { int unwrap_prev_frame_num = h -> prev_frame_num ; int max_frame_num = 1 << h -> sps . log2_max_frame_num ; if ( unwrap_prev_frame_num > h -> frame_num ) unwrap_prev_frame_num -= max_frame_num ; if ( ( h -> frame_num - unwrap_prev_frame_num ) > h -> sps . ref_frame_count ) { unwrap_prev_frame_num = ( h -> frame_num - h -> sps . ref_frame_count ) - 1 ; if ( unwrap_prev_frame_num < 0 ) unwrap_prev_frame_num += max_frame_num ; h -> prev_frame_num = unwrap_prev_frame_num ; } } if ( h0 -> first_field ) { assert ( h0 -> cur_pic_ptr ) ; assert ( h0 -> cur_pic_ptr -> f . data [ 0 ] ) ; assert ( h0 -> cur_pic_ptr -> reference != DELAYED_PIC_REF ) ; <S2SV_StartBug> if ( ! last_pic_droppable && h0 -> cur_pic_ptr -> tf . owner == h0 -> avctx ) { <S2SV_EndBug> ff_thread_report_progress ( & h0 -> cur_pic_ptr -> tf , INT_MAX , last_pic_structure == PICT_BOTTOM_FIELD ) ; } if ( ! FIELD_PICTURE ( h ) || h -> picture_structure == last_pic_structure ) { <S2SV_StartBug> if ( ! last_pic_droppable && last_pic_structure != PICT_FRAME ) { <S2SV_EndBug> ff_thread_report_progress ( & h0 -> cur_pic_ptr -> tf , INT_MAX , last_pic_structure == PICT_TOP_FIELD ) ; } } else { if ( h0 -> cur_pic_ptr -> frame_num != h -> frame_num ) { <S2SV_StartBug> if ( ! last_pic_droppable && last_pic_structure != PICT_FRAME ) { <S2SV_EndBug> ff_thread_report_progress ( & h0 -> cur_pic_ptr -> tf , INT_MAX , last_pic_structure == PICT_TOP_FIELD ) ; } } else { if ( ! ( ( last_pic_structure == PICT_TOP_FIELD && h -> picture_structure == PICT_BOTTOM_FIELD ) || ( last_pic_structure == PICT_BOTTOM_FIELD && h -> picture_structure == PICT_TOP_FIELD ) ) ) { av_log ( h -> avctx , AV_LOG_ERROR , ""Invalid<S2SV_blank>field<S2SV_blank>mode<S2SV_blank>combination<S2SV_blank>%d/%d\\n"" , last_pic_structure , h -> picture_structure ) ; h -> picture_structure = last_pic_structure ; h -> droppable = last_pic_droppable ; return AVERROR_INVALIDDATA ; } else if ( last_pic_droppable != h -> droppable ) { avpriv_request_sample ( h -> avctx , ""Found<S2SV_blank>reference<S2SV_blank>and<S2SV_blank>non-reference<S2SV_blank>fields<S2SV_blank>in<S2SV_blank>the<S2SV_blank>same<S2SV_blank>frame,<S2SV_blank>which"" ) ; h -> picture_structure = last_pic_structure ; h -> droppable = last_pic_droppable ; return AVERROR_PATCHWELCOME ; } } } } while ( h -> frame_num != h -> prev_frame_num && h -> prev_frame_num >= 0 && ! h0 -> first_field && h -> frame_num != ( h -> prev_frame_num + 1 ) % ( 1 << h -> sps . log2_max_frame_num ) ) { Picture * prev = h -> short_ref_count ? h -> short_ref [ 0 ] : NULL ; av_log ( h -> avctx , AV_LOG_DEBUG , ""Frame<S2SV_blank>num<S2SV_blank>gap<S2SV_blank>%d<S2SV_blank>%d\\n"" , h -> frame_num , h -> prev_frame_num ) ; if ( ! h -> sps . gaps_in_frame_num_allowed_flag ) for ( i = 0 ; i < FF_ARRAY_ELEMS ( h -> last_pocs ) ; i ++ ) h -> last_pocs [ i ] = INT_MIN ; ret = h264_frame_start ( h ) ; if ( ret < 0 ) return ret ; h -> prev_frame_num ++ ; h -> prev_frame_num %= 1 << h -> sps . log2_max_frame_num ; h -> cur_pic_ptr -> frame_num = h -> prev_frame_num ; ff_thread_report_progress ( & h -> cur_pic_ptr -> tf , INT_MAX , 0 ) ; ff_thread_report_progress ( & h -> cur_pic_ptr -> tf , INT_MAX , 1 ) ; ret = ff_generate_sliding_window_mmcos ( h , 1 ) ; if ( ret < 0 && ( h -> avctx -> err_recognition & AV_EF_EXPLODE ) ) return ret ; ret = ff_h264_execute_ref_pic_marking ( h , h -> mmco , h -> mmco_index ) ; if ( ret < 0 && ( h -> avctx -> err_recognition & AV_EF_EXPLODE ) ) return ret ; if ( h -> short_ref_count ) { if ( prev ) { av_image_copy ( h -> short_ref [ 0 ] -> f . data , h -> short_ref [ 0 ] -> f . linesize , ( const uint8_t * * ) prev -> f . data , prev -> f . linesize , h -> avctx -> pix_fmt , h -> mb_width * 16 , h -> mb_height * 16 ) ; h -> short_ref [ 0 ] -> poc = prev -> poc + 2 ; } h -> short_ref [ 0 ] -> frame_num = h -> prev_frame_num ; } } if ( h0 -> first_field ) { assert ( h0 -> cur_pic_ptr ) ; assert ( h0 -> cur_pic_ptr -> f . data [ 0 ] ) ; assert ( h0 -> cur_pic_ptr -> reference != DELAYED_PIC_REF ) ; if ( ! FIELD_PICTURE ( h ) || h -> picture_structure == last_pic_structure ) { h0 -> cur_pic_ptr = NULL ; h0 -> first_field = FIELD_PICTURE ( h ) ; } else { if ( h0 -> cur_pic_ptr -> frame_num != h -> frame_num ) { ff_thread_report_progress ( & h0 -> cur_pic_ptr -> tf , INT_MAX , h0 -> picture_structure == PICT_BOTTOM_FIELD ) ; h0 -> first_field = 1 ; h0 -> cur_pic_ptr = NULL ; } else { h0 -> first_field = 0 ; } } } else { h0 -> first_field = FIELD_PICTURE ( h ) ; } if ( ! FIELD_PICTURE ( h ) || h0 -> first_field ) { if ( h264_frame_start ( h ) < 0 ) { h0 -> first_field = 0 ; return AVERROR_INVALIDDATA ; } } else { release_unused_pictures ( h , 0 ) ; } if ( FIELD_PICTURE ( h ) ) { for ( i = ( h -> picture_structure == PICT_BOTTOM_FIELD ) ; i < h -> mb_height ; i ++ ) memset ( h -> slice_table + i * h -> mb_stride , - 1 , ( h -> mb_stride - ( i + 1 == h -> mb_height ) ) * sizeof ( * h -> slice_table ) ) ; } else { memset ( h -> slice_table , - 1 , ( h -> mb_height * h -> mb_stride - 1 ) * sizeof ( * h -> slice_table ) ) ; } h0 -> last_slice_type = - 1 ; } if ( h != h0 && ( ret = clone_slice ( h , h0 ) ) < 0 ) return ret ; for ( i = 0 ; i < h -> slice_context_count ; i ++ ) if ( h -> thread_context [ i ] ) { ret = alloc_scratch_buffers ( h -> thread_context [ i ] , h -> linesize ) ; if ( ret < 0 ) return ret ; } h -> cur_pic_ptr -> frame_num = h -> frame_num ; av_assert1 ( h -> mb_num == h -> mb_width * h -> mb_height ) ; if ( first_mb_in_slice << FIELD_OR_MBAFF_PICTURE ( h ) >= h -> mb_num || first_mb_in_slice >= h -> mb_num ) { av_log ( h -> avctx , AV_LOG_ERROR , ""first_mb_in_slice<S2SV_blank>overflow\\n"" ) ; return AVERROR_INVALIDDATA ; } h -> resync_mb_x = h -> mb_x = first_mb_in_slice % h -> mb_width ; h -> resync_mb_y = h -> mb_y = ( first_mb_in_slice / h -> mb_width ) << FIELD_OR_MBAFF_PICTURE ( h ) ; if ( h -> picture_structure == PICT_BOTTOM_FIELD ) h -> resync_mb_y = h -> mb_y = h -> mb_y + 1 ; av_assert1 ( h -> mb_y < h -> mb_height ) ; if ( h -> picture_structure == PICT_FRAME ) { h -> curr_pic_num = h -> frame_num ; h -> max_pic_num = 1 << h -> sps . log2_max_frame_num ; } else { h -> curr_pic_num = 2 * h -> frame_num + 1 ; h -> max_pic_num = 1 << ( h -> sps . log2_max_frame_num + 1 ) ; } if ( h -> nal_unit_type == NAL_IDR_SLICE ) get_ue_golomb ( & h -> gb ) ; if ( h -> sps . poc_type == 0 ) { h -> poc_lsb = get_bits ( & h -> gb , h -> sps . log2_max_poc_lsb ) ; if ( h -> pps . pic_order_present == 1 && h -> picture_structure == PICT_FRAME ) h -> delta_poc_bottom = get_se_golomb ( & h -> gb ) ; } if ( h -> sps . poc_type == 1 && ! h -> sps . delta_pic_order_always_zero_flag ) { h -> delta_poc [ 0 ] = get_se_golomb ( & h -> gb ) ; if ( h -> pps . pic_order_present == 1 && h -> picture_structure == PICT_FRAME ) h -> delta_poc [ 1 ] = get_se_golomb ( & h -> gb ) ; } ff_init_poc ( h , h -> cur_pic_ptr -> field_poc , & h -> cur_pic_ptr -> poc ) ; if ( h -> pps . redundant_pic_cnt_present ) h -> redundant_pic_count = get_ue_golomb ( & h -> gb ) ; ret = ff_set_ref_count ( h ) ; if ( ret < 0 ) return ret ; if ( slice_type != AV_PICTURE_TYPE_I && ( h0 -> current_slice == 0 || slice_type != h0 -> last_slice_type || memcmp ( h0 -> last_ref_count , h0 -> ref_count , sizeof ( h0 -> ref_count ) ) ) ) { ff_h264_fill_default_ref_list ( h ) ; } if ( h -> slice_type_nos != AV_PICTURE_TYPE_I ) { ret = ff_h264_decode_ref_pic_list_reordering ( h ) ; if ( ret < 0 ) { h -> ref_count [ 1 ] = h -> ref_count [ 0 ] = 0 ; return ret ; } } if ( ( h -> pps . weighted_pred && h -> slice_type_nos == AV_PICTURE_TYPE_P ) || ( h -> pps . weighted_bipred_idc == 1 && h -> slice_type_nos == AV_PICTURE_TYPE_B ) ) ff_pred_weight_table ( h ) ; else if ( h -> pps . weighted_bipred_idc == 2 && h -> slice_type_nos == AV_PICTURE_TYPE_B ) { implicit_weight_table ( h , - 1 ) ; } else { h -> use_weight = 0 ; for ( i = 0 ; i < 2 ; i ++ ) { h -> luma_weight_flag [ i ] = 0 ; h -> chroma_weight_flag [ i ] = 0 ; } } if ( h -> nal_ref_idc ) { ret = ff_h264_decode_ref_pic_marking ( h0 , & h -> gb , ! ( h -> avctx -> active_thread_type & FF_THREAD_FRAME ) || h0 -> current_slice == 0 ) ; if ( ret < 0 && ( h -> avctx -> err_recognition & AV_EF_EXPLODE ) ) return AVERROR_INVALIDDATA ; } if ( FRAME_MBAFF ( h ) ) { ff_h264_fill_mbaff_ref_list ( h ) ; if ( h -> pps . weighted_bipred_idc == 2 && h -> slice_type_nos == AV_PICTURE_TYPE_B ) { implicit_weight_table ( h , 0 ) ; implicit_weight_table ( h , 1 ) ; } } if ( h -> slice_type_nos == AV_PICTURE_TYPE_B && ! h -> direct_spatial_mv_pred ) ff_h264_direct_dist_scale_factor ( h ) ; ff_h264_direct_ref_list_init ( h ) ; if ( h -> slice_type_nos != AV_PICTURE_TYPE_I && h -> pps . cabac ) { tmp = get_ue_golomb_31 ( & h -> gb ) ; if ( tmp > 2 ) { av_log ( h -> avctx , AV_LOG_ERROR , ""cabac_init_idc<S2SV_blank>overflow\\n"" ) ; return AVERROR_INVALIDDATA ; } h -> cabac_init_idc = tmp ; } h -> last_qscale_diff = 0 ; tmp = h -> pps . init_qp + get_se_golomb ( & h -> gb ) ; if ( tmp > 51 + 6 * ( h -> sps . bit_depth_luma - 8 ) ) { av_log ( h -> avctx , AV_LOG_ERROR , ""QP<S2SV_blank>%u<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range\\n"" , tmp ) ; return AVERROR_INVALIDDATA ; } h -> qscale = tmp ; h -> chroma_qp [ 0 ] = get_chroma_qp ( h , 0 , h -> qscale ) ; h -> chroma_qp [ 1 ] = get_chroma_qp ( h , 1 , h -> qscale ) ; if ( h -> slice_type == AV_PICTURE_TYPE_SP ) get_bits1 ( & h -> gb ) ; if ( h -> slice_type == AV_PICTURE_TYPE_SP || h -> slice_type == AV_PICTURE_TYPE_SI ) get_se_golomb ( & h -> gb ) ; h -> deblocking_filter = 1 ; h -> slice_alpha_c0_offset = 52 ; h -> slice_beta_offset = 52 ; if ( h -> pps . deblocking_filter_parameters_present ) { tmp = get_ue_golomb_31 ( & h -> gb ) ; if ( tmp > 2 ) { av_log ( h -> avctx , AV_LOG_ERROR , ""deblocking_filter_idc<S2SV_blank>%u<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range\\n"" , tmp ) ; return AVERROR_INVALIDDATA ; } h -> deblocking_filter = tmp ; if ( h -> deblocking_filter < 2 ) h -> deblocking_filter ^= 1 ; if ( h -> deblocking_filter ) { h -> slice_alpha_c0_offset += get_se_golomb ( & h -> gb ) << 1 ; h -> slice_beta_offset += get_se_golomb ( & h -> gb ) << 1 ; if ( h -> slice_alpha_c0_offset > 104U || h -> slice_beta_offset > 104U ) { av_log ( h -> avctx , AV_LOG_ERROR , ""deblocking<S2SV_blank>filter<S2SV_blank>parameters<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range\\n"" , h -> slice_alpha_c0_offset , h -> slice_beta_offset ) ; return AVERROR_INVALIDDATA ; } } } if ( h -> avctx -> skip_loop_filter >= AVDISCARD_ALL || ( h -> avctx -> skip_loop_filter >= AVDISCARD_NONKEY && h -> slice_type_nos != AV_PICTURE_TYPE_I ) || ( h -> avctx -> skip_loop_filter >= AVDISCARD_BIDIR && h -> slice_type_nos == AV_PICTURE_TYPE_B ) || ( h -> avctx -> skip_loop_filter >= AVDISCARD_NONREF && h -> nal_ref_idc == 0 ) ) h -> deblocking_filter = 0 ; if ( h -> deblocking_filter == 1 && h0 -> max_contexts > 1 ) { if ( h -> avctx -> flags2 & CODEC_FLAG2_FAST ) { h -> deblocking_filter = 2 ; } else { h0 -> max_contexts = 1 ; if ( ! h0 -> single_decode_warning ) { av_log ( h -> avctx , AV_LOG_INFO , ""Cannot<S2SV_blank>parallelize<S2SV_blank>deblocking<S2SV_blank>type<S2SV_blank>1,<S2SV_blank>decoding<S2SV_blank>such<S2SV_blank>frames<S2SV_blank>in<S2SV_blank>sequential<S2SV_blank>order\\n"" ) ; h0 -> single_decode_warning = 1 ; } if ( h != h0 ) { av_log ( h -> avctx , AV_LOG_ERROR , ""Deblocking<S2SV_blank>switched<S2SV_blank>inside<S2SV_blank>frame.\\n"" ) ; return 1 ; } } } h -> qp_thresh = 15 + 52 - FFMIN ( h -> slice_alpha_c0_offset , h -> slice_beta_offset ) - FFMAX3 ( 0 , h -> pps . chroma_qp_index_offset [ 0 ] , h -> pps . chroma_qp_index_offset [ 1 ] ) + 6 * ( h -> sps . bit_depth_luma - 8 ) ; h0 -> last_slice_type = slice_type ; memcpy ( h0 -> last_ref_count , h0 -> ref_count , sizeof ( h0 -> last_ref_count ) ) ; h -> slice_num = ++ h0 -> current_slice ; if ( h -> slice_num ) h0 -> slice_row [ ( h -> slice_num - 1 ) & ( MAX_SLICES - 1 ) ] = h -> resync_mb_y ; if ( h0 -> slice_row [ h -> slice_num & ( MAX_SLICES - 1 ) ] + 3 >= h -> resync_mb_y && h0 -> slice_row [ h -> slice_num & ( MAX_SLICES - 1 ) ] <= h -> resync_mb_y && h -> slice_num >= MAX_SLICES ) { av_log ( h -> avctx , AV_LOG_WARNING , ""Possibly<S2SV_blank>too<S2SV_blank>many<S2SV_blank>slices<S2SV_blank>(%d<S2SV_blank>>=<S2SV_blank>%d),<S2SV_blank>increase<S2SV_blank>MAX_SLICES<S2SV_blank>and<S2SV_blank>recompile<S2SV_blank>if<S2SV_blank>there<S2SV_blank>are<S2SV_blank>artifacts\\n"" , h -> slice_num , MAX_SLICES ) ; } for ( j = 0 ; j < 2 ; j ++ ) { int id_list [ 16 ] ; int * ref2frm = h -> ref2frm [ h -> slice_num & ( MAX_SLICES - 1 ) ] [ j ] ; for ( i = 0 ; i < 16 ; i ++ ) { id_list [ i ] = 60 ; if ( j < h -> list_count && i < h -> ref_count [ j ] && h -> ref_list [ j ] [ i ] . f . buf [ 0 ] ) { int k ; AVBuffer * buf = h -> ref_list [ j ] [ i ] . f . buf [ 0 ] -> buffer ; for ( k = 0 ; k < h -> short_ref_count ; k ++ ) if ( h -> short_ref [ k ] -> f . buf [ 0 ] -> buffer == buf ) { id_list [ i ] = k ; break ; } for ( k = 0 ; k < h -> long_ref_count ; k ++ ) if ( h -> long_ref [ k ] && h -> long_ref [ k ] -> f . buf [ 0 ] -> buffer == buf ) { id_list [ i ] = h -> short_ref_count + k ; break ; } } } ref2frm [ 0 ] = ref2frm [ 1 ] = - 1 ; for ( i = 0 ; i < 16 ; i ++ ) ref2frm [ i + 2 ] = 4 * id_list [ i ] + ( h -> ref_list [ j ] [ i ] . reference & 3 ) ; ref2frm [ 18 + 0 ] = ref2frm [ 18 + 1 ] = - 1 ; for ( i = 16 ; i < 48 ; i ++ ) ref2frm [ i + 4 ] = 4 * id_list [ ( i - 16 ) >> 1 ] + ( h -> ref_list [ j ] [ i ] . reference & 3 ) ; } if ( h -> ref_count [ 0 ] ) h -> er . last_pic = & h -> ref_list [ 0 ] [ 0 ] ; if ( h -> ref_count [ 1 ] ) h -> er . next_pic = & h -> ref_list [ 1 ] [ 0 ] ; h -> er . ref_count = h -> ref_count [ 0 ] ; if ( h -> avctx -> debug & FF_DEBUG_PICT_INFO ) { av_log ( h -> avctx , AV_LOG_DEBUG , ""slice:%d<S2SV_blank>%s<S2SV_blank>mb:%d<S2SV_blank>%c%s%s<S2SV_blank>pps:%u<S2SV_blank>frame:%d<S2SV_blank>poc:%d/%d<S2SV_blank>ref:%d/%d<S2SV_blank>qp:%d<S2SV_blank>loop:%d:%d:%d<S2SV_blank>weight:%d%s<S2SV_blank>%s\\n"" , h -> slice_num , ( h -> picture_structure == PICT_FRAME ? ""F"" : h -> picture_structure == PICT_TOP_FIELD ? ""T"" : ""B"" ) , first_mb_in_slice , av_get_picture_type_char ( h -> slice_type ) , h -> slice_type_fixed ? ""<S2SV_blank>fix"" : """" , h -> nal_unit_type == NAL_IDR_SLICE ? ""<S2SV_blank>IDR"" : """" , pps_id , h -> frame_num , h -> cur_pic_ptr -> field_poc [ 0 ] , h -> cur_pic_ptr -> field_poc [ 1 ] , h -> ref_count [ 0 ] , h -> ref_count [ 1 ] , h -> qscale , h -> deblocking_filter , h -> slice_alpha_c0_offset / 2 - 26 , h -> slice_beta_offset / 2 - 26 , h -> use_weight , h -> use_weight == 1 && h -> use_weight_chroma ? ""c"" : """" , h -> slice_type == AV_PICTURE_TYPE_B ? ( h -> direct_spatial_mv_pred ? ""SPAT"" : ""TEMP"" ) : """" ) ; } return 0 ; }",; if ( <S2SV_ModEnd> h0 -> cur_pic_ptr <S2SV_ModStart> { if ( <S2SV_ModEnd> last_pic_structure != PICT_FRAME <S2SV_ModStart> { if ( <S2SV_ModEnd> last_pic_structure != PICT_FRAME
662,"static void fillrd ( struct postproc_state * state , int q , int a ) { char char_dist [ 300 ] ; double sigma ; int i ; vp8_clear_system_state ( ) ; sigma = a + .5 + .6 * ( 63 - q ) / 63.0 ; { int next , j ; next = 0 ; for ( i = - 32 ; i < 32 ; i ++ ) { <S2SV_StartBug> const int v = ( int ) ( .5 + 256 * vp8_gaussian ( sigma , 0 , i ) ) ; <S2SV_EndBug> if ( v ) { for ( j = 0 ; j < v ; j ++ ) { char_dist [ next + j ] = ( char ) i ; } next = next + j ; } } for ( ; next < 256 ; next ++ ) char_dist [ next ] = 0 ; } for ( i = 0 ; i < 3072 ; i ++ ) { state -> noise [ i ] = char_dist [ rand ( ) & 0xff ] ; } for ( i = 0 ; i < 16 ; i ++ ) { state -> blackclamp [ i ] = - char_dist [ 0 ] ; state -> whiteclamp [ i ] = - char_dist [ 0 ] ; state -> bothclamp [ i ] = - 2 * char_dist [ 0 ] ; } state -> last_q = q ; state -> last_noise = a ; }","+ 256 * gaussian <S2SV_ModEnd> ( sigma ,"
663,"static void ChopUpSingleUncompressedStrip ( TIFF * tif ) { register TIFFDirectory * td = & tif -> tif_dir ; uint64 bytecount ; uint64 offset ; uint32 rowblock ; uint64 rowblockbytes ; uint64 stripbytes ; uint32 strip ; <S2SV_StartBug> uint64 nstrips64 ; <S2SV_EndBug> uint32 nstrips32 ; uint32 rowsperstrip ; uint64 * newcounts ; uint64 * newoffsets ; bytecount = td -> td_stripbytecount [ 0 ] ; offset = td -> td_stripoffset [ 0 ] ; assert ( td -> td_planarconfig == PLANARCONFIG_CONTIG ) ; if ( ( td -> td_photometric == PHOTOMETRIC_YCBCR ) && ( ! isUpSampled ( tif ) ) ) rowblock = td -> td_ycbcrsubsampling [ 1 ] ; else rowblock = 1 ; rowblockbytes = TIFFVTileSize64 ( tif , rowblock ) ; if ( rowblockbytes > STRIP_SIZE_DEFAULT ) { stripbytes = rowblockbytes ; rowsperstrip = rowblock ; } else if ( rowblockbytes > 0 ) { uint32 rowblocksperstrip ; rowblocksperstrip = ( uint32 ) ( STRIP_SIZE_DEFAULT / rowblockbytes ) ; rowsperstrip = rowblocksperstrip * rowblock ; stripbytes = rowblocksperstrip * rowblockbytes ; } else return ; if ( rowsperstrip >= td -> td_rowsperstrip ) return ; <S2SV_StartBug> nstrips64 = TIFFhowmany_64 ( bytecount , stripbytes ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( nstrips64 == 0 ) || ( nstrips64 > 0xFFFFFFFF ) ) <S2SV_EndBug> return ; nstrips32 = ( uint32 ) nstrips64 ; <S2SV_StartBug> newcounts = ( uint64 * ) _TIFFCheckMalloc ( tif , nstrips32 , sizeof ( uint64 ) , <S2SV_EndBug> ""for<S2SV_blank>chopped<S2SV_blank>\\""StripByteCounts\\""<S2SV_blank>array"" ) ; <S2SV_StartBug> newoffsets = ( uint64 * ) _TIFFCheckMalloc ( tif , nstrips32 , sizeof ( uint64 ) , <S2SV_EndBug> ""for<S2SV_blank>chopped<S2SV_blank>\\""StripOffsets\\""<S2SV_blank>array"" ) ; if ( newcounts == NULL || newoffsets == NULL ) { if ( newcounts != NULL ) _TIFFfree ( newcounts ) ; if ( newoffsets != NULL ) _TIFFfree ( newoffsets ) ; return ; } <S2SV_StartBug> for ( strip = 0 ; strip < nstrips32 ; strip ++ ) { <S2SV_EndBug> if ( stripbytes > bytecount ) stripbytes = bytecount ; newcounts [ strip ] = stripbytes ; <S2SV_StartBug> newoffsets [ strip ] = offset ; <S2SV_EndBug> offset += stripbytes ; bytecount -= stripbytes ; } <S2SV_StartBug> td -> td_stripsperimage = td -> td_nstrips = nstrips32 ; <S2SV_EndBug> TIFFSetField ( tif , TIFFTAG_ROWSPERSTRIP , rowsperstrip ) ; _TIFFfree ( td -> td_stripbytecount ) ; _TIFFfree ( td -> td_stripoffset ) ; td -> td_stripbytecount = newcounts ; td -> td_stripoffset = newoffsets ; td -> td_stripbytecountsorted = 1 ; }","uint32 strip ; uint32 nstrips <S2SV_ModEnd> ; uint32 rowsperstrip <S2SV_ModStart> ) return ; nstrips = TIFFhowmany_32 ( td -> td_imagelength , rowsperstrip ) ; if ( nstrips <S2SV_ModEnd> == 0 ) <S2SV_ModStart> == 0 ) return ; <S2SV_ModEnd> newcounts = ( <S2SV_ModStart> ( tif , nstrips <S2SV_ModEnd> , sizeof ( <S2SV_ModStart> ( tif , nstrips <S2SV_ModEnd> , sizeof ( <S2SV_ModStart> ; strip < nstrips <S2SV_ModEnd> ; strip ++ <S2SV_ModStart> strip ] = stripbytes ? offset : 0 <S2SV_ModEnd> ; offset += <S2SV_ModStart> -> td_nstrips = nstrips <S2SV_ModEnd> ; TIFFSetField ("
664,"struct lldpd_mgmt * lldpd_alloc_mgmt ( int family , void * addrptr , size_t addrsize , u_int32_t iface ) { struct lldpd_mgmt * mgmt ; log_debug ( ""alloc"" , ""allocate<S2SV_blank>a<S2SV_blank>new<S2SV_blank>management<S2SV_blank>address<S2SV_blank>(family:<S2SV_blank>%d)"" , family ) ; if ( family <= LLDPD_AF_UNSPEC || family >= LLDPD_AF_LAST ) { errno = EAFNOSUPPORT ; return NULL ; } if ( addrsize > LLDPD_MGMT_MAXADDRSIZE ) { errno = EOVERFLOW ; return NULL ; } mgmt = calloc ( 1 , sizeof ( struct lldpd_mgmt ) ) ; if ( mgmt == NULL ) { errno = ENOMEM ; return NULL ; } mgmt -> m_family = family ; <S2SV_StartBug> assert ( addrsize <= LLDPD_MGMT_MAXADDRSIZE ) ; <S2SV_EndBug> memcpy ( & mgmt -> m_addr , addrptr , addrsize ) ; mgmt -> m_addrsize = addrsize ; mgmt -> m_iface = iface ; return mgmt ; }",= family ; <S2SV_ModEnd> memcpy ( &
665,"static int my_login ( pTHX_ SV * dbh , imp_dbh_t * imp_dbh ) { SV * sv ; HV * hv ; char * dbname ; char * host ; char * port ; char * user ; char * password ; char * mysql_socket ; <S2SV_StartBug> int result ; <S2SV_EndBug> D_imp_xxh ( dbh ) ; # define TAKE_IMP_DATA_VERSION 1 # if TAKE_IMP_DATA_VERSION if ( DBIc_has ( imp_dbh , DBIcf_IMPSET ) ) { if ( DBIc_has ( imp_dbh , DBIcf_ACTIVE ) ) { if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""my_login<S2SV_blank>skip<S2SV_blank>connect\\n"" ) ; ++ DBIc_ACTIVE_KIDS ( DBIc_PARENT_COM ( imp_dbh ) ) ; return TRUE ; } if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""my_login<S2SV_blank>IMPSET<S2SV_blank>but<S2SV_blank>not<S2SV_blank>ACTIVE<S2SV_blank>so<S2SV_blank>connect<S2SV_blank>not<S2SV_blank>skipped\\n"" ) ; } # endif sv = DBIc_IMP_DATA ( imp_dbh ) ; if ( ! sv || ! SvROK ( sv ) ) return FALSE ; hv = ( HV * ) SvRV ( sv ) ; if ( SvTYPE ( hv ) != SVt_PVHV ) return FALSE ; host = safe_hv_fetch ( aTHX_ hv , ""host"" , 4 ) ; port = safe_hv_fetch ( aTHX_ hv , ""port"" , 4 ) ; user = safe_hv_fetch ( aTHX_ hv , ""user"" , 4 ) ; password = safe_hv_fetch ( aTHX_ hv , ""password"" , 8 ) ; dbname = safe_hv_fetch ( aTHX_ hv , ""database"" , 8 ) ; mysql_socket = safe_hv_fetch ( aTHX_ hv , ""mysql_socket"" , 12 ) ; if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""imp_dbh->my_login<S2SV_blank>:<S2SV_blank>dbname<S2SV_blank>=<S2SV_blank>%s,<S2SV_blank>uid<S2SV_blank>=<S2SV_blank>%s,<S2SV_blank>pwd<S2SV_blank>=<S2SV_blank>%s,"" ""host<S2SV_blank>=<S2SV_blank>%s,<S2SV_blank>port<S2SV_blank>=<S2SV_blank>%s\\n"" , dbname ? dbname : ""NULL"" , user ? user : ""NULL"" , password ? password : ""NULL"" , host ? host : ""NULL"" , port ? port : ""NULL"" ) ; if ( ! imp_dbh -> pmysql ) { <S2SV_StartBug> Newz ( 908 , imp_dbh -> pmysql , 1 , MYSQL ) ; <S2SV_EndBug> } result = mysql_dr_connect ( dbh , imp_dbh -> pmysql , mysql_socket , host , port , user , password , dbname , imp_dbh ) ? TRUE : FALSE ; <S2SV_StartBug> if ( ! result ) <S2SV_EndBug> <S2SV_StartBug> Safefree ( imp_dbh -> pmysql ) ; <S2SV_EndBug> return result ; }","; int result ; int fresh = 0 <S2SV_ModStart> pmysql ) { fresh = 1 ; <S2SV_ModStart> ; if ( fresh && <S2SV_ModStart> ! result ) { do_error ( dbh , mysql_errno ( imp_dbh -> pmysql ) , mysql_error ( imp_dbh -> pmysql ) , mysql_sqlstate ( imp_dbh -> pmysql ) ) ; <S2SV_ModStart> pmysql ) ; imp_dbh -> pmysql = NULL ; }"
666,"GF_Err cat_multiple_files ( GF_ISOFile * dest , char * fileName , u32 import_flags , Double force_fps , u32 frames_per_sample , char * tmp_dir , Bool force_cat , Bool align_timelines , Bool allow_add_in_command ) { CATEnum cat_enum ; char * sep ; cat_enum . dest = dest ; cat_enum . import_flags = import_flags ; cat_enum . force_fps = force_fps ; cat_enum . frames_per_sample = frames_per_sample ; cat_enum . tmp_dir = tmp_dir ; cat_enum . force_cat = force_cat ; cat_enum . align_timelines = align_timelines ; cat_enum . allow_add_in_command = allow_add_in_command ; <S2SV_StartBug> strcpy ( cat_enum . szPath , fileName ) ; <S2SV_EndBug> sep = strrchr ( cat_enum . szPath , GF_PATH_SEPARATOR ) ; if ( ! sep ) sep = strrchr ( cat_enum . szPath , '/' ) ; if ( ! sep ) { strcpy ( cat_enum . szPath , ""."" ) ; <S2SV_StartBug> strcpy ( cat_enum . szRad1 , fileName ) ; <S2SV_EndBug> } else { <S2SV_StartBug> strcpy ( cat_enum . szRad1 , sep + 1 ) ; <S2SV_EndBug> sep [ 0 ] = 0 ; } <S2SV_StartBug> sep = strchr ( cat_enum . szRad1 , '*' ) ; <S2SV_EndBug> <S2SV_StartBug> strcpy ( cat_enum . szRad2 , sep + 1 ) ; <S2SV_EndBug> sep [ 0 ] = 0 ; <S2SV_StartBug> sep = strchr ( cat_enum . szRad2 , '%' ) ; <S2SV_EndBug> if ( ! sep ) sep = strchr ( cat_enum . szRad2 , '#' ) ; if ( ! sep ) sep = strchr ( cat_enum . szRad2 , ':' ) ; strcpy ( cat_enum . szOpt , """" ) ; <S2SV_StartBug> if ( sep ) { <S2SV_EndBug> strcpy ( cat_enum . szOpt , sep ) ; sep [ 0 ] = 0 ; } return gf_enum_directory ( cat_enum . szPath , 0 , cat_enumerate , & cat_enum , NULL ) ; }","= allow_add_in_command ; if ( strlen ( fileName ) >= sizeof <S2SV_ModEnd> ( cat_enum . <S2SV_ModStart> cat_enum . szPath ) ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( ""File<S2SV_blank>name<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long.\\n"" , fileName ) ) ; return GF_NOT_SUPPORTED ; } strcpy ( cat_enum . szPath <S2SV_ModStart> ""."" ) ; if ( strlen ( fileName ) >= sizeof <S2SV_ModEnd> ( cat_enum . <S2SV_ModStart> cat_enum . szRad1 ) ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( ""File<S2SV_blank>name<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long.\\n"" , fileName ) ) ; return GF_NOT_SUPPORTED ; } strcpy ( cat_enum . szRad1 <S2SV_ModStart> } else { if ( strlen ( <S2SV_ModEnd> sep + 1 <S2SV_ModStart> + 1 ) >= sizeof <S2SV_ModEnd> ( cat_enum . <S2SV_ModStart> cat_enum . szRad1 ) ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( ""File<S2SV_blank>name<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long.\\n"" , ( <S2SV_ModEnd> sep + 1 <S2SV_ModStart> + 1 ) ) ) ; return GF_NOT_SUPPORTED ; } strcpy ( cat_enum . szRad1 , sep + 1 ) <S2SV_ModStart> = 0 ; } <S2SV_ModStart> ( cat_enum . szRad1 , '*' ) ; if ( strlen ( sep + 1 ) >= sizeof ( cat_enum . szRad2 ) ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( ""File<S2SV_blank>name<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long.\\n"" , ( sep + 1 ) ) ) ; return GF_NOT_SUPPORTED ; } strcpy ( cat_enum . szRad2 , sep + 1 ) ; sep [ 0 ] = 0 ; sep = strchr ( cat_enum . szRad2 <S2SV_ModEnd> , '%' ) <S2SV_ModStart> sep ) { if ( strlen ( sep ) >= sizeof ( cat_enum . szOpt ) ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( ""Invalid<S2SV_blank>option:<S2SV_blank>%s.\\n"" , sep ) ) ; return GF_NOT_SUPPORTED ; }"
667,"void receive_carbon ( void * * state ) { prof_input ( ""/carbons<S2SV_blank>on"" ) ; prof_connect ( ) ; assert_true ( stbbr_received ( ""<iq<S2SV_blank>id=\'*\'<S2SV_blank>type=\'set\'><enable<S2SV_blank>xmlns=\'urn:xmpp:carbons:2\'/></iq>"" ) ) ; stbbr_send ( ""<presence<S2SV_blank>to=\'stabber@localhost\'<S2SV_blank>from=\'buddy1@localhost/mobile\'>"" ""<priority>10</priority>"" ""<status>On<S2SV_blank>my<S2SV_blank>mobile</status>"" ""</presence>"" ) ; assert_true ( prof_output_exact ( ""Buddy1<S2SV_blank>(mobile)<S2SV_blank>is<S2SV_blank>online,<S2SV_blank>\\""On<S2SV_blank>my<S2SV_blank>mobile\\"""" ) ) ; prof_input ( ""/msg<S2SV_blank>Buddy1"" ) ; assert_true ( prof_output_exact ( ""unencrypted"" ) ) ; stbbr_send ( <S2SV_StartBug> ""<message<S2SV_blank>type=\'chat\'<S2SV_blank>to=\'stabber@localhost/profanity\'<S2SV_blank>from=\'buddy1@localhost\'>"" <S2SV_EndBug> ""<received<S2SV_blank>xmlns=\'urn:xmpp:carbons:2\'>"" ""<forwarded<S2SV_blank>xmlns=\'urn:xmpp:forward:0\'>"" ""<message<S2SV_blank>id=\'prof_msg_7\'<S2SV_blank>xmlns=\'jabber:client\'<S2SV_blank>type=\'chat\'<S2SV_blank>lang=\'en\'<S2SV_blank>to=\'stabber@localhost/profanity\'<S2SV_blank>from=\'buddy1@localhost/mobile\'>"" ""<body>test<S2SV_blank>carbon<S2SV_blank>from<S2SV_blank>recipient</body>"" ""</message>"" ""</forwarded>"" ""</received>"" ""</message>"" ) ; assert_true ( prof_output_regex ( ""Buddy1/mobile:<S2SV_blank>.+test<S2SV_blank>carbon<S2SV_blank>from<S2SV_blank>recipient"" ) ) ; }","; stbbr_send ( ""<message<S2SV_blank>type=\'chat\'<S2SV_blank>to=\'stabber@localhost/profanity\'<S2SV_blank>from=\'stabber@localhost\'>"" <S2SV_ModEnd> ""<received<S2SV_blank>xmlns=\'urn:xmpp:carbons:2\'>"" ""<forwarded<S2SV_blank>xmlns=\'urn:xmpp:forward:0\'>"" ""<message<S2SV_blank>id=\'prof_msg_7\'<S2SV_blank>xmlns=\'jabber:client\'<S2SV_blank>type=\'chat\'<S2SV_blank>lang=\'en\'<S2SV_blank>to=\'stabber@localhost/profanity\'<S2SV_blank>from=\'buddy1@localhost/mobile\'>"""
668,"static int mem_read ( jas_stream_obj_t * obj , char * buf , int cnt ) { <S2SV_StartBug> int n ; <S2SV_EndBug> assert ( cnt >= 0 ) ; assert ( buf ) ; JAS_DBGLOG ( 100 , ( ""mem_read(%p,<S2SV_blank>%p,<S2SV_blank>%d)\\n"" , obj , buf , cnt ) ) ; jas_stream_memobj_t * m = ( jas_stream_memobj_t * ) obj ; n = m -> len_ - m -> pos_ ; cnt = JAS_MIN ( n , cnt ) ; memcpy ( buf , & m -> buf_ [ m -> pos_ ] , cnt ) ; m -> pos_ += cnt ; return cnt ; }",cnt ) { ssize_t <S2SV_ModEnd> n ; assert
669,"static MagickBooleanType GetEXIFProperty ( const Image * image , const char * property , ExceptionInfo * exception ) { # define MaxDirectoryStack 16 # define EXIF_DELIMITER ""\\n"" # define EXIF_NUM_FORMATS 12 # define EXIF_FMT_BYTE 1 # define EXIF_FMT_STRING 2 # define EXIF_FMT_USHORT 3 # define EXIF_FMT_ULONG 4 # define EXIF_FMT_URATIONAL 5 # define EXIF_FMT_SBYTE 6 # define EXIF_FMT_UNDEFINED 7 # define EXIF_FMT_SSHORT 8 # define EXIF_FMT_SLONG 9 # define EXIF_FMT_SRATIONAL 10 # define EXIF_FMT_SINGLE 11 # define EXIF_FMT_DOUBLE 12 # define TAG_EXIF_OFFSET 0x8769 # define TAG_GPS_OFFSET 0x8825 # define TAG_INTEROP_OFFSET 0xa005 <S2SV_StartBug> # define EXIFMultipleValues ( size , format , arg ) { ssize_t component ; size_t length ; unsigned char * p1 ; length = 0 ; p1 = p ; for ( component = 0 ; component < components ; component ++ ) { length += FormatLocaleString ( buffer + length , MagickPathExtent - length , format "",<S2SV_blank>"" , arg ) ; if ( length >= ( MagickPathExtent - 1 ) ) length = MagickPathExtent - 1 ; p1 += size ; } if ( length > 1 ) buffer [ length - 2 ] = '\\0' ; value = AcquireString ( buffer ) ; } <S2SV_EndBug> <S2SV_StartBug> # define EXIFMultipleFractions ( size , format , arg1 , arg2 ) { ssize_t component ; size_t length ; unsigned char * p1 ; length = 0 ; p1 = p ; for ( component = 0 ; component < components ; component ++ ) { length += FormatLocaleString ( buffer + length , MagickPathExtent - length , format "",<S2SV_blank>"" , ( arg1 ) , ( arg2 ) ) ; if ( length >= ( MagickPathExtent - 1 ) ) length = MagickPathExtent - 1 ; p1 += size ; } if ( length > 1 ) buffer [ length - 2 ] = '\\0' ; value = AcquireString ( buffer ) ; } <S2SV_EndBug> typedef struct _DirectoryInfo { const unsigned char * directory ; size_t entry ; ssize_t offset ; } DirectoryInfo ; typedef struct _TagInfo { size_t tag ; const char * description ; } TagInfo ; static TagInfo EXIFTag [ ] = { { 0x001 , ""exif:InteroperabilityIndex"" } , { 0x002 , ""exif:InteroperabilityVersion"" } , { 0x100 , ""exif:ImageWidth"" } , { 0x101 , ""exif:ImageLength"" } , { 0x102 , ""exif:BitsPerSample"" } , { 0x103 , ""exif:Compression"" } , { 0x106 , ""exif:PhotometricInterpretation"" } , { 0x10a , ""exif:FillOrder"" } , { 0x10d , ""exif:DocumentName"" } , { 0x10e , ""exif:ImageDescription"" } , { 0x10f , ""exif:Make"" } , { 0x110 , ""exif:Model"" } , { 0x111 , ""exif:StripOffsets"" } , { 0x112 , ""exif:Orientation"" } , { 0x115 , ""exif:SamplesPerPixel"" } , { 0x116 , ""exif:RowsPerStrip"" } , { 0x117 , ""exif:StripByteCounts"" } , { 0x11a , ""exif:XResolution"" } , { 0x11b , ""exif:YResolution"" } , { 0x11c , ""exif:PlanarConfiguration"" } , { 0x11d , ""exif:PageName"" } , { 0x11e , ""exif:XPosition"" } , { 0x11f , ""exif:YPosition"" } , { 0x118 , ""exif:MinSampleValue"" } , { 0x119 , ""exif:MaxSampleValue"" } , { 0x120 , ""exif:FreeOffsets"" } , { 0x121 , ""exif:FreeByteCounts"" } , { 0x122 , ""exif:GrayResponseUnit"" } , { 0x123 , ""exif:GrayResponseCurve"" } , { 0x124 , ""exif:T4Options"" } , { 0x125 , ""exif:T6Options"" } , { 0x128 , ""exif:ResolutionUnit"" } , { 0x12d , ""exif:TransferFunction"" } , { 0x131 , ""exif:Software"" } , { 0x132 , ""exif:DateTime"" } , { 0x13b , ""exif:Artist"" } , { 0x13e , ""exif:WhitePoint"" } , { 0x13f , ""exif:PrimaryChromaticities"" } , { 0x140 , ""exif:ColorMap"" } , { 0x141 , ""exif:HalfToneHints"" } , { 0x142 , ""exif:TileWidth"" } , { 0x143 , ""exif:TileLength"" } , { 0x144 , ""exif:TileOffsets"" } , { 0x145 , ""exif:TileByteCounts"" } , { 0x14a , ""exif:SubIFD"" } , { 0x14c , ""exif:InkSet"" } , { 0x14d , ""exif:InkNames"" } , { 0x14e , ""exif:NumberOfInks"" } , { 0x150 , ""exif:DotRange"" } , { 0x151 , ""exif:TargetPrinter"" } , { 0x152 , ""exif:ExtraSample"" } , { 0x153 , ""exif:SampleFormat"" } , { 0x154 , ""exif:SMinSampleValue"" } , { 0x155 , ""exif:SMaxSampleValue"" } , { 0x156 , ""exif:TransferRange"" } , { 0x157 , ""exif:ClipPath"" } , { 0x158 , ""exif:XClipPathUnits"" } , { 0x159 , ""exif:YClipPathUnits"" } , { 0x15a , ""exif:Indexed"" } , { 0x15b , ""exif:JPEGTables"" } , { 0x15f , ""exif:OPIProxy"" } , { 0x200 , ""exif:JPEGProc"" } , { 0x201 , ""exif:JPEGInterchangeFormat"" } , { 0x202 , ""exif:JPEGInterchangeFormatLength"" } , { 0x203 , ""exif:JPEGRestartInterval"" } , { 0x205 , ""exif:JPEGLosslessPredictors"" } , { 0x206 , ""exif:JPEGPointTransforms"" } , { 0x207 , ""exif:JPEGQTables"" } , { 0x208 , ""exif:JPEGDCTables"" } , { 0x209 , ""exif:JPEGACTables"" } , { 0x211 , ""exif:YCbCrCoefficients"" } , { 0x212 , ""exif:YCbCrSubSampling"" } , { 0x213 , ""exif:YCbCrPositioning"" } , { 0x214 , ""exif:ReferenceBlackWhite"" } , { 0x2bc , ""exif:ExtensibleMetadataPlatform"" } , { 0x301 , ""exif:Gamma"" } , { 0x302 , ""exif:ICCProfileDescriptor"" } , { 0x303 , ""exif:SRGBRenderingIntent"" } , { 0x320 , ""exif:ImageTitle"" } , { 0x5001 , ""exif:ResolutionXUnit"" } , { 0x5002 , ""exif:ResolutionYUnit"" } , { 0x5003 , ""exif:ResolutionXLengthUnit"" } , { 0x5004 , ""exif:ResolutionYLengthUnit"" } , { 0x5005 , ""exif:PrintFlags"" } , { 0x5006 , ""exif:PrintFlagsVersion"" } , { 0x5007 , ""exif:PrintFlagsCrop"" } , { 0x5008 , ""exif:PrintFlagsBleedWidth"" } , { 0x5009 , ""exif:PrintFlagsBleedWidthScale"" } , { 0x500A , ""exif:HalftoneLPI"" } , { 0x500B , ""exif:HalftoneLPIUnit"" } , { 0x500C , ""exif:HalftoneDegree"" } , { 0x500D , ""exif:HalftoneShape"" } , { 0x500E , ""exif:HalftoneMisc"" } , { 0x500F , ""exif:HalftoneScreen"" } , { 0x5010 , ""exif:JPEGQuality"" } , { 0x5011 , ""exif:GridSize"" } , { 0x5012 , ""exif:ThumbnailFormat"" } , { 0x5013 , ""exif:ThumbnailWidth"" } , { 0x5014 , ""exif:ThumbnailHeight"" } , { 0x5015 , ""exif:ThumbnailColorDepth"" } , { 0x5016 , ""exif:ThumbnailPlanes"" } , { 0x5017 , ""exif:ThumbnailRawBytes"" } , { 0x5018 , ""exif:ThumbnailSize"" } , { 0x5019 , ""exif:ThumbnailCompressedSize"" } , { 0x501a , ""exif:ColorTransferFunction"" } , { 0x501b , ""exif:ThumbnailData"" } , { 0x5020 , ""exif:ThumbnailImageWidth"" } , { 0x5021 , ""exif:ThumbnailImageHeight"" } , { 0x5022 , ""exif:ThumbnailBitsPerSample"" } , { 0x5023 , ""exif:ThumbnailCompression"" } , { 0x5024 , ""exif:ThumbnailPhotometricInterp"" } , { 0x5025 , ""exif:ThumbnailImageDescription"" } , { 0x5026 , ""exif:ThumbnailEquipMake"" } , { 0x5027 , ""exif:ThumbnailEquipModel"" } , { 0x5028 , ""exif:ThumbnailStripOffsets"" } , { 0x5029 , ""exif:ThumbnailOrientation"" } , { 0x502a , ""exif:ThumbnailSamplesPerPixel"" } , { 0x502b , ""exif:ThumbnailRowsPerStrip"" } , { 0x502c , ""exif:ThumbnailStripBytesCount"" } , { 0x502d , ""exif:ThumbnailResolutionX"" } , { 0x502e , ""exif:ThumbnailResolutionY"" } , { 0x502f , ""exif:ThumbnailPlanarConfig"" } , { 0x5030 , ""exif:ThumbnailResolutionUnit"" } , { 0x5031 , ""exif:ThumbnailTransferFunction"" } , { 0x5032 , ""exif:ThumbnailSoftwareUsed"" } , { 0x5033 , ""exif:ThumbnailDateTime"" } , { 0x5034 , ""exif:ThumbnailArtist"" } , { 0x5035 , ""exif:ThumbnailWhitePoint"" } , { 0x5036 , ""exif:ThumbnailPrimaryChromaticities"" } , { 0x5037 , ""exif:ThumbnailYCbCrCoefficients"" } , { 0x5038 , ""exif:ThumbnailYCbCrSubsampling"" } , { 0x5039 , ""exif:ThumbnailYCbCrPositioning"" } , { 0x503A , ""exif:ThumbnailRefBlackWhite"" } , { 0x503B , ""exif:ThumbnailCopyRight"" } , { 0x5090 , ""exif:LuminanceTable"" } , { 0x5091 , ""exif:ChrominanceTable"" } , { 0x5100 , ""exif:FrameDelay"" } , { 0x5101 , ""exif:LoopCount"" } , { 0x5110 , ""exif:PixelUnit"" } , { 0x5111 , ""exif:PixelPerUnitX"" } , { 0x5112 , ""exif:PixelPerUnitY"" } , { 0x5113 , ""exif:PaletteHistogram"" } , { 0x1000 , ""exif:RelatedImageFileFormat"" } , { 0x1001 , ""exif:RelatedImageLength"" } , { 0x1002 , ""exif:RelatedImageWidth"" } , { 0x800d , ""exif:ImageID"" } , { 0x80e3 , ""exif:Matteing"" } , { 0x80e4 , ""exif:DataType"" } , { 0x80e5 , ""exif:ImageDepth"" } , { 0x80e6 , ""exif:TileDepth"" } , { 0x828d , ""exif:CFARepeatPatternDim"" } , { 0x828e , ""exif:CFAPattern2"" } , { 0x828f , ""exif:BatteryLevel"" } , { 0x8298 , ""exif:Copyright"" } , { 0x829a , ""exif:ExposureTime"" } , { 0x829d , ""exif:FNumber"" } , { 0x83bb , ""exif:IPTC/NAA"" } , { 0x84e3 , ""exif:IT8RasterPadding"" } , { 0x84e5 , ""exif:IT8ColorTable"" } , { 0x8649 , ""exif:ImageResourceInformation"" } , { 0x8769 , ""exif:ExifOffset"" } , { 0x8773 , ""exif:InterColorProfile"" } , { 0x8822 , ""exif:ExposureProgram"" } , { 0x8824 , ""exif:SpectralSensitivity"" } , { 0x8825 , ""exif:GPSInfo"" } , { 0x8827 , ""exif:ISOSpeedRatings"" } , { 0x8828 , ""exif:OECF"" } , { 0x8829 , ""exif:Interlace"" } , { 0x882a , ""exif:TimeZoneOffset"" } , { 0x882b , ""exif:SelfTimerMode"" } , { 0x9000 , ""exif:ExifVersion"" } , { 0x9003 , ""exif:DateTimeOriginal"" } , { 0x9004 , ""exif:DateTimeDigitized"" } , { 0x9101 , ""exif:ComponentsConfiguration"" } , { 0x9102 , ""exif:CompressedBitsPerPixel"" } , { 0x9201 , ""exif:ShutterSpeedValue"" } , { 0x9202 , ""exif:ApertureValue"" } , { 0x9203 , ""exif:BrightnessValue"" } , { 0x9204 , ""exif:ExposureBiasValue"" } , { 0x9205 , ""exif:MaxApertureValue"" } , { 0x9206 , ""exif:SubjectDistance"" } , { 0x9207 , ""exif:MeteringMode"" } , { 0x9208 , ""exif:LightSource"" } , { 0x9209 , ""exif:Flash"" } , { 0x920a , ""exif:FocalLength"" } , { 0x920b , ""exif:FlashEnergy"" } , { 0x920c , ""exif:SpatialFrequencyResponse"" } , { 0x920d , ""exif:Noise"" } , { 0x9211 , ""exif:ImageNumber"" } , { 0x9212 , ""exif:SecurityClassification"" } , { 0x9213 , ""exif:ImageHistory"" } , { 0x9214 , ""exif:SubjectArea"" } , { 0x9215 , ""exif:ExposureIndex"" } , { 0x9216 , ""exif:TIFF-EPStandardID"" } , { 0x927c , ""exif:MakerNote"" } , { 0x9C9b , ""exif:WinXP-Title"" } , { 0x9C9c , ""exif:WinXP-Comments"" } , { 0x9C9d , ""exif:WinXP-Author"" } , { 0x9C9e , ""exif:WinXP-Keywords"" } , { 0x9C9f , ""exif:WinXP-Subject"" } , { 0x9286 , ""exif:UserComment"" } , { 0x9290 , ""exif:SubSecTime"" } , { 0x9291 , ""exif:SubSecTimeOriginal"" } , { 0x9292 , ""exif:SubSecTimeDigitized"" } , { 0xa000 , ""exif:FlashPixVersion"" } , { 0xa001 , ""exif:ColorSpace"" } , { 0xa002 , ""exif:ExifImageWidth"" } , { 0xa003 , ""exif:ExifImageLength"" } , { 0xa004 , ""exif:RelatedSoundFile"" } , { 0xa005 , ""exif:InteroperabilityOffset"" } , { 0xa20b , ""exif:FlashEnergy"" } , { 0xa20c , ""exif:SpatialFrequencyResponse"" } , { 0xa20d , ""exif:Noise"" } , { 0xa20e , ""exif:FocalPlaneXResolution"" } , { 0xa20f , ""exif:FocalPlaneYResolution"" } , { 0xa210 , ""exif:FocalPlaneResolutionUnit"" } , { 0xa214 , ""exif:SubjectLocation"" } , { 0xa215 , ""exif:ExposureIndex"" } , { 0xa216 , ""exif:TIFF/EPStandardID"" } , { 0xa217 , ""exif:SensingMethod"" } , { 0xa300 , ""exif:FileSource"" } , { 0xa301 , ""exif:SceneType"" } , { 0xa302 , ""exif:CFAPattern"" } , { 0xa401 , ""exif:CustomRendered"" } , { 0xa402 , ""exif:ExposureMode"" } , { 0xa403 , ""exif:WhiteBalance"" } , { 0xa404 , ""exif:DigitalZoomRatio"" } , { 0xa405 , ""exif:FocalLengthIn35mmFilm"" } , { 0xa406 , ""exif:SceneCaptureType"" } , { 0xa407 , ""exif:GainControl"" } , { 0xa408 , ""exif:Contrast"" } , { 0xa409 , ""exif:Saturation"" } , { 0xa40a , ""exif:Sharpness"" } , { 0xa40b , ""exif:DeviceSettingDescription"" } , { 0xa40c , ""exif:SubjectDistanceRange"" } , { 0xa420 , ""exif:ImageUniqueID"" } , { 0xc4a5 , ""exif:PrintImageMatching"" } , { 0xa500 , ""exif:Gamma"" } , { 0xc640 , ""exif:CR2Slice"" } , { 0x10000 , ""exif:GPSVersionID"" } , { 0x10001 , ""exif:GPSLatitudeRef"" } , { 0x10002 , ""exif:GPSLatitude"" } , { 0x10003 , ""exif:GPSLongitudeRef"" } , { 0x10004 , ""exif:GPSLongitude"" } , { 0x10005 , ""exif:GPSAltitudeRef"" } , { 0x10006 , ""exif:GPSAltitude"" } , { 0x10007 , ""exif:GPSTimeStamp"" } , { 0x10008 , ""exif:GPSSatellites"" } , { 0x10009 , ""exif:GPSStatus"" } , { 0x1000a , ""exif:GPSMeasureMode"" } , { 0x1000b , ""exif:GPSDop"" } , { 0x1000c , ""exif:GPSSpeedRef"" } , { 0x1000d , ""exif:GPSSpeed"" } , { 0x1000e , ""exif:GPSTrackRef"" } , { 0x1000f , ""exif:GPSTrack"" } , { 0x10010 , ""exif:GPSImgDirectionRef"" } , { 0x10011 , ""exif:GPSImgDirection"" } , { 0x10012 , ""exif:GPSMapDatum"" } , { 0x10013 , ""exif:GPSDestLatitudeRef"" } , { 0x10014 , ""exif:GPSDestLatitude"" } , { 0x10015 , ""exif:GPSDestLongitudeRef"" } , { 0x10016 , ""exif:GPSDestLongitude"" } , { 0x10017 , ""exif:GPSDestBearingRef"" } , { 0x10018 , ""exif:GPSDestBearing"" } , { 0x10019 , ""exif:GPSDestDistanceRef"" } , { 0x1001a , ""exif:GPSDestDistance"" } , { 0x1001b , ""exif:GPSProcessingMethod"" } , { 0x1001c , ""exif:GPSAreaInformation"" } , { 0x1001d , ""exif:GPSDateStamp"" } , { 0x1001e , ""exif:GPSDifferential"" } , { 0x00000 , ( const char * ) NULL } } ; const StringInfo * profile ; const unsigned char * directory , * exif ; DirectoryInfo directory_stack [ MaxDirectoryStack ] ; EndianType endian ; MagickBooleanType status ; register ssize_t i ; size_t entry , length , number_entries , tag , tag_value ; SplayTreeInfo * exif_resources ; ssize_t all , id , level , offset , tag_offset ; static int tag_bytes [ ] = { 0 , 1 , 1 , 2 , 4 , 8 , 1 , 1 , 2 , 4 , 8 , 4 , 8 } ; profile = GetImageProfile ( image , ""exif"" ) ; if ( profile == ( const StringInfo * ) NULL ) return ( MagickFalse ) ; if ( ( property == ( const char * ) NULL ) || ( * property == '\\0' ) ) return ( MagickFalse ) ; while ( isspace ( ( int ) ( ( unsigned char ) * property ) ) != 0 ) property ++ ; if ( strlen ( property ) <= 5 ) return ( MagickFalse ) ; all = 0 ; tag = ( ~ 0UL ) ; switch ( * ( property + 5 ) ) { case '*' : { tag = 0 ; all = 1 ; break ; } case '!' : { tag = 0 ; all = 2 ; break ; } case '#' : case '@' : { int c ; size_t n ; tag = ( * ( property + 5 ) == '@' ) ? 1UL : 0UL ; property += 6 ; n = strlen ( property ) ; if ( n != 4 ) return ( MagickFalse ) ; n /= 4 ; do { for ( i = ( ssize_t ) n - 1L ; i >= 0 ; i -- ) { c = ( * property ++ ) ; tag <<= 4 ; if ( ( c >= '0' ) && ( c <= '9' ) ) tag |= ( c - '0' ) ; else if ( ( c >= 'A' ) && ( c <= 'F' ) ) tag |= ( c - ( 'A' - 10 ) ) ; else if ( ( c >= 'a' ) && ( c <= 'f' ) ) tag |= ( c - ( 'a' - 10 ) ) ; else return ( MagickFalse ) ; } } while ( * property != '\\0' ) ; break ; } default : { for ( i = 0 ; ; i ++ ) { if ( EXIFTag [ i ] . tag == 0 ) break ; if ( LocaleCompare ( EXIFTag [ i ] . description , property ) == 0 ) { tag = ( size_t ) EXIFTag [ i ] . tag ; break ; } } break ; } } if ( tag == ( ~ 0UL ) ) return ( MagickFalse ) ; length = GetStringInfoLength ( profile ) ; exif = GetStringInfoDatum ( profile ) ; while ( length != 0 ) { if ( ReadPropertyByte ( & exif , & length ) != 0x45 ) continue ; if ( ReadPropertyByte ( & exif , & length ) != 0x78 ) continue ; if ( ReadPropertyByte ( & exif , & length ) != 0x69 ) continue ; if ( ReadPropertyByte ( & exif , & length ) != 0x66 ) continue ; if ( ReadPropertyByte ( & exif , & length ) != 0x00 ) continue ; if ( ReadPropertyByte ( & exif , & length ) != 0x00 ) continue ; break ; } if ( length < 16 ) return ( MagickFalse ) ; id = ( ssize_t ) ReadPropertySignedShort ( LSBEndian , exif ) ; endian = LSBEndian ; if ( id == 0x4949 ) endian = LSBEndian ; else if ( id == 0x4D4D ) endian = MSBEndian ; else return ( MagickFalse ) ; if ( ReadPropertyUnsignedShort ( endian , exif + 2 ) != 0x002a ) return ( MagickFalse ) ; offset = ( ssize_t ) ReadPropertySignedLong ( endian , exif + 4 ) ; if ( ( offset < 0 ) || ( size_t ) offset >= length ) return ( MagickFalse ) ; status = MagickFalse ; directory = exif + offset ; level = 0 ; entry = 0 ; tag_offset = 0 ; exif_resources = NewSplayTree ( ( int ( * ) ( const void * , const void * ) ) NULL , ( void * ( * ) ( void * ) ) NULL , ( void * ( * ) ( void * ) ) NULL ) ; do { if ( level > 0 ) { level -- ; directory = directory_stack [ level ] . directory ; entry = directory_stack [ level ] . entry ; tag_offset = directory_stack [ level ] . offset ; } if ( ( directory < exif ) || ( directory > ( exif + length - 2 ) ) ) break ; number_entries = ( size_t ) ReadPropertyUnsignedShort ( endian , directory ) ; for ( ; entry < number_entries ; entry ++ ) { register unsigned char * p , * q ; size_t format ; ssize_t number_bytes , components ; q = ( unsigned char * ) ( directory + ( 12 * entry ) + 2 ) ; <S2SV_StartBug> if ( GetValueFromSplayTree ( exif_resources , q ) == q ) <S2SV_EndBug> break ; ( void ) AddValueToSplayTree ( exif_resources , q , q ) ; tag_value = ( size_t ) ReadPropertyUnsignedShort ( endian , q ) + tag_offset ; format = ( size_t ) ReadPropertyUnsignedShort ( endian , q + 2 ) ; if ( format >= ( sizeof ( tag_bytes ) / sizeof ( * tag_bytes ) ) ) break ; <S2SV_StartBug> components = ( ssize_t ) ReadPropertySignedLong ( endian , q + 4 ) ; <S2SV_EndBug> number_bytes = ( size_t ) components * tag_bytes [ format ] ; if ( number_bytes < components ) break ; if ( number_bytes <= 4 ) p = q + 8 ; else { ssize_t offset ; offset = ( ssize_t ) ReadPropertySignedLong ( endian , q + 8 ) ; if ( ( offset < 0 ) || ( size_t ) offset >= length ) continue ; if ( ( ssize_t ) ( offset + number_bytes ) < offset ) continue ; if ( ( size_t ) ( offset + number_bytes ) > length ) continue ; p = ( unsigned char * ) ( exif + offset ) ; } if ( ( all != 0 ) || ( tag == ( size_t ) tag_value ) ) { char buffer [ MagickPathExtent ] , * value ; value = ( char * ) NULL ; * buffer = '\\0' ; switch ( format ) { case EXIF_FMT_BYTE : case EXIF_FMT_UNDEFINED : { EXIFMultipleValues ( 1 , ""%.20g"" , ( double ) ( * ( unsigned char * ) p1 ) ) ; break ; } case EXIF_FMT_SBYTE : { EXIFMultipleValues ( 1 , ""%.20g"" , ( double ) ( * ( signed char * ) p1 ) ) ; break ; } case EXIF_FMT_SSHORT : { EXIFMultipleValues ( 2 , ""%hd"" , ReadPropertySignedShort ( endian , p1 ) ) ; break ; } case EXIF_FMT_USHORT : { EXIFMultipleValues ( 2 , ""%hu"" , ReadPropertyUnsignedShort ( endian , p1 ) ) ; break ; } case EXIF_FMT_ULONG : { EXIFMultipleValues ( 4 , ""%.20g"" , ( double ) ReadPropertyUnsignedLong ( endian , p1 ) ) ; break ; } case EXIF_FMT_SLONG : { EXIFMultipleValues ( 4 , ""%.20g"" , ( double ) ReadPropertySignedLong ( endian , p1 ) ) ; break ; } case EXIF_FMT_URATIONAL : { EXIFMultipleFractions ( 8 , ""%.20g/%.20g"" , ( double ) ReadPropertyUnsignedLong ( endian , p1 ) , ( double ) ReadPropertyUnsignedLong ( endian , p1 + 4 ) ) ; break ; } case EXIF_FMT_SRATIONAL : { EXIFMultipleFractions ( 8 , ""%.20g/%.20g"" , ( double ) ReadPropertySignedLong ( endian , p1 ) , ( double ) ReadPropertySignedLong ( endian , p1 + 4 ) ) ; break ; } case EXIF_FMT_SINGLE : { EXIFMultipleValues ( 4 , ""%f"" , ( double ) * ( float * ) p1 ) ; break ; } case EXIF_FMT_DOUBLE : { EXIFMultipleValues ( 8 , ""%f"" , * ( double * ) p1 ) ; break ; } default : case EXIF_FMT_STRING : { value = ( char * ) NULL ; if ( ~ ( ( size_t ) number_bytes ) >= 1 ) value = ( char * ) AcquireQuantumMemory ( ( size_t ) number_bytes + 1UL , sizeof ( * value ) ) ; if ( value != ( char * ) NULL ) { register ssize_t i ; for ( i = 0 ; i < ( ssize_t ) number_bytes ; i ++ ) { value [ i ] = '.' ; if ( ( isprint ( ( int ) p [ i ] ) != 0 ) || ( p [ i ] == '\\0' ) ) value [ i ] = ( char ) p [ i ] ; } value [ i ] = '\\0' ; } break ; } } if ( value != ( char * ) NULL ) { char * key ; register const char * p ; key = AcquireString ( property ) ; switch ( all ) { case 1 : { const char * description ; register ssize_t i ; description = ""unknown"" ; for ( i = 0 ; ; i ++ ) { if ( EXIFTag [ i ] . tag == 0 ) break ; if ( EXIFTag [ i ] . tag == tag_value ) { description = EXIFTag [ i ] . description ; break ; } } ( void ) FormatLocaleString ( key , MagickPathExtent , ""%s"" , description ) ; if ( level == 2 ) ( void ) SubstituteString ( & key , ""exif:"" , ""exif:thumbnail:"" ) ; break ; } case 2 : { if ( tag_value < 0x10000 ) ( void ) FormatLocaleString ( key , MagickPathExtent , ""#%04lx"" , ( unsigned long ) tag_value ) ; else if ( tag_value < 0x20000 ) ( void ) FormatLocaleString ( key , MagickPathExtent , ""@%04lx"" , ( unsigned long ) ( tag_value & 0xffff ) ) ; else ( void ) FormatLocaleString ( key , MagickPathExtent , ""unknown"" ) ; break ; } default : { if ( level == 2 ) ( void ) SubstituteString ( & key , ""exif:"" , ""exif:thumbnail:"" ) ; } } p = ( const char * ) NULL ; if ( image -> properties != ( void * ) NULL ) p = ( const char * ) GetValueFromSplayTree ( ( SplayTreeInfo * ) image -> properties , key ) ; if ( p == ( const char * ) NULL ) ( void ) SetImageProperty ( ( Image * ) image , key , value , exception ) ; value = DestroyString ( value ) ; key = DestroyString ( key ) ; status = MagickTrue ; } } if ( ( tag_value == TAG_EXIF_OFFSET ) || ( tag_value == TAG_INTEROP_OFFSET ) || ( tag_value == TAG_GPS_OFFSET ) ) { ssize_t offset ; offset = ( ssize_t ) ReadPropertySignedLong ( endian , p ) ; if ( ( ( size_t ) offset < length ) && ( level < ( MaxDirectoryStack - 2 ) ) ) { ssize_t tag_offset1 ; tag_offset1 = ( ssize_t ) ( ( tag_value == TAG_GPS_OFFSET ) ? 0x10000 : 0 ) ; directory_stack [ level ] . directory = directory ; entry ++ ; directory_stack [ level ] . entry = entry ; directory_stack [ level ] . offset = tag_offset ; level ++ ; directory_stack [ level ] . directory = exif + offset ; directory_stack [ level ] . offset = tag_offset1 ; directory_stack [ level ] . entry = 0 ; level ++ ; if ( ( directory + 2 + ( 12 * number_entries ) ) > ( exif + length ) ) break ; offset = ( ssize_t ) ReadPropertySignedLong ( endian , directory + 2 + ( 12 * number_entries ) ) ; if ( ( offset != 0 ) && ( ( size_t ) offset < length ) && ( level < ( MaxDirectoryStack - 2 ) ) ) { directory_stack [ level ] . directory = exif + offset ; directory_stack [ level ] . entry = 0 ; directory_stack [ level ] . offset = tag_offset1 ; level ++ ; } } break ; } } } while ( level > 0 ) ; exif_resources = DestroySplayTree ( exif_resources ) ; return ( status ) ; }",", arg ) \\\n{ <S2SV_ModEnd> ssize_t component ; <S2SV_ModStart> buffer ) ; \\\n} <S2SV_ModEnd> # define EXIFMultipleFractions <S2SV_ModStart> , arg2 ) \\\n{ <S2SV_ModEnd> ssize_t component ; <S2SV_ModStart> buffer ) ; \\\n} <S2SV_ModEnd> typedef struct _DirectoryInfo <S2SV_ModStart> ; if ( q > ( exif + length - 12 ) ) break ; if ( <S2SV_ModStart> + 4 ) ; if ( components < 0 ) break"
670,"void CLASS identify ( ) { static const short pana [ ] [ 6 ] = { { 3130 , 1743 , 4 , 0 , - 6 , 0 } , { 3130 , 2055 , 4 , 0 , - 6 , 0 } , { 3130 , 2319 , 4 , 0 , - 6 , 0 } , { 3170 , 2103 , 18 , 0 , - 42 , 20 } , { 3170 , 2367 , 18 , 13 , - 42 , - 21 } , { 3177 , 2367 , 0 , 0 , - 1 , 0 } , { 3304 , 2458 , 0 , 0 , - 1 , 0 } , { 3330 , 2463 , 9 , 0 , - 5 , 0 } , { 3330 , 2479 , 9 , 0 , - 17 , 4 } , { 3370 , 1899 , 15 , 0 , - 44 , 20 } , { 3370 , 2235 , 15 , 0 , - 44 , 20 } , { 3370 , 2511 , 15 , 10 , - 44 , - 21 } , { 3690 , 2751 , 3 , 0 , - 8 , - 3 } , { 3710 , 2751 , 0 , 0 , - 3 , 0 } , { 3724 , 2450 , 0 , 0 , 0 , - 2 } , { 3770 , 2487 , 17 , 0 , - 44 , 19 } , { 3770 , 2799 , 17 , 15 , - 44 , - 19 } , { 3880 , 2170 , 6 , 0 , - 6 , 0 } , { 4060 , 3018 , 0 , 0 , 0 , - 2 } , { 4290 , 2391 , 3 , 0 , - 8 , - 1 } , { 4330 , 2439 , 17 , 15 , - 44 , - 19 } , { 4508 , 2962 , 0 , 0 , - 3 , - 4 } , { 4508 , 3330 , 0 , 0 , - 3 , - 6 } , } ; static const ushort canon [ ] [ 11 ] = { { 1944 , 1416 , 0 , 0 , 48 , 0 } , { 2144 , 1560 , 4 , 8 , 52 , 2 , 0 , 0 , 0 , 25 } , { 2224 , 1456 , 48 , 6 , 0 , 2 } , { 2376 , 1728 , 12 , 6 , 52 , 2 } , { 2672 , 1968 , 12 , 6 , 44 , 2 } , { 3152 , 2068 , 64 , 12 , 0 , 0 , 16 } , { 3160 , 2344 , 44 , 12 , 4 , 4 } , { 3344 , 2484 , 4 , 6 , 52 , 6 } , { 3516 , 2328 , 42 , 14 , 0 , 0 } , { 3596 , 2360 , 74 , 12 , 0 , 0 } , { 3744 , 2784 , 52 , 12 , 8 , 12 } , { 3944 , 2622 , 30 , 18 , 6 , 2 } , { 3948 , 2622 , 42 , 18 , 0 , 2 } , { 3984 , 2622 , 76 , 20 , 0 , 2 , 14 } , { 4104 , 3048 , 48 , 12 , 24 , 12 } , { 4116 , 2178 , 4 , 2 , 0 , 0 } , { 4152 , 2772 , 192 , 12 , 0 , 0 } , { 4160 , 3124 , 104 , 11 , 8 , 65 } , { 4176 , 3062 , 96 , 17 , 8 , 0 , 0 , 16 , 0 , 7 , 0x49 } , { 4192 , 3062 , 96 , 17 , 24 , 0 , 0 , 16 , 0 , 0 , 0x49 } , { 4312 , 2876 , 22 , 18 , 0 , 2 } , { 4352 , 2874 , 62 , 18 , 0 , 0 } , { 4476 , 2954 , 90 , 34 , 0 , 0 } , { 4480 , 3348 , 12 , 10 , 36 , 12 , 0 , 0 , 0 , 18 , 0x49 } , { 4480 , 3366 , 80 , 50 , 0 , 0 } , { 4496 , 3366 , 80 , 50 , 12 , 0 } , { 4768 , 3516 , 96 , 16 , 0 , 0 , 0 , 16 } , { 4832 , 3204 , 62 , 26 , 0 , 0 } , { 4832 , 3228 , 62 , 51 , 0 , 0 } , { 5108 , 3349 , 98 , 13 , 0 , 0 } , { 5120 , 3318 , 142 , 45 , 62 , 0 } , { 5280 , 3528 , 72 , 52 , 0 , 0 } , { 5344 , 3516 , 142 , 51 , 0 , 0 } , { 5344 , 3584 , 126 , 100 , 0 , 2 } , { 5360 , 3516 , 158 , 51 , 0 , 0 } , { 5568 , 3708 , 72 , 38 , 0 , 0 } , { 5632 , 3710 , 96 , 17 , 0 , 0 , 0 , 16 , 0 , 0 , 0x49 } , { 5712 , 3774 , 62 , 20 , 10 , 2 } , { 5792 , 3804 , 158 , 51 , 0 , 0 } , { 5920 , 3950 , 122 , 80 , 2 , 0 } , { 6096 , 4056 , 72 , 34 , 0 , 0 } , { 6288 , 4056 , 266 , 36 , 0 , 0 } , { 6384 , 4224 , 120 , 44 , 0 , 0 } , { 6880 , 4544 , 136 , 42 , 0 , 0 } , { 8896 , 5920 , 160 , 64 , 0 , 0 } , } ; static const struct { ushort id ; char t_model [ 20 ] ; } unique [ ] = { { 0x001 , ""EOS-1D"" } , { 0x167 , ""EOS-1DS"" } , { 0x168 , ""EOS<S2SV_blank>10D"" } , { 0x169 , ""EOS-1D<S2SV_blank>Mark<S2SV_blank>III"" } , { 0x170 , ""EOS<S2SV_blank>300D"" } , { 0x174 , ""EOS-1D<S2SV_blank>Mark<S2SV_blank>II"" } , { 0x175 , ""EOS<S2SV_blank>20D"" } , { 0x176 , ""EOS<S2SV_blank>450D"" } , { 0x188 , ""EOS-1Ds<S2SV_blank>Mark<S2SV_blank>II"" } , { 0x189 , ""EOS<S2SV_blank>350D"" } , { 0x190 , ""EOS<S2SV_blank>40D"" } , { 0x213 , ""EOS<S2SV_blank>5D"" } , { 0x215 , ""EOS-1Ds<S2SV_blank>Mark<S2SV_blank>III"" } , { 0x218 , ""EOS<S2SV_blank>5D<S2SV_blank>Mark<S2SV_blank>II"" } , { 0x232 , ""EOS-1D<S2SV_blank>Mark<S2SV_blank>II<S2SV_blank>N"" } , { 0x234 , ""EOS<S2SV_blank>30D"" } , { 0x236 , ""EOS<S2SV_blank>400D"" } , { 0x250 , ""EOS<S2SV_blank>7D"" } , { 0x252 , ""EOS<S2SV_blank>500D"" } , { 0x254 , ""EOS<S2SV_blank>1000D"" } , { 0x261 , ""EOS<S2SV_blank>50D"" } , { 0x269 , ""EOS-1D<S2SV_blank>X"" } , { 0x270 , ""EOS<S2SV_blank>550D"" } , { 0x281 , ""EOS-1D<S2SV_blank>Mark<S2SV_blank>IV"" } , { 0x285 , ""EOS<S2SV_blank>5D<S2SV_blank>Mark<S2SV_blank>III"" } , { 0x286 , ""EOS<S2SV_blank>600D"" } , { 0x287 , ""EOS<S2SV_blank>60D"" } , { 0x288 , ""EOS<S2SV_blank>1100D"" } , { 0x289 , ""EOS<S2SV_blank>7D<S2SV_blank>Mark<S2SV_blank>II"" } , { 0x301 , ""EOS<S2SV_blank>650D"" } , { 0x302 , ""EOS<S2SV_blank>6D"" } , { 0x324 , ""EOS-1D<S2SV_blank>C"" } , { 0x325 , ""EOS<S2SV_blank>70D"" } , { 0x326 , ""EOS<S2SV_blank>700D"" } , { 0x327 , ""EOS<S2SV_blank>1200D"" } , { 0x328 , ""EOS-1D<S2SV_blank>X<S2SV_blank>Mark<S2SV_blank>II"" } , { 0x331 , ""EOS<S2SV_blank>M"" } , { 0x335 , ""EOS<S2SV_blank>M2"" } , { 0x374 , ""EOS<S2SV_blank>M3"" } , { 0x384 , ""EOS<S2SV_blank>M10"" } , { 0x394 , ""EOS<S2SV_blank>M5"" } , { 0x398 , ""EOS<S2SV_blank>M100"" } , { 0x346 , ""EOS<S2SV_blank>100D"" } , { 0x347 , ""EOS<S2SV_blank>760D"" } , { 0x349 , ""EOS<S2SV_blank>5D<S2SV_blank>Mark<S2SV_blank>IV"" } , { 0x350 , ""EOS<S2SV_blank>80D"" } , { 0x382 , ""EOS<S2SV_blank>5DS"" } , { 0x393 , ""EOS<S2SV_blank>750D"" } , { 0x401 , ""EOS<S2SV_blank>5DS<S2SV_blank>R"" } , { 0x404 , ""EOS<S2SV_blank>1300D"" } , { 0x405 , ""EOS<S2SV_blank>800D"" } , { 0x406 , ""EOS<S2SV_blank>6D<S2SV_blank>Mark<S2SV_blank>II"" } , { 0x407 , ""EOS<S2SV_blank>M6"" } , { 0x408 , ""EOS<S2SV_blank>77D"" } , { 0x417 , ""EOS<S2SV_blank>200D"" } , } , sonique [ ] = { { 0x002 , ""DSC-R1"" } , { 0x100 , ""DSLR-A100"" } , { 0x101 , ""DSLR-A900"" } , { 0x102 , ""DSLR-A700"" } , { 0x103 , ""DSLR-A200"" } , { 0x104 , ""DSLR-A350"" } , { 0x105 , ""DSLR-A300"" } , { 0x106 , ""DSLR-A900"" } , { 0x107 , ""DSLR-A380"" } , { 0x108 , ""DSLR-A330"" } , { 0x109 , ""DSLR-A230"" } , { 0x10a , ""DSLR-A290"" } , { 0x10d , ""DSLR-A850"" } , { 0x10e , ""DSLR-A850"" } , { 0x111 , ""DSLR-A550"" } , { 0x112 , ""DSLR-A500"" } , { 0x113 , ""DSLR-A450"" } , { 0x116 , ""NEX-5"" } , { 0x117 , ""NEX-3"" } , { 0x118 , ""SLT-A33"" } , { 0x119 , ""SLT-A55V"" } , { 0x11a , ""DSLR-A560"" } , { 0x11b , ""DSLR-A580"" } , { 0x11c , ""NEX-C3"" } , { 0x11d , ""SLT-A35"" } , { 0x11e , ""SLT-A65V"" } , { 0x11f , ""SLT-A77V"" } , { 0x120 , ""NEX-5N"" } , { 0x121 , ""NEX-7"" } , { 0x122 , ""NEX-VG20E"" } , { 0x123 , ""SLT-A37"" } , { 0x124 , ""SLT-A57"" } , { 0x125 , ""NEX-F3"" } , { 0x126 , ""SLT-A99V"" } , { 0x127 , ""NEX-6"" } , { 0x128 , ""NEX-5R"" } , { 0x129 , ""DSC-RX100"" } , { 0x12a , ""DSC-RX1"" } , { 0x12b , ""NEX-VG900"" } , { 0x12c , ""NEX-VG30E"" } , { 0x12e , ""ILCE-3000"" } , { 0x12f , ""SLT-A58"" } , { 0x131 , ""NEX-3N"" } , { 0x132 , ""ILCE-7"" } , { 0x133 , ""NEX-5T"" } , { 0x134 , ""DSC-RX100M2"" } , { 0x135 , ""DSC-RX10"" } , { 0x136 , ""DSC-RX1R"" } , { 0x137 , ""ILCE-7R"" } , { 0x138 , ""ILCE-6000"" } , { 0x139 , ""ILCE-5000"" } , { 0x13d , ""DSC-RX100M3"" } , { 0x13e , ""ILCE-7S"" } , { 0x13f , ""ILCA-77M2"" } , { 0x153 , ""ILCE-5100"" } , { 0x154 , ""ILCE-7M2"" } , { 0x155 , ""DSC-RX100M4"" } , { 0x156 , ""DSC-RX10M2"" } , { 0x158 , ""DSC-RX1RM2"" } , { 0x15a , ""ILCE-QX1"" } , { 0x15b , ""ILCE-7RM2"" } , { 0x15e , ""ILCE-7SM2"" } , { 0x161 , ""ILCA-68"" } , { 0x162 , ""ILCA-99M2"" } , { 0x163 , ""DSC-RX10M3"" } , { 0x164 , ""DSC-RX100M5"" } , { 0x165 , ""ILCE-6300"" } , { 0x166 , ""ILCE-9"" } , { 0x168 , ""ILCE-6500"" } , { 0x16a , ""ILCE-7RM3"" } , { 0x16c , ""DSC-RX0"" } , { 0x16d , ""DSC-RX10M4"" } , } ; # ifdef LIBRAW_LIBRARY_BUILD static const libraw_custom_camera_t const_table [ ] # else static const struct { unsigned fsize ; ushort rw , rh ; uchar lm , tm , rm , bm , lf , cf , max , flags ; char t_make [ 10 ] , t_model [ 20 ] ; ushort offset ; } table [ ] # endif = { { 786432 , 1024 , 768 , 0 , 0 , 0 , 0 , 0 , 0x94 , 0 , 0 , ""AVT"" , ""F-080C"" } , { 1447680 , 1392 , 1040 , 0 , 0 , 0 , 0 , 0 , 0x94 , 0 , 0 , ""AVT"" , ""F-145C"" } , { 1920000 , 1600 , 1200 , 0 , 0 , 0 , 0 , 0 , 0x94 , 0 , 0 , ""AVT"" , ""F-201C"" } , { 5067304 , 2588 , 1958 , 0 , 0 , 0 , 0 , 0 , 0x94 , 0 , 0 , ""AVT"" , ""F-510C"" } , { 5067316 , 2588 , 1958 , 0 , 0 , 0 , 0 , 0 , 0x94 , 0 , 0 , ""AVT"" , ""F-510C"" , 12 } , { 10134608 , 2588 , 1958 , 0 , 0 , 0 , 0 , 9 , 0x94 , 0 , 0 , ""AVT"" , ""F-510C"" } , { 10134620 , 2588 , 1958 , 0 , 0 , 0 , 0 , 9 , 0x94 , 0 , 0 , ""AVT"" , ""F-510C"" , 12 } , { 16157136 , 3272 , 2469 , 0 , 0 , 0 , 0 , 9 , 0x94 , 0 , 0 , ""AVT"" , ""F-810C"" } , { 15980544 , 3264 , 2448 , 0 , 0 , 0 , 0 , 8 , 0x61 , 0 , 1 , ""AgfaPhoto"" , ""DC-833m"" } , { 9631728 , 2532 , 1902 , 0 , 0 , 0 , 0 , 96 , 0x61 , 0 , 0 , ""Alcatel"" , ""5035D"" } , { 31850496 , 4608 , 3456 , 0 , 0 , 0 , 0 , 0 , 0x94 , 0 , 0 , ""GITUP"" , ""GIT2<S2SV_blank>4:3"" } , { 23887872 , 4608 , 2592 , 0 , 0 , 0 , 0 , 0 , 0x94 , 0 , 0 , ""GITUP"" , ""GIT2<S2SV_blank>16:9"" } , { 32257024 , 4624 , 3488 , 8 , 2 , 16 , 2 , 0 , 0x94 , 0 , 0 , ""GITUP"" , ""GIT2P<S2SV_blank>4:3"" } , { 1540857 , 2688 , 1520 , 0 , 0 , 0 , 0 , 1 , 0x61 , 0 , 0 , ""Samsung"" , ""S3"" } , { 2658304 , 1212 , 1096 , 0 , 0 , 0 , 0 , 1 , 0x16 , 0 , 0 , ""LG"" , ""G3FrontMipi"" } , { 2842624 , 1296 , 1096 , 0 , 0 , 0 , 0 , 1 , 0x16 , 0 , 0 , ""LG"" , ""G3FrontQCOM"" } , { 2969600 , 1976 , 1200 , 0 , 0 , 0 , 0 , 1 , 0x16 , 0 , 0 , ""Xiaomi"" , ""MI3wMipi"" } , { 3170304 , 1976 , 1200 , 0 , 0 , 0 , 0 , 1 , 0x16 , 0 , 0 , ""Xiaomi"" , ""MI3wQCOM"" } , { 3763584 , 1584 , 1184 , 0 , 0 , 0 , 0 , 96 , 0x61 , 0 , 0 , ""I_Mobile"" , ""I_StyleQ6"" } , { 5107712 , 2688 , 1520 , 0 , 0 , 0 , 0 , 1 , 0x61 , 0 , 0 , ""OmniVisi"" , ""UltraPixel1"" } , { 5382640 , 2688 , 1520 , 0 , 0 , 0 , 0 , 1 , 0x61 , 0 , 0 , ""OmniVisi"" , ""UltraPixel2"" } , { 5664912 , 2688 , 1520 , 0 , 0 , 0 , 0 , 1 , 0x61 , 0 , 0 , ""OmniVisi"" , ""4688"" } , { 5664912 , 2688 , 1520 , 0 , 0 , 0 , 0 , 1 , 0x61 , 0 , 0 , ""OmniVisi"" , ""4688"" } , { 5364240 , 2688 , 1520 , 0 , 0 , 0 , 0 , 1 , 0x61 , 0 , 0 , ""OmniVisi"" , ""4688"" } , { 6299648 , 2592 , 1944 , 0 , 0 , 0 , 0 , 1 , 0x16 , 0 , 0 , ""OmniVisi"" , ""OV5648"" } , { 6721536 , 2592 , 1944 , 0 , 0 , 0 , 0 , 0 , 0x16 , 0 , 0 , ""OmniVisi"" , ""OV56482"" } , { 6746112 , 2592 , 1944 , 0 , 0 , 0 , 0 , 0 , 0x16 , 0 , 0 , ""HTC"" , ""OneSV"" } , { 9631728 , 2532 , 1902 , 0 , 0 , 0 , 0 , 96 , 0x61 , 0 , 0 , ""Sony"" , ""5mp"" } , { 9830400 , 2560 , 1920 , 0 , 0 , 0 , 0 , 96 , 0x61 , 0 , 0 , ""NGM"" , ""ForwardArt"" } , { 10186752 , 3264 , 2448 , 0 , 0 , 0 , 0 , 1 , 0x94 , 0 , 0 , ""Sony"" , ""IMX219-mipi<S2SV_blank>8mp"" } , { 10223360 , 2608 , 1944 , 0 , 0 , 0 , 0 , 96 , 0x16 , 0 , 0 , ""Sony"" , ""IMX"" } , { 10782464 , 3282 , 2448 , 0 , 0 , 0 , 0 , 0 , 0x16 , 0 , 0 , ""HTC"" , ""MyTouch4GSlide"" } , { 10788864 , 3282 , 2448 , 0 , 0 , 0 , 0 , 0 , 0x16 , 0 , 0 , ""Xperia"" , ""L"" } , { 15967488 , 3264 , 2446 , 0 , 0 , 0 , 0 , 96 , 0x16 , 0 , 0 , ""OmniVison"" , ""OV8850"" } , { 16224256 , 4208 , 3082 , 0 , 0 , 0 , 0 , 1 , 0x16 , 0 , 0 , ""LG"" , ""G3MipiL"" } , { 16424960 , 4208 , 3120 , 0 , 0 , 0 , 0 , 1 , 0x16 , 0 , 0 , ""IMX135"" , ""MipiL"" } , { 17326080 , 4164 , 3120 , 0 , 0 , 0 , 0 , 1 , 0x16 , 0 , 0 , ""LG"" , ""G3LQCom"" } , { 17522688 , 4212 , 3120 , 0 , 0 , 0 , 0 , 0 , 0x16 , 0 , 0 , ""Sony"" , ""IMX135-QCOM"" } , { 19906560 , 4608 , 3456 , 0 , 0 , 0 , 0 , 1 , 0x16 , 0 , 0 , ""Gione"" , ""E7mipi"" } , { 19976192 , 5312 , 2988 , 0 , 0 , 0 , 0 , 1 , 0x16 , 0 , 0 , ""LG"" , ""G4"" } , { 20389888 , 4632 , 3480 , 0 , 0 , 0 , 0 , 1 , 0x16 , 0 , 0 , ""Xiaomi"" , ""RedmiNote3Pro"" } , { 20500480 , 4656 , 3496 , 0 , 0 , 0 , 0 , 1 , 0x94 , 0 , 0 , ""Sony"" , ""IMX298-mipi<S2SV_blank>16mp"" } , { 21233664 , 4608 , 3456 , 0 , 0 , 0 , 0 , 1 , 0x16 , 0 , 0 , ""Gione"" , ""E7qcom"" } , { 26023936 , 4192 , 3104 , 0 , 0 , 0 , 0 , 96 , 0x94 , 0 , 0 , ""THL"" , ""5000"" } , { 26257920 , 4208 , 3120 , 0 , 0 , 0 , 0 , 96 , 0x94 , 0 , 0 , ""Sony"" , ""IMX214"" } , { 26357760 , 4224 , 3120 , 0 , 0 , 0 , 0 , 96 , 0x61 , 0 , 0 , ""OV"" , ""13860"" } , { 41312256 , 5248 , 3936 , 0 , 0 , 0 , 0 , 96 , 0x61 , 0 , 0 , ""Meizu"" , ""MX4"" } , { 42923008 , 5344 , 4016 , 0 , 0 , 0 , 0 , 96 , 0x61 , 0 , 0 , ""Sony"" , ""IMX230"" } , { 20137344 , 3664 , 2748 , 0 , 0 , 0 , 0 , 0x40 , 0x49 , 0 , 0 , ""Aptina"" , ""MT9J003"" , 0xffff } , { 2868726 , 1384 , 1036 , 0 , 0 , 0 , 0 , 64 , 0x49 , 0 , 8 , ""Baumer"" , ""TXG14"" , 1078 } , { 5298000 , 2400 , 1766 , 12 , 12 , 44 , 2 , 40 , 0x94 , 0 , 2 , ""Canon"" , ""PowerShot<S2SV_blank>SD300"" } , { 6553440 , 2664 , 1968 , 4 , 4 , 44 , 4 , 40 , 0x94 , 0 , 2 , ""Canon"" , ""PowerShot<S2SV_blank>A460"" } , { 6573120 , 2672 , 1968 , 12 , 8 , 44 , 0 , 40 , 0x94 , 0 , 2 , ""Canon"" , ""PowerShot<S2SV_blank>A610"" } , { 6653280 , 2672 , 1992 , 10 , 6 , 42 , 2 , 40 , 0x94 , 0 , 2 , ""Canon"" , ""PowerShot<S2SV_blank>A530"" } , { 7710960 , 2888 , 2136 , 44 , 8 , 4 , 0 , 40 , 0x94 , 0 , 2 , ""Canon"" , ""PowerShot<S2SV_blank>S3<S2SV_blank>IS"" } , { 9219600 , 3152 , 2340 , 36 , 12 , 4 , 0 , 40 , 0x94 , 0 , 2 , ""Canon"" , ""PowerShot<S2SV_blank>A620"" } , { 9243240 , 3152 , 2346 , 12 , 7 , 44 , 13 , 40 , 0x49 , 0 , 2 , ""Canon"" , ""PowerShot<S2SV_blank>A470"" } , { 10341600 , 3336 , 2480 , 6 , 5 , 32 , 3 , 40 , 0x94 , 0 , 2 , ""Canon"" , ""PowerShot<S2SV_blank>A720<S2SV_blank>IS"" } , { 10383120 , 3344 , 2484 , 12 , 6 , 44 , 6 , 40 , 0x94 , 0 , 2 , ""Canon"" , ""PowerShot<S2SV_blank>A630"" } , { 12945240 , 3736 , 2772 , 12 , 6 , 52 , 6 , 40 , 0x94 , 0 , 2 , ""Canon"" , ""PowerShot<S2SV_blank>A640"" } , { 15636240 , 4104 , 3048 , 48 , 12 , 24 , 12 , 40 , 0x94 , 0 , 2 , ""Canon"" , ""PowerShot<S2SV_blank>A650"" } , { 15467760 , 3720 , 2772 , 6 , 12 , 30 , 0 , 40 , 0x94 , 0 , 2 , ""Canon"" , ""PowerShot<S2SV_blank>SX110<S2SV_blank>IS"" } , { 15534576 , 3728 , 2778 , 12 , 9 , 44 , 9 , 40 , 0x94 , 0 , 2 , ""Canon"" , ""PowerShot<S2SV_blank>SX120<S2SV_blank>IS"" } , { 18653760 , 4080 , 3048 , 24 , 12 , 24 , 12 , 40 , 0x94 , 0 , 2 , ""Canon"" , ""PowerShot<S2SV_blank>SX20<S2SV_blank>IS"" } , { 18763488 , 4104 , 3048 , 10 , 22 , 82 , 22 , 8 , 0x49 , 0 , 0 , ""Canon"" , ""PowerShot<S2SV_blank>D10"" } , { 19131120 , 4168 , 3060 , 92 , 16 , 4 , 1 , 40 , 0x94 , 0 , 2 , ""Canon"" , ""PowerShot<S2SV_blank>SX220<S2SV_blank>HS"" } , { 21936096 , 4464 , 3276 , 25 , 10 , 73 , 12 , 40 , 0x16 , 0 , 2 , ""Canon"" , ""PowerShot<S2SV_blank>SX30<S2SV_blank>IS"" } , { 24724224 , 4704 , 3504 , 8 , 16 , 56 , 8 , 40 , 0x49 , 0 , 2 , ""Canon"" , ""PowerShot<S2SV_blank>A3300<S2SV_blank>IS"" } , { 30858240 , 5248 , 3920 , 8 , 16 , 56 , 16 , 40 , 0x94 , 0 , 2 , ""Canon"" , ""IXUS<S2SV_blank>160"" } , { 1976352 , 1632 , 1211 , 0 , 2 , 0 , 1 , 0 , 0x94 , 0 , 1 , ""Casio"" , ""QV-2000UX"" } , { 3217760 , 2080 , 1547 , 0 , 0 , 10 , 1 , 0 , 0x94 , 0 , 1 , ""Casio"" , ""QV-3*00EX"" } , { 6218368 , 2585 , 1924 , 0 , 0 , 9 , 0 , 0 , 0x94 , 0 , 1 , ""Casio"" , ""QV-5700"" } , { 7816704 , 2867 , 2181 , 0 , 0 , 34 , 36 , 0 , 0x16 , 0 , 1 , ""Casio"" , ""EX-Z60"" } , { 2937856 , 1621 , 1208 , 0 , 0 , 1 , 0 , 0 , 0x94 , 7 , 13 , ""Casio"" , ""EX-S20"" } , { 4948608 , 2090 , 1578 , 0 , 0 , 32 , 34 , 0 , 0x94 , 7 , 1 , ""Casio"" , ""EX-S100"" } , { 6054400 , 2346 , 1720 , 2 , 0 , 32 , 0 , 0 , 0x94 , 7 , 1 , ""Casio"" , ""QV-R41"" } , { 7426656 , 2568 , 1928 , 0 , 0 , 0 , 0 , 0 , 0x94 , 0 , 1 , ""Casio"" , ""EX-P505"" } , { 7530816 , 2602 , 1929 , 0 , 0 , 22 , 0 , 0 , 0x94 , 7 , 1 , ""Casio"" , ""QV-R51"" } , { 7542528 , 2602 , 1932 , 0 , 0 , 32 , 0 , 0 , 0x94 , 7 , 1 , ""Casio"" , ""EX-Z50"" } , { 7562048 , 2602 , 1937 , 0 , 0 , 25 , 0 , 0 , 0x16 , 7 , 1 , ""Casio"" , ""EX-Z500"" } , { 7753344 , 2602 , 1986 , 0 , 0 , 32 , 26 , 0 , 0x94 , 7 , 1 , ""Casio"" , ""EX-Z55"" } , { 9313536 , 2858 , 2172 , 0 , 0 , 14 , 30 , 0 , 0x94 , 7 , 1 , ""Casio"" , ""EX-P600"" } , { 10834368 , 3114 , 2319 , 0 , 0 , 27 , 0 , 0 , 0x94 , 0 , 1 , ""Casio"" , ""EX-Z750"" } , { 10843712 , 3114 , 2321 , 0 , 0 , 25 , 0 , 0 , 0x94 , 0 , 1 , ""Casio"" , ""EX-Z75"" } , { 10979200 , 3114 , 2350 , 0 , 0 , 32 , 32 , 0 , 0x94 , 7 , 1 , ""Casio"" , ""EX-P700"" } , { 12310144 , 3285 , 2498 , 0 , 0 , 6 , 30 , 0 , 0x94 , 0 , 1 , ""Casio"" , ""EX-Z850"" } , { 12489984 , 3328 , 2502 , 0 , 0 , 47 , 35 , 0 , 0x94 , 0 , 1 , ""Casio"" , ""EX-Z8"" } , { 15499264 , 3754 , 2752 , 0 , 0 , 82 , 0 , 0 , 0x94 , 0 , 1 , ""Casio"" , ""EX-Z1050"" } , { 18702336 , 4096 , 3044 , 0 , 0 , 24 , 0 , 80 , 0x94 , 7 , 1 , ""Casio"" , ""EX-ZR100"" } , { 7684000 , 2260 , 1700 , 0 , 0 , 0 , 0 , 13 , 0x94 , 0 , 1 , ""Casio"" , ""QV-4000"" } , { 787456 , 1024 , 769 , 0 , 1 , 0 , 0 , 0 , 0x49 , 0 , 0 , ""Creative"" , ""PC-CAM<S2SV_blank>600"" } , { 28829184 , 4384 , 3288 , 0 , 0 , 0 , 0 , 36 , 0x61 , 0 , 0 , ""DJI"" } , { 15151104 , 4608 , 3288 , 0 , 0 , 0 , 0 , 0 , 0x94 , 0 , 0 , ""Matrix"" } , { 3840000 , 1600 , 1200 , 0 , 0 , 0 , 0 , 65 , 0x49 , 0 , 0 , ""Foculus"" , ""531C"" } , { 307200 , 640 , 480 , 0 , 0 , 0 , 0 , 0 , 0x94 , 0 , 0 , ""Generic"" } , { 62464 , 256 , 244 , 1 , 1 , 6 , 1 , 0 , 0x8d , 0 , 0 , ""Kodak"" , ""DC20"" } , { 124928 , 512 , 244 , 1 , 1 , 10 , 1 , 0 , 0x8d , 0 , 0 , ""Kodak"" , ""DC20"" } , { 1652736 , 1536 , 1076 , 0 , 52 , 0 , 0 , 0 , 0x61 , 0 , 0 , ""Kodak"" , ""DCS200"" } , { 4159302 , 2338 , 1779 , 1 , 33 , 1 , 2 , 0 , 0x94 , 0 , 0 , ""Kodak"" , ""C330"" } , { 4162462 , 2338 , 1779 , 1 , 33 , 1 , 2 , 0 , 0x94 , 0 , 0 , ""Kodak"" , ""C330"" , 3160 } , { 2247168 , 1232 , 912 , 0 , 0 , 16 , 0 , 0 , 0x00 , 0 , 0 , ""Kodak"" , ""C330"" } , { 3370752 , 1232 , 912 , 0 , 0 , 16 , 0 , 0 , 0x00 , 0 , 0 , ""Kodak"" , ""C330"" } , { 6163328 , 2864 , 2152 , 0 , 0 , 0 , 0 , 0 , 0x94 , 0 , 0 , ""Kodak"" , ""C603"" } , { 6166488 , 2864 , 2152 , 0 , 0 , 0 , 0 , 0 , 0x94 , 0 , 0 , ""Kodak"" , ""C603"" , 3160 } , { 460800 , 640 , 480 , 0 , 0 , 0 , 0 , 0 , 0x00 , 0 , 0 , ""Kodak"" , ""C603"" } , { 9116448 , 2848 , 2134 , 0 , 0 , 0 , 0 , 0 , 0x00 , 0 , 0 , ""Kodak"" , ""C603"" } , { 12241200 , 4040 , 3030 , 2 , 0 , 0 , 13 , 0 , 0x49 , 0 , 0 , ""Kodak"" , ""12MP"" } , { 12272756 , 4040 , 3030 , 2 , 0 , 0 , 13 , 0 , 0x49 , 0 , 0 , ""Kodak"" , ""12MP"" , 31556 } , { 18000000 , 4000 , 3000 , 0 , 0 , 0 , 0 , 0 , 0x00 , 0 , 0 , ""Kodak"" , ""12MP"" } , { 614400 , 640 , 480 , 0 , 3 , 0 , 0 , 64 , 0x94 , 0 , 0 , ""Kodak"" , ""KAI-0340"" } , { 15360000 , 3200 , 2400 , 0 , 0 , 0 , 0 , 96 , 0x16 , 0 , 0 , ""Lenovo"" , ""A820"" } , { 3884928 , 1608 , 1207 , 0 , 0 , 0 , 0 , 96 , 0x16 , 0 , 0 , ""Micron"" , ""2010"" , 3212 } , { 1138688 , 1534 , 986 , 0 , 0 , 0 , 0 , 0 , 0x61 , 0 , 0 , ""Minolta"" , ""RD175"" , 513 } , { 1581060 , 1305 , 969 , 0 , 0 , 18 , 6 , 6 , 0x1e , 4 , 1 , ""Nikon"" , ""E900"" } , { 2465792 , 1638 , 1204 , 0 , 0 , 22 , 1 , 6 , 0x4b , 5 , 1 , ""Nikon"" , ""E950"" } , { 2940928 , 1616 , 1213 , 0 , 0 , 0 , 7 , 30 , 0x94 , 0 , 1 , ""Nikon"" , ""E2100"" } , { 4771840 , 2064 , 1541 , 0 , 0 , 0 , 1 , 6 , 0xe1 , 0 , 1 , ""Nikon"" , ""E990"" } , { 4775936 , 2064 , 1542 , 0 , 0 , 0 , 0 , 30 , 0x94 , 0 , 1 , ""Nikon"" , ""E3700"" } , { 5865472 , 2288 , 1709 , 0 , 0 , 0 , 1 , 6 , 0xb4 , 0 , 1 , ""Nikon"" , ""E4500"" } , { 5869568 , 2288 , 1710 , 0 , 0 , 0 , 0 , 6 , 0x16 , 0 , 1 , ""Nikon"" , ""E4300"" } , { 7438336 , 2576 , 1925 , 0 , 0 , 0 , 1 , 6 , 0xb4 , 0 , 1 , ""Nikon"" , ""E5000"" } , { 8998912 , 2832 , 2118 , 0 , 0 , 0 , 0 , 30 , 0x94 , 7 , 1 , ""Nikon"" , ""COOLPIX<S2SV_blank>S6"" } , { 5939200 , 2304 , 1718 , 0 , 0 , 0 , 0 , 30 , 0x16 , 0 , 0 , ""Olympus"" , ""C770UZ"" } , { 3178560 , 2064 , 1540 , 0 , 0 , 0 , 0 , 0 , 0x94 , 0 , 1 , ""Pentax"" , ""Optio<S2SV_blank>S"" } , { 4841984 , 2090 , 1544 , 0 , 0 , 22 , 0 , 0 , 0x94 , 7 , 1 , ""Pentax"" , ""Optio<S2SV_blank>S"" } , { 6114240 , 2346 , 1737 , 0 , 0 , 22 , 0 , 0 , 0x94 , 7 , 1 , ""Pentax"" , ""Optio<S2SV_blank>S4"" } , { 10702848 , 3072 , 2322 , 0 , 0 , 0 , 21 , 30 , 0x94 , 0 , 1 , ""Pentax"" , ""Optio<S2SV_blank>750Z"" } , { 4147200 , 1920 , 1080 , 0 , 0 , 0 , 0 , 0 , 0x49 , 0 , 0 , ""Photron"" , ""BC2-HD"" } , { 4151666 , 1920 , 1080 , 0 , 0 , 0 , 0 , 0 , 0x49 , 0 , 0 , ""Photron"" , ""BC2-HD"" , 8 } , { 13248000 , 2208 , 3000 , 0 , 0 , 0 , 0 , 13 , 0x61 , 0 , 0 , ""Pixelink"" , ""A782"" } , { 6291456 , 2048 , 1536 , 0 , 0 , 0 , 0 , 96 , 0x61 , 0 , 0 , ""RoverShot"" , ""3320AF"" } , { 311696 , 644 , 484 , 0 , 0 , 0 , 0 , 0 , 0x16 , 0 , 8 , ""ST<S2SV_blank>Micro"" , ""STV680<S2SV_blank>VGA"" } , { 16098048 , 3288 , 2448 , 0 , 0 , 24 , 0 , 9 , 0x94 , 0 , 1 , ""Samsung"" , ""S85"" } , { 16215552 , 3312 , 2448 , 0 , 0 , 48 , 0 , 9 , 0x94 , 0 , 1 , ""Samsung"" , ""S85"" } , { 20487168 , 3648 , 2808 , 0 , 0 , 0 , 0 , 13 , 0x94 , 5 , 1 , ""Samsung"" , ""WB550"" } , { 24000000 , 4000 , 3000 , 0 , 0 , 0 , 0 , 13 , 0x94 , 5 , 1 , ""Samsung"" , ""WB550"" } , { 12582980 , 3072 , 2048 , 0 , 0 , 0 , 0 , 33 , 0x61 , 0 , 0 , ""Sinar"" , """" , 68 } , { 33292868 , 4080 , 4080 , 0 , 0 , 0 , 0 , 33 , 0x61 , 0 , 0 , ""Sinar"" , """" , 68 } , { 44390468 , 4080 , 5440 , 0 , 0 , 0 , 0 , 33 , 0x61 , 0 , 0 , ""Sinar"" , """" , 68 } , { 1409024 , 1376 , 1024 , 0 , 0 , 1 , 0 , 0 , 0x49 , 0 , 0 , ""Sony"" , ""XCD-SX910CR"" } , { 2818048 , 1376 , 1024 , 0 , 0 , 1 , 0 , 97 , 0x49 , 0 , 0 , ""Sony"" , ""XCD-SX910CR"" } , } ; # ifdef LIBRAW_LIBRARY_BUILD libraw_custom_camera_t table [ 64 + sizeof ( const_table ) / sizeof ( const_table [ 0 ] ) ] ; # endif static const char * corp [ ] = { ""AgfaPhoto"" , ""Canon"" , ""Casio"" , ""Epson"" , ""Fujifilm"" , ""Mamiya"" , ""Minolta"" , ""Motorola"" , ""Kodak"" , ""Konica"" , ""Leica"" , ""Nikon"" , ""Nokia"" , ""Olympus"" , ""Pentax"" , ""Phase<S2SV_blank>One"" , ""Ricoh"" , ""Samsung"" , ""Sigma"" , ""Sinar"" , ""Sony"" } ; # ifdef LIBRAW_LIBRARY_BUILD char head [ 64 ] , * cp ; # else char head [ 32 ] , * cp ; # endif int hlen , flen , fsize , zero_fsize = 1 , i , c ; struct jhead jh ; # ifdef LIBRAW_LIBRARY_BUILD unsigned camera_count = parse_custom_cameras ( 64 , table , imgdata . params . custom_camera_strings ) ; for ( int q = 0 ; q < sizeof ( const_table ) / sizeof ( const_table [ 0 ] ) ; q ++ ) memmove ( & table [ q + camera_count ] , & const_table [ q ] , sizeof ( const_table [ 0 ] ) ) ; camera_count += sizeof ( const_table ) / sizeof ( const_table [ 0 ] ) ; # endif tiff_flip = flip = filters = UINT_MAX ; raw_height = raw_width = fuji_width = fuji_layout = cr2_slice [ 0 ] = 0 ; maximum = height = width = top_margin = left_margin = 0 ; cdesc [ 0 ] = desc [ 0 ] = artist [ 0 ] = make [ 0 ] = model [ 0 ] = model2 [ 0 ] = 0 ; iso_speed = shutter = aperture = focal_len = unique_id = 0 ; tiff_nifds = 0 ; memset ( tiff_ifd , 0 , sizeof tiff_ifd ) ; # ifdef LIBRAW_LIBRARY_BUILD imgdata . other . CameraTemperature = imgdata . other . SensorTemperature = imgdata . other . SensorTemperature2 = imgdata . other . LensTemperature = imgdata . other . AmbientTemperature = imgdata . other . BatteryTemperature = imgdata . other . exifAmbientTemperature = - 1000.0f ; for ( i = 0 ; i < LIBRAW_IFD_MAXCOUNT ; i ++ ) { tiff_ifd [ i ] . dng_color [ 0 ] . illuminant = tiff_ifd [ i ] . dng_color [ 1 ] . illuminant = 0xffff ; for ( int c = 0 ; c < 4 ; c ++ ) tiff_ifd [ i ] . dng_levels . analogbalance [ c ] = 1.0f ; } # endif memset ( gpsdata , 0 , sizeof gpsdata ) ; memset ( cblack , 0 , sizeof cblack ) ; memset ( white , 0 , sizeof white ) ; memset ( mask , 0 , sizeof mask ) ; thumb_offset = thumb_length = thumb_width = thumb_height = 0 ; load_raw = thumb_load_raw = 0 ; write_thumb = & CLASS jpeg_thumb ; data_offset = meta_offset = meta_length = tiff_bps = tiff_compress = 0 ; kodak_cbpp = zero_after_ff = dng_version = load_flags = 0 ; timestamp = shot_order = tiff_samples = black = is_foveon = 0 ; mix_green = profile_length = data_error = zero_is_bad = 0 ; pixel_aspect = is_raw = raw_color = 1 ; tile_width = tile_length = 0 ; for ( i = 0 ; i < 4 ; i ++ ) { cam_mul [ i ] = i == 1 ; pre_mul [ i ] = i < 3 ; FORC3 cmatrix [ c ] [ i ] = 0 ; FORC3 rgb_cam [ c ] [ i ] = c == i ; } colors = 3 ; for ( i = 0 ; i < 0x10000 ; i ++ ) curve [ i ] = i ; order = get2 ( ) ; hlen = get4 ( ) ; fseek ( ifp , 0 , SEEK_SET ) ; # ifdef LIBRAW_LIBRARY_BUILD fread ( head , 1 , 64 , ifp ) ; libraw_internal_data . unpacker_data . lenRAFData = libraw_internal_data . unpacker_data . posRAFData = 0 ; # else fread ( head , 1 , 32 , ifp ) ; # endif fseek ( ifp , 0 , SEEK_END ) ; flen = fsize = ftell ( ifp ) ; if ( ( cp = ( char * ) memmem ( head , 32 , ( char * ) ""MMMM"" , 4 ) ) || ( cp = ( char * ) memmem ( head , 32 , ( char * ) ""IIII"" , 4 ) ) ) { parse_phase_one ( cp - head ) ; if ( cp - head && parse_tiff ( 0 ) ) apply_tiff ( ) ; } else if ( order == 0x4949 || order == 0x4d4d ) { if ( ! memcmp ( head + 6 , ""HEAPCCDR"" , 8 ) ) { data_offset = hlen ; # ifdef LIBRAW_LIBRARY_BUILD imgdata . lens . makernotes . CameraMount = LIBRAW_MOUNT_FixedLens ; imgdata . lens . makernotes . LensMount = LIBRAW_MOUNT_FixedLens ; # endif parse_ciff ( hlen , flen - hlen , 0 ) ; load_raw = & CLASS canon_load_raw ; } else if ( parse_tiff ( 0 ) ) apply_tiff ( ) ; } else if ( ! memcmp ( head , ""\\xff\\xd8\\xff\\xe1"" , 4 ) && ! memcmp ( head + 6 , ""Exif"" , 4 ) ) { fseek ( ifp , 4 , SEEK_SET ) ; data_offset = 4 + get2 ( ) ; fseek ( ifp , data_offset , SEEK_SET ) ; if ( fgetc ( ifp ) != 0xff ) parse_tiff ( 12 ) ; thumb_offset = 0 ; } else if ( ! memcmp ( head + 25 , ""ARECOYK"" , 7 ) ) { strcpy ( make , ""Contax"" ) ; strcpy ( model , ""N<S2SV_blank>Digital"" ) ; fseek ( ifp , 33 , SEEK_SET ) ; get_timestamp ( 1 ) ; fseek ( ifp , 52 , SEEK_SET ) ; switch ( get4 ( ) ) { case 7 : iso_speed = 25 ; break ; case 8 : iso_speed = 32 ; break ; case 9 : iso_speed = 40 ; break ; case 10 : iso_speed = 50 ; break ; case 11 : iso_speed = 64 ; break ; case 12 : iso_speed = 80 ; break ; case 13 : iso_speed = 100 ; break ; case 14 : iso_speed = 125 ; break ; case 15 : iso_speed = 160 ; break ; case 16 : iso_speed = 200 ; break ; case 17 : iso_speed = 250 ; break ; case 18 : iso_speed = 320 ; break ; case 19 : iso_speed = 400 ; break ; } shutter = powf64 ( 2.0f , ( ( ( float ) get4 ( ) ) / 8.0f ) ) / 16000.0f ; FORC4 cam_mul [ c ^ ( c >> 1 ) ] = get4 ( ) ; fseek ( ifp , 88 , SEEK_SET ) ; aperture = powf64 ( 2.0f , ( ( float ) get4 ( ) ) / 16.0f ) ; fseek ( ifp , 112 , SEEK_SET ) ; focal_len = get4 ( ) ; # ifdef LIBRAW_LIBRARY_BUILD fseek ( ifp , 104 , SEEK_SET ) ; imgdata . lens . makernotes . MaxAp4CurFocal = powf64 ( 2.0f , ( ( float ) get4 ( ) ) / 16.0f ) ; fseek ( ifp , 124 , SEEK_SET ) ; stmread ( imgdata . lens . makernotes . Lens , 32 , ifp ) ; imgdata . lens . makernotes . CameraMount = LIBRAW_MOUNT_Contax_N ; if ( imgdata . lens . makernotes . Lens [ 0 ] ) imgdata . lens . makernotes . LensMount = LIBRAW_MOUNT_Contax_N ; # endif } else if ( ! strcmp ( head , ""PXN"" ) ) { strcpy ( make , ""Logitech"" ) ; strcpy ( model , ""Fotoman<S2SV_blank>Pixtura"" ) ; } else if ( ! strcmp ( head , ""qktk"" ) ) { strcpy ( make , ""Apple"" ) ; strcpy ( model , ""QuickTake<S2SV_blank>100"" ) ; load_raw = & CLASS quicktake_100_load_raw ; } else if ( ! strcmp ( head , ""qktn"" ) ) { strcpy ( make , ""Apple"" ) ; strcpy ( model , ""QuickTake<S2SV_blank>150"" ) ; load_raw = & CLASS kodak_radc_load_raw ; } else if ( ! memcmp ( head , ""FUJIFILM"" , 8 ) ) { # ifdef LIBRAW_LIBRARY_BUILD strcpy ( model , head + 0x1c ) ; memcpy ( model2 , head + 0x3c , 4 ) ; model2 [ 4 ] = 0 ; # endif fseek ( ifp , 84 , SEEK_SET ) ; thumb_offset = get4 ( ) ; thumb_length = get4 ( ) ; fseek ( ifp , 92 , SEEK_SET ) ; parse_fuji ( get4 ( ) ) ; if ( thumb_offset > 120 ) { fseek ( ifp , 120 , SEEK_SET ) ; is_raw += ( i = get4 ( ) ) ? 1 : 0 ; if ( is_raw == 2 && shot_select ) parse_fuji ( i ) ; } load_raw = & CLASS unpacked_load_raw ; fseek ( ifp , 100 + 28 * ( shot_select > 0 ) , SEEK_SET ) ; parse_tiff ( data_offset = get4 ( ) ) ; parse_tiff ( thumb_offset + 12 ) ; apply_tiff ( ) ; } else if ( ! memcmp ( head , ""RIFF"" , 4 ) ) { fseek ( ifp , 0 , SEEK_SET ) ; parse_riff ( ) ; } else if ( ! memcmp ( head + 4 , ""ftypqt<S2SV_blank><S2SV_blank><S2SV_blank>"" , 9 ) ) { fseek ( ifp , 0 , SEEK_SET ) ; parse_qt ( fsize ) ; is_raw = 0 ; } else if ( ! memcmp ( head , ""\\0\\001\\0\\001\\0@"" , 6 ) ) { fseek ( ifp , 6 , SEEK_SET ) ; fread ( make , 1 , 8 , ifp ) ; fread ( model , 1 , 8 , ifp ) ; fread ( model2 , 1 , 16 , ifp ) ; data_offset = get2 ( ) ; get2 ( ) ; raw_width = get2 ( ) ; raw_height = get2 ( ) ; load_raw = & CLASS nokia_load_raw ; filters = 0x61616161 ; } else if ( ! memcmp ( head , ""NOKIARAW"" , 8 ) ) { strcpy ( make , ""NOKIA"" ) ; order = 0x4949 ; fseek ( ifp , 300 , SEEK_SET ) ; data_offset = get4 ( ) ; i = get4 ( ) ; width = get2 ( ) ; height = get2 ( ) ; # ifdef LIBRAW_LIBRARY_BUILD if ( width < 1 || width > 16000 || height < 1 || height > 16000 || i < ( width * height ) || i > ( 2 * width * height ) ) throw LIBRAW_EXCEPTION_IO_CORRUPT ; # endif switch ( tiff_bps = i * 8 / ( width * height ) ) { case 8 : load_raw = & CLASS eight_bit_load_raw ; break ; case 10 : load_raw = & CLASS nokia_load_raw ; } raw_height = height + ( top_margin = i / ( width * tiff_bps / 8 ) - height ) ; mask [ 0 ] [ 3 ] = 1 ; filters = 0x61616161 ; } else if ( ! memcmp ( head , ""ARRI"" , 4 ) ) { order = 0x4949 ; fseek ( ifp , 20 , SEEK_SET ) ; width = get4 ( ) ; height = get4 ( ) ; strcpy ( make , ""ARRI"" ) ; fseek ( ifp , 668 , SEEK_SET ) ; fread ( model , 1 , 64 , ifp ) ; data_offset = 4096 ; load_raw = & CLASS packed_load_raw ; load_flags = 88 ; filters = 0x61616161 ; } else if ( ! memcmp ( head , ""XPDS"" , 4 ) ) { order = 0x4949 ; fseek ( ifp , 0x800 , SEEK_SET ) ; fread ( make , 1 , 41 , ifp ) ; raw_height = get2 ( ) ; raw_width = get2 ( ) ; fseek ( ifp , 56 , SEEK_CUR ) ; fread ( model , 1 , 30 , ifp ) ; data_offset = 0x10000 ; load_raw = & CLASS canon_rmf_load_raw ; gamma_curve ( 0 , 12.25 , 1 , 1023 ) ; } else if ( ! memcmp ( head + 4 , ""RED1"" , 4 ) ) { strcpy ( make , ""Red"" ) ; strcpy ( model , ""One"" ) ; parse_redcine ( ) ; load_raw = & CLASS redcine_load_raw ; gamma_curve ( 1 / 2.4 , 12.92 , 1 , 4095 ) ; filters = 0x49494949 ; } else if ( ! memcmp ( head , ""DSC-Image"" , 9 ) ) parse_rollei ( ) ; else if ( ! memcmp ( head , ""PWAD"" , 4 ) ) parse_sinar_ia ( ) ; else if ( ! memcmp ( head , ""\\0MRM"" , 4 ) ) parse_minolta ( 0 ) ; else if ( ! memcmp ( head , ""FOVb"" , 4 ) ) { # ifdef LIBRAW_LIBRARY_BUILD parse_x3f ( ) ; # endif } else if ( ! memcmp ( head , ""CI"" , 2 ) ) parse_cine ( ) ; if ( make [ 0 ] == 0 ) # ifdef LIBRAW_LIBRARY_BUILD for ( zero_fsize = i = 0 ; i < camera_count ; i ++ ) # else for ( zero_fsize = i = 0 ; i < sizeof table / sizeof * table ; i ++ ) # endif if ( fsize == table [ i ] . fsize ) { strcpy ( make , table [ i ] . t_make ) ; # ifdef LIBRAW_LIBRARY_BUILD if ( ! strncmp ( make , ""Canon"" , 5 ) ) { imgdata . lens . makernotes . CameraMount = LIBRAW_MOUNT_FixedLens ; imgdata . lens . makernotes . LensMount = LIBRAW_MOUNT_FixedLens ; } # endif strcpy ( model , table [ i ] . t_model ) ; flip = table [ i ] . flags >> 2 ; zero_is_bad = table [ i ] . flags & 2 ; if ( table [ i ] . flags & 1 ) parse_external_jpeg ( ) ; data_offset = table [ i ] . offset == 0xffff ? 0 : table [ i ] . offset ; raw_width = table [ i ] . rw ; raw_height = table [ i ] . rh ; left_margin = table [ i ] . lm ; top_margin = table [ i ] . tm ; width = raw_width - left_margin - table [ i ] . rm ; height = raw_height - top_margin - table [ i ] . bm ; filters = 0x1010101 * table [ i ] . cf ; colors = 4 - ! ( ( filters & filters >> 1 ) & 0x5555 ) ; load_flags = table [ i ] . lf ; switch ( tiff_bps = ( fsize - data_offset ) * 8 / ( raw_width * raw_height ) ) { case 6 : load_raw = & CLASS minolta_rd175_load_raw ; break ; case 8 : load_raw = & CLASS eight_bit_load_raw ; break ; case 10 : if ( ( fsize - data_offset ) / raw_height * 3 >= raw_width * 4 ) { load_raw = & CLASS android_loose_load_raw ; break ; } else if ( load_flags & 1 ) { load_raw = & CLASS android_tight_load_raw ; break ; } case 12 : load_flags |= 128 ; load_raw = & CLASS packed_load_raw ; break ; case 16 : order = 0x4949 | 0x404 * ( load_flags & 1 ) ; tiff_bps -= load_flags >> 4 ; tiff_bps -= load_flags = load_flags >> 1 & 7 ; load_raw = table [ i ] . offset == 0xffff ? & CLASS unpacked_load_raw_reversed : & CLASS unpacked_load_raw ; } maximum = ( 1 << tiff_bps ) - ( 1 << table [ i ] . max ) ; break ; } if ( zero_fsize ) fsize = 0 ; if ( make [ 0 ] == 0 ) parse_smal ( 0 , flen ) ; if ( make [ 0 ] == 0 ) { parse_jpeg ( 0 ) ; fseek ( ifp , 0 , SEEK_END ) ; int sz = ftell ( ifp ) ; # ifdef LIBRAW_LIBRARY_BUILD if ( ! strncmp ( model , ""RP_imx219"" , 9 ) && sz >= 0x9cb600 && ! fseek ( ifp , - 0x9cb600 , SEEK_END ) && fread ( head , 1 , 0x20 , ifp ) && ! strncmp ( head , ""BRCM"" , 4 ) ) { strcpy ( make , ""Broadcom"" ) ; strcpy ( model , ""RPi<S2SV_blank>IMX219"" ) ; if ( raw_height > raw_width ) flip = 5 ; data_offset = ftell ( ifp ) + 0x8000 - 0x20 ; parse_broadcom ( ) ; black = 66 ; maximum = 0x3ff ; load_raw = & CLASS broadcom_load_raw ; thumb_offset = 0 ; thumb_length = sz - 0x9cb600 - 1 ; } else if ( ! ( strncmp ( model , ""ov5647"" , 6 ) && strncmp ( model , ""RP_OV5647"" , 9 ) ) && sz >= 0x61b800 && ! fseek ( ifp , - 0x61b800 , SEEK_END ) && fread ( head , 1 , 0x20 , ifp ) && ! strncmp ( head , ""BRCM"" , 4 ) ) { strcpy ( make , ""Broadcom"" ) ; if ( ! strncmp ( model , ""ov5647"" , 6 ) ) strcpy ( model , ""RPi<S2SV_blank>OV5647<S2SV_blank>v.1"" ) ; else strcpy ( model , ""RPi<S2SV_blank>OV5647<S2SV_blank>v.2"" ) ; if ( raw_height > raw_width ) flip = 5 ; data_offset = ftell ( ifp ) + 0x8000 - 0x20 ; parse_broadcom ( ) ; black = 16 ; maximum = 0x3ff ; load_raw = & CLASS broadcom_load_raw ; thumb_offset = 0 ; thumb_length = sz - 0x61b800 - 1 ; # else if ( ! ( strncmp ( model , ""ov"" , 2 ) && strncmp ( model , ""RP_OV"" , 5 ) ) && sz >= 6404096 && ! fseek ( ifp , - 6404096 , SEEK_END ) && fread ( head , 1 , 32 , ifp ) && ! strcmp ( head , ""BRCMn"" ) ) { strcpy ( make , ""OmniVision"" ) ; data_offset = ftell ( ifp ) + 0x8000 - 32 ; width = raw_width ; raw_width = 2611 ; load_raw = & CLASS nokia_load_raw ; filters = 0x16161616 ; # endif } else is_raw = 0 ; } # ifdef LIBRAW_LIBRARY_BUILD desc [ 511 ] = artist [ 63 ] = make [ 63 ] = model [ 63 ] = model2 [ 63 ] = 0 ; # endif for ( i = 0 ; i < sizeof corp / sizeof * corp ; i ++ ) if ( strcasestr ( make , corp [ i ] ) ) strcpy ( make , corp [ i ] ) ; if ( ( ! strncmp ( make , ""Kodak"" , 5 ) || ! strncmp ( make , ""Leica"" , 5 ) ) && ( ( cp = strcasestr ( model , ""<S2SV_blank>DIGITAL<S2SV_blank>CAMERA"" ) ) || ( cp = strstr ( model , ""FILE<S2SV_blank>VERSION"" ) ) ) ) * cp = 0 ; if ( ! strncasecmp ( model , ""PENTAX"" , 6 ) ) strcpy ( make , ""Pentax"" ) ; # ifdef LIBRAW_LIBRARY_BUILD remove_trailing_spaces ( make , sizeof ( make ) ) ; remove_trailing_spaces ( model , sizeof ( model ) ) ; # else cp = make + strlen ( make ) ; while ( * -- cp == '<S2SV_blank>' ) * cp = 0 ; cp = model + strlen ( model ) ; while ( * -- cp == '<S2SV_blank>' ) * cp = 0 ; # endif i = strbuflen ( make ) ; if ( ! strncasecmp ( model , make , i ) && model [ i ++ ] == '<S2SV_blank>' ) memmove ( model , model + i , 64 - i ) ; if ( ! strncmp ( model , ""FinePix<S2SV_blank>"" , 8 ) ) strcpy ( model , model + 8 ) ; if ( ! strncmp ( model , ""Digital<S2SV_blank>Camera<S2SV_blank>"" , 15 ) ) strcpy ( model , model + 15 ) ; desc [ 511 ] = artist [ 63 ] = make [ 63 ] = model [ 63 ] = model2 [ 63 ] = 0 ; if ( ! is_raw ) goto notraw ; if ( ! height ) height = raw_height ; if ( ! width ) width = raw_width ; if ( height == 2624 && width == 3936 ) { height = 2616 ; width = 3896 ; } if ( height == 3136 && width == 4864 ) { height = 3124 ; width = 4688 ; filters = 0x16161616 ; } if ( width == 4352 && ( ! strcmp ( model , ""K-r"" ) || ! strcmp ( model , ""K-x"" ) ) ) { width = 4309 ; filters = 0x16161616 ; } if ( width >= 4960 && ! strncmp ( model , ""K-5"" , 3 ) ) { left_margin = 10 ; width = 4950 ; filters = 0x16161616 ; } if ( width == 6080 && ! strcmp ( model , ""K-70"" ) ) { height = 4016 ; top_margin = 32 ; width = 6020 ; left_margin = 60 ; } if ( width == 4736 && ! strcmp ( model , ""K-7"" ) ) { height = 3122 ; width = 4684 ; filters = 0x16161616 ; top_margin = 2 ; } if ( width == 6080 && ! strcmp ( model , ""K-3<S2SV_blank>II"" ) ) { left_margin = 4 ; width = 6040 ; } if ( width == 6112 && ! strcmp ( model , ""KP"" ) ) { left_margin = 54 ; top_margin = 28 ; width = 6028 ; height = raw_height - top_margin ; } if ( width == 6080 && ! strcmp ( model , ""K-3"" ) ) { left_margin = 4 ; width = 6040 ; } if ( width == 7424 && ! strcmp ( model , ""645D"" ) ) { height = 5502 ; width = 7328 ; filters = 0x61616161 ; top_margin = 29 ; left_margin = 48 ; } if ( height == 3014 && width == 4096 ) width = 4014 ; if ( dng_version ) { if ( filters == UINT_MAX ) filters = 0 ; if ( filters ) is_raw *= tiff_samples ; else colors = tiff_samples ; switch ( tiff_compress ) { case 0 : case 1 : load_raw = & CLASS packed_dng_load_raw ; break ; case 7 : load_raw = & CLASS lossless_dng_load_raw ; break ; # ifdef LIBRAW_LIBRARY_BUILD case 8 : load_raw = & CLASS deflate_dng_load_raw ; break ; # endif case 34892 : load_raw = & CLASS lossy_dng_load_raw ; break ; default : load_raw = 0 ; } if ( ! strncmp ( make , ""Canon"" , 5 ) && unique_id ) { for ( i = 0 ; i < sizeof unique / sizeof * unique ; i ++ ) if ( unique_id == 0x80000000 + unique [ i ] . id ) { strcpy ( model , unique [ i ] . t_model ) ; break ; } } if ( ! strncasecmp ( make , ""Sony"" , 4 ) && unique_id ) { for ( i = 0 ; i < sizeof sonique / sizeof * sonique ; i ++ ) if ( unique_id == sonique [ i ] . id ) { strcpy ( model , sonique [ i ] . t_model ) ; break ; } } goto dng_skip ; } if ( ! strncmp ( make , ""Canon"" , 5 ) && ! fsize && tiff_bps != 15 ) { if ( ! load_raw ) load_raw = & CLASS lossless_jpeg_load_raw ; for ( i = 0 ; i < sizeof canon / sizeof * canon ; i ++ ) if ( raw_width == canon [ i ] [ 0 ] && raw_height == canon [ i ] [ 1 ] ) { width = raw_width - ( left_margin = canon [ i ] [ 2 ] ) ; height = raw_height - ( top_margin = canon [ i ] [ 3 ] ) ; width -= canon [ i ] [ 4 ] ; height -= canon [ i ] [ 5 ] ; mask [ 0 ] [ 1 ] = canon [ i ] [ 6 ] ; mask [ 0 ] [ 3 ] = - canon [ i ] [ 7 ] ; mask [ 1 ] [ 1 ] = canon [ i ] [ 8 ] ; mask [ 1 ] [ 3 ] = - canon [ i ] [ 9 ] ; if ( canon [ i ] [ 10 ] ) filters = canon [ i ] [ 10 ] * 0x01010101 ; } if ( ( unique_id | 0x20000 ) == 0x2720000 ) { left_margin = 8 ; top_margin = 16 ; } } if ( ! strncmp ( make , ""Canon"" , 5 ) && unique_id ) { for ( i = 0 ; i < sizeof unique / sizeof * unique ; i ++ ) if ( unique_id == 0x80000000 + unique [ i ] . id ) { adobe_coeff ( ""Canon"" , unique [ i ] . t_model ) ; strcpy ( model , unique [ i ] . t_model ) ; } } if ( ! strncasecmp ( make , ""Sony"" , 4 ) && unique_id ) { for ( i = 0 ; i < sizeof sonique / sizeof * sonique ; i ++ ) if ( unique_id == sonique [ i ] . id ) { adobe_coeff ( ""Sony"" , sonique [ i ] . t_model ) ; strcpy ( model , sonique [ i ] . t_model ) ; } } if ( ! strncmp ( make , ""Nikon"" , 5 ) ) { if ( ! load_raw ) load_raw = & CLASS packed_load_raw ; if ( model [ 0 ] == 'E' ) load_flags |= ! data_offset << 2 | 2 ; } if ( ! strcmp ( model , ""KAI-0340"" ) && find_green ( 16 , 16 , 3840 , 5120 ) < 25 ) { height = 480 ; top_margin = filters = 0 ; strcpy ( model , ""C603"" ) ; } # ifndef LIBRAW_LIBRARY_BUILD if ( ! strcmp ( make , ""Sony"" ) && raw_width > 3888 && ! black && ! cblack [ 0 ] ) black = 128 << ( tiff_bps - 12 ) ; # else if ( ! strcmp ( make , ""Sony"" ) && raw_width > 3888 && ! black && ! cblack [ 0 ] ) black = ( load_raw == & LibRaw : : sony_arw2_load_raw ) ? 512 : ( 128 << ( tiff_bps - 12 ) ) ; # endif if ( is_foveon ) { if ( height * 2 < width ) pixel_aspect = 0.5 ; if ( height > width ) pixel_aspect = 2 ; filters = 0 ; } else if ( ! strncmp ( make , ""Pentax"" , 6 ) && ! strncmp ( model , ""K-1"" , 3 ) ) { top_margin = 18 ; height = raw_height - top_margin ; if ( raw_width == 7392 ) { left_margin = 6 ; width = 7376 ; } } else if ( ! strncmp ( make , ""Canon"" , 5 ) && tiff_bps == 15 ) { switch ( width ) { case 3344 : width -= 66 ; case 3872 : width -= 6 ; } if ( height > width ) { SWAP ( height , width ) ; SWAP ( raw_height , raw_width ) ; } if ( width == 7200 && height == 3888 ) { raw_width = width = 6480 ; raw_height = height = 4320 ; } filters = 0 ; tiff_samples = colors = 3 ; load_raw = & CLASS canon_sraw_load_raw ; } else if ( ! strcmp ( model , ""PowerShot<S2SV_blank>600"" ) ) { height = 613 ; width = 854 ; raw_width = 896 ; colors = 4 ; filters = 0xe1e4e1e4 ; load_raw = & CLASS canon_600_load_raw ; } else if ( ! strcmp ( model , ""PowerShot<S2SV_blank>A5"" ) || ! strcmp ( model , ""PowerShot<S2SV_blank>A5<S2SV_blank>Zoom"" ) ) { height = 773 ; width = 960 ; raw_width = 992 ; pixel_aspect = 256 / 235.0 ; filters = 0x1e4e1e4e ; goto canon_a5 ; } else if ( ! strcmp ( model , ""PowerShot<S2SV_blank>A50"" ) ) { height = 968 ; width = 1290 ; raw_width = 1320 ; filters = 0x1b4e4b1e ; goto canon_a5 ; } else if ( ! strcmp ( model , ""PowerShot<S2SV_blank>Pro70"" ) ) { height = 1024 ; width = 1552 ; filters = 0x1e4b4e1b ; canon_a5 : colors = 4 ; tiff_bps = 10 ; load_raw = & CLASS packed_load_raw ; load_flags = 40 ; } else if ( ! strcmp ( model , ""PowerShot<S2SV_blank>Pro90<S2SV_blank>IS"" ) || ! strcmp ( model , ""PowerShot<S2SV_blank>G1"" ) ) { colors = 4 ; filters = 0xb4b4b4b4 ; } else if ( ! strcmp ( model , ""PowerShot<S2SV_blank>A610"" ) ) { if ( canon_s2is ( ) ) strcpy ( model + 10 , ""S2<S2SV_blank>IS"" ) ; } else if ( ! strcmp ( model , ""PowerShot<S2SV_blank>SX220<S2SV_blank>HS"" ) ) { mask [ 1 ] [ 3 ] = - 4 ; top_margin = 16 ; left_margin = 92 ; } else if ( ! strcmp ( model , ""PowerShot<S2SV_blank>S120"" ) ) { raw_width = 4192 ; raw_height = 3062 ; width = 4022 ; height = 3016 ; mask [ 0 ] [ 0 ] = top_margin = 31 ; mask [ 0 ] [ 2 ] = top_margin + height ; left_margin = 120 ; mask [ 0 ] [ 1 ] = 23 ; mask [ 0 ] [ 3 ] = 72 ; } else if ( ! strcmp ( model , ""PowerShot<S2SV_blank>G16"" ) ) { mask [ 0 ] [ 0 ] = 0 ; mask [ 0 ] [ 2 ] = 80 ; mask [ 0 ] [ 1 ] = 0 ; mask [ 0 ] [ 3 ] = 16 ; top_margin = 29 ; left_margin = 120 ; width = raw_width - left_margin - 48 ; height = raw_height - top_margin - 14 ; } else if ( ! strcmp ( model , ""PowerShot<S2SV_blank>SX50<S2SV_blank>HS"" ) ) { top_margin = 17 ; } else if ( ! strcmp ( model , ""EOS<S2SV_blank>D2000C"" ) ) { filters = 0x61616161 ; if ( ! black ) black = curve [ 200 ] ; } else if ( ! strcmp ( model , ""D1"" ) ) { cam_mul [ 0 ] *= 256 / 527.0 ; cam_mul [ 2 ] *= 256 / 317.0 ; } else if ( ! strcmp ( model , ""D1X"" ) ) { width -= 4 ; pixel_aspect = 0.5 ; } else if ( ! strcmp ( model , ""D40X"" ) || ! strcmp ( model , ""D60"" ) || ! strcmp ( model , ""D80"" ) || ! strcmp ( model , ""D3000"" ) ) { height -= 3 ; width -= 4 ; } else if ( ! strcmp ( model , ""D3"" ) || ! strcmp ( model , ""D3S"" ) || ! strcmp ( model , ""D700"" ) ) { width -= 4 ; left_margin = 2 ; } else if ( ! strcmp ( model , ""D3100"" ) ) { width -= 28 ; left_margin = 6 ; } else if ( ! strcmp ( model , ""D5000"" ) || ! strcmp ( model , ""D90"" ) ) { width -= 42 ; } else if ( ! strcmp ( model , ""D5100"" ) || ! strcmp ( model , ""D7000"" ) || ! strcmp ( model , ""COOLPIX<S2SV_blank>A"" ) ) { width -= 44 ; } else if ( ! strcmp ( model , ""D3200"" ) || ! strncmp ( model , ""D6"" , 2 ) || ! strncmp ( model , ""D800"" , 4 ) ) { width -= 46 ; } else if ( ! strcmp ( model , ""D4"" ) || ! strcmp ( model , ""Df"" ) ) { width -= 52 ; left_margin = 2 ; } else if ( ! strcmp ( model , ""D500"" ) ) { } else if ( ! strncmp ( model , ""D40"" , 3 ) || ! strncmp ( model , ""D50"" , 3 ) || ! strncmp ( model , ""D70"" , 3 ) ) { width -- ; } else if ( ! strcmp ( model , ""D100"" ) ) { if ( load_flags ) raw_width = ( width += 3 ) + 3 ; } else if ( ! strcmp ( model , ""D200"" ) ) { left_margin = 1 ; width -= 4 ; filters = 0x94949494 ; } else if ( ! strncmp ( model , ""D2H"" , 3 ) ) { left_margin = 6 ; width -= 14 ; } else if ( ! strncmp ( model , ""D2X"" , 3 ) ) { if ( width == 3264 ) width -= 32 ; else width -= 8 ; } else if ( ! strncmp ( model , ""D300"" , 4 ) ) { width -= 32 ; } else if ( ! strncmp ( make , ""Nikon"" , 5 ) && raw_width == 4032 ) { if ( ! strcmp ( model , ""COOLPIX<S2SV_blank>P7700"" ) ) { adobe_coeff ( ""Nikon"" , ""COOLPIX<S2SV_blank>P7700"" ) ; maximum = 65504 ; load_flags = 0 ; } else if ( ! strcmp ( model , ""COOLPIX<S2SV_blank>P7800"" ) ) { adobe_coeff ( ""Nikon"" , ""COOLPIX<S2SV_blank>P7800"" ) ; maximum = 65504 ; load_flags = 0 ; } else if ( ! strcmp ( model , ""COOLPIX<S2SV_blank>P340"" ) ) load_flags = 0 ; } else if ( ! strncmp ( model , ""COOLPIX<S2SV_blank>P"" , 9 ) && raw_width != 4032 ) { load_flags = 24 ; filters = 0x94949494 ; if ( model [ 9 ] == '7' && ( iso_speed >= 400 || iso_speed == 0 ) && ! strstr ( software , ""V1.2"" ) ) black = 255 ; } else if ( ! strncmp ( model , ""COOLPIX<S2SV_blank>B700"" , 12 ) ) { load_flags = 24 ; black = 200 ; } else if ( ! strncmp ( model , ""1<S2SV_blank>"" , 2 ) ) { height -= 2 ; } else if ( fsize == 1581060 ) { simple_coeff ( 3 ) ; pre_mul [ 0 ] = 1.2085 ; pre_mul [ 1 ] = 1.0943 ; pre_mul [ 3 ] = 1.1103 ; } else if ( fsize == 3178560 ) { cam_mul [ 0 ] *= 4 ; cam_mul [ 2 ] *= 4 ; } else if ( fsize == 4771840 ) { if ( ! timestamp && nikon_e995 ( ) ) strcpy ( model , ""E995"" ) ; if ( strcmp ( model , ""E995"" ) ) { filters = 0xb4b4b4b4 ; simple_coeff ( 3 ) ; pre_mul [ 0 ] = 1.196 ; pre_mul [ 1 ] = 1.246 ; pre_mul [ 2 ] = 1.018 ; } } else if ( fsize == 2940928 ) { if ( ! timestamp && ! nikon_e2100 ( ) ) strcpy ( model , ""E2500"" ) ; if ( ! strcmp ( model , ""E2500"" ) ) { height -= 2 ; load_flags = 6 ; colors = 4 ; filters = 0x4b4b4b4b ; } } else if ( fsize == 4775936 ) { if ( ! timestamp ) nikon_3700 ( ) ; if ( model [ 0 ] == 'E' && atoi ( model + 1 ) < 3700 ) filters = 0x49494949 ; if ( ! strcmp ( model , ""Optio<S2SV_blank>33WR"" ) ) { flip = 1 ; filters = 0x16161616 ; } if ( make [ 0 ] == 'O' ) { i = find_green ( 12 , 32 , 1188864 , 3576832 ) ; c = find_green ( 12 , 32 , 2383920 , 2387016 ) ; if ( abs ( i ) < abs ( c ) ) { SWAP ( i , c ) ; load_flags = 24 ; } if ( i < 0 ) filters = 0x61616161 ; } } else if ( fsize == 5869568 ) { if ( ! timestamp && minolta_z2 ( ) ) { strcpy ( make , ""Minolta"" ) ; strcpy ( model , ""DiMAGE<S2SV_blank>Z2"" ) ; } load_flags = 6 + 24 * ( make [ 0 ] == 'M' ) ; } else if ( fsize == 6291456 ) { fseek ( ifp , 0x300000 , SEEK_SET ) ; if ( ( order = guess_byte_order ( 0x10000 ) ) == 0x4d4d ) { height -= ( top_margin = 16 ) ; width -= ( left_margin = 28 ) ; maximum = 0xf5c0 ; strcpy ( make , ""ISG"" ) ; model [ 0 ] = 0 ; } } else if ( ! strncmp ( make , ""Fujifilm"" , 8 ) ) { if ( ! strcmp ( model , ""X-A3"" ) || ! strcmp ( model , ""X-A10"" ) ) { left_margin = 0 ; top_margin = 0 ; width = raw_width ; height = raw_height ; } if ( ! strcmp ( model + 7 , ""S2Pro"" ) ) { strcpy ( model , ""S2Pro"" ) ; height = 2144 ; width = 2880 ; flip = 6 ; } else if ( load_raw != & CLASS packed_load_raw && strncmp ( model , ""X-"" , 2 ) ) maximum = ( is_raw == 2 && shot_select ) ? 0x2f00 : 0x3e00 ; top_margin = ( raw_height - height ) >> 2 << 1 ; left_margin = ( raw_width - width ) >> 2 << 1 ; if ( width == 2848 || width == 3664 ) filters = 0x16161616 ; if ( width == 4032 || width == 4952 ) left_margin = 0 ; if ( width == 3328 && ( width -= 66 ) ) left_margin = 34 ; if ( width == 4936 ) left_margin = 4 ; if ( width == 6032 ) left_margin = 0 ; if ( ! strcmp ( model , ""HS50EXR"" ) || ! strcmp ( model , ""F900EXR"" ) ) { width += 2 ; left_margin = 0 ; filters = 0x16161616 ; } if ( ! strcmp ( model , ""GFX<S2SV_blank>50S"" ) ) { left_margin = 0 ; top_margin = 0 ; } if ( ! strcmp ( model , ""S5500"" ) ) { height -= ( top_margin = 6 ) ; } if ( fuji_layout ) raw_width *= is_raw ; if ( filters == 9 ) FORC ( 36 ) ( ( char * ) xtrans ) [ c ] = xtrans_abs [ ( c / 6 + top_margin ) % 6 ] [ ( c + left_margin ) % 6 ] ; } else if ( ! strcmp ( model , ""KD-400Z"" ) ) { height = 1712 ; width = 2312 ; raw_width = 2336 ; goto konica_400z ; } else if ( ! strcmp ( model , ""KD-510Z"" ) ) { goto konica_510z ; } else if ( ! strncasecmp ( make , ""Minolta"" , 7 ) ) { if ( ! load_raw && ( maximum = 0xfff ) ) load_raw = & CLASS unpacked_load_raw ; if ( ! strncmp ( model , ""DiMAGE<S2SV_blank>A"" , 8 ) ) { if ( ! strcmp ( model , ""DiMAGE<S2SV_blank>A200"" ) ) filters = 0x49494949 ; tiff_bps = 12 ; load_raw = & CLASS packed_load_raw ; } else if ( ! strncmp ( model , ""ALPHA"" , 5 ) || ! strncmp ( model , ""DYNAX"" , 5 ) || ! strncmp ( model , ""MAXXUM"" , 6 ) ) { sprintf ( model + 20 , ""DYNAX<S2SV_blank>%-10s"" , model + 6 + ( model [ 0 ] == 'M' ) ) ; adobe_coeff ( make , model + 20 ) ; load_raw = & CLASS packed_load_raw ; } else if ( ! strncmp ( model , ""DiMAGE<S2SV_blank>G"" , 8 ) ) { if ( model [ 8 ] == '4' ) { height = 1716 ; width = 2304 ; } else if ( model [ 8 ] == '5' ) { konica_510z : height = 1956 ; width = 2607 ; raw_width = 2624 ; } else if ( model [ 8 ] == '6' ) { height = 2136 ; width = 2848 ; } data_offset += 14 ; filters = 0x61616161 ; konica_400z : load_raw = & CLASS unpacked_load_raw ; maximum = 0x3df ; order = 0x4d4d ; } } else if ( ! strcmp ( model , ""*ist<S2SV_blank>D"" ) ) { load_raw = & CLASS unpacked_load_raw ; data_error = - 1 ; } else if ( ! strcmp ( model , ""*ist<S2SV_blank>DS"" ) ) { height -= 2 ; } else if ( ! strncmp ( make , ""Samsung"" , 7 ) && raw_width == 4704 ) { height -= top_margin = 8 ; width -= 2 * ( left_margin = 8 ) ; load_flags = 32 ; } else if ( ! strncmp ( make , ""Samsung"" , 7 ) && ! strcmp ( model , ""NX3000"" ) ) { top_margin = 38 ; left_margin = 92 ; width = 5456 ; height = 3634 ; filters = 0x61616161 ; colors = 3 ; } else if ( ! strncmp ( make , ""Samsung"" , 7 ) && raw_height == 3714 ) { height -= top_margin = 18 ; left_margin = raw_width - ( width = 5536 ) ; if ( raw_width != 5600 ) left_margin = top_margin = 0 ; filters = 0x61616161 ; colors = 3 ; } else if ( ! strncmp ( make , ""Samsung"" , 7 ) && raw_width == 5632 ) { order = 0x4949 ; height = 3694 ; top_margin = 2 ; width = 5574 - ( left_margin = 32 + tiff_bps ) ; if ( tiff_bps == 12 ) load_flags = 80 ; } else if ( ! strncmp ( make , ""Samsung"" , 7 ) && raw_width == 5664 ) { height -= top_margin = 17 ; left_margin = 96 ; width = 5544 ; filters = 0x49494949 ; } else if ( ! strncmp ( make , ""Samsung"" , 7 ) && raw_width == 6496 ) { filters = 0x61616161 ; # ifdef LIBRAW_LIBRARY_BUILD if ( ! black && ! cblack [ 0 ] && ! cblack [ 1 ] && ! cblack [ 2 ] && ! cblack [ 3 ] ) # endif black = 1 << ( tiff_bps - 7 ) ; } else if ( ! strcmp ( model , ""EX1"" ) ) { order = 0x4949 ; height -= 20 ; top_margin = 2 ; if ( ( width -= 6 ) > 3682 ) { height -= 10 ; width -= 46 ; top_margin = 8 ; } } else if ( ! strcmp ( model , ""WB2000"" ) ) { order = 0x4949 ; height -= 3 ; top_margin = 2 ; if ( ( width -= 10 ) > 3718 ) { height -= 28 ; width -= 56 ; top_margin = 8 ; } } else if ( strstr ( model , ""WB550"" ) ) { strcpy ( model , ""WB550"" ) ; } else if ( ! strcmp ( model , ""EX2F"" ) ) { height = 3030 ; width = 4040 ; top_margin = 15 ; left_margin = 24 ; order = 0x4949 ; filters = 0x49494949 ; load_raw = & CLASS unpacked_load_raw ; } else if ( ! strcmp ( model , ""STV680<S2SV_blank>VGA"" ) ) { black = 16 ; } else if ( ! strcmp ( model , ""N95"" ) ) { height = raw_height - ( top_margin = 2 ) ; } else if ( ! strcmp ( model , ""640x480"" ) ) { gamma_curve ( 0.45 , 4.5 , 1 , 255 ) ; } else if ( ! strncmp ( make , ""Hasselblad"" , 10 ) ) { if ( load_raw == & CLASS lossless_jpeg_load_raw ) load_raw = & CLASS hasselblad_load_raw ; if ( raw_width == 7262 ) { height = 5444 ; width = 7248 ; top_margin = 4 ; left_margin = 7 ; filters = 0x61616161 ; if ( ! strncasecmp ( model , ""H3D"" , 3 ) ) { adobe_coeff ( ""Hasselblad"" , ""H3DII-39"" ) ; strcpy ( model , ""H3DII-39"" ) ; } } else if ( raw_width == 12000 ) { left_margin = 64 ; width = 11608 ; top_margin = 108 ; height = raw_height - top_margin ; adobe_coeff ( ""Hasselblad"" , ""H6D-100c"" ) ; } else if ( raw_width == 7410 || raw_width == 8282 ) { height -= 84 ; width -= 82 ; top_margin = 4 ; left_margin = 41 ; filters = 0x61616161 ; adobe_coeff ( ""Hasselblad"" , ""H4D-40"" ) ; strcpy ( model , ""H4D-40"" ) ; } else if ( raw_width == 8384 ) { top_margin = 96 ; height -= 96 ; left_margin = 48 ; width -= 106 ; adobe_coeff ( ""Hasselblad"" , ""X1D"" ) ; maximum = 0xffff ; tiff_bps = 16 ; } else if ( raw_width == 9044 ) { if ( black > 500 ) { top_margin = 12 ; left_margin = 44 ; width = 8956 ; height = 6708 ; memset ( cblack , 0 , sizeof ( cblack ) ) ; adobe_coeff ( ""Hasselblad"" , ""H4D-60"" ) ; strcpy ( model , ""H4D-60"" ) ; black = 512 ; } else { height = 6716 ; width = 8964 ; top_margin = 8 ; left_margin = 40 ; black += load_flags = 256 ; maximum = 0x8101 ; strcpy ( model , ""H3DII-60"" ) ; } } else if ( raw_width == 4090 ) { strcpy ( model , ""V96C"" ) ; height -= ( top_margin = 6 ) ; width -= ( left_margin = 3 ) + 7 ; filters = 0x61616161 ; } else if ( raw_width == 8282 && raw_height == 6240 ) { if ( ! strncasecmp ( model , ""H5D"" , 3 ) ) { left_margin = 54 ; top_margin = 16 ; width = 8176 ; height = 6132 ; black = 256 ; strcpy ( model , ""H5D-50"" ) ; } else if ( ! strncasecmp ( model , ""H3D"" , 3 ) ) { black = 0 ; left_margin = 54 ; top_margin = 16 ; width = 8176 ; height = 6132 ; memset ( cblack , 0 , sizeof ( cblack ) ) ; adobe_coeff ( ""Hasselblad"" , ""H3D-50"" ) ; strcpy ( model , ""H3D-50"" ) ; } } else if ( raw_width == 8374 && raw_height == 6304 ) { left_margin = 52 ; top_margin = 100 ; width = 8272 ; height = 6200 ; black = 256 ; strcpy ( model , ""H5D-50c"" ) ; } if ( tiff_samples > 1 ) { is_raw = tiff_samples + 1 ; if ( ! shot_select && ! half_size ) filters = 0 ; } } else if ( ! strncmp ( make , ""Sinar"" , 5 ) ) { if ( ! load_raw ) load_raw = & CLASS unpacked_load_raw ; if ( is_raw > 1 && ! shot_select && ! half_size ) filters = 0 ; maximum = 0x3fff ; } else if ( ! strncmp ( make , ""Leaf"" , 4 ) ) { maximum = 0x3fff ; fseek ( ifp , data_offset , SEEK_SET ) ; if ( ljpeg_start ( & jh , 1 ) && jh . bits == 15 ) maximum = 0x1fff ; if ( tiff_samples > 1 ) filters = 0 ; if ( tiff_samples > 1 || tile_length < raw_height ) { load_raw = & CLASS leaf_hdr_load_raw ; raw_width = tile_width ; } if ( ( width | height ) == 2048 ) { if ( tiff_samples == 1 ) { filters = 1 ; strcpy ( cdesc , ""RBTG"" ) ; strcpy ( model , ""CatchLight"" ) ; top_margin = 8 ; left_margin = 18 ; height = 2032 ; width = 2016 ; } else { strcpy ( model , ""DCB2"" ) ; top_margin = 10 ; left_margin = 16 ; height = 2028 ; width = 2022 ; } } else if ( width + height == 3144 + 2060 ) { if ( ! model [ 0 ] ) strcpy ( model , ""Cantare"" ) ; if ( width > height ) { top_margin = 6 ; left_margin = 32 ; height = 2048 ; width = 3072 ; filters = 0x61616161 ; } else { left_margin = 6 ; top_margin = 32 ; width = 2048 ; height = 3072 ; filters = 0x16161616 ; } if ( ! cam_mul [ 0 ] || model [ 0 ] == 'V' ) filters = 0 ; else is_raw = tiff_samples ; } else if ( width == 2116 ) { strcpy ( model , ""Valeo<S2SV_blank>6"" ) ; height -= 2 * ( top_margin = 30 ) ; width -= 2 * ( left_margin = 55 ) ; filters = 0x49494949 ; } else if ( width == 3171 ) { strcpy ( model , ""Valeo<S2SV_blank>6"" ) ; height -= 2 * ( top_margin = 24 ) ; width -= 2 * ( left_margin = 24 ) ; filters = 0x16161616 ; } } else if ( ! strncmp ( make , ""Leica"" , 5 ) || ! strncmp ( make , ""Panasonic"" , 9 ) || ! strncasecmp ( make , ""YUNEEC"" , 6 ) ) { if ( raw_width > 0 && ( ( flen - data_offset ) / ( raw_width * 8 / 7 ) == raw_height ) ) load_raw = & CLASS panasonic_load_raw ; if ( ! load_raw ) { load_raw = & CLASS unpacked_load_raw ; load_flags = 4 ; } zero_is_bad = 1 ; # ifdef LIBRAW_LIBRARY_BUILD float fratio = float ( data_size ) / ( float ( raw_height ) * float ( raw_width ) ) ; if ( ! ( raw_width % 10 ) && ! ( data_size % 16384 ) && fratio >= 1.6f && fratio <= 1.6001f ) { load_raw = & CLASS panasonic_16x10_load_raw ; zero_is_bad = 0 ; } # endif if ( ( height += 12 ) > raw_height ) height = raw_height ; for ( i = 0 ; i < sizeof pana / sizeof * pana ; i ++ ) if ( raw_width == pana [ i ] [ 0 ] && raw_height == pana [ i ] [ 1 ] ) { left_margin = pana [ i ] [ 2 ] ; top_margin = pana [ i ] [ 3 ] ; width += pana [ i ] [ 4 ] ; height += pana [ i ] [ 5 ] ; } filters = 0x01010101 * ( uchar ) ""\\x94\\x61\\x49\\x16"" [ ( ( filters - 1 ) ^ ( left_margin & 1 ) ^ ( top_margin << 1 ) ) & 3 ] ; } else if ( ! strcmp ( model , ""C770UZ"" ) ) { height = 1718 ; width = 2304 ; filters = 0x16161616 ; load_raw = & CLASS packed_load_raw ; load_flags = 30 ; } else if ( ! strncmp ( make , ""Olympus"" , 7 ) ) { height += height & 1 ; if ( exif_cfa ) filters = exif_cfa ; if ( width == 4100 ) width -= 4 ; if ( width == 4080 ) width -= 24 ; if ( width == 9280 ) { width -= 6 ; height -= 6 ; } if ( load_raw == & CLASS unpacked_load_raw ) load_flags = 4 ; tiff_bps = 12 ; if ( ! strcmp ( model , ""E-300"" ) || ! strcmp ( model , ""E-500"" ) ) { width -= 20 ; if ( load_raw == & CLASS unpacked_load_raw ) { maximum = 0xfc3 ; memset ( cblack , 0 , sizeof cblack ) ; } } else if ( ! strcmp ( model , ""STYLUS1"" ) ) { width -= 14 ; maximum = 0xfff ; } else if ( ! strcmp ( model , ""E-330"" ) ) { width -= 30 ; if ( load_raw == & CLASS unpacked_load_raw ) maximum = 0xf79 ; } else if ( ! strcmp ( model , ""SP550UZ"" ) ) { thumb_length = flen - ( thumb_offset = 0xa39800 ) ; thumb_height = 480 ; thumb_width = 640 ; } else if ( ! strcmp ( model , ""TG-4"" ) ) { width -= 16 ; } else if ( ! strcmp ( model , ""TG-5"" ) ) { width -= 26 ; } } else if ( ! strcmp ( model , ""N<S2SV_blank>Digital"" ) ) { height = 2047 ; width = 3072 ; filters = 0x61616161 ; data_offset = 0x1a00 ; load_raw = & CLASS packed_load_raw ; } else if ( ! strcmp ( model , ""DSC-F828"" ) ) { width = 3288 ; left_margin = 5 ; mask [ 1 ] [ 3 ] = - 17 ; data_offset = 862144 ; load_raw = & CLASS sony_load_raw ; filters = 0x9c9c9c9c ; colors = 4 ; strcpy ( cdesc , ""RGBE"" ) ; } else if ( ! strcmp ( model , ""DSC-V3"" ) ) { width = 3109 ; left_margin = 59 ; mask [ 0 ] [ 1 ] = 9 ; data_offset = 787392 ; load_raw = & CLASS sony_load_raw ; } else if ( ! strncmp ( make , ""Sony"" , 4 ) && raw_width == 3984 ) { width = 3925 ; order = 0x4d4d ; } else if ( ! strncmp ( make , ""Sony"" , 4 ) && raw_width == 4288 ) { width -= 32 ; } else if ( ! strcmp ( make , ""Sony"" ) && raw_width == 4600 ) { if ( ! strcmp ( model , ""DSLR-A350"" ) ) height -= 4 ; black = 0 ; } else if ( ! strncmp ( make , ""Sony"" , 4 ) && raw_width == 4928 ) { if ( height < 3280 ) width -= 8 ; } else if ( ! strncmp ( make , ""Sony"" , 4 ) && raw_width == 5504 ) { width -= height > 3664 ? 8 : 32 ; } else if ( ! strncmp ( make , ""Sony"" , 4 ) && raw_width == 6048 ) { width -= 24 ; if ( strstr ( model , ""RX1"" ) || strstr ( model , ""A99"" ) ) width -= 6 ; } else if ( ! strncmp ( make , ""Sony"" , 4 ) && raw_width == 7392 ) { width -= 30 ; } else if ( ! strncmp ( make , ""Sony"" , 4 ) && raw_width == 8000 ) { width -= 32 ; } else if ( ! strcmp ( model , ""DSLR-A100"" ) ) { if ( width == 3880 ) { height -- ; width = ++ raw_width ; } else { height -= 4 ; width -= 4 ; order = 0x4d4d ; load_flags = 2 ; } filters = 0x61616161 ; } else if ( ! strcmp ( model , ""PIXL"" ) ) { height -= top_margin = 4 ; width -= left_margin = 32 ; gamma_curve ( 0 , 7 , 1 , 255 ) ; } else if ( ! strcmp ( model , ""C603"" ) || ! strcmp ( model , ""C330"" ) || ! strcmp ( model , ""12MP"" ) ) { order = 0x4949 ; if ( filters && data_offset ) { fseek ( ifp , data_offset < 4096 ? 168 : 5252 , SEEK_SET ) ; read_shorts ( curve , 256 ) ; } else gamma_curve ( 0 , 3.875 , 1 , 255 ) ; load_raw = filters ? & CLASS eight_bit_load_raw : strcmp ( model , ""C330"" ) ? & CLASS kodak_c603_load_raw : & CLASS kodak_c330_load_raw ; load_flags = tiff_bps > 16 ; tiff_bps = 8 ; } else if ( ! strncasecmp ( model , ""EasyShare"" , 9 ) ) { data_offset = data_offset < 0x15000 ? 0x15000 : 0x17000 ; load_raw = & CLASS packed_load_raw ; } else if ( ! strncasecmp ( make , ""Kodak"" , 5 ) ) { if ( filters == UINT_MAX ) filters = 0x61616161 ; if ( ! strncmp ( model , ""NC2000"" , 6 ) || ! strncmp ( model , ""EOSDCS"" , 6 ) || ! strncmp ( model , ""DCS4"" , 4 ) ) { width -= 4 ; left_margin = 2 ; if ( model [ 6 ] == '<S2SV_blank>' ) model [ 6 ] = 0 ; if ( ! strcmp ( model , ""DCS460A"" ) ) goto bw ; } else if ( ! strcmp ( model , ""DCS660M"" ) ) { black = 214 ; goto bw ; } else if ( ! strcmp ( model , ""DCS760M"" ) ) { bw : colors = 1 ; filters = 0 ; } if ( ! strcmp ( model + 4 , ""20X"" ) ) strcpy ( cdesc , ""MYCY"" ) ; if ( strstr ( model , ""DC25"" ) ) { strcpy ( model , ""DC25"" ) ; data_offset = 15424 ; } if ( ! strncmp ( model , ""DC2"" , 3 ) ) { raw_height = 2 + ( height = 242 ) ; if ( ! strncmp ( model , ""DC290"" , 5 ) ) iso_speed = 100 ; if ( ! strncmp ( model , ""DC280"" , 5 ) ) iso_speed = 70 ; if ( flen < 100000 ) { raw_width = 256 ; width = 249 ; pixel_aspect = ( 4.0 * height ) / ( 3.0 * width ) ; } else { raw_width = 512 ; width = 501 ; pixel_aspect = ( 493.0 * height ) / ( 373.0 * width ) ; } top_margin = left_margin = 1 ; colors = 4 ; filters = 0x8d8d8d8d ; simple_coeff ( 1 ) ; pre_mul [ 1 ] = 1.179 ; pre_mul [ 2 ] = 1.209 ; pre_mul [ 3 ] = 1.036 ; load_raw = & CLASS eight_bit_load_raw ; } else if ( ! strcmp ( model , ""40"" ) ) { strcpy ( model , ""DC40"" ) ; height = 512 ; width = 768 ; data_offset = 1152 ; load_raw = & CLASS kodak_radc_load_raw ; tiff_bps = 12 ; } else if ( strstr ( model , ""DC50"" ) ) { strcpy ( model , ""DC50"" ) ; height = 512 ; width = 768 ; iso_speed = 84 ; data_offset = 19712 ; load_raw = & CLASS kodak_radc_load_raw ; } else if ( strstr ( model , ""DC120"" ) ) { strcpy ( model , ""DC120"" ) ; raw_height = height = 976 ; raw_width = width = 848 ; iso_speed = 160 ; pixel_aspect = height / 0.75 / width ; load_raw = tiff_compress == 7 ? & CLASS kodak_jpeg_load_raw : & CLASS kodak_dc120_load_raw ; } else if ( ! strcmp ( model , ""DCS200"" ) ) { thumb_height = 128 ; thumb_width = 192 ; thumb_offset = 6144 ; thumb_misc = 360 ; iso_speed = 140 ; write_thumb = & CLASS layer_thumb ; black = 17 ; } } else if ( ! strcmp ( model , ""Fotoman<S2SV_blank>Pixtura"" ) ) { height = 512 ; width = 768 ; data_offset = 3632 ; load_raw = & CLASS kodak_radc_load_raw ; filters = 0x61616161 ; simple_coeff ( 2 ) ; } else if ( ! strncmp ( model , ""QuickTake"" , 9 ) ) { if ( head [ 5 ] ) strcpy ( model + 10 , ""200"" ) ; fseek ( ifp , 544 , SEEK_SET ) ; height = get2 ( ) ; width = get2 ( ) ; data_offset = ( get4 ( ) , get2 ( ) ) == 30 ? 738 : 736 ; if ( height > width ) { SWAP ( height , width ) ; fseek ( ifp , data_offset - 6 , SEEK_SET ) ; flip = ~ get2 ( ) & 3 ? 5 : 6 ; } filters = 0x61616161 ; } else if ( ! strncmp ( make , ""Rollei"" , 6 ) && ! load_raw ) { switch ( raw_width ) { case 1316 : height = 1030 ; width = 1300 ; top_margin = 1 ; left_margin = 6 ; break ; case 2568 : height = 1960 ; width = 2560 ; top_margin = 2 ; left_margin = 8 ; } filters = 0x16161616 ; load_raw = & CLASS rollei_load_raw ; } else if ( ! strcmp ( model , ""GRAS-50S5C"" ) ) { height = 2048 ; width = 2440 ; load_raw = & CLASS unpacked_load_raw ; data_offset = 0 ; filters = 0x49494949 ; order = 0x4949 ; maximum = 0xfffC ; } else if ( ! strcmp ( model , ""BB-500CL"" ) ) { height = 2058 ; width = 2448 ; load_raw = & CLASS unpacked_load_raw ; data_offset = 0 ; filters = 0x94949494 ; order = 0x4949 ; maximum = 0x3fff ; } else if ( ! strcmp ( model , ""BB-500GE"" ) ) { height = 2058 ; width = 2456 ; load_raw = & CLASS unpacked_load_raw ; data_offset = 0 ; filters = 0x94949494 ; order = 0x4949 ; maximum = 0x3fff ; } else if ( ! strcmp ( model , ""SVS625CL"" ) ) { height = 2050 ; width = 2448 ; load_raw = & CLASS unpacked_load_raw ; data_offset = 0 ; filters = 0x94949494 ; order = 0x4949 ; maximum = 0x0fff ; } if ( ! load_raw || height < 22 || width < 22 || # ifdef LIBRAW_LIBRARY_BUILD ( tiff_bps > 16 && load_raw != & LibRaw : : deflate_dng_load_raw ) # else tiff_bps > 16 # endif || tiff_samples > 4 || colors > 4 || colors < 1 ) { is_raw = 0 ; # ifdef LIBRAW_LIBRARY_BUILD RUN_CALLBACK ( LIBRAW_PROGRESS_IDENTIFY , 1 , 2 ) ; # endif return ; } if ( ! model [ 0 ] ) sprintf ( model , ""%dx%d"" , width , height ) ; if ( filters == UINT_MAX ) filters = 0x94949494 ; if ( thumb_offset && ! thumb_height ) { fseek ( ifp , thumb_offset , SEEK_SET ) ; if ( ljpeg_start ( & jh , 1 ) ) { thumb_width = jh . wide ; thumb_height = jh . high ; } } dng_skip : # ifdef LIBRAW_LIBRARY_BUILD if ( dng_version ) { int iifd = 0 ; for ( ; iifd < tiff_nifds ; iifd ++ ) if ( tiff_ifd [ iifd ] . offset == data_offset ) break ; int pifd = - 1 ; for ( int ii = 0 ; ii < tiff_nifds ; ii ++ ) if ( tiff_ifd [ ii ] . offset == thumb_offset ) { pifd = ii ; break ; } # define CFAROUND ( value , filters ) filters ? ( filters >= 1000 ? ( ( value + 1 ) / 2 ) * 2 : ( ( value + 5 ) / 6 ) * 6 ) : value # define IFDCOLORINDEX ( ifd , subset , bit ) ( tiff_ifd [ ifd ] . dng_color [ subset ] . parsedfields & bit ) ? ifd : ( ( tiff_ifd [ 0 ] . dng_color [ subset ] . parsedfields & bit ) ? 0 : - 1 ) # define IFDLEVELINDEX ( ifd , bit ) ( tiff_ifd [ ifd ] . dng_levels . parsedfields & bit ) ? ifd : ( ( tiff_ifd [ 0 ] . dng_levels . parsedfields & bit ) ? 0 : - 1 ) # define COPYARR ( to , from ) memmove ( & to , & from , sizeof ( from ) ) if ( iifd < tiff_nifds ) { int sidx ; if ( imgdata . params . raw_processing_options & LIBRAW_PROCESSING_USE_DNG_DEFAULT_CROP ) { sidx = IFDLEVELINDEX ( iifd , LIBRAW_DNGFM_CROPORIGIN ) ; int sidx2 = IFDLEVELINDEX ( iifd , LIBRAW_DNGFM_CROPSIZE ) ; if ( sidx >= 0 && sidx == sidx2 ) { int lm = tiff_ifd [ sidx ] . dng_levels . default_crop [ 0 ] ; int lmm = CFAROUND ( lm , filters ) ; int tm = tiff_ifd [ sidx ] . dng_levels . default_crop [ 1 ] ; int tmm = CFAROUND ( tm , filters ) ; int ww = tiff_ifd [ sidx ] . dng_levels . default_crop [ 2 ] ; int hh = tiff_ifd [ sidx ] . dng_levels . default_crop [ 3 ] ; if ( lmm > lm ) ww -= ( lmm - lm ) ; if ( tmm > tm ) hh -= ( tmm - tm ) ; if ( left_margin + lm + ww <= raw_width && top_margin + tm + hh <= raw_height ) { left_margin += lmm ; top_margin += tmm ; width = ww ; height = hh ; } } } if ( ! ( imgdata . color . dng_color [ 0 ] . parsedfields & LIBRAW_DNGFM_FORWARDMATRIX ) ) { sidx = IFDCOLORINDEX ( iifd , 0 , LIBRAW_DNGFM_FORWARDMATRIX ) ; if ( sidx >= 0 ) COPYARR ( imgdata . color . dng_color [ 0 ] . forwardmatrix , tiff_ifd [ sidx ] . dng_color [ 0 ] . forwardmatrix ) ; } if ( ! ( imgdata . color . dng_color [ 1 ] . parsedfields & LIBRAW_DNGFM_FORWARDMATRIX ) ) { sidx = IFDCOLORINDEX ( iifd , 1 , LIBRAW_DNGFM_FORWARDMATRIX ) ; if ( sidx >= 0 ) COPYARR ( imgdata . color . dng_color [ 1 ] . forwardmatrix , tiff_ifd [ sidx ] . dng_color [ 1 ] . forwardmatrix ) ; } for ( int ss = 0 ; ss < 2 ; ss ++ ) { sidx = IFDCOLORINDEX ( iifd , ss , LIBRAW_DNGFM_COLORMATRIX ) ; if ( sidx >= 0 ) COPYARR ( imgdata . color . dng_color [ ss ] . colormatrix , tiff_ifd [ sidx ] . dng_color [ ss ] . colormatrix ) ; sidx = IFDCOLORINDEX ( iifd , ss , LIBRAW_DNGFM_CALIBRATION ) ; if ( sidx >= 0 ) COPYARR ( imgdata . color . dng_color [ ss ] . calibration , tiff_ifd [ sidx ] . dng_color [ ss ] . calibration ) ; sidx = IFDCOLORINDEX ( iifd , ss , LIBRAW_DNGFM_ILLUMINANT ) ; if ( sidx >= 0 ) imgdata . color . dng_color [ ss ] . illuminant = tiff_ifd [ sidx ] . dng_color [ ss ] . illuminant ; } sidx = IFDLEVELINDEX ( iifd , LIBRAW_DNGFM_ANALOGBALANCE ) ; if ( sidx >= 0 ) COPYARR ( imgdata . color . dng_levels . analogbalance , tiff_ifd [ sidx ] . dng_levels . analogbalance ) ; sidx = IFDLEVELINDEX ( iifd , LIBRAW_DNGFM_WHITE ) ; if ( sidx >= 0 ) COPYARR ( imgdata . color . dng_levels . dng_whitelevel , tiff_ifd [ sidx ] . dng_levels . dng_whitelevel ) ; sidx = IFDLEVELINDEX ( iifd , LIBRAW_DNGFM_BLACK ) ; if ( sidx >= 0 ) { imgdata . color . dng_levels . dng_black = tiff_ifd [ sidx ] . dng_levels . dng_black ; COPYARR ( imgdata . color . dng_levels . dng_cblack , tiff_ifd [ sidx ] . dng_levels . dng_cblack ) ; } if ( pifd >= 0 ) { sidx = IFDLEVELINDEX ( pifd , LIBRAW_DNGFM_PREVIEWCS ) ; if ( sidx >= 0 ) imgdata . color . dng_levels . preview_colorspace = tiff_ifd [ sidx ] . dng_levels . preview_colorspace ; } sidx = IFDLEVELINDEX ( iifd , LIBRAW_DNGFM_OPCODE2 ) ; if ( sidx >= 0 ) meta_offset = tiff_ifd [ sidx ] . opcode2_offset ; sidx = IFDLEVELINDEX ( iifd , LIBRAW_DNGFM_LINTABLE ) ; INT64 linoff = - 1 ; int linlen = 0 ; if ( sidx >= 0 ) { linoff = tiff_ifd [ sidx ] . lineartable_offset ; linlen = tiff_ifd [ sidx ] . lineartable_len ; } if ( linoff >= 0 && linlen > 0 ) { INT64 pos = ftell ( ifp ) ; fseek ( ifp , linoff , SEEK_SET ) ; linear_table ( linlen ) ; fseek ( ifp , pos , SEEK_SET ) ; } } maximum = imgdata . color . dng_levels . dng_whitelevel [ 0 ] ; black = imgdata . color . dng_levels . dng_black ; int ll = LIM ( 0 , ( sizeof ( cblack ) / sizeof ( cblack [ 0 ] ) ) , ( sizeof ( imgdata . color . dng_levels . dng_cblack ) / sizeof ( imgdata . color . dng_levels . dng_cblack [ 0 ] ) ) ) ; for ( int i = 0 ; i < ll ; i ++ ) cblack [ i ] = imgdata . color . dng_levels . dng_cblack [ i ] ; } # endif if ( ! load_raw || height < 22 || width < 22 || # ifdef LIBRAW_LIBRARY_BUILD ( tiff_bps > 16 && load_raw != & LibRaw : : deflate_dng_load_raw ) # else tiff_bps > 16 # endif || tiff_samples > 4 || colors > 4 || colors < 1 ) { is_raw = 0 ; # ifdef LIBRAW_LIBRARY_BUILD RUN_CALLBACK ( LIBRAW_PROGRESS_IDENTIFY , 1 , 2 ) ; # endif return ; } if ( ( use_camera_matrix & ( ( use_camera_wb || dng_version ) | 0x2 ) ) && cmatrix [ 0 ] [ 0 ] > 0.125 ) { memcpy ( rgb_cam , cmatrix , sizeof cmatrix ) ; raw_color = 0 ; } if ( raw_color ) adobe_coeff ( make , model ) ; # ifdef LIBRAW_LIBRARY_BUILD else if ( imgdata . color . cam_xyz [ 0 ] [ 0 ] < 0.01 ) adobe_coeff ( make , model , 1 ) ; # endif if ( load_raw == & CLASS kodak_radc_load_raw ) if ( raw_color ) adobe_coeff ( ""Apple"" , ""Quicktake"" ) ; <S2SV_StartBug> if ( fuji_width ) <S2SV_EndBug> { fuji_width = width >> ! fuji_layout ; filters = fuji_width & 1 ? 0x94949494 : 0x49494949 ; width = ( height >> fuji_layout ) + fuji_width ; height = width - 1 ; pixel_aspect = 1 ; } else { if ( raw_height < height ) raw_height = height ; if ( raw_width < width ) raw_width = width ; } if ( ! tiff_bps ) tiff_bps = 12 ; if ( ! maximum ) { maximum = ( 1 << tiff_bps ) - 1 ; if ( maximum < 0x10000 && curve [ maximum ] > 0 && load_raw == & CLASS sony_arw2_load_raw ) maximum = curve [ maximum ] ; } if ( ! load_raw || height < 22 || width < 22 || # ifdef LIBRAW_LIBRARY_BUILD ( tiff_bps > 16 && load_raw != & LibRaw : : deflate_dng_load_raw ) # else tiff_bps > 16 # endif || tiff_samples > 6 || colors > 4 ) is_raw = 0 ; if ( raw_width < 22 || raw_width > 64000 || raw_height < 22 || raw_height > 64000 ) is_raw = 0 ; # ifdef NO_JASPER if ( load_raw == & CLASS redcine_load_raw ) { # ifdef DCRAW_VERBOSE fprintf ( stderr , _ ( ""%s:<S2SV_blank>You<S2SV_blank>must<S2SV_blank>link<S2SV_blank>dcraw<S2SV_blank>with<S2SV_blank>%s!!\\n"" ) , ifname , ""libjasper"" ) ; # endif is_raw = 0 ; # ifdef LIBRAW_LIBRARY_BUILD imgdata . process_warnings |= LIBRAW_WARN_NO_JASPER ; # endif } # endif # ifdef NO_JPEG if ( load_raw == & CLASS kodak_jpeg_load_raw || load_raw == & CLASS lossy_dng_load_raw ) { # ifdef DCRAW_VERBOSE fprintf ( stderr , _ ( ""%s:<S2SV_blank>You<S2SV_blank>must<S2SV_blank>link<S2SV_blank>dcraw<S2SV_blank>with<S2SV_blank>%s!!\\n"" ) , ifname , ""libjpeg"" ) ; # endif is_raw = 0 ; # ifdef LIBRAW_LIBRARY_BUILD imgdata . process_warnings |= LIBRAW_WARN_NO_JPEGLIB ; # endif } # endif if ( ! cdesc [ 0 ] ) strcpy ( cdesc , colors == 3 ? ""RGBG"" : ""GMCY"" ) ; if ( ! raw_height ) raw_height = height ; if ( ! raw_width ) raw_width = width ; if ( filters > 999 && colors == 3 ) filters |= ( ( filters >> 2 & 0x22222222 ) | ( filters << 2 & 0x88888888 ) ) & filters << 1 ; notraw : if ( flip == UINT_MAX ) flip = tiff_flip ; if ( flip == UINT_MAX ) flip = 0 ; if ( flip > 89 || flip < - 89 ) { switch ( ( flip + 3600 ) % 360 ) { case 270 : flip = 5 ; break ; case 180 : flip = 3 ; break ; case 90 : flip = 6 ; break ; } } # ifdef LIBRAW_LIBRARY_BUILD RUN_CALLBACK ( LIBRAW_PROGRESS_IDENTIFY , 1 , 2 ) ; # endif }","""Quicktake"" ) ; # ifdef LIBRAW_LIBRARY_BUILD if ( fuji_width && ! dng_version && ! ( imgdata . process_warnings & LIBRAW_WARN_PARSEFUJI_PROCESSED ) ) fuji_width = 0 ; # endif"
671,"int rds_sendmsg ( struct socket * sock , struct msghdr * msg , size_t payload_len ) { struct sock * sk = sock -> sk ; struct rds_sock * rs = rds_sk_to_rs ( sk ) ; DECLARE_SOCKADDR ( struct sockaddr_in * , usin , msg -> msg_name ) ; __be32 daddr ; __be16 dport ; struct rds_message * rm = NULL ; struct rds_connection * conn ; int ret = 0 ; int queued = 0 , allocated_mr = 0 ; int nonblock = msg -> msg_flags & MSG_DONTWAIT ; long timeo = sock_sndtimeo ( sk , nonblock ) ; if ( msg -> msg_flags & ~ ( MSG_DONTWAIT | MSG_CMSG_COMPAT ) ) { ret = - EOPNOTSUPP ; goto out ; } if ( msg -> msg_namelen ) { if ( msg -> msg_namelen < sizeof ( * usin ) || usin -> sin_family != AF_INET ) { ret = - EINVAL ; goto out ; } daddr = usin -> sin_addr . s_addr ; dport = usin -> sin_port ; } else { lock_sock ( sk ) ; daddr = rs -> rs_conn_addr ; dport = rs -> rs_conn_port ; release_sock ( sk ) ; } <S2SV_StartBug> if ( daddr == 0 || rs -> rs_bound_addr == 0 ) { <S2SV_EndBug> <S2SV_StartBug> ret = - ENOTCONN ; <S2SV_EndBug> goto out ; <S2SV_StartBug> } <S2SV_EndBug> if ( payload_len > rds_sk_sndbuf ( rs ) ) { ret = - EMSGSIZE ; goto out ; } ret = rds_rm_size ( msg , payload_len ) ; if ( ret < 0 ) goto out ; rm = rds_message_alloc ( ret , GFP_KERNEL ) ; if ( ! rm ) { ret = - ENOMEM ; goto out ; } if ( payload_len ) { rm -> data . op_sg = rds_message_alloc_sgs ( rm , ceil ( payload_len , PAGE_SIZE ) ) ; if ( ! rm -> data . op_sg ) { ret = - ENOMEM ; goto out ; } ret = rds_message_copy_from_user ( rm , & msg -> msg_iter ) ; if ( ret ) goto out ; } rm -> data . op_active = 1 ; rm -> m_daddr = daddr ; if ( rs -> rs_conn && rs -> rs_conn -> c_faddr == daddr ) conn = rs -> rs_conn ; else { conn = rds_conn_create_outgoing ( sock_net ( sock -> sk ) , rs -> rs_bound_addr , daddr , rs -> rs_transport , sock -> sk -> sk_allocation ) ; if ( IS_ERR ( conn ) ) { ret = PTR_ERR ( conn ) ; goto out ; } rs -> rs_conn = conn ; } ret = rds_cmsg_send ( rs , rm , msg , & allocated_mr ) ; if ( ret ) goto out ; if ( rm -> rdma . op_active && ! conn -> c_trans -> xmit_rdma ) { printk_ratelimited ( KERN_NOTICE ""rdma_op<S2SV_blank>%p<S2SV_blank>conn<S2SV_blank>xmit_rdma<S2SV_blank>%p\\n"" , & rm -> rdma , conn -> c_trans -> xmit_rdma ) ; ret = - EOPNOTSUPP ; goto out ; } if ( rm -> atomic . op_active && ! conn -> c_trans -> xmit_atomic ) { printk_ratelimited ( KERN_NOTICE ""atomic_op<S2SV_blank>%p<S2SV_blank>conn<S2SV_blank>xmit_atomic<S2SV_blank>%p\\n"" , & rm -> atomic , conn -> c_trans -> xmit_atomic ) ; ret = - EOPNOTSUPP ; goto out ; } rds_conn_connect_if_down ( conn ) ; ret = rds_cong_wait ( conn -> c_fcong , dport , nonblock , rs ) ; if ( ret ) { rs -> rs_seen_congestion = 1 ; goto out ; } while ( ! rds_send_queue_rm ( rs , conn , rm , rs -> rs_bound_port , dport , & queued ) ) { rds_stats_inc ( s_send_queue_full ) ; if ( nonblock ) { ret = - EAGAIN ; goto out ; } timeo = wait_event_interruptible_timeout ( * sk_sleep ( sk ) , rds_send_queue_rm ( rs , conn , rm , rs -> rs_bound_port , dport , & queued ) , timeo ) ; rdsdebug ( ""sendmsg<S2SV_blank>woke<S2SV_blank>queued<S2SV_blank>%d<S2SV_blank>timeo<S2SV_blank>%ld\\n"" , queued , timeo ) ; if ( timeo > 0 || timeo == MAX_SCHEDULE_TIMEOUT ) continue ; ret = timeo ; if ( ret == 0 ) ret = - ETIMEDOUT ; goto out ; } rds_stats_inc ( s_send_queued ) ; ret = rds_send_xmit ( conn ) ; if ( ret == - ENOMEM || ret == - EAGAIN ) queue_delayed_work ( rds_wq , & conn -> c_send_w , 1 ) ; rds_message_put ( rm ) ; return payload_len ; out : if ( allocated_mr ) rds_rdma_unuse ( rs , rds_rdma_cookie_key ( rm -> m_rdma_cookie ) , 1 ) ; if ( rm ) rds_message_put ( rm ) ; return ret ; }",) ; } lock_sock ( sk ) ; <S2SV_ModStart> 0 ) { release_sock ( sk ) ; <S2SV_ModStart> out ; } release_sock ( sk ) ;
672,"static struct sk_buff * ipv6_gso_segment ( struct sk_buff * skb , netdev_features_t features ) { struct sk_buff * segs = ERR_PTR ( - EINVAL ) ; struct ipv6hdr * ipv6h ; const struct net_offload * ops ; int proto ; struct frag_hdr * fptr ; unsigned int unfrag_ip6hlen ; unsigned int payload_len ; u8 * prevhdr ; int offset = 0 ; bool encap , udpfrag ; int nhoff ; bool gso_partial ; skb_reset_network_header ( skb ) ; nhoff = skb_network_header ( skb ) - skb_mac_header ( skb ) ; if ( unlikely ( ! pskb_may_pull ( skb , sizeof ( * ipv6h ) ) ) ) goto out ; encap = SKB_GSO_CB ( skb ) -> encap_level > 0 ; if ( encap ) features &= skb -> dev -> hw_enc_features ; SKB_GSO_CB ( skb ) -> encap_level += sizeof ( * ipv6h ) ; ipv6h = ipv6_hdr ( skb ) ; __skb_pull ( skb , sizeof ( * ipv6h ) ) ; segs = ERR_PTR ( - EPROTONOSUPPORT ) ; proto = ipv6_gso_pull_exthdrs ( skb , ipv6h -> nexthdr ) ; if ( skb -> encapsulation && skb_shinfo ( skb ) -> gso_type & ( SKB_GSO_IPXIP4 | SKB_GSO_IPXIP6 ) ) udpfrag = proto == IPPROTO_UDP && encap ; else udpfrag = proto == IPPROTO_UDP && ! skb -> encapsulation ; ops = rcu_dereference ( inet6_offloads [ proto ] ) ; if ( likely ( ops && ops -> callbacks . gso_segment ) ) { skb_reset_transport_header ( skb ) ; segs = ops -> callbacks . gso_segment ( skb , features ) ; } if ( IS_ERR_OR_NULL ( segs ) ) goto out ; gso_partial = ! ! ( skb_shinfo ( segs ) -> gso_type & SKB_GSO_PARTIAL ) ; for ( skb = segs ; skb ; skb = skb -> next ) { ipv6h = ( struct ipv6hdr * ) ( skb_mac_header ( skb ) + nhoff ) ; if ( gso_partial ) payload_len = skb_shinfo ( skb ) -> gso_size + SKB_GSO_CB ( skb ) -> data_offset + skb -> head - ( unsigned char * ) ( ipv6h + 1 ) ; else payload_len = skb -> len - nhoff - sizeof ( * ipv6h ) ; ipv6h -> payload_len = htons ( payload_len ) ; skb -> network_header = ( u8 * ) ipv6h - skb -> head ; if ( udpfrag ) { unfrag_ip6hlen = ip6_find_1stfragopt ( skb , & prevhdr ) ; <S2SV_StartBug> fptr = ( struct frag_hdr * ) ( ( u8 * ) ipv6h + unfrag_ip6hlen ) ; <S2SV_EndBug> fptr -> frag_off = htons ( offset ) ; if ( skb -> next ) fptr -> frag_off |= htons ( IP6_MF ) ; offset += ( ntohs ( ipv6h -> payload_len ) - sizeof ( struct frag_hdr ) ) ; } if ( encap ) skb_reset_inner_headers ( skb ) ; } out : return segs ; }",prevhdr ) ; if ( unfrag_ip6hlen < 0 ) return ERR_PTR ( unfrag_ip6hlen ) ;
673,"static void decode_macroblock ( VP8D_COMP * pbi , MACROBLOCKD * xd , unsigned int mb_idx ) { MB_PREDICTION_MODE mode ; int i ; # if CONFIG_ERROR_CONCEALMENT int corruption_detected = 0 ; <S2SV_StartBug> # endif <S2SV_EndBug> if ( xd -> mode_info_context -> mbmi . mb_skip_coeff ) { vp8_reset_mb_tokens_context ( xd ) ; } else if ( ! vp8dx_bool_error ( xd -> current_bc ) ) { int eobtotal ; eobtotal = vp8_decode_mb_tokens ( pbi , xd ) ; xd -> mode_info_context -> mbmi . mb_skip_coeff = ( eobtotal == 0 ) ; } mode = xd -> mode_info_context -> mbmi . mode ; if ( xd -> segmentation_enabled ) vp8_mb_init_dequantizer ( pbi , xd ) ; # if CONFIG_ERROR_CONCEALMENT if ( pbi -> ec_active ) { int throw_residual ; throw_residual = ( ! pbi -> independent_partitions && pbi -> frame_corrupt_residual ) ; throw_residual = ( throw_residual || vp8dx_bool_error ( xd -> current_bc ) ) ; if ( ( mb_idx >= pbi -> mvs_corrupt_from_mb || throw_residual ) ) { pbi -> frame_corrupt_residual = 1 ; <S2SV_StartBug> vpx_memset ( xd -> qcoeff , 0 , sizeof ( xd -> qcoeff ) ) ; <S2SV_EndBug> vp8_conceal_corrupt_mb ( xd ) ; corruption_detected = 1 ; <S2SV_StartBug> vpx_memset ( xd -> eobs , 0 , 25 ) ; <S2SV_EndBug> } } # endif if ( xd -> mode_info_context -> mbmi . ref_frame == INTRA_FRAME ) { vp8_build_intra_predictors_mbuv_s ( xd , xd -> recon_above [ 1 ] , xd -> recon_above [ 2 ] , xd -> recon_left [ 1 ] , xd -> recon_left [ 2 ] , xd -> recon_left_stride [ 1 ] , xd -> dst . u_buffer , xd -> dst . v_buffer , xd -> dst . uv_stride ) ; if ( mode != B_PRED ) { vp8_build_intra_predictors_mby_s ( xd , xd -> recon_above [ 0 ] , xd -> recon_left [ 0 ] , xd -> recon_left_stride [ 0 ] , xd -> dst . y_buffer , xd -> dst . y_stride ) ; } else { short * DQC = xd -> dequant_y1 ; int dst_stride = xd -> dst . y_stride ; if ( xd -> mode_info_context -> mbmi . mb_skip_coeff ) <S2SV_StartBug> vpx_memset ( xd -> eobs , 0 , 25 ) ; <S2SV_EndBug> intra_prediction_down_copy ( xd , xd -> recon_above [ 0 ] + 16 ) ; for ( i = 0 ; i < 16 ; i ++ ) { BLOCKD * b = & xd -> block [ i ] ; unsigned char * dst = xd -> dst . y_buffer + b -> offset ; B_PREDICTION_MODE b_mode = xd -> mode_info_context -> bmi [ i ] . as_mode ; unsigned char * Above = dst - dst_stride ; unsigned char * yleft = dst - 1 ; int left_stride = dst_stride ; unsigned char top_left = Above [ - 1 ] ; vp8_intra4x4_predict ( Above , yleft , left_stride , b_mode , dst , dst_stride , top_left ) ; if ( xd -> eobs [ i ] ) { if ( xd -> eobs [ i ] > 1 ) { vp8_dequant_idct_add ( b -> qcoeff , DQC , dst , dst_stride ) ; } else { vp8_dc_only_idct_add ( b -> qcoeff [ 0 ] * DQC [ 0 ] , dst , dst_stride , dst , dst_stride ) ; <S2SV_StartBug> vpx_memset ( b -> qcoeff , 0 , 2 * sizeof ( b -> qcoeff [ 0 ] ) ) ; <S2SV_EndBug> } } } } } else { vp8_build_inter_predictors_mb ( xd ) ; } # if CONFIG_ERROR_CONCEALMENT if ( corruption_detected ) { return ; } # endif if ( ! xd -> mode_info_context -> mbmi . mb_skip_coeff ) { if ( mode != B_PRED ) { short * DQC = xd -> dequant_y1 ; if ( mode != SPLITMV ) { BLOCKD * b = & xd -> block [ 24 ] ; if ( xd -> eobs [ 24 ] > 1 ) { vp8_dequantize_b ( b , xd -> dequant_y2 ) ; vp8_short_inv_walsh4x4 ( & b -> dqcoeff [ 0 ] , xd -> qcoeff ) ; <S2SV_StartBug> vpx_memset ( b -> qcoeff , 0 , 16 * sizeof ( b -> qcoeff [ 0 ] ) ) ; <S2SV_EndBug> } else { b -> dqcoeff [ 0 ] = b -> qcoeff [ 0 ] * xd -> dequant_y2 [ 0 ] ; vp8_short_inv_walsh4x4_1 ( & b -> dqcoeff [ 0 ] , xd -> qcoeff ) ; <S2SV_StartBug> vpx_memset ( b -> qcoeff , 0 , 2 * sizeof ( b -> qcoeff [ 0 ] ) ) ; <S2SV_EndBug> } DQC = xd -> dequant_y1_dc ; } vp8_dequant_idct_add_y_block ( xd -> qcoeff , DQC , xd -> dst . y_buffer , xd -> dst . y_stride , xd -> eobs ) ; } vp8_dequant_idct_add_uv_block ( xd -> qcoeff + 16 * 16 , xd -> dequant_uv , xd -> dst . u_buffer , xd -> dst . v_buffer , xd -> dst . uv_stride , xd -> eobs + 16 ) ; } }",0 ; # else ( void ) mb_idx ; # <S2SV_ModStart> = 1 ; memset <S2SV_ModEnd> ( xd -> <S2SV_ModStart> = 1 ; memset <S2SV_ModEnd> ( xd -> <S2SV_ModStart> . mb_skip_coeff ) memset <S2SV_ModEnd> ( xd -> <S2SV_ModStart> dst_stride ) ; memset <S2SV_ModEnd> ( b -> <S2SV_ModStart> qcoeff ) ; memset <S2SV_ModEnd> ( b -> <S2SV_ModStart> qcoeff ) ; memset <S2SV_ModEnd> ( b ->
674,"<S2SV_StartBug> static void show_object ( struct object * object , struct strbuf * path , <S2SV_EndBug> <S2SV_StartBug> const char * last , void * data ) <S2SV_EndBug> { struct bitmap * base = data ; int bitmap_pos ; bitmap_pos = bitmap_position ( object -> oid . hash ) ; <S2SV_StartBug> if ( bitmap_pos < 0 ) { <S2SV_EndBug> char * name = path_name ( path , last ) ; bitmap_pos = ext_index_add_object ( object , name ) ; <S2SV_StartBug> free ( name ) ; <S2SV_EndBug> } bitmap_set ( base , bitmap_pos ) ; }","* object , <S2SV_ModEnd> const char * <S2SV_ModStart> const char * name <S2SV_ModEnd> , void * <S2SV_ModStart> < 0 ) <S2SV_ModEnd> bitmap_pos = ext_index_add_object <S2SV_ModStart> name ) ; <S2SV_ModEnd> bitmap_set ( base"
675,"qboolean S_AL_Init ( soundInterface_t * si ) { # ifdef USE_OPENAL const char * device = NULL ; const char * inputdevice = NULL ; int i ; if ( ! si ) { return qfalse ; } for ( i = 0 ; i < MAX_RAW_STREAMS ; i ++ ) { streamSourceHandles [ i ] = - 1 ; streamPlaying [ i ] = qfalse ; streamSources [ i ] = 0 ; streamNumBuffers [ i ] = 0 ; streamBufIndex [ i ] = 0 ; } s_alPrecache = Cvar_Get ( ""s_alPrecache"" , ""1"" , CVAR_ARCHIVE ) ; s_alGain = Cvar_Get ( ""s_alGain"" , ""1.0"" , CVAR_ARCHIVE ) ; s_alSources = Cvar_Get ( ""s_alSources"" , ""128"" , CVAR_ARCHIVE ) ; s_alDopplerFactor = Cvar_Get ( ""s_alDopplerFactor"" , ""1.0"" , CVAR_ARCHIVE ) ; s_alDopplerSpeed = Cvar_Get ( ""s_alDopplerSpeed"" , ""9000"" , CVAR_ARCHIVE ) ; s_alMinDistance = Cvar_Get ( ""s_alMinDistance"" , ""256"" , CVAR_ARCHIVE ) ; s_alMaxDistance = Cvar_Get ( ""s_alMaxDistance"" , ""1024"" , CVAR_ARCHIVE ) ; s_alRolloff = Cvar_Get ( ""s_alRolloff"" , ""1.3"" , CVAR_ARCHIVE ) ; s_alGraceDistance = Cvar_Get ( ""s_alGraceDistance"" , ""512"" , CVAR_ARCHIVE ) ; s_alTalkAnims = Cvar_Get ( ""s_alTalkAnims"" , ""160"" , CVAR_ARCHIVE ) ; <S2SV_StartBug> s_alDriver = Cvar_Get ( ""s_alDriver"" , ALDRIVER_DEFAULT , CVAR_ARCHIVE | CVAR_LATCH ) ; <S2SV_EndBug> s_alInputDevice = Cvar_Get ( ""s_alInputDevice"" , """" , CVAR_ARCHIVE | CVAR_LATCH ) ; <S2SV_StartBug> s_alDevice = Cvar_Get ( ""s_alDevice"" , """" , CVAR_ARCHIVE | CVAR_LATCH ) ; <S2SV_EndBug> if ( ! QAL_Init ( s_alDriver -> string ) ) { # if defined ( _WIN32 ) if ( ! Q_stricmp ( s_alDriver -> string , ALDRIVER_DEFAULT ) && ! QAL_Init ( ""OpenAL64.dll"" ) ) { # elif defined ( __APPLE__ ) if ( ! Q_stricmp ( s_alDriver -> string , ALDRIVER_DEFAULT ) && ! QAL_Init ( ""/System/Library/Frameworks/OpenAL.framework/OpenAL"" ) ) { # else if ( ! Q_stricmp ( s_alDriver -> string , ALDRIVER_DEFAULT ) || ! QAL_Init ( ALDRIVER_DEFAULT ) ) { # endif return qfalse ; } } device = s_alDevice -> string ; if ( device && ! * device ) device = NULL ; inputdevice = s_alInputDevice -> string ; if ( inputdevice && ! * inputdevice ) inputdevice = NULL ; enumeration_all_ext = qalcIsExtensionPresent ( NULL , ""ALC_ENUMERATE_ALL_EXT"" ) ; enumeration_ext = qalcIsExtensionPresent ( NULL , ""ALC_ENUMERATION_EXT"" ) ; if ( enumeration_ext || enumeration_all_ext ) { char devicenames [ 16384 ] = """" ; const char * devicelist ; # ifdef _WIN32 const char * defaultdevice ; # endif int curlen ; if ( enumeration_all_ext ) { devicelist = qalcGetString ( NULL , ALC_ALL_DEVICES_SPECIFIER ) ; # ifdef _WIN32 defaultdevice = qalcGetString ( NULL , ALC_DEFAULT_ALL_DEVICES_SPECIFIER ) ; # endif } else { devicelist = qalcGetString ( NULL , ALC_DEVICE_SPECIFIER ) ; # ifdef _WIN32 defaultdevice = qalcGetString ( NULL , ALC_DEFAULT_DEVICE_SPECIFIER ) ; # endif enumeration_ext = qtrue ; } # ifdef _WIN32 if ( ! device && defaultdevice && ! strcmp ( defaultdevice , ""Generic<S2SV_blank>Hardware"" ) ) device = ""Generic<S2SV_blank>Software"" ; # endif if ( devicelist ) { while ( ( curlen = strlen ( devicelist ) ) ) { Q_strcat ( devicenames , sizeof ( devicenames ) , devicelist ) ; Q_strcat ( devicenames , sizeof ( devicenames ) , ""\\n"" ) ; devicelist += curlen + 1 ; } } s_alAvailableDevices = Cvar_Get ( ""s_alAvailableDevices"" , devicenames , CVAR_ROM | CVAR_NORESTART ) ; } alDevice = qalcOpenDevice ( device ) ; if ( ! alDevice && device ) { Com_Printf ( ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>OpenAL<S2SV_blank>device<S2SV_blank>\'%s\',<S2SV_blank>trying<S2SV_blank>default.\\n"" , device ) ; alDevice = qalcOpenDevice ( NULL ) ; } if ( ! alDevice ) { QAL_Shutdown ( ) ; Com_Printf ( ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>OpenAL<S2SV_blank>device.\\n"" ) ; return qfalse ; } alContext = qalcCreateContext ( alDevice , NULL ) ; if ( ! alContext ) { QAL_Shutdown ( ) ; qalcCloseDevice ( alDevice ) ; Com_Printf ( ""Failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>OpenAL<S2SV_blank>context.\\n"" ) ; return qfalse ; } qalcMakeContextCurrent ( alContext ) ; S_AL_BufferInit ( ) ; S_AL_SrcInit ( ) ; Com_Printf ( ""Allocated<S2SV_blank>%d<S2SV_blank>sources.\\n"" , srcCount ) ; qalDistanceModel ( AL_INVERSE_DISTANCE_CLAMPED ) ; qalDopplerFactor ( s_alDopplerFactor -> value ) ; qalSpeedOfSound ( s_alDopplerSpeed -> value ) ; # ifdef USE_VOIP s_alCapture = Cvar_Get ( ""s_alCapture"" , ""1"" , CVAR_ARCHIVE | CVAR_LATCH ) ; if ( ! s_alCapture -> integer ) { Com_Printf ( ""OpenAL<S2SV_blank>capture<S2SV_blank>support<S2SV_blank>disabled<S2SV_blank>by<S2SV_blank>user<S2SV_blank>(\'+set<S2SV_blank>s_alCapture<S2SV_blank>1\'<S2SV_blank>to<S2SV_blank>enable)\\n"" ) ; } # if USE_MUMBLE else if ( cl_useMumble -> integer ) { Com_Printf ( ""OpenAL<S2SV_blank>capture<S2SV_blank>support<S2SV_blank>disabled<S2SV_blank>for<S2SV_blank>Mumble<S2SV_blank>support\\n"" ) ; } # endif else { # ifdef __APPLE__ if ( qalcCaptureOpenDevice == NULL ) # else if ( ! qalcIsExtensionPresent ( NULL , ""ALC_EXT_capture"" ) ) # endif { Com_Printf ( ""No<S2SV_blank>ALC_EXT_capture<S2SV_blank>support,<S2SV_blank>can\'t<S2SV_blank>record<S2SV_blank>audio.\\n"" ) ; } else { char inputdevicenames [ 16384 ] = """" ; const char * inputdevicelist ; const char * defaultinputdevice ; int curlen ; capture_ext = qtrue ; inputdevicelist = qalcGetString ( NULL , ALC_CAPTURE_DEVICE_SPECIFIER ) ; defaultinputdevice = qalcGetString ( NULL , ALC_CAPTURE_DEFAULT_DEVICE_SPECIFIER ) ; if ( inputdevicelist ) { while ( ( curlen = strlen ( inputdevicelist ) ) ) { Q_strcat ( inputdevicenames , sizeof ( inputdevicenames ) , inputdevicelist ) ; Q_strcat ( inputdevicenames , sizeof ( inputdevicenames ) , ""\\n"" ) ; inputdevicelist += curlen + 1 ; } } s_alAvailableInputDevices = Cvar_Get ( ""s_alAvailableInputDevices"" , inputdevicenames , CVAR_ROM | CVAR_NORESTART ) ; Com_Printf ( ""OpenAL<S2SV_blank>default<S2SV_blank>capture<S2SV_blank>device<S2SV_blank>is<S2SV_blank>\'%s\'\\n"" , defaultinputdevice ? defaultinputdevice : ""none"" ) ; alCaptureDevice = qalcCaptureOpenDevice ( inputdevice , 48000 , AL_FORMAT_MONO16 , VOIP_MAX_PACKET_SAMPLES * 4 ) ; if ( ! alCaptureDevice && inputdevice ) { Com_Printf ( ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>OpenAL<S2SV_blank>Input<S2SV_blank>device<S2SV_blank>\'%s\',<S2SV_blank>trying<S2SV_blank>default.\\n"" , inputdevice ) ; alCaptureDevice = qalcCaptureOpenDevice ( NULL , 48000 , AL_FORMAT_MONO16 , VOIP_MAX_PACKET_SAMPLES * 4 ) ; } Com_Printf ( ""OpenAL<S2SV_blank>capture<S2SV_blank>device<S2SV_blank>%s.\\n"" , ( alCaptureDevice == NULL ) ? ""failed<S2SV_blank>to<S2SV_blank>open"" : ""opened"" ) ; } } # endif si -> Shutdown = S_AL_Shutdown ; si -> StartSound = S_AL_StartSound ; si -> StartSoundEx = S_AL_StartSoundEx ; si -> StartLocalSound = S_AL_StartLocalSound ; si -> StartBackgroundTrack = S_AL_StartBackgroundTrack ; si -> StopBackgroundTrack = S_AL_StopBackgroundTrack ; si -> FadeStreamingSound = S_AL_FadeStreamingSound ; si -> FadeAllSounds = S_AL_FadeAllSounds ; si -> StartStreamingSound = S_AL_StartStreamingSound ; si -> StopEntStreamingSound = S_AL_StopEntStreamingSound ; si -> GetVoiceAmplitude = S_AL_GetVoiceAmplitude ; si -> RawSamples = S_AL_RawSamples ; si -> StopAllSounds = S_AL_StopAllSounds ; si -> ClearLoopingSounds = S_AL_ClearLoopingSounds ; si -> AddLoopingSound = S_AL_AddLoopingSound ; si -> AddRealLoopingSound = S_AL_AddRealLoopingSound ; si -> StopLoopingSound = S_AL_StopLoopingSound ; si -> Respatialize = S_AL_Respatialize ; si -> UpdateEntityPosition = S_AL_UpdateEntityPosition ; si -> Update = S_AL_Update ; si -> DisableSounds = S_AL_DisableSounds ; si -> BeginRegistration = S_AL_BeginRegistration ; si -> RegisterSound = S_AL_RegisterSound ; si -> ClearSoundBuffer = S_AL_ClearSoundBuffer ; si -> SoundInfo = S_AL_SoundInfo ; si -> SoundList = S_AL_SoundList ; # ifdef USE_VOIP si -> StartCapture = S_AL_StartCapture ; si -> AvailableCaptureSamples = S_AL_AvailableCaptureSamples ; si -> Capture = S_AL_Capture ; si -> StopCapture = S_AL_StopCapture ; si -> MasterGain = S_AL_MasterGain ; # endif return qtrue ; # else return qfalse ; # endif }","CVAR_ARCHIVE | CVAR_LATCH | CVAR_PROTECTED <S2SV_ModStart> CVAR_LATCH ) ; if ( COM_CompareExtension ( s_alDriver -> string , "".pk3"" ) ) { Com_Printf ( ""Rejecting<S2SV_blank>DLL<S2SV_blank>named<S2SV_blank>\\""%s\\"""" , s_alDriver -> string ) ; return qfalse ; }"
676,"gchar * _rsvg_io_get_file_path ( const gchar * filename , const gchar * base_uri ) { gchar * absolute_filename ; <S2SV_StartBug> if ( g_file_test ( filename , G_FILE_TEST_EXISTS ) || g_path_is_absolute ( filename ) ) { <S2SV_EndBug> absolute_filename = g_strdup ( filename ) ; } else { gchar * tmpcdir ; gchar * base_filename ; if ( base_uri ) { base_filename = g_filename_from_uri ( base_uri , NULL , NULL ) ; if ( base_filename != NULL ) { tmpcdir = g_path_get_dirname ( base_filename ) ; g_free ( base_filename ) ; } else return NULL ; } else tmpcdir = g_get_current_dir ( ) ; absolute_filename = g_build_filename ( tmpcdir , filename , NULL ) ; g_free ( tmpcdir ) ; } return absolute_filename ; }",; if ( <S2SV_ModEnd> g_path_is_absolute ( filename
677,"OM_uint32 kg_seal_iov ( OM_uint32 * minor_status , gss_ctx_id_t context_handle , int conf_req_flag , gss_qop_t qop_req , int * conf_state , gss_iov_buffer_desc * iov , int iov_count , int toktype ) { krb5_gss_ctx_id_rec * ctx ; krb5_error_code code ; krb5_context context ; if ( qop_req != 0 ) { * minor_status = ( OM_uint32 ) G_UNKNOWN_QOP ; return GSS_S_FAILURE ; } ctx = ( krb5_gss_ctx_id_rec * ) context_handle ; <S2SV_StartBug> if ( ! ctx -> established ) { <S2SV_EndBug> * minor_status = KG_CTX_INCOMPLETE ; return GSS_S_NO_CONTEXT ; } if ( conf_req_flag && kg_integ_only_iov ( iov , iov_count ) ) { conf_req_flag = FALSE ; } context = ctx -> k5_context ; switch ( ctx -> proto ) { case 0 : code = make_seal_token_v1_iov ( context , ctx , conf_req_flag , conf_state , iov , iov_count , toktype ) ; break ; case 1 : code = gss_krb5int_make_seal_token_v3_iov ( context , ctx , conf_req_flag , conf_state , iov , iov_count , toktype ) ; break ; default : code = G_UNKNOWN_QOP ; break ; } if ( code != 0 ) { * minor_status = code ; save_error_info ( * minor_status , context ) ; return GSS_S_FAILURE ; } * minor_status = 0 ; return GSS_S_COMPLETE ; }",; if ( ctx -> terminated ||
678,"static void snd_timer_check_master ( struct snd_timer_instance * master ) { struct snd_timer_instance * slave , * tmp ; list_for_each_entry_safe ( slave , tmp , & snd_timer_slave_list , open_list ) { if ( slave -> slave_class == master -> slave_class && slave -> slave_id == master -> slave_id ) { list_move_tail ( & slave -> open_list , & master -> slave_list_head ) ; spin_lock_irq ( & slave_active_lock ) ; <S2SV_StartBug> slave -> master = master ; <S2SV_EndBug> slave -> timer = master -> timer ; if ( slave -> flags & SNDRV_TIMER_IFLG_RUNNING ) list_add_tail ( & slave -> active_list , & master -> slave_active_head ) ; <S2SV_StartBug> spin_unlock_irq ( & slave_active_lock ) ; <S2SV_EndBug> } } }",slave_active_lock ) ; spin_lock ( & master -> timer -> lock ) ; <S2SV_ModStart> slave_active_head ) ; spin_unlock ( & master -> timer -> lock ) ;
679,"<S2SV_StartBug> static char * print_number ( cJSON * item ) <S2SV_EndBug> { char * str ; double f , f2 ; int64_t i ; str = ( char * ) cJSON_malloc ( 64 ) ; if ( str ) { <S2SV_StartBug> f = item -> valuefloat ; <S2SV_EndBug> i = f ; f2 = i ; <S2SV_StartBug> if ( f2 == f && item -> valueint >= LLONG_MIN && item -> valueint <= LLONG_MAX ) <S2SV_EndBug> sprintf ( str , ""%lld"" , ( long long ) item -> valueint ) ; else sprintf ( str , ""%g"" , item -> valuefloat ) ; } return str ; }","cJSON * item , printbuffer * p ) { char * str = 0 ; double d <S2SV_ModEnd> = item -> <S2SV_ModStart> = item -> valuedouble ; if ( d == 0 ) { if ( p ) str = ensure ( p , 2 ) ; else str = ( char * ) cJSON_malloc ( 2 ) ; if ( str ) strcpy ( str , ""0"" ) ; } else if ( fabs ( ( ( double ) <S2SV_ModEnd> item -> valueint <S2SV_ModStart> item -> valueint ) - d ) <= DBL_EPSILON && d <= LLONG_MAX && d >= LLONG_MIN ) { if ( p ) str = ensure ( p , 64 ) ; else str = ( char * ) cJSON_malloc ( 64 ) ; if ( str ) sprintf ( str , ""%lld"" , ( long long ) <S2SV_ModEnd> item -> valueint <S2SV_ModStart> item -> valueint ) ; } else { if ( p ) str = ensure ( p , 64 ) ; else str = ( char * ) cJSON_malloc ( 64 ) ; if ( str ) { if ( fpclassify ( d ) != FP_ZERO && ! isnormal ( d ) ) sprintf ( str , ""null"" ) ; else if ( fabs ( floor ( d ) - d ) <= DBL_EPSILON && fabs ( d ) < 1.0e60 ) sprintf ( str , ""%.0f"" , d ) ; else if ( fabs ( d ) < 1.0e-6 || fabs ( d ) > 1.0e9 ) sprintf ( str , ""%e"" , d ) ; else sprintf ( str , ""%f"" , d ) ; } <S2SV_ModEnd> } return str"
680,"static uint32_t scsi_init_iovec ( SCSIDiskReq * r ) <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> r -> iov . iov_len = MIN ( r -> sector_count * 512 , SCSI_DMA_BUF_SIZE ) ; <S2SV_EndBug> qemu_iovec_init_external ( & r -> qiov , & r -> iov , 1 ) ; return r -> qiov . size / 512 ; }","r ) { SCSIDiskState * s = DO_UPCAST ( SCSIDiskState , qdev , r -> req . dev ) ; if ( ! r -> iov . iov_base ) { r -> buflen = SCSI_DMA_BUF_SIZE ; r -> iov . iov_base = qemu_blockalign ( s -> bs , r -> buflen ) ; } <S2SV_ModStart> * 512 , r -> buflen <S2SV_ModEnd> ) ; qemu_iovec_init_external"
681,"static int get_rx_bufs ( struct vhost_virtqueue * vq , struct vring_used_elem * heads , int datalen , unsigned * iovcount , struct vhost_log * log , unsigned * log_num , unsigned int quota ) { unsigned int out , in ; int seg = 0 ; int headcount = 0 ; unsigned d ; int r , nlogs = 0 ; while ( datalen > 0 && headcount < quota ) { if ( unlikely ( seg >= UIO_MAXIOV ) ) { r = - ENOBUFS ; goto err ; } d = vhost_get_vq_desc ( vq -> dev , vq , vq -> iov + seg , ARRAY_SIZE ( vq -> iov ) - seg , & out , & in , log , log_num ) ; if ( d == vq -> num ) { r = 0 ; goto err ; } if ( unlikely ( out || in <= 0 ) ) { vq_err ( vq , ""unexpected<S2SV_blank>descriptor<S2SV_blank>format<S2SV_blank>for<S2SV_blank>RX:<S2SV_blank>"" ""out<S2SV_blank>%d,<S2SV_blank>in<S2SV_blank>%d\\n"" , out , in ) ; r = - EINVAL ; goto err ; } if ( unlikely ( log ) ) { nlogs += * log_num ; log += * log_num ; } heads [ headcount ] . id = d ; heads [ headcount ] . len = iov_length ( vq -> iov + seg , in ) ; datalen -= heads [ headcount ] . len ; ++ headcount ; seg += in ; } heads [ headcount - 1 ] . len += datalen ; * iovcount = seg ; if ( unlikely ( log ) ) * log_num = nlogs ; <S2SV_StartBug> return headcount ; <S2SV_EndBug> err : vhost_discard_vq_desc ( vq , headcount ) ; return r ; }",= nlogs ; if ( unlikely ( datalen > 0 ) ) { r = UIO_MAXIOV + 1 ; goto err ; }
682,"WORD32 ih264d_decode_gaps_in_frame_num ( dec_struct_t * ps_dec , UWORD16 u2_frame_num ) { UWORD32 u4_next_frm_num , u4_start_frm_num ; UWORD32 u4_max_frm_num ; pocstruct_t s_tmp_poc ; WORD32 i4_poc ; dec_slice_params_t * ps_cur_slice ; dec_pic_params_t * ps_pic_params ; WORD8 i1_gap_idx ; WORD32 * i4_gaps_start_frm_num ; dpb_manager_t * ps_dpb_mgr ; WORD32 i4_frame_gaps ; WORD8 * pi1_gaps_per_seq ; WORD32 ret ; ps_cur_slice = ps_dec -> ps_cur_slice ; if ( ps_cur_slice -> u1_field_pic_flag ) { if ( ps_dec -> u2_prev_ref_frame_num == u2_frame_num ) return 0 ; } u4_next_frm_num = ps_dec -> u2_prev_ref_frame_num + 1 ; u4_max_frm_num = ps_dec -> ps_cur_sps -> u2_u4_max_pic_num_minus1 + 1 ; if ( u4_next_frm_num >= u4_max_frm_num ) { u4_next_frm_num -= u4_max_frm_num ; } if ( u4_next_frm_num == u2_frame_num ) { return ( 0 ) ; } if ( ( ps_dec -> u1_nal_unit_type == IDR_SLICE_NAL ) && ( u4_next_frm_num >= u2_frame_num ) ) { return ( 0 ) ; } u4_start_frm_num = u4_next_frm_num ; s_tmp_poc . i4_pic_order_cnt_lsb = 0 ; s_tmp_poc . i4_delta_pic_order_cnt_bottom = 0 ; s_tmp_poc . i4_pic_order_cnt_lsb = 0 ; s_tmp_poc . i4_delta_pic_order_cnt_bottom = 0 ; s_tmp_poc . i4_delta_pic_order_cnt [ 0 ] = 0 ; s_tmp_poc . i4_delta_pic_order_cnt [ 1 ] = 0 ; ps_cur_slice = ps_dec -> ps_cur_slice ; ps_pic_params = ps_dec -> ps_cur_pps ; <S2SV_StartBug> ps_cur_slice -> u1_field_pic_flag = 0 ; <S2SV_EndBug> i4_frame_gaps = 0 ; ps_dpb_mgr = ps_dec -> ps_dpb_mgr ; i4_gaps_start_frm_num = ps_dpb_mgr -> ai4_gaps_start_frm_num ; for ( i1_gap_idx = 0 ; i1_gap_idx < MAX_FRAMES ; i1_gap_idx ++ ) { if ( INVALID_FRAME_NUM == i4_gaps_start_frm_num [ i1_gap_idx ] ) break ; } if ( MAX_FRAMES == i1_gap_idx ) { UWORD32 i4_error_code ; i4_error_code = ERROR_DBP_MANAGER_T ; return i4_error_code ; } i4_poc = 0 ; i4_gaps_start_frm_num [ i1_gap_idx ] = u4_start_frm_num ; ps_dpb_mgr -> ai4_gaps_end_frm_num [ i1_gap_idx ] = u2_frame_num - 1 ; pi1_gaps_per_seq = ps_dpb_mgr -> ai1_gaps_per_seq ; pi1_gaps_per_seq [ i1_gap_idx ] = 0 ; while ( u4_next_frm_num != u2_frame_num ) { ih264d_delete_nonref_nondisplay_pics ( ps_dpb_mgr ) ; if ( ps_pic_params -> ps_sps -> u1_pic_order_cnt_type ) { ret = ih264d_decode_pic_order_cnt ( 0 , u4_next_frm_num , & ps_dec -> s_prev_pic_poc , & s_tmp_poc , ps_cur_slice , ps_pic_params , 1 , 0 , 0 , & i4_poc ) ; if ( ret != OK ) return ret ; if ( i4_poc >= ps_dec -> i4_max_poc ) ps_dec -> i4_max_poc = i4_poc ; if ( i4_poc == 0 ) { ps_dec -> i4_prev_max_display_seq = ps_dec -> i4_prev_max_display_seq + ps_dec -> i4_max_poc + ps_dec -> u1_max_dec_frame_buffering + 1 ; ps_dec -> i4_max_poc = 0 ; } ps_cur_slice -> u1_mmco_equalto5 = 0 ; ps_cur_slice -> u2_frame_num = u4_next_frm_num ; } if ( ps_dpb_mgr -> i1_poc_buf_id_entries >= ps_dec -> u1_max_dec_frame_buffering ) { ret = ih264d_assign_display_seq ( ps_dec ) ; if ( ret != OK ) return ret ; } ret = ih264d_insert_pic_in_display_list ( ps_dec -> ps_dpb_mgr , ( WORD8 ) DO_NOT_DISP , ( WORD32 ) ( ps_dec -> i4_prev_max_display_seq + i4_poc ) , u4_next_frm_num ) ; if ( ret != OK ) return ret ; pi1_gaps_per_seq [ i1_gap_idx ] ++ ; ret = ih264d_do_mmco_for_gaps ( ps_dpb_mgr , ps_dec -> ps_cur_sps -> u1_num_ref_frames ) ; if ( ret != OK ) return ret ; ih264d_delete_nonref_nondisplay_pics ( ps_dpb_mgr ) ; u4_next_frm_num ++ ; if ( u4_next_frm_num >= u4_max_frm_num ) { u4_next_frm_num -= u4_max_frm_num ; } i4_frame_gaps ++ ; } return OK ; }",-> ps_cur_pps ; <S2SV_ModEnd> i4_frame_gaps = 0
683,"static int xc2028_set_config ( struct dvb_frontend * fe , void * priv_cfg ) { struct xc2028_data * priv = fe -> tuner_priv ; struct xc2028_ctrl * p = priv_cfg ; int rc = 0 ; tuner_dbg ( ""%s<S2SV_blank>called\\n"" , __func__ ) ; mutex_lock ( & priv -> lock ) ; kfree ( priv -> ctrl . fname ) ; <S2SV_StartBug> memcpy ( & priv -> ctrl , p , sizeof ( priv -> ctrl ) ) ; <S2SV_EndBug> if ( p -> fname ) { priv -> ctrl . fname = kstrdup ( p -> fname , GFP_KERNEL ) ; if ( priv -> ctrl . fname == NULL ) <S2SV_StartBug> rc = - ENOMEM ; <S2SV_EndBug> } if ( ! firmware_name [ 0 ] && p -> fname && priv -> fname && strcmp ( p -> fname , priv -> fname ) ) free_firmware ( priv ) ; if ( priv -> ctrl . max_len < 9 ) priv -> ctrl . max_len = 13 ; if ( priv -> state == XC2028_NO_FIRMWARE ) { if ( ! firmware_name [ 0 ] ) priv -> fname = priv -> ctrl . fname ; else priv -> fname = firmware_name ; rc = request_firmware_nowait ( THIS_MODULE , 1 , priv -> fname , priv -> i2c_props . adap -> dev . parent , GFP_KERNEL , fe , load_firmware_cb ) ; if ( rc < 0 ) { tuner_err ( ""Failed<S2SV_blank>to<S2SV_blank>request<S2SV_blank>firmware<S2SV_blank>%s\\n"" , priv -> fname ) ; priv -> state = XC2028_NODEV ; } else priv -> state = XC2028_WAITING_FIRMWARE ; } mutex_unlock ( & priv -> lock ) ; return rc ; }",fname ) ; priv -> ctrl . fname = NULL ; <S2SV_ModStart> == NULL ) return <S2SV_ModEnd> - ENOMEM ;
684,"static const xmlChar * xmlParseNameComplex ( xmlParserCtxtPtr ctxt ) { int len = 0 , l ; int c ; int count = 0 ; # ifdef DEBUG nbParseNameComplex ++ ; # endif GROW ; if ( ctxt -> instate == XML_PARSER_EOF ) return ( NULL ) ; c = CUR_CHAR ( l ) ; if ( ( ctxt -> options & XML_PARSE_OLD10 ) == 0 ) { if ( ( c == '<S2SV_blank>' ) || ( c == '>' ) || ( c == '/' ) || ( ! ( ( ( c >= 'a' ) && ( c <= 'z' ) ) || ( ( c >= 'A' ) && ( c <= 'Z' ) ) || ( c == '_' ) || ( c == ':' ) || ( ( c >= 0xC0 ) && ( c <= 0xD6 ) ) || ( ( c >= 0xD8 ) && ( c <= 0xF6 ) ) || ( ( c >= 0xF8 ) && ( c <= 0x2FF ) ) || ( ( c >= 0x370 ) && ( c <= 0x37D ) ) || ( ( c >= 0x37F ) && ( c <= 0x1FFF ) ) || ( ( c >= 0x200C ) && ( c <= 0x200D ) ) || ( ( c >= 0x2070 ) && ( c <= 0x218F ) ) || ( ( c >= 0x2C00 ) && ( c <= 0x2FEF ) ) || ( ( c >= 0x3001 ) && ( c <= 0xD7FF ) ) || ( ( c >= 0xF900 ) && ( c <= 0xFDCF ) ) || ( ( c >= 0xFDF0 ) && ( c <= 0xFFFD ) ) || ( ( c >= 0x10000 ) && ( c <= 0xEFFFF ) ) ) ) ) { return ( NULL ) ; } len += l ; NEXTL ( l ) ; c = CUR_CHAR ( l ) ; while ( ( c != '<S2SV_blank>' ) && ( c != '>' ) && ( c != '/' ) && ( ( ( c >= 'a' ) && ( c <= 'z' ) ) || ( ( c >= 'A' ) && ( c <= 'Z' ) ) || ( ( c >= '0' ) && ( c <= '9' ) ) || ( c == '_' ) || ( c == ':' ) || ( c == '-' ) || ( c == '.' ) || ( c == 0xB7 ) || ( ( c >= 0xC0 ) && ( c <= 0xD6 ) ) || ( ( c >= 0xD8 ) && ( c <= 0xF6 ) ) || ( ( c >= 0xF8 ) && ( c <= 0x2FF ) ) || ( ( c >= 0x300 ) && ( c <= 0x36F ) ) || ( ( c >= 0x370 ) && ( c <= 0x37D ) ) || ( ( c >= 0x37F ) && ( c <= 0x1FFF ) ) || ( ( c >= 0x200C ) && ( c <= 0x200D ) ) || ( ( c >= 0x203F ) && ( c <= 0x2040 ) ) || ( ( c >= 0x2070 ) && ( c <= 0x218F ) ) || ( ( c >= 0x2C00 ) && ( c <= 0x2FEF ) ) || ( ( c >= 0x3001 ) && ( c <= 0xD7FF ) ) || ( ( c >= 0xF900 ) && ( c <= 0xFDCF ) ) || ( ( c >= 0xFDF0 ) && ( c <= 0xFFFD ) ) || ( ( c >= 0x10000 ) && ( c <= 0xEFFFF ) ) ) ) { if ( count ++ > XML_PARSER_CHUNK_SIZE ) { count = 0 ; GROW ; if ( ctxt -> instate == XML_PARSER_EOF ) return ( NULL ) ; } len += l ; NEXTL ( l ) ; c = CUR_CHAR ( l ) ; } } else { if ( ( c == '<S2SV_blank>' ) || ( c == '>' ) || ( c == '/' ) || ( ! IS_LETTER ( c ) && ( c != '_' ) && ( c != ':' ) ) ) { return ( NULL ) ; } len += l ; NEXTL ( l ) ; c = CUR_CHAR ( l ) ; while ( ( c != '<S2SV_blank>' ) && ( c != '>' ) && ( c != '/' ) && ( ( IS_LETTER ( c ) ) || ( IS_DIGIT ( c ) ) || ( c == '.' ) || ( c == '-' ) || ( c == '_' ) || ( c == ':' ) || ( IS_COMBINING ( c ) ) || ( IS_EXTENDER ( c ) ) ) ) { if ( count ++ > XML_PARSER_CHUNK_SIZE ) { count = 0 ; GROW ; if ( ctxt -> instate == XML_PARSER_EOF ) return ( NULL ) ; } len += l ; NEXTL ( l ) ; c = CUR_CHAR ( l ) ; <S2SV_StartBug> if ( c == 0 ) { <S2SV_EndBug> count = 0 ; GROW ; if ( ctxt -> instate == XML_PARSER_EOF ) return ( NULL ) ; c = CUR_CHAR ( l ) ; } } } if ( ( len > XML_MAX_NAME_LENGTH ) && ( ( ctxt -> options & XML_PARSE_HUGE ) == 0 ) ) { <S2SV_StartBug> xmlFatalErr ( ctxt , XML_ERR_NAME_TOO_LONG , ""Name"" ) ; <S2SV_EndBug> return ( NULL ) ; } if ( ( * ctxt -> input -> cur == '\\n' ) && ( ctxt -> input -> cur [ - 1 ] == '\\r' ) ) return ( xmlDictLookup ( ctxt -> dict , ctxt -> input -> cur - ( len + 1 ) , len ) ) ; return ( xmlDictLookup ( ctxt -> dict , ctxt -> input -> cur - len , len ) ) ; }","l ) ; <S2SV_ModEnd> } } if <S2SV_ModStart> XML_ERR_NAME_TOO_LONG , ""Name"" ) ; return ( NULL ) ; } if ( ctxt -> input -> cur - ctxt -> input -> base < len ) { xmlFatalErr ( ctxt , XML_ERR_INTERNAL_ERROR , ""unexpected<S2SV_blank>change<S2SV_blank>of<S2SV_blank>input<S2SV_blank>buffer"""
685,static inline size_t GetPSDRowSize ( Image * image ) { if ( image -> depth == 1 ) <S2SV_StartBug> return ( ( image -> columns + 7 ) / 8 ) ; <S2SV_EndBug> else return ( image -> columns * GetPSDPacketSize ( image ) ) ; },return ( ( ( <S2SV_ModStart> ) / 8 ) * GetPSDPacketSize ( image )
686,"static void nhmldump_send_header ( GF_NHMLDumpCtx * ctx ) { GF_FilterPacket * dst_pck ; char nhml [ 1024 ] ; u32 size ; u8 * output ; const GF_PropertyValue * p ; ctx -> szRootName = ""NHNTStream"" ; if ( ctx -> dims ) { ctx -> szRootName = ""DIMSStream"" ; } if ( ! ctx -> filep ) { sprintf ( nhml , ""<?xml<S2SV_blank>version=\\""1.0\\""<S2SV_blank>encoding=\\""UTF-8\\""<S2SV_blank>?>\\n"" ) ; gf_bs_write_data ( ctx -> bs_w , nhml , ( u32 ) strlen ( nhml ) ) ; } sprintf ( nhml , ""<%s<S2SV_blank>version=\\""1.0\\""<S2SV_blank>"" , ctx -> szRootName ) ; gf_bs_write_data ( ctx -> bs_w , nhml , ( u32 ) strlen ( nhml ) ) ; NHML_PRINT_UINT ( GF_PROP_PID_ID , NULL , ""trackID"" ) NHML_PRINT_UINT ( GF_PROP_PID_TIMESCALE , NULL , ""timeScale"" ) p = gf_filter_pid_get_property ( ctx -> ipid , GF_PROP_PID_IN_IOD ) ; if ( p && p -> value . boolean ) { sprintf ( nhml , ""inRootOD=\\""yes\\""<S2SV_blank>"" ) ; gf_bs_write_data ( ctx -> bs_w , nhml , ( u32 ) strlen ( nhml ) ) ; } if ( ctx -> oti && ( ctx -> oti < GF_CODECID_LAST_MPEG4_MAPPING ) ) { sprintf ( nhml , ""streamType=\\""%d\\""<S2SV_blank>objectTypeIndication=\\""%d\\""<S2SV_blank>"" , ctx -> streamtype , ctx -> oti ) ; gf_bs_write_data ( ctx -> bs_w , nhml , ( u32 ) strlen ( nhml ) ) ; } else { p = gf_filter_pid_get_property ( ctx -> ipid , GF_PROP_PID_SUBTYPE ) ; if ( p ) { sprintf ( nhml , ""%s=\\""%s\\""<S2SV_blank>"" , ""mediaType"" , gf_4cc_to_str ( p -> value . uint ) ) ; gf_bs_write_data ( ctx -> bs_w , nhml , ( u32 ) strlen ( nhml ) ) ; NHML_PRINT_4CC ( GF_PROP_PID_ISOM_SUBTYPE , ""mediaSubType"" , ""mediaSubType"" ) } else { NHML_PRINT_4CC ( GF_PROP_PID_CODECID , NULL , ""codecID"" ) } } if ( ctx -> w && ctx -> h ) { switch ( ctx -> streamtype ) { case GF_STREAM_VISUAL : case GF_STREAM_SCENE : sprintf ( nhml , ""width=\\""%d\\""<S2SV_blank>height=\\""%d\\""<S2SV_blank>"" , ctx -> w , ctx -> h ) ; gf_bs_write_data ( ctx -> bs_w , nhml , ( u32 ) strlen ( nhml ) ) ; break ; default : break ; } } else if ( ctx -> sr && ctx -> chan ) { sprintf ( nhml , ""sampleRate=\\""%d\\""<S2SV_blank>numChannels=\\""%d\\""<S2SV_blank>"" , ctx -> sr , ctx -> chan ) ; gf_bs_write_data ( ctx -> bs_w , nhml , ( u32 ) strlen ( nhml ) ) ; sprintf ( nhml , ""sampleRate=\\""%d\\""<S2SV_blank>numChannels=\\""%d\\""<S2SV_blank>"" , ctx -> sr , ctx -> chan ) ; gf_bs_write_data ( ctx -> bs_w , nhml , ( u32 ) strlen ( nhml ) ) ; <S2SV_StartBug> p = gf_filter_pid_get_property ( ctx -> ipid , GF_PROP_PID_AUDIO_FORMAT ) ; <S2SV_EndBug> sprintf ( nhml , ""bitsPerSample=\\""%d\\""<S2SV_blank>"" , gf_audio_fmt_bit_depth ( p -> value . uint ) ) ; gf_bs_write_data ( ctx -> bs_w , nhml , ( u32 ) strlen ( nhml ) ) ; } NHML_PRINT_4CC ( 0 , ""codec_vendor"" , ""codecVendor"" ) NHML_PRINT_UINT ( 0 , ""codec_version"" , ""codecVersion"" ) NHML_PRINT_UINT ( 0 , ""codec_revision"" , ""codecRevision"" ) NHML_PRINT_STRING ( 0 , ""compressor_name"" , ""compressorName"" ) NHML_PRINT_UINT ( 0 , ""temporal_quality"" , ""temporalQuality"" ) NHML_PRINT_UINT ( 0 , ""spatial_quality"" , ""spatialQuality"" ) NHML_PRINT_UINT ( 0 , ""hres"" , ""horizontalResolution"" ) NHML_PRINT_UINT ( 0 , ""vres"" , ""verticalResolution"" ) NHML_PRINT_UINT ( GF_PROP_PID_BIT_DEPTH_Y , NULL , ""bitDepth"" ) NHML_PRINT_STRING ( 0 , ""meta:xmlns"" , ""xml_namespace"" ) NHML_PRINT_STRING ( 0 , ""meta:schemaloc"" , ""xml_schema_location"" ) NHML_PRINT_STRING ( 0 , ""meta:mime"" , ""mime_type"" ) NHML_PRINT_STRING ( 0 , ""meta:config"" , ""config"" ) NHML_PRINT_STRING ( 0 , ""meta:aux_mimes"" , ""aux_mime_type"" ) if ( ctx -> codecid == GF_CODECID_DIMS ) { if ( gf_filter_pid_get_property_str ( ctx -> ipid , ""meta:xmlns"" ) == NULL ) { sprintf ( nhml , ""xmlns=\\""http://www.3gpp.org/richmedia\\""<S2SV_blank>"" ) ; gf_bs_write_data ( ctx -> bs_w , nhml , ( u32 ) strlen ( nhml ) ) ; } NHML_PRINT_UINT ( 0 , ""dims:profile"" , ""profile"" ) NHML_PRINT_UINT ( 0 , ""dims:level"" , ""level"" ) NHML_PRINT_UINT ( 0 , ""dims:pathComponents"" , ""pathComponents"" ) p = gf_filter_pid_get_property_str ( ctx -> ipid , ""dims:fullRequestHost"" ) ; if ( p ) { sprintf ( nhml , ""useFullRequestHost=\\""%s\\""<S2SV_blank>"" , p -> value . boolean ? ""yes"" : ""no"" ) ; gf_bs_write_data ( ctx -> bs_w , nhml , ( u32 ) strlen ( nhml ) ) ; } p = gf_filter_pid_get_property_str ( ctx -> ipid , ""dims:streamType"" ) ; if ( p ) { sprintf ( nhml , ""stream_type=\\""%s\\""<S2SV_blank>"" , p -> value . boolean ? ""primary"" : ""secondary"" ) ; gf_bs_write_data ( ctx -> bs_w , nhml , ( u32 ) strlen ( nhml ) ) ; } p = gf_filter_pid_get_property_str ( ctx -> ipid , ""dims:redundant"" ) ; if ( p ) { sprintf ( nhml , ""contains_redundant=\\""%s\\""<S2SV_blank>"" , ( p -> value . uint == 1 ) ? ""main"" : ( ( p -> value . uint == 1 ) ? ""redundant"" : ""main+redundant"" ) ) ; gf_bs_write_data ( ctx -> bs_w , nhml , ( u32 ) strlen ( nhml ) ) ; } NHML_PRINT_UINT ( 0 , ""dims:scriptTypes"" , ""scriptTypes"" ) } if ( ctx -> opid_info ) { sprintf ( nhml , ""specificInfoFile=\\""%s\\""<S2SV_blank>"" , gf_file_basename ( ctx -> info_file ) ) ; gf_bs_write_data ( ctx -> bs_w , nhml , ( u32 ) strlen ( nhml ) ) ; dst_pck = gf_filter_pck_new_shared ( ctx -> opid_info , ctx -> dcfg , ctx -> dcfg_size , NULL ) ; gf_filter_pck_set_framing ( dst_pck , GF_TRUE , GF_TRUE ) ; gf_filter_pck_set_readonly ( dst_pck ) ; gf_filter_pck_send ( dst_pck ) ; } NHML_PRINT_STRING ( 0 , ""meta:encoding"" , ""encoding"" ) NHML_PRINT_STRING ( 0 , ""meta:contentEncoding"" , ""content_encoding"" ) ctx -> uncompress = GF_FALSE ; if ( p ) { if ( ! strcmp ( p -> value . string , ""deflate"" ) ) ctx -> uncompress = GF_TRUE ; else { GF_LOG ( GF_LOG_ERROR , GF_LOG_AUTHOR , ( ""[NHMLMx]<S2SV_blank>content_encoding<S2SV_blank>%s<S2SV_blank>not<S2SV_blank>supported\\n"" , p -> value . string ) ) ; } } if ( ctx -> opid_mdia ) { sprintf ( nhml , ""baseMediaFile=\\""%s\\""<S2SV_blank>"" , gf_file_basename ( ctx -> media_file ) ) ; gf_bs_write_data ( ctx -> bs_w , nhml , ( u32 ) strlen ( nhml ) ) ; } sprintf ( nhml , "">\\n"" ) ; gf_bs_write_data ( ctx -> bs_w , nhml , ( u32 ) strlen ( nhml ) ) ; gf_bs_get_content_no_truncate ( ctx -> bs_w , & ctx -> nhml_buffer , & size , & ctx -> nhml_buffer_size ) ; if ( ctx -> filep ) { gf_fwrite ( ctx -> nhml_buffer , size , ctx -> filep ) ; return ; } dst_pck = gf_filter_pck_new_alloc ( ctx -> opid_nhml , size , & output ) ; memcpy ( output , ctx -> nhml_buffer , size ) ; gf_filter_pck_set_framing ( dst_pck , GF_TRUE , GF_FALSE ) ; gf_filter_pck_send ( dst_pck ) ; }",GF_PROP_PID_AUDIO_FORMAT ) ; if ( p )
687,"int dwg_decode_add_object ( Dwg_Data * restrict dwg , Bit_Chain * dat , Bit_Chain * hdl_dat , long unsigned int address ) { long unsigned int objpos , restartpos ; Bit_Chain abs_dat = { NULL } ; unsigned char previous_bit ; Dwg_Object * restrict obj ; BITCODE_BL num = dwg -> num_objects ; int error = 0 ; int realloced = 0 ; abs_dat = * dat ; dat -> byte = address ; dat -> bit = 0 ; realloced = dwg_add_object ( dwg ) ; if ( realloced > 0 ) { * dat = abs_dat ; return realloced ; } obj = & dwg -> object [ num ] ; LOG_INFO ( ""==========================================\\n"" ""Object<S2SV_blank>number:<S2SV_blank>%lu/%lX"" , ( unsigned long ) num , ( unsigned long ) num ) obj -> size = bit_read_MS ( dat ) ; LOG_INFO ( "",<S2SV_blank>Size:<S2SV_blank>%d<S2SV_blank>[MS]"" , obj -> size ) SINCE ( R_2010 ) { obj -> handlestream_size = bit_read_UMC ( dat ) ; LOG_INFO ( "",<S2SV_blank>Hdlsize:<S2SV_blank>"" FORMAT_UMC ""<S2SV_blank>[UMC]<S2SV_blank>"" , obj -> handlestream_size ) ; obj -> bitsize = obj -> size * 8 - obj -> handlestream_size ; } objpos = bit_position ( dat ) ; obj -> address = dat -> byte ; bit_reset_chain ( dat ) ; if ( obj -> size > dat -> size ) { LOG_ERROR ( ""\\nInvalid<S2SV_blank>object<S2SV_blank>size.<S2SV_blank>Would<S2SV_blank>overflow"" ) ; * dat = abs_dat ; return DWG_ERR_VALUEOUTOFBOUNDS ; } dat -> size = obj -> size ; SINCE ( R_2010 ) { obj -> type = bit_read_BOT ( dat ) ; } else { obj -> type = bit_read_BS ( dat ) ; } LOG_INFO ( "",<S2SV_blank>Type:<S2SV_blank>%d<S2SV_blank>[%s]\\n"" , obj -> type , dat -> version >= R_2010 ? ""BOT"" : ""BS"" ) ; restartpos = bit_position ( dat ) ; switch ( obj -> type ) { case DWG_TYPE_TEXT : error = dwg_decode_TEXT ( dat , obj ) ; break ; case DWG_TYPE_ATTRIB : error = dwg_decode_ATTRIB ( dat , obj ) ; break ; case DWG_TYPE_ATTDEF : error = dwg_decode_ATTDEF ( dat , obj ) ; break ; case DWG_TYPE_BLOCK : error = dwg_decode_BLOCK ( dat , obj ) ; break ; case DWG_TYPE_ENDBLK : error = dwg_decode_ENDBLK ( dat , obj ) ; break ; case DWG_TYPE_SEQEND : error = dwg_decode_SEQEND ( dat , obj ) ; if ( dat -> version >= R_13 && obj -> tio . entity -> ownerhandle ) { Dwg_Object * restrict owner = dwg_resolve_handle ( dwg , obj -> tio . entity -> ownerhandle -> absolute_ref ) ; if ( ! owner ) { LOG_WARN ( ""no<S2SV_blank>SEQEND.ownerhandle"" ) } else if ( owner -> fixedtype == DWG_TYPE_INSERT || owner -> fixedtype == DWG_TYPE_MINSERT ) { hash_set ( dwg -> object_map , obj -> handle . value , ( uint32_t ) num ) ; ( void ) dwg_validate_INSERT ( owner ) ; } else if ( owner -> fixedtype == DWG_TYPE_POLYLINE_2D || owner -> fixedtype == DWG_TYPE_POLYLINE_3D || owner -> fixedtype == DWG_TYPE_POLYLINE_PFACE || owner -> fixedtype == DWG_TYPE_POLYLINE_MESH ) { Dwg_Entity_POLYLINE_2D * restrict _obj = owner -> tio . entity -> tio . POLYLINE_2D ; if ( ! _obj -> seqend ) hash_set ( dwg -> object_map , obj -> handle . value , ( uint32_t ) num ) ; ( void ) dwg_validate_POLYLINE ( owner ) ; } } break ; case DWG_TYPE_INSERT : error = dwg_decode_INSERT ( dat , obj ) ; break ; case DWG_TYPE_MINSERT : error = dwg_decode_MINSERT ( dat , obj ) ; break ; case DWG_TYPE_VERTEX_2D : error = dwg_decode_VERTEX_2D ( dat , obj ) ; break ; case DWG_TYPE_VERTEX_3D : error = dwg_decode_VERTEX_3D ( dat , obj ) ; break ; case DWG_TYPE_VERTEX_MESH : error = dwg_decode_VERTEX_MESH ( dat , obj ) ; break ; case DWG_TYPE_VERTEX_PFACE : error = dwg_decode_VERTEX_PFACE ( dat , obj ) ; break ; case DWG_TYPE_VERTEX_PFACE_FACE : error = dwg_decode_VERTEX_PFACE_FACE ( dat , obj ) ; break ; case DWG_TYPE_POLYLINE_2D : error = dwg_decode_POLYLINE_2D ( dat , obj ) ; if ( dat -> version >= R_2010 ) check_POLYLINE_handles ( obj ) ; break ; case DWG_TYPE_POLYLINE_3D : error = dwg_decode_POLYLINE_3D ( dat , obj ) ; if ( dat -> version >= R_2010 ) check_POLYLINE_handles ( obj ) ; break ; case DWG_TYPE_ARC : error = dwg_decode_ARC ( dat , obj ) ; break ; case DWG_TYPE_CIRCLE : error = dwg_decode_CIRCLE ( dat , obj ) ; break ; case DWG_TYPE_LINE : error = dwg_decode_LINE ( dat , obj ) ; break ; case DWG_TYPE_DIMENSION_ORDINATE : error = dwg_decode_DIMENSION_ORDINATE ( dat , obj ) ; break ; case DWG_TYPE_DIMENSION_LINEAR : error = dwg_decode_DIMENSION_LINEAR ( dat , obj ) ; break ; case DWG_TYPE_DIMENSION_ALIGNED : error = dwg_decode_DIMENSION_ALIGNED ( dat , obj ) ; break ; case DWG_TYPE_DIMENSION_ANG3PT : error = dwg_decode_DIMENSION_ANG3PT ( dat , obj ) ; break ; case DWG_TYPE_DIMENSION_ANG2LN : error = dwg_decode_DIMENSION_ANG2LN ( dat , obj ) ; break ; case DWG_TYPE_DIMENSION_RADIUS : error = dwg_decode_DIMENSION_RADIUS ( dat , obj ) ; break ; case DWG_TYPE_DIMENSION_DIAMETER : error = dwg_decode_DIMENSION_DIAMETER ( dat , obj ) ; break ; case DWG_TYPE_POINT : error = dwg_decode_POINT ( dat , obj ) ; break ; case DWG_TYPE__3DFACE : error = dwg_decode__3DFACE ( dat , obj ) ; break ; case DWG_TYPE_POLYLINE_PFACE : error = dwg_decode_POLYLINE_PFACE ( dat , obj ) ; if ( dat -> version >= R_2010 ) check_POLYLINE_handles ( obj ) ; break ; case DWG_TYPE_POLYLINE_MESH : error = dwg_decode_POLYLINE_MESH ( dat , obj ) ; if ( dat -> version >= R_2010 ) check_POLYLINE_handles ( obj ) ; break ; case DWG_TYPE_SOLID : error = dwg_decode_SOLID ( dat , obj ) ; break ; case DWG_TYPE_TRACE : error = dwg_decode_TRACE ( dat , obj ) ; break ; case DWG_TYPE_SHAPE : error = dwg_decode_SHAPE ( dat , obj ) ; break ; case DWG_TYPE_VIEWPORT : error = dwg_decode_VIEWPORT ( dat , obj ) ; break ; case DWG_TYPE_ELLIPSE : error = dwg_decode_ELLIPSE ( dat , obj ) ; break ; case DWG_TYPE_SPLINE : error = dwg_decode_SPLINE ( dat , obj ) ; break ; case DWG_TYPE_REGION : error = dwg_decode_REGION ( dat , obj ) ; break ; case DWG_TYPE__3DSOLID : error = dwg_decode__3DSOLID ( dat , obj ) ; break ; case DWG_TYPE_BODY : error = dwg_decode_BODY ( dat , obj ) ; break ; case DWG_TYPE_RAY : error = dwg_decode_RAY ( dat , obj ) ; break ; case DWG_TYPE_XLINE : error = dwg_decode_XLINE ( dat , obj ) ; break ; case DWG_TYPE_DICTIONARY : error = dwg_decode_DICTIONARY ( dat , obj ) ; break ; case DWG_TYPE_MTEXT : error = dwg_decode_MTEXT ( dat , obj ) ; break ; case DWG_TYPE_LEADER : error = dwg_decode_LEADER ( dat , obj ) ; break ; case DWG_TYPE_TOLERANCE : error = dwg_decode_TOLERANCE ( dat , obj ) ; break ; case DWG_TYPE_MLINE : error = dwg_decode_MLINE ( dat , obj ) ; break ; case DWG_TYPE_BLOCK_CONTROL : error = dwg_decode_BLOCK_CONTROL ( dat , obj ) ; if ( ! error && obj -> tio . object -> tio . BLOCK_CONTROL ) { obj -> tio . object -> tio . BLOCK_CONTROL -> objid = num ; if ( ! dwg -> block_control . parent ) dwg -> block_control = * obj -> tio . object -> tio . BLOCK_CONTROL ; else LOG_WARN ( ""Second<S2SV_blank>BLOCK_CONTROL<S2SV_blank>object<S2SV_blank>ignored"" ) ; } break ; case DWG_TYPE_BLOCK_HEADER : error = dwg_decode_BLOCK_HEADER ( dat , obj ) ; break ; case DWG_TYPE_LAYER_CONTROL : error = dwg_decode_LAYER_CONTROL ( dat , obj ) ; if ( ! error && obj -> tio . object -> tio . LAYER_CONTROL ) { obj -> tio . object -> tio . LAYER_CONTROL -> objid = num ; dwg -> layer_control = * obj -> tio . object -> tio . LAYER_CONTROL ; } break ; case DWG_TYPE_LAYER : error = dwg_decode_LAYER ( dat , obj ) ; break ; case DWG_TYPE_STYLE_CONTROL : error = dwg_decode_STYLE_CONTROL ( dat , obj ) ; if ( ! error && obj -> tio . object -> tio . STYLE_CONTROL ) { obj -> tio . object -> tio . STYLE_CONTROL -> objid = num ; dwg -> style_control = * obj -> tio . object -> tio . STYLE_CONTROL ; } break ; case DWG_TYPE_STYLE : error = dwg_decode_STYLE ( dat , obj ) ; break ; case DWG_TYPE_LTYPE_CONTROL : error = dwg_decode_LTYPE_CONTROL ( dat , obj ) ; if ( ! error && obj -> tio . object -> tio . LTYPE_CONTROL ) { obj -> tio . object -> tio . LTYPE_CONTROL -> objid = num ; dwg -> ltype_control = * obj -> tio . object -> tio . LTYPE_CONTROL ; } break ; case DWG_TYPE_LTYPE : error = dwg_decode_LTYPE ( dat , obj ) ; break ; case DWG_TYPE_VIEW_CONTROL : error = dwg_decode_VIEW_CONTROL ( dat , obj ) ; if ( ! error && obj -> tio . object -> tio . VIEW_CONTROL ) { obj -> tio . object -> tio . VIEW_CONTROL -> objid = num ; dwg -> view_control = * obj -> tio . object -> tio . VIEW_CONTROL ; } break ; case DWG_TYPE_VIEW : error = dwg_decode_VIEW ( dat , obj ) ; break ; case DWG_TYPE_UCS_CONTROL : error = dwg_decode_UCS_CONTROL ( dat , obj ) ; if ( ! error && obj -> tio . object -> tio . UCS_CONTROL ) { obj -> tio . object -> tio . UCS_CONTROL -> objid = num ; dwg -> ucs_control = * obj -> tio . object -> tio . UCS_CONTROL ; } break ; case DWG_TYPE_UCS : error = dwg_decode_UCS ( dat , obj ) ; break ; case DWG_TYPE_VPORT_CONTROL : error = dwg_decode_VPORT_CONTROL ( dat , obj ) ; if ( ! error && obj -> tio . object -> tio . VPORT_CONTROL ) { obj -> tio . object -> tio . VPORT_CONTROL -> objid = num ; dwg -> vport_control = * obj -> tio . object -> tio . VPORT_CONTROL ; } break ; case DWG_TYPE_VPORT : error = dwg_decode_VPORT ( dat , obj ) ; break ; case DWG_TYPE_APPID_CONTROL : error = dwg_decode_APPID_CONTROL ( dat , obj ) ; if ( ! error && obj -> tio . object -> tio . APPID_CONTROL ) { obj -> tio . object -> tio . APPID_CONTROL -> objid = num ; dwg -> appid_control = * obj -> tio . object -> tio . APPID_CONTROL ; } break ; case DWG_TYPE_APPID : error = dwg_decode_APPID ( dat , obj ) ; break ; case DWG_TYPE_DIMSTYLE_CONTROL : error = dwg_decode_DIMSTYLE_CONTROL ( dat , obj ) ; if ( ! error && obj -> tio . object -> tio . DIMSTYLE_CONTROL ) { obj -> tio . object -> tio . DIMSTYLE_CONTROL -> objid = num ; dwg -> dimstyle_control = * obj -> tio . object -> tio . DIMSTYLE_CONTROL ; } break ; case DWG_TYPE_DIMSTYLE : error = dwg_decode_DIMSTYLE ( dat , obj ) ; break ; case DWG_TYPE_VPORT_ENTITY_CONTROL : error = dwg_decode_VPORT_ENTITY_CONTROL ( dat , obj ) ; if ( ! error && obj -> tio . object -> tio . VPORT_ENTITY_CONTROL ) { obj -> tio . object -> tio . VPORT_ENTITY_CONTROL -> objid = num ; dwg -> vport_entity_control = * obj -> tio . object -> tio . VPORT_ENTITY_CONTROL ; } break ; case DWG_TYPE_VPORT_ENTITY_HEADER : error = dwg_decode_VPORT_ENTITY_HEADER ( dat , obj ) ; break ; case DWG_TYPE_GROUP : error = dwg_decode_GROUP ( dat , obj ) ; break ; case DWG_TYPE_MLINESTYLE : error = dwg_decode_MLINESTYLE ( dat , obj ) ; break ; case DWG_TYPE_OLE2FRAME : error = dwg_decode_OLE2FRAME ( dat , obj ) ; break ; case DWG_TYPE_DUMMY : error = dwg_decode_DUMMY ( dat , obj ) ; break ; case DWG_TYPE_LONG_TRANSACTION : error = dwg_decode_LONG_TRANSACTION ( dat , obj ) ; break ; case DWG_TYPE_LWPOLYLINE : error = dwg_decode_LWPOLYLINE ( dat , obj ) ; break ; case DWG_TYPE_HATCH : error = dwg_decode_HATCH ( dat , obj ) ; break ; case DWG_TYPE_XRECORD : error = dwg_decode_XRECORD ( dat , obj ) ; break ; case DWG_TYPE_PLACEHOLDER : error = dwg_decode_PLACEHOLDER ( dat , obj ) ; break ; case DWG_TYPE_OLEFRAME : error = dwg_decode_OLEFRAME ( dat , obj ) ; break ; case DWG_TYPE_VBA_PROJECT : LOG_ERROR ( ""Unhandled<S2SV_blank>Object<S2SV_blank>VBA_PROJECT.<S2SV_blank>Has<S2SV_blank>its<S2SV_blank>own<S2SV_blank>section"" ) ; error = DWG_ERR_UNHANDLEDCLASS ; break ; case DWG_TYPE_LAYOUT : error = dwg_decode_LAYOUT ( dat , obj ) ; break ; case DWG_TYPE_PROXY_ENTITY : error = dwg_decode_PROXY_ENTITY ( dat , obj ) ; break ; case DWG_TYPE_PROXY_OBJECT : error = dwg_decode_PROXY_OBJECT ( dat , obj ) ; break ; default : if ( obj -> type == dwg -> layout_type ) error = dwg_decode_LAYOUT ( dat , obj ) ; else if ( ( error = dwg_decode_variable_type ( dwg , dat , hdl_dat , obj ) ) & DWG_ERR_UNHANDLEDCLASS ) { int is_entity = 0 ; int i = obj -> type - 500 ; Dwg_Class * klass = NULL ; <S2SV_StartBug> bit_set_position ( dat , restartpos ) ; <S2SV_EndBug> if ( i >= 0 && i < ( int ) dwg -> num_classes ) { klass = & dwg -> dwg_class [ i ] ; is_entity = dwg_class_is_entity ( klass ) ; } else { if ( i < 0 ) { LOG_ERROR ( ""Invalid<S2SV_blank>class<S2SV_blank>index<S2SV_blank>%d<S2SV_blank><0"" , i ) ; } else { LOG_ERROR ( ""Invalid<S2SV_blank>class<S2SV_blank>index<S2SV_blank>%d<S2SV_blank>>%d"" , i , ( int ) dwg -> num_classes ) ; } <S2SV_StartBug> obj -> supertype = DWG_SUPERTYPE_UNKNOWN ; <S2SV_EndBug> obj -> type = 0 ; * dat = abs_dat ; return error | DWG_ERR_VALUEOUTOFBOUNDS ; } <S2SV_StartBug> if ( klass && ! is_entity ) <S2SV_EndBug> { int err = dwg_decode_UNKNOWN_OBJ ( dat , obj ) ; error |= err ; obj -> supertype = DWG_SUPERTYPE_UNKNOWN ; if ( ! dat ) return error ; <S2SV_StartBug> if ( err >= DWG_ERR_CRITICAL ) <S2SV_EndBug> * dat = abs_dat ; <S2SV_StartBug> } <S2SV_EndBug> else if ( klass ) { int err ; # if 0 && ! defined ( IS_RELEASE ) if ( strEQc ( klass -> dxfname , ""MULTILEADER"" ) ) { char * mleader = bit_read_TF ( dat , obj -> size ) ; LOG_INSANE_TF ( mleader , ( int ) obj -> size ) bit_set_position ( dat , restartpos ) ; free ( mleader ) ; } # endif err = dwg_decode_UNKNOWN_ENT ( dat , obj ) ; error |= err ; obj -> supertype = DWG_SUPERTYPE_UNKNOWN ; if ( ! dat ) return error ; if ( err >= DWG_ERR_CRITICAL ) * dat = abs_dat ; } else { LOG_WARN ( ""Unknown<S2SV_blank>object,<S2SV_blank>skipping<S2SV_blank>eed/reactors/xdic"" ) ; SINCE ( R_2000 ) { obj -> bitsize = bit_read_RL ( dat ) ; LOG_TRACE ( ""bitsize:<S2SV_blank>"" FORMAT_RL ""<S2SV_blank>[RL]<S2SV_blank>@%lu.%u\\n"" , obj -> bitsize , dat -> byte - 2 , dat -> bit ) ; if ( obj -> bitsize > obj -> size * 8 ) { LOG_ERROR ( ""Invalid<S2SV_blank>bitsize<S2SV_blank>"" FORMAT_RL ""<S2SV_blank>=><S2SV_blank>"" FORMAT_RL , obj -> bitsize , obj -> size * 8 ) ; obj -> bitsize = obj -> size * 8 ; error |= DWG_ERR_VALUEOUTOFBOUNDS ; } } if ( ! bit_read_H ( dat , & obj -> handle ) ) { LOG_TRACE ( ""handle:<S2SV_blank>"" FORMAT_H ""<S2SV_blank>[H<S2SV_blank>5]\\n"" , ARGS_H ( obj -> handle ) ) ; } restartpos = dat -> byte ; obj -> supertype = DWG_SUPERTYPE_UNKNOWN ; obj -> tio . unknown = bit_read_TF ( dat , obj -> size ) ; dat -> byte = restartpos ; } } } if ( obj -> handle . value ) { LOG_HANDLE ( ""<S2SV_blank>object_map{%lX}<S2SV_blank>=<S2SV_blank>%lu\\n"" , obj -> handle . value , ( unsigned long ) num ) ; hash_set ( dwg -> object_map , obj -> handle . value , ( uint32_t ) num ) ; } if ( dat -> byte > 8 * dat -> size ) { LOG_ERROR ( ""Invalid<S2SV_blank>object<S2SV_blank>address<S2SV_blank>(overflow):<S2SV_blank>%lu<S2SV_blank>><S2SV_blank>%lu"" , dat -> byte , 8 * dat -> size ) ; * dat = abs_dat ; return error | DWG_ERR_INVALIDDWG ; } restartpos = bit_position ( dat ) ; * dat = abs_dat ; bit_set_position ( dat , objpos + restartpos ) ; if ( dat -> bit ) { unsigned char r = 8 - dat -> bit ; LOG_HANDLE ( ""<S2SV_blank>padding:<S2SV_blank>%X/%X<S2SV_blank>(%d<S2SV_blank>bits)\\n"" , dat -> chain [ dat -> byte ] , dat -> chain [ dat -> byte ] & ( ( 1 << r ) - 1 ) , r ) ; bit_advance_position ( dat , r ) ; } bit_set_position ( dat , ( obj -> address + obj -> size ) * 8 - 2 ) ; if ( ! bit_check_CRC ( dat , address , 0xC0C1 ) ) error |= DWG_ERR_WRONGCRC ; * dat = abs_dat ; return realloced ? - 1 : error ; }",", restartpos ) ; obj -> supertype = DWG_SUPERTYPE_UNKNOWN <S2SV_ModStart> } obj -> <S2SV_ModEnd> type = 0 <S2SV_ModStart> } if ( is_entity ) error |= dwg_decode_UNKNOWN_ENT ( dat , obj ) ; else error |= dwg_decode_UNKNOWN_OBJ ( dat , obj ) ; if ( ! <S2SV_ModEnd> dat ) return <S2SV_ModStart> ; if ( error <S2SV_ModEnd> >= DWG_ERR_CRITICAL ) <S2SV_ModStart> = abs_dat ; <S2SV_ModEnd> } } if"
688,"static inline unsigned short ReadPropertyUnsignedShort ( const EndianType endian , const unsigned char * buffer ) { unsigned short value ; if ( endian == LSBEndian ) { <S2SV_StartBug> value = ( unsigned short ) ( ( buffer [ 1 ] << 8 ) | buffer [ 0 ] ) ; <S2SV_EndBug> <S2SV_StartBug> return ( ( unsigned short ) ( value & 0xffff ) ) ; <S2SV_EndBug> } <S2SV_StartBug> value = ( unsigned short ) ( ( ( ( unsigned char * ) buffer ) [ 0 ] << 8 ) | <S2SV_EndBug> ( ( unsigned char * ) buffer ) [ 1 ] ) ; <S2SV_StartBug> return ( ( unsigned short ) ( value & 0xffff ) ) ; <S2SV_EndBug> }",unsigned short ) <S2SV_ModEnd> buffer [ 1 <S2SV_ModStart> ] << 8 ; value |= ( unsigned short ) <S2SV_ModEnd> buffer [ 0 <S2SV_ModStart> [ 0 ] <S2SV_ModEnd> ; return ( <S2SV_ModStart> ; return ( <S2SV_ModEnd> value & 0xffff <S2SV_ModStart> value & 0xffff <S2SV_ModEnd> ) ; } <S2SV_ModStart> unsigned short ) buffer <S2SV_ModEnd> [ 0 ] <S2SV_ModStart> ] << 8 ; value |= <S2SV_ModEnd> ( unsigned short <S2SV_ModStart> unsigned short ) buffer [ 1 ] ; return <S2SV_ModStart> & 0xffff ) <S2SV_ModEnd> ; } <S2SV_null>
689,"int main ( int argc , char * argv [ ] ) { <S2SV_StartBug> libettercap_init ( ) ; <S2SV_EndBug> ef_globals_alloc ( ) ; select_text_interface ( ) ; libettercap_ui_init ( ) ; fprintf ( stdout , ""\\n"" EC_COLOR_BOLD ""%s<S2SV_blank>%s"" EC_COLOR_END ""<S2SV_blank>copyright<S2SV_blank>%s<S2SV_blank>%s\\n\\n"" , PROGRAM , EC_VERSION , EC_COPYRIGHT , EC_AUTHORS ) ; EF_GBL -> lineno = 1 ; parse_options ( argc , argv ) ; if ( EF_GBL_OPTIONS -> source_file ) { yyin = fopen ( EF_GBL_OPTIONS -> source_file , ""r"" ) ; if ( yyin == NULL ) FATAL_ERROR ( ""Input<S2SV_blank>file<S2SV_blank>not<S2SV_blank>found<S2SV_blank>!"" ) ; } else { FATAL_ERROR ( ""No<S2SV_blank>source<S2SV_blank>file."" ) ; } setbuf ( yyin , NULL ) ; setbuf ( stdout , NULL ) ; setbuf ( stderr , NULL ) ; load_tables ( ) ; load_constants ( ) ; fprintf ( stdout , ""\\n<S2SV_blank>Parsing<S2SV_blank>source<S2SV_blank>file<S2SV_blank>\\\'%s\\\'<S2SV_blank>"" , EF_GBL_OPTIONS -> source_file ) ; fflush ( stdout ) ; ef_debug ( 1 , ""\\n"" ) ; if ( yyparse ( ) == 0 ) fprintf ( stdout , ""<S2SV_blank>done.\\n\\n"" ) ; else fprintf ( stdout , ""\\n\\nThe<S2SV_blank>script<S2SV_blank>contains<S2SV_blank>errors...\\n\\n"" ) ; <S2SV_StartBug> if ( write_output ( ) != E_SUCCESS ) <S2SV_EndBug> FATAL_ERROR ( ""Cannot<S2SV_blank>write<S2SV_blank>output<S2SV_blank>file<S2SV_blank>(%s)"" , EF_GBL_OPTIONS -> output_file ) ; ef_globals_free ( ) ; return 0 ; }","] ) { int ret_value = 0 ; <S2SV_ModStart> ""\\n\\nThe<S2SV_blank>script<S2SV_blank>contains<S2SV_blank>errors...\\n\\n"" ) ; ret_value = <S2SV_ModEnd> write_output ( ) <S2SV_ModStart> write_output ( ) ; if ( ret_value == - E_NOTHANDLED ) FATAL_ERROR ( ""Cannot<S2SV_blank>write<S2SV_blank>output<S2SV_blank>file<S2SV_blank>(%s):<S2SV_blank>the<S2SV_blank>filter<S2SV_blank>is<S2SV_blank>not<S2SV_blank>correctly<S2SV_blank>handled."" , EF_GBL_OPTIONS -> output_file ) ; else if ( ret_value == - E_INVALID ) FATAL_ERROR ( ""Cannot<S2SV_blank>write<S2SV_blank>output<S2SV_blank>file<S2SV_blank>(%s):<S2SV_blank>the<S2SV_blank>filter<S2SV_blank>format<S2SV_blank>is<S2SV_blank>not<S2SV_blank>correct.<S2SV_blank>"" <S2SV_ModEnd> , EF_GBL_OPTIONS ->"
690,"void uverbs_user_mmap_disassociate ( struct ib_uverbs_file * ufile ) { struct rdma_umap_priv * priv , * next_priv ; lockdep_assert_held ( & ufile -> hw_destroy_rwsem ) ; while ( 1 ) { struct mm_struct * mm = NULL ; mutex_lock ( & ufile -> umap_lock ) ; while ( ! list_empty ( & ufile -> umaps ) ) { int ret ; priv = list_first_entry ( & ufile -> umaps , struct rdma_umap_priv , list ) ; mm = priv -> vma -> vm_mm ; ret = mmget_not_zero ( mm ) ; if ( ! ret ) { list_del_init ( & priv -> list ) ; mm = NULL ; continue ; } break ; } mutex_unlock ( & ufile -> umap_lock ) ; if ( ! mm ) return ; <S2SV_StartBug> down_write ( & mm -> mmap_sem ) ; <S2SV_EndBug> mutex_lock ( & ufile -> umap_lock ) ; list_for_each_entry_safe ( priv , next_priv , & ufile -> umaps , list ) { struct vm_area_struct * vma = priv -> vma ; if ( vma -> vm_mm != mm ) continue ; list_del_init ( & priv -> list ) ; zap_vma_ptes ( vma , vma -> vm_start , vma -> vm_end - vma -> vm_start ) ; vma -> vm_flags &= ~ ( VM_SHARED | VM_MAYSHARE ) ; } mutex_unlock ( & ufile -> umap_lock ) ; <S2SV_StartBug> up_write ( & mm -> mmap_sem ) ; <S2SV_EndBug> mmput ( mm ) ; } }",-> mmap_sem ) ; if ( ! mmget_still_valid ( mm ) ) goto skip_mm <S2SV_ModStart> umap_lock ) ; skip_mm :
691,"static void hugetlb_vm_op_close ( struct vm_area_struct * vma ) { struct hstate * h = hstate_vma ( vma ) ; struct resv_map * reservations = vma_resv_map ( vma ) ; struct hugepage_subpool * spool = subpool_vma ( vma ) ; unsigned long reserve ; unsigned long start ; unsigned long end ; if ( reservations ) { start = vma_hugecache_offset ( h , vma , vma -> vm_start ) ; end = vma_hugecache_offset ( h , vma , vma -> vm_end ) ; reserve = ( end - start ) - region_count ( & reservations -> regions , start , end ) ; <S2SV_StartBug> kref_put ( & reservations -> refs , resv_map_release ) ; <S2SV_EndBug> if ( reserve ) { hugetlb_acct_memory ( h , - reserve ) ; hugepage_subpool_put_pages ( spool , reserve ) ; } } }",end ) ; resv_map_put ( vma <S2SV_ModEnd> ) ; if
692,"int dccp_v4_connect ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { const struct sockaddr_in * usin = ( struct sockaddr_in * ) uaddr ; struct inet_sock * inet = inet_sk ( sk ) ; struct dccp_sock * dp = dccp_sk ( sk ) ; __be16 orig_sport , orig_dport ; __be32 daddr , nexthop ; struct flowi4 fl4 ; struct rtable * rt ; <S2SV_StartBug> int err ; <S2SV_EndBug> dp -> dccps_role = DCCP_ROLE_CLIENT ; if ( addr_len < sizeof ( struct sockaddr_in ) ) return - EINVAL ; if ( usin -> sin_family != AF_INET ) return - EAFNOSUPPORT ; nexthop = daddr = usin -> sin_addr . s_addr ; <S2SV_StartBug> if ( inet -> opt != NULL && inet -> opt -> srr ) { <S2SV_EndBug> if ( daddr == 0 ) return - EINVAL ; <S2SV_StartBug> nexthop = inet -> opt -> faddr ; <S2SV_EndBug> } orig_sport = inet -> inet_sport ; orig_dport = usin -> sin_port ; rt = ip_route_connect ( & fl4 , nexthop , inet -> inet_saddr , RT_CONN_FLAGS ( sk ) , sk -> sk_bound_dev_if , IPPROTO_DCCP , orig_sport , orig_dport , sk , true ) ; if ( IS_ERR ( rt ) ) return PTR_ERR ( rt ) ; if ( rt -> rt_flags & ( RTCF_MULTICAST | RTCF_BROADCAST ) ) { ip_rt_put ( rt ) ; return - ENETUNREACH ; } <S2SV_StartBug> if ( inet -> opt == NULL || ! inet -> opt -> srr ) <S2SV_EndBug> daddr = rt -> rt_dst ; if ( inet -> inet_saddr == 0 ) inet -> inet_saddr = rt -> rt_src ; inet -> inet_rcv_saddr = inet -> inet_saddr ; inet -> inet_dport = usin -> sin_port ; inet -> inet_daddr = daddr ; inet_csk ( sk ) -> icsk_ext_hdr_len = 0 ; <S2SV_StartBug> if ( inet -> opt != NULL ) <S2SV_EndBug> inet_csk ( sk ) -> icsk_ext_hdr_len = inet -> opt -> optlen ; dccp_set_state ( sk , DCCP_REQUESTING ) ; err = inet_hash_connect ( & dccp_death_row , sk ) ; if ( err != 0 ) goto failure ; rt = ip_route_newports ( & fl4 , rt , orig_sport , orig_dport , inet -> inet_sport , inet -> inet_dport , sk ) ; if ( IS_ERR ( rt ) ) { rt = NULL ; goto failure ; } sk_setup_caps ( sk , & rt -> dst ) ; dp -> dccps_iss = secure_dccp_sequence_number ( inet -> inet_saddr , inet -> inet_daddr , inet -> inet_sport , inet -> inet_dport ) ; inet -> inet_id = dp -> dccps_iss ^ jiffies ; err = dccp_connect ( sk ) ; rt = NULL ; if ( err != 0 ) goto failure ; out : return err ; failure : dccp_set_state ( sk , DCCP_CLOSED ) ; ip_rt_put ( rt ) ; sk -> sk_route_caps = 0 ; inet -> inet_dport = 0 ; goto out ; }","; int err ; struct ip_options_rcu * inet_opt <S2SV_ModStart> . s_addr ; inet_opt = rcu_dereference_protected ( inet -> inet_opt , sock_owned_by_user ( sk ) ) ; if ( inet_opt <S2SV_ModEnd> != NULL && <S2SV_ModStart> != NULL && inet_opt -> opt . <S2SV_ModEnd> srr ) { <S2SV_ModStart> ; nexthop = inet_opt -> opt . <S2SV_ModEnd> faddr ; } <S2SV_ModStart> } if ( inet_opt <S2SV_ModEnd> == NULL || <S2SV_ModStart> NULL || ! inet_opt -> opt . <S2SV_ModEnd> srr ) daddr <S2SV_ModStart> ; if ( inet_opt ) inet_csk ( sk ) -> icsk_ext_hdr_len = inet_opt -> opt . <S2SV_ModEnd> optlen ; dccp_set_state"
693,"IMPEG2D_ERROR_CODES_T impeg2d_dec_pic_hdr ( dec_state_t * ps_dec ) { stream_t * ps_stream ; ps_stream = & ps_dec -> s_bit_stream ; impeg2d_bit_stream_flush ( ps_stream , START_CODE_LEN ) ; impeg2d_bit_stream_get ( ps_stream , 10 ) ; ps_dec -> e_pic_type = ( e_pic_type_t ) impeg2d_bit_stream_get ( ps_stream , 3 ) ; if ( ( ps_dec -> e_pic_type < I_PIC ) || ( ps_dec -> e_pic_type > D_PIC ) ) { impeg2d_next_code ( ps_dec , PICTURE_START_CODE ) ; return IMPEG2D_INVALID_PIC_TYPE ; } impeg2d_bit_stream_get ( ps_stream , 16 ) ; if ( ps_dec -> e_pic_type == P_PIC || ps_dec -> e_pic_type == B_PIC ) { ps_dec -> u2_full_pel_forw_vector = impeg2d_bit_stream_get_bit ( ps_stream ) ; ps_dec -> u2_forw_f_code = impeg2d_bit_stream_get ( ps_stream , 3 ) ; } if ( ps_dec -> e_pic_type == B_PIC ) { ps_dec -> u2_full_pel_back_vector = impeg2d_bit_stream_get_bit ( ps_stream ) ; ps_dec -> u2_back_f_code = impeg2d_bit_stream_get ( ps_stream , 3 ) ; } if ( ps_dec -> u2_is_mpeg2 == 0 ) { <S2SV_StartBug> ps_dec -> au2_f_code [ 0 ] [ 0 ] = ps_dec -> au2_f_code [ 0 ] [ 1 ] = ps_dec -> u2_forw_f_code ; <S2SV_EndBug> ps_dec -> au2_f_code [ 1 ] [ 0 ] = ps_dec -> au2_f_code [ 1 ] [ 1 ] = ps_dec -> u2_back_f_code ; } while ( impeg2d_bit_stream_nxt ( ps_stream , 1 ) == 1 && ps_stream -> u4_offset < ps_stream -> u4_max_offset ) { impeg2d_bit_stream_get ( ps_stream , 9 ) ; } impeg2d_bit_stream_get_bit ( ps_stream ) ; impeg2d_next_start_code ( ps_dec ) ; return ( IMPEG2D_ERROR_CODES_T ) IVD_ERROR_NONE ; }",0 ) { if ( ps_dec -> u2_forw_f_code < 1 || ps_dec -> u2_forw_f_code > 7 || ps_dec -> u2_back_f_code < 1 || ps_dec -> u2_back_f_code > 7 ) { return IMPEG2D_UNKNOWN_ERROR ; }
694,"int sas_discover_sata ( struct domain_device * dev ) { int res ; if ( dev -> dev_type == SAS_SATA_PM ) return - ENODEV ; dev -> sata_dev . class = sas_get_ata_command_set ( dev ) ; sas_fill_in_rphy ( dev , dev -> rphy ) ; res = sas_notify_lldd_dev_found ( dev ) ; if ( res ) return res ; <S2SV_StartBug> sas_discover_event ( dev -> port , DISCE_PROBE ) ; <S2SV_EndBug> return 0 ; }",return res ; <S2SV_ModEnd> return 0 ;
695,"static Image * ReadDDSImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image ; MagickBooleanType status , cubemap = MagickFalse , volume = MagickFalse , matte ; CompressionType compression ; DDSInfo dds_info ; DDSDecoder * decoder ; size_t n , num_images ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } <S2SV_StartBug> if ( ReadDDSInfo ( image , & dds_info ) != MagickTrue ) { <S2SV_EndBug> ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; <S2SV_StartBug> } <S2SV_EndBug> if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP ) cubemap = MagickTrue ; if ( dds_info . ddscaps2 & DDSCAPS2_VOLUME && dds_info . depth > 0 ) volume = MagickTrue ; ( void ) SeekBlob ( image , 128 , SEEK_SET ) ; if ( dds_info . pixelformat . flags & DDPF_RGB ) { compression = NoCompression ; if ( dds_info . pixelformat . flags & DDPF_ALPHAPIXELS ) { matte = MagickTrue ; decoder = ReadUncompressedRGBA ; } else { matte = MagickTrue ; decoder = ReadUncompressedRGB ; } } else if ( dds_info . pixelformat . flags & DDPF_LUMINANCE ) { compression = NoCompression ; if ( dds_info . pixelformat . flags & DDPF_ALPHAPIXELS ) { ThrowReaderException ( CorruptImageError , ""ImageTypeNotSupported"" ) ; } else { matte = MagickFalse ; decoder = ReadUncompressedRGB ; } } else if ( dds_info . pixelformat . flags & DDPF_FOURCC ) { switch ( dds_info . pixelformat . fourcc ) { case FOURCC_DXT1 : { matte = MagickFalse ; compression = DXT1Compression ; decoder = ReadDXT1 ; break ; } case FOURCC_DXT3 : { matte = MagickTrue ; compression = DXT3Compression ; decoder = ReadDXT3 ; break ; } case FOURCC_DXT5 : { matte = MagickTrue ; compression = DXT5Compression ; decoder = ReadDXT5 ; break ; } default : { ThrowReaderException ( CorruptImageError , ""ImageTypeNotSupported"" ) ; } } } else { ThrowReaderException ( CorruptImageError , ""ImageTypeNotSupported"" ) ; } num_images = 1 ; if ( cubemap ) { num_images = 0 ; if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP_POSITIVEX ) num_images ++ ; if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP_NEGATIVEX ) num_images ++ ; if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP_POSITIVEY ) num_images ++ ; if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP_NEGATIVEY ) num_images ++ ; if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP_POSITIVEZ ) num_images ++ ; if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP_NEGATIVEZ ) num_images ++ ; } if ( volume ) num_images = dds_info . depth ; <S2SV_StartBug> for ( n = 0 ; n < num_images ; n ++ ) <S2SV_EndBug> { if ( n != 0 ) { if ( EOFBlob ( image ) != MagickFalse ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; AcquireNextImage ( image_info , image ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) return ( DestroyImageList ( image ) ) ; image = SyncNextImageInList ( image ) ; } image -> matte = matte ; image -> compression = compression ; image -> columns = dds_info . width ; image -> rows = dds_info . height ; image -> storage_class = DirectClass ; image -> endian = LSBEndian ; image -> depth = 8 ; if ( image_info -> ping != MagickFalse ) { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } if ( ( decoder ) ( image , & dds_info , exception ) != MagickTrue ) { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } } ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }","!= MagickTrue ) <S2SV_ModEnd> ThrowReaderException ( CorruptImageError <S2SV_ModStart> ""ImproperImageHeader"" ) ; <S2SV_ModEnd> if ( dds_info <S2SV_ModStart> . depth ; if ( num_images < 1 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ;"
696,"int ping_recvmsg ( struct kiocb * iocb , struct sock * sk , struct msghdr * msg , size_t len , int noblock , int flags , int * addr_len ) { struct inet_sock * isk = inet_sk ( sk ) ; int family = sk -> sk_family ; struct sk_buff * skb ; int copied , err ; pr_debug ( ""ping_recvmsg(sk=%p,sk->num=%u)\\n"" , isk , isk -> inet_num ) ; err = - EOPNOTSUPP ; if ( flags & MSG_OOB ) goto out ; if ( flags & MSG_ERRQUEUE ) { if ( family == AF_INET ) { return ip_recv_error ( sk , msg , len ) ; # if IS_ENABLED ( CONFIG_IPV6 ) } else if ( family == AF_INET6 ) { return pingv6_ops . ipv6_recv_error ( sk , msg , len ) ; # endif } } skb = skb_recv_datagram ( sk , flags , noblock , & err ) ; if ( ! skb ) goto out ; copied = skb -> len ; if ( copied > len ) { msg -> msg_flags |= MSG_TRUNC ; copied = len ; } err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; if ( err ) goto done ; sock_recv_timestamp ( msg , sk , skb ) ; if ( family == AF_INET ) { struct sockaddr_in * sin = ( struct sockaddr_in * ) msg -> msg_name ; <S2SV_StartBug> sin -> sin_family = AF_INET ; <S2SV_EndBug> sin -> sin_port = 0 ; sin -> sin_addr . s_addr = ip_hdr ( skb ) -> saddr ; memset ( sin -> sin_zero , 0 , sizeof ( sin -> sin_zero ) ) ; * addr_len = sizeof ( * sin ) ; <S2SV_StartBug> if ( isk -> cmsg_flags ) <S2SV_EndBug> ip_cmsg_recv ( msg , skb ) ; # if IS_ENABLED ( CONFIG_IPV6 ) } else if ( family == AF_INET6 ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct ipv6hdr * ip6 = ipv6_hdr ( skb ) ; struct sockaddr_in6 * sin6 = ( struct sockaddr_in6 * ) msg -> msg_name ; <S2SV_StartBug> sin6 -> sin6_family = AF_INET6 ; <S2SV_EndBug> sin6 -> sin6_port = 0 ; sin6 -> sin6_addr = ip6 -> saddr ; sin6 -> sin6_flowinfo = 0 ; if ( np -> sndflow ) sin6 -> sin6_flowinfo = ip6_flowinfo ( ip6 ) ; sin6 -> sin6_scope_id = ipv6_iface_scope_id ( & sin6 -> sin6_addr , IP6CB ( skb ) -> iif ) ; <S2SV_StartBug> * addr_len = sizeof ( * sin6 ) ; <S2SV_EndBug> if ( inet6_sk ( sk ) -> rxopt . all ) pingv6_ops . ip6_datagram_recv_ctl ( sk , msg , skb ) ; # endif } else { BUG ( ) ; } err = copied ; done : skb_free_datagram ( sk , skb ) ; out : pr_debug ( ""ping_recvmsg<S2SV_blank>-><S2SV_blank>%d\\n"" , err ) ; return err ; }",-> msg_name ; if ( sin ) { <S2SV_ModStart> sin ) ; } <S2SV_ModStart> -> msg_name ; if ( sin6 ) { <S2SV_ModStart> sin6 ) ; }
697,"int vcc_getsockopt ( struct socket * sock , int level , int optname , char __user * optval , int __user * optlen ) { struct atm_vcc * vcc ; int len ; if ( get_user ( len , optlen ) ) return - EFAULT ; if ( __SO_LEVEL_MATCH ( optname , level ) && len != __SO_SIZE ( optname ) ) return - EINVAL ; vcc = ATM_SD ( sock ) ; switch ( optname ) { case SO_ATMQOS : if ( ! test_bit ( ATM_VF_HASQOS , & vcc -> flags ) ) return - EINVAL ; return copy_to_user ( optval , & vcc -> qos , sizeof ( vcc -> qos ) ) ? - EFAULT : 0 ; case SO_SETCLP : return put_user ( vcc -> atm_options & ATM_ATMOPT_CLP ? 1 : 0 , ( unsigned long __user * ) optval ) ? - EFAULT : 0 ; case SO_ATMPVC : { struct sockaddr_atmpvc pvc ; if ( ! vcc -> dev || ! test_bit ( ATM_VF_ADDR , & vcc -> flags ) ) return - ENOTCONN ; <S2SV_StartBug> pvc . sap_family = AF_ATMPVC ; <S2SV_EndBug> pvc . sap_addr . itf = vcc -> dev -> number ; pvc . sap_addr . vpi = vcc -> vpi ; pvc . sap_addr . vci = vcc -> vci ; return copy_to_user ( optval , & pvc , sizeof ( pvc ) ) ? - EFAULT : 0 ; } default : if ( level == SOL_SOCKET ) return - EINVAL ; break ; } if ( ! vcc -> dev || ! vcc -> dev -> ops -> getsockopt ) return - EINVAL ; return vcc -> dev -> ops -> getsockopt ( vcc , level , optname , optval , len ) ; }","- ENOTCONN ; memset ( & pvc , 0 , sizeof ( pvc ) ) ;"
698,"int jas_stream_read ( jas_stream_t * stream , void * buf , int cnt ) { int n ; int c ; <S2SV_StartBug> char * bufptr ; <S2SV_EndBug> bufptr = buf ; n = 0 ; while ( n < cnt ) { if ( ( c = jas_stream_getc ( stream ) ) == EOF ) { return n ; } * bufptr ++ = c ; ++ n ; } return n ; }","* bufptr ; if ( cnt < 0 ) { jas_deprecated ( ""negative<S2SV_blank>count<S2SV_blank>for<S2SV_blank>jas_stream_read"" ) ; }"
699,"static krb5_error_code build_principal_va ( krb5_context context , krb5_principal princ , unsigned int rlen , const char * realm , va_list ap ) { krb5_error_code retval = 0 ; char * r = NULL ; krb5_data * data = NULL ; krb5_int32 count = 0 ; krb5_int32 size = 2 ; char * component = NULL ; data = malloc ( size * sizeof ( krb5_data ) ) ; if ( ! data ) { retval = ENOMEM ; } <S2SV_StartBug> if ( ! retval ) { <S2SV_EndBug> r = strdup ( realm ) ; if ( ! r ) { retval = ENOMEM ; } } while ( ! retval && ( component = va_arg ( ap , char * ) ) ) { if ( count == size ) { krb5_data * new_data = NULL ; size *= 2 ; new_data = realloc ( data , size * sizeof ( krb5_data ) ) ; if ( new_data ) { data = new_data ; } else { retval = ENOMEM ; } } if ( ! retval ) { data [ count ] . length = strlen ( component ) ; data [ count ] . data = strdup ( component ) ; if ( ! data [ count ] . data ) { retval = ENOMEM ; } count ++ ; } } if ( ! retval ) { princ -> type = KRB5_NT_UNKNOWN ; princ -> magic = KV5M_PRINCIPAL ; princ -> realm = make_data ( r , rlen ) ; princ -> data = data ; princ -> length = count ; r = NULL ; data = NULL ; } if ( data ) { while ( -- count >= 0 ) { free ( data [ count ] . data ) ; } free ( data ) ; } free ( r ) ; return retval ; }","! retval ) r = k5memdup0 ( realm , rlen , & retval ) ; <S2SV_ModEnd> while ( !"
700,"static void smp_task_timedout ( struct timer_list * t ) { struct sas_task_slow * slow = from_timer ( slow , t , timer ) ; struct sas_task * task = slow -> task ; unsigned long flags ; spin_lock_irqsave ( & task -> task_state_lock , flags ) ; <S2SV_StartBug> if ( ! ( task -> task_state_flags & SAS_TASK_STATE_DONE ) ) <S2SV_EndBug> <S2SV_StartBug> task -> task_state_flags |= SAS_TASK_STATE_ABORTED ; <S2SV_EndBug> spin_unlock_irqrestore ( & task -> task_state_lock , flags ) ; complete ( & task -> slow_task -> completion ) ; <S2SV_StartBug> } <S2SV_EndBug>","SAS_TASK_STATE_DONE ) ) { <S2SV_ModStart> task_state_flags |= SAS_TASK_STATE_ABORTED <S2SV_ModEnd> ; complete ( <S2SV_ModStart> ) ; } spin_unlock_irqrestore ( & task -> task_state_lock , flags ) ; }"
701,"ssize_t cdf_read_short_sector ( const cdf_stream_t * sst , void * buf , size_t offs , size_t len , const cdf_header_t * h , cdf_secid_t id ) { <S2SV_StartBug> assert ( ( size_t ) CDF_SHORT_SEC_SIZE ( h ) == len ) ; <S2SV_EndBug> ( void ) memcpy ( ( ( char * ) buf ) + offs , <S2SV_StartBug> ( ( const char * ) sst -> sst_tab ) + CDF_SHORT_SEC_POS ( h , id ) , len ) ; <S2SV_EndBug> return len ; }","id ) { size_t ss = <S2SV_ModEnd> CDF_SHORT_SEC_SIZE ( h <S2SV_ModStart> ( h ) ; size_t pos = CDF_SHORT_SEC_POS ( h , id ) ; assert ( ss <S2SV_ModStart> len ) ; if ( sst -> sst_len < ( size_t ) id ) { DPRINTF ( ( ""bad<S2SV_blank>sector<S2SV_blank>id<S2SV_blank>%d<S2SV_blank>><S2SV_blank>%d\\n"" , id , sst -> sst_len ) ) ; return - 1 ; } <S2SV_ModStart> sst_tab ) + pos <S2SV_ModEnd> , len )"
702,"static void <S2SV_StartBug> l2tp_proxy_auth_type_print ( netdissect_options * ndo , const u_char * dat ) <S2SV_EndBug> { <S2SV_StartBug> const uint16_t * ptr = ( const uint16_t * ) dat ; <S2SV_EndBug> ND_PRINT ( ( ndo , ""%s"" , tok2str ( l2tp_authentype2str , ""AuthType-#%u"" , EXTRACT_16BITS ( ptr ) ) ) ) ; }","u_char * dat , u_int length <S2SV_ModStart> ) dat ; if ( length < 2 ) { ND_PRINT ( ( ndo , ""AVP<S2SV_blank>too<S2SV_blank>short"" ) ) ; return ; }"
703,"static int _hostsock_getsockopt ( oe_fd_t * sock_ , int level , int optname , void * optval , oe_socklen_t * optlen ) { int ret = - 1 ; sock_t * sock = _cast_sock ( sock_ ) ; oe_socklen_t optlen_in = 0 ; <S2SV_StartBug> oe_errno = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( ! sock ) <S2SV_EndBug> OE_RAISE_ERRNO ( OE_EINVAL ) ; <S2SV_StartBug> if ( optlen ) <S2SV_EndBug> optlen_in = * optlen ; if ( oe_syscall_getsockopt_ocall ( <S2SV_StartBug> & ret , sock -> host_fd , level , optname , optval , optlen_in , optlen ) != <S2SV_EndBug> OE_OK ) { OE_RAISE_ERRNO ( OE_EINVAL ) ; } <S2SV_StartBug> done : <S2SV_EndBug> return ret ; }","= 0 ; oe_socklen_t optlen_out = 0 ; <S2SV_ModStart> ( ! sock || ! optval || ! optlen <S2SV_ModStart> OE_EINVAL ) ; <S2SV_ModEnd> optlen_in = * <S2SV_ModStart> , optlen_in , & optlen_out <S2SV_ModEnd> ) != OE_OK <S2SV_ModStart> ) ; } if ( optlen_out > optlen_in ) optlen_out = optlen_in ; * optlen = optlen_out ;"
704,"static int skcipher_setkey ( void * private , const u8 * key , unsigned int keylen ) { <S2SV_StartBug> return crypto_skcipher_setkey ( private , key , keylen ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>","keylen ) { struct skcipher_tfm * tfm = private ; int err ; err = crypto_skcipher_setkey ( tfm -> skcipher <S2SV_ModEnd> , key , <S2SV_ModStart> keylen ) ; tfm -> has_key = ! err ; return err ;"
705,"void beep_print ( netdissect_options * ndo , const u_char * bp , u_int length ) { <S2SV_StartBug> if ( l_strnstart ( ""MSG"" , 4 , ( const char * ) bp , length ) ) <S2SV_EndBug> ND_PRINT ( ( ndo , ""<S2SV_blank>BEEP<S2SV_blank>MSG"" ) ) ; <S2SV_StartBug> else if ( l_strnstart ( ""RPY<S2SV_blank>"" , 4 , ( const char * ) bp , length ) ) <S2SV_EndBug> ND_PRINT ( ( ndo , ""<S2SV_blank>BEEP<S2SV_blank>RPY"" ) ) ; <S2SV_StartBug> else if ( l_strnstart ( ""ERR<S2SV_blank>"" , 4 , ( const char * ) bp , length ) ) <S2SV_EndBug> ND_PRINT ( ( ndo , ""<S2SV_blank>BEEP<S2SV_blank>ERR"" ) ) ; <S2SV_StartBug> else if ( l_strnstart ( ""ANS<S2SV_blank>"" , 4 , ( const char * ) bp , length ) ) <S2SV_EndBug> ND_PRINT ( ( ndo , ""<S2SV_blank>BEEP<S2SV_blank>ANS"" ) ) ; <S2SV_StartBug> else if ( l_strnstart ( ""NUL<S2SV_blank>"" , 4 , ( const char * ) bp , length ) ) <S2SV_EndBug> ND_PRINT ( ( ndo , ""<S2SV_blank>BEEP<S2SV_blank>NUL"" ) ) ; <S2SV_StartBug> else if ( l_strnstart ( ""SEQ<S2SV_blank>"" , 4 , ( const char * ) bp , length ) ) <S2SV_EndBug> ND_PRINT ( ( ndo , ""<S2SV_blank>BEEP<S2SV_blank>SEQ"" ) ) ; <S2SV_StartBug> else if ( l_strnstart ( ""END"" , 4 , ( const char * ) bp , length ) ) <S2SV_EndBug> ND_PRINT ( ( ndo , ""<S2SV_blank>BEEP<S2SV_blank>END"" ) ) ; else ND_PRINT ( ( ndo , ""<S2SV_blank>BEEP<S2SV_blank>(payload<S2SV_blank>or<S2SV_blank>undecoded)"" ) ) ; }","( l_strnstart ( ndo , <S2SV_ModStart> ( l_strnstart ( ndo , <S2SV_ModStart> ( l_strnstart ( ndo , <S2SV_ModStart> ( l_strnstart ( ndo , <S2SV_ModStart> ( l_strnstart ( ndo , <S2SV_ModStart> ( l_strnstart ( ndo , <S2SV_ModStart> ( l_strnstart ( ndo ,"
706,"static plist_t parse_bin_node ( struct bplist_data * bplist , const char * * object ) { uint16_t type = 0 ; uint64_t size = 0 ; if ( ! object ) return NULL ; type = ( * * object ) & BPLIST_MASK ; size = ( * * object ) & BPLIST_FILL ; ( * object ) ++ ; if ( size == BPLIST_FILL ) { switch ( type ) { case BPLIST_DATA : case BPLIST_STRING : case BPLIST_UNICODE : case BPLIST_ARRAY : case BPLIST_SET : case BPLIST_DICT : { uint16_t next_size = * * object & BPLIST_FILL ; if ( ( * * object & BPLIST_MASK ) != BPLIST_UINT ) { PLIST_BIN_ERR ( ""%s:<S2SV_blank>invalid<S2SV_blank>size<S2SV_blank>node<S2SV_blank>type<S2SV_blank>for<S2SV_blank>node<S2SV_blank>type<S2SV_blank>0x%02x:<S2SV_blank>found<S2SV_blank>0x%02x,<S2SV_blank>expected<S2SV_blank>0x%02x\\n"" , __func__ , type , * * object & BPLIST_MASK , BPLIST_UINT ) ; return NULL ; } ( * object ) ++ ; next_size = 1 << next_size ; if ( * object + next_size > bplist -> offset_table ) { PLIST_BIN_ERR ( ""%s:<S2SV_blank>size<S2SV_blank>node<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>for<S2SV_blank>node<S2SV_blank>type<S2SV_blank>0x%02x<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\n"" , __func__ , type ) ; return NULL ; } size = UINT_TO_HOST ( * object , next_size ) ; ( * object ) += next_size ; break ; } default : break ; } } switch ( type ) { case BPLIST_NULL : switch ( size ) { case BPLIST_TRUE : { plist_data_t data = plist_new_plist_data ( ) ; data -> type = PLIST_BOOLEAN ; data -> boolval = TRUE ; data -> length = 1 ; return node_create ( NULL , data ) ; } case BPLIST_FALSE : { plist_data_t data = plist_new_plist_data ( ) ; data -> type = PLIST_BOOLEAN ; data -> boolval = FALSE ; data -> length = 1 ; return node_create ( NULL , data ) ; } case BPLIST_NULL : default : return NULL ; } case BPLIST_UINT : if ( * object + ( uint64_t ) ( 1 << size ) > bplist -> offset_table ) { PLIST_BIN_ERR ( ""%s:<S2SV_blank>BPLIST_UINT<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\n"" , __func__ ) ; return NULL ; } return parse_uint_node ( object , size ) ; case BPLIST_REAL : if ( * object + ( uint64_t ) ( 1 << size ) > bplist -> offset_table ) { PLIST_BIN_ERR ( ""%s:<S2SV_blank>BPLIST_REAL<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\n"" , __func__ ) ; return NULL ; } return parse_real_node ( object , size ) ; case BPLIST_DATE : if ( 3 != size ) { PLIST_BIN_ERR ( ""%s:<S2SV_blank>invalid<S2SV_blank>data<S2SV_blank>size<S2SV_blank>for<S2SV_blank>BPLIST_DATE<S2SV_blank>node\\n"" , __func__ ) ; return NULL ; } if ( * object + ( uint64_t ) ( 1 << size ) > bplist -> offset_table ) { PLIST_BIN_ERR ( ""%s:<S2SV_blank>BPLIST_DATE<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\n"" , __func__ ) ; return NULL ; } return parse_date_node ( object , size ) ; case BPLIST_DATA : <S2SV_StartBug> if ( * object + size > bplist -> offset_table ) { <S2SV_EndBug> PLIST_BIN_ERR ( ""%s:<S2SV_blank>BPLIST_DATA<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\n"" , __func__ ) ; return NULL ; } return parse_data_node ( object , size ) ; case BPLIST_STRING : <S2SV_StartBug> if ( * object + size > bplist -> offset_table ) { <S2SV_EndBug> PLIST_BIN_ERR ( ""%s:<S2SV_blank>BPLIST_STRING<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\n"" , __func__ ) ; return NULL ; } return parse_string_node ( object , size ) ; case BPLIST_UNICODE : if ( size * 2 < size ) { PLIST_BIN_ERR ( ""%s:<S2SV_blank>Integer<S2SV_blank>overflow<S2SV_blank>when<S2SV_blank>calculating<S2SV_blank>BPLIST_UNICODE<S2SV_blank>data<S2SV_blank>size.\\n"" , __func__ ) ; return NULL ; } <S2SV_StartBug> if ( * object + size * 2 > bplist -> offset_table ) { <S2SV_EndBug> PLIST_BIN_ERR ( ""%s:<S2SV_blank>BPLIST_UNICODE<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\n"" , __func__ ) ; return NULL ; } return parse_unicode_node ( object , size ) ; case BPLIST_SET : case BPLIST_ARRAY : <S2SV_StartBug> if ( * object + size > bplist -> offset_table ) { <S2SV_EndBug> PLIST_BIN_ERR ( ""%s:<S2SV_blank>BPLIST_ARRAY<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\n"" , __func__ ) ; return NULL ; } return parse_array_node ( bplist , object , size ) ; case BPLIST_UID : if ( * object + size + 1 > bplist -> offset_table ) { PLIST_BIN_ERR ( ""%s:<S2SV_blank>BPLIST_UID<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\n"" , __func__ ) ; return NULL ; } return parse_uid_node ( object , size ) ; case BPLIST_DICT : <S2SV_StartBug> if ( * object + size > bplist -> offset_table ) { <S2SV_EndBug> PLIST_BIN_ERR ( ""%s:<S2SV_blank>BPLIST_REAL<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\n"" , __func__ ) ; return NULL ; } return parse_dict_node ( bplist , object , size ) ; default : PLIST_BIN_ERR ( ""%s:<S2SV_blank>unexpected<S2SV_blank>node<S2SV_blank>type<S2SV_blank>0x%02x\\n"" , __func__ , type ) ; return NULL ; } return NULL ; }","object + size < * object || * object + size <S2SV_ModStart> : if ( * object + size < * object || <S2SV_ModStart> size * 2 < * object || * object + size * 2 <S2SV_ModStart> object + size < * object || * object + size <S2SV_ModStart> object + size < * object || * object + size > bplist -> offset_table ) { PLIST_BIN_ERR ( ""%s:<S2SV_blank>BPLIST_DICT<S2SV_blank>data<S2SV_blank>bytes<S2SV_blank>point<S2SV_blank>outside<S2SV_blank>of<S2SV_blank>valid<S2SV_blank>range\\n"" <S2SV_ModEnd> , __func__ )"
707,"__be32 nfsd4_set_nfs4_acl ( struct svc_rqst * rqstp , struct svc_fh * fhp , struct nfs4_acl * acl ) { __be32 error ; int host_error ; struct dentry * dentry ; struct inode * inode ; struct posix_acl * pacl = NULL , * dpacl = NULL ; unsigned int flags = 0 ; error = fh_verify ( rqstp , fhp , 0 , NFSD_MAY_SATTR ) ; if ( error ) return error ; dentry = fhp -> fh_dentry ; inode = d_inode ( dentry ) ; <S2SV_StartBug> if ( ! inode -> i_op -> set_acl || ! IS_POSIXACL ( inode ) ) <S2SV_EndBug> return nfserr_attrnotsupp ; if ( S_ISDIR ( inode -> i_mode ) ) flags = NFS4_ACL_DIR ; host_error = nfs4_acl_nfsv4_to_posix ( acl , & pacl , & dpacl , flags ) ; if ( host_error == - EINVAL ) return nfserr_attrnotsupp ; if ( host_error < 0 ) goto out_nfserr ; <S2SV_StartBug> host_error = inode -> i_op -> set_acl ( inode , pacl , ACL_TYPE_ACCESS ) ; <S2SV_EndBug> if ( host_error < 0 ) <S2SV_StartBug> goto out_release ; <S2SV_EndBug> if ( S_ISDIR ( inode -> i_mode ) ) { <S2SV_StartBug> host_error = inode -> i_op -> set_acl ( inode , dpacl , <S2SV_EndBug> ACL_TYPE_DEFAULT ) ; } <S2SV_StartBug> out_release : <S2SV_EndBug> posix_acl_release ( pacl ) ; posix_acl_release ( dpacl ) ; out_nfserr : if ( host_error == - EOPNOTSUPP ) return nfserr_attrnotsupp ; else return nfserrno ( host_error ) ; }","; if ( <S2SV_ModEnd> S_ISDIR ( inode <S2SV_ModStart> goto out_nfserr ; fh_lock ( fhp ) ; host_error = set_posix_acl ( inode , ACL_TYPE_ACCESS , pacl <S2SV_ModEnd> ) ; if <S2SV_ModStart> 0 ) goto out_drop_lock <S2SV_ModEnd> ; if ( <S2SV_ModStart> { host_error = set_posix_acl ( inode , ACL_TYPE_DEFAULT , dpacl <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } out_drop_lock : fh_unlock ( fhp ) ; <S2SV_ModEnd> posix_acl_release ( pacl"
708,"SQLRETURN SQLSetDescFieldW ( SQLHDESC descriptor_handle , SQLSMALLINT rec_number , SQLSMALLINT field_identifier , SQLPOINTER value , SQLINTEGER buffer_length ) { DMHDESC descriptor = ( DMHDESC ) descriptor_handle ; SQLRETURN ret ; SQLCHAR s1 [ 100 + LOG_MESSAGE_LEN ] ; int isStrField = 0 ; if ( ! __validate_desc ( descriptor ) ) { dm_log_write ( __FILE__ , __LINE__ , LOG_INFO , LOG_INFO , ""Error:<S2SV_blank>SQL_INVALID_HANDLE"" ) ; # ifdef WITH_HANDLE_REDIRECT { DMHDESC parent_desc ; parent_desc = find_parent_handle ( descriptor , SQL_HANDLE_DESC ) ; if ( parent_desc ) { dm_log_write ( __FILE__ , __LINE__ , LOG_INFO , LOG_INFO , ""Info:<S2SV_blank>found<S2SV_blank>parent<S2SV_blank>handle"" ) ; if ( CHECK_SQLSETDESCFIELDW ( parent_desc -> connection ) ) { dm_log_write ( __FILE__ , __LINE__ , LOG_INFO , LOG_INFO , ""Info:<S2SV_blank>calling<S2SV_blank>redirected<S2SV_blank>driver<S2SV_blank>function"" ) ; return SQLSETDESCFIELDW ( parent_desc -> connection , descriptor , rec_number , field_identifier , value , buffer_length ) ; } } } # endif return SQL_INVALID_HANDLE ; } function_entry ( descriptor ) ; if ( log_info . log_flag ) { <S2SV_StartBug> sprintf ( descriptor -> msg , ""\\n\\t\\tEntry:\\\n<S2SV_blank>\\n\\t\\t\\tDescriptor<S2SV_blank>=<S2SV_blank>%p\\\n<S2SV_blank>\\n\\t\\t\\tRec<S2SV_blank>Number<S2SV_blank>=<S2SV_blank>%d\\\n<S2SV_blank>\\n\\t\\t\\tField<S2SV_blank>Ident<S2SV_blank>=<S2SV_blank>%s\\\n<S2SV_blank>\\n\\t\\t\\tValue<S2SV_blank>=<S2SV_blank>%p\\\n<S2SV_blank>\\n\\t\\t\\tBuffer<S2SV_blank>Length<S2SV_blank>=<S2SV_blank>%d"" , <S2SV_EndBug> descriptor , rec_number , __desc_attr_as_string ( s1 , field_identifier ) , value , ( int ) buffer_length ) ; dm_log_write ( __FILE__ , __LINE__ , LOG_INFO , LOG_INFO , descriptor -> msg ) ; } thread_protect ( SQL_HANDLE_DESC , descriptor ) ; if ( descriptor -> connection -> state < STATE_C4 ) { dm_log_write ( __FILE__ , __LINE__ , LOG_INFO , LOG_INFO , ""Error:<S2SV_blank>HY010"" ) ; __post_internal_error ( & descriptor -> error , ERROR_HY010 , NULL , descriptor -> connection -> environment -> requested_version ) ; return function_return_nodrv ( SQL_HANDLE_DESC , descriptor , SQL_ERROR ) ; } if ( __check_stmt_from_desc ( descriptor , STATE_S8 ) || __check_stmt_from_desc ( descriptor , STATE_S9 ) || __check_stmt_from_desc ( descriptor , STATE_S10 ) || __check_stmt_from_desc ( descriptor , STATE_S11 ) || __check_stmt_from_desc ( descriptor , STATE_S12 ) || __check_stmt_from_desc ( descriptor , STATE_S13 ) || __check_stmt_from_desc ( descriptor , STATE_S14 ) || __check_stmt_from_desc ( descriptor , STATE_S15 ) ) { dm_log_write ( __FILE__ , __LINE__ , LOG_INFO , LOG_INFO , ""Error:<S2SV_blank>HY010"" ) ; __post_internal_error ( & descriptor -> error , ERROR_HY010 , NULL , descriptor -> connection -> environment -> requested_version ) ; return function_return_nodrv ( SQL_HANDLE_DESC , descriptor , SQL_ERROR ) ; } if ( rec_number < 0 ) { __post_internal_error ( & descriptor -> error , ERROR_07009 , NULL , descriptor -> connection -> environment -> requested_version ) ; return function_return_nodrv ( SQL_HANDLE_DESC , descriptor , SQL_ERROR ) ; } switch ( field_identifier ) { case SQL_DESC_ALLOC_TYPE : case SQL_DESC_ARRAY_SIZE : case SQL_DESC_ARRAY_STATUS_PTR : case SQL_DESC_BIND_OFFSET_PTR : case SQL_DESC_BIND_TYPE : case SQL_DESC_COUNT : case SQL_DESC_ROWS_PROCESSED_PTR : case SQL_DESC_AUTO_UNIQUE_VALUE : case SQL_DESC_CASE_SENSITIVE : case SQL_DESC_CONCISE_TYPE : case SQL_DESC_DATA_PTR : case SQL_DESC_DATETIME_INTERVAL_CODE : case SQL_DESC_DATETIME_INTERVAL_PRECISION : case SQL_DESC_DISPLAY_SIZE : case SQL_DESC_FIXED_PREC_SCALE : case SQL_DESC_INDICATOR_PTR : case SQL_DESC_LENGTH : case SQL_DESC_NULLABLE : case SQL_DESC_NUM_PREC_RADIX : case SQL_DESC_OCTET_LENGTH : case SQL_DESC_OCTET_LENGTH_PTR : case SQL_DESC_PARAMETER_TYPE : case SQL_DESC_PRECISION : case SQL_DESC_ROWVER : case SQL_DESC_SCALE : case SQL_DESC_SEARCHABLE : case SQL_DESC_TYPE : case SQL_DESC_UNNAMED : case SQL_DESC_UNSIGNED : case SQL_DESC_UPDATABLE : isStrField = 0 ; break ; case SQL_DESC_BASE_COLUMN_NAME : case SQL_DESC_BASE_TABLE_NAME : case SQL_DESC_CATALOG_NAME : case SQL_DESC_LABEL : case SQL_DESC_LITERAL_PREFIX : case SQL_DESC_LITERAL_SUFFIX : case SQL_DESC_LOCAL_TYPE_NAME : case SQL_DESC_NAME : case SQL_DESC_SCHEMA_NAME : case SQL_DESC_TABLE_NAME : case SQL_DESC_TYPE_NAME : isStrField = 1 ; break ; default : isStrField = buffer_length != SQL_IS_POINTER && buffer_length != SQL_IS_INTEGER && buffer_length != SQL_IS_UINTEGER && buffer_length != SQL_IS_SMALLINT && buffer_length != SQL_IS_USMALLINT ; } if ( isStrField && buffer_length < 0 && buffer_length != SQL_NTS ) { __post_internal_error ( & descriptor -> error , ERROR_HY090 , NULL , descriptor -> connection -> environment -> requested_version ) ; return function_return_nodrv ( SQL_HANDLE_DESC , descriptor , SQL_ERROR ) ; } <S2SV_StartBug> if ( field_identifier == SQL_DESC_COUNT && ( SQLINTEGER ) value < 0 ) <S2SV_EndBug> { __post_internal_error ( & descriptor -> error , ERROR_07009 , NULL , descriptor -> connection -> environment -> requested_version ) ; return function_return_nodrv ( SQL_HANDLE_DESC , descriptor , SQL_ERROR ) ; } <S2SV_StartBug> if ( field_identifier == SQL_DESC_PARAMETER_TYPE && value != SQL_PARAM_INPUT <S2SV_EndBug> <S2SV_StartBug> && value != SQL_PARAM_OUTPUT && value != SQL_PARAM_INPUT_OUTPUT && <S2SV_EndBug> <S2SV_StartBug> value != SQL_PARAM_INPUT_OUTPUT_STREAM && value != SQL_PARAM_OUTPUT_STREAM ) <S2SV_EndBug> { __post_internal_error ( & descriptor -> error , ERROR_HY105 , NULL , descriptor -> connection -> environment -> requested_version ) ; return function_return_nodrv ( SQL_HANDLE_DESC , descriptor , SQL_ERROR ) ; } if ( descriptor -> connection -> unicode_driver || CHECK_SQLSETDESCFIELDW ( descriptor -> connection ) ) { if ( ! CHECK_SQLSETDESCFIELDW ( descriptor -> connection ) ) { dm_log_write ( __FILE__ , __LINE__ , LOG_INFO , LOG_INFO , ""Error:<S2SV_blank>IM001"" ) ; __post_internal_error ( & descriptor -> error , ERROR_IM001 , NULL , descriptor -> connection -> environment -> requested_version ) ; return function_return_nodrv ( SQL_HANDLE_DESC , descriptor , SQL_ERROR ) ; } ret = SQLSETDESCFIELDW ( descriptor -> connection , descriptor -> driver_desc , rec_number , field_identifier , value , buffer_length ) ; if ( log_info . log_flag ) { sprintf ( descriptor -> msg , ""\\n\\t\\tExit:[%s]"" , __get_return_status ( ret , s1 ) ) ; dm_log_write ( __FILE__ , __LINE__ , LOG_INFO , LOG_INFO , descriptor -> msg ) ; } } else { SQLCHAR * ascii_str = NULL ; if ( ! CHECK_SQLSETDESCFIELD ( descriptor -> connection ) ) { dm_log_write ( __FILE__ , __LINE__ , LOG_INFO , LOG_INFO , ""Error:<S2SV_blank>IM001"" ) ; __post_internal_error ( & descriptor -> error , ERROR_IM001 , NULL , descriptor -> connection -> environment -> requested_version ) ; return function_return_nodrv ( SQL_HANDLE_DESC , descriptor , SQL_ERROR ) ; } switch ( field_identifier ) { case SQL_DESC_NAME : ascii_str = ( SQLCHAR * ) unicode_to_ansi_alloc ( value , buffer_length , descriptor -> connection , NULL ) ; value = ascii_str ; buffer_length = strlen ( ( char * ) ascii_str ) ; break ; default : break ; } ret = SQLSETDESCFIELD ( descriptor -> connection , descriptor -> driver_desc , rec_number , field_identifier , value , buffer_length ) ; if ( log_info . log_flag ) { sprintf ( descriptor -> msg , ""\\n\\t\\tExit:[%s]"" , __get_return_status ( ret , s1 ) ) ; dm_log_write ( __FILE__ , __LINE__ , LOG_INFO , LOG_INFO , descriptor -> msg ) ; } if ( ascii_str ) { free ( ascii_str ) ; } } return function_return ( SQL_HANDLE_DESC , descriptor , ret ) ; }","-> msg , ""\\n\\t\\tEntry:\\\n\\n\\t\\t\\tDescriptor<S2SV_blank>=<S2SV_blank>%p\\\n\\n\\t\\t\\tRec<S2SV_blank>Number<S2SV_blank>=<S2SV_blank>%d\\\n\\n\\t\\t\\tField<S2SV_blank>Ident<S2SV_blank>=<S2SV_blank>%s\\\n\\n\\t\\t\\tValue<S2SV_blank>=<S2SV_blank>%p\\\n\\n\\t\\t\\tBuffer<S2SV_blank>Length<S2SV_blank>=<S2SV_blank>%d"" <S2SV_ModEnd> , descriptor , <S2SV_ModStart> SQL_DESC_COUNT && ( intptr_t <S2SV_ModEnd> ) value < <S2SV_ModStart> == SQL_DESC_PARAMETER_TYPE && ( intptr_t ) <S2SV_ModStart> != SQL_PARAM_INPUT && ( intptr_t ) <S2SV_ModStart> != SQL_PARAM_OUTPUT && ( intptr_t ) <S2SV_ModStart> != SQL_PARAM_INPUT_OUTPUT && ( intptr_t ) <S2SV_ModStart> != SQL_PARAM_INPUT_OUTPUT_STREAM && ( intptr_t )"
709,"void enc624j600WritePhyReg ( NetInterface * interface , uint8_t address , uint16_t data ) { <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_MIREGADR , MIREGADR_R8 | address ) ; <S2SV_EndBug> <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_MIWR , data ) ; <S2SV_EndBug> <S2SV_StartBug> while ( ( enc624j600ReadReg ( interface , ENC624J600_REG_MISTAT ) & MISTAT_BUSY ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> } }","data ) { uint16_t status ; <S2SV_ModStart> ( interface , ENC624J600_MIREGADR , ENC624J600_MIREGADR_R12_8_DEFAULT <S2SV_ModEnd> | address ) <S2SV_ModStart> ( interface , ENC624J600_MIWR <S2SV_ModEnd> , data ) <S2SV_ModStart> data ) ; do { status = <S2SV_ModEnd> enc624j600ReadReg ( interface <S2SV_ModStart> ( interface , ENC624J600_MISTAT ) ; } while ( ( status & ENC624J600_MISTAT_BUSY <S2SV_ModEnd> ) != 0 <S2SV_ModStart> != 0 ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>"
710,"SECURITY_STATUS ntlm_read_AuthenticateMessage ( NTLM_CONTEXT * context , PSecBuffer buffer ) { <S2SV_StartBug> wStream * s ; <S2SV_EndBug> size_t length ; <S2SV_StartBug> UINT32 flags ; <S2SV_EndBug> <S2SV_StartBug> NTLM_AV_PAIR * AvFlags ; <S2SV_EndBug> UINT32 PayloadBufferOffset ; NTLM_AUTHENTICATE_MESSAGE * message ; SSPI_CREDENTIALS * credentials = context -> credentials ; <S2SV_StartBug> flags = 0 ; <S2SV_EndBug> AvFlags = NULL ; message = & context -> AUTHENTICATE_MESSAGE ; ZeroMemory ( message , sizeof ( NTLM_AUTHENTICATE_MESSAGE ) ) ; s = Stream_New ( ( BYTE * ) buffer -> pvBuffer , buffer -> cbBuffer ) ; if ( ! s ) return SEC_E_INTERNAL_ERROR ; if ( ntlm_read_message_header ( s , ( NTLM_MESSAGE_HEADER * ) message ) < 0 ) <S2SV_StartBug> { <S2SV_EndBug> Stream_Free ( s , FALSE ) ; return SEC_E_INVALID_TOKEN ; } if ( message -> MessageType != MESSAGE_TYPE_AUTHENTICATE ) <S2SV_StartBug> { <S2SV_EndBug> Stream_Free ( s , FALSE ) ; return SEC_E_INVALID_TOKEN ; } if ( ntlm_read_message_fields ( s , & ( message -> LmChallengeResponse ) ) < 0 ) <S2SV_StartBug> { <S2SV_EndBug> Stream_Free ( s , FALSE ) ; return SEC_E_INVALID_TOKEN ; } if ( ntlm_read_message_fields ( s , & ( message -> NtChallengeResponse ) ) < 0 ) <S2SV_StartBug> { <S2SV_EndBug> Stream_Free ( s , FALSE ) ; return SEC_E_INVALID_TOKEN ; } if ( ntlm_read_message_fields ( s , & ( message -> DomainName ) ) < 0 ) <S2SV_StartBug> { <S2SV_EndBug> Stream_Free ( s , FALSE ) ; return SEC_E_INVALID_TOKEN ; } if ( ntlm_read_message_fields ( s , & ( message -> UserName ) ) < 0 ) <S2SV_StartBug> { <S2SV_EndBug> Stream_Free ( s , FALSE ) ; return SEC_E_INVALID_TOKEN ; } if ( ntlm_read_message_fields ( s , & ( message -> Workstation ) ) < 0 ) <S2SV_StartBug> { <S2SV_EndBug> Stream_Free ( s , FALSE ) ; return SEC_E_INVALID_TOKEN ; } if ( ntlm_read_message_fields ( s , & ( message -> EncryptedRandomSessionKey ) ) < 0 ) <S2SV_StartBug> { <S2SV_EndBug> Stream_Free ( s , FALSE ) ; return SEC_E_INVALID_TOKEN ; } Stream_Read_UINT32 ( s , message -> NegotiateFlags ) ; context -> NegotiateKeyExchange = ( message -> NegotiateFlags & NTLMSSP_NEGOTIATE_KEY_EXCH ) ? TRUE : FALSE ; if ( ( context -> NegotiateKeyExchange && ! message -> EncryptedRandomSessionKey . Len ) || ( ! context -> NegotiateKeyExchange && message -> EncryptedRandomSessionKey . Len ) ) <S2SV_StartBug> { <S2SV_EndBug> Stream_Free ( s , FALSE ) ; return SEC_E_INVALID_TOKEN ; } if ( message -> NegotiateFlags & NTLMSSP_NEGOTIATE_VERSION ) { if ( ntlm_read_version_info ( s , & ( message -> Version ) ) < 0 ) { Stream_Free ( s , FALSE ) ; return SEC_E_INVALID_TOKEN ; } } PayloadBufferOffset = Stream_GetPosition ( s ) ; if ( ntlm_read_message_fields_buffer ( s , & ( message -> DomainName ) ) < 0 ) { Stream_Free ( s , FALSE ) ; return SEC_E_INTERNAL_ERROR ; } if ( ntlm_read_message_fields_buffer ( s , & ( message -> UserName ) ) < 0 ) { Stream_Free ( s , FALSE ) ; return SEC_E_INTERNAL_ERROR ; } if ( ntlm_read_message_fields_buffer ( s , & ( message -> Workstation ) ) < 0 ) { Stream_Free ( s , FALSE ) ; return SEC_E_INTERNAL_ERROR ; } if ( ntlm_read_message_fields_buffer ( s , & ( message -> LmChallengeResponse ) ) < 0 ) { Stream_Free ( s , FALSE ) ; return SEC_E_INTERNAL_ERROR ; } if ( ntlm_read_message_fields_buffer ( s , & ( message -> NtChallengeResponse ) ) < 0 ) { Stream_Free ( s , FALSE ) ; return SEC_E_INTERNAL_ERROR ; } if ( message -> NtChallengeResponse . Len > 0 ) { size_t cbAvFlags ; wStream * snt = Stream_New ( message -> NtChallengeResponse . Buffer , message -> NtChallengeResponse . Len ) ; if ( ! snt ) <S2SV_StartBug> { <S2SV_EndBug> Stream_Free ( s , FALSE ) ; <S2SV_StartBug> return SEC_E_INTERNAL_ERROR ; <S2SV_EndBug> } if ( ntlm_read_ntlm_v2_response ( snt , & ( context -> NTLMv2Response ) ) < 0 ) { Stream_Free ( s , FALSE ) ; Stream_Free ( snt , FALSE ) ; return SEC_E_INVALID_TOKEN ; } Stream_Free ( snt , FALSE ) ; context -> NtChallengeResponse . pvBuffer = message -> NtChallengeResponse . Buffer ; context -> NtChallengeResponse . cbBuffer = message -> NtChallengeResponse . Len ; sspi_SecBufferFree ( & ( context -> ChallengeTargetInfo ) ) ; context -> ChallengeTargetInfo . pvBuffer = ( void * ) context -> NTLMv2Response . Challenge . AvPairs ; context -> ChallengeTargetInfo . cbBuffer = message -> NtChallengeResponse . Len - ( 28 + 16 ) ; CopyMemory ( context -> ClientChallenge , context -> NTLMv2Response . Challenge . ClientChallenge , 8 ) ; AvFlags = ntlm_av_pair_get ( context -> NTLMv2Response . Challenge . AvPairs , context -> NTLMv2Response . Challenge . cbAvPairs , MsvAvFlags , & cbAvFlags ) ; if ( AvFlags ) Data_Read_UINT32 ( ntlm_av_pair_get_value_pointer ( AvFlags ) , flags ) ; } if ( ntlm_read_message_fields_buffer ( s , & ( message -> EncryptedRandomSessionKey ) ) < 0 ) <S2SV_StartBug> { <S2SV_EndBug> Stream_Free ( s , FALSE ) ; return SEC_E_INTERNAL_ERROR ; } if ( message -> EncryptedRandomSessionKey . Len > 0 ) { if ( message -> EncryptedRandomSessionKey . Len != 16 ) <S2SV_StartBug> { <S2SV_EndBug> Stream_Free ( s , FALSE ) ; return SEC_E_INVALID_TOKEN ; } CopyMemory ( context -> EncryptedRandomSessionKey , message -> EncryptedRandomSessionKey . Buffer , 16 ) ; } length = Stream_GetPosition ( s ) ; if ( ! sspi_SecBufferAlloc ( & context -> AuthenticateMessage , length ) ) <S2SV_StartBug> { <S2SV_EndBug> Stream_Free ( s , FALSE ) ; return SEC_E_INTERNAL_ERROR ; } CopyMemory ( context -> AuthenticateMessage . pvBuffer , Stream_Buffer ( s ) , length ) ; buffer -> cbBuffer = length ; Stream_SetPosition ( s , PayloadBufferOffset ) ; if ( flags & MSV_AV_FLAGS_MESSAGE_INTEGRITY_CHECK ) { context -> MessageIntegrityCheckOffset = ( UINT32 ) Stream_GetPosition ( s ) ; if ( Stream_GetRemainingLength ( s ) < 16 ) { Stream_Free ( s , FALSE ) ; return SEC_E_INVALID_TOKEN ; } Stream_Read ( s , message -> MessageIntegrityCheck , 16 ) ; } # ifdef WITH_DEBUG_NTLM WLog_DBG ( TAG , ""AUTHENTICATE_MESSAGE<S2SV_blank>(length<S2SV_blank>=<S2SV_blank>%"" PRIu32 "")"" , context -> AuthenticateMessage . cbBuffer ) ; winpr_HexDump ( TAG , WLOG_DEBUG , context -> AuthenticateMessage . pvBuffer , context -> AuthenticateMessage . cbBuffer ) ; if ( message -> NegotiateFlags & NTLMSSP_NEGOTIATE_VERSION ) ntlm_print_version_info ( & ( message -> Version ) ) ; ntlm_print_message_fields ( & ( message -> DomainName ) , ""DomainName"" ) ; ntlm_print_message_fields ( & ( message -> UserName ) , ""UserName"" ) ; ntlm_print_message_fields ( & ( message -> Workstation ) , ""Workstation"" ) ; ntlm_print_message_fields ( & ( message -> LmChallengeResponse ) , ""LmChallengeResponse"" ) ; ntlm_print_message_fields ( & ( message -> NtChallengeResponse ) , ""NtChallengeResponse"" ) ; ntlm_print_message_fields ( & ( message -> EncryptedRandomSessionKey ) , ""EncryptedRandomSessionKey"" ) ; ntlm_print_av_pair_list ( context -> NTLMv2Response . Challenge . AvPairs , context -> NTLMv2Response . Challenge . cbAvPairs ) ; if ( flags & MSV_AV_FLAGS_MESSAGE_INTEGRITY_CHECK ) { WLog_DBG ( TAG , ""MessageIntegrityCheck:"" ) ; winpr_HexDump ( TAG , WLOG_DEBUG , message -> MessageIntegrityCheck , 16 ) ; } # endif if ( message -> UserName . Len > 0 ) { credentials -> identity . User = ( UINT16 * ) malloc ( message -> UserName . Len ) ; if ( ! credentials -> identity . User ) <S2SV_StartBug> { <S2SV_EndBug> Stream_Free ( s , FALSE ) ; return SEC_E_INTERNAL_ERROR ; } CopyMemory ( credentials -> identity . User , message -> UserName . Buffer , message -> UserName . Len ) ; credentials -> identity . UserLength = message -> UserName . Len / 2 ; } if ( message -> DomainName . Len > 0 ) { credentials -> identity . Domain = ( UINT16 * ) malloc ( message -> DomainName . Len ) ; if ( ! credentials -> identity . Domain ) <S2SV_StartBug> { <S2SV_EndBug> Stream_Free ( s , FALSE ) ; return SEC_E_INTERNAL_ERROR ; } CopyMemory ( credentials -> identity . Domain , message -> DomainName . Buffer , message -> DomainName . Len ) ; credentials -> identity . DomainLength = message -> DomainName . Len / 2 ; } Stream_Free ( s , FALSE ) ; context -> state = NTLM_STATE_COMPLETION ; return SEC_I_COMPLETE_NEEDED ; <S2SV_StartBug> } <S2SV_EndBug>","buffer ) { SECURITY_STATUS status = SEC_E_INVALID_TOKEN ; <S2SV_ModStart> ; UINT32 flags = 0 <S2SV_ModStart> NTLM_AV_PAIR * AvFlags = NULL <S2SV_ModStart> -> credentials ; <S2SV_ModEnd> message = & <S2SV_ModStart> < 0 ) goto fail ; <S2SV_ModEnd> if ( message <S2SV_ModStart> != MESSAGE_TYPE_AUTHENTICATE ) goto fail ; <S2SV_ModEnd> if ( ntlm_read_message_fields <S2SV_ModStart> < 0 ) goto fail ; <S2SV_ModEnd> if ( ntlm_read_message_fields <S2SV_ModStart> < 0 ) goto fail ; <S2SV_ModEnd> if ( ntlm_read_message_fields <S2SV_ModStart> < 0 ) goto fail ; <S2SV_ModEnd> if ( ntlm_read_message_fields <S2SV_ModStart> < 0 ) goto fail ; <S2SV_ModEnd> if ( ntlm_read_message_fields <S2SV_ModStart> < 0 ) goto fail ; <S2SV_ModEnd> if ( ntlm_read_message_fields <S2SV_ModStart> < 0 ) goto fail ; if ( Stream_GetRemainingLength ( s ) < 4 ) goto fail ; <S2SV_ModEnd> Stream_Read_UINT32 ( s <S2SV_ModStart> Len ) ) goto fail ; if ( message -> NegotiateFlags & NTLMSSP_NEGOTIATE_VERSION ) { if ( ntlm_read_version_info ( s , & ( message -> Version ) ) < 0 ) goto fail ; } PayloadBufferOffset = Stream_GetPosition ( s ) ; status = SEC_E_INTERNAL_ERROR ; if ( ntlm_read_message_fields_buffer ( s , & ( message -> DomainName ) ) < 0 ) goto fail ; if ( ntlm_read_message_fields_buffer ( s , & ( message -> UserName ) ) < 0 ) goto fail ; if ( ntlm_read_message_fields_buffer ( s , & ( message -> Workstation ) ) < 0 ) goto fail ; if ( ntlm_read_message_fields_buffer ( s , & ( message -> LmChallengeResponse ) ) < 0 ) goto fail ; if ( ntlm_read_message_fields_buffer ( s , & ( message -> NtChallengeResponse ) ) < 0 ) goto fail ; if ( message -> NtChallengeResponse . Len > 0 ) { int rc ; <S2SV_ModEnd> size_t cbAvFlags ; <S2SV_ModStart> ! snt ) goto fail ; status = SEC_E_INVALID_TOKEN ; rc = ntlm_read_ntlm_v2_response ( snt , & ( context -> NTLMv2Response ) ) ; Stream_Free ( snt <S2SV_ModEnd> , FALSE ) <S2SV_ModStart> FALSE ) ; if ( rc < 0 ) goto fail ; status = SEC_E_INTERNAL_ERROR <S2SV_ModEnd> ; context -> <S2SV_ModStart> < 0 ) goto fail ; <S2SV_ModEnd> if ( message <S2SV_ModStart> != 16 ) goto fail ; <S2SV_ModEnd> CopyMemory ( context <S2SV_ModStart> length ) ) goto fail ; CopyMemory ( context -> AuthenticateMessage . pvBuffer , Stream_Buffer ( s ) , length ) ; buffer -> cbBuffer = length ; Stream_SetPosition ( s , PayloadBufferOffset ) ; if ( flags & MSV_AV_FLAGS_MESSAGE_INTEGRITY_CHECK ) { context -> MessageIntegrityCheckOffset = ( UINT32 ) Stream_GetPosition ( s ) ; status = SEC_E_INVALID_TOKEN ; if ( Stream_GetRemainingLength ( s ) < 16 ) goto fail ; Stream_Read ( s , message -> MessageIntegrityCheck , 16 ) ; } status = SEC_E_INTERNAL_ERROR ; <S2SV_ModEnd> # ifdef WITH_DEBUG_NTLM <S2SV_ModStart> . User ) goto fail ; <S2SV_ModEnd> CopyMemory ( credentials <S2SV_ModStart> . Domain ) goto fail ; <S2SV_ModEnd> CopyMemory ( credentials <S2SV_ModStart> return SEC_I_COMPLETE_NEEDED ; fail : Stream_Free ( s , FALSE ) ; return status ;"
711,"static void create_watching_parent ( void ) { pid_t child ; sigset_t ourset ; struct sigaction oldact [ 3 ] ; int status = 0 ; int retval ; retval = pam_open_session ( pamh , 0 ) ; if ( is_pam_failure ( retval ) ) { cleanup_pam ( retval ) ; errx ( EXIT_FAILURE , _ ( ""cannot<S2SV_blank>open<S2SV_blank>session:<S2SV_blank>%s"" ) , pam_strerror ( pamh , retval ) ) ; } else _pam_session_opened = 1 ; memset ( oldact , 0 , sizeof ( oldact ) ) ; child = fork ( ) ; if ( child == ( pid_t ) - 1 ) { cleanup_pam ( PAM_ABORT ) ; err ( EXIT_FAILURE , _ ( ""cannot<S2SV_blank>create<S2SV_blank>child<S2SV_blank>process"" ) ) ; } if ( child == 0 ) return ; if ( chdir ( ""/"" ) != 0 ) warn ( _ ( ""cannot<S2SV_blank>change<S2SV_blank>directory<S2SV_blank>to<S2SV_blank>%s"" ) , ""/"" ) ; sigfillset ( & ourset ) ; if ( sigprocmask ( SIG_BLOCK , & ourset , NULL ) ) { warn ( _ ( ""cannot<S2SV_blank>block<S2SV_blank>signals"" ) ) ; caught_signal = true ; } if ( ! caught_signal ) { struct sigaction action ; action . sa_handler = su_catch_sig ; sigemptyset ( & action . sa_mask ) ; action . sa_flags = 0 ; sigemptyset ( & ourset ) ; if ( ! same_session ) { if ( sigaddset ( & ourset , SIGINT ) || sigaddset ( & ourset , SIGQUIT ) ) { warn ( _ ( ""cannot<S2SV_blank>set<S2SV_blank>signal<S2SV_blank>handler"" ) ) ; caught_signal = true ; } } if ( ! caught_signal && ( sigaddset ( & ourset , SIGTERM ) || sigaddset ( & ourset , SIGALRM ) || sigaction ( SIGTERM , & action , & oldact [ 0 ] ) || sigprocmask ( SIG_UNBLOCK , & ourset , NULL ) ) ) { warn ( _ ( ""cannot<S2SV_blank>set<S2SV_blank>signal<S2SV_blank>handler"" ) ) ; caught_signal = true ; } if ( ! caught_signal && ! same_session && ( sigaction ( SIGINT , & action , & oldact [ 1 ] ) || sigaction ( SIGQUIT , & action , & oldact [ 2 ] ) ) ) { warn ( _ ( ""cannot<S2SV_blank>set<S2SV_blank>signal<S2SV_blank>handler"" ) ) ; caught_signal = true ; } } if ( ! caught_signal ) { pid_t pid ; for ( ; ; ) { pid = waitpid ( child , & status , WUNTRACED ) ; if ( pid != ( pid_t ) - 1 && WIFSTOPPED ( status ) ) { kill ( getpid ( ) , SIGSTOP ) ; kill ( pid , SIGCONT ) ; } else break ; } if ( pid != ( pid_t ) - 1 ) { if ( WIFSIGNALED ( status ) ) { fprintf ( stderr , ""%s%s\\n"" , strsignal ( WTERMSIG ( status ) ) , WCOREDUMP ( status ) ? _ ( ""<S2SV_blank>(core<S2SV_blank>dumped)"" ) : """" ) ; status = WTERMSIG ( status ) + 128 ; } else status = WEXITSTATUS ( status ) ; <S2SV_StartBug> } <S2SV_EndBug> else if ( caught_signal ) status = caught_signal + 128 ; else status = 1 ; } else status = 1 ; <S2SV_StartBug> if ( caught_signal ) <S2SV_EndBug> { fprintf ( stderr , _ ( ""\\nSession<S2SV_blank>terminated,<S2SV_blank>killing<S2SV_blank>shell..."" ) ) ; kill ( child , SIGTERM ) ; } cleanup_pam ( PAM_SUCCESS ) ; if ( caught_signal ) { <S2SV_StartBug> sleep ( 2 ) ; <S2SV_EndBug> kill ( child , SIGKILL ) ; <S2SV_StartBug> fprintf ( stderr , _ ( ""<S2SV_blank>...killed.\\n"" ) ) ; <S2SV_EndBug> switch ( caught_signal ) { case SIGTERM : sigaction ( SIGTERM , & oldact [ 0 ] , NULL ) ; break ; case SIGINT : sigaction ( SIGINT , & oldact [ 1 ] , NULL ) ; break ; case SIGQUIT : sigaction ( SIGQUIT , & oldact [ 2 ] , NULL ) ; break ; default : caught_signal = SIGKILL ; break ; } kill ( getpid ( ) , caught_signal ) ; } exit ( status ) ; }",status ) ; child = ( pid_t ) - 1 ; <S2SV_ModStart> if ( caught_signal && child != ( pid_t ) - 1 <S2SV_ModStart> caught_signal ) { if ( child != ( pid_t ) - 1 ) { <S2SV_ModStart> ) ) ; }
712,"int socket_create ( uint16_t port ) { int sfd = - 1 ; int yes = 1 ; # ifdef WIN32 WSADATA wsa_data ; if ( ! wsa_init ) { if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsa_data ) != ERROR_SUCCESS ) { fprintf ( stderr , ""WSAStartup<S2SV_blank>failed!\\n"" ) ; ExitProcess ( - 1 ) ; } wsa_init = 1 ; } # endif struct sockaddr_in saddr ; if ( 0 > ( sfd = socket ( PF_INET , SOCK_STREAM , IPPROTO_TCP ) ) ) { perror ( ""socket()"" ) ; return - 1 ; } if ( setsockopt ( sfd , SOL_SOCKET , SO_REUSEADDR , ( void * ) & yes , sizeof ( int ) ) == - 1 ) { perror ( ""setsockopt()"" ) ; socket_close ( sfd ) ; return - 1 ; } # ifdef SO_NOSIGPIPE if ( setsockopt ( sfd , SOL_SOCKET , SO_NOSIGPIPE , ( void * ) & yes , sizeof ( int ) ) == - 1 ) { perror ( ""setsockopt()"" ) ; socket_close ( sfd ) ; return - 1 ; } # endif memset ( ( void * ) & saddr , 0 , sizeof ( saddr ) ) ; saddr . sin_family = AF_INET ; <S2SV_StartBug> saddr . sin_addr . s_addr = htonl ( INADDR_ANY ) ; <S2SV_EndBug> saddr . sin_port = htons ( port ) ; if ( 0 > bind ( sfd , ( struct sockaddr * ) & saddr , sizeof ( saddr ) ) ) { perror ( ""bind()"" ) ; socket_close ( sfd ) ; return - 1 ; } if ( listen ( sfd , 1 ) == - 1 ) { perror ( ""listen()"" ) ; socket_close ( sfd ) ; return - 1 ; } return sfd ; }",= htonl ( INADDR_LOOPBACK <S2SV_ModEnd> ) ; saddr
713,"xfs_buf_t * _xfs_buf_find ( struct xfs_buftarg * btp , struct xfs_buf_map * map , int nmaps , xfs_buf_flags_t flags , xfs_buf_t * new_bp ) { size_t numbytes ; struct xfs_perag * pag ; struct rb_node * * rbp ; struct rb_node * parent ; xfs_buf_t * bp ; <S2SV_StartBug> xfs_daddr_t blkno = map [ 0 ] . bm_bn ; <S2SV_EndBug> int numblks = 0 ; int i ; for ( i = 0 ; i < nmaps ; i ++ ) numblks += map [ i ] . bm_len ; numbytes = BBTOB ( numblks ) ; ASSERT ( ! ( numbytes < ( 1 << btp -> bt_sshift ) ) ) ; ASSERT ( ! ( BBTOB ( blkno ) & ( xfs_off_t ) btp -> bt_smask ) ) ; <S2SV_StartBug> pag = xfs_perag_get ( btp -> bt_mount , <S2SV_EndBug> xfs_daddr_to_agno ( btp -> bt_mount , blkno ) ) ; spin_lock ( & pag -> pag_buf_lock ) ; rbp = & pag -> pag_buf_tree . rb_node ; parent = NULL ; bp = NULL ; while ( * rbp ) { parent = * rbp ; bp = rb_entry ( parent , struct xfs_buf , b_rbnode ) ; if ( blkno < bp -> b_bn ) rbp = & ( * rbp ) -> rb_left ; else if ( blkno > bp -> b_bn ) rbp = & ( * rbp ) -> rb_right ; else { if ( bp -> b_length != numblks ) { ASSERT ( bp -> b_flags & XBF_STALE ) ; rbp = & ( * rbp ) -> rb_right ; continue ; } atomic_inc ( & bp -> b_hold ) ; goto found ; } } if ( new_bp ) { rb_link_node ( & new_bp -> b_rbnode , parent , rbp ) ; rb_insert_color ( & new_bp -> b_rbnode , & pag -> pag_buf_tree ) ; new_bp -> b_pag = pag ; spin_unlock ( & pag -> pag_buf_lock ) ; } else { XFS_STATS_INC ( xb_miss_locked ) ; spin_unlock ( & pag -> pag_buf_lock ) ; xfs_perag_put ( pag ) ; } return new_bp ; found : spin_unlock ( & pag -> pag_buf_lock ) ; xfs_perag_put ( pag ) ; if ( ! xfs_buf_trylock ( bp ) ) { if ( flags & XBF_TRYLOCK ) { xfs_buf_rele ( bp ) ; XFS_STATS_INC ( xb_busy_locked ) ; return NULL ; } xfs_buf_lock ( bp ) ; XFS_STATS_INC ( xb_get_locked_waited ) ; } if ( bp -> b_flags & XBF_STALE ) { ASSERT ( ( bp -> b_flags & _XBF_DELWRI_Q ) == 0 ) ; ASSERT ( bp -> b_iodone == NULL ) ; bp -> b_flags &= _XBF_KMEM | _XBF_PAGES ; bp -> b_ops = NULL ; } trace_xfs_buf_find ( bp , flags , _RET_IP_ ) ; XFS_STATS_INC ( xb_get_locked ) ; return bp ; }","] . bm_bn ; xfs_daddr_t eofs <S2SV_ModStart> ) ) ; eofs = XFS_FSB_TO_BB ( btp -> bt_mount , btp -> bt_mount -> m_sb . sb_dblocks ) ; if ( blkno >= eofs ) { xfs_alert ( btp -> bt_mount , ""%s:<S2SV_blank>Block<S2SV_blank>out<S2SV_blank>of<S2SV_blank>range:<S2SV_blank>block<S2SV_blank>0x%llx,<S2SV_blank>EOFS<S2SV_blank>0x%llx<S2SV_blank>"" , __func__ , blkno , eofs ) ; return NULL ; }"
714,"int DSA_verify ( int type , const unsigned char * dgst , int dgst_len , const unsigned char * sigbuf , int siglen , DSA * dsa ) { DSA_SIG * s ; <S2SV_StartBug> int ret = - 1 ; <S2SV_EndBug> s = DSA_SIG_new ( ) ; if ( s == NULL ) return ( ret ) ; <S2SV_StartBug> if ( d2i_DSA_SIG ( & s , & sigbuf , siglen ) == NULL ) goto err ; <S2SV_EndBug> ret = DSA_do_verify ( dgst , dgst_len , s , dsa ) ; err : <S2SV_StartBug> DSA_SIG_free ( s ) ; <S2SV_EndBug> return ( ret ) ; }","* s ; const unsigned char * p = sigbuf ; unsigned char * der = NULL ; int derlen = - 1 ; <S2SV_ModStart> s , & p <S2SV_ModEnd> , siglen ) <S2SV_ModStart> == NULL ) goto err ; derlen = i2d_DSA_SIG ( s , & der ) ; if ( derlen != siglen || memcmp ( sigbuf , der , derlen ) ) <S2SV_ModStart> ; err : if ( derlen > 0 ) { OPENSSL_cleanse ( der , derlen ) ; OPENSSL_free ( der ) ; }"
715,"int sas_ex_revalidate_domain ( struct domain_device * port_dev ) { int res ; struct domain_device * dev = NULL ; res = sas_find_bcast_dev ( port_dev , & dev ) ; <S2SV_StartBug> while ( res == 0 && dev ) { <S2SV_EndBug> struct expander_device * ex = & dev -> ex_dev ; int i = 0 , phy_id ; do { phy_id = - 1 ; res = sas_find_bcast_phy ( dev , & phy_id , i , true ) ; if ( phy_id == - 1 ) break ; res = sas_rediscover ( dev , phy_id ) ; i = phy_id + 1 ; } while ( i < ex -> num_phys ) ; <S2SV_StartBug> dev = NULL ; <S2SV_EndBug> res = sas_find_bcast_dev ( port_dev , & dev ) ; } return res ; }",dev ) ; if <S2SV_ModEnd> ( res == <S2SV_ModStart> num_phys ) ; <S2SV_ModEnd> } return res
716,"static int atl2_probe ( struct pci_dev * pdev , const struct pci_device_id * ent ) { struct net_device * netdev ; struct atl2_adapter * adapter ; static int cards_found ; unsigned long mmio_start ; int mmio_len ; int err ; cards_found = 0 ; err = pci_enable_device ( pdev ) ; if ( err ) return err ; if ( pci_set_dma_mask ( pdev , DMA_BIT_MASK ( 32 ) ) && pci_set_consistent_dma_mask ( pdev , DMA_BIT_MASK ( 32 ) ) ) { printk ( KERN_ERR ""atl2:<S2SV_blank>No<S2SV_blank>usable<S2SV_blank>DMA<S2SV_blank>configuration,<S2SV_blank>aborting\\n"" ) ; goto err_dma ; } err = pci_request_regions ( pdev , atl2_driver_name ) ; if ( err ) goto err_pci_reg ; pci_set_master ( pdev ) ; err = - ENOMEM ; netdev = alloc_etherdev ( sizeof ( struct atl2_adapter ) ) ; if ( ! netdev ) goto err_alloc_etherdev ; SET_NETDEV_DEV ( netdev , & pdev -> dev ) ; pci_set_drvdata ( pdev , netdev ) ; adapter = netdev_priv ( netdev ) ; adapter -> netdev = netdev ; adapter -> pdev = pdev ; adapter -> hw . back = adapter ; mmio_start = pci_resource_start ( pdev , 0x0 ) ; mmio_len = pci_resource_len ( pdev , 0x0 ) ; adapter -> hw . mem_rang = ( u32 ) mmio_len ; adapter -> hw . hw_addr = ioremap ( mmio_start , mmio_len ) ; if ( ! adapter -> hw . hw_addr ) { err = - EIO ; goto err_ioremap ; } atl2_setup_pcicmd ( pdev ) ; netdev -> netdev_ops = & atl2_netdev_ops ; netdev -> ethtool_ops = & atl2_ethtool_ops ; netdev -> watchdog_timeo = 5 * HZ ; strncpy ( netdev -> name , pci_name ( pdev ) , sizeof ( netdev -> name ) - 1 ) ; netdev -> mem_start = mmio_start ; netdev -> mem_end = mmio_start + mmio_len ; adapter -> bd_number = cards_found ; adapter -> pci_using_64 = false ; err = atl2_sw_init ( adapter ) ; if ( err ) goto err_sw_init ; err = - EIO ; <S2SV_StartBug> netdev -> hw_features = NETIF_F_SG | NETIF_F_HW_VLAN_CTAG_RX ; <S2SV_EndBug> netdev -> features |= ( NETIF_F_HW_VLAN_CTAG_TX | NETIF_F_HW_VLAN_CTAG_RX ) ; atl2_phy_init ( & adapter -> hw ) ; if ( atl2_reset_hw ( & adapter -> hw ) ) { err = - EIO ; goto err_reset ; } atl2_read_mac_addr ( & adapter -> hw ) ; memcpy ( netdev -> dev_addr , adapter -> hw . mac_addr , netdev -> addr_len ) ; if ( ! is_valid_ether_addr ( netdev -> dev_addr ) ) { err = - EIO ; goto err_eeprom ; } atl2_check_options ( adapter ) ; setup_timer ( & adapter -> watchdog_timer , atl2_watchdog , ( unsigned long ) adapter ) ; setup_timer ( & adapter -> phy_config_timer , atl2_phy_config , ( unsigned long ) adapter ) ; INIT_WORK ( & adapter -> reset_task , atl2_reset_task ) ; INIT_WORK ( & adapter -> link_chg_task , atl2_link_chg_task ) ; strcpy ( netdev -> name , ""eth%d"" ) ; err = register_netdev ( netdev ) ; if ( err ) goto err_register ; netif_carrier_off ( netdev ) ; netif_stop_queue ( netdev ) ; cards_found ++ ; return 0 ; err_reset : err_register : err_sw_init : err_eeprom : iounmap ( adapter -> hw . hw_addr ) ; err_ioremap : free_netdev ( netdev ) ; err_alloc_etherdev : pci_release_regions ( pdev ) ; err_pci_reg : err_dma : pci_disable_device ( pdev ) ; return err ; }",-> hw_features = <S2SV_ModEnd> NETIF_F_HW_VLAN_CTAG_RX ; netdev
717,"int cdc_parse_cdc_header ( struct usb_cdc_parsed_header * hdr , struct usb_interface * intf , u8 * buffer , int buflen ) { struct usb_cdc_union_desc * union_header = NULL ; struct usb_cdc_header_desc * header = NULL ; struct usb_cdc_ether_desc * ether = NULL ; struct usb_cdc_mdlm_detail_desc * detail = NULL ; struct usb_cdc_mdlm_desc * desc = NULL ; unsigned int elength ; int cnt = 0 ; memset ( hdr , 0x00 , sizeof ( struct usb_cdc_parsed_header ) ) ; hdr -> phonet_magic_present = false ; while ( buflen > 0 ) { elength = buffer [ 0 ] ; if ( ! elength ) { dev_err ( & intf -> dev , ""skipping<S2SV_blank>garbage<S2SV_blank>byte\\n"" ) ; elength = 1 ; <S2SV_StartBug> goto next_desc ; <S2SV_EndBug> } if ( buffer [ 1 ] != USB_DT_CS_INTERFACE ) { dev_err ( & intf -> dev , ""skipping<S2SV_blank>garbage\\n"" ) ; goto next_desc ; } switch ( buffer [ 2 ] ) { case USB_CDC_UNION_TYPE : if ( elength < sizeof ( struct usb_cdc_union_desc ) ) goto next_desc ; if ( union_header ) { dev_err ( & intf -> dev , ""More<S2SV_blank>than<S2SV_blank>one<S2SV_blank>union<S2SV_blank>descriptor,<S2SV_blank>skipping<S2SV_blank>...\\n"" ) ; goto next_desc ; } union_header = ( struct usb_cdc_union_desc * ) buffer ; break ; case USB_CDC_COUNTRY_TYPE : if ( elength < sizeof ( struct usb_cdc_country_functional_desc ) ) goto next_desc ; hdr -> usb_cdc_country_functional_desc = ( struct usb_cdc_country_functional_desc * ) buffer ; break ; case USB_CDC_HEADER_TYPE : if ( elength != sizeof ( struct usb_cdc_header_desc ) ) goto next_desc ; if ( header ) return - EINVAL ; header = ( struct usb_cdc_header_desc * ) buffer ; break ; case USB_CDC_ACM_TYPE : if ( elength < sizeof ( struct usb_cdc_acm_descriptor ) ) goto next_desc ; hdr -> usb_cdc_acm_descriptor = ( struct usb_cdc_acm_descriptor * ) buffer ; break ; case USB_CDC_ETHERNET_TYPE : if ( elength != sizeof ( struct usb_cdc_ether_desc ) ) goto next_desc ; if ( ether ) return - EINVAL ; ether = ( struct usb_cdc_ether_desc * ) buffer ; break ; case USB_CDC_CALL_MANAGEMENT_TYPE : if ( elength < sizeof ( struct usb_cdc_call_mgmt_descriptor ) ) goto next_desc ; hdr -> usb_cdc_call_mgmt_descriptor = ( struct usb_cdc_call_mgmt_descriptor * ) buffer ; break ; case USB_CDC_DMM_TYPE : if ( elength < sizeof ( struct usb_cdc_dmm_desc ) ) goto next_desc ; hdr -> usb_cdc_dmm_desc = ( struct usb_cdc_dmm_desc * ) buffer ; break ; case USB_CDC_MDLM_TYPE : if ( elength < sizeof ( struct usb_cdc_mdlm_desc * ) ) goto next_desc ; if ( desc ) return - EINVAL ; desc = ( struct usb_cdc_mdlm_desc * ) buffer ; break ; case USB_CDC_MDLM_DETAIL_TYPE : if ( elength < sizeof ( struct usb_cdc_mdlm_detail_desc * ) ) goto next_desc ; if ( detail ) return - EINVAL ; detail = ( struct usb_cdc_mdlm_detail_desc * ) buffer ; break ; case USB_CDC_NCM_TYPE : if ( elength < sizeof ( struct usb_cdc_ncm_desc ) ) goto next_desc ; hdr -> usb_cdc_ncm_desc = ( struct usb_cdc_ncm_desc * ) buffer ; break ; case USB_CDC_MBIM_TYPE : if ( elength < sizeof ( struct usb_cdc_mbim_desc ) ) goto next_desc ; hdr -> usb_cdc_mbim_desc = ( struct usb_cdc_mbim_desc * ) buffer ; break ; case USB_CDC_MBIM_EXTENDED_TYPE : if ( elength < sizeof ( struct usb_cdc_mbim_extended_desc ) ) break ; hdr -> usb_cdc_mbim_extended_desc = ( struct usb_cdc_mbim_extended_desc * ) buffer ; break ; case CDC_PHONET_MAGIC_NUMBER : hdr -> phonet_magic_present = true ; break ; default : dev_dbg ( & intf -> dev , ""Ignoring<S2SV_blank>descriptor:<S2SV_blank>type<S2SV_blank>%02x,<S2SV_blank>length<S2SV_blank>%ud\\n"" , buffer [ 2 ] , elength ) ; goto next_desc ; } cnt ++ ; next_desc : buflen -= elength ; buffer += elength ; } hdr -> usb_cdc_union_desc = union_header ; hdr -> usb_cdc_header_desc = header ; hdr -> usb_cdc_mdlm_detail_desc = detail ; hdr -> usb_cdc_mdlm_desc = desc ; hdr -> usb_cdc_ether_desc = ether ; return cnt ; }","; goto next_desc ; } if ( ( buflen < elength ) || ( elength < 3 ) ) { dev_err ( & intf -> dev , ""invalid<S2SV_blank>descriptor<S2SV_blank>buffer<S2SV_blank>length\\n"" ) ; break"
718,"static gchar * read_file ( gchar * filepath ) { FILE * f ; size_t length ; gchar * ret = NULL ; <S2SV_StartBug> f = fopen ( filepath , ""rb"" ) ; <S2SV_EndBug> if ( f ) { fseek ( f , 0 , SEEK_END ) ; length = ( size_t ) ftell ( f ) ; fseek ( f , 0 , SEEK_SET ) ; ret = MALLOC ( length + 1 ) ; if ( ret ) { if ( fread ( ret , length , 1 , f ) != 1 ) { log_message ( LOG_INFO , ""Failed<S2SV_blank>to<S2SV_blank>read<S2SV_blank>all<S2SV_blank>of<S2SV_blank>%s"" , filepath ) ; } ret [ length ] = '\\0' ; } else log_message ( LOG_INFO , ""Unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>Dbus<S2SV_blank>file<S2SV_blank>%s"" , filepath ) ; fclose ( f ) ; } return ret ; }","( filepath , ""r"" <S2SV_ModEnd> ) ; if"
719,"int ext4_ext_insert_extent ( handle_t * handle , struct inode * inode , struct ext4_ext_path * path , struct ext4_extent * newext , int flag ) { struct ext4_extent_header * eh ; struct ext4_extent * ex , * fex ; struct ext4_extent * nearex ; struct ext4_ext_path * npath = NULL ; int depth , len , err ; ext4_lblk_t next ; unsigned uninitialized = 0 ; BUG_ON ( ext4_ext_get_actual_len ( newext ) == 0 ) ; depth = ext_depth ( inode ) ; ex = path [ depth ] . p_ext ; BUG_ON ( path [ depth ] . p_hdr == NULL ) ; <S2SV_StartBug> if ( ex && ( flag != EXT4_GET_BLOCKS_PRE_IO ) <S2SV_EndBug> && ext4_can_extents_be_merged ( inode , ex , newext ) ) { ext_debug ( ""append<S2SV_blank>[%d]%d<S2SV_blank>block<S2SV_blank>to<S2SV_blank>%d:[%d]%d<S2SV_blank>(from<S2SV_blank>%llu)\\n"" , ext4_ext_is_uninitialized ( newext ) , ext4_ext_get_actual_len ( newext ) , le32_to_cpu ( ex -> ee_block ) , ext4_ext_is_uninitialized ( ex ) , ext4_ext_get_actual_len ( ex ) , ext_pblock ( ex ) ) ; err = ext4_ext_get_access ( handle , inode , path + depth ) ; if ( err ) return err ; if ( ext4_ext_is_uninitialized ( ex ) ) uninitialized = 1 ; ex -> ee_len = cpu_to_le16 ( ext4_ext_get_actual_len ( ex ) + ext4_ext_get_actual_len ( newext ) ) ; if ( uninitialized ) ext4_ext_mark_uninitialized ( ex ) ; eh = path [ depth ] . p_hdr ; nearex = ex ; goto merge ; } repeat : depth = ext_depth ( inode ) ; eh = path [ depth ] . p_hdr ; if ( le16_to_cpu ( eh -> eh_entries ) < le16_to_cpu ( eh -> eh_max ) ) goto has_space ; fex = EXT_LAST_EXTENT ( eh ) ; next = ext4_ext_next_leaf_block ( inode , path ) ; if ( le32_to_cpu ( newext -> ee_block ) > le32_to_cpu ( fex -> ee_block ) && next != EXT_MAX_BLOCK ) { ext_debug ( ""next<S2SV_blank>leaf<S2SV_blank>block<S2SV_blank>-<S2SV_blank>%d\\n"" , next ) ; BUG_ON ( npath != NULL ) ; npath = ext4_ext_find_extent ( inode , next , NULL ) ; if ( IS_ERR ( npath ) ) return PTR_ERR ( npath ) ; BUG_ON ( npath -> p_depth != path -> p_depth ) ; eh = npath [ depth ] . p_hdr ; if ( le16_to_cpu ( eh -> eh_entries ) < le16_to_cpu ( eh -> eh_max ) ) { ext_debug ( ""next<S2SV_blank>leaf<S2SV_blank>isnt<S2SV_blank>full(%d)\\n"" , le16_to_cpu ( eh -> eh_entries ) ) ; path = npath ; goto repeat ; } ext_debug ( ""next<S2SV_blank>leaf<S2SV_blank>has<S2SV_blank>no<S2SV_blank>free<S2SV_blank>space(%d,%d)\\n"" , le16_to_cpu ( eh -> eh_entries ) , le16_to_cpu ( eh -> eh_max ) ) ; } err = ext4_ext_create_new_leaf ( handle , inode , path , newext ) ; if ( err ) goto cleanup ; depth = ext_depth ( inode ) ; eh = path [ depth ] . p_hdr ; has_space : nearex = path [ depth ] . p_ext ; err = ext4_ext_get_access ( handle , inode , path + depth ) ; if ( err ) goto cleanup ; if ( ! nearex ) { ext_debug ( ""first<S2SV_blank>extent<S2SV_blank>in<S2SV_blank>the<S2SV_blank>leaf:<S2SV_blank>%d:%llu:[%d]%d\\n"" , le32_to_cpu ( newext -> ee_block ) , ext_pblock ( newext ) , ext4_ext_is_uninitialized ( newext ) , ext4_ext_get_actual_len ( newext ) ) ; path [ depth ] . p_ext = EXT_FIRST_EXTENT ( eh ) ; } else if ( le32_to_cpu ( newext -> ee_block ) > le32_to_cpu ( nearex -> ee_block ) ) { if ( nearex != EXT_LAST_EXTENT ( eh ) ) { len = EXT_MAX_EXTENT ( eh ) - nearex ; len = ( len - 1 ) * sizeof ( struct ext4_extent ) ; len = len < 0 ? 0 : len ; ext_debug ( ""insert<S2SV_blank>%d:%llu:[%d]%d<S2SV_blank>after:<S2SV_blank>nearest<S2SV_blank>0x%p,<S2SV_blank>"" ""move<S2SV_blank>%d<S2SV_blank>from<S2SV_blank>0x%p<S2SV_blank>to<S2SV_blank>0x%p\\n"" , le32_to_cpu ( newext -> ee_block ) , ext_pblock ( newext ) , ext4_ext_is_uninitialized ( newext ) , ext4_ext_get_actual_len ( newext ) , nearex , len , nearex + 1 , nearex + 2 ) ; memmove ( nearex + 2 , nearex + 1 , len ) ; } path [ depth ] . p_ext = nearex + 1 ; } else { BUG_ON ( newext -> ee_block == nearex -> ee_block ) ; len = ( EXT_MAX_EXTENT ( eh ) - nearex ) * sizeof ( struct ext4_extent ) ; len = len < 0 ? 0 : len ; ext_debug ( ""insert<S2SV_blank>%d:%llu:[%d]%d<S2SV_blank>before:<S2SV_blank>nearest<S2SV_blank>0x%p,<S2SV_blank>"" ""move<S2SV_blank>%d<S2SV_blank>from<S2SV_blank>0x%p<S2SV_blank>to<S2SV_blank>0x%p\\n"" , le32_to_cpu ( newext -> ee_block ) , ext_pblock ( newext ) , ext4_ext_is_uninitialized ( newext ) , ext4_ext_get_actual_len ( newext ) , nearex , len , nearex + 1 , nearex + 2 ) ; memmove ( nearex + 1 , nearex , len ) ; path [ depth ] . p_ext = nearex ; } le16_add_cpu ( & eh -> eh_entries , 1 ) ; nearex = path [ depth ] . p_ext ; nearex -> ee_block = newext -> ee_block ; ext4_ext_store_pblock ( nearex , ext_pblock ( newext ) ) ; nearex -> ee_len = newext -> ee_len ; merge : <S2SV_StartBug> if ( flag != EXT4_GET_BLOCKS_PRE_IO ) <S2SV_EndBug> ext4_ext_try_to_merge ( inode , path , nearex ) ; err = ext4_ext_correct_indexes ( handle , inode , path ) ; if ( err ) goto cleanup ; err = ext4_ext_dirty ( handle , inode , path + depth ) ; cleanup : if ( npath ) { ext4_ext_drop_refs ( npath ) ; kfree ( npath ) ; } ext4_ext_invalidate_cache ( inode ) ; return err ; }",( ex && ! ( flag & <S2SV_ModEnd> EXT4_GET_BLOCKS_PRE_IO ) && <S2SV_ModStart> : if ( ! ( flag & EXT4_GET_BLOCKS_PRE_IO ) <S2SV_ModEnd> ) ext4_ext_try_to_merge (
720,"static void vhost_scsi_send_evt ( struct vhost_scsi * vs , struct vhost_scsi_tpg * tpg , struct se_lun * lun , u32 event , u32 reason ) { struct vhost_scsi_evt * evt ; evt = vhost_scsi_allocate_evt ( vs , event , reason ) ; if ( ! evt ) return ; if ( tpg && lun ) { evt -> event . lun [ 0 ] = 0x01 ; <S2SV_StartBug> evt -> event . lun [ 1 ] = tpg -> tport_tpgt & 0xFF ; <S2SV_EndBug> if ( lun -> unpacked_lun >= 256 ) evt -> event . lun [ 2 ] = lun -> unpacked_lun >> 8 | 0x40 ; evt -> event . lun [ 3 ] = lun -> unpacked_lun & 0xFF ; } llist_add ( & evt -> list , & vs -> vs_event_list ) ; vhost_work_queue ( & vs -> dev , & vs -> vs_event_work ) ; }",tpg -> tport_tpgt <S2SV_ModEnd> ; if (
721,"static int do_setxattr ( struct btrfs_trans_handle * trans , struct inode * inode , const char * name , const void * value , size_t size , int flags ) { <S2SV_StartBug> struct btrfs_dir_item * di ; <S2SV_EndBug> struct btrfs_root * root = BTRFS_I ( inode ) -> root ; struct btrfs_path * path ; size_t name_len = strlen ( name ) ; int ret = 0 ; if ( name_len + size > BTRFS_MAX_XATTR_SIZE ( root ) ) return - ENOSPC ; path = btrfs_alloc_path ( ) ; if ( ! path ) return - ENOMEM ; <S2SV_StartBug> if ( flags & XATTR_REPLACE ) { <S2SV_EndBug> <S2SV_StartBug> di = btrfs_lookup_xattr ( trans , root , path , btrfs_ino ( inode ) , name , <S2SV_EndBug> name_len , - 1 ) ; if ( IS_ERR ( di ) ) { ret = PTR_ERR ( di ) ; goto out ; <S2SV_StartBug> } else if ( ! di ) { <S2SV_EndBug> ret = - ENODATA ; goto out ; } <S2SV_StartBug> ret = btrfs_delete_one_dir_name ( trans , root , path , di ) ; <S2SV_EndBug> if ( ret ) goto out ; <S2SV_StartBug> btrfs_release_path ( path ) ; <S2SV_EndBug> if ( ! value ) goto out ; <S2SV_StartBug> } else { <S2SV_EndBug> di = btrfs_lookup_xattr ( NULL , root , path , btrfs_ino ( inode ) , name , name_len , 0 ) ; if ( IS_ERR ( di ) ) { ret = PTR_ERR ( di ) ; goto out ; } if ( ! di && ! value ) goto out ; btrfs_release_path ( path ) ; } again : ret = btrfs_insert_xattr_item ( trans , root , path , btrfs_ino ( inode ) , name , name_len , value , size ) ; if ( ret == - EOVERFLOW ) ret = - EEXIST ; if ( ret == - EEXIST ) { <S2SV_StartBug> if ( flags & XATTR_CREATE ) <S2SV_EndBug> goto out ; <S2SV_StartBug> btrfs_release_path ( path ) ; <S2SV_EndBug> di = btrfs_lookup_xattr ( trans , root , path , btrfs_ino ( inode ) , name , name_len , - 1 ) ; if ( IS_ERR ( di ) ) { ret = PTR_ERR ( di ) ; goto out ; <S2SV_StartBug> } else if ( ! di ) { <S2SV_EndBug> btrfs_release_path ( path ) ; goto again ; } ret = btrfs_delete_one_dir_name ( trans , root , path , di ) ; if ( ret ) goto out ; <S2SV_StartBug> if ( value ) { <S2SV_EndBug> btrfs_release_path ( path ) ; goto again ; } } out : btrfs_free_path ( path ) ; return ret ; }","btrfs_dir_item * di = NULL <S2SV_ModStart> - ENOMEM ; path -> skip_release_on_error = 1 ; if ( ! value ) { di = btrfs_lookup_xattr ( trans , root , path , btrfs_ino ( inode ) , name , name_len , - 1 ) ; if ( ! di && <S2SV_ModEnd> ( flags & <S2SV_ModStart> & XATTR_REPLACE ) ) ret = - ENODATA ; else if ( di ) ret = btrfs_delete_one_dir_name <S2SV_ModEnd> ( trans , <S2SV_ModStart> , path , <S2SV_ModEnd> di ) ; <S2SV_ModStart> out ; } if ( flags & XATTR_REPLACE ) { ASSERT ( mutex_is_locked ( & inode -> i_mutex ) ) ; di = btrfs_lookup_xattr ( NULL , root , path , btrfs_ino ( inode ) , name , name_len , 0 ) ; <S2SV_ModEnd> if ( ! <S2SV_ModStart> out ; } btrfs_release_path ( path ) ; di = NULL ; } ret = btrfs_insert_xattr_item <S2SV_ModEnd> ( trans , <S2SV_ModStart> , path , btrfs_ino ( inode ) , name , name_len , value , size ) ; if ( ret == - EOVERFLOW ) { ret = 0 ; btrfs_assert_tree_locked ( path -> nodes [ 0 ] ) ; di = btrfs_match_dir_item_name ( root , path , name , name_len ) ; if ( ! di && ! ( flags & XATTR_REPLACE ) ) { ret = - ENOSPC ; <S2SV_ModEnd> goto out ; <S2SV_ModStart> goto out ; } } else if ( ret == - EEXIST ) { ret = 0 ; di = btrfs_match_dir_item_name ( root , path , name , name_len ) ; ASSERT ( di ) ; } else if ( ret ) { <S2SV_ModEnd> goto out ; <S2SV_ModStart> out ; } if ( di && <S2SV_ModEnd> ( flags & <S2SV_ModStart> & XATTR_CREATE ) ) { ret = - EEXIST ; <S2SV_ModStart> goto out ; } if ( di ) { const int slot = path -> slots [ 0 ] ; struct extent_buffer * leaf = path -> nodes [ 0 ] ; const u16 old_data_len = btrfs_dir_data_len ( leaf , di ) ; const u32 item_size = btrfs_item_size_nr ( leaf , slot ) ; const u32 data_size = sizeof ( * di ) + name_len + size ; struct btrfs_item * item ; unsigned long data_ptr ; char * ptr ; if ( size > old_data_len ) { if ( btrfs_leaf_free_space ( root , leaf ) < ( size - old_data_len ) ) { ret = - ENOSPC <S2SV_ModEnd> ; goto out <S2SV_ModStart> out ; } } if ( old_data_len + name_len + sizeof ( * di ) == item_size ) { if ( size > old_data_len ) btrfs_extend_item ( root , path , size - old_data_len ) ; <S2SV_ModStart> else if ( size < old_data_len ) btrfs_truncate_item ( root , path , data_size , 1 ) ; } else { <S2SV_ModEnd> ret = btrfs_delete_one_dir_name <S2SV_ModStart> goto out ; btrfs_extend_item ( root , path , data_size ) ; } item = btrfs_item_nr ( slot ) ; ptr = btrfs_item_ptr ( leaf , slot , char ) ; ptr += btrfs_item_size ( leaf , item ) - data_size ; di = ( struct btrfs_dir_item * ) ptr ; btrfs_set_dir_data_len ( leaf , di , size ) ; data_ptr = ( ( unsigned long ) ( di + 1 ) ) + name_len ; write_extent_buffer ( leaf , value , data_ptr , size ) ; btrfs_mark_buffer_dirty ( leaf ) ; } else { <S2SV_ModEnd> } out :"
722,"void Strgrow ( Str x ) { char * old = x -> ptr ; int newlen ; <S2SV_StartBug> newlen = x -> length * 6 / 5 ; <S2SV_EndBug> <S2SV_StartBug> if ( newlen == x -> length ) <S2SV_EndBug> newlen += 2 ; x -> ptr = GC_MALLOC_ATOMIC ( newlen ) ; x -> area_size = newlen ; bcopy ( ( void * ) old , ( void * ) x -> ptr , x -> length ) ; GC_free ( old ) ; }",= x -> area_size <S2SV_ModEnd> * 6 / <S2SV_ModStart> == x -> area_size <S2SV_ModEnd> ) newlen +=
723,"static int vsock_stream_recvmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { struct sock * sk ; struct vsock_sock * vsk ; int err ; size_t target ; ssize_t copied ; long timeout ; struct vsock_transport_recv_notify_data recv_data ; DEFINE_WAIT ( wait ) ; sk = sock -> sk ; vsk = vsock_sk ( sk ) ; err = 0 ; <S2SV_StartBug> lock_sock ( sk ) ; <S2SV_EndBug> if ( sk -> sk_state != SS_CONNECTED ) { if ( sock_flag ( sk , SOCK_DONE ) ) err = 0 ; else err = - ENOTCONN ; goto out ; } if ( flags & MSG_OOB ) { err = - EOPNOTSUPP ; goto out ; } if ( sk -> sk_shutdown & RCV_SHUTDOWN ) { err = 0 ; goto out ; } if ( ! len ) { err = 0 ; goto out ; } target = sock_rcvlowat ( sk , flags & MSG_WAITALL , len ) ; if ( target >= transport -> stream_rcvhiwat ( vsk ) ) { err = - ENOMEM ; goto out ; } timeout = sock_rcvtimeo ( sk , flags & MSG_DONTWAIT ) ; copied = 0 ; err = transport -> notify_recv_init ( vsk , target , & recv_data ) ; if ( err < 0 ) goto out ; prepare_to_wait ( sk_sleep ( sk ) , & wait , TASK_INTERRUPTIBLE ) ; while ( 1 ) { s64 ready = vsock_stream_has_data ( vsk ) ; if ( ready < 0 ) { err = - ENOMEM ; goto out_wait ; } else if ( ready > 0 ) { ssize_t read ; err = transport -> notify_recv_pre_dequeue ( vsk , target , & recv_data ) ; if ( err < 0 ) break ; read = transport -> stream_dequeue ( vsk , msg -> msg_iov , len - copied , flags ) ; if ( read < 0 ) { err = - ENOMEM ; break ; } copied += read ; err = transport -> notify_recv_post_dequeue ( vsk , target , read , ! ( flags & MSG_PEEK ) , & recv_data ) ; if ( err < 0 ) goto out_wait ; if ( read >= target || flags & MSG_PEEK ) break ; target -= read ; } else { if ( sk -> sk_err != 0 || ( sk -> sk_shutdown & RCV_SHUTDOWN ) || ( vsk -> peer_shutdown & SEND_SHUTDOWN ) ) { break ; } if ( timeout == 0 ) { err = - EAGAIN ; break ; } err = transport -> notify_recv_pre_block ( vsk , target , & recv_data ) ; if ( err < 0 ) break ; release_sock ( sk ) ; timeout = schedule_timeout ( timeout ) ; lock_sock ( sk ) ; if ( signal_pending ( current ) ) { err = sock_intr_errno ( timeout ) ; break ; } else if ( timeout == 0 ) { err = - EAGAIN ; break ; } prepare_to_wait ( sk_sleep ( sk ) , & wait , TASK_INTERRUPTIBLE ) ; } } if ( sk -> sk_err ) err = - sk -> sk_err ; else if ( sk -> sk_shutdown & RCV_SHUTDOWN ) err = 0 ; if ( copied > 0 ) { if ( ! ( flags & MSG_PEEK ) ) { if ( vsk -> peer_shutdown & SEND_SHUTDOWN ) { if ( vsock_stream_has_data ( vsk ) <= 0 ) { sk -> sk_state = SS_UNCONNECTED ; sock_set_flag ( sk , SOCK_DONE ) ; sk -> sk_state_change ( sk ) ; } } } err = copied ; } out_wait : finish_wait ( sk_sleep ( sk ) , & wait ) ; out : release_sock ( sk ) ; return err ; }",= 0 ; msg -> msg_namelen = 0 ;
724,"CURLcode Curl_urldecode ( struct SessionHandle * data , const char * string , size_t length , char * * ostring , size_t * olen , bool reject_ctrl ) { size_t alloc = ( length ? length : strlen ( string ) ) + 1 ; char * ns = malloc ( alloc ) ; unsigned char in ; size_t strindex = 0 ; unsigned long hex ; CURLcode res ; if ( ! ns ) return CURLE_OUT_OF_MEMORY ; while ( -- alloc > 0 ) { in = * string ; <S2SV_StartBug> if ( ( '%' == in ) && ISXDIGIT ( string [ 1 ] ) && ISXDIGIT ( string [ 2 ] ) ) { <S2SV_EndBug> char hexstr [ 3 ] ; char * ptr ; hexstr [ 0 ] = string [ 1 ] ; hexstr [ 1 ] = string [ 2 ] ; hexstr [ 2 ] = 0 ; hex = strtoul ( hexstr , & ptr , 16 ) ; in = curlx_ultouc ( hex ) ; res = Curl_convert_from_network ( data , & in , 1 ) ; if ( res ) { free ( ns ) ; return res ; } string += 2 ; alloc -= 2 ; } if ( reject_ctrl && ( in < 0x20 ) ) { free ( ns ) ; return CURLE_URL_MALFORMAT ; } ns [ strindex ++ ] = in ; string ++ ; } ns [ strindex ] = 0 ; if ( olen ) * olen = strindex ; if ( ostring ) * ostring = ns ; return CURLE_OK ; }",in ) && ( alloc > 2 ) &&
725,"int inet6_csk_xmit ( struct sock * sk , struct sk_buff * skb , struct flowi * fl_unused ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct flowi6 fl6 ; struct dst_entry * dst ; int res ; dst = inet6_csk_route_socket ( sk , & fl6 ) ; if ( IS_ERR ( dst ) ) { sk -> sk_err_soft = - PTR_ERR ( dst ) ; sk -> sk_route_caps = 0 ; kfree_skb ( skb ) ; return PTR_ERR ( dst ) ; } rcu_read_lock ( ) ; skb_dst_set_noref ( skb , dst ) ; fl6 . daddr = sk -> sk_v6_daddr ; <S2SV_StartBug> res = ip6_xmit ( sk , skb , & fl6 , np -> opt , np -> tclass ) ; <S2SV_EndBug> rcu_read_unlock ( ) ; return res ; }","& fl6 , rcu_dereference ( <S2SV_ModStart> np -> opt )"
726,"void ipv4_pktinfo_prepare ( const struct sock * sk , struct sk_buff * skb ) { struct in_pktinfo * pktinfo = PKTINFO_SKB_CB ( skb ) ; bool prepare = ( inet_sk ( sk ) -> cmsg_flags & IP_CMSG_PKTINFO ) || ipv6_sk_rxinfo ( sk ) ; if ( prepare && skb_rtable ( skb ) ) { if ( pktinfo -> ipi_ifindex == LOOPBACK_IFINDEX ) pktinfo -> ipi_ifindex = inet_iif ( skb ) ; pktinfo -> ipi_spec_dst . s_addr = fib_compute_spec_dst ( skb ) ; } else { pktinfo -> ipi_ifindex = 0 ; pktinfo -> ipi_spec_dst . s_addr = 0 ; } <S2SV_StartBug> skb_dst_drop ( skb ) ; <S2SV_EndBug> }",0 ; } if ( unlikely ( IPCB ( skb ) -> opt . optlen ) ) skb_dst_force ( skb ) ; else
727,"static void xsltCompileLocationPathPattern ( xsltParserContextPtr ctxt , int novar ) { SKIP_BLANKS ; if ( ( CUR == '/' ) && ( NXT ( 1 ) == '/' ) ) { NEXT ; NEXT ; ctxt -> comp -> priority = 0.5 ; xsltCompileRelativePathPattern ( ctxt , NULL , novar ) ; } else if ( CUR == '/' ) { NEXT ; SKIP_BLANKS ; PUSH ( XSLT_OP_ROOT , NULL , NULL , novar ) ; if ( ( CUR != 0 ) && ( CUR != '|' ) ) { PUSH ( XSLT_OP_PARENT , NULL , NULL , novar ) ; xsltCompileRelativePathPattern ( ctxt , NULL , novar ) ; } } else if ( CUR == '*' ) { xsltCompileRelativePathPattern ( ctxt , NULL , novar ) ; } else if ( CUR == '@' ) { xsltCompileRelativePathPattern ( ctxt , NULL , novar ) ; } else { xmlChar * name ; name = xsltScanNCName ( ctxt ) ; if ( name == NULL ) { xsltTransformError ( NULL , NULL , NULL , ""xsltCompileLocationPathPattern<S2SV_blank>:<S2SV_blank>Name<S2SV_blank>expected\\n"" ) ; ctxt -> error = 1 ; return ; } SKIP_BLANKS ; if ( ( CUR == '(' ) && ! xmlXPathIsNodeType ( name ) ) { xsltCompileIdKeyPattern ( ctxt , name , 1 , novar , 0 ) ; <S2SV_StartBug> if ( ( CUR == '/' ) && ( NXT ( 1 ) == '/' ) ) { <S2SV_EndBug> PUSH ( XSLT_OP_ANCESTOR , NULL , NULL , novar ) ; NEXT ; NEXT ; SKIP_BLANKS ; xsltCompileRelativePathPattern ( ctxt , NULL , novar ) ; } else if ( CUR == '/' ) { PUSH ( XSLT_OP_PARENT , NULL , NULL , novar ) ; NEXT ; SKIP_BLANKS ; xsltCompileRelativePathPattern ( ctxt , NULL , novar ) ; } return ; } xsltCompileRelativePathPattern ( ctxt , name , novar ) ; } error : return ; }",; if ( ctxt -> error ) return ; if (
728,"static int iucv_sock_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { int noblock = flags & MSG_DONTWAIT ; struct sock * sk = sock -> sk ; struct iucv_sock * iucv = iucv_sk ( sk ) ; unsigned int copied , rlen ; struct sk_buff * skb , * rskb , * cskb ; int err = 0 ; <S2SV_StartBug> u32 offset ; <S2SV_EndBug> msg -> msg_namelen = 0 ; if ( ( sk -> sk_state == IUCV_DISCONN ) && skb_queue_empty ( & iucv -> backlog_skb_q ) && skb_queue_empty ( & sk -> sk_receive_queue ) && list_empty ( & iucv -> message_q . list ) ) return 0 ; if ( flags & ( MSG_OOB ) ) return - EOPNOTSUPP ; skb = skb_recv_datagram ( sk , flags , noblock , & err ) ; if ( ! skb ) { if ( sk -> sk_shutdown & RCV_SHUTDOWN ) return 0 ; return err ; } offset = IUCV_SKB_CB ( skb ) -> offset ; rlen = skb -> len - offset ; copied = min_t ( unsigned int , rlen , len ) ; if ( ! rlen ) sk -> sk_shutdown = sk -> sk_shutdown | RCV_SHUTDOWN ; cskb = skb ; if ( skb_copy_datagram_iovec ( cskb , offset , msg -> msg_iov , copied ) ) { if ( ! ( flags & MSG_PEEK ) ) skb_queue_head ( & sk -> sk_receive_queue , skb ) ; return - EFAULT ; } if ( sk -> sk_type == SOCK_SEQPACKET ) { if ( copied < rlen ) msg -> msg_flags |= MSG_TRUNC ; msg -> msg_flags |= MSG_EOR ; } err = put_cmsg ( msg , SOL_IUCV , SCM_IUCV_TRGCLS , sizeof ( IUCV_SKB_CB ( skb ) -> class ) , ( void * ) & IUCV_SKB_CB ( skb ) -> class ) ; if ( err ) { if ( ! ( flags & MSG_PEEK ) ) skb_queue_head ( & sk -> sk_receive_queue , skb ) ; return err ; } if ( ! ( flags & MSG_PEEK ) ) { if ( sk -> sk_type == SOCK_STREAM ) { if ( copied < rlen ) { IUCV_SKB_CB ( skb ) -> offset = offset + copied ; goto done ; } } kfree_skb ( skb ) ; if ( iucv -> transport == AF_IUCV_TRANS_HIPER ) { atomic_inc ( & iucv -> msg_recv ) ; if ( atomic_read ( & iucv -> msg_recv ) > iucv -> msglimit ) { WARN_ON ( 1 ) ; iucv_sock_close ( sk ) ; return - EFAULT ; } } spin_lock_bh ( & iucv -> message_q . lock ) ; rskb = skb_dequeue ( & iucv -> backlog_skb_q ) ; while ( rskb ) { IUCV_SKB_CB ( rskb ) -> offset = 0 ; if ( sock_queue_rcv_skb ( sk , rskb ) ) { skb_queue_head ( & iucv -> backlog_skb_q , rskb ) ; break ; } else { rskb = skb_dequeue ( & iucv -> backlog_skb_q ) ; } } if ( skb_queue_empty ( & iucv -> backlog_skb_q ) ) { if ( ! list_empty ( & iucv -> message_q . list ) ) iucv_process_message_q ( sk ) ; if ( atomic_read ( & iucv -> msg_recv ) >= iucv -> msglimit / 2 ) { err = iucv_send_ctrl ( sk , AF_IUCV_FLAG_WIN ) ; if ( err ) { sk -> sk_state = IUCV_DISCONN ; sk -> sk_state_change ( sk ) ; } } } spin_unlock_bh ( & iucv -> message_q . lock ) ; } done : if ( sk -> sk_type == SOCK_SEQPACKET && ( flags & MSG_TRUNC ) ) copied = rlen ; return copied ; }",; u32 offset <S2SV_ModEnd> ; if (
729,"int ssh_packet_get_state ( struct ssh * ssh , struct sshbuf * m ) { struct session_state * state = ssh -> state ; u_char * p ; size_t slen , rlen ; int r , ssh1cipher ; if ( ! compat20 ) { ssh1cipher = cipher_ctx_get_number ( state -> receive_context ) ; slen = cipher_get_keyiv_len ( state -> send_context ) ; rlen = cipher_get_keyiv_len ( state -> receive_context ) ; if ( ( r = sshbuf_put_u32 ( m , state -> remote_protocol_flags ) ) != 0 || ( r = sshbuf_put_u32 ( m , ssh1cipher ) ) != 0 || ( r = sshbuf_put_string ( m , state -> ssh1_key , state -> ssh1_keylen ) ) != 0 || ( r = sshbuf_put_u32 ( m , slen ) ) != 0 || ( r = sshbuf_reserve ( m , slen , & p ) ) != 0 || ( r = cipher_get_keyiv ( state -> send_context , p , slen ) ) != 0 || ( r = sshbuf_put_u32 ( m , rlen ) ) != 0 || ( r = sshbuf_reserve ( m , rlen , & p ) ) != 0 || ( r = cipher_get_keyiv ( state -> receive_context , p , rlen ) ) != 0 ) return r ; } else { if ( ( r = kex_to_blob ( m , ssh -> kex ) ) != 0 || ( r = newkeys_to_blob ( m , ssh , MODE_OUT ) ) != 0 || ( r = newkeys_to_blob ( m , ssh , MODE_IN ) ) != 0 || ( r = sshbuf_put_u64 ( m , state -> rekey_limit ) ) != 0 || ( r = sshbuf_put_u32 ( m , state -> rekey_interval ) ) != 0 || ( r = sshbuf_put_u32 ( m , state -> p_send . seqnr ) ) != 0 || ( r = sshbuf_put_u64 ( m , state -> p_send . blocks ) ) != 0 || ( r = sshbuf_put_u32 ( m , state -> p_send . packets ) ) != 0 || ( r = sshbuf_put_u64 ( m , state -> p_send . bytes ) ) != 0 || ( r = sshbuf_put_u32 ( m , state -> p_read . seqnr ) ) != 0 || ( r = sshbuf_put_u64 ( m , state -> p_read . blocks ) ) != 0 || ( r = sshbuf_put_u32 ( m , state -> p_read . packets ) ) != 0 || ( r = sshbuf_put_u64 ( m , state -> p_read . bytes ) ) != 0 ) return r ; } slen = cipher_get_keycontext ( state -> send_context , NULL ) ; rlen = cipher_get_keycontext ( state -> receive_context , NULL ) ; if ( ( r = sshbuf_put_u32 ( m , slen ) ) != 0 || ( r = sshbuf_reserve ( m , slen , & p ) ) != 0 ) return r ; if ( cipher_get_keycontext ( state -> send_context , p ) != ( int ) slen ) return SSH_ERR_INTERNAL_ERROR ; if ( ( r = sshbuf_put_u32 ( m , rlen ) ) != 0 || ( r = sshbuf_reserve ( m , rlen , & p ) ) != 0 ) return r ; if ( cipher_get_keycontext ( state -> receive_context , p ) != ( int ) rlen ) return SSH_ERR_INTERNAL_ERROR ; <S2SV_StartBug> if ( ( r = ssh_packet_get_compress_state ( m , ssh ) ) != 0 || <S2SV_EndBug> ( r = sshbuf_put_stringb ( m , state -> input ) ) != 0 || ( r = sshbuf_put_stringb ( m , state -> output ) ) != 0 ) return r ; return 0 ; }",( r = <S2SV_ModEnd> sshbuf_put_stringb ( m
730,"void fmtutil_macbitmap_read_pixmap_only_fields ( deark * c , dbuf * f , struct fmtutil_macbitmap_info * bi , i64 pos ) { i64 pixmap_version ; i64 pack_size ; i64 plane_bytes ; i64 n ; de_dbg ( c , ""additional<S2SV_blank>PixMap<S2SV_blank>header<S2SV_blank>fields,<S2SV_blank>at<S2SV_blank>%d"" , ( int ) pos ) ; de_dbg_indent ( c , 1 ) ; pixmap_version = dbuf_getu16be ( f , pos + 0 ) ; de_dbg ( c , ""pixmap<S2SV_blank>version:<S2SV_blank>%d"" , ( int ) pixmap_version ) ; bi -> packing_type = dbuf_getu16be ( f , pos + 2 ) ; de_dbg ( c , ""packing<S2SV_blank>type:<S2SV_blank>%d"" , ( int ) bi -> packing_type ) ; pack_size = dbuf_getu32be ( f , pos + 4 ) ; de_dbg ( c , ""pixel<S2SV_blank>data<S2SV_blank>length:<S2SV_blank>%d"" , ( int ) pack_size ) ; bi -> hdpi = pict_read_fixed ( f , pos + 8 ) ; bi -> vdpi = pict_read_fixed ( f , pos + 12 ) ; de_dbg ( c , ""dpi:<S2SV_blank>%.2f"" DE_CHAR_TIMES ""%.2f"" , bi -> hdpi , bi -> vdpi ) ; bi -> pixeltype = dbuf_getu16be ( f , pos + 16 ) ; bi -> pixelsize = dbuf_getu16be ( f , pos + 18 ) ; bi -> cmpcount = dbuf_getu16be ( f , pos + 20 ) ; bi -> cmpsize = dbuf_getu16be ( f , pos + 22 ) ; de_dbg ( c , ""pixel<S2SV_blank>type=%d,<S2SV_blank>bits/pixel=%d,<S2SV_blank>components/pixel=%d,<S2SV_blank>bits/comp=%d"" , ( int ) bi -> pixeltype , ( int ) bi -> pixelsize , ( int ) bi -> cmpcount , ( int ) bi -> cmpsize ) ; <S2SV_StartBug> bi -> pdwidth = ( bi -> rowbytes * 8 ) / bi -> pixelsize ; <S2SV_EndBug> <S2SV_StartBug> if ( bi -> pdwidth < bi -> npwidth ) { <S2SV_EndBug> bi -> pdwidth = bi -> npwidth ; } plane_bytes = dbuf_getu32be ( f , pos + 24 ) ; de_dbg ( c , ""plane<S2SV_blank>bytes:<S2SV_blank>%d"" , ( int ) plane_bytes ) ; bi -> pmTable = ( u32 ) dbuf_getu32be ( f , pos + 28 ) ; de_dbg ( c , ""pmTable:<S2SV_blank>0x%08x"" , ( unsigned int ) bi -> pmTable ) ; n = dbuf_getu32be ( f , pos + 32 ) ; de_dbg ( c , ""pmReserved:<S2SV_blank>0x%08x"" , ( unsigned int ) n ) ; de_dbg_indent ( c , - 1 ) ; }",cmpsize ) ; if ( bi -> pixelsize > 0 ) { <S2SV_ModStart> -> pixelsize ; }
731,"static void sas_unregister_devs_sas_addr ( struct domain_device * parent , int phy_id , bool last ) { struct expander_device * ex_dev = & parent -> ex_dev ; struct ex_phy * phy = & ex_dev -> ex_phy [ phy_id ] ; struct domain_device * child , * n , * found = NULL ; if ( last ) { list_for_each_entry_safe ( child , n , & ex_dev -> children , siblings ) { if ( SAS_ADDR ( child -> sas_addr ) == SAS_ADDR ( phy -> attached_sas_addr ) ) { set_bit ( SAS_DEV_GONE , & child -> state ) ; if ( child -> dev_type == SAS_EDGE_EXPANDER_DEVICE || child -> dev_type == SAS_FANOUT_EXPANDER_DEVICE ) sas_unregister_ex_tree ( parent -> port , child ) ; else sas_unregister_dev ( parent -> port , child ) ; found = child ; break ; } } sas_disable_routing ( parent , phy -> attached_sas_addr ) ; } memset ( phy -> attached_sas_addr , 0 , SAS_ADDR_SIZE ) ; if ( phy -> port ) { sas_port_delete_phy ( phy -> port , phy -> phy ) ; sas_device_set_phy ( found , phy -> port ) ; if ( phy -> port -> num_phys == 0 ) <S2SV_StartBug> sas_port_delete ( phy -> port ) ; <S2SV_EndBug> phy -> port = NULL ; } }","== 0 ) list_add_tail ( & phy -> port -> del_list , & parent -> port -> sas_port_del_list <S2SV_ModEnd> ) ; phy"
732,"<S2SV_StartBug> static u32 __ipv6_select_ident ( struct net * net , u32 hashrnd , <S2SV_EndBug> const struct in6_addr * dst , const struct in6_addr * src ) { <S2SV_StartBug> u32 hash , id ; <S2SV_EndBug> <S2SV_StartBug> hash = __ipv6_addr_jhash ( dst , hashrnd ) ; <S2SV_EndBug> <S2SV_StartBug> hash = __ipv6_addr_jhash ( src , hash ) ; <S2SV_EndBug> hash ^= net_hash_mix ( net ) ; id = ip_idents_reserve ( hash , 1 ) ; if ( unlikely ( ! id ) ) id = 1 << 31 ; return id ; }","net * net <S2SV_ModEnd> , const struct <S2SV_ModStart> src ) { const struct { struct in6_addr dst ; struct in6_addr src ; } __aligned ( SIPHASH_ALIGNMENT ) combined = { . dst = * dst , . src = * src , } ; <S2SV_ModStart> , id ; if ( unlikely ( siphash_key_is_zero ( & net -> ipv4 . ip_id_key ) ) ) get_random_bytes ( & net -> ipv4 . ip_id_key , sizeof ( net -> ipv4 . ip_id_key ) <S2SV_ModEnd> ) ; hash <S2SV_ModStart> ; hash = siphash ( & combined , sizeof ( combined ) , & net -> ipv4 . ip_id_key <S2SV_ModEnd> ) ; id"
733,"static ssize_t aio_setup_single_vector ( struct kiocb * kiocb , int rw , char __user * buf , unsigned long * nr_segs , struct iovec * iovec ) { <S2SV_StartBug> if ( unlikely ( ! access_ok ( ! rw , buf , kiocb -> ki_nbytes ) ) ) <S2SV_EndBug> return - EFAULT ; iovec -> iov_base = buf ; <S2SV_StartBug> iovec -> iov_len = kiocb -> ki_nbytes ; <S2SV_EndBug> * nr_segs = 1 ; return 0 ; }","iovec ) { size_t len = kiocb -> ki_nbytes ; if ( len > MAX_RW_COUNT ) len = MAX_RW_COUNT ; <S2SV_ModStart> , buf , len <S2SV_ModEnd> ) ) ) <S2SV_ModStart> -> iov_len = len <S2SV_ModEnd> ; * nr_segs"
734,"static int PredictorEncodeRow ( TIFF * tif , uint8 * bp , tmsize_t cc , uint16 s ) { TIFFPredictorState * sp = PredictorState ( tif ) ; assert ( sp != NULL ) ; assert ( sp -> encodepfunc != NULL ) ; assert ( sp -> encoderow != NULL ) ; <S2SV_StartBug> ( * sp -> encodepfunc ) ( tif , bp , cc ) ; <S2SV_EndBug> return ( * sp -> encoderow ) ( tif , bp , cc , s ) ; }","NULL ) ; if ( ! <S2SV_ModStart> , cc ) ) return 0"
735,"static void define_gf_group ( VP8_COMP * cpi , FIRSTPASS_STATS * this_frame ) { FIRSTPASS_STATS next_frame ; FIRSTPASS_STATS * start_pos ; int i ; double r ; double boost_score = 0.0 ; double old_boost_score = 0.0 ; double gf_group_err = 0.0 ; double gf_first_frame_err = 0.0 ; double mod_frame_err = 0.0 ; double mv_ratio_accumulator = 0.0 ; double decay_accumulator = 1.0 ; double loop_decay_rate = 1.00 ; double this_frame_mv_in_out = 0.0 ; double mv_in_out_accumulator = 0.0 ; double abs_mv_in_out_accumulator = 0.0 ; double mod_err_per_mb_accumulator = 0.0 ; int max_bits = frame_max_bits ( cpi ) ; unsigned int allow_alt_ref = cpi -> oxcf . play_alternate && cpi -> oxcf . lag_in_frames ; int alt_boost = 0 ; int f_boost = 0 ; int b_boost = 0 ; int flash_detected ; cpi -> twopass . gf_group_bits = 0 ; cpi -> twopass . gf_decay_rate = 0 ; vp8_clear_system_state ( ) ; start_pos = cpi -> twopass . stats_in ; <S2SV_StartBug> vpx_memset ( & next_frame , 0 , sizeof ( next_frame ) ) ; <S2SV_EndBug> mod_frame_err = calculate_modified_err ( cpi , this_frame ) ; gf_first_frame_err = mod_frame_err ; if ( cpi -> common . frame_type == KEY_FRAME ) gf_group_err -= gf_first_frame_err ; i = 0 ; while ( ( ( i < cpi -> twopass . static_scene_max_gf_interval ) || ( ( cpi -> twopass . frames_to_key - i ) < MIN_GF_INTERVAL ) ) && ( i < cpi -> twopass . frames_to_key ) ) { i ++ ; mod_frame_err = calculate_modified_err ( cpi , this_frame ) ; gf_group_err += mod_frame_err ; mod_err_per_mb_accumulator += mod_frame_err / DOUBLE_DIVIDE_CHECK ( ( double ) cpi -> common . MBs ) ; if ( EOF == input_stats ( cpi , & next_frame ) ) break ; flash_detected = detect_flash ( cpi , 0 ) ; accumulate_frame_motion_stats ( cpi , & next_frame , & this_frame_mv_in_out , & mv_in_out_accumulator , & abs_mv_in_out_accumulator , & mv_ratio_accumulator ) ; r = calc_frame_boost ( cpi , & next_frame , this_frame_mv_in_out ) ; if ( ! flash_detected ) { loop_decay_rate = get_prediction_decay_rate ( cpi , & next_frame ) ; decay_accumulator = decay_accumulator * loop_decay_rate ; decay_accumulator = decay_accumulator < 0.1 ? 0.1 : decay_accumulator ; } boost_score += ( decay_accumulator * r ) ; if ( detect_transition_to_still ( cpi , i , 5 , loop_decay_rate , decay_accumulator ) ) { allow_alt_ref = 0 ; boost_score = old_boost_score ; break ; } if ( ( i >= cpi -> max_gf_interval && ( decay_accumulator < 0.995 ) ) || ( ( i > MIN_GF_INTERVAL ) && ( ( cpi -> twopass . frames_to_key - i ) >= MIN_GF_INTERVAL ) && ( ( boost_score > 20.0 ) || ( next_frame . pcnt_inter < 0.75 ) ) && ( ! flash_detected ) && ( ( mv_ratio_accumulator > 100.0 ) || ( abs_mv_in_out_accumulator > 3.0 ) || ( mv_in_out_accumulator < - 2.0 ) || ( ( boost_score - old_boost_score ) < 2.0 ) ) ) ) { boost_score = old_boost_score ; break ; } <S2SV_StartBug> vpx_memcpy ( this_frame , & next_frame , sizeof ( * this_frame ) ) ; <S2SV_EndBug> old_boost_score = boost_score ; } cpi -> twopass . gf_decay_rate = ( i > 0 ) ? ( int ) ( 100.0 * ( 1.0 - decay_accumulator ) ) / i : 0 ; if ( cpi -> oxcf . end_usage == USAGE_STREAM_FROM_SERVER ) { double max_boost ; if ( cpi -> drop_frames_allowed ) { int64_t df_buffer_level = cpi -> oxcf . drop_frames_water_mark * ( cpi -> oxcf . optimal_buffer_level / 100 ) ; if ( cpi -> buffer_level > df_buffer_level ) max_boost = ( ( double ) ( ( cpi -> buffer_level - df_buffer_level ) * 2 / 3 ) * 16.0 ) / DOUBLE_DIVIDE_CHECK ( ( double ) cpi -> av_per_frame_bandwidth ) ; else max_boost = 0.0 ; } else if ( cpi -> buffer_level > 0 ) { max_boost = ( ( double ) ( cpi -> buffer_level * 2 / 3 ) * 16.0 ) / DOUBLE_DIVIDE_CHECK ( ( double ) cpi -> av_per_frame_bandwidth ) ; } else { max_boost = 0.0 ; } if ( boost_score > max_boost ) boost_score = max_boost ; } if ( ( cpi -> twopass . frames_to_key - i ) < MIN_GF_INTERVAL ) { while ( i < cpi -> twopass . frames_to_key ) { i ++ ; if ( EOF == input_stats ( cpi , this_frame ) ) break ; if ( i < cpi -> twopass . frames_to_key ) { mod_frame_err = calculate_modified_err ( cpi , this_frame ) ; gf_group_err += mod_frame_err ; } } } cpi -> gfu_boost = ( int ) ( boost_score * 100.0 ) >> 4 ; # if NEW_BOOST alt_boost = calc_arf_boost ( cpi , 0 , ( i - 1 ) , ( i - 1 ) , & f_boost , & b_boost ) ; # endif if ( allow_alt_ref && ( i >= MIN_GF_INTERVAL ) && ( i <= ( cpi -> twopass . frames_to_key - MIN_GF_INTERVAL ) ) && # if NEW_BOOST ( ( next_frame . pcnt_inter > 0.75 ) || ( next_frame . pcnt_second_ref > 0.5 ) ) && ( ( mv_in_out_accumulator / ( double ) i > - 0.2 ) || ( mv_in_out_accumulator > - 2.0 ) ) && ( b_boost > 100 ) && ( f_boost > 100 ) ) # else ( next_frame . pcnt_inter > 0.75 ) && ( ( mv_in_out_accumulator / ( double ) i > - 0.2 ) || ( mv_in_out_accumulator > - 2.0 ) ) && ( cpi -> gfu_boost > 100 ) && ( cpi -> twopass . gf_decay_rate <= ( ARF_DECAY_THRESH + ( cpi -> gfu_boost / 200 ) ) ) ) # endif { int Boost ; int allocation_chunks ; int Q = ( cpi -> oxcf . fixed_q < 0 ) ? cpi -> last_q [ INTER_FRAME ] : cpi -> oxcf . fixed_q ; int tmp_q ; int arf_frame_bits = 0 ; int group_bits ; # if NEW_BOOST cpi -> gfu_boost = alt_boost ; # endif if ( ( cpi -> twopass . kf_group_bits > 0 ) && ( cpi -> twopass . kf_group_error_left > 0 ) ) { group_bits = ( int ) ( ( double ) cpi -> twopass . kf_group_bits * ( gf_group_err / ( double ) cpi -> twopass . kf_group_error_left ) ) ; } else group_bits = 0 ; # if NEW_BOOST Boost = ( alt_boost * GFQ_ADJUSTMENT ) / 100 ; # else Boost = ( cpi -> gfu_boost * 3 * GFQ_ADJUSTMENT ) / ( 2 * 100 ) ; # endif Boost += ( i * 50 ) ; if ( Boost > ( ( cpi -> baseline_gf_interval + 1 ) * 200 ) ) Boost = ( ( cpi -> baseline_gf_interval + 1 ) * 200 ) ; else if ( Boost < 125 ) Boost = 125 ; allocation_chunks = ( i * 100 ) + Boost ; while ( Boost > 1000 ) { Boost /= 2 ; allocation_chunks /= 2 ; } arf_frame_bits = ( int ) ( ( double ) Boost * ( group_bits / ( double ) allocation_chunks ) ) ; tmp_q = estimate_q ( cpi , mod_frame_err , ( int ) arf_frame_bits ) ; if ( tmp_q < cpi -> worst_quality ) { int half_gf_int ; int frames_after_arf ; int frames_bwd = cpi -> oxcf . arnr_max_frames - 1 ; int frames_fwd = cpi -> oxcf . arnr_max_frames - 1 ; cpi -> source_alt_ref_pending = 1 ; cpi -> baseline_gf_interval = i ; half_gf_int = cpi -> baseline_gf_interval >> 1 ; frames_after_arf = ( int ) ( cpi -> twopass . total_stats . count - this_frame -> frame - 1 ) ; switch ( cpi -> oxcf . arnr_type ) { case 1 : frames_fwd = 0 ; if ( frames_bwd > half_gf_int ) frames_bwd = half_gf_int ; break ; case 2 : if ( frames_fwd > half_gf_int ) frames_fwd = half_gf_int ; if ( frames_fwd > frames_after_arf ) frames_fwd = frames_after_arf ; frames_bwd = 0 ; break ; case 3 : default : frames_fwd >>= 1 ; if ( frames_fwd > frames_after_arf ) frames_fwd = frames_after_arf ; if ( frames_fwd > half_gf_int ) frames_fwd = half_gf_int ; frames_bwd = frames_fwd ; if ( frames_bwd < half_gf_int ) frames_bwd += ( cpi -> oxcf . arnr_max_frames + 1 ) & 0x1 ; break ; } cpi -> active_arnr_frames = frames_bwd + 1 + frames_fwd ; } else { cpi -> source_alt_ref_pending = 0 ; cpi -> baseline_gf_interval = i ; } } else { cpi -> source_alt_ref_pending = 0 ; cpi -> baseline_gf_interval = i ; } if ( cpi -> twopass . frames_to_key >= ( int ) ( cpi -> twopass . total_stats . count - cpi -> common . current_video_frame ) ) { cpi -> twopass . kf_group_bits = ( cpi -> twopass . bits_left > 0 ) ? cpi -> twopass . bits_left : 0 ; } if ( ( cpi -> twopass . kf_group_bits > 0 ) && ( cpi -> twopass . kf_group_error_left > 0 ) ) { cpi -> twopass . gf_group_bits = ( int64_t ) ( cpi -> twopass . kf_group_bits * ( gf_group_err / cpi -> twopass . kf_group_error_left ) ) ; } else cpi -> twopass . gf_group_bits = 0 ; cpi -> twopass . gf_group_bits = ( cpi -> twopass . gf_group_bits < 0 ) ? 0 : ( cpi -> twopass . gf_group_bits > cpi -> twopass . kf_group_bits ) ? cpi -> twopass . kf_group_bits : cpi -> twopass . gf_group_bits ; if ( cpi -> twopass . gf_group_bits > ( int64_t ) max_bits * cpi -> baseline_gf_interval ) cpi -> twopass . gf_group_bits = ( int64_t ) max_bits * cpi -> baseline_gf_interval ; reset_fpf_position ( cpi , start_pos ) ; cpi -> twopass . modified_error_used += gf_group_err ; for ( i = 0 ; i <= ( cpi -> source_alt_ref_pending && cpi -> common . frame_type != KEY_FRAME ) ; i ++ ) { int Boost ; int allocation_chunks ; int Q = ( cpi -> oxcf . fixed_q < 0 ) ? cpi -> last_q [ INTER_FRAME ] : cpi -> oxcf . fixed_q ; int gf_bits ; if ( cpi -> source_alt_ref_pending && i == 0 ) { # if NEW_BOOST Boost = ( alt_boost * GFQ_ADJUSTMENT ) / 100 ; # else Boost = ( cpi -> gfu_boost * 3 * GFQ_ADJUSTMENT ) / ( 2 * 100 ) ; # endif Boost += ( cpi -> baseline_gf_interval * 50 ) ; if ( Boost > ( ( cpi -> baseline_gf_interval + 1 ) * 200 ) ) Boost = ( ( cpi -> baseline_gf_interval + 1 ) * 200 ) ; else if ( Boost < 125 ) Boost = 125 ; allocation_chunks = ( ( cpi -> baseline_gf_interval + 1 ) * 100 ) + Boost ; } else { Boost = ( cpi -> gfu_boost * GFQ_ADJUSTMENT ) / 100 ; if ( Boost > ( cpi -> baseline_gf_interval * 150 ) ) Boost = ( cpi -> baseline_gf_interval * 150 ) ; else if ( Boost < 125 ) Boost = 125 ; allocation_chunks = ( cpi -> baseline_gf_interval * 100 ) + ( Boost - 100 ) ; } while ( Boost > 1000 ) { Boost /= 2 ; allocation_chunks /= 2 ; } gf_bits = ( int ) ( ( double ) Boost * ( cpi -> twopass . gf_group_bits / ( double ) allocation_chunks ) ) ; if ( mod_frame_err < gf_group_err / ( double ) cpi -> baseline_gf_interval ) { double alt_gf_grp_bits ; int alt_gf_bits ; alt_gf_grp_bits = ( double ) cpi -> twopass . kf_group_bits * ( mod_frame_err * ( double ) cpi -> baseline_gf_interval ) / DOUBLE_DIVIDE_CHECK ( ( double ) cpi -> twopass . kf_group_error_left ) ; alt_gf_bits = ( int ) ( ( double ) Boost * ( alt_gf_grp_bits / ( double ) allocation_chunks ) ) ; if ( gf_bits > alt_gf_bits ) { gf_bits = alt_gf_bits ; } } else { int alt_gf_bits = ( int ) ( ( double ) cpi -> twopass . kf_group_bits * mod_frame_err / DOUBLE_DIVIDE_CHECK ( ( double ) cpi -> twopass . kf_group_error_left ) ) ; if ( alt_gf_bits > gf_bits ) { gf_bits = alt_gf_bits ; } } if ( cpi -> oxcf . end_usage == USAGE_STREAM_FROM_SERVER ) { if ( cpi -> twopass . gf_bits > ( int ) ( cpi -> buffer_level >> 1 ) ) cpi -> twopass . gf_bits = ( int ) ( cpi -> buffer_level >> 1 ) ; } if ( gf_bits < 0 ) gf_bits = 0 ; gf_bits += cpi -> min_frame_bandwidth ; if ( i == 0 ) { cpi -> twopass . gf_bits = gf_bits ; } if ( i == 1 || ( ! cpi -> source_alt_ref_pending && ( cpi -> common . frame_type != KEY_FRAME ) ) ) { cpi -> per_frame_bandwidth = gf_bits ; } } { cpi -> twopass . kf_group_error_left -= ( int64_t ) gf_group_err ; cpi -> twopass . kf_group_bits -= cpi -> twopass . gf_group_bits ; if ( cpi -> twopass . kf_group_bits < 0 ) cpi -> twopass . kf_group_bits = 0 ; if ( ! cpi -> source_alt_ref_pending && cpi -> common . frame_type != KEY_FRAME ) cpi -> twopass . gf_group_error_left = ( int ) ( gf_group_err - gf_first_frame_err ) ; else cpi -> twopass . gf_group_error_left = ( int ) gf_group_err ; cpi -> twopass . gf_group_bits -= cpi -> twopass . gf_bits - cpi -> min_frame_bandwidth ; if ( cpi -> twopass . gf_group_bits < 0 ) cpi -> twopass . gf_group_bits = 0 ; if ( cpi -> baseline_gf_interval >= 3 ) { # if NEW_BOOST int boost = ( cpi -> source_alt_ref_pending ) ? b_boost : cpi -> gfu_boost ; # else int boost = cpi -> gfu_boost ; # endif if ( boost >= 150 ) { int pct_extra ; pct_extra = ( boost - 100 ) / 50 ; pct_extra = ( pct_extra > 20 ) ? 20 : pct_extra ; cpi -> twopass . alt_extra_bits = ( int ) ( cpi -> twopass . gf_group_bits * pct_extra ) / 100 ; cpi -> twopass . gf_group_bits -= cpi -> twopass . alt_extra_bits ; cpi -> twopass . alt_extra_bits /= ( ( cpi -> baseline_gf_interval - 1 ) >> 1 ) ; } else cpi -> twopass . alt_extra_bits = 0 ; } else cpi -> twopass . alt_extra_bits = 0 ; } if ( cpi -> common . frame_type != KEY_FRAME ) { FIRSTPASS_STATS sectionstats ; double Ratio ; zero_stats ( & sectionstats ) ; reset_fpf_position ( cpi , start_pos ) ; for ( i = 0 ; i < cpi -> baseline_gf_interval ; i ++ ) { input_stats ( cpi , & next_frame ) ; accumulate_stats ( & sectionstats , & next_frame ) ; } avg_stats ( & sectionstats ) ; cpi -> twopass . section_intra_rating = ( unsigned int ) ( sectionstats . intra_error / DOUBLE_DIVIDE_CHECK ( sectionstats . coded_error ) ) ; Ratio = sectionstats . intra_error / DOUBLE_DIVIDE_CHECK ( sectionstats . coded_error ) ; cpi -> twopass . section_max_qfactor = 1.0 - ( ( Ratio - 10.0 ) * 0.025 ) ; if ( cpi -> twopass . section_max_qfactor < 0.80 ) cpi -> twopass . section_max_qfactor = 0.80 ; reset_fpf_position ( cpi , start_pos ) ; } }",". stats_in ; memset <S2SV_ModEnd> ( & next_frame <S2SV_ModStart> break ; } memcpy <S2SV_ModEnd> ( this_frame ,"
736,"int main ( int argc , char * argv [ ] ) { struct mschm_decompressor * chmd ; struct mschmd_header * chm ; struct mschmd_file * file , * * f ; unsigned int numf , i ; setbuf ( stdout , NULL ) ; setbuf ( stderr , NULL ) ; user_umask = umask ( 0 ) ; umask ( user_umask ) ; MSPACK_SYS_SELFTEST ( i ) ; if ( i ) return 0 ; if ( ( chmd = mspack_create_chm_decompressor ( NULL ) ) ) { for ( argv ++ ; * argv ; argv ++ ) { printf ( ""%s\\n"" , * argv ) ; if ( ( chm = chmd -> open ( chmd , * argv ) ) ) { for ( numf = 0 , file = chm -> files ; file ; file = file -> next ) numf ++ ; if ( ( f = ( struct mschmd_file * * ) calloc ( numf , sizeof ( struct mschmd_file * ) ) ) ) { for ( i = 0 , file = chm -> files ; file ; file = file -> next ) f [ i ++ ] = file ; qsort ( f , numf , sizeof ( struct mschmd_file * ) , & sortfunc ) ; for ( i = 0 ; i < numf ; i ++ ) { <S2SV_StartBug> char * outname = create_output_name ( ( unsigned char * ) f [ i ] -> filename , NULL , 0 , 1 , 0 ) ; <S2SV_EndBug> printf ( ""Extracting<S2SV_blank>%s\\n"" , outname ) ; ensure_filepath ( outname ) ; if ( chmd -> extract ( chmd , f [ i ] , outname ) ) { printf ( ""%s:<S2SV_blank>extract<S2SV_blank>error<S2SV_blank>on<S2SV_blank>\\""%s\\"":<S2SV_blank>%s\\n"" , * argv , f [ i ] -> filename , ERROR ( chmd ) ) ; } free ( outname ) ; } free ( f ) ; } chmd -> close ( chmd , chm ) ; } else { printf ( ""%s:<S2SV_blank>can\'t<S2SV_blank>open<S2SV_blank>--<S2SV_blank>%s\\n"" , * argv , ERROR ( chmd ) ) ; } } mspack_destroy_chm_decompressor ( chmd ) ; } return 0 ; }",= create_output_name ( <S2SV_ModEnd> f [ i <S2SV_ModStart> ] -> filename <S2SV_ModEnd> ) ; printf
737,"int ParseDsdiffHeaderConfig ( FILE * infile , char * infilename , char * fourcc , WavpackContext * wpc , WavpackConfig * config ) { int64_t infilesize , total_samples ; DFFFileHeader dff_file_header ; DFFChunkHeader dff_chunk_header ; uint32_t bcount ; infilesize = DoGetFileSize ( infile ) ; memcpy ( & dff_file_header , fourcc , 4 ) ; if ( ( ! DoReadFile ( infile , ( ( char * ) & dff_file_header ) + 4 , sizeof ( DFFFileHeader ) - 4 , & bcount ) || bcount != sizeof ( DFFFileHeader ) - 4 ) || strncmp ( dff_file_header . formType , ""DSD<S2SV_blank>"" , 4 ) ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & dff_file_header , sizeof ( DFFFileHeader ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } # if 1 WavpackBigEndianToNative ( & dff_file_header , DFFFileHeaderFormat ) ; if ( infilesize && ! ( config -> qmode & QMODE_IGNORE_LENGTH ) && dff_file_header . ckDataSize && dff_file_header . ckDataSize + 1 && dff_file_header . ckDataSize + 12 != infilesize ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file<S2SV_blank>(by<S2SV_blank>total<S2SV_blank>size)!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( debug_logging_mode ) error_line ( ""file<S2SV_blank>header<S2SV_blank>indicated<S2SV_blank>length<S2SV_blank>=<S2SV_blank>%lld"" , dff_file_header . ckDataSize ) ; # endif while ( 1 ) { if ( ! DoReadFile ( infile , & dff_chunk_header , sizeof ( DFFChunkHeader ) , & bcount ) || bcount != sizeof ( DFFChunkHeader ) ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & dff_chunk_header , sizeof ( DFFChunkHeader ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackBigEndianToNative ( & dff_chunk_header , DFFChunkHeaderFormat ) ; if ( debug_logging_mode ) error_line ( ""chunk<S2SV_blank>header<S2SV_blank>indicated<S2SV_blank>length<S2SV_blank>=<S2SV_blank>%lld"" , dff_chunk_header . ckDataSize ) ; if ( ! strncmp ( dff_chunk_header . ckID , ""FVER"" , 4 ) ) { uint32_t version ; if ( dff_chunk_header . ckDataSize != sizeof ( version ) || ! DoReadFile ( infile , & version , sizeof ( version ) , & bcount ) || bcount != sizeof ( version ) ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & version , sizeof ( version ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackBigEndianToNative ( & version , ""L"" ) ; if ( debug_logging_mode ) error_line ( ""dsdiff<S2SV_blank>file<S2SV_blank>version<S2SV_blank>=<S2SV_blank>0x%08x"" , version ) ; } else if ( ! strncmp ( dff_chunk_header . ckID , ""PROP"" , 4 ) ) { char * prop_chunk ; if ( dff_chunk_header . ckDataSize < 4 || dff_chunk_header . ckDataSize > 1024 ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( debug_logging_mode ) error_line ( ""got<S2SV_blank>PROP<S2SV_blank>chunk<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>total"" , ( int ) dff_chunk_header . ckDataSize ) ; prop_chunk = malloc ( ( size_t ) dff_chunk_header . ckDataSize ) ; if ( ! DoReadFile ( infile , prop_chunk , ( uint32_t ) dff_chunk_header . ckDataSize , & bcount ) || bcount != dff_chunk_header . ckDataSize ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , prop_chunk , ( uint32_t ) dff_chunk_header . ckDataSize ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } if ( ! strncmp ( prop_chunk , ""SND<S2SV_blank>"" , 4 ) ) { char * cptr = prop_chunk + 4 , * eptr = prop_chunk + dff_chunk_header . ckDataSize ; <S2SV_StartBug> uint16_t numChannels , chansSpecified , chanMask = 0 ; <S2SV_EndBug> uint32_t sampleRate ; while ( eptr - cptr >= sizeof ( dff_chunk_header ) ) { memcpy ( & dff_chunk_header , cptr , sizeof ( dff_chunk_header ) ) ; cptr += sizeof ( dff_chunk_header ) ; WavpackBigEndianToNative ( & dff_chunk_header , DFFChunkHeaderFormat ) ; if ( dff_chunk_header . ckDataSize > 0 && dff_chunk_header . ckDataSize <= eptr - cptr ) { if ( ! strncmp ( dff_chunk_header . ckID , ""FS<S2SV_blank><S2SV_blank>"" , 4 ) && dff_chunk_header . ckDataSize == 4 ) { memcpy ( & sampleRate , cptr , sizeof ( sampleRate ) ) ; WavpackBigEndianToNative ( & sampleRate , ""L"" ) ; cptr += dff_chunk_header . ckDataSize ; if ( debug_logging_mode ) error_line ( ""got<S2SV_blank>sample<S2SV_blank>rate<S2SV_blank>of<S2SV_blank>%u<S2SV_blank>Hz"" , sampleRate ) ; } else if ( ! strncmp ( dff_chunk_header . ckID , ""CHNL"" , 4 ) && dff_chunk_header . ckDataSize >= 2 ) { memcpy ( & numChannels , cptr , sizeof ( numChannels ) ) ; WavpackBigEndianToNative ( & numChannels , ""S"" ) ; cptr += sizeof ( numChannels ) ; chansSpecified = ( int ) ( dff_chunk_header . ckDataSize - sizeof ( numChannels ) ) / 4 ; <S2SV_StartBug> if ( numChannels < chansSpecified || numChannels < 1 ) { <S2SV_EndBug> error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } while ( chansSpecified -- ) { if ( ! strncmp ( cptr , ""SLFT"" , 4 ) || ! strncmp ( cptr , ""MLFT"" , 4 ) ) chanMask |= 0x1 ; else if ( ! strncmp ( cptr , ""SRGT"" , 4 ) || ! strncmp ( cptr , ""MRGT"" , 4 ) ) chanMask |= 0x2 ; else if ( ! strncmp ( cptr , ""LS<S2SV_blank><S2SV_blank>"" , 4 ) ) chanMask |= 0x10 ; else if ( ! strncmp ( cptr , ""RS<S2SV_blank><S2SV_blank>"" , 4 ) ) chanMask |= 0x20 ; else if ( ! strncmp ( cptr , ""C<S2SV_blank><S2SV_blank><S2SV_blank>"" , 4 ) ) chanMask |= 0x4 ; else if ( ! strncmp ( cptr , ""LFE<S2SV_blank>"" , 4 ) ) chanMask |= 0x8 ; else if ( debug_logging_mode ) error_line ( ""undefined<S2SV_blank>channel<S2SV_blank>ID<S2SV_blank>%c%c%c%c"" , cptr [ 0 ] , cptr [ 1 ] , cptr [ 2 ] , cptr [ 3 ] ) ; cptr += 4 ; } if ( debug_logging_mode ) error_line ( ""%d<S2SV_blank>channels,<S2SV_blank>mask<S2SV_blank>=<S2SV_blank>0x%08x"" , numChannels , chanMask ) ; } else if ( ! strncmp ( dff_chunk_header . ckID , ""CMPR"" , 4 ) && dff_chunk_header . ckDataSize >= 4 ) { if ( strncmp ( cptr , ""DSD<S2SV_blank>"" , 4 ) ) { error_line ( ""DSDIFF<S2SV_blank>files<S2SV_blank>must<S2SV_blank>be<S2SV_blank>uncompressed,<S2SV_blank>not<S2SV_blank>\\""%c%c%c%c\\""!"" , cptr [ 0 ] , cptr [ 1 ] , cptr [ 2 ] , cptr [ 3 ] ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } cptr += dff_chunk_header . ckDataSize ; } else { if ( debug_logging_mode ) error_line ( ""got<S2SV_blank>PROP/SND<S2SV_blank>chunk<S2SV_blank>type<S2SV_blank>\\""%c%c%c%c\\""<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes"" , dff_chunk_header . ckID [ 0 ] , dff_chunk_header . ckID [ 1 ] , dff_chunk_header . ckID [ 2 ] , dff_chunk_header . ckID [ 3 ] , dff_chunk_header . ckDataSize ) ; cptr += dff_chunk_header . ckDataSize ; } } else { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } } if ( chanMask && ( config -> channel_mask || ( config -> qmode & QMODE_CHANS_UNASSIGNED ) ) ) { error_line ( ""this<S2SV_blank>DSDIFF<S2SV_blank>file<S2SV_blank>already<S2SV_blank>has<S2SV_blank>channel<S2SV_blank>order<S2SV_blank>information!"" ) ; free ( prop_chunk ) ; return WAVPACK_SOFT_ERROR ; } else if ( chanMask ) config -> channel_mask = chanMask ; config -> bits_per_sample = 8 ; config -> bytes_per_sample = 1 ; config -> num_channels = numChannels ; config -> sample_rate = sampleRate / 8 ; config -> qmode |= QMODE_DSD_MSB_FIRST ; } else if ( debug_logging_mode ) error_line ( ""got<S2SV_blank>unknown<S2SV_blank>PROP<S2SV_blank>chunk<S2SV_blank>type<S2SV_blank>\\""%c%c%c%c\\""<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes"" , prop_chunk [ 0 ] , prop_chunk [ 1 ] , prop_chunk [ 2 ] , prop_chunk [ 3 ] , dff_chunk_header . ckDataSize ) ; free ( prop_chunk ) ; } else if ( ! strncmp ( dff_chunk_header . ckID , ""DSD<S2SV_blank>"" , 4 ) ) { <S2SV_StartBug> total_samples = dff_chunk_header . ckDataSize / config -> num_channels ; <S2SV_EndBug> break ; } else { int bytes_to_copy = ( int ) ( ( ( dff_chunk_header . ckDataSize ) + 1 ) & ~ ( int64_t ) 1 ) ; char * buff ; if ( bytes_to_copy < 0 || bytes_to_copy > 4194304 ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } buff = malloc ( bytes_to_copy ) ; if ( debug_logging_mode ) error_line ( ""extra<S2SV_blank>unknown<S2SV_blank>chunk<S2SV_blank>\\""%c%c%c%c\\""<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes"" , dff_chunk_header . ckID [ 0 ] , dff_chunk_header . ckID [ 1 ] , dff_chunk_header . ckID [ 2 ] , dff_chunk_header . ckID [ 3 ] , dff_chunk_header . ckDataSize ) ; if ( ! DoReadFile ( infile , buff , bytes_to_copy , & bcount ) || bcount != bytes_to_copy || ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , buff , bytes_to_copy ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; free ( buff ) ; return WAVPACK_SOFT_ERROR ; } free ( buff ) ; } } if ( debug_logging_mode ) error_line ( ""setting<S2SV_blank>configuration<S2SV_blank>with<S2SV_blank>%lld<S2SV_blank>samples"" , total_samples ) ; if ( ! WavpackSetConfiguration64 ( wpc , config , total_samples , NULL ) ) { error_line ( ""%s:<S2SV_blank>%s"" , infilename , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } return WAVPACK_NO_ERROR ; }","; uint16_t numChannels = 0 <S2SV_ModStart> numChannels < 1 || numChannels > 256 <S2SV_ModStart> ) ) { if ( ! config -> num_channels ) { error_line ( ""%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.DFF<S2SV_blank>file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; }"
738,"static int tty_open ( struct inode * inode , struct file * filp ) { struct tty_struct * tty = NULL ; int noctty , retval ; struct tty_driver * driver ; int index ; dev_t device = inode -> i_rdev ; unsigned saved_flags = filp -> f_flags ; nonseekable_open ( inode , filp ) ; retry_open : noctty = filp -> f_flags & O_NOCTTY ; index = - 1 ; retval = 0 ; mutex_lock ( & tty_mutex ) ; tty_lock ( ) ; if ( device == MKDEV ( TTYAUX_MAJOR , 0 ) ) { tty = get_current_tty ( ) ; if ( ! tty ) { tty_unlock ( ) ; mutex_unlock ( & tty_mutex ) ; return - ENXIO ; } driver = tty_driver_kref_get ( tty -> driver ) ; index = tty -> index ; filp -> f_flags |= O_NONBLOCK ; tty_kref_put ( tty ) ; goto got_driver ; } # ifdef CONFIG_VT if ( device == MKDEV ( TTY_MAJOR , 0 ) ) { extern struct tty_driver * console_driver ; driver = tty_driver_kref_get ( console_driver ) ; index = fg_console ; noctty = 1 ; goto got_driver ; } # endif if ( device == MKDEV ( TTYAUX_MAJOR , 1 ) ) { struct tty_driver * console_driver = console_device ( & index ) ; if ( console_driver ) { driver = tty_driver_kref_get ( console_driver ) ; if ( driver ) { filp -> f_flags |= O_NONBLOCK ; noctty = 1 ; goto got_driver ; } } tty_unlock ( ) ; mutex_unlock ( & tty_mutex ) ; return - ENODEV ; } driver = get_tty_driver ( device , & index ) ; if ( ! driver ) { tty_unlock ( ) ; mutex_unlock ( & tty_mutex ) ; return - ENODEV ; } got_driver : if ( ! tty ) { tty = tty_driver_lookup_tty ( driver , inode , index ) ; if ( IS_ERR ( tty ) ) { tty_unlock ( ) ; mutex_unlock ( & tty_mutex ) ; <S2SV_StartBug> return PTR_ERR ( tty ) ; <S2SV_EndBug> } } if ( tty ) { retval = tty_reopen ( tty ) ; if ( retval ) tty = ERR_PTR ( retval ) ; } else tty = tty_init_dev ( driver , index , 0 ) ; mutex_unlock ( & tty_mutex ) ; tty_driver_kref_put ( driver ) ; if ( IS_ERR ( tty ) ) { tty_unlock ( ) ; return PTR_ERR ( tty ) ; } retval = tty_add_file ( tty , filp ) ; if ( retval ) { tty_unlock ( ) ; tty_release ( inode , filp ) ; return retval ; } check_tty_count ( tty , ""tty_open"" ) ; if ( tty -> driver -> type == TTY_DRIVER_TYPE_PTY && tty -> driver -> subtype == PTY_TYPE_MASTER ) noctty = 1 ; # ifdef TTY_DEBUG_HANGUP printk ( KERN_DEBUG ""opening<S2SV_blank>%s..."" , tty -> name ) ; # endif if ( tty -> ops -> open ) retval = tty -> ops -> open ( tty , filp ) ; else retval = - ENODEV ; filp -> f_flags = saved_flags ; if ( ! retval && test_bit ( TTY_EXCLUSIVE , & tty -> flags ) && ! capable ( CAP_SYS_ADMIN ) ) retval = - EBUSY ; if ( retval ) { # ifdef TTY_DEBUG_HANGUP printk ( KERN_DEBUG ""error<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>opening<S2SV_blank>%s..."" , retval , tty -> name ) ; # endif tty_unlock ( ) ; tty_release ( inode , filp ) ; if ( retval != - ERESTARTSYS ) return retval ; if ( signal_pending ( current ) ) return retval ; schedule ( ) ; tty_lock ( ) ; if ( filp -> f_op == & hung_up_tty_fops ) filp -> f_op = & tty_fops ; tty_unlock ( ) ; goto retry_open ; } tty_unlock ( ) ; mutex_lock ( & tty_mutex ) ; tty_lock ( ) ; spin_lock_irq ( & current -> sighand -> siglock ) ; if ( ! noctty && current -> signal -> leader && ! current -> signal -> tty && tty -> session == NULL ) __proc_set_tty ( current , tty ) ; spin_unlock_irq ( & current -> sighand -> siglock ) ; tty_unlock ( ) ; mutex_unlock ( & tty_mutex ) ; return 0 ; }",tty_mutex ) ; tty_driver_kref_put ( driver ) ;
739,"sctp_disposition_t sctp_sf_do_asconf_ack ( struct net * net , const struct sctp_endpoint * ep , const struct sctp_association * asoc , const sctp_subtype_t type , void * arg , sctp_cmd_seq_t * commands ) { struct sctp_chunk * asconf_ack = arg ; struct sctp_chunk * last_asconf = asoc -> addip_last_asconf ; struct sctp_chunk * abort ; struct sctp_paramhdr * err_param = NULL ; sctp_addiphdr_t * addip_hdr ; __u32 sent_serial , rcvd_serial ; if ( ! sctp_vtag_verify ( asconf_ack , asoc ) ) { sctp_add_cmd_sf ( commands , SCTP_CMD_REPORT_BAD_TAG , SCTP_NULL ( ) ) ; return sctp_sf_pdiscard ( net , ep , asoc , type , arg , commands ) ; } if ( ! net -> sctp . addip_noauth && ! asconf_ack -> auth ) return sctp_sf_discard_chunk ( net , ep , asoc , type , arg , commands ) ; if ( ! sctp_chunk_length_valid ( asconf_ack , sizeof ( sctp_addip_chunk_t ) ) ) return sctp_sf_violation_chunklen ( net , ep , asoc , type , arg , commands ) ; addip_hdr = ( sctp_addiphdr_t * ) asconf_ack -> skb -> data ; rcvd_serial = ntohl ( addip_hdr -> serial ) ; if ( ! sctp_verify_asconf ( asoc , <S2SV_StartBug> ( sctp_paramhdr_t * ) addip_hdr -> params , <S2SV_EndBug> ( void * ) asconf_ack -> chunk_end , & err_param ) ) return sctp_sf_violation_paramlen ( net , ep , asoc , type , arg , ( void * ) err_param , commands ) ; if ( last_asconf ) { addip_hdr = ( sctp_addiphdr_t * ) last_asconf -> subh . addip_hdr ; sent_serial = ntohl ( addip_hdr -> serial ) ; } else { sent_serial = asoc -> addip_serial - 1 ; } if ( ADDIP_SERIAL_gte ( rcvd_serial , sent_serial + 1 ) && ! ( asoc -> addip_last_asconf ) ) { abort = sctp_make_abort ( asoc , asconf_ack , sizeof ( sctp_errhdr_t ) ) ; if ( abort ) { sctp_init_cause ( abort , SCTP_ERROR_ASCONF_ACK , 0 ) ; sctp_add_cmd_sf ( commands , SCTP_CMD_REPLY , SCTP_CHUNK ( abort ) ) ; } sctp_add_cmd_sf ( commands , SCTP_CMD_TIMER_STOP , SCTP_TO ( SCTP_EVENT_TIMEOUT_T4_RTO ) ) ; sctp_add_cmd_sf ( commands , SCTP_CMD_DISCARD_PACKET , SCTP_NULL ( ) ) ; sctp_add_cmd_sf ( commands , SCTP_CMD_SET_SK_ERR , SCTP_ERROR ( ECONNABORTED ) ) ; sctp_add_cmd_sf ( commands , SCTP_CMD_ASSOC_FAILED , SCTP_PERR ( SCTP_ERROR_ASCONF_ACK ) ) ; SCTP_INC_STATS ( net , SCTP_MIB_ABORTEDS ) ; SCTP_DEC_STATS ( net , SCTP_MIB_CURRESTAB ) ; return SCTP_DISPOSITION_ABORT ; } if ( ( rcvd_serial == sent_serial ) && asoc -> addip_last_asconf ) { sctp_add_cmd_sf ( commands , SCTP_CMD_TIMER_STOP , SCTP_TO ( SCTP_EVENT_TIMEOUT_T4_RTO ) ) ; if ( ! sctp_process_asconf_ack ( ( struct sctp_association * ) asoc , asconf_ack ) ) { sctp_add_cmd_sf ( commands , SCTP_CMD_SEND_NEXT_ASCONF , SCTP_NULL ( ) ) ; return SCTP_DISPOSITION_CONSUME ; } abort = sctp_make_abort ( asoc , asconf_ack , sizeof ( sctp_errhdr_t ) ) ; if ( abort ) { sctp_init_cause ( abort , SCTP_ERROR_RSRC_LOW , 0 ) ; sctp_add_cmd_sf ( commands , SCTP_CMD_REPLY , SCTP_CHUNK ( abort ) ) ; } sctp_add_cmd_sf ( commands , SCTP_CMD_DISCARD_PACKET , SCTP_NULL ( ) ) ; sctp_add_cmd_sf ( commands , SCTP_CMD_SET_SK_ERR , SCTP_ERROR ( ECONNABORTED ) ) ; sctp_add_cmd_sf ( commands , SCTP_CMD_ASSOC_FAILED , SCTP_PERR ( SCTP_ERROR_ASCONF_ACK ) ) ; SCTP_INC_STATS ( net , SCTP_MIB_ABORTEDS ) ; SCTP_DEC_STATS ( net , SCTP_MIB_CURRESTAB ) ; return SCTP_DISPOSITION_ABORT ; } return SCTP_DISPOSITION_DISCARD ; }","( asoc , asconf_ack , false , <S2SV_ModEnd> & err_param )"
740,"void queue_push ( register Queue * qp , size_t extra_length , char const * info ) { register char * cp ; size_t memory_length ; size_t available_length ; size_t begin_length ; size_t n_begin ; size_t q_length ; if ( ! extra_length ) return ; memory_length = qp -> d_memory_end - qp -> d_memory ; q_length = qp -> d_read <= qp -> d_write ? ( size_t ) ( qp -> d_write - qp -> d_read ) : memory_length - ( qp -> d_read - qp -> d_write ) ; available_length = memory_length - q_length - 1 ; if ( message_show ( MSG_INFO ) ) message ( ""push_front<S2SV_blank>%u<S2SV_blank>bytes<S2SV_blank>in<S2SV_blank>`%s\'"" , ( unsigned ) extra_length , info ) ; if ( extra_length > available_length ) { <S2SV_StartBug> memory_length += extra_length - available_length + BLOCK_QUEUE ; <S2SV_EndBug> cp = new_memory ( memory_length , sizeof ( char ) ) ; if ( message_show ( MSG_INFO ) ) message ( ""Reallocating<S2SV_blank>queue<S2SV_blank>at<S2SV_blank>%p<S2SV_blank>to<S2SV_blank>%p"" , qp -> d_memory , cp ) ; if ( qp -> d_read > qp -> d_write ) { size_t tail_len = qp -> d_memory_end - qp -> d_read ; memcpy ( cp , qp -> d_read , tail_len ) ; memcpy ( cp + tail_len , qp -> d_memory , ( size_t ) ( qp -> d_write - qp -> d_memory ) ) ; qp -> d_write = cp + q_length ; qp -> d_read = cp ; } else { <S2SV_StartBug> memcpy ( cp , qp -> d_memory , memory_length ) ; <S2SV_EndBug> qp -> d_read = cp + ( qp -> d_read - qp -> d_memory ) ; qp -> d_write = cp + ( qp -> d_write - qp -> d_memory ) ; } free ( qp -> d_memory ) ; qp -> d_memory_end = cp + memory_length ; qp -> d_memory = cp ; } begin_length = qp -> d_read - qp -> d_memory ; n_begin = extra_length <= begin_length ? extra_length : begin_length ; memcpy ( qp -> d_read -= n_begin , info + extra_length - n_begin , n_begin ) ; if ( extra_length > begin_length ) { extra_length -= begin_length ; memcpy ( qp -> d_read = qp -> d_memory_end - extra_length , info , extra_length ) ; } }","available_length ) { size_t original_length = memory_length ; <S2SV_ModStart> -> d_memory , original_length <S2SV_ModEnd> ) ; qp"
741,"static ssize_t __nfs4_get_acl_uncached ( struct inode * inode , void * buf , size_t buflen ) { struct page * pages [ NFS4ACL_MAXPAGES ] = { NULL , } ; struct nfs_getaclargs args = { . fh = NFS_FH ( inode ) , . acl_pages = pages , . acl_len = buflen , } ; struct nfs_getaclres res = { . acl_len = buflen , } ; void * resp_buf ; struct rpc_message msg = { . rpc_proc = & nfs4_procedures [ NFSPROC4_CLNT_GETACL ] , . rpc_argp = & args , . rpc_resp = & res , } ; int ret = - ENOMEM , npages , i , acl_len = 0 ; npages = ( buflen + PAGE_SIZE - 1 ) >> PAGE_SHIFT ; if ( npages == 0 ) npages = 1 ; for ( i = 0 ; i < npages ; i ++ ) { pages [ i ] = alloc_page ( GFP_KERNEL ) ; if ( ! pages [ i ] ) goto out_free ; } if ( npages > 1 ) { res . acl_scratch = alloc_page ( GFP_KERNEL ) ; if ( ! res . acl_scratch ) goto out_free ; } args . acl_len = npages * PAGE_SIZE ; args . acl_pgbase = 0 ; if ( buf == NULL ) res . acl_flags |= NFS4_ACL_LEN_REQUEST ; resp_buf = page_address ( pages [ 0 ] ) ; dprintk ( ""%s<S2SV_blank><S2SV_blank>buf<S2SV_blank>%p<S2SV_blank>buflen<S2SV_blank>%zu<S2SV_blank>npages<S2SV_blank>%d<S2SV_blank>args.acl_len<S2SV_blank>%zu\\n"" , __func__ , buf , buflen , npages , args . acl_len ) ; ret = nfs4_call_sync ( NFS_SERVER ( inode ) -> client , NFS_SERVER ( inode ) , & msg , & args . seq_args , & res . seq_res , 0 ) ; if ( ret ) goto out_free ; acl_len = res . acl_len - res . acl_data_offset ; if ( acl_len > args . acl_len ) nfs4_write_cached_acl ( inode , NULL , acl_len ) ; else nfs4_write_cached_acl ( inode , resp_buf + res . acl_data_offset , acl_len ) ; if ( buf ) { ret = - ERANGE ; if ( acl_len > buflen ) goto out_free ; _copy_from_pages ( buf , pages , res . acl_data_offset , <S2SV_StartBug> res . acl_len ) ; <S2SV_EndBug> } ret = acl_len ; out_free : for ( i = 0 ; i < npages ; i ++ ) if ( pages [ i ] ) __free_page ( pages [ i ] ) ; if ( res . acl_scratch ) __free_page ( res . acl_scratch ) ; return ret ; }",". acl_data_offset , <S2SV_ModEnd> acl_len ) ;"
742,"static MagickBooleanType ReadDXT5 ( Image * image , DDSInfo * dds_info , ExceptionInfo * exception ) { DDSColors colors ; ssize_t j , y ; MagickSizeType alpha_bits ; PixelPacket * q ; register ssize_t i , x ; unsigned char a0 , a1 ; size_t alpha , bits , code , alpha_code ; unsigned short c0 , c1 ; for ( y = 0 ; y < ( ssize_t ) dds_info -> height ; y += 4 ) { for ( x = 0 ; x < ( ssize_t ) dds_info -> width ; x += 4 ) { <S2SV_StartBug> q = QueueAuthenticPixels ( image , x , y , Min ( 4 , dds_info -> width - x ) , <S2SV_EndBug> <S2SV_StartBug> Min ( 4 , dds_info -> height - y ) , exception ) ; <S2SV_EndBug> if ( q == ( PixelPacket * ) NULL ) return MagickFalse ; a0 = ( unsigned char ) ReadBlobByte ( image ) ; a1 = ( unsigned char ) ReadBlobByte ( image ) ; alpha_bits = ( MagickSizeType ) ReadBlobLSBLong ( image ) ; alpha_bits = alpha_bits | ( ( MagickSizeType ) ReadBlobLSBShort ( image ) << 32 ) ; c0 = ReadBlobLSBShort ( image ) ; c1 = ReadBlobLSBShort ( image ) ; bits = ReadBlobLSBLong ( image ) ; CalculateColors ( c0 , c1 , & colors , MagickTrue ) ; for ( j = 0 ; j < 4 ; j ++ ) { for ( i = 0 ; i < 4 ; i ++ ) { if ( ( x + i ) < ( ssize_t ) dds_info -> width && ( y + j ) < ( ssize_t ) dds_info -> height ) { code = ( bits >> ( ( 4 * j + i ) * 2 ) ) & 0x3 ; SetPixelRed ( q , ScaleCharToQuantum ( colors . r [ code ] ) ) ; SetPixelGreen ( q , ScaleCharToQuantum ( colors . g [ code ] ) ) ; SetPixelBlue ( q , ScaleCharToQuantum ( colors . b [ code ] ) ) ; alpha_code = ( size_t ) ( alpha_bits >> ( 3 * ( 4 * j + i ) ) ) & 0x7 ; if ( alpha_code == 0 ) alpha = a0 ; else if ( alpha_code == 1 ) alpha = a1 ; else if ( a0 > a1 ) alpha = ( ( 8 - alpha_code ) * a0 + ( alpha_code - 1 ) * a1 ) / 7 ; else if ( alpha_code == 6 ) alpha = 0 ; else if ( alpha_code == 7 ) alpha = 255 ; else alpha = ( ( ( 6 - alpha_code ) * a0 + ( alpha_code - 1 ) * a1 ) / 5 ) ; SetPixelAlpha ( q , ScaleCharToQuantum ( ( unsigned char ) alpha ) ) ; q ++ ; } } } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) return MagickFalse ; } } <S2SV_StartBug> SkipDXTMipmaps ( image , dds_info , 16 ) ; <S2SV_EndBug> return MagickTrue ; }",", y , MagickMin <S2SV_ModEnd> ( 4 , <S2SV_ModStart> x ) , MagickMin <S2SV_ModEnd> ( 4 , <S2SV_ModStart> ; } } return ( <S2SV_ModStart> dds_info , 16 , exception ) ) <S2SV_ModEnd> ; } <S2SV_null>"
743,"int ipc_addid ( struct ipc_ids * ids , struct kern_ipc_perm * new , int size ) { kuid_t euid ; kgid_t egid ; int id ; int next_id = ids -> next_id ; if ( size > IPCMNI ) size = IPCMNI ; if ( ids -> in_use >= size ) return - ENOSPC ; idr_preload ( GFP_KERNEL ) ; spin_lock_init ( & new -> lock ) ; new -> deleted = false ; rcu_read_lock ( ) ; spin_lock ( & new -> lock ) ; <S2SV_StartBug> id = idr_alloc ( & ids -> ipcs_idr , new , <S2SV_EndBug> ( next_id < 0 ) ? 0 : ipcid_to_idx ( next_id ) , 0 , GFP_NOWAIT ) ; idr_preload_end ( ) ; if ( id < 0 ) { spin_unlock ( & new -> lock ) ; rcu_read_unlock ( ) ; return id ; } ids -> in_use ++ ; <S2SV_StartBug> current_euid_egid ( & euid , & egid ) ; <S2SV_EndBug> new -> cuid = new -> uid = euid ; new -> gid = new -> cgid = egid ; if ( next_id < 0 ) { new -> seq = ids -> seq ++ ; if ( ids -> seq > IPCID_SEQ_MAX ) ids -> seq = 0 ; } else { new -> seq = ipcid_to_seqx ( next_id ) ; ids -> next_id = - 1 ; } new -> id = ipc_buildid ( id , new -> seq ) ; return id ; }","lock ) ; current_euid_egid ( & euid , & egid ) ; new -> cuid = new -> uid = euid ; new -> gid = new -> cgid = egid ; <S2SV_ModStart> in_use ++ ; <S2SV_ModEnd> if ( next_id"
744,"int snmp_helper ( void * context , size_t hdrlen , unsigned char tag , const void * data , size_t datalen ) { struct snmp_ctx * ctx = ( struct snmp_ctx * ) context ; <S2SV_StartBug> __be32 * pdata = ( __be32 * ) data ; <S2SV_EndBug> if ( * pdata == ctx -> from ) { pr_debug ( ""%s:<S2SV_blank>%pI4<S2SV_blank>to<S2SV_blank>%pI4\\n"" , __func__ , ( void * ) & ctx -> from , ( void * ) & ctx -> to ) ; if ( * ctx -> check ) fast_csum ( ctx , ( unsigned char * ) data - ctx -> begin ) ; * pdata = ctx -> to ; } return 1 ; }",; __be32 * pdata ; if ( datalen != 4 ) return - EINVAL ;
745,"static void dma_rx ( struct b43_dmaring * ring , int * slot ) { const struct b43_dma_ops * ops = ring -> ops ; struct b43_dmadesc_generic * desc ; struct b43_dmadesc_meta * meta ; struct b43_rxhdr_fw4 * rxhdr ; struct sk_buff * skb ; u16 len ; int err ; dma_addr_t dmaaddr ; desc = ops -> idx2desc ( ring , * slot , & meta ) ; sync_descbuffer_for_cpu ( ring , meta -> dmaaddr , ring -> rx_buffersize ) ; skb = meta -> skb ; rxhdr = ( struct b43_rxhdr_fw4 * ) skb -> data ; len = le16_to_cpu ( rxhdr -> frame_len ) ; if ( len == 0 ) { int i = 0 ; do { udelay ( 2 ) ; barrier ( ) ; len = le16_to_cpu ( rxhdr -> frame_len ) ; } while ( len == 0 && i ++ < 5 ) ; if ( unlikely ( len == 0 ) ) { dmaaddr = meta -> dmaaddr ; goto drop_recycle_buffer ; } } if ( unlikely ( b43_rx_buffer_is_poisoned ( ring , skb ) ) ) { b43dbg ( ring -> dev -> wl , ""DMA<S2SV_blank>RX:<S2SV_blank>Dropping<S2SV_blank>poisoned<S2SV_blank>buffer.\\n"" ) ; dmaaddr = meta -> dmaaddr ; goto drop_recycle_buffer ; } <S2SV_StartBug> if ( unlikely ( len > ring -> rx_buffersize ) ) { <S2SV_EndBug> int cnt = 0 ; s32 tmp = len ; while ( 1 ) { desc = ops -> idx2desc ( ring , * slot , & meta ) ; b43_poison_rx_buffer ( ring , meta -> skb ) ; sync_descbuffer_for_device ( ring , meta -> dmaaddr , ring -> rx_buffersize ) ; * slot = next_slot ( ring , * slot ) ; cnt ++ ; tmp -= ring -> rx_buffersize ; if ( tmp <= 0 ) break ; } b43err ( ring -> dev -> wl , ""DMA<S2SV_blank>RX<S2SV_blank>buffer<S2SV_blank>too<S2SV_blank>small<S2SV_blank>"" ""(len:<S2SV_blank>%u,<S2SV_blank>buffer:<S2SV_blank>%u,<S2SV_blank>nr-dropped:<S2SV_blank>%d)\\n"" , len , ring -> rx_buffersize , cnt ) ; goto drop ; } dmaaddr = meta -> dmaaddr ; err = setup_rx_descbuffer ( ring , desc , meta , GFP_ATOMIC ) ; if ( unlikely ( err ) ) { b43dbg ( ring -> dev -> wl , ""DMA<S2SV_blank>RX:<S2SV_blank>setup_rx_descbuffer()<S2SV_blank>failed\\n"" ) ; goto drop_recycle_buffer ; } unmap_descbuffer ( ring , dmaaddr , ring -> rx_buffersize , 0 ) ; skb_put ( skb , len + ring -> frameoffset ) ; skb_pull ( skb , ring -> frameoffset ) ; b43_rx ( ring -> dev , skb , rxhdr ) ; drop : return ; drop_recycle_buffer : b43_poison_rx_buffer ( ring , skb ) ; sync_descbuffer_for_device ( ring , dmaaddr , ring -> rx_buffersize ) ; }",unlikely ( len + ring -> frameoffset
746,"int module_load ( YR_SCAN_CONTEXT * context , YR_OBJECT * module_object , void * module_data , size_t module_data_size ) { set_integer ( 1 , module_object , ""constants.one"" ) ; set_integer ( 2 , module_object , ""constants.two"" ) ; set_string ( ""foo"" , module_object , ""constants.foo"" ) ; set_string ( """" , module_object , ""constants.empty"" ) ; set_integer ( 1 , module_object , ""struct_array[1].i"" ) ; set_integer ( 0 , module_object , ""integer_array[%i]"" , 0 ) ; set_integer ( 1 , module_object , ""integer_array[%i]"" , 1 ) ; set_integer ( 2 , module_object , ""integer_array[%i]"" , 2 ) ; <S2SV_StartBug> set_string ( ""foo"" , module_object , ""string_array[%i]"" , 0 ) ; <S2SV_EndBug> set_string ( ""bar"" , module_object , ""string_array[%i]"" , 1 ) ; set_string ( ""baz"" , module_object , ""string_array[%i]"" , 2 ) ; set_sized_string ( ""foo\\0bar"" , 7 , module_object , ""string_array[%i]"" , 3 ) ; set_string ( ""foo"" , module_object , ""string_dict[%s]"" , ""foo"" ) ; set_string ( ""bar"" , module_object , ""string_dict[\\""bar\\""]"" ) ; set_string ( ""foo"" , module_object , ""struct_dict[%s].s"" , ""foo"" ) ; set_integer ( 1 , module_object , ""struct_dict[%s].i"" , ""foo"" ) ; return ERROR_SUCCESS ; }","2 ) ; set_integer ( 256 , module_object , ""integer_array[%i]"" , 256 ) ;"
747,"static void perf_event_for_each ( struct perf_event * event , void ( * func ) ( struct perf_event * ) ) { struct perf_event_context * ctx = event -> ctx ; struct perf_event * sibling ; <S2SV_StartBug> WARN_ON_ONCE ( ctx -> parent_ctx ) ; <S2SV_EndBug> mutex_lock ( & ctx -> mutex ) ; event = event -> group_leader ; perf_event_for_each_child ( event , func ) ; list_for_each_entry ( sibling , & event -> sibling_list , group_entry ) perf_event_for_each_child ( sibling , func ) ; <S2SV_StartBug> mutex_unlock ( & ctx -> mutex ) ; <S2SV_EndBug> }",* sibling ; lockdep_assert_held <S2SV_ModEnd> ( & ctx <S2SV_ModStart> func ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
748,"void qedi_dbg_warn ( struct qedi_dbg_ctx * qedi , const char * func , u32 line , const char * fmt , ... ) { va_list va ; <S2SV_StartBug> struct va_format vaf ; <S2SV_EndBug> char nfunc [ 32 ] ; memset ( nfunc , 0 , sizeof ( nfunc ) ) ; memcpy ( nfunc , func , sizeof ( nfunc ) - 1 ) ; va_start ( va , fmt ) ; vaf . fmt = fmt ; vaf . va = & va ; if ( ! ( qedi_dbg_log & QEDI_LOG_WARN ) ) goto ret ; if ( likely ( qedi ) && likely ( qedi -> pdev ) ) pr_warn ( ""[%s]:[%s:%d]:%d:<S2SV_blank>%pV"" , dev_name ( & qedi -> pdev -> dev ) , <S2SV_StartBug> nfunc , line , qedi -> host_no , & vaf ) ; <S2SV_EndBug> else <S2SV_StartBug> pr_warn ( ""[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV"" , nfunc , line , & vaf ) ; <S2SV_EndBug> ret : va_end ( va ) ; }","struct va_format vaf <S2SV_ModEnd> ; va_start ( <S2SV_ModStart> dev ) , func <S2SV_ModEnd> , line , <S2SV_ModStart> ( ""[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV"" , func <S2SV_ModEnd> , line ,"
749,"static MagickBooleanType load_tile ( Image * image , Image * tile_image , XCFDocInfo * inDocInfo , XCFLayerInfo * inLayerInfo , size_t data_length , ExceptionInfo * exception ) { ssize_t y ; register ssize_t x ; register Quantum * q ; ssize_t count ; unsigned char * graydata ; XCFPixelInfo * xcfdata , * xcfodata ; <S2SV_StartBug> xcfdata = ( XCFPixelInfo * ) AcquireQuantumMemory ( data_length , sizeof ( * xcfdata ) ) ; <S2SV_EndBug> if ( xcfdata == ( XCFPixelInfo * ) NULL ) ThrowBinaryException ( ResourceLimitError , ""MemoryAllocationFailed"" , image -> filename ) ; xcfodata = xcfdata ; graydata = ( unsigned char * ) xcfdata ; count = ReadBlob ( image , data_length , ( unsigned char * ) xcfdata ) ; if ( count != ( ssize_t ) data_length ) ThrowBinaryException ( CorruptImageError , ""NotEnoughPixelData"" , image -> filename ) ; for ( y = 0 ; y < ( ssize_t ) tile_image -> rows ; y ++ ) { q = GetAuthenticPixels ( tile_image , 0 , y , tile_image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; if ( inDocInfo -> image_type == GIMP_GRAY ) { for ( x = 0 ; x < ( ssize_t ) tile_image -> columns ; x ++ ) { SetPixelGray ( tile_image , ScaleCharToQuantum ( * graydata ) , q ) ; SetPixelAlpha ( tile_image , ScaleCharToQuantum ( ( unsigned char ) inLayerInfo -> alpha ) , q ) ; graydata ++ ; q += GetPixelChannels ( tile_image ) ; } } else if ( inDocInfo -> image_type == GIMP_RGB ) { for ( x = 0 ; x < ( ssize_t ) tile_image -> columns ; x ++ ) { SetPixelRed ( tile_image , ScaleCharToQuantum ( xcfdata -> red ) , q ) ; SetPixelGreen ( tile_image , ScaleCharToQuantum ( xcfdata -> green ) , q ) ; SetPixelBlue ( tile_image , ScaleCharToQuantum ( xcfdata -> blue ) , q ) ; SetPixelAlpha ( tile_image , xcfdata -> alpha == 255U ? TransparentAlpha : ScaleCharToQuantum ( ( unsigned char ) inLayerInfo -> alpha ) , q ) ; xcfdata ++ ; q += GetPixelChannels ( tile_image ) ; } } if ( SyncAuthenticPixels ( tile_image , exception ) == MagickFalse ) break ; } xcfodata = ( XCFPixelInfo * ) RelinquishMagickMemory ( xcfodata ) ; return MagickTrue ; }",") AcquireQuantumMemory ( MagickMax ( data_length , tile_image -> columns * tile_image -> rows ) <S2SV_ModEnd> , sizeof ("
750,"static int userauth_pubkey ( struct ssh * ssh ) { Authctxt * authctxt = ssh -> authctxt ; struct passwd * pw = authctxt -> pw ; <S2SV_StartBug> struct sshbuf * b ; <S2SV_EndBug> struct sshkey * key = NULL ; <S2SV_StartBug> char * pkalg , * userstyle = NULL , * key_s = NULL , * ca_s = NULL ; <S2SV_EndBug> <S2SV_StartBug> u_char * pkblob , * sig , have_sig ; <S2SV_EndBug> size_t blen , slen ; int r , pktype ; int authenticated = 0 ; struct sshauthopt * authopts = NULL ; <S2SV_StartBug> if ( ! authctxt -> valid ) { <S2SV_EndBug> debug2 ( ""%s:<S2SV_blank>disabled<S2SV_blank>because<S2SV_blank>of<S2SV_blank>invalid<S2SV_blank>user"" , __func__ ) ; return 0 ; } if ( ( r = sshpkt_get_u8 ( ssh , & have_sig ) ) != 0 || ( r = sshpkt_get_cstring ( ssh , & pkalg , NULL ) ) != 0 || ( r = sshpkt_get_string ( ssh , & pkblob , & blen ) ) != 0 ) fatal ( ""%s:<S2SV_blank>parse<S2SV_blank>request<S2SV_blank>failed:<S2SV_blank>%s"" , __func__ , ssh_err ( r ) ) ; pktype = sshkey_type_from_name ( pkalg ) ; if ( pktype == KEY_UNSPEC ) { verbose ( ""%s:<S2SV_blank>unsupported<S2SV_blank>public<S2SV_blank>key<S2SV_blank>algorithm:<S2SV_blank>%s"" , __func__ , pkalg ) ; goto done ; } if ( ( r = sshkey_from_blob ( pkblob , blen , & key ) ) != 0 ) { error ( ""%s:<S2SV_blank>could<S2SV_blank>not<S2SV_blank>parse<S2SV_blank>key:<S2SV_blank>%s"" , __func__ , ssh_err ( r ) ) ; goto done ; } if ( key == NULL ) { error ( ""%s:<S2SV_blank>cannot<S2SV_blank>decode<S2SV_blank>key:<S2SV_blank>%s"" , __func__ , pkalg ) ; goto done ; } if ( key -> type != pktype ) { error ( ""%s:<S2SV_blank>type<S2SV_blank>mismatch<S2SV_blank>for<S2SV_blank>decoded<S2SV_blank>key<S2SV_blank>"" ""(received<S2SV_blank>%d,<S2SV_blank>expected<S2SV_blank>%d)"" , __func__ , key -> type , pktype ) ; goto done ; } if ( sshkey_type_plain ( key -> type ) == KEY_RSA && ( ssh -> compat & SSH_BUG_RSASIGMD5 ) != 0 ) { logit ( ""Refusing<S2SV_blank>RSA<S2SV_blank>key<S2SV_blank>because<S2SV_blank>client<S2SV_blank>uses<S2SV_blank>unsafe<S2SV_blank>"" ""signature<S2SV_blank>scheme"" ) ; goto done ; } if ( auth2_key_already_used ( authctxt , key ) ) { logit ( ""refusing<S2SV_blank>previously-used<S2SV_blank>%s<S2SV_blank>key"" , sshkey_type ( key ) ) ; goto done ; } if ( match_pattern_list ( pkalg , options . pubkey_key_types , 0 ) != 1 ) { logit ( ""%s:<S2SV_blank>key<S2SV_blank>type<S2SV_blank>%s<S2SV_blank>not<S2SV_blank>in<S2SV_blank>PubkeyAcceptedKeyTypes"" , __func__ , sshkey_ssh_name ( key ) ) ; goto done ; } key_s = format_key ( key ) ; if ( sshkey_is_cert ( key ) ) ca_s = format_key ( key -> cert -> signature_key ) ; if ( have_sig ) { debug3 ( ""%s:<S2SV_blank>have<S2SV_blank>%s<S2SV_blank>signature<S2SV_blank>for<S2SV_blank>%s%s%s"" , __func__ , pkalg , key_s , ca_s == NULL ? """" : ""<S2SV_blank>CA<S2SV_blank>"" , ca_s == NULL ? """" : ca_s ) ; if ( ( r = sshpkt_get_string ( ssh , & sig , & slen ) ) != 0 || ( r = sshpkt_get_end ( ssh ) ) != 0 ) fatal ( ""%s:<S2SV_blank>%s"" , __func__ , ssh_err ( r ) ) ; if ( ( b = sshbuf_new ( ) ) == NULL ) fatal ( ""%s:<S2SV_blank>sshbuf_new<S2SV_blank>failed"" , __func__ ) ; if ( ssh -> compat & SSH_OLD_SESSIONID ) { if ( ( r = sshbuf_put ( b , session_id2 , session_id2_len ) ) != 0 ) fatal ( ""%s:<S2SV_blank>sshbuf_put<S2SV_blank>session<S2SV_blank>id:<S2SV_blank>%s"" , __func__ , ssh_err ( r ) ) ; } else { if ( ( r = sshbuf_put_string ( b , session_id2 , session_id2_len ) ) != 0 ) fatal ( ""%s:<S2SV_blank>sshbuf_put_string<S2SV_blank>session<S2SV_blank>id:<S2SV_blank>%s"" , <S2SV_StartBug> __func__ , ssh_err ( r ) ) ; <S2SV_EndBug> } xasprintf ( & userstyle , ""%s%s%s"" , authctxt -> user , authctxt -> style ? "":"" : """" , authctxt -> style ? authctxt -> style : """" ) ; if ( ( r = sshbuf_put_u8 ( b , SSH2_MSG_USERAUTH_REQUEST ) ) != 0 || ( r = sshbuf_put_cstring ( b , userstyle ) ) != 0 || ( r = sshbuf_put_cstring ( b , authctxt -> service ) ) != 0 || ( r = sshbuf_put_cstring ( b , ""publickey"" ) ) != 0 || ( r = sshbuf_put_u8 ( b , have_sig ) ) != 0 || ( r = sshbuf_put_cstring ( b , pkalg ) != 0 ) || ( r = sshbuf_put_string ( b , pkblob , blen ) ) != 0 ) fatal ( ""%s:<S2SV_blank>build<S2SV_blank>packet<S2SV_blank>failed:<S2SV_blank>%s"" , __func__ , ssh_err ( r ) ) ; # ifdef DEBUG_PK sshbuf_dump ( b , stderr ) ; # endif authenticated = 0 ; if ( PRIVSEP ( user_key_allowed ( ssh , pw , key , 1 , & authopts ) ) && PRIVSEP ( sshkey_verify ( key , sig , slen , sshbuf_ptr ( b ) , sshbuf_len ( b ) , ( ssh -> compat & SSH_BUG_SIGTYPE ) == 0 ? pkalg : NULL , ssh -> compat ) ) == 0 ) { authenticated = 1 ; } sshbuf_free ( b ) ; <S2SV_StartBug> free ( sig ) ; <S2SV_EndBug> auth2_record_key ( authctxt , authenticated , key ) ; } else { debug ( ""%s:<S2SV_blank>test<S2SV_blank>pkalg<S2SV_blank>%s<S2SV_blank>pkblob<S2SV_blank>%s%s%s"" , __func__ , pkalg , key_s , ca_s == NULL ? """" : ""<S2SV_blank>CA<S2SV_blank>"" , ca_s == NULL ? """" : ca_s ) ; if ( ( r = sshpkt_get_end ( ssh ) ) != 0 ) <S2SV_StartBug> fatal ( ""%s:<S2SV_blank>%s"" , __func__ , ssh_err ( r ) ) ; <S2SV_EndBug> if ( PRIVSEP ( user_key_allowed ( ssh , pw , key , 0 , NULL ) ) ) { if ( ( r = sshpkt_start ( ssh , SSH2_MSG_USERAUTH_PK_OK ) ) != 0 || ( r = sshpkt_put_cstring ( ssh , pkalg ) ) != 0 || ( r = sshpkt_put_string ( ssh , pkblob , blen ) ) != 0 || ( r = sshpkt_send ( ssh ) ) != 0 || ( r = ssh_packet_write_wait ( ssh ) ) != 0 ) fatal ( ""%s:<S2SV_blank>%s"" , __func__ , ssh_err ( r ) ) ; authctxt -> postponed = 1 ; } } done : if ( authenticated == 1 && auth_activate_options ( ssh , authopts ) != 0 ) { debug ( ""%s:<S2SV_blank>key<S2SV_blank>options<S2SV_blank>inconsistent<S2SV_blank>with<S2SV_blank>existing"" , __func__ ) ; authenticated = 0 ; } debug2 ( ""%s:<S2SV_blank>authenticated<S2SV_blank>%d<S2SV_blank>pkalg<S2SV_blank>%s"" , __func__ , authenticated , pkalg ) ; sshauthopt_free ( authopts ) ; sshkey_free ( key ) ; free ( userstyle ) ; free ( pkalg ) ; free ( pkblob ) ; free ( key_s ) ; free ( ca_s ) ; <S2SV_StartBug> return authenticated ; <S2SV_EndBug> }","sshbuf * b = NULL <S2SV_ModStart> char * pkalg = NULL <S2SV_ModStart> u_char * pkblob = NULL <S2SV_ModStart> , * sig = NULL <S2SV_ModStart> ; if ( <S2SV_ModEnd> ( r = <S2SV_ModStart> r ) ) ; } if ( ! authctxt -> valid || authctxt -> user == NULL ) { debug2 ( ""%s:<S2SV_blank>disabled<S2SV_blank>because<S2SV_blank>of<S2SV_blank>invalid<S2SV_blank>user"" , __func__ ) ; goto done <S2SV_ModStart> b ) ; <S2SV_ModEnd> auth2_record_key ( authctxt <S2SV_ModStart> ) ) ; if ( ! authctxt -> valid || authctxt -> user == NULL ) { debug2 ( ""%s:<S2SV_blank>disabled<S2SV_blank>because<S2SV_blank>of<S2SV_blank>invalid<S2SV_blank>user"" , __func__ ) ; goto done ; } <S2SV_ModStart> ca_s ) ; free ( sig ) ;"
751,"static void renameTableFunc ( sqlite3_context * context , int NotUsed , sqlite3_value * * argv ) { sqlite3 * db = sqlite3_context_db_handle ( context ) ; const char * zDb = ( const char * ) sqlite3_value_text ( argv [ 0 ] ) ; const char * zInput = ( const char * ) sqlite3_value_text ( argv [ 3 ] ) ; const char * zOld = ( const char * ) sqlite3_value_text ( argv [ 4 ] ) ; const char * zNew = ( const char * ) sqlite3_value_text ( argv [ 5 ] ) ; int bTemp = sqlite3_value_int ( argv [ 6 ] ) ; UNUSED_PARAMETER ( NotUsed ) ; if ( zInput && zOld && zNew ) { Parse sParse ; int rc ; int bQuote = 1 ; RenameCtx sCtx ; Walker sWalker ; # ifndef SQLITE_OMIT_AUTHORIZATION sqlite3_xauth xAuth = db -> xAuth ; db -> xAuth = 0 ; # endif sqlite3BtreeEnterAll ( db ) ; memset ( & sCtx , 0 , sizeof ( RenameCtx ) ) ; sCtx . pTab = sqlite3FindTable ( db , zOld , zDb ) ; memset ( & sWalker , 0 , sizeof ( Walker ) ) ; sWalker . pParse = & sParse ; sWalker . xExprCallback = renameTableExprCb ; sWalker . xSelectCallback = renameTableSelectCb ; sWalker . u . pRename = & sCtx ; rc = renameParseSql ( & sParse , zDb , 1 , db , zInput , bTemp ) ; if ( rc == SQLITE_OK ) { int isLegacy = ( db -> flags & SQLITE_LegacyAlter ) ; if ( sParse . pNewTable ) { Table * pTab = sParse . pNewTable ; if ( pTab -> pSelect ) { if ( isLegacy == 0 ) { <S2SV_StartBug> NameContext sNC ; <S2SV_EndBug> memset ( & sNC , 0 , sizeof ( sNC ) ) ; <S2SV_StartBug> sNC . pParse = & sParse ; <S2SV_EndBug> sqlite3SelectPrep ( & sParse , pTab -> pSelect , & sNC ) ; if ( sParse . nErr ) rc = sParse . rc ; sqlite3WalkSelect ( & sWalker , pTab -> pSelect ) ; } } else { # ifndef SQLITE_OMIT_FOREIGN_KEY if ( isLegacy == 0 || ( db -> flags & SQLITE_ForeignKeys ) ) { FKey * pFKey ; for ( pFKey = pTab -> pFKey ; pFKey ; pFKey = pFKey -> pNextFrom ) { if ( sqlite3_stricmp ( pFKey -> zTo , zOld ) == 0 ) { renameTokenFind ( & sParse , & sCtx , ( void * ) pFKey -> zTo ) ; } } } # endif if ( sqlite3_stricmp ( zOld , pTab -> zName ) == 0 ) { sCtx . pTab = pTab ; if ( isLegacy == 0 ) { sqlite3WalkExprList ( & sWalker , pTab -> pCheck ) ; } renameTokenFind ( & sParse , & sCtx , pTab -> zName ) ; } } } else if ( sParse . pNewIndex ) { renameTokenFind ( & sParse , & sCtx , sParse . pNewIndex -> zName ) ; if ( isLegacy == 0 ) { sqlite3WalkExpr ( & sWalker , sParse . pNewIndex -> pPartIdxWhere ) ; } } # ifndef SQLITE_OMIT_TRIGGER else { Trigger * pTrigger = sParse . pNewTrigger ; TriggerStep * pStep ; if ( 0 == sqlite3_stricmp ( sParse . pNewTrigger -> table , zOld ) && sCtx . pTab -> pSchema == pTrigger -> pTabSchema ) { renameTokenFind ( & sParse , & sCtx , sParse . pNewTrigger -> table ) ; } if ( isLegacy == 0 ) { rc = renameResolveTrigger ( & sParse , bTemp ? 0 : zDb ) ; if ( rc == SQLITE_OK ) { renameWalkTrigger ( & sWalker , pTrigger ) ; for ( pStep = pTrigger -> step_list ; pStep ; pStep = pStep -> pNext ) { if ( pStep -> zTarget && 0 == sqlite3_stricmp ( pStep -> zTarget , zOld ) ) { renameTokenFind ( & sParse , & sCtx , pStep -> zTarget ) ; } } } } } # endif } if ( rc == SQLITE_OK ) { rc = renameEditSql ( context , & sCtx , zInput , zNew , bQuote ) ; } if ( rc != SQLITE_OK ) { if ( sParse . zErrMsg ) { renameColumnParseError ( context , 0 , argv [ 1 ] , argv [ 2 ] , & sParse ) ; } else { sqlite3_result_error_code ( context , rc ) ; } } renameParseCleanup ( & sParse ) ; renameTokenFree ( db , sCtx . pList ) ; sqlite3BtreeLeaveAll ( db ) ; # ifndef SQLITE_OMIT_AUTHORIZATION db -> xAuth = xAuth ; # endif } return ; }",0 ) { Select * pSelect = pTab -> pSelect ; <S2SV_ModStart> = & sParse ; assert ( pSelect -> selFlags & SF_View ) ; pSelect -> selFlags &= ~ SF_View
752,"STATIC int xfs_attr_node_addname ( xfs_da_args_t * args ) { xfs_da_state_t * state ; xfs_da_state_blk_t * blk ; xfs_inode_t * dp ; xfs_mount_t * mp ; int committed , retval , error ; trace_xfs_attr_node_addname ( args ) ; dp = args -> dp ; mp = dp -> i_mount ; restart : state = xfs_da_state_alloc ( ) ; state -> args = args ; state -> mp = mp ; state -> blocksize = state -> mp -> m_sb . sb_blocksize ; state -> node_ents = state -> mp -> m_attr_node_ents ; error = xfs_da3_node_lookup_int ( state , & retval ) ; if ( error ) goto out ; blk = & state -> path . blk [ state -> path . active - 1 ] ; ASSERT ( blk -> magic == XFS_ATTR_LEAF_MAGIC ) ; if ( ( args -> flags & ATTR_REPLACE ) && ( retval == ENOATTR ) ) { goto out ; } else if ( retval == EEXIST ) { if ( args -> flags & ATTR_CREATE ) goto out ; trace_xfs_attr_node_replace ( args ) ; args -> op_flags |= XFS_DA_OP_RENAME ; args -> blkno2 = args -> blkno ; args -> index2 = args -> index ; args -> rmtblkno2 = args -> rmtblkno ; args -> rmtblkcnt2 = args -> rmtblkcnt ; <S2SV_StartBug> args -> rmtblkno = 0 ; <S2SV_EndBug> <S2SV_StartBug> args -> rmtblkcnt = 0 ; <S2SV_EndBug> } retval = xfs_attr3_leaf_add ( blk -> bp , state -> args ) ; if ( retval == ENOSPC ) { if ( state -> path . active == 1 ) { xfs_da_state_free ( state ) ; state = NULL ; xfs_bmap_init ( args -> flist , args -> firstblock ) ; error = xfs_attr3_leaf_to_node ( args ) ; if ( ! error ) { error = xfs_bmap_finish ( & args -> trans , args -> flist , & committed ) ; } if ( error ) { ASSERT ( committed ) ; args -> trans = NULL ; xfs_bmap_cancel ( args -> flist ) ; goto out ; } if ( committed ) xfs_trans_ijoin ( args -> trans , dp , 0 ) ; error = xfs_trans_roll ( & args -> trans , dp ) ; if ( error ) goto out ; goto restart ; } xfs_bmap_init ( args -> flist , args -> firstblock ) ; error = xfs_da3_split ( state ) ; if ( ! error ) { error = xfs_bmap_finish ( & args -> trans , args -> flist , & committed ) ; } if ( error ) { ASSERT ( committed ) ; args -> trans = NULL ; xfs_bmap_cancel ( args -> flist ) ; goto out ; } if ( committed ) xfs_trans_ijoin ( args -> trans , dp , 0 ) ; } else { xfs_da3_fixhashpath ( state , & state -> path ) ; } xfs_da_state_free ( state ) ; state = NULL ; error = xfs_trans_roll ( & args -> trans , dp ) ; if ( error ) goto out ; if ( args -> rmtblkno > 0 ) { error = xfs_attr_rmtval_set ( args ) ; if ( error ) return ( error ) ; } if ( args -> op_flags & XFS_DA_OP_RENAME ) { error = xfs_attr3_leaf_flipflags ( args ) ; if ( error ) goto out ; args -> index = args -> index2 ; args -> blkno = args -> blkno2 ; args -> rmtblkno = args -> rmtblkno2 ; <S2SV_StartBug> args -> rmtblkcnt = args -> rmtblkcnt2 ; <S2SV_EndBug> if ( args -> rmtblkno ) { error = xfs_attr_rmtval_remove ( args ) ; if ( error ) return ( error ) ; } args -> flags |= XFS_ATTR_INCOMPLETE ; state = xfs_da_state_alloc ( ) ; state -> args = args ; state -> mp = mp ; state -> blocksize = state -> mp -> m_sb . sb_blocksize ; state -> node_ents = state -> mp -> m_attr_node_ents ; state -> inleaf = 0 ; error = xfs_da3_node_lookup_int ( state , & retval ) ; if ( error ) goto out ; blk = & state -> path . blk [ state -> path . active - 1 ] ; ASSERT ( blk -> magic == XFS_ATTR_LEAF_MAGIC ) ; error = xfs_attr3_leaf_remove ( blk -> bp , args ) ; xfs_da3_fixhashpath ( state , & state -> path ) ; if ( retval && ( state -> path . active > 1 ) ) { xfs_bmap_init ( args -> flist , args -> firstblock ) ; error = xfs_da3_join ( state ) ; if ( ! error ) { error = xfs_bmap_finish ( & args -> trans , args -> flist , & committed ) ; } if ( error ) { ASSERT ( committed ) ; args -> trans = NULL ; xfs_bmap_cancel ( args -> flist ) ; goto out ; } if ( committed ) xfs_trans_ijoin ( args -> trans , dp , 0 ) ; } error = xfs_trans_roll ( & args -> trans , dp ) ; if ( error ) goto out ; } else if ( args -> rmtblkno > 0 ) { error = xfs_attr3_leaf_clearflag ( args ) ; if ( error ) goto out ; } retval = error = 0 ; out : if ( state ) xfs_da_state_free ( state ) ; if ( error ) return ( error ) ; return ( retval ) ; }",; args -> rmtvaluelen2 = args -> rmtvaluelen ; args -> <S2SV_ModStart> args -> rmtblkcnt = 0 ; args -> rmtvaluelen <S2SV_ModStart> args -> rmtblkcnt2 ; args -> rmtvaluelen = args -> rmtvaluelen2
753,"int X509_cmp_time ( const ASN1_TIME * ctm , time_t * cmp_time ) { char * str ; ASN1_TIME atm ; long offset ; char buff1 [ 24 ] , buff2 [ 24 ] , * p ; <S2SV_StartBug> int i , j ; <S2SV_EndBug> p = buff1 ; <S2SV_StartBug> i = ctm -> length ; <S2SV_EndBug> str = ( char * ) ctm -> data ; if ( ctm -> type == V_ASN1_UTCTIME ) { <S2SV_StartBug> if ( ( i < 11 ) || ( i > 17 ) ) <S2SV_EndBug> return 0 ; memcpy ( p , str , 10 ) ; p += 10 ; str += 10 ; <S2SV_StartBug> } else { <S2SV_EndBug> <S2SV_StartBug> if ( i < 13 ) <S2SV_EndBug> return 0 ; memcpy ( p , str , 12 ) ; p += 12 ; str += 12 ; <S2SV_StartBug> } <S2SV_EndBug> if ( ( * str == 'Z' ) || ( * str == '-' ) || ( * str == '+' ) ) { * ( p ++ ) = '0' ; * ( p ++ ) = '0' ; } else { <S2SV_StartBug> * ( p ++ ) = * ( str ++ ) ; <S2SV_EndBug> * ( p ++ ) = * ( str ++ ) ; if ( * str == '.' ) { str ++ ; <S2SV_StartBug> while ( ( * str >= '0' ) && ( * str <= '9' ) ) <S2SV_EndBug> str ++ ; } } * ( p ++ ) = 'Z' ; * ( p ++ ) = '\\0' ; <S2SV_StartBug> if ( * str == 'Z' ) <S2SV_EndBug> offset = 0 ; <S2SV_StartBug> else { <S2SV_EndBug> <S2SV_StartBug> if ( ( * str != '+' ) && ( * str != '-' ) ) <S2SV_EndBug> return 0 ; offset = ( ( str [ 1 ] - '0' ) * 10 + ( str [ 2 ] - '0' ) ) * 60 ; offset += ( str [ 3 ] - '0' ) * 10 + ( str [ 4 ] - '0' ) ; if ( * str == '-' ) offset = - offset ; } atm . type = ctm -> type ; atm . flags = 0 ; atm . length = sizeof ( buff2 ) ; atm . data = ( unsigned char * ) buff2 ; if ( X509_time_adj ( & atm , offset * 60 , cmp_time ) == NULL ) return 0 ; if ( ctm -> type == V_ASN1_UTCTIME ) { i = ( buff1 [ 0 ] - '0' ) * 10 + ( buff1 [ 1 ] - '0' ) ; if ( i < 50 ) i += 100 ; j = ( buff2 [ 0 ] - '0' ) * 10 + ( buff2 [ 1 ] - '0' ) ; if ( j < 50 ) j += 100 ; if ( i < j ) return - 1 ; if ( i > j ) return 1 ; } i = strcmp ( buff1 , buff2 ) ; if ( i == 0 ) return - 1 ; else return i ; }","i , j , remaining <S2SV_ModStart> = buff1 ; remaining <S2SV_ModEnd> = ctm -> <S2SV_ModStart> V_ASN1_UTCTIME ) { int min_length = sizeof ( ""YYMMDDHHMMZ"" ) - 1 ; int max_length = sizeof ( ""YYMMDDHHMMSS+hhmm"" ) - 1 ; if ( remaining < min_length || remaining > max_length <S2SV_ModEnd> ) return 0 <S2SV_ModStart> += 10 ; remaining -= 10 ; <S2SV_ModStart> } else { int min_length = sizeof ( ""YYYYMMDDHHMMZ"" ) - 1 ; int max_length = sizeof ( ""YYYYMMDDHHMMSS.fff+hhmm"" ) - 1 ; if ( remaining < min_length || remaining > max_length <S2SV_ModEnd> ) return 0 <S2SV_ModStart> += 12 ; remaining -= 12 ; <S2SV_ModStart> } else { if ( remaining < 2 ) return 0 ; * ( p ++ ) = * ( str ++ ) ; * ( p ++ ) = * ( str ++ ) ; remaining -= 2 ; if ( remaining && <S2SV_ModEnd> * str == <S2SV_ModStart> str ++ ; remaining -- ; for ( i = 0 ; i < 3 && remaining ; i ++ , str ++ , remaining -- ) { if ( * str < '0' || * str > '9' ) break ; } <S2SV_ModEnd> } } * <S2SV_ModStart> ; if ( ! remaining ) return 0 ; if ( <S2SV_ModStart> == 'Z' ) { if ( remaining != 1 ) return 0 ; <S2SV_ModStart> = 0 ; } <S2SV_ModStart> != '-' ) ) return 0 ; if ( remaining != 5 ) return 0 ; if ( str [ 1 ] < '0' || str [ 1 ] > '9' || str [ 2 ] < '0' || str [ 2 ] > '9' || str [ 3 ] < '0' || str [ 3 ] > '9' || str [ 4 ] < '0' || str [ 4 ] > '9'"
754,"BOOL nsc_process_message ( NSC_CONTEXT * context , UINT16 bpp , UINT32 width , UINT32 height , const BYTE * data , UINT32 length , BYTE * pDstData , UINT32 DstFormat , UINT32 nDstStride , UINT32 nXDst , UINT32 nYDst , UINT32 nWidth , UINT32 nHeight , UINT32 flip ) { wStream * s ; BOOL ret ; s = Stream_New ( ( BYTE * ) data , length ) ; if ( ! s ) return FALSE ; if ( nDstStride == 0 ) nDstStride = nWidth * GetBytesPerPixel ( DstFormat ) ; switch ( bpp ) { case 32 : context -> format = PIXEL_FORMAT_BGRA32 ; break ; case 24 : context -> format = PIXEL_FORMAT_BGR24 ; break ; case 16 : context -> format = PIXEL_FORMAT_BGR16 ; break ; case 8 : context -> format = PIXEL_FORMAT_RGB8 ; break ; case 4 : context -> format = PIXEL_FORMAT_A4 ; break ; default : Stream_Free ( s , TRUE ) ; return FALSE ; } context -> width = width ; context -> height = height ; ret = nsc_context_initialize ( context , s ) ; Stream_Free ( s , FALSE ) ; if ( ! ret ) return FALSE ; <S2SV_StartBug> PROFILER_ENTER ( context -> priv -> prof_nsc_rle_decompress_data ) <S2SV_EndBug> <S2SV_StartBug> nsc_rle_decompress_data ( context ) ; <S2SV_EndBug> PROFILER_EXIT ( context -> priv -> prof_nsc_rle_decompress_data ) <S2SV_StartBug> PROFILER_ENTER ( context -> priv -> prof_nsc_decode ) <S2SV_EndBug> <S2SV_StartBug> context -> decode ( context ) ; <S2SV_EndBug> <S2SV_StartBug> PROFILER_EXIT ( context -> priv -> prof_nsc_decode ) <S2SV_EndBug> if ( ! freerdp_image_copy ( pDstData , DstFormat , nDstStride , nXDst , nYDst , width , height , context -> BitmapData , PIXEL_FORMAT_BGRA32 , 0 , 0 , 0 , NULL , flip ) ) return FALSE ; return TRUE ; }",return FALSE ; { BOOL rc ; <S2SV_ModStart> -> prof_nsc_rle_decompress_data ) rc = <S2SV_ModStart> -> prof_nsc_rle_decompress_data ) if ( ! rc ) return FALSE ; } { BOOL rc ; <S2SV_ModStart> -> prof_nsc_decode ) rc = <S2SV_ModStart> -> prof_nsc_decode ) if ( ! rc ) return FALSE ; }
755,"static void Sp_match ( js_State * J ) { js_Regexp * re ; const char * text ; int len ; const char * a , * b , * c , * e ; Resub m ; text = checkstring ( J , 0 ) ; if ( js_isregexp ( J , 1 ) ) js_copy ( J , 1 ) ; else if ( js_isundefined ( J , 1 ) ) js_newregexp ( J , """" , 0 ) ; else js_newregexp ( J , js_tostring ( J , 1 ) , 0 ) ; re = js_toregexp ( J , - 1 ) ; if ( ! ( re -> flags & JS_REGEXP_G ) ) { js_RegExp_prototype_exec ( J , re , text ) ; return ; } re -> last = 0 ; js_newarray ( J ) ; len = 0 ; a = text ; e = text + strlen ( text ) ; while ( a <= e ) { <S2SV_StartBug> if ( js_regexec ( re -> prog , a , & m , a > text ? REG_NOTBOL : 0 ) ) <S2SV_EndBug> break ; b = m . sub [ 0 ] . sp ; c = m . sub [ 0 ] . ep ; js_pushlstring ( J , b , c - b ) ; js_setindex ( J , - 2 , len ++ ) ; a = c ; if ( c - b == 0 ) ++ a ; } if ( len == 0 ) { js_pop ( J , 1 ) ; js_pushnull ( J ) ; } }","{ if ( js_doregexec ( J , <S2SV_ModEnd> re -> prog"
756,"static netdev_tx_t hns_nic_net_xmit ( struct sk_buff * skb , struct net_device * ndev ) { struct hns_nic_priv * priv = netdev_priv ( ndev ) ; <S2SV_StartBug> int ret ; <S2SV_EndBug> assert ( skb -> queue_mapping < ndev -> ae_handle -> q_num ) ; <S2SV_StartBug> ret = hns_nic_net_xmit_hw ( ndev , skb , <S2SV_EndBug> & tx_ring_data ( priv , skb -> queue_mapping ) ) ; <S2SV_StartBug> if ( ret == NETDEV_TX_OK ) { <S2SV_EndBug> netif_trans_update ( ndev ) ; ndev -> stats . tx_bytes += skb -> len ; ndev -> stats . tx_packets ++ ; } return ( netdev_tx_t ) ret ; }",ndev ) ; <S2SV_ModEnd> assert ( skb <S2SV_ModStart> q_num ) ; return <S2SV_ModEnd> hns_nic_net_xmit_hw ( ndev <S2SV_ModStart> ) ) ; <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
757,"void HTML_put_string ( HTStructured * me , const char * s ) <S2SV_StartBug> { <S2SV_EndBug> # ifdef USE_PRETTYSRC char * translated_string = NULL ; # endif if ( s == NULL || ( LYMapsOnly && me -> sp [ 0 ] . tag_number != HTML_OBJECT ) ) return ; # ifdef USE_PRETTYSRC if ( psrc_convert_string ) { StrAllocCopy ( translated_string , s ) ; TRANSLATE_AND_UNESCAPE_ENTITIES ( & translated_string , TRUE , FALSE ) ; s = ( const char * ) translated_string ; } # endif switch ( me -> sp [ 0 ] . tag_number ) { case HTML_COMMENT : break ; case HTML_TITLE : <S2SV_StartBug> HTChunkPuts ( & me -> title , s ) ; <S2SV_EndBug> break ; case HTML_STYLE : <S2SV_StartBug> HTChunkPuts ( & me -> style_block , s ) ; <S2SV_EndBug> break ; case HTML_SCRIPT : <S2SV_StartBug> HTChunkPuts ( & me -> script , s ) ; <S2SV_EndBug> break ; case HTML_PRE : case HTML_LISTING : case HTML_XMP : case HTML_PLAINTEXT : HText_appendText ( me -> text , s ) ; break ; case HTML_OBJECT : <S2SV_StartBug> HTChunkPuts ( & me -> object , s ) ; <S2SV_EndBug> break ; case HTML_TEXTAREA : <S2SV_StartBug> HTChunkPuts ( & me -> textarea , s ) ; <S2SV_EndBug> break ; case HTML_SELECT : case HTML_OPTION : <S2SV_StartBug> HTChunkPuts ( & me -> option , s ) ; <S2SV_EndBug> break ; case HTML_MATH : <S2SV_StartBug> HTChunkPuts ( & me -> math , s ) ; <S2SV_EndBug> break ; default : if ( ! me -> sp -> style -> freeFormat ) { # ifdef USE_PRETTYSRC if ( psrc_view ) { for ( ; * s ; ++ s ) HTML_put_character ( me , * s ) ; } else # endif HText_appendText ( me -> text , s ) ; break ; } else { const char * p = s ; char c ; if ( me -> style_change ) { for ( ; * p && ( ( * p == '\\n' ) || ( * p == '\\r' ) || ( * p == '<S2SV_blank>' ) || ( * p == '\\t' ) ) ; p ++ ) ; if ( ! * p ) break ; UPDATE_STYLE ; } for ( ; * p ; p ++ ) { if ( * p == 13 && p [ 1 ] != 10 ) { c = '\\n' ; } else { c = * p ; } if ( me -> style_change ) { if ( ( c == '\\n' ) || ( c == '<S2SV_blank>' ) || ( c == '\\t' ) ) continue ; UPDATE_STYLE ; } if ( c == '\\n' ) { if ( ! FIX_JAPANESE_SPACES ) { if ( me -> in_word ) { if ( HText_getLastChar ( me -> text ) != '<S2SV_blank>' ) HText_appendCharacter ( me -> text , '<S2SV_blank>' ) ; me -> in_word = NO ; } } } else if ( c == '<S2SV_blank>' || c == '\\t' ) { if ( HText_getLastChar ( me -> text ) != '<S2SV_blank>' ) HText_appendCharacter ( me -> text , '<S2SV_blank>' ) ; } else if ( c == '\\r' ) { } else { HText_appendCharacter ( me -> text , c ) ; me -> in_word = YES ; } if ( c == '\\n' || c == '\\t' ) { HText_setLastChar ( me -> text , '<S2SV_blank>' ) ; } else if ( c == '\\r' && HText_getLastChar ( me -> text ) == '<S2SV_blank>' ) { HText_setLastChar ( me -> text , '<S2SV_blank>' ) ; } else { HText_setLastChar ( me -> text , c ) ; } } } } <S2SV_StartBug> # ifdef USE_PRETTYSRC <S2SV_EndBug> if ( psrc_convert_string ) { psrc_convert_string = FALSE ; FREE ( translated_string ) ; } # endif }","s ) { HTChunk * target = NULL ; <S2SV_ModStart> case HTML_TITLE : target = <S2SV_ModEnd> & me -> <S2SV_ModStart> me -> title <S2SV_ModEnd> ; break ; <S2SV_ModStart> case HTML_STYLE : target = <S2SV_ModEnd> & me -> <S2SV_ModStart> me -> style_block <S2SV_ModEnd> ; break ; <S2SV_ModStart> case HTML_SCRIPT : target = <S2SV_ModEnd> & me -> <S2SV_ModStart> me -> script <S2SV_ModEnd> ; break ; <S2SV_ModStart> case HTML_OBJECT : target = <S2SV_ModEnd> & me -> <S2SV_ModStart> me -> object <S2SV_ModEnd> ; break ; <S2SV_ModStart> case HTML_TEXTAREA : target = <S2SV_ModEnd> & me -> <S2SV_ModStart> me -> textarea <S2SV_ModEnd> ; break ; <S2SV_ModStart> case HTML_OPTION : target = <S2SV_ModEnd> & me -> <S2SV_ModStart> me -> option <S2SV_ModEnd> ; break ; <S2SV_ModStart> case HTML_MATH : target = <S2SV_ModEnd> & me -> <S2SV_ModStart> me -> math <S2SV_ModEnd> ; break ; <S2SV_ModStart> } } } if ( target != NULL ) { if ( target -> data == s ) { CTRACE ( ( tfp , ""BUG:<S2SV_blank>appending<S2SV_blank>chunk<S2SV_blank>to<S2SV_blank>itself:<S2SV_blank>`%.*s\'\\n"" , target -> size , target -> data ) ) ; } else { HTChunkPuts ( target , s ) ; } }"
758,"int iwch_cxgb3_ofld_send ( struct t3cdev * tdev , struct sk_buff * skb ) { int error = 0 ; struct cxio_rdev * rdev ; rdev = ( struct cxio_rdev * ) tdev -> ulp ; if ( cxio_fatal_error ( rdev ) ) { kfree_skb ( skb ) ; return - EIO ; } error = cxgb3_ofld_send ( tdev , skb ) ; if ( error < 0 ) kfree_skb ( skb ) ; <S2SV_StartBug> return error ; <S2SV_EndBug> }",; return error < 0 ? error : 0
759,"static ssize_t aio_setup_vectored_rw ( int type , struct kiocb * kiocb , bool compat ) { ssize_t ret ; # ifdef CONFIG_COMPAT if ( compat ) ret = compat_rw_copy_check_uvector ( type , ( struct compat_iovec __user * ) kiocb -> ki_buf , kiocb -> ki_nbytes , 1 , & kiocb -> ki_inline_vec , & kiocb -> ki_iovec , 1 ) ; else # endif ret = rw_copy_check_uvector ( type , ( struct iovec __user * ) kiocb -> ki_buf , kiocb -> ki_nbytes , 1 , & kiocb -> ki_inline_vec , & kiocb -> ki_iovec , 1 ) ; if ( ret < 0 ) goto out ; <S2SV_StartBug> kiocb -> ki_nr_segs = kiocb -> ki_nbytes ; <S2SV_EndBug> kiocb -> ki_cur_seg = 0 ; kiocb -> ki_nbytes = ret ; kiocb -> ki_left = ret ; ret = 0 ; out : return ret ; }","goto out ; ret = rw_verify_area ( type , kiocb -> ki_filp , & kiocb -> ki_pos , ret ) ; if ( ret < 0 ) goto out ;"
760,"int sas_discover_sata ( struct domain_device * dev ) { int res ; if ( dev -> dev_type == SAS_SATA_PM ) return - ENODEV ; dev -> sata_dev . class = sas_get_ata_command_set ( dev ) ; sas_fill_in_rphy ( dev , dev -> rphy ) ; res = sas_notify_lldd_dev_found ( dev ) ; if ( res ) return res ; <S2SV_StartBug> sas_discover_event ( dev -> port , DISCE_PROBE ) ; <S2SV_EndBug> return 0 ; }",return res ; <S2SV_ModEnd> return 0 ;
761,"void pdo_stmt_init ( TSRMLS_D ) { zend_class_entry ce ; INIT_CLASS_ENTRY ( ce , ""PDOStatement"" , pdo_dbstmt_functions ) ; pdo_dbstmt_ce = zend_register_internal_class ( & ce TSRMLS_CC ) ; pdo_dbstmt_ce -> get_iterator = pdo_stmt_iter_get ; pdo_dbstmt_ce -> create_object = pdo_dbstmt_new ; zend_class_implements ( pdo_dbstmt_ce TSRMLS_CC , 1 , zend_ce_traversable ) ; zend_declare_property_null ( pdo_dbstmt_ce , ""queryString"" , sizeof ( ""queryString"" ) - 1 , ZEND_ACC_PUBLIC TSRMLS_CC ) ; memcpy ( & pdo_dbstmt_object_handlers , & std_object_handlers , sizeof ( zend_object_handlers ) ) ; pdo_dbstmt_object_handlers . write_property = dbstmt_prop_write ; pdo_dbstmt_object_handlers . unset_property = dbstmt_prop_delete ; pdo_dbstmt_object_handlers . get_method = dbstmt_method_get ; pdo_dbstmt_object_handlers . compare_objects = dbstmt_compare ; pdo_dbstmt_object_handlers . clone_obj = dbstmt_clone_obj ; INIT_CLASS_ENTRY ( ce , ""PDORow"" , pdo_row_functions ) ; pdo_row_ce = zend_register_internal_class ( & ce TSRMLS_CC ) ; pdo_row_ce -> ce_flags |= ZEND_ACC_FINAL_CLASS ; pdo_row_ce -> create_object = pdo_row_new ; pdo_row_ce -> serialize = pdo_row_serialize ; <S2SV_StartBug> } <S2SV_EndBug>",= pdo_row_serialize ; pdo_row_ce -> unserialize = zend_class_unserialize_deny ;
762,"static int ext2_xattr_list ( struct dentry * dentry , char * buffer , size_t buffer_size ) { struct inode * inode = d_inode ( dentry ) ; struct buffer_head * bh = NULL ; struct ext2_xattr_entry * entry ; char * end ; size_t rest = buffer_size ; <S2SV_StartBug> int error ; <S2SV_EndBug> ea_idebug ( inode , ""buffer=%p,<S2SV_blank>buffer_size=%ld"" , buffer , ( long ) buffer_size ) ; down_read ( & EXT2_I ( inode ) -> xattr_sem ) ; error = 0 ; if ( ! EXT2_I ( inode ) -> i_file_acl ) goto cleanup ; ea_idebug ( inode , ""reading<S2SV_blank>block<S2SV_blank>%d"" , EXT2_I ( inode ) -> i_file_acl ) ; bh = sb_bread ( inode -> i_sb , EXT2_I ( inode ) -> i_file_acl ) ; error = - EIO ; if ( ! bh ) goto cleanup ; ea_bdebug ( bh , ""b_count=%d,<S2SV_blank>refcount=%d"" , atomic_read ( & ( bh -> b_count ) ) , le32_to_cpu ( HDR ( bh ) -> h_refcount ) ) ; end = bh -> b_data + bh -> b_size ; if ( HDR ( bh ) -> h_magic != cpu_to_le32 ( EXT2_XATTR_MAGIC ) || HDR ( bh ) -> h_blocks != cpu_to_le32 ( 1 ) ) { bad_block : ext2_error ( inode -> i_sb , ""ext2_xattr_list"" , ""inode<S2SV_blank>%ld:<S2SV_blank>bad<S2SV_blank>block<S2SV_blank>%d"" , inode -> i_ino , EXT2_I ( inode ) -> i_file_acl ) ; error = - EIO ; goto cleanup ; } entry = FIRST_ENTRY ( bh ) ; while ( ! IS_LAST_ENTRY ( entry ) ) { struct ext2_xattr_entry * next = EXT2_XATTR_NEXT ( entry ) ; if ( ( char * ) next >= end ) goto bad_block ; entry = next ; } <S2SV_StartBug> if ( ext2_xattr_cache_insert ( bh ) ) <S2SV_EndBug> ea_idebug ( inode , ""cache<S2SV_blank>insert<S2SV_blank>failed"" ) ; for ( entry = FIRST_ENTRY ( bh ) ; ! IS_LAST_ENTRY ( entry ) ; entry = EXT2_XATTR_NEXT ( entry ) ) { const struct xattr_handler * handler = ext2_xattr_handler ( entry -> e_name_index ) ; if ( handler && ( ! handler -> list || handler -> list ( dentry ) ) ) { const char * prefix = handler -> prefix ? : handler -> name ; size_t prefix_len = strlen ( prefix ) ; size_t size = prefix_len + entry -> e_name_len + 1 ; if ( buffer ) { if ( size > rest ) { error = - ERANGE ; goto cleanup ; } memcpy ( buffer , prefix , prefix_len ) ; buffer += prefix_len ; memcpy ( buffer , entry -> e_name , entry -> e_name_len ) ; buffer += entry -> e_name_len ; * buffer ++ = 0 ; } rest -= size ; } } error = buffer_size - rest ; cleanup : brelse ( bh ) ; up_read ( & EXT2_I ( inode ) -> xattr_sem ) ; return error ; }","; int error ; struct mb2_cache * ext2_mb_cache = EXT2_SB ( inode -> i_sb ) -> s_mb_cache <S2SV_ModStart> ( ext2_xattr_cache_insert ( ext2_mb_cache ,"
763,"static int snd_seq_ioctl_remove_events ( struct snd_seq_client * client , void __user * arg ) { struct snd_seq_remove_events info ; if ( copy_from_user ( & info , arg , sizeof ( info ) ) ) return - EFAULT ; if ( info . remove_mode & SNDRV_SEQ_REMOVE_INPUT ) { <S2SV_StartBug> if ( client -> type == USER_CLIENT ) <S2SV_EndBug> snd_seq_fifo_clear ( client -> data . user . fifo ) ; } if ( info . remove_mode & SNDRV_SEQ_REMOVE_OUTPUT ) snd_seq_queue_remove_cells ( client -> number , & info ) ; return 0 ; }",type == USER_CLIENT && client -> data . user . fifo
764,"key_ref_t key_create_or_update ( key_ref_t keyring_ref , const char * type , const char * description , const void * payload , size_t plen , key_perm_t perm , unsigned long flags ) { struct keyring_index_key index_key = { . description = description , } ; struct key_preparsed_payload prep ; struct assoc_array_edit * edit ; const struct cred * cred = current_cred ( ) ; struct key * keyring , * key = NULL ; key_ref_t key_ref ; int ret ; index_key . type = key_type_lookup ( type ) ; if ( IS_ERR ( index_key . type ) ) { key_ref = ERR_PTR ( - ENODEV ) ; goto error ; } key_ref = ERR_PTR ( - EINVAL ) ; <S2SV_StartBug> if ( ! index_key . type -> match || ! index_key . type -> instantiate || <S2SV_EndBug> ( ! index_key . description && ! index_key . type -> preparse ) ) goto error_put_type ; keyring = key_ref_to_ptr ( keyring_ref ) ; key_check ( keyring ) ; key_ref = ERR_PTR ( - ENOTDIR ) ; if ( keyring -> type != & key_type_keyring ) goto error_put_type ; memset ( & prep , 0 , sizeof ( prep ) ) ; prep . data = payload ; prep . datalen = plen ; prep . quotalen = index_key . type -> def_datalen ; prep . trusted = flags & KEY_ALLOC_TRUSTED ; prep . expiry = TIME_T_MAX ; if ( index_key . type -> preparse ) { ret = index_key . type -> preparse ( & prep ) ; if ( ret < 0 ) { key_ref = ERR_PTR ( ret ) ; goto error_free_prep ; } if ( ! index_key . description ) index_key . description = prep . description ; key_ref = ERR_PTR ( - EINVAL ) ; if ( ! index_key . description ) goto error_free_prep ; } index_key . desc_len = strlen ( index_key . description ) ; key_ref = ERR_PTR ( - EPERM ) ; if ( ! prep . trusted && test_bit ( KEY_FLAG_TRUSTED_ONLY , & keyring -> flags ) ) goto error_free_prep ; flags |= prep . trusted ? KEY_ALLOC_TRUSTED : 0 ; ret = __key_link_begin ( keyring , & index_key , & edit ) ; if ( ret < 0 ) { key_ref = ERR_PTR ( ret ) ; goto error_free_prep ; } ret = key_permission ( keyring_ref , KEY_NEED_WRITE ) ; if ( ret < 0 ) { key_ref = ERR_PTR ( ret ) ; goto error_link_end ; } if ( index_key . type -> update ) { key_ref = find_key_to_update ( keyring_ref , & index_key ) ; if ( key_ref ) goto found_matching_key ; } if ( perm == KEY_PERM_UNDEF ) { perm = KEY_POS_VIEW | KEY_POS_SEARCH | KEY_POS_LINK | KEY_POS_SETATTR ; perm |= KEY_USR_VIEW ; if ( index_key . type -> read ) perm |= KEY_POS_READ ; if ( index_key . type == & key_type_keyring || index_key . type -> update ) perm |= KEY_POS_WRITE ; } key = key_alloc ( index_key . type , index_key . description , cred -> fsuid , cred -> fsgid , cred , perm , flags ) ; if ( IS_ERR ( key ) ) { key_ref = ERR_CAST ( key ) ; goto error_link_end ; } ret = __key_instantiate_and_link ( key , & prep , keyring , NULL , & edit ) ; if ( ret < 0 ) { key_put ( key ) ; key_ref = ERR_PTR ( ret ) ; goto error_link_end ; } key_ref = make_key_ref ( key , is_key_possessed ( keyring_ref ) ) ; error_link_end : __key_link_end ( keyring , & index_key , edit ) ; error_free_prep : if ( index_key . type -> preparse ) index_key . type -> free_preparse ( & prep ) ; error_put_type : key_type_put ( index_key . type ) ; error : return key_ref ; found_matching_key : __key_link_end ( keyring , & index_key , edit ) ; key_ref = __key_update ( key_ref , & prep ) ; goto error_free_prep ; }",; if ( <S2SV_ModEnd> ! index_key .
765,"void vrrp_print_json ( void ) { FILE * file ; element e ; struct json_object * array ; if ( LIST_ISEMPTY ( vrrp_data -> vrrp ) ) return ; <S2SV_StartBug> file = fopen ( ""/tmp/keepalived.json"" , ""w"" ) ; <S2SV_EndBug> if ( ! file ) { log_message ( LOG_INFO , ""Can\'t<S2SV_blank>open<S2SV_blank>/tmp/keepalived.json<S2SV_blank>(%d:<S2SV_blank>%s)"" , errno , strerror ( errno ) ) ; return ; } array = json_object_new_array ( ) ; for ( e = LIST_HEAD ( vrrp_data -> vrrp ) ; e ; ELEMENT_NEXT ( e ) ) { struct json_object * instance_json , * json_stats , * json_data , * vips , * evips , * track_ifp , * track_script ; # ifdef _HAVE_FIB_ROUTING_ struct json_object * vroutes , * vrules ; # endif element f ; vrrp_t * vrrp = ELEMENT_DATA ( e ) ; instance_json = json_object_new_object ( ) ; json_stats = json_object_new_object ( ) ; json_data = json_object_new_object ( ) ; vips = json_object_new_array ( ) ; evips = json_object_new_array ( ) ; track_ifp = json_object_new_array ( ) ; track_script = json_object_new_array ( ) ; # ifdef _HAVE_FIB_ROUTING_ vroutes = json_object_new_array ( ) ; vrules = json_object_new_array ( ) ; # endif json_object_object_add ( json_data , ""iname"" , json_object_new_string ( vrrp -> iname ) ) ; json_object_object_add ( json_data , ""dont_track_primary"" , json_object_new_int ( vrrp -> dont_track_primary ) ) ; json_object_object_add ( json_data , ""skip_check_adv_addr"" , json_object_new_int ( vrrp -> skip_check_adv_addr ) ) ; json_object_object_add ( json_data , ""strict_mode"" , json_object_new_int ( ( int ) vrrp -> strict_mode ) ) ; # ifdef _HAVE_VRRP_VMAC_ json_object_object_add ( json_data , ""vmac_ifname"" , json_object_new_string ( vrrp -> vmac_ifname ) ) ; # endif if ( ! LIST_ISEMPTY ( vrrp -> track_ifp ) ) { for ( f = LIST_HEAD ( vrrp -> track_ifp ) ; f ; ELEMENT_NEXT ( f ) ) { interface_t * ifp = ELEMENT_DATA ( f ) ; json_object_array_add ( track_ifp , json_object_new_string ( ifp -> ifname ) ) ; } } json_object_object_add ( json_data , ""track_ifp"" , track_ifp ) ; if ( ! LIST_ISEMPTY ( vrrp -> track_script ) ) { for ( f = LIST_HEAD ( vrrp -> track_script ) ; f ; ELEMENT_NEXT ( f ) ) { tracked_sc_t * tsc = ELEMENT_DATA ( f ) ; vrrp_script_t * vscript = tsc -> scr ; json_object_array_add ( track_script , json_object_new_string ( cmd_str ( & vscript -> script ) ) ) ; } } json_object_object_add ( json_data , ""track_script"" , track_script ) ; json_object_object_add ( json_data , ""ifp_ifname"" , json_object_new_string ( vrrp -> ifp -> ifname ) ) ; json_object_object_add ( json_data , ""master_priority"" , json_object_new_int ( vrrp -> master_priority ) ) ; json_object_object_add ( json_data , ""last_transition"" , json_object_new_double ( timeval_to_double ( & vrrp -> last_transition ) ) ) ; json_object_object_add ( json_data , ""garp_delay"" , json_object_new_double ( vrrp -> garp_delay / TIMER_HZ_FLOAT ) ) ; json_object_object_add ( json_data , ""garp_refresh"" , json_object_new_int ( ( int ) vrrp -> garp_refresh . tv_sec ) ) ; json_object_object_add ( json_data , ""garp_rep"" , json_object_new_int ( ( int ) vrrp -> garp_rep ) ) ; json_object_object_add ( json_data , ""garp_refresh_rep"" , json_object_new_int ( ( int ) vrrp -> garp_refresh_rep ) ) ; json_object_object_add ( json_data , ""garp_lower_prio_delay"" , json_object_new_int ( ( int ) ( vrrp -> garp_lower_prio_delay / TIMER_HZ ) ) ) ; json_object_object_add ( json_data , ""garp_lower_prio_rep"" , json_object_new_int ( ( int ) vrrp -> garp_lower_prio_rep ) ) ; json_object_object_add ( json_data , ""lower_prio_no_advert"" , json_object_new_int ( ( int ) vrrp -> lower_prio_no_advert ) ) ; json_object_object_add ( json_data , ""higher_prio_send_advert"" , json_object_new_int ( ( int ) vrrp -> higher_prio_send_advert ) ) ; json_object_object_add ( json_data , ""vrid"" , json_object_new_int ( vrrp -> vrid ) ) ; json_object_object_add ( json_data , ""base_priority"" , json_object_new_int ( vrrp -> base_priority ) ) ; json_object_object_add ( json_data , ""effective_priority"" , json_object_new_int ( vrrp -> effective_priority ) ) ; json_object_object_add ( json_data , ""vipset"" , json_object_new_boolean ( vrrp -> vipset ) ) ; if ( ! LIST_ISEMPTY ( vrrp -> vip ) ) { for ( f = LIST_HEAD ( vrrp -> vip ) ; f ; ELEMENT_NEXT ( f ) ) { ip_address_t * vip = ELEMENT_DATA ( f ) ; char ipaddr [ INET6_ADDRSTRLEN ] ; inet_ntop ( vrrp -> family , & ( vip -> u . sin . sin_addr . s_addr ) , ipaddr , INET6_ADDRSTRLEN ) ; json_object_array_add ( vips , json_object_new_string ( ipaddr ) ) ; } } json_object_object_add ( json_data , ""vips"" , vips ) ; if ( ! LIST_ISEMPTY ( vrrp -> evip ) ) { for ( f = LIST_HEAD ( vrrp -> evip ) ; f ; ELEMENT_NEXT ( f ) ) { ip_address_t * evip = ELEMENT_DATA ( f ) ; char ipaddr [ INET6_ADDRSTRLEN ] ; inet_ntop ( vrrp -> family , & ( evip -> u . sin . sin_addr . s_addr ) , ipaddr , INET6_ADDRSTRLEN ) ; json_object_array_add ( evips , json_object_new_string ( ipaddr ) ) ; } } json_object_object_add ( json_data , ""evips"" , evips ) ; json_object_object_add ( json_data , ""promote_secondaries"" , json_object_new_boolean ( vrrp -> promote_secondaries ) ) ; # ifdef _HAVE_FIB_ROUTING_ if ( ! LIST_ISEMPTY ( vrrp -> vroutes ) ) { for ( f = LIST_HEAD ( vrrp -> vroutes ) ; f ; ELEMENT_NEXT ( f ) ) { ip_route_t * route = ELEMENT_DATA ( f ) ; char * buf = MALLOC ( ROUTE_BUF_SIZE ) ; format_iproute ( route , buf , ROUTE_BUF_SIZE ) ; json_object_array_add ( vroutes , json_object_new_string ( buf ) ) ; } } json_object_object_add ( json_data , ""vroutes"" , vroutes ) ; if ( ! LIST_ISEMPTY ( vrrp -> vrules ) ) { for ( f = LIST_HEAD ( vrrp -> vrules ) ; f ; ELEMENT_NEXT ( f ) ) { ip_rule_t * rule = ELEMENT_DATA ( f ) ; char * buf = MALLOC ( RULE_BUF_SIZE ) ; format_iprule ( rule , buf , RULE_BUF_SIZE ) ; json_object_array_add ( vrules , json_object_new_string ( buf ) ) ; } } json_object_object_add ( json_data , ""vrules"" , vrules ) ; # endif json_object_object_add ( json_data , ""adver_int"" , json_object_new_double ( vrrp -> adver_int / TIMER_HZ_FLOAT ) ) ; json_object_object_add ( json_data , ""master_adver_int"" , json_object_new_double ( vrrp -> master_adver_int / TIMER_HZ_FLOAT ) ) ; json_object_object_add ( json_data , ""accept"" , json_object_new_int ( ( int ) vrrp -> accept ) ) ; json_object_object_add ( json_data , ""nopreempt"" , json_object_new_boolean ( vrrp -> nopreempt ) ) ; json_object_object_add ( json_data , ""preempt_delay"" , json_object_new_int ( ( int ) ( vrrp -> preempt_delay / TIMER_HZ ) ) ) ; json_object_object_add ( json_data , ""state"" , json_object_new_int ( vrrp -> state ) ) ; json_object_object_add ( json_data , ""wantstate"" , json_object_new_int ( vrrp -> wantstate ) ) ; json_object_object_add ( json_data , ""version"" , json_object_new_int ( vrrp -> version ) ) ; if ( vrrp -> script_backup ) json_object_object_add ( json_data , ""script_backup"" , json_object_new_string ( cmd_str ( vrrp -> script_backup ) ) ) ; if ( vrrp -> script_master ) json_object_object_add ( json_data , ""script_master"" , json_object_new_string ( cmd_str ( vrrp -> script_master ) ) ) ; if ( vrrp -> script_fault ) json_object_object_add ( json_data , ""script_fault"" , json_object_new_string ( cmd_str ( vrrp -> script_fault ) ) ) ; if ( vrrp -> script_stop ) json_object_object_add ( json_data , ""script_stop"" , json_object_new_string ( cmd_str ( vrrp -> script_stop ) ) ) ; if ( vrrp -> script ) json_object_object_add ( json_data , ""script"" , json_object_new_string ( cmd_str ( vrrp -> script ) ) ) ; if ( vrrp -> script_master_rx_lower_pri ) json_object_object_add ( json_data , ""script_master_rx_lower_pri"" , json_object_new_string ( cmd_str ( vrrp -> script_master_rx_lower_pri ) ) ) ; json_object_object_add ( json_data , ""smtp_alert"" , json_object_new_boolean ( vrrp -> smtp_alert ) ) ; # ifdef _WITH_VRRP_AUTH_ if ( vrrp -> auth_type ) { json_object_object_add ( json_data , ""auth_type"" , json_object_new_int ( vrrp -> auth_type ) ) ; if ( vrrp -> auth_type != VRRP_AUTH_AH ) { char auth_data [ sizeof ( vrrp -> auth_data ) + 1 ] ; memcpy ( auth_data , vrrp -> auth_data , sizeof ( vrrp -> auth_data ) ) ; auth_data [ sizeof ( vrrp -> auth_data ) ] = '\\0' ; json_object_object_add ( json_data , ""auth_data"" , json_object_new_string ( auth_data ) ) ; } } else json_object_object_add ( json_data , ""auth_type"" , json_object_new_int ( 0 ) ) ; # endif json_object_object_add ( json_stats , ""advert_rcvd"" , json_object_new_int64 ( ( int64_t ) vrrp -> stats -> advert_rcvd ) ) ; json_object_object_add ( json_stats , ""advert_sent"" , json_object_new_int64 ( vrrp -> stats -> advert_sent ) ) ; json_object_object_add ( json_stats , ""become_master"" , json_object_new_int64 ( vrrp -> stats -> become_master ) ) ; json_object_object_add ( json_stats , ""release_master"" , json_object_new_int64 ( vrrp -> stats -> release_master ) ) ; json_object_object_add ( json_stats , ""packet_len_err"" , json_object_new_int64 ( ( int64_t ) vrrp -> stats -> packet_len_err ) ) ; json_object_object_add ( json_stats , ""advert_interval_err"" , json_object_new_int64 ( ( int64_t ) vrrp -> stats -> advert_interval_err ) ) ; json_object_object_add ( json_stats , ""ip_ttl_err"" , json_object_new_int64 ( ( int64_t ) vrrp -> stats -> ip_ttl_err ) ) ; json_object_object_add ( json_stats , ""invalid_type_rcvd"" , json_object_new_int64 ( ( int64_t ) vrrp -> stats -> invalid_type_rcvd ) ) ; json_object_object_add ( json_stats , ""addr_list_err"" , json_object_new_int64 ( ( int64_t ) vrrp -> stats -> addr_list_err ) ) ; json_object_object_add ( json_stats , ""invalid_authtype"" , json_object_new_int64 ( vrrp -> stats -> invalid_authtype ) ) ; # ifdef _WITH_VRRP_AUTH_ json_object_object_add ( json_stats , ""authtype_mismatch"" , json_object_new_int64 ( vrrp -> stats -> authtype_mismatch ) ) ; json_object_object_add ( json_stats , ""auth_failure"" , json_object_new_int64 ( vrrp -> stats -> auth_failure ) ) ; # endif json_object_object_add ( json_stats , ""pri_zero_rcvd"" , json_object_new_int64 ( ( int64_t ) vrrp -> stats -> pri_zero_rcvd ) ) ; json_object_object_add ( json_stats , ""pri_zero_sent"" , json_object_new_int64 ( ( int64_t ) vrrp -> stats -> pri_zero_sent ) ) ; json_object_object_add ( instance_json , ""data"" , json_data ) ; json_object_object_add ( instance_json , ""stats"" , json_stats ) ; json_object_array_add ( array , instance_json ) ; } fprintf ( file , ""%s"" , json_object_to_json_string ( array ) ) ; fclose ( file ) ; }","; file = fopen_safe <S2SV_ModEnd> ( ""/tmp/keepalived.json"" ,"
766,"int pdf_load_xrefs ( FILE * fp , pdf_t * pdf ) { int i , ver , is_linear ; long pos , pos_count ; char x , * c , buf [ 256 ] ; c = NULL ; pdf -> n_xrefs = 0 ; fseek ( fp , 0 , SEEK_SET ) ; while ( get_next_eof ( fp ) >= 0 ) ++ pdf -> n_xrefs ; if ( ! pdf -> n_xrefs ) return 0 ; fseek ( fp , 0 , SEEK_SET ) ; <S2SV_StartBug> pdf -> xrefs = calloc ( 1 , sizeof ( xref_t ) * pdf -> n_xrefs ) ; <S2SV_EndBug> ver = 1 ; for ( i = 0 ; i < pdf -> n_xrefs ; i ++ ) { if ( ( pos = get_next_eof ( fp ) ) < 0 ) break ; pdf -> xrefs [ i ] . version = ver ++ ; pos_count = 0 ; while ( SAFE_F ( fp , ( ( x = fgetc ( fp ) ) != 'f' ) ) ) fseek ( fp , pos - ( ++ pos_count ) , SEEK_SET ) ; if ( pos_count >= sizeof ( buf ) ) { ERR ( ""Failed<S2SV_blank>to<S2SV_blank>locate<S2SV_blank>the<S2SV_blank>startxref<S2SV_blank>token.<S2SV_blank>"" ""This<S2SV_blank>might<S2SV_blank>be<S2SV_blank>a<S2SV_blank>corrupt<S2SV_blank>PDF.\\n"" ) ; return - 1 ; } memset ( buf , 0 , sizeof ( buf ) ) ; SAFE_E ( fread ( buf , 1 , pos_count , fp ) , pos_count , ""Failed<S2SV_blank>to<S2SV_blank>read<S2SV_blank>startxref.\\n"" ) ; c = buf ; while ( * c == '<S2SV_blank>' || * c == '\\n' || * c == '\\r' ) ++ c ; pdf -> xrefs [ i ] . start = atol ( c ) ; if ( pdf -> xrefs [ i ] . start == 0 ) get_xref_linear_skipped ( fp , & pdf -> xrefs [ i ] ) ; else { pos = ftell ( fp ) ; fseek ( fp , pdf -> xrefs [ i ] . start , SEEK_SET ) ; pdf -> xrefs [ i ] . end = get_next_eof ( fp ) ; fseek ( fp , pos , SEEK_SET ) ; } if ( ! is_valid_xref ( fp , pdf , & pdf -> xrefs [ i ] ) ) { is_linear = pdf -> xrefs [ i ] . is_linear ; memset ( & pdf -> xrefs [ i ] , 0 , sizeof ( xref_t ) ) ; pdf -> xrefs [ i ] . is_linear = is_linear ; rewind ( fp ) ; get_next_eof ( fp ) ; continue ; } load_xref_entries ( fp , & pdf -> xrefs [ i ] ) ; } if ( pdf -> xrefs [ 0 ] . is_linear ) resolve_linearized_pdf ( pdf ) ; load_creator ( fp , pdf ) ; return pdf -> n_xrefs ; }",-> xrefs = safe_calloc ( <S2SV_ModEnd> sizeof ( xref_t
767,"static int crypto_report ( struct sk_buff * in_skb , struct nlmsghdr * in_nlh , struct nlattr * * attrs ) { struct net * net = sock_net ( in_skb -> sk ) ; struct crypto_user_alg * p = nlmsg_data ( in_nlh ) ; struct crypto_alg * alg ; struct sk_buff * skb ; struct crypto_dump_info info ; int err ; if ( ! null_terminated ( p -> cru_name ) || ! null_terminated ( p -> cru_driver_name ) ) return - EINVAL ; alg = crypto_alg_match ( p , 0 ) ; if ( ! alg ) return - ENOENT ; err = - ENOMEM ; skb = nlmsg_new ( NLMSG_DEFAULT_SIZE , GFP_KERNEL ) ; if ( ! skb ) goto drop_alg ; info . in_skb = in_skb ; info . out_skb = skb ; info . nlmsg_seq = in_nlh -> nlmsg_seq ; info . nlmsg_flags = 0 ; err = crypto_report_alg ( alg , & info ) ; drop_alg : crypto_mod_put ( alg ) ; if ( err ) <S2SV_StartBug> return err ; <S2SV_EndBug> return nlmsg_unicast ( net -> crypto_nlsk , skb , NETLINK_CB ( in_skb ) . portid ) ; }",( err ) { kfree_skb ( skb ) ; return err ; } <S2SV_ModEnd> return nlmsg_unicast (
768,"static void __munlock_pagevec ( struct pagevec * pvec , struct zone * zone ) { int i ; int nr = pagevec_count ( pvec ) ; <S2SV_StartBug> int delta_munlocked ; <S2SV_EndBug> struct pagevec pvec_putback ; int pgrescued = 0 ; pagevec_init ( & pvec_putback , 0 ) ; spin_lock_irq ( zone_lru_lock ( zone ) ) ; for ( i = 0 ; i < nr ; i ++ ) { struct page * page = pvec -> pages [ i ] ; if ( TestClearPageMlocked ( page ) ) { if ( __munlock_isolate_lru_page ( page , false ) ) continue ; else __munlock_isolation_failed ( page ) ; <S2SV_StartBug> } <S2SV_EndBug> pagevec_add ( & pvec_putback , pvec -> pages [ i ] ) ; pvec -> pages [ i ] = NULL ; } <S2SV_StartBug> delta_munlocked = - nr + pagevec_count ( & pvec_putback ) ; <S2SV_EndBug> __mod_zone_page_state ( zone , NR_MLOCK , delta_munlocked ) ; spin_unlock_irq ( zone_lru_lock ( zone ) ) ; pagevec_release ( & pvec_putback ) ; for ( i = 0 ; i < nr ; i ++ ) { struct page * page = pvec -> pages [ i ] ; if ( page ) { lock_page ( page ) ; if ( ! __putback_lru_fast_prepare ( page , & pvec_putback , & pgrescued ) ) { get_page ( page ) ; __munlock_isolated_page ( page ) ; unlock_page ( page ) ; put_page ( page ) ; } } } if ( pagevec_count ( & pvec_putback ) ) __putback_lru_fast ( & pvec_putback , pgrescued ) ; }",; int delta_munlocked = - nr <S2SV_ModStart> ) ; } else { delta_munlocked ++ ; } <S2SV_ModStart> NULL ; } <S2SV_ModEnd> __mod_zone_page_state ( zone
769,"static int choose_volume ( struct archive_read * a , struct iso9660 * iso9660 ) { struct file_info * file ; int64_t skipsize ; struct vd * vd ; const void * block ; char seenJoliet ; vd = & ( iso9660 -> primary ) ; if ( ! iso9660 -> opt_support_joliet ) iso9660 -> seenJoliet = 0 ; if ( iso9660 -> seenJoliet && vd -> location > iso9660 -> joliet . location ) vd = & ( iso9660 -> joliet ) ; <S2SV_StartBug> skipsize = LOGICAL_BLOCK_SIZE * vd -> location ; <S2SV_EndBug> skipsize = __archive_read_consume ( a , skipsize ) ; if ( skipsize < 0 ) return ( ( int ) skipsize ) ; iso9660 -> current_position = skipsize ; block = __archive_read_ahead ( a , vd -> size , NULL ) ; if ( block == NULL ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC , ""Failed<S2SV_blank>to<S2SV_blank>read<S2SV_blank>full<S2SV_blank>block<S2SV_blank>when<S2SV_blank>scanning<S2SV_blank>"" ""ISO9660<S2SV_blank>directory<S2SV_blank>list"" ) ; return ( ARCHIVE_FATAL ) ; } seenJoliet = iso9660 -> seenJoliet ; iso9660 -> seenJoliet = 0 ; file = parse_file_info ( a , NULL , block ) ; if ( file == NULL ) return ( ARCHIVE_FATAL ) ; iso9660 -> seenJoliet = seenJoliet ; if ( vd == & ( iso9660 -> primary ) && iso9660 -> seenRockridge && iso9660 -> seenJoliet ) iso9660 -> seenJoliet = 0 ; if ( vd == & ( iso9660 -> primary ) && ! iso9660 -> seenRockridge && iso9660 -> seenJoliet ) { vd = & ( iso9660 -> joliet ) ; <S2SV_StartBug> skipsize = LOGICAL_BLOCK_SIZE * vd -> location ; <S2SV_EndBug> skipsize -= iso9660 -> current_position ; skipsize = __archive_read_consume ( a , skipsize ) ; if ( skipsize < 0 ) return ( ( int ) skipsize ) ; iso9660 -> current_position += skipsize ; block = __archive_read_ahead ( a , vd -> size , NULL ) ; if ( block == NULL ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC , ""Failed<S2SV_blank>to<S2SV_blank>read<S2SV_blank>full<S2SV_blank>block<S2SV_blank>when<S2SV_blank>scanning<S2SV_blank>"" ""ISO9660<S2SV_blank>directory<S2SV_blank>list"" ) ; return ( ARCHIVE_FATAL ) ; } iso9660 -> seenJoliet = 0 ; file = parse_file_info ( a , NULL , block ) ; if ( file == NULL ) return ( ARCHIVE_FATAL ) ; iso9660 -> seenJoliet = seenJoliet ; } if ( add_entry ( a , iso9660 , file ) != ARCHIVE_OK ) return ( ARCHIVE_FATAL ) ; if ( iso9660 -> seenRockridge ) { a -> archive . archive_format = ARCHIVE_FORMAT_ISO9660_ROCKRIDGE ; a -> archive . archive_format_name = ""ISO9660<S2SV_blank>with<S2SV_blank>Rockridge<S2SV_blank>extensions"" ; } return ( ARCHIVE_OK ) ; }",= LOGICAL_BLOCK_SIZE * ( int64_t ) <S2SV_ModStart> = LOGICAL_BLOCK_SIZE * ( int64_t )
770,"static int smb_send_rqst ( struct TCP_Server_Info * server , struct smb_rqst * rqst ) { int rc ; struct kvec * iov = rqst -> rq_iov ; int n_vec = rqst -> rq_nvec ; unsigned int smb_buf_length = get_rfc1002_length ( iov [ 0 ] . iov_base ) ; unsigned int i ; size_t total_len = 0 , sent ; struct socket * ssocket = server -> ssocket ; <S2SV_StartBug> int val = 1 ; <S2SV_EndBug> cFYI ( 1 , ""Sending<S2SV_blank>smb:<S2SV_blank>smb_len=%u"" , smb_buf_length ) ; dump_smb ( iov [ 0 ] . iov_base , iov [ 0 ] . iov_len ) ; kernel_setsockopt ( ssocket , SOL_TCP , TCP_CORK , ( char * ) & val , sizeof ( val ) ) ; rc = smb_send_kvec ( server , iov , n_vec , & sent ) ; if ( rc < 0 ) goto uncork ; total_len += sent ; for ( i = 0 ; i < rqst -> rq_npages ; i ++ ) { struct kvec p_iov ; cifs_rqst_page_to_kvec ( rqst , i , & p_iov ) ; rc = smb_send_kvec ( server , & p_iov , 1 , & sent ) ; kunmap ( rqst -> rq_pages [ i ] ) ; if ( rc < 0 ) break ; total_len += sent ; } uncork : val = 0 ; kernel_setsockopt ( ssocket , SOL_TCP , TCP_CORK , ( char * ) & val , sizeof ( val ) ) ; if ( ( total_len > 0 ) && ( total_len != smb_buf_length + 4 ) ) { cFYI ( 1 , ""partial<S2SV_blank>send<S2SV_blank>(wanted=%u<S2SV_blank>sent=%zu):<S2SV_blank>terminating<S2SV_blank>"" ""session"" , smb_buf_length + 4 , total_len ) ; server -> tcpStatus = CifsNeedReconnect ; } if ( rc < 0 && rc != - EINTR ) cERROR ( 1 , ""Error<S2SV_blank>%d<S2SV_blank>sending<S2SV_blank>data<S2SV_blank>on<S2SV_blank>socket<S2SV_blank>to<S2SV_blank>server"" , rc ) ; else rc = 0 ; return rc ; }",val = 1 ; if ( ssocket == NULL ) return - ENOTSOCK
771,"void vp9_copy_and_extend_frame ( const YV12_BUFFER_CONFIG * src , YV12_BUFFER_CONFIG * dst ) { const int et_y = 16 ; const int el_y = 16 ; <S2SV_StartBug> const int eb_y = MAX ( ALIGN_POWER_OF_TWO ( src -> y_width , 6 ) - src -> y_width , <S2SV_EndBug> 16 ) ; const int er_y = MAX ( ALIGN_POWER_OF_TWO ( src -> y_height , 6 ) - src -> y_height , 16 ) ; const int uv_width_subsampling = ( src -> uv_width != src -> y_width ) ; const int uv_height_subsampling = ( src -> uv_height != src -> y_height ) ; const int et_uv = et_y >> uv_height_subsampling ; const int el_uv = el_y >> uv_width_subsampling ; const int eb_uv = eb_y >> uv_height_subsampling ; const int er_uv = er_y >> uv_width_subsampling ; <S2SV_StartBug> # if CONFIG_ALPHA <S2SV_EndBug> const int et_a = dst -> border >> ( dst -> alpha_height != dst -> y_height ) ; const int el_a = dst -> border >> ( dst -> alpha_width != dst -> y_width ) ; const int eb_a = et_a + dst -> alpha_height - src -> alpha_height ; const int er_a = el_a + dst -> alpha_width - src -> alpha_width ; copy_and_extend_plane ( src -> alpha_buffer , src -> alpha_stride , dst -> alpha_buffer , dst -> alpha_stride , src -> alpha_width , src -> alpha_height , et_a , el_a , eb_a , er_a ) ; # endif copy_and_extend_plane ( src -> y_buffer , src -> y_stride , dst -> y_buffer , dst -> y_stride , <S2SV_StartBug> src -> y_width , src -> y_height , <S2SV_EndBug> et_y , el_y , eb_y , er_y ) ; copy_and_extend_plane ( src -> u_buffer , src -> uv_stride , dst -> u_buffer , dst -> uv_stride , <S2SV_StartBug> src -> uv_width , src -> uv_height , <S2SV_EndBug> et_uv , el_uv , eb_uv , er_uv ) ; copy_and_extend_plane ( src -> v_buffer , src -> uv_stride , dst -> v_buffer , dst -> uv_stride , <S2SV_StartBug> src -> uv_width , src -> uv_height , <S2SV_EndBug> et_uv , el_uv , eb_uv , er_uv ) ; }","; const int er_y = MAX ( src -> y_width + 16 , ALIGN_POWER_OF_TWO ( src -> y_width , 6 ) ) - src -> y_crop_width ; const int <S2SV_ModStart> = MAX ( src -> y_height + 16 , <S2SV_ModStart> ( src -> y_height <S2SV_ModEnd> , 6 ) <S2SV_ModStart> , 6 ) ) <S2SV_ModStart> - src -> y_crop_height <S2SV_ModEnd> ; const int <S2SV_ModStart> ; # if CONFIG_VP9_HIGHBITDEPTH if ( src -> flags & YV12_FLAG_HIGHBITDEPTH ) { highbd_copy_and_extend_plane ( src -> y_buffer , src -> y_stride , dst -> y_buffer , dst -> y_stride , src -> y_crop_width , src -> y_crop_height , et_y , el_y , eb_y , er_y ) ; highbd_copy_and_extend_plane ( src -> u_buffer , src -> uv_stride , dst -> u_buffer , dst -> uv_stride , src -> uv_crop_width , src -> uv_crop_height , et_uv , el_uv , eb_uv , er_uv ) ; highbd_copy_and_extend_plane ( src -> v_buffer , src -> uv_stride , dst -> v_buffer , dst -> uv_stride , src -> uv_crop_width , src -> uv_crop_height , et_uv , el_uv , eb_uv , er_uv ) ; return ; } <S2SV_ModEnd> # endif copy_and_extend_plane <S2SV_ModStart> , src -> y_crop_width , src -> y_crop_height <S2SV_ModEnd> , et_y , <S2SV_ModStart> , src -> uv_crop_width , src -> uv_crop_height <S2SV_ModEnd> , et_uv , <S2SV_ModStart> , src -> uv_crop_width , src -> uv_crop_height <S2SV_ModEnd> , et_uv ,"
772,"void * leak_malloc ( size_t bytes ) { <S2SV_StartBug> void * base = dlmalloc ( bytes + sizeof ( AllocationEntry ) ) ; <S2SV_EndBug> if ( base != NULL ) { pthread_mutex_lock ( & gAllocationsMutex ) ; intptr_t backtrace [ BACKTRACE_SIZE ] ; size_t numEntries = get_backtrace ( backtrace , BACKTRACE_SIZE ) ; AllocationEntry * header = ( AllocationEntry * ) base ; header -> entry = record_backtrace ( backtrace , numEntries , bytes ) ; header -> guard = GUARD ; base = ( AllocationEntry * ) base + 1 ; pthread_mutex_unlock ( & gAllocationsMutex ) ; } return base ; }",bytes ) { size_t size = bytes + sizeof ( AllocationEntry ) ; if ( size < bytes ) { return NULL ; } <S2SV_ModStart> = dlmalloc ( size <S2SV_ModEnd> ) ; if
773,"WORD32 ih264d_mark_err_slice_skip ( dec_struct_t * ps_dec , WORD32 num_mb_skip , UWORD8 u1_is_idr_slice , UWORD16 u2_frame_num , pocstruct_t * ps_cur_poc , WORD32 prev_slice_err ) { WORD32 i2_cur_mb_addr ; UWORD32 u1_num_mbs , u1_num_mbsNby2 ; UWORD32 u1_mb_idx = ps_dec -> u1_mb_idx ; UWORD32 i2_mb_skip_run ; UWORD32 u1_num_mbs_next , u1_end_of_row ; const UWORD32 i2_pic_wdin_mbs = ps_dec -> u2_frm_wd_in_mbs ; UWORD32 u1_slice_end ; UWORD32 u1_tfr_n_mb ; UWORD32 u1_decode_nmb ; dec_bit_stream_t * const ps_bitstrm = ps_dec -> ps_bitstrm ; dec_slice_params_t * ps_slice = ps_dec -> ps_cur_slice ; UWORD32 * pu4_bitstrm_buf = ps_bitstrm -> pu4_buffer ; UWORD32 * pu4_bitstrm_ofst = & ps_bitstrm -> u4_ofst ; deblk_mb_t * ps_cur_deblk_mb ; dec_mb_info_t * ps_cur_mb_info ; parse_pmbarams_t * ps_parse_mb_data ; UWORD32 u1_inter_mb_type ; UWORD32 u1_deblk_mb_type ; UWORD16 u2_total_mbs_coded ; UWORD32 u1_mbaff = ps_slice -> u1_mbaff_frame_flag ; parse_part_params_t * ps_part_info ; WORD32 ret ; if ( ps_dec -> ps_dec_err_status -> u1_err_flag & REJECT_CUR_PIC ) { ih264d_err_pic_dispbuf_mgr ( ps_dec ) ; return 0 ; } if ( prev_slice_err == 1 ) { ps_dec -> ps_cur_slice -> u2_frame_num = u2_frame_num ; if ( ! ps_dec -> u1_first_slice_in_stream ) { ih264d_end_of_pic ( ps_dec , u1_is_idr_slice , ps_dec -> ps_cur_slice -> u2_frame_num ) ; ps_dec -> s_cur_pic_poc . u2_frame_num = ps_dec -> ps_cur_slice -> u2_frame_num ; } { WORD32 i , j , poc = 0 ; ps_dec -> ps_cur_slice -> u2_first_mb_in_slice = 0 ; ps_dec -> pf_mvpred = ih264d_mvpred_nonmbaff ; ps_dec -> p_form_mb_part_info = ih264d_form_mb_part_info_bp ; ps_dec -> p_motion_compensate = ih264d_motion_compensate_bp ; if ( ps_dec -> ps_cur_pic != NULL ) poc = ps_dec -> ps_cur_pic -> i4_poc + 2 ; j = 0 ; for ( i = 0 ; i < MAX_NUM_PIC_PARAMS ; i ++ ) if ( ps_dec -> ps_pps [ i ] . u1_is_valid == TRUE ) j = i ; { ret = ih264d_start_of_pic ( ps_dec , poc , ps_cur_poc , ps_dec -> ps_cur_slice -> u2_frame_num , & ps_dec -> ps_pps [ j ] ) ; if ( ret != OK ) { return ret ; } } ps_dec -> ps_ref_pic_buf_lx [ 0 ] [ 0 ] -> u1_pic_buf_id = 0 ; ps_dec -> u4_output_present = 0 ; { ih264d_get_next_display_field ( ps_dec , ps_dec -> ps_out_buffer , & ( ps_dec -> s_disp_op ) ) ; if ( 0 != ps_dec -> s_disp_op . u4_error_code ) { ps_dec -> u4_fmt_conv_cur_row = ps_dec -> s_disp_frame_info . u4_y_ht ; } else ps_dec -> u4_output_present = 1 ; } if ( ps_dec -> u1_separate_parse == 1 ) { if ( ps_dec -> u4_dec_thread_created == 0 ) { ithread_create ( ps_dec -> pv_dec_thread_handle , NULL , ( void * ) ih264d_decode_picture_thread , ( void * ) ps_dec ) ; ps_dec -> u4_dec_thread_created = 1 ; } if ( ( ps_dec -> u4_num_cores == 3 ) && ( ( ps_dec -> u4_app_disable_deblk_frm == 0 ) || ps_dec -> i1_recon_in_thread3_flag ) && ( ps_dec -> u4_bs_deblk_thread_created == 0 ) ) { ps_dec -> u4_start_recon_deblk = 0 ; ithread_create ( ps_dec -> pv_bs_deblk_thread_handle , NULL , ( void * ) ih264d_recon_deblk_thread , ( void * ) ps_dec ) ; ps_dec -> u4_bs_deblk_thread_created = 1 ; } } } } else { dec_slice_struct_t * ps_parse_cur_slice ; ps_parse_cur_slice = ps_dec -> ps_dec_slice_buf + ps_dec -> u2_cur_slice_num ; if ( ps_dec -> u1_slice_header_done && ps_parse_cur_slice == ps_dec -> ps_parse_cur_slice ) { u1_num_mbs = ps_dec -> u4_num_mbs_cur_nmb ; if ( u1_num_mbs ) { ps_cur_mb_info = ps_dec -> ps_nmb_info + u1_num_mbs - 1 ; } else { if ( ps_dec -> u1_separate_parse ) { ps_cur_mb_info = ps_dec -> ps_nmb_info - 1 ; } else { ps_cur_mb_info = ps_dec -> ps_nmb_info + ps_dec -> u4_num_mbs_prev_nmb - 1 ; } } ps_dec -> u2_mby = ps_cur_mb_info -> u2_mby ; ps_dec -> u2_mbx = ps_cur_mb_info -> u2_mbx ; ps_dec -> u1_mb_ngbr_availablity = ps_cur_mb_info -> u1_mb_ngbr_availablity ; ps_dec -> pv_parse_tu_coeff_data = ps_dec -> pv_prev_mb_parse_tu_coeff_data ; ps_dec -> u2_cur_mb_addr -- ; ps_dec -> i4_submb_ofst -= SUB_BLK_SIZE ; if ( u1_num_mbs ) { if ( ps_dec -> u1_pr_sl_type == P_SLICE || ps_dec -> u1_pr_sl_type == B_SLICE ) { ps_dec -> pf_mvpred_ref_tfr_nby2mb ( ps_dec , u1_mb_idx , u1_num_mbs ) ; ps_dec -> ps_part = ps_dec -> ps_parse_part_params ; } u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec -> u2_mbx - 1 ; u1_end_of_row = ( ! u1_num_mbs_next ) && ( ! ( u1_mbaff && ( u1_num_mbs & 0x01 ) ) ) ; u1_slice_end = 1 ; u1_tfr_n_mb = 1 ; ps_cur_mb_info -> u1_end_of_slice = u1_slice_end ; if ( ps_dec -> u1_separate_parse ) { ih264d_parse_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; ps_dec -> ps_nmb_info += u1_num_mbs ; } else { ih264d_decode_recon_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; } <S2SV_StartBug> ps_dec -> u1_mb_idx = 0 ; <S2SV_EndBug> ps_dec -> u4_num_mbs_cur_nmb = 0 ; } if ( ps_dec -> u2_total_mbs_coded >= ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) { ps_dec -> u1_pic_decode_done = 1 ; return 0 ; } ps_dec -> u2_cur_slice_num ++ ; ps_dec -> i2_prev_slice_mbx = ps_dec -> u2_mbx ; ps_dec -> i2_prev_slice_mby = ps_dec -> u2_mby ; ps_dec -> ps_parse_cur_slice ++ ; } else { ps_dec -> ps_parse_cur_slice = ps_dec -> ps_dec_slice_buf + ps_dec -> u2_cur_slice_num ; } } { WORD32 num_entries ; WORD32 size ; UWORD8 * pu1_buf ; num_entries = MIN ( MAX_FRAMES , ps_dec -> u4_num_ref_frames_at_init ) ; num_entries = 2 * ( ( 2 * num_entries ) + 1 ) ; size = num_entries * sizeof ( void * ) ; size += PAD_MAP_IDX_POC * sizeof ( void * ) ; pu1_buf = ( UWORD8 * ) ps_dec -> pv_map_ref_idx_to_poc_buf ; pu1_buf += size * ps_dec -> u2_cur_slice_num ; ps_dec -> ps_parse_cur_slice -> ppv_map_ref_idx_to_poc = ( volatile void * * ) pu1_buf ; } ps_dec -> ps_cur_slice -> u2_first_mb_in_slice = ps_dec -> u2_total_mbs_coded << u1_mbaff ; if ( ps_dec -> ps_cur_slice -> u1_field_pic_flag ) ps_dec -> u2_prv_frame_num = ps_dec -> ps_cur_slice -> u2_frame_num ; ps_dec -> ps_parse_cur_slice -> u4_first_mb_in_slice = ps_dec -> u2_total_mbs_coded << u1_mbaff ; ps_dec -> ps_parse_cur_slice -> u2_log2Y_crwd = ps_dec -> ps_cur_slice -> u2_log2Y_crwd ; if ( ps_dec -> u1_separate_parse ) { ps_dec -> ps_parse_cur_slice -> pv_tu_coeff_data_start = ps_dec -> pv_parse_tu_coeff_data ; } else { ps_dec -> pv_proc_tu_coeff_data = ps_dec -> pv_parse_tu_coeff_data ; } u1_inter_mb_type = P_MB ; u1_deblk_mb_type = D_INTER_MB ; ps_dec -> ps_cur_slice -> u1_slice_type = P_SLICE ; ps_dec -> ps_parse_cur_slice -> slice_type = P_SLICE ; ps_dec -> pf_mvpred_ref_tfr_nby2mb = ih264d_mv_pred_ref_tfr_nby2_pmb ; ps_dec -> ps_part = ps_dec -> ps_parse_part_params ; ps_dec -> u1_slice_header_done = 2 ; ps_dec -> u1_qp = ps_slice -> u1_slice_qp ; ih264d_update_qp ( ps_dec , 0 ) ; u1_mb_idx = ps_dec -> u1_mb_idx ; ps_parse_mb_data = ps_dec -> ps_parse_mb_data ; u1_num_mbs = u1_mb_idx ; u1_slice_end = 0 ; u1_tfr_n_mb = 0 ; u1_decode_nmb = 0 ; u1_num_mbsNby2 = 0 ; i2_cur_mb_addr = ps_dec -> u2_total_mbs_coded ; i2_mb_skip_run = num_mb_skip ; while ( ! u1_slice_end ) { UWORD8 u1_mb_type ; if ( i2_cur_mb_addr > ps_dec -> ps_cur_sps -> u2_max_mb_addr ) break ; ps_cur_mb_info = ps_dec -> ps_nmb_info + u1_num_mbs ; ps_dec -> u4_num_mbs_cur_nmb = u1_num_mbs ; ps_cur_mb_info -> u1_Mux = 0 ; ps_dec -> u4_num_pmbair = ( u1_num_mbs >> u1_mbaff ) ; ps_cur_deblk_mb = ps_dec -> ps_deblk_mbn + u1_num_mbs ; ps_cur_mb_info -> u1_end_of_slice = 0 ; ps_parse_mb_data -> u1_num_part = 1 ; ps_parse_mb_data -> u1_isI_mb = 0 ; if ( u1_mbaff ) ih264d_get_mb_info_cavlc_mbaff ( ps_dec , i2_cur_mb_addr , ps_cur_mb_info , i2_mb_skip_run ) ; else ih264d_get_mb_info_cavlc_nonmbaff ( ps_dec , i2_cur_mb_addr , ps_cur_mb_info , i2_mb_skip_run ) ; if ( ps_dec -> u4_app_disable_deblk_frm == 0 ) { ih264d_set_deblocking_parameters ( ps_cur_deblk_mb , ps_slice , ps_dec -> u1_mb_ngbr_availablity , ps_dec -> u1_cur_mb_fld_dec_flag ) ; } ps_dec -> i1_prev_mb_qp_delta = 0 ; ps_dec -> u1_sub_mb_num = 0 ; ps_cur_mb_info -> u1_mb_type = MB_SKIP ; ps_cur_mb_info -> u1_mb_mc_mode = PRED_16x16 ; ps_cur_mb_info -> u1_cbp = 0 ; ps_part_info = ps_dec -> ps_part ; ps_part_info -> u1_is_direct = PART_DIRECT_16x16 ; ps_part_info -> u1_sub_mb_num = 0 ; ps_dec -> ps_part ++ ; ih264d_update_nnz_for_skipmb ( ps_dec , ps_cur_mb_info , CAVLC ) ; ps_cur_mb_info -> ps_curmb -> u1_mb_type = u1_inter_mb_type ; ps_cur_deblk_mb -> u1_mb_type |= u1_deblk_mb_type ; i2_mb_skip_run -- ; ps_cur_deblk_mb -> u1_mb_qp = ps_dec -> u1_qp ; if ( u1_mbaff ) { ih264d_update_mbaff_left_nnz ( ps_dec , ps_cur_mb_info ) ; } i2_cur_mb_addr ++ ; u1_num_mbs ++ ; <S2SV_StartBug> ps_dec -> u2_total_mbs_coded ++ ; <S2SV_EndBug> u1_num_mbsNby2 ++ ; ps_parse_mb_data ++ ; u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec -> u2_mbx - 1 ; u1_end_of_row = ( ! u1_num_mbs_next ) && ( ! ( u1_mbaff && ( u1_num_mbs & 0x01 ) ) ) ; u1_slice_end = ! i2_mb_skip_run ; u1_tfr_n_mb = ( u1_num_mbs == ps_dec -> u1_recon_mb_grp ) || u1_end_of_row || u1_slice_end ; u1_decode_nmb = u1_tfr_n_mb || u1_slice_end ; ps_cur_mb_info -> u1_end_of_slice = u1_slice_end ; if ( u1_decode_nmb ) { ps_dec -> pf_mvpred_ref_tfr_nby2mb ( ps_dec , u1_mb_idx , u1_num_mbs ) ; u1_num_mbsNby2 = 0 ; ps_parse_mb_data = ps_dec -> ps_parse_mb_data ; ps_dec -> ps_part = ps_dec -> ps_parse_part_params ; if ( ps_dec -> u1_separate_parse ) { ih264d_parse_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; ps_dec -> ps_nmb_info += u1_num_mbs ; } else { ih264d_decode_recon_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; } <S2SV_StartBug> if ( u1_tfr_n_mb ) <S2SV_EndBug> u1_num_mbs = 0 ; u1_mb_idx = u1_num_mbs ; ps_dec -> u1_mb_idx = u1_num_mbs ; } } ps_dec -> u4_num_mbs_cur_nmb = 0 ; ps_dec -> ps_cur_slice -> u4_mbs_in_slice = i2_cur_mb_addr - ps_dec -> ps_parse_cur_slice -> u4_first_mb_in_slice ; H264_DEC_DEBUG_PRINT ( ""Mbs<S2SV_blank>in<S2SV_blank>slice:<S2SV_blank>%d\\n"" , ps_dec -> ps_cur_slice -> u4_mbs_in_slice ) ; ps_dec -> u2_cur_slice_num ++ ; if ( ps_dec -> u4_first_slice_in_pic != 0 ) ps_dec -> ps_parse_cur_slice ++ ; ps_dec -> i2_prev_slice_mbx = ps_dec -> u2_mbx ; ps_dec -> i2_prev_slice_mby = ps_dec -> u2_mby ; if ( ps_dec -> u2_total_mbs_coded >= ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) { ps_dec -> u1_pic_decode_done = 1 ; } return 0 ; }",} ps_dec -> u2_total_mbs_coded += u1_num_mbs ; ps_dec -> <S2SV_ModStart> u1_num_mbs ++ ; <S2SV_ModEnd> u1_num_mbsNby2 ++ ; <S2SV_ModStart> ) ; } ps_dec -> u2_total_mbs_coded += u1_num_mbs ;
774,"static int bgp_attr_print ( netdissect_options * ndo , u_int atype , const u_char * pptr , u_int len ) { int i ; uint16_t af ; uint8_t safi , snpa , nhlen ; union { float f ; uint32_t i ; } bw ; int advance ; u_int tlen ; const u_char * tptr ; char buf [ MAXHOSTNAMELEN + 100 ] ; int as_size ; tptr = pptr ; tlen = len ; switch ( atype ) { case BGPTYPE_ORIGIN : if ( len != 1 ) ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; else { ND_TCHECK ( * tptr ) ; ND_PRINT ( ( ndo , ""%s"" , tok2str ( bgp_origin_values , ""Unknown<S2SV_blank>Origin<S2SV_blank>Typecode"" , tptr [ 0 ] ) ) ) ; } break ; case BGPTYPE_AS4_PATH : case BGPTYPE_AS_PATH : if ( len % 2 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } if ( ! len ) { ND_PRINT ( ( ndo , ""empty"" ) ) ; break ; } as_size = bgp_attr_get_as_size ( ndo , atype , pptr , len ) ; while ( tptr < pptr + len ) { ND_TCHECK ( tptr [ 0 ] ) ; ND_PRINT ( ( ndo , ""%s"" , tok2str ( bgp_as_path_segment_open_values , ""?"" , tptr [ 0 ] ) ) ) ; ND_TCHECK ( tptr [ 1 ] ) ; for ( i = 0 ; i < tptr [ 1 ] * as_size ; i += as_size ) { ND_TCHECK2 ( tptr [ 2 + i ] , as_size ) ; ND_PRINT ( ( ndo , ""%s<S2SV_blank>"" , as_printf ( ndo , astostr , sizeof ( astostr ) , as_size == 2 ? EXTRACT_16BITS ( & tptr [ 2 + i ] ) : EXTRACT_32BITS ( & tptr [ 2 + i ] ) ) ) ) ; } ND_TCHECK ( tptr [ 0 ] ) ; ND_PRINT ( ( ndo , ""%s"" , tok2str ( bgp_as_path_segment_close_values , ""?"" , tptr [ 0 ] ) ) ) ; ND_TCHECK ( tptr [ 1 ] ) ; tptr += 2 + tptr [ 1 ] * as_size ; } break ; case BGPTYPE_NEXT_HOP : if ( len != 4 ) ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; else { ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , tptr ) ) ) ; } break ; case BGPTYPE_MULTI_EXIT_DISC : case BGPTYPE_LOCAL_PREF : if ( len != 4 ) ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; else { ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , ""%u"" , EXTRACT_32BITS ( tptr ) ) ) ; } break ; case BGPTYPE_ATOMIC_AGGREGATE : if ( len != 0 ) ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; case BGPTYPE_AGGREGATOR : if ( len != 6 && len != 8 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } ND_TCHECK2 ( tptr [ 0 ] , len ) ; if ( len == 6 ) { ND_PRINT ( ( ndo , ""<S2SV_blank>AS<S2SV_blank>#%s,<S2SV_blank>origin<S2SV_blank>%s"" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_16BITS ( tptr ) ) , ipaddr_string ( ndo , tptr + 2 ) ) ) ; } else { ND_PRINT ( ( ndo , ""<S2SV_blank>AS<S2SV_blank>#%s,<S2SV_blank>origin<S2SV_blank>%s"" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( tptr ) ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; } break ; case BGPTYPE_AGGREGATOR4 : if ( len != 8 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , ""<S2SV_blank>AS<S2SV_blank>#%s,<S2SV_blank>origin<S2SV_blank>%s"" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( tptr ) ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; break ; case BGPTYPE_COMMUNITIES : if ( len % 4 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } while ( tlen > 0 ) { uint32_t comm ; ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; comm = EXTRACT_32BITS ( tptr ) ; switch ( comm ) { case BGP_COMMUNITY_NO_EXPORT : ND_PRINT ( ( ndo , ""<S2SV_blank>NO_EXPORT"" ) ) ; break ; case BGP_COMMUNITY_NO_ADVERT : ND_PRINT ( ( ndo , ""<S2SV_blank>NO_ADVERTISE"" ) ) ; break ; case BGP_COMMUNITY_NO_EXPORT_SUBCONFED : ND_PRINT ( ( ndo , ""<S2SV_blank>NO_EXPORT_SUBCONFED"" ) ) ; break ; default : ND_PRINT ( ( ndo , ""%u:%u%s"" , ( comm >> 16 ) & 0xffff , comm & 0xffff , ( tlen > 4 ) ? "",<S2SV_blank>"" : """" ) ) ; break ; } tlen -= 4 ; tptr += 4 ; } break ; case BGPTYPE_ORIGINATOR_ID : if ( len != 4 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , tptr ) ) ) ; break ; case BGPTYPE_CLUSTER_LIST : if ( len % 4 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } while ( tlen > 0 ) { ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , ""%s%s"" , ipaddr_string ( ndo , tptr ) , ( tlen > 4 ) ? "",<S2SV_blank>"" : """" ) ) ; tlen -= 4 ; tptr += 4 ; } break ; case BGPTYPE_MP_REACH_NLRI : ND_TCHECK2 ( tptr [ 0 ] , 3 ) ; af = EXTRACT_16BITS ( tptr ) ; safi = tptr [ 2 ] ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>AFI:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>%sSAFI:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( af_values , ""Unknown<S2SV_blank>AFI"" , af ) , af , ( safi > 128 ) ? ""vendor<S2SV_blank>specific<S2SV_blank>"" : """" , tok2str ( bgp_safi_values , ""Unknown<S2SV_blank>SAFI"" , safi ) , safi ) ) ; switch ( af << 8 | safi ) { case ( AFNUM_INET << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_LABUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_RT_ROUTING_INFO ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNIMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST_VPN ) : case ( AFNUM_INET << 8 | SAFNUM_MDT ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_LABUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNIMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNIMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNIMULTICAST ) : case ( AFNUM_VPLS << 8 | SAFNUM_VPLS ) : break ; default : ND_TCHECK2 ( tptr [ 0 ] , tlen ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>no<S2SV_blank>AFI<S2SV_blank>%u<S2SV_blank>/<S2SV_blank>SAFI<S2SV_blank>%u<S2SV_blank>decoder"" , af , safi ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , tlen ) ; goto done ; break ; } tptr += 3 ; ND_TCHECK ( tptr [ 0 ] ) ; nhlen = tptr [ 0 ] ; tlen = nhlen ; tptr ++ ; if ( tlen ) { int nnh = 0 ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>nexthop:<S2SV_blank>"" ) ) ; while ( tlen > 0 ) { if ( nnh ++ > 0 ) { ND_PRINT ( ( ndo , "",<S2SV_blank>"" ) ) ; } switch ( af << 8 | safi ) { case ( AFNUM_INET << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_LABUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_RT_ROUTING_INFO ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST_VPN ) : case ( AFNUM_INET << 8 | SAFNUM_MDT ) : if ( tlen < ( int ) sizeof ( struct in_addr ) ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in_addr ) ) ; ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , tptr ) ) ) ; tlen -= sizeof ( struct in_addr ) ; tptr += sizeof ( struct in_addr ) ; } break ; case ( AFNUM_INET << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNIMULTICAST ) : if ( tlen < ( int ) ( sizeof ( struct in_addr ) + BGP_VPN_RD_LEN ) ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in_addr ) + BGP_VPN_RD_LEN ) ; ND_PRINT ( ( ndo , ""RD:<S2SV_blank>%s,<S2SV_blank>%s"" , bgp_vpn_rd_print ( ndo , tptr ) , ipaddr_string ( ndo , tptr + BGP_VPN_RD_LEN ) ) ) ; tlen -= ( sizeof ( struct in_addr ) + BGP_VPN_RD_LEN ) ; tptr += ( sizeof ( struct in_addr ) + BGP_VPN_RD_LEN ) ; } break ; case ( AFNUM_INET6 << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_LABUNICAST ) : if ( tlen < ( int ) sizeof ( struct in6_addr ) ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in6_addr ) ) ; ND_PRINT ( ( ndo , ""%s"" , ip6addr_string ( ndo , tptr ) ) ) ; tlen -= sizeof ( struct in6_addr ) ; tptr += sizeof ( struct in6_addr ) ; } break ; case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNIMULTICAST ) : if ( tlen < ( int ) ( sizeof ( struct in6_addr ) + BGP_VPN_RD_LEN ) ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in6_addr ) + BGP_VPN_RD_LEN ) ; ND_PRINT ( ( ndo , ""RD:<S2SV_blank>%s,<S2SV_blank>%s"" , bgp_vpn_rd_print ( ndo , tptr ) , ip6addr_string ( ndo , tptr + BGP_VPN_RD_LEN ) ) ) ; tlen -= ( sizeof ( struct in6_addr ) + BGP_VPN_RD_LEN ) ; tptr += ( sizeof ( struct in6_addr ) + BGP_VPN_RD_LEN ) ; } break ; case ( AFNUM_VPLS << 8 | SAFNUM_VPLS ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNIMULTICAST ) : if ( tlen < ( int ) sizeof ( struct in_addr ) ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in_addr ) ) ; ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , tptr ) ) ) ; tlen -= ( sizeof ( struct in_addr ) ) ; tptr += ( sizeof ( struct in_addr ) ) ; } break ; case ( AFNUM_NSAP << 8 | SAFNUM_UNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNIMULTICAST ) : ND_TCHECK2 ( tptr [ 0 ] , tlen ) ; ND_PRINT ( ( ndo , ""%s"" , isonsap_string ( ndo , tptr , tlen ) ) ) ; tptr += tlen ; tlen = 0 ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNIMULTICAST ) : if ( tlen < BGP_VPN_RD_LEN + 1 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , tlen ) ; ND_PRINT ( ( ndo , ""RD:<S2SV_blank>%s,<S2SV_blank>%s"" , bgp_vpn_rd_print ( ndo , tptr ) , isonsap_string ( ndo , tptr + BGP_VPN_RD_LEN , tlen - BGP_VPN_RD_LEN ) ) ) ; if ( EXTRACT_32BITS ( tptr + BGP_VPN_RD_LEN ) == 0x47000601 ) ND_PRINT ( ( ndo , ""<S2SV_blank>=<S2SV_blank>%s"" , ipaddr_string ( ndo , tptr + BGP_VPN_RD_LEN + 4 ) ) ) ; else if ( EXTRACT_24BITS ( tptr + BGP_VPN_RD_LEN ) == 0x350000 ) ND_PRINT ( ( ndo , ""<S2SV_blank>=<S2SV_blank>%s"" , ip6addr_string ( ndo , tptr + BGP_VPN_RD_LEN + 3 ) ) ) ; tptr += tlen ; tlen = 0 ; } break ; default : ND_TCHECK2 ( tptr [ 0 ] , tlen ) ; ND_PRINT ( ( ndo , ""no<S2SV_blank>AFI<S2SV_blank>%u/SAFI<S2SV_blank>%u<S2SV_blank>decoder"" , af , safi ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , tlen ) ; tptr += tlen ; tlen = 0 ; goto done ; break ; } } } ND_PRINT ( ( ndo , "",<S2SV_blank>nh-length:<S2SV_blank>%u"" , nhlen ) ) ; tptr += tlen ; ND_TCHECK ( tptr [ 0 ] ) ; snpa = tptr [ 0 ] ; tptr ++ ; if ( snpa ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%u<S2SV_blank>SNPA"" , snpa ) ) ; for ( ; snpa > 0 ; snpa -- ) { ND_TCHECK ( tptr [ 0 ] ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%d<S2SV_blank>bytes"" , tptr [ 0 ] ) ) ; tptr += tptr [ 0 ] + 1 ; } } else { ND_PRINT ( ( ndo , "",<S2SV_blank>no<S2SV_blank>SNPA"" ) ) ; } while ( len - ( tptr - pptr ) > 0 ) { switch ( af << 8 | safi ) { case ( AFNUM_INET << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_prefix4 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_LABUNICAST ) : advance = decode_labeled_prefix4 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_prefix4 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_RT_ROUTING_INFO ) : advance = decode_rt_routing_info ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_MULTICAST_VPN ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST_VPN ) : advance = decode_multicast_vpn ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_MDT ) : advance = decode_mdt_vpn_nlri ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_prefix6 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_LABUNICAST ) : advance = decode_labeled_prefix6 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_prefix6 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_VPLS << 8 | SAFNUM_VPLS ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_l2 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_UNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_clnp_prefix ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_clnp_prefix ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; default : ND_TCHECK2 ( * tptr , tlen ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>no<S2SV_blank>AFI<S2SV_blank>%u<S2SV_blank>/<S2SV_blank>SAFI<S2SV_blank>%u<S2SV_blank>decoder"" , af , safi ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , tlen ) ; advance = 0 ; tptr = pptr + len ; break ; } if ( advance < 0 ) break ; tptr += advance ; } done : break ; case BGPTYPE_MP_UNREACH_NLRI : ND_TCHECK2 ( tptr [ 0 ] , BGP_MP_NLRI_MINSIZE ) ; af = EXTRACT_16BITS ( tptr ) ; safi = tptr [ 2 ] ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>AFI:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>%sSAFI:<S2SV_blank>%s<S2SV_blank>(%u)"" , tok2str ( af_values , ""Unknown<S2SV_blank>AFI"" , af ) , af , ( safi > 128 ) ? ""vendor<S2SV_blank>specific<S2SV_blank>"" : """" , tok2str ( bgp_safi_values , ""Unknown<S2SV_blank>SAFI"" , safi ) , safi ) ) ; if ( len == BGP_MP_NLRI_MINSIZE ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>End-of-Rib<S2SV_blank>Marker<S2SV_blank>(empty<S2SV_blank>NLRI)"" ) ) ; tptr += 3 ; while ( len - ( tptr - pptr ) > 0 ) { switch ( af << 8 | safi ) { case ( AFNUM_INET << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_prefix4 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_LABUNICAST ) : advance = decode_labeled_prefix4 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_prefix4 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_prefix6 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_LABUNICAST ) : advance = decode_labeled_prefix6 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_prefix6 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_VPLS << 8 | SAFNUM_VPLS ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_l2 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_UNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_clnp_prefix ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_clnp_prefix ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_MDT ) : advance = decode_mdt_vpn_nlri ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_MULTICAST_VPN ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST_VPN ) : advance = decode_multicast_vpn ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; break ; default : ND_TCHECK2 ( * ( tptr - 3 ) , tlen ) ; ND_PRINT ( ( ndo , ""no<S2SV_blank>AFI<S2SV_blank>%u<S2SV_blank>/<S2SV_blank>SAFI<S2SV_blank>%u<S2SV_blank>decoder"" , af , safi ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr - 3 , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , tlen ) ; advance = 0 ; tptr = pptr + len ; break ; } if ( advance < 0 ) break ; tptr += advance ; } break ; case BGPTYPE_EXTD_COMMUNITIES : if ( len % 8 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } while ( tlen > 0 ) { uint16_t extd_comm ; ND_TCHECK2 ( tptr [ 0 ] , 2 ) ; extd_comm = EXTRACT_16BITS ( tptr ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s<S2SV_blank>(0x%04x),<S2SV_blank>Flags<S2SV_blank>[%s]"" , tok2str ( bgp_extd_comm_subtype_values , ""unknown<S2SV_blank>extd<S2SV_blank>community<S2SV_blank>typecode"" , extd_comm ) , extd_comm , bittok2str ( bgp_extd_comm_flag_values , ""none"" , extd_comm ) ) ) ; ND_TCHECK2 ( * ( tptr + 2 ) , 6 ) ; switch ( extd_comm ) { case BGP_EXT_COM_RT_0 : case BGP_EXT_COM_RO_0 : case BGP_EXT_COM_L2VPN_RT_0 : ND_PRINT ( ( ndo , "":<S2SV_blank>%u:%u<S2SV_blank>(=<S2SV_blank>%s)"" , EXTRACT_16BITS ( tptr + 2 ) , EXTRACT_32BITS ( tptr + 4 ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; break ; case BGP_EXT_COM_RT_1 : case BGP_EXT_COM_RO_1 : case BGP_EXT_COM_L2VPN_RT_1 : case BGP_EXT_COM_VRF_RT_IMP : ND_PRINT ( ( ndo , "":<S2SV_blank>%s:%u"" , ipaddr_string ( ndo , tptr + 2 ) , EXTRACT_16BITS ( tptr + 6 ) ) ) ; break ; case BGP_EXT_COM_RT_2 : case BGP_EXT_COM_RO_2 : ND_PRINT ( ( ndo , "":<S2SV_blank>%s:%u"" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( tptr + 2 ) ) , EXTRACT_16BITS ( tptr + 6 ) ) ) ; break ; case BGP_EXT_COM_LINKBAND : bw . i = EXTRACT_32BITS ( tptr + 2 ) ; ND_PRINT ( ( ndo , "":<S2SV_blank>bandwidth:<S2SV_blank>%.3f<S2SV_blank>Mbps"" , bw . f * 8 / 1000000 ) ) ; break ; case BGP_EXT_COM_VPN_ORIGIN : case BGP_EXT_COM_VPN_ORIGIN2 : case BGP_EXT_COM_VPN_ORIGIN3 : case BGP_EXT_COM_VPN_ORIGIN4 : case BGP_EXT_COM_OSPF_RID : case BGP_EXT_COM_OSPF_RID2 : ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , tptr + 2 ) ) ) ; break ; case BGP_EXT_COM_OSPF_RTYPE : case BGP_EXT_COM_OSPF_RTYPE2 : ND_PRINT ( ( ndo , "":<S2SV_blank>area:%s,<S2SV_blank>router-type:%s,<S2SV_blank>metric-type:%s%s"" , ipaddr_string ( ndo , tptr + 2 ) , tok2str ( bgp_extd_comm_ospf_rtype_values , ""unknown<S2SV_blank>(0x%02x)"" , * ( tptr + 6 ) ) , ( * ( tptr + 7 ) & BGP_OSPF_RTYPE_METRIC_TYPE ) ? ""E2"" : """" , ( ( * ( tptr + 6 ) == BGP_OSPF_RTYPE_EXT ) || ( * ( tptr + 6 ) == BGP_OSPF_RTYPE_NSSA ) ) ? ""E1"" : """" ) ) ; break ; case BGP_EXT_COM_L2INFO : ND_PRINT ( ( ndo , "":<S2SV_blank>%s<S2SV_blank>Control<S2SV_blank>Flags<S2SV_blank>[0x%02x]:MTU<S2SV_blank>%u"" , tok2str ( l2vpn_encaps_values , ""unknown<S2SV_blank>encaps"" , * ( tptr + 2 ) ) , * ( tptr + 3 ) , EXTRACT_16BITS ( tptr + 4 ) ) ) ; break ; case BGP_EXT_COM_SOURCE_AS : ND_PRINT ( ( ndo , "":<S2SV_blank>AS<S2SV_blank>%u"" , EXTRACT_16BITS ( tptr + 2 ) ) ) ; break ; default : ND_TCHECK2 ( * tptr , 8 ) ; print_unknown_data ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , 8 ) ; break ; } tlen -= 8 ; tptr += 8 ; } break ; case BGPTYPE_PMSI_TUNNEL : { uint8_t tunnel_type , flags ; tunnel_type = * ( tptr + 1 ) ; flags = * tptr ; tlen = len ; ND_TCHECK2 ( tptr [ 0 ] , 5 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Tunnel-type<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>Flags<S2SV_blank>[%s],<S2SV_blank>MPLS<S2SV_blank>Label<S2SV_blank>%u"" , tok2str ( bgp_pmsi_tunnel_values , ""Unknown"" , tunnel_type ) , tunnel_type , bittok2str ( bgp_pmsi_flag_values , ""none"" , flags ) , EXTRACT_24BITS ( tptr + 2 ) >> 4 ) ) ; tptr += 5 ; tlen -= 5 ; switch ( tunnel_type ) { case BGP_PMSI_TUNNEL_PIM_SM : case BGP_PMSI_TUNNEL_PIM_BIDIR : ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Sender<S2SV_blank>%s,<S2SV_blank>P-Group<S2SV_blank>%s"" , ipaddr_string ( ndo , tptr ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; break ; case BGP_PMSI_TUNNEL_PIM_SSM : ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Root-Node<S2SV_blank>%s,<S2SV_blank>P-Group<S2SV_blank>%s"" , ipaddr_string ( ndo , tptr ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; break ; case BGP_PMSI_TUNNEL_INGRESS : ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Tunnel-Endpoint<S2SV_blank>%s"" , ipaddr_string ( ndo , tptr ) ) ) ; break ; case BGP_PMSI_TUNNEL_LDP_P2MP : case BGP_PMSI_TUNNEL_LDP_MP2MP : ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Root-Node<S2SV_blank>%s,<S2SV_blank>LSP-ID<S2SV_blank>0x%08x"" , ipaddr_string ( ndo , tptr ) , EXTRACT_32BITS ( tptr + 4 ) ) ) ; break ; case BGP_PMSI_TUNNEL_RSVP_P2MP : ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Extended-Tunnel-ID<S2SV_blank>%s,<S2SV_blank>P2MP-ID<S2SV_blank>0x%08x"" , ipaddr_string ( ndo , tptr ) , EXTRACT_32BITS ( tptr + 4 ) ) ) ; break ; default : if ( ndo -> ndo_vflag <= 1 ) { print_unknown_data ( ndo , tptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , tlen ) ; } } break ; } case BGPTYPE_AIGP : { uint8_t type ; uint16_t length ; <S2SV_StartBug> ND_TCHECK2 ( tptr [ 0 ] , 3 ) ; <S2SV_EndBug> <S2SV_StartBug> tlen = len ; <S2SV_EndBug> while ( tlen >= 3 ) { type = * tptr ; length = EXTRACT_16BITS ( tptr + 1 ) ; <S2SV_StartBug> ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s<S2SV_blank>TLV<S2SV_blank>(%u),<S2SV_blank>length<S2SV_blank>%u"" , <S2SV_EndBug> tok2str ( bgp_aigp_values , ""Unknown"" , type ) , <S2SV_StartBug> type , length ) ) ; <S2SV_EndBug> <S2SV_StartBug> ND_TCHECK2 ( tptr [ 3 ] , length - 3 ) ; <S2SV_EndBug> switch ( type ) { case BGP_AIGP_TLV : <S2SV_StartBug> ND_TCHECK2 ( tptr [ 3 ] , 8 ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , "",<S2SV_blank>metric<S2SV_blank>%"" PRIu64 , <S2SV_StartBug> EXTRACT_64BITS ( tptr + 3 ) ) ) ; <S2SV_EndBug> break ; default : if ( ndo -> ndo_vflag <= 1 ) { <S2SV_StartBug> print_unknown_data ( ndo , tptr + 3 , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , length - 3 ) ; <S2SV_EndBug> } } tptr += length ; tlen -= length ; } break ; } case BGPTYPE_ATTR_SET : ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; if ( len < 4 ) goto trunc ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Origin<S2SV_blank>AS:<S2SV_blank>%s"" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( tptr ) ) ) ) ; tptr += 4 ; len -= 4 ; while ( len ) { u_int aflags , alenlen , alen ; ND_TCHECK2 ( tptr [ 0 ] , 2 ) ; if ( len < 2 ) goto trunc ; aflags = * tptr ; atype = * ( tptr + 1 ) ; tptr += 2 ; len -= 2 ; alenlen = bgp_attr_lenlen ( aflags , tptr ) ; ND_TCHECK2 ( tptr [ 0 ] , alenlen ) ; if ( len < alenlen ) goto trunc ; alen = bgp_attr_len ( aflags , tptr ) ; tptr += alenlen ; len -= alenlen ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>length:<S2SV_blank>%u"" , tok2str ( bgp_attr_values , ""Unknown<S2SV_blank>Attribute"" , atype ) , atype , alen ) ) ; if ( aflags ) { ND_PRINT ( ( ndo , "",<S2SV_blank>Flags<S2SV_blank>[%s%s%s%s"" , aflags & 0x80 ? ""O"" : """" , aflags & 0x40 ? ""T"" : """" , aflags & 0x20 ? ""P"" : """" , aflags & 0x10 ? ""E"" : """" ) ) ; if ( aflags & 0xf ) ND_PRINT ( ( ndo , ""+%x"" , aflags & 0xf ) ) ; ND_PRINT ( ( ndo , ""]:<S2SV_blank>"" ) ) ; } if ( ! bgp_attr_print ( ndo , atype , tptr , alen ) ) return 0 ; tptr += alen ; len -= alen ; } break ; case BGPTYPE_LARGE_COMMUNITY : if ( len == 0 || len % 12 ) { ND_PRINT ( ( ndo , ""invalid<S2SV_blank>len"" ) ) ; break ; } ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" ) ) ; while ( len > 0 ) { ND_TCHECK2 ( * tptr , 12 ) ; ND_PRINT ( ( ndo , ""%u:%u:%u%s"" , EXTRACT_32BITS ( tptr ) , EXTRACT_32BITS ( tptr + 4 ) , EXTRACT_32BITS ( tptr + 8 ) , ( len > 12 ) ? "",<S2SV_blank>"" : """" ) ) ; tptr += 12 ; len -= 12 ; } break ; default : ND_TCHECK2 ( * pptr , len ) ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>no<S2SV_blank>Attribute<S2SV_blank>%u<S2SV_blank>decoder"" , atype ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , pptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , len ) ; break ; } if ( ndo -> ndo_vflag > 1 && len ) { ND_TCHECK2 ( * pptr , len ) ; print_unknown_data ( ndo , pptr , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , len ) ; } return 1 ; trunc : return 0 ; }","uint16_t length ; tlen = len ; while ( tlen >= 3 ) { <S2SV_ModStart> 3 ) ; <S2SV_ModEnd> type = * <S2SV_ModStart> 1 ) ; tptr += 3 ; tlen -= 3 ; <S2SV_ModStart> length ) ) ; if ( length < 3 ) goto trunc ; length -= 3 <S2SV_ModStart> ] , length <S2SV_ModEnd> ) ; switch <S2SV_ModStart> case BGP_AIGP_TLV : if ( length < 8 ) goto trunc <S2SV_ModEnd> ; ND_PRINT ( <S2SV_ModStart> EXTRACT_64BITS ( tptr <S2SV_ModEnd> ) ) ) <S2SV_ModStart> ndo , tptr <S2SV_ModEnd> , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , <S2SV_ModStart> ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>"" , length <S2SV_ModEnd> ) ; }"
775,"int yyparse ( void * yyscanner , HEX_LEX_ENVIRONMENT * lex_env ) { int yychar ; YY_INITIAL_VALUE ( static YYSTYPE yyval_default ; ) YYSTYPE yylval YY_INITIAL_VALUE ( = yyval_default ) ; int yynerrs ; int yystate ; int yyerrstatus ; yytype_int16 yyssa [ YYINITDEPTH ] ; yytype_int16 * yyss ; yytype_int16 * yyssp ; YYSTYPE yyvsa [ YYINITDEPTH ] ; YYSTYPE * yyvs ; YYSTYPE * yyvsp ; YYSIZE_T yystacksize ; int yyn ; int yyresult ; int yytoken = 0 ; YYSTYPE yyval ; # if YYERROR_VERBOSE char yymsgbuf [ 128 ] ; char * yymsg = yymsgbuf ; YYSIZE_T yymsg_alloc = sizeof yymsgbuf ; # endif # define YYPOPSTACK ( N ) ( yyvsp -= ( N ) , yyssp -= ( N ) ) int yylen = 0 ; yyssp = yyss = yyssa ; yyvsp = yyvs = yyvsa ; yystacksize = YYINITDEPTH ; YYDPRINTF ( ( stderr , ""Starting<S2SV_blank>parse\\n"" ) ) ; yystate = 0 ; yyerrstatus = 0 ; yynerrs = 0 ; yychar = YYEMPTY ; goto yysetstate ; yynewstate : yyssp ++ ; yysetstate : * yyssp = yystate ; if ( yyss + yystacksize - 1 <= yyssp ) { YYSIZE_T yysize = yyssp - yyss + 1 ; # ifdef yyoverflow { YYSTYPE * yyvs1 = yyvs ; yytype_int16 * yyss1 = yyss ; yyoverflow ( YY_ ( ""memory<S2SV_blank>exhausted"" ) , & yyss1 , yysize * sizeof ( * yyssp ) , & yyvs1 , yysize * sizeof ( * yyvsp ) , & yystacksize ) ; yyss = yyss1 ; yyvs = yyvs1 ; } # else # ifndef YYSTACK_RELOCATE goto yyexhaustedlab ; # else if ( YYMAXDEPTH <= yystacksize ) goto yyexhaustedlab ; yystacksize *= 2 ; if ( YYMAXDEPTH < yystacksize ) yystacksize = YYMAXDEPTH ; { yytype_int16 * yyss1 = yyss ; union yyalloc * yyptr = ( union yyalloc * ) YYSTACK_ALLOC ( YYSTACK_BYTES ( yystacksize ) ) ; if ( ! yyptr ) goto yyexhaustedlab ; YYSTACK_RELOCATE ( yyss_alloc , yyss ) ; YYSTACK_RELOCATE ( yyvs_alloc , yyvs ) ; # undef YYSTACK_RELOCATE if ( yyss1 != yyssa ) YYSTACK_FREE ( yyss1 ) ; } # endif # endif yyssp = yyss + yysize - 1 ; yyvsp = yyvs + yysize - 1 ; YYDPRINTF ( ( stderr , ""Stack<S2SV_blank>size<S2SV_blank>increased<S2SV_blank>to<S2SV_blank>%lu\\n"" , ( unsigned long int ) yystacksize ) ) ; if ( yyss + yystacksize - 1 <= yyssp ) YYABORT ; } YYDPRINTF ( ( stderr , ""Entering<S2SV_blank>state<S2SV_blank>%d\\n"" , yystate ) ) ; if ( yystate == YYFINAL ) YYACCEPT ; goto yybackup ; yybackup : yyn = yypact [ yystate ] ; if ( yypact_value_is_default ( yyn ) ) goto yydefault ; if ( yychar == YYEMPTY ) { YYDPRINTF ( ( stderr , ""Reading<S2SV_blank>a<S2SV_blank>token:<S2SV_blank>"" ) ) ; yychar = yylex ( & yylval , yyscanner , lex_env ) ; } if ( yychar <= YYEOF ) { yychar = yytoken = YYEOF ; YYDPRINTF ( ( stderr , ""Now<S2SV_blank>at<S2SV_blank>end<S2SV_blank>of<S2SV_blank>input.\\n"" ) ) ; } else { yytoken = YYTRANSLATE ( yychar ) ; YY_SYMBOL_PRINT ( ""Next<S2SV_blank>token<S2SV_blank>is"" , yytoken , & yylval , & yylloc ) ; } yyn += yytoken ; if ( yyn < 0 || YYLAST < yyn || yycheck [ yyn ] != yytoken ) goto yydefault ; yyn = yytable [ yyn ] ; if ( yyn <= 0 ) { if ( yytable_value_is_error ( yyn ) ) goto yyerrlab ; yyn = - yyn ; goto yyreduce ; } if ( yyerrstatus ) yyerrstatus -- ; YY_SYMBOL_PRINT ( ""Shifting"" , yytoken , & yylval , & yylloc ) ; yychar = YYEMPTY ; yystate = yyn ; YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN * ++ yyvsp = yylval ; YY_IGNORE_MAYBE_UNINITIALIZED_END goto yynewstate ; yydefault : yyn = yydefact [ yystate ] ; if ( yyn == 0 ) goto yyerrlab ; goto yyreduce ; yyreduce : yylen = yyr2 [ yyn ] ; yyval = yyvsp [ 1 - yylen ] ; YY_REDUCE_PRINT ( yyn ) ; switch ( yyn ) { case 2 : <S2SV_StartBug> # line 106 ""hex_grammar.y"" <S2SV_EndBug> { RE_AST * re_ast = yyget_extra ( yyscanner ) ; re_ast -> root_node = ( yyvsp [ - 1 ] . re_node ) ; } <S2SV_StartBug> # line 1330 ""hex_grammar.c"" <S2SV_EndBug> break ; case 3 : <S2SV_StartBug> # line 115 ""hex_grammar.y"" <S2SV_EndBug> { ( yyval . re_node ) = ( yyvsp [ 0 ] . re_node ) ; } <S2SV_StartBug> # line 1338 ""hex_grammar.c"" <S2SV_EndBug> break ; case 4 : <S2SV_StartBug> # line 119 ""hex_grammar.y"" <S2SV_EndBug> { ( yyval . re_node ) = yr_re_node_create ( RE_NODE_CONCAT , ( yyvsp [ - 1 ] . re_node ) , ( yyvsp [ 0 ] . re_node ) ) ; DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ - 1 ] . re_node ) ) ; DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ 0 ] . re_node ) ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; } <S2SV_StartBug> # line 1351 ""hex_grammar.c"" <S2SV_EndBug> break ; case 5 : <S2SV_StartBug> # line 128 ""hex_grammar.y"" <S2SV_EndBug> { RE_NODE * new_concat ; RE_NODE * leftmost_concat = NULL ; <S2SV_StartBug> RE_NODE * leftmost_node = ( yyvsp [ - 1 ] . re_node ) ; <S2SV_EndBug> ( yyval . re_node ) = NULL ; while ( leftmost_node -> type == RE_NODE_CONCAT ) { leftmost_concat = leftmost_node ; leftmost_node = leftmost_node -> left ; } new_concat = yr_re_node_create ( RE_NODE_CONCAT , ( yyvsp [ - 2 ] . re_node ) , leftmost_node ) ; if ( new_concat != NULL ) { if ( leftmost_concat != NULL ) { leftmost_concat -> left = new_concat ; ( yyval . re_node ) = yr_re_node_create ( RE_NODE_CONCAT , ( yyvsp [ - 1 ] . re_node ) , ( yyvsp [ 0 ] . re_node ) ) ; } else { ( yyval . re_node ) = yr_re_node_create ( RE_NODE_CONCAT , new_concat , ( yyvsp [ 0 ] . re_node ) ) ; } } DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ - 2 ] . re_node ) ) ; DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ - 1 ] . re_node ) ) ; DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ 0 ] . re_node ) ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; } <S2SV_StartBug> # line 1413 ""hex_grammar.c"" <S2SV_EndBug> break ; case 6 : <S2SV_StartBug> # line 190 ""hex_grammar.y"" <S2SV_EndBug> { ( yyval . re_node ) = ( yyvsp [ 0 ] . re_node ) ; } <S2SV_StartBug> # line 1421 ""hex_grammar.c"" <S2SV_EndBug> break ; case 7 : <S2SV_StartBug> # line 194 ""hex_grammar.y"" <S2SV_EndBug> { ( yyval . re_node ) = yr_re_node_create ( RE_NODE_CONCAT , ( yyvsp [ - 1 ] . re_node ) , ( yyvsp [ 0 ] . re_node ) ) ; DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ - 1 ] . re_node ) ) ; DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ 0 ] . re_node ) ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; } <S2SV_StartBug> # line 1434 ""hex_grammar.c"" <S2SV_EndBug> break ; case 8 : <S2SV_StartBug> # line 207 ""hex_grammar.y"" <S2SV_EndBug> { ( yyval . re_node ) = ( yyvsp [ 0 ] . re_node ) ; } <S2SV_StartBug> # line 1442 ""hex_grammar.c"" <S2SV_EndBug> break ; case 9 : <S2SV_StartBug> # line 211 ""hex_grammar.y"" <S2SV_EndBug> { ( yyval . re_node ) = ( yyvsp [ 0 ] . re_node ) ; ( yyval . re_node ) -> greedy = FALSE ; } <S2SV_StartBug> # line 1451 ""hex_grammar.c"" <S2SV_EndBug> break ; case 10 : <S2SV_StartBug> # line 220 ""hex_grammar.y"" <S2SV_EndBug> { lex_env -> token_count ++ ; if ( lex_env -> token_count > MAX_HEX_STRING_TOKENS ) { yr_re_node_destroy ( ( yyvsp [ 0 ] . re_node ) ) ; yyerror ( yyscanner , lex_env , ""string<S2SV_blank>too<S2SV_blank>long"" ) ; YYABORT ; } ( yyval . re_node ) = ( yyvsp [ 0 ] . re_node ) ; } <S2SV_StartBug> # line 1468 ""hex_grammar.c"" <S2SV_EndBug> break ; case 11 : <S2SV_StartBug> # line 233 ""hex_grammar.y"" <S2SV_EndBug> { lex_env -> inside_or ++ ; } <S2SV_StartBug> # line 1476 ""hex_grammar.c"" <S2SV_EndBug> break ; case 12 : <S2SV_StartBug> # line 237 ""hex_grammar.y"" <S2SV_EndBug> { ( yyval . re_node ) = ( yyvsp [ - 1 ] . re_node ) ; lex_env -> inside_or -- ; } <S2SV_StartBug> # line 1485 ""hex_grammar.c"" <S2SV_EndBug> break ; case 13 : <S2SV_StartBug> # line 246 ""hex_grammar.y"" <S2SV_EndBug> { if ( ( yyvsp [ - 1 ] . integer ) <= 0 ) { yyerror ( yyscanner , lex_env , ""invalid<S2SV_blank>jump<S2SV_blank>length"" ) ; YYABORT ; } if ( lex_env -> inside_or && ( yyvsp [ - 1 ] . integer ) > STRING_CHAINING_THRESHOLD ) { yyerror ( yyscanner , lex_env , ""jumps<S2SV_blank>over<S2SV_blank>"" STR ( STRING_CHAINING_THRESHOLD ) ""<S2SV_blank>now<S2SV_blank>allowed<S2SV_blank>inside<S2SV_blank>alternation<S2SV_blank>(|)"" ) ; YYABORT ; } ( yyval . re_node ) = yr_re_node_create ( RE_NODE_RANGE_ANY , NULL , NULL ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; ( yyval . re_node ) -> start = ( int ) ( yyvsp [ - 1 ] . integer ) ; ( yyval . re_node ) -> end = ( int ) ( yyvsp [ - 1 ] . integer ) ; } <S2SV_StartBug> # line 1512 ""hex_grammar.c"" <S2SV_EndBug> break ; case 14 : <S2SV_StartBug> # line 269 ""hex_grammar.y"" <S2SV_EndBug> { if ( lex_env -> inside_or && ( ( yyvsp [ - 3 ] . integer ) > STRING_CHAINING_THRESHOLD || ( yyvsp [ - 1 ] . integer ) > STRING_CHAINING_THRESHOLD ) ) { yyerror ( yyscanner , lex_env , ""jumps<S2SV_blank>over<S2SV_blank>"" STR ( STRING_CHAINING_THRESHOLD ) ""<S2SV_blank>now<S2SV_blank>allowed<S2SV_blank>inside<S2SV_blank>alternation<S2SV_blank>(|)"" ) ; YYABORT ; } if ( ( yyvsp [ - 3 ] . integer ) < 0 || ( yyvsp [ - 1 ] . integer ) < 0 ) { yyerror ( yyscanner , lex_env , ""invalid<S2SV_blank>negative<S2SV_blank>jump<S2SV_blank>length"" ) ; YYABORT ; } if ( ( yyvsp [ - 3 ] . integer ) > ( yyvsp [ - 1 ] . integer ) ) { yyerror ( yyscanner , lex_env , ""invalid<S2SV_blank>jump<S2SV_blank>range"" ) ; YYABORT ; } ( yyval . re_node ) = yr_re_node_create ( RE_NODE_RANGE_ANY , NULL , NULL ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; ( yyval . re_node ) -> start = ( int ) ( yyvsp [ - 3 ] . integer ) ; ( yyval . re_node ) -> end = ( int ) ( yyvsp [ - 1 ] . integer ) ; } <S2SV_StartBug> # line 1548 ""hex_grammar.c"" <S2SV_EndBug> break ; case 15 : <S2SV_StartBug> # line 301 ""hex_grammar.y"" <S2SV_EndBug> { if ( lex_env -> inside_or ) { yyerror ( yyscanner , lex_env , ""unbounded<S2SV_blank>jumps<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>inside<S2SV_blank>alternation<S2SV_blank>(|)"" ) ; YYABORT ; } if ( ( yyvsp [ - 2 ] . integer ) < 0 ) { yyerror ( yyscanner , lex_env , ""invalid<S2SV_blank>negative<S2SV_blank>jump<S2SV_blank>length"" ) ; YYABORT ; } ( yyval . re_node ) = yr_re_node_create ( RE_NODE_RANGE_ANY , NULL , NULL ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; ( yyval . re_node ) -> start = ( int ) ( yyvsp [ - 2 ] . integer ) ; ( yyval . re_node ) -> end = INT_MAX ; } <S2SV_StartBug> # line 1574 ""hex_grammar.c"" <S2SV_EndBug> break ; case 16 : <S2SV_StartBug> # line 323 ""hex_grammar.y"" <S2SV_EndBug> { if ( lex_env -> inside_or ) { yyerror ( yyscanner , lex_env , ""unbounded<S2SV_blank>jumps<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>inside<S2SV_blank>alternation<S2SV_blank>(|)"" ) ; YYABORT ; } ( yyval . re_node ) = yr_re_node_create ( RE_NODE_RANGE_ANY , NULL , NULL ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; ( yyval . re_node ) -> start = 0 ; ( yyval . re_node ) -> end = INT_MAX ; } <S2SV_StartBug> # line 1594 ""hex_grammar.c"" <S2SV_EndBug> break ; case 17 : <S2SV_StartBug> # line 343 ""hex_grammar.y"" <S2SV_EndBug> { ( yyval . re_node ) = ( yyvsp [ 0 ] . re_node ) ; } <S2SV_StartBug> # line 1602 ""hex_grammar.c"" <S2SV_EndBug> break ; case 18 : <S2SV_StartBug> # line 347 ""hex_grammar.y"" <S2SV_EndBug> { mark_as_not_fast_regexp ( ) ; <S2SV_StartBug> ( yyval . re_node ) = yr_re_node_create ( RE_NODE_ALT , ( yyvsp [ - 2 ] . re_node ) , ( yyvsp [ 0 ] . re_node ) ) ; <S2SV_EndBug> DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ - 2 ] . re_node ) ) ; DESTROY_NODE_IF ( ( yyval . re_node ) == NULL , ( yyvsp [ 0 ] . re_node ) ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; } <S2SV_StartBug> # line 1617 ""hex_grammar.c"" <S2SV_EndBug> break ; case 19 : <S2SV_StartBug> # line 361 ""hex_grammar.y"" <S2SV_EndBug> { ( yyval . re_node ) = yr_re_node_create ( RE_NODE_LITERAL , NULL , NULL ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; ( yyval . re_node ) -> value = ( int ) ( yyvsp [ 0 ] . integer ) ; } <S2SV_StartBug> # line 1629 ""hex_grammar.c"" <S2SV_EndBug> break ; case 20 : <S2SV_StartBug> # line 369 ""hex_grammar.y"" <S2SV_EndBug> { uint8_t mask = ( uint8_t ) ( ( yyvsp [ 0 ] . integer ) >> 8 ) ; if ( mask == 0x00 ) { ( yyval . re_node ) = yr_re_node_create ( RE_NODE_ANY , NULL , NULL ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; } else { ( yyval . re_node ) = yr_re_node_create ( RE_NODE_MASKED_LITERAL , NULL , NULL ) ; ERROR_IF ( ( yyval . re_node ) == NULL , ERROR_INSUFFICIENT_MEMORY ) ; ( yyval . re_node ) -> value = ( yyvsp [ 0 ] . integer ) & 0xFF ; ( yyval . re_node ) -> mask = mask ; } } <S2SV_StartBug> # line 1653 ""hex_grammar.c"" <S2SV_EndBug> break ; <S2SV_StartBug> # line 1657 ""hex_grammar.c"" <S2SV_EndBug> default : break ; } YY_SYMBOL_PRINT ( ""-><S2SV_blank>$$<S2SV_blank>="" , yyr1 [ yyn ] , & yyval , & yyloc ) ; YYPOPSTACK ( yylen ) ; yylen = 0 ; YY_STACK_PRINT ( yyss , yyssp ) ; * ++ yyvsp = yyval ; yyn = yyr1 [ yyn ] ; yystate = yypgoto [ yyn - YYNTOKENS ] + * yyssp ; if ( 0 <= yystate && yystate <= YYLAST && yycheck [ yystate ] == * yyssp ) yystate = yytable [ yystate ] ; else yystate = yydefgoto [ yyn - YYNTOKENS ] ; goto yynewstate ; yyerrlab : yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE ( yychar ) ; if ( ! yyerrstatus ) { ++ yynerrs ; # if ! YYERROR_VERBOSE yyerror ( yyscanner , lex_env , YY_ ( ""syntax<S2SV_blank>error"" ) ) ; # else # define YYSYNTAX_ERROR yysyntax_error ( & yymsg_alloc , & yymsg , yyssp , yytoken ) { char const * yymsgp = YY_ ( ""syntax<S2SV_blank>error"" ) ; int yysyntax_error_status ; yysyntax_error_status = YYSYNTAX_ERROR ; if ( yysyntax_error_status == 0 ) yymsgp = yymsg ; else if ( yysyntax_error_status == 1 ) { if ( yymsg != yymsgbuf ) YYSTACK_FREE ( yymsg ) ; yymsg = ( char * ) YYSTACK_ALLOC ( yymsg_alloc ) ; if ( ! yymsg ) { yymsg = yymsgbuf ; yymsg_alloc = sizeof yymsgbuf ; yysyntax_error_status = 2 ; } else { yysyntax_error_status = YYSYNTAX_ERROR ; yymsgp = yymsg ; } } yyerror ( yyscanner , lex_env , yymsgp ) ; if ( yysyntax_error_status == 2 ) goto yyexhaustedlab ; } # undef YYSYNTAX_ERROR # endif } if ( yyerrstatus == 3 ) { if ( yychar <= YYEOF ) { if ( yychar == YYEOF ) YYABORT ; } else { yydestruct ( ""Error:<S2SV_blank>discarding"" , yytoken , & yylval , yyscanner , lex_env ) ; yychar = YYEMPTY ; } } goto yyerrlab1 ; yyerrorlab : if ( 0 ) goto yyerrorlab ; YYPOPSTACK ( yylen ) ; yylen = 0 ; YY_STACK_PRINT ( yyss , yyssp ) ; yystate = * yyssp ; goto yyerrlab1 ; yyerrlab1 : yyerrstatus = 3 ; for ( ; ; ) { yyn = yypact [ yystate ] ; if ( ! yypact_value_is_default ( yyn ) ) { yyn += YYTERROR ; if ( 0 <= yyn && yyn <= YYLAST && yycheck [ yyn ] == YYTERROR ) { yyn = yytable [ yyn ] ; if ( 0 < yyn ) break ; } } if ( yyssp == yyss ) YYABORT ; yydestruct ( ""Error:<S2SV_blank>popping"" , yystos [ yystate ] , yyvsp , yyscanner , lex_env ) ; YYPOPSTACK ( 1 ) ; yystate = * yyssp ; YY_STACK_PRINT ( yyss , yyssp ) ; } YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN * ++ yyvsp = yylval ; YY_IGNORE_MAYBE_UNINITIALIZED_END YY_SYMBOL_PRINT ( ""Shifting"" , yystos [ yyn ] , yyvsp , yylsp ) ; yystate = yyn ; goto yynewstate ; yyacceptlab : yyresult = 0 ; goto yyreturn ; yyabortlab : yyresult = 1 ; goto yyreturn ; # if ! defined yyoverflow || YYERROR_VERBOSE yyexhaustedlab : yyerror ( yyscanner , lex_env , YY_ ( ""memory<S2SV_blank>exhausted"" ) ) ; yyresult = 2 ; # endif yyreturn : if ( yychar != YYEMPTY ) { yytoken = YYTRANSLATE ( yychar ) ; yydestruct ( ""Cleanup:<S2SV_blank>discarding<S2SV_blank>lookahead"" , yytoken , & yylval , yyscanner , lex_env ) ; } YYPOPSTACK ( yylen ) ; YY_STACK_PRINT ( yyss , yyssp ) ; while ( yyssp != yyss ) { yydestruct ( ""Cleanup:<S2SV_blank>popping"" , yystos [ * yyssp ] , yyvsp , yyscanner , lex_env ) ; YYPOPSTACK ( 1 ) ; } # ifndef yyoverflow if ( yyss != yyssa ) YYSTACK_FREE ( yyss ) ; # endif # if YYERROR_VERBOSE if ( yymsg != yymsgbuf ) YYSTACK_FREE ( yymsg ) ; # endif return yyresult ; }",": # line 113 <S2SV_ModEnd> ""hex_grammar.y"" { RE_AST <S2SV_ModStart> } # line 1337 <S2SV_ModEnd> ""hex_grammar.c"" break ; <S2SV_ModStart> : # line 122 <S2SV_ModEnd> ""hex_grammar.y"" { ( <S2SV_ModStart> } # line 1345 <S2SV_ModEnd> ""hex_grammar.c"" break ; <S2SV_ModStart> : # line 126 ""hex_grammar.y"" { incr_ast_levels ( ) ; <S2SV_ModEnd> ( yyval . <S2SV_ModStart> } # line 1360 <S2SV_ModEnd> ""hex_grammar.c"" break ; <S2SV_ModStart> : # line 137 <S2SV_ModEnd> ""hex_grammar.y"" { RE_NODE <S2SV_ModStart> ] . re_node ) ; incr_ast_levels ( <S2SV_ModStart> } # line 1424 <S2SV_ModEnd> ""hex_grammar.c"" break ; <S2SV_ModStart> : # line 201 <S2SV_ModEnd> ""hex_grammar.y"" { ( <S2SV_ModStart> } # line 1432 <S2SV_ModEnd> ""hex_grammar.c"" break ; <S2SV_ModStart> : # line 205 ""hex_grammar.y"" { incr_ast_levels ( ) ; <S2SV_ModEnd> ( yyval . <S2SV_ModStart> } # line 1447 <S2SV_ModEnd> ""hex_grammar.c"" break ; <S2SV_ModStart> : # line 220 <S2SV_ModEnd> ""hex_grammar.y"" { ( <S2SV_ModStart> } # line 1455 <S2SV_ModEnd> ""hex_grammar.c"" break ; <S2SV_ModStart> : # line 224 <S2SV_ModEnd> ""hex_grammar.y"" { ( <S2SV_ModStart> } # line 1464 <S2SV_ModEnd> ""hex_grammar.c"" break ; <S2SV_ModStart> : # line 233 <S2SV_ModEnd> ""hex_grammar.y"" { lex_env <S2SV_ModStart> } # line 1481 <S2SV_ModEnd> ""hex_grammar.c"" break ; <S2SV_ModStart> : # line 246 <S2SV_ModEnd> ""hex_grammar.y"" { lex_env <S2SV_ModStart> } # line 1489 <S2SV_ModEnd> ""hex_grammar.c"" break ; <S2SV_ModStart> : # line 250 <S2SV_ModEnd> ""hex_grammar.y"" { ( <S2SV_ModStart> } # line 1498 <S2SV_ModEnd> ""hex_grammar.c"" break ; <S2SV_ModStart> : # line 259 <S2SV_ModEnd> ""hex_grammar.y"" { if <S2SV_ModStart> } # line 1525 <S2SV_ModEnd> ""hex_grammar.c"" break ; <S2SV_ModStart> : # line 282 <S2SV_ModEnd> ""hex_grammar.y"" { if <S2SV_ModStart> } # line 1561 <S2SV_ModEnd> ""hex_grammar.c"" break ; <S2SV_ModStart> : # line 314 <S2SV_ModEnd> ""hex_grammar.y"" { if <S2SV_ModStart> } # line 1587 <S2SV_ModEnd> ""hex_grammar.c"" break ; <S2SV_ModStart> : # line 336 <S2SV_ModEnd> ""hex_grammar.y"" { if <S2SV_ModStart> } # line 1607 <S2SV_ModEnd> ""hex_grammar.c"" break ; <S2SV_ModStart> : # line 356 <S2SV_ModEnd> ""hex_grammar.y"" { ( <S2SV_ModStart> } # line 1615 <S2SV_ModEnd> ""hex_grammar.c"" break ; <S2SV_ModStart> : # line 360 <S2SV_ModEnd> ""hex_grammar.y"" { mark_as_not_fast_regexp <S2SV_ModStart> ( ) ; incr_ast_levels ( ) ; <S2SV_ModStart> } # line 1631 <S2SV_ModEnd> ""hex_grammar.c"" break ; <S2SV_ModStart> : # line 375 <S2SV_ModEnd> ""hex_grammar.y"" { ( <S2SV_ModStart> } # line 1643 <S2SV_ModEnd> ""hex_grammar.c"" break ; <S2SV_ModStart> : # line 383 <S2SV_ModEnd> ""hex_grammar.y"" { uint8_t <S2SV_ModStart> } # line 1667 <S2SV_ModEnd> ""hex_grammar.c"" break ; <S2SV_ModStart> ; # line 1671 <S2SV_ModEnd> ""hex_grammar.c"" default :"
776,"int nntp_add_group ( char * line , void * data ) { struct NntpServer * nserv = data ; struct NntpData * nntp_data = NULL ; <S2SV_StartBug> char group [ LONG_STRING ] ; <S2SV_EndBug> char desc [ HUGE_STRING ] = """" ; char mod ; anum_t first , last ; if ( ! nserv || ! line ) return 0 ; <S2SV_StartBug> if ( sscanf ( line , ""%s<S2SV_blank>"" ANUM ""<S2SV_blank>"" ANUM ""<S2SV_blank>%c<S2SV_blank>%[^\\n]"" , group , & last , & first , & mod , desc ) < 4 ) <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> nntp_data = nntp_data_find ( nserv , group ) ; nntp_data -> deleted = false ; nntp_data -> first_message = first ; nntp_data -> last_message = last ; nntp_data -> allowed = ( mod == 'y' ) || ( mod == 'm' ) ; mutt_str_replace ( & nntp_data -> desc , desc ) ; if ( nntp_data -> newsrc_ent || nntp_data -> last_cached ) nntp_group_unread_stat ( nntp_data ) ; else if ( nntp_data -> last_message && nntp_data -> first_message <= nntp_data -> last_message ) nntp_data -> unread = nntp_data -> last_message - nntp_data -> first_message + 1 ; else nntp_data -> unread = 0 ; return 0 ; }","[ LONG_STRING ] = """" <S2SV_ModStart> ( line , ""%1023s<S2SV_blank>"" <S2SV_ModEnd> ANUM ""<S2SV_blank>"" ANUM <S2SV_ModStart> ANUM ""<S2SV_blank>"" ANUM ""<S2SV_blank>%c<S2SV_blank>%8191[^\\n]"" <S2SV_ModEnd> , group , <S2SV_ModStart> < 4 ) { mutt_debug ( 4 , ""Cannot<S2SV_blank>parse<S2SV_blank>server<S2SV_blank>line:<S2SV_blank>%s\\n"" , line ) ; <S2SV_ModStart> return 0 ; }"
777,"u32 h264bsdActivateParamSets ( storage_t * pStorage , u32 ppsId , u32 isIdr ) { u32 tmp ; u32 flag ; ASSERT ( pStorage ) ; ASSERT ( ppsId < MAX_NUM_PIC_PARAM_SETS ) ; if ( ( pStorage -> pps [ ppsId ] == NULL ) || ( pStorage -> sps [ pStorage -> pps [ ppsId ] -> seqParameterSetId ] == NULL ) ) { return ( HANTRO_NOK ) ; } tmp = CheckPps ( pStorage -> pps [ ppsId ] , pStorage -> sps [ pStorage -> pps [ ppsId ] -> seqParameterSetId ] ) ; if ( tmp != HANTRO_OK ) return ( tmp ) ; if ( pStorage -> activePpsId == MAX_NUM_PIC_PARAM_SETS ) { pStorage -> activePpsId = ppsId ; pStorage -> activePps = pStorage -> pps [ ppsId ] ; pStorage -> activeSpsId = pStorage -> activePps -> seqParameterSetId ; pStorage -> activeSps = pStorage -> sps [ pStorage -> activeSpsId ] ; <S2SV_StartBug> pStorage -> picSizeInMbs = <S2SV_EndBug> pStorage -> activeSps -> picWidthInMbs * <S2SV_StartBug> pStorage -> activeSps -> picHeightInMbs ; <S2SV_EndBug> pStorage -> currImage -> width = pStorage -> activeSps -> picWidthInMbs ; pStorage -> currImage -> height = pStorage -> activeSps -> picHeightInMbs ; pStorage -> pendingActivation = HANTRO_TRUE ; } else if ( pStorage -> pendingActivation ) { pStorage -> pendingActivation = HANTRO_FALSE ; FREE ( pStorage -> mb ) ; FREE ( pStorage -> sliceGroupMap ) ; ALLOCATE ( pStorage -> mb , pStorage -> picSizeInMbs , mbStorage_t ) ; ALLOCATE ( pStorage -> sliceGroupMap , pStorage -> picSizeInMbs , u32 ) ; if ( pStorage -> mb == NULL || pStorage -> sliceGroupMap == NULL ) return ( MEMORY_ALLOCATION_ERROR ) ; H264SwDecMemset ( pStorage -> mb , 0 , pStorage -> picSizeInMbs * sizeof ( mbStorage_t ) ) ; h264bsdInitMbNeighbours ( pStorage -> mb , pStorage -> activeSps -> picWidthInMbs , pStorage -> picSizeInMbs ) ; if ( pStorage -> noReordering || pStorage -> activeSps -> picOrderCntType == 2 || ( pStorage -> activeSps -> vuiParametersPresentFlag && pStorage -> activeSps -> vuiParameters -> bitstreamRestrictionFlag && ! pStorage -> activeSps -> vuiParameters -> numReorderFrames ) ) flag = HANTRO_TRUE ; else flag = HANTRO_FALSE ; tmp = h264bsdResetDpb ( pStorage -> dpb , pStorage -> activeSps -> picWidthInMbs * pStorage -> activeSps -> picHeightInMbs , pStorage -> activeSps -> maxDpbSize , pStorage -> activeSps -> numRefFrames , pStorage -> activeSps -> maxFrameNum , flag ) ; if ( tmp != HANTRO_OK ) return ( tmp ) ; } else if ( ppsId != pStorage -> activePpsId ) { if ( pStorage -> pps [ ppsId ] -> seqParameterSetId != pStorage -> activeSpsId ) { DEBUG ( ( ""SEQ<S2SV_blank>PARAM<S2SV_blank>SET<S2SV_blank>CHANGING...\\n"" ) ) ; if ( isIdr ) { pStorage -> activePpsId = ppsId ; pStorage -> activePps = pStorage -> pps [ ppsId ] ; pStorage -> activeSpsId = pStorage -> activePps -> seqParameterSetId ; pStorage -> activeSps = pStorage -> sps [ pStorage -> activeSpsId ] ; pStorage -> picSizeInMbs = pStorage -> activeSps -> picWidthInMbs * pStorage -> activeSps -> picHeightInMbs ; pStorage -> currImage -> width = pStorage -> activeSps -> picWidthInMbs ; pStorage -> currImage -> height = pStorage -> activeSps -> picHeightInMbs ; pStorage -> pendingActivation = HANTRO_TRUE ; } else { DEBUG ( ( ""TRYING<S2SV_blank>TO<S2SV_blank>CHANGE<S2SV_blank>SPS<S2SV_blank>IN<S2SV_blank>NON-IDR<S2SV_blank>SLICE\\n"" ) ) ; return ( HANTRO_NOK ) ; } } else { pStorage -> activePpsId = ppsId ; pStorage -> activePps = pStorage -> pps [ ppsId ] ; } } return ( HANTRO_OK ) ; }",activeSpsId ] ; if ( pStorage -> activeSps -> picWidthInMbs == 0 ) { pStorage -> picSizeInMbs = 0 ; } else if ( pStorage -> activeSps -> picHeightInMbs > UINT32_MAX / pStorage -> activeSps -> picWidthInMbs ) { return ( MEMORY_ALLOCATION_ERROR ) ; } else { <S2SV_ModStart> -> picHeightInMbs ; }
778,"static int adjust_scalar_min_max_vals ( struct bpf_verifier_env * env , struct bpf_insn * insn , struct bpf_reg_state * dst_reg , struct bpf_reg_state src_reg ) { struct bpf_reg_state * regs = cur_regs ( env ) ; u8 opcode = BPF_OP ( insn -> code ) ; bool src_known , dst_known ; s64 smin_val , smax_val ; u64 umin_val , umax_val ; <S2SV_StartBug> if ( BPF_CLASS ( insn -> code ) != BPF_ALU64 ) { <S2SV_EndBug> coerce_reg_to_size ( dst_reg , 4 ) ; coerce_reg_to_size ( & src_reg , 4 ) ; } smin_val = src_reg . smin_value ; smax_val = src_reg . smax_value ; umin_val = src_reg . umin_value ; umax_val = src_reg . umax_value ; src_known = tnum_is_const ( src_reg . var_off ) ; dst_known = tnum_is_const ( dst_reg -> var_off ) ; switch ( opcode ) { case BPF_ADD : if ( signed_add_overflows ( dst_reg -> smin_value , smin_val ) || signed_add_overflows ( dst_reg -> smax_value , smax_val ) ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value += smin_val ; dst_reg -> smax_value += smax_val ; } if ( dst_reg -> umin_value + umin_val < umin_val || dst_reg -> umax_value + umax_val < umax_val ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value += umin_val ; dst_reg -> umax_value += umax_val ; } dst_reg -> var_off = tnum_add ( dst_reg -> var_off , src_reg . var_off ) ; break ; case BPF_SUB : if ( signed_sub_overflows ( dst_reg -> smin_value , smax_val ) || signed_sub_overflows ( dst_reg -> smax_value , smin_val ) ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value -= smax_val ; dst_reg -> smax_value -= smin_val ; } if ( dst_reg -> umin_value < umax_val ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value -= umax_val ; dst_reg -> umax_value -= umin_val ; } dst_reg -> var_off = tnum_sub ( dst_reg -> var_off , src_reg . var_off ) ; break ; case BPF_MUL : dst_reg -> var_off = tnum_mul ( dst_reg -> var_off , src_reg . var_off ) ; if ( smin_val < 0 || dst_reg -> smin_value < 0 ) { __mark_reg_unbounded ( dst_reg ) ; __update_reg_bounds ( dst_reg ) ; break ; } if ( umax_val > U32_MAX || dst_reg -> umax_value > U32_MAX ) { __mark_reg_unbounded ( dst_reg ) ; __update_reg_bounds ( dst_reg ) ; break ; } dst_reg -> umin_value *= umin_val ; dst_reg -> umax_value *= umax_val ; if ( dst_reg -> umax_value > S64_MAX ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } break ; case BPF_AND : if ( src_known && dst_known ) { __mark_reg_known ( dst_reg , dst_reg -> var_off . value & src_reg . var_off . value ) ; break ; } dst_reg -> var_off = tnum_and ( dst_reg -> var_off , src_reg . var_off ) ; dst_reg -> umin_value = dst_reg -> var_off . value ; dst_reg -> umax_value = min ( dst_reg -> umax_value , umax_val ) ; if ( dst_reg -> smin_value < 0 || smin_val < 0 ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } __update_reg_bounds ( dst_reg ) ; break ; case BPF_OR : if ( src_known && dst_known ) { __mark_reg_known ( dst_reg , dst_reg -> var_off . value | src_reg . var_off . value ) ; break ; } dst_reg -> var_off = tnum_or ( dst_reg -> var_off , src_reg . var_off ) ; dst_reg -> umin_value = max ( dst_reg -> umin_value , umin_val ) ; dst_reg -> umax_value = dst_reg -> var_off . value | dst_reg -> var_off . mask ; if ( dst_reg -> smin_value < 0 || smin_val < 0 ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } __update_reg_bounds ( dst_reg ) ; break ; case BPF_LSH : <S2SV_StartBug> if ( umax_val > 63 ) { <S2SV_EndBug> mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; if ( dst_reg -> umax_value > 1ULL << ( 63 - umax_val ) ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value <<= umin_val ; dst_reg -> umax_value <<= umax_val ; } if ( src_known ) dst_reg -> var_off = tnum_lshift ( dst_reg -> var_off , umin_val ) ; else dst_reg -> var_off = tnum_lshift ( tnum_unknown , umin_val ) ; __update_reg_bounds ( dst_reg ) ; break ; case BPF_RSH : <S2SV_StartBug> if ( umax_val > 63 ) { <S2SV_EndBug> mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; if ( src_known ) dst_reg -> var_off = tnum_rshift ( dst_reg -> var_off , umin_val ) ; else dst_reg -> var_off = tnum_rshift ( tnum_unknown , umin_val ) ; dst_reg -> umin_value >>= umax_val ; dst_reg -> umax_value >>= umin_val ; __update_reg_bounds ( dst_reg ) ; break ; default : mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } <S2SV_StartBug> __reg_deduce_bounds ( dst_reg ) ; <S2SV_EndBug> __reg_bound_offset ( dst_reg ) ; return 0 ; }",", umax_val ; u64 insn_bitness = <S2SV_ModEnd> ( BPF_CLASS ( <S2SV_ModStart> -> code ) == BPF_ALU64 ) ? 64 : 32 ; <S2SV_ModEnd> smin_val = src_reg <S2SV_ModStart> if ( umax_val >= insn_bitness <S2SV_ModEnd> ) { mark_reg_unknown <S2SV_ModStart> if ( umax_val >= insn_bitness <S2SV_ModEnd> ) { mark_reg_unknown <S2SV_ModStart> break ; } if ( BPF_CLASS ( insn -> code ) != BPF_ALU64 ) { coerce_reg_to_size ( dst_reg , 4 ) ; coerce_reg_to_size ( & src_reg , 4 ) ; }"
779,"DECLAREreadFunc ( readContigTilesIntoBuffer ) { int status = 1 ; tsize_t tilesize = TIFFTileSize ( in ) ; tdata_t tilebuf ; uint32 imagew = TIFFScanlineSize ( in ) ; uint32 tilew = TIFFTileRowSize ( in ) ; <S2SV_StartBug> int iskew = imagew - tilew ; <S2SV_EndBug> uint8 * bufp = ( uint8 * ) buf ; uint32 tw , tl ; uint32 row ; ( void ) spp ; tilebuf = _TIFFmalloc ( tilesize ) ; if ( tilebuf == 0 ) return 0 ; _TIFFmemset ( tilebuf , 0 , tilesize ) ; ( void ) TIFFGetField ( in , TIFFTAG_TILEWIDTH , & tw ) ; ( void ) TIFFGetField ( in , TIFFTAG_TILELENGTH , & tl ) ; for ( row = 0 ; row < imagelength ; row += tl ) { uint32 nrow = ( row + tl > imagelength ) ? imagelength - row : tl ; uint32 colb = 0 ; uint32 col ; for ( col = 0 ; col < imagewidth && colb < imagew ; col += tw ) { if ( TIFFReadTile ( in , tilebuf , col , row , 0 , 0 ) < 0 && ! ignore ) { TIFFError ( TIFFFileName ( in ) , ""Error,<S2SV_blank>can\'t<S2SV_blank>read<S2SV_blank>tile<S2SV_blank>at<S2SV_blank>%lu<S2SV_blank>%lu"" , ( unsigned long ) col , ( unsigned long ) row ) ; status = 0 ; goto done ; } <S2SV_StartBug> if ( colb + tilew > imagew ) { <S2SV_EndBug> uint32 width = imagew - colb ; uint32 oskew = tilew - width ; cpStripToTile ( bufp + colb , tilebuf , nrow , width , oskew + iskew , oskew ) ; } else cpStripToTile ( bufp + colb , tilebuf , nrow , tilew , iskew , 0 ) ; colb += tilew ; } bufp += imagew * nrow ; } done : _TIFFfree ( tilebuf ) ; return status ; }",in ) ; int64 iskew = ( int64 ) imagew - ( int64 ) <S2SV_ModEnd> tilew ; uint8 <S2SV_ModStart> if ( colb > iskew <S2SV_ModEnd> ) { uint32
780,"int dev_forward_skb ( struct net_device * dev , struct sk_buff * skb ) { skb_orphan ( skb ) ; <S2SV_StartBug> if ( ! ( dev -> flags & IFF_UP ) ) <S2SV_EndBug> return NET_RX_DROP ; <S2SV_StartBug> if ( skb -> len > ( dev -> mtu + dev -> hard_header_len ) ) <S2SV_EndBug> <S2SV_StartBug> return NET_RX_DROP ; <S2SV_EndBug> skb_set_dev ( skb , dev ) ; skb -> tstamp . tv64 = 0 ; skb -> pkt_type = PACKET_HOST ; skb -> protocol = eth_type_trans ( skb , dev ) ; return netif_rx ( skb ) ; }",& IFF_UP ) || <S2SV_ModEnd> ( skb -> <S2SV_ModStart> hard_header_len ) ) ) { kfree_skb ( skb ) ; <S2SV_ModStart> return NET_RX_DROP ; }
781,"static void cs_cmd_flags ( sourceinfo_t * si , int parc , char * parv [ ] ) { chanacs_t * ca ; mowgli_node_t * n ; char * channel = parv [ 0 ] ; char * target = sstrdup ( parv [ 1 ] ) ; char * flagstr = parv [ 2 ] ; const char * str1 ; unsigned int addflags , removeflags , restrictflags ; hook_channel_acl_req_t req ; mychan_t * mc ; if ( parc < 1 ) { command_fail ( si , fault_needmoreparams , STR_INSUFFICIENT_PARAMS , ""FLAGS"" ) ; command_fail ( si , fault_needmoreparams , _ ( ""Syntax:<S2SV_blank>FLAGS<S2SV_blank><channel><S2SV_blank>[target]<S2SV_blank>[flags]"" ) ) ; return ; } mc = mychan_find ( channel ) ; if ( ! mc ) { command_fail ( si , fault_nosuch_target , _ ( ""Channel<S2SV_blank>\\2%s\\2<S2SV_blank>is<S2SV_blank>not<S2SV_blank>registered."" ) , channel ) ; return ; } if ( metadata_find ( mc , ""private:close:closer"" ) && ( target || ! has_priv ( si , PRIV_CHAN_AUSPEX ) ) ) { command_fail ( si , fault_noprivs , _ ( ""\\2%s\\2<S2SV_blank>is<S2SV_blank>closed."" ) , channel ) ; return ; } if ( ! target || ( target && target [ 0 ] == '+' && flagstr == NULL ) ) { unsigned int flags = ( target != NULL ) ? flags_to_bitmask ( target , 0 ) : 0 ; do_list ( si , mc , flags ) ; return ; } <S2SV_StartBug> else if ( ! strcasecmp ( target , ""LIST"" ) && myentity_find_ext ( target ) == NULL ) <S2SV_EndBug> { do_list ( si , mc , 0 ) ; free ( target ) ; return ; } <S2SV_StartBug> else if ( ! strcasecmp ( target , ""CLEAR"" ) && myentity_find_ext ( target ) == NULL ) <S2SV_EndBug> { free ( target ) ; if ( ! chanacs_source_has_flag ( mc , si , CA_FOUNDER ) ) { command_fail ( si , fault_noprivs , ""You<S2SV_blank>are<S2SV_blank>not<S2SV_blank>authorized<S2SV_blank>to<S2SV_blank>perform<S2SV_blank>this<S2SV_blank>operation."" ) ; return ; } mowgli_node_t * tn ; MOWGLI_ITER_FOREACH_SAFE ( n , tn , mc -> chanacs . head ) { ca = n -> data ; if ( ca -> level & CA_FOUNDER ) continue ; object_unref ( ca ) ; } logcommand ( si , CMDLOG_DO , ""CLEAR:FLAGS:<S2SV_blank>\\2%s\\2"" , mc -> name ) ; command_success_nodata ( si , _ ( ""Cleared<S2SV_blank>flags<S2SV_blank>in<S2SV_blank>\\2%s\\2."" ) , mc -> name ) ; return ; } <S2SV_StartBug> else if ( ! strcasecmp ( target , ""MODIFY"" ) && myentity_find_ext ( target ) == NULL ) <S2SV_EndBug> { free ( target ) ; if ( parc < 3 ) { command_fail ( si , fault_needmoreparams , STR_INSUFFICIENT_PARAMS , ""FLAGS"" ) ; command_fail ( si , fault_needmoreparams , _ ( ""Syntax:<S2SV_blank>FLAGS<S2SV_blank><#channel><S2SV_blank>MODIFY<S2SV_blank>[target]<S2SV_blank><flags>"" ) ) ; return ; } flagstr = strchr ( parv [ 2 ] , '<S2SV_blank>' ) ; if ( flagstr ) * flagstr ++ = '\\0' ; target = strdup ( parv [ 2 ] ) ; } { myentity_t * mt ; if ( ! si -> smu ) { command_fail ( si , fault_noprivs , _ ( ""You<S2SV_blank>are<S2SV_blank>not<S2SV_blank>logged<S2SV_blank>in."" ) ) ; return ; } if ( ! flagstr ) { if ( ! ( mc -> flags & MC_PUBACL ) && ! chanacs_source_has_flag ( mc , si , CA_ACLVIEW ) ) { command_fail ( si , fault_noprivs , _ ( ""You<S2SV_blank>are<S2SV_blank>not<S2SV_blank>authorized<S2SV_blank>to<S2SV_blank>execute<S2SV_blank>this<S2SV_blank>command."" ) ) ; return ; } if ( validhostmask ( target ) ) ca = chanacs_find_host_literal ( mc , target , 0 ) ; else { if ( ! ( mt = myentity_find_ext ( target ) ) ) { command_fail ( si , fault_nosuch_target , _ ( ""\\2%s\\2<S2SV_blank>is<S2SV_blank>not<S2SV_blank>registered."" ) , target ) ; return ; } free ( target ) ; target = sstrdup ( mt -> name ) ; ca = chanacs_find_literal ( mc , mt , 0 ) ; } if ( ca != NULL ) { str1 = bitmask_to_flags2 ( ca -> level , 0 ) ; command_success_string ( si , str1 , _ ( ""Flags<S2SV_blank>for<S2SV_blank>\\2%s\\2<S2SV_blank>in<S2SV_blank>\\2%s\\2<S2SV_blank>are<S2SV_blank>\\2%s\\2."" ) , target , channel , str1 ) ; } else command_success_string ( si , """" , _ ( ""No<S2SV_blank>flags<S2SV_blank>for<S2SV_blank>\\2%s\\2<S2SV_blank>in<S2SV_blank>\\2%s\\2."" ) , target , channel ) ; logcommand ( si , CMDLOG_GET , ""FLAGS:<S2SV_blank>\\2%s\\2<S2SV_blank>on<S2SV_blank>\\2%s\\2"" , mc -> name , target ) ; return ; } restrictflags = chanacs_source_flags ( mc , si ) ; if ( restrictflags & CA_FOUNDER ) restrictflags = ca_all ; else { if ( ! ( restrictflags & CA_FLAGS ) ) { if ( restrictflags & CA_AKICK || si -> smu == NULL || irccasecmp ( target , entity ( si -> smu ) -> name ) || strcmp ( flagstr , ""-*"" ) ) { command_fail ( si , fault_noprivs , _ ( ""You<S2SV_blank>are<S2SV_blank>not<S2SV_blank>authorized<S2SV_blank>to<S2SV_blank>execute<S2SV_blank>this<S2SV_blank>command."" ) ) ; return ; } } if ( irccasecmp ( target , entity ( si -> smu ) -> name ) ) restrictflags = allow_flags ( mc , restrictflags ) ; else restrictflags |= allow_flags ( mc , restrictflags ) ; } if ( * flagstr == '+' || * flagstr == '-' || * flagstr == '=' ) { flags_make_bitmasks ( flagstr , & addflags , & removeflags ) ; if ( addflags == 0 && removeflags == 0 ) { command_fail ( si , fault_badparams , _ ( ""No<S2SV_blank>valid<S2SV_blank>flags<S2SV_blank>given,<S2SV_blank>use<S2SV_blank>/%s%s<S2SV_blank>HELP<S2SV_blank>FLAGS<S2SV_blank>for<S2SV_blank>a<S2SV_blank>list"" ) , ircd -> uses_rcommand ? """" : ""msg<S2SV_blank>"" , chansvs . me -> disp ) ; return ; } } else { addflags = get_template_flags ( mc , flagstr ) ; if ( addflags == 0 ) { if ( * target == '+' || * target == '-' || * target == '=' ) command_fail ( si , fault_badparams , _ ( ""Usage:<S2SV_blank>FLAGS<S2SV_blank>%s<S2SV_blank>[target]<S2SV_blank>[flags]"" ) , mc -> name ) ; else command_fail ( si , fault_badparams , _ ( ""Invalid<S2SV_blank>template<S2SV_blank>name<S2SV_blank>given,<S2SV_blank>use<S2SV_blank>/%s%s<S2SV_blank>TEMPLATE<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>a<S2SV_blank>list"" ) , ircd -> uses_rcommand ? """" : ""msg<S2SV_blank>"" , chansvs . me -> disp , mc -> name ) ; return ; } removeflags = ca_all & ~ addflags ; } if ( ! validhostmask ( target ) ) { if ( ! ( mt = myentity_find_ext ( target ) ) ) { command_fail ( si , fault_nosuch_target , _ ( ""\\2%s\\2<S2SV_blank>is<S2SV_blank>not<S2SV_blank>registered."" ) , target ) ; return ; } free ( target ) ; target = sstrdup ( mt -> name ) ; ca = chanacs_open ( mc , mt , NULL , true , entity ( si -> smu ) ) ; if ( ca -> level & CA_FOUNDER && removeflags & CA_FLAGS && ! ( removeflags & CA_FOUNDER ) ) { command_fail ( si , fault_noprivs , _ ( ""You<S2SV_blank>may<S2SV_blank>not<S2SV_blank>remove<S2SV_blank>a<S2SV_blank>founder\'s<S2SV_blank>+f<S2SV_blank>access."" ) ) ; return ; } if ( ca -> level & CA_FOUNDER && removeflags & CA_FOUNDER && mychan_num_founders ( mc ) == 1 ) { command_fail ( si , fault_noprivs , _ ( ""You<S2SV_blank>may<S2SV_blank>not<S2SV_blank>remove<S2SV_blank>the<S2SV_blank>last<S2SV_blank>founder."" ) ) ; return ; } if ( ! ( ca -> level & CA_FOUNDER ) && addflags & CA_FOUNDER ) { if ( mychan_num_founders ( mc ) >= chansvs . maxfounders ) { command_fail ( si , fault_noprivs , _ ( ""Only<S2SV_blank>%d<S2SV_blank>founders<S2SV_blank>allowed<S2SV_blank>per<S2SV_blank>channel."" ) , chansvs . maxfounders ) ; chanacs_close ( ca ) ; return ; } if ( ! myentity_can_register_channel ( mt ) ) { command_fail ( si , fault_toomany , _ ( ""\\2%s\\2<S2SV_blank>has<S2SV_blank>too<S2SV_blank>many<S2SV_blank>channels<S2SV_blank>registered."" ) , mt -> name ) ; chanacs_close ( ca ) ; return ; } if ( ! myentity_allow_foundership ( mt ) ) { command_fail ( si , fault_toomany , _ ( ""\\2%s\\2<S2SV_blank>cannot<S2SV_blank>take<S2SV_blank>foundership<S2SV_blank>of<S2SV_blank>a<S2SV_blank>channel."" ) , mt -> name ) ; chanacs_close ( ca ) ; return ; } } if ( addflags & CA_FOUNDER ) addflags |= CA_FLAGS , removeflags &= ~ CA_FLAGS ; if ( isuser ( mt ) && ( MU_NEVEROP & user ( mt ) -> flags && addflags != CA_AKICK && addflags != 0 && ( ca -> level == 0 || ca -> level == CA_AKICK ) ) ) { command_fail ( si , fault_noprivs , _ ( ""\\2%s\\2<S2SV_blank>does<S2SV_blank>not<S2SV_blank>wish<S2SV_blank>to<S2SV_blank>be<S2SV_blank>added<S2SV_blank>to<S2SV_blank>channel<S2SV_blank>access<S2SV_blank>lists<S2SV_blank>(NEVEROP<S2SV_blank>set)."" ) , mt -> name ) ; chanacs_close ( ca ) ; return ; } if ( ca -> level == 0 && chanacs_is_table_full ( ca ) ) { command_fail ( si , fault_toomany , _ ( ""Channel<S2SV_blank>%s<S2SV_blank>access<S2SV_blank>list<S2SV_blank>is<S2SV_blank>full."" ) , mc -> name ) ; chanacs_close ( ca ) ; return ; } req . ca = ca ; req . oldlevel = ca -> level ; if ( ! chanacs_modify ( ca , & addflags , & removeflags , restrictflags ) ) { command_fail ( si , fault_noprivs , _ ( ""You<S2SV_blank>are<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>\\2%s\\2<S2SV_blank>on<S2SV_blank>\\2%s\\2<S2SV_blank>in<S2SV_blank>\\2%s\\2."" ) , bitmask_to_flags2 ( addflags , removeflags ) , mt -> name , mc -> name ) ; chanacs_close ( ca ) ; return ; } req . newlevel = ca -> level ; hook_call_channel_acl_change ( & req ) ; chanacs_close ( ca ) ; } else { if ( addflags & CA_FOUNDER ) { command_fail ( si , fault_badparams , _ ( ""You<S2SV_blank>may<S2SV_blank>not<S2SV_blank>set<S2SV_blank>founder<S2SV_blank>status<S2SV_blank>on<S2SV_blank>a<S2SV_blank>hostmask."" ) ) ; return ; } ca = chanacs_open ( mc , NULL , target , true , entity ( si -> smu ) ) ; if ( ca -> level == 0 && chanacs_is_table_full ( ca ) ) { command_fail ( si , fault_toomany , _ ( ""Channel<S2SV_blank>%s<S2SV_blank>access<S2SV_blank>list<S2SV_blank>is<S2SV_blank>full."" ) , mc -> name ) ; chanacs_close ( ca ) ; return ; } req . ca = ca ; req . oldlevel = ca -> level ; if ( ! chanacs_modify ( ca , & addflags , & removeflags , restrictflags ) ) { command_fail ( si , fault_noprivs , _ ( ""You<S2SV_blank>are<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>\\2%s\\2<S2SV_blank>on<S2SV_blank>\\2%s\\2<S2SV_blank>in<S2SV_blank>\\2%s\\2."" ) , bitmask_to_flags2 ( addflags , removeflags ) , target , mc -> name ) ; chanacs_close ( ca ) ; return ; } req . newlevel = ca -> level ; hook_call_channel_acl_change ( & req ) ; chanacs_close ( ca ) ; } if ( ( addflags | removeflags ) == 0 ) { command_fail ( si , fault_nochange , _ ( ""Channel<S2SV_blank>access<S2SV_blank>to<S2SV_blank>\\2%s\\2<S2SV_blank>for<S2SV_blank>\\2%s\\2<S2SV_blank>unchanged."" ) , channel , target ) ; return ; } flagstr = bitmask_to_flags2 ( addflags , removeflags ) ; command_success_nodata ( si , _ ( ""Flags<S2SV_blank>\\2%s\\2<S2SV_blank>were<S2SV_blank>set<S2SV_blank>on<S2SV_blank>\\2%s\\2<S2SV_blank>in<S2SV_blank>\\2%s\\2."" ) , flagstr , target , channel ) ; logcommand ( si , CMDLOG_SET , ""FLAGS:<S2SV_blank>\\2%s\\2<S2SV_blank>\\2%s\\2<S2SV_blank>\\2%s\\2"" , mc -> name , target , flagstr ) ; verbose ( mc , ""\\2%s\\2<S2SV_blank>set<S2SV_blank>flags<S2SV_blank>\\2%s\\2<S2SV_blank>on<S2SV_blank>\\2%s\\2"" , get_source_name ( si ) , flagstr , target ) ; } free ( target ) ; }",else if ( anope_flags_compat && <S2SV_ModStart> else if ( anope_flags_compat && <S2SV_ModStart> else if ( anope_flags_compat &&
782,"static struct key * construct_key_and_link ( struct keyring_search_context * ctx , const char * callout_info , size_t callout_len , void * aux , struct key * dest_keyring , unsigned long flags ) { struct key_user * user ; struct key * key ; int ret ; kenter ( """" ) ; if ( ctx -> index_key . type == & key_type_keyring ) return ERR_PTR ( - EPERM ) ; <S2SV_StartBug> user = key_user_lookup ( current_fsuid ( ) ) ; <S2SV_EndBug> if ( ! user ) <S2SV_StartBug> return ERR_PTR ( - ENOMEM ) ; <S2SV_EndBug> construct_get_dest_keyring ( & dest_keyring ) ; ret = construct_alloc_key ( ctx , dest_keyring , flags , user , & key ) ; key_user_put ( user ) ; if ( ret == 0 ) { ret = construct_key ( key , callout_info , callout_len , aux , dest_keyring ) ; if ( ret < 0 ) { kdebug ( ""cons<S2SV_blank>failed"" ) ; goto construction_failed ; } } else if ( ret == - EINPROGRESS ) { ret = 0 ; } else { <S2SV_StartBug> goto couldnt_alloc_key ; <S2SV_EndBug> } key_put ( dest_keyring ) ; kleave ( ""<S2SV_blank>=<S2SV_blank>key<S2SV_blank>%d"" , key_serial ( key ) ) ; return key ; construction_failed : key_negate_and_link ( key , key_negative_timeout , NULL , NULL ) ; key_put ( key ) ; <S2SV_StartBug> couldnt_alloc_key : <S2SV_EndBug> <S2SV_StartBug> key_put ( dest_keyring ) ; <S2SV_EndBug> kleave ( ""<S2SV_blank>=<S2SV_blank>%d"" , ret ) ; return ERR_PTR ( ret ) ; }",EPERM ) ; ret = construct_get_dest_keyring ( & dest_keyring ) ; if ( ret ) goto error ; <S2SV_ModStart> ! user ) { ret = - ENOMEM ; goto error_put_dest_keyring ; } <S2SV_ModEnd> ret = construct_alloc_key <S2SV_ModStart> else { goto error_put_dest_keyring <S2SV_ModEnd> ; } key_put <S2SV_ModStart> key ) ; error_put_dest_keyring <S2SV_ModEnd> : key_put ( <S2SV_ModStart> dest_keyring ) ; error :
783,"static int http_read_stream ( URLContext * h , uint8_t * buf , int size ) { HTTPContext * s = h -> priv_data ; int err , new_location , read_ret ; int64_t seek_ret ; if ( ! s -> hd ) return AVERROR_EOF ; if ( s -> end_chunked_post && ! s -> end_header ) { err = http_read_header ( h , & new_location ) ; if ( err < 0 ) return err ; } <S2SV_StartBug> if ( s -> chunksize >= 0 ) { <S2SV_EndBug> if ( ! s -> chunksize ) { char line [ 32 ] ; do { if ( ( err = http_get_line ( s , line , sizeof ( line ) ) ) < 0 ) return err ; } while ( ! * line ) ; <S2SV_StartBug> s -> chunksize = strtoll ( line , NULL , 16 ) ; <S2SV_EndBug> <S2SV_StartBug> av_log ( NULL , AV_LOG_TRACE , ""Chunked<S2SV_blank>encoding<S2SV_blank>data<S2SV_blank>size:<S2SV_blank>%"" PRId64 ""\'\\n"" , <S2SV_EndBug> s -> chunksize ) ; if ( ! s -> chunksize ) <S2SV_StartBug> return 0 ; <S2SV_EndBug> } size = FFMIN ( size , s -> chunksize ) ; } # if CONFIG_ZLIB if ( s -> compressed ) return http_buf_read_compressed ( h , buf , size ) ; # endif read_ret = http_buf_read ( h , buf , size ) ; if ( ( read_ret < 0 && s -> reconnect && ( ! h -> is_streamed || s -> reconnect_streamed ) && s -> filesize > 0 && s -> off < s -> filesize ) || ( read_ret == 0 && s -> reconnect_at_eof && ( ! h -> is_streamed || s -> reconnect_streamed ) ) ) { <S2SV_StartBug> int64_t target = h -> is_streamed ? 0 : s -> off ; <S2SV_EndBug> if ( s -> reconnect_delay > s -> reconnect_delay_max ) return AVERROR ( EIO ) ; <S2SV_StartBug> av_log ( h , AV_LOG_INFO , ""Will<S2SV_blank>reconnect<S2SV_blank>at<S2SV_blank>%"" PRId64 ""<S2SV_blank>error=%s.\\n"" , s -> off , av_err2str ( read_ret ) ) ; <S2SV_EndBug> av_usleep ( 1000U * 1000 * s -> reconnect_delay ) ; s -> reconnect_delay = 1 + 2 * s -> reconnect_delay ; seek_ret = http_seek_internal ( h , target , SEEK_SET , 1 ) ; if ( seek_ret != target ) { <S2SV_StartBug> av_log ( h , AV_LOG_ERROR , ""Failed<S2SV_blank>to<S2SV_blank>reconnect<S2SV_blank>at<S2SV_blank>%"" PRId64 "".\\n"" , target ) ; <S2SV_EndBug> return read_ret ; } read_ret = http_buf_read ( h , buf , size ) ; } else s -> reconnect_delay = 0 ; return read_ret ; }","s -> chunksize != UINT64_MAX <S2SV_ModEnd> ) { if <S2SV_ModStart> -> chunksize = strtoull <S2SV_ModEnd> ( line , <S2SV_ModStart> ; av_log ( h <S2SV_ModEnd> , AV_LOG_TRACE , <S2SV_ModStart> AV_LOG_TRACE , ""Chunked<S2SV_blank>encoding<S2SV_blank>data<S2SV_blank>size:<S2SV_blank>%"" PRIu64 <S2SV_ModEnd> ""\'\\n"" , s <S2SV_ModStart> return 0 ; else if ( s -> chunksize == UINT64_MAX ) { av_log ( h , AV_LOG_ERROR , ""Invalid<S2SV_blank>chunk<S2SV_blank>size<S2SV_blank>%"" PRIu64 ""\\n"" , s -> chunksize ) ; return AVERROR ( EINVAL ) ; } <S2SV_ModStart> ) ) { uint64_t <S2SV_ModEnd> target = h <S2SV_ModStart> AV_LOG_INFO , ""Will<S2SV_blank>reconnect<S2SV_blank>at<S2SV_blank>%"" PRIu64 <S2SV_ModEnd> ""<S2SV_blank>error=%s.\\n"" , s <S2SV_ModStart> AV_LOG_ERROR , ""Failed<S2SV_blank>to<S2SV_blank>reconnect<S2SV_blank>at<S2SV_blank>%"" PRIu64 <S2SV_ModEnd> "".\\n"" , target"
784,"static inline int ldsem_cmpxchg ( long * old , long new , struct ld_semaphore * sem ) { <S2SV_StartBug> long tmp = * old ; <S2SV_EndBug> * old = atomic_long_cmpxchg ( & sem -> count , * old , new ) ; <S2SV_StartBug> return * old == tmp ; <S2SV_EndBug> }",long tmp = <S2SV_ModEnd> atomic_long_cmpxchg ( & <S2SV_ModStart> new ) ; if ( tmp == * old ) { * old = new ; return 1 ; } else { * old = tmp ; return 0 ; } <S2SV_ModEnd> } <S2SV_null> <S2SV_null>
785,"<S2SV_StartBug> static void write_sync_code ( struct vp9_write_bit_buffer * wb ) { <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_literal ( wb , VP9_SYNC_CODE_0 , 8 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_literal ( wb , VP9_SYNC_CODE_1 , 8 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_literal ( wb , VP9_SYNC_CODE_2 , 8 ) ; <S2SV_EndBug> }","write_sync_code ( struct vpx_write_bit_buffer <S2SV_ModEnd> * wb ) <S2SV_ModStart> wb ) { vpx_wb_write_literal <S2SV_ModEnd> ( wb , <S2SV_ModStart> 8 ) ; vpx_wb_write_literal <S2SV_ModEnd> ( wb , <S2SV_ModStart> 8 ) ; vpx_wb_write_literal <S2SV_ModEnd> ( wb ,"
786,"<S2SV_StartBug> static void nsc_encode_sse2 ( NSC_CONTEXT * context , const BYTE * data , <S2SV_EndBug> UINT32 scanline ) { nsc_encode_argb_to_aycocg_sse2 ( context , data , scanline ) ; if ( context -> ChromaSubsamplingLevel > 0 ) { nsc_encode_subsampling_sse2 ( context ) ; } <S2SV_StartBug> } <S2SV_EndBug>",<S2SV_null> <S2SV_null> static BOOL <S2SV_ModEnd> nsc_encode_sse2 ( NSC_CONTEXT <S2SV_ModStart> ) ; } return TRUE ;
787,"static Image * ReadSUNImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define RMT_EQUAL_RGB 1 # define RMT_NONE 0 # define RMT_RAW 2 # define RT_STANDARD 1 # define RT_ENCODED 2 # define RT_FORMAT_RGB 3 typedef struct _SUNInfo { unsigned int magic , width , height , depth , length , type , maptype , maplength ; } SUNInfo ; Image * image ; int bit ; MagickBooleanType status ; MagickSizeType number_pixels ; register Quantum * q ; register ssize_t i , x ; register unsigned char * p ; size_t bytes_per_line , extent , length ; ssize_t count , y ; SUNInfo sun_info ; unsigned char * sun_data , * sun_pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) ResetMagickMemory ( & sun_info , 0 , sizeof ( sun_info ) ) ; sun_info . magic = ReadBlobMSBLong ( image ) ; do { if ( sun_info . magic != 0x59a66a95 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; sun_info . width = ReadBlobMSBLong ( image ) ; sun_info . height = ReadBlobMSBLong ( image ) ; sun_info . depth = ReadBlobMSBLong ( image ) ; sun_info . length = ReadBlobMSBLong ( image ) ; sun_info . type = ReadBlobMSBLong ( image ) ; sun_info . maptype = ReadBlobMSBLong ( image ) ; sun_info . maplength = ReadBlobMSBLong ( image ) ; extent = sun_info . height * sun_info . width ; if ( ( sun_info . height != 0 ) && ( sun_info . width != extent / sun_info . height ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . type != RT_STANDARD ) && ( sun_info . type != RT_ENCODED ) && ( sun_info . type != RT_FORMAT_RGB ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . maptype == RMT_NONE ) && ( sun_info . maplength != 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . depth == 0 ) || ( sun_info . depth > 32 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( sun_info . maptype != RMT_NONE ) && ( sun_info . maptype != RMT_EQUAL_RGB ) && ( sun_info . maptype != RMT_RAW ) ) ThrowReaderException ( CoderError , ""ColormapTypeNotSupported"" ) ; image -> columns = sun_info . width ; image -> rows = sun_info . height ; image -> depth = sun_info . depth <= 8 ? sun_info . depth : MAGICKCORE_QUANTUM_DEPTH ; if ( sun_info . depth < 24 ) { size_t one ; image -> colors = sun_info . maplength ; one = 1 ; if ( sun_info . maptype == RMT_NONE ) image -> colors = one << sun_info . depth ; if ( sun_info . maptype == RMT_EQUAL_RGB ) image -> colors = sun_info . maplength / 3 ; if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; } switch ( sun_info . maptype ) <S2SV_StartBug> { <S2SV_EndBug> case RMT_EQUAL_RGB : { unsigned char * sun_colormap ; sun_colormap = ( unsigned char * ) AcquireQuantumMemory ( image -> colors , sizeof ( * sun_colormap ) ) ; if ( sun_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , image -> colors , sun_colormap ) ; if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) image -> colormap [ i ] . red = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ; count = ReadBlob ( image , image -> colors , sun_colormap ) ; if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) image -> colormap [ i ] . green = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ; count = ReadBlob ( image , image -> colors , sun_colormap ) ; if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) image -> colormap [ i ] . blue = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ; sun_colormap = ( unsigned char * ) RelinquishMagickMemory ( sun_colormap ) ; break ; } case RMT_RAW : { unsigned char * sun_colormap ; sun_colormap = ( unsigned char * ) AcquireQuantumMemory ( sun_info . maplength , sizeof ( * sun_colormap ) ) ; if ( sun_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ReadBlob ( image , sun_info . maplength , sun_colormap ) ; if ( count != ( ssize_t ) sun_info . maplength ) ThrowReaderException ( CorruptImageError , ""UnexpectedEndOfFile"" ) ; sun_colormap = ( unsigned char * ) RelinquishMagickMemory ( sun_colormap ) ; break ; } default : ThrowReaderException ( CoderError , ""ColormapTypeNotSupported"" ) ; } image -> alpha_trait = sun_info . depth == 32 ? BlendPixelTrait : UndefinedPixelTrait ; image -> columns = sun_info . width ; image -> rows = sun_info . height ; if ( image_info -> ping != MagickFalse ) { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; if ( ( sun_info . length * sizeof ( * sun_data ) ) / sizeof ( * sun_data ) != sun_info . length || ! sun_info . length ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; number_pixels = ( MagickSizeType ) image -> columns * image -> rows ; if ( ( sun_info . type != RT_ENCODED ) && ( sun_info . depth >= 8 ) && ( ( number_pixels * ( ( sun_info . depth + 7 ) / 8 ) ) > sun_info . length ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; bytes_per_line = sun_info . width * sun_info . depth ; sun_data = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) MagickMax ( sun_info . length , bytes_per_line * sun_info . width ) , sizeof ( * sun_data ) ) ; if ( sun_data == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; count = ( ssize_t ) ReadBlob ( image , sun_info . length , sun_data ) ; if ( count != ( ssize_t ) sun_info . length ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; sun_pixels = sun_data ; bytes_per_line = 0 ; if ( sun_info . type == RT_ENCODED ) { size_t height ; height = sun_info . height ; if ( ( height == 0 ) || ( sun_info . width == 0 ) || ( sun_info . depth == 0 ) || ( ( bytes_per_line / sun_info . depth ) != sun_info . width ) ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; bytes_per_line += 15 ; bytes_per_line <<= 1 ; if ( ( bytes_per_line >> 1 ) != ( sun_info . width * sun_info . depth + 15 ) ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; bytes_per_line >>= 4 ; sun_pixels = ( unsigned char * ) AcquireQuantumMemory ( height , bytes_per_line * sizeof ( * sun_pixels ) ) ; if ( sun_pixels == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) DecodeImage ( sun_data , sun_info . length , sun_pixels , bytes_per_line * height ) ; sun_data = ( unsigned char * ) RelinquishMagickMemory ( sun_data ) ; } p = sun_pixels ; if ( sun_info . depth == 1 ) for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 7 ) ; x += 8 ) { for ( bit = 7 ; bit >= 0 ; bit -- ) { SetPixelIndex ( image , ( Quantum ) ( ( * p ) & ( 0x01 << bit ) ? 0x00 : 0x01 ) , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( ( image -> columns % 8 ) != 0 ) { for ( bit = 7 ; bit >= ( int ) ( 8 - ( image -> columns % 8 ) ) ; bit -- ) { SetPixelIndex ( image , ( Quantum ) ( ( * p ) & ( 0x01 << bit ) ? 0x00 : 0x01 ) , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( ( ( ( image -> columns / 8 ) + ( image -> columns % 8 ? 1 : 0 ) ) % 2 ) != 0 ) p ++ ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } else if ( image -> storage_class == PseudoClass ) { if ( bytes_per_line == 0 ) bytes_per_line = image -> columns ; length = image -> rows * ( image -> columns + image -> columns % 2 ) ; if ( ( ( sun_info . type == RT_ENCODED ) && ( length > ( bytes_per_line * image -> rows ) ) ) || ( ( sun_info . type != RT_ENCODED ) && ( length > sun_info . length ) ) ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelIndex ( image , * p ++ , q ) ; q += GetPixelChannels ( image ) ; } if ( ( image -> columns % 2 ) != 0 ) p ++ ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else { size_t bytes_per_pixel ; bytes_per_pixel = 3 ; if ( image -> alpha_trait != UndefinedPixelTrait ) bytes_per_pixel ++ ; if ( bytes_per_line == 0 ) bytes_per_line = bytes_per_pixel * image -> columns ; length = image -> rows * ( bytes_per_line + image -> columns % 2 ) ; if ( ( ( sun_info . type == RT_ENCODED ) && ( length > ( bytes_per_line * image -> rows ) ) ) || ( ( sun_info . type != RT_ENCODED ) && ( length > sun_info . length ) ) ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; if ( sun_info . type == RT_STANDARD ) { SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; } else { SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; } if ( image -> colors != 0 ) { SetPixelRed ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelRed ( image , q ) ] . red ) , q ) ; SetPixelGreen ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelGreen ( image , q ) ] . green ) , q ) ; SetPixelBlue ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelBlue ( image , q ) ] . blue ) , q ) ; } q += GetPixelChannels ( image ) ; } if ( ( ( bytes_per_pixel * image -> columns ) % 2 ) != 0 ) p ++ ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } if ( image -> storage_class == PseudoClass ) ( void ) SyncImage ( image , exception ) ; sun_pixels = ( unsigned char * ) RelinquishMagickMemory ( sun_pixels ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; sun_info . magic = ReadBlobMSBLong ( image ) ; if ( sun_info . magic == 0x59a66a95 ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( sun_info . magic == 0x59a66a95 ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }",maptype ) { case RMT_NONE : break ;
788,"static int check_cond_jmp_op ( struct bpf_verifier_env * env , struct bpf_insn * insn , int * insn_idx ) { struct bpf_verifier_state * this_branch = env -> cur_state ; struct bpf_verifier_state * other_branch ; struct bpf_reg_state * regs = this_branch -> frame [ this_branch -> curframe ] -> regs ; struct bpf_reg_state * dst_reg , * other_branch_regs ; u8 opcode = BPF_OP ( insn -> code ) ; int err ; if ( opcode > BPF_JSLE ) { verbose ( env , ""invalid<S2SV_blank>BPF_JMP<S2SV_blank>opcode<S2SV_blank>%x\\n"" , opcode ) ; return - EINVAL ; } if ( BPF_SRC ( insn -> code ) == BPF_X ) { if ( insn -> imm != 0 ) { verbose ( env , ""BPF_JMP<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n"" ) ; return - EINVAL ; } err = check_reg_arg ( env , insn -> src_reg , SRC_OP ) ; if ( err ) return err ; if ( is_pointer_value ( env , insn -> src_reg ) ) { verbose ( env , ""R%d<S2SV_blank>pointer<S2SV_blank>comparison<S2SV_blank>prohibited\\n"" , insn -> src_reg ) ; return - EACCES ; } } else { if ( insn -> src_reg != BPF_REG_0 ) { verbose ( env , ""BPF_JMP<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n"" ) ; return - EINVAL ; } } err = check_reg_arg ( env , insn -> dst_reg , SRC_OP ) ; if ( err ) return err ; dst_reg = & regs [ insn -> dst_reg ] ; if ( BPF_SRC ( insn -> code ) == BPF_K ) { int pred = is_branch_taken ( dst_reg , insn -> imm , opcode ) ; if ( pred == 1 ) { * insn_idx += insn -> off ; return 0 ; } else if ( pred == 0 ) { return 0 ; } } <S2SV_StartBug> other_branch = push_stack ( env , * insn_idx + insn -> off + 1 , * insn_idx ) ; <S2SV_EndBug> if ( ! other_branch ) return - EFAULT ; other_branch_regs = other_branch -> frame [ other_branch -> curframe ] -> regs ; if ( BPF_SRC ( insn -> code ) == BPF_X ) { if ( dst_reg -> type == SCALAR_VALUE && regs [ insn -> src_reg ] . type == SCALAR_VALUE ) { if ( tnum_is_const ( regs [ insn -> src_reg ] . var_off ) ) reg_set_min_max ( & other_branch_regs [ insn -> dst_reg ] , dst_reg , regs [ insn -> src_reg ] . var_off . value , opcode ) ; else if ( tnum_is_const ( dst_reg -> var_off ) ) reg_set_min_max_inv ( & other_branch_regs [ insn -> src_reg ] , & regs [ insn -> src_reg ] , dst_reg -> var_off . value , opcode ) ; else if ( opcode == BPF_JEQ || opcode == BPF_JNE ) reg_combine_min_max ( & other_branch_regs [ insn -> src_reg ] , & other_branch_regs [ insn -> dst_reg ] , & regs [ insn -> src_reg ] , & regs [ insn -> dst_reg ] , opcode ) ; } } else if ( dst_reg -> type == SCALAR_VALUE ) { reg_set_min_max ( & other_branch_regs [ insn -> dst_reg ] , dst_reg , insn -> imm , opcode ) ; } if ( BPF_SRC ( insn -> code ) == BPF_K && insn -> imm == 0 && ( opcode == BPF_JEQ || opcode == BPF_JNE ) && reg_type_may_be_null ( dst_reg -> type ) ) { mark_ptr_or_null_regs ( this_branch , insn -> dst_reg , opcode == BPF_JNE ) ; mark_ptr_or_null_regs ( other_branch , insn -> dst_reg , opcode == BPF_JEQ ) ; } else if ( ! try_match_pkt_pointers ( insn , dst_reg , & regs [ insn -> src_reg ] , this_branch , other_branch ) && is_pointer_value ( env , insn -> dst_reg ) ) { verbose ( env , ""R%d<S2SV_blank>pointer<S2SV_blank>comparison<S2SV_blank>prohibited\\n"" , insn -> dst_reg ) ; return - EACCES ; } if ( env -> log . level ) print_verifier_state ( env , this_branch -> frame [ this_branch -> curframe ] ) ; return 0 ; }",", * insn_idx , false"
789,"int stats_open_file ( stats_io_t * stats , const char * fpf , int pass ) { int res ; stats -> pass = pass ; if ( pass == 0 ) { stats -> file = fopen ( fpf , ""wb"" ) ; stats -> buf . sz = 0 ; stats -> buf . buf = NULL ; res = ( stats -> file != NULL ) ; } else { # if USE_POSIX_MMAP struct stat stat_buf ; int fd ; fd = open ( fpf , O_RDONLY ) ; stats -> file = fdopen ( fd , ""rb"" ) ; fstat ( fd , & stat_buf ) ; stats -> buf . sz = stat_buf . st_size ; stats -> buf . buf = mmap ( NULL , stats -> buf . sz , PROT_READ , MAP_PRIVATE , fd , 0 ) ; res = ( stats -> buf . buf != NULL ) ; # else size_t nbytes ; stats -> file = fopen ( fpf , ""rb"" ) ; <S2SV_StartBug> if ( fseek ( stats -> file , 0 , SEEK_END ) ) <S2SV_EndBug> fatal ( ""First-pass<S2SV_blank>stats<S2SV_blank>file<S2SV_blank>must<S2SV_blank>be<S2SV_blank>seekable!"" ) ; stats -> buf . sz = stats -> buf_alloc_sz = ftell ( stats -> file ) ; rewind ( stats -> file ) ; stats -> buf . buf = malloc ( stats -> buf_alloc_sz ) ; if ( ! stats -> buf . buf ) fatal ( ""Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>first-pass<S2SV_blank>stats<S2SV_blank>buffer<S2SV_blank>(%lu<S2SV_blank>bytes)"" , ( unsigned int ) stats -> buf_alloc_sz ) ; nbytes = fread ( stats -> buf . buf , 1 , stats -> buf . sz , stats -> file ) ; res = ( nbytes == stats -> buf . sz ) ; # endif } return res ; }","; if ( stats -> file == NULL ) fatal ( ""First-pass<S2SV_blank>stats<S2SV_blank>file<S2SV_blank>does<S2SV_blank>not<S2SV_blank>exist!"" ) ; if ("
790,"static int int_x509_param_set_hosts ( X509_VERIFY_PARAM_ID * id , int mode , const char * name , size_t namelen ) { char * copy ; <S2SV_StartBug> if ( name && memchr ( name , '\\0' , namelen ) ) <S2SV_EndBug> return 0 ; if ( mode == SET_HOST && id -> hosts ) { string_stack_free ( id -> hosts ) ; id -> hosts = NULL ; } if ( name == NULL || namelen == 0 ) return 1 ; copy = strndup ( name , namelen ) ; if ( copy == NULL ) return 0 ; if ( id -> hosts == NULL && ( id -> hosts = sk_OPENSSL_STRING_new_null ( ) ) == NULL ) { free ( copy ) ; return 0 ; } if ( ! sk_OPENSSL_STRING_push ( id -> hosts , copy ) ) { free ( copy ) ; if ( sk_OPENSSL_STRING_num ( id -> hosts ) == 0 ) { sk_OPENSSL_STRING_free ( id -> hosts ) ; id -> hosts = NULL ; } return 0 ; } return 1 ; }",if ( name != NULL && namelen == 0 ) namelen = strlen ( name ) ; if ( name
791,"<S2SV_StartBug> static int mem_resize ( jas_stream_memobj_t * m , int bufsize ) <S2SV_EndBug> { unsigned char * buf ; <S2SV_StartBug> assert ( bufsize >= 0 ) ; <S2SV_EndBug> <S2SV_StartBug> JAS_DBGLOG ( 100 , ( ""mem_resize(%p,<S2SV_blank>%d)\\n"" , m , bufsize ) ) ; <S2SV_EndBug> if ( ! ( buf = jas_realloc2 ( m -> buf_ , bufsize , sizeof ( unsigned char ) ) ) && bufsize ) { JAS_DBGLOG ( 100 , ( ""mem_resize<S2SV_blank>realloc<S2SV_blank>failed\\n"" ) ) ; return - 1 ; } JAS_DBGLOG ( 100 , ( ""mem_resize<S2SV_blank>realloc<S2SV_blank>succeeded\\n"" ) ) ; m -> buf_ = buf ; m -> bufsize_ = bufsize ; return 0 ; }","* m , size_t <S2SV_ModEnd> bufsize ) { <S2SV_ModStart> * buf ; <S2SV_ModEnd> JAS_DBGLOG ( 100 <S2SV_ModStart> 100 , ( ""mem_resize(%p,<S2SV_blank>%zu)\\n"" <S2SV_ModEnd> , m , <S2SV_ModStart> ) ) ; if ( ! bufsize ) { jas_eprintf ( ""mem_resize<S2SV_blank>was<S2SV_blank>not<S2SV_blank>really<S2SV_blank>designed<S2SV_blank>to<S2SV_blank>handle<S2SV_blank>a<S2SV_blank>buffer<S2SV_blank>of<S2SV_blank>size<S2SV_blank>0\\n"" ""This<S2SV_blank>may<S2SV_blank>not<S2SV_blank>work.\\n"" ) ; }"
792,"static int jp2_cmap_getdata ( jp2_box_t * box , jas_stream_t * in ) { jp2_cmap_t * cmap = & box -> data . cmap ; jp2_cmapent_t * ent ; <S2SV_StartBug> unsigned int i ; <S2SV_EndBug> cmap -> numchans = ( box -> datalen ) / 4 ; if ( ! ( cmap -> ents = jas_alloc2 ( cmap -> numchans , sizeof ( jp2_cmapent_t ) ) ) ) { return - 1 ; } for ( i = 0 ; i < cmap -> numchans ; ++ i ) { ent = & cmap -> ents [ i ] ; if ( jp2_getuint16 ( in , & ent -> cmptno ) || jp2_getuint8 ( in , & ent -> map ) || jp2_getuint8 ( in , & ent -> pcol ) ) { return - 1 ; } } return 0 ; }",unsigned int i ; cmap -> ents = 0
793,"static int next_state_val ( CClassNode * cc , OnigCodePoint * vs , OnigCodePoint v , int * vs_israw , int v_israw , enum CCVALTYPE intype , enum CCVALTYPE * type , enum CCSTATE * state , ScanEnv * env ) { int r ; switch ( * state ) { case CCS_VALUE : if ( * type == CCV_SB ) { <S2SV_StartBug> BITSET_SET_BIT ( cc -> bs , ( int ) ( * vs ) ) ; <S2SV_EndBug> } else if ( * type == CCV_CODE_POINT ) { r = add_code_range ( & ( cc -> mbuf ) , env , * vs , * vs ) ; if ( r < 0 ) return r ; } break ; case CCS_RANGE : if ( intype == * type ) { if ( intype == CCV_SB ) { if ( * vs > 0xff || v > 0xff ) return ONIGERR_INVALID_CODE_POINT_VALUE ; if ( * vs > v ) { if ( IS_SYNTAX_BV ( env -> syntax , ONIG_SYN_ALLOW_EMPTY_RANGE_IN_CC ) ) goto ccs_range_end ; else return ONIGERR_EMPTY_RANGE_IN_CHAR_CLASS ; } bitset_set_range ( cc -> bs , ( int ) * vs , ( int ) v ) ; } else { r = add_code_range ( & ( cc -> mbuf ) , env , * vs , v ) ; if ( r < 0 ) return r ; } } else { # if 0 if ( intype == CCV_CODE_POINT && * type == CCV_SB ) { # endif if ( * vs > v ) { if ( IS_SYNTAX_BV ( env -> syntax , ONIG_SYN_ALLOW_EMPTY_RANGE_IN_CC ) ) goto ccs_range_end ; else return ONIGERR_EMPTY_RANGE_IN_CHAR_CLASS ; } bitset_set_range ( cc -> bs , ( int ) * vs , ( int ) ( v < 0xff ? v : 0xff ) ) ; r = add_code_range ( & ( cc -> mbuf ) , env , ( OnigCodePoint ) * vs , v ) ; if ( r < 0 ) return r ; # if 0 } else return ONIGERR_MISMATCH_CODE_LENGTH_IN_CLASS_RANGE ; # endif } ccs_range_end : * state = CCS_COMPLETE ; break ; case CCS_COMPLETE : case CCS_START : * state = CCS_VALUE ; break ; default : break ; } * vs_israw = v_israw ; * vs = v ; * type = intype ; return 0 ; }",CCV_SB ) { if ( * vs > 0xff ) return ONIGERR_INVALID_CODE_POINT_VALUE ;
794,"static void dex_parse_debug_item ( RBinFile * binfile , RBinDexObj * bin , RBinDexClass * c , int MI , int MA , int paddr , int ins_size , int insns_size , char * class_name , int regsz , int debug_info_off ) { struct r_bin_t * rbin = binfile -> rbin ; const ut8 * p4 = r_buf_get_at ( binfile -> buf , debug_info_off , NULL ) ; const ut8 * p4_end = p4 + binfile -> buf -> length - debug_info_off ; ut64 line_start ; ut64 parameters_size ; ut64 param_type_idx ; ut16 argReg = regsz - ins_size ; ut64 source_file_idx = c -> source_file ; RList * params , * debug_positions , * emitted_debug_locals = NULL ; bool keep = true ; if ( argReg > regsz ) { return ; } p4 = r_uleb128 ( p4 , p4_end - p4 , & line_start ) ; p4 = r_uleb128 ( p4 , p4_end - p4 , & parameters_size ) ; ut32 address = 0 ; ut32 line = line_start ; if ( ! ( debug_positions = r_list_newf ( ( RListFree ) free ) ) ) { return ; } if ( ! ( emitted_debug_locals = r_list_newf ( ( RListFree ) free ) ) ) { r_list_free ( debug_positions ) ; return ; } struct dex_debug_local_t debug_locals [ regsz ] ; memset ( debug_locals , 0 , sizeof ( struct dex_debug_local_t ) * regsz ) ; if ( ! ( MA & 0x0008 ) ) { debug_locals [ argReg ] . name = ""this"" ; debug_locals [ argReg ] . descriptor = r_str_newf ( ""%s;"" , class_name ) ; debug_locals [ argReg ] . startAddress = 0 ; debug_locals [ argReg ] . signature = NULL ; debug_locals [ argReg ] . live = true ; argReg ++ ; } if ( ! ( params = dex_method_signature2 ( bin , MI ) ) ) { r_list_free ( debug_positions ) ; r_list_free ( emitted_debug_locals ) ; return ; } RListIter * iter = r_list_iterator ( params ) ; char * name ; char * type ; int reg ; r_list_foreach ( params , iter , type ) { if ( ( argReg >= regsz ) || ! type || parameters_size <= 0 ) { r_list_free ( debug_positions ) ; r_list_free ( params ) ; r_list_free ( emitted_debug_locals ) ; return ; } p4 = r_uleb128 ( p4 , p4_end - p4 , & param_type_idx ) ; param_type_idx -= 1 ; name = getstr ( bin , param_type_idx ) ; reg = argReg ; switch ( type [ 0 ] ) { case 'D' : case 'J' : argReg += 2 ; break ; default : argReg += 1 ; break ; } if ( name ) { debug_locals [ reg ] . name = name ; debug_locals [ reg ] . descriptor = type ; debug_locals [ reg ] . signature = NULL ; debug_locals [ reg ] . startAddress = address ; debug_locals [ reg ] . live = true ; } -- parameters_size ; } <S2SV_StartBug> ut8 opcode = * ( p4 ++ ) & 0xff ; <S2SV_EndBug> while ( keep ) { switch ( opcode ) { case 0x0 : keep = false ; break ; case 0x1 : { ut64 addr_diff ; p4 = r_uleb128 ( p4 , p4_end - p4 , & addr_diff ) ; address += addr_diff ; } break ; case 0x2 : { st64 line_diff = r_sleb128 ( & p4 , p4_end ) ; line += line_diff ; } break ; case 0x3 : { ut64 register_num ; ut64 name_idx ; ut64 type_idx ; p4 = r_uleb128 ( p4 , p4_end - p4 , & register_num ) ; p4 = r_uleb128 ( p4 , p4_end - p4 , & name_idx ) ; name_idx -= 1 ; p4 = r_uleb128 ( p4 , p4_end - p4 , & type_idx ) ; type_idx -= 1 ; if ( register_num >= regsz ) { r_list_free ( debug_positions ) ; r_list_free ( params ) ; return ; } if ( debug_locals [ register_num ] . live ) { struct dex_debug_local_t * local = malloc ( sizeof ( struct dex_debug_local_t ) ) ; if ( ! local ) { keep = false ; break ; } local -> name = debug_locals [ register_num ] . name ; local -> descriptor = debug_locals [ register_num ] . descriptor ; local -> startAddress = debug_locals [ register_num ] . startAddress ; local -> signature = debug_locals [ register_num ] . signature ; local -> live = true ; local -> reg = register_num ; local -> endAddress = address ; r_list_append ( emitted_debug_locals , local ) ; } debug_locals [ register_num ] . name = getstr ( bin , name_idx ) ; debug_locals [ register_num ] . descriptor = dex_type_descriptor ( bin , type_idx ) ; debug_locals [ register_num ] . startAddress = address ; debug_locals [ register_num ] . signature = NULL ; debug_locals [ register_num ] . live = true ; } break ; case 0x4 : { ut64 register_num ; ut64 name_idx ; ut64 type_idx ; ut64 sig_idx ; p4 = r_uleb128 ( p4 , p4_end - p4 , & register_num ) ; p4 = r_uleb128 ( p4 , p4_end - p4 , & name_idx ) ; name_idx -= 1 ; p4 = r_uleb128 ( p4 , p4_end - p4 , & type_idx ) ; type_idx -= 1 ; p4 = r_uleb128 ( p4 , p4_end - p4 , & sig_idx ) ; sig_idx -= 1 ; if ( register_num >= regsz ) { r_list_free ( debug_positions ) ; r_list_free ( params ) ; return ; } if ( debug_locals [ register_num ] . live ) { struct dex_debug_local_t * local = malloc ( sizeof ( struct dex_debug_local_t ) ) ; if ( ! local ) { keep = false ; break ; } local -> name = debug_locals [ register_num ] . name ; local -> descriptor = debug_locals [ register_num ] . descriptor ; local -> startAddress = debug_locals [ register_num ] . startAddress ; local -> signature = debug_locals [ register_num ] . signature ; local -> live = true ; local -> reg = register_num ; local -> endAddress = address ; r_list_append ( emitted_debug_locals , local ) ; } debug_locals [ register_num ] . name = getstr ( bin , name_idx ) ; debug_locals [ register_num ] . descriptor = dex_type_descriptor ( bin , type_idx ) ; debug_locals [ register_num ] . startAddress = address ; debug_locals [ register_num ] . signature = getstr ( bin , sig_idx ) ; debug_locals [ register_num ] . live = true ; } break ; case 0x5 : { ut64 register_num ; p4 = r_uleb128 ( p4 , p4_end - p4 , & register_num ) ; if ( debug_locals [ register_num ] . live ) { struct dex_debug_local_t * local = malloc ( sizeof ( struct dex_debug_local_t ) ) ; if ( ! local ) { keep = false ; break ; } local -> name = debug_locals [ register_num ] . name ; local -> descriptor = debug_locals [ register_num ] . descriptor ; local -> startAddress = debug_locals [ register_num ] . startAddress ; local -> signature = debug_locals [ register_num ] . signature ; local -> live = true ; local -> reg = register_num ; local -> endAddress = address ; r_list_append ( emitted_debug_locals , local ) ; } debug_locals [ register_num ] . live = false ; } break ; case 0x6 : { ut64 register_num ; p4 = r_uleb128 ( p4 , p4_end - p4 , & register_num ) ; if ( ! debug_locals [ register_num ] . live ) { debug_locals [ register_num ] . startAddress = address ; debug_locals [ register_num ] . live = true ; } } break ; case 0x7 : break ; case 0x8 : break ; case 0x9 : { p4 = r_uleb128 ( p4 , p4_end - p4 , & source_file_idx ) ; source_file_idx -- ; } break ; default : { int adjusted_opcode = opcode - 0x0a ; address += ( adjusted_opcode / 15 ) ; line += - 4 + ( adjusted_opcode % 15 ) ; struct dex_debug_position_t * position = malloc ( sizeof ( struct dex_debug_position_t ) ) ; if ( ! position ) { keep = false ; break ; } position -> source_file_idx = source_file_idx ; position -> address = address ; position -> line = line ; r_list_append ( debug_positions , position ) ; } break ; } opcode = * ( p4 ++ ) & 0xff ; } if ( ! binfile -> sdb_addrinfo ) { binfile -> sdb_addrinfo = sdb_new0 ( ) ; } char * fileline ; char offset [ 64 ] ; char * offset_ptr ; RListIter * iter1 ; struct dex_debug_position_t * pos ; r_list_foreach ( debug_positions , iter1 , pos ) { fileline = r_str_newf ( ""%s|%"" PFMT64d , getstr ( bin , pos -> source_file_idx ) , pos -> line ) ; offset_ptr = sdb_itoa ( pos -> address + paddr , offset , 16 ) ; sdb_set ( binfile -> sdb_addrinfo , offset_ptr , fileline , 0 ) ; sdb_set ( binfile -> sdb_addrinfo , fileline , offset_ptr , 0 ) ; } if ( ! dexdump ) { r_list_free ( debug_positions ) ; r_list_free ( emitted_debug_locals ) ; r_list_free ( params ) ; return ; } RListIter * iter2 ; struct dex_debug_position_t * position ; rbin -> cb_printf ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>positions<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>:\\n"" ) ; r_list_foreach ( debug_positions , iter2 , position ) { rbin -> cb_printf ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>0x%04llx<S2SV_blank>line=%llu\\n"" , position -> address , position -> line ) ; } rbin -> cb_printf ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>locals<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>:\\n"" ) ; RListIter * iter3 ; struct dex_debug_local_t * local ; r_list_foreach ( emitted_debug_locals , iter3 , local ) { if ( local -> signature ) { rbin -> cb_printf ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>0x%04x<S2SV_blank>-<S2SV_blank>0x%04x<S2SV_blank>reg=%d<S2SV_blank>%s<S2SV_blank>%s<S2SV_blank>%s\\n"" , local -> startAddress , local -> endAddress , local -> reg , local -> name , local -> descriptor , local -> signature ) ; } else { rbin -> cb_printf ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>0x%04x<S2SV_blank>-<S2SV_blank>0x%04x<S2SV_blank>reg=%d<S2SV_blank>%s<S2SV_blank>%s\\n"" , local -> startAddress , local -> endAddress , local -> reg , local -> name , local -> descriptor ) ; } } for ( reg = 0 ; reg < regsz ; reg ++ ) { if ( debug_locals [ reg ] . live ) { if ( debug_locals [ reg ] . signature ) { rbin -> cb_printf ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>0x%04x<S2SV_blank>-<S2SV_blank>0x%04x<S2SV_blank>reg=%d<S2SV_blank>%s<S2SV_blank>%s<S2SV_blank>"" ""%s\\n"" , debug_locals [ reg ] . startAddress , insns_size , reg , debug_locals [ reg ] . name , debug_locals [ reg ] . descriptor , debug_locals [ reg ] . signature ) ; } else { rbin -> cb_printf ( ""<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>0x%04x<S2SV_blank>-<S2SV_blank>0x%04x<S2SV_blank>reg=%d<S2SV_blank>%s<S2SV_blank>%s"" ""\\n"" , debug_locals [ reg ] . startAddress , insns_size , reg , debug_locals [ reg ] . name , debug_locals [ reg ] . descriptor ) ; } } } r_list_free ( debug_positions ) ; r_list_free ( emitted_debug_locals ) ; r_list_free ( params ) ; }",parameters_size ; } if ( p4 <= 0 ) { return ; }
795,"static int archive_read_format_cpio_read_header ( struct archive_read * a , struct archive_entry * entry ) { struct cpio * cpio ; const void * h ; struct archive_string_conv * sconv ; size_t namelength ; size_t name_pad ; int r ; cpio = ( struct cpio * ) ( a -> format -> data ) ; sconv = cpio -> opt_sconv ; if ( sconv == NULL ) { if ( ! cpio -> init_default_conversion ) { cpio -> sconv_default = archive_string_default_conversion_for_read ( & ( a -> archive ) ) ; cpio -> init_default_conversion = 1 ; } sconv = cpio -> sconv_default ; } r = ( cpio -> read_header ( a , cpio , entry , & namelength , & name_pad ) ) ; if ( r < ARCHIVE_WARN ) return ( r ) ; h = __archive_read_ahead ( a , namelength + name_pad , NULL ) ; if ( h == NULL ) return ( ARCHIVE_FATAL ) ; if ( archive_entry_copy_pathname_l ( entry , ( const char * ) h , namelength , sconv ) != 0 ) { if ( errno == ENOMEM ) { archive_set_error ( & a -> archive , ENOMEM , ""Can\'t<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>Pathname"" ) ; return ( ARCHIVE_FATAL ) ; } archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , ""Pathname<S2SV_blank>can\'t<S2SV_blank>be<S2SV_blank>converted<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>current<S2SV_blank>locale."" , archive_string_conversion_charset_name ( sconv ) ) ; r = ARCHIVE_WARN ; } cpio -> entry_offset = 0 ; __archive_read_consume ( a , namelength + name_pad ) ; if ( archive_entry_filetype ( entry ) == AE_IFLNK ) { <S2SV_StartBug> h = __archive_read_ahead ( a , <S2SV_EndBug> ( size_t ) cpio -> entry_bytes_remaining , NULL ) ; if ( h == NULL ) return ( ARCHIVE_FATAL ) ; if ( archive_entry_copy_symlink_l ( entry , ( const char * ) h , ( size_t ) cpio -> entry_bytes_remaining , sconv ) != 0 ) { if ( errno == ENOMEM ) { archive_set_error ( & a -> archive , ENOMEM , ""Can\'t<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>Linkname"" ) ; return ( ARCHIVE_FATAL ) ; } archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , ""Linkname<S2SV_blank>can\'t<S2SV_blank>be<S2SV_blank>converted<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>"" ""current<S2SV_blank>locale."" , archive_string_conversion_charset_name ( sconv ) ) ; r = ARCHIVE_WARN ; } __archive_read_consume ( a , cpio -> entry_bytes_remaining ) ; cpio -> entry_bytes_remaining = 0 ; } if ( namelength == 11 && strcmp ( ( const char * ) h , ""TRAILER!!!"" ) == 0 ) { archive_clear_error ( & a -> archive ) ; return ( ARCHIVE_EOF ) ; } if ( record_hardlink ( a , cpio , entry ) != ARCHIVE_OK ) { return ( ARCHIVE_FATAL ) ; } return ( r ) ; }","AE_IFLNK ) { if ( cpio -> entry_bytes_remaining > 1024 * 1024 ) { archive_set_error ( & a -> archive , ENOMEM , ""Rejecting<S2SV_blank>malformed<S2SV_blank>cpio<S2SV_blank>archive:<S2SV_blank>symlink<S2SV_blank>contents<S2SV_blank>exceed<S2SV_blank>1<S2SV_blank>megabyte"" ) ; return ( ARCHIVE_FATAL ) ; }"
796,"struct key * key_get_instantiation_authkey ( key_serial_t target_id ) { char description [ 16 ] ; struct keyring_search_context ctx = { . index_key . type = & key_type_request_key_auth , . index_key . description = description , . cred = current_cred ( ) , <S2SV_StartBug> . match_data . cmp = user_match , <S2SV_EndBug> . match_data . raw_data = description , . match_data . lookup_type = KEYRING_SEARCH_LOOKUP_DIRECT , } ; struct key * authkey ; key_ref_t authkey_ref ; sprintf ( description , ""%x"" , target_id ) ; authkey_ref = search_process_keyrings ( & ctx ) ; if ( IS_ERR ( authkey_ref ) ) { authkey = ERR_CAST ( authkey_ref ) ; if ( authkey == ERR_PTR ( - EAGAIN ) ) authkey = ERR_PTR ( - ENOKEY ) ; goto error ; } authkey = key_ref_to_ptr ( authkey_ref ) ; if ( test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) { key_put ( authkey ) ; authkey = ERR_PTR ( - EKEYREVOKED ) ; } error : return authkey ; }",". cmp = key_default_cmp <S2SV_ModEnd> , . match_data"
797,"static int java_switch_op ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * data , int len ) { ut8 op_byte = data [ 0 ] ; ut64 offset = addr - java_get_method_start ( ) ; ut8 pos = ( offset + 1 ) % 4 ? 1 + 4 - ( offset + 1 ) % 4 : 1 ; if ( op_byte == 0xaa ) { <S2SV_StartBug> if ( pos + 8 > len ) { <S2SV_EndBug> return op -> size ; } <S2SV_StartBug> int min_val = ( ut32 ) ( UINT ( data , pos + 4 ) ) , <S2SV_EndBug> max_val = ( ut32 ) ( UINT ( data , pos + 8 ) ) ; ut32 default_loc = ( ut32 ) ( UINT ( data , pos ) ) , cur_case = 0 ; op -> switch_op = r_anal_switch_op_new ( addr , min_val , default_loc ) ; RAnalCaseOp * caseop = NULL ; pos += 12 ; if ( max_val > min_val && ( ( max_val - min_val ) < ( UT16_MAX / 4 ) ) ) { for ( cur_case = 0 ; cur_case <= max_val - min_val ; pos += 4 , cur_case ++ ) { if ( pos + 4 >= len ) { break ; } int offset = ( int ) ( ut32 ) ( R_BIN_JAVA_UINT ( data , pos ) ) ; caseop = r_anal_switch_op_add_case ( op -> switch_op , addr + pos , cur_case + min_val , addr + offset ) ; if ( caseop ) { caseop -> bb_ref_to = addr + offset ; caseop -> bb_ref_from = addr ; } } } else { eprintf ( ""Invalid<S2SV_blank>switch<S2SV_blank>boundaries<S2SV_blank>at<S2SV_blank>0x%"" PFMT64x ""\\n"" , addr ) ; } } op -> size = pos ; return op -> size ; }",pos + 8 + 8 <S2SV_ModStart> size ; } const <S2SV_ModStart> 4 ) ) ; const int <S2SV_ModEnd> max_val = (
798,"RD_BOOL <S2SV_StartBug> ber_parse_header ( STREAM s , int tagval , int * length ) <S2SV_EndBug> { int tag , len ; if ( tagval > 0xff ) { in_uint16_be ( s , tag ) ; } else { in_uint8 ( s , tag ) ; } if ( tag != tagval ) { logger ( Core , Error , ""ber_parse_header(),<S2SV_blank>expected<S2SV_blank>tag<S2SV_blank>%d,<S2SV_blank>got<S2SV_blank>%d"" , tagval , tag ) ; return False ; } in_uint8 ( s , len ) ; if ( len & 0x80 ) { len &= ~ 0x80 ; * length = 0 ; while ( len -- ) next_be ( s , * length ) ; } else * length = len ; return s_check ( s ) ; }","int tagval , uint32 <S2SV_ModEnd> * length )"
799,"static int dnxhd_find_frame_end ( DNXHDParserContext * dctx , const uint8_t * buf , int buf_size ) { ParseContext * pc = & dctx -> pc ; uint64_t state = pc -> state64 ; int pic_found = pc -> frame_start_found ; int i = 0 ; if ( ! pic_found ) { for ( i = 0 ; i < buf_size ; i ++ ) { state = ( state << 8 ) | buf [ i ] ; if ( ff_dnxhd_check_header_prefix ( state & 0xffffffffff00LL ) != 0 ) { i ++ ; pic_found = 1 ; dctx -> cur_byte = 0 ; dctx -> remaining = 0 ; break ; } } } if ( pic_found && ! dctx -> remaining ) { if ( ! buf_size ) return 0 ; for ( ; i < buf_size ; i ++ ) { dctx -> cur_byte ++ ; state = ( state << 8 ) | buf [ i ] ; if ( dctx -> cur_byte == 24 ) { dctx -> h = ( state >> 32 ) & 0xFFFF ; } else if ( dctx -> cur_byte == 26 ) { dctx -> w = ( state >> 32 ) & 0xFFFF ; } else if ( dctx -> cur_byte == 42 ) { int cid = ( state >> 32 ) & 0xFFFFFFFF ; <S2SV_StartBug> if ( cid <= 0 ) <S2SV_EndBug> continue ; <S2SV_StartBug> dctx -> remaining = avpriv_dnxhd_get_frame_size ( cid ) ; <S2SV_EndBug> <S2SV_StartBug> if ( dctx -> remaining <= 0 ) { <S2SV_EndBug> <S2SV_StartBug> dctx -> remaining = ff_dnxhd_get_hr_frame_size ( cid , dctx -> w , dctx -> h ) ; <S2SV_EndBug> <S2SV_StartBug> if ( dctx -> remaining <= 0 ) <S2SV_EndBug> <S2SV_StartBug> return dctx -> remaining ; <S2SV_EndBug> } if ( buf_size - i + 47 >= dctx -> remaining ) { int remaining = dctx -> remaining ; pc -> frame_start_found = 0 ; pc -> state64 = - 1 ; dctx -> cur_byte = 0 ; dctx -> remaining = 0 ; return remaining ; } else { dctx -> remaining -= buf_size ; } } } } else if ( pic_found ) { if ( dctx -> remaining > buf_size ) { dctx -> remaining -= buf_size ; } else { int remaining = dctx -> remaining ; pc -> frame_start_found = 0 ; pc -> state64 = - 1 ; dctx -> cur_byte = 0 ; dctx -> remaining = 0 ; return remaining ; } } pc -> frame_start_found = pic_found ; pc -> state64 = state ; return END_NOT_FOUND ; }",& 0xFFFFFFFF ; int remaining ; <S2SV_ModStart> ) continue ; <S2SV_ModEnd> remaining = avpriv_dnxhd_get_frame_size <S2SV_ModStart> ; if ( <S2SV_ModEnd> remaining <= 0 <S2SV_ModStart> 0 ) { <S2SV_ModEnd> remaining = ff_dnxhd_get_hr_frame_size <S2SV_ModStart> ; if ( <S2SV_ModEnd> remaining <= 0 <S2SV_ModStart> <= 0 ) continue ; } dctx -> remaining = remaining ; <S2SV_ModEnd> if ( buf_size
800,"int ext4_punch_hole ( struct inode * inode , loff_t offset , loff_t length ) { struct super_block * sb = inode -> i_sb ; ext4_lblk_t first_block , stop_block ; struct address_space * mapping = inode -> i_mapping ; loff_t first_block_offset , last_block_offset ; handle_t * handle ; unsigned int credits ; int ret = 0 ; if ( ! S_ISREG ( inode -> i_mode ) ) return - EOPNOTSUPP ; trace_ext4_punch_hole ( inode , offset , length , 0 ) ; if ( mapping -> nrpages && mapping_tagged ( mapping , PAGECACHE_TAG_DIRTY ) ) { ret = filemap_write_and_wait_range ( mapping , offset , offset + length - 1 ) ; if ( ret ) return ret ; } mutex_lock ( & inode -> i_mutex ) ; if ( offset >= inode -> i_size ) goto out_mutex ; if ( offset + length > inode -> i_size ) { length = inode -> i_size + PAGE_CACHE_SIZE - ( inode -> i_size & ( PAGE_CACHE_SIZE - 1 ) ) - offset ; } if ( offset & ( sb -> s_blocksize - 1 ) || ( offset + length ) & ( sb -> s_blocksize - 1 ) ) { ret = ext4_inode_attach_jinode ( inode ) ; if ( ret < 0 ) goto out_mutex ; } <S2SV_StartBug> first_block_offset = round_up ( offset , sb -> s_blocksize ) ; <S2SV_EndBug> last_block_offset = round_down ( ( offset + length ) , sb -> s_blocksize ) - 1 ; if ( last_block_offset > first_block_offset ) truncate_pagecache_range ( inode , first_block_offset , last_block_offset ) ; <S2SV_StartBug> ext4_inode_block_unlocked_dio ( inode ) ; <S2SV_EndBug> inode_dio_wait ( inode ) ; if ( ext4_test_inode_flag ( inode , EXT4_INODE_EXTENTS ) ) credits = ext4_writepage_trans_blocks ( inode ) ; else credits = ext4_blocks_for_truncate ( inode ) ; handle = ext4_journal_start ( inode , EXT4_HT_TRUNCATE , credits ) ; if ( IS_ERR ( handle ) ) { ret = PTR_ERR ( handle ) ; ext4_std_error ( sb , ret ) ; goto out_dio ; } ret = ext4_zero_partial_blocks ( handle , inode , offset , length ) ; if ( ret ) goto out_stop ; first_block = ( offset + sb -> s_blocksize - 1 ) >> EXT4_BLOCK_SIZE_BITS ( sb ) ; stop_block = ( offset + length ) >> EXT4_BLOCK_SIZE_BITS ( sb ) ; if ( first_block >= stop_block ) goto out_stop ; down_write ( & EXT4_I ( inode ) -> i_data_sem ) ; ext4_discard_preallocations ( inode ) ; ret = ext4_es_remove_extent ( inode , first_block , stop_block - first_block ) ; if ( ret ) { up_write ( & EXT4_I ( inode ) -> i_data_sem ) ; goto out_stop ; } if ( ext4_test_inode_flag ( inode , EXT4_INODE_EXTENTS ) ) ret = ext4_ext_remove_space ( inode , first_block , stop_block - 1 ) ; else ret = ext4_ind_remove_space ( handle , inode , first_block , stop_block ) ; up_write ( & EXT4_I ( inode ) -> i_data_sem ) ; if ( IS_SYNC ( inode ) ) ext4_handle_sync ( handle ) ; <S2SV_StartBug> if ( last_block_offset > first_block_offset ) <S2SV_EndBug> truncate_pagecache_range ( inode , first_block_offset , last_block_offset ) ; inode -> i_mtime = inode -> i_ctime = ext4_current_time ( inode ) ; ext4_mark_inode_dirty ( handle , inode ) ; out_stop : ext4_journal_stop ( handle ) ; out_dio : <S2SV_StartBug> ext4_inode_resume_unlocked_dio ( inode ) ; <S2SV_EndBug> out_mutex : mutex_unlock ( & inode -> i_mutex ) ; return ret ; }",out_mutex ; } ext4_inode_block_unlocked_dio ( inode ) ; inode_dio_wait ( inode ) ; down_write ( & EXT4_I ( inode ) -> i_mmap_sem ) ; <S2SV_ModStart> last_block_offset ) ; <S2SV_ModEnd> if ( ext4_test_inode_flag <S2SV_ModStart> handle ) ; <S2SV_ModEnd> inode -> i_mtime <S2SV_ModStart> ; out_dio : up_write ( & EXT4_I ( inode ) -> i_mmap_sem ) ;
801,"int main ( int argc , char * * argv ) { int frame_cnt = 0 ; FILE * outfile = NULL ; vpx_codec_ctx_t codec ; vpx_codec_err_t res ; VpxVideoReader * reader = NULL ; const VpxInterface * decoder = NULL ; const VpxVideoInfo * info = NULL ; exec_name = argv [ 0 ] ; if ( argc != 3 ) die ( ""Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>arguments."" ) ; reader = vpx_video_reader_open ( argv [ 1 ] ) ; if ( ! reader ) die ( ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading."" , argv [ 1 ] ) ; if ( ! ( outfile = fopen ( argv [ 2 ] , ""wb"" ) ) ) die ( ""Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>writing"" , argv [ 2 ] ) ; info = vpx_video_reader_get_info ( reader ) ; decoder = get_vpx_decoder_by_fourcc ( info -> codec_fourcc ) ; if ( ! decoder ) die ( ""Unknown<S2SV_blank>input<S2SV_blank>codec."" ) ; <S2SV_StartBug> printf ( ""Using<S2SV_blank>%s\\n"" , vpx_codec_iface_name ( decoder -> interface ( ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> res = vpx_codec_dec_init ( & codec , decoder -> interface ( ) , NULL , <S2SV_EndBug> VPX_CODEC_USE_POSTPROC ) ; if ( res == VPX_CODEC_INCAPABLE ) die_codec ( & codec , ""Postproc<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>by<S2SV_blank>this<S2SV_blank>decoder."" ) ; if ( res ) die_codec ( & codec , ""Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>decoder."" ) ; while ( vpx_video_reader_read_frame ( reader ) ) { vpx_codec_iter_t iter = NULL ; vpx_image_t * img = NULL ; size_t frame_size = 0 ; const unsigned char * frame = vpx_video_reader_get_frame ( reader , & frame_size ) ; ++ frame_cnt ; if ( frame_cnt % 30 == 1 ) { vp8_postproc_cfg_t pp = { 0 , 0 , 0 } ; if ( vpx_codec_control ( & codec , VP8_SET_POSTPROC , & pp ) ) die_codec ( & codec , ""Failed<S2SV_blank>to<S2SV_blank>turn<S2SV_blank>off<S2SV_blank>postproc."" ) ; } else if ( frame_cnt % 30 == 16 ) { vp8_postproc_cfg_t pp = { VP8_DEBLOCK | VP8_DEMACROBLOCK | VP8_MFQE , 4 , 0 } ; if ( vpx_codec_control ( & codec , VP8_SET_POSTPROC , & pp ) ) die_codec ( & codec , ""Failed<S2SV_blank>to<S2SV_blank>turn<S2SV_blank>on<S2SV_blank>postproc."" ) ; } ; if ( vpx_codec_decode ( & codec , frame , ( unsigned int ) frame_size , NULL , 15000 ) ) die_codec ( & codec , ""Failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>frame"" ) ; while ( ( img = vpx_codec_get_frame ( & codec , & iter ) ) != NULL ) { vpx_img_write ( img , outfile ) ; } } printf ( ""Processed<S2SV_blank>%d<S2SV_blank>frames.\\n"" , frame_cnt ) ; if ( vpx_codec_destroy ( & codec ) ) die_codec ( & codec , ""Failed<S2SV_blank>to<S2SV_blank>destroy<S2SV_blank>codec"" ) ; printf ( ""Play:<S2SV_blank>ffplay<S2SV_blank>-f<S2SV_blank>rawvideo<S2SV_blank>-pix_fmt<S2SV_blank>yuv420p<S2SV_blank>-s<S2SV_blank>%dx%d<S2SV_blank>%s\\n"" , info -> frame_width , info -> frame_height , argv [ 2 ] ) ; vpx_video_reader_close ( reader ) ; fclose ( outfile ) ; return EXIT_SUCCESS ; }","( decoder -> codec_interface <S2SV_ModEnd> ( ) ) <S2SV_ModStart> , decoder -> codec_interface <S2SV_ModEnd> ( ) ,"
802,"timestamp PGTYPEStimestamp_from_asc ( char * str , char * * endptr ) { timestamp result ; # ifdef HAVE_INT64_TIMESTAMP int64 noresult = 0 ; # else double noresult = 0.0 ; # endif fsec_t fsec ; struct tm tt , * tm = & tt ; int dtype ; int nf ; char * field [ MAXDATEFIELDS ] ; int ftype [ MAXDATEFIELDS ] ; char lowstr [ MAXDATELEN + MAXDATEFIELDS ] ; char * realptr ; char * * ptr = ( endptr != NULL ) ? endptr : & realptr ; <S2SV_StartBug> if ( strlen ( str ) >= sizeof ( lowstr ) ) <S2SV_EndBug> { errno = PGTYPES_TS_BAD_TIMESTAMP ; return ( noresult ) ; } <S2SV_StartBug> if ( ParseDateTime ( str , lowstr , field , ftype , & nf , ptr ) != 0 || <S2SV_EndBug> DecodeDateTime ( field , ftype , nf , & dtype , tm , & fsec , 0 ) != 0 ) { errno = PGTYPES_TS_BAD_TIMESTAMP ; return ( noresult ) ; } switch ( dtype ) { case DTK_DATE : if ( tm2timestamp ( tm , fsec , NULL , & result ) != 0 ) { errno = PGTYPES_TS_BAD_TIMESTAMP ; return ( noresult ) ; } break ; case DTK_EPOCH : result = SetEpochTimestamp ( ) ; break ; case DTK_LATE : TIMESTAMP_NOEND ( result ) ; break ; case DTK_EARLY : TIMESTAMP_NOBEGIN ( result ) ; break ; case DTK_INVALID : errno = PGTYPES_TS_BAD_TIMESTAMP ; return ( noresult ) ; default : errno = PGTYPES_TS_BAD_TIMESTAMP ; return ( noresult ) ; } errno = 0 ; return result ; }","( str ) > MAXDATELEN ) { errno = PGTYPES_TS_BAD_TIMESTAMP ; return ( noresult ) ; } if ( ParseDateTime ( str , lowstr , field , ftype , & nf , ptr ) != 0 || DecodeDateTime ( field , ftype , nf , & dtype , tm , & fsec , 0 ) != 0 ) { errno = PGTYPES_TS_BAD_TIMESTAMP ; return ( noresult ) ; } switch ( dtype ) { case DTK_DATE : if ( tm2timestamp ( tm , fsec , NULL , & result <S2SV_ModEnd> ) != 0 <S2SV_ModStart> ) != 0 <S2SV_ModEnd> ) { errno"
803,"void Huff_Compress ( msg_t * mbuf , int offset ) { int i , ch , size ; byte seq [ 65536 ] ; byte * buffer ; huff_t huff ; size = mbuf -> cursize - offset ; buffer = mbuf -> data + + offset ; if ( size <= 0 ) { return ; } Com_Memset ( & huff , 0 , sizeof ( huff_t ) ) ; huff . tree = huff . lhead = huff . loc [ NYT ] = & ( huff . nodeList [ huff . blocNode ++ ] ) ; huff . tree -> symbol = NYT ; huff . tree -> weight = 0 ; huff . lhead -> next = huff . lhead -> prev = NULL ; huff . tree -> parent = huff . tree -> left = huff . tree -> right = NULL ; seq [ 0 ] = ( size >> 8 ) ; seq [ 1 ] = size & 0xff ; bloc = 16 ; for ( i = 0 ; i < size ; i ++ ) { ch = buffer [ i ] ; <S2SV_StartBug> Huff_transmit ( & huff , ch , seq ) ; <S2SV_EndBug> Huff_addRef ( & huff , ( byte ) ch ) ; } bloc += 8 ; mbuf -> cursize = ( bloc >> 3 ) + offset ; Com_Memcpy ( mbuf -> data + offset , seq , ( bloc >> 3 ) ) ; }","ch , seq , size << 3"
804,"static int kvaser_usb_leaf_simple_cmd_async ( struct kvaser_usb_net_priv * priv , u8 cmd_id ) { struct kvaser_cmd * cmd ; int err ; <S2SV_StartBug> cmd = kmalloc ( sizeof ( * cmd ) , GFP_ATOMIC ) ; <S2SV_EndBug> if ( ! cmd ) return - ENOMEM ; cmd -> len = CMD_HEADER_LEN + sizeof ( struct kvaser_cmd_simple ) ; cmd -> id = cmd_id ; cmd -> u . simple . channel = priv -> channel ; err = kvaser_usb_send_cmd_async ( priv , cmd , cmd -> len ) ; if ( err ) kfree ( cmd ) ; return err ; }",; cmd = kzalloc <S2SV_ModEnd> ( sizeof (
805,"static struct phy * serdes_simple_xlate ( struct device * dev , struct of_phandle_args * args ) { struct serdes_ctrl * ctrl = dev_get_drvdata ( dev ) ; unsigned int port , idx , i ; if ( args -> args_count != 2 ) return ERR_PTR ( - EINVAL ) ; port = args -> args [ 0 ] ; idx = args -> args [ 1 ] ; <S2SV_StartBug> for ( i = 0 ; i <= SERDES_MAX ; i ++ ) { <S2SV_EndBug> struct serdes_macro * macro = phy_get_drvdata ( ctrl -> phys [ i ] ) ; if ( idx != macro -> idx ) continue ; if ( idx != SERDES6G ( 0 ) && macro -> port >= 0 ) return ERR_PTR ( - EBUSY ) ; macro -> port = port ; return ctrl -> phys [ i ] ; } return ERR_PTR ( - ENODEV ) ; }",0 ; i < <S2SV_ModEnd> SERDES_MAX ; i
806,"ssize_t cdf_read_sector ( const cdf_info_t * info , void * buf , size_t offs , size_t len , const cdf_header_t * h , cdf_secid_t id ) { <S2SV_StartBug> assert ( ( size_t ) CDF_SEC_SIZE ( h ) == len ) ; <S2SV_EndBug> <S2SV_StartBug> return cdf_read ( info , ( off_t ) CDF_SEC_POS ( h , id ) , <S2SV_EndBug> ( ( char * ) buf ) + offs , len ) ; }","id ) { size_t ss = <S2SV_ModEnd> CDF_SEC_SIZE ( h <S2SV_ModStart> ( h ) ; size_t pos = CDF_SEC_POS ( h , id ) ; assert ( ss <S2SV_ModStart> ( off_t ) pos , <S2SV_ModEnd> ( ( char"
807,"static void * listen_fn_ ( UNUSED_ATTR void * context ) { prctl ( PR_SET_NAME , ( unsigned long ) LISTEN_THREAD_NAME_ , 0 , 0 , 0 ) ; listen_socket_ = socket ( AF_INET , SOCK_STREAM , IPPROTO_TCP ) ; if ( listen_socket_ == - 1 ) { LOG_ERROR ( ""%s<S2SV_blank>socket<S2SV_blank>creation<S2SV_blank>failed:<S2SV_blank>%s"" , __func__ , strerror ( errno ) ) ; goto cleanup ; } int enable = 1 ; if ( setsockopt ( listen_socket_ , SOL_SOCKET , SO_REUSEADDR , & enable , sizeof ( enable ) ) == - 1 ) { LOG_ERROR ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>set<S2SV_blank>SO_REUSEADDR:<S2SV_blank>%s"" , __func__ , strerror ( errno ) ) ; goto cleanup ; } struct sockaddr_in addr ; addr . sin_family = AF_INET ; addr . sin_addr . s_addr = htonl ( LOCALHOST_ ) ; addr . sin_port = htons ( LISTEN_PORT_ ) ; if ( bind ( listen_socket_ , ( struct sockaddr * ) & addr , sizeof ( addr ) ) == - 1 ) { LOG_ERROR ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>bind<S2SV_blank>listen<S2SV_blank>socket:<S2SV_blank>%s"" , __func__ , strerror ( errno ) ) ; goto cleanup ; } if ( listen ( listen_socket_ , 10 ) == - 1 ) { LOG_ERROR ( ""%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>listen:<S2SV_blank>%s"" , __func__ , strerror ( errno ) ) ; goto cleanup ; } for ( ; ; ) { <S2SV_StartBug> int client_socket = accept ( listen_socket_ , NULL , NULL ) ; <S2SV_EndBug> if ( client_socket == - 1 ) { if ( errno == EINVAL || errno == EBADF ) { break ; } LOG_WARN ( ""%s<S2SV_blank>error<S2SV_blank>accepting<S2SV_blank>socket:<S2SV_blank>%s"" , __func__ , strerror ( errno ) ) ; continue ; } pthread_mutex_lock ( & client_socket_lock_ ) ; safe_close_ ( & client_socket_ ) ; client_socket_ = client_socket ; <S2SV_StartBug> send ( client_socket_ , ""btsnoop\\0\\0\\0\\0\\1\\0\\0\\x3\\xea"" , 16 , 0 ) ; <S2SV_EndBug> pthread_mutex_unlock ( & client_socket_lock_ ) ; } cleanup : safe_close_ ( & listen_socket_ ) ; return NULL ; }","int client_socket = TEMP_FAILURE_RETRY ( <S2SV_ModStart> NULL , NULL ) <S2SV_ModStart> = client_socket ; TEMP_FAILURE_RETRY ( <S2SV_ModStart> 16 , 0 )"
808,"struct clock_source * dce112_clock_source_create ( struct dc_context * ctx , struct dc_bios * bios , enum clock_source_id id , const struct dce110_clk_src_regs * regs , bool dp_clk_src ) { struct dce110_clk_src * clk_src = kzalloc ( sizeof ( struct dce110_clk_src ) , GFP_KERNEL ) ; if ( ! clk_src ) return NULL ; if ( dce112_clk_src_construct ( clk_src , ctx , bios , id , regs , & cs_shift , & cs_mask ) ) { clk_src -> base . dp_clk_src = dp_clk_src ; return & clk_src -> base ; } <S2SV_StartBug> BREAK_TO_DEBUGGER ( ) ; <S2SV_EndBug> return NULL ; }",base ; } kfree ( clk_src ) ;
809,"static int ext4_writepage ( struct page * page , struct writeback_control * wbc ) { int ret = 0 ; loff_t size ; unsigned int len ; <S2SV_StartBug> struct buffer_head * page_bufs ; <S2SV_EndBug> struct inode * inode = page -> mapping -> host ; trace_ext4_writepage ( inode , page ) ; size = i_size_read ( inode ) ; if ( page -> index == size >> PAGE_CACHE_SHIFT ) len = size & ~ PAGE_CACHE_MASK ; else len = PAGE_CACHE_SIZE ; if ( page_has_buffers ( page ) ) { page_bufs = page_buffers ( page ) ; if ( walk_page_buffers ( NULL , page_bufs , 0 , len , NULL , ext4_bh_delay_or_unwritten ) ) { redirty_page_for_writepage ( wbc , page ) ; unlock_page ( page ) ; return 0 ; } } else { ret = block_prepare_write ( page , 0 , len , noalloc_get_block_write ) ; if ( ! ret ) { page_bufs = page_buffers ( page ) ; if ( walk_page_buffers ( NULL , page_bufs , 0 , len , NULL , ext4_bh_delay_or_unwritten ) ) { redirty_page_for_writepage ( wbc , page ) ; unlock_page ( page ) ; return 0 ; } } else { redirty_page_for_writepage ( wbc , page ) ; unlock_page ( page ) ; return 0 ; } block_commit_write ( page , 0 , len ) ; } if ( PageChecked ( page ) && ext4_should_journal_data ( inode ) ) { ClearPageChecked ( page ) ; return __ext4_journalled_writepage ( page , len ) ; } if ( test_opt ( inode -> i_sb , NOBH ) && ext4_should_writeback_data ( inode ) ) ret = nobh_writepage ( page , noalloc_get_block_write , wbc ) ; <S2SV_StartBug> else <S2SV_EndBug> ret = block_write_full_page ( page , noalloc_get_block_write , wbc ) ; return ret ; }","buffer_head * page_bufs = NULL <S2SV_ModStart> ) ; else if ( page_bufs && buffer_uninit ( page_bufs ) ) { ext4_set_bh_endio ( page_bufs , inode ) ; ret = block_write_full_page_endio ( page , noalloc_get_block_write , wbc , ext4_end_io_buffer_write ) ; } else"
810,"void vp9_resize_plane ( const uint8_t * const input , int height , int width , int in_stride , uint8_t * output , int height2 , int width2 , int out_stride ) { int i ; uint8_t * intbuf = ( uint8_t * ) malloc ( sizeof ( uint8_t ) * width2 * height ) ; uint8_t * tmpbuf = ( uint8_t * ) malloc ( sizeof ( uint8_t ) * ( width < height ? height : width ) ) ; uint8_t * arrbuf = ( uint8_t * ) malloc ( sizeof ( uint8_t ) * ( height + height2 ) ) ; <S2SV_StartBug> for ( i = 0 ; i < height ; ++ i ) <S2SV_EndBug> resize_multistep ( input + in_stride * i , width , intbuf + width2 * i , width2 , tmpbuf ) ; for ( i = 0 ; i < width2 ; ++ i ) { fill_col_to_arr ( intbuf + i , width2 , height , arrbuf ) ; resize_multistep ( arrbuf , height , arrbuf + height , height2 , tmpbuf ) ; fill_arr_to_col ( output + i , out_stride , height2 , arrbuf + height ) ; } free ( intbuf ) ; free ( tmpbuf ) ; free ( arrbuf ) ; }",) ) ; assert ( width > 0 ) ; assert ( height > 0 ) ; assert ( width2 > 0 ) ; assert ( height2 > 0 ) ;
811,"static irqreturn_t sunkbd_interrupt ( struct serio * serio , unsigned char data , unsigned int flags ) { struct sunkbd * sunkbd = serio_get_drvdata ( serio ) ; if ( sunkbd -> reset <= - 1 ) { sunkbd -> reset = data ; wake_up_interruptible ( & sunkbd -> wait ) ; goto out ; } if ( sunkbd -> layout == - 1 ) { sunkbd -> layout = data ; wake_up_interruptible ( & sunkbd -> wait ) ; goto out ; } switch ( data ) { case SUNKBD_RET_RESET : <S2SV_StartBug> schedule_work ( & sunkbd -> tq ) ; <S2SV_EndBug> sunkbd -> reset = - 1 ; break ; case SUNKBD_RET_LAYOUT : sunkbd -> layout = - 1 ; break ; case SUNKBD_RET_ALLUP : break ; default : if ( ! sunkbd -> enabled ) break ; if ( sunkbd -> keycode [ data & SUNKBD_KEY ] ) { input_report_key ( sunkbd -> dev , sunkbd -> keycode [ data & SUNKBD_KEY ] , ! ( data & SUNKBD_RELEASE ) ) ; input_sync ( sunkbd -> dev ) ; } else { printk ( KERN_WARNING ""sunkbd.c:<S2SV_blank>Unknown<S2SV_blank>key<S2SV_blank>(scancode<S2SV_blank>%#x)<S2SV_blank>%s.\\n"" , data & SUNKBD_KEY , data & SUNKBD_RELEASE ? ""released"" : ""pressed"" ) ; } } out : return IRQ_HANDLED ; }",case SUNKBD_RET_RESET : if ( sunkbd -> enabled )
812,"static MagickBooleanType EncodeImage ( const ImageInfo * image_info , Image * image , const size_t data_size , ExceptionInfo * exception ) { # define MaxCode ( number_bits ) ( ( one << ( number_bits ) ) - 1 ) # define MaxHashTable 5003 # define MaxGIFBits 12UL # define MaxGIFTable ( 1UL << MaxGIFBits ) <S2SV_StartBug> # define GIFOutputCode ( code ) { if ( bits > 0 ) datum |= ( size_t ) ( code ) << bits ; else datum = ( size_t ) ( code ) ; bits += number_bits ; while ( bits >= 8 ) { packet [ length ++ ] = ( unsigned char ) ( datum & 0xff ) ; if ( length >= 254 ) { ( void ) WriteBlobByte ( image , ( unsigned char ) length ) ; ( void ) WriteBlob ( image , length , packet ) ; length = 0 ; } datum >>= 8 ; bits -= 8 ; } if ( free_code > max_code ) { number_bits ++ ; if ( number_bits == MaxGIFBits ) max_code = MaxGIFTable ; else max_code = MaxCode ( number_bits ) ; } } <S2SV_EndBug> Quantum index ; short * hash_code , * hash_prefix , waiting_code ; size_t bits , clear_code , datum , end_of_information_code , free_code , length , max_code , next_pixel , number_bits , one , pass ; ssize_t displacement , offset , k , y ; unsigned char * packet , * hash_suffix ; assert ( image != ( Image * ) NULL ) ; one = 1 ; packet = ( unsigned char * ) AcquireQuantumMemory ( 256 , sizeof ( * packet ) ) ; hash_code = ( short * ) AcquireQuantumMemory ( MaxHashTable , sizeof ( * hash_code ) ) ; hash_prefix = ( short * ) AcquireQuantumMemory ( MaxHashTable , sizeof ( * hash_prefix ) ) ; hash_suffix = ( unsigned char * ) AcquireQuantumMemory ( MaxHashTable , sizeof ( * hash_suffix ) ) ; if ( ( packet == ( unsigned char * ) NULL ) || ( hash_code == ( short * ) NULL ) || ( hash_prefix == ( short * ) NULL ) || ( hash_suffix == ( unsigned char * ) NULL ) ) { if ( packet != ( unsigned char * ) NULL ) packet = ( unsigned char * ) RelinquishMagickMemory ( packet ) ; if ( hash_code != ( short * ) NULL ) hash_code = ( short * ) RelinquishMagickMemory ( hash_code ) ; if ( hash_prefix != ( short * ) NULL ) hash_prefix = ( short * ) RelinquishMagickMemory ( hash_prefix ) ; if ( hash_suffix != ( unsigned char * ) NULL ) hash_suffix = ( unsigned char * ) RelinquishMagickMemory ( hash_suffix ) ; return ( MagickFalse ) ; } ( void ) memset ( packet , 0 , 256 * sizeof ( * packet ) ) ; ( void ) memset ( hash_code , 0 , MaxHashTable * sizeof ( * hash_code ) ) ; ( void ) memset ( hash_prefix , 0 , MaxHashTable * sizeof ( * hash_prefix ) ) ; ( void ) memset ( hash_suffix , 0 , MaxHashTable * sizeof ( * hash_suffix ) ) ; number_bits = data_size ; max_code = MaxCode ( number_bits ) ; clear_code = ( ( short ) one << ( data_size - 1 ) ) ; end_of_information_code = clear_code + 1 ; free_code = clear_code + 2 ; length = 0 ; datum = 0 ; bits = 0 ; GIFOutputCode ( clear_code ) ; offset = 0 ; pass = 0 ; waiting_code = 0 ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { register const Quantum * magick_restrict p ; register ssize_t x ; p = GetVirtualPixels ( image , 0 , offset , image -> columns , 1 , exception ) ; if ( p == ( const Quantum * ) NULL ) break ; if ( y == 0 ) { waiting_code = ( short ) GetPixelIndex ( image , p ) ; p += GetPixelChannels ( image ) ; } for ( x = ( ssize_t ) ( y == 0 ? 1 : 0 ) ; x < ( ssize_t ) image -> columns ; x ++ ) { <S2SV_StartBug> index = ( Quantum ) ( ( size_t ) GetPixelIndex ( image , p ) & 0xff ) ; <S2SV_EndBug> p += GetPixelChannels ( image ) ; k = ( ssize_t ) ( ( ( size_t ) index << ( MaxGIFBits - 8 ) ) + waiting_code ) ; if ( k >= MaxHashTable ) k -= MaxHashTable ; <S2SV_StartBug> next_pixel = MagickFalse ; <S2SV_EndBug> displacement = 1 ; if ( hash_code [ k ] > 0 ) { if ( ( hash_prefix [ k ] == waiting_code ) && ( hash_suffix [ k ] == ( unsigned char ) index ) ) { waiting_code = hash_code [ k ] ; continue ; } if ( k != 0 ) displacement = MaxHashTable - k ; for ( ; ; ) { k -= displacement ; if ( k < 0 ) k += MaxHashTable ; if ( hash_code [ k ] == 0 ) break ; if ( ( hash_prefix [ k ] == waiting_code ) && ( hash_suffix [ k ] == ( unsigned char ) index ) ) { waiting_code = hash_code [ k ] ; next_pixel = MagickTrue ; break ; } } if ( next_pixel != MagickFalse ) continue ; } GIFOutputCode ( waiting_code ) ; if ( free_code < MaxGIFTable ) { hash_code [ k ] = ( short ) free_code ++ ; hash_prefix [ k ] = waiting_code ; hash_suffix [ k ] = ( unsigned char ) index ; } else { for ( k = 0 ; k < MaxHashTable ; k ++ ) hash_code [ k ] = 0 ; free_code = clear_code + 2 ; GIFOutputCode ( clear_code ) ; number_bits = data_size ; max_code = MaxCode ( number_bits ) ; } waiting_code = ( short ) index ; } if ( image_info -> interlace == NoInterlace ) offset ++ ; else switch ( pass ) { case 0 : default : { offset += 8 ; if ( offset >= ( ssize_t ) image -> rows ) { pass ++ ; offset = 4 ; } break ; } case 1 : { offset += 8 ; if ( offset >= ( ssize_t ) image -> rows ) { pass ++ ; offset = 2 ; } break ; } case 2 : { offset += 4 ; if ( offset >= ( ssize_t ) image -> rows ) { pass ++ ; offset = 1 ; } break ; } case 3 : { offset += 2 ; break ; } } } GIFOutputCode ( waiting_code ) ; GIFOutputCode ( end_of_information_code ) ; if ( bits > 0 ) { packet [ length ++ ] = ( unsigned char ) ( datum & 0xff ) ; if ( length >= 254 ) { ( void ) WriteBlobByte ( image , ( unsigned char ) length ) ; ( void ) WriteBlob ( image , length , packet ) ; length = 0 ; } } if ( length > 0 ) { ( void ) WriteBlobByte ( image , ( unsigned char ) length ) ; ( void ) WriteBlob ( image , length , packet ) ; } hash_suffix = ( unsigned char * ) RelinquishMagickMemory ( hash_suffix ) ; hash_prefix = ( short * ) RelinquishMagickMemory ( hash_prefix ) ; hash_code = ( short * ) RelinquishMagickMemory ( hash_code ) ; packet = ( unsigned char * ) RelinquishMagickMemory ( packet ) ; return ( MagickTrue ) ; }",( code ) \\\n{ <S2SV_ModEnd> if ( bits <S2SV_ModStart> ) ; } \\\n} <S2SV_ModEnd> Quantum index ; <S2SV_ModStart> ++ ) { next_pixel = MagickFalse ; displacement = 1 ; <S2SV_ModStart> -= MaxHashTable ; if ( k < 0 ) continue <S2SV_ModEnd> ; if (
813,"void __detach_mounts ( struct dentry * dentry ) { struct mountpoint * mp ; struct mount * mnt ; namespace_lock ( ) ; mp = lookup_mountpoint ( dentry ) ; if ( IS_ERR_OR_NULL ( mp ) ) goto out_unlock ; lock_mount_hash ( ) ; while ( ! hlist_empty ( & mp -> m_list ) ) { mnt = hlist_entry ( mp -> m_list . first , struct mount , mnt_mp_list ) ; if ( mnt -> mnt . mnt_flags & MNT_UMOUNT ) { struct mount * p , * tmp ; list_for_each_entry_safe ( p , tmp , & mnt -> mnt_mounts , mnt_child ) { hlist_add_head ( & p -> mnt_umount . s_list , & unmounted ) ; umount_mnt ( p ) ; } } <S2SV_StartBug> else umount_tree ( mnt , 0 ) ; <S2SV_EndBug> } unlock_mount_hash ( ) ; put_mountpoint ( mp ) ; out_unlock : namespace_unlock ( ) ; }","( mnt , UMOUNT_CONNECTED <S2SV_ModEnd> ) ; }"
814,"CURLcode Curl_auth_create_plain_message ( struct Curl_easy * data , const char * userp , const char * passwdp , char * * outptr , size_t * outlen ) { CURLcode result ; char * plainauth ; size_t ulen ; size_t plen ; size_t plainlen ; * outlen = 0 ; * outptr = NULL ; ulen = strlen ( userp ) ; plen = strlen ( passwdp ) ; <S2SV_StartBug> if ( ( ulen > SIZE_T_MAX / 2 ) || ( plen > ( SIZE_T_MAX / 2 - 2 ) ) ) <S2SV_EndBug> return CURLE_OUT_OF_MEMORY ; plainlen = 2 * ulen + plen + 2 ; plainauth = malloc ( plainlen ) ; if ( ! plainauth ) return CURLE_OUT_OF_MEMORY ; memcpy ( plainauth , userp , ulen ) ; plainauth [ ulen ] = '\\0' ; memcpy ( plainauth + ulen + 1 , userp , ulen ) ; plainauth [ 2 * ulen + 1 ] = '\\0' ; memcpy ( plainauth + 2 * ulen + 2 , passwdp , plen ) ; result = Curl_base64_encode ( data , plainauth , plainlen , outptr , outlen ) ; free ( plainauth ) ; return result ; }",> SIZE_T_MAX / 4 <S2SV_ModEnd> ) || (
815,"char * suhosin_decrypt_single_cookie ( char * name , int name_len , char * value , int value_len , char * key , char * * where TSRMLS_DC ) { <S2SV_StartBug> char buffer [ 4096 ] ; <S2SV_EndBug> char buffer2 [ 4096 ] ; int o_name_len = name_len ; <S2SV_StartBug> char * buf = buffer , * buf2 = buffer2 , * d , * d_url ; <S2SV_EndBug> int l ; <S2SV_StartBug> if ( name_len > sizeof ( buffer ) - 2 ) { <S2SV_EndBug> buf = estrndup ( name , name_len ) ; <S2SV_StartBug> } else { <S2SV_EndBug> memcpy ( buf , name , name_len ) ; buf [ name_len ] = 0 ; } name_len = php_url_decode ( buf , name_len ) ; normalize_varname ( buf ) ; name_len = strlen ( buf ) ; if ( SUHOSIN_G ( cookie_plainlist ) ) { if ( zend_hash_exists ( SUHOSIN_G ( cookie_plainlist ) , buf , name_len + 1 ) ) { decrypt_return_plain : <S2SV_StartBug> if ( buf != buffer ) { <S2SV_EndBug> efree ( buf ) ; } memcpy ( * where , name , o_name_len ) ; * where += o_name_len ; * * where = '=' ; * where += 1 ; memcpy ( * where , value , value_len ) ; * where += value_len ; return * where ; } } else if ( SUHOSIN_G ( cookie_cryptlist ) ) { if ( ! zend_hash_exists ( SUHOSIN_G ( cookie_cryptlist ) , buf , name_len + 1 ) ) { goto decrypt_return_plain ; } } <S2SV_StartBug> if ( strlen ( value ) <= sizeof ( buffer2 ) - 2 ) { <S2SV_EndBug> memcpy ( buf2 , value , value_len ) ; buf2 [ value_len ] = 0 ; } else { buf2 = estrndup ( value , value_len ) ; } value_len = php_url_decode ( buf2 , value_len ) ; d = suhosin_decrypt_string ( buf2 , value_len , buf , name_len , key , & l , SUHOSIN_G ( cookie_checkraddr ) TSRMLS_CC ) ; if ( d == NULL ) { goto skip_cookie ; } d_url = php_url_encode ( d , l , & l ) ; efree ( d ) ; memcpy ( * where , name , o_name_len ) ; * where += o_name_len ; * * where = '=' ; * where += 1 ; memcpy ( * where , d_url , l ) ; * where += l ; efree ( d_url ) ; skip_cookie : <S2SV_StartBug> if ( buf != buffer ) { <S2SV_EndBug> efree ( buf ) ; } if ( buf2 != buffer2 ) { efree ( buf2 ) ; } return * where ; }","TSRMLS_DC ) { <S2SV_ModEnd> int o_name_len = <S2SV_ModStart> char * buf , * buf2 <S2SV_ModEnd> , * d <S2SV_ModStart> int l ; <S2SV_ModEnd> buf = estrndup <S2SV_ModStart> name_len ) ; <S2SV_ModEnd> name_len = php_url_decode <S2SV_ModStart> { decrypt_return_plain : efree ( buf ) ; <S2SV_ModEnd> memcpy ( * <S2SV_ModStart> ; } } buf2 = estrndup ( value , value_len ) ; <S2SV_ModEnd> value_len = php_url_decode <S2SV_ModStart> ; skip_cookie : efree ( buf ) ; efree ( buf2 ) ; <S2SV_ModEnd> return * where"
816,"static double calc_correction_factor ( double err_per_mb , double err_divisor , double pt_low , double pt_high , <S2SV_StartBug> int q ) { <S2SV_EndBug> const double error_term = err_per_mb / err_divisor ; <S2SV_StartBug> const double power_term = MIN ( vp9_convert_qindex_to_q ( q ) * 0.0125 + pt_low , <S2SV_EndBug> pt_high ) ; if ( power_term < 1.0 ) assert ( error_term >= 0.0 ) ; return fclamp ( pow ( error_term , power_term ) , 0.05 , 5.0 ) ; }",", int q , vpx_bit_depth_t bit_depth <S2SV_ModStart> vp9_convert_qindex_to_q ( q , bit_depth ) * 0.01 <S2SV_ModEnd> + pt_low ,"
817,"int tcp_disconnect ( struct sock * sk , int flags ) { struct inet_sock * inet = inet_sk ( sk ) ; struct inet_connection_sock * icsk = inet_csk ( sk ) ; struct tcp_sock * tp = tcp_sk ( sk ) ; int err = 0 ; int old_state = sk -> sk_state ; if ( old_state != TCP_CLOSE ) tcp_set_state ( sk , TCP_CLOSE ) ; if ( old_state == TCP_LISTEN ) { inet_csk_listen_stop ( sk ) ; } else if ( unlikely ( tp -> repair ) ) { sk -> sk_err = ECONNABORTED ; } else if ( tcp_need_reset ( old_state ) || ( tp -> snd_nxt != tp -> write_seq && ( 1 << old_state ) & ( TCPF_CLOSING | TCPF_LAST_ACK ) ) ) { tcp_send_active_reset ( sk , gfp_any ( ) ) ; sk -> sk_err = ECONNRESET ; } else if ( old_state == TCP_SYN_SENT ) sk -> sk_err = ECONNRESET ; tcp_clear_xmit_timers ( sk ) ; __skb_queue_purge ( & sk -> sk_receive_queue ) ; tcp_write_queue_purge ( sk ) ; tcp_fastopen_active_disable_ofo_check ( sk ) ; skb_rbtree_purge ( & tp -> out_of_order_queue ) ; inet -> inet_dport = 0 ; if ( ! ( sk -> sk_userlocks & SOCK_BINDADDR_LOCK ) ) inet_reset_saddr ( sk ) ; sk -> sk_shutdown = 0 ; sock_reset_flag ( sk , SOCK_DONE ) ; tp -> srtt_us = 0 ; tp -> write_seq += tp -> max_window + 2 ; if ( tp -> write_seq == 0 ) tp -> write_seq = 1 ; icsk -> icsk_backoff = 0 ; tp -> snd_cwnd = 2 ; icsk -> icsk_probes_out = 0 ; tp -> packets_out = 0 ; tp -> snd_ssthresh = TCP_INFINITE_SSTHRESH ; tp -> snd_cwnd_cnt = 0 ; tp -> window_clamp = 0 ; tcp_set_ca_state ( sk , TCP_CA_Open ) ; tcp_clear_retrans ( tp ) ; inet_csk_delack_init ( sk ) ; <S2SV_StartBug> tcp_init_send_head ( sk ) ; <S2SV_EndBug> memset ( & tp -> rx_opt , 0 , sizeof ( tp -> rx_opt ) ) ; __sk_dst_reset ( sk ) ; tcp_saved_syn_free ( tp ) ; tcp_free_fastopen_req ( tp ) ; inet -> defer_connect = 0 ; WARN_ON ( inet -> inet_num && ! icsk -> icsk_bind_hash ) ; sk -> sk_error_report ( sk ) ; return err ; }",sk ) ; icsk -> icsk_ack . rcv_mss = TCP_MIN_MSS ;
818,"static bool generic_new ( struct nf_conn * ct , const struct sk_buff * skb , unsigned int dataoff , unsigned int * timeouts ) { <S2SV_StartBug> return true ; <S2SV_EndBug> }",) { return nf_generic_should_process ( nf_ct_protonum ( ct ) ) <S2SV_ModEnd> ; } <S2SV_null>
819,"static void on_read ( h2o_socket_t * sock , int status ) { h2o_http2_conn_t * conn = sock -> data ; if ( status != 0 ) { h2o_socket_read_stop ( conn -> sock ) ; close_connection ( conn ) ; return ; } update_idle_timeout ( conn ) ; <S2SV_StartBug> parse_input ( conn ) ; <S2SV_EndBug> if ( h2o_timeout_is_linked ( & conn -> _write . timeout_entry ) ) { h2o_timeout_unlink ( & conn -> _write . timeout_entry ) ; do_emit_writereq ( conn ) ; } }",conn ) ; if ( <S2SV_ModStart> ( conn ) != 0 ) return
820,"static Image * ReadMATImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image , * image2 = NULL , * rotated_image ; PixelPacket * q ; unsigned int status ; MATHeader MATLAB_HDR ; size_t size ; size_t CellType ; QuantumInfo * quantum_info ; ImageInfo * clone_info ; int i ; ssize_t ldblk ; unsigned char * BImgBuff = NULL ; double MinVal , MaxVal ; size_t Unknown6 ; unsigned z , z2 ; unsigned Frames ; int logging ; int sample_size ; MagickOffsetType filepos = 0x80 ; BlobInfo * blob ; size_t one ; unsigned int ( * ReadBlobXXXLong ) ( Image * image ) ; unsigned short ( * ReadBlobXXXShort ) ( Image * image ) ; void ( * ReadBlobDoublesXXX ) ( Image * image , size_t len , double * data ) ; void ( * ReadBlobFloatsXXX ) ( Image * image , size_t len , float * data ) ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; logging = LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""enter"" ) ; quantum_info = ( QuantumInfo * ) NULL ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } clone_info = ( ImageInfo * ) NULL ; if ( ReadBlob ( image , 124 , ( unsigned char * ) & MATLAB_HDR . identific ) != 124 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( strncmp ( MATLAB_HDR . identific , ""MATLAB"" , 6 ) != 0 ) { image2 = ReadMATImageV4 ( image_info , image , exception ) ; if ( image2 == NULL ) goto MATLAB_KO ; image = image2 ; goto END_OF_READING ; } MATLAB_HDR . Version = ReadBlobLSBShort ( image ) ; if ( ReadBlob ( image , 2 , ( unsigned char * ) & MATLAB_HDR . EndianIndicator ) != 2 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>Endian<S2SV_blank>%c%c"" , MATLAB_HDR . EndianIndicator [ 0 ] , MATLAB_HDR . EndianIndicator [ 1 ] ) ; if ( ! strncmp ( MATLAB_HDR . EndianIndicator , ""IM"" , 2 ) ) { ReadBlobXXXLong = ReadBlobLSBLong ; ReadBlobXXXShort = ReadBlobLSBShort ; ReadBlobDoublesXXX = ReadBlobDoublesLSB ; ReadBlobFloatsXXX = ReadBlobFloatsLSB ; image -> endian = LSBEndian ; } else if ( ! strncmp ( MATLAB_HDR . EndianIndicator , ""MI"" , 2 ) ) { ReadBlobXXXLong = ReadBlobMSBLong ; ReadBlobXXXShort = ReadBlobMSBShort ; ReadBlobDoublesXXX = ReadBlobDoublesMSB ; ReadBlobFloatsXXX = ReadBlobFloatsMSB ; image -> endian = MSBEndian ; } else goto MATLAB_KO ; if ( strncmp ( MATLAB_HDR . identific , ""MATLAB"" , 6 ) ) { <S2SV_StartBug> MATLAB_KO : <S2SV_EndBug> clone_info = DestroyImageInfo ( clone_info ) ; ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } filepos = TellBlob ( image ) ; while ( ! EOFBlob ( image ) ) { Frames = 1 ; ( void ) SeekBlob ( image , filepos , SEEK_SET ) ; MATLAB_HDR . DataType = ReadBlobXXXLong ( image ) ; if ( EOFBlob ( image ) ) break ; MATLAB_HDR . ObjectSize = ReadBlobXXXLong ( image ) ; if ( EOFBlob ( image ) ) break ; if ( ( MagickSizeType ) ( MATLAB_HDR . ObjectSize + filepos ) > GetBlobSize ( image ) ) goto MATLAB_KO ; filepos += MATLAB_HDR . ObjectSize + 4 + 4 ; clone_info = CloneImageInfo ( image_info ) ; image2 = image ; # if defined ( MAGICKCORE_ZLIB_DELEGATE ) if ( MATLAB_HDR . DataType == miCOMPRESSED ) { image2 = decompress_block ( image , & MATLAB_HDR . ObjectSize , clone_info , exception ) ; if ( image2 == NULL ) continue ; MATLAB_HDR . DataType = ReadBlobXXXLong ( image2 ) ; } # endif if ( MATLAB_HDR . DataType != miMATRIX ) continue ; MATLAB_HDR . unknown1 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown2 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown5 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . StructureClass = MATLAB_HDR . unknown5 & 0xFF ; MATLAB_HDR . StructureFlag = ( MATLAB_HDR . unknown5 >> 8 ) & 0xFF ; MATLAB_HDR . unknown3 = ReadBlobXXXLong ( image2 ) ; if ( image != image2 ) MATLAB_HDR . unknown4 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown4 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . DimFlag = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . SizeX = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . SizeY = ReadBlobXXXLong ( image2 ) ; switch ( MATLAB_HDR . DimFlag ) { case 8 : z2 = z = 1 ; break ; case 12 : z2 = z = ReadBlobXXXLong ( image2 ) ; Unknown6 = ReadBlobXXXLong ( image2 ) ; ( void ) Unknown6 ; if ( z != 3 ) ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; break ; case 16 : z2 = z = ReadBlobXXXLong ( image2 ) ; if ( z != 3 && z != 1 ) ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; Frames = ReadBlobXXXLong ( image2 ) ; if ( Frames == 0 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; break ; default : ThrowReaderException ( CoderError , ""MultidimensionalMatricesAreNotSupported"" ) ; } MATLAB_HDR . Flag1 = ReadBlobXXXShort ( image2 ) ; MATLAB_HDR . NameFlag = ReadBlobXXXShort ( image2 ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""MATLAB_HDR.StructureClass<S2SV_blank>%d"" , MATLAB_HDR . StructureClass ) ; if ( MATLAB_HDR . StructureClass != mxCHAR_CLASS && MATLAB_HDR . StructureClass != mxSINGLE_CLASS && MATLAB_HDR . StructureClass != mxDOUBLE_CLASS && MATLAB_HDR . StructureClass != mxINT8_CLASS && MATLAB_HDR . StructureClass != mxUINT8_CLASS && MATLAB_HDR . StructureClass != mxINT16_CLASS && MATLAB_HDR . StructureClass != mxUINT16_CLASS && MATLAB_HDR . StructureClass != mxINT32_CLASS && MATLAB_HDR . StructureClass != mxUINT32_CLASS && MATLAB_HDR . StructureClass != mxINT64_CLASS && MATLAB_HDR . StructureClass != mxUINT64_CLASS ) ThrowReaderException ( CoderError , ""UnsupportedCellTypeInTheMatrix"" ) ; switch ( MATLAB_HDR . NameFlag ) { case 0 : size = ReadBlobXXXLong ( image2 ) ; size = 4 * ( ssize_t ) ( ( size + 3 + 1 ) / 4 ) ; ( void ) SeekBlob ( image2 , size , SEEK_CUR ) ; break ; case 1 : case 2 : case 3 : case 4 : ( void ) ReadBlob ( image2 , 4 , ( unsigned char * ) & size ) ; break ; default : goto MATLAB_KO ; } CellType = ReadBlobXXXLong ( image2 ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""MATLAB_HDR.CellType:<S2SV_blank>%.20g"" , ( double ) CellType ) ; ( void ) ReadBlob ( image2 , 4 , ( unsigned char * ) & size ) ; NEXT_FRAME : switch ( CellType ) { case miINT8 : case miUINT8 : sample_size = 8 ; if ( MATLAB_HDR . StructureFlag & FLAG_LOGICAL ) image -> depth = 1 ; else image -> depth = 8 ; ldblk = ( ssize_t ) MATLAB_HDR . SizeX ; break ; case miINT16 : case miUINT16 : sample_size = 16 ; image -> depth = 16 ; ldblk = ( ssize_t ) ( 2 * MATLAB_HDR . SizeX ) ; break ; case miINT32 : case miUINT32 : sample_size = 32 ; image -> depth = 32 ; ldblk = ( ssize_t ) ( 4 * MATLAB_HDR . SizeX ) ; break ; case miINT64 : case miUINT64 : sample_size = 64 ; image -> depth = 64 ; ldblk = ( ssize_t ) ( 8 * MATLAB_HDR . SizeX ) ; break ; case miSINGLE : sample_size = 32 ; image -> depth = 32 ; ( void ) SetImageOption ( clone_info , ""quantum:format"" , ""floating-point"" ) ; if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { } ldblk = ( ssize_t ) ( 4 * MATLAB_HDR . SizeX ) ; break ; case miDOUBLE : sample_size = 64 ; image -> depth = 64 ; ( void ) SetImageOption ( clone_info , ""quantum:format"" , ""floating-point"" ) ; DisableMSCWarning ( 4127 ) if ( sizeof ( double ) != 8 ) RestoreMSCWarning ThrowReaderException ( CoderError , ""IncompatibleSizeOfDouble"" ) ; if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { } ldblk = ( ssize_t ) ( 8 * MATLAB_HDR . SizeX ) ; break ; default : if ( ( image != image2 ) && ( image2 != ( Image * ) NULL ) ) image2 = DestroyImage ( image2 ) ; if ( clone_info ) clone_info = DestroyImageInfo ( clone_info ) ; ThrowReaderException ( CoderError , ""UnsupportedCellTypeInTheMatrix"" ) ; } ( void ) sample_size ; image -> columns = MATLAB_HDR . SizeX ; image -> rows = MATLAB_HDR . SizeY ; one = 1 ; image -> colors = one << image -> depth ; if ( image -> columns == 0 || image -> rows == 0 ) goto MATLAB_KO ; if ( ( unsigned long ) ldblk * MATLAB_HDR . SizeY > MATLAB_HDR . ObjectSize ) goto MATLAB_KO ; if ( ( MATLAB_HDR . DimFlag == 8 ) && ( ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) == 0 ) ) { SetImageColorspace ( image , GRAYColorspace ) ; image -> type = GrayscaleType ; } if ( image_info -> ping ) { size_t temp = image -> columns ; image -> columns = image -> rows ; image -> rows = temp ; goto done_reading ; } status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } quantum_info = AcquireQuantumInfo ( clone_info , image ) ; if ( quantum_info == ( QuantumInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; BImgBuff = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ( ldblk ) , sizeof ( double ) ) ; if ( BImgBuff == NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; ( void ) ResetMagickMemory ( BImgBuff , 0 , ldblk * sizeof ( double ) ) ; MinVal = 0 ; MaxVal = 0 ; if ( CellType == miDOUBLE || CellType == miSINGLE ) { CalcMinMax ( image2 , image_info -> endian , MATLAB_HDR . SizeX , MATLAB_HDR . SizeY , CellType , ldblk , BImgBuff , & quantum_info -> minimum , & quantum_info -> maximum ) ; } if ( z == 1 ) z = 0 ; do { for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { q = GetAuthenticPixels ( image , 0 , MATLAB_HDR . SizeY - i - 1 , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>set<S2SV_blank>image<S2SV_blank>pixels<S2SV_blank>returns<S2SV_blank>unexpected<S2SV_blank>NULL<S2SV_blank>on<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u."" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto done_reading ; } if ( ReadBlob ( image2 , ldblk , ( unsigned char * ) BImgBuff ) != ( ssize_t ) ldblk ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>cannot<S2SV_blank>read<S2SV_blank>scanrow<S2SV_blank>%u<S2SV_blank>from<S2SV_blank>a<S2SV_blank>file."" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto ExitLoop ; } if ( ( CellType == miINT8 || CellType == miUINT8 ) && ( MATLAB_HDR . StructureFlag & FLAG_LOGICAL ) ) { FixLogical ( ( unsigned char * ) BImgBuff , ldblk ) ; if ( ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , z2qtype [ z ] , BImgBuff , exception ) <= 0 ) { ImportQuantumPixelsFailed : if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>ImportQuantumPixels<S2SV_blank>for<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u"" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; break ; } } else { if ( ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , z2qtype [ z ] , BImgBuff , exception ) <= 0 ) goto ImportQuantumPixelsFailed ; if ( z <= 1 && ( CellType == miINT8 || CellType == miINT16 || CellType == miINT32 || CellType == miINT64 ) ) FixSignedValues ( q , MATLAB_HDR . SizeX ) ; } if ( ! SyncAuthenticPixels ( image , exception ) ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""<S2SV_blank><S2SV_blank>MAT<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>sync<S2SV_blank>image<S2SV_blank>pixels<S2SV_blank>for<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u"" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto ExitLoop ; } } } while ( z -- >= 2 ) ; ExitLoop : if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { CellType = ReadBlobXXXLong ( image2 ) ; i = ReadBlobXXXLong ( image2 ) ; if ( CellType == miDOUBLE || CellType == miSINGLE ) { CalcMinMax ( image2 , image_info -> endian , MATLAB_HDR . SizeX , MATLAB_HDR . SizeY , CellType , ldblk , BImgBuff , & MinVal , & MaxVal ) ; } if ( CellType == miDOUBLE ) for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { ReadBlobDoublesXXX ( image2 , ldblk , ( double * ) BImgBuff ) ; InsertComplexDoubleRow ( ( double * ) BImgBuff , i , image , MinVal , MaxVal ) ; } if ( CellType == miSINGLE ) for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { ReadBlobFloatsXXX ( image2 , ldblk , ( float * ) BImgBuff ) ; InsertComplexFloatRow ( ( float * ) BImgBuff , i , image , MinVal , MaxVal ) ; } } if ( ( MATLAB_HDR . DimFlag == 8 ) && ( ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) == 0 ) ) image -> type = GrayscaleType ; if ( image -> depth == 1 ) image -> type = BilevelType ; if ( image2 == image ) image2 = NULL ; rotated_image = RotateImage ( image , 90.0 , exception ) ; if ( rotated_image != ( Image * ) NULL ) { rotated_image -> page . x = 0 ; rotated_image -> page . y = 0 ; blob = rotated_image -> blob ; rotated_image -> blob = image -> blob ; rotated_image -> colors = image -> colors ; image -> blob = blob ; AppendImageToList ( & image , rotated_image ) ; DeleteImageFromList ( & image ) ; } done_reading : if ( image2 != NULL ) if ( image2 != image ) { DeleteImageFromList ( & image2 ) ; if ( clone_info ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } } } AcquireNextImage ( image_info , image ) ; if ( image -> next == ( Image * ) NULL ) break ; image = SyncNextImageInList ( image ) ; image -> columns = image -> rows = 0 ; image -> colors = 0 ; RelinquishMagickMemory ( BImgBuff ) ; BImgBuff = NULL ; if ( -- Frames > 0 ) { z = z2 ; if ( image2 == NULL ) image2 = image ; goto NEXT_FRAME ; } if ( image2 != NULL ) if ( image2 != image ) { DeleteImageFromList ( & image2 ) ; if ( clone_info ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) unlink ( clone_info -> filename ) ; } } } } RelinquishMagickMemory ( BImgBuff ) ; if ( quantum_info != ( QuantumInfo * ) NULL ) quantum_info = DestroyQuantumInfo ( quantum_info ) ; END_OF_READING : if ( clone_info ) clone_info = DestroyImageInfo ( clone_info ) ; CloseBlob ( image ) ; { Image * p ; ssize_t scene = 0 ; p = image ; image = NULL ; while ( p != ( Image * ) NULL ) { Image * tmp = p ; if ( ( p -> rows == 0 ) || ( p -> columns == 0 ) ) { p = p -> previous ; DeleteImageFromList ( & tmp ) ; } else { image = p ; p = p -> previous ; } } for ( p = image ; p != ( Image * ) NULL ; p = p -> next ) p -> scene = scene ++ ; } if ( clone_info != NULL ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } DestroyImageInfo ( clone_info ) ; clone_info = NULL ; } if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""return"" ) ; if ( ( image != image2 ) && ( image2 != ( Image * ) NULL ) ) image2 = DestroyImage ( image2 ) ; if ( image == NULL ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; return ( image ) ; }",{ MATLAB_KO : if ( clone_info != ( ImageInfo * ) NULL )
821,"static void bgp_update_print ( netdissect_options * ndo , const u_char * dat , int length ) { struct bgp bgp ; const u_char * p ; int withdrawn_routes_len ; int len ; int i ; ND_TCHECK2 ( dat [ 0 ] , BGP_SIZE ) ; if ( length < BGP_SIZE ) goto trunc ; memcpy ( & bgp , dat , BGP_SIZE ) ; p = dat + BGP_SIZE ; length -= BGP_SIZE ; ND_TCHECK2 ( p [ 0 ] , 2 ) ; if ( length < 2 ) goto trunc ; withdrawn_routes_len = EXTRACT_16BITS ( p ) ; p += 2 ; length -= 2 ; if ( withdrawn_routes_len ) { ND_TCHECK2 ( p [ 0 ] , withdrawn_routes_len ) ; if ( length < withdrawn_routes_len ) goto trunc ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Withdrawn<S2SV_blank>routes:<S2SV_blank>%d<S2SV_blank>bytes"" , withdrawn_routes_len ) ) ; p += withdrawn_routes_len ; length -= withdrawn_routes_len ; } ND_TCHECK2 ( p [ 0 ] , 2 ) ; if ( length < 2 ) goto trunc ; len = EXTRACT_16BITS ( p ) ; p += 2 ; length -= 2 ; if ( withdrawn_routes_len == 0 && len == 0 && length == 0 ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>End-of-Rib<S2SV_blank>Marker<S2SV_blank>(empty<S2SV_blank>NLRI)"" ) ) ; return ; } if ( len ) { while ( len ) { int aflags , atype , alenlen , alen ; ND_TCHECK2 ( p [ 0 ] , 2 ) ; if ( len < 2 ) goto trunc ; if ( length < 2 ) goto trunc ; aflags = * p ; atype = * ( p + 1 ) ; p += 2 ; len -= 2 ; length -= 2 ; alenlen = bgp_attr_lenlen ( aflags , p ) ; ND_TCHECK2 ( p [ 0 ] , alenlen ) ; if ( len < alenlen ) goto trunc ; if ( length < alenlen ) goto trunc ; alen = bgp_attr_len ( aflags , p ) ; p += alenlen ; len -= alenlen ; length -= alenlen ; ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>length:<S2SV_blank>%u"" , tok2str ( bgp_attr_values , ""Unknown<S2SV_blank>Attribute"" , atype ) , atype , alen ) ) ; if ( aflags ) { ND_PRINT ( ( ndo , "",<S2SV_blank>Flags<S2SV_blank>[%s%s%s%s"" , aflags & 0x80 ? ""O"" : """" , aflags & 0x40 ? ""T"" : """" , aflags & 0x20 ? ""P"" : """" , aflags & 0x10 ? ""E"" : """" ) ) ; if ( aflags & 0xf ) ND_PRINT ( ( ndo , ""+%x"" , aflags & 0xf ) ) ; ND_PRINT ( ( ndo , ""]:<S2SV_blank>"" ) ) ; } if ( len < alen ) goto trunc ; if ( length < alen ) goto trunc ; <S2SV_StartBug> if ( ! bgp_attr_print ( ndo , atype , p , alen ) ) <S2SV_EndBug> goto trunc ; p += alen ; len -= alen ; length -= alen ; } } if ( length ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank>Updated<S2SV_blank>routes:"" ) ) ; while ( length ) { char buf [ MAXHOSTNAMELEN + 100 ] ; i = decode_prefix4 ( ndo , p , length , buf , sizeof ( buf ) ) ; if ( i == - 1 ) { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)"" ) ) ; break ; } else if ( i == - 2 ) goto trunc ; else if ( i == - 3 ) goto trunc ; else { ND_PRINT ( ( ndo , ""\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s"" , buf ) ) ; p += i ; length -= i ; } } } return ; trunc : ND_PRINT ( ( ndo , ""%s"" , tstr ) ) ; }","p , alen , 0"
822,"static void ext2_put_super ( struct super_block * sb ) { int db_count ; int i ; struct ext2_sb_info * sbi = EXT2_SB ( sb ) ; dquot_disable ( sb , - 1 , DQUOT_USAGE_ENABLED | DQUOT_LIMITS_ENABLED ) ; <S2SV_StartBug> ext2_xattr_put_super ( sb ) ; <S2SV_EndBug> if ( ! ( sb -> s_flags & MS_RDONLY ) ) { struct ext2_super_block * es = sbi -> s_es ; spin_lock ( & sbi -> s_lock ) ; es -> s_state = cpu_to_le16 ( sbi -> s_mount_state ) ; spin_unlock ( & sbi -> s_lock ) ; ext2_sync_super ( sb , es , 1 ) ; } db_count = sbi -> s_gdb_count ; for ( i = 0 ; i < db_count ; i ++ ) if ( sbi -> s_group_desc [ i ] ) brelse ( sbi -> s_group_desc [ i ] ) ; kfree ( sbi -> s_group_desc ) ; kfree ( sbi -> s_debts ) ; percpu_counter_destroy ( & sbi -> s_freeblocks_counter ) ; percpu_counter_destroy ( & sbi -> s_freeinodes_counter ) ; percpu_counter_destroy ( & sbi -> s_dirs_counter ) ; brelse ( sbi -> s_sbh ) ; sb -> s_fs_info = NULL ; kfree ( sbi -> s_blockgroup_lock ) ; kfree ( sbi ) ; }",DQUOT_LIMITS_ENABLED ) ; if ( sbi -> s_mb_cache ) { ext2_xattr_destroy_cache ( sbi -> s_mb_cache ) ; sbi -> s_mb_cache = NULL ; } <S2SV_ModEnd> if ( !
823,"long keyctl_update_key ( key_serial_t id , const void __user * _payload , size_t plen ) { key_ref_t key_ref ; void * payload ; long ret ; ret = - EINVAL ; if ( plen > PAGE_SIZE ) goto error ; payload = NULL ; <S2SV_StartBug> if ( _payload ) { <S2SV_EndBug> ret = - ENOMEM ; payload = kmalloc ( plen , GFP_KERNEL ) ; if ( ! payload ) goto error ; ret = - EFAULT ; if ( copy_from_user ( payload , _payload , plen ) != 0 ) goto error2 ; } key_ref = lookup_user_key ( id , 0 , KEY_NEED_WRITE ) ; if ( IS_ERR ( key_ref ) ) { ret = PTR_ERR ( key_ref ) ; goto error2 ; } ret = key_update ( key_ref , payload , plen ) ; key_ref_put ( key_ref ) ; error2 : kfree ( payload ) ; error : return ret ; }",; if ( plen <S2SV_ModEnd> ) { ret
824,"void vp8_set_speed_features ( VP8_COMP * cpi ) { SPEED_FEATURES * sf = & cpi -> sf ; int Mode = cpi -> compressor_speed ; int Speed = cpi -> Speed ; int i ; VP8_COMMON * cm = & cpi -> common ; int last_improved_quant = sf -> improved_quant ; int ref_frames ; for ( i = 0 ; i < MAX_MODES ; i ++ ) { cpi -> mode_check_freq [ i ] = 0 ; } cpi -> mb . mbs_tested_so_far = 0 ; <S2SV_StartBug> sf -> RD = 1 ; <S2SV_EndBug> sf -> search_method = NSTEP ; sf -> improved_quant = 1 ; sf -> improved_dct = 1 ; sf -> auto_filter = 1 ; sf -> recode_loop = 1 ; sf -> quarter_pixel_search = 1 ; sf -> half_pixel_search = 1 ; sf -> iterative_sub_pixel = 1 ; sf -> optimize_coefficients = 1 ; sf -> use_fastquant_for_pick = 0 ; sf -> no_skip_block4x4_search = 1 ; sf -> first_step = 0 ; sf -> max_step_search_steps = MAX_MVSEARCH_STEPS ; sf -> improved_mv_pred = 1 ; for ( i = 0 ; i < MAX_MODES ; i ++ ) sf -> thresh_mult [ i ] = 0 ; ref_frames = 1 ; if ( cpi -> ref_frame_flags & VP8_LAST_FRAME ) ref_frames ++ ; if ( cpi -> ref_frame_flags & VP8_GOLD_FRAME ) ref_frames ++ ; if ( cpi -> ref_frame_flags & VP8_ALTR_FRAME ) ref_frames ++ ; if ( Mode == 0 ) Speed = 0 ; else if ( Mode == 2 ) Speed = RT ( Speed ) ; else { if ( Speed > 5 ) Speed = 5 ; Speed = GOOD ( Speed ) ; } sf -> thresh_mult [ THR_ZERO1 ] = sf -> thresh_mult [ THR_NEAREST1 ] = sf -> thresh_mult [ THR_NEAR1 ] = sf -> thresh_mult [ THR_DC ] = 0 ; sf -> thresh_mult [ THR_ZERO2 ] = sf -> thresh_mult [ THR_ZERO3 ] = sf -> thresh_mult [ THR_NEAREST2 ] = sf -> thresh_mult [ THR_NEAREST3 ] = sf -> thresh_mult [ THR_NEAR2 ] = sf -> thresh_mult [ THR_NEAR3 ] = speed_map ( Speed , thresh_mult_map_znn ) ; sf -> thresh_mult [ THR_V_PRED ] = sf -> thresh_mult [ THR_H_PRED ] = speed_map ( Speed , thresh_mult_map_vhpred ) ; sf -> thresh_mult [ THR_B_PRED ] = speed_map ( Speed , thresh_mult_map_bpred ) ; sf -> thresh_mult [ THR_TM ] = speed_map ( Speed , thresh_mult_map_tm ) ; sf -> thresh_mult [ THR_NEW1 ] = speed_map ( Speed , thresh_mult_map_new1 ) ; sf -> thresh_mult [ THR_NEW2 ] = sf -> thresh_mult [ THR_NEW3 ] = speed_map ( Speed , thresh_mult_map_new2 ) ; sf -> thresh_mult [ THR_SPLIT1 ] = speed_map ( Speed , thresh_mult_map_split1 ) ; sf -> thresh_mult [ THR_SPLIT2 ] = <S2SV_StartBug> sf -> thresh_mult [ THR_SPLIT3 ] = speed_map ( Speed , thresh_mult_map_split2 ) ; <S2SV_EndBug> cpi -> mode_check_freq [ THR_ZERO1 ] = cpi -> mode_check_freq [ THR_NEAREST1 ] = cpi -> mode_check_freq [ THR_NEAR1 ] = cpi -> mode_check_freq [ THR_TM ] = cpi -> mode_check_freq [ THR_DC ] = 0 ; cpi -> mode_check_freq [ THR_ZERO2 ] = cpi -> mode_check_freq [ THR_ZERO3 ] = cpi -> mode_check_freq [ THR_NEAREST2 ] = cpi -> mode_check_freq [ THR_NEAREST3 ] = speed_map ( Speed , mode_check_freq_map_zn2 ) ; cpi -> mode_check_freq [ THR_NEAR2 ] = cpi -> mode_check_freq [ THR_NEAR3 ] = speed_map ( Speed , mode_check_freq_map_near2 ) ; cpi -> mode_check_freq [ THR_V_PRED ] = cpi -> mode_check_freq [ THR_H_PRED ] = cpi -> mode_check_freq [ THR_B_PRED ] = speed_map ( Speed , mode_check_freq_map_vhbpred ) ; cpi -> mode_check_freq [ THR_NEW1 ] = speed_map ( Speed , mode_check_freq_map_new1 ) ; cpi -> mode_check_freq [ THR_NEW2 ] = cpi -> mode_check_freq [ THR_NEW3 ] = speed_map ( Speed , mode_check_freq_map_new2 ) ; cpi -> mode_check_freq [ THR_SPLIT1 ] = speed_map ( Speed , mode_check_freq_map_split1 ) ; cpi -> mode_check_freq [ THR_SPLIT2 ] = cpi -> mode_check_freq [ THR_SPLIT3 ] = speed_map ( Speed , mode_check_freq_map_split2 ) ; Speed = cpi -> Speed ; switch ( Mode ) { # if ! ( CONFIG_REALTIME_ONLY ) case 0 : sf -> first_step = 0 ; sf -> max_step_search_steps = MAX_MVSEARCH_STEPS ; break ; case 1 : case 3 : if ( Speed > 0 ) { sf -> optimize_coefficients = 0 ; sf -> use_fastquant_for_pick = 1 ; sf -> no_skip_block4x4_search = 0 ; sf -> first_step = 1 ; } if ( Speed > 2 ) { sf -> improved_quant = 0 ; sf -> improved_dct = 0 ; sf -> recode_loop = 2 ; } if ( Speed > 3 ) { sf -> auto_filter = 1 ; sf -> recode_loop = 0 ; sf -> RD = 0 ; } if ( Speed > 4 ) { sf -> auto_filter = 0 ; } break ; # endif case 2 : sf -> optimize_coefficients = 0 ; sf -> recode_loop = 0 ; sf -> auto_filter = 1 ; sf -> iterative_sub_pixel = 1 ; sf -> search_method = NSTEP ; if ( Speed > 0 ) { sf -> improved_quant = 0 ; sf -> improved_dct = 0 ; sf -> use_fastquant_for_pick = 1 ; sf -> no_skip_block4x4_search = 0 ; sf -> first_step = 1 ; } if ( Speed > 2 ) sf -> auto_filter = 0 ; if ( Speed > 3 ) { sf -> RD = 0 ; sf -> auto_filter = 1 ; } if ( Speed > 4 ) { sf -> auto_filter = 0 ; sf -> search_method = HEX ; sf -> iterative_sub_pixel = 0 ; } if ( Speed > 6 ) { unsigned int sum = 0 ; unsigned int total_mbs = cm -> MBs ; int thresh ; unsigned int total_skip ; int min = 2000 ; if ( cpi -> oxcf . encode_breakout > 2000 ) min = cpi -> oxcf . encode_breakout ; min >>= 7 ; for ( i = 0 ; i < min ; i ++ ) { sum += cpi -> mb . error_bins [ i ] ; } total_skip = sum ; sum = 0 ; for ( ; i < 1024 ; i ++ ) { sum += cpi -> mb . error_bins [ i ] ; if ( 10 * sum >= ( unsigned int ) ( cpi -> Speed - 6 ) * ( total_mbs - total_skip ) ) break ; } i -- ; thresh = ( i << 7 ) ; if ( thresh < 2000 ) thresh = 2000 ; if ( ref_frames > 1 ) { sf -> thresh_mult [ THR_NEW1 ] = thresh ; sf -> thresh_mult [ THR_NEAREST1 ] = thresh >> 1 ; sf -> thresh_mult [ THR_NEAR1 ] = thresh >> 1 ; } if ( ref_frames > 2 ) { sf -> thresh_mult [ THR_NEW2 ] = thresh << 1 ; sf -> thresh_mult [ THR_NEAREST2 ] = thresh ; sf -> thresh_mult [ THR_NEAR2 ] = thresh ; } if ( ref_frames > 3 ) { sf -> thresh_mult [ THR_NEW3 ] = thresh << 1 ; sf -> thresh_mult [ THR_NEAREST3 ] = thresh ; sf -> thresh_mult [ THR_NEAR3 ] = thresh ; } sf -> improved_mv_pred = 0 ; } if ( Speed > 8 ) sf -> quarter_pixel_search = 0 ; if ( cm -> version == 0 ) { cm -> filter_type = NORMAL_LOOPFILTER ; if ( Speed >= 14 ) cm -> filter_type = SIMPLE_LOOPFILTER ; } else { cm -> filter_type = SIMPLE_LOOPFILTER ; } if ( Speed >= 15 ) sf -> half_pixel_search = 0 ; <S2SV_StartBug> vpx_memset ( cpi -> mb . error_bins , 0 , sizeof ( cpi -> mb . error_bins ) ) ; <S2SV_EndBug> } ; if ( cpi -> pass == 1 ) { sf -> improved_quant = 0 ; sf -> optimize_coefficients = 0 ; sf -> improved_dct = 0 ; } if ( cpi -> sf . search_method == NSTEP ) { vp8_init3smotion_compensation ( & cpi -> mb , cm -> yv12_fb [ cm -> lst_fb_idx ] . y_stride ) ; } else if ( cpi -> sf . search_method == DIAMOND ) { vp8_init_dsmotion_compensation ( & cpi -> mb , cm -> yv12_fb [ cm -> lst_fb_idx ] . y_stride ) ; } if ( cpi -> sf . improved_dct ) { cpi -> mb . short_fdct8x4 = vp8_short_fdct8x4 ; cpi -> mb . short_fdct4x4 = vp8_short_fdct4x4 ; } else { cpi -> mb . short_fdct8x4 = vp8_short_fdct8x4 ; cpi -> mb . short_fdct4x4 = vp8_short_fdct4x4 ; } cpi -> mb . short_walsh4x4 = vp8_short_walsh4x4 ; if ( cpi -> sf . improved_quant ) { cpi -> mb . quantize_b = vp8_regular_quantize_b ; <S2SV_StartBug> cpi -> mb . quantize_b_pair = vp8_regular_quantize_b_pair ; <S2SV_EndBug> } else { <S2SV_StartBug> cpi -> mb . quantize_b = vp8_fast_quantize_b ; <S2SV_EndBug> cpi -> mb . quantize_b_pair = vp8_fast_quantize_b_pair ; } if ( cpi -> sf . improved_quant != last_improved_quant ) vp8cx_init_quantizer ( cpi ) ; if ( cpi -> sf . iterative_sub_pixel == 1 ) { cpi -> find_fractional_mv_step = vp8_find_best_sub_pixel_step_iteratively ; } else if ( cpi -> sf . quarter_pixel_search ) { cpi -> find_fractional_mv_step = vp8_find_best_sub_pixel_step ; } else if ( cpi -> sf . half_pixel_search ) { cpi -> find_fractional_mv_step = vp8_find_best_half_pixel_step ; } else { cpi -> find_fractional_mv_step = vp8_skip_fractional_mv_step ; } if ( cpi -> sf . optimize_coefficients == 1 && cpi -> pass != 1 ) cpi -> mb . optimize = 1 ; else cpi -> mb . optimize = 0 ; if ( cpi -> common . full_pixel ) cpi -> find_fractional_mv_step = vp8_skip_fractional_mv_step ; # ifdef SPEEDSTATS frames_at_speed [ cpi -> Speed ] ++ ; # endif }",= 0 ; cpi -> mb . mbs_zero_last_dot_suppress = 0 ; <S2SV_ModStart> thresh_mult_map_split2 ) ; if ( ( cpi -> Speed <= 6 ) && ( cpi -> oxcf . number_of_layers > 1 ) && ( cpi -> ref_frame_flags & VP8_LAST_FRAME ) && ( cpi -> ref_frame_flags & VP8_GOLD_FRAME ) ) { if ( cpi -> closest_reference_frame == GOLDEN_FRAME ) { sf -> thresh_mult [ THR_ZERO2 ] = sf -> thresh_mult [ THR_ZERO2 ] >> 3 ; sf -> thresh_mult [ THR_NEAREST2 ] = sf -> thresh_mult [ THR_NEAREST2 ] >> 3 ; sf -> thresh_mult [ THR_NEAR2 ] = sf -> thresh_mult [ THR_NEAR2 ] >> 3 ; } else { sf -> thresh_mult [ THR_ZERO2 ] = sf -> thresh_mult [ THR_ZERO2 ] >> 1 ; sf -> thresh_mult [ THR_NEAREST2 ] = sf -> thresh_mult [ THR_NEAREST2 ] >> 1 ; sf -> thresh_mult [ THR_NEAR2 ] = sf -> thresh_mult [ THR_NEAR2 ] >> 1 ; } } <S2SV_ModStart> = 0 ; memset <S2SV_ModEnd> ( cpi -> <S2SV_ModStart> = vp8_regular_quantize_b ; } else { <S2SV_ModStart> -> mb . <S2SV_ModEnd> quantize_b = vp8_fast_quantize_b <S2SV_ModStart> quantize_b = vp8_fast_quantize_b <S2SV_ModEnd> ; } if
825,"int jas_stream_read ( jas_stream_t * stream , void * buf , int cnt ) { int n ; int c ; <S2SV_StartBug> char * bufptr ; <S2SV_EndBug> bufptr = buf ; n = 0 ; while ( n < cnt ) { if ( ( c = jas_stream_getc ( stream ) ) == EOF ) { return n ; } * bufptr ++ = c ; ++ n ; } return n ; }","* bufptr ; if ( cnt < 0 ) { jas_deprecated ( ""negative<S2SV_blank>count<S2SV_blank>for<S2SV_blank>jas_stream_read"" ) ; }"
826,"struct r_bin_dyldcache_obj_t * r_bin_dyldcache_from_bytes_new ( const ut8 * buf , ut64 size ) { <S2SV_StartBug> struct r_bin_dyldcache_obj_t * bin ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( bin = malloc ( sizeof ( struct r_bin_dyldcache_obj_t ) ) ) ) { <S2SV_EndBug> return NULL ; } <S2SV_StartBug> memset ( bin , 0 , sizeof ( struct r_bin_dyldcache_obj_t ) ) ; <S2SV_EndBug> if ( ! buf ) { return r_bin_dyldcache_free ( bin ) ; } bin -> b = r_buf_new ( ) ; <S2SV_StartBug> if ( ! r_buf_set_bytes ( bin -> b , buf , size ) ) { <S2SV_EndBug> return r_bin_dyldcache_free ( bin ) ; } if ( ! r_bin_dyldcache_init ( bin ) ) { return r_bin_dyldcache_free ( bin ) ; } bin -> size = size ; return bin ; }",r_bin_dyldcache_obj_t * bin = R_NEW0 ( struct r_bin_dyldcache_obj_t ) <S2SV_ModStart> if ( ! bin <S2SV_ModEnd> ) { return <S2SV_ModStart> NULL ; } <S2SV_ModEnd> if ( ! <S2SV_ModStart> ; if ( ! bin -> b ||
827,"vpx_image_t * vpx_codec_get_frame ( vpx_codec_ctx_t * ctx , vpx_codec_iter_t * iter ) { vpx_image_t * img ; if ( ! ctx || ! iter || ! ctx -> iface || ! ctx -> priv ) img = NULL ; else <S2SV_StartBug> img = ctx -> iface -> dec . get_frame ( ctx -> priv -> alg_priv , iter ) ; <S2SV_EndBug> return img ; }",". get_frame ( get_alg_priv ( ctx ) <S2SV_ModEnd> , iter )"
828,"static void * Type_MLU_Read ( struct _cms_typehandler_struct * self , cmsIOHANDLER * io , cmsUInt32Number * nItems , cmsUInt32Number SizeOfTag ) { cmsMLU * mlu ; cmsUInt32Number Count , RecLen , NumOfWchar ; cmsUInt32Number SizeOfHeader ; cmsUInt32Number Len , Offset ; cmsUInt32Number i ; wchar_t * Block ; cmsUInt32Number BeginOfThisString , EndOfThisString , LargestPosition ; * nItems = 0 ; if ( ! _cmsReadUInt32Number ( io , & Count ) ) return NULL ; if ( ! _cmsReadUInt32Number ( io , & RecLen ) ) return NULL ; if ( RecLen != 12 ) { cmsSignalError ( self -> ContextID , cmsERROR_UNKNOWN_EXTENSION , ""multiLocalizedUnicodeType<S2SV_blank>of<S2SV_blank>len<S2SV_blank>!=<S2SV_blank>12<S2SV_blank>is<S2SV_blank>not<S2SV_blank>supported."" ) ; return NULL ; } mlu = cmsMLUalloc ( self -> ContextID , Count ) ; if ( mlu == NULL ) return NULL ; mlu -> UsedEntries = Count ; SizeOfHeader = 12 * Count + sizeof ( _cmsTagBase ) ; LargestPosition = 0 ; for ( i = 0 ; i < Count ; i ++ ) { if ( ! _cmsReadUInt16Number ( io , & mlu -> Entries [ i ] . Language ) ) goto Error ; if ( ! _cmsReadUInt16Number ( io , & mlu -> Entries [ i ] . Country ) ) goto Error ; if ( ! _cmsReadUInt32Number ( io , & Len ) ) goto Error ; if ( ! _cmsReadUInt32Number ( io , & Offset ) ) goto Error ; <S2SV_StartBug> if ( Offset < ( SizeOfHeader + 8 ) ) goto Error ; <S2SV_EndBug> BeginOfThisString = Offset - SizeOfHeader - 8 ; mlu -> Entries [ i ] . Len = ( Len * sizeof ( wchar_t ) ) / sizeof ( cmsUInt16Number ) ; mlu -> Entries [ i ] . StrW = ( BeginOfThisString * sizeof ( wchar_t ) ) / sizeof ( cmsUInt16Number ) ; EndOfThisString = BeginOfThisString + Len ; if ( EndOfThisString > LargestPosition ) LargestPosition = EndOfThisString ; } SizeOfTag = ( LargestPosition * sizeof ( wchar_t ) ) / sizeof ( cmsUInt16Number ) ; if ( SizeOfTag == 0 ) { Block = NULL ; NumOfWchar = 0 ; } else { Block = ( wchar_t * ) _cmsMalloc ( self -> ContextID , SizeOfTag ) ; if ( Block == NULL ) goto Error ; NumOfWchar = SizeOfTag / sizeof ( wchar_t ) ; if ( ! _cmsReadWCharArray ( io , NumOfWchar , Block ) ) goto Error ; } mlu -> MemPool = Block ; mlu -> PoolSize = SizeOfTag ; mlu -> PoolUsed = SizeOfTag ; * nItems = 1 ; return ( void * ) mlu ; Error : if ( mlu ) cmsMLUfree ( mlu ) ; return NULL ; }",+ 8 ) ) goto Error ; if ( ( Offset + Len ) > SizeOfTag + 8
829,"void __ip_select_ident ( struct net * net , struct iphdr * iph , int segs ) { <S2SV_StartBug> static u32 ip_idents_hashrnd __read_mostly ; <S2SV_EndBug> u32 hash , id ; <S2SV_StartBug> net_get_random_once ( & ip_idents_hashrnd , sizeof ( ip_idents_hashrnd ) ) ; <S2SV_EndBug> <S2SV_StartBug> hash = jhash_3words ( ( __force u32 ) iph -> daddr , <S2SV_EndBug> ( __force u32 ) iph -> saddr , <S2SV_StartBug> iph -> protocol ^ net_hash_mix ( net ) , <S2SV_EndBug> ip_idents_hashrnd ) ; id = ip_idents_reserve ( hash , segs ) ; iph -> id = htons ( id ) ; }","segs ) { <S2SV_ModEnd> u32 hash , <S2SV_ModStart> , id ; if ( unlikely ( siphash_key_is_zero ( & net -> ipv4 . ip_id_key ) ) ) get_random_bytes ( & net -> ipv4 . ip_id_key <S2SV_ModEnd> , sizeof ( <S2SV_ModStart> , sizeof ( net -> ipv4 . ip_id_key <S2SV_ModEnd> ) ) ; <S2SV_ModStart> ; hash = siphash_3u32 <S2SV_ModEnd> ( ( __force <S2SV_ModStart> iph -> protocol , & net -> ipv4 . ip_id_key <S2SV_ModEnd> ) ; id"
830,"static int cp2112_gpio_direction_output ( struct gpio_chip * chip , unsigned offset , int value ) { struct cp2112_device * dev = gpiochip_get_data ( chip ) ; struct hid_device * hdev = dev -> hdev ; u8 * buf = dev -> in_out_buffer ; <S2SV_StartBug> unsigned long flags ; <S2SV_EndBug> int ret ; <S2SV_StartBug> spin_lock_irqsave ( & dev -> lock , flags ) ; <S2SV_EndBug> ret = hid_hw_raw_request ( hdev , CP2112_GPIO_CONFIG , buf , CP2112_GPIO_CONFIG_LENGTH , HID_FEATURE_REPORT , HID_REQ_GET_REPORT ) ; if ( ret != CP2112_GPIO_CONFIG_LENGTH ) { hid_err ( hdev , ""error<S2SV_blank>requesting<S2SV_blank>GPIO<S2SV_blank>config:<S2SV_blank>%d\\n"" , ret ) ; goto fail ; } buf [ 1 ] |= 1 << offset ; buf [ 2 ] = gpio_push_pull ; ret = hid_hw_raw_request ( hdev , CP2112_GPIO_CONFIG , buf , CP2112_GPIO_CONFIG_LENGTH , HID_FEATURE_REPORT , HID_REQ_SET_REPORT ) ; if ( ret < 0 ) { hid_err ( hdev , ""error<S2SV_blank>setting<S2SV_blank>GPIO<S2SV_blank>config:<S2SV_blank>%d\\n"" , ret ) ; goto fail ; } <S2SV_StartBug> spin_unlock_irqrestore ( & dev -> lock , flags ) ; <S2SV_EndBug> cp2112_gpio_set ( chip , offset , value ) ; return 0 ; fail : <S2SV_StartBug> spin_unlock_irqrestore ( & dev -> lock , flags ) ; <S2SV_EndBug> return ret < 0 ? ret : - EIO ; }",-> in_out_buffer ; <S2SV_ModEnd> int ret ; <S2SV_ModStart> int ret ; mutex_lock <S2SV_ModEnd> ( & dev <S2SV_ModStart> dev -> lock <S2SV_ModEnd> ) ; ret <S2SV_ModStart> fail ; } mutex_unlock <S2SV_ModEnd> ( & dev <S2SV_ModStart> dev -> lock <S2SV_ModEnd> ) ; cp2112_gpio_set <S2SV_ModStart> ; fail : mutex_unlock <S2SV_ModEnd> ( & dev <S2SV_ModStart> dev -> lock <S2SV_ModEnd> ) ; return
831,"static void timer_enter_running ( Timer * t ) { _cleanup_bus_error_free_ sd_bus_error error = SD_BUS_ERROR_NULL ; int r ; assert ( t ) ; if ( unit_stop_pending ( UNIT ( t ) ) ) return ; r = manager_add_job ( UNIT ( t ) -> manager , JOB_START , UNIT_TRIGGER ( UNIT ( t ) ) , JOB_REPLACE , true , & error , NULL ) ; if ( r < 0 ) goto fail ; dual_timestamp_get ( & t -> last_trigger ) ; if ( t -> stamp_path ) <S2SV_StartBug> touch_file ( t -> stamp_path , true , t -> last_trigger . realtime , UID_INVALID , GID_INVALID , 0 ) ; <S2SV_EndBug> timer_set_state ( t , TIMER_RUNNING ) ; return ; fail : log_unit_warning ( UNIT ( t ) , ""Failed<S2SV_blank>to<S2SV_blank>queue<S2SV_blank>unit<S2SV_blank>startup<S2SV_blank>job:<S2SV_blank>%s"" , bus_error_message ( & error , r ) ) ; timer_enter_dead ( t , TIMER_FAILURE_RESOURCES ) ; }",", GID_INVALID , MODE_INVALID <S2SV_ModEnd> ) ; timer_set_state"
832,"int sock_queue_err_skb ( struct sock * sk , struct sk_buff * skb ) { if ( atomic_read ( & sk -> sk_rmem_alloc ) + skb -> truesize >= ( unsigned int ) sk -> sk_rcvbuf ) return - ENOMEM ; skb_orphan ( skb ) ; skb -> sk = sk ; skb -> destructor = sock_rmem_free ; atomic_add ( skb -> truesize , & sk -> sk_rmem_alloc ) ; <S2SV_StartBug> skb_dst_force ( skb ) ; <S2SV_EndBug> skb_queue_tail ( & sk -> sk_error_queue , skb ) ; if ( ! sock_flag ( sk , SOCK_DEAD ) ) sk -> sk_data_ready ( sk ) ; return 0 ; }",sk_rmem_alloc ) ; skb_set_err_queue ( skb ) ;
833,"static const char * lua_authz_parse ( cmd_parms * cmd , const char * require_line , const void * * parsed_require_line ) { const char * provider_name ; <S2SV_StartBug> lua_authz_provider_spec * spec ; <S2SV_EndBug> apr_pool_userdata_get ( ( void * * ) & provider_name , AUTHZ_PROVIDER_NAME_NOTE , cmd -> temp_pool ) ; ap_assert ( provider_name != NULL ) ; spec = apr_hash_get ( lua_authz_providers , provider_name , APR_HASH_KEY_STRING ) ; ap_assert ( spec != NULL ) ; <S2SV_StartBug> if ( require_line && * require_line ) { <S2SV_EndBug> const char * arg ; <S2SV_StartBug> spec -> args = apr_array_make ( cmd -> pool , 2 , sizeof ( const char * ) ) ; <S2SV_EndBug> while ( ( arg = ap_getword_conf ( cmd -> pool , & require_line ) ) && * arg ) { <S2SV_StartBug> APR_ARRAY_PUSH ( spec -> args , const char * ) = arg ; <S2SV_EndBug> } } <S2SV_StartBug> * parsed_require_line = spec ; <S2SV_EndBug> return NULL ; }","lua_authz_provider_spec * spec ; lua_authz_provider_func * func = apr_pcalloc ( cmd -> pool , sizeof ( lua_authz_provider_func ) ) <S2SV_ModStart> NULL ) ; func -> spec = spec ; <S2SV_ModStart> * arg ; func <S2SV_ModEnd> -> args = <S2SV_ModStart> { APR_ARRAY_PUSH ( func <S2SV_ModEnd> -> args , <S2SV_ModStart> * parsed_require_line = func <S2SV_ModEnd> ; return NULL"
834,"static void voutf ( struct GlobalConfig * config , const char * prefix , const char * fmt , va_list ap ) { size_t width = ( 79 - strlen ( prefix ) ) ; if ( ! config -> mute ) { size_t len ; char * ptr ; char * print_buffer ; print_buffer = curlx_mvaprintf ( fmt , ap ) ; if ( ! print_buffer ) return ; len = strlen ( print_buffer ) ; ptr = print_buffer ; while ( len > 0 ) { fputs ( prefix , config -> errors ) ; if ( len > width ) { size_t cut = width - 1 ; while ( ! ISSPACE ( ptr [ cut ] ) && cut ) { cut -- ; } if ( 0 == cut ) cut = width - 1 ; ( void ) fwrite ( ptr , cut + 1 , 1 , config -> errors ) ; fputs ( ""\\n"" , config -> errors ) ; ptr += cut + 1 ; <S2SV_StartBug> len -= cut ; <S2SV_EndBug> } else { fputs ( ptr , config -> errors ) ; len = 0 ; } } curl_free ( print_buffer ) ; } }",len -= cut + 1
835,"int pam_sm_authenticate ( pam_handle_t * pamh , int flags , int argc , const char * * argv ) { struct passwd * pw = NULL , pw_s ; const char * user = NULL ; cfg_t cfg_st ; cfg_t * cfg = & cfg_st ; char buffer [ BUFSIZE ] ; char * buf = NULL ; char * authfile_dir ; size_t authfile_dir_len ; int pgu_ret , gpn_ret ; int retval = PAM_IGNORE ; device_t * devices = NULL ; unsigned n_devices = 0 ; int openasuser ; int should_free_origin = 0 ; int should_free_appid = 0 ; int should_free_auth_file = 0 ; int should_free_authpending_file = 0 ; parse_cfg ( flags , argc , argv , cfg ) ; if ( ! cfg -> origin ) { strcpy ( buffer , DEFAULT_ORIGIN_PREFIX ) ; if ( gethostname ( buffer + strlen ( DEFAULT_ORIGIN_PREFIX ) , BUFSIZE - strlen ( DEFAULT_ORIGIN_PREFIX ) ) == - 1 ) { DBG ( ""Unable<S2SV_blank>to<S2SV_blank>get<S2SV_blank>host<S2SV_blank>name"" ) ; goto done ; } DBG ( ""Origin<S2SV_blank>not<S2SV_blank>specified,<S2SV_blank>using<S2SV_blank>\\""%s\\"""" , buffer ) ; cfg -> origin = strdup ( buffer ) ; if ( ! cfg -> origin ) { DBG ( ""Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory"" ) ; goto done ; } else { should_free_origin = 1 ; } } if ( ! cfg -> appid ) { DBG ( ""Appid<S2SV_blank>not<S2SV_blank>specified,<S2SV_blank>using<S2SV_blank>the<S2SV_blank>same<S2SV_blank>value<S2SV_blank>of<S2SV_blank>origin<S2SV_blank>(%s)"" , cfg -> origin ) ; cfg -> appid = strdup ( cfg -> origin ) ; if ( ! cfg -> appid ) { DBG ( ""Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory"" ) goto done ; } else { should_free_appid = 1 ; } } if ( cfg -> max_devs == 0 ) { DBG ( ""Maximum<S2SV_blank>devices<S2SV_blank>number<S2SV_blank>not<S2SV_blank>set.<S2SV_blank>Using<S2SV_blank>default<S2SV_blank>(%d)"" , MAX_DEVS ) ; cfg -> max_devs = MAX_DEVS ; } devices = malloc ( sizeof ( device_t ) * cfg -> max_devs ) ; if ( ! devices ) { DBG ( ""Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory"" ) ; retval = PAM_IGNORE ; goto done ; } pgu_ret = pam_get_user ( pamh , & user , NULL ) ; if ( pgu_ret != PAM_SUCCESS || user == NULL ) { DBG ( ""Unable<S2SV_blank>to<S2SV_blank>access<S2SV_blank>user<S2SV_blank>%s"" , user ) ; retval = PAM_CONV_ERR ; goto done ; } DBG ( ""Requesting<S2SV_blank>authentication<S2SV_blank>for<S2SV_blank>user<S2SV_blank>%s"" , user ) ; gpn_ret = getpwnam_r ( user , & pw_s , buffer , sizeof ( buffer ) , & pw ) ; if ( gpn_ret != 0 || pw == NULL || pw -> pw_dir == NULL || pw -> pw_dir [ 0 ] != '/' ) { DBG ( ""Unable<S2SV_blank>to<S2SV_blank>retrieve<S2SV_blank>credentials<S2SV_blank>for<S2SV_blank>user<S2SV_blank>%s,<S2SV_blank>(%s)"" , user , strerror ( errno ) ) ; retval = PAM_USER_UNKNOWN ; goto done ; } DBG ( ""Found<S2SV_blank>user<S2SV_blank>%s"" , user ) ; DBG ( ""Home<S2SV_blank>directory<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>%s"" , user , pw -> pw_dir ) ; if ( ! cfg -> auth_file ) { buf = NULL ; authfile_dir = secure_getenv ( DEFAULT_AUTHFILE_DIR_VAR ) ; if ( ! authfile_dir ) { DBG ( ""Variable<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>set.<S2SV_blank>Using<S2SV_blank>default<S2SV_blank>value<S2SV_blank>($HOME/.config/)"" , DEFAULT_AUTHFILE_DIR_VAR ) ; authfile_dir_len = strlen ( pw -> pw_dir ) + strlen ( ""/.config"" ) + strlen ( DEFAULT_AUTHFILE ) + 1 ; buf = malloc ( sizeof ( char ) * ( authfile_dir_len ) ) ; if ( ! buf ) { DBG ( ""Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory"" ) ; retval = PAM_IGNORE ; goto done ; } snprintf ( buf , authfile_dir_len , ""%s/.config%s"" , pw -> pw_dir , DEFAULT_AUTHFILE ) ; } else { DBG ( ""Variable<S2SV_blank>%s<S2SV_blank>set<S2SV_blank>to<S2SV_blank>%s"" , DEFAULT_AUTHFILE_DIR_VAR , authfile_dir ) ; authfile_dir_len = strlen ( authfile_dir ) + strlen ( DEFAULT_AUTHFILE ) + 1 ; buf = malloc ( sizeof ( char ) * ( authfile_dir_len ) ) ; if ( ! buf ) { DBG ( ""Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory"" ) ; retval = PAM_IGNORE ; goto done ; } snprintf ( buf , authfile_dir_len , ""%s%s"" , authfile_dir , DEFAULT_AUTHFILE ) ; } DBG ( ""Using<S2SV_blank>default<S2SV_blank>authentication<S2SV_blank>file<S2SV_blank>%s"" , buf ) ; cfg -> auth_file = buf ; should_free_auth_file = 1 ; buf = NULL ; } else { DBG ( ""Using<S2SV_blank>authentication<S2SV_blank>file<S2SV_blank>%s"" , cfg -> auth_file ) ; } openasuser = geteuid ( ) == 0 && cfg -> openasuser ; if ( openasuser ) { if ( seteuid ( pw_s . pw_uid ) ) { DBG ( ""Unable<S2SV_blank>to<S2SV_blank>switch<S2SV_blank>user<S2SV_blank>to<S2SV_blank>uid<S2SV_blank>%i"" , pw_s . pw_uid ) ; retval = PAM_IGNORE ; goto done ; } DBG ( ""Switched<S2SV_blank>to<S2SV_blank>uid<S2SV_blank>%i"" , pw_s . pw_uid ) ; } retval = get_devices_from_authfile ( cfg -> auth_file , user , cfg -> max_devs , cfg -> debug , cfg -> debug_file , devices , & n_devices ) ; if ( openasuser ) { if ( seteuid ( 0 ) ) { DBG ( ""Unable<S2SV_blank>to<S2SV_blank>switch<S2SV_blank>back<S2SV_blank>to<S2SV_blank>uid<S2SV_blank>0"" ) ; retval = PAM_IGNORE ; goto done ; } DBG ( ""Switched<S2SV_blank>back<S2SV_blank>to<S2SV_blank>uid<S2SV_blank>0"" ) ; } if ( retval != 1 ) { n_devices = 0 ; } if ( n_devices == 0 ) { if ( cfg -> nouserok ) { DBG ( ""Found<S2SV_blank>no<S2SV_blank>devices<S2SV_blank>but<S2SV_blank>nouserok<S2SV_blank>specified.<S2SV_blank>Skipping<S2SV_blank>authentication"" ) ; retval = PAM_SUCCESS ; goto done ; } else if ( retval != 1 ) { DBG ( ""Unable<S2SV_blank>to<S2SV_blank>get<S2SV_blank>devices<S2SV_blank>from<S2SV_blank>file<S2SV_blank>%s"" , cfg -> auth_file ) ; retval = PAM_AUTHINFO_UNAVAIL ; goto done ; } else { DBG ( ""Found<S2SV_blank>no<S2SV_blank>devices.<S2SV_blank>Aborting."" ) ; retval = PAM_AUTHINFO_UNAVAIL ; goto done ; } } if ( ! cfg -> authpending_file ) { int actual_size = snprintf ( buffer , BUFSIZE , DEFAULT_AUTHPENDING_FILE_PATH , getuid ( ) ) ; if ( actual_size >= 0 && actual_size < BUFSIZE ) { cfg -> authpending_file = strdup ( buffer ) ; } if ( ! cfg -> authpending_file ) { DBG ( ""Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>the<S2SV_blank>authpending_file,<S2SV_blank>touch<S2SV_blank>request<S2SV_blank>notifications<S2SV_blank>will<S2SV_blank>not<S2SV_blank>be<S2SV_blank>emitted"" ) ; } else { should_free_authpending_file = 1 ; } } else { if ( strlen ( cfg -> authpending_file ) == 0 ) { DBG ( ""authpending_file<S2SV_blank>is<S2SV_blank>set<S2SV_blank>to<S2SV_blank>an<S2SV_blank>empty<S2SV_blank>value,<S2SV_blank>touch<S2SV_blank>request<S2SV_blank>notifications<S2SV_blank>will<S2SV_blank>be<S2SV_blank>disabled"" ) ; cfg -> authpending_file = NULL ; } } int authpending_file_descriptor = - 1 ; if ( cfg -> authpending_file ) { DBG ( ""Using<S2SV_blank>file<S2SV_blank>\'%s\'<S2SV_blank>for<S2SV_blank>emitting<S2SV_blank>touch<S2SV_blank>request<S2SV_blank>notifications"" , cfg -> authpending_file ) ; <S2SV_StartBug> authpending_file_descriptor = open ( cfg -> authpending_file , O_RDONLY | O_CREAT , 0664 ) ; <S2SV_EndBug> if ( authpending_file_descriptor < 0 ) { DBG ( ""Unable<S2SV_blank>to<S2SV_blank>emit<S2SV_blank>\'authentication<S2SV_blank>started\'<S2SV_blank>notification<S2SV_blank>by<S2SV_blank>opening<S2SV_blank>the<S2SV_blank>file<S2SV_blank>\'%s\',<S2SV_blank>(%s)"" , cfg -> authpending_file , strerror ( errno ) ) ; } } if ( cfg -> manual == 0 ) { if ( cfg -> interactive ) { converse ( pamh , PAM_PROMPT_ECHO_ON , cfg -> prompt != NULL ? cfg -> prompt : DEFAULT_PROMPT ) ; } retval = do_authentication ( cfg , devices , n_devices , pamh ) ; } else { retval = do_manual_authentication ( cfg , devices , n_devices , pamh ) ; } if ( authpending_file_descriptor >= 0 ) { if ( close ( authpending_file_descriptor ) < 0 ) { DBG ( ""Unable<S2SV_blank>to<S2SV_blank>emit<S2SV_blank>\'authentication<S2SV_blank>stopped\'<S2SV_blank>notification<S2SV_blank>by<S2SV_blank>closing<S2SV_blank>the<S2SV_blank>file<S2SV_blank>\'%s\',<S2SV_blank>(%s)"" , cfg -> authpending_file , strerror ( errno ) ) ; } } if ( retval != 1 ) { DBG ( ""do_authentication<S2SV_blank>returned<S2SV_blank>%d"" , retval ) ; retval = PAM_AUTH_ERR ; goto done ; } retval = PAM_SUCCESS ; done : free_devices ( devices , n_devices ) ; if ( buf ) { free ( buf ) ; buf = NULL ; } if ( should_free_origin ) { free ( ( char * ) cfg -> origin ) ; cfg -> origin = NULL ; } if ( should_free_appid ) { free ( ( char * ) cfg -> appid ) ; cfg -> appid = NULL ; } if ( should_free_auth_file ) { free ( ( char * ) cfg -> auth_file ) ; cfg -> auth_file = NULL ; } if ( should_free_authpending_file ) { free ( ( char * ) cfg -> authpending_file ) ; cfg -> authpending_file = NULL ; } if ( cfg -> alwaysok && retval != PAM_SUCCESS ) { DBG ( ""alwaysok<S2SV_blank>needed<S2SV_blank>(otherwise<S2SV_blank>return<S2SV_blank>with<S2SV_blank>%d)"" , retval ) ; retval = PAM_SUCCESS ; } DBG ( ""done.<S2SV_blank>[%s]"" , pam_strerror ( pamh , retval ) ) ; <S2SV_StartBug> return retval ; <S2SV_EndBug> }",O_RDONLY | O_CREAT | O_CLOEXEC | O_NOFOLLOW | O_NOCTTY <S2SV_ModStart> ) ) ; if ( cfg -> is_custom_debug_file ) { fclose ( cfg -> debug_file ) ; }
836,"static void update_sharpness ( loop_filter_info_n * lfi , int sharpness_lvl ) { int lvl ; for ( lvl = 0 ; lvl <= MAX_LOOP_FILTER ; lvl ++ ) { int block_inside_limit = lvl >> ( ( sharpness_lvl > 0 ) + ( sharpness_lvl > 4 ) ) ; if ( sharpness_lvl > 0 ) { if ( block_inside_limit > ( 9 - sharpness_lvl ) ) block_inside_limit = ( 9 - sharpness_lvl ) ; } if ( block_inside_limit < 1 ) block_inside_limit = 1 ; <S2SV_StartBug> vpx_memset ( lfi -> lfthr [ lvl ] . lim , block_inside_limit , SIMD_WIDTH ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( lfi -> lfthr [ lvl ] . mblim , ( 2 * ( lvl + 2 ) + block_inside_limit ) , <S2SV_EndBug> SIMD_WIDTH ) ; } }",= 1 ; memset <S2SV_ModEnd> ( lfi -> <S2SV_ModStart> SIMD_WIDTH ) ; memset <S2SV_ModEnd> ( lfi ->
837,"static void uipc_check_interrupt_locked ( void ) { if ( SAFE_FD_ISSET ( uipc_main . signal_fds [ 0 ] , & uipc_main . read_set ) ) { char sig_recv = 0 ; <S2SV_StartBug> recv ( uipc_main . signal_fds [ 0 ] , & sig_recv , sizeof ( sig_recv ) , MSG_WAITALL ) ; <S2SV_EndBug> } }","= 0 ; TEMP_FAILURE_RETRY ( <S2SV_ModStart> , MSG_WAITALL ) )"
838,"static unsigned long ioapic_read_indirect ( struct kvm_ioapic * ioapic , unsigned long addr , unsigned long length ) { unsigned long result = 0 ; switch ( ioapic -> ioregsel ) { case IOAPIC_REG_VERSION : result = ( ( ( ( IOAPIC_NUM_PINS - 1 ) & 0xff ) << 16 ) | ( IOAPIC_VERSION_ID & 0xff ) ) ; break ; case IOAPIC_REG_APIC_ID : case IOAPIC_REG_ARB_ID : result = ( ( ioapic -> id & 0xf ) << 24 ) ; break ; default : { u32 redir_index = ( ioapic -> ioregsel - 0x10 ) >> 1 ; u64 redir_content ; <S2SV_StartBug> ASSERT ( redir_index < IOAPIC_NUM_PINS ) ; <S2SV_EndBug> <S2SV_StartBug> redir_content = ioapic -> redirtbl [ redir_index ] . bits ; <S2SV_EndBug> result = ( ioapic -> ioregsel & 0x1 ) ? ( redir_content >> 32 ) & 0xffffffff : redir_content & 0xffffffff ; break ; } } return result ; }",u64 redir_content ; if <S2SV_ModEnd> ( redir_index < <S2SV_ModStart> < IOAPIC_NUM_PINS ) <S2SV_ModEnd> redir_content = ioapic <S2SV_ModStart> ] . bits ; else redir_content = ~ 0ULL
839,"<S2SV_StartBug> void <S2SV_EndBug> crm_send_remote_msg ( void * session , xmlNode * msg , gboolean encrypted ) { <S2SV_StartBug> if ( encrypted ) { <S2SV_EndBug> # ifdef HAVE_GNUTLS_GNUTLS_H cib_send_tls ( session , msg ) ; <S2SV_StartBug> # else <S2SV_EndBug> CRM_ASSERT ( encrypted == FALSE ) ; # endif } else { <S2SV_StartBug> cib_send_plaintext ( GPOINTER_TO_INT ( session ) , msg ) ; <S2SV_EndBug> } <S2SV_StartBug> } <S2SV_EndBug>","<S2SV_null> <S2SV_null> <S2SV_null> int <S2SV_ModEnd> crm_send_remote_msg ( void <S2SV_ModStart> encrypted ) { int rc = - 1 ; char * xml_text = NULL ; int len = 0 ; xml_text = dump_xml_unformatted ( <S2SV_ModEnd> msg ) ; <S2SV_ModStart> msg ) ; if ( xml_text ) { len = strlen ( xml_text ) ; <S2SV_ModEnd> } else { <S2SV_ModStart> } else { crm_err ( ""Invalid<S2SV_blank>XML,<S2SV_blank>can<S2SV_blank>not<S2SV_blank>send<S2SV_blank>msg"" ) ; return - 1 ; } rc = crm_send_remote_msg_raw ( session , xml_text , len , encrypted ) ; if ( rc < 0 ) { goto done ; } rc = crm_send_remote_msg_raw ( session , REMOTE_MSG_TERMINATOR , strlen ( REMOTE_MSG_TERMINATOR ) , encrypted ) ; done : if ( rc < 0 ) { crm_err ( ""Failed<S2SV_blank>to<S2SV_blank>send<S2SV_blank>remote<S2SV_blank>msg,<S2SV_blank>rc<S2SV_blank>=<S2SV_blank>%d"" , rc <S2SV_ModEnd> ) ; } <S2SV_ModStart> ) ; } free ( xml_text ) ; return rc ;"
840,"WORD32 ih264d_video_decode ( iv_obj_t * dec_hdl , void * pv_api_ip , void * pv_api_op ) { dec_struct_t * ps_dec = ( dec_struct_t * ) ( dec_hdl -> pv_codec_handle ) ; WORD32 i4_err_status = 0 ; UWORD8 * pu1_buf = NULL ; WORD32 buflen ; UWORD32 u4_max_ofst , u4_length_of_start_code = 0 ; UWORD32 bytes_consumed = 0 ; UWORD32 cur_slice_is_nonref = 0 ; UWORD32 u4_next_is_aud ; UWORD32 u4_first_start_code_found = 0 ; WORD32 ret = 0 , api_ret_value = IV_SUCCESS ; WORD32 header_data_left = 0 , frame_data_left = 0 ; UWORD8 * pu1_bitstrm_buf ; ivd_video_decode_ip_t * ps_dec_ip ; ivd_video_decode_op_t * ps_dec_op ; ithread_set_name ( ( void * ) ""Parse_thread"" ) ; ps_dec_ip = ( ivd_video_decode_ip_t * ) pv_api_ip ; <S2SV_StartBug> ps_dec_op = ( ivd_video_decode_op_t * ) pv_api_op ; <S2SV_EndBug> ps_dec -> pv_dec_out = ps_dec_op ; if ( ps_dec -> init_done != 1 ) { return IV_FAIL ; } DATA_SYNC ( ) ; if ( 0 == ps_dec -> u1_flushfrm ) { if ( ps_dec_ip -> pv_stream_buffer == NULL ) { ps_dec_op -> u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM ; ps_dec_op -> u4_error_code |= IVD_DEC_FRM_BS_BUF_NULL ; return IV_FAIL ; } if ( ps_dec_ip -> u4_num_Bytes <= 0 ) { ps_dec_op -> u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM ; ps_dec_op -> u4_error_code |= IVD_DEC_NUMBYTES_INV ; return IV_FAIL ; } } ps_dec -> u1_pic_decode_done = 0 ; ps_dec_op -> u4_num_bytes_consumed = 0 ; ps_dec -> ps_out_buffer = NULL ; if ( ps_dec_ip -> u4_size >= offsetof ( ivd_video_decode_ip_t , s_out_buffer ) ) ps_dec -> ps_out_buffer = & ps_dec_ip -> s_out_buffer ; ps_dec -> u4_fmt_conv_cur_row = 0 ; ps_dec -> u4_output_present = 0 ; ps_dec -> s_disp_op . u4_error_code = 1 ; ps_dec -> u4_fmt_conv_num_rows = FMT_CONV_NUM_ROWS ; if ( 0 == ps_dec -> u4_share_disp_buf && ps_dec -> i4_decode_header == 0 ) { UWORD32 i ; if ( ps_dec -> ps_out_buffer -> u4_num_bufs == 0 ) { ps_dec_op -> u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM ; ps_dec_op -> u4_error_code |= IVD_DISP_FRM_ZERO_OP_BUFS ; return IV_FAIL ; } for ( i = 0 ; i < ps_dec -> ps_out_buffer -> u4_num_bufs ; i ++ ) { if ( ps_dec -> ps_out_buffer -> pu1_bufs [ i ] == NULL ) { ps_dec_op -> u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM ; ps_dec_op -> u4_error_code |= IVD_DISP_FRM_OP_BUF_NULL ; return IV_FAIL ; } if ( ps_dec -> ps_out_buffer -> u4_min_out_buf_size [ i ] == 0 ) { ps_dec_op -> u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM ; ps_dec_op -> u4_error_code |= IVD_DISP_FRM_ZERO_OP_BUF_SIZE ; return IV_FAIL ; } } } if ( ps_dec -> u4_total_frames_decoded >= NUM_FRAMES_LIMIT ) { ps_dec_op -> u4_error_code = ERROR_FRAME_LIMIT_OVER ; return IV_FAIL ; } ps_dec -> u4_ts = ps_dec_ip -> u4_ts ; ps_dec_op -> u4_error_code = 0 ; ps_dec_op -> e_pic_type = - 1 ; ps_dec_op -> u4_output_present = 0 ; ps_dec_op -> u4_frame_decoded_flag = 0 ; ps_dec -> i4_frametype = - 1 ; ps_dec -> i4_content_type = - 1 ; { if ( ( TOP_FIELD_ONLY | BOT_FIELD_ONLY ) == ps_dec -> u1_top_bottom_decoded ) { ps_dec -> u1_top_bottom_decoded = 0 ; } } ps_dec -> u4_slice_start_code_found = 0 ; if ( ps_dec -> u1_init_dec_flag == 1 && ps_dec -> u4_share_disp_buf == 1 && ps_dec -> u1_flushfrm == 0 ) { UWORD32 i ; WORD32 disp_avail = 0 , free_id ; for ( i = 0 ; i < ps_dec -> u1_pic_bufs ; i ++ ) { if ( 0 == ps_dec -> u4_disp_buf_mapping [ i ] || 1 == ps_dec -> u4_disp_buf_to_be_freed [ i ] ) { disp_avail = 1 ; break ; } } if ( 0 == disp_avail ) { ps_dec_op -> u4_error_code = IVD_DEC_REF_BUF_NULL ; ps_dec_op -> u4_error_code |= ( 1 << IVD_UNSUPPORTEDPARAM ) ; return ( IV_FAIL ) ; } while ( 1 ) { pic_buffer_t * ps_pic_buf ; ps_pic_buf = ( pic_buffer_t * ) ih264_buf_mgr_get_next_free ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , & free_id ) ; if ( ps_pic_buf == NULL ) { UWORD32 i , display_queued = 0 ; for ( i = 0 ; i < ( MAX_DISP_BUFS_NEW ) ; i ++ ) { if ( 0 != ps_dec -> u4_disp_buf_mapping [ i ] ) { display_queued = 1 ; break ; } } if ( 1 == display_queued ) { ps_dec_op -> u4_error_code = IVD_DEC_REF_BUF_NULL ; ps_dec_op -> u4_error_code |= ( 1 << IVD_UNSUPPORTEDPARAM ) ; return ( IV_FAIL ) ; } } else { if ( 1 == ps_dec -> u4_disp_buf_mapping [ free_id ] ) { ih264_buf_mgr_set_status ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , free_id , BUF_MGR_IO ) ; } else { ih264_buf_mgr_release ( ( buf_mgr_t * ) ps_dec -> pv_pic_buf_mgr , free_id , BUF_MGR_IO ) ; break ; } } } } if ( ps_dec -> u1_flushfrm && ps_dec -> u1_init_dec_flag ) { ih264d_get_next_display_field ( ps_dec , ps_dec -> ps_out_buffer , & ( ps_dec -> s_disp_op ) ) ; if ( 0 == ps_dec -> s_disp_op . u4_error_code ) { ps_dec -> u4_fmt_conv_cur_row = 0 ; ps_dec -> u4_fmt_conv_num_rows = ps_dec -> s_disp_frame_info . u4_y_ht ; ih264d_format_convert ( ps_dec , & ( ps_dec -> s_disp_op ) , ps_dec -> u4_fmt_conv_cur_row , ps_dec -> u4_fmt_conv_num_rows ) ; ps_dec -> u4_fmt_conv_cur_row += ps_dec -> u4_fmt_conv_num_rows ; ps_dec -> u4_output_present = 1 ; } ih264d_release_display_field ( ps_dec , & ( ps_dec -> s_disp_op ) ) ; ps_dec_op -> u4_pic_wd = ( UWORD32 ) ps_dec -> u2_disp_width ; ps_dec_op -> u4_pic_ht = ( UWORD32 ) ps_dec -> u2_disp_height ; ps_dec_op -> u4_new_seq = 0 ; ps_dec_op -> u4_output_present = ps_dec -> u4_output_present ; ps_dec_op -> u4_progressive_frame_flag = ps_dec -> s_disp_op . u4_progressive_frame_flag ; ps_dec_op -> e_output_format = ps_dec -> s_disp_op . e_output_format ; ps_dec_op -> s_disp_frm_buf = ps_dec -> s_disp_op . s_disp_frm_buf ; ps_dec_op -> e4_fld_type = ps_dec -> s_disp_op . e4_fld_type ; ps_dec_op -> u4_ts = ps_dec -> s_disp_op . u4_ts ; ps_dec_op -> u4_disp_buf_id = ps_dec -> s_disp_op . u4_disp_buf_id ; ps_dec_op -> u4_is_ref_flag = - 1 ; ps_dec_op -> e_pic_type = IV_NA_FRAME ; ps_dec_op -> u4_frame_decoded_flag = 0 ; if ( 0 == ps_dec -> s_disp_op . u4_error_code ) { return ( IV_SUCCESS ) ; } else return ( IV_FAIL ) ; } if ( ps_dec -> u1_res_changed == 1 ) { ih264d_init_decoder ( ps_dec ) ; } ps_dec -> u4_prev_nal_skipped = 0 ; ps_dec -> u2_cur_mb_addr = 0 ; ps_dec -> u2_total_mbs_coded = 0 ; ps_dec -> u2_cur_slice_num = 0 ; ps_dec -> cur_dec_mb_num = 0 ; ps_dec -> cur_recon_mb_num = 0 ; ps_dec -> u4_first_slice_in_pic = 2 ; ps_dec -> u1_slice_header_done = 0 ; ps_dec -> u1_dangling_field = 0 ; ps_dec -> u4_dec_thread_created = 0 ; ps_dec -> u4_bs_deblk_thread_created = 0 ; ps_dec -> u4_cur_bs_mb_num = 0 ; DEBUG_THREADS_PRINTF ( ""<S2SV_blank>Starting<S2SV_blank>process<S2SV_blank>call\\n"" ) ; ps_dec -> u4_pic_buf_got = 0 ; do { WORD32 buf_size ; pu1_buf = ( UWORD8 * ) ps_dec_ip -> pv_stream_buffer + ps_dec_op -> u4_num_bytes_consumed ; u4_max_ofst = ps_dec_ip -> u4_num_Bytes - ps_dec_op -> u4_num_bytes_consumed ; if ( ( NULL == ps_dec -> pu1_bits_buf_dynamic ) && ( ps_dec -> i4_header_decoded & 1 ) ) { WORD32 size ; void * pv_buf ; void * pv_mem_ctxt = ps_dec -> pv_mem_ctxt ; size = MAX ( 256000 , ps_dec -> u2_pic_wd * ps_dec -> u2_pic_ht * 3 / 2 ) ; pv_buf = ps_dec -> pf_aligned_alloc ( pv_mem_ctxt , 128 , size ) ; RETURN_IF ( ( NULL == pv_buf ) , IV_FAIL ) ; ps_dec -> pu1_bits_buf_dynamic = pv_buf ; ps_dec -> u4_dynamic_bits_buf_size = size ; } if ( ps_dec -> pu1_bits_buf_dynamic ) { pu1_bitstrm_buf = ps_dec -> pu1_bits_buf_dynamic ; buf_size = ps_dec -> u4_dynamic_bits_buf_size ; } else { pu1_bitstrm_buf = ps_dec -> pu1_bits_buf_static ; buf_size = ps_dec -> u4_static_bits_buf_size ; } u4_next_is_aud = 0 ; buflen = ih264d_find_start_code ( pu1_buf , 0 , u4_max_ofst , & u4_length_of_start_code , & u4_next_is_aud ) ; if ( buflen == - 1 ) buflen = 0 ; buflen = MIN ( buflen , buf_size ) ; bytes_consumed = buflen + u4_length_of_start_code ; ps_dec_op -> u4_num_bytes_consumed += bytes_consumed ; { UWORD8 u1_firstbyte , u1_nal_ref_idc ; if ( ps_dec -> i4_app_skip_mode == IVD_SKIP_B ) { u1_firstbyte = * ( pu1_buf + u4_length_of_start_code ) ; u1_nal_ref_idc = ( UWORD8 ) ( NAL_REF_IDC ( u1_firstbyte ) ) ; if ( u1_nal_ref_idc == 0 ) { cur_slice_is_nonref = 1 ; continue ; } else { if ( 1 == cur_slice_is_nonref ) { ps_dec_op -> u4_num_bytes_consumed -= bytes_consumed ; ps_dec_op -> e_pic_type = IV_B_FRAME ; ps_dec_op -> u4_error_code = IVD_DEC_FRM_SKIPPED ; ps_dec_op -> u4_error_code |= ( 1 << IVD_UNSUPPORTEDPARAM ) ; ps_dec_op -> u4_frame_decoded_flag = 0 ; ps_dec_op -> u4_size = sizeof ( ivd_video_decode_op_t ) ; ih264d_signal_decode_thread ( ps_dec ) ; if ( ps_dec -> u4_num_cores == 3 ) { ih264d_signal_bs_deblk_thread ( ps_dec ) ; } return ( IV_FAIL ) ; } } } } if ( buflen ) { memcpy ( pu1_bitstrm_buf , pu1_buf + u4_length_of_start_code , buflen ) ; if ( ( buflen + 8 ) < buf_size ) { memset ( pu1_bitstrm_buf + buflen , 0 , 8 ) ; } u4_first_start_code_found = 1 ; } else { if ( u4_first_start_code_found == 0 ) { ps_dec -> i4_error_code = ERROR_START_CODE_NOT_FOUND ; ps_dec_op -> u4_error_code |= 1 << IVD_INSUFFICIENTDATA ; if ( ps_dec -> u4_pic_buf_got == 0 ) { ih264d_fill_output_struct_from_context ( ps_dec , ps_dec_op ) ; ps_dec_op -> u4_error_code = ps_dec -> i4_error_code ; ps_dec_op -> u4_frame_decoded_flag = 0 ; return ( IV_FAIL ) ; } else { ps_dec -> u1_pic_decode_done = 1 ; continue ; } } else { frame_data_left = 0 ; continue ; } } ps_dec -> u4_return_to_app = 0 ; ret = ih264d_parse_nal_unit ( dec_hdl , ps_dec_op , pu1_bitstrm_buf , buflen ) ; if ( ret != OK ) { UWORD32 error = ih264d_map_error ( ret ) ; ps_dec_op -> u4_error_code = error | ret ; api_ret_value = IV_FAIL ; if ( ( ret == IVD_RES_CHANGED ) || ( ret == IVD_MEM_ALLOC_FAILED ) || ( ret == ERROR_UNAVAIL_PICBUF_T ) || ( ret == ERROR_UNAVAIL_MVBUF_T ) ) { break ; } if ( ( ret == ERROR_INCOMPLETE_FRAME ) || ( ret == ERROR_DANGLING_FIELD_IN_PIC ) ) { ps_dec_op -> u4_num_bytes_consumed -= bytes_consumed ; api_ret_value = IV_FAIL ; break ; } if ( ret == ERROR_IN_LAST_SLICE_OF_PIC ) { api_ret_value = IV_FAIL ; break ; } } if ( ps_dec -> u4_return_to_app ) { ps_dec_op -> u4_num_bytes_consumed -= bytes_consumed ; ps_dec_op -> u4_error_code = IVD_DEC_FRM_SKIPPED ; ps_dec_op -> u4_error_code |= ( 1 << IVD_UNSUPPORTEDPARAM ) ; ps_dec_op -> u4_frame_decoded_flag = 0 ; ps_dec_op -> u4_size = sizeof ( ivd_video_decode_op_t ) ; ih264d_signal_decode_thread ( ps_dec ) ; if ( ps_dec -> u4_num_cores == 3 ) { ih264d_signal_bs_deblk_thread ( ps_dec ) ; } return ( IV_FAIL ) ; } header_data_left = ( ( ps_dec -> i4_decode_header == 1 ) && ( ps_dec -> i4_header_decoded != 3 ) && ( ps_dec_op -> u4_num_bytes_consumed < ps_dec_ip -> u4_num_Bytes ) ) ; frame_data_left = ( ( ( ps_dec -> i4_decode_header == 0 ) && ( ( ps_dec -> u1_pic_decode_done == 0 ) || ( u4_next_is_aud == 1 ) ) ) && ( ps_dec_op -> u4_num_bytes_consumed < ps_dec_ip -> u4_num_Bytes ) ) ; } while ( ( header_data_left == 1 ) || ( frame_data_left == 1 ) ) ; if ( ( ps_dec -> u4_slice_start_code_found == 1 ) && ( ret != IVD_MEM_ALLOC_FAILED ) && ps_dec -> u2_total_mbs_coded < ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) { WORD32 num_mb_skipped ; WORD32 prev_slice_err ; pocstruct_t temp_poc ; WORD32 ret1 ; num_mb_skipped = ( ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) - ps_dec -> u2_total_mbs_coded ; if ( ps_dec -> u4_first_slice_in_pic && ( ps_dec -> u4_pic_buf_got == 0 ) ) prev_slice_err = 1 ; else prev_slice_err = 2 ; ret1 = ih264d_mark_err_slice_skip ( ps_dec , num_mb_skipped , ps_dec -> u1_nal_unit_type == IDR_SLICE_NAL , ps_dec -> ps_cur_slice -> u2_frame_num , & temp_poc , prev_slice_err ) ; if ( ( ret1 == ERROR_UNAVAIL_PICBUF_T ) || ( ret1 == ERROR_UNAVAIL_MVBUF_T ) ) { return IV_FAIL ; } } if ( ( ret == IVD_RES_CHANGED ) || ( ret == IVD_MEM_ALLOC_FAILED ) || ( ret == ERROR_UNAVAIL_PICBUF_T ) || ( ret == ERROR_UNAVAIL_MVBUF_T ) ) { ih264d_signal_decode_thread ( ps_dec ) ; if ( ps_dec -> u4_num_cores == 3 ) { ih264d_signal_bs_deblk_thread ( ps_dec ) ; } if ( ret == IVD_RES_CHANGED ) { ps_dec_op -> u4_num_bytes_consumed -= bytes_consumed ; } return IV_FAIL ; } if ( ps_dec -> u1_separate_parse ) { if ( ps_dec -> u4_num_cores == 2 ) { if ( ( ps_dec -> u4_nmb_deblk == 0 ) && ( ps_dec -> u4_start_recon_deblk == 1 ) && ( ps_dec -> ps_cur_sps -> u1_mb_aff_flag == 0 ) ) { UWORD32 u4_num_mbs , u4_max_addr ; tfr_ctxt_t s_tfr_ctxt ; tfr_ctxt_t * ps_tfr_cxt = & s_tfr_ctxt ; pad_mgr_t * ps_pad_mgr = & ps_dec -> s_pad_mgr ; u4_max_addr = ( ps_dec -> u2_frm_wd_in_mbs * ps_dec -> u2_frm_ht_in_mbs ) - 1 ; ps_dec -> u4_cur_bs_mb_num = u4_max_addr + 1 ; ih264d_init_deblk_tfr_ctxt ( ps_dec , ps_pad_mgr , ps_tfr_cxt , ps_dec -> u2_frm_wd_in_mbs , 0 ) ; u4_num_mbs = u4_max_addr - ps_dec -> u4_cur_deblk_mb_num + 1 ; DEBUG_PERF_PRINTF ( ""mbs<S2SV_blank>left<S2SV_blank>for<S2SV_blank>deblocking=<S2SV_blank>%d<S2SV_blank>\\n"" , u4_num_mbs ) ; if ( u4_num_mbs != 0 ) ih264d_check_mb_map_deblk ( ps_dec , u4_num_mbs , ps_tfr_cxt , 1 ) ; ps_dec -> u4_start_recon_deblk = 0 ; } } ih264d_signal_decode_thread ( ps_dec ) ; if ( ps_dec -> u4_num_cores == 3 ) { ih264d_signal_bs_deblk_thread ( ps_dec ) ; } } DATA_SYNC ( ) ; if ( ( ps_dec_op -> u4_error_code & 0xff ) != ERROR_DYNAMIC_RESOLUTION_NOT_SUPPORTED ) { ps_dec_op -> u4_pic_wd = ( UWORD32 ) ps_dec -> u2_disp_width ; ps_dec_op -> u4_pic_ht = ( UWORD32 ) ps_dec -> u2_disp_height ; } if ( ps_dec -> i4_header_decoded != 3 ) { ps_dec_op -> u4_error_code |= ( 1 << IVD_INSUFFICIENTDATA ) ; } if ( ps_dec -> i4_decode_header == 1 && ps_dec -> i4_header_decoded != 3 ) { ps_dec_op -> u4_error_code |= ( 1 << IVD_INSUFFICIENTDATA ) ; } if ( ps_dec -> u4_prev_nal_skipped ) { ps_dec_op -> u4_error_code = IVD_DEC_FRM_SKIPPED ; ps_dec_op -> u4_error_code |= ( 1 << IVD_UNSUPPORTEDPARAM ) ; ps_dec_op -> u4_frame_decoded_flag = 0 ; ps_dec_op -> u4_size = sizeof ( ivd_video_decode_op_t ) ; if ( ps_dec -> u4_num_cores == 3 ) { ih264d_signal_bs_deblk_thread ( ps_dec ) ; } return ( IV_FAIL ) ; } if ( ( ps_dec -> u4_slice_start_code_found == 1 ) && ( ERROR_DANGLING_FIELD_IN_PIC != i4_err_status ) ) { if ( ps_dec -> ps_cur_slice -> u1_field_pic_flag ) { if ( 1 == ps_dec -> ps_cur_slice -> u1_bottom_field_flag ) { ps_dec -> u1_top_bottom_decoded |= BOT_FIELD_ONLY ; } else { ps_dec -> u1_top_bottom_decoded |= TOP_FIELD_ONLY ; } } if ( ( ps_dec -> ps_dec_err_status -> u1_err_flag & REJECT_CUR_PIC ) == 0 ) { ret = ih264d_deblock_display ( ps_dec ) ; if ( ret != 0 ) { return IV_FAIL ; } } if ( ps_dec -> i4_header_decoded == 3 ) { ps_dec -> u2_total_mbs_coded = ps_dec -> ps_cur_sps -> u2_max_mb_addr + 1 ; } if ( ps_dec -> ps_cur_slice -> u1_nal_unit_type == IDR_SLICE_NAL ) { ps_dec -> i4_frametype = IV_IDR_FRAME ; } else if ( ps_dec -> i4_pic_type == B_SLICE ) { ps_dec -> i4_frametype = IV_B_FRAME ; } else if ( ps_dec -> i4_pic_type == P_SLICE ) { ps_dec -> i4_frametype = IV_P_FRAME ; } else if ( ps_dec -> i4_pic_type == I_SLICE ) { ps_dec -> i4_frametype = IV_I_FRAME ; } else { H264_DEC_DEBUG_PRINT ( ""Shouldn\'t<S2SV_blank>come<S2SV_blank>here\\n"" ) ; } ps_dec -> i4_content_type = ps_dec -> ps_cur_slice -> u1_field_pic_flag ; ps_dec -> u4_total_frames_decoded = ps_dec -> u4_total_frames_decoded + 2 ; ps_dec -> u4_total_frames_decoded = ps_dec -> u4_total_frames_decoded - ps_dec -> ps_cur_slice -> u1_field_pic_flag ; } if ( ps_dec -> u4_num_cores == 3 ) { ih264d_signal_bs_deblk_thread ( ps_dec ) ; } { if ( ( IVD_DECODE_FRAME_OUT == ps_dec -> e_frm_out_mode ) && ps_dec -> u1_init_dec_flag ) { ih264d_get_next_display_field ( ps_dec , ps_dec -> ps_out_buffer , & ( ps_dec -> s_disp_op ) ) ; if ( 0 == ps_dec -> s_disp_op . u4_error_code ) { ps_dec -> u4_fmt_conv_cur_row = 0 ; ps_dec -> u4_output_present = 1 ; } } ih264d_fill_output_struct_from_context ( ps_dec , ps_dec_op ) ; if ( ps_dec -> u4_output_present && ( ps_dec -> u4_fmt_conv_cur_row < ps_dec -> s_disp_frame_info . u4_y_ht ) ) { ps_dec -> u4_fmt_conv_num_rows = ps_dec -> s_disp_frame_info . u4_y_ht - ps_dec -> u4_fmt_conv_cur_row ; ih264d_format_convert ( ps_dec , & ( ps_dec -> s_disp_op ) , ps_dec -> u4_fmt_conv_cur_row , ps_dec -> u4_fmt_conv_num_rows ) ; ps_dec -> u4_fmt_conv_cur_row += ps_dec -> u4_fmt_conv_num_rows ; } ih264d_release_display_field ( ps_dec , & ( ps_dec -> s_disp_op ) ) ; } if ( ps_dec -> i4_decode_header == 1 && ( ps_dec -> i4_header_decoded & 1 ) == 1 ) { ps_dec_op -> u4_progressive_frame_flag = 1 ; if ( ( NULL != ps_dec -> ps_cur_sps ) && ( 1 == ( ps_dec -> ps_cur_sps -> u1_is_valid ) ) ) { if ( ( 0 == ps_dec -> ps_sps -> u1_frame_mbs_only_flag ) && ( 0 == ps_dec -> ps_sps -> u1_mb_aff_flag ) ) ps_dec_op -> u4_progressive_frame_flag = 0 ; } } DATA_SYNC ( ) ; H264_DEC_DEBUG_PRINT ( ""The<S2SV_blank>num<S2SV_blank>bytes<S2SV_blank>consumed:<S2SV_blank>%d\\n"" , ps_dec_op -> u4_num_bytes_consumed ) ; return api_ret_value ; }",") pv_api_op ; { UWORD32 u4_size ; u4_size = ps_dec_op -> u4_size ; memset ( ps_dec_op , 0 , sizeof ( ivd_video_decode_op_t ) ) ; ps_dec_op -> u4_size = u4_size ; }"
841,"static void perf_event_interrupt ( struct pt_regs * regs ) { int i ; struct cpu_hw_events * cpuhw = & __get_cpu_var ( cpu_hw_events ) ; struct perf_event * event ; unsigned long val ; int found = 0 ; int nmi ; if ( cpuhw -> n_limited ) freeze_limited_counters ( cpuhw , mfspr ( SPRN_PMC5 ) , mfspr ( SPRN_PMC6 ) ) ; perf_read_regs ( regs ) ; nmi = perf_intr_is_nmi ( regs ) ; if ( nmi ) nmi_enter ( ) ; else irq_enter ( ) ; for ( i = 0 ; i < cpuhw -> n_events ; ++ i ) { event = cpuhw -> event [ i ] ; if ( ! event -> hw . idx || is_limited_pmc ( event -> hw . idx ) ) continue ; val = read_pmc ( event -> hw . idx ) ; if ( ( int ) val < 0 ) { found = 1 ; record_and_restart ( event , val , regs , nmi ) ; } } if ( ! found ) { for ( i = 0 ; i < ppmu -> n_counter ; ++ i ) { if ( is_limited_pmc ( i + 1 ) ) continue ; val = read_pmc ( i + 1 ) ; <S2SV_StartBug> if ( ( int ) val < 0 ) <S2SV_EndBug> write_pmc ( i + 1 , 0 ) ; } } write_mmcr0 ( cpuhw , cpuhw -> mmcr [ 0 ] ) ; if ( nmi ) nmi_exit ( ) ; else irq_exit ( ) ; }",; if ( pmc_overflow ( val ) <S2SV_ModEnd> ) write_pmc (
842,"int SMB2_negotiate ( const unsigned int xid , struct cifs_ses * ses ) { struct smb_rqst rqst ; struct smb2_negotiate_req * req ; struct smb2_negotiate_rsp * rsp ; struct kvec iov [ 1 ] ; struct kvec rsp_iov ; int rc = 0 ; int resp_buftype ; struct TCP_Server_Info * server = ses -> server ; int blob_offset , blob_length ; char * security_blob ; int flags = CIFS_NEG_OP ; unsigned int total_len ; cifs_dbg ( FYI , ""Negotiate<S2SV_blank>protocol\\n"" ) ; if ( ! server ) { WARN ( 1 , ""%s:<S2SV_blank>server<S2SV_blank>is<S2SV_blank>NULL!\\n"" , __func__ ) ; return - EIO ; } rc = smb2_plain_req_init ( SMB2_NEGOTIATE , NULL , ( void * * ) & req , & total_len ) ; if ( rc ) return rc ; req -> sync_hdr . SessionId = 0 ; memset ( server -> preauth_sha_hash , 0 , SMB2_PREAUTH_HASH_SIZE ) ; memset ( ses -> preauth_sha_hash , 0 , SMB2_PREAUTH_HASH_SIZE ) ; if ( strcmp ( ses -> server -> vals -> version_string , SMB3ANY_VERSION_STRING ) == 0 ) { req -> Dialects [ 0 ] = cpu_to_le16 ( SMB30_PROT_ID ) ; req -> Dialects [ 1 ] = cpu_to_le16 ( SMB302_PROT_ID ) ; req -> DialectCount = cpu_to_le16 ( 2 ) ; total_len += 4 ; } else if ( strcmp ( ses -> server -> vals -> version_string , SMBDEFAULT_VERSION_STRING ) == 0 ) { req -> Dialects [ 0 ] = cpu_to_le16 ( SMB21_PROT_ID ) ; req -> Dialects [ 1 ] = cpu_to_le16 ( SMB30_PROT_ID ) ; req -> Dialects [ 2 ] = cpu_to_le16 ( SMB302_PROT_ID ) ; req -> Dialects [ 3 ] = cpu_to_le16 ( SMB311_PROT_ID ) ; req -> DialectCount = cpu_to_le16 ( 4 ) ; total_len += 8 ; } else { req -> Dialects [ 0 ] = cpu_to_le16 ( ses -> server -> vals -> protocol_id ) ; req -> DialectCount = cpu_to_le16 ( 1 ) ; total_len += 2 ; } if ( ses -> sign ) req -> SecurityMode = cpu_to_le16 ( SMB2_NEGOTIATE_SIGNING_REQUIRED ) ; else if ( global_secflags & CIFSSEC_MAY_SIGN ) req -> SecurityMode = cpu_to_le16 ( SMB2_NEGOTIATE_SIGNING_ENABLED ) ; else req -> SecurityMode = 0 ; req -> Capabilities = cpu_to_le32 ( ses -> server -> vals -> req_capabilities ) ; if ( ses -> server -> vals -> protocol_id == SMB20_PROT_ID ) memset ( req -> ClientGUID , 0 , SMB2_CLIENT_GUID_SIZE ) ; else { memcpy ( req -> ClientGUID , server -> client_guid , SMB2_CLIENT_GUID_SIZE ) ; if ( ( ses -> server -> vals -> protocol_id == SMB311_PROT_ID ) || ( strcmp ( ses -> server -> vals -> version_string , SMBDEFAULT_VERSION_STRING ) == 0 ) ) assemble_neg_contexts ( req , & total_len ) ; } iov [ 0 ] . iov_base = ( char * ) req ; iov [ 0 ] . iov_len = total_len ; memset ( & rqst , 0 , sizeof ( struct smb_rqst ) ) ; rqst . rq_iov = iov ; rqst . rq_nvec = 1 ; rc = cifs_send_recv ( xid , ses , & rqst , & resp_buftype , flags , & rsp_iov ) ; cifs_small_buf_release ( req ) ; rsp = ( struct smb2_negotiate_rsp * ) rsp_iov . iov_base ; if ( rc == - EOPNOTSUPP ) { cifs_dbg ( VFS , ""Dialect<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>by<S2SV_blank>server.<S2SV_blank>Consider<S2SV_blank>"" ""specifying<S2SV_blank>vers=1.0<S2SV_blank>or<S2SV_blank>vers=2.0<S2SV_blank>on<S2SV_blank>mount<S2SV_blank>for<S2SV_blank>accessing"" ""<S2SV_blank>older<S2SV_blank>servers\\n"" ) ; goto neg_exit ; } else if ( rc != 0 ) goto neg_exit ; if ( strcmp ( ses -> server -> vals -> version_string , SMB3ANY_VERSION_STRING ) == 0 ) { if ( rsp -> DialectRevision == cpu_to_le16 ( SMB20_PROT_ID ) ) { cifs_dbg ( VFS , ""SMB2<S2SV_blank>dialect<S2SV_blank>returned<S2SV_blank>but<S2SV_blank>not<S2SV_blank>requested\\n"" ) ; return - EIO ; } else if ( rsp -> DialectRevision == cpu_to_le16 ( SMB21_PROT_ID ) ) { cifs_dbg ( VFS , ""SMB2.1<S2SV_blank>dialect<S2SV_blank>returned<S2SV_blank>but<S2SV_blank>not<S2SV_blank>requested\\n"" ) ; return - EIO ; } } else if ( strcmp ( ses -> server -> vals -> version_string , SMBDEFAULT_VERSION_STRING ) == 0 ) { if ( rsp -> DialectRevision == cpu_to_le16 ( SMB20_PROT_ID ) ) { cifs_dbg ( VFS , ""SMB2<S2SV_blank>dialect<S2SV_blank>returned<S2SV_blank>but<S2SV_blank>not<S2SV_blank>requested\\n"" ) ; return - EIO ; } else if ( rsp -> DialectRevision == cpu_to_le16 ( SMB21_PROT_ID ) ) { ses -> server -> ops = & smb21_operations ; <S2SV_StartBug> } else if ( rsp -> DialectRevision == cpu_to_le16 ( SMB311_PROT_ID ) ) <S2SV_EndBug> <S2SV_StartBug> ses -> server -> ops = & smb311_operations ; <S2SV_EndBug> } else if ( le16_to_cpu ( rsp -> DialectRevision ) != ses -> server -> vals -> protocol_id ) { cifs_dbg ( VFS , ""Illegal<S2SV_blank>0x%x<S2SV_blank>dialect<S2SV_blank>returned:<S2SV_blank>not<S2SV_blank>requested\\n"" , le16_to_cpu ( rsp -> DialectRevision ) ) ; return - EIO ; } cifs_dbg ( FYI , ""mode<S2SV_blank>0x%x\\n"" , rsp -> SecurityMode ) ; if ( rsp -> DialectRevision == cpu_to_le16 ( SMB20_PROT_ID ) ) cifs_dbg ( FYI , ""negotiated<S2SV_blank>smb2.0<S2SV_blank>dialect\\n"" ) ; else if ( rsp -> DialectRevision == cpu_to_le16 ( SMB21_PROT_ID ) ) cifs_dbg ( FYI , ""negotiated<S2SV_blank>smb2.1<S2SV_blank>dialect\\n"" ) ; else if ( rsp -> DialectRevision == cpu_to_le16 ( SMB30_PROT_ID ) ) cifs_dbg ( FYI , ""negotiated<S2SV_blank>smb3.0<S2SV_blank>dialect\\n"" ) ; else if ( rsp -> DialectRevision == cpu_to_le16 ( SMB302_PROT_ID ) ) cifs_dbg ( FYI , ""negotiated<S2SV_blank>smb3.02<S2SV_blank>dialect\\n"" ) ; else if ( rsp -> DialectRevision == cpu_to_le16 ( SMB311_PROT_ID ) ) cifs_dbg ( FYI , ""negotiated<S2SV_blank>smb3.1.1<S2SV_blank>dialect\\n"" ) ; else { cifs_dbg ( VFS , ""Illegal<S2SV_blank>dialect<S2SV_blank>returned<S2SV_blank>by<S2SV_blank>server<S2SV_blank>0x%x\\n"" , le16_to_cpu ( rsp -> DialectRevision ) ) ; rc = - EIO ; goto neg_exit ; } server -> dialect = le16_to_cpu ( rsp -> DialectRevision ) ; memcpy ( server -> preauth_sha_hash , ses -> preauth_sha_hash , SMB2_PREAUTH_HASH_SIZE ) ; server -> negflavor = CIFS_NEGFLAVOR_EXTENDED ; server -> maxBuf = min_t ( unsigned int , le32_to_cpu ( rsp -> MaxTransactSize ) , SMB2_MAX_BUFFER_SIZE ) ; server -> max_read = le32_to_cpu ( rsp -> MaxReadSize ) ; server -> max_write = le32_to_cpu ( rsp -> MaxWriteSize ) ; server -> sec_mode = le16_to_cpu ( rsp -> SecurityMode ) ; if ( ( server -> sec_mode & SMB2_SEC_MODE_FLAGS_ALL ) != server -> sec_mode ) cifs_dbg ( FYI , ""Server<S2SV_blank>returned<S2SV_blank>unexpected<S2SV_blank>security<S2SV_blank>mode<S2SV_blank>0x%x\\n"" , server -> sec_mode ) ; server -> capabilities = le32_to_cpu ( rsp -> Capabilities ) ; server -> capabilities |= SMB2_NT_FIND | SMB2_LARGE_FILES ; security_blob = smb2_get_data_area_len ( & blob_offset , & blob_length , ( struct smb2_sync_hdr * ) rsp ) ; if ( blob_length == 0 ) { cifs_dbg ( FYI , ""missing<S2SV_blank>security<S2SV_blank>blob<S2SV_blank>on<S2SV_blank>negprot\\n"" ) ; server -> sec_ntlmssp = true ; } rc = cifs_enable_signing ( server , ses -> sign ) ; if ( rc ) goto neg_exit ; if ( blob_length ) { rc = decode_negTokenInit ( security_blob , blob_length , server ) ; if ( rc == 1 ) rc = 0 ; else if ( rc == 0 ) rc = - EIO ; } if ( rsp -> DialectRevision == cpu_to_le16 ( SMB311_PROT_ID ) ) { if ( rsp -> NegotiateContextCount ) rc = smb311_decode_neg_context ( rsp , server , rsp_iov . iov_len ) ; else cifs_dbg ( VFS , ""Missing<S2SV_blank>expected<S2SV_blank>negotiate<S2SV_blank>contexts\\n"" ) ; } neg_exit : free_rsp_buf ( resp_buftype , rsp ) ; return rc ; }",& smb21_operations ; ses -> server -> vals = & smb21_values ; <S2SV_ModStart> SMB311_PROT_ID ) ) { <S2SV_ModStart> & smb311_operations ; ses -> server -> vals = & smb311_values ; }
843,"int hfsplus_set_posix_acl ( struct inode * inode , struct posix_acl * acl , int type ) { int err ; char * xattr_name ; size_t size = 0 ; char * value = NULL ; hfs_dbg ( ACL_MOD , ""[%s]:<S2SV_blank>ino<S2SV_blank>%lu\\n"" , __func__ , inode -> i_ino ) ; switch ( type ) { case ACL_TYPE_ACCESS : xattr_name = XATTR_NAME_POSIX_ACL_ACCESS ; if ( acl ) { <S2SV_StartBug> err = posix_acl_equiv_mode ( acl , & inode -> i_mode ) ; <S2SV_EndBug> if ( err < 0 ) return err ; } err = 0 ; break ; case ACL_TYPE_DEFAULT : xattr_name = XATTR_NAME_POSIX_ACL_DEFAULT ; if ( ! S_ISDIR ( inode -> i_mode ) ) return acl ? - EACCES : 0 ; break ; default : return - EINVAL ; } if ( acl ) { size = posix_acl_xattr_size ( acl -> a_count ) ; if ( unlikely ( size > HFSPLUS_MAX_INLINE_DATA_SIZE ) ) return - ENOMEM ; value = ( char * ) hfsplus_alloc_attr_entry ( ) ; if ( unlikely ( ! value ) ) return - ENOMEM ; err = posix_acl_to_xattr ( & init_user_ns , acl , value , size ) ; if ( unlikely ( err < 0 ) ) goto end_set_acl ; } err = __hfsplus_setxattr ( inode , xattr_name , value , size , 0 ) ; end_set_acl : hfsplus_destroy_attr_entry ( ( hfsplus_attr_entry * ) value ) ; if ( ! err ) set_cached_acl ( inode , type , acl ) ; return err ; }","{ err = posix_acl_update_mode ( inode <S2SV_ModEnd> , & inode <S2SV_ModStart> inode -> i_mode , & acl ) ; if ( err <S2SV_ModEnd> ) return err"
844,"static int picolcd_raw_event ( struct hid_device * hdev , struct hid_report * report , u8 * raw_data , int size ) { struct picolcd_data * data = hid_get_drvdata ( hdev ) ; unsigned long flags ; int ret = 0 ; if ( ! data ) return 1 ; <S2SV_StartBug> if ( report -> id == REPORT_KEY_STATE ) { <S2SV_EndBug> if ( data -> input_keys ) ret = picolcd_raw_keypad ( data , report , raw_data + 1 , size - 1 ) ; } else if ( report -> id == REPORT_IR_DATA ) { ret = picolcd_raw_cir ( data , report , raw_data + 1 , size - 1 ) ; } else { spin_lock_irqsave ( & data -> lock , flags ) ; if ( data -> pending ) { memcpy ( data -> pending -> raw_data , raw_data + 1 , size - 1 ) ; data -> pending -> raw_size = size - 1 ; data -> pending -> in_report = report ; complete ( & data -> pending -> ready ) ; } spin_unlock_irqrestore ( & data -> lock , flags ) ; } picolcd_debug_raw_event ( data , hdev , report , raw_data , size ) ; return 1 ; }","; if ( size > 64 ) { hid_warn ( hdev , ""invalid<S2SV_blank>size<S2SV_blank>value<S2SV_blank>(%d)<S2SV_blank>for<S2SV_blank>picolcd<S2SV_blank>raw<S2SV_blank>event\\n"" , size ) ; return 0 ; } if ("
845,"static struct dst_entry * ip6_sk_dst_check ( struct sock * sk , struct dst_entry * dst , const struct flowi6 * fl6 ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; <S2SV_StartBug> struct rt6_info * rt = ( struct rt6_info * ) dst ; <S2SV_EndBug> if ( ! dst ) <S2SV_StartBug> goto out ; <S2SV_EndBug> if ( ip6_rt_check ( & rt -> rt6i_dst , & fl6 -> daddr , np -> daddr_cache ) || # ifdef CONFIG_IPV6_SUBTREES ip6_rt_check ( & rt -> rt6i_src , & fl6 -> saddr , np -> saddr_cache ) || # endif ( fl6 -> flowi6_oif && fl6 -> flowi6_oif != dst -> dev -> ifindex ) ) { dst_release ( dst ) ; dst = NULL ; } out : return dst ; }",rt6_info * rt <S2SV_ModEnd> ; if ( <S2SV_ModStart> ) goto out ; if ( dst -> ops -> family != AF_INET6 ) { dst_release ( dst ) ; return NULL ; } rt = ( struct rt6_info * ) dst
846,"int x86_decode_insn ( struct x86_emulate_ctxt * ctxt , void * insn , int insn_len ) { int rc = X86EMUL_CONTINUE ; int mode = ctxt -> mode ; int def_op_bytes , def_ad_bytes , goffset , simd_prefix ; bool op_prefix = false ; bool has_seg_override = false ; struct opcode opcode ; ctxt -> memop . type = OP_NONE ; ctxt -> memopp = NULL ; ctxt -> _eip = ctxt -> eip ; ctxt -> fetch . ptr = ctxt -> fetch . data ; ctxt -> fetch . end = ctxt -> fetch . data + insn_len ; ctxt -> opcode_len = 1 ; if ( insn_len > 0 ) memcpy ( ctxt -> fetch . data , insn , insn_len ) ; else { rc = __do_insn_fetch_bytes ( ctxt , 1 ) ; if ( rc != X86EMUL_CONTINUE ) return rc ; } switch ( mode ) { case X86EMUL_MODE_REAL : case X86EMUL_MODE_VM86 : case X86EMUL_MODE_PROT16 : def_op_bytes = def_ad_bytes = 2 ; break ; case X86EMUL_MODE_PROT32 : def_op_bytes = def_ad_bytes = 4 ; break ; # ifdef CONFIG_X86_64 case X86EMUL_MODE_PROT64 : def_op_bytes = 4 ; def_ad_bytes = 8 ; break ; # endif default : return EMULATION_FAILED ; } ctxt -> op_bytes = def_op_bytes ; ctxt -> ad_bytes = def_ad_bytes ; for ( ; ; ) { switch ( ctxt -> b = insn_fetch ( u8 , ctxt ) ) { case 0x66 : op_prefix = true ; ctxt -> op_bytes = def_op_bytes ^ 6 ; break ; case 0x67 : if ( mode == X86EMUL_MODE_PROT64 ) ctxt -> ad_bytes = def_ad_bytes ^ 12 ; else ctxt -> ad_bytes = def_ad_bytes ^ 6 ; break ; case 0x26 : case 0x2e : case 0x36 : case 0x3e : has_seg_override = true ; ctxt -> seg_override = ( ctxt -> b >> 3 ) & 3 ; break ; case 0x64 : case 0x65 : has_seg_override = true ; ctxt -> seg_override = ctxt -> b & 7 ; break ; case 0x40 ... 0x4f : if ( mode != X86EMUL_MODE_PROT64 ) goto done_prefixes ; ctxt -> rex_prefix = ctxt -> b ; continue ; case 0xf0 : ctxt -> lock_prefix = 1 ; break ; case 0xf2 : case 0xf3 : ctxt -> rep_prefix = ctxt -> b ; break ; default : goto done_prefixes ; } ctxt -> rex_prefix = 0 ; } done_prefixes : if ( ctxt -> rex_prefix & 8 ) ctxt -> op_bytes = 8 ; opcode = opcode_table [ ctxt -> b ] ; if ( ctxt -> b == 0x0f ) { ctxt -> opcode_len = 2 ; ctxt -> b = insn_fetch ( u8 , ctxt ) ; opcode = twobyte_table [ ctxt -> b ] ; if ( ctxt -> b == 0x38 ) { ctxt -> opcode_len = 3 ; ctxt -> b = insn_fetch ( u8 , ctxt ) ; opcode = opcode_map_0f_38 [ ctxt -> b ] ; } } ctxt -> d = opcode . flags ; if ( ctxt -> d & ModRM ) ctxt -> modrm = insn_fetch ( u8 , ctxt ) ; if ( ctxt -> opcode_len == 1 && ( ctxt -> b == 0xc5 || ctxt -> b == 0xc4 ) && ( mode == X86EMUL_MODE_PROT64 || ( mode >= X86EMUL_MODE_PROT16 && ( ctxt -> modrm & 0x80 ) ) ) ) { ctxt -> d = NotImpl ; } while ( ctxt -> d & GroupMask ) { switch ( ctxt -> d & GroupMask ) { case Group : goffset = ( ctxt -> modrm >> 3 ) & 7 ; opcode = opcode . u . group [ goffset ] ; break ; case GroupDual : goffset = ( ctxt -> modrm >> 3 ) & 7 ; if ( ( ctxt -> modrm >> 6 ) == 3 ) opcode = opcode . u . gdual -> mod3 [ goffset ] ; else opcode = opcode . u . gdual -> mod012 [ goffset ] ; break ; case RMExt : goffset = ctxt -> modrm & 7 ; opcode = opcode . u . group [ goffset ] ; break ; case Prefix : if ( ctxt -> rep_prefix && op_prefix ) return EMULATION_FAILED ; simd_prefix = op_prefix ? 0x66 : ctxt -> rep_prefix ; switch ( simd_prefix ) { case 0x00 : opcode = opcode . u . gprefix -> pfx_no ; break ; case 0x66 : opcode = opcode . u . gprefix -> pfx_66 ; break ; case 0xf2 : opcode = opcode . u . gprefix -> pfx_f2 ; break ; case 0xf3 : opcode = opcode . u . gprefix -> pfx_f3 ; break ; } break ; case Escape : if ( ctxt -> modrm > 0xbf ) opcode = opcode . u . esc -> high [ ctxt -> modrm - 0xc0 ] ; else opcode = opcode . u . esc -> op [ ( ctxt -> modrm >> 3 ) & 7 ] ; break ; default : return EMULATION_FAILED ; } ctxt -> d &= ~ ( u64 ) GroupMask ; ctxt -> d |= opcode . flags ; } if ( ctxt -> d == 0 ) return EMULATION_FAILED ; ctxt -> execute = opcode . u . execute ; if ( unlikely ( ctxt -> ud ) && likely ( ! ( ctxt -> d & EmulateOnUD ) ) ) return EMULATION_FAILED ; if ( unlikely ( ctxt -> d & ( NotImpl | Stack | Op3264 | Sse | Mmx | Intercept | CheckPerm ) ) ) { ctxt -> check_perm = opcode . check_perm ; ctxt -> intercept = opcode . intercept ; if ( ctxt -> d & NotImpl ) return EMULATION_FAILED ; if ( mode == X86EMUL_MODE_PROT64 && ( ctxt -> d & Stack ) ) ctxt -> op_bytes = 8 ; if ( ctxt -> d & Op3264 ) { if ( mode == X86EMUL_MODE_PROT64 ) ctxt -> op_bytes = 8 ; else ctxt -> op_bytes = 4 ; } if ( ctxt -> d & Sse ) ctxt -> op_bytes = 16 ; else if ( ctxt -> d & Mmx ) ctxt -> op_bytes = 8 ; } if ( ctxt -> d & ModRM ) { rc = decode_modrm ( ctxt , & ctxt -> memop ) ; if ( ! has_seg_override ) { has_seg_override = true ; ctxt -> seg_override = ctxt -> modrm_seg ; } } else if ( ctxt -> d & MemAbs ) rc = decode_abs ( ctxt , & ctxt -> memop ) ; if ( rc != X86EMUL_CONTINUE ) goto done ; if ( ! has_seg_override ) ctxt -> seg_override = VCPU_SREG_DS ; ctxt -> memop . addr . mem . seg = ctxt -> seg_override ; rc = decode_operand ( ctxt , & ctxt -> src , ( ctxt -> d >> SrcShift ) & OpMask ) ; if ( rc != X86EMUL_CONTINUE ) goto done ; rc = decode_operand ( ctxt , & ctxt -> src2 , ( ctxt -> d >> Src2Shift ) & OpMask ) ; if ( rc != X86EMUL_CONTINUE ) goto done ; rc = decode_operand ( ctxt , & ctxt -> dst , ( ctxt -> d >> DstShift ) & OpMask ) ; <S2SV_StartBug> done : <S2SV_EndBug> if ( ctxt -> rip_relative ) <S2SV_StartBug> ctxt -> memopp -> addr . mem . ea += ctxt -> _eip ; <S2SV_EndBug> return ( rc != X86EMUL_CONTINUE ) ? EMULATION_FAILED : EMULATION_OK ; }",OpMask ) ; <S2SV_ModEnd> if ( ctxt <S2SV_ModStart> -> _eip ; done :
847,"static void test_iterators ( ) { <S2SV_StartBug> json_t * object , * foo , * bar , * baz ; <S2SV_EndBug> <S2SV_StartBug> void * iter ; <S2SV_EndBug> if ( json_object_iter ( NULL ) ) fail ( ""able<S2SV_blank>to<S2SV_blank>iterate<S2SV_blank>over<S2SV_blank>NULL"" ) ; if ( json_object_iter_next ( NULL , NULL ) ) fail ( ""able<S2SV_blank>to<S2SV_blank>increment<S2SV_blank>an<S2SV_blank>iterator<S2SV_blank>on<S2SV_blank>a<S2SV_blank>NULL<S2SV_blank>object"" ) ; object = json_object ( ) ; foo = json_string ( ""foo"" ) ; bar = json_string ( ""bar"" ) ; baz = json_string ( ""baz"" ) ; if ( ! object || ! foo || ! bar || ! bar ) fail ( ""unable<S2SV_blank>to<S2SV_blank>create<S2SV_blank>values"" ) ; if ( json_object_iter_next ( object , NULL ) ) fail ( ""able<S2SV_blank>to<S2SV_blank>increment<S2SV_blank>a<S2SV_blank>NULL<S2SV_blank>iterator"" ) ; if ( json_object_set ( object , ""a"" , foo ) || json_object_set ( object , ""b"" , bar ) || json_object_set ( object , ""c"" , baz ) ) fail ( ""unable<S2SV_blank>to<S2SV_blank>populate<S2SV_blank>object"" ) ; iter = json_object_iter ( object ) ; if ( ! iter ) fail ( ""unable<S2SV_blank>to<S2SV_blank>get<S2SV_blank>iterator"" ) ; <S2SV_StartBug> if ( strcmp ( json_object_iter_key ( iter ) , ""a"" ) ) <S2SV_EndBug> fail ( ""iterating<S2SV_blank>failed:<S2SV_blank>wrong<S2SV_blank>key"" ) ; if ( json_object_iter_value ( iter ) != foo ) <S2SV_StartBug> fail ( ""iterating<S2SV_blank>failed:<S2SV_blank>wrong<S2SV_blank>value"" ) ; <S2SV_EndBug> <S2SV_StartBug> iter = json_object_iter_next ( object , iter ) ; <S2SV_EndBug> if ( ! iter ) fail ( ""unable<S2SV_blank>to<S2SV_blank>increment<S2SV_blank>iterator"" ) ; if ( strcmp ( json_object_iter_key ( iter ) , ""b"" ) ) <S2SV_StartBug> fail ( ""iterating<S2SV_blank>failed:<S2SV_blank>wrong<S2SV_blank>key"" ) ; <S2SV_EndBug> <S2SV_StartBug> if ( json_object_iter_value ( iter ) != bar ) <S2SV_EndBug> fail ( ""iterating<S2SV_blank>failed:<S2SV_blank>wrong<S2SV_blank>value"" ) ; iter = json_object_iter_next ( object , iter ) ; if ( ! iter ) fail ( ""unable<S2SV_blank>to<S2SV_blank>increment<S2SV_blank>iterator"" ) ; if ( strcmp ( json_object_iter_key ( iter ) , ""c"" ) ) fail ( ""iterating<S2SV_blank>failed:<S2SV_blank>wrong<S2SV_blank>key"" ) ; <S2SV_StartBug> if ( json_object_iter_value ( iter ) != baz ) <S2SV_EndBug> fail ( ""iterating<S2SV_blank>failed:<S2SV_blank>wrong<S2SV_blank>value"" ) ; if ( json_object_iter_next ( object , iter ) != NULL ) fail ( ""able<S2SV_blank>to<S2SV_blank>iterate<S2SV_blank>over<S2SV_blank>the<S2SV_blank>end"" ) ; if ( json_object_iter_at ( object , ""foo"" ) ) fail ( ""json_object_iter_at()<S2SV_blank>succeeds<S2SV_blank>for<S2SV_blank>non-existent<S2SV_blank>key"" ) ; iter = json_object_iter_at ( object , ""b"" ) ; if ( ! iter ) fail ( ""json_object_iter_at()<S2SV_blank>fails<S2SV_blank>for<S2SV_blank>an<S2SV_blank>existing<S2SV_blank>key"" ) ; if ( strcmp ( json_object_iter_key ( iter ) , ""b"" ) ) fail ( ""iterating<S2SV_blank>failed:<S2SV_blank>wrong<S2SV_blank>key"" ) ; if ( json_object_iter_value ( iter ) != bar ) fail ( ""iterating<S2SV_blank>failed:<S2SV_blank>wrong<S2SV_blank>value"" ) ; iter = json_object_iter_next ( object , iter ) ; if ( ! iter ) fail ( ""unable<S2SV_blank>to<S2SV_blank>increment<S2SV_blank>iterator"" ) ; if ( strcmp ( json_object_iter_key ( iter ) , ""c"" ) ) fail ( ""iterating<S2SV_blank>failed:<S2SV_blank>wrong<S2SV_blank>key"" ) ; if ( json_object_iter_value ( iter ) != baz ) fail ( ""iterating<S2SV_blank>failed:<S2SV_blank>wrong<S2SV_blank>value"" ) ; if ( json_object_iter_set ( object , iter , bar ) ) fail ( ""unable<S2SV_blank>to<S2SV_blank>set<S2SV_blank>value<S2SV_blank>at<S2SV_blank>iterator"" ) ; if ( strcmp ( json_object_iter_key ( iter ) , ""c"" ) ) fail ( ""json_object_iter_key()<S2SV_blank>fails<S2SV_blank>after<S2SV_blank>json_object_iter_set()"" ) ; if ( json_object_iter_value ( iter ) != bar ) fail ( ""json_object_iter_value()<S2SV_blank>fails<S2SV_blank>after<S2SV_blank>json_object_iter_set()"" ) ; if ( json_object_get ( object , ""c"" ) != bar ) fail ( ""json_object_get()<S2SV_blank>fails<S2SV_blank>after<S2SV_blank>json_object_iter_set()"" ) ; json_decref ( object ) ; json_decref ( foo ) ; json_decref ( bar ) ; json_decref ( baz ) ; }","( ) { int i ; <S2SV_ModStart> * baz ; const char * iter_keys [ 3 ] ; int have_key [ 3 ] = { 0 , 0 , 0 } ; json_t * iter_values [ 3 ] ; <S2SV_ModStart> ""unable<S2SV_blank>to<S2SV_blank>get<S2SV_blank>iterator"" ) ; iter_keys [ 0 ] = json_object_iter_key ( iter ) ; iter_values [ 0 ] = json_object_iter_value ( iter ) ; iter = json_object_iter_next ( object , iter ) ; if ( ! iter ) fail ( ""unable<S2SV_blank>to<S2SV_blank>increment<S2SV_blank>iterator"" ) ; iter_keys [ 1 ] = json_object_iter_key ( iter ) ; iter_values [ 1 ] = json_object_iter_value ( iter ) ; iter = json_object_iter_next ( object , iter ) ; if ( ! iter ) fail ( ""unable<S2SV_blank>to<S2SV_blank>increment<S2SV_blank>iterator"" ) ; iter_keys [ 2 ] = json_object_iter_key ( iter ) ; iter_values [ 2 ] = json_object_iter_value ( iter ) ; if ( json_object_iter_next ( object , iter ) != NULL ) fail ( ""able<S2SV_blank>to<S2SV_blank>iterate<S2SV_blank>over<S2SV_blank>the<S2SV_blank>end"" ) ; for ( i = 0 ; i < 3 ; i ++ ) { <S2SV_ModStart> ( strcmp ( iter_keys [ i ] <S2SV_ModEnd> , ""a"" ) <S2SV_ModStart> , ""a"" ) == 0 ) { if ( iter_values [ i ] <S2SV_ModEnd> != foo ) <S2SV_ModStart> ) fail ( ""wrong<S2SV_blank>value<S2SV_blank>for<S2SV_blank>iter<S2SV_blank>key<S2SV_blank>a"" ) ; else have_key [ 0 ] = 1 ; } else if ( strcmp ( iter_keys [ i ] , ""b"" ) == 0 ) { if ( iter_values [ i ] != bar ) fail ( ""wrong<S2SV_blank>value<S2SV_blank>for<S2SV_blank>iter<S2SV_blank>key<S2SV_blank>b"" ) ; else have_key [ 1 ] = 1 ; } else if ( strcmp ( iter_keys [ i ] , ""c"" ) == 0 ) { if ( iter_values [ i ] != baz ) fail ( ""wrong<S2SV_blank>value<S2SV_blank>for<S2SV_blank>iter<S2SV_blank>key<S2SV_blank>c"" ) ; else have_key [ 2 ] = 1 ; } } for ( i = 0 ; i < 3 ; i ++ ) { if ( ! have_key [ i ] ) fail ( ""a<S2SV_blank>key<S2SV_blank>wasn\'t<S2SV_blank>iterated<S2SV_blank>over"" ) ; } if ( json_object_iter_at ( object , ""foo"" ) ) fail ( ""json_object_iter_at()<S2SV_blank>succeeds<S2SV_blank>for<S2SV_blank>non-existent<S2SV_blank>key"" ) ; iter = json_object_iter_at ( object , ""b"" ) ; if ( ! iter ) fail ( ""json_object_iter_at()<S2SV_blank>fails<S2SV_blank>for<S2SV_blank>an<S2SV_blank>existing<S2SV_blank>key"" ) ; if ( strcmp ( json_object_iter_key ( iter ) , ""b"" ) ) fail ( ""iterating<S2SV_blank>failed:<S2SV_blank>wrong<S2SV_blank>key"" ) ; if ( json_object_iter_value ( iter ) != bar ) fail ( <S2SV_ModStart> ""iterating<S2SV_blank>failed:<S2SV_blank>wrong<S2SV_blank>value"" ) ; if ( json_object_iter_set ( object , iter , baz ) ) fail ( ""unable<S2SV_blank>to<S2SV_blank>set<S2SV_blank>value<S2SV_blank>at<S2SV_blank>iterator"" <S2SV_ModEnd> ) ; if <S2SV_ModStart> ) fail ( ""json_object_iter_key()<S2SV_blank>fails<S2SV_blank>after<S2SV_blank>json_object_iter_set()"" <S2SV_ModEnd> ) ; if <S2SV_ModStart> iter ) != baz ) fail ( ""json_object_iter_value()<S2SV_blank>fails<S2SV_blank>after<S2SV_blank>json_object_iter_set()"" ) ; if ( json_object_get ( object , ""b"" <S2SV_ModEnd> ) != baz <S2SV_ModStart> ) != baz <S2SV_ModEnd> ) fail ("
848,"static int cac_get_serial_nr_from_CUID ( sc_card_t * card , sc_serial_number_t * serial ) { cac_private_data_t * priv = CAC_DATA ( card ) ; SC_FUNC_CALLED ( card -> ctx , SC_LOG_DEBUG_NORMAL ) ; if ( card -> serialnr . len ) { * serial = card -> serialnr ; SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_NORMAL , SC_SUCCESS ) ; } if ( priv -> cac_id_len ) { serial -> len = MIN ( priv -> cac_id_len , SC_MAX_SERIALNR ) ; <S2SV_StartBug> memcpy ( serial -> value , priv -> cac_id , priv -> cac_id_len ) ; <S2SV_EndBug> SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_NORMAL , SC_SUCCESS ) ; } SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_NORMAL , SC_ERROR_FILE_NOT_FOUND ) ; }","-> cac_id , serial -> len <S2SV_ModEnd> ) ; SC_FUNC_RETURN"
849,"static int filter_frame ( AVFilterLink * inlink , AVFrame * in ) { PadContext * s = inlink -> dst -> priv ; AVFrame * out ; int needs_copy = frame_needs_copy ( s , in ) ; if ( needs_copy ) { av_log ( inlink -> dst , AV_LOG_DEBUG , ""Direct<S2SV_blank>padding<S2SV_blank>impossible<S2SV_blank>allocating<S2SV_blank>new<S2SV_blank>frame\\n"" ) ; out = ff_get_video_buffer ( inlink -> dst -> outputs [ 0 ] , FFMAX ( inlink -> w , s -> w ) , FFMAX ( inlink -> h , s -> h ) ) ; if ( ! out ) { av_frame_free ( & in ) ; return AVERROR ( ENOMEM ) ; } av_frame_copy_props ( out , in ) ; } else { int i ; out = in ; <S2SV_StartBug> for ( i = 0 ; i < 4 && out -> data [ i ] ; i ++ ) { <S2SV_EndBug> int hsub = s -> draw . hsub [ i ] ; int vsub = s -> draw . vsub [ i ] ; out -> data [ i ] -= ( s -> x >> hsub ) * s -> draw . pixelstep [ i ] + ( s -> y >> vsub ) * out -> linesize [ i ] ; } } if ( s -> y ) { ff_fill_rectangle ( & s -> draw , & s -> color , out -> data , out -> linesize , 0 , 0 , s -> w , s -> y ) ; } if ( s -> h > s -> y + s -> in_h ) { ff_fill_rectangle ( & s -> draw , & s -> color , out -> data , out -> linesize , 0 , s -> y + s -> in_h , s -> w , s -> h - s -> y - s -> in_h ) ; } ff_fill_rectangle ( & s -> draw , & s -> color , out -> data , out -> linesize , 0 , s -> y , s -> x , in -> height ) ; if ( needs_copy ) { ff_copy_rectangle2 ( & s -> draw , out -> data , out -> linesize , in -> data , in -> linesize , s -> x , s -> y , 0 , 0 , in -> width , in -> height ) ; } ff_fill_rectangle ( & s -> draw , & s -> color , out -> data , out -> linesize , s -> x + s -> in_w , s -> y , s -> w - s -> x - s -> in_w , in -> height ) ; out -> width = s -> w ; out -> height = s -> h ; if ( in != out ) av_frame_free ( & in ) ; return ff_filter_frame ( inlink -> dst -> outputs [ 0 ] , out ) ; }",[ i ] && out -> linesize [ i ]
850,"static int handle_exception ( struct kvm_vcpu * vcpu ) { struct vcpu_vmx * vmx = to_vmx ( vcpu ) ; struct kvm_run * kvm_run = vcpu -> run ; u32 intr_info , ex_no , error_code ; unsigned long cr2 , rip , dr6 ; u32 vect_info ; enum emulation_result er ; vect_info = vmx -> idt_vectoring_info ; intr_info = vmx -> exit_intr_info ; if ( is_machine_check ( intr_info ) ) return handle_machine_check ( vcpu ) ; <S2SV_StartBug> if ( ( intr_info & INTR_INFO_INTR_TYPE_MASK ) == INTR_TYPE_NMI_INTR ) <S2SV_EndBug> return 1 ; if ( is_no_device ( intr_info ) ) { vmx_fpu_activate ( vcpu ) ; return 1 ; } if ( is_invalid_opcode ( intr_info ) ) { if ( is_guest_mode ( vcpu ) ) { kvm_queue_exception ( vcpu , UD_VECTOR ) ; return 1 ; } er = emulate_instruction ( vcpu , EMULTYPE_TRAP_UD ) ; if ( er != EMULATE_DONE ) kvm_queue_exception ( vcpu , UD_VECTOR ) ; return 1 ; } error_code = 0 ; if ( intr_info & INTR_INFO_DELIVER_CODE_MASK ) error_code = vmcs_read32 ( VM_EXIT_INTR_ERROR_CODE ) ; if ( ( vect_info & VECTORING_INFO_VALID_MASK ) && ! ( is_page_fault ( intr_info ) && ! ( error_code & PFERR_RSVD_MASK ) ) ) { vcpu -> run -> exit_reason = KVM_EXIT_INTERNAL_ERROR ; vcpu -> run -> internal . suberror = KVM_INTERNAL_ERROR_SIMUL_EX ; vcpu -> run -> internal . ndata = 3 ; vcpu -> run -> internal . data [ 0 ] = vect_info ; vcpu -> run -> internal . data [ 1 ] = intr_info ; vcpu -> run -> internal . data [ 2 ] = error_code ; return 0 ; } if ( is_page_fault ( intr_info ) ) { BUG_ON ( enable_ept ) ; cr2 = vmcs_readl ( EXIT_QUALIFICATION ) ; trace_kvm_page_fault ( cr2 , error_code ) ; if ( kvm_event_needs_reinjection ( vcpu ) ) kvm_mmu_unprotect_page_virt ( vcpu , cr2 ) ; return kvm_mmu_page_fault ( vcpu , cr2 , error_code , NULL , 0 ) ; } ex_no = intr_info & INTR_INFO_VECTOR_MASK ; if ( vmx -> rmode . vm86_active && rmode_exception ( vcpu , ex_no ) ) return handle_rmode_exception ( vcpu , ex_no , error_code ) ; switch ( ex_no ) { case AC_VECTOR : kvm_queue_exception_e ( vcpu , AC_VECTOR , error_code ) ; return 1 ; case DB_VECTOR : dr6 = vmcs_readl ( EXIT_QUALIFICATION ) ; if ( ! ( vcpu -> guest_debug & ( KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP ) ) ) { vcpu -> arch . dr6 &= ~ 15 ; vcpu -> arch . dr6 |= dr6 | DR6_RTM ; if ( ! ( dr6 & ~ DR6_RESERVED ) ) skip_emulated_instruction ( vcpu ) ; kvm_queue_exception ( vcpu , DB_VECTOR ) ; return 1 ; } kvm_run -> debug . arch . dr6 = dr6 | DR6_FIXED_1 ; kvm_run -> debug . arch . dr7 = vmcs_readl ( GUEST_DR7 ) ; case BP_VECTOR : vmx -> vcpu . arch . event_exit_inst_len = vmcs_read32 ( VM_EXIT_INSTRUCTION_LEN ) ; kvm_run -> exit_reason = KVM_EXIT_DEBUG ; rip = kvm_rip_read ( vcpu ) ; kvm_run -> debug . arch . pc = vmcs_readl ( GUEST_CS_BASE ) + rip ; kvm_run -> debug . arch . exception = ex_no ; break ; default : kvm_run -> exit_reason = KVM_EXIT_EXCEPTION ; kvm_run -> ex . exception = ex_no ; kvm_run -> ex . error_code = error_code ; break ; } return 0 ; }",; if ( is_nmi ( intr_info ) <S2SV_ModEnd> ) return 1
851,"static int hybiReadAndDecode ( ws_ctx_t * wsctx , char * dst , int len , int * sockRet , int nInBuf ) { int n ; int i ; int toReturn ; int toDecode ; int bufsize ; int nextRead ; <S2SV_StartBug> unsigned char * data ; <S2SV_EndBug> uint32_t * data32 ; memcpy ( wsctx -> writePos , wsctx -> carryBuf , wsctx -> carrylen ) ; wsctx -> writePos += wsctx -> carrylen ; bufsize = wsctx -> codeBufDecode + ARRAYSIZE ( wsctx -> codeBufDecode ) - wsctx -> writePos - 1 ; ws_dbg ( ""bufsize=%d\\n"" , bufsize ) ; if ( hybiRemaining ( wsctx ) > bufsize ) { nextRead = bufsize ; } else { nextRead = hybiRemaining ( wsctx ) ; } ws_dbg ( ""calling<S2SV_blank>read<S2SV_blank>with<S2SV_blank>buf=%p<S2SV_blank>and<S2SV_blank>len=%d<S2SV_blank>(decodebuf=%p<S2SV_blank>headerLen=%d)\\n"" , wsctx -> writePos , nextRead , wsctx -> codeBufDecode , wsctx -> header . headerLen ) ; if ( nextRead > 0 ) { if ( - 1 == ( n = wsctx -> ctxInfo . readFunc ( wsctx -> ctxInfo . ctxPtr , wsctx -> writePos , nextRead ) ) ) { int olderrno = errno ; rfbErr ( ""%s:<S2SV_blank>read;<S2SV_blank>%s"" , __func__ , strerror ( errno ) ) ; errno = olderrno ; * sockRet = - 1 ; return WS_HYBI_STATE_ERR ; } else if ( n == 0 ) { * sockRet = 0 ; return WS_HYBI_STATE_ERR ; } else { ws_dbg ( ""read<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>from<S2SV_blank>socket;<S2SV_blank>nRead=%d\\n"" , n , wsctx -> nReadPayload ) ; } } else { n = 0 ; } wsctx -> nReadPayload += n ; wsctx -> writePos += n ; if ( hybiRemaining ( wsctx ) == 0 ) { wsctx -> hybiDecodeState = WS_HYBI_STATE_FRAME_COMPLETE ; } toDecode = n + wsctx -> carrylen + nInBuf ; ws_dbg ( ""toDecode=%d<S2SV_blank>from<S2SV_blank>n=%d<S2SV_blank>carrylen=%d<S2SV_blank>headerLen=%d\\n"" , toDecode , n , wsctx -> carrylen , wsctx -> header . headerLen ) ; if ( toDecode < 0 ) { rfbErr ( ""%s:<S2SV_blank>internal<S2SV_blank>error;<S2SV_blank>negative<S2SV_blank>number<S2SV_blank>of<S2SV_blank>bytes<S2SV_blank>to<S2SV_blank>decode:<S2SV_blank>%d"" , __func__ , toDecode ) ; errno = EIO ; * sockRet = - 1 ; return WS_HYBI_STATE_ERR ; } data = ( unsigned char * ) ( wsctx -> writePos - toDecode ) ; <S2SV_StartBug> data32 = ( uint32_t * ) data ; <S2SV_EndBug> for ( i = 0 ; i < ( toDecode >> 2 ) ; i ++ ) { <S2SV_StartBug> data32 [ i ] ^= wsctx -> header . mask . u ; <S2SV_EndBug> } ws_dbg ( ""mask<S2SV_blank>decoding;<S2SV_blank>i=%d<S2SV_blank>toDecode=%d\\n"" , i , toDecode ) ; if ( wsctx -> hybiDecodeState == WS_HYBI_STATE_FRAME_COMPLETE ) { for ( i *= 4 ; i < toDecode ; i ++ ) { data [ i ] ^= wsctx -> header . mask . c [ i % 4 ] ; } wsctx -> carrylen = 0 ; } else { wsctx -> carrylen = toDecode - ( i * 4 ) ; if ( wsctx -> carrylen < 0 || wsctx -> carrylen > ARRAYSIZE ( wsctx -> carryBuf ) ) { rfbErr ( ""%s:<S2SV_blank>internal<S2SV_blank>error,<S2SV_blank>invalid<S2SV_blank>carry<S2SV_blank>over<S2SV_blank>size:<S2SV_blank>carrylen=%d,<S2SV_blank>toDecode=%d,<S2SV_blank>i=%d"" , __func__ , wsctx -> carrylen , toDecode , i ) ; * sockRet = - 1 ; errno = EIO ; return WS_HYBI_STATE_ERR ; } ws_dbg ( ""carrying<S2SV_blank>over<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>from<S2SV_blank>%p<S2SV_blank>to<S2SV_blank>%p\\n"" , wsctx -> carrylen , wsctx -> writePos + ( i * 4 ) , wsctx -> carryBuf ) ; memcpy ( wsctx -> carryBuf , data + ( i * 4 ) , wsctx -> carrylen ) ; wsctx -> writePos -= wsctx -> carrylen ; } toReturn = toDecode - wsctx -> carrylen ; switch ( wsctx -> header . opcode ) { case WS_OPCODE_CLOSE : if ( hybiWsFrameComplete ( wsctx ) ) { * ( wsctx -> writePos ) = '\\0' ; ws_dbg ( ""got<S2SV_blank>close<S2SV_blank>cmd<S2SV_blank>%d,<S2SV_blank>reason<S2SV_blank>%d:<S2SV_blank>%s\\n"" , ( int ) ( wsctx -> writePos - hybiPayloadStart ( wsctx ) ) , WS_NTOH16 ( ( ( uint16_t * ) hybiPayloadStart ( wsctx ) ) [ 0 ] ) , & hybiPayloadStart ( wsctx ) [ 2 ] ) ; errno = ECONNRESET ; * sockRet = - 1 ; return WS_HYBI_STATE_FRAME_COMPLETE ; } else { ws_dbg ( ""got<S2SV_blank>close<S2SV_blank>cmd;<S2SV_blank>waiting<S2SV_blank>for<S2SV_blank>%d<S2SV_blank>more<S2SV_blank>bytes<S2SV_blank>to<S2SV_blank>arrive\\n"" , hybiRemaining ( wsctx ) ) ; * sockRet = - 1 ; errno = EAGAIN ; return WS_HYBI_STATE_CLOSE_REASON_PENDING ; } break ; case WS_OPCODE_TEXT_FRAME : data [ toReturn ] = '\\0' ; ws_dbg ( ""Initiate<S2SV_blank>Base64<S2SV_blank>decoding<S2SV_blank>in<S2SV_blank>%p<S2SV_blank>with<S2SV_blank>max<S2SV_blank>size<S2SV_blank>%d<S2SV_blank>and<S2SV_blank>\'\\\\0\'<S2SV_blank>at<S2SV_blank>%p\\n"" , data , bufsize , data + toReturn ) ; if ( - 1 == ( wsctx -> readlen = rfbBase64PtoN ( ( char * ) data , data , bufsize ) ) ) { rfbErr ( ""%s:<S2SV_blank>Base64<S2SV_blank>decode<S2SV_blank>error;<S2SV_blank>%s\\n"" , __func__ , strerror ( errno ) ) ; } wsctx -> writePos = hybiPayloadStart ( wsctx ) ; break ; case WS_OPCODE_BINARY_FRAME : wsctx -> readlen = toReturn ; wsctx -> writePos = hybiPayloadStart ( wsctx ) ; ws_dbg ( ""set<S2SV_blank>readlen=%d<S2SV_blank>writePos=%p\\n"" , wsctx -> readlen , wsctx -> writePos ) ; break ; default : rfbErr ( ""%s:<S2SV_blank>unhandled<S2SV_blank>opcode<S2SV_blank>%d,<S2SV_blank>b0:<S2SV_blank>%02x,<S2SV_blank>b1:<S2SV_blank>%02x\\n"" , __func__ , ( int ) wsctx -> header . opcode , wsctx -> header . data -> b0 , wsctx -> header . data -> b1 ) ; } wsctx -> readPos = data ; return hybiReturnData ( dst , len , wsctx , sockRet ) ; }","char * data <S2SV_ModEnd> ; memcpy ( <S2SV_ModStart> toDecode ) ; <S2SV_ModEnd> for ( i <S2SV_ModStart> ++ ) { uint32_t tmp ; memcpy ( & tmp , data + i * sizeof ( tmp ) , sizeof ( tmp ) ) ; tmp <S2SV_ModEnd> ^= wsctx -> <S2SV_ModStart> mask . u ; memcpy ( data + i * sizeof ( tmp ) , & tmp , sizeof ( tmp ) )"
852,"static struct dentry * aio_mount ( struct file_system_type * fs_type , int flags , const char * dev_name , void * data ) { static const struct dentry_operations ops = { . d_dname = simple_dname , } ; <S2SV_StartBug> return mount_pseudo ( fs_type , ""aio:"" , NULL , & ops , AIO_RING_MAGIC ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>",", } ; struct dentry * root = <S2SV_ModEnd> mount_pseudo ( fs_type <S2SV_ModStart> AIO_RING_MAGIC ) ; if ( ! IS_ERR ( root ) ) root -> d_sb -> s_iflags |= SB_I_NOEXEC ; return root ;"
