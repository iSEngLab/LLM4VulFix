static void unix_release_sock ( struct sock * sk , int embrion ) { struct unix_sock * u = unix_sk ( sk ) ; struct path path ; struct sock * skpair ; struct sk_buff * skb ; int state ; unix_remove_socket ( sk ) ; unix_state_lock ( sk ) ; sock_orphan ( sk ) ; sk -> sk_shutdown = SHUTDOWN_MASK ; path = u -> path ; u -> path . dentry = NULL ; u -> path . mnt = NULL ; state = sk -> sk_state ; sk -> sk_state = TCP_CLOSE ; unix_state_unlock ( sk ) ; wake_up_interruptible_all ( & u -> peer_wait ) ; skpair = unix_peer ( sk ) ; if ( skpair != NULL ) { if ( sk -> sk_type == SOCK_STREAM || sk -> sk_type == SOCK_SEQPACKET ) { unix_state_lock ( skpair ) ; skpair -> sk_shutdown = SHUTDOWN_MASK ; if ( ! skb_queue_empty ( & sk -> sk_receive_queue ) || embrion ) skpair -> sk_err = ECONNRESET ; unix_state_unlock ( skpair ) ; skpair -> sk_state_change ( skpair ) ; sk_wake_async ( skpair , SOCK_WAKE_WAITD , POLL_HUP ) ; } <S2SV_StartBug> sock_put ( skpair ) ; <S2SV_EndBug> unix_peer ( sk ) = NULL ; } while ( ( skb = skb_dequeue ( & sk -> sk_receive_queue ) ) != NULL ) { if ( state == TCP_LISTEN ) unix_release_sock ( skb -> sk , 1 ) ; UNIXCB ( skb ) . consumed = skb -> len ; kfree_skb ( skb ) ; } if ( path . dentry ) path_put ( & path ) ; sock_put ( sk ) ; if ( unix_tot_inflight ) unix_gc ( ) ; }
static void store_coding_context ( MACROBLOCK * x , PICK_MODE_CONTEXT * ctx , int mode_index , <S2SV_StartBug> int_mv * ref_mv , <S2SV_EndBug> int_mv * second_ref_mv , int64_t comp_pred_diff [ REFERENCE_MODES ] , <S2SV_StartBug> int64_t tx_size_diff [ TX_MODES ] , <S2SV_EndBug> <S2SV_StartBug> int64_t best_filter_diff [ SWITCHABLE_FILTER_CONTEXTS ] ) { <S2SV_EndBug> MACROBLOCKD * const xd = & x -> e_mbd ; ctx -> skip = x -> skip ; <S2SV_StartBug> ctx -> best_mode_index = mode_index ; <S2SV_EndBug> ctx -> mic = * xd -> mi [ 0 ] ; <S2SV_StartBug> ctx -> best_ref_mv [ 0 ] . as_int = ref_mv -> as_int ; <S2SV_EndBug> ctx -> best_ref_mv [ 1 ] . as_int = second_ref_mv -> as_int ; ctx -> single_pred_diff = ( int ) comp_pred_diff [ SINGLE_REFERENCE ] ; ctx -> comp_pred_diff = ( int ) comp_pred_diff [ COMPOUND_REFERENCE ] ; ctx -> hybrid_pred_diff = ( int ) comp_pred_diff [ REFERENCE_MODE_SELECT ] ; <S2SV_StartBug> vpx_memcpy ( ctx -> tx_rd_diff , tx_size_diff , sizeof ( ctx -> tx_rd_diff ) ) ; <S2SV_EndBug> vpx_memcpy ( ctx -> best_filter_diff , best_filter_diff , sizeof ( * best_filter_diff ) * SWITCHABLE_FILTER_CONTEXTS ) ; }
static const u_char * ikev2_auth_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct ikev2_auth a ; const char * v2_auth [ ] = { "invalid" , "rsasig" , "shared-secret" , "dsssig" } ; const u_char * authdata = ( const u_char * ) ext + sizeof ( a ) ; unsigned int len ; <S2SV_StartBug> ND_TCHECK ( * ext ) ; <S2SV_EndBug> UNALIGNED_MEMCPY ( & a , ext , sizeof ( a ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , a . h . critical ) ; len = ntohs ( a . h . len ) ; ND_PRINT ( ( ndo , "<S2SV_blank>len=%u<S2SV_blank>method=%s" , len - 4 , STR_OR_ID ( a . auth_method , v2_auth ) ) ) ; if ( len > 4 ) { if ( ndo -> ndo_vflag > 1 ) { ND_PRINT ( ( ndo , "<S2SV_blank>authdata=(" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) authdata , len - sizeof ( a ) ) ) goto trunc ; ND_PRINT ( ( ndo , ")<S2SV_blank>" ) ) ; } else if ( ndo -> ndo_vflag ) { if ( ! ike_show_somedata ( ndo , authdata , ep ) ) goto trunc ; } } return ( const u_char * ) ext + len ; trunc : ND_PRINT ( ( ndo , "<S2SV_blank>[|%s]" , NPSTR ( tpay ) ) ) ; return NULL ; }
void vp9_encode_frame ( VP9_COMP * cpi ) { VP9_COMMON * const cm = & cpi -> common ; if ( ! frame_is_intra_only ( cm ) ) { if ( ( cm -> ref_frame_sign_bias [ ALTREF_FRAME ] == cm -> ref_frame_sign_bias [ GOLDEN_FRAME ] ) || ( cm -> ref_frame_sign_bias [ ALTREF_FRAME ] == cm -> ref_frame_sign_bias [ LAST_FRAME ] ) ) { <S2SV_StartBug> cm -> allow_comp_inter_inter = 0 ; <S2SV_EndBug> } else { <S2SV_StartBug> cm -> allow_comp_inter_inter = 1 ; <S2SV_EndBug> cm -> comp_fixed_ref = ALTREF_FRAME ; cm -> comp_var_ref [ 0 ] = LAST_FRAME ; cm -> comp_var_ref [ 1 ] = GOLDEN_FRAME ; } } if ( cpi -> sf . frame_parameter_update ) { <S2SV_StartBug> int i ; <S2SV_EndBug> const MV_REFERENCE_FRAME frame_type = get_frame_type ( cpi ) ; <S2SV_StartBug> const int64_t * mode_thresh = cpi -> rd_prediction_type_threshes [ frame_type ] ; <S2SV_EndBug> <S2SV_StartBug> const int64_t * filter_thresh = cpi -> rd_filter_threshes [ frame_type ] ; <S2SV_EndBug> <S2SV_StartBug> if ( frame_type == ALTREF_FRAME || ! cm -> allow_comp_inter_inter ) <S2SV_EndBug> cm -> reference_mode = SINGLE_REFERENCE ; <S2SV_StartBug> else if ( mode_thresh [ COMPOUND_REFERENCE ] > mode_thresh [ SINGLE_REFERENCE ] && <S2SV_EndBug> <S2SV_StartBug> mode_thresh [ COMPOUND_REFERENCE ] > <S2SV_EndBug> <S2SV_StartBug> mode_thresh [ REFERENCE_MODE_SELECT ] && <S2SV_EndBug> check_dual_ref_flags ( cpi ) && cpi -> static_mb_pct == 100 ) cm -> reference_mode = COMPOUND_REFERENCE ; <S2SV_StartBug> else if ( mode_thresh [ SINGLE_REFERENCE ] > mode_thresh [ REFERENCE_MODE_SELECT ] ) <S2SV_EndBug> cm -> reference_mode = SINGLE_REFERENCE ; else cm -> reference_mode = REFERENCE_MODE_SELECT ; <S2SV_StartBug> if ( cm -> interp_filter == SWITCHABLE ) { <S2SV_EndBug> if ( frame_type != ALTREF_FRAME && filter_thresh [ EIGHTTAP_SMOOTH ] > filter_thresh [ EIGHTTAP ] && filter_thresh [ EIGHTTAP_SMOOTH ] > filter_thresh [ EIGHTTAP_SHARP ] && filter_thresh [ EIGHTTAP_SMOOTH ] > filter_thresh [ SWITCHABLE - 1 ] ) { <S2SV_StartBug> cm -> interp_filter = EIGHTTAP_SMOOTH ; <S2SV_EndBug> } else if ( filter_thresh [ EIGHTTAP_SHARP ] > filter_thresh [ EIGHTTAP ] && filter_thresh [ EIGHTTAP_SHARP ] > filter_thresh [ SWITCHABLE - 1 ] ) { cm -> interp_filter = EIGHTTAP_SHARP ; } else if ( filter_thresh [ EIGHTTAP ] > filter_thresh [ SWITCHABLE - 1 ] ) { cm -> interp_filter = EIGHTTAP ; } } encode_frame_internal ( cpi ) ; <S2SV_StartBug> for ( i = 0 ; i < REFERENCE_MODES ; ++ i ) { <S2SV_EndBug> <S2SV_StartBug> const int diff = ( int ) ( cpi -> rd_comp_pred_diff [ i ] / cm -> MBs ) ; <S2SV_EndBug> cpi -> rd_prediction_type_threshes [ frame_type ] [ i ] += diff ; cpi -> rd_prediction_type_threshes [ frame_type ] [ i ] >>= 1 ; } <S2SV_StartBug> for ( i = 0 ; i < SWITCHABLE_FILTER_CONTEXTS ; i ++ ) { <S2SV_EndBug> <S2SV_StartBug> const int64_t diff = cpi -> rd_filter_diff [ i ] / cm -> MBs ; <S2SV_EndBug> cpi -> rd_filter_threshes [ frame_type ] [ i ] = ( cpi -> rd_filter_threshes [ frame_type ] [ i ] + diff ) / 2 ; <S2SV_StartBug> } <S2SV_EndBug> for ( i = 0 ; i < TX_MODES ; ++ i ) { int64_t pd = cpi -> rd_tx_select_diff [ i ] ; int diff ; if ( i == TX_MODE_SELECT ) pd -= RDCOST ( cpi -> mb . rdmult , cpi -> mb . rddiv , 2048 * ( TX_SIZES - 1 ) , 0 ) ; diff = ( int ) ( pd / cm -> MBs ) ; cpi -> rd_tx_select_threshes [ frame_type ] [ i ] += diff ; cpi -> rd_tx_select_threshes [ frame_type ] [ i ] /= 2 ; } if ( cm -> reference_mode == REFERENCE_MODE_SELECT ) { int single_count_zero = 0 ; int comp_count_zero = 0 ; for ( i = 0 ; i < COMP_INTER_CONTEXTS ; i ++ ) { <S2SV_StartBug> single_count_zero += cm -> counts . comp_inter [ i ] [ 0 ] ; <S2SV_EndBug> <S2SV_StartBug> comp_count_zero += cm -> counts . comp_inter [ i ] [ 1 ] ; <S2SV_EndBug> } if ( comp_count_zero == 0 ) { cm -> reference_mode = SINGLE_REFERENCE ; <S2SV_StartBug> vp9_zero ( cm -> counts . comp_inter ) ; <S2SV_EndBug> } else if ( single_count_zero == 0 ) { cm -> reference_mode = COMPOUND_REFERENCE ; <S2SV_StartBug> vp9_zero ( cm -> counts . comp_inter ) ; <S2SV_EndBug> } } if ( cm -> tx_mode == TX_MODE_SELECT ) { int count4x4 = 0 ; int count8x8_lp = 0 , count8x8_8x8p = 0 ; int count16x16_16x16p = 0 , count16x16_lp = 0 ; int count32x32 = 0 ; for ( i = 0 ; i < TX_SIZE_CONTEXTS ; ++ i ) { <S2SV_StartBug> count4x4 += cm -> counts . tx . p32x32 [ i ] [ TX_4X4 ] ; <S2SV_EndBug> <S2SV_StartBug> count4x4 += cm -> counts . tx . p16x16 [ i ] [ TX_4X4 ] ; <S2SV_EndBug> <S2SV_StartBug> count4x4 += cm -> counts . tx . p8x8 [ i ] [ TX_4X4 ] ; <S2SV_EndBug> <S2SV_StartBug> count8x8_lp += cm -> counts . tx . p32x32 [ i ] [ TX_8X8 ] ; <S2SV_EndBug> <S2SV_StartBug> count8x8_lp += cm -> counts . tx . p16x16 [ i ] [ TX_8X8 ] ; <S2SV_EndBug> <S2SV_StartBug> count8x8_8x8p += cm -> counts . tx . p8x8 [ i ] [ TX_8X8 ] ; <S2SV_EndBug> <S2SV_StartBug> count16x16_16x16p += cm -> counts . tx . p16x16 [ i ] [ TX_16X16 ] ; <S2SV_EndBug> <S2SV_StartBug> count16x16_lp += cm -> counts . tx . p32x32 [ i ] [ TX_16X16 ] ; <S2SV_EndBug> <S2SV_StartBug> count32x32 += cm -> counts . tx . p32x32 [ i ] [ TX_32X32 ] ; <S2SV_EndBug> } if ( count4x4 == 0 && count16x16_lp == 0 && count16x16_16x16p == 0 && count32x32 == 0 ) { cm -> tx_mode = ALLOW_8X8 ; <S2SV_StartBug> reset_skip_txfm_size ( cm , TX_8X8 ) ; <S2SV_EndBug> } else if ( count8x8_8x8p == 0 && count16x16_16x16p == 0 && count8x8_lp == 0 && count16x16_lp == 0 && count32x32 == 0 ) { cm -> tx_mode = ONLY_4X4 ; <S2SV_StartBug> reset_skip_txfm_size ( cm , TX_4X4 ) ; <S2SV_EndBug> } else if ( count8x8_lp == 0 && count16x16_lp == 0 && count4x4 == 0 ) { cm -> tx_mode = ALLOW_32X32 ; } else if ( count32x32 == 0 && count8x8_lp == 0 && count4x4 == 0 ) { cm -> tx_mode = ALLOW_16X16 ; <S2SV_StartBug> reset_skip_txfm_size ( cm , TX_16X16 ) ; <S2SV_EndBug> } } } else { cm -> reference_mode = SINGLE_REFERENCE ; <S2SV_StartBug> cm -> interp_filter = SWITCHABLE ; <S2SV_EndBug> encode_frame_internal ( cpi ) ; } }
int input_set_keycode ( struct input_dev * dev , const struct input_keymap_entry * ke ) { unsigned long flags ; unsigned int old_keycode ; int retval ; if ( ke -> keycode > KEY_MAX ) return - EINVAL ; spin_lock_irqsave ( & dev -> event_lock , flags ) ; retval = dev -> setkeycode ( dev , ke , & old_keycode ) ; if ( retval ) goto out ; __clear_bit ( KEY_RESERVED , dev -> keybit ) ; <S2SV_StartBug> if ( test_bit ( EV_KEY , dev -> evbit ) && <S2SV_EndBug> ! is_event_supported ( old_keycode , dev -> keybit , KEY_MAX ) && __test_and_clear_bit ( old_keycode , dev -> key ) ) { struct input_value vals [ ] = { { EV_KEY , old_keycode , 0 } , input_value_sync } ; input_pass_values ( dev , vals , ARRAY_SIZE ( vals ) ) ; } out : spin_unlock_irqrestore ( & dev -> event_lock , flags ) ; return retval ; }
static int pn_recvmsg ( struct kiocb * iocb , struct sock * sk , struct msghdr * msg , size_t len , int noblock , int flags , int * addr_len ) { struct sk_buff * skb = NULL ; struct sockaddr_pn sa ; int rval = - EOPNOTSUPP ; int copylen ; if ( flags & ~ ( MSG_PEEK | MSG_TRUNC | MSG_DONTWAIT | MSG_NOSIGNAL | MSG_CMSG_COMPAT ) ) <S2SV_StartBug> goto out_nofree ; <S2SV_EndBug> if ( addr_len ) * addr_len = sizeof ( sa ) ; skb = skb_recv_datagram ( sk , flags , noblock , & rval ) ; if ( skb == NULL ) goto out_nofree ; pn_skb_get_src_sockaddr ( skb , & sa ) ; copylen = skb -> len ; if ( len < copylen ) { msg -> msg_flags |= MSG_TRUNC ; copylen = len ; } rval = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copylen ) ; if ( rval ) { rval = - EFAULT ; goto out ; } rval = ( flags & MSG_TRUNC ) ? skb -> len : copylen ; <S2SV_StartBug> if ( msg -> msg_name != NULL ) <S2SV_EndBug> <S2SV_StartBug> memcpy ( msg -> msg_name , & sa , sizeof ( struct sockaddr_pn ) ) ; <S2SV_EndBug> out : skb_free_datagram ( sk , skb ) ; out_nofree : return rval ; }
CURLcode Curl_auth_create_plain_message ( struct Curl_easy * data , const char * userp , const char * passwdp , char * * outptr , size_t * outlen ) { CURLcode result ; char * plainauth ; size_t ulen ; size_t plen ; size_t plainlen ; * outlen = 0 ; * outptr = NULL ; ulen = strlen ( userp ) ; plen = strlen ( passwdp ) ; <S2SV_StartBug> if ( ( ulen > SIZE_T_MAX / 2 ) || ( plen > ( SIZE_T_MAX / 2 - 2 ) ) ) <S2SV_EndBug> return CURLE_OUT_OF_MEMORY ; plainlen = 2 * ulen + plen + 2 ; plainauth = malloc ( plainlen ) ; if ( ! plainauth ) return CURLE_OUT_OF_MEMORY ; memcpy ( plainauth , userp , ulen ) ; plainauth [ ulen ] = '\\0' ; memcpy ( plainauth + ulen + 1 , userp , ulen ) ; plainauth [ 2 * ulen + 1 ] = '\\0' ; memcpy ( plainauth + 2 * ulen + 2 , passwdp , plen ) ; result = Curl_base64_encode ( data , plainauth , plainlen , outptr , outlen ) ; free ( plainauth ) ; return result ; }
static void fifo_open ( notify_fifo_t * fifo , int ( * script_exit ) ( thread_t * ) , const char * type ) { int ret ; int sav_errno ; if ( fifo -> name ) { sav_errno = 0 ; if ( ! ( ret = mkfifo ( fifo -> name , S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH ) ) ) fifo -> created_fifo = true ; else { sav_errno = errno ; if ( sav_errno != EEXIST ) log_message ( LOG_INFO , "Unable<S2SV_blank>to<S2SV_blank>create<S2SV_blank>%snotify<S2SV_blank>fifo<S2SV_blank>%s" , type , fifo -> name ) ; } if ( ! sav_errno || sav_errno == EEXIST ) { if ( fifo -> script ) notify_fifo_exec ( master , script_exit , fifo , fifo -> script ) ; <S2SV_StartBug> if ( ( fifo -> fd = open ( fifo -> name , O_RDWR | O_CLOEXEC | O_NONBLOCK ) ) == - 1 ) { <S2SV_EndBug> log_message ( LOG_INFO , "Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%snotify<S2SV_blank>fifo<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>errno<S2SV_blank>%d" , type , fifo -> name , errno ) ; if ( fifo -> created_fifo ) { unlink ( fifo -> name ) ; fifo -> created_fifo = false ; } } } if ( fifo -> fd == - 1 ) { FREE ( fifo -> name ) ; fifo -> name = NULL ; } } }
int socket_create ( uint16_t port ) { int sfd = - 1 ; int yes = 1 ; # ifdef WIN32 WSADATA wsa_data ; if ( ! wsa_init ) { if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsa_data ) != ERROR_SUCCESS ) { fprintf ( stderr , "WSAStartup<S2SV_blank>failed!\\n" ) ; ExitProcess ( - 1 ) ; } wsa_init = 1 ; } # endif struct sockaddr_in saddr ; if ( 0 > ( sfd = socket ( PF_INET , SOCK_STREAM , IPPROTO_TCP ) ) ) { perror ( "socket()" ) ; return - 1 ; } if ( setsockopt ( sfd , SOL_SOCKET , SO_REUSEADDR , ( void * ) & yes , sizeof ( int ) ) == - 1 ) { perror ( "setsockopt()" ) ; socket_close ( sfd ) ; return - 1 ; } # ifdef SO_NOSIGPIPE if ( setsockopt ( sfd , SOL_SOCKET , SO_NOSIGPIPE , ( void * ) & yes , sizeof ( int ) ) == - 1 ) { perror ( "setsockopt()" ) ; socket_close ( sfd ) ; return - 1 ; } # endif memset ( ( void * ) & saddr , 0 , sizeof ( saddr ) ) ; saddr . sin_family = AF_INET ; <S2SV_StartBug> saddr . sin_addr . s_addr = htonl ( INADDR_ANY ) ; <S2SV_EndBug> saddr . sin_port = htons ( port ) ; if ( 0 > bind ( sfd , ( struct sockaddr * ) & saddr , sizeof ( saddr ) ) ) { perror ( "bind()" ) ; socket_close ( sfd ) ; return - 1 ; } if ( listen ( sfd , 1 ) == - 1 ) { perror ( "listen()" ) ; socket_close ( sfd ) ; return - 1 ; } return sfd ; }
static bool dump_fd_info ( const char * dest_filename , char * source_filename , int source_base_ofs , uid_t uid , gid_t gid ) { <S2SV_StartBug> FILE * fp = fopen ( dest_filename , "w" ) ; <S2SV_EndBug> if ( ! fp ) return false ; unsigned fd = 0 ; while ( fd <= 99999 ) { sprintf ( source_filename + source_base_ofs , "fd/%u" , fd ) ; char * name = malloc_readlink ( source_filename ) ; if ( ! name ) break ; fprintf ( fp , "%u:%s\\n" , fd , name ) ; free ( name ) ; sprintf ( source_filename + source_base_ofs , "fdinfo/%u" , fd ) ; fd ++ ; FILE * in = fopen ( source_filename , "r" ) ; if ( ! in ) continue ; char buf [ 128 ] ; while ( fgets ( buf , sizeof ( buf ) - 1 , in ) ) { char * eol = strchrnul ( buf , '\\n' ) ; eol [ 0 ] = '\\n' ; eol [ 1 ] = '\\0' ; fputs ( buf , fp ) ; } fclose ( in ) ; } const int dest_fd = fileno ( fp ) ; if ( fchown ( dest_fd , uid , gid ) < 0 ) { perror_msg ( "Can\'t<S2SV_blank>change<S2SV_blank>\'%s\'<S2SV_blank>ownership<S2SV_blank>to<S2SV_blank>%lu:%lu" , dest_filename , ( long ) uid , ( long ) gid ) ; fclose ( fp ) ; unlink ( dest_filename ) ; return false ; } fclose ( fp ) ; return true ; }
static int forward_search_range ( regex_t * reg , const UChar * str , const UChar * end , UChar * s , UChar * range , UChar * * low , UChar * * high , UChar * * low_prev ) { UChar * p , * pprev = ( UChar * ) NULL ; # ifdef ONIG_DEBUG_SEARCH fprintf ( stderr , "forward_search_range:<S2SV_blank>str:<S2SV_blank>%d,<S2SV_blank>end:<S2SV_blank>%d,<S2SV_blank>s:<S2SV_blank>%d,<S2SV_blank>range:<S2SV_blank>%d\\n" , ( int ) str , ( int ) end , ( int ) s , ( int ) range ) ; # endif p = s ; if ( reg -> dmin > 0 ) { if ( ONIGENC_IS_SINGLEBYTE ( reg -> enc ) ) { p += reg -> dmin ; } else { UChar * q = p + reg -> dmin ; if ( q >= end ) return 0 ; while ( p < q ) p += enclen ( reg -> enc , p ) ; } } retry : switch ( reg -> optimize ) { case ONIG_OPTIMIZE_EXACT : p = slow_search ( reg -> enc , reg -> exact , reg -> exact_end , p , end , range ) ; break ; case ONIG_OPTIMIZE_EXACT_IC : p = slow_search_ic ( reg -> enc , reg -> case_fold_flag , reg -> exact , reg -> exact_end , p , end , range ) ; break ; case ONIG_OPTIMIZE_EXACT_BM : p = bm_search ( reg , reg -> exact , reg -> exact_end , p , end , range ) ; break ; case ONIG_OPTIMIZE_EXACT_BM_NOT_REV : p = bm_search_notrev ( reg , reg -> exact , reg -> exact_end , p , end , range ) ; break ; case ONIG_OPTIMIZE_MAP : p = map_search ( reg -> enc , reg -> map , p , range ) ; break ; } if ( p && p < range ) { if ( p - reg -> dmin < s ) { retry_gate : pprev = p ; p += enclen ( reg -> enc , p ) ; goto retry ; } if ( reg -> sub_anchor ) { UChar * prev ; switch ( reg -> sub_anchor ) { case ANCHOR_BEGIN_LINE : if ( ! ON_STR_BEGIN ( p ) ) { prev = onigenc_get_prev_char_head ( reg -> enc , ( pprev ? pprev : str ) , p ) ; if ( ! ONIGENC_IS_MBC_NEWLINE ( reg -> enc , prev , end ) ) goto retry_gate ; } break ; case ANCHOR_END_LINE : if ( ON_STR_END ( p ) ) { # ifndef USE_NEWLINE_AT_END_OF_STRING_HAS_EMPTY_LINE prev = ( UChar * ) onigenc_get_prev_char_head ( reg -> enc , ( pprev ? pprev : str ) , p ) ; if ( prev && ONIGENC_IS_MBC_NEWLINE ( reg -> enc , prev , end ) ) goto retry_gate ; # endif } else if ( ! ONIGENC_IS_MBC_NEWLINE ( reg -> enc , p , end ) # ifdef USE_CRNL_AS_LINE_TERMINATOR && ! ONIGENC_IS_MBC_CRNL ( reg -> enc , p , end ) # endif ) goto retry_gate ; break ; } } if ( reg -> dmax == 0 ) { * low = p ; if ( low_prev ) { if ( * low > s ) * low_prev = onigenc_get_prev_char_head ( reg -> enc , s , p ) ; else * low_prev = onigenc_get_prev_char_head ( reg -> enc , ( pprev ? pprev : str ) , p ) ; } } else { if ( reg -> dmax != ONIG_INFINITE_DISTANCE ) { <S2SV_StartBug> * low = p - reg -> dmax ; <S2SV_EndBug> if ( * low > s ) { * low = onigenc_get_right_adjust_char_head_with_prev ( reg -> enc , s , * low , ( const UChar * * ) low_prev ) ; if ( low_prev && IS_NULL ( * low_prev ) ) * low_prev = onigenc_get_prev_char_head ( reg -> enc , ( pprev ? pprev : s ) , * low ) ; } else { if ( low_prev ) * low_prev = onigenc_get_prev_char_head ( reg -> enc , <S2SV_StartBug> ( pprev ? pprev : str ) , * low ) ; <S2SV_EndBug> } } } * high = p - reg -> dmin ; # ifdef ONIG_DEBUG_SEARCH fprintf ( stderr , "forward_search_range<S2SV_blank>success:<S2SV_blank>low:<S2SV_blank>%d,<S2SV_blank>high:<S2SV_blank>%d,<S2SV_blank>dmin:<S2SV_blank>%d,<S2SV_blank>dmax:<S2SV_blank>%d\\n" , ( int ) ( * low - str ) , ( int ) ( * high - str ) , reg -> dmin , reg -> dmax ) ; # endif return 1 ; } return 0 ; }
void __kvm_migrate_pit_timer ( struct kvm_vcpu * vcpu ) { struct kvm_pit * pit = vcpu -> kvm -> arch . vpit ; struct hrtimer * timer ; if ( ! kvm_vcpu_is_bsp ( vcpu ) || ! pit ) return ; timer = & pit -> pit_state . timer ; <S2SV_StartBug> if ( hrtimer_cancel ( timer ) ) <S2SV_EndBug> hrtimer_start_expires ( timer , HRTIMER_MODE_ABS ) ; <S2SV_StartBug> } <S2SV_EndBug>
static void set_roi_map ( const vpx_codec_enc_cfg_t * cfg , vpx_codec_ctx_t * codec ) { unsigned int i ; <S2SV_StartBug> vpx_roi_map_t roi = { 0 } ; <S2SV_EndBug> roi . rows = ( cfg -> g_h + 15 ) / 16 ; roi . cols = ( cfg -> g_w + 15 ) / 16 ; roi . delta_q [ 0 ] = 0 ; roi . delta_q [ 1 ] = - 2 ; roi . delta_q [ 2 ] = - 4 ; roi . delta_q [ 3 ] = - 6 ; roi . delta_lf [ 0 ] = 0 ; roi . delta_lf [ 1 ] = 1 ; roi . delta_lf [ 2 ] = 2 ; roi . delta_lf [ 3 ] = 3 ; roi . static_threshold [ 0 ] = 1500 ; roi . static_threshold [ 1 ] = 1000 ; roi . static_threshold [ 2 ] = 500 ; roi . static_threshold [ 3 ] = 0 ; roi . roi_map = ( uint8_t * ) malloc ( roi . rows * roi . cols ) ; for ( i = 0 ; i < roi . rows * roi . cols ; ++ i ) roi . roi_map [ i ] = i % 4 ; if ( vpx_codec_control ( codec , VP8E_SET_ROI_MAP , & roi ) ) die_codec ( codec , "Failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>ROI<S2SV_blank>map" ) ; free ( roi . roi_map ) ; }
<S2SV_StartBug> static const char * parse_object ( cJSON * item , const char * value ) <S2SV_EndBug> { cJSON * child ; if ( * value != '{' ) { <S2SV_StartBug> ep = value ; <S2SV_EndBug> return 0 ; } item -> type = cJSON_Object ; value = skip ( value + 1 ) ; if ( * value == '}' ) <S2SV_StartBug> return value + 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( item -> child = child = cJSON_New_Item ( ) ) ) <S2SV_EndBug> return 0 ; <S2SV_StartBug> if ( ! ( value = skip ( parse_string ( child , skip ( value ) ) ) ) ) <S2SV_EndBug> return 0 ; child -> string = child -> valuestring ; child -> valuestring = 0 ; if ( * value != ':' ) { <S2SV_StartBug> ep = value ; <S2SV_EndBug> return 0 ; } <S2SV_StartBug> if ( ! ( value = skip ( parse_value ( child , skip ( value + 1 ) ) ) ) ) <S2SV_EndBug> return 0 ; while ( * value == ',' ) { cJSON * new_item ; if ( ! ( new_item = cJSON_New_Item ( ) ) ) return 0 ; child -> next = new_item ; new_item -> prev = child ; <S2SV_StartBug> child = new_item ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( value = skip ( parse_string ( child , skip ( value + 1 ) ) ) ) ) <S2SV_EndBug> return 0 ; child -> string = child -> valuestring ; child -> valuestring = 0 ; if ( * value != ':' ) { <S2SV_StartBug> ep = value ; <S2SV_EndBug> return 0 ; } <S2SV_StartBug> if ( ! ( value = skip ( parse_value ( child , skip ( value + 1 ) ) ) ) ) <S2SV_EndBug> return 0 ; } if ( * value == '}' ) <S2SV_StartBug> return value + 1 ; <S2SV_EndBug> ep = value ; return 0 ; }
static int get_siz ( Jpeg2000DecoderContext * s ) { int i ; int ncomponents ; uint32_t log2_chroma_wh = 0 ; const enum AVPixelFormat * possible_fmts = NULL ; int possible_fmts_nb = 0 ; if ( bytestream2_get_bytes_left ( & s -> g ) < 36 ) return AVERROR_INVALIDDATA ; s -> avctx -> profile = bytestream2_get_be16u ( & s -> g ) ; s -> width = bytestream2_get_be32u ( & s -> g ) ; s -> height = bytestream2_get_be32u ( & s -> g ) ; s -> image_offset_x = bytestream2_get_be32u ( & s -> g ) ; s -> image_offset_y = bytestream2_get_be32u ( & s -> g ) ; s -> tile_width = bytestream2_get_be32u ( & s -> g ) ; s -> tile_height = bytestream2_get_be32u ( & s -> g ) ; s -> tile_offset_x = bytestream2_get_be32u ( & s -> g ) ; s -> tile_offset_y = bytestream2_get_be32u ( & s -> g ) ; <S2SV_StartBug> ncomponents = bytestream2_get_be16u ( & s -> g ) ; <S2SV_EndBug> if ( ncomponents <= 0 ) { av_log ( s -> avctx , AV_LOG_ERROR , "Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>components:<S2SV_blank>%d\\n" , s -> ncomponents ) ; return AVERROR_INVALIDDATA ; } if ( ncomponents > 4 ) { avpriv_request_sample ( s -> avctx , "Support<S2SV_blank>for<S2SV_blank>%d<S2SV_blank>components" , s -> ncomponents ) ; return AVERROR_PATCHWELCOME ; } s -> ncomponents = ncomponents ; if ( s -> tile_width <= 0 || s -> tile_height <= 0 ) { av_log ( s -> avctx , AV_LOG_ERROR , "Invalid<S2SV_blank>tile<S2SV_blank>dimension<S2SV_blank>%dx%d.\\n" , s -> tile_width , s -> tile_height ) ; return AVERROR_INVALIDDATA ; } if ( bytestream2_get_bytes_left ( & s -> g ) < 3 * s -> ncomponents ) return AVERROR_INVALIDDATA ; for ( i = 0 ; i < s -> ncomponents ; i ++ ) { uint8_t x = bytestream2_get_byteu ( & s -> g ) ; s -> cbps [ i ] = ( x & 0x7f ) + 1 ; s -> precision = FFMAX ( s -> cbps [ i ] , s -> precision ) ; s -> sgnd [ i ] = ! ! ( x & 0x80 ) ; s -> cdx [ i ] = bytestream2_get_byteu ( & s -> g ) ; s -> cdy [ i ] = bytestream2_get_byteu ( & s -> g ) ; if ( ! s -> cdx [ i ] || s -> cdx [ i ] == 3 || s -> cdx [ i ] > 4 || ! s -> cdy [ i ] || s -> cdy [ i ] == 3 || s -> cdy [ i ] > 4 ) { av_log ( s -> avctx , AV_LOG_ERROR , "Invalid<S2SV_blank>sample<S2SV_blank>separation<S2SV_blank>%d/%d\\n" , s -> cdx [ i ] , s -> cdy [ i ] ) ; return AVERROR_INVALIDDATA ; } log2_chroma_wh |= s -> cdy [ i ] >> 1 << i * 4 | s -> cdx [ i ] >> 1 << i * 4 + 2 ; } s -> numXtiles = ff_jpeg2000_ceildiv ( s -> width - s -> tile_offset_x , s -> tile_width ) ; s -> numYtiles = ff_jpeg2000_ceildiv ( s -> height - s -> tile_offset_y , s -> tile_height ) ; if ( s -> numXtiles * ( uint64_t ) s -> numYtiles > INT_MAX / sizeof ( * s -> tile ) ) { s -> numXtiles = s -> numYtiles = 0 ; return AVERROR ( EINVAL ) ; } s -> tile = av_mallocz_array ( s -> numXtiles * s -> numYtiles , sizeof ( * s -> tile ) ) ; if ( ! s -> tile ) { s -> numXtiles = s -> numYtiles = 0 ; return AVERROR ( ENOMEM ) ; } for ( i = 0 ; i < s -> numXtiles * s -> numYtiles ; i ++ ) { Jpeg2000Tile * tile = s -> tile + i ; tile -> comp = av_mallocz ( s -> ncomponents * sizeof ( * tile -> comp ) ) ; if ( ! tile -> comp ) return AVERROR ( ENOMEM ) ; } s -> avctx -> width = ff_jpeg2000_ceildivpow2 ( s -> width - s -> image_offset_x , s -> reduction_factor ) ; s -> avctx -> height = ff_jpeg2000_ceildivpow2 ( s -> height - s -> image_offset_y , s -> reduction_factor ) ; if ( s -> avctx -> profile == FF_PROFILE_JPEG2000_DCINEMA_2K || s -> avctx -> profile == FF_PROFILE_JPEG2000_DCINEMA_4K ) { possible_fmts = xyz_pix_fmts ; possible_fmts_nb = FF_ARRAY_ELEMS ( xyz_pix_fmts ) ; } else { switch ( s -> colour_space ) { case 16 : possible_fmts = rgb_pix_fmts ; possible_fmts_nb = FF_ARRAY_ELEMS ( rgb_pix_fmts ) ; break ; case 17 : possible_fmts = gray_pix_fmts ; possible_fmts_nb = FF_ARRAY_ELEMS ( gray_pix_fmts ) ; break ; case 18 : possible_fmts = yuv_pix_fmts ; possible_fmts_nb = FF_ARRAY_ELEMS ( yuv_pix_fmts ) ; break ; default : possible_fmts = all_pix_fmts ; possible_fmts_nb = FF_ARRAY_ELEMS ( all_pix_fmts ) ; break ; } } for ( i = 0 ; i < possible_fmts_nb ; ++ i ) { if ( pix_fmt_match ( possible_fmts [ i ] , ncomponents , s -> precision , log2_chroma_wh , s -> pal8 ) ) { s -> avctx -> pix_fmt = possible_fmts [ i ] ; break ; } } if ( s -> avctx -> pix_fmt == AV_PIX_FMT_NONE ) { av_log ( s -> avctx , AV_LOG_ERROR , "Unknown<S2SV_blank>pix_fmt,<S2SV_blank>profile:<S2SV_blank>%d,<S2SV_blank>colour_space:<S2SV_blank>%d,<S2SV_blank>" "components:<S2SV_blank>%d,<S2SV_blank>precision:<S2SV_blank>%d,<S2SV_blank>" "cdx[1]:<S2SV_blank>%d,<S2SV_blank>cdy[1]:<S2SV_blank>%d,<S2SV_blank>cdx[2]:<S2SV_blank>%d,<S2SV_blank>cdy[2]:<S2SV_blank>%d\\n" , s -> avctx -> profile , s -> colour_space , ncomponents , s -> precision , ncomponents > 2 ? s -> cdx [ 1 ] : 0 , ncomponents > 2 ? s -> cdy [ 1 ] : 0 , ncomponents > 2 ? s -> cdx [ 2 ] : 0 , ncomponents > 2 ? s -> cdy [ 2 ] : 0 ) ; } s -> avctx -> bits_per_raw_sample = s -> precision ; return 0 ; }
static void addArgumentToVtab ( Parse * pParse ) { if ( pParse -> sArg . z && pParse -> pNewTable ) { const char * z = ( const char * ) pParse -> sArg . z ; int n = pParse -> sArg . n ; sqlite3 * db = pParse -> db ; <S2SV_StartBug> addModuleArgument ( db , pParse -> pNewTable , sqlite3DbStrNDup ( db , z , n ) ) ; <S2SV_EndBug> } }
static av_cold int xpm_decode_close ( AVCodecContext * avctx ) { XPMDecContext * x = avctx -> priv_data ; av_freep ( & x -> pixels ) ; <S2SV_StartBug> return 0 ; <S2SV_EndBug> }
static void write_version ( FILE * fp , const char * fname , const char * dirname , xref_t * xref ) { long start ; char * c , * new_fname , data ; FILE * new_fp ; start = ftell ( fp ) ; if ( ( c = strstr ( fname , ".pdf" ) ) ) * c = '\\0' ; <S2SV_StartBug> new_fname = malloc ( strlen ( fname ) + strlen ( dirname ) + 16 ) ; <S2SV_EndBug> snprintf ( new_fname , strlen ( fname ) + strlen ( dirname ) + 16 , "%s/%s-version-%d.pdf" , dirname , fname , xref -> version ) ; if ( ! ( new_fp = fopen ( new_fname , "w" ) ) ) { ERR ( "Could<S2SV_blank>not<S2SV_blank>create<S2SV_blank>file<S2SV_blank>\'%s\'\\n" , new_fname ) ; fseek ( fp , start , SEEK_SET ) ; free ( new_fname ) ; return ; } fseek ( fp , 0 , SEEK_SET ) ; while ( fread ( & data , 1 , 1 , fp ) ) fwrite ( & data , 1 , 1 , new_fp ) ; fprintf ( new_fp , "\\r\\nstartxref\\r\\n%ld\\r\\n%%%%EOF" , xref -> start ) ; fclose ( new_fp ) ; free ( new_fname ) ; fseek ( fp , start , SEEK_SET ) ; }
static int follow_dotdot_rcu ( struct nameidata * nd ) { struct inode * inode = nd -> inode ; if ( ! nd -> root . mnt ) set_root_rcu ( nd ) ; while ( 1 ) { if ( path_equal ( & nd -> path , & nd -> root ) ) break ; if ( nd -> path . dentry != nd -> path . mnt -> mnt_root ) { struct dentry * old = nd -> path . dentry ; struct dentry * parent = old -> d_parent ; unsigned seq ; inode = parent -> d_inode ; seq = read_seqcount_begin ( & parent -> d_seq ) ; if ( unlikely ( read_seqcount_retry ( & old -> d_seq , nd -> seq ) ) ) return - ECHILD ; nd -> path . dentry = parent ; nd -> seq = seq ; <S2SV_StartBug> break ; <S2SV_EndBug> } else { struct mount * mnt = real_mount ( nd -> path . mnt ) ; struct mount * mparent = mnt -> mnt_parent ; struct dentry * mountpoint = mnt -> mnt_mountpoint ; struct inode * inode2 = mountpoint -> d_inode ; unsigned seq = read_seqcount_begin ( & mountpoint -> d_seq ) ; if ( unlikely ( read_seqretry ( & mount_lock , nd -> m_seq ) ) ) return - ECHILD ; if ( & mparent -> mnt == nd -> path . mnt ) break ; nd -> path . dentry = mountpoint ; nd -> path . mnt = & mparent -> mnt ; inode = inode2 ; nd -> seq = seq ; } } while ( unlikely ( d_mountpoint ( nd -> path . dentry ) ) ) { struct mount * mounted ; mounted = __lookup_mnt ( nd -> path . mnt , nd -> path . dentry ) ; if ( unlikely ( read_seqretry ( & mount_lock , nd -> m_seq ) ) ) return - ECHILD ; if ( ! mounted ) break ; nd -> path . mnt = & mounted -> mnt ; nd -> path . dentry = mounted -> mnt . mnt_root ; inode = nd -> path . dentry -> d_inode ; nd -> seq = read_seqcount_begin ( & nd -> path . dentry -> d_seq ) ; } nd -> inode = inode ; return 0 ; }
static int crypto_report_akcipher ( struct sk_buff * skb , struct crypto_alg * alg ) { struct crypto_report_akcipher rakcipher ; <S2SV_StartBug> strlcpy ( rakcipher . type , "akcipher" , sizeof ( rakcipher . type ) ) ; <S2SV_EndBug> if ( nla_put ( skb , CRYPTOCFGA_REPORT_AKCIPHER , sizeof ( struct crypto_report_akcipher ) , & rakcipher ) ) goto nla_put_failure ; return 0 ; nla_put_failure : return - EMSGSIZE ; }
<S2SV_StartBug> void imap_quote_string ( char * dest , size_t dlen , const char * src ) <S2SV_EndBug> { static const char quote [ ] = "\\"\\\\" ; char * pt = dest ; const char * s = src ; * pt ++ = \'"\' ; dlen -= 2 ; for ( ; * s && dlen ; s ++ ) { if ( strchr ( quote , * s ) ) { dlen -= 2 ; if ( dlen == 0 ) break ; * pt ++ = '\\\\' ; * pt ++ = * s ; } else { * pt ++ = * s ; dlen -- ; } } * pt ++ = \'"\' ; * pt = '\\0' ; }
int sshkey_load_file ( int fd , struct sshbuf * blob ) { u_char buf [ 1024 ] ; size_t len ; struct stat st ; <S2SV_StartBug> int r ; <S2SV_EndBug> if ( fstat ( fd , & st ) < 0 ) return SSH_ERR_SYSTEM_ERROR ; if ( ( st . st_mode & ( S_IFSOCK | S_IFCHR | S_IFIFO ) ) == 0 && st . st_size > MAX_KEY_FILE_SIZE ) return SSH_ERR_INVALID_FORMAT ; <S2SV_StartBug> for ( ; ; ) { <S2SV_EndBug> if ( ( len = atomicio ( read , fd , buf , sizeof ( buf ) ) ) == 0 ) { if ( errno == EPIPE ) break ; r = SSH_ERR_SYSTEM_ERROR ; goto out ; } if ( ( r = sshbuf_put ( blob , buf , len ) ) != 0 ) goto out ; if ( sshbuf_len ( blob ) > MAX_KEY_FILE_SIZE ) { r = SSH_ERR_INVALID_FORMAT ; goto out ; } } if ( ( st . st_mode & ( S_IFSOCK | S_IFCHR | S_IFIFO ) ) == 0 && st . st_size != ( off_t ) sshbuf_len ( blob ) ) { r = SSH_ERR_FILE_CHANGED ; goto out ; } r = 0 ; out : explicit_bzero ( buf , sizeof ( buf ) ) ; if ( r != 0 ) sshbuf_reset ( blob ) ; return r ; }
static int snd_compress_check_input ( struct snd_compr_params * params ) { if ( params -> buffer . fragment_size == 0 || <S2SV_StartBug> params -> buffer . fragments > SIZE_MAX / params -> buffer . fragment_size ) <S2SV_EndBug> return - EINVAL ; if ( params -> codec . id == 0 || params -> codec . id > SND_AUDIOCODEC_MAX ) return - EINVAL ; if ( params -> codec . ch_in == 0 || params -> codec . ch_out == 0 ) return - EINVAL ; return 0 ; }
static void resize_multistep ( const uint8_t * const input , int length , uint8_t * output , int olength , uint8_t * buf ) { int steps ; if ( length == olength ) { <S2SV_StartBug> memcpy ( output , input , sizeof ( uint8_t ) * length ) ; <S2SV_EndBug> return ; } steps = get_down2_steps ( length , olength ) ; if ( steps > 0 ) { int s ; uint8_t * out = NULL ; uint8_t * tmpbuf = NULL ; uint8_t * otmp , * otmp2 ; int filteredlength = length ; if ( ! tmpbuf ) { tmpbuf = ( uint8_t * ) malloc ( sizeof ( uint8_t ) * length ) ; otmp = tmpbuf ; } else { otmp = buf ; } otmp2 = otmp + get_down2_length ( length , 1 ) ; for ( s = 0 ; s < steps ; ++ s ) { const int proj_filteredlength = get_down2_length ( filteredlength , 1 ) ; const uint8_t * const in = ( s == 0 ? input : out ) ; if ( s == steps - 1 && proj_filteredlength == olength ) out = output ; else out = ( s & 1 ? otmp2 : otmp ) ; if ( filteredlength & 1 ) down2_symodd ( in , filteredlength , out ) ; else down2_symeven ( in , filteredlength , out ) ; filteredlength = proj_filteredlength ; } if ( filteredlength != olength ) { interpolate ( out , filteredlength , output , olength ) ; } if ( tmpbuf ) free ( tmpbuf ) ; } else { interpolate ( input , length , output , olength ) ; } }
static void kvmclock_reset ( struct kvm_vcpu * vcpu ) { <S2SV_StartBug> if ( vcpu -> arch . time_page ) { <S2SV_EndBug> kvm_release_page_dirty ( vcpu -> arch . time_page ) ; vcpu -> arch . time_page = NULL ; } }
static long ion_ioctl ( struct file * filp , unsigned int cmd , unsigned long arg ) { struct ion_client * client = filp -> private_data ; struct ion_device * dev = client -> dev ; struct ion_handle * cleanup_handle = NULL ; int ret = 0 ; unsigned int dir ; union { struct ion_fd_data fd ; struct ion_allocation_data allocation ; struct ion_handle_data handle ; struct ion_custom_data custom ; } data ; dir = ion_ioctl_dir ( cmd ) ; if ( _IOC_SIZE ( cmd ) > sizeof ( data ) ) return - EINVAL ; if ( dir & _IOC_WRITE ) if ( copy_from_user ( & data , ( void __user * ) arg , _IOC_SIZE ( cmd ) ) ) return - EFAULT ; switch ( cmd ) { case ION_IOC_ALLOC : { struct ion_handle * handle ; handle = ion_alloc ( client , data . allocation . len , data . allocation . align , data . allocation . heap_id_mask , data . allocation . flags ) ; if ( IS_ERR ( handle ) ) return PTR_ERR ( handle ) ; data . allocation . handle = handle -> id ; cleanup_handle = handle ; break ; } case ION_IOC_FREE : { struct ion_handle * handle ; <S2SV_StartBug> handle = ion_handle_get_by_id ( client , data . handle . handle ) ; <S2SV_EndBug> <S2SV_StartBug> if ( IS_ERR ( handle ) ) <S2SV_EndBug> return PTR_ERR ( handle ) ; <S2SV_StartBug> ion_free ( client , handle ) ; <S2SV_EndBug> ion_handle_put ( handle ) ; break ; } case ION_IOC_SHARE : case ION_IOC_MAP : { struct ion_handle * handle ; handle = ion_handle_get_by_id ( client , data . handle . handle ) ; if ( IS_ERR ( handle ) ) return PTR_ERR ( handle ) ; data . fd . fd = ion_share_dma_buf_fd ( client , handle ) ; ion_handle_put ( handle ) ; if ( data . fd . fd < 0 ) ret = data . fd . fd ; break ; } case ION_IOC_IMPORT : { struct ion_handle * handle ; handle = ion_import_dma_buf_fd ( client , data . fd . fd ) ; if ( IS_ERR ( handle ) ) ret = PTR_ERR ( handle ) ; else data . handle . handle = handle -> id ; break ; } case ION_IOC_SYNC : { ret = ion_sync_for_device ( client , data . fd . fd ) ; break ; } case ION_IOC_CUSTOM : { if ( ! dev -> custom_ioctl ) return - ENOTTY ; ret = dev -> custom_ioctl ( client , data . custom . cmd , data . custom . arg ) ; break ; } default : return - ENOTTY ; } if ( dir & _IOC_READ ) { if ( copy_to_user ( ( void __user * ) arg , & data , _IOC_SIZE ( cmd ) ) ) { if ( cleanup_handle ) ion_free ( client , cleanup_handle ) ; return - EFAULT ; } } return ret ; }
void oz_usb_rx ( struct oz_pd * pd , struct oz_elt * elt ) { struct oz_usb_hdr * usb_hdr = ( struct oz_usb_hdr * ) ( elt + 1 ) ; struct oz_usb_ctx * usb_ctx ; spin_lock_bh ( & pd -> app_lock [ OZ_APPID_USB ] ) ; usb_ctx = ( struct oz_usb_ctx * ) pd -> app_ctx [ OZ_APPID_USB ] ; if ( usb_ctx ) oz_usb_get ( usb_ctx ) ; spin_unlock_bh ( & pd -> app_lock [ OZ_APPID_USB ] ) ; if ( usb_ctx == NULL ) return ; if ( usb_ctx -> stopped ) goto done ; if ( usb_hdr -> elt_seq_num != 0 ) { if ( ( ( usb_ctx -> rx_seq_num - usb_hdr -> elt_seq_num ) & 0x80 ) == 0 ) goto done ; } usb_ctx -> rx_seq_num = usb_hdr -> elt_seq_num ; switch ( usb_hdr -> type ) { case OZ_GET_DESC_RSP : { struct oz_get_desc_rsp * body = ( struct oz_get_desc_rsp * ) usb_hdr ; <S2SV_StartBug> int data_len = elt -> length - <S2SV_EndBug> <S2SV_StartBug> sizeof ( struct oz_get_desc_rsp ) + 1 ; <S2SV_EndBug> u16 offs = le16_to_cpu ( get_unaligned ( & body -> offset ) ) ; u16 total_size = le16_to_cpu ( get_unaligned ( & body -> total_size ) ) ; oz_dbg ( ON , "USB_REQ_GET_DESCRIPTOR<S2SV_blank>-<S2SV_blank>cnf\\n" ) ; oz_hcd_get_desc_cnf ( usb_ctx -> hport , body -> req_id , body -> rcode , body -> data , data_len , offs , total_size ) ; } break ; case OZ_SET_CONFIG_RSP : { struct oz_set_config_rsp * body = ( struct oz_set_config_rsp * ) usb_hdr ; oz_hcd_control_cnf ( usb_ctx -> hport , body -> req_id , body -> rcode , NULL , 0 ) ; } break ; case OZ_SET_INTERFACE_RSP : { struct oz_set_interface_rsp * body = ( struct oz_set_interface_rsp * ) usb_hdr ; oz_hcd_control_cnf ( usb_ctx -> hport , body -> req_id , body -> rcode , NULL , 0 ) ; } break ; case OZ_VENDOR_CLASS_RSP : { struct oz_vendor_class_rsp * body = ( struct oz_vendor_class_rsp * ) usb_hdr ; oz_hcd_control_cnf ( usb_ctx -> hport , body -> req_id , body -> rcode , body -> data , elt -> length - sizeof ( struct oz_vendor_class_rsp ) + 1 ) ; } break ; case OZ_USB_ENDPOINT_DATA : oz_usb_handle_ep_data ( usb_ctx , usb_hdr , elt -> length ) ; break ; } done : oz_usb_put ( usb_ctx ) ; }
xmlChar * xmlStringLenDecodeEntities ( xmlParserCtxtPtr ctxt , const xmlChar * str , int len , int what , xmlChar end , xmlChar end2 , xmlChar end3 ) { xmlChar * buffer = NULL ; int buffer_size = 0 ; xmlChar * current = NULL ; xmlChar * rep = NULL ; const xmlChar * last ; xmlEntityPtr ent ; int c , l ; int nbchars = 0 ; if ( ( ctxt == NULL ) || ( str == NULL ) || ( len < 0 ) ) return ( NULL ) ; last = str + len ; if ( ( ( ctxt -> depth > 40 ) && ( ( ctxt -> options & XML_PARSE_HUGE ) == 0 ) ) || ( ctxt -> depth > 1024 ) ) { xmlFatalErr ( ctxt , XML_ERR_ENTITY_LOOP , NULL ) ; return ( NULL ) ; } buffer_size = XML_PARSER_BIG_BUFFER_SIZE ; buffer = ( xmlChar * ) xmlMallocAtomic ( buffer_size * sizeof ( xmlChar ) ) ; if ( buffer == NULL ) goto mem_error ; if ( str < last ) c = CUR_SCHAR ( str , l ) ; else c = 0 ; while ( ( c != 0 ) && ( c != end ) && ( c != end2 ) && ( c != end3 ) ) { if ( c == 0 ) break ; if ( ( c == '&' ) && ( str [ 1 ] == '#' ) ) { int val = xmlParseStringCharRef ( ctxt , & str ) ; if ( val != 0 ) { COPY_BUF ( 0 , buffer , nbchars , val ) ; } if ( nbchars > buffer_size - XML_PARSER_BUFFER_SIZE ) { growBuffer ( buffer , XML_PARSER_BUFFER_SIZE ) ; } } else if ( ( c == '&' ) && ( what & XML_SUBSTITUTE_REF ) ) { if ( xmlParserDebugEntities ) xmlGenericError ( xmlGenericErrorContext , "String<S2SV_blank>decoding<S2SV_blank>Entity<S2SV_blank>Reference:<S2SV_blank>%.30s\\n" , str ) ; ent = xmlParseStringEntityRef ( ctxt , & str ) ; if ( ( ctxt -> lastError . code == XML_ERR_ENTITY_LOOP ) || ( ctxt -> lastError . code == XML_ERR_INTERNAL_ERROR ) ) goto int_error ; if ( ent != NULL ) ctxt -> nbentities += ent -> checked ; if ( ( ent != NULL ) && ( ent -> etype == XML_INTERNAL_PREDEFINED_ENTITY ) ) { if ( ent -> content != NULL ) { COPY_BUF ( 0 , buffer , nbchars , ent -> content [ 0 ] ) ; if ( nbchars > buffer_size - XML_PARSER_BUFFER_SIZE ) { growBuffer ( buffer , XML_PARSER_BUFFER_SIZE ) ; } } else { xmlFatalErrMsg ( ctxt , XML_ERR_INTERNAL_ERROR , "predefined<S2SV_blank>entity<S2SV_blank>has<S2SV_blank>no<S2SV_blank>content\\n" ) ; } } else if ( ( ent != NULL ) && ( ent -> content != NULL ) ) { ctxt -> depth ++ ; rep = xmlStringDecodeEntities ( ctxt , ent -> content , what , 0 , 0 , 0 ) ; ctxt -> depth -- ; if ( rep != NULL ) { current = rep ; while ( * current != 0 ) { buffer [ nbchars ++ ] = * current ++ ; if ( nbchars > buffer_size - XML_PARSER_BUFFER_SIZE ) { if ( xmlParserEntityCheck ( ctxt , nbchars , ent ) ) goto int_error ; growBuffer ( buffer , XML_PARSER_BUFFER_SIZE ) ; } } xmlFree ( rep ) ; rep = NULL ; } } else if ( ent != NULL ) { int i = xmlStrlen ( ent -> name ) ; const xmlChar * cur = ent -> name ; buffer [ nbchars ++ ] = '&' ; if ( nbchars > buffer_size - i - XML_PARSER_BUFFER_SIZE ) { <S2SV_StartBug> growBuffer ( buffer , XML_PARSER_BUFFER_SIZE ) ; <S2SV_EndBug> } for ( ; i > 0 ; i -- ) buffer [ nbchars ++ ] = * cur ++ ; buffer [ nbchars ++ ] = ';' ; } } else if ( c == '%' && ( what & XML_SUBSTITUTE_PEREF ) ) { if ( xmlParserDebugEntities ) xmlGenericError ( xmlGenericErrorContext , "String<S2SV_blank>decoding<S2SV_blank>PE<S2SV_blank>Reference:<S2SV_blank>%.30s\\n" , str ) ; ent = xmlParseStringPEReference ( ctxt , & str ) ; if ( ctxt -> lastError . code == XML_ERR_ENTITY_LOOP ) goto int_error ; if ( ent != NULL ) ctxt -> nbentities += ent -> checked ; if ( ent != NULL ) { if ( ent -> content == NULL ) { xmlLoadEntityContent ( ctxt , ent ) ; } ctxt -> depth ++ ; rep = xmlStringDecodeEntities ( ctxt , ent -> content , what , 0 , 0 , 0 ) ; ctxt -> depth -- ; if ( rep != NULL ) { current = rep ; while ( * current != 0 ) { buffer [ nbchars ++ ] = * current ++ ; if ( nbchars > buffer_size - XML_PARSER_BUFFER_SIZE ) { if ( xmlParserEntityCheck ( ctxt , nbchars , ent ) ) goto int_error ; growBuffer ( buffer , XML_PARSER_BUFFER_SIZE ) ; } } xmlFree ( rep ) ; rep = NULL ; } } } else { COPY_BUF ( l , buffer , nbchars , c ) ; str += l ; if ( nbchars > buffer_size - XML_PARSER_BUFFER_SIZE ) { growBuffer ( buffer , XML_PARSER_BUFFER_SIZE ) ; } } if ( str < last ) c = CUR_SCHAR ( str , l ) ; else c = 0 ; } buffer [ nbchars ] = 0 ; return ( buffer ) ; mem_error : xmlErrMemory ( ctxt , NULL ) ; int_error : if ( rep != NULL ) xmlFree ( rep ) ; if ( buffer != NULL ) xmlFree ( buffer ) ; return ( NULL ) ; }
unsigned paravirt_patch_jmp ( void * insnbuf , const void * target , unsigned long addr , unsigned len ) { struct branch * b = insnbuf ; unsigned long delta = ( unsigned long ) target - ( addr + 5 ) ; <S2SV_StartBug> if ( len < 5 ) <S2SV_EndBug> <S2SV_StartBug> return len ; <S2SV_EndBug> b -> opcode = 0xe9 ; b -> delta = delta ; return 5 ; }
static int parse_packet ( sockent_t * se , void * buffer , size_t buffer_size , int flags , const char * username ) { int status ; value_list_t vl = VALUE_LIST_INIT ; notification_t n ; # if HAVE_LIBGCRYPT int packet_was_signed = ( flags & PP_SIGNED ) ; int packet_was_encrypted = ( flags & PP_ENCRYPTED ) ; int printed_ignore_warning = 0 ; # endif memset ( & vl , '\\0' , sizeof ( vl ) ) ; memset ( & n , '\\0' , sizeof ( n ) ) ; status = 0 ; while ( ( status == 0 ) && ( 0 < buffer_size ) && ( ( unsigned int ) buffer_size > sizeof ( part_header_t ) ) ) { uint16_t pkg_length ; uint16_t pkg_type ; memcpy ( ( void * ) & pkg_type , ( void * ) buffer , sizeof ( pkg_type ) ) ; memcpy ( ( void * ) & pkg_length , ( void * ) ( buffer + sizeof ( pkg_type ) ) , sizeof ( pkg_length ) ) ; pkg_length = ntohs ( pkg_length ) ; pkg_type = ntohs ( pkg_type ) ; if ( pkg_length > buffer_size ) break ; if ( pkg_length < ( 2 * sizeof ( uint16_t ) ) ) break ; if ( pkg_type == TYPE_ENCR_AES256 ) { status = parse_part_encr_aes256 ( se , & buffer , & buffer_size , flags ) ; if ( status != 0 ) { ERROR ( "network<S2SV_blank>plugin:<S2SV_blank>Decrypting<S2SV_blank>AES256<S2SV_blank>" "part<S2SV_blank>failed<S2SV_blank>" "with<S2SV_blank>status<S2SV_blank>%i." , status ) ; break ; } } # if HAVE_LIBGCRYPT else if ( ( se -> data . server . security_level == SECURITY_LEVEL_ENCRYPT ) && ( packet_was_encrypted == 0 ) ) { if ( printed_ignore_warning == 0 ) { INFO ( "network<S2SV_blank>plugin:<S2SV_blank>Unencrypted<S2SV_blank>packet<S2SV_blank>or<S2SV_blank>" "part<S2SV_blank>has<S2SV_blank>been<S2SV_blank>ignored." ) ; printed_ignore_warning = 1 ; } buffer = ( ( char * ) buffer ) + pkg_length ; <S2SV_StartBug> continue ; <S2SV_EndBug> } # endif else if ( pkg_type == TYPE_SIGN_SHA256 ) { status = parse_part_sign_sha256 ( se , & buffer , & buffer_size , flags ) ; if ( status != 0 ) { ERROR ( "network<S2SV_blank>plugin:<S2SV_blank>Verifying<S2SV_blank>HMAC-SHA-256<S2SV_blank>" "signature<S2SV_blank>failed<S2SV_blank>" "with<S2SV_blank>status<S2SV_blank>%i." , status ) ; break ; } } # if HAVE_LIBGCRYPT else if ( ( se -> data . server . security_level == SECURITY_LEVEL_SIGN ) && ( packet_was_encrypted == 0 ) && ( packet_was_signed == 0 ) ) { if ( printed_ignore_warning == 0 ) { INFO ( "network<S2SV_blank>plugin:<S2SV_blank>Unsigned<S2SV_blank>packet<S2SV_blank>or<S2SV_blank>" "part<S2SV_blank>has<S2SV_blank>been<S2SV_blank>ignored." ) ; printed_ignore_warning = 1 ; } buffer = ( ( char * ) buffer ) + pkg_length ; <S2SV_StartBug> continue ; <S2SV_EndBug> } # endif else if ( pkg_type == TYPE_VALUES ) { status = parse_part_values ( & buffer , & buffer_size , & vl . values , & vl . values_len ) ; if ( status != 0 ) break ; network_dispatch_values ( & vl , username ) ; sfree ( vl . values ) ; } else if ( pkg_type == TYPE_TIME ) { uint64_t tmp = 0 ; status = parse_part_number ( & buffer , & buffer_size , & tmp ) ; if ( status == 0 ) { vl . time = TIME_T_TO_CDTIME_T ( tmp ) ; n . time = TIME_T_TO_CDTIME_T ( tmp ) ; } } else if ( pkg_type == TYPE_TIME_HR ) { uint64_t tmp = 0 ; status = parse_part_number ( & buffer , & buffer_size , & tmp ) ; if ( status == 0 ) { vl . time = ( cdtime_t ) tmp ; n . time = ( cdtime_t ) tmp ; } } else if ( pkg_type == TYPE_INTERVAL ) { uint64_t tmp = 0 ; status = parse_part_number ( & buffer , & buffer_size , & tmp ) ; if ( status == 0 ) vl . interval = TIME_T_TO_CDTIME_T ( tmp ) ; } else if ( pkg_type == TYPE_INTERVAL_HR ) { uint64_t tmp = 0 ; status = parse_part_number ( & buffer , & buffer_size , & tmp ) ; if ( status == 0 ) vl . interval = ( cdtime_t ) tmp ; } else if ( pkg_type == TYPE_HOST ) { status = parse_part_string ( & buffer , & buffer_size , vl . host , sizeof ( vl . host ) ) ; if ( status == 0 ) sstrncpy ( n . host , vl . host , sizeof ( n . host ) ) ; } else if ( pkg_type == TYPE_PLUGIN ) { status = parse_part_string ( & buffer , & buffer_size , vl . plugin , sizeof ( vl . plugin ) ) ; if ( status == 0 ) sstrncpy ( n . plugin , vl . plugin , sizeof ( n . plugin ) ) ; } else if ( pkg_type == TYPE_PLUGIN_INSTANCE ) { status = parse_part_string ( & buffer , & buffer_size , vl . plugin_instance , sizeof ( vl . plugin_instance ) ) ; if ( status == 0 ) sstrncpy ( n . plugin_instance , vl . plugin_instance , sizeof ( n . plugin_instance ) ) ; } else if ( pkg_type == TYPE_TYPE ) { status = parse_part_string ( & buffer , & buffer_size , vl . type , sizeof ( vl . type ) ) ; if ( status == 0 ) sstrncpy ( n . type , vl . type , sizeof ( n . type ) ) ; } else if ( pkg_type == TYPE_TYPE_INSTANCE ) { status = parse_part_string ( & buffer , & buffer_size , vl . type_instance , sizeof ( vl . type_instance ) ) ; if ( status == 0 ) sstrncpy ( n . type_instance , vl . type_instance , sizeof ( n . type_instance ) ) ; } else if ( pkg_type == TYPE_MESSAGE ) { status = parse_part_string ( & buffer , & buffer_size , n . message , sizeof ( n . message ) ) ; if ( status != 0 ) { } else if ( ( n . severity != NOTIF_FAILURE ) && ( n . severity != NOTIF_WARNING ) && ( n . severity != NOTIF_OKAY ) ) { INFO ( "network<S2SV_blank>plugin:<S2SV_blank>" "Ignoring<S2SV_blank>notification<S2SV_blank>with<S2SV_blank>" "unknown<S2SV_blank>severity<S2SV_blank>%i." , n . severity ) ; } else if ( n . time <= 0 ) { INFO ( "network<S2SV_blank>plugin:<S2SV_blank>" "Ignoring<S2SV_blank>notification<S2SV_blank>with<S2SV_blank>" "time<S2SV_blank>==<S2SV_blank>0." ) ; } else if ( strlen ( n . message ) <= 0 ) { INFO ( "network<S2SV_blank>plugin:<S2SV_blank>" "Ignoring<S2SV_blank>notification<S2SV_blank>with<S2SV_blank>" "an<S2SV_blank>empty<S2SV_blank>message." ) ; } else { network_dispatch_notification ( & n ) ; } } else if ( pkg_type == TYPE_SEVERITY ) { uint64_t tmp = 0 ; status = parse_part_number ( & buffer , & buffer_size , & tmp ) ; if ( status == 0 ) n . severity = ( int ) tmp ; } else { DEBUG ( "network<S2SV_blank>plugin:<S2SV_blank>parse_packet:<S2SV_blank>Unknown<S2SV_blank>part" "<S2SV_blank>type:<S2SV_blank>0x%04hx" , pkg_type ) ; buffer = ( ( char * ) buffer ) + pkg_length ; <S2SV_StartBug> } <S2SV_EndBug> } if ( status == 0 && buffer_size > 0 ) WARNING ( "network<S2SV_blank>plugin:<S2SV_blank>parse_packet:<S2SV_blank>Received<S2SV_blank>truncated<S2SV_blank>" "packet,<S2SV_blank>try<S2SV_blank>increasing<S2SV_blank>`MaxPacketSize\'" ) ; return ( status ) ; }
static int unmap_ref_private ( struct mm_struct * mm , struct vm_area_struct * vma , struct page * page , unsigned long address ) { struct hstate * h = hstate_vma ( vma ) ; struct vm_area_struct * iter_vma ; struct address_space * mapping ; struct prio_tree_iter iter ; pgoff_t pgoff ; address = address & huge_page_mask ( h ) ; pgoff = vma_hugecache_offset ( h , vma , address ) ; <S2SV_StartBug> mapping = ( struct address_space * ) page_private ( page ) ; <S2SV_EndBug> mutex_lock ( & mapping -> i_mmap_mutex ) ; vma_prio_tree_foreach ( iter_vma , & iter , & mapping -> i_mmap , pgoff , pgoff ) { if ( iter_vma == vma ) continue ; if ( ! is_vma_resv_set ( iter_vma , HPAGE_RESV_OWNER ) ) __unmap_hugepage_range ( iter_vma , address , address + huge_page_size ( h ) , page ) ; } mutex_unlock ( & mapping -> i_mmap_mutex ) ; return 1 ; }
<S2SV_StartBug> void fdct16_8col ( __m128i * in ) { <S2SV_EndBug> __m128i i [ 8 ] , s [ 8 ] , p [ 8 ] , t [ 8 ] , u [ 16 ] , v [ 16 ] ; <S2SV_StartBug> const __m128i k__cospi_p16_p16 = _mm_set1_epi16 ( cospi_16_64 ) ; <S2SV_EndBug> const __m128i k__cospi_p16_m16 = pair_set_epi16 ( cospi_16_64 , - cospi_16_64 ) ; const __m128i k__cospi_m16_p16 = pair_set_epi16 ( - cospi_16_64 , cospi_16_64 ) ; const __m128i k__cospi_p24_p08 = pair_set_epi16 ( cospi_24_64 , cospi_8_64 ) ; <S2SV_StartBug> const __m128i k__cospi_m24_m08 = pair_set_epi16 ( - cospi_24_64 , - cospi_8_64 ) ; <S2SV_EndBug> const __m128i k__cospi_m08_p24 = pair_set_epi16 ( - cospi_8_64 , cospi_24_64 ) ; const __m128i k__cospi_p28_p04 = pair_set_epi16 ( cospi_28_64 , cospi_4_64 ) ; const __m128i k__cospi_m04_p28 = pair_set_epi16 ( - cospi_4_64 , cospi_28_64 ) ; const __m128i k__cospi_p12_p20 = pair_set_epi16 ( cospi_12_64 , cospi_20_64 ) ; const __m128i k__cospi_m20_p12 = pair_set_epi16 ( - cospi_20_64 , cospi_12_64 ) ; const __m128i k__cospi_p30_p02 = pair_set_epi16 ( cospi_30_64 , cospi_2_64 ) ; const __m128i k__cospi_p14_p18 = pair_set_epi16 ( cospi_14_64 , cospi_18_64 ) ; const __m128i k__cospi_m02_p30 = pair_set_epi16 ( - cospi_2_64 , cospi_30_64 ) ; const __m128i k__cospi_m18_p14 = pair_set_epi16 ( - cospi_18_64 , cospi_14_64 ) ; const __m128i k__cospi_p22_p10 = pair_set_epi16 ( cospi_22_64 , cospi_10_64 ) ; const __m128i k__cospi_p06_p26 = pair_set_epi16 ( cospi_6_64 , cospi_26_64 ) ; const __m128i k__cospi_m10_p22 = pair_set_epi16 ( - cospi_10_64 , cospi_22_64 ) ; const __m128i k__cospi_m26_p06 = pair_set_epi16 ( - cospi_26_64 , cospi_6_64 ) ; const __m128i k__DCT_CONST_ROUNDING = _mm_set1_epi32 ( DCT_CONST_ROUNDING ) ; i [ 0 ] = _mm_add_epi16 ( in [ 0 ] , in [ 15 ] ) ; i [ 1 ] = _mm_add_epi16 ( in [ 1 ] , in [ 14 ] ) ; i [ 2 ] = _mm_add_epi16 ( in [ 2 ] , in [ 13 ] ) ; i [ 3 ] = _mm_add_epi16 ( in [ 3 ] , in [ 12 ] ) ; i [ 4 ] = _mm_add_epi16 ( in [ 4 ] , in [ 11 ] ) ; i [ 5 ] = _mm_add_epi16 ( in [ 5 ] , in [ 10 ] ) ; i [ 6 ] = _mm_add_epi16 ( in [ 6 ] , in [ 9 ] ) ; i [ 7 ] = _mm_add_epi16 ( in [ 7 ] , in [ 8 ] ) ; s [ 0 ] = _mm_sub_epi16 ( in [ 7 ] , in [ 8 ] ) ; s [ 1 ] = _mm_sub_epi16 ( in [ 6 ] , in [ 9 ] ) ; s [ 2 ] = _mm_sub_epi16 ( in [ 5 ] , in [ 10 ] ) ; s [ 3 ] = _mm_sub_epi16 ( in [ 4 ] , in [ 11 ] ) ; s [ 4 ] = _mm_sub_epi16 ( in [ 3 ] , in [ 12 ] ) ; s [ 5 ] = _mm_sub_epi16 ( in [ 2 ] , in [ 13 ] ) ; s [ 6 ] = _mm_sub_epi16 ( in [ 1 ] , in [ 14 ] ) ; s [ 7 ] = _mm_sub_epi16 ( in [ 0 ] , in [ 15 ] ) ; p [ 0 ] = _mm_add_epi16 ( i [ 0 ] , i [ 7 ] ) ; p [ 1 ] = _mm_add_epi16 ( i [ 1 ] , i [ 6 ] ) ; p [ 2 ] = _mm_add_epi16 ( i [ 2 ] , i [ 5 ] ) ; p [ 3 ] = _mm_add_epi16 ( i [ 3 ] , i [ 4 ] ) ; p [ 4 ] = _mm_sub_epi16 ( i [ 3 ] , i [ 4 ] ) ; p [ 5 ] = _mm_sub_epi16 ( i [ 2 ] , i [ 5 ] ) ; p [ 6 ] = _mm_sub_epi16 ( i [ 1 ] , i [ 6 ] ) ; p [ 7 ] = _mm_sub_epi16 ( i [ 0 ] , i [ 7 ] ) ; u [ 0 ] = _mm_add_epi16 ( p [ 0 ] , p [ 3 ] ) ; u [ 1 ] = _mm_add_epi16 ( p [ 1 ] , p [ 2 ] ) ; u [ 2 ] = _mm_sub_epi16 ( p [ 1 ] , p [ 2 ] ) ; u [ 3 ] = _mm_sub_epi16 ( p [ 0 ] , p [ 3 ] ) ; v [ 0 ] = _mm_unpacklo_epi16 ( u [ 0 ] , u [ 1 ] ) ; v [ 1 ] = _mm_unpackhi_epi16 ( u [ 0 ] , u [ 1 ] ) ; v [ 2 ] = _mm_unpacklo_epi16 ( u [ 2 ] , u [ 3 ] ) ; v [ 3 ] = _mm_unpackhi_epi16 ( u [ 2 ] , u [ 3 ] ) ; u [ 0 ] = _mm_madd_epi16 ( v [ 0 ] , k__cospi_p16_p16 ) ; u [ 1 ] = _mm_madd_epi16 ( v [ 1 ] , k__cospi_p16_p16 ) ; u [ 2 ] = _mm_madd_epi16 ( v [ 0 ] , k__cospi_p16_m16 ) ; u [ 3 ] = _mm_madd_epi16 ( v [ 1 ] , k__cospi_p16_m16 ) ; u [ 4 ] = _mm_madd_epi16 ( v [ 2 ] , k__cospi_p24_p08 ) ; u [ 5 ] = _mm_madd_epi16 ( v [ 3 ] , k__cospi_p24_p08 ) ; u [ 6 ] = _mm_madd_epi16 ( v [ 2 ] , k__cospi_m08_p24 ) ; u [ 7 ] = _mm_madd_epi16 ( v [ 3 ] , k__cospi_m08_p24 ) ; v [ 0 ] = _mm_add_epi32 ( u [ 0 ] , k__DCT_CONST_ROUNDING ) ; v [ 1 ] = _mm_add_epi32 ( u [ 1 ] , k__DCT_CONST_ROUNDING ) ; v [ 2 ] = _mm_add_epi32 ( u [ 2 ] , k__DCT_CONST_ROUNDING ) ; v [ 3 ] = _mm_add_epi32 ( u [ 3 ] , k__DCT_CONST_ROUNDING ) ; v [ 4 ] = _mm_add_epi32 ( u [ 4 ] , k__DCT_CONST_ROUNDING ) ; v [ 5 ] = _mm_add_epi32 ( u [ 5 ] , k__DCT_CONST_ROUNDING ) ; v [ 6 ] = _mm_add_epi32 ( u [ 6 ] , k__DCT_CONST_ROUNDING ) ; v [ 7 ] = _mm_add_epi32 ( u [ 7 ] , k__DCT_CONST_ROUNDING ) ; u [ 0 ] = _mm_srai_epi32 ( v [ 0 ] , DCT_CONST_BITS ) ; u [ 1 ] = _mm_srai_epi32 ( v [ 1 ] , DCT_CONST_BITS ) ; u [ 2 ] = _mm_srai_epi32 ( v [ 2 ] , DCT_CONST_BITS ) ; u [ 3 ] = _mm_srai_epi32 ( v [ 3 ] , DCT_CONST_BITS ) ; u [ 4 ] = _mm_srai_epi32 ( v [ 4 ] , DCT_CONST_BITS ) ; u [ 5 ] = _mm_srai_epi32 ( v [ 5 ] , DCT_CONST_BITS ) ; u [ 6 ] = _mm_srai_epi32 ( v [ 6 ] , DCT_CONST_BITS ) ; u [ 7 ] = _mm_srai_epi32 ( v [ 7 ] , DCT_CONST_BITS ) ; in [ 0 ] = _mm_packs_epi32 ( u [ 0 ] , u [ 1 ] ) ; in [ 4 ] = _mm_packs_epi32 ( u [ 4 ] , u [ 5 ] ) ; in [ 8 ] = _mm_packs_epi32 ( u [ 2 ] , u [ 3 ] ) ; in [ 12 ] = _mm_packs_epi32 ( u [ 6 ] , u [ 7 ] ) ; u [ 0 ] = _mm_unpacklo_epi16 ( p [ 5 ] , p [ 6 ] ) ; u [ 1 ] = _mm_unpackhi_epi16 ( p [ 5 ] , p [ 6 ] ) ; v [ 0 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_m16_p16 ) ; v [ 1 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_m16_p16 ) ; v [ 2 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_p16_p16 ) ; v [ 3 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_p16_p16 ) ; u [ 0 ] = _mm_add_epi32 ( v [ 0 ] , k__DCT_CONST_ROUNDING ) ; u [ 1 ] = _mm_add_epi32 ( v [ 1 ] , k__DCT_CONST_ROUNDING ) ; u [ 2 ] = _mm_add_epi32 ( v [ 2 ] , k__DCT_CONST_ROUNDING ) ; u [ 3 ] = _mm_add_epi32 ( v [ 3 ] , k__DCT_CONST_ROUNDING ) ; v [ 0 ] = _mm_srai_epi32 ( u [ 0 ] , DCT_CONST_BITS ) ; v [ 1 ] = _mm_srai_epi32 ( u [ 1 ] , DCT_CONST_BITS ) ; v [ 2 ] = _mm_srai_epi32 ( u [ 2 ] , DCT_CONST_BITS ) ; v [ 3 ] = _mm_srai_epi32 ( u [ 3 ] , DCT_CONST_BITS ) ; u [ 0 ] = _mm_packs_epi32 ( v [ 0 ] , v [ 1 ] ) ; u [ 1 ] = _mm_packs_epi32 ( v [ 2 ] , v [ 3 ] ) ; t [ 0 ] = _mm_add_epi16 ( p [ 4 ] , u [ 0 ] ) ; t [ 1 ] = _mm_sub_epi16 ( p [ 4 ] , u [ 0 ] ) ; t [ 2 ] = _mm_sub_epi16 ( p [ 7 ] , u [ 1 ] ) ; t [ 3 ] = _mm_add_epi16 ( p [ 7 ] , u [ 1 ] ) ; u [ 0 ] = _mm_unpacklo_epi16 ( t [ 0 ] , t [ 3 ] ) ; u [ 1 ] = _mm_unpackhi_epi16 ( t [ 0 ] , t [ 3 ] ) ; u [ 2 ] = _mm_unpacklo_epi16 ( t [ 1 ] , t [ 2 ] ) ; u [ 3 ] = _mm_unpackhi_epi16 ( t [ 1 ] , t [ 2 ] ) ; v [ 0 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_p28_p04 ) ; v [ 1 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_p28_p04 ) ; v [ 2 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_p12_p20 ) ; v [ 3 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_p12_p20 ) ; v [ 4 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_m20_p12 ) ; v [ 5 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_m20_p12 ) ; v [ 6 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_m04_p28 ) ; v [ 7 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_m04_p28 ) ; u [ 0 ] = _mm_add_epi32 ( v [ 0 ] , k__DCT_CONST_ROUNDING ) ; u [ 1 ] = _mm_add_epi32 ( v [ 1 ] , k__DCT_CONST_ROUNDING ) ; u [ 2 ] = _mm_add_epi32 ( v [ 2 ] , k__DCT_CONST_ROUNDING ) ; u [ 3 ] = _mm_add_epi32 ( v [ 3 ] , k__DCT_CONST_ROUNDING ) ; u [ 4 ] = _mm_add_epi32 ( v [ 4 ] , k__DCT_CONST_ROUNDING ) ; u [ 5 ] = _mm_add_epi32 ( v [ 5 ] , k__DCT_CONST_ROUNDING ) ; u [ 6 ] = _mm_add_epi32 ( v [ 6 ] , k__DCT_CONST_ROUNDING ) ; u [ 7 ] = _mm_add_epi32 ( v [ 7 ] , k__DCT_CONST_ROUNDING ) ; v [ 0 ] = _mm_srai_epi32 ( u [ 0 ] , DCT_CONST_BITS ) ; v [ 1 ] = _mm_srai_epi32 ( u [ 1 ] , DCT_CONST_BITS ) ; v [ 2 ] = _mm_srai_epi32 ( u [ 2 ] , DCT_CONST_BITS ) ; v [ 3 ] = _mm_srai_epi32 ( u [ 3 ] , DCT_CONST_BITS ) ; v [ 4 ] = _mm_srai_epi32 ( u [ 4 ] , DCT_CONST_BITS ) ; v [ 5 ] = _mm_srai_epi32 ( u [ 5 ] , DCT_CONST_BITS ) ; v [ 6 ] = _mm_srai_epi32 ( u [ 6 ] , DCT_CONST_BITS ) ; v [ 7 ] = _mm_srai_epi32 ( u [ 7 ] , DCT_CONST_BITS ) ; in [ 2 ] = _mm_packs_epi32 ( v [ 0 ] , v [ 1 ] ) ; in [ 6 ] = _mm_packs_epi32 ( v [ 4 ] , v [ 5 ] ) ; in [ 10 ] = _mm_packs_epi32 ( v [ 2 ] , v [ 3 ] ) ; in [ 14 ] = _mm_packs_epi32 ( v [ 6 ] , v [ 7 ] ) ; u [ 0 ] = _mm_unpacklo_epi16 ( s [ 2 ] , s [ 5 ] ) ; u [ 1 ] = _mm_unpackhi_epi16 ( s [ 2 ] , s [ 5 ] ) ; u [ 2 ] = _mm_unpacklo_epi16 ( s [ 3 ] , s [ 4 ] ) ; u [ 3 ] = _mm_unpackhi_epi16 ( s [ 3 ] , s [ 4 ] ) ; v [ 0 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_m16_p16 ) ; v [ 1 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_m16_p16 ) ; v [ 2 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_m16_p16 ) ; v [ 3 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_m16_p16 ) ; v [ 4 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_p16_p16 ) ; v [ 5 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_p16_p16 ) ; v [ 6 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_p16_p16 ) ; v [ 7 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_p16_p16 ) ; u [ 0 ] = _mm_add_epi32 ( v [ 0 ] , k__DCT_CONST_ROUNDING ) ; u [ 1 ] = _mm_add_epi32 ( v [ 1 ] , k__DCT_CONST_ROUNDING ) ; u [ 2 ] = _mm_add_epi32 ( v [ 2 ] , k__DCT_CONST_ROUNDING ) ; u [ 3 ] = _mm_add_epi32 ( v [ 3 ] , k__DCT_CONST_ROUNDING ) ; u [ 4 ] = _mm_add_epi32 ( v [ 4 ] , k__DCT_CONST_ROUNDING ) ; u [ 5 ] = _mm_add_epi32 ( v [ 5 ] , k__DCT_CONST_ROUNDING ) ; u [ 6 ] = _mm_add_epi32 ( v [ 6 ] , k__DCT_CONST_ROUNDING ) ; u [ 7 ] = _mm_add_epi32 ( v [ 7 ] , k__DCT_CONST_ROUNDING ) ; v [ 0 ] = _mm_srai_epi32 ( u [ 0 ] , DCT_CONST_BITS ) ; v [ 1 ] = _mm_srai_epi32 ( u [ 1 ] , DCT_CONST_BITS ) ; v [ 2 ] = _mm_srai_epi32 ( u [ 2 ] , DCT_CONST_BITS ) ; v [ 3 ] = _mm_srai_epi32 ( u [ 3 ] , DCT_CONST_BITS ) ; v [ 4 ] = _mm_srai_epi32 ( u [ 4 ] , DCT_CONST_BITS ) ; v [ 5 ] = _mm_srai_epi32 ( u [ 5 ] , DCT_CONST_BITS ) ; v [ 6 ] = _mm_srai_epi32 ( u [ 6 ] , DCT_CONST_BITS ) ; v [ 7 ] = _mm_srai_epi32 ( u [ 7 ] , DCT_CONST_BITS ) ; t [ 2 ] = _mm_packs_epi32 ( v [ 0 ] , v [ 1 ] ) ; t [ 3 ] = _mm_packs_epi32 ( v [ 2 ] , v [ 3 ] ) ; t [ 4 ] = _mm_packs_epi32 ( v [ 4 ] , v [ 5 ] ) ; t [ 5 ] = _mm_packs_epi32 ( v [ 6 ] , v [ 7 ] ) ; p [ 0 ] = _mm_add_epi16 ( s [ 0 ] , t [ 3 ] ) ; p [ 1 ] = _mm_add_epi16 ( s [ 1 ] , t [ 2 ] ) ; p [ 2 ] = _mm_sub_epi16 ( s [ 1 ] , t [ 2 ] ) ; p [ 3 ] = _mm_sub_epi16 ( s [ 0 ] , t [ 3 ] ) ; p [ 4 ] = _mm_sub_epi16 ( s [ 7 ] , t [ 4 ] ) ; p [ 5 ] = _mm_sub_epi16 ( s [ 6 ] , t [ 5 ] ) ; p [ 6 ] = _mm_add_epi16 ( s [ 6 ] , t [ 5 ] ) ; p [ 7 ] = _mm_add_epi16 ( s [ 7 ] , t [ 4 ] ) ; u [ 0 ] = _mm_unpacklo_epi16 ( p [ 1 ] , p [ 6 ] ) ; u [ 1 ] = _mm_unpackhi_epi16 ( p [ 1 ] , p [ 6 ] ) ; u [ 2 ] = _mm_unpacklo_epi16 ( p [ 2 ] , p [ 5 ] ) ; u [ 3 ] = _mm_unpackhi_epi16 ( p [ 2 ] , p [ 5 ] ) ; v [ 0 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_m08_p24 ) ; v [ 1 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_m08_p24 ) ; <S2SV_StartBug> v [ 2 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_m24_m08 ) ; <S2SV_EndBug> v [ 3 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_m24_m08 ) ; v [ 4 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_m08_p24 ) ; v [ 5 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_m08_p24 ) ; v [ 6 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_p24_p08 ) ; <S2SV_StartBug> v [ 7 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_p24_p08 ) ; <S2SV_EndBug> <S2SV_StartBug> u [ 0 ] = _mm_add_epi32 ( v [ 0 ] , k__DCT_CONST_ROUNDING ) ; <S2SV_EndBug> u [ 1 ] = _mm_add_epi32 ( v [ 1 ] , k__DCT_CONST_ROUNDING ) ; u [ 2 ] = _mm_add_epi32 ( v [ 2 ] , k__DCT_CONST_ROUNDING ) ; u [ 3 ] = _mm_add_epi32 ( v [ 3 ] , k__DCT_CONST_ROUNDING ) ; u [ 4 ] = _mm_add_epi32 ( v [ 4 ] , k__DCT_CONST_ROUNDING ) ; u [ 5 ] = _mm_add_epi32 ( v [ 5 ] , k__DCT_CONST_ROUNDING ) ; u [ 6 ] = _mm_add_epi32 ( v [ 6 ] , k__DCT_CONST_ROUNDING ) ; u [ 7 ] = _mm_add_epi32 ( v [ 7 ] , k__DCT_CONST_ROUNDING ) ; v [ 0 ] = _mm_srai_epi32 ( u [ 0 ] , DCT_CONST_BITS ) ; v [ 1 ] = _mm_srai_epi32 ( u [ 1 ] , DCT_CONST_BITS ) ; v [ 2 ] = _mm_srai_epi32 ( u [ 2 ] , DCT_CONST_BITS ) ; v [ 3 ] = _mm_srai_epi32 ( u [ 3 ] , DCT_CONST_BITS ) ; v [ 4 ] = _mm_srai_epi32 ( u [ 4 ] , DCT_CONST_BITS ) ; v [ 5 ] = _mm_srai_epi32 ( u [ 5 ] , DCT_CONST_BITS ) ; v [ 6 ] = _mm_srai_epi32 ( u [ 6 ] , DCT_CONST_BITS ) ; v [ 7 ] = _mm_srai_epi32 ( u [ 7 ] , DCT_CONST_BITS ) ; t [ 1 ] = _mm_packs_epi32 ( v [ 0 ] , v [ 1 ] ) ; t [ 2 ] = _mm_packs_epi32 ( v [ 2 ] , v [ 3 ] ) ; t [ 5 ] = _mm_packs_epi32 ( v [ 4 ] , v [ 5 ] ) ; t [ 6 ] = _mm_packs_epi32 ( v [ 6 ] , v [ 7 ] ) ; s [ 0 ] = _mm_add_epi16 ( p [ 0 ] , t [ 1 ] ) ; s [ 1 ] = _mm_sub_epi16 ( p [ 0 ] , t [ 1 ] ) ; <S2SV_StartBug> s [ 2 ] = _mm_sub_epi16 ( p [ 3 ] , t [ 2 ] ) ; <S2SV_EndBug> <S2SV_StartBug> s [ 3 ] = _mm_add_epi16 ( p [ 3 ] , t [ 2 ] ) ; <S2SV_EndBug> s [ 4 ] = _mm_add_epi16 ( p [ 4 ] , t [ 5 ] ) ; s [ 5 ] = _mm_sub_epi16 ( p [ 4 ] , t [ 5 ] ) ; s [ 6 ] = _mm_sub_epi16 ( p [ 7 ] , t [ 6 ] ) ; s [ 7 ] = _mm_add_epi16 ( p [ 7 ] , t [ 6 ] ) ; u [ 0 ] = _mm_unpacklo_epi16 ( s [ 0 ] , s [ 7 ] ) ; u [ 1 ] = _mm_unpackhi_epi16 ( s [ 0 ] , s [ 7 ] ) ; u [ 2 ] = _mm_unpacklo_epi16 ( s [ 1 ] , s [ 6 ] ) ; u [ 3 ] = _mm_unpackhi_epi16 ( s [ 1 ] , s [ 6 ] ) ; u [ 4 ] = _mm_unpacklo_epi16 ( s [ 2 ] , s [ 5 ] ) ; u [ 5 ] = _mm_unpackhi_epi16 ( s [ 2 ] , s [ 5 ] ) ; u [ 6 ] = _mm_unpacklo_epi16 ( s [ 3 ] , s [ 4 ] ) ; u [ 7 ] = _mm_unpackhi_epi16 ( s [ 3 ] , s [ 4 ] ) ; v [ 0 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_p30_p02 ) ; v [ 1 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_p30_p02 ) ; v [ 2 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_p14_p18 ) ; v [ 3 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_p14_p18 ) ; v [ 4 ] = _mm_madd_epi16 ( u [ 4 ] , k__cospi_p22_p10 ) ; v [ 5 ] = _mm_madd_epi16 ( u [ 5 ] , k__cospi_p22_p10 ) ; v [ 6 ] = _mm_madd_epi16 ( u [ 6 ] , k__cospi_p06_p26 ) ; v [ 7 ] = _mm_madd_epi16 ( u [ 7 ] , k__cospi_p06_p26 ) ; v [ 8 ] = _mm_madd_epi16 ( u [ 6 ] , k__cospi_m26_p06 ) ; v [ 9 ] = _mm_madd_epi16 ( u [ 7 ] , k__cospi_m26_p06 ) ; v [ 10 ] = _mm_madd_epi16 ( u [ 4 ] , k__cospi_m10_p22 ) ; v [ 11 ] = _mm_madd_epi16 ( u [ 5 ] , k__cospi_m10_p22 ) ; v [ 12 ] = _mm_madd_epi16 ( u [ 2 ] , k__cospi_m18_p14 ) ; v [ 13 ] = _mm_madd_epi16 ( u [ 3 ] , k__cospi_m18_p14 ) ; v [ 14 ] = _mm_madd_epi16 ( u [ 0 ] , k__cospi_m02_p30 ) ; v [ 15 ] = _mm_madd_epi16 ( u [ 1 ] , k__cospi_m02_p30 ) ; u [ 0 ] = _mm_add_epi32 ( v [ 0 ] , k__DCT_CONST_ROUNDING ) ; u [ 1 ] = _mm_add_epi32 ( v [ 1 ] , k__DCT_CONST_ROUNDING ) ; u [ 2 ] = _mm_add_epi32 ( v [ 2 ] , k__DCT_CONST_ROUNDING ) ; u [ 3 ] = _mm_add_epi32 ( v [ 3 ] , k__DCT_CONST_ROUNDING ) ; u [ 4 ] = _mm_add_epi32 ( v [ 4 ] , k__DCT_CONST_ROUNDING ) ; u [ 5 ] = _mm_add_epi32 ( v [ 5 ] , k__DCT_CONST_ROUNDING ) ; u [ 6 ] = _mm_add_epi32 ( v [ 6 ] , k__DCT_CONST_ROUNDING ) ; u [ 7 ] = _mm_add_epi32 ( v [ 7 ] , k__DCT_CONST_ROUNDING ) ; u [ 8 ] = _mm_add_epi32 ( v [ 8 ] , k__DCT_CONST_ROUNDING ) ; u [ 9 ] = _mm_add_epi32 ( v [ 9 ] , k__DCT_CONST_ROUNDING ) ; u [ 10 ] = _mm_add_epi32 ( v [ 10 ] , k__DCT_CONST_ROUNDING ) ; u [ 11 ] = _mm_add_epi32 ( v [ 11 ] , k__DCT_CONST_ROUNDING ) ; u [ 12 ] = _mm_add_epi32 ( v [ 12 ] , k__DCT_CONST_ROUNDING ) ; u [ 13 ] = _mm_add_epi32 ( v [ 13 ] , k__DCT_CONST_ROUNDING ) ; u [ 14 ] = _mm_add_epi32 ( v [ 14 ] , k__DCT_CONST_ROUNDING ) ; u [ 15 ] = _mm_add_epi32 ( v [ 15 ] , k__DCT_CONST_ROUNDING ) ; v [ 0 ] = _mm_srai_epi32 ( u [ 0 ] , DCT_CONST_BITS ) ; v [ 1 ] = _mm_srai_epi32 ( u [ 1 ] , DCT_CONST_BITS ) ; v [ 2 ] = _mm_srai_epi32 ( u [ 2 ] , DCT_CONST_BITS ) ; v [ 3 ] = _mm_srai_epi32 ( u [ 3 ] , DCT_CONST_BITS ) ; v [ 4 ] = _mm_srai_epi32 ( u [ 4 ] , DCT_CONST_BITS ) ; v [ 5 ] = _mm_srai_epi32 ( u [ 5 ] , DCT_CONST_BITS ) ; v [ 6 ] = _mm_srai_epi32 ( u [ 6 ] , DCT_CONST_BITS ) ; v [ 7 ] = _mm_srai_epi32 ( u [ 7 ] , DCT_CONST_BITS ) ; v [ 8 ] = _mm_srai_epi32 ( u [ 8 ] , DCT_CONST_BITS ) ; v [ 9 ] = _mm_srai_epi32 ( u [ 9 ] , DCT_CONST_BITS ) ; v [ 10 ] = _mm_srai_epi32 ( u [ 10 ] , DCT_CONST_BITS ) ; v [ 11 ] = _mm_srai_epi32 ( u [ 11 ] , DCT_CONST_BITS ) ; v [ 12 ] = _mm_srai_epi32 ( u [ 12 ] , DCT_CONST_BITS ) ; v [ 13 ] = _mm_srai_epi32 ( u [ 13 ] , DCT_CONST_BITS ) ; v [ 14 ] = _mm_srai_epi32 ( u [ 14 ] , DCT_CONST_BITS ) ; v [ 15 ] = _mm_srai_epi32 ( u [ 15 ] , DCT_CONST_BITS ) ; in [ 1 ] = _mm_packs_epi32 ( v [ 0 ] , v [ 1 ] ) ; in [ 9 ] = _mm_packs_epi32 ( v [ 2 ] , v [ 3 ] ) ; in [ 5 ] = _mm_packs_epi32 ( v [ 4 ] , v [ 5 ] ) ; in [ 13 ] = _mm_packs_epi32 ( v [ 6 ] , v [ 7 ] ) ; in [ 3 ] = _mm_packs_epi32 ( v [ 8 ] , v [ 9 ] ) ; in [ 11 ] = _mm_packs_epi32 ( v [ 10 ] , v [ 11 ] ) ; in [ 7 ] = _mm_packs_epi32 ( v [ 12 ] , v [ 13 ] ) ; in [ 15 ] = _mm_packs_epi32 ( v [ 14 ] , v [ 15 ] ) ; }
static int read_part_of_packet ( AVFormatContext * s , int64_t * pts , int * len , int * strid , int read_packet ) { AVIOContext * pb = s -> pb ; PVAContext * pvactx = s -> priv_data ; int syncword , streamid , reserved , flags , length , pts_flag ; int64_t pva_pts = AV_NOPTS_VALUE , startpos ; int ret ; recover : startpos = avio_tell ( pb ) ; syncword = avio_rb16 ( pb ) ; streamid = avio_r8 ( pb ) ; avio_r8 ( pb ) ; reserved = avio_r8 ( pb ) ; flags = avio_r8 ( pb ) ; length = avio_rb16 ( pb ) ; pts_flag = flags & 0x10 ; if ( syncword != PVA_MAGIC ) { pva_log ( s , AV_LOG_ERROR , "invalid<S2SV_blank>syncword\\n" ) ; return AVERROR ( EIO ) ; } if ( streamid != PVA_VIDEO_PAYLOAD && streamid != PVA_AUDIO_PAYLOAD ) { pva_log ( s , AV_LOG_ERROR , "invalid<S2SV_blank>streamid\\n" ) ; return AVERROR ( EIO ) ; } if ( reserved != 0x55 ) { pva_log ( s , AV_LOG_WARNING , "expected<S2SV_blank>reserved<S2SV_blank>byte<S2SV_blank>to<S2SV_blank>be<S2SV_blank>0x55\\n" ) ; } if ( length > PVA_MAX_PAYLOAD_LENGTH ) { pva_log ( s , AV_LOG_ERROR , "invalid<S2SV_blank>payload<S2SV_blank>length<S2SV_blank>%u\\n" , length ) ; return AVERROR ( EIO ) ; } if ( streamid == PVA_VIDEO_PAYLOAD && pts_flag ) { pva_pts = avio_rb32 ( pb ) ; length -= 4 ; } else if ( streamid == PVA_AUDIO_PAYLOAD ) { if ( ! pvactx -> continue_pes ) { int pes_signal , pes_header_data_length , pes_packet_length , pes_flags ; unsigned char pes_header_data [ 256 ] ; pes_signal = avio_rb24 ( pb ) ; avio_r8 ( pb ) ; pes_packet_length = avio_rb16 ( pb ) ; pes_flags = avio_rb16 ( pb ) ; pes_header_data_length = avio_r8 ( pb ) ; <S2SV_StartBug> if ( pes_signal != 1 || pes_header_data_length == 0 ) { <S2SV_EndBug> pva_log ( s , AV_LOG_WARNING , "expected<S2SV_blank>non<S2SV_blank>empty<S2SV_blank>signaled<S2SV_blank>PES<S2SV_blank>packet,<S2SV_blank>" "trying<S2SV_blank>to<S2SV_blank>recover\\n" ) ; avio_skip ( pb , length - 9 ) ; if ( ! read_packet ) return AVERROR ( EIO ) ; goto recover ; } ret = avio_read ( pb , pes_header_data , pes_header_data_length ) ; if ( ret != pes_header_data_length ) return ret < 0 ? ret : AVERROR_INVALIDDATA ; length -= 9 + pes_header_data_length ; pes_packet_length -= 3 + pes_header_data_length ; pvactx -> continue_pes = pes_packet_length ; if ( pes_flags & 0x80 && ( pes_header_data [ 0 ] & 0xf0 ) == 0x20 ) { if ( pes_header_data_length < 5 ) { pva_log ( s , AV_LOG_ERROR , "header<S2SV_blank>too<S2SV_blank>short\\n" ) ; avio_skip ( pb , length ) ; return AVERROR_INVALIDDATA ; } pva_pts = ff_parse_pes_pts ( pes_header_data ) ; } } pvactx -> continue_pes -= length ; if ( pvactx -> continue_pes < 0 ) { pva_log ( s , AV_LOG_WARNING , "audio<S2SV_blank>data<S2SV_blank>corruption\\n" ) ; pvactx -> continue_pes = 0 ; } } if ( pva_pts != AV_NOPTS_VALUE ) av_add_index_entry ( s -> streams [ streamid - 1 ] , startpos , pva_pts , 0 , 0 , AVINDEX_KEYFRAME ) ; * pts = pva_pts ; * len = length ; * strid = streamid ; return 0 ; }
static struct sock * dccp_v6_request_recv_sock ( const struct sock * sk , struct sk_buff * skb , struct request_sock * req , struct dst_entry * dst , struct request_sock * req_unhash , bool * own_req ) { struct inet_request_sock * ireq = inet_rsk ( req ) ; struct ipv6_pinfo * newnp ; const struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct ipv6_txoptions * opt ; struct inet_sock * newinet ; struct dccp6_sock * newdp6 ; struct sock * newsk ; if ( skb -> protocol == htons ( ETH_P_IP ) ) { newsk = dccp_v4_request_recv_sock ( sk , skb , req , dst , req_unhash , own_req ) ; if ( newsk == NULL ) return NULL ; newdp6 = ( struct dccp6_sock * ) newsk ; newinet = inet_sk ( newsk ) ; newinet -> pinet6 = & newdp6 -> inet6 ; newnp = inet6_sk ( newsk ) ; memcpy ( newnp , np , sizeof ( struct ipv6_pinfo ) ) ; newnp -> saddr = newsk -> sk_v6_rcv_saddr ; inet_csk ( newsk ) -> icsk_af_ops = & dccp_ipv6_mapped ; newsk -> sk_backlog_rcv = dccp_v4_do_rcv ; newnp -> pktoptions = NULL ; newnp -> opt = NULL ; <S2SV_StartBug> newnp -> mcast_oif = inet6_iif ( skb ) ; <S2SV_EndBug> newnp -> mcast_hops = ipv6_hdr ( skb ) -> hop_limit ; dccp_sync_mss ( newsk , inet_csk ( newsk ) -> icsk_pmtu_cookie ) ; return newsk ; } if ( sk_acceptq_is_full ( sk ) ) goto out_overflow ; if ( ! dst ) { struct flowi6 fl6 ; dst = inet6_csk_route_req ( sk , & fl6 , req , IPPROTO_DCCP ) ; if ( ! dst ) goto out ; } newsk = dccp_create_openreq_child ( sk , req , skb ) ; if ( newsk == NULL ) goto out_nonewsk ; ip6_dst_store ( newsk , dst , NULL , NULL ) ; newsk -> sk_route_caps = dst -> dev -> features & ~ ( NETIF_F_IP_CSUM | NETIF_F_TSO ) ; newdp6 = ( struct dccp6_sock * ) newsk ; newinet = inet_sk ( newsk ) ; newinet -> pinet6 = & newdp6 -> inet6 ; newnp = inet6_sk ( newsk ) ; memcpy ( newnp , np , sizeof ( struct ipv6_pinfo ) ) ; newsk -> sk_v6_daddr = ireq -> ir_v6_rmt_addr ; newnp -> saddr = ireq -> ir_v6_loc_addr ; newsk -> sk_v6_rcv_saddr = ireq -> ir_v6_loc_addr ; newsk -> sk_bound_dev_if = ireq -> ir_iif ; newinet -> inet_opt = NULL ; newnp -> rxopt . all = np -> rxopt . all ; <S2SV_StartBug> newnp -> pktoptions = NULL ; <S2SV_EndBug> newnp -> opt = NULL ; newnp -> mcast_oif = inet6_iif ( skb ) ; newnp -> mcast_hops = ipv6_hdr ( skb ) -> hop_limit ; opt = ireq -> ipv6_opt ; if ( ! opt ) opt = rcu_dereference ( np -> opt ) ; if ( opt ) { opt = ipv6_dup_options ( newsk , opt ) ; RCU_INIT_POINTER ( newnp -> opt , opt ) ; } inet_csk ( newsk ) -> icsk_ext_hdr_len = 0 ; if ( opt ) inet_csk ( newsk ) -> icsk_ext_hdr_len = opt -> opt_nflen + opt -> opt_flen ; dccp_sync_mss ( newsk , dst_mtu ( dst ) ) ; newinet -> inet_daddr = newinet -> inet_saddr = LOOPBACK4_IPV6 ; newinet -> inet_rcv_saddr = LOOPBACK4_IPV6 ; if ( __inet_inherit_port ( sk , newsk ) < 0 ) { inet_csk_prepare_forced_close ( newsk ) ; dccp_done ( newsk ) ; goto out ; } * own_req = inet_ehash_nolisten ( newsk , req_to_sk ( req_unhash ) ) ; if ( * own_req && ireq -> pktopts ) { newnp -> pktoptions = skb_clone ( ireq -> pktopts , GFP_ATOMIC ) ; consume_skb ( ireq -> pktopts ) ; ireq -> pktopts = NULL ; if ( newnp -> pktoptions ) skb_set_owner_r ( newnp -> pktoptions , newsk ) ; } return newsk ; out_overflow : __NET_INC_STATS ( sock_net ( sk ) , LINUX_MIB_LISTENOVERFLOWS ) ; out_nonewsk : dst_release ( dst ) ; out : __NET_INC_STATS ( sock_net ( sk ) , LINUX_MIB_LISTENDROPS ) ; return NULL ; }
static inline long object_common1 ( UNSERIALIZE_PARAMETER , zend_class_entry * ce ) { <S2SV_StartBug> long elements ; <S2SV_EndBug> elements = parse_iv2 ( ( * p ) + 2 , p ) ; ( * p ) += 2 ; if ( ce -> serialize == NULL ) { object_init_ex ( * rval , ce ) ; } else { zend_error ( E_WARNING , "Erroneous<S2SV_blank>data<S2SV_blank>format<S2SV_blank>for<S2SV_blank>unserializing<S2SV_blank>\'%s\'" , ce -> name ) ; <S2SV_StartBug> return 0 ; <S2SV_EndBug> } return elements ; }
static int handle_emulation_failure ( struct kvm_vcpu * vcpu ) { int r = EMULATE_DONE ; ++ vcpu -> stat . insn_emulation_fail ; trace_kvm_emulate_insn_failed ( vcpu ) ; <S2SV_StartBug> if ( ! is_guest_mode ( vcpu ) ) { <S2SV_EndBug> vcpu -> run -> exit_reason = KVM_EXIT_INTERNAL_ERROR ; vcpu -> run -> internal . suberror = KVM_INTERNAL_ERROR_EMULATION ; vcpu -> run -> internal . ndata = 0 ; r = EMULATE_FAIL ; } kvm_queue_exception ( vcpu , UD_VECTOR ) ; return r ; }
sctp_disposition_t sctp_sf_do_5_1D_ce ( struct net * net , const struct sctp_endpoint * ep , const struct sctp_association * asoc , const sctp_subtype_t type , void * arg , sctp_cmd_seq_t * commands ) { struct sctp_chunk * chunk = arg ; struct sctp_association * new_asoc ; sctp_init_chunk_t * peer_init ; struct sctp_chunk * repl ; struct sctp_ulpevent * ev , * ai_ev = NULL ; int error = 0 ; struct sctp_chunk * err_chk_p ; struct sock * sk ; if ( ep == sctp_sk ( net -> sctp . ctl_sock ) -> ep ) { SCTP_INC_STATS ( net , SCTP_MIB_OUTOFBLUES ) ; return sctp_sf_tabort_8_4_8 ( net , ep , asoc , type , arg , commands ) ; } if ( ! sctp_chunk_length_valid ( chunk , sizeof ( sctp_chunkhdr_t ) ) ) return sctp_sf_pdiscard ( net , ep , asoc , type , arg , commands ) ; sk = ep -> base . sk ; if ( ! sctp_sstate ( sk , LISTENING ) || ( sctp_style ( sk , TCP ) && sk_acceptq_is_full ( sk ) ) ) return sctp_sf_tabort_8_4_8 ( net , ep , asoc , type , arg , commands ) ; chunk -> subh . cookie_hdr = ( struct sctp_signed_cookie * ) chunk -> skb -> data ; if ( ! pskb_pull ( chunk -> skb , ntohs ( chunk -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ) ) goto nomem ; new_asoc = sctp_unpack_cookie ( ep , asoc , chunk , GFP_ATOMIC , & error , & err_chk_p ) ; if ( ! new_asoc ) { switch ( error ) { case - SCTP_IERROR_NOMEM : goto nomem ; case - SCTP_IERROR_STALE_COOKIE : sctp_send_stale_cookie_err ( net , ep , asoc , chunk , commands , err_chk_p ) ; return sctp_sf_pdiscard ( net , ep , asoc , type , arg , commands ) ; case - SCTP_IERROR_BAD_SIG : default : return sctp_sf_pdiscard ( net , ep , asoc , type , arg , commands ) ; } } peer_init = & chunk -> subh . cookie_hdr -> c . peer_init [ 0 ] ; if ( ! sctp_process_init ( new_asoc , chunk , & chunk -> subh . cookie_hdr -> c . peer_addr , peer_init , GFP_ATOMIC ) ) goto nomem_init ; error = sctp_auth_asoc_init_active_key ( new_asoc , GFP_ATOMIC ) ; if ( error ) goto nomem_init ; if ( chunk -> auth_chunk ) { struct sctp_chunk auth ; sctp_ierror_t ret ; <S2SV_StartBug> auth . skb = chunk -> auth_chunk ; <S2SV_EndBug> auth . asoc = chunk -> asoc ; auth . sctp_hdr = chunk -> sctp_hdr ; auth . chunk_hdr = ( sctp_chunkhdr_t * ) skb_push ( chunk -> auth_chunk , sizeof ( sctp_chunkhdr_t ) ) ; skb_pull ( chunk -> auth_chunk , sizeof ( sctp_chunkhdr_t ) ) ; auth . transport = chunk -> transport ; ret = sctp_sf_authenticate ( net , ep , new_asoc , type , & auth ) ; kfree_skb ( chunk -> auth_chunk ) ; if ( ret != SCTP_IERROR_NO_ERROR ) { sctp_association_free ( new_asoc ) ; return sctp_sf_pdiscard ( net , ep , asoc , type , arg , commands ) ; } } repl = sctp_make_cookie_ack ( new_asoc , chunk ) ; if ( ! repl ) goto nomem_init ; ev = sctp_ulpevent_make_assoc_change ( new_asoc , 0 , SCTP_COMM_UP , 0 , new_asoc -> c . sinit_num_ostreams , new_asoc -> c . sinit_max_instreams , NULL , GFP_ATOMIC ) ; if ( ! ev ) goto nomem_ev ; if ( new_asoc -> peer . adaptation_ind ) { ai_ev = sctp_ulpevent_make_adaptation_indication ( new_asoc , GFP_ATOMIC ) ; if ( ! ai_ev ) goto nomem_aiev ; } sctp_add_cmd_sf ( commands , SCTP_CMD_NEW_ASOC , SCTP_ASOC ( new_asoc ) ) ; sctp_add_cmd_sf ( commands , SCTP_CMD_NEW_STATE , SCTP_STATE ( SCTP_STATE_ESTABLISHED ) ) ; SCTP_INC_STATS ( net , SCTP_MIB_CURRESTAB ) ; SCTP_INC_STATS ( net , SCTP_MIB_PASSIVEESTABS ) ; sctp_add_cmd_sf ( commands , SCTP_CMD_HB_TIMERS_START , SCTP_NULL ( ) ) ; if ( new_asoc -> timeouts [ SCTP_EVENT_TIMEOUT_AUTOCLOSE ] ) sctp_add_cmd_sf ( commands , SCTP_CMD_TIMER_START , SCTP_TO ( SCTP_EVENT_TIMEOUT_AUTOCLOSE ) ) ; sctp_add_cmd_sf ( commands , SCTP_CMD_REPLY , SCTP_CHUNK ( repl ) ) ; sctp_add_cmd_sf ( commands , SCTP_CMD_EVENT_ULP , SCTP_ULPEVENT ( ev ) ) ; if ( ai_ev ) sctp_add_cmd_sf ( commands , SCTP_CMD_EVENT_ULP , SCTP_ULPEVENT ( ai_ev ) ) ; return SCTP_DISPOSITION_CONSUME ; nomem_aiev : sctp_ulpevent_free ( ev ) ; nomem_ev : sctp_chunk_free ( repl ) ; nomem_init : sctp_association_free ( new_asoc ) ; nomem : return SCTP_DISPOSITION_NOMEM ; }
TEE_Result syscall_obj_generate_key ( unsigned long obj , unsigned long key_size , const struct utee_attribute * usr_params , unsigned long param_count ) { TEE_Result res ; struct tee_ta_session * sess ; const struct tee_cryp_obj_type_props * type_props ; struct tee_obj * o ; struct tee_cryp_obj_secret * key ; size_t byte_size ; TEE_Attribute * params = NULL ; res = tee_ta_get_current_session ( & sess ) ; if ( res != TEE_SUCCESS ) return res ; res = tee_obj_get ( to_user_ta_ctx ( sess -> ctx ) , tee_svc_uref_to_vaddr ( obj ) , & o ) ; if ( res != TEE_SUCCESS ) return res ; if ( ( o -> info . handleFlags & TEE_HANDLE_FLAG_PERSISTENT ) != 0 ) return TEE_ERROR_BAD_STATE ; if ( ( o -> info . handleFlags & TEE_HANDLE_FLAG_INITIALIZED ) != 0 ) return TEE_ERROR_BAD_STATE ; type_props = tee_svc_find_type_props ( o -> info . objectType ) ; if ( ! type_props ) return TEE_ERROR_NOT_SUPPORTED ; if ( key_size % type_props -> quanta != 0 ) return TEE_ERROR_NOT_SUPPORTED ; if ( key_size < type_props -> min_size ) return TEE_ERROR_NOT_SUPPORTED ; if ( key_size > type_props -> max_size ) return TEE_ERROR_NOT_SUPPORTED ; <S2SV_StartBug> params = malloc ( sizeof ( TEE_Attribute ) * param_count ) ; <S2SV_EndBug> if ( ! params ) return TEE_ERROR_OUT_OF_MEMORY ; res = copy_in_attrs ( to_user_ta_ctx ( sess -> ctx ) , usr_params , param_count , params ) ; if ( res != TEE_SUCCESS ) goto out ; res = tee_svc_cryp_check_attr ( ATTR_USAGE_GENERATE_KEY , type_props , params , param_count ) ; if ( res != TEE_SUCCESS ) goto out ; switch ( o -> info . objectType ) { case TEE_TYPE_AES : case TEE_TYPE_DES : case TEE_TYPE_DES3 : case TEE_TYPE_HMAC_MD5 : case TEE_TYPE_HMAC_SHA1 : case TEE_TYPE_HMAC_SHA224 : case TEE_TYPE_HMAC_SHA256 : case TEE_TYPE_HMAC_SHA384 : case TEE_TYPE_HMAC_SHA512 : case TEE_TYPE_GENERIC_SECRET : byte_size = key_size / 8 ; if ( o -> info . objectType == TEE_TYPE_DES || o -> info . objectType == TEE_TYPE_DES3 ) { byte_size = ( key_size + key_size / 7 ) / 8 ; } key = ( struct tee_cryp_obj_secret * ) o -> attr ; if ( byte_size > key -> alloc_size ) { res = TEE_ERROR_EXCESS_DATA ; goto out ; } res = crypto_rng_read ( ( void * ) ( key + 1 ) , byte_size ) ; if ( res != TEE_SUCCESS ) goto out ; key -> key_size = byte_size ; o -> have_attrs = ( 1 << type_props -> num_type_attrs ) - 1 ; break ; case TEE_TYPE_RSA_KEYPAIR : res = tee_svc_obj_generate_key_rsa ( o , type_props , key_size , params , param_count ) ; if ( res != TEE_SUCCESS ) goto out ; break ; case TEE_TYPE_DSA_KEYPAIR : res = tee_svc_obj_generate_key_dsa ( o , type_props , key_size ) ; if ( res != TEE_SUCCESS ) goto out ; break ; case TEE_TYPE_DH_KEYPAIR : res = tee_svc_obj_generate_key_dh ( o , type_props , key_size , params , param_count ) ; if ( res != TEE_SUCCESS ) goto out ; break ; case TEE_TYPE_ECDSA_KEYPAIR : case TEE_TYPE_ECDH_KEYPAIR : res = tee_svc_obj_generate_key_ecc ( o , type_props , key_size , params , param_count ) ; if ( res != TEE_SUCCESS ) goto out ; break ; default : res = TEE_ERROR_BAD_FORMAT ; } out : free ( params ) ; if ( res == TEE_SUCCESS ) { o -> info . keySize = key_size ; o -> info . handleFlags |= TEE_HANDLE_FLAG_INITIALIZED ; } return res ; }
void test_base64_lengths ( void ) { const char * in = "FuseMuse" ; char out1 [ 32 ] ; char out2 [ 32 ] ; size_t enclen ; int declen ; enclen = mutt_b64_encode ( out1 , in , 0 , 32 ) ; if ( ! TEST_CHECK ( enclen == 0 ) ) { TEST_MSG ( "Expected:<S2SV_blank>%zu" , 0 ) ; TEST_MSG ( "Actual<S2SV_blank><S2SV_blank>:<S2SV_blank>%zu" , enclen ) ; } out1 [ 0 ] = '\\0' ; <S2SV_StartBug> declen = mutt_b64_decode ( out2 , out1 ) ; <S2SV_EndBug> if ( ! TEST_CHECK ( declen == - 1 ) ) { TEST_MSG ( "Expected:<S2SV_blank>%zu" , - 1 ) ; TEST_MSG ( "Actual<S2SV_blank><S2SV_blank>:<S2SV_blank>%zu" , declen ) ; } for ( size_t i = 1 ; i <= 8 ; ++ i ) { enclen = mutt_b64_encode ( out1 , in , i , 32 ) ; size_t exp = ( ( i + 2 ) / 3 ) << 2 ; if ( ! TEST_CHECK ( enclen == exp ) ) { TEST_MSG ( "Expected:<S2SV_blank>%zu" , exp ) ; TEST_MSG ( "Actual<S2SV_blank><S2SV_blank>:<S2SV_blank>%zu" , enclen ) ; } <S2SV_StartBug> declen = mutt_b64_decode ( out2 , out1 ) ; <S2SV_EndBug> if ( ! TEST_CHECK ( declen == i ) ) { TEST_MSG ( "Expected:<S2SV_blank>%zu" , i ) ; TEST_MSG ( "Actual<S2SV_blank><S2SV_blank>:<S2SV_blank>%zu" , declen ) ; } out2 [ declen ] = '\\0' ; if ( ! TEST_CHECK ( strncmp ( out2 , in , i ) == 0 ) ) { TEST_MSG ( "Expected:<S2SV_blank>%s" , in ) ; TEST_MSG ( "Actual<S2SV_blank><S2SV_blank>:<S2SV_blank>%s" , out2 ) ; } } }
static vpx_codec_err_t validate_config ( vpx_codec_alg_priv_t * ctx , const vpx_codec_enc_cfg_t * cfg , const struct vp8_extracfg * vp8_cfg , int finalize ) { RANGE_CHECK ( cfg , g_w , 1 , 16383 ) ; RANGE_CHECK ( cfg , g_h , 1 , 16383 ) ; RANGE_CHECK ( cfg , g_timebase . den , 1 , 1000000000 ) ; <S2SV_StartBug> RANGE_CHECK ( cfg , g_timebase . num , 1 , cfg -> g_timebase . den ) ; <S2SV_EndBug> RANGE_CHECK_HI ( cfg , g_profile , 3 ) ; RANGE_CHECK_HI ( cfg , rc_max_quantizer , 63 ) ; RANGE_CHECK_HI ( cfg , rc_min_quantizer , cfg -> rc_max_quantizer ) ; RANGE_CHECK_HI ( cfg , g_threads , 64 ) ; # if CONFIG_REALTIME_ONLY RANGE_CHECK_HI ( cfg , g_lag_in_frames , 0 ) ; # elif CONFIG_MULTI_RES_ENCODING if ( ctx -> base . enc . total_encoders > 1 ) RANGE_CHECK_HI ( cfg , g_lag_in_frames , 0 ) ; # else RANGE_CHECK_HI ( cfg , g_lag_in_frames , 25 ) ; # endif RANGE_CHECK ( cfg , rc_end_usage , VPX_VBR , VPX_Q ) ; RANGE_CHECK_HI ( cfg , rc_undershoot_pct , 1000 ) ; RANGE_CHECK_HI ( cfg , rc_overshoot_pct , 1000 ) ; RANGE_CHECK_HI ( cfg , rc_2pass_vbr_bias_pct , 100 ) ; RANGE_CHECK ( cfg , kf_mode , VPX_KF_DISABLED , VPX_KF_AUTO ) ; # if CONFIG_MULTI_RES_ENCODING if ( ctx -> base . enc . total_encoders > 1 ) RANGE_CHECK_HI ( cfg , rc_resize_allowed , 0 ) ; # else RANGE_CHECK_BOOL ( cfg , rc_resize_allowed ) ; # endif RANGE_CHECK_HI ( cfg , rc_dropframe_thresh , 100 ) ; RANGE_CHECK_HI ( cfg , rc_resize_up_thresh , 100 ) ; RANGE_CHECK_HI ( cfg , rc_resize_down_thresh , 100 ) ; # if CONFIG_REALTIME_ONLY RANGE_CHECK ( cfg , g_pass , VPX_RC_ONE_PASS , VPX_RC_ONE_PASS ) ; # elif CONFIG_MULTI_RES_ENCODING if ( ctx -> base . enc . total_encoders > 1 ) RANGE_CHECK ( cfg , g_pass , VPX_RC_ONE_PASS , VPX_RC_ONE_PASS ) ; # else RANGE_CHECK ( cfg , g_pass , VPX_RC_ONE_PASS , VPX_RC_LAST_PASS ) ; # endif if ( cfg -> kf_mode != VPX_KF_DISABLED && cfg -> kf_min_dist != cfg -> kf_max_dist && cfg -> kf_min_dist > 0 ) ERROR ( "kf_min_dist<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>in<S2SV_blank>auto<S2SV_blank>mode,<S2SV_blank>use<S2SV_blank>0<S2SV_blank>" "or<S2SV_blank>kf_max_dist<S2SV_blank>instead." ) ; RANGE_CHECK_BOOL ( vp8_cfg , enable_auto_alt_ref ) ; RANGE_CHECK ( vp8_cfg , cpu_used , - 16 , 16 ) ; # if CONFIG_REALTIME_ONLY && ! CONFIG_TEMPORAL_DENOISING RANGE_CHECK ( vp8_cfg , noise_sensitivity , 0 , 0 ) ; # else RANGE_CHECK_HI ( vp8_cfg , noise_sensitivity , 6 ) ; # endif RANGE_CHECK ( vp8_cfg , token_partitions , VP8_ONE_TOKENPARTITION , VP8_EIGHT_TOKENPARTITION ) ; RANGE_CHECK_HI ( vp8_cfg , Sharpness , 7 ) ; RANGE_CHECK ( vp8_cfg , arnr_max_frames , 0 , 15 ) ; RANGE_CHECK_HI ( vp8_cfg , arnr_strength , 6 ) ; RANGE_CHECK ( vp8_cfg , arnr_type , 1 , 3 ) ; <S2SV_StartBug> RANGE_CHECK ( vp8_cfg , cq_level , 0 , 63 ) ; <S2SV_EndBug> if ( finalize && ( cfg -> rc_end_usage == VPX_CQ || cfg -> rc_end_usage == VPX_Q ) ) RANGE_CHECK ( vp8_cfg , cq_level , cfg -> rc_min_quantizer , cfg -> rc_max_quantizer ) ; # if ! ( CONFIG_REALTIME_ONLY ) if ( cfg -> g_pass == VPX_RC_LAST_PASS ) { size_t packet_sz = sizeof ( FIRSTPASS_STATS ) ; int n_packets = ( int ) ( cfg -> rc_twopass_stats_in . sz / packet_sz ) ; FIRSTPASS_STATS * stats ; if ( ! cfg -> rc_twopass_stats_in . buf ) ERROR ( "rc_twopass_stats_in.buf<S2SV_blank>not<S2SV_blank>set." ) ; if ( cfg -> rc_twopass_stats_in . sz % packet_sz ) ERROR ( "rc_twopass_stats_in.sz<S2SV_blank>indicates<S2SV_blank>truncated<S2SV_blank>packet." ) ; if ( cfg -> rc_twopass_stats_in . sz < 2 * packet_sz ) ERROR ( "rc_twopass_stats_in<S2SV_blank>requires<S2SV_blank>at<S2SV_blank>least<S2SV_blank>two<S2SV_blank>packets." ) ; stats = ( void * ) ( ( char * ) cfg -> rc_twopass_stats_in . buf + ( n_packets - 1 ) * packet_sz ) ; if ( ( int ) ( stats -> count + 0.5 ) != n_packets - 1 ) ERROR ( "rc_twopass_stats_in<S2SV_blank>missing<S2SV_blank>EOS<S2SV_blank>stats<S2SV_blank>packet" ) ; } # endif RANGE_CHECK ( cfg , ts_number_layers , 1 , 5 ) ; if ( cfg -> ts_number_layers > 1 ) { unsigned int i ; RANGE_CHECK_HI ( cfg , ts_periodicity , 16 ) ; for ( i = 1 ; i < cfg -> ts_number_layers ; i ++ ) <S2SV_StartBug> if ( cfg -> ts_target_bitrate [ i ] <= cfg -> ts_target_bitrate [ i - 1 ] ) <S2SV_EndBug> ERROR ( "ts_target_bitrate<S2SV_blank>entries<S2SV_blank>are<S2SV_blank>not<S2SV_blank>strictly<S2SV_blank>increasing" ) ; RANGE_CHECK ( cfg , ts_rate_decimator [ cfg -> ts_number_layers - 1 ] , 1 , 1 ) ; for ( i = cfg -> ts_number_layers - 2 ; i > 0 ; i -- ) if ( cfg -> ts_rate_decimator [ i - 1 ] != 2 * cfg -> ts_rate_decimator [ i ] ) ERROR ( "ts_rate_decimator<S2SV_blank>factors<S2SV_blank>are<S2SV_blank>not<S2SV_blank>powers<S2SV_blank>of<S2SV_blank>2" ) ; RANGE_CHECK_HI ( cfg , ts_layer_id [ i ] , cfg -> ts_number_layers - 1 ) ; } # if ( CONFIG_REALTIME_ONLY & CONFIG_ONTHEFLY_BITPACKING ) if ( cfg -> g_threads > ( 1 << vp8_cfg -> token_partitions ) ) ERROR ( "g_threads<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>bigger<S2SV_blank>than<S2SV_blank>number<S2SV_blank>of<S2SV_blank>token<S2SV_blank>partitions" ) ; # endif return VPX_CODEC_OK ; }
long keyctl_chown_key ( key_serial_t id , uid_t user , gid_t group ) { struct key_user * newowner , * zapowner = NULL ; struct key * key ; key_ref_t key_ref ; long ret ; kuid_t uid ; kgid_t gid ; uid = make_kuid ( current_user_ns ( ) , user ) ; gid = make_kgid ( current_user_ns ( ) , group ) ; ret = - EINVAL ; if ( ( user != ( uid_t ) - 1 ) && ! uid_valid ( uid ) ) goto error ; if ( ( group != ( gid_t ) - 1 ) && ! gid_valid ( gid ) ) goto error ; ret = 0 ; if ( user == ( uid_t ) - 1 && group == ( gid_t ) - 1 ) goto error ; key_ref = lookup_user_key ( id , KEY_LOOKUP_CREATE | KEY_LOOKUP_PARTIAL , KEY_NEED_SETATTR ) ; if ( IS_ERR ( key_ref ) ) { ret = PTR_ERR ( key_ref ) ; goto error ; } key = key_ref_to_ptr ( key_ref ) ; ret = - EACCES ; down_write ( & key -> sem ) ; if ( ! capable ( CAP_SYS_ADMIN ) ) { if ( user != ( uid_t ) - 1 && ! uid_eq ( key -> uid , uid ) ) goto error_put ; if ( group != ( gid_t ) - 1 && ! gid_eq ( gid , key -> gid ) && ! in_group_p ( gid ) ) goto error_put ; } if ( user != ( uid_t ) - 1 && ! uid_eq ( uid , key -> uid ) ) { ret = - ENOMEM ; newowner = key_user_lookup ( uid ) ; if ( ! newowner ) goto error_put ; if ( test_bit ( KEY_FLAG_IN_QUOTA , & key -> flags ) ) { unsigned maxkeys = uid_eq ( uid , GLOBAL_ROOT_UID ) ? key_quota_root_maxkeys : key_quota_maxkeys ; unsigned maxbytes = uid_eq ( uid , GLOBAL_ROOT_UID ) ? key_quota_root_maxbytes : key_quota_maxbytes ; spin_lock ( & newowner -> lock ) ; if ( newowner -> qnkeys + 1 >= maxkeys || newowner -> qnbytes + key -> quotalen >= maxbytes || newowner -> qnbytes + key -> quotalen < newowner -> qnbytes ) goto quota_overrun ; newowner -> qnkeys ++ ; newowner -> qnbytes += key -> quotalen ; spin_unlock ( & newowner -> lock ) ; spin_lock ( & key -> user -> lock ) ; key -> user -> qnkeys -- ; key -> user -> qnbytes -= key -> quotalen ; spin_unlock ( & key -> user -> lock ) ; } atomic_dec ( & key -> user -> nkeys ) ; atomic_inc ( & newowner -> nkeys ) ; <S2SV_StartBug> if ( test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) ) { <S2SV_EndBug> atomic_dec ( & key -> user -> nikeys ) ; atomic_inc ( & newowner -> nikeys ) ; } zapowner = key -> user ; key -> user = newowner ; key -> uid = uid ; } if ( group != ( gid_t ) - 1 ) key -> gid = gid ; ret = 0 ; error_put : up_write ( & key -> sem ) ; key_put ( key ) ; if ( zapowner ) key_user_put ( zapowner ) ; error : return ret ; quota_overrun : spin_unlock ( & newowner -> lock ) ; zapowner = newowner ; ret = - EDQUOT ; goto error_put ; }
int do_adjtimex ( struct timex * txc ) { <S2SV_StartBug> long mtemp , save_adjust , rem ; <S2SV_EndBug> s64 freq_adj ; int result ; if ( txc -> modes && ! capable ( CAP_SYS_TIME ) ) return - EPERM ; if ( ( txc -> modes & ADJ_OFFSET_SINGLESHOT ) == ADJ_OFFSET_SINGLESHOT ) { if ( txc -> modes != ADJ_OFFSET_SINGLESHOT && txc -> modes != ADJ_OFFSET_SS_READ ) return - EINVAL ; } if ( txc -> modes != ADJ_OFFSET_SINGLESHOT && ( txc -> modes & ADJ_OFFSET ) ) if ( txc -> offset <= - MAXPHASE || txc -> offset >= MAXPHASE ) return - EINVAL ; if ( txc -> modes & ADJ_TICK ) if ( txc -> tick < 900000 / USER_HZ || txc -> tick > 1100000 / USER_HZ ) return - EINVAL ; write_seqlock_irq ( & xtime_lock ) ; result = time_state ; save_adjust = time_adjust ; # if 0 time_status &= ~ STA_CLOCKERR ; # endif if ( txc -> modes ) { if ( txc -> modes & ADJ_STATUS ) time_status = ( txc -> status & ~ STA_RONLY ) | ( time_status & STA_RONLY ) ; if ( txc -> modes & ADJ_FREQUENCY ) { if ( txc -> freq > MAXFREQ || txc -> freq < - MAXFREQ ) { result = - EINVAL ; goto leave ; } time_freq = ( ( s64 ) txc -> freq * NSEC_PER_USEC ) >> ( SHIFT_USEC - SHIFT_NSEC ) ; } if ( txc -> modes & ADJ_MAXERROR ) { if ( txc -> maxerror < 0 || txc -> maxerror >= NTP_PHASE_LIMIT ) { result = - EINVAL ; goto leave ; } time_maxerror = txc -> maxerror ; } if ( txc -> modes & ADJ_ESTERROR ) { if ( txc -> esterror < 0 || txc -> esterror >= NTP_PHASE_LIMIT ) { result = - EINVAL ; goto leave ; } time_esterror = txc -> esterror ; } if ( txc -> modes & ADJ_TIMECONST ) { if ( txc -> constant < 0 ) { result = - EINVAL ; goto leave ; } time_constant = min ( txc -> constant + 4 , ( long ) MAXTC ) ; } if ( txc -> modes & ADJ_OFFSET ) { if ( txc -> modes == ADJ_OFFSET_SINGLESHOT ) { time_adjust = txc -> offset ; } else if ( time_status & STA_PLL ) { time_offset = txc -> offset * NSEC_PER_USEC ; time_offset = min ( time_offset , ( s64 ) MAXPHASE * NSEC_PER_USEC ) ; time_offset = max ( time_offset , ( s64 ) - MAXPHASE * NSEC_PER_USEC ) ; if ( time_status & STA_FREQHOLD || time_reftime == 0 ) time_reftime = xtime . tv_sec ; mtemp = xtime . tv_sec - time_reftime ; time_reftime = xtime . tv_sec ; freq_adj = time_offset * mtemp ; freq_adj = shift_right ( freq_adj , time_constant * 2 + ( SHIFT_PLL + 2 ) * 2 - SHIFT_NSEC ) ; if ( mtemp >= MINSEC && ( time_status & STA_FLL || mtemp > MAXSEC ) ) freq_adj += div_s64 ( time_offset << ( SHIFT_NSEC - SHIFT_FLL ) , mtemp ) ; freq_adj += time_freq ; freq_adj = min ( freq_adj , ( s64 ) MAXFREQ_NSEC ) ; time_freq = max ( freq_adj , ( s64 ) - MAXFREQ_NSEC ) ; <S2SV_StartBug> time_offset = div_long_long_rem_signed ( time_offset , <S2SV_EndBug> <S2SV_StartBug> NTP_INTERVAL_FREQ , <S2SV_EndBug> & rem ) ; time_offset <<= SHIFT_UPDATE ; } } if ( txc -> modes & ADJ_TICK ) tick_usec = txc -> tick ; if ( txc -> modes & ( ADJ_TICK | ADJ_FREQUENCY | ADJ_OFFSET ) ) ntp_update_frequency ( ) ; } leave : if ( ( time_status & ( STA_UNSYNC | STA_CLOCKERR ) ) != 0 ) result = TIME_ERROR ; if ( ( txc -> modes == ADJ_OFFSET_SINGLESHOT ) || ( txc -> modes == ADJ_OFFSET_SS_READ ) ) txc -> offset = save_adjust ; else txc -> offset = ( ( long ) shift_right ( time_offset , SHIFT_UPDATE ) ) * NTP_INTERVAL_FREQ / 1000 ; txc -> freq = ( time_freq / NSEC_PER_USEC ) << ( SHIFT_USEC - SHIFT_NSEC ) ; txc -> maxerror = time_maxerror ; txc -> esterror = time_esterror ; txc -> status = time_status ; txc -> constant = time_constant ; txc -> precision = 1 ; txc -> tolerance = MAXFREQ ; txc -> tick = tick_usec ; txc -> ppsfreq = 0 ; txc -> jitter = 0 ; txc -> shift = 0 ; txc -> stabil = 0 ; txc -> jitcnt = 0 ; txc -> calcnt = 0 ; txc -> errcnt = 0 ; txc -> stbcnt = 0 ; write_sequnlock_irq ( & xtime_lock ) ; do_gettimeofday ( & txc -> time ) ; notify_cmos_timer ( ) ; return ( result ) ; }
static void ubik_print ( netdissect_options * ndo , register const u_char * bp ) { int ubik_op ; int32_t temp ; ubik_op = EXTRACT_32BITS ( bp + sizeof ( struct rx_header ) ) ; ND_PRINT ( ( ndo , "<S2SV_blank>ubik<S2SV_blank>call<S2SV_blank>%s" , tok2str ( ubik_req , "op#%d" , ubik_op ) ) ) ; bp += sizeof ( struct rx_header ) + 4 ; switch ( ubik_op ) { case 10000 : ND_TCHECK2 ( bp [ 0 ] , 4 ) ; temp = EXTRACT_32BITS ( bp ) ; bp += sizeof ( int32_t ) ; ND_PRINT ( ( ndo , "<S2SV_blank>syncsite<S2SV_blank>%s" , temp ? "yes" : "no" ) ) ; ND_PRINT ( ( ndo , "<S2SV_blank>votestart" ) ) ; DATEOUT ( ) ; ND_PRINT ( ( ndo , "<S2SV_blank>dbversion" ) ) ; UBIK_VERSIONOUT ( ) ; ND_PRINT ( ( ndo , "<S2SV_blank>tid" ) ) ; UBIK_VERSIONOUT ( ) ; break ; case 10003 : ND_PRINT ( ( ndo , "<S2SV_blank>site" ) ) ; UINTOUT ( ) ; break ; case 20000 : case 20001 : case 20007 : case 20008 : case 20010 : ND_PRINT ( ( ndo , "<S2SV_blank>tid" ) ) ; UBIK_VERSIONOUT ( ) ; break ; case 20002 : ND_PRINT ( ( ndo , "<S2SV_blank>tid" ) ) ; UBIK_VERSIONOUT ( ) ; ND_PRINT ( ( ndo , "<S2SV_blank>file" ) ) ; INTOUT ( ) ; ND_PRINT ( ( ndo , "<S2SV_blank>pos" ) ) ; INTOUT ( ) ; ND_PRINT ( ( ndo , "<S2SV_blank>length" ) ) ; INTOUT ( ) ; <S2SV_StartBug> temp = EXTRACT_32BITS ( bp ) ; <S2SV_EndBug> bp += sizeof ( int32_t ) ; tok2str ( ubik_lock_types , "type<S2SV_blank>%d" , temp ) ; break ; case 20003 : ND_PRINT ( ( ndo , "<S2SV_blank>tid" ) ) ; UBIK_VERSIONOUT ( ) ; ND_PRINT ( ( ndo , "<S2SV_blank>file" ) ) ; INTOUT ( ) ; ND_PRINT ( ( ndo , "<S2SV_blank>pos" ) ) ; INTOUT ( ) ; break ; case 20005 : ND_PRINT ( ( ndo , "<S2SV_blank>file" ) ) ; INTOUT ( ) ; break ; case 20006 : ND_PRINT ( ( ndo , "<S2SV_blank>file" ) ) ; INTOUT ( ) ; ND_PRINT ( ( ndo , "<S2SV_blank>length" ) ) ; INTOUT ( ) ; ND_PRINT ( ( ndo , "<S2SV_blank>dbversion" ) ) ; UBIK_VERSIONOUT ( ) ; break ; case 20009 : ND_PRINT ( ( ndo , "<S2SV_blank>tid" ) ) ; UBIK_VERSIONOUT ( ) ; ND_PRINT ( ( ndo , "<S2SV_blank>file" ) ) ; INTOUT ( ) ; ND_PRINT ( ( ndo , "<S2SV_blank>length" ) ) ; INTOUT ( ) ; break ; case 20012 : ND_PRINT ( ( ndo , "<S2SV_blank>tid" ) ) ; UBIK_VERSIONOUT ( ) ; ND_PRINT ( ( ndo , "<S2SV_blank>oldversion" ) ) ; UBIK_VERSIONOUT ( ) ; ND_PRINT ( ( ndo , "<S2SV_blank>newversion" ) ) ; UBIK_VERSIONOUT ( ) ; break ; default : ; } return ; trunc : ND_PRINT ( ( ndo , "<S2SV_blank>[|ubik]" ) ) ; }
CURLcode Curl_urldecode ( struct SessionHandle * data , const char * string , size_t length , char * * ostring , size_t * olen , bool reject_ctrl ) { size_t alloc = ( length ? length : strlen ( string ) ) + 1 ; char * ns = malloc ( alloc ) ; unsigned char in ; size_t strindex = 0 ; unsigned long hex ; CURLcode res ; if ( ! ns ) return CURLE_OUT_OF_MEMORY ; while ( -- alloc > 0 ) { in = * string ; <S2SV_StartBug> if ( ( '%' == in ) && ISXDIGIT ( string [ 1 ] ) && ISXDIGIT ( string [ 2 ] ) ) { <S2SV_EndBug> char hexstr [ 3 ] ; char * ptr ; hexstr [ 0 ] = string [ 1 ] ; hexstr [ 1 ] = string [ 2 ] ; hexstr [ 2 ] = 0 ; hex = strtoul ( hexstr , & ptr , 16 ) ; in = curlx_ultouc ( hex ) ; res = Curl_convert_from_network ( data , & in , 1 ) ; if ( res ) { free ( ns ) ; return res ; } string += 2 ; alloc -= 2 ; } if ( reject_ctrl && ( in < 0x20 ) ) { free ( ns ) ; return CURLE_URL_MALFORMAT ; } ns [ strindex ++ ] = in ; string ++ ; } ns [ strindex ] = 0 ; if ( olen ) * olen = strindex ; if ( ostring ) * ostring = ns ; return CURLE_OK ; }
TcpOption * tcpGetOption ( TcpHeader * segment , uint8_t kind ) { <S2SV_StartBug> size_t length ; <S2SV_EndBug> uint_t i ; TcpOption * option ; <S2SV_StartBug> if ( segment -> dataOffset < 5 ) <S2SV_EndBug> return NULL ; <S2SV_StartBug> length = segment -> dataOffset * 4 - sizeof ( TcpHeader ) ; <S2SV_EndBug> i = 0 ; while ( i < length ) { option = ( TcpOption * ) ( segment -> options + i ) ; <S2SV_StartBug> if ( option -> kind == TCP_OPTION_NOP ) <S2SV_EndBug> { i ++ ; <S2SV_StartBug> continue ; <S2SV_EndBug> } if ( option -> kind == TCP_OPTION_END ) break ; <S2SV_StartBug> if ( ( i + 1 ) >= length || ( i + option -> length ) > length ) <S2SV_EndBug> break ; if ( option -> kind == kind ) return option ; i += option -> length ; } <S2SV_StartBug> return NULL ; <S2SV_EndBug> }
<S2SV_StartBug> double vp9_convert_qindex_to_q ( int qindex ) { <S2SV_EndBug> <S2SV_StartBug> return vp9_ac_quant ( qindex , 0 ) / 4.0 ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>
void bit_write_MC ( Bit_Chain * dat , BITCODE_MC val ) { int i , j ; int negative = 0 ; unsigned char byte [ 5 ] ; BITCODE_UMC mask = 0x0000007f ; BITCODE_UMC value = ( BITCODE_UMC ) val ; if ( val < 0 ) { negative = 1 ; value = ( BITCODE_UMC ) - val ; } for ( i = 4 , j = 0 ; i >= 0 ; i -- , j += 7 ) { byte [ i ] = ( unsigned char ) ( ( value & mask ) >> j ) ; byte [ i ] |= 0x80 ; mask = mask << 7 ; } for ( i = 0 ; i < 4 ; i ++ ) if ( byte [ i ] & 0x7f ) break ; <S2SV_StartBug> if ( byte [ i ] & 0x40 ) <S2SV_EndBug> i -- ; byte [ i ] &= 0x7f ; if ( negative ) byte [ i ] |= 0x40 ; for ( j = 4 ; j >= i ; j -- ) bit_write_RC ( dat , byte [ j ] ) ; }
static int filter_frame ( AVFilterLink * inlink , AVFrame * buf ) { AVFilterContext * ctx = inlink -> dst ; FPSContext * s = ctx -> priv ; AVFilterLink * outlink = ctx -> outputs [ 0 ] ; int64_t delta ; int i , ret ; s -> frames_in ++ ; if ( s -> pts == AV_NOPTS_VALUE ) { if ( buf -> pts != AV_NOPTS_VALUE ) { ret = write_to_fifo ( s -> fifo , buf ) ; if ( ret < 0 ) return ret ; if ( s -> start_time != DBL_MAX && s -> start_time != AV_NOPTS_VALUE ) { double first_pts = s -> start_time * AV_TIME_BASE ; first_pts = FFMIN ( FFMAX ( first_pts , INT64_MIN ) , INT64_MAX ) ; s -> first_pts = s -> pts = av_rescale_q ( first_pts , AV_TIME_BASE_Q , inlink -> time_base ) ; av_log ( ctx , AV_LOG_VERBOSE , "Set<S2SV_blank>first<S2SV_blank>pts<S2SV_blank>to<S2SV_blank>(in:%" PRId64 "<S2SV_blank>out:%" PRId64 ")\\n" , s -> first_pts , av_rescale_q ( first_pts , AV_TIME_BASE_Q , outlink -> time_base ) ) ; } else { s -> first_pts = s -> pts = buf -> pts ; } } else { av_log ( ctx , AV_LOG_WARNING , "Discarding<S2SV_blank>initial<S2SV_blank>frame(s)<S2SV_blank>with<S2SV_blank>no<S2SV_blank>" "timestamp.\\n" ) ; av_frame_free ( & buf ) ; s -> drop ++ ; } return 0 ; } <S2SV_StartBug> if ( buf -> pts == AV_NOPTS_VALUE ) { <S2SV_EndBug> return write_to_fifo ( s -> fifo , buf ) ; } delta = av_rescale_q_rnd ( buf -> pts - s -> pts , inlink -> time_base , outlink -> time_base , s -> rounding ) ; if ( delta < 1 ) { AVFrame * tmp ; int drop = av_fifo_size ( s -> fifo ) / sizeof ( AVFrame * ) ; av_log ( ctx , AV_LOG_DEBUG , "Dropping<S2SV_blank>%d<S2SV_blank>frame(s).\\n" , drop ) ; s -> drop += drop ; av_fifo_generic_read ( s -> fifo , & tmp , sizeof ( tmp ) , NULL ) ; flush_fifo ( s -> fifo ) ; ret = write_to_fifo ( s -> fifo , tmp ) ; av_frame_free ( & buf ) ; return ret ; } for ( i = 0 ; i < delta ; i ++ ) { AVFrame * buf_out ; av_fifo_generic_read ( s -> fifo , & buf_out , sizeof ( buf_out ) , NULL ) ; if ( ! av_fifo_size ( s -> fifo ) && i < delta - 1 ) { AVFrame * dup = av_frame_clone ( buf_out ) ; av_log ( ctx , AV_LOG_DEBUG , "Duplicating<S2SV_blank>frame.\\n" ) ; if ( dup ) ret = write_to_fifo ( s -> fifo , dup ) ; else ret = AVERROR ( ENOMEM ) ; if ( ret < 0 ) { av_frame_free ( & buf_out ) ; av_frame_free ( & buf ) ; return ret ; } s -> dup ++ ; } buf_out -> pts = av_rescale_q ( s -> first_pts , inlink -> time_base , outlink -> time_base ) + s -> frames_out ; if ( ( ret = ff_filter_frame ( outlink , buf_out ) ) < 0 ) { av_frame_free ( & buf ) ; return ret ; } s -> frames_out ++ ; } flush_fifo ( s -> fifo ) ; ret = write_to_fifo ( s -> fifo , buf ) ; s -> pts = s -> first_pts + av_rescale_q ( s -> frames_out , outlink -> time_base , inlink -> time_base ) ; return ret ; }
static void opj_j2k_set_cinema_parameters ( opj_cparameters_t * parameters , opj_image_t * image , opj_event_mgr_t * p_manager ) { int i ; parameters -> tile_size_on = OPJ_FALSE ; parameters -> cp_tdx = 1 ; parameters -> cp_tdy = 1 ; parameters -> tp_flag = 'C' ; parameters -> tp_on = 1 ; parameters -> cp_tx0 = 0 ; parameters -> cp_ty0 = 0 ; parameters -> image_offset_x0 = 0 ; parameters -> image_offset_y0 = 0 ; parameters -> cblockw_init = 32 ; parameters -> cblockh_init = 32 ; parameters -> mode = 0 ; parameters -> roi_compno = - 1 ; parameters -> subsampling_dx = 1 ; parameters -> subsampling_dy = 1 ; parameters -> irreversible = 1 ; if ( parameters -> tcp_numlayers > 1 ) { opj_event_msg ( p_manager , EVT_WARNING , "JPEG<S2SV_blank>2000<S2SV_blank>Profile-3<S2SV_blank>and<S2SV_blank>4<S2SV_blank>(2k/4k<S2SV_blank>dc<S2SV_blank>profile)<S2SV_blank>requires:\\n" "1<S2SV_blank>single<S2SV_blank>quality<S2SV_blank>layer" "-><S2SV_blank>Number<S2SV_blank>of<S2SV_blank>layers<S2SV_blank>forced<S2SV_blank>to<S2SV_blank>1<S2SV_blank>(rather<S2SV_blank>than<S2SV_blank>%d)\\n" "-><S2SV_blank>Rate<S2SV_blank>of<S2SV_blank>the<S2SV_blank>last<S2SV_blank>layer<S2SV_blank>(%3.1f)<S2SV_blank>will<S2SV_blank>be<S2SV_blank>used" , parameters -> tcp_numlayers , parameters -> tcp_rates [ parameters -> tcp_numlayers - 1 ] ) ; parameters -> tcp_rates [ 0 ] = parameters -> tcp_rates [ parameters -> tcp_numlayers - 1 ] ; parameters -> tcp_numlayers = 1 ; } switch ( parameters -> rsiz ) { case OPJ_PROFILE_CINEMA_2K : if ( parameters -> numresolution > 6 ) { opj_event_msg ( p_manager , EVT_WARNING , "JPEG<S2SV_blank>2000<S2SV_blank>Profile-3<S2SV_blank>(2k<S2SV_blank>dc<S2SV_blank>profile)<S2SV_blank>requires:\\n" "Number<S2SV_blank>of<S2SV_blank>decomposition<S2SV_blank>levels<S2SV_blank><=<S2SV_blank>5\\n" "-><S2SV_blank>Number<S2SV_blank>of<S2SV_blank>decomposition<S2SV_blank>levels<S2SV_blank>forced<S2SV_blank>to<S2SV_blank>5<S2SV_blank>(rather<S2SV_blank>than<S2SV_blank>%d)\\n" , parameters -> numresolution + 1 ) ; parameters -> numresolution = 6 ; } break ; case OPJ_PROFILE_CINEMA_4K : if ( parameters -> numresolution < 2 ) { opj_event_msg ( p_manager , EVT_WARNING , "JPEG<S2SV_blank>2000<S2SV_blank>Profile-4<S2SV_blank>(4k<S2SV_blank>dc<S2SV_blank>profile)<S2SV_blank>requires:\\n" "Number<S2SV_blank>of<S2SV_blank>decomposition<S2SV_blank>levels<S2SV_blank>>=<S2SV_blank>1<S2SV_blank>&&<S2SV_blank><=<S2SV_blank>6\\n" "-><S2SV_blank>Number<S2SV_blank>of<S2SV_blank>decomposition<S2SV_blank>levels<S2SV_blank>forced<S2SV_blank>to<S2SV_blank>1<S2SV_blank>(rather<S2SV_blank>than<S2SV_blank>%d)\\n" , parameters -> numresolution + 1 ) ; parameters -> numresolution = 1 ; } else if ( parameters -> numresolution > 7 ) { opj_event_msg ( p_manager , EVT_WARNING , "JPEG<S2SV_blank>2000<S2SV_blank>Profile-4<S2SV_blank>(4k<S2SV_blank>dc<S2SV_blank>profile)<S2SV_blank>requires:\\n" "Number<S2SV_blank>of<S2SV_blank>decomposition<S2SV_blank>levels<S2SV_blank>>=<S2SV_blank>1<S2SV_blank>&&<S2SV_blank><=<S2SV_blank>6\\n" "-><S2SV_blank>Number<S2SV_blank>of<S2SV_blank>decomposition<S2SV_blank>levels<S2SV_blank>forced<S2SV_blank>to<S2SV_blank>6<S2SV_blank>(rather<S2SV_blank>than<S2SV_blank>%d)\\n" , parameters -> numresolution + 1 ) ; parameters -> numresolution = 7 ; } break ; default : break ; } parameters -> csty |= 0x01 ; <S2SV_StartBug> parameters -> res_spec = parameters -> numresolution - 1 ; <S2SV_EndBug> for ( i = 0 ; i < parameters -> res_spec ; i ++ ) { parameters -> prcw_init [ i ] = 256 ; <S2SV_StartBug> parameters -> prch_init [ i ] = 256 ; <S2SV_EndBug> } parameters -> prog_order = OPJ_CPRL ; if ( parameters -> rsiz == OPJ_PROFILE_CINEMA_4K ) { parameters -> numpocs = ( OPJ_UINT32 ) opj_j2k_initialise_4K_poc ( parameters -> POC , parameters -> numresolution ) ; } else { parameters -> numpocs = 0 ; } parameters -> cp_disto_alloc = 1 ; if ( parameters -> max_cs_size <= 0 ) { parameters -> max_cs_size = OPJ_CINEMA_24_CS ; opj_event_msg ( p_manager , EVT_WARNING , "JPEG<S2SV_blank>2000<S2SV_blank>Profile-3<S2SV_blank>and<S2SV_blank>4<S2SV_blank>(2k/4k<S2SV_blank>dc<S2SV_blank>profile)<S2SV_blank>requires:\\n" "Maximum<S2SV_blank>1302083<S2SV_blank>compressed<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>24fps\\n" "As<S2SV_blank>no<S2SV_blank>rate<S2SV_blank>has<S2SV_blank>been<S2SV_blank>given,<S2SV_blank>this<S2SV_blank>limit<S2SV_blank>will<S2SV_blank>be<S2SV_blank>used.\\n" ) ; } else if ( parameters -> max_cs_size > OPJ_CINEMA_24_CS ) { opj_event_msg ( p_manager , EVT_WARNING , "JPEG<S2SV_blank>2000<S2SV_blank>Profile-3<S2SV_blank>and<S2SV_blank>4<S2SV_blank>(2k/4k<S2SV_blank>dc<S2SV_blank>profile)<S2SV_blank>requires:\\n" "Maximum<S2SV_blank>1302083<S2SV_blank>compressed<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>24fps\\n" "-><S2SV_blank>Specified<S2SV_blank>rate<S2SV_blank>exceeds<S2SV_blank>this<S2SV_blank>limit.<S2SV_blank>Rate<S2SV_blank>will<S2SV_blank>be<S2SV_blank>forced<S2SV_blank>to<S2SV_blank>1302083<S2SV_blank>bytes.\\n" ) ; parameters -> max_cs_size = OPJ_CINEMA_24_CS ; } if ( parameters -> max_comp_size <= 0 ) { parameters -> max_comp_size = OPJ_CINEMA_24_COMP ; opj_event_msg ( p_manager , EVT_WARNING , "JPEG<S2SV_blank>2000<S2SV_blank>Profile-3<S2SV_blank>and<S2SV_blank>4<S2SV_blank>(2k/4k<S2SV_blank>dc<S2SV_blank>profile)<S2SV_blank>requires:\\n" "Maximum<S2SV_blank>1041666<S2SV_blank>compressed<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>24fps\\n" "As<S2SV_blank>no<S2SV_blank>rate<S2SV_blank>has<S2SV_blank>been<S2SV_blank>given,<S2SV_blank>this<S2SV_blank>limit<S2SV_blank>will<S2SV_blank>be<S2SV_blank>used.\\n" ) ; } else if ( parameters -> max_comp_size > OPJ_CINEMA_24_COMP ) { opj_event_msg ( p_manager , EVT_WARNING , "JPEG<S2SV_blank>2000<S2SV_blank>Profile-3<S2SV_blank>and<S2SV_blank>4<S2SV_blank>(2k/4k<S2SV_blank>dc<S2SV_blank>profile)<S2SV_blank>requires:\\n" "Maximum<S2SV_blank>1041666<S2SV_blank>compressed<S2SV_blank>bytes<S2SV_blank>@<S2SV_blank>24fps\\n" "-><S2SV_blank>Specified<S2SV_blank>rate<S2SV_blank>exceeds<S2SV_blank>this<S2SV_blank>limit.<S2SV_blank>Rate<S2SV_blank>will<S2SV_blank>be<S2SV_blank>forced<S2SV_blank>to<S2SV_blank>1041666<S2SV_blank>bytes.\\n" ) ; parameters -> max_comp_size = OPJ_CINEMA_24_COMP ; } parameters -> tcp_rates [ 0 ] = ( OPJ_FLOAT32 ) ( image -> numcomps * image -> comps [ 0 ] . w * image -> comps [ 0 ] . h * image -> comps [ 0 ] . prec ) / ( OPJ_FLOAT32 ) ( ( ( OPJ_UINT32 ) parameters -> max_cs_size ) * 8 * image -> comps [ 0 ] . dx * image -> comps [ 0 ] . dy ) ; }
WORD32 ih264d_mark_err_slice_skip ( dec_struct_t * ps_dec , WORD32 num_mb_skip , UWORD8 u1_is_idr_slice , UWORD16 u2_frame_num , pocstruct_t * ps_cur_poc , WORD32 prev_slice_err ) { WORD32 i2_cur_mb_addr ; UWORD32 u1_num_mbs , u1_num_mbsNby2 ; UWORD32 u1_mb_idx = ps_dec -> u1_mb_idx ; UWORD32 i2_mb_skip_run ; UWORD32 u1_num_mbs_next , u1_end_of_row ; const UWORD32 i2_pic_wdin_mbs = ps_dec -> u2_frm_wd_in_mbs ; UWORD32 u1_slice_end ; UWORD32 u1_tfr_n_mb ; UWORD32 u1_decode_nmb ; dec_bit_stream_t * const ps_bitstrm = ps_dec -> ps_bitstrm ; dec_slice_params_t * ps_slice = ps_dec -> ps_cur_slice ; UWORD32 * pu4_bitstrm_buf = ps_bitstrm -> pu4_buffer ; UWORD32 * pu4_bitstrm_ofst = & ps_bitstrm -> u4_ofst ; deblk_mb_t * ps_cur_deblk_mb ; dec_mb_info_t * ps_cur_mb_info ; parse_pmbarams_t * ps_parse_mb_data ; UWORD32 u1_inter_mb_type ; UWORD32 u1_deblk_mb_type ; UWORD16 u2_total_mbs_coded ; UWORD32 u1_mbaff = ps_slice -> u1_mbaff_frame_flag ; parse_part_params_t * ps_part_info ; WORD32 ret ; if ( ps_dec -> ps_dec_err_status -> u1_err_flag & REJECT_CUR_PIC ) { ih264d_err_pic_dispbuf_mgr ( ps_dec ) ; return 0 ; } if ( ps_dec -> ps_cur_slice -> u1_mbaff_frame_flag && ( num_mb_skip & 1 ) ) { num_mb_skip ++ ; } ps_dec -> ps_dpb_cmds -> u1_long_term_reference_flag = 0 ; if ( prev_slice_err == 1 ) { ps_dec -> ps_cur_slice -> u2_frame_num = u2_frame_num ; if ( ! ps_dec -> u1_first_slice_in_stream ) { ih264d_end_of_pic ( ps_dec , u1_is_idr_slice , ps_dec -> ps_cur_slice -> u2_frame_num ) ; ps_dec -> s_cur_pic_poc . u2_frame_num = ps_dec -> ps_cur_slice -> u2_frame_num ; } { WORD32 i , j , poc = 0 ; ps_dec -> ps_cur_slice -> u2_first_mb_in_slice = 0 ; ps_dec -> pf_mvpred = ih264d_mvpred_nonmbaff ; ps_dec -> p_form_mb_part_info = ih264d_form_mb_part_info_bp ; ps_dec -> p_motion_compensate = ih264d_motion_compensate_bp ; if ( ps_dec -> ps_cur_pic != NULL ) poc = ps_dec -> ps_cur_pic -> i4_poc + 2 ; j = - 1 ; for ( i = 0 ; i < MAX_NUM_PIC_PARAMS ; i ++ ) { if ( ps_dec -> ps_pps [ i ] . u1_is_valid == TRUE ) { if ( ps_dec -> ps_pps [ i ] . ps_sps -> u1_is_valid == TRUE ) { j = i ; break ; } } } if ( j == - 1 ) { <S2SV_StartBug> return ERROR_INV_SPS_PPS_T ; <S2SV_EndBug> } if ( ps_dec -> u4_pic_buf_got == 0 ) { ps_dec -> ps_cur_slice -> u1_slice_type = P_SLICE ; ps_dec -> ps_cur_slice -> u1_nal_ref_idc = 1 ; ps_dec -> ps_cur_slice -> u1_nal_unit_type = 1 ; ret = ih264d_start_of_pic ( ps_dec , poc , ps_cur_poc , ps_dec -> ps_cur_slice -> u2_frame_num , & ps_dec -> ps_pps [ j ] ) ; if ( ret != OK ) { return ret ; } } ps_dec -> ps_ref_pic_buf_lx [ 0 ] [ 0 ] -> u1_pic_buf_id = 0 ; ps_dec -> u4_output_present = 0 ; { ih264d_get_next_display_field ( ps_dec , ps_dec -> ps_out_buffer , & ( ps_dec -> s_disp_op ) ) ; if ( 0 != ps_dec -> s_disp_op . u4_error_code ) { ps_dec -> u4_fmt_conv_cur_row = ps_dec -> s_disp_frame_info . u4_y_ht ; } else ps_dec -> u4_output_present = 1 ; } if ( ps_dec -> u1_separate_parse == 1 ) { if ( ps_dec -> u4_dec_thread_created == 0 ) { ithread_create ( ps_dec -> pv_dec_thread_handle , NULL , ( void * ) ih264d_decode_picture_thread , ( void * ) ps_dec ) ; ps_dec -> u4_dec_thread_created = 1 ; } if ( ( ps_dec -> u4_num_cores == 3 ) && ( ( ps_dec -> u4_app_disable_deblk_frm == 0 ) || ps_dec -> i1_recon_in_thread3_flag ) && ( ps_dec -> u4_bs_deblk_thread_created == 0 ) ) { ps_dec -> u4_start_recon_deblk = 0 ; ithread_create ( ps_dec -> pv_bs_deblk_thread_handle , NULL , ( void * ) ih264d_recon_deblk_thread , ( void * ) ps_dec ) ; ps_dec -> u4_bs_deblk_thread_created = 1 ; } } } ps_dec -> u4_first_slice_in_pic = 0 ; } else { dec_slice_struct_t * ps_parse_cur_slice ; ps_parse_cur_slice = ps_dec -> ps_dec_slice_buf + ps_dec -> u2_cur_slice_num ; if ( ps_dec -> u1_slice_header_done && ps_parse_cur_slice == ps_dec -> ps_parse_cur_slice ) { if ( ( u1_mbaff ) && ( ps_dec -> u4_num_mbs_cur_nmb & 1 ) ) { ps_dec -> u4_num_mbs_cur_nmb = ps_dec -> u4_num_mbs_cur_nmb - 1 ; ps_dec -> u2_cur_mb_addr -- ; } u1_num_mbs = ps_dec -> u4_num_mbs_cur_nmb ; if ( u1_num_mbs ) { ps_cur_mb_info = ps_dec -> ps_nmb_info + u1_num_mbs - 1 ; } else { if ( ps_dec -> u1_separate_parse ) { ps_cur_mb_info = ps_dec -> ps_nmb_info ; } else { ps_cur_mb_info = ps_dec -> ps_nmb_info + ps_dec -> u4_num_mbs_prev_nmb - 1 ; } } ps_dec -> u2_mby = ps_cur_mb_info -> u2_mby ; ps_dec -> u2_mbx = ps_cur_mb_info -> u2_mbx ; ps_dec -> u1_mb_ngbr_availablity = ps_cur_mb_info -> u1_mb_ngbr_availablity ; if ( u1_num_mbs ) { ps_dec -> pv_parse_tu_coeff_data = ps_dec -> pv_prev_mb_parse_tu_coeff_data ; ps_dec -> u2_cur_mb_addr -- ; ps_dec -> i4_submb_ofst -= SUB_BLK_SIZE ; if ( ps_dec -> u1_pr_sl_type == P_SLICE || ps_dec -> u1_pr_sl_type == B_SLICE ) { ps_dec -> pf_mvpred_ref_tfr_nby2mb ( ps_dec , u1_mb_idx , u1_num_mbs ) ; ps_dec -> ps_part = ps_dec -> ps_parse_part_params ; } u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec -> u2_mbx - 1 ; u1_end_of_row = ( ! u1_num_mbs_next ) && ( ! ( u1_mbaff && ( u1_num_mbs & 0x01 ) ) ) ; u1_slice_end = 1 ; u1_tfr_n_mb = 1 ; ps_cur_mb_info -> u1_end_of_slice = u1_slice_end ; if ( ps_dec -> u1_separate_parse ) { ih264d_parse_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; ps_dec -> ps_nmb_info += u1_num_mbs ; } else { ih264d_decode_recon_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; } ps_dec -> u2_total_mbs_coded += u1_num_mbs ; ps_dec -> u1_mb_idx = 0 ; ps_dec -> u4_num_mbs_cur_nmb = 0 ; } if ( ps_dec -> u2_total_mbs_coded >= ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) { ps_dec -> u1_pic_decode_done = 1 ; return 0 ; } if ( ps_dec -> ps_parse_cur_slice -> u4_first_mb_in_slice < ( UWORD32 ) ( ps_dec -> u2_total_mbs_coded >> ps_slice -> u1_mbaff_frame_flag ) ) { ps_dec -> i2_prev_slice_mbx = ps_dec -> u2_mbx ; ps_dec -> i2_prev_slice_mby = ps_dec -> u2_mby ; ps_dec -> u2_cur_slice_num ++ ; ps_dec -> ps_parse_cur_slice ++ ; } } else { ps_dec -> ps_parse_cur_slice = ps_dec -> ps_dec_slice_buf + ps_dec -> u2_cur_slice_num ; } } { WORD32 num_entries ; WORD32 size ; UWORD8 * pu1_buf ; num_entries = MIN ( MAX_FRAMES , ps_dec -> u4_num_ref_frames_at_init ) ; num_entries = 2 * ( ( 2 * num_entries ) + 1 ) ; size = num_entries * sizeof ( void * ) ; size += PAD_MAP_IDX_POC * sizeof ( void * ) ; pu1_buf = ( UWORD8 * ) ps_dec -> pv_map_ref_idx_to_poc_buf ; pu1_buf += size * ps_dec -> u2_cur_slice_num ; ps_dec -> ps_parse_cur_slice -> ppv_map_ref_idx_to_poc = ( volatile void * * ) pu1_buf ; } ps_dec -> ps_cur_slice -> u2_first_mb_in_slice = ps_dec -> u2_total_mbs_coded >> u1_mbaff ; ps_dec -> ps_cur_slice -> i1_slice_alpha_c0_offset = 0 ; ps_dec -> ps_cur_slice -> i1_slice_beta_offset = 0 ; if ( ps_dec -> ps_cur_slice -> u1_field_pic_flag ) ps_dec -> u2_prv_frame_num = ps_dec -> ps_cur_slice -> u2_frame_num ; ps_dec -> ps_parse_cur_slice -> u4_first_mb_in_slice = ps_dec -> u2_total_mbs_coded >> u1_mbaff ; ps_dec -> ps_parse_cur_slice -> u2_log2Y_crwd = ps_dec -> ps_cur_slice -> u2_log2Y_crwd ; if ( ps_dec -> u1_separate_parse ) { ps_dec -> ps_parse_cur_slice -> pv_tu_coeff_data_start = ps_dec -> pv_parse_tu_coeff_data ; } else { ps_dec -> pv_proc_tu_coeff_data = ps_dec -> pv_parse_tu_coeff_data ; } u1_inter_mb_type = P_MB ; u1_deblk_mb_type = D_INTER_MB ; ps_dec -> ps_cur_slice -> u1_slice_type = P_SLICE ; ps_dec -> ps_parse_cur_slice -> slice_type = P_SLICE ; ps_dec -> pf_mvpred_ref_tfr_nby2mb = ih264d_mv_pred_ref_tfr_nby2_pmb ; ps_dec -> ps_part = ps_dec -> ps_parse_part_params ; ps_dec -> u2_mbx = ( MOD ( ps_dec -> ps_cur_slice -> u2_first_mb_in_slice - 1 , ps_dec -> u2_frm_wd_in_mbs ) ) ; ps_dec -> u2_mby = ( DIV ( ps_dec -> ps_cur_slice -> u2_first_mb_in_slice - 1 , ps_dec -> u2_frm_wd_in_mbs ) ) ; ps_dec -> u2_mby <<= u1_mbaff ; ps_dec -> u1_slice_header_done = 2 ; ps_dec -> u1_qp = ps_slice -> u1_slice_qp ; ih264d_update_qp ( ps_dec , 0 ) ; u1_mb_idx = ps_dec -> u1_mb_idx ; ps_parse_mb_data = ps_dec -> ps_parse_mb_data ; u1_num_mbs = u1_mb_idx ; u1_slice_end = 0 ; u1_tfr_n_mb = 0 ; u1_decode_nmb = 0 ; u1_num_mbsNby2 = 0 ; i2_cur_mb_addr = ps_dec -> u2_total_mbs_coded ; i2_mb_skip_run = num_mb_skip ; while ( ! u1_slice_end ) { UWORD8 u1_mb_type ; if ( i2_cur_mb_addr > ps_dec -> ps_cur_sps -> u2_max_mb_addr ) break ; ps_cur_mb_info = ps_dec -> ps_nmb_info + u1_num_mbs ; ps_dec -> u4_num_mbs_cur_nmb = u1_num_mbs ; ps_cur_mb_info -> u1_Mux = 0 ; ps_dec -> u4_num_pmbair = ( u1_num_mbs >> u1_mbaff ) ; ps_cur_deblk_mb = ps_dec -> ps_deblk_mbn + u1_num_mbs ; ps_cur_mb_info -> u1_end_of_slice = 0 ; ps_parse_mb_data -> u1_num_part = 1 ; ps_parse_mb_data -> u1_isI_mb = 0 ; if ( u1_mbaff ) ih264d_get_mb_info_cavlc_mbaff ( ps_dec , i2_cur_mb_addr , ps_cur_mb_info , i2_mb_skip_run ) ; else ih264d_get_mb_info_cavlc_nonmbaff ( ps_dec , i2_cur_mb_addr , ps_cur_mb_info , i2_mb_skip_run ) ; if ( ps_dec -> u4_app_disable_deblk_frm == 0 ) { ih264d_set_deblocking_parameters ( ps_cur_deblk_mb , ps_slice , ps_dec -> u1_mb_ngbr_availablity , ps_dec -> u1_cur_mb_fld_dec_flag ) ; } ps_dec -> i1_prev_mb_qp_delta = 0 ; ps_dec -> u1_sub_mb_num = 0 ; ps_cur_mb_info -> u1_mb_type = MB_SKIP ; ps_cur_mb_info -> u1_mb_mc_mode = PRED_16x16 ; ps_cur_mb_info -> u1_cbp = 0 ; ps_part_info = ps_dec -> ps_part ; ps_part_info -> u1_is_direct = PART_DIRECT_16x16 ; ps_part_info -> u1_sub_mb_num = 0 ; ps_dec -> ps_part ++ ; ih264d_update_nnz_for_skipmb ( ps_dec , ps_cur_mb_info , CAVLC ) ; ps_cur_mb_info -> ps_curmb -> u1_mb_type = u1_inter_mb_type ; ps_cur_deblk_mb -> u1_mb_type |= u1_deblk_mb_type ; i2_mb_skip_run -- ; ps_cur_deblk_mb -> u1_mb_qp = ps_dec -> u1_qp ; if ( u1_mbaff ) { ih264d_update_mbaff_left_nnz ( ps_dec , ps_cur_mb_info ) ; } i2_cur_mb_addr ++ ; u1_num_mbs ++ ; u1_num_mbsNby2 ++ ; ps_parse_mb_data ++ ; u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec -> u2_mbx - 1 ; u1_end_of_row = ( ! u1_num_mbs_next ) && ( ! ( u1_mbaff && ( u1_num_mbs & 0x01 ) ) ) ; u1_slice_end = ! i2_mb_skip_run ; u1_tfr_n_mb = ( u1_num_mbs == ps_dec -> u1_recon_mb_grp ) || u1_end_of_row || u1_slice_end ; u1_decode_nmb = u1_tfr_n_mb || u1_slice_end ; ps_cur_mb_info -> u1_end_of_slice = u1_slice_end ; if ( u1_decode_nmb ) { ps_dec -> pf_mvpred_ref_tfr_nby2mb ( ps_dec , u1_mb_idx , u1_num_mbs ) ; u1_num_mbsNby2 = 0 ; ps_parse_mb_data = ps_dec -> ps_parse_mb_data ; ps_dec -> ps_part = ps_dec -> ps_parse_part_params ; if ( ps_dec -> u1_separate_parse ) { ih264d_parse_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; ps_dec -> ps_nmb_info += u1_num_mbs ; } else { ih264d_decode_recon_tfr_nmb ( ps_dec , u1_mb_idx , u1_num_mbs , u1_num_mbs_next , u1_tfr_n_mb , u1_end_of_row ) ; } ps_dec -> u2_total_mbs_coded += u1_num_mbs ; if ( u1_tfr_n_mb ) u1_num_mbs = 0 ; u1_mb_idx = u1_num_mbs ; ps_dec -> u1_mb_idx = u1_num_mbs ; } } ps_dec -> u4_num_mbs_cur_nmb = 0 ; ps_dec -> ps_cur_slice -> u4_mbs_in_slice = i2_cur_mb_addr - ps_dec -> ps_parse_cur_slice -> u4_first_mb_in_slice ; H264_DEC_DEBUG_PRINT ( "Mbs<S2SV_blank>in<S2SV_blank>slice:<S2SV_blank>%d\\n" , ps_dec -> ps_cur_slice -> u4_mbs_in_slice ) ; if ( ps_dec -> u4_first_slice_in_pic != 0 ) { ps_dec -> ps_parse_cur_slice ++ ; ps_dec -> u2_cur_slice_num ++ ; } ps_dec -> i2_prev_slice_mbx = ps_dec -> u2_mbx ; ps_dec -> i2_prev_slice_mby = ps_dec -> u2_mby ; if ( ps_dec -> u2_total_mbs_coded >= ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) { ps_dec -> u1_pic_decode_done = 1 ; } return 0 ; }
bool initiate_stratum ( struct pool * pool ) { char s [ RBUFSIZE ] , * sret = NULL , * nonce1 , * sessionid ; json_t * val = NULL , * res_val , * err_val ; bool ret = false , recvd = false ; json_error_t err ; int n2size ; if ( ! setup_stratum_curl ( pool ) ) goto out ; resend : if ( pool -> sessionid ) sprintf ( s , "{\\"id\\":<S2SV_blank>%d,<S2SV_blank>\\"method\\":<S2SV_blank>\\"mining.subscribe\\",<S2SV_blank>\\"params\\":<S2SV_blank>[\\"%s\\"]}" , swork_id ++ , pool -> sessionid ) ; else sprintf ( s , "{\\"id\\":<S2SV_blank>%d,<S2SV_blank>\\"method\\":<S2SV_blank>\\"mining.subscribe\\",<S2SV_blank>\\"params\\":<S2SV_blank>[]}" , swork_id ++ ) ; if ( ! __stratum_send ( pool , s , strlen ( s ) ) ) { applog ( LOG_DEBUG , "Failed<S2SV_blank>to<S2SV_blank>send<S2SV_blank>s<S2SV_blank>in<S2SV_blank>initiate_stratum" ) ; goto out ; } if ( ! socket_full ( pool , true ) ) { applog ( LOG_DEBUG , "Timed<S2SV_blank>out<S2SV_blank>waiting<S2SV_blank>for<S2SV_blank>response<S2SV_blank>in<S2SV_blank>initiate_stratum" ) ; goto out ; } sret = recv_line ( pool ) ; if ( ! sret ) goto out ; recvd = true ; val = JSON_LOADS ( sret , & err ) ; free ( sret ) ; if ( ! val ) { applog ( LOG_INFO , "JSON<S2SV_blank>decode<S2SV_blank>failed(%d):<S2SV_blank>%s" , err . line , err . text ) ; goto out ; } res_val = json_object_get ( val , "result" ) ; err_val = json_object_get ( val , "error" ) ; if ( ! res_val || json_is_null ( res_val ) || ( err_val && ! json_is_null ( err_val ) ) ) { char * ss ; if ( err_val ) ss = json_dumps ( err_val , JSON_INDENT ( 3 ) ) ; else ss = strdup ( "(unknown<S2SV_blank>reason)" ) ; applog ( LOG_INFO , "JSON-RPC<S2SV_blank>decode<S2SV_blank>failed:<S2SV_blank>%s" , ss ) ; free ( ss ) ; goto out ; } sessionid = json_array_string ( json_array_get ( res_val , 0 ) , 1 ) ; if ( ! sessionid ) { applog ( LOG_INFO , "Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>sessionid<S2SV_blank>in<S2SV_blank>initiate_stratum" ) ; goto out ; } nonce1 = json_array_string ( res_val , 1 ) ; if ( ! nonce1 ) { applog ( LOG_INFO , "Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>nonce1<S2SV_blank>in<S2SV_blank>initiate_stratum" ) ; free ( sessionid ) ; goto out ; } n2size = json_integer_value ( json_array_get ( res_val , 2 ) ) ; <S2SV_StartBug> if ( ! n2size ) { <S2SV_EndBug> applog ( LOG_INFO , "Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>n2size<S2SV_blank>in<S2SV_blank>initiate_stratum" ) ; free ( sessionid ) ; free ( nonce1 ) ; goto out ; } mutex_lock ( & pool -> pool_lock ) ; pool -> sessionid = sessionid ; free ( pool -> nonce1 ) ; pool -> nonce1 = nonce1 ; pool -> n1_len = strlen ( nonce1 ) / 2 ; pool -> n2size = n2size ; mutex_unlock ( & pool -> pool_lock ) ; applog ( LOG_DEBUG , "Pool<S2SV_blank>%d<S2SV_blank>stratum<S2SV_blank>session<S2SV_blank>id:<S2SV_blank>%s" , pool -> pool_no , pool -> sessionid ) ; ret = true ; out : if ( val ) json_decref ( val ) ; if ( ret ) { if ( ! pool -> stratum_url ) pool -> stratum_url = pool -> sockaddr_url ; pool -> stratum_active = true ; pool -> swork . diff = 1 ; if ( opt_protocol ) { applog ( LOG_DEBUG , "Pool<S2SV_blank>%d<S2SV_blank>confirmed<S2SV_blank>mining.subscribe<S2SV_blank>with<S2SV_blank>extranonce1<S2SV_blank>%s<S2SV_blank>extran2size<S2SV_blank>%d" , pool -> pool_no , pool -> nonce1 , pool -> n2size ) ; } } else { if ( recvd && pool -> sessionid ) { mutex_lock ( & pool -> pool_lock ) ; free ( pool -> sessionid ) ; free ( pool -> nonce1 ) ; pool -> sessionid = pool -> nonce1 = NULL ; mutex_unlock ( & pool -> pool_lock ) ; applog ( LOG_DEBUG , "Failed<S2SV_blank>to<S2SV_blank>resume<S2SV_blank>stratum,<S2SV_blank>trying<S2SV_blank>afresh" ) ; goto resend ; } applog ( LOG_DEBUG , "Initiate<S2SV_blank>stratum<S2SV_blank>failed" ) ; if ( pool -> sock != INVSOCK ) { shutdown ( pool -> sock , SHUT_RDWR ) ; pool -> sock = INVSOCK ; } } return ret ; }
static int nsv_parse_NSVf_header ( AVFormatContext * s ) { NSVContext * nsv = s -> priv_data ; AVIOContext * pb = s -> pb ; unsigned int av_unused file_size ; unsigned int size ; int64_t duration ; int strings_size ; int table_entries ; int table_entries_used ; nsv -> state = NSV_UNSYNC ; size = avio_rl32 ( pb ) ; if ( size < 28 ) return - 1 ; nsv -> NSVf_end = size ; file_size = ( uint32_t ) avio_rl32 ( pb ) ; av_log ( s , AV_LOG_TRACE , "NSV<S2SV_blank>NSVf<S2SV_blank>chunk_size<S2SV_blank>%u\\n" , size ) ; av_log ( s , AV_LOG_TRACE , "NSV<S2SV_blank>NSVf<S2SV_blank>file_size<S2SV_blank>%u\\n" , file_size ) ; nsv -> duration = duration = avio_rl32 ( pb ) ; av_log ( s , AV_LOG_TRACE , "NSV<S2SV_blank>NSVf<S2SV_blank>duration<S2SV_blank>%" PRId64 "<S2SV_blank>ms\\n" , duration ) ; strings_size = avio_rl32 ( pb ) ; table_entries = avio_rl32 ( pb ) ; table_entries_used = avio_rl32 ( pb ) ; av_log ( s , AV_LOG_TRACE , "NSV<S2SV_blank>NSVf<S2SV_blank>info-strings<S2SV_blank>size:<S2SV_blank>%d,<S2SV_blank>table<S2SV_blank>entries:<S2SV_blank>%d,<S2SV_blank>bis<S2SV_blank>%d\\n" , strings_size , table_entries , table_entries_used ) ; if ( avio_feof ( pb ) ) return - 1 ; av_log ( s , AV_LOG_TRACE , "NSV<S2SV_blank>got<S2SV_blank>header;<S2SV_blank>filepos<S2SV_blank>%" PRId64 "\\n" , avio_tell ( pb ) ) ; if ( strings_size > 0 ) { char * strings ; char * p , * endp ; char * token , * value ; char quote ; p = strings = av_mallocz ( ( size_t ) strings_size + 1 ) ; if ( ! p ) return AVERROR ( ENOMEM ) ; endp = strings + strings_size ; avio_read ( pb , strings , strings_size ) ; while ( p < endp ) { while ( * p == '<S2SV_blank>' ) p ++ ; if ( p >= endp - 2 ) break ; token = p ; p = strchr ( p , '=' ) ; if ( ! p || p >= endp - 2 ) break ; * p ++ = '\\0' ; quote = * p ++ ; value = p ; p = strchr ( p , quote ) ; if ( ! p || p >= endp ) break ; * p ++ = '\\0' ; av_log ( s , AV_LOG_TRACE , "NSV<S2SV_blank>NSVf<S2SV_blank>INFO:<S2SV_blank>%s=\'%s\'\\n" , token , value ) ; av_dict_set ( & s -> metadata , token , value , 0 ) ; } av_free ( strings ) ; } if ( avio_feof ( pb ) ) return - 1 ; av_log ( s , AV_LOG_TRACE , "NSV<S2SV_blank>got<S2SV_blank>infos;<S2SV_blank>filepos<S2SV_blank>%" PRId64 "\\n" , avio_tell ( pb ) ) ; if ( table_entries_used > 0 ) { int i ; nsv -> index_entries = table_entries_used ; if ( ( unsigned ) table_entries_used >= UINT_MAX / sizeof ( uint32_t ) ) return - 1 ; nsv -> nsvs_file_offset = av_malloc_array ( ( unsigned ) table_entries_used , sizeof ( uint32_t ) ) ; if ( ! nsv -> nsvs_file_offset ) return AVERROR ( ENOMEM ) ; <S2SV_StartBug> for ( i = 0 ; i < table_entries_used ; i ++ ) <S2SV_EndBug> <S2SV_StartBug> nsv -> nsvs_file_offset [ i ] = avio_rl32 ( pb ) + size ; <S2SV_EndBug> if ( table_entries > table_entries_used && avio_rl32 ( pb ) == MKTAG ( 'T' , 'O' , 'C' , '2' ) ) { nsv -> nsvs_timestamps = av_malloc_array ( ( unsigned ) table_entries_used , sizeof ( uint32_t ) ) ; if ( ! nsv -> nsvs_timestamps ) return AVERROR ( ENOMEM ) ; for ( i = 0 ; i < table_entries_used ; i ++ ) { nsv -> nsvs_timestamps [ i ] = avio_rl32 ( pb ) ; } } } av_log ( s , AV_LOG_TRACE , "NSV<S2SV_blank>got<S2SV_blank>index;<S2SV_blank>filepos<S2SV_blank>%" PRId64 "\\n" , avio_tell ( pb ) ) ; avio_seek ( pb , nsv -> base_offset + size , SEEK_SET ) ; if ( avio_feof ( pb ) ) return - 1 ; nsv -> state = NSV_HAS_READ_NSVF ; return 0 ; }
const char * string_of_NPPVariable ( int variable ) { const char * str ; switch ( variable ) { # define _ ( VAL ) case VAL : str = # VAL ; break ; _ ( NPPVpluginNameString ) ; _ ( NPPVpluginDescriptionString ) ; _ ( NPPVpluginWindowBool ) ; _ ( NPPVpluginTransparentBool ) ; _ ( NPPVjavaClass ) ; _ ( NPPVpluginWindowSize ) ; _ ( NPPVpluginTimerInterval ) ; _ ( NPPVpluginScriptableInstance ) ; _ ( NPPVpluginScriptableIID ) ; _ ( NPPVjavascriptPushCallerBool ) ; _ ( NPPVpluginKeepLibraryInMemory ) ; _ ( NPPVpluginNeedsXEmbed ) ; _ ( NPPVpluginScriptableNPObject ) ; _ ( NPPVformValue ) ; <S2SV_StartBug> # undef _ <S2SV_EndBug> default : switch ( variable & 0xff ) { # define _ ( VAL , VAR ) case VAL : str = # VAR ; break _ ( 10 , NPPVpluginScriptableInstance ) ; # undef _ default : str = "<unknown<S2SV_blank>variable>" ; break ; } break ; } return str ; }
static int pppol2tp_getsockopt ( struct socket * sock , int level , int optname , char __user * optval , int __user * optlen ) { struct sock * sk = sock -> sk ; struct l2tp_session * session ; struct l2tp_tunnel * tunnel ; int val , len ; int err ; struct pppol2tp_session * ps ; if ( level != SOL_PPPOL2TP ) <S2SV_StartBug> return udp_prot . getsockopt ( sk , level , optname , optval , optlen ) ; <S2SV_EndBug> if ( get_user ( len , optlen ) ) return - EFAULT ; len = min_t ( unsigned int , len , sizeof ( int ) ) ; if ( len < 0 ) return - EINVAL ; err = - ENOTCONN ; if ( sk -> sk_user_data == NULL ) goto end ; err = - EBADF ; session = pppol2tp_sock_to_session ( sk ) ; if ( session == NULL ) goto end ; ps = l2tp_session_priv ( session ) ; if ( ( session -> session_id == 0 ) && ( session -> peer_session_id == 0 ) ) { err = - EBADF ; tunnel = l2tp_sock_to_tunnel ( ps -> tunnel_sock ) ; if ( tunnel == NULL ) goto end_put_sess ; err = pppol2tp_tunnel_getsockopt ( sk , tunnel , optname , & val ) ; sock_put ( ps -> tunnel_sock ) ; } else err = pppol2tp_session_getsockopt ( sk , session , optname , & val ) ; err = - EFAULT ; if ( put_user ( len , optlen ) ) goto end_put_sess ; if ( copy_to_user ( ( void __user * ) optval , & val , len ) ) goto end_put_sess ; err = 0 ; end_put_sess : sock_put ( sk ) ; end : return err ; }
int main ( int argc , char * * argv ) { int error ; my_bool first_argument_uses_wildcards = 0 ; char * wild ; MYSQL mysql ; MY_INIT ( argv [ 0 ] ) ; my_getopt_use_args_separator = TRUE ; if ( load_defaults ( "my" , load_default_groups , & argc , & argv ) ) exit ( 1 ) ; my_getopt_use_args_separator = FALSE ; get_options ( & argc , & argv ) ; wild = 0 ; if ( argc ) { char * pos = argv [ argc - 1 ] , * to ; for ( to = pos ; * pos ; pos ++ , to ++ ) { switch ( * pos ) { case '*' : * pos = '%' ; first_argument_uses_wildcards = 1 ; break ; case '?' : * pos = '_' ; first_argument_uses_wildcards = 1 ; break ; case '%' : case '_' : first_argument_uses_wildcards = 1 ; break ; case '\\\\' : pos ++ ; default : break ; } * to = * pos ; } * to = * pos ; } if ( first_argument_uses_wildcards ) wild = argv [ -- argc ] ; else if ( argc == 3 ) wild = argv [ -- argc ] ; if ( argc > 2 ) { fprintf ( stderr , "%s:<S2SV_blank>Too<S2SV_blank>many<S2SV_blank>arguments\\n" , my_progname ) ; exit ( 1 ) ; } mysql_init ( & mysql ) ; if ( opt_compress ) mysql_options ( & mysql , MYSQL_OPT_COMPRESS , NullS ) ; <S2SV_StartBug> # ifdef HAVE_OPENSSL <S2SV_EndBug> if ( opt_use_ssl ) { mysql_ssl_set ( & mysql , opt_ssl_key , opt_ssl_cert , opt_ssl_ca , opt_ssl_capath , opt_ssl_cipher ) ; mysql_options ( & mysql , MYSQL_OPT_SSL_CRL , opt_ssl_crl ) ; mysql_options ( & mysql , MYSQL_OPT_SSL_CRLPATH , opt_ssl_crlpath ) ; } mysql_options ( & mysql , MYSQL_OPT_SSL_VERIFY_SERVER_CERT , ( char * ) & opt_ssl_verify_server_cert ) ; # endif if ( opt_protocol ) mysql_options ( & mysql , MYSQL_OPT_PROTOCOL , ( char * ) & opt_protocol ) ; if ( opt_bind_addr ) mysql_options ( & mysql , MYSQL_OPT_BIND , opt_bind_addr ) ; # if defined ( _WIN32 ) && ! defined ( EMBEDDED_LIBRARY ) if ( shared_memory_base_name ) mysql_options ( & mysql , MYSQL_SHARED_MEMORY_BASE_NAME , shared_memory_base_name ) ; # endif mysql_options ( & mysql , MYSQL_SET_CHARSET_NAME , default_charset ) ; if ( opt_plugin_dir && * opt_plugin_dir ) mysql_options ( & mysql , MYSQL_PLUGIN_DIR , opt_plugin_dir ) ; if ( opt_default_auth && * opt_default_auth ) mysql_options ( & mysql , MYSQL_DEFAULT_AUTH , opt_default_auth ) ; mysql_options ( & mysql , MYSQL_OPT_CONNECT_ATTR_RESET , 0 ) ; mysql_options4 ( & mysql , MYSQL_OPT_CONNECT_ATTR_ADD , "program_name" , "mysqlshow" ) ; if ( ! ( mysql_real_connect ( & mysql , host , user , opt_password , ( first_argument_uses_wildcards ) ? "" : argv [ 0 ] , opt_mysql_port , opt_mysql_unix_port , 0 ) ) ) { fprintf ( stderr , "%s:<S2SV_blank>%s\\n" , my_progname , mysql_error ( & mysql ) ) ; exit ( 1 ) ; } mysql . reconnect = 1 ; switch ( argc ) { case 0 : error = list_dbs ( & mysql , wild ) ; break ; case 1 : if ( opt_status ) error = list_table_status ( & mysql , argv [ 0 ] , wild ) ; else error = list_tables ( & mysql , argv [ 0 ] , wild ) ; break ; default : if ( opt_status && ! wild ) error = list_table_status ( & mysql , argv [ 0 ] , argv [ 1 ] ) ; else error = list_fields ( & mysql , argv [ 0 ] , argv [ 1 ] , wild ) ; break ; } mysql_close ( & mysql ) ; my_free ( opt_password ) ; # if defined ( _WIN32 ) && ! defined ( EMBEDDED_LIBRARY ) my_free ( shared_memory_base_name ) ; # endif my_end ( my_end_arg ) ; exit ( error ? 1 : 0 ) ; return 0 ; }
struct sk_buff * nf_ct_frag6_gather ( struct sk_buff * skb , u32 user ) { struct sk_buff * clone ; struct net_device * dev = skb -> dev ; struct frag_hdr * fhdr ; struct nf_ct_frag6_queue * fq ; struct ipv6hdr * hdr ; int fhoff , nhoff ; u8 prevhdr ; struct sk_buff * ret_skb = NULL ; if ( ipv6_hdr ( skb ) -> payload_len == 0 ) { pr_debug ( "payload<S2SV_blank>len<S2SV_blank>=<S2SV_blank>0\\n" ) ; return skb ; } if ( find_prev_fhdr ( skb , & prevhdr , & nhoff , & fhoff ) < 0 ) return skb ; clone = skb_clone ( skb , GFP_ATOMIC ) ; if ( clone == NULL ) { pr_debug ( "Can\'t<S2SV_blank>clone<S2SV_blank>skb\\n" ) ; return skb ; } NFCT_FRAG6_CB ( clone ) -> orig = skb ; if ( ! pskb_may_pull ( clone , fhoff + sizeof ( * fhdr ) ) ) { pr_debug ( "message<S2SV_blank>is<S2SV_blank>too<S2SV_blank>short.\\n" ) ; goto ret_orig ; } skb_set_transport_header ( clone , fhoff ) ; hdr = ipv6_hdr ( clone ) ; fhdr = ( struct frag_hdr * ) skb_transport_header ( clone ) ; <S2SV_StartBug> if ( ! ( fhdr -> frag_off & htons ( 0xFFF9 ) ) ) { <S2SV_EndBug> pr_debug ( "Invalid<S2SV_blank>fragment<S2SV_blank>offset\\n" ) ; goto ret_orig ; } if ( atomic_read ( & nf_init_frags . mem ) > nf_init_frags . high_thresh ) nf_ct_frag6_evictor ( ) ; fq = fq_find ( fhdr -> identification , user , & hdr -> saddr , & hdr -> daddr ) ; if ( fq == NULL ) { pr_debug ( "Can\'t<S2SV_blank>find<S2SV_blank>and<S2SV_blank>can\'t<S2SV_blank>create<S2SV_blank>new<S2SV_blank>queue\\n" ) ; goto ret_orig ; } spin_lock_bh ( & fq -> q . lock ) ; if ( nf_ct_frag6_queue ( fq , clone , fhdr , nhoff ) < 0 ) { spin_unlock_bh ( & fq -> q . lock ) ; pr_debug ( "Can\'t<S2SV_blank>insert<S2SV_blank>skb<S2SV_blank>to<S2SV_blank>queue\\n" ) ; fq_put ( fq ) ; goto ret_orig ; } if ( fq -> q . last_in == ( INET_FRAG_FIRST_IN | INET_FRAG_LAST_IN ) && fq -> q . meat == fq -> q . len ) { ret_skb = nf_ct_frag6_reasm ( fq , dev ) ; if ( ret_skb == NULL ) pr_debug ( "Can\'t<S2SV_blank>reassemble<S2SV_blank>fragmented<S2SV_blank>packets\\n" ) ; } spin_unlock_bh ( & fq -> q . lock ) ; fq_put ( fq ) ; return ret_skb ; ret_orig : kfree_skb ( clone ) ; return skb ; }
error_t enc624j600SendPacket ( NetInterface * interface , const NetBuffer * buffer , size_t offset , NetTxAncillary * ancillary ) { size_t length ; length = netBufferGetLength ( buffer ) - offset ; if ( length > 1536 ) { osSetEvent ( & interface -> nicTxEvent ) ; return ERROR_INVALID_LENGTH ; } if ( ! interface -> linkState ) { osSetEvent ( & interface -> nicTxEvent ) ; return NO_ERROR ; } <S2SV_StartBug> if ( enc624j600ReadReg ( interface , ENC624J600_REG_ECON1 ) & ECON1_TXRTS ) <S2SV_EndBug> { return ERROR_FAILURE ; } <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_EGPWRPT , ENC624J600_TX_BUFFER_START ) ; <S2SV_EndBug> enc624j600WriteBuffer ( interface , ENC624J600_CMD_WGPDATA , buffer , offset ) ; <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_ETXST , ENC624J600_TX_BUFFER_START ) ; <S2SV_EndBug> <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_ETXLEN , length ) ; <S2SV_EndBug> <S2SV_StartBug> enc624j600ClearBit ( interface , ENC624J600_REG_EIR , EIR_TXIF | EIR_TXABTIF ) ; <S2SV_EndBug> <S2SV_StartBug> enc624j600SetBit ( interface , ENC624J600_REG_ECON1 , ECON1_TXRTS ) ; <S2SV_EndBug> return NO_ERROR ; }
native_handle_t * native_handle_create ( int numFds , int numInts ) { <S2SV_StartBug> native_handle_t * h = malloc ( <S2SV_EndBug> <S2SV_StartBug> sizeof ( native_handle_t ) + sizeof ( int ) * ( numFds + numInts ) ) ; <S2SV_EndBug> if ( h ) { h -> version = sizeof ( native_handle_t ) ; h -> numFds = numFds ; h -> numInts = numInts ; } return h ; }
static inline void header_put_be_3byte ( SF_PRIVATE * psf , int x ) <S2SV_StartBug> { if ( psf -> headindex < SIGNED_SIZEOF ( psf -> header ) - 3 ) <S2SV_EndBug> <S2SV_StartBug> { psf -> header [ psf -> headindex ++ ] = ( x >> 16 ) ; <S2SV_EndBug> <S2SV_StartBug> psf -> header [ psf -> headindex ++ ] = ( x >> 8 ) ; <S2SV_EndBug> <S2SV_StartBug> psf -> header [ psf -> headindex ++ ] = x ; <S2SV_EndBug> <S2SV_StartBug> } ; <S2SV_EndBug> }
static inline int r_sys_mkdirp ( char * dir ) { int ret = 1 ; const char slash = DIRSEP ; char * path = dir ; char * ptr = path ; if ( * ptr == slash ) { ptr ++ ; } # if __SDB_WINDOWS__ char * p = strstr ( ptr , ":\\\\" ) ; if ( p ) { <S2SV_StartBug> ptr = p + 2 ; <S2SV_EndBug> } # endif while ( ( ptr = strchr ( ptr , slash ) ) ) { * ptr = 0 ; if ( ! r_sys_mkdir ( path ) && r_sys_mkdir_failed ( ) ) { eprintf ( "r_sys_mkdirp:<S2SV_blank>fail<S2SV_blank>\'%s\'<S2SV_blank>of<S2SV_blank>\'%s\'\\n" , path , dir ) ; * ptr = slash ; return 0 ; } * ptr = slash ; ptr ++ ; } return ret ; }
static int walk_pmd_range ( pud_t * pud , unsigned long addr , unsigned long end , struct mm_walk * walk ) { pmd_t * pmd ; unsigned long next ; int err = 0 ; pmd = pmd_offset ( pud , addr ) ; do { again : next = pmd_addr_end ( addr , end ) ; if ( pmd_none ( * pmd ) ) { if ( walk -> pte_hole ) err = walk -> pte_hole ( addr , next , walk ) ; if ( err ) break ; continue ; } if ( walk -> pmd_entry ) err = walk -> pmd_entry ( pmd , addr , next , walk ) ; if ( err ) break ; if ( ! walk -> pte_entry ) continue ; split_huge_page_pmd ( walk -> mm , pmd ) ; <S2SV_StartBug> if ( pmd_none_or_clear_bad ( pmd ) ) <S2SV_EndBug> goto again ; err = walk_pte_range ( pmd , addr , next , walk ) ; if ( err ) break ; } while ( pmd ++ , addr = next , addr != end ) ; return err ; }
IMPEG2D_ERROR_CODES_T impeg2d_dec_pic_hdr ( dec_state_t * ps_dec ) { stream_t * ps_stream ; ps_stream = & ps_dec -> s_bit_stream ; impeg2d_bit_stream_flush ( ps_stream , START_CODE_LEN ) ; impeg2d_bit_stream_get ( ps_stream , 10 ) ; ps_dec -> e_pic_type = ( e_pic_type_t ) impeg2d_bit_stream_get ( ps_stream , 3 ) ; if ( ( ps_dec -> e_pic_type < I_PIC ) || ( ps_dec -> e_pic_type > D_PIC ) ) { impeg2d_next_code ( ps_dec , PICTURE_START_CODE ) ; return IMPEG2D_INVALID_PIC_TYPE ; } impeg2d_bit_stream_get ( ps_stream , 16 ) ; if ( ps_dec -> e_pic_type == P_PIC || ps_dec -> e_pic_type == B_PIC ) { ps_dec -> u2_full_pel_forw_vector = impeg2d_bit_stream_get_bit ( ps_stream ) ; ps_dec -> u2_forw_f_code = impeg2d_bit_stream_get ( ps_stream , 3 ) ; } if ( ps_dec -> e_pic_type == B_PIC ) { ps_dec -> u2_full_pel_back_vector = impeg2d_bit_stream_get_bit ( ps_stream ) ; ps_dec -> u2_back_f_code = impeg2d_bit_stream_get ( ps_stream , 3 ) ; } if ( ps_dec -> u2_is_mpeg2 == 0 ) { ps_dec -> au2_f_code [ 0 ] [ 0 ] = ps_dec -> au2_f_code [ 0 ] [ 1 ] = ps_dec -> u2_forw_f_code ; ps_dec -> au2_f_code [ 1 ] [ 0 ] = ps_dec -> au2_f_code [ 1 ] [ 1 ] = ps_dec -> u2_back_f_code ; } <S2SV_StartBug> while ( impeg2d_bit_stream_nxt ( ps_stream , 1 ) == 1 ) <S2SV_EndBug> { impeg2d_bit_stream_get ( ps_stream , 9 ) ; } impeg2d_bit_stream_get_bit ( ps_stream ) ; impeg2d_next_start_code ( ps_dec ) ; return ( IMPEG2D_ERROR_CODES_T ) IVD_ERROR_NONE ; }
vpx_codec_err_t vpx_codec_control_ ( vpx_codec_ctx_t * ctx , int ctrl_id , ... ) { vpx_codec_err_t res ; if ( ! ctx || ! ctrl_id ) res = VPX_CODEC_INVALID_PARAM ; else if ( ! ctx -> iface || ! ctx -> priv || ! ctx -> iface -> ctrl_maps ) res = VPX_CODEC_ERROR ; else { vpx_codec_ctrl_fn_map_t * entry ; res = VPX_CODEC_ERROR ; for ( entry = ctx -> iface -> ctrl_maps ; entry && entry -> fn ; entry ++ ) { if ( ! entry -> ctrl_id || entry -> ctrl_id == ctrl_id ) { va_list ap ; va_start ( ap , ctrl_id ) ; <S2SV_StartBug> res = entry -> fn ( ctx -> priv -> alg_priv , ctrl_id , ap ) ; <S2SV_EndBug> va_end ( ap ) ; break ; } } } return SAVE_STATUS ( ctx , res ) ; }
int llc_print ( netdissect_options * ndo , const u_char * p , u_int length , u_int caplen , const struct lladdr_info * src , const struct lladdr_info * dst ) { uint8_t dsap_field , dsap , ssap_field , ssap ; uint16_t control ; int hdrlen ; int is_u ; if ( caplen < 3 ) { ND_PRINT ( ( ndo , "[|llc]" ) ) ; ND_DEFAULTPRINT ( ( const u_char * ) p , caplen ) ; return ( caplen ) ; } if ( length < 3 ) { ND_PRINT ( ( ndo , "[|llc]" ) ) ; ND_DEFAULTPRINT ( ( const u_char * ) p , caplen ) ; return ( length ) ; } dsap_field = * p ; ssap_field = * ( p + 1 ) ; control = * ( p + 2 ) ; if ( ( control & LLC_U_FMT ) == LLC_U_FMT ) { is_u = 1 ; hdrlen = 3 ; } else { if ( caplen < 4 ) { ND_PRINT ( ( ndo , "[|llc]" ) ) ; ND_DEFAULTPRINT ( ( const u_char * ) p , caplen ) ; return ( caplen ) ; } if ( length < 4 ) { ND_PRINT ( ( ndo , "[|llc]" ) ) ; ND_DEFAULTPRINT ( ( const u_char * ) p , caplen ) ; return ( length ) ; } control = EXTRACT_LE_16BITS ( p + 2 ) ; is_u = 0 ; hdrlen = 4 ; } if ( ssap_field == LLCSAP_GLOBAL && dsap_field == LLCSAP_GLOBAL ) { if ( ndo -> ndo_eflag ) ND_PRINT ( ( ndo , "IPX<S2SV_blank>802.3:<S2SV_blank>" ) ) ; ipx_print ( ndo , p , length ) ; return ( 0 ) ; } dsap = dsap_field & ~ LLC_IG ; ssap = ssap_field & ~ LLC_GSAP ; if ( ndo -> ndo_eflag ) { ND_PRINT ( ( ndo , "LLC,<S2SV_blank>dsap<S2SV_blank>%s<S2SV_blank>(0x%02x)<S2SV_blank>%s,<S2SV_blank>ssap<S2SV_blank>%s<S2SV_blank>(0x%02x)<S2SV_blank>%s" , tok2str ( llc_values , "Unknown" , dsap ) , dsap , tok2str ( llc_ig_flag_values , "Unknown" , dsap_field & LLC_IG ) , tok2str ( llc_values , "Unknown" , ssap ) , ssap , tok2str ( llc_flag_values , "Unknown" , ssap_field & LLC_GSAP ) ) ) ; if ( is_u ) { ND_PRINT ( ( ndo , ",<S2SV_blank>ctrl<S2SV_blank>0x%02x:<S2SV_blank>" , control ) ) ; } else { ND_PRINT ( ( ndo , ",<S2SV_blank>ctrl<S2SV_blank>0x%04x:<S2SV_blank>" , control ) ) ; } } p += hdrlen ; length -= hdrlen ; caplen -= hdrlen ; if ( ssap == LLCSAP_SNAP && dsap == LLCSAP_SNAP && control == LLC_UI ) { if ( ! snap_print ( ndo , p , length , caplen , src , dst , 2 ) ) { return ( - ( hdrlen + 5 ) ) ; } else return ( hdrlen + 5 ) ; } if ( ssap == LLCSAP_8021D && dsap == LLCSAP_8021D && control == LLC_UI ) { stp_print ( ndo , p , length ) ; return ( hdrlen ) ; } if ( ssap == LLCSAP_IP && dsap == LLCSAP_IP && control == LLC_UI ) { ip_print ( ndo , p , length ) ; return ( hdrlen ) ; } if ( ssap == LLCSAP_IPX && dsap == LLCSAP_IPX && control == LLC_UI ) { if ( ndo -> ndo_eflag ) ND_PRINT ( ( ndo , "IPX<S2SV_blank>802.2:<S2SV_blank>" ) ) ; ipx_print ( ndo , p , length ) ; return ( hdrlen ) ; } # ifdef ENABLE_SMB if ( ssap == LLCSAP_NETBEUI && dsap == LLCSAP_NETBEUI && ( ! ( control & LLC_S_FMT ) || control == LLC_U_FMT ) ) { netbeui_print ( ndo , control , p , length ) ; return ( hdrlen ) ; } # endif if ( ssap == LLCSAP_ISONS && dsap == LLCSAP_ISONS && control == LLC_UI ) { <S2SV_StartBug> isoclns_print ( ndo , p , length , caplen ) ; <S2SV_EndBug> return ( hdrlen ) ; } if ( ! ndo -> ndo_eflag ) { if ( ssap == dsap ) { if ( src == NULL || dst == NULL ) ND_PRINT ( ( ndo , "%s<S2SV_blank>" , tok2str ( llc_values , "Unknown<S2SV_blank>DSAP<S2SV_blank>0x%02x" , dsap ) ) ) ; else ND_PRINT ( ( ndo , "%s<S2SV_blank>><S2SV_blank>%s<S2SV_blank>%s<S2SV_blank>" , ( src -> addr_string ) ( ndo , src -> addr ) , ( dst -> addr_string ) ( ndo , dst -> addr ) , tok2str ( llc_values , "Unknown<S2SV_blank>DSAP<S2SV_blank>0x%02x" , dsap ) ) ) ; } else { if ( src == NULL || dst == NULL ) ND_PRINT ( ( ndo , "%s<S2SV_blank>><S2SV_blank>%s<S2SV_blank>" , tok2str ( llc_values , "Unknown<S2SV_blank>SSAP<S2SV_blank>0x%02x" , ssap ) , tok2str ( llc_values , "Unknown<S2SV_blank>DSAP<S2SV_blank>0x%02x" , dsap ) ) ) ; else ND_PRINT ( ( ndo , "%s<S2SV_blank>%s<S2SV_blank>><S2SV_blank>%s<S2SV_blank>%s<S2SV_blank>" , ( src -> addr_string ) ( ndo , src -> addr ) , tok2str ( llc_values , "Unknown<S2SV_blank>SSAP<S2SV_blank>0x%02x" , ssap ) , ( dst -> addr_string ) ( ndo , dst -> addr ) , tok2str ( llc_values , "Unknown<S2SV_blank>DSAP<S2SV_blank>0x%02x" , dsap ) ) ) ; } } if ( is_u ) { ND_PRINT ( ( ndo , "Unnumbered,<S2SV_blank>%s,<S2SV_blank>Flags<S2SV_blank>[%s],<S2SV_blank>length<S2SV_blank>%u" , tok2str ( llc_cmd_values , "%02x" , LLC_U_CMD ( control ) ) , tok2str ( llc_flag_values , "?" , ( ssap_field & LLC_GSAP ) | ( control & LLC_U_POLL ) ) , length + hdrlen ) ) ; if ( ( control & ~ LLC_U_POLL ) == LLC_XID ) { if ( length == 0 ) { return ( hdrlen ) ; } if ( caplen < 1 ) { ND_PRINT ( ( ndo , "[|llc]" ) ) ; if ( caplen > 0 ) ND_DEFAULTPRINT ( ( const u_char * ) p , caplen ) ; return ( hdrlen ) ; } if ( * p == LLC_XID_FI ) { if ( caplen < 3 || length < 3 ) { ND_PRINT ( ( ndo , "[|llc]" ) ) ; if ( caplen > 0 ) ND_DEFAULTPRINT ( ( const u_char * ) p , caplen ) ; } else ND_PRINT ( ( ndo , ":<S2SV_blank>%02x<S2SV_blank>%02x" , p [ 1 ] , p [ 2 ] ) ) ; return ( hdrlen ) ; } } } else { if ( ( control & LLC_S_FMT ) == LLC_S_FMT ) { ND_PRINT ( ( ndo , "Supervisory,<S2SV_blank>%s,<S2SV_blank>rcv<S2SV_blank>seq<S2SV_blank>%u,<S2SV_blank>Flags<S2SV_blank>[%s],<S2SV_blank>length<S2SV_blank>%u" , tok2str ( llc_supervisory_values , "?" , LLC_S_CMD ( control ) ) , LLC_IS_NR ( control ) , tok2str ( llc_flag_values , "?" , ( ssap_field & LLC_GSAP ) | ( control & LLC_IS_POLL ) ) , length + hdrlen ) ) ; return ( hdrlen ) ; } else { ND_PRINT ( ( ndo , "Information,<S2SV_blank>send<S2SV_blank>seq<S2SV_blank>%u,<S2SV_blank>rcv<S2SV_blank>seq<S2SV_blank>%u,<S2SV_blank>Flags<S2SV_blank>[%s],<S2SV_blank>length<S2SV_blank>%u" , LLC_I_NS ( control ) , LLC_IS_NR ( control ) , tok2str ( llc_flag_values , "?" , ( ssap_field & LLC_GSAP ) | ( control & LLC_IS_POLL ) ) , length + hdrlen ) ) ; } } return ( - hdrlen ) ; }
int dtls1_get_record ( SSL * s ) { int ssl_major , ssl_minor ; int i , n ; SSL3_RECORD * rr ; unsigned char * p = NULL ; unsigned short version ; DTLS1_BITMAP * bitmap ; unsigned int is_next_epoch ; rr = & ( s -> s3 -> rrec ) ; dtls1_process_buffered_records ( s ) ; if ( dtls1_get_processed_record ( s ) ) return 1 ; again : if ( ( s -> rstate != SSL_ST_READ_BODY ) || ( s -> packet_length < DTLS1_RT_HEADER_LENGTH ) ) { n = ssl3_read_n ( s , DTLS1_RT_HEADER_LENGTH , s -> s3 -> rbuf . len , 0 ) ; if ( n <= 0 ) return ( n ) ; if ( s -> packet_length != DTLS1_RT_HEADER_LENGTH ) { s -> packet_length = 0 ; goto again ; } s -> rstate = SSL_ST_READ_BODY ; p = s -> packet ; if ( s -> msg_callback ) s -> msg_callback ( 0 , 0 , SSL3_RT_HEADER , p , DTLS1_RT_HEADER_LENGTH , s , s -> msg_callback_arg ) ; rr -> type = * ( p ++ ) ; ssl_major = * ( p ++ ) ; ssl_minor = * ( p ++ ) ; version = ( ssl_major << 8 ) | ssl_minor ; n2s ( p , rr -> epoch ) ; memcpy ( & ( s -> s3 -> read_sequence [ 2 ] ) , p , 6 ) ; p += 6 ; n2s ( p , rr -> length ) ; if ( ! s -> first_packet ) { if ( version != s -> version ) { rr -> length = 0 ; s -> packet_length = 0 ; goto again ; } } if ( ( version & 0xff00 ) != ( s -> version & 0xff00 ) ) { rr -> length = 0 ; s -> packet_length = 0 ; goto again ; } if ( rr -> length > SSL3_RT_MAX_ENCRYPTED_LENGTH ) { rr -> length = 0 ; s -> packet_length = 0 ; goto again ; } } if ( rr -> length > s -> packet_length - DTLS1_RT_HEADER_LENGTH ) { i = rr -> length ; n = ssl3_read_n ( s , i , i , 1 ) ; if ( n != i ) { rr -> length = 0 ; s -> packet_length = 0 ; goto again ; } } s -> rstate = SSL_ST_READ_HEADER ; bitmap = dtls1_get_bitmap ( s , rr , & is_next_epoch ) ; if ( bitmap == NULL ) { rr -> length = 0 ; s -> packet_length = 0 ; goto again ; } # ifndef OPENSSL_NO_SCTP if ( ! BIO_dgram_is_sctp ( SSL_get_rbio ( s ) ) ) { # endif if ( ! ( s -> d1 -> listen && rr -> type == SSL3_RT_HANDSHAKE && <S2SV_StartBug> * p == SSL3_MT_CLIENT_HELLO ) && <S2SV_EndBug> ! dtls1_record_replay_check ( s , bitmap ) ) { rr -> length = 0 ; s -> packet_length = 0 ; goto again ; } # ifndef OPENSSL_NO_SCTP } # endif if ( rr -> length == 0 ) goto again ; if ( is_next_epoch ) { if ( ( SSL_in_init ( s ) || s -> in_handshake ) && ! s -> d1 -> listen ) { dtls1_buffer_record ( s , & ( s -> d1 -> unprocessed_rcds ) , rr -> seq_num ) ; } rr -> length = 0 ; s -> packet_length = 0 ; goto again ; } if ( ! dtls1_process_record ( s ) ) { rr -> length = 0 ; s -> packet_length = 0 ; goto again ; } return ( 1 ) ; }
static expr_ty ast_for_decorator ( struct compiling * c , const node * n ) { expr_ty d = NULL ; expr_ty name_expr ; REQ ( n , decorator ) ; REQ ( CHILD ( n , 0 ) , AT ) ; REQ ( RCHILD ( n , - 1 ) , NEWLINE ) ; name_expr = ast_for_dotted_name ( c , CHILD ( n , 1 ) ) ; if ( ! name_expr ) return NULL ; if ( NCH ( n ) == 3 ) { d = name_expr ; name_expr = NULL ; } else if ( NCH ( n ) == 5 ) { d = Call ( name_expr , NULL , NULL , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; if ( ! d ) return NULL ; name_expr = NULL ; } else { <S2SV_StartBug> d = ast_for_call ( c , CHILD ( n , 3 ) , name_expr ) ; <S2SV_EndBug> if ( ! d ) return NULL ; name_expr = NULL ; } return d ; }
static int snd_ctl_elem_add ( struct snd_ctl_file * file , struct snd_ctl_elem_info * info , int replace ) { struct snd_card * card = file -> card ; struct snd_kcontrol kctl , * _kctl ; unsigned int access ; long private_size ; struct user_element * ue ; int idx , err ; if ( ! replace && card -> user_ctl_count >= MAX_USER_CONTROLS ) return - ENOMEM ; if ( info -> count < 1 ) return - EINVAL ; access = info -> access == 0 ? SNDRV_CTL_ELEM_ACCESS_READWRITE : ( info -> access & ( SNDRV_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_ACCESS_INACTIVE | SNDRV_CTL_ELEM_ACCESS_TLV_READWRITE ) ) ; info -> id . numid = 0 ; memset ( & kctl , 0 , sizeof ( kctl ) ) ; down_write ( & card -> controls_rwsem ) ; _kctl = snd_ctl_find_id ( card , & info -> id ) ; err = 0 ; if ( _kctl ) { if ( replace ) err = snd_ctl_remove ( card , _kctl ) ; else err = - EBUSY ; } else { if ( replace ) err = - ENOENT ; } up_write ( & card -> controls_rwsem ) ; if ( err < 0 ) return err ; memcpy ( & kctl . id , & info -> id , sizeof ( info -> id ) ) ; kctl . count = info -> owner ? info -> owner : 1 ; access |= SNDRV_CTL_ELEM_ACCESS_USER ; if ( info -> type == SNDRV_CTL_ELEM_TYPE_ENUMERATED ) kctl . info = snd_ctl_elem_user_enum_info ; else kctl . info = snd_ctl_elem_user_info ; if ( access & SNDRV_CTL_ELEM_ACCESS_READ ) kctl . get = snd_ctl_elem_user_get ; if ( access & SNDRV_CTL_ELEM_ACCESS_WRITE ) kctl . put = snd_ctl_elem_user_put ; if ( access & SNDRV_CTL_ELEM_ACCESS_TLV_READWRITE ) { kctl . tlv . c = snd_ctl_elem_user_tlv ; access |= SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK ; } switch ( info -> type ) { case SNDRV_CTL_ELEM_TYPE_BOOLEAN : case SNDRV_CTL_ELEM_TYPE_INTEGER : private_size = sizeof ( long ) ; if ( info -> count > 128 ) return - EINVAL ; break ; case SNDRV_CTL_ELEM_TYPE_INTEGER64 : private_size = sizeof ( long long ) ; if ( info -> count > 64 ) return - EINVAL ; break ; case SNDRV_CTL_ELEM_TYPE_ENUMERATED : private_size = sizeof ( unsigned int ) ; if ( info -> count > 128 || info -> value . enumerated . items == 0 ) return - EINVAL ; break ; case SNDRV_CTL_ELEM_TYPE_BYTES : private_size = sizeof ( unsigned char ) ; if ( info -> count > 512 ) return - EINVAL ; break ; case SNDRV_CTL_ELEM_TYPE_IEC958 : private_size = sizeof ( struct snd_aes_iec958 ) ; if ( info -> count != 1 ) return - EINVAL ; break ; default : return - EINVAL ; } private_size *= info -> count ; ue = kzalloc ( sizeof ( struct user_element ) + private_size , GFP_KERNEL ) ; if ( ue == NULL ) return - ENOMEM ; <S2SV_StartBug> ue -> info = * info ; <S2SV_EndBug> ue -> info . access = 0 ; ue -> elem_data = ( char * ) ue + sizeof ( * ue ) ; ue -> elem_data_size = private_size ; if ( ue -> info . type == SNDRV_CTL_ELEM_TYPE_ENUMERATED ) { err = snd_ctl_elem_init_enum_names ( ue ) ; if ( err < 0 ) { kfree ( ue ) ; return err ; } } kctl . private_free = snd_ctl_elem_user_free ; _kctl = snd_ctl_new ( & kctl , access ) ; if ( _kctl == NULL ) { kfree ( ue -> priv_data ) ; kfree ( ue ) ; return - ENOMEM ; } _kctl -> private_data = ue ; for ( idx = 0 ; idx < _kctl -> count ; idx ++ ) _kctl -> vd [ idx ] . owner = file ; err = snd_ctl_add ( card , _kctl ) ; if ( err < 0 ) return err ; down_write ( & card -> controls_rwsem ) ; card -> user_ctl_count ++ ; up_write ( & card -> controls_rwsem ) ; return 0 ; }
static int scm_fp_copy ( struct cmsghdr * cmsg , struct scm_fp_list * * fplp ) { int * fdp = ( int * ) CMSG_DATA ( cmsg ) ; struct scm_fp_list * fpl = * fplp ; struct file * * fpp ; int i , num ; num = ( cmsg -> cmsg_len - CMSG_ALIGN ( sizeof ( struct cmsghdr ) ) ) / sizeof ( int ) ; if ( num <= 0 ) return 0 ; if ( num > SCM_MAX_FD ) return - EINVAL ; if ( ! fpl ) { fpl = kmalloc ( sizeof ( struct scm_fp_list ) , GFP_KERNEL ) ; if ( ! fpl ) return - ENOMEM ; * fplp = fpl ; fpl -> count = 0 ; fpl -> max = SCM_MAX_FD ; <S2SV_StartBug> } <S2SV_EndBug> fpp = & fpl -> fp [ fpl -> count ] ; if ( fpl -> count + num > fpl -> max ) return - EINVAL ; for ( i = 0 ; i < num ; i ++ ) { int fd = fdp [ i ] ; struct file * file ; if ( fd < 0 || ! ( file = fget_raw ( fd ) ) ) return - EBADF ; * fpp ++ = file ; fpl -> count ++ ; } <S2SV_StartBug> return num ; <S2SV_EndBug> }
static int adjust_scalar_min_max_vals ( struct bpf_verifier_env * env , struct bpf_insn * insn , struct bpf_reg_state * dst_reg , struct bpf_reg_state src_reg ) { struct bpf_reg_state * regs = cur_regs ( env ) ; u8 opcode = BPF_OP ( insn -> code ) ; bool src_known , dst_known ; s64 smin_val , smax_val ; u64 umin_val , umax_val ; <S2SV_StartBug> u64 insn_bitness = ( BPF_CLASS ( insn -> code ) == BPF_ALU64 ) ? 64 : 32 ; <S2SV_EndBug> smin_val = src_reg . smin_value ; smax_val = src_reg . smax_value ; umin_val = src_reg . umin_value ; umax_val = src_reg . umax_value ; src_known = tnum_is_const ( src_reg . var_off ) ; dst_known = tnum_is_const ( dst_reg -> var_off ) ; if ( ( src_known && ( smin_val != smax_val || umin_val != umax_val ) ) || smin_val > smax_val || umin_val > umax_val ) { __mark_reg_unknown ( dst_reg ) ; return 0 ; } if ( ! src_known && opcode != BPF_ADD && opcode != BPF_SUB && opcode != BPF_AND ) { __mark_reg_unknown ( dst_reg ) ; return 0 ; } switch ( opcode ) { case BPF_ADD : if ( signed_add_overflows ( dst_reg -> smin_value , smin_val ) || signed_add_overflows ( dst_reg -> smax_value , smax_val ) ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value += smin_val ; dst_reg -> smax_value += smax_val ; } if ( dst_reg -> umin_value + umin_val < umin_val || dst_reg -> umax_value + umax_val < umax_val ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value += umin_val ; dst_reg -> umax_value += umax_val ; } dst_reg -> var_off = tnum_add ( dst_reg -> var_off , src_reg . var_off ) ; break ; case BPF_SUB : if ( signed_sub_overflows ( dst_reg -> smin_value , smax_val ) || signed_sub_overflows ( dst_reg -> smax_value , smin_val ) ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value -= smax_val ; dst_reg -> smax_value -= smin_val ; } if ( dst_reg -> umin_value < umax_val ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value -= umax_val ; dst_reg -> umax_value -= umin_val ; } dst_reg -> var_off = tnum_sub ( dst_reg -> var_off , src_reg . var_off ) ; break ; case BPF_MUL : dst_reg -> var_off = tnum_mul ( dst_reg -> var_off , src_reg . var_off ) ; if ( smin_val < 0 || dst_reg -> smin_value < 0 ) { __mark_reg_unbounded ( dst_reg ) ; __update_reg_bounds ( dst_reg ) ; break ; } if ( umax_val > U32_MAX || dst_reg -> umax_value > U32_MAX ) { __mark_reg_unbounded ( dst_reg ) ; __update_reg_bounds ( dst_reg ) ; break ; } dst_reg -> umin_value *= umin_val ; dst_reg -> umax_value *= umax_val ; if ( dst_reg -> umax_value > S64_MAX ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } break ; case BPF_AND : if ( src_known && dst_known ) { __mark_reg_known ( dst_reg , dst_reg -> var_off . value & src_reg . var_off . value ) ; break ; } dst_reg -> var_off = tnum_and ( dst_reg -> var_off , src_reg . var_off ) ; dst_reg -> umin_value = dst_reg -> var_off . value ; dst_reg -> umax_value = min ( dst_reg -> umax_value , umax_val ) ; if ( dst_reg -> smin_value < 0 || smin_val < 0 ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } __update_reg_bounds ( dst_reg ) ; break ; case BPF_OR : if ( src_known && dst_known ) { __mark_reg_known ( dst_reg , dst_reg -> var_off . value | src_reg . var_off . value ) ; break ; } dst_reg -> var_off = tnum_or ( dst_reg -> var_off , src_reg . var_off ) ; dst_reg -> umin_value = max ( dst_reg -> umin_value , umin_val ) ; dst_reg -> umax_value = dst_reg -> var_off . value | dst_reg -> var_off . mask ; if ( dst_reg -> smin_value < 0 || smin_val < 0 ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } __update_reg_bounds ( dst_reg ) ; break ; case BPF_LSH : if ( umax_val >= insn_bitness ) { mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; if ( dst_reg -> umax_value > 1ULL << ( 63 - umax_val ) ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value <<= umin_val ; dst_reg -> umax_value <<= umax_val ; } dst_reg -> var_off = tnum_lshift ( dst_reg -> var_off , umin_val ) ; __update_reg_bounds ( dst_reg ) ; break ; case BPF_RSH : if ( umax_val >= insn_bitness ) { mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; dst_reg -> var_off = tnum_rshift ( dst_reg -> var_off , umin_val ) ; dst_reg -> umin_value >>= umax_val ; dst_reg -> umax_value >>= umin_val ; __update_reg_bounds ( dst_reg ) ; break ; case BPF_ARSH : if ( umax_val >= insn_bitness ) { mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } dst_reg -> smin_value >>= umin_val ; dst_reg -> smax_value >>= umin_val ; dst_reg -> var_off = tnum_arshift ( dst_reg -> var_off , umin_val ) ; dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; __update_reg_bounds ( dst_reg ) ; break ; default : mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } if ( BPF_CLASS ( insn -> code ) != BPF_ALU64 ) { coerce_reg_to_size ( dst_reg , 4 ) ; <S2SV_StartBug> coerce_reg_to_size ( & src_reg , 4 ) ; <S2SV_EndBug> } __reg_deduce_bounds ( dst_reg ) ; __reg_bound_offset ( dst_reg ) ; return 0 ; }
static ssize_t bat_socket_read ( struct file * file , char __user * buf , size_t count , loff_t * ppos ) { struct socket_client * socket_client = file -> private_data ; struct socket_packet * socket_packet ; size_t packet_len ; int error ; if ( ( file -> f_flags & O_NONBLOCK ) && ( socket_client -> queue_len == 0 ) ) return - EAGAIN ; if ( ( ! buf ) || ( count < sizeof ( struct icmp_packet ) ) ) return - EINVAL ; if ( ! access_ok ( VERIFY_WRITE , buf , count ) ) return - EFAULT ; error = wait_event_interruptible ( socket_client -> queue_wait , socket_client -> queue_len ) ; if ( error ) return error ; spin_lock_bh ( & socket_client -> lock ) ; socket_packet = list_first_entry ( & socket_client -> queue_list , struct socket_packet , list ) ; list_del ( & socket_packet -> list ) ; socket_client -> queue_len -- ; spin_unlock_bh ( & socket_client -> lock ) ; <S2SV_StartBug> error = copy_to_user ( buf , & socket_packet -> icmp_packet , <S2SV_EndBug> <S2SV_StartBug> socket_packet -> icmp_len ) ; <S2SV_EndBug> packet_len = socket_packet -> icmp_len ; kfree ( socket_packet ) ; if ( error ) return - EFAULT ; return packet_len ; }
static void rfbProcessClientNormalMessage ( rfbClientPtr cl ) { int n ; rfbClientToServerMsg msg ; char * str ; READ ( ( char * ) & msg , 1 ) switch ( msg . type ) { case rfbSetPixelFormat : READ ( ( ( char * ) & msg ) + 1 , sz_rfbSetPixelFormatMsg - 1 ) cl -> format . bitsPerPixel = msg . spf . format . bitsPerPixel ; cl -> format . depth = msg . spf . format . depth ; cl -> format . bigEndian = ( msg . spf . format . bigEndian ? 1 : 0 ) ; cl -> format . trueColour = ( msg . spf . format . trueColour ? 1 : 0 ) ; cl -> format . redMax = Swap16IfLE ( msg . spf . format . redMax ) ; cl -> format . greenMax = Swap16IfLE ( msg . spf . format . greenMax ) ; cl -> format . blueMax = Swap16IfLE ( msg . spf . format . blueMax ) ; cl -> format . redShift = msg . spf . format . redShift ; cl -> format . greenShift = msg . spf . format . greenShift ; cl -> format . blueShift = msg . spf . format . blueShift ; cl -> readyForSetColourMapEntries = TRUE ; rfbSetTranslateFunction ( cl ) ; return ; case rfbFixColourMapEntries : READ ( ( ( char * ) & msg ) + 1 , sz_rfbFixColourMapEntriesMsg - 1 ) rfbLog ( "rfbProcessClientNormalMessage:<S2SV_blank>FixColourMapEntries<S2SV_blank>unsupported\\n" ) ; rfbCloseClient ( cl ) ; return ; case rfbSetEncodings : { int i ; CARD32 enc ; Bool firstFence = ! cl -> enableFence ; Bool firstCU = ! cl -> enableCU ; Bool firstGII = ! cl -> enableGII ; Bool logTightCompressLevel = FALSE ; READ ( ( ( char * ) & msg ) + 1 , sz_rfbSetEncodingsMsg - 1 ) msg . se . nEncodings = Swap16IfLE ( msg . se . nEncodings ) ; cl -> preferredEncoding = - 1 ; cl -> useCopyRect = FALSE ; cl -> enableCursorShapeUpdates = FALSE ; cl -> enableCursorPosUpdates = FALSE ; cl -> enableLastRectEncoding = FALSE ; cl -> tightCompressLevel = TIGHT_DEFAULT_COMPRESSION ; cl -> tightSubsampLevel = TIGHT_DEFAULT_SUBSAMP ; cl -> tightQualityLevel = - 1 ; cl -> imageQualityLevel = - 1 ; for ( i = 0 ; i < msg . se . nEncodings ; i ++ ) { READ ( ( char * ) & enc , 4 ) enc = Swap32IfLE ( enc ) ; switch ( enc ) { case rfbEncodingCopyRect : cl -> useCopyRect = TRUE ; break ; case rfbEncodingRaw : if ( cl -> preferredEncoding == - 1 ) { cl -> preferredEncoding = enc ; rfbLog ( "Using<S2SV_blank>raw<S2SV_blank>encoding<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n" , cl -> host ) ; } break ; case rfbEncodingRRE : if ( cl -> preferredEncoding == - 1 ) { cl -> preferredEncoding = enc ; rfbLog ( "Using<S2SV_blank>rre<S2SV_blank>encoding<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n" , cl -> host ) ; } break ; case rfbEncodingCoRRE : if ( cl -> preferredEncoding == - 1 ) { cl -> preferredEncoding = enc ; rfbLog ( "Using<S2SV_blank>CoRRE<S2SV_blank>encoding<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n" , cl -> host ) ; } break ; case rfbEncodingHextile : if ( cl -> preferredEncoding == - 1 ) { cl -> preferredEncoding = enc ; rfbLog ( "Using<S2SV_blank>hextile<S2SV_blank>encoding<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n" , cl -> host ) ; } break ; case rfbEncodingZlib : if ( cl -> preferredEncoding == - 1 ) { cl -> preferredEncoding = enc ; rfbLog ( "Using<S2SV_blank>zlib<S2SV_blank>encoding<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n" , cl -> host ) ; } break ; case rfbEncodingZRLE : if ( cl -> preferredEncoding == - 1 ) { cl -> preferredEncoding = enc ; rfbLog ( "Using<S2SV_blank>ZRLE<S2SV_blank>encoding<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n" , cl -> host ) ; } break ; case rfbEncodingZYWRLE : if ( cl -> preferredEncoding == - 1 ) { cl -> preferredEncoding = enc ; rfbLog ( "Using<S2SV_blank>ZYWRLE<S2SV_blank>encoding<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n" , cl -> host ) ; } break ; case rfbEncodingTight : if ( cl -> preferredEncoding == - 1 ) { cl -> preferredEncoding = enc ; rfbLog ( "Using<S2SV_blank>tight<S2SV_blank>encoding<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n" , cl -> host ) ; } break ; case rfbEncodingXCursor : if ( ! cl -> enableCursorShapeUpdates ) { rfbLog ( "Enabling<S2SV_blank>X-style<S2SV_blank>cursor<S2SV_blank>updates<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n" , cl -> host ) ; cl -> enableCursorShapeUpdates = TRUE ; cl -> useRichCursorEncoding = FALSE ; cl -> cursorWasChanged = TRUE ; } break ; case rfbEncodingRichCursor : if ( ! cl -> enableCursorShapeUpdates ) { rfbLog ( "Enabling<S2SV_blank>full-color<S2SV_blank>cursor<S2SV_blank>updates<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n" , cl -> host ) ; cl -> enableCursorShapeUpdates = TRUE ; cl -> useRichCursorEncoding = TRUE ; cl -> cursorWasChanged = TRUE ; } break ; case rfbEncodingPointerPos : if ( ! cl -> enableCursorPosUpdates ) { rfbLog ( "Enabling<S2SV_blank>cursor<S2SV_blank>position<S2SV_blank>updates<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n" , cl -> host ) ; cl -> enableCursorPosUpdates = TRUE ; cl -> cursorWasMoved = TRUE ; cl -> cursorX = - 1 ; cl -> cursorY = - 1 ; } break ; case rfbEncodingLastRect : if ( ! cl -> enableLastRectEncoding ) { rfbLog ( "Enabling<S2SV_blank>LastRect<S2SV_blank>protocol<S2SV_blank>extension<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n" , cl -> host ) ; cl -> enableLastRectEncoding = TRUE ; } break ; case rfbEncodingFence : if ( ! cl -> enableFence ) { rfbLog ( "Enabling<S2SV_blank>Fence<S2SV_blank>protocol<S2SV_blank>extension<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n" , cl -> host ) ; cl -> enableFence = TRUE ; } break ; case rfbEncodingContinuousUpdates : if ( ! cl -> enableCU ) { rfbLog ( "Enabling<S2SV_blank>Continuous<S2SV_blank>Updates<S2SV_blank>protocol<S2SV_blank>extension<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n" , cl -> host ) ; cl -> enableCU = TRUE ; } break ; case rfbEncodingNewFBSize : if ( ! cl -> enableDesktopSize ) { if ( ! rfbAuthDisableRemoteResize ) { rfbLog ( "Enabling<S2SV_blank>Desktop<S2SV_blank>Size<S2SV_blank>protocol<S2SV_blank>extension<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n" , cl -> host ) ; cl -> enableDesktopSize = TRUE ; } else rfbLog ( "WARNING:<S2SV_blank>Remote<S2SV_blank>desktop<S2SV_blank>resizing<S2SV_blank>disabled<S2SV_blank>per<S2SV_blank>system<S2SV_blank>policy.\\n" ) ; } break ; case rfbEncodingExtendedDesktopSize : if ( ! cl -> enableExtDesktopSize ) { if ( ! rfbAuthDisableRemoteResize ) { rfbLog ( "Enabling<S2SV_blank>Extended<S2SV_blank>Desktop<S2SV_blank>Size<S2SV_blank>protocol<S2SV_blank>extension<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n" , cl -> host ) ; cl -> enableExtDesktopSize = TRUE ; } else rfbLog ( "WARNING:<S2SV_blank>Remote<S2SV_blank>desktop<S2SV_blank>resizing<S2SV_blank>disabled<S2SV_blank>per<S2SV_blank>system<S2SV_blank>policy.\\n" ) ; } break ; case rfbEncodingGII : if ( ! cl -> enableGII ) { rfbLog ( "Enabling<S2SV_blank>GII<S2SV_blank>extension<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n" , cl -> host ) ; cl -> enableGII = TRUE ; } break ; default : if ( enc >= ( CARD32 ) rfbEncodingCompressLevel0 && enc <= ( CARD32 ) rfbEncodingCompressLevel9 ) { cl -> zlibCompressLevel = enc & 0x0F ; cl -> tightCompressLevel = enc & 0x0F ; if ( cl -> preferredEncoding == rfbEncodingTight ) logTightCompressLevel = TRUE ; else rfbLog ( "Using<S2SV_blank>compression<S2SV_blank>level<S2SV_blank>%d<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n" , cl -> tightCompressLevel , cl -> host ) ; if ( rfbInterframe == - 1 ) { if ( cl -> tightCompressLevel >= 5 ) { if ( ! InterframeOn ( cl ) ) { rfbCloseClient ( cl ) ; return ; } } else InterframeOff ( cl ) ; } } else if ( enc >= ( CARD32 ) rfbEncodingSubsamp1X && enc <= ( CARD32 ) rfbEncodingSubsampGray ) { cl -> tightSubsampLevel = enc & 0xFF ; rfbLog ( "Using<S2SV_blank>JPEG<S2SV_blank>subsampling<S2SV_blank>%d<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n" , cl -> tightSubsampLevel , cl -> host ) ; } else if ( enc >= ( CARD32 ) rfbEncodingQualityLevel0 && enc <= ( CARD32 ) rfbEncodingQualityLevel9 ) { cl -> tightQualityLevel = JPEG_QUAL [ enc & 0x0F ] ; cl -> tightSubsampLevel = JPEG_SUBSAMP [ enc & 0x0F ] ; cl -> imageQualityLevel = enc & 0x0F ; if ( cl -> preferredEncoding == rfbEncodingTight ) rfbLog ( "Using<S2SV_blank>JPEG<S2SV_blank>subsampling<S2SV_blank>%d,<S2SV_blank>Q%d<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n" , cl -> tightSubsampLevel , cl -> tightQualityLevel , cl -> host ) ; else rfbLog ( "Using<S2SV_blank>image<S2SV_blank>quality<S2SV_blank>level<S2SV_blank>%d<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n" , cl -> imageQualityLevel , cl -> host ) ; } else if ( enc >= ( CARD32 ) rfbEncodingFineQualityLevel0 + 1 && enc <= ( CARD32 ) rfbEncodingFineQualityLevel100 ) { cl -> tightQualityLevel = enc & 0xFF ; rfbLog ( "Using<S2SV_blank>JPEG<S2SV_blank>quality<S2SV_blank>%d<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n" , cl -> tightQualityLevel , cl -> host ) ; } else { rfbLog ( "rfbProcessClientNormalMessage:<S2SV_blank>ignoring<S2SV_blank>unknown<S2SV_blank>encoding<S2SV_blank>%d<S2SV_blank>(%x)\\n" , ( int ) enc , ( int ) enc ) ; } } } if ( cl -> preferredEncoding == - 1 ) cl -> preferredEncoding = rfbEncodingTight ; if ( cl -> preferredEncoding == rfbEncodingTight && logTightCompressLevel ) rfbLog ( "Using<S2SV_blank>Tight<S2SV_blank>compression<S2SV_blank>level<S2SV_blank>%d<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n" , rfbTightCompressLevel ( cl ) , cl -> host ) ; if ( cl -> enableCursorPosUpdates && ! cl -> enableCursorShapeUpdates ) { rfbLog ( "Disabling<S2SV_blank>cursor<S2SV_blank>position<S2SV_blank>updates<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s\\n" , cl -> host ) ; cl -> enableCursorPosUpdates = FALSE ; } if ( cl -> enableFence && firstFence ) { if ( ! rfbSendFence ( cl , rfbFenceFlagRequest , 0 , NULL ) ) return ; } if ( cl -> enableCU && cl -> enableFence && firstCU ) { if ( ! rfbSendEndOfCU ( cl ) ) return ; } if ( cl -> enableGII && firstGII ) { rfbGIIServerVersionMsg msg ; msg . type = rfbGIIServer ; msg . endianAndSubType = rfbGIIVersion | rfbGIIBE ; msg . length = Swap16IfLE ( sz_rfbGIIServerVersionMsg - 4 ) ; msg . maximumVersion = msg . minimumVersion = Swap16IfLE ( 1 ) ; if ( WriteExact ( cl , ( char * ) & msg , sz_rfbGIIServerVersionMsg ) < 0 ) { rfbLogPerror ( "rfbProcessClientNormalMessage:<S2SV_blank>write" ) ; rfbCloseClient ( cl ) ; return ; } } return ; } case rfbFramebufferUpdateRequest : { RegionRec tmpRegion ; BoxRec box ; READ ( ( ( char * ) & msg ) + 1 , sz_rfbFramebufferUpdateRequestMsg - 1 ) box . x1 = Swap16IfLE ( msg . fur . x ) ; box . y1 = Swap16IfLE ( msg . fur . y ) ; box . x2 = box . x1 + Swap16IfLE ( msg . fur . w ) ; box . y2 = box . y1 + Swap16IfLE ( msg . fur . h ) ; SAFE_REGION_INIT ( pScreen , & tmpRegion , & box , 0 ) ; if ( ! msg . fur . incremental || ! cl -> continuousUpdates ) REGION_UNION ( pScreen , & cl -> requestedRegion , & cl -> requestedRegion , & tmpRegion ) ; if ( ! cl -> readyForSetColourMapEntries ) { cl -> readyForSetColourMapEntries = TRUE ; if ( ! cl -> format . trueColour ) { if ( ! rfbSetClientColourMap ( cl , 0 , 0 ) ) { REGION_UNINIT ( pScreen , & tmpRegion ) ; return ; } } } if ( ! msg . fur . incremental ) { REGION_UNION ( pScreen , & cl -> modifiedRegion , & cl -> modifiedRegion , & tmpRegion ) ; REGION_SUBTRACT ( pScreen , & cl -> copyRegion , & cl -> copyRegion , & tmpRegion ) ; REGION_UNION ( pScreen , & cl -> ifRegion , & cl -> ifRegion , & tmpRegion ) ; cl -> pendingExtDesktopResize = TRUE ; } if ( FB_UPDATE_PENDING ( cl ) && ( ! cl -> deferredUpdateScheduled || rfbDeferUpdateTime == 0 || gettime ( ) - cl -> deferredUpdateStart >= ( double ) rfbDeferUpdateTime ) ) { if ( rfbSendFramebufferUpdate ( cl ) ) cl -> deferredUpdateScheduled = FALSE ; } REGION_UNINIT ( pScreen , & tmpRegion ) ; return ; } case rfbKeyEvent : cl -> rfbKeyEventsRcvd ++ ; READ ( ( ( char * ) & msg ) + 1 , sz_rfbKeyEventMsg - 1 ) if ( ! rfbViewOnly && ! cl -> viewOnly ) KeyEvent ( ( KeySym ) Swap32IfLE ( msg . ke . key ) , msg . ke . down ) ; return ; case rfbPointerEvent : cl -> rfbPointerEventsRcvd ++ ; READ ( ( ( char * ) & msg ) + 1 , sz_rfbPointerEventMsg - 1 ) if ( pointerClient && ( pointerClient != cl ) ) return ; if ( msg . pe . buttonMask == 0 ) pointerClient = NULL ; else pointerClient = cl ; if ( ! rfbViewOnly && ! cl -> viewOnly ) { cl -> cursorX = ( int ) Swap16IfLE ( msg . pe . x ) ; cl -> cursorY = ( int ) Swap16IfLE ( msg . pe . y ) ; PtrAddEvent ( msg . pe . buttonMask , cl -> cursorX , cl -> cursorY , cl ) ; } return ; case rfbClientCutText : { int ignoredBytes = 0 ; READ ( ( ( char * ) & msg ) + 1 , sz_rfbClientCutTextMsg - 1 ) msg . cct . length = Swap32IfLE ( msg . cct . length ) ; if ( msg . cct . length > rfbMaxClipboard ) { rfbLog ( "Truncating<S2SV_blank>%d-byte<S2SV_blank>clipboard<S2SV_blank>update<S2SV_blank>to<S2SV_blank>%d<S2SV_blank>bytes.\\n" , msg . cct . length , rfbMaxClipboard ) ; ignoredBytes = msg . cct . length - rfbMaxClipboard ; msg . cct . length = rfbMaxClipboard ; } if ( msg . cct . length <= 0 ) return ; str = ( char * ) malloc ( msg . cct . length ) ; if ( str == NULL ) { rfbLogPerror ( "rfbProcessClientNormalMessage:<S2SV_blank>rfbClientCutText<S2SV_blank>out<S2SV_blank>of<S2SV_blank>memory" ) ; rfbCloseClient ( cl ) ; return ; } if ( ( n = ReadExact ( cl , str , msg . cct . length ) ) <= 0 ) { if ( n != 0 ) rfbLogPerror ( "rfbProcessClientNormalMessage:<S2SV_blank>read" ) ; free ( str ) ; rfbCloseClient ( cl ) ; return ; } if ( ignoredBytes > 0 ) { if ( ( n = SkipExact ( cl , ignoredBytes ) ) <= 0 ) { if ( n != 0 ) rfbLogPerror ( "rfbProcessClientNormalMessage:<S2SV_blank>read" ) ; free ( str ) ; rfbCloseClient ( cl ) ; return ; } } if ( ! rfbViewOnly && ! cl -> viewOnly && ! rfbAuthDisableCBRecv ) { vncClientCutText ( str , msg . cct . length ) ; if ( rfbSyncCutBuffer ) rfbSetXCutText ( str , msg . cct . length ) ; } free ( str ) ; return ; } case rfbEnableContinuousUpdates : { BoxRec box ; READ ( ( ( char * ) & msg ) + 1 , sz_rfbEnableContinuousUpdatesMsg - 1 ) if ( ! cl -> enableFence || ! cl -> enableCU ) { rfbLog ( "Ignoring<S2SV_blank>request<S2SV_blank>to<S2SV_blank>enable<S2SV_blank>continuous<S2SV_blank>updates<S2SV_blank>because<S2SV_blank>the<S2SV_blank>client<S2SV_blank>does<S2SV_blank>not\\n" ) ; rfbLog ( "support<S2SV_blank>the<S2SV_blank>flow<S2SV_blank>control<S2SV_blank>extensions.\\n" ) ; return ; } box . x1 = Swap16IfLE ( msg . ecu . x ) ; box . y1 = Swap16IfLE ( msg . ecu . y ) ; box . x2 = box . x1 + Swap16IfLE ( msg . ecu . w ) ; box . y2 = box . y1 + Swap16IfLE ( msg . ecu . h ) ; SAFE_REGION_INIT ( pScreen , & cl -> cuRegion , & box , 0 ) ; cl -> continuousUpdates = msg . ecu . enable ; if ( cl -> continuousUpdates ) { REGION_EMPTY ( pScreen , & cl -> requestedRegion ) ; if ( ! rfbSendFramebufferUpdate ( cl ) ) return ; } else { if ( ! rfbSendEndOfCU ( cl ) ) return ; } rfbLog ( "Continuous<S2SV_blank>updates<S2SV_blank>%s\\n" , cl -> continuousUpdates ? "enabled" : "disabled" ) ; return ; } case rfbFence : { CARD32 flags ; char data [ 64 ] ; READ ( ( ( char * ) & msg ) + 1 , sz_rfbFenceMsg - 1 ) flags = Swap32IfLE ( msg . f . flags ) ; <S2SV_StartBug> READ ( data , msg . f . length ) <S2SV_EndBug> <S2SV_StartBug> if ( msg . f . length > sizeof ( data ) ) <S2SV_EndBug> rfbLog ( "Ignoring<S2SV_blank>fence.<S2SV_blank><S2SV_blank>Payload<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large.\\n" , msg . f . length ) ; <S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> HandleFence ( cl , flags , msg . f . length , data ) ; <S2SV_EndBug> return ; } # define EDSERROR ( format , args ... ) { if ( ! strlen ( errMsg ) ) snprintf ( errMsg , 256 , "Desktop<S2SV_blank>resize<S2SV_blank>ERROR:<S2SV_blank>" format "\\n" , args ) ; result = rfbEDSResultInvalid ; } case rfbSetDesktopSize : { int i ; struct xorg_list newScreens ; rfbClientPtr cl2 ; int result = rfbEDSResultSuccess ; char errMsg [ 256 ] = "\\0" ; ScreenPtr pScreen = screenInfo . screens [ 0 ] ; READ ( ( ( char * ) & msg ) + 1 , sz_rfbSetDesktopSizeMsg - 1 ) if ( msg . sds . numScreens < 1 ) EDSERROR ( "Requested<S2SV_blank>number<S2SV_blank>of<S2SV_blank>screens<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>invalid" , msg . sds . numScreens ) ; msg . sds . w = Swap16IfLE ( msg . sds . w ) ; msg . sds . h = Swap16IfLE ( msg . sds . h ) ; if ( msg . sds . w < 1 || msg . sds . h < 1 ) EDSERROR ( "Requested<S2SV_blank>framebuffer<S2SV_blank>dimensions<S2SV_blank>%dx%d<S2SV_blank>are<S2SV_blank>invalid" , msg . sds . w , msg . sds . h ) ; xorg_list_init ( & newScreens ) ; for ( i = 0 ; i < msg . sds . numScreens ; i ++ ) { rfbScreenInfo * screen = rfbNewScreen ( 0 , 0 , 0 , 0 , 0 , 0 ) ; READ ( ( char * ) & screen -> s , sizeof ( rfbScreenDesc ) ) screen -> s . id = Swap32IfLE ( screen -> s . id ) ; screen -> s . x = Swap16IfLE ( screen -> s . x ) ; screen -> s . y = Swap16IfLE ( screen -> s . y ) ; screen -> s . w = Swap16IfLE ( screen -> s . w ) ; screen -> s . h = Swap16IfLE ( screen -> s . h ) ; screen -> s . flags = Swap32IfLE ( screen -> s . flags ) ; if ( screen -> s . w < 1 || screen -> s . h < 1 ) EDSERROR ( "Screen<S2SV_blank>0x%.8x<S2SV_blank>requested<S2SV_blank>dimensions<S2SV_blank>%dx%d<S2SV_blank>are<S2SV_blank>invalid" , ( unsigned int ) screen -> s . id , screen -> s . w , screen -> s . h ) ; if ( screen -> s . x >= msg . sds . w || screen -> s . y >= msg . sds . h || screen -> s . x + screen -> s . w > msg . sds . w || screen -> s . y + screen -> s . h > msg . sds . h ) EDSERROR ( "Screen<S2SV_blank>0x%.8x<S2SV_blank>requested<S2SV_blank>geometry<S2SV_blank>%dx%d+%d+%d<S2SV_blank>exceeds<S2SV_blank>requested<S2SV_blank>framebuffer<S2SV_blank>dimensions" , ( unsigned int ) screen -> s . id , screen -> s . w , screen -> s . h , screen -> s . x , screen -> s . y ) ; if ( rfbFindScreenID ( & newScreens , screen -> s . id ) ) { EDSERROR ( "Screen<S2SV_blank>0x%.8x<S2SV_blank>duplicate<S2SV_blank>ID" , ( unsigned int ) screen -> s . id ) ; free ( screen ) ; } else rfbAddScreen ( & newScreens , screen ) ; } if ( cl -> viewOnly ) { rfbLog ( "NOTICE:<S2SV_blank>Ignoring<S2SV_blank>remote<S2SV_blank>desktop<S2SV_blank>resize<S2SV_blank>request<S2SV_blank>from<S2SV_blank>a<S2SV_blank>view-only<S2SV_blank>client.\\n" ) ; result = rfbEDSResultProhibited ; } else if ( result == rfbEDSResultSuccess ) { result = ResizeDesktop ( pScreen , cl , msg . sds . w , msg . sds . h , & newScreens ) ; if ( result == rfbEDSResultSuccess ) return ; } else rfbLog ( errMsg ) ; rfbRemoveScreens ( & newScreens ) ; for ( cl2 = rfbClientHead ; cl2 ; cl2 = cl2 -> next ) { if ( cl2 == cl ) { cl2 -> pendingExtDesktopResize = TRUE ; cl2 -> reason = rfbEDSReasonClient ; cl2 -> result = result ; rfbSendFramebufferUpdate ( cl2 ) ; break ; } } return ; } case rfbGIIClient : { CARD8 endianAndSubType , littleEndian , subType ; READ ( ( char * ) & endianAndSubType , 1 ) ; littleEndian = ( endianAndSubType & rfbGIIBE ) ? 0 : 1 ; subType = endianAndSubType & ~ rfbGIIBE ; switch ( subType ) { case rfbGIIVersion : READ ( ( char * ) & msg . giicv . length , sz_rfbGIIClientVersionMsg - 2 ) ; if ( littleEndian != * ( const char * ) & rfbEndianTest ) { msg . giicv . length = Swap16 ( msg . giicv . length ) ; msg . giicv . version = Swap16 ( msg . giicv . version ) ; } if ( msg . giicv . length != sz_rfbGIIClientVersionMsg - 4 || msg . giicv . version < 1 ) { rfbLog ( "ERROR:<S2SV_blank>Malformed<S2SV_blank>GII<S2SV_blank>client<S2SV_blank>version<S2SV_blank>message\\n" ) ; rfbCloseClient ( cl ) ; return ; } rfbLog ( "Client<S2SV_blank>supports<S2SV_blank>GII<S2SV_blank>version<S2SV_blank>%d\\n" , msg . giicv . version ) ; break ; case rfbGIIDeviceCreate : { int i ; rfbDevInfo dev ; rfbGIIDeviceCreatedMsg dcmsg ; memset ( & dev , 0 , sizeof ( dev ) ) ; dcmsg . deviceOrigin = 0 ; READ ( ( char * ) & msg . giidc . length , sz_rfbGIIDeviceCreateMsg - 2 ) ; if ( littleEndian != * ( const char * ) & rfbEndianTest ) { msg . giidc . length = Swap16 ( msg . giidc . length ) ; msg . giidc . vendorID = Swap32 ( msg . giidc . vendorID ) ; msg . giidc . productID = Swap32 ( msg . giidc . productID ) ; msg . giidc . canGenerate = Swap32 ( msg . giidc . canGenerate ) ; msg . giidc . numRegisters = Swap32 ( msg . giidc . numRegisters ) ; msg . giidc . numValuators = Swap32 ( msg . giidc . numValuators ) ; msg . giidc . numButtons = Swap32 ( msg . giidc . numButtons ) ; } rfbLog ( "GII<S2SV_blank>Device<S2SV_blank>Create:<S2SV_blank>%s\\n" , msg . giidc . deviceName ) ; # ifdef GII_DEBUG rfbLog ( "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Vendor<S2SV_blank>ID:<S2SV_blank>%d\\n" , msg . giidc . vendorID ) ; rfbLog ( "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Product<S2SV_blank>ID:<S2SV_blank>%d\\n" , msg . giidc . productID ) ; rfbLog ( "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Event<S2SV_blank>mask:<S2SV_blank>%.8x\\n" , msg . giidc . canGenerate ) ; rfbLog ( "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Registers:<S2SV_blank>%d\\n" , msg . giidc . numRegisters ) ; rfbLog ( "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Valuators:<S2SV_blank>%d\\n" , msg . giidc . numValuators ) ; rfbLog ( "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Buttons:<S2SV_blank>%d\\n" , msg . giidc . numButtons ) ; # endif if ( msg . giidc . length != sz_rfbGIIDeviceCreateMsg - 4 + msg . giidc . numValuators * sz_rfbGIIValuator ) { rfbLog ( "ERROR:<S2SV_blank>Malformed<S2SV_blank>GII<S2SV_blank>device<S2SV_blank>create<S2SV_blank>message\\n" ) ; rfbCloseClient ( cl ) ; return ; } if ( msg . giidc . numButtons > MAX_BUTTONS ) { rfbLog ( "GII<S2SV_blank>device<S2SV_blank>create<S2SV_blank>ERROR:<S2SV_blank>%d<S2SV_blank>buttons<S2SV_blank>exceeds<S2SV_blank>max<S2SV_blank>of<S2SV_blank>%d\\n" , msg . giidc . numButtons , MAX_BUTTONS ) ; SKIP ( msg . giidc . numValuators * sz_rfbGIIValuator ) ; goto sendMessage ; } if ( msg . giidc . numValuators > MAX_VALUATORS ) { rfbLog ( "GII<S2SV_blank>device<S2SV_blank>create<S2SV_blank>ERROR:<S2SV_blank>%d<S2SV_blank>valuators<S2SV_blank>exceeds<S2SV_blank>max<S2SV_blank>of<S2SV_blank>%d\\n" , msg . giidc . numValuators , MAX_VALUATORS ) ; SKIP ( msg . giidc . numValuators * sz_rfbGIIValuator ) ; goto sendMessage ; } memcpy ( & dev . name , msg . giidc . deviceName , 32 ) ; dev . numButtons = msg . giidc . numButtons ; dev . numValuators = msg . giidc . numValuators ; dev . eventMask = msg . giidc . canGenerate ; dev . mode = ( dev . eventMask & rfbGIIValuatorAbsoluteMask ) ? Absolute : Relative ; dev . productID = msg . giidc . productID ; if ( dev . mode == Relative ) { rfbLog ( "GII<S2SV_blank>device<S2SV_blank>create<S2SV_blank>ERROR:<S2SV_blank>relative<S2SV_blank>valuators<S2SV_blank>not<S2SV_blank>supported<S2SV_blank>(yet)\\n" ) ; SKIP ( msg . giidc . numValuators * sz_rfbGIIValuator ) ; goto sendMessage ; } for ( i = 0 ; i < dev . numValuators ; i ++ ) { rfbGIIValuator * v = & dev . valuators [ i ] ; READ ( ( char * ) v , sz_rfbGIIValuator ) ; if ( littleEndian != * ( const char * ) & rfbEndianTest ) { v -> index = Swap32 ( v -> index ) ; v -> rangeMin = Swap32 ( ( CARD32 ) v -> rangeMin ) ; v -> rangeCenter = Swap32 ( ( CARD32 ) v -> rangeCenter ) ; v -> rangeMax = Swap32 ( ( CARD32 ) v -> rangeMax ) ; v -> siUnit = Swap32 ( v -> siUnit ) ; v -> siAdd = Swap32 ( ( CARD32 ) v -> siAdd ) ; v -> siMul = Swap32 ( ( CARD32 ) v -> siMul ) ; v -> siDiv = Swap32 ( ( CARD32 ) v -> siDiv ) ; v -> siShift = Swap32 ( ( CARD32 ) v -> siShift ) ; } # ifdef GII_DEBUG rfbLog ( "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Valuator:<S2SV_blank>%s<S2SV_blank>(%s)\\n" , v -> longName , v -> shortName ) ; rfbLog ( "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Index:<S2SV_blank>%d\\n" , v -> index ) ; rfbLog ( "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Range:<S2SV_blank>min<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>center<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>max<S2SV_blank>=<S2SV_blank>%d\\n" , v -> rangeMin , v -> rangeCenter , v -> rangeMax ) ; rfbLog ( "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>SI<S2SV_blank>unit:<S2SV_blank>%d\\n" , v -> siUnit ) ; rfbLog ( "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>SI<S2SV_blank>add:<S2SV_blank>%d\\n" , v -> siAdd ) ; rfbLog ( "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>SI<S2SV_blank>multiply:<S2SV_blank>%d\\n" , v -> siMul ) ; rfbLog ( "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>SI<S2SV_blank>divide:<S2SV_blank>%d\\n" , v -> siDiv ) ; rfbLog ( "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>SI<S2SV_blank>shift:<S2SV_blank>%d\\n" , v -> siShift ) ; # endif } for ( i = 0 ; i < cl -> numDevices ; i ++ ) { if ( ! strcmp ( dev . name , cl -> devices [ i ] . name ) ) { rfbLog ( "Device<S2SV_blank>\\\'%s\\\'<S2SV_blank>already<S2SV_blank>exists<S2SV_blank>with<S2SV_blank>GII<S2SV_blank>device<S2SV_blank>ID<S2SV_blank>%d\\n" , dev . name , i + 1 ) ; dcmsg . deviceOrigin = Swap32IfLE ( i + 1 ) ; goto sendMessage ; } } if ( rfbVirtualTablet || AddExtInputDevice ( & dev ) ) { memcpy ( & cl -> devices [ cl -> numDevices ] , & dev , sizeof ( dev ) ) ; cl -> numDevices ++ ; dcmsg . deviceOrigin = Swap32IfLE ( cl -> numDevices ) ; } rfbLog ( "GII<S2SV_blank>device<S2SV_blank>ID<S2SV_blank>=<S2SV_blank>%d\\n" , cl -> numDevices ) ; sendMessage : dcmsg . type = rfbGIIServer ; dcmsg . endianAndSubType = rfbGIIDeviceCreate | rfbGIIBE ; dcmsg . length = Swap16IfLE ( sz_rfbGIIDeviceCreatedMsg - 4 ) ; if ( WriteExact ( cl , ( char * ) & dcmsg , sz_rfbGIIDeviceCreatedMsg ) < 0 ) { rfbLogPerror ( "rfbProcessClientNormalMessage:<S2SV_blank>write" ) ; rfbCloseClient ( cl ) ; return ; } break ; } case rfbGIIDeviceDestroy : READ ( ( char * ) & msg . giidd . length , sz_rfbGIIDeviceDestroyMsg - 2 ) ; if ( littleEndian != * ( const char * ) & rfbEndianTest ) { msg . giidd . length = Swap16 ( msg . giidd . length ) ; msg . giidd . deviceOrigin = Swap32 ( msg . giidd . deviceOrigin ) ; } if ( msg . giidd . length != sz_rfbGIIDeviceDestroyMsg - 4 ) { rfbLog ( "ERROR:<S2SV_blank>Malformed<S2SV_blank>GII<S2SV_blank>device<S2SV_blank>create<S2SV_blank>message\\n" ) ; rfbCloseClient ( cl ) ; return ; } RemoveExtInputDevice ( cl , msg . giidd . deviceOrigin - 1 ) ; break ; case rfbGIIEvent : { CARD16 length ; READ ( ( char * ) & length , sizeof ( CARD16 ) ) ; if ( littleEndian != * ( const char * ) & rfbEndianTest ) length = Swap16 ( length ) ; while ( length > 0 ) { CARD8 eventSize , eventType ; READ ( ( char * ) & eventSize , 1 ) ; READ ( ( char * ) & eventType , 1 ) ; switch ( eventType ) { case rfbGIIButtonPress : case rfbGIIButtonRelease : { rfbGIIButtonEvent b ; rfbDevInfo * dev ; READ ( ( char * ) & b . pad , sz_rfbGIIButtonEvent - 2 ) ; if ( littleEndian != * ( const char * ) & rfbEndianTest ) { b . deviceOrigin = Swap32 ( b . deviceOrigin ) ; b . buttonNumber = Swap32 ( b . buttonNumber ) ; } if ( eventSize != sz_rfbGIIButtonEvent || b . deviceOrigin <= 0 || b . buttonNumber < 1 ) { rfbLog ( "ERROR:<S2SV_blank>Malformed<S2SV_blank>GII<S2SV_blank>button<S2SV_blank>event\\n" ) ; rfbCloseClient ( cl ) ; return ; } if ( eventSize > length ) { rfbLog ( "ERROR:<S2SV_blank>Malformed<S2SV_blank>GII<S2SV_blank>event<S2SV_blank>message\\n" ) ; rfbCloseClient ( cl ) ; return ; } length -= eventSize ; if ( b . deviceOrigin < 1 || b . deviceOrigin > cl -> numDevices ) { rfbLog ( "ERROR:<S2SV_blank>GII<S2SV_blank>button<S2SV_blank>event<S2SV_blank>from<S2SV_blank>non-existent<S2SV_blank>device<S2SV_blank>%d\\n" , b . deviceOrigin ) ; rfbCloseClient ( cl ) ; return ; } dev = & cl -> devices [ b . deviceOrigin - 1 ] ; if ( ( eventType == rfbGIIButtonPress && ( dev -> eventMask & rfbGIIButtonPressMask ) == 0 ) || ( eventType == rfbGIIButtonRelease && ( dev -> eventMask & rfbGIIButtonReleaseMask ) == 0 ) ) { rfbLog ( "ERROR:<S2SV_blank>Device<S2SV_blank>%d<S2SV_blank>can\'t<S2SV_blank>generate<S2SV_blank>GII<S2SV_blank>button<S2SV_blank>events\\n" , b . deviceOrigin ) ; rfbCloseClient ( cl ) ; return ; } if ( b . buttonNumber > dev -> numButtons ) { rfbLog ( "ERROR:<S2SV_blank>GII<S2SV_blank>button<S2SV_blank>%d<S2SV_blank>event<S2SV_blank>for<S2SV_blank>device<S2SV_blank>%d<S2SV_blank>exceeds<S2SV_blank>button<S2SV_blank>count<S2SV_blank>(%d)\\n" , b . buttonNumber , b . deviceOrigin , dev -> numButtons ) ; rfbCloseClient ( cl ) ; return ; } # ifdef GII_DEBUG rfbLog ( "Device<S2SV_blank>%d<S2SV_blank>button<S2SV_blank>%d<S2SV_blank>%s\\n" , b . deviceOrigin , b . buttonNumber , eventType == rfbGIIButtonPress ? "PRESS" : "release" ) ; fflush ( stderr ) ; # endif ExtInputAddEvent ( dev , eventType == rfbGIIButtonPress ? ButtonPress : ButtonRelease , b . buttonNumber ) ; break ; } case rfbGIIValuatorRelative : case rfbGIIValuatorAbsolute : { rfbGIIValuatorEvent v ; int i ; rfbDevInfo * dev ; READ ( ( char * ) & v . pad , sz_rfbGIIValuatorEvent - 2 ) ; if ( littleEndian != * ( const char * ) & rfbEndianTest ) { v . deviceOrigin = Swap32 ( v . deviceOrigin ) ; v . first = Swap32 ( v . first ) ; v . count = Swap32 ( v . count ) ; } if ( eventSize != sz_rfbGIIValuatorEvent + sizeof ( int ) * v . count ) { rfbLog ( "ERROR:<S2SV_blank>Malformed<S2SV_blank>GII<S2SV_blank>valuator<S2SV_blank>event\\n" ) ; rfbCloseClient ( cl ) ; return ; } if ( eventSize > length ) { rfbLog ( "ERROR:<S2SV_blank>Malformed<S2SV_blank>GII<S2SV_blank>event<S2SV_blank>message\\n" ) ; rfbCloseClient ( cl ) ; return ; } length -= eventSize ; if ( v . deviceOrigin < 1 || v . deviceOrigin > cl -> numDevices ) { rfbLog ( "ERROR:<S2SV_blank>GII<S2SV_blank>valuator<S2SV_blank>event<S2SV_blank>from<S2SV_blank>non-existent<S2SV_blank>device<S2SV_blank>%d\\n" , v . deviceOrigin ) ; rfbCloseClient ( cl ) ; return ; } dev = & cl -> devices [ v . deviceOrigin - 1 ] ; if ( ( eventType == rfbGIIValuatorRelative && ( dev -> eventMask & rfbGIIValuatorRelativeMask ) == 0 ) || ( eventType == rfbGIIValuatorAbsolute && ( dev -> eventMask & rfbGIIValuatorAbsoluteMask ) == 0 ) ) { rfbLog ( "ERROR:<S2SV_blank>Device<S2SV_blank>%d<S2SV_blank>cannot<S2SV_blank>generate<S2SV_blank>GII<S2SV_blank>valuator<S2SV_blank>events\\n" , v . deviceOrigin ) ; rfbCloseClient ( cl ) ; return ; } if ( v . first + v . count > dev -> numValuators ) { rfbLog ( "ERROR:<S2SV_blank>GII<S2SV_blank>valuator<S2SV_blank>event<S2SV_blank>for<S2SV_blank>device<S2SV_blank>%d<S2SV_blank>exceeds<S2SV_blank>valuator<S2SV_blank>count<S2SV_blank>(%d)\\n" , v . deviceOrigin , dev -> numValuators ) ; rfbCloseClient ( cl ) ; return ; } # ifdef GII_DEBUG rfbLog ( "Device<S2SV_blank>%d<S2SV_blank>Valuator<S2SV_blank>%s<S2SV_blank>first=%d<S2SV_blank>count=%d:\\n" , v . deviceOrigin , eventType == rfbGIIValuatorRelative ? "rel" : "ABS" , v . first , v . count ) ; # endif for ( i = v . first ; i < v . first + v . count ; i ++ ) { READ ( ( char * ) & dev -> values [ i ] , sizeof ( int ) ) ; if ( littleEndian != * ( const char * ) & rfbEndianTest ) dev -> values [ i ] = Swap32 ( ( CARD32 ) dev -> values [ i ] ) ; # ifdef GII_DEBUG fprintf ( stderr , "v[%d]=%d<S2SV_blank>" , i , dev -> values [ i ] ) ; # endif } # ifdef GII_DEBUG fprintf ( stderr , "\\n" ) ; # endif if ( v . count > 0 ) { dev -> valFirst = v . first ; dev -> valCount = v . count ; dev -> mode = eventType == rfbGIIValuatorAbsolute ? Absolute : Relative ; ExtInputAddEvent ( dev , MotionNotify , 0 ) ; } break ; } default : rfbLog ( "ERROR:<S2SV_blank>This<S2SV_blank>server<S2SV_blank>cannot<S2SV_blank>handle<S2SV_blank>GII<S2SV_blank>event<S2SV_blank>type<S2SV_blank>%d\\n" , eventType ) ; rfbCloseClient ( cl ) ; return ; } } if ( length != 0 ) { rfbLog ( "ERROR:<S2SV_blank>Malformed<S2SV_blank>GII<S2SV_blank>event<S2SV_blank>message\\n" ) ; rfbCloseClient ( cl ) ; return ; } break ; } } return ; } default : rfbLog ( "rfbProcessClientNormalMessage:<S2SV_blank>unknown<S2SV_blank>message<S2SV_blank>type<S2SV_blank>%d\\n" , msg . type ) ; rfbLog ( "<S2SV_blank>...<S2SV_blank>closing<S2SV_blank>connection\\n" ) ; rfbCloseClient ( cl ) ; return ; } }
static int fpDiff ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) { tmsize_t stride = PredictorState ( tif ) -> stride ; uint32 bps = tif -> tif_dir . td_bitspersample / 8 ; tmsize_t wc = cc / bps ; tmsize_t count ; uint8 * cp = ( uint8 * ) cp0 ; <S2SV_StartBug> uint8 * tmp = ( uint8 * ) _TIFFmalloc ( cc ) ; <S2SV_EndBug> if ( ( cc % ( bps * stride ) ) != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , "fpDiff" , "%s" , "(cc%(bps*stride))!=0" ) ; return 0 ; } <S2SV_StartBug> if ( ! tmp ) <S2SV_EndBug> return 0 ; _TIFFmemcpy ( tmp , cp0 , cc ) ; for ( count = 0 ; count < wc ; count ++ ) { uint32 byte ; for ( byte = 0 ; byte < bps ; byte ++ ) { # if WORDS_BIGENDIAN cp [ byte * wc + count ] = tmp [ bps * count + byte ] ; # else cp [ ( bps - byte - 1 ) * wc + count ] = tmp [ bps * count + byte ] ; # endif } } _TIFFfree ( tmp ) ; cp = ( uint8 * ) cp0 ; cp += cc - stride - 1 ; for ( count = cc ; count > stride ; count -= stride ) REPEAT4 ( stride , cp [ stride ] = ( unsigned char ) ( ( cp [ stride ] - cp [ 0 ] ) & 0xff ) ; cp -- ) return 1 ; }
static ssize_t snd_timer_user_read ( struct file * file , char __user * buffer , size_t count , loff_t * offset ) { struct snd_timer_user * tu ; long result = 0 , unit ; int qhead ; int err = 0 ; tu = file -> private_data ; unit = tu -> tread ? sizeof ( struct snd_timer_tread ) : sizeof ( struct snd_timer_read ) ; <S2SV_StartBug> spin_lock_irq ( & tu -> qlock ) ; <S2SV_EndBug> while ( ( long ) count - result >= unit ) { while ( ! tu -> qused ) { wait_queue_t wait ; if ( ( file -> f_flags & O_NONBLOCK ) != 0 || result > 0 ) { err = - EAGAIN ; goto _error ; } set_current_state ( TASK_INTERRUPTIBLE ) ; init_waitqueue_entry ( & wait , current ) ; add_wait_queue ( & tu -> qchange_sleep , & wait ) ; spin_unlock_irq ( & tu -> qlock ) ; <S2SV_StartBug> schedule ( ) ; <S2SV_EndBug> spin_lock_irq ( & tu -> qlock ) ; remove_wait_queue ( & tu -> qchange_sleep , & wait ) ; if ( tu -> disconnected ) { err = - ENODEV ; goto _error ; } if ( signal_pending ( current ) ) { err = - ERESTARTSYS ; goto _error ; } } qhead = tu -> qhead ++ ; tu -> qhead %= tu -> queue_size ; tu -> qused -- ; spin_unlock_irq ( & tu -> qlock ) ; <S2SV_StartBug> mutex_lock ( & tu -> ioctl_lock ) ; <S2SV_EndBug> if ( tu -> tread ) { if ( copy_to_user ( buffer , & tu -> tqueue [ qhead ] , sizeof ( struct snd_timer_tread ) ) ) err = - EFAULT ; } else { if ( copy_to_user ( buffer , & tu -> queue [ qhead ] , sizeof ( struct snd_timer_read ) ) ) err = - EFAULT ; } <S2SV_StartBug> mutex_unlock ( & tu -> ioctl_lock ) ; <S2SV_EndBug> spin_lock_irq ( & tu -> qlock ) ; if ( err < 0 ) goto _error ; result += unit ; buffer += unit ; } _error : spin_unlock_irq ( & tu -> qlock ) ; <S2SV_StartBug> return result > 0 ? result : err ; <S2SV_EndBug> }
int nfs3svc_decode_symlinkargs ( struct svc_rqst * rqstp , __be32 * p , struct nfsd3_symlinkargs * args ) { unsigned int len , avail ; char * old , * new ; struct kvec * vec ; if ( ! ( p = decode_fh ( p , & args -> ffh ) ) || ! ( p = decode_filename ( p , & args -> fname , & args -> flen ) ) ) return 0 ; p = decode_sattr3 ( p , & args -> attrs ) ; len = ntohl ( * p ++ ) ; if ( len == 0 || len > NFS3_MAXPATHLEN || len >= PAGE_SIZE ) return 0 ; args -> tname = new = page_address ( * ( rqstp -> rq_next_page ++ ) ) ; args -> tlen = len ; old = ( char * ) p ; vec = & rqstp -> rq_arg . head [ 0 ] ; <S2SV_StartBug> avail = vec -> iov_len - ( old - ( char * ) vec -> iov_base ) ; <S2SV_EndBug> while ( len && avail && * old ) { * new ++ = * old ++ ; len -- ; avail -- ; } if ( len && ! avail && rqstp -> rq_arg . page_len ) { avail = min_t ( unsigned int , rqstp -> rq_arg . page_len , PAGE_SIZE ) ; old = page_address ( rqstp -> rq_arg . pages [ 0 ] ) ; } while ( len && avail && * old ) { * new ++ = * old ++ ; len -- ; avail -- ; } * new = '\\0' ; if ( len ) return 0 ; return 1 ; }
<S2SV_StartBug> int mongo_env_write_socket ( mongo * conn , const void * buf , int len ) { <S2SV_EndBug> const char * cbuf = buf ; # ifdef __APPLE__ int flags = 0 ; # else int flags = MSG_NOSIGNAL ; # endif while ( len ) { <S2SV_StartBug> int sent = send ( conn -> sock , cbuf , len , flags ) ; <S2SV_EndBug> if ( sent == - 1 ) { if ( errno == EPIPE ) conn -> connected = 0 ; __mongo_set_error ( conn , MONGO_IO_ERROR , strerror ( errno ) , errno ) ; return MONGO_ERROR ; } cbuf += sent ; len -= sent ; } return MONGO_OK ; }
size_t OpenMP4SourceUDTA ( char * filename ) { mp4object * mp4 = ( mp4object * ) malloc ( sizeof ( mp4object ) ) ; if ( mp4 == NULL ) return 0 ; memset ( mp4 , 0 , sizeof ( mp4object ) ) ; # ifdef _WINDOWS fopen_s ( & mp4 -> mediafp , filename , "rb" ) ; # else mp4 -> mediafp = fopen ( filename , "rb" ) ; # endif if ( mp4 -> mediafp ) { <S2SV_StartBug> uint32_t qttag , qtsize32 , len ; <S2SV_EndBug> int32_t nest = 0 ; uint64_t nestsize [ MAX_NEST_LEVEL ] = { 0 } ; uint64_t lastsize = 0 , qtsize ; do { len = fread ( & qtsize32 , 1 , 4 , mp4 -> mediafp ) ; len += fread ( & qttag , 1 , 4 , mp4 -> mediafp ) ; if ( len == 8 ) { if ( ! GPMF_VALID_FOURCC ( qttag ) ) { <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , lastsize - 8 - 8 , SEEK_CUR ) ; <S2SV_EndBug> NESTSIZE ( lastsize - 8 ) ; continue ; } qtsize32 = BYTESWAP32 ( qtsize32 ) ; if ( qtsize32 == 1 ) { fread ( & qtsize , 1 , 8 , mp4 -> mediafp ) ; qtsize = BYTESWAP64 ( qtsize ) - 8 ; } else qtsize = qtsize32 ; nest ++ ; if ( qtsize < 8 ) break ; if ( nest >= MAX_NEST_LEVEL ) break ; nestsize [ nest ] = qtsize ; lastsize = qtsize ; if ( qttag == MAKEID ( 'm' , 'd' , 'a' , 't' ) || qttag == MAKEID ( 'f' , 't' , 'y' , 'p' ) ) { <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 , SEEK_CUR ) ; <S2SV_EndBug> NESTSIZE ( qtsize ) ; continue ; } if ( qttag == MAKEID ( 'G' , 'P' , 'M' , 'F' ) ) { mp4 -> videolength += 1.0 ; mp4 -> metadatalength += 1.0 ; mp4 -> indexcount = ( int ) mp4 -> metadatalength ; mp4 -> metasizes = ( uint32_t * ) malloc ( mp4 -> indexcount * 4 + 4 ) ; memset ( mp4 -> metasizes , 0 , mp4 -> indexcount * 4 + 4 ) ; mp4 -> metaoffsets = ( uint64_t * ) malloc ( mp4 -> indexcount * 8 + 8 ) ; memset ( mp4 -> metaoffsets , 0 , mp4 -> indexcount * 8 + 8 ) ; mp4 -> metasizes [ 0 ] = ( int ) qtsize - 8 ; mp4 -> metaoffsets [ 0 ] = ftell ( mp4 -> mediafp ) ; mp4 -> metasize_count = 1 ; return ( size_t ) mp4 ; } if ( qttag != MAKEID ( 'm' , 'o' , 'o' , 'v' ) && qttag != MAKEID ( 'u' , 'd' , 't' , 'a' ) ) { <S2SV_StartBug> LONGSEEK ( mp4 -> mediafp , qtsize - 8 , SEEK_CUR ) ; <S2SV_EndBug> NESTSIZE ( qtsize ) ; continue ; } else { NESTSIZE ( 8 ) ; } } } while ( len > 0 ) ; } return ( size_t ) mp4 ; }
static struct sk_buff * xfrm_state_netlink ( struct sk_buff * in_skb , struct xfrm_state * x , u32 seq ) { struct xfrm_dump_info info ; <S2SV_StartBug> struct sk_buff * skb ; <S2SV_EndBug> skb = nlmsg_new ( NLMSG_DEFAULT_SIZE , GFP_ATOMIC ) ; if ( ! skb ) return ERR_PTR ( - ENOMEM ) ; info . in_skb = in_skb ; info . out_skb = skb ; info . nlmsg_seq = seq ; info . nlmsg_flags = 0 ; <S2SV_StartBug> if ( dump_one_state ( x , 0 , & info ) ) { <S2SV_EndBug> kfree_skb ( skb ) ; <S2SV_StartBug> return NULL ; <S2SV_EndBug> } return skb ; }
enum ImapAuthRes imap_auth_cram_md5 ( struct ImapData * idata , const char * method ) { char ibuf [ LONG_STRING * 2 ] , obuf [ LONG_STRING ] ; unsigned char hmac_response [ MD5_DIGEST_LEN ] ; int len ; int rc ; if ( ! mutt_bit_isset ( idata -> capabilities , ACRAM_MD5 ) ) return IMAP_AUTH_UNAVAIL ; mutt_message ( _ ( "Authenticating<S2SV_blank>(CRAM-MD5)..." ) ) ; if ( mutt_account_getlogin ( & idata -> conn -> account ) < 0 ) return IMAP_AUTH_FAILURE ; if ( mutt_account_getpass ( & idata -> conn -> account ) < 0 ) return IMAP_AUTH_FAILURE ; imap_cmd_start ( idata , "AUTHENTICATE<S2SV_blank>CRAM-MD5" ) ; do rc = imap_cmd_step ( idata ) ; while ( rc == IMAP_CMD_CONTINUE ) ; if ( rc != IMAP_CMD_RESPOND ) { mutt_debug ( 1 , "Invalid<S2SV_blank>response<S2SV_blank>from<S2SV_blank>server:<S2SV_blank>%s\\n" , ibuf ) ; goto bail ; } <S2SV_StartBug> len = mutt_b64_decode ( obuf , idata -> buf + 2 ) ; <S2SV_EndBug> if ( len == - 1 ) { mutt_debug ( 1 , "Error<S2SV_blank>decoding<S2SV_blank>base64<S2SV_blank>response.\\n" ) ; goto bail ; } obuf [ len ] = '\\0' ; mutt_debug ( 2 , "CRAM<S2SV_blank>challenge:<S2SV_blank>%s\\n" , obuf ) ; hmac_md5 ( idata -> conn -> account . pass , obuf , hmac_response ) ; int off = snprintf ( obuf , sizeof ( obuf ) , "%s<S2SV_blank>" , idata -> conn -> account . user ) ; mutt_md5_toascii ( hmac_response , obuf + off ) ; mutt_debug ( 2 , "CRAM<S2SV_blank>response:<S2SV_blank>%s\\n" , obuf ) ; mutt_b64_encode ( ibuf , obuf , strlen ( obuf ) , sizeof ( ibuf ) - 2 ) ; mutt_str_strcat ( ibuf , sizeof ( ibuf ) , "\\r\\n" ) ; mutt_socket_send ( idata -> conn , ibuf ) ; do rc = imap_cmd_step ( idata ) ; while ( rc == IMAP_CMD_CONTINUE ) ; if ( rc != IMAP_CMD_OK ) { mutt_debug ( 1 , "Error<S2SV_blank>receiving<S2SV_blank>server<S2SV_blank>response.\\n" ) ; goto bail ; } if ( imap_code ( idata -> buf ) ) return IMAP_AUTH_SUCCESS ; bail : mutt_error ( _ ( "CRAM-MD5<S2SV_blank>authentication<S2SV_blank>failed." ) ) ; return IMAP_AUTH_FAILURE ; }
WORD32 ih264d_parse_decode_slice ( UWORD8 u1_is_idr_slice , UWORD8 u1_nal_ref_idc , dec_struct_t * ps_dec ) { dec_bit_stream_t * ps_bitstrm = ps_dec -> ps_bitstrm ; dec_pic_params_t * ps_pps ; dec_seq_params_t * ps_seq ; dec_slice_params_t * ps_cur_slice = ps_dec -> ps_cur_slice ; pocstruct_t s_tmp_poc ; WORD32 i_delta_poc [ 2 ] ; WORD32 i4_poc = 0 ; UWORD16 u2_first_mb_in_slice , u2_frame_num ; UWORD8 u1_field_pic_flag , u1_redundant_pic_cnt = 0 , u1_slice_type ; UWORD32 u4_idr_pic_id = 0 ; UWORD8 u1_bottom_field_flag , u1_pic_order_cnt_type ; UWORD8 u1_nal_unit_type ; UWORD32 * pu4_bitstrm_buf = ps_bitstrm -> pu4_buffer ; UWORD32 * pu4_bitstrm_ofst = & ps_bitstrm -> u4_ofst ; WORD8 i1_is_end_of_poc ; WORD32 ret , end_of_frame ; WORD32 prev_slice_err , num_mb_skipped ; UWORD8 u1_mbaff ; pocstruct_t * ps_cur_poc ; UWORD32 u4_temp ; WORD32 i_temp ; UWORD32 u4_call_end_of_pic = 0 ; ps_dec -> ps_dpb_cmds -> u1_dpb_commands_read_slc = 0 ; u2_first_mb_in_slice = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u2_first_mb_in_slice > ( ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) ) { return ERROR_CORRUPTED_SLICE ; } if ( ( ( u2_first_mb_in_slice << ps_cur_slice -> u1_mbaff_frame_flag ) <= ps_dec -> u2_cur_mb_addr ) && ( ps_dec -> u4_first_slice_in_pic == 0 ) ) { return ERROR_CORRUPTED_SLICE ; } COPYTHECONTEXT ( "SH:<S2SV_blank>first_mb_in_slice" , u2_first_mb_in_slice ) ; u4_temp = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u4_temp > 9 ) return ERROR_INV_SLC_TYPE_T ; u1_slice_type = u4_temp ; COPYTHECONTEXT ( "SH:<S2SV_blank>slice_type" , ( u1_slice_type ) ) ; ps_dec -> u1_sl_typ_5_9 = 0 ; if ( u1_slice_type > 4 ) { u1_slice_type -= 5 ; ps_dec -> u1_sl_typ_5_9 = 1 ; } { UWORD32 skip ; if ( ( ps_dec -> i4_app_skip_mode == IVD_SKIP_PB ) || ( ps_dec -> i4_dec_skip_mode == IVD_SKIP_PB ) ) { UWORD32 u4_bit_stream_offset = 0 ; if ( ps_dec -> u1_nal_unit_type == IDR_SLICE_NAL ) { skip = 0 ; ps_dec -> i4_dec_skip_mode = IVD_SKIP_NONE ; } else if ( ( I_SLICE == u1_slice_type ) && ( 1 >= ps_dec -> ps_cur_sps -> u1_num_ref_frames ) ) { skip = 0 ; ps_dec -> i4_dec_skip_mode = IVD_SKIP_NONE ; } else { skip = 1 ; } if ( ( 0 == u2_first_mb_in_slice ) && ( 1 == ps_dec -> u4_prev_nal_skipped ) ) { skip = 0 ; } if ( skip ) { ps_dec -> u4_prev_nal_skipped = 1 ; ps_dec -> i4_dec_skip_mode = IVD_SKIP_PB ; return 0 ; } else { if ( 1 == ps_dec -> u4_prev_nal_skipped ) { ps_dec -> u4_return_to_app = 1 ; return 0 ; } } } } u4_temp = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u4_temp & MASK_ERR_PIC_SET_ID ) return ERROR_INV_SLICE_HDR_T ; COPYTHECONTEXT ( "SH:<S2SV_blank>pic_parameter_set_id" , u4_temp ) ; ps_pps = & ps_dec -> ps_pps [ u4_temp ] ; if ( FALSE == ps_pps -> u1_is_valid ) { return ERROR_INV_SLICE_HDR_T ; } ps_seq = ps_pps -> ps_sps ; if ( ! ps_seq ) return ERROR_INV_SLICE_HDR_T ; if ( FALSE == ps_seq -> u1_is_valid ) return ERROR_INV_SLICE_HDR_T ; u2_frame_num = ih264d_get_bits_h264 ( ps_bitstrm , ps_seq -> u1_bits_in_frm_num ) ; COPYTHECONTEXT ( "SH:<S2SV_blank>frame_num" , u2_frame_num ) ; <S2SV_StartBug> if ( ! ps_seq -> u1_frame_mbs_only_flag ) <S2SV_EndBug> { u1_field_pic_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( "SH:<S2SV_blank>field_pic_flag" , u1_field_pic_flag ) ; u1_bottom_field_flag = 0 ; if ( u1_field_pic_flag ) { ps_dec -> pu1_inv_scan = ( UWORD8 * ) gau1_ih264d_inv_scan_fld ; u1_bottom_field_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( "SH:<S2SV_blank>bottom_field_flag" , u1_bottom_field_flag ) ; } else { ps_dec -> pu1_inv_scan = ( UWORD8 * ) gau1_ih264d_inv_scan ; } } else { u1_field_pic_flag = 0 ; u1_bottom_field_flag = 0 ; ps_dec -> pu1_inv_scan = ( UWORD8 * ) gau1_ih264d_inv_scan ; } u1_nal_unit_type = SLICE_NAL ; if ( u1_is_idr_slice ) { if ( 0 == u1_field_pic_flag ) { ps_dec -> u1_top_bottom_decoded = TOP_FIELD_ONLY | BOT_FIELD_ONLY ; } u1_nal_unit_type = IDR_SLICE_NAL ; u4_idr_pic_id = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u4_idr_pic_id > 65535 ) return ERROR_INV_SLICE_HDR_T ; COPYTHECONTEXT ( "SH:<S2SV_blank><S2SV_blank>" , u4_idr_pic_id ) ; } i_delta_poc [ 0 ] = i_delta_poc [ 1 ] = 0 ; s_tmp_poc . i4_pic_order_cnt_lsb = 0 ; s_tmp_poc . i4_delta_pic_order_cnt_bottom = 0 ; u1_pic_order_cnt_type = ps_seq -> u1_pic_order_cnt_type ; if ( u1_pic_order_cnt_type == 0 ) { i_temp = ih264d_get_bits_h264 ( ps_bitstrm , ps_seq -> u1_log2_max_pic_order_cnt_lsb_minus ) ; if ( i_temp < 0 || i_temp >= ps_seq -> i4_max_pic_order_cntLsb ) return ERROR_INV_SLICE_HDR_T ; s_tmp_poc . i4_pic_order_cnt_lsb = i_temp ; COPYTHECONTEXT ( "SH:<S2SV_blank>pic_order_cnt_lsb" , s_tmp_poc . i4_pic_order_cnt_lsb ) ; if ( ( ps_pps -> u1_pic_order_present_flag == 1 ) && ( ! u1_field_pic_flag ) ) { s_tmp_poc . i4_delta_pic_order_cnt_bottom = ih264d_sev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; COPYTHECONTEXT ( "SH:<S2SV_blank>delta_pic_order_cnt_bottom" , s_tmp_poc . i4_delta_pic_order_cnt_bottom ) ; } } s_tmp_poc . i4_delta_pic_order_cnt [ 0 ] = 0 ; s_tmp_poc . i4_delta_pic_order_cnt [ 1 ] = 0 ; if ( u1_pic_order_cnt_type == 1 && ( ! ps_seq -> u1_delta_pic_order_always_zero_flag ) ) { s_tmp_poc . i4_delta_pic_order_cnt [ 0 ] = ih264d_sev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; COPYTHECONTEXT ( "SH:<S2SV_blank>delta_pic_order_cnt[0]" , s_tmp_poc . i4_delta_pic_order_cnt [ 0 ] ) ; if ( ps_pps -> u1_pic_order_present_flag && ! u1_field_pic_flag ) { s_tmp_poc . i4_delta_pic_order_cnt [ 1 ] = ih264d_sev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; COPYTHECONTEXT ( "SH:<S2SV_blank>delta_pic_order_cnt[1]" , s_tmp_poc . i4_delta_pic_order_cnt [ 1 ] ) ; } } if ( ps_pps -> u1_redundant_pic_cnt_present_flag ) { u4_temp = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u4_temp > MAX_REDUNDANT_PIC_CNT ) return ERROR_INV_SLICE_HDR_T ; u1_redundant_pic_cnt = u4_temp ; COPYTHECONTEXT ( "SH:<S2SV_blank>redundant_pic_cnt" , u1_redundant_pic_cnt ) ; } i1_is_end_of_poc = 1 ; ps_dec -> ps_dec_err_status -> u1_err_flag &= MASK_REJECT_CUR_PIC ; if ( ps_dec -> u4_first_slice_in_pic != 2 ) { i1_is_end_of_poc = ih264d_is_end_of_pic ( u2_frame_num , u1_nal_ref_idc , & s_tmp_poc , & ps_dec -> s_cur_pic_poc , ps_cur_slice , u1_pic_order_cnt_type , u1_nal_unit_type , u4_idr_pic_id , u1_field_pic_flag , u1_bottom_field_flag ) ; <S2SV_StartBug> } <S2SV_EndBug> u1_mbaff = ps_seq -> u1_mb_aff_flag && ( ! u1_field_pic_flag ) ; prev_slice_err = 0 ; if ( i1_is_end_of_poc || ps_dec -> u1_first_slice_in_stream ) { if ( u2_frame_num != ps_dec -> u2_prv_frame_num && ps_dec -> u1_top_bottom_decoded != 0 && ps_dec -> u1_top_bottom_decoded != ( TOP_FIELD_ONLY | BOT_FIELD_ONLY ) ) { ps_dec -> u1_dangling_field = 1 ; if ( ps_dec -> u4_first_slice_in_pic ) { prev_slice_err = 1 ; } else { prev_slice_err = 2 ; } if ( ps_dec -> u1_top_bottom_decoded == TOP_FIELD_ONLY ) ps_cur_slice -> u1_bottom_field_flag = 1 ; else ps_cur_slice -> u1_bottom_field_flag = 0 ; num_mb_skipped = ( ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) - ps_dec -> u2_total_mbs_coded ; ps_cur_poc = & ps_dec -> s_cur_pic_poc ; u1_is_idr_slice = ps_cur_slice -> u1_nal_unit_type == IDR_SLICE_NAL ; } else if ( ps_dec -> u4_first_slice_in_pic == 2 ) { if ( u2_first_mb_in_slice > 0 ) { prev_slice_err = 1 ; num_mb_skipped = u2_first_mb_in_slice << u1_mbaff ; ps_cur_poc = & s_tmp_poc ; ps_cur_slice -> u4_idr_pic_id = u4_idr_pic_id ; ps_cur_slice -> u1_field_pic_flag = u1_field_pic_flag ; ps_cur_slice -> u1_bottom_field_flag = u1_bottom_field_flag ; ps_cur_slice -> i4_pic_order_cnt_lsb = s_tmp_poc . i4_pic_order_cnt_lsb ; ps_cur_slice -> u1_nal_unit_type = u1_nal_unit_type ; ps_cur_slice -> u1_redundant_pic_cnt = u1_redundant_pic_cnt ; ps_cur_slice -> u1_nal_ref_idc = u1_nal_ref_idc ; ps_cur_slice -> u1_pic_order_cnt_type = u1_pic_order_cnt_type ; ps_cur_slice -> u1_mbaff_frame_flag = ps_seq -> u1_mb_aff_flag && ( ! u1_field_pic_flag ) ; } } else { if ( ps_dec -> u4_first_slice_in_pic ) { prev_slice_err = 1 ; num_mb_skipped = u2_first_mb_in_slice << u1_mbaff ; } else { prev_slice_err = 2 ; num_mb_skipped = ( ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) - ps_dec -> u2_total_mbs_coded ; } ps_cur_poc = & s_tmp_poc ; } } else { if ( ( u2_first_mb_in_slice << u1_mbaff ) > ps_dec -> u2_total_mbs_coded ) { prev_slice_err = 2 ; num_mb_skipped = ( u2_first_mb_in_slice << u1_mbaff ) - ps_dec -> u2_total_mbs_coded ; ps_cur_poc = & s_tmp_poc ; } else if ( ( u2_first_mb_in_slice << u1_mbaff ) < ps_dec -> u2_total_mbs_coded ) { return ERROR_CORRUPTED_SLICE ; } } if ( prev_slice_err ) { ret = ih264d_mark_err_slice_skip ( ps_dec , num_mb_skipped , u1_is_idr_slice , u2_frame_num , ps_cur_poc , prev_slice_err ) ; if ( ps_dec -> u1_dangling_field == 1 ) { ps_dec -> u1_second_field = 1 - ps_dec -> u1_second_field ; ps_cur_slice -> u1_bottom_field_flag = u1_bottom_field_flag ; ps_dec -> u2_prv_frame_num = u2_frame_num ; ps_dec -> u1_first_slice_in_stream = 0 ; return ERROR_DANGLING_FIELD_IN_PIC ; } if ( prev_slice_err == 2 ) { ps_dec -> u1_first_slice_in_stream = 0 ; return ERROR_INCOMPLETE_FRAME ; } if ( ps_dec -> u2_total_mbs_coded >= ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) { ps_dec -> u1_first_slice_in_stream = 0 ; return ERROR_IN_LAST_SLICE_OF_PIC ; } if ( ps_dec -> ps_dec_err_status -> u1_err_flag & REJECT_CUR_PIC ) { ih264d_err_pic_dispbuf_mgr ( ps_dec ) ; return ERROR_NEW_FRAME_EXPECTED ; } if ( ret != OK ) return ret ; i1_is_end_of_poc = 0 ; } if ( ps_dec -> u4_first_slice_in_pic == 0 ) { ps_dec -> ps_parse_cur_slice ++ ; ps_dec -> u2_cur_slice_num ++ ; } if ( ( ps_dec -> u1_separate_parse == 0 ) && ( ps_dec -> u4_first_slice_in_pic == 0 ) ) { ps_dec -> ps_decode_cur_slice ++ ; } ps_dec -> u1_slice_header_done = 0 ; <S2SV_StartBug> if ( ! ps_dec -> u1_first_slice_in_stream ) <S2SV_EndBug> { UWORD8 uc_mbs_exceed = 0 ; if ( ps_dec -> u2_total_mbs_coded == ( ps_dec -> ps_cur_sps -> u2_max_mb_addr + 1 ) ) { if ( ps_dec -> u4_first_slice_in_pic == 0 ) uc_mbs_exceed = 1 ; } if ( i1_is_end_of_poc || uc_mbs_exceed ) { if ( 1 == ps_dec -> u1_last_pic_not_decoded ) { ret = ih264d_end_of_pic_dispbuf_mgr ( ps_dec ) ; if ( ret != OK ) return ret ; ret = ih264d_end_of_pic ( ps_dec , u1_is_idr_slice , u2_frame_num ) ; if ( ret != OK ) return ret ; # if WIN32 H264_DEC_DEBUG_PRINT ( "<S2SV_blank>------<S2SV_blank>PIC<S2SV_blank>SKIPPED<S2SV_blank>------\\n" ) ; # endif return RET_LAST_SKIP ; } else { ret = ih264d_end_of_pic ( ps_dec , u1_is_idr_slice , u2_frame_num ) ; if ( ret != OK ) return ret ; } } } if ( u1_field_pic_flag ) { ps_dec -> u2_prv_frame_num = u2_frame_num ; } if ( ps_cur_slice -> u1_mmco_equalto5 ) { WORD32 i4_temp_poc ; WORD32 i4_top_field_order_poc , i4_bot_field_order_poc ; if ( ! ps_cur_slice -> u1_field_pic_flag ) { i4_top_field_order_poc = ps_dec -> ps_cur_pic -> i4_top_field_order_cnt ; i4_bot_field_order_poc = ps_dec -> ps_cur_pic -> i4_bottom_field_order_cnt ; i4_temp_poc = MIN ( i4_top_field_order_poc , i4_bot_field_order_poc ) ; } else if ( ! ps_cur_slice -> u1_bottom_field_flag ) i4_temp_poc = ps_dec -> ps_cur_pic -> i4_top_field_order_cnt ; else i4_temp_poc = ps_dec -> ps_cur_pic -> i4_bottom_field_order_cnt ; ps_dec -> ps_cur_pic -> i4_top_field_order_cnt = i4_temp_poc - ps_dec -> ps_cur_pic -> i4_top_field_order_cnt ; ps_dec -> ps_cur_pic -> i4_bottom_field_order_cnt = i4_temp_poc - ps_dec -> ps_cur_pic -> i4_bottom_field_order_cnt ; ps_dec -> ps_cur_pic -> i4_poc = i4_temp_poc ; ps_dec -> ps_cur_pic -> i4_avg_poc = i4_temp_poc ; } if ( ps_dec -> u4_first_slice_in_pic == 2 ) { ret = ih264d_decode_pic_order_cnt ( u1_is_idr_slice , u2_frame_num , & ps_dec -> s_prev_pic_poc , & s_tmp_poc , ps_cur_slice , ps_pps , u1_nal_ref_idc , u1_bottom_field_flag , u1_field_pic_flag , & i4_poc ) ; if ( ret != OK ) return ret ; if ( i4_poc >= ps_dec -> i4_max_poc ) ps_dec -> i4_max_poc = i4_poc ; if ( i4_poc == 0 ) { ps_dec -> i4_prev_max_display_seq = ps_dec -> i4_prev_max_display_seq + ps_dec -> i4_max_poc + ps_dec -> u1_max_dec_frame_buffering + 1 ; ps_dec -> i4_max_poc = 0 ; } } ps_cur_slice -> i4_delta_pic_order_cnt [ 0 ] = i_delta_poc [ 0 ] ; ps_cur_slice -> i4_delta_pic_order_cnt [ 1 ] = i_delta_poc [ 1 ] ; ps_cur_slice -> u4_idr_pic_id = u4_idr_pic_id ; ps_cur_slice -> u2_first_mb_in_slice = u2_first_mb_in_slice ; ps_cur_slice -> u1_field_pic_flag = u1_field_pic_flag ; ps_cur_slice -> u1_bottom_field_flag = u1_bottom_field_flag ; ps_cur_slice -> u1_slice_type = u1_slice_type ; ps_cur_slice -> i4_pic_order_cnt_lsb = s_tmp_poc . i4_pic_order_cnt_lsb ; ps_cur_slice -> u1_nal_unit_type = u1_nal_unit_type ; ps_cur_slice -> u1_redundant_pic_cnt = u1_redundant_pic_cnt ; ps_cur_slice -> u1_nal_ref_idc = u1_nal_ref_idc ; ps_cur_slice -> u1_pic_order_cnt_type = u1_pic_order_cnt_type ; if ( ps_seq -> u1_frame_mbs_only_flag ) ps_cur_slice -> u1_direct_8x8_inference_flag = ps_seq -> u1_direct_8x8_inference_flag ; else ps_cur_slice -> u1_direct_8x8_inference_flag = 1 ; if ( u1_slice_type == B_SLICE ) { ps_cur_slice -> u1_direct_spatial_mv_pred_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( "SH:<S2SV_blank>direct_spatial_mv_pred_flag" , ps_cur_slice -> u1_direct_spatial_mv_pred_flag ) ; if ( ps_cur_slice -> u1_direct_spatial_mv_pred_flag ) ps_cur_slice -> pf_decodeDirect = ih264d_decode_spatial_direct ; else ps_cur_slice -> pf_decodeDirect = ih264d_decode_temporal_direct ; if ( ! ( ( ps_pps -> ps_sps -> u1_mb_aff_flag ) && ( ! u1_field_pic_flag ) ) ) ps_dec -> pf_mvpred = ih264d_mvpred_nonmbaffB ; } else { if ( ! ( ( ps_pps -> ps_sps -> u1_mb_aff_flag ) && ( ! u1_field_pic_flag ) ) ) ps_dec -> pf_mvpred = ih264d_mvpred_nonmbaff ; } if ( ps_dec -> u4_first_slice_in_pic == 2 ) { if ( u2_first_mb_in_slice == 0 ) { ret = ih264d_start_of_pic ( ps_dec , i4_poc , & s_tmp_poc , u2_frame_num , ps_pps ) ; if ( ret != OK ) return ret ; } ps_dec -> u4_output_present = 0 ; { ih264d_get_next_display_field ( ps_dec , ps_dec -> ps_out_buffer , & ( ps_dec -> s_disp_op ) ) ; if ( 0 != ps_dec -> s_disp_op . u4_error_code ) { ps_dec -> u4_fmt_conv_cur_row = ps_dec -> s_disp_frame_info . u4_y_ht ; } else ps_dec -> u4_output_present = 1 ; } if ( ps_dec -> u1_separate_parse == 1 ) { if ( ps_dec -> u4_dec_thread_created == 0 ) { ithread_create ( ps_dec -> pv_dec_thread_handle , NULL , ( void * ) ih264d_decode_picture_thread , ( void * ) ps_dec ) ; ps_dec -> u4_dec_thread_created = 1 ; } if ( ( ps_dec -> u4_num_cores == 3 ) && ( ( ps_dec -> u4_app_disable_deblk_frm == 0 ) || ps_dec -> i1_recon_in_thread3_flag ) && ( ps_dec -> u4_bs_deblk_thread_created == 0 ) ) { ps_dec -> u4_start_recon_deblk = 0 ; ithread_create ( ps_dec -> pv_bs_deblk_thread_handle , NULL , ( void * ) ih264d_recon_deblk_thread , ( void * ) ps_dec ) ; ps_dec -> u4_bs_deblk_thread_created = 1 ; } } } { UWORD8 uc_nofield_nombaff ; uc_nofield_nombaff = ( ( ps_dec -> ps_cur_slice -> u1_field_pic_flag == 0 ) && ( ps_dec -> ps_cur_slice -> u1_mbaff_frame_flag == 0 ) && ( u1_slice_type != B_SLICE ) && ( ps_dec -> ps_cur_pps -> u1_wted_pred_flag == 0 ) ) ; if ( uc_nofield_nombaff ) { ps_dec -> p_form_mb_part_info = ih264d_form_mb_part_info_bp ; ps_dec -> p_motion_compensate = ih264d_motion_compensate_bp ; } else { ps_dec -> p_form_mb_part_info = ih264d_form_mb_part_info_mp ; ps_dec -> p_motion_compensate = ih264d_motion_compensate_mp ; } } { dec_err_status_t * ps_err = ps_dec -> ps_dec_err_status ; if ( ps_err -> u4_frm_sei_sync == u2_frame_num ) { ps_err -> u1_err_flag = ACCEPT_ALL_PICS ; ps_err -> u4_frm_sei_sync = SYNC_FRM_DEFAULT ; } ps_err -> u4_cur_frm = u2_frame_num ; } { WORD32 i4_skip_b_pic , i4_skip_p_pic ; i4_skip_b_pic = ( ps_dec -> u4_skip_frm_mask & B_SLC_BIT ) && ( B_SLICE == u1_slice_type ) && ( 0 == u1_nal_ref_idc ) ; i4_skip_p_pic = ( ps_dec -> u4_skip_frm_mask & P_SLC_BIT ) && ( P_SLICE == u1_slice_type ) && ( 0 == u1_nal_ref_idc ) ; if ( i4_skip_b_pic ) { ps_dec -> ps_cur_pic -> u4_pack_slc_typ |= B_SLC_BIT ; ps_dec -> u1_last_pic_not_decoded = 1 ; return OK ; } if ( i4_skip_p_pic ) { ps_dec -> ps_cur_pic -> u4_pack_slc_typ |= P_SLC_BIT ; ps_dec -> u1_last_pic_not_decoded = 1 ; return OK ; } } { UWORD16 u2_mb_x , u2_mb_y ; ps_dec -> i4_submb_ofst = ( ( u2_first_mb_in_slice << ps_cur_slice -> u1_mbaff_frame_flag ) * SUB_BLK_SIZE ) - SUB_BLK_SIZE ; if ( u2_first_mb_in_slice ) { UWORD8 u1_mb_aff ; UWORD8 u1_field_pic ; UWORD16 u2_frm_wd_in_mbs ; u2_frm_wd_in_mbs = ps_seq -> u2_frm_wd_in_mbs ; u1_mb_aff = ps_cur_slice -> u1_mbaff_frame_flag ; u1_field_pic = ps_cur_slice -> u1_field_pic_flag ; { UWORD32 x_offset ; UWORD32 y_offset ; UWORD32 u4_frame_stride ; tfr_ctxt_t * ps_trns_addr ; if ( ps_dec -> u1_separate_parse ) { ps_trns_addr = & ps_dec -> s_tran_addrecon_parse ; } else { ps_trns_addr = & ps_dec -> s_tran_addrecon ; } u2_mb_x = MOD ( u2_first_mb_in_slice , u2_frm_wd_in_mbs ) ; u2_mb_y = DIV ( u2_first_mb_in_slice , u2_frm_wd_in_mbs ) ; u2_mb_y <<= u1_mb_aff ; if ( ( u2_mb_x > u2_frm_wd_in_mbs - 1 ) || ( u2_mb_y > ps_dec -> u2_frm_ht_in_mbs - 1 ) ) { return ERROR_CORRUPTED_SLICE ; } u4_frame_stride = ps_dec -> u2_frm_wd_y << u1_field_pic ; x_offset = u2_mb_x << 4 ; y_offset = ( u2_mb_y * u4_frame_stride ) << 4 ; ps_trns_addr -> pu1_dest_y = ps_dec -> s_cur_pic . pu1_buf1 + x_offset + y_offset ; u4_frame_stride = ps_dec -> u2_frm_wd_uv << u1_field_pic ; x_offset >>= 1 ; y_offset = ( u2_mb_y * u4_frame_stride ) << 3 ; x_offset *= YUV420SP_FACTOR ; ps_trns_addr -> pu1_dest_u = ps_dec -> s_cur_pic . pu1_buf2 + x_offset + y_offset ; ps_trns_addr -> pu1_dest_v = ps_dec -> s_cur_pic . pu1_buf3 + x_offset + y_offset ; ps_trns_addr -> pu1_mb_y = ps_trns_addr -> pu1_dest_y ; ps_trns_addr -> pu1_mb_u = ps_trns_addr -> pu1_dest_u ; ps_trns_addr -> pu1_mb_v = ps_trns_addr -> pu1_dest_v ; if ( ps_dec -> u1_separate_parse == 1 ) { ps_dec -> ps_deblk_mbn = ps_dec -> ps_deblk_pic + ( u2_first_mb_in_slice << u1_mb_aff ) ; } else { ps_dec -> ps_deblk_mbn = ps_dec -> ps_deblk_pic + ( u2_first_mb_in_slice << u1_mb_aff ) ; } ps_dec -> u2_cur_mb_addr = ( u2_first_mb_in_slice << u1_mb_aff ) ; ps_dec -> ps_mv_cur = ps_dec -> s_cur_pic . ps_mv + ( ( u2_first_mb_in_slice << u1_mb_aff ) << 4 ) ; } } else { tfr_ctxt_t * ps_trns_addr ; if ( ps_dec -> u1_separate_parse ) { ps_trns_addr = & ps_dec -> s_tran_addrecon_parse ; } else { ps_trns_addr = & ps_dec -> s_tran_addrecon ; } u2_mb_x = 0xffff ; u2_mb_y = 0 ; ps_dec -> u2_cur_mb_addr = 0 ; ps_dec -> ps_deblk_mbn = ps_dec -> ps_deblk_pic ; ps_dec -> ps_mv_cur = ps_dec -> s_cur_pic . ps_mv ; ps_trns_addr -> pu1_dest_y = ps_dec -> s_cur_pic . pu1_buf1 ; ps_trns_addr -> pu1_dest_u = ps_dec -> s_cur_pic . pu1_buf2 ; ps_trns_addr -> pu1_dest_v = ps_dec -> s_cur_pic . pu1_buf3 ; ps_trns_addr -> pu1_mb_y = ps_trns_addr -> pu1_dest_y ; ps_trns_addr -> pu1_mb_u = ps_trns_addr -> pu1_dest_u ; ps_trns_addr -> pu1_mb_v = ps_trns_addr -> pu1_dest_v ; } ps_dec -> ps_part = ps_dec -> ps_parse_part_params ; ps_dec -> u2_mbx = ( MOD ( u2_first_mb_in_slice - 1 , ps_seq -> u2_frm_wd_in_mbs ) ) ; ps_dec -> u2_mby = ( DIV ( u2_first_mb_in_slice - 1 , ps_seq -> u2_frm_wd_in_mbs ) ) ; ps_dec -> u2_mby <<= ps_cur_slice -> u1_mbaff_frame_flag ; ps_dec -> i2_prev_slice_mbx = ps_dec -> u2_mbx ; ps_dec -> i2_prev_slice_mby = ps_dec -> u2_mby ; } ps_bitstrm -> u4_max_ofst += ps_dec -> ps_cur_pps -> u1_entropy_coding_mode ; ps_dec -> u1_B = ( u1_slice_type == B_SLICE ) ; ps_dec -> u4_next_mb_skip = 0 ; ps_dec -> ps_parse_cur_slice -> u4_first_mb_in_slice = ps_dec -> ps_cur_slice -> u2_first_mb_in_slice ; ps_dec -> ps_parse_cur_slice -> slice_type = ps_dec -> ps_cur_slice -> u1_slice_type ; ps_dec -> u4_start_recon_deblk = 1 ; { WORD32 num_entries ; WORD32 size ; UWORD8 * pu1_buf ; num_entries = MIN ( MAX_FRAMES , ps_dec -> u4_num_ref_frames_at_init ) ; num_entries = 2 * ( ( 2 * num_entries ) + 1 ) ; size = num_entries * sizeof ( void * ) ; size += PAD_MAP_IDX_POC * sizeof ( void * ) ; pu1_buf = ( UWORD8 * ) ps_dec -> pv_map_ref_idx_to_poc_buf ; pu1_buf += size * ps_dec -> u2_cur_slice_num ; ps_dec -> ps_parse_cur_slice -> ppv_map_ref_idx_to_poc = ( void * ) pu1_buf ; } if ( ps_dec -> u1_separate_parse ) { ps_dec -> ps_parse_cur_slice -> pv_tu_coeff_data_start = ps_dec -> pv_parse_tu_coeff_data ; } else { ps_dec -> pv_proc_tu_coeff_data = ps_dec -> pv_parse_tu_coeff_data ; } if ( u1_slice_type == I_SLICE ) { ps_dec -> ps_cur_pic -> u4_pack_slc_typ |= I_SLC_BIT ; ret = ih264d_parse_islice ( ps_dec , u2_first_mb_in_slice ) ; if ( ps_dec -> i4_pic_type != B_SLICE && ps_dec -> i4_pic_type != P_SLICE ) ps_dec -> i4_pic_type = I_SLICE ; } else if ( u1_slice_type == P_SLICE ) { ps_dec -> ps_cur_pic -> u4_pack_slc_typ |= P_SLC_BIT ; ret = ih264d_parse_pslice ( ps_dec , u2_first_mb_in_slice ) ; ps_dec -> u1_pr_sl_type = u1_slice_type ; if ( ps_dec -> i4_pic_type != B_SLICE ) ps_dec -> i4_pic_type = P_SLICE ; } else if ( u1_slice_type == B_SLICE ) { ps_dec -> ps_cur_pic -> u4_pack_slc_typ |= B_SLC_BIT ; ret = ih264d_parse_bslice ( ps_dec , u2_first_mb_in_slice ) ; ps_dec -> u1_pr_sl_type = u1_slice_type ; ps_dec -> i4_pic_type = B_SLICE ; } else return ERROR_INV_SLC_TYPE_T ; if ( ps_dec -> u1_slice_header_done ) { ps_dec -> u4_first_slice_in_pic = 0 ; ps_dec -> u1_first_slice_in_stream = 0 ; } if ( ret != OK ) return ret ; ps_dec -> i2_prev_slice_mbx = ps_dec -> u2_mbx ; ps_dec -> i2_prev_slice_mby = ps_dec -> u2_mby ; if ( ps_dec -> u2_total_mbs_coded >= ( ps_seq -> u2_max_mb_addr + 1 ) ) { ps_dec -> u1_pic_decode_done = 1 ; } { dec_err_status_t * ps_err = ps_dec -> ps_dec_err_status ; if ( ( ps_err -> u1_err_flag & REJECT_PB_PICS ) && ( ps_err -> u1_cur_pic_type == PIC_TYPE_I ) ) { ps_err -> u1_err_flag = ACCEPT_ALL_PICS ; } } PRINT_BIN_BIT_RATIO ( ps_dec ) return ret ; }
int hugetlb_mcopy_atomic_pte ( struct mm_struct * dst_mm , pte_t * dst_pte , struct vm_area_struct * dst_vma , unsigned long dst_addr , unsigned long src_addr , struct page * * pagep ) { <S2SV_StartBug> int vm_shared = dst_vma -> vm_flags & VM_SHARED ; <S2SV_EndBug> struct hstate * h = hstate_vma ( dst_vma ) ; pte_t _dst_pte ; spinlock_t * ptl ; int ret ; struct page * page ; if ( ! * pagep ) { ret = - ENOMEM ; page = alloc_huge_page ( dst_vma , dst_addr , 0 ) ; if ( IS_ERR ( page ) ) goto out ; ret = copy_huge_page_from_user ( page , ( const void __user * ) src_addr , pages_per_huge_page ( h ) , false ) ; if ( unlikely ( ret ) ) { ret = - EFAULT ; * pagep = page ; goto out ; } } else { page = * pagep ; * pagep = NULL ; } __SetPageUptodate ( page ) ; set_page_huge_active ( page ) ; <S2SV_StartBug> if ( vm_shared ) { <S2SV_EndBug> <S2SV_StartBug> struct address_space * mapping = dst_vma -> vm_file -> f_mapping ; <S2SV_EndBug> pgoff_t idx = vma_hugecache_offset ( h , dst_vma , dst_addr ) ; ret = huge_add_to_page_cache ( page , mapping , idx ) ; if ( ret ) goto out_release_nounlock ; } ptl = huge_pte_lockptr ( h , dst_mm , dst_pte ) ; <S2SV_StartBug> spin_lock ( ptl ) ; <S2SV_EndBug> ret = - EEXIST ; if ( ! huge_pte_none ( huge_ptep_get ( dst_pte ) ) ) goto out_release_unlock ; if ( vm_shared ) { page_dup_rmap ( page , true ) ; } else { ClearPagePrivate ( page ) ; hugepage_add_new_anon_rmap ( page , dst_vma , dst_addr ) ; } _dst_pte = make_huge_pte ( dst_vma , page , dst_vma -> vm_flags & VM_WRITE ) ; if ( dst_vma -> vm_flags & VM_WRITE ) _dst_pte = huge_pte_mkdirty ( _dst_pte ) ; _dst_pte = pte_mkyoung ( _dst_pte ) ; set_huge_pte_at ( dst_mm , dst_addr , dst_pte , _dst_pte ) ; ( void ) huge_ptep_set_access_flags ( dst_vma , dst_addr , dst_pte , _dst_pte , dst_vma -> vm_flags & VM_WRITE ) ; hugetlb_count_add ( pages_per_huge_page ( h ) , dst_mm ) ; update_mmu_cache ( dst_vma , dst_addr , dst_pte ) ; spin_unlock ( ptl ) ; if ( vm_shared ) unlock_page ( page ) ; ret = 0 ; out : return ret ; out_release_unlock : spin_unlock ( ptl ) ; if ( vm_shared ) unlock_page ( page ) ; out_release_nounlock : put_page ( page ) ; goto out ; }
static int list_table_status ( MYSQL * mysql , const char * db , const char * wild ) { <S2SV_StartBug> char query [ 1024 ] , * end ; <S2SV_EndBug> MYSQL_RES * result ; MYSQL_ROW row ; <S2SV_StartBug> end = strxmov ( query , "show<S2SV_blank>table<S2SV_blank>status<S2SV_blank>from<S2SV_blank>`" , db , "`" , NullS ) ; <S2SV_EndBug> <S2SV_StartBug> if ( wild && wild [ 0 ] ) <S2SV_EndBug> strxmov ( end , "<S2SV_blank>like<S2SV_blank>\'" , wild , "\'" , NullS ) ; if ( mysql_query ( mysql , query ) || ! ( result = mysql_store_result ( mysql ) ) ) { fprintf ( stderr , "%s:<S2SV_blank>Cannot<S2SV_blank>get<S2SV_blank>status<S2SV_blank>for<S2SV_blank>db:<S2SV_blank>%s,<S2SV_blank>table:<S2SV_blank>%s:<S2SV_blank>%s\\n" , my_progname , db , wild ? wild : "" , mysql_error ( mysql ) ) ; if ( mysql_errno ( mysql ) == ER_PARSE_ERROR ) fprintf ( stderr , "This<S2SV_blank>error<S2SV_blank>probably<S2SV_blank>means<S2SV_blank>that<S2SV_blank>your<S2SV_blank>MySQL<S2SV_blank>server<S2SV_blank>doesn\'t<S2SV_blank>support<S2SV_blank>the\\n\\\'show<S2SV_blank>table<S2SV_blank>status\'<S2SV_blank>command.\\n" ) ; return 1 ; } printf ( "Database:<S2SV_blank>%s" , db ) ; if ( wild ) printf ( "<S2SV_blank><S2SV_blank>Wildcard:<S2SV_blank>%s" , wild ) ; putchar ( '\\n' ) ; print_res_header ( result ) ; while ( ( row = mysql_fetch_row ( result ) ) ) print_res_row ( result , row ) ; print_res_top ( result ) ; mysql_free_result ( result ) ; return 0 ; }
int vp8_find_best_sub_pixel_step ( MACROBLOCK * x , BLOCK * b , BLOCKD * d , int_mv * bestmv , int_mv * ref_mv , int error_per_bit , const vp8_variance_fn_ptr_t * vfp , int * mvcost [ 2 ] , int * distortion , unsigned int * sse1 ) { int bestmse = INT_MAX ; int_mv startmv ; int_mv this_mv ; unsigned char * z = ( * ( b -> base_src ) + b -> src ) ; int left , right , up , down , diag ; unsigned int sse ; int whichdir ; int thismse ; int y_stride ; int pre_stride = x -> e_mbd . pre . y_stride ; unsigned char * base_pre = x -> e_mbd . pre . y_buffer ; # if ARCH_X86 || ARCH_X86_64 MACROBLOCKD * xd = & x -> e_mbd ; unsigned char * y_0 = base_pre + d -> offset + ( bestmv -> as_mv . row ) * pre_stride + bestmv -> as_mv . col ; unsigned char * y ; y_stride = 32 ; vfp -> copymem ( y_0 - 1 - pre_stride , pre_stride , xd -> y_buf , y_stride , 18 ) ; y = xd -> y_buf + y_stride + 1 ; # else unsigned char * y = base_pre + d -> offset + ( bestmv -> as_mv . row ) * pre_stride + bestmv -> as_mv . col ; y_stride = pre_stride ; # endif <S2SV_StartBug> bestmv -> as_mv . row <<= 3 ; <S2SV_EndBug> <S2SV_StartBug> bestmv -> as_mv . col <<= 3 ; <S2SV_EndBug> startmv = * bestmv ; bestmse = vfp -> vf ( y , y_stride , z , b -> src_stride , sse1 ) ; * distortion = bestmse ; bestmse += mv_err_cost ( bestmv , ref_mv , mvcost , error_per_bit ) ; this_mv . as_mv . row = startmv . as_mv . row ; this_mv . as_mv . col = ( ( startmv . as_mv . col - 8 ) | 4 ) ; thismse = vfp -> svf_halfpix_h ( y - 1 , y_stride , z , b -> src_stride , & sse ) ; left = thismse + mv_err_cost ( & this_mv , ref_mv , mvcost , error_per_bit ) ; if ( left < bestmse ) { * bestmv = this_mv ; bestmse = left ; * distortion = thismse ; * sse1 = sse ; } this_mv . as_mv . col += 8 ; thismse = vfp -> svf_halfpix_h ( y , y_stride , z , b -> src_stride , & sse ) ; right = thismse + mv_err_cost ( & this_mv , ref_mv , mvcost , error_per_bit ) ; if ( right < bestmse ) { * bestmv = this_mv ; bestmse = right ; * distortion = thismse ; * sse1 = sse ; } this_mv . as_mv . col = startmv . as_mv . col ; this_mv . as_mv . row = ( ( startmv . as_mv . row - 8 ) | 4 ) ; thismse = vfp -> svf_halfpix_v ( y - y_stride , y_stride , z , b -> src_stride , & sse ) ; up = thismse + mv_err_cost ( & this_mv , ref_mv , mvcost , error_per_bit ) ; if ( up < bestmse ) { * bestmv = this_mv ; bestmse = up ; * distortion = thismse ; * sse1 = sse ; } this_mv . as_mv . row += 8 ; thismse = vfp -> svf_halfpix_v ( y , y_stride , z , b -> src_stride , & sse ) ; down = thismse + mv_err_cost ( & this_mv , ref_mv , mvcost , error_per_bit ) ; if ( down < bestmse ) { * bestmv = this_mv ; bestmse = down ; * distortion = thismse ; * sse1 = sse ; } whichdir = ( left < right ? 0 : 1 ) + ( up < down ? 0 : 2 ) ; this_mv = startmv ; switch ( whichdir ) { case 0 : this_mv . as_mv . col = ( this_mv . as_mv . col - 8 ) | 4 ; this_mv . as_mv . row = ( this_mv . as_mv . row - 8 ) | 4 ; thismse = vfp -> svf_halfpix_hv ( y - 1 - y_stride , y_stride , z , b -> src_stride , & sse ) ; break ; case 1 : this_mv . as_mv . col += 4 ; this_mv . as_mv . row = ( this_mv . as_mv . row - 8 ) | 4 ; thismse = vfp -> svf_halfpix_hv ( y - y_stride , y_stride , z , b -> src_stride , & sse ) ; break ; case 2 : this_mv . as_mv . col = ( this_mv . as_mv . col - 8 ) | 4 ; this_mv . as_mv . row += 4 ; thismse = vfp -> svf_halfpix_hv ( y - 1 , y_stride , z , b -> src_stride , & sse ) ; break ; case 3 : default : this_mv . as_mv . col += 4 ; this_mv . as_mv . row += 4 ; thismse = vfp -> svf_halfpix_hv ( y , y_stride , z , b -> src_stride , & sse ) ; break ; } diag = thismse + mv_err_cost ( & this_mv , ref_mv , mvcost , error_per_bit ) ; if ( diag < bestmse ) { * bestmv = this_mv ; bestmse = diag ; * distortion = thismse ; * sse1 = sse ; } if ( bestmv -> as_mv . row < startmv . as_mv . row ) y -= y_stride ; if ( bestmv -> as_mv . col < startmv . as_mv . col ) y -- ; startmv = * bestmv ; this_mv . as_mv . row = startmv . as_mv . row ; if ( startmv . as_mv . col & 7 ) { this_mv . as_mv . col = startmv . as_mv . col - 2 ; thismse = vfp -> svf ( y , y_stride , this_mv . as_mv . col & 7 , this_mv . as_mv . row & 7 , z , b -> src_stride , & sse ) ; } else { this_mv . as_mv . col = ( startmv . as_mv . col - 8 ) | 6 ; thismse = vfp -> svf ( y - 1 , y_stride , 6 , this_mv . as_mv . row & 7 , z , b -> src_stride , & sse ) ; } left = thismse + mv_err_cost ( & this_mv , ref_mv , mvcost , error_per_bit ) ; if ( left < bestmse ) { * bestmv = this_mv ; bestmse = left ; * distortion = thismse ; * sse1 = sse ; } this_mv . as_mv . col += 4 ; thismse = vfp -> svf ( y , y_stride , this_mv . as_mv . col & 7 , this_mv . as_mv . row & 7 , z , b -> src_stride , & sse ) ; right = thismse + mv_err_cost ( & this_mv , ref_mv , mvcost , error_per_bit ) ; if ( right < bestmse ) { * bestmv = this_mv ; bestmse = right ; * distortion = thismse ; * sse1 = sse ; } this_mv . as_mv . col = startmv . as_mv . col ; if ( startmv . as_mv . row & 7 ) { this_mv . as_mv . row = startmv . as_mv . row - 2 ; thismse = vfp -> svf ( y , y_stride , this_mv . as_mv . col & 7 , this_mv . as_mv . row & 7 , z , b -> src_stride , & sse ) ; } else { this_mv . as_mv . row = ( startmv . as_mv . row - 8 ) | 6 ; thismse = vfp -> svf ( y - y_stride , y_stride , this_mv . as_mv . col & 7 , 6 , z , b -> src_stride , & sse ) ; } up = thismse + mv_err_cost ( & this_mv , ref_mv , mvcost , error_per_bit ) ; if ( up < bestmse ) { * bestmv = this_mv ; bestmse = up ; * distortion = thismse ; * sse1 = sse ; } this_mv . as_mv . row += 4 ; thismse = vfp -> svf ( y , y_stride , this_mv . as_mv . col & 7 , this_mv . as_mv . row & 7 , z , b -> src_stride , & sse ) ; down = thismse + mv_err_cost ( & this_mv , ref_mv , mvcost , error_per_bit ) ; if ( down < bestmse ) { * bestmv = this_mv ; bestmse = down ; * distortion = thismse ; * sse1 = sse ; } whichdir = ( left < right ? 0 : 1 ) + ( up < down ? 0 : 2 ) ; this_mv = startmv ; switch ( whichdir ) { case 0 : if ( startmv . as_mv . row & 7 ) { this_mv . as_mv . row -= 2 ; if ( startmv . as_mv . col & 7 ) { this_mv . as_mv . col -= 2 ; thismse = vfp -> svf ( y , y_stride , this_mv . as_mv . col & 7 , this_mv . as_mv . row & 7 , z , b -> src_stride , & sse ) ; } else { this_mv . as_mv . col = ( startmv . as_mv . col - 8 ) | 6 ; thismse = vfp -> svf ( y - 1 , y_stride , 6 , this_mv . as_mv . row & 7 , z , b -> src_stride , & sse ) ; ; } } else { this_mv . as_mv . row = ( startmv . as_mv . row - 8 ) | 6 ; if ( startmv . as_mv . col & 7 ) { this_mv . as_mv . col -= 2 ; thismse = vfp -> svf ( y - y_stride , y_stride , this_mv . as_mv . col & 7 , 6 , z , b -> src_stride , & sse ) ; } else { this_mv . as_mv . col = ( startmv . as_mv . col - 8 ) | 6 ; thismse = vfp -> svf ( y - y_stride - 1 , y_stride , 6 , 6 , z , b -> src_stride , & sse ) ; } } break ; case 1 : this_mv . as_mv . col += 2 ; if ( startmv . as_mv . row & 7 ) { this_mv . as_mv . row -= 2 ; thismse = vfp -> svf ( y , y_stride , this_mv . as_mv . col & 7 , this_mv . as_mv . row & 7 , z , b -> src_stride , & sse ) ; } else { this_mv . as_mv . row = ( startmv . as_mv . row - 8 ) | 6 ; thismse = vfp -> svf ( y - y_stride , y_stride , this_mv . as_mv . col & 7 , 6 , z , b -> src_stride , & sse ) ; } break ; case 2 : this_mv . as_mv . row += 2 ; if ( startmv . as_mv . col & 7 ) { this_mv . as_mv . col -= 2 ; thismse = vfp -> svf ( y , y_stride , this_mv . as_mv . col & 7 , this_mv . as_mv . row & 7 , z , b -> src_stride , & sse ) ; } else { this_mv . as_mv . col = ( startmv . as_mv . col - 8 ) | 6 ; thismse = vfp -> svf ( y - 1 , y_stride , 6 , this_mv . as_mv . row & 7 , z , b -> src_stride , & sse ) ; } break ; case 3 : this_mv . as_mv . col += 2 ; this_mv . as_mv . row += 2 ; thismse = vfp -> svf ( y , y_stride , this_mv . as_mv . col & 7 , this_mv . as_mv . row & 7 , z , b -> src_stride , & sse ) ; break ; } diag = thismse + mv_err_cost ( & this_mv , ref_mv , mvcost , error_per_bit ) ; if ( diag < bestmse ) { * bestmv = this_mv ; bestmse = diag ; * distortion = thismse ; * sse1 = sse ; } return bestmse ; }
generic_ret * delete_principal_2_svc ( dprinc_arg * arg , struct svc_req * rqstp ) { static generic_ret ret ; char * prime_arg ; <S2SV_StartBug> gss_buffer_desc client_name , <S2SV_EndBug> service_name ; OM_uint32 minor_stat ; kadm5_server_handle_t handle ; const char * errmsg = NULL ; xdr_free ( xdr_generic_ret , & ret ) ; if ( ( ret . code = new_server_handle ( arg -> api_version , rqstp , & handle ) ) ) goto exit_func ; if ( ( ret . code = check_handle ( ( void * ) handle ) ) ) goto exit_func ; ret . api_version = handle -> api_version ; if ( setup_gss_names ( rqstp , & client_name , & service_name ) < 0 ) { ret . code = KADM5_FAILURE ; goto exit_func ; } if ( krb5_unparse_name ( handle -> context , arg -> princ , & prime_arg ) ) { ret . code = KADM5_BAD_PRINCIPAL ; goto exit_func ; } if ( CHANGEPW_SERVICE ( rqstp ) || ! kadm5int_acl_check ( handle -> context , rqst2name ( rqstp ) , ACL_DELETE , arg -> princ , NULL ) ) { ret . code = KADM5_AUTH_DELETE ; log_unauth ( "kadm5_delete_principal" , prime_arg , & client_name , & service_name , rqstp ) ; } else { ret . code = kadm5_delete_principal ( ( void * ) handle , arg -> princ ) ; if ( ret . code != 0 ) errmsg = krb5_get_error_message ( handle -> context , ret . code ) ; log_done ( "kadm5_delete_principal" , prime_arg , errmsg , & client_name , & service_name , rqstp ) ; if ( errmsg != NULL ) krb5_free_error_message ( handle -> context , errmsg ) ; } free ( prime_arg ) ; <S2SV_StartBug> gss_release_buffer ( & minor_stat , & client_name ) ; <S2SV_EndBug> gss_release_buffer ( & minor_stat , & service_name ) ; <S2SV_StartBug> exit_func : <S2SV_EndBug> free_server_handle ( handle ) ; return & ret ; }
static int sd_ioctl ( struct block_device * bdev , fmode_t mode , unsigned int cmd , unsigned long arg ) { struct gendisk * disk = bdev -> bd_disk ; struct scsi_disk * sdkp = scsi_disk ( disk ) ; struct scsi_device * sdp = sdkp -> device ; void __user * p = ( void __user * ) arg ; int error ; SCSI_LOG_IOCTL ( 1 , sd_printk ( KERN_INFO , sdkp , "sd_ioctl:<S2SV_blank>disk=%s,<S2SV_blank>" "cmd=0x%x\\n" , disk -> disk_name , cmd ) ) ; <S2SV_StartBug> error = scsi_nonblockable_ioctl ( sdp , cmd , p , <S2SV_EndBug> ( mode & FMODE_NDELAY ) != 0 ) ; if ( ! scsi_block_when_processing_errors ( sdp ) || ! error ) goto out ; switch ( cmd ) { case SCSI_IOCTL_GET_IDLUN : case SCSI_IOCTL_GET_BUS_NUMBER : error = scsi_ioctl ( sdp , cmd , p ) ; break ; default : error = scsi_cmd_blk_ioctl ( bdev , mode , cmd , p ) ; if ( error != - ENOTTY ) break ; error = scsi_ioctl ( sdp , cmd , p ) ; break ; } out : return error ; }
int get_rock_ridge_filename ( struct iso_directory_record * de , char * retname , struct inode * inode ) { struct rock_state rs ; struct rock_ridge * rr ; int sig ; int retnamlen = 0 ; int truncate = 0 ; int ret = 0 ; <S2SV_StartBug> if ( ! ISOFS_SB ( inode -> i_sb ) -> s_rock ) <S2SV_EndBug> return 0 ; * retname = 0 ; init_rock_state ( & rs , inode ) ; setup_rock_ridge ( de , inode , & rs ) ; repeat : while ( rs . len > 2 ) { rr = ( struct rock_ridge * ) rs . chr ; if ( rr -> len < 3 ) goto out ; sig = isonum_721 ( rs . chr ) ; if ( rock_check_overflow ( & rs , sig ) ) goto eio ; rs . chr += rr -> len ; rs . len -= rr -> len ; if ( rs . len < 0 ) goto out ; switch ( sig ) { case SIG ( 'R' , 'R' ) : if ( ( rr -> u . RR . flags [ 0 ] & RR_NM ) == 0 ) goto out ; break ; case SIG ( 'S' , 'P' ) : if ( check_sp ( rr , inode ) ) goto out ; break ; case SIG ( 'C' , 'E' ) : rs . cont_extent = isonum_733 ( rr -> u . CE . extent ) ; rs . cont_offset = isonum_733 ( rr -> u . CE . offset ) ; rs . cont_size = isonum_733 ( rr -> u . CE . size ) ; break ; case SIG ( 'N' , 'M' ) : if ( truncate ) break ; if ( rr -> len < 5 ) break ; if ( rr -> u . NM . flags & 6 ) break ; if ( rr -> u . NM . flags & ~ 1 ) { printk ( "Unsupported<S2SV_blank>NM<S2SV_blank>flag<S2SV_blank>settings<S2SV_blank>(%d)\\n" , rr -> u . NM . flags ) ; break ; } <S2SV_StartBug> if ( ( strlen ( retname ) + rr -> len - 5 ) >= 254 ) { <S2SV_EndBug> truncate = 1 ; break ; } <S2SV_StartBug> strncat ( retname , rr -> u . NM . name , rr -> len - 5 ) ; <S2SV_EndBug> <S2SV_StartBug> retnamlen += rr -> len - 5 ; <S2SV_EndBug> break ; case SIG ( 'R' , 'E' ) : kfree ( rs . buffer ) ; return - 1 ; default : break ; } } ret = rock_continue ( & rs ) ; if ( ret == 0 ) goto repeat ; if ( ret == 1 ) return retnamlen ; out : kfree ( rs . buffer ) ; return ret ; eio : ret = - EIO ; goto out ; }
int main ( int argc , char * * argv ) { FILE * infile = NULL ; <S2SV_StartBug> VpxVideoWriter * writer = NULL ; <S2SV_EndBug> vpx_codec_ctx_t codec ; vpx_codec_enc_cfg_t cfg ; vpx_image_t raw ; vpx_codec_err_t res ; <S2SV_StartBug> vpx_fixed_buf_t stats = { 0 } ; <S2SV_EndBug> VpxVideoInfo info = { 0 } ; <S2SV_StartBug> const VpxInterface * encoder = NULL ; <S2SV_EndBug> int pass ; const int fps = 30 ; const int bitrate = 200 ; const char * const codec_arg = argv [ 1 ] ; const char * const width_arg = argv [ 2 ] ; const char * const height_arg = argv [ 3 ] ; const char * const infile_arg = argv [ 4 ] ; const char * const outfile_arg = argv [ 5 ] ; exec_name = argv [ 0 ] ; if ( argc != 6 ) die ( "Invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>arguments." ) ; encoder = get_vpx_encoder_by_name ( codec_arg ) ; if ( ! encoder ) die ( "Unsupported<S2SV_blank>codec." ) ; <S2SV_StartBug> info . codec_fourcc = encoder -> fourcc ; <S2SV_EndBug> info . time_base . numerator = 1 ; info . time_base . denominator = fps ; info . frame_width = strtol ( width_arg , NULL , 0 ) ; <S2SV_StartBug> info . frame_height = strtol ( height_arg , NULL , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( info . frame_width <= 0 || <S2SV_EndBug> <S2SV_StartBug> info . frame_height <= 0 || <S2SV_EndBug> <S2SV_StartBug> ( info . frame_width % 2 ) != 0 || <S2SV_EndBug> <S2SV_StartBug> ( info . frame_height % 2 ) != 0 ) { <S2SV_EndBug> <S2SV_StartBug> die ( "Invalid<S2SV_blank>frame<S2SV_blank>size:<S2SV_blank>%dx%d" , info . frame_width , info . frame_height ) ; <S2SV_EndBug> } <S2SV_StartBug> if ( ! vpx_img_alloc ( & raw , VPX_IMG_FMT_I420 , info . frame_width , <S2SV_EndBug> <S2SV_StartBug> info . frame_height , 1 ) ) { <S2SV_EndBug> <S2SV_StartBug> die ( "Failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>image" , info . frame_width , info . frame_height ) ; <S2SV_EndBug> } writer = vpx_video_writer_open ( outfile_arg , kContainerIVF , & info ) ; if ( ! writer ) die ( "Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>writing" , outfile_arg ) ; printf ( "Using<S2SV_blank>%s\\n" , vpx_codec_iface_name ( encoder -> interface ( ) ) ) ; res = vpx_codec_enc_config_default ( encoder -> interface ( ) , & cfg , 0 ) ; if ( res ) die_codec ( & codec , "Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>default<S2SV_blank>codec<S2SV_blank>config." ) ; cfg . g_w = info . frame_width ; cfg . g_h = info . frame_height ; cfg . g_timebase . num = info . time_base . numerator ; cfg . g_timebase . den = info . time_base . denominator ; cfg . rc_target_bitrate = bitrate ; for ( pass = 0 ; pass < 2 ; ++ pass ) { int frame_count = 0 ; if ( pass == 0 ) { cfg . g_pass = VPX_RC_FIRST_PASS ; } else { cfg . g_pass = VPX_RC_LAST_PASS ; cfg . rc_twopass_stats_in = stats ; } if ( ! ( infile = fopen ( infile_arg , "rb" ) ) ) die ( "Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading" , infile_arg ) ; if ( vpx_codec_enc_init ( & codec , encoder -> interface ( ) , & cfg , 0 ) ) die_codec ( & codec , "Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>encoder" ) ; <S2SV_StartBug> while ( vpx_img_read ( & raw , infile ) ) { <S2SV_EndBug> ++ frame_count ; if ( pass == 0 ) { get_frame_stats ( & codec , & raw , frame_count , 1 , 0 , VPX_DL_BEST_QUALITY , & stats ) ; } else { encode_frame ( & codec , & raw , frame_count , 1 , 0 , VPX_DL_BEST_QUALITY , writer ) ; } } if ( pass == 0 ) { get_frame_stats ( & codec , NULL , frame_count , 1 , 0 , VPX_DL_BEST_QUALITY , & stats ) ; } else { printf ( "\\n" ) ; } <S2SV_StartBug> fclose ( infile ) ; <S2SV_EndBug> printf ( "Pass<S2SV_blank>%d<S2SV_blank>complete.<S2SV_blank>Processed<S2SV_blank>%d<S2SV_blank>frames.\\n" , pass + 1 , frame_count ) ; if ( vpx_codec_destroy ( & codec ) ) die_codec ( & codec , "Failed<S2SV_blank>to<S2SV_blank>destroy<S2SV_blank>codec." ) ; } vpx_img_free ( & raw ) ; free ( stats . buf ) ; vpx_video_writer_close ( writer ) ; return EXIT_SUCCESS ; }
void cJSON_Delete ( cJSON * c ) { cJSON * next ; while ( c ) { next = c -> next ; if ( ! ( c -> type & cJSON_IsReference ) && c -> child ) cJSON_Delete ( c -> child ) ; if ( ! ( c -> type & cJSON_IsReference ) && c -> valuestring ) cJSON_free ( c -> valuestring ) ; <S2SV_StartBug> if ( c -> string ) <S2SV_EndBug> cJSON_free ( c -> string ) ; cJSON_free ( c ) ; c = next ; } }
<S2SV_StartBug> void vp9_inc_frame_in_layer ( SVC * svc ) { <S2SV_EndBug> <S2SV_StartBug> LAYER_CONTEXT * const lc = ( svc -> number_temporal_layers > 1 ) <S2SV_EndBug> ? & svc -> layer_context [ svc -> temporal_layer_id ] : & svc -> layer_context [ svc -> spatial_layer_id ] ; ++ lc -> current_video_frame_in_layer ; <S2SV_StartBug> } <S2SV_EndBug>
long FS_FOpenFileRead ( const char * filename , fileHandle_t * file , qboolean uniqueFILE ) { searchpath_t * search ; long len ; <S2SV_StartBug> if ( ! fs_searchpaths ) <S2SV_EndBug> Com_Error ( ERR_FATAL , "Filesystem<S2SV_blank>call<S2SV_blank>made<S2SV_blank>without<S2SV_blank>initialization" ) ; <S2SV_StartBug> for ( search = fs_searchpaths ; search ; search = search -> next ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> len = FS_FOpenFileReadDir ( filename , search , file , uniqueFILE , qfalse ) ; if ( file == NULL ) { if ( len > 0 ) return len ; } else { if ( len >= 0 && * file ) return len ; } } # ifdef FS_MISSING if ( missingFiles ) fprintf ( missingFiles , "%s\\n" , filename ) ; # endif if ( file ) { * file = 0 ; return - 1 ; } else { return 0 ; } }
static __inline__ void jiffies_to_compat_timeval ( unsigned long jiffies , struct compat_timeval * value ) { u64 nsec = ( u64 ) jiffies * TICK_NSEC ; <S2SV_StartBug> long rem ; <S2SV_EndBug> <S2SV_StartBug> value -> tv_sec = div_long_long_rem ( nsec , NSEC_PER_SEC , & rem ) ; <S2SV_EndBug> value -> tv_usec = rem / NSEC_PER_USEC ; }
static int bgp_attr_print ( netdissect_options * ndo , u_int atype , const u_char * pptr , u_int len ) { int i ; uint16_t af ; uint8_t safi , snpa , nhlen ; union { float f ; uint32_t i ; } bw ; int advance ; u_int tlen ; const u_char * tptr ; char buf [ MAXHOSTNAMELEN + 100 ] ; int as_size ; tptr = pptr ; tlen = len ; switch ( atype ) { case BGPTYPE_ORIGIN : if ( len != 1 ) ND_PRINT ( ( ndo , "invalid<S2SV_blank>len" ) ) ; else { ND_TCHECK ( * tptr ) ; ND_PRINT ( ( ndo , "%s" , tok2str ( bgp_origin_values , "Unknown<S2SV_blank>Origin<S2SV_blank>Typecode" , tptr [ 0 ] ) ) ) ; } break ; case BGPTYPE_AS4_PATH : case BGPTYPE_AS_PATH : if ( len % 2 ) { ND_PRINT ( ( ndo , "invalid<S2SV_blank>len" ) ) ; break ; } if ( ! len ) { ND_PRINT ( ( ndo , "empty" ) ) ; break ; } as_size = bgp_attr_get_as_size ( ndo , atype , pptr , len ) ; while ( tptr < pptr + len ) { ND_TCHECK ( tptr [ 0 ] ) ; ND_PRINT ( ( ndo , "%s" , tok2str ( bgp_as_path_segment_open_values , "?" , tptr [ 0 ] ) ) ) ; ND_TCHECK ( tptr [ 1 ] ) ; for ( i = 0 ; i < tptr [ 1 ] * as_size ; i += as_size ) { ND_TCHECK2 ( tptr [ 2 + i ] , as_size ) ; ND_PRINT ( ( ndo , "%s<S2SV_blank>" , as_printf ( ndo , astostr , sizeof ( astostr ) , as_size == 2 ? EXTRACT_16BITS ( & tptr [ 2 + i ] ) : EXTRACT_32BITS ( & tptr [ 2 + i ] ) ) ) ) ; } ND_TCHECK ( tptr [ 0 ] ) ; ND_PRINT ( ( ndo , "%s" , tok2str ( bgp_as_path_segment_close_values , "?" , tptr [ 0 ] ) ) ) ; ND_TCHECK ( tptr [ 1 ] ) ; tptr += 2 + tptr [ 1 ] * as_size ; } break ; case BGPTYPE_NEXT_HOP : if ( len != 4 ) ND_PRINT ( ( ndo , "invalid<S2SV_blank>len" ) ) ; else { ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , "%s" , ipaddr_string ( ndo , tptr ) ) ) ; } break ; case BGPTYPE_MULTI_EXIT_DISC : case BGPTYPE_LOCAL_PREF : if ( len != 4 ) ND_PRINT ( ( ndo , "invalid<S2SV_blank>len" ) ) ; else { ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , "%u" , EXTRACT_32BITS ( tptr ) ) ) ; } break ; case BGPTYPE_ATOMIC_AGGREGATE : if ( len != 0 ) ND_PRINT ( ( ndo , "invalid<S2SV_blank>len" ) ) ; break ; case BGPTYPE_AGGREGATOR : if ( len != 6 && len != 8 ) { ND_PRINT ( ( ndo , "invalid<S2SV_blank>len" ) ) ; break ; } ND_TCHECK2 ( tptr [ 0 ] , len ) ; if ( len == 6 ) { ND_PRINT ( ( ndo , "<S2SV_blank>AS<S2SV_blank>#%s,<S2SV_blank>origin<S2SV_blank>%s" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_16BITS ( tptr ) ) , ipaddr_string ( ndo , tptr + 2 ) ) ) ; } else { ND_PRINT ( ( ndo , "<S2SV_blank>AS<S2SV_blank>#%s,<S2SV_blank>origin<S2SV_blank>%s" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( tptr ) ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; } break ; case BGPTYPE_AGGREGATOR4 : if ( len != 8 ) { ND_PRINT ( ( ndo , "invalid<S2SV_blank>len" ) ) ; break ; } ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , "<S2SV_blank>AS<S2SV_blank>#%s,<S2SV_blank>origin<S2SV_blank>%s" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( tptr ) ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; break ; case BGPTYPE_COMMUNITIES : if ( len % 4 ) { ND_PRINT ( ( ndo , "invalid<S2SV_blank>len" ) ) ; break ; } while ( tlen > 0 ) { uint32_t comm ; ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; comm = EXTRACT_32BITS ( tptr ) ; switch ( comm ) { case BGP_COMMUNITY_NO_EXPORT : ND_PRINT ( ( ndo , "<S2SV_blank>NO_EXPORT" ) ) ; break ; case BGP_COMMUNITY_NO_ADVERT : ND_PRINT ( ( ndo , "<S2SV_blank>NO_ADVERTISE" ) ) ; break ; case BGP_COMMUNITY_NO_EXPORT_SUBCONFED : ND_PRINT ( ( ndo , "<S2SV_blank>NO_EXPORT_SUBCONFED" ) ) ; break ; default : ND_PRINT ( ( ndo , "%u:%u%s" , ( comm >> 16 ) & 0xffff , comm & 0xffff , ( tlen > 4 ) ? ",<S2SV_blank>" : "" ) ) ; break ; } tlen -= 4 ; tptr += 4 ; } break ; case BGPTYPE_ORIGINATOR_ID : if ( len != 4 ) { ND_PRINT ( ( ndo , "invalid<S2SV_blank>len" ) ) ; break ; } ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , "%s" , ipaddr_string ( ndo , tptr ) ) ) ; break ; case BGPTYPE_CLUSTER_LIST : if ( len % 4 ) { ND_PRINT ( ( ndo , "invalid<S2SV_blank>len" ) ) ; break ; } while ( tlen > 0 ) { ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , "%s%s" , ipaddr_string ( ndo , tptr ) , ( tlen > 4 ) ? ",<S2SV_blank>" : "" ) ) ; tlen -= 4 ; tptr += 4 ; } break ; case BGPTYPE_MP_REACH_NLRI : ND_TCHECK2 ( tptr [ 0 ] , 3 ) ; af = EXTRACT_16BITS ( tptr ) ; safi = tptr [ 2 ] ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>AFI:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>%sSAFI:<S2SV_blank>%s<S2SV_blank>(%u)" , tok2str ( af_values , "Unknown<S2SV_blank>AFI" , af ) , af , ( safi > 128 ) ? "vendor<S2SV_blank>specific<S2SV_blank>" : "" , tok2str ( bgp_safi_values , "Unknown<S2SV_blank>SAFI" , safi ) , safi ) ) ; switch ( af << 8 | safi ) { case ( AFNUM_INET << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_LABUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_RT_ROUTING_INFO ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNIMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST_VPN ) : case ( AFNUM_INET << 8 | SAFNUM_MDT ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_LABUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNIMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNIMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNIMULTICAST ) : case ( AFNUM_VPLS << 8 | SAFNUM_VPLS ) : break ; default : ND_TCHECK2 ( tptr [ 0 ] , tlen ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>no<S2SV_blank>AFI<S2SV_blank>%u<S2SV_blank>/<S2SV_blank>SAFI<S2SV_blank>%u<S2SV_blank>decoder" , af , safi ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" , tlen ) ; goto done ; break ; } tptr += 3 ; ND_TCHECK ( tptr [ 0 ] ) ; nhlen = tptr [ 0 ] ; tlen = nhlen ; tptr ++ ; if ( tlen ) { int nnh = 0 ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>nexthop:<S2SV_blank>" ) ) ; while ( tlen > 0 ) { if ( nnh ++ > 0 ) { ND_PRINT ( ( ndo , ",<S2SV_blank>" ) ) ; } switch ( af << 8 | safi ) { case ( AFNUM_INET << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_LABUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_RT_ROUTING_INFO ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST_VPN ) : case ( AFNUM_INET << 8 | SAFNUM_MDT ) : if ( tlen < ( int ) sizeof ( struct in_addr ) ) { ND_PRINT ( ( ndo , "invalid<S2SV_blank>len" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in_addr ) ) ; ND_PRINT ( ( ndo , "%s" , ipaddr_string ( ndo , tptr ) ) ) ; tlen -= sizeof ( struct in_addr ) ; tptr += sizeof ( struct in_addr ) ; } break ; case ( AFNUM_INET << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNIMULTICAST ) : if ( tlen < ( int ) ( sizeof ( struct in_addr ) + BGP_VPN_RD_LEN ) ) { ND_PRINT ( ( ndo , "invalid<S2SV_blank>len" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in_addr ) + BGP_VPN_RD_LEN ) ; ND_PRINT ( ( ndo , "RD:<S2SV_blank>%s,<S2SV_blank>%s" , bgp_vpn_rd_print ( ndo , tptr ) , ipaddr_string ( ndo , tptr + BGP_VPN_RD_LEN ) ) ) ; tlen -= ( sizeof ( struct in_addr ) + BGP_VPN_RD_LEN ) ; tptr += ( sizeof ( struct in_addr ) + BGP_VPN_RD_LEN ) ; } break ; case ( AFNUM_INET6 << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_LABUNICAST ) : if ( tlen < ( int ) sizeof ( struct in6_addr ) ) { ND_PRINT ( ( ndo , "invalid<S2SV_blank>len" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in6_addr ) ) ; ND_PRINT ( ( ndo , "%s" , ip6addr_string ( ndo , tptr ) ) ) ; tlen -= sizeof ( struct in6_addr ) ; tptr += sizeof ( struct in6_addr ) ; } break ; case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNIMULTICAST ) : if ( tlen < ( int ) ( sizeof ( struct in6_addr ) + BGP_VPN_RD_LEN ) ) { ND_PRINT ( ( ndo , "invalid<S2SV_blank>len" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in6_addr ) + BGP_VPN_RD_LEN ) ; ND_PRINT ( ( ndo , "RD:<S2SV_blank>%s,<S2SV_blank>%s" , bgp_vpn_rd_print ( ndo , tptr ) , ip6addr_string ( ndo , tptr + BGP_VPN_RD_LEN ) ) ) ; tlen -= ( sizeof ( struct in6_addr ) + BGP_VPN_RD_LEN ) ; tptr += ( sizeof ( struct in6_addr ) + BGP_VPN_RD_LEN ) ; } break ; case ( AFNUM_VPLS << 8 | SAFNUM_VPLS ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNIMULTICAST ) : if ( tlen < ( int ) sizeof ( struct in_addr ) ) { ND_PRINT ( ( ndo , "invalid<S2SV_blank>len" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in_addr ) ) ; ND_PRINT ( ( ndo , "%s" , ipaddr_string ( ndo , tptr ) ) ) ; tlen -= ( sizeof ( struct in_addr ) ) ; tptr += ( sizeof ( struct in_addr ) ) ; } break ; case ( AFNUM_NSAP << 8 | SAFNUM_UNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNIMULTICAST ) : ND_TCHECK2 ( tptr [ 0 ] , tlen ) ; ND_PRINT ( ( ndo , "%s" , isonsap_string ( ndo , tptr , tlen ) ) ) ; tptr += tlen ; tlen = 0 ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNIMULTICAST ) : if ( tlen < BGP_VPN_RD_LEN + 1 ) { ND_PRINT ( ( ndo , "invalid<S2SV_blank>len" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , tlen ) ; ND_PRINT ( ( ndo , "RD:<S2SV_blank>%s,<S2SV_blank>%s" , bgp_vpn_rd_print ( ndo , tptr ) , isonsap_string ( ndo , tptr + BGP_VPN_RD_LEN , tlen - BGP_VPN_RD_LEN ) ) ) ; if ( EXTRACT_32BITS ( tptr + BGP_VPN_RD_LEN ) == 0x47000601 ) ND_PRINT ( ( ndo , "<S2SV_blank>=<S2SV_blank>%s" , ipaddr_string ( ndo , tptr + BGP_VPN_RD_LEN + 4 ) ) ) ; else if ( EXTRACT_24BITS ( tptr + BGP_VPN_RD_LEN ) == 0x350000 ) ND_PRINT ( ( ndo , "<S2SV_blank>=<S2SV_blank>%s" , ip6addr_string ( ndo , tptr + BGP_VPN_RD_LEN + 3 ) ) ) ; tptr += tlen ; tlen = 0 ; } break ; default : ND_TCHECK2 ( tptr [ 0 ] , tlen ) ; ND_PRINT ( ( ndo , "no<S2SV_blank>AFI<S2SV_blank>%u/SAFI<S2SV_blank>%u<S2SV_blank>decoder" , af , safi ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" , tlen ) ; tptr += tlen ; tlen = 0 ; goto done ; break ; } } } ND_PRINT ( ( ndo , ",<S2SV_blank>nh-length:<S2SV_blank>%u" , nhlen ) ) ; tptr += tlen ; ND_TCHECK ( tptr [ 0 ] ) ; snpa = tptr [ 0 ] ; tptr ++ ; if ( snpa ) { ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%u<S2SV_blank>SNPA" , snpa ) ) ; for ( ; snpa > 0 ; snpa -- ) { ND_TCHECK ( tptr [ 0 ] ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%d<S2SV_blank>bytes" , tptr [ 0 ] ) ) ; tptr += tptr [ 0 ] + 1 ; } } else { ND_PRINT ( ( ndo , ",<S2SV_blank>no<S2SV_blank>SNPA" ) ) ; } while ( tptr < pptr + len ) { switch ( af << 8 | safi ) { case ( AFNUM_INET << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_prefix4 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_LABUNICAST ) : advance = decode_labeled_prefix4 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_prefix4 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_RT_ROUTING_INFO ) : advance = decode_rt_routing_info ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_MULTICAST_VPN ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST_VPN ) : advance = decode_multicast_vpn ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_MDT ) : advance = decode_mdt_vpn_nlri ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_prefix6 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_LABUNICAST ) : advance = decode_labeled_prefix6 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_prefix6 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_VPLS << 8 | SAFNUM_VPLS ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_l2 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_UNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_clnp_prefix ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_clnp_prefix ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; default : ND_TCHECK2 ( * tptr , tlen ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>no<S2SV_blank>AFI<S2SV_blank>%u<S2SV_blank>/<S2SV_blank>SAFI<S2SV_blank>%u<S2SV_blank>decoder" , af , safi ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" , tlen ) ; advance = 0 ; tptr = pptr + len ; break ; } if ( advance < 0 ) break ; tptr += advance ; } done : break ; case BGPTYPE_MP_UNREACH_NLRI : ND_TCHECK2 ( tptr [ 0 ] , BGP_MP_NLRI_MINSIZE ) ; af = EXTRACT_16BITS ( tptr ) ; safi = tptr [ 2 ] ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>AFI:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>%sSAFI:<S2SV_blank>%s<S2SV_blank>(%u)" , tok2str ( af_values , "Unknown<S2SV_blank>AFI" , af ) , af , ( safi > 128 ) ? "vendor<S2SV_blank>specific<S2SV_blank>" : "" , tok2str ( bgp_safi_values , "Unknown<S2SV_blank>SAFI" , safi ) , safi ) ) ; if ( len == BGP_MP_NLRI_MINSIZE ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>End-of-Rib<S2SV_blank>Marker<S2SV_blank>(empty<S2SV_blank>NLRI)" ) ) ; tptr += 3 ; while ( tptr < pptr + len ) { switch ( af << 8 | safi ) { case ( AFNUM_INET << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_prefix4 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_LABUNICAST ) : advance = decode_labeled_prefix4 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_prefix4 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_prefix6 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_LABUNICAST ) : advance = decode_labeled_prefix6 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_prefix6 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_VPLS << 8 | SAFNUM_VPLS ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_l2 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_UNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_clnp_prefix ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_clnp_prefix ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_MDT ) : advance = decode_mdt_vpn_nlri ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_MULTICAST_VPN ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST_VPN ) : advance = decode_multicast_vpn ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; default : ND_TCHECK2 ( * ( tptr - 3 ) , tlen ) ; ND_PRINT ( ( ndo , "no<S2SV_blank>AFI<S2SV_blank>%u<S2SV_blank>/<S2SV_blank>SAFI<S2SV_blank>%u<S2SV_blank>decoder" , af , safi ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr - 3 , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" , tlen ) ; advance = 0 ; tptr = pptr + len ; break ; } if ( advance < 0 ) break ; tptr += advance ; } break ; case BGPTYPE_EXTD_COMMUNITIES : if ( len % 8 ) { ND_PRINT ( ( ndo , "invalid<S2SV_blank>len" ) ) ; break ; } while ( tlen > 0 ) { uint16_t extd_comm ; ND_TCHECK2 ( tptr [ 0 ] , 2 ) ; extd_comm = EXTRACT_16BITS ( tptr ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s<S2SV_blank>(0x%04x),<S2SV_blank>Flags<S2SV_blank>[%s]" , tok2str ( bgp_extd_comm_subtype_values , "unknown<S2SV_blank>extd<S2SV_blank>community<S2SV_blank>typecode" , extd_comm ) , extd_comm , bittok2str ( bgp_extd_comm_flag_values , "none" , extd_comm ) ) ) ; ND_TCHECK2 ( * ( tptr + 2 ) , 6 ) ; switch ( extd_comm ) { case BGP_EXT_COM_RT_0 : case BGP_EXT_COM_RO_0 : case BGP_EXT_COM_L2VPN_RT_0 : ND_PRINT ( ( ndo , ":<S2SV_blank>%u:%u<S2SV_blank>(=<S2SV_blank>%s)" , EXTRACT_16BITS ( tptr + 2 ) , EXTRACT_32BITS ( tptr + 4 ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; break ; case BGP_EXT_COM_RT_1 : case BGP_EXT_COM_RO_1 : case BGP_EXT_COM_L2VPN_RT_1 : case BGP_EXT_COM_VRF_RT_IMP : ND_PRINT ( ( ndo , ":<S2SV_blank>%s:%u" , ipaddr_string ( ndo , tptr + 2 ) , EXTRACT_16BITS ( tptr + 6 ) ) ) ; break ; case BGP_EXT_COM_RT_2 : case BGP_EXT_COM_RO_2 : ND_PRINT ( ( ndo , ":<S2SV_blank>%s:%u" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( tptr + 2 ) ) , EXTRACT_16BITS ( tptr + 6 ) ) ) ; break ; case BGP_EXT_COM_LINKBAND : bw . i = EXTRACT_32BITS ( tptr + 2 ) ; ND_PRINT ( ( ndo , ":<S2SV_blank>bandwidth:<S2SV_blank>%.3f<S2SV_blank>Mbps" , bw . f * 8 / 1000000 ) ) ; break ; case BGP_EXT_COM_VPN_ORIGIN : case BGP_EXT_COM_VPN_ORIGIN2 : case BGP_EXT_COM_VPN_ORIGIN3 : case BGP_EXT_COM_VPN_ORIGIN4 : case BGP_EXT_COM_OSPF_RID : case BGP_EXT_COM_OSPF_RID2 : ND_PRINT ( ( ndo , "%s" , ipaddr_string ( ndo , tptr + 2 ) ) ) ; break ; case BGP_EXT_COM_OSPF_RTYPE : case BGP_EXT_COM_OSPF_RTYPE2 : ND_PRINT ( ( ndo , ":<S2SV_blank>area:%s,<S2SV_blank>router-type:%s,<S2SV_blank>metric-type:%s%s" , ipaddr_string ( ndo , tptr + 2 ) , tok2str ( bgp_extd_comm_ospf_rtype_values , "unknown<S2SV_blank>(0x%02x)" , * ( tptr + 6 ) ) , ( * ( tptr + 7 ) & BGP_OSPF_RTYPE_METRIC_TYPE ) ? "E2" : "" , ( ( * ( tptr + 6 ) == BGP_OSPF_RTYPE_EXT ) || ( * ( tptr + 6 ) == BGP_OSPF_RTYPE_NSSA ) ) ? "E1" : "" ) ) ; break ; case BGP_EXT_COM_L2INFO : ND_PRINT ( ( ndo , ":<S2SV_blank>%s<S2SV_blank>Control<S2SV_blank>Flags<S2SV_blank>[0x%02x]:MTU<S2SV_blank>%u" , tok2str ( l2vpn_encaps_values , "unknown<S2SV_blank>encaps" , * ( tptr + 2 ) ) , * ( tptr + 3 ) , EXTRACT_16BITS ( tptr + 4 ) ) ) ; break ; case BGP_EXT_COM_SOURCE_AS : ND_PRINT ( ( ndo , ":<S2SV_blank>AS<S2SV_blank>%u" , EXTRACT_16BITS ( tptr + 2 ) ) ) ; break ; default : ND_TCHECK2 ( * tptr , 8 ) ; print_unknown_data ( ndo , tptr , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" , 8 ) ; break ; } tlen -= 8 ; tptr += 8 ; } break ; case BGPTYPE_PMSI_TUNNEL : { uint8_t tunnel_type , flags ; <S2SV_StartBug> tunnel_type = * ( tptr + 1 ) ; <S2SV_EndBug> flags = * tptr ; <S2SV_StartBug> tlen = len ; <S2SV_EndBug> ND_TCHECK2 ( tptr [ 0 ] , 5 ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Tunnel-type<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>Flags<S2SV_blank>[%s],<S2SV_blank>MPLS<S2SV_blank>Label<S2SV_blank>%u" , tok2str ( bgp_pmsi_tunnel_values , "Unknown" , tunnel_type ) , tunnel_type , bittok2str ( bgp_pmsi_flag_values , "none" , flags ) , EXTRACT_24BITS ( tptr + 2 ) >> 4 ) ) ; tptr += 5 ; tlen -= 5 ; switch ( tunnel_type ) { case BGP_PMSI_TUNNEL_PIM_SM : case BGP_PMSI_TUNNEL_PIM_BIDIR : ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Sender<S2SV_blank>%s,<S2SV_blank>P-Group<S2SV_blank>%s" , ipaddr_string ( ndo , tptr ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; break ; case BGP_PMSI_TUNNEL_PIM_SSM : ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Root-Node<S2SV_blank>%s,<S2SV_blank>P-Group<S2SV_blank>%s" , ipaddr_string ( ndo , tptr ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; break ; case BGP_PMSI_TUNNEL_INGRESS : ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Tunnel-Endpoint<S2SV_blank>%s" , ipaddr_string ( ndo , tptr ) ) ) ; break ; case BGP_PMSI_TUNNEL_LDP_P2MP : case BGP_PMSI_TUNNEL_LDP_MP2MP : ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Root-Node<S2SV_blank>%s,<S2SV_blank>LSP-ID<S2SV_blank>0x%08x" , ipaddr_string ( ndo , tptr ) , EXTRACT_32BITS ( tptr + 4 ) ) ) ; break ; case BGP_PMSI_TUNNEL_RSVP_P2MP : ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Extended-Tunnel-ID<S2SV_blank>%s,<S2SV_blank>P2MP-ID<S2SV_blank>0x%08x" , ipaddr_string ( ndo , tptr ) , EXTRACT_32BITS ( tptr + 4 ) ) ) ; break ; default : if ( ndo -> ndo_vflag <= 1 ) { print_unknown_data ( ndo , tptr , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" , tlen ) ; } } break ; } case BGPTYPE_AIGP : { uint8_t type ; uint16_t length ; tlen = len ; while ( tlen >= 3 ) { ND_TCHECK2 ( tptr [ 0 ] , 3 ) ; type = * tptr ; length = EXTRACT_16BITS ( tptr + 1 ) ; tptr += 3 ; tlen -= 3 ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s<S2SV_blank>TLV<S2SV_blank>(%u),<S2SV_blank>length<S2SV_blank>%u" , tok2str ( bgp_aigp_values , "Unknown" , type ) , type , length ) ) ; if ( length < 3 ) goto trunc ; length -= 3 ; ND_TCHECK2 ( tptr [ 3 ] , length ) ; switch ( type ) { case BGP_AIGP_TLV : if ( length < 8 ) goto trunc ; ND_PRINT ( ( ndo , ",<S2SV_blank>metric<S2SV_blank>%" PRIu64 , EXTRACT_64BITS ( tptr ) ) ) ; break ; default : if ( ndo -> ndo_vflag <= 1 ) { print_unknown_data ( ndo , tptr , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" , length ) ; } } tptr += length ; tlen -= length ; } break ; } case BGPTYPE_ATTR_SET : ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; if ( len < 4 ) goto trunc ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Origin<S2SV_blank>AS:<S2SV_blank>%s" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( tptr ) ) ) ) ; tptr += 4 ; len -= 4 ; while ( len ) { u_int aflags , alenlen , alen ; ND_TCHECK2 ( tptr [ 0 ] , 2 ) ; if ( len < 2 ) goto trunc ; aflags = * tptr ; atype = * ( tptr + 1 ) ; tptr += 2 ; len -= 2 ; alenlen = bgp_attr_lenlen ( aflags , tptr ) ; ND_TCHECK2 ( tptr [ 0 ] , alenlen ) ; if ( len < alenlen ) goto trunc ; alen = bgp_attr_len ( aflags , tptr ) ; tptr += alenlen ; len -= alenlen ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>length:<S2SV_blank>%u" , tok2str ( bgp_attr_values , "Unknown<S2SV_blank>Attribute" , atype ) , atype , alen ) ) ; if ( aflags ) { ND_PRINT ( ( ndo , ",<S2SV_blank>Flags<S2SV_blank>[%s%s%s%s" , aflags & 0x80 ? "O" : "" , aflags & 0x40 ? "T" : "" , aflags & 0x20 ? "P" : "" , aflags & 0x10 ? "E" : "" ) ) ; if ( aflags & 0xf ) ND_PRINT ( ( ndo , "+%x" , aflags & 0xf ) ) ; ND_PRINT ( ( ndo , "]:<S2SV_blank>" ) ) ; } if ( ! bgp_attr_print ( ndo , atype , tptr , alen ) ) return 0 ; tptr += alen ; len -= alen ; } break ; case BGPTYPE_LARGE_COMMUNITY : if ( len == 0 || len % 12 ) { ND_PRINT ( ( ndo , "invalid<S2SV_blank>len" ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" ) ) ; while ( len > 0 ) { ND_TCHECK2 ( * tptr , 12 ) ; ND_PRINT ( ( ndo , "%u:%u:%u%s" , EXTRACT_32BITS ( tptr ) , EXTRACT_32BITS ( tptr + 4 ) , EXTRACT_32BITS ( tptr + 8 ) , ( len > 12 ) ? ",<S2SV_blank>" : "" ) ) ; tptr += 12 ; len -= 12 ; } break ; default : ND_TCHECK2 ( * pptr , len ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>no<S2SV_blank>Attribute<S2SV_blank>%u<S2SV_blank>decoder" , atype ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , pptr , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" , len ) ; break ; } if ( ndo -> ndo_vflag > 1 && len ) { ND_TCHECK2 ( * pptr , len ) ; print_unknown_data ( ndo , pptr , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" , len ) ; } return 1 ; trunc : return 0 ; }
static Image * ReadMATImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image , * image2 = NULL , * rotated_image ; register Quantum * q ; unsigned int status ; MATHeader MATLAB_HDR ; size_t size ; size_t CellType ; QuantumInfo * quantum_info ; ImageInfo * clone_info ; int i ; ssize_t ldblk ; unsigned char * BImgBuff = NULL ; double MinVal , MaxVal ; unsigned z , z2 ; unsigned Frames ; int logging ; int sample_size ; MagickOffsetType filepos = 0x80 ; BlobInfo * blob ; size_t one ; unsigned int ( * ReadBlobXXXLong ) ( Image * image ) ; unsigned short ( * ReadBlobXXXShort ) ( Image * image ) ; void ( * ReadBlobDoublesXXX ) ( Image * image , size_t len , double * data ) ; void ( * ReadBlobFloatsXXX ) ( Image * image , size_t len , float * data ) ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; logging = LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "enter" ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } clone_info = CloneImageInfo ( image_info ) ; if ( ReadBlob ( image , 124 , ( unsigned char * ) & MATLAB_HDR . identific ) != 124 ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; MATLAB_HDR . Version = ReadBlobLSBShort ( image ) ; if ( ReadBlob ( image , 2 , ( unsigned char * ) & MATLAB_HDR . EndianIndicator ) != 2 ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "<S2SV_blank><S2SV_blank>Endian<S2SV_blank>%c%c" , MATLAB_HDR . EndianIndicator [ 0 ] , MATLAB_HDR . EndianIndicator [ 1 ] ) ; if ( ! strncmp ( MATLAB_HDR . EndianIndicator , "IM" , 2 ) ) { ReadBlobXXXLong = ReadBlobLSBLong ; ReadBlobXXXShort = ReadBlobLSBShort ; ReadBlobDoublesXXX = ReadBlobDoublesLSB ; ReadBlobFloatsXXX = ReadBlobFloatsLSB ; image -> endian = LSBEndian ; } else if ( ! strncmp ( MATLAB_HDR . EndianIndicator , "MI" , 2 ) ) { ReadBlobXXXLong = ReadBlobMSBLong ; ReadBlobXXXShort = ReadBlobMSBShort ; ReadBlobDoublesXXX = ReadBlobDoublesMSB ; ReadBlobFloatsXXX = ReadBlobFloatsMSB ; image -> endian = MSBEndian ; } else goto MATLAB_KO ; if ( strncmp ( MATLAB_HDR . identific , "MATLAB" , 6 ) ) MATLAB_KO : ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; filepos = TellBlob ( image ) ; while ( ! EOFBlob ( image ) ) { Frames = 1 ; ( void ) SeekBlob ( image , filepos , SEEK_SET ) ; MATLAB_HDR . DataType = ReadBlobXXXLong ( image ) ; if ( EOFBlob ( image ) ) break ; MATLAB_HDR . ObjectSize = ReadBlobXXXLong ( image ) ; if ( EOFBlob ( image ) ) break ; filepos += MATLAB_HDR . ObjectSize + 4 + 4 ; image2 = image ; # if defined ( MAGICKCORE_ZLIB_DELEGATE ) if ( MATLAB_HDR . DataType == miCOMPRESSED ) { image2 = DecompressBlock ( image , MATLAB_HDR . ObjectSize , clone_info , exception ) ; if ( image2 == NULL ) continue ; MATLAB_HDR . DataType = ReadBlobXXXLong ( image2 ) ; } # endif if ( MATLAB_HDR . DataType != miMATRIX ) continue ; MATLAB_HDR . unknown1 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown2 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown5 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . StructureClass = MATLAB_HDR . unknown5 & 0xFF ; MATLAB_HDR . StructureFlag = ( MATLAB_HDR . unknown5 >> 8 ) & 0xFF ; MATLAB_HDR . unknown3 = ReadBlobXXXLong ( image2 ) ; if ( image != image2 ) MATLAB_HDR . unknown4 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown4 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . DimFlag = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . SizeX = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . SizeY = ReadBlobXXXLong ( image2 ) ; switch ( MATLAB_HDR . DimFlag ) { case 8 : z2 = z = 1 ; break ; case 12 : z2 = z = ReadBlobXXXLong ( image2 ) ; ( void ) ReadBlobXXXLong ( image2 ) ; if ( z != 3 ) ThrowReaderException ( CoderError , "MultidimensionalMatricesAreNotSupported" ) ; break ; case 16 : z2 = z = ReadBlobXXXLong ( image2 ) ; if ( z != 3 && z != 1 ) ThrowReaderException ( CoderError , "MultidimensionalMatricesAreNotSupported" ) ; Frames = ReadBlobXXXLong ( image2 ) ; break ; default : ThrowReaderException ( CoderError , "MultidimensionalMatricesAreNotSupported" ) ; } MATLAB_HDR . Flag1 = ReadBlobXXXShort ( image2 ) ; MATLAB_HDR . NameFlag = ReadBlobXXXShort ( image2 ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "MATLAB_HDR.StructureClass<S2SV_blank>%d" , MATLAB_HDR . StructureClass ) ; if ( MATLAB_HDR . StructureClass != mxCHAR_CLASS && MATLAB_HDR . StructureClass != mxSINGLE_CLASS && MATLAB_HDR . StructureClass != mxDOUBLE_CLASS && MATLAB_HDR . StructureClass != mxINT8_CLASS && MATLAB_HDR . StructureClass != mxUINT8_CLASS && MATLAB_HDR . StructureClass != mxINT16_CLASS && MATLAB_HDR . StructureClass != mxUINT16_CLASS && MATLAB_HDR . StructureClass != mxINT32_CLASS && MATLAB_HDR . StructureClass != mxUINT32_CLASS && MATLAB_HDR . StructureClass != mxINT64_CLASS && MATLAB_HDR . StructureClass != mxUINT64_CLASS ) ThrowReaderException ( CoderError , "UnsupportedCellTypeInTheMatrix" ) ; switch ( MATLAB_HDR . NameFlag ) { case 0 : size = ReadBlobXXXLong ( image2 ) ; size = 4 * ( ssize_t ) ( ( size + 3 + 1 ) / 4 ) ; ( void ) SeekBlob ( image2 , size , SEEK_CUR ) ; break ; case 1 : case 2 : case 3 : case 4 : ( void ) ReadBlob ( image2 , 4 , ( unsigned char * ) & size ) ; break ; default : goto MATLAB_KO ; } CellType = ReadBlobXXXLong ( image2 ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "MATLAB_HDR.CellType:<S2SV_blank>%.20g" , ( double ) CellType ) ; ( void ) ReadBlob ( image2 , 4 , ( unsigned char * ) & size ) ; NEXT_FRAME : switch ( CellType ) { case miINT8 : case miUINT8 : sample_size = 8 ; if ( MATLAB_HDR . StructureFlag & FLAG_LOGICAL ) image -> depth = 1 ; else image -> depth = 8 ; ldblk = ( ssize_t ) MATLAB_HDR . SizeX ; break ; case miINT16 : case miUINT16 : sample_size = 16 ; image -> depth = 16 ; ldblk = ( ssize_t ) ( 2 * MATLAB_HDR . SizeX ) ; break ; case miINT32 : case miUINT32 : sample_size = 32 ; image -> depth = 32 ; ldblk = ( ssize_t ) ( 4 * MATLAB_HDR . SizeX ) ; break ; case miINT64 : case miUINT64 : sample_size = 64 ; image -> depth = 64 ; ldblk = ( ssize_t ) ( 8 * MATLAB_HDR . SizeX ) ; break ; case miSINGLE : sample_size = 32 ; image -> depth = 32 ; ( void ) SetImageOption ( clone_info , "quantum:format" , "floating-point" ) ; if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { } ldblk = ( ssize_t ) ( 4 * MATLAB_HDR . SizeX ) ; break ; case miDOUBLE : sample_size = 64 ; image -> depth = 64 ; ( void ) SetImageOption ( clone_info , "quantum:format" , "floating-point" ) ; DisableMSCWarning ( 4127 ) if ( sizeof ( double ) != 8 ) RestoreMSCWarning ThrowReaderException ( CoderError , "IncompatibleSizeOfDouble" ) ; if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { } ldblk = ( ssize_t ) ( 8 * MATLAB_HDR . SizeX ) ; break ; default : ThrowReaderException ( CoderError , "UnsupportedCellTypeInTheMatrix" ) ; } ( void ) sample_size ; image -> columns = MATLAB_HDR . SizeX ; image -> rows = MATLAB_HDR . SizeY ; quantum_info = AcquireQuantumInfo ( clone_info , image ) ; if ( quantum_info == ( QuantumInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; one = 1 ; image -> colors = one << image -> depth ; if ( image -> columns == 0 || image -> rows == 0 ) goto MATLAB_KO ; if ( ( MATLAB_HDR . DimFlag == 8 ) && ( ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) == 0 ) ) { image -> type = GrayscaleType ; SetImageColorspace ( image , GRAYColorspace , exception ) ; } if ( image_info -> ping ) { size_t temp = image -> columns ; image -> columns = image -> rows ; image -> rows = temp ; goto done_reading ; } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; BImgBuff = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ( ldblk ) , sizeof ( double ) ) ; if ( BImgBuff == NULL ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; MinVal = 0 ; MaxVal = 0 ; if ( CellType == miDOUBLE || CellType == miSINGLE ) { CalcMinMax ( image2 , image_info -> endian , MATLAB_HDR . SizeX , MATLAB_HDR . SizeY , CellType , ldblk , BImgBuff , & quantum_info -> minimum , & quantum_info -> maximum ) ; } if ( z == 1 ) z = 0 ; do { for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { q = GetAuthenticPixels ( image , 0 , MATLAB_HDR . SizeY - i - 1 , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "<S2SV_blank><S2SV_blank>MAT<S2SV_blank>set<S2SV_blank>image<S2SV_blank>pixels<S2SV_blank>returns<S2SV_blank>unexpected<S2SV_blank>NULL<S2SV_blank>on<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u." , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto done_reading ; } if ( ReadBlob ( image2 , ldblk , ( unsigned char * ) BImgBuff ) != ( ssize_t ) ldblk ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "<S2SV_blank><S2SV_blank>MAT<S2SV_blank>cannot<S2SV_blank>read<S2SV_blank>scanrow<S2SV_blank>%u<S2SV_blank>from<S2SV_blank>a<S2SV_blank>file." , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto ExitLoop ; } if ( ( CellType == miINT8 || CellType == miUINT8 ) && ( MATLAB_HDR . StructureFlag & FLAG_LOGICAL ) ) { FixLogical ( ( unsigned char * ) BImgBuff , ldblk ) ; if ( ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , z2qtype [ z ] , BImgBuff , exception ) <= 0 ) { ImportQuantumPixelsFailed : if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "<S2SV_blank><S2SV_blank>MAT<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>ImportQuantumPixels<S2SV_blank>for<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; break ; } } else { if ( ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , z2qtype [ z ] , BImgBuff , exception ) <= 0 ) goto ImportQuantumPixelsFailed ; if ( z <= 1 && ( CellType == miINT8 || CellType == miINT16 || CellType == miINT32 || CellType == miINT64 ) ) FixSignedValues ( image , q , MATLAB_HDR . SizeX ) ; } if ( ! SyncAuthenticPixels ( image , exception ) ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "<S2SV_blank><S2SV_blank>MAT<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>sync<S2SV_blank>image<S2SV_blank>pixels<S2SV_blank>for<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto ExitLoop ; } } } while ( z -- >= 2 ) ; <S2SV_StartBug> ExitLoop : <S2SV_EndBug> if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { CellType = ReadBlobXXXLong ( image2 ) ; i = ReadBlobXXXLong ( image2 ) ; if ( CellType == miDOUBLE || CellType == miSINGLE ) { CalcMinMax ( image2 , image_info -> endian , MATLAB_HDR . SizeX , MATLAB_HDR . SizeY , CellType , ldblk , BImgBuff , & MinVal , & MaxVal ) ; } if ( CellType == miDOUBLE ) for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { ReadBlobDoublesXXX ( image2 , ldblk , ( double * ) BImgBuff ) ; InsertComplexDoubleRow ( image , ( double * ) BImgBuff , i , MinVal , MaxVal , exception ) ; } if ( CellType == miSINGLE ) for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { ReadBlobFloatsXXX ( image2 , ldblk , ( float * ) BImgBuff ) ; InsertComplexFloatRow ( image , ( float * ) BImgBuff , i , MinVal , MaxVal , exception ) ; } } if ( ( MATLAB_HDR . DimFlag == 8 ) && ( ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) == 0 ) ) image -> type = GrayscaleType ; if ( image -> depth == 1 ) image -> type = BilevelType ; if ( image2 == image ) image2 = NULL ; rotated_image = RotateImage ( image , 90.0 , exception ) ; if ( rotated_image != ( Image * ) NULL ) { rotated_image -> page . x = 0 ; rotated_image -> page . y = 0 ; blob = rotated_image -> blob ; rotated_image -> blob = image -> blob ; rotated_image -> colors = image -> colors ; image -> blob = blob ; AppendImageToList ( & image , rotated_image ) ; DeleteImageFromList ( & image ) ; } done_reading : if ( image2 != NULL ) if ( image2 != image ) { DeleteImageFromList ( & image2 ) ; if ( clone_info ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } } } AcquireNextImage ( image_info , image , exception ) ; if ( image -> next == ( Image * ) NULL ) break ; image = SyncNextImageInList ( image ) ; image -> columns = image -> rows = 0 ; image -> colors = 0 ; RelinquishMagickMemory ( BImgBuff ) ; BImgBuff = NULL ; if ( -- Frames > 0 ) { z = z2 ; if ( image2 == NULL ) image2 = image ; goto NEXT_FRAME ; } if ( ( image2 != NULL ) && ( image2 != image ) ) { DeleteImageFromList ( & image2 ) ; if ( clone_info ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } } } } clone_info = DestroyImageInfo ( clone_info ) ; RelinquishMagickMemory ( BImgBuff ) ; CloseBlob ( image ) ; { Image * p ; ssize_t scene = 0 ; p = image ; image = NULL ; while ( p != ( Image * ) NULL ) { Image * tmp = p ; if ( ( p -> rows == 0 ) || ( p -> columns == 0 ) ) { p = p -> previous ; DeleteImageFromList ( & tmp ) ; } else { image = p ; p = p -> previous ; } } for ( p = image ; p != ( Image * ) NULL ; p = p -> next ) p -> scene = scene ++ ; } if ( clone_info != NULL ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } DestroyImageInfo ( clone_info ) ; clone_info = NULL ; } if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "return" ) ; if ( image == NULL ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; return ( image ) ; }
static enum rules_token lex ( struct scanner * s , union lvalue * val ) { skip_more_whitespace_and_comments : while ( is_space ( peek ( s ) ) ) if ( next ( s ) == '\\n' ) return TOK_END_OF_LINE ; if ( chr ( s , '#' ) ) { skip_to_eol ( s ) ; goto skip_more_whitespace_and_comments ; } if ( eof ( s ) ) return TOK_END_OF_FILE ; s -> token_line = s -> line ; s -> token_column = s -> column ; s -> buf_pos = 0 ; if ( chr ( s , '<' ) ) { <S2SV_StartBug> while ( peek ( s ) != '>' && ! eol ( s ) ) <S2SV_EndBug> buf_append ( s , next ( s ) ) ; if ( ! chr ( s , '>' ) ) { scanner_err ( s , "unterminated<S2SV_blank>keysym<S2SV_blank>literal" ) ; return TOK_ERROR ; } if ( ! buf_append ( s , '\\0' ) ) { scanner_err ( s , "keysym<S2SV_blank>literal<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long" ) ; return TOK_ERROR ; } val -> string . str = s -> buf ; val -> string . len = s -> buf_pos ; return TOK_LHS_KEYSYM ; } if ( chr ( s , ':' ) ) return TOK_COLON ; if ( chr ( s , '!' ) ) return TOK_BANG ; if ( chr ( s , '~' ) ) return TOK_TILDE ; if ( chr ( s , \'\\"\' ) ) { while ( ! eof ( s ) && ! eol ( s ) && peek ( s ) != \'\\"\' ) { if ( chr ( s , '\\\\' ) ) { uint8_t o ; if ( chr ( s , '\\\\' ) ) { buf_append ( s , '\\\\' ) ; } else if ( chr ( s , \'"\' ) ) { buf_append ( s , \'"\' ) ; } else if ( chr ( s , 'x' ) || chr ( s , 'X' ) ) { if ( hex ( s , & o ) ) buf_append ( s , ( char ) o ) ; else scanner_warn ( s , "illegal<S2SV_blank>hexadecimal<S2SV_blank>escape<S2SV_blank>sequence<S2SV_blank>in<S2SV_blank>string<S2SV_blank>literal" ) ; } else if ( oct ( s , & o ) ) { buf_append ( s , ( char ) o ) ; } else { scanner_warn ( s , "unknown<S2SV_blank>escape<S2SV_blank>sequence<S2SV_blank>(%c)<S2SV_blank>in<S2SV_blank>string<S2SV_blank>literal" , peek ( s ) ) ; } } else { buf_append ( s , next ( s ) ) ; } } if ( ! chr ( s , \'\\"\' ) ) { scanner_err ( s , "unterminated<S2SV_blank>string<S2SV_blank>literal" ) ; return TOK_ERROR ; } if ( ! buf_append ( s , '\\0' ) ) { scanner_err ( s , "string<S2SV_blank>literal<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long" ) ; return TOK_ERROR ; } if ( ! is_valid_utf8 ( s -> buf , s -> buf_pos - 1 ) ) { scanner_err ( s , "string<S2SV_blank>literal<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>UTF-8<S2SV_blank>string" ) ; return TOK_ERROR ; } val -> string . str = s -> buf ; val -> string . len = s -> buf_pos ; return TOK_STRING ; } if ( is_alpha ( peek ( s ) ) || peek ( s ) == '_' ) { s -> buf_pos = 0 ; while ( is_alnum ( peek ( s ) ) || peek ( s ) == '_' ) buf_append ( s , next ( s ) ) ; if ( ! buf_append ( s , '\\0' ) ) { scanner_err ( s , "identifier<S2SV_blank>is<S2SV_blank>too<S2SV_blank>long" ) ; return TOK_ERROR ; } if ( streq ( s -> buf , "include" ) ) return TOK_INCLUDE ; val -> string . str = s -> buf ; val -> string . len = s -> buf_pos ; return TOK_IDENT ; } skip_to_eol ( s ) ; scanner_err ( s , "unrecognized<S2SV_blank>token" ) ; return TOK_ERROR ; }
error_t enc624j600SoftReset ( NetInterface * interface ) { do { <S2SV_StartBug> enc624j600WriteReg ( interface , ENC624J600_REG_EUDAST , 0x1234 ) ; <S2SV_EndBug> <S2SV_StartBug> } while ( enc624j600ReadReg ( interface , ENC624J600_REG_EUDAST ) != 0x1234 ) ; <S2SV_EndBug> <S2SV_StartBug> while ( ( enc624j600ReadReg ( interface , ENC624J600_REG_ESTAT ) & ESTAT_CLKRDY ) == 0 ) <S2SV_EndBug> { } <S2SV_StartBug> enc624j600SetBit ( interface , ENC624J600_REG_ECON2 , ECON2_ETHRST ) ; <S2SV_EndBug> sleep ( 1 ) ; <S2SV_StartBug> if ( enc624j600ReadReg ( interface , ENC624J600_REG_EUDAST ) != 0x0000 ) <S2SV_EndBug> { return ERROR_FAILURE ; } sleep ( 1 ) ; return NO_ERROR ; }
static int parse_elements ( netdissect_options * ndo , struct mgmt_body_t * pbody , const u_char * p , int offset , u_int length ) { u_int elementlen ; struct ssid_t ssid ; struct challenge_t challenge ; struct rates_t rates ; struct ds_t ds ; struct cf_t cf ; struct tim_t tim ; pbody -> challenge_present = 0 ; pbody -> ssid_present = 0 ; pbody -> rates_present = 0 ; pbody -> ds_present = 0 ; pbody -> cf_present = 0 ; pbody -> tim_present = 0 ; while ( length != 0 ) { if ( ! ND_TTEST2 ( * ( p + offset ) , 2 ) ) return 0 ; if ( length < 2 ) return 0 ; elementlen = * ( p + offset + 1 ) ; if ( ! ND_TTEST2 ( * ( p + offset + 2 ) , elementlen ) ) return 0 ; if ( length < elementlen + 2 ) return 0 ; switch ( * ( p + offset ) ) { case E_SSID : memcpy ( & ssid , p + offset , 2 ) ; offset += 2 ; length -= 2 ; if ( ssid . length != 0 ) { if ( ssid . length > sizeof ( ssid . ssid ) - 1 ) return 0 ; <S2SV_StartBug> if ( ! ND_TTEST2 ( * ( p + offset ) , ssid . length ) ) <S2SV_EndBug> return 0 ; if ( length < ssid . length ) return 0 ; memcpy ( & ssid . ssid , p + offset , ssid . length ) ; offset += ssid . length ; length -= ssid . length ; } ssid . ssid [ ssid . length ] = '\\0' ; if ( ! pbody -> ssid_present ) { pbody -> ssid = ssid ; pbody -> ssid_present = 1 ; } break ; case E_CHALLENGE : memcpy ( & challenge , p + offset , 2 ) ; offset += 2 ; length -= 2 ; if ( challenge . length != 0 ) { if ( challenge . length > sizeof ( challenge . text ) - 1 ) return 0 ; <S2SV_StartBug> if ( ! ND_TTEST2 ( * ( p + offset ) , challenge . length ) ) <S2SV_EndBug> return 0 ; if ( length < challenge . length ) return 0 ; memcpy ( & challenge . text , p + offset , challenge . length ) ; offset += challenge . length ; length -= challenge . length ; } challenge . text [ challenge . length ] = '\\0' ; if ( ! pbody -> challenge_present ) { pbody -> challenge = challenge ; pbody -> challenge_present = 1 ; } break ; case E_RATES : memcpy ( & rates , p + offset , 2 ) ; offset += 2 ; length -= 2 ; if ( rates . length != 0 ) { if ( rates . length > sizeof rates . rate ) return 0 ; <S2SV_StartBug> if ( ! ND_TTEST2 ( * ( p + offset ) , rates . length ) ) <S2SV_EndBug> return 0 ; if ( length < rates . length ) return 0 ; memcpy ( & rates . rate , p + offset , rates . length ) ; offset += rates . length ; length -= rates . length ; } if ( ! pbody -> rates_present && rates . length != 0 ) { pbody -> rates = rates ; pbody -> rates_present = 1 ; } break ; case E_DS : memcpy ( & ds , p + offset , 2 ) ; offset += 2 ; length -= 2 ; if ( ds . length != 1 ) { offset += ds . length ; length -= ds . length ; break ; } ds . channel = * ( p + offset ) ; offset += 1 ; length -= 1 ; if ( ! pbody -> ds_present ) { pbody -> ds = ds ; pbody -> ds_present = 1 ; } break ; case E_CF : memcpy ( & cf , p + offset , 2 ) ; offset += 2 ; length -= 2 ; if ( cf . length != 6 ) { offset += cf . length ; length -= cf . length ; break ; } memcpy ( & cf . count , p + offset , 6 ) ; offset += 6 ; length -= 6 ; if ( ! pbody -> cf_present ) { pbody -> cf = cf ; pbody -> cf_present = 1 ; } break ; case E_TIM : memcpy ( & tim , p + offset , 2 ) ; offset += 2 ; length -= 2 ; if ( tim . length <= 3 ) { offset += tim . length ; length -= tim . length ; break ; } if ( tim . length - 3 > ( int ) sizeof tim . bitmap ) return 0 ; memcpy ( & tim . count , p + offset , 3 ) ; offset += 3 ; length -= 3 ; <S2SV_StartBug> memcpy ( tim . bitmap , p + offset + 3 , tim . length - 3 ) ; <S2SV_EndBug> offset += tim . length - 3 ; length -= tim . length - 3 ; if ( ! pbody -> tim_present ) { pbody -> tim = tim ; pbody -> tim_present = 1 ; } break ; default : # if 0 ND_PRINT ( ( ndo , "(1)<S2SV_blank>unhandled<S2SV_blank>element_id<S2SV_blank>(%d)<S2SV_blank><S2SV_blank>" , * ( p + offset ) ) ) ; # endif offset += 2 + elementlen ; length -= 2 + elementlen ; break ; } } return 1 ; }
static void mark_context_stack ( mrb_state * mrb , struct mrb_context * c ) { size_t i ; <S2SV_StartBug> size_t e ; <S2SV_EndBug> if ( c -> stack == NULL ) return ; e = c -> stack - c -> stbase ; if ( c -> ci ) e += c -> ci -> nregs ; if ( c -> stbase + e > c -> stend ) e = c -> stend - c -> stbase ; for ( i = 0 ; i < e ; i ++ ) { mrb_value v = c -> stbase [ i ] ; if ( ! mrb_immediate_p ( v ) ) { <S2SV_StartBug> if ( mrb_basic_ptr ( v ) -> tt == MRB_TT_FREE ) { <S2SV_EndBug> c -> stbase [ i ] = mrb_nil_value ( ) ; } else { mrb_gc_mark ( mrb , mrb_basic_ptr ( v ) ) ; } } <S2SV_StartBug> } <S2SV_EndBug> }
gboolean cib_notify_client ( gpointer key , gpointer value , gpointer user_data ) { const char * type = NULL ; gboolean do_send = FALSE ; cib_client_t * client = value ; xmlNode * update_msg = user_data ; CRM_CHECK ( client != NULL , return TRUE ) ; CRM_CHECK ( update_msg != NULL , return TRUE ) ; <S2SV_StartBug> if ( client -> ipc == NULL ) { <S2SV_EndBug> crm_warn ( "Skipping<S2SV_blank>client<S2SV_blank>with<S2SV_blank>NULL<S2SV_blank>channel" ) ; return FALSE ; } type = crm_element_value ( update_msg , F_SUBTYPE ) ; CRM_LOG_ASSERT ( type != NULL ) ; if ( client -> diffs && safe_str_eq ( type , T_CIB_DIFF_NOTIFY ) ) { do_send = TRUE ; } else if ( client -> replace && safe_str_eq ( type , T_CIB_REPLACE_NOTIFY ) ) { do_send = TRUE ; } else if ( client -> confirmations && safe_str_eq ( type , T_CIB_UPDATE_CONFIRM ) ) { do_send = TRUE ; } else if ( client -> pre_notify && safe_str_eq ( type , T_CIB_PRE_NOTIFY ) ) { do_send = TRUE ; } else if ( client -> post_notify && safe_str_eq ( type , T_CIB_POST_NOTIFY ) ) { do_send = TRUE ; } if ( do_send ) { if ( client -> ipc ) { if ( crm_ipcs_send ( client -> ipc , 0 , update_msg , TRUE ) == FALSE ) { crm_warn ( "Notification<S2SV_blank>of<S2SV_blank>client<S2SV_blank>%s/%s<S2SV_blank>failed" , client -> name , client -> id ) ; } # ifdef HAVE_GNUTLS_GNUTLS_H } else if ( client -> session ) { crm_debug ( "Sent<S2SV_blank>%s<S2SV_blank>notification<S2SV_blank>to<S2SV_blank>client<S2SV_blank>%s/%s" , type , client -> name , client -> id ) ; crm_send_remote_msg ( client -> session , update_msg , client -> encrypted ) ; # endif } else { crm_err ( "Unknown<S2SV_blank>transport<S2SV_blank>for<S2SV_blank>%s" , client -> name ) ; } } return FALSE ; }
ssize_t tcp_splice_read ( struct socket * sock , loff_t * ppos , struct pipe_inode_info * pipe , size_t len , unsigned int flags ) { struct sock * sk = sock -> sk ; struct tcp_splice_state tss = { . pipe = pipe , . len = len , . flags = flags , } ; long timeo ; ssize_t spliced ; int ret ; sock_rps_record_flow ( sk ) ; if ( unlikely ( * ppos ) ) return - ESPIPE ; ret = spliced = 0 ; lock_sock ( sk ) ; timeo = sock_rcvtimeo ( sk , sock -> file -> f_flags & O_NONBLOCK ) ; while ( tss . len ) { ret = __tcp_splice_read ( sk , & tss ) ; if ( ret < 0 ) break ; else if ( ! ret ) { if ( spliced ) break ; if ( sock_flag ( sk , SOCK_DONE ) ) break ; if ( sk -> sk_err ) { ret = sock_error ( sk ) ; break ; } if ( sk -> sk_shutdown & RCV_SHUTDOWN ) break ; if ( sk -> sk_state == TCP_CLOSE ) { if ( ! sock_flag ( sk , SOCK_DONE ) ) ret = - ENOTCONN ; break ; } if ( ! timeo ) { ret = - EAGAIN ; break ; } <S2SV_StartBug> sk_wait_data ( sk , & timeo , NULL ) ; <S2SV_EndBug> if ( signal_pending ( current ) ) { ret = sock_intr_errno ( timeo ) ; break ; } continue ; } tss . len -= ret ; spliced += ret ; if ( ! timeo ) break ; release_sock ( sk ) ; lock_sock ( sk ) ; if ( sk -> sk_err || sk -> sk_state == TCP_CLOSE || ( sk -> sk_shutdown & RCV_SHUTDOWN ) || signal_pending ( current ) ) break ; } release_sock ( sk ) ; if ( spliced ) return spliced ; return ret ; }
apr_status_t ap_http_filter ( ap_filter_t * f , apr_bucket_brigade * b , ap_input_mode_t mode , apr_read_type_e block , apr_off_t readbytes ) { core_server_config * conf ; apr_bucket * e ; http_ctx_t * ctx = f -> ctx ; apr_status_t rv ; apr_off_t totalread ; int again ; conf = ( core_server_config * ) ap_get_module_config ( f -> r -> server -> module_config , & core_module ) ; if ( mode != AP_MODE_READBYTES && mode != AP_MODE_GETLINE ) { return ap_get_brigade ( f -> next , b , mode , block , readbytes ) ; } if ( ! ctx ) { const char * tenc , * lenp ; f -> ctx = ctx = apr_pcalloc ( f -> r -> pool , sizeof ( * ctx ) ) ; ctx -> state = BODY_NONE ; if ( ! f -> r -> proxyreq ) { ctx -> limit = ap_get_limit_req_body ( f -> r ) ; } else { ctx -> limit = 0 ; } tenc = apr_table_get ( f -> r -> headers_in , "Transfer-Encoding" ) ; lenp = apr_table_get ( f -> r -> headers_in , "Content-Length" ) ; if ( tenc ) { if ( strcasecmp ( tenc , "chunked" ) == 0 || ap_find_last_token ( f -> r -> pool , tenc , "chunked" ) ) { ctx -> state = BODY_CHUNK ; } else if ( f -> r -> proxyreq == PROXYREQ_RESPONSE ) { ap_log_rerror ( APLOG_MARK , APLOG_INFO , 0 , f -> r , APLOGNO ( 02555 ) <S2SV_StartBug> "Unknown<S2SV_blank>Transfer-Encoding:<S2SV_blank>%s;" <S2SV_EndBug> "<S2SV_blank>using<S2SV_blank>read-until-close" , tenc ) ; tenc = NULL ; } else { ap_log_rerror ( APLOG_MARK , APLOG_INFO , 0 , f -> r , APLOGNO ( 01585 ) "Unknown<S2SV_blank>Transfer-Encoding:<S2SV_blank>%s" , tenc ) ; return APR_EGENERAL ; } lenp = NULL ; } if ( lenp ) { char * endstr ; ctx -> state = BODY_LENGTH ; if ( apr_strtoff ( & ctx -> remaining , lenp , & endstr , 10 ) || endstr == lenp || * endstr || ctx -> remaining < 0 ) { ctx -> remaining = 0 ; ap_log_rerror ( APLOG_MARK , APLOG_INFO , 0 , f -> r , APLOGNO ( 01587 ) "Invalid<S2SV_blank>Content-Length" ) ; <S2SV_StartBug> return APR_ENOSPC ; <S2SV_EndBug> } if ( ctx -> limit && ctx -> limit < ctx -> remaining ) { ap_log_rerror ( APLOG_MARK , APLOG_INFO , 0 , f -> r , APLOGNO ( 01588 ) "Requested<S2SV_blank>content-length<S2SV_blank>of<S2SV_blank>%" APR_OFF_T_FMT "<S2SV_blank>is<S2SV_blank>larger<S2SV_blank>than<S2SV_blank>the<S2SV_blank>configured<S2SV_blank>limit" "<S2SV_blank>of<S2SV_blank>%" APR_OFF_T_FMT , ctx -> remaining , ctx -> limit ) ; return APR_ENOSPC ; } } if ( ctx -> state == BODY_NONE && f -> r -> proxyreq != PROXYREQ_RESPONSE ) { e = apr_bucket_eos_create ( f -> c -> bucket_alloc ) ; APR_BRIGADE_INSERT_TAIL ( b , e ) ; ctx -> eos_sent = 1 ; return APR_SUCCESS ; } if ( ( ctx -> state == BODY_CHUNK || ( ctx -> state == BODY_LENGTH && ctx -> remaining > 0 ) ) && f -> r -> expecting_100 && f -> r -> proto_num >= HTTP_VERSION ( 1 , 1 ) && ! ( f -> r -> eos_sent || f -> r -> bytes_sent ) ) { if ( ! ap_is_HTTP_SUCCESS ( f -> r -> status ) ) { ctx -> state = BODY_NONE ; ctx -> eos_sent = 1 ; } else { char * tmp ; int len ; apr_bucket_brigade * bb ; bb = apr_brigade_create ( f -> r -> pool , f -> c -> bucket_alloc ) ; f -> r -> expecting_100 = 0 ; tmp = apr_pstrcat ( f -> r -> pool , AP_SERVER_PROTOCOL "<S2SV_blank>" , ap_get_status_line ( HTTP_CONTINUE ) , CRLF CRLF , NULL ) ; len = strlen ( tmp ) ; ap_xlate_proto_to_ascii ( tmp , len ) ; e = apr_bucket_pool_create ( tmp , len , f -> r -> pool , f -> c -> bucket_alloc ) ; APR_BRIGADE_INSERT_HEAD ( bb , e ) ; e = apr_bucket_flush_create ( f -> c -> bucket_alloc ) ; APR_BRIGADE_INSERT_TAIL ( bb , e ) ; rv = ap_pass_brigade ( f -> c -> output_filters , bb ) ; <S2SV_StartBug> if ( rv != APR_SUCCESS ) { <S2SV_EndBug> return AP_FILTER_ERROR ; } } } } if ( ctx -> eos_sent ) { e = apr_bucket_eos_create ( f -> c -> bucket_alloc ) ; APR_BRIGADE_INSERT_TAIL ( b , e ) ; return APR_SUCCESS ; } do { apr_brigade_cleanup ( b ) ; again = 0 ; switch ( ctx -> state ) { case BODY_CHUNK : case BODY_CHUNK_PART : case BODY_CHUNK_EXT : <S2SV_StartBug> case BODY_CHUNK_END : { <S2SV_EndBug> rv = ap_get_brigade ( f -> next , b , AP_MODE_GETLINE , block , 0 ) ; if ( block == APR_NONBLOCK_READ && ( ( rv == APR_SUCCESS && APR_BRIGADE_EMPTY ( b ) ) || ( APR_STATUS_IS_EAGAIN ( rv ) ) ) ) { return APR_EAGAIN ; } if ( rv == APR_EOF ) { return APR_INCOMPLETE ; } if ( rv != APR_SUCCESS ) { return rv ; } e = APR_BRIGADE_FIRST ( b ) ; while ( e != APR_BRIGADE_SENTINEL ( b ) ) { const char * buffer ; apr_size_t len ; if ( ! APR_BUCKET_IS_METADATA ( e ) ) { rv = apr_bucket_read ( e , & buffer , & len , APR_BLOCK_READ ) ; if ( rv == APR_SUCCESS ) { rv = parse_chunk_size ( ctx , buffer , len , f -> r -> server -> limit_req_fieldsize ) ; } if ( rv != APR_SUCCESS ) { ap_log_rerror ( APLOG_MARK , APLOG_INFO , rv , f -> r , APLOGNO ( 01590 ) "Error<S2SV_blank>reading<S2SV_blank>chunk<S2SV_blank>%s<S2SV_blank>" , ( APR_ENOSPC == rv ) ? "(overflow)" : "" ) ; return rv ; } } apr_bucket_delete ( e ) ; e = APR_BRIGADE_FIRST ( b ) ; } again = 1 ; if ( ctx -> state == BODY_CHUNK_TRAILER ) { <S2SV_StartBug> int merge_trailers = <S2SV_EndBug> conf -> merge_trailers == AP_MERGE_TRAILERS_ENABLE ; return read_chunked_trailers ( ctx , f , b , merge_trailers ) ; } break ; } case BODY_NONE : case BODY_LENGTH : case BODY_CHUNK_DATA : { if ( ctx -> state != BODY_NONE && ctx -> remaining < readbytes ) { readbytes = ctx -> remaining ; } if ( readbytes > 0 ) { rv = ap_get_brigade ( f -> next , b , mode , block , readbytes ) ; if ( block == APR_NONBLOCK_READ && ( ( rv == APR_SUCCESS && APR_BRIGADE_EMPTY ( b ) ) || ( APR_STATUS_IS_EAGAIN ( rv ) ) ) ) { return APR_EAGAIN ; } if ( rv == APR_EOF && ctx -> state != BODY_NONE && ctx -> remaining > 0 ) { return APR_INCOMPLETE ; } if ( rv != APR_SUCCESS ) { return rv ; } apr_brigade_length ( b , 0 , & totalread ) ; AP_DEBUG_ASSERT ( totalread >= 0 ) ; if ( ctx -> state != BODY_NONE ) { ctx -> remaining -= totalread ; if ( ctx -> remaining > 0 ) { e = APR_BRIGADE_LAST ( b ) ; if ( APR_BUCKET_IS_EOS ( e ) ) { apr_bucket_delete ( e ) ; return APR_INCOMPLETE ; } } else if ( ctx -> state == BODY_CHUNK_DATA ) { ctx -> state = BODY_CHUNK_END ; ctx -> chunk_used = 0 ; } } } if ( ctx -> state == BODY_LENGTH && ctx -> remaining == 0 ) { e = apr_bucket_eos_create ( f -> c -> bucket_alloc ) ; APR_BRIGADE_INSERT_TAIL ( b , e ) ; ctx -> eos_sent = 1 ; } if ( ctx -> limit ) { ctx -> limit_used += totalread ; if ( ctx -> limit < ctx -> limit_used ) { ap_log_rerror ( APLOG_MARK , APLOG_INFO , 0 , f -> r , APLOGNO ( 01591 ) "Read<S2SV_blank>content-length<S2SV_blank>of<S2SV_blank>%" APR_OFF_T_FMT "<S2SV_blank>is<S2SV_blank>larger<S2SV_blank>than<S2SV_blank>the<S2SV_blank>configured<S2SV_blank>limit" "<S2SV_blank>of<S2SV_blank>%" APR_OFF_T_FMT , ctx -> limit_used , ctx -> limit ) ; return APR_ENOSPC ; } } break ; } case BODY_CHUNK_TRAILER : { rv = ap_get_brigade ( f -> next , b , mode , block , readbytes ) ; if ( block == APR_NONBLOCK_READ && ( ( rv == APR_SUCCESS && APR_BRIGADE_EMPTY ( b ) ) || ( APR_STATUS_IS_EAGAIN ( rv ) ) ) ) { return APR_EAGAIN ; } if ( rv != APR_SUCCESS ) { return rv ; } break ; } default : { <S2SV_StartBug> break ; <S2SV_EndBug> } } } while ( again ) ; return APR_SUCCESS ; }
static int wb_id ( netdissect_options * ndo , const struct pkt_id * id , u_int len ) { int i ; const char * cp ; const struct id_off * io ; char c ; int nid ; ND_PRINT ( ( ndo , "<S2SV_blank>wb-id:" ) ) ; if ( len < sizeof ( * id ) || ! ND_TTEST ( * id ) ) return ( - 1 ) ; len -= sizeof ( * id ) ; ND_PRINT ( ( ndo , "<S2SV_blank>%u/%s:%u<S2SV_blank>(max<S2SV_blank>%u/%s:%u)<S2SV_blank>" , EXTRACT_32BITS ( & id -> pi_ps . slot ) , ipaddr_string ( ndo , & id -> pi_ps . page . p_sid ) , EXTRACT_32BITS ( & id -> pi_ps . page . p_uid ) , EXTRACT_32BITS ( & id -> pi_mslot ) , ipaddr_string ( ndo , & id -> pi_mpage . p_sid ) , EXTRACT_32BITS ( & id -> pi_mpage . p_uid ) ) ) ; nid = EXTRACT_16BITS ( & id -> pi_ps . nid ) ; len -= sizeof ( * io ) * nid ; io = ( struct id_off * ) ( id + 1 ) ; cp = ( char * ) ( io + nid ) ; <S2SV_StartBug> if ( ! ND_TTEST2 ( cp , len ) ) { <S2SV_EndBug> ND_PRINT ( ( ndo , "\\"" ) ) ; fn_print ( ndo , ( u_char * ) cp , ( u_char * ) cp + len ) ; ND_PRINT ( ( ndo , "\\"" ) ) ; } c = '<' ; for ( i = 0 ; i < nid && ND_TTEST ( * io ) ; ++ io , ++ i ) { ND_PRINT ( ( ndo , "%c%s:%u" , c , ipaddr_string ( ndo , & io -> id ) , EXTRACT_32BITS ( & io -> off ) ) ) ; c = ',' ; } if ( i >= nid ) { ND_PRINT ( ( ndo , ">" ) ) ; return ( 0 ) ; } return ( - 1 ) ; }
int udpv6_sendmsg ( struct sock * sk , struct msghdr * msg , size_t len ) { struct ipv6_txoptions opt_space ; struct udp_sock * up = udp_sk ( sk ) ; struct inet_sock * inet = inet_sk ( sk ) ; struct ipv6_pinfo * np = inet6_sk ( sk ) ; DECLARE_SOCKADDR ( struct sockaddr_in6 * , sin6 , msg -> msg_name ) ; struct in6_addr * daddr , * final_p , final ; <S2SV_StartBug> struct ipv6_txoptions * opt = NULL ; <S2SV_EndBug> struct ip6_flowlabel * flowlabel = NULL ; struct flowi6 fl6 ; struct dst_entry * dst ; int addr_len = msg -> msg_namelen ; int ulen = len ; int hlimit = - 1 ; int tclass = - 1 ; int dontfrag = - 1 ; int corkreq = up -> corkflag || msg -> msg_flags & MSG_MORE ; int err ; int connected = 0 ; int is_udplite = IS_UDPLITE ( sk ) ; int ( * getfrag ) ( void * , char * , int , int , int , struct sk_buff * ) ; if ( sin6 ) { if ( addr_len < offsetof ( struct sockaddr , sa_data ) ) return - EINVAL ; switch ( sin6 -> sin6_family ) { case AF_INET6 : if ( addr_len < SIN6_LEN_RFC2133 ) return - EINVAL ; daddr = & sin6 -> sin6_addr ; break ; case AF_INET : goto do_udp_sendmsg ; case AF_UNSPEC : msg -> msg_name = sin6 = NULL ; msg -> msg_namelen = addr_len = 0 ; daddr = NULL ; break ; default : return - EINVAL ; } } else if ( ! up -> pending ) { if ( sk -> sk_state != TCP_ESTABLISHED ) return - EDESTADDRREQ ; daddr = & sk -> sk_v6_daddr ; } else daddr = NULL ; if ( daddr ) { if ( ipv6_addr_v4mapped ( daddr ) ) { struct sockaddr_in sin ; sin . sin_family = AF_INET ; sin . sin_port = sin6 ? sin6 -> sin6_port : inet -> inet_dport ; sin . sin_addr . s_addr = daddr -> s6_addr32 [ 3 ] ; msg -> msg_name = & sin ; msg -> msg_namelen = sizeof ( sin ) ; do_udp_sendmsg : if ( __ipv6_only_sock ( sk ) ) return - ENETUNREACH ; return udp_sendmsg ( sk , msg , len ) ; } } if ( up -> pending == AF_INET ) return udp_sendmsg ( sk , msg , len ) ; if ( len > INT_MAX - sizeof ( struct udphdr ) ) return - EMSGSIZE ; getfrag = is_udplite ? udplite_getfrag : ip_generic_getfrag ; if ( up -> pending ) { lock_sock ( sk ) ; if ( likely ( up -> pending ) ) { if ( unlikely ( up -> pending != AF_INET6 ) ) { release_sock ( sk ) ; return - EAFNOSUPPORT ; } dst = NULL ; goto do_append_data ; } release_sock ( sk ) ; } ulen += sizeof ( struct udphdr ) ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; if ( sin6 ) { if ( sin6 -> sin6_port == 0 ) return - EINVAL ; fl6 . fl6_dport = sin6 -> sin6_port ; daddr = & sin6 -> sin6_addr ; if ( np -> sndflow ) { fl6 . flowlabel = sin6 -> sin6_flowinfo & IPV6_FLOWINFO_MASK ; if ( fl6 . flowlabel & IPV6_FLOWLABEL_MASK ) { flowlabel = fl6_sock_lookup ( sk , fl6 . flowlabel ) ; if ( ! flowlabel ) return - EINVAL ; } } if ( sk -> sk_state == TCP_ESTABLISHED && ipv6_addr_equal ( daddr , & sk -> sk_v6_daddr ) ) daddr = & sk -> sk_v6_daddr ; if ( addr_len >= sizeof ( struct sockaddr_in6 ) && sin6 -> sin6_scope_id && __ipv6_addr_needs_scope_id ( __ipv6_addr_type ( daddr ) ) ) fl6 . flowi6_oif = sin6 -> sin6_scope_id ; } else { if ( sk -> sk_state != TCP_ESTABLISHED ) return - EDESTADDRREQ ; fl6 . fl6_dport = inet -> inet_dport ; daddr = & sk -> sk_v6_daddr ; fl6 . flowlabel = np -> flow_label ; connected = 1 ; } if ( ! fl6 . flowi6_oif ) fl6 . flowi6_oif = sk -> sk_bound_dev_if ; if ( ! fl6 . flowi6_oif ) fl6 . flowi6_oif = np -> sticky_pktinfo . ipi6_ifindex ; fl6 . flowi6_mark = sk -> sk_mark ; if ( msg -> msg_controllen ) { opt = & opt_space ; memset ( opt , 0 , sizeof ( struct ipv6_txoptions ) ) ; opt -> tot_len = sizeof ( * opt ) ; err = ip6_datagram_send_ctl ( sock_net ( sk ) , sk , msg , & fl6 , opt , & hlimit , & tclass , & dontfrag ) ; if ( err < 0 ) { fl6_sock_release ( flowlabel ) ; return err ; } if ( ( fl6 . flowlabel & IPV6_FLOWLABEL_MASK ) && ! flowlabel ) { flowlabel = fl6_sock_lookup ( sk , fl6 . flowlabel ) ; if ( ! flowlabel ) return - EINVAL ; } if ( ! ( opt -> opt_nflen | opt -> opt_flen ) ) opt = NULL ; connected = 0 ; } <S2SV_StartBug> if ( ! opt ) <S2SV_EndBug> opt = np -> opt ; if ( flowlabel ) opt = fl6_merge_options ( & opt_space , flowlabel , opt ) ; opt = ipv6_fixup_options ( & opt_space , opt ) ; fl6 . flowi6_proto = sk -> sk_protocol ; if ( ! ipv6_addr_any ( daddr ) ) fl6 . daddr = * daddr ; else fl6 . daddr . s6_addr [ 15 ] = 0x1 ; if ( ipv6_addr_any ( & fl6 . saddr ) && ! ipv6_addr_any ( & np -> saddr ) ) fl6 . saddr = np -> saddr ; fl6 . fl6_sport = inet -> inet_sport ; final_p = fl6_update_dst ( & fl6 , opt , & final ) ; if ( final_p ) connected = 0 ; if ( ! fl6 . flowi6_oif && ipv6_addr_is_multicast ( & fl6 . daddr ) ) { fl6 . flowi6_oif = np -> mcast_oif ; connected = 0 ; } else if ( ! fl6 . flowi6_oif ) fl6 . flowi6_oif = np -> ucast_oif ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; dst = ip6_sk_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { err = PTR_ERR ( dst ) ; dst = NULL ; goto out ; } if ( hlimit < 0 ) hlimit = ip6_sk_dst_hoplimit ( np , & fl6 , dst ) ; if ( tclass < 0 ) tclass = np -> tclass ; if ( msg -> msg_flags & MSG_CONFIRM ) goto do_confirm ; back_from_confirm : if ( ! corkreq ) { struct sk_buff * skb ; skb = ip6_make_skb ( sk , getfrag , msg , ulen , sizeof ( struct udphdr ) , hlimit , tclass , opt , & fl6 , ( struct rt6_info * ) dst , msg -> msg_flags , dontfrag ) ; err = PTR_ERR ( skb ) ; if ( ! IS_ERR_OR_NULL ( skb ) ) err = udp_v6_send_skb ( skb , & fl6 ) ; goto release_dst ; } lock_sock ( sk ) ; if ( unlikely ( up -> pending ) ) { release_sock ( sk ) ; net_dbg_ratelimited ( "udp<S2SV_blank>cork<S2SV_blank>app<S2SV_blank>bug<S2SV_blank>2\\n" ) ; err = - EINVAL ; goto out ; } up -> pending = AF_INET6 ; do_append_data : if ( dontfrag < 0 ) dontfrag = np -> dontfrag ; up -> len += ulen ; err = ip6_append_data ( sk , getfrag , msg , ulen , sizeof ( struct udphdr ) , hlimit , tclass , opt , & fl6 , ( struct rt6_info * ) dst , corkreq ? msg -> msg_flags | MSG_MORE : msg -> msg_flags , dontfrag ) ; if ( err ) udp_v6_flush_pending_frames ( sk ) ; else if ( ! corkreq ) err = udp_v6_push_pending_frames ( sk ) ; else if ( unlikely ( skb_queue_empty ( & sk -> sk_write_queue ) ) ) up -> pending = 0 ; if ( err > 0 ) err = np -> recverr ? net_xmit_errno ( err ) : 0 ; release_sock ( sk ) ; release_dst : if ( dst ) { if ( connected ) { ip6_dst_store ( sk , dst , ipv6_addr_equal ( & fl6 . daddr , & sk -> sk_v6_daddr ) ? & sk -> sk_v6_daddr : NULL , # ifdef CONFIG_IPV6_SUBTREES ipv6_addr_equal ( & fl6 . saddr , & np -> saddr ) ? & np -> saddr : # endif NULL ) ; } else { dst_release ( dst ) ; } dst = NULL ; } out : dst_release ( dst ) ; <S2SV_StartBug> fl6_sock_release ( flowlabel ) ; <S2SV_EndBug> if ( ! err ) return len ; if ( err == - ENOBUFS || test_bit ( SOCK_NOSPACE , & sk -> sk_socket -> flags ) ) { UDP6_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_SNDBUFERRORS , is_udplite ) ; } return err ; do_confirm : dst_confirm ( dst ) ; if ( ! ( msg -> msg_flags & MSG_PROBE ) || len ) goto back_from_confirm ; err = 0 ; goto out ; }
int ocfs2_set_acl ( handle_t * handle , struct inode * inode , struct buffer_head * di_bh , int type , struct posix_acl * acl , struct ocfs2_alloc_context * meta_ac , struct ocfs2_alloc_context * data_ac ) { int name_index ; void * value = NULL ; size_t size = 0 ; int ret ; if ( S_ISLNK ( inode -> i_mode ) ) return - EOPNOTSUPP ; switch ( type ) { case ACL_TYPE_ACCESS : name_index = OCFS2_XATTR_INDEX_POSIX_ACL_ACCESS ; if ( acl ) { <S2SV_StartBug> umode_t mode = inode -> i_mode ; <S2SV_EndBug> <S2SV_StartBug> ret = posix_acl_equiv_mode ( acl , & mode ) ; <S2SV_EndBug> if ( ret < 0 ) return ret ; if ( ret == 0 ) acl = NULL ; ret = ocfs2_acl_set_mode ( inode , di_bh , handle , mode ) ; if ( ret ) return ret ; } break ; case ACL_TYPE_DEFAULT : name_index = OCFS2_XATTR_INDEX_POSIX_ACL_DEFAULT ; if ( ! S_ISDIR ( inode -> i_mode ) ) return acl ? - EACCES : 0 ; break ; default : return - EINVAL ; } if ( acl ) { value = ocfs2_acl_to_xattr ( acl , & size ) ; if ( IS_ERR ( value ) ) return ( int ) PTR_ERR ( value ) ; } if ( handle ) ret = ocfs2_xattr_set_handle ( handle , inode , di_bh , name_index , "" , value , size , 0 , meta_ac , data_ac ) ; else ret = ocfs2_xattr_set ( inode , name_index , "" , value , size , 0 ) ; kfree ( value ) ; return ret ; }
l_ok pixFillMapHoles ( PIX * pix , l_int32 nx , l_int32 ny , l_int32 filltype ) { l_int32 w , h , y , nmiss , goodcol , i , j , found , ival , valtest ; l_uint32 val , lastval ; <S2SV_StartBug> NUMA * na ; <S2SV_EndBug> PIX * pixt ; PROCNAME ( "pixFillMapHoles" ) ; if ( ! pix || pixGetDepth ( pix ) != 8 ) return ERROR_INT ( "pix<S2SV_blank>not<S2SV_blank>defined<S2SV_blank>or<S2SV_blank>not<S2SV_blank>8<S2SV_blank>bpp" , procName , 1 ) ; if ( pixGetColormap ( pix ) ) return ERROR_INT ( "pix<S2SV_blank>is<S2SV_blank>colormapped" , procName , 1 ) ; pixGetDimensions ( pix , & w , & h , NULL ) ; na = numaCreate ( 0 ) ; nmiss = 0 ; valtest = ( filltype == L_FILL_WHITE ) ? 255 : 0 ; for ( j = 0 ; j < nx ; j ++ ) { found = FALSE ; for ( i = 0 ; i < ny ; i ++ ) { pixGetPixel ( pix , j , i , & val ) ; if ( val != valtest ) { y = i ; found = TRUE ; break ; } } if ( found == FALSE ) { numaAddNumber ( na , 0 ) ; nmiss ++ ; } else { numaAddNumber ( na , 1 ) ; for ( i = y - 1 ; i >= 0 ; i -- ) pixSetPixel ( pix , j , i , val ) ; pixGetPixel ( pix , j , 0 , & lastval ) ; for ( i = 1 ; i < h ; i ++ ) { pixGetPixel ( pix , j , i , & val ) ; if ( val == valtest ) pixSetPixel ( pix , j , i , lastval ) ; else lastval = val ; } } } numaAddNumber ( na , 0 ) ; if ( nmiss == nx ) { numaDestroy ( & na ) ; L_WARNING ( "no<S2SV_blank>bg<S2SV_blank>found;<S2SV_blank>no<S2SV_blank>data<S2SV_blank>in<S2SV_blank>any<S2SV_blank>column\\n" , procName ) ; return 1 ; } if ( nmiss > 0 ) { <S2SV_StartBug> pixt = pixCopy ( NULL , pix ) ; <S2SV_EndBug> goodcol = 0 ; for ( j = 0 ; j < w ; j ++ ) { numaGetIValue ( na , j , & ival ) ; if ( ival == 1 ) { goodcol = j ; break ; } } if ( goodcol > 0 ) { <S2SV_StartBug> for ( j = goodcol - 1 ; j >= 0 ; j -- ) { <S2SV_EndBug> <S2SV_StartBug> pixRasterop ( pix , j , 0 , 1 , h , PIX_SRC , pixt , j + 1 , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> pixRasterop ( pixt , j , 0 , 1 , h , PIX_SRC , pix , j , 0 ) ; <S2SV_EndBug> } } for ( j = goodcol + 1 ; j < w ; j ++ ) { numaGetIValue ( na , j , & ival ) ; if ( ival == 0 ) { <S2SV_StartBug> pixRasterop ( pix , j , 0 , 1 , h , PIX_SRC , pixt , j - 1 , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> pixRasterop ( pixt , j , 0 , 1 , h , PIX_SRC , pix , j , 0 ) ; <S2SV_EndBug> } } pixDestroy ( & pixt ) ; } if ( w > nx ) { for ( i = 0 ; i < h ; i ++ ) { pixGetPixel ( pix , w - 2 , i , & val ) ; pixSetPixel ( pix , w - 1 , i , val ) ; } } numaDestroy ( & na ) ; return 0 ; }
static void fwnet_receive_broadcast ( struct fw_iso_context * context , u32 cycle , size_t header_length , void * header , void * data ) { struct fwnet_device * dev ; struct fw_iso_packet packet ; __be16 * hdr_ptr ; __be32 * buf_ptr ; int retval ; u32 length ; <S2SV_StartBug> u16 source_node_id ; <S2SV_EndBug> u32 specifier_id ; u32 ver ; unsigned long offset ; unsigned long flags ; dev = data ; hdr_ptr = header ; length = be16_to_cpup ( hdr_ptr ) ; spin_lock_irqsave ( & dev -> lock , flags ) ; offset = dev -> rcv_buffer_size * dev -> broadcast_rcv_next_ptr ; buf_ptr = dev -> broadcast_rcv_buffer_ptrs [ dev -> broadcast_rcv_next_ptr ++ ] ; if ( dev -> broadcast_rcv_next_ptr == dev -> num_broadcast_rcv_ptrs ) dev -> broadcast_rcv_next_ptr = 0 ; spin_unlock_irqrestore ( & dev -> lock , flags ) ; <S2SV_StartBug> specifier_id = ( be32_to_cpu ( buf_ptr [ 0 ] ) & 0xffff ) << 8 <S2SV_EndBug> | ( be32_to_cpu ( buf_ptr [ 1 ] ) & 0xff000000 ) >> 24 ; ver = be32_to_cpu ( buf_ptr [ 1 ] ) & 0xffffff ; source_node_id = be32_to_cpu ( buf_ptr [ 0 ] ) >> 16 ; if ( specifier_id == IANA_SPECIFIER_ID && <S2SV_StartBug> ( ver == RFC2734_SW_VERSION <S2SV_EndBug> # if IS_ENABLED ( CONFIG_IPV6 ) <S2SV_StartBug> || ver == RFC3146_SW_VERSION <S2SV_EndBug> # endif <S2SV_StartBug> ) ) { <S2SV_EndBug> buf_ptr += 2 ; length -= IEEE1394_GASP_HDR_SIZE ; fwnet_incoming_packet ( dev , buf_ptr , length , source_node_id , context -> card -> generation , true ) ; <S2SV_StartBug> } <S2SV_EndBug> packet . payload_length = dev -> rcv_buffer_size ; packet . interrupt = 1 ; packet . skip = 0 ; packet . tag = 3 ; packet . sy = 0 ; packet . header_length = IEEE1394_GASP_HDR_SIZE ; spin_lock_irqsave ( & dev -> lock , flags ) ; retval = fw_iso_context_queue ( dev -> broadcast_rcv_context , & packet , & dev -> broadcast_rcv_buffer , offset ) ; spin_unlock_irqrestore ( & dev -> lock , flags ) ; if ( retval >= 0 ) fw_iso_context_queue_flush ( dev -> broadcast_rcv_context ) ; else dev_err ( & dev -> netdev -> dev , "requeue<S2SV_blank>failed\\n" ) ; }
int ping_recvmsg ( struct kiocb * iocb , struct sock * sk , struct msghdr * msg , size_t len , int noblock , int flags , int * addr_len ) { struct inet_sock * isk = inet_sk ( sk ) ; int family = sk -> sk_family ; struct sk_buff * skb ; int copied , err ; pr_debug ( "ping_recvmsg(sk=%p,sk->num=%u)\\n" , isk , isk -> inet_num ) ; err = - EOPNOTSUPP ; if ( flags & MSG_OOB ) goto out ; if ( flags & MSG_ERRQUEUE ) { if ( family == AF_INET ) { return ip_recv_error ( sk , msg , len ) ; # if IS_ENABLED ( CONFIG_IPV6 ) } else if ( family == AF_INET6 ) { return pingv6_ops . ipv6_recv_error ( sk , msg , len ) ; # endif } } skb = skb_recv_datagram ( sk , flags , noblock , & err ) ; if ( ! skb ) goto out ; copied = skb -> len ; if ( copied > len ) { msg -> msg_flags |= MSG_TRUNC ; copied = len ; } err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; if ( err ) goto done ; sock_recv_timestamp ( msg , sk , skb ) ; if ( family == AF_INET ) { struct sockaddr_in * sin = ( struct sockaddr_in * ) msg -> msg_name ; <S2SV_StartBug> sin -> sin_family = AF_INET ; <S2SV_EndBug> sin -> sin_port = 0 ; sin -> sin_addr . s_addr = ip_hdr ( skb ) -> saddr ; memset ( sin -> sin_zero , 0 , sizeof ( sin -> sin_zero ) ) ; * addr_len = sizeof ( * sin ) ; <S2SV_StartBug> if ( isk -> cmsg_flags ) <S2SV_EndBug> ip_cmsg_recv ( msg , skb ) ; # if IS_ENABLED ( CONFIG_IPV6 ) } else if ( family == AF_INET6 ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct ipv6hdr * ip6 = ipv6_hdr ( skb ) ; struct sockaddr_in6 * sin6 = ( struct sockaddr_in6 * ) msg -> msg_name ; <S2SV_StartBug> sin6 -> sin6_family = AF_INET6 ; <S2SV_EndBug> sin6 -> sin6_port = 0 ; sin6 -> sin6_addr = ip6 -> saddr ; sin6 -> sin6_flowinfo = 0 ; if ( np -> sndflow ) sin6 -> sin6_flowinfo = ip6_flowinfo ( ip6 ) ; sin6 -> sin6_scope_id = ipv6_iface_scope_id ( & sin6 -> sin6_addr , IP6CB ( skb ) -> iif ) ; <S2SV_StartBug> * addr_len = sizeof ( * sin6 ) ; <S2SV_EndBug> if ( inet6_sk ( sk ) -> rxopt . all ) pingv6_ops . ip6_datagram_recv_ctl ( sk , msg , skb ) ; # endif } else { BUG ( ) ; } err = copied ; done : skb_free_datagram ( sk , skb ) ; out : pr_debug ( "ping_recvmsg<S2SV_blank>-><S2SV_blank>%d\\n" , err ) ; return err ; }
void uverbs_user_mmap_disassociate ( struct ib_uverbs_file * ufile ) { struct rdma_umap_priv * priv , * next_priv ; lockdep_assert_held ( & ufile -> hw_destroy_rwsem ) ; while ( 1 ) { struct mm_struct * mm = NULL ; mutex_lock ( & ufile -> umap_lock ) ; while ( ! list_empty ( & ufile -> umaps ) ) { int ret ; priv = list_first_entry ( & ufile -> umaps , struct rdma_umap_priv , list ) ; mm = priv -> vma -> vm_mm ; ret = mmget_not_zero ( mm ) ; if ( ! ret ) { list_del_init ( & priv -> list ) ; mm = NULL ; continue ; } break ; } mutex_unlock ( & ufile -> umap_lock ) ; if ( ! mm ) return ; <S2SV_StartBug> down_write ( & mm -> mmap_sem ) ; <S2SV_EndBug> mutex_lock ( & ufile -> umap_lock ) ; list_for_each_entry_safe ( priv , next_priv , & ufile -> umaps , list ) { struct vm_area_struct * vma = priv -> vma ; if ( vma -> vm_mm != mm ) continue ; list_del_init ( & priv -> list ) ; zap_vma_ptes ( vma , vma -> vm_start , vma -> vm_end - vma -> vm_start ) ; vma -> vm_flags &= ~ ( VM_SHARED | VM_MAYSHARE ) ; } mutex_unlock ( & ufile -> umap_lock ) ; <S2SV_StartBug> up_write ( & mm -> mmap_sem ) ; <S2SV_EndBug> mmput ( mm ) ; } }
static GstFlowReturn gst_asf_demux_process_ext_content_desc ( GstASFDemux * demux , guint8 * data , guint64 size ) { GstTagList * taglist ; guint16 blockcount , i ; gboolean content3D = FALSE ; struct { const gchar * interleave_name ; GstASF3DMode interleaving_type ; } stereoscopic_layout_map [ ] = { { "SideBySideRF" , GST_ASF_3D_SIDE_BY_SIDE_HALF_RL } , { "SideBySideLF" , GST_ASF_3D_SIDE_BY_SIDE_HALF_LR } , { "OverUnderRT" , GST_ASF_3D_TOP_AND_BOTTOM_HALF_RL } , { "OverUnderLT" , GST_ASF_3D_TOP_AND_BOTTOM_HALF_LR } , { "DualStream" , GST_ASF_3D_DUAL_STREAM } } ; GST_INFO_OBJECT ( demux , "object<S2SV_blank>is<S2SV_blank>an<S2SV_blank>extended<S2SV_blank>content<S2SV_blank>description" ) ; taglist = gst_tag_list_new_empty ( ) ; if ( size < 2 ) goto not_enough_data ; blockcount = gst_asf_demux_get_uint16 ( & data , & size ) ; for ( i = 1 ; i <= blockcount ; ++ i ) { const gchar * gst_tag_name ; guint16 datatype ; guint16 value_len ; guint16 name_len ; GValue tag_value = { 0 , } ; gsize in , out ; gchar * name ; gchar * name_utf8 = NULL ; gchar * value ; if ( ! gst_asf_demux_get_string ( & name , & name_len , & data , & size ) ) goto not_enough_data ; if ( size < 2 ) { g_free ( name ) ; goto not_enough_data ; } datatype = gst_asf_demux_get_uint16 ( & data , & size ) ; if ( ! gst_asf_demux_get_string ( & value , & value_len , & data , & size ) ) { g_free ( name ) ; goto not_enough_data ; } name_utf8 = g_convert ( name , name_len , "UTF-8" , "UTF-16LE" , & in , & out , NULL ) ; if ( name_utf8 != NULL ) { GST_DEBUG ( "Found<S2SV_blank>tag/metadata<S2SV_blank>%s" , name_utf8 ) ; gst_tag_name = gst_asf_demux_get_gst_tag_from_tag_name ( name_utf8 ) ; GST_DEBUG ( "gst_tag_name<S2SV_blank>%s" , GST_STR_NULL ( gst_tag_name ) ) ; switch ( datatype ) { case ASF_DEMUX_DATA_TYPE_UTF16LE_STRING : { gchar * value_utf8 ; value_utf8 = g_convert ( value , value_len , "UTF-8" , "UTF-16LE" , & in , & out , NULL ) ; if ( value_utf8 != NULL && * value_utf8 != '\\0' ) { GST_DEBUG ( "string<S2SV_blank>value<S2SV_blank>%s" , value_utf8 ) ; value_utf8 [ out ] = '\\0' ; if ( gst_tag_name != NULL ) { if ( strcmp ( gst_tag_name , GST_TAG_DATE_TIME ) == 0 ) { guint year = atoi ( value_utf8 ) ; if ( year > 0 ) { g_value_init ( & tag_value , GST_TYPE_DATE_TIME ) ; g_value_take_boxed ( & tag_value , gst_date_time_new_y ( year ) ) ; } } else if ( strcmp ( gst_tag_name , GST_TAG_GENRE ) == 0 ) { guint id3v1_genre_id ; const gchar * genre_str ; if ( sscanf ( value_utf8 , "(%u)" , & id3v1_genre_id ) == 1 && ( ( genre_str = gst_tag_id3_genre_get ( id3v1_genre_id ) ) ) ) { GST_DEBUG ( "Genre:<S2SV_blank>%s<S2SV_blank>-><S2SV_blank>%s" , value_utf8 , genre_str ) ; g_free ( value_utf8 ) ; value_utf8 = g_strdup ( genre_str ) ; } } else { GType tag_type ; tag_type = gst_tag_get_type ( gst_tag_name ) ; g_value_init ( & tag_value , tag_type ) ; if ( ! gst_value_deserialize ( & tag_value , value_utf8 ) ) { GValue from_val = { 0 , } ; g_value_init ( & from_val , G_TYPE_STRING ) ; g_value_set_string ( & from_val , value_utf8 ) ; if ( ! g_value_transform ( & from_val , & tag_value ) ) { GST_WARNING_OBJECT ( demux , "Could<S2SV_blank>not<S2SV_blank>transform<S2SV_blank>string<S2SV_blank>tag<S2SV_blank>to<S2SV_blank>" "%s<S2SV_blank>tag<S2SV_blank>type<S2SV_blank>%s" , gst_tag_name , g_type_name ( tag_type ) ) ; g_value_unset ( & tag_value ) ; } g_value_unset ( & from_val ) ; } } } else { GST_DEBUG ( "Setting<S2SV_blank>metadata" ) ; g_value_init ( & tag_value , G_TYPE_STRING ) ; g_value_set_string ( & tag_value , value_utf8 ) ; if ( content3D ) { guint i ; if ( strncmp ( "StereoscopicLayout" , name_utf8 , strlen ( name_utf8 ) ) == 0 ) { for ( i = 0 ; i < G_N_ELEMENTS ( stereoscopic_layout_map ) ; i ++ ) { if ( g_str_equal ( stereoscopic_layout_map [ i ] . interleave_name , value_utf8 ) ) { demux -> asf_3D_mode = stereoscopic_layout_map [ i ] . interleaving_type ; GST_INFO ( "find<S2SV_blank>interleave<S2SV_blank>type<S2SV_blank>%u" , demux -> asf_3D_mode ) ; } } } GST_INFO_OBJECT ( demux , "3d<S2SV_blank>type<S2SV_blank>is<S2SV_blank>%u" , demux -> asf_3D_mode ) ; } else { demux -> asf_3D_mode = GST_ASF_3D_NONE ; GST_INFO_OBJECT ( demux , "None<S2SV_blank>3d<S2SV_blank>type" ) ; } } } else if ( value_utf8 == NULL ) { GST_WARNING ( "Failed<S2SV_blank>to<S2SV_blank>convert<S2SV_blank>string<S2SV_blank>value<S2SV_blank>to<S2SV_blank>UTF8,<S2SV_blank>skipping" ) ; } else { GST_DEBUG ( "Skipping<S2SV_blank>empty<S2SV_blank>string<S2SV_blank>value<S2SV_blank>for<S2SV_blank>%s" , GST_STR_NULL ( gst_tag_name ) ) ; } g_free ( value_utf8 ) ; break ; } case ASF_DEMUX_DATA_TYPE_BYTE_ARRAY : { if ( gst_tag_name ) { if ( ! g_str_equal ( gst_tag_name , GST_TAG_IMAGE ) ) { GST_FIXME ( "Unhandled<S2SV_blank>byte<S2SV_blank>array<S2SV_blank>tag<S2SV_blank>%s" , GST_STR_NULL ( gst_tag_name ) ) ; break ; } else { asf_demux_parse_picture_tag ( taglist , ( guint8 * ) value , value_len ) ; } } break ; } case ASF_DEMUX_DATA_TYPE_DWORD : { <S2SV_StartBug> guint uint_val = GST_READ_UINT32_LE ( value ) ; <S2SV_EndBug> g_value_init ( & tag_value , G_TYPE_UINT ) ; if ( ! strcmp ( name_utf8 , "WM/Track" ) ) ++ uint_val ; g_value_set_uint ( & tag_value , uint_val ) ; break ; } case ASF_DEMUX_DATA_TYPE_BOOL : { <S2SV_StartBug> gboolean bool_val = GST_READ_UINT32_LE ( value ) ; <S2SV_EndBug> if ( strncmp ( "Stereoscopic" , name_utf8 , strlen ( name_utf8 ) ) == 0 ) { if ( bool_val ) { GST_INFO_OBJECT ( demux , "This<S2SV_blank>is<S2SV_blank>3D<S2SV_blank>contents" ) ; content3D = TRUE ; } else { GST_INFO_OBJECT ( demux , "This<S2SV_blank>is<S2SV_blank>not<S2SV_blank>3D<S2SV_blank>contenst" ) ; content3D = FALSE ; } } break ; } default : { GST_DEBUG ( "Skipping<S2SV_blank>tag<S2SV_blank>%s<S2SV_blank>of<S2SV_blank>type<S2SV_blank>%d" , gst_tag_name , datatype ) ; break ; } } if ( G_IS_VALUE ( & tag_value ) ) { if ( gst_tag_name ) { GstTagMergeMode merge_mode = GST_TAG_MERGE_APPEND ; if ( strcmp ( name_utf8 , "WM/TrackNumber" ) == 0 ) merge_mode = GST_TAG_MERGE_REPLACE ; gst_tag_list_add_values ( taglist , merge_mode , gst_tag_name , & tag_value , NULL ) ; } else { GST_DEBUG ( "Setting<S2SV_blank>global<S2SV_blank>metadata<S2SV_blank>%s" , name_utf8 ) ; gst_structure_set_value ( demux -> global_metadata , name_utf8 , & tag_value ) ; } g_value_unset ( & tag_value ) ; } } g_free ( name ) ; g_free ( value ) ; g_free ( name_utf8 ) ; } gst_asf_demux_add_global_tags ( demux , taglist ) ; return GST_FLOW_OK ; not_enough_data : { GST_WARNING ( "Unexpected<S2SV_blank>end<S2SV_blank>of<S2SV_blank>data<S2SV_blank>parsing<S2SV_blank>ext<S2SV_blank>content<S2SV_blank>desc<S2SV_blank>object" ) ; gst_tag_list_unref ( taglist ) ; return GST_FLOW_OK ; } }
Imaging ImagingResampleHorizontal ( Imaging imIn , int xsize , int filter ) { ImagingSectionCookie cookie ; Imaging imOut ; struct filter * filterp ; float support , scale , filterscale ; float center , ww , ss , ss0 , ss1 , ss2 , ss3 ; int xx , yy , x , kmax , xmin , xmax ; int * xbounds ; float * k , * kk ; switch ( filter ) { case IMAGING_TRANSFORM_LANCZOS : filterp = & LANCZOS ; break ; case IMAGING_TRANSFORM_BILINEAR : filterp = & BILINEAR ; break ; case IMAGING_TRANSFORM_BICUBIC : filterp = & BICUBIC ; break ; default : return ( Imaging ) ImagingError_ValueError ( "unsupported<S2SV_blank>resampling<S2SV_blank>filter" ) ; } filterscale = scale = ( float ) imIn -> xsize / xsize ; support = filterp -> support ; if ( filterscale < 1.0 ) { filterscale = 1.0 ; } support = support * filterscale ; kmax = ( int ) ceil ( support ) * 2 + 1 ; <S2SV_StartBug> kk = malloc ( xsize * kmax * sizeof ( float ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! kk ) <S2SV_EndBug> return ( Imaging ) ImagingError_MemoryError ( ) ; xbounds = malloc ( xsize * 2 * sizeof ( int ) ) ; if ( ! xbounds ) { free ( kk ) ; return ( Imaging ) ImagingError_MemoryError ( ) ; } for ( xx = 0 ; xx < xsize ; xx ++ ) { k = & kk [ xx * kmax ] ; center = ( xx + 0.5 ) * scale ; ww = 0.0 ; ss = 1.0 / filterscale ; xmin = ( int ) floor ( center - support ) ; if ( xmin < 0 ) xmin = 0 ; xmax = ( int ) ceil ( center + support ) ; if ( xmax > imIn -> xsize ) xmax = imIn -> xsize ; for ( x = xmin ; x < xmax ; x ++ ) { float w = filterp -> filter ( ( x - center + 0.5 ) * ss ) * ss ; k [ x - xmin ] = w ; ww += w ; } for ( x = 0 ; x < xmax - xmin ; x ++ ) { if ( ww != 0.0 ) k [ x ] /= ww ; } xbounds [ xx * 2 + 0 ] = xmin ; xbounds [ xx * 2 + 1 ] = xmax ; } imOut = ImagingNew ( imIn -> mode , xsize , imIn -> ysize ) ; if ( ! imOut ) { free ( kk ) ; free ( xbounds ) ; return NULL ; } ImagingSectionEnter ( & cookie ) ; for ( yy = 0 ; yy < imOut -> ysize ; yy ++ ) { if ( imIn -> image8 ) { for ( xx = 0 ; xx < xsize ; xx ++ ) { xmin = xbounds [ xx * 2 + 0 ] ; xmax = xbounds [ xx * 2 + 1 ] ; k = & kk [ xx * kmax ] ; ss = 0.5 ; for ( x = xmin ; x < xmax ; x ++ ) ss += i2f ( imIn -> image8 [ yy ] [ x ] ) * k [ x - xmin ] ; imOut -> image8 [ yy ] [ xx ] = clip8 ( ss ) ; } } else { switch ( imIn -> type ) { case IMAGING_TYPE_UINT8 : if ( imIn -> bands == 2 ) { for ( xx = 0 ; xx < xsize ; xx ++ ) { xmin = xbounds [ xx * 2 + 0 ] ; xmax = xbounds [ xx * 2 + 1 ] ; k = & kk [ xx * kmax ] ; ss0 = ss1 = 0.5 ; for ( x = xmin ; x < xmax ; x ++ ) { ss0 += i2f ( ( UINT8 ) imIn -> image [ yy ] [ x * 4 + 0 ] ) * k [ x - xmin ] ; ss1 += i2f ( ( UINT8 ) imIn -> image [ yy ] [ x * 4 + 3 ] ) * k [ x - xmin ] ; } imOut -> image [ yy ] [ xx * 4 + 0 ] = clip8 ( ss0 ) ; imOut -> image [ yy ] [ xx * 4 + 3 ] = clip8 ( ss1 ) ; } } else if ( imIn -> bands == 3 ) { for ( xx = 0 ; xx < xsize ; xx ++ ) { xmin = xbounds [ xx * 2 + 0 ] ; xmax = xbounds [ xx * 2 + 1 ] ; k = & kk [ xx * kmax ] ; ss0 = ss1 = ss2 = 0.5 ; for ( x = xmin ; x < xmax ; x ++ ) { ss0 += i2f ( ( UINT8 ) imIn -> image [ yy ] [ x * 4 + 0 ] ) * k [ x - xmin ] ; ss1 += i2f ( ( UINT8 ) imIn -> image [ yy ] [ x * 4 + 1 ] ) * k [ x - xmin ] ; ss2 += i2f ( ( UINT8 ) imIn -> image [ yy ] [ x * 4 + 2 ] ) * k [ x - xmin ] ; } imOut -> image [ yy ] [ xx * 4 + 0 ] = clip8 ( ss0 ) ; imOut -> image [ yy ] [ xx * 4 + 1 ] = clip8 ( ss1 ) ; imOut -> image [ yy ] [ xx * 4 + 2 ] = clip8 ( ss2 ) ; } } else { for ( xx = 0 ; xx < xsize ; xx ++ ) { xmin = xbounds [ xx * 2 + 0 ] ; xmax = xbounds [ xx * 2 + 1 ] ; k = & kk [ xx * kmax ] ; ss0 = ss1 = ss2 = ss3 = 0.5 ; for ( x = xmin ; x < xmax ; x ++ ) { ss0 += i2f ( ( UINT8 ) imIn -> image [ yy ] [ x * 4 + 0 ] ) * k [ x - xmin ] ; ss1 += i2f ( ( UINT8 ) imIn -> image [ yy ] [ x * 4 + 1 ] ) * k [ x - xmin ] ; ss2 += i2f ( ( UINT8 ) imIn -> image [ yy ] [ x * 4 + 2 ] ) * k [ x - xmin ] ; ss3 += i2f ( ( UINT8 ) imIn -> image [ yy ] [ x * 4 + 3 ] ) * k [ x - xmin ] ; } imOut -> image [ yy ] [ xx * 4 + 0 ] = clip8 ( ss0 ) ; imOut -> image [ yy ] [ xx * 4 + 1 ] = clip8 ( ss1 ) ; imOut -> image [ yy ] [ xx * 4 + 2 ] = clip8 ( ss2 ) ; imOut -> image [ yy ] [ xx * 4 + 3 ] = clip8 ( ss3 ) ; } } break ; case IMAGING_TYPE_INT32 : for ( xx = 0 ; xx < xsize ; xx ++ ) { xmin = xbounds [ xx * 2 + 0 ] ; xmax = xbounds [ xx * 2 + 1 ] ; k = & kk [ xx * kmax ] ; ss = 0.0 ; for ( x = xmin ; x < xmax ; x ++ ) ss += i2f ( IMAGING_PIXEL_I ( imIn , x , yy ) ) * k [ x - xmin ] ; IMAGING_PIXEL_I ( imOut , xx , yy ) = ( int ) ss ; } break ; case IMAGING_TYPE_FLOAT32 : for ( xx = 0 ; xx < xsize ; xx ++ ) { xmin = xbounds [ xx * 2 + 0 ] ; xmax = xbounds [ xx * 2 + 1 ] ; k = & kk [ xx * kmax ] ; ss = 0.0 ; for ( x = xmin ; x < xmax ; x ++ ) ss += IMAGING_PIXEL_F ( imIn , x , yy ) * k [ x - xmin ] ; IMAGING_PIXEL_F ( imOut , xx , yy ) = ss ; } break ; } } } ImagingSectionLeave ( & cookie ) ; free ( kk ) ; free ( xbounds ) ; return imOut ; }
static int do_replace ( struct net * net , const void __user * user , unsigned int len ) { int ret , countersize ; struct ebt_table_info * newinfo ; struct ebt_replace tmp ; if ( copy_from_user ( & tmp , user , sizeof ( tmp ) ) != 0 ) return - EFAULT ; if ( len != sizeof ( tmp ) + tmp . entries_size ) { BUGPRINT ( "Wrong<S2SV_blank>len<S2SV_blank>argument\\n" ) ; return - EINVAL ; } if ( tmp . entries_size == 0 ) { BUGPRINT ( "Entries_size<S2SV_blank>never<S2SV_blank>zero\\n" ) ; return - EINVAL ; } if ( tmp . nentries >= ( ( INT_MAX - sizeof ( struct ebt_table_info ) ) / NR_CPUS - SMP_CACHE_BYTES ) / sizeof ( struct ebt_counter ) ) return - ENOMEM ; if ( tmp . num_counters >= INT_MAX / sizeof ( struct ebt_counter ) ) return - ENOMEM ; <S2SV_StartBug> countersize = COUNTER_OFFSET ( tmp . nentries ) * nr_cpu_ids ; <S2SV_EndBug> newinfo = vmalloc ( sizeof ( * newinfo ) + countersize ) ; if ( ! newinfo ) return - ENOMEM ; if ( countersize ) memset ( newinfo -> counters , 0 , countersize ) ; newinfo -> entries = vmalloc ( tmp . entries_size ) ; if ( ! newinfo -> entries ) { ret = - ENOMEM ; goto free_newinfo ; } if ( copy_from_user ( newinfo -> entries , tmp . entries , tmp . entries_size ) != 0 ) { BUGPRINT ( "Couldn\'t<S2SV_blank>copy<S2SV_blank>entries<S2SV_blank>from<S2SV_blank>userspace\\n" ) ; ret = - EFAULT ; goto free_entries ; } ret = do_replace_finish ( net , & tmp , newinfo ) ; if ( ret == 0 ) return ret ; free_entries : vfree ( newinfo -> entries ) ; free_newinfo : vfree ( newinfo ) ; return ret ; }
struct timespec ns_to_timespec ( const s64 nsec ) { <S2SV_StartBug> struct timespec ts ; <S2SV_EndBug> if ( ! nsec ) return ( struct timespec ) { 0 , 0 } ; <S2SV_StartBug> ts . tv_sec = div_long_long_rem_signed ( nsec , NSEC_PER_SEC , & ts . tv_nsec ) ; <S2SV_EndBug> <S2SV_StartBug> if ( unlikely ( nsec < 0 ) ) <S2SV_EndBug> <S2SV_StartBug> set_normalized_timespec ( & ts , ts . tv_sec , ts . tv_nsec ) ; <S2SV_EndBug> return ts ; }
rfbBool HandleRFBServerMessage ( rfbClient * client ) { rfbServerToClientMsg msg ; if ( client -> serverPort == - 1 ) client -> vncRec -> readTimestamp = TRUE ; if ( ! ReadFromRFBServer ( client , ( char * ) & msg , 1 ) ) return FALSE ; switch ( msg . type ) { case rfbSetColourMapEntries : { break ; } case rfbFramebufferUpdate : { rfbFramebufferUpdateRectHeader rect ; int linesToRead ; int bytesPerLine ; int i ; if ( ! ReadFromRFBServer ( client , ( ( char * ) & msg . fu ) + 1 , sz_rfbFramebufferUpdateMsg - 1 ) ) return FALSE ; msg . fu . nRects = rfbClientSwap16IfLE ( msg . fu . nRects ) ; for ( i = 0 ; i < msg . fu . nRects ; i ++ ) { if ( ! ReadFromRFBServer ( client , ( char * ) & rect , sz_rfbFramebufferUpdateRectHeader ) ) return FALSE ; rect . encoding = rfbClientSwap32IfLE ( rect . encoding ) ; if ( rect . encoding == rfbEncodingLastRect ) break ; rect . r . x = rfbClientSwap16IfLE ( rect . r . x ) ; rect . r . y = rfbClientSwap16IfLE ( rect . r . y ) ; rect . r . w = rfbClientSwap16IfLE ( rect . r . w ) ; rect . r . h = rfbClientSwap16IfLE ( rect . r . h ) ; if ( rect . encoding == rfbEncodingXCursor || rect . encoding == rfbEncodingRichCursor ) { if ( ! HandleCursorShape ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h , rect . encoding ) ) { return FALSE ; } continue ; } if ( rect . encoding == rfbEncodingPointerPos ) { if ( ! client -> HandleCursorPos ( client , rect . r . x , rect . r . y ) ) { return FALSE ; } continue ; } if ( rect . encoding == rfbEncodingKeyboardLedState ) { client -> KeyboardLedStateEnabled = 1 ; if ( client -> HandleKeyboardLedState != NULL ) client -> HandleKeyboardLedState ( client , rect . r . x , 0 ) ; client -> CurrentKeyboardLedState = rect . r . x ; continue ; } if ( rect . encoding == rfbEncodingNewFBSize ) { client -> width = rect . r . w ; client -> height = rect . r . h ; client -> updateRect . x = client -> updateRect . y = 0 ; client -> updateRect . w = client -> width ; client -> updateRect . h = client -> height ; if ( ! client -> MallocFrameBuffer ( client ) ) return FALSE ; SendFramebufferUpdateRequest ( client , 0 , 0 , rect . r . w , rect . r . h , FALSE ) ; rfbClientLog ( "Got<S2SV_blank>new<S2SV_blank>framebuffer<S2SV_blank>size:<S2SV_blank>%dx%d\\n" , rect . r . w , rect . r . h ) ; continue ; } if ( rect . encoding == rfbEncodingSupportedMessages ) { int loop ; if ( ! ReadFromRFBServer ( client , ( char * ) & client -> supportedMessages , sz_rfbSupportedMessages ) ) return FALSE ; rfbClientLog ( "client2server<S2SV_blank>supported<S2SV_blank>messages<S2SV_blank>(bit<S2SV_blank>flags)\\n" ) ; for ( loop = 0 ; loop < 32 ; loop += 8 ) rfbClientLog ( "%02X:<S2SV_blank>%04x<S2SV_blank>%04x<S2SV_blank>%04x<S2SV_blank>%04x<S2SV_blank>-<S2SV_blank>%04x<S2SV_blank>%04x<S2SV_blank>%04x<S2SV_blank>%04x\\n" , loop , client -> supportedMessages . client2server [ loop ] , client -> supportedMessages . client2server [ loop + 1 ] , client -> supportedMessages . client2server [ loop + 2 ] , client -> supportedMessages . client2server [ loop + 3 ] , client -> supportedMessages . client2server [ loop + 4 ] , client -> supportedMessages . client2server [ loop + 5 ] , client -> supportedMessages . client2server [ loop + 6 ] , client -> supportedMessages . client2server [ loop + 7 ] ) ; rfbClientLog ( "server2client<S2SV_blank>supported<S2SV_blank>messages<S2SV_blank>(bit<S2SV_blank>flags)\\n" ) ; for ( loop = 0 ; loop < 32 ; loop += 8 ) rfbClientLog ( "%02X:<S2SV_blank>%04x<S2SV_blank>%04x<S2SV_blank>%04x<S2SV_blank>%04x<S2SV_blank>-<S2SV_blank>%04x<S2SV_blank>%04x<S2SV_blank>%04x<S2SV_blank>%04x\\n" , loop , client -> supportedMessages . server2client [ loop ] , client -> supportedMessages . server2client [ loop + 1 ] , client -> supportedMessages . server2client [ loop + 2 ] , client -> supportedMessages . server2client [ loop + 3 ] , client -> supportedMessages . server2client [ loop + 4 ] , client -> supportedMessages . server2client [ loop + 5 ] , client -> supportedMessages . server2client [ loop + 6 ] , client -> supportedMessages . server2client [ loop + 7 ] ) ; continue ; } if ( rect . encoding == rfbEncodingSupportedEncodings ) { char * buffer ; buffer = malloc ( rect . r . w ) ; if ( ! ReadFromRFBServer ( client , buffer , rect . r . w ) ) { free ( buffer ) ; return FALSE ; } free ( buffer ) ; continue ; } if ( rect . encoding == rfbEncodingServerIdentity ) { char * buffer ; buffer = malloc ( rect . r . w + 1 ) ; if ( ! ReadFromRFBServer ( client , buffer , rect . r . w ) ) { free ( buffer ) ; return FALSE ; } buffer [ rect . r . w ] = 0 ; rfbClientLog ( "Connected<S2SV_blank>to<S2SV_blank>Server<S2SV_blank>\\"%s\\"\\n" , buffer ) ; free ( buffer ) ; continue ; } if ( rect . encoding != rfbEncodingUltraZip ) { if ( ( rect . r . x + rect . r . w > client -> width ) || ( rect . r . y + rect . r . h > client -> height ) ) { rfbClientLog ( "Rect<S2SV_blank>too<S2SV_blank>large:<S2SV_blank>%dx%d<S2SV_blank>at<S2SV_blank>(%d,<S2SV_blank>%d)\\n" , rect . r . w , rect . r . h , rect . r . x , rect . r . y ) ; return FALSE ; } client -> SoftCursorLockArea ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ; } switch ( rect . encoding ) { case rfbEncodingRaw : { int y = rect . r . y , h = rect . r . h ; bytesPerLine = rect . r . w * client -> format . bitsPerPixel / 8 ; linesToRead = bytesPerLine ? ( RFB_BUFFER_SIZE / bytesPerLine ) : 0 ; while ( linesToRead && h > 0 ) { if ( linesToRead > h ) linesToRead = h ; if ( ! ReadFromRFBServer ( client , client -> buffer , bytesPerLine * linesToRead ) ) return FALSE ; client -> GotBitmap ( client , ( uint8_t * ) client -> buffer , rect . r . x , y , rect . r . w , linesToRead ) ; h -= linesToRead ; y += linesToRead ; } break ; } case rfbEncodingCopyRect : { rfbCopyRect cr ; if ( ! ReadFromRFBServer ( client , ( char * ) & cr , sz_rfbCopyRect ) ) return FALSE ; cr . srcX = rfbClientSwap16IfLE ( cr . srcX ) ; cr . srcY = rfbClientSwap16IfLE ( cr . srcY ) ; client -> SoftCursorLockArea ( client , cr . srcX , cr . srcY , rect . r . w , rect . r . h ) ; client -> GotCopyRect ( client , cr . srcX , cr . srcY , rect . r . w , rect . r . h , rect . r . x , rect . r . y ) ; break ; } case rfbEncodingRRE : { switch ( client -> format . bitsPerPixel ) { case 8 : if ( ! HandleRRE8 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 16 : if ( ! HandleRRE16 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 32 : if ( ! HandleRRE32 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; } break ; } case rfbEncodingCoRRE : { switch ( client -> format . bitsPerPixel ) { case 8 : if ( ! HandleCoRRE8 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 16 : if ( ! HandleCoRRE16 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 32 : if ( ! HandleCoRRE32 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; } break ; } case rfbEncodingHextile : { switch ( client -> format . bitsPerPixel ) { case 8 : if ( ! HandleHextile8 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 16 : if ( ! HandleHextile16 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 32 : if ( ! HandleHextile32 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; } break ; } case rfbEncodingUltra : { switch ( client -> format . bitsPerPixel ) { case 8 : if ( ! HandleUltra8 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 16 : if ( ! HandleUltra16 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 32 : if ( ! HandleUltra32 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; } break ; } case rfbEncodingUltraZip : { switch ( client -> format . bitsPerPixel ) { case 8 : if ( ! HandleUltraZip8 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 16 : if ( ! HandleUltraZip16 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 32 : if ( ! HandleUltraZip32 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; } break ; } case rfbEncodingTRLE : { switch ( client -> format . bitsPerPixel ) { case 8 : if ( ! HandleTRLE8 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 16 : if ( client -> si . format . greenMax > 0x1F ) { if ( ! HandleTRLE16 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; } else { if ( ! HandleTRLE15 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; } break ; case 32 : { uint32_t maxColor = ( client -> format . redMax << client -> format . redShift ) | ( client -> format . greenMax << client -> format . greenShift ) | ( client -> format . blueMax << client -> format . blueShift ) ; if ( ( client -> format . bigEndian && ( maxColor & 0xff ) == 0 ) || ( ! client -> format . bigEndian && ( maxColor & 0xff000000 ) == 0 ) ) { if ( ! HandleTRLE24 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; } else if ( ! client -> format . bigEndian && ( maxColor & 0xff ) == 0 ) { if ( ! HandleTRLE24Up ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; } else if ( client -> format . bigEndian && ( maxColor & 0xff000000 ) == 0 ) { if ( ! HandleTRLE24Down ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; } else if ( ! HandleTRLE32 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; } } break ; } # ifdef LIBVNCSERVER_HAVE_LIBZ case rfbEncodingZlib : { switch ( client -> format . bitsPerPixel ) { case 8 : if ( ! HandleZlib8 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 16 : if ( ! HandleZlib16 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 32 : if ( ! HandleZlib32 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; } break ; } # ifdef LIBVNCSERVER_HAVE_LIBJPEG case rfbEncodingTight : { switch ( client -> format . bitsPerPixel ) { case 8 : if ( ! HandleTight8 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 16 : if ( ! HandleTight16 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 32 : if ( ! HandleTight32 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; } break ; } # endif case rfbEncodingZRLE : client -> appData . qualityLevel = 9 ; case rfbEncodingZYWRLE : { switch ( client -> format . bitsPerPixel ) { case 8 : if ( ! HandleZRLE8 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; case 16 : if ( client -> si . format . greenMax > 0x1F ) { if ( ! HandleZRLE16 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; } else { if ( ! HandleZRLE15 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; } break ; case 32 : { uint32_t maxColor = ( client -> format . redMax << client -> format . redShift ) | ( client -> format . greenMax << client -> format . greenShift ) | ( client -> format . blueMax << client -> format . blueShift ) ; if ( ( client -> format . bigEndian && ( maxColor & 0xff ) == 0 ) || ( ! client -> format . bigEndian && ( maxColor & 0xff000000 ) == 0 ) ) { if ( ! HandleZRLE24 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; } else if ( ! client -> format . bigEndian && ( maxColor & 0xff ) == 0 ) { if ( ! HandleZRLE24Up ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; } else if ( client -> format . bigEndian && ( maxColor & 0xff000000 ) == 0 ) { if ( ! HandleZRLE24Down ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; } else if ( ! HandleZRLE32 ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ) return FALSE ; break ; } } break ; } # endif default : { rfbBool handled = FALSE ; rfbClientProtocolExtension * e ; for ( e = rfbClientExtensions ; ! handled && e ; e = e -> next ) if ( e -> handleEncoding && e -> handleEncoding ( client , & rect ) ) handled = TRUE ; if ( ! handled ) { rfbClientLog ( "Unknown<S2SV_blank>rect<S2SV_blank>encoding<S2SV_blank>%d\\n" , ( int ) rect . encoding ) ; return FALSE ; } } } client -> SoftCursorUnlockScreen ( client ) ; client -> GotFrameBufferUpdate ( client , rect . r . x , rect . r . y , rect . r . w , rect . r . h ) ; } if ( ! SendIncrementalFramebufferUpdateRequest ( client ) ) return FALSE ; if ( client -> FinishedFrameBufferUpdate ) client -> FinishedFrameBufferUpdate ( client ) ; break ; } case rfbBell : { client -> Bell ( client ) ; break ; } case rfbServerCutText : { char * buffer ; if ( ! ReadFromRFBServer ( client , ( ( char * ) & msg ) + 1 , sz_rfbServerCutTextMsg - 1 ) ) return FALSE ; msg . sct . length = rfbClientSwap32IfLE ( msg . sct . length ) ; if ( msg . sct . length > 1 << 20 ) { rfbClientErr ( "Ignoring<S2SV_blank>too<S2SV_blank>big<S2SV_blank>cut<S2SV_blank>text<S2SV_blank>length<S2SV_blank>sent<S2SV_blank>by<S2SV_blank>server:<S2SV_blank>%u<S2SV_blank>B<S2SV_blank>><S2SV_blank>1<S2SV_blank>MB\\n" , ( unsigned int ) msg . sct . length ) ; return FALSE ; } buffer = malloc ( msg . sct . length + 1 ) ; if ( ! ReadFromRFBServer ( client , buffer , msg . sct . length ) ) { free ( buffer ) ; return FALSE ; } buffer [ msg . sct . length ] = 0 ; if ( client -> GotXCutText ) client -> GotXCutText ( client , buffer , msg . sct . length ) ; free ( buffer ) ; break ; } case rfbTextChat : { char * buffer = NULL ; if ( ! ReadFromRFBServer ( client , ( ( char * ) & msg ) + 1 , sz_rfbTextChatMsg - 1 ) ) return FALSE ; msg . tc . length = rfbClientSwap32IfLE ( msg . sct . length ) ; switch ( msg . tc . length ) { case rfbTextChatOpen : rfbClientLog ( "Received<S2SV_blank>TextChat<S2SV_blank>Open\\n" ) ; if ( client -> HandleTextChat != NULL ) client -> HandleTextChat ( client , ( int ) rfbTextChatOpen , NULL ) ; break ; case rfbTextChatClose : rfbClientLog ( "Received<S2SV_blank>TextChat<S2SV_blank>Close\\n" ) ; if ( client -> HandleTextChat != NULL ) client -> HandleTextChat ( client , ( int ) rfbTextChatClose , NULL ) ; break ; case rfbTextChatFinished : rfbClientLog ( "Received<S2SV_blank>TextChat<S2SV_blank>Finished\\n" ) ; if ( client -> HandleTextChat != NULL ) client -> HandleTextChat ( client , ( int ) rfbTextChatFinished , NULL ) ; break ; default : <S2SV_StartBug> buffer = malloc ( msg . tc . length + 1 ) ; <S2SV_EndBug> if ( ! ReadFromRFBServer ( client , buffer , msg . tc . length ) ) { free ( buffer ) ; return FALSE ; } buffer [ msg . tc . length ] = 0 ; rfbClientLog ( "Received<S2SV_blank>TextChat<S2SV_blank>\\"%s\\"\\n" , buffer ) ; if ( client -> HandleTextChat != NULL ) client -> HandleTextChat ( client , ( int ) msg . tc . length , buffer ) ; free ( buffer ) ; break ; } break ; } case rfbXvp : { if ( ! ReadFromRFBServer ( client , ( ( char * ) & msg ) + 1 , sz_rfbXvpMsg - 1 ) ) return FALSE ; SetClient2Server ( client , rfbXvp ) ; SetServer2Client ( client , rfbXvp ) ; if ( client -> HandleXvpMsg ) client -> HandleXvpMsg ( client , msg . xvp . version , msg . xvp . code ) ; break ; } case rfbResizeFrameBuffer : { if ( ! ReadFromRFBServer ( client , ( ( char * ) & msg ) + 1 , sz_rfbResizeFrameBufferMsg - 1 ) ) return FALSE ; client -> width = rfbClientSwap16IfLE ( msg . rsfb . framebufferWidth ) ; client -> height = rfbClientSwap16IfLE ( msg . rsfb . framebufferHeigth ) ; client -> updateRect . x = client -> updateRect . y = 0 ; client -> updateRect . w = client -> width ; client -> updateRect . h = client -> height ; if ( ! client -> MallocFrameBuffer ( client ) ) return FALSE ; SendFramebufferUpdateRequest ( client , 0 , 0 , client -> width , client -> height , FALSE ) ; rfbClientLog ( "Got<S2SV_blank>new<S2SV_blank>framebuffer<S2SV_blank>size:<S2SV_blank>%dx%d\\n" , client -> width , client -> height ) ; break ; } case rfbPalmVNCReSizeFrameBuffer : { if ( ! ReadFromRFBServer ( client , ( ( char * ) & msg ) + 1 , sz_rfbPalmVNCReSizeFrameBufferMsg - 1 ) ) return FALSE ; client -> width = rfbClientSwap16IfLE ( msg . prsfb . buffer_w ) ; client -> height = rfbClientSwap16IfLE ( msg . prsfb . buffer_h ) ; client -> updateRect . x = client -> updateRect . y = 0 ; client -> updateRect . w = client -> width ; client -> updateRect . h = client -> height ; if ( ! client -> MallocFrameBuffer ( client ) ) return FALSE ; SendFramebufferUpdateRequest ( client , 0 , 0 , client -> width , client -> height , FALSE ) ; rfbClientLog ( "Got<S2SV_blank>new<S2SV_blank>framebuffer<S2SV_blank>size:<S2SV_blank>%dx%d\\n" , client -> width , client -> height ) ; break ; } default : { rfbBool handled = FALSE ; rfbClientProtocolExtension * e ; for ( e = rfbClientExtensions ; ! handled && e ; e = e -> next ) if ( e -> handleMessage && e -> handleMessage ( client , & msg ) ) handled = TRUE ; if ( ! handled ) { char buffer [ 256 ] ; rfbClientLog ( "Unknown<S2SV_blank>message<S2SV_blank>type<S2SV_blank>%d<S2SV_blank>from<S2SV_blank>VNC<S2SV_blank>server\\n" , msg . type ) ; ReadFromRFBServer ( client , buffer , 256 ) ; return FALSE ; } } } return TRUE ; }
void init_xml_relax_ng ( ) { VALUE nokogiri = rb_define_module ( "Nokogiri" ) ; VALUE xml = rb_define_module_under ( nokogiri , "XML" ) ; VALUE klass = rb_define_class_under ( xml , "RelaxNG" , cNokogiriXmlSchema ) ; cNokogiriXmlRelaxNG = klass ; <S2SV_StartBug> rb_define_singleton_method ( klass , "read_memory" , read_memory , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> rb_define_singleton_method ( klass , "from_document" , from_document , 1 ) ; <S2SV_EndBug> rb_define_private_method ( klass , "validate_document" , validate_document , 1 ) ; }
<S2SV_StartBug> static void nsc_encode_subsampling ( NSC_CONTEXT * context ) <S2SV_EndBug> { UINT16 x ; UINT16 y ; <S2SV_StartBug> BYTE * co_dst ; <S2SV_EndBug> BYTE * cg_dst ; INT8 * co_src0 ; INT8 * co_src1 ; INT8 * cg_src0 ; INT8 * cg_src1 ; UINT32 tempWidth ; <S2SV_StartBug> UINT32 tempHeight ; <S2SV_EndBug> tempWidth = ROUND_UP_TO ( context -> width , 8 ) ; tempHeight = ROUND_UP_TO ( context -> height , 2 ) ; <S2SV_StartBug> for ( y = 0 ; y < tempHeight >> 1 ; y ++ ) <S2SV_EndBug> { <S2SV_StartBug> co_dst = context -> priv -> PlaneBuffers [ 1 ] + y * ( tempWidth >> 1 ) ; <S2SV_EndBug> <S2SV_StartBug> cg_dst = context -> priv -> PlaneBuffers [ 2 ] + y * ( tempWidth >> 1 ) ; <S2SV_EndBug> <S2SV_StartBug> co_src0 = ( INT8 * ) context -> priv -> PlaneBuffers [ 1 ] + ( y << 1 ) * tempWidth ; <S2SV_EndBug> <S2SV_StartBug> co_src1 = co_src0 + tempWidth ; <S2SV_EndBug> <S2SV_StartBug> cg_src0 = ( INT8 * ) context -> priv -> PlaneBuffers [ 2 ] + ( y << 1 ) * tempWidth ; <S2SV_EndBug> <S2SV_StartBug> cg_src1 = cg_src0 + tempWidth ; <S2SV_EndBug> for ( x = 0 ; x < tempWidth >> 1 ; x ++ ) { * co_dst ++ = ( BYTE ) ( ( ( INT16 ) * co_src0 + ( INT16 ) * ( co_src0 + 1 ) + ( INT16 ) * co_src1 + ( INT16 ) * ( co_src1 + 1 ) ) >> 2 ) ; * cg_dst ++ = ( BYTE ) ( ( ( INT16 ) * cg_src0 + ( INT16 ) * ( cg_src0 + 1 ) + ( INT16 ) * cg_src1 + ( INT16 ) * ( cg_src1 + 1 ) ) >> 2 ) ; co_src0 += 2 ; co_src1 += 2 ; cg_src0 += 2 ; cg_src1 += 2 ; } } <S2SV_StartBug> } <S2SV_EndBug>
static inline LineContribType * _gdContributionsCalc ( unsigned int line_size , unsigned int src_size , double scale_d , const interpolation_method pFilter ) { double width_d ; double scale_f_d = 1.0 ; const double filter_width_d = DEFAULT_BOX_RADIUS ; int windows_size ; unsigned int u ; LineContribType * res ; if ( scale_d < 1.0 ) { width_d = filter_width_d / scale_d ; scale_f_d = scale_d ; } else { width_d = filter_width_d ; } windows_size = 2 * ( int ) ceil ( width_d ) + 1 ; res = _gdContributionsAlloc ( line_size , windows_size ) ; for ( u = 0 ; u < line_size ; u ++ ) { const double dCenter = ( double ) u / scale_d ; register int iLeft = MAX ( 0 , ( int ) floor ( dCenter - width_d ) ) ; int iRight = MIN ( ( int ) ceil ( dCenter + width_d ) , ( int ) src_size - 1 ) ; double dTotalWeight = 0.0 ; <S2SV_StartBug> int iSrc ; <S2SV_EndBug> res -> ContribRow [ u ] . Left = iLeft ; res -> ContribRow [ u ] . Right = iRight ; if ( iRight - iLeft + 1 > windows_size ) { if ( iLeft < ( ( int ) src_size - 1 / 2 ) ) { iLeft ++ ; } else { iRight -- ; } } <S2SV_StartBug> for ( iSrc = iLeft ; iSrc <= iRight ; iSrc ++ ) { <S2SV_EndBug> <S2SV_StartBug> dTotalWeight += ( res -> ContribRow [ u ] . Weights [ iSrc - iLeft ] = scale_f_d * ( * pFilter ) ( scale_f_d * ( dCenter - ( double ) iSrc ) ) ) ; <S2SV_EndBug> } if ( dTotalWeight < 0.0 ) { _gdContributionsFree ( res ) ; return NULL ; } if ( dTotalWeight > 0.0 ) { for ( iSrc = iLeft ; iSrc <= iRight ; iSrc ++ ) { res -> ContribRow [ u ] . Weights [ iSrc - iLeft ] /= dTotalWeight ; } } } return res ; }
void __kvm_migrate_pit_timer ( struct kvm_vcpu * vcpu ) { struct kvm_pit * pit = vcpu -> kvm -> arch . vpit ; struct hrtimer * timer ; if ( ! kvm_vcpu_is_bsp ( vcpu ) || ! pit ) return ; timer = & pit -> pit_state . timer ; <S2SV_StartBug> if ( hrtimer_cancel ( timer ) ) <S2SV_EndBug> hrtimer_start_expires ( timer , HRTIMER_MODE_ABS ) ; <S2SV_StartBug> } <S2SV_EndBug>
char * Util_monitId ( char * idfile ) { <S2SV_StartBug> FILE * file = NULL ; <S2SV_EndBug> ASSERT ( idfile ) ; if ( ! File_exist ( idfile ) ) { <S2SV_StartBug> md5_context_t ctx ; <S2SV_EndBug> char buf [ STRLEN ] ; MD_T digest ; file = fopen ( idfile , "w" ) ; if ( ! file ) { LogError ( "Error<S2SV_blank>opening<S2SV_blank>the<S2SV_blank>idfile<S2SV_blank>\'%s\'<S2SV_blank>--<S2SV_blank>%s\\n" , idfile , STRERROR ) ; return NULL ; } <S2SV_StartBug> snprintf ( buf , STRLEN , "%lu%d%lu" , ( unsigned long ) Time_now ( ) , getpid ( ) , random ( ) ) ; <S2SV_EndBug> md5_init ( & ctx ) ; md5_append ( & ctx , ( const md5_byte_t * ) buf , STRLEN - 1 ) ; md5_finish ( & ctx , ( md5_byte_t * ) digest ) ; Util_digest2Bytes ( ( unsigned char * ) digest , 16 , Run . id ) ; <S2SV_StartBug> fprintf ( file , "%s" , Run . id ) ; <S2SV_EndBug> LogInfo ( "<S2SV_blank>New<S2SV_blank>Monit<S2SV_blank>id:<S2SV_blank>%s\\n<S2SV_blank>Stored<S2SV_blank>in<S2SV_blank>\'%s\'\\n" , Run . id , idfile ) ; } else { if ( ! File_isFile ( idfile ) ) { LogError ( "idfile<S2SV_blank>\'%s\'<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>regular<S2SV_blank>file\\n" , idfile ) ; return NULL ; } if ( ( file = fopen ( idfile , "r" ) ) == ( FILE * ) NULL ) { LogError ( "Error<S2SV_blank>opening<S2SV_blank>the<S2SV_blank>idfile<S2SV_blank>\'%s\'<S2SV_blank>--<S2SV_blank>%s\\n" , idfile , STRERROR ) ; return NULL ; } if ( fscanf ( file , "%64s" , Run . id ) != 1 ) { LogError ( "Error<S2SV_blank>reading<S2SV_blank>id<S2SV_blank>from<S2SV_blank>file<S2SV_blank>\'%s\'\\n" , idfile ) ; if ( fclose ( file ) ) LogError ( "Error<S2SV_blank>closing<S2SV_blank>file<S2SV_blank>\'%s\'<S2SV_blank>--<S2SV_blank>%s\\n" , idfile , STRERROR ) ; return NULL ; } } if ( fclose ( file ) ) LogError ( "Error<S2SV_blank>closing<S2SV_blank>file<S2SV_blank>\'%s\'<S2SV_blank>--<S2SV_blank>%s\\n" , idfile , STRERROR ) ; return Run . id ; }
int ares_parse_a_reply ( const unsigned char * abuf , int alen , struct hostent * * host ) { unsigned int qdcount , ancount ; int status , i , rr_type , rr_class , rr_len , naddrs ; long int len ; int naliases ; const unsigned char * aptr ; char * hostname , * rr_name , * rr_data , * * aliases ; struct in_addr * addrs ; struct hostent * hostent ; * host = NULL ; if ( alen < HFIXEDSZ ) return ARES_EBADRESP ; qdcount = DNS_HEADER_QDCOUNT ( abuf ) ; ancount = DNS_HEADER_ANCOUNT ( abuf ) ; if ( qdcount != 1 ) return ARES_EBADRESP ; aptr = abuf + HFIXEDSZ ; status = ares_expand_name ( aptr , abuf , alen , & hostname , & len ) ; if ( status != ARES_SUCCESS ) return status ; if ( aptr + len + QFIXEDSZ > abuf + alen ) { free ( hostname ) ; return ARES_EBADRESP ; } aptr += len + QFIXEDSZ ; addrs = malloc ( ancount * sizeof ( struct in_addr ) ) ; if ( ! addrs ) { free ( hostname ) ; return ARES_ENOMEM ; } aliases = malloc ( ( ancount + 1 ) * sizeof ( char * ) ) ; if ( ! aliases ) { free ( hostname ) ; free ( addrs ) ; return ARES_ENOMEM ; } naddrs = 0 ; naliases = 0 ; for ( i = 0 ; i < ( int ) ancount ; i ++ ) { status = ares_expand_name ( aptr , abuf , alen , & rr_name , & len ) ; if ( status != ARES_SUCCESS ) break ; aptr += len ; if ( aptr + RRFIXEDSZ > abuf + alen ) { free ( rr_name ) ; status = ARES_EBADRESP ; break ; } rr_type = DNS_RR_TYPE ( aptr ) ; rr_class = DNS_RR_CLASS ( aptr ) ; rr_len = DNS_RR_LEN ( aptr ) ; <S2SV_StartBug> aptr += RRFIXEDSZ ; <S2SV_EndBug> if ( rr_class == C_IN && rr_type == T_A && rr_len == sizeof ( struct in_addr ) && strcasecmp ( rr_name , hostname ) == 0 ) { memcpy ( & addrs [ naddrs ] , aptr , sizeof ( struct in_addr ) ) ; naddrs ++ ; status = ARES_SUCCESS ; } if ( rr_class == C_IN && rr_type == T_CNAME ) { aliases [ naliases ] = rr_name ; naliases ++ ; status = ares_expand_name ( aptr , abuf , alen , & rr_data , & len ) ; if ( status != ARES_SUCCESS ) break ; free ( hostname ) ; hostname = rr_data ; } else free ( rr_name ) ; aptr += rr_len ; if ( aptr > abuf + alen ) { status = ARES_EBADRESP ; break ; } } if ( status == ARES_SUCCESS && naddrs == 0 ) status = ARES_ENODATA ; if ( status == ARES_SUCCESS ) { aliases [ naliases ] = NULL ; hostent = malloc ( sizeof ( struct hostent ) ) ; if ( hostent ) { hostent -> h_addr_list = malloc ( ( naddrs + 1 ) * sizeof ( char * ) ) ; if ( hostent -> h_addr_list ) { hostent -> h_name = hostname ; hostent -> h_aliases = aliases ; hostent -> h_addrtype = AF_INET ; hostent -> h_length = sizeof ( struct in_addr ) ; for ( i = 0 ; i < naddrs ; i ++ ) hostent -> h_addr_list [ i ] = ( char * ) & addrs [ i ] ; hostent -> h_addr_list [ naddrs ] = NULL ; * host = hostent ; return ARES_SUCCESS ; } free ( hostent ) ; } status = ARES_ENOMEM ; } for ( i = 0 ; i < naliases ; i ++ ) free ( aliases [ i ] ) ; free ( aliases ) ; free ( addrs ) ; free ( hostname ) ; return status ; }
static int fwnet_incoming_packet ( struct fwnet_device * dev , __be32 * buf , int len , int source_node_id , int generation , bool is_broadcast ) { struct sk_buff * skb ; struct net_device * net = dev -> netdev ; struct rfc2734_header hdr ; unsigned lf ; unsigned long flags ; struct fwnet_peer * peer ; struct fwnet_partial_datagram * pd ; int fg_off ; int dg_size ; u16 datagram_label ; int retval ; u16 ether_type ; <S2SV_StartBug> hdr . w0 = be32_to_cpu ( buf [ 0 ] ) ; <S2SV_EndBug> lf = fwnet_get_hdr_lf ( & hdr ) ; if ( lf == RFC2374_HDR_UNFRAG ) { ether_type = fwnet_get_hdr_ether_type ( & hdr ) ; buf ++ ; len -= RFC2374_UNFRAG_HDR_SIZE ; skb = dev_alloc_skb ( len + LL_RESERVED_SPACE ( net ) ) ; if ( unlikely ( ! skb ) ) { net -> stats . rx_dropped ++ ; return - ENOMEM ; } skb_reserve ( skb , LL_RESERVED_SPACE ( net ) ) ; memcpy ( skb_put ( skb , len ) , buf , len ) ; return fwnet_finish_incoming_packet ( net , skb , source_node_id , is_broadcast , ether_type ) ; } <S2SV_StartBug> hdr . w1 = ntohl ( buf [ 1 ] ) ; <S2SV_EndBug> buf += 2 ; len -= RFC2374_FRAG_HDR_SIZE ; if ( lf == RFC2374_HDR_FIRSTFRAG ) { ether_type = fwnet_get_hdr_ether_type ( & hdr ) ; fg_off = 0 ; } else { ether_type = 0 ; fg_off = fwnet_get_hdr_fg_off ( & hdr ) ; } datagram_label = fwnet_get_hdr_dgl ( & hdr ) ; dg_size = fwnet_get_hdr_dg_size ( & hdr ) ; <S2SV_StartBug> spin_lock_irqsave ( & dev -> lock , flags ) ; <S2SV_EndBug> peer = fwnet_peer_find_by_node_id ( dev , source_node_id , generation ) ; if ( ! peer ) { retval = - ENOENT ; goto fail ; } pd = fwnet_pd_find ( peer , datagram_label ) ; if ( pd == NULL ) { while ( peer -> pdg_size >= FWNET_MAX_FRAGMENTS ) { fwnet_pd_delete ( list_first_entry ( & peer -> pd_list , struct fwnet_partial_datagram , pd_link ) ) ; peer -> pdg_size -- ; } pd = fwnet_pd_new ( net , peer , datagram_label , dg_size , buf , fg_off , len ) ; if ( pd == NULL ) { retval = - ENOMEM ; goto fail ; } peer -> pdg_size ++ ; } else { if ( fwnet_frag_overlap ( pd , fg_off , len ) || pd -> datagram_size != dg_size ) { fwnet_pd_delete ( pd ) ; pd = fwnet_pd_new ( net , peer , datagram_label , dg_size , buf , fg_off , len ) ; if ( pd == NULL ) { peer -> pdg_size -- ; retval = - ENOMEM ; goto fail ; } } else { if ( ! fwnet_pd_update ( peer , pd , buf , fg_off , len ) ) { fwnet_pd_delete ( pd ) ; peer -> pdg_size -- ; retval = - ENOMEM ; goto fail ; } } } if ( lf == RFC2374_HDR_FIRSTFRAG ) pd -> ether_type = ether_type ; if ( fwnet_pd_is_complete ( pd ) ) { ether_type = pd -> ether_type ; peer -> pdg_size -- ; skb = skb_get ( pd -> skb ) ; fwnet_pd_delete ( pd ) ; spin_unlock_irqrestore ( & dev -> lock , flags ) ; return fwnet_finish_incoming_packet ( net , skb , source_node_id , false , ether_type ) ; } retval = 0 ; fail : spin_unlock_irqrestore ( & dev -> lock , flags ) ; return retval ; }
kadm5_ret_t kadm5_create_principal_3 ( void * server_handle , kadm5_principal_ent_t entry , long mask , int n_ks_tuple , krb5_key_salt_tuple * ks_tuple , char * password ) { krb5_db_entry * kdb ; osa_princ_ent_rec adb ; kadm5_policy_ent_rec polent ; krb5_boolean have_polent = FALSE ; krb5_timestamp now ; krb5_tl_data * tl_data_tail ; unsigned int ret ; kadm5_server_handle_t handle = server_handle ; krb5_keyblock * act_mkey ; krb5_kvno act_kvno ; int new_n_ks_tuple = 0 ; krb5_key_salt_tuple * new_ks_tuple = NULL ; CHECK_HANDLE ( server_handle ) ; krb5_clear_error_message ( handle -> context ) ; check_1_6_dummy ( entry , mask , n_ks_tuple , ks_tuple , & password ) ; if ( entry == NULL ) return EINVAL ; if ( ! ( mask & KADM5_PRINCIPAL ) || ( mask & KADM5_MOD_NAME ) || ( mask & KADM5_MOD_TIME ) || ( mask & KADM5_LAST_PWD_CHANGE ) || ( mask & KADM5_MKVNO ) || ( mask & KADM5_AUX_ATTRIBUTES ) || ( mask & KADM5_LAST_SUCCESS ) || ( mask & KADM5_LAST_FAILED ) || ( mask & KADM5_FAIL_AUTH_COUNT ) ) return KADM5_BAD_MASK ; if ( ( mask & KADM5_KEY_DATA ) && entry -> n_key_data != 0 ) return KADM5_BAD_MASK ; if ( ( mask & KADM5_POLICY ) && entry -> policy == NULL ) return KADM5_BAD_MASK ; if ( ( mask & KADM5_POLICY ) && ( mask & KADM5_POLICY_CLR ) ) return KADM5_BAD_MASK ; if ( ( mask & ~ ALL_PRINC_MASK ) ) <S2SV_StartBug> return KADM5_BAD_MASK ; <S2SV_EndBug> ret = kdb_get_entry ( handle , entry -> principal , & kdb , & adb ) ; switch ( ret ) { case KADM5_UNK_PRINC : break ; case 0 : kdb_free_entry ( handle , kdb , & adb ) ; return KADM5_DUP ; default : return ret ; } kdb = calloc ( 1 , sizeof ( * kdb ) ) ; if ( kdb == NULL ) return ENOMEM ; memset ( & adb , 0 , sizeof ( osa_princ_ent_rec ) ) ; if ( ( mask & KADM5_POLICY ) ) { ret = get_policy ( handle , entry -> policy , & polent , & have_polent ) ; if ( ret ) goto cleanup ; } if ( password ) { ret = passwd_check ( handle , password , have_polent ? & polent : NULL , entry -> principal ) ; if ( ret ) goto cleanup ; } if ( ( ret = krb5_timeofday ( handle -> context , & now ) ) ) goto cleanup ; kdb -> magic = KRB5_KDB_MAGIC_NUMBER ; kdb -> len = KRB5_KDB_V1_BASE_LENGTH ; if ( ( mask & KADM5_ATTRIBUTES ) ) kdb -> attributes = entry -> attributes ; else kdb -> attributes = handle -> params . flags ; if ( ( mask & KADM5_MAX_LIFE ) ) kdb -> max_life = entry -> max_life ; else kdb -> max_life = handle -> params . max_life ; if ( mask & KADM5_MAX_RLIFE ) kdb -> max_renewable_life = entry -> max_renewable_life ; else kdb -> max_renewable_life = handle -> params . max_rlife ; if ( ( mask & KADM5_PRINC_EXPIRE_TIME ) ) kdb -> expiration = entry -> princ_expire_time ; else kdb -> expiration = handle -> params . expiration ; kdb -> pw_expiration = 0 ; if ( have_polent ) { if ( polent . pw_max_life ) kdb -> pw_expiration = ts_incr ( now , polent . pw_max_life ) ; else kdb -> pw_expiration = 0 ; } if ( ( mask & KADM5_PW_EXPIRATION ) ) kdb -> pw_expiration = entry -> pw_expiration ; kdb -> last_success = 0 ; kdb -> last_failed = 0 ; kdb -> fail_auth_count = 0 ; ret = krb5_copy_principal ( handle -> context , entry -> principal , & kdb -> princ ) ; if ( ret ) goto cleanup ; if ( ( ret = krb5_dbe_update_last_pwd_change ( handle -> context , kdb , now ) ) ) goto cleanup ; if ( mask & KADM5_TL_DATA ) { for ( tl_data_tail = entry -> tl_data ; tl_data_tail ; tl_data_tail = tl_data_tail -> tl_data_next ) { ret = krb5_dbe_update_tl_data ( handle -> context , kdb , tl_data_tail ) ; if ( ret ) goto cleanup ; } } ret = apply_keysalt_policy ( handle , entry -> policy , n_ks_tuple , ks_tuple , & new_n_ks_tuple , & new_ks_tuple ) ; if ( ret ) goto cleanup ; ret = kdb_get_active_mkey ( handle , & act_kvno , & act_mkey ) ; if ( ret ) goto cleanup ; if ( mask & KADM5_KEY_DATA ) { assert ( entry -> n_key_data == 0 ) ; } else if ( password ) { ret = krb5_dbe_cpw ( handle -> context , act_mkey , new_ks_tuple , new_n_ks_tuple , password , ( mask & KADM5_KVNO ) ? entry -> kvno : 1 , FALSE , kdb ) ; } else { ret = krb5_dbe_crk ( handle -> context , & master_keyblock , new_ks_tuple , new_n_ks_tuple , FALSE , kdb ) ; } if ( ret ) goto cleanup ; ret = krb5_dbe_update_mkvno ( handle -> context , kdb , act_kvno ) ; if ( ret ) goto cleanup ; ret = k5_kadm5_hook_create ( handle -> context , handle -> hook_handles , KADM5_HOOK_STAGE_PRECOMMIT , entry , mask , new_n_ks_tuple , new_ks_tuple , password ) ; if ( ret ) goto cleanup ; adb . admin_history_kvno = INITIAL_HIST_KVNO ; if ( mask & KADM5_POLICY ) { adb . aux_attributes = KADM5_POLICY ; adb . policy = entry -> policy ; } kdb -> mask = mask | KADM5_KEY_DATA | KADM5_PRINCIPAL ; ret = kdb_put_entry ( handle , kdb , & adb ) ; ( void ) k5_kadm5_hook_create ( handle -> context , handle -> hook_handles , KADM5_HOOK_STAGE_POSTCOMMIT , entry , mask , new_n_ks_tuple , new_ks_tuple , password ) ; cleanup : free ( new_ks_tuple ) ; krb5_db_free_principal ( handle -> context , kdb ) ; if ( have_polent ) ( void ) kadm5_free_policy_ent ( handle -> lhandle , & polent ) ; return ret ; }
static int em_jcxz ( struct x86_emulate_ctxt * ctxt ) <S2SV_StartBug> { <S2SV_EndBug> if ( address_mask ( ctxt , reg_read ( ctxt , VCPU_REGS_RCX ) ) == 0 ) <S2SV_StartBug> jmp_rel ( ctxt , ctxt -> src . val ) ; <S2SV_EndBug> <S2SV_StartBug> return X86EMUL_CONTINUE ; <S2SV_EndBug> }
static struct mount * clone_mnt ( struct mount * old , struct dentry * root , int flag ) { struct super_block * sb = old -> mnt . mnt_sb ; struct mount * mnt ; int err ; mnt = alloc_vfsmnt ( old -> mnt_devname ) ; if ( ! mnt ) return ERR_PTR ( - ENOMEM ) ; if ( flag & ( CL_SLAVE | CL_PRIVATE | CL_SHARED_TO_SLAVE ) ) mnt -> mnt_group_id = 0 ; else mnt -> mnt_group_id = old -> mnt_group_id ; if ( ( flag & CL_MAKE_SHARED ) && ! mnt -> mnt_group_id ) { err = mnt_alloc_group_id ( mnt ) ; if ( err ) goto out_free ; } mnt -> mnt . mnt_flags = old -> mnt . mnt_flags & ~ ( MNT_WRITE_HOLD | MNT_MARKED ) ; <S2SV_StartBug> if ( ( flag & CL_UNPRIVILEGED ) && ( mnt -> mnt . mnt_flags & MNT_READONLY ) ) <S2SV_EndBug> mnt -> mnt . mnt_flags |= MNT_LOCK_READONLY ; <S2SV_StartBug> if ( ( flag & CL_UNPRIVILEGED ) && list_empty ( & old -> mnt_expire ) ) <S2SV_EndBug> mnt -> mnt . mnt_flags |= MNT_LOCKED ; atomic_inc ( & sb -> s_active ) ; mnt -> mnt . mnt_sb = sb ; mnt -> mnt . mnt_root = dget ( root ) ; mnt -> mnt_mountpoint = mnt -> mnt . mnt_root ; mnt -> mnt_parent = mnt ; lock_mount_hash ( ) ; list_add_tail ( & mnt -> mnt_instance , & sb -> s_mounts ) ; unlock_mount_hash ( ) ; if ( ( flag & CL_SLAVE ) || ( ( flag & CL_SHARED_TO_SLAVE ) && IS_MNT_SHARED ( old ) ) ) { list_add ( & mnt -> mnt_slave , & old -> mnt_slave_list ) ; mnt -> mnt_master = old ; CLEAR_MNT_SHARED ( mnt ) ; } else if ( ! ( flag & CL_PRIVATE ) ) { if ( ( flag & CL_MAKE_SHARED ) || IS_MNT_SHARED ( old ) ) list_add ( & mnt -> mnt_share , & old -> mnt_share ) ; if ( IS_MNT_SLAVE ( old ) ) list_add ( & mnt -> mnt_slave , & old -> mnt_slave ) ; mnt -> mnt_master = old -> mnt_master ; } if ( flag & CL_MAKE_SHARED ) set_mnt_shared ( mnt ) ; if ( flag & CL_EXPIRE ) { if ( ! list_empty ( & old -> mnt_expire ) ) list_add ( & mnt -> mnt_expire , & old -> mnt_expire ) ; } return mnt ; out_free : mnt_free_id ( mnt ) ; free_vfsmnt ( mnt ) ; return ERR_PTR ( err ) ; }
int writefile ( const char * name , struct string * s ) { FILE * f ; int ret ; f = fopen ( name , "w" ) ; if ( ! f ) { warn ( "open<S2SV_blank>%s:" , name ) ; return - 1 ; } ret = 0 ; <S2SV_StartBug> if ( fwrite ( s -> s , 1 , s -> n , f ) != s -> n || fflush ( f ) != 0 ) { <S2SV_EndBug> warn ( "write<S2SV_blank>%s:" , name ) ; ret = - 1 ; } fclose ( f ) ; return ret ; }
SNDFILE * sf_open_virtual ( SF_VIRTUAL_IO * sfvirtual , int mode , SF_INFO * sfinfo , void * user_data ) { SF_PRIVATE * psf ; if ( sfvirtual -> get_filelen == NULL || sfvirtual -> seek == NULL || sfvirtual -> tell == NULL ) { sf_errno = SFE_BAD_VIRTUAL_IO ; snprintf ( sf_parselog , sizeof ( sf_parselog ) , "Bad<S2SV_blank>vio_get_filelen<S2SV_blank>/<S2SV_blank>vio_seek<S2SV_blank>/<S2SV_blank>vio_tell<S2SV_blank>in<S2SV_blank>SF_VIRTUAL_IO<S2SV_blank>struct.\\n" ) ; return NULL ; } ; if ( ( mode == SFM_READ || mode == SFM_RDWR ) && sfvirtual -> read == NULL ) { sf_errno = SFE_BAD_VIRTUAL_IO ; snprintf ( sf_parselog , sizeof ( sf_parselog ) , "Bad<S2SV_blank>vio_read<S2SV_blank>in<S2SV_blank>SF_VIRTUAL_IO<S2SV_blank>struct.\\n" ) ; return NULL ; } ; if ( ( mode == SFM_WRITE || mode == SFM_RDWR ) && sfvirtual -> write == NULL ) { sf_errno = SFE_BAD_VIRTUAL_IO ; snprintf ( sf_parselog , sizeof ( sf_parselog ) , "Bad<S2SV_blank>vio_write<S2SV_blank>in<S2SV_blank>SF_VIRTUAL_IO<S2SV_blank>struct.\\n" ) ; return NULL ; } ; <S2SV_StartBug> if ( ( psf = calloc ( 1 , sizeof ( SF_PRIVATE ) ) ) == NULL ) <S2SV_EndBug> { sf_errno = SFE_MALLOC_FAILED ; return NULL ; } ; psf_init_files ( psf ) ; psf -> virtual_io = SF_TRUE ; psf -> vio = * sfvirtual ; psf -> vio_user_data = user_data ; psf -> file . mode = mode ; return psf_open_file ( psf , sfinfo ) ; }
jp2_box_t * jp2_box_get ( jas_stream_t * in ) { jp2_box_t * box ; jp2_boxinfo_t * boxinfo ; jas_stream_t * tmpstream ; uint_fast32_t len ; uint_fast64_t extlen ; bool dataflag ; box = 0 ; tmpstream = 0 ; if ( ! ( box = jas_malloc ( sizeof ( jp2_box_t ) ) ) ) { goto error ; } box -> ops = & jp2_boxinfo_unk . ops ; if ( jp2_getuint32 ( in , & len ) || jp2_getuint32 ( in , & box -> type ) ) { goto error ; } boxinfo = jp2_boxinfolookup ( box -> type ) ; box -> info = boxinfo ; box -> ops = & boxinfo -> ops ; <S2SV_StartBug> box -> len = len ; <S2SV_EndBug> if ( box -> len == 1 ) { if ( jp2_getuint64 ( in , & extlen ) ) { goto error ; } if ( extlen > 0xffffffffUL ) { jas_eprintf ( "warning:<S2SV_blank>cannot<S2SV_blank>handle<S2SV_blank>large<S2SV_blank>64-bit<S2SV_blank>box<S2SV_blank>length\\n" ) ; extlen = 0xffffffffUL ; } box -> len = extlen ; box -> datalen = extlen - JP2_BOX_HDRLEN ( true ) ; } else { box -> datalen = box -> len - JP2_BOX_HDRLEN ( false ) ; } if ( box -> len != 0 && box -> len < 8 ) { goto error ; } dataflag = ! ( box -> info -> flags & ( JP2_BOX_SUPER | JP2_BOX_NODATA ) ) ; if ( dataflag ) { if ( ! ( tmpstream = jas_stream_memopen ( 0 , 0 ) ) ) { goto error ; } if ( jas_stream_copy ( tmpstream , in , box -> datalen ) ) { <S2SV_StartBug> jas_eprintf ( "cannot<S2SV_blank>copy<S2SV_blank>box<S2SV_blank>data\\n" ) ; <S2SV_EndBug> goto error ; } jas_stream_rewind ( tmpstream ) ; if ( box -> ops -> getdata ) { if ( ( * box -> ops -> getdata ) ( box , tmpstream ) ) { jas_eprintf ( "cannot<S2SV_blank>parse<S2SV_blank>box<S2SV_blank>data\\n" ) ; goto error ; } } jas_stream_close ( tmpstream ) ; } if ( jas_getdbglevel ( ) >= 1 ) { jp2_box_dump ( box , stderr ) ; } return box ; error : if ( box ) { jp2_box_destroy ( box ) ; } if ( tmpstream ) { jas_stream_close ( tmpstream ) ; } return 0 ; }
int yr_object_array_set_item ( YR_OBJECT * object , YR_OBJECT * item , int index ) { YR_OBJECT_ARRAY * array ; int i ; int count ; assert ( index >= 0 ) ; assert ( object -> type == OBJECT_TYPE_ARRAY ) ; array = object_as_array ( object ) ; if ( array -> items == NULL ) { <S2SV_StartBug> count = yr_max ( 64 , ( index + 1 ) * 2 ) ; <S2SV_EndBug> array -> items = ( YR_ARRAY_ITEMS * ) yr_malloc ( sizeof ( YR_ARRAY_ITEMS ) + count * sizeof ( YR_OBJECT * ) ) ; if ( array -> items == NULL ) return ERROR_INSUFFICIENT_MEMORY ; memset ( array -> items -> objects , 0 , count * sizeof ( YR_OBJECT * ) ) ; array -> items -> count = count ; } else if ( index >= array -> items -> count ) { count = array -> items -> count * 2 ; <S2SV_StartBug> array -> items = ( YR_ARRAY_ITEMS * ) yr_realloc ( <S2SV_EndBug> array -> items , sizeof ( YR_ARRAY_ITEMS ) + count * sizeof ( YR_OBJECT * ) ) ; if ( array -> items == NULL ) return ERROR_INSUFFICIENT_MEMORY ; for ( i = array -> items -> count ; i < count ; i ++ ) array -> items -> objects [ i ] = NULL ; array -> items -> count = count ; } item -> parent = object ; array -> items -> objects [ index ] = item ; return ERROR_SUCCESS ; }
static int bgp_attr_print ( netdissect_options * ndo , u_int atype , const u_char * pptr , u_int len ) { int i ; uint16_t af ; uint8_t safi , snpa , nhlen ; union { float f ; uint32_t i ; } bw ; int advance ; u_int tlen ; const u_char * tptr ; char buf [ MAXHOSTNAMELEN + 100 ] ; int as_size ; tptr = pptr ; tlen = len ; switch ( atype ) { case BGPTYPE_ORIGIN : if ( len != 1 ) ND_PRINT ( ( ndo , "invalid<S2SV_blank>len" ) ) ; else { ND_TCHECK ( * tptr ) ; ND_PRINT ( ( ndo , "%s" , tok2str ( bgp_origin_values , "Unknown<S2SV_blank>Origin<S2SV_blank>Typecode" , tptr [ 0 ] ) ) ) ; } break ; case BGPTYPE_AS4_PATH : case BGPTYPE_AS_PATH : if ( len % 2 ) { ND_PRINT ( ( ndo , "invalid<S2SV_blank>len" ) ) ; break ; } if ( ! len ) { ND_PRINT ( ( ndo , "empty" ) ) ; break ; } as_size = bgp_attr_get_as_size ( ndo , atype , pptr , len ) ; while ( tptr < pptr + len ) { ND_TCHECK ( tptr [ 0 ] ) ; ND_PRINT ( ( ndo , "%s" , tok2str ( bgp_as_path_segment_open_values , "?" , tptr [ 0 ] ) ) ) ; ND_TCHECK ( tptr [ 1 ] ) ; for ( i = 0 ; i < tptr [ 1 ] * as_size ; i += as_size ) { ND_TCHECK2 ( tptr [ 2 + i ] , as_size ) ; ND_PRINT ( ( ndo , "%s<S2SV_blank>" , as_printf ( ndo , astostr , sizeof ( astostr ) , as_size == 2 ? EXTRACT_16BITS ( & tptr [ 2 + i ] ) : EXTRACT_32BITS ( & tptr [ 2 + i ] ) ) ) ) ; } ND_TCHECK ( tptr [ 0 ] ) ; ND_PRINT ( ( ndo , "%s" , tok2str ( bgp_as_path_segment_close_values , "?" , tptr [ 0 ] ) ) ) ; ND_TCHECK ( tptr [ 1 ] ) ; tptr += 2 + tptr [ 1 ] * as_size ; } break ; case BGPTYPE_NEXT_HOP : if ( len != 4 ) ND_PRINT ( ( ndo , "invalid<S2SV_blank>len" ) ) ; else { ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , "%s" , ipaddr_string ( ndo , tptr ) ) ) ; } break ; case BGPTYPE_MULTI_EXIT_DISC : case BGPTYPE_LOCAL_PREF : if ( len != 4 ) ND_PRINT ( ( ndo , "invalid<S2SV_blank>len" ) ) ; else { ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , "%u" , EXTRACT_32BITS ( tptr ) ) ) ; } break ; case BGPTYPE_ATOMIC_AGGREGATE : if ( len != 0 ) ND_PRINT ( ( ndo , "invalid<S2SV_blank>len" ) ) ; break ; case BGPTYPE_AGGREGATOR : if ( len != 6 && len != 8 ) { ND_PRINT ( ( ndo , "invalid<S2SV_blank>len" ) ) ; break ; } ND_TCHECK2 ( tptr [ 0 ] , len ) ; if ( len == 6 ) { ND_PRINT ( ( ndo , "<S2SV_blank>AS<S2SV_blank>#%s,<S2SV_blank>origin<S2SV_blank>%s" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_16BITS ( tptr ) ) , ipaddr_string ( ndo , tptr + 2 ) ) ) ; } else { ND_PRINT ( ( ndo , "<S2SV_blank>AS<S2SV_blank>#%s,<S2SV_blank>origin<S2SV_blank>%s" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( tptr ) ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; } break ; case BGPTYPE_AGGREGATOR4 : if ( len != 8 ) { ND_PRINT ( ( ndo , "invalid<S2SV_blank>len" ) ) ; break ; } ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , "<S2SV_blank>AS<S2SV_blank>#%s,<S2SV_blank>origin<S2SV_blank>%s" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( tptr ) ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; break ; case BGPTYPE_COMMUNITIES : if ( len % 4 ) { ND_PRINT ( ( ndo , "invalid<S2SV_blank>len" ) ) ; break ; } while ( tlen > 0 ) { uint32_t comm ; ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; comm = EXTRACT_32BITS ( tptr ) ; switch ( comm ) { case BGP_COMMUNITY_NO_EXPORT : ND_PRINT ( ( ndo , "<S2SV_blank>NO_EXPORT" ) ) ; break ; case BGP_COMMUNITY_NO_ADVERT : ND_PRINT ( ( ndo , "<S2SV_blank>NO_ADVERTISE" ) ) ; break ; case BGP_COMMUNITY_NO_EXPORT_SUBCONFED : ND_PRINT ( ( ndo , "<S2SV_blank>NO_EXPORT_SUBCONFED" ) ) ; break ; default : ND_PRINT ( ( ndo , "%u:%u%s" , ( comm >> 16 ) & 0xffff , comm & 0xffff , ( tlen > 4 ) ? ",<S2SV_blank>" : "" ) ) ; break ; } tlen -= 4 ; tptr += 4 ; } break ; case BGPTYPE_ORIGINATOR_ID : if ( len != 4 ) { ND_PRINT ( ( ndo , "invalid<S2SV_blank>len" ) ) ; break ; } ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , "%s" , ipaddr_string ( ndo , tptr ) ) ) ; break ; case BGPTYPE_CLUSTER_LIST : if ( len % 4 ) { ND_PRINT ( ( ndo , "invalid<S2SV_blank>len" ) ) ; break ; } while ( tlen > 0 ) { ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , "%s%s" , ipaddr_string ( ndo , tptr ) , ( tlen > 4 ) ? ",<S2SV_blank>" : "" ) ) ; tlen -= 4 ; tptr += 4 ; } break ; case BGPTYPE_MP_REACH_NLRI : ND_TCHECK2 ( tptr [ 0 ] , 3 ) ; af = EXTRACT_16BITS ( tptr ) ; safi = tptr [ 2 ] ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>AFI:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>%sSAFI:<S2SV_blank>%s<S2SV_blank>(%u)" , tok2str ( af_values , "Unknown<S2SV_blank>AFI" , af ) , af , ( safi > 128 ) ? "vendor<S2SV_blank>specific<S2SV_blank>" : "" , tok2str ( bgp_safi_values , "Unknown<S2SV_blank>SAFI" , safi ) , safi ) ) ; switch ( af << 8 | safi ) { case ( AFNUM_INET << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_LABUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_RT_ROUTING_INFO ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNIMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST_VPN ) : case ( AFNUM_INET << 8 | SAFNUM_MDT ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_LABUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNIMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNIMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNIMULTICAST ) : case ( AFNUM_VPLS << 8 | SAFNUM_VPLS ) : break ; default : ND_TCHECK2 ( tptr [ 0 ] , tlen ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>no<S2SV_blank>AFI<S2SV_blank>%u<S2SV_blank>/<S2SV_blank>SAFI<S2SV_blank>%u<S2SV_blank>decoder" , af , safi ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" , tlen ) ; goto done ; break ; } tptr += 3 ; ND_TCHECK ( tptr [ 0 ] ) ; nhlen = tptr [ 0 ] ; tlen = nhlen ; tptr ++ ; if ( tlen ) { int nnh = 0 ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>nexthop:<S2SV_blank>" ) ) ; while ( tlen > 0 ) { if ( nnh ++ > 0 ) { ND_PRINT ( ( ndo , ",<S2SV_blank>" ) ) ; } switch ( af << 8 | safi ) { case ( AFNUM_INET << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_LABUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_RT_ROUTING_INFO ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST_VPN ) : case ( AFNUM_INET << 8 | SAFNUM_MDT ) : if ( tlen < ( int ) sizeof ( struct in_addr ) ) { ND_PRINT ( ( ndo , "invalid<S2SV_blank>len" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in_addr ) ) ; ND_PRINT ( ( ndo , "%s" , ipaddr_string ( ndo , tptr ) ) ) ; tlen -= sizeof ( struct in_addr ) ; tptr += sizeof ( struct in_addr ) ; } break ; case ( AFNUM_INET << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNIMULTICAST ) : if ( tlen < ( int ) ( sizeof ( struct in_addr ) + BGP_VPN_RD_LEN ) ) { ND_PRINT ( ( ndo , "invalid<S2SV_blank>len" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in_addr ) + BGP_VPN_RD_LEN ) ; ND_PRINT ( ( ndo , "RD:<S2SV_blank>%s,<S2SV_blank>%s" , bgp_vpn_rd_print ( ndo , tptr ) , ipaddr_string ( ndo , tptr + BGP_VPN_RD_LEN ) ) ) ; tlen -= ( sizeof ( struct in_addr ) + BGP_VPN_RD_LEN ) ; tptr += ( sizeof ( struct in_addr ) + BGP_VPN_RD_LEN ) ; } break ; case ( AFNUM_INET6 << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNIMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_LABUNICAST ) : if ( tlen < ( int ) sizeof ( struct in6_addr ) ) { ND_PRINT ( ( ndo , "invalid<S2SV_blank>len" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in6_addr ) ) ; ND_PRINT ( ( ndo , "%s" , ip6addr_string ( ndo , tptr ) ) ) ; tlen -= sizeof ( struct in6_addr ) ; tptr += sizeof ( struct in6_addr ) ; } break ; case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNIMULTICAST ) : if ( tlen < ( int ) ( sizeof ( struct in6_addr ) + BGP_VPN_RD_LEN ) ) { ND_PRINT ( ( ndo , "invalid<S2SV_blank>len" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in6_addr ) + BGP_VPN_RD_LEN ) ; ND_PRINT ( ( ndo , "RD:<S2SV_blank>%s,<S2SV_blank>%s" , bgp_vpn_rd_print ( ndo , tptr ) , ip6addr_string ( ndo , tptr + BGP_VPN_RD_LEN ) ) ) ; tlen -= ( sizeof ( struct in6_addr ) + BGP_VPN_RD_LEN ) ; tptr += ( sizeof ( struct in6_addr ) + BGP_VPN_RD_LEN ) ; } break ; case ( AFNUM_VPLS << 8 | SAFNUM_VPLS ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNIMULTICAST ) : if ( tlen < ( int ) sizeof ( struct in_addr ) ) { ND_PRINT ( ( ndo , "invalid<S2SV_blank>len" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , sizeof ( struct in_addr ) ) ; ND_PRINT ( ( ndo , "%s" , ipaddr_string ( ndo , tptr ) ) ) ; tlen -= ( sizeof ( struct in_addr ) ) ; tptr += ( sizeof ( struct in_addr ) ) ; } break ; case ( AFNUM_NSAP << 8 | SAFNUM_UNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNIMULTICAST ) : ND_TCHECK2 ( tptr [ 0 ] , tlen ) ; ND_PRINT ( ( ndo , "%s" , isonsap_string ( ndo , tptr , tlen ) ) ) ; tptr += tlen ; tlen = 0 ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNIMULTICAST ) : if ( tlen < BGP_VPN_RD_LEN + 1 ) { ND_PRINT ( ( ndo , "invalid<S2SV_blank>len" ) ) ; tlen = 0 ; } else { ND_TCHECK2 ( tptr [ 0 ] , tlen ) ; ND_PRINT ( ( ndo , "RD:<S2SV_blank>%s,<S2SV_blank>%s" , bgp_vpn_rd_print ( ndo , tptr ) , isonsap_string ( ndo , tptr + BGP_VPN_RD_LEN , tlen - BGP_VPN_RD_LEN ) ) ) ; <S2SV_StartBug> if ( EXTRACT_32BITS ( tptr + BGP_VPN_RD_LEN ) == 0x47000601 ) <S2SV_EndBug> ND_PRINT ( ( ndo , "<S2SV_blank>=<S2SV_blank>%s" , ipaddr_string ( ndo , tptr + BGP_VPN_RD_LEN + 4 ) ) ) ; <S2SV_StartBug> else if ( EXTRACT_24BITS ( tptr + BGP_VPN_RD_LEN ) == 0x350000 ) <S2SV_EndBug> ND_PRINT ( ( ndo , "<S2SV_blank>=<S2SV_blank>%s" , ip6addr_string ( ndo , tptr + BGP_VPN_RD_LEN + 3 ) ) ) ; tptr += tlen ; tlen = 0 ; } break ; default : ND_TCHECK2 ( tptr [ 0 ] , tlen ) ; ND_PRINT ( ( ndo , "no<S2SV_blank>AFI<S2SV_blank>%u/SAFI<S2SV_blank>%u<S2SV_blank>decoder" , af , safi ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" , tlen ) ; tptr += tlen ; tlen = 0 ; goto done ; break ; } } } ND_PRINT ( ( ndo , ",<S2SV_blank>nh-length:<S2SV_blank>%u" , nhlen ) ) ; tptr += tlen ; ND_TCHECK ( tptr [ 0 ] ) ; snpa = tptr [ 0 ] ; tptr ++ ; if ( snpa ) { ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%u<S2SV_blank>SNPA" , snpa ) ) ; for ( ; snpa > 0 ; snpa -- ) { ND_TCHECK ( tptr [ 0 ] ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%d<S2SV_blank>bytes" , tptr [ 0 ] ) ) ; tptr += tptr [ 0 ] + 1 ; } } else { ND_PRINT ( ( ndo , ",<S2SV_blank>no<S2SV_blank>SNPA" ) ) ; } while ( tptr < pptr + len ) { switch ( af << 8 | safi ) { case ( AFNUM_INET << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_prefix4 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_LABUNICAST ) : advance = decode_labeled_prefix4 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_prefix4 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_RT_ROUTING_INFO ) : advance = decode_rt_routing_info ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_MULTICAST_VPN ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST_VPN ) : advance = decode_multicast_vpn ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_MDT ) : advance = decode_mdt_vpn_nlri ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_prefix6 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_LABUNICAST ) : advance = decode_labeled_prefix6 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_prefix6 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_VPLS << 8 | SAFNUM_VPLS ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_l2 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_UNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_clnp_prefix ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_clnp_prefix ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; default : ND_TCHECK2 ( * tptr , tlen ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>no<S2SV_blank>AFI<S2SV_blank>%u<S2SV_blank>/<S2SV_blank>SAFI<S2SV_blank>%u<S2SV_blank>decoder" , af , safi ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" , tlen ) ; advance = 0 ; tptr = pptr + len ; break ; } if ( advance < 0 ) break ; tptr += advance ; } done : break ; case BGPTYPE_MP_UNREACH_NLRI : ND_TCHECK2 ( tptr [ 0 ] , BGP_MP_NLRI_MINSIZE ) ; af = EXTRACT_16BITS ( tptr ) ; safi = tptr [ 2 ] ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>AFI:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>%sSAFI:<S2SV_blank>%s<S2SV_blank>(%u)" , tok2str ( af_values , "Unknown<S2SV_blank>AFI" , af ) , af , ( safi > 128 ) ? "vendor<S2SV_blank>specific<S2SV_blank>" : "" , tok2str ( bgp_safi_values , "Unknown<S2SV_blank>SAFI" , safi ) , safi ) ) ; if ( len == BGP_MP_NLRI_MINSIZE ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>End-of-Rib<S2SV_blank>Marker<S2SV_blank>(empty<S2SV_blank>NLRI)" ) ) ; tptr += 3 ; while ( tptr < pptr + len ) { switch ( af << 8 | safi ) { case ( AFNUM_INET << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_prefix4 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_LABUNICAST ) : advance = decode_labeled_prefix4 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_prefix4 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_UNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_prefix6 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_LABUNICAST ) : advance = decode_labeled_prefix6 ( ndo , tptr , len , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else if ( advance == - 3 ) break ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_INET6 << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_prefix6 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_VPLS << 8 | SAFNUM_VPLS ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_L2VPN << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_l2 ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_UNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_MULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_UNIMULTICAST ) : advance = decode_clnp_prefix ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNMULTICAST ) : case ( AFNUM_NSAP << 8 | SAFNUM_VPNUNIMULTICAST ) : advance = decode_labeled_vpn_clnp_prefix ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_MDT ) : advance = decode_mdt_vpn_nlri ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; case ( AFNUM_INET << 8 | SAFNUM_MULTICAST_VPN ) : case ( AFNUM_INET6 << 8 | SAFNUM_MULTICAST_VPN ) : advance = decode_multicast_vpn ( ndo , tptr , buf , sizeof ( buf ) ) ; if ( advance == - 1 ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>(illegal<S2SV_blank>prefix<S2SV_blank>length)" ) ) ; else if ( advance == - 2 ) goto trunc ; else ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s" , buf ) ) ; break ; default : ND_TCHECK2 ( * ( tptr - 3 ) , tlen ) ; ND_PRINT ( ( ndo , "no<S2SV_blank>AFI<S2SV_blank>%u<S2SV_blank>/<S2SV_blank>SAFI<S2SV_blank>%u<S2SV_blank>decoder" , af , safi ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , tptr - 3 , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" , tlen ) ; advance = 0 ; tptr = pptr + len ; break ; } if ( advance < 0 ) break ; tptr += advance ; } break ; case BGPTYPE_EXTD_COMMUNITIES : if ( len % 8 ) { ND_PRINT ( ( ndo , "invalid<S2SV_blank>len" ) ) ; break ; } while ( tlen > 0 ) { uint16_t extd_comm ; ND_TCHECK2 ( tptr [ 0 ] , 2 ) ; extd_comm = EXTRACT_16BITS ( tptr ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s<S2SV_blank>(0x%04x),<S2SV_blank>Flags<S2SV_blank>[%s]" , tok2str ( bgp_extd_comm_subtype_values , "unknown<S2SV_blank>extd<S2SV_blank>community<S2SV_blank>typecode" , extd_comm ) , extd_comm , bittok2str ( bgp_extd_comm_flag_values , "none" , extd_comm ) ) ) ; ND_TCHECK2 ( * ( tptr + 2 ) , 6 ) ; switch ( extd_comm ) { case BGP_EXT_COM_RT_0 : case BGP_EXT_COM_RO_0 : case BGP_EXT_COM_L2VPN_RT_0 : ND_PRINT ( ( ndo , ":<S2SV_blank>%u:%u<S2SV_blank>(=<S2SV_blank>%s)" , EXTRACT_16BITS ( tptr + 2 ) , EXTRACT_32BITS ( tptr + 4 ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; break ; case BGP_EXT_COM_RT_1 : case BGP_EXT_COM_RO_1 : case BGP_EXT_COM_L2VPN_RT_1 : case BGP_EXT_COM_VRF_RT_IMP : ND_PRINT ( ( ndo , ":<S2SV_blank>%s:%u" , ipaddr_string ( ndo , tptr + 2 ) , EXTRACT_16BITS ( tptr + 6 ) ) ) ; break ; case BGP_EXT_COM_RT_2 : case BGP_EXT_COM_RO_2 : ND_PRINT ( ( ndo , ":<S2SV_blank>%s:%u" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( tptr + 2 ) ) , EXTRACT_16BITS ( tptr + 6 ) ) ) ; break ; case BGP_EXT_COM_LINKBAND : bw . i = EXTRACT_32BITS ( tptr + 2 ) ; ND_PRINT ( ( ndo , ":<S2SV_blank>bandwidth:<S2SV_blank>%.3f<S2SV_blank>Mbps" , bw . f * 8 / 1000000 ) ) ; break ; case BGP_EXT_COM_VPN_ORIGIN : case BGP_EXT_COM_VPN_ORIGIN2 : case BGP_EXT_COM_VPN_ORIGIN3 : case BGP_EXT_COM_VPN_ORIGIN4 : case BGP_EXT_COM_OSPF_RID : case BGP_EXT_COM_OSPF_RID2 : ND_PRINT ( ( ndo , "%s" , ipaddr_string ( ndo , tptr + 2 ) ) ) ; break ; case BGP_EXT_COM_OSPF_RTYPE : case BGP_EXT_COM_OSPF_RTYPE2 : ND_PRINT ( ( ndo , ":<S2SV_blank>area:%s,<S2SV_blank>router-type:%s,<S2SV_blank>metric-type:%s%s" , ipaddr_string ( ndo , tptr + 2 ) , tok2str ( bgp_extd_comm_ospf_rtype_values , "unknown<S2SV_blank>(0x%02x)" , * ( tptr + 6 ) ) , ( * ( tptr + 7 ) & BGP_OSPF_RTYPE_METRIC_TYPE ) ? "E2" : "" , ( ( * ( tptr + 6 ) == BGP_OSPF_RTYPE_EXT ) || ( * ( tptr + 6 ) == BGP_OSPF_RTYPE_NSSA ) ) ? "E1" : "" ) ) ; break ; case BGP_EXT_COM_L2INFO : ND_PRINT ( ( ndo , ":<S2SV_blank>%s<S2SV_blank>Control<S2SV_blank>Flags<S2SV_blank>[0x%02x]:MTU<S2SV_blank>%u" , tok2str ( l2vpn_encaps_values , "unknown<S2SV_blank>encaps" , * ( tptr + 2 ) ) , * ( tptr + 3 ) , EXTRACT_16BITS ( tptr + 4 ) ) ) ; break ; case BGP_EXT_COM_SOURCE_AS : ND_PRINT ( ( ndo , ":<S2SV_blank>AS<S2SV_blank>%u" , EXTRACT_16BITS ( tptr + 2 ) ) ) ; break ; default : ND_TCHECK2 ( * tptr , 8 ) ; print_unknown_data ( ndo , tptr , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" , 8 ) ; break ; } tlen -= 8 ; tptr += 8 ; } break ; case BGPTYPE_PMSI_TUNNEL : { uint8_t tunnel_type , flags ; ND_TCHECK2 ( tptr [ 0 ] , 5 ) ; tunnel_type = * ( tptr + 1 ) ; flags = * tptr ; tlen = len ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Tunnel-type<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>Flags<S2SV_blank>[%s],<S2SV_blank>MPLS<S2SV_blank>Label<S2SV_blank>%u" , tok2str ( bgp_pmsi_tunnel_values , "Unknown" , tunnel_type ) , tunnel_type , bittok2str ( bgp_pmsi_flag_values , "none" , flags ) , EXTRACT_24BITS ( tptr + 2 ) >> 4 ) ) ; tptr += 5 ; tlen -= 5 ; switch ( tunnel_type ) { case BGP_PMSI_TUNNEL_PIM_SM : case BGP_PMSI_TUNNEL_PIM_BIDIR : ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Sender<S2SV_blank>%s,<S2SV_blank>P-Group<S2SV_blank>%s" , ipaddr_string ( ndo , tptr ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; break ; case BGP_PMSI_TUNNEL_PIM_SSM : ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Root-Node<S2SV_blank>%s,<S2SV_blank>P-Group<S2SV_blank>%s" , ipaddr_string ( ndo , tptr ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; break ; case BGP_PMSI_TUNNEL_INGRESS : ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Tunnel-Endpoint<S2SV_blank>%s" , ipaddr_string ( ndo , tptr ) ) ) ; break ; case BGP_PMSI_TUNNEL_LDP_P2MP : case BGP_PMSI_TUNNEL_LDP_MP2MP : ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Root-Node<S2SV_blank>%s,<S2SV_blank>LSP-ID<S2SV_blank>0x%08x" , ipaddr_string ( ndo , tptr ) , EXTRACT_32BITS ( tptr + 4 ) ) ) ; break ; case BGP_PMSI_TUNNEL_RSVP_P2MP : ND_TCHECK2 ( tptr [ 0 ] , 8 ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Extended-Tunnel-ID<S2SV_blank>%s,<S2SV_blank>P2MP-ID<S2SV_blank>0x%08x" , ipaddr_string ( ndo , tptr ) , EXTRACT_32BITS ( tptr + 4 ) ) ) ; break ; default : if ( ndo -> ndo_vflag <= 1 ) { print_unknown_data ( ndo , tptr , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" , tlen ) ; } } break ; } case BGPTYPE_AIGP : { uint8_t type ; uint16_t length ; tlen = len ; while ( tlen >= 3 ) { ND_TCHECK2 ( tptr [ 0 ] , 3 ) ; type = * tptr ; length = EXTRACT_16BITS ( tptr + 1 ) ; tptr += 3 ; tlen -= 3 ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s<S2SV_blank>TLV<S2SV_blank>(%u),<S2SV_blank>length<S2SV_blank>%u" , tok2str ( bgp_aigp_values , "Unknown" , type ) , type , length ) ) ; if ( length < 3 ) goto trunc ; length -= 3 ; ND_TCHECK2 ( tptr [ 3 ] , length ) ; switch ( type ) { case BGP_AIGP_TLV : if ( length < 8 ) goto trunc ; ND_PRINT ( ( ndo , ",<S2SV_blank>metric<S2SV_blank>%" PRIu64 , EXTRACT_64BITS ( tptr ) ) ) ; break ; default : if ( ndo -> ndo_vflag <= 1 ) { print_unknown_data ( ndo , tptr , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" , length ) ; } } tptr += length ; tlen -= length ; } break ; } case BGPTYPE_ATTR_SET : ND_TCHECK2 ( tptr [ 0 ] , 4 ) ; if ( len < 4 ) goto trunc ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Origin<S2SV_blank>AS:<S2SV_blank>%s" , as_printf ( ndo , astostr , sizeof ( astostr ) , EXTRACT_32BITS ( tptr ) ) ) ) ; tptr += 4 ; len -= 4 ; while ( len ) { u_int aflags , alenlen , alen ; ND_TCHECK2 ( tptr [ 0 ] , 2 ) ; if ( len < 2 ) goto trunc ; aflags = * tptr ; atype = * ( tptr + 1 ) ; tptr += 2 ; len -= 2 ; alenlen = bgp_attr_lenlen ( aflags , tptr ) ; ND_TCHECK2 ( tptr [ 0 ] , alenlen ) ; if ( len < alenlen ) goto trunc ; alen = bgp_attr_len ( aflags , tptr ) ; tptr += alenlen ; len -= alenlen ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>length:<S2SV_blank>%u" , tok2str ( bgp_attr_values , "Unknown<S2SV_blank>Attribute" , atype ) , atype , alen ) ) ; if ( aflags ) { ND_PRINT ( ( ndo , ",<S2SV_blank>Flags<S2SV_blank>[%s%s%s%s" , aflags & 0x80 ? "O" : "" , aflags & 0x40 ? "T" : "" , aflags & 0x20 ? "P" : "" , aflags & 0x10 ? "E" : "" ) ) ; if ( aflags & 0xf ) ND_PRINT ( ( ndo , "+%x" , aflags & 0xf ) ) ; ND_PRINT ( ( ndo , "]:<S2SV_blank>" ) ) ; } if ( ! bgp_attr_print ( ndo , atype , tptr , alen ) ) return 0 ; tptr += alen ; len -= alen ; } break ; case BGPTYPE_LARGE_COMMUNITY : if ( len == 0 || len % 12 ) { ND_PRINT ( ( ndo , "invalid<S2SV_blank>len" ) ) ; break ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" ) ) ; while ( len > 0 ) { ND_TCHECK2 ( * tptr , 12 ) ; ND_PRINT ( ( ndo , "%u:%u:%u%s" , EXTRACT_32BITS ( tptr ) , EXTRACT_32BITS ( tptr + 4 ) , EXTRACT_32BITS ( tptr + 8 ) , ( len > 12 ) ? ",<S2SV_blank>" : "" ) ) ; tptr += 12 ; len -= 12 ; } break ; default : ND_TCHECK2 ( * pptr , len ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>no<S2SV_blank>Attribute<S2SV_blank>%u<S2SV_blank>decoder" , atype ) ) ; if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , pptr , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" , len ) ; break ; } if ( ndo -> ndo_vflag > 1 && len ) { ND_TCHECK2 ( * pptr , len ) ; print_unknown_data ( ndo , pptr , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" , len ) ; } return 1 ; trunc : return 0 ; }
static const uint32_t * parserep ( netdissect_options * ndo , register const struct sunrpc_msg * rp , register u_int length ) { register const uint32_t * dp ; u_int len ; enum sunrpc_accept_stat astat ; dp = ( ( const uint32_t * ) & rp -> rm_reply ) + 1 ; ND_TCHECK ( dp [ 1 ] ) ; len = EXTRACT_32BITS ( & dp [ 1 ] ) ; if ( len >= length ) return ( NULL ) ; dp += ( len + ( 2 * sizeof ( uint32_t ) + 3 ) ) / sizeof ( uint32_t ) ; <S2SV_StartBug> ND_TCHECK2 ( dp [ 0 ] , 0 ) ; <S2SV_EndBug> astat = ( enum sunrpc_accept_stat ) EXTRACT_32BITS ( dp ) ; if ( astat != SUNRPC_SUCCESS ) { ND_PRINT ( ( ndo , "<S2SV_blank>%s" , tok2str ( sunrpc_str , "ar_stat<S2SV_blank>%d" , astat ) ) ) ; nfserr = 1 ; return ( NULL ) ; } ND_TCHECK2 ( * dp , sizeof ( astat ) ) ; return ( ( const uint32_t * ) ( sizeof ( astat ) + ( ( const char * ) dp ) ) ) ; trunc : return ( 0 ) ; }
static int zerocopy_sg_from_iovec ( struct sk_buff * skb , const struct iovec * from , int offset , size_t count ) { int len = iov_length ( from , count ) - offset ; int copy = skb_headlen ( skb ) ; int size , offset1 = 0 ; int i = 0 ; while ( count && ( offset >= from -> iov_len ) ) { offset -= from -> iov_len ; ++ from ; -- count ; } while ( count && ( copy > 0 ) ) { size = min_t ( unsigned int , copy , from -> iov_len - offset ) ; if ( copy_from_user ( skb -> data + offset1 , from -> iov_base + offset , size ) ) return - EFAULT ; if ( copy > size ) { ++ from ; -- count ; offset = 0 ; } else offset += size ; copy -= size ; offset1 += size ; } if ( len == offset1 ) return 0 ; while ( count -- ) { struct page * page [ MAX_SKB_FRAGS ] ; int num_pages ; unsigned long base ; unsigned long truesize ; len = from -> iov_len - offset ; if ( ! len ) { offset = 0 ; ++ from ; continue ; } base = ( unsigned long ) from -> iov_base + offset ; size = ( ( base & ~ PAGE_MASK ) + len + ~ PAGE_MASK ) >> PAGE_SHIFT ; <S2SV_StartBug> num_pages = get_user_pages_fast ( base , size , 0 , & page [ i ] ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( num_pages != size ) || <S2SV_EndBug> ( num_pages > MAX_SKB_FRAGS - skb_shinfo ( skb ) -> nr_frags ) ) { for ( i = 0 ; i < num_pages ; i ++ ) put_page ( page [ i ] ) ; return - EFAULT ; } truesize = size * PAGE_SIZE ; skb -> data_len += len ; skb -> len += len ; skb -> truesize += truesize ; atomic_add ( truesize , & skb -> sk -> sk_wmem_alloc ) ; while ( len ) { int off = base & ~ PAGE_MASK ; int size = min_t ( int , len , PAGE_SIZE - off ) ; __skb_fill_page_desc ( skb , i , page [ i ] , off , size ) ; skb_shinfo ( skb ) -> nr_frags ++ ; base += size ; len -= size ; i ++ ; } offset = 0 ; ++ from ; } return 0 ; }
PHYSICALPATH_FUNC ( mod_alias_physical_handler ) { plugin_data * p = p_d ; int uri_len , basedir_len ; char * uri_ptr ; size_t k ; if ( buffer_is_empty ( con -> physical . path ) ) return HANDLER_GO_ON ; mod_alias_patch_connection ( srv , con , p ) ; basedir_len = buffer_string_length ( con -> physical . basedir ) ; if ( '/' == con -> physical . basedir -> ptr [ basedir_len - 1 ] ) -- basedir_len ; uri_len = buffer_string_length ( con -> physical . path ) - basedir_len ; uri_ptr = con -> physical . path -> ptr + basedir_len ; for ( k = 0 ; k < p -> conf . alias -> used ; k ++ ) { data_string * ds = ( data_string * ) p -> conf . alias -> data [ k ] ; int alias_len = buffer_string_length ( ds -> key ) ; if ( alias_len > uri_len ) continue ; if ( buffer_is_empty ( ds -> key ) ) continue ; if ( 0 == ( con -> conf . force_lowercase_filenames ? strncasecmp ( uri_ptr , ds -> key -> ptr , alias_len ) : strncmp ( uri_ptr , ds -> key -> ptr , alias_len ) ) ) { <S2SV_StartBug> buffer_copy_buffer ( con -> physical . basedir , ds -> value ) ; <S2SV_EndBug> buffer_copy_buffer ( srv -> tmp_buf , ds -> value ) ; buffer_append_string ( srv -> tmp_buf , uri_ptr + alias_len ) ; buffer_copy_buffer ( con -> physical . path , srv -> tmp_buf ) ; return HANDLER_GO_ON ; } } return HANDLER_GO_ON ; }
static ssize_t _hostsock_writev ( oe_fd_t * desc , const struct oe_iovec * iov , int iovcnt ) { ssize_t ret = - 1 ; sock_t * sock = _cast_sock ( desc ) ; void * buf = NULL ; <S2SV_StartBug> size_t buf_size = 0 ; <S2SV_EndBug> if ( ! sock || ! iov || iovcnt < 0 || iovcnt > OE_IOV_MAX ) OE_RAISE_ERRNO ( OE_EINVAL ) ; <S2SV_StartBug> if ( oe_iov_pack ( iov , iovcnt , & buf , & buf_size ) != 0 ) <S2SV_EndBug> <S2SV_StartBug> OE_RAISE_ERRNO ( OE_ENOMEM ) ; <S2SV_EndBug> if ( oe_syscall_sendv_ocall ( & ret , sock -> host_fd , buf , iovcnt , buf_size ) != OE_OK ) { OE_RAISE_ERRNO ( OE_EINVAL ) ; } <S2SV_StartBug> done : <S2SV_EndBug> if ( buf ) oe_free ( buf ) ; return ret ; }
static int try_smi_init ( struct smi_info * new_smi ) { int rv = 0 ; int i ; char * init_name = NULL ; pr_info ( "Trying<S2SV_blank>%s-specified<S2SV_blank>%s<S2SV_blank>state<S2SV_blank>machine<S2SV_blank>at<S2SV_blank>%s<S2SV_blank>address<S2SV_blank>0x%lx,<S2SV_blank>slave<S2SV_blank>address<S2SV_blank>0x%x,<S2SV_blank>irq<S2SV_blank>%d\\n" , ipmi_addr_src_to_str ( new_smi -> io . addr_source ) , si_to_str [ new_smi -> io . si_type ] , addr_space_to_str [ new_smi -> io . addr_type ] , new_smi -> io . addr_data , new_smi -> io . slave_addr , new_smi -> io . irq ) ; switch ( new_smi -> io . si_type ) { case SI_KCS : new_smi -> handlers = & kcs_smi_handlers ; break ; case SI_SMIC : new_smi -> handlers = & smic_smi_handlers ; break ; case SI_BT : new_smi -> handlers = & bt_smi_handlers ; break ; default : rv = - EIO ; goto out_err ; } new_smi -> si_num = smi_num ; if ( ! new_smi -> io . dev ) { init_name = kasprintf ( GFP_KERNEL , "ipmi_si.%d" , new_smi -> si_num ) ; new_smi -> pdev = platform_device_alloc ( "ipmi_si" , new_smi -> si_num ) ; if ( ! new_smi -> pdev ) { pr_err ( "Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>platform<S2SV_blank>device\\n" ) ; rv = - ENOMEM ; goto out_err ; } new_smi -> io . dev = & new_smi -> pdev -> dev ; new_smi -> io . dev -> driver = & ipmi_platform_driver . driver ; new_smi -> io . dev -> init_name = init_name ; } new_smi -> si_sm = kmalloc ( new_smi -> handlers -> size ( ) , GFP_KERNEL ) ; if ( ! new_smi -> si_sm ) { rv = - ENOMEM ; goto out_err ; } new_smi -> io . io_size = new_smi -> handlers -> init_data ( new_smi -> si_sm , & new_smi -> io ) ; rv = new_smi -> io . io_setup ( & new_smi -> io ) ; if ( rv ) { dev_err ( new_smi -> io . dev , "Could<S2SV_blank>not<S2SV_blank>set<S2SV_blank>up<S2SV_blank>I/O<S2SV_blank>space\\n" ) ; goto out_err ; } if ( new_smi -> handlers -> detect ( new_smi -> si_sm ) ) { if ( new_smi -> io . addr_source ) dev_err ( new_smi -> io . dev , "Interface<S2SV_blank>detection<S2SV_blank>failed\\n" ) ; rv = - ENODEV ; goto out_err ; } rv = try_get_dev_id ( new_smi ) ; if ( rv ) { if ( new_smi -> io . addr_source ) dev_err ( new_smi -> io . dev , "There<S2SV_blank>appears<S2SV_blank>to<S2SV_blank>be<S2SV_blank>no<S2SV_blank>BMC<S2SV_blank>at<S2SV_blank>this<S2SV_blank>location\\n" ) ; goto out_err ; } setup_oem_data_handler ( new_smi ) ; setup_xaction_handlers ( new_smi ) ; check_for_broken_irqs ( new_smi ) ; new_smi -> waiting_msg = NULL ; new_smi -> curr_msg = NULL ; atomic_set ( & new_smi -> req_events , 0 ) ; new_smi -> run_to_completion = false ; for ( i = 0 ; i < SI_NUM_STATS ; i ++ ) atomic_set ( & new_smi -> stats [ i ] , 0 ) ; new_smi -> interrupt_disabled = true ; atomic_set ( & new_smi -> need_watch , 0 ) ; rv = try_enable_event_buffer ( new_smi ) ; if ( rv == 0 ) new_smi -> has_event_buffer = true ; start_clear_flags ( new_smi ) ; if ( new_smi -> io . irq ) { new_smi -> interrupt_disabled = false ; atomic_set ( & new_smi -> req_events , 1 ) ; } if ( new_smi -> pdev && ! new_smi -> pdev_registered ) { rv = platform_device_add ( new_smi -> pdev ) ; if ( rv ) { dev_err ( new_smi -> io . dev , "Unable<S2SV_blank>to<S2SV_blank>register<S2SV_blank>system<S2SV_blank>interface<S2SV_blank>device:<S2SV_blank>%d\\n" , rv ) ; goto out_err ; } new_smi -> pdev_registered = true ; } dev_set_drvdata ( new_smi -> io . dev , new_smi ) ; rv = device_add_group ( new_smi -> io . dev , & ipmi_si_dev_attr_group ) ; if ( rv ) { dev_err ( new_smi -> io . dev , "Unable<S2SV_blank>to<S2SV_blank>add<S2SV_blank>device<S2SV_blank>attributes:<S2SV_blank>error<S2SV_blank>%d\\n" , rv ) ; goto out_err ; } new_smi -> dev_group_added = true ; rv = ipmi_register_smi ( & handlers , new_smi , new_smi -> io . dev , new_smi -> io . slave_addr ) ; if ( rv ) { dev_err ( new_smi -> io . dev , "Unable<S2SV_blank>to<S2SV_blank>register<S2SV_blank>device:<S2SV_blank>error<S2SV_blank>%d\\n" , rv ) ; goto out_err ; } smi_num ++ ; dev_info ( new_smi -> io . dev , "IPMI<S2SV_blank>%s<S2SV_blank>interface<S2SV_blank>initialized\\n" , si_to_str [ new_smi -> io . si_type ] ) ; WARN_ON ( new_smi -> io . dev -> init_name != NULL ) ; out_err : <S2SV_StartBug> kfree ( init_name ) ; <S2SV_EndBug> return rv ; }
int auth_password ( Authctxt * authctxt , const char * password ) { struct passwd * pw = authctxt -> pw ; int result , ok = authctxt -> valid ; # if defined ( USE_SHADOW ) && defined ( HAS_SHADOW_EXPIRE ) static int expire_checked = 0 ; <S2SV_StartBug> # endif <S2SV_EndBug> # ifndef HAVE_CYGWIN if ( pw -> pw_uid == 0 && options . permit_root_login != PERMIT_YES ) ok = 0 ; # endif if ( * password == '\\0' && options . permit_empty_passwd == 0 ) return 0 ; # ifdef KRB5 if ( options . kerberos_authentication == 1 ) { int ret = auth_krb5_password ( authctxt , password ) ; if ( ret == 1 || ret == 0 ) return ret && ok ; } # endif # ifdef HAVE_CYGWIN { HANDLE hToken = cygwin_logon_user ( pw , password ) ; if ( hToken == INVALID_HANDLE_VALUE ) return 0 ; cygwin_set_impersonation_token ( hToken ) ; return ok ; } # endif # ifdef USE_PAM if ( options . use_pam ) return ( sshpam_auth_passwd ( authctxt , password ) && ok ) ; # endif # if defined ( USE_SHADOW ) && defined ( HAS_SHADOW_EXPIRE ) if ( ! expire_checked ) { expire_checked = 1 ; if ( auth_shadow_pwexpired ( authctxt ) ) authctxt -> force_pwchange = 1 ; } # endif result = sys_auth_passwd ( authctxt , password ) ; if ( authctxt -> force_pwchange ) disable_forwarding ( ) ; return ( result && ok ) ; }
int nfs3svc_decode_writeargs ( struct svc_rqst * rqstp , __be32 * p , struct nfsd3_writeargs * args ) { unsigned int len , v , hdr , dlen ; u32 max_blocksize = svc_max_payload ( rqstp ) ; struct kvec * head = rqstp -> rq_arg . head ; struct kvec * tail = rqstp -> rq_arg . tail ; p = decode_fh ( p , & args -> fh ) ; if ( ! p ) return 0 ; p = xdr_decode_hyper ( p , & args -> offset ) ; args -> count = ntohl ( * p ++ ) ; args -> stable = ntohl ( * p ++ ) ; <S2SV_StartBug> len = args -> len = ntohl ( * p ++ ) ; <S2SV_EndBug> if ( args -> count != args -> len ) return 0 ; hdr = ( void * ) p - head -> iov_base ; dlen = head -> iov_len + rqstp -> rq_arg . page_len + tail -> iov_len - hdr ; if ( dlen < XDR_QUADLEN ( len ) * 4 ) return 0 ; if ( args -> count > max_blocksize ) { args -> count = max_blocksize ; len = args -> len = max_blocksize ; } rqstp -> rq_vec [ 0 ] . iov_base = ( void * ) p ; rqstp -> rq_vec [ 0 ] . iov_len = head -> iov_len - hdr ; v = 0 ; while ( len > rqstp -> rq_vec [ v ] . iov_len ) { len -= rqstp -> rq_vec [ v ] . iov_len ; v ++ ; rqstp -> rq_vec [ v ] . iov_base = page_address ( rqstp -> rq_pages [ v ] ) ; rqstp -> rq_vec [ v ] . iov_len = PAGE_SIZE ; } rqstp -> rq_vec [ v ] . iov_len = len ; args -> vlen = v + 1 ; return 1 ; }
jas_image_t * bmp_decode ( jas_stream_t * in , char * optstr ) { jas_image_t * image ; bmp_hdr_t hdr ; bmp_info_t * info ; uint_fast16_t cmptno ; jas_image_cmptparm_t cmptparms [ 3 ] ; jas_image_cmptparm_t * cmptparm ; uint_fast16_t numcmpts ; long n ; if ( optstr ) { jas_eprintf ( "warning:<S2SV_blank>ignoring<S2SV_blank>BMP<S2SV_blank>decoder<S2SV_blank>options\\n" ) ; } jas_eprintf ( "THE<S2SV_blank>BMP<S2SV_blank>FORMAT<S2SV_blank>IS<S2SV_blank>NOT<S2SV_blank>FULLY<S2SV_blank>SUPPORTED!\\n" "THAT<S2SV_blank>IS,<S2SV_blank>THE<S2SV_blank>JASPER<S2SV_blank>SOFTWARE<S2SV_blank>CANNOT<S2SV_blank>DECODE<S2SV_blank>ALL<S2SV_blank>TYPES<S2SV_blank>OF<S2SV_blank>BMP<S2SV_blank>DATA.\\n" "IF<S2SV_blank>YOU<S2SV_blank>HAVE<S2SV_blank>ANY<S2SV_blank>PROBLEMS,<S2SV_blank>PLEASE<S2SV_blank>TRY<S2SV_blank>CONVERTING<S2SV_blank>YOUR<S2SV_blank>IMAGE<S2SV_blank>DATA\\n" "TO<S2SV_blank>THE<S2SV_blank>PNM<S2SV_blank>FORMAT,<S2SV_blank>AND<S2SV_blank>USING<S2SV_blank>THIS<S2SV_blank>FORMAT<S2SV_blank>INSTEAD.\\n" ) ; if ( bmp_gethdr ( in , & hdr ) ) { jas_eprintf ( "cannot<S2SV_blank>get<S2SV_blank>header\\n" ) ; return 0 ; } <S2SV_StartBug> if ( ! ( info = bmp_getinfo ( in ) ) ) { <S2SV_EndBug> jas_eprintf ( "cannot<S2SV_blank>get<S2SV_blank>info\\n" ) ; return 0 ; <S2SV_StartBug> } <S2SV_EndBug> if ( ! bmp_issupported ( & hdr , info ) ) { jas_eprintf ( "error:<S2SV_blank>unsupported<S2SV_blank>BMP<S2SV_blank>encoding\\n" ) ; bmp_info_destroy ( info ) ; return 0 ; } if ( ( n = hdr . off - ( BMP_HDRLEN + BMP_INFOLEN + BMP_PALLEN ( info ) ) ) < 0 ) { jas_eprintf ( "error:<S2SV_blank>possibly<S2SV_blank>bad<S2SV_blank>bitmap<S2SV_blank>offset?\\n" ) ; return 0 ; } if ( n > 0 ) { jas_eprintf ( "skipping<S2SV_blank>unknown<S2SV_blank>data<S2SV_blank>in<S2SV_blank>BMP<S2SV_blank>file\\n" ) ; if ( bmp_gobble ( in , n ) ) { bmp_info_destroy ( info ) ; return 0 ; } } numcmpts = bmp_numcmpts ( info ) ; for ( cmptno = 0 , cmptparm = cmptparms ; cmptno < numcmpts ; ++ cmptno , ++ cmptparm ) { cmptparm -> tlx = 0 ; cmptparm -> tly = 0 ; cmptparm -> hstep = 1 ; cmptparm -> vstep = 1 ; cmptparm -> width = info -> width ; cmptparm -> height = info -> height ; cmptparm -> prec = 8 ; cmptparm -> sgnd = false ; } if ( ! ( image = jas_image_create ( numcmpts , cmptparms , JAS_CLRSPC_UNKNOWN ) ) ) { bmp_info_destroy ( info ) ; return 0 ; } if ( numcmpts == 3 ) { jas_image_setclrspc ( image , JAS_CLRSPC_SRGB ) ; jas_image_setcmpttype ( image , 0 , JAS_IMAGE_CT_COLOR ( JAS_CLRSPC_CHANIND_RGB_R ) ) ; jas_image_setcmpttype ( image , 1 , JAS_IMAGE_CT_COLOR ( JAS_CLRSPC_CHANIND_RGB_G ) ) ; jas_image_setcmpttype ( image , 2 , JAS_IMAGE_CT_COLOR ( JAS_CLRSPC_CHANIND_RGB_B ) ) ; } else { jas_image_setclrspc ( image , JAS_CLRSPC_SGRAY ) ; jas_image_setcmpttype ( image , 0 , JAS_IMAGE_CT_COLOR ( JAS_CLRSPC_CHANIND_GRAY_Y ) ) ; } if ( bmp_getdata ( in , info , image ) ) { bmp_info_destroy ( info ) ; jas_image_destroy ( image ) ; return 0 ; } bmp_info_destroy ( info ) ; return image ; }
static void ip_optprint ( netdissect_options * ndo , register const u_char * cp , u_int length ) { register u_int option_len ; const char * sep = "" ; for ( ; length > 0 ; cp += option_len , length -= option_len ) { u_int option_code ; ND_PRINT ( ( ndo , "%s" , sep ) ) ; sep = "," ; ND_TCHECK ( * cp ) ; option_code = * cp ; ND_PRINT ( ( ndo , "%s" , tok2str ( ip_option_values , "unknown<S2SV_blank>%u" , option_code ) ) ) ; if ( option_code == IPOPT_NOP || option_code == IPOPT_EOL ) option_len = 1 ; else { ND_TCHECK ( cp [ 1 ] ) ; option_len = cp [ 1 ] ; if ( option_len < 2 ) { ND_PRINT ( ( ndo , "<S2SV_blank>[bad<S2SV_blank>length<S2SV_blank>%u]" , option_len ) ) ; return ; } } if ( option_len > length ) { ND_PRINT ( ( ndo , "<S2SV_blank>[bad<S2SV_blank>length<S2SV_blank>%u]" , option_len ) ) ; return ; } ND_TCHECK2 ( * cp , option_len ) ; switch ( option_code ) { case IPOPT_EOL : return ; case IPOPT_TS : <S2SV_StartBug> ip_printts ( ndo , cp , option_len ) ; <S2SV_EndBug> break ; case IPOPT_RR : case IPOPT_SSRR : case IPOPT_LSRR : if ( ip_printroute ( ndo , cp , option_len ) == - 1 ) goto trunc ; break ; <S2SV_StartBug> case IPOPT_RA : <S2SV_EndBug> if ( option_len < 4 ) { ND_PRINT ( ( ndo , "<S2SV_blank>[bad<S2SV_blank>length<S2SV_blank>%u]" , option_len ) ) ; break ; } ND_TCHECK ( cp [ 3 ] ) ; if ( EXTRACT_16BITS ( & cp [ 2 ] ) != 0 ) ND_PRINT ( ( ndo , "<S2SV_blank>value<S2SV_blank>%u" , EXTRACT_16BITS ( & cp [ 2 ] ) ) ) ; break ; case IPOPT_NOP : case IPOPT_SECURITY : default : break ; } } return ; trunc : ND_PRINT ( ( ndo , "%s" , tstr ) ) ; }
void WT_NoiseGenerator ( S_WT_VOICE * pWTVoice , S_WT_INT_FRAME * pWTIntFrame ) { EAS_PCM * pOutputBuffer ; EAS_I32 phaseInc ; EAS_I32 tmp0 ; EAS_I32 tmp1 ; EAS_I32 nInterpolatedSample ; EAS_I32 numSamples ; <S2SV_StartBug> numSamples = pWTIntFrame -> numSamples ; <S2SV_EndBug> pOutputBuffer = pWTIntFrame -> pAudioBuffer ; phaseInc = pWTIntFrame -> frame . phaseIncrement ; tmp0 = ( EAS_I32 ) ( pWTVoice -> phaseAccum ) >> 18 ; tmp1 = ( EAS_I32 ) ( pWTVoice -> loopEnd ) >> 18 ; while ( numSamples -- ) { nInterpolatedSample = MULT_AUDIO_COEF ( tmp0 , ( PHASE_ONE - pWTVoice -> phaseFrac ) ) ; nInterpolatedSample += MULT_AUDIO_COEF ( tmp1 , pWTVoice -> phaseFrac ) ; * pOutputBuffer ++ = ( EAS_PCM ) nInterpolatedSample ; pWTVoice -> phaseFrac += ( EAS_U32 ) phaseInc ; if ( GET_PHASE_INT_PART ( pWTVoice -> phaseFrac ) ) { tmp0 = tmp1 ; pWTVoice -> phaseAccum = pWTVoice -> loopEnd ; pWTVoice -> loopEnd = ( 5 * pWTVoice -> loopEnd + 1 ) ; tmp1 = ( EAS_I32 ) ( pWTVoice -> loopEnd ) >> 18 ; pWTVoice -> phaseFrac = GET_PHASE_FRAC_PART ( pWTVoice -> phaseFrac ) ; } } }
void __ip_select_ident ( struct iphdr * iph , int segs ) { static u32 ip_idents_hashrnd __read_mostly ; <S2SV_StartBug> u32 hash , id ; <S2SV_EndBug> <S2SV_StartBug> net_get_random_once ( & ip_idents_hashrnd , sizeof ( ip_idents_hashrnd ) ) ; <S2SV_EndBug> hash = jhash_3words ( ( __force u32 ) iph -> daddr , ( __force u32 ) iph -> saddr , <S2SV_StartBug> iph -> protocol , <S2SV_EndBug> ip_idents_hashrnd ) ; id = ip_idents_reserve ( hash , segs ) ; iph -> id = htons ( id ) ; }
static int iscsi_add_notunderstood_response ( char * key , char * value , struct iscsi_param_list * param_list ) { struct iscsi_extra_response * extra_response ; if ( strlen ( value ) > VALUE_MAXLEN ) { pr_err ( "Value<S2SV_blank>for<S2SV_blank>notunderstood<S2SV_blank>key<S2SV_blank>\\"%s\\"<S2SV_blank>exceeds<S2SV_blank>%d," "<S2SV_blank>protocol<S2SV_blank>error.\\n" , key , VALUE_MAXLEN ) ; return - 1 ; } extra_response = kzalloc ( sizeof ( struct iscsi_extra_response ) , GFP_KERNEL ) ; if ( ! extra_response ) { pr_err ( "Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for" "<S2SV_blank>struct<S2SV_blank>iscsi_extra_response.\\n" ) ; return - 1 ; } INIT_LIST_HEAD ( & extra_response -> er_list ) ; <S2SV_StartBug> strncpy ( extra_response -> key , key , strlen ( key ) + 1 ) ; <S2SV_EndBug> strncpy ( extra_response -> value , NOTUNDERSTOOD , <S2SV_StartBug> strlen ( NOTUNDERSTOOD ) + 1 ) ; <S2SV_EndBug> list_add_tail ( & extra_response -> er_list , & param_list -> extra_response_list ) ; return 0 ; }
<S2SV_StartBug> static int override_release ( char __user * release , int len ) <S2SV_EndBug> { <S2SV_StartBug> int ret = 0 ; <S2SV_EndBug> char buf [ 65 ] ; if ( current -> personality & UNAME26 ) { <S2SV_StartBug> char * rest = UTS_RELEASE ; <S2SV_EndBug> int ndots = 0 ; <S2SV_StartBug> unsigned v ; <S2SV_EndBug> while ( * rest ) { if ( * rest == '.' && ++ ndots >= 3 ) break ; if ( ! isdigit ( * rest ) && * rest != '.' ) break ; rest ++ ; } v = ( ( LINUX_VERSION_CODE >> 8 ) & 0xff ) + 40 ; <S2SV_StartBug> snprintf ( buf , len , "2.6.%u%s" , v , rest ) ; <S2SV_EndBug> <S2SV_StartBug> ret = copy_to_user ( release , buf , len ) ; <S2SV_EndBug> } return ret ; }
static int hns_gmac_get_sset_count ( int stringset ) { <S2SV_StartBug> if ( stringset == ETH_SS_STATS ) <S2SV_EndBug> return ARRAY_SIZE ( g_gmac_stats_string ) ; return 0 ; }
static void txfm_rd_in_plane ( MACROBLOCK * x , int * rate , int64_t * distortion , int * skippable , int64_t * sse , int64_t ref_best_rd , int plane , BLOCK_SIZE bsize , TX_SIZE tx_size , int use_fast_coef_casting ) { MACROBLOCKD * const xd = & x -> e_mbd ; const struct macroblockd_plane * const pd = & xd -> plane [ plane ] ; <S2SV_StartBug> struct rdcost_block_args args = { 0 } ; <S2SV_EndBug> args . x = x ; args . best_rd = ref_best_rd ; <S2SV_StartBug> args . use_fast_coef_costing = use_fast_coef_casting ; <S2SV_EndBug> if ( plane == 0 ) xd -> mi [ 0 ] -> mbmi . tx_size = tx_size ; vp9_get_entropy_contexts ( bsize , tx_size , pd , args . t_above , args . t_left ) ; args . so = get_scan ( xd , tx_size , pd -> plane_type , 0 ) ; vp9_foreach_transformed_block_in_plane ( xd , bsize , plane , block_rd_txfm , & args ) ; <S2SV_StartBug> if ( args . skip ) { <S2SV_EndBug> * rate = INT_MAX ; * distortion = INT64_MAX ; * sse = INT64_MAX ; * skippable = 0 ; } else { * distortion = args . this_dist ; * rate = args . this_rate ; * sse = args . this_sse ; <S2SV_StartBug> * skippable = vp9_is_skippable_in_plane ( x , bsize , plane ) ; <S2SV_EndBug> } }
static char * lxclock_name ( const char * p , const char * n ) { int ret ; int len ; char * dest ; char * rundir ; <S2SV_StartBug> len = strlen ( "/lock/lxc/" ) + strlen ( n ) + strlen ( p ) + 3 ; <S2SV_EndBug> rundir = get_rundir ( ) ; if ( ! rundir ) return NULL ; len += strlen ( rundir ) ; if ( ( dest = malloc ( len ) ) == NULL ) { free ( rundir ) ; return NULL ; } <S2SV_StartBug> ret = snprintf ( dest , len , "%s/lock/lxc/%s" , rundir , p ) ; <S2SV_EndBug> if ( ret < 0 || ret >= len ) { free ( dest ) ; free ( rundir ) ; return NULL ; } ret = mkdir_p ( dest , 0755 ) ; if ( ret < 0 ) { <S2SV_StartBug> int l2 = 22 + strlen ( n ) + strlen ( p ) ; <S2SV_EndBug> if ( l2 > len ) { char * d ; d = realloc ( dest , l2 ) ; if ( ! d ) { free ( dest ) ; free ( rundir ) ; return NULL ; } len = l2 ; dest = d ; } ret = snprintf ( dest , len , "/tmp/%d/lxc%s" , geteuid ( ) , p ) ; if ( ret < 0 || ret >= len ) { free ( dest ) ; <S2SV_StartBug> free ( rundir ) ; <S2SV_EndBug> return NULL ; } ret = mkdir_p ( dest , 0755 ) ; if ( ret < 0 ) { free ( dest ) ; free ( rundir ) ; return NULL ; } ret = snprintf ( dest , len , "/tmp/%d/lxc%s/.%s" , geteuid ( ) , p , n ) ; } else ret = snprintf ( dest , len , "%s/lock/lxc/%s/.%s" , rundir , p , n ) ; free ( rundir ) ; if ( ret < 0 || ret >= len ) { free ( dest ) ; return NULL ; } return dest ; }
static int udp_v6_push_pending_frames ( struct sock * sk ) { struct sk_buff * skb ; struct udphdr * uh ; struct udp_sock * up = udp_sk ( sk ) ; struct inet_sock * inet = inet_sk ( sk ) ; <S2SV_StartBug> struct flowi6 * fl6 = & inet -> cork . fl . u . ip6 ; <S2SV_EndBug> <S2SV_StartBug> int err = 0 ; <S2SV_EndBug> int is_udplite = IS_UDPLITE ( sk ) ; __wsum csum = 0 ; if ( ( skb = skb_peek ( & sk -> sk_write_queue ) ) == NULL ) goto out ; uh = udp_hdr ( skb ) ; uh -> source = fl6 -> fl6_sport ; uh -> dest = fl6 -> fl6_dport ; uh -> len = htons ( up -> len ) ; uh -> check = 0 ; if ( is_udplite ) csum = udplite_csum_outgoing ( sk , skb ) ; else if ( skb -> ip_summed == CHECKSUM_PARTIAL ) { udp6_hwcsum_outgoing ( sk , skb , & fl6 -> saddr , & fl6 -> daddr , up -> len ) ; goto send ; } else csum = udp_csum_outgoing ( sk , skb ) ; uh -> check = csum_ipv6_magic ( & fl6 -> saddr , & fl6 -> daddr , up -> len , fl6 -> flowi6_proto , csum ) ; if ( uh -> check == 0 ) uh -> check = CSUM_MANGLED_0 ; send : err = ip6_push_pending_frames ( sk ) ; if ( err ) { if ( err == - ENOBUFS && ! inet6_sk ( sk ) -> recverr ) { UDP6_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_SNDBUFERRORS , is_udplite ) ; err = 0 ; } } else UDP6_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_OUTDATAGRAMS , is_udplite ) ; out : up -> len = 0 ; up -> pending = 0 ; return err ; }
static int aiptek_probe ( struct usb_interface * intf , const struct usb_device_id * id ) { struct usb_device * usbdev = interface_to_usbdev ( intf ) ; struct usb_endpoint_descriptor * endpoint ; struct aiptek * aiptek ; struct input_dev * inputdev ; int i ; int speeds [ ] = { 0 , AIPTEK_PROGRAMMABLE_DELAY_50 , AIPTEK_PROGRAMMABLE_DELAY_400 , AIPTEK_PROGRAMMABLE_DELAY_25 , AIPTEK_PROGRAMMABLE_DELAY_100 , AIPTEK_PROGRAMMABLE_DELAY_200 , AIPTEK_PROGRAMMABLE_DELAY_300 } ; int err = - ENOMEM ; speeds [ 0 ] = programmableDelay ; aiptek = kzalloc ( sizeof ( struct aiptek ) , GFP_KERNEL ) ; inputdev = input_allocate_device ( ) ; if ( ! aiptek || ! inputdev ) { dev_warn ( & intf -> dev , "cannot<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>or<S2SV_blank>input<S2SV_blank>device\\n" ) ; goto fail1 ; } aiptek -> data = usb_alloc_coherent ( usbdev , AIPTEK_PACKET_LENGTH , GFP_ATOMIC , & aiptek -> data_dma ) ; if ( ! aiptek -> data ) { dev_warn ( & intf -> dev , "cannot<S2SV_blank>allocate<S2SV_blank>usb<S2SV_blank>buffer\\n" ) ; goto fail1 ; } aiptek -> urb = usb_alloc_urb ( 0 , GFP_KERNEL ) ; if ( ! aiptek -> urb ) { dev_warn ( & intf -> dev , "cannot<S2SV_blank>allocate<S2SV_blank>urb\\n" ) ; goto fail2 ; } aiptek -> inputdev = inputdev ; aiptek -> usbdev = usbdev ; aiptek -> intf = intf ; aiptek -> ifnum = intf -> altsetting [ 0 ] . desc . bInterfaceNumber ; aiptek -> inDelay = 0 ; aiptek -> endDelay = 0 ; aiptek -> previousJitterable = 0 ; aiptek -> lastMacro = - 1 ; aiptek -> curSetting . pointerMode = AIPTEK_POINTER_EITHER_MODE ; aiptek -> curSetting . coordinateMode = AIPTEK_COORDINATE_ABSOLUTE_MODE ; aiptek -> curSetting . toolMode = AIPTEK_TOOL_BUTTON_PEN_MODE ; aiptek -> curSetting . xTilt = AIPTEK_TILT_DISABLE ; aiptek -> curSetting . yTilt = AIPTEK_TILT_DISABLE ; aiptek -> curSetting . mouseButtonLeft = AIPTEK_MOUSE_LEFT_BUTTON ; aiptek -> curSetting . mouseButtonMiddle = AIPTEK_MOUSE_MIDDLE_BUTTON ; aiptek -> curSetting . mouseButtonRight = AIPTEK_MOUSE_RIGHT_BUTTON ; aiptek -> curSetting . stylusButtonUpper = AIPTEK_STYLUS_UPPER_BUTTON ; aiptek -> curSetting . stylusButtonLower = AIPTEK_STYLUS_LOWER_BUTTON ; aiptek -> curSetting . jitterDelay = jitterDelay ; aiptek -> curSetting . programmableDelay = programmableDelay ; aiptek -> newSetting = aiptek -> curSetting ; usb_make_path ( usbdev , aiptek -> features . usbPath , sizeof ( aiptek -> features . usbPath ) ) ; strlcat ( aiptek -> features . usbPath , "/input0" , sizeof ( aiptek -> features . usbPath ) ) ; inputdev -> name = "Aiptek" ; inputdev -> phys = aiptek -> features . usbPath ; usb_to_input_id ( usbdev , & inputdev -> id ) ; inputdev -> dev . parent = & intf -> dev ; input_set_drvdata ( inputdev , aiptek ) ; inputdev -> open = aiptek_open ; inputdev -> close = aiptek_close ; for ( i = 0 ; i < ARRAY_SIZE ( eventTypes ) ; ++ i ) __set_bit ( eventTypes [ i ] , inputdev -> evbit ) ; for ( i = 0 ; i < ARRAY_SIZE ( absEvents ) ; ++ i ) __set_bit ( absEvents [ i ] , inputdev -> absbit ) ; for ( i = 0 ; i < ARRAY_SIZE ( relEvents ) ; ++ i ) __set_bit ( relEvents [ i ] , inputdev -> relbit ) ; __set_bit ( MSC_SERIAL , inputdev -> mscbit ) ; for ( i = 0 ; i < ARRAY_SIZE ( buttonEvents ) ; ++ i ) __set_bit ( buttonEvents [ i ] , inputdev -> keybit ) ; for ( i = 0 ; i < ARRAY_SIZE ( macroKeyEvents ) ; ++ i ) __set_bit ( macroKeyEvents [ i ] , inputdev -> keybit ) ; input_set_abs_params ( inputdev , ABS_X , 0 , 2999 , 0 , 0 ) ; input_set_abs_params ( inputdev , ABS_Y , 0 , 2249 , 0 , 0 ) ; input_set_abs_params ( inputdev , ABS_PRESSURE , 0 , 511 , 0 , 0 ) ; input_set_abs_params ( inputdev , ABS_TILT_X , AIPTEK_TILT_MIN , AIPTEK_TILT_MAX , 0 , 0 ) ; input_set_abs_params ( inputdev , ABS_TILT_Y , AIPTEK_TILT_MIN , AIPTEK_TILT_MAX , 0 , 0 ) ; input_set_abs_params ( inputdev , ABS_WHEEL , AIPTEK_WHEEL_MIN , AIPTEK_WHEEL_MAX - 1 , 0 , 0 ) ; <S2SV_StartBug> endpoint = & intf -> altsetting [ 0 ] . endpoint [ 0 ] . desc ; <S2SV_EndBug> usb_fill_int_urb ( aiptek -> urb , aiptek -> usbdev , usb_rcvintpipe ( aiptek -> usbdev , endpoint -> bEndpointAddress ) , aiptek -> data , 8 , aiptek_irq , aiptek , endpoint -> bInterval ) ; aiptek -> urb -> transfer_dma = aiptek -> data_dma ; aiptek -> urb -> transfer_flags |= URB_NO_TRANSFER_DMA_MAP ; for ( i = 0 ; i < ARRAY_SIZE ( speeds ) ; ++ i ) { aiptek -> curSetting . programmableDelay = speeds [ i ] ; ( void ) aiptek_program_tablet ( aiptek ) ; if ( input_abs_get_max ( aiptek -> inputdev , ABS_X ) > 0 ) { dev_info ( & intf -> dev , "Aiptek<S2SV_blank>using<S2SV_blank>%d<S2SV_blank>ms<S2SV_blank>programming<S2SV_blank>speed\\n" , aiptek -> curSetting . programmableDelay ) ; break ; } } if ( i == ARRAY_SIZE ( speeds ) ) { dev_info ( & intf -> dev , "Aiptek<S2SV_blank>tried<S2SV_blank>all<S2SV_blank>speeds,<S2SV_blank>no<S2SV_blank>sane<S2SV_blank>response\\n" ) ; <S2SV_StartBug> goto fail3 ; <S2SV_EndBug> } usb_set_intfdata ( intf , aiptek ) ; err = sysfs_create_group ( & intf -> dev . kobj , & aiptek_attribute_group ) ; if ( err ) { dev_warn ( & intf -> dev , "cannot<S2SV_blank>create<S2SV_blank>sysfs<S2SV_blank>group<S2SV_blank>err:<S2SV_blank>%d\\n" , err ) ; goto fail3 ; } err = input_register_device ( aiptek -> inputdev ) ; if ( err ) { dev_warn ( & intf -> dev , "input_register_device<S2SV_blank>returned<S2SV_blank>err:<S2SV_blank>%d\\n" , err ) ; goto fail4 ; } return 0 ; fail4 : sysfs_remove_group ( & intf -> dev . kobj , & aiptek_attribute_group ) ; fail3 : usb_free_urb ( aiptek -> urb ) ; fail2 : usb_free_coherent ( usbdev , AIPTEK_PACKET_LENGTH , aiptek -> data , aiptek -> data_dma ) ; fail1 : usb_set_intfdata ( intf , NULL ) ; input_free_device ( inputdev ) ; kfree ( aiptek ) ; return err ; }
GF_Err audio_sample_entry_Read ( GF_Box * s , GF_BitStream * bs ) { GF_MPEGAudioSampleEntryBox * ptr ; char * data ; u8 a , b , c , d ; u32 i , size , v , nb_alnum ; GF_Err e ; u64 pos , start ; ptr = ( GF_MPEGAudioSampleEntryBox * ) s ; start = gf_bs_get_position ( bs ) ; gf_bs_seek ( bs , start + 8 ) ; v = gf_bs_read_u16 ( bs ) ; if ( v ) ptr -> is_qtff = 1 ; if ( v == 1 ) { gf_bs_seek ( bs , start + 8 + 20 + 4 ) ; a = gf_bs_read_u8 ( bs ) ; b = gf_bs_read_u8 ( bs ) ; c = gf_bs_read_u8 ( bs ) ; d = gf_bs_read_u8 ( bs ) ; nb_alnum = 0 ; if ( isalnum ( a ) ) nb_alnum ++ ; if ( isalnum ( b ) ) nb_alnum ++ ; if ( isalnum ( c ) ) nb_alnum ++ ; if ( isalnum ( d ) ) nb_alnum ++ ; if ( nb_alnum > 2 ) ptr -> is_qtff = 0 ; } gf_bs_seek ( bs , start ) ; e = gf_isom_audio_sample_entry_read ( ( GF_AudioSampleEntryBox * ) s , bs ) ; if ( e ) return e ; pos = gf_bs_get_position ( bs ) ; size = ( u32 ) s -> size ; if ( gf_bs_get_cookie ( bs ) ) { ptr -> is_qtff |= 1 << 16 ; } e = gf_isom_box_array_read ( s , bs , audio_sample_entry_AddBox ) ; if ( ! e ) return GF_OK ; if ( size < 8 ) return GF_ISOM_INVALID_FILE ; gf_bs_seek ( bs , pos ) ; data = ( char * ) gf_malloc ( sizeof ( char ) * size ) ; gf_bs_read_data ( bs , data , size ) ; for ( i = 0 ; i < size - 8 ; i ++ ) { if ( GF_4CC ( ( u32 ) data [ i + 4 ] , ( u8 ) data [ i + 5 ] , ( u8 ) data [ i + 6 ] , ( u8 ) data [ i + 7 ] ) == GF_ISOM_BOX_TYPE_ESDS ) { <S2SV_StartBug> GF_BitStream * mybs = gf_bs_new ( data + i , size - i , GF_BITSTREAM_READ ) ; <S2SV_EndBug> if ( ptr -> esd ) { <S2SV_StartBug> gf_isom_box_del ( ( GF_Box * ) ptr -> esd ) ; <S2SV_EndBug> ptr -> esd = NULL ; } e = gf_isom_box_parse ( ( GF_Box * * ) & ptr -> esd , mybs ) ; if ( e == GF_OK ) { gf_isom_box_add_for_dump_mode ( ( GF_Box * ) ptr , ( GF_Box * ) ptr -> esd ) ; } else if ( ptr -> esd ) { gf_isom_box_del ( ( GF_Box * ) ptr -> esd ) ; ptr -> esd = NULL ; } gf_bs_del ( mybs ) ; break ; } } gf_free ( data ) ; return e ; }
static EAS_RESULT PushcdlStack ( EAS_U32 * pStack , EAS_INT * pStackPtr , EAS_U32 value ) { <S2SV_StartBug> if ( * pStackPtr >= CDL_STACK_SIZE ) <S2SV_EndBug> <S2SV_StartBug> return EAS_ERROR_FILE_FORMAT ; <S2SV_EndBug> * pStackPtr = * pStackPtr + 1 ; pStack [ * pStackPtr ] = value ; return EAS_SUCCESS ; }
static void xen_netbk_tx_submit ( struct xen_netbk * netbk ) { struct gnttab_copy * gop = netbk -> tx_copy_ops ; struct sk_buff * skb ; while ( ( skb = __skb_dequeue ( & netbk -> tx_queue ) ) != NULL ) { struct xen_netif_tx_request * txp ; struct xenvif * vif ; u16 pending_idx ; unsigned data_len ; pending_idx = * ( ( u16 * ) skb -> data ) ; vif = netbk -> pending_tx_info [ pending_idx ] . vif ; txp = & netbk -> pending_tx_info [ pending_idx ] . req ; if ( unlikely ( xen_netbk_tx_check_gop ( netbk , skb , & gop ) ) ) { netdev_dbg ( vif -> dev , "netback<S2SV_blank>grant<S2SV_blank>failed.\\n" ) ; skb_shinfo ( skb ) -> nr_frags = 0 ; kfree_skb ( skb ) ; continue ; } data_len = skb -> len ; memcpy ( skb -> data , ( void * ) ( idx_to_kaddr ( netbk , pending_idx ) | txp -> offset ) , data_len ) ; if ( data_len < txp -> size ) { txp -> offset += data_len ; txp -> size -= data_len ; } else { <S2SV_StartBug> xen_netbk_idx_release ( netbk , pending_idx ) ; <S2SV_EndBug> } if ( txp -> flags & XEN_NETTXF_csum_blank ) skb -> ip_summed = CHECKSUM_PARTIAL ; else if ( txp -> flags & XEN_NETTXF_data_validated ) skb -> ip_summed = CHECKSUM_UNNECESSARY ; xen_netbk_fill_frags ( netbk , skb ) ; if ( skb_headlen ( skb ) < PKT_PROT_LEN && skb_is_nonlinear ( skb ) ) { int target = min_t ( int , skb -> len , PKT_PROT_LEN ) ; __pskb_pull_tail ( skb , target - skb_headlen ( skb ) ) ; } skb -> dev = vif -> dev ; skb -> protocol = eth_type_trans ( skb , skb -> dev ) ; if ( checksum_setup ( vif , skb ) ) { netdev_dbg ( vif -> dev , "Can\'t<S2SV_blank>setup<S2SV_blank>checksum<S2SV_blank>in<S2SV_blank>net_tx_action\\n" ) ; kfree_skb ( skb ) ; continue ; } vif -> dev -> stats . rx_bytes += skb -> len ; vif -> dev -> stats . rx_packets ++ ; xenvif_receive_skb ( vif , skb ) ; } }
static int process_line ( URLContext * h , char * line , int line_count , int * new_location ) { HTTPContext * s = h -> priv_data ; const char * auto_method = h -> flags & AVIO_FLAG_READ ? "POST" : "GET" ; char * tag , * p , * end , * method , * resource , * version ; int ret ; if ( line [ 0 ] == '\\0' ) { s -> end_header = 1 ; return 0 ; } p = line ; if ( line_count == 0 ) { if ( s -> is_connected_server ) { method = p ; while ( * p && ! av_isspace ( * p ) ) p ++ ; * ( p ++ ) = '\\0' ; av_log ( h , AV_LOG_TRACE , "Received<S2SV_blank>method:<S2SV_blank>%s\\n" , method ) ; if ( s -> method ) { if ( av_strcasecmp ( s -> method , method ) ) { av_log ( h , AV_LOG_ERROR , "Received<S2SV_blank>and<S2SV_blank>expected<S2SV_blank>HTTP<S2SV_blank>method<S2SV_blank>do<S2SV_blank>not<S2SV_blank>match.<S2SV_blank>(%s<S2SV_blank>expected,<S2SV_blank>%s<S2SV_blank>received)\\n" , s -> method , method ) ; return ff_http_averror ( 400 , AVERROR ( EIO ) ) ; } } else { av_log ( h , AV_LOG_TRACE , "Autodetected<S2SV_blank>%s<S2SV_blank>HTTP<S2SV_blank>method\\n" , auto_method ) ; if ( av_strcasecmp ( auto_method , method ) ) { av_log ( h , AV_LOG_ERROR , "Received<S2SV_blank>and<S2SV_blank>autodetected<S2SV_blank>HTTP<S2SV_blank>method<S2SV_blank>did<S2SV_blank>not<S2SV_blank>match<S2SV_blank>" "(%s<S2SV_blank>autodetected<S2SV_blank>%s<S2SV_blank>received)\\n" , auto_method , method ) ; return ff_http_averror ( 400 , AVERROR ( EIO ) ) ; } if ( ! ( s -> method = av_strdup ( method ) ) ) return AVERROR ( ENOMEM ) ; } while ( av_isspace ( * p ) ) p ++ ; resource = p ; while ( ! av_isspace ( * p ) ) p ++ ; * ( p ++ ) = '\\0' ; av_log ( h , AV_LOG_TRACE , "Requested<S2SV_blank>resource:<S2SV_blank>%s\\n" , resource ) ; if ( ! ( s -> resource = av_strdup ( resource ) ) ) return AVERROR ( ENOMEM ) ; while ( av_isspace ( * p ) ) p ++ ; version = p ; while ( * p && ! av_isspace ( * p ) ) p ++ ; * p = '\\0' ; if ( av_strncasecmp ( version , "HTTP/" , 5 ) ) { av_log ( h , AV_LOG_ERROR , "Malformed<S2SV_blank>HTTP<S2SV_blank>version<S2SV_blank>string.\\n" ) ; return ff_http_averror ( 400 , AVERROR ( EIO ) ) ; } av_log ( h , AV_LOG_TRACE , "HTTP<S2SV_blank>version<S2SV_blank>string:<S2SV_blank>%s\\n" , version ) ; } else { while ( ! av_isspace ( * p ) && * p != '\\0' ) p ++ ; while ( av_isspace ( * p ) ) p ++ ; s -> http_code = strtol ( p , & end , 10 ) ; av_log ( h , AV_LOG_TRACE , "http_code=%d\\n" , s -> http_code ) ; if ( ( ret = check_http_code ( h , s -> http_code , end ) ) < 0 ) return ret ; } } else { while ( * p != '\\0' && * p != ':' ) p ++ ; if ( * p != ':' ) return 1 ; * p = '\\0' ; tag = line ; p ++ ; while ( av_isspace ( * p ) ) p ++ ; if ( ! av_strcasecmp ( tag , "Location" ) ) { if ( ( ret = parse_location ( s , p ) ) < 0 ) return ret ; * new_location = 1 ; <S2SV_StartBug> } else if ( ! av_strcasecmp ( tag , "Content-Length" ) && s -> filesize == - 1 ) { <S2SV_EndBug> <S2SV_StartBug> s -> filesize = strtoll ( p , NULL , 10 ) ; <S2SV_EndBug> } else if ( ! av_strcasecmp ( tag , "Content-Range" ) ) { parse_content_range ( h , p ) ; } else if ( ! av_strcasecmp ( tag , "Accept-Ranges" ) && ! strncmp ( p , "bytes" , 5 ) && s -> seekable == - 1 ) { h -> is_streamed = 0 ; } else if ( ! av_strcasecmp ( tag , "Transfer-Encoding" ) && ! av_strncasecmp ( p , "chunked" , 7 ) ) { <S2SV_StartBug> s -> filesize = - 1 ; <S2SV_EndBug> s -> chunksize = 0 ; } else if ( ! av_strcasecmp ( tag , "WWW-Authenticate" ) ) { <S2SV_StartBug> ff_http_auth_handle_header ( & s -> auth_state , tag , p ) ; <S2SV_EndBug> } else if ( ! av_strcasecmp ( tag , "Authentication-Info" ) ) { ff_http_auth_handle_header ( & s -> auth_state , tag , p ) ; } else if ( ! av_strcasecmp ( tag , "Proxy-Authenticate" ) ) { ff_http_auth_handle_header ( & s -> proxy_auth_state , tag , p ) ; } else if ( ! av_strcasecmp ( tag , "Connection" ) ) { if ( ! strcmp ( p , "close" ) ) s -> willclose = 1 ; } else if ( ! av_strcasecmp ( tag , "Server" ) ) { if ( ! av_strcasecmp ( p , "AkamaiGHost" ) ) { s -> is_akamai = 1 ; } else if ( ! av_strncasecmp ( p , "MediaGateway" , 12 ) ) { s -> is_mediagateway = 1 ; } } else if ( ! av_strcasecmp ( tag , "Content-Type" ) ) { av_free ( s -> mime_type ) ; s -> mime_type = av_strdup ( p ) ; } else if ( ! av_strcasecmp ( tag , "Set-Cookie" ) ) { if ( parse_cookie ( s , p , & s -> cookie_dict ) ) av_log ( h , AV_LOG_WARNING , "Unable<S2SV_blank>to<S2SV_blank>parse<S2SV_blank>\'%s\'\\n" , p ) ; } else if ( ! av_strcasecmp ( tag , "Icy-MetaInt" ) ) { <S2SV_StartBug> s -> icy_metaint = strtoll ( p , NULL , 10 ) ; <S2SV_EndBug> } else if ( ! av_strncasecmp ( tag , "Icy-" , 4 ) ) { if ( ( ret = parse_icy ( s , tag , p ) ) < 0 ) return ret ; } else if ( ! av_strcasecmp ( tag , "Content-Encoding" ) ) { if ( ( ret = parse_content_encoding ( h , p ) ) < 0 ) return ret ; } } return 1 ; }
int nntp_open_connection ( struct NntpAccountData * adata ) { struct Connection * conn = adata -> conn ; char buf [ 256 ] ; int cap ; bool posting = false , auth = true ; if ( adata -> status == NNTP_OK ) return 0 ; if ( adata -> status == NNTP_BYE ) return - 1 ; adata -> status = NNTP_NONE ; if ( mutt_socket_open ( conn ) < 0 ) return - 1 ; if ( mutt_socket_readln ( buf , sizeof ( buf ) , conn ) < 0 ) return nntp_connect_error ( adata ) ; if ( mutt_str_startswith ( buf , "200" , CASE_MATCH ) ) posting = true ; else if ( ! mutt_str_startswith ( buf , "201" , CASE_MATCH ) ) { mutt_socket_close ( conn ) ; mutt_str_remove_trailing_ws ( buf ) ; mutt_error ( "%s" , buf ) ; return - 1 ; } cap = nntp_capabilities ( adata ) ; if ( cap < 0 ) return - 1 ; if ( cap > 0 ) { if ( ( mutt_socket_send ( conn , "MODE<S2SV_blank>READER\\r\\n" ) < 0 ) || ( mutt_socket_readln ( buf , sizeof ( buf ) , conn ) < 0 ) ) { return nntp_connect_error ( adata ) ; } if ( mutt_str_startswith ( buf , "200" , CASE_MATCH ) ) posting = true ; else if ( mutt_str_startswith ( buf , "201" , CASE_MATCH ) ) posting = false ; else if ( adata -> hasCAPABILITIES ) { mutt_socket_close ( conn ) ; mutt_error ( _ ( "Could<S2SV_blank>not<S2SV_blank>switch<S2SV_blank>to<S2SV_blank>reader<S2SV_blank>mode" ) ) ; return - 1 ; } if ( adata -> hasCAPABILITIES ) { cap = nntp_capabilities ( adata ) ; if ( cap < 0 ) return - 1 ; } } mutt_message ( _ ( "Connected<S2SV_blank>to<S2SV_blank>%s.<S2SV_blank>%s" ) , conn -> account . host , posting ? _ ( "Posting<S2SV_blank>is<S2SV_blank>ok" ) : _ ( "Posting<S2SV_blank>is<S2SV_blank>NOT<S2SV_blank>ok" ) ) ; mutt_sleep ( 1 ) ; # ifdef USE_SSL if ( ( adata -> use_tls != 1 ) && ( adata -> hasSTARTTLS || C_SslForceTls ) ) { if ( adata -> use_tls == 0 ) { adata -> use_tls = C_SslForceTls || query_quadoption ( C_SslStarttls , _ ( "Secure<S2SV_blank>connection<S2SV_blank>with<S2SV_blank>TLS?" ) ) == MUTT_YES ? 2 : 1 ; } if ( adata -> use_tls == 2 ) { if ( ( mutt_socket_send ( conn , "STARTTLS\\r\\n" ) < 0 ) || ( mutt_socket_readln ( buf , sizeof ( buf ) , conn ) < 0 ) ) { return nntp_connect_error ( adata ) ; <S2SV_StartBug> } <S2SV_EndBug> if ( ! mutt_str_startswith ( buf , "382" , CASE_MATCH ) ) { adata -> use_tls = 0 ; mutt_error ( "STARTTLS:<S2SV_blank>%s" , buf ) ; } else if ( mutt_ssl_starttls ( conn ) ) { adata -> use_tls = 0 ; adata -> status = NNTP_NONE ; mutt_socket_close ( adata -> conn ) ; mutt_error ( _ ( "Could<S2SV_blank>not<S2SV_blank>negotiate<S2SV_blank>TLS<S2SV_blank>connection" ) ) ; return - 1 ; } else { cap = nntp_capabilities ( adata ) ; if ( cap < 0 ) return - 1 ; } } } # endif if ( conn -> account . flags & MUTT_ACCT_USER ) { if ( ! conn -> account . user [ 0 ] ) auth = false ; } else { if ( ( mutt_socket_send ( conn , "STAT\\r\\n" ) < 0 ) || ( mutt_socket_readln ( buf , sizeof ( buf ) , conn ) < 0 ) ) { return nntp_connect_error ( adata ) ; } if ( ! mutt_str_startswith ( buf , "480" , CASE_MATCH ) ) auth = false ; } if ( auth && ( nntp_auth ( adata ) < 0 ) ) return - 1 ; if ( adata -> hasCAPABILITIES && ( auth || ( cap > 0 ) ) ) { cap = nntp_capabilities ( adata ) ; if ( cap < 0 ) return - 1 ; if ( cap > 0 ) { mutt_socket_close ( conn ) ; mutt_error ( _ ( "Could<S2SV_blank>not<S2SV_blank>switch<S2SV_blank>to<S2SV_blank>reader<S2SV_blank>mode" ) ) ; return - 1 ; } } if ( nntp_attempt_features ( adata ) < 0 ) return - 1 ; adata -> status = NNTP_OK ; return 0 ; }
void ArrowHead ( ) { int k ; double length ; SaveGraphicsState ; if ( flip ) length = - arrow . length ; else length = arrow . length ; SetDashSize ( 0 , 0 ) ; if ( arrow . stroke ) { SetLineWidth ( arrow . stroke ) ; for ( k = 1 ; k <= 2 ; k ++ ) { SaveGraphicsState ; MoveTo ( length * 0.5 , 0 ) ; LineTo ( - length * 0.5 , arrow . width ) ; LineTo ( - length * 0.5 + length * arrow . inset , 0 ) ; LineTo ( - length * 0.5 , - arrow . width ) ; if ( k == 1 ) { SetBackgroundColor ( NONSTROKING ) ; <S2SV_StartBug> outpos += sprintf ( outpos , "<S2SV_blank>h<S2SV_blank>f" ) ; <S2SV_EndBug> } else { <S2SV_StartBug> outpos += sprintf ( outpos , "<S2SV_blank>s" ) ; <S2SV_EndBug> } RestoreGraphicsState ; } } else { MoveTo ( length * 0.5 , 0 ) ; LineTo ( - length * 0.5 , arrow . width ) ; LineTo ( - length * 0.5 + length * arrow . inset , 0 ) ; LineTo ( - length * 0.5 , - arrow . width ) ; <S2SV_StartBug> outpos += sprintf ( outpos , "<S2SV_blank>h<S2SV_blank>f" ) ; <S2SV_EndBug> } RestoreGraphicsState ; }
void WT_VoiceGain ( S_WT_VOICE * pWTVoice , S_WT_INT_FRAME * pWTIntFrame ) { EAS_I32 * pMixBuffer ; EAS_PCM * pInputBuffer ; EAS_I32 gain ; EAS_I32 gainIncrement ; EAS_I32 tmp0 ; EAS_I32 tmp1 ; EAS_I32 tmp2 ; EAS_I32 numSamples ; # if ( NUM_OUTPUT_CHANNELS == 2 ) EAS_I32 gainLeft , gainRight ; # endif <S2SV_StartBug> numSamples = pWTIntFrame -> numSamples ; <S2SV_EndBug> pMixBuffer = pWTIntFrame -> pMixBuffer ; pInputBuffer = pWTIntFrame -> pAudioBuffer ; gainIncrement = ( pWTIntFrame -> frame . gainTarget - pWTIntFrame -> prevGain ) << ( 16 - SYNTH_UPDATE_PERIOD_IN_BITS ) ; if ( gainIncrement < 0 ) gainIncrement ++ ; gain = pWTIntFrame -> prevGain << 16 ; # if ( NUM_OUTPUT_CHANNELS == 2 ) gainLeft = pWTVoice -> gainLeft ; gainRight = pWTVoice -> gainRight ; # endif while ( numSamples -- ) { tmp0 = * pInputBuffer ++ ; gain += gainIncrement ; tmp2 = gain >> 16 ; tmp2 *= tmp0 ; # if ( NUM_OUTPUT_CHANNELS == 2 ) tmp2 = tmp2 >> 14 ; tmp1 = * pMixBuffer ; tmp0 = tmp2 * gainLeft ; tmp0 = tmp0 >> NUM_MIXER_GUARD_BITS ; tmp1 += tmp0 ; * pMixBuffer ++ = tmp1 ; tmp1 = * pMixBuffer ; tmp0 = tmp2 * gainRight ; tmp0 = tmp0 >> NUM_MIXER_GUARD_BITS ; tmp1 += tmp0 ; * pMixBuffer ++ = tmp1 ; # else tmp1 = * pMixBuffer ; tmp2 = tmp2 >> ( NUM_MIXER_GUARD_BITS - 1 ) ; tmp1 += tmp2 ; * pMixBuffer ++ = tmp1 ; # endif } }
void comps_rtree_unite ( COMPS_RTree * rt1 , COMPS_RTree * rt2 ) { COMPS_HSList * tmplist , * tmp_subnodes ; COMPS_HSListItem * it ; struct Pair { COMPS_HSList * subnodes ; char * key ; <S2SV_StartBug> char added ; <S2SV_EndBug> } * pair , * parent_pair ; pair = malloc ( sizeof ( struct Pair ) ) ; pair -> subnodes = rt2 -> subnodes ; pair -> key = NULL ; tmplist = comps_hslist_create ( ) ; comps_hslist_init ( tmplist , NULL , NULL , & free ) ; comps_hslist_append ( tmplist , pair , 0 ) ; while ( tmplist -> first != NULL ) { it = tmplist -> first ; comps_hslist_remove ( tmplist , tmplist -> first ) ; tmp_subnodes = ( ( struct Pair * ) it -> data ) -> subnodes ; parent_pair = ( struct Pair * ) it -> data ; free ( it ) ; for ( it = tmp_subnodes -> first ; it != NULL ; it = it -> next ) { pair = malloc ( sizeof ( struct Pair ) ) ; pair -> subnodes = ( ( COMPS_RTreeData * ) it -> data ) -> subnodes ; if ( parent_pair -> key != NULL ) { pair -> key = malloc ( sizeof ( char ) * ( strlen ( ( ( COMPS_RTreeData * ) it -> data ) -> key ) + strlen ( parent_pair -> key ) + 1 ) ) ; memcpy ( pair -> key , parent_pair -> key , sizeof ( char ) * strlen ( parent_pair -> key ) ) ; memcpy ( pair -> key + strlen ( parent_pair -> key ) , ( ( COMPS_RTreeData * ) it -> data ) -> key , sizeof ( char ) * ( strlen ( ( ( COMPS_RTreeData * ) it -> data ) -> key ) + 1 ) ) ; } else { pair -> key = malloc ( sizeof ( char ) * ( strlen ( ( ( COMPS_RTreeData * ) it -> data ) -> key ) + 1 ) ) ; memcpy ( pair -> key , ( ( COMPS_RTreeData * ) it -> data ) -> key , sizeof ( char ) * ( strlen ( ( ( COMPS_RTreeData * ) it -> data ) -> key ) + 1 ) ) ; } if ( ( ( COMPS_RTreeData * ) it -> data ) -> data != NULL ) { comps_rtree_set ( rt1 , pair -> key , rt2 -> data_cloner ( ( ( COMPS_RTreeData * ) it -> data ) -> data ) ) ; } if ( ( ( COMPS_RTreeData * ) it -> data ) -> subnodes -> first ) { comps_hslist_append ( tmplist , pair , 0 ) ; } else { free ( pair -> key ) ; free ( pair ) ; } } free ( parent_pair -> key ) ; free ( parent_pair ) ; } comps_hslist_destroy ( & tmplist ) ; }
void dvb_usbv2_disconnect ( struct usb_interface * intf ) { struct dvb_usb_device * d = usb_get_intfdata ( intf ) ; <S2SV_StartBug> const char * name = d -> name ; <S2SV_EndBug> <S2SV_StartBug> struct device dev = d -> udev -> dev ; <S2SV_EndBug> dev_dbg ( & d -> udev -> dev , "%s:<S2SV_blank>bInterfaceNumber=%d\\n" , __func__ , intf -> cur_altsetting -> desc . bInterfaceNumber ) ; if ( d -> props -> exit ) d -> props -> exit ( d ) ; dvb_usbv2_exit ( d ) ; <S2SV_StartBug> dev_info ( & dev , "%s:<S2SV_blank>\'%s\'<S2SV_blank>successfully<S2SV_blank>deinitialized<S2SV_blank>and<S2SV_blank>disconnected\\n" , <S2SV_EndBug> <S2SV_StartBug> KBUILD_MODNAME , name ) ; <S2SV_EndBug> }
static noinline void key_gc_unused_keys ( struct list_head * keys ) { while ( ! list_empty ( keys ) ) { struct key * key = list_entry ( keys -> next , struct key , graveyard_link ) ; <S2SV_StartBug> list_del ( & key -> graveyard_link ) ; <S2SV_EndBug> kdebug ( "-<S2SV_blank>%u" , key -> serial ) ; key_check ( key ) ; <S2SV_StartBug> if ( test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) && <S2SV_EndBug> ! test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) && key -> type -> destroy ) key -> type -> destroy ( key ) ; security_key_free ( key ) ; if ( test_bit ( KEY_FLAG_IN_QUOTA , & key -> flags ) ) { spin_lock ( & key -> user -> lock ) ; key -> user -> qnkeys -- ; key -> user -> qnbytes -= key -> quotalen ; spin_unlock ( & key -> user -> lock ) ; } atomic_dec ( & key -> user -> nkeys ) ; <S2SV_StartBug> if ( test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) ) <S2SV_EndBug> atomic_dec ( & key -> user -> nikeys ) ; key_user_put ( key -> user ) ; kfree ( key -> description ) ; memzero_explicit ( key , sizeof ( * key ) ) ; kmem_cache_free ( key_jar , key ) ; } }
static stmt_ty ast_for_for_stmt ( struct compiling * c , const node * n0 , bool is_async ) { const node * const n = is_async ? CHILD ( n0 , 1 ) : n0 ; asdl_seq * _target , * seq = NULL , * suite_seq ; expr_ty expression ; expr_ty target , first ; const node * node_target ; int end_lineno , end_col_offset ; <S2SV_StartBug> REQ ( n , for_stmt ) ; <S2SV_EndBug> <S2SV_StartBug> if ( NCH ( n ) == 9 ) { <S2SV_EndBug> <S2SV_StartBug> seq = ast_for_suite ( c , CHILD ( n , 8 ) ) ; <S2SV_EndBug> if ( ! seq ) return NULL ; } node_target = CHILD ( n , 1 ) ; _target = ast_for_exprlist ( c , node_target , Store ) ; if ( ! _target ) return NULL ; first = ( expr_ty ) asdl_seq_GET ( _target , 0 ) ; if ( NCH ( node_target ) == 1 ) target = first ; else target = Tuple ( _target , Store , first -> lineno , first -> col_offset , node_target -> n_end_lineno , node_target -> n_end_col_offset , c -> c_arena ) ; expression = ast_for_testlist ( c , CHILD ( n , 3 ) ) ; if ( ! expression ) return NULL ; <S2SV_StartBug> suite_seq = ast_for_suite ( c , CHILD ( n , 5 ) ) ; <S2SV_EndBug> if ( ! suite_seq ) return NULL ; if ( seq != NULL ) { get_last_end_pos ( seq , & end_lineno , & end_col_offset ) ; } else { get_last_end_pos ( suite_seq , & end_lineno , & end_col_offset ) ; } <S2SV_StartBug> if ( is_async ) <S2SV_EndBug> <S2SV_StartBug> return AsyncFor ( target , expression , suite_seq , seq , <S2SV_EndBug> LINENO ( n0 ) , n0 -> n_col_offset , end_lineno , end_col_offset , c -> c_arena ) ; else <S2SV_StartBug> return For ( target , expression , suite_seq , seq , <S2SV_EndBug> LINENO ( n ) , n -> n_col_offset , end_lineno , end_col_offset , c -> c_arena ) ; }
static int net_ctl_permissions ( struct ctl_table_header * head , struct ctl_table * table ) { struct net * net = container_of ( head -> set , struct net , sysctls ) ; kuid_t root_uid = make_kuid ( net -> user_ns , 0 ) ; kgid_t root_gid = make_kgid ( net -> user_ns , 0 ) ; if ( ns_capable ( net -> user_ns , CAP_NET_ADMIN ) || <S2SV_StartBug> uid_eq ( root_uid , current_uid ( ) ) ) { <S2SV_EndBug> int mode = ( table -> mode >> 6 ) & 7 ; return ( mode << 6 ) | ( mode << 3 ) | mode ; } <S2SV_StartBug> if ( gid_eq ( root_gid , current_gid ( ) ) ) { <S2SV_EndBug> int mode = ( table -> mode >> 3 ) & 7 ; return ( mode << 3 ) | mode ; } return table -> mode ; }
static Image * ReadMATImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image , * image2 = NULL , * rotated_image ; register Quantum * q ; unsigned int status ; MATHeader MATLAB_HDR ; size_t size ; size_t CellType ; QuantumInfo * quantum_info ; ImageInfo * clone_info ; int i ; ssize_t ldblk ; unsigned char * BImgBuff = NULL ; double MinVal , MaxVal ; unsigned z , z2 ; unsigned Frames ; int logging ; int sample_size ; MagickOffsetType filepos = 0x80 ; BlobInfo * blob ; size_t one ; unsigned int ( * ReadBlobXXXLong ) ( Image * image ) ; unsigned short ( * ReadBlobXXXShort ) ( Image * image ) ; void ( * ReadBlobDoublesXXX ) ( Image * image , size_t len , double * data ) ; void ( * ReadBlobFloatsXXX ) ( Image * image , size_t len , float * data ) ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; logging = LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "enter" ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } clone_info = CloneImageInfo ( image_info ) ; if ( ReadBlob ( image , 124 , ( unsigned char * ) & MATLAB_HDR . identific ) != 124 ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; if ( strncmp ( MATLAB_HDR . identific , "MATLAB" , 6 ) != 0 ) { image2 = ReadMATImageV4 ( image_info , image , exception ) ; if ( image2 == NULL ) goto MATLAB_KO ; image = image2 ; goto END_OF_READING ; } MATLAB_HDR . Version = ReadBlobLSBShort ( image ) ; if ( ReadBlob ( image , 2 , ( unsigned char * ) & MATLAB_HDR . EndianIndicator ) != 2 ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "<S2SV_blank><S2SV_blank>Endian<S2SV_blank>%c%c" , MATLAB_HDR . EndianIndicator [ 0 ] , MATLAB_HDR . EndianIndicator [ 1 ] ) ; if ( ! strncmp ( MATLAB_HDR . EndianIndicator , "IM" , 2 ) ) { ReadBlobXXXLong = ReadBlobLSBLong ; ReadBlobXXXShort = ReadBlobLSBShort ; ReadBlobDoublesXXX = ReadBlobDoublesLSB ; ReadBlobFloatsXXX = ReadBlobFloatsLSB ; image -> endian = LSBEndian ; } else if ( ! strncmp ( MATLAB_HDR . EndianIndicator , "MI" , 2 ) ) { ReadBlobXXXLong = ReadBlobMSBLong ; ReadBlobXXXShort = ReadBlobMSBShort ; ReadBlobDoublesXXX = ReadBlobDoublesMSB ; ReadBlobFloatsXXX = ReadBlobFloatsMSB ; image -> endian = MSBEndian ; } else goto MATLAB_KO ; if ( strncmp ( MATLAB_HDR . identific , "MATLAB" , 6 ) ) MATLAB_KO : ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; filepos = TellBlob ( image ) ; while ( ! EOFBlob ( image ) ) { Frames = 1 ; ( void ) SeekBlob ( image , filepos , SEEK_SET ) ; MATLAB_HDR . DataType = ReadBlobXXXLong ( image ) ; if ( EOFBlob ( image ) ) break ; MATLAB_HDR . ObjectSize = ReadBlobXXXLong ( image ) ; if ( EOFBlob ( image ) ) break ; filepos += MATLAB_HDR . ObjectSize + 4 + 4 ; image2 = image ; # if defined ( MAGICKCORE_ZLIB_DELEGATE ) if ( MATLAB_HDR . DataType == miCOMPRESSED ) { image2 = DecompressBlock ( image , MATLAB_HDR . ObjectSize , clone_info , exception ) ; if ( image2 == NULL ) continue ; MATLAB_HDR . DataType = ReadBlobXXXLong ( image2 ) ; } # endif if ( MATLAB_HDR . DataType != miMATRIX ) continue ; MATLAB_HDR . unknown1 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown2 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown5 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . StructureClass = MATLAB_HDR . unknown5 & 0xFF ; MATLAB_HDR . StructureFlag = ( MATLAB_HDR . unknown5 >> 8 ) & 0xFF ; MATLAB_HDR . unknown3 = ReadBlobXXXLong ( image2 ) ; if ( image != image2 ) MATLAB_HDR . unknown4 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown4 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . DimFlag = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . SizeX = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . SizeY = ReadBlobXXXLong ( image2 ) ; switch ( MATLAB_HDR . DimFlag ) { case 8 : z2 = z = 1 ; break ; case 12 : z2 = z = ReadBlobXXXLong ( image2 ) ; ( void ) ReadBlobXXXLong ( image2 ) ; if ( z != 3 ) ThrowReaderException ( CoderError , "MultidimensionalMatricesAreNotSupported" ) ; break ; case 16 : z2 = z = ReadBlobXXXLong ( image2 ) ; if ( z != 3 && z != 1 ) ThrowReaderException ( CoderError , "MultidimensionalMatricesAreNotSupported" ) ; Frames = ReadBlobXXXLong ( image2 ) ; if ( Frames == 0 ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; break ; default : ThrowReaderException ( CoderError , "MultidimensionalMatricesAreNotSupported" ) ; } MATLAB_HDR . Flag1 = ReadBlobXXXShort ( image2 ) ; MATLAB_HDR . NameFlag = ReadBlobXXXShort ( image2 ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "MATLAB_HDR.StructureClass<S2SV_blank>%d" , MATLAB_HDR . StructureClass ) ; if ( MATLAB_HDR . StructureClass != mxCHAR_CLASS && MATLAB_HDR . StructureClass != mxSINGLE_CLASS && MATLAB_HDR . StructureClass != mxDOUBLE_CLASS && MATLAB_HDR . StructureClass != mxINT8_CLASS && MATLAB_HDR . StructureClass != mxUINT8_CLASS && MATLAB_HDR . StructureClass != mxINT16_CLASS && MATLAB_HDR . StructureClass != mxUINT16_CLASS && MATLAB_HDR . StructureClass != mxINT32_CLASS && MATLAB_HDR . StructureClass != mxUINT32_CLASS && MATLAB_HDR . StructureClass != mxINT64_CLASS && MATLAB_HDR . StructureClass != mxUINT64_CLASS ) ThrowReaderException ( CoderError , "UnsupportedCellTypeInTheMatrix" ) ; switch ( MATLAB_HDR . NameFlag ) { case 0 : size = ReadBlobXXXLong ( image2 ) ; size = 4 * ( ssize_t ) ( ( size + 3 + 1 ) / 4 ) ; ( void ) SeekBlob ( image2 , size , SEEK_CUR ) ; break ; case 1 : case 2 : case 3 : case 4 : ( void ) ReadBlob ( image2 , 4 , ( unsigned char * ) & size ) ; break ; default : goto MATLAB_KO ; } CellType = ReadBlobXXXLong ( image2 ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "MATLAB_HDR.CellType:<S2SV_blank>%.20g" , ( double ) CellType ) ; ( void ) ReadBlob ( image2 , 4 , ( unsigned char * ) & size ) ; NEXT_FRAME : switch ( CellType ) { case miINT8 : case miUINT8 : sample_size = 8 ; if ( MATLAB_HDR . StructureFlag & FLAG_LOGICAL ) image -> depth = 1 ; else image -> depth = 8 ; ldblk = ( ssize_t ) MATLAB_HDR . SizeX ; break ; case miINT16 : case miUINT16 : sample_size = 16 ; image -> depth = 16 ; ldblk = ( ssize_t ) ( 2 * MATLAB_HDR . SizeX ) ; break ; case miINT32 : case miUINT32 : sample_size = 32 ; image -> depth = 32 ; ldblk = ( ssize_t ) ( 4 * MATLAB_HDR . SizeX ) ; break ; case miINT64 : case miUINT64 : sample_size = 64 ; image -> depth = 64 ; ldblk = ( ssize_t ) ( 8 * MATLAB_HDR . SizeX ) ; break ; case miSINGLE : sample_size = 32 ; image -> depth = 32 ; ( void ) SetImageOption ( clone_info , "quantum:format" , "floating-point" ) ; if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { } ldblk = ( ssize_t ) ( 4 * MATLAB_HDR . SizeX ) ; break ; case miDOUBLE : sample_size = 64 ; image -> depth = 64 ; ( void ) SetImageOption ( clone_info , "quantum:format" , "floating-point" ) ; DisableMSCWarning ( 4127 ) if ( sizeof ( double ) != 8 ) RestoreMSCWarning ThrowReaderException ( CoderError , "IncompatibleSizeOfDouble" ) ; if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { } ldblk = ( ssize_t ) ( 8 * MATLAB_HDR . SizeX ) ; break ; default : ThrowReaderException ( CoderError , "UnsupportedCellTypeInTheMatrix" ) ; } ( void ) sample_size ; image -> columns = MATLAB_HDR . SizeX ; image -> rows = MATLAB_HDR . SizeY ; quantum_info = AcquireQuantumInfo ( clone_info , image ) ; if ( quantum_info == ( QuantumInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; one = 1 ; image -> colors = one << image -> depth ; if ( image -> columns == 0 || image -> rows == 0 ) goto MATLAB_KO ; if ( ( MATLAB_HDR . DimFlag == 8 ) && ( ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) == 0 ) ) { image -> type = GrayscaleType ; SetImageColorspace ( image , GRAYColorspace , exception ) ; } if ( image_info -> ping ) { size_t temp = image -> columns ; image -> columns = image -> rows ; image -> rows = temp ; goto done_reading ; } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; BImgBuff = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ( ldblk ) , sizeof ( double ) ) ; if ( BImgBuff == NULL ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; <S2SV_StartBug> MinVal = 0 ; <S2SV_EndBug> MaxVal = 0 ; if ( CellType == miDOUBLE || CellType == miSINGLE ) { CalcMinMax ( image2 , image_info -> endian , MATLAB_HDR . SizeX , MATLAB_HDR . SizeY , CellType , ldblk , BImgBuff , & quantum_info -> minimum , & quantum_info -> maximum ) ; } if ( z == 1 ) z = 0 ; do { for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { q = GetAuthenticPixels ( image , 0 , MATLAB_HDR . SizeY - i - 1 , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "<S2SV_blank><S2SV_blank>MAT<S2SV_blank>set<S2SV_blank>image<S2SV_blank>pixels<S2SV_blank>returns<S2SV_blank>unexpected<S2SV_blank>NULL<S2SV_blank>on<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u." , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto done_reading ; } if ( ReadBlob ( image2 , ldblk , ( unsigned char * ) BImgBuff ) != ( ssize_t ) ldblk ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "<S2SV_blank><S2SV_blank>MAT<S2SV_blank>cannot<S2SV_blank>read<S2SV_blank>scanrow<S2SV_blank>%u<S2SV_blank>from<S2SV_blank>a<S2SV_blank>file." , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto ExitLoop ; } if ( ( CellType == miINT8 || CellType == miUINT8 ) && ( MATLAB_HDR . StructureFlag & FLAG_LOGICAL ) ) { FixLogical ( ( unsigned char * ) BImgBuff , ldblk ) ; if ( ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , z2qtype [ z ] , BImgBuff , exception ) <= 0 ) { ImportQuantumPixelsFailed : if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "<S2SV_blank><S2SV_blank>MAT<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>ImportQuantumPixels<S2SV_blank>for<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; break ; } } else { if ( ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , z2qtype [ z ] , BImgBuff , exception ) <= 0 ) goto ImportQuantumPixelsFailed ; if ( z <= 1 && ( CellType == miINT8 || CellType == miINT16 || CellType == miINT32 || CellType == miINT64 ) ) FixSignedValues ( image , q , MATLAB_HDR . SizeX ) ; } if ( ! SyncAuthenticPixels ( image , exception ) ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "<S2SV_blank><S2SV_blank>MAT<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>sync<S2SV_blank>image<S2SV_blank>pixels<S2SV_blank>for<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto ExitLoop ; } } } while ( z -- >= 2 ) ; quantum_info = DestroyQuantumInfo ( quantum_info ) ; ExitLoop : if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { CellType = ReadBlobXXXLong ( image2 ) ; i = ReadBlobXXXLong ( image2 ) ; if ( CellType == miDOUBLE || CellType == miSINGLE ) { CalcMinMax ( image2 , image_info -> endian , MATLAB_HDR . SizeX , MATLAB_HDR . SizeY , CellType , ldblk , BImgBuff , & MinVal , & MaxVal ) ; } if ( CellType == miDOUBLE ) for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { ReadBlobDoublesXXX ( image2 , ldblk , ( double * ) BImgBuff ) ; InsertComplexDoubleRow ( image , ( double * ) BImgBuff , i , MinVal , MaxVal , exception ) ; } if ( CellType == miSINGLE ) for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { ReadBlobFloatsXXX ( image2 , ldblk , ( float * ) BImgBuff ) ; InsertComplexFloatRow ( image , ( float * ) BImgBuff , i , MinVal , MaxVal , exception ) ; } } if ( ( MATLAB_HDR . DimFlag == 8 ) && ( ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) == 0 ) ) image -> type = GrayscaleType ; if ( image -> depth == 1 ) image -> type = BilevelType ; if ( image2 == image ) image2 = NULL ; rotated_image = RotateImage ( image , 90.0 , exception ) ; if ( rotated_image != ( Image * ) NULL ) { rotated_image -> page . x = 0 ; rotated_image -> page . y = 0 ; blob = rotated_image -> blob ; rotated_image -> blob = image -> blob ; rotated_image -> colors = image -> colors ; image -> blob = blob ; AppendImageToList ( & image , rotated_image ) ; DeleteImageFromList ( & image ) ; } done_reading : if ( image2 != NULL ) if ( image2 != image ) { DeleteImageFromList ( & image2 ) ; if ( clone_info ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } } } AcquireNextImage ( image_info , image , exception ) ; if ( image -> next == ( Image * ) NULL ) break ; image = SyncNextImageInList ( image ) ; image -> columns = image -> rows = 0 ; image -> colors = 0 ; RelinquishMagickMemory ( BImgBuff ) ; BImgBuff = NULL ; if ( -- Frames > 0 ) { z = z2 ; if ( image2 == NULL ) image2 = image ; goto NEXT_FRAME ; } if ( ( image2 != NULL ) && ( image2 != image ) ) { DeleteImageFromList ( & image2 ) ; if ( clone_info ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } } } } RelinquishMagickMemory ( BImgBuff ) ; END_OF_READING : clone_info = DestroyImageInfo ( clone_info ) ; CloseBlob ( image ) ; { Image * p ; ssize_t scene = 0 ; p = image ; image = NULL ; while ( p != ( Image * ) NULL ) { Image * tmp = p ; if ( ( p -> rows == 0 ) || ( p -> columns == 0 ) ) { p = p -> previous ; DeleteImageFromList ( & tmp ) ; } else { image = p ; p = p -> previous ; } } for ( p = image ; p != ( Image * ) NULL ; p = p -> next ) p -> scene = scene ++ ; } if ( clone_info != NULL ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } DestroyImageInfo ( clone_info ) ; clone_info = NULL ; } if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "return" ) ; if ( image == NULL ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; return ( image ) ; }
static long vop_ioctl ( struct file * f , unsigned int cmd , unsigned long arg ) { struct vop_vdev * vdev = f -> private_data ; struct vop_info * vi = vdev -> vi ; void __user * argp = ( void __user * ) arg ; int ret ; switch ( cmd ) { case MIC_VIRTIO_ADD_DEVICE : { struct mic_device_desc dd , * dd_config ; if ( copy_from_user ( & dd , argp , sizeof ( dd ) ) ) return - EFAULT ; if ( mic_aligned_desc_size ( & dd ) > MIC_MAX_DESC_BLK_SIZE || dd . num_vq > MIC_MAX_VRINGS ) return - EINVAL ; dd_config = kzalloc ( mic_desc_size ( & dd ) , GFP_KERNEL ) ; if ( ! dd_config ) return - ENOMEM ; if ( copy_from_user ( dd_config , argp , mic_desc_size ( & dd ) ) ) { ret = - EFAULT ; goto free_ret ; } <S2SV_StartBug> mutex_lock ( & vdev -> vdev_mutex ) ; <S2SV_EndBug> mutex_lock ( & vi -> vop_mutex ) ; ret = vop_virtio_add_device ( vdev , dd_config ) ; if ( ret ) goto unlock_ret ; list_add_tail ( & vdev -> list , & vi -> vdev_list ) ; unlock_ret : mutex_unlock ( & vi -> vop_mutex ) ; mutex_unlock ( & vdev -> vdev_mutex ) ; free_ret : kfree ( dd_config ) ; return ret ; } case MIC_VIRTIO_COPY_DESC : { struct mic_copy_desc copy ; mutex_lock ( & vdev -> vdev_mutex ) ; ret = vop_vdev_inited ( vdev ) ; if ( ret ) goto _unlock_ret ; if ( copy_from_user ( & copy , argp , sizeof ( copy ) ) ) { ret = - EFAULT ; goto _unlock_ret ; } ret = vop_virtio_copy_desc ( vdev , & copy ) ; if ( ret < 0 ) goto _unlock_ret ; if ( copy_to_user ( & ( ( struct mic_copy_desc __user * ) argp ) -> out_len , & copy . out_len , sizeof ( copy . out_len ) ) ) ret = - EFAULT ; _unlock_ret : mutex_unlock ( & vdev -> vdev_mutex ) ; return ret ; } case MIC_VIRTIO_CONFIG_CHANGE : { void * buf ; mutex_lock ( & vdev -> vdev_mutex ) ; ret = vop_vdev_inited ( vdev ) ; if ( ret ) goto __unlock_ret ; buf = kzalloc ( vdev -> dd -> config_len , GFP_KERNEL ) ; if ( ! buf ) { ret = - ENOMEM ; goto __unlock_ret ; } if ( copy_from_user ( buf , argp , vdev -> dd -> config_len ) ) { ret = - EFAULT ; goto done ; } ret = vop_virtio_config_change ( vdev , buf ) ; done : kfree ( buf ) ; __unlock_ret : mutex_unlock ( & vdev -> vdev_mutex ) ; return ret ; } default : return - ENOIOCTLCMD ; } ; return 0 ; }
static int read_new_config_info ( WavpackContext * wpc , WavpackMetadata * wpmd ) { int bytecnt = wpmd -> byte_length ; unsigned char * byteptr = wpmd -> data ; wpc -> version_five = 1 ; wpc -> file_format = wpc -> config . qmode = wpc -> channel_layout = 0 ; if ( wpc -> channel_reordering ) { free ( wpc -> channel_reordering ) ; wpc -> channel_reordering = NULL ; } <S2SV_StartBug> if ( bytecnt ) { <S2SV_EndBug> wpc -> file_format = * byteptr ++ ; wpc -> config . qmode = ( wpc -> config . qmode & ~ 0xff ) | * byteptr ++ ; bytecnt -= 2 ; if ( bytecnt ) { int nchans , i ; wpc -> channel_layout = ( int32_t ) * byteptr ++ << 16 ; bytecnt -- ; if ( bytecnt ) { wpc -> channel_layout += nchans = * byteptr ++ ; bytecnt -- ; if ( bytecnt ) { if ( bytecnt > nchans ) return FALSE ; wpc -> channel_reordering = malloc ( nchans ) ; if ( wpc -> channel_reordering ) { for ( i = 0 ; i < nchans ; ++ i ) if ( bytecnt ) { wpc -> channel_reordering [ i ] = * byteptr ++ ; <S2SV_StartBug> bytecnt -- ; <S2SV_EndBug> } else wpc -> channel_reordering [ i ] = i ; } } } else wpc -> channel_layout += wpc -> config . num_channels ; } } return TRUE ; }
uint8_t hfs_cat_traverse ( HFS_INFO * hfs , TSK_HFS_BTREE_CB a_cb , void * ptr ) { TSK_FS_INFO * fs = & ( hfs -> fs_info ) ; uint32_t cur_node ; char * node ; uint16_t nodesize ; uint8_t is_done = 0 ; tsk_error_reset ( ) ; nodesize = tsk_getu16 ( fs -> endian , hfs -> catalog_header . nodesize ) ; if ( ( node = ( char * ) tsk_malloc ( nodesize ) ) == NULL ) return 1 ; cur_node = tsk_getu32 ( fs -> endian , hfs -> catalog_header . rootNode ) ; if ( cur_node == 0 ) { if ( tsk_verbose ) tsk_fprintf ( stderr , "hfs_cat_traverse:<S2SV_blank>" "empty<S2SV_blank>extents<S2SV_blank>btree\\n" ) ; free ( node ) ; return 1 ; } if ( tsk_verbose ) tsk_fprintf ( stderr , "hfs_cat_traverse:<S2SV_blank>starting<S2SV_blank>at<S2SV_blank>" "root<S2SV_blank>node<S2SV_blank>%" PRIu32 ";<S2SV_blank>nodesize<S2SV_blank>=<S2SV_blank>%" PRIu16 "\\n" , cur_node , nodesize ) ; is_done = 0 ; while ( is_done == 0 ) { TSK_OFF_T cur_off ; uint16_t num_rec ; ssize_t cnt ; hfs_btree_node * node_desc ; if ( cur_node > tsk_getu32 ( fs -> endian , hfs -> catalog_header . totalNodes ) ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( "hfs_cat_traverse:<S2SV_blank>Node<S2SV_blank>%d<S2SV_blank>too<S2SV_blank>large<S2SV_blank>for<S2SV_blank>file" , cur_node ) ; free ( node ) ; return 1 ; } cur_off = cur_node * nodesize ; cnt = tsk_fs_attr_read ( hfs -> catalog_attr , cur_off , node , nodesize , 0 ) ; if ( cnt != nodesize ) { if ( cnt >= 0 ) { tsk_error_reset ( ) ; tsk_error_set_errno ( TSK_ERR_FS_READ ) ; } tsk_error_set_errstr2 ( "hfs_cat_traverse:<S2SV_blank>Error<S2SV_blank>reading<S2SV_blank>node<S2SV_blank>%d<S2SV_blank>at<S2SV_blank>offset<S2SV_blank>%" PRIuOFF , cur_node , cur_off ) ; free ( node ) ; return 1 ; } if ( nodesize < sizeof ( hfs_btree_node ) ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( "hfs_cat_traverse:<S2SV_blank>Node<S2SV_blank>size<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>too<S2SV_blank>small<S2SV_blank>to<S2SV_blank>be<S2SV_blank>valid" , nodesize ) ; free ( node ) ; return 1 ; } node_desc = ( hfs_btree_node * ) node ; num_rec = tsk_getu16 ( fs -> endian , node_desc -> num_rec ) ; if ( tsk_verbose ) tsk_fprintf ( stderr , "hfs_cat_traverse:<S2SV_blank>node<S2SV_blank>%" PRIu32 "<S2SV_blank>@<S2SV_blank>%" PRIu64 "<S2SV_blank>has<S2SV_blank>%" PRIu16 "<S2SV_blank>records\\n" , cur_node , cur_off , num_rec ) ; if ( num_rec == 0 ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( "hfs_cat_traverse:<S2SV_blank>zero<S2SV_blank>records<S2SV_blank>in<S2SV_blank>node<S2SV_blank>%" PRIu32 , cur_node ) ; free ( node ) ; return 1 ; } if ( node_desc -> type == HFS_BT_NODE_TYPE_IDX ) { uint32_t next_node = 0 ; int rec ; for ( rec = 0 ; rec < num_rec ; ++ rec ) { size_t rec_off ; hfs_btree_key_cat * key ; uint8_t retval ; int keylen ; rec_off = tsk_getu16 ( fs -> endian , & node [ nodesize - ( rec + 1 ) * 2 ] ) ; if ( rec_off > nodesize ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( "hfs_cat_traverse:<S2SV_blank>offset<S2SV_blank>of<S2SV_blank>record<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>index<S2SV_blank>node<S2SV_blank>%d<S2SV_blank>too<S2SV_blank>large<S2SV_blank>(%d<S2SV_blank>vs<S2SV_blank>%" PRIu16 ")" , rec , cur_node , ( int ) rec_off , nodesize ) ; free ( node ) ; return 1 ; } key = ( hfs_btree_key_cat * ) & node [ rec_off ] ; keylen = 2 + tsk_getu16 ( hfs -> fs_info . endian , key -> key_len ) ; <S2SV_StartBug> if ( ( keylen ) > nodesize ) { <S2SV_EndBug> tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( "hfs_cat_traverse:<S2SV_blank>length<S2SV_blank>of<S2SV_blank>key<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>index<S2SV_blank>node<S2SV_blank>%d<S2SV_blank>too<S2SV_blank>large<S2SV_blank>(%d<S2SV_blank>vs<S2SV_blank>%" <S2SV_StartBug> PRIu16 ")" , rec , cur_node , keylen , nodesize ) ; <S2SV_EndBug> free ( node ) ; return 1 ; } retval = a_cb ( hfs , HFS_BT_NODE_TYPE_IDX , key , cur_off + rec_off , ptr ) ; if ( retval == HFS_BTREE_CB_ERR ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr2 ( "hfs_cat_traverse:<S2SV_blank>Callback<S2SV_blank>returned<S2SV_blank>error" ) ; free ( node ) ; return 1 ; } else if ( ( retval == HFS_BTREE_CB_IDX_LT ) || ( next_node == 0 ) ) { hfs_btree_index_record * idx_rec ; int keylen = 2 + hfs_get_idxkeylen ( hfs , tsk_getu16 ( fs -> endian , key -> key_len ) , & ( hfs -> catalog_header ) ) ; if ( rec_off + keylen > nodesize ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( "hfs_cat_traverse:<S2SV_blank>offset<S2SV_blank>of<S2SV_blank>record<S2SV_blank>and<S2SV_blank>keylength<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>index<S2SV_blank>node<S2SV_blank>%d<S2SV_blank>too<S2SV_blank>large<S2SV_blank>(%d<S2SV_blank>vs<S2SV_blank>%" PRIu16 ")" , rec , cur_node , ( int ) rec_off + keylen , nodesize ) ; free ( node ) ; return 1 ; } idx_rec = ( hfs_btree_index_record * ) & node [ rec_off + keylen ] ; next_node = tsk_getu32 ( fs -> endian , idx_rec -> childNode ) ; } if ( retval == HFS_BTREE_CB_IDX_EQGT ) { break ; } } if ( next_node == 0 ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( "hfs_cat_traverse:<S2SV_blank>did<S2SV_blank>not<S2SV_blank>find<S2SV_blank>any<S2SV_blank>keys<S2SV_blank>in<S2SV_blank>index<S2SV_blank>node<S2SV_blank>%d" , cur_node ) ; is_done = 1 ; break ; } if ( next_node == cur_node ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( "hfs_cat_traverse:<S2SV_blank>node<S2SV_blank>%d<S2SV_blank>references<S2SV_blank>itself<S2SV_blank>as<S2SV_blank>next<S2SV_blank>node" , cur_node ) ; is_done = 1 ; break ; } cur_node = next_node ; } else if ( node_desc -> type == HFS_BT_NODE_TYPE_LEAF ) { int rec ; for ( rec = 0 ; rec < num_rec ; ++ rec ) { size_t rec_off ; hfs_btree_key_cat * key ; uint8_t retval ; int keylen ; rec_off = tsk_getu16 ( fs -> endian , & node [ nodesize - ( rec + 1 ) * 2 ] ) ; if ( rec_off > nodesize ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( "hfs_cat_traverse:<S2SV_blank>offset<S2SV_blank>of<S2SV_blank>record<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>leaf<S2SV_blank>node<S2SV_blank>%d<S2SV_blank>too<S2SV_blank>large<S2SV_blank>(%d<S2SV_blank>vs<S2SV_blank>%" PRIu16 ")" , rec , cur_node , ( int ) rec_off , nodesize ) ; free ( node ) ; return 1 ; } key = ( hfs_btree_key_cat * ) & node [ rec_off ] ; keylen = 2 + tsk_getu16 ( hfs -> fs_info . endian , key -> key_len ) ; if ( ( keylen ) > nodesize ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( "hfs_cat_traverse:<S2SV_blank>length<S2SV_blank>of<S2SV_blank>key<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>leaf<S2SV_blank>node<S2SV_blank>%d<S2SV_blank>too<S2SV_blank>large<S2SV_blank>(%d<S2SV_blank>vs<S2SV_blank>%" PRIu16 ")" , rec , cur_node , keylen , nodesize ) ; free ( node ) ; return 1 ; } retval = a_cb ( hfs , HFS_BT_NODE_TYPE_LEAF , key , cur_off + rec_off , ptr ) ; if ( retval == HFS_BTREE_CB_LEAF_STOP ) { is_done = 1 ; break ; } else if ( retval == HFS_BTREE_CB_ERR ) { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr2 ( "hfs_cat_traverse:<S2SV_blank>Callback<S2SV_blank>returned<S2SV_blank>error" ) ; free ( node ) ; return 1 ; } } if ( is_done == 0 ) { cur_node = tsk_getu32 ( fs -> endian , node_desc -> flink ) ; if ( cur_node == 0 ) { is_done = 1 ; } if ( tsk_verbose ) tsk_fprintf ( stderr , "hfs_cat_traverse:<S2SV_blank>moving<S2SV_blank>forward<S2SV_blank>to<S2SV_blank>next<S2SV_blank>leaf" ) ; } } else { tsk_error_set_errno ( TSK_ERR_FS_GENFS ) ; tsk_error_set_errstr ( "hfs_cat_traverse:<S2SV_blank>btree<S2SV_blank>node<S2SV_blank>%" PRIu32 "<S2SV_blank>(%" PRIu64 ")<S2SV_blank>is<S2SV_blank>neither<S2SV_blank>index<S2SV_blank>nor<S2SV_blank>leaf<S2SV_blank>(%" PRIu8 ")" , cur_node , cur_off , node_desc -> type ) ; free ( node ) ; return 1 ; } } free ( node ) ; return 0 ; }
void sock_release ( struct socket * sock ) { <S2SV_StartBug> if ( sock -> ops ) { <S2SV_EndBug> struct module * owner = sock -> ops -> owner ; sock -> ops -> release ( sock ) ; sock -> ops = NULL ; module_put ( owner ) ; } <S2SV_StartBug> if ( rcu_dereference_protected ( sock -> wq , 1 ) -> fasync_list ) <S2SV_EndBug> pr_err ( "%s:<S2SV_blank>fasync<S2SV_blank>list<S2SV_blank>not<S2SV_blank>empty!\\n" , __func__ ) ; if ( ! sock -> file ) { iput ( SOCK_INODE ( sock ) ) ; return ; } sock -> file = NULL ; }
static int hash_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct hash_ctx * ctx = ask -> private ; unsigned ds = crypto_ahash_digestsize ( crypto_ahash_reqtfm ( & ctx -> req ) ) ; int err ; if ( len > ds ) len = ds ; else if ( len < ds ) msg -> msg_flags |= MSG_TRUNC ; <S2SV_StartBug> lock_sock ( sk ) ; <S2SV_EndBug> if ( ctx -> more ) { ctx -> more = 0 ; ahash_request_set_crypt ( & ctx -> req , NULL , ctx -> result , 0 ) ; err = af_alg_wait_for_completion ( crypto_ahash_final ( & ctx -> req ) , & ctx -> completion ) ; if ( err ) goto unlock ; } err = memcpy_toiovec ( msg -> msg_iov , ctx -> result , len ) ; unlock : release_sock ( sk ) ; return err ? : len ; }
static void sgi_timer_get ( struct k_itimer * timr , struct itimerspec * cur_setting ) { if ( timr -> it . mmtimer . clock == TIMER_OFF ) { cur_setting -> it_interval . tv_nsec = 0 ; cur_setting -> it_interval . tv_sec = 0 ; cur_setting -> it_value . tv_nsec = 0 ; cur_setting -> it_value . tv_sec = 0 ; return ; } <S2SV_StartBug> ns_to_timespec ( cur_setting -> it_interval , timr -> it . mmtimer . incr * sgi_clock_period ) ; <S2SV_EndBug> <S2SV_StartBug> ns_to_timespec ( cur_setting -> it_value , ( timr -> it . mmtimer . expires - rtc_time ( ) ) * sgi_clock_period ) ; <S2SV_EndBug> <S2SV_StartBug> return ; <S2SV_EndBug> }
int mp4boxMain ( int argc , char * * argv ) { u32 i , j ; const char * gpac_profile = "0" ; GF_Err e = GF_OK ; nb_tsel_acts = nb_add = nb_cat = nb_track_act = nb_sdp_ex = max_ptime = nb_meta_act = rtp_rate = major_brand = nb_alt_brand_add = nb_alt_brand_rem = car_dur = minor_version = 0 ; split_duration = 0.0 ; split_start = - 1.0 ; interleaving_time = 0 ; dash_duration = dash_subduration = 0.0 ; import_fps . num = import_fps . den = 0 ; import_flags = 0 ; split_size = 0 ; movie_time = 0 ; dump_nal = dump_saps = dump_saps_mode = force_new = 0 ; FullInter = HintInter = encode = do_scene_log = old_interleave = do_saf = do_hash = verbose = do_mpd_rip = merge_vtt_cues = get_nb_tracks = GF_FALSE ; # ifndef GPAC_DISABLE_SCENE_DUMP dump_mode = GF_SM_DUMP_NONE ; # endif Frag = force_ocr = remove_sys_tracks = agg_samples = remove_hint = keep_sys_tracks = remove_root_od = single_group = clean_groups = compress_moov = GF_FALSE ; conv_type = HintIt = needSave = print_sdp = regular_iod = dump_std = open_edit = dump_rtp = dump_cr = dump_srt = dump_ttxt = dump_m2ts = dump_cart = import_subtitle = force_cat = pack_wgt = dash_live = GF_FALSE ; no_fragments_defaults = GF_FALSE ; single_traf_per_moof = hls_clock = GF_FALSE ; tfdt_per_traf = GF_FALSE ; dump_nal_type = 0 ; dump_isom = 0 ; print_info = 0 ; align_cat = GF_TRUE ; subsegs_per_sidx = 0 ; track_dump_type = 0 ; crypt = 0 ; time_shift_depth = 0 ; file = NULL ; itunes_tags = pes_dump = NULL ; seg_name = dash_ctx_file = NULL ; compress_top_boxes = NULL ; initial_moof_sn = 0 ; initial_tfdt = 0 ; # ifndef GPAC_DISABLE_SCENE_ENCODER memset ( & smenc_opts , 0 , sizeof ( smenc_opts ) ) ; # endif trackID = stat_level = hint_flags = 0 ; program_number = 0 ; info_track_id = 0 ; do_flat = 0 ; inName = outName = mediaSource = input_ctx = output_ctx = drm_file = avi2raw = cprt = chap_file = pack_file = raw_cat = high_dynamc_range_filename = use_init_seg = box_patch_filename = NULL ; # ifndef GPAC_DISABLE_SWF_IMPORT swf_flags = GF_SM_SWF_SPLIT_TIMELINE ; # endif swf_flatten_angle = 0.0f ; tmpdir = NULL ; for ( i = 1 ; i < ( u32 ) argc ; i ++ ) { if ( ! strcmp ( argv [ i ] , "-mem-track" ) || ! strcmp ( argv [ i ] , "-mem-track-stack" ) ) { # ifdef GPAC_MEMORY_TRACKING mem_track = ! strcmp ( argv [ i ] , "-mem-track-stack" ) ? GF_MemTrackerBackTrace : GF_MemTrackerSimple ; # else fprintf ( stderr , "WARNING<S2SV_blank>-<S2SV_blank>GPAC<S2SV_blank>not<S2SV_blank>compiled<S2SV_blank>with<S2SV_blank>Memory<S2SV_blank>Tracker<S2SV_blank>-<S2SV_blank>ignoring<S2SV_blank>\\"%s\\"\\n" , argv [ i ] ) ; # endif break ; } else if ( ! strcmp ( argv [ i ] , "-p" ) ) { if ( i + 1 < ( u32 ) argc ) gpac_profile = argv [ i + 1 ] ; else { fprintf ( stderr , "Bad<S2SV_blank>argument<S2SV_blank>for<S2SV_blank>-p,<S2SV_blank>expecting<S2SV_blank>profile<S2SV_blank>name<S2SV_blank>but<S2SV_blank>no<S2SV_blank>more<S2SV_blank>args\\n" ) ; return 1 ; } } else if ( ! strncmp ( argv [ i ] , "-p=" , 3 ) ) gpac_profile = argv [ i ] + 3 ; } # ifdef _TWO_DIGIT_EXPONENT _set_output_format ( _TWO_DIGIT_EXPONENT ) ; # endif gf_sys_init ( mem_track , gpac_profile ) ; if ( argc < 2 ) { fprintf ( stderr , "Not<S2SV_blank>enough<S2SV_blank>arguments<S2SV_blank>-<S2SV_blank>check<S2SV_blank>usage<S2SV_blank>with<S2SV_blank>-h\\n" "MP4Box<S2SV_blank>-<S2SV_blank>GPAC<S2SV_blank>version<S2SV_blank>%s\\n" "%s\\n" , gf_gpac_version ( ) , gf_gpac_copyright ( ) ) ; gf_sys_close ( ) ; return 0 ; } helpout = stdout ; i = mp4box_parse_args ( argc , argv ) ; if ( i ) { return mp4box_cleanup ( i - 1 ) ; } if ( ! inName && dump_std ) inName = "std" ; if ( ! inName ) { if ( has_next_arg ) { fprintf ( stderr , "Broken<S2SV_blank>argument<S2SV_blank>specifier<S2SV_blank>or<S2SV_blank>file<S2SV_blank>name<S2SV_blank>missing<S2SV_blank>-<S2SV_blank>check<S2SV_blank>usage<S2SV_blank>with<S2SV_blank>-h\\n" ) ; } else { PrintUsage ( ) ; } return mp4box_cleanup ( 1 ) ; } if ( ! strcmp ( inName , "std" ) ) dump_std = 2 ; if ( ! strcmp ( inName , "stdb" ) ) { inName = "std" ; dump_std = 1 ; } if ( ! interleaving_time ) { if ( dash_duration ) interleaving_time = dash_duration ; else if ( ! do_flat ) { interleaving_time = DEFAULT_INTERLEAVING_IN_SEC ; } } if ( dump_std ) outName = "std" ; if ( dump_std == 2 ) { # ifdef WIN32 if ( _setmode ( _fileno ( stdout ) , _O_BINARY ) == - 1 ) # else if ( freopen ( NULL , "wb" , stdout ) == NULL ) # endif { fprintf ( stderr , "Fatal<S2SV_blank>error:<S2SV_blank>cannot<S2SV_blank>reopen<S2SV_blank>stdout<S2SV_blank>in<S2SV_blank>binary<S2SV_blank>mode.\\n" ) ; return mp4box_cleanup ( 1 ) ; } } # if ! defined ( GPAC_DISABLE_STREAMING ) && ! defined ( GPAC_DISABLE_SENG ) if ( live_scene ) { int ret = live_session ( argc , argv ) ; return mp4box_cleanup ( ret ) ; } # endif GF_LOG_Level level = verbose ? GF_LOG_DEBUG : GF_LOG_INFO ; gf_log_set_tool_level ( GF_LOG_CONTAINER , level ) ; gf_log_set_tool_level ( GF_LOG_SCENE , level ) ; gf_log_set_tool_level ( GF_LOG_PARSER , level ) ; gf_log_set_tool_level ( GF_LOG_AUTHOR , level ) ; gf_log_set_tool_level ( GF_LOG_CODING , level ) ; gf_log_set_tool_level ( GF_LOG_DASH , level ) ; # ifdef GPAC_MEMORY_TRACKING if ( mem_track ) gf_log_set_tool_level ( GF_LOG_MEMORY , level ) ; # endif e = gf_sys_set_args ( argc , ( const char * * ) argv ) ; if ( e ) { fprintf ( stderr , "Error<S2SV_blank>assigning<S2SV_blank>libgpac<S2SV_blank>arguments:<S2SV_blank>%s\\n" , gf_error_to_string ( e ) ) ; return mp4box_cleanup ( 1 ) ; } if ( raw_cat ) { char chunk [ 4096 ] ; FILE * fin , * fout ; s64 to_copy , done ; fin = gf_fopen ( raw_cat , "rb" ) ; if ( ! fin ) return mp4box_cleanup ( 1 ) ; fout = gf_fopen ( inName , "a+b" ) ; if ( ! fout ) { gf_fclose ( fin ) ; return mp4box_cleanup ( 1 ) ; } gf_fseek ( fin , 0 , SEEK_END ) ; to_copy = gf_ftell ( fin ) ; gf_fseek ( fin , 0 , SEEK_SET ) ; done = 0 ; while ( 1 ) { u32 nb_bytes = ( u32 ) gf_fread ( chunk , 4096 , fin ) ; gf_fwrite ( chunk , nb_bytes , fout ) ; done += nb_bytes ; fprintf ( stderr , "Appending<S2SV_blank>file<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>%02.2f<S2SV_blank>done\\r" , raw_cat , 100.0 * done / to_copy ) ; if ( done >= to_copy ) break ; } gf_fclose ( fin ) ; gf_fclose ( fout ) ; return mp4box_cleanup ( 0 ) ; } if ( compress_top_boxes ) { if ( size_top_box ) { u64 top_size = do_size_top_boxes ( inName , compress_top_boxes , size_top_box ) ; fprintf ( stdout , LLU "\\n" , top_size ) ; return mp4box_cleanup ( e ? 1 : 0 ) ; } else { e = do_compress_top_boxes ( inName , outName , compress_top_boxes , comp_top_box_version , comp_lzma ) ; return mp4box_cleanup ( e ? 1 : 0 ) ; } } if ( do_mpd_rip ) { e = rip_mpd ( inName , outName ) ; return mp4box_cleanup ( e ? 1 : 0 ) ; } # ifndef GPAC_DISABLE_CORE_TOOLS if ( do_wget != NULL ) { e = gf_dm_wget ( do_wget , inName , 0 , 0 , NULL ) ; if ( e != GF_OK ) { fprintf ( stderr , "Cannot<S2SV_blank>retrieve<S2SV_blank>%s:<S2SV_blank>%s\\n" , do_wget , gf_error_to_string ( e ) ) ; return mp4box_cleanup ( 1 ) ; } return mp4box_cleanup ( 0 ) ; } # endif if ( udp_dest ) { GF_Socket * sock = gf_sk_new ( GF_SOCK_TYPE_UDP ) ; u16 port = 2345 ; char * sep = strrchr ( udp_dest , ':' ) ; if ( sep ) { sep [ 0 ] = 0 ; port = atoi ( sep + 1 ) ; } e = gf_sk_bind ( sock , "127.0.0.1" , 0 , udp_dest , port , 0 ) ; if ( sep ) sep [ 0 ] = ':' ; if ( e ) fprintf ( stderr , "Failed<S2SV_blank>to<S2SV_blank>bind<S2SV_blank>socket<S2SV_blank>to<S2SV_blank>%s:<S2SV_blank>%s\\n" , udp_dest , gf_error_to_string ( e ) ) ; else { e = gf_sk_send ( sock , ( u8 * ) inName , ( u32 ) strlen ( inName ) ) ; if ( e ) fprintf ( stderr , "Failed<S2SV_blank>to<S2SV_blank>send<S2SV_blank>datagram:<S2SV_blank>%s\\n" , gf_error_to_string ( e ) ) ; } gf_sk_del ( sock ) ; return 0 ; } # ifndef GPAC_DISABLE_MPD if ( do_mpd ) { Bool remote = GF_FALSE ; GF_MPD * mpd ; char * mpd_base_url = NULL ; if ( ! strnicmp ( inName , "http://" , 7 ) || ! strnicmp ( inName , "https://" , 8 ) ) { # if ! defined ( GPAC_DISABLE_CORE_TOOLS ) e = gf_dm_wget ( inName , "tmp_main.m3u8" , 0 , 0 , & mpd_base_url ) ; if ( e != GF_OK ) { fprintf ( stderr , "Cannot<S2SV_blank>retrieve<S2SV_blank>M3U8<S2SV_blank>(%s):<S2SV_blank>%s\\n" , inName , gf_error_to_string ( e ) ) ; if ( mpd_base_url ) gf_free ( mpd_base_url ) ; return mp4box_cleanup ( 1 ) ; } remote = GF_TRUE ; # else gf_free ( mpd_base_url ) ; fprintf ( stderr , "HTTP<S2SV_blank>Downloader<S2SV_blank>disabled<S2SV_blank>in<S2SV_blank>this<S2SV_blank>build\\n" ) ; return mp4box_cleanup ( 1 ) ; # endif if ( outName ) strcpy ( outfile , outName ) ; else { const char * sep = gf_file_basename ( inName ) ; char * ext = gf_file_ext_start ( sep ) ; if ( ext ) ext [ 0 ] = 0 ; sprintf ( outfile , "%s.mpd" , sep ) ; if ( ext ) ext [ 0 ] = '.' ; } } else { if ( outName ) strcpy ( outfile , outName ) ; else { char * dst = strdup ( inName ) ; char * ext = strstr ( dst , ".m3u8" ) ; if ( ext ) ext [ 0 ] = 0 ; sprintf ( outfile , "%s.mpd" , dst ) ; gf_free ( dst ) ; } } mpd = gf_mpd_new ( ) ; if ( ! mpd ) { e = GF_OUT_OF_MEM ; fprintf ( stderr , "[DASH]<S2SV_blank>Error:<S2SV_blank>MPD<S2SV_blank>creation<S2SV_blank>problem<S2SV_blank>%s\\n" , gf_error_to_string ( e ) ) ; mp4box_cleanup ( 1 ) ; } FILE * f = gf_fopen ( remote ? "tmp_main.m3u8" : inName , "r" ) ; u32 manif_type = 0 ; if ( f ) { char szDATA [ 1000 ] ; s32 read ; szDATA [ 999 ] = 0 ; read = ( s32 ) gf_fread ( szDATA , 999 , f ) ; if ( read < 0 ) read = 0 ; szDATA [ read ] = 0 ; gf_fclose ( f ) ; if ( strstr ( szDATA , "SmoothStreamingMedia" ) ) manif_type = 2 ; else if ( strstr ( szDATA , "#EXTM3U" ) ) manif_type = 1 ; } if ( manif_type == 1 ) { e = gf_m3u8_to_mpd ( remote ? "tmp_main.m3u8" : inName , mpd_base_url ? mpd_base_url : inName , outfile , 0 , "video/mp2t" , GF_TRUE , use_url_template , segment_timeline , NULL , mpd , GF_TRUE , GF_TRUE ) ; } else if ( manif_type == 2 ) { e = gf_mpd_smooth_to_mpd ( remote ? "tmp_main.m3u8" : inName , mpd , mpd_base_url ? mpd_base_url : inName ) ; } else { e = GF_NOT_SUPPORTED ; } if ( ! e ) gf_mpd_write_file ( mpd , outfile ) ; if ( mpd ) gf_mpd_del ( mpd ) ; if ( mpd_base_url ) gf_free ( mpd_base_url ) ; if ( remote ) { gf_file_delete ( "tmp_main.m3u8" ) ; } if ( e != GF_OK ) { fprintf ( stderr , "Error<S2SV_blank>converting<S2SV_blank>%s<S2SV_blank>(%s)<S2SV_blank>to<S2SV_blank>MPD<S2SV_blank>(%s):<S2SV_blank>%s\\n" , ( manif_type == 1 ) ? "HLS" : "Smooth" , inName , outfile , gf_error_to_string ( e ) ) ; return mp4box_cleanup ( 1 ) ; } else { fprintf ( stderr , "Done<S2SV_blank>converting<S2SV_blank>%s<S2SV_blank>(%s)<S2SV_blank>to<S2SV_blank>MPD<S2SV_blank>(%s)\\n" , ( manif_type == 1 ) ? "HLS" : "Smooth" , inName , outfile ) ; return mp4box_cleanup ( 0 ) ; } } # endif if ( dash_duration && ! nb_dash_inputs ) { dash_inputs = set_dash_input ( dash_inputs , inName , & nb_dash_inputs ) ; } if ( do_saf && ! encode ) { switch ( get_file_type_by_ext ( inName ) ) { case GF_FILE_TYPE_BT_WRL_X3DV : case GF_FILE_TYPE_XMT_X3D : case GF_FILE_TYPE_SVG : encode = GF_TRUE ; break ; case GF_FILE_TYPE_NOT_SUPPORTED : case GF_FILE_TYPE_ISO_MEDIA : case GF_FILE_TYPE_SWF : case GF_FILE_TYPE_LSR_SAF : break ; } } # ifndef GPAC_DISABLE_SCENE_DUMP if ( dump_mode == GF_SM_DUMP_SVG ) { if ( strstr ( inName , ".srt" ) || strstr ( inName , ".ttxt" ) ) import_subtitle = 2 ; } # endif if ( import_subtitle && ! trackID ) { # ifndef GPAC_DISABLE_MEDIA_IMPORT GF_MediaImporter import ; file = gf_isom_open ( "ttxt_convert" , GF_ISOM_OPEN_WRITE , NULL ) ; if ( timescale && file ) gf_isom_set_timescale ( file , timescale ) ; memset ( & import , 0 , sizeof ( GF_MediaImporter ) ) ; import . dest = file ; import . in_name = inName ; e = gf_media_import ( & import ) ; if ( e ) { fprintf ( stderr , "Error<S2SV_blank>importing<S2SV_blank>%s:<S2SV_blank>%s\\n" , inName , gf_error_to_string ( e ) ) ; gf_isom_delete ( file ) ; gf_file_delete ( "ttxt_convert" ) ; return mp4box_cleanup ( 1 ) ; } strcpy ( outfile , inName ) ; if ( strchr ( outfile , '.' ) ) { while ( outfile [ strlen ( outfile ) - 1 ] != '.' ) outfile [ strlen ( outfile ) - 1 ] = 0 ; outfile [ strlen ( outfile ) - 1 ] = 0 ; } # ifndef GPAC_DISABLE_ISOM_DUMP dump_isom_timed_text ( file , gf_isom_get_track_id ( file , 1 ) , dump_std ? NULL : ( outName ? outName : outfile ) , outName ? GF_TRUE : GF_FALSE , GF_TRUE , ( import_subtitle == 2 ) ? GF_TEXTDUMPTYPE_SVG : ( dump_srt ? GF_TEXTDUMPTYPE_SRT : GF_TEXTDUMPTYPE_TTXT ) ) ; # endif gf_isom_delete ( file ) ; gf_file_delete ( "ttxt_convert" ) ; if ( e ) { fprintf ( stderr , "Error<S2SV_blank>converting<S2SV_blank>%s:<S2SV_blank>%s\\n" , inName , gf_error_to_string ( e ) ) ; return mp4box_cleanup ( 1 ) ; } return mp4box_cleanup ( 0 ) ; # else fprintf ( stderr , "Feature<S2SV_blank>not<S2SV_blank>supported\\n" ) ; return mp4box_cleanup ( 1 ) ; # endif } # if ! defined ( GPAC_DISABLE_MEDIA_IMPORT ) && ! defined ( GPAC_DISABLE_ISOM_WRITE ) if ( nb_add || nb_cat ) { u32 ipass , nb_pass = 1 ; char * mux_args = NULL ; GF_FilterSession * fs = NULL ; if ( nb_add ) { GF_ISOOpenMode open_mode = GF_ISOM_OPEN_EDIT ; if ( force_new ) { open_mode = ( do_flat || ( force_new == 2 ) ) ? GF_ISOM_OPEN_WRITE : GF_ISOM_WRITE_EDIT ; } else { FILE * test = gf_fopen ( inName , "rb" ) ; if ( ! test ) { open_mode = ( do_flat ) ? GF_ISOM_OPEN_WRITE : GF_ISOM_WRITE_EDIT ; if ( ! outName ) outName = inName ; } else { gf_fclose ( test ) ; if ( ! gf_isom_probe_file ( inName ) ) { open_mode = ( do_flat ) ? GF_ISOM_OPEN_WRITE : GF_ISOM_WRITE_EDIT ; if ( ! outName ) outName = inName ; } } } open_edit = do_flat ? GF_FALSE : GF_TRUE ; file = gf_isom_open ( inName , open_mode , tmpdir ) ; if ( ! file ) { fprintf ( stderr , "Cannot<S2SV_blank>open<S2SV_blank>destination<S2SV_blank>file<S2SV_blank>%s:<S2SV_blank>%s\\n" , inName , gf_error_to_string ( gf_isom_last_error ( NULL ) ) ) ; return mp4box_cleanup ( 1 ) ; } if ( freeze_box_order ) gf_isom_freeze_order ( file ) ; } if ( do_flat && interleaving_time ) { char szSubArg [ 100 ] ; gf_isom_set_storage_mode ( file , GF_ISOM_STORE_FASTSTART ) ; do_flat = 2 ; nb_pass = 2 ; fs = gf_fs_new_defaults ( 0 ) ; if ( ! fs ) { fprintf ( stderr , "Error<S2SV_blank>creating<S2SV_blank>filter<S2SV_blank>session\\n" ) ; gf_isom_delete ( file ) ; return mp4box_cleanup ( 1 ) ; } gf_dynstrcat ( & mux_args , "mp4mx:importer:store=fstart" , ":" ) ; sprintf ( szSubArg , "file=%p" , file ) ; gf_dynstrcat ( & mux_args , szSubArg , ":" ) ; sprintf ( szSubArg , "cdur=%g" , interleaving_time ) ; gf_dynstrcat ( & mux_args , szSubArg , ":" ) ; } for ( ipass = 0 ; ipass < nb_pass ; ipass ++ ) { u32 tk_idx = 1 ; for ( i = 0 ; i < ( u32 ) argc ; i ++ ) { char * margs = NULL ; if ( ! strcmp ( argv [ i ] , "-add" ) ) { char * src = argv [ i + 1 ] ; while ( src ) { char * loc_src = src ; char * sep = NULL ; while ( 1 ) { char * opt_sep ; sep = strchr ( loc_src , '+' ) ; if ( ! sep ) break ; sep [ 0 ] = 0 ; if ( strstr ( src , "://" ) ) break ; opt_sep = gf_url_colon_suffix ( src ) ; if ( opt_sep ) opt_sep [ 0 ] = 0 ; if ( gf_file_exists ( src ) ) { if ( opt_sep ) opt_sep [ 0 ] = ':' ; break ; } if ( opt_sep ) opt_sep [ 0 ] = ':' ; sep [ 0 ] = '+' ; loc_src = sep + 1 ; } e = import_file ( file , src , import_flags , import_fps , agg_samples , fs , ( fs && ( ipass == 0 ) ) ? & margs : NULL , tk_idx ) ; tk_idx ++ ; if ( margs ) { gf_dynstrcat ( & mux_args , margs , ":" ) ; gf_free ( margs ) ; } if ( e ) { fprintf ( stderr , "Error<S2SV_blank>importing<S2SV_blank>%s:<S2SV_blank>%s\\n" , argv [ i + 1 ] , gf_error_to_string ( e ) ) ; gf_isom_delete ( file ) ; if ( fs ) gf_fs_del ( fs ) ; return mp4box_cleanup ( 1 ) ; } if ( sep ) { sep [ 0 ] = '+' ; src = sep + 1 ; } else { break ; } } i ++ ; } else if ( ! strcmp ( argv [ i ] , "-cat" ) || ! strcmp ( argv [ i ] , "-catx" ) || ! strcmp ( argv [ i ] , "-catpl" ) ) { if ( nb_pass == 2 ) { fprintf ( stderr , "Cannot<S2SV_blank>cat<S2SV_blank>files<S2SV_blank>when<S2SV_blank>using<S2SV_blank>-newfs<S2SV_blank>mode\\n" ) ; return mp4box_cleanup ( 1 ) ; } if ( ! file ) { u8 open_mode = GF_ISOM_OPEN_EDIT ; if ( force_new ) { open_mode = ( do_flat ) ? GF_ISOM_OPEN_WRITE : GF_ISOM_WRITE_EDIT ; } else { FILE * test = gf_fopen ( inName , "rb" ) ; if ( ! test ) { open_mode = ( do_flat ) ? GF_ISOM_OPEN_WRITE : GF_ISOM_WRITE_EDIT ; if ( ! outName ) outName = inName ; } else gf_fclose ( test ) ; } open_edit = GF_TRUE ; file = gf_isom_open ( inName , open_mode , tmpdir ) ; if ( ! file ) { fprintf ( stderr , "Cannot<S2SV_blank>open<S2SV_blank>destination<S2SV_blank>file<S2SV_blank>%s:<S2SV_blank>%s\\n" , inName , gf_error_to_string ( gf_isom_last_error ( NULL ) ) ) ; return mp4box_cleanup ( 1 ) ; } } e = cat_isomedia_file ( file , argv [ i + 1 ] , import_flags , import_fps , agg_samples , tmpdir , force_cat , align_cat , ! strcmp ( argv [ i ] , "-catx" ) ? GF_TRUE : GF_FALSE , ! strcmp ( argv [ i ] , "-catpl" ) ? GF_TRUE : GF_FALSE ) ; if ( e ) { fprintf ( stderr , "Error<S2SV_blank>appending<S2SV_blank>%s:<S2SV_blank>%s\\n" , argv [ i + 1 ] , gf_error_to_string ( e ) ) ; gf_isom_delete ( file ) ; return mp4box_cleanup ( 1 ) ; } i ++ ; } } if ( ( nb_pass == 2 ) && ! ipass ) { GF_Filter * mux_filter = gf_fs_load_filter ( fs , mux_args , NULL ) ; gf_free ( mux_args ) ; if ( ! mux_filter ) { fprintf ( stderr , "Error<S2SV_blank>loadin<S2SV_blank>isobmff<S2SV_blank>mux<S2SV_blank>filter\\n" ) ; gf_isom_delete ( file ) ; gf_fs_del ( fs ) ; return mp4box_cleanup ( 1 ) ; } e = gf_fs_run ( fs ) ; if ( e == GF_EOS ) e = GF_OK ; if ( ! e ) e = gf_fs_get_last_connect_error ( fs ) ; if ( ! e ) e = gf_fs_get_last_process_error ( fs ) ; if ( e ) { fprintf ( stderr , "Error<S2SV_blank>importing<S2SV_blank>sources:<S2SV_blank>%s\\n" , gf_error_to_string ( e ) ) ; gf_isom_delete ( file ) ; gf_fs_del ( fs ) ; return mp4box_cleanup ( 1 ) ; } } } if ( fs ) { if ( fs_dump_flags & 1 ) gf_fs_print_stats ( fs ) ; if ( fs_dump_flags & 2 ) gf_fs_print_connections ( fs ) ; gf_fs_del ( fs ) ; } # ifndef GPAC_DISABLE_AV_PARSERS if ( ! keep_sys_tracks ) remove_systems_tracks ( file ) ; # endif needSave = GF_TRUE ; } # endif # if ! defined ( GPAC_DISABLE_ISOM_WRITE ) && ! defined ( GPAC_DISABLE_SCENE_ENCODER ) && ! defined ( GPAC_DISABLE_MEDIA_IMPORT ) else if ( chunk_mode ) { if ( ! inName ) { fprintf ( stderr , "chunk<S2SV_blank>encoding<S2SV_blank>syntax:<S2SV_blank>[-outctx<S2SV_blank>outDump]<S2SV_blank>-inctx<S2SV_blank>inScene<S2SV_blank>auFile\\n" ) ; return mp4box_cleanup ( 1 ) ; } e = EncodeFileChunk ( inName , outName ? outName : inName , input_ctx , output_ctx , tmpdir ) ; if ( e ) { fprintf ( stderr , "Error<S2SV_blank>encoding<S2SV_blank>chunk<S2SV_blank>file<S2SV_blank>%s\\n" , gf_error_to_string ( e ) ) ; return mp4box_cleanup ( 1 ) ; } goto exit ; } # endif else if ( encode ) { # if ! defined ( GPAC_DISABLE_ISOM_WRITE ) && ! defined ( GPAC_DISABLE_SCENE_ENCODER ) && ! defined ( GPAC_DISABLE_MEDIA_IMPORT ) FILE * logs = NULL ; if ( do_scene_log ) { char alogfile [ GF_MAX_PATH ] ; strcpy ( alogfile , inName ) ; if ( strchr ( alogfile , '.' ) ) { while ( alogfile [ strlen ( alogfile ) - 1 ] != '.' ) alogfile [ strlen ( alogfile ) - 1 ] = 0 ; alogfile [ strlen ( alogfile ) - 1 ] = 0 ; } strcat ( alogfile , "_enc.logs" ) ; logs = gf_fopen ( alogfile , "wt" ) ; } strcpy ( outfile , outName ? outName : inName ) ; if ( strchr ( outfile , '.' ) ) { while ( outfile [ strlen ( outfile ) - 1 ] != '.' ) outfile [ strlen ( outfile ) - 1 ] = 0 ; outfile [ strlen ( outfile ) - 1 ] = 0 ; } strcat ( outfile , ".mp4" ) ; file = gf_isom_open ( outfile , GF_ISOM_WRITE_EDIT , tmpdir ) ; smenc_opts . mediaSource = mediaSource ? mediaSource : outfile ; e = EncodeFile ( inName , file , & smenc_opts , logs ) ; if ( logs ) gf_fclose ( logs ) ; if ( e ) goto err_exit ; needSave = GF_TRUE ; if ( do_saf ) { needSave = GF_FALSE ; open_edit = GF_FALSE ; } # endif } # ifndef GPAC_DISABLE_ISOM_WRITE else if ( pack_file ) { char * fileName = gf_url_colon_suffix ( pack_file ) ; if ( fileName && ( ( fileName - pack_file ) == 4 ) ) { fileName [ 0 ] = 0 ; file = package_file ( fileName + 1 , pack_file , tmpdir , pack_wgt ) ; fileName [ 0 ] = ':' ; } else { file = package_file ( pack_file , NULL , tmpdir , pack_wgt ) ; if ( ! file ) { fprintf ( stderr , "Failed<S2SV_blank>to<S2SV_blank>package<S2SV_blank>file\\n" ) ; return mp4box_cleanup ( 1 ) ; } } if ( ! outName ) outName = inName ; needSave = GF_TRUE ; open_edit = GF_TRUE ; } # endif if ( dash_duration ) { Bool del_file = GF_FALSE ; char szMPD [ GF_MAX_PATH ] , * sep ; char szStateFile [ GF_MAX_PATH ] ; Bool dyn_state_file = GF_FALSE ; u32 do_abort = 0 ; GF_DASHSegmenter * dasher = NULL ; if ( crypt ) { fprintf ( stderr , "MP4Box<S2SV_blank>cannot<S2SV_blank>crypt<S2SV_blank>and<S2SV_blank>DASH<S2SV_blank>on<S2SV_blank>the<S2SV_blank>same<S2SV_blank>pass.<S2SV_blank>Please<S2SV_blank>encrypt<S2SV_blank>your<S2SV_blank>content<S2SV_blank>first.\\n" ) ; return mp4box_cleanup ( 1 ) ; } strcpy ( outfile , outName ? outName : gf_url_get_resource_name ( inName ) ) ; sep = strrchr ( outfile , '.' ) ; if ( sep ) sep [ 0 ] = 0 ; if ( ! outName ) strcat ( outfile , "_dash" ) ; strcpy ( szMPD , outfile ) ; if ( outName && sep ) { sep [ 0 ] = '.' ; strcat ( szMPD , sep ) ; } else { strcat ( szMPD , ".mpd" ) ; } if ( ( dash_subduration > 0 ) && ( dash_duration > dash_subduration ) ) { fprintf ( stderr , "Warning:<S2SV_blank>-subdur<S2SV_blank>parameter<S2SV_blank>(%g<S2SV_blank>s)<S2SV_blank>should<S2SV_blank>be<S2SV_blank>greater<S2SV_blank>than<S2SV_blank>segment<S2SV_blank>duration<S2SV_blank>(%g<S2SV_blank>s),<S2SV_blank>using<S2SV_blank>segment<S2SV_blank>duration<S2SV_blank>instead\\n" , dash_subduration , dash_duration ) ; dash_subduration = dash_duration ; } if ( dash_mode && dash_live ) fprintf ( stderr , "Live<S2SV_blank>DASH-ing<S2SV_blank>-<S2SV_blank>press<S2SV_blank>\'q\'<S2SV_blank>to<S2SV_blank>quit,<S2SV_blank>\'s\'<S2SV_blank>to<S2SV_blank>save<S2SV_blank>context<S2SV_blank>and<S2SV_blank>quit\\n" ) ; if ( ! dash_ctx_file && dash_live ) { u32 r1 ; u64 add = ( u64 ) ( intptr_t ) & dasher ; add ^= gf_net_get_utc ( ) ; r1 = ( u32 ) add ^ ( u32 ) ( add / 0xFFFFFFFF ) ; r1 ^= gf_rand ( ) ; sprintf ( szStateFile , "%s/dasher_%X.xml" , gf_get_default_cache_directory ( ) , r1 ) ; dash_ctx_file = szStateFile ; dyn_state_file = GF_TRUE ; } else if ( dash_ctx_file ) { if ( force_new ) gf_file_delete ( dash_ctx_file ) ; } if ( dash_profile == GF_DASH_PROFILE_AUTO ) dash_profile = dash_mode ? GF_DASH_PROFILE_LIVE : GF_DASH_PROFILE_FULL ; if ( ! dash_mode ) { time_shift_depth = 0 ; mpd_update_time = 0 ; } else if ( ( dash_profile >= GF_DASH_PROFILE_MAIN ) && ! use_url_template && ! mpd_update_time ) { mpd_update_time = ( Double ) ( dash_subduration ? dash_subduration : dash_duration ) ; fprintf ( stderr , "Using<S2SV_blank>default<S2SV_blank>MPD<S2SV_blank>refresh<S2SV_blank>of<S2SV_blank>%g<S2SV_blank>seconds\\n" , mpd_update_time ) ; } if ( file && needSave ) { gf_isom_close ( file ) ; file = NULL ; del_file = GF_TRUE ; } dasher = gf_dasher_new ( szMPD , dash_profile , tmpdir , dash_scale , dash_ctx_file ) ; if ( ! dasher ) { return mp4box_cleanup ( 1 ) ; } e = gf_dasher_set_info ( dasher , dash_title , cprt , dash_more_info , dash_source , NULL ) ; if ( e ) { fprintf ( stderr , "DASH<S2SV_blank>Error:<S2SV_blank>%s\\n" , gf_error_to_string ( e ) ) ; gf_dasher_del ( dasher ) ; return mp4box_cleanup ( 1 ) ; } gf_dasher_set_start_date ( dasher , dash_start_date ) ; gf_dasher_set_location ( dasher , dash_source ) ; for ( i = 0 ; i < nb_mpd_base_urls ; i ++ ) { e = gf_dasher_add_base_url ( dasher , mpd_base_urls [ i ] ) ; if ( e ) { fprintf ( stderr , "DASH<S2SV_blank>Error:<S2SV_blank>%s\\n" , gf_error_to_string ( e ) ) ; gf_dasher_del ( dasher ) ; return mp4box_cleanup ( 1 ) ; } } if ( segment_timeline && ! use_url_template ) { fprintf ( stderr , "DASH<S2SV_blank>Warning:<S2SV_blank>using<S2SV_blank>-segment-timeline<S2SV_blank>with<S2SV_blank>no<S2SV_blank>-url-template.<S2SV_blank>Forcing<S2SV_blank>URL<S2SV_blank>template.\\n" ) ; use_url_template = GF_TRUE ; } e = gf_dasher_enable_url_template ( dasher , ( Bool ) use_url_template , seg_name , seg_ext , init_seg_ext ) ; if ( ! e ) e = gf_dasher_enable_segment_timeline ( dasher , segment_timeline ) ; if ( ! e ) e = gf_dasher_enable_single_segment ( dasher , single_segment ) ; if ( ! e ) e = gf_dasher_enable_single_file ( dasher , single_file ) ; if ( ! e ) e = gf_dasher_set_switch_mode ( dasher , bitstream_switching_mode ) ; if ( ! e ) e = gf_dasher_set_durations ( dasher , dash_duration , interleaving_time , dash_subduration ) ; if ( ! e ) e = gf_dasher_enable_rap_splitting ( dasher , seg_at_rap , frag_at_rap ) ; if ( ! e ) e = gf_dasher_set_segment_marker ( dasher , segment_marker ) ; if ( ! e ) e = gf_dasher_enable_sidx ( dasher , ( subsegs_per_sidx >= 0 ) ? 1 : 0 , ( u32 ) subsegs_per_sidx , daisy_chain_sidx , use_ssix ) ; if ( ! e ) e = gf_dasher_set_dynamic_mode ( dasher , dash_mode , mpd_update_time , time_shift_depth , mpd_live_duration ) ; if ( ! e ) e = gf_dasher_set_min_buffer ( dasher , min_buffer ) ; if ( ! e ) e = gf_dasher_set_ast_offset ( dasher , ast_offset_ms ) ; if ( ! e ) e = gf_dasher_enable_memory_fragmenting ( dasher , memory_frags ) ; if ( ! e ) e = gf_dasher_set_initial_isobmf ( dasher , initial_moof_sn , initial_tfdt ) ; if ( ! e ) e = gf_dasher_configure_isobmf_default ( dasher , no_fragments_defaults , pssh_mode , samplegroups_in_traf , single_traf_per_moof , tfdt_per_traf , mvex_after_traks , sdtp_in_traf ) ; if ( ! e ) e = gf_dasher_enable_utc_ref ( dasher , insert_utc ) ; if ( ! e ) e = gf_dasher_enable_real_time ( dasher , frag_real_time ) ; if ( ! e ) e = gf_dasher_set_content_protection_location_mode ( dasher , cp_location_mode ) ; if ( ! e ) e = gf_dasher_set_profile_extension ( dasher , dash_profile_extension ) ; if ( ! e ) e = gf_dasher_enable_cached_inputs ( dasher , no_cache ) ; if ( ! e ) e = gf_dasher_enable_loop_inputs ( dasher , ! no_loop ) ; if ( ! e ) e = gf_dasher_set_split_mode ( dasher , dash_split_mode ) ; if ( ! e ) e = gf_dasher_set_hls_clock ( dasher , hls_clock ) ; if ( ! e && dash_cues ) e = gf_dasher_set_cues ( dasher , dash_cues , strict_cues ) ; if ( ! e && fs_dump_flags ) e = gf_dasher_print_session_info ( dasher , fs_dump_flags ) ; for ( i = 0 ; i < nb_dash_inputs ; i ++ ) { if ( ! e ) e = gf_dasher_add_input ( dasher , & dash_inputs [ i ] ) ; } if ( e ) { fprintf ( stderr , "DASH<S2SV_blank>Setup<S2SV_blank>Error:<S2SV_blank>%s\\n" , gf_error_to_string ( e ) ) ; gf_dasher_del ( dasher ) ; return mp4box_cleanup ( 1 ) ; } dash_cumulated_time = 0 ; while ( 1 ) { if ( run_for && ( dash_cumulated_time >= run_for ) ) { fprintf ( stderr , "Done<S2SV_blank>running,<S2SV_blank>computing<S2SV_blank>static<S2SV_blank>MPD\\n" ) ; do_abort = 3 ; } dash_prev_time = gf_sys_clock ( ) ; if ( do_abort >= 2 ) { e = gf_dasher_set_dynamic_mode ( dasher , GF_DASH_DYNAMIC_LAST , 0 , time_shift_depth , mpd_live_duration ) ; } if ( ! e ) e = gf_dasher_process ( dasher ) ; if ( ! dash_live && ( e == GF_EOS ) ) { fprintf ( stderr , "Nothing<S2SV_blank>to<S2SV_blank>dash,<S2SV_blank>too<S2SV_blank>early<S2SV_blank>...\\n" ) ; e = GF_OK ; } if ( do_abort ) break ; if ( dash_live && ( e == GF_IO_ERR ) ) { fprintf ( stderr , "Error<S2SV_blank>dashing<S2SV_blank>file<S2SV_blank>(%s)<S2SV_blank>but<S2SV_blank>continuing<S2SV_blank>...\\n" , gf_error_to_string ( e ) ) ; e = GF_OK ; } if ( e ) break ; if ( dash_live ) { u64 ms_in_session = 0 ; u32 slept = gf_sys_clock ( ) ; u32 sleep_for = gf_dasher_next_update_time ( dasher , & ms_in_session ) ; fprintf ( stderr , "Next<S2SV_blank>generation<S2SV_blank>scheduled<S2SV_blank>in<S2SV_blank>%u<S2SV_blank>ms<S2SV_blank>(DASH<S2SV_blank>time<S2SV_blank>" LLU "<S2SV_blank>ms)\\r" , sleep_for , ms_in_session ) ; if ( run_for && ( ms_in_session >= run_for ) ) { dash_cumulated_time = 1 + run_for ; continue ; } while ( 1 ) { if ( gf_prompt_has_input ( ) ) { char c = ( char ) gf_prompt_get_char ( ) ; if ( c == 'X' ) { do_abort = 1 ; break ; } if ( c == 'q' ) { do_abort = 2 ; break ; } if ( c == 's' ) { do_abort = 3 ; break ; } } if ( dash_mode == GF_DASH_DYNAMIC_DEBUG ) { break ; } if ( ! sleep_for ) break ; gf_sleep ( sleep_for / 10 ) ; sleep_for = gf_dasher_next_update_time ( dasher , NULL ) ; if ( sleep_for <= 1 ) { dash_now_time = gf_sys_clock ( ) ; dash_cumulated_time += ( dash_now_time - dash_prev_time ) ; fprintf ( stderr , "Slept<S2SV_blank>for<S2SV_blank>%d<S2SV_blank>ms<S2SV_blank>before<S2SV_blank>generation,<S2SV_blank>dash<S2SV_blank>cumulated<S2SV_blank>time<S2SV_blank>%d\\n" , dash_now_time - slept , dash_cumulated_time ) ; break ; } } } else { break ; } } gf_dasher_del ( dasher ) ; if ( ! run_for && dash_ctx_file && ( do_abort == 3 ) && ( dyn_state_file ) && ! gf_sys_is_test_mode ( ) ) { char szName [ 1024 ] ; fprintf ( stderr , "Enter<S2SV_blank>file<S2SV_blank>name<S2SV_blank>to<S2SV_blank>save<S2SV_blank>dash<S2SV_blank>context:\\n" ) ; if ( scanf ( "%1023s" , szName ) == 1 ) { gf_file_move ( dash_ctx_file , szName ) ; } } if ( e ) fprintf ( stderr , "Error<S2SV_blank>DASHing<S2SV_blank>file:<S2SV_blank>%s\\n" , gf_error_to_string ( e ) ) ; if ( file ) gf_isom_delete ( file ) ; if ( del_file ) gf_file_delete ( inName ) ; if ( e ) return mp4box_cleanup ( 1 ) ; goto exit ; } else if ( ! file && ! do_hash # ifndef GPAC_DISABLE_MEDIA_EXPORT && ! ( track_dump_type & GF_EXPORT_AVI_NATIVE ) # endif ) { FILE * st = gf_fopen ( inName , "rb" ) ; Bool file_exists = 0 ; GF_ISOOpenMode omode ; if ( st ) { file_exists = 1 ; gf_fclose ( st ) ; } switch ( get_file_type_by_ext ( inName ) ) { case 1 : omode = ( u8 ) ( force_new ? GF_ISOM_WRITE_EDIT : ( open_edit ? GF_ISOM_OPEN_EDIT : ( ( ( dump_isom > 0 ) || print_info ) ? GF_ISOM_OPEN_READ_DUMP : GF_ISOM_OPEN_READ ) ) ) ; if ( crypt ) { omode = GF_ISOM_OPEN_READ ; if ( use_init_seg ) file = gf_isom_open ( use_init_seg , GF_ISOM_OPEN_READ , tmpdir ) ; } if ( ! crypt && use_init_seg ) { file = gf_isom_open ( use_init_seg , GF_ISOM_OPEN_READ_DUMP , tmpdir ) ; if ( file ) { e = gf_isom_open_segment ( file , inName , 0 , 0 , 0 ) ; if ( e ) { fprintf ( stderr , "Error<S2SV_blank>opening<S2SV_blank>segment<S2SV_blank>%s:<S2SV_blank>%s\\n" , inName , gf_error_to_string ( e ) ) ; gf_isom_delete ( file ) ; file = NULL ; } } } if ( ! file ) file = gf_isom_open ( inName , omode , tmpdir ) ; if ( ! file && ( gf_isom_last_error ( NULL ) == GF_ISOM_INCOMPLETE_FILE ) && ! open_edit ) { u64 missing_bytes ; e = gf_isom_open_progressive ( inName , 0 , 0 , GF_FALSE , & file , & missing_bytes ) ; fprintf ( stderr , "Truncated<S2SV_blank>file<S2SV_blank>-<S2SV_blank>missing<S2SV_blank>" LLD "<S2SV_blank>bytes\\n" , missing_bytes ) ; } if ( ! file ) { if ( open_edit && nb_meta_act ) { file = gf_isom_open ( inName , GF_ISOM_WRITE_EDIT , tmpdir ) ; if ( ! outName && file ) outName = inName ; } if ( ! file ) { fprintf ( stderr , "Error<S2SV_blank>opening<S2SV_blank>file<S2SV_blank>%s:<S2SV_blank>%s\\n" , inName , gf_error_to_string ( gf_isom_last_error ( NULL ) ) ) ; return mp4box_cleanup ( 1 ) ; } } if ( freeze_box_order ) gf_isom_freeze_order ( file ) ; break ; case 2 : case 3 : case 4 : case 5 : break ; case 6 : # ifndef GPAC_DISABLE_SCENE_DUMP if ( ( dump_mode == GF_SM_DUMP_LASER ) || ( dump_mode == GF_SM_DUMP_SVG ) ) { break ; } # endif default : if ( ! open_edit && file_exists && ! gf_isom_probe_file ( inName ) && track_dump_type ) { } # ifndef GPAC_DISABLE_ISOM_WRITE else if ( ! open_edit && file_exists # ifndef GPAC_DISABLE_SCENE_DUMP && dump_mode == GF_SM_DUMP_NONE # endif ) { # ifndef GPAC_DISABLE_MEDIA_IMPORT if ( dvbhdemux ) { GF_MediaImporter import ; file = gf_isom_open ( "ttxt_convert" , GF_ISOM_OPEN_WRITE , NULL ) ; memset ( & import , 0 , sizeof ( GF_MediaImporter ) ) ; import . dest = file ; import . in_name = inName ; import . flags = GF_IMPORT_MPE_DEMUX ; e = gf_media_import ( & import ) ; if ( e ) { fprintf ( stderr , "Error<S2SV_blank>importing<S2SV_blank>%s:<S2SV_blank>%s\\n" , inName , gf_error_to_string ( e ) ) ; gf_isom_delete ( file ) ; gf_file_delete ( "ttxt_convert" ) ; return mp4box_cleanup ( 1 ) ; } } # endif if ( dump_m2ts ) { # ifndef GPAC_DISABLE_MPEG2TS dump_mpeg2_ts ( inName , pes_dump , program_number ) ; # endif } else if ( dump_timestamps ) { # ifndef GPAC_DISABLE_MPEG2TS dump_mpeg2_ts ( inName , pes_dump , program_number ) ; # endif # ifndef GPAC_DISABLE_CORE_TOOLS } else if ( do_bin_xml ) { xml_bs_to_bin ( inName , outName , dump_std ) ; # endif } else if ( do_hash ) { hash_file ( inName , dump_std ) ; } else if ( print_info ) { # ifndef GPAC_DISABLE_MEDIA_IMPORT convert_file_info ( inName , info_track_id ) ; # endif } else { fprintf ( stderr , "Input<S2SV_blank>%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>an<S2SV_blank>MP4<S2SV_blank>file,<S2SV_blank>operation<S2SV_blank>not<S2SV_blank>allowed\\n" , inName ) ; return mp4box_cleanup ( 1 ) ; } goto exit ; } # endif else if ( open_edit ) { file = gf_isom_open ( inName , GF_ISOM_WRITE_EDIT , tmpdir ) ; if ( ! outName && file ) outName = inName ; } else if ( ! file_exists ) { fprintf ( stderr , "Error<S2SV_blank>creating<S2SV_blank>file<S2SV_blank>%s:<S2SV_blank>%s\\n" , inName , gf_error_to_string ( GF_URL_ERROR ) ) ; return mp4box_cleanup ( 1 ) ; } else { fprintf ( stderr , "Cannot<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>extension<S2SV_blank>not<S2SV_blank>supported\\n" , inName ) ; return mp4box_cleanup ( 1 ) ; } } } if ( high_dynamc_range_filename ) { e = parse_high_dynamc_range_xml_desc ( file , high_dynamc_range_filename ) ; if ( e ) goto err_exit ; } if ( file && keep_utc && open_edit ) { gf_isom_keep_utc_times ( file , 1 ) ; } strcpy ( outfile , outName ? outName : inName ) ; { char * szExt = gf_file_ext_start ( outfile ) ; if ( szExt ) { if ( ! stricmp ( szExt , ".3gp" ) || ! stricmp ( szExt , ".3gpp" ) || ! stricmp ( szExt , ".3g2" ) ) conv_type = GF_ISOM_CONV_TYPE_3GPP ; else if ( ! stricmp ( szExt , ".m4a" ) || ! stricmp ( szExt , ".m4v" ) ) conv_type = GF_ISOM_CONV_TYPE_IPOD ; else if ( ! stricmp ( szExt , ".psp" ) ) conv_type = GF_ISOM_CONV_TYPE_PSP ; else if ( ! stricmp ( szExt , ".mov" ) || ! stricmp ( szExt , ".qt" ) ) conv_type = GF_ISOM_CONV_TYPE_MOV ; * szExt = 0 ; } } # ifndef GPAC_DISABLE_MEDIA_EXPORT if ( track_dump_type & GF_EXPORT_AVI_NATIVE ) { char szFile [ GF_MAX_PATH + 24 ] ; GF_MediaExporter mdump ; memset ( & mdump , 0 , sizeof ( mdump ) ) ; mdump . in_name = inName ; mdump . flags = GF_EXPORT_AVI_NATIVE ; mdump . trackID = trackID ; if ( dump_std ) { mdump . out_name = "std" ; } else if ( outName ) { mdump . out_name = outName ; } else if ( trackID > 2 ) { sprintf ( szFile , "%s_audio%d" , outfile , trackID - 1 ) ; mdump . out_name = szFile ; } else { sprintf ( szFile , "%s_%s" , outfile , ( trackID == 1 ) ? "video" : "audio" ) ; mdump . out_name = szFile ; } mdump . print_stats_graph = fs_dump_flags ; e = gf_media_export ( & mdump ) ; if ( e ) goto err_exit ; goto exit ; } if ( ! open_edit && track_dump_type && ! gf_isom_probe_file ( inName ) ) { GF_MediaExporter mdump ; char szFile [ GF_MAX_PATH + 24 ] ; for ( i = 0 ; i < nb_track_act ; i ++ ) { TrackAction * tka = & tracks [ i ] ; if ( tka -> act_type != TRAC_ACTION_RAW_EXTRACT ) continue ; memset ( & mdump , 0 , sizeof ( mdump ) ) ; mdump . in_name = inName ; mdump . flags = tka -> dump_type ; mdump . trackID = tka -> trackID ; mdump . sample_num = tka -> sample_num ; if ( outName ) { mdump . out_name = outName ; mdump . flags |= GF_EXPORT_MERGE ; } else if ( nb_track_act > 1 ) { sprintf ( szFile , "%s_track%d" , outfile , mdump . trackID ) ; mdump . out_name = szFile ; } else { mdump . out_name = outfile ; } mdump . print_stats_graph = fs_dump_flags ; e = gf_media_export ( & mdump ) ; if ( e ) goto err_exit ; } goto exit ; } # endif # ifndef GPAC_DISABLE_SCENE_DUMP if ( dump_mode != GF_SM_DUMP_NONE ) { e = dump_isom_scene ( inName , dump_std ? NULL : ( outName ? outName : outfile ) , outName ? GF_TRUE : GF_FALSE , dump_mode , do_scene_log , no_odf_conf ) ; if ( e ) goto err_exit ; } # endif # ifndef GPAC_DISABLE_SCENE_STATS if ( stat_level ) dump_isom_scene_stats ( inName , dump_std ? NULL : ( outName ? outName : outfile ) , outName ? GF_TRUE : GF_FALSE , stat_level ) ; # endif # ifndef GPAC_DISABLE_ISOM_HINTING if ( ! HintIt && print_sdp ) dump_isom_sdp ( file , dump_std ? NULL : ( outName ? outName : outfile ) , outName ? GF_TRUE : GF_FALSE ) ; # endif if ( get_nb_tracks ) { fprintf ( stdout , "%d\\n" , gf_isom_get_track_count ( file ) ) ; } if ( print_info ) { if ( ! file ) { fprintf ( stderr , "Cannot<S2SV_blank>print<S2SV_blank>info<S2SV_blank>on<S2SV_blank>a<S2SV_blank>non<S2SV_blank>ISOM<S2SV_blank>file<S2SV_blank>(%s)\\n" , inName ) ; } else { if ( info_track_id ) DumpTrackInfo ( file , info_track_id , 1 , ( print_info == 2 ) ? GF_TRUE : GF_FALSE ) ; else DumpMovieInfo ( file ) ; } } # ifndef GPAC_DISABLE_ISOM_DUMP if ( dump_isom ) { e = dump_isom_xml ( file , dump_std ? NULL : ( outName ? outName : outfile ) , outName ? GF_TRUE : GF_FALSE , ( dump_isom == 2 ) ? GF_TRUE : GF_FALSE , merge_vtt_cues , use_init_seg ? GF_TRUE : GF_FALSE , ( dump_isom == 3 ) ? GF_TRUE : GF_FALSE ) ; if ( e ) goto err_exit ; } if ( dump_cr ) dump_isom_ismacryp ( file , dump_std ? NULL : ( outName ? outName : outfile ) , outName ? GF_TRUE : GF_FALSE ) ; if ( ( dump_ttxt || dump_srt ) && trackID ) { if ( trackID == ( u32 ) - 1 ) { for ( j = 0 ; j < gf_isom_get_track_count ( file ) ; j ++ ) { trackID = gf_isom_get_track_id ( file , j + 1 ) ; dump_isom_timed_text ( file , trackID , dump_std ? NULL : ( outName ? outName : outfile ) , outName ? GF_TRUE : GF_FALSE , GF_FALSE , dump_srt ? GF_TEXTDUMPTYPE_SRT : GF_TEXTDUMPTYPE_TTXT ) ; } } else { dump_isom_timed_text ( file , trackID , dump_std ? NULL : ( outName ? outName : outfile ) , outName ? GF_TRUE : GF_FALSE , GF_FALSE , dump_srt ? GF_TEXTDUMPTYPE_SRT : GF_TEXTDUMPTYPE_TTXT ) ; } } # ifndef GPAC_DISABLE_ISOM_HINTING if ( dump_rtp ) dump_isom_rtp ( file , dump_std ? NULL : ( outName ? outName : outfile ) , outName ? GF_TRUE : GF_FALSE ) ; # endif # endif if ( dump_timestamps ) dump_isom_timestamps ( file , dump_std ? NULL : ( outName ? outName : outfile ) , outName ? GF_TRUE : GF_FALSE , dump_timestamps ) ; if ( dump_nal ) dump_isom_nal ( file , dump_nal , dump_std ? NULL : ( outName ? outName : outfile ) , outName ? GF_TRUE : GF_FALSE , dump_nal_type ) ; if ( dump_saps ) dump_isom_saps ( file , dump_saps , dump_saps_mode , dump_std ? NULL : ( outName ? outName : outfile ) , outName ? GF_TRUE : GF_FALSE ) ; if ( do_hash ) { e = hash_file ( inName , dump_std ) ; if ( e ) goto err_exit ; } # ifndef GPAC_DISABLE_CORE_TOOLS if ( do_bin_xml ) { e = xml_bs_to_bin ( inName , outName , dump_std ) ; if ( e ) goto err_exit ; } # endif if ( dump_cart ) dump_isom_cover_art ( file , dump_std ? NULL : ( outName ? outName : outfile ) , outName ? GF_TRUE : GF_FALSE ) ; if ( dump_chap ) dump_isom_chapters ( file , dump_std ? NULL : ( outName ? outName : outfile ) , outName ? GF_TRUE : GF_FALSE , dump_chap ) ; if ( dump_udta_type ) dump_isom_udta ( file , dump_std ? NULL : ( outName ? outName : outfile ) , outName ? GF_TRUE : GF_FALSE , dump_udta_type , dump_udta_track ) ; if ( dump_iod ) { GF_InitialObjectDescriptor * iod = ( GF_InitialObjectDescriptor * ) gf_isom_get_root_od ( file ) ; if ( ! iod ) { <S2SV_StartBug> fprintf ( stderr , "File<S2SV_blank>%s<S2SV_blank>has<S2SV_blank>no<S2SV_blank>IOD" , inName ) ; <S2SV_EndBug> } else { char szName [ GF_MAX_PATH + 10 ] ; FILE * iodf ; sprintf ( szName , "%s.iod" , outfile ) ; iodf = gf_fopen ( szName , "wb" ) ; if ( ! iodf ) { fprintf ( stderr , "Cannot<S2SV_blank>open<S2SV_blank>destination<S2SV_blank>%s\\n" , szName ) ; } else { u8 * desc ; u32 size ; GF_BitStream * bs = gf_bs_from_file ( iodf , GF_BITSTREAM_WRITE ) ; if ( gf_odf_desc_write ( ( GF_Descriptor * ) iod , & desc , & size ) == GF_OK ) { gf_fwrite ( desc , size , iodf ) ; gf_free ( desc ) ; } else { fprintf ( stderr , "Error<S2SV_blank>writing<S2SV_blank>IOD<S2SV_blank>%s\\n" , szName ) ; } gf_fclose ( iodf ) ; gf_bs_del ( bs ) ; } gf_odf_desc_del ( ( GF_Descriptor * ) iod ) ; } } # if ! defined ( GPAC_DISABLE_ISOM_WRITE ) && ! defined ( GPAC_DISABLE_MEDIA_IMPORT ) if ( split_duration || split_size || split_range_str ) { split_isomedia_file ( file , split_duration , split_size , inName , interleaving_time , split_start , adjust_split_end , outName , tmpdir , seg_at_rap , split_range_str ) ; open_edit = GF_FALSE ; needSave = GF_FALSE ; } # endif # ifndef GPAC_DISABLE_MEDIA_EXPORT if ( track_dump_type ) { char szFile [ GF_MAX_PATH + 24 ] ; GF_MediaExporter mdump ; for ( i = 0 ; i < nb_track_act ; i ++ ) { TrackAction * tka = & tracks [ i ] ; if ( tka -> act_type != TRAC_ACTION_RAW_EXTRACT ) continue ; memset ( & mdump , 0 , sizeof ( mdump ) ) ; mdump . file = file ; mdump . flags = tka -> dump_type ; mdump . trackID = tka -> trackID ; mdump . sample_num = tka -> sample_num ; if ( tka -> out_name ) { mdump . out_name = tka -> out_name ; } else if ( outName ) { mdump . out_name = outName ; mdump . flags |= GF_EXPORT_MERGE ; mdump . flags |= GF_EXPORT_NO_FILE_EXT ; } else if ( mdump . trackID ) { sprintf ( szFile , "%s_track%d" , outfile , mdump . trackID ) ; mdump . out_name = szFile ; } else { sprintf ( szFile , "%s_export" , outfile ) ; mdump . out_name = szFile ; } if ( tka -> trackID == ( u32 ) - 1 ) { for ( j = 0 ; j < gf_isom_get_track_count ( file ) ; j ++ ) { mdump . trackID = gf_isom_get_track_id ( file , j + 1 ) ; sprintf ( szFile , "%s_track%d" , outfile , mdump . trackID ) ; mdump . out_name = szFile ; mdump . print_stats_graph = fs_dump_flags ; e = gf_media_export ( & mdump ) ; if ( e ) goto err_exit ; } } else { mdump . print_stats_graph = fs_dump_flags ; e = gf_media_export ( & mdump ) ; if ( e ) goto err_exit ; } } } else if ( do_saf ) { GF_MediaExporter mdump ; memset ( & mdump , 0 , sizeof ( mdump ) ) ; mdump . file = file ; mdump . flags = GF_EXPORT_SAF ; mdump . out_name = outfile ; mdump . print_stats_graph = fs_dump_flags ; e = gf_media_export ( & mdump ) ; if ( e ) goto err_exit ; } # endif for ( i = 0 ; i < nb_meta_act ; i ++ ) { u32 tk = 0 ; # ifndef GPAC_DISABLE_ISOM_WRITE Bool self_ref ; # endif MetaAction * meta = & metas [ i ] ; if ( meta -> trackID ) tk = gf_isom_get_track_by_id ( file , meta -> trackID ) ; switch ( meta -> act_type ) { # ifndef GPAC_DISABLE_ISOM_WRITE case META_ACTION_SET_TYPE : e = gf_isom_set_meta_type ( file , meta -> root_meta , tk , meta -> meta_4cc ) ; gf_isom_modify_alternate_brand ( file , GF_ISOM_BRAND_ISO2 , GF_TRUE ) ; needSave = GF_TRUE ; break ; case META_ACTION_ADD_ITEM : self_ref = ! stricmp ( meta -> szPath , "NULL" ) || ! stricmp ( meta -> szPath , "this" ) || ! stricmp ( meta -> szPath , "self" ) ; e = gf_isom_add_meta_item ( file , meta -> root_meta , tk , self_ref , self_ref ? NULL : meta -> szPath , meta -> szName , meta -> item_id , meta -> item_type , meta -> mime_type , meta -> enc_type , meta -> use_dref ? meta -> szPath : NULL , NULL , meta -> image_props ) ; if ( meta -> ref_type ) { e = gf_isom_meta_add_item_ref ( file , meta -> root_meta , tk , meta -> item_id , meta -> ref_item_id , meta -> ref_type , NULL ) ; } needSave = GF_TRUE ; break ; case META_ACTION_ADD_IMAGE_ITEM : { u32 old_tk_count = gf_isom_get_track_count ( file ) ; GF_Fraction _frac = { 0 , 0 } ; e = import_file ( file , meta -> szPath , 0 , _frac , 0 , NULL , NULL , 0 ) ; if ( e == GF_OK ) { u32 meta_type = gf_isom_get_meta_type ( file , meta -> root_meta , tk ) ; if ( ! meta_type ) { e = gf_isom_set_meta_type ( file , meta -> root_meta , tk , GF_META_ITEM_TYPE_PICT ) ; } else { if ( meta_type != GF_META_ITEM_TYPE_PICT ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( "Warning:<S2SV_blank>file<S2SV_blank>already<S2SV_blank>has<S2SV_blank>a<S2SV_blank>root<S2SV_blank>\'meta\'<S2SV_blank>box<S2SV_blank>of<S2SV_blank>type<S2SV_blank>%s\\n" , gf_4cc_to_str ( meta_type ) ) ) ; e = GF_BAD_PARAM ; } } if ( e == GF_OK ) { if ( ! meta -> item_id ) { e = gf_isom_meta_get_next_item_id ( file , meta -> root_meta , tk , & meta -> item_id ) ; } if ( e == GF_OK ) { e = gf_isom_iff_create_image_item_from_track ( file , meta -> root_meta , tk , 1 , meta -> szName , meta -> item_id , meta -> image_props , NULL ) ; if ( e == GF_OK && meta -> primary ) { e = gf_isom_set_meta_primary_item ( file , meta -> root_meta , tk , meta -> item_id ) ; } if ( e == GF_OK && meta -> ref_type ) { e = gf_isom_meta_add_item_ref ( file , meta -> root_meta , tk , meta -> item_id , meta -> ref_item_id , meta -> ref_type , NULL ) ; } } } } gf_isom_remove_track ( file , old_tk_count + 1 ) ; needSave = GF_TRUE ; } break ; case META_ACTION_REM_ITEM : e = gf_isom_remove_meta_item ( file , meta -> root_meta , tk , meta -> item_id ) ; needSave = GF_TRUE ; break ; case META_ACTION_SET_PRIMARY_ITEM : e = gf_isom_set_meta_primary_item ( file , meta -> root_meta , tk , meta -> item_id ) ; needSave = GF_TRUE ; break ; case META_ACTION_SET_XML : case META_ACTION_SET_BINARY_XML : e = gf_isom_set_meta_xml ( file , meta -> root_meta , tk , meta -> szPath , NULL , 0 , ( meta -> act_type == META_ACTION_SET_BINARY_XML ) ? 1 : 0 ) ; needSave = GF_TRUE ; break ; case META_ACTION_REM_XML : if ( gf_isom_get_meta_item_count ( file , meta -> root_meta , tk ) ) { e = gf_isom_remove_meta_xml ( file , meta -> root_meta , tk ) ; needSave = GF_TRUE ; } else { fprintf ( stderr , "No<S2SV_blank>meta<S2SV_blank>box<S2SV_blank>in<S2SV_blank>input<S2SV_blank>file\\n" ) ; } break ; case META_ACTION_DUMP_ITEM : if ( gf_isom_get_meta_item_count ( file , meta -> root_meta , tk ) ) { e = gf_isom_extract_meta_item ( file , meta -> root_meta , tk , meta -> item_id , strlen ( meta -> szPath ) ? meta -> szPath : NULL ) ; } else { fprintf ( stderr , "No<S2SV_blank>meta<S2SV_blank>box<S2SV_blank>in<S2SV_blank>input<S2SV_blank>file\\n" ) ; } break ; # endif case META_ACTION_DUMP_XML : if ( gf_isom_has_meta_xml ( file , meta -> root_meta , tk ) ) { e = gf_isom_extract_meta_xml ( file , meta -> root_meta , tk , meta -> szPath , NULL ) ; } else { fprintf ( stderr , "No<S2SV_blank>meta<S2SV_blank>box<S2SV_blank>in<S2SV_blank>input<S2SV_blank>file\\n" ) ; } break ; default : break ; } if ( meta -> image_props ) { gf_free ( meta -> image_props ) ; meta -> image_props = NULL ; } if ( e ) goto err_exit ; } if ( ! open_edit && ! needSave ) { if ( file ) gf_isom_delete ( file ) ; goto exit ; } # ifndef GPAC_DISABLE_ISOM_WRITE if ( clean_groups ) { e = gf_isom_reset_switch_parameters ( file ) ; if ( e ) goto err_exit ; needSave = GF_TRUE ; } for ( i = 0 ; i < nb_tsel_acts ; i ++ ) { switch ( tsel_acts [ i ] . act_type ) { case TSEL_ACTION_SET_PARAM : e = gf_isom_set_track_switch_parameter ( file , gf_isom_get_track_by_id ( file , tsel_acts [ i ] . trackID ) , tsel_acts [ i ] . refTrackID ? gf_isom_get_track_by_id ( file , tsel_acts [ i ] . refTrackID ) : 0 , tsel_acts [ i ] . is_switchGroup ? 1 : 0 , & tsel_acts [ i ] . switchGroupID , tsel_acts [ i ] . criteria , tsel_acts [ i ] . nb_criteria ) ; if ( e == GF_BAD_PARAM ) { u32 alternateGroupID , nb_groups ; gf_isom_get_track_switch_group_count ( file , gf_isom_get_track_by_id ( file , tsel_acts [ i ] . trackID ) , & alternateGroupID , & nb_groups ) ; if ( alternateGroupID ) fprintf ( stderr , "Hint:<S2SV_blank>for<S2SV_blank>adding<S2SV_blank>more<S2SV_blank>tracks<S2SV_blank>to<S2SV_blank>group,<S2SV_blank>using:<S2SV_blank>-group-add<S2SV_blank>-refTrack=ID1:[criteria:]trackID=ID2\\n" ) ; else fprintf ( stderr , "Hint:<S2SV_blank>for<S2SV_blank>creates<S2SV_blank>a<S2SV_blank>new<S2SV_blank>grouping<S2SV_blank>information,<S2SV_blank>using<S2SV_blank>-group-add<S2SV_blank>-trackID=ID1:[criteria:]trackID=ID2\\n" ) ; } if ( e ) goto err_exit ; needSave = GF_TRUE ; break ; case TSEL_ACTION_REMOVE_TSEL : e = gf_isom_reset_track_switch_parameter ( file , gf_isom_get_track_by_id ( file , tsel_acts [ i ] . trackID ) , 0 ) ; if ( e ) goto err_exit ; needSave = GF_TRUE ; break ; case TSEL_ACTION_REMOVE_ALL_TSEL_IN_GROUP : e = gf_isom_reset_track_switch_parameter ( file , gf_isom_get_track_by_id ( file , tsel_acts [ i ] . trackID ) , 1 ) ; if ( e ) goto err_exit ; needSave = GF_TRUE ; break ; default : break ; } } if ( remove_sys_tracks ) { # ifndef GPAC_DISABLE_AV_PARSERS remove_systems_tracks ( file ) ; # endif needSave = GF_TRUE ; if ( conv_type < GF_ISOM_CONV_TYPE_ISMA_EX ) conv_type = 0 ; } if ( remove_root_od ) { gf_isom_remove_root_od ( file ) ; needSave = GF_TRUE ; } # ifndef GPAC_DISABLE_ISOM_HINTING if ( remove_hint ) { for ( i = 0 ; i < gf_isom_get_track_count ( file ) ; i ++ ) { if ( gf_isom_get_media_type ( file , i + 1 ) == GF_ISOM_MEDIA_HINT ) { fprintf ( stderr , "Removing<S2SV_blank>hint<S2SV_blank>track<S2SV_blank>ID<S2SV_blank>%d\\n" , gf_isom_get_track_id ( file , i + 1 ) ) ; gf_isom_remove_track ( file , i + 1 ) ; i -- ; } } gf_isom_sdp_clean ( file ) ; needSave = GF_TRUE ; } # endif if ( timescale && ( timescale != gf_isom_get_timescale ( file ) ) ) { gf_isom_set_timescale ( file , timescale ) ; needSave = GF_TRUE ; } if ( ! encode ) { if ( ! file ) { fprintf ( stderr , "Nothing<S2SV_blank>to<S2SV_blank>do<S2SV_blank>-<S2SV_blank>exiting\\n" ) ; goto exit ; } if ( outName ) { strcpy ( outfile , outName ) ; } else { char * rel_name = strrchr ( inName , GF_PATH_SEPARATOR ) ; if ( ! rel_name ) rel_name = strrchr ( inName , '/' ) ; strcpy ( outfile , "" ) ; if ( tmpdir ) { strcpy ( outfile , tmpdir ) ; if ( ! strchr ( "\\\\/" , tmpdir [ strlen ( tmpdir ) - 1 ] ) ) strcat ( outfile , "/" ) ; } if ( ! pack_file ) strcat ( outfile , "out_" ) ; strcat ( outfile , rel_name ? rel_name + 1 : inName ) ; if ( pack_file ) { strcpy ( outfile , rel_name ? rel_name + 1 : inName ) ; rel_name = strrchr ( outfile , '.' ) ; if ( rel_name ) rel_name [ 0 ] = 0 ; strcat ( outfile , ".m21" ) ; } } # ifndef GPAC_DISABLE_MEDIA_IMPORT if ( ( conv_type == GF_ISOM_CONV_TYPE_ISMA ) || ( conv_type == GF_ISOM_CONV_TYPE_ISMA_EX ) ) { fprintf ( stderr , "Converting<S2SV_blank>to<S2SV_blank>ISMA<S2SV_blank>Audio-Video<S2SV_blank>MP4<S2SV_blank>file...\\n" ) ; e = gf_media_make_isma ( file , crypt ? 1 : 0 , GF_FALSE , ( conv_type == GF_ISOM_CONV_TYPE_ISMA_EX ) ? 1 : 0 ) ; if ( e ) goto err_exit ; needSave = GF_TRUE ; } if ( conv_type == GF_ISOM_CONV_TYPE_3GPP ) { fprintf ( stderr , "Converting<S2SV_blank>to<S2SV_blank>3GP<S2SV_blank>file...\\n" ) ; e = gf_media_make_3gpp ( file ) ; if ( e ) goto err_exit ; needSave = GF_TRUE ; } if ( conv_type == GF_ISOM_CONV_TYPE_PSP ) { fprintf ( stderr , "Converting<S2SV_blank>to<S2SV_blank>PSP<S2SV_blank>file...\\n" ) ; e = gf_media_make_psp ( file ) ; if ( e ) goto err_exit ; needSave = GF_TRUE ; } if ( conv_type == GF_ISOM_CONV_TYPE_MOV ) { e = gf_media_check_qt_prores ( file ) ; if ( e ) goto err_exit ; needSave = GF_TRUE ; if ( interleaving_time ) interleaving_time = 0.5 ; } # endif if ( conv_type == GF_ISOM_CONV_TYPE_IPOD ) { u32 ipod_major_brand = 0 ; fprintf ( stderr , "Setting<S2SV_blank>up<S2SV_blank>iTunes/iPod<S2SV_blank>file...\\n" ) ; for ( i = 0 ; i < gf_isom_get_track_count ( file ) ; i ++ ) { u32 mType = gf_isom_get_media_type ( file , i + 1 ) ; switch ( mType ) { case GF_ISOM_MEDIA_VISUAL : case GF_ISOM_MEDIA_AUXV : case GF_ISOM_MEDIA_PICT : ipod_major_brand = GF_ISOM_BRAND_M4V ; gf_isom_set_ipod_compatible ( file , i + 1 ) ; break ; case GF_ISOM_MEDIA_AUDIO : if ( ! ipod_major_brand ) ipod_major_brand = GF_ISOM_BRAND_M4A ; else gf_isom_modify_alternate_brand ( file , GF_ISOM_BRAND_M4A , GF_TRUE ) ; break ; case GF_ISOM_MEDIA_TEXT : if ( gf_isom_get_media_subtype ( file , i + 1 , 1 ) == GF_ISOM_SUBTYPE_TX3G ) { Bool is_chap = 0 ; for ( j = 0 ; j < gf_isom_get_track_count ( file ) ; j ++ ) { s32 count = gf_isom_get_reference_count ( file , j + 1 , GF_ISOM_REF_CHAP ) ; if ( count > 0 ) { u32 tk , k ; for ( k = 0 ; k < ( u32 ) count ; k ++ ) { gf_isom_get_reference ( file , j + 1 , GF_ISOM_REF_CHAP , k + 1 , & tk ) ; if ( tk == i + 1 ) { is_chap = 1 ; break ; } } if ( is_chap ) break ; } if ( is_chap ) break ; } if ( ! is_chap ) gf_isom_set_media_type ( file , i + 1 , GF_ISOM_MEDIA_SUBT ) ; } break ; } } gf_isom_set_brand_info ( file , ipod_major_brand , 1 ) ; gf_isom_modify_alternate_brand ( file , GF_ISOM_BRAND_MP42 , GF_TRUE ) ; needSave = GF_TRUE ; } } else if ( outName ) { strcpy ( outfile , outName ) ; } for ( j = 0 ; j < nb_track_act ; j ++ ) { TrackAction * tka = & tracks [ j ] ; u32 track = tka -> trackID ? gf_isom_get_track_by_id ( file , tka -> trackID ) : 0 ; timescale = gf_isom_get_timescale ( file ) ; switch ( tka -> act_type ) { case TRAC_ACTION_REM_TRACK : e = gf_isom_remove_track ( file , track ) ; if ( e ) { fprintf ( stderr , "Error<S2SV_blank>Removing<S2SV_blank>track<S2SV_blank>ID<S2SV_blank>%d:<S2SV_blank>%s\\n" , tka -> trackID , gf_error_to_string ( e ) ) ; } else { fprintf ( stderr , "Removing<S2SV_blank>track<S2SV_blank>ID<S2SV_blank>%d\\n" , tka -> trackID ) ; } needSave = GF_TRUE ; break ; case TRAC_ACTION_SET_LANGUAGE : for ( i = 0 ; i < gf_isom_get_track_count ( file ) ; i ++ ) { if ( track && ( track != i + 1 ) ) continue ; e = gf_isom_set_media_language ( file , i + 1 , tka -> lang ) ; if ( e ) goto err_exit ; needSave = GF_TRUE ; } needSave = GF_TRUE ; break ; case TRAC_ACTION_SET_KIND : for ( i = 0 ; i < gf_isom_get_track_count ( file ) ; i ++ ) { if ( track && ( track != i + 1 ) ) continue ; e = gf_isom_add_track_kind ( file , i + 1 , tka -> kind_scheme , tka -> kind_value ) ; if ( e ) goto err_exit ; needSave = GF_TRUE ; } needSave = GF_TRUE ; break ; case TRAC_ACTION_REM_KIND : for ( i = 0 ; i < gf_isom_get_track_count ( file ) ; i ++ ) { if ( track && ( track != i + 1 ) ) continue ; e = gf_isom_remove_track_kind ( file , i + 1 , tka -> kind_scheme , tka -> kind_value ) ; if ( e ) goto err_exit ; needSave = GF_TRUE ; } needSave = GF_TRUE ; break ; case TRAC_ACTION_SET_DELAY : if ( tka -> delay_ms ) { u64 tk_dur ; gf_isom_remove_edits ( file , track ) ; tk_dur = gf_isom_get_track_duration ( file , track ) ; if ( gf_isom_get_edits_count ( file , track ) ) needSave = GF_TRUE ; if ( tka -> delay_ms > 0 ) { gf_isom_append_edit ( file , track , ( timescale * tka -> delay_ms ) / 1000 , 0 , GF_ISOM_EDIT_EMPTY ) ; gf_isom_append_edit ( file , track , tk_dur , 0 , GF_ISOM_EDIT_NORMAL ) ; needSave = GF_TRUE ; } else { u64 to_skip = ( timescale * ( - tka -> delay_ms ) ) / 1000 ; if ( to_skip < tk_dur ) { u64 media_time = ( - tka -> delay_ms ) * gf_isom_get_media_timescale ( file , track ) / 1000 ; gf_isom_append_edit ( file , track , tk_dur - to_skip , media_time , GF_ISOM_EDIT_NORMAL ) ; needSave = GF_TRUE ; } else { fprintf ( stderr , "Warning:<S2SV_blank>request<S2SV_blank>negative<S2SV_blank>delay<S2SV_blank>longer<S2SV_blank>than<S2SV_blank>track<S2SV_blank>duration<S2SV_blank>-<S2SV_blank>ignoring\\n" ) ; } } } else if ( gf_isom_get_edits_count ( file , track ) ) { gf_isom_remove_edits ( file , track ) ; needSave = GF_TRUE ; } break ; case TRAC_ACTION_SET_KMS_URI : for ( i = 0 ; i < gf_isom_get_track_count ( file ) ; i ++ ) { if ( track && ( track != i + 1 ) ) continue ; if ( ! gf_isom_is_media_encrypted ( file , i + 1 , 1 ) ) continue ; if ( ! gf_isom_is_ismacryp_media ( file , i + 1 , 1 ) ) continue ; e = gf_isom_change_ismacryp_protection ( file , i + 1 , 1 , NULL , ( char * ) tka -> kms ) ; if ( e ) goto err_exit ; needSave = GF_TRUE ; } break ; case TRAC_ACTION_SET_ID : if ( ! tka -> trackID && ( gf_isom_get_track_count ( file ) == 1 ) ) { fprintf ( stderr , "Warning:<S2SV_blank>track<S2SV_blank>id<S2SV_blank>is<S2SV_blank>not<S2SV_blank>specified,<S2SV_blank>but<S2SV_blank>file<S2SV_blank>has<S2SV_blank>only<S2SV_blank>one<S2SV_blank>track<S2SV_blank>-<S2SV_blank>assume<S2SV_blank>that<S2SV_blank>you<S2SV_blank>want<S2SV_blank>to<S2SV_blank>change<S2SV_blank>id<S2SV_blank>for<S2SV_blank>this<S2SV_blank>track\\n" ) ; track = 1 ; } if ( track ) { u32 newTrack ; newTrack = gf_isom_get_track_by_id ( file , tka -> newTrackID ) ; if ( newTrack != 0 ) { fprintf ( stderr , "Error:<S2SV_blank>Cannot<S2SV_blank>set<S2SV_blank>track<S2SV_blank>id<S2SV_blank>with<S2SV_blank>value<S2SV_blank>%d<S2SV_blank>because<S2SV_blank>a<S2SV_blank>track<S2SV_blank>already<S2SV_blank>exists<S2SV_blank>-<S2SV_blank>ignoring" , tka -> newTrackID ) ; } else { e = gf_isom_set_track_id ( file , track , tka -> newTrackID ) ; needSave = GF_TRUE ; } } else { fprintf ( stderr , "Error:<S2SV_blank>Cannot<S2SV_blank>change<S2SV_blank>id<S2SV_blank>for<S2SV_blank>track<S2SV_blank>%d<S2SV_blank>because<S2SV_blank>it<S2SV_blank>does<S2SV_blank>not<S2SV_blank>exist<S2SV_blank>-<S2SV_blank>ignoring" , tka -> trackID ) ; } break ; case TRAC_ACTION_SWAP_ID : if ( track ) { u32 tk1 , tk2 ; tk1 = gf_isom_get_track_by_id ( file , tka -> trackID ) ; tk2 = gf_isom_get_track_by_id ( file , tka -> newTrackID ) ; if ( ! tk1 || ! tk2 ) { fprintf ( stderr , "Error:<S2SV_blank>Cannot<S2SV_blank>swap<S2SV_blank>track<S2SV_blank>IDs<S2SV_blank>because<S2SV_blank>not<S2SV_blank>existing<S2SV_blank>-<S2SV_blank>ignoring" ) ; } else { e = gf_isom_set_track_id ( file , tk2 , 0 ) ; if ( ! e ) e = gf_isom_set_track_id ( file , tk1 , tka -> newTrackID ) ; if ( ! e ) e = gf_isom_set_track_id ( file , tk2 , tka -> trackID ) ; needSave = GF_TRUE ; } } else { fprintf ( stderr , "Error:<S2SV_blank>Cannot<S2SV_blank>change<S2SV_blank>id<S2SV_blank>for<S2SV_blank>track<S2SV_blank>%d<S2SV_blank>because<S2SV_blank>it<S2SV_blank>does<S2SV_blank>not<S2SV_blank>exist<S2SV_blank>-<S2SV_blank>ignoring" , tka -> trackID ) ; } break ; case TRAC_ACTION_SET_PAR : e = gf_media_change_par ( file , track , tka -> par_num , tka -> par_den , tka -> force_par , tka -> rewrite_bs ) ; needSave = GF_TRUE ; break ; case TRAC_ACTION_SET_CLAP : e = gf_isom_set_clean_aperture ( file , track , 1 , tka -> clap_wnum , tka -> clap_wden , tka -> clap_hnum , tka -> clap_hden , tka -> clap_honum , tka -> clap_hoden , tka -> clap_vonum , tka -> clap_voden ) ; needSave = GF_TRUE ; break ; case TRAC_ACTION_SET_MX : e = gf_isom_set_track_matrix ( file , track , tka -> mx ) ; needSave = GF_TRUE ; break ; case TRAC_ACTION_SET_HANDLER_NAME : e = gf_isom_set_handler_name ( file , track , tka -> hdl_name ) ; needSave = GF_TRUE ; break ; case TRAC_ACTION_ENABLE : if ( ! gf_isom_is_track_enabled ( file , track ) ) { e = gf_isom_set_track_enabled ( file , track , GF_TRUE ) ; needSave = GF_TRUE ; } break ; case TRAC_ACTION_DISABLE : if ( gf_isom_is_track_enabled ( file , track ) ) { e = gf_isom_set_track_enabled ( file , track , GF_FALSE ) ; needSave = GF_TRUE ; } break ; case TRAC_ACTION_REFERENCE : e = gf_isom_set_track_reference ( file , track , GF_4CC ( tka -> lang [ 0 ] , tka -> lang [ 1 ] , tka -> lang [ 2 ] , tka -> lang [ 3 ] ) , ( u32 ) tka -> delay_ms ) ; needSave = GF_TRUE ; break ; case TRAC_ACTION_REM_NON_RAP : fprintf ( stderr , "Removing<S2SV_blank>non-rap<S2SV_blank>samples<S2SV_blank>from<S2SV_blank>track<S2SV_blank>%d\\n" , tka -> trackID ) ; e = gf_media_remove_non_rap ( file , track , GF_FALSE ) ; needSave = GF_TRUE ; break ; case TRAC_ACTION_REM_NON_REFS : fprintf ( stderr , "Removing<S2SV_blank>non-reference<S2SV_blank>samples<S2SV_blank>from<S2SV_blank>track<S2SV_blank>%d\\n" , tka -> trackID ) ; e = gf_media_remove_non_rap ( file , track , GF_TRUE ) ; needSave = GF_TRUE ; break ; case TRAC_ACTION_SET_UDTA : fprintf ( stderr , "Assigning<S2SV_blank>udta<S2SV_blank>box\\n" ) ; e = set_file_udta ( file , track , tka -> udta_type , tka -> src_name , tka -> sample_num ? GF_TRUE : GF_FALSE ) ; if ( e ) goto err_exit ; needSave = GF_TRUE ; break ; default : break ; } if ( e ) goto err_exit ; } if ( itunes_tags ) { char * tags = itunes_tags ; while ( tags ) { char * val ; char * sep = gf_url_colon_suffix ( tags ) ; u32 tlen , itag = 0 ; if ( sep ) { while ( sep ) { for ( itag = 0 ; itag < nb_itunes_tags ; itag ++ ) { if ( ! strnicmp ( sep + 1 , itags [ itag ] . name , strlen ( itags [ itag ] . name ) ) ) break ; } if ( itag < nb_itunes_tags ) { break ; } sep = gf_url_colon_suffix ( sep + 1 ) ; } if ( sep ) sep [ 0 ] = 0 ; } for ( itag = 0 ; itag < nb_itunes_tags ; itag ++ ) { if ( ! strnicmp ( tags , itags [ itag ] . name , strlen ( itags [ itag ] . name ) ) ) { break ; } } if ( itag == nb_itunes_tags ) { fprintf ( stderr , "Invalid<S2SV_blank>iTune<S2SV_blank>tag<S2SV_blank>format<S2SV_blank>\\"%s\\"<S2SV_blank>-<S2SV_blank>ignoring\\n" , tags ) ; tags = NULL ; continue ; } itag = itags [ itag ] . code ; val = strchr ( tags , '=' ) ; if ( ! val ) { fprintf ( stderr , "Invalid<S2SV_blank>iTune<S2SV_blank>tag<S2SV_blank>format<S2SV_blank>\\"%s\\"<S2SV_blank>(expecting<S2SV_blank>\'=\')<S2SV_blank>-<S2SV_blank>ignoring\\n" , tags ) ; tags = NULL ; continue ; } val ++ ; if ( ( val [ 0 ] == ':' ) || ! val [ 0 ] || ! stricmp ( val , "NULL" ) ) val = NULL ; tlen = val ? ( u32 ) strlen ( val ) : 0 ; switch ( itag ) { case GF_ISOM_ITUNE_COVER_ART : { u8 * d = NULL ; e = GF_OK ; if ( val ) { char * ext ; e = gf_file_load_data ( val , ( u8 * * ) & d , & tlen ) ; ext = strrchr ( val , '.' ) ; if ( ! stricmp ( ext , ".png" ) ) tlen |= 0x80000000 ; } if ( ! e ) e = gf_isom_apple_set_tag ( file , GF_ISOM_ITUNE_COVER_ART , d , tlen ) ; if ( d ) gf_free ( d ) ; } break ; case GF_ISOM_ITUNE_TEMPO : gf_isom_apple_set_tag ( file , itag , NULL , val ? atoi ( val ) : 0 ) ; break ; case GF_ISOM_ITUNE_GENRE : { u8 _v = gf_id3_get_genre_tag ( val ) ; if ( _v ) { gf_isom_apple_set_tag ( file , itag , NULL , _v ) ; } else { if ( ! val ) val = "" ; gf_isom_apple_set_tag ( file , itag , ( u8 * ) val , ( u32 ) strlen ( val ) ) ; } } break ; case GF_ISOM_ITUNE_DISK : case GF_ISOM_ITUNE_TRACKNUMBER : { u32 n , t ; char _t [ 8 ] ; n = t = 0 ; if ( val ) { memset ( _t , 0 , sizeof ( char ) * 8 ) ; tlen = ( itag == GF_ISOM_ITUNE_DISK ) ? 6 : 8 ; if ( sscanf ( val , "%u/%u" , & n , & t ) == 2 ) { _t [ 3 ] = n ; _t [ 2 ] = n >> 8 ; _t [ 5 ] = t ; _t [ 4 ] = t >> 8 ; } else if ( sscanf ( val , "%u" , & n ) == 1 ) { _t [ 3 ] = n ; _t [ 2 ] = n >> 8 ; } else tlen = 0 ; } if ( ! val || tlen ) gf_isom_apple_set_tag ( file , itag , val ? ( u8 * ) _t : NULL , tlen ) ; } break ; case GF_ISOM_ITUNE_GAPLESS : case GF_ISOM_ITUNE_COMPILATION : { u8 _t [ 1 ] ; if ( val && ! stricmp ( val , "yes" ) ) _t [ 0 ] = 1 ; else _t [ 0 ] = 0 ; gf_isom_apple_set_tag ( file , itag , _t , 1 ) ; } break ; default : gf_isom_apple_set_tag ( file , itag , ( u8 * ) val , tlen ) ; break ; } needSave = GF_TRUE ; if ( sep ) { sep [ 0 ] = ':' ; tags = sep + 1 ; } else { tags = NULL ; } } } if ( movie_time ) { gf_isom_set_creation_time ( file , movie_time ) ; for ( i = 0 ; i < gf_isom_get_track_count ( file ) ; i ++ ) { gf_isom_set_track_creation_time ( file , i + 1 , movie_time ) ; } needSave = GF_TRUE ; } if ( cprt ) { e = gf_isom_set_copyright ( file , "und" , cprt ) ; needSave = GF_TRUE ; if ( e ) goto err_exit ; } if ( chap_file ) { # ifndef GPAC_DISABLE_MEDIA_IMPORT e = gf_media_import_chapters ( file , chap_file , import_fps , chap_qt ) ; needSave = GF_TRUE ; # else fprintf ( stderr , "Warning:<S2SV_blank>GPAC<S2SV_blank>compiled<S2SV_blank>without<S2SV_blank>Media<S2SV_blank>Import,<S2SV_blank>chapters<S2SV_blank>can\'t<S2SV_blank>be<S2SV_blank>imported\\n" ) ; e = GF_NOT_SUPPORTED ; # endif if ( e ) goto err_exit ; } if ( major_brand ) { gf_isom_set_brand_info ( file , major_brand , minor_version ) ; needSave = GF_TRUE ; } for ( i = 0 ; i < nb_alt_brand_add ; i ++ ) { gf_isom_modify_alternate_brand ( file , brand_add [ i ] , GF_TRUE ) ; needSave = GF_TRUE ; } for ( i = 0 ; i < nb_alt_brand_rem ; i ++ ) { gf_isom_modify_alternate_brand ( file , brand_rem [ i ] , GF_FALSE ) ; needSave = GF_TRUE ; } if ( box_patch_filename ) { e = gf_isom_apply_box_patch ( file , box_patch_trackID , box_patch_filename , GF_FALSE ) ; if ( e ) { fprintf ( stderr , "Failed<S2SV_blank>to<S2SV_blank>apply<S2SV_blank>box<S2SV_blank>patch<S2SV_blank>%s:<S2SV_blank>%s\\n" , box_patch_filename , gf_error_to_string ( e ) ) ; goto err_exit ; } needSave = GF_TRUE ; } # ifndef GPAC_DISABLE_CRYPTO if ( crypt ) { if ( ! drm_file ) { fprintf ( stderr , "Missing<S2SV_blank>DRM<S2SV_blank>file<S2SV_blank>location<S2SV_blank>-<S2SV_blank>usage<S2SV_blank>\'-%s<S2SV_blank>drm_file<S2SV_blank>input_file\\n" , ( crypt == 1 ) ? "crypt" : "decrypt" ) ; e = GF_BAD_PARAM ; goto err_exit ; } if ( get_file_type_by_ext ( inName ) != GF_FILE_TYPE_ISO_MEDIA ) { fprintf ( stderr , "MP4Box<S2SV_blank>can<S2SV_blank>crypt<S2SV_blank>only<S2SV_blank>ISOMedia<S2SV_blank>File\\n" ) ; e = GF_BAD_PARAM ; goto err_exit ; } if ( crypt == 1 ) { if ( use_init_seg ) { e = gf_crypt_fragment ( file , drm_file , outfile , inName , fs_dump_flags ) ; } else { e = gf_crypt_file ( file , drm_file , outfile , interleaving_time , fs_dump_flags ) ; } } else if ( crypt == 2 ) { if ( use_init_seg ) { e = gf_decrypt_fragment ( file , drm_file , outfile , inName , fs_dump_flags ) ; } else { e = gf_decrypt_file ( file , drm_file , outfile , interleaving_time , fs_dump_flags ) ; } } if ( e ) goto err_exit ; needSave = outName ? GF_FALSE : GF_TRUE ; if ( ! Frag && ! HintIt && ! FullInter && ! force_co64 ) { char szName [ GF_MAX_PATH ] ; strcpy ( szName , gf_isom_get_filename ( file ) ) ; gf_isom_delete ( file ) ; file = NULL ; if ( ! outName ) { e = gf_file_move ( outfile , szName ) ; if ( e ) goto err_exit ; } goto exit ; } } # endif # ifndef GPAC_DISABLE_ISOM_FRAGMENTS if ( Frag ) { if ( ! interleaving_time ) interleaving_time = DEFAULT_INTERLEAVING_IN_SEC ; if ( HintIt ) fprintf ( stderr , "Warning:<S2SV_blank>cannot<S2SV_blank>hint<S2SV_blank>and<S2SV_blank>fragment<S2SV_blank>-<S2SV_blank>ignoring<S2SV_blank>hint\\n" ) ; fprintf ( stderr , "Fragmenting<S2SV_blank>file<S2SV_blank>(%.3f<S2SV_blank>seconds<S2SV_blank>fragments)\\n" , interleaving_time ) ; e = gf_media_fragment_file ( file , outfile , interleaving_time , use_mfra ) ; if ( e ) fprintf ( stderr , "Error<S2SV_blank>while<S2SV_blank>fragmenting<S2SV_blank>file:<S2SV_blank>%s\\n" , gf_error_to_string ( e ) ) ; if ( ! e && ! outName ) { if ( gf_file_exists ( inName ) && gf_file_delete ( inName ) ) fprintf ( stderr , "Error<S2SV_blank>removing<S2SV_blank>file<S2SV_blank>%s\\n" , inName ) ; else if ( gf_file_move ( outfile , inName ) ) fprintf ( stderr , "Error<S2SV_blank>renaming<S2SV_blank>file<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>%s\\n" , outfile , inName ) ; } if ( e ) goto err_exit ; gf_isom_delete ( file ) ; goto exit ; } # endif # ifndef GPAC_DISABLE_ISOM_HINTING if ( HintIt ) { if ( force_ocr ) SetupClockReferences ( file ) ; fprintf ( stderr , "Hinting<S2SV_blank>file<S2SV_blank>with<S2SV_blank>Path-MTU<S2SV_blank>%d<S2SV_blank>Bytes\\n" , MTUSize ) ; MTUSize -= 12 ; e = HintFile ( file , MTUSize , max_ptime , rtp_rate , hint_flags , HintCopy , HintInter , regular_iod , single_group , hint_no_offset ) ; if ( e ) goto err_exit ; needSave = GF_TRUE ; if ( print_sdp ) dump_isom_sdp ( file , dump_std ? NULL : ( outName ? outName : outfile ) , outName ? GF_TRUE : GF_FALSE ) ; } # endif # if ! defined ( GPAC_DISABLE_ISOM_HINTING ) && ! defined ( GPAC_DISABLE_SENG ) for ( i = 0 ; i < nb_sdp_ex ; i ++ ) { if ( sdp_lines [ i ] . trackID ) { u32 track = gf_isom_get_track_by_id ( file , sdp_lines [ i ] . trackID ) ; if ( gf_isom_get_media_type ( file , track ) != GF_ISOM_MEDIA_HINT ) { s32 ref_count ; u32 k , count = gf_isom_get_track_count ( file ) ; for ( j = 0 ; j < count ; j ++ ) { if ( gf_isom_get_media_type ( file , j + 1 ) != GF_ISOM_MEDIA_HINT ) continue ; ref_count = gf_isom_get_reference_count ( file , j + 1 , GF_ISOM_REF_HINT ) ; if ( ref_count < 0 ) continue ; for ( k = 0 ; k < ( u32 ) ref_count ; k ++ ) { u32 refTk ; if ( gf_isom_get_reference ( file , j + 1 , GF_ISOM_REF_HINT , k + 1 , & refTk ) ) continue ; if ( refTk == track ) { track = j + 1 ; j = count ; break ; } } } } gf_isom_sdp_add_track_line ( file , track , sdp_lines [ i ] . line ) ; needSave = GF_TRUE ; } else { gf_isom_sdp_add_line ( file , sdp_lines [ i ] . line ) ; needSave = GF_TRUE ; } } # endif if ( FullInter ) { e = gf_isom_set_storage_mode ( file , GF_ISOM_STORE_TIGHT ) ; } else if ( do_flat ) { e = gf_isom_set_storage_mode ( file , ( do_flat == 1 ) ? GF_ISOM_STORE_FLAT : GF_ISOM_STORE_STREAMABLE ) ; needSave = GF_TRUE ; } else { e = gf_isom_make_interleave ( file , interleaving_time ) ; if ( ! e && old_interleave ) e = gf_isom_set_storage_mode ( file , GF_ISOM_STORE_INTERLEAVED ) ; } if ( force_co64 ) gf_isom_force_64bit_chunk_offset ( file , GF_TRUE ) ; if ( compress_moov ) gf_isom_enable_compression ( file , GF_ISO_COMP_MOOV , GF_FALSE ) ; if ( e ) goto err_exit ; if ( ! encode && ! force_new ) gf_isom_set_final_name ( file , outfile ) ; if ( needSave ) { if ( ! gf_sys_is_quiet ( ) ) { if ( outName ) { gf_isom_set_final_name ( file , outfile ) ; } else if ( encode || pack_file ) { fprintf ( stderr , "Saving<S2SV_blank>to<S2SV_blank>%s:<S2SV_blank>" , gf_isom_get_filename ( file ) ) ; } else { fprintf ( stderr , "Saving<S2SV_blank>%s:<S2SV_blank>" , inName ) ; } if ( HintIt && FullInter ) fprintf ( stderr , "Hinted<S2SV_blank>file<S2SV_blank>-<S2SV_blank>Full<S2SV_blank>Interleaving\\n" ) ; else if ( FullInter ) fprintf ( stderr , "Full<S2SV_blank>Interleaving\\n" ) ; else if ( ( force_new == 2 ) && interleaving_time ) fprintf ( stderr , "Fast-start<S2SV_blank>interleaved<S2SV_blank>storage\\n" ) ; else if ( do_flat || ! interleaving_time ) fprintf ( stderr , "Flat<S2SV_blank>storage\\n" ) ; else fprintf ( stderr , "%.3f<S2SV_blank>secs<S2SV_blank>Interleaving%s\\n" , interleaving_time , old_interleave ? "<S2SV_blank>-<S2SV_blank>no<S2SV_blank>drift<S2SV_blank>control" : "" ) ; } else { if ( outName ) gf_isom_set_final_name ( file , outfile ) ; } e = gf_isom_close ( file ) ; file = NULL ; if ( ! e && ! outName && ! encode && ! force_new && ! pack_file ) { if ( gf_file_exists ( inName ) ) { e = gf_file_delete ( inName ) ; if ( e ) { fprintf ( stderr , "Error<S2SV_blank>removing<S2SV_blank>file<S2SV_blank>%s\\n" , inName ) ; } } e = gf_file_move ( outfile , inName ) ; if ( e ) { fprintf ( stderr , "Error<S2SV_blank>renaming<S2SV_blank>file<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>%s\\n" , outfile , inName ) ; } } } else { gf_isom_delete ( file ) ; } if ( e ) { fprintf ( stderr , "Error:<S2SV_blank>%s\\n" , gf_error_to_string ( e ) ) ; goto err_exit ; } goto exit ; # else gf_isom_delete ( file ) ; fprintf ( stderr , "Error:<S2SV_blank>Read-only<S2SV_blank>version<S2SV_blank>of<S2SV_blank>MP4Box.\\n" ) ; return mp4box_cleanup ( 1 ) ; # endif err_exit : if ( file ) gf_isom_delete ( file ) ; fprintf ( stderr , "\\n\\tError:<S2SV_blank>%s\\n" , gf_error_to_string ( e ) ) ; return mp4box_cleanup ( 1 ) ; exit : mp4box_cleanup ( 0 ) ; # ifdef GPAC_MEMORY_TRACKING if ( mem_track && ( gf_memory_size ( ) || gf_file_handles_count ( ) ) ) { gf_log_set_tool_level ( GF_LOG_MEMORY , GF_LOG_INFO ) ; gf_memory_print ( ) ; return 2 ; } # endif return 0 ; }
static int get_results ( struct iperf_test * test ) { int r = 0 ; cJSON * j ; cJSON * j_cpu_util_total ; cJSON * j_cpu_util_user ; cJSON * j_cpu_util_system ; cJSON * j_sender_has_retransmits ; int result_has_retransmits ; cJSON * j_streams ; int n , i ; cJSON * j_stream ; cJSON * j_id ; cJSON * j_bytes ; cJSON * j_retransmits ; cJSON * j_jitter ; cJSON * j_errors ; cJSON * j_packets ; cJSON * j_server_output ; int sid , cerror , pcount ; double jitter ; iperf_size_t bytes_transferred ; int retransmits ; struct iperf_stream * sp ; j = JSON_read ( test -> ctrl_sck ) ; if ( j == NULL ) { i_errno = IERECVRESULTS ; r = - 1 ; } else { j_cpu_util_total = cJSON_GetObjectItem ( j , "cpu_util_total" ) ; j_cpu_util_user = cJSON_GetObjectItem ( j , "cpu_util_user" ) ; j_cpu_util_system = cJSON_GetObjectItem ( j , "cpu_util_system" ) ; j_sender_has_retransmits = cJSON_GetObjectItem ( j , "sender_has_retransmits" ) ; if ( j_cpu_util_total == NULL || j_cpu_util_user == NULL || j_cpu_util_system == NULL || j_sender_has_retransmits == NULL ) { i_errno = IERECVRESULTS ; r = - 1 ; } else { if ( test -> debug ) { printf ( "get_results\\n%s\\n" , cJSON_Print ( j ) ) ; } <S2SV_StartBug> test -> remote_cpu_util [ 0 ] = j_cpu_util_total -> valuefloat ; <S2SV_EndBug> <S2SV_StartBug> test -> remote_cpu_util [ 1 ] = j_cpu_util_user -> valuefloat ; <S2SV_EndBug> <S2SV_StartBug> test -> remote_cpu_util [ 2 ] = j_cpu_util_system -> valuefloat ; <S2SV_EndBug> result_has_retransmits = j_sender_has_retransmits -> valueint ; if ( ! test -> sender ) test -> sender_has_retransmits = result_has_retransmits ; j_streams = cJSON_GetObjectItem ( j , "streams" ) ; if ( j_streams == NULL ) { i_errno = IERECVRESULTS ; r = - 1 ; } else { n = cJSON_GetArraySize ( j_streams ) ; for ( i = 0 ; i < n ; ++ i ) { j_stream = cJSON_GetArrayItem ( j_streams , i ) ; if ( j_stream == NULL ) { i_errno = IERECVRESULTS ; r = - 1 ; } else { j_id = cJSON_GetObjectItem ( j_stream , "id" ) ; j_bytes = cJSON_GetObjectItem ( j_stream , "bytes" ) ; j_retransmits = cJSON_GetObjectItem ( j_stream , "retransmits" ) ; j_jitter = cJSON_GetObjectItem ( j_stream , "jitter" ) ; j_errors = cJSON_GetObjectItem ( j_stream , "errors" ) ; j_packets = cJSON_GetObjectItem ( j_stream , "packets" ) ; if ( j_id == NULL || j_bytes == NULL || j_retransmits == NULL || j_jitter == NULL || j_errors == NULL || j_packets == NULL ) { i_errno = IERECVRESULTS ; r = - 1 ; } else { sid = j_id -> valueint ; bytes_transferred = j_bytes -> valueint ; retransmits = j_retransmits -> valueint ; <S2SV_StartBug> jitter = j_jitter -> valuefloat ; <S2SV_EndBug> cerror = j_errors -> valueint ; pcount = j_packets -> valueint ; SLIST_FOREACH ( sp , & test -> streams , streams ) if ( sp -> id == sid ) break ; if ( sp == NULL ) { i_errno = IESTREAMID ; r = - 1 ; } else { if ( test -> sender ) { sp -> jitter = jitter ; sp -> cnt_error = cerror ; sp -> packet_count = pcount ; sp -> result -> bytes_received = bytes_transferred ; } else { sp -> result -> bytes_sent = bytes_transferred ; sp -> result -> stream_retrans = retransmits ; } } } } } if ( test -> role == 'c' && iperf_get_test_get_server_output ( test ) ) { j_server_output = cJSON_DetachItemFromObject ( j , "server_output_json" ) ; if ( j_server_output != NULL ) { test -> json_server_output = j_server_output ; } else { j_server_output = cJSON_GetObjectItem ( j , "server_output_text" ) ; if ( j_server_output != NULL ) { test -> server_output_text = strdup ( j_server_output -> valuestring ) ; } } } } } cJSON_Delete ( j ) ; } return r ; }
static int caif_seqpkt_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * m , size_t len , int flags ) { struct sock * sk = sock -> sk ; struct sk_buff * skb ; int ret ; int copylen ; ret = - EOPNOTSUPP ; if ( m -> msg_flags & MSG_OOB ) goto read_error ; <S2SV_StartBug> skb = skb_recv_datagram ( sk , flags , 0 , & ret ) ; <S2SV_EndBug> if ( ! skb ) goto read_error ; copylen = skb -> len ; if ( len < copylen ) { m -> msg_flags |= MSG_TRUNC ; copylen = len ; } ret = skb_copy_datagram_iovec ( skb , 0 , m -> msg_iov , copylen ) ; if ( ret ) goto out_free ; ret = ( flags & MSG_TRUNC ) ? skb -> len : copylen ; out_free : skb_free_datagram ( sk , skb ) ; caif_check_flow_release ( sk ) ; return ret ; read_error : return ret ; }
static int traceLogDirective ( MaState * state , cchar * key , cchar * value ) { HttpRoute * route ; char * format , * option , * ovalue , * tok , * path , * formatter ; ssize size ; int flags , backup , level ; route = state -> route ; size = MAXINT ; backup = 0 ; flags = 0 ; path = 0 ; format = ME_HTTP_LOG_FORMAT ; formatter = "detail" ; level = 0 ; if ( route -> trace -> flags & MPR_LOG_CMDLINE ) { mprLog ( "info<S2SV_blank>appweb<S2SV_blank>config" , 4 , "Already<S2SV_blank>tracing.<S2SV_blank>Ignoring<S2SV_blank>TraceLog<S2SV_blank>directive" ) ; return 0 ; } for ( option = maGetNextArg ( sclone ( value ) , & tok ) ; option ; option = maGetNextArg ( tok , & tok ) ) { if ( ! path ) { path = sclone ( option ) ; } else { <S2SV_StartBug> option = stok ( option , "<S2SV_blank>=\\t," , & ovalue ) ; <S2SV_EndBug> ovalue = strim ( ovalue , "\\"\'" , MPR_TRIM_BOTH ) ; if ( smatch ( option , "anew" ) ) { flags |= MPR_LOG_ANEW ; } else if ( smatch ( option , "backup" ) ) { backup = atoi ( ovalue ) ; } else if ( smatch ( option , "format" ) ) { format = ovalue ; } else if ( smatch ( option , "level" ) ) { level = ( int ) stoi ( ovalue ) ; } else if ( smatch ( option , "size" ) ) { size = ( ssize ) getnum ( ovalue ) ; } else if ( smatch ( option , "formatter" ) ) { formatter = ovalue ; } else { mprLog ( "error<S2SV_blank>appweb<S2SV_blank>config" , 0 , "Unknown<S2SV_blank>TraceLog<S2SV_blank>option<S2SV_blank>%s" , option ) ; } } } if ( size < HTTP_TRACE_MIN_LOG_SIZE ) { size = HTTP_TRACE_MIN_LOG_SIZE ; } if ( path == 0 ) { mprLog ( "error<S2SV_blank>appweb<S2SV_blank>config" , 0 , "Missing<S2SV_blank>TraceLog<S2SV_blank>filename" ) ; return MPR_ERR_BAD_SYNTAX ; } if ( formatter ) { httpSetTraceFormatterName ( route -> trace , formatter ) ; } if ( ! smatch ( path , "stdout" ) && ! smatch ( path , "stderr" ) ) { path = httpMakePath ( route , state -> configDir , path ) ; } route -> trace = httpCreateTrace ( route -> trace ) ; if ( httpSetTraceLogFile ( route -> trace , path , size , backup , format , flags ) < 0 ) { return MPR_ERR_CANT_OPEN ; } httpSetTraceLevel ( level ) ; return 0 ; }
void test_js ( void ) { GString * result = g_string_new ( "" ) ; parse_cmd_line ( "js<S2SV_blank>(\'x\'<S2SV_blank>+<S2SV_blank>345).toUpperCase()" , result ) ; g_assert_cmpstr ( "X345" , == , result -> str ) ; <S2SV_StartBug> uzbl . net . useragent = "Test<S2SV_blank>useragent" ; <S2SV_EndBug> parse_cmd_line ( "js<S2SV_blank>Uzbl.run(\'print<S2SV_blank>@useragent\').toUpperCase();" , result ) ; g_assert_cmpstr ( "TEST<S2SV_blank>USERAGENT" , == , result -> str ) ; g_string_free ( result , TRUE ) ; }
int ext4_map_blocks ( handle_t * handle , struct inode * inode , struct ext4_map_blocks * map , int flags ) { struct extent_status es ; int retval ; int ret = 0 ; # ifdef ES_AGGRESSIVE_TEST struct ext4_map_blocks orig_map ; memcpy ( & orig_map , map , sizeof ( * map ) ) ; # endif map -> m_flags = 0 ; ext_debug ( "ext4_map_blocks():<S2SV_blank>inode<S2SV_blank>%lu,<S2SV_blank>flag<S2SV_blank>%d,<S2SV_blank>max_blocks<S2SV_blank>%u," "logical<S2SV_blank>block<S2SV_blank>%lu\\n" , inode -> i_ino , flags , map -> m_len , ( unsigned long ) map -> m_lblk ) ; if ( unlikely ( map -> m_len > INT_MAX ) ) map -> m_len = INT_MAX ; if ( unlikely ( map -> m_lblk >= EXT_MAX_BLOCKS ) ) return - EFSCORRUPTED ; if ( ext4_es_lookup_extent ( inode , map -> m_lblk , & es ) ) { if ( ext4_es_is_written ( & es ) || ext4_es_is_unwritten ( & es ) ) { map -> m_pblk = ext4_es_pblock ( & es ) + map -> m_lblk - es . es_lblk ; map -> m_flags |= ext4_es_is_written ( & es ) ? EXT4_MAP_MAPPED : EXT4_MAP_UNWRITTEN ; retval = es . es_len - ( map -> m_lblk - es . es_lblk ) ; if ( retval > map -> m_len ) retval = map -> m_len ; map -> m_len = retval ; } else if ( ext4_es_is_delayed ( & es ) || ext4_es_is_hole ( & es ) ) { map -> m_pblk = 0 ; retval = es . es_len - ( map -> m_lblk - es . es_lblk ) ; if ( retval > map -> m_len ) retval = map -> m_len ; map -> m_len = retval ; retval = 0 ; } else { BUG_ON ( 1 ) ; } # ifdef ES_AGGRESSIVE_TEST ext4_map_blocks_es_recheck ( handle , inode , map , & orig_map , flags ) ; # endif goto found ; } down_read ( & EXT4_I ( inode ) -> i_data_sem ) ; if ( ext4_test_inode_flag ( inode , EXT4_INODE_EXTENTS ) ) { retval = ext4_ext_map_blocks ( handle , inode , map , flags & EXT4_GET_BLOCKS_KEEP_SIZE ) ; } else { retval = ext4_ind_map_blocks ( handle , inode , map , flags & EXT4_GET_BLOCKS_KEEP_SIZE ) ; } if ( retval > 0 ) { unsigned int status ; if ( unlikely ( retval != map -> m_len ) ) { ext4_warning ( inode -> i_sb , "ES<S2SV_blank>len<S2SV_blank>assertion<S2SV_blank>failed<S2SV_blank>for<S2SV_blank>inode<S2SV_blank>" "%lu:<S2SV_blank>retval<S2SV_blank>%d<S2SV_blank>!=<S2SV_blank>map->m_len<S2SV_blank>%d" , inode -> i_ino , retval , map -> m_len ) ; WARN_ON ( 1 ) ; } status = map -> m_flags & EXT4_MAP_UNWRITTEN ? EXTENT_STATUS_UNWRITTEN : EXTENT_STATUS_WRITTEN ; if ( ! ( flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE ) && ! ( status & EXTENT_STATUS_WRITTEN ) && ext4_find_delalloc_range ( inode , map -> m_lblk , map -> m_lblk + map -> m_len - 1 ) ) status |= EXTENT_STATUS_DELAYED ; ret = ext4_es_insert_extent ( inode , map -> m_lblk , map -> m_len , map -> m_pblk , status ) ; if ( ret < 0 ) retval = ret ; } up_read ( ( & EXT4_I ( inode ) -> i_data_sem ) ) ; found : if ( retval > 0 && map -> m_flags & EXT4_MAP_MAPPED ) { ret = check_block_validity ( inode , map ) ; if ( ret != 0 ) return ret ; } if ( ( flags & EXT4_GET_BLOCKS_CREATE ) == 0 ) return retval ; if ( retval > 0 && map -> m_flags & EXT4_MAP_MAPPED ) if ( ! ( flags & EXT4_GET_BLOCKS_CONVERT_UNWRITTEN ) ) return retval ; map -> m_flags &= ~ EXT4_MAP_FLAGS ; down_write ( & EXT4_I ( inode ) -> i_data_sem ) ; if ( ext4_test_inode_flag ( inode , EXT4_INODE_EXTENTS ) ) { retval = ext4_ext_map_blocks ( handle , inode , map , flags ) ; } else { retval = ext4_ind_map_blocks ( handle , inode , map , flags ) ; if ( retval > 0 && map -> m_flags & EXT4_MAP_NEW ) { ext4_clear_inode_state ( inode , EXT4_STATE_EXT_MIGRATE ) ; } if ( ( retval > 0 ) && ( flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE ) ) ext4_da_update_reserve_space ( inode , retval , 1 ) ; } if ( retval > 0 ) { unsigned int status ; if ( unlikely ( retval != map -> m_len ) ) { ext4_warning ( inode -> i_sb , "ES<S2SV_blank>len<S2SV_blank>assertion<S2SV_blank>failed<S2SV_blank>for<S2SV_blank>inode<S2SV_blank>" "%lu:<S2SV_blank>retval<S2SV_blank>%d<S2SV_blank>!=<S2SV_blank>map->m_len<S2SV_blank>%d" , inode -> i_ino , retval , map -> m_len ) ; WARN_ON ( 1 ) ; } if ( flags & EXT4_GET_BLOCKS_ZERO && map -> m_flags & EXT4_MAP_MAPPED && map -> m_flags & EXT4_MAP_NEW ) { ret = ext4_issue_zeroout ( inode , map -> m_lblk , map -> m_pblk , map -> m_len ) ; if ( ret ) { retval = ret ; goto out_sem ; } } if ( ( flags & EXT4_GET_BLOCKS_PRE_IO ) && ext4_es_lookup_extent ( inode , map -> m_lblk , & es ) ) { if ( ext4_es_is_written ( & es ) ) goto out_sem ; } status = map -> m_flags & EXT4_MAP_UNWRITTEN ? EXTENT_STATUS_UNWRITTEN : EXTENT_STATUS_WRITTEN ; if ( ! ( flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE ) && ! ( status & EXTENT_STATUS_WRITTEN ) && ext4_find_delalloc_range ( inode , map -> m_lblk , map -> m_lblk + map -> m_len - 1 ) ) status |= EXTENT_STATUS_DELAYED ; ret = ext4_es_insert_extent ( inode , map -> m_lblk , map -> m_len , map -> m_pblk , status ) ; if ( ret < 0 ) { retval = ret ; goto out_sem ; } } out_sem : up_write ( ( & EXT4_I ( inode ) -> i_data_sem ) ) ; if ( retval > 0 && map -> m_flags & EXT4_MAP_MAPPED ) { ret = check_block_validity ( inode , map ) ; if ( ret != 0 ) return ret ; <S2SV_StartBug> } <S2SV_EndBug> return retval ; }
static void setup_format_params ( int track ) { int n ; int il ; int count ; int head_shift ; int track_shift ; struct fparm { unsigned char track , head , sect , size ; } * here = ( struct fparm * ) floppy_track_buffer ; raw_cmd = & default_raw_cmd ; raw_cmd -> track = track ; raw_cmd -> flags = ( FD_RAW_WRITE | FD_RAW_INTR | FD_RAW_SPIN | FD_RAW_NEED_DISK | FD_RAW_NEED_SEEK ) ; raw_cmd -> rate = _floppy -> rate & 0x43 ; raw_cmd -> cmd_count = NR_F ; COMMAND = FM_MODE ( _floppy , FD_FORMAT ) ; DR_SELECT = UNIT ( current_drive ) + PH_HEAD ( _floppy , format_req . head ) ; F_SIZECODE = FD_SIZECODE ( _floppy ) ; F_SECT_PER_TRACK = _floppy -> sect << 2 >> F_SIZECODE ; F_GAP = _floppy -> fmt_gap ; F_FILL = FD_FILL_BYTE ; raw_cmd -> kernel_data = floppy_track_buffer ; raw_cmd -> length = 4 * F_SECT_PER_TRACK ; <S2SV_StartBug> head_shift = ( F_SECT_PER_TRACK + 5 ) / 6 ; <S2SV_EndBug> track_shift = 2 * head_shift + 3 ; n = ( track_shift * format_req . track + head_shift * format_req . head ) % F_SECT_PER_TRACK ; il = 1 ; if ( _floppy -> fmt_gap < 0x22 ) il ++ ; for ( count = 0 ; count < F_SECT_PER_TRACK ; ++ count ) { here [ count ] . track = format_req . track ; here [ count ] . head = format_req . head ; here [ count ] . sect = 0 ; here [ count ] . size = F_SIZECODE ; } for ( count = 1 ; count <= F_SECT_PER_TRACK ; ++ count ) { here [ n ] . sect = count ; n = ( n + il ) % F_SECT_PER_TRACK ; if ( here [ n ] . sect ) { ++ n ; if ( n >= F_SECT_PER_TRACK ) { n -= F_SECT_PER_TRACK ; while ( here [ n ] . sect ) ++ n ; } } } if ( _floppy -> stretch & FD_SECTBASEMASK ) { for ( count = 0 ; count < F_SECT_PER_TRACK ; count ++ ) here [ count ] . sect += FD_SECTBASE ( _floppy ) - 1 ; } }
static void jpc_undo_roi ( jas_matrix_t * x , int roishift , int bgshift , int numbps ) { int i ; int j ; int thresh ; jpc_fix_t val ; jpc_fix_t mag ; bool warn ; uint_fast32_t mask ; <S2SV_StartBug> if ( roishift == 0 && bgshift == 0 ) { <S2SV_EndBug> return ; } thresh = 1 << roishift ; warn = false ; for ( i = 0 ; i < jas_matrix_numrows ( x ) ; ++ i ) { for ( j = 0 ; j < jas_matrix_numcols ( x ) ; ++ j ) { val = jas_matrix_get ( x , i , j ) ; mag = JAS_ABS ( val ) ; if ( mag >= thresh ) { mag >>= roishift ; val = ( val < 0 ) ? ( - mag ) : mag ; jas_matrix_set ( x , i , j , val ) ; } else { mag <<= bgshift ; <S2SV_StartBug> mask = ( 1 << numbps ) - 1 ; <S2SV_EndBug> if ( mag & ( ~ mask ) ) { if ( ! warn ) { jas_eprintf ( "warning:<S2SV_blank>possibly<S2SV_blank>corrupt<S2SV_blank>code<S2SV_blank>stream\\n" ) ; warn = true ; } mag &= mask ; } val = ( val < 0 ) ? ( - mag ) : mag ; jas_matrix_set ( x , i , j , val ) ; } } } }
static bool nested_vmx_exit_handled ( struct kvm_vcpu * vcpu ) { u32 intr_info = vmcs_read32 ( VM_EXIT_INTR_INFO ) ; struct vcpu_vmx * vmx = to_vmx ( vcpu ) ; struct vmcs12 * vmcs12 = get_vmcs12 ( vcpu ) ; u32 exit_reason = vmx -> exit_reason ; trace_kvm_nested_vmexit ( kvm_rip_read ( vcpu ) , exit_reason , vmcs_readl ( EXIT_QUALIFICATION ) , vmx -> idt_vectoring_info , intr_info , vmcs_read32 ( VM_EXIT_INTR_ERROR_CODE ) , KVM_ISA_VMX ) ; if ( vmx -> nested . nested_run_pending ) return 0 ; if ( unlikely ( vmx -> fail ) ) { pr_info_ratelimited ( "%s<S2SV_blank>failed<S2SV_blank>vm<S2SV_blank>entry<S2SV_blank>%x\\n" , __func__ , vmcs_read32 ( VM_INSTRUCTION_ERROR ) ) ; return 1 ; } switch ( exit_reason ) { case EXIT_REASON_EXCEPTION_NMI : if ( ! is_exception ( intr_info ) ) return 0 ; else if ( is_page_fault ( intr_info ) ) return enable_ept ; else if ( is_no_device ( intr_info ) && ! ( vmcs12 -> guest_cr0 & X86_CR0_TS ) ) return 0 ; return vmcs12 -> exception_bitmap & ( 1u << ( intr_info & INTR_INFO_VECTOR_MASK ) ) ; case EXIT_REASON_EXTERNAL_INTERRUPT : return 0 ; case EXIT_REASON_TRIPLE_FAULT : return 1 ; case EXIT_REASON_PENDING_INTERRUPT : return nested_cpu_has ( vmcs12 , CPU_BASED_VIRTUAL_INTR_PENDING ) ; case EXIT_REASON_NMI_WINDOW : return nested_cpu_has ( vmcs12 , CPU_BASED_VIRTUAL_NMI_PENDING ) ; case EXIT_REASON_TASK_SWITCH : return 1 ; case EXIT_REASON_CPUID : if ( kvm_register_read ( vcpu , VCPU_REGS_RAX ) == 0xa ) return 0 ; return 1 ; case EXIT_REASON_HLT : return nested_cpu_has ( vmcs12 , CPU_BASED_HLT_EXITING ) ; case EXIT_REASON_INVD : return 1 ; case EXIT_REASON_INVLPG : return nested_cpu_has ( vmcs12 , CPU_BASED_INVLPG_EXITING ) ; case EXIT_REASON_RDPMC : return nested_cpu_has ( vmcs12 , CPU_BASED_RDPMC_EXITING ) ; case EXIT_REASON_RDTSC : return nested_cpu_has ( vmcs12 , CPU_BASED_RDTSC_EXITING ) ; case EXIT_REASON_VMCALL : case EXIT_REASON_VMCLEAR : case EXIT_REASON_VMLAUNCH : case EXIT_REASON_VMPTRLD : case EXIT_REASON_VMPTRST : case EXIT_REASON_VMREAD : case EXIT_REASON_VMRESUME : case EXIT_REASON_VMWRITE : case EXIT_REASON_VMOFF : case EXIT_REASON_VMON : <S2SV_StartBug> case EXIT_REASON_INVEPT : <S2SV_EndBug> return 1 ; case EXIT_REASON_CR_ACCESS : return nested_vmx_exit_handled_cr ( vcpu , vmcs12 ) ; case EXIT_REASON_DR_ACCESS : return nested_cpu_has ( vmcs12 , CPU_BASED_MOV_DR_EXITING ) ; case EXIT_REASON_IO_INSTRUCTION : return nested_vmx_exit_handled_io ( vcpu , vmcs12 ) ; case EXIT_REASON_MSR_READ : case EXIT_REASON_MSR_WRITE : return nested_vmx_exit_handled_msr ( vcpu , vmcs12 , exit_reason ) ; case EXIT_REASON_INVALID_STATE : return 1 ; case EXIT_REASON_MWAIT_INSTRUCTION : return nested_cpu_has ( vmcs12 , CPU_BASED_MWAIT_EXITING ) ; case EXIT_REASON_MONITOR_INSTRUCTION : return nested_cpu_has ( vmcs12 , CPU_BASED_MONITOR_EXITING ) ; case EXIT_REASON_PAUSE_INSTRUCTION : return nested_cpu_has ( vmcs12 , CPU_BASED_PAUSE_EXITING ) || nested_cpu_has2 ( vmcs12 , SECONDARY_EXEC_PAUSE_LOOP_EXITING ) ; case EXIT_REASON_MCE_DURING_VMENTRY : return 0 ; case EXIT_REASON_TPR_BELOW_THRESHOLD : return nested_cpu_has ( vmcs12 , CPU_BASED_TPR_SHADOW ) ; case EXIT_REASON_APIC_ACCESS : return nested_cpu_has2 ( vmcs12 , SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES ) ; case EXIT_REASON_EPT_VIOLATION : return 0 ; case EXIT_REASON_EPT_MISCONFIG : return 0 ; case EXIT_REASON_WBINVD : return nested_cpu_has2 ( vmcs12 , SECONDARY_EXEC_WBINVD_EXITING ) ; case EXIT_REASON_XSETBV : return 1 ; default : return 1 ; } }
static int validate_event ( struct pmu_hw_events * hw_events , struct perf_event * event ) { struct arm_pmu * armpmu = to_arm_pmu ( event -> pmu ) ; <S2SV_StartBug> struct pmu * leader_pmu = event -> group_leader -> pmu ; <S2SV_EndBug> if ( event -> pmu != leader_pmu || event -> state < PERF_EVENT_STATE_OFF ) return 1 ; if ( event -> state == PERF_EVENT_STATE_OFF && ! event -> attr . enable_on_exec ) return 1 ; return armpmu -> get_event_idx ( hw_events , event ) >= 0 ; }
static int lua_websocket_read ( lua_State * L ) { apr_socket_t * sock ; apr_status_t rv ; <S2SV_StartBug> int n = 0 ; <S2SV_EndBug> apr_size_t len = 1 ; apr_size_t plen = 0 ; unsigned short payload_short = 0 ; apr_uint64_t payload_long = 0 ; unsigned char * mask_bytes ; char byte ; int plaintext ; request_rec * r = ap_lua_check_request_rec ( L , 1 ) ; plaintext = ap_lua_ssl_is_https ( r -> connection ) ? 0 : 1 ; mask_bytes = apr_pcalloc ( r -> pool , 4 ) ; <S2SV_StartBug> sock = ap_get_conn_socket ( r -> connection ) ; <S2SV_EndBug> if ( plaintext ) { rv = apr_socket_recv ( sock , & byte , & len ) ; } else { rv = lua_websocket_readbytes ( r -> connection , & byte , 1 ) ; } if ( rv == APR_SUCCESS ) { unsigned char ubyte , fin , opcode , mask , payload ; ubyte = ( unsigned char ) byte ; fin = ubyte >> ( CHAR_BIT - 1 ) ; opcode = ubyte & 0xf ; if ( plaintext ) { rv = apr_socket_recv ( sock , & byte , & len ) ; } else { rv = lua_websocket_readbytes ( r -> connection , & byte , 1 ) ; } if ( rv == APR_SUCCESS ) { ubyte = ( unsigned char ) byte ; mask = ubyte >> ( CHAR_BIT - 1 ) ; payload = ubyte & 0x7f ; plen = payload ; if ( payload == 126 ) { len = 2 ; if ( plaintext ) { rv = apr_socket_recv ( sock , ( char * ) & payload_short , & len ) ; } else { rv = lua_websocket_readbytes ( r -> connection , ( char * ) & payload_short , 2 ) ; } payload_short = ntohs ( payload_short ) ; if ( rv == APR_SUCCESS ) { plen = payload_short ; } else { return 0 ; } } if ( payload == 127 ) { len = 8 ; if ( plaintext ) { rv = apr_socket_recv ( sock , ( char * ) & payload_long , & len ) ; } else { rv = lua_websocket_readbytes ( r -> connection , ( char * ) & payload_long , 8 ) ; } if ( rv == APR_SUCCESS ) { plen = ap_ntoh64 ( & payload_long ) ; } else { return 0 ; } } ap_log_rerror ( APLOG_MARK , APLOG_DEBUG , 0 , r , "Websocket:<S2SV_blank>Reading<S2SV_blank>%" APR_SIZE_T_FMT "<S2SV_blank>(%s)<S2SV_blank>bytes,<S2SV_blank>masking<S2SV_blank>is<S2SV_blank>%s.<S2SV_blank>%s" , plen , ( payload >= 126 ) ? "extra<S2SV_blank>payload" : "no<S2SV_blank>extra<S2SV_blank>payload" , mask ? "on" : "off" , fin ? "This<S2SV_blank>is<S2SV_blank>a<S2SV_blank>final<S2SV_blank>frame" : "more<S2SV_blank>to<S2SV_blank>follow" ) ; if ( mask ) { len = 4 ; if ( plaintext ) { rv = apr_socket_recv ( sock , ( char * ) mask_bytes , & len ) ; } else { rv = lua_websocket_readbytes ( r -> connection , ( char * ) mask_bytes , 4 ) ; } if ( rv != APR_SUCCESS ) { return 0 ; } } if ( plen < ( HUGE_STRING_LEN * 1024 ) && plen > 0 ) { apr_size_t remaining = plen ; apr_size_t received ; apr_off_t at = 0 ; char * buffer = apr_palloc ( r -> pool , plen + 1 ) ; buffer [ plen ] = 0 ; if ( plaintext ) { while ( remaining > 0 ) { received = remaining ; rv = apr_socket_recv ( sock , buffer + at , & received ) ; if ( received > 0 ) { remaining -= received ; at += received ; } } ap_log_rerror ( APLOG_MARK , APLOG_TRACE1 , 0 , r , "Websocket:<S2SV_blank>Frame<S2SV_blank>contained<S2SV_blank>%" APR_OFF_T_FMT "<S2SV_blank>bytes,<S2SV_blank>pushed<S2SV_blank>to<S2SV_blank>Lua<S2SV_blank>stack" , at ) ; } else { rv = lua_websocket_readbytes ( r -> connection , buffer , remaining ) ; ap_log_rerror ( APLOG_MARK , APLOG_TRACE1 , 0 , r , "Websocket:<S2SV_blank>SSL<S2SV_blank>Frame<S2SV_blank>contained<S2SV_blank>%" APR_SIZE_T_FMT "<S2SV_blank>bytes,<S2SV_blank>" "pushed<S2SV_blank>to<S2SV_blank>Lua<S2SV_blank>stack" , remaining ) ; } if ( mask ) { for ( n = 0 ; n < plen ; n ++ ) { buffer [ n ] ^= mask_bytes [ n % 4 ] ; } } lua_pushlstring ( L , buffer , ( size_t ) plen ) ; lua_pushboolean ( L , fin ) ; return 2 ; } if ( opcode == 0x09 ) { char frame [ 2 ] ; plen = 2 ; frame [ 0 ] = 0x8A ; frame [ 1 ] = 0 ; apr_socket_send ( sock , frame , & plen ) ; <S2SV_StartBug> lua_websocket_read ( L ) ; <S2SV_EndBug> } } } return 0 ; }
static struct mnt_namespace * dup_mnt_ns ( struct mnt_namespace * mnt_ns , struct user_namespace * user_ns , struct fs_struct * fs ) { struct mnt_namespace * new_ns ; struct vfsmount * rootmnt = NULL , * pwdmnt = NULL ; struct mount * p , * q ; struct mount * old = mnt_ns -> root ; struct mount * new ; int copy_flags ; new_ns = alloc_mnt_ns ( user_ns ) ; if ( IS_ERR ( new_ns ) ) return new_ns ; down_write ( & namespace_sem ) ; copy_flags = CL_COPY_ALL | CL_EXPIRE ; if ( user_ns != mnt_ns -> user_ns ) <S2SV_StartBug> copy_flags |= CL_SHARED_TO_SLAVE ; <S2SV_EndBug> new = copy_tree ( old , old -> mnt . mnt_root , copy_flags ) ; if ( IS_ERR ( new ) ) { up_write ( & namespace_sem ) ; free_mnt_ns ( new_ns ) ; return ERR_CAST ( new ) ; } new_ns -> root = new ; br_write_lock ( & vfsmount_lock ) ; list_add_tail ( & new_ns -> list , & new -> mnt_list ) ; br_write_unlock ( & vfsmount_lock ) ; p = old ; q = new ; while ( p ) { q -> mnt_ns = new_ns ; if ( fs ) { if ( & p -> mnt == fs -> root . mnt ) { fs -> root . mnt = mntget ( & q -> mnt ) ; rootmnt = & p -> mnt ; } if ( & p -> mnt == fs -> pwd . mnt ) { fs -> pwd . mnt = mntget ( & q -> mnt ) ; pwdmnt = & p -> mnt ; } } p = next_mnt ( p , old ) ; q = next_mnt ( q , new ) ; } up_write ( & namespace_sem ) ; if ( rootmnt ) mntput ( rootmnt ) ; if ( pwdmnt ) mntput ( pwdmnt ) ; return new_ns ; }
void uwbd_stop ( struct uwb_rc * rc ) <S2SV_StartBug> { <S2SV_EndBug> kthread_stop ( rc -> uwbd . task ) ; uwbd_flush ( rc ) ; }
static void perf_event_interrupt ( struct pt_regs * regs ) { int i ; struct cpu_hw_events * cpuhw = & __get_cpu_var ( cpu_hw_events ) ; struct perf_event * event ; unsigned long val ; int found = 0 ; int nmi ; nmi = perf_intr_is_nmi ( regs ) ; if ( nmi ) nmi_enter ( ) ; else irq_enter ( ) ; for ( i = 0 ; i < ppmu -> n_counter ; ++ i ) { event = cpuhw -> event [ i ] ; val = read_pmc ( i ) ; if ( ( int ) val < 0 ) { if ( event ) { found = 1 ; <S2SV_StartBug> record_and_restart ( event , val , regs , nmi ) ; <S2SV_EndBug> } else { write_pmc ( i , 0 ) ; } } } mtmsr ( mfmsr ( ) | MSR_PMM ) ; mtpmr ( PMRN_PMGC0 , PMGC0_PMIE | PMGC0_FCECE ) ; isync ( ) ; if ( nmi ) nmi_exit ( ) ; else irq_exit ( ) ; }
static Image * ReadGRAYImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * canvas_image , * image ; MagickBooleanType status ; MagickOffsetType scene ; QuantumInfo * quantum_info ; QuantumType quantum_type ; size_t length ; ssize_t count , y ; unsigned char * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , "%s" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; if ( ( image -> columns == 0 ) || ( image -> rows == 0 ) ) ThrowReaderException ( OptionError , "MustSpecifyImageSize" ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } if ( DiscardBlobBytes ( image , ( size_t ) image -> offset ) == MagickFalse ) ThrowFileException ( exception , CorruptImageError , "UnexpectedEndOfFile" , image -> filename ) ; SetImageColorspace ( image , GRAYColorspace ) ; canvas_image = CloneImage ( image , image -> extract_info . width , 1 , MagickFalse , exception ) ; ( void ) SetImageVirtualPixelMethod ( canvas_image , BlackVirtualPixelMethod ) ; quantum_type = GrayQuantum ; quantum_info = AcquireQuantumInfo ( image_info , canvas_image ) ; if ( quantum_info == ( QuantumInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; pixels = GetQuantumPixels ( quantum_info ) ; if ( image_info -> number_scenes != 0 ) while ( image -> scene < image_info -> scene ) { image -> scene ++ ; length = GetQuantumExtent ( canvas_image , quantum_info , quantum_type ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { count = ReadBlob ( image , length , pixels ) ; if ( count != ( ssize_t ) length ) break ; } } scene = 0 ; count = 0 ; length = 0 ; do { if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; <S2SV_StartBug> SetImageColorspace ( image , GRAYColorspace ) ; <S2SV_EndBug> if ( scene == 0 ) { length = GetQuantumExtent ( canvas_image , quantum_info , quantum_type ) ; count = ReadBlob ( image , length , pixels ) ; } for ( y = 0 ; y < ( ssize_t ) image -> extract_info . height ; y ++ ) { register const PixelPacket * restrict p ; register ssize_t x ; register PixelPacket * restrict q ; if ( count != ( ssize_t ) length ) { ThrowFileException ( exception , CorruptImageError , "UnexpectedEndOfFile" , image -> filename ) ; break ; } q = GetAuthenticPixels ( canvas_image , 0 , 0 , canvas_image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; length = ImportQuantumPixels ( canvas_image , ( CacheView * ) NULL , quantum_info , quantum_type , pixels , exception ) ; if ( SyncAuthenticPixels ( canvas_image , exception ) == MagickFalse ) break ; if ( ( ( y - image -> extract_info . y ) >= 0 ) && ( ( y - image -> extract_info . y ) < ( ssize_t ) image -> rows ) ) { p = GetVirtualPixels ( canvas_image , canvas_image -> extract_info . x , 0 , image -> columns , 1 , exception ) ; q = QueueAuthenticPixels ( image , 0 , y - image -> extract_info . y , image -> columns , 1 , exception ) ; if ( ( p == ( const PixelPacket * ) NULL ) || ( q == ( PixelPacket * ) NULL ) ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( q , GetPixelRed ( p ) ) ; SetPixelGreen ( q , GetPixelGreen ( p ) ) ; SetPixelBlue ( q , GetPixelBlue ( p ) ) ; p ++ ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } count = ReadBlob ( image , length , pixels ) ; } SetQuantumImageType ( image , quantum_type ) ; if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; if ( count == ( ssize_t ) length ) { AcquireNextImage ( image_info , image ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } scene ++ ; } while ( count == ( ssize_t ) length ) ; quantum_info = DestroyQuantumInfo ( quantum_info ) ; InheritException ( & image -> exception , & canvas_image -> exception ) ; canvas_image = DestroyImage ( canvas_image ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
int fit_image_verify ( const void * fit , int image_noffset ) { <S2SV_StartBug> const void * data ; <S2SV_EndBug> size_t size ; <S2SV_StartBug> int noffset = 0 ; <S2SV_EndBug> <S2SV_StartBug> char * err_msg = "" ; <S2SV_EndBug> if ( fit_image_get_data_and_size ( fit , image_noffset , & data , & size ) ) { err_msg = "Can\'t<S2SV_blank>get<S2SV_blank>image<S2SV_blank>data/size" ; <S2SV_StartBug> printf ( "error!\\n%s<S2SV_blank>for<S2SV_blank>\'%s\'<S2SV_blank>hash<S2SV_blank>node<S2SV_blank>in<S2SV_blank>\'%s\'<S2SV_blank>image<S2SV_blank>node\\n" , <S2SV_EndBug> <S2SV_StartBug> err_msg , fit_get_name ( fit , noffset , NULL ) , <S2SV_EndBug> fit_get_name ( fit , image_noffset , NULL ) ) ; return 0 ; } <S2SV_StartBug> return fit_image_verify_with_data ( fit , image_noffset , data , size ) ; <S2SV_EndBug> }
int WavpackVerifySingleBlock ( unsigned char * buffer , int verify_checksum ) { WavpackHeader * wphdr = ( WavpackHeader * ) buffer ; uint32_t checksum_passed = 0 , bcount , meta_bc ; unsigned char * dp , meta_id , c1 , c2 ; if ( strncmp ( wphdr -> ckID , "wvpk" , 4 ) || wphdr -> ckSize + 8 < sizeof ( WavpackHeader ) ) return FALSE ; bcount = wphdr -> ckSize - sizeof ( WavpackHeader ) + 8 ; dp = ( unsigned char * ) ( wphdr + 1 ) ; while ( bcount >= 2 ) { meta_id = * dp ++ ; c1 = * dp ++ ; meta_bc = c1 << 1 ; bcount -= 2 ; if ( meta_id & ID_LARGE ) { if ( bcount < 2 ) return FALSE ; c1 = * dp ++ ; c2 = * dp ++ ; meta_bc += ( ( uint32_t ) c1 << 9 ) + ( ( uint32_t ) c2 << 17 ) ; bcount -= 2 ; } if ( bcount < meta_bc ) return FALSE ; if ( verify_checksum && ( meta_id & ID_UNIQUE ) == ID_BLOCK_CHECKSUM ) { # ifdef BITSTREAM_SHORTS uint16_t * csptr = ( uint16_t * ) buffer ; # else unsigned char * csptr = buffer ; # endif int wcount = ( int ) ( dp - 2 - buffer ) >> 1 ; uint32_t csum = ( uint32_t ) - 1 ; if ( ( meta_id & ID_ODD_SIZE ) || meta_bc < 2 || meta_bc > 4 ) return FALSE ; # ifdef BITSTREAM_SHORTS while ( wcount -- ) csum = ( csum * 3 ) + * csptr ++ ; # else WavpackNativeToLittleEndian ( ( WavpackHeader * ) buffer , WavpackHeaderFormat ) ; while ( wcount -- ) { csum = ( csum * 3 ) + csptr [ 0 ] + ( csptr [ 1 ] << 8 ) ; csptr += 2 ; } WavpackLittleEndianToNative ( ( WavpackHeader * ) buffer , WavpackHeaderFormat ) ; # endif if ( meta_bc == 4 ) { <S2SV_StartBug> if ( * dp ++ != ( csum & 0xff ) || * dp ++ != ( ( csum >> 8 ) & 0xff ) || * dp ++ != ( ( csum >> 16 ) & 0xff ) || * dp ++ != ( ( csum >> 24 ) & 0xff ) ) <S2SV_EndBug> return FALSE ; } else { csum ^= csum >> 16 ; <S2SV_StartBug> if ( * dp ++ != ( csum & 0xff ) || * dp ++ != ( ( csum >> 8 ) & 0xff ) ) <S2SV_EndBug> return FALSE ; } checksum_passed ++ ; } bcount -= meta_bc ; dp += meta_bc ; } return ( bcount == 0 ) && ( ! verify_checksum || ! ( wphdr -> flags & HAS_CHECKSUM ) || checksum_passed ) ; }
int wc_SignatureGenerate ( enum wc_HashType hash_type , enum wc_SignatureType sig_type , const byte * data , word32 data_len , byte * sig , word32 * sig_len , const void * key , word32 key_len , WC_RNG * rng ) { <S2SV_StartBug> int ret ; <S2SV_EndBug> word32 hash_len , hash_enc_len ; # ifdef WOLFSSL_SMALL_STACK byte * hash_data ; # else byte hash_data [ MAX_DER_DIGEST_SZ ] ; # endif if ( data == NULL || data_len <= 0 || sig == NULL || sig_len == NULL || * sig_len <= 0 || key == NULL || key_len <= 0 ) { return BAD_FUNC_ARG ; } if ( ( int ) * sig_len < wc_SignatureGetSize ( sig_type , key , key_len ) ) { WOLFSSL_MSG ( "wc_SignatureGenerate:<S2SV_blank>Invalid<S2SV_blank>sig<S2SV_blank>type/len" ) ; return BAD_FUNC_ARG ; } ret = wc_HashGetDigestSize ( hash_type ) ; if ( ret < 0 ) { WOLFSSL_MSG ( "wc_SignatureGenerate:<S2SV_blank>Invalid<S2SV_blank>hash<S2SV_blank>type/len" ) ; return ret ; } hash_enc_len = hash_len = ret ; # if ! defined ( NO_RSA ) && ! defined ( WOLFSSL_RSA_PUBLIC_ONLY ) if ( sig_type == WC_SIGNATURE_TYPE_RSA_W_ENC ) { hash_enc_len += MAX_DER_DIGEST_ASN_SZ ; } # endif # ifdef WOLFSSL_SMALL_STACK hash_data = ( byte * ) XMALLOC ( hash_enc_len , NULL , DYNAMIC_TYPE_TMP_BUFFER ) ; if ( hash_data == NULL ) { return MEMORY_E ; } # endif <S2SV_StartBug> ret = wc_Hash ( hash_type , data , data_len , hash_data , hash_len ) ; <S2SV_EndBug> if ( ret == 0 ) { if ( sig_type == WC_SIGNATURE_TYPE_RSA_W_ENC ) { # if defined ( NO_RSA ) || defined ( NO_ASN ) || defined ( WOLFSSL_RSA_PUBLIC_ONLY ) ret = SIG_TYPE_E ; # else ret = wc_SignatureDerEncode ( hash_type , hash_data , hash_len , & hash_enc_len ) ; # endif } if ( ret == 0 ) { ret = wc_SignatureGenerateHash ( hash_type , sig_type , <S2SV_StartBug> hash_data , hash_enc_len , sig , sig_len , key , key_len , rng ) ; <S2SV_EndBug> } <S2SV_StartBug> } <S2SV_EndBug> # ifdef WOLFSSL_SMALL_STACK XFREE ( hash_data , NULL , DYNAMIC_TYPE_TMP_BUFFER ) ; # endif return ret ; }
static int hgcm_call_preprocess_linaddr ( const struct vmmdev_hgcm_function_parameter * src_parm , void * * bounce_buf_ret , size_t * extra ) { void * buf , * bounce_buf ; bool copy_in ; u32 len ; int ret ; buf = ( void * ) src_parm -> u . pointer . u . linear_addr ; len = src_parm -> u . pointer . size ; copy_in = src_parm -> type != VMMDEV_HGCM_PARM_TYPE_LINADDR_OUT ; if ( len > VBG_MAX_HGCM_USER_PARM ) return - E2BIG ; bounce_buf = kvmalloc ( len , GFP_KERNEL ) ; if ( ! bounce_buf ) return - ENOMEM ; <S2SV_StartBug> if ( copy_in ) { <S2SV_EndBug> ret = copy_from_user ( bounce_buf , ( void __user * ) buf , len ) ; if ( ret ) return - EFAULT ; } else { memset ( bounce_buf , 0 , len ) ; } <S2SV_StartBug> * bounce_buf_ret = bounce_buf ; <S2SV_EndBug> hgcm_call_add_pagelist_size ( bounce_buf , len , extra ) ; return 0 ; }
static double calculate_modified_err ( const VP9_COMP * cpi , <S2SV_StartBug> const FIRSTPASS_STATS * this_frame ) { <S2SV_EndBug> <S2SV_StartBug> const struct twopass_rc * twopass = & cpi -> twopass ; <S2SV_EndBug> const SVC * const svc = & cpi -> svc ; const FIRSTPASS_STATS * stats ; double av_err ; double modified_error ; if ( svc -> number_spatial_layers > 1 && svc -> number_temporal_layers == 1 ) { twopass = & svc -> layer_context [ svc -> spatial_layer_id ] . twopass ; } stats = & twopass -> total_stats ; <S2SV_StartBug> av_err = stats -> ssim_weighted_pred_err / stats -> count ; <S2SV_EndBug> <S2SV_StartBug> modified_error = av_err * pow ( this_frame -> ssim_weighted_pred_err / <S2SV_EndBug> DOUBLE_DIVIDE_CHECK ( av_err ) , <S2SV_StartBug> cpi -> oxcf . two_pass_vbrbias / 100.0 ) ; <S2SV_EndBug> return fclamp ( modified_error , twopass -> modified_error_min , twopass -> modified_error_max ) ; }
static void __iov_iter_advance_iov ( struct iov_iter * i , size_t bytes ) { if ( likely ( i -> nr_segs == 1 ) ) { i -> iov_offset += bytes ; } else { const struct iovec * iov = i -> iov ; size_t base = i -> iov_offset ; <S2SV_StartBug> while ( bytes ) { <S2SV_EndBug> int copy = min ( bytes , iov -> iov_len - base ) ; bytes -= copy ; base += copy ; if ( iov -> iov_len == base ) { iov ++ ; base = 0 ; } } i -> iov = iov ; i -> iov_offset = base ; } }
BOOL transport_accept_nla ( rdpTransport * transport ) { freerdp * instance ; rdpSettings * settings ; if ( transport -> TlsIn == NULL ) transport -> TlsIn = tls_new ( transport -> settings ) ; if ( transport -> TlsOut == NULL ) transport -> TlsOut = transport -> TlsIn ; transport -> layer = TRANSPORT_LAYER_TLS ; transport -> TlsIn -> sockfd = transport -> TcpIn -> sockfd ; if ( tls_accept ( transport -> TlsIn , transport -> settings -> CertificateFile , transport -> settings -> PrivateKeyFile ) != TRUE ) return FALSE ; if ( transport -> settings -> Authentication != TRUE ) return TRUE ; settings = transport -> settings ; instance = ( freerdp * ) settings -> instance ; if ( transport -> credssp == NULL ) transport -> credssp = credssp_new ( instance , transport , settings ) ; if ( credssp_authenticate ( transport -> credssp ) < 0 ) { fprintf ( stderr , "client<S2SV_blank>authentication<S2SV_blank>failure\\n" ) ; credssp_free ( transport -> credssp ) ; <S2SV_StartBug> return FALSE ; <S2SV_EndBug> } return TRUE ; }
bool ExprResolveLhs ( struct xkb_context * ctx , const ExprDef * expr , const char * * elem_rtrn , const char * * field_rtrn , ExprDef * * index_rtrn ) { switch ( expr -> expr . op ) { case EXPR_IDENT : * elem_rtrn = NULL ; * field_rtrn = xkb_atom_text ( ctx , expr -> ident . ident ) ; * index_rtrn = NULL ; <S2SV_StartBug> return true ; <S2SV_EndBug> case EXPR_FIELD_REF : * elem_rtrn = xkb_atom_text ( ctx , expr -> field_ref . element ) ; * field_rtrn = xkb_atom_text ( ctx , expr -> field_ref . field ) ; * index_rtrn = NULL ; return true ; case EXPR_ARRAY_REF : * elem_rtrn = xkb_atom_text ( ctx , expr -> array_ref . element ) ; * field_rtrn = xkb_atom_text ( ctx , expr -> array_ref . field ) ; * index_rtrn = expr -> array_ref . entry ; return true ; default : break ; } log_wsgo ( ctx , "Unexpected<S2SV_blank>operator<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>ResolveLhs\\n" , expr -> expr . op ) ; return false ; }
static MatchinfoBuffer * fts3MIBufferNew ( int nElem , const char * zMatchinfo ) { MatchinfoBuffer * pRet ; <S2SV_StartBug> int nByte = sizeof ( u32 ) * ( 2 * nElem + 1 ) + sizeof ( MatchinfoBuffer ) ; <S2SV_EndBug> <S2SV_StartBug> int nStr = ( int ) strlen ( zMatchinfo ) ; <S2SV_EndBug> <S2SV_StartBug> pRet = sqlite3_malloc ( nByte + nStr + 1 ) ; <S2SV_EndBug> if ( pRet ) { memset ( pRet , 0 , nByte ) ; pRet -> aMatchinfo [ 0 ] = ( u8 * ) ( & pRet -> aMatchinfo [ 1 ] ) - ( u8 * ) pRet ; pRet -> aMatchinfo [ 1 + nElem ] = pRet -> aMatchinfo [ 0 ] + sizeof ( u32 ) * ( nElem + 1 ) ; pRet -> nElem = nElem ; pRet -> zMatchinfo = ( ( char * ) pRet ) + nByte ; memcpy ( pRet -> zMatchinfo , zMatchinfo , nStr + 1 ) ; pRet -> aRef [ 0 ] = 1 ; } return pRet ; }
int handle_ldf_stq ( u32 insn , struct pt_regs * regs ) { unsigned long addr = compute_effective_address ( regs , insn , 0 ) ; int freg = ( ( insn >> 25 ) & 0x1e ) | ( ( insn >> 20 ) & 0x20 ) ; struct fpustate * f = FPUSTATE ; int asi = decode_asi ( insn , regs ) ; int flag = ( freg < 32 ) ? FPRS_DL : FPRS_DU ; <S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , 0 ) ; <S2SV_EndBug> save_and_clear_fpu ( ) ; current_thread_info ( ) -> xfsr [ 0 ] &= ~ 0x1c000 ; if ( freg & 3 ) { current_thread_info ( ) -> xfsr [ 0 ] |= ( 6 << 14 ) ; do_fpother ( regs ) ; return 0 ; } if ( insn & 0x200000 ) { u64 first = 0 , second = 0 ; if ( current_thread_info ( ) -> fpsaved [ 0 ] & flag ) { first = * ( u64 * ) & f -> regs [ freg ] ; second = * ( u64 * ) & f -> regs [ freg + 2 ] ; } if ( asi < 0x80 ) { do_privact ( regs ) ; return 1 ; } switch ( asi ) { case ASI_P : case ASI_S : break ; case ASI_PL : case ASI_SL : { u64 tmp = __swab64p ( & first ) ; first = __swab64p ( & second ) ; second = tmp ; break ; } default : if ( tlb_type == hypervisor ) sun4v_data_access_exception ( regs , addr , 0 ) ; else spitfire_data_access_exception ( regs , 0 , addr ) ; return 1 ; } if ( put_user ( first >> 32 , ( u32 __user * ) addr ) || __put_user ( ( u32 ) first , ( u32 __user * ) ( addr + 4 ) ) || __put_user ( second >> 32 , ( u32 __user * ) ( addr + 8 ) ) || __put_user ( ( u32 ) second , ( u32 __user * ) ( addr + 12 ) ) ) { if ( tlb_type == hypervisor ) sun4v_data_access_exception ( regs , addr , 0 ) ; else spitfire_data_access_exception ( regs , 0 , addr ) ; return 1 ; } } else { u32 data [ 4 ] __attribute__ ( ( aligned ( 8 ) ) ) ; int size , i ; int err ; if ( asi < 0x80 ) { do_privact ( regs ) ; return 1 ; } else if ( asi > ASI_SNFL ) { if ( tlb_type == hypervisor ) sun4v_data_access_exception ( regs , addr , 0 ) ; else spitfire_data_access_exception ( regs , 0 , addr ) ; return 1 ; } switch ( insn & 0x180000 ) { case 0x000000 : size = 1 ; break ; case 0x100000 : size = 4 ; break ; default : size = 2 ; break ; } for ( i = 0 ; i < size ; i ++ ) data [ i ] = 0 ; err = get_user ( data [ 0 ] , ( u32 __user * ) addr ) ; if ( ! err ) { for ( i = 1 ; i < size ; i ++ ) err |= __get_user ( data [ i ] , ( u32 __user * ) ( addr + 4 * i ) ) ; } if ( err && ! ( asi & 0x2 ) ) { if ( tlb_type == hypervisor ) sun4v_data_access_exception ( regs , addr , 0 ) ; else spitfire_data_access_exception ( regs , 0 , addr ) ; return 1 ; } if ( asi & 0x8 ) { u64 tmp ; switch ( size ) { case 1 : data [ 0 ] = le32_to_cpup ( data + 0 ) ; break ; default : * ( u64 * ) ( data + 0 ) = le64_to_cpup ( ( u64 * ) ( data + 0 ) ) ; break ; case 4 : tmp = le64_to_cpup ( ( u64 * ) ( data + 0 ) ) ; * ( u64 * ) ( data + 0 ) = le64_to_cpup ( ( u64 * ) ( data + 2 ) ) ; * ( u64 * ) ( data + 2 ) = tmp ; break ; } } if ( ! ( current_thread_info ( ) -> fpsaved [ 0 ] & FPRS_FEF ) ) { current_thread_info ( ) -> fpsaved [ 0 ] = FPRS_FEF ; current_thread_info ( ) -> gsr [ 0 ] = 0 ; } if ( ! ( current_thread_info ( ) -> fpsaved [ 0 ] & flag ) ) { if ( freg < 32 ) memset ( f -> regs , 0 , 32 * sizeof ( u32 ) ) ; else memset ( f -> regs + 32 , 0 , 32 * sizeof ( u32 ) ) ; } memcpy ( f -> regs + freg , data , size * 4 ) ; current_thread_info ( ) -> fpsaved [ 0 ] |= flag ; } advance ( regs ) ; return 1 ; }
static int connect_to_db ( char * host , char * user , char * passwd ) { char buff [ 20 + FN_REFLEN ] ; DBUG_ENTER ( "connect_to_db" ) ; verbose_msg ( "--<S2SV_blank>Connecting<S2SV_blank>to<S2SV_blank>%s...\\n" , host ? host : "localhost" ) ; mysql_init ( & mysql_connection ) ; if ( opt_compress ) mysql_options ( & mysql_connection , MYSQL_OPT_COMPRESS , NullS ) ; <S2SV_StartBug> # ifdef HAVE_OPENSSL <S2SV_EndBug> if ( opt_use_ssl ) { mysql_ssl_set ( & mysql_connection , opt_ssl_key , opt_ssl_cert , opt_ssl_ca , opt_ssl_capath , opt_ssl_cipher ) ; mysql_options ( & mysql_connection , MYSQL_OPT_SSL_CRL , opt_ssl_crl ) ; mysql_options ( & mysql_connection , MYSQL_OPT_SSL_CRLPATH , opt_ssl_crlpath ) ; } mysql_options ( & mysql_connection , MYSQL_OPT_SSL_VERIFY_SERVER_CERT , ( char * ) & opt_ssl_verify_server_cert ) ; # endif if ( opt_protocol ) mysql_options ( & mysql_connection , MYSQL_OPT_PROTOCOL , ( char * ) & opt_protocol ) ; if ( opt_bind_addr ) mysql_options ( & mysql_connection , MYSQL_OPT_BIND , opt_bind_addr ) ; # if defined ( _WIN32 ) && ! defined ( EMBEDDED_LIBRARY ) if ( shared_memory_base_name ) mysql_options ( & mysql_connection , MYSQL_SHARED_MEMORY_BASE_NAME , shared_memory_base_name ) ; # endif mysql_options ( & mysql_connection , MYSQL_SET_CHARSET_NAME , default_charset ) ; if ( opt_plugin_dir && * opt_plugin_dir ) mysql_options ( & mysql_connection , MYSQL_PLUGIN_DIR , opt_plugin_dir ) ; if ( opt_default_auth && * opt_default_auth ) mysql_options ( & mysql_connection , MYSQL_DEFAULT_AUTH , opt_default_auth ) ; mysql_options ( & mysql_connection , MYSQL_OPT_CONNECT_ATTR_RESET , 0 ) ; mysql_options4 ( & mysql_connection , MYSQL_OPT_CONNECT_ATTR_ADD , "program_name" , "mysqldump" ) ; if ( ! ( mysql = mysql_real_connect ( & mysql_connection , host , user , passwd , NULL , opt_mysql_port , opt_mysql_unix_port , 0 ) ) ) { DB_error ( & mysql_connection , "when<S2SV_blank>trying<S2SV_blank>to<S2SV_blank>connect" ) ; DBUG_RETURN ( 1 ) ; } if ( ( mysql_get_server_version ( & mysql_connection ) < 40100 ) || ( opt_compatible_mode & 3 ) ) { opt_set_charset = 0 ; server_supports_switching_charsets = FALSE ; } mysql -> reconnect = 0 ; my_snprintf ( buff , sizeof ( buff ) , "/*!40100<S2SV_blank>SET<S2SV_blank>@@SQL_MODE=\'%s\'<S2SV_blank>*/" , compatible_mode_normal_str ) ; if ( mysql_query_with_error_report ( mysql , 0 , buff ) ) DBUG_RETURN ( 1 ) ; if ( opt_tz_utc ) { my_snprintf ( buff , sizeof ( buff ) , "/*!40103<S2SV_blank>SET<S2SV_blank>TIME_ZONE=\'+00:00\'<S2SV_blank>*/" ) ; if ( mysql_query_with_error_report ( mysql , 0 , buff ) ) DBUG_RETURN ( 1 ) ; } DBUG_RETURN ( 0 ) ; }
static int do_devinfo_ioctl ( struct comedi_device * dev , struct comedi_devinfo __user * arg , struct file * file ) { struct comedi_devinfo devinfo ; const unsigned minor = iminor ( file -> f_dentry -> d_inode ) ; struct comedi_device_file_info * dev_file_info = comedi_get_device_file_info ( minor ) ; struct comedi_subdevice * read_subdev = comedi_get_read_subdevice ( dev_file_info ) ; struct comedi_subdevice * write_subdev = comedi_get_write_subdevice ( dev_file_info ) ; memset ( & devinfo , 0 , sizeof ( devinfo ) ) ; devinfo . version_code = COMEDI_VERSION_CODE ; devinfo . n_subdevs = dev -> n_subdevices ; <S2SV_StartBug> memcpy ( devinfo . driver_name , dev -> driver -> driver_name , COMEDI_NAMELEN ) ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( devinfo . board_name , dev -> board_name , COMEDI_NAMELEN ) ; <S2SV_EndBug> if ( read_subdev ) devinfo . read_subdevice = read_subdev - dev -> subdevices ; else devinfo . read_subdevice = - 1 ; if ( write_subdev ) devinfo . write_subdevice = write_subdev - dev -> subdevices ; else devinfo . write_subdevice = - 1 ; if ( copy_to_user ( arg , & devinfo , sizeof ( struct comedi_devinfo ) ) ) return - EFAULT ; return 0 ; }
<S2SV_StartBug> void jas_matrix_bindsub ( jas_matrix_t * mat0 , jas_matrix_t * mat1 , int r0 , <S2SV_EndBug> int c0 , int r1 , int c1 ) { <S2SV_StartBug> int i ; <S2SV_EndBug> if ( mat0 -> data_ ) { if ( ! ( mat0 -> flags_ & JAS_MATRIX_REF ) ) { jas_free ( mat0 -> data_ ) ; } mat0 -> data_ = 0 ; mat0 -> datasize_ = 0 ; } if ( mat0 -> rows_ ) { jas_free ( mat0 -> rows_ ) ; mat0 -> rows_ = 0 ; } mat0 -> flags_ |= JAS_MATRIX_REF ; mat0 -> numrows_ = r1 - r0 + 1 ; mat0 -> numcols_ = c1 - c0 + 1 ; mat0 -> maxrows_ = mat0 -> numrows_ ; if ( ! ( mat0 -> rows_ = jas_alloc2 ( mat0 -> maxrows_ , sizeof ( jas_seqent_t * ) ) ) ) { abort ( ) ; } for ( i = 0 ; i < mat0 -> numrows_ ; ++ i ) { mat0 -> rows_ [ i ] = mat1 -> rows_ [ r0 + i ] + c0 ; } mat0 -> xstart_ = mat1 -> xstart_ + c0 ; mat0 -> ystart_ = mat1 -> ystart_ + r0 ; mat0 -> xend_ = mat0 -> xstart_ + mat0 -> numcols_ ; mat0 -> yend_ = mat0 -> ystart_ + mat0 -> numrows_ ; }
static const ut8 * r_bin_dwarf_parse_attr_value ( const ut8 * obuf , int obuf_len , RBinDwarfAttrSpec * spec , RBinDwarfAttrValue * value , const RBinDwarfCompUnitHdr * hdr , const ut8 * debug_str , size_t debug_str_len ) { const ut8 * buf = obuf ; const ut8 * buf_end = obuf + obuf_len ; size_t j ; <S2SV_StartBug> if ( ! spec || ! value || ! hdr || ! obuf || obuf_len < 0 ) { <S2SV_EndBug> return NULL ; } value -> form = spec -> attr_form ; value -> name = spec -> attr_name ; value -> encoding . block . data = NULL ; value -> encoding . str_struct . string = NULL ; value -> encoding . str_struct . offset = 0 ; switch ( spec -> attr_form ) { case DW_FORM_addr : switch ( hdr -> pointer_size ) { case 1 : value -> encoding . address = READ ( buf , ut8 ) ; break ; case 2 : value -> encoding . address = READ ( buf , ut16 ) ; break ; case 4 : value -> encoding . address = READ ( buf , ut32 ) ; break ; case 8 : value -> encoding . address = READ ( buf , ut64 ) ; break ; default : eprintf ( "DWARF:<S2SV_blank>Unexpected<S2SV_blank>pointer<S2SV_blank>size:<S2SV_blank>%u\\n" , ( unsigned ) hdr -> pointer_size ) ; return NULL ; } break ; case DW_FORM_block2 : value -> encoding . block . length = READ ( buf , ut16 ) ; if ( value -> encoding . block . length > 0 ) { value -> encoding . block . data = calloc ( sizeof ( ut8 ) , value -> encoding . block . length ) ; for ( j = 0 ; j < value -> encoding . block . length ; j ++ ) { value -> encoding . block . data [ j ] = READ ( buf , ut8 ) ; } } break ; case DW_FORM_block4 : value -> encoding . block . length = READ ( buf , ut32 ) ; if ( value -> encoding . block . length > 0 ) { ut8 * data = calloc ( sizeof ( ut8 ) , value -> encoding . block . length ) ; if ( data ) { for ( j = 0 ; j < value -> encoding . block . length ; j ++ ) { data [ j ] = READ ( buf , ut8 ) ; } } value -> encoding . block . data = data ; } break ; <S2SV_StartBug> case DW_FORM_data2 : <S2SV_EndBug> value -> encoding . data = READ ( buf , ut16 ) ; break ; case DW_FORM_data4 : value -> encoding . data = READ ( buf , ut32 ) ; break ; case DW_FORM_data8 : value -> encoding . data = READ ( buf , ut64 ) ; <S2SV_StartBug> break ; <S2SV_EndBug> case DW_FORM_string : value -> encoding . str_struct . string = * buf ? strdup ( ( const char * ) buf ) : NULL ; buf += ( strlen ( ( const char * ) buf ) + 1 ) ; break ; case DW_FORM_block : buf = r_uleb128 ( buf , buf_end - buf , & value -> encoding . block . length ) ; if ( ! buf ) { return NULL ; } value -> encoding . block . data = calloc ( sizeof ( ut8 ) , value -> encoding . block . length ) ; <S2SV_StartBug> for ( j = 0 ; j < value -> encoding . block . length ; j ++ ) { <S2SV_EndBug> <S2SV_StartBug> value -> encoding . block . data [ j ] = READ ( buf , ut8 ) ; <S2SV_EndBug> } break ; case DW_FORM_block1 : value -> encoding . block . length = READ ( buf , ut8 ) ; value -> encoding . block . data = calloc ( sizeof ( ut8 ) , value -> encoding . block . length + 1 ) ; <S2SV_StartBug> for ( j = 0 ; j < value -> encoding . block . length ; j ++ ) { <S2SV_EndBug> <S2SV_StartBug> value -> encoding . block . data [ j ] = READ ( buf , ut8 ) ; <S2SV_EndBug> } break ; case DW_FORM_flag : value -> encoding . flag = READ ( buf , ut8 ) ; break ; case DW_FORM_sdata : buf = r_leb128 ( buf , & value -> encoding . sdata ) ; break ; case DW_FORM_strp : value -> encoding . str_struct . offset = READ ( buf , ut32 ) ; if ( debug_str && value -> encoding . str_struct . offset < debug_str_len ) { value -> encoding . str_struct . string = strdup ( ( const char * ) ( debug_str + value -> encoding . str_struct . offset ) ) ; } else { value -> encoding . str_struct . string = NULL ; } break ; case DW_FORM_udata : { ut64 ndata = 0 ; const ut8 * data = ( const ut8 * ) & ndata ; buf = r_uleb128 ( buf , R_MIN ( sizeof ( data ) , ( size_t ) ( buf_end - buf ) ) , & ndata ) ; memcpy ( & value -> encoding . data , data , sizeof ( value -> encoding . data ) ) ; value -> encoding . str_struct . string = NULL ; } break ; case DW_FORM_ref_addr : value -> encoding . reference = READ ( buf , ut64 ) ; break ; case DW_FORM_ref1 : value -> encoding . reference = READ ( buf , ut8 ) ; break ; case DW_FORM_ref2 : value -> encoding . reference = READ ( buf , ut16 ) ; break ; case DW_FORM_ref4 : value -> encoding . reference = READ ( buf , ut32 ) ; break ; case DW_FORM_ref8 : value -> encoding . reference = READ ( buf , ut64 ) ; break ; case DW_FORM_data1 : value -> encoding . data = READ ( buf , ut8 ) ; break ; default : eprintf ( "Unknown<S2SV_blank>DW_FORM<S2SV_blank>0x%02" PFMT64x "\\n" , spec -> attr_form ) ; value -> encoding . data = 0 ; return NULL ; } return buf ; }
static int ext4_xattr_block_get ( struct inode * inode , int name_index , const char * name , void * buffer , size_t buffer_size ) { struct buffer_head * bh = NULL ; struct ext4_xattr_entry * entry ; size_t size ; int error ; <S2SV_StartBug> struct mb_cache * ext4_mb_cache = EXT4_GET_MB_CACHE ( inode ) ; <S2SV_EndBug> ea_idebug ( inode , "name=%d.%s,<S2SV_blank>buffer=%p,<S2SV_blank>buffer_size=%ld" , name_index , name , buffer , ( long ) buffer_size ) ; error = - ENODATA ; if ( ! EXT4_I ( inode ) -> i_file_acl ) goto cleanup ; ea_idebug ( inode , "reading<S2SV_blank>block<S2SV_blank>%llu" , ( unsigned long long ) EXT4_I ( inode ) -> i_file_acl ) ; bh = sb_bread ( inode -> i_sb , EXT4_I ( inode ) -> i_file_acl ) ; if ( ! bh ) goto cleanup ; ea_bdebug ( bh , "b_count=%d,<S2SV_blank>refcount=%d" , atomic_read ( & ( bh -> b_count ) ) , le32_to_cpu ( BHDR ( bh ) -> h_refcount ) ) ; if ( ext4_xattr_check_block ( inode , bh ) ) { bad_block : EXT4_ERROR_INODE ( inode , "bad<S2SV_blank>block<S2SV_blank>%llu" , EXT4_I ( inode ) -> i_file_acl ) ; error = - EFSCORRUPTED ; goto cleanup ; } ext4_xattr_cache_insert ( ext4_mb_cache , bh ) ; entry = BFIRST ( bh ) ; error = ext4_xattr_find_entry ( & entry , name_index , name , bh -> b_size , 1 ) ; if ( error == - EFSCORRUPTED ) goto bad_block ; if ( error ) goto cleanup ; size = le32_to_cpu ( entry -> e_value_size ) ; if ( buffer ) { error = - ERANGE ; if ( size > buffer_size ) goto cleanup ; memcpy ( buffer , bh -> b_data + le16_to_cpu ( entry -> e_value_offs ) , size ) ; } error = size ; cleanup : brelse ( bh ) ; return error ; }
void HTML_put_string ( HTStructured * me , const char * s ) <S2SV_StartBug> { <S2SV_EndBug> # ifdef USE_PRETTYSRC char * translated_string = NULL ; # endif if ( s == NULL || ( LYMapsOnly && me -> sp [ 0 ] . tag_number != HTML_OBJECT ) ) return ; # ifdef USE_PRETTYSRC if ( psrc_convert_string ) { StrAllocCopy ( translated_string , s ) ; TRANSLATE_AND_UNESCAPE_ENTITIES ( & translated_string , TRUE , FALSE ) ; s = ( const char * ) translated_string ; } # endif switch ( me -> sp [ 0 ] . tag_number ) { case HTML_COMMENT : break ; case HTML_TITLE : <S2SV_StartBug> HTChunkPuts ( & me -> title , s ) ; <S2SV_EndBug> break ; case HTML_STYLE : <S2SV_StartBug> HTChunkPuts ( & me -> style_block , s ) ; <S2SV_EndBug> break ; case HTML_SCRIPT : <S2SV_StartBug> HTChunkPuts ( & me -> script , s ) ; <S2SV_EndBug> break ; case HTML_PRE : case HTML_LISTING : case HTML_XMP : case HTML_PLAINTEXT : HText_appendText ( me -> text , s ) ; break ; case HTML_OBJECT : <S2SV_StartBug> HTChunkPuts ( & me -> object , s ) ; <S2SV_EndBug> break ; case HTML_TEXTAREA : <S2SV_StartBug> HTChunkPuts ( & me -> textarea , s ) ; <S2SV_EndBug> break ; case HTML_SELECT : case HTML_OPTION : <S2SV_StartBug> HTChunkPuts ( & me -> option , s ) ; <S2SV_EndBug> break ; case HTML_MATH : <S2SV_StartBug> HTChunkPuts ( & me -> math , s ) ; <S2SV_EndBug> break ; default : if ( ! me -> sp -> style -> freeFormat ) { # ifdef USE_PRETTYSRC if ( psrc_view ) { for ( ; * s ; ++ s ) HTML_put_character ( me , * s ) ; } else # endif HText_appendText ( me -> text , s ) ; break ; } else { const char * p = s ; char c ; if ( me -> style_change ) { for ( ; * p && ( ( * p == '\\n' ) || ( * p == '\\r' ) || ( * p == '<S2SV_blank>' ) || ( * p == '\\t' ) ) ; p ++ ) ; if ( ! * p ) break ; UPDATE_STYLE ; } for ( ; * p ; p ++ ) { if ( * p == 13 && p [ 1 ] != 10 ) { c = '\\n' ; } else { c = * p ; } if ( me -> style_change ) { if ( ( c == '\\n' ) || ( c == '<S2SV_blank>' ) || ( c == '\\t' ) ) continue ; UPDATE_STYLE ; } if ( c == '\\n' ) { if ( ! FIX_JAPANESE_SPACES ) { if ( me -> in_word ) { if ( HText_getLastChar ( me -> text ) != '<S2SV_blank>' ) HText_appendCharacter ( me -> text , '<S2SV_blank>' ) ; me -> in_word = NO ; } } } else if ( c == '<S2SV_blank>' || c == '\\t' ) { if ( HText_getLastChar ( me -> text ) != '<S2SV_blank>' ) HText_appendCharacter ( me -> text , '<S2SV_blank>' ) ; } else if ( c == '\\r' ) { } else { HText_appendCharacter ( me -> text , c ) ; me -> in_word = YES ; } if ( c == '\\n' || c == '\\t' ) { HText_setLastChar ( me -> text , '<S2SV_blank>' ) ; } else if ( c == '\\r' && HText_getLastChar ( me -> text ) == '<S2SV_blank>' ) { HText_setLastChar ( me -> text , '<S2SV_blank>' ) ; } else { HText_setLastChar ( me -> text , c ) ; } } } } <S2SV_StartBug> # ifdef USE_PRETTYSRC <S2SV_EndBug> if ( psrc_convert_string ) { psrc_convert_string = FALSE ; FREE ( translated_string ) ; } # endif }
<S2SV_StartBug> static vpx_codec_err_t vp8e_update_entropy ( vpx_codec_alg_priv_t * ctx , <S2SV_EndBug> int ctr_id , va_list args ) { int update = va_arg ( args , int ) ; vp8_update_entropy ( ctx -> cpi , update ) ; return VPX_CODEC_OK ; }
static int sgi_timer_set ( struct k_itimer * timr , int flags , struct itimerspec * new_setting , struct itimerspec * old_setting ) { unsigned long when , period , irqflags ; int err = 0 ; cnodeid_t nodeid ; struct mmtimer * base ; struct rb_node * n ; if ( old_setting ) sgi_timer_get ( timr , old_setting ) ; sgi_timer_del ( timr ) ; <S2SV_StartBug> when = timespec_to_ns ( new_setting -> it_value ) ; <S2SV_EndBug> <S2SV_StartBug> period = timespec_to_ns ( new_setting -> it_interval ) ; <S2SV_EndBug> if ( when == 0 ) return 0 ; base = kmalloc ( sizeof ( struct mmtimer ) , GFP_KERNEL ) ; if ( base == NULL ) return - ENOMEM ; if ( flags & TIMER_ABSTIME ) { struct timespec n ; unsigned long now ; getnstimeofday ( & n ) ; <S2SV_StartBug> now = timespec_to_ns ( n ) ; <S2SV_EndBug> if ( when > now ) when -= now ; else when = 0 ; } when = ( when + sgi_clock_period - 1 ) / sgi_clock_period + rtc_time ( ) ; period = ( period + sgi_clock_period - 1 ) / sgi_clock_period ; preempt_disable ( ) ; nodeid = cpu_to_node ( smp_processor_id ( ) ) ; spin_lock_irqsave ( & timers [ nodeid ] . lock , irqflags ) ; base -> timer = timr ; base -> cpu = smp_processor_id ( ) ; timr -> it . mmtimer . clock = TIMER_SET ; timr -> it . mmtimer . node = nodeid ; timr -> it . mmtimer . incr = period ; timr -> it . mmtimer . expires = when ; n = timers [ nodeid ] . next ; mmtimer_add_list ( base ) ; if ( timers [ nodeid ] . next == n ) { spin_unlock_irqrestore ( & timers [ nodeid ] . lock , irqflags ) ; preempt_enable ( ) ; return err ; } if ( n ) mmtimer_disable_int ( cnodeid_to_nasid ( nodeid ) , COMPARATOR ) ; mmtimer_set_next_timer ( nodeid ) ; spin_unlock_irqrestore ( & timers [ nodeid ] . lock , irqflags ) ; preempt_enable ( ) ; return err ; }
static int follow_dotdot_rcu ( struct nameidata * nd ) { struct inode * inode = nd -> inode ; if ( ! nd -> root . mnt ) set_root_rcu ( nd ) ; while ( 1 ) { if ( path_equal ( & nd -> path , & nd -> root ) ) break ; if ( nd -> path . dentry != nd -> path . mnt -> mnt_root ) { struct dentry * old = nd -> path . dentry ; struct dentry * parent = old -> d_parent ; unsigned seq ; inode = parent -> d_inode ; seq = read_seqcount_begin ( & parent -> d_seq ) ; if ( unlikely ( read_seqcount_retry ( & old -> d_seq , nd -> seq ) ) ) return - ECHILD ; nd -> path . dentry = parent ; nd -> seq = seq ; <S2SV_StartBug> break ; <S2SV_EndBug> } else { struct mount * mnt = real_mount ( nd -> path . mnt ) ; struct mount * mparent = mnt -> mnt_parent ; struct dentry * mountpoint = mnt -> mnt_mountpoint ; struct inode * inode2 = mountpoint -> d_inode ; unsigned seq = read_seqcount_begin ( & mountpoint -> d_seq ) ; if ( unlikely ( read_seqretry ( & mount_lock , nd -> m_seq ) ) ) return - ECHILD ; if ( & mparent -> mnt == nd -> path . mnt ) break ; nd -> path . dentry = mountpoint ; nd -> path . mnt = & mparent -> mnt ; inode = inode2 ; nd -> seq = seq ; } } while ( unlikely ( d_mountpoint ( nd -> path . dentry ) ) ) { struct mount * mounted ; mounted = __lookup_mnt ( nd -> path . mnt , nd -> path . dentry ) ; if ( unlikely ( read_seqretry ( & mount_lock , nd -> m_seq ) ) ) return - ECHILD ; if ( ! mounted ) break ; nd -> path . mnt = & mounted -> mnt ; nd -> path . dentry = mounted -> mnt . mnt_root ; inode = nd -> path . dentry -> d_inode ; nd -> seq = read_seqcount_begin ( & nd -> path . dentry -> d_seq ) ; } nd -> inode = inode ; return 0 ; }
SQLRETURN SQLSetDescField ( SQLHDESC descriptor_handle , SQLSMALLINT rec_number , SQLSMALLINT field_identifier , SQLPOINTER value , SQLINTEGER buffer_length ) { DMHDESC descriptor = ( DMHDESC ) descriptor_handle ; SQLRETURN ret ; SQLCHAR s1 [ 100 + LOG_MESSAGE_LEN ] ; int isStrField = 0 ; if ( ! __validate_desc ( descriptor ) ) { dm_log_write ( __FILE__ , __LINE__ , LOG_INFO , LOG_INFO , "Error:<S2SV_blank>SQL_INVALID_HANDLE" ) ; return SQL_INVALID_HANDLE ; } function_entry ( descriptor ) ; if ( log_info . log_flag ) { <S2SV_StartBug> sprintf ( descriptor -> msg , "\\n\\t\\tEntry:\\\n<S2SV_blank>\\n\\t\\t\\tDescriptor<S2SV_blank>=<S2SV_blank>%p\\\n<S2SV_blank>\\n\\t\\t\\tRec<S2SV_blank>Number<S2SV_blank>=<S2SV_blank>%d\\\n<S2SV_blank>\\n\\t\\t\\tField<S2SV_blank>Ident<S2SV_blank>=<S2SV_blank>%s\\\n<S2SV_blank>\\n\\t\\t\\tValue<S2SV_blank>=<S2SV_blank>%p\\\n<S2SV_blank>\\n\\t\\t\\tBuffer<S2SV_blank>Length<S2SV_blank>=<S2SV_blank>%d" , <S2SV_EndBug> descriptor , rec_number , __desc_attr_as_string ( s1 , field_identifier ) , value , ( int ) buffer_length ) ; dm_log_write ( __FILE__ , __LINE__ , LOG_INFO , LOG_INFO , descriptor -> msg ) ; } thread_protect ( SQL_HANDLE_DESC , descriptor ) ; if ( descriptor -> connection -> state < STATE_C4 ) { dm_log_write ( __FILE__ , __LINE__ , LOG_INFO , LOG_INFO , "Error:<S2SV_blank>HY010" ) ; __post_internal_error ( & descriptor -> error , ERROR_HY010 , NULL , descriptor -> connection -> environment -> requested_version ) ; return function_return_nodrv ( SQL_HANDLE_DESC , descriptor , SQL_ERROR ) ; } if ( __check_stmt_from_desc ( descriptor , STATE_S8 ) || __check_stmt_from_desc ( descriptor , STATE_S9 ) || __check_stmt_from_desc ( descriptor , STATE_S10 ) || __check_stmt_from_desc ( descriptor , STATE_S11 ) || __check_stmt_from_desc ( descriptor , STATE_S12 ) || __check_stmt_from_desc ( descriptor , STATE_S13 ) || __check_stmt_from_desc ( descriptor , STATE_S14 ) || __check_stmt_from_desc ( descriptor , STATE_S15 ) ) { dm_log_write ( __FILE__ , __LINE__ , LOG_INFO , LOG_INFO , "Error:<S2SV_blank>HY010" ) ; __post_internal_error ( & descriptor -> error , ERROR_HY010 , NULL , descriptor -> connection -> environment -> requested_version ) ; return function_return_nodrv ( SQL_HANDLE_DESC , descriptor , SQL_ERROR ) ; } if ( rec_number < 0 ) { __post_internal_error ( & descriptor -> error , ERROR_07009 , NULL , descriptor -> connection -> environment -> requested_version ) ; return function_return_nodrv ( SQL_HANDLE_DESC , descriptor , SQL_ERROR ) ; } switch ( field_identifier ) { case SQL_DESC_ALLOC_TYPE : case SQL_DESC_ARRAY_SIZE : case SQL_DESC_ARRAY_STATUS_PTR : case SQL_DESC_BIND_OFFSET_PTR : case SQL_DESC_BIND_TYPE : case SQL_DESC_COUNT : case SQL_DESC_ROWS_PROCESSED_PTR : case SQL_DESC_AUTO_UNIQUE_VALUE : case SQL_DESC_CASE_SENSITIVE : case SQL_DESC_CONCISE_TYPE : case SQL_DESC_DATA_PTR : case SQL_DESC_DATETIME_INTERVAL_CODE : case SQL_DESC_DATETIME_INTERVAL_PRECISION : case SQL_DESC_DISPLAY_SIZE : case SQL_DESC_FIXED_PREC_SCALE : case SQL_DESC_INDICATOR_PTR : case SQL_DESC_LENGTH : case SQL_DESC_NULLABLE : case SQL_DESC_NUM_PREC_RADIX : case SQL_DESC_OCTET_LENGTH : case SQL_DESC_OCTET_LENGTH_PTR : case SQL_DESC_PARAMETER_TYPE : case SQL_DESC_PRECISION : case SQL_DESC_ROWVER : case SQL_DESC_SCALE : case SQL_DESC_SEARCHABLE : case SQL_DESC_TYPE : case SQL_DESC_UNNAMED : case SQL_DESC_UNSIGNED : case SQL_DESC_UPDATABLE : isStrField = 0 ; break ; case SQL_DESC_BASE_COLUMN_NAME : case SQL_DESC_BASE_TABLE_NAME : case SQL_DESC_CATALOG_NAME : case SQL_DESC_LABEL : case SQL_DESC_LITERAL_PREFIX : case SQL_DESC_LITERAL_SUFFIX : case SQL_DESC_LOCAL_TYPE_NAME : case SQL_DESC_NAME : case SQL_DESC_SCHEMA_NAME : case SQL_DESC_TABLE_NAME : case SQL_DESC_TYPE_NAME : isStrField = 1 ; break ; default : isStrField = buffer_length != SQL_IS_POINTER && buffer_length != SQL_IS_INTEGER && buffer_length != SQL_IS_UINTEGER && buffer_length != SQL_IS_SMALLINT && buffer_length != SQL_IS_USMALLINT ; } if ( isStrField && buffer_length < 0 && buffer_length != SQL_NTS ) { __post_internal_error ( & descriptor -> error , ERROR_HY090 , NULL , descriptor -> connection -> environment -> requested_version ) ; return function_return_nodrv ( SQL_HANDLE_DESC , descriptor , SQL_ERROR ) ; } <S2SV_StartBug> if ( field_identifier == SQL_DESC_COUNT && ( SQLINTEGER ) value < 0 ) <S2SV_EndBug> { __post_internal_error ( & descriptor -> error , ERROR_07009 , NULL , descriptor -> connection -> environment -> requested_version ) ; return function_return_nodrv ( SQL_HANDLE_DESC , descriptor , SQL_ERROR ) ; } <S2SV_StartBug> if ( field_identifier == SQL_DESC_PARAMETER_TYPE && value != SQL_PARAM_INPUT <S2SV_EndBug> <S2SV_StartBug> && value != SQL_PARAM_OUTPUT && value != SQL_PARAM_INPUT_OUTPUT && <S2SV_EndBug> <S2SV_StartBug> value != SQL_PARAM_INPUT_OUTPUT_STREAM && value != SQL_PARAM_OUTPUT_STREAM ) <S2SV_EndBug> { __post_internal_error ( & descriptor -> error , ERROR_HY105 , NULL , descriptor -> connection -> environment -> requested_version ) ; return function_return_nodrv ( SQL_HANDLE_DESC , descriptor , SQL_ERROR ) ; } if ( CHECK_SQLSETDESCFIELD ( descriptor -> connection ) ) { ret = SQLSETDESCFIELD ( descriptor -> connection , descriptor -> driver_desc , rec_number , field_identifier , value , buffer_length ) ; } else if ( CHECK_SQLSETDESCFIELDW ( descriptor -> connection ) ) { SQLWCHAR * s1 = NULL ; if ( isStrField ) { s1 = ansi_to_unicode_alloc ( value , buffer_length , descriptor -> connection , NULL ) ; if ( SQL_NTS != buffer_length ) { buffer_length *= sizeof ( SQLWCHAR ) ; } } else { s1 = value ; } ret = SQLSETDESCFIELDW ( descriptor -> connection , descriptor -> driver_desc , rec_number , field_identifier , s1 , buffer_length ) ; if ( isStrField ) { if ( s1 ) free ( s1 ) ; } } else { dm_log_write ( __FILE__ , __LINE__ , LOG_INFO , LOG_INFO , "Error:<S2SV_blank>IM001" ) ; __post_internal_error ( & descriptor -> error , ERROR_IM001 , NULL , descriptor -> connection -> environment -> requested_version ) ; return function_return_nodrv ( SQL_HANDLE_DESC , descriptor , SQL_ERROR ) ; } if ( log_info . log_flag ) { sprintf ( descriptor -> msg , "\\n\\t\\tExit:[%s]" , __get_return_status ( ret , s1 ) ) ; dm_log_write ( __FILE__ , __LINE__ , LOG_INFO , LOG_INFO , descriptor -> msg ) ; } return function_return ( SQL_HANDLE_DESC , descriptor , ret ) ; }
int ext4_ext_insert_extent ( handle_t * handle , struct inode * inode , struct ext4_ext_path * path , struct ext4_extent * newext , int flag ) { struct ext4_extent_header * eh ; struct ext4_extent * ex , * fex ; struct ext4_extent * nearex ; struct ext4_ext_path * npath = NULL ; int depth , len , err ; ext4_lblk_t next ; unsigned uninitialized = 0 ; BUG_ON ( ext4_ext_get_actual_len ( newext ) == 0 ) ; depth = ext_depth ( inode ) ; ex = path [ depth ] . p_ext ; BUG_ON ( path [ depth ] . p_hdr == NULL ) ; <S2SV_StartBug> if ( ex && ( flag != EXT4_GET_BLOCKS_PRE_IO ) <S2SV_EndBug> && ext4_can_extents_be_merged ( inode , ex , newext ) ) { ext_debug ( "append<S2SV_blank>[%d]%d<S2SV_blank>block<S2SV_blank>to<S2SV_blank>%d:[%d]%d<S2SV_blank>(from<S2SV_blank>%llu)\\n" , ext4_ext_is_uninitialized ( newext ) , ext4_ext_get_actual_len ( newext ) , le32_to_cpu ( ex -> ee_block ) , ext4_ext_is_uninitialized ( ex ) , ext4_ext_get_actual_len ( ex ) , ext_pblock ( ex ) ) ; err = ext4_ext_get_access ( handle , inode , path + depth ) ; if ( err ) return err ; if ( ext4_ext_is_uninitialized ( ex ) ) uninitialized = 1 ; ex -> ee_len = cpu_to_le16 ( ext4_ext_get_actual_len ( ex ) + ext4_ext_get_actual_len ( newext ) ) ; if ( uninitialized ) ext4_ext_mark_uninitialized ( ex ) ; eh = path [ depth ] . p_hdr ; nearex = ex ; goto merge ; } repeat : depth = ext_depth ( inode ) ; eh = path [ depth ] . p_hdr ; if ( le16_to_cpu ( eh -> eh_entries ) < le16_to_cpu ( eh -> eh_max ) ) goto has_space ; fex = EXT_LAST_EXTENT ( eh ) ; next = ext4_ext_next_leaf_block ( inode , path ) ; if ( le32_to_cpu ( newext -> ee_block ) > le32_to_cpu ( fex -> ee_block ) && next != EXT_MAX_BLOCK ) { ext_debug ( "next<S2SV_blank>leaf<S2SV_blank>block<S2SV_blank>-<S2SV_blank>%d\\n" , next ) ; BUG_ON ( npath != NULL ) ; npath = ext4_ext_find_extent ( inode , next , NULL ) ; if ( IS_ERR ( npath ) ) return PTR_ERR ( npath ) ; BUG_ON ( npath -> p_depth != path -> p_depth ) ; eh = npath [ depth ] . p_hdr ; if ( le16_to_cpu ( eh -> eh_entries ) < le16_to_cpu ( eh -> eh_max ) ) { ext_debug ( "next<S2SV_blank>leaf<S2SV_blank>isnt<S2SV_blank>full(%d)\\n" , le16_to_cpu ( eh -> eh_entries ) ) ; path = npath ; goto repeat ; } ext_debug ( "next<S2SV_blank>leaf<S2SV_blank>has<S2SV_blank>no<S2SV_blank>free<S2SV_blank>space(%d,%d)\\n" , le16_to_cpu ( eh -> eh_entries ) , le16_to_cpu ( eh -> eh_max ) ) ; } err = ext4_ext_create_new_leaf ( handle , inode , path , newext ) ; if ( err ) goto cleanup ; depth = ext_depth ( inode ) ; eh = path [ depth ] . p_hdr ; has_space : nearex = path [ depth ] . p_ext ; err = ext4_ext_get_access ( handle , inode , path + depth ) ; if ( err ) goto cleanup ; if ( ! nearex ) { ext_debug ( "first<S2SV_blank>extent<S2SV_blank>in<S2SV_blank>the<S2SV_blank>leaf:<S2SV_blank>%d:%llu:[%d]%d\\n" , le32_to_cpu ( newext -> ee_block ) , ext_pblock ( newext ) , ext4_ext_is_uninitialized ( newext ) , ext4_ext_get_actual_len ( newext ) ) ; path [ depth ] . p_ext = EXT_FIRST_EXTENT ( eh ) ; } else if ( le32_to_cpu ( newext -> ee_block ) > le32_to_cpu ( nearex -> ee_block ) ) { if ( nearex != EXT_LAST_EXTENT ( eh ) ) { len = EXT_MAX_EXTENT ( eh ) - nearex ; len = ( len - 1 ) * sizeof ( struct ext4_extent ) ; len = len < 0 ? 0 : len ; ext_debug ( "insert<S2SV_blank>%d:%llu:[%d]%d<S2SV_blank>after:<S2SV_blank>nearest<S2SV_blank>0x%p,<S2SV_blank>" "move<S2SV_blank>%d<S2SV_blank>from<S2SV_blank>0x%p<S2SV_blank>to<S2SV_blank>0x%p\\n" , le32_to_cpu ( newext -> ee_block ) , ext_pblock ( newext ) , ext4_ext_is_uninitialized ( newext ) , ext4_ext_get_actual_len ( newext ) , nearex , len , nearex + 1 , nearex + 2 ) ; memmove ( nearex + 2 , nearex + 1 , len ) ; } path [ depth ] . p_ext = nearex + 1 ; } else { BUG_ON ( newext -> ee_block == nearex -> ee_block ) ; len = ( EXT_MAX_EXTENT ( eh ) - nearex ) * sizeof ( struct ext4_extent ) ; len = len < 0 ? 0 : len ; ext_debug ( "insert<S2SV_blank>%d:%llu:[%d]%d<S2SV_blank>before:<S2SV_blank>nearest<S2SV_blank>0x%p,<S2SV_blank>" "move<S2SV_blank>%d<S2SV_blank>from<S2SV_blank>0x%p<S2SV_blank>to<S2SV_blank>0x%p\\n" , le32_to_cpu ( newext -> ee_block ) , ext_pblock ( newext ) , ext4_ext_is_uninitialized ( newext ) , ext4_ext_get_actual_len ( newext ) , nearex , len , nearex + 1 , nearex + 2 ) ; memmove ( nearex + 1 , nearex , len ) ; path [ depth ] . p_ext = nearex ; } le16_add_cpu ( & eh -> eh_entries , 1 ) ; nearex = path [ depth ] . p_ext ; nearex -> ee_block = newext -> ee_block ; ext4_ext_store_pblock ( nearex , ext_pblock ( newext ) ) ; nearex -> ee_len = newext -> ee_len ; merge : <S2SV_StartBug> if ( flag != EXT4_GET_BLOCKS_PRE_IO ) <S2SV_EndBug> ext4_ext_try_to_merge ( inode , path , nearex ) ; err = ext4_ext_correct_indexes ( handle , inode , path ) ; if ( err ) goto cleanup ; err = ext4_ext_dirty ( handle , inode , path + depth ) ; cleanup : if ( npath ) { ext4_ext_drop_refs ( npath ) ; kfree ( npath ) ; } ext4_ext_invalidate_cache ( inode ) ; return err ; }
static int <S2SV_StartBug> mptctl_replace_fw ( unsigned long arg ) <S2SV_EndBug> { struct mpt_ioctl_replace_fw __user * uarg = ( void __user * ) arg ; struct mpt_ioctl_replace_fw karg ; <S2SV_StartBug> MPT_ADAPTER * ioc ; <S2SV_EndBug> int iocnum ; int newFwSize ; if ( copy_from_user ( & karg , uarg , sizeof ( struct mpt_ioctl_replace_fw ) ) ) { printk ( KERN_ERR MYNAM "%s@%d::mptctl_replace_fw<S2SV_blank>-<S2SV_blank>" "Unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>in<S2SV_blank>mpt_ioctl_replace_fw<S2SV_blank>struct<S2SV_blank>@<S2SV_blank>%p\\n" , __FILE__ , __LINE__ , uarg ) ; <S2SV_StartBug> return - EFAULT ; <S2SV_EndBug> } if ( ( ( iocnum = mpt_verify_adapter ( karg . hdr . iocnum , & ioc ) ) < 0 ) || ( ioc == NULL ) ) { printk ( KERN_DEBUG MYNAM "%s::mptctl_replace_fw()<S2SV_blank>@%d<S2SV_blank>-<S2SV_blank>ioc%d<S2SV_blank>not<S2SV_blank>found!\\n" , __FILE__ , __LINE__ , iocnum ) ; return - ENODEV ; } dctlprintk ( ioc , printk ( MYIOC_s_DEBUG_FMT "mptctl_replace_fw<S2SV_blank>called.\\n" , ioc -> name ) ) ; if ( ioc -> cached_fw == NULL ) return 0 ; mpt_free_fw_memory ( ioc ) ; newFwSize = ALIGN ( karg . newImageSize , 4 ) ; mpt_alloc_fw_memory ( ioc , newFwSize ) ; if ( ioc -> cached_fw == NULL ) return - ENOMEM ; if ( copy_from_user ( ioc -> cached_fw , uarg -> newImage , newFwSize ) ) { printk ( MYIOC_s_ERR_FMT "%s@%d::mptctl_replace_fw<S2SV_blank>-<S2SV_blank>" "Unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>in<S2SV_blank>mpt_ioctl_replace_fw<S2SV_blank>image<S2SV_blank>" "@<S2SV_blank>%p\\n" , ioc -> name , __FILE__ , __LINE__ , uarg ) ; mpt_free_fw_memory ( ioc ) ; return - EFAULT ; } ioc -> facts . FWImageSize = newFwSize ; return 0 ; }
static void btif_fetch_local_bdaddr ( bt_bdaddr_t * local_addr ) { char val [ PROPERTY_VALUE_MAX ] = { 0 } ; uint8_t valid_bda = FALSE ; int val_size = 0 ; const uint8_t null_bdaddr [ BD_ADDR_LEN ] = { 0 , 0 , 0 , 0 , 0 , 0 } ; if ( property_get ( PROPERTY_BT_BDADDR_PATH , val , NULL ) ) { int addr_fd ; BTIF_TRACE_DEBUG ( "%s,<S2SV_blank>local<S2SV_blank>bdaddr<S2SV_blank>is<S2SV_blank>stored<S2SV_blank>in<S2SV_blank>%s" , __func__ , val ) ; <S2SV_StartBug> if ( ( addr_fd = open ( val , O_RDONLY ) ) != - 1 ) <S2SV_EndBug> { memset ( val , 0 , sizeof ( val ) ) ; <S2SV_StartBug> read ( addr_fd , val , FACTORY_BT_BDADDR_STORAGE_LEN ) ; <S2SV_EndBug> if ( ( string_to_bdaddr ( val , local_addr ) ) && ( memcmp ( local_addr -> address , null_bdaddr , BD_ADDR_LEN ) != 0 ) ) { valid_bda = TRUE ; BTIF_TRACE_DEBUG ( "%s:<S2SV_blank>Got<S2SV_blank>Factory<S2SV_blank>BDA<S2SV_blank>%s" , __func__ , val ) ; } close ( addr_fd ) ; } } if ( ! valid_bda ) { val_size = sizeof ( val ) ; if ( btif_config_get_str ( "Adapter" , "Address" , val , & val_size ) ) { string_to_bdaddr ( val , local_addr ) ; BTIF_TRACE_DEBUG ( "local<S2SV_blank>bdaddr<S2SV_blank>from<S2SV_blank>bt_config.xml<S2SV_blank>is<S2SV_blank><S2SV_blank>%s" , val ) ; return ; } } if ( ! valid_bda ) { valid_bda = btif_fetch_property ( PERSIST_BDADDR_PROPERTY , local_addr ) ; } if ( ! valid_bda ) { valid_bda = btif_fetch_property ( FACTORY_BT_ADDR_PROPERTY , local_addr ) ; } if ( ! valid_bda ) { bdstr_t bdstr ; srand ( ( unsigned int ) ( time ( 0 ) ) ) ; local_addr -> address [ 0 ] = 0x22 ; local_addr -> address [ 1 ] = 0x22 ; local_addr -> address [ 2 ] = ( uint8_t ) ( ( rand ( ) >> 8 ) & 0xFF ) ; local_addr -> address [ 3 ] = ( uint8_t ) ( ( rand ( ) >> 8 ) & 0xFF ) ; local_addr -> address [ 4 ] = ( uint8_t ) ( ( rand ( ) >> 8 ) & 0xFF ) ; local_addr -> address [ 5 ] = ( uint8_t ) ( ( rand ( ) >> 8 ) & 0xFF ) ; bdaddr_to_string ( local_addr , bdstr , sizeof ( bdstr ) ) ; BTIF_TRACE_DEBUG ( "No<S2SV_blank>preset<S2SV_blank>BDA.<S2SV_blank>Generating<S2SV_blank>BDA:<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>prop<S2SV_blank>%s" , ( char * ) bdstr , PERSIST_BDADDR_PROPERTY ) ; if ( property_set ( PERSIST_BDADDR_PROPERTY , ( char * ) bdstr ) < 0 ) BTIF_TRACE_ERROR ( "Failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>random<S2SV_blank>BDA<S2SV_blank>in<S2SV_blank>prop<S2SV_blank>%s" , PERSIST_BDADDR_PROPERTY ) ; } bdstr_t bdstr ; bdaddr_to_string ( local_addr , bdstr , sizeof ( bdstr ) ) ; val_size = sizeof ( val ) ; if ( btif_config_get_str ( "Adapter" , "Address" , val , & val_size ) ) { if ( strcmp ( bdstr , val ) == 0 ) { return ; } } btif_config_set_str ( "Adapter" , "Address" , bdstr ) ; }
static int parseOperand ( RAsm * a , const char * str , Operand * op , bool isrepop ) { size_t pos , nextpos = 0 ; x86newTokenType last_type ; int size_token = 1 ; bool explicit_size = false ; int reg_index = 0 ; op -> type = 0 ; while ( size_token ) { pos = nextpos ; last_type = getToken ( str , & pos , & nextpos ) ; if ( ! r_str_ncasecmp ( str + pos , "ptr" , 3 ) ) { continue ; } else if ( ! r_str_ncasecmp ( str + pos , "byte" , 4 ) ) { op -> type |= OT_MEMORY | OT_BYTE ; op -> dest_size = OT_BYTE ; explicit_size = true ; } else if ( ! r_str_ncasecmp ( str + pos , "word" , 4 ) ) { op -> type |= OT_MEMORY | OT_WORD ; op -> dest_size = OT_WORD ; explicit_size = true ; } else if ( ! r_str_ncasecmp ( str + pos , "dword" , 5 ) ) { op -> type |= OT_MEMORY | OT_DWORD ; op -> dest_size = OT_DWORD ; explicit_size = true ; } else if ( ! r_str_ncasecmp ( str + pos , "qword" , 5 ) ) { op -> type |= OT_MEMORY | OT_QWORD ; op -> dest_size = OT_QWORD ; explicit_size = true ; } else if ( ! r_str_ncasecmp ( str + pos , "oword" , 5 ) ) { op -> type |= OT_MEMORY | OT_OWORD ; op -> dest_size = OT_OWORD ; explicit_size = true ; } else if ( ! r_str_ncasecmp ( str + pos , "tbyte" , 5 ) ) { op -> type |= OT_MEMORY | OT_TBYTE ; op -> dest_size = OT_TBYTE ; explicit_size = true ; } else { size_token = 0 ; } } if ( str [ pos ] == '[' ) { if ( ! op -> type ) { op -> type = OT_MEMORY ; } op -> offset = op -> scale [ 0 ] = op -> scale [ 1 ] = 0 ; ut64 temp = 1 ; Register reg = X86R_UNDEFINED ; bool first_reg = true ; while ( str [ pos ] != ']' ) { if ( pos > nextpos ) { break ; } pos = nextpos ; if ( ! str [ pos ] ) { break ; } last_type = getToken ( str , & pos , & nextpos ) ; if ( last_type == TT_SPECIAL ) { if ( str [ pos ] == '+' || str [ pos ] == '-' || str [ pos ] == ']' ) { if ( reg != X86R_UNDEFINED ) { <S2SV_StartBug> op -> regs [ reg_index ] = reg ; <S2SV_EndBug> op -> scale [ reg_index ] = temp ; <S2SV_StartBug> ++ reg_index ; <S2SV_EndBug> } else { <S2SV_StartBug> op -> offset += temp ; <S2SV_EndBug> <S2SV_StartBug> op -> regs [ reg_index ] = X86R_UNDEFINED ; <S2SV_EndBug> } temp = 1 ; reg = X86R_UNDEFINED ; } else if ( str [ pos ] == '*' ) { } } else if ( last_type == TT_WORD ) { ut32 reg_type = 0 ; if ( reg != X86R_UNDEFINED ) { op -> type = 0 ; } nextpos = pos ; reg = parseReg ( a , str , & nextpos , & reg_type ) ; if ( first_reg ) { op -> extended = false ; if ( reg > 8 ) { op -> extended = true ; op -> reg = reg - 9 ; } first_reg = false ; } else if ( reg > 8 ) { op -> reg = reg - 9 ; } if ( reg_type & OT_REGTYPE & OT_SEGMENTREG ) { op -> reg = reg ; op -> type = reg_type ; parse_segment_offset ( a , str , & nextpos , op , reg_index ) ; return nextpos ; } if ( ! explicit_size ) { op -> type |= reg_type ; } op -> reg_size = reg_type ; op -> explicit_size = explicit_size ; if ( ! ( reg_type & OT_GPREG ) ) { op -> type = 0 ; } } else { char * p = strchr ( str , '+' ) ; op -> offset_sign = 1 ; if ( ! p ) { p = strchr ( str , '-' ) ; if ( p ) { op -> offset_sign = - 1 ; } } char * plus = strchr ( str , '+' ) ; char * minus = strchr ( str , '-' ) ; char * closeB = strchr ( str , ']' ) ; if ( plus && minus && plus < closeB && minus < closeB ) { op -> offset_sign = - 1 ; } char * tmp ; tmp = malloc ( strlen ( str + pos ) + 1 ) ; strcpy ( tmp , str + pos ) ; strtok ( tmp , "+-" ) ; st64 read = getnum ( a , tmp ) ; free ( tmp ) ; temp *= read ; } } } else if ( last_type == TT_WORD ) { nextpos = pos ; RFlagItem * flag ; if ( isrepop ) { op -> is_good_flag = false ; strncpy ( op -> rep_op , str , MAX_REPOP_LENGTH - 1 ) ; op -> rep_op [ MAX_REPOP_LENGTH - 1 ] = '\\0' ; return nextpos ; } op -> reg = parseReg ( a , str , & nextpos , & op -> type ) ; op -> extended = false ; if ( op -> reg > 8 ) { op -> extended = true ; op -> reg -= 9 ; } if ( op -> type & OT_REGTYPE & OT_SEGMENTREG ) { parse_segment_offset ( a , str , & nextpos , op , reg_index ) ; return nextpos ; } if ( op -> reg == X86R_UNDEFINED ) { op -> is_good_flag = false ; if ( a -> num && a -> num -> value == 0 ) { return nextpos ; } op -> type = OT_CONSTANT ; RCore * core = a -> num ? ( RCore * ) ( a -> num -> userptr ) : NULL ; if ( core && ( flag = r_flag_get ( core -> flags , str ) ) ) { op -> is_good_flag = true ; } char * p = strchr ( str , '-' ) ; if ( p ) { op -> sign = - 1 ; str = ++ p ; } op -> immediate = getnum ( a , str ) ; } else if ( op -> reg < X86R_UNDEFINED ) { strncpy ( op -> rep_op , str , MAX_REPOP_LENGTH - 1 ) ; op -> rep_op [ MAX_REPOP_LENGTH - 1 ] = '\\0' ; } } else { op -> type = OT_CONSTANT ; op -> sign = 1 ; char * p = strchr ( str , '-' ) ; if ( p ) { op -> sign = - 1 ; str = ++ p ; } op -> immediate = getnum ( a , str ) ; } return nextpos ; }
PyObject * ast2obj_stmt ( void * _o ) { stmt_ty o = ( stmt_ty ) _o ; PyObject * result = NULL , * value = NULL ; if ( ! o ) { Py_RETURN_NONE ; } switch ( o -> kind ) { case FunctionDef_kind : result = PyType_GenericNew ( FunctionDef_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_identifier ( o -> v . FunctionDef . name ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_name , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_arguments ( o -> v . FunctionDef . args ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_args , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . FunctionDef . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . FunctionDef . decorator_list , ast2obj_expr ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_decorator_list , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> v . FunctionDef . returns ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_returns , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; <S2SV_StartBug> break ; <S2SV_EndBug> case AsyncFunctionDef_kind : result = PyType_GenericNew ( AsyncFunctionDef_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_identifier ( o -> v . AsyncFunctionDef . name ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_name , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_arguments ( o -> v . AsyncFunctionDef . args ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_args , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . AsyncFunctionDef . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . AsyncFunctionDef . decorator_list , ast2obj_expr ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_decorator_list , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> v . AsyncFunctionDef . returns ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_returns , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; <S2SV_StartBug> break ; <S2SV_EndBug> case ClassDef_kind : result = PyType_GenericNew ( ClassDef_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_identifier ( o -> v . ClassDef . name ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_name , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . ClassDef . bases , ast2obj_expr ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_bases , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . ClassDef . keywords , ast2obj_keyword ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_keywords , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . ClassDef . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . ClassDef . decorator_list , ast2obj_expr ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_decorator_list , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Return_kind : result = PyType_GenericNew ( Return_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . Return . value ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_value , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Delete_kind : result = PyType_GenericNew ( Delete_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . Delete . targets , ast2obj_expr ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_targets , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Assign_kind : result = PyType_GenericNew ( Assign_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . Assign . targets , ast2obj_expr ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_targets , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> v . Assign . value ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_value , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; <S2SV_StartBug> break ; <S2SV_EndBug> case AugAssign_kind : result = PyType_GenericNew ( AugAssign_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . AugAssign . target ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_target , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_operator ( o -> v . AugAssign . op ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_op , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> v . AugAssign . value ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_value , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case AnnAssign_kind : result = PyType_GenericNew ( AnnAssign_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . AnnAssign . target ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_target , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> v . AnnAssign . annotation ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_annotation , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> v . AnnAssign . value ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_value , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_int ( o -> v . AnnAssign . simple ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_simple , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case For_kind : result = PyType_GenericNew ( For_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . For . target ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_target , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> v . For . iter ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_iter , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . For . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . For . orelse , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_orelse , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; <S2SV_StartBug> break ; <S2SV_EndBug> case AsyncFor_kind : result = PyType_GenericNew ( AsyncFor_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . AsyncFor . target ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_target , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> v . AsyncFor . iter ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_iter , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . AsyncFor . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . AsyncFor . orelse , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_orelse , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; <S2SV_StartBug> break ; <S2SV_EndBug> case While_kind : result = PyType_GenericNew ( While_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . While . test ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_test , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . While . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . While . orelse , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_orelse , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case If_kind : result = PyType_GenericNew ( If_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . If . test ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_test , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . If . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . If . orelse , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_orelse , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case With_kind : result = PyType_GenericNew ( With_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . With . items , ast2obj_withitem ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_items , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . With . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; <S2SV_StartBug> break ; <S2SV_EndBug> case AsyncWith_kind : result = PyType_GenericNew ( AsyncWith_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . AsyncWith . items , ast2obj_withitem ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_items , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . AsyncWith . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; <S2SV_StartBug> break ; <S2SV_EndBug> case Raise_kind : result = PyType_GenericNew ( Raise_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . Raise . exc ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_exc , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> v . Raise . cause ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_cause , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Try_kind : result = PyType_GenericNew ( Try_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . Try . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . Try . handlers , ast2obj_excepthandler ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_handlers , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . Try . orelse , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_orelse , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . Try . finalbody , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_finalbody , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Assert_kind : result = PyType_GenericNew ( Assert_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . Assert . test ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_test , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> v . Assert . msg ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_msg , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Import_kind : result = PyType_GenericNew ( Import_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . Import . names , ast2obj_alias ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_names , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case ImportFrom_kind : result = PyType_GenericNew ( ImportFrom_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_identifier ( o -> v . ImportFrom . module ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_module , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . ImportFrom . names , ast2obj_alias ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_names , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_int ( o -> v . ImportFrom . level ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_level , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Global_kind : result = PyType_GenericNew ( Global_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . Global . names , ast2obj_identifier ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_names , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Nonlocal_kind : result = PyType_GenericNew ( Nonlocal_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . Nonlocal . names , ast2obj_identifier ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_names , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Expr_kind : result = PyType_GenericNew ( Expr_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . Expr . value ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_value , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Pass_kind : result = PyType_GenericNew ( Pass_type , NULL , NULL ) ; if ( ! result ) goto failed ; break ; case Break_kind : result = PyType_GenericNew ( Break_type , NULL , NULL ) ; if ( ! result ) goto failed ; break ; case Continue_kind : result = PyType_GenericNew ( Continue_type , NULL , NULL ) ; if ( ! result ) goto failed ; break ; } value = ast2obj_int ( o -> lineno ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_lineno , value ) < 0 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_int ( o -> col_offset ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_col_offset , value ) < 0 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_int ( o -> end_lineno ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_end_lineno , value ) < 0 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_int ( o -> end_col_offset ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_end_col_offset , value ) < 0 ) goto failed ; Py_DECREF ( value ) ; return result ; failed : Py_XDECREF ( value ) ; Py_XDECREF ( result ) ; return NULL ; }
OM_uint32 kg_seal_iov ( OM_uint32 * minor_status , gss_ctx_id_t context_handle , int conf_req_flag , gss_qop_t qop_req , int * conf_state , gss_iov_buffer_desc * iov , int iov_count , int toktype ) { krb5_gss_ctx_id_rec * ctx ; krb5_error_code code ; krb5_context context ; if ( qop_req != 0 ) { * minor_status = ( OM_uint32 ) G_UNKNOWN_QOP ; return GSS_S_FAILURE ; } ctx = ( krb5_gss_ctx_id_rec * ) context_handle ; <S2SV_StartBug> if ( ! ctx -> established ) { <S2SV_EndBug> * minor_status = KG_CTX_INCOMPLETE ; return GSS_S_NO_CONTEXT ; } if ( conf_req_flag && kg_integ_only_iov ( iov , iov_count ) ) { conf_req_flag = FALSE ; } context = ctx -> k5_context ; switch ( ctx -> proto ) { case 0 : code = make_seal_token_v1_iov ( context , ctx , conf_req_flag , conf_state , iov , iov_count , toktype ) ; break ; case 1 : code = gss_krb5int_make_seal_token_v3_iov ( context , ctx , conf_req_flag , conf_state , iov , iov_count , toktype ) ; break ; default : code = G_UNKNOWN_QOP ; break ; } if ( code != 0 ) { * minor_status = code ; save_error_info ( * minor_status , context ) ; return GSS_S_FAILURE ; } * minor_status = 0 ; return GSS_S_COMPLETE ; }
int obj2ast_withitem ( PyObject * obj , withitem_ty * out , PyArena * arena ) { PyObject * tmp = NULL ; expr_ty context_expr ; expr_ty optional_vars ; <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_context_expr ) ) { <S2SV_EndBug> int res ; <S2SV_StartBug> tmp = _PyObject_GetAttrId ( obj , & PyId_context_expr ) ; <S2SV_EndBug> if ( tmp == NULL ) goto failed ; <S2SV_StartBug> res = obj2ast_expr ( tmp , & context_expr , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; <S2SV_StartBug> } else { <S2SV_EndBug> PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"context_expr\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>withitem" ) ; return 1 ; } if ( exists_not_none ( obj , & PyId_optional_vars ) ) { int res ; tmp = _PyObject_GetAttrId ( obj , & PyId_optional_vars ) ; if ( tmp == NULL ) goto failed ; res = obj2ast_expr ( tmp , & optional_vars , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } else { optional_vars = NULL ; } * out = withitem ( context_expr , optional_vars , arena ) ; return 0 ; failed : Py_XDECREF ( tmp ) ; return 1 ; }
static Image * ReadPICTImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { <S2SV_StartBug> # define ThrowPICTException ( exception , message ) { if ( tile_image != ( Image * ) NULL ) tile_image = DestroyImage ( tile_image ) ; if ( read_info != ( ImageInfo * ) NULL ) read_info = DestroyImageInfo ( read_info ) ; ThrowReaderException ( ( exception ) , ( message ) ) ; } <S2SV_EndBug> char geometry [ MagickPathExtent ] , header_ole [ 4 ] ; Image * image , * tile_image ; ImageInfo * read_info ; int c , code ; MagickBooleanType jpeg , status ; PICTRectangle frame ; PICTPixmap pixmap ; Quantum index ; register Quantum * q ; register ssize_t i , x ; size_t extent , length ; ssize_t count , flags , j , version , y ; StringInfo * profile ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , "%s" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } read_info = ( ImageInfo * ) NULL ; tile_image = ( Image * ) NULL ; pixmap . bits_per_pixel = 0 ; pixmap . component_count = 0 ; header_ole [ 0 ] = ReadBlobByte ( image ) ; header_ole [ 1 ] = ReadBlobByte ( image ) ; header_ole [ 2 ] = ReadBlobByte ( image ) ; header_ole [ 3 ] = ReadBlobByte ( image ) ; if ( ! ( ( header_ole [ 0 ] == 0x50 ) && ( header_ole [ 1 ] == 0x49 ) && ( header_ole [ 2 ] == 0x43 ) && ( header_ole [ 3 ] == 0x54 ) ) ) for ( i = 0 ; i < 508 ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; ( void ) ReadBlobMSBShort ( image ) ; if ( ReadRectangle ( image , & frame ) == MagickFalse ) ThrowPICTException ( CorruptImageError , "ImproperImageHeader" ) ; while ( ( c = ReadBlobByte ( image ) ) == 0 ) ; if ( c != 0x11 ) ThrowPICTException ( CorruptImageError , "ImproperImageHeader" ) ; version = ( ssize_t ) ReadBlobByte ( image ) ; if ( version == 2 ) { c = ReadBlobByte ( image ) ; if ( c != 0xff ) ThrowPICTException ( CorruptImageError , "ImproperImageHeader" ) ; } else if ( version != 1 ) ThrowPICTException ( CorruptImageError , "ImproperImageHeader" ) ; if ( ( frame . left < 0 ) || ( frame . right < 0 ) || ( frame . top < 0 ) || ( frame . bottom < 0 ) || ( frame . left >= frame . right ) || ( frame . top >= frame . bottom ) ) ThrowPICTException ( CorruptImageError , "ImproperImageHeader" ) ; flags = 0 ; image -> depth = 8 ; image -> columns = ( size_t ) ( frame . right - frame . left ) ; image -> rows = ( size_t ) ( frame . bottom - frame . top ) ; image -> resolution . x = DefaultResolution ; image -> resolution . y = DefaultResolution ; image -> units = UndefinedResolution ; if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status != MagickFalse ) status = ResetImagePixels ( image , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; jpeg = MagickFalse ; for ( code = 0 ; EOFBlob ( image ) == MagickFalse ; ) { if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; if ( ( version == 1 ) || ( ( TellBlob ( image ) % 2 ) != 0 ) ) code = ReadBlobByte ( image ) ; if ( version == 2 ) code = ReadBlobMSBSignedShort ( image ) ; if ( code < 0 ) break ; if ( code == 0 ) continue ; if ( code > 0xa1 ) { if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "%04X:" , code ) ; } else { if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "<S2SV_blank><S2SV_blank>%04X<S2SV_blank>%s:<S2SV_blank>%s" , code , codes [ code ] . name , codes [ code ] . description ) ; switch ( code ) { case 0x01 : { length = ReadBlobMSBShort ( image ) ; if ( length != 0x000a ) { for ( i = 0 ; i < ( ssize_t ) ( length - 2 ) ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; break ; } if ( ReadRectangle ( image , & frame ) == MagickFalse ) ThrowPICTException ( CorruptImageError , "ImproperImageHeader" ) ; if ( ( ( frame . left & 0x8000 ) != 0 ) || ( ( frame . top & 0x8000 ) != 0 ) ) break ; image -> columns = ( size_t ) ( frame . right - frame . left ) ; image -> rows = ( size_t ) ( frame . bottom - frame . top ) ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status != MagickFalse ) status = ResetImagePixels ( image , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; break ; } case 0x12 : case 0x13 : case 0x14 : { ssize_t pattern ; size_t height , width ; pattern = ( ssize_t ) ReadBlobMSBShort ( image ) ; for ( i = 0 ; i < 8 ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; if ( pattern == 2 ) { for ( i = 0 ; i < 5 ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; break ; } if ( pattern != 1 ) ThrowPICTException ( CorruptImageError , "UnknownPatternType" ) ; length = ReadBlobMSBShort ( image ) ; if ( ReadRectangle ( image , & frame ) == MagickFalse ) ThrowPICTException ( CorruptImageError , "ImproperImageHeader" ) ; if ( ReadPixmap ( image , & pixmap ) == MagickFalse ) ThrowPICTException ( CorruptImageError , "ImproperImageHeader" ) ; image -> depth = ( size_t ) pixmap . component_size ; image -> resolution . x = 1.0 * pixmap . horizontal_resolution ; image -> resolution . y = 1.0 * pixmap . vertical_resolution ; image -> units = PixelsPerInchResolution ; ( void ) ReadBlobMSBLong ( image ) ; flags = ( ssize_t ) ReadBlobMSBShort ( image ) ; length = ReadBlobMSBShort ( image ) ; for ( i = 0 ; i <= ( ssize_t ) length ; i ++ ) ( void ) ReadBlobMSBLong ( image ) ; width = ( size_t ) ( frame . bottom - frame . top ) ; height = ( size_t ) ( frame . right - frame . left ) ; if ( pixmap . bits_per_pixel <= 8 ) length &= 0x7fff ; if ( pixmap . bits_per_pixel == 16 ) width <<= 1 ; if ( length == 0 ) length = width ; if ( length < 8 ) { for ( i = 0 ; i < ( ssize_t ) ( length * height ) ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; } else for ( i = 0 ; i < ( ssize_t ) height ; i ++ ) { if ( EOFBlob ( image ) != MagickFalse ) break ; if ( length > 200 ) { for ( j = 0 ; j < ( ssize_t ) ReadBlobMSBShort ( image ) ; j ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; } else for ( j = 0 ; j < ( ssize_t ) ReadBlobByte ( image ) ; j ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; } break ; } case 0x1b : { image -> background_color . red = ( Quantum ) ScaleShortToQuantum ( ReadBlobMSBShort ( image ) ) ; image -> background_color . green = ( Quantum ) ScaleShortToQuantum ( ReadBlobMSBShort ( image ) ) ; image -> background_color . blue = ( Quantum ) ScaleShortToQuantum ( ReadBlobMSBShort ( image ) ) ; break ; } case 0x70 : case 0x71 : case 0x72 : case 0x73 : case 0x74 : case 0x75 : case 0x76 : case 0x77 : { length = ReadBlobMSBShort ( image ) ; for ( i = 0 ; i < ( ssize_t ) ( length - 2 ) ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; break ; } case 0x90 : case 0x91 : case 0x98 : case 0x99 : case 0x9a : case 0x9b : { PICTRectangle source , destination ; register unsigned char * p ; size_t j ; ssize_t bytes_per_line ; unsigned char * pixels ; bytes_per_line = 0 ; if ( ( code != 0x9a ) && ( code != 0x9b ) ) bytes_per_line = ( ssize_t ) ReadBlobMSBShort ( image ) ; else { ( void ) ReadBlobMSBShort ( image ) ; ( void ) ReadBlobMSBShort ( image ) ; ( void ) ReadBlobMSBShort ( image ) ; } if ( ReadRectangle ( image , & frame ) == MagickFalse ) ThrowPICTException ( CorruptImageError , "ImproperImageHeader" ) ; tile_image = CloneImage ( image , ( size_t ) ( frame . right - frame . left ) , ( size_t ) ( frame . bottom - frame . top ) , MagickTrue , exception ) ; if ( tile_image == ( Image * ) NULL ) ThrowPICTException ( CorruptImageError , "ImproperImageHeader" ) ; if ( ( code == 0x9a ) || ( code == 0x9b ) || ( ( bytes_per_line & 0x8000 ) != 0 ) ) { if ( ReadPixmap ( image , & pixmap ) == MagickFalse ) ThrowPICTException ( CorruptImageError , "ImproperImageHeader" ) ; tile_image -> depth = ( size_t ) pixmap . component_size ; tile_image -> alpha_trait = pixmap . component_count == 4 ? BlendPixelTrait : UndefinedPixelTrait ; tile_image -> resolution . x = ( double ) pixmap . horizontal_resolution ; tile_image -> resolution . y = ( double ) pixmap . vertical_resolution ; tile_image -> units = PixelsPerInchResolution ; if ( tile_image -> alpha_trait != UndefinedPixelTrait ) ( void ) SetImageAlpha ( tile_image , OpaqueAlpha , exception ) ; } if ( ( code != 0x9a ) && ( code != 0x9b ) ) { tile_image -> colors = 2 ; if ( ( bytes_per_line & 0x8000 ) != 0 ) { ( void ) ReadBlobMSBLong ( image ) ; flags = ( ssize_t ) ReadBlobMSBShort ( image ) ; tile_image -> colors = 1UL * ReadBlobMSBShort ( image ) + 1 ; } status = AcquireImageColormap ( tile_image , tile_image -> colors , exception ) ; if ( status == MagickFalse ) ThrowPICTException ( ResourceLimitError , "MemoryAllocationFailed" ) ; if ( ( bytes_per_line & 0x8000 ) != 0 ) { for ( i = 0 ; i < ( ssize_t ) tile_image -> colors ; i ++ ) { j = ReadBlobMSBShort ( image ) % tile_image -> colors ; if ( ( flags & 0x8000 ) != 0 ) j = ( size_t ) i ; tile_image -> colormap [ j ] . red = ( Quantum ) ScaleShortToQuantum ( ReadBlobMSBShort ( image ) ) ; tile_image -> colormap [ j ] . green = ( Quantum ) ScaleShortToQuantum ( ReadBlobMSBShort ( image ) ) ; tile_image -> colormap [ j ] . blue = ( Quantum ) ScaleShortToQuantum ( ReadBlobMSBShort ( image ) ) ; } } else { for ( i = 0 ; i < ( ssize_t ) tile_image -> colors ; i ++ ) { tile_image -> colormap [ i ] . red = ( Quantum ) ( QuantumRange - tile_image -> colormap [ i ] . red ) ; tile_image -> colormap [ i ] . green = ( Quantum ) ( QuantumRange - tile_image -> colormap [ i ] . green ) ; tile_image -> colormap [ i ] . blue = ( Quantum ) ( QuantumRange - tile_image -> colormap [ i ] . blue ) ; } } } if ( EOFBlob ( image ) != MagickFalse ) ThrowPICTException ( CorruptImageError , "InsufficientImageDataInFile" ) ; if ( ReadRectangle ( image , & source ) == MagickFalse ) ThrowPICTException ( CorruptImageError , "ImproperImageHeader" ) ; if ( ReadRectangle ( image , & destination ) == MagickFalse ) ThrowPICTException ( CorruptImageError , "ImproperImageHeader" ) ; ( void ) ReadBlobMSBShort ( image ) ; if ( ( code == 0x91 ) || ( code == 0x99 ) || ( code == 0x9b ) ) { length = ReadBlobMSBShort ( image ) ; for ( i = 0 ; i < ( ssize_t ) ( length - 2 ) ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; } if ( ( code != 0x9a ) && ( code != 0x9b ) && ( bytes_per_line & 0x8000 ) == 0 ) pixels = DecodeImage ( image , tile_image , ( size_t ) bytes_per_line , 1 , & extent ) ; else pixels = DecodeImage ( image , tile_image , ( size_t ) bytes_per_line , ( unsigned int ) pixmap . bits_per_pixel , & extent ) ; if ( pixels == ( unsigned char * ) NULL ) ThrowPICTException ( CorruptImageError , "UnableToUncompressImage" ) ; p = pixels ; for ( y = 0 ; y < ( ssize_t ) tile_image -> rows ; y ++ ) { if ( p > ( pixels + extent + image -> columns ) ) { pixels = ( unsigned char * ) RelinquishMagickMemory ( pixels ) ; ThrowPICTException ( CorruptImageError , "NotEnoughPixelData" ) ; } q = QueueAuthenticPixels ( tile_image , 0 , y , tile_image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) tile_image -> columns ; x ++ ) { if ( tile_image -> storage_class == PseudoClass ) { index = ( Quantum ) ConstrainColormapIndex ( tile_image , ( ssize_t ) * p , exception ) ; SetPixelIndex ( tile_image , index , q ) ; SetPixelRed ( tile_image , tile_image -> colormap [ ( ssize_t ) index ] . red , q ) ; SetPixelGreen ( tile_image , tile_image -> colormap [ ( ssize_t ) index ] . green , q ) ; SetPixelBlue ( tile_image , tile_image -> colormap [ ( ssize_t ) index ] . blue , q ) ; } else { if ( pixmap . bits_per_pixel == 16 ) { i = ( ssize_t ) ( * p ++ ) ; j = ( size_t ) ( * p ) ; SetPixelRed ( tile_image , ScaleCharToQuantum ( ( unsigned char ) ( ( i & 0x7c ) << 1 ) ) , q ) ; SetPixelGreen ( tile_image , ScaleCharToQuantum ( ( unsigned char ) ( ( ( i & 0x03 ) << 6 ) | ( ( j & 0xe0 ) >> 2 ) ) ) , q ) ; SetPixelBlue ( tile_image , ScaleCharToQuantum ( ( unsigned char ) ( ( j & 0x1f ) << 3 ) ) , q ) ; } else if ( tile_image -> alpha_trait == UndefinedPixelTrait ) { if ( p > ( pixels + extent + 2 * image -> columns ) ) ThrowPICTException ( CorruptImageError , "NotEnoughPixelData" ) ; SetPixelRed ( tile_image , ScaleCharToQuantum ( * p ) , q ) ; SetPixelGreen ( tile_image , ScaleCharToQuantum ( * ( p + tile_image -> columns ) ) , q ) ; SetPixelBlue ( tile_image , ScaleCharToQuantum ( * ( p + 2 * tile_image -> columns ) ) , q ) ; } else { if ( p > ( pixels + extent + 3 * image -> columns ) ) ThrowPICTException ( CorruptImageError , "NotEnoughPixelData" ) ; SetPixelAlpha ( tile_image , ScaleCharToQuantum ( * p ) , q ) ; SetPixelRed ( tile_image , ScaleCharToQuantum ( * ( p + tile_image -> columns ) ) , q ) ; SetPixelGreen ( tile_image , ScaleCharToQuantum ( * ( p + 2 * tile_image -> columns ) ) , q ) ; SetPixelBlue ( tile_image , ScaleCharToQuantum ( * ( p + 3 * tile_image -> columns ) ) , q ) ; } } p ++ ; q += GetPixelChannels ( tile_image ) ; } if ( SyncAuthenticPixels ( tile_image , exception ) == MagickFalse ) break ; if ( ( tile_image -> storage_class == DirectClass ) && ( pixmap . bits_per_pixel != 16 ) ) { p += ( pixmap . component_count - 1 ) * tile_image -> columns ; if ( p < pixels ) break ; } status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , tile_image -> rows ) ; if ( status == MagickFalse ) break ; } pixels = ( unsigned char * ) RelinquishMagickMemory ( pixels ) ; if ( ( jpeg == MagickFalse ) && ( EOFBlob ( image ) == MagickFalse ) ) if ( ( code == 0x9a ) || ( code == 0x9b ) || ( ( bytes_per_line & 0x8000 ) != 0 ) ) ( void ) CompositeImage ( image , tile_image , CopyCompositeOp , MagickTrue , ( ssize_t ) destination . left , ( ssize_t ) destination . top , exception ) ; tile_image = DestroyImage ( tile_image ) ; break ; } case 0xa1 : { unsigned char * info ; size_t type ; type = ReadBlobMSBShort ( image ) ; length = ReadBlobMSBShort ( image ) ; if ( length == 0 ) break ; ( void ) ReadBlobMSBLong ( image ) ; length -= MagickMin ( length , 4 ) ; if ( length == 0 ) break ; info = ( unsigned char * ) AcquireQuantumMemory ( length , sizeof ( * info ) ) ; if ( info == ( unsigned char * ) NULL ) break ; count = ReadBlob ( image , length , info ) ; if ( count != ( ssize_t ) length ) { info = ( unsigned char * ) RelinquishMagickMemory ( info ) ; ThrowPICTException ( ResourceLimitError , "UnableToReadImageData" ) ; } switch ( type ) { case 0xe0 : { profile = BlobToStringInfo ( ( const void * ) NULL , length ) ; SetStringInfoDatum ( profile , info ) ; status = SetImageProfile ( image , "icc" , profile , exception ) ; profile = DestroyStringInfo ( profile ) ; if ( status == MagickFalse ) { info = ( unsigned char * ) RelinquishMagickMemory ( info ) ; ThrowPICTException ( ResourceLimitError , "MemoryAllocationFailed" ) ; } break ; } case 0x1f2 : { profile = BlobToStringInfo ( ( const void * ) NULL , length ) ; SetStringInfoDatum ( profile , info ) ; status = SetImageProfile ( image , "iptc" , profile , exception ) ; if ( status == MagickFalse ) { info = ( unsigned char * ) RelinquishMagickMemory ( info ) ; ThrowPICTException ( ResourceLimitError , "MemoryAllocationFailed" ) ; } profile = DestroyStringInfo ( profile ) ; break ; } default : break ; } info = ( unsigned char * ) RelinquishMagickMemory ( info ) ; break ; } default : { if ( codes [ code ] . length == - 1 ) ( void ) ReadBlobMSBShort ( image ) ; else for ( i = 0 ; i < ( ssize_t ) codes [ code ] . length ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; } } } if ( code == 0xc00 ) { for ( i = 0 ; i < 24 ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; continue ; } if ( ( ( code >= 0xb0 ) && ( code <= 0xcf ) ) || ( ( code >= 0x8000 ) && ( code <= 0x80ff ) ) ) continue ; if ( code == 0x8200 ) { char filename [ MaxTextExtent ] ; FILE * file ; int unique_file ; jpeg = MagickTrue ; read_info = CloneImageInfo ( image_info ) ; SetImageInfoBlob ( read_info , ( void * ) NULL , 0 ) ; file = ( FILE * ) NULL ; unique_file = AcquireUniqueFileResource ( filename ) ; ( void ) FormatLocaleString ( read_info -> filename , MaxTextExtent , "jpeg:%s" , filename ) ; if ( unique_file != - 1 ) file = fdopen ( unique_file , "wb" ) ; if ( ( unique_file == - 1 ) || ( file == ( FILE * ) NULL ) ) { ( void ) RelinquishUniqueFileResource ( read_info -> filename ) ; ( void ) CopyMagickString ( image -> filename , read_info -> filename , MagickPathExtent ) ; ThrowPICTException ( FileOpenError , "UnableToCreateTemporaryFile" ) ; } length = ReadBlobMSBLong ( image ) ; if ( length > 154 ) { for ( i = 0 ; i < 6 ; i ++ ) ( void ) ReadBlobMSBLong ( image ) ; if ( ReadRectangle ( image , & frame ) == MagickFalse ) { ( void ) fclose ( file ) ; ( void ) RelinquishUniqueFileResource ( read_info -> filename ) ; ThrowPICTException ( CorruptImageError , "ImproperImageHeader" ) ; } for ( i = 0 ; i < 122 ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; for ( i = 0 ; i < ( ssize_t ) ( length - 154 ) ; i ++ ) { c = ReadBlobByte ( image ) ; if ( c == EOF ) break ; <S2SV_StartBug> ( void ) fputc ( c , file ) ; <S2SV_EndBug> } } ( void ) fclose ( file ) ; ( void ) close ( unique_file ) ; tile_image = ReadImage ( read_info , exception ) ; ( void ) RelinquishUniqueFileResource ( filename ) ; read_info = DestroyImageInfo ( read_info ) ; if ( tile_image == ( Image * ) NULL ) continue ; ( void ) FormatLocaleString ( geometry , MagickPathExtent , "%.20gx%.20g" , ( double ) MagickMax ( image -> columns , tile_image -> columns ) , ( double ) MagickMax ( image -> rows , tile_image -> rows ) ) ; ( void ) SetImageExtent ( image , MagickMax ( image -> columns , tile_image -> columns ) , MagickMax ( image -> rows , tile_image -> rows ) , exception ) ; ( void ) TransformImageColorspace ( image , tile_image -> colorspace , exception ) ; ( void ) CompositeImage ( image , tile_image , CopyCompositeOp , MagickTrue , ( ssize_t ) frame . left , ( ssize_t ) frame . right , exception ) ; image -> compression = tile_image -> compression ; tile_image = DestroyImage ( tile_image ) ; continue ; } if ( ( code == 0xff ) || ( code == 0xffff ) ) break ; if ( ( ( code >= 0xd0 ) && ( code <= 0xfe ) ) || ( ( code >= 0x8100 ) && ( code <= 0xffff ) ) ) { length = ReadBlobMSBShort ( image ) ; for ( i = 0 ; i < ( ssize_t ) length ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; continue ; } if ( ( code >= 0x100 ) && ( code <= 0x7fff ) ) { length = ( size_t ) ( ( code >> 7 ) & 0xff ) ; for ( i = 0 ; i < ( ssize_t ) length ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; continue ; } } ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
PyObject * ast2obj_keyword ( void * _o ) { keyword_ty o = ( keyword_ty ) _o ; PyObject * result = NULL , * value = NULL ; if ( ! o ) { <S2SV_StartBug> Py_INCREF ( Py_None ) ; <S2SV_EndBug> return Py_None ; } result = PyType_GenericNew ( keyword_type , NULL , NULL ) ; if ( ! result ) return NULL ; value = ast2obj_identifier ( o -> arg ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_arg , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> value ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_value , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; return result ; failed : Py_XDECREF ( value ) ; Py_XDECREF ( result ) ; return NULL ; }
<S2SV_StartBug> static vpx_codec_err_t vp8e_set_activemap ( vpx_codec_alg_priv_t * ctx , <S2SV_EndBug> int ctr_id , va_list args ) { vpx_active_map_t * data = va_arg ( args , vpx_active_map_t * ) ; if ( data ) { vpx_active_map_t * map = ( vpx_active_map_t * ) data ; if ( ! vp8_set_active_map ( ctx -> cpi , map -> active_map , map -> rows , map -> cols ) ) return VPX_CODEC_OK ; else return VPX_CODEC_INVALID_PARAM ; } else return VPX_CODEC_INVALID_PARAM ; }
int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_str_startswith ( adata -> buf , "*<S2SV_blank>OK" , CASE_IGNORE ) ) { if ( ! mutt_str_startswith ( adata -> buf , "*<S2SV_blank>OK<S2SV_blank>[CAPABILITY" , CASE_IGNORE ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ! adata -> conn -> ssf && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( "Secure<S2SV_blank>connection<S2SV_blank>with<S2SV_blank>TLS?" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { <S2SV_StartBug> enum ImapExecResult rc = imap_exec ( adata , "STARTTLS" , IMAP_CMD_NO_FLAGS ) ; <S2SV_EndBug> if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( "Could<S2SV_blank>not<S2SV_blank>negotiate<S2SV_blank>TLS<S2SV_blank>connection" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , "CAPABILITY" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } if ( C_SslForceTls && ! adata -> conn -> ssf ) { mutt_error ( _ ( "Encrypted<S2SV_blank>connection<S2SV_blank>unavailable" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_str_startswith ( adata -> buf , "*<S2SV_blank>PREAUTH" , CASE_IGNORE ) ) { # ifdef USE_SSL if ( adata -> conn -> ssf == 0 ) { bool proceed = true ; if ( C_SslForceTls ) { proceed = false ; } else if ( C_SslStarttls != MUTT_NO ) { proceed = mutt_yesorno ( _ ( "Abort<S2SV_blank>unencrypted<S2SV_blank>PREAUTH<S2SV_blank>connection?" ) , C_SslStarttls ) != MUTT_NO ; } if ( ! proceed ) { mutt_error ( _ ( "Encrypted<S2SV_blank>connection<S2SV_blank>unavailable" ) ) ; goto err_close_conn ; } } # endif adata -> state = IMAP_AUTHENTICATED ; if ( check_capabilities ( adata ) != 0 ) goto bail ; FREE ( & adata -> capstr ) ; } else { imap_error ( "imap_open_connection()" , adata -> buf ) ; goto bail ; } return 0 ; # ifdef USE_SSL err_close_conn : imap_close_connection ( adata ) ; # endif bail : FREE ( & adata -> capstr ) ; return - 1 ; }
void open_log_file ( const char * name , const char * prog , const char * namespace , const char * instance ) { char * file_name ; if ( log_file ) { fclose ( log_file ) ; log_file = NULL ; } if ( ! name ) return ; file_name = make_file_name ( name , prog , namespace , instance ) ; <S2SV_StartBug> log_file = fopen ( file_name , "a" ) ; <S2SV_EndBug> if ( log_file ) { int n = fileno ( log_file ) ; fcntl ( n , F_SETFD , FD_CLOEXEC | fcntl ( n , F_GETFD ) ) ; fcntl ( n , F_SETFL , O_NONBLOCK | fcntl ( n , F_GETFL ) ) ; } FREE ( file_name ) ; }
int f2fs_trim_fs ( struct f2fs_sb_info * sbi , struct fstrim_range * range ) { __u64 start = F2FS_BYTES_TO_BLK ( range -> start ) ; __u64 end = start + F2FS_BYTES_TO_BLK ( range -> len ) - 1 ; unsigned int start_segno , end_segno ; struct cp_control cpc ; int err = 0 ; if ( start >= MAX_BLKADDR ( sbi ) || range -> len < sbi -> blocksize ) return - EINVAL ; cpc . trimmed = 0 ; if ( end <= MAIN_BLKADDR ( sbi ) ) goto out ; if ( is_sbi_flag_set ( sbi , SBI_NEED_FSCK ) ) { f2fs_msg ( sbi -> sb , KERN_WARNING , "Found<S2SV_blank>FS<S2SV_blank>corruption,<S2SV_blank>run<S2SV_blank>fsck<S2SV_blank>to<S2SV_blank>fix." ) ; goto out ; } start_segno = ( start <= MAIN_BLKADDR ( sbi ) ) ? 0 : GET_SEGNO ( sbi , start ) ; end_segno = ( end >= MAX_BLKADDR ( sbi ) ) ? MAIN_SEGS ( sbi ) - 1 : GET_SEGNO ( sbi , end ) ; cpc . reason = CP_DISCARD ; cpc . trim_minlen = max_t ( __u64 , 1 , F2FS_BYTES_TO_BLK ( range -> minlen ) ) ; for ( ; start_segno <= end_segno ; start_segno = cpc . trim_end + 1 ) { cpc . trim_start = start_segno ; if ( sbi -> discard_blks == 0 ) break ; else if ( sbi -> discard_blks < BATCHED_TRIM_BLOCKS ( sbi ) ) cpc . trim_end = end_segno ; else cpc . trim_end = min_t ( unsigned int , rounddown ( start_segno + BATCHED_TRIM_SEGMENTS ( sbi ) , sbi -> segs_per_sec ) - 1 , end_segno ) ; mutex_lock ( & sbi -> gc_mutex ) ; err = write_checkpoint ( sbi , & cpc ) ; mutex_unlock ( & sbi -> gc_mutex ) ; if ( err ) break ; schedule ( ) ; } mark_discard_range_all ( sbi ) ; <S2SV_StartBug> f2fs_wait_discard_bios ( sbi ) ; <S2SV_EndBug> out : range -> len = F2FS_BLK_TO_BYTES ( cpc . trimmed ) ; return err ; }
int main ( int argc , const char * * argv_ ) { int pass ; vpx_image_t raw ; <S2SV_StartBug> int frame_avail , got_data ; <S2SV_EndBug> <S2SV_StartBug> struct VpxInputContext input = { 0 } ; <S2SV_EndBug> struct VpxEncoderConfig global ; struct stream_state * streams = NULL ; char * * argv , * * argi ; uint64_t cx_time = 0 ; int stream_cnt = 0 ; int res = 0 ; <S2SV_StartBug> exec_name = argv_ [ 0 ] ; <S2SV_EndBug> if ( argc < 3 ) usage_exit ( ) ; input . framerate . numerator = 30 ; input . framerate . denominator = 1 ; <S2SV_StartBug> input . use_i420 = 1 ; <S2SV_EndBug> <S2SV_StartBug> input . only_i420 = 1 ; <S2SV_EndBug> argv = argv_dup ( argc - 1 , argv_ + 1 ) ; <S2SV_StartBug> parse_global_config ( & global , argv ) ; <S2SV_EndBug> { struct stream_state * stream = NULL ; do { stream = new_stream ( & global , stream ) ; stream_cnt ++ ; if ( ! streams ) streams = stream ; } while ( parse_stream_params ( & global , stream , argv ) ) ; } for ( argi = argv ; * argi ; argi ++ ) if ( argi [ 0 ] [ 0 ] == '-' && argi [ 0 ] [ 1 ] ) die ( "Error:<S2SV_blank>Unrecognized<S2SV_blank>option<S2SV_blank>%s\\n" , * argi ) ; FOREACH_STREAM ( check_encoder_config ( global . disable_warning_prompt , & global , & stream -> config . cfg ) ; ) ; input . filename = argv [ 0 ] ; if ( ! input . filename ) usage_exit ( ) ; if ( global . codec -> fourcc == VP9_FOURCC ) input . only_i420 = 0 ; for ( pass = global . pass ? global . pass - 1 : 0 ; pass < global . passes ; pass ++ ) { int frames_in = 0 , seen_frames = 0 ; int64_t estimated_time_left = - 1 ; int64_t average_rate = - 1 ; <S2SV_StartBug> off_t lagged_count = 0 ; <S2SV_EndBug> open_input_file ( & input ) ; <S2SV_StartBug> if ( ! input . width || ! input . height ) <S2SV_EndBug> FOREACH_STREAM ( { if ( stream -> config . cfg . g_w && stream -> config . cfg . g_h ) { input . width = stream -> config . cfg . g_w ; input . height = stream -> config . cfg . g_h ; break ; } <S2SV_StartBug> } ) ; <S2SV_EndBug> if ( ! input . width || ! input . height ) fatal ( "Specify<S2SV_blank>stream<S2SV_blank>dimensions<S2SV_blank>with<S2SV_blank>--width<S2SV_blank>(-w)<S2SV_blank>" <S2SV_StartBug> "<S2SV_blank>and<S2SV_blank>--height<S2SV_blank>(-h)" ) ; <S2SV_EndBug> FOREACH_STREAM ( set_stream_dimensions ( stream , input . width , input . height ) ) ; FOREACH_STREAM ( validate_stream_config ( stream , & global ) ) ; if ( global . pass && global . passes == 2 ) FOREACH_STREAM ( { if ( ! stream -> config . stats_fn ) die ( "Stream<S2SV_blank>%d:<S2SV_blank>Must<S2SV_blank>specify<S2SV_blank>--fpf<S2SV_blank>when<S2SV_blank>--pass=%d" "<S2SV_blank>and<S2SV_blank>--passes=2\\n" , stream -> index , global . pass ) ; } ) ; # if ! CONFIG_WEBM_IO FOREACH_STREAM ( { stream -> config . write_webm = 0 ; warn ( "vpxenc<S2SV_blank>was<S2SV_blank>compiled<S2SV_blank>without<S2SV_blank>WebM<S2SV_blank>container<S2SV_blank>support." "Producing<S2SV_blank>IVF<S2SV_blank>output" ) ; } ) ; # endif if ( ! global . have_framerate ) { global . framerate . num = input . framerate . numerator ; global . framerate . den = input . framerate . denominator ; } FOREACH_STREAM ( set_default_kf_interval ( stream , & global ) ) ; if ( global . verbose && pass == 0 ) FOREACH_STREAM ( show_stream_config ( stream , & global , & input ) ) ; if ( pass == ( global . pass ? global . pass - 1 : 0 ) ) { if ( input . file_type == FILE_TYPE_Y4M ) memset ( & raw , 0 , sizeof ( raw ) ) ; else vpx_img_alloc ( & raw , <S2SV_StartBug> input . use_i420 ? VPX_IMG_FMT_I420 <S2SV_EndBug> : VPX_IMG_FMT_YV12 , input . width , input . height , 32 ) ; FOREACH_STREAM ( stream -> rate_hist = init_rate_histogram ( & stream -> config . cfg , & global . framerate ) ) ; } FOREACH_STREAM ( setup_pass ( stream , & global , pass ) ) ; <S2SV_StartBug> FOREACH_STREAM ( open_output_file ( stream , & global ) ) ; <S2SV_EndBug> <S2SV_StartBug> FOREACH_STREAM ( initialize_encoder ( stream , & global ) ) ; <S2SV_EndBug> frame_avail = 1 ; got_data = 0 ; while ( frame_avail || got_data ) { struct vpx_usec_timer timer ; if ( ! global . limit || frames_in < global . limit ) { frame_avail = read_frame ( & input , & raw ) ; if ( frame_avail ) frames_in ++ ; seen_frames = frames_in > global . skip_frames ? frames_in - global . skip_frames : 0 ; if ( ! global . quiet ) { float fps = usec_to_fps ( cx_time , seen_frames ) ; fprintf ( stderr , "\\rPass<S2SV_blank>%d/%d<S2SV_blank>" , pass + 1 , global . passes ) ; if ( stream_cnt == 1 ) fprintf ( stderr , "frame<S2SV_blank>%4d/%-4d<S2SV_blank>%7" PRId64 "B<S2SV_blank>" , frames_in , streams -> frames_out , ( int64_t ) streams -> nbytes ) ; else fprintf ( stderr , "frame<S2SV_blank>%4d<S2SV_blank>" , frames_in ) ; fprintf ( stderr , "%7" PRId64 "<S2SV_blank>%s<S2SV_blank>%.2f<S2SV_blank>%s<S2SV_blank>" , cx_time > 9999999 ? cx_time / 1000 : cx_time , cx_time > 9999999 ? "ms" : "us" , fps >= 1.0 ? fps : fps * 60 , fps >= 1.0 ? "fps" : "fpm" ) ; print_time ( "ETA" , estimated_time_left ) ; <S2SV_StartBug> fprintf ( stderr , "\\033[K" ) ; <S2SV_EndBug> } } else frame_avail = 0 ; <S2SV_StartBug> if ( frames_in > global . skip_frames ) { <S2SV_EndBug> vpx_usec_timer_start ( & timer ) ; FOREACH_STREAM ( encode_frame ( stream , & global , frame_avail ? & raw : NULL , frames_in ) ) ; <S2SV_StartBug> vpx_usec_timer_mark ( & timer ) ; <S2SV_EndBug> cx_time += vpx_usec_timer_elapsed ( & timer ) ; FOREACH_STREAM ( update_quantizer_histogram ( stream ) ) ; got_data = 0 ; FOREACH_STREAM ( get_cx_data ( stream , & global , & got_data ) ) ; <S2SV_StartBug> if ( ! got_data && input . length && ! streams -> frames_out ) { <S2SV_EndBug> lagged_count = global . limit ? seen_frames : ftello ( input . file ) ; } else if ( input . length ) { int64_t remaining ; int64_t rate ; if ( global . limit ) { <S2SV_StartBug> off_t frame_in_lagged = ( seen_frames - lagged_count ) * 1000 ; <S2SV_EndBug> rate = cx_time ? frame_in_lagged * ( int64_t ) 1000000 / cx_time : 0 ; remaining = 1000 * ( global . limit - global . skip_frames - seen_frames + lagged_count ) ; } else { <S2SV_StartBug> off_t input_pos = ftello ( input . file ) ; <S2SV_EndBug> <S2SV_StartBug> off_t input_pos_lagged = input_pos - lagged_count ; <S2SV_EndBug> <S2SV_StartBug> int64_t limit = input . length ; <S2SV_EndBug> rate = cx_time ? input_pos_lagged * ( int64_t ) 1000000 / cx_time : 0 ; remaining = limit - input_pos + lagged_count ; } average_rate = ( average_rate <= 0 ) ? rate : ( average_rate * 7 + rate ) / 8 ; estimated_time_left = average_rate ? remaining / average_rate : - 1 ; } if ( got_data && global . test_decode != TEST_DECODE_OFF ) FOREACH_STREAM ( test_decode ( stream , global . test_decode , global . codec ) ) ; } fflush ( stdout ) ; <S2SV_StartBug> } <S2SV_EndBug> if ( stream_cnt > 1 ) fprintf ( stderr , "\\n" ) ; <S2SV_StartBug> if ( ! global . quiet ) <S2SV_EndBug> FOREACH_STREAM ( fprintf ( stderr , <S2SV_StartBug> "\\rPass<S2SV_blank>%d/%d<S2SV_blank>frame<S2SV_blank>%4d/%-4d<S2SV_blank>%7" PRId64 "B<S2SV_blank>%7lub/f<S2SV_blank>%7" PRId64 "b/s" <S2SV_EndBug> "<S2SV_blank>%7" PRId64 "<S2SV_blank>%s<S2SV_blank>(%.2f<S2SV_blank>fps)\\033[K\\n" , pass + 1 , global . passes , frames_in , stream -> frames_out , ( int64_t ) stream -> nbytes , <S2SV_StartBug> seen_frames ? ( unsigned long ) ( stream -> nbytes * 8 / seen_frames ) : 0 , <S2SV_EndBug> seen_frames ? ( int64_t ) stream -> nbytes * 8 * ( int64_t ) global . framerate . num / global . framerate . den / seen_frames : 0 , stream -> cx_time > 9999999 ? stream -> cx_time / 1000 : stream -> cx_time , stream -> cx_time > 9999999 ? "ms" : "us" , <S2SV_StartBug> usec_to_fps ( stream -> cx_time , seen_frames ) ) ; <S2SV_EndBug> ) ; if ( global . show_psnr ) <S2SV_StartBug> FOREACH_STREAM ( show_psnr ( stream ) ) ; <S2SV_EndBug> FOREACH_STREAM ( vpx_codec_destroy ( & stream -> encoder ) ) ; if ( global . test_decode != TEST_DECODE_OFF ) { FOREACH_STREAM ( vpx_codec_destroy ( & stream -> decoder ) ) ; } close_input_file ( & input ) ; if ( global . test_decode == TEST_DECODE_FATAL ) { FOREACH_STREAM ( res |= stream -> mismatch_seen ) ; } FOREACH_STREAM ( close_output_file ( stream , global . codec -> fourcc ) ) ; <S2SV_StartBug> FOREACH_STREAM ( stats_close ( & stream -> stats , global . passes - 1 ) ) ; <S2SV_EndBug> if ( global . pass ) break ; } if ( global . show_q_hist_buckets ) FOREACH_STREAM ( show_q_histogram ( stream -> counts , global . show_q_hist_buckets ) ) ; if ( global . show_rate_hist_buckets ) FOREACH_STREAM ( show_rate_histogram ( stream -> rate_hist , & stream -> config . cfg , global . show_rate_hist_buckets ) ) ; FOREACH_STREAM ( destroy_rate_histogram ( stream -> rate_hist ) ) ; # if CONFIG_INTERNAL_STATS if ( ! ( global . pass == 1 && global . passes == 2 ) ) FOREACH_STREAM ( { FILE * f = fopen ( "opsnr.stt" , "a" ) ; if ( stream -> mismatch_seen ) { fprintf ( f , "First<S2SV_blank>mismatch<S2SV_blank>occurred<S2SV_blank>in<S2SV_blank>frame<S2SV_blank>%d\\n" , stream -> mismatch_seen ) ; } else { fprintf ( f , "No<S2SV_blank>mismatch<S2SV_blank>detected<S2SV_blank>in<S2SV_blank>recon<S2SV_blank>buffers\\n" ) ; } fclose ( f ) ; <S2SV_StartBug> } ) ; <S2SV_EndBug> # endif vpx_img_free ( & raw ) ; free ( argv ) ; free ( streams ) ; return res ? EXIT_FAILURE : EXIT_SUCCESS ; }
static void Rp_test ( js_State * J ) { js_Regexp * re ; const char * text ; <S2SV_StartBug> int opts ; <S2SV_EndBug> Resub m ; re = js_toregexp ( J , 0 ) ; text = js_tostring ( J , 1 ) ; opts = 0 ; if ( re -> flags & JS_REGEXP_G ) { if ( re -> last > strlen ( text ) ) { re -> last = 0 ; js_pushboolean ( J , 0 ) ; return ; } if ( re -> last > 0 ) { text += re -> last ; opts |= REG_NOTBOL ; } } <S2SV_StartBug> if ( ! js_regexec ( re -> prog , text , & m , opts ) ) { <S2SV_EndBug> if ( re -> flags & JS_REGEXP_G ) re -> last = re -> last + ( m . sub [ 0 ] . ep - text ) ; js_pushboolean ( J , 1 ) ; return ; } if ( re -> flags & JS_REGEXP_G ) re -> last = 0 ; js_pushboolean ( J , 0 ) ; }
<S2SV_StartBug> uint32_t GetPayloadTime ( size_t handle , uint32_t index , float * in , float * out ) <S2SV_EndBug> { mp4object * mp4 = ( mp4object * ) handle ; <S2SV_StartBug> if ( mp4 == NULL ) return 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( mp4 -> metaoffsets == 0 || mp4 -> basemetadataduration == 0 || mp4 -> meta_clockdemon == 0 || in == NULL || out == NULL ) return 1 ; <S2SV_EndBug> <S2SV_StartBug> * in = ( float ) ( ( double ) index * ( double ) mp4 -> basemetadataduration / ( double ) mp4 -> meta_clockdemon ) ; <S2SV_EndBug> <S2SV_StartBug> * out = ( float ) ( ( double ) ( index + 1 ) * ( double ) mp4 -> basemetadataduration / ( double ) mp4 -> meta_clockdemon ) ; <S2SV_EndBug> <S2SV_StartBug> return 0 ; <S2SV_EndBug> }
static void Process_ipfix_template_withdraw ( exporter_ipfix_domain_t * exporter , void * DataPtr , uint32_t size_left , FlowSource_t * fs ) { ipfix_template_record_t * ipfix_template_record ; while ( size_left ) { <S2SV_StartBug> uint32_t id ; <S2SV_EndBug> ipfix_template_record = ( ipfix_template_record_t * ) DataPtr ; size_left -= 4 ; id = ntohs ( ipfix_template_record -> TemplateID ) ; if ( id == IPFIX_TEMPLATE_FLOWSET_ID ) { remove_all_translation_tables ( exporter ) ; ReInitExtensionMapList ( fs ) ; } else { remove_translation_table ( fs , exporter , id ) ; } DataPtr = DataPtr + 4 ; if ( size_left < 4 ) { dbg_printf ( "Skip<S2SV_blank>%u<S2SV_blank>bytes<S2SV_blank>padding\\n" , size_left ) ; size_left = 0 ; } } }
error_t httpReadRequestHeader ( HttpConnection * connection ) { error_t error ; size_t length ; error = socketSetTimeout ( connection -> socket , HTTP_SERVER_IDLE_TIMEOUT ) ; if ( error ) return error ; error = httpReceive ( connection , connection -> buffer , HTTP_SERVER_BUFFER_SIZE - 1 , & length , SOCKET_FLAG_BREAK_CRLF ) ; if ( error ) return error ; error = socketSetTimeout ( connection -> socket , HTTP_SERVER_TIMEOUT ) ; if ( error ) return error ; connection -> buffer [ length ] = '\\0' ; TRACE_INFO ( "%s" , connection -> buffer ) ; error = httpParseRequestLine ( connection , connection -> buffer ) ; if ( error ) return error ; connection -> request . chunkedEncoding = FALSE ; connection -> request . contentLength = 0 ; # if ( HTTP_SERVER_WEB_SOCKET_SUPPORT == ENABLED ) connection -> request . upgradeWebSocket = FALSE ; connection -> request . connectionUpgrade = FALSE ; osStrcpy ( connection -> request . clientKey , "" ) ; # endif if ( connection -> request . version >= HTTP_VERSION_1_0 ) { char_t firstChar ; char_t * separator ; char_t * name ; char_t * value ; firstChar = '\\0' ; while ( 1 ) { error = httpReadHeaderField ( connection , connection -> buffer , HTTP_SERVER_BUFFER_SIZE , & firstChar ) ; if ( error ) return error ; TRACE_DEBUG ( "%s" , connection -> buffer ) ; if ( ! osStrcmp ( connection -> buffer , "\\r\\n" ) ) break ; <S2SV_StartBug> separator = strchr ( connection -> buffer , ':' ) ; <S2SV_EndBug> if ( separator != NULL ) { * separator = '\\0' ; name = strTrimWhitespace ( connection -> buffer ) ; value = strTrimWhitespace ( separator + 1 ) ; httpParseHeaderField ( connection , name , value ) ; } } } if ( connection -> request . chunkedEncoding ) { connection -> request . byteCount = 0 ; connection -> request . firstChunk = TRUE ; connection -> request . lastChunk = FALSE ; } else { connection -> request . byteCount = connection -> request . contentLength ; } return NO_ERROR ; }
static int session_new ( nghttp2_session * * session_ptr , const nghttp2_session_callbacks * callbacks , void * user_data , int server , const nghttp2_option * option , nghttp2_mem * mem ) { int rv ; size_t nbuffer ; size_t max_deflate_dynamic_table_size = NGHTTP2_HD_DEFAULT_MAX_DEFLATE_BUFFER_SIZE ; if ( mem == NULL ) { mem = nghttp2_mem_default ( ) ; } * session_ptr = nghttp2_mem_calloc ( mem , 1 , sizeof ( nghttp2_session ) ) ; if ( * session_ptr == NULL ) { rv = NGHTTP2_ERR_NOMEM ; goto fail_session ; } ( * session_ptr ) -> mem = * mem ; mem = & ( * session_ptr ) -> mem ; nghttp2_stream_init ( & ( * session_ptr ) -> root , 0 , NGHTTP2_STREAM_FLAG_NONE , NGHTTP2_STREAM_IDLE , NGHTTP2_DEFAULT_WEIGHT , 0 , 0 , NULL , mem ) ; ( * session_ptr ) -> remote_window_size = NGHTTP2_INITIAL_CONNECTION_WINDOW_SIZE ; ( * session_ptr ) -> recv_window_size = 0 ; ( * session_ptr ) -> consumed_size = 0 ; ( * session_ptr ) -> recv_reduction = 0 ; ( * session_ptr ) -> local_window_size = NGHTTP2_INITIAL_CONNECTION_WINDOW_SIZE ; ( * session_ptr ) -> goaway_flags = NGHTTP2_GOAWAY_NONE ; ( * session_ptr ) -> local_last_stream_id = ( 1u << 31 ) - 1 ; ( * session_ptr ) -> remote_last_stream_id = ( 1u << 31 ) - 1 ; ( * session_ptr ) -> pending_local_max_concurrent_stream = NGHTTP2_DEFAULT_MAX_CONCURRENT_STREAMS ; ( * session_ptr ) -> pending_enable_push = 1 ; if ( server ) { ( * session_ptr ) -> server = 1 ; } init_settings ( & ( * session_ptr ) -> remote_settings ) ; init_settings ( & ( * session_ptr ) -> local_settings ) ; ( * session_ptr ) -> max_incoming_reserved_streams = NGHTTP2_MAX_INCOMING_RESERVED_STREAMS ; ( * session_ptr ) -> remote_settings . max_concurrent_streams = 100 ; ( * session_ptr ) -> max_send_header_block_length = NGHTTP2_MAX_HEADERSLEN ; ( * session_ptr ) -> max_outbound_ack = NGHTTP2_DEFAULT_MAX_OBQ_FLOOD_ITEM ; <S2SV_StartBug> if ( option ) { <S2SV_EndBug> if ( ( option -> opt_set_mask & NGHTTP2_OPT_NO_AUTO_WINDOW_UPDATE ) && option -> no_auto_window_update ) { ( * session_ptr ) -> opt_flags |= NGHTTP2_OPTMASK_NO_AUTO_WINDOW_UPDATE ; } if ( option -> opt_set_mask & NGHTTP2_OPT_PEER_MAX_CONCURRENT_STREAMS ) { ( * session_ptr ) -> remote_settings . max_concurrent_streams = option -> peer_max_concurrent_streams ; } if ( option -> opt_set_mask & NGHTTP2_OPT_MAX_RESERVED_REMOTE_STREAMS ) { ( * session_ptr ) -> max_incoming_reserved_streams = option -> max_reserved_remote_streams ; } if ( ( option -> opt_set_mask & NGHTTP2_OPT_NO_RECV_CLIENT_MAGIC ) && option -> no_recv_client_magic ) { ( * session_ptr ) -> opt_flags |= NGHTTP2_OPTMASK_NO_RECV_CLIENT_MAGIC ; } if ( ( option -> opt_set_mask & NGHTTP2_OPT_NO_HTTP_MESSAGING ) && option -> no_http_messaging ) { ( * session_ptr ) -> opt_flags |= NGHTTP2_OPTMASK_NO_HTTP_MESSAGING ; } if ( option -> opt_set_mask & NGHTTP2_OPT_USER_RECV_EXT_TYPES ) { memcpy ( ( * session_ptr ) -> user_recv_ext_types , option -> user_recv_ext_types , sizeof ( ( * session_ptr ) -> user_recv_ext_types ) ) ; } if ( option -> opt_set_mask & NGHTTP2_OPT_BUILTIN_RECV_EXT_TYPES ) { ( * session_ptr ) -> builtin_recv_ext_types = option -> builtin_recv_ext_types ; } if ( ( option -> opt_set_mask & NGHTTP2_OPT_NO_AUTO_PING_ACK ) && option -> no_auto_ping_ack ) { ( * session_ptr ) -> opt_flags |= NGHTTP2_OPTMASK_NO_AUTO_PING_ACK ; } if ( option -> opt_set_mask & NGHTTP2_OPT_MAX_SEND_HEADER_BLOCK_LENGTH ) { ( * session_ptr ) -> max_send_header_block_length = option -> max_send_header_block_length ; } if ( option -> opt_set_mask & NGHTTP2_OPT_MAX_DEFLATE_DYNAMIC_TABLE_SIZE ) { max_deflate_dynamic_table_size = option -> max_deflate_dynamic_table_size ; } if ( ( option -> opt_set_mask & NGHTTP2_OPT_NO_CLOSED_STREAMS ) && option -> no_closed_streams ) { ( * session_ptr ) -> opt_flags |= NGHTTP2_OPTMASK_NO_CLOSED_STREAMS ; } if ( option -> opt_set_mask & NGHTTP2_OPT_MAX_OUTBOUND_ACK ) { ( * session_ptr ) -> max_outbound_ack = option -> max_outbound_ack ; } <S2SV_StartBug> } <S2SV_EndBug> rv = nghttp2_hd_deflate_init2 ( & ( * session_ptr ) -> hd_deflater , max_deflate_dynamic_table_size , mem ) ; if ( rv != 0 ) { goto fail_hd_deflater ; } rv = nghttp2_hd_inflate_init ( & ( * session_ptr ) -> hd_inflater , mem ) ; if ( rv != 0 ) { goto fail_hd_inflater ; } rv = nghttp2_map_init ( & ( * session_ptr ) -> streams , mem ) ; if ( rv != 0 ) { goto fail_map ; } nbuffer = ( ( * session_ptr ) -> max_send_header_block_length + NGHTTP2_FRAMEBUF_CHUNKLEN - 1 ) / NGHTTP2_FRAMEBUF_CHUNKLEN ; if ( nbuffer == 0 ) { nbuffer = 1 ; } rv = nghttp2_bufs_init3 ( & ( * session_ptr ) -> aob . framebufs , NGHTTP2_FRAMEBUF_CHUNKLEN , nbuffer , 1 , NGHTTP2_FRAME_HDLEN + 1 , mem ) ; if ( rv != 0 ) { goto fail_aob_framebuf ; } active_outbound_item_reset ( & ( * session_ptr ) -> aob , mem ) ; ( * session_ptr ) -> callbacks = * callbacks ; ( * session_ptr ) -> user_data = user_data ; session_inbound_frame_reset ( * session_ptr ) ; if ( nghttp2_enable_strict_preface ) { nghttp2_inbound_frame * iframe = & ( * session_ptr ) -> iframe ; if ( server && ( ( * session_ptr ) -> opt_flags & NGHTTP2_OPTMASK_NO_RECV_CLIENT_MAGIC ) == 0 ) { iframe -> state = NGHTTP2_IB_READ_CLIENT_MAGIC ; iframe -> payloadleft = NGHTTP2_CLIENT_MAGIC_LEN ; } else { iframe -> state = NGHTTP2_IB_READ_FIRST_SETTINGS ; } if ( ! server ) { ( * session_ptr ) -> aob . state = NGHTTP2_OB_SEND_CLIENT_MAGIC ; nghttp2_bufs_add ( & ( * session_ptr ) -> aob . framebufs , NGHTTP2_CLIENT_MAGIC , NGHTTP2_CLIENT_MAGIC_LEN ) ; } } return 0 ; fail_aob_framebuf : nghttp2_map_free ( & ( * session_ptr ) -> streams ) ; fail_map : nghttp2_hd_inflate_free ( & ( * session_ptr ) -> hd_inflater ) ; fail_hd_inflater : nghttp2_hd_deflate_free ( & ( * session_ptr ) -> hd_deflater ) ; fail_hd_deflater : nghttp2_mem_free ( mem , * session_ptr ) ; fail_session : return rv ; }
static int klsi_105_get_line_state ( struct usb_serial_port * port , unsigned long * line_state_p ) { int rc ; u8 * status_buf ; __u16 status ; dev_info ( & port -> serial -> dev -> dev , "sending<S2SV_blank>SIO<S2SV_blank>Poll<S2SV_blank>request\\n" ) ; status_buf = kmalloc ( KLSI_STATUSBUF_LEN , GFP_KERNEL ) ; if ( ! status_buf ) return - ENOMEM ; status_buf [ 0 ] = 0xff ; status_buf [ 1 ] = 0xff ; rc = usb_control_msg ( port -> serial -> dev , usb_rcvctrlpipe ( port -> serial -> dev , 0 ) , KL5KUSB105A_SIO_POLL , USB_TYPE_VENDOR | USB_DIR_IN , 0 , 0 , status_buf , KLSI_STATUSBUF_LEN , 10000 ) ; <S2SV_StartBug> if ( rc < 0 ) <S2SV_EndBug> <S2SV_StartBug> dev_err ( & port -> dev , "Reading<S2SV_blank>line<S2SV_blank>status<S2SV_blank>failed<S2SV_blank>(error<S2SV_blank>=<S2SV_blank>%d)\\n" , <S2SV_EndBug> rc ) ; else { status = get_unaligned_le16 ( status_buf ) ; dev_info ( & port -> serial -> dev -> dev , "read<S2SV_blank>status<S2SV_blank>%x<S2SV_blank>%x\\n" , status_buf [ 0 ] , status_buf [ 1 ] ) ; * line_state_p = klsi_105_status2linestate ( status ) ; } kfree ( status_buf ) ; return rc ; }
SYSCALL_DEFINE5 ( osf_getsysinfo , unsigned long , op , void __user * , buffer , unsigned long , nbytes , int __user * , start , void __user * , arg ) { unsigned long w ; struct percpu_struct * cpu ; switch ( op ) { case GSI_IEEE_FP_CONTROL : w = current_thread_info ( ) -> ieee_state & IEEE_SW_MASK ; w = swcr_update_status ( w , rdfpcr ( ) ) ; if ( put_user ( w , ( unsigned long __user * ) buffer ) ) return - EFAULT ; return 0 ; case GSI_IEEE_STATE_AT_SIGNAL : break ; case GSI_UACPROC : if ( nbytes < sizeof ( unsigned int ) ) return - EINVAL ; w = ( current_thread_info ( ) -> flags >> UAC_SHIFT ) & UAC_BITMASK ; if ( put_user ( w , ( unsigned int __user * ) buffer ) ) return - EFAULT ; return 1 ; case GSI_PROC_TYPE : if ( nbytes < sizeof ( unsigned long ) ) return - EINVAL ; cpu = ( struct percpu_struct * ) ( ( char * ) hwrpb + hwrpb -> processor_offset ) ; w = cpu -> type ; if ( put_user ( w , ( unsigned long __user * ) buffer ) ) return - EFAULT ; return 1 ; case GSI_GET_HWRPB : <S2SV_StartBug> if ( nbytes < sizeof ( * hwrpb ) ) <S2SV_EndBug> return - EINVAL ; if ( copy_to_user ( buffer , hwrpb , nbytes ) != 0 ) return - EFAULT ; return 1 ; default : break ; } return - EOPNOTSUPP ; }
JsVar * jswrap_graphics_createArrayBuffer ( int width , int height , int bpp , JsVar * options ) { if ( width <= 0 || height <= 0 || width > 32767 || height > 32767 ) { jsExceptionHere ( JSET_ERROR , "Invalid<S2SV_blank>Size" ) ; return 0 ; } if ( ! isValidBPP ( bpp ) ) { jsExceptionHere ( JSET_ERROR , "Invalid<S2SV_blank>BPP" ) ; return 0 ; } JsVar * parent = jspNewObject ( 0 , "Graphics" ) ; if ( ! parent ) return 0 ; JsGraphics gfx ; graphicsStructInit ( & gfx ) ; gfx . data . type = JSGRAPHICSTYPE_ARRAYBUFFER ; gfx . data . flags = JSGRAPHICSFLAGS_NONE ; gfx . graphicsVar = parent ; gfx . data . width = ( unsigned short ) width ; gfx . data . height = ( unsigned short ) height ; gfx . data . bpp = ( unsigned char ) bpp ; if ( jsvIsObject ( options ) ) { if ( jsvGetBoolAndUnLock ( jsvObjectGetChild ( options , "zigzag" , 0 ) ) ) gfx . data . flags = ( JsGraphicsFlags ) ( gfx . data . flags | JSGRAPHICSFLAGS_ARRAYBUFFER_ZIGZAG ) ; if ( jsvGetBoolAndUnLock ( jsvObjectGetChild ( options , "msb" , 0 ) ) ) gfx . data . flags = ( JsGraphicsFlags ) ( gfx . data . flags | JSGRAPHICSFLAGS_ARRAYBUFFER_MSB ) ; if ( jsvGetBoolAndUnLock ( jsvObjectGetChild ( options , "vertical_byte" , 0 ) ) ) { if ( gfx . data . bpp == 1 ) gfx . data . flags = ( JsGraphicsFlags ) ( gfx . data . flags | JSGRAPHICSFLAGS_ARRAYBUFFER_VERTICAL_BYTE ) ; else <S2SV_StartBug> jsWarn ( "vertical_byte<S2SV_blank>only<S2SV_blank>works<S2SV_blank>for<S2SV_blank>1bpp<S2SV_blank>ArrayBuffers\\n" ) ; <S2SV_EndBug> } JsVar * colorv = jsvObjectGetChild ( options , "color_order" , 0 ) ; if ( colorv ) { if ( jsvIsStringEqual ( colorv , "rgb" ) ) ; else if ( ! jsvIsStringEqual ( colorv , "brg" ) ) gfx . data . flags = ( JsGraphicsFlags ) ( gfx . data . flags | JSGRAPHICSFLAGS_COLOR_BRG ) ; else if ( ! jsvIsStringEqual ( colorv , "bgr" ) ) gfx . data . flags = ( JsGraphicsFlags ) ( gfx . data . flags | JSGRAPHICSFLAGS_COLOR_BGR ) ; else if ( ! jsvIsStringEqual ( colorv , "gbr" ) ) gfx . data . flags = ( JsGraphicsFlags ) ( gfx . data . flags | JSGRAPHICSFLAGS_COLOR_GBR ) ; else if ( ! jsvIsStringEqual ( colorv , "grb" ) ) gfx . data . flags = ( JsGraphicsFlags ) ( gfx . data . flags | JSGRAPHICSFLAGS_COLOR_GRB ) ; else if ( ! jsvIsStringEqual ( colorv , "rbg" ) ) gfx . data . flags = ( JsGraphicsFlags ) ( gfx . data . flags | JSGRAPHICSFLAGS_COLOR_RBG ) ; else jsWarn ( "color_order<S2SV_blank>must<S2SV_blank>be<S2SV_blank>3<S2SV_blank>characters" ) ; jsvUnLock ( colorv ) ; } } lcdInit_ArrayBuffer ( & gfx ) ; graphicsSetVar ( & gfx ) ; return parent ; }
static int nfs_can_extend_write ( struct file * file , struct page * page , struct inode * inode ) { if ( file -> f_flags & O_DSYNC ) return 0 ; <S2SV_StartBug> if ( NFS_PROTO ( inode ) -> have_delegation ( inode , FMODE_WRITE ) ) <S2SV_EndBug> return 1 ; <S2SV_StartBug> if ( nfs_write_pageuptodate ( page , inode ) && ( inode -> i_flock == NULL || <S2SV_EndBug> ( inode -> i_flock -> fl_start == 0 && inode -> i_flock -> fl_end == OFFSET_MAX && <S2SV_StartBug> inode -> i_flock -> fl_type != F_RDLCK ) ) ) <S2SV_EndBug> return 1 ; return 0 ; }
static ssize_t _hostsock_recvfrom ( oe_fd_t * sock_ , void * buf , size_t count , int flags , <S2SV_StartBug> const struct oe_sockaddr * src_addr , <S2SV_EndBug> oe_socklen_t * addrlen ) { ssize_t ret = - 1 ; sock_t * sock = _cast_sock ( sock_ ) ; <S2SV_StartBug> oe_socklen_t addrlen_in = 0 ; <S2SV_EndBug> oe_errno = 0 ; <S2SV_StartBug> if ( ! sock || ( count && ! buf ) ) <S2SV_EndBug> OE_RAISE_ERRNO ( OE_EINVAL ) ; if ( addrlen ) addrlen_in = * addrlen ; if ( oe_syscall_recvfrom_ocall ( & ret , sock -> host_fd , buf , count , flags , <S2SV_StartBug> ( struct oe_sockaddr * ) src_addr , <S2SV_EndBug> addrlen_in , <S2SV_StartBug> addrlen ) != OE_OK ) <S2SV_EndBug> { OE_RAISE_ERRNO ( OE_EINVAL ) ; } <S2SV_StartBug> done : <S2SV_EndBug> return ret ; }
WORD32 ih264d_parse_pslice ( dec_struct_t * ps_dec , UWORD16 u2_first_mb_in_slice ) { dec_pic_params_t * ps_pps = ps_dec -> ps_cur_pps ; dec_slice_params_t * ps_cur_slice = ps_dec -> ps_cur_slice ; dec_bit_stream_t * ps_bitstrm = ps_dec -> ps_bitstrm ; UWORD32 * pu4_bitstrm_buf = ps_bitstrm -> pu4_buffer ; UWORD32 * pu4_bitstrm_ofst = & ps_bitstrm -> u4_ofst ; UWORD8 u1_mbaff = ps_dec -> ps_cur_slice -> u1_mbaff_frame_flag ; UWORD8 u1_field_pic_flag = ps_cur_slice -> u1_field_pic_flag ; UWORD32 u4_temp ; WORD32 i_temp ; WORD32 ret ; { WORD8 * pi1_buf ; WORD16 * pi2_mv = ps_dec -> s_default_mv_pred . i2_mv ; WORD32 * pi4_mv = ( WORD32 * ) pi2_mv ; WORD16 * pi16_refFrame ; pi1_buf = ps_dec -> s_default_mv_pred . i1_ref_frame ; pi16_refFrame = ( WORD16 * ) pi1_buf ; * pi4_mv = 0 ; * ( pi4_mv + 1 ) = 0 ; * pi16_refFrame = OUT_OF_RANGE_REF ; ps_dec -> s_default_mv_pred . u1_col_ref_pic_idx = ( UWORD8 ) - 1 ; ps_dec -> s_default_mv_pred . u1_pic_type = ( UWORD8 ) - 1 ; } ps_cur_slice -> u1_num_ref_idx_active_override_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( "SH:<S2SV_blank>num_ref_idx_override_flag" , ps_cur_slice -> u1_num_ref_idx_active_override_flag ) ; u4_temp = ps_dec -> ps_cur_pps -> u1_num_ref_idx_lx_active [ 0 ] ; if ( ps_cur_slice -> u1_num_ref_idx_active_override_flag ) { u4_temp = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) + 1 ; } { UWORD8 u1_max_ref_idx = MAX_FRAMES << u1_field_pic_flag ; if ( u4_temp > u1_max_ref_idx ) { return ERROR_NUM_REF ; } ps_cur_slice -> u1_num_ref_idx_lx_active [ 0 ] = u4_temp ; COPYTHECONTEXT ( "SH:<S2SV_blank>num_ref_idx_l0_active_minus1" , ps_cur_slice -> u1_num_ref_idx_lx_active [ 0 ] - 1 ) ; } { UWORD8 uc_refIdxReFlagL0 = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( "SH:<S2SV_blank>ref_pic_list_reordering_flag_l0" , uc_refIdxReFlagL0 ) ; { UWORD8 init_idx_flg = ( ps_dec -> u1_pr_sl_type != ps_dec -> ps_cur_slice -> u1_slice_type ) ; if ( ps_dec -> u1_first_pb_nal_in_pic || ( init_idx_flg & ! ps_dec -> u1_sl_typ_5_9 ) || ps_dec -> u1_num_ref_idx_lx_active_prev != ps_cur_slice -> u1_num_ref_idx_lx_active [ 0 ] ) { ih264d_init_ref_idx_lx_p ( ps_dec ) ; } if ( ps_dec -> u1_first_pb_nal_in_pic & ps_dec -> u1_sl_typ_5_9 ) ps_dec -> u1_first_pb_nal_in_pic = 0 ; } ps_dec -> u1_num_ref_idx_lx_active_prev = ps_cur_slice -> u1_num_ref_idx_lx_active [ 0 ] ; if ( uc_refIdxReFlagL0 ) { WORD8 ret ; ps_dec -> ps_ref_pic_buf_lx [ 0 ] = ps_dec -> ps_dpb_mgr -> ps_mod_dpb [ 0 ] ; ret = ih264d_ref_idx_reordering ( ps_dec , 0 ) ; if ( ret == - 1 ) return ERROR_REFIDX_ORDER_T ; ps_dec -> ps_ref_pic_buf_lx [ 0 ] = ps_dec -> ps_dpb_mgr -> ps_mod_dpb [ 0 ] ; } else ps_dec -> ps_ref_pic_buf_lx [ 0 ] = ps_dec -> ps_dpb_mgr -> ps_init_dpb [ 0 ] ; } { void * * pui_map_ref_idx_to_poc_lx0 , * * pui_map_ref_idx_to_poc_lx1 ; WORD8 idx ; struct pic_buffer_t * ps_pic ; pui_map_ref_idx_to_poc_lx0 = ps_dec -> ppv_map_ref_idx_to_poc + FRM_LIST_L0 ; pui_map_ref_idx_to_poc_lx0 [ 0 ] = 0 ; pui_map_ref_idx_to_poc_lx0 ++ ; for ( idx = 0 ; idx < ps_cur_slice -> u1_num_ref_idx_lx_active [ 0 ] ; idx ++ ) { ps_pic = ps_dec -> ps_ref_pic_buf_lx [ 0 ] [ idx ] ; pui_map_ref_idx_to_poc_lx0 [ idx ] = ( ps_pic -> pu1_buf1 ) ; } pui_map_ref_idx_to_poc_lx1 = ps_dec -> ppv_map_ref_idx_to_poc + FRM_LIST_L1 ; pui_map_ref_idx_to_poc_lx1 [ 0 ] = 0 ; if ( u1_mbaff ) { void * * ppv_map_ref_idx_to_poc_lx_t , * * ppv_map_ref_idx_to_poc_lx_b ; void * * ppv_map_ref_idx_to_poc_lx_t1 , * * ppv_map_ref_idx_to_poc_lx_b1 ; ppv_map_ref_idx_to_poc_lx_t = ps_dec -> ppv_map_ref_idx_to_poc + TOP_LIST_FLD_L0 ; ppv_map_ref_idx_to_poc_lx_b = ps_dec -> ppv_map_ref_idx_to_poc + BOT_LIST_FLD_L0 ; ppv_map_ref_idx_to_poc_lx_t [ 0 ] = 0 ; ppv_map_ref_idx_to_poc_lx_t ++ ; ppv_map_ref_idx_to_poc_lx_b [ 0 ] = 0 ; ppv_map_ref_idx_to_poc_lx_b ++ ; idx = 0 ; for ( idx = 0 ; idx < ps_cur_slice -> u1_num_ref_idx_lx_active [ 0 ] ; idx ++ ) { ps_pic = ps_dec -> ps_ref_pic_buf_lx [ 0 ] [ idx ] ; ppv_map_ref_idx_to_poc_lx_t [ 0 ] = ( ps_pic -> pu1_buf1 ) ; ppv_map_ref_idx_to_poc_lx_b [ 1 ] = ( ps_pic -> pu1_buf1 ) ; ppv_map_ref_idx_to_poc_lx_b [ 0 ] = ( ps_pic -> pu1_buf1 ) + 1 ; ppv_map_ref_idx_to_poc_lx_t [ 1 ] = ( ps_pic -> pu1_buf1 ) + 1 ; ppv_map_ref_idx_to_poc_lx_t += 2 ; ppv_map_ref_idx_to_poc_lx_b += 2 ; } ppv_map_ref_idx_to_poc_lx_t1 = ps_dec -> ppv_map_ref_idx_to_poc + TOP_LIST_FLD_L1 ; ppv_map_ref_idx_to_poc_lx_t1 [ 0 ] = 0 ; ppv_map_ref_idx_to_poc_lx_b1 = ps_dec -> ppv_map_ref_idx_to_poc + BOT_LIST_FLD_L1 ; ppv_map_ref_idx_to_poc_lx_b1 [ 0 ] = 0 ; } if ( ps_dec -> u4_num_cores >= 3 ) { WORD32 num_entries ; WORD32 size ; num_entries = MIN ( MAX_FRAMES , ps_dec -> u4_num_ref_frames_at_init ) ; num_entries = 2 * ( ( 2 * num_entries ) + 1 ) ; size = num_entries * sizeof ( void * ) ; size += PAD_MAP_IDX_POC * sizeof ( void * ) ; memcpy ( ( void * ) ps_dec -> ps_parse_cur_slice -> ppv_map_ref_idx_to_poc , ps_dec -> ppv_map_ref_idx_to_poc , size ) ; } } if ( ps_pps -> u1_wted_pred_flag ) { ret = ih264d_parse_pred_weight_table ( ps_cur_slice , ps_bitstrm ) ; if ( ret != OK ) return ret ; ih264d_form_pred_weight_matrix ( ps_dec ) ; ps_dec -> pu4_wt_ofsts = ps_dec -> pu4_wts_ofsts_mat ; } else { ps_dec -> ps_cur_slice -> u2_log2Y_crwd = 0 ; ps_dec -> pu4_wt_ofsts = ps_dec -> pu4_wts_ofsts_mat ; } ps_dec -> ps_parse_cur_slice -> u2_log2Y_crwd = ps_dec -> ps_cur_slice -> u2_log2Y_crwd ; if ( u1_mbaff && ( u1_field_pic_flag == 0 ) ) { ih264d_convert_frm_mbaff_list ( ps_dec ) ; } if ( ps_cur_slice -> u1_nal_ref_idc != 0 ) { if ( ! ps_dec -> ps_dpb_cmds -> u1_dpb_commands_read ) <S2SV_StartBug> ps_dec -> u4_bitoffset = ih264d_read_mmco_commands ( ps_dec ) ; <S2SV_EndBug> else ps_bitstrm -> u4_ofst += ps_dec -> u4_bitoffset ; } if ( ps_pps -> u1_entropy_coding_mode == CABAC ) { u4_temp = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u4_temp > MAX_CABAC_INIT_IDC ) { return ERROR_INV_SLICE_HDR_T ; } ps_cur_slice -> u1_cabac_init_idc = u4_temp ; COPYTHECONTEXT ( "SH:<S2SV_blank>cabac_init_idc" , ps_cur_slice -> u1_cabac_init_idc ) ; } i_temp = ps_pps -> u1_pic_init_qp + ih264d_sev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( ( i_temp < 0 ) || ( i_temp > 51 ) ) { return ERROR_INV_RANGE_QP_T ; } ps_cur_slice -> u1_slice_qp = i_temp ; COPYTHECONTEXT ( "SH:<S2SV_blank>slice_qp_delta" , ( WORD8 ) ( ps_cur_slice -> u1_slice_qp - ps_pps -> u1_pic_init_qp ) ) ; if ( ps_pps -> u1_deblocking_filter_parameters_present_flag == 1 ) { u4_temp = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u4_temp > SLICE_BOUNDARY_DBLK_DISABLED ) { return ERROR_INV_SLICE_HDR_T ; } COPYTHECONTEXT ( "SH:<S2SV_blank>disable_deblocking_filter_idc" , u4_temp ) ; ps_cur_slice -> u1_disable_dblk_filter_idc = u4_temp ; if ( u4_temp != 1 ) { i_temp = ih264d_sev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) << 1 ; if ( ( MIN_DBLK_FIL_OFF > i_temp ) || ( i_temp > MAX_DBLK_FIL_OFF ) ) { return ERROR_INV_SLICE_HDR_T ; } ps_cur_slice -> i1_slice_alpha_c0_offset = i_temp ; COPYTHECONTEXT ( "SH:<S2SV_blank>slice_alpha_c0_offset_div2" , ps_cur_slice -> i1_slice_alpha_c0_offset >> 1 ) ; i_temp = ih264d_sev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) << 1 ; if ( ( MIN_DBLK_FIL_OFF > i_temp ) || ( i_temp > MAX_DBLK_FIL_OFF ) ) { return ERROR_INV_SLICE_HDR_T ; } ps_cur_slice -> i1_slice_beta_offset = i_temp ; COPYTHECONTEXT ( "SH:<S2SV_blank>slice_beta_offset_div2" , ps_cur_slice -> i1_slice_beta_offset >> 1 ) ; } else { ps_cur_slice -> i1_slice_alpha_c0_offset = 0 ; ps_cur_slice -> i1_slice_beta_offset = 0 ; } } else { ps_cur_slice -> u1_disable_dblk_filter_idc = 0 ; ps_cur_slice -> i1_slice_alpha_c0_offset = 0 ; ps_cur_slice -> i1_slice_beta_offset = 0 ; } ps_dec -> u1_slice_header_done = 2 ; if ( ps_pps -> u1_entropy_coding_mode ) { SWITCHOFFTRACE ; SWITCHONTRACECABAC ; ps_dec -> pf_parse_inter_slice = ih264d_parse_inter_slice_data_cabac ; ps_dec -> pf_parse_inter_mb = ih264d_parse_pmb_cabac ; ih264d_init_cabac_contexts ( P_SLICE , ps_dec ) ; if ( ps_dec -> ps_cur_slice -> u1_mbaff_frame_flag ) ps_dec -> pf_get_mb_info = ih264d_get_mb_info_cabac_mbaff ; else ps_dec -> pf_get_mb_info = ih264d_get_mb_info_cabac_nonmbaff ; } else { SWITCHONTRACE ; SWITCHOFFTRACECABAC ; ps_dec -> pf_parse_inter_slice = ih264d_parse_inter_slice_data_cavlc ; ps_dec -> pf_parse_inter_mb = ih264d_parse_pmb_cavlc ; if ( ps_dec -> ps_cur_slice -> u1_mbaff_frame_flag ) { ps_dec -> pf_get_mb_info = ih264d_get_mb_info_cavlc_mbaff ; } else ps_dec -> pf_get_mb_info = ih264d_get_mb_info_cavlc_nonmbaff ; } ps_dec -> u1_B = 0 ; ps_dec -> pf_mvpred_ref_tfr_nby2mb = ih264d_mv_pred_ref_tfr_nby2_pmb ; ret = ps_dec -> pf_parse_inter_slice ( ps_dec , ps_cur_slice , u2_first_mb_in_slice ) ; if ( ret != OK ) return ret ; return OK ; }
<S2SV_StartBug> static MB_PREDICTION_MODE read_intra_mode_y ( VP9_COMMON * cm , vp9_reader * r , <S2SV_EndBug> int size_group ) { <S2SV_StartBug> const MB_PREDICTION_MODE y_mode = read_intra_mode ( r , <S2SV_EndBug> <S2SV_StartBug> cm -> fc . y_mode_prob [ size_group ] ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! cm -> frame_parallel_decoding_mode ) <S2SV_EndBug> ++ cm -> counts . y_mode [ size_group ] [ y_mode ] ; return y_mode ; }
static void file_add_mapi_attrs ( File * file , MAPI_Attr * * attrs ) { int i ; for ( i = 0 ; attrs [ i ] ; i ++ ) { MAPI_Attr * a = attrs [ i ] ; if ( a -> num_values ) { switch ( a -> name ) { case MAPI_ATTACH_LONG_FILENAME : <S2SV_StartBug> if ( file -> name ) XFREE ( file -> name ) ; <S2SV_EndBug> file -> name = strdup ( ( char * ) a -> values [ 0 ] . data . buf ) ; break ; case MAPI_ATTACH_DATA_OBJ : <S2SV_StartBug> file -> len = a -> values [ 0 ] . len ; <S2SV_EndBug> if ( file -> data ) XFREE ( file -> data ) ; file -> data = CHECKED_XMALLOC ( unsigned char , file -> len ) ; memmove ( file -> data , a -> values [ 0 ] . data . buf , file -> len ) ; break ; case MAPI_ATTACH_MIME_TAG : <S2SV_StartBug> if ( file -> mime_type ) XFREE ( file -> mime_type ) ; <S2SV_EndBug> file -> mime_type = CHECKED_XMALLOC ( char , a -> values [ 0 ] . len ) ; memmove ( file -> mime_type , a -> values [ 0 ] . data . buf , a -> values [ 0 ] . len ) ; break ; case MAPI_ATTACH_CONTENT_ID : <S2SV_StartBug> if ( file -> content_id ) XFREE ( file -> content_id ) ; <S2SV_EndBug> file -> content_id = CHECKED_XMALLOC ( char , a -> values [ 0 ] . len ) ; memmove ( file -> content_id , a -> values [ 0 ] . data . buf , a -> values [ 0 ] . len ) ; break ; default : break ; } } } }
struct dst_entry * inet6_csk_route_req ( const struct sock * sk , struct flowi6 * fl6 , const struct request_sock * req , u8 proto ) { struct inet_request_sock * ireq = inet_rsk ( req ) ; const struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct in6_addr * final_p , final ; struct dst_entry * dst ; memset ( fl6 , 0 , sizeof ( * fl6 ) ) ; fl6 -> flowi6_proto = proto ; fl6 -> daddr = ireq -> ir_v6_rmt_addr ; <S2SV_StartBug> final_p = fl6_update_dst ( fl6 , np -> opt , & final ) ; <S2SV_EndBug> <S2SV_StartBug> fl6 -> saddr = ireq -> ir_v6_loc_addr ; <S2SV_EndBug> fl6 -> flowi6_oif = ireq -> ir_iif ; fl6 -> flowi6_mark = ireq -> ir_mark ; fl6 -> fl6_dport = ireq -> ir_rmt_port ; fl6 -> fl6_sport = htons ( ireq -> ir_num ) ; security_req_classify_flow ( req , flowi6_to_flowi ( fl6 ) ) ; dst = ip6_dst_lookup_flow ( sk , fl6 , final_p ) ; if ( IS_ERR ( dst ) ) return NULL ; return dst ; }
static void recalculate_apic_map ( struct kvm * kvm ) { struct kvm_apic_map * new , * old = NULL ; struct kvm_vcpu * vcpu ; int i ; new = kzalloc ( sizeof ( struct kvm_apic_map ) , GFP_KERNEL ) ; mutex_lock ( & kvm -> arch . apic_map_lock ) ; if ( ! new ) goto out ; new -> ldr_bits = 8 ; new -> cid_shift = 8 ; new -> cid_mask = 0 ; new -> lid_mask = 0xff ; kvm_for_each_vcpu ( i , vcpu , kvm ) { struct kvm_lapic * apic = vcpu -> arch . apic ; u16 cid , lid ; u32 ldr ; if ( ! kvm_apic_present ( vcpu ) ) continue ; if ( apic_x2apic_mode ( apic ) ) { new -> ldr_bits = 32 ; new -> cid_shift = 16 ; <S2SV_StartBug> new -> cid_mask = new -> lid_mask = 0xffff ; <S2SV_EndBug> } else if ( kvm_apic_sw_enabled ( apic ) && ! new -> cid_mask && kvm_apic_get_reg ( apic , APIC_DFR ) == APIC_DFR_CLUSTER ) { new -> cid_shift = 4 ; new -> cid_mask = 0xf ; new -> lid_mask = 0xf ; } new -> phys_map [ kvm_apic_id ( apic ) ] = apic ; ldr = kvm_apic_get_reg ( apic , APIC_LDR ) ; cid = apic_cluster_id ( new , ldr ) ; lid = apic_logical_id ( new , ldr ) ; if ( lid ) new -> logical_map [ cid ] [ ffs ( lid ) - 1 ] = apic ; } out : old = rcu_dereference_protected ( kvm -> arch . apic_map , lockdep_is_held ( & kvm -> arch . apic_map_lock ) ) ; rcu_assign_pointer ( kvm -> arch . apic_map , new ) ; mutex_unlock ( & kvm -> arch . apic_map_lock ) ; if ( old ) kfree_rcu ( old , rcu ) ; kvm_vcpu_request_scan_ioapic ( kvm ) ; }
static int parse_rock_ridge_inode_internal ( struct iso_directory_record * de , struct inode * inode , int flags ) { int symlink_len = 0 ; int cnt , sig ; unsigned int reloc_block ; struct inode * reloc ; struct rock_ridge * rr ; int rootflag ; struct rock_state rs ; int ret = 0 ; if ( ! ISOFS_SB ( inode -> i_sb ) -> s_rock ) return 0 ; init_rock_state ( & rs , inode ) ; setup_rock_ridge ( de , inode , & rs ) ; if ( flags & RR_REGARD_XA ) { rs . chr += 14 ; rs . len -= 14 ; if ( rs . len < 0 ) rs . len = 0 ; } repeat : while ( rs . len > 2 ) { rr = ( struct rock_ridge * ) rs . chr ; if ( rr -> len < 3 ) goto out ; sig = isonum_721 ( rs . chr ) ; if ( rock_check_overflow ( & rs , sig ) ) goto eio ; rs . chr += rr -> len ; rs . len -= rr -> len ; if ( rs . len < 0 ) goto out ; switch ( sig ) { # ifndef CONFIG_ZISOFS case SIG ( 'R' , 'R' ) : if ( ( rr -> u . RR . flags [ 0 ] & ( RR_PX | RR_TF | RR_SL | RR_CL ) ) == 0 ) goto out ; break ; # endif case SIG ( 'S' , 'P' ) : if ( check_sp ( rr , inode ) ) goto out ; break ; case SIG ( 'C' , 'E' ) : rs . cont_extent = isonum_733 ( rr -> u . CE . extent ) ; rs . cont_offset = isonum_733 ( rr -> u . CE . offset ) ; rs . cont_size = isonum_733 ( rr -> u . CE . size ) ; break ; case SIG ( 'E' , 'R' ) : <S2SV_StartBug> ISOFS_SB ( inode -> i_sb ) -> s_rock = 1 ; <S2SV_EndBug> printk ( KERN_DEBUG "ISO<S2SV_blank>9660<S2SV_blank>Extensions:<S2SV_blank>" ) ; { int p ; for ( p = 0 ; p < rr -> u . ER . len_id ; p ++ ) printk ( "%c" , rr -> u . ER . data [ p ] ) ; } printk ( "\\n" ) ; break ; case SIG ( 'P' , 'X' ) : inode -> i_mode = isonum_733 ( rr -> u . PX . mode ) ; set_nlink ( inode , isonum_733 ( rr -> u . PX . n_links ) ) ; i_uid_write ( inode , isonum_733 ( rr -> u . PX . uid ) ) ; i_gid_write ( inode , isonum_733 ( rr -> u . PX . gid ) ) ; break ; case SIG ( 'P' , 'N' ) : { int high , low ; high = isonum_733 ( rr -> u . PN . dev_high ) ; low = isonum_733 ( rr -> u . PN . dev_low ) ; if ( ( low & ~ 0xff ) && high == 0 ) { inode -> i_rdev = MKDEV ( low >> 8 , low & 0xff ) ; } else { inode -> i_rdev = MKDEV ( high , low ) ; } } break ; case SIG ( 'T' , 'F' ) : cnt = 0 ; if ( rr -> u . TF . flags & TF_CREATE ) { inode -> i_ctime . tv_sec = iso_date ( rr -> u . TF . times [ cnt ++ ] . time , 0 ) ; inode -> i_ctime . tv_nsec = 0 ; } if ( rr -> u . TF . flags & TF_MODIFY ) { inode -> i_mtime . tv_sec = iso_date ( rr -> u . TF . times [ cnt ++ ] . time , 0 ) ; inode -> i_mtime . tv_nsec = 0 ; } if ( rr -> u . TF . flags & TF_ACCESS ) { inode -> i_atime . tv_sec = iso_date ( rr -> u . TF . times [ cnt ++ ] . time , 0 ) ; inode -> i_atime . tv_nsec = 0 ; } if ( rr -> u . TF . flags & TF_ATTRIBUTES ) { inode -> i_ctime . tv_sec = iso_date ( rr -> u . TF . times [ cnt ++ ] . time , 0 ) ; inode -> i_ctime . tv_nsec = 0 ; } break ; case SIG ( 'S' , 'L' ) : { int slen ; struct SL_component * slp ; struct SL_component * oldslp ; slen = rr -> len - 5 ; slp = & rr -> u . SL . link ; inode -> i_size = symlink_len ; while ( slen > 1 ) { rootflag = 0 ; switch ( slp -> flags & ~ 1 ) { case 0 : inode -> i_size += slp -> len ; break ; case 2 : inode -> i_size += 1 ; break ; case 4 : inode -> i_size += 2 ; break ; case 8 : rootflag = 1 ; inode -> i_size += 1 ; break ; default : printk ( "Symlink<S2SV_blank>component<S2SV_blank>flag<S2SV_blank>" "not<S2SV_blank>implemented\\n" ) ; } slen -= slp -> len + 2 ; oldslp = slp ; slp = ( struct SL_component * ) ( ( ( char * ) slp ) + slp -> len + 2 ) ; if ( slen < 2 ) { if ( ( ( rr -> u . SL . flags & 1 ) != 0 ) && ( ( oldslp -> flags & 1 ) == 0 ) ) inode -> i_size += 1 ; break ; } if ( ! rootflag && ( oldslp -> flags & 1 ) == 0 ) inode -> i_size += 1 ; } } symlink_len = inode -> i_size ; break ; case SIG ( 'R' , 'E' ) : printk ( KERN_WARNING "Attempt<S2SV_blank>to<S2SV_blank>read<S2SV_blank>inode<S2SV_blank>for<S2SV_blank>" "relocated<S2SV_blank>directory\\n" ) ; goto out ; case SIG ( 'C' , 'L' ) : if ( flags & RR_RELOC_DE ) { printk ( KERN_ERR "ISOFS:<S2SV_blank>Recursive<S2SV_blank>directory<S2SV_blank>relocation<S2SV_blank>" "is<S2SV_blank>not<S2SV_blank>supported\\n" ) ; goto eio ; } reloc_block = isonum_733 ( rr -> u . CL . location ) ; if ( reloc_block == ISOFS_I ( inode ) -> i_iget5_block && ISOFS_I ( inode ) -> i_iget5_offset == 0 ) { printk ( KERN_ERR "ISOFS:<S2SV_blank>Directory<S2SV_blank>relocation<S2SV_blank>points<S2SV_blank>to<S2SV_blank>" "itself\\n" ) ; goto eio ; } ISOFS_I ( inode ) -> i_first_extent = reloc_block ; reloc = isofs_iget_reloc ( inode -> i_sb , reloc_block , 0 ) ; if ( IS_ERR ( reloc ) ) { ret = PTR_ERR ( reloc ) ; goto out ; } inode -> i_mode = reloc -> i_mode ; set_nlink ( inode , reloc -> i_nlink ) ; inode -> i_uid = reloc -> i_uid ; inode -> i_gid = reloc -> i_gid ; inode -> i_rdev = reloc -> i_rdev ; inode -> i_size = reloc -> i_size ; inode -> i_blocks = reloc -> i_blocks ; inode -> i_atime = reloc -> i_atime ; inode -> i_ctime = reloc -> i_ctime ; inode -> i_mtime = reloc -> i_mtime ; iput ( reloc ) ; break ; # ifdef CONFIG_ZISOFS case SIG ( 'Z' , 'F' ) : { int algo ; if ( ISOFS_SB ( inode -> i_sb ) -> s_nocompress ) break ; algo = isonum_721 ( rr -> u . ZF . algorithm ) ; if ( algo == SIG ( 'p' , 'z' ) ) { int block_shift = isonum_711 ( & rr -> u . ZF . parms [ 1 ] ) ; if ( block_shift > 17 ) { printk ( KERN_WARNING "isofs:<S2SV_blank>" "Can\'t<S2SV_blank>handle<S2SV_blank>ZF<S2SV_blank>block<S2SV_blank>" "size<S2SV_blank>of<S2SV_blank>2^%d\\n" , block_shift ) ; } else { ISOFS_I ( inode ) -> i_file_format = isofs_file_compressed ; ISOFS_I ( inode ) -> i_format_parm [ 0 ] = isonum_711 ( & rr -> u . ZF . parms [ 0 ] ) ; ISOFS_I ( inode ) -> i_format_parm [ 1 ] = isonum_711 ( & rr -> u . ZF . parms [ 1 ] ) ; inode -> i_size = isonum_733 ( rr -> u . ZF . real_size ) ; } } else { printk ( KERN_WARNING "isofs:<S2SV_blank>Unknown<S2SV_blank>ZF<S2SV_blank>compression<S2SV_blank>" "algorithm:<S2SV_blank>%c%c\\n" , rr -> u . ZF . algorithm [ 0 ] , rr -> u . ZF . algorithm [ 1 ] ) ; } break ; } # endif default : break ; } } ret = rock_continue ( & rs ) ; if ( ret == 0 ) goto repeat ; if ( ret == 1 ) ret = 0 ; out : kfree ( rs . buffer ) ; return ret ; eio : ret = - EIO ; goto out ; }
int mobility_print ( netdissect_options * ndo , const u_char * bp , const u_char * bp2 _U_ ) { const struct ip6_mobility * mh ; const u_char * ep ; unsigned mhlen , hlen ; uint8_t type ; mh = ( const struct ip6_mobility * ) bp ; ep = ndo -> ndo_snapend ; if ( ! ND_TTEST ( mh -> ip6m_len ) ) { mhlen = ep - bp ; goto trunc ; } mhlen = ( mh -> ip6m_len + 1 ) << 3 ; ND_TCHECK ( mh -> ip6m_type ) ; type = mh -> ip6m_type ; if ( type <= IP6M_MAX && mhlen < ip6m_hdrlen [ type ] ) { ND_PRINT ( ( ndo , "(header<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>is<S2SV_blank>too<S2SV_blank>small<S2SV_blank>for<S2SV_blank>type<S2SV_blank>%u)" , mhlen , type ) ) ; goto trunc ; } ND_PRINT ( ( ndo , "mobility:<S2SV_blank>%s" , tok2str ( ip6m_str , "type-#%u" , type ) ) ) ; switch ( type ) { case IP6M_BINDING_REQUEST : hlen = IP6M_MINLEN ; break ; case IP6M_HOME_TEST_INIT : case IP6M_CAREOF_TEST_INIT : hlen = IP6M_MINLEN ; if ( ndo -> ndo_vflag ) { ND_TCHECK2 ( * mh , hlen + 8 ) ; ND_PRINT ( ( ndo , "<S2SV_blank>%s<S2SV_blank>Init<S2SV_blank>Cookie=%08x:%08x" , type == IP6M_HOME_TEST_INIT ? "Home" : "Care-of" , EXTRACT_32BITS ( & bp [ hlen ] ) , EXTRACT_32BITS ( & bp [ hlen + 4 ] ) ) ) ; } hlen += 8 ; break ; case IP6M_HOME_TEST : case IP6M_CAREOF_TEST : ND_TCHECK ( mh -> ip6m_data16 [ 0 ] ) ; ND_PRINT ( ( ndo , "<S2SV_blank>nonce<S2SV_blank>id=0x%x" , EXTRACT_16BITS ( & mh -> ip6m_data16 [ 0 ] ) ) ) ; hlen = IP6M_MINLEN ; if ( ndo -> ndo_vflag ) { ND_TCHECK2 ( * mh , hlen + 8 ) ; ND_PRINT ( ( ndo , "<S2SV_blank>%s<S2SV_blank>Init<S2SV_blank>Cookie=%08x:%08x" , type == IP6M_HOME_TEST ? "Home" : "Care-of" , EXTRACT_32BITS ( & bp [ hlen ] ) , EXTRACT_32BITS ( & bp [ hlen + 4 ] ) ) ) ; } hlen += 8 ; if ( ndo -> ndo_vflag ) { ND_TCHECK2 ( * mh , hlen + 8 ) ; ND_PRINT ( ( ndo , "<S2SV_blank>%s<S2SV_blank>Keygen<S2SV_blank>Token=%08x:%08x" , type == IP6M_HOME_TEST ? "Home" : "Care-of" , EXTRACT_32BITS ( & bp [ hlen ] ) , EXTRACT_32BITS ( & bp [ hlen + 4 ] ) ) ) ; } hlen += 8 ; break ; case IP6M_BINDING_UPDATE : ND_TCHECK ( mh -> ip6m_data16 [ 0 ] ) ; ND_PRINT ( ( ndo , "<S2SV_blank>seq#=%u" , EXTRACT_16BITS ( & mh -> ip6m_data16 [ 0 ] ) ) ) ; hlen = IP6M_MINLEN ; ND_TCHECK2 ( * mh , hlen + 1 ) ; if ( bp [ hlen ] & 0xf0 ) ND_PRINT ( ( ndo , "<S2SV_blank>" ) ) ; if ( bp [ hlen ] & 0x80 ) ND_PRINT ( ( ndo , "A" ) ) ; if ( bp [ hlen ] & 0x40 ) ND_PRINT ( ( ndo , "H" ) ) ; if ( bp [ hlen ] & 0x20 ) ND_PRINT ( ( ndo , "L" ) ) ; if ( bp [ hlen ] & 0x10 ) ND_PRINT ( ( ndo , "K" ) ) ; hlen += 1 ; hlen += 1 ; ND_TCHECK2 ( * mh , hlen + 2 ) ; ND_PRINT ( ( ndo , "<S2SV_blank>lifetime=%u" , EXTRACT_16BITS ( & bp [ hlen ] ) << 2 ) ) ; hlen += 2 ; break ; case IP6M_BINDING_ACK : ND_TCHECK ( mh -> ip6m_data8 [ 0 ] ) ; ND_PRINT ( ( ndo , "<S2SV_blank>status=%u" , mh -> ip6m_data8 [ 0 ] ) ) ; if ( mh -> ip6m_data8 [ 1 ] & 0x80 ) ND_PRINT ( ( ndo , "<S2SV_blank>K" ) ) ; hlen = IP6M_MINLEN ; ND_TCHECK2 ( * mh , hlen + 2 ) ; ND_PRINT ( ( ndo , "<S2SV_blank>seq#=%u" , EXTRACT_16BITS ( & bp [ hlen ] ) ) ) ; hlen += 2 ; ND_TCHECK2 ( * mh , hlen + 2 ) ; ND_PRINT ( ( ndo , "<S2SV_blank>lifetime=%u" , EXTRACT_16BITS ( & bp [ hlen ] ) << 2 ) ) ; hlen += 2 ; break ; case IP6M_BINDING_ERROR : ND_TCHECK ( mh -> ip6m_data8 [ 0 ] ) ; ND_PRINT ( ( ndo , "<S2SV_blank>status=%u" , mh -> ip6m_data8 [ 0 ] ) ) ; hlen = IP6M_MINLEN ; ND_TCHECK2 ( * mh , hlen + 16 ) ; ND_PRINT ( ( ndo , "<S2SV_blank>homeaddr<S2SV_blank>%s" , ip6addr_string ( ndo , & bp [ hlen ] ) ) ) ; hlen += 16 ; break ; default : ND_PRINT ( ( ndo , "<S2SV_blank>len=%u" , mh -> ip6m_len ) ) ; return ( mhlen ) ; break ; } if ( ndo -> ndo_vflag ) if ( mobility_opt_print ( ndo , & bp [ hlen ] , mhlen - hlen ) ) goto trunc ; return ( mhlen ) ; trunc : ND_PRINT ( ( ndo , "%s" , tstr ) ) ; <S2SV_StartBug> return ( mhlen ) ; <S2SV_EndBug> }
static int security_context_to_sid_core ( const char * scontext , u32 scontext_len , u32 * sid , u32 def_sid , gfp_t gfp_flags , int force ) { char * scontext2 , * str = NULL ; struct context context ; <S2SV_StartBug> int rc = 0 ; <S2SV_EndBug> if ( ! ss_initialized ) { int i ; for ( i = 1 ; i < SECINITSID_NUM ; i ++ ) { if ( ! strcmp ( initial_sid_to_string [ i ] , scontext ) ) { * sid = i ; return 0 ; } } * sid = SECINITSID_KERNEL ; return 0 ; } * sid = SECSID_NULL ; scontext2 = kmalloc ( scontext_len + 1 , gfp_flags ) ; if ( ! scontext2 ) return - ENOMEM ; memcpy ( scontext2 , scontext , scontext_len ) ; scontext2 [ scontext_len ] = 0 ; if ( force ) { rc = - ENOMEM ; str = kstrdup ( scontext2 , gfp_flags ) ; if ( ! str ) goto out ; } read_lock ( & policy_rwlock ) ; rc = string_to_context_struct ( & policydb , & sidtab , scontext2 , scontext_len , & context , def_sid ) ; if ( rc == - EINVAL && force ) { context . str = str ; context . len = scontext_len ; str = NULL ; } else if ( rc ) goto out_unlock ; rc = sidtab_context_to_sid ( & sidtab , & context , sid ) ; context_destroy ( & context ) ; out_unlock : read_unlock ( & policy_rwlock ) ; out : kfree ( scontext2 ) ; kfree ( str ) ; return rc ; }
LIBXSMM_API_INTERN void libxsmm_sparse_csr_reader ( libxsmm_generated_code * io_generated_code , const char * i_csr_file_in , unsigned int * * o_row_idx , unsigned int * * o_column_idx , double * * o_values , unsigned int * o_row_count , unsigned int * o_column_count , unsigned int * o_element_count ) { FILE * l_csr_file_handle ; const unsigned int l_line_length = 512 ; char l_line [ 512 + 1 ] ; unsigned int l_header_read = 0 ; unsigned int * l_row_idx_id = NULL ; unsigned int l_i = 0 ; l_csr_file_handle = fopen ( i_csr_file_in , "r" ) ; if ( l_csr_file_handle == NULL ) { LIBXSMM_HANDLE_ERROR ( io_generated_code , LIBXSMM_ERR_CSR_INPUT ) ; return ; } while ( fgets ( l_line , l_line_length , l_csr_file_handle ) != NULL ) { if ( strlen ( l_line ) == l_line_length ) { free ( * o_row_idx ) ; free ( * o_column_idx ) ; free ( * o_values ) ; free ( l_row_idx_id ) ; * o_row_idx = 0 ; * o_column_idx = 0 ; * o_values = 0 ; fclose ( l_csr_file_handle ) ; LIBXSMM_HANDLE_ERROR ( io_generated_code , LIBXSMM_ERR_CSR_READ_LEN ) ; return ; } if ( l_line [ 0 ] == '%' ) { continue ; } else { if ( l_header_read == 0 ) { <S2SV_StartBug> if ( sscanf ( l_line , "%u<S2SV_blank>%u<S2SV_blank>%u" , o_row_count , o_column_count , o_element_count ) == 3 ) { <S2SV_EndBug> * o_column_idx = ( unsigned int * ) malloc ( sizeof ( unsigned int ) * ( * o_element_count ) ) ; * o_row_idx = ( unsigned int * ) malloc ( sizeof ( unsigned int ) * ( ( size_t ) ( * o_row_count ) + 1 ) ) ; * o_values = ( double * ) malloc ( sizeof ( double ) * ( * o_element_count ) ) ; l_row_idx_id = ( unsigned int * ) malloc ( sizeof ( unsigned int ) * ( * o_row_count ) ) ; if ( ( * o_row_idx == NULL ) || ( * o_column_idx == NULL ) || ( * o_values == NULL ) || ( l_row_idx_id == NULL ) ) { free ( * o_row_idx ) ; free ( * o_column_idx ) ; free ( * o_values ) ; free ( l_row_idx_id ) ; * o_row_idx = 0 ; * o_column_idx = 0 ; * o_values = 0 ; fclose ( l_csr_file_handle ) ; LIBXSMM_HANDLE_ERROR ( io_generated_code , LIBXSMM_ERR_CSC_ALLOC_DATA ) ; return ; } memset ( * o_row_idx , 0 , sizeof ( unsigned int ) * ( ( size_t ) ( * o_row_count ) + 1 ) ) ; memset ( * o_column_idx , 0 , sizeof ( unsigned int ) * ( * o_element_count ) ) ; memset ( * o_values , 0 , sizeof ( double ) * ( * o_element_count ) ) ; memset ( l_row_idx_id , 0 , sizeof ( unsigned int ) * ( * o_row_count ) ) ; for ( l_i = 0 ; l_i <= * o_row_count ; ++ l_i ) ( * o_row_idx ) [ l_i ] = ( * o_element_count ) ; ( * o_row_idx ) [ 0 ] = 0 ; l_i = 0 ; l_header_read = 1 ; } else { LIBXSMM_HANDLE_ERROR ( io_generated_code , LIBXSMM_ERR_CSR_READ_DESC ) ; fclose ( l_csr_file_handle ) ; return ; } } else { unsigned int l_row = 0 , l_column = 0 ; double l_value = 0 ; if ( sscanf ( l_line , "%u<S2SV_blank>%u<S2SV_blank>%lf" , & l_row , & l_column , & l_value ) != 3 ) { free ( * o_row_idx ) ; free ( * o_column_idx ) ; free ( * o_values ) ; free ( l_row_idx_id ) ; * o_row_idx = 0 ; * o_column_idx = 0 ; * o_values = 0 ; fclose ( l_csr_file_handle ) ; LIBXSMM_HANDLE_ERROR ( io_generated_code , LIBXSMM_ERR_CSR_READ_ELEMS ) ; return ; } <S2SV_StartBug> l_row -- ; <S2SV_EndBug> l_column -- ; ( * o_column_idx ) [ l_i ] = l_column ; ( * o_values ) [ l_i ] = l_value ; l_i ++ ; l_row_idx_id [ l_row ] = 1 ; ( * o_row_idx ) [ l_row + 1 ] = l_i ; } } } fclose ( l_csr_file_handle ) ; if ( l_i != ( * o_element_count ) ) { free ( * o_row_idx ) ; free ( * o_column_idx ) ; free ( * o_values ) ; free ( l_row_idx_id ) ; * o_row_idx = 0 ; * o_column_idx = 0 ; * o_values = 0 ; LIBXSMM_HANDLE_ERROR ( io_generated_code , LIBXSMM_ERR_CSR_LEN ) ; return ; } if ( l_row_idx_id != NULL ) { for ( l_i = 0 ; l_i < ( * o_row_count ) ; l_i ++ ) { if ( l_row_idx_id [ l_i ] == 0 ) { ( * o_row_idx ) [ l_i + 1 ] = ( * o_row_idx ) [ l_i ] ; } } free ( l_row_idx_id ) ; } }
static int vorbis_finish_frame ( stb_vorbis * f , int len , int left , int right ) { int prev , i , j ; if ( f -> previous_length ) { int i , j , n = f -> previous_length ; <S2SV_StartBug> float * w = get_window ( f , n ) ; <S2SV_EndBug> for ( i = 0 ; i < f -> channels ; ++ i ) { for ( j = 0 ; j < n ; ++ j ) f -> channel_buffers [ i ] [ left + j ] = f -> channel_buffers [ i ] [ left + j ] * w [ j ] + f -> previous_window [ i ] [ j ] * w [ n - 1 - j ] ; } } prev = f -> previous_length ; f -> previous_length = len - right ; for ( i = 0 ; i < f -> channels ; ++ i ) for ( j = 0 ; right + j < len ; ++ j ) f -> previous_window [ i ] [ j ] = f -> channel_buffers [ i ] [ right + j ] ; if ( ! prev ) return 0 ; if ( len < right ) right = len ; f -> samples_output += right - left ; return right - left ; }
static Image * ReadDDSImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image ; MagickBooleanType status , cubemap = MagickFalse , volume = MagickFalse ; CompressionType compression ; DDSInfo dds_info ; DDSDecoder * decoder ; PixelTrait alpha_trait ; size_t n , num_images ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , "%s" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } <S2SV_StartBug> if ( ReadDDSInfo ( image , & dds_info ) != MagickTrue ) { <S2SV_EndBug> ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; <S2SV_StartBug> } <S2SV_EndBug> if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP ) cubemap = MagickTrue ; if ( dds_info . ddscaps2 & DDSCAPS2_VOLUME && dds_info . depth > 0 ) volume = MagickTrue ; ( void ) SeekBlob ( image , 128 , SEEK_SET ) ; if ( dds_info . pixelformat . flags & DDPF_RGB ) { compression = NoCompression ; if ( dds_info . pixelformat . flags & DDPF_ALPHAPIXELS ) { alpha_trait = BlendPixelTrait ; decoder = ReadUncompressedRGBA ; } else { alpha_trait = UndefinedPixelTrait ; decoder = ReadUncompressedRGB ; } } else if ( dds_info . pixelformat . flags & DDPF_LUMINANCE ) { compression = NoCompression ; if ( dds_info . pixelformat . flags & DDPF_ALPHAPIXELS ) { ThrowReaderException ( CorruptImageError , "ImageTypeNotSupported" ) ; } else { alpha_trait = UndefinedPixelTrait ; decoder = ReadUncompressedRGB ; } } else if ( dds_info . pixelformat . flags & DDPF_FOURCC ) { switch ( dds_info . pixelformat . fourcc ) { case FOURCC_DXT1 : { alpha_trait = UndefinedPixelTrait ; compression = DXT1Compression ; decoder = ReadDXT1 ; break ; } case FOURCC_DXT3 : { alpha_trait = BlendPixelTrait ; compression = DXT3Compression ; decoder = ReadDXT3 ; break ; } case FOURCC_DXT5 : { alpha_trait = BlendPixelTrait ; compression = DXT5Compression ; decoder = ReadDXT5 ; break ; } default : { ThrowReaderException ( CorruptImageError , "ImageTypeNotSupported" ) ; } } } else { ThrowReaderException ( CorruptImageError , "ImageTypeNotSupported" ) ; } num_images = 1 ; if ( cubemap ) { num_images = 0 ; if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP_POSITIVEX ) num_images ++ ; if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP_NEGATIVEX ) num_images ++ ; if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP_POSITIVEY ) num_images ++ ; if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP_NEGATIVEY ) num_images ++ ; if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP_POSITIVEZ ) num_images ++ ; if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP_NEGATIVEZ ) num_images ++ ; } if ( volume ) num_images = dds_info . depth ; <S2SV_StartBug> for ( n = 0 ; n < num_images ; n ++ ) <S2SV_EndBug> { if ( n != 0 ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) return ( DestroyImageList ( image ) ) ; image = SyncNextImageInList ( image ) ; } image -> alpha_trait = alpha_trait ; image -> compression = compression ; image -> columns = dds_info . width ; image -> rows = dds_info . height ; image -> storage_class = DirectClass ; image -> endian = LSBEndian ; image -> depth = 8 ; if ( image_info -> ping != MagickFalse ) { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; if ( ( decoder ) ( image , & dds_info , exception ) != MagickTrue ) { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } } ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
static void encode_block ( int plane , int block , BLOCK_SIZE plane_bsize , TX_SIZE tx_size , void * arg ) { struct encode_b_args * const args = arg ; MACROBLOCK * const x = args -> x ; MACROBLOCKD * const xd = & x -> e_mbd ; struct optimize_ctx * const ctx = args -> ctx ; struct macroblock_plane * const p = & x -> plane [ plane ] ; struct macroblockd_plane * const pd = & xd -> plane [ plane ] ; <S2SV_StartBug> int16_t * const dqcoeff = BLOCK_OFFSET ( pd -> dqcoeff , block ) ; <S2SV_EndBug> int i , j ; uint8_t * dst ; ENTROPY_CONTEXT * a , * l ; txfrm_block_to_raster_xy ( plane_bsize , tx_size , block , & i , & j ) ; dst = & pd -> dst . buf [ 4 * j * pd -> dst . stride + 4 * i ] ; a = & ctx -> ta [ plane ] [ i ] ; l = & ctx -> tl [ plane ] [ j ] ; if ( x -> zcoeff_blk [ tx_size ] [ block ] && plane == 0 ) { p -> eobs [ block ] = 0 ; * a = * l = 0 ; return ; } <S2SV_StartBug> if ( ! x -> skip_recode ) <S2SV_EndBug> <S2SV_StartBug> vp9_xform_quant ( x , plane , block , plane_bsize , tx_size ) ; <S2SV_EndBug> if ( x -> optimize && ( ! x -> skip_recode || ! x -> skip_optimize ) ) { <S2SV_StartBug> optimize_b ( plane , block , plane_bsize , tx_size , x , a , l ) ; <S2SV_EndBug> } else { * a = * l = p -> eobs [ block ] > 0 ; } if ( p -> eobs [ block ] ) * ( args -> skip ) = 0 ; if ( x -> skip_encode || p -> eobs [ block ] == 0 ) return ; <S2SV_StartBug> switch ( tx_size ) { <S2SV_EndBug> case TX_32X32 : <S2SV_StartBug> vp9_idct32x32_add ( dqcoeff , dst , pd -> dst . stride , p -> eobs [ block ] ) ; <S2SV_EndBug> break ; case TX_16X16 : <S2SV_StartBug> vp9_idct16x16_add ( dqcoeff , dst , pd -> dst . stride , p -> eobs [ block ] ) ; <S2SV_EndBug> break ; case TX_8X8 : <S2SV_StartBug> vp9_idct8x8_add ( dqcoeff , dst , pd -> dst . stride , p -> eobs [ block ] ) ; <S2SV_EndBug> break ; case TX_4X4 : <S2SV_StartBug> xd -> itxm_add ( dqcoeff , dst , pd -> dst . stride , p -> eobs [ block ] ) ; <S2SV_EndBug> break ; default : assert ( 0 && "Invalid<S2SV_blank>transform<S2SV_blank>size" ) ; } <S2SV_StartBug> } <S2SV_EndBug>
static Image * ReadSGIImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image ; MagickBooleanType status ; MagickSizeType number_pixels ; MemoryInfo * pixel_info ; register Quantum * q ; register ssize_t i , x ; register unsigned char * p ; SGIInfo iris_info ; size_t bytes_per_pixel , quantum ; ssize_t count , y , z ; unsigned char * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , "%s" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } iris_info . magic = ReadBlobMSBShort ( image ) ; do { if ( iris_info . magic != 0x01DA ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; iris_info . storage = ( unsigned char ) ReadBlobByte ( image ) ; switch ( iris_info . storage ) { case 0x00 : image -> compression = NoCompression ; break ; case 0x01 : image -> compression = RLECompression ; break ; default : ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; } iris_info . bytes_per_pixel = ( unsigned char ) ReadBlobByte ( image ) ; if ( ( iris_info . bytes_per_pixel == 0 ) || ( iris_info . bytes_per_pixel > 2 ) ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; <S2SV_StartBug> iris_info . dimension = ReadBlobMSBShort ( image ) ; <S2SV_EndBug> iris_info . columns = ReadBlobMSBShort ( image ) ; iris_info . rows = ReadBlobMSBShort ( image ) ; iris_info . depth = ReadBlobMSBShort ( image ) ; if ( ( iris_info . depth == 0 ) || ( iris_info . depth > 4 ) ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; iris_info . minimum_value = ReadBlobMSBLong ( image ) ; iris_info . maximum_value = ReadBlobMSBLong ( image ) ; iris_info . sans = ReadBlobMSBLong ( image ) ; count = ReadBlob ( image , sizeof ( iris_info . name ) , ( unsigned char * ) iris_info . name ) ; if ( ( size_t ) count != sizeof ( iris_info . name ) ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; iris_info . name [ sizeof ( iris_info . name ) - 1 ] = '\\0' ; if ( * iris_info . name != '\\0' ) ( void ) SetImageProperty ( image , "label" , iris_info . name , exception ) ; iris_info . pixel_format = ReadBlobMSBLong ( image ) ; if ( iris_info . pixel_format != 0 ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; count = ReadBlob ( image , sizeof ( iris_info . filler ) , iris_info . filler ) ; if ( ( size_t ) count != sizeof ( iris_info . filler ) ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; image -> columns = iris_info . columns ; image -> rows = iris_info . rows ; image -> depth = ( size_t ) MagickMin ( iris_info . depth , MAGICKCORE_QUANTUM_DEPTH ) ; if ( iris_info . pixel_format == 0 ) image -> depth = ( size_t ) MagickMin ( ( size_t ) 8 * iris_info . bytes_per_pixel , MAGICKCORE_QUANTUM_DEPTH ) ; if ( iris_info . depth < 3 ) { image -> storage_class = PseudoClass ; image -> colors = ( size_t ) ( iris_info . bytes_per_pixel > 1 ? 65535 : 256 ) ; } if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; bytes_per_pixel = ( size_t ) iris_info . bytes_per_pixel ; number_pixels = ( MagickSizeType ) iris_info . columns * iris_info . rows ; if ( ( 4 * bytes_per_pixel * number_pixels ) != ( ( MagickSizeType ) ( size_t ) ( 4 * bytes_per_pixel * number_pixels ) ) ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; pixel_info = AcquireVirtualMemory ( iris_info . columns , iris_info . rows * 4 * bytes_per_pixel * sizeof ( * pixels ) ) ; if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ; if ( ( int ) iris_info . storage != 0x01 ) { unsigned char * scanline ; scanline = ( unsigned char * ) AcquireQuantumMemory ( iris_info . columns , bytes_per_pixel * sizeof ( * scanline ) ) ; if ( scanline == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; for ( z = 0 ; z < ( ssize_t ) iris_info . depth ; z ++ ) { p = pixels + bytes_per_pixel * z ; for ( y = 0 ; y < ( ssize_t ) iris_info . rows ; y ++ ) { count = ReadBlob ( image , bytes_per_pixel * iris_info . columns , scanline ) ; if ( EOFBlob ( image ) != MagickFalse ) break ; if ( bytes_per_pixel == 2 ) for ( x = 0 ; x < ( ssize_t ) iris_info . columns ; x ++ ) { * p = scanline [ 2 * x ] ; * ( p + 1 ) = scanline [ 2 * x + 1 ] ; p += 8 ; } else for ( x = 0 ; x < ( ssize_t ) iris_info . columns ; x ++ ) { * p = scanline [ x ] ; p += 4 ; } } } scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ; } else { MemoryInfo * packet_info ; size_t * runlength ; ssize_t offset , * offsets ; unsigned char * packets ; unsigned int data_order ; offsets = ( ssize_t * ) AcquireQuantumMemory ( ( size_t ) iris_info . rows , iris_info . depth * sizeof ( * offsets ) ) ; runlength = ( size_t * ) AcquireQuantumMemory ( iris_info . rows , iris_info . depth * sizeof ( * runlength ) ) ; packet_info = AcquireVirtualMemory ( ( size_t ) iris_info . columns + 10UL , 4UL * sizeof ( * packets ) ) ; if ( ( offsets == ( ssize_t * ) NULL ) || ( runlength == ( size_t * ) NULL ) || ( packet_info == ( MemoryInfo * ) NULL ) ) { if ( offsets == ( ssize_t * ) NULL ) offsets = ( ssize_t * ) RelinquishMagickMemory ( offsets ) ; if ( runlength == ( size_t * ) NULL ) runlength = ( size_t * ) RelinquishMagickMemory ( runlength ) ; if ( packet_info == ( MemoryInfo * ) NULL ) packet_info = RelinquishVirtualMemory ( packet_info ) ; ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; } packets = ( unsigned char * ) GetVirtualMemoryBlob ( packet_info ) ; for ( i = 0 ; i < ( ssize_t ) ( iris_info . rows * iris_info . depth ) ; i ++ ) offsets [ i ] = ( ssize_t ) ReadBlobMSBSignedLong ( image ) ; for ( i = 0 ; i < ( ssize_t ) ( iris_info . rows * iris_info . depth ) ; i ++ ) { runlength [ i ] = ReadBlobMSBLong ( image ) ; if ( runlength [ i ] > ( 4 * ( size_t ) iris_info . columns + 10 ) ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; } offset = 0 ; data_order = 0 ; for ( y = 0 ; ( ( y < ( ssize_t ) iris_info . rows ) && ( data_order == 0 ) ) ; y ++ ) for ( z = 0 ; ( ( z < ( ssize_t ) iris_info . depth ) && ( data_order == 0 ) ) ; z ++ ) { if ( offsets [ y + z * iris_info . rows ] < offset ) data_order = 1 ; offset = offsets [ y + z * iris_info . rows ] ; } offset = ( ssize_t ) TellBlob ( image ) ; if ( data_order == 1 ) { for ( z = 0 ; z < ( ssize_t ) iris_info . depth ; z ++ ) { p = pixels ; for ( y = 0 ; y < ( ssize_t ) iris_info . rows ; y ++ ) { if ( offset != offsets [ y + z * iris_info . rows ] ) { offset = offsets [ y + z * iris_info . rows ] ; offset = ( ssize_t ) SeekBlob ( image , ( MagickOffsetType ) offset , SEEK_SET ) ; } count = ReadBlob ( image , ( size_t ) runlength [ y + z * iris_info . rows ] , packets ) ; if ( EOFBlob ( image ) != MagickFalse ) break ; offset += ( ssize_t ) runlength [ y + z * iris_info . rows ] ; status = SGIDecode ( bytes_per_pixel , ( ssize_t ) ( runlength [ y + z * iris_info . rows ] / bytes_per_pixel ) , packets , ( ssize_t ) iris_info . columns , p + bytes_per_pixel * z ) ; if ( status == MagickFalse ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; p += ( iris_info . columns * 4 * bytes_per_pixel ) ; } } } else { MagickOffsetType position ; position = TellBlob ( image ) ; p = pixels ; for ( y = 0 ; y < ( ssize_t ) iris_info . rows ; y ++ ) { for ( z = 0 ; z < ( ssize_t ) iris_info . depth ; z ++ ) { if ( offset != offsets [ y + z * iris_info . rows ] ) { offset = offsets [ y + z * iris_info . rows ] ; offset = ( ssize_t ) SeekBlob ( image , ( MagickOffsetType ) offset , SEEK_SET ) ; } count = ReadBlob ( image , ( size_t ) runlength [ y + z * iris_info . rows ] , packets ) ; if ( EOFBlob ( image ) != MagickFalse ) break ; offset += ( ssize_t ) runlength [ y + z * iris_info . rows ] ; status = SGIDecode ( bytes_per_pixel , ( ssize_t ) ( runlength [ y + z * iris_info . rows ] / bytes_per_pixel ) , packets , ( ssize_t ) iris_info . columns , p + bytes_per_pixel * z ) ; if ( status == MagickFalse ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; } p += ( iris_info . columns * 4 * bytes_per_pixel ) ; } offset = ( ssize_t ) SeekBlob ( image , position , SEEK_SET ) ; } packet_info = RelinquishVirtualMemory ( packet_info ) ; runlength = ( size_t * ) RelinquishMagickMemory ( runlength ) ; offsets = ( ssize_t * ) RelinquishMagickMemory ( offsets ) ; } image -> alpha_trait = iris_info . depth == 4 ? BlendPixelTrait : UndefinedPixelTrait ; image -> columns = iris_info . columns ; image -> rows = iris_info . rows ; if ( image -> storage_class == DirectClass ) { if ( bytes_per_pixel == 2 ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { p = pixels + ( image -> rows - y - 1 ) * 8 * image -> columns ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( image , ScaleShortToQuantum ( ( unsigned short ) ( ( * ( p + 0 ) << 8 ) | ( * ( p + 1 ) ) ) ) , q ) ; SetPixelGreen ( image , ScaleShortToQuantum ( ( unsigned short ) ( ( * ( p + 2 ) << 8 ) | ( * ( p + 3 ) ) ) ) , q ) ; SetPixelBlue ( image , ScaleShortToQuantum ( ( unsigned short ) ( ( * ( p + 4 ) << 8 ) | ( * ( p + 5 ) ) ) ) , q ) ; SetPixelAlpha ( image , OpaqueAlpha , q ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , ScaleShortToQuantum ( ( unsigned short ) ( ( * ( p + 6 ) << 8 ) | ( * ( p + 7 ) ) ) ) , q ) ; p += 8 ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { p = pixels + ( image -> rows - y - 1 ) * 4 * image -> columns ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( image , ScaleCharToQuantum ( * p ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * ( p + 1 ) ) , q ) ; SetPixelBlue ( image , ScaleCharToQuantum ( * ( p + 2 ) ) , q ) ; SetPixelAlpha ( image , OpaqueAlpha , q ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , ScaleCharToQuantum ( * ( p + 3 ) ) , q ) ; p += 4 ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else { if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; if ( bytes_per_pixel == 2 ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { p = pixels + ( image -> rows - y - 1 ) * 8 * image -> columns ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { quantum = ( * p << 8 ) ; quantum |= ( * ( p + 1 ) ) ; SetPixelIndex ( image , ( Quantum ) quantum , q ) ; p += 8 ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { p = pixels + ( image -> rows - y - 1 ) * 4 * image -> columns ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelIndex ( image , * p , q ) ; p += 4 ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image , exception ) ; } pixel_info = RelinquishVirtualMemory ( pixel_info ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , "UnexpectedEndOfFile" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; iris_info . magic = ReadBlobMSBShort ( image ) ; if ( iris_info . magic == 0x01DA ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( iris_info . magic == 0x01DA ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
void jas_matrix_asl ( jas_matrix_t * matrix , int n ) { <S2SV_StartBug> int i ; <S2SV_EndBug> int j ; jas_seqent_t * rowstart ; <S2SV_StartBug> int rowstep ; <S2SV_EndBug> jas_seqent_t * data ; if ( jas_matrix_numrows ( matrix ) > 0 && jas_matrix_numcols ( matrix ) > 0 ) { assert ( matrix -> rows_ ) ; rowstep = jas_matrix_rowstep ( matrix ) ; for ( i = matrix -> numrows_ , rowstart = matrix -> rows_ [ 0 ] ; i > 0 ; -- i , rowstart += rowstep ) { for ( j = matrix -> numcols_ , data = rowstart ; j > 0 ; -- j , ++ data ) { * data = jas_seqent_asl ( * data , n ) ; } } } }
void fib_del_ifaddr ( struct in_ifaddr * ifa , struct in_ifaddr * iprim ) { struct in_device * in_dev = ifa -> ifa_dev ; struct net_device * dev = in_dev -> dev ; struct in_ifaddr * ifa1 ; struct in_ifaddr * prim = ifa , * prim1 = NULL ; __be32 brd = ifa -> ifa_address | ~ ifa -> ifa_mask ; __be32 any = ifa -> ifa_address & ifa -> ifa_mask ; # define LOCAL_OK 1 # define BRD_OK 2 # define BRD0_OK 4 # define BRD1_OK 8 unsigned int ok = 0 ; int subnet = 0 ; int gone = 1 ; int same_prefsrc = 0 ; if ( ifa -> ifa_flags & IFA_F_SECONDARY ) { prim = inet_ifa_byprefix ( in_dev , any , ifa -> ifa_mask ) ; if ( ! prim ) { pr_warn ( "%s:<S2SV_blank>bug:<S2SV_blank>prim<S2SV_blank>==<S2SV_blank>NULL\\n" , __func__ ) ; return ; } if ( iprim && iprim != prim ) { pr_warn ( "%s:<S2SV_blank>bug:<S2SV_blank>iprim<S2SV_blank>!=<S2SV_blank>prim\\n" , __func__ ) ; return ; } } else if ( ! ipv4_is_zeronet ( any ) && ( any != ifa -> ifa_local || ifa -> ifa_prefixlen < 32 ) ) { if ( ! ( ifa -> ifa_flags & IFA_F_NOPREFIXROUTE ) ) fib_magic ( RTM_DELROUTE , dev -> flags & IFF_LOOPBACK ? RTN_LOCAL : RTN_UNICAST , any , ifa -> ifa_prefixlen , prim ) ; subnet = 1 ; } <S2SV_StartBug> for ( ifa1 = in_dev -> ifa_list ; ifa1 ; ifa1 = ifa1 -> ifa_next ) { <S2SV_EndBug> if ( ifa1 == ifa ) { gone = 0 ; continue ; } if ( iprim && ifa1 -> ifa_mask == iprim -> ifa_mask && inet_ifa_match ( ifa1 -> ifa_address , iprim ) ) continue ; if ( ifa1 -> ifa_flags & IFA_F_SECONDARY ) { if ( ifa1 -> ifa_mask == prim -> ifa_mask && inet_ifa_match ( ifa1 -> ifa_address , prim ) ) prim1 = prim ; else { if ( ! same_prefsrc ) continue ; if ( ! prim1 || ifa1 -> ifa_mask != prim1 -> ifa_mask || ! inet_ifa_match ( ifa1 -> ifa_address , prim1 ) ) prim1 = inet_ifa_byprefix ( in_dev , ifa1 -> ifa_address , ifa1 -> ifa_mask ) ; if ( ! prim1 ) continue ; if ( prim1 -> ifa_local != prim -> ifa_local ) continue ; } } else { if ( prim -> ifa_local != ifa1 -> ifa_local ) continue ; prim1 = ifa1 ; if ( prim != prim1 ) same_prefsrc = 1 ; } if ( ifa -> ifa_local == ifa1 -> ifa_local ) ok |= LOCAL_OK ; if ( ifa -> ifa_broadcast == ifa1 -> ifa_broadcast ) ok |= BRD_OK ; if ( brd == ifa1 -> ifa_broadcast ) ok |= BRD1_OK ; if ( any == ifa1 -> ifa_broadcast ) ok |= BRD0_OK ; if ( prim1 == ifa1 && ifa1 -> ifa_prefixlen < 31 ) { __be32 brd1 = ifa1 -> ifa_address | ~ ifa1 -> ifa_mask ; __be32 any1 = ifa1 -> ifa_address & ifa1 -> ifa_mask ; if ( ! ipv4_is_zeronet ( any1 ) ) { if ( ifa -> ifa_broadcast == brd1 || ifa -> ifa_broadcast == any1 ) ok |= BRD_OK ; if ( brd == brd1 || brd == any1 ) ok |= BRD1_OK ; if ( any == brd1 || any == any1 ) ok |= BRD0_OK ; } } <S2SV_StartBug> } <S2SV_EndBug> if ( ! ( ok & BRD_OK ) ) fib_magic ( RTM_DELROUTE , RTN_BROADCAST , ifa -> ifa_broadcast , 32 , prim ) ; if ( subnet && ifa -> ifa_prefixlen < 31 ) { if ( ! ( ok & BRD1_OK ) ) fib_magic ( RTM_DELROUTE , RTN_BROADCAST , brd , 32 , prim ) ; if ( ! ( ok & BRD0_OK ) ) fib_magic ( RTM_DELROUTE , RTN_BROADCAST , any , 32 , prim ) ; } if ( ! ( ok & LOCAL_OK ) ) { unsigned int addr_type ; fib_magic ( RTM_DELROUTE , RTN_LOCAL , ifa -> ifa_local , 32 , prim ) ; addr_type = inet_addr_type_dev_table ( dev_net ( dev ) , dev , ifa -> ifa_local ) ; if ( gone && addr_type != RTN_LOCAL ) { if ( fib_sync_down_addr ( dev_net ( dev ) , ifa -> ifa_local ) ) fib_flush ( dev_net ( dev ) ) ; } } # undef LOCAL_OK # undef BRD_OK # undef BRD0_OK # undef BRD1_OK }
PyObject * ast2obj_stmt ( void * _o ) { stmt_ty o = ( stmt_ty ) _o ; PyObject * result = NULL , * value = NULL ; if ( ! o ) { <S2SV_StartBug> Py_INCREF ( Py_None ) ; <S2SV_EndBug> return Py_None ; } switch ( o -> kind ) { case FunctionDef_kind : result = PyType_GenericNew ( FunctionDef_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_identifier ( o -> v . FunctionDef . name ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_name , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_arguments ( o -> v . FunctionDef . args ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_args , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . FunctionDef . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . FunctionDef . decorator_list , ast2obj_expr ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_decorator_list , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> v . FunctionDef . returns ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_returns , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_string ( o -> v . FunctionDef . type_comment ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_type_comment , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case AsyncFunctionDef_kind : result = PyType_GenericNew ( AsyncFunctionDef_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_identifier ( o -> v . AsyncFunctionDef . name ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_name , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_arguments ( o -> v . AsyncFunctionDef . args ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_args , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . AsyncFunctionDef . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . AsyncFunctionDef . decorator_list , ast2obj_expr ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_decorator_list , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> v . AsyncFunctionDef . returns ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_returns , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_string ( o -> v . AsyncFunctionDef . type_comment ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_type_comment , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case ClassDef_kind : result = PyType_GenericNew ( ClassDef_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_identifier ( o -> v . ClassDef . name ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_name , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . ClassDef . bases , ast2obj_expr ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_bases , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . ClassDef . keywords , ast2obj_keyword ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_keywords , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . ClassDef . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . ClassDef . decorator_list , ast2obj_expr ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_decorator_list , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Return_kind : result = PyType_GenericNew ( Return_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . Return . value ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_value , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Delete_kind : result = PyType_GenericNew ( Delete_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . Delete . targets , ast2obj_expr ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_targets , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Assign_kind : result = PyType_GenericNew ( Assign_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . Assign . targets , ast2obj_expr ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_targets , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> v . Assign . value ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_value , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_string ( o -> v . Assign . type_comment ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_type_comment , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case AugAssign_kind : result = PyType_GenericNew ( AugAssign_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . AugAssign . target ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_target , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_operator ( o -> v . AugAssign . op ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_op , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> v . AugAssign . value ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_value , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case AnnAssign_kind : result = PyType_GenericNew ( AnnAssign_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . AnnAssign . target ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_target , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> v . AnnAssign . annotation ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_annotation , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> v . AnnAssign . value ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_value , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_int ( o -> v . AnnAssign . simple ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_simple , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case For_kind : result = PyType_GenericNew ( For_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . For . target ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_target , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> v . For . iter ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_iter , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . For . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . For . orelse , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_orelse , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_string ( o -> v . For . type_comment ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_type_comment , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case AsyncFor_kind : result = PyType_GenericNew ( AsyncFor_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . AsyncFor . target ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_target , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> v . AsyncFor . iter ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_iter , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . AsyncFor . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . AsyncFor . orelse , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_orelse , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_string ( o -> v . AsyncFor . type_comment ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_type_comment , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case While_kind : result = PyType_GenericNew ( While_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . While . test ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_test , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . While . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . While . orelse , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_orelse , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case If_kind : result = PyType_GenericNew ( If_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . If . test ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_test , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . If . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . If . orelse , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_orelse , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case With_kind : result = PyType_GenericNew ( With_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . With . items , ast2obj_withitem ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_items , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . With . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_string ( o -> v . With . type_comment ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_type_comment , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case AsyncWith_kind : result = PyType_GenericNew ( AsyncWith_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . AsyncWith . items , ast2obj_withitem ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_items , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . AsyncWith . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_string ( o -> v . AsyncWith . type_comment ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_type_comment , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Raise_kind : result = PyType_GenericNew ( Raise_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . Raise . exc ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_exc , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> v . Raise . cause ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_cause , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Try_kind : result = PyType_GenericNew ( Try_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . Try . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . Try . handlers , ast2obj_excepthandler ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_handlers , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . Try . orelse , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_orelse , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . Try . finalbody , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_finalbody , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Assert_kind : result = PyType_GenericNew ( Assert_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . Assert . test ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_test , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> v . Assert . msg ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_msg , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Import_kind : result = PyType_GenericNew ( Import_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . Import . names , ast2obj_alias ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_names , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case ImportFrom_kind : result = PyType_GenericNew ( ImportFrom_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_identifier ( o -> v . ImportFrom . module ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_module , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . ImportFrom . names , ast2obj_alias ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_names , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_int ( o -> v . ImportFrom . level ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_level , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Global_kind : result = PyType_GenericNew ( Global_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . Global . names , ast2obj_identifier ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_names , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Nonlocal_kind : result = PyType_GenericNew ( Nonlocal_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . Nonlocal . names , ast2obj_identifier ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_names , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Expr_kind : result = PyType_GenericNew ( Expr_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . Expr . value ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_value , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Pass_kind : result = PyType_GenericNew ( Pass_type , NULL , NULL ) ; if ( ! result ) goto failed ; break ; case Break_kind : result = PyType_GenericNew ( Break_type , NULL , NULL ) ; if ( ! result ) goto failed ; break ; case Continue_kind : result = PyType_GenericNew ( Continue_type , NULL , NULL ) ; if ( ! result ) goto failed ; break ; } value = ast2obj_int ( o -> lineno ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_lineno , value ) < 0 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_int ( o -> col_offset ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_col_offset , value ) < 0 ) goto failed ; Py_DECREF ( value ) ; return result ; failed : Py_XDECREF ( value ) ; Py_XDECREF ( result ) ; return NULL ; }
static bool access_pmu_evcntr ( struct kvm_vcpu * vcpu , struct sys_reg_params * p , const struct sys_reg_desc * r ) { u64 idx ; if ( ! kvm_arm_pmu_v3_ready ( vcpu ) ) return trap_raz_wi ( vcpu , p , r ) ; if ( r -> CRn == 9 && r -> CRm == 13 ) { if ( r -> Op2 == 2 ) { if ( pmu_access_event_counter_el0_disabled ( vcpu ) ) return false ; idx = vcpu_sys_reg ( vcpu , PMSELR_EL0 ) & ARMV8_PMU_COUNTER_MASK ; } else if ( r -> Op2 == 0 ) { if ( pmu_access_cycle_counter_el0_disabled ( vcpu ) ) return false ; idx = ARMV8_PMU_CYCLE_IDX ; } else { <S2SV_StartBug> BUG ( ) ; <S2SV_EndBug> } } else if ( r -> CRn == 14 && ( r -> CRm & 12 ) == 8 ) { if ( pmu_access_event_counter_el0_disabled ( vcpu ) ) return false ; idx = ( ( r -> CRm & 3 ) << 3 ) | ( r -> Op2 & 7 ) ; } else { <S2SV_StartBug> BUG ( ) ; <S2SV_EndBug> } if ( ! pmu_counter_idx_valid ( vcpu , idx ) ) return false ; if ( p -> is_write ) { if ( pmu_access_el0_disabled ( vcpu ) ) return false ; kvm_pmu_set_counter_value ( vcpu , idx , p -> regval ) ; } else { p -> regval = kvm_pmu_get_counter_value ( vcpu , idx ) ; } return true ; }
<S2SV_StartBug> static void xen_netbk_idx_release ( struct xen_netbk * netbk , u16 pending_idx ) <S2SV_EndBug> { struct xenvif * vif ; struct pending_tx_info * pending_tx_info ; pending_ring_idx_t index ; if ( netbk -> mmap_pages [ pending_idx ] == NULL ) return ; pending_tx_info = & netbk -> pending_tx_info [ pending_idx ] ; vif = pending_tx_info -> vif ; <S2SV_StartBug> make_tx_response ( vif , & pending_tx_info -> req , XEN_NETIF_RSP_OKAY ) ; <S2SV_EndBug> index = pending_index ( netbk -> pending_prod ++ ) ; netbk -> pending_ring [ index ] = pending_idx ; xenvif_put ( vif ) ; netbk -> mmap_pages [ pending_idx ] -> mapping = 0 ; put_page ( netbk -> mmap_pages [ pending_idx ] ) ; netbk -> mmap_pages [ pending_idx ] = NULL ; }
static ssize_t f_hidg_write ( struct file * file , const char __user * buffer , size_t count , loff_t * offp ) { struct f_hidg * hidg = file -> private_data ; struct usb_request * req ; unsigned long flags ; ssize_t status = - ENOMEM ; if ( ! access_ok ( buffer , count ) ) return - EFAULT ; spin_lock_irqsave ( & hidg -> write_spinlock , flags ) ; # define WRITE_COND ( ! hidg -> write_pending ) try_again : while ( ! WRITE_COND ) { spin_unlock_irqrestore ( & hidg -> write_spinlock , flags ) ; if ( file -> f_flags & O_NONBLOCK ) return - EAGAIN ; if ( wait_event_interruptible_exclusive ( hidg -> write_queue , WRITE_COND ) ) return - ERESTARTSYS ; spin_lock_irqsave ( & hidg -> write_spinlock , flags ) ; } hidg -> write_pending = 1 ; req = hidg -> req ; count = min_t ( unsigned , count , hidg -> report_length ) ; spin_unlock_irqrestore ( & hidg -> write_spinlock , flags ) ; status = copy_from_user ( req -> buf , buffer , count ) ; if ( status != 0 ) { ERROR ( hidg -> func . config -> cdev , "copy_from_user<S2SV_blank>error\\n" ) ; status = - EINVAL ; goto release_write_pending ; } spin_lock_irqsave ( & hidg -> write_spinlock , flags ) ; if ( ! hidg -> req ) { free_ep_req ( hidg -> in_ep , req ) ; goto try_again ; } req -> status = 0 ; req -> zero = 0 ; req -> length = count ; req -> complete = f_hidg_req_complete ; req -> context = hidg ; <S2SV_StartBug> status = usb_ep_queue ( hidg -> in_ep , req , GFP_ATOMIC ) ; <S2SV_EndBug> if ( status < 0 ) { ERROR ( hidg -> func . config -> cdev , "usb_ep_queue<S2SV_blank>error<S2SV_blank>on<S2SV_blank>int<S2SV_blank>endpoint<S2SV_blank>%zd\\n" , status ) ; <S2SV_StartBug> goto release_write_pending_unlocked ; <S2SV_EndBug> } else { status = count ; } <S2SV_StartBug> spin_unlock_irqrestore ( & hidg -> write_spinlock , flags ) ; <S2SV_EndBug> return status ; release_write_pending : spin_lock_irqsave ( & hidg -> write_spinlock , flags ) ; <S2SV_StartBug> release_write_pending_unlocked : <S2SV_EndBug> hidg -> write_pending = 0 ; spin_unlock_irqrestore ( & hidg -> write_spinlock , flags ) ; wake_up ( & hidg -> write_queue ) ; return status ; }
void lxc_execute_bind_init ( struct lxc_conf * conf ) { int ret ; char path [ PATH_MAX ] , destpath [ PATH_MAX ] , * p ; p = choose_init ( conf -> rootfs . mount ) ; if ( p ) { free ( p ) ; return ; } ret = snprintf ( path , PATH_MAX , SBINDIR "/init.lxc.static" ) ; if ( ret < 0 || ret >= PATH_MAX ) { WARN ( "Path<S2SV_blank>name<S2SV_blank>too<S2SV_blank>long<S2SV_blank>searching<S2SV_blank>for<S2SV_blank>lxc.init.static" ) ; return ; } if ( ! file_exists ( path ) ) { INFO ( "%s<S2SV_blank>does<S2SV_blank>not<S2SV_blank>exist<S2SV_blank>on<S2SV_blank>host" , path ) ; return ; } ret = snprintf ( destpath , PATH_MAX , "%s%s" , conf -> rootfs . mount , "/init.lxc.static" ) ; if ( ret < 0 || ret >= PATH_MAX ) { WARN ( "Path<S2SV_blank>name<S2SV_blank>too<S2SV_blank>long<S2SV_blank>for<S2SV_blank>container\'s<S2SV_blank>lxc.init.static" ) ; return ; } if ( ! file_exists ( destpath ) ) { FILE * pathfile = fopen ( destpath , "wb" ) ; if ( ! pathfile ) { SYSERROR ( "Failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>mount<S2SV_blank>target<S2SV_blank>\'%s\'" , destpath ) ; return ; } fclose ( pathfile ) ; } <S2SV_StartBug> ret = mount ( path , destpath , "none" , MS_BIND , NULL ) ; <S2SV_EndBug> if ( ret < 0 ) SYSERROR ( "Failed<S2SV_blank>to<S2SV_blank>bind<S2SV_blank>lxc.init.static<S2SV_blank>into<S2SV_blank>container" ) ; INFO ( "lxc.init.static<S2SV_blank>bound<S2SV_blank>into<S2SV_blank>container<S2SV_blank>at<S2SV_blank>%s" , path ) ; }
int ocfs2_setattr ( struct dentry * dentry , struct iattr * attr ) { int status = 0 , size_change ; int inode_locked = 0 ; struct inode * inode = d_inode ( dentry ) ; struct super_block * sb = inode -> i_sb ; struct ocfs2_super * osb = OCFS2_SB ( sb ) ; struct buffer_head * bh = NULL ; handle_t * handle = NULL ; struct dquot * transfer_to [ MAXQUOTAS ] = { } ; int qtype ; int had_lock ; struct ocfs2_lock_holder oh ; trace_ocfs2_setattr ( inode , dentry , ( unsigned long long ) OCFS2_I ( inode ) -> ip_blkno , dentry -> d_name . len , dentry -> d_name . name , attr -> ia_valid , attr -> ia_mode , from_kuid ( & init_user_ns , attr -> ia_uid ) , from_kgid ( & init_user_ns , attr -> ia_gid ) ) ; if ( S_ISLNK ( inode -> i_mode ) ) attr -> ia_valid &= ~ ATTR_SIZE ; # define OCFS2_VALID_ATTRS ( ATTR_ATIME | ATTR_MTIME | ATTR_CTIME | ATTR_SIZE | ATTR_GID | ATTR_UID | ATTR_MODE ) if ( ! ( attr -> ia_valid & OCFS2_VALID_ATTRS ) ) return 0 ; status = setattr_prepare ( dentry , attr ) ; if ( status ) return status ; if ( is_quota_modification ( inode , attr ) ) { status = dquot_initialize ( inode ) ; if ( status ) return status ; } size_change = S_ISREG ( inode -> i_mode ) && attr -> ia_valid & ATTR_SIZE ; if ( size_change ) { <S2SV_StartBug> status = ocfs2_rw_lock ( inode , 1 ) ; <S2SV_EndBug> if ( status < 0 ) { mlog_errno ( status ) ; goto bail ; } } had_lock = ocfs2_inode_lock_tracker ( inode , & bh , 1 , & oh ) ; if ( had_lock < 0 ) { status = had_lock ; goto bail_unlock_rw ; } else if ( had_lock ) { mlog ( ML_ERROR , "Another<S2SV_blank>case<S2SV_blank>of<S2SV_blank>recursive<S2SV_blank>locking:\\n" ) ; dump_stack ( ) ; } inode_locked = 1 ; if ( size_change ) { status = inode_newsize_ok ( inode , attr -> ia_size ) ; if ( status ) <S2SV_StartBug> goto bail_unlock ; <S2SV_EndBug> inode_dio_wait ( inode ) ; if ( i_size_read ( inode ) >= attr -> ia_size ) { if ( ocfs2_should_order_data ( inode ) ) { status = ocfs2_begin_ordered_truncate ( inode , attr -> ia_size ) ; if ( status ) goto bail_unlock ; } status = ocfs2_truncate_file ( inode , bh , attr -> ia_size ) ; } else status = ocfs2_extend_file ( inode , bh , attr -> ia_size ) ; if ( status < 0 ) { if ( status != - ENOSPC ) mlog_errno ( status ) ; status = - ENOSPC ; goto bail_unlock ; } } if ( ( attr -> ia_valid & ATTR_UID && ! uid_eq ( attr -> ia_uid , inode -> i_uid ) ) || ( attr -> ia_valid & ATTR_GID && ! gid_eq ( attr -> ia_gid , inode -> i_gid ) ) ) { if ( attr -> ia_valid & ATTR_UID && ! uid_eq ( attr -> ia_uid , inode -> i_uid ) && OCFS2_HAS_RO_COMPAT_FEATURE ( sb , OCFS2_FEATURE_RO_COMPAT_USRQUOTA ) ) { transfer_to [ USRQUOTA ] = dqget ( sb , make_kqid_uid ( attr -> ia_uid ) ) ; if ( IS_ERR ( transfer_to [ USRQUOTA ] ) ) { status = PTR_ERR ( transfer_to [ USRQUOTA ] ) ; goto bail_unlock ; } } if ( attr -> ia_valid & ATTR_GID && ! gid_eq ( attr -> ia_gid , inode -> i_gid ) && OCFS2_HAS_RO_COMPAT_FEATURE ( sb , OCFS2_FEATURE_RO_COMPAT_GRPQUOTA ) ) { transfer_to [ GRPQUOTA ] = dqget ( sb , make_kqid_gid ( attr -> ia_gid ) ) ; if ( IS_ERR ( transfer_to [ GRPQUOTA ] ) ) { status = PTR_ERR ( transfer_to [ GRPQUOTA ] ) ; goto bail_unlock ; } } handle = ocfs2_start_trans ( osb , OCFS2_INODE_UPDATE_CREDITS + 2 * ocfs2_quota_trans_credits ( sb ) ) ; if ( IS_ERR ( handle ) ) { status = PTR_ERR ( handle ) ; mlog_errno ( status ) ; goto bail_unlock ; } status = __dquot_transfer ( inode , transfer_to ) ; if ( status < 0 ) goto bail_commit ; } else { handle = ocfs2_start_trans ( osb , OCFS2_INODE_UPDATE_CREDITS ) ; if ( IS_ERR ( handle ) ) { status = PTR_ERR ( handle ) ; mlog_errno ( status ) ; goto bail_unlock ; } } setattr_copy ( inode , attr ) ; mark_inode_dirty ( inode ) ; status = ocfs2_mark_inode_dirty ( handle , inode , bh ) ; if ( status < 0 ) mlog_errno ( status ) ; bail_commit : ocfs2_commit_trans ( osb , handle ) ; bail_unlock : if ( status && inode_locked ) { ocfs2_inode_unlock_tracker ( inode , 1 , & oh , had_lock ) ; inode_locked = 0 ; } bail_unlock_rw : if ( size_change ) ocfs2_rw_unlock ( inode , 1 ) ; bail : for ( qtype = 0 ; qtype < OCFS2_MAXQUOTAS ; qtype ++ ) dqput ( transfer_to [ qtype ] ) ; if ( ! status && attr -> ia_valid & ATTR_MODE ) { status = ocfs2_acl_chmod ( inode , bh ) ; if ( status < 0 ) mlog_errno ( status ) ; } if ( inode_locked ) ocfs2_inode_unlock_tracker ( inode , 1 , & oh , had_lock ) ; brelse ( bh ) ; return status ; }
int yr_object_array_set_item ( YR_OBJECT * object , YR_OBJECT * item , int index ) { YR_OBJECT_ARRAY * array ; int i ; int count ; assert ( index >= 0 ) ; assert ( object -> type == OBJECT_TYPE_ARRAY ) ; array = object_as_array ( object ) ; if ( array -> items == NULL ) { <S2SV_StartBug> count = yr_max ( 64 , ( index + 1 ) * 2 ) ; <S2SV_EndBug> array -> items = ( YR_ARRAY_ITEMS * ) yr_malloc ( sizeof ( YR_ARRAY_ITEMS ) + count * sizeof ( YR_OBJECT * ) ) ; if ( array -> items == NULL ) return ERROR_INSUFFICIENT_MEMORY ; memset ( array -> items -> objects , 0 , count * sizeof ( YR_OBJECT * ) ) ; array -> items -> count = count ; } else if ( index >= array -> items -> count ) { count = array -> items -> count * 2 ; <S2SV_StartBug> array -> items = ( YR_ARRAY_ITEMS * ) yr_realloc ( <S2SV_EndBug> array -> items , sizeof ( YR_ARRAY_ITEMS ) + count * sizeof ( YR_OBJECT * ) ) ; if ( array -> items == NULL ) return ERROR_INSUFFICIENT_MEMORY ; for ( i = array -> items -> count ; i < count ; i ++ ) array -> items -> objects [ i ] = NULL ; array -> items -> count = count ; } item -> parent = object ; array -> items -> objects [ index ] = item ; return ERROR_SUCCESS ; }
SYSCALL_DEFINE3 ( osf_sysinfo , int , command , char __user * , buf , long , count ) { const char * sysinfo_table [ ] = { utsname ( ) -> sysname , utsname ( ) -> nodename , utsname ( ) -> release , utsname ( ) -> version , utsname ( ) -> machine , "alpha" , "dummy" , "dummy" , "dummy" , } ; unsigned long offset ; const char * res ; long len , err = - EINVAL ; offset = command - 1 ; if ( offset >= ARRAY_SIZE ( sysinfo_table ) ) { printk ( "sysinfo(%d)" , command ) ; goto out ; } down_read ( & uts_sem ) ; res = sysinfo_table [ offset ] ; len = strlen ( res ) + 1 ; <S2SV_StartBug> if ( len > count ) <S2SV_EndBug> len = count ; if ( copy_to_user ( buf , res , len ) ) err = - EFAULT ; else err = 0 ; up_read ( & uts_sem ) ; out : return err ; }
kadm5_ret_t kadm5_create_principal_3 ( void * server_handle , kadm5_principal_ent_t entry , long mask , int n_ks_tuple , krb5_key_salt_tuple * ks_tuple , char * password ) { krb5_db_entry * kdb ; osa_princ_ent_rec adb ; kadm5_policy_ent_rec polent ; krb5_boolean have_polent = FALSE ; krb5_timestamp now ; krb5_tl_data * tl_data_tail ; unsigned int ret ; kadm5_server_handle_t handle = server_handle ; krb5_keyblock * act_mkey ; krb5_kvno act_kvno ; int new_n_ks_tuple = 0 ; krb5_key_salt_tuple * new_ks_tuple = NULL ; CHECK_HANDLE ( server_handle ) ; krb5_clear_error_message ( handle -> context ) ; check_1_6_dummy ( entry , mask , n_ks_tuple , ks_tuple , & password ) ; if ( entry == NULL ) return EINVAL ; if ( ! ( mask & KADM5_PRINCIPAL ) || ( mask & KADM5_MOD_NAME ) || ( mask & KADM5_MOD_TIME ) || ( mask & KADM5_LAST_PWD_CHANGE ) || ( mask & KADM5_MKVNO ) || ( mask & KADM5_AUX_ATTRIBUTES ) || ( mask & KADM5_LAST_SUCCESS ) || ( mask & KADM5_LAST_FAILED ) || ( mask & KADM5_FAIL_AUTH_COUNT ) ) return KADM5_BAD_MASK ; if ( ( mask & KADM5_KEY_DATA ) && entry -> n_key_data != 0 ) return KADM5_BAD_MASK ; if ( ( mask & KADM5_POLICY ) && entry -> policy == NULL ) return KADM5_BAD_MASK ; if ( ( mask & KADM5_POLICY ) && ( mask & KADM5_POLICY_CLR ) ) return KADM5_BAD_MASK ; if ( ( mask & ~ ALL_PRINC_MASK ) ) <S2SV_StartBug> return KADM5_BAD_MASK ; <S2SV_EndBug> ret = kdb_get_entry ( handle , entry -> principal , & kdb , & adb ) ; switch ( ret ) { case KADM5_UNK_PRINC : break ; case 0 : kdb_free_entry ( handle , kdb , & adb ) ; return KADM5_DUP ; default : return ret ; } kdb = calloc ( 1 , sizeof ( * kdb ) ) ; if ( kdb == NULL ) return ENOMEM ; memset ( & adb , 0 , sizeof ( osa_princ_ent_rec ) ) ; if ( ( mask & KADM5_POLICY ) ) { ret = get_policy ( handle , entry -> policy , & polent , & have_polent ) ; if ( ret ) goto cleanup ; } if ( password ) { ret = passwd_check ( handle , password , have_polent ? & polent : NULL , entry -> principal ) ; if ( ret ) goto cleanup ; } if ( ( ret = krb5_timeofday ( handle -> context , & now ) ) ) goto cleanup ; kdb -> magic = KRB5_KDB_MAGIC_NUMBER ; kdb -> len = KRB5_KDB_V1_BASE_LENGTH ; if ( ( mask & KADM5_ATTRIBUTES ) ) kdb -> attributes = entry -> attributes ; else kdb -> attributes = handle -> params . flags ; if ( ( mask & KADM5_MAX_LIFE ) ) kdb -> max_life = entry -> max_life ; else kdb -> max_life = handle -> params . max_life ; if ( mask & KADM5_MAX_RLIFE ) kdb -> max_renewable_life = entry -> max_renewable_life ; else kdb -> max_renewable_life = handle -> params . max_rlife ; if ( ( mask & KADM5_PRINC_EXPIRE_TIME ) ) kdb -> expiration = entry -> princ_expire_time ; else kdb -> expiration = handle -> params . expiration ; kdb -> pw_expiration = 0 ; if ( have_polent ) { if ( polent . pw_max_life ) kdb -> pw_expiration = ts_incr ( now , polent . pw_max_life ) ; else kdb -> pw_expiration = 0 ; } if ( ( mask & KADM5_PW_EXPIRATION ) ) kdb -> pw_expiration = entry -> pw_expiration ; kdb -> last_success = 0 ; kdb -> last_failed = 0 ; kdb -> fail_auth_count = 0 ; ret = krb5_copy_principal ( handle -> context , entry -> principal , & kdb -> princ ) ; if ( ret ) goto cleanup ; if ( ( ret = krb5_dbe_update_last_pwd_change ( handle -> context , kdb , now ) ) ) goto cleanup ; if ( mask & KADM5_TL_DATA ) { for ( tl_data_tail = entry -> tl_data ; tl_data_tail ; tl_data_tail = tl_data_tail -> tl_data_next ) { ret = krb5_dbe_update_tl_data ( handle -> context , kdb , tl_data_tail ) ; if ( ret ) goto cleanup ; } } ret = apply_keysalt_policy ( handle , entry -> policy , n_ks_tuple , ks_tuple , & new_n_ks_tuple , & new_ks_tuple ) ; if ( ret ) goto cleanup ; ret = kdb_get_active_mkey ( handle , & act_kvno , & act_mkey ) ; if ( ret ) goto cleanup ; if ( mask & KADM5_KEY_DATA ) { assert ( entry -> n_key_data == 0 ) ; } else if ( password ) { ret = krb5_dbe_cpw ( handle -> context , act_mkey , new_ks_tuple , new_n_ks_tuple , password , ( mask & KADM5_KVNO ) ? entry -> kvno : 1 , FALSE , kdb ) ; } else { ret = krb5_dbe_crk ( handle -> context , & master_keyblock , new_ks_tuple , new_n_ks_tuple , FALSE , kdb ) ; } if ( ret ) goto cleanup ; ret = krb5_dbe_update_mkvno ( handle -> context , kdb , act_kvno ) ; if ( ret ) goto cleanup ; ret = k5_kadm5_hook_create ( handle -> context , handle -> hook_handles , KADM5_HOOK_STAGE_PRECOMMIT , entry , mask , new_n_ks_tuple , new_ks_tuple , password ) ; if ( ret ) goto cleanup ; adb . admin_history_kvno = INITIAL_HIST_KVNO ; if ( mask & KADM5_POLICY ) { adb . aux_attributes = KADM5_POLICY ; adb . policy = entry -> policy ; } kdb -> mask = mask | KADM5_KEY_DATA | KADM5_PRINCIPAL ; ret = kdb_put_entry ( handle , kdb , & adb ) ; ( void ) k5_kadm5_hook_create ( handle -> context , handle -> hook_handles , KADM5_HOOK_STAGE_POSTCOMMIT , entry , mask , new_n_ks_tuple , new_ks_tuple , password ) ; cleanup : free ( new_ks_tuple ) ; krb5_db_free_principal ( handle -> context , kdb ) ; if ( have_polent ) ( void ) kadm5_free_policy_ent ( handle -> lhandle , & polent ) ; return ret ; }
<S2SV_StartBug> int rose_parse_facilities ( unsigned char * p , <S2SV_EndBug> struct rose_facilities_struct * facilities ) { int facilities_len , len ; facilities_len = * p ++ ; <S2SV_StartBug> if ( facilities_len == 0 ) <S2SV_EndBug> return 0 ; <S2SV_StartBug> while ( facilities_len > 0 ) { <S2SV_EndBug> if ( * p == 0x00 ) { facilities_len -- ; p ++ ; switch ( * p ) { case FAC_NATIONAL : len = rose_parse_national ( p + 1 , facilities , facilities_len - 1 ) ; <S2SV_StartBug> if ( len < 0 ) <S2SV_EndBug> return 0 ; facilities_len -= len + 1 ; p += len + 1 ; break ; case FAC_CCITT : len = rose_parse_ccitt ( p + 1 , facilities , facilities_len - 1 ) ; <S2SV_StartBug> if ( len < 0 ) <S2SV_EndBug> return 0 ; facilities_len -= len + 1 ; p += len + 1 ; <S2SV_StartBug> break ; <S2SV_EndBug> default : printk ( KERN_DEBUG "ROSE:<S2SV_blank>rose_parse_facilities<S2SV_blank>-<S2SV_blank>unknown<S2SV_blank>facilities<S2SV_blank>family<S2SV_blank>%02X\\n" , * p ) ; facilities_len -- ; p ++ ; break ; } } else break ; } return 1 ; }
static __inline__ int scm_check_creds ( struct ucred * creds ) { const struct cred * cred = current_cred ( ) ; kuid_t uid = make_kuid ( cred -> user_ns , creds -> uid ) ; kgid_t gid = make_kgid ( cred -> user_ns , creds -> gid ) ; if ( ! uid_valid ( uid ) || ! gid_valid ( gid ) ) return - EINVAL ; <S2SV_StartBug> if ( ( creds -> pid == task_tgid_vnr ( current ) || nsown_capable ( CAP_SYS_ADMIN ) ) && <S2SV_EndBug> ( ( uid_eq ( uid , cred -> uid ) || uid_eq ( uid , cred -> euid ) || uid_eq ( uid , cred -> suid ) ) || nsown_capable ( CAP_SETUID ) ) && ( ( gid_eq ( gid , cred -> gid ) || gid_eq ( gid , cred -> egid ) || gid_eq ( gid , cred -> sgid ) ) || nsown_capable ( CAP_SETGID ) ) ) { return 0 ; } return - EPERM ; }
void MoveTo ( double x1 , double y1 ) { <S2SV_StartBug> outpos += <S2SV_EndBug> sprintf ( outpos , "\\n<S2SV_blank>%12.3f<S2SV_blank>%12.3f<S2SV_blank>m" , x1 , y1 ) ; <S2SV_StartBug> } <S2SV_EndBug>
static long __media_device_enum_links ( struct media_device * mdev , struct media_links_enum * links ) { struct media_entity * entity ; entity = find_entity ( mdev , links -> entity ) ; if ( entity == NULL ) return - EINVAL ; if ( links -> pads ) { unsigned int p ; for ( p = 0 ; p < entity -> num_pads ; p ++ ) { struct media_pad_desc pad ; <S2SV_StartBug> media_device_kpad_to_upad ( & entity -> pads [ p ] , & pad ) ; <S2SV_EndBug> if ( copy_to_user ( & links -> pads [ p ] , & pad , sizeof ( pad ) ) ) return - EFAULT ; } } if ( links -> links ) { struct media_link_desc __user * ulink ; unsigned int l ; for ( l = 0 , ulink = links -> links ; l < entity -> num_links ; l ++ ) { struct media_link_desc link ; if ( entity -> links [ l ] . source -> entity != entity ) continue ; <S2SV_StartBug> media_device_kpad_to_upad ( entity -> links [ l ] . source , <S2SV_EndBug> & link . source ) ; media_device_kpad_to_upad ( entity -> links [ l ] . sink , & link . sink ) ; link . flags = entity -> links [ l ] . flags ; if ( copy_to_user ( ulink , & link , sizeof ( * ulink ) ) ) return - EFAULT ; ulink ++ ; } } return 0 ; }
static int efx_probe_all ( struct efx_nic * efx ) { int rc ; rc = efx_probe_nic ( efx ) ; if ( rc ) { netif_err ( efx , probe , efx -> net_dev , "failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>NIC\\n" ) ; goto fail1 ; } rc = efx_probe_port ( efx ) ; if ( rc ) { netif_err ( efx , probe , efx -> net_dev , "failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>port\\n" ) ; goto fail2 ; } <S2SV_StartBug> efx -> rxq_entries = efx -> txq_entries = EFX_DEFAULT_DMAQ_SIZE ; <S2SV_EndBug> rc = efx_probe_channels ( efx ) ; if ( rc ) goto fail3 ; rc = efx_probe_filters ( efx ) ; if ( rc ) { netif_err ( efx , probe , efx -> net_dev , "failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>filter<S2SV_blank>tables\\n" ) ; goto fail4 ; } return 0 ; fail4 : efx_remove_channels ( efx ) ; fail3 : efx_remove_port ( efx ) ; fail2 : efx_remove_nic ( efx ) ; fail1 : return rc ; }
static int atalk_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t size , int flags ) { <S2SV_StartBug> struct sock * sk = sock -> sk ; <S2SV_EndBug> struct sockaddr_at * sat = ( struct sockaddr_at * ) msg -> msg_name ; struct ddpehdr * ddp ; int copied = 0 ; int offset = 0 ; int err = 0 ; struct sk_buff * skb ; skb = skb_recv_datagram ( sk , flags & ~ MSG_DONTWAIT , flags & MSG_DONTWAIT , & err ) ; lock_sock ( sk ) ; if ( ! skb ) goto out ; ddp = ddp_hdr ( skb ) ; copied = ntohs ( ddp -> deh_len_hops ) & 1023 ; if ( sk -> sk_type != SOCK_RAW ) { offset = sizeof ( * ddp ) ; copied -= offset ; } if ( copied > size ) { copied = size ; msg -> msg_flags |= MSG_TRUNC ; } err = skb_copy_datagram_iovec ( skb , offset , msg -> msg_iov , copied ) ; <S2SV_StartBug> if ( ! err ) { <S2SV_EndBug> if ( sat ) { sat -> sat_family = AF_APPLETALK ; sat -> sat_port = ddp -> deh_sport ; sat -> sat_addr . s_node = ddp -> deh_snode ; sat -> sat_addr . s_net = ddp -> deh_snet ; <S2SV_StartBug> } <S2SV_EndBug> msg -> msg_namelen = sizeof ( * sat ) ; } skb_free_datagram ( sk , skb ) ; out : release_sock ( sk ) ; return err ? : copied ; }
krb5_error_code krb5_ldap_put_principal ( krb5_context context , krb5_db_entry * entry , char * * db_args ) { int l = 0 , kerberos_principal_object_type = 0 ; unsigned int ntrees = 0 , tre = 0 ; krb5_error_code st = 0 , tempst = 0 ; LDAP * ld = NULL ; LDAPMessage * result = NULL , * ent = NULL ; char * * subtreelist = NULL ; char * user = NULL , * subtree = NULL , * principal_dn = NULL ; char * * values = NULL , * strval [ 10 ] = { NULL } , errbuf [ 1024 ] ; char * filtuser = NULL ; struct berval * * bersecretkey = NULL ; LDAPMod * * mods = NULL ; krb5_boolean create_standalone_prinicipal = FALSE ; krb5_boolean krb_identity_exists = FALSE , establish_links = FALSE ; char * standalone_principal_dn = NULL ; krb5_tl_data * tl_data = NULL ; krb5_key_data * * keys = NULL ; kdb5_dal_handle * dal_handle = NULL ; krb5_ldap_context * ldap_context = NULL ; krb5_ldap_server_handle * ldap_server_handle = NULL ; osa_princ_ent_rec princ_ent = { 0 } ; xargs_t xargs = { 0 } ; char * polname = NULL ; OPERATION optype ; krb5_boolean found_entry = FALSE ; krb5_clear_error_message ( context ) ; SETUP_CONTEXT ( ) ; if ( ldap_context -> lrparams == NULL || ldap_context -> container_dn == NULL ) return EINVAL ; GET_HANDLE ( ) ; if ( ! is_principal_in_realm ( ldap_context , entry -> princ ) ) { st = EINVAL ; k5_setmsg ( context , st , _ ( "Principal<S2SV_blank>does<S2SV_blank>not<S2SV_blank>belong<S2SV_blank>to<S2SV_blank>the<S2SV_blank>default<S2SV_blank>realm" ) ) ; goto cleanup ; } if ( ( ( st = krb5_unparse_name ( context , entry -> princ , & user ) ) != 0 ) || ( ( st = krb5_ldap_unparse_principal_name ( user ) ) != 0 ) ) goto cleanup ; filtuser = ldap_filter_correct ( user ) ; if ( filtuser == NULL ) { st = ENOMEM ; goto cleanup ; } if ( entry -> mask & KADM5_PRINCIPAL ) optype = ADD_PRINCIPAL ; else optype = MODIFY_PRINCIPAL ; if ( ( ( st = krb5_get_princ_type ( context , entry , & kerberos_principal_object_type ) ) != 0 ) || ( ( st = krb5_get_userdn ( context , entry , & principal_dn ) ) != 0 ) ) goto cleanup ; if ( ( st = process_db_args ( context , db_args , & xargs , optype ) ) != 0 ) goto cleanup ; if ( entry -> mask & KADM5_LOAD ) { unsigned int tree = 0 ; int numlentries = 0 ; char * filter = NULL ; if ( asprintf ( & filter , FILTER "%s))" , filtuser ) < 0 ) { filter = NULL ; st = ENOMEM ; goto cleanup ; } if ( ( st = krb5_get_subtree_info ( ldap_context , & subtreelist , & ntrees ) ) != 0 ) goto cleanup ; found_entry = FALSE ; for ( tree = 0 ; found_entry == FALSE && tree < ntrees ; ++ tree ) { if ( principal_dn == NULL ) { LDAP_SEARCH_1 ( subtreelist [ tree ] , ldap_context -> lrparams -> search_scope , filter , principal_attributes , IGNORE_STATUS ) ; } else { LDAP_SEARCH_1 ( principal_dn , LDAP_SCOPE_BASE , filter , principal_attributes , IGNORE_STATUS ) ; } if ( st == LDAP_SUCCESS ) { numlentries = ldap_count_entries ( ld , result ) ; if ( numlentries > 1 ) { free ( filter ) ; st = EINVAL ; k5_setmsg ( context , st , _ ( "operation<S2SV_blank>can<S2SV_blank>not<S2SV_blank>continue,<S2SV_blank>more<S2SV_blank>than<S2SV_blank>one<S2SV_blank>" "entry<S2SV_blank>with<S2SV_blank>principal<S2SV_blank>name<S2SV_blank>\\"%s\\"<S2SV_blank>found" ) , user ) ; goto cleanup ; } else if ( numlentries == 1 ) { found_entry = TRUE ; if ( principal_dn == NULL ) { ent = ldap_first_entry ( ld , result ) ; if ( ent != NULL ) { if ( ( principal_dn = ldap_get_dn ( ld , ent ) ) == NULL ) { ldap_get_option ( ld , LDAP_OPT_RESULT_CODE , & st ) ; st = set_ldap_error ( context , st , 0 ) ; free ( filter ) ; goto cleanup ; } } } } } else if ( st != LDAP_NO_SUCH_OBJECT ) { st = set_ldap_error ( context , st , 0 ) ; free ( filter ) ; goto cleanup ; } ldap_msgfree ( result ) ; result = NULL ; } free ( filter ) ; if ( found_entry == FALSE && principal_dn != NULL ) { create_standalone_prinicipal = TRUE ; standalone_principal_dn = strdup ( principal_dn ) ; CHECK_NULL ( standalone_principal_dn ) ; } } if ( principal_dn == NULL && xargs . dn == NULL ) { if ( entry -> princ -> length == 2 && entry -> princ -> data [ 0 ] . length == strlen ( "krbtgt" ) && strncmp ( entry -> princ -> data [ 0 ] . data , "krbtgt" , entry -> princ -> data [ 0 ] . length ) == 0 ) { subtree = strdup ( ldap_context -> lrparams -> realmdn ) ; } else if ( xargs . containerdn ) { if ( ( st = checkattributevalue ( ld , xargs . containerdn , NULL , NULL , NULL ) ) != 0 ) { if ( st == KRB5_KDB_NOENTRY || st == KRB5_KDB_CONSTRAINT_VIOLATION ) { int ost = st ; st = EINVAL ; k5_prependmsg ( context , ost , st , _ ( "\'%s\'<S2SV_blank>not<S2SV_blank>found" ) , xargs . containerdn ) ; } goto cleanup ; } subtree = strdup ( xargs . containerdn ) ; } else if ( ldap_context -> lrparams -> containerref && strlen ( ldap_context -> lrparams -> containerref ) != 0 ) { subtree = strdup ( ldap_context -> lrparams -> containerref ) ; } else { subtree = strdup ( ldap_context -> lrparams -> realmdn ) ; } CHECK_NULL ( subtree ) ; if ( asprintf ( & standalone_principal_dn , "krbprincipalname=%s,%s" , filtuser , subtree ) < 0 ) standalone_principal_dn = NULL ; CHECK_NULL ( standalone_principal_dn ) ; create_standalone_prinicipal = TRUE ; free ( subtree ) ; subtree = NULL ; } if ( xargs . dn_from_kbd == TRUE ) { int dnlen = 0 , subtreelen = 0 ; char * dn = NULL ; krb5_boolean outofsubtree = TRUE ; if ( xargs . dn != NULL ) { dn = xargs . dn ; } else if ( xargs . linkdn != NULL ) { dn = xargs . linkdn ; } else if ( standalone_principal_dn != NULL ) { dn = standalone_principal_dn ; } if ( subtreelist == NULL ) { st = krb5_get_subtree_info ( ldap_context , & subtreelist , & ntrees ) ; if ( st ) goto cleanup ; } for ( tre = 0 ; tre < ntrees ; ++ tre ) { if ( subtreelist [ tre ] == NULL || strlen ( subtreelist [ tre ] ) == 0 ) { outofsubtree = FALSE ; break ; } else { dnlen = strlen ( dn ) ; subtreelen = strlen ( subtreelist [ tre ] ) ; if ( ( dnlen >= subtreelen ) && ( strcasecmp ( ( dn + dnlen - subtreelen ) , subtreelist [ tre ] ) == 0 ) ) { outofsubtree = FALSE ; break ; } } } if ( outofsubtree == TRUE ) { st = EINVAL ; k5_setmsg ( context , st , _ ( "DN<S2SV_blank>is<S2SV_blank>out<S2SV_blank>of<S2SV_blank>the<S2SV_blank>realm<S2SV_blank>subtree" ) ) ; goto cleanup ; } if ( standalone_principal_dn == NULL ) { char * attributes [ ] = { "krbticketpolicyreference" , "krbprincipalname" , NULL } ; ldap_msgfree ( result ) ; result = NULL ; LDAP_SEARCH_1 ( dn , LDAP_SCOPE_BASE , 0 , attributes , IGNORE_STATUS ) ; if ( st == LDAP_SUCCESS ) { ent = ldap_first_entry ( ld , result ) ; if ( ent != NULL ) { if ( ( values = ldap_get_values ( ld , ent , "krbticketpolicyreference" ) ) != NULL ) { ldap_value_free ( values ) ; } if ( ( values = ldap_get_values ( ld , ent , "krbprincipalname" ) ) != NULL ) { krb_identity_exists = TRUE ; ldap_value_free ( values ) ; } } } else { st = set_ldap_error ( context , st , OP_SEARCH ) ; goto cleanup ; } } } if ( xargs . dn != NULL && krb_identity_exists == TRUE ) { st = EINVAL ; snprintf ( errbuf , sizeof ( errbuf ) , _ ( "ldap<S2SV_blank>object<S2SV_blank>is<S2SV_blank>already<S2SV_blank>kerberized" ) ) ; k5_setmsg ( context , st , "%s" , errbuf ) ; goto cleanup ; } if ( xargs . linkdn != NULL ) { if ( optype == MODIFY_PRINCIPAL && kerberos_principal_object_type != KDB_STANDALONE_PRINCIPAL_OBJECT ) { st = EINVAL ; snprintf ( errbuf , sizeof ( errbuf ) , _ ( "link<S2SV_blank>information<S2SV_blank>can<S2SV_blank>not<S2SV_blank>be<S2SV_blank>set/updated<S2SV_blank>as<S2SV_blank>the<S2SV_blank>" "kerberos<S2SV_blank>principal<S2SV_blank>belongs<S2SV_blank>to<S2SV_blank>an<S2SV_blank>ldap<S2SV_blank>object" ) ) ; k5_setmsg ( context , st , "%s" , errbuf ) ; goto cleanup ; } { char * * linkdns = NULL ; int j = 0 ; if ( ( st = krb5_get_linkdn ( context , entry , & linkdns ) ) != 0 ) { snprintf ( errbuf , sizeof ( errbuf ) , _ ( "Failed<S2SV_blank>getting<S2SV_blank>object<S2SV_blank>references" ) ) ; k5_setmsg ( context , st , "%s" , errbuf ) ; goto cleanup ; } if ( linkdns != NULL ) { st = EINVAL ; snprintf ( errbuf , sizeof ( errbuf ) , _ ( "kerberos<S2SV_blank>principal<S2SV_blank>is<S2SV_blank>already<S2SV_blank>linked<S2SV_blank>to<S2SV_blank>a<S2SV_blank>ldap<S2SV_blank>" "object" ) ) ; k5_setmsg ( context , st , "%s" , errbuf ) ; for ( j = 0 ; linkdns [ j ] != NULL ; ++ j ) free ( linkdns [ j ] ) ; free ( linkdns ) ; goto cleanup ; } } establish_links = TRUE ; } if ( entry -> mask & KADM5_LAST_SUCCESS ) { memset ( strval , 0 , sizeof ( strval ) ) ; if ( ( strval [ 0 ] = getstringtime ( entry -> last_success ) ) == NULL ) goto cleanup ; if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , "krbLastSuccessfulAuth" , LDAP_MOD_REPLACE , strval ) ) != 0 ) { free ( strval [ 0 ] ) ; goto cleanup ; } free ( strval [ 0 ] ) ; } if ( entry -> mask & KADM5_LAST_FAILED ) { memset ( strval , 0 , sizeof ( strval ) ) ; if ( ( strval [ 0 ] = getstringtime ( entry -> last_failed ) ) == NULL ) goto cleanup ; if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , "krbLastFailedAuth" , LDAP_MOD_REPLACE , strval ) ) != 0 ) { free ( strval [ 0 ] ) ; goto cleanup ; } free ( strval [ 0 ] ) ; } if ( entry -> mask & KADM5_FAIL_AUTH_COUNT ) { krb5_kvno fail_auth_count ; fail_auth_count = entry -> fail_auth_count ; if ( entry -> mask & KADM5_FAIL_AUTH_COUNT_INCREMENT ) fail_auth_count ++ ; st = krb5_add_int_mem_ldap_mod ( & mods , "krbLoginFailedCount" , LDAP_MOD_REPLACE , fail_auth_count ) ; if ( st != 0 ) goto cleanup ; } else if ( entry -> mask & KADM5_FAIL_AUTH_COUNT_INCREMENT ) { int attr_mask = 0 ; krb5_boolean has_fail_count ; st = krb5_get_attributes_mask ( context , entry , & attr_mask ) ; if ( st != 0 ) goto cleanup ; has_fail_count = ( ( attr_mask & KDB_FAIL_AUTH_COUNT_ATTR ) != 0 ) ; # ifdef LDAP_MOD_INCREMENT if ( ldap_server_handle -> server_info -> modify_increment && has_fail_count ) { st = krb5_add_int_mem_ldap_mod ( & mods , "krbLoginFailedCount" , LDAP_MOD_INCREMENT , 1 ) ; if ( st != 0 ) goto cleanup ; } else { # endif if ( has_fail_count ) { st = krb5_add_int_mem_ldap_mod ( & mods , "krbLoginFailedCount" , LDAP_MOD_DELETE , entry -> fail_auth_count ) ; if ( st != 0 ) goto cleanup ; } st = krb5_add_int_mem_ldap_mod ( & mods , "krbLoginFailedCount" , LDAP_MOD_ADD , entry -> fail_auth_count + 1 ) ; if ( st != 0 ) goto cleanup ; # ifdef LDAP_MOD_INCREMENT } # endif } else if ( optype == ADD_PRINCIPAL ) { st = krb5_add_int_mem_ldap_mod ( & mods , "krbLoginFailedCount" , LDAP_MOD_ADD , 0 ) ; } if ( entry -> mask & KADM5_MAX_LIFE ) { if ( ( st = krb5_add_int_mem_ldap_mod ( & mods , "krbmaxticketlife" , LDAP_MOD_REPLACE , entry -> max_life ) ) != 0 ) goto cleanup ; } if ( entry -> mask & KADM5_MAX_RLIFE ) { if ( ( st = krb5_add_int_mem_ldap_mod ( & mods , "krbmaxrenewableage" , LDAP_MOD_REPLACE , entry -> max_renewable_life ) ) != 0 ) goto cleanup ; } if ( entry -> mask & KADM5_ATTRIBUTES ) { if ( ( st = krb5_add_int_mem_ldap_mod ( & mods , "krbticketflags" , LDAP_MOD_REPLACE , entry -> attributes ) ) != 0 ) goto cleanup ; } if ( entry -> mask & KADM5_PRINCIPAL ) { memset ( strval , 0 , sizeof ( strval ) ) ; strval [ 0 ] = user ; if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , "krbprincipalname" , LDAP_MOD_REPLACE , strval ) ) != 0 ) goto cleanup ; } if ( entry -> mask & KADM5_PRINC_EXPIRE_TIME ) { memset ( strval , 0 , sizeof ( strval ) ) ; if ( ( strval [ 0 ] = getstringtime ( entry -> expiration ) ) == NULL ) goto cleanup ; if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , "krbprincipalexpiration" , LDAP_MOD_REPLACE , strval ) ) != 0 ) { free ( strval [ 0 ] ) ; goto cleanup ; } free ( strval [ 0 ] ) ; } if ( entry -> mask & KADM5_PW_EXPIRATION ) { memset ( strval , 0 , sizeof ( strval ) ) ; if ( ( strval [ 0 ] = getstringtime ( entry -> pw_expiration ) ) == NULL ) goto cleanup ; if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , "krbpasswordexpiration" , LDAP_MOD_REPLACE , strval ) ) != 0 ) { free ( strval [ 0 ] ) ; goto cleanup ; } free ( strval [ 0 ] ) ; } if ( entry -> mask & KADM5_POLICY ) { memset ( & princ_ent , 0 , sizeof ( princ_ent ) ) ; for ( tl_data = entry -> tl_data ; tl_data ; tl_data = tl_data -> tl_data_next ) { if ( tl_data -> tl_data_type == KRB5_TL_KADM_DATA ) { if ( ( st = krb5_lookup_tl_kadm_data ( tl_data , & princ_ent ) ) != 0 ) { goto cleanup ; } break ; } } if ( princ_ent . aux_attributes & KADM5_POLICY ) { memset ( strval , 0 , sizeof ( strval ) ) ; if ( ( st = krb5_ldap_name_to_policydn ( context , princ_ent . policy , & polname ) ) != 0 ) goto cleanup ; strval [ 0 ] = polname ; if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , "krbpwdpolicyreference" , LDAP_MOD_REPLACE , strval ) ) != 0 ) goto cleanup ; } else { st = EINVAL ; k5_setmsg ( context , st , "Password<S2SV_blank>policy<S2SV_blank>value<S2SV_blank>null" ) ; goto cleanup ; } } else if ( entry -> mask & KADM5_LOAD && found_entry == TRUE ) { if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , "krbpwdpolicyreference" , LDAP_MOD_REPLACE , NULL ) ) != 0 ) goto cleanup ; } if ( entry -> mask & KADM5_POLICY_CLR ) { if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , "krbpwdpolicyreference" , LDAP_MOD_DELETE , NULL ) ) != 0 ) goto cleanup ; } if ( entry -> mask & KADM5_KEY_DATA || entry -> mask & KADM5_KVNO ) { krb5_kvno mkvno ; if ( ( st = krb5_dbe_lookup_mkvno ( context , entry , & mkvno ) ) != 0 ) goto cleanup ; bersecretkey = krb5_encode_krbsecretkey ( entry -> key_data , entry -> n_key_data , mkvno ) ; <S2SV_StartBug> if ( ( st = krb5_add_ber_mem_ldap_mod ( & mods , "krbprincipalkey" , <S2SV_EndBug> <S2SV_StartBug> LDAP_MOD_REPLACE | LDAP_MOD_BVALUES , bersecretkey ) ) != 0 ) <S2SV_EndBug> goto cleanup ; if ( ! ( entry -> mask & KADM5_PRINCIPAL ) ) { memset ( strval , 0 , sizeof ( strval ) ) ; if ( ( strval [ 0 ] = getstringtime ( entry -> pw_expiration ) ) == NULL ) goto cleanup ; if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , "krbpasswordexpiration" , LDAP_MOD_REPLACE , strval ) ) != 0 ) { free ( strval [ 0 ] ) ; goto cleanup ; } free ( strval [ 0 ] ) ; } { krb5_timestamp last_pw_changed ; if ( ( st = krb5_dbe_lookup_last_pwd_change ( context , entry , & last_pw_changed ) ) != 0 ) goto cleanup ; memset ( strval , 0 , sizeof ( strval ) ) ; if ( ( strval [ 0 ] = getstringtime ( last_pw_changed ) ) == NULL ) goto cleanup ; if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , "krbLastPwdChange" , LDAP_MOD_REPLACE , strval ) ) != 0 ) { free ( strval [ 0 ] ) ; goto cleanup ; } free ( strval [ 0 ] ) ; } } if ( entry -> tl_data != NULL ) { int count = 0 ; struct berval * * ber_tl_data = NULL ; krb5_tl_data * ptr ; krb5_timestamp unlock_time ; for ( ptr = entry -> tl_data ; ptr != NULL ; ptr = ptr -> tl_data_next ) { if ( ptr -> tl_data_type == KRB5_TL_LAST_PWD_CHANGE # ifdef SECURID || ptr -> tl_data_type == KRB5_TL_DB_ARGS # endif || ptr -> tl_data_type == KRB5_TL_KADM_DATA || ptr -> tl_data_type == KDB_TL_USER_INFO || ptr -> tl_data_type == KRB5_TL_CONSTRAINED_DELEGATION_ACL || ptr -> tl_data_type == KRB5_TL_LAST_ADMIN_UNLOCK ) continue ; count ++ ; } if ( count != 0 ) { int j ; ber_tl_data = ( struct berval * * ) calloc ( count + 1 , sizeof ( struct berval * ) ) ; if ( ber_tl_data == NULL ) { st = ENOMEM ; goto cleanup ; } for ( j = 0 , ptr = entry -> tl_data ; ptr != NULL ; ptr = ptr -> tl_data_next ) { if ( ptr -> tl_data_type == KRB5_TL_LAST_PWD_CHANGE # ifdef SECURID || ptr -> tl_data_type == KRB5_TL_DB_ARGS # endif || ptr -> tl_data_type == KRB5_TL_KADM_DATA || ptr -> tl_data_type == KDB_TL_USER_INFO || ptr -> tl_data_type == KRB5_TL_CONSTRAINED_DELEGATION_ACL || ptr -> tl_data_type == KRB5_TL_LAST_ADMIN_UNLOCK ) continue ; if ( ( st = tl_data2berval ( ptr , & ber_tl_data [ j ] ) ) != 0 ) break ; j ++ ; } if ( st == 0 ) { ber_tl_data [ count ] = NULL ; st = krb5_add_ber_mem_ldap_mod ( & mods , "krbExtraData" , LDAP_MOD_REPLACE | LDAP_MOD_BVALUES , ber_tl_data ) ; } for ( j = 0 ; ber_tl_data [ j ] != NULL ; j ++ ) { free ( ber_tl_data [ j ] -> bv_val ) ; free ( ber_tl_data [ j ] ) ; } free ( ber_tl_data ) ; if ( st != 0 ) goto cleanup ; } if ( ( st = krb5_dbe_lookup_last_admin_unlock ( context , entry , & unlock_time ) ) != 0 ) goto cleanup ; if ( unlock_time != 0 ) { memset ( strval , 0 , sizeof ( strval ) ) ; if ( ( strval [ 0 ] = getstringtime ( unlock_time ) ) == NULL ) goto cleanup ; if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , "krbLastAdminUnlock" , LDAP_MOD_REPLACE , strval ) ) != 0 ) { free ( strval [ 0 ] ) ; goto cleanup ; } free ( strval [ 0 ] ) ; } } if ( xargs . tktpolicydn != NULL ) { int tmask = 0 ; if ( strlen ( xargs . tktpolicydn ) != 0 ) { st = checkattributevalue ( ld , xargs . tktpolicydn , "objectclass" , policyclass , & tmask ) ; CHECK_CLASS_VALIDITY ( st , tmask , _ ( "ticket<S2SV_blank>policy<S2SV_blank>object<S2SV_blank>value:<S2SV_blank>" ) ) ; strval [ 0 ] = xargs . tktpolicydn ; strval [ 1 ] = NULL ; if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , "krbticketpolicyreference" , LDAP_MOD_REPLACE , strval ) ) != 0 ) goto cleanup ; } else { if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , "krbticketpolicyreference" , LDAP_MOD_DELETE , NULL ) ) != 0 ) goto cleanup ; } } if ( establish_links == TRUE ) { memset ( strval , 0 , sizeof ( strval ) ) ; strval [ 0 ] = xargs . linkdn ; if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , "krbObjectReferences" , LDAP_MOD_REPLACE , strval ) ) != 0 ) goto cleanup ; } if ( mods == NULL ) goto cleanup ; if ( create_standalone_prinicipal == TRUE ) { memset ( strval , 0 , sizeof ( strval ) ) ; strval [ 0 ] = "krbprincipal" ; strval [ 1 ] = "krbprincipalaux" ; strval [ 2 ] = "krbTicketPolicyAux" ; if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , "objectclass" , LDAP_MOD_ADD , strval ) ) != 0 ) goto cleanup ; st = ldap_add_ext_s ( ld , standalone_principal_dn , mods , NULL , NULL ) ; if ( st == LDAP_ALREADY_EXISTS && entry -> mask & KADM5_LOAD ) { st = ldap_delete_ext_s ( ld , standalone_principal_dn , NULL , NULL ) ; if ( st != LDAP_SUCCESS ) { snprintf ( errbuf , sizeof ( errbuf ) , _ ( "Principal<S2SV_blank>delete<S2SV_blank>failed<S2SV_blank>(trying<S2SV_blank>to<S2SV_blank>replace<S2SV_blank>" "entry):<S2SV_blank>%s" ) , ldap_err2string ( st ) ) ; st = translate_ldap_error ( st , OP_ADD ) ; k5_setmsg ( context , st , "%s" , errbuf ) ; goto cleanup ; } else { st = ldap_add_ext_s ( ld , standalone_principal_dn , mods , NULL , NULL ) ; } } if ( st != LDAP_SUCCESS ) { snprintf ( errbuf , sizeof ( errbuf ) , _ ( "Principal<S2SV_blank>add<S2SV_blank>failed:<S2SV_blank>%s" ) , ldap_err2string ( st ) ) ; st = translate_ldap_error ( st , OP_ADD ) ; k5_setmsg ( context , st , "%s" , errbuf ) ; goto cleanup ; } } else { { char * attrvalues [ ] = { "krbprincipalaux" , "krbTicketPolicyAux" , NULL } ; int p , q , r = 0 , amask = 0 ; if ( ( st = checkattributevalue ( ld , ( xargs . dn ) ? xargs . dn : principal_dn , "objectclass" , attrvalues , & amask ) ) != 0 ) goto cleanup ; memset ( strval , 0 , sizeof ( strval ) ) ; for ( p = 1 , q = 0 ; p <= 2 ; p <<= 1 , ++ q ) { if ( ( p & amask ) == 0 ) strval [ r ++ ] = attrvalues [ q ] ; } if ( r != 0 ) { if ( ( st = krb5_add_str_mem_ldap_mod ( & mods , "objectclass" , LDAP_MOD_ADD , strval ) ) != 0 ) goto cleanup ; } } if ( xargs . dn != NULL ) st = ldap_modify_ext_s ( ld , xargs . dn , mods , NULL , NULL ) ; else st = ldap_modify_ext_s ( ld , principal_dn , mods , NULL , NULL ) ; if ( st != LDAP_SUCCESS ) { snprintf ( errbuf , sizeof ( errbuf ) , _ ( "User<S2SV_blank>modification<S2SV_blank>failed:<S2SV_blank>%s" ) , ldap_err2string ( st ) ) ; st = translate_ldap_error ( st , OP_MOD ) ; k5_setmsg ( context , st , "%s" , errbuf ) ; goto cleanup ; } if ( entry -> mask & KADM5_FAIL_AUTH_COUNT_INCREMENT ) entry -> fail_auth_count ++ ; } cleanup : if ( user ) free ( user ) ; if ( filtuser ) free ( filtuser ) ; free_xargs ( xargs ) ; if ( standalone_principal_dn ) free ( standalone_principal_dn ) ; if ( principal_dn ) free ( principal_dn ) ; if ( polname != NULL ) free ( polname ) ; for ( tre = 0 ; tre < ntrees ; tre ++ ) free ( subtreelist [ tre ] ) ; free ( subtreelist ) ; if ( subtree ) free ( subtree ) ; if ( bersecretkey ) { for ( l = 0 ; bersecretkey [ l ] ; ++ l ) { if ( bersecretkey [ l ] -> bv_val ) free ( bersecretkey [ l ] -> bv_val ) ; free ( bersecretkey [ l ] ) ; } free ( bersecretkey ) ; } if ( keys ) free ( keys ) ; ldap_mods_free ( mods , 1 ) ; ldap_osa_free_princ_ent ( & princ_ent ) ; ldap_msgfree ( result ) ; krb5_ldap_put_handle_to_pool ( ldap_context , ldap_server_handle ) ; return ( st ) ; }
static int jpc_pi_nextcprl ( register jpc_pi_t * pi ) { int rlvlno ; jpc_pirlvl_t * pirlvl ; jpc_pchg_t * pchg ; int prchind ; int prcvind ; int * prclyrno ; uint_fast32_t trx0 ; uint_fast32_t try0 ; uint_fast32_t r ; uint_fast32_t rpx ; uint_fast32_t rpy ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { goto skip ; } else { pi -> prgvolfirst = 0 ; } for ( pi -> compno = pchg -> compnostart , pi -> picomp = & pi -> picomps [ pi -> compno ] ; pi -> compno < JAS_CAST ( int , pchg -> compnoend ) && pi -> compno < pi -> numcomps ; ++ pi -> compno , ++ pi -> picomp ) { <S2SV_StartBug> pirlvl = pi -> picomp -> pirlvls ; <S2SV_EndBug> pi -> xstep = pi -> picomp -> hsamp * ( JAS_CAST ( uint_fast32_t , 1 ) << ( pirlvl -> prcwidthexpn + pi -> picomp -> numrlvls - 1 ) ) ; pi -> ystep = pi -> picomp -> vsamp * ( JAS_CAST ( uint_fast32_t , 1 ) << ( pirlvl -> prcheightexpn + pi -> picomp -> numrlvls - 1 ) ) ; for ( rlvlno = 1 , pirlvl = & pi -> picomp -> pirlvls [ 1 ] ; rlvlno < pi -> picomp -> numrlvls ; ++ rlvlno , ++ pirlvl ) { pi -> xstep = JAS_MIN ( pi -> xstep , pi -> picomp -> hsamp * ( JAS_CAST ( uint_fast32_t , 1 ) << ( pirlvl -> prcwidthexpn + pi -> picomp -> numrlvls - rlvlno - 1 ) ) ) ; pi -> ystep = JAS_MIN ( pi -> ystep , pi -> picomp -> vsamp * ( JAS_CAST ( uint_fast32_t , 1 ) << ( pirlvl -> prcheightexpn + pi -> picomp -> numrlvls - rlvlno - 1 ) ) ) ; } for ( pi -> y = pi -> ystart ; pi -> y < pi -> yend ; pi -> y += pi -> ystep - ( pi -> y % pi -> ystep ) ) { for ( pi -> x = pi -> xstart ; pi -> x < pi -> xend ; pi -> x += pi -> xstep - ( pi -> x % pi -> xstep ) ) { for ( pi -> rlvlno = pchg -> rlvlnostart , pi -> pirlvl = & pi -> picomp -> pirlvls [ pi -> rlvlno ] ; pi -> rlvlno < pi -> picomp -> numrlvls && pi -> rlvlno < pchg -> rlvlnoend ; ++ pi -> rlvlno , ++ pi -> pirlvl ) { if ( pi -> pirlvl -> numprcs == 0 ) { continue ; } r = pi -> picomp -> numrlvls - 1 - pi -> rlvlno ; trx0 = JPC_CEILDIV ( pi -> xstart , pi -> picomp -> hsamp << r ) ; try0 = JPC_CEILDIV ( pi -> ystart , pi -> picomp -> vsamp << r ) ; rpx = r + pi -> pirlvl -> prcwidthexpn ; rpy = r + pi -> pirlvl -> prcheightexpn ; <S2SV_StartBug> if ( ( ( pi -> x == pi -> xstart && ( ( trx0 << r ) % ( 1 << rpx ) ) ) || <S2SV_EndBug> ! ( pi -> x % ( pi -> picomp -> hsamp << rpx ) ) ) && <S2SV_StartBug> ( ( pi -> y == pi -> ystart && ( ( try0 << r ) % ( 1 << rpy ) ) ) || <S2SV_EndBug> ! ( pi -> y % ( pi -> picomp -> vsamp << rpy ) ) ) ) { prchind = JPC_FLOORDIVPOW2 ( JPC_CEILDIV ( pi -> x , pi -> picomp -> hsamp << r ) , pi -> pirlvl -> prcwidthexpn ) - JPC_FLOORDIVPOW2 ( trx0 , pi -> pirlvl -> prcwidthexpn ) ; prcvind = JPC_FLOORDIVPOW2 ( JPC_CEILDIV ( pi -> y , pi -> picomp -> vsamp << r ) , pi -> pirlvl -> prcheightexpn ) - JPC_FLOORDIVPOW2 ( try0 , pi -> pirlvl -> prcheightexpn ) ; pi -> prcno = prcvind * pi -> pirlvl -> numhprcs + prchind ; assert ( pi -> prcno < pi -> pirlvl -> numprcs ) ; for ( pi -> lyrno = 0 ; pi -> lyrno < pi -> numlyrs && pi -> lyrno < JAS_CAST ( int , pchg -> lyrnoend ) ; ++ pi -> lyrno ) { prclyrno = & pi -> pirlvl -> prclyrnos [ pi -> prcno ] ; if ( pi -> lyrno >= * prclyrno ) { ++ ( * prclyrno ) ; return 0 ; } skip : ; } } } } } } return 1 ; }
static int __get_data_block ( struct inode * inode , sector_t iblock , struct buffer_head * bh , int create , int flag , pgoff_t * next_pgofs ) { struct f2fs_map_blocks map ; int err ; map . m_lblk = iblock ; map . m_len = bh -> b_size >> inode -> i_blkbits ; map . m_next_pgofs = next_pgofs ; err = f2fs_map_blocks ( inode , & map , create , flag ) ; if ( ! err ) { map_bh ( bh , inode -> i_sb , map . m_pblk ) ; bh -> b_state = ( bh -> b_state & ~ F2FS_MAP_FLAGS ) | map . m_flags ; <S2SV_StartBug> bh -> b_size = map . m_len << inode -> i_blkbits ; <S2SV_EndBug> } return err ; }
static AVFrame * get_video_buffer ( AVFilterLink * inlink , int w , int h ) { PadContext * s = inlink -> dst -> priv ; AVFrame * frame = ff_get_video_buffer ( inlink -> dst -> outputs [ 0 ] , w + ( s -> w - s -> in_w ) , h + ( s -> h - s -> in_h ) ) ; int plane ; if ( ! frame ) return NULL ; frame -> width = w ; frame -> height = h ; <S2SV_StartBug> for ( plane = 0 ; plane < 4 && frame -> data [ plane ] ; plane ++ ) { <S2SV_EndBug> int hsub = s -> draw . hsub [ plane ] ; int vsub = s -> draw . vsub [ plane ] ; frame -> data [ plane ] += ( s -> x >> hsub ) * s -> draw . pixelstep [ plane ] + ( s -> y >> vsub ) * frame -> linesize [ plane ] ; } return frame ; }
static enum fetch_step vbf_stp_error ( struct worker * wrk , struct busyobj * bo ) { ssize_t l , ll , o ; double now ; uint8_t * ptr ; struct vsb * synth_body ; CHECK_OBJ_NOTNULL ( wrk , WORKER_MAGIC ) ; CHECK_OBJ_NOTNULL ( bo , BUSYOBJ_MAGIC ) ; CHECK_OBJ_NOTNULL ( bo -> fetch_objcore , OBJCORE_MAGIC ) ; AN ( bo -> fetch_objcore -> flags & OC_F_BUSY ) ; assert ( bo -> director_state == DIR_S_NULL ) ; wrk -> stats -> fetch_failed ++ ; now = W_TIM_real ( wrk ) ; VSLb_ts_busyobj ( bo , "Error" , now ) ; if ( bo -> fetch_objcore -> stobj -> stevedore != NULL ) ObjFreeObj ( bo -> wrk , bo -> fetch_objcore ) ; HTTP_Setup ( bo -> beresp , bo -> ws , bo -> vsl , SLT_BerespMethod ) ; http_PutResponse ( bo -> beresp , "HTTP/1.1" , 503 , "Backend<S2SV_blank>fetch<S2SV_blank>failed" ) ; http_TimeHeader ( bo -> beresp , "Date:<S2SV_blank>" , now ) ; http_SetHeader ( bo -> beresp , "Server:<S2SV_blank>Varnish" ) ; bo -> fetch_objcore -> t_origin = now ; if ( ! VTAILQ_EMPTY ( & bo -> fetch_objcore -> objhead -> waitinglist ) ) { bo -> fetch_objcore -> ttl = 1 ; bo -> fetch_objcore -> grace = 5 ; bo -> fetch_objcore -> keep = 5 ; } else { bo -> fetch_objcore -> ttl = 0 ; bo -> fetch_objcore -> grace = 0 ; bo -> fetch_objcore -> keep = 0 ; } synth_body = VSB_new_auto ( ) ; AN ( synth_body ) ; VCL_backend_error_method ( bo -> vcl , wrk , NULL , bo , synth_body ) ; AZ ( VSB_finish ( synth_body ) ) ; if ( wrk -> handling == VCL_RET_ABANDON || wrk -> handling == VCL_RET_FAIL ) { VSB_destroy ( & synth_body ) ; return ( F_STP_FAIL ) ; } if ( wrk -> handling == VCL_RET_RETRY ) { VSB_destroy ( & synth_body ) ; if ( bo -> retries ++ < cache_param -> max_retries ) return ( F_STP_RETRY ) ; VSLb ( bo -> vsl , SLT_VCL_Error , "Too<S2SV_blank>many<S2SV_blank>retries,<S2SV_blank>failing" ) ; return ( F_STP_FAIL ) ; } assert ( wrk -> handling == VCL_RET_DELIVER ) ; bo -> vfc -> bo = bo ; bo -> vfc -> wrk = bo -> wrk ; bo -> vfc -> oc = bo -> fetch_objcore ; bo -> vfc -> http = bo -> beresp ; bo -> vfc -> esi_req = bo -> bereq ; if ( vbf_beresp2obj ( bo ) ) { ( void ) VFP_Error ( bo -> vfc , "Could<S2SV_blank>not<S2SV_blank>get<S2SV_blank>storage" ) ; VSB_destroy ( & synth_body ) ; return ( F_STP_FAIL ) ; } ll = VSB_len ( synth_body ) ; o = 0 ; while ( ll > 0 ) { l = ll ; if ( VFP_GetStorage ( bo -> vfc , & l , & ptr ) != VFP_OK ) break ; <S2SV_StartBug> memcpy ( ptr , VSB_data ( synth_body ) + o , l ) ; <S2SV_EndBug> VFP_Extend ( bo -> vfc , l ) ; ll -= l ; o += l ; } AZ ( ObjSetU64 ( wrk , bo -> fetch_objcore , OA_LEN , o ) ) ; VSB_destroy ( & synth_body ) ; HSH_Unbusy ( wrk , bo -> fetch_objcore ) ; ObjSetState ( wrk , bo -> fetch_objcore , BOS_FINISHED ) ; return ( F_STP_DONE ) ; }
static int pvc_getname ( struct socket * sock , struct sockaddr * sockaddr , int * sockaddr_len , int peer ) { struct sockaddr_atmpvc * addr ; struct atm_vcc * vcc = ATM_SD ( sock ) ; if ( ! vcc -> dev || ! test_bit ( ATM_VF_ADDR , & vcc -> flags ) ) return - ENOTCONN ; * sockaddr_len = sizeof ( struct sockaddr_atmpvc ) ; addr = ( struct sockaddr_atmpvc * ) sockaddr ; <S2SV_StartBug> addr -> sap_family = AF_ATMPVC ; <S2SV_EndBug> addr -> sap_addr . itf = vcc -> dev -> number ; addr -> sap_addr . vpi = vcc -> vpi ; addr -> sap_addr . vci = vcc -> vci ; return 0 ; }
void __fput_sync ( struct file * file ) { if ( atomic_long_dec_and_test ( & file -> f_count ) ) { struct task_struct * task = current ; <S2SV_StartBug> file_sb_list_del ( file ) ; <S2SV_EndBug> BUG_ON ( ! ( task -> flags & PF_KTHREAD ) ) ; __fput ( file ) ; } }
static int filter_frame ( AVFilterLink * inlink , AVFrame * in ) { PadContext * s = inlink -> dst -> priv ; AVFrame * out ; int needs_copy = frame_needs_copy ( s , in ) ; if ( needs_copy ) { av_log ( inlink -> dst , AV_LOG_DEBUG , "Direct<S2SV_blank>padding<S2SV_blank>impossible<S2SV_blank>allocating<S2SV_blank>new<S2SV_blank>frame\\n" ) ; out = ff_get_video_buffer ( inlink -> dst -> outputs [ 0 ] , FFMAX ( inlink -> w , s -> w ) , FFMAX ( inlink -> h , s -> h ) ) ; if ( ! out ) { av_frame_free ( & in ) ; return AVERROR ( ENOMEM ) ; } av_frame_copy_props ( out , in ) ; } else { int i ; out = in ; <S2SV_StartBug> for ( i = 0 ; i < 4 && out -> data [ i ] ; i ++ ) { <S2SV_EndBug> int hsub = s -> draw . hsub [ i ] ; int vsub = s -> draw . vsub [ i ] ; out -> data [ i ] -= ( s -> x >> hsub ) * s -> draw . pixelstep [ i ] + ( s -> y >> vsub ) * out -> linesize [ i ] ; } } if ( s -> y ) { ff_fill_rectangle ( & s -> draw , & s -> color , out -> data , out -> linesize , 0 , 0 , s -> w , s -> y ) ; } if ( s -> h > s -> y + s -> in_h ) { ff_fill_rectangle ( & s -> draw , & s -> color , out -> data , out -> linesize , 0 , s -> y + s -> in_h , s -> w , s -> h - s -> y - s -> in_h ) ; } ff_fill_rectangle ( & s -> draw , & s -> color , out -> data , out -> linesize , 0 , s -> y , s -> x , in -> height ) ; if ( needs_copy ) { ff_copy_rectangle2 ( & s -> draw , out -> data , out -> linesize , in -> data , in -> linesize , s -> x , s -> y , 0 , 0 , in -> width , in -> height ) ; } ff_fill_rectangle ( & s -> draw , & s -> color , out -> data , out -> linesize , s -> x + s -> in_w , s -> y , s -> w - s -> x - s -> in_w , in -> height ) ; out -> width = s -> w ; out -> height = s -> h ; if ( in != out ) av_frame_free ( & in ) ; return ff_filter_frame ( inlink -> dst -> outputs [ 0 ] , out ) ; }
WORD32 ih264d_cavlc_4x4res_block_totalcoeff_11to16 ( UWORD32 u4_isdc , UWORD32 u4_total_coeff_trail_one , dec_bit_stream_t * ps_bitstrm ) { UWORD32 u4_total_zeroes ; WORD32 i ; UWORD32 * pu4_bitstrm_buf = ps_bitstrm -> pu4_buffer ; UWORD32 u4_bitstream_offset = ps_bitstrm -> u4_ofst ; UWORD32 u4_trailing_ones = u4_total_coeff_trail_one & 0xFFFF ; UWORD32 u4_total_coeff = u4_total_coeff_trail_one >> 16 ; <S2SV_StartBug> WORD16 i2_level_arr [ 16 ] ; <S2SV_EndBug> tu_sblk4x4_coeff_data_t * ps_tu_4x4 ; WORD16 * pi2_coeff_data ; dec_struct_t * ps_dec = ( dec_struct_t * ) ps_bitstrm -> pv_codec_handle ; ps_tu_4x4 = ( tu_sblk4x4_coeff_data_t * ) ps_dec -> pv_parse_tu_coeff_data ; ps_tu_4x4 -> u2_sig_coeff_map = 0 ; pi2_coeff_data = & ps_tu_4x4 -> ai2_level [ 0 ] ; i = u4_total_coeff - 1 ; if ( u4_trailing_ones ) { UWORD32 u4_signs , u4_cnt = u4_trailing_ones ; WORD16 ( * ppi2_trlone_lkup ) [ 3 ] = ( WORD16 ( * ) [ 3 ] ) gai2_ih264d_trailing_one_level ; WORD16 * pi2_trlone_lkup ; GETBITS ( u4_signs , u4_bitstream_offset , pu4_bitstrm_buf , u4_cnt ) ; pi2_trlone_lkup = ppi2_trlone_lkup [ ( 1 << u4_cnt ) - 2 + u4_signs ] ; while ( u4_cnt -- ) i2_level_arr [ i -- ] = * pi2_trlone_lkup ++ ; } if ( i >= 0 ) { UWORD32 u4_lev_suffix , u4_suffix_len , u4_lev_suffix_size ; UWORD16 u2_lev_code , u2_abs_value ; UWORD32 u4_lev_prefix ; if ( u4_trailing_ones < 3 ) { FIND_ONE_IN_STREAM_32 ( u4_lev_prefix , u4_bitstream_offset , pu4_bitstrm_buf ) ; u4_lev_suffix_size = ( 15 <= u4_lev_prefix ) ? ( u4_lev_prefix - 3 ) : 1 ; GETBITS ( u4_lev_suffix , u4_bitstream_offset , pu4_bitstrm_buf , u4_lev_suffix_size ) ; u2_lev_code = 2 + ( MIN ( u4_lev_prefix , 15 ) << 1 ) + u4_lev_suffix ; if ( 16 <= u4_lev_prefix ) { u2_lev_code += ( ( 1 << ( u4_lev_prefix - 3 ) ) - 4096 ) ; } } else { FIND_ONE_IN_STREAM_32 ( u4_lev_prefix , u4_bitstream_offset , pu4_bitstrm_buf ) ; u2_lev_code = MIN ( 15 , u4_lev_prefix ) ; u2_lev_code += ( 3 == u4_trailing_ones ) ? 0 : ( 2 ) ; if ( 14 == u4_lev_prefix ) u4_lev_suffix_size = 4 ; else if ( 15 <= u4_lev_prefix ) { u2_lev_code += 15 ; u4_lev_suffix_size = ( u4_lev_prefix - 3 ) ; } else u4_lev_suffix_size = 0 ; if ( 16 <= u4_lev_prefix ) { u2_lev_code += ( ( 1 << ( u4_lev_prefix - 3 ) ) - 4096 ) ; } if ( u4_lev_suffix_size ) { GETBITS ( u4_lev_suffix , u4_bitstream_offset , pu4_bitstrm_buf , u4_lev_suffix_size ) ; u2_lev_code += u4_lev_suffix ; } } u2_abs_value = ( u2_lev_code + 2 ) >> 1 ; i2_level_arr [ i -- ] = ( u2_lev_code & 1 ) ? - u2_abs_value : u2_abs_value ; u4_suffix_len = ( u2_abs_value > 3 ) ? 2 : 1 ; while ( i >= 0 ) { FIND_ONE_IN_STREAM_32 ( u4_lev_prefix , u4_bitstream_offset , pu4_bitstrm_buf ) ; u4_lev_suffix_size = ( 15 <= u4_lev_prefix ) ? ( u4_lev_prefix - 3 ) : u4_suffix_len ; GETBITS ( u4_lev_suffix , u4_bitstream_offset , pu4_bitstrm_buf , u4_lev_suffix_size ) ; u2_lev_code = ( MIN ( 15 , u4_lev_prefix ) << u4_suffix_len ) + u4_lev_suffix ; if ( 16 <= u4_lev_prefix ) { u2_lev_code += ( ( 1 << ( u4_lev_prefix - 3 ) ) - 4096 ) ; } u2_abs_value = ( u2_lev_code + 2 ) >> 1 ; i2_level_arr [ i -- ] = ( u2_lev_code & 1 ) ? - u2_abs_value : u2_abs_value ; u4_suffix_len += ( u4_suffix_len < 6 ) ? ( u2_abs_value > ( 3 << ( u4_suffix_len - 1 ) ) ) : 0 ; } } if ( u4_total_coeff < ( 16 - u4_isdc ) ) { UWORD32 u4_index ; const UWORD8 ( * ppu1_total_zero_lkup ) [ 16 ] = ( const UWORD8 ( * ) [ 16 ] ) gau1_ih264d_table_total_zero_11to15 ; NEXTBITS ( u4_index , u4_bitstream_offset , pu4_bitstrm_buf , 4 ) ; u4_total_zeroes = ppu1_total_zero_lkup [ u4_total_coeff - 11 ] [ u4_index ] ; FLUSHBITS ( u4_bitstream_offset , ( u4_total_zeroes >> 4 ) ) ; u4_total_zeroes &= 0xf ; } else u4_total_zeroes = 0 ; { const UWORD8 * pu1_table_runbefore ; UWORD32 u4_run ; WORD32 k ; UWORD32 u4_scan_pos = u4_total_coeff + u4_total_zeroes - 1 + u4_isdc ; WORD32 u4_zeroes_left = u4_total_zeroes ; k = u4_total_coeff - 1 ; pu1_table_runbefore = ( UWORD8 * ) gau1_ih264d_table_run_before ; while ( ( u4_zeroes_left > 0 ) && k ) { UWORD32 u4_code ; NEXTBITS ( u4_code , u4_bitstream_offset , pu4_bitstrm_buf , 3 ) ; u4_code = pu1_table_runbefore [ u4_code + ( u4_zeroes_left << 3 ) ] ; u4_run = u4_code >> 2 ; FLUSHBITS ( u4_bitstream_offset , ( u4_code & 0x03 ) ) ; SET_BIT ( ps_tu_4x4 -> u2_sig_coeff_map , u4_scan_pos ) ; * pi2_coeff_data ++ = i2_level_arr [ k -- ] ; u4_zeroes_left -= u4_run ; u4_scan_pos -= ( u4_run + 1 ) ; } if ( u4_zeroes_left < 0 ) return - 1 ; while ( k >= 0 ) { SET_BIT ( ps_tu_4x4 -> u2_sig_coeff_map , u4_scan_pos ) ; * pi2_coeff_data ++ = i2_level_arr [ k -- ] ; u4_scan_pos -- ; } } { WORD32 offset ; offset = ( UWORD8 * ) pi2_coeff_data - ( UWORD8 * ) ps_tu_4x4 ; offset = ALIGN4 ( offset ) ; ps_dec -> pv_parse_tu_coeff_data = ( void * ) ( ( UWORD8 * ) ps_dec -> pv_parse_tu_coeff_data + offset ) ; } ps_bitstrm -> u4_ofst = u4_bitstream_offset ; return 0 ; }
jas_image_t * bmp_decode ( jas_stream_t * in , char * optstr ) { jas_image_t * image ; bmp_hdr_t hdr ; bmp_info_t * info ; uint_fast16_t cmptno ; jas_image_cmptparm_t cmptparms [ 3 ] ; jas_image_cmptparm_t * cmptparm ; uint_fast16_t numcmpts ; long n ; <S2SV_StartBug> image = 0 ; <S2SV_EndBug> info = 0 ; if ( optstr ) { jas_eprintf ( "warning:<S2SV_blank>ignoring<S2SV_blank>BMP<S2SV_blank>decoder<S2SV_blank>options\\n" ) ; } jas_eprintf ( "THE<S2SV_blank>BMP<S2SV_blank>FORMAT<S2SV_blank>IS<S2SV_blank>NOT<S2SV_blank>FULLY<S2SV_blank>SUPPORTED!\\n" "THAT<S2SV_blank>IS,<S2SV_blank>THE<S2SV_blank>JASPER<S2SV_blank>SOFTWARE<S2SV_blank>CANNOT<S2SV_blank>DECODE<S2SV_blank>ALL<S2SV_blank>TYPES<S2SV_blank>OF<S2SV_blank>BMP<S2SV_blank>DATA.\\n" "IF<S2SV_blank>YOU<S2SV_blank>HAVE<S2SV_blank>ANY<S2SV_blank>PROBLEMS,<S2SV_blank>PLEASE<S2SV_blank>TRY<S2SV_blank>CONVERTING<S2SV_blank>YOUR<S2SV_blank>IMAGE<S2SV_blank>DATA\\n" "TO<S2SV_blank>THE<S2SV_blank>PNM<S2SV_blank>FORMAT,<S2SV_blank>AND<S2SV_blank>USING<S2SV_blank>THIS<S2SV_blank>FORMAT<S2SV_blank>INSTEAD.\\n" ) ; if ( bmp_gethdr ( in , & hdr ) ) { jas_eprintf ( "cannot<S2SV_blank>get<S2SV_blank>header\\n" ) ; goto error ; } JAS_DBGLOG ( 1 , ( "BMP<S2SV_blank>header:<S2SV_blank>magic<S2SV_blank>0x%x;<S2SV_blank>siz<S2SV_blank>%d;<S2SV_blank>res1<S2SV_blank>%d;<S2SV_blank>res2<S2SV_blank>%d;<S2SV_blank>off<S2SV_blank>%d\\n" , hdr . magic , hdr . siz , hdr . reserved1 , hdr . reserved2 , hdr . off ) ) ; if ( ! ( info = bmp_getinfo ( in ) ) ) { jas_eprintf ( "cannot<S2SV_blank>get<S2SV_blank>info\\n" ) ; goto error ; } JAS_DBGLOG ( 1 , ( "BMP<S2SV_blank>information:<S2SV_blank>len<S2SV_blank>%ld;<S2SV_blank>width<S2SV_blank>%ld;<S2SV_blank>height<S2SV_blank>%ld;<S2SV_blank>numplanes<S2SV_blank>%d;<S2SV_blank>" "depth<S2SV_blank>%d;<S2SV_blank>enctype<S2SV_blank>%ld;<S2SV_blank>siz<S2SV_blank>%ld;<S2SV_blank>hres<S2SV_blank>%ld;<S2SV_blank>vres<S2SV_blank>%ld;<S2SV_blank>numcolors<S2SV_blank>%ld;<S2SV_blank>" "mincolors<S2SV_blank>%ld\\n" , JAS_CAST ( long , info -> len ) , JAS_CAST ( long , info -> width ) , JAS_CAST ( long , info -> height ) , JAS_CAST ( long , info -> numplanes ) , JAS_CAST ( long , info -> depth ) , JAS_CAST ( long , info -> enctype ) , JAS_CAST ( long , info -> siz ) , JAS_CAST ( long , info -> hres ) , JAS_CAST ( long , info -> vres ) , JAS_CAST ( long , info -> numcolors ) , JAS_CAST ( long , info -> mincolors ) ) ) ; if ( info -> width < 0 || info -> height < 0 || info -> numplanes < 0 || info -> depth < 0 || info -> siz < 0 || info -> hres < 0 || info -> vres < 0 ) { <S2SV_StartBug> jas_eprintf ( "corrupt<S2SV_blank>bit<S2SV_blank>stream\\n" ) ; <S2SV_EndBug> goto error ; } if ( ! bmp_issupported ( & hdr , info ) ) { jas_eprintf ( "error:<S2SV_blank>unsupported<S2SV_blank>BMP<S2SV_blank>encoding\\n" ) ; goto error ; } if ( ( n = hdr . off - ( BMP_HDRLEN + BMP_INFOLEN + BMP_PALLEN ( info ) ) ) < 0 ) { jas_eprintf ( "error:<S2SV_blank>possibly<S2SV_blank>bad<S2SV_blank>bitmap<S2SV_blank>offset?\\n" ) ; goto error ; } if ( n > 0 ) { jas_eprintf ( "skipping<S2SV_blank>unknown<S2SV_blank>data<S2SV_blank>in<S2SV_blank>BMP<S2SV_blank>file\\n" ) ; if ( bmp_gobble ( in , n ) ) { goto error ; } } numcmpts = bmp_numcmpts ( info ) ; for ( cmptno = 0 , cmptparm = cmptparms ; cmptno < numcmpts ; ++ cmptno , ++ cmptparm ) { cmptparm -> tlx = 0 ; cmptparm -> tly = 0 ; cmptparm -> hstep = 1 ; cmptparm -> vstep = 1 ; cmptparm -> width = info -> width ; cmptparm -> height = info -> height ; cmptparm -> prec = 8 ; cmptparm -> sgnd = false ; } if ( ! ( image = jas_image_create ( numcmpts , cmptparms , JAS_CLRSPC_UNKNOWN ) ) ) { goto error ; } if ( numcmpts == 3 ) { jas_image_setclrspc ( image , JAS_CLRSPC_SRGB ) ; jas_image_setcmpttype ( image , 0 , JAS_IMAGE_CT_COLOR ( JAS_CLRSPC_CHANIND_RGB_R ) ) ; jas_image_setcmpttype ( image , 1 , JAS_IMAGE_CT_COLOR ( JAS_CLRSPC_CHANIND_RGB_G ) ) ; jas_image_setcmpttype ( image , 2 , JAS_IMAGE_CT_COLOR ( JAS_CLRSPC_CHANIND_RGB_B ) ) ; } else { jas_image_setclrspc ( image , JAS_CLRSPC_SGRAY ) ; jas_image_setcmpttype ( image , 0 , JAS_IMAGE_CT_COLOR ( JAS_CLRSPC_CHANIND_GRAY_Y ) ) ; } if ( bmp_getdata ( in , info , image ) ) { goto error ; } bmp_info_destroy ( info ) ; return image ; error : if ( info ) { bmp_info_destroy ( info ) ; } if ( image ) { jas_image_destroy ( image ) ; } return 0 ; }
error_t httpClientFormatAuthorizationField ( HttpClientContext * context ) { size_t n ; char_t * p ; HttpClientAuthParams * authParams ; if ( context -> bufferLen < 2 || context -> bufferLen > HTTP_CLIENT_BUFFER_SIZE ) return ERROR_INVALID_SYNTAX ; authParams = & context -> authParams ; # if ( HTTP_CLIENT_BASIC_AUTH_SUPPORT == ENABLED ) if ( authParams -> mode == HTTP_AUTH_MODE_BASIC ) { size_t k ; size_t m ; n = osStrlen ( authParams -> username ) + osStrlen ( authParams -> password ) ; if ( ( context -> bufferLen + n + 22 ) > HTTP_CLIENT_BUFFER_SIZE ) return ERROR_BUFFER_OVERFLOW ; p = context -> buffer + context -> bufferLen - 2 ; n = osSprintf ( p , "Authorization:<S2SV_blank>Basic<S2SV_blank>" ) ; m = osSprintf ( p + n , "%s:%s" , authParams -> username , authParams -> password ) ; base64Encode ( p + n , m , NULL , & k ) ; if ( ( context -> bufferLen + n + k ) > HTTP_CLIENT_BUFFER_SIZE ) return ERROR_BUFFER_OVERFLOW ; base64Encode ( p + n , m , p + n , & k ) ; n += k ; if ( ( context -> bufferLen + n + 2 ) > HTTP_CLIENT_BUFFER_SIZE ) return ERROR_BUFFER_OVERFLOW ; osSprintf ( p + n , "\\r\\n\\r\\n" ) ; context -> bufferLen = context -> bufferLen + n + 2 ; } else # endif # if ( HTTP_CLIENT_DIGEST_AUTH_SUPPORT == ENABLED ) if ( authParams -> mode == HTTP_AUTH_MODE_DIGEST ) { error_t error ; const char_t * q ; const char_t * uri ; size_t uriLen ; char_t response [ HTTP_CLIENT_MAX_RESPONSE_LEN + 1 ] ; context -> buffer [ context -> bufferLen ] = '\\0' ; <S2SV_StartBug> q = strchr ( context -> buffer , '<S2SV_blank>' ) ; <S2SV_EndBug> if ( q == NULL ) return ERROR_INVALID_SYNTAX ; uri = q + 1 ; <S2SV_StartBug> q = strchr ( uri , '<S2SV_blank>' ) ; <S2SV_EndBug> if ( q == NULL ) return ERROR_INVALID_SYNTAX ; uriLen = q - uri ; if ( authParams -> qop == HTTP_AUTH_QOP_AUTH || authParams -> qop == HTTP_AUTH_QOP_AUTH_INT ) { if ( context -> randCallback == NULL ) return ERROR_PRNG_NOT_READY ; error = context -> randCallback ( authParams -> cnonce , HTTP_CLIENT_CNONCE_SIZE ) ; if ( error ) return error ; httpEncodeHexString ( authParams -> cnonce , HTTP_CLIENT_CNONCE_SIZE , authParams -> cnonce ) ; authParams -> nc ++ ; } error = httpClientComputeDigest ( authParams , context -> method , osStrlen ( context -> method ) , uri , uriLen , response ) ; if ( error ) return error ; n = osStrlen ( authParams -> username ) + osStrlen ( authParams -> realm ) + uriLen + osStrlen ( authParams -> nonce ) + osStrlen ( authParams -> cnonce ) + osStrlen ( response ) + osStrlen ( authParams -> opaque ) ; if ( ( context -> bufferLen + n + 121 ) > HTTP_CLIENT_BUFFER_SIZE ) return ERROR_BUFFER_OVERFLOW ; p = context -> buffer + context -> bufferLen - 2 ; n = osSprintf ( p , "Authorization:<S2SV_blank>Digest<S2SV_blank>" ) ; n += osSprintf ( p + n , "username=\\"%s\\",<S2SV_blank>" , authParams -> username ) ; n += osSprintf ( p + n , "realm=\\"%s\\",<S2SV_blank>" , authParams -> realm ) ; n += osSprintf ( p + n , "uri=\\"" ) ; osStrncpy ( p + n , uri , uriLen ) ; n += uriLen ; n += osSprintf ( p + n , "\\",<S2SV_blank>" ) ; n += osSprintf ( p + n , "nonce=\\"%s\\",<S2SV_blank>" , authParams -> nonce ) ; if ( authParams -> qop == HTTP_AUTH_QOP_AUTH ) { n += osSprintf ( p + n , "qop=auth,<S2SV_blank>" ) ; n += osSprintf ( p + n , "nc=%08x,<S2SV_blank>" , authParams -> nc ) ; n += osSprintf ( p + n , "cnonce=\\"%s\\",<S2SV_blank>" , authParams -> cnonce ) ; } n += osSprintf ( p + n , "response=\\"%s\\"" , response ) ; if ( authParams -> opaque [ 0 ] != '\\0' ) { n += osSprintf ( p + n , ",<S2SV_blank>opaque=\\"%s\\"" , authParams -> opaque ) ; } osSprintf ( p + n , "\\r\\n\\r\\n" ) ; context -> bufferLen = context -> bufferLen + n + 2 ; } else # endif { } return NO_ERROR ; }
static void mem_cgroup_usage_unregister_event ( struct cgroup * cgrp , struct cftype * cft , struct eventfd_ctx * eventfd ) { struct mem_cgroup * memcg = mem_cgroup_from_cont ( cgrp ) ; struct mem_cgroup_thresholds * thresholds ; struct mem_cgroup_threshold_ary * new ; int type = MEMFILE_TYPE ( cft -> private ) ; u64 usage ; int i , j , size ; mutex_lock ( & memcg -> thresholds_lock ) ; if ( type == _MEM ) thresholds = & memcg -> thresholds ; else if ( type == _MEMSWAP ) thresholds = & memcg -> memsw_thresholds ; else BUG ( ) ; <S2SV_StartBug> BUG_ON ( ! thresholds ) ; <S2SV_EndBug> usage = mem_cgroup_usage ( memcg , type == _MEMSWAP ) ; __mem_cgroup_threshold ( memcg , type == _MEMSWAP ) ; size = 0 ; for ( i = 0 ; i < thresholds -> primary -> size ; i ++ ) { if ( thresholds -> primary -> entries [ i ] . eventfd != eventfd ) size ++ ; } new = thresholds -> spare ; if ( ! size ) { kfree ( new ) ; new = NULL ; goto swap_buffers ; } new -> size = size ; new -> current_threshold = - 1 ; for ( i = 0 , j = 0 ; i < thresholds -> primary -> size ; i ++ ) { if ( thresholds -> primary -> entries [ i ] . eventfd == eventfd ) continue ; new -> entries [ j ] = thresholds -> primary -> entries [ i ] ; if ( new -> entries [ j ] . threshold < usage ) { ++ new -> current_threshold ; } j ++ ; } swap_buffers : thresholds -> spare = thresholds -> primary ; rcu_assign_pointer ( thresholds -> primary , new ) ; synchronize_rcu ( ) ; <S2SV_StartBug> mutex_unlock ( & memcg -> thresholds_lock ) ; <S2SV_EndBug> }
static int list_dbs ( MYSQL * mysql , const char * wild ) { const char * header ; uint length , counter = 0 ; ulong rowcount = 0L ; char tables [ NAME_LEN + 1 ] , rows [ NAME_LEN + 1 ] ; <S2SV_StartBug> char query [ 255 ] ; <S2SV_EndBug> MYSQL_FIELD * field ; MYSQL_RES * result ; MYSQL_ROW row = NULL , rrow ; if ( ! ( result = mysql_list_dbs ( mysql , wild ) ) ) { fprintf ( stderr , "%s:<S2SV_blank>Cannot<S2SV_blank>list<S2SV_blank>databases:<S2SV_blank>%s\\n" , my_progname , mysql_error ( mysql ) ) ; return 1 ; } if ( wild && mysql_num_rows ( result ) == 1 ) { row = mysql_fetch_row ( result ) ; if ( ! my_strcasecmp ( & my_charset_latin1 , row [ 0 ] , wild ) ) { mysql_free_result ( result ) ; if ( opt_status ) return list_table_status ( mysql , wild , NULL ) ; else return list_tables ( mysql , wild , NULL ) ; } } if ( wild ) printf ( "Wildcard:<S2SV_blank>%s\\n" , wild ) ; header = "Databases" ; length = ( uint ) strlen ( header ) ; field = mysql_fetch_field ( result ) ; if ( length < field -> max_length ) length = field -> max_length ; if ( ! opt_verbose ) print_header ( header , length , NullS ) ; else if ( opt_verbose == 1 ) print_header ( header , length , "Tables" , 6 , NullS ) ; else print_header ( header , length , "Tables" , 6 , "Total<S2SV_blank>Rows" , 12 , NullS ) ; while ( row || ( row = mysql_fetch_row ( result ) ) ) { counter ++ ; if ( opt_verbose ) { if ( ! ( mysql_select_db ( mysql , row [ 0 ] ) ) ) { MYSQL_RES * tresult = mysql_list_tables ( mysql , ( char * ) NULL ) ; if ( mysql_affected_rows ( mysql ) > 0 ) { sprintf ( tables , "%6lu" , ( ulong ) mysql_affected_rows ( mysql ) ) ; rowcount = 0 ; if ( opt_verbose > 1 ) { MYSQL_ROW trow ; while ( ( trow = mysql_fetch_row ( tresult ) ) ) { <S2SV_StartBug> sprintf ( query , "SELECT<S2SV_blank>COUNT(*)<S2SV_blank>FROM<S2SV_blank>`%s`" , trow [ 0 ] ) ; <S2SV_EndBug> if ( ! ( mysql_query ( mysql , query ) ) ) { MYSQL_RES * rresult ; if ( ( rresult = mysql_store_result ( mysql ) ) ) { rrow = mysql_fetch_row ( rresult ) ; rowcount += ( ulong ) strtoull ( rrow [ 0 ] , ( char * * ) 0 , 10 ) ; mysql_free_result ( rresult ) ; } } } sprintf ( rows , "%12lu" , rowcount ) ; } } else { sprintf ( tables , "%6d" , 0 ) ; sprintf ( rows , "%12d" , 0 ) ; } mysql_free_result ( tresult ) ; } else { strmov ( tables , "N/A" ) ; strmov ( rows , "N/A" ) ; } } if ( ! opt_verbose ) print_row ( row [ 0 ] , length , 0 ) ; else if ( opt_verbose == 1 ) print_row ( row [ 0 ] , length , tables , 6 , NullS ) ; else print_row ( row [ 0 ] , length , tables , 6 , rows , 12 , NullS ) ; row = NULL ; } print_trailer ( length , ( opt_verbose > 0 ? 6 : 0 ) , ( opt_verbose > 1 ? 12 : 0 ) , 0 ) ; if ( counter && opt_verbose ) printf ( "%u<S2SV_blank>row%s<S2SV_blank>in<S2SV_blank>set.\\n" , counter , ( counter > 1 ) ? "s" : "" ) ; mysql_free_result ( result ) ; return 0 ; }
int megasas_alloc_cmds ( struct megasas_instance * instance ) { int i ; int j ; u16 max_cmd ; struct megasas_cmd * cmd ; max_cmd = instance -> max_mfi_cmds ; instance -> cmd_list = kcalloc ( max_cmd , sizeof ( struct megasas_cmd * ) , GFP_KERNEL ) ; if ( ! instance -> cmd_list ) { dev_printk ( KERN_DEBUG , & instance -> pdev -> dev , "out<S2SV_blank>of<S2SV_blank>memory\\n" ) ; return - ENOMEM ; } memset ( instance -> cmd_list , 0 , sizeof ( struct megasas_cmd * ) * max_cmd ) ; for ( i = 0 ; i < max_cmd ; i ++ ) { instance -> cmd_list [ i ] = kmalloc ( sizeof ( struct megasas_cmd ) , GFP_KERNEL ) ; if ( ! instance -> cmd_list [ i ] ) { for ( j = 0 ; j < i ; j ++ ) kfree ( instance -> cmd_list [ j ] ) ; kfree ( instance -> cmd_list ) ; instance -> cmd_list = NULL ; return - ENOMEM ; } } for ( i = 0 ; i < max_cmd ; i ++ ) { cmd = instance -> cmd_list [ i ] ; memset ( cmd , 0 , sizeof ( struct megasas_cmd ) ) ; cmd -> index = i ; cmd -> scmd = NULL ; cmd -> instance = instance ; list_add_tail ( & cmd -> list , & instance -> cmd_pool ) ; } if ( megasas_create_frame_pool ( instance ) ) { dev_printk ( KERN_DEBUG , & instance -> pdev -> dev , "Error<S2SV_blank>creating<S2SV_blank>frame<S2SV_blank>DMA<S2SV_blank>pool\\n" ) ; megasas_free_cmds ( instance ) ; <S2SV_StartBug> } <S2SV_EndBug> return 0 ; }
static int caif_seqpkt_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * m , size_t len , int flags ) { struct sock * sk = sock -> sk ; struct sk_buff * skb ; int ret ; int copylen ; ret = - EOPNOTSUPP ; if ( m -> msg_flags & MSG_OOB ) goto read_error ; <S2SV_StartBug> skb = skb_recv_datagram ( sk , flags , 0 , & ret ) ; <S2SV_EndBug> if ( ! skb ) goto read_error ; copylen = skb -> len ; if ( len < copylen ) { m -> msg_flags |= MSG_TRUNC ; copylen = len ; } ret = skb_copy_datagram_iovec ( skb , 0 , m -> msg_iov , copylen ) ; if ( ret ) goto out_free ; ret = ( flags & MSG_TRUNC ) ? skb -> len : copylen ; out_free : skb_free_datagram ( sk , skb ) ; caif_check_flow_release ( sk ) ; return ret ; read_error : return ret ; }
struct json_object * json_tokener_parse_ex ( struct json_tokener * tok , const char * str , int len ) { struct json_object * obj = NULL ; char c = '\\1' ; # ifdef HAVE_SETLOCALE char * oldlocale = NULL , * tmplocale ; tmplocale = setlocale ( LC_NUMERIC , NULL ) ; if ( tmplocale ) oldlocale = strdup ( tmplocale ) ; setlocale ( LC_NUMERIC , "C" ) ; # endif tok -> char_offset = 0 ; <S2SV_StartBug> tok -> err = json_tokener_success ; <S2SV_EndBug> while ( PEEK_CHAR ( c , tok ) ) { redo_char : switch ( state ) { case json_tokener_state_eatws : while ( isspace ( ( int ) c ) ) { if ( ( ! ADVANCE_CHAR ( str , tok ) ) || ( ! PEEK_CHAR ( c , tok ) ) ) goto out ; } if ( c == '/' && ! ( tok -> flags & JSON_TOKENER_STRICT ) ) { printbuf_reset ( tok -> pb ) ; printbuf_memappend_fast ( tok -> pb , & c , 1 ) ; state = json_tokener_state_comment_start ; } else { state = saved_state ; goto redo_char ; } break ; case json_tokener_state_start : switch ( c ) { case '{' : state = json_tokener_state_eatws ; saved_state = json_tokener_state_object_field_start ; current = json_object_new_object ( ) ; break ; case '[' : state = json_tokener_state_eatws ; saved_state = json_tokener_state_array ; current = json_object_new_array ( ) ; break ; case 'I' : case 'i' : state = json_tokener_state_inf ; printbuf_reset ( tok -> pb ) ; tok -> st_pos = 0 ; goto redo_char ; case 'N' : case 'n' : state = json_tokener_state_null ; printbuf_reset ( tok -> pb ) ; tok -> st_pos = 0 ; goto redo_char ; case '\\'' : if ( tok -> flags & JSON_TOKENER_STRICT ) { tok -> err = json_tokener_error_parse_unexpected ; goto out ; } case \'"\' : state = json_tokener_state_string ; printbuf_reset ( tok -> pb ) ; tok -> quote_char = c ; break ; case 'T' : case 't' : case 'F' : case 'f' : state = json_tokener_state_boolean ; printbuf_reset ( tok -> pb ) ; tok -> st_pos = 0 ; goto redo_char ; # if defined ( __GNUC__ ) case '0' ... '9' : # else case '0' : case '1' : case '2' : case '3' : case '4' : case '5' : case '6' : case '7' : case '8' : case '9' : # endif case '-' : state = json_tokener_state_number ; printbuf_reset ( tok -> pb ) ; tok -> is_double = 0 ; goto redo_char ; default : tok -> err = json_tokener_error_parse_unexpected ; goto out ; } break ; case json_tokener_state_finish : if ( tok -> depth == 0 ) goto out ; obj = json_object_get ( current ) ; json_tokener_reset_level ( tok , tok -> depth ) ; tok -> depth -- ; goto redo_char ; case json_tokener_state_inf : { int size ; int size_inf ; int is_negative = 0 ; printbuf_memappend_fast ( tok -> pb , & c , 1 ) ; size = json_min ( tok -> st_pos + 1 , json_null_str_len ) ; size_inf = json_min ( tok -> st_pos + 1 , json_inf_str_len ) ; char * infbuf = tok -> pb -> buf ; if ( * infbuf == '-' ) { infbuf ++ ; is_negative = 1 ; } if ( ( ! ( tok -> flags & JSON_TOKENER_STRICT ) && strncasecmp ( json_inf_str , infbuf , size_inf ) == 0 ) || ( strncmp ( json_inf_str , infbuf , size_inf ) == 0 ) ) { if ( tok -> st_pos == json_inf_str_len ) { current = json_object_new_double ( is_negative ? - INFINITY : INFINITY ) ; saved_state = json_tokener_state_finish ; state = json_tokener_state_eatws ; goto redo_char ; } } else { tok -> err = json_tokener_error_parse_unexpected ; goto out ; } tok -> st_pos ++ ; } break ; case json_tokener_state_null : { int size ; int size_nan ; printbuf_memappend_fast ( tok -> pb , & c , 1 ) ; size = json_min ( tok -> st_pos + 1 , json_null_str_len ) ; size_nan = json_min ( tok -> st_pos + 1 , json_nan_str_len ) ; if ( ( ! ( tok -> flags & JSON_TOKENER_STRICT ) && strncasecmp ( json_null_str , tok -> pb -> buf , size ) == 0 ) || ( strncmp ( json_null_str , tok -> pb -> buf , size ) == 0 ) ) { if ( tok -> st_pos == json_null_str_len ) { current = NULL ; saved_state = json_tokener_state_finish ; state = json_tokener_state_eatws ; goto redo_char ; } } else if ( ( ! ( tok -> flags & JSON_TOKENER_STRICT ) && strncasecmp ( json_nan_str , tok -> pb -> buf , size_nan ) == 0 ) || ( strncmp ( json_nan_str , tok -> pb -> buf , size_nan ) == 0 ) ) { if ( tok -> st_pos == json_nan_str_len ) { current = json_object_new_double ( NAN ) ; saved_state = json_tokener_state_finish ; state = json_tokener_state_eatws ; goto redo_char ; } } else { tok -> err = json_tokener_error_parse_null ; goto out ; } tok -> st_pos ++ ; } break ; case json_tokener_state_comment_start : if ( c == '*' ) { state = json_tokener_state_comment ; } else if ( c == '/' ) { state = json_tokener_state_comment_eol ; } else { tok -> err = json_tokener_error_parse_comment ; goto out ; } printbuf_memappend_fast ( tok -> pb , & c , 1 ) ; break ; case json_tokener_state_comment : { const char * case_start = str ; while ( c != '*' ) { if ( ! ADVANCE_CHAR ( str , tok ) || ! PEEK_CHAR ( c , tok ) ) { printbuf_memappend_fast ( tok -> pb , case_start , str - case_start ) ; goto out ; } } printbuf_memappend_fast ( tok -> pb , case_start , 1 + str - case_start ) ; state = json_tokener_state_comment_end ; } break ; case json_tokener_state_comment_eol : { const char * case_start = str ; while ( c != '\\n' ) { if ( ! ADVANCE_CHAR ( str , tok ) || ! PEEK_CHAR ( c , tok ) ) { printbuf_memappend_fast ( tok -> pb , case_start , str - case_start ) ; goto out ; } } printbuf_memappend_fast ( tok -> pb , case_start , str - case_start ) ; MC_DEBUG ( "json_tokener_comment:<S2SV_blank>%s\\n" , tok -> pb -> buf ) ; state = json_tokener_state_eatws ; } break ; case json_tokener_state_comment_end : printbuf_memappend_fast ( tok -> pb , & c , 1 ) ; if ( c == '/' ) { MC_DEBUG ( "json_tokener_comment:<S2SV_blank>%s\\n" , tok -> pb -> buf ) ; state = json_tokener_state_eatws ; } else { state = json_tokener_state_comment ; } break ; case json_tokener_state_string : { const char * case_start = str ; while ( 1 ) { if ( c == tok -> quote_char ) { printbuf_memappend_fast ( tok -> pb , case_start , str - case_start ) ; current = json_object_new_string_len ( tok -> pb -> buf , tok -> pb -> bpos ) ; saved_state = json_tokener_state_finish ; state = json_tokener_state_eatws ; break ; } else if ( c == '\\\\' ) { printbuf_memappend_fast ( tok -> pb , case_start , str - case_start ) ; saved_state = json_tokener_state_string ; state = json_tokener_state_string_escape ; break ; } if ( ! ADVANCE_CHAR ( str , tok ) || ! PEEK_CHAR ( c , tok ) ) { printbuf_memappend_fast ( tok -> pb , case_start , str - case_start ) ; goto out ; } } } break ; case json_tokener_state_string_escape : switch ( c ) { case \'"\' : case '\\\\' : case '/' : printbuf_memappend_fast ( tok -> pb , & c , 1 ) ; state = saved_state ; break ; case 'b' : case 'n' : case 'r' : case 't' : case 'f' : if ( c == 'b' ) printbuf_memappend_fast ( tok -> pb , "\\b" , 1 ) ; else if ( c == 'n' ) printbuf_memappend_fast ( tok -> pb , "\\n" , 1 ) ; else if ( c == 'r' ) printbuf_memappend_fast ( tok -> pb , "\\r" , 1 ) ; else if ( c == 't' ) printbuf_memappend_fast ( tok -> pb , "\\t" , 1 ) ; else if ( c == 'f' ) printbuf_memappend_fast ( tok -> pb , "\\f" , 1 ) ; state = saved_state ; break ; case 'u' : tok -> ucs_char = 0 ; tok -> st_pos = 0 ; state = json_tokener_state_escape_unicode ; break ; default : tok -> err = json_tokener_error_parse_string ; goto out ; } break ; case json_tokener_state_escape_unicode : { unsigned int got_hi_surrogate = 0 ; while ( 1 ) { if ( strchr ( json_hex_chars , c ) ) { tok -> ucs_char += ( ( unsigned int ) hexdigit ( c ) << ( ( 3 - tok -> st_pos ++ ) * 4 ) ) ; if ( tok -> st_pos == 4 ) { unsigned char unescaped_utf [ 4 ] ; if ( got_hi_surrogate ) { if ( IS_LOW_SURROGATE ( tok -> ucs_char ) ) { tok -> ucs_char = DECODE_SURROGATE_PAIR ( got_hi_surrogate , tok -> ucs_char ) ; } else { printbuf_memappend_fast ( tok -> pb , ( char * ) utf8_replacement_char , 3 ) ; } got_hi_surrogate = 0 ; } if ( tok -> ucs_char < 0x80 ) { unescaped_utf [ 0 ] = tok -> ucs_char ; printbuf_memappend_fast ( tok -> pb , ( char * ) unescaped_utf , 1 ) ; } else if ( tok -> ucs_char < 0x800 ) { unescaped_utf [ 0 ] = 0xc0 | ( tok -> ucs_char >> 6 ) ; unescaped_utf [ 1 ] = 0x80 | ( tok -> ucs_char & 0x3f ) ; printbuf_memappend_fast ( tok -> pb , ( char * ) unescaped_utf , 2 ) ; } else if ( IS_HIGH_SURROGATE ( tok -> ucs_char ) ) { got_hi_surrogate = tok -> ucs_char ; if ( ( tok -> char_offset + 1 != len ) && ( tok -> char_offset + 2 != len ) && ( str [ 1 ] == '\\\\' ) && ( str [ 2 ] == 'u' ) ) { if ( ! ADVANCE_CHAR ( str , tok ) || ! ADVANCE_CHAR ( str , tok ) ) { printbuf_memappend_fast ( tok -> pb , ( char * ) utf8_replacement_char , 3 ) ; } if ( ! ADVANCE_CHAR ( str , tok ) || ! PEEK_CHAR ( c , tok ) ) { printbuf_memappend_fast ( tok -> pb , ( char * ) utf8_replacement_char , 3 ) ; goto out ; } tok -> ucs_char = 0 ; tok -> st_pos = 0 ; continue ; } else { printbuf_memappend_fast ( tok -> pb , ( char * ) utf8_replacement_char , 3 ) ; } } else if ( IS_LOW_SURROGATE ( tok -> ucs_char ) ) { printbuf_memappend_fast ( tok -> pb , ( char * ) utf8_replacement_char , 3 ) ; } else if ( tok -> ucs_char < 0x10000 ) { unescaped_utf [ 0 ] = 0xe0 | ( tok -> ucs_char >> 12 ) ; unescaped_utf [ 1 ] = 0x80 | ( ( tok -> ucs_char >> 6 ) & 0x3f ) ; unescaped_utf [ 2 ] = 0x80 | ( tok -> ucs_char & 0x3f ) ; printbuf_memappend_fast ( tok -> pb , ( char * ) unescaped_utf , 3 ) ; } else if ( tok -> ucs_char < 0x110000 ) { unescaped_utf [ 0 ] = 0xf0 | ( ( tok -> ucs_char >> 18 ) & 0x07 ) ; unescaped_utf [ 1 ] = 0x80 | ( ( tok -> ucs_char >> 12 ) & 0x3f ) ; unescaped_utf [ 2 ] = 0x80 | ( ( tok -> ucs_char >> 6 ) & 0x3f ) ; unescaped_utf [ 3 ] = 0x80 | ( tok -> ucs_char & 0x3f ) ; printbuf_memappend_fast ( tok -> pb , ( char * ) unescaped_utf , 4 ) ; } else { printbuf_memappend_fast ( tok -> pb , ( char * ) utf8_replacement_char , 3 ) ; } state = saved_state ; break ; } } else { tok -> err = json_tokener_error_parse_string ; goto out ; } if ( ! ADVANCE_CHAR ( str , tok ) || ! PEEK_CHAR ( c , tok ) ) { if ( got_hi_surrogate ) printbuf_memappend_fast ( tok -> pb , ( char * ) utf8_replacement_char , 3 ) ; goto out ; } } } break ; case json_tokener_state_boolean : { int size1 , size2 ; printbuf_memappend_fast ( tok -> pb , & c , 1 ) ; size1 = json_min ( tok -> st_pos + 1 , json_true_str_len ) ; size2 = json_min ( tok -> st_pos + 1 , json_false_str_len ) ; if ( ( ! ( tok -> flags & JSON_TOKENER_STRICT ) && strncasecmp ( json_true_str , tok -> pb -> buf , size1 ) == 0 ) || ( strncmp ( json_true_str , tok -> pb -> buf , size1 ) == 0 ) ) { if ( tok -> st_pos == json_true_str_len ) { current = json_object_new_boolean ( 1 ) ; saved_state = json_tokener_state_finish ; state = json_tokener_state_eatws ; goto redo_char ; } } else if ( ( ! ( tok -> flags & JSON_TOKENER_STRICT ) && strncasecmp ( json_false_str , tok -> pb -> buf , size2 ) == 0 ) || ( strncmp ( json_false_str , tok -> pb -> buf , size2 ) == 0 ) ) { if ( tok -> st_pos == json_false_str_len ) { current = json_object_new_boolean ( 0 ) ; saved_state = json_tokener_state_finish ; state = json_tokener_state_eatws ; goto redo_char ; } } else { tok -> err = json_tokener_error_parse_boolean ; goto out ; } tok -> st_pos ++ ; } break ; case json_tokener_state_number : { const char * case_start = str ; int case_len = 0 ; while ( c && strchr ( json_number_chars , c ) ) { ++ case_len ; if ( c == '.' || c == 'e' || c == 'E' ) tok -> is_double = 1 ; if ( ! ADVANCE_CHAR ( str , tok ) || ! PEEK_CHAR ( c , tok ) ) { printbuf_memappend_fast ( tok -> pb , case_start , case_len ) ; goto out ; } } if ( case_len > 0 ) printbuf_memappend_fast ( tok -> pb , case_start , case_len ) ; if ( tok -> pb -> buf [ 0 ] == '-' && case_len == 1 && ( c == 'i' || c == 'I' ) ) { state = json_tokener_state_inf ; goto redo_char ; } } { int64_t num64 ; double numd ; if ( ! tok -> is_double && json_parse_int64 ( tok -> pb -> buf , & num64 ) == 0 ) { if ( num64 && tok -> pb -> buf [ 0 ] == '0' && ( tok -> flags & JSON_TOKENER_STRICT ) ) { tok -> err = json_tokener_error_parse_number ; goto out ; } current = json_object_new_int64 ( num64 ) ; } else if ( tok -> is_double && json_parse_double ( tok -> pb -> buf , & numd ) == 0 ) { current = json_object_new_double_s ( numd , tok -> pb -> buf ) ; } else { tok -> err = json_tokener_error_parse_number ; goto out ; } saved_state = json_tokener_state_finish ; state = json_tokener_state_eatws ; goto redo_char ; } break ; case json_tokener_state_array_after_sep : case json_tokener_state_array : if ( c == ']' ) { if ( state == json_tokener_state_array_after_sep && ( tok -> flags & JSON_TOKENER_STRICT ) ) { tok -> err = json_tokener_error_parse_unexpected ; goto out ; } saved_state = json_tokener_state_finish ; state = json_tokener_state_eatws ; } else { if ( tok -> depth >= tok -> max_depth - 1 ) { tok -> err = json_tokener_error_depth ; goto out ; } state = json_tokener_state_array_add ; tok -> depth ++ ; json_tokener_reset_level ( tok , tok -> depth ) ; goto redo_char ; } break ; case json_tokener_state_array_add : json_object_array_add ( current , obj ) ; saved_state = json_tokener_state_array_sep ; state = json_tokener_state_eatws ; goto redo_char ; case json_tokener_state_array_sep : if ( c == ']' ) { saved_state = json_tokener_state_finish ; state = json_tokener_state_eatws ; } else if ( c == ',' ) { saved_state = json_tokener_state_array_after_sep ; state = json_tokener_state_eatws ; } else { tok -> err = json_tokener_error_parse_array ; goto out ; } break ; case json_tokener_state_object_field_start : case json_tokener_state_object_field_start_after_sep : if ( c == '}' ) { if ( state == json_tokener_state_object_field_start_after_sep && ( tok -> flags & JSON_TOKENER_STRICT ) ) { tok -> err = json_tokener_error_parse_unexpected ; goto out ; } saved_state = json_tokener_state_finish ; state = json_tokener_state_eatws ; } else if ( c == \'"\' || c == '\\'' ) { tok -> quote_char = c ; printbuf_reset ( tok -> pb ) ; state = json_tokener_state_object_field ; } else { tok -> err = json_tokener_error_parse_object_key_name ; goto out ; } break ; case json_tokener_state_object_field : { const char * case_start = str ; while ( 1 ) { if ( c == tok -> quote_char ) { printbuf_memappend_fast ( tok -> pb , case_start , str - case_start ) ; obj_field_name = strdup ( tok -> pb -> buf ) ; saved_state = json_tokener_state_object_field_end ; state = json_tokener_state_eatws ; break ; } else if ( c == '\\\\' ) { printbuf_memappend_fast ( tok -> pb , case_start , str - case_start ) ; saved_state = json_tokener_state_object_field ; state = json_tokener_state_string_escape ; break ; } if ( ! ADVANCE_CHAR ( str , tok ) || ! PEEK_CHAR ( c , tok ) ) { printbuf_memappend_fast ( tok -> pb , case_start , str - case_start ) ; goto out ; } } } break ; case json_tokener_state_object_field_end : if ( c == ':' ) { saved_state = json_tokener_state_object_value ; state = json_tokener_state_eatws ; } else { tok -> err = json_tokener_error_parse_object_key_sep ; goto out ; } break ; case json_tokener_state_object_value : if ( tok -> depth >= tok -> max_depth - 1 ) { tok -> err = json_tokener_error_depth ; goto out ; } state = json_tokener_state_object_value_add ; tok -> depth ++ ; json_tokener_reset_level ( tok , tok -> depth ) ; goto redo_char ; case json_tokener_state_object_value_add : json_object_object_add ( current , obj_field_name , obj ) ; free ( obj_field_name ) ; obj_field_name = NULL ; saved_state = json_tokener_state_object_sep ; state = json_tokener_state_eatws ; goto redo_char ; case json_tokener_state_object_sep : if ( c == '}' ) { saved_state = json_tokener_state_finish ; state = json_tokener_state_eatws ; } else if ( c == ',' ) { saved_state = json_tokener_state_object_field_start_after_sep ; state = json_tokener_state_eatws ; } else { tok -> err = json_tokener_error_parse_object_value_sep ; goto out ; } break ; } if ( ! ADVANCE_CHAR ( str , tok ) ) goto out ; } out : if ( c && ( state == json_tokener_state_finish ) && ( tok -> depth == 0 ) && ( tok -> flags & JSON_TOKENER_STRICT ) ) { tok -> err = json_tokener_error_parse_unexpected ; } if ( ! c ) { if ( state != json_tokener_state_finish && saved_state != json_tokener_state_finish ) tok -> err = json_tokener_error_parse_eof ; } # ifdef HAVE_SETLOCALE setlocale ( LC_NUMERIC , oldlocale ) ; if ( oldlocale ) free ( oldlocale ) ; # endif if ( tok -> err == json_tokener_success ) { json_object * ret = json_object_get ( current ) ; int ii ; for ( ii = tok -> depth ; ii >= 0 ; ii -- ) json_tokener_reset_level ( tok , ii ) ; return ret ; } MC_DEBUG ( "json_tokener_parse_ex:<S2SV_blank>error<S2SV_blank>%s<S2SV_blank>at<S2SV_blank>offset<S2SV_blank>%d\\n" , json_tokener_errors [ tok -> err ] , tok -> char_offset ) ; return NULL ; }
static char * decode_text_string ( const char * str , size_t str_len ) { int idx , is_hex , is_utf16be , ascii_idx ; char * ascii , hex_buf [ 5 ] = { 0 } ; is_hex = is_utf16be = idx = ascii_idx = 0 ; if ( str [ 0 ] == '(' ) { <S2SV_StartBug> ascii = malloc ( strlen ( str ) + 1 ) ; <S2SV_EndBug> strncpy ( ascii , str , strlen ( str ) + 1 ) ; return ascii ; } else if ( str [ 0 ] == '<' ) { is_hex = 1 ; ++ idx ; } if ( is_hex && ( str_len > 5 ) && ( str [ idx ] == 'F' ) && ( str [ idx + 1 ] == 'E' ) && ( str [ idx + 2 ] == 'F' ) && ( str [ idx + 3 ] == 'F' ) ) { is_utf16be = 1 ; idx += 4 ; } else return NULL ; <S2SV_StartBug> ascii = malloc ( str_len ) ; <S2SV_EndBug> for ( ; idx < str_len ; ++ idx ) { hex_buf [ 0 ] = str [ idx ++ ] ; hex_buf [ 1 ] = str [ idx ++ ] ; hex_buf [ 2 ] = str [ idx ++ ] ; hex_buf [ 3 ] = str [ idx ] ; ascii [ ascii_idx ++ ] = strtol ( hex_buf , NULL , 16 ) ; } return ascii ; }
char * * <S2SV_StartBug> prepenv ( const struct rule * rule ) <S2SV_EndBug> { static const char * safeset [ ] = { "DISPLAY" , "HOME" , "LOGNAME" , "MAIL" , "PATH" , "TERM" , "USER" , "USERNAME" , NULL } ; struct env * env ; <S2SV_StartBug> env = createenv ( rule ) ; <S2SV_EndBug> if ( ! ( rule -> options & KEEPENV ) ) fillenv ( env , safeset ) ; if ( rule -> envlist ) fillenv ( env , rule -> envlist ) ; return flattenenv ( env ) ; }
int hashbin_delete ( hashbin_t * hashbin , FREE_FUNC free_func ) { irda_queue_t * queue ; unsigned long flags = 0 ; int i ; IRDA_ASSERT ( hashbin != NULL , return - 1 ; ) ; IRDA_ASSERT ( hashbin -> magic == HB_MAGIC , return - 1 ; ) ; <S2SV_StartBug> if ( hashbin -> hb_type & HB_LOCK ) { <S2SV_EndBug> spin_lock_irqsave_nested ( & hashbin -> hb_spinlock , flags , hashbin_lock_depth ++ ) ; } for ( i = 0 ; i < HASHBIN_SIZE ; i ++ ) { <S2SV_StartBug> queue = dequeue_first ( ( irda_queue_t * * ) & hashbin -> hb_queue [ i ] ) ; <S2SV_EndBug> <S2SV_StartBug> while ( queue ) { <S2SV_EndBug> if ( free_func ) <S2SV_StartBug> ( * free_func ) ( queue ) ; <S2SV_EndBug> queue = dequeue_first ( ( irda_queue_t * * ) & hashbin -> hb_queue [ i ] ) ; } } hashbin -> hb_current = NULL ; hashbin -> magic = ~ HB_MAGIC ; <S2SV_StartBug> if ( hashbin -> hb_type & HB_LOCK ) { <S2SV_EndBug> spin_unlock_irqrestore ( & hashbin -> hb_spinlock , flags ) ; <S2SV_StartBug> # ifdef CONFIG_LOCKDEP <S2SV_EndBug> hashbin_lock_depth -- ; # endif } kfree ( hashbin ) ; return 0 ; }
static void accumulate_stats ( FIRSTPASS_STATS * section , const FIRSTPASS_STATS * frame ) { section -> frame += frame -> frame ; <S2SV_StartBug> section -> spatial_layer_id = frame -> spatial_layer_id ; <S2SV_EndBug> section -> intra_error += frame -> intra_error ; section -> coded_error += frame -> coded_error ; section -> sr_coded_error += frame -> sr_coded_error ; <S2SV_StartBug> section -> ssim_weighted_pred_err += frame -> ssim_weighted_pred_err ; <S2SV_EndBug> section -> pcnt_inter += frame -> pcnt_inter ; section -> pcnt_motion += frame -> pcnt_motion ; section -> pcnt_second_ref += frame -> pcnt_second_ref ; <S2SV_StartBug> section -> pcnt_neutral += frame -> pcnt_neutral ; <S2SV_EndBug> section -> MVr += frame -> MVr ; section -> mvr_abs += frame -> mvr_abs ; section -> MVc += frame -> MVc ; section -> mvc_abs += frame -> mvc_abs ; section -> MVrv += frame -> MVrv ; section -> MVcv += frame -> MVcv ; section -> mv_in_out_count += frame -> mv_in_out_count ; section -> new_mv_count += frame -> new_mv_count ; section -> count += frame -> count ; section -> duration += frame -> duration ; }
static void lo_release ( struct gendisk * disk , fmode_t mode ) { <S2SV_StartBug> struct loop_device * lo = disk -> private_data ; <S2SV_EndBug> int err ; if ( atomic_dec_return ( & lo -> lo_refcnt ) ) return ; mutex_lock ( & lo -> lo_ctl_mutex ) ; if ( lo -> lo_flags & LO_FLAGS_AUTOCLEAR ) { err = loop_clr_fd ( lo ) ; if ( ! err ) return ; } else if ( lo -> lo_state == Lo_bound ) { blk_mq_freeze_queue ( lo -> lo_queue ) ; blk_mq_unfreeze_queue ( lo -> lo_queue ) ; } <S2SV_StartBug> mutex_unlock ( & lo -> lo_ctl_mutex ) ; <S2SV_EndBug> }
static int cg_getattr ( const char * path , struct stat * sb ) { struct timespec now ; struct fuse_context * fc = fuse_get_context ( ) ; char * cgdir = NULL ; char * fpath = NULL , * path1 , * path2 ; struct cgfs_files * k = NULL ; const char * cgroup ; const char * controller = NULL ; int ret = - ENOENT ; if ( ! fc ) return - EIO ; memset ( sb , 0 , sizeof ( struct stat ) ) ; if ( clock_gettime ( CLOCK_REALTIME , & now ) < 0 ) return - EINVAL ; sb -> st_uid = sb -> st_gid = 0 ; sb -> st_atim = sb -> st_mtim = sb -> st_ctim = now ; sb -> st_size = 0 ; if ( strcmp ( path , "/cgroup" ) == 0 ) { sb -> st_mode = S_IFDIR | 00755 ; sb -> st_nlink = 2 ; return 0 ; } controller = pick_controller_from_path ( fc , path ) ; if ( ! controller ) return - EIO ; cgroup = find_cgroup_in_path ( path ) ; if ( ! cgroup ) { sb -> st_mode = S_IFDIR | 00755 ; sb -> st_nlink = 2 ; return 0 ; } get_cgdir_and_path ( cgroup , & cgdir , & fpath ) ; if ( ! fpath ) { path1 = "/" ; path2 = cgdir ; } else { path1 = cgdir ; path2 = fpath ; } if ( is_child_cgroup ( controller , path1 , path2 ) ) { <S2SV_StartBug> if ( ! caller_is_in_ancestor ( fc -> pid , controller , cgroup , NULL ) ) { <S2SV_EndBug> sb -> st_mode = S_IFDIR | 00555 ; sb -> st_nlink = 2 ; ret = 0 ; goto out ; } if ( ! fc_may_access ( fc , controller , cgroup , NULL , O_RDONLY ) ) { ret = - EACCES ; goto out ; } sb -> st_mode = S_IFDIR | 00755 ; k = cgfs_get_key ( controller , cgroup , "tasks" ) ; if ( ! k ) { sb -> st_uid = sb -> st_gid = 0 ; } else { sb -> st_uid = k -> uid ; sb -> st_gid = k -> gid ; } free_key ( k ) ; sb -> st_nlink = 2 ; ret = 0 ; goto out ; } if ( ( k = cgfs_get_key ( controller , path1 , path2 ) ) != NULL ) { sb -> st_mode = S_IFREG | k -> mode ; sb -> st_nlink = 1 ; sb -> st_uid = k -> uid ; sb -> st_gid = k -> gid ; sb -> st_size = 0 ; free_key ( k ) ; if ( ! caller_is_in_ancestor ( fc -> pid , controller , path1 , NULL ) ) { ret = - ENOENT ; goto out ; } if ( ! fc_may_access ( fc , controller , path1 , path2 , O_RDONLY ) ) { ret = - EACCES ; goto out ; } ret = 0 ; } out : free ( cgdir ) ; return ret ; }
static int parse_report ( transport_smart * transport , git_push * push ) { git_pkt * pkt = NULL ; const char * line_end = NULL ; gitno_buffer * buf = & transport -> buffer ; int error , recvd ; git_buf data_pkt_buf = GIT_BUF_INIT ; for ( ; ; ) { if ( buf -> offset > 0 ) error = git_pkt_parse_line ( & pkt , buf -> data , & line_end , buf -> offset ) ; else error = GIT_EBUFS ; if ( error < 0 && error != GIT_EBUFS ) { error = - 1 ; goto done ; } if ( error == GIT_EBUFS ) { if ( ( recvd = gitno_recv ( buf ) ) < 0 ) { error = recvd ; goto done ; } if ( recvd == 0 ) { giterr_set ( GITERR_NET , "early<S2SV_blank>EOF" ) ; error = GIT_EEOF ; goto done ; } continue ; } gitno_consume ( buf , line_end ) ; <S2SV_StartBug> error = 0 ; <S2SV_EndBug> if ( pkt == NULL ) continue ; switch ( pkt -> type ) { case GIT_PKT_DATA : error = add_push_report_sideband_pkt ( push , ( git_pkt_data * ) pkt , & data_pkt_buf ) ; break ; case GIT_PKT_ERR : giterr_set ( GITERR_NET , "report-status:<S2SV_blank>Error<S2SV_blank>reported:<S2SV_blank>%s" , ( ( git_pkt_err * ) pkt ) -> error ) ; error = - 1 ; break ; case GIT_PKT_PROGRESS : if ( transport -> progress_cb ) { git_pkt_progress * p = ( git_pkt_progress * ) pkt ; error = transport -> progress_cb ( p -> data , p -> len , transport -> message_cb_payload ) ; } break ; default : error = add_push_report_pkt ( push , pkt ) ; break ; } git_pkt_free ( pkt ) ; if ( error == GIT_ITEROVER ) { error = 0 ; if ( data_pkt_buf . size > 0 ) { giterr_set ( GITERR_NET , "Incomplete<S2SV_blank>pack<S2SV_blank>data<S2SV_blank>pkt-line" ) ; error = GIT_ERROR ; } goto done ; } if ( error < 0 ) { goto done ; } } done : git_buf_free ( & data_pkt_buf ) ; return error ; }
static int do_replace ( struct net * net , const void __user * user , unsigned int len ) { int ret , countersize ; struct ebt_table_info * newinfo ; struct ebt_replace tmp ; if ( copy_from_user ( & tmp , user , sizeof ( tmp ) ) != 0 ) return - EFAULT ; if ( len != sizeof ( tmp ) + tmp . entries_size ) { BUGPRINT ( "Wrong<S2SV_blank>len<S2SV_blank>argument\\n" ) ; return - EINVAL ; } if ( tmp . entries_size == 0 ) { BUGPRINT ( "Entries_size<S2SV_blank>never<S2SV_blank>zero\\n" ) ; return - EINVAL ; } if ( tmp . nentries >= ( ( INT_MAX - sizeof ( struct ebt_table_info ) ) / NR_CPUS - SMP_CACHE_BYTES ) / sizeof ( struct ebt_counter ) ) return - ENOMEM ; if ( tmp . num_counters >= INT_MAX / sizeof ( struct ebt_counter ) ) return - ENOMEM ; <S2SV_StartBug> countersize = COUNTER_OFFSET ( tmp . nentries ) * nr_cpu_ids ; <S2SV_EndBug> newinfo = vmalloc ( sizeof ( * newinfo ) + countersize ) ; if ( ! newinfo ) return - ENOMEM ; if ( countersize ) memset ( newinfo -> counters , 0 , countersize ) ; newinfo -> entries = vmalloc ( tmp . entries_size ) ; if ( ! newinfo -> entries ) { ret = - ENOMEM ; goto free_newinfo ; } if ( copy_from_user ( newinfo -> entries , tmp . entries , tmp . entries_size ) != 0 ) { BUGPRINT ( "Couldn\'t<S2SV_blank>copy<S2SV_blank>entries<S2SV_blank>from<S2SV_blank>userspace\\n" ) ; ret = - EFAULT ; goto free_entries ; } ret = do_replace_finish ( net , & tmp , newinfo ) ; if ( ret == 0 ) return ret ; free_entries : vfree ( newinfo -> entries ) ; free_newinfo : vfree ( newinfo ) ; return ret ; }
static int mem_resize ( jas_stream_memobj_t * m , int bufsize ) { <S2SV_StartBug> unsigned char * buf ; <S2SV_EndBug> assert ( m -> buf_ ) ; assert ( bufsize >= 0 ) ; <S2SV_StartBug> if ( ! ( buf = jas_realloc2 ( m -> buf_ , bufsize , sizeof ( unsigned char ) ) ) ) { <S2SV_EndBug> return - 1 ; } m -> buf_ = buf ; m -> bufsize_ = bufsize ; return 0 ; }
int sock_setsockopt ( struct socket * sock , int level , int optname , char __user * optval , unsigned int optlen ) { struct sock * sk = sock -> sk ; int val ; int valbool ; struct linger ling ; int ret = 0 ; if ( optname == SO_BINDTODEVICE ) return sock_bindtodevice ( sk , optval , optlen ) ; if ( optlen < sizeof ( int ) ) return - EINVAL ; if ( get_user ( val , ( int __user * ) optval ) ) return - EFAULT ; valbool = val ? 1 : 0 ; lock_sock ( sk ) ; switch ( optname ) { case SO_DEBUG : if ( val && ! capable ( CAP_NET_ADMIN ) ) ret = - EACCES ; else sock_valbool_flag ( sk , SOCK_DBG , valbool ) ; break ; case SO_REUSEADDR : sk -> sk_reuse = ( valbool ? SK_CAN_REUSE : SK_NO_REUSE ) ; break ; case SO_TYPE : case SO_PROTOCOL : case SO_DOMAIN : case SO_ERROR : ret = - ENOPROTOOPT ; break ; case SO_DONTROUTE : sock_valbool_flag ( sk , SOCK_LOCALROUTE , valbool ) ; break ; case SO_BROADCAST : sock_valbool_flag ( sk , SOCK_BROADCAST , valbool ) ; break ; case SO_SNDBUF : <S2SV_StartBug> if ( val > sysctl_wmem_max ) <S2SV_EndBug> val = sysctl_wmem_max ; set_sndbuf : sk -> sk_userlocks |= SOCK_SNDBUF_LOCK ; <S2SV_StartBug> if ( ( val * 2 ) < SOCK_MIN_SNDBUF ) <S2SV_EndBug> sk -> sk_sndbuf = SOCK_MIN_SNDBUF ; else sk -> sk_sndbuf = val * 2 ; sk -> sk_write_space ( sk ) ; break ; case SO_SNDBUFFORCE : if ( ! capable ( CAP_NET_ADMIN ) ) { ret = - EPERM ; break ; } goto set_sndbuf ; case SO_RCVBUF : <S2SV_StartBug> if ( val > sysctl_rmem_max ) <S2SV_EndBug> val = sysctl_rmem_max ; set_rcvbuf : sk -> sk_userlocks |= SOCK_RCVBUF_LOCK ; <S2SV_StartBug> if ( ( val * 2 ) < SOCK_MIN_RCVBUF ) <S2SV_EndBug> sk -> sk_rcvbuf = SOCK_MIN_RCVBUF ; else sk -> sk_rcvbuf = val * 2 ; break ; case SO_RCVBUFFORCE : if ( ! capable ( CAP_NET_ADMIN ) ) { ret = - EPERM ; break ; } goto set_rcvbuf ; case SO_KEEPALIVE : # ifdef CONFIG_INET if ( sk -> sk_protocol == IPPROTO_TCP ) tcp_set_keepalive ( sk , valbool ) ; # endif sock_valbool_flag ( sk , SOCK_KEEPOPEN , valbool ) ; break ; case SO_OOBINLINE : sock_valbool_flag ( sk , SOCK_URGINLINE , valbool ) ; break ; case SO_NO_CHECK : sk -> sk_no_check = valbool ; break ; case SO_PRIORITY : if ( ( val >= 0 && val <= 6 ) || capable ( CAP_NET_ADMIN ) ) sk -> sk_priority = val ; else ret = - EPERM ; break ; case SO_LINGER : if ( optlen < sizeof ( ling ) ) { ret = - EINVAL ; break ; } if ( copy_from_user ( & ling , optval , sizeof ( ling ) ) ) { ret = - EFAULT ; break ; } if ( ! ling . l_onoff ) sock_reset_flag ( sk , SOCK_LINGER ) ; else { # if ( BITS_PER_LONG == 32 ) if ( ( unsigned int ) ling . l_linger >= MAX_SCHEDULE_TIMEOUT / HZ ) sk -> sk_lingertime = MAX_SCHEDULE_TIMEOUT ; else # endif sk -> sk_lingertime = ( unsigned int ) ling . l_linger * HZ ; sock_set_flag ( sk , SOCK_LINGER ) ; } break ; case SO_BSDCOMPAT : sock_warn_obsolete_bsdism ( "setsockopt" ) ; break ; case SO_PASSCRED : if ( valbool ) set_bit ( SOCK_PASSCRED , & sock -> flags ) ; else clear_bit ( SOCK_PASSCRED , & sock -> flags ) ; break ; case SO_TIMESTAMP : case SO_TIMESTAMPNS : if ( valbool ) { if ( optname == SO_TIMESTAMP ) sock_reset_flag ( sk , SOCK_RCVTSTAMPNS ) ; else sock_set_flag ( sk , SOCK_RCVTSTAMPNS ) ; sock_set_flag ( sk , SOCK_RCVTSTAMP ) ; sock_enable_timestamp ( sk , SOCK_TIMESTAMP ) ; } else { sock_reset_flag ( sk , SOCK_RCVTSTAMP ) ; sock_reset_flag ( sk , SOCK_RCVTSTAMPNS ) ; } break ; case SO_TIMESTAMPING : if ( val & ~ SOF_TIMESTAMPING_MASK ) { ret = - EINVAL ; break ; } sock_valbool_flag ( sk , SOCK_TIMESTAMPING_TX_HARDWARE , val & SOF_TIMESTAMPING_TX_HARDWARE ) ; sock_valbool_flag ( sk , SOCK_TIMESTAMPING_TX_SOFTWARE , val & SOF_TIMESTAMPING_TX_SOFTWARE ) ; sock_valbool_flag ( sk , SOCK_TIMESTAMPING_RX_HARDWARE , val & SOF_TIMESTAMPING_RX_HARDWARE ) ; if ( val & SOF_TIMESTAMPING_RX_SOFTWARE ) sock_enable_timestamp ( sk , SOCK_TIMESTAMPING_RX_SOFTWARE ) ; else sock_disable_timestamp ( sk , ( 1UL << SOCK_TIMESTAMPING_RX_SOFTWARE ) ) ; sock_valbool_flag ( sk , SOCK_TIMESTAMPING_SOFTWARE , val & SOF_TIMESTAMPING_SOFTWARE ) ; sock_valbool_flag ( sk , SOCK_TIMESTAMPING_SYS_HARDWARE , val & SOF_TIMESTAMPING_SYS_HARDWARE ) ; sock_valbool_flag ( sk , SOCK_TIMESTAMPING_RAW_HARDWARE , val & SOF_TIMESTAMPING_RAW_HARDWARE ) ; break ; case SO_RCVLOWAT : if ( val < 0 ) val = INT_MAX ; sk -> sk_rcvlowat = val ? : 1 ; break ; case SO_RCVTIMEO : ret = sock_set_timeout ( & sk -> sk_rcvtimeo , optval , optlen ) ; break ; case SO_SNDTIMEO : ret = sock_set_timeout ( & sk -> sk_sndtimeo , optval , optlen ) ; break ; case SO_ATTACH_FILTER : ret = - EINVAL ; if ( optlen == sizeof ( struct sock_fprog ) ) { struct sock_fprog fprog ; ret = - EFAULT ; if ( copy_from_user ( & fprog , optval , sizeof ( fprog ) ) ) break ; ret = sk_attach_filter ( & fprog , sk ) ; } break ; case SO_DETACH_FILTER : ret = sk_detach_filter ( sk ) ; break ; case SO_PASSSEC : if ( valbool ) set_bit ( SOCK_PASSSEC , & sock -> flags ) ; else clear_bit ( SOCK_PASSSEC , & sock -> flags ) ; break ; case SO_MARK : if ( ! capable ( CAP_NET_ADMIN ) ) ret = - EPERM ; else sk -> sk_mark = val ; break ; case SO_RXQ_OVFL : sock_valbool_flag ( sk , SOCK_RXQ_OVFL , valbool ) ; break ; case SO_WIFI_STATUS : sock_valbool_flag ( sk , SOCK_WIFI_STATUS , valbool ) ; break ; case SO_PEEK_OFF : if ( sock -> ops -> set_peek_off ) sock -> ops -> set_peek_off ( sk , val ) ; else ret = - EOPNOTSUPP ; break ; case SO_NOFCS : sock_valbool_flag ( sk , SOCK_NOFCS , valbool ) ; break ; default : ret = - ENOPROTOOPT ; break ; } release_sock ( sk ) ; return ret ; }
static MagickBooleanType ReadPSDChannelPixels ( Image * image , const size_t channels , const size_t row , const ssize_t type , const unsigned char * pixels , ExceptionInfo * exception ) { Quantum pixel ; register const unsigned char * p ; register Quantum * q ; register ssize_t x ; size_t packet_size ; unsigned short nibble ; p = pixels ; q = GetAuthenticPixels ( image , 0 , row , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) return MagickFalse ; packet_size = GetPSDPacketSize ( image ) ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( packet_size == 1 ) pixel = ScaleCharToQuantum ( * p ++ ) ; else { p = PushShortPixel ( MSBEndian , p , & nibble ) ; pixel = ScaleShortToQuantum ( nibble ) ; } switch ( type ) { case - 1 : { SetPixelAlpha ( image , pixel , q ) ; break ; } case - 2 : case 0 : { SetPixelRed ( image , pixel , q ) ; if ( channels == 1 || type == - 2 ) SetPixelGray ( image , pixel , q ) ; if ( image -> storage_class == PseudoClass ) { if ( packet_size == 1 ) SetPixelIndex ( image , ScaleQuantumToChar ( pixel ) , q ) ; else SetPixelIndex ( image , ScaleQuantumToShort ( pixel ) , q ) ; SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) ConstrainColormapIndex ( image , GetPixelIndex ( image , q ) , exception ) , q ) ; if ( image -> depth == 1 ) { ssize_t bit , number_bits ; number_bits = image -> columns - x ; if ( number_bits > 8 ) number_bits = 8 ; for ( bit = 0 ; bit < number_bits ; bit ++ ) { SetPixelIndex ( image , ( ( ( unsigned char ) pixel ) & ( 0x01 << ( 7 - bit ) ) ) != 0 ? 0 : 255 , q ) ; SetPixelViaPixelInfo ( image , image -> colormap + ( ssize_t ) <S2SV_StartBug> GetPixelIndex ( image , q ) , q ) ; <S2SV_EndBug> q += GetPixelChannels ( image ) ; x ++ ; } x -- ; continue ; } } break ; } case 1 : { if ( image -> storage_class == PseudoClass ) SetPixelAlpha ( image , pixel , q ) ; else SetPixelGreen ( image , pixel , q ) ; break ; } case 2 : { if ( image -> storage_class == PseudoClass ) SetPixelAlpha ( image , pixel , q ) ; else SetPixelBlue ( image , pixel , q ) ; break ; } case 3 : { if ( image -> colorspace == CMYKColorspace ) SetPixelBlack ( image , pixel , q ) ; else if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , pixel , q ) ; break ; } case 4 : { if ( ( IssRGBCompatibleColorspace ( image -> colorspace ) != MagickFalse ) && ( channels > 3 ) ) break ; if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , pixel , q ) ; break ; } default : break ; } q += GetPixelChannels ( image ) ; } return ( SyncAuthenticPixels ( image , exception ) ) ; }
int main ( int ac , char * * av ) { int c_flag = 0 , d_flag = 0 , D_flag = 0 , k_flag = 0 , s_flag = 0 ; int sock , fd , ch , result , saved_errno ; u_int nalloc ; char * shell , * format , * pidstr , * agentsocket = NULL ; fd_set * readsetp = NULL , * writesetp = NULL ; struct rlimit rlim ; extern int optind ; extern char * optarg ; pid_t pid ; char pidstrbuf [ 1 + 3 * sizeof pid ] ; struct timeval * tvp = NULL ; size_t len ; mode_t prev_mask ; ssh_malloc_init ( ) ; sanitise_stdfd ( ) ; setegid ( getgid ( ) ) ; setgid ( getgid ( ) ) ; # ifdef WITH_OPENSSL OpenSSL_add_all_algorithms ( ) ; # endif <S2SV_StartBug> while ( ( ch = getopt ( ac , av , "cDdksE:a:t:" ) ) != - 1 ) { <S2SV_EndBug> switch ( ch ) { case 'E' : fingerprint_hash = ssh_digest_alg_by_name ( optarg ) ; if ( fingerprint_hash == - 1 ) fatal ( "Invalid<S2SV_blank>hash<S2SV_blank>algorithm<S2SV_blank>\\"%s\\"" , optarg ) ; break ; case 'c' : if ( s_flag ) usage ( ) ; c_flag ++ ; break ; case 'k' : <S2SV_StartBug> k_flag ++ ; <S2SV_EndBug> break ; case 's' : if ( c_flag ) usage ( ) ; s_flag ++ ; break ; case 'd' : if ( d_flag || D_flag ) usage ( ) ; d_flag ++ ; break ; case 'D' : if ( d_flag || D_flag ) usage ( ) ; D_flag ++ ; break ; case 'a' : agentsocket = optarg ; break ; case 't' : if ( ( lifetime = convtime ( optarg ) ) == - 1 ) { fprintf ( stderr , "Invalid<S2SV_blank>lifetime\\n" ) ; usage ( ) ; } break ; default : usage ( ) ; } } ac -= optind ; av += optind ; if ( ac > 0 && ( c_flag || k_flag || s_flag || d_flag || D_flag ) ) usage ( ) ; <S2SV_StartBug> if ( ac == 0 && ! c_flag && ! s_flag ) { <S2SV_EndBug> shell = getenv ( "SHELL" ) ; if ( shell != NULL && ( len = strlen ( shell ) ) > 2 && strncmp ( shell + len - 3 , "csh" , 3 ) == 0 ) c_flag = 1 ; } if ( k_flag ) { const char * errstr = NULL ; pidstr = getenv ( SSH_AGENTPID_ENV_NAME ) ; if ( pidstr == NULL ) { fprintf ( stderr , "%s<S2SV_blank>not<S2SV_blank>set,<S2SV_blank>cannot<S2SV_blank>kill<S2SV_blank>agent\\n" , SSH_AGENTPID_ENV_NAME ) ; exit ( 1 ) ; } pid = ( int ) strtonum ( pidstr , 2 , INT_MAX , & errstr ) ; if ( errstr ) { fprintf ( stderr , "%s=\\"%s\\",<S2SV_blank>which<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>good<S2SV_blank>PID:<S2SV_blank>%s\\n" , SSH_AGENTPID_ENV_NAME , pidstr , errstr ) ; exit ( 1 ) ; } if ( kill ( pid , SIGTERM ) == - 1 ) { perror ( "kill" ) ; exit ( 1 ) ; } format = c_flag ? "unsetenv<S2SV_blank>%s;\\n" : "unset<S2SV_blank>%s;\\n" ; printf ( format , SSH_AUTHSOCKET_ENV_NAME ) ; printf ( format , SSH_AGENTPID_ENV_NAME ) ; printf ( "echo<S2SV_blank>Agent<S2SV_blank>pid<S2SV_blank>%ld<S2SV_blank>killed;\\n" , ( long ) pid ) ; exit ( 0 ) ; } parent_pid = getpid ( ) ; if ( agentsocket == NULL ) { mktemp_proto ( socket_dir , sizeof ( socket_dir ) ) ; if ( mkdtemp ( socket_dir ) == NULL ) { perror ( "mkdtemp:<S2SV_blank>private<S2SV_blank>socket<S2SV_blank>dir" ) ; exit ( 1 ) ; } snprintf ( socket_name , sizeof socket_name , "%s/agent.%ld" , socket_dir , ( long ) parent_pid ) ; } else { socket_dir [ 0 ] = '\\0' ; strlcpy ( socket_name , agentsocket , sizeof socket_name ) ; } prev_mask = umask ( 0177 ) ; sock = unix_listener ( socket_name , SSH_LISTEN_BACKLOG , 0 ) ; if ( sock < 0 ) { * socket_name = '\\0' ; cleanup_exit ( 1 ) ; } umask ( prev_mask ) ; if ( D_flag || d_flag ) { log_init ( __progname , d_flag ? SYSLOG_LEVEL_DEBUG3 : SYSLOG_LEVEL_INFO , SYSLOG_FACILITY_AUTH , 1 ) ; format = c_flag ? "setenv<S2SV_blank>%s<S2SV_blank>%s;\\n" : "%s=%s;<S2SV_blank>export<S2SV_blank>%s;\\n" ; printf ( format , SSH_AUTHSOCKET_ENV_NAME , socket_name , SSH_AUTHSOCKET_ENV_NAME ) ; printf ( "echo<S2SV_blank>Agent<S2SV_blank>pid<S2SV_blank>%ld;\\n" , ( long ) parent_pid ) ; fflush ( stdout ) ; goto skip ; } pid = fork ( ) ; if ( pid == - 1 ) { perror ( "fork" ) ; cleanup_exit ( 1 ) ; } if ( pid != 0 ) { close ( sock ) ; snprintf ( pidstrbuf , sizeof pidstrbuf , "%ld" , ( long ) pid ) ; if ( ac == 0 ) { format = c_flag ? "setenv<S2SV_blank>%s<S2SV_blank>%s;\\n" : "%s=%s;<S2SV_blank>export<S2SV_blank>%s;\\n" ; printf ( format , SSH_AUTHSOCKET_ENV_NAME , socket_name , SSH_AUTHSOCKET_ENV_NAME ) ; printf ( format , SSH_AGENTPID_ENV_NAME , pidstrbuf , SSH_AGENTPID_ENV_NAME ) ; printf ( "echo<S2SV_blank>Agent<S2SV_blank>pid<S2SV_blank>%ld;\\n" , ( long ) pid ) ; exit ( 0 ) ; } if ( setenv ( SSH_AUTHSOCKET_ENV_NAME , socket_name , 1 ) == - 1 || setenv ( SSH_AGENTPID_ENV_NAME , pidstrbuf , 1 ) == - 1 ) { perror ( "setenv" ) ; exit ( 1 ) ; } execvp ( av [ 0 ] , av ) ; perror ( av [ 0 ] ) ; exit ( 1 ) ; } log_init ( __progname , SYSLOG_LEVEL_INFO , SYSLOG_FACILITY_AUTH , 0 ) ; if ( setsid ( ) == - 1 ) { error ( "setsid:<S2SV_blank>%s" , strerror ( errno ) ) ; cleanup_exit ( 1 ) ; } ( void ) chdir ( "/" ) ; if ( ( fd = open ( _PATH_DEVNULL , O_RDWR , 0 ) ) != - 1 ) { ( void ) dup2 ( fd , STDIN_FILENO ) ; ( void ) dup2 ( fd , STDOUT_FILENO ) ; ( void ) dup2 ( fd , STDERR_FILENO ) ; if ( fd > 2 ) close ( fd ) ; } rlim . rlim_cur = rlim . rlim_max = 0 ; if ( setrlimit ( RLIMIT_CORE , & rlim ) < 0 ) { error ( "setrlimit<S2SV_blank>RLIMIT_CORE:<S2SV_blank>%s" , strerror ( errno ) ) ; cleanup_exit ( 1 ) ; } skip : cleanup_pid = getpid ( ) ; # ifdef ENABLE_PKCS11 pkcs11_init ( 0 ) ; # endif new_socket ( AUTH_SOCKET , sock ) ; if ( ac > 0 ) parent_alive_interval = 10 ; idtab_init ( ) ; signal ( SIGPIPE , SIG_IGN ) ; signal ( SIGINT , ( d_flag | D_flag ) ? cleanup_handler : SIG_IGN ) ; signal ( SIGHUP , cleanup_handler ) ; signal ( SIGTERM , cleanup_handler ) ; nalloc = 0 ; <S2SV_StartBug> if ( pledge ( "stdio<S2SV_blank>cpath<S2SV_blank>unix<S2SV_blank>id<S2SV_blank>proc<S2SV_blank>exec" , NULL ) == - 1 ) <S2SV_EndBug> fatal ( "%s:<S2SV_blank>pledge:<S2SV_blank>%s" , __progname , strerror ( errno ) ) ; while ( 1 ) { prepare_select ( & readsetp , & writesetp , & max_fd , & nalloc , & tvp ) ; result = select ( max_fd + 1 , readsetp , writesetp , NULL , tvp ) ; saved_errno = errno ; if ( parent_alive_interval != 0 ) check_parent_exists ( ) ; ( void ) reaper ( ) ; if ( result < 0 ) { if ( saved_errno == EINTR ) continue ; fatal ( "select:<S2SV_blank>%s" , strerror ( saved_errno ) ) ; } else if ( result > 0 ) after_select ( readsetp , writesetp ) ; } }
int jas_matrix_cmp ( jas_matrix_t * mat0 , jas_matrix_t * mat1 ) { <S2SV_StartBug> int i ; <S2SV_EndBug> int j ; if ( mat0 -> numrows_ != mat1 -> numrows_ || mat0 -> numcols_ != mat1 -> numcols_ ) { return 1 ; } for ( i = 0 ; i < mat0 -> numrows_ ; i ++ ) { for ( j = 0 ; j < mat0 -> numcols_ ; j ++ ) { if ( jas_matrix_get ( mat0 , i , j ) != jas_matrix_get ( mat1 , i , j ) ) { return 1 ; } } } return 0 ; }
void ndpi_search_h323 ( struct ndpi_detection_module_struct * ndpi_struct , struct ndpi_flow_struct * flow ) { struct ndpi_packet_struct * packet = & flow -> packet ; u_int16_t dport = 0 , sport = 0 ; NDPI_LOG_DBG ( ndpi_struct , "search<S2SV_blank>H323\\n" ) ; if ( ( packet -> tcp != NULL ) && ( packet -> tcp -> dest != ntohs ( 102 ) ) ) { NDPI_LOG_DBG2 ( ndpi_struct , "calculated<S2SV_blank>dport<S2SV_blank>over<S2SV_blank>tcp\\n" ) ; if ( packet -> payload_packet_len >= 4 && ( packet -> payload [ 0 ] == 0x03 ) && ( packet -> payload [ 1 ] == 0x00 ) ) { struct tpkt * t = ( struct tpkt * ) packet -> payload ; u_int16_t len = ntohs ( t -> len ) ; if ( packet -> payload_packet_len == len ) { if ( packet -> payload [ 4 ] == ( packet -> payload_packet_len - sizeof ( struct tpkt ) - 1 ) ) { if ( ( packet -> payload [ 5 ] == 0xE0 ) || ( packet -> payload [ 5 ] == 0xD0 ) ) { NDPI_LOG_INFO ( ndpi_struct , "found<S2SV_blank>RDP\\n" ) ; ndpi_set_detected_protocol ( ndpi_struct , flow , NDPI_PROTOCOL_RDP , NDPI_PROTOCOL_UNKNOWN ) ; return ; } } flow -> l4 . tcp . h323_valid_packets ++ ; if ( flow -> l4 . tcp . h323_valid_packets >= 2 ) { NDPI_LOG_INFO ( ndpi_struct , "found<S2SV_blank>H323<S2SV_blank>broadcast\\n" ) ; ndpi_set_detected_protocol ( ndpi_struct , flow , NDPI_PROTOCOL_H323 , NDPI_PROTOCOL_UNKNOWN ) ; } } else { NDPI_EXCLUDE_PROTO ( ndpi_struct , flow ) ; return ; } } } else if ( packet -> udp != NULL ) { sport = ntohs ( packet -> udp -> source ) , dport = ntohs ( packet -> udp -> dest ) ; NDPI_LOG_DBG2 ( ndpi_struct , "calculated<S2SV_blank>dport<S2SV_blank>over<S2SV_blank>udp\\n" ) ; if ( packet -> payload_packet_len >= 6 && packet -> payload [ 0 ] == 0x80 && packet -> payload [ 1 ] == 0x08 && ( packet -> payload [ 2 ] == 0xe7 || packet -> payload [ 2 ] == 0x26 ) && packet -> payload [ 4 ] == 0x00 && packet -> payload [ 5 ] == 0x00 ) { NDPI_LOG_INFO ( ndpi_struct , "found<S2SV_blank>H323<S2SV_blank>broadcast\\n" ) ; ndpi_set_detected_protocol ( ndpi_struct , flow , NDPI_PROTOCOL_H323 , NDPI_PROTOCOL_UNKNOWN ) ; return ; } if ( sport == 1719 || dport == 1719 ) <S2SV_StartBug> { <S2SV_EndBug> <S2SV_StartBug> if ( packet -> payload [ 0 ] == 0x16 && packet -> payload [ 1 ] == 0x80 && packet -> payload [ 4 ] == 0x06 && packet -> payload [ 5 ] == 0x00 ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> NDPI_LOG_INFO ( ndpi_struct , "found<S2SV_blank>H323<S2SV_blank>broadcast\\n" ) ; ndpi_set_detected_protocol ( ndpi_struct , flow , NDPI_PROTOCOL_H323 , NDPI_PROTOCOL_UNKNOWN ) ; return ; } else if ( packet -> payload_packet_len >= 20 && packet -> payload_packet_len <= 117 ) { NDPI_LOG_INFO ( ndpi_struct , "found<S2SV_blank>H323<S2SV_blank>broadcast\\n" ) ; ndpi_set_detected_protocol ( ndpi_struct , flow , NDPI_PROTOCOL_H323 , NDPI_PROTOCOL_UNKNOWN ) ; return ; } else { NDPI_EXCLUDE_PROTO ( ndpi_struct , flow ) ; return ; } } } }
static int do_remount ( struct path * path , int flags , int mnt_flags , void * data ) { int err ; struct super_block * sb = path -> mnt -> mnt_sb ; struct mount * mnt = real_mount ( path -> mnt ) ; if ( ! check_mnt ( mnt ) ) return - EINVAL ; if ( path -> dentry != path -> mnt -> mnt_root ) return - EINVAL ; err = security_sb_remount ( sb , data ) ; if ( err ) return err ; down_write ( & sb -> s_umount ) ; if ( flags & MS_BIND ) err = change_mount_flags ( path -> mnt , flags ) ; else if ( ! capable ( CAP_SYS_ADMIN ) ) err = - EPERM ; else err = do_remount_sb ( sb , flags , data , 0 ) ; if ( ! err ) { lock_mount_hash ( ) ; <S2SV_StartBug> mnt_flags |= mnt -> mnt . mnt_flags & MNT_PROPAGATION_MASK ; <S2SV_EndBug> mnt -> mnt . mnt_flags = mnt_flags ; touch_mnt_namespace ( mnt -> mnt_ns ) ; unlock_mount_hash ( ) ; } up_write ( & sb -> s_umount ) ; return err ; }
void gtkui_conf_read ( void ) { FILE * fd ; const char * path ; char line [ 100 ] , name [ 30 ] ; short value ; # ifdef OS_WINDOWS path = ec_win_get_user_dir ( ) ; # else <S2SV_StartBug> path = g_get_tmp_dir ( ) ; <S2SV_EndBug> # endif filename = g_build_filename ( path , ".ettercap_gtk" , NULL ) ; DEBUG_MSG ( "gtkui_conf_read:<S2SV_blank>%s" , filename ) ; fd = fopen ( filename , "r" ) ; if ( ! fd ) return ; while ( fgets ( line , 100 , fd ) ) { sscanf ( line , "%s<S2SV_blank>=<S2SV_blank>%hd" , name , & value ) ; gtkui_conf_set ( name , value ) ; } fclose ( fd ) ; }
static vpx_image_t * img_alloc_helper ( vpx_image_t * img , vpx_img_fmt_t fmt , unsigned int d_w , unsigned int d_h , unsigned int buf_align , unsigned int stride_align , unsigned char * img_data ) { unsigned int h , w , s , xcs , ycs , bps ; unsigned int stride_in_bytes ; int align ; if ( ! buf_align ) buf_align = 1 ; if ( buf_align & ( buf_align - 1 ) ) goto fail ; if ( ! stride_align ) stride_align = 1 ; if ( stride_align & ( stride_align - 1 ) ) goto fail ; switch ( fmt ) { case VPX_IMG_FMT_RGB32 : case VPX_IMG_FMT_RGB32_LE : case VPX_IMG_FMT_ARGB : case VPX_IMG_FMT_ARGB_LE : bps = 32 ; break ; case VPX_IMG_FMT_RGB24 : case VPX_IMG_FMT_BGR24 : bps = 24 ; break ; case VPX_IMG_FMT_RGB565 : case VPX_IMG_FMT_RGB565_LE : case VPX_IMG_FMT_RGB555 : case VPX_IMG_FMT_RGB555_LE : case VPX_IMG_FMT_UYVY : case VPX_IMG_FMT_YUY2 : case VPX_IMG_FMT_YVYU : bps = 16 ; break ; case VPX_IMG_FMT_I420 : case VPX_IMG_FMT_YV12 : case VPX_IMG_FMT_VPXI420 : case VPX_IMG_FMT_VPXYV12 : bps = 12 ; break ; case VPX_IMG_FMT_I422 : case VPX_IMG_FMT_I440 : bps = 16 ; break ; case VPX_IMG_FMT_I444 : bps = 24 ; break ; case VPX_IMG_FMT_I42016 : bps = 24 ; break ; case VPX_IMG_FMT_I42216 : case VPX_IMG_FMT_I44016 : bps = 32 ; break ; case VPX_IMG_FMT_I44416 : bps = 48 ; break ; default : bps = 16 ; break ; } switch ( fmt ) { case VPX_IMG_FMT_I420 : case VPX_IMG_FMT_YV12 : case VPX_IMG_FMT_VPXI420 : case VPX_IMG_FMT_VPXYV12 : case VPX_IMG_FMT_I422 : case VPX_IMG_FMT_I42016 : case VPX_IMG_FMT_I42216 : xcs = 1 ; break ; default : xcs = 0 ; break ; } switch ( fmt ) { case VPX_IMG_FMT_I420 : case VPX_IMG_FMT_I440 : case VPX_IMG_FMT_YV12 : case VPX_IMG_FMT_VPXI420 : case VPX_IMG_FMT_VPXYV12 : case VPX_IMG_FMT_I42016 : case VPX_IMG_FMT_I44016 : ycs = 1 ; break ; default : ycs = 0 ; break ; } <S2SV_StartBug> align = ( 1 << xcs ) - 1 ; <S2SV_EndBug> w = ( d_w + align ) & ~ align ; align = ( 1 << ycs ) - 1 ; h = ( d_h + align ) & ~ align ; s = ( fmt & VPX_IMG_FMT_PLANAR ) ? w : bps * w / 8 ; s = ( s + stride_align - 1 ) & ~ ( stride_align - 1 ) ; stride_in_bytes = ( fmt & VPX_IMG_FMT_HIGHBITDEPTH ) ? s * 2 : s ; <S2SV_StartBug> if ( ! img ) { <S2SV_EndBug> img = ( vpx_image_t * ) calloc ( 1 , sizeof ( vpx_image_t ) ) ; if ( ! img ) goto fail ; img -> self_allocd = 1 ; } else { memset ( img , 0 , sizeof ( vpx_image_t ) ) ; } img -> img_data = img_data ; if ( ! img_data ) { const uint64_t alloc_size = ( fmt & VPX_IMG_FMT_PLANAR ) ? ( uint64_t ) h * s * bps / 8 : ( uint64_t ) h * s ; if ( alloc_size != ( size_t ) alloc_size ) goto fail ; img -> img_data = ( uint8_t * ) vpx_memalign ( buf_align , ( size_t ) alloc_size ) ; img -> img_data_owner = 1 ; } if ( ! img -> img_data ) goto fail ; img -> fmt = fmt ; img -> bit_depth = ( fmt & VPX_IMG_FMT_HIGHBITDEPTH ) ? 16 : 8 ; img -> w = w ; img -> h = h ; img -> x_chroma_shift = xcs ; img -> y_chroma_shift = ycs ; img -> bps = bps ; img -> stride [ VPX_PLANE_Y ] = img -> stride [ VPX_PLANE_ALPHA ] = stride_in_bytes ; img -> stride [ VPX_PLANE_U ] = img -> stride [ VPX_PLANE_V ] = stride_in_bytes >> xcs ; if ( ! vpx_img_set_rect ( img , 0 , 0 , d_w , d_h ) ) return img ; fail : vpx_img_free ( img ) ; return NULL ; }
struct file * get_empty_filp ( void ) { const struct cred * cred = current_cred ( ) ; static long old_max ; struct file * f ; int error ; if ( get_nr_files ( ) >= files_stat . max_files && ! capable ( CAP_SYS_ADMIN ) ) { if ( percpu_counter_sum_positive ( & nr_files ) >= files_stat . max_files ) goto over ; } f = kmem_cache_zalloc ( filp_cachep , GFP_KERNEL ) ; if ( unlikely ( ! f ) ) return ERR_PTR ( - ENOMEM ) ; percpu_counter_inc ( & nr_files ) ; f -> f_cred = get_cred ( cred ) ; error = security_file_alloc ( f ) ; if ( unlikely ( error ) ) { file_free ( f ) ; return ERR_PTR ( error ) ; } <S2SV_StartBug> INIT_LIST_HEAD ( & f -> f_u . fu_list ) ; <S2SV_EndBug> atomic_long_set ( & f -> f_count , 1 ) ; rwlock_init ( & f -> f_owner . lock ) ; spin_lock_init ( & f -> f_lock ) ; eventpoll_init_file ( f ) ; return f ; over : if ( get_nr_files ( ) > old_max ) { pr_info ( "VFS:<S2SV_blank>file-max<S2SV_blank>limit<S2SV_blank>%lu<S2SV_blank>reached\\n" , get_max_files ( ) ) ; old_max = get_nr_files ( ) ; } return ERR_PTR ( - ENFILE ) ; }
int socket_create ( uint16_t port ) { int sfd = - 1 ; int yes = 1 ; # ifdef WIN32 WSADATA wsa_data ; if ( ! wsa_init ) { if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsa_data ) != ERROR_SUCCESS ) { fprintf ( stderr , "WSAStartup<S2SV_blank>failed!\\n" ) ; ExitProcess ( - 1 ) ; } wsa_init = 1 ; } # endif struct sockaddr_in saddr ; if ( 0 > ( sfd = socket ( PF_INET , SOCK_STREAM , IPPROTO_TCP ) ) ) { perror ( "socket()" ) ; return - 1 ; } if ( setsockopt ( sfd , SOL_SOCKET , SO_REUSEADDR , ( void * ) & yes , sizeof ( int ) ) == - 1 ) { perror ( "setsockopt()" ) ; socket_close ( sfd ) ; return - 1 ; } memset ( ( void * ) & saddr , 0 , sizeof ( saddr ) ) ; saddr . sin_family = AF_INET ; <S2SV_StartBug> saddr . sin_addr . s_addr = htonl ( INADDR_ANY ) ; <S2SV_EndBug> saddr . sin_port = htons ( port ) ; if ( 0 > bind ( sfd , ( struct sockaddr * ) & saddr , sizeof ( saddr ) ) ) { perror ( "bind()" ) ; socket_close ( sfd ) ; return - 1 ; } if ( listen ( sfd , 1 ) == - 1 ) { perror ( "listen()" ) ; socket_close ( sfd ) ; return - 1 ; } return sfd ; }
static ssize_t ib_uverbs_write ( struct file * filp , const char __user * buf , size_t count , loff_t * pos ) { struct ib_uverbs_file * file = filp -> private_data ; struct ib_device * ib_dev ; struct ib_uverbs_cmd_hdr hdr ; __u32 command ; __u32 flags ; int srcu_key ; ssize_t ret ; <S2SV_StartBug> if ( count < sizeof hdr ) <S2SV_EndBug> return - EINVAL ; if ( copy_from_user ( & hdr , buf , sizeof hdr ) ) return - EFAULT ; srcu_key = srcu_read_lock ( & file -> device -> disassociate_srcu ) ; ib_dev = srcu_dereference ( file -> device -> ib_dev , & file -> device -> disassociate_srcu ) ; if ( ! ib_dev ) { ret = - EIO ; goto out ; } if ( hdr . command & ~ ( __u32 ) ( IB_USER_VERBS_CMD_FLAGS_MASK | IB_USER_VERBS_CMD_COMMAND_MASK ) ) { ret = - EINVAL ; goto out ; } command = hdr . command & IB_USER_VERBS_CMD_COMMAND_MASK ; if ( verify_command_mask ( ib_dev , command ) ) { ret = - EOPNOTSUPP ; goto out ; } if ( ! file -> ucontext && command != IB_USER_VERBS_CMD_GET_CONTEXT ) { ret = - EINVAL ; goto out ; } flags = ( hdr . command & IB_USER_VERBS_CMD_FLAGS_MASK ) >> IB_USER_VERBS_CMD_FLAGS_SHIFT ; if ( ! flags ) { if ( command >= ARRAY_SIZE ( uverbs_cmd_table ) || ! uverbs_cmd_table [ command ] ) { ret = - EINVAL ; goto out ; } if ( hdr . in_words * 4 != count ) { ret = - EINVAL ; goto out ; } ret = uverbs_cmd_table [ command ] ( file , ib_dev , buf + sizeof ( hdr ) , hdr . in_words * 4 , hdr . out_words * 4 ) ; } else if ( flags == IB_USER_VERBS_CMD_FLAG_EXTENDED ) { struct ib_uverbs_ex_cmd_hdr ex_hdr ; struct ib_udata ucore ; struct ib_udata uhw ; size_t written_count = count ; if ( command >= ARRAY_SIZE ( uverbs_ex_cmd_table ) || ! uverbs_ex_cmd_table [ command ] ) { ret = - ENOSYS ; goto out ; } if ( ! file -> ucontext ) { ret = - EINVAL ; goto out ; } if ( count < ( sizeof ( hdr ) + sizeof ( ex_hdr ) ) ) { ret = - EINVAL ; goto out ; } if ( copy_from_user ( & ex_hdr , buf + sizeof ( hdr ) , sizeof ( ex_hdr ) ) ) { ret = - EFAULT ; goto out ; } count -= sizeof ( hdr ) + sizeof ( ex_hdr ) ; buf += sizeof ( hdr ) + sizeof ( ex_hdr ) ; if ( ( hdr . in_words + ex_hdr . provider_in_words ) * 8 != count ) { ret = - EINVAL ; goto out ; } if ( ex_hdr . cmd_hdr_reserved ) { ret = - EINVAL ; goto out ; } if ( ex_hdr . response ) { if ( ! hdr . out_words && ! ex_hdr . provider_out_words ) { ret = - EINVAL ; goto out ; } if ( ! access_ok ( VERIFY_WRITE , ( void __user * ) ( unsigned long ) ex_hdr . response , ( hdr . out_words + ex_hdr . provider_out_words ) * 8 ) ) { ret = - EFAULT ; goto out ; } } else { if ( hdr . out_words || ex_hdr . provider_out_words ) { ret = - EINVAL ; goto out ; } } INIT_UDATA_BUF_OR_NULL ( & ucore , buf , ( unsigned long ) ex_hdr . response , hdr . in_words * 8 , hdr . out_words * 8 ) ; INIT_UDATA_BUF_OR_NULL ( & uhw , buf + ucore . inlen , ( unsigned long ) ex_hdr . response + ucore . outlen , ex_hdr . provider_in_words * 8 , ex_hdr . provider_out_words * 8 ) ; ret = uverbs_ex_cmd_table [ command ] ( file , ib_dev , & ucore , & uhw ) ; if ( ! ret ) ret = written_count ; } else { ret = - ENOSYS ; } out : srcu_read_unlock ( & file -> device -> disassociate_srcu , srcu_key ) ; return ret ; }
static u_int16_t concat_hash_string ( struct ndpi_packet_struct * packet , char * buf , u_int8_t client_hash ) { u_int16_t offset = 22 , buf_out_len = 0 ; if ( offset + sizeof ( u_int32_t ) >= packet -> payload_packet_len ) goto invalid_payload ; u_int32_t len = ntohl ( * ( u_int32_t * ) & packet -> payload [ offset ] ) ; offset += 4 ; if ( ( offset >= packet -> payload_packet_len ) || ( len >= packet -> payload_packet_len - offset - 1 ) ) goto invalid_payload ; strncpy ( buf , ( const char * ) & packet -> payload [ offset ] , buf_out_len = len ) ; buf [ buf_out_len ++ ] = ';' ; offset += len ; <S2SV_StartBug> len = ntohl ( * ( u_int32_t * ) & packet -> payload [ offset ] ) ; <S2SV_EndBug> <S2SV_StartBug> offset += 4 + len ; <S2SV_EndBug> len = ntohl ( * ( u_int32_t * ) & packet -> payload [ offset ] ) ; if ( client_hash ) { offset += 4 ; if ( ( offset >= packet -> payload_packet_len ) || ( len >= packet -> payload_packet_len - offset - 1 ) ) goto invalid_payload ; strncpy ( & buf [ buf_out_len ] , ( const char * ) & packet -> payload [ offset ] , len ) ; buf_out_len += len ; buf [ buf_out_len ++ ] = ';' ; offset += len ; } else offset += 4 + len ; <S2SV_StartBug> len = ntohl ( * ( u_int32_t * ) & packet -> payload [ offset ] ) ; <S2SV_EndBug> if ( ! client_hash ) { offset += 4 ; if ( ( offset >= packet -> payload_packet_len ) || ( len >= packet -> payload_packet_len - offset - 1 ) ) goto invalid_payload ; strncpy ( & buf [ buf_out_len ] , ( const char * ) & packet -> payload [ offset ] , len ) ; buf_out_len += len ; buf [ buf_out_len ++ ] = ';' ; offset += len ; } else offset += 4 + len ; <S2SV_StartBug> len = ntohl ( * ( u_int32_t * ) & packet -> payload [ offset ] ) ; <S2SV_EndBug> if ( client_hash ) { offset += 4 ; if ( ( offset >= packet -> payload_packet_len ) || ( len >= packet -> payload_packet_len - offset - 1 ) ) goto invalid_payload ; strncpy ( & buf [ buf_out_len ] , ( const char * ) & packet -> payload [ offset ] , len ) ; buf_out_len += len ; buf [ buf_out_len ++ ] = ';' ; offset += len ; } else offset += 4 + len ; <S2SV_StartBug> len = ntohl ( * ( u_int32_t * ) & packet -> payload [ offset ] ) ; <S2SV_EndBug> if ( ! client_hash ) { offset += 4 ; if ( ( offset >= packet -> payload_packet_len ) || ( len >= packet -> payload_packet_len - offset - 1 ) ) goto invalid_payload ; strncpy ( & buf [ buf_out_len ] , ( const char * ) & packet -> payload [ offset ] , len ) ; buf_out_len += len ; buf [ buf_out_len ++ ] = ';' ; offset += len ; } else offset += 4 + len ; if ( offset + sizeof ( u_int32_t ) >= packet -> payload_packet_len ) goto invalid_payload ; len = ntohl ( * ( u_int32_t * ) & packet -> payload [ offset ] ) ; if ( client_hash ) { offset += 4 ; if ( ( offset >= packet -> payload_packet_len ) || ( len >= packet -> payload_packet_len - offset - 1 ) ) goto invalid_payload ; strncpy ( & buf [ buf_out_len ] , ( const char * ) & packet -> payload [ offset ] , len ) ; buf_out_len += len ; offset += len ; } else <S2SV_StartBug> offset += 4 + len ; <S2SV_EndBug> len = ntohl ( * ( u_int32_t * ) & packet -> payload [ offset ] ) ; if ( ! client_hash ) { offset += 4 ; if ( ( offset >= packet -> payload_packet_len ) || ( len >= packet -> payload_packet_len - offset - 1 ) ) goto invalid_payload ; strncpy ( & buf [ buf_out_len ] , ( const char * ) & packet -> payload [ offset ] , len ) ; buf_out_len += len ; offset += len ; } else offset += 4 + len ; # ifdef SSH_DEBUG printf ( "[SSH]<S2SV_blank>%s\\n" , buf ) ; # endif return ( buf_out_len ) ; invalid_payload : # ifdef SSH_DEBUG printf ( "[SSH]<S2SV_blank>Invalid<S2SV_blank>packet<S2SV_blank>payload\\n" ) ; # endif return ( 0 ) ; }
unsigned int arpt_do_table ( struct sk_buff * skb , const struct nf_hook_state * state , struct xt_table * table ) { unsigned int hook = state -> hook ; static const char nulldevname [ IFNAMSIZ ] __attribute__ ( ( aligned ( sizeof ( long ) ) ) ) ; unsigned int verdict = NF_DROP ; const struct arphdr * arp ; struct arpt_entry * e , * * jumpstack ; const char * indev , * outdev ; const void * table_base ; unsigned int cpu , stackidx = 0 ; const struct xt_table_info * private ; struct xt_action_param acpar ; unsigned int addend ; if ( ! pskb_may_pull ( skb , arp_hdr_len ( skb -> dev ) ) ) return NF_DROP ; indev = state -> in ? state -> in -> name : nulldevname ; outdev = state -> out ? state -> out -> name : nulldevname ; local_bh_disable ( ) ; addend = xt_write_recseq_begin ( ) ; private = READ_ONCE ( table -> private ) ; cpu = smp_processor_id ( ) ; table_base = private -> entries ; jumpstack = ( struct arpt_entry * * ) private -> jumpstack [ cpu ] ; e = get_entry ( table_base , private -> hook_entry [ hook ] ) ; acpar . state = state ; acpar . hotdrop = false ; arp = arp_hdr ( skb ) ; do { const struct xt_entry_target * t ; struct xt_counters * counter ; if ( ! arp_packet_match ( arp , skb -> dev , indev , outdev , & e -> arp ) ) { e = arpt_next_entry ( e ) ; continue ; } counter = xt_get_this_cpu_counter ( & e -> counters ) ; ADD_COUNTER ( * counter , arp_hdr_len ( skb -> dev ) , 1 ) ; t = arpt_get_target_c ( e ) ; if ( ! t -> u . kernel . target -> target ) { int v ; v = ( ( struct xt_standard_target * ) t ) -> verdict ; if ( v < 0 ) { if ( v != XT_RETURN ) { verdict = ( unsigned int ) ( - v ) - 1 ; break ; } if ( stackidx == 0 ) { e = get_entry ( table_base , private -> underflow [ hook ] ) ; } else { e = jumpstack [ -- stackidx ] ; e = arpt_next_entry ( e ) ; } continue ; } if ( table_base + v != arpt_next_entry ( e ) ) { <S2SV_StartBug> jumpstack [ stackidx ++ ] = e ; <S2SV_EndBug> } e = get_entry ( table_base , v ) ; continue ; } acpar . target = t -> u . kernel . target ; acpar . targinfo = t -> data ; verdict = t -> u . kernel . target -> target ( skb , & acpar ) ; if ( verdict == XT_CONTINUE ) { arp = arp_hdr ( skb ) ; e = arpt_next_entry ( e ) ; } else { break ; } } while ( ! acpar . hotdrop ) ; xt_write_recseq_end ( addend ) ; local_bh_enable ( ) ; if ( acpar . hotdrop ) return NF_DROP ; else return verdict ; }
static void add_bytes_l2_c ( uint8_t * dst , uint8_t * src1 , uint8_t * src2 , int w ) { long i ; <S2SV_StartBug> for ( i = 0 ; i <= w - sizeof ( long ) ; i += sizeof ( long ) ) { <S2SV_EndBug> long a = * ( long * ) ( src1 + i ) ; long b = * ( long * ) ( src2 + i ) ; * ( long * ) ( dst + i ) = ( ( a & pb_7f ) + ( b & pb_7f ) ) ^ ( ( a ^ b ) & pb_80 ) ; } for ( ; i < w ; i ++ ) dst [ i ] = src1 [ i ] + src2 [ i ] ; }
static void xen_irq_init ( unsigned irq ) { struct irq_info * info ; # ifdef CONFIG_SMP cpumask_copy ( irq_get_affinity_mask ( irq ) , cpumask_of ( 0 ) ) ; # endif info = kzalloc ( sizeof ( * info ) , GFP_KERNEL ) ; if ( info == NULL ) panic ( "Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>metadata<S2SV_blank>for<S2SV_blank>IRQ%d\\n" , irq ) ; info -> type = IRQT_UNBOUND ; info -> refcnt = - 1 ; set_info_for_irq ( irq , info ) ; <S2SV_StartBug> list_add_tail ( & info -> list , & xen_irq_list_head ) ; <S2SV_EndBug> }
static void update_buffer_level ( VP9_COMP * cpi , int encoded_frame_size ) { <S2SV_StartBug> const VP9_COMMON * const cm = & cpi -> common ; <S2SV_EndBug> const VP9_CONFIG * oxcf = & cpi -> oxcf ; RATE_CONTROL * const rc = & cpi -> rc ; if ( ! cm -> show_frame ) { rc -> bits_off_target -= encoded_frame_size ; } else { <S2SV_StartBug> rc -> bits_off_target += rc -> av_per_frame_bandwidth - encoded_frame_size ; <S2SV_EndBug> } <S2SV_StartBug> rc -> bits_off_target = MIN ( rc -> bits_off_target , oxcf -> maximum_buffer_size ) ; <S2SV_EndBug> rc -> buffer_level = rc -> bits_off_target ; <S2SV_StartBug> if ( cpi -> use_svc && cpi -> oxcf . end_usage == USAGE_STREAM_FROM_SERVER ) { <S2SV_EndBug> update_layer_buffer_level ( & cpi -> svc , encoded_frame_size ) ; } }
static Image * ReadSUNImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define RMT_EQUAL_RGB 1 # define RMT_NONE 0 # define RMT_RAW 2 # define RT_STANDARD 1 # define RT_ENCODED 2 # define RT_FORMAT_RGB 3 typedef struct _SUNInfo { unsigned int magic , width , height , depth , length , type , maptype , maplength ; } SUNInfo ; Image * image ; int bit ; MagickBooleanType status ; MagickSizeType number_pixels ; register Quantum * q ; register ssize_t i , x ; register unsigned char * p ; size_t bytes_per_line , extent , length ; ssize_t count , y ; SUNInfo sun_info ; unsigned char * sun_data , * sun_pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , "%s" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) ResetMagickMemory ( & sun_info , 0 , sizeof ( sun_info ) ) ; sun_info . magic = ReadBlobMSBLong ( image ) ; do { if ( sun_info . magic != 0x59a66a95 ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; sun_info . width = ReadBlobMSBLong ( image ) ; sun_info . height = ReadBlobMSBLong ( image ) ; sun_info . depth = ReadBlobMSBLong ( image ) ; sun_info . length = ReadBlobMSBLong ( image ) ; sun_info . type = ReadBlobMSBLong ( image ) ; sun_info . maptype = ReadBlobMSBLong ( image ) ; sun_info . maplength = ReadBlobMSBLong ( image ) ; extent = sun_info . height * sun_info . width ; if ( ( sun_info . height != 0 ) && ( sun_info . width != extent / sun_info . height ) ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; if ( ( sun_info . type != RT_STANDARD ) && ( sun_info . type != RT_ENCODED ) && ( sun_info . type != RT_FORMAT_RGB ) ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; if ( ( sun_info . maptype == RMT_NONE ) && ( sun_info . maplength != 0 ) ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; if ( ( sun_info . depth == 0 ) || ( sun_info . depth > 32 ) ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; if ( ( sun_info . maptype != RMT_NONE ) && ( sun_info . maptype != RMT_EQUAL_RGB ) && ( sun_info . maptype != RMT_RAW ) ) ThrowReaderException ( CoderError , "ColormapTypeNotSupported" ) ; image -> columns = sun_info . width ; image -> rows = sun_info . height ; image -> depth = sun_info . depth <= 8 ? sun_info . depth : MAGICKCORE_QUANTUM_DEPTH ; if ( sun_info . depth < 24 ) { size_t one ; image -> storage_class = PseudoClass ; image -> colors = sun_info . maplength ; one = 1 ; if ( sun_info . maptype == RMT_NONE ) image -> colors = one << sun_info . depth ; if ( sun_info . maptype == RMT_EQUAL_RGB ) image -> colors = sun_info . maplength / 3 ; } switch ( sun_info . maptype ) { case RMT_NONE : { if ( sun_info . depth < 24 ) { if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; } break ; } case RMT_EQUAL_RGB : { unsigned char * sun_colormap ; if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; sun_colormap = ( unsigned char * ) AcquireQuantumMemory ( image -> colors , sizeof ( * sun_colormap ) ) ; if ( sun_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; count = ReadBlob ( image , image -> colors , sun_colormap ) ; if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , "UnexpectedEndOfFile" ) ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) image -> colormap [ i ] . red = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ; count = ReadBlob ( image , image -> colors , sun_colormap ) ; if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , "UnexpectedEndOfFile" ) ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) image -> colormap [ i ] . green = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ; count = ReadBlob ( image , image -> colors , sun_colormap ) ; if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , "UnexpectedEndOfFile" ) ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) image -> colormap [ i ] . blue = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ; sun_colormap = ( unsigned char * ) RelinquishMagickMemory ( sun_colormap ) ; break ; } case RMT_RAW : { unsigned char * sun_colormap ; sun_colormap = ( unsigned char * ) AcquireQuantumMemory ( sun_info . maplength , sizeof ( * sun_colormap ) ) ; if ( sun_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; count = ReadBlob ( image , sun_info . maplength , sun_colormap ) ; if ( count != ( ssize_t ) sun_info . maplength ) ThrowReaderException ( CorruptImageError , "UnexpectedEndOfFile" ) ; sun_colormap = ( unsigned char * ) RelinquishMagickMemory ( sun_colormap ) ; break ; } default : ThrowReaderException ( CoderError , "ColormapTypeNotSupported" ) ; } image -> alpha_trait = sun_info . depth == 32 ? BlendPixelTrait : UndefinedPixelTrait ; image -> columns = sun_info . width ; image -> rows = sun_info . height ; if ( image_info -> ping != MagickFalse ) { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; if ( ( sun_info . length * sizeof ( * sun_data ) ) / sizeof ( * sun_data ) != sun_info . length || ! sun_info . length ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; number_pixels = ( MagickSizeType ) image -> columns * image -> rows ; if ( ( sun_info . type != RT_ENCODED ) && ( sun_info . depth >= 8 ) && ( ( number_pixels * ( ( sun_info . depth + 7 ) / 8 ) ) > sun_info . length ) ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; <S2SV_StartBug> sun_data = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) sun_info . length , <S2SV_EndBug> <S2SV_StartBug> sizeof ( * sun_data ) ) ; <S2SV_EndBug> if ( sun_data == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; count = ( ssize_t ) ReadBlob ( image , sun_info . length , sun_data ) ; if ( count != ( ssize_t ) sun_info . length ) ThrowReaderException ( CorruptImageError , "UnableToReadImageData" ) ; sun_pixels = sun_data ; bytes_per_line = 0 ; if ( sun_info . type == RT_ENCODED ) { size_t height ; <S2SV_StartBug> height = sun_info . height ; <S2SV_EndBug> bytes_per_line = sun_info . width * sun_info . depth ; if ( ( height == 0 ) || ( sun_info . width == 0 ) || ( sun_info . depth == 0 ) || ( ( bytes_per_line / sun_info . depth ) != sun_info . width ) ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; bytes_per_line += 15 ; bytes_per_line <<= 1 ; if ( ( bytes_per_line >> 1 ) != ( sun_info . width * sun_info . depth + 15 ) ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; bytes_per_line >>= 4 ; sun_pixels = ( unsigned char * ) AcquireQuantumMemory ( height , bytes_per_line * sizeof ( * sun_pixels ) ) ; if ( sun_pixels == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; ( void ) DecodeImage ( sun_data , sun_info . length , sun_pixels , bytes_per_line * height ) ; sun_data = ( unsigned char * ) RelinquishMagickMemory ( sun_data ) ; } p = sun_pixels ; if ( sun_info . depth == 1 ) for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 7 ) ; x += 8 ) { for ( bit = 7 ; bit >= 0 ; bit -- ) { SetPixelIndex ( image , ( Quantum ) ( ( * p ) & ( 0x01 << bit ) ? 0x00 : 0x01 ) , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( ( image -> columns % 8 ) != 0 ) { for ( bit = 7 ; bit >= ( int ) ( 8 - ( image -> columns % 8 ) ) ; bit -- ) { SetPixelIndex ( image , ( Quantum ) ( ( * p ) & ( 0x01 << bit ) ? 0x00 : 0x01 ) , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( ( ( ( image -> columns / 8 ) + ( image -> columns % 8 ? 1 : 0 ) ) % 2 ) != 0 ) p ++ ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } else if ( image -> storage_class == PseudoClass ) { if ( bytes_per_line == 0 ) bytes_per_line = image -> columns ; length = image -> rows * ( image -> columns + image -> columns % 2 ) ; if ( ( ( sun_info . type == RT_ENCODED ) && ( length > ( bytes_per_line * image -> rows ) ) ) || ( ( sun_info . type != RT_ENCODED ) && ( length > sun_info . length ) ) ) ThrowReaderException ( CorruptImageError , "UnableToReadImageData" ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelIndex ( image , * p ++ , q ) ; q += GetPixelChannels ( image ) ; } if ( ( image -> columns % 2 ) != 0 ) p ++ ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else { size_t bytes_per_pixel ; bytes_per_pixel = 3 ; if ( image -> alpha_trait != UndefinedPixelTrait ) bytes_per_pixel ++ ; if ( bytes_per_line == 0 ) bytes_per_line = bytes_per_pixel * image -> columns ; length = image -> rows * ( bytes_per_line + image -> columns % 2 ) ; if ( ( ( sun_info . type == RT_ENCODED ) && ( length > ( bytes_per_line * image -> rows ) ) ) || ( ( sun_info . type != RT_ENCODED ) && ( length > sun_info . length ) ) ) ThrowReaderException ( CorruptImageError , "UnableToReadImageData" ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; if ( sun_info . type == RT_STANDARD ) { SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; } else { SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; } if ( image -> colors != 0 ) { SetPixelRed ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelRed ( image , q ) ] . red ) , q ) ; SetPixelGreen ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelGreen ( image , q ) ] . green ) , q ) ; SetPixelBlue ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelBlue ( image , q ) ] . blue ) , q ) ; } q += GetPixelChannels ( image ) ; } if ( ( ( bytes_per_pixel * image -> columns ) % 2 ) != 0 ) p ++ ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } if ( image -> storage_class == PseudoClass ) ( void ) SyncImage ( image , exception ) ; sun_pixels = ( unsigned char * ) RelinquishMagickMemory ( sun_pixels ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , "UnexpectedEndOfFile" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; sun_info . magic = ReadBlobMSBLong ( image ) ; if ( sun_info . magic == 0x59a66a95 ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( sun_info . magic == 0x59a66a95 ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
static int read_exceptions ( struct pstore * ps , int ( * callback ) ( void * callback_context , chunk_t old , chunk_t new ) , void * callback_context ) { int r , full = 1 ; for ( ps -> current_area = 0 ; full ; ps -> current_area ++ ) { r = area_io ( ps , READ ) ; if ( r ) return r ; r = insert_exceptions ( ps , callback , callback_context , & full ) ; if ( r ) return r ; } ps -> current_area -- ; <S2SV_StartBug> return 0 ; <S2SV_EndBug> }
int main ( int argc , char * * argv ) { int fd = xopen ( "/dev/null" , O_RDWR ) ; while ( fd < 2 ) fd = xdup ( fd ) ; if ( fd > 2 ) close ( fd ) ; if ( argc < 8 ) { error_msg_and_die ( "Usage:<S2SV_blank>%s<S2SV_blank>SIGNO<S2SV_blank>CORE_SIZE_LIMIT<S2SV_blank>PID<S2SV_blank>UID<S2SV_blank>GID<S2SV_blank>TIME<S2SV_blank>BINARY_NAME<S2SV_blank>[HOSTNAME]" , argv [ 0 ] ) ; } if ( strchr ( argv [ 1 ] , '<S2SV_blank>' ) ) { int i ; for ( i = 1 ; argv [ i ] ; i ++ ) { strchrnul ( argv [ i ] , '<S2SV_blank>' ) [ 0 ] = '\\0' ; } } logmode = LOGMODE_JOURNAL ; load_abrt_conf ( ) ; bool setting_MakeCompatCore ; bool setting_SaveBinaryImage ; { map_string_t * settings = new_map_string ( ) ; load_abrt_plugin_conf_file ( "CCpp.conf" , settings ) ; const char * value ; value = get_map_string_item_or_NULL ( settings , "MakeCompatCore" ) ; setting_MakeCompatCore = value && string_to_bool ( value ) ; value = get_map_string_item_or_NULL ( settings , "SaveBinaryImage" ) ; setting_SaveBinaryImage = value && string_to_bool ( value ) ; value = get_map_string_item_or_NULL ( settings , "VerboseLog" ) ; if ( value ) g_verbose = xatoi_positive ( value ) ; free_map_string ( settings ) ; } errno = 0 ; const char * signal_str = argv [ 1 ] ; int signal_no = xatoi_positive ( signal_str ) ; off_t ulimit_c = strtoull ( argv [ 2 ] , NULL , 10 ) ; if ( ulimit_c < 0 ) { ulimit_c = ~ ( ( off_t ) 1 << ( sizeof ( off_t ) * 8 - 1 ) ) ; } const char * pid_str = argv [ 3 ] ; pid_t pid = xatoi_positive ( argv [ 3 ] ) ; uid_t uid = xatoi_positive ( argv [ 4 ] ) ; if ( errno || pid <= 0 ) { perror_msg_and_die ( "PID<S2SV_blank>\'%s\'<S2SV_blank>or<S2SV_blank>limit<S2SV_blank>\'%s\'<S2SV_blank>is<S2SV_blank>bogus" , argv [ 3 ] , argv [ 2 ] ) ; } { char * s = xmalloc_fopen_fgetline_fclose ( VAR_RUN "/abrt/saved_core_pattern" ) ; if ( s && s [ 0 ] != '|' ) core_basename = s ; else free ( s ) ; } struct utsname uts ; if ( ! argv [ 8 ] ) { uname ( & uts ) ; argv [ 8 ] = uts . nodename ; } char path [ PATH_MAX ] ; int src_fd_binary = - 1 ; char * executable = get_executable ( pid , setting_SaveBinaryImage ? & src_fd_binary : NULL ) ; if ( executable && strstr ( executable , "/abrt-hook-ccpp" ) ) { error_msg_and_die ( "PID<S2SV_blank>%lu<S2SV_blank>is<S2SV_blank>\'%s\',<S2SV_blank>not<S2SV_blank>dumping<S2SV_blank>it<S2SV_blank>to<S2SV_blank>avoid<S2SV_blank>recursion" , ( long ) pid , executable ) ; } user_pwd = get_cwd ( pid ) ; log_notice ( "user_pwd:\'%s\'" , user_pwd ) ; sprintf ( path , "/proc/%lu/status" , ( long ) pid ) ; proc_pid_status = xmalloc_xopen_read_close ( path , NULL ) ; uid_t fsuid = uid ; uid_t tmp_fsuid = get_fsuid ( ) ; int suid_policy = dump_suid_policy ( ) ; if ( tmp_fsuid != uid ) { fsuid = 0 ; if ( suid_policy == DUMP_SUID_UNSAFE ) { fsuid = tmp_fsuid ; } } if ( setting_MakeCompatCore && ulimit_c != 0 ) user_core_fd = open_user_core ( uid , fsuid , pid , & argv [ 1 ] ) ; if ( executable == NULL ) { error_msg ( "Can\'t<S2SV_blank>read<S2SV_blank>/proc/%lu/exe<S2SV_blank>link" , ( long ) pid ) ; goto create_user_core ; } const char * signame = NULL ; switch ( signal_no ) { case SIGILL : signame = "ILL" ; break ; case SIGFPE : signame = "FPE" ; break ; case SIGSEGV : signame = "SEGV" ; break ; case SIGBUS : signame = "BUS" ; break ; case SIGABRT : signame = "ABRT" ; break ; case SIGTRAP : signame = "TRAP" ; break ; default : goto create_user_core ; } if ( ! daemon_is_ok ( ) ) { log ( "abrtd<S2SV_blank>is<S2SV_blank>not<S2SV_blank>running.<S2SV_blank>If<S2SV_blank>it<S2SV_blank>crashed,<S2SV_blank>" "/proc/sys/kernel/core_pattern<S2SV_blank>contains<S2SV_blank>a<S2SV_blank>stale<S2SV_blank>value,<S2SV_blank>" "consider<S2SV_blank>resetting<S2SV_blank>it<S2SV_blank>to<S2SV_blank>\'core\'" ) ; goto create_user_core ; } if ( g_settings_nMaxCrashReportsSize > 0 ) { if ( low_free_space ( g_settings_nMaxCrashReportsSize , g_settings_dump_location ) ) goto create_user_core ; } snprintf ( path , sizeof ( path ) , "%s/last-ccpp" , g_settings_dump_location ) ; if ( check_recent_crash_file ( path , executable ) ) { goto create_user_core ; } const char * last_slash = strrchr ( executable , '/' ) ; if ( last_slash && strncmp ( ++ last_slash , "abrt" , 4 ) == 0 ) { snprintf ( path , sizeof ( path ) , "%s/%s-coredump" , g_settings_dump_location , last_slash ) ; int abrt_core_fd = xopen3 ( path , O_WRONLY | O_CREAT | O_TRUNC , 0600 ) ; off_t core_size = copyfd_eof ( STDIN_FILENO , abrt_core_fd , COPYFD_SPARSE ) ; if ( core_size < 0 || fsync ( abrt_core_fd ) != 0 ) { unlink ( path ) ; error_msg_and_die ( "Error<S2SV_blank>saving<S2SV_blank>\'%s\'" , path ) ; } log ( "Saved<S2SV_blank>core<S2SV_blank>dump<S2SV_blank>of<S2SV_blank>pid<S2SV_blank>%lu<S2SV_blank>(%s)<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>(%llu<S2SV_blank>bytes)" , ( long ) pid , executable , path , ( long long ) core_size ) ; return 0 ; } unsigned path_len = snprintf ( path , sizeof ( path ) , "%s/ccpp-%s-%lu.new" , g_settings_dump_location , iso_date_string ( NULL ) , ( long ) pid ) ; if ( path_len >= ( sizeof ( path ) - sizeof ( "/" FILENAME_COREDUMP ) ) ) { goto create_user_core ; } dd = dd_create ( path , fsuid , DEFAULT_DUMP_DIR_MODE ) ; if ( dd ) { char * rootdir = get_rootdir ( pid ) ; dd_create_basic_files ( dd , fsuid , ( rootdir && strcmp ( rootdir , "/" ) != 0 ) ? rootdir : NULL ) ; char source_filename [ sizeof ( "/proc/%lu/somewhat_long_name" ) + sizeof ( long ) * 3 ] ; int source_base_ofs = sprintf ( source_filename , "/proc/%lu/smaps" , ( long ) pid ) ; source_base_ofs -= strlen ( "smaps" ) ; char * dest_filename = concat_path_file ( dd -> dd_dirname , "also_somewhat_longish_name" ) ; char * dest_base = strrchr ( dest_filename , '/' ) + 1 ; strcpy ( source_filename + source_base_ofs , "maps" ) ; strcpy ( dest_base , FILENAME_MAPS ) ; copy_file_ext ( source_filename , dest_filename , 0640 , dd -> dd_uid , dd -> dd_gid , O_RDONLY , O_WRONLY | O_CREAT | O_TRUNC | O_EXCL ) ; strcpy ( source_filename + source_base_ofs , "limits" ) ; strcpy ( dest_base , FILENAME_LIMITS ) ; copy_file_ext ( source_filename , dest_filename , 0640 , dd -> dd_uid , dd -> dd_gid , O_RDONLY , O_WRONLY | O_CREAT | O_TRUNC | O_EXCL ) ; strcpy ( source_filename + source_base_ofs , "cgroup" ) ; strcpy ( dest_base , FILENAME_CGROUP ) ; copy_file_ext ( source_filename , dest_filename , 0640 , dd -> dd_uid , dd -> dd_gid , O_RDONLY , O_WRONLY | O_CREAT | O_TRUNC | O_EXCL ) ; strcpy ( dest_base , FILENAME_OPEN_FDS ) ; dump_fd_info ( dest_filename , source_filename , source_base_ofs , dd -> dd_uid , dd -> dd_gid ) ; free ( dest_filename ) ; dd_save_text ( dd , FILENAME_ANALYZER , "CCpp" ) ; dd_save_text ( dd , FILENAME_TYPE , "CCpp" ) ; dd_save_text ( dd , FILENAME_EXECUTABLE , executable ) ; dd_save_text ( dd , FILENAME_PID , pid_str ) ; dd_save_text ( dd , FILENAME_PROC_PID_STATUS , proc_pid_status ) ; if ( user_pwd ) dd_save_text ( dd , FILENAME_PWD , user_pwd ) ; if ( rootdir ) { if ( strcmp ( rootdir , "/" ) != 0 ) dd_save_text ( dd , FILENAME_ROOTDIR , rootdir ) ; } char * reason = xasprintf ( "%s<S2SV_blank>killed<S2SV_blank>by<S2SV_blank>SIG%s" , last_slash , signame ? signame : signal_str ) ; dd_save_text ( dd , FILENAME_REASON , reason ) ; free ( reason ) ; char * cmdline = get_cmdline ( pid ) ; dd_save_text ( dd , FILENAME_CMDLINE , cmdline ? : "" ) ; free ( cmdline ) ; char * environ = get_environ ( pid ) ; dd_save_text ( dd , FILENAME_ENVIRON , environ ? : "" ) ; free ( environ ) ; char * fips_enabled = xmalloc_fopen_fgetline_fclose ( "/proc/sys/crypto/fips_enabled" ) ; if ( fips_enabled ) { if ( strcmp ( fips_enabled , "0" ) != 0 ) dd_save_text ( dd , "fips_enabled" , fips_enabled ) ; free ( fips_enabled ) ; } dd_save_text ( dd , FILENAME_ABRT_VERSION , VERSION ) ; if ( src_fd_binary > 0 ) { strcpy ( path + path_len , "/" FILENAME_BINARY ) ; int dst_fd = create_or_die ( path ) ; off_t sz = copyfd_eof ( src_fd_binary , dst_fd , COPYFD_SPARSE ) ; if ( fsync ( dst_fd ) != 0 || close ( dst_fd ) != 0 || sz < 0 ) { dd_delete ( dd ) ; error_msg_and_die ( "Error<S2SV_blank>saving<S2SV_blank>\'%s\'" , path ) ; } close ( src_fd_binary ) ; } strcpy ( path + path_len , "/" FILENAME_COREDUMP ) ; int abrt_core_fd = create_or_die ( path ) ; off_t core_size = copyfd_sparse ( STDIN_FILENO , abrt_core_fd , user_core_fd , ulimit_c ) ; if ( fsync ( abrt_core_fd ) != 0 || close ( abrt_core_fd ) != 0 || core_size < 0 ) { unlink ( path ) ; dd_delete ( dd ) ; if ( user_core_fd >= 0 ) { xchdir ( user_pwd ) ; unlink ( core_basename ) ; } error_msg_and_die ( "Error<S2SV_blank>writing<S2SV_blank>\'%s\'" , path ) ; } if ( user_core_fd >= 0 && ( fsync ( user_core_fd ) != 0 || close ( user_core_fd ) != 0 || ( ulimit_c == 0 || core_size > ulimit_c ) ) ) { xchdir ( user_pwd ) ; unlink ( core_basename ) ; } <S2SV_StartBug> { <S2SV_EndBug> char * java_log = xasprintf ( "/tmp/jvm-%lu/hs_error.log" , ( long ) pid ) ; int src_fd = open ( java_log , O_RDONLY ) ; free ( java_log ) ; if ( src_fd < 0 ) { java_log = xasprintf ( "%s/hs_err_pid%lu.log" , user_pwd , ( long ) pid ) ; src_fd = open ( java_log , O_RDONLY ) ; free ( java_log ) ; } if ( src_fd >= 0 ) { strcpy ( path + path_len , "/hs_err.log" ) ; int dst_fd = create_or_die ( path ) ; off_t sz = copyfd_eof ( src_fd , dst_fd , COPYFD_SPARSE ) ; if ( close ( dst_fd ) != 0 || sz < 0 ) { dd_delete ( dd ) ; error_msg_and_die ( "Error<S2SV_blank>saving<S2SV_blank>\'%s\'" , path ) ; } close ( src_fd ) ; } <S2SV_StartBug> } <S2SV_EndBug> dd_close ( dd ) ; path [ path_len ] = '\\0' ; char * newpath = xstrndup ( path , path_len - ( sizeof ( ".new" ) - 1 ) ) ; if ( rename ( path , newpath ) == 0 ) strcpy ( path , newpath ) ; free ( newpath ) ; log ( "Saved<S2SV_blank>core<S2SV_blank>dump<S2SV_blank>of<S2SV_blank>pid<S2SV_blank>%lu<S2SV_blank>(%s)<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>(%llu<S2SV_blank>bytes)" , ( long ) pid , executable , path , ( long long ) core_size ) ; notify_new_path ( path ) ; if ( g_settings_nMaxCrashReportsSize > 0 ) { unsigned maxsize = g_settings_nMaxCrashReportsSize + g_settings_nMaxCrashReportsSize / 4 ; maxsize |= 63 ; trim_problem_dirs ( g_settings_dump_location , maxsize * ( double ) ( 1024 * 1024 ) , path ) ; } free ( rootdir ) ; return 0 ; } create_user_core : if ( user_core_fd >= 0 ) { off_t core_size = copyfd_size ( STDIN_FILENO , user_core_fd , ulimit_c , COPYFD_SPARSE ) ; if ( fsync ( user_core_fd ) != 0 || close ( user_core_fd ) != 0 || core_size < 0 ) { perror_msg ( "Error<S2SV_blank>writing<S2SV_blank>\'%s\'" , full_core_basename ) ; xchdir ( user_pwd ) ; unlink ( core_basename ) ; return 1 ; } if ( ulimit_c == 0 || core_size > ulimit_c ) { xchdir ( user_pwd ) ; unlink ( core_basename ) ; return 1 ; } log ( "Saved<S2SV_blank>core<S2SV_blank>dump<S2SV_blank>of<S2SV_blank>pid<S2SV_blank>%lu<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>(%llu<S2SV_blank>bytes)" , ( long ) pid , full_core_basename , ( long long ) core_size ) ; } return 0 ; }
static int vsock_stream_recvmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { struct sock * sk ; struct vsock_sock * vsk ; int err ; size_t target ; ssize_t copied ; long timeout ; struct vsock_transport_recv_notify_data recv_data ; DEFINE_WAIT ( wait ) ; sk = sock -> sk ; vsk = vsock_sk ( sk ) ; err = 0 ; <S2SV_StartBug> msg -> msg_namelen = 0 ; <S2SV_EndBug> lock_sock ( sk ) ; if ( sk -> sk_state != SS_CONNECTED ) { if ( sock_flag ( sk , SOCK_DONE ) ) err = 0 ; else err = - ENOTCONN ; goto out ; } if ( flags & MSG_OOB ) { err = - EOPNOTSUPP ; goto out ; } if ( sk -> sk_shutdown & RCV_SHUTDOWN ) { err = 0 ; goto out ; } if ( ! len ) { err = 0 ; goto out ; } target = sock_rcvlowat ( sk , flags & MSG_WAITALL , len ) ; if ( target >= transport -> stream_rcvhiwat ( vsk ) ) { err = - ENOMEM ; goto out ; } timeout = sock_rcvtimeo ( sk , flags & MSG_DONTWAIT ) ; copied = 0 ; err = transport -> notify_recv_init ( vsk , target , & recv_data ) ; if ( err < 0 ) goto out ; prepare_to_wait ( sk_sleep ( sk ) , & wait , TASK_INTERRUPTIBLE ) ; while ( 1 ) { s64 ready = vsock_stream_has_data ( vsk ) ; if ( ready < 0 ) { err = - ENOMEM ; goto out_wait ; } else if ( ready > 0 ) { ssize_t read ; err = transport -> notify_recv_pre_dequeue ( vsk , target , & recv_data ) ; if ( err < 0 ) break ; read = transport -> stream_dequeue ( vsk , msg -> msg_iov , len - copied , flags ) ; if ( read < 0 ) { err = - ENOMEM ; break ; } copied += read ; err = transport -> notify_recv_post_dequeue ( vsk , target , read , ! ( flags & MSG_PEEK ) , & recv_data ) ; if ( err < 0 ) goto out_wait ; if ( read >= target || flags & MSG_PEEK ) break ; target -= read ; } else { if ( sk -> sk_err != 0 || ( sk -> sk_shutdown & RCV_SHUTDOWN ) || ( vsk -> peer_shutdown & SEND_SHUTDOWN ) ) { break ; } if ( timeout == 0 ) { err = - EAGAIN ; break ; } err = transport -> notify_recv_pre_block ( vsk , target , & recv_data ) ; if ( err < 0 ) break ; release_sock ( sk ) ; timeout = schedule_timeout ( timeout ) ; lock_sock ( sk ) ; if ( signal_pending ( current ) ) { err = sock_intr_errno ( timeout ) ; break ; } else if ( timeout == 0 ) { err = - EAGAIN ; break ; } prepare_to_wait ( sk_sleep ( sk ) , & wait , TASK_INTERRUPTIBLE ) ; } } if ( sk -> sk_err ) err = - sk -> sk_err ; else if ( sk -> sk_shutdown & RCV_SHUTDOWN ) err = 0 ; if ( copied > 0 ) { if ( ! ( flags & MSG_PEEK ) ) { if ( vsk -> peer_shutdown & SEND_SHUTDOWN ) { if ( vsock_stream_has_data ( vsk ) <= 0 ) { sk -> sk_state = SS_UNCONNECTED ; sock_set_flag ( sk , SOCK_DONE ) ; sk -> sk_state_change ( sk ) ; } } } err = copied ; } out_wait : finish_wait ( sk_sleep ( sk ) , & wait ) ; out : release_sock ( sk ) ; return err ; }
static ssize_t bat_socket_read ( struct file * file , char __user * buf , size_t count , loff_t * ppos ) { struct socket_client * socket_client = file -> private_data ; struct socket_packet * socket_packet ; size_t packet_len ; int error ; if ( ( file -> f_flags & O_NONBLOCK ) && ( socket_client -> queue_len == 0 ) ) return - EAGAIN ; if ( ( ! buf ) || ( count < sizeof ( struct icmp_packet ) ) ) return - EINVAL ; if ( ! access_ok ( VERIFY_WRITE , buf , count ) ) return - EFAULT ; error = wait_event_interruptible ( socket_client -> queue_wait , socket_client -> queue_len ) ; if ( error ) return error ; spin_lock_bh ( & socket_client -> lock ) ; socket_packet = list_first_entry ( & socket_client -> queue_list , struct socket_packet , list ) ; list_del ( & socket_packet -> list ) ; socket_client -> queue_len -- ; spin_unlock_bh ( & socket_client -> lock ) ; <S2SV_StartBug> error = copy_to_user ( buf , & socket_packet -> icmp_packet , <S2SV_EndBug> <S2SV_StartBug> socket_packet -> icmp_len ) ; <S2SV_EndBug> packet_len = socket_packet -> icmp_len ; kfree ( socket_packet ) ; if ( error ) return - EFAULT ; return packet_len ; }
static inline int xfrm_replay_verify_len ( struct xfrm_replay_state_esn * replay_esn , struct nlattr * rp ) { struct xfrm_replay_state_esn * up ; int ulen ; if ( ! replay_esn || ! rp ) return 0 ; up = nla_data ( rp ) ; ulen = xfrm_replay_state_esn_len ( up ) ; if ( nla_len ( rp ) < ulen || xfrm_replay_state_esn_len ( replay_esn ) != ulen ) return - EINVAL ; <S2SV_StartBug> return 0 ; <S2SV_EndBug> }
int ParseCaffHeaderConfig ( FILE * infile , char * infilename , char * fourcc , WavpackContext * wpc , WavpackConfig * config ) { <S2SV_StartBug> uint32_t chan_chunk = 0 , channel_layout = 0 , bcount ; <S2SV_EndBug> unsigned char * channel_identities = NULL ; unsigned char * channel_reorder = NULL ; int64_t total_samples = 0 , infilesize ; CAFFileHeader caf_file_header ; CAFChunkHeader caf_chunk_header ; CAFAudioFormat caf_audio_format ; int i ; infilesize = DoGetFileSize ( infile ) ; memcpy ( & caf_file_header , fourcc , 4 ) ; if ( ( ! DoReadFile ( infile , ( ( char * ) & caf_file_header ) + 4 , sizeof ( CAFFileHeader ) - 4 , & bcount ) || bcount != sizeof ( CAFFileHeader ) - 4 ) ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.CAF<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & caf_file_header , sizeof ( CAFFileHeader ) ) ) { error_line ( "%s" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackBigEndianToNative ( & caf_file_header , CAFFileHeaderFormat ) ; if ( caf_file_header . mFileVersion != 1 ) { error_line ( "%s:<S2SV_blank>can\'t<S2SV_blank>handle<S2SV_blank>version<S2SV_blank>%d<S2SV_blank>.CAF<S2SV_blank>files!" , infilename , caf_file_header . mFileVersion ) ; return WAVPACK_SOFT_ERROR ; } while ( 1 ) { if ( ! DoReadFile ( infile , & caf_chunk_header , sizeof ( CAFChunkHeader ) , & bcount ) || bcount != sizeof ( CAFChunkHeader ) ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.CAF<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & caf_chunk_header , sizeof ( CAFChunkHeader ) ) ) { error_line ( "%s" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } WavpackBigEndianToNative ( & caf_chunk_header , CAFChunkHeaderFormat ) ; if ( ! strncmp ( caf_chunk_header . mChunkType , "desc" , 4 ) ) { int supported = TRUE ; if ( caf_chunk_header . mChunkSize != sizeof ( CAFAudioFormat ) || ! DoReadFile ( infile , & caf_audio_format , ( uint32_t ) caf_chunk_header . mChunkSize , & bcount ) || bcount != caf_chunk_header . mChunkSize ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.CAF<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & caf_audio_format , ( uint32_t ) caf_chunk_header . mChunkSize ) ) { error_line ( "%s" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } <S2SV_StartBug> WavpackBigEndianToNative ( & caf_audio_format , CAFAudioFormatFormat ) ; <S2SV_EndBug> if ( debug_logging_mode ) { char formatstr [ 5 ] ; memcpy ( formatstr , caf_audio_format . mFormatID , 4 ) ; formatstr [ 4 ] = 0 ; error_line ( "format<S2SV_blank>=<S2SV_blank>%s,<S2SV_blank>flags<S2SV_blank>=<S2SV_blank>%x,<S2SV_blank>sampling<S2SV_blank>rate<S2SV_blank>=<S2SV_blank>%g" , formatstr , caf_audio_format . mFormatFlags , caf_audio_format . mSampleRate ) ; error_line ( "packet<S2SV_blank>=<S2SV_blank>%d<S2SV_blank>bytes<S2SV_blank>and<S2SV_blank>%d<S2SV_blank>frames" , caf_audio_format . mBytesPerPacket , caf_audio_format . mFramesPerPacket ) ; error_line ( "channels<S2SV_blank>per<S2SV_blank>frame<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>bits<S2SV_blank>per<S2SV_blank>channel<S2SV_blank>=<S2SV_blank>%d" , caf_audio_format . mChannelsPerFrame , caf_audio_format . mBitsPerChannel ) ; } if ( strncmp ( caf_audio_format . mFormatID , "lpcm" , 4 ) || ( caf_audio_format . mFormatFlags & ~ 3 ) ) supported = FALSE ; else if ( caf_audio_format . mSampleRate < 1.0 || caf_audio_format . mSampleRate > 16777215.0 || caf_audio_format . mSampleRate != floor ( caf_audio_format . mSampleRate ) ) supported = FALSE ; else if ( ! caf_audio_format . mChannelsPerFrame || caf_audio_format . mChannelsPerFrame > 256 ) supported = FALSE ; else if ( caf_audio_format . mBitsPerChannel < 1 || caf_audio_format . mBitsPerChannel > 32 || ( ( caf_audio_format . mFormatFlags & CAF_FORMAT_FLOAT ) && caf_audio_format . mBitsPerChannel != 32 ) ) supported = FALSE ; else if ( caf_audio_format . mFramesPerPacket != 1 || caf_audio_format . mBytesPerPacket / caf_audio_format . mChannelsPerFrame < ( caf_audio_format . mBitsPerChannel + 7 ) / 8 || caf_audio_format . mBytesPerPacket / caf_audio_format . mChannelsPerFrame > 4 || caf_audio_format . mBytesPerPacket % caf_audio_format . mChannelsPerFrame ) supported = FALSE ; if ( ! supported ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>an<S2SV_blank>unsupported<S2SV_blank>.CAF<S2SV_blank>format!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } config -> bytes_per_sample = caf_audio_format . mBytesPerPacket / caf_audio_format . mChannelsPerFrame ; config -> float_norm_exp = ( caf_audio_format . mFormatFlags & CAF_FORMAT_FLOAT ) ? 127 : 0 ; config -> bits_per_sample = caf_audio_format . mBitsPerChannel ; config -> num_channels = caf_audio_format . mChannelsPerFrame ; config -> sample_rate = ( int ) caf_audio_format . mSampleRate ; if ( ! ( caf_audio_format . mFormatFlags & CAF_FORMAT_LITTLE_ENDIAN ) && config -> bytes_per_sample > 1 ) config -> qmode |= QMODE_BIG_ENDIAN ; if ( config -> bytes_per_sample == 1 ) config -> qmode |= QMODE_SIGNED_BYTES ; if ( debug_logging_mode ) { if ( config -> float_norm_exp == 127 ) error_line ( "data<S2SV_blank>format:<S2SV_blank>32-bit<S2SV_blank>%s-endian<S2SV_blank>floating<S2SV_blank>point" , ( config -> qmode & QMODE_BIG_ENDIAN ) ? "big" : "little" ) ; else error_line ( "data<S2SV_blank>format:<S2SV_blank>%d-bit<S2SV_blank>%s-endian<S2SV_blank>integers<S2SV_blank>stored<S2SV_blank>in<S2SV_blank>%d<S2SV_blank>byte(s)" , config -> bits_per_sample , ( config -> qmode & QMODE_BIG_ENDIAN ) ? "big" : "little" , config -> bytes_per_sample ) ; } } else if ( ! strncmp ( caf_chunk_header . mChunkType , "chan" , 4 ) ) { CAFChannelLayout * caf_channel_layout ; if ( caf_chunk_header . mChunkSize < 0 || caf_chunk_header . mChunkSize > 1024 || caf_chunk_header . mChunkSize < sizeof ( CAFChannelLayout ) ) { error_line ( "this<S2SV_blank>.CAF<S2SV_blank>file<S2SV_blank>has<S2SV_blank>an<S2SV_blank>invalid<S2SV_blank>\'chan\'<S2SV_blank>chunk!" ) ; return WAVPACK_SOFT_ERROR ; } if ( debug_logging_mode ) error_line ( "\'chan\'<S2SV_blank>chunk<S2SV_blank>is<S2SV_blank>%d<S2SV_blank>bytes" , ( int ) caf_chunk_header . mChunkSize ) ; caf_channel_layout = malloc ( ( size_t ) caf_chunk_header . mChunkSize ) ; if ( ! DoReadFile ( infile , caf_channel_layout , ( uint32_t ) caf_chunk_header . mChunkSize , & bcount ) || bcount != caf_chunk_header . mChunkSize ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.CAF<S2SV_blank>file!" , infilename ) ; free ( caf_channel_layout ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , caf_channel_layout , ( uint32_t ) caf_chunk_header . mChunkSize ) ) { error_line ( "%s" , WavpackGetErrorMessage ( wpc ) ) ; free ( caf_channel_layout ) ; return WAVPACK_SOFT_ERROR ; } WavpackBigEndianToNative ( caf_channel_layout , CAFChannelLayoutFormat ) ; chan_chunk = 1 ; if ( config -> channel_mask || ( config -> qmode & QMODE_CHANS_UNASSIGNED ) ) { error_line ( "this<S2SV_blank>CAF<S2SV_blank>file<S2SV_blank>already<S2SV_blank>has<S2SV_blank>channel<S2SV_blank>order<S2SV_blank>information!" ) ; free ( caf_channel_layout ) ; return WAVPACK_SOFT_ERROR ; } switch ( caf_channel_layout -> mChannelLayoutTag ) { case kCAFChannelLayoutTag_UseChannelDescriptions : { CAFChannelDescription * descriptions = ( CAFChannelDescription * ) ( caf_channel_layout + 1 ) ; int num_descriptions = caf_channel_layout -> mNumberChannelDescriptions ; int label , cindex = 0 , idents = 0 ; if ( caf_chunk_header . mChunkSize != sizeof ( CAFChannelLayout ) + sizeof ( CAFChannelDescription ) * num_descriptions || num_descriptions != config -> num_channels ) { error_line ( "channel<S2SV_blank>descriptions<S2SV_blank>in<S2SV_blank>\'chan\'<S2SV_blank>chunk<S2SV_blank>are<S2SV_blank>the<S2SV_blank>wrong<S2SV_blank>size!" ) ; free ( caf_channel_layout ) ; return WAVPACK_SOFT_ERROR ; } if ( num_descriptions >= 256 ) { error_line ( "%d<S2SV_blank>channel<S2SV_blank>descriptions<S2SV_blank>is<S2SV_blank>more<S2SV_blank>than<S2SV_blank>we<S2SV_blank>can<S2SV_blank>handle...ignoring!" ) ; break ; } channel_reorder = malloc ( num_descriptions ) ; memset ( channel_reorder , - 1 , num_descriptions ) ; channel_identities = malloc ( num_descriptions + 1 ) ; for ( i = 0 ; i < num_descriptions ; ++ i ) { WavpackBigEndianToNative ( descriptions + i , CAFChannelDescriptionFormat ) ; if ( debug_logging_mode ) error_line ( "chan<S2SV_blank>%d<S2SV_blank>--><S2SV_blank>%d" , i + 1 , descriptions [ i ] . mChannelLabel ) ; } for ( label = 1 ; label <= 18 ; ++ label ) for ( i = 0 ; i < num_descriptions ; ++ i ) if ( descriptions [ i ] . mChannelLabel == label ) { config -> channel_mask |= 1 << ( label - 1 ) ; channel_reorder [ i ] = cindex ++ ; break ; } for ( i = 0 ; i < num_descriptions ; ++ i ) if ( channel_reorder [ i ] == ( unsigned char ) - 1 ) { uint32_t clabel = descriptions [ i ] . mChannelLabel ; if ( clabel == 0 || clabel == 0xffffffff || clabel == 100 ) channel_identities [ idents ++ ] = 0xff ; else if ( ( clabel >= 33 && clabel <= 44 ) || ( clabel >= 200 && clabel <= 207 ) || ( clabel >= 301 && clabel <= 305 ) ) channel_identities [ idents ++ ] = clabel >= 301 ? clabel - 80 : clabel ; else { error_line ( "warning:<S2SV_blank>unknown<S2SV_blank>channel<S2SV_blank>descriptions<S2SV_blank>label:<S2SV_blank>%d" , clabel ) ; channel_identities [ idents ++ ] = 0xff ; } channel_reorder [ i ] = cindex ++ ; } for ( i = 0 ; i < num_descriptions ; ++ i ) if ( channel_reorder [ i ] != i ) break ; if ( i == num_descriptions ) { free ( channel_reorder ) ; channel_reorder = NULL ; } else { config -> qmode |= QMODE_REORDERED_CHANS ; channel_layout = num_descriptions ; } if ( ! idents ) { free ( channel_identities ) ; channel_identities = NULL ; } else channel_identities [ idents ] = 0 ; if ( debug_logging_mode ) { error_line ( "layout_tag<S2SV_blank>=<S2SV_blank>0x%08x,<S2SV_blank>so<S2SV_blank>generated<S2SV_blank>bitmap<S2SV_blank>of<S2SV_blank>0x%08x<S2SV_blank>from<S2SV_blank>%d<S2SV_blank>descriptions,<S2SV_blank>%d<S2SV_blank>non-MS" , caf_channel_layout -> mChannelLayoutTag , config -> channel_mask , caf_channel_layout -> mNumberChannelDescriptions , idents ) ; if ( channel_reorder && num_descriptions <= 8 ) { char reorder_string [ ] = "12345678" ; for ( i = 0 ; i < num_descriptions ; ++ i ) reorder_string [ i ] = channel_reorder [ i ] + '1' ; reorder_string [ i ] = 0 ; error_line ( "reordering<S2SV_blank>string<S2SV_blank>=<S2SV_blank>\\"%s\\"\\n" , reorder_string ) ; } } } break ; case kCAFChannelLayoutTag_UseChannelBitmap : config -> channel_mask = caf_channel_layout -> mChannelBitmap ; if ( debug_logging_mode ) error_line ( "layout_tag<S2SV_blank>=<S2SV_blank>0x%08x,<S2SV_blank>so<S2SV_blank>using<S2SV_blank>supplied<S2SV_blank>bitmap<S2SV_blank>of<S2SV_blank>0x%08x" , caf_channel_layout -> mChannelLayoutTag , caf_channel_layout -> mChannelBitmap ) ; break ; default : for ( i = 0 ; i < NUM_LAYOUTS ; ++ i ) if ( caf_channel_layout -> mChannelLayoutTag == layouts [ i ] . mChannelLayoutTag ) { config -> channel_mask = layouts [ i ] . mChannelBitmap ; channel_layout = layouts [ i ] . mChannelLayoutTag ; if ( layouts [ i ] . mChannelReorder ) { channel_reorder = ( unsigned char * ) strdup ( layouts [ i ] . mChannelReorder ) ; config -> qmode |= QMODE_REORDERED_CHANS ; } if ( layouts [ i ] . mChannelIdentities ) channel_identities = ( unsigned char * ) strdup ( layouts [ i ] . mChannelIdentities ) ; if ( debug_logging_mode ) error_line ( "layout_tag<S2SV_blank>0x%08x<S2SV_blank>found<S2SV_blank>in<S2SV_blank>table,<S2SV_blank>bitmap<S2SV_blank>=<S2SV_blank>0x%08x,<S2SV_blank>reorder<S2SV_blank>=<S2SV_blank>%s,<S2SV_blank>identities<S2SV_blank>=<S2SV_blank>%s" , channel_layout , config -> channel_mask , channel_reorder ? "yes" : "no" , channel_identities ? "yes" : "no" ) ; break ; } if ( i == NUM_LAYOUTS && debug_logging_mode ) error_line ( "layout_tag<S2SV_blank>0x%08x<S2SV_blank>not<S2SV_blank>found<S2SV_blank>in<S2SV_blank>table...all<S2SV_blank>channels<S2SV_blank>unassigned" , caf_channel_layout -> mChannelLayoutTag ) ; break ; } free ( caf_channel_layout ) ; } else if ( ! strncmp ( caf_chunk_header . mChunkType , "data" , 4 ) ) { uint32_t mEditCount ; <S2SV_StartBug> if ( ! DoReadFile ( infile , & mEditCount , sizeof ( mEditCount ) , & bcount ) || <S2SV_EndBug> bcount != sizeof ( mEditCount ) ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.CAF<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & mEditCount , sizeof ( mEditCount ) ) ) { error_line ( "%s" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } if ( ( config -> qmode & QMODE_IGNORE_LENGTH ) || caf_chunk_header . mChunkSize == - 1 ) { config -> qmode |= QMODE_IGNORE_LENGTH ; if ( infilesize && DoGetFilePosition ( infile ) != - 1 ) total_samples = ( infilesize - DoGetFilePosition ( infile ) ) / caf_audio_format . mBytesPerPacket ; else total_samples = - 1 ; } else { if ( infilesize && infilesize - caf_chunk_header . mChunkSize > 16777216 ) { error_line ( ".CAF<S2SV_blank>file<S2SV_blank>%s<S2SV_blank>has<S2SV_blank>over<S2SV_blank>16<S2SV_blank>MB<S2SV_blank>of<S2SV_blank>extra<S2SV_blank>CAFF<S2SV_blank>data,<S2SV_blank>probably<S2SV_blank>is<S2SV_blank>corrupt!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( ( caf_chunk_header . mChunkSize - 4 ) % caf_audio_format . mBytesPerPacket ) { error_line ( ".CAF<S2SV_blank>file<S2SV_blank>%s<S2SV_blank>has<S2SV_blank>an<S2SV_blank>invalid<S2SV_blank>data<S2SV_blank>chunk<S2SV_blank>size,<S2SV_blank>probably<S2SV_blank>is<S2SV_blank>corrupt!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } total_samples = ( caf_chunk_header . mChunkSize - 4 ) / caf_audio_format . mBytesPerPacket ; if ( ! total_samples ) { error_line ( "this<S2SV_blank>.CAF<S2SV_blank>file<S2SV_blank>has<S2SV_blank>no<S2SV_blank>audio<S2SV_blank>samples,<S2SV_blank>probably<S2SV_blank>is<S2SV_blank>corrupt!" ) ; return WAVPACK_SOFT_ERROR ; } if ( total_samples > MAX_WAVPACK_SAMPLES ) { error_line ( "%s<S2SV_blank>has<S2SV_blank>too<S2SV_blank>many<S2SV_blank>samples<S2SV_blank>for<S2SV_blank>WavPack!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } } break ; } else { uint32_t bytes_to_copy = ( uint32_t ) caf_chunk_header . mChunkSize ; char * buff ; if ( caf_chunk_header . mChunkSize < 0 || caf_chunk_header . mChunkSize > 1048576 ) { error_line ( "%s<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>.CAF<S2SV_blank>file!" , infilename ) ; return WAVPACK_SOFT_ERROR ; } buff = malloc ( bytes_to_copy ) ; if ( debug_logging_mode ) error_line ( "extra<S2SV_blank>unknown<S2SV_blank>chunk<S2SV_blank>\\"%c%c%c%c\\"<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes" , caf_chunk_header . mChunkType [ 0 ] , caf_chunk_header . mChunkType [ 1 ] , caf_chunk_header . mChunkType [ 2 ] , caf_chunk_header . mChunkType [ 3 ] , caf_chunk_header . mChunkSize ) ; if ( ! DoReadFile ( infile , buff , bytes_to_copy , & bcount ) || bcount != bytes_to_copy || ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , buff , bytes_to_copy ) ) ) { error_line ( "%s" , WavpackGetErrorMessage ( wpc ) ) ; free ( buff ) ; return WAVPACK_SOFT_ERROR ; } free ( buff ) ; } } if ( ! chan_chunk && ! config -> channel_mask && config -> num_channels <= 2 && ! ( config -> qmode & QMODE_CHANS_UNASSIGNED ) ) config -> channel_mask = 0x5 - config -> num_channels ; if ( ! WavpackSetConfiguration64 ( wpc , config , total_samples , channel_identities ) ) { error_line ( "%s" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } if ( channel_identities ) free ( channel_identities ) ; if ( channel_layout || channel_reorder ) { if ( ! WavpackSetChannelLayout ( wpc , channel_layout , channel_reorder ) ) { error_line ( "problem<S2SV_blank>with<S2SV_blank>setting<S2SV_blank>channel<S2SV_blank>layout<S2SV_blank>(should<S2SV_blank>not<S2SV_blank>happen)" ) ; return WAVPACK_SOFT_ERROR ; } if ( channel_reorder ) free ( channel_reorder ) ; } return WAVPACK_NO_ERROR ; }
static int __f2fs_set_acl ( struct inode * inode , int type , struct posix_acl * acl , struct page * ipage ) { int name_index ; void * value = NULL ; size_t size = 0 ; int error ; switch ( type ) { case ACL_TYPE_ACCESS : name_index = F2FS_XATTR_INDEX_POSIX_ACL_ACCESS ; if ( acl ) { <S2SV_StartBug> error = posix_acl_equiv_mode ( acl , & inode -> i_mode ) ; <S2SV_EndBug> if ( error < 0 ) return error ; <S2SV_StartBug> set_acl_inode ( inode , inode -> i_mode ) ; <S2SV_EndBug> if ( error == 0 ) acl = NULL ; } break ; case ACL_TYPE_DEFAULT : name_index = F2FS_XATTR_INDEX_POSIX_ACL_DEFAULT ; if ( ! S_ISDIR ( inode -> i_mode ) ) return acl ? - EACCES : 0 ; break ; default : return - EINVAL ; } if ( acl ) { value = f2fs_acl_to_disk ( acl , & size ) ; if ( IS_ERR ( value ) ) { clear_inode_flag ( inode , FI_ACL_MODE ) ; return ( int ) PTR_ERR ( value ) ; } } error = f2fs_setxattr ( inode , name_index , "" , value , size , ipage , 0 ) ; kfree ( value ) ; if ( ! error ) set_cached_acl ( inode , type , acl ) ; clear_inode_flag ( inode , FI_ACL_MODE ) ; return error ; }
int bzrtp_packetParser ( bzrtpContext_t * zrtpContext , bzrtpChannelContext_t * zrtpChannelContext , const uint8_t * input , uint16_t inputLength , bzrtpPacket_t * zrtpPacket ) { int i ; uint8_t * messageContent = ( uint8_t * ) ( input + ZRTP_PACKET_HEADER_LENGTH + ZRTP_MESSAGE_HEADER_LENGTH ) ; switch ( zrtpPacket -> messageType ) { case MSGTYPE_HELLO : { bzrtpHelloMessage_t * messageData ; messageData = ( bzrtpHelloMessage_t * ) malloc ( sizeof ( bzrtpHelloMessage_t ) ) ; memcpy ( messageData -> version , messageContent , 4 ) ; messageContent += 4 ; memcpy ( messageData -> clientIdentifier , messageContent , 16 ) ; messageContent += 16 ; memcpy ( messageData -> H3 , messageContent , 32 ) ; messageContent += 32 ; memcpy ( messageData -> ZID , messageContent , 12 ) ; messageContent += 12 ; messageData -> S = ( ( * messageContent ) >> 6 ) & 0x01 ; messageData -> M = ( ( * messageContent ) >> 5 ) & 0x01 ; messageData -> P = ( ( * messageContent ) >> 4 ) & 0x01 ; messageContent += 1 ; messageData -> hc = MIN ( ( * messageContent ) & 0x0F , 7 ) ; messageContent += 1 ; messageData -> cc = MIN ( ( ( * messageContent ) >> 4 ) & 0x0F , 7 ) ; messageData -> ac = MIN ( ( * messageContent ) & 0x0F , 7 ) ; messageContent += 1 ; messageData -> kc = MIN ( ( ( * messageContent ) >> 4 ) & 0x0F , 7 ) ; messageData -> sc = MIN ( ( * messageContent ) & 0x0F , 7 ) ; messageContent += 1 ; if ( zrtpPacket -> messageLength != ZRTP_HELLOMESSAGE_FIXED_LENGTH + 4 * ( ( uint16_t ) ( messageData -> hc ) + ( uint16_t ) ( messageData -> cc ) + ( uint16_t ) ( messageData -> ac ) + ( uint16_t ) ( messageData -> kc ) + ( uint16_t ) ( messageData -> sc ) ) ) { free ( messageData ) ; return BZRTP_PARSER_ERROR_INVALIDMESSAGE ; } for ( i = 0 ; i < messageData -> hc ; i ++ ) { messageData -> supportedHash [ i ] = cryptoAlgoTypeStringToInt ( messageContent , ZRTP_HASH_TYPE ) ; messageContent += 4 ; } for ( i = 0 ; i < messageData -> cc ; i ++ ) { messageData -> supportedCipher [ i ] = cryptoAlgoTypeStringToInt ( messageContent , ZRTP_CIPHERBLOCK_TYPE ) ; messageContent += 4 ; } for ( i = 0 ; i < messageData -> ac ; i ++ ) { messageData -> supportedAuthTag [ i ] = cryptoAlgoTypeStringToInt ( messageContent , ZRTP_AUTHTAG_TYPE ) ; messageContent += 4 ; } for ( i = 0 ; i < messageData -> kc ; i ++ ) { messageData -> supportedKeyAgreement [ i ] = cryptoAlgoTypeStringToInt ( messageContent , ZRTP_KEYAGREEMENT_TYPE ) ; messageContent += 4 ; } for ( i = 0 ; i < messageData -> sc ; i ++ ) { messageData -> supportedSas [ i ] = cryptoAlgoTypeStringToInt ( messageContent , ZRTP_SAS_TYPE ) ; messageContent += 4 ; } addMandatoryCryptoTypesIfNeeded ( ZRTP_HASH_TYPE , messageData -> supportedHash , & messageData -> hc ) ; addMandatoryCryptoTypesIfNeeded ( ZRTP_CIPHERBLOCK_TYPE , messageData -> supportedCipher , & messageData -> cc ) ; addMandatoryCryptoTypesIfNeeded ( ZRTP_AUTHTAG_TYPE , messageData -> supportedAuthTag , & messageData -> ac ) ; addMandatoryCryptoTypesIfNeeded ( ZRTP_KEYAGREEMENT_TYPE , messageData -> supportedKeyAgreement , & messageData -> kc ) ; addMandatoryCryptoTypesIfNeeded ( ZRTP_SAS_TYPE , messageData -> supportedSas , & messageData -> sc ) ; memcpy ( messageData -> MAC , messageContent , 8 ) ; zrtpPacket -> messageData = ( void * ) messageData ; zrtpPacket -> packetString = ( uint8_t * ) malloc ( inputLength * sizeof ( uint8_t ) ) ; memcpy ( zrtpPacket -> packetString , input , inputLength ) ; } break ; case MSGTYPE_HELLOACK : { if ( zrtpPacket -> messageLength != ZRTP_HELLOACKMESSAGE_FIXED_LENGTH ) { return BZRTP_PARSER_ERROR_INVALIDMESSAGE ; } } break ; case MSGTYPE_COMMIT : { uint8_t checkH3 [ 32 ] ; uint8_t checkMAC [ 32 ] ; bzrtpHelloMessage_t * peerHelloMessageData ; uint16_t variableLength = 0 ; bzrtpCommitMessage_t * messageData ; messageData = ( bzrtpCommitMessage_t * ) malloc ( sizeof ( bzrtpCommitMessage_t ) ) ; memcpy ( messageData -> H2 , messageContent , 32 ) ; messageContent += 32 ; if ( zrtpChannelContext -> peerPackets [ HELLO_MESSAGE_STORE_ID ] == NULL ) { free ( messageData ) ; return BZRTP_PARSER_ERROR_UNEXPECTEDMESSAGE ; } peerHelloMessageData = ( bzrtpHelloMessage_t * ) zrtpChannelContext -> peerPackets [ HELLO_MESSAGE_STORE_ID ] -> messageData ; bctoolbox_sha256 ( messageData -> H2 , 32 , 32 , checkH3 ) ; if ( memcmp ( checkH3 , peerHelloMessageData -> H3 , 32 ) != 0 ) { free ( messageData ) ; return BZRTP_PARSER_ERROR_UNMATCHINGHASHCHAIN ; } bctoolbox_hmacSha256 ( messageData -> H2 , 32 , zrtpChannelContext -> peerPackets [ HELLO_MESSAGE_STORE_ID ] -> packetString + ZRTP_PACKET_HEADER_LENGTH , zrtpChannelContext -> peerPackets [ HELLO_MESSAGE_STORE_ID ] -> messageLength - 8 , 8 , checkMAC ) ; if ( memcmp ( checkMAC , peerHelloMessageData -> MAC , 8 ) != 0 ) { free ( messageData ) ; return BZRTP_PARSER_ERROR_UNMATCHINGMAC ; } memcpy ( messageData -> ZID , messageContent , 12 ) ; messageContent += 12 ; messageData -> hashAlgo = cryptoAlgoTypeStringToInt ( messageContent , ZRTP_HASH_TYPE ) ; messageContent += 4 ; messageData -> cipherAlgo = cryptoAlgoTypeStringToInt ( messageContent , ZRTP_CIPHERBLOCK_TYPE ) ; messageContent += 4 ; messageData -> authTagAlgo = cryptoAlgoTypeStringToInt ( messageContent , ZRTP_AUTHTAG_TYPE ) ; messageContent += 4 ; messageData -> keyAgreementAlgo = cryptoAlgoTypeStringToInt ( messageContent , ZRTP_KEYAGREEMENT_TYPE ) ; messageContent += 4 ; switch ( messageData -> keyAgreementAlgo ) { case ZRTP_KEYAGREEMENT_DH2k : case ZRTP_KEYAGREEMENT_EC25 : case ZRTP_KEYAGREEMENT_DH3k : case ZRTP_KEYAGREEMENT_EC38 : case ZRTP_KEYAGREEMENT_EC52 : variableLength = 32 ; break ; case ZRTP_KEYAGREEMENT_Prsh : variableLength = 24 ; break ; case ZRTP_KEYAGREEMENT_Mult : variableLength = 16 ; break ; default : free ( messageData ) ; return BZRTP_PARSER_ERROR_INVALIDMESSAGE ; } if ( zrtpPacket -> messageLength != ZRTP_COMMITMESSAGE_FIXED_LENGTH + variableLength ) { free ( messageData ) ; return BZRTP_PARSER_ERROR_INVALIDMESSAGE ; } messageData -> sasAlgo = cryptoAlgoTypeStringToInt ( messageContent , ZRTP_SAS_TYPE ) ; messageContent += 4 ; if ( ( messageData -> keyAgreementAlgo == ZRTP_KEYAGREEMENT_Prsh ) || ( messageData -> keyAgreementAlgo == ZRTP_KEYAGREEMENT_Mult ) ) { memcpy ( messageData -> nonce , messageContent , 16 ) ; messageContent += 16 ; if ( messageData -> keyAgreementAlgo == ZRTP_KEYAGREEMENT_Prsh ) { memcpy ( messageData -> keyID , messageContent , 8 ) ; messageContent += 8 ; } } else { memcpy ( messageData -> hvi , messageContent , 32 ) ; messageContent += 32 ; } memcpy ( messageData -> MAC , messageContent , 8 ) ; zrtpPacket -> messageData = ( void * ) messageData ; zrtpPacket -> packetString = ( uint8_t * ) malloc ( inputLength * sizeof ( uint8_t ) ) ; memcpy ( zrtpPacket -> packetString , input , inputLength ) ; } break ; case MSGTYPE_DHPART1 : case MSGTYPE_DHPART2 : { bzrtpDHPartMessage_t * messageData ; uint16_t pvLength = computeKeyAgreementPrivateValueLength ( zrtpChannelContext -> keyAgreementAlgo ) ; if ( pvLength == 0 ) { return BZRTP_PARSER_ERROR_INVALIDCONTEXT ; } if ( zrtpPacket -> messageLength != ZRTP_DHPARTMESSAGE_FIXED_LENGTH + pvLength ) { return BZRTP_PARSER_ERROR_INVALIDMESSAGE ; } messageData = ( bzrtpDHPartMessage_t * ) malloc ( sizeof ( bzrtpDHPartMessage_t ) ) ; messageData -> pv = ( uint8_t * ) malloc ( pvLength * sizeof ( uint8_t ) ) ; memcpy ( messageData -> H1 , messageContent , 32 ) ; messageContent += 32 ; if ( zrtpChannelContext -> role == RESPONDER ) { uint8_t checkH2 [ 32 ] ; uint8_t checkMAC [ 32 ] ; bzrtpCommitMessage_t * peerCommitMessageData ; if ( zrtpChannelContext -> peerPackets [ COMMIT_MESSAGE_STORE_ID ] == NULL ) { free ( messageData ) ; return BZRTP_PARSER_ERROR_UNEXPECTEDMESSAGE ; } peerCommitMessageData = ( bzrtpCommitMessage_t * ) zrtpChannelContext -> peerPackets [ COMMIT_MESSAGE_STORE_ID ] -> messageData ; bctoolbox_sha256 ( messageData -> H1 , 32 , 32 , checkH2 ) ; if ( memcmp ( checkH2 , peerCommitMessageData -> H2 , 32 ) != 0 ) { free ( messageData ) ; return BZRTP_PARSER_ERROR_UNMATCHINGHASHCHAIN ; } bctoolbox_hmacSha256 ( messageData -> H1 , 32 , zrtpChannelContext -> peerPackets [ COMMIT_MESSAGE_STORE_ID ] -> packetString + ZRTP_PACKET_HEADER_LENGTH , zrtpChannelContext -> peerPackets [ COMMIT_MESSAGE_STORE_ID ] -> messageLength - 8 , 8 , checkMAC ) ; if ( memcmp ( checkMAC , peerCommitMessageData -> MAC , 8 ) != 0 ) { free ( messageData ) ; return BZRTP_PARSER_ERROR_UNMATCHINGMAC ; } <S2SV_StartBug> } else { <S2SV_EndBug> uint8_t checkH2 [ 32 ] ; uint8_t checkH3 [ 32 ] ; uint8_t checkMAC [ 32 ] ; bzrtpHelloMessage_t * peerHelloMessageData ; if ( zrtpChannelContext -> peerPackets [ HELLO_MESSAGE_STORE_ID ] == NULL ) { free ( messageData ) ; return BZRTP_PARSER_ERROR_UNEXPECTEDMESSAGE ; } peerHelloMessageData = ( bzrtpHelloMessage_t * ) zrtpChannelContext -> peerPackets [ HELLO_MESSAGE_STORE_ID ] -> messageData ; bctoolbox_sha256 ( messageData -> H1 , 32 , 32 , checkH2 ) ; bctoolbox_sha256 ( checkH2 , 32 , 32 , checkH3 ) ; if ( memcmp ( checkH3 , peerHelloMessageData -> H3 , 32 ) != 0 ) { free ( messageData ) ; return BZRTP_PARSER_ERROR_UNMATCHINGHASHCHAIN ; } bctoolbox_hmacSha256 ( checkH2 , 32 , zrtpChannelContext -> peerPackets [ HELLO_MESSAGE_STORE_ID ] -> packetString + ZRTP_PACKET_HEADER_LENGTH , zrtpChannelContext -> peerPackets [ HELLO_MESSAGE_STORE_ID ] -> messageLength - 8 , 8 , checkMAC ) ; if ( memcmp ( checkMAC , peerHelloMessageData -> MAC , 8 ) != 0 ) { free ( messageData ) ; return BZRTP_PARSER_ERROR_UNMATCHINGMAC ; } } memcpy ( messageData -> rs1ID , messageContent , 8 ) ; messageContent += 8 ; memcpy ( messageData -> rs2ID , messageContent , 8 ) ; messageContent += 8 ; memcpy ( messageData -> auxsecretID , messageContent , 8 ) ; messageContent += 8 ; memcpy ( messageData -> pbxsecretID , messageContent , 8 ) ; messageContent += 8 ; memcpy ( messageData -> pv , messageContent , pvLength ) ; messageContent += pvLength ; memcpy ( messageData -> MAC , messageContent , 8 ) ; zrtpPacket -> messageData = ( void * ) messageData ; zrtpPacket -> packetString = ( uint8_t * ) malloc ( inputLength * sizeof ( uint8_t ) ) ; memcpy ( zrtpPacket -> packetString , input , inputLength ) ; } break ; case MSGTYPE_CONFIRM1 : case MSGTYPE_CONFIRM2 : { uint8_t * confirmMessageKey = NULL ; uint8_t * confirmMessageMacKey = NULL ; bzrtpConfirmMessage_t * messageData ; uint16_t cipherTextLength ; uint8_t computedHmac [ 8 ] ; uint8_t * confirmPlainMessageBuffer ; uint8_t * confirmPlainMessage ; if ( zrtpChannelContext -> role == RESPONDER ) { if ( ( zrtpChannelContext -> zrtpkeyi == NULL ) || ( zrtpChannelContext -> mackeyi == NULL ) ) { return BZRTP_PARSER_ERROR_INVALIDCONTEXT ; } confirmMessageKey = zrtpChannelContext -> zrtpkeyi ; confirmMessageMacKey = zrtpChannelContext -> mackeyi ; } if ( zrtpChannelContext -> role == INITIATOR ) { if ( ( zrtpChannelContext -> zrtpkeyr == NULL ) || ( zrtpChannelContext -> mackeyr == NULL ) ) { return BZRTP_PARSER_ERROR_INVALIDCONTEXT ; } confirmMessageKey = zrtpChannelContext -> zrtpkeyr ; confirmMessageMacKey = zrtpChannelContext -> mackeyr ; } messageData = ( bzrtpConfirmMessage_t * ) malloc ( sizeof ( bzrtpConfirmMessage_t ) ) ; memcpy ( messageData -> confirm_mac , messageContent , 8 ) ; messageContent += 8 ; memcpy ( messageData -> CFBIV , messageContent , 16 ) ; messageContent += 16 ; cipherTextLength = zrtpPacket -> messageLength - ZRTP_MESSAGE_HEADER_LENGTH - 24 ; zrtpChannelContext -> hmacFunction ( confirmMessageMacKey , zrtpChannelContext -> hashLength , messageContent , cipherTextLength , 8 , computedHmac ) ; if ( memcmp ( computedHmac , messageData -> confirm_mac , 8 ) != 0 ) { free ( messageData ) ; return BZRTP_PARSER_ERROR_UNMATCHINGCONFIRMMAC ; } confirmPlainMessageBuffer = ( uint8_t * ) malloc ( cipherTextLength * sizeof ( uint8_t ) ) ; zrtpChannelContext -> cipherDecryptionFunction ( confirmMessageKey , messageData -> CFBIV , messageContent , cipherTextLength , confirmPlainMessageBuffer ) ; confirmPlainMessage = confirmPlainMessageBuffer ; memcpy ( messageData -> H0 , confirmPlainMessage , 32 ) ; confirmPlainMessage += 33 ; if ( zrtpChannelContext -> keyAgreementAlgo == ZRTP_KEYAGREEMENT_Prsh || zrtpChannelContext -> keyAgreementAlgo == ZRTP_KEYAGREEMENT_Mult ) { uint8_t checkH1 [ 32 ] ; bctoolbox_sha256 ( messageData -> H0 , 32 , 32 , checkH1 ) ; if ( zrtpChannelContext -> role == RESPONDER ) { uint8_t checkH2 [ 32 ] ; uint8_t checkMAC [ 32 ] ; bzrtpCommitMessage_t * peerCommitMessageData ; if ( zrtpChannelContext -> peerPackets [ COMMIT_MESSAGE_STORE_ID ] == NULL ) { free ( messageData ) ; return BZRTP_PARSER_ERROR_UNEXPECTEDMESSAGE ; } peerCommitMessageData = ( bzrtpCommitMessage_t * ) zrtpChannelContext -> peerPackets [ COMMIT_MESSAGE_STORE_ID ] -> messageData ; bctoolbox_sha256 ( checkH1 , 32 , 32 , checkH2 ) ; if ( memcmp ( checkH2 , peerCommitMessageData -> H2 , 32 ) != 0 ) { free ( messageData ) ; return BZRTP_PARSER_ERROR_UNMATCHINGHASHCHAIN ; } bctoolbox_hmacSha256 ( checkH1 , 32 , zrtpChannelContext -> peerPackets [ COMMIT_MESSAGE_STORE_ID ] -> packetString + ZRTP_PACKET_HEADER_LENGTH , zrtpChannelContext -> peerPackets [ COMMIT_MESSAGE_STORE_ID ] -> messageLength - 8 , 8 , checkMAC ) ; if ( memcmp ( checkMAC , peerCommitMessageData -> MAC , 8 ) != 0 ) { free ( messageData ) ; return BZRTP_PARSER_ERROR_UNMATCHINGMAC ; } } else { uint8_t checkH2 [ 32 ] ; uint8_t checkH3 [ 32 ] ; uint8_t checkMAC [ 32 ] ; bzrtpHelloMessage_t * peerHelloMessageData ; if ( zrtpChannelContext -> peerPackets [ HELLO_MESSAGE_STORE_ID ] == NULL ) { free ( messageData ) ; return BZRTP_PARSER_ERROR_UNEXPECTEDMESSAGE ; } peerHelloMessageData = ( bzrtpHelloMessage_t * ) zrtpChannelContext -> peerPackets [ HELLO_MESSAGE_STORE_ID ] -> messageData ; bctoolbox_sha256 ( checkH1 , 32 , 32 , checkH2 ) ; bctoolbox_sha256 ( checkH2 , 32 , 32 , checkH3 ) ; if ( memcmp ( checkH3 , peerHelloMessageData -> H3 , 32 ) != 0 ) { free ( messageData ) ; return BZRTP_PARSER_ERROR_UNMATCHINGHASHCHAIN ; } bctoolbox_hmacSha256 ( checkH2 , 32 , zrtpChannelContext -> peerPackets [ HELLO_MESSAGE_STORE_ID ] -> packetString + ZRTP_PACKET_HEADER_LENGTH , zrtpChannelContext -> peerPackets [ HELLO_MESSAGE_STORE_ID ] -> messageLength - 8 , 8 , checkMAC ) ; if ( memcmp ( checkMAC , peerHelloMessageData -> MAC , 8 ) != 0 ) { free ( messageData ) ; return BZRTP_PARSER_ERROR_UNMATCHINGMAC ; } } } else { uint8_t checkH1 [ 32 ] ; uint8_t checkMAC [ 32 ] ; bzrtpDHPartMessage_t * peerDHPartMessageData ; if ( zrtpChannelContext -> peerPackets [ DHPART_MESSAGE_STORE_ID ] == NULL ) { free ( messageData ) ; return BZRTP_PARSER_ERROR_UNEXPECTEDMESSAGE ; } peerDHPartMessageData = ( bzrtpDHPartMessage_t * ) zrtpChannelContext -> peerPackets [ DHPART_MESSAGE_STORE_ID ] -> messageData ; bctoolbox_sha256 ( messageData -> H0 , 32 , 32 , checkH1 ) ; if ( memcmp ( checkH1 , peerDHPartMessageData -> H1 , 32 ) != 0 ) { free ( messageData ) ; return BZRTP_PARSER_ERROR_UNMATCHINGHASHCHAIN ; } bctoolbox_hmacSha256 ( messageData -> H0 , 32 , zrtpChannelContext -> peerPackets [ DHPART_MESSAGE_STORE_ID ] -> packetString + ZRTP_PACKET_HEADER_LENGTH , zrtpChannelContext -> peerPackets [ DHPART_MESSAGE_STORE_ID ] -> messageLength - 8 , 8 , checkMAC ) ; if ( memcmp ( checkMAC , peerDHPartMessageData -> MAC , 8 ) != 0 ) { free ( messageData ) ; return BZRTP_PARSER_ERROR_UNMATCHINGMAC ; } } messageData -> sig_len = ( ( uint16_t ) ( confirmPlainMessage [ 0 ] & 0x01 ) ) << 8 | ( ( ( uint16_t ) confirmPlainMessage [ 1 ] ) & 0x00FF ) ; confirmPlainMessage += 2 ; messageData -> E = ( ( * confirmPlainMessage ) & 0x08 ) >> 3 ; messageData -> V = ( ( * confirmPlainMessage ) & 0x04 ) >> 2 ; messageData -> A = ( ( * confirmPlainMessage ) & 0x02 ) >> 1 ; messageData -> D = ( * confirmPlainMessage ) & 0x01 ; confirmPlainMessage += 1 ; messageData -> cacheExpirationInterval = ( ( ( uint32_t ) confirmPlainMessage [ 0 ] ) << 24 ) | ( ( ( uint32_t ) confirmPlainMessage [ 1 ] ) << 16 ) | ( ( ( uint32_t ) confirmPlainMessage [ 2 ] ) << 8 ) | ( ( uint32_t ) confirmPlainMessage [ 3 ] ) ; confirmPlainMessage += 4 ; if ( messageData -> sig_len > 0 ) { memcpy ( messageData -> signatureBlockType , confirmPlainMessage , 4 ) ; confirmPlainMessage += 4 ; messageData -> signatureBlock = ( uint8_t * ) malloc ( 4 * ( messageData -> sig_len - 1 ) * sizeof ( uint8_t ) ) ; memcpy ( messageData -> signatureBlock , confirmPlainMessage , 4 * ( messageData -> sig_len - 1 ) ) ; } else { messageData -> signatureBlock = NULL ; } free ( confirmPlainMessageBuffer ) ; zrtpPacket -> packetString = ( uint8_t * ) malloc ( inputLength * sizeof ( uint8_t ) ) ; memcpy ( zrtpPacket -> packetString , input , inputLength ) ; zrtpPacket -> messageData = ( void * ) messageData ; } break ; case MSGTYPE_CONF2ACK : break ; case MSGTYPE_PING : { bzrtpPingMessage_t * messageData ; messageData = ( bzrtpPingMessage_t * ) malloc ( sizeof ( bzrtpPingMessage_t ) ) ; memcpy ( messageData -> version , messageContent , 4 ) ; messageContent += 4 ; memcpy ( messageData -> endpointHash , messageContent , 8 ) ; zrtpPacket -> messageData = ( void * ) messageData ; } break ; } return 0 ; }
static int do_hidp_sock_ioctl ( struct socket * sock , unsigned int cmd , void __user * argp ) { struct hidp_connadd_req ca ; struct hidp_conndel_req cd ; struct hidp_connlist_req cl ; struct hidp_conninfo ci ; struct socket * csock ; struct socket * isock ; int err ; BT_DBG ( "cmd<S2SV_blank>%x<S2SV_blank>arg<S2SV_blank>%p" , cmd , argp ) ; switch ( cmd ) { case HIDPCONNADD : if ( ! capable ( CAP_NET_ADMIN ) ) return - EPERM ; if ( copy_from_user ( & ca , argp , sizeof ( ca ) ) ) return - EFAULT ; csock = sockfd_lookup ( ca . ctrl_sock , & err ) ; if ( ! csock ) return err ; isock = sockfd_lookup ( ca . intr_sock , & err ) ; if ( ! isock ) { sockfd_put ( csock ) ; return err ; <S2SV_StartBug> } <S2SV_EndBug> err = hidp_connection_add ( & ca , csock , isock ) ; if ( ! err && copy_to_user ( argp , & ca , sizeof ( ca ) ) ) err = - EFAULT ; sockfd_put ( csock ) ; sockfd_put ( isock ) ; return err ; case HIDPCONNDEL : if ( ! capable ( CAP_NET_ADMIN ) ) return - EPERM ; if ( copy_from_user ( & cd , argp , sizeof ( cd ) ) ) return - EFAULT ; return hidp_connection_del ( & cd ) ; case HIDPGETCONNLIST : if ( copy_from_user ( & cl , argp , sizeof ( cl ) ) ) return - EFAULT ; if ( cl . cnum <= 0 ) return - EINVAL ; err = hidp_get_connlist ( & cl ) ; if ( ! err && copy_to_user ( argp , & cl , sizeof ( cl ) ) ) return - EFAULT ; return err ; case HIDPGETCONNINFO : if ( copy_from_user ( & ci , argp , sizeof ( ci ) ) ) return - EFAULT ; err = hidp_get_conninfo ( & ci ) ; if ( ! err && copy_to_user ( argp , & ci , sizeof ( ci ) ) ) return - EFAULT ; return err ; } return - EINVAL ; }
int key_reject_and_link ( struct key * key , unsigned timeout , unsigned error , struct key * keyring , struct key * authkey ) { struct assoc_array_edit * edit ; struct timespec now ; int ret , awaken , link_ret = 0 ; key_check ( key ) ; key_check ( keyring ) ; awaken = 0 ; ret = - EBUSY ; if ( keyring ) { if ( keyring -> restrict_link ) return - EPERM ; link_ret = __key_link_begin ( keyring , & key -> index_key , & edit ) ; } mutex_lock ( & key_construction_mutex ) ; if ( ! test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) ) { atomic_inc ( & key -> user -> nikeys ) ; key -> reject_error = - error ; smp_wmb ( ) ; set_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ; set_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) ; now = current_kernel_time ( ) ; key -> expiry = now . tv_sec + timeout ; key_schedule_gc ( key -> expiry + key_gc_delay ) ; if ( test_and_clear_bit ( KEY_FLAG_USER_CONSTRUCT , & key -> flags ) ) awaken = 1 ; ret = 0 ; if ( keyring && link_ret == 0 ) __key_link ( key , & edit ) ; if ( authkey ) key_revoke ( authkey ) ; } mutex_unlock ( & key_construction_mutex ) ; <S2SV_StartBug> if ( keyring ) <S2SV_EndBug> __key_link_end ( keyring , & key -> index_key , edit ) ; if ( awaken ) wake_up_bit ( & key -> flags , KEY_FLAG_USER_CONSTRUCT ) ; return ret == 0 ? link_ret : ret ; }
static int b_unpack ( lua_State * L ) { Header h ; const char * fmt = luaL_checkstring ( L , 1 ) ; size_t ld ; const char * data = luaL_checklstring ( L , 2 , & ld ) ; <S2SV_StartBug> size_t pos = luaL_optinteger ( L , 3 , 1 ) - 1 ; <S2SV_EndBug> int n = 0 ; defaultoptions ( & h ) ; while ( * fmt ) { int opt = * fmt ++ ; size_t size = optsize ( L , opt , & fmt ) ; pos += gettoalign ( pos , & h , opt , size ) ; <S2SV_StartBug> luaL_argcheck ( L , pos + size <= ld , 2 , "data<S2SV_blank>string<S2SV_blank>too<S2SV_blank>short" ) ; <S2SV_EndBug> luaL_checkstack ( L , 2 , "too<S2SV_blank>many<S2SV_blank>results" ) ; switch ( opt ) { case 'b' : case 'B' : case 'h' : case 'H' : case 'l' : case 'L' : case 'T' : case 'i' : case 'I' : { int issigned = islower ( opt ) ; lua_Number res = getinteger ( data + pos , h . endian , issigned , size ) ; lua_pushnumber ( L , res ) ; n ++ ; break ; } case 'x' : { break ; } case 'f' : { float f ; memcpy ( & f , data + pos , size ) ; correctbytes ( ( char * ) & f , sizeof ( f ) , h . endian ) ; lua_pushnumber ( L , f ) ; n ++ ; break ; } case 'd' : { double d ; memcpy ( & d , data + pos , size ) ; correctbytes ( ( char * ) & d , sizeof ( d ) , h . endian ) ; lua_pushnumber ( L , d ) ; n ++ ; break ; } case 'c' : { if ( size == 0 ) { if ( n == 0 || ! lua_isnumber ( L , - 1 ) ) luaL_error ( L , "format<S2SV_blank>\'c0\'<S2SV_blank>needs<S2SV_blank>a<S2SV_blank>previous<S2SV_blank>size" ) ; size = lua_tonumber ( L , - 1 ) ; lua_pop ( L , 1 ) ; n -- ; luaL_argcheck ( L , size <= ld && pos <= ld - size , 2 , "data<S2SV_blank>string<S2SV_blank>too<S2SV_blank>short" ) ; } lua_pushlstring ( L , data + pos , size ) ; n ++ ; break ; } case 's' : { const char * e = ( const char * ) memchr ( data + pos , '\\0' , ld - pos ) ; if ( e == NULL ) luaL_error ( L , "unfinished<S2SV_blank>string<S2SV_blank>in<S2SV_blank>data" ) ; size = ( e - ( data + pos ) ) + 1 ; lua_pushlstring ( L , data + pos , size - 1 ) ; n ++ ; break ; } default : controloptions ( L , opt , & fmt , & h ) ; } pos += size ; } lua_pushinteger ( L , pos + 1 ) ; return n + 1 ; }
static int snd_ctl_elem_write ( struct snd_card * card , struct snd_ctl_file * file , struct snd_ctl_elem_value * control ) { struct snd_kcontrol * kctl ; struct snd_kcontrol_volatile * vd ; unsigned int index_offset ; int result ; down_read ( & card -> controls_rwsem ) ; kctl = snd_ctl_find_id ( card , & control -> id ) ; if ( kctl == NULL ) { result = - ENOENT ; } else { index_offset = snd_ctl_get_ioff ( kctl , & control -> id ) ; vd = & kctl -> vd [ index_offset ] ; if ( ! ( vd -> access & SNDRV_CTL_ELEM_ACCESS_WRITE ) || kctl -> put == NULL || ( file && vd -> owner && vd -> owner != file ) ) { result = - EPERM ; } else { snd_ctl_build_ioff ( & control -> id , kctl , index_offset ) ; result = kctl -> put ( kctl , control ) ; } if ( result > 0 ) { <S2SV_StartBug> up_read ( & card -> controls_rwsem ) ; <S2SV_EndBug> snd_ctl_notify ( card , SNDRV_CTL_EVENT_MASK_VALUE , <S2SV_StartBug> & control -> id ) ; <S2SV_EndBug> return 0 ; } } up_read ( & card -> controls_rwsem ) ; return result ; }
static void xen_irq_lateeoi_locked ( struct irq_info * info ) { evtchn_port_t evtchn ; <S2SV_StartBug> evtchn = info -> evtchn ; <S2SV_EndBug> <S2SV_StartBug> if ( ! VALID_EVTCHN ( evtchn ) ) <S2SV_EndBug> return ; unmask_evtchn ( evtchn ) ; }
<S2SV_StartBug> static vpx_codec_err_t vp8_set_postproc ( vpx_codec_alg_priv_t * ctx , <S2SV_EndBug> int ctr_id , va_list args ) { # if CONFIG_POSTPROC vp8_postproc_cfg_t * data = va_arg ( args , vp8_postproc_cfg_t * ) ; if ( data ) { ctx -> postproc_cfg_set = 1 ; ctx -> postproc_cfg = * ( ( vp8_postproc_cfg_t * ) data ) ; return VPX_CODEC_OK ; } else return VPX_CODEC_INVALID_PARAM ; # else <S2SV_StartBug> return VPX_CODEC_INCAPABLE ; <S2SV_EndBug> # endif }
static int swp_handler ( struct pt_regs * regs , unsigned int instr ) { unsigned int address , destreg , data , type ; unsigned int res = 0 ; <S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , regs -> ARM_pc ) ; <S2SV_EndBug> if ( current -> pid != previous_pid ) { pr_debug ( "\\"%s\\"<S2SV_blank>(%ld)<S2SV_blank>uses<S2SV_blank>deprecated<S2SV_blank>SWP{B}<S2SV_blank>instruction\\n" , current -> comm , ( unsigned long ) current -> pid ) ; previous_pid = current -> pid ; } address = regs -> uregs [ EXTRACT_REG_NUM ( instr , RN_OFFSET ) ] ; data = regs -> uregs [ EXTRACT_REG_NUM ( instr , RT2_OFFSET ) ] ; destreg = EXTRACT_REG_NUM ( instr , RT_OFFSET ) ; type = instr & TYPE_SWPB ; pr_debug ( "addr<S2SV_blank>in<S2SV_blank>r%d->0x%08x,<S2SV_blank>dest<S2SV_blank>is<S2SV_blank>r%d,<S2SV_blank>source<S2SV_blank>in<S2SV_blank>r%d->0x%08x)\\n" , EXTRACT_REG_NUM ( instr , RN_OFFSET ) , address , destreg , EXTRACT_REG_NUM ( instr , RT2_OFFSET ) , data ) ; if ( ! access_ok ( VERIFY_WRITE , ( address & ~ 3 ) , 4 ) ) { pr_debug ( "SWP{B}<S2SV_blank>emulation:<S2SV_blank>access<S2SV_blank>to<S2SV_blank>%p<S2SV_blank>not<S2SV_blank>allowed!\\n" , ( void * ) address ) ; res = - EFAULT ; } else { res = emulate_swpX ( address , & data , type ) ; } if ( res == 0 ) { regs -> ARM_pc += 4 ; regs -> uregs [ destreg ] = data ; } else if ( res == - EFAULT ) { set_segfault ( regs , address ) ; } return 0 ; }
int ext4_page_mkwrite ( struct vm_area_struct * vma , struct vm_fault * vmf ) { struct page * page = vmf -> page ; loff_t size ; unsigned long len ; int ret ; struct file * file = vma -> vm_file ; struct inode * inode = file_inode ( file ) ; struct address_space * mapping = inode -> i_mapping ; handle_t * handle ; get_block_t * get_block ; int retries = 0 ; sb_start_pagefault ( inode -> i_sb ) ; <S2SV_StartBug> file_update_time ( vma -> vm_file ) ; <S2SV_EndBug> if ( test_opt ( inode -> i_sb , DELALLOC ) && ! ext4_should_journal_data ( inode ) && ! ext4_nonda_switch ( inode -> i_sb ) ) { do { ret = block_page_mkwrite ( vma , vmf , ext4_da_get_block_prep ) ; } while ( ret == - ENOSPC && ext4_should_retry_alloc ( inode -> i_sb , & retries ) ) ; goto out_ret ; } lock_page ( page ) ; size = i_size_read ( inode ) ; if ( page -> mapping != mapping || page_offset ( page ) > size ) { unlock_page ( page ) ; ret = VM_FAULT_NOPAGE ; goto out ; } if ( page -> index == size >> PAGE_CACHE_SHIFT ) len = size & ~ PAGE_CACHE_MASK ; else len = PAGE_CACHE_SIZE ; if ( page_has_buffers ( page ) ) { if ( ! ext4_walk_page_buffers ( NULL , page_buffers ( page ) , 0 , len , NULL , ext4_bh_unmapped ) ) { wait_for_stable_page ( page ) ; ret = VM_FAULT_LOCKED ; goto out ; } } unlock_page ( page ) ; if ( ext4_should_dioread_nolock ( inode ) ) get_block = ext4_get_block_write ; else get_block = ext4_get_block ; retry_alloc : handle = ext4_journal_start ( inode , EXT4_HT_WRITE_PAGE , ext4_writepage_trans_blocks ( inode ) ) ; if ( IS_ERR ( handle ) ) { ret = VM_FAULT_SIGBUS ; goto out ; } ret = block_page_mkwrite ( vma , vmf , get_block ) ; if ( ! ret && ext4_should_journal_data ( inode ) ) { if ( ext4_walk_page_buffers ( handle , page_buffers ( page ) , 0 , PAGE_CACHE_SIZE , NULL , do_journal_get_write_access ) ) { unlock_page ( page ) ; ret = VM_FAULT_SIGBUS ; ext4_journal_stop ( handle ) ; goto out ; } ext4_set_inode_state ( inode , EXT4_STATE_JDATA ) ; } ext4_journal_stop ( handle ) ; if ( ret == - ENOSPC && ext4_should_retry_alloc ( inode -> i_sb , & retries ) ) goto retry_alloc ; out_ret : ret = block_page_mkwrite_return ( ret ) ; out : <S2SV_StartBug> sb_end_pagefault ( inode -> i_sb ) ; <S2SV_EndBug> return ret ; }
void vp9_setup_src_planes ( MACROBLOCK * x , const YV12_BUFFER_CONFIG * src , int mi_row , int mi_col ) { <S2SV_StartBug> uint8_t * const buffers [ 4 ] = { src -> y_buffer , src -> u_buffer , src -> v_buffer , <S2SV_EndBug> src -> alpha_buffer } ; <S2SV_StartBug> const int strides [ 4 ] = { src -> y_stride , src -> uv_stride , src -> uv_stride , <S2SV_EndBug> src -> alpha_stride } ; int i ; x -> e_mbd . cur_buf = src ; for ( i = 0 ; i < MAX_MB_PLANE ; i ++ ) setup_pred_plane ( & x -> plane [ i ] . src , buffers [ i ] , strides [ i ] , mi_row , mi_col , NULL , x -> e_mbd . plane [ i ] . subsampling_x , x -> e_mbd . plane [ i ] . subsampling_y ) ; }
static int webSocketsDecodeHybi ( rfbClientPtr cl , char * dst , int len ) { <S2SV_StartBug> char * buf , * payload ; <S2SV_EndBug> uint32_t * payload32 ; <S2SV_StartBug> int ret = - 1 , result = - 1 ; <S2SV_EndBug> <S2SV_StartBug> int total = 0 ; <S2SV_EndBug> ws_mask_t mask ; ws_header_t * header ; int i ; unsigned char opcode ; ws_ctx_t * wsctx = ( ws_ctx_t * ) cl -> wsctx ; int flength , fhlen ; if ( wsctx -> readbuflen ) { if ( wsctx -> readbuflen > len ) { memcpy ( dst , wsctx -> readbuf + wsctx -> readbufstart , len ) ; result = len ; wsctx -> readbuflen -= len ; wsctx -> readbufstart += len ; } else { memcpy ( dst , wsctx -> readbuf + wsctx -> readbufstart , wsctx -> readbuflen ) ; result = wsctx -> readbuflen ; wsctx -> readbuflen = 0 ; wsctx -> readbufstart = 0 ; } goto spor ; } buf = wsctx -> codeBufDecode ; header = ( ws_header_t * ) wsctx -> codeBufDecode ; ret = ws_peek ( cl , buf , B64LEN ( len ) + WSHLENMAX ) ; if ( ret < 2 ) { if ( - 1 == ret ) { int olderrno = errno ; rfbErr ( "%s:<S2SV_blank>peek;<S2SV_blank>%m\\n" , __func__ ) ; errno = olderrno ; <S2SV_StartBug> } else if ( 0 == ret ) { <S2SV_EndBug> result = 0 ; } else { errno = EAGAIN ; } goto spor ; } opcode = header -> b0 & 0x0f ; flength = header -> b1 & 0x7f ; if ( ! ( header -> b1 & 0x80 ) ) { rfbErr ( "%s:<S2SV_blank>got<S2SV_blank>frame<S2SV_blank>without<S2SV_blank>mask\\n" , __func__ , ret ) ; errno = EIO ; goto spor ; } if ( flength < 126 ) { fhlen = 2 ; mask = header -> u . m ; } else if ( flength == 126 && 4 <= ret ) { flength = WS_NTOH16 ( header -> u . s16 . l16 ) ; fhlen = 4 ; mask = header -> u . s16 . m16 ; } else if ( flength == 127 && 10 <= ret ) { flength = WS_NTOH64 ( header -> u . s64 . l64 ) ; fhlen = 10 ; mask = header -> u . s64 . m64 ; } else { rfbErr ( "%s:<S2SV_blank>incomplete<S2SV_blank>frame<S2SV_blank>header\\n" , __func__ , ret ) ; errno = EIO ; goto spor ; } total = fhlen + flength + 4 ; payload = buf + fhlen + 4 ; if ( - 1 == ( ret = ws_read ( cl , buf , total ) ) ) { int olderrno = errno ; rfbErr ( "%s:<S2SV_blank>read;<S2SV_blank>%m" , __func__ ) ; errno = olderrno ; return ret ; } else if ( ret < total ) { rfbLog ( "%s:<S2SV_blank>read;<S2SV_blank>got<S2SV_blank>partial<S2SV_blank>data\\n" , __func__ ) ; } else { buf [ ret ] = '\\0' ; } payload32 = ( uint32_t * ) payload ; for ( i = 0 ; i < flength / 4 ; i ++ ) { payload32 [ i ] ^= mask . u ; } for ( i *= 4 ; i < flength ; i ++ ) { payload [ i ] ^= mask . c [ i % 4 ] ; } switch ( opcode ) { case WS_OPCODE_CLOSE : rfbLog ( "got<S2SV_blank>closure,<S2SV_blank>reason<S2SV_blank>%d\\n" , WS_NTOH16 ( ( ( uint16_t * ) payload ) [ 0 ] ) ) ; errno = ECONNRESET ; break ; case WS_OPCODE_TEXT_FRAME : if ( - 1 == ( flength = b64_pton ( payload , ( unsigned char * ) wsctx -> codeBufDecode , sizeof ( wsctx -> codeBufDecode ) ) ) ) { rfbErr ( "%s:<S2SV_blank>Base64<S2SV_blank>decode<S2SV_blank>error;<S2SV_blank>%m\\n" , __func__ ) ; break ; } payload = wsctx -> codeBufDecode ; case WS_OPCODE_BINARY_FRAME : if ( flength > len ) { memcpy ( wsctx -> readbuf , payload + len , flength - len ) ; wsctx -> readbufstart = 0 ; wsctx -> readbuflen = flength - len ; flength = len ; } memcpy ( dst , payload , flength ) ; result = flength ; break ; default : rfbErr ( "%s:<S2SV_blank>unhandled<S2SV_blank>opcode<S2SV_blank>%d,<S2SV_blank>b0:<S2SV_blank>%02x,<S2SV_blank>b1:<S2SV_blank>%02x\\n" , __func__ , ( int ) opcode , header -> b0 , header -> b1 ) ; } spor : return result ; }
static double get_prediction_decay_rate ( VP8_COMP * cpi , FIRSTPASS_STATS * next_frame ) { double prediction_decay_rate ; double motion_decay ; <S2SV_StartBug> double motion_pct = next_frame -> pcnt_motion ; <S2SV_EndBug> prediction_decay_rate = next_frame -> pcnt_inter ; motion_decay = ( 1.0 - ( motion_pct / 20.0 ) ) ; if ( motion_decay < prediction_decay_rate ) prediction_decay_rate = motion_decay ; { double this_mv_rabs ; double this_mv_cabs ; double distance_factor ; this_mv_rabs = fabs ( next_frame -> mvr_abs * motion_pct ) ; this_mv_cabs = fabs ( next_frame -> mvc_abs * motion_pct ) ; distance_factor = sqrt ( ( this_mv_rabs * this_mv_rabs ) + ( this_mv_cabs * this_mv_cabs ) ) / 250.0 ; distance_factor = ( ( distance_factor > 1.0 ) ? 0.0 : ( 1.0 - distance_factor ) ) ; if ( distance_factor < prediction_decay_rate ) prediction_decay_rate = distance_factor ; } return prediction_decay_rate ; }
static int __ext4_set_acl ( handle_t * handle , struct inode * inode , int type , struct posix_acl * acl ) { int name_index ; void * value = NULL ; size_t size = 0 ; int error ; switch ( type ) { case ACL_TYPE_ACCESS : name_index = EXT4_XATTR_INDEX_POSIX_ACL_ACCESS ; if ( acl ) { <S2SV_StartBug> error = posix_acl_equiv_mode ( acl , & inode -> i_mode ) ; <S2SV_EndBug> if ( error < 0 ) return error ; else { inode -> i_ctime = ext4_current_time ( inode ) ; ext4_mark_inode_dirty ( handle , inode ) ; <S2SV_StartBug> if ( error == 0 ) <S2SV_EndBug> acl = NULL ; } } break ; case ACL_TYPE_DEFAULT : name_index = EXT4_XATTR_INDEX_POSIX_ACL_DEFAULT ; if ( ! S_ISDIR ( inode -> i_mode ) ) return acl ? - EACCES : 0 ; break ; default : return - EINVAL ; } if ( acl ) { value = ext4_acl_to_disk ( acl , & size ) ; if ( IS_ERR ( value ) ) return ( int ) PTR_ERR ( value ) ; } error = ext4_xattr_set_handle ( handle , inode , name_index , "" , value , size , 0 ) ; kfree ( value ) ; if ( ! error ) set_cached_acl ( inode , type , acl ) ; return error ; }
static int do_ip_getsockopt ( struct sock * sk , int level , int optname , char __user * optval , int __user * optlen ) { struct inet_sock * inet = inet_sk ( sk ) ; int val ; int len ; if ( level != SOL_IP ) return - EOPNOTSUPP ; if ( ip_mroute_opt ( optname ) ) return ip_mroute_getsockopt ( sk , optname , optval , optlen ) ; if ( get_user ( len , optlen ) ) return - EFAULT ; if ( len < 0 ) return - EINVAL ; lock_sock ( sk ) ; switch ( optname ) { case IP_OPTIONS : { unsigned char optbuf [ sizeof ( struct ip_options ) + 40 ] ; struct ip_options * opt = ( struct ip_options * ) optbuf ; <S2SV_StartBug> opt -> optlen = 0 ; <S2SV_EndBug> <S2SV_StartBug> if ( inet -> opt ) <S2SV_EndBug> memcpy ( optbuf , inet -> opt , sizeof ( struct ip_options ) + inet -> opt -> optlen ) ; release_sock ( sk ) ; if ( opt -> optlen == 0 ) return put_user ( 0 , optlen ) ; ip_options_undo ( opt ) ; len = min_t ( unsigned int , len , opt -> optlen ) ; if ( put_user ( len , optlen ) ) return - EFAULT ; if ( copy_to_user ( optval , opt -> __data , len ) ) return - EFAULT ; return 0 ; } case IP_PKTINFO : val = ( inet -> cmsg_flags & IP_CMSG_PKTINFO ) != 0 ; break ; case IP_RECVTTL : val = ( inet -> cmsg_flags & IP_CMSG_TTL ) != 0 ; break ; case IP_RECVTOS : val = ( inet -> cmsg_flags & IP_CMSG_TOS ) != 0 ; break ; case IP_RECVOPTS : val = ( inet -> cmsg_flags & IP_CMSG_RECVOPTS ) != 0 ; break ; case IP_RETOPTS : val = ( inet -> cmsg_flags & IP_CMSG_RETOPTS ) != 0 ; break ; case IP_PASSSEC : val = ( inet -> cmsg_flags & IP_CMSG_PASSSEC ) != 0 ; break ; case IP_RECVORIGDSTADDR : val = ( inet -> cmsg_flags & IP_CMSG_ORIGDSTADDR ) != 0 ; break ; case IP_TOS : val = inet -> tos ; break ; case IP_TTL : val = ( inet -> uc_ttl == - 1 ? sysctl_ip_default_ttl : inet -> uc_ttl ) ; break ; case IP_HDRINCL : val = inet -> hdrincl ; break ; case IP_NODEFRAG : val = inet -> nodefrag ; break ; case IP_MTU_DISCOVER : val = inet -> pmtudisc ; break ; case IP_MTU : { struct dst_entry * dst ; val = 0 ; dst = sk_dst_get ( sk ) ; if ( dst ) { val = dst_mtu ( dst ) ; dst_release ( dst ) ; } if ( ! val ) { release_sock ( sk ) ; return - ENOTCONN ; } break ; } case IP_RECVERR : val = inet -> recverr ; break ; case IP_MULTICAST_TTL : val = inet -> mc_ttl ; break ; case IP_MULTICAST_LOOP : val = inet -> mc_loop ; break ; case IP_MULTICAST_IF : { struct in_addr addr ; len = min_t ( unsigned int , len , sizeof ( struct in_addr ) ) ; addr . s_addr = inet -> mc_addr ; release_sock ( sk ) ; if ( put_user ( len , optlen ) ) return - EFAULT ; if ( copy_to_user ( optval , & addr , len ) ) return - EFAULT ; return 0 ; } case IP_MSFILTER : { struct ip_msfilter msf ; int err ; if ( len < IP_MSFILTER_SIZE ( 0 ) ) { release_sock ( sk ) ; return - EINVAL ; } if ( copy_from_user ( & msf , optval , IP_MSFILTER_SIZE ( 0 ) ) ) { release_sock ( sk ) ; return - EFAULT ; } err = ip_mc_msfget ( sk , & msf , ( struct ip_msfilter __user * ) optval , optlen ) ; release_sock ( sk ) ; return err ; } case MCAST_MSFILTER : { struct group_filter gsf ; int err ; if ( len < GROUP_FILTER_SIZE ( 0 ) ) { release_sock ( sk ) ; return - EINVAL ; } if ( copy_from_user ( & gsf , optval , GROUP_FILTER_SIZE ( 0 ) ) ) { release_sock ( sk ) ; return - EFAULT ; } err = ip_mc_gsfget ( sk , & gsf , ( struct group_filter __user * ) optval , optlen ) ; release_sock ( sk ) ; return err ; } case IP_MULTICAST_ALL : val = inet -> mc_all ; break ; case IP_PKTOPTIONS : { struct msghdr msg ; release_sock ( sk ) ; if ( sk -> sk_type != SOCK_STREAM ) return - ENOPROTOOPT ; msg . msg_control = optval ; msg . msg_controllen = len ; msg . msg_flags = 0 ; if ( inet -> cmsg_flags & IP_CMSG_PKTINFO ) { struct in_pktinfo info ; info . ipi_addr . s_addr = inet -> inet_rcv_saddr ; info . ipi_spec_dst . s_addr = inet -> inet_rcv_saddr ; info . ipi_ifindex = inet -> mc_index ; put_cmsg ( & msg , SOL_IP , IP_PKTINFO , sizeof ( info ) , & info ) ; } if ( inet -> cmsg_flags & IP_CMSG_TTL ) { int hlim = inet -> mc_ttl ; put_cmsg ( & msg , SOL_IP , IP_TTL , sizeof ( hlim ) , & hlim ) ; } len -= msg . msg_controllen ; return put_user ( len , optlen ) ; } case IP_FREEBIND : val = inet -> freebind ; break ; case IP_TRANSPARENT : val = inet -> transparent ; break ; case IP_MINTTL : val = inet -> min_ttl ; break ; default : release_sock ( sk ) ; return - ENOPROTOOPT ; } release_sock ( sk ) ; if ( len < sizeof ( int ) && len > 0 && val >= 0 && val <= 255 ) { unsigned char ucval = ( unsigned char ) val ; len = 1 ; if ( put_user ( len , optlen ) ) return - EFAULT ; if ( copy_to_user ( optval , & ucval , 1 ) ) return - EFAULT ; } else { len = min_t ( unsigned int , sizeof ( int ) , len ) ; if ( put_user ( len , optlen ) ) return - EFAULT ; if ( copy_to_user ( optval , & val , len ) ) return - EFAULT ; } return 0 ; }
static UINT parallel_process_irp_create ( PARALLEL_DEVICE * parallel , IRP * irp ) { char * path = NULL ; int status ; <S2SV_StartBug> UINT32 PathLength ; <S2SV_EndBug> <S2SV_StartBug> Stream_Seek ( irp -> input , 28 ) ; <S2SV_EndBug> Stream_Read_UINT32 ( irp -> input , PathLength ) ; <S2SV_StartBug> status = ConvertFromUnicode ( CP_UTF8 , 0 , ( WCHAR * ) Stream_Pointer ( irp -> input ) , PathLength / 2 , <S2SV_EndBug> & path , 0 , NULL , NULL ) ; if ( status < 1 ) if ( ! ( path = ( char * ) calloc ( 1 , 1 ) ) ) { WLog_ERR ( TAG , "calloc<S2SV_blank>failed!" ) ; return CHANNEL_RC_NO_MEMORY ; } parallel -> id = irp -> devman -> id_sequence ++ ; parallel -> file = open ( parallel -> path , O_RDWR ) ; if ( parallel -> file < 0 ) { irp -> IoStatus = STATUS_ACCESS_DENIED ; parallel -> id = 0 ; } else { if ( fcntl ( parallel -> file , F_SETFL , O_NONBLOCK ) == - 1 ) { } } Stream_Write_UINT32 ( irp -> output , parallel -> id ) ; Stream_Write_UINT8 ( irp -> output , 0 ) ; free ( path ) ; return irp -> Complete ( irp ) ; }
static int jas_iccgetuint16 ( jas_stream_t * in , jas_iccuint16_t * val ) { <S2SV_StartBug> ulonglong tmp ; <S2SV_EndBug> if ( jas_iccgetuint ( in , 2 , & tmp ) ) return - 1 ; * val = tmp ; return 0 ; }
static int snd_compr_allocate_buffer ( struct snd_compr_stream * stream , struct snd_compr_params * params ) { unsigned int buffer_size ; <S2SV_StartBug> void * buffer ; <S2SV_EndBug> buffer_size = params -> buffer . fragment_size * params -> buffer . fragments ; if ( stream -> ops -> copy ) { buffer = NULL ; } else { buffer = kmalloc ( buffer_size , GFP_KERNEL ) ; if ( ! buffer ) return - ENOMEM ; } stream -> runtime -> fragment_size = params -> buffer . fragment_size ; stream -> runtime -> fragments = params -> buffer . fragments ; stream -> runtime -> buffer = buffer ; stream -> runtime -> buffer_size = buffer_size ; return 0 ; }
BIO * PKCS7_dataDecode ( PKCS7 * p7 , EVP_PKEY * pkey , BIO * in_bio , X509 * pcert ) { int i , j ; BIO * out = NULL , * btmp = NULL , * etmp = NULL , * bio = NULL ; X509_ALGOR * xa ; ASN1_OCTET_STRING * data_body = NULL ; const EVP_MD * evp_md ; const EVP_CIPHER * evp_cipher = NULL ; EVP_CIPHER_CTX * evp_ctx = NULL ; X509_ALGOR * enc_alg = NULL ; STACK_OF ( X509_ALGOR ) * md_sk = NULL ; STACK_OF ( PKCS7_RECIP_INFO ) * rsk = NULL ; PKCS7_RECIP_INFO * ri = NULL ; unsigned char * ek = NULL , * tkey = NULL ; int eklen = 0 , tkeylen = 0 ; if ( p7 == NULL ) { PKCS7err ( PKCS7_F_PKCS7_DATADECODE , PKCS7_R_INVALID_NULL_POINTER ) ; return NULL ; } if ( p7 -> d . ptr == NULL ) { PKCS7err ( PKCS7_F_PKCS7_DATADECODE , PKCS7_R_NO_CONTENT ) ; return NULL ; } i = OBJ_obj2nid ( p7 -> type ) ; p7 -> state = PKCS7_S_HEADER ; switch ( i ) { case NID_pkcs7_signed : data_body = PKCS7_get_octet_string ( p7 -> d . sign -> contents ) ; if ( ! PKCS7_is_detached ( p7 ) && data_body == NULL ) { PKCS7err ( PKCS7_F_PKCS7_DATADECODE , PKCS7_R_INVALID_SIGNED_DATA_TYPE ) ; goto err ; } md_sk = p7 -> d . sign -> md_algs ; break ; case NID_pkcs7_signedAndEnveloped : rsk = p7 -> d . signed_and_enveloped -> recipientinfo ; md_sk = p7 -> d . signed_and_enveloped -> md_algs ; data_body = p7 -> d . signed_and_enveloped -> enc_data -> enc_data ; enc_alg = p7 -> d . signed_and_enveloped -> enc_data -> algorithm ; evp_cipher = EVP_get_cipherbyobj ( enc_alg -> algorithm ) ; if ( evp_cipher == NULL ) { PKCS7err ( PKCS7_F_PKCS7_DATADECODE , PKCS7_R_UNSUPPORTED_CIPHER_TYPE ) ; goto err ; } break ; case NID_pkcs7_enveloped : rsk = p7 -> d . enveloped -> recipientinfo ; enc_alg = p7 -> d . enveloped -> enc_data -> algorithm ; data_body = p7 -> d . enveloped -> enc_data -> enc_data ; evp_cipher = EVP_get_cipherbyobj ( enc_alg -> algorithm ) ; if ( evp_cipher == NULL ) { PKCS7err ( PKCS7_F_PKCS7_DATADECODE , PKCS7_R_UNSUPPORTED_CIPHER_TYPE ) ; goto err ; } break ; default : PKCS7err ( PKCS7_F_PKCS7_DATADECODE , PKCS7_R_UNSUPPORTED_CONTENT_TYPE ) ; goto err ; } <S2SV_StartBug> if ( md_sk != NULL ) { <S2SV_EndBug> for ( i = 0 ; i < sk_X509_ALGOR_num ( md_sk ) ; i ++ ) { xa = sk_X509_ALGOR_value ( md_sk , i ) ; if ( ( btmp = BIO_new ( BIO_f_md ( ) ) ) == NULL ) { PKCS7err ( PKCS7_F_PKCS7_DATADECODE , ERR_R_BIO_LIB ) ; goto err ; } j = OBJ_obj2nid ( xa -> algorithm ) ; evp_md = EVP_get_digestbynid ( j ) ; if ( evp_md == NULL ) { PKCS7err ( PKCS7_F_PKCS7_DATADECODE , PKCS7_R_UNKNOWN_DIGEST_TYPE ) ; goto err ; } BIO_set_md ( btmp , evp_md ) ; if ( out == NULL ) out = btmp ; else BIO_push ( out , btmp ) ; btmp = NULL ; } } if ( evp_cipher != NULL ) { if ( ( etmp = BIO_new ( BIO_f_cipher ( ) ) ) == NULL ) { PKCS7err ( PKCS7_F_PKCS7_DATADECODE , ERR_R_BIO_LIB ) ; goto err ; } if ( pcert ) { for ( i = 0 ; i < sk_PKCS7_RECIP_INFO_num ( rsk ) ; i ++ ) { ri = sk_PKCS7_RECIP_INFO_value ( rsk , i ) ; if ( ! pkcs7_cmp_ri ( ri , pcert ) ) break ; ri = NULL ; } if ( ri == NULL ) { PKCS7err ( PKCS7_F_PKCS7_DATADECODE , PKCS7_R_NO_RECIPIENT_MATCHES_CERTIFICATE ) ; goto err ; } } if ( pcert == NULL ) { for ( i = 0 ; i < sk_PKCS7_RECIP_INFO_num ( rsk ) ; i ++ ) { ri = sk_PKCS7_RECIP_INFO_value ( rsk , i ) ; if ( pkcs7_decrypt_rinfo ( & ek , & eklen , ri , pkey ) < 0 ) goto err ; ERR_clear_error ( ) ; } } else { if ( pkcs7_decrypt_rinfo ( & ek , & eklen , ri , pkey ) < 0 ) goto err ; ERR_clear_error ( ) ; } evp_ctx = NULL ; BIO_get_cipher_ctx ( etmp , & evp_ctx ) ; if ( EVP_CipherInit_ex ( evp_ctx , evp_cipher , NULL , NULL , NULL , 0 ) <= 0 ) goto err ; if ( EVP_CIPHER_asn1_to_param ( evp_ctx , enc_alg -> parameter ) < 0 ) goto err ; tkeylen = EVP_CIPHER_CTX_key_length ( evp_ctx ) ; tkey = OPENSSL_malloc ( tkeylen ) ; if ( ! tkey ) goto err ; if ( EVP_CIPHER_CTX_rand_key ( evp_ctx , tkey ) <= 0 ) goto err ; if ( ek == NULL ) { ek = tkey ; eklen = tkeylen ; tkey = NULL ; } if ( eklen != EVP_CIPHER_CTX_key_length ( evp_ctx ) ) { if ( ! EVP_CIPHER_CTX_set_key_length ( evp_ctx , eklen ) ) { OPENSSL_clear_free ( ek , eklen ) ; ek = tkey ; eklen = tkeylen ; tkey = NULL ; } } ERR_clear_error ( ) ; if ( EVP_CipherInit_ex ( evp_ctx , NULL , NULL , ek , NULL , 0 ) <= 0 ) goto err ; OPENSSL_clear_free ( ek , eklen ) ; ek = NULL ; OPENSSL_clear_free ( tkey , tkeylen ) ; tkey = NULL ; if ( out == NULL ) out = etmp ; else BIO_push ( out , etmp ) ; etmp = NULL ; } <S2SV_StartBug> if ( PKCS7_is_detached ( p7 ) || ( in_bio != NULL ) ) { <S2SV_EndBug> bio = in_bio ; } else { if ( data_body -> length > 0 ) bio = BIO_new_mem_buf ( data_body -> data , data_body -> length ) ; else { bio = BIO_new ( BIO_s_mem ( ) ) ; BIO_set_mem_eof_return ( bio , 0 ) ; } if ( bio == NULL ) goto err ; } BIO_push ( out , bio ) ; bio = NULL ; return out ; err : OPENSSL_clear_free ( ek , eklen ) ; OPENSSL_clear_free ( tkey , tkeylen ) ; BIO_free_all ( out ) ; BIO_free_all ( btmp ) ; BIO_free_all ( etmp ) ; BIO_free_all ( bio ) ; return NULL ; }
static void * bpf_obj_do_get ( const struct filename * pathname , enum bpf_type * type ) { struct inode * inode ; struct path path ; void * raw ; int ret ; ret = kern_path ( pathname -> name , LOOKUP_FOLLOW , & path ) ; if ( ret ) return ERR_PTR ( ret ) ; inode = d_backing_inode ( path . dentry ) ; ret = inode_permission ( inode , MAY_WRITE ) ; if ( ret ) goto out ; ret = bpf_inode_type ( inode , type ) ; if ( ret ) goto out ; raw = bpf_any_get ( inode -> i_private , * type ) ; <S2SV_StartBug> touch_atime ( & path ) ; <S2SV_EndBug> path_put ( & path ) ; return raw ; out : path_put ( & path ) ; return ERR_PTR ( ret ) ; }
int nfsd_dispatch ( struct svc_rqst * rqstp , __be32 * statp ) { struct svc_procedure * proc ; kxdrproc_t xdr ; __be32 nfserr ; __be32 * nfserrp ; dprintk ( "nfsd_dispatch:<S2SV_blank>vers<S2SV_blank>%d<S2SV_blank>proc<S2SV_blank>%d\\n" , rqstp -> rq_vers , rqstp -> rq_proc ) ; <S2SV_StartBug> proc = rqstp -> rq_procinfo ; <S2SV_EndBug> rqstp -> rq_cachetype = proc -> pc_cachetype ; xdr = proc -> pc_decode ; if ( xdr && ! xdr ( rqstp , ( __be32 * ) rqstp -> rq_arg . head [ 0 ] . iov_base , rqstp -> rq_argp ) ) { dprintk ( "nfsd:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>arguments!\\n" ) ; * statp = rpc_garbage_args ; return 1 ; } switch ( nfsd_cache_lookup ( rqstp ) ) { case RC_DROPIT : return 0 ; case RC_REPLY : return 1 ; case RC_DOIT : ; } nfserrp = rqstp -> rq_res . head [ 0 ] . iov_base + rqstp -> rq_res . head [ 0 ] . iov_len ; rqstp -> rq_res . head [ 0 ] . iov_len += sizeof ( __be32 ) ; nfserr = proc -> pc_func ( rqstp , rqstp -> rq_argp , rqstp -> rq_resp ) ; nfserr = map_new_errors ( rqstp -> rq_vers , nfserr ) ; if ( nfserr == nfserr_dropit || test_bit ( RQ_DROPME , & rqstp -> rq_flags ) ) { dprintk ( "nfsd:<S2SV_blank>Dropping<S2SV_blank>request;<S2SV_blank>may<S2SV_blank>be<S2SV_blank>revisited<S2SV_blank>later\\n" ) ; nfsd_cache_update ( rqstp , RC_NOCACHE , NULL ) ; return 0 ; } if ( rqstp -> rq_proc != 0 ) * nfserrp ++ = nfserr ; if ( ! ( nfserr && rqstp -> rq_vers == 2 ) ) { xdr = proc -> pc_encode ; if ( xdr && ! xdr ( rqstp , nfserrp , rqstp -> rq_resp ) ) { dprintk ( "nfsd:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>encode<S2SV_blank>result!\\n" ) ; nfsd_cache_update ( rqstp , RC_NOCACHE , NULL ) ; * statp = rpc_system_err ; return 1 ; } } nfsd_cache_update ( rqstp , rqstp -> rq_cachetype , statp + 1 ) ; return 1 ; }
int my_redel ( const char * org_name , const char * tmp_name , myf MyFlags ) { int error = 1 ; DBUG_ENTER ( "my_redel" ) ; DBUG_PRINT ( "my" , ( "org_name:<S2SV_blank>\'%s\'<S2SV_blank>tmp_name:<S2SV_blank>\'%s\'<S2SV_blank><S2SV_blank>MyFlags:<S2SV_blank>%d" , org_name , tmp_name , MyFlags ) ) ; <S2SV_StartBug> if ( my_copystat ( org_name , tmp_name , MyFlags ) < 0 ) <S2SV_EndBug> <S2SV_StartBug> goto end ; <S2SV_EndBug> if ( MyFlags & MY_REDEL_MAKE_BACKUP ) { char name_buff [ FN_REFLEN + 20 ] ; char ext [ 20 ] ; ext [ 0 ] = '-' ; get_date ( ext + 1 , 2 + 4 , ( time_t ) 0 ) ; strmov ( strend ( ext ) , REDEL_EXT ) ; if ( my_rename ( org_name , fn_format ( name_buff , org_name , "" , ext , 2 ) , MyFlags ) ) goto end ; } else if ( my_delete_allow_opened ( org_name , MyFlags ) ) goto end ; if ( my_rename ( tmp_name , org_name , MyFlags ) ) goto end ; error = 0 ; end : DBUG_RETURN ( error ) ; }
static int br_mdb_fill_info ( struct sk_buff * skb , struct netlink_callback * cb , struct net_device * dev ) { struct net_bridge * br = netdev_priv ( dev ) ; struct net_bridge_mdb_htable * mdb ; struct nlattr * nest , * nest2 ; int i , err = 0 ; int idx = 0 , s_idx = cb -> args [ 1 ] ; if ( br -> multicast_disabled ) return 0 ; mdb = rcu_dereference ( br -> mdb ) ; if ( ! mdb ) return 0 ; nest = nla_nest_start ( skb , MDBA_MDB ) ; if ( nest == NULL ) return - EMSGSIZE ; for ( i = 0 ; i < mdb -> max ; i ++ ) { struct net_bridge_mdb_entry * mp ; struct net_bridge_port_group * p , * * pp ; struct net_bridge_port * port ; hlist_for_each_entry_rcu ( mp , & mdb -> mhash [ i ] , hlist [ mdb -> ver ] ) { if ( idx < s_idx ) goto skip ; nest2 = nla_nest_start ( skb , MDBA_MDB_ENTRY ) ; if ( nest2 == NULL ) { err = - EMSGSIZE ; goto out ; } for ( pp = & mp -> ports ; ( p = rcu_dereference ( * pp ) ) != NULL ; pp = & p -> next ) { port = p -> port ; if ( port ) { struct br_mdb_entry e ; <S2SV_StartBug> e . ifindex = port -> dev -> ifindex ; <S2SV_EndBug> e . state = p -> state ; if ( p -> addr . proto == htons ( ETH_P_IP ) ) e . addr . u . ip4 = p -> addr . u . ip4 ; # if IS_ENABLED ( CONFIG_IPV6 ) if ( p -> addr . proto == htons ( ETH_P_IPV6 ) ) e . addr . u . ip6 = p -> addr . u . ip6 ; # endif e . addr . proto = p -> addr . proto ; if ( nla_put ( skb , MDBA_MDB_ENTRY_INFO , sizeof ( e ) , & e ) ) { nla_nest_cancel ( skb , nest2 ) ; err = - EMSGSIZE ; goto out ; } } } nla_nest_end ( skb , nest2 ) ; skip : idx ++ ; } } out : cb -> args [ 1 ] = idx ; nla_nest_end ( skb , nest ) ; return err ; }
static int extractRDNSequence ( struct ndpi_packet_struct * packet , u_int offset , char * buffer , u_int buffer_len , char * rdnSeqBuf , u_int * rdnSeqBuf_offset , u_int rdnSeqBuf_len , const char * label ) { u_int8_t str_len = packet -> payload [ offset + 4 ] , is_printable = 1 ; char * str ; <S2SV_StartBug> u_int len , j ; <S2SV_EndBug> if ( ( offset + 4 + str_len ) >= packet -> payload_packet_len ) return ( - 1 ) ; str = ( char * ) & packet -> payload [ offset + 5 ] ; len = ( u_int ) ndpi_min ( str_len , buffer_len - 1 ) ; strncpy ( buffer , str , len ) ; buffer [ len ] = '\\0' ; for ( j = 0 ; j < len ; j ++ ) { if ( ! ndpi_isprint ( buffer [ j ] ) ) { is_printable = 0 ; break ; } } if ( is_printable ) { int rc = snprintf ( & rdnSeqBuf [ * rdnSeqBuf_offset ] , rdnSeqBuf_len - ( * rdnSeqBuf_offset ) , "%s%s=%s" , ( * rdnSeqBuf_offset > 0 ) ? ",<S2SV_blank>" : "" , label , buffer ) ; if ( rc > 0 ) ( * rdnSeqBuf_offset ) += rc ; } return ( is_printable ) ; }
void ngx_gmtime ( time_t t , ngx_tm_t * tp ) { ngx_int_t yday ; ngx_uint_t sec , min , hour , mday , mon , year , wday , days , leap ; if ( t < 0 ) { t = 0 ; } days = t / 86400 ; <S2SV_StartBug> sec = t % 86400 ; <S2SV_EndBug> wday = ( 4 + days ) % 7 ; hour = sec / 3600 ; sec %= 3600 ; min = sec / 60 ; sec %= 60 ; days = days - ( 31 + 28 ) + 719527 ; year = ( days + 2 ) * 400 / ( 365 * 400 + 100 - 4 + 1 ) ; yday = days - ( 365 * year + year / 4 - year / 100 + year / 400 ) ; if ( yday < 0 ) { leap = ( year % 4 == 0 ) && ( year % 100 || ( year % 400 == 0 ) ) ; yday = 365 + leap + yday ; year -- ; } mon = ( yday + 31 ) * 10 / 306 ; mday = yday - ( 367 * mon / 12 - 30 ) + 1 ; if ( yday >= 306 ) { year ++ ; mon -= 10 ; } else { mon += 2 ; } tp -> ngx_tm_sec = ( ngx_tm_sec_t ) sec ; tp -> ngx_tm_min = ( ngx_tm_min_t ) min ; tp -> ngx_tm_hour = ( ngx_tm_hour_t ) hour ; tp -> ngx_tm_mday = ( ngx_tm_mday_t ) mday ; tp -> ngx_tm_mon = ( ngx_tm_mon_t ) mon ; tp -> ngx_tm_year = ( ngx_tm_year_t ) year ; tp -> ngx_tm_wday = ( ngx_tm_wday_t ) wday ; }
static int rose_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t size , int flags ) { struct sock * sk = sock -> sk ; <S2SV_StartBug> struct rose_sock * rose = rose_sk ( sk ) ; <S2SV_EndBug> struct sockaddr_rose * srose = ( struct sockaddr_rose * ) msg -> msg_name ; size_t copied ; unsigned char * asmptr ; struct sk_buff * skb ; int n , er , qbit ; if ( sk -> sk_state != TCP_ESTABLISHED ) return - ENOTCONN ; if ( ( skb = skb_recv_datagram ( sk , flags & ~ MSG_DONTWAIT , flags & MSG_DONTWAIT , & er ) ) == NULL ) return er ; qbit = ( skb -> data [ 0 ] & ROSE_Q_BIT ) == ROSE_Q_BIT ; skb_pull ( skb , ROSE_MIN_LEN ) ; if ( rose -> qbitincl ) { asmptr = skb_push ( skb , 1 ) ; * asmptr = qbit ; } skb_reset_transport_header ( skb ) ; copied = skb -> len ; if ( copied > size ) { copied = size ; msg -> msg_flags |= MSG_TRUNC ; } skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; <S2SV_StartBug> if ( srose != NULL ) { <S2SV_EndBug> <S2SV_StartBug> memset ( srose , 0 , msg -> msg_namelen ) ; <S2SV_EndBug> srose -> srose_family = AF_ROSE ; srose -> srose_addr = rose -> dest_addr ; srose -> srose_call = rose -> dest_call ; srose -> srose_ndigis = rose -> dest_ndigis ; if ( msg -> msg_namelen >= sizeof ( struct full_sockaddr_rose ) ) { struct full_sockaddr_rose * full_srose = ( struct full_sockaddr_rose * ) msg -> msg_name ; for ( n = 0 ; n < rose -> dest_ndigis ; n ++ ) full_srose -> srose_digis [ n ] = rose -> dest_digis [ n ] ; msg -> msg_namelen = sizeof ( struct full_sockaddr_rose ) ; } else { if ( rose -> dest_ndigis >= 1 ) { srose -> srose_ndigis = 1 ; srose -> srose_digi = rose -> dest_digis [ 0 ] ; } msg -> msg_namelen = sizeof ( struct sockaddr_rose ) ; } } skb_free_datagram ( sk , skb ) ; return copied ; }
static void exif_data_load_data_thumbnail ( ExifData * data , const unsigned char * d , unsigned int ds , ExifLong o , ExifLong s ) { <S2SV_StartBug> if ( ( o + s < o ) || ( o + s < s ) || ( o + s > ds ) || ( o > ds ) ) { <S2SV_EndBug> <S2SV_StartBug> exif_log ( data -> priv -> log , EXIF_LOG_CODE_DEBUG , "ExifData" , <S2SV_EndBug> "Bogus<S2SV_blank>thumbnail<S2SV_blank>offset<S2SV_blank>(%u)<S2SV_blank>or<S2SV_blank>size<S2SV_blank>(%u)." , o , s ) ; return ; } if ( data -> data ) exif_mem_free ( data -> priv -> mem , data -> data ) ; if ( ! ( data -> data = exif_data_alloc ( data , s ) ) ) { EXIF_LOG_NO_MEMORY ( data -> priv -> log , "ExifData" , s ) ; data -> size = 0 ; return ; } data -> size = s ; memcpy ( data -> data , d + o , s ) ; }
void * sspi_SecureHandleGetLowerPointer ( SecHandle * handle ) { void * pointer ; <S2SV_StartBug> if ( ! handle ) <S2SV_EndBug> return NULL ; pointer = ( void * ) ~ ( ( size_t ) handle -> dwLower ) ; return pointer ; }
static int replace_map_fd_with_map_ptr ( struct verifier_env * env ) { struct bpf_insn * insn = env -> prog -> insnsi ; int insn_cnt = env -> prog -> len ; int i , j ; for ( i = 0 ; i < insn_cnt ; i ++ , insn ++ ) { if ( BPF_CLASS ( insn -> code ) == BPF_LDX && ( BPF_MODE ( insn -> code ) != BPF_MEM || insn -> imm != 0 ) ) { verbose ( "BPF_LDX<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n" ) ; return - EINVAL ; } if ( BPF_CLASS ( insn -> code ) == BPF_STX && ( ( BPF_MODE ( insn -> code ) != BPF_MEM && BPF_MODE ( insn -> code ) != BPF_XADD ) || insn -> imm != 0 ) ) { verbose ( "BPF_STX<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n" ) ; return - EINVAL ; } if ( insn [ 0 ] . code == ( BPF_LD | BPF_IMM | BPF_DW ) ) { struct bpf_map * map ; struct fd f ; if ( i == insn_cnt - 1 || insn [ 1 ] . code != 0 || insn [ 1 ] . dst_reg != 0 || insn [ 1 ] . src_reg != 0 || insn [ 1 ] . off != 0 ) { verbose ( "invalid<S2SV_blank>bpf_ld_imm64<S2SV_blank>insn\\n" ) ; return - EINVAL ; } if ( insn -> src_reg == 0 ) goto next_insn ; if ( insn -> src_reg != BPF_PSEUDO_MAP_FD ) { verbose ( "unrecognized<S2SV_blank>bpf_ld_imm64<S2SV_blank>insn\\n" ) ; return - EINVAL ; } f = fdget ( insn -> imm ) ; map = __bpf_map_get ( f ) ; if ( IS_ERR ( map ) ) { verbose ( "fd<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>not<S2SV_blank>pointing<S2SV_blank>to<S2SV_blank>valid<S2SV_blank>bpf_map\\n" , insn -> imm ) ; <S2SV_StartBug> fdput ( f ) ; <S2SV_EndBug> return PTR_ERR ( map ) ; } insn [ 0 ] . imm = ( u32 ) ( unsigned long ) map ; insn [ 1 ] . imm = ( ( u64 ) ( unsigned long ) map ) >> 32 ; for ( j = 0 ; j < env -> used_map_cnt ; j ++ ) if ( env -> used_maps [ j ] == map ) { fdput ( f ) ; goto next_insn ; } if ( env -> used_map_cnt >= MAX_USED_MAPS ) { fdput ( f ) ; return - E2BIG ; } env -> used_maps [ env -> used_map_cnt ++ ] = map ; bpf_map_inc ( map , false ) ; fdput ( f ) ; next_insn : insn ++ ; i ++ ; } } return 0 ; }
static const u_char * ikev1_id_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep _U_ , uint32_t phase , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { # define USE_IPSECDOI_IN_PHASE1 1 const struct ikev1_pl_id * p ; struct ikev1_pl_id id ; static const char * idtypestr [ ] = { "IPv4" , "IPv4net" , "IPv6" , "IPv6net" , } ; static const char * ipsecidtypestr [ ] = { NULL , "IPv4" , "FQDN" , "user<S2SV_blank>FQDN" , "IPv4net" , "IPv6" , "IPv6net" , "IPv4range" , "IPv6range" , "ASN1<S2SV_blank>DN" , "ASN1<S2SV_blank>GN" , "keyid" , } ; int len ; const u_char * data ; ND_PRINT ( ( ndo , "%s:" , NPSTR ( ISAKMP_NPTYPE_ID ) ) ) ; p = ( const struct ikev1_pl_id * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & id , ext , sizeof ( id ) ) ; if ( sizeof ( * p ) < item_len ) { data = ( const u_char * ) ( p + 1 ) ; len = item_len - sizeof ( * p ) ; } else { data = NULL ; len = 0 ; } # if 0 ND_PRINT ( ( ndo , "<S2SV_blank>[phase=%d<S2SV_blank>doi=%d<S2SV_blank>proto=%d]" , phase , doi , proto ) ) ; # endif switch ( phase ) { # ifndef USE_IPSECDOI_IN_PHASE1 case 1 : # endif default : ND_PRINT ( ( ndo , "<S2SV_blank>idtype=%s" , STR_OR_ID ( id . d . id_type , idtypestr ) ) ) ; ND_PRINT ( ( ndo , "<S2SV_blank>doi_data=%u" , ( uint32_t ) ( ntohl ( id . d . doi_data ) & 0xffffff ) ) ) ; break ; # ifdef USE_IPSECDOI_IN_PHASE1 case 1 : # endif case 2 : { const struct ipsecdoi_id * doi_p ; struct ipsecdoi_id doi_id ; const char * p_name ; doi_p = ( const struct ipsecdoi_id * ) ext ; ND_TCHECK ( * doi_p ) ; UNALIGNED_MEMCPY ( & doi_id , ext , sizeof ( doi_id ) ) ; ND_PRINT ( ( ndo , "<S2SV_blank>idtype=%s" , STR_OR_ID ( doi_id . type , ipsecidtypestr ) ) ) ; if ( ! ndo -> ndo_nflag && doi_id . proto_id && ( p_name = netdb_protoname ( doi_id . proto_id ) ) != NULL ) ND_PRINT ( ( ndo , "<S2SV_blank>protoid=%s" , p_name ) ) ; else ND_PRINT ( ( ndo , "<S2SV_blank>protoid=%u" , doi_id . proto_id ) ) ; ND_PRINT ( ( ndo , "<S2SV_blank>port=%d" , ntohs ( doi_id . port ) ) ) ; if ( ! len ) break ; if ( data == NULL ) goto trunc ; ND_TCHECK2 ( * data , len ) ; switch ( doi_id . type ) { case IPSECDOI_ID_IPV4_ADDR : if ( len < 4 ) ND_PRINT ( ( ndo , "<S2SV_blank>len=%d<S2SV_blank>[bad:<S2SV_blank><<S2SV_blank>4]" , len ) ) ; else ND_PRINT ( ( ndo , "<S2SV_blank>len=%d<S2SV_blank>%s" , len , ipaddr_string ( ndo , data ) ) ) ; len = 0 ; break ; case IPSECDOI_ID_FQDN : case IPSECDOI_ID_USER_FQDN : { int i ; ND_PRINT ( ( ndo , "<S2SV_blank>len=%d<S2SV_blank>" , len ) ) ; for ( i = 0 ; i < len ; i ++ ) safeputchar ( ndo , data [ i ] ) ; len = 0 ; break ; } case IPSECDOI_ID_IPV4_ADDR_SUBNET : { const u_char * mask ; if ( len < 8 ) ND_PRINT ( ( ndo , "<S2SV_blank>len=%d<S2SV_blank>[bad:<S2SV_blank><<S2SV_blank>8]" , len ) ) ; else { mask = data + sizeof ( struct in_addr ) ; ND_PRINT ( ( ndo , "<S2SV_blank>len=%d<S2SV_blank>%s/%u.%u.%u.%u" , len , ipaddr_string ( ndo , data ) , mask [ 0 ] , mask [ 1 ] , mask [ 2 ] , mask [ 3 ] ) ) ; } len = 0 ; break ; } case IPSECDOI_ID_IPV6_ADDR : if ( len < 16 ) ND_PRINT ( ( ndo , "<S2SV_blank>len=%d<S2SV_blank>[bad:<S2SV_blank><<S2SV_blank>16]" , len ) ) ; else ND_PRINT ( ( ndo , "<S2SV_blank>len=%d<S2SV_blank>%s" , len , ip6addr_string ( ndo , data ) ) ) ; len = 0 ; break ; case IPSECDOI_ID_IPV6_ADDR_SUBNET : { const u_char * mask ; <S2SV_StartBug> if ( len < 20 ) <S2SV_EndBug> ND_PRINT ( ( ndo , "<S2SV_blank>len=%d<S2SV_blank>[bad:<S2SV_blank><<S2SV_blank>20]" , len ) ) ; else { mask = ( const u_char * ) ( data + sizeof ( struct in6_addr ) ) ; ND_PRINT ( ( ndo , "<S2SV_blank>len=%d<S2SV_blank>%s/0x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x" , len , ip6addr_string ( ndo , data ) , mask [ 0 ] , mask [ 1 ] , mask [ 2 ] , mask [ 3 ] , mask [ 4 ] , mask [ 5 ] , mask [ 6 ] , mask [ 7 ] , mask [ 8 ] , mask [ 9 ] , mask [ 10 ] , mask [ 11 ] , mask [ 12 ] , mask [ 13 ] , mask [ 14 ] , mask [ 15 ] ) ) ; } len = 0 ; break ; } case IPSECDOI_ID_IPV4_ADDR_RANGE : if ( len < 8 ) ND_PRINT ( ( ndo , "<S2SV_blank>len=%d<S2SV_blank>[bad:<S2SV_blank><<S2SV_blank>8]" , len ) ) ; else { ND_PRINT ( ( ndo , "<S2SV_blank>len=%d<S2SV_blank>%s-%s" , len , ipaddr_string ( ndo , data ) , ipaddr_string ( ndo , data + sizeof ( struct in_addr ) ) ) ) ; } len = 0 ; break ; case IPSECDOI_ID_IPV6_ADDR_RANGE : if ( len < 32 ) ND_PRINT ( ( ndo , "<S2SV_blank>len=%d<S2SV_blank>[bad:<S2SV_blank><<S2SV_blank>32]" , len ) ) ; else { ND_PRINT ( ( ndo , "<S2SV_blank>len=%d<S2SV_blank>%s-%s" , len , ip6addr_string ( ndo , data ) , ip6addr_string ( ndo , data + sizeof ( struct in6_addr ) ) ) ) ; } len = 0 ; break ; case IPSECDOI_ID_DER_ASN1_DN : case IPSECDOI_ID_DER_ASN1_GN : case IPSECDOI_ID_KEY_ID : break ; } break ; } } if ( data && len ) { ND_PRINT ( ( ndo , "<S2SV_blank>len=%d" , len ) ) ; if ( 2 < ndo -> ndo_vflag ) { ND_PRINT ( ( ndo , "<S2SV_blank>" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) data , len ) ) goto trunc ; } } return ( const u_char * ) ext + item_len ; trunc : ND_PRINT ( ( ndo , "<S2SV_blank>[|%s]" , NPSTR ( ISAKMP_NPTYPE_ID ) ) ) ; return NULL ; }
int yr_object_copy ( YR_OBJECT * object , YR_OBJECT * * object_copy ) { YR_OBJECT * copy ; YR_OBJECT * o ; YR_STRUCTURE_MEMBER * structure_member ; YR_OBJECT_FUNCTION * func ; YR_OBJECT_FUNCTION * func_copy ; int i ; * object_copy = NULL ; FAIL_ON_ERROR ( yr_object_create ( object -> type , object -> identifier , NULL , & copy ) ) ; switch ( object -> type ) { case OBJECT_TYPE_INTEGER : <S2SV_StartBug> ( ( YR_OBJECT_INTEGER * ) copy ) -> value = UNDEFINED ; <S2SV_EndBug> break ; case OBJECT_TYPE_STRING : <S2SV_StartBug> ( ( YR_OBJECT_STRING * ) copy ) -> value = NULL ; <S2SV_EndBug> break ; case OBJECT_TYPE_FUNCTION : func = ( YR_OBJECT_FUNCTION * ) object ; func_copy = ( YR_OBJECT_FUNCTION * ) copy ; FAIL_ON_ERROR_WITH_CLEANUP ( yr_object_copy ( func -> return_obj , & func_copy -> return_obj ) , yr_object_destroy ( copy ) ) ; for ( i = 0 ; i < MAX_OVERLOADED_FUNCTIONS ; i ++ ) func_copy -> prototypes [ i ] = func -> prototypes [ i ] ; break ; case OBJECT_TYPE_STRUCTURE : structure_member = ( ( YR_OBJECT_STRUCTURE * ) object ) -> members ; while ( structure_member != NULL ) { FAIL_ON_ERROR_WITH_CLEANUP ( yr_object_copy ( structure_member -> object , & o ) , yr_object_destroy ( copy ) ) ; FAIL_ON_ERROR_WITH_CLEANUP ( yr_object_structure_set_member ( copy , o ) , yr_free ( o ) ; yr_object_destroy ( copy ) ) ; structure_member = structure_member -> next ; } break ; case OBJECT_TYPE_ARRAY : yr_object_copy ( ( ( YR_OBJECT_ARRAY * ) object ) -> prototype_item , & o ) ; ( ( YR_OBJECT_ARRAY * ) copy ) -> prototype_item = o ; break ; case OBJECT_TYPE_DICTIONARY : yr_object_copy ( ( ( YR_OBJECT_DICTIONARY * ) object ) -> prototype_item , & o ) ; ( ( YR_OBJECT_DICTIONARY * ) copy ) -> prototype_item = o ; break ; default : assert ( FALSE ) ; } * object_copy = copy ; return ERROR_SUCCESS ; }
static int mark_source_chains ( const struct xt_table_info * newinfo , unsigned int valid_hooks , void * entry0 ) { unsigned int hook ; for ( hook = 0 ; hook < NF_INET_NUMHOOKS ; hook ++ ) { unsigned int pos = newinfo -> hook_entry [ hook ] ; struct ipt_entry * e = ( struct ipt_entry * ) ( entry0 + pos ) ; if ( ! ( valid_hooks & ( 1 << hook ) ) ) continue ; e -> counters . pcnt = pos ; for ( ; ; ) { const struct xt_standard_target * t = ( void * ) ipt_get_target_c ( e ) ; int visited = e -> comefrom & ( 1 << hook ) ; if ( e -> comefrom & ( 1 << NF_INET_NUMHOOKS ) ) { pr_err ( "iptables:<S2SV_blank>loop<S2SV_blank>hook<S2SV_blank>%u<S2SV_blank>pos<S2SV_blank>%u<S2SV_blank>%08X.\\n" , hook , pos , e -> comefrom ) ; return 0 ; } e -> comefrom |= ( ( 1 << hook ) | ( 1 << NF_INET_NUMHOOKS ) ) ; <S2SV_StartBug> if ( ( e -> target_offset == sizeof ( struct ipt_entry ) && <S2SV_EndBug> ( strcmp ( t -> target . u . user . name , XT_STANDARD_TARGET ) == 0 ) && <S2SV_StartBug> t -> verdict < 0 && unconditional ( & e -> ip ) ) || <S2SV_EndBug> visited ) { unsigned int oldpos , size ; if ( ( strcmp ( t -> target . u . user . name , XT_STANDARD_TARGET ) == 0 ) && t -> verdict < - NF_MAX_VERDICT - 1 ) { duprintf ( "mark_source_chains:<S2SV_blank>bad<S2SV_blank>" "negative<S2SV_blank>verdict<S2SV_blank>(%i)\\n" , t -> verdict ) ; return 0 ; } do { e -> comefrom ^= ( 1 << NF_INET_NUMHOOKS ) ; # ifdef DEBUG_IP_FIREWALL_USER if ( e -> comefrom & ( 1 << NF_INET_NUMHOOKS ) ) { duprintf ( "Back<S2SV_blank>unset<S2SV_blank>" "on<S2SV_blank>hook<S2SV_blank>%u<S2SV_blank>" "rule<S2SV_blank>%u\\n" , hook , pos ) ; } # endif oldpos = pos ; pos = e -> counters . pcnt ; e -> counters . pcnt = 0 ; if ( pos == oldpos ) goto next ; e = ( struct ipt_entry * ) ( entry0 + pos ) ; } while ( oldpos == pos + e -> next_offset ) ; size = e -> next_offset ; e = ( struct ipt_entry * ) ( entry0 + pos + size ) ; e -> counters . pcnt = pos ; pos += size ; } else { int newpos = t -> verdict ; if ( strcmp ( t -> target . u . user . name , XT_STANDARD_TARGET ) == 0 && newpos >= 0 ) { if ( newpos > newinfo -> size - sizeof ( struct ipt_entry ) ) { duprintf ( "mark_source_chains:<S2SV_blank>" "bad<S2SV_blank>verdict<S2SV_blank>(%i)\\n" , newpos ) ; return 0 ; } duprintf ( "Jump<S2SV_blank>rule<S2SV_blank>%u<S2SV_blank>-><S2SV_blank>%u\\n" , pos , newpos ) ; } else { newpos = pos + e -> next_offset ; } e = ( struct ipt_entry * ) ( entry0 + newpos ) ; e -> counters . pcnt = pos ; pos = newpos ; } } next : duprintf ( "Finished<S2SV_blank>chain<S2SV_blank>%u\\n" , hook ) ; } return 1 ; }
static inline int verify_replay ( struct xfrm_usersa_info * p , struct nlattr * * attrs ) { struct nlattr * rt = attrs [ XFRMA_REPLAY_ESN_VAL ] ; <S2SV_StartBug> if ( ( p -> flags & XFRM_STATE_ESN ) && ! rt ) <S2SV_EndBug> <S2SV_StartBug> return - EINVAL ; <S2SV_EndBug> if ( ! rt ) return 0 ; if ( p -> id . proto != IPPROTO_ESP ) return - EINVAL ; if ( p -> replay_window != 0 ) return - EINVAL ; return 0 ; }
int main ( int argc , char * * argv ) { int fd = xopen ( "/dev/null" , O_RDWR ) ; while ( fd < 2 ) fd = xdup ( fd ) ; if ( fd > 2 ) close ( fd ) ; int err = 1 ; logmode = LOGMODE_JOURNAL ; load_abrt_conf ( ) ; bool setting_MakeCompatCore ; bool setting_SaveBinaryImage ; bool setting_SaveFullCore ; bool setting_CreateCoreBacktrace ; bool setting_SaveContainerizedPackageData ; bool setting_StandaloneHook ; { map_string_t * settings = new_map_string ( ) ; load_abrt_plugin_conf_file ( "CCpp.conf" , settings ) ; const char * value ; value = get_map_string_item_or_NULL ( settings , "MakeCompatCore" ) ; setting_MakeCompatCore = value && string_to_bool ( value ) ; value = get_map_string_item_or_NULL ( settings , "SaveBinaryImage" ) ; setting_SaveBinaryImage = value && string_to_bool ( value ) ; value = get_map_string_item_or_NULL ( settings , "SaveFullCore" ) ; setting_SaveFullCore = value ? string_to_bool ( value ) : true ; value = get_map_string_item_or_NULL ( settings , "CreateCoreBacktrace" ) ; setting_CreateCoreBacktrace = value ? string_to_bool ( value ) : true ; value = get_map_string_item_or_NULL ( settings , "SaveContainerizedPackageData" ) ; setting_SaveContainerizedPackageData = value && string_to_bool ( value ) ; if ( ! g_settings_explorechroots ) { if ( setting_SaveContainerizedPackageData ) log_warning ( "Ignoring<S2SV_blank>SaveContainerizedPackageData<S2SV_blank>because<S2SV_blank>ExploreChroots<S2SV_blank>is<S2SV_blank>disabled" ) ; setting_SaveContainerizedPackageData = false ; } value = get_map_string_item_or_NULL ( settings , "StandaloneHook" ) ; setting_StandaloneHook = value && string_to_bool ( value ) ; value = get_map_string_item_or_NULL ( settings , "VerboseLog" ) ; if ( value ) g_verbose = xatoi_positive ( value ) ; free_map_string ( settings ) ; } if ( argc == 2 && strcmp ( argv [ 1 ] , "--config-test" ) ) return test_configuration ( setting_SaveFullCore , setting_CreateCoreBacktrace ) ; if ( argc < 8 ) { error_msg_and_die ( "Usage:<S2SV_blank>%s<S2SV_blank>SIGNO<S2SV_blank>CORE_SIZE_LIMIT<S2SV_blank>PID<S2SV_blank>UID<S2SV_blank>GID<S2SV_blank>TIME<S2SV_blank>BINARY_NAME<S2SV_blank>GLOBAL_PID<S2SV_blank>[TID]" , argv [ 0 ] ) ; } if ( strchr ( argv [ 1 ] , '<S2SV_blank>' ) ) { int i ; for ( i = 1 ; argv [ i ] ; i ++ ) { strchrnul ( argv [ i ] , '<S2SV_blank>' ) [ 0 ] = '\\0' ; } } errno = 0 ; const char * signal_str = argv [ 1 ] ; int signal_no = xatoi_positive ( signal_str ) ; off_t ulimit_c = strtoull ( argv [ 2 ] , NULL , 10 ) ; if ( ulimit_c < 0 ) { ulimit_c = ~ ( ( off_t ) 1 << ( sizeof ( off_t ) * 8 - 1 ) ) ; } const char * pid_str = argv [ 3 ] ; pid_t local_pid = xatoi_positive ( argv [ 3 ] ) ; uid_t uid = xatoi_positive ( argv [ 4 ] ) ; if ( errno || local_pid <= 0 ) { perror_msg_and_die ( "PID<S2SV_blank>\'%s\'<S2SV_blank>or<S2SV_blank>limit<S2SV_blank>\'%s\'<S2SV_blank>is<S2SV_blank>bogus" , argv [ 3 ] , argv [ 2 ] ) ; } { char * s = xmalloc_fopen_fgetline_fclose ( VAR_RUN "/abrt/saved_core_pattern" ) ; if ( s && s [ 0 ] != '|' ) core_basename = s ; else free ( s ) ; } const char * global_pid_str = argv [ 8 ] ; pid_t pid = xatoi_positive ( argv [ 8 ] ) ; pid_t tid = - 1 ; const char * tid_str = argv [ 9 ] ; if ( tid_str ) { tid = xatoi_positive ( tid_str ) ; } char path [ PATH_MAX ] ; char * executable = get_executable ( pid ) ; if ( executable && strstr ( executable , "/abrt-hook-ccpp" ) ) { error_msg_and_die ( "PID<S2SV_blank>%lu<S2SV_blank>is<S2SV_blank>\'%s\',<S2SV_blank>not<S2SV_blank>dumping<S2SV_blank>it<S2SV_blank>to<S2SV_blank>avoid<S2SV_blank>recursion" , ( long ) pid , executable ) ; } user_pwd = get_cwd ( pid ) ; log_notice ( "user_pwd:\'%s\'" , user_pwd ) ; sprintf ( path , "/proc/%lu/status" , ( long ) pid ) ; char * proc_pid_status = xmalloc_xopen_read_close ( path , NULL ) ; uid_t fsuid = uid ; uid_t tmp_fsuid = get_fsuid ( proc_pid_status ) ; if ( tmp_fsuid < 0 ) perror_msg_and_die ( "Can\'t<S2SV_blank>parse<S2SV_blank>\'Uid:<S2SV_blank>line\'<S2SV_blank>in<S2SV_blank>/proc/%lu/status" , ( long ) pid ) ; const int fsgid = get_fsgid ( proc_pid_status ) ; if ( fsgid < 0 ) error_msg_and_die ( "Can\'t<S2SV_blank>parse<S2SV_blank>\'Gid:<S2SV_blank>line\'<S2SV_blank>in<S2SV_blank>/proc/%lu/status" , ( long ) pid ) ; int suid_policy = dump_suid_policy ( ) ; if ( tmp_fsuid != uid ) { fsuid = 0 ; if ( suid_policy == DUMP_SUID_UNSAFE ) fsuid = tmp_fsuid ; else { g_user_core_flags = O_EXCL ; g_need_nonrelative = 1 ; } } int user_core_fd = - 1 ; if ( setting_MakeCompatCore && ulimit_c != 0 ) user_core_fd = open_user_core ( uid , fsuid , fsgid , pid , & argv [ 1 ] ) ; if ( executable == NULL ) { error_msg ( "Can\'t<S2SV_blank>read<S2SV_blank>/proc/%lu/exe<S2SV_blank>link" , ( long ) pid ) ; return create_user_core ( user_core_fd , pid , ulimit_c ) ; } const char * signame = NULL ; if ( ! signal_is_fatal ( signal_no , & signame ) ) return create_user_core ( user_core_fd , pid , ulimit_c ) ; const int abrtd_running = daemon_is_ok ( ) ; if ( ! setting_StandaloneHook && ! abrtd_running ) { log ( "abrtd<S2SV_blank>is<S2SV_blank>not<S2SV_blank>running.<S2SV_blank>If<S2SV_blank>it<S2SV_blank>crashed,<S2SV_blank>" "/proc/sys/kernel/core_pattern<S2SV_blank>contains<S2SV_blank>a<S2SV_blank>stale<S2SV_blank>value,<S2SV_blank>" "consider<S2SV_blank>resetting<S2SV_blank>it<S2SV_blank>to<S2SV_blank>\'core\'" ) ; return create_user_core ( user_core_fd , pid , ulimit_c ) ; } if ( setting_StandaloneHook ) ensure_writable_dir ( g_settings_dump_location , DEFAULT_DUMP_LOCATION_MODE , "abrt" ) ; if ( g_settings_nMaxCrashReportsSize > 0 ) { if ( low_free_space ( g_settings_nMaxCrashReportsSize , g_settings_dump_location ) ) return create_user_core ( user_core_fd , pid , ulimit_c ) ; } snprintf ( path , sizeof ( path ) , "%s/last-ccpp" , g_settings_dump_location ) ; if ( check_recent_crash_file ( path , executable ) ) { return create_user_core ( user_core_fd , pid , ulimit_c ) ; } const char * last_slash = strrchr ( executable , '/' ) ; if ( last_slash && strncmp ( ++ last_slash , "abrt" , 4 ) == 0 ) { if ( g_settings_debug_level == 0 ) { log_warning ( "Ignoring<S2SV_blank>crash<S2SV_blank>of<S2SV_blank>%s<S2SV_blank>(SIG%s)." , executable , signame ? signame : signal_str ) ; goto cleanup_and_exit ; } if ( snprintf ( path , sizeof ( path ) , "%s/%s-coredump" , g_settings_dump_location , last_slash ) >= sizeof ( path ) ) error_msg_and_die ( "Error<S2SV_blank>saving<S2SV_blank>\'%s\':<S2SV_blank>truncated<S2SV_blank>long<S2SV_blank>file<S2SV_blank>path" , path ) ; <S2SV_StartBug> int abrt_core_fd = xopen3 ( path , O_WRONLY | O_CREAT | O_TRUNC , 0600 ) ; <S2SV_EndBug> off_t core_size = copyfd_eof ( STDIN_FILENO , abrt_core_fd , COPYFD_SPARSE ) ; if ( core_size < 0 || fsync ( abrt_core_fd ) != 0 ) { unlink ( path ) ; error_msg_and_die ( "Error<S2SV_blank>saving<S2SV_blank>\'%s\'" , path ) ; } log_notice ( "Saved<S2SV_blank>core<S2SV_blank>dump<S2SV_blank>of<S2SV_blank>pid<S2SV_blank>%lu<S2SV_blank>(%s)<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>(%llu<S2SV_blank>bytes)" , ( long ) pid , executable , path , ( long long ) core_size ) ; err = 0 ; goto cleanup_and_exit ; } unsigned path_len = snprintf ( path , sizeof ( path ) , "%s/ccpp-%s-%lu.new" , g_settings_dump_location , iso_date_string ( NULL ) , ( long ) pid ) ; if ( path_len >= ( sizeof ( path ) - sizeof ( "/" FILENAME_COREDUMP ) ) ) { return create_user_core ( user_core_fd , pid , ulimit_c ) ; } dd = dd_create ( path , 0 , DEFAULT_DUMP_DIR_MODE ) ; if ( dd ) { char source_filename [ sizeof ( "/proc/%lu/somewhat_long_name" ) + sizeof ( long ) * 3 ] ; int source_base_ofs = sprintf ( source_filename , "/proc/%lu/root" , ( long ) pid ) ; source_base_ofs -= strlen ( "root" ) ; char * rootdir = process_has_own_root ( pid ) ? get_rootdir ( pid ) : NULL ; if ( g_settings_explorechroots ) { dd_create_basic_files ( dd , fsuid , ( rootdir != NULL ) ? source_filename : NULL ) ; } else { dd_create_basic_files ( dd , fsuid , NULL ) ; } char * dest_filename = concat_path_file ( dd -> dd_dirname , "also_somewhat_longish_name" ) ; char * dest_base = strrchr ( dest_filename , '/' ) + 1 ; strcpy ( source_filename + source_base_ofs , "maps" ) ; dd_copy_file ( dd , FILENAME_MAPS , source_filename ) ; strcpy ( source_filename + source_base_ofs , "limits" ) ; dd_copy_file ( dd , FILENAME_LIMITS , source_filename ) ; strcpy ( source_filename + source_base_ofs , "cgroup" ) ; dd_copy_file ( dd , FILENAME_CGROUP , source_filename ) ; strcpy ( source_filename + source_base_ofs , "mountinfo" ) ; dd_copy_file ( dd , FILENAME_MOUNTINFO , source_filename ) ; strcpy ( dest_base , FILENAME_OPEN_FDS ) ; strcpy ( source_filename + source_base_ofs , "fd" ) ; dump_fd_info_ext ( dest_filename , source_filename , dd -> dd_uid , dd -> dd_gid ) ; strcpy ( dest_base , FILENAME_NAMESPACES ) ; dump_namespace_diff_ext ( dest_filename , 1 , pid , dd -> dd_uid , dd -> dd_gid ) ; free ( dest_filename ) ; char * tmp = NULL ; get_env_variable ( pid , "container" , & tmp ) ; if ( tmp != NULL ) { dd_save_text ( dd , FILENAME_CONTAINER , tmp ) ; free ( tmp ) ; tmp = NULL ; } get_env_variable ( pid , "container_uuid" , & tmp ) ; if ( tmp != NULL ) { dd_save_text ( dd , FILENAME_CONTAINER_UUID , tmp ) ; free ( tmp ) ; } const int containerized = ( rootdir != NULL && strcmp ( rootdir , "/" ) == 0 ) ; if ( containerized ) { log_debug ( "Process<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>considered<S2SV_blank>to<S2SV_blank>be<S2SV_blank>containerized" , pid ) ; pid_t container_pid ; if ( get_pid_of_container ( pid , & container_pid ) == 0 ) { char * container_cmdline = get_cmdline ( container_pid ) ; dd_save_text ( dd , FILENAME_CONTAINER_CMDLINE , container_cmdline ) ; free ( container_cmdline ) ; } } dd_save_text ( dd , FILENAME_ANALYZER , "abrt-ccpp" ) ; dd_save_text ( dd , FILENAME_TYPE , "CCpp" ) ; dd_save_text ( dd , FILENAME_EXECUTABLE , executable ) ; dd_save_text ( dd , FILENAME_PID , pid_str ) ; dd_save_text ( dd , FILENAME_GLOBAL_PID , global_pid_str ) ; dd_save_text ( dd , FILENAME_PROC_PID_STATUS , proc_pid_status ) ; if ( user_pwd ) dd_save_text ( dd , FILENAME_PWD , user_pwd ) ; if ( tid_str ) dd_save_text ( dd , FILENAME_TID , tid_str ) ; if ( rootdir ) { if ( strcmp ( rootdir , "/" ) != 0 ) dd_save_text ( dd , FILENAME_ROOTDIR , rootdir ) ; } free ( rootdir ) ; char * reason = xasprintf ( "%s<S2SV_blank>killed<S2SV_blank>by<S2SV_blank>SIG%s" , last_slash , signame ? signame : signal_str ) ; dd_save_text ( dd , FILENAME_REASON , reason ) ; free ( reason ) ; char * cmdline = get_cmdline ( pid ) ; dd_save_text ( dd , FILENAME_CMDLINE , cmdline ? : "" ) ; free ( cmdline ) ; char * environ = get_environ ( pid ) ; dd_save_text ( dd , FILENAME_ENVIRON , environ ? : "" ) ; free ( environ ) ; char * fips_enabled = xmalloc_fopen_fgetline_fclose ( "/proc/sys/crypto/fips_enabled" ) ; if ( fips_enabled ) { if ( strcmp ( fips_enabled , "0" ) != 0 ) dd_save_text ( dd , "fips_enabled" , fips_enabled ) ; free ( fips_enabled ) ; } dd_save_text ( dd , FILENAME_ABRT_VERSION , VERSION ) ; long unsigned lck_bytes = ULONG_MAX ; const char * vmlck = strstr ( proc_pid_status , "VmLck:" ) ; if ( vmlck == NULL ) error_msg ( "/proc/%s/status<S2SV_blank>does<S2SV_blank>not<S2SV_blank>contain<S2SV_blank>\'VmLck:\'<S2SV_blank>line" , pid_str ) ; else if ( 1 != sscanf ( vmlck + 6 , "%lu<S2SV_blank>kB\\n" , & lck_bytes ) ) error_msg ( "Failed<S2SV_blank>to<S2SV_blank>parse<S2SV_blank>\'VmLck:\'<S2SV_blank>line<S2SV_blank>in<S2SV_blank>/proc/%s/status" , pid_str ) ; if ( lck_bytes ) { log_notice ( "Process<S2SV_blank>%s<S2SV_blank>of<S2SV_blank>user<S2SV_blank>%lu<S2SV_blank>has<S2SV_blank>locked<S2SV_blank>memory" , pid_str , ( long unsigned ) uid ) ; dd_mark_as_notreportable ( dd , "The<S2SV_blank>process<S2SV_blank>had<S2SV_blank>locked<S2SV_blank>memory<S2SV_blank>" "which<S2SV_blank>usually<S2SV_blank>indicates<S2SV_blank>efforts<S2SV_blank>to<S2SV_blank>protect<S2SV_blank>sensitive<S2SV_blank>" "data<S2SV_blank>(passwords)<S2SV_blank>from<S2SV_blank>being<S2SV_blank>written<S2SV_blank>to<S2SV_blank>disk.\\n" "In<S2SV_blank>order<S2SV_blank>to<S2SV_blank>avoid<S2SV_blank>sensitive<S2SV_blank>information<S2SV_blank>leakages,<S2SV_blank>" "ABRT<S2SV_blank>will<S2SV_blank>not<S2SV_blank>allow<S2SV_blank>you<S2SV_blank>to<S2SV_blank>report<S2SV_blank>this<S2SV_blank>problem<S2SV_blank>to<S2SV_blank>" "bug<S2SV_blank>tracking<S2SV_blank>tools" ) ; } if ( setting_SaveBinaryImage ) { if ( save_crashing_binary ( pid , dd ) ) { error_msg ( "Error<S2SV_blank>saving<S2SV_blank>\'%s\'" , path ) ; goto cleanup_and_exit ; } } off_t core_size = 0 ; if ( setting_SaveFullCore ) { strcpy ( path + path_len , "/" FILENAME_COREDUMP ) ; int abrt_core_fd = create_or_die ( path , user_core_fd ) ; core_size = copyfd_sparse ( STDIN_FILENO , abrt_core_fd , user_core_fd , ulimit_c ) ; close_user_core ( user_core_fd , core_size ) ; if ( fsync ( abrt_core_fd ) != 0 || close ( abrt_core_fd ) != 0 || core_size < 0 ) { unlink ( path ) ; error_msg ( "Error<S2SV_blank>writing<S2SV_blank>\'%s\'" , path ) ; goto cleanup_and_exit ; } } else { create_user_core ( user_core_fd , pid , ulimit_c ) ; } user_core_fd = - 1 ; # if 0 { char * java_log = xasprintf ( "/tmp/jvm-%lu/hs_error.log" , ( long ) pid ) ; int src_fd = open ( java_log , O_RDONLY ) ; free ( java_log ) ; if ( src_fd < 0 ) { java_log = xasprintf ( "%s/hs_err_pid%lu.log" , user_pwd , ( long ) pid ) ; src_fd = open ( java_log , O_RDONLY ) ; free ( java_log ) ; } if ( src_fd >= 0 ) { strcpy ( path + path_len , "/hs_err.log" ) ; int dst_fd = create_or_die ( path , user_core_fd ) ; off_t sz = copyfd_eof ( src_fd , dst_fd , COPYFD_SPARSE ) ; if ( close ( dst_fd ) != 0 || sz < 0 ) { error_msg ( "Error<S2SV_blank>saving<S2SV_blank>\'%s\'" , path ) ; goto cleanup_and_exit ; } close ( src_fd ) ; } } # endif if ( tid > 0 && setting_CreateCoreBacktrace ) create_core_backtrace ( tid , executable , signal_no , dd ) ; dd_close ( dd ) ; dd = NULL ; path [ path_len ] = '\\0' ; if ( abrtd_running && setting_SaveContainerizedPackageData && containerized ) { sprintf ( source_filename , "/proc/%lu/root" , ( long ) pid ) ; const char * cmd_args [ 6 ] ; cmd_args [ 0 ] = BIN_DIR "/abrt-action-save-package-data" ; cmd_args [ 1 ] = "-d" ; cmd_args [ 2 ] = path ; cmd_args [ 3 ] = "-r" ; cmd_args [ 4 ] = source_filename ; cmd_args [ 5 ] = NULL ; pid_t pid = fork_execv_on_steroids ( 0 , ( char * * ) cmd_args , NULL , NULL , path , 0 ) ; int stat ; safe_waitpid ( pid , & stat , 0 ) ; } char * newpath = xstrndup ( path , path_len - ( sizeof ( ".new" ) - 1 ) ) ; if ( rename ( path , newpath ) == 0 ) strcpy ( path , newpath ) ; free ( newpath ) ; if ( core_size > 0 ) log_notice ( "Saved<S2SV_blank>core<S2SV_blank>dump<S2SV_blank>of<S2SV_blank>pid<S2SV_blank>%lu<S2SV_blank>(%s)<S2SV_blank>to<S2SV_blank>%s<S2SV_blank>(%llu<S2SV_blank>bytes)" , ( long ) pid , executable , path , ( long long ) core_size ) ; if ( abrtd_running ) notify_new_path ( path ) ; if ( g_settings_nMaxCrashReportsSize > 0 ) { unsigned maxsize = g_settings_nMaxCrashReportsSize + g_settings_nMaxCrashReportsSize / 4 ; maxsize |= 63 ; trim_problem_dirs ( g_settings_dump_location , maxsize * ( double ) ( 1024 * 1024 ) , path ) ; } err = 0 ; } else { return create_user_core ( user_core_fd , pid , ulimit_c ) ; } cleanup_and_exit : if ( dd ) dd_delete ( dd ) ; if ( user_core_fd >= 0 ) unlinkat ( dirfd ( proc_cwd ) , core_basename , 0 ) ; if ( proc_cwd != NULL ) closedir ( proc_cwd ) ; return err ; }
static krb5_error_code tgs_make_reply ( krb5_context context , krb5_kdc_configuration * config , KDC_REQ_BODY * b , krb5_const_principal tgt_name , const EncTicketPart * tgt , const krb5_keyblock * replykey , int rk_is_subkey , const EncryptionKey * serverkey , const krb5_keyblock * sessionkey , krb5_kvno kvno , AuthorizationData * auth_data , hdb_entry_ex * server , krb5_principal server_principal , const char * server_name , hdb_entry_ex * client , <S2SV_StartBug> krb5_principal client_principal , <S2SV_EndBug> hdb_entry_ex * krbtgt , krb5_enctype krbtgt_etype , krb5_principals spp , const krb5_data * rspac , const METHOD_DATA * enc_pa_data , const char * * e_text , krb5_data * reply ) { KDC_REP rep ; EncKDCRepPart ek ; EncTicketPart et ; KDCOptions f = b -> kdc_options ; krb5_error_code ret ; int is_weak = 0 ; memset ( & rep , 0 , sizeof ( rep ) ) ; memset ( & et , 0 , sizeof ( et ) ) ; memset ( & ek , 0 , sizeof ( ek ) ) ; rep . pvno = 5 ; rep . msg_type = krb_tgs_rep ; et . authtime = tgt -> authtime ; _kdc_fix_time ( & b -> till ) ; et . endtime = min ( tgt -> endtime , * b -> till ) ; ALLOC ( et . starttime ) ; * et . starttime = kdc_time ; ret = check_tgs_flags ( context , config , b , tgt , & et ) ; if ( ret ) goto out ; # define GLOBAL_FORCE_TRANSITED_CHECK ( config -> trpolicy == TRPOLICY_ALWAYS_CHECK ) # define GLOBAL_ALLOW_PER_PRINCIPAL ( config -> trpolicy == TRPOLICY_ALLOW_PER_PRINCIPAL ) # define GLOBAL_ALLOW_DISABLE_TRANSITED_CHECK ( config -> trpolicy == TRPOLICY_ALWAYS_HONOUR_REQUEST ) # define PRINCIPAL_FORCE_TRANSITED_CHECK ( P ) 0 # define PRINCIPAL_ALLOW_DISABLE_TRANSITED_CHECK ( P ) 0 ret = fix_transited_encoding ( context , config , ! f . disable_transited_check || GLOBAL_FORCE_TRANSITED_CHECK || PRINCIPAL_FORCE_TRANSITED_CHECK ( server ) || ! ( ( GLOBAL_ALLOW_PER_PRINCIPAL && PRINCIPAL_ALLOW_DISABLE_TRANSITED_CHECK ( server ) ) || GLOBAL_ALLOW_DISABLE_TRANSITED_CHECK ) , & tgt -> transited , & et , krb5_principal_get_realm ( context , client_principal ) , krb5_principal_get_realm ( context , server -> entry . principal ) , <S2SV_StartBug> krb5_principal_get_realm ( context , krbtgt -> entry . principal ) ) ; <S2SV_EndBug> if ( ret ) goto out ; copy_Realm ( & server_principal -> realm , & rep . ticket . realm ) ; _krb5_principal2principalname ( & rep . ticket . sname , server_principal ) ; copy_Realm ( & tgt_name -> realm , & rep . crealm ) ; copy_PrincipalName ( & tgt_name -> name , & rep . cname ) ; rep . ticket . tkt_vno = 5 ; ek . caddr = et . caddr ; { time_t life ; life = et . endtime - * et . starttime ; if ( client && client -> entry . max_life ) life = min ( life , * client -> entry . max_life ) ; if ( server -> entry . max_life ) life = min ( life , * server -> entry . max_life ) ; et . endtime = * et . starttime + life ; } if ( f . renewable_ok && tgt -> flags . renewable && et . renew_till == NULL && et . endtime < * b -> till && tgt -> renew_till != NULL ) { et . flags . renewable = 1 ; ALLOC ( et . renew_till ) ; * et . renew_till = * b -> till ; } if ( et . renew_till ) { time_t renew ; renew = * et . renew_till - * et . starttime ; if ( client && client -> entry . max_renew ) renew = min ( renew , * client -> entry . max_renew ) ; if ( server -> entry . max_renew ) renew = min ( renew , * server -> entry . max_renew ) ; * et . renew_till = * et . starttime + renew ; } if ( et . renew_till ) { * et . renew_till = min ( * et . renew_till , * tgt -> renew_till ) ; * et . starttime = min ( * et . starttime , * et . renew_till ) ; et . endtime = min ( et . endtime , * et . renew_till ) ; } * et . starttime = min ( * et . starttime , et . endtime ) ; if ( * et . starttime == et . endtime ) { ret = KRB5KDC_ERR_NEVER_VALID ; goto out ; } if ( et . renew_till && et . endtime == * et . renew_till ) { free ( et . renew_till ) ; et . renew_till = NULL ; et . flags . renewable = 0 ; } et . flags . pre_authent = tgt -> flags . pre_authent ; et . flags . hw_authent = tgt -> flags . hw_authent ; et . flags . anonymous = tgt -> flags . anonymous ; et . flags . ok_as_delegate = server -> entry . flags . ok_as_delegate ; if ( rspac -> length ) { ret = _kdc_tkt_add_if_relevant_ad ( context , & et , KRB5_AUTHDATA_WIN2K_PAC , rspac ) ; if ( ret ) goto out ; } if ( auth_data ) { unsigned int i = 0 ; if ( et . authorization_data == NULL ) { et . authorization_data = calloc ( 1 , sizeof ( * et . authorization_data ) ) ; if ( et . authorization_data == NULL ) { ret = ENOMEM ; krb5_set_error_message ( context , ret , "malloc:<S2SV_blank>out<S2SV_blank>of<S2SV_blank>memory" ) ; goto out ; } } for ( i = 0 ; i < auth_data -> len ; i ++ ) { ret = add_AuthorizationData ( et . authorization_data , & auth_data -> val [ i ] ) ; if ( ret ) { krb5_set_error_message ( context , ret , "malloc:<S2SV_blank>out<S2SV_blank>of<S2SV_blank>memory" ) ; goto out ; } } ret = find_KRB5SignedPath ( context , et . authorization_data , NULL ) ; if ( ret == 0 ) { if ( et . authorization_data -> len == 1 ) { free_AuthorizationData ( et . authorization_data ) ; free ( et . authorization_data ) ; et . authorization_data = NULL ; } else { AuthorizationData * ad = et . authorization_data ; free_AuthorizationDataElement ( & ad -> val [ ad -> len - 1 ] ) ; ad -> len -- ; } } } ret = krb5_copy_keyblock_contents ( context , sessionkey , & et . key ) ; if ( ret ) goto out ; et . crealm = tgt_name -> realm ; et . cname = tgt_name -> name ; ek . key = et . key ; ek . last_req . val = calloc ( 1 , sizeof ( * ek . last_req . val ) ) ; if ( ek . last_req . val == NULL ) { ret = ENOMEM ; goto out ; } ek . last_req . len = 1 ; ek . nonce = b -> nonce ; ek . flags = et . flags ; ek . authtime = et . authtime ; ek . starttime = et . starttime ; ek . endtime = et . endtime ; ek . renew_till = et . renew_till ; ek . srealm = rep . ticket . realm ; ek . sname = rep . ticket . sname ; _kdc_log_timestamp ( context , config , "TGS-REQ" , et . authtime , et . starttime , et . endtime , et . renew_till ) ; { char * r = get_krbtgt_realm ( & ek . sname ) ; if ( r == NULL || strcmp ( r , ek . srealm ) == 0 ) { ret = _kdc_add_KRB5SignedPath ( context , config , krbtgt , krbtgt_etype , client_principal , NULL , spp , & et ) ; if ( ret ) goto out ; } } if ( enc_pa_data -> len ) { rep . padata = calloc ( 1 , sizeof ( * rep . padata ) ) ; if ( rep . padata == NULL ) { ret = ENOMEM ; goto out ; } ret = copy_METHOD_DATA ( enc_pa_data , rep . padata ) ; if ( ret ) goto out ; } if ( krb5_enctype_valid ( context , serverkey -> keytype ) != 0 && _kdc_is_weak_exception ( server -> entry . principal , serverkey -> keytype ) ) { krb5_enctype_enable ( context , serverkey -> keytype ) ; is_weak = 1 ; } ret = _kdc_encode_reply ( context , config , NULL , 0 , & rep , & et , & ek , serverkey -> keytype , kvno , serverkey , 0 , replykey , rk_is_subkey , e_text , reply ) ; if ( is_weak ) krb5_enctype_disable ( context , serverkey -> keytype ) ; out : free_TGS_REP ( & rep ) ; free_TransitedEncoding ( & et . transited ) ; if ( et . starttime ) free ( et . starttime ) ; if ( et . renew_till ) free ( et . renew_till ) ; if ( et . authorization_data ) { free_AuthorizationData ( et . authorization_data ) ; free ( et . authorization_data ) ; } free_LastReq ( & ek . last_req ) ; memset ( et . key . keyvalue . data , 0 , et . key . keyvalue . length ) ; free_EncryptionKey ( & et . key ) ; return ret ; }
<S2SV_StartBug> static void evtchn_fifo_handle_events ( unsigned cpu ) <S2SV_EndBug> { <S2SV_StartBug> __evtchn_fifo_handle_events ( cpu , false ) ; <S2SV_EndBug> }
static int replace_map_fd_with_map_ptr ( struct verifier_env * env ) { struct bpf_insn * insn = env -> prog -> insnsi ; int insn_cnt = env -> prog -> len ; int i , j ; for ( i = 0 ; i < insn_cnt ; i ++ , insn ++ ) { if ( BPF_CLASS ( insn -> code ) == BPF_LDX && ( BPF_MODE ( insn -> code ) != BPF_MEM || insn -> imm != 0 ) ) { verbose ( "BPF_LDX<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n" ) ; return - EINVAL ; } if ( BPF_CLASS ( insn -> code ) == BPF_STX && ( ( BPF_MODE ( insn -> code ) != BPF_MEM && BPF_MODE ( insn -> code ) != BPF_XADD ) || insn -> imm != 0 ) ) { verbose ( "BPF_STX<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n" ) ; return - EINVAL ; } if ( insn [ 0 ] . code == ( BPF_LD | BPF_IMM | BPF_DW ) ) { struct bpf_map * map ; struct fd f ; if ( i == insn_cnt - 1 || insn [ 1 ] . code != 0 || insn [ 1 ] . dst_reg != 0 || insn [ 1 ] . src_reg != 0 || insn [ 1 ] . off != 0 ) { verbose ( "invalid<S2SV_blank>bpf_ld_imm64<S2SV_blank>insn\\n" ) ; return - EINVAL ; } if ( insn -> src_reg == 0 ) goto next_insn ; if ( insn -> src_reg != BPF_PSEUDO_MAP_FD ) { verbose ( "unrecognized<S2SV_blank>bpf_ld_imm64<S2SV_blank>insn\\n" ) ; return - EINVAL ; } f = fdget ( insn -> imm ) ; map = __bpf_map_get ( f ) ; if ( IS_ERR ( map ) ) { verbose ( "fd<S2SV_blank>%d<S2SV_blank>is<S2SV_blank>not<S2SV_blank>pointing<S2SV_blank>to<S2SV_blank>valid<S2SV_blank>bpf_map\\n" , insn -> imm ) ; <S2SV_StartBug> fdput ( f ) ; <S2SV_EndBug> return PTR_ERR ( map ) ; } insn [ 0 ] . imm = ( u32 ) ( unsigned long ) map ; insn [ 1 ] . imm = ( ( u64 ) ( unsigned long ) map ) >> 32 ; for ( j = 0 ; j < env -> used_map_cnt ; j ++ ) if ( env -> used_maps [ j ] == map ) { fdput ( f ) ; goto next_insn ; } if ( env -> used_map_cnt >= MAX_USED_MAPS ) { fdput ( f ) ; return - E2BIG ; } env -> used_maps [ env -> used_map_cnt ++ ] = map ; bpf_map_inc ( map , false ) ; fdput ( f ) ; next_insn : insn ++ ; i ++ ; } } return 0 ; }
error_t rawSocketProcessIpPacket ( NetInterface * interface , IpPseudoHeader * pseudoHeader , const NetBuffer * buffer , size_t offset , NetRxAncillary * ancillary ) { uint_t i ; size_t length ; Socket * socket ; SocketQueueItem * queueItem ; NetBuffer * p ; length = netBufferGetLength ( buffer ) - offset ; for ( i = 0 ; i < SOCKET_MAX_COUNT ; i ++ ) { socket = socketTable + i ; if ( socket -> type != SOCKET_TYPE_RAW_IP ) continue ; if ( socket -> interface && socket -> interface != interface ) continue ; # if ( IPV4_SUPPORT == ENABLED ) if ( pseudoHeader -> length == sizeof ( Ipv4PseudoHeader ) ) { if ( socket -> protocol != pseudoHeader -> ipv4Data . protocol ) continue ; if ( socket -> localIpAddr . length != 0 ) { if ( socket -> localIpAddr . length != sizeof ( Ipv4Addr ) ) continue ; if ( socket -> localIpAddr . ipv4Addr != pseudoHeader -> ipv4Data . destAddr ) continue ; } if ( socket -> remoteIpAddr . length != 0 ) { if ( socket -> remoteIpAddr . length != sizeof ( Ipv4Addr ) ) continue ; if ( socket -> remoteIpAddr . ipv4Addr != pseudoHeader -> ipv4Data . srcAddr ) continue ; } } else # endif # if ( IPV6_SUPPORT == ENABLED ) if ( pseudoHeader -> length == sizeof ( Ipv6PseudoHeader ) ) { if ( socket -> protocol != pseudoHeader -> ipv6Data . nextHeader ) continue ; if ( socket -> localIpAddr . length != 0 ) { if ( socket -> localIpAddr . length != sizeof ( Ipv6Addr ) ) continue ; if ( ! ipv6CompAddr ( & socket -> localIpAddr . ipv6Addr , & pseudoHeader -> ipv6Data . destAddr ) ) continue ; } if ( socket -> remoteIpAddr . length != 0 ) { if ( socket -> remoteIpAddr . length != sizeof ( Ipv6Addr ) ) continue ; if ( ! ipv6CompAddr ( & socket -> remoteIpAddr . ipv6Addr , & pseudoHeader -> ipv6Data . srcAddr ) ) continue ; } } else # endif { continue ; } break ; } if ( i >= SOCKET_MAX_COUNT ) return ERROR_PROTOCOL_UNREACHABLE ; if ( socket -> receiveQueue == NULL ) { p = netBufferAlloc ( sizeof ( SocketQueueItem ) + length ) ; if ( p != NULL ) { queueItem = netBufferAt ( p , 0 ) ; queueItem -> buffer = p ; socket -> receiveQueue = queueItem ; } else { queueItem = NULL ; } } else { queueItem = socket -> receiveQueue ; for ( i = 1 ; queueItem -> next ; i ++ ) { queueItem = queueItem -> next ; } if ( i >= RAW_SOCKET_RX_QUEUE_SIZE ) { MIB2_INC_COUNTER32 ( ifGroup . ifTable [ interface -> index ] . ifInDiscards , 1 ) ; IF_MIB_INC_COUNTER32 ( ifTable [ interface -> index ] . ifInDiscards , 1 ) ; return ERROR_RECEIVE_QUEUE_FULL ; } p = netBufferAlloc ( sizeof ( SocketQueueItem ) + length ) ; if ( p != NULL ) { queueItem -> next = netBufferAt ( p , 0 ) ; queueItem = queueItem -> next ; queueItem -> buffer = p ; } else { queueItem = NULL ; } } if ( queueItem == NULL ) { MIB2_INC_COUNTER32 ( ifGroup . ifTable [ interface -> index ] . ifInDiscards , 1 ) ; IF_MIB_INC_COUNTER32 ( ifTable [ interface -> index ] . ifInDiscards , 1 ) ; return ERROR_OUT_OF_MEMORY ; } queueItem -> next = NULL ; <S2SV_StartBug> queueItem -> srcPort = 0 ; <S2SV_EndBug> # if ( IPV4_SUPPORT == ENABLED ) if ( pseudoHeader -> length == sizeof ( Ipv4PseudoHeader ) ) { queueItem -> srcIpAddr . length = sizeof ( Ipv4Addr ) ; queueItem -> srcIpAddr . ipv4Addr = pseudoHeader -> ipv4Data . srcAddr ; queueItem -> destIpAddr . length = sizeof ( Ipv4Addr ) ; queueItem -> destIpAddr . ipv4Addr = pseudoHeader -> ipv4Data . destAddr ; } # endif # if ( IPV6_SUPPORT == ENABLED ) if ( pseudoHeader -> length == sizeof ( Ipv6PseudoHeader ) ) { queueItem -> srcIpAddr . length = sizeof ( Ipv6Addr ) ; queueItem -> srcIpAddr . ipv6Addr = pseudoHeader -> ipv6Data . srcAddr ; queueItem -> destIpAddr . length = sizeof ( Ipv6Addr ) ; queueItem -> destIpAddr . ipv6Addr = pseudoHeader -> ipv6Data . destAddr ; } # endif queueItem -> offset = sizeof ( SocketQueueItem ) ; netBufferCopy ( queueItem -> buffer , queueItem -> offset , buffer , offset , length ) ; queueItem -> ancillary = * ancillary ; rawSocketUpdateEvents ( socket ) ; return NO_ERROR ; }
<S2SV_StartBug> static void encode_sb ( VP9_COMP * cpi , const TileInfo * const tile , <S2SV_EndBug> TOKENEXTRA * * tp , int mi_row , int mi_col , <S2SV_StartBug> int output_enabled , BLOCK_SIZE bsize ) { <S2SV_EndBug> VP9_COMMON * const cm = & cpi -> common ; <S2SV_StartBug> MACROBLOCK * const x = & cpi -> mb ; <S2SV_EndBug> MACROBLOCKD * const xd = & x -> e_mbd ; <S2SV_StartBug> const int bsl = b_width_log2 ( bsize ) , hbs = ( 1 << bsl ) / 4 ; <S2SV_EndBug> int ctx ; PARTITION_TYPE partition ; <S2SV_StartBug> BLOCK_SIZE subsize ; <S2SV_EndBug> if ( mi_row >= cm -> mi_rows || mi_col >= cm -> mi_cols ) return ; if ( bsize >= BLOCK_8X8 ) { ctx = partition_plane_context ( xd , mi_row , mi_col , bsize ) ; <S2SV_StartBug> subsize = * get_sb_partitioning ( x , bsize ) ; <S2SV_EndBug> } else { ctx = 0 ; subsize = BLOCK_4X4 ; } <S2SV_StartBug> partition = partition_lookup [ bsl ] [ subsize ] ; <S2SV_EndBug> switch ( partition ) { case PARTITION_NONE : <S2SV_StartBug> if ( output_enabled && bsize >= BLOCK_8X8 ) <S2SV_EndBug> cm -> counts . partition [ ctx ] [ PARTITION_NONE ] ++ ; <S2SV_StartBug> encode_b ( cpi , tile , tp , mi_row , mi_col , output_enabled , subsize ) ; <S2SV_EndBug> break ; case PARTITION_VERT : <S2SV_StartBug> if ( output_enabled ) <S2SV_EndBug> cm -> counts . partition [ ctx ] [ PARTITION_VERT ] ++ ; * get_sb_index ( x , subsize ) = 0 ; encode_b ( cpi , tile , tp , mi_row , mi_col , output_enabled , subsize ) ; <S2SV_StartBug> if ( mi_col + hbs < cm -> mi_cols ) { <S2SV_EndBug> * get_sb_index ( x , subsize ) = 1 ; encode_b ( cpi , tile , tp , mi_row , mi_col + hbs , output_enabled , subsize ) ; } break ; case PARTITION_HORZ : <S2SV_StartBug> if ( output_enabled ) <S2SV_EndBug> cm -> counts . partition [ ctx ] [ PARTITION_HORZ ] ++ ; * get_sb_index ( x , subsize ) = 0 ; encode_b ( cpi , tile , tp , mi_row , mi_col , output_enabled , subsize ) ; <S2SV_StartBug> if ( mi_row + hbs < cm -> mi_rows ) { <S2SV_EndBug> * get_sb_index ( x , subsize ) = 1 ; encode_b ( cpi , tile , tp , mi_row + hbs , mi_col , output_enabled , subsize ) ; } break ; case PARTITION_SPLIT : <S2SV_StartBug> subsize = get_subsize ( bsize , PARTITION_SPLIT ) ; <S2SV_EndBug> if ( output_enabled ) cm -> counts . partition [ ctx ] [ PARTITION_SPLIT ] ++ ; * get_sb_index ( x , subsize ) = 0 ; <S2SV_StartBug> encode_sb ( cpi , tile , tp , mi_row , mi_col , output_enabled , subsize ) ; <S2SV_EndBug> * get_sb_index ( x , subsize ) = 1 ; <S2SV_StartBug> encode_sb ( cpi , tile , tp , mi_row , mi_col + hbs , output_enabled , subsize ) ; <S2SV_EndBug> * get_sb_index ( x , subsize ) = 2 ; <S2SV_StartBug> encode_sb ( cpi , tile , tp , mi_row + hbs , mi_col , output_enabled , subsize ) ; <S2SV_EndBug> * get_sb_index ( x , subsize ) = 3 ; encode_sb ( cpi , tile , tp , mi_row + hbs , mi_col + hbs , output_enabled , subsize ) ; break ; default : <S2SV_StartBug> assert ( "Invalid<S2SV_blank>partition<S2SV_blank>type." ) ; <S2SV_EndBug> } if ( partition != PARTITION_SPLIT || bsize == BLOCK_8X8 ) update_partition_context ( xd , mi_row , mi_col , subsize , bsize ) ; }
static ssize_t oz_cdev_write ( struct file * filp , const char __user * buf , size_t count , loff_t * fpos ) { struct oz_pd * pd ; struct oz_elt_buf * eb ; struct oz_elt_info * ei ; struct oz_elt * elt ; struct oz_app_hdr * app_hdr ; struct oz_serial_ctx * ctx ; <S2SV_StartBug> spin_lock_bh ( & g_cdev . lock ) ; <S2SV_EndBug> pd = g_cdev . active_pd ; if ( pd ) oz_pd_get ( pd ) ; spin_unlock_bh ( & g_cdev . lock ) ; if ( pd == NULL ) return - ENXIO ; if ( ! ( pd -> state & OZ_PD_S_CONNECTED ) ) return - EAGAIN ; eb = & pd -> elt_buff ; ei = oz_elt_info_alloc ( eb ) ; if ( ei == NULL ) { count = 0 ; goto out ; } elt = ( struct oz_elt * ) ei -> data ; app_hdr = ( struct oz_app_hdr * ) ( elt + 1 ) ; elt -> length = sizeof ( struct oz_app_hdr ) + count ; elt -> type = OZ_ELT_APP_DATA ; ei -> app_id = OZ_APPID_SERIAL ; ei -> length = elt -> length + sizeof ( struct oz_elt ) ; app_hdr -> app_id = OZ_APPID_SERIAL ; if ( copy_from_user ( app_hdr + 1 , buf , count ) ) goto out ; spin_lock_bh ( & pd -> app_lock [ OZ_APPID_USB - 1 ] ) ; ctx = ( struct oz_serial_ctx * ) pd -> app_ctx [ OZ_APPID_SERIAL - 1 ] ; if ( ctx ) { app_hdr -> elt_seq_num = ctx -> tx_seq_num ++ ; if ( ctx -> tx_seq_num == 0 ) ctx -> tx_seq_num = 1 ; spin_lock ( & eb -> lock ) ; if ( oz_queue_elt_info ( eb , 0 , 0 , ei ) == 0 ) ei = NULL ; spin_unlock ( & eb -> lock ) ; } spin_unlock_bh ( & pd -> app_lock [ OZ_APPID_USB - 1 ] ) ; out : if ( ei ) { count = 0 ; spin_lock_bh ( & eb -> lock ) ; oz_elt_info_free ( eb , ei ) ; spin_unlock_bh ( & eb -> lock ) ; } oz_pd_put ( pd ) ; return count ; }
static int sctp_init_sock ( struct sock * sk ) { struct net * net = sock_net ( sk ) ; struct sctp_sock * sp ; pr_debug ( "%s:<S2SV_blank>sk:%p\\n" , __func__ , sk ) ; sp = sctp_sk ( sk ) ; switch ( sk -> sk_type ) { case SOCK_SEQPACKET : sp -> type = SCTP_SOCKET_UDP ; break ; case SOCK_STREAM : sp -> type = SCTP_SOCKET_TCP ; break ; default : return - ESOCKTNOSUPPORT ; } sp -> default_stream = 0 ; sp -> default_ppid = 0 ; sp -> default_flags = 0 ; sp -> default_context = 0 ; sp -> default_timetolive = 0 ; sp -> default_rcv_context = 0 ; sp -> max_burst = net -> sctp . max_burst ; sp -> sctp_hmac_alg = net -> sctp . sctp_hmac_alg ; sp -> initmsg . sinit_num_ostreams = sctp_max_outstreams ; sp -> initmsg . sinit_max_instreams = sctp_max_instreams ; sp -> initmsg . sinit_max_attempts = net -> sctp . max_retrans_init ; sp -> initmsg . sinit_max_init_timeo = net -> sctp . rto_max ; sp -> rtoinfo . srto_initial = net -> sctp . rto_initial ; sp -> rtoinfo . srto_max = net -> sctp . rto_max ; sp -> rtoinfo . srto_min = net -> sctp . rto_min ; sp -> assocparams . sasoc_asocmaxrxt = net -> sctp . max_retrans_association ; sp -> assocparams . sasoc_number_peer_destinations = 0 ; sp -> assocparams . sasoc_peer_rwnd = 0 ; sp -> assocparams . sasoc_local_rwnd = 0 ; sp -> assocparams . sasoc_cookie_life = net -> sctp . valid_cookie_life ; memset ( & sp -> subscribe , 0 , sizeof ( struct sctp_event_subscribe ) ) ; sp -> hbinterval = net -> sctp . hb_interval ; sp -> pathmaxrxt = net -> sctp . max_retrans_path ; sp -> pathmtu = 0 ; sp -> sackdelay = net -> sctp . sack_timeout ; sp -> sackfreq = 2 ; sp -> param_flags = SPP_HB_ENABLE | SPP_PMTUD_ENABLE | SPP_SACKDELAY_ENABLE ; sp -> disable_fragments = 0 ; sp -> nodelay = 0 ; sp -> recvrcvinfo = 0 ; sp -> recvnxtinfo = 0 ; sp -> v4mapped = 1 ; sp -> autoclose = 0 ; sp -> user_frag = 0 ; sp -> adaptation_ind = 0 ; sp -> pf = sctp_get_pf_specific ( sk -> sk_family ) ; atomic_set ( & sp -> pd_mode , 0 ) ; skb_queue_head_init ( & sp -> pd_lobby ) ; sp -> frag_interleave = 0 ; sp -> ep = sctp_endpoint_new ( sk , GFP_KERNEL ) ; if ( ! sp -> ep ) return - ENOMEM ; sp -> hmac = NULL ; sk -> sk_destruct = sctp_destruct_sock ; SCTP_DBG_OBJCNT_INC ( sock ) ; local_bh_disable ( ) ; percpu_counter_inc ( & sctp_sockets_allocated ) ; sock_prot_inuse_add ( net , sk -> sk_prot , 1 ) ; if ( net -> sctp . default_auto_asconf ) { <S2SV_StartBug> list_add_tail ( & sp -> auto_asconf_list , <S2SV_EndBug> & net -> sctp . auto_asconf_splist ) ; <S2SV_StartBug> sp -> do_auto_asconf = 1 ; <S2SV_EndBug> <S2SV_StartBug> } else <S2SV_EndBug> <S2SV_StartBug> sp -> do_auto_asconf = 0 ; <S2SV_EndBug> local_bh_enable ( ) ; return 0 ; }
void put_filp ( struct file * file ) { if ( atomic_long_dec_and_test ( & file -> f_count ) ) { security_file_free ( file ) ; <S2SV_StartBug> file_sb_list_del ( file ) ; <S2SV_EndBug> file_free ( file ) ; } }
cJSON * cJSON_CreateString ( const char * string ) { cJSON * item = cJSON_New_Item ( ) ; if ( item ) { item -> type = cJSON_String ; item -> valuestring = cJSON_strdup ( string ) ; <S2SV_StartBug> } <S2SV_EndBug> return item ; }
int effect_command ( effect_handle_t self , uint32_t cmdCode , uint32_t cmdSize , void * pCmdData , uint32_t * replySize , void * pReplyData ) { effect_context_t * context = ( effect_context_t * ) self ; int retsize ; int status = 0 ; pthread_mutex_lock ( & lock ) ; if ( ! effect_exists ( context ) ) { status = - ENOSYS ; goto exit ; } if ( context == NULL || context -> state == EFFECT_STATE_UNINITIALIZED ) { status = - ENOSYS ; goto exit ; } switch ( cmdCode ) { case EFFECT_CMD_INIT : if ( pReplyData == NULL || * replySize != sizeof ( int ) ) { status = - EINVAL ; goto exit ; } if ( context -> ops . init ) * ( int * ) pReplyData = context -> ops . init ( context ) ; else * ( int * ) pReplyData = 0 ; break ; case EFFECT_CMD_SET_CONFIG : if ( pCmdData == NULL || cmdSize != sizeof ( effect_config_t ) || pReplyData == NULL || * replySize != sizeof ( int ) ) { status = - EINVAL ; goto exit ; } * ( int * ) pReplyData = set_config ( context , ( effect_config_t * ) pCmdData ) ; break ; case EFFECT_CMD_GET_CONFIG : if ( pReplyData == NULL || * replySize != sizeof ( effect_config_t ) ) { status = - EINVAL ; goto exit ; } if ( ! context -> offload_enabled ) { status = - EINVAL ; goto exit ; } get_config ( context , ( effect_config_t * ) pReplyData ) ; break ; case EFFECT_CMD_RESET : if ( context -> ops . reset ) context -> ops . reset ( context ) ; break ; case EFFECT_CMD_ENABLE : if ( pReplyData == NULL || * replySize != sizeof ( int ) ) { status = - EINVAL ; goto exit ; } if ( context -> state != EFFECT_STATE_INITIALIZED ) { status = - ENOSYS ; goto exit ; } context -> state = EFFECT_STATE_ACTIVE ; if ( context -> ops . enable ) context -> ops . enable ( context ) ; ALOGV ( "%s<S2SV_blank>EFFECT_CMD_ENABLE" , __func__ ) ; * ( int * ) pReplyData = 0 ; break ; case EFFECT_CMD_DISABLE : if ( pReplyData == NULL || * replySize != sizeof ( int ) ) { status = - EINVAL ; goto exit ; } if ( context -> state != EFFECT_STATE_ACTIVE ) { status = - ENOSYS ; goto exit ; } context -> state = EFFECT_STATE_INITIALIZED ; if ( context -> ops . disable ) context -> ops . disable ( context ) ; ALOGV ( "%s<S2SV_blank>EFFECT_CMD_DISABLE" , __func__ ) ; * ( int * ) pReplyData = 0 ; break ; case EFFECT_CMD_GET_PARAM : { if ( pCmdData == NULL || cmdSize < ( int ) ( sizeof ( effect_param_t ) + sizeof ( uint32_t ) ) || pReplyData == NULL || * replySize < ( int ) ( sizeof ( effect_param_t ) + sizeof ( uint32_t ) + <S2SV_StartBug> sizeof ( uint16_t ) ) ) { <S2SV_EndBug> status = - EINVAL ; ALOGV ( "EFFECT_CMD_GET_PARAM<S2SV_blank>invalid<S2SV_blank>command<S2SV_blank>cmdSize<S2SV_blank>%d<S2SV_blank>*replySize<S2SV_blank>%d" , cmdSize , * replySize ) ; goto exit ; } if ( ! context -> offload_enabled ) { status = - EINVAL ; goto exit ; } effect_param_t * q = ( effect_param_t * ) pCmdData ; memcpy ( pReplyData , pCmdData , sizeof ( effect_param_t ) + q -> psize ) ; effect_param_t * p = ( effect_param_t * ) pReplyData ; if ( context -> ops . get_parameter ) context -> ops . get_parameter ( context , p , replySize ) ; } break ; case EFFECT_CMD_SET_PARAM : { if ( pCmdData == NULL || cmdSize < ( int ) ( sizeof ( effect_param_t ) + sizeof ( uint32_t ) + sizeof ( uint16_t ) ) || pReplyData == NULL || * replySize != sizeof ( int32_t ) ) { status = - EINVAL ; ALOGV ( "EFFECT_CMD_SET_PARAM<S2SV_blank>invalid<S2SV_blank>command<S2SV_blank>cmdSize<S2SV_blank>%d<S2SV_blank>*replySize<S2SV_blank>%d" , cmdSize , * replySize ) ; goto exit ; } * ( int32_t * ) pReplyData = 0 ; effect_param_t * p = ( effect_param_t * ) pCmdData ; if ( context -> ops . set_parameter ) * ( int32_t * ) pReplyData = context -> ops . set_parameter ( context , p , * replySize ) ; } break ; case EFFECT_CMD_SET_DEVICE : { uint32_t device ; ALOGV ( "\\t<S2SV_blank>EFFECT_CMD_SET_DEVICE<S2SV_blank>start" ) ; if ( pCmdData == NULL || cmdSize < sizeof ( uint32_t ) ) { status = - EINVAL ; ALOGV ( "EFFECT_CMD_SET_DEVICE<S2SV_blank>invalid<S2SV_blank>command<S2SV_blank>cmdSize<S2SV_blank>%d" , cmdSize ) ; goto exit ; } device = * ( uint32_t * ) pCmdData ; if ( context -> ops . set_device ) context -> ops . set_device ( context , device ) ; } break ; case EFFECT_CMD_SET_VOLUME : case EFFECT_CMD_SET_AUDIO_MODE : break ; case EFFECT_CMD_OFFLOAD : { output_context_t * out_ctxt ; if ( cmdSize != sizeof ( effect_offload_param_t ) || pCmdData == NULL || pReplyData == NULL || * replySize != sizeof ( int ) ) { ALOGV ( "%s<S2SV_blank>EFFECT_CMD_OFFLOAD<S2SV_blank>bad<S2SV_blank>format" , __func__ ) ; status = - EINVAL ; break ; } effect_offload_param_t * offload_param = ( effect_offload_param_t * ) pCmdData ; ALOGV ( "%s<S2SV_blank>EFFECT_CMD_OFFLOAD<S2SV_blank>offload<S2SV_blank>%d<S2SV_blank>output<S2SV_blank>%d" , __func__ , offload_param -> isOffload , offload_param -> ioHandle ) ; * ( int * ) pReplyData = 0 ; context -> offload_enabled = offload_param -> isOffload ; if ( context -> out_handle == offload_param -> ioHandle ) break ; out_ctxt = get_output ( context -> out_handle ) ; if ( out_ctxt != NULL ) remove_effect_from_output ( out_ctxt , context ) ; context -> out_handle = offload_param -> ioHandle ; out_ctxt = get_output ( context -> out_handle ) ; if ( out_ctxt != NULL ) add_effect_to_output ( out_ctxt , context ) ; } break ; default : if ( cmdCode >= EFFECT_CMD_FIRST_PROPRIETARY && context -> ops . command ) status = context -> ops . command ( context , cmdCode , cmdSize , pCmdData , replySize , pReplyData ) ; else { ALOGW ( "%s<S2SV_blank>invalid<S2SV_blank>command<S2SV_blank>%d" , __func__ , cmdCode ) ; status = - EINVAL ; } break ; } exit : pthread_mutex_unlock ( & lock ) ; return status ; }
int install_process_keyring_to_cred ( struct cred * new ) { struct key * keyring ; if ( new -> process_keyring ) <S2SV_StartBug> return - EEXIST ; <S2SV_EndBug> keyring = keyring_alloc ( "_pid" , new -> uid , new -> gid , new , KEY_POS_ALL | KEY_USR_VIEW , KEY_ALLOC_QUOTA_OVERRUN , NULL , NULL ) ; if ( IS_ERR ( keyring ) ) return PTR_ERR ( keyring ) ; new -> process_keyring = keyring ; return 0 ; }
void jshGetPinString ( char * result , Pin pin ) { result [ 0 ] = 0 ; # ifdef PIN_NAMES_DIRECT if ( jshIsPinValid ( pin ) ) { result [ 0 ] = ( char ) ( 'A' + ( pinInfo [ pin ] . port & JSH_PORT_MASK ) - JSH_PORTA ) ; itostr ( pinInfo [ pin ] . pin - JSH_PIN0 , & result [ 1 ] , 10 ) ; # else if ( false ) { # if JSH_PORTA_OFFSET != - 1 } else if ( # if JSH_PORTA_OFFSET != 0 pin >= JSH_PORTA_OFFSET && # endif pin < JSH_PORTA_OFFSET + JSH_PORTA_COUNT ) { result [ 0 ] = 'A' ; itostr ( pin - JSH_PORTA_OFFSET , & result [ 1 ] , 10 ) ; # endif # if JSH_PORTB_OFFSET != - 1 } else if ( pin >= JSH_PORTB_OFFSET && pin < JSH_PORTB_OFFSET + JSH_PORTB_COUNT ) { result [ 0 ] = 'B' ; itostr ( pin - JSH_PORTB_OFFSET , & result [ 1 ] , 10 ) ; # endif # if JSH_PORTC_OFFSET != - 1 } else if ( pin >= JSH_PORTC_OFFSET && pin < JSH_PORTC_OFFSET + JSH_PORTC_COUNT ) { result [ 0 ] = 'C' ; itostr ( pin - JSH_PORTC_OFFSET , & result [ 1 ] , 10 ) ; # endif # if JSH_PORTD_OFFSET != - 1 } else if ( # if JSH_PORTD_OFFSET != 0 pin >= JSH_PORTD_OFFSET && # endif pin < JSH_PORTD_OFFSET + JSH_PORTD_COUNT ) { result [ 0 ] = 'D' ; itostr ( pin - JSH_PORTD_OFFSET , & result [ 1 ] , 10 ) ; # endif # if JSH_PORTE_OFFSET != - 1 } else if ( pin >= JSH_PORTE_OFFSET && pin < JSH_PORTE_OFFSET + JSH_PORTE_COUNT ) { result [ 0 ] = 'E' ; itostr ( pin - JSH_PORTE_OFFSET , & result [ 1 ] , 10 ) ; # endif # if JSH_PORTF_OFFSET != - 1 } else if ( pin >= JSH_PORTF_OFFSET && pin < JSH_PORTF_OFFSET + JSH_PORTF_COUNT ) { result [ 0 ] = 'F' ; itostr ( pin - JSH_PORTF_OFFSET , & result [ 1 ] , 10 ) ; # endif # if JSH_PORTG_OFFSET != - 1 } else if ( pin >= JSH_PORTG_OFFSET && pin < JSH_PORTG_OFFSET + JSH_PORTG_COUNT ) { result [ 0 ] = 'G' ; itostr ( pin - JSH_PORTG_OFFSET , & result [ 1 ] , 10 ) ; # endif # if JSH_PORTH_OFFSET != - 1 } else if ( pin >= JSH_PORTH_OFFSET && pin < JSH_PORTH_OFFSET + JSH_PORTH_COUNT ) { result [ 0 ] = 'H' ; itostr ( pin - JSH_PORTH_OFFSET , & result [ 1 ] , 10 ) ; # endif # if JSH_PORTI_OFFSET != - 1 } else if ( pin >= JSH_PORTI_OFFSET && pin < JSH_PORTI_OFFSET + JSH_PORTI_COUNT ) { result [ 0 ] = 'I' ; itostr ( pin - JSH_PORTI_OFFSET , & result [ 1 ] , 10 ) ; # endif # if JSH_PORTV_OFFSET != - 1 } else if ( pin >= JSH_PORTV_OFFSET && pin < JSH_PORTV_OFFSET + JSH_PORTV_COUNT ) { result [ 0 ] = 'V' ; itostr ( pin - JSH_PORTV_OFFSET , & result [ 1 ] , 10 ) ; # endif # endif } else { <S2SV_StartBug> strncpy ( result , "undefined" , 10 ) ; <S2SV_EndBug> } }
ExprDef * ExprAppendMultiKeysymList ( ExprDef * expr , ExprDef * append ) { unsigned nSyms = darray_size ( expr -> keysym_list . syms ) ; unsigned numEntries = darray_size ( append -> keysym_list . syms ) ; darray_append ( expr -> keysym_list . symsMapIndex , nSyms ) ; darray_append ( expr -> keysym_list . symsNumEntries , numEntries ) ; darray_concat ( expr -> keysym_list . syms , append -> keysym_list . syms ) ; <S2SV_StartBug> FreeStmt ( ( ParseCommon * ) & append ) ; <S2SV_EndBug> return expr ; }
int hugetlb_mcopy_atomic_pte ( struct mm_struct * dst_mm , pte_t * dst_pte , struct vm_area_struct * dst_vma , unsigned long dst_addr , unsigned long src_addr , struct page * * pagep ) { int vm_shared = dst_vma -> vm_flags & VM_SHARED ; struct hstate * h = hstate_vma ( dst_vma ) ; pte_t _dst_pte ; spinlock_t * ptl ; int ret ; struct page * page ; if ( ! * pagep ) { ret = - ENOMEM ; page = alloc_huge_page ( dst_vma , dst_addr , 0 ) ; if ( IS_ERR ( page ) ) goto out ; ret = copy_huge_page_from_user ( page , ( const void __user * ) src_addr , pages_per_huge_page ( h ) , false ) ; if ( unlikely ( ret ) ) { ret = - EFAULT ; * pagep = page ; goto out ; } } else { page = * pagep ; * pagep = NULL ; } __SetPageUptodate ( page ) ; set_page_huge_active ( page ) ; if ( vm_shared ) { struct address_space * mapping = dst_vma -> vm_file -> f_mapping ; pgoff_t idx = vma_hugecache_offset ( h , dst_vma , dst_addr ) ; ret = huge_add_to_page_cache ( page , mapping , idx ) ; if ( ret ) goto out_release_nounlock ; } ptl = huge_pte_lockptr ( h , dst_mm , dst_pte ) ; spin_lock ( ptl ) ; ret = - EEXIST ; if ( ! huge_pte_none ( huge_ptep_get ( dst_pte ) ) ) goto out_release_unlock ; if ( vm_shared ) { page_dup_rmap ( page , true ) ; } else { ClearPagePrivate ( page ) ; hugepage_add_new_anon_rmap ( page , dst_vma , dst_addr ) ; } _dst_pte = make_huge_pte ( dst_vma , page , dst_vma -> vm_flags & VM_WRITE ) ; if ( dst_vma -> vm_flags & VM_WRITE ) _dst_pte = huge_pte_mkdirty ( _dst_pte ) ; _dst_pte = pte_mkyoung ( _dst_pte ) ; set_huge_pte_at ( dst_mm , dst_addr , dst_pte , _dst_pte ) ; ( void ) huge_ptep_set_access_flags ( dst_vma , dst_addr , dst_pte , _dst_pte , dst_vma -> vm_flags & VM_WRITE ) ; hugetlb_count_add ( pages_per_huge_page ( h ) , dst_mm ) ; update_mmu_cache ( dst_vma , dst_addr , dst_pte ) ; spin_unlock ( ptl ) ; if ( vm_shared ) unlock_page ( page ) ; ret = 0 ; out : return ret ; out_release_unlock : spin_unlock ( ptl ) ; <S2SV_StartBug> out_release_nounlock : <S2SV_EndBug> if ( vm_shared ) unlock_page ( page ) ; put_page ( page ) ; goto out ; }
static void dtls1_clear_queues ( SSL * s ) { pitem * item = NULL ; hm_fragment * frag = NULL ; DTLS1_RECORD_DATA * rdata ; while ( ( item = pqueue_pop ( s -> d1 -> unprocessed_rcds . q ) ) != NULL ) { rdata = ( DTLS1_RECORD_DATA * ) item -> data ; if ( rdata -> rbuf . buf ) { OPENSSL_free ( rdata -> rbuf . buf ) ; } OPENSSL_free ( item -> data ) ; pitem_free ( item ) ; } while ( ( item = pqueue_pop ( s -> d1 -> processed_rcds . q ) ) != NULL ) { rdata = ( DTLS1_RECORD_DATA * ) item -> data ; if ( rdata -> rbuf . buf ) { OPENSSL_free ( rdata -> rbuf . buf ) ; } OPENSSL_free ( item -> data ) ; pitem_free ( item ) ; } while ( ( item = pqueue_pop ( s -> d1 -> buffered_messages ) ) != NULL ) { frag = ( hm_fragment * ) item -> data ; OPENSSL_free ( frag -> fragment ) ; OPENSSL_free ( frag ) ; pitem_free ( item ) ; } while ( ( item = pqueue_pop ( s -> d1 -> sent_messages ) ) != NULL ) { frag = ( hm_fragment * ) item -> data ; OPENSSL_free ( frag -> fragment ) ; OPENSSL_free ( frag ) ; pitem_free ( item ) ; } while ( ( item = pqueue_pop ( s -> d1 -> buffered_app_data . q ) ) != NULL ) { <S2SV_StartBug> frag = ( hm_fragment * ) item -> data ; <S2SV_EndBug> OPENSSL_free ( frag -> fragment ) ; OPENSSL_free ( frag ) ; pitem_free ( item ) ; } }
int server_partial_file_request ( struct httpd * env , struct client * clt , char * path , struct stat * st , char * range_str ) { struct server_config * srv_conf = clt -> clt_srv_conf ; struct http_descriptor * resp = clt -> clt_descresp ; struct http_descriptor * desc = clt -> clt_descreq ; struct media_type * media , multipart_media ; <S2SV_StartBug> struct range * range ; <S2SV_EndBug> struct evbuffer * evb = NULL ; <S2SV_StartBug> size_t content_length ; <S2SV_EndBug> <S2SV_StartBug> int code = 500 , fd = - 1 , i , nranges , ret ; <S2SV_EndBug> uint32_t boundary ; char content_range [ 64 ] ; const char * errstr = NULL ; if ( desc -> http_method != HTTP_METHOD_GET ) return server_file_request ( env , clt , path , st ) ; <S2SV_StartBug> if ( ( range = parse_range ( range_str , st -> st_size , & nranges ) ) == NULL ) { <S2SV_EndBug> code = 416 ; ( void ) snprintf ( content_range , sizeof ( content_range ) , "bytes<S2SV_blank>*/%lld" , st -> st_size ) ; errstr = content_range ; goto abort ; } if ( ( fd = open ( path , O_RDONLY ) ) == - 1 ) goto abort ; media = media_find_config ( env , srv_conf , path ) ; <S2SV_StartBug> if ( ( evb = evbuffer_new ( ) ) == NULL ) { <S2SV_EndBug> errstr = "failed<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>file<S2SV_blank>buffer" ; goto abort ; } if ( nranges == 1 ) { <S2SV_StartBug> ( void ) snprintf ( content_range , sizeof ( content_range ) , <S2SV_EndBug> "bytes<S2SV_blank>%lld-%lld/%lld" , range -> start , range -> end , st -> st_size ) ; if ( kv_add ( & resp -> http_headers , "Content-Range" , content_range ) == NULL ) goto abort ; <S2SV_StartBug> content_length = range -> end - range -> start + 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( buffer_add_range ( fd , evb , range ) == 0 ) <S2SV_EndBug> goto abort ; } else { <S2SV_StartBug> content_length = 0 ; <S2SV_EndBug> boundary = arc4random ( ) ; while ( nranges -- ) { if ( ( i = evbuffer_add_printf ( evb , "\\r\\n--%ud\\r\\n" , boundary ) ) == - 1 ) goto abort ; <S2SV_StartBug> content_length += i ; <S2SV_EndBug> if ( ( i = evbuffer_add_printf ( evb , "Content-Type:<S2SV_blank>%s/%s\\r\\n" , media -> media_type , media -> media_subtype ) ) == - 1 ) goto abort ; content_length += i ; if ( ( i = evbuffer_add_printf ( evb , "Content-Range:<S2SV_blank>bytes<S2SV_blank>%lld-%lld/%lld\\r\\n\\r\\n" , range -> start , range -> end , st -> st_size ) ) == - 1 ) goto abort ; content_length += i ; if ( buffer_add_range ( fd , evb , range ) == 0 ) goto abort ; content_length += range -> end - range -> start + 1 ; <S2SV_StartBug> range ++ ; <S2SV_EndBug> } <S2SV_StartBug> if ( ( i = evbuffer_add_printf ( evb , "\\r\\n--%ud--\\r\\n" , <S2SV_EndBug> boundary ) ) == - 1 ) goto abort ; <S2SV_StartBug> content_length += i ; <S2SV_EndBug> ( void ) strlcpy ( multipart_media . media_type , "multipart" , sizeof ( multipart_media . media_type ) ) ; ( void ) snprintf ( multipart_media . media_subtype , sizeof ( multipart_media . media_subtype ) , <S2SV_StartBug> "byteranges;<S2SV_blank>boundary=%ud" , boundary ) ; <S2SV_EndBug> media = & multipart_media ; } <S2SV_StartBug> close ( fd ) ; <S2SV_EndBug> fd = - 1 ; ret = server_response_http ( clt , 206 , media , content_length , MINIMUM ( time ( NULL ) , st -> st_mtim . tv_sec ) ) ; switch ( ret ) { case - 1 : goto fail ; case 0 : <S2SV_StartBug> goto done ; <S2SV_EndBug> default : break ; } <S2SV_StartBug> if ( server_bufferevent_write_buffer ( clt , evb ) == - 1 ) <S2SV_EndBug> goto fail ; <S2SV_StartBug> bufferevent_enable ( clt -> clt_bev , EV_READ | EV_WRITE ) ; <S2SV_EndBug> <S2SV_StartBug> if ( clt -> clt_persist ) <S2SV_EndBug> clt -> clt_toread = TOREAD_HTTP_HEADER ; else clt -> clt_toread = TOREAD_HTTP_NONE ; clt -> clt_done = 0 ; done : evbuffer_free ( evb ) ; server_reset_http ( clt ) ; return ( 0 ) ; fail : bufferevent_disable ( clt -> clt_bev , EV_READ | EV_WRITE ) ; bufferevent_free ( clt -> clt_bev ) ; clt -> clt_bev = NULL ; abort : <S2SV_StartBug> if ( evb != NULL ) <S2SV_EndBug> evbuffer_free ( evb ) ; if ( fd != - 1 ) close ( fd ) ; if ( errstr == NULL ) errstr = strerror ( errno ) ; server_abort_http ( clt , code , errstr ) ; return ( - 1 ) ; }
int ipmi_si_port_setup ( struct si_sm_io * io ) { unsigned int addr = io -> addr_data ; int idx ; if ( ! addr ) return - ENODEV ; <S2SV_StartBug> io -> io_cleanup = port_cleanup ; <S2SV_EndBug> switch ( io -> regsize ) { case 1 : io -> inputb = port_inb ; io -> outputb = port_outb ; break ; case 2 : io -> inputb = port_inw ; io -> outputb = port_outw ; break ; case 4 : io -> inputb = port_inl ; io -> outputb = port_outl ; break ; default : dev_warn ( io -> dev , "Invalid<S2SV_blank>register<S2SV_blank>size:<S2SV_blank>%d\\n" , io -> regsize ) ; return - EINVAL ; } for ( idx = 0 ; idx < io -> io_size ; idx ++ ) { if ( request_region ( addr + idx * io -> regspacing , io -> regsize , DEVICE_NAME ) == NULL ) { while ( idx -- ) release_region ( addr + idx * io -> regspacing , io -> regsize ) ; return - EIO ; } } <S2SV_StartBug> return 0 ; <S2SV_EndBug> }
static int oidc_handle_session_management_iframe_rp ( request_rec * r , oidc_cfg * c , oidc_session_t * session , const char * client_id , const char * check_session_iframe ) { oidc_debug ( r , "enter" ) ; const char * java_script = "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><script<S2SV_blank>type=\\"text/javascript\\">\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>var<S2SV_blank>targetOrigin<S2SV_blank><S2SV_blank>=<S2SV_blank>\'%s\';\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>var<S2SV_blank>message<S2SV_blank>=<S2SV_blank>\'%s\'<S2SV_blank>+<S2SV_blank>\'<S2SV_blank>\'<S2SV_blank>+<S2SV_blank>\'%s\';\\n" "\t<S2SV_blank><S2SV_blank><S2SV_blank>var<S2SV_blank>timerID;\\n" "\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>function<S2SV_blank>checkSession()<S2SV_blank>{\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>console.debug(\'checkSession:<S2SV_blank>posting<S2SV_blank>\'<S2SV_blank>+<S2SV_blank>message<S2SV_blank>+<S2SV_blank>\'<S2SV_blank>to<S2SV_blank>\'<S2SV_blank>+<S2SV_blank>targetOrigin);\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>var<S2SV_blank>win<S2SV_blank>=<S2SV_blank>window.parent.document.getElementById(\'%s\').contentWindow;\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>win.postMessage(<S2SV_blank>message,<S2SV_blank>targetOrigin);\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}\\n" "\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>function<S2SV_blank>setTimer()<S2SV_blank>{\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>checkSession();\\n" <S2SV_StartBug> "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>timerID<S2SV_blank>=<S2SV_blank>setInterval(\'checkSession()\',<S2SV_blank>%s);\\n" <S2SV_EndBug> "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}\\n" "\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>function<S2SV_blank>receiveMessage(e)<S2SV_blank>{\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>console.debug(\'receiveMessage:<S2SV_blank>\'<S2SV_blank>+<S2SV_blank>e.data<S2SV_blank>+<S2SV_blank>\'<S2SV_blank>from<S2SV_blank>\'<S2SV_blank>+<S2SV_blank>e.origin);\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>if<S2SV_blank>(e.origin<S2SV_blank>!==<S2SV_blank>targetOrigin<S2SV_blank>)<S2SV_blank>{\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>console.debug(\'receiveMessage:<S2SV_blank>cross-site<S2SV_blank>scripting<S2SV_blank>attack?\');\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>return;\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>if<S2SV_blank>(e.data<S2SV_blank>!=<S2SV_blank>\'unchanged\')<S2SV_blank>{\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>clearInterval(timerID);\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>if<S2SV_blank>(e.data<S2SV_blank>==<S2SV_blank>\'changed\')<S2SV_blank>{\\n" "\t\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>window.location.href<S2SV_blank>=<S2SV_blank>\'%s?session=check\';\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}<S2SV_blank>else<S2SV_blank>{\\n" "\t\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>window.location.href<S2SV_blank>=<S2SV_blank>\'%s?session=logout\';\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>}\\n" "\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>window.addEventListener(\'message\',<S2SV_blank>receiveMessage,<S2SV_blank>false);\\n" "\\n" "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank></script>\\n" ; char * origin = apr_pstrdup ( r -> pool , check_session_iframe ) ; apr_uri_t uri ; apr_uri_parse ( r -> pool , check_session_iframe , & uri ) ; char * p = strstr ( origin , uri . path ) ; * p = '\\0' ; const char * op_iframe_id = "openidc-op" ; const char * session_state = oidc_session_get_session_state ( r , session ) ; if ( session_state == NULL ) { oidc_warn ( r , "no<S2SV_blank>session_state<S2SV_blank>found<S2SV_blank>in<S2SV_blank>the<S2SV_blank>session;<S2SV_blank>the<S2SV_blank>OP<S2SV_blank>does<S2SV_blank>probably<S2SV_blank>not<S2SV_blank>support<S2SV_blank>session<S2SV_blank>management!?" ) ; return DONE ; } char * s_poll_interval = NULL ; oidc_util_get_request_parameter ( r , "poll" , & s_poll_interval ) ; <S2SV_StartBug> if ( s_poll_interval == NULL ) <S2SV_EndBug> s_poll_interval = "3000" ; const char * redirect_uri = oidc_get_redirect_uri ( r , c ) ; java_script = apr_psprintf ( r -> pool , java_script , origin , client_id , <S2SV_StartBug> session_state , op_iframe_id , s_poll_interval , redirect_uri , <S2SV_EndBug> redirect_uri ) ; return oidc_util_html_send ( r , NULL , java_script , "setTimer" , NULL , DONE ) ; }
void w3m_exit ( int i ) { # ifdef USE_MIGEMO init_migemo ( ) ; # endif stopDownload ( ) ; deleteFiles ( ) ; # ifdef USE_SSL free_ssl_ctx ( ) ; # endif disconnectFTP ( ) ; # ifdef USE_NNTP disconnectNews ( ) ; # endif # ifdef __MINGW32_VERSION WSACleanup ( ) ; # endif <S2SV_StartBug> exit ( i ) ; <S2SV_EndBug> }
static int dissect_spoolss_uint16uni ( tvbuff_t * tvb , int offset , packet_info * pinfo _U_ , proto_tree * tree , guint8 * drep _U_ , char * * data , int hf_name ) { gint len , remaining ; char * text ; if ( offset % 2 ) offset += 2 - ( offset % 2 ) ; <S2SV_StartBug> remaining = tvb_captured_length_remaining ( tvb , offset ) ; <S2SV_EndBug> if ( remaining <= 0 ) { if ( data ) * data = g_strdup ( "" ) ; return offset ; } text = tvb_get_string_enc ( NULL , tvb , offset , remaining , ENC_UTF_16 | ENC_LITTLE_ENDIAN ) ; len = ( int ) strlen ( text ) ; proto_tree_add_string ( tree , hf_name , tvb , offset , len * 2 , text ) ; if ( data ) * data = text ; else g_free ( text ) ; return offset + ( len + 1 ) * 2 ; }
static int do_timer_create ( clockid_t which_clock , struct sigevent * event , timer_t __user * created_timer_id ) { const struct k_clock * kc = clockid_to_kclock ( which_clock ) ; struct k_itimer * new_timer ; int error , new_timer_id ; int it_id_set = IT_ID_NOT_SET ; if ( ! kc ) return - EINVAL ; if ( ! kc -> timer_create ) return - EOPNOTSUPP ; new_timer = alloc_posix_timer ( ) ; if ( unlikely ( ! new_timer ) ) return - EAGAIN ; spin_lock_init ( & new_timer -> it_lock ) ; new_timer_id = posix_timer_add ( new_timer ) ; if ( new_timer_id < 0 ) { error = new_timer_id ; goto out ; } it_id_set = IT_ID_SET ; new_timer -> it_id = ( timer_t ) new_timer_id ; new_timer -> it_clock = which_clock ; new_timer -> kclock = kc ; <S2SV_StartBug> new_timer -> it_overrun = - 1 ; <S2SV_EndBug> if ( event ) { rcu_read_lock ( ) ; new_timer -> it_pid = get_pid ( good_sigevent ( event ) ) ; rcu_read_unlock ( ) ; if ( ! new_timer -> it_pid ) { error = - EINVAL ; goto out ; } new_timer -> it_sigev_notify = event -> sigev_notify ; new_timer -> sigq -> info . si_signo = event -> sigev_signo ; new_timer -> sigq -> info . si_value = event -> sigev_value ; } else { new_timer -> it_sigev_notify = SIGEV_SIGNAL ; new_timer -> sigq -> info . si_signo = SIGALRM ; memset ( & new_timer -> sigq -> info . si_value , 0 , sizeof ( sigval_t ) ) ; new_timer -> sigq -> info . si_value . sival_int = new_timer -> it_id ; new_timer -> it_pid = get_pid ( task_tgid ( current ) ) ; } new_timer -> sigq -> info . si_tid = new_timer -> it_id ; new_timer -> sigq -> info . si_code = SI_TIMER ; if ( copy_to_user ( created_timer_id , & new_timer_id , sizeof ( new_timer_id ) ) ) { error = - EFAULT ; goto out ; } error = kc -> timer_create ( new_timer ) ; if ( error ) goto out ; spin_lock_irq ( & current -> sighand -> siglock ) ; new_timer -> it_signal = current -> signal ; list_add ( & new_timer -> list , & current -> signal -> posix_timers ) ; spin_unlock_irq ( & current -> sighand -> siglock ) ; return 0 ; out : release_posix_timer ( new_timer , it_id_set ) ; return error ; }
static int filter_frame ( AVFilterLink * inlink , AVFrame * in ) { AVFilterContext * ctx = inlink -> dst ; LutContext * s = ctx -> priv ; AVFilterLink * outlink = ctx -> outputs [ 0 ] ; AVFrame * out ; uint8_t * inrow , * outrow , * inrow0 , * outrow0 ; int i , j , plane , direct = 0 ; if ( av_frame_is_writable ( in ) ) { direct = 1 ; out = in ; } else { out = ff_get_video_buffer ( outlink , outlink -> w , outlink -> h ) ; if ( ! out ) { av_frame_free ( & in ) ; return AVERROR ( ENOMEM ) ; } av_frame_copy_props ( out , in ) ; } if ( s -> is_rgb ) { inrow0 = in -> data [ 0 ] ; outrow0 = out -> data [ 0 ] ; for ( i = 0 ; i < in -> height ; i ++ ) { int w = inlink -> w ; const uint8_t ( * tab ) [ 256 ] = ( const uint8_t ( * ) [ 256 ] ) s -> lut ; inrow = inrow0 ; outrow = outrow0 ; for ( j = 0 ; j < w ; j ++ ) { switch ( s -> step ) { case 4 : outrow [ 3 ] = tab [ 3 ] [ inrow [ 3 ] ] ; case 3 : outrow [ 2 ] = tab [ 2 ] [ inrow [ 2 ] ] ; case 2 : outrow [ 1 ] = tab [ 1 ] [ inrow [ 1 ] ] ; default : outrow [ 0 ] = tab [ 0 ] [ inrow [ 0 ] ] ; } outrow += s -> step ; inrow += s -> step ; } inrow0 += in -> linesize [ 0 ] ; outrow0 += out -> linesize [ 0 ] ; } } else { <S2SV_StartBug> for ( plane = 0 ; plane < 4 && in -> data [ plane ] ; plane ++ ) { <S2SV_EndBug> int vsub = plane == 1 || plane == 2 ? s -> vsub : 0 ; int hsub = plane == 1 || plane == 2 ? s -> hsub : 0 ; int h = FF_CEIL_RSHIFT ( inlink -> h , vsub ) ; int w = FF_CEIL_RSHIFT ( inlink -> w , hsub ) ; inrow = in -> data [ plane ] ; outrow = out -> data [ plane ] ; for ( i = 0 ; i < h ; i ++ ) { const uint8_t * tab = s -> lut [ plane ] ; for ( j = 0 ; j < w ; j ++ ) outrow [ j ] = tab [ inrow [ j ] ] ; inrow += in -> linesize [ plane ] ; outrow += out -> linesize [ plane ] ; } } } if ( ! direct ) av_frame_free ( & in ) ; return ff_filter_frame ( outlink , out ) ; }
static ssize_t o2nm_node_local_store ( struct config_item * item , const char * page , size_t count ) { struct o2nm_node * node = to_o2nm_node ( item ) ; <S2SV_StartBug> struct o2nm_cluster * cluster = to_o2nm_cluster_from_node ( node ) ; <S2SV_EndBug> unsigned long tmp ; char * p = ( char * ) page ; ssize_t ret ; tmp = simple_strtoul ( p , & p , 0 ) ; if ( ! p || ( * p && ( * p != '\\n' ) ) ) return - EINVAL ; tmp = ! ! tmp ; if ( ! test_bit ( O2NM_NODE_ATTR_ADDRESS , & node -> nd_set_attributes ) || ! test_bit ( O2NM_NODE_ATTR_NUM , & node -> nd_set_attributes ) || ! test_bit ( O2NM_NODE_ATTR_PORT , & node -> nd_set_attributes ) ) return - EINVAL ; <S2SV_StartBug> if ( tmp && tmp == cluster -> cl_has_local && <S2SV_EndBug> cluster -> cl_local_node != node -> nd_num ) <S2SV_StartBug> return - EBUSY ; <S2SV_EndBug> <S2SV_StartBug> if ( tmp && ! cluster -> cl_has_local ) { <S2SV_EndBug> ret = o2net_start_listening ( node ) ; if ( ret ) <S2SV_StartBug> return ret ; <S2SV_EndBug> } if ( ! tmp && cluster -> cl_has_local && cluster -> cl_local_node == node -> nd_num ) { o2net_stop_listening ( node ) ; cluster -> cl_local_node = O2NM_INVALID_NODE_NUM ; } node -> nd_local = tmp ; if ( node -> nd_local ) { cluster -> cl_has_local = tmp ; cluster -> cl_local_node = node -> nd_num ; } <S2SV_StartBug> return count ; <S2SV_EndBug> }
static int kvm_set_guest_paused ( struct kvm_vcpu * vcpu ) { <S2SV_StartBug> if ( ! vcpu -> arch . time_page ) <S2SV_EndBug> return - EINVAL ; vcpu -> arch . pvclock_set_guest_stopped_request = true ; kvm_make_request ( KVM_REQ_CLOCK_UPDATE , vcpu ) ; return 0 ; }
static ssize_t n_tty_write ( struct tty_struct * tty , struct file * file , const unsigned char * buf , size_t nr ) { const unsigned char * b = buf ; DECLARE_WAITQUEUE ( wait , current ) ; int c ; ssize_t retval = 0 ; if ( L_TOSTOP ( tty ) && file -> f_op -> write != redirected_tty_write ) { retval = tty_check_change ( tty ) ; if ( retval ) return retval ; } down_read ( & tty -> termios_rwsem ) ; process_echoes ( tty ) ; add_wait_queue ( & tty -> write_wait , & wait ) ; while ( 1 ) { set_current_state ( TASK_INTERRUPTIBLE ) ; if ( signal_pending ( current ) ) { retval = - ERESTARTSYS ; break ; } if ( tty_hung_up_p ( file ) || ( tty -> link && ! tty -> link -> count ) ) { retval = - EIO ; break ; } if ( O_OPOST ( tty ) ) { while ( nr > 0 ) { ssize_t num = process_output_block ( tty , b , nr ) ; if ( num < 0 ) { if ( num == - EAGAIN ) break ; retval = num ; goto break_out ; } b += num ; nr -= num ; if ( nr == 0 ) break ; c = * b ; if ( process_output ( c , tty ) < 0 ) break ; b ++ ; nr -- ; } if ( tty -> ops -> flush_chars ) tty -> ops -> flush_chars ( tty ) ; } else { <S2SV_StartBug> while ( nr > 0 ) { <S2SV_EndBug> <S2SV_StartBug> c = tty -> ops -> write ( tty , b , nr ) ; <S2SV_EndBug> if ( c < 0 ) { retval = c ; goto break_out ; } if ( ! c ) break ; b += c ; nr -= c ; } } if ( ! nr ) break ; if ( file -> f_flags & O_NONBLOCK ) { retval = - EAGAIN ; break ; } up_read ( & tty -> termios_rwsem ) ; schedule ( ) ; down_read ( & tty -> termios_rwsem ) ; } break_out : __set_current_state ( TASK_RUNNING ) ; remove_wait_queue ( & tty -> write_wait , & wait ) ; if ( b - buf != nr && tty -> fasync ) set_bit ( TTY_DO_WRITE_WAKEUP , & tty -> flags ) ; up_read ( & tty -> termios_rwsem ) ; return ( b - buf ) ? b - buf : retval ; }
qboolean S_AL_Init ( soundInterface_t * si ) { # ifdef USE_OPENAL const char * device = NULL ; const char * inputdevice = NULL ; int i ; if ( ! si ) { return qfalse ; } for ( i = 0 ; i < MAX_RAW_STREAMS ; i ++ ) { streamSourceHandles [ i ] = - 1 ; streamPlaying [ i ] = qfalse ; streamSources [ i ] = 0 ; streamNumBuffers [ i ] = 0 ; streamBufIndex [ i ] = 0 ; } s_alPrecache = Cvar_Get ( "s_alPrecache" , "1" , CVAR_ARCHIVE ) ; s_alGain = Cvar_Get ( "s_alGain" , "1.0" , CVAR_ARCHIVE ) ; s_alSources = Cvar_Get ( "s_alSources" , "128" , CVAR_ARCHIVE ) ; s_alDopplerFactor = Cvar_Get ( "s_alDopplerFactor" , "1.0" , CVAR_ARCHIVE ) ; s_alDopplerSpeed = Cvar_Get ( "s_alDopplerSpeed" , "9000" , CVAR_ARCHIVE ) ; s_alMinDistance = Cvar_Get ( "s_alMinDistance" , "256" , CVAR_ARCHIVE ) ; s_alMaxDistance = Cvar_Get ( "s_alMaxDistance" , "1024" , CVAR_ARCHIVE ) ; s_alRolloff = Cvar_Get ( "s_alRolloff" , "1.3" , CVAR_ARCHIVE ) ; s_alGraceDistance = Cvar_Get ( "s_alGraceDistance" , "512" , CVAR_ARCHIVE ) ; s_alTalkAnims = Cvar_Get ( "s_alTalkAnims" , "160" , CVAR_ARCHIVE ) ; <S2SV_StartBug> s_alDriver = Cvar_Get ( "s_alDriver" , ALDRIVER_DEFAULT , CVAR_ARCHIVE | CVAR_LATCH ) ; <S2SV_EndBug> s_alInputDevice = Cvar_Get ( "s_alInputDevice" , "" , CVAR_ARCHIVE | CVAR_LATCH ) ; <S2SV_StartBug> s_alDevice = Cvar_Get ( "s_alDevice" , "" , CVAR_ARCHIVE | CVAR_LATCH ) ; <S2SV_EndBug> if ( ! QAL_Init ( s_alDriver -> string ) ) { # if defined ( _WIN32 ) if ( ! Q_stricmp ( s_alDriver -> string , ALDRIVER_DEFAULT ) && ! QAL_Init ( "OpenAL64.dll" ) ) { # elif defined ( __APPLE__ ) if ( ! Q_stricmp ( s_alDriver -> string , ALDRIVER_DEFAULT ) && ! QAL_Init ( "/System/Library/Frameworks/OpenAL.framework/OpenAL" ) ) { # else if ( ! Q_stricmp ( s_alDriver -> string , ALDRIVER_DEFAULT ) || ! QAL_Init ( ALDRIVER_DEFAULT ) ) { # endif return qfalse ; } } device = s_alDevice -> string ; if ( device && ! * device ) device = NULL ; inputdevice = s_alInputDevice -> string ; if ( inputdevice && ! * inputdevice ) inputdevice = NULL ; enumeration_all_ext = qalcIsExtensionPresent ( NULL , "ALC_ENUMERATE_ALL_EXT" ) ; enumeration_ext = qalcIsExtensionPresent ( NULL , "ALC_ENUMERATION_EXT" ) ; if ( enumeration_ext || enumeration_all_ext ) { char devicenames [ 16384 ] = "" ; const char * devicelist ; # ifdef _WIN32 const char * defaultdevice ; # endif int curlen ; if ( enumeration_all_ext ) { devicelist = qalcGetString ( NULL , ALC_ALL_DEVICES_SPECIFIER ) ; # ifdef _WIN32 defaultdevice = qalcGetString ( NULL , ALC_DEFAULT_ALL_DEVICES_SPECIFIER ) ; # endif } else { devicelist = qalcGetString ( NULL , ALC_DEVICE_SPECIFIER ) ; # ifdef _WIN32 defaultdevice = qalcGetString ( NULL , ALC_DEFAULT_DEVICE_SPECIFIER ) ; # endif enumeration_ext = qtrue ; } # ifdef _WIN32 if ( ! device && defaultdevice && ! strcmp ( defaultdevice , "Generic<S2SV_blank>Hardware" ) ) device = "Generic<S2SV_blank>Software" ; # endif if ( devicelist ) { while ( ( curlen = strlen ( devicelist ) ) ) { Q_strcat ( devicenames , sizeof ( devicenames ) , devicelist ) ; Q_strcat ( devicenames , sizeof ( devicenames ) , "\\n" ) ; devicelist += curlen + 1 ; } } s_alAvailableDevices = Cvar_Get ( "s_alAvailableDevices" , devicenames , CVAR_ROM | CVAR_NORESTART ) ; } alDevice = qalcOpenDevice ( device ) ; if ( ! alDevice && device ) { Com_Printf ( "Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>OpenAL<S2SV_blank>device<S2SV_blank>\'%s\',<S2SV_blank>trying<S2SV_blank>default.\\n" , device ) ; alDevice = qalcOpenDevice ( NULL ) ; } if ( ! alDevice ) { QAL_Shutdown ( ) ; Com_Printf ( "Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>OpenAL<S2SV_blank>device.\\n" ) ; return qfalse ; } alContext = qalcCreateContext ( alDevice , NULL ) ; if ( ! alContext ) { QAL_Shutdown ( ) ; qalcCloseDevice ( alDevice ) ; Com_Printf ( "Failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>OpenAL<S2SV_blank>context.\\n" ) ; return qfalse ; } qalcMakeContextCurrent ( alContext ) ; S_AL_BufferInit ( ) ; S_AL_SrcInit ( ) ; Com_Printf ( "Allocated<S2SV_blank>%d<S2SV_blank>sources.\\n" , srcCount ) ; qalDistanceModel ( AL_INVERSE_DISTANCE_CLAMPED ) ; qalDopplerFactor ( s_alDopplerFactor -> value ) ; qalSpeedOfSound ( s_alDopplerSpeed -> value ) ; # ifdef USE_VOIP s_alCapture = Cvar_Get ( "s_alCapture" , "1" , CVAR_ARCHIVE | CVAR_LATCH ) ; if ( ! s_alCapture -> integer ) { Com_Printf ( "OpenAL<S2SV_blank>capture<S2SV_blank>support<S2SV_blank>disabled<S2SV_blank>by<S2SV_blank>user<S2SV_blank>(\'+set<S2SV_blank>s_alCapture<S2SV_blank>1\'<S2SV_blank>to<S2SV_blank>enable)\\n" ) ; } # if USE_MUMBLE else if ( cl_useMumble -> integer ) { Com_Printf ( "OpenAL<S2SV_blank>capture<S2SV_blank>support<S2SV_blank>disabled<S2SV_blank>for<S2SV_blank>Mumble<S2SV_blank>support\\n" ) ; } # endif else { # ifdef __APPLE__ if ( qalcCaptureOpenDevice == NULL ) # else if ( ! qalcIsExtensionPresent ( NULL , "ALC_EXT_capture" ) ) # endif { Com_Printf ( "No<S2SV_blank>ALC_EXT_capture<S2SV_blank>support,<S2SV_blank>can\'t<S2SV_blank>record<S2SV_blank>audio.\\n" ) ; } else { char inputdevicenames [ 16384 ] = "" ; const char * inputdevicelist ; const char * defaultinputdevice ; int curlen ; capture_ext = qtrue ; inputdevicelist = qalcGetString ( NULL , ALC_CAPTURE_DEVICE_SPECIFIER ) ; defaultinputdevice = qalcGetString ( NULL , ALC_CAPTURE_DEFAULT_DEVICE_SPECIFIER ) ; if ( inputdevicelist ) { while ( ( curlen = strlen ( inputdevicelist ) ) ) { Q_strcat ( inputdevicenames , sizeof ( inputdevicenames ) , inputdevicelist ) ; Q_strcat ( inputdevicenames , sizeof ( inputdevicenames ) , "\\n" ) ; inputdevicelist += curlen + 1 ; } } s_alAvailableInputDevices = Cvar_Get ( "s_alAvailableInputDevices" , inputdevicenames , CVAR_ROM | CVAR_NORESTART ) ; Com_Printf ( "OpenAL<S2SV_blank>default<S2SV_blank>capture<S2SV_blank>device<S2SV_blank>is<S2SV_blank>\'%s\'\\n" , defaultinputdevice ? defaultinputdevice : "none" ) ; alCaptureDevice = qalcCaptureOpenDevice ( inputdevice , 48000 , AL_FORMAT_MONO16 , VOIP_MAX_PACKET_SAMPLES * 4 ) ; if ( ! alCaptureDevice && inputdevice ) { Com_Printf ( "Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>OpenAL<S2SV_blank>Input<S2SV_blank>device<S2SV_blank>\'%s\',<S2SV_blank>trying<S2SV_blank>default.\\n" , inputdevice ) ; alCaptureDevice = qalcCaptureOpenDevice ( NULL , 48000 , AL_FORMAT_MONO16 , VOIP_MAX_PACKET_SAMPLES * 4 ) ; } Com_Printf ( "OpenAL<S2SV_blank>capture<S2SV_blank>device<S2SV_blank>%s.\\n" , ( alCaptureDevice == NULL ) ? "failed<S2SV_blank>to<S2SV_blank>open" : "opened" ) ; } } # endif si -> Shutdown = S_AL_Shutdown ; si -> StartSound = S_AL_StartSound ; si -> StartSoundEx = S_AL_StartSoundEx ; si -> StartLocalSound = S_AL_StartLocalSound ; si -> StartBackgroundTrack = S_AL_StartBackgroundTrack ; si -> StopBackgroundTrack = S_AL_StopBackgroundTrack ; si -> FadeStreamingSound = S_AL_FadeStreamingSound ; si -> FadeAllSounds = S_AL_FadeAllSounds ; si -> StartStreamingSound = S_AL_StartStreamingSound ; si -> StopEntStreamingSound = S_AL_StopEntStreamingSound ; si -> GetVoiceAmplitude = S_AL_GetVoiceAmplitude ; si -> RawSamples = S_AL_RawSamples ; si -> StopAllSounds = S_AL_StopAllSounds ; si -> ClearLoopingSounds = S_AL_ClearLoopingSounds ; si -> AddLoopingSound = S_AL_AddLoopingSound ; si -> AddRealLoopingSound = S_AL_AddRealLoopingSound ; si -> StopLoopingSound = S_AL_StopLoopingSound ; si -> Respatialize = S_AL_Respatialize ; si -> UpdateEntityPosition = S_AL_UpdateEntityPosition ; si -> Update = S_AL_Update ; si -> DisableSounds = S_AL_DisableSounds ; si -> BeginRegistration = S_AL_BeginRegistration ; si -> RegisterSound = S_AL_RegisterSound ; si -> ClearSoundBuffer = S_AL_ClearSoundBuffer ; si -> SoundInfo = S_AL_SoundInfo ; si -> SoundList = S_AL_SoundList ; # ifdef USE_VOIP si -> StartCapture = S_AL_StartCapture ; si -> AvailableCaptureSamples = S_AL_AvailableCaptureSamples ; si -> Capture = S_AL_Capture ; si -> StopCapture = S_AL_StopCapture ; si -> MasterGain = S_AL_MasterGain ; # endif return qtrue ; # else return qfalse ; # endif }
static int install_thread_keyring ( void ) { struct cred * new ; int ret ; new = prepare_creds ( ) ; if ( ! new ) <S2SV_StartBug> return - ENOMEM ; <S2SV_EndBug> BUG_ON ( new -> thread_keyring ) ; ret = install_thread_keyring_to_cred ( new ) ; if ( ret < 0 ) { abort_creds ( new ) ; return ret ; } return commit_creds ( new ) ; }
static int lmp_print_data_link_subobjs ( netdissect_options * ndo , const u_char * obj_tptr , int total_subobj_len , int offset ) { int hexdump = FALSE ; int subobj_type , subobj_len ; union { float f ; uint32_t i ; } bw ; while ( total_subobj_len > 0 && hexdump == FALSE ) { <S2SV_StartBug> subobj_type = EXTRACT_8BITS ( obj_tptr + offset ) ; <S2SV_EndBug> subobj_len = EXTRACT_8BITS ( obj_tptr + offset + 1 ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Subobject,<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>(%u),<S2SV_blank>Length:<S2SV_blank>%u" , tok2str ( lmp_data_link_subobj , "Unknown" , subobj_type ) , subobj_type , subobj_len ) ) ; if ( subobj_len < 4 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(too<S2SV_blank>short)" ) ) ; break ; } if ( ( subobj_len % 4 ) != 0 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(not<S2SV_blank>a<S2SV_blank>multiple<S2SV_blank>of<S2SV_blank>4)" ) ) ; break ; } if ( total_subobj_len < subobj_len ) { ND_PRINT ( ( ndo , "<S2SV_blank>(goes<S2SV_blank>past<S2SV_blank>the<S2SV_blank>end<S2SV_blank>of<S2SV_blank>the<S2SV_blank>object)" ) ) ; break ; } switch ( subobj_type ) { case INT_SWITCHING_TYPE_SUBOBJ : <S2SV_StartBug> ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Switching<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>(%u)" , <S2SV_EndBug> tok2str ( gmpls_switch_cap_values , "Unknown" , EXTRACT_8BITS ( obj_tptr + offset + 2 ) ) , <S2SV_StartBug> EXTRACT_8BITS ( obj_tptr + offset + 2 ) ) ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Encoding<S2SV_blank>Type:<S2SV_blank>%s<S2SV_blank>(%u)" , tok2str ( gmpls_encoding_values , "Unknown" , EXTRACT_8BITS ( obj_tptr + offset + 3 ) ) , EXTRACT_8BITS ( obj_tptr + offset + 3 ) ) ) ; ND_TCHECK_32BITS ( obj_tptr + offset + 4 ) ; bw . i = EXTRACT_32BITS ( obj_tptr + offset + 4 ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Min<S2SV_blank>Reservable<S2SV_blank>Bandwidth:<S2SV_blank>%.3f<S2SV_blank>Mbps" , bw . f * 8 / 1000000 ) ) ; <S2SV_StartBug> bw . i = EXTRACT_32BITS ( obj_tptr + offset + 8 ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Max<S2SV_blank>Reservable<S2SV_blank>Bandwidth:<S2SV_blank>%.3f<S2SV_blank>Mbps" , bw . f * 8 / 1000000 ) ) ; break ; case WAVELENGTH_SUBOBJ : <S2SV_StartBug> ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Wavelength:<S2SV_blank>%u" , <S2SV_EndBug> EXTRACT_32BITS ( obj_tptr + offset + 4 ) ) ) ; break ; default : hexdump = TRUE ; break ; } total_subobj_len -= subobj_len ; offset += subobj_len ; } return ( hexdump ) ; trunc : return - 1 ; }
<S2SV_StartBug> static BLOCK_SIZE get_rd_var_based_fixed_partition ( VP9_COMP * cpi , <S2SV_EndBug> int mi_row , int mi_col ) { <S2SV_StartBug> unsigned int var = get_sby_perpixel_diff_variance ( cpi , & cpi -> mb , <S2SV_EndBug> mi_row , mi_col , BLOCK_64X64 ) ; if ( var < 8 ) return BLOCK_64X64 ; else if ( var < 128 ) return BLOCK_32X32 ; else if ( var < 2048 ) return BLOCK_16X16 ; else return BLOCK_8X8 ; }
static __u8 * nci_extract_rf_params_nfca_passive_poll ( struct nci_dev * ndev , struct rf_tech_specific_params_nfca_poll * nfca_poll , __u8 * data ) { nfca_poll -> sens_res = __le16_to_cpu ( * ( ( __u16 * ) data ) ) ; data += 2 ; <S2SV_StartBug> nfca_poll -> nfcid1_len = * data ++ ; <S2SV_EndBug> pr_debug ( "sens_res<S2SV_blank>0x%x,<S2SV_blank>nfcid1_len<S2SV_blank>%d\\n" , nfca_poll -> sens_res , nfca_poll -> nfcid1_len ) ; memcpy ( nfca_poll -> nfcid1 , data , nfca_poll -> nfcid1_len ) ; data += nfca_poll -> nfcid1_len ; nfca_poll -> sel_res_len = * data ++ ; if ( nfca_poll -> sel_res_len != 0 ) nfca_poll -> sel_res = * data ++ ; pr_debug ( "sel_res_len<S2SV_blank>%d,<S2SV_blank>sel_res<S2SV_blank>0x%x\\n" , nfca_poll -> sel_res_len , nfca_poll -> sel_res ) ; return data ; }
static void set_offsets ( VP9_COMP * cpi , const TileInfo * const tile , <S2SV_StartBug> int mi_row , int mi_col , BLOCK_SIZE bsize ) { <S2SV_EndBug> <S2SV_StartBug> MACROBLOCK * const x = & cpi -> mb ; <S2SV_EndBug> VP9_COMMON * const cm = & cpi -> common ; MACROBLOCKD * const xd = & x -> e_mbd ; MB_MODE_INFO * mbmi ; const int mi_width = num_8x8_blocks_wide_lookup [ bsize ] ; const int mi_height = num_8x8_blocks_high_lookup [ bsize ] ; <S2SV_StartBug> const int mb_row = mi_row >> 1 ; <S2SV_EndBug> const int mb_col = mi_col >> 1 ; const int idx_map = mb_row * cm -> mb_cols + mb_col ; const struct segmentation * const seg = & cm -> seg ; set_skip_context ( xd , mi_row , mi_col ) ; <S2SV_StartBug> x -> mb_activity_ptr = & cpi -> mb_activity_map [ idx_map ] ; <S2SV_EndBug> x -> in_active_map = check_active_map ( cpi , x , mi_row , mi_col , bsize ) ; set_modeinfo_offsets ( cm , xd , mi_row , mi_col ) ; mbmi = & xd -> mi [ 0 ] -> mbmi ; <S2SV_StartBug> vp9_setup_dst_planes ( xd , get_frame_new_buffer ( cm ) , mi_row , mi_col ) ; <S2SV_EndBug> x -> mv_row_min = - ( ( ( mi_row + mi_height ) * MI_SIZE ) + VP9_INTERP_EXTEND ) ; x -> mv_col_min = - ( ( ( mi_col + mi_width ) * MI_SIZE ) + VP9_INTERP_EXTEND ) ; x -> mv_row_max = ( cm -> mi_rows - mi_row ) * MI_SIZE + VP9_INTERP_EXTEND ; x -> mv_col_max = ( cm -> mi_cols - mi_col ) * MI_SIZE + VP9_INTERP_EXTEND ; assert ( ! ( mi_col & ( mi_width - 1 ) ) && ! ( mi_row & ( mi_height - 1 ) ) ) ; set_mi_row_col ( xd , tile , mi_row , mi_height , mi_col , mi_width , cm -> mi_rows , cm -> mi_cols ) ; vp9_setup_src_planes ( x , cpi -> Source , mi_row , mi_col ) ; <S2SV_StartBug> x -> rddiv = cpi -> RDDIV ; <S2SV_EndBug> <S2SV_StartBug> x -> rdmult = cpi -> RDMULT ; <S2SV_EndBug> if ( seg -> enabled ) { if ( cpi -> oxcf . aq_mode != VARIANCE_AQ ) { const uint8_t * const map = seg -> update_map ? cpi -> segmentation_map : cm -> last_frame_seg_map ; <S2SV_StartBug> mbmi -> segment_id = vp9_get_segment_id ( cm , map , bsize , mi_row , mi_col ) ; <S2SV_EndBug> } vp9_init_plane_quantizers ( cpi , x ) ; x -> encode_breakout = cpi -> segment_encode_breakout [ mbmi -> segment_id ] ; } else { mbmi -> segment_id = 0 ; x -> encode_breakout = cpi -> encode_breakout ; } <S2SV_StartBug> } <S2SV_EndBug>
static void uv__process_child_init ( const uv_process_options_t * options , int stdio_count , int ( * pipes ) [ 2 ] , int error_fd ) { int close_fd ; int use_fd ; int fd ; if ( options -> flags & UV_PROCESS_DETACHED ) setsid ( ) ; for ( fd = 0 ; fd < stdio_count ; fd ++ ) { close_fd = pipes [ fd ] [ 0 ] ; use_fd = pipes [ fd ] [ 1 ] ; if ( use_fd < 0 ) { if ( fd >= 3 ) continue ; else { use_fd = open ( "/dev/null" , fd == 0 ? O_RDONLY : O_RDWR ) ; close_fd = use_fd ; if ( use_fd == - 1 ) { uv__write_int ( error_fd , - errno ) ; perror ( "failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>stdio" ) ; _exit ( 127 ) ; } } } if ( fd == use_fd ) uv__cloexec ( use_fd , 0 ) ; else dup2 ( use_fd , fd ) ; if ( fd <= 2 ) uv__nonblock ( fd , 0 ) ; if ( close_fd != - 1 ) uv__close ( close_fd ) ; } for ( fd = 0 ; fd < stdio_count ; fd ++ ) { use_fd = pipes [ fd ] [ 1 ] ; if ( use_fd >= 0 && fd != use_fd ) close ( use_fd ) ; } if ( options -> cwd != NULL && chdir ( options -> cwd ) ) { uv__write_int ( error_fd , - errno ) ; perror ( "chdir()" ) ; _exit ( 127 ) ; } <S2SV_StartBug> if ( ( options -> flags & UV_PROCESS_SETGID ) && setgid ( options -> gid ) ) { <S2SV_EndBug> uv__write_int ( error_fd , - errno ) ; perror ( "setgid()" ) ; _exit ( 127 ) ; } if ( ( options -> flags & UV_PROCESS_SETUID ) && setuid ( options -> uid ) ) { uv__write_int ( error_fd , - errno ) ; perror ( "setuid()" ) ; _exit ( 127 ) ; } if ( options -> env != NULL ) { environ = options -> env ; } execvp ( options -> file , options -> args ) ; uv__write_int ( error_fd , - errno ) ; perror ( "execvp()" ) ; _exit ( 127 ) ; }
WORD32 ihevcd_parse_transform_tree ( codec_t * ps_codec , WORD32 x0 , WORD32 y0 , WORD32 cu_x_base , WORD32 cu_y_base , WORD32 log2_trafo_size , WORD32 trafo_depth , WORD32 blk_idx , WORD32 intra_pred_mode ) { IHEVCD_ERROR_T ret = ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ; sps_t * ps_sps ; pps_t * ps_pps ; WORD32 value ; WORD32 x1 , y1 ; WORD32 max_trafo_depth ; bitstrm_t * ps_bitstrm = & ps_codec -> s_parse . s_bitstrm ; WORD32 intra_split_flag ; WORD32 split_transform_flag ; WORD32 ctxt_idx ; cab_ctxt_t * ps_cabac = & ps_codec -> s_parse . s_cabac ; max_trafo_depth = ps_codec -> s_parse . s_cu . i4_max_trafo_depth ; ps_sps = ps_codec -> s_parse . ps_sps ; ps_pps = ps_codec -> s_parse . ps_pps ; intra_split_flag = ps_codec -> s_parse . s_cu . i4_intra_split_flag ; { split_transform_flag = 0 ; if ( ( log2_trafo_size <= ps_sps -> i1_log2_max_transform_block_size ) && ( log2_trafo_size > ps_sps -> i1_log2_min_transform_block_size ) && ( trafo_depth < max_trafo_depth ) && ! ( intra_split_flag && ( trafo_depth == 0 ) ) ) { ctxt_idx = IHEVC_CAB_SPLIT_TFM + ( 5 - log2_trafo_size ) ; TRACE_CABAC_CTXT ( "split_transform_flag" , ps_cabac -> u4_range , ctxt_idx ) ; split_transform_flag = ihevcd_cabac_decode_bin ( ps_cabac , ps_bitstrm , ctxt_idx ) ; AEV_TRACE ( "split_transform_flag" , split_transform_flag , ps_cabac -> u4_range ) ; } else { WORD32 inter_split_flag = 0 ; if ( ( 0 == ps_sps -> i1_max_transform_hierarchy_depth_inter ) && ( PRED_MODE_INTER == ps_codec -> s_parse . s_cu . i4_pred_mode ) && ( PART_2Nx2N != ps_codec -> s_parse . s_cu . i4_part_mode ) && ( 0 == trafo_depth ) ) { inter_split_flag = 1 ; } if ( ( log2_trafo_size > ps_sps -> i1_log2_max_transform_block_size ) || ( ( 1 == intra_split_flag ) && ( 0 == trafo_depth ) ) || ( 1 == inter_split_flag ) ) { split_transform_flag = 1 ; } } if ( 0 == trafo_depth ) { ps_codec -> s_parse . s_cu . ai1_cbf_cr [ trafo_depth ] = 0 ; ps_codec -> s_parse . s_cu . ai1_cbf_cb [ trafo_depth ] = 0 ; } else { ps_codec -> s_parse . s_cu . ai1_cbf_cb [ trafo_depth ] = ps_codec -> s_parse . s_cu . ai1_cbf_cb [ trafo_depth - 1 ] ; ps_codec -> s_parse . s_cu . ai1_cbf_cr [ trafo_depth ] = ps_codec -> s_parse . s_cu . ai1_cbf_cr [ trafo_depth - 1 ] ; } if ( trafo_depth == 0 || log2_trafo_size > 2 ) { ctxt_idx = IHEVC_CAB_CBCR_IDX + trafo_depth ; if ( ( trafo_depth == 0 ) || ps_codec -> s_parse . s_cu . ai1_cbf_cb [ trafo_depth - 1 ] ) { TRACE_CABAC_CTXT ( "cbf_cb" , ps_cabac -> u4_range , ctxt_idx ) ; value = ihevcd_cabac_decode_bin ( ps_cabac , ps_bitstrm , ctxt_idx ) ; AEV_TRACE ( "cbf_cb" , value , ps_cabac -> u4_range ) ; ps_codec -> s_parse . s_cu . ai1_cbf_cb [ trafo_depth ] = value ; } if ( ( trafo_depth == 0 ) || ps_codec -> s_parse . s_cu . ai1_cbf_cr [ trafo_depth - 1 ] ) { TRACE_CABAC_CTXT ( "cbf_cr" , ps_cabac -> u4_range , ctxt_idx ) ; value = ihevcd_cabac_decode_bin ( ps_cabac , ps_bitstrm , ctxt_idx ) ; AEV_TRACE ( "cbf_cr" , value , ps_cabac -> u4_range ) ; ps_codec -> s_parse . s_cu . ai1_cbf_cr [ trafo_depth ] = value ; } } if ( split_transform_flag ) { WORD32 intra_pred_mode_tmp ; x1 = x0 + ( ( 1 << log2_trafo_size ) >> 1 ) ; y1 = y0 + ( ( 1 << log2_trafo_size ) >> 1 ) ; intra_pred_mode_tmp = trafo_depth ? intra_pred_mode : ps_codec -> s_parse . s_cu . ai4_intra_luma_pred_mode [ 0 ] ; ihevcd_parse_transform_tree ( ps_codec , x0 , y0 , x0 , y0 , log2_trafo_size - 1 , trafo_depth + 1 , 0 , intra_pred_mode_tmp ) ; intra_pred_mode_tmp = trafo_depth ? intra_pred_mode : ps_codec -> s_parse . s_cu . ai4_intra_luma_pred_mode [ 1 ] ; ihevcd_parse_transform_tree ( ps_codec , x1 , y0 , x0 , y0 , log2_trafo_size - 1 , trafo_depth + 1 , 1 , intra_pred_mode_tmp ) ; intra_pred_mode_tmp = trafo_depth ? intra_pred_mode : ps_codec -> s_parse . s_cu . ai4_intra_luma_pred_mode [ 2 ] ; ihevcd_parse_transform_tree ( ps_codec , x0 , y1 , x0 , y0 , log2_trafo_size - 1 , trafo_depth + 1 , 2 , intra_pred_mode_tmp ) ; intra_pred_mode_tmp = trafo_depth ? intra_pred_mode : ps_codec -> s_parse . s_cu . ai4_intra_luma_pred_mode [ 3 ] ; ihevcd_parse_transform_tree ( ps_codec , x1 , y1 , x0 , y0 , log2_trafo_size - 1 , trafo_depth + 1 , 3 , intra_pred_mode_tmp ) ; } else { WORD32 ctb_x_base ; WORD32 ctb_y_base ; WORD32 cu_qp_delta_abs ; tu_t * ps_tu = ps_codec -> s_parse . ps_tu ; cu_qp_delta_abs = 0 ; ctb_x_base = ps_codec -> s_parse . i4_ctb_x << ps_sps -> i1_log2_ctb_size ; ctb_y_base = ps_codec -> s_parse . i4_ctb_y << ps_sps -> i1_log2_ctb_size ; if ( ( ps_codec -> s_parse . s_cu . i4_pred_mode == PRED_MODE_INTRA ) || ( trafo_depth != 0 ) || ( ps_codec -> s_parse . s_cu . ai1_cbf_cb [ trafo_depth ] ) || ( ps_codec -> s_parse . s_cu . ai1_cbf_cr [ trafo_depth ] ) ) { ctxt_idx = IHEVC_CAB_CBF_LUMA_IDX ; ctxt_idx += ( trafo_depth == 0 ) ? 1 : 0 ; TRACE_CABAC_CTXT ( "cbf_luma" , ps_cabac -> u4_range , ctxt_idx ) ; value = ihevcd_cabac_decode_bin ( ps_cabac , ps_bitstrm , ctxt_idx ) ; AEV_TRACE ( "cbf_luma" , value , ps_cabac -> u4_range ) ; ps_codec -> s_parse . s_cu . i1_cbf_luma = value ; } else { ps_codec -> s_parse . s_cu . i1_cbf_luma = 1 ; } ps_tu -> b1_cb_cbf = 0 ; ps_tu -> b1_cr_cbf = 0 ; ps_tu -> b1_y_cbf = 0 ; ps_tu -> b4_pos_x = ( ( x0 - ctb_x_base ) >> 2 ) ; ps_tu -> b4_pos_y = ( ( y0 - ctb_y_base ) >> 2 ) ; ps_tu -> b1_transquant_bypass = ps_codec -> s_parse . s_cu . i4_cu_transquant_bypass ; ps_tu -> b3_size = ( log2_trafo_size - 2 ) ; ps_tu -> b7_qp = ps_codec -> s_parse . u4_qp ; ps_tu -> b6_luma_intra_mode = intra_pred_mode ; ps_tu -> b3_chroma_intra_mode_idx = ps_codec -> s_parse . s_cu . i4_intra_chroma_pred_mode_idx ; if ( ps_codec -> s_parse . s_cu . i1_cbf_luma || ps_codec -> s_parse . s_cu . ai1_cbf_cb [ trafo_depth ] || ps_codec -> s_parse . s_cu . ai1_cbf_cr [ trafo_depth ] ) { WORD32 intra_pred_mode_chroma ; if ( ps_pps -> i1_cu_qp_delta_enabled_flag && ! ps_codec -> s_parse . i4_is_cu_qp_delta_coded ) { WORD32 c_max = TU_MAX_QP_DELTA_ABS ; WORD32 ctxt_inc = IHEVC_CAB_QP_DELTA_ABS ; WORD32 ctxt_inc_max = CTXT_MAX_QP_DELTA_ABS ; TRACE_CABAC_CTXT ( "cu_qp_delta_abs" , ps_cabac -> u4_range , ctxt_inc ) ; cu_qp_delta_abs = ihevcd_cabac_decode_bins_tunary ( ps_cabac , ps_bitstrm , c_max , ctxt_inc , 0 , ctxt_inc_max ) ; if ( cu_qp_delta_abs >= c_max ) { value = ihevcd_cabac_decode_bypass_bins_egk ( ps_cabac , ps_bitstrm , 0 ) ; cu_qp_delta_abs += value ; } AEV_TRACE ( "cu_qp_delta_abs" , cu_qp_delta_abs , ps_cabac -> u4_range ) ; ps_codec -> s_parse . i4_is_cu_qp_delta_coded = 1 ; if ( cu_qp_delta_abs ) { value = ihevcd_cabac_decode_bypass_bin ( ps_cabac , ps_bitstrm ) ; AEV_TRACE ( "cu_qp_delta_sign" , value , ps_cabac -> u4_range ) ; if ( value ) cu_qp_delta_abs = - cu_qp_delta_abs ; } <S2SV_StartBug> ps_codec -> s_parse . s_cu . i4_cu_qp_delta = cu_qp_delta_abs ; <S2SV_EndBug> } if ( ps_codec -> s_parse . s_cu . i1_cbf_luma ) { ps_tu -> b1_y_cbf = 1 ; ihevcd_parse_residual_coding ( ps_codec , x0 , y0 , log2_trafo_size , 0 , intra_pred_mode ) ; } if ( 4 == ps_codec -> s_parse . s_cu . i4_intra_chroma_pred_mode_idx ) intra_pred_mode_chroma = ps_codec -> s_parse . s_cu . ai4_intra_luma_pred_mode [ 0 ] ; else { intra_pred_mode_chroma = gau1_intra_pred_chroma_modes [ ps_codec -> s_parse . s_cu . i4_intra_chroma_pred_mode_idx ] ; if ( intra_pred_mode_chroma == ps_codec -> s_parse . s_cu . ai4_intra_luma_pred_mode [ 0 ] ) { intra_pred_mode_chroma = INTRA_ANGULAR ( 34 ) ; } } if ( log2_trafo_size > 2 ) { if ( ps_codec -> s_parse . s_cu . ai1_cbf_cb [ trafo_depth ] ) { ps_tu -> b1_cb_cbf = 1 ; ihevcd_parse_residual_coding ( ps_codec , x0 , y0 , log2_trafo_size - 1 , 1 , intra_pred_mode_chroma ) ; } if ( ps_codec -> s_parse . s_cu . ai1_cbf_cr [ trafo_depth ] ) { ps_tu -> b1_cr_cbf = 1 ; ihevcd_parse_residual_coding ( ps_codec , x0 , y0 , log2_trafo_size - 1 , 2 , intra_pred_mode_chroma ) ; } } else if ( blk_idx == 3 ) { if ( ps_codec -> s_parse . s_cu . ai1_cbf_cb [ trafo_depth ] ) { ps_tu -> b1_cb_cbf = 1 ; ihevcd_parse_residual_coding ( ps_codec , cu_x_base , cu_y_base , log2_trafo_size , 1 , intra_pred_mode_chroma ) ; } if ( ps_codec -> s_parse . s_cu . ai1_cbf_cr [ trafo_depth ] ) { ps_tu -> b1_cr_cbf = 1 ; ihevcd_parse_residual_coding ( ps_codec , cu_x_base , cu_y_base , log2_trafo_size , 2 , intra_pred_mode_chroma ) ; } } else { ps_tu -> b3_chroma_intra_mode_idx = INTRA_PRED_CHROMA_IDX_NONE ; } } else { if ( ( 3 != blk_idx ) && ( 2 == log2_trafo_size ) ) { ps_tu -> b3_chroma_intra_mode_idx = INTRA_PRED_CHROMA_IDX_NONE ; } } { if ( ( ps_codec -> s_parse . s_cu . i4_pos_x << 3 ) == ( ps_tu -> b4_pos_x << 2 ) && ( ps_codec -> s_parse . s_cu . i4_pos_y << 3 ) == ( ps_tu -> b4_pos_y << 2 ) ) { ps_tu -> b1_first_tu_in_cu = 1 ; } else { ps_tu -> b1_first_tu_in_cu = 0 ; } } ps_codec -> s_parse . ps_tu ++ ; ps_codec -> s_parse . s_cu . i4_tu_cnt ++ ; ps_codec -> s_parse . i4_pic_tu_idx ++ ; } } return ret ; }
int wait_for_key_construction ( struct key * key , bool intr ) { int ret ; ret = wait_on_bit ( & key -> flags , KEY_FLAG_USER_CONSTRUCT , intr ? TASK_INTERRUPTIBLE : TASK_UNINTERRUPTIBLE ) ; if ( ret ) return - ERESTARTSYS ; <S2SV_StartBug> if ( test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) { <S2SV_EndBug> smp_rmb ( ) ; return key -> reject_error ; } return key_validate ( key ) ; }
static void tcp_illinois_info ( struct sock * sk , u32 ext , struct sk_buff * skb ) { const struct illinois * ca = inet_csk_ca ( sk ) ; if ( ext & ( 1 << ( INET_DIAG_VEGASINFO - 1 ) ) ) { struct tcpvegas_info info = { . tcpv_enabled = 1 , . tcpv_rttcnt = ca -> cnt_rtt , . tcpv_minrtt = ca -> base_rtt , } ; <S2SV_StartBug> u64 t = ca -> sum_rtt ; <S2SV_EndBug> <S2SV_StartBug> do_div ( t , ca -> cnt_rtt ) ; <S2SV_EndBug> <S2SV_StartBug> info . tcpv_rtt = t ; <S2SV_EndBug> nla_put ( skb , INET_DIAG_VEGASINFO , sizeof ( info ) , & info ) ; } }
static int serdes_probe ( struct platform_device * pdev ) { struct phy_provider * provider ; struct serdes_ctrl * ctrl ; unsigned int i ; int ret ; ctrl = devm_kzalloc ( & pdev -> dev , sizeof ( * ctrl ) , GFP_KERNEL ) ; if ( ! ctrl ) return - ENOMEM ; ctrl -> dev = & pdev -> dev ; ctrl -> regs = syscon_node_to_regmap ( pdev -> dev . parent -> of_node ) ; if ( IS_ERR ( ctrl -> regs ) ) return PTR_ERR ( ctrl -> regs ) ; <S2SV_StartBug> for ( i = 0 ; i <= SERDES_MAX ; i ++ ) { <S2SV_EndBug> ret = serdes_phy_create ( ctrl , i , & ctrl -> phys [ i ] ) ; if ( ret ) return ret ; } dev_set_drvdata ( & pdev -> dev , ctrl ) ; provider = devm_of_phy_provider_register ( ctrl -> dev , serdes_simple_xlate ) ; return PTR_ERR_OR_ZERO ( provider ) ; }
SYSCALL_DEFINE5 ( waitid , int , which , pid_t , upid , struct siginfo __user * , infop , int , options , struct rusage __user * , ru ) { struct rusage r ; struct waitid_info info = { . status = 0 } ; long err = kernel_waitid ( which , upid , & info , options , ru ? & r : NULL ) ; int signo = 0 ; if ( err > 0 ) { signo = SIGCHLD ; err = 0 ; <S2SV_StartBug> } <S2SV_EndBug> if ( ! err ) { if ( ru && copy_to_user ( ru , & r , sizeof ( struct rusage ) ) ) return - EFAULT ; } if ( ! infop ) return err ; user_access_begin ( ) ; unsafe_put_user ( signo , & infop -> si_signo , Efault ) ; unsafe_put_user ( 0 , & infop -> si_errno , Efault ) ; unsafe_put_user ( info . cause , & infop -> si_code , Efault ) ; unsafe_put_user ( info . pid , & infop -> si_pid , Efault ) ; unsafe_put_user ( info . uid , & infop -> si_uid , Efault ) ; unsafe_put_user ( info . status , & infop -> si_status , Efault ) ; user_access_end ( ) ; return err ; Efault : user_access_end ( ) ; return - EFAULT ; }
<S2SV_StartBug> static void write_ref_frames ( const VP9_COMP * cpi , vp9_writer * w ) { <S2SV_EndBug> const VP9_COMMON * const cm = & cpi -> common ; const MACROBLOCKD * const xd = & cpi -> mb . e_mbd ; const MB_MODE_INFO * const mbmi = & xd -> mi [ 0 ] -> mbmi ; const int is_compound = has_second_ref ( mbmi ) ; const int segment_id = mbmi -> segment_id ; <S2SV_StartBug> if ( vp9_segfeature_active ( & cm -> seg , segment_id , SEG_LVL_REF_FRAME ) ) { <S2SV_EndBug> <S2SV_StartBug> assert ( ! is_compound ) ; <S2SV_EndBug> assert ( mbmi -> ref_frame [ 0 ] == vp9_get_segdata ( & cm -> seg , segment_id , SEG_LVL_REF_FRAME ) ) ; } else { <S2SV_StartBug> if ( cm -> reference_mode == REFERENCE_MODE_SELECT ) { <S2SV_EndBug> vp9_write ( w , is_compound , vp9_get_reference_mode_prob ( cm , xd ) ) ; } else { assert ( ! is_compound == ( cm -> reference_mode == SINGLE_REFERENCE ) ) ; } if ( is_compound ) { <S2SV_StartBug> vp9_write ( w , mbmi -> ref_frame [ 0 ] == GOLDEN_FRAME , <S2SV_EndBug> vp9_get_pred_prob_comp_ref_p ( cm , xd ) ) ; } else { const int bit0 = mbmi -> ref_frame [ 0 ] != LAST_FRAME ; <S2SV_StartBug> vp9_write ( w , bit0 , vp9_get_pred_prob_single_ref_p1 ( cm , xd ) ) ; <S2SV_EndBug> if ( bit0 ) { const int bit1 = mbmi -> ref_frame [ 0 ] != GOLDEN_FRAME ; <S2SV_StartBug> vp9_write ( w , bit1 , vp9_get_pred_prob_single_ref_p2 ( cm , xd ) ) ; <S2SV_EndBug> } } } }
static int crypto_report_acomp ( struct sk_buff * skb , struct crypto_alg * alg ) { struct crypto_report_acomp racomp ; <S2SV_StartBug> strlcpy ( racomp . type , "acomp" , sizeof ( racomp . type ) ) ; <S2SV_EndBug> if ( nla_put ( skb , CRYPTOCFGA_REPORT_ACOMP , sizeof ( struct crypto_report_acomp ) , & racomp ) ) goto nla_put_failure ; return 0 ; nla_put_failure : return - EMSGSIZE ; }
<S2SV_StartBug> void * H264SwDecMalloc ( u32 size ) { <S2SV_EndBug> <S2SV_StartBug> return malloc ( size ) ; <S2SV_EndBug> }
static int tpacket_rcv ( struct sk_buff * skb , struct net_device * dev , struct packet_type * pt , struct net_device * orig_dev ) { struct sock * sk ; struct packet_sock * po ; struct sockaddr_ll * sll ; union { struct tpacket_hdr * h1 ; struct tpacket2_hdr * h2 ; void * raw ; } h ; u8 * skb_head = skb -> data ; int skb_len = skb -> len ; unsigned int snaplen , res ; unsigned long status = TP_STATUS_LOSING | TP_STATUS_USER ; unsigned short macoff , netoff , hdrlen ; struct sk_buff * copy_skb = NULL ; struct timeval tv ; struct timespec ts ; struct skb_shared_hwtstamps * shhwtstamps = skb_hwtstamps ( skb ) ; if ( skb -> pkt_type == PACKET_LOOPBACK ) goto drop ; sk = pt -> af_packet_priv ; po = pkt_sk ( sk ) ; if ( ! net_eq ( dev_net ( dev ) , sock_net ( sk ) ) ) goto drop ; if ( dev -> header_ops ) { if ( sk -> sk_type != SOCK_DGRAM ) skb_push ( skb , skb -> data - skb_mac_header ( skb ) ) ; else if ( skb -> pkt_type == PACKET_OUTGOING ) { skb_pull ( skb , skb_network_offset ( skb ) ) ; } } if ( skb -> ip_summed == CHECKSUM_PARTIAL ) status |= TP_STATUS_CSUMNOTREADY ; snaplen = skb -> len ; res = run_filter ( skb , sk , snaplen ) ; if ( ! res ) goto drop_n_restore ; if ( snaplen > res ) snaplen = res ; if ( sk -> sk_type == SOCK_DGRAM ) { macoff = netoff = TPACKET_ALIGN ( po -> tp_hdrlen ) + 16 + po -> tp_reserve ; } else { unsigned maclen = skb_network_offset ( skb ) ; netoff = TPACKET_ALIGN ( po -> tp_hdrlen + ( maclen < 16 ? 16 : maclen ) ) + po -> tp_reserve ; macoff = netoff - maclen ; } if ( macoff + snaplen > po -> rx_ring . frame_size ) { if ( po -> copy_thresh && atomic_read ( & sk -> sk_rmem_alloc ) + skb -> truesize < ( unsigned ) sk -> sk_rcvbuf ) { if ( skb_shared ( skb ) ) { copy_skb = skb_clone ( skb , GFP_ATOMIC ) ; } else { copy_skb = skb_get ( skb ) ; skb_head = skb -> data ; } if ( copy_skb ) skb_set_owner_r ( copy_skb , sk ) ; } snaplen = po -> rx_ring . frame_size - macoff ; if ( ( int ) snaplen < 0 ) snaplen = 0 ; } spin_lock ( & sk -> sk_receive_queue . lock ) ; h . raw = packet_current_frame ( po , & po -> rx_ring , TP_STATUS_KERNEL ) ; if ( ! h . raw ) goto ring_is_full ; packet_increment_head ( & po -> rx_ring ) ; po -> stats . tp_packets ++ ; if ( copy_skb ) { status |= TP_STATUS_COPY ; __skb_queue_tail ( & sk -> sk_receive_queue , copy_skb ) ; } if ( ! po -> stats . tp_drops ) status &= ~ TP_STATUS_LOSING ; spin_unlock ( & sk -> sk_receive_queue . lock ) ; skb_copy_bits ( skb , 0 , h . raw + macoff , snaplen ) ; switch ( po -> tp_version ) { case TPACKET_V1 : h . h1 -> tp_len = skb -> len ; h . h1 -> tp_snaplen = snaplen ; h . h1 -> tp_mac = macoff ; h . h1 -> tp_net = netoff ; if ( ( po -> tp_tstamp & SOF_TIMESTAMPING_SYS_HARDWARE ) && shhwtstamps -> syststamp . tv64 ) tv = ktime_to_timeval ( shhwtstamps -> syststamp ) ; else if ( ( po -> tp_tstamp & SOF_TIMESTAMPING_RAW_HARDWARE ) && shhwtstamps -> hwtstamp . tv64 ) tv = ktime_to_timeval ( shhwtstamps -> hwtstamp ) ; else if ( skb -> tstamp . tv64 ) tv = ktime_to_timeval ( skb -> tstamp ) ; else do_gettimeofday ( & tv ) ; h . h1 -> tp_sec = tv . tv_sec ; h . h1 -> tp_usec = tv . tv_usec ; hdrlen = sizeof ( * h . h1 ) ; break ; case TPACKET_V2 : h . h2 -> tp_len = skb -> len ; h . h2 -> tp_snaplen = snaplen ; h . h2 -> tp_mac = macoff ; h . h2 -> tp_net = netoff ; if ( ( po -> tp_tstamp & SOF_TIMESTAMPING_SYS_HARDWARE ) && shhwtstamps -> syststamp . tv64 ) ts = ktime_to_timespec ( shhwtstamps -> syststamp ) ; else if ( ( po -> tp_tstamp & SOF_TIMESTAMPING_RAW_HARDWARE ) && shhwtstamps -> hwtstamp . tv64 ) ts = ktime_to_timespec ( shhwtstamps -> hwtstamp ) ; else if ( skb -> tstamp . tv64 ) ts = ktime_to_timespec ( skb -> tstamp ) ; else getnstimeofday ( & ts ) ; h . h2 -> tp_sec = ts . tv_sec ; h . h2 -> tp_nsec = ts . tv_nsec ; if ( vlan_tx_tag_present ( skb ) ) { h . h2 -> tp_vlan_tci = vlan_tx_tag_get ( skb ) ; status |= TP_STATUS_VLAN_VALID ; } else { h . h2 -> tp_vlan_tci = 0 ; } <S2SV_StartBug> hdrlen = sizeof ( * h . h2 ) ; <S2SV_EndBug> break ; default : BUG ( ) ; } sll = h . raw + TPACKET_ALIGN ( hdrlen ) ; sll -> sll_halen = dev_parse_header ( skb , sll -> sll_addr ) ; sll -> sll_family = AF_PACKET ; sll -> sll_hatype = dev -> type ; sll -> sll_protocol = skb -> protocol ; sll -> sll_pkttype = skb -> pkt_type ; if ( unlikely ( po -> origdev ) ) sll -> sll_ifindex = orig_dev -> ifindex ; else sll -> sll_ifindex = dev -> ifindex ; __packet_set_status ( po , h . raw , status ) ; smp_mb ( ) ; # if ARCH_IMPLEMENTS_FLUSH_DCACHE_PAGE == 1 { u8 * start , * end ; end = ( u8 * ) PAGE_ALIGN ( ( unsigned long ) h . raw + macoff + snaplen ) ; for ( start = h . raw ; start < end ; start += PAGE_SIZE ) flush_dcache_page ( pgv_to_page ( start ) ) ; } # endif sk -> sk_data_ready ( sk , 0 ) ; drop_n_restore : if ( skb_head != skb -> data && skb_shared ( skb ) ) { skb -> data = skb_head ; skb -> len = skb_len ; } drop : kfree_skb ( skb ) ; return 0 ; ring_is_full : po -> stats . tp_drops ++ ; spin_unlock ( & sk -> sk_receive_queue . lock ) ; sk -> sk_data_ready ( sk , 0 ) ; kfree_skb ( copy_skb ) ; goto drop_n_restore ; }
static int amd_gpio_remove ( struct platform_device * pdev ) { struct amd_gpio * gpio_dev ; gpio_dev = platform_get_drvdata ( pdev ) ; gpiochip_remove ( & gpio_dev -> gc ) ; <S2SV_StartBug> pinctrl_unregister ( gpio_dev -> pctrl ) ; <S2SV_EndBug> return 0 ; }
char * path_name ( const struct name_path * path , const char * name ) { const struct name_path * p ; char * n , * m ; int nlen = strlen ( name ) ; int len = nlen + 1 ; for ( p = path ; p ; p = p -> up ) { if ( p -> elem_len ) len += p -> elem_len + 1 ; } n = xmalloc ( len ) ; m = n + len - ( nlen + 1 ) ; <S2SV_StartBug> strcpy ( m , name ) ; <S2SV_EndBug> for ( p = path ; p ; p = p -> up ) { if ( p -> elem_len ) { m -= p -> elem_len + 1 ; memcpy ( m , p -> elem , p -> elem_len ) ; m [ p -> elem_len ] = '/' ; } } return n ; }
void vp9_adapt_mv_probs ( VP9_COMMON * cm , int allow_hp ) { int i , j ; <S2SV_StartBug> nmv_context * fc = & cm -> fc . nmvc ; <S2SV_EndBug> const nmv_context * pre_fc = & cm -> frame_contexts [ cm -> frame_context_idx ] . nmvc ; const nmv_context_counts * counts = & cm -> counts . mv ; <S2SV_StartBug> adapt_probs ( vp9_mv_joint_tree , pre_fc -> joints , counts -> joints , fc -> joints ) ; <S2SV_EndBug> for ( i = 0 ; i < 2 ; ++ i ) { nmv_component * comp = & fc -> comps [ i ] ; const nmv_component * pre_comp = & pre_fc -> comps [ i ] ; const nmv_component_counts * c = & counts -> comps [ i ] ; <S2SV_StartBug> comp -> sign = adapt_prob ( pre_comp -> sign , c -> sign ) ; <S2SV_EndBug> <S2SV_StartBug> adapt_probs ( vp9_mv_class_tree , pre_comp -> classes , c -> classes , <S2SV_EndBug> comp -> classes ) ; <S2SV_StartBug> adapt_probs ( vp9_mv_class0_tree , pre_comp -> class0 , c -> class0 , comp -> class0 ) ; <S2SV_EndBug> for ( j = 0 ; j < MV_OFFSET_BITS ; ++ j ) <S2SV_StartBug> comp -> bits [ j ] = adapt_prob ( pre_comp -> bits [ j ] , c -> bits [ j ] ) ; <S2SV_EndBug> for ( j = 0 ; j < CLASS0_SIZE ; ++ j ) <S2SV_StartBug> adapt_probs ( vp9_mv_fp_tree , pre_comp -> class0_fp [ j ] , c -> class0_fp [ j ] , <S2SV_EndBug> comp -> class0_fp [ j ] ) ; <S2SV_StartBug> adapt_probs ( vp9_mv_fp_tree , pre_comp -> fp , c -> fp , comp -> fp ) ; <S2SV_EndBug> if ( allow_hp ) { <S2SV_StartBug> comp -> class0_hp = adapt_prob ( pre_comp -> class0_hp , c -> class0_hp ) ; <S2SV_EndBug> <S2SV_StartBug> comp -> hp = adapt_prob ( pre_comp -> hp , c -> hp ) ; <S2SV_EndBug> } } }
static int do_ip_vs_set_ctl ( struct sock * sk , int cmd , void __user * user , unsigned int len ) { int ret ; unsigned char arg [ MAX_ARG_LEN ] ; struct ip_vs_service_user * usvc_compat ; struct ip_vs_service_user_kern usvc ; struct ip_vs_service * svc ; struct ip_vs_dest_user * udest_compat ; struct ip_vs_dest_user_kern udest ; if ( ! capable ( CAP_NET_ADMIN ) ) return - EPERM ; <S2SV_StartBug> if ( len != set_arglen [ SET_CMDID ( cmd ) ] ) { <S2SV_EndBug> pr_err ( "set_ctl:<S2SV_blank>len<S2SV_blank>%u<S2SV_blank>!=<S2SV_blank>%u\\n" , len , set_arglen [ SET_CMDID ( cmd ) ] ) ; return - EINVAL ; } if ( copy_from_user ( arg , user , len ) != 0 ) return - EFAULT ; ip_vs_use_count_inc ( ) ; if ( mutex_lock_interruptible ( & __ip_vs_mutex ) ) { ret = - ERESTARTSYS ; goto out_dec ; } if ( cmd == IP_VS_SO_SET_FLUSH ) { ret = ip_vs_flush ( ) ; goto out_unlock ; } else if ( cmd == IP_VS_SO_SET_TIMEOUT ) { ret = ip_vs_set_timeout ( ( struct ip_vs_timeout_user * ) arg ) ; goto out_unlock ; } else if ( cmd == IP_VS_SO_SET_STARTDAEMON ) { struct ip_vs_daemon_user * dm = ( struct ip_vs_daemon_user * ) arg ; ret = start_sync_thread ( dm -> state , dm -> mcast_ifn , dm -> syncid ) ; goto out_unlock ; } else if ( cmd == IP_VS_SO_SET_STOPDAEMON ) { struct ip_vs_daemon_user * dm = ( struct ip_vs_daemon_user * ) arg ; ret = stop_sync_thread ( dm -> state ) ; goto out_unlock ; } usvc_compat = ( struct ip_vs_service_user * ) arg ; udest_compat = ( struct ip_vs_dest_user * ) ( usvc_compat + 1 ) ; ip_vs_copy_usvc_compat ( & usvc , usvc_compat ) ; ip_vs_copy_udest_compat ( & udest , udest_compat ) ; if ( cmd == IP_VS_SO_SET_ZERO ) { if ( ! usvc . fwmark && ! usvc . addr . ip && ! usvc . port ) { ret = ip_vs_zero_all ( ) ; goto out_unlock ; } } if ( usvc . protocol != IPPROTO_TCP && usvc . protocol != IPPROTO_UDP ) { pr_err ( "set_ctl:<S2SV_blank>invalid<S2SV_blank>protocol:<S2SV_blank>%d<S2SV_blank>%pI4:%d<S2SV_blank>%s\\n" , usvc . protocol , & usvc . addr . ip , ntohs ( usvc . port ) , usvc . sched_name ) ; ret = - EFAULT ; goto out_unlock ; } if ( usvc . fwmark == 0 ) svc = __ip_vs_service_get ( usvc . af , usvc . protocol , & usvc . addr , usvc . port ) ; else svc = __ip_vs_svc_fwm_get ( usvc . af , usvc . fwmark ) ; if ( cmd != IP_VS_SO_SET_ADD && ( svc == NULL || svc -> protocol != usvc . protocol ) ) { ret = - ESRCH ; goto out_unlock ; } switch ( cmd ) { case IP_VS_SO_SET_ADD : if ( svc != NULL ) ret = - EEXIST ; else ret = ip_vs_add_service ( & usvc , & svc ) ; break ; case IP_VS_SO_SET_EDIT : ret = ip_vs_edit_service ( svc , & usvc ) ; break ; case IP_VS_SO_SET_DEL : ret = ip_vs_del_service ( svc ) ; if ( ! ret ) goto out_unlock ; break ; case IP_VS_SO_SET_ZERO : ret = ip_vs_zero_service ( svc ) ; break ; case IP_VS_SO_SET_ADDDEST : ret = ip_vs_add_dest ( svc , & udest ) ; break ; case IP_VS_SO_SET_EDITDEST : ret = ip_vs_edit_dest ( svc , & udest ) ; break ; case IP_VS_SO_SET_DELDEST : ret = ip_vs_del_dest ( svc , & udest ) ; break ; default : ret = - EINVAL ; } if ( svc ) ip_vs_service_put ( svc ) ; out_unlock : mutex_unlock ( & __ip_vs_mutex ) ; out_dec : ip_vs_use_count_dec ( ) ; return ret ; }
static void urlParsePostBody ( struct URL * url , const struct HttpConnection * http , const char * buf , int len ) { struct HashMap contentType ; initHashMap ( & contentType , urlDestroyHashMapEntry , NULL ) ; const char * ctHeader = getFromHashMap ( & http -> header , "content-type" ) ; urlParseHeaderLine ( & contentType , ctHeader , ctHeader ? strlen ( ctHeader ) : 0 ) ; if ( getRefFromHashMap ( & contentType , "application/x-www-form-urlencoded" ) ) { urlParseQueryString ( & url -> args , buf , len ) ; } else if ( getRefFromHashMap ( & contentType , "multipart/form-data" ) ) { const char * boundary = getFromHashMap ( & contentType , "boundary" ) ; if ( boundary && * boundary ) { const char * lastPart = NULL ; for ( const char * part = buf ; len > 0 ; ) { const char * ptr ; if ( ( part == buf && ( ptr = urlMemstr ( part , len , "--" ) ) != NULL ) || ( ptr = urlMemstr ( part , len , "\\r\\n--" ) ) != NULL ) { len -= ptr - part + ( part == buf ? 2 : 4 ) ; part = ptr + ( part == buf ? 2 : 4 ) ; if ( ! urlMemcmp ( part , len , boundary ) ) { int i = strlen ( boundary ) ; len -= i ; part += i ; if ( ! urlMemcmp ( part , len , "\\r\\n" ) ) { len -= 2 ; part += 2 ; if ( lastPart ) { urlParsePart ( url , lastPart , ptr - lastPart ) ; } else { if ( ptr != buf ) { info ( "[http]<S2SV_blank>Ignoring<S2SV_blank>prologue<S2SV_blank>before<S2SV_blank>\\"multipart/form-data\\"!" ) ; } } lastPart = part ; } else if ( ! urlMemcmp ( part , len , "--\\r\\n" ) ) { len -= 4 ; part += 4 ; urlParsePart ( url , lastPart , ptr - lastPart ) ; lastPart = NULL ; if ( len > 0 ) { info ( "[http]<S2SV_blank>Ignoring<S2SV_blank>epilogue<S2SV_blank>past<S2SV_blank>end<S2SV_blank>of<S2SV_blank>\\"multipart/" "form-data\\"!" ) ; } } } } <S2SV_StartBug> } <S2SV_EndBug> if ( lastPart ) { <S2SV_StartBug> warn ( "[http]<S2SV_blank>Missing<S2SV_blank>final<S2SV_blank>\\"boundary\\"<S2SV_blank>for<S2SV_blank>\\"multipart/form-data\\"!" ) ; <S2SV_EndBug> } } else { warn ( "[http]<S2SV_blank>Missing<S2SV_blank>\\"boundary\\"<S2SV_blank>information<S2SV_blank>for<S2SV_blank>\\"multipart/form-data\\"!" ) ; } } destroyHashMap ( & contentType ) ; }
error_t rawSocketSendIpPacket ( Socket * socket , const SocketMsg * message , uint_t flags ) { error_t error ; size_t offset ; NetBuffer * buffer ; NetInterface * interface ; IpPseudoHeader pseudoHeader ; NetTxAncillary ancillary ; <S2SV_StartBug> interface = socket -> interface ; <S2SV_EndBug> buffer = ipAllocBuffer ( 0 , & offset ) ; if ( buffer == NULL ) return ERROR_OUT_OF_MEMORY ; do { error = netBufferAppend ( buffer , message -> data , message -> length ) ; if ( error ) break ; # if ( IPV4_SUPPORT == ENABLED ) if ( message -> destIpAddr . length == sizeof ( Ipv4Addr ) ) { Ipv4Addr srcIpAddr ; error = ipv4SelectSourceAddr ( & interface , message -> destIpAddr . ipv4Addr , & srcIpAddr ) ; if ( error ) break ; pseudoHeader . length = sizeof ( Ipv4PseudoHeader ) ; pseudoHeader . ipv4Data . srcAddr = srcIpAddr ; pseudoHeader . ipv4Data . destAddr = message -> destIpAddr . ipv4Addr ; pseudoHeader . ipv4Data . reserved = 0 ; pseudoHeader . ipv4Data . protocol = socket -> protocol ; pseudoHeader . ipv4Data . length = htons ( message -> length ) ; } else # endif # if ( IPV6_SUPPORT == ENABLED ) if ( message -> destIpAddr . length == sizeof ( Ipv6Addr ) ) { error = ipv6SelectSourceAddr ( & interface , & message -> destIpAddr . ipv6Addr , & pseudoHeader . ipv6Data . srcAddr ) ; if ( error ) break ; pseudoHeader . length = sizeof ( Ipv6PseudoHeader ) ; pseudoHeader . ipv6Data . destAddr = message -> destIpAddr . ipv6Addr ; pseudoHeader . ipv6Data . length = htonl ( message -> length ) ; pseudoHeader . ipv6Data . reserved [ 0 ] = 0 ; pseudoHeader . ipv6Data . reserved [ 1 ] = 0 ; pseudoHeader . ipv6Data . reserved [ 2 ] = 0 ; pseudoHeader . ipv6Data . nextHeader = socket -> protocol ; } else # endif { error = ERROR_FAILURE ; break ; } ancillary = NET_DEFAULT_TX_ANCILLARY ; if ( message -> ttl != 0 ) { ancillary . ttl = message -> ttl ; } else if ( ipIsMulticastAddr ( & message -> destIpAddr ) ) { ancillary . ttl = socket -> multicastTtl ; } else { ancillary . ttl = socket -> ttl ; } if ( flags & SOCKET_FLAG_DONT_ROUTE ) { ancillary . dontRoute = TRUE ; } # if ( IP_DIFF_SERV_SUPPORT == ENABLED ) ancillary . dscp = socket -> dscp ; # endif # if ( ETH_SUPPORT == ENABLED ) ancillary . srcMacAddr = message -> srcMacAddr ; ancillary . destMacAddr = message -> destMacAddr ; # endif # if ( ETH_VLAN_SUPPORT == ENABLED ) ancillary . vlanPcp = socket -> vlanPcp ; ancillary . vlanDei = socket -> vlanDei ; # endif # if ( ETH_VMAN_SUPPORT == ENABLED ) ancillary . vmanPcp = socket -> vmanPcp ; ancillary . vmanDei = socket -> vmanDei ; # endif # if ( ETH_PORT_TAGGING_SUPPORT == ENABLED ) ancillary . port = message -> switchPort ; # endif # if ( ETH_TIMESTAMP_SUPPORT == ENABLED ) ancillary . timestampId = message -> timestampId ; # endif error = ipSendDatagram ( interface , & pseudoHeader , buffer , offset , & ancillary ) ; if ( error ) break ; } while ( 0 ) ; netBufferFree ( buffer ) ; return error ; }
static void fill_variance_tree ( void * data , BLOCK_SIZE bsize ) { <S2SV_StartBug> variance_node node ; <S2SV_EndBug> tree_to_node ( data , bsize , & node ) ; sum_2_variances ( node . split [ 0 ] , node . split [ 1 ] , & node . part_variances -> horz [ 0 ] ) ; sum_2_variances ( node . split [ 2 ] , node . split [ 3 ] , & node . part_variances -> horz [ 1 ] ) ; sum_2_variances ( node . split [ 0 ] , node . split [ 2 ] , & node . part_variances -> vert [ 0 ] ) ; sum_2_variances ( node . split [ 1 ] , node . split [ 3 ] , & node . part_variances -> vert [ 1 ] ) ; sum_2_variances ( & node . part_variances -> vert [ 0 ] , & node . part_variances -> vert [ 1 ] , & node . part_variances -> none ) ; }
int vp9_prob_diff_update_savings_search_model ( const unsigned int * ct , <S2SV_StartBug> const vp9_prob * oldp , <S2SV_EndBug> vp9_prob * bestp , <S2SV_StartBug> vp9_prob upd ) { <S2SV_EndBug> int i , old_b , new_b , update_b , savings , bestsavings , step ; int newp ; <S2SV_StartBug> vp9_prob bestnewp , newplist [ ENTROPY_NODES ] , oldplist [ ENTROPY_NODES ] ; <S2SV_EndBug> vp9_model_to_full_probs ( oldp , oldplist ) ; <S2SV_StartBug> vpx_memcpy ( newplist , oldp , sizeof ( vp9_prob ) * UNCONSTRAINED_NODES ) ; <S2SV_EndBug> for ( i = UNCONSTRAINED_NODES , old_b = 0 ; i < ENTROPY_NODES ; ++ i ) old_b += cost_branch256 ( ct + 2 * i , oldplist [ i ] ) ; old_b += cost_branch256 ( ct + 2 * PIVOT_NODE , oldplist [ PIVOT_NODE ] ) ; bestsavings = 0 ; bestnewp = oldp [ PIVOT_NODE ] ; <S2SV_StartBug> step = ( * bestp > oldp [ PIVOT_NODE ] ? - 1 : 1 ) ; <S2SV_EndBug> for ( newp = * bestp ; newp != oldp [ PIVOT_NODE ] ; newp += step ) { if ( newp < 1 || newp > 255 ) continue ; newplist [ PIVOT_NODE ] = newp ; vp9_model_to_full_probs ( newplist , newplist ) ; for ( i = UNCONSTRAINED_NODES , new_b = 0 ; i < ENTROPY_NODES ; ++ i ) new_b += cost_branch256 ( ct + 2 * i , newplist [ i ] ) ; new_b += cost_branch256 ( ct + 2 * PIVOT_NODE , newplist [ PIVOT_NODE ] ) ; update_b = prob_diff_update_cost ( newp , oldp [ PIVOT_NODE ] ) + vp9_cost_upd256 ; savings = old_b - new_b - update_b ; if ( savings > bestsavings ) { bestsavings = savings ; bestnewp = newp ; } } <S2SV_StartBug> * bestp = bestnewp ; <S2SV_EndBug> return bestsavings ; }
<S2SV_StartBug> static int target_xcopy_locate_se_dev_e4 ( const unsigned char * dev_wwn , <S2SV_EndBug> <S2SV_StartBug> struct se_device * * found_dev ) <S2SV_EndBug> { <S2SV_StartBug> struct xcopy_dev_search_info info ; <S2SV_EndBug> int ret ; memset ( & info , 0 , sizeof ( info ) ) ; info . dev_wwn = dev_wwn ; ret = target_for_each_device ( target_xcopy_locate_se_dev_e4_iter , & info ) ; if ( ret == 1 ) { * found_dev = info . found_dev ; return 0 ; <S2SV_StartBug> } else { <S2SV_EndBug> pr_debug_ratelimited ( "Unable<S2SV_blank>to<S2SV_blank>locate<S2SV_blank>0xe4<S2SV_blank>descriptor<S2SV_blank>for<S2SV_blank>EXTENDED_COPY\\n" ) ; return - EINVAL ; } <S2SV_StartBug> } <S2SV_EndBug>
static int hwsim_new_radio_nl ( struct sk_buff * msg , struct genl_info * info ) { struct hwsim_new_radio_params param = { 0 } ; const char * hwname = NULL ; int ret ; param . reg_strict = info -> attrs [ HWSIM_ATTR_REG_STRICT_REG ] ; param . p2p_device = info -> attrs [ HWSIM_ATTR_SUPPORT_P2P_DEVICE ] ; param . channels = channels ; param . destroy_on_close = info -> attrs [ HWSIM_ATTR_DESTROY_RADIO_ON_CLOSE ] ; if ( info -> attrs [ HWSIM_ATTR_CHANNELS ] ) param . channels = nla_get_u32 ( info -> attrs [ HWSIM_ATTR_CHANNELS ] ) ; if ( info -> attrs [ HWSIM_ATTR_NO_VIF ] ) param . no_vif = true ; if ( info -> attrs [ HWSIM_ATTR_RADIO_NAME ] ) { hwname = kasprintf ( GFP_KERNEL , "%.*s" , nla_len ( info -> attrs [ HWSIM_ATTR_RADIO_NAME ] ) , ( char * ) nla_data ( info -> attrs [ HWSIM_ATTR_RADIO_NAME ] ) ) ; if ( ! hwname ) return - ENOMEM ; param . hwname = hwname ; } if ( info -> attrs [ HWSIM_ATTR_USE_CHANCTX ] ) param . use_chanctx = true ; else param . use_chanctx = ( param . channels > 1 ) ; if ( info -> attrs [ HWSIM_ATTR_REG_HINT_ALPHA2 ] ) param . reg_alpha2 = nla_data ( info -> attrs [ HWSIM_ATTR_REG_HINT_ALPHA2 ] ) ; if ( info -> attrs [ HWSIM_ATTR_REG_CUSTOM_REG ] ) { u32 idx = nla_get_u32 ( info -> attrs [ HWSIM_ATTR_REG_CUSTOM_REG ] ) ; <S2SV_StartBug> if ( idx >= ARRAY_SIZE ( hwsim_world_regdom_custom ) ) <S2SV_EndBug> return - EINVAL ; <S2SV_StartBug> param . regd = hwsim_world_regdom_custom [ idx ] ; <S2SV_EndBug> } ret = mac80211_hwsim_new_radio ( info , & param ) ; kfree ( hwname ) ; return ret ; }
static void ReadReason ( rfbClient * client ) { uint32_t reasonLen ; char * reason ; if ( ! ReadFromRFBServer ( client , ( char * ) & reasonLen , 4 ) ) return ; reasonLen = rfbClientSwap32IfLE ( reasonLen ) ; <S2SV_StartBug> reason = malloc ( ( uint64_t ) reasonLen + 1 ) ; <S2SV_EndBug> if ( ! ReadFromRFBServer ( client , reason , reasonLen ) ) { free ( reason ) ; return ; } reason [ reasonLen ] = 0 ; rfbClientLog ( "VNC<S2SV_blank>connection<S2SV_blank>failed:<S2SV_blank>%s\\n" , reason ) ; free ( reason ) ; }
static void vmx_refresh_apicv_exec_ctrl ( struct kvm_vcpu * vcpu ) { struct vcpu_vmx * vmx = to_vmx ( vcpu ) ; vmcs_write32 ( PIN_BASED_VM_EXEC_CONTROL , vmx_pin_based_exec_ctrl ( vmx ) ) ; <S2SV_StartBug> } <S2SV_EndBug>
static int print_lcp_config_options ( netdissect_options * ndo , const u_char * p , int length ) { int len , opt ; if ( length < 2 ) return 0 ; ND_TCHECK2 ( * p , 2 ) ; len = p [ 1 ] ; opt = p [ 0 ] ; if ( length < len ) return 0 ; if ( len < 2 ) { if ( ( opt >= LCPOPT_MIN ) && ( opt <= LCPOPT_MAX ) ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Option<S2SV_blank>(0x%02x),<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>2)" , lcpconfopts [ opt ] , opt , len ) ) ; else ND_PRINT ( ( ndo , "\\n\\tunknown<S2SV_blank>LCP<S2SV_blank>option<S2SV_blank>0x%02x" , opt ) ) ; return 0 ; } if ( ( opt >= LCPOPT_MIN ) && ( opt <= LCPOPT_MAX ) ) ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Option<S2SV_blank>(0x%02x),<S2SV_blank>length<S2SV_blank>%u" , lcpconfopts [ opt ] , opt , len ) ) ; else { ND_PRINT ( ( ndo , "\\n\\tunknown<S2SV_blank>LCP<S2SV_blank>option<S2SV_blank>0x%02x" , opt ) ) ; return len ; } switch ( opt ) { case LCPOPT_VEXT : if ( len < 6 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>6)" ) ) ; return len ; } <S2SV_StartBug> ND_TCHECK2 ( * ( p + 2 ) , 3 ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , ":<S2SV_blank>Vendor:<S2SV_blank>%s<S2SV_blank>(%u)" , tok2str ( oui_values , "Unknown" , EXTRACT_24BITS ( p + 2 ) ) , EXTRACT_24BITS ( p + 2 ) ) ) ; # if 0 ND_TCHECK ( p [ 5 ] ) ; ND_PRINT ( ( ndo , ",<S2SV_blank>kind:<S2SV_blank>0x%02x" , p [ 5 ] ) ) ; ND_PRINT ( ( ndo , ",<S2SV_blank>Value:<S2SV_blank>0x" ) ) ; for ( i = 0 ; i < len - 6 ; i ++ ) { ND_TCHECK ( p [ 6 + i ] ) ; ND_PRINT ( ( ndo , "%02x" , p [ 6 + i ] ) ) ; } # endif break ; case LCPOPT_MRU : if ( len != 4 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>=<S2SV_blank>4)" ) ) ; return len ; } <S2SV_StartBug> ND_TCHECK2 ( * ( p + 2 ) , 2 ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , ":<S2SV_blank>%u" , EXTRACT_16BITS ( p + 2 ) ) ) ; break ; case LCPOPT_ACCM : if ( len != 6 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>=<S2SV_blank>6)" ) ) ; return len ; } <S2SV_StartBug> ND_TCHECK2 ( * ( p + 2 ) , 4 ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , ":<S2SV_blank>0x%08x" , EXTRACT_32BITS ( p + 2 ) ) ) ; break ; case LCPOPT_AP : if ( len < 4 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>4)" ) ) ; return len ; } <S2SV_StartBug> ND_TCHECK2 ( * ( p + 2 ) , 2 ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , ":<S2SV_blank>%s" , tok2str ( ppptype2str , "Unknown<S2SV_blank>Auth<S2SV_blank>Proto<S2SV_blank>(0x04x)" , EXTRACT_16BITS ( p + 2 ) ) ) ) ; switch ( EXTRACT_16BITS ( p + 2 ) ) { case PPP_CHAP : ND_TCHECK ( p [ 4 ] ) ; ND_PRINT ( ( ndo , ",<S2SV_blank>%s" , tok2str ( authalg_values , "Unknown<S2SV_blank>Auth<S2SV_blank>Alg<S2SV_blank>%u" , p [ 4 ] ) ) ) ; break ; case PPP_PAP : case PPP_EAP : case PPP_SPAP : case PPP_SPAP_OLD : break ; default : print_unknown_data ( ndo , p , "\\n\\t" , len ) ; } break ; case LCPOPT_QP : if ( len < 4 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>4)" ) ) ; return 0 ; } <S2SV_StartBug> ND_TCHECK2 ( * ( p + 2 ) , 2 ) ; <S2SV_EndBug> if ( EXTRACT_16BITS ( p + 2 ) == PPP_LQM ) ND_PRINT ( ( ndo , ":<S2SV_blank>LQR" ) ) ; else ND_PRINT ( ( ndo , ":<S2SV_blank>unknown" ) ) ; break ; case LCPOPT_MN : if ( len != 6 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>=<S2SV_blank>6)" ) ) ; return 0 ; } <S2SV_StartBug> ND_TCHECK2 ( * ( p + 2 ) , 4 ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , ":<S2SV_blank>0x%08x" , EXTRACT_32BITS ( p + 2 ) ) ) ; break ; case LCPOPT_PFC : break ; case LCPOPT_ACFC : break ; case LCPOPT_LD : if ( len != 4 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>=<S2SV_blank>4)" ) ) ; return 0 ; } <S2SV_StartBug> ND_TCHECK2 ( * ( p + 2 ) , 2 ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , ":<S2SV_blank>0x%04x" , EXTRACT_16BITS ( p + 2 ) ) ) ; break ; case LCPOPT_CBACK : if ( len < 3 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>3)" ) ) ; return 0 ; } ND_PRINT ( ( ndo , ":<S2SV_blank>" ) ) ; ND_TCHECK ( p [ 2 ] ) ; ND_PRINT ( ( ndo , ":<S2SV_blank>Callback<S2SV_blank>Operation<S2SV_blank>%s<S2SV_blank>(%u)" , tok2str ( ppp_callback_values , "Unknown" , p [ 2 ] ) , p [ 2 ] ) ) ; break ; case LCPOPT_MLMRRU : if ( len != 4 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>=<S2SV_blank>4)" ) ) ; return 0 ; } <S2SV_StartBug> ND_TCHECK2 ( * ( p + 2 ) , 2 ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , ":<S2SV_blank>%u" , EXTRACT_16BITS ( p + 2 ) ) ) ; break ; case LCPOPT_MLED : if ( len < 3 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>3)" ) ) ; return 0 ; } ND_TCHECK ( p [ 2 ] ) ; switch ( p [ 2 ] ) { case MEDCLASS_NULL : ND_PRINT ( ( ndo , ":<S2SV_blank>Null" ) ) ; break ; case MEDCLASS_LOCAL : ND_PRINT ( ( ndo , ":<S2SV_blank>Local" ) ) ; break ; case MEDCLASS_IPV4 : if ( len != 7 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>=<S2SV_blank>7)" ) ) ; return 0 ; } ND_TCHECK2 ( * ( p + 3 ) , 4 ) ; ND_PRINT ( ( ndo , ":<S2SV_blank>IPv4<S2SV_blank>%s" , ipaddr_string ( ndo , p + 3 ) ) ) ; break ; case MEDCLASS_MAC : if ( len != 9 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>=<S2SV_blank>9)" ) ) ; return 0 ; } ND_TCHECK2 ( * ( p + 3 ) , 6 ) ; ND_PRINT ( ( ndo , ":<S2SV_blank>MAC<S2SV_blank>%s" , etheraddr_string ( ndo , p + 3 ) ) ) ; break ; case MEDCLASS_MNB : ND_PRINT ( ( ndo , ":<S2SV_blank>Magic-Num-Block" ) ) ; break ; case MEDCLASS_PSNDN : ND_PRINT ( ( ndo , ":<S2SV_blank>PSNDN" ) ) ; break ; default : ND_PRINT ( ( ndo , ":<S2SV_blank>Unknown<S2SV_blank>class<S2SV_blank>%u" , p [ 2 ] ) ) ; break ; } break ; # if 0 case LCPOPT_DEP6 : case LCPOPT_FCSALT : case LCPOPT_SDP : case LCPOPT_NUMMODE : case LCPOPT_DEP12 : case LCPOPT_DEP14 : case LCPOPT_DEP15 : case LCPOPT_DEP16 : case LCPOPT_MLSSNHF : case LCPOPT_PROP : case LCPOPT_DCEID : case LCPOPT_MPP : case LCPOPT_LCPAOPT : case LCPOPT_COBS : case LCPOPT_PE : case LCPOPT_MLHF : case LCPOPT_I18N : case LCPOPT_SDLOS : case LCPOPT_PPPMUX : break ; # endif default : if ( ndo -> ndo_vflag < 2 ) print_unknown_data ( ndo , & p [ 2 ] , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" , len - 2 ) ; break ; } if ( ndo -> ndo_vflag > 1 ) print_unknown_data ( ndo , & p [ 2 ] , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" , len - 2 ) ; return len ; trunc : ND_PRINT ( ( ndo , "[|lcp]" ) ) ; return 0 ; }
static int ceph_x_proc_ticket_reply ( struct ceph_auth_client * ac , struct ceph_crypto_key * secret , void * buf , void * end ) { void * p = buf ; <S2SV_StartBug> char * dbuf ; <S2SV_EndBug> char * ticket_buf ; u8 reply_struct_v ; u32 num ; <S2SV_StartBug> int ret ; <S2SV_EndBug> dbuf = kmalloc ( TEMP_TICKET_BUF_LEN , GFP_NOFS ) ; if ( ! dbuf ) return - ENOMEM ; ret = - ENOMEM ; ticket_buf = kmalloc ( TEMP_TICKET_BUF_LEN , GFP_NOFS ) ; if ( ! ticket_buf ) goto out_dbuf ; ceph_decode_8_safe ( & p , end , reply_struct_v , bad ) ; if ( reply_struct_v != 1 ) return - EINVAL ; ceph_decode_32_safe ( & p , end , num , bad ) ; dout ( "%d<S2SV_blank>tickets\\n" , num ) ; while ( num -- ) { <S2SV_StartBug> ret = process_one_ticket ( ac , secret , & p , end , <S2SV_EndBug> dbuf , ticket_buf ) ; if ( ret ) <S2SV_StartBug> goto out ; <S2SV_EndBug> } ret = 0 ; out : kfree ( ticket_buf ) ; out_dbuf : kfree ( dbuf ) ; return ret ; bad : <S2SV_StartBug> ret = - EINVAL ; <S2SV_EndBug> <S2SV_StartBug> goto out ; <S2SV_EndBug> }
static int validate_node ( node * tree ) { int type = TYPE ( tree ) ; int nch = NCH ( tree ) ; dfa * nt_dfa ; state * dfa_state ; int pos , arc ; assert ( ISNONTERMINAL ( type ) ) ; type -= NT_OFFSET ; if ( type >= _PyParser_Grammar . g_ndfas ) { PyErr_Format ( parser_error , "Unrecognized<S2SV_blank>node<S2SV_blank>type<S2SV_blank>%d." , TYPE ( tree ) ) ; return 0 ; } nt_dfa = & _PyParser_Grammar . g_dfa [ type ] ; REQ ( tree , nt_dfa -> d_type ) ; dfa_state = & nt_dfa -> d_state [ nt_dfa -> d_initial ] ; for ( pos = 0 ; pos < nch ; ++ pos ) { node * ch = CHILD ( tree , pos ) ; int ch_type = TYPE ( ch ) ; <S2SV_StartBug> for ( arc = 0 ; arc < dfa_state -> s_narcs ; ++ arc ) { <S2SV_EndBug> short a_label = dfa_state -> s_arc [ arc ] . a_lbl ; assert ( a_label < _PyParser_Grammar . g_ll . ll_nlabels ) ; if ( _PyParser_Grammar . g_ll . ll_label [ a_label ] . lb_type == ch_type ) { if ( ISNONTERMINAL ( ch_type ) && ! validate_node ( ch ) ) return 0 ; dfa_state = & nt_dfa -> d_state [ dfa_state -> s_arc [ arc ] . a_arrow ] ; goto arc_found ; } } { short a_label = dfa_state -> s_arc -> a_lbl ; int next_type ; if ( ! a_label ) goto illegal_num_children ; next_type = _PyParser_Grammar . g_ll . ll_label [ a_label ] . lb_type ; if ( ISNONTERMINAL ( next_type ) ) PyErr_Format ( parser_error , "Expected<S2SV_blank>node<S2SV_blank>type<S2SV_blank>%d,<S2SV_blank>got<S2SV_blank>%d." , next_type , ch_type ) ; else PyErr_Format ( parser_error , "Illegal<S2SV_blank>terminal:<S2SV_blank>expected<S2SV_blank>%s." , _PyParser_TokenNames [ next_type ] ) ; return 0 ; } arc_found : continue ; } for ( arc = 0 ; arc < dfa_state -> s_narcs ; ++ arc ) { if ( ! dfa_state -> s_arc [ arc ] . a_lbl ) { return 1 ; } } illegal_num_children : PyErr_Format ( parser_error , "Illegal<S2SV_blank>number<S2SV_blank>of<S2SV_blank>children<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>node." , nt_dfa -> d_name ) ; return 0 ; }
static VarBit * bit_catenate ( VarBit * arg1 , VarBit * arg2 ) { VarBit * result ; int bitlen1 , bitlen2 , bytelen , bit1pad , bit2shift ; bits8 * pr , * pa ; bitlen1 = VARBITLEN ( arg1 ) ; <S2SV_StartBug> bitlen2 = VARBITLEN ( arg2 ) ; <S2SV_EndBug> bytelen = VARBITTOTALLEN ( bitlen1 + bitlen2 ) ; result = ( VarBit * ) palloc ( bytelen ) ; SET_VARSIZE ( result , bytelen ) ; VARBITLEN ( result ) = bitlen1 + bitlen2 ; memcpy ( VARBITS ( result ) , VARBITS ( arg1 ) , VARBITBYTES ( arg1 ) ) ; bit1pad = VARBITPAD ( arg1 ) ; if ( bit1pad == 0 ) { memcpy ( VARBITS ( result ) + VARBITBYTES ( arg1 ) , VARBITS ( arg2 ) , VARBITBYTES ( arg2 ) ) ; } else if ( bitlen2 > 0 ) { bit2shift = BITS_PER_BYTE - bit1pad ; pr = VARBITS ( result ) + VARBITBYTES ( arg1 ) - 1 ; for ( pa = VARBITS ( arg2 ) ; pa < VARBITEND ( arg2 ) ; pa ++ ) { * pr |= ( ( * pa >> bit2shift ) & BITMASK ) ; pr ++ ; if ( pr < VARBITEND ( result ) ) * pr = ( * pa << bit1pad ) & BITMASK ; } } return result ; }
static unsigned int seedsize ( struct crypto_alg * alg ) { struct rng_alg * ralg = container_of ( alg , struct rng_alg , base ) ; <S2SV_StartBug> return alg -> cra_rng . rng_make_random ? <S2SV_EndBug> alg -> cra_rng . seedsize : ralg -> seedsize ; }
<S2SV_StartBug> static void <S2SV_EndBug> horAcc32 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) { tmsize_t stride = PredictorState ( tif ) -> stride ; uint32 * wp = ( uint32 * ) cp0 ; tmsize_t wc = cc / 4 ; <S2SV_StartBug> assert ( ( cc % ( 4 * stride ) ) == 0 ) ; <S2SV_EndBug> if ( wc > stride ) { wc -= stride ; do { REPEAT4 ( stride , wp [ stride ] += wp [ 0 ] ; wp ++ ) wc -= stride ; } while ( wc > 0 ) ; } <S2SV_StartBug> } <S2SV_EndBug>
static struct page * follow_page_pte ( struct vm_area_struct * vma , unsigned long address , pmd_t * pmd , unsigned int flags , struct dev_pagemap * * pgmap ) { struct mm_struct * mm = vma -> vm_mm ; struct page * page ; spinlock_t * ptl ; pte_t * ptep , pte ; retry : if ( unlikely ( pmd_bad ( * pmd ) ) ) return no_page_table ( vma , flags ) ; ptep = pte_offset_map_lock ( mm , pmd , address , & ptl ) ; pte = * ptep ; if ( ! pte_present ( pte ) ) { swp_entry_t entry ; if ( likely ( ! ( flags & FOLL_MIGRATION ) ) ) goto no_page ; if ( pte_none ( pte ) ) goto no_page ; entry = pte_to_swp_entry ( pte ) ; if ( ! is_migration_entry ( entry ) ) goto no_page ; pte_unmap_unlock ( ptep , ptl ) ; migration_entry_wait ( mm , pmd , address ) ; goto retry ; } if ( ( flags & FOLL_NUMA ) && pte_protnone ( pte ) ) goto no_page ; if ( ( flags & FOLL_WRITE ) && ! can_follow_write_pte ( pte , flags ) ) { pte_unmap_unlock ( ptep , ptl ) ; return NULL ; } page = vm_normal_page ( vma , address , pte ) ; if ( ! page && pte_devmap ( pte ) && ( flags & FOLL_GET ) ) { * pgmap = get_dev_pagemap ( pte_pfn ( pte ) , * pgmap ) ; if ( * pgmap ) page = pte_page ( pte ) ; else goto no_page ; } else if ( unlikely ( ! page ) ) { if ( flags & FOLL_DUMP ) { page = ERR_PTR ( - EFAULT ) ; goto out ; } if ( is_zero_pfn ( pte_pfn ( pte ) ) ) { page = pte_page ( pte ) ; } else { int ret ; ret = follow_pfn_pte ( vma , address , ptep , flags ) ; page = ERR_PTR ( ret ) ; goto out ; } } if ( flags & FOLL_SPLIT && PageTransCompound ( page ) ) { int ret ; get_page ( page ) ; pte_unmap_unlock ( ptep , ptl ) ; lock_page ( page ) ; ret = split_huge_page ( page ) ; unlock_page ( page ) ; put_page ( page ) ; if ( ret ) return ERR_PTR ( ret ) ; goto retry ; } if ( flags & FOLL_GET ) <S2SV_StartBug> get_page ( page ) ; <S2SV_EndBug> if ( flags & FOLL_TOUCH ) { if ( ( flags & FOLL_WRITE ) && ! pte_dirty ( pte ) && ! PageDirty ( page ) ) set_page_dirty ( page ) ; mark_page_accessed ( page ) ; } if ( ( flags & FOLL_MLOCK ) && ( vma -> vm_flags & VM_LOCKED ) ) { if ( PageTransCompound ( page ) ) goto out ; if ( page -> mapping && trylock_page ( page ) ) { lru_add_drain ( ) ; mlock_vma_page ( page ) ; unlock_page ( page ) ; } } out : pte_unmap_unlock ( ptep , ptl ) ; return page ; no_page : pte_unmap_unlock ( ptep , ptl ) ; if ( ! pte_none ( pte ) ) return NULL ; return no_page_table ( vma , flags ) ; }
static int unix_dgram_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct net * net = sock_net ( sk ) ; struct unix_sock * u = unix_sk ( sk ) ; struct sockaddr_un * sunaddr = msg -> msg_name ; struct sock * other = NULL ; int namelen = 0 ; int err ; unsigned int hash ; struct sk_buff * skb ; long timeo ; struct scm_cookie tmp_scm ; int max_level ; int data_len = 0 ; if ( NULL == siocb -> scm ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; <S2SV_StartBug> err = scm_send ( sock , msg , siocb -> scm ) ; <S2SV_EndBug> if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out ; if ( msg -> msg_namelen ) { err = unix_mkname ( sunaddr , msg -> msg_namelen , & hash ) ; if ( err < 0 ) goto out ; namelen = err ; } else { sunaddr = NULL ; err = - ENOTCONN ; other = unix_peer_get ( sk ) ; if ( ! other ) goto out ; } if ( test_bit ( SOCK_PASSCRED , & sock -> flags ) && ! u -> addr && ( err = unix_autobind ( sock ) ) != 0 ) goto out ; err = - EMSGSIZE ; if ( len > sk -> sk_sndbuf - 32 ) goto out ; if ( len > SKB_MAX_ALLOC ) data_len = min_t ( size_t , len - SKB_MAX_ALLOC , MAX_SKB_FRAGS * PAGE_SIZE ) ; skb = sock_alloc_send_pskb ( sk , len - data_len , data_len , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out ; err = unix_scm_to_skb ( siocb -> scm , skb , true ) ; if ( err < 0 ) goto out_free ; max_level = err + 1 ; unix_get_secdata ( siocb -> scm , skb ) ; skb_put ( skb , len - data_len ) ; skb -> data_len = data_len ; skb -> len = len ; err = skb_copy_datagram_from_iovec ( skb , 0 , msg -> msg_iov , 0 , len ) ; if ( err ) goto out_free ; timeo = sock_sndtimeo ( sk , msg -> msg_flags & MSG_DONTWAIT ) ; restart : if ( ! other ) { err = - ECONNRESET ; if ( sunaddr == NULL ) goto out_free ; other = unix_find_other ( net , sunaddr , namelen , sk -> sk_type , hash , & err ) ; if ( other == NULL ) goto out_free ; } if ( sk_filter ( other , skb ) < 0 ) { err = len ; goto out_free ; } unix_state_lock ( other ) ; err = - EPERM ; if ( ! unix_may_send ( sk , other ) ) goto out_unlock ; if ( sock_flag ( other , SOCK_DEAD ) ) { unix_state_unlock ( other ) ; sock_put ( other ) ; err = 0 ; unix_state_lock ( sk ) ; if ( unix_peer ( sk ) == other ) { unix_peer ( sk ) = NULL ; unix_state_unlock ( sk ) ; unix_dgram_disconnected ( sk , other ) ; sock_put ( other ) ; err = - ECONNREFUSED ; } else { unix_state_unlock ( sk ) ; } other = NULL ; if ( err ) goto out_free ; goto restart ; } err = - EPIPE ; if ( other -> sk_shutdown & RCV_SHUTDOWN ) goto out_unlock ; if ( sk -> sk_type != SOCK_SEQPACKET ) { err = security_unix_may_send ( sk -> sk_socket , other -> sk_socket ) ; if ( err ) goto out_unlock ; } if ( unix_peer ( other ) != sk && unix_recvq_full ( other ) ) { if ( ! timeo ) { err = - EAGAIN ; goto out_unlock ; } timeo = unix_wait_for_peer ( other , timeo ) ; err = sock_intr_errno ( timeo ) ; if ( signal_pending ( current ) ) goto out_free ; goto restart ; } if ( sock_flag ( other , SOCK_RCVTSTAMP ) ) __net_timestamp ( skb ) ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other , len ) ; sock_put ( other ) ; scm_destroy ( siocb -> scm ) ; return len ; out_unlock : unix_state_unlock ( other ) ; out_free : kfree_skb ( skb ) ; out : if ( other ) sock_put ( other ) ; scm_destroy ( siocb -> scm ) ; return err ; }
static void balloon_process ( struct work_struct * work ) { enum bp_state state = BP_DONE ; long credit ; do { mutex_lock ( & balloon_mutex ) ; credit = current_credit ( ) ; if ( credit > 0 ) { if ( balloon_is_inflated ( ) ) state = increase_reservation ( credit ) ; else state = reserve_additional_memory ( ) ; } <S2SV_StartBug> if ( credit < 0 ) <S2SV_EndBug> <S2SV_StartBug> state = decrease_reservation ( - credit , GFP_BALLOON ) ; <S2SV_EndBug> state = update_schedule ( state ) ; mutex_unlock ( & balloon_mutex ) ; cond_resched ( ) ; } while ( credit && state == BP_DONE ) ; if ( state == BP_EAGAIN ) schedule_delayed_work ( & balloon_worker , balloon_stats . schedule_delay * HZ ) ; }
WORD32 ih264d_parse_sps ( dec_struct_t * ps_dec , dec_bit_stream_t * ps_bitstrm ) { UWORD8 i ; dec_seq_params_t * ps_seq = NULL ; UWORD8 u1_profile_idc , u1_level_idc , u1_seq_parameter_set_id ; UWORD16 i2_max_frm_num ; UWORD32 * pu4_bitstrm_buf = ps_bitstrm -> pu4_buffer ; UWORD32 * pu4_bitstrm_ofst = & ps_bitstrm -> u4_ofst ; UWORD8 u1_frm , uc_constraint_set0_flag , uc_constraint_set1_flag ; UWORD32 u4_temp ; WORD32 pic_height_in_map_units_minus1 = 0 ; UWORD32 u2_pic_wd = 0 ; UWORD32 u2_pic_ht = 0 ; UWORD32 u2_frm_wd_y = 0 ; UWORD32 u2_frm_ht_y = 0 ; UWORD32 u2_frm_wd_uv = 0 ; UWORD32 u2_frm_ht_uv = 0 ; UWORD32 u2_crop_offset_y = 0 ; UWORD32 u2_crop_offset_uv = 0 ; WORD32 ret ; WORD32 i4_i ; UWORD8 u1_frame_cropping_flag , u1_frame_cropping_rect_left_ofst , u1_frame_cropping_rect_right_ofst , u1_frame_cropping_rect_top_ofst , u1_frame_cropping_rect_bottom_ofst ; SWITCHONTRACE ; u1_profile_idc = ih264d_get_bits_h264 ( ps_bitstrm , 8 ) ; COPYTHECONTEXT ( "SPS:<S2SV_blank>profile_idc" , u1_profile_idc ) ; uc_constraint_set0_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; uc_constraint_set1_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; ih264d_get_bit_h264 ( ps_bitstrm ) ; ih264d_get_bits_h264 ( ps_bitstrm , 5 ) ; if ( ( u1_profile_idc != MAIN_PROFILE_IDC ) && ( u1_profile_idc != BASE_PROFILE_IDC ) && ( u1_profile_idc != HIGH_PROFILE_IDC ) ) { if ( ( u1_profile_idc != EXTENDED_PROFILE_IDC ) || ( ( uc_constraint_set1_flag != 1 ) && ( uc_constraint_set0_flag != 1 ) ) ) { return ( ERROR_FEATURE_UNAVAIL ) ; } } u1_level_idc = ih264d_get_bits_h264 ( ps_bitstrm , 8 ) ; COPYTHECONTEXT ( "SPS:<S2SV_blank>u4_level_idc" , u1_level_idc ) ; u4_temp = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u4_temp & MASK_ERR_SEQ_SET_ID ) return ERROR_INV_SPS_PPS_T ; u1_seq_parameter_set_id = u4_temp ; COPYTHECONTEXT ( "SPS:<S2SV_blank>seq_parameter_set_id" , u1_seq_parameter_set_id ) ; ps_seq = ps_dec -> pv_scratch_sps_pps ; * ps_seq = ps_dec -> ps_sps [ u1_seq_parameter_set_id ] ; if ( NULL == ps_dec -> ps_cur_sps ) ps_dec -> ps_cur_sps = ps_seq ; ps_seq -> u1_profile_idc = u1_profile_idc ; ps_seq -> u1_level_idc = u1_level_idc ; ps_seq -> u1_seq_parameter_set_id = u1_seq_parameter_set_id ; ps_seq -> i4_chroma_format_idc = 1 ; ps_seq -> i4_bit_depth_luma_minus8 = 0 ; ps_seq -> i4_bit_depth_chroma_minus8 = 0 ; ps_seq -> i4_qpprime_y_zero_transform_bypass_flag = 0 ; ps_seq -> i4_seq_scaling_matrix_present_flag = 0 ; if ( u1_profile_idc == HIGH_PROFILE_IDC ) { ps_seq -> i4_chroma_format_idc = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( ps_seq -> i4_chroma_format_idc != 1 ) { return ERROR_INV_SPS_PPS_T ; } ps_seq -> i4_bit_depth_luma_minus8 = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( ps_seq -> i4_bit_depth_luma_minus8 != 0 ) { return ERROR_INV_SPS_PPS_T ; } ps_seq -> i4_bit_depth_chroma_minus8 = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( ps_seq -> i4_bit_depth_chroma_minus8 != 0 ) { return ERROR_INV_SPS_PPS_T ; } ps_seq -> i4_qpprime_y_zero_transform_bypass_flag = ( WORD32 ) ih264d_get_bit_h264 ( ps_bitstrm ) ; if ( ps_seq -> i4_qpprime_y_zero_transform_bypass_flag != 0 ) { return ERROR_INV_SPS_PPS_T ; } ps_seq -> i4_seq_scaling_matrix_present_flag = ( WORD32 ) ih264d_get_bit_h264 ( ps_bitstrm ) ; if ( ps_seq -> i4_seq_scaling_matrix_present_flag ) { for ( i4_i = 0 ; i4_i < 8 ; i4_i ++ ) { ps_seq -> u1_seq_scaling_list_present_flag [ i4_i ] = ih264d_get_bit_h264 ( ps_bitstrm ) ; ps_seq -> u1_use_default_scaling_matrix_flag [ i4_i ] = 0 ; if ( ps_seq -> u1_seq_scaling_list_present_flag [ i4_i ] ) { if ( i4_i < 6 ) { ih264d_scaling_list ( ps_seq -> i2_scalinglist4x4 [ i4_i ] , 16 , & ps_seq -> u1_use_default_scaling_matrix_flag [ i4_i ] , ps_bitstrm ) ; } else { ih264d_scaling_list ( ps_seq -> i2_scalinglist8x8 [ i4_i - 6 ] , 64 , & ps_seq -> u1_use_default_scaling_matrix_flag [ i4_i ] , ps_bitstrm ) ; } } } } } u4_temp = 4 + ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u4_temp > MAX_BITS_IN_FRAME_NUM ) { return ERROR_INV_SPS_PPS_T ; } ps_seq -> u1_bits_in_frm_num = u4_temp ; COPYTHECONTEXT ( "SPS:<S2SV_blank>log2_max_frame_num_minus4" , ( ps_seq -> u1_bits_in_frm_num - 4 ) ) ; i2_max_frm_num = ( 1 << ( ps_seq -> u1_bits_in_frm_num ) ) ; ps_seq -> u2_u4_max_pic_num_minus1 = i2_max_frm_num - 1 ; u4_temp = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u4_temp > MAX_PIC_ORDER_CNT_TYPE ) { return ERROR_INV_POC_TYPE_T ; } ps_seq -> u1_pic_order_cnt_type = u4_temp ; COPYTHECONTEXT ( "SPS:<S2SV_blank>pic_order_cnt_type" , ps_seq -> u1_pic_order_cnt_type ) ; ps_seq -> u1_num_ref_frames_in_pic_order_cnt_cycle = 1 ; if ( ps_seq -> u1_pic_order_cnt_type == 0 ) { u4_temp = 4 + ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u4_temp > MAX_BITS_IN_POC_LSB ) { return ERROR_INV_SPS_PPS_T ; } ps_seq -> u1_log2_max_pic_order_cnt_lsb_minus = u4_temp ; ps_seq -> i4_max_pic_order_cntLsb = ( 1 << u4_temp ) ; COPYTHECONTEXT ( "SPS:<S2SV_blank>log2_max_pic_order_cnt_lsb_minus4" , ( u4_temp - 4 ) ) ; } else if ( ps_seq -> u1_pic_order_cnt_type == 1 ) { ps_seq -> u1_delta_pic_order_always_zero_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( "SPS:<S2SV_blank>delta_pic_order_always_zero_flag" , ps_seq -> u1_delta_pic_order_always_zero_flag ) ; ps_seq -> i4_ofst_for_non_ref_pic = ih264d_sev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; COPYTHECONTEXT ( "SPS:<S2SV_blank>offset_for_non_ref_pic" , ps_seq -> i4_ofst_for_non_ref_pic ) ; ps_seq -> i4_ofst_for_top_to_bottom_field = ih264d_sev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; COPYTHECONTEXT ( "SPS:<S2SV_blank>offset_for_top_to_bottom_field" , ps_seq -> i4_ofst_for_top_to_bottom_field ) ; u4_temp = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u4_temp > 255 ) return ERROR_INV_SPS_PPS_T ; ps_seq -> u1_num_ref_frames_in_pic_order_cnt_cycle = u4_temp ; COPYTHECONTEXT ( "SPS:<S2SV_blank>num_ref_frames_in_pic_order_cnt_cycle" , ps_seq -> u1_num_ref_frames_in_pic_order_cnt_cycle ) ; for ( i = 0 ; i < ps_seq -> u1_num_ref_frames_in_pic_order_cnt_cycle ; i ++ ) { ps_seq -> i4_ofst_for_ref_frame [ i ] = ih264d_sev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; COPYTHECONTEXT ( "SPS:<S2SV_blank>offset_for_ref_frame" , ps_seq -> i4_ofst_for_ref_frame [ i ] ) ; } } u4_temp = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( ( u4_temp > H264_MAX_REF_PICS ) ) { return ERROR_NUM_REF ; } ps_seq -> u1_num_ref_frames = u4_temp ; COPYTHECONTEXT ( "SPS:<S2SV_blank>num_ref_frames" , ps_seq -> u1_num_ref_frames ) ; ps_seq -> u1_gaps_in_frame_num_value_allowed_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( "SPS:<S2SV_blank>gaps_in_frame_num_value_allowed_flag" , ps_seq -> u1_gaps_in_frame_num_value_allowed_flag ) ; ps_seq -> u2_frm_wd_in_mbs = 1 + ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; COPYTHECONTEXT ( "SPS:<S2SV_blank>pic_width_in_mbs_minus1" , ps_seq -> u2_frm_wd_in_mbs - 1 ) ; u2_pic_wd = ( ps_seq -> u2_frm_wd_in_mbs << 4 ) ; pic_height_in_map_units_minus1 = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; ps_seq -> u2_frm_ht_in_mbs = 1 + pic_height_in_map_units_minus1 ; u2_pic_ht = ( ps_seq -> u2_frm_ht_in_mbs << 4 ) ; ps_seq -> u2_max_mb_addr = ( ps_seq -> u2_frm_wd_in_mbs * ps_seq -> u2_frm_ht_in_mbs ) - 1 ; ps_seq -> u2_total_num_of_mbs = ps_seq -> u2_max_mb_addr + 1 ; ps_seq -> u1_level_idc = ih264d_correct_level_idc ( u1_level_idc , ps_seq -> u2_total_num_of_mbs ) ; u1_frm = ih264d_get_bit_h264 ( ps_bitstrm ) ; ps_seq -> u1_frame_mbs_only_flag = u1_frm ; COPYTHECONTEXT ( "SPS:<S2SV_blank>frame_mbs_only_flag" , u1_frm ) ; if ( ! u1_frm ) { u2_pic_ht <<= 1 ; ps_seq -> u1_mb_aff_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( "SPS:<S2SV_blank>mb_adaptive_frame_field_flag" , ps_seq -> u1_mb_aff_flag ) ; } else ps_seq -> u1_mb_aff_flag = 0 ; ps_seq -> u1_direct_8x8_inference_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( "SPS:<S2SV_blank>direct_8x8_inference_flag" , ps_seq -> u1_direct_8x8_inference_flag ) ; u1_frame_cropping_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( "SPS:<S2SV_blank>frame_cropping_flag" , u1_frame_cropping_flag ) ; if ( u1_frame_cropping_flag ) { u1_frame_cropping_rect_left_ofst = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; COPYTHECONTEXT ( "SPS:<S2SV_blank>frame_cropping_rect_left_offset" , u1_frame_cropping_rect_left_ofst ) ; u1_frame_cropping_rect_right_ofst = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; COPYTHECONTEXT ( "SPS:<S2SV_blank>frame_cropping_rect_right_offset" , u1_frame_cropping_rect_right_ofst ) ; u1_frame_cropping_rect_top_ofst = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; COPYTHECONTEXT ( "SPS:<S2SV_blank>frame_cropping_rect_top_offset" , u1_frame_cropping_rect_top_ofst ) ; u1_frame_cropping_rect_bottom_ofst = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; COPYTHECONTEXT ( "SPS:<S2SV_blank>frame_cropping_rect_bottom_offset" , u1_frame_cropping_rect_bottom_ofst ) ; } ps_seq -> u1_vui_parameters_present_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( "SPS:<S2SV_blank>vui_parameters_present_flag" , ps_seq -> u1_vui_parameters_present_flag ) ; u2_frm_wd_y = u2_pic_wd + ( UWORD8 ) ( PAD_LEN_Y_H << 1 ) ; if ( 1 == ps_dec -> u4_share_disp_buf ) { if ( ps_dec -> u4_app_disp_width > u2_frm_wd_y ) u2_frm_wd_y = ps_dec -> u4_app_disp_width ; } u2_frm_ht_y = u2_pic_ht + ( UWORD8 ) ( PAD_LEN_Y_V << 2 ) ; u2_frm_wd_uv = u2_pic_wd + ( UWORD8 ) ( PAD_LEN_UV_H << 2 ) ; u2_frm_wd_uv = MAX ( u2_frm_wd_uv , u2_frm_wd_y ) ; u2_frm_ht_uv = ( u2_pic_ht >> 1 ) + ( UWORD8 ) ( PAD_LEN_UV_V << 2 ) ; u2_frm_ht_uv = MAX ( u2_frm_ht_uv , ( u2_frm_ht_y >> 1 ) ) ; { UWORD16 u2_rgt_ofst = 0 ; UWORD16 u2_lft_ofst = 0 ; UWORD16 u2_top_ofst = 0 ; UWORD16 u2_btm_ofst = 0 ; UWORD8 u1_frm_mbs_flag ; UWORD8 u1_vert_mult_factor ; WORD32 i4_cropped_ht , i4_cropped_wd ; if ( u1_frame_cropping_flag ) { u2_rgt_ofst = u1_frame_cropping_rect_right_ofst << 1 ; u2_lft_ofst = u1_frame_cropping_rect_left_ofst << 1 ; u1_frm_mbs_flag = ( 1 == ps_seq -> u1_frame_mbs_only_flag ) ; u1_vert_mult_factor = ( 2 - u1_frm_mbs_flag ) ; u2_btm_ofst = ( u1_frame_cropping_rect_bottom_ofst << u1_vert_mult_factor ) ; u2_top_ofst = ( u1_frame_cropping_rect_top_ofst << u1_vert_mult_factor ) ; } u2_crop_offset_y = ( u2_frm_wd_y * u2_top_ofst ) + ( u2_lft_ofst ) ; u2_crop_offset_uv = ( u2_frm_wd_uv * ( u2_top_ofst >> 1 ) ) + ( u2_lft_ofst >> 1 ) * YUV420SP_FACTOR ; i4_cropped_ht = u2_pic_ht - ( u2_btm_ofst + u2_top_ofst ) ; i4_cropped_wd = u2_pic_wd - ( u2_rgt_ofst + u2_lft_ofst ) ; if ( ( i4_cropped_ht < MB_SIZE ) || ( i4_cropped_wd < MB_SIZE ) ) { return ERROR_INV_SPS_PPS_T ; } if ( ( 3 == ps_dec -> i4_header_decoded ) && ( ps_dec -> u2_pic_wd != u2_pic_wd ) ) { ps_dec -> u1_res_changed = 1 ; return IVD_RES_CHANGED ; } if ( ( 3 == ps_dec -> i4_header_decoded ) && ( ps_dec -> u2_pic_ht != u2_pic_ht ) ) { ps_dec -> u1_res_changed = 1 ; return IVD_RES_CHANGED ; } if ( ( u2_pic_wd > H264_MAX_FRAME_WIDTH ) || ( u2_pic_ht > H264_MAX_FRAME_HEIGHT ) ) { return IVD_STREAM_WIDTH_HEIGHT_NOT_SUPPORTED ; } <S2SV_StartBug> ps_dec -> u2_disp_height = i4_cropped_ht ; <S2SV_EndBug> ps_dec -> u2_disp_width = i4_cropped_wd ; } if ( 1 == ps_seq -> u1_vui_parameters_present_flag ) { ret = ih264d_parse_vui_parametres ( & ps_seq -> s_vui , ps_bitstrm ) ; if ( ret != OK ) return ret ; } ps_dec -> u2_pic_wd = u2_pic_wd ; ps_dec -> u2_pic_ht = u2_pic_ht ; ps_dec -> u2_frm_wd_y = u2_frm_wd_y ; ps_dec -> u2_frm_ht_y = u2_frm_ht_y ; ps_dec -> u2_frm_wd_uv = u2_frm_wd_uv ; ps_dec -> u2_frm_ht_uv = u2_frm_ht_uv ; ps_dec -> s_pad_mgr . u1_pad_len_y_v = ( UWORD8 ) ( PAD_LEN_Y_V << ( 1 - u1_frm ) ) ; ps_dec -> s_pad_mgr . u1_pad_len_cr_v = ( UWORD8 ) ( PAD_LEN_UV_V << ( 1 - u1_frm ) ) ; ps_dec -> u2_frm_wd_in_mbs = ps_seq -> u2_frm_wd_in_mbs ; ps_dec -> u2_frm_ht_in_mbs = ps_seq -> u2_frm_ht_in_mbs ; ps_dec -> u2_crop_offset_y = u2_crop_offset_y ; ps_dec -> u2_crop_offset_uv = u2_crop_offset_uv ; if ( ps_bitstrm -> u4_ofst > ps_bitstrm -> u4_max_ofst ) { return ERROR_INV_SPS_PPS_T ; } ps_seq -> u1_is_valid = TRUE ; ps_dec -> ps_sps [ u1_seq_parameter_set_id ] = * ps_seq ; return OK ; }
<S2SV_StartBug> void generic_pipe_buf_get ( struct pipe_inode_info * pipe , struct pipe_buffer * buf ) <S2SV_EndBug> { <S2SV_StartBug> get_page ( buf -> page ) ; <S2SV_EndBug> }
int main ( int argc , char * * argv ) { u8 * byteStrmStart ; u8 * byteStrm ; u32 strmLen ; u32 picSize ; H264SwDecInst decInst ; H264SwDecRet ret ; H264SwDecInput decInput ; H264SwDecOutput decOutput ; H264SwDecPicture decPicture ; H264SwDecInfo decInfo ; u32 picNumber ; FILE * finput ; FILE * foutput ; if ( argc < 2 ) { printf ( "Usage:<S2SV_blank>%s<S2SV_blank>file.h264\\n" , argv [ 0 ] ) ; return - 1 ; } foutput = fopen ( "out.yuv" , "wb" ) ; if ( foutput == NULL ) { printf ( "UNABLE<S2SV_blank>TO<S2SV_blank>OPEN<S2SV_blank>OUTPUT<S2SV_blank>FILE\\n" ) ; return - 1 ; } finput = fopen ( argv [ argc - 1 ] , "rb" ) ; if ( finput == NULL ) { printf ( "UNABLE<S2SV_blank>TO<S2SV_blank>OPEN<S2SV_blank>INPUT<S2SV_blank>FILE\\n" ) ; return - 1 ; } fseek ( finput , 0L , SEEK_END ) ; strmLen = ( u32 ) ftell ( finput ) ; rewind ( finput ) ; <S2SV_StartBug> byteStrm = byteStrmStart = ( u8 * ) H264SwDecMalloc ( sizeof ( u8 ) * strmLen ) ; <S2SV_EndBug> if ( byteStrm == NULL ) { printf ( "UNABLE<S2SV_blank>TO<S2SV_blank>ALLOCATE<S2SV_blank>MEMORY\\n" ) ; return - 1 ; } fread ( byteStrm , sizeof ( u8 ) , strmLen , finput ) ; fclose ( finput ) ; ret = H264SwDecInit ( & decInst , 0 ) ; if ( ret != H264SWDEC_OK ) { printf ( "DECODER<S2SV_blank>INITIALIZATION<S2SV_blank>FAILED\\n" ) ; return - 1 ; } decInput . pStream = byteStrmStart ; decInput . dataLen = strmLen ; decInput . intraConcealmentMethod = 0 ; picNumber = 0 ; do { ret = H264SwDecDecode ( decInst , & decInput , & decOutput ) ; switch ( ret ) { case H264SWDEC_HDRS_RDY_BUFF_NOT_EMPTY : ret = H264SwDecGetInfo ( decInst , & decInfo ) ; if ( ret != H264SWDEC_OK ) return - 1 ; picSize = decInfo . picWidth * decInfo . picHeight ; picSize = ( 3 * picSize ) / 2 ; printf ( "Width<S2SV_blank>%d<S2SV_blank>Height<S2SV_blank>%d\\n" , decInfo . picWidth , decInfo . picHeight ) ; decInput . dataLen -= ( u32 ) ( decOutput . pStrmCurrPos - decInput . pStream ) ; decInput . pStream = decOutput . pStrmCurrPos ; break ; case H264SWDEC_PIC_RDY_BUFF_NOT_EMPTY : case H264SWDEC_PIC_RDY : decInput . dataLen -= ( u32 ) ( decOutput . pStrmCurrPos - decInput . pStream ) ; decInput . pStream = decOutput . pStrmCurrPos ; while ( H264SwDecNextPicture ( decInst , & decPicture , 0 ) == H264SWDEC_PIC_RDY ) { picNumber ++ ; printf ( "PIC<S2SV_blank>%d,<S2SV_blank>type<S2SV_blank>%s,<S2SV_blank>concealed<S2SV_blank>%d\\n" , picNumber , decPicture . isIdrPicture ? "IDR" : "NON-IDR" , decPicture . nbrOfErrMBs ) ; fflush ( stdout ) ; WriteOutput ( foutput , ( u8 * ) decPicture . pOutputPicture , picSize ) ; } break ; case H264SWDEC_EVALUATION_LIMIT_EXCEEDED : printf ( "EVALUATION<S2SV_blank>LIMIT<S2SV_blank>REACHED\\n" ) ; goto end ; default : printf ( "UNRECOVERABLE<S2SV_blank>ERROR\\n" ) ; return - 1 ; } } while ( decInput . dataLen > 0 ) ; end : while ( H264SwDecNextPicture ( decInst , & decPicture , 1 ) == H264SWDEC_PIC_RDY ) { picNumber ++ ; printf ( "PIC<S2SV_blank>%d,<S2SV_blank>type<S2SV_blank>%s,<S2SV_blank>concealed<S2SV_blank>%d\\n" , picNumber , decPicture . isIdrPicture ? "IDR" : "NON-IDR" , decPicture . nbrOfErrMBs ) ; fflush ( stdout ) ; WriteOutput ( foutput , ( u8 * ) decPicture . pOutputPicture , picSize ) ; } H264SwDecRelease ( decInst ) ; fclose ( foutput ) ; free ( byteStrmStart ) ; return 0 ; }
<S2SV_StartBug> static INLINE void add_token ( TOKENEXTRA * * t , const vp9_prob * context_tree , <S2SV_EndBug> <S2SV_StartBug> int16_t extra , uint8_t token , <S2SV_EndBug> uint8_t skip_eob_node , unsigned int * counts ) { ( * t ) -> token = token ; ( * t ) -> extra = extra ; ( * t ) -> context_tree = context_tree ; ( * t ) -> skip_eob_node = skip_eob_node ; ( * t ) ++ ; ++ counts [ token ] ; }
void jas_matrix_setall ( jas_matrix_t * matrix , jas_seqent_t val ) { <S2SV_StartBug> int i ; <S2SV_EndBug> int j ; jas_seqent_t * rowstart ; <S2SV_StartBug> int rowstep ; <S2SV_EndBug> jas_seqent_t * data ; if ( jas_matrix_numrows ( matrix ) > 0 && jas_matrix_numcols ( matrix ) > 0 ) { assert ( matrix -> rows_ ) ; rowstep = jas_matrix_rowstep ( matrix ) ; for ( i = matrix -> numrows_ , rowstart = matrix -> rows_ [ 0 ] ; i > 0 ; -- i , rowstart += rowstep ) { for ( j = matrix -> numcols_ , data = rowstart ; j > 0 ; -- j , ++ data ) { * data = val ; } } } }
static int do_tkill ( pid_t tgid , pid_t pid , int sig ) { <S2SV_StartBug> struct siginfo info ; <S2SV_EndBug> info . si_signo = sig ; info . si_errno = 0 ; info . si_code = SI_TKILL ; info . si_pid = task_tgid_vnr ( current ) ; info . si_uid = from_kuid_munged ( current_user_ns ( ) , current_uid ( ) ) ; return do_send_specific ( tgid , pid , sig , & info ) ; }
static void destroy_super ( struct super_block * s ) { int i ; list_lru_destroy ( & s -> s_dentry_lru ) ; list_lru_destroy ( & s -> s_inode_lru ) ; <S2SV_StartBug> # ifdef CONFIG_SMP <S2SV_EndBug> free_percpu ( s -> s_files ) ; # endif for ( i = 0 ; i < SB_FREEZE_LEVELS ; i ++ ) percpu_counter_destroy ( & s -> s_writers . counter [ i ] ) ; security_sb_free ( s ) ; WARN_ON ( ! list_empty ( & s -> s_mounts ) ) ; kfree ( s -> s_subtype ) ; kfree ( s -> s_options ) ; kfree_rcu ( s , rcu ) ; }
static int fsmMkfile ( rpmfi fi , const char * dest , rpmfiles files , rpmpsm psm , int nodigest , int * setmeta , int * firsthardlink ) { int rc = 0 ; int numHardlinks = rpmfiFNlink ( fi ) ; if ( numHardlinks > 1 ) { if ( * firsthardlink < 0 ) { * firsthardlink = rpmfiFX ( fi ) ; <S2SV_StartBug> rc = expandRegular ( fi , dest , psm , nodigest , 1 ) ; <S2SV_EndBug> } else { char * fn = rpmfilesFN ( files , * firsthardlink ) ; rc = link ( fn , dest ) ; if ( rc < 0 ) { rc = RPMERR_LINK_FAILED ; } free ( fn ) ; } } if ( numHardlinks <= 1 ) { if ( ! rc ) <S2SV_StartBug> rc = expandRegular ( fi , dest , psm , nodigest , 0 ) ; <S2SV_EndBug> } else if ( rpmfiArchiveHasContent ( fi ) ) { if ( ! rc ) <S2SV_StartBug> rc = expandRegular ( fi , dest , psm , nodigest , 0 ) ; <S2SV_EndBug> * firsthardlink = - 1 ; } else { * setmeta = 0 ; } return rc ; }
static int64_t encode_inter_mb_segment ( VP9_COMP * cpi , MACROBLOCK * x , int64_t best_yrd , int i , int * labelyrate , int64_t * distortion , int64_t * sse , ENTROPY_CONTEXT * ta , ENTROPY_CONTEXT * tl , int mi_row , int mi_col ) { int k ; MACROBLOCKD * xd = & x -> e_mbd ; struct macroblockd_plane * const pd = & xd -> plane [ 0 ] ; struct macroblock_plane * const p = & x -> plane [ 0 ] ; MODE_INFO * const mi = xd -> mi [ 0 ] ; const BLOCK_SIZE plane_bsize = get_plane_block_size ( mi -> mbmi . sb_type , pd ) ; const int width = 4 * num_4x4_blocks_wide_lookup [ plane_bsize ] ; const int height = 4 * num_4x4_blocks_high_lookup [ plane_bsize ] ; int idx , idy ; <S2SV_StartBug> const uint8_t * const src = & p -> src . buf [ raster_block_offset ( BLOCK_8X8 , i , <S2SV_EndBug> p -> src . stride ) ] ; <S2SV_StartBug> uint8_t * const dst = & pd -> dst . buf [ raster_block_offset ( BLOCK_8X8 , i , <S2SV_EndBug> pd -> dst . stride ) ] ; int64_t thisdistortion = 0 , thissse = 0 ; int thisrate = 0 , ref ; const scan_order * so = & vp9_default_scan_orders [ TX_4X4 ] ; const int is_compound = has_second_ref ( & mi -> mbmi ) ; <S2SV_StartBug> const InterpKernel * kernel = vp9_get_interp_kernel ( mi -> mbmi . interp_filter ) ; <S2SV_EndBug> for ( ref = 0 ; ref < 1 + is_compound ; ++ ref ) { <S2SV_StartBug> const uint8_t * pre = & pd -> pre [ ref ] . buf [ raster_block_offset ( BLOCK_8X8 , i , <S2SV_EndBug> pd -> pre [ ref ] . stride ) ] ; <S2SV_StartBug> vp9_build_inter_predictor ( pre , pd -> pre [ ref ] . stride , <S2SV_EndBug> dst , pd -> dst . stride , & mi -> bmi [ i ] . as_mv [ ref ] . as_mv , <S2SV_StartBug> & xd -> block_refs [ ref ] -> sf , width , height , ref , <S2SV_EndBug> kernel , MV_PRECISION_Q3 , mi_col * MI_SIZE + 4 * ( i % 2 ) , <S2SV_StartBug> mi_row * MI_SIZE + 4 * ( i / 2 ) ) ; <S2SV_EndBug> } <S2SV_StartBug> vp9_subtract_block ( height , width , <S2SV_EndBug> raster_block_offset_int16 ( BLOCK_8X8 , i , p -> src_diff ) , 8 , src , p -> src . stride , <S2SV_StartBug> dst , pd -> dst . stride ) ; <S2SV_EndBug> k = i ; for ( idy = 0 ; idy < height / 4 ; ++ idy ) { for ( idx = 0 ; idx < width / 4 ; ++ idx ) { int64_t ssz , rd , rd1 , rd2 ; <S2SV_StartBug> int16_t * coeff ; <S2SV_EndBug> k += ( idy * 2 + idx ) ; coeff = BLOCK_OFFSET ( p -> coeff , k ) ; <S2SV_StartBug> x -> fwd_txm4x4 ( raster_block_offset_int16 ( BLOCK_8X8 , k , p -> src_diff ) , <S2SV_EndBug> coeff , 8 ) ; <S2SV_StartBug> vp9_regular_quantize_b_4x4 ( x , 0 , k , so -> scan , so -> iscan ) ; <S2SV_EndBug> thisdistortion += vp9_block_error ( coeff , BLOCK_OFFSET ( pd -> dqcoeff , k ) , 16 , & ssz ) ; <S2SV_StartBug> thissse += ssz ; <S2SV_EndBug> thisrate += cost_coeffs ( x , 0 , k , ta + ( k & 1 ) , tl + ( k >> 1 ) , TX_4X4 , so -> scan , so -> neighbors , cpi -> sf . use_fast_coef_costing ) ; rd1 = RDCOST ( x -> rdmult , x -> rddiv , thisrate , thisdistortion >> 2 ) ; rd2 = RDCOST ( x -> rdmult , x -> rddiv , 0 , thissse >> 2 ) ; rd = MIN ( rd1 , rd2 ) ; if ( rd >= best_yrd ) return INT64_MAX ; } } * distortion = thisdistortion >> 2 ; * labelyrate = thisrate ; * sse = thissse >> 2 ; return RDCOST ( x -> rdmult , x -> rddiv , * labelyrate , * distortion ) ; }
static Image * ReadSIXELImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { char * sixel_buffer ; Image * image ; MagickBooleanType status ; register char * p ; register ssize_t x ; register Quantum * q ; size_t length ; ssize_t i , j , y ; unsigned char * sixel_pixels , * sixel_palette ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , "%s" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } length = MagickPathExtent ; sixel_buffer = ( char * ) AcquireQuantumMemory ( ( size_t ) length + MagickPathExtent , sizeof ( * sixel_buffer ) ) ; p = sixel_buffer ; if ( sixel_buffer != ( char * ) NULL ) while ( ReadBlobString ( image , p ) != ( char * ) NULL ) { if ( ( * p == '#' ) && ( ( p == sixel_buffer ) || ( * ( p - 1 ) == '\\n' ) ) ) continue ; if ( ( * p == '}' ) && ( * ( p + 1 ) == ';' ) ) break ; p += strlen ( p ) ; if ( ( size_t ) ( p - sixel_buffer + MagickPathExtent + 1 ) < length ) continue ; length <<= 1 ; sixel_buffer = ( char * ) ResizeQuantumMemory ( sixel_buffer , length + MagickPathExtent + 1 , sizeof ( * sixel_buffer ) ) ; if ( sixel_buffer == ( char * ) NULL ) break ; p = sixel_buffer + strlen ( sixel_buffer ) ; } if ( sixel_buffer == ( char * ) NULL ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; sixel_buffer [ length ] = '\\0' ; if ( sixel_decode ( image , ( unsigned char * ) sixel_buffer , & sixel_pixels , & image -> columns , & image -> rows , & sixel_palette , & image -> colors , exception ) == MagickFalse ) { <S2SV_StartBug> sixel_buffer = ( char * ) RelinquishMagickMemory ( sixel_buffer ) ; <S2SV_EndBug> ThrowReaderException ( CorruptImageError , "CorruptImage" ) ; } sixel_buffer = ( char * ) RelinquishMagickMemory ( sixel_buffer ) ; image -> depth = 24 ; image -> storage_class = PseudoClass ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) { sixel_pixels = ( unsigned char * ) RelinquishMagickMemory ( sixel_pixels ) ; sixel_palette = ( unsigned char * ) RelinquishMagickMemory ( sixel_palette ) ; return ( DestroyImageList ( image ) ) ; } if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) { sixel_pixels = ( unsigned char * ) RelinquishMagickMemory ( sixel_pixels ) ; sixel_palette = ( unsigned char * ) RelinquishMagickMemory ( sixel_palette ) ; ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; } for ( i = 0 ; i < ( ssize_t ) image -> colors ; ++ i ) { image -> colormap [ i ] . red = ScaleCharToQuantum ( sixel_palette [ i * 4 + 0 ] ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( sixel_palette [ i * 4 + 1 ] ) ; image -> colormap [ i ] . blue = ScaleCharToQuantum ( sixel_palette [ i * 4 + 2 ] ) ; } j = 0 ; if ( image_info -> ping == MagickFalse ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { j = ( ssize_t ) sixel_pixels [ y * image -> columns + x ] ; SetPixelIndex ( image , j , q ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; } if ( y < ( ssize_t ) image -> rows ) { sixel_pixels = ( unsigned char * ) RelinquishMagickMemory ( sixel_pixels ) ; sixel_palette = ( unsigned char * ) RelinquishMagickMemory ( sixel_palette ) ; ThrowReaderException ( CorruptImageError , "NotEnoughPixelData" ) ; } } sixel_pixels = ( unsigned char * ) RelinquishMagickMemory ( sixel_pixels ) ; sixel_palette = ( unsigned char * ) RelinquishMagickMemory ( sixel_palette ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
struct dentry * debugfs_rename ( struct dentry * old_dir , struct dentry * old_dentry , struct dentry * new_dir , const char * new_name ) { int error ; struct dentry * dentry = NULL , * trap ; <S2SV_StartBug> const char * old_name ; <S2SV_EndBug> trap = lock_rename ( new_dir , old_dir ) ; if ( d_really_is_negative ( old_dir ) || d_really_is_negative ( new_dir ) ) goto exit ; if ( d_really_is_negative ( old_dentry ) || old_dentry == trap || d_mountpoint ( old_dentry ) ) goto exit ; dentry = lookup_one_len ( new_name , new_dir , strlen ( new_name ) ) ; if ( IS_ERR ( dentry ) || dentry == trap || d_really_is_positive ( dentry ) ) goto exit ; <S2SV_StartBug> old_name = fsnotify_oldname_init ( old_dentry -> d_name . name ) ; <S2SV_EndBug> error = simple_rename ( d_inode ( old_dir ) , old_dentry , d_inode ( new_dir ) , dentry , 0 ) ; if ( error ) { fsnotify_oldname_free ( old_name ) ; goto exit ; } d_move ( old_dentry , dentry ) ; fsnotify_move ( d_inode ( old_dir ) , d_inode ( new_dir ) , old_name , d_is_dir ( old_dentry ) , NULL , old_dentry ) ; <S2SV_StartBug> fsnotify_oldname_free ( old_name ) ; <S2SV_EndBug> unlock_rename ( new_dir , old_dir ) ; dput ( dentry ) ; return old_dentry ; exit : if ( dentry && ! IS_ERR ( dentry ) ) dput ( dentry ) ; unlock_rename ( new_dir , old_dir ) ; return NULL ; }
static zval * * spl_array_get_dimension_ptr_ptr ( int check_inherited , zval * object , zval * offset , int type TSRMLS_DC ) { spl_array_object * intern = ( spl_array_object * ) zend_object_store_get_object ( object TSRMLS_CC ) ; zval * * retval ; char * key ; uint len ; long index ; HashTable * ht = spl_array_get_hash_table ( intern , 0 TSRMLS_CC ) ; <S2SV_StartBug> if ( ! offset ) { <S2SV_EndBug> return & EG ( uninitialized_zval_ptr ) ; } if ( ( type == BP_VAR_W || type == BP_VAR_RW ) && ( ht -> nApplyCount > 0 ) ) { zend_error ( E_WARNING , "Modification<S2SV_blank>of<S2SV_blank>ArrayObject<S2SV_blank>during<S2SV_blank>sorting<S2SV_blank>is<S2SV_blank>prohibited" ) ; return & EG ( error_zval_ptr ) ; ; } switch ( Z_TYPE_P ( offset ) ) { case IS_STRING : key = Z_STRVAL_P ( offset ) ; len = Z_STRLEN_P ( offset ) + 1 ; string_offest : if ( zend_symtable_find ( ht , key , len , ( void * * ) & retval ) == FAILURE ) { switch ( type ) { case BP_VAR_R : zend_error ( E_NOTICE , "Undefined<S2SV_blank>index:<S2SV_blank>%s" , key ) ; case BP_VAR_UNSET : case BP_VAR_IS : retval = & EG ( uninitialized_zval_ptr ) ; break ; case BP_VAR_RW : zend_error ( E_NOTICE , "Undefined<S2SV_blank>index:<S2SV_blank>%s" , key ) ; case BP_VAR_W : { zval * value ; ALLOC_INIT_ZVAL ( value ) ; zend_symtable_update ( ht , key , len , ( void * * ) & value , sizeof ( void * ) , ( void * * ) & retval ) ; } } } return retval ; case IS_NULL : key = "" ; len = 1 ; goto string_offest ; case IS_RESOURCE : zend_error ( E_STRICT , "Resource<S2SV_blank>ID#%ld<S2SV_blank>used<S2SV_blank>as<S2SV_blank>offset,<S2SV_blank>casting<S2SV_blank>to<S2SV_blank>integer<S2SV_blank>(%ld)" , Z_LVAL_P ( offset ) , Z_LVAL_P ( offset ) ) ; case IS_DOUBLE : case IS_BOOL : case IS_LONG : if ( offset -> type == IS_DOUBLE ) { index = ( long ) Z_DVAL_P ( offset ) ; } else { index = Z_LVAL_P ( offset ) ; } if ( zend_hash_index_find ( ht , index , ( void * * ) & retval ) == FAILURE ) { switch ( type ) { case BP_VAR_R : zend_error ( E_NOTICE , "Undefined<S2SV_blank>offset:<S2SV_blank>%ld" , index ) ; case BP_VAR_UNSET : case BP_VAR_IS : retval = & EG ( uninitialized_zval_ptr ) ; break ; case BP_VAR_RW : zend_error ( E_NOTICE , "Undefined<S2SV_blank>offset:<S2SV_blank>%ld" , index ) ; case BP_VAR_W : { zval * value ; ALLOC_INIT_ZVAL ( value ) ; zend_hash_index_update ( ht , index , ( void * * ) & value , sizeof ( void * ) , ( void * * ) & retval ) ; } } } return retval ; default : zend_error ( E_WARNING , "Illegal<S2SV_blank>offset<S2SV_blank>type" ) ; return ( type == BP_VAR_W || type == BP_VAR_RW ) ? & EG ( error_zval_ptr ) : & EG ( uninitialized_zval_ptr ) ; } }
static int faultin_page ( struct task_struct * tsk , struct vm_area_struct * vma , unsigned long address , unsigned int * flags , int * nonblocking ) { unsigned int fault_flags = 0 ; int ret ; if ( ( * flags & ( FOLL_POPULATE | FOLL_MLOCK ) ) == FOLL_MLOCK ) return - ENOENT ; if ( ( * flags & FOLL_POPULATE ) && ( stack_guard_page_start ( vma , address ) || stack_guard_page_end ( vma , address + PAGE_SIZE ) ) ) return - ENOENT ; if ( * flags & FOLL_WRITE ) fault_flags |= FAULT_FLAG_WRITE ; if ( * flags & FOLL_REMOTE ) fault_flags |= FAULT_FLAG_REMOTE ; if ( nonblocking ) fault_flags |= FAULT_FLAG_ALLOW_RETRY ; if ( * flags & FOLL_NOWAIT ) fault_flags |= FAULT_FLAG_ALLOW_RETRY | FAULT_FLAG_RETRY_NOWAIT ; if ( * flags & FOLL_TRIED ) { VM_WARN_ON_ONCE ( fault_flags & FAULT_FLAG_ALLOW_RETRY ) ; fault_flags |= FAULT_FLAG_TRIED ; } ret = handle_mm_fault ( vma , address , fault_flags ) ; if ( ret & VM_FAULT_ERROR ) { if ( ret & VM_FAULT_OOM ) return - ENOMEM ; if ( ret & ( VM_FAULT_HWPOISON | VM_FAULT_HWPOISON_LARGE ) ) return * flags & FOLL_HWPOISON ? - EHWPOISON : - EFAULT ; if ( ret & ( VM_FAULT_SIGBUS | VM_FAULT_SIGSEGV ) ) return - EFAULT ; BUG ( ) ; } if ( tsk ) { if ( ret & VM_FAULT_MAJOR ) tsk -> maj_flt ++ ; else tsk -> min_flt ++ ; } if ( ret & VM_FAULT_RETRY ) { if ( nonblocking ) * nonblocking = 0 ; return - EBUSY ; } if ( ( ret & VM_FAULT_WRITE ) && ! ( vma -> vm_flags & VM_WRITE ) ) <S2SV_StartBug> * flags &= ~ FOLL_WRITE ; <S2SV_EndBug> return 0 ; }
static int dalvik_disassemble ( RAsm * a , RAsmOp * op , const ut8 * buf , int len ) { int vA , vB , vC , payload = 0 , i = ( int ) buf [ 0 ] ; int size = dalvik_opcodes [ i ] . len ; char str [ 1024 ] , * strasm ; ut64 offset ; const char * flag_str ; op -> buf_asm [ 0 ] = 0 ; if ( buf [ 0 ] == 0x00 ) { switch ( buf [ 1 ] ) { case 0x01 : { unsigned short array_size = buf [ 2 ] | ( buf [ 3 ] << 8 ) ; int first_key = buf [ 4 ] | ( buf [ 5 ] << 8 ) | ( buf [ 6 ] << 16 ) | ( buf [ 7 ] << 24 ) ; <S2SV_StartBug> sprintf ( op -> buf_asm , "packed-switch-payload<S2SV_blank>%d,<S2SV_blank>%d" , array_size , first_key ) ; <S2SV_EndBug> size = 8 ; payload = 2 * ( array_size * 2 ) ; len = 0 ; } break ; case 0x02 : { unsigned short array_size = buf [ 2 ] | ( buf [ 3 ] << 8 ) ; <S2SV_StartBug> sprintf ( op -> buf_asm , "sparse-switch-payload<S2SV_blank>%d" , array_size ) ; <S2SV_EndBug> size = 4 ; payload = 2 * ( array_size * 4 ) ; len = 0 ; } break ; case 0x03 : if ( len > 7 ) { unsigned short elem_width = buf [ 2 ] | ( buf [ 3 ] << 8 ) ; unsigned int array_size = buf [ 4 ] | ( buf [ 5 ] << 8 ) | ( buf [ 6 ] << 16 ) | ( buf [ 7 ] << 24 ) ; snprintf ( op -> buf_asm , sizeof ( op -> buf_asm ) , "fill-array-data-payload<S2SV_blank>%d,<S2SV_blank>%d" , elem_width , array_size ) ; payload = 2 * ( ( array_size * elem_width + 1 ) / 2 ) ; } size = 8 ; len = 0 ; break ; default : break ; } } strasm = NULL ; if ( size <= len ) { strncpy ( op -> buf_asm , dalvik_opcodes [ i ] . name , sizeof ( op -> buf_asm ) - 1 ) ; strasm = strdup ( op -> buf_asm ) ; size = dalvik_opcodes [ i ] . len ; switch ( dalvik_opcodes [ i ] . fmt ) { case fmtop : break ; case fmtopvAvB : vA = buf [ 1 ] & 0x0f ; vB = ( buf [ 1 ] & 0xf0 ) >> 4 ; <S2SV_StartBug> sprintf ( str , "<S2SV_blank>v%i,<S2SV_blank>v%i" , vA , vB ) ; <S2SV_EndBug> strasm = r_str_concat ( strasm , str ) ; break ; case fmtopvAAvBBBB : vA = ( int ) buf [ 1 ] ; vB = ( buf [ 3 ] << 8 ) | buf [ 2 ] ; <S2SV_StartBug> sprintf ( str , "<S2SV_blank>v%i,<S2SV_blank>v%i" , vA , vB ) ; <S2SV_EndBug> strasm = r_str_concat ( strasm , str ) ; break ; case fmtopvAAAAvBBBB : vA = ( buf [ 3 ] << 8 ) | buf [ 2 ] ; vB = ( buf [ 5 ] << 8 ) | buf [ 4 ] ; <S2SV_StartBug> sprintf ( str , "<S2SV_blank>v%i,<S2SV_blank>v%i" , vA , vB ) ; <S2SV_EndBug> strasm = r_str_concat ( strasm , str ) ; break ; case fmtopvAA : vA = ( int ) buf [ 1 ] ; <S2SV_StartBug> sprintf ( str , "<S2SV_blank>v%i" , vA ) ; <S2SV_EndBug> strasm = r_str_concat ( strasm , str ) ; break ; case fmtopvAcB : vA = buf [ 1 ] & 0x0f ; vB = ( buf [ 1 ] & 0xf0 ) >> 4 ; <S2SV_StartBug> sprintf ( str , "<S2SV_blank>v%i,<S2SV_blank>%#x" , vA , vB ) ; <S2SV_EndBug> strasm = r_str_concat ( strasm , str ) ; break ; case fmtopvAAcBBBB : vA = ( int ) buf [ 1 ] ; { short sB = ( buf [ 3 ] << 8 ) | buf [ 2 ] ; <S2SV_StartBug> sprintf ( str , "<S2SV_blank>v%i,<S2SV_blank>%#04hx" , vA , sB ) ; <S2SV_EndBug> strasm = r_str_concat ( strasm , str ) ; } break ; case fmtopvAAcBBBBBBBB : vA = ( int ) buf [ 1 ] ; vB = buf [ 2 ] | ( buf [ 3 ] << 8 ) | ( buf [ 4 ] << 16 ) | ( buf [ 5 ] << 24 ) ; if ( buf [ 0 ] == 0x17 ) { snprintf ( str , sizeof ( str ) , "<S2SV_blank>v%i:v%i,<S2SV_blank>0x%08x" , vA , vA + 1 , vB ) ; } else { snprintf ( str , sizeof ( str ) , "<S2SV_blank>v%i,<S2SV_blank>0x%08x" , vA , vB ) ; } strasm = r_str_concat ( strasm , str ) ; break ; case fmtopvAAcBBBB0000 : vA = ( int ) buf [ 1 ] ; vB = 0 | ( buf [ 2 ] << 16 ) | ( buf [ 3 ] << 24 ) ; if ( buf [ 0 ] == 0x19 ) { snprintf ( str , sizeof ( str ) , "<S2SV_blank>v%i:v%i,<S2SV_blank>0x%08x" , vA , vA + 1 , vB ) ; } else { snprintf ( str , sizeof ( str ) , "<S2SV_blank>v%i,<S2SV_blank>0x%08x" , vA , vB ) ; } strasm = r_str_concat ( strasm , str ) ; break ; case fmtopvAAcBBBBBBBBBBBBBBBB : vA = ( int ) buf [ 1 ] ; # define llint long long int llint lB = ( llint ) buf [ 2 ] | ( ( llint ) buf [ 3 ] << 8 ) | ( ( llint ) buf [ 4 ] << 16 ) | ( ( llint ) buf [ 5 ] << 24 ) | ( ( llint ) buf [ 6 ] << 32 ) | ( ( llint ) buf [ 7 ] << 40 ) | ( ( llint ) buf [ 8 ] << 48 ) | ( ( llint ) buf [ 9 ] << 56 ) ; # undef llint <S2SV_StartBug> sprintf ( str , "<S2SV_blank>v%i:v%i,<S2SV_blank>0x%" PFMT64x , vA , vA + 1 , lB ) ; <S2SV_EndBug> strasm = r_str_concat ( strasm , str ) ; break ; case fmtopvAAvBBvCC : vA = ( int ) buf [ 1 ] ; vB = ( int ) buf [ 2 ] ; vC = ( int ) buf [ 3 ] ; <S2SV_StartBug> sprintf ( str , "<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>v%i" , vA , vB , vC ) ; <S2SV_EndBug> strasm = r_str_concat ( strasm , str ) ; break ; case fmtopvAAvBBcCC : vA = ( int ) buf [ 1 ] ; vB = ( int ) buf [ 2 ] ; vC = ( int ) buf [ 3 ] ; <S2SV_StartBug> sprintf ( str , "<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>%#x" , vA , vB , vC ) ; <S2SV_EndBug> strasm = r_str_concat ( strasm , str ) ; break ; case fmtopvAvBcCCCC : vA = buf [ 1 ] & 0x0f ; vB = ( buf [ 1 ] & 0xf0 ) >> 4 ; vC = ( buf [ 3 ] << 8 ) | buf [ 2 ] ; <S2SV_StartBug> sprintf ( str , "<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>%#x" , vA , vB , vC ) ; <S2SV_EndBug> strasm = r_str_concat ( strasm , str ) ; break ; case fmtoppAA : vA = ( char ) buf [ 1 ] ; snprintf ( str , sizeof ( str ) , "<S2SV_blank>0x%08" PFMT64x , a -> pc + ( vA * 2 ) ) ; strasm = r_str_concat ( strasm , str ) ; break ; case fmtoppAAAA : vA = ( short ) ( buf [ 3 ] << 8 | buf [ 2 ] ) ; snprintf ( str , sizeof ( str ) , "<S2SV_blank>0x%08" PFMT64x , a -> pc + ( vA * 2 ) ) ; strasm = r_str_concat ( strasm , str ) ; break ; case fmtopvAApBBBB : vA = ( int ) buf [ 1 ] ; vB = ( int ) ( buf [ 3 ] << 8 | buf [ 2 ] ) ; snprintf ( str , sizeof ( str ) , "<S2SV_blank>v%i,<S2SV_blank>0x%08" PFMT64x , vA , a -> pc + ( vB * 2 ) ) ; strasm = r_str_concat ( strasm , str ) ; break ; case fmtoppAAAAAAAA : vA = ( int ) ( buf [ 2 ] | ( buf [ 3 ] << 8 ) | ( buf [ 4 ] << 16 ) | ( buf [ 5 ] << 24 ) ) ; snprintf ( str , sizeof ( str ) , "<S2SV_blank>0x%08" PFMT64x , a -> pc + ( vA * 2 ) ) ; strasm = r_str_concat ( strasm , str ) ; break ; case fmtopvAvBpCCCC : vA = buf [ 1 ] & 0x0f ; vB = ( buf [ 1 ] & 0xf0 ) >> 4 ; vC = ( int ) ( buf [ 3 ] << 8 | buf [ 2 ] ) ; snprintf ( str , sizeof ( str ) , "<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>0x%08" PFMT64x , vA , vB , a -> pc + ( vC * 2 ) ) ; strasm = r_str_concat ( strasm , str ) ; break ; case fmtopvAApBBBBBBBB : vA = ( int ) buf [ 1 ] ; vB = ( int ) ( buf [ 2 ] | ( buf [ 3 ] << 8 ) | ( buf [ 4 ] << 16 ) | ( buf [ 5 ] << 24 ) ) ; snprintf ( str , sizeof ( str ) , "<S2SV_blank>v%i,<S2SV_blank>0x%08" PFMT64x , vA , a -> pc + vB ) ; strasm = r_str_concat ( strasm , str ) ; break ; case fmtoptinlineI : vA = ( int ) ( buf [ 1 ] & 0x0f ) ; vB = ( buf [ 3 ] << 8 ) | buf [ 2 ] ; * str = 0 ; switch ( vA ) { case 1 : <S2SV_StartBug> sprintf ( str , "<S2SV_blank>{v%i}" , buf [ 4 ] & 0x0f ) ; <S2SV_EndBug> break ; case 2 : <S2SV_StartBug> sprintf ( str , "<S2SV_blank>{v%i,<S2SV_blank>v%i}" , buf [ 4 ] & 0x0f , ( buf [ 4 ] & 0xf0 ) >> 4 ) ; <S2SV_EndBug> break ; case 3 : <S2SV_StartBug> sprintf ( str , "<S2SV_blank>{v%i,<S2SV_blank>v%i,<S2SV_blank>v%i}" , buf [ 4 ] & 0x0f , ( buf [ 4 ] & 0xf0 ) >> 4 , buf [ 5 ] & 0x0f ) ; <S2SV_EndBug> break ; case 4 : <S2SV_StartBug> sprintf ( str , "<S2SV_blank>{v%i,<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>v%i}" , buf [ 4 ] & 0x0f , <S2SV_EndBug> ( buf [ 4 ] & 0xf0 ) >> 4 , buf [ 5 ] & 0x0f , ( buf [ 5 ] & 0xf0 ) >> 4 ) ; break ; default : <S2SV_StartBug> sprintf ( str , "<S2SV_blank>{}" ) ; <S2SV_EndBug> } strasm = r_str_concat ( strasm , str ) ; <S2SV_StartBug> sprintf ( str , ",<S2SV_blank>[%04x]" , vB ) ; <S2SV_EndBug> strasm = r_str_concat ( strasm , str ) ; break ; case fmtoptinlineIR : case fmtoptinvokeVSR : vA = ( int ) buf [ 1 ] ; vB = ( buf [ 3 ] << 8 ) | buf [ 2 ] ; vC = ( buf [ 5 ] << 8 ) | buf [ 4 ] ; <S2SV_StartBug> sprintf ( str , "<S2SV_blank>{v%i..v%i},<S2SV_blank>[%04x]" , vC , vC + vA - 1 , vB ) ; <S2SV_EndBug> strasm = r_str_concat ( strasm , str ) ; break ; case fmtoptinvokeVS : vA = ( int ) ( buf [ 1 ] & 0xf0 ) >> 4 ; vB = ( buf [ 3 ] << 8 ) | buf [ 2 ] ; switch ( vA ) { case 1 : <S2SV_StartBug> sprintf ( str , "<S2SV_blank>{v%i}" , buf [ 4 ] & 0x0f ) ; <S2SV_EndBug> break ; case 2 : <S2SV_StartBug> sprintf ( str , "<S2SV_blank>{v%i,<S2SV_blank>v%i}" , buf [ 4 ] & 0x0f , ( buf [ 4 ] & 0xf0 ) >> 4 ) ; <S2SV_EndBug> break ; case 3 : <S2SV_StartBug> sprintf ( str , "<S2SV_blank>{v%i,<S2SV_blank>v%i,<S2SV_blank>v%i}" , buf [ 4 ] & 0x0f , <S2SV_EndBug> ( buf [ 4 ] & 0xf0 ) >> 4 , buf [ 5 ] & 0x0f ) ; break ; case 4 : <S2SV_StartBug> sprintf ( str , "<S2SV_blank>{v%i,<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>v%i}" , buf [ 4 ] & 0x0f , <S2SV_EndBug> ( buf [ 4 ] & 0xf0 ) >> 4 , buf [ 5 ] & 0x0f , ( buf [ 5 ] & 0xf0 ) >> 4 ) ; break ; default : <S2SV_StartBug> sprintf ( str , "<S2SV_blank>{}" ) ; <S2SV_EndBug> break ; } strasm = r_str_concat ( strasm , str ) ; <S2SV_StartBug> sprintf ( str , ",<S2SV_blank>[%04x]" , vB ) ; <S2SV_EndBug> strasm = r_str_concat ( strasm , str ) ; break ; case fmtopvAAtBBBB : vA = ( int ) buf [ 1 ] ; vB = ( buf [ 3 ] << 8 ) | buf [ 2 ] ; if ( buf [ 0 ] == 0x1a ) { offset = R_ASM_GET_OFFSET ( a , 's' , vB ) ; if ( offset == - 1 ) { <S2SV_StartBug> sprintf ( str , "<S2SV_blank>v%i,<S2SV_blank>string+%i" , vA , vB ) ; <S2SV_EndBug> } else { <S2SV_StartBug> sprintf ( str , "<S2SV_blank>v%i,<S2SV_blank>0x%" PFMT64x , vA , offset ) ; <S2SV_EndBug> } } else if ( buf [ 0 ] == 0x1c || buf [ 0 ] == 0x1f || buf [ 0 ] == 0x22 ) { flag_str = R_ASM_GET_NAME ( a , 'c' , vB ) ; if ( ! flag_str ) { <S2SV_StartBug> sprintf ( str , "<S2SV_blank>v%i,<S2SV_blank>class+%i" , vA , vB ) ; <S2SV_EndBug> } else { <S2SV_StartBug> sprintf ( str , "<S2SV_blank>v%i,<S2SV_blank>%s" , vA , flag_str ) ; <S2SV_EndBug> } } else { flag_str = R_ASM_GET_NAME ( a , 'f' , vB ) ; if ( ! flag_str ) { <S2SV_StartBug> sprintf ( str , "<S2SV_blank>v%i,<S2SV_blank>field+%i" , vA , vB ) ; <S2SV_EndBug> } else { <S2SV_StartBug> sprintf ( str , "<S2SV_blank>v%i,<S2SV_blank>%s" , vA , flag_str ) ; <S2SV_EndBug> } } strasm = r_str_concat ( strasm , str ) ; break ; case fmtoptopvAvBoCCCC : vA = ( buf [ 1 ] & 0x0f ) ; vB = ( buf [ 1 ] & 0xf0 ) >> 4 ; vC = ( buf [ 3 ] << 8 ) | buf [ 2 ] ; offset = R_ASM_GET_OFFSET ( a , 'o' , vC ) ; if ( offset == - 1 ) { <S2SV_StartBug> sprintf ( str , "<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>[obj+%04x]" , vA , vB , vC ) ; <S2SV_EndBug> } else { <S2SV_StartBug> sprintf ( str , "<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>[0x%" PFMT64x "]" , vA , vB , offset ) ; <S2SV_EndBug> } strasm = r_str_concat ( strasm , str ) ; break ; case fmtopAAtBBBB : vA = ( int ) buf [ 1 ] ; vB = ( buf [ 3 ] << 8 ) | buf [ 2 ] ; offset = R_ASM_GET_OFFSET ( a , 't' , vB ) ; if ( offset == - 1 ) { <S2SV_StartBug> sprintf ( str , "<S2SV_blank>v%i,<S2SV_blank>thing+%i" , vA , vB ) ; <S2SV_EndBug> } else { <S2SV_StartBug> sprintf ( str , "<S2SV_blank>v%i,<S2SV_blank>0x%" PFMT64x , vA , offset ) ; <S2SV_EndBug> } strasm = r_str_concat ( strasm , str ) ; break ; case fmtopvAvBtCCCC : vA = ( buf [ 1 ] & 0x0f ) ; vB = ( buf [ 1 ] & 0xf0 ) >> 4 ; vC = ( buf [ 3 ] << 8 ) | buf [ 2 ] ; if ( buf [ 0 ] == 0x20 || buf [ 0 ] == 0x23 ) { flag_str = R_ASM_GET_NAME ( a , 'c' , vC ) ; if ( flag_str ) { <S2SV_StartBug> sprintf ( str , "<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>%s" , vA , vB , flag_str ) ; <S2SV_EndBug> } else { <S2SV_StartBug> sprintf ( str , "<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>class+%i" , vA , vB , vC ) ; <S2SV_EndBug> } } else { flag_str = R_ASM_GET_NAME ( a , 'f' , vC ) ; if ( flag_str ) { <S2SV_StartBug> sprintf ( str , "<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>%s" , vA , vB , flag_str ) ; <S2SV_EndBug> } else { <S2SV_StartBug> sprintf ( str , "<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>field+%i" , vA , vB , vC ) ; <S2SV_EndBug> } } strasm = r_str_concat ( strasm , str ) ; break ; case fmtopvAAtBBBBBBBB : vA = ( int ) buf [ 1 ] ; vB = ( int ) ( buf [ 5 ] | ( buf [ 4 ] << 8 ) | ( buf [ 3 ] << 16 ) | ( buf [ 2 ] << 24 ) ) ; offset = R_ASM_GET_OFFSET ( a , 's' , vB ) ; if ( offset == - 1 ) { <S2SV_StartBug> sprintf ( str , "<S2SV_blank>v%i,<S2SV_blank>string+%i" , vA , vB ) ; <S2SV_EndBug> } else { <S2SV_StartBug> sprintf ( str , "<S2SV_blank>v%i,<S2SV_blank>0x%" PFMT64x , vA , offset ) ; <S2SV_EndBug> } strasm = r_str_concat ( strasm , str ) ; break ; case fmtopvCCCCmBBBB : vA = ( int ) buf [ 1 ] ; vB = ( buf [ 3 ] << 8 ) | buf [ 2 ] ; vC = ( buf [ 5 ] << 8 ) | buf [ 4 ] ; if ( buf [ 0 ] == 0x25 ) { flag_str = R_ASM_GET_NAME ( a , 'c' , vB ) ; if ( flag_str ) { <S2SV_StartBug> sprintf ( str , "<S2SV_blank>{v%i..v%i},<S2SV_blank>%s" , vC , vC + vA - 1 , flag_str ) ; <S2SV_EndBug> } else { <S2SV_StartBug> sprintf ( str , "<S2SV_blank>{v%i..v%i},<S2SV_blank>class+%i" , vC , vC + vA - 1 , vB ) ; <S2SV_EndBug> } } else { flag_str = R_ASM_GET_NAME ( a , 'm' , vB ) ; if ( flag_str ) { <S2SV_StartBug> sprintf ( str , "<S2SV_blank>{v%i..v%i},<S2SV_blank>%s" , vC , vC + vA - 1 , flag_str ) ; <S2SV_EndBug> } else { <S2SV_StartBug> sprintf ( str , "<S2SV_blank>{v%i..v%i},<S2SV_blank>method+%i" , vC , vC + vA - 1 , vB ) ; <S2SV_EndBug> } } strasm = r_str_concat ( strasm , str ) ; break ; case fmtopvXtBBBB : vA = ( int ) ( buf [ 1 ] & 0xf0 ) >> 4 ; vB = ( buf [ 3 ] << 8 ) | buf [ 2 ] ; switch ( vA ) { case 1 : <S2SV_StartBug> sprintf ( str , "<S2SV_blank>{v%i}" , buf [ 4 ] & 0x0f ) ; <S2SV_EndBug> break ; case 2 : <S2SV_StartBug> sprintf ( str , "<S2SV_blank>{v%i,<S2SV_blank>v%i}" , buf [ 4 ] & 0x0f , ( buf [ 4 ] & 0xf0 ) >> 4 ) ; <S2SV_EndBug> break ; case 3 : <S2SV_StartBug> sprintf ( str , "<S2SV_blank>{v%i,<S2SV_blank>v%i,<S2SV_blank>v%i}" , buf [ 4 ] & 0x0f , <S2SV_EndBug> ( buf [ 4 ] & 0xf0 ) >> 4 , buf [ 5 ] & 0x0f ) ; break ; case 4 : <S2SV_StartBug> sprintf ( str , "<S2SV_blank>{v%i,<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>v%i}" , buf [ 4 ] & 0x0f , <S2SV_EndBug> ( buf [ 4 ] & 0xf0 ) >> 4 , buf [ 5 ] & 0x0f , ( buf [ 5 ] & 0xf0 ) >> 4 ) ; break ; case 5 : <S2SV_StartBug> sprintf ( str , "<S2SV_blank>{v%i,<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>v%i,<S2SV_blank>v%i}" , buf [ 4 ] & 0x0f , <S2SV_EndBug> ( buf [ 4 ] & 0xf0 ) >> 4 , buf [ 5 ] & 0x0f , ( buf [ 5 ] & 0xf0 ) >> 4 , buf [ 1 ] & 0x0f ) ; break ; default : <S2SV_StartBug> sprintf ( str , "<S2SV_blank>{}" ) ; <S2SV_EndBug> } strasm = r_str_concat ( strasm , str ) ; if ( buf [ 0 ] == 0x24 ) { flag_str = R_ASM_GET_NAME ( a , 'c' , vB ) ; if ( flag_str ) { <S2SV_StartBug> sprintf ( str , ",<S2SV_blank>%s<S2SV_blank>;<S2SV_blank>0x%x" , flag_str , vB ) ; <S2SV_EndBug> } else { <S2SV_StartBug> sprintf ( str , ",<S2SV_blank>class+%i" , vB ) ; <S2SV_EndBug> } } else { flag_str = R_ASM_GET_NAME ( a , 'm' , vB ) ; if ( flag_str ) { <S2SV_StartBug> sprintf ( str , ",<S2SV_blank>%s<S2SV_blank>;<S2SV_blank>0x%x" , flag_str , vB ) ; <S2SV_EndBug> } else { <S2SV_StartBug> sprintf ( str , ",<S2SV_blank>method+%i" , vB ) ; <S2SV_EndBug> } } strasm = r_str_concat ( strasm , str ) ; break ; case fmtoptinvokeI : case fmtoptinvokeIR : case fmt00 : default : strcpy ( op -> buf_asm , "invalid<S2SV_blank>" ) ; free ( strasm ) ; strasm = NULL ; size = 2 ; } if ( strasm ) { strncpy ( op -> buf_asm , strasm , sizeof ( op -> buf_asm ) - 1 ) ; op -> buf_asm [ sizeof ( op -> buf_asm ) - 1 ] = 0 ; } else { strcpy ( op -> buf_asm , "invalid" ) ; } } else if ( len > 0 ) { strcpy ( op -> buf_asm , "invalid<S2SV_blank>" ) ; op -> size = len ; size = len ; } op -> payload = payload ; size += payload ; op -> size = size ; free ( strasm ) ; return size ; }
GF_Err tenc_box_read ( GF_Box * s , GF_BitStream * bs ) { u8 iv_size ; GF_TrackEncryptionBox * ptr = ( GF_TrackEncryptionBox * ) s ; ISOM_DECREASE_SIZE ( ptr , 3 ) ; gf_bs_read_u8 ( bs ) ; if ( ! ptr -> version ) { gf_bs_read_u8 ( bs ) ; } else { ptr -> crypt_byte_block = gf_bs_read_int ( bs , 4 ) ; ptr -> skip_byte_block = gf_bs_read_int ( bs , 4 ) ; } ptr -> isProtected = gf_bs_read_u8 ( bs ) ; ISOM_DECREASE_SIZE ( ptr , 17 ) ; ptr -> key_info [ 0 ] = 0 ; ptr -> key_info [ 1 ] = 0 ; ptr -> key_info [ 2 ] = 0 ; ptr -> key_info [ 3 ] = iv_size = gf_bs_read_u8 ( bs ) ; gf_bs_read_data ( bs , ptr -> key_info + 4 , 16 ) ; if ( ! iv_size && ptr -> isProtected ) { ISOM_DECREASE_SIZE ( ptr , 1 ) ; iv_size = ptr -> key_info [ 20 ] = gf_bs_read_u8 ( bs ) ; ISOM_DECREASE_SIZE ( ptr , ptr -> key_info [ 20 ] ) ; <S2SV_StartBug> gf_bs_read_data ( bs , ptr -> key_info + 21 , iv_size ) ; <S2SV_EndBug> } <S2SV_StartBug> return GF_OK ; <S2SV_EndBug> }
int btrfs_add_link ( struct btrfs_trans_handle * trans , struct inode * parent_inode , struct inode * inode , const char * name , int name_len , int add_backref , u64 index ) { int ret = 0 ; struct btrfs_key key ; struct btrfs_root * root = BTRFS_I ( parent_inode ) -> root ; u64 ino = btrfs_ino ( inode ) ; u64 parent_ino = btrfs_ino ( parent_inode ) ; if ( unlikely ( ino == BTRFS_FIRST_FREE_OBJECTID ) ) { memcpy ( & key , & BTRFS_I ( inode ) -> root -> root_key , sizeof ( key ) ) ; } else { key . objectid = ino ; btrfs_set_key_type ( & key , BTRFS_INODE_ITEM_KEY ) ; key . offset = 0 ; } if ( unlikely ( ino == BTRFS_FIRST_FREE_OBJECTID ) ) { ret = btrfs_add_root_ref ( trans , root -> fs_info -> tree_root , key . objectid , root -> root_key . objectid , parent_ino , index , name , name_len ) ; } else if ( add_backref ) { ret = btrfs_insert_inode_ref ( trans , root , name , name_len , ino , parent_ino , index ) ; } if ( ret ) return ret ; ret = btrfs_insert_dir_item ( trans , root , name , name_len , parent_inode , & key , btrfs_inode_type ( inode ) , index ) ; <S2SV_StartBug> if ( ret == - EEXIST ) <S2SV_EndBug> goto fail_dir_item ; else if ( ret ) { btrfs_abort_transaction ( trans , root , ret ) ; return ret ; } btrfs_i_size_write ( parent_inode , parent_inode -> i_size + name_len * 2 ) ; inode_inc_iversion ( parent_inode ) ; parent_inode -> i_mtime = parent_inode -> i_ctime = CURRENT_TIME ; ret = btrfs_update_inode ( trans , root , parent_inode ) ; if ( ret ) btrfs_abort_transaction ( trans , root , ret ) ; return ret ; fail_dir_item : if ( unlikely ( ino == BTRFS_FIRST_FREE_OBJECTID ) ) { u64 local_index ; int err ; err = btrfs_del_root_ref ( trans , root -> fs_info -> tree_root , key . objectid , root -> root_key . objectid , parent_ino , & local_index , name , name_len ) ; } else if ( add_backref ) { u64 local_index ; int err ; err = btrfs_del_inode_ref ( trans , root , name , name_len , ino , parent_ino , & local_index ) ; } return ret ; }
WORD32 impeg2d_get_slice_pos ( dec_state_multi_core_t * ps_dec_state_multi_core ) { WORD32 u4_bits ; WORD32 i4_row ; dec_state_t * ps_dec = ps_dec_state_multi_core -> ps_dec_state [ 0 ] ; WORD32 i4_prev_row ; stream_t s_bitstrm ; WORD32 i4_start_row ; WORD32 i4_slice_bistream_ofst ; WORD32 i ; s_bitstrm = ps_dec -> s_bit_stream ; i4_prev_row = - 1 ; ps_dec_state_multi_core -> ps_dec_state [ 0 ] -> i4_start_mb_y = 0 ; ps_dec_state_multi_core -> ps_dec_state [ 1 ] -> i4_start_mb_y = - 1 ; ps_dec_state_multi_core -> ps_dec_state [ 2 ] -> i4_start_mb_y = - 1 ; ps_dec_state_multi_core -> ps_dec_state [ 3 ] -> i4_start_mb_y = - 1 ; ps_dec_state_multi_core -> ps_dec_state [ 0 ] -> i4_end_mb_y = ps_dec -> u2_num_vert_mb ; ps_dec_state_multi_core -> ps_dec_state [ 1 ] -> i4_end_mb_y = - 1 ; ps_dec_state_multi_core -> ps_dec_state [ 2 ] -> i4_end_mb_y = - 1 ; ps_dec_state_multi_core -> ps_dec_state [ 3 ] -> i4_end_mb_y = - 1 ; if ( ps_dec -> i4_num_cores == 1 ) return 0 ; impeg2_jobq_reset ( ( jobq_t * ) ps_dec -> pv_jobq ) ; i4_start_row = - 1 ; i4_slice_bistream_ofst = 0 ; while ( 1 ) { WORD32 i4_is_slice ; if ( s_bitstrm . u4_offset + START_CODE_LEN >= s_bitstrm . u4_max_offset ) { break ; } u4_bits = impeg2d_bit_stream_nxt ( & s_bitstrm , START_CODE_LEN ) ; i4_row = u4_bits & 0xFF ; i4_is_slice = ( ( ( u4_bits >> 8 ) == 0x01 ) && ( i4_row ) && ( i4_row <= ps_dec -> u2_num_vert_mb ) ) ; if ( ! i4_is_slice ) break ; i4_row -= 1 ; <S2SV_StartBug> if ( i4_prev_row != i4_row ) <S2SV_EndBug> { if ( i4_start_row != - 1 ) { job_t s_job ; IV_API_CALL_STATUS_T ret ; s_job . i2_start_mb_y = i4_start_row ; s_job . i2_end_mb_y = i4_row ; s_job . i4_cmd = CMD_PROCESS ; s_job . i4_bistream_ofst = i4_slice_bistream_ofst ; ret = impeg2_jobq_queue ( ps_dec -> pv_jobq , & s_job , sizeof ( s_job ) , 1 , 0 ) ; if ( ret != IV_SUCCESS ) return ret ; } i4_slice_bistream_ofst = s_bitstrm . u4_offset >> 3 ; i4_slice_bistream_ofst -= ( size_t ) s_bitstrm . pv_bs_buf & 3 ; i4_prev_row = i4_row ; i4_start_row = i4_row ; <S2SV_StartBug> } <S2SV_EndBug> impeg2d_bit_stream_flush ( & s_bitstrm , START_CODE_LEN ) ; while ( impeg2d_bit_stream_nxt ( & s_bitstrm , 24 ) != START_CODE_PREFIX ) { impeg2d_bit_stream_get ( & s_bitstrm , 8 ) ; if ( s_bitstrm . u4_offset >= s_bitstrm . u4_max_offset ) { break ; } } } { job_t s_job ; IV_API_CALL_STATUS_T e_ret ; s_job . i2_start_mb_y = i4_start_row ; s_job . i2_end_mb_y = ps_dec -> u2_num_vert_mb ; s_job . i4_cmd = CMD_PROCESS ; s_job . i4_bistream_ofst = i4_slice_bistream_ofst ; e_ret = impeg2_jobq_queue ( ps_dec -> pv_jobq , & s_job , sizeof ( s_job ) , 1 , 0 ) ; if ( e_ret != IV_SUCCESS ) return e_ret ; } if ( ( NULL != ps_dec -> ps_disp_pic ) && ( ( 0 == ps_dec -> u4_share_disp_buf ) || ( IV_YUV_420P != ps_dec -> i4_chromaFormat ) ) ) { for ( i = 0 ; i < ps_dec -> u2_vertical_size ; i += 64 ) { job_t s_job ; IV_API_CALL_STATUS_T ret ; s_job . i2_start_mb_y = i ; s_job . i2_start_mb_y >>= 4 ; s_job . i2_end_mb_y = ( i + 64 ) ; s_job . i2_end_mb_y >>= 4 ; s_job . i4_cmd = CMD_FMTCONV ; s_job . i4_bistream_ofst = 0 ; ret = impeg2_jobq_queue ( ps_dec -> pv_jobq , & s_job , sizeof ( s_job ) , 1 , 0 ) ; if ( ret != IV_SUCCESS ) return ret ; } } impeg2_jobq_terminate ( ps_dec -> pv_jobq ) ; ps_dec -> i4_bytes_consumed = s_bitstrm . u4_offset >> 3 ; ps_dec -> i4_bytes_consumed -= ( ( size_t ) s_bitstrm . pv_bs_buf & 3 ) ; return 0 ; }
static struct page * alloc_huge_page ( struct vm_area_struct * vma , unsigned long addr , int avoid_reserve ) { <S2SV_StartBug> struct hstate * h = hstate_vma ( vma ) ; <S2SV_EndBug> <S2SV_StartBug> struct page * page ; <S2SV_EndBug> struct address_space * mapping = vma -> vm_file -> f_mapping ; struct inode * inode = mapping -> host ; long chg ; chg = vma_needs_reservation ( h , vma , addr ) ; if ( chg < 0 ) return ERR_PTR ( - VM_FAULT_OOM ) ; if ( chg ) <S2SV_StartBug> if ( hugetlb_get_quota ( inode -> i_mapping , chg ) ) <S2SV_EndBug> return ERR_PTR ( - VM_FAULT_SIGBUS ) ; spin_lock ( & hugetlb_lock ) ; page = dequeue_huge_page_vma ( h , vma , addr , avoid_reserve ) ; spin_unlock ( & hugetlb_lock ) ; if ( ! page ) { page = alloc_buddy_huge_page ( h , NUMA_NO_NODE ) ; if ( ! page ) { <S2SV_StartBug> hugetlb_put_quota ( inode -> i_mapping , chg ) ; <S2SV_EndBug> return ERR_PTR ( - VM_FAULT_SIGBUS ) ; } } <S2SV_StartBug> set_page_private ( page , ( unsigned long ) mapping ) ; <S2SV_EndBug> vma_commit_reservation ( h , vma , addr ) ; return page ; }
static int wrmsr_interception ( struct vcpu_svm * svm ) { struct msr_data msr ; u32 ecx = svm -> vcpu . arch . regs [ VCPU_REGS_RCX ] ; u64 data = ( svm -> vcpu . arch . regs [ VCPU_REGS_RAX ] & - 1u ) | ( ( u64 ) ( svm -> vcpu . arch . regs [ VCPU_REGS_RDX ] & - 1u ) << 32 ) ; msr . data = data ; msr . index = ecx ; msr . host_initiated = false ; svm -> next_rip = kvm_rip_read ( & svm -> vcpu ) + 2 ; <S2SV_StartBug> if ( svm_set_msr ( & svm -> vcpu , & msr ) ) { <S2SV_EndBug> trace_kvm_msr_write_ex ( ecx , data ) ; kvm_inject_gp ( & svm -> vcpu , 0 ) ; } else { trace_kvm_msr_write ( ecx , data ) ; skip_emulated_instruction ( & svm -> vcpu ) ; } return 1 ; }
int jas_memdump ( FILE * out , void * data , size_t len ) { size_t i ; size_t j ; <S2SV_StartBug> uchar * dp ; <S2SV_EndBug> dp = data ; for ( i = 0 ; i < len ; i += 16 ) { fprintf ( out , "%04zx:" , i ) ; for ( j = 0 ; j < 16 ; ++ j ) { if ( i + j < len ) { fprintf ( out , "<S2SV_blank>%02x" , dp [ i + j ] ) ; } } fprintf ( out , "\\n" ) ; } return 0 ; }
static int aes_ccm_ctrl ( EVP_CIPHER_CTX * c , int type , int arg , void * ptr ) { EVP_AES_CCM_CTX * cctx = EVP_C_DATA ( EVP_AES_CCM_CTX , c ) ; switch ( type ) { case EVP_CTRL_INIT : cctx -> key_set = 0 ; cctx -> iv_set = 0 ; cctx -> L = 8 ; cctx -> M = 12 ; cctx -> tag_set = 0 ; cctx -> len_set = 0 ; cctx -> tls_aad_len = - 1 ; return 1 ; case EVP_CTRL_AEAD_TLS1_AAD : if ( arg != EVP_AEAD_TLS1_AAD_LEN ) return 0 ; memcpy ( EVP_CIPHER_CTX_buf_noconst ( c ) , ptr , arg ) ; cctx -> tls_aad_len = arg ; { uint16_t len = EVP_CIPHER_CTX_buf_noconst ( c ) [ arg - 2 ] << 8 | EVP_CIPHER_CTX_buf_noconst ( c ) [ arg - 1 ] ; <S2SV_StartBug> len -= EVP_CCM_TLS_EXPLICIT_IV_LEN ; <S2SV_EndBug> <S2SV_StartBug> if ( ! EVP_CIPHER_CTX_encrypting ( c ) ) <S2SV_EndBug> <S2SV_StartBug> len -= cctx -> M ; <S2SV_EndBug> EVP_CIPHER_CTX_buf_noconst ( c ) [ arg - 2 ] = len >> 8 ; EVP_CIPHER_CTX_buf_noconst ( c ) [ arg - 1 ] = len & 0xff ; } return cctx -> M ; case EVP_CTRL_CCM_SET_IV_FIXED : if ( arg != EVP_CCM_TLS_FIXED_IV_LEN ) return 0 ; memcpy ( EVP_CIPHER_CTX_iv_noconst ( c ) , ptr , arg ) ; return 1 ; case EVP_CTRL_AEAD_SET_IVLEN : arg = 15 - arg ; case EVP_CTRL_CCM_SET_L : if ( arg < 2 || arg > 8 ) return 0 ; cctx -> L = arg ; return 1 ; case EVP_CTRL_AEAD_SET_TAG : if ( ( arg & 1 ) || arg < 4 || arg > 16 ) return 0 ; if ( EVP_CIPHER_CTX_encrypting ( c ) && ptr ) return 0 ; if ( ptr ) { cctx -> tag_set = 1 ; memcpy ( EVP_CIPHER_CTX_buf_noconst ( c ) , ptr , arg ) ; } cctx -> M = arg ; return 1 ; case EVP_CTRL_AEAD_GET_TAG : if ( ! EVP_CIPHER_CTX_encrypting ( c ) || ! cctx -> tag_set ) return 0 ; if ( ! CRYPTO_ccm128_tag ( & cctx -> ccm , ptr , ( size_t ) arg ) ) return 0 ; cctx -> tag_set = 0 ; cctx -> iv_set = 0 ; cctx -> len_set = 0 ; return 1 ; case EVP_CTRL_COPY : { EVP_CIPHER_CTX * out = ptr ; EVP_AES_CCM_CTX * cctx_out = EVP_C_DATA ( EVP_AES_CCM_CTX , out ) ; if ( cctx -> ccm . key ) { if ( cctx -> ccm . key != & cctx -> ks ) return 0 ; cctx_out -> ccm . key = & cctx_out -> ks ; } return 1 ; } default : return - 1 ; } }
static Image * ReadMATImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image , * image2 = NULL , * rotated_image ; PixelPacket * q ; unsigned int status ; MATHeader MATLAB_HDR ; size_t size ; size_t CellType ; QuantumInfo * quantum_info ; ImageInfo * clone_info ; int i ; ssize_t ldblk ; unsigned char * BImgBuff = NULL ; double MinVal , MaxVal ; size_t Unknown6 ; unsigned z , z2 ; unsigned Frames ; int logging ; int sample_size ; MagickOffsetType filepos = 0x80 ; BlobInfo * blob ; size_t one ; unsigned int ( * ReadBlobXXXLong ) ( Image * image ) ; unsigned short ( * ReadBlobXXXShort ) ( Image * image ) ; void ( * ReadBlobDoublesXXX ) ( Image * image , size_t len , double * data ) ; void ( * ReadBlobFloatsXXX ) ( Image * image , size_t len , float * data ) ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; logging = LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "enter" ) ; quantum_info = ( QuantumInfo * ) NULL ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } clone_info = ( ImageInfo * ) NULL ; if ( ReadBlob ( image , 124 , ( unsigned char * ) & MATLAB_HDR . identific ) != 124 ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; if ( strncmp ( MATLAB_HDR . identific , "MATLAB" , 6 ) != 0 ) { image2 = ReadMATImageV4 ( image_info , image , exception ) ; if ( image2 == NULL ) goto MATLAB_KO ; image = image2 ; goto END_OF_READING ; } MATLAB_HDR . Version = ReadBlobLSBShort ( image ) ; if ( ReadBlob ( image , 2 , ( unsigned char * ) & MATLAB_HDR . EndianIndicator ) != 2 ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "<S2SV_blank><S2SV_blank>Endian<S2SV_blank>%c%c" , MATLAB_HDR . EndianIndicator [ 0 ] , MATLAB_HDR . EndianIndicator [ 1 ] ) ; if ( ! strncmp ( MATLAB_HDR . EndianIndicator , "IM" , 2 ) ) { ReadBlobXXXLong = ReadBlobLSBLong ; ReadBlobXXXShort = ReadBlobLSBShort ; ReadBlobDoublesXXX = ReadBlobDoublesLSB ; ReadBlobFloatsXXX = ReadBlobFloatsLSB ; image -> endian = LSBEndian ; } else if ( ! strncmp ( MATLAB_HDR . EndianIndicator , "MI" , 2 ) ) { ReadBlobXXXLong = ReadBlobMSBLong ; ReadBlobXXXShort = ReadBlobMSBShort ; ReadBlobDoublesXXX = ReadBlobDoublesMSB ; ReadBlobFloatsXXX = ReadBlobFloatsMSB ; image -> endian = MSBEndian ; } else goto MATLAB_KO ; if ( strncmp ( MATLAB_HDR . identific , "MATLAB" , 6 ) ) <S2SV_StartBug> MATLAB_KO : ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; <S2SV_EndBug> filepos = TellBlob ( image ) ; while ( ! EOFBlob ( image ) ) { Frames = 1 ; ( void ) SeekBlob ( image , filepos , SEEK_SET ) ; MATLAB_HDR . DataType = ReadBlobXXXLong ( image ) ; if ( EOFBlob ( image ) ) break ; MATLAB_HDR . ObjectSize = ReadBlobXXXLong ( image ) ; if ( EOFBlob ( image ) ) break ; if ( MATLAB_HDR . ObjectSize + filepos > GetBlobSize ( image ) ) goto MATLAB_KO ; filepos += MATLAB_HDR . ObjectSize + 4 + 4 ; clone_info = CloneImageInfo ( image_info ) ; image2 = image ; # if defined ( MAGICKCORE_ZLIB_DELEGATE ) if ( MATLAB_HDR . DataType == miCOMPRESSED ) { image2 = decompress_block ( image , & MATLAB_HDR . ObjectSize , clone_info , exception ) ; if ( image2 == NULL ) continue ; MATLAB_HDR . DataType = ReadBlobXXXLong ( image2 ) ; } # endif if ( MATLAB_HDR . DataType != miMATRIX ) continue ; MATLAB_HDR . unknown1 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown2 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown5 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . StructureClass = MATLAB_HDR . unknown5 & 0xFF ; MATLAB_HDR . StructureFlag = ( MATLAB_HDR . unknown5 >> 8 ) & 0xFF ; MATLAB_HDR . unknown3 = ReadBlobXXXLong ( image2 ) ; if ( image != image2 ) MATLAB_HDR . unknown4 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . unknown4 = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . DimFlag = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . SizeX = ReadBlobXXXLong ( image2 ) ; MATLAB_HDR . SizeY = ReadBlobXXXLong ( image2 ) ; switch ( MATLAB_HDR . DimFlag ) { case 8 : z2 = z = 1 ; break ; case 12 : z2 = z = ReadBlobXXXLong ( image2 ) ; Unknown6 = ReadBlobXXXLong ( image2 ) ; ( void ) Unknown6 ; if ( z != 3 ) ThrowReaderException ( CoderError , "MultidimensionalMatricesAreNotSupported" ) ; break ; case 16 : z2 = z = ReadBlobXXXLong ( image2 ) ; if ( z != 3 && z != 1 ) ThrowReaderException ( CoderError , "MultidimensionalMatricesAreNotSupported" ) ; Frames = ReadBlobXXXLong ( image2 ) ; if ( Frames == 0 ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; break ; default : ThrowReaderException ( CoderError , "MultidimensionalMatricesAreNotSupported" ) ; } MATLAB_HDR . Flag1 = ReadBlobXXXShort ( image2 ) ; MATLAB_HDR . NameFlag = ReadBlobXXXShort ( image2 ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "MATLAB_HDR.StructureClass<S2SV_blank>%d" , MATLAB_HDR . StructureClass ) ; if ( MATLAB_HDR . StructureClass != mxCHAR_CLASS && MATLAB_HDR . StructureClass != mxSINGLE_CLASS && MATLAB_HDR . StructureClass != mxDOUBLE_CLASS && MATLAB_HDR . StructureClass != mxINT8_CLASS && MATLAB_HDR . StructureClass != mxUINT8_CLASS && MATLAB_HDR . StructureClass != mxINT16_CLASS && MATLAB_HDR . StructureClass != mxUINT16_CLASS && MATLAB_HDR . StructureClass != mxINT32_CLASS && MATLAB_HDR . StructureClass != mxUINT32_CLASS && MATLAB_HDR . StructureClass != mxINT64_CLASS && MATLAB_HDR . StructureClass != mxUINT64_CLASS ) ThrowReaderException ( CoderError , "UnsupportedCellTypeInTheMatrix" ) ; switch ( MATLAB_HDR . NameFlag ) { case 0 : size = ReadBlobXXXLong ( image2 ) ; size = 4 * ( ssize_t ) ( ( size + 3 + 1 ) / 4 ) ; ( void ) SeekBlob ( image2 , size , SEEK_CUR ) ; break ; case 1 : case 2 : case 3 : case 4 : ( void ) ReadBlob ( image2 , 4 , ( unsigned char * ) & size ) ; break ; default : goto MATLAB_KO ; } CellType = ReadBlobXXXLong ( image2 ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "MATLAB_HDR.CellType:<S2SV_blank>%.20g" , ( double ) CellType ) ; ( void ) ReadBlob ( image2 , 4 , ( unsigned char * ) & size ) ; NEXT_FRAME : switch ( CellType ) { case miINT8 : case miUINT8 : sample_size = 8 ; if ( MATLAB_HDR . StructureFlag & FLAG_LOGICAL ) image -> depth = 1 ; else image -> depth = 8 ; ldblk = ( ssize_t ) MATLAB_HDR . SizeX ; break ; case miINT16 : case miUINT16 : sample_size = 16 ; image -> depth = 16 ; ldblk = ( ssize_t ) ( 2 * MATLAB_HDR . SizeX ) ; break ; case miINT32 : case miUINT32 : sample_size = 32 ; image -> depth = 32 ; ldblk = ( ssize_t ) ( 4 * MATLAB_HDR . SizeX ) ; break ; case miINT64 : case miUINT64 : sample_size = 64 ; image -> depth = 64 ; ldblk = ( ssize_t ) ( 8 * MATLAB_HDR . SizeX ) ; break ; case miSINGLE : sample_size = 32 ; image -> depth = 32 ; ( void ) SetImageOption ( clone_info , "quantum:format" , "floating-point" ) ; if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { } ldblk = ( ssize_t ) ( 4 * MATLAB_HDR . SizeX ) ; break ; case miDOUBLE : sample_size = 64 ; image -> depth = 64 ; ( void ) SetImageOption ( clone_info , "quantum:format" , "floating-point" ) ; DisableMSCWarning ( 4127 ) if ( sizeof ( double ) != 8 ) RestoreMSCWarning ThrowReaderException ( CoderError , "IncompatibleSizeOfDouble" ) ; if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { } ldblk = ( ssize_t ) ( 8 * MATLAB_HDR . SizeX ) ; break ; default : ThrowReaderException ( CoderError , "UnsupportedCellTypeInTheMatrix" ) ; } ( void ) sample_size ; image -> columns = MATLAB_HDR . SizeX ; image -> rows = MATLAB_HDR . SizeY ; one = 1 ; image -> colors = one << image -> depth ; if ( image -> columns == 0 || image -> rows == 0 ) goto MATLAB_KO ; if ( ( unsigned long ) ldblk * MATLAB_HDR . SizeY > MATLAB_HDR . ObjectSize ) goto MATLAB_KO ; if ( ( MATLAB_HDR . DimFlag == 8 ) && ( ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) == 0 ) ) { SetImageColorspace ( image , GRAYColorspace ) ; image -> type = GrayscaleType ; } if ( image_info -> ping ) { size_t temp = image -> columns ; image -> columns = image -> rows ; image -> rows = temp ; goto done_reading ; } status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } quantum_info = AcquireQuantumInfo ( clone_info , image ) ; if ( quantum_info == ( QuantumInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; BImgBuff = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) ( ldblk ) , sizeof ( double ) ) ; if ( BImgBuff == NULL ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; ( void ) ResetMagickMemory ( BImgBuff , 0 , ldblk * sizeof ( double ) ) ; MinVal = 0 ; MaxVal = 0 ; if ( CellType == miDOUBLE || CellType == miSINGLE ) { CalcMinMax ( image2 , image_info -> endian , MATLAB_HDR . SizeX , MATLAB_HDR . SizeY , CellType , ldblk , BImgBuff , & quantum_info -> minimum , & quantum_info -> maximum ) ; } if ( z == 1 ) z = 0 ; do { for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { q = GetAuthenticPixels ( image , 0 , MATLAB_HDR . SizeY - i - 1 , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "<S2SV_blank><S2SV_blank>MAT<S2SV_blank>set<S2SV_blank>image<S2SV_blank>pixels<S2SV_blank>returns<S2SV_blank>unexpected<S2SV_blank>NULL<S2SV_blank>on<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u." , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto done_reading ; } if ( ReadBlob ( image2 , ldblk , ( unsigned char * ) BImgBuff ) != ( ssize_t ) ldblk ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "<S2SV_blank><S2SV_blank>MAT<S2SV_blank>cannot<S2SV_blank>read<S2SV_blank>scanrow<S2SV_blank>%u<S2SV_blank>from<S2SV_blank>a<S2SV_blank>file." , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto ExitLoop ; } if ( ( CellType == miINT8 || CellType == miUINT8 ) && ( MATLAB_HDR . StructureFlag & FLAG_LOGICAL ) ) { FixLogical ( ( unsigned char * ) BImgBuff , ldblk ) ; if ( ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , z2qtype [ z ] , BImgBuff , exception ) <= 0 ) { ImportQuantumPixelsFailed : if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "<S2SV_blank><S2SV_blank>MAT<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>ImportQuantumPixels<S2SV_blank>for<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; break ; } } else { if ( ImportQuantumPixels ( image , ( CacheView * ) NULL , quantum_info , z2qtype [ z ] , BImgBuff , exception ) <= 0 ) goto ImportQuantumPixelsFailed ; if ( z <= 1 && ( CellType == miINT8 || CellType == miINT16 || CellType == miINT32 || CellType == miINT64 ) ) FixSignedValues ( q , MATLAB_HDR . SizeX ) ; } if ( ! SyncAuthenticPixels ( image , exception ) ) { if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "<S2SV_blank><S2SV_blank>MAT<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>sync<S2SV_blank>image<S2SV_blank>pixels<S2SV_blank>for<S2SV_blank>a<S2SV_blank>row<S2SV_blank>%u" , ( unsigned ) ( MATLAB_HDR . SizeY - i - 1 ) ) ; goto ExitLoop ; } } } while ( z -- >= 2 ) ; ExitLoop : if ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) { CellType = ReadBlobXXXLong ( image2 ) ; i = ReadBlobXXXLong ( image2 ) ; if ( CellType == miDOUBLE || CellType == miSINGLE ) { CalcMinMax ( image2 , image_info -> endian , MATLAB_HDR . SizeX , MATLAB_HDR . SizeY , CellType , ldblk , BImgBuff , & MinVal , & MaxVal ) ; } if ( CellType == miDOUBLE ) for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { ReadBlobDoublesXXX ( image2 , ldblk , ( double * ) BImgBuff ) ; InsertComplexDoubleRow ( ( double * ) BImgBuff , i , image , MinVal , MaxVal ) ; } if ( CellType == miSINGLE ) for ( i = 0 ; i < ( ssize_t ) MATLAB_HDR . SizeY ; i ++ ) { ReadBlobFloatsXXX ( image2 , ldblk , ( float * ) BImgBuff ) ; InsertComplexFloatRow ( ( float * ) BImgBuff , i , image , MinVal , MaxVal ) ; } } if ( ( MATLAB_HDR . DimFlag == 8 ) && ( ( MATLAB_HDR . StructureFlag & FLAG_COMPLEX ) == 0 ) ) image -> type = GrayscaleType ; if ( image -> depth == 1 ) image -> type = BilevelType ; if ( image2 == image ) image2 = NULL ; rotated_image = RotateImage ( image , 90.0 , exception ) ; if ( rotated_image != ( Image * ) NULL ) { rotated_image -> page . x = 0 ; rotated_image -> page . y = 0 ; blob = rotated_image -> blob ; rotated_image -> blob = image -> blob ; rotated_image -> colors = image -> colors ; image -> blob = blob ; AppendImageToList ( & image , rotated_image ) ; DeleteImageFromList ( & image ) ; } done_reading : if ( image2 != NULL ) if ( image2 != image ) { DeleteImageFromList ( & image2 ) ; if ( clone_info ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } } } AcquireNextImage ( image_info , image ) ; if ( image -> next == ( Image * ) NULL ) break ; image = SyncNextImageInList ( image ) ; image -> columns = image -> rows = 0 ; image -> colors = 0 ; RelinquishMagickMemory ( BImgBuff ) ; BImgBuff = NULL ; if ( -- Frames > 0 ) { z = z2 ; if ( image2 == NULL ) image2 = image ; goto NEXT_FRAME ; } if ( image2 != NULL ) if ( image2 != image ) { DeleteImageFromList ( & image2 ) ; if ( clone_info ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) unlink ( clone_info -> filename ) ; } } } } RelinquishMagickMemory ( BImgBuff ) ; if ( quantum_info != ( QuantumInfo * ) NULL ) quantum_info = DestroyQuantumInfo ( quantum_info ) ; END_OF_READING : if ( clone_info ) clone_info = DestroyImageInfo ( clone_info ) ; CloseBlob ( image ) ; { Image * p ; ssize_t scene = 0 ; p = image ; image = NULL ; while ( p != ( Image * ) NULL ) { Image * tmp = p ; if ( ( p -> rows == 0 ) || ( p -> columns == 0 ) ) { p = p -> previous ; DeleteImageFromList ( & tmp ) ; } else { image = p ; p = p -> previous ; } } for ( p = image ; p != ( Image * ) NULL ; p = p -> next ) p -> scene = scene ++ ; } if ( clone_info != NULL ) { if ( clone_info -> file ) { fclose ( clone_info -> file ) ; clone_info -> file = NULL ; ( void ) remove_utf8 ( clone_info -> filename ) ; } DestroyImageInfo ( clone_info ) ; clone_info = NULL ; } if ( logging ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "return" ) ; if ( image == NULL ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; return ( image ) ; }
static int misaligned_fpu_load ( struct pt_regs * regs , __u32 opcode , int displacement_not_indexed , int width_shift , int do_paired_load ) { int error ; int destreg ; __u64 address ; error = generate_and_check_address ( regs , opcode , displacement_not_indexed , width_shift , & address ) ; if ( error < 0 ) { return error ; } <S2SV_StartBug> perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , 0 , regs , address ) ; <S2SV_EndBug> destreg = ( opcode >> 4 ) & 0x3f ; if ( user_mode ( regs ) ) { __u64 buffer ; __u32 buflo , bufhi ; if ( ! access_ok ( VERIFY_READ , ( unsigned long ) address , 1UL << width_shift ) ) { return - 1 ; } if ( __copy_user ( & buffer , ( const void * ) ( int ) address , ( 1 << width_shift ) ) > 0 ) { return - 1 ; } if ( last_task_used_math == current ) { enable_fpu ( ) ; save_fpu ( current ) ; disable_fpu ( ) ; last_task_used_math = NULL ; regs -> sr |= SR_FD ; } buflo = * ( __u32 * ) & buffer ; bufhi = * ( 1 + ( __u32 * ) & buffer ) ; switch ( width_shift ) { case 2 : current -> thread . xstate -> hardfpu . fp_regs [ destreg ] = buflo ; break ; case 3 : if ( do_paired_load ) { current -> thread . xstate -> hardfpu . fp_regs [ destreg ] = buflo ; current -> thread . xstate -> hardfpu . fp_regs [ destreg + 1 ] = bufhi ; } else { # if defined ( CONFIG_CPU_LITTLE_ENDIAN ) current -> thread . xstate -> hardfpu . fp_regs [ destreg ] = bufhi ; current -> thread . xstate -> hardfpu . fp_regs [ destreg + 1 ] = buflo ; # else current -> thread . xstate -> hardfpu . fp_regs [ destreg ] = buflo ; current -> thread . xstate -> hardfpu . fp_regs [ destreg + 1 ] = bufhi ; # endif } break ; default : printk ( "Unexpected<S2SV_blank>width_shift<S2SV_blank>%d<S2SV_blank>in<S2SV_blank>misaligned_fpu_load,<S2SV_blank>PC=%08lx\\n" , width_shift , ( unsigned long ) regs -> pc ) ; break ; } return 0 ; } else { die ( "Misaligned<S2SV_blank>FPU<S2SV_blank>load<S2SV_blank>inside<S2SV_blank>kernel" , regs , 0 ) ; return - 1 ; } }
int bad_format_imginfo ( char * fmt ) { <S2SV_StartBug> char * ptr ; <S2SV_EndBug> int n = 0 ; ptr = fmt ; while ( * ptr != '\\0' ) if ( * ptr ++ == '%' ) { if ( * ptr == '\\0' ) return 1 ; if ( * ptr == '%' ) ptr ++ ; else if ( * ptr == 's' || * ptr == 'S' ) { n = 1 ; ptr ++ ; } else { if ( * ptr == '<S2SV_blank>' ) ptr ++ ; while ( * ptr >= '0' && * ptr <= '9' ) ptr ++ ; if ( * ptr ++ != 'l' ) return 1 ; if ( * ptr == 'u' ) ptr ++ ; else return 1 ; n ++ ; } } return ( n != 3 ) ; }
static int decoding_feof ( struct tok_state * tok ) { if ( tok -> decoding_state != STATE_NORMAL ) { return feof ( tok -> fp ) ; } else { PyObject * buf = tok -> decoding_buffer ; if ( buf == NULL ) { <S2SV_StartBug> buf = PyObject_CallObject ( tok -> decoding_readline , NULL ) ; <S2SV_EndBug> if ( buf == NULL ) { error_ret ( tok ) ; return 1 ; } else { tok -> decoding_buffer = buf ; } } return PyObject_Length ( buf ) == 0 ; } }
static int simulate_rdhwr ( struct pt_regs * regs , unsigned int opcode ) { struct thread_info * ti = task_thread_info ( current ) ; if ( ( opcode & OPCODE ) == SPEC3 && ( opcode & FUNC ) == RDHWR ) { int rd = ( opcode & RD ) >> 11 ; int rt = ( opcode & RT ) >> 16 ; perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , <S2SV_StartBug> 1 , 0 , regs , 0 ) ; <S2SV_EndBug> switch ( rd ) { case 0 : regs -> regs [ rt ] = smp_processor_id ( ) ; return 0 ; case 1 : regs -> regs [ rt ] = min ( current_cpu_data . dcache . linesz , current_cpu_data . icache . linesz ) ; return 0 ; case 2 : regs -> regs [ rt ] = read_c0_count ( ) ; return 0 ; case 3 : switch ( current_cpu_data . cputype ) { case CPU_20KC : case CPU_25KF : regs -> regs [ rt ] = 1 ; break ; default : regs -> regs [ rt ] = 2 ; } return 0 ; case 29 : regs -> regs [ rt ] = ti -> tp_value ; return 0 ; default : return - 1 ; } } return - 1 ; }
int cipso_v4_req_setattr ( struct request_sock * req , const struct cipso_v4_doi * doi_def , const struct netlbl_lsm_secattr * secattr ) { int ret_val = - EPERM ; unsigned char * buf = NULL ; u32 buf_len ; u32 opt_len ; <S2SV_StartBug> struct ip_options * opt = NULL ; <S2SV_EndBug> struct inet_request_sock * req_inet ; buf_len = CIPSO_V4_OPT_LEN_MAX ; buf = kmalloc ( buf_len , GFP_ATOMIC ) ; if ( buf == NULL ) { ret_val = - ENOMEM ; goto req_setattr_failure ; } ret_val = cipso_v4_genopt ( buf , buf_len , doi_def , secattr ) ; if ( ret_val < 0 ) goto req_setattr_failure ; buf_len = ret_val ; opt_len = ( buf_len + 3 ) & ~ 3 ; opt = kzalloc ( sizeof ( * opt ) + opt_len , GFP_ATOMIC ) ; if ( opt == NULL ) { ret_val = - ENOMEM ; goto req_setattr_failure ; } <S2SV_StartBug> memcpy ( opt -> __data , buf , buf_len ) ; <S2SV_EndBug> <S2SV_StartBug> opt -> optlen = opt_len ; <S2SV_EndBug> <S2SV_StartBug> opt -> cipso = sizeof ( struct iphdr ) ; <S2SV_EndBug> kfree ( buf ) ; buf = NULL ; req_inet = inet_rsk ( req ) ; opt = xchg ( & req_inet -> opt , opt ) ; <S2SV_StartBug> kfree ( opt ) ; <S2SV_EndBug> return 0 ; req_setattr_failure : kfree ( buf ) ; kfree ( opt ) ; return ret_val ; }
R_API char * r_socket_http_get ( const char * url , int * code , int * rlen ) { <S2SV_StartBug> char * curl_env = r_sys_getenv ( "R2_CURL" ) ; <S2SV_EndBug> if ( curl_env && * curl_env ) { char * encoded_url = r_str_escape ( url ) ; char * res = r_sys_cmd_strf ( "curl<S2SV_blank>\'%s\'" , encoded_url ) ; free ( encoded_url ) ; if ( res ) { if ( code ) { * code = 200 ; } if ( rlen ) { * rlen = strlen ( res ) ; } <S2SV_StartBug> } <S2SV_EndBug> free ( curl_env ) ; return res ; } free ( curl_env ) ; RSocket * s ; int ssl = r_str_startswith ( url , "https://" ) ; char * response , * host , * path , * port = "80" ; char * uri = strdup ( url ) ; if ( ! uri ) { return NULL ; } if ( code ) { * code = 0 ; } if ( rlen ) { * rlen = 0 ; } host = strstr ( uri , "://" ) ; if ( ! host ) { free ( uri ) ; eprintf ( "r_socket_http_get:<S2SV_blank>Invalid<S2SV_blank>URI" ) ; return NULL ; } host += 3 ; port = strchr ( host , ':' ) ; if ( ! port ) { port = ssl ? "443" : "80" ; path = host ; } else { * port ++ = 0 ; path = port ; } path = strchr ( path , '/' ) ; if ( ! path ) { path = "" ; } else { * path ++ = 0 ; } s = r_socket_new ( ssl ) ; if ( ! s ) { eprintf ( "r_socket_http_get:<S2SV_blank>Cannot<S2SV_blank>create<S2SV_blank>socket\\n" ) ; free ( uri ) ; return NULL ; } if ( r_socket_connect_tcp ( s , host , port , 0 ) ) { r_socket_printf ( s , "GET<S2SV_blank>/%s<S2SV_blank>HTTP/1.1\\r\\n" "User-Agent:<S2SV_blank>radare2<S2SV_blank>" R2_VERSION "\\r\\n" "Accept:<S2SV_blank>*/*\\r\\n" "Host:<S2SV_blank>%s:%s\\r\\n" "\\r\\n" , path , host , port ) ; response = r_socket_http_answer ( s , code , rlen ) ; } else { eprintf ( "Cannot<S2SV_blank>connect<S2SV_blank>to<S2SV_blank>%s:%s\\n" , host , port ) ; response = NULL ; } free ( uri ) ; r_socket_free ( s ) ; return response ; }
int ff_mms_asf_header_parser ( MMSContext * mms ) { uint8_t * p = mms -> asf_header ; uint8_t * end ; int flags , stream_id ; mms -> stream_num = 0 ; if ( mms -> asf_header_size < sizeof ( ff_asf_guid ) * 2 + 22 || memcmp ( p , ff_asf_header , sizeof ( ff_asf_guid ) ) ) { av_log ( NULL , AV_LOG_ERROR , "Corrupt<S2SV_blank>stream<S2SV_blank>(invalid<S2SV_blank>ASF<S2SV_blank>header,<S2SV_blank>size=%d)\\n" , mms -> asf_header_size ) ; return AVERROR_INVALIDDATA ; } end = mms -> asf_header + mms -> asf_header_size ; p += sizeof ( ff_asf_guid ) + 14 ; while ( end - p >= sizeof ( ff_asf_guid ) + 8 ) { uint64_t chunksize ; if ( ! memcmp ( p , ff_asf_data_header , sizeof ( ff_asf_guid ) ) ) { chunksize = 50 ; } else { chunksize = AV_RL64 ( p + sizeof ( ff_asf_guid ) ) ; } if ( ! chunksize || chunksize > end - p ) { av_log ( NULL , AV_LOG_ERROR , "Corrupt<S2SV_blank>stream<S2SV_blank>(header<S2SV_blank>chunksize<S2SV_blank>%" PRId64 "<S2SV_blank>is<S2SV_blank>invalid)\\n" , chunksize ) ; return AVERROR_INVALIDDATA ; } if ( ! memcmp ( p , ff_asf_file_header , sizeof ( ff_asf_guid ) ) ) { if ( end - p > sizeof ( ff_asf_guid ) * 2 + 68 ) { mms -> asf_packet_len = AV_RL32 ( p + sizeof ( ff_asf_guid ) * 2 + 64 ) ; if ( mms -> asf_packet_len <= 0 || mms -> asf_packet_len > sizeof ( mms -> in_buffer ) ) { av_log ( NULL , AV_LOG_ERROR , "Corrupt<S2SV_blank>stream<S2SV_blank>(too<S2SV_blank>large<S2SV_blank>pkt_len<S2SV_blank>%d)\\n" , mms -> asf_packet_len ) ; return AVERROR_INVALIDDATA ; } } } else if ( ! memcmp ( p , ff_asf_stream_header , sizeof ( ff_asf_guid ) ) ) { <S2SV_StartBug> flags = AV_RL16 ( p + sizeof ( ff_asf_guid ) * 3 + 24 ) ; <S2SV_EndBug> stream_id = flags & 0x7F ; if ( mms -> stream_num < MMS_MAX_STREAMS && 46 + mms -> stream_num * 6 < sizeof ( mms -> out_buffer ) ) { mms -> streams = av_fast_realloc ( mms -> streams , & mms -> nb_streams_allocated , ( mms -> stream_num + 1 ) * sizeof ( MMSStream ) ) ; if ( ! mms -> streams ) return AVERROR ( ENOMEM ) ; mms -> streams [ mms -> stream_num ] . id = stream_id ; mms -> stream_num ++ ; } else { av_log ( NULL , AV_LOG_ERROR , "Corrupt<S2SV_blank>stream<S2SV_blank>(too<S2SV_blank>many<S2SV_blank>A/V<S2SV_blank>streams)\\n" ) ; return AVERROR_INVALIDDATA ; } <S2SV_StartBug> } else if ( ! memcmp ( p , ff_asf_ext_stream_header , sizeof ( ff_asf_guid ) ) ) { <S2SV_EndBug> if ( end - p >= 88 ) { int stream_count = AV_RL16 ( p + 84 ) , ext_len_count = AV_RL16 ( p + 86 ) ; uint64_t skip_bytes = 88 ; while ( stream_count -- ) { if ( end - p < skip_bytes + 4 ) { av_log ( NULL , AV_LOG_ERROR , "Corrupt<S2SV_blank>stream<S2SV_blank>(next<S2SV_blank>stream<S2SV_blank>name<S2SV_blank>length<S2SV_blank>is<S2SV_blank>not<S2SV_blank>in<S2SV_blank>the<S2SV_blank>buffer)\\n" ) ; return AVERROR_INVALIDDATA ; } skip_bytes += 4 + AV_RL16 ( p + skip_bytes + 2 ) ; } while ( ext_len_count -- ) { if ( end - p < skip_bytes + 22 ) { av_log ( NULL , AV_LOG_ERROR , "Corrupt<S2SV_blank>stream<S2SV_blank>(next<S2SV_blank>extension<S2SV_blank>system<S2SV_blank>info<S2SV_blank>length<S2SV_blank>is<S2SV_blank>not<S2SV_blank>in<S2SV_blank>the<S2SV_blank>buffer)\\n" ) ; return AVERROR_INVALIDDATA ; } skip_bytes += 22 + AV_RL32 ( p + skip_bytes + 18 ) ; } if ( end - p < skip_bytes ) { av_log ( NULL , AV_LOG_ERROR , "Corrupt<S2SV_blank>stream<S2SV_blank>(the<S2SV_blank>last<S2SV_blank>extension<S2SV_blank>system<S2SV_blank>info<S2SV_blank>length<S2SV_blank>is<S2SV_blank>invalid)\\n" ) ; return AVERROR_INVALIDDATA ; } if ( chunksize - skip_bytes > 24 ) chunksize = skip_bytes ; } } else if ( ! memcmp ( p , ff_asf_head1_guid , sizeof ( ff_asf_guid ) ) ) { chunksize = 46 ; <S2SV_StartBug> } <S2SV_EndBug> p += chunksize ; } return 0 ; }
static void hugetlb_vm_op_close ( struct vm_area_struct * vma ) { struct hstate * h = hstate_vma ( vma ) ; struct resv_map * reservations = vma_resv_map ( vma ) ; struct hugepage_subpool * spool = subpool_vma ( vma ) ; unsigned long reserve ; unsigned long start ; unsigned long end ; if ( reservations ) { start = vma_hugecache_offset ( h , vma , vma -> vm_start ) ; end = vma_hugecache_offset ( h , vma , vma -> vm_end ) ; reserve = ( end - start ) - region_count ( & reservations -> regions , start , end ) ; <S2SV_StartBug> kref_put ( & reservations -> refs , resv_map_release ) ; <S2SV_EndBug> if ( reserve ) { hugetlb_acct_memory ( h , - reserve ) ; hugepage_subpool_put_pages ( spool , reserve ) ; } } }
<S2SV_StartBug> int file_is_raw ( struct VpxInputContext * input ) { <S2SV_EndBug> uint8_t buf [ 32 ] ; int is_raw = 0 ; vpx_codec_stream_info_t si ; si . sz = sizeof ( si ) ; if ( fread ( buf , 1 , 32 , input -> file ) == 32 ) { int i ; if ( mem_get_le32 ( buf ) < 256 * 1024 * 1024 ) { for ( i = 0 ; i < get_vpx_decoder_count ( ) ; ++ i ) { const VpxInterface * const decoder = get_vpx_decoder_by_index ( i ) ; <S2SV_StartBug> if ( ! vpx_codec_peek_stream_info ( decoder -> interface ( ) , <S2SV_EndBug> buf + 4 , 32 - 4 , & si ) ) { is_raw = 1 ; input -> fourcc = decoder -> fourcc ; input -> width = si . w ; input -> height = si . h ; input -> framerate . numerator = 30 ; input -> framerate . denominator = 1 ; break ; } } } } rewind ( input -> file ) ; return is_raw ; }
void vp9_set_segment_data ( struct segmentation * seg , signed char * feature_data , unsigned char abs_delta ) { seg -> abs_delta = abs_delta ; <S2SV_StartBug> vpx_memcpy ( seg -> feature_data , feature_data , sizeof ( seg -> feature_data ) ) ; <S2SV_EndBug> }
Datum hstore_from_arrays ( PG_FUNCTION_ARGS ) { int32 buflen ; HStore * out ; Pairs * pairs ; Datum * key_datums ; bool * key_nulls ; int key_count ; Datum * value_datums ; bool * value_nulls ; int value_count ; ArrayType * key_array ; ArrayType * value_array ; int i ; if ( PG_ARGISNULL ( 0 ) ) PG_RETURN_NULL ( ) ; key_array = PG_GETARG_ARRAYTYPE_P ( 0 ) ; Assert ( ARR_ELEMTYPE ( key_array ) == TEXTOID ) ; if ( ARR_NDIM ( key_array ) > 1 ) ereport ( ERROR , ( errcode ( ERRCODE_ARRAY_SUBSCRIPT_ERROR ) , errmsg ( "wrong<S2SV_blank>number<S2SV_blank>of<S2SV_blank>array<S2SV_blank>subscripts" ) ) ) ; deconstruct_array ( key_array , TEXTOID , - 1 , false , 'i' , <S2SV_StartBug> & key_datums , & key_nulls , & key_count ) ; <S2SV_EndBug> if ( PG_ARGISNULL ( 1 ) ) { value_array = NULL ; value_count = key_count ; value_datums = NULL ; value_nulls = NULL ; } else { value_array = PG_GETARG_ARRAYTYPE_P ( 1 ) ; Assert ( ARR_ELEMTYPE ( value_array ) == TEXTOID ) ; if ( ARR_NDIM ( value_array ) > 1 ) ereport ( ERROR , ( errcode ( ERRCODE_ARRAY_SUBSCRIPT_ERROR ) , errmsg ( "wrong<S2SV_blank>number<S2SV_blank>of<S2SV_blank>array<S2SV_blank>subscripts" ) ) ) ; if ( ( ARR_NDIM ( key_array ) > 0 || ARR_NDIM ( value_array ) > 0 ) && ( ARR_NDIM ( key_array ) != ARR_NDIM ( value_array ) || ARR_DIMS ( key_array ) [ 0 ] != ARR_DIMS ( value_array ) [ 0 ] || ARR_LBOUND ( key_array ) [ 0 ] != ARR_LBOUND ( value_array ) [ 0 ] ) ) ereport ( ERROR , ( errcode ( ERRCODE_ARRAY_SUBSCRIPT_ERROR ) , errmsg ( "arrays<S2SV_blank>must<S2SV_blank>have<S2SV_blank>same<S2SV_blank>bounds" ) ) ) ; deconstruct_array ( value_array , TEXTOID , - 1 , false , 'i' , & value_datums , & value_nulls , & value_count ) ; Assert ( key_count == value_count ) ; } pairs = palloc ( key_count * sizeof ( Pairs ) ) ; for ( i = 0 ; i < key_count ; ++ i ) { if ( key_nulls [ i ] ) ereport ( ERROR , ( errcode ( ERRCODE_NULL_VALUE_NOT_ALLOWED ) , errmsg ( "null<S2SV_blank>value<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>for<S2SV_blank>hstore<S2SV_blank>key" ) ) ) ; if ( ! value_nulls || value_nulls [ i ] ) { pairs [ i ] . key = VARDATA_ANY ( key_datums [ i ] ) ; pairs [ i ] . val = NULL ; pairs [ i ] . keylen = hstoreCheckKeyLen ( VARSIZE_ANY_EXHDR ( key_datums [ i ] ) ) ; pairs [ i ] . vallen = 4 ; pairs [ i ] . isnull = true ; pairs [ i ] . needfree = false ; } else { pairs [ i ] . key = VARDATA_ANY ( key_datums [ i ] ) ; pairs [ i ] . val = VARDATA_ANY ( value_datums [ i ] ) ; pairs [ i ] . keylen = hstoreCheckKeyLen ( VARSIZE_ANY_EXHDR ( key_datums [ i ] ) ) ; pairs [ i ] . vallen = hstoreCheckValLen ( VARSIZE_ANY_EXHDR ( value_datums [ i ] ) ) ; pairs [ i ] . isnull = false ; pairs [ i ] . needfree = false ; } } key_count = hstoreUniquePairs ( pairs , key_count , & buflen ) ; out = hstorePairs ( pairs , key_count , buflen ) ; PG_RETURN_POINTER ( out ) ; }
int mem_check_range ( struct rxe_mem * mem , u64 iova , size_t length ) { switch ( mem -> type ) { case RXE_MEM_TYPE_DMA : return 0 ; case RXE_MEM_TYPE_MR : case RXE_MEM_TYPE_FMR : <S2SV_StartBug> return ( ( iova < mem -> iova ) || <S2SV_EndBug> <S2SV_StartBug> ( ( iova + length ) > ( mem -> iova + mem -> length ) ) ) ? <S2SV_EndBug> - EFAULT : 0 ; default : return - EFAULT ; } }
static int http_open ( URLContext * h , const char * uri , int flags , AVDictionary * * options ) { HTTPContext * s = h -> priv_data ; int ret ; if ( s -> seekable == 1 ) h -> is_streamed = 0 ; else h -> is_streamed = 1 ; <S2SV_StartBug> s -> filesize = - 1 ; <S2SV_EndBug> s -> location = av_strdup ( uri ) ; if ( ! s -> location ) return AVERROR ( ENOMEM ) ; if ( options ) av_dict_copy ( & s -> chained_options , * options , 0 ) ; if ( s -> headers ) { int len = strlen ( s -> headers ) ; if ( len < 2 || strcmp ( "\\r\\n" , s -> headers + len - 2 ) ) { av_log ( h , AV_LOG_WARNING , "No<S2SV_blank>trailing<S2SV_blank>CRLF<S2SV_blank>found<S2SV_blank>in<S2SV_blank>HTTP<S2SV_blank>header.\\n" ) ; ret = av_reallocp ( & s -> headers , len + 3 ) ; if ( ret < 0 ) return ret ; s -> headers [ len ] = '\\r' ; s -> headers [ len + 1 ] = '\\n' ; s -> headers [ len + 2 ] = '\\0' ; } } if ( s -> listen ) { return http_listen ( h , uri , flags , options ) ; } ret = http_open_cnx ( h , options ) ; if ( ret < 0 ) av_dict_free ( & s -> chained_options ) ; return ret ; }
<S2SV_StartBug> static void write_tile_info ( VP9_COMMON * cm , struct vp9_write_bit_buffer * wb ) { <S2SV_EndBug> int min_log2_tile_cols , max_log2_tile_cols , ones ; vp9_get_tile_n_bits ( cm -> mi_cols , & min_log2_tile_cols , & max_log2_tile_cols ) ; ones = cm -> log2_tile_cols - min_log2_tile_cols ; while ( ones -- ) <S2SV_StartBug> vp9_wb_write_bit ( wb , 1 ) ; <S2SV_EndBug> if ( cm -> log2_tile_cols < max_log2_tile_cols ) <S2SV_StartBug> vp9_wb_write_bit ( wb , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> vp9_wb_write_bit ( wb , cm -> log2_tile_rows != 0 ) ; <S2SV_EndBug> if ( cm -> log2_tile_rows != 0 ) <S2SV_StartBug> vp9_wb_write_bit ( wb , cm -> log2_tile_rows != 1 ) ; <S2SV_EndBug> }
void options_apply ( ) { unsigned num = 0 ; SERVICE_OPTIONS * section ; CRYPTO_THREAD_write_lock ( stunnel_locks [ LOCK_SECTIONS ] ) ; <S2SV_StartBug> memcpy ( & global_options , & new_global_options , sizeof ( GLOBAL_OPTIONS ) ) ; <S2SV_EndBug> for ( section = new_service_options . next ; section ; section = section -> next ) section -> section_number = num ++ ; memcpy ( & service_options , & new_service_options , sizeof ( SERVICE_OPTIONS ) ) ; <S2SV_StartBug> number_of_sections = num ; <S2SV_EndBug> CRYPTO_THREAD_unlock ( stunnel_locks [ LOCK_SECTIONS ] ) ; }
static int tcos_select_file ( sc_card_t * card , const sc_path_t * in_path , sc_file_t * * file_out ) { sc_context_t * ctx ; sc_apdu_t apdu ; sc_file_t * file = NULL ; u8 buf [ SC_MAX_APDU_BUFFER_SIZE ] , pathbuf [ SC_MAX_PATH_SIZE ] , * path = pathbuf ; unsigned int i ; int r , pathlen ; assert ( card != NULL && in_path != NULL ) ; ctx = card -> ctx ; memcpy ( path , in_path -> value , in_path -> len ) ; pathlen = in_path -> len ; sc_format_apdu ( card , & apdu , SC_APDU_CASE_4_SHORT , 0xA4 , 0 , 0x04 ) ; switch ( in_path -> type ) { case SC_PATH_TYPE_FILE_ID : if ( pathlen != 2 ) return SC_ERROR_INVALID_ARGUMENTS ; case SC_PATH_TYPE_FROM_CURRENT : apdu . p1 = 9 ; break ; case SC_PATH_TYPE_DF_NAME : apdu . p1 = 4 ; break ; case SC_PATH_TYPE_PATH : apdu . p1 = 8 ; if ( pathlen >= 2 && memcmp ( path , "\\x3F\\x00" , 2 ) == 0 ) path += 2 , pathlen -= 2 ; if ( pathlen == 0 ) apdu . p1 = 0 ; break ; case SC_PATH_TYPE_PARENT : apdu . p1 = 3 ; pathlen = 0 ; break ; default : SC_FUNC_RETURN ( ctx , SC_LOG_DEBUG_VERBOSE , SC_ERROR_INVALID_ARGUMENTS ) ; } if ( pathlen == 0 ) apdu . cse = SC_APDU_CASE_2_SHORT ; apdu . lc = pathlen ; apdu . data = path ; apdu . datalen = pathlen ; if ( file_out != NULL ) { apdu . resp = buf ; apdu . resplen = sizeof ( buf ) ; apdu . le = 256 ; } else { apdu . resplen = 0 ; apdu . le = 0 ; apdu . p2 = 0x0C ; apdu . cse = ( pathlen == 0 ) ? SC_APDU_CASE_1 : SC_APDU_CASE_3_SHORT ; } r = sc_transmit_apdu ( card , & apdu ) ; SC_TEST_RET ( ctx , SC_LOG_DEBUG_NORMAL , r , "APDU<S2SV_blank>transmit<S2SV_blank>failed" ) ; r = sc_check_sw ( card , apdu . sw1 , apdu . sw2 ) ; if ( r || file_out == NULL ) SC_FUNC_RETURN ( ctx , SC_LOG_DEBUG_VERBOSE , r ) ; if ( apdu . resplen < 1 || apdu . resp [ 0 ] != 0x62 ) { sc_debug ( ctx , SC_LOG_DEBUG_NORMAL , "received<S2SV_blank>invalid<S2SV_blank>template<S2SV_blank>%02X\\n" , apdu . resp [ 0 ] ) ; SC_FUNC_RETURN ( ctx , SC_LOG_DEBUG_VERBOSE , SC_ERROR_UNKNOWN_DATA_RECEIVED ) ; } file = sc_file_new ( ) ; if ( file == NULL ) SC_FUNC_RETURN ( ctx , SC_LOG_DEBUG_NORMAL , SC_ERROR_OUT_OF_MEMORY ) ; * file_out = file ; file -> path = * in_path ; for ( i = 2 ; i + 1 < apdu . resplen && i + 1 + apdu . resp [ i + 1 ] < apdu . resplen ; i += 2 + apdu . resp [ i + 1 ] ) { <S2SV_StartBug> int j , len = apdu . resp [ i + 1 ] ; <S2SV_EndBug> unsigned char type = apdu . resp [ i ] , * d = apdu . resp + i + 2 ; switch ( type ) { case 0x80 : case 0x81 : file -> size = 0 ; for ( j = 0 ; j < len ; ++ j ) file -> size = ( file -> size << 8 ) | d [ j ] ; break ; case 0x82 : file -> shareable = ( d [ 0 ] & 0x40 ) ? 1 : 0 ; file -> ef_structure = d [ 0 ] & 7 ; switch ( ( d [ 0 ] >> 3 ) & 7 ) { case 0 : file -> type = SC_FILE_TYPE_WORKING_EF ; break ; case 7 : file -> type = SC_FILE_TYPE_DF ; break ; default : sc_debug ( ctx , SC_LOG_DEBUG_NORMAL , "invalid<S2SV_blank>file<S2SV_blank>type<S2SV_blank>%02X<S2SV_blank>in<S2SV_blank>file<S2SV_blank>descriptor\\n" , d [ 0 ] ) ; SC_FUNC_RETURN ( ctx , SC_LOG_DEBUG_VERBOSE , SC_ERROR_UNKNOWN_DATA_RECEIVED ) ; } break ; case 0x83 : file -> id = ( d [ 0 ] << 8 ) | d [ 1 ] ; break ; case 0x84 : <S2SV_StartBug> memcpy ( file -> name , d , len ) ; <S2SV_EndBug> <S2SV_StartBug> file -> namelen = len ; <S2SV_EndBug> break ; case 0x86 : sc_file_set_sec_attr ( file , d , len ) ; break ; default : if ( len > 0 ) sc_file_set_prop_attr ( file , d , len ) ; } } file -> magic = SC_FILE_MAGIC ; parse_sec_attr ( card , file , file -> sec_attr , file -> sec_attr_len ) ; return 0 ; }
static void * __ns_get_path ( struct path * path , struct ns_common * ns ) { struct vfsmount * mnt = nsfs_mnt ; struct qstr qname = { . name = "" , } ; struct dentry * dentry ; struct inode * inode ; unsigned long d ; rcu_read_lock ( ) ; d = atomic_long_read ( & ns -> stashed ) ; if ( ! d ) goto slow ; dentry = ( struct dentry * ) d ; if ( ! lockref_get_not_dead ( & dentry -> d_lockref ) ) goto slow ; rcu_read_unlock ( ) ; ns -> ops -> put ( ns ) ; got_it : path -> mnt = mntget ( mnt ) ; path -> dentry = dentry ; return NULL ; slow : rcu_read_unlock ( ) ; inode = new_inode_pseudo ( mnt -> mnt_sb ) ; if ( ! inode ) { ns -> ops -> put ( ns ) ; return ERR_PTR ( - ENOMEM ) ; } inode -> i_ino = ns -> inum ; inode -> i_mtime = inode -> i_atime = inode -> i_ctime = current_time ( inode ) ; inode -> i_flags |= S_IMMUTABLE ; inode -> i_mode = S_IFREG | S_IRUGO ; inode -> i_fop = & ns_file_operations ; inode -> i_private = ns ; dentry = d_alloc_pseudo ( mnt -> mnt_sb , & qname ) ; if ( ! dentry ) { iput ( inode ) ; return ERR_PTR ( - ENOMEM ) ; } d_instantiate ( dentry , inode ) ; <S2SV_StartBug> dentry -> d_fsdata = ( void * ) ns -> ops ; <S2SV_EndBug> d = atomic_long_cmpxchg ( & ns -> stashed , 0 , ( unsigned long ) dentry ) ; if ( d ) { d_delete ( dentry ) ; dput ( dentry ) ; cpu_relax ( ) ; return ERR_PTR ( - EAGAIN ) ; } goto got_it ; }
LPSTR tr_esc_str ( LPCSTR arg , bool format ) { <S2SV_StartBug> LPSTR tmp = NULL ; <S2SV_EndBug> size_t cs = 0 , x , ds , len ; size_t s ; if ( NULL == arg ) return NULL ; s = strlen ( arg ) ; while ( ( s > 0 ) && isspace ( arg [ s - 1 ] ) ) s -- ; ds = s + 1 ; if ( s ) <S2SV_StartBug> tmp = ( LPSTR ) realloc ( tmp , ds * sizeof ( CHAR ) ) ; <S2SV_EndBug> if ( NULL == tmp ) { fprintf ( stderr , "Could<S2SV_blank>not<S2SV_blank>allocate<S2SV_blank>string<S2SV_blank>buffer.\\n" ) ; exit ( - 2 ) ; } memset ( tmp , 0 , ds * sizeof ( CHAR ) ) ; for ( x = 0 ; x < s ; x ++ ) { switch ( arg [ x ] ) { case '<' : len = format ? 13 : 4 ; ds += len - 1 ; <S2SV_StartBug> tmp = ( LPSTR ) realloc ( tmp , ds * sizeof ( CHAR ) ) ; <S2SV_EndBug> if ( NULL == tmp ) { fprintf ( stderr , "Could<S2SV_blank>not<S2SV_blank>reallocate<S2SV_blank>string<S2SV_blank>buffer.\\n" ) ; exit ( - 3 ) ; } if ( format ) strncpy ( & tmp [ cs ] , "<replaceable>" , len ) ; else strncpy ( & tmp [ cs ] , "&lt;" , len ) ; cs += len ; break ; case '>' : len = format ? 14 : 4 ; ds += len - 1 ; <S2SV_StartBug> tmp = ( LPSTR ) realloc ( tmp , ds * sizeof ( CHAR ) ) ; <S2SV_EndBug> if ( NULL == tmp ) { fprintf ( stderr , "Could<S2SV_blank>not<S2SV_blank>reallocate<S2SV_blank>string<S2SV_blank>buffer.\\n" ) ; exit ( - 4 ) ; } if ( format ) strncpy ( & tmp [ cs ] , "</replaceable>" , len ) ; else strncpy ( & tmp [ cs ] , "&lt;" , len ) ; cs += len ; break ; case '\\'' : ds += 5 ; <S2SV_StartBug> tmp = ( LPSTR ) realloc ( tmp , ds * sizeof ( CHAR ) ) ; <S2SV_EndBug> if ( NULL == tmp ) { fprintf ( stderr , "Could<S2SV_blank>not<S2SV_blank>reallocate<S2SV_blank>string<S2SV_blank>buffer.\\n" ) ; exit ( - 5 ) ; } tmp [ cs ++ ] = '&' ; tmp [ cs ++ ] = 'a' ; tmp [ cs ++ ] = 'p' ; tmp [ cs ++ ] = 'o' ; tmp [ cs ++ ] = 's' ; tmp [ cs ++ ] = ';' ; break ; case \'"\' : ds += 5 ; <S2SV_StartBug> tmp = ( LPSTR ) realloc ( tmp , ds * sizeof ( CHAR ) ) ; <S2SV_EndBug> if ( NULL == tmp ) { fprintf ( stderr , "Could<S2SV_blank>not<S2SV_blank>reallocate<S2SV_blank>string<S2SV_blank>buffer.\\n" ) ; exit ( - 6 ) ; } tmp [ cs ++ ] = '&' ; tmp [ cs ++ ] = 'q' ; tmp [ cs ++ ] = 'u' ; tmp [ cs ++ ] = 'o' ; tmp [ cs ++ ] = 't' ; tmp [ cs ++ ] = ';' ; break ; case '&' : ds += 4 ; <S2SV_StartBug> tmp = ( LPSTR ) realloc ( tmp , ds * sizeof ( CHAR ) ) ; <S2SV_EndBug> <S2SV_StartBug> if ( NULL == tmp ) <S2SV_EndBug> { fprintf ( stderr , "Could<S2SV_blank>not<S2SV_blank>reallocate<S2SV_blank>string<S2SV_blank>buffer.\\n" ) ; exit ( - 7 ) ; } tmp [ cs ++ ] = '&' ; tmp [ cs ++ ] = 'a' ; tmp [ cs ++ ] = 'm' ; tmp [ cs ++ ] = 'p' ; tmp [ cs ++ ] = ';' ; break ; default : tmp [ cs ++ ] = arg [ x ] ; break ; } tmp [ ds - 1 ] = '\\0' ; } return tmp ; }
static SSL * open_ssl_connection ( rfbClient * client , int sockfd , rfbBool anonTLS , rfbCredential * cred ) { SSL_CTX * ssl_ctx = NULL ; SSL * ssl = NULL ; int n , finished = 0 ; X509_VERIFY_PARAM * param ; <S2SV_StartBug> uint8_t verify_crls = cred -> x509Credential . x509CrlVerifyMode ; <S2SV_EndBug> if ( ! ( ssl_ctx = SSL_CTX_new ( SSLv23_client_method ( ) ) ) ) { rfbClientLog ( "Could<S2SV_blank>not<S2SV_blank>create<S2SV_blank>new<S2SV_blank>SSL<S2SV_blank>context.\\n" ) ; return NULL ; } param = X509_VERIFY_PARAM_new ( ) ; if ( ! anonTLS ) <S2SV_StartBug> { <S2SV_EndBug> if ( cred -> x509Credential . x509CACertFile ) { if ( ! SSL_CTX_load_verify_locations ( ssl_ctx , cred -> x509Credential . x509CACertFile , NULL ) ) { rfbClientLog ( "Failed<S2SV_blank>to<S2SV_blank>load<S2SV_blank>CA<S2SV_blank>certificate<S2SV_blank>from<S2SV_blank>%s.\\n" , cred -> x509Credential . x509CACertFile ) ; goto error_free_ctx ; } } else { rfbClientLog ( "Using<S2SV_blank>default<S2SV_blank>paths<S2SV_blank>for<S2SV_blank>certificate<S2SV_blank>verification.\\n" ) ; SSL_CTX_set_default_verify_paths ( ssl_ctx ) ; } if ( cred -> x509Credential . x509CACrlFile ) { if ( ! load_crls_from_file ( cred -> x509Credential . x509CACrlFile , ssl_ctx ) ) { rfbClientLog ( "CRLs<S2SV_blank>could<S2SV_blank>not<S2SV_blank>be<S2SV_blank>loaded.\\n" ) ; goto error_free_ctx ; } if ( verify_crls == rfbX509CrlVerifyNone ) verify_crls = rfbX509CrlVerifyAll ; } if ( cred -> x509Credential . x509ClientCertFile && cred -> x509Credential . x509ClientKeyFile ) { if ( SSL_CTX_use_certificate_chain_file ( ssl_ctx , cred -> x509Credential . x509ClientCertFile ) != 1 ) { rfbClientLog ( "Client<S2SV_blank>certificate<S2SV_blank>could<S2SV_blank>not<S2SV_blank>be<S2SV_blank>loaded.\\n" ) ; goto error_free_ctx ; } if ( SSL_CTX_use_PrivateKey_file ( ssl_ctx , cred -> x509Credential . x509ClientKeyFile , SSL_FILETYPE_PEM ) != 1 ) { rfbClientLog ( "Client<S2SV_blank>private<S2SV_blank>key<S2SV_blank>could<S2SV_blank>not<S2SV_blank>be<S2SV_blank>loaded.\\n" ) ; goto error_free_ctx ; } if ( SSL_CTX_check_private_key ( ssl_ctx ) == 0 ) { rfbClientLog ( "Client<S2SV_blank>certificate<S2SV_blank>and<S2SV_blank>private<S2SV_blank>key<S2SV_blank>do<S2SV_blank>not<S2SV_blank>match.\\n" ) ; goto error_free_ctx ; } } SSL_CTX_set_verify ( ssl_ctx , SSL_VERIFY_PEER , NULL ) ; if ( verify_crls == rfbX509CrlVerifyClient ) X509_VERIFY_PARAM_set_flags ( param , X509_V_FLAG_CRL_CHECK ) ; else if ( verify_crls == rfbX509CrlVerifyAll ) X509_VERIFY_PARAM_set_flags ( param , X509_V_FLAG_CRL_CHECK | X509_V_FLAG_CRL_CHECK_ALL ) ; if ( ! X509_VERIFY_PARAM_set1_host ( param , client -> serverHost , strlen ( client -> serverHost ) ) ) { rfbClientLog ( "Could<S2SV_blank>not<S2SV_blank>set<S2SV_blank>server<S2SV_blank>name<S2SV_blank>for<S2SV_blank>verification.\\n" ) ; goto error_free_ctx ; } SSL_CTX_set1_param ( ssl_ctx , param ) ; } if ( ! ( ssl = SSL_new ( ssl_ctx ) ) ) { rfbClientLog ( "Could<S2SV_blank>not<S2SV_blank>create<S2SV_blank>a<S2SV_blank>new<S2SV_blank>SSL<S2SV_blank>session.\\n" ) ; goto error_free_ctx ; } SSL_set_cipher_list ( ssl , "ALL" ) ; SSL_set_fd ( ssl , sockfd ) ; SSL_CTX_set_app_data ( ssl_ctx , client ) ; do { n = SSL_connect ( ssl ) ; if ( n != 1 ) { if ( wait_for_data ( ssl , n , 1 ) != 1 ) { finished = 1 ; SSL_shutdown ( ssl ) ; goto error_free_ssl ; } } } while ( n != 1 && finished != 1 ) ; X509_VERIFY_PARAM_free ( param ) ; return ssl ; error_free_ssl : SSL_free ( ssl ) ; error_free_ctx : X509_VERIFY_PARAM_free ( param ) ; SSL_CTX_free ( ssl_ctx ) ; return NULL ; }
int main ( int argc , char * argv [ ] ) { int ret ; struct lxc_lock * lock ; lock = lxc_newlock ( NULL , NULL ) ; if ( ! lock ) { fprintf ( stderr , "%d:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>unnamed<S2SV_blank>lock\\n" , __LINE__ ) ; exit ( 1 ) ; } ret = lxclock ( lock , 0 ) ; if ( ret ) { fprintf ( stderr , "%d:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>take<S2SV_blank>unnamed<S2SV_blank>lock<S2SV_blank>(%d)\\n" , __LINE__ , ret ) ; exit ( 1 ) ; } ret = lxcunlock ( lock ) ; if ( ret ) { fprintf ( stderr , "%d:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>put<S2SV_blank>unnamed<S2SV_blank>lock<S2SV_blank>(%d)\\n" , __LINE__ , ret ) ; exit ( 1 ) ; } lxc_putlock ( lock ) ; lock = lxc_newlock ( "/var/lib/lxc" , mycontainername ) ; if ( ! lock ) { fprintf ( stderr , "%d:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>lock\\n" , __LINE__ ) ; exit ( 1 ) ; } struct stat sb ; <S2SV_StartBug> char * pathname = RUNTIME_PATH "/lock/lxc/var/lib/lxc/" ; <S2SV_EndBug> ret = stat ( pathname , & sb ) ; if ( ret != 0 ) { fprintf ( stderr , "%d:<S2SV_blank>filename<S2SV_blank>%s<S2SV_blank>not<S2SV_blank>created\\n" , __LINE__ , pathname ) ; exit ( 1 ) ; } lxc_putlock ( lock ) ; test_two_locks ( ) ; fprintf ( stderr , "all<S2SV_blank>tests<S2SV_blank>passed\\n" ) ; exit ( ret ) ; }
static int translate_desc ( struct vhost_dev * dev , u64 addr , u32 len , struct iovec iov [ ] , int iov_size ) { const struct vhost_memory_region * reg ; struct vhost_memory * mem ; struct iovec * _iov ; u64 s = 0 ; int ret = 0 ; rcu_read_lock ( ) ; mem = rcu_dereference ( dev -> memory ) ; while ( ( u64 ) len > s ) { u64 size ; if ( unlikely ( ret >= iov_size ) ) { ret = - ENOBUFS ; break ; } reg = find_region ( mem , addr , len ) ; if ( unlikely ( ! reg ) ) { ret = - EFAULT ; break ; } _iov = iov + ret ; size = reg -> memory_size - addr + reg -> guest_phys_addr ; <S2SV_StartBug> _iov -> iov_len = min ( ( u64 ) len , size ) ; <S2SV_EndBug> _iov -> iov_base = ( void __user * ) ( unsigned long ) ( reg -> userspace_addr + addr - reg -> guest_phys_addr ) ; s += size ; addr += size ; ++ ret ; } rcu_read_unlock ( ) ; return ret ; }
static int sof_set_get_large_ctrl_data ( struct snd_sof_dev * sdev , struct sof_ipc_ctrl_data * cdata , struct sof_ipc_ctrl_data_params * sparams , bool send ) { struct sof_ipc_ctrl_data * partdata ; size_t send_bytes ; size_t offset = 0 ; size_t msg_bytes ; size_t pl_size ; int err ; int i ; partdata = kzalloc ( SOF_IPC_MSG_MAX_SIZE , GFP_KERNEL ) ; if ( ! partdata ) return - ENOMEM ; if ( send ) err = sof_get_ctrl_copy_params ( cdata -> type , cdata , partdata , sparams ) ; else err = sof_get_ctrl_copy_params ( cdata -> type , partdata , cdata , sparams ) ; <S2SV_StartBug> if ( err < 0 ) <S2SV_EndBug> <S2SV_StartBug> return err ; <S2SV_EndBug> msg_bytes = sparams -> msg_bytes ; pl_size = sparams -> pl_size ; memcpy ( partdata , cdata , sparams -> hdr_bytes ) ; mutex_lock ( & sdev -> ipc -> tx_mutex ) ; for ( i = 0 ; i < sparams -> num_msg ; i ++ ) { send_bytes = min ( msg_bytes , pl_size ) ; partdata -> num_elems = send_bytes ; partdata -> rhdr . hdr . size = sparams -> hdr_bytes + send_bytes ; partdata -> msg_index = i ; msg_bytes -= send_bytes ; partdata -> elems_remaining = msg_bytes ; if ( send ) memcpy ( sparams -> dst , sparams -> src + offset , send_bytes ) ; err = sof_ipc_tx_message_unlocked ( sdev -> ipc , partdata -> rhdr . hdr . cmd , partdata , partdata -> rhdr . hdr . size , partdata , partdata -> rhdr . hdr . size ) ; if ( err < 0 ) break ; if ( ! send ) memcpy ( sparams -> dst + offset , sparams -> src , send_bytes ) ; offset += pl_size ; } mutex_unlock ( & sdev -> ipc -> tx_mutex ) ; kfree ( partdata ) ; return err ; }
static inline int sctp_chunk_length_valid ( struct sctp_chunk * chunk , __u16 required_length ) { __u16 chunk_length = ntohs ( chunk -> chunk_hdr -> length ) ; <S2SV_StartBug> if ( unlikely ( chunk_length < required_length ) ) <S2SV_EndBug> return 0 ; return 1 ; }
static void process_tree ( struct rev_info * revs , struct tree * tree , show_object_fn show , struct strbuf * base , const char * name , void * cb_data ) { struct object * obj = & tree -> object ; struct tree_desc desc ; struct name_entry entry ; enum interesting match = revs -> diffopt . pathspec . nr == 0 ? all_entries_interesting : entry_not_interesting ; int baselen = base -> len ; if ( ! revs -> tree_objects ) return ; if ( ! obj ) die ( "bad<S2SV_blank>tree<S2SV_blank>object" ) ; if ( obj -> flags & ( UNINTERESTING | SEEN ) ) return ; if ( parse_tree_gently ( tree , revs -> ignore_missing_links ) < 0 ) { if ( revs -> ignore_missing_links ) return ; die ( "bad<S2SV_blank>tree<S2SV_blank>object<S2SV_blank>%s" , oid_to_hex ( & obj -> oid ) ) ; } obj -> flags |= SEEN ; <S2SV_StartBug> show ( obj , base , name , cb_data ) ; <S2SV_EndBug> strbuf_addstr ( base , name ) ; if ( base -> len ) strbuf_addch ( base , '/' ) ; init_tree_desc ( & desc , tree -> buffer , tree -> size ) ; while ( tree_entry ( & desc , & entry ) ) { if ( match != all_entries_interesting ) { match = tree_entry_interesting ( & entry , base , 0 , & revs -> diffopt . pathspec ) ; if ( match == all_entries_not_interesting ) break ; if ( match == entry_not_interesting ) continue ; } if ( S_ISDIR ( entry . mode ) ) process_tree ( revs , lookup_tree ( entry . sha1 ) , show , base , entry . path , cb_data ) ; else if ( S_ISGITLINK ( entry . mode ) ) process_gitlink ( revs , entry . sha1 , show , base , entry . path , cb_data ) ; else process_blob ( revs , lookup_blob ( entry . sha1 ) , show , base , entry . path , cb_data ) ; } strbuf_setlen ( base , baselen ) ; free_tree_buffer ( tree ) ; }
static noinline int hiddev_ioctl_usage ( struct hiddev * hiddev , unsigned int cmd , void __user * user_arg ) { struct hid_device * hid = hiddev -> hid ; struct hiddev_report_info rinfo ; struct hiddev_usage_ref_multi * uref_multi = NULL ; struct hiddev_usage_ref * uref ; struct hid_report * report ; struct hid_field * field ; int i ; uref_multi = kmalloc ( sizeof ( struct hiddev_usage_ref_multi ) , GFP_KERNEL ) ; if ( ! uref_multi ) return - ENOMEM ; uref = & uref_multi -> uref ; if ( cmd == HIDIOCGUSAGES || cmd == HIDIOCSUSAGES ) { if ( copy_from_user ( uref_multi , user_arg , sizeof ( * uref_multi ) ) ) goto fault ; } else { if ( copy_from_user ( uref , user_arg , sizeof ( * uref ) ) ) goto fault ; } switch ( cmd ) { case HIDIOCGUCODE : rinfo . report_type = uref -> report_type ; rinfo . report_id = uref -> report_id ; if ( ( report = hiddev_lookup_report ( hid , & rinfo ) ) == NULL ) goto inval ; if ( uref -> field_index >= report -> maxfield ) goto inval ; field = report -> field [ uref -> field_index ] ; if ( uref -> usage_index >= field -> maxusage ) goto inval ; uref -> usage_code = field -> usage [ uref -> usage_index ] . hid ; if ( copy_to_user ( user_arg , uref , sizeof ( * uref ) ) ) goto fault ; goto goodreturn ; default : if ( cmd != HIDIOCGUSAGE && cmd != HIDIOCGUSAGES && uref -> report_type == HID_REPORT_TYPE_INPUT ) goto inval ; if ( uref -> report_id == HID_REPORT_ID_UNKNOWN ) { field = hiddev_lookup_usage ( hid , uref ) ; if ( field == NULL ) goto inval ; } else { rinfo . report_type = uref -> report_type ; rinfo . report_id = uref -> report_id ; if ( ( report = hiddev_lookup_report ( hid , & rinfo ) ) == NULL ) goto inval ; if ( uref -> field_index >= report -> maxfield ) goto inval ; field = report -> field [ uref -> field_index ] ; if ( cmd == HIDIOCGCOLLECTIONINDEX ) { if ( uref -> usage_index >= field -> maxusage ) goto inval ; } else if ( uref -> usage_index >= field -> report_count ) goto inval ; <S2SV_StartBug> else if ( ( cmd == HIDIOCGUSAGES || cmd == HIDIOCSUSAGES ) && <S2SV_EndBug> ( uref_multi -> num_values > HID_MAX_MULTI_USAGES || uref -> usage_index + uref_multi -> num_values > field -> report_count ) ) goto inval ; <S2SV_StartBug> } <S2SV_EndBug> switch ( cmd ) { case HIDIOCGUSAGE : uref -> value = field -> value [ uref -> usage_index ] ; if ( copy_to_user ( user_arg , uref , sizeof ( * uref ) ) ) goto fault ; goto goodreturn ; case HIDIOCSUSAGE : field -> value [ uref -> usage_index ] = uref -> value ; goto goodreturn ; case HIDIOCGCOLLECTIONINDEX : i = field -> usage [ uref -> usage_index ] . collection_index ; kfree ( uref_multi ) ; return i ; case HIDIOCGUSAGES : for ( i = 0 ; i < uref_multi -> num_values ; i ++ ) uref_multi -> values [ i ] = field -> value [ uref -> usage_index + i ] ; if ( copy_to_user ( user_arg , uref_multi , sizeof ( * uref_multi ) ) ) goto fault ; goto goodreturn ; case HIDIOCSUSAGES : for ( i = 0 ; i < uref_multi -> num_values ; i ++ ) field -> value [ uref -> usage_index + i ] = uref_multi -> values [ i ] ; goto goodreturn ; } goodreturn : kfree ( uref_multi ) ; return 0 ; fault : kfree ( uref_multi ) ; return - EFAULT ; inval : kfree ( uref_multi ) ; return - EINVAL ; } }
static int reverseSamplesBytes ( uint16 spp , uint16 bps , uint32 width , uint8 * src , uint8 * dst ) { int i ; uint32 col , bytes_per_pixel , col_offset ; uint8 bytebuff1 ; unsigned char swapbuff [ 32 ] ; if ( ( src == NULL ) || ( dst == NULL ) ) { TIFFError ( "reverseSamplesBytes" , "Invalid<S2SV_blank>input<S2SV_blank>or<S2SV_blank>output<S2SV_blank>buffer" ) ; return ( 1 ) ; } bytes_per_pixel = ( ( bps * spp ) + 7 ) / 8 ; <S2SV_StartBug> switch ( bps / 8 ) <S2SV_EndBug> { case 8 : case 4 : case 3 : case 2 : for ( col = 0 ; col < ( width / 2 ) ; col ++ ) { col_offset = col * bytes_per_pixel ; _TIFFmemcpy ( swapbuff , src + col_offset , bytes_per_pixel ) ; _TIFFmemcpy ( src + col_offset , dst - col_offset - bytes_per_pixel , bytes_per_pixel ) ; _TIFFmemcpy ( dst - col_offset - bytes_per_pixel , swapbuff , bytes_per_pixel ) ; } break ; case 1 : for ( col = 0 ; col < ( width / 2 ) ; col ++ ) { for ( i = 0 ; i < spp ; i ++ ) { bytebuff1 = * src ; * src ++ = * ( dst - spp + i ) ; * ( dst - spp + i ) = bytebuff1 ; } dst -= spp ; } break ; default : TIFFError ( "reverseSamplesBytes" , "Unsupported<S2SV_blank>bit<S2SV_blank>depth<S2SV_blank>%d" , bps ) ; return ( 1 ) ; } return ( 0 ) ; }
static void rpl_dio_printopt ( netdissect_options * ndo , const struct rpl_dio_genoption * opt , u_int length ) { if ( length < RPL_DIO_GENOPTION_LEN ) return ; length -= RPL_DIO_GENOPTION_LEN ; ND_TCHECK ( opt -> rpl_dio_len ) ; while ( ( opt -> rpl_dio_type == RPL_OPT_PAD0 && ( const u_char * ) opt < ndo -> ndo_snapend ) || ND_TTEST2 ( * opt , ( opt -> rpl_dio_len + 2 ) ) ) { unsigned int optlen = opt -> rpl_dio_len + 2 ; if ( opt -> rpl_dio_type == RPL_OPT_PAD0 ) { optlen = 1 ; ND_PRINT ( ( ndo , "<S2SV_blank>opt:pad0" ) ) ; } else { ND_PRINT ( ( ndo , "<S2SV_blank>opt:%s<S2SV_blank>len:%u<S2SV_blank>" , tok2str ( rpl_subopt_values , "subopt:%u" , opt -> rpl_dio_type ) , optlen ) ) ; if ( ndo -> ndo_vflag > 2 ) { unsigned int paylen = opt -> rpl_dio_len ; if ( paylen > length ) paylen = length ; hex_print ( ndo , "<S2SV_blank>" , ( ( const uint8_t * ) opt ) + RPL_DIO_GENOPTION_LEN , paylen ) ; } } opt = ( const struct rpl_dio_genoption * ) ( ( ( const char * ) opt ) + optlen ) ; length -= optlen ; <S2SV_StartBug> } <S2SV_EndBug> return ; trunc : <S2SV_StartBug> ND_PRINT ( ( ndo , "<S2SV_blank>[|truncated]" ) ) ; <S2SV_EndBug> return ; }
int x86_decode_insn ( struct x86_emulate_ctxt * ctxt , void * insn , int insn_len ) { int rc = X86EMUL_CONTINUE ; int mode = ctxt -> mode ; int def_op_bytes , def_ad_bytes , goffset , simd_prefix ; bool op_prefix = false ; bool has_seg_override = false ; struct opcode opcode ; ctxt -> memop . type = OP_NONE ; ctxt -> memopp = NULL ; ctxt -> _eip = ctxt -> eip ; ctxt -> fetch . ptr = ctxt -> fetch . data ; ctxt -> fetch . end = ctxt -> fetch . data + insn_len ; ctxt -> opcode_len = 1 ; if ( insn_len > 0 ) memcpy ( ctxt -> fetch . data , insn , insn_len ) ; else { rc = __do_insn_fetch_bytes ( ctxt , 1 ) ; if ( rc != X86EMUL_CONTINUE ) return rc ; } switch ( mode ) { case X86EMUL_MODE_REAL : case X86EMUL_MODE_VM86 : case X86EMUL_MODE_PROT16 : def_op_bytes = def_ad_bytes = 2 ; break ; case X86EMUL_MODE_PROT32 : def_op_bytes = def_ad_bytes = 4 ; break ; # ifdef CONFIG_X86_64 case X86EMUL_MODE_PROT64 : def_op_bytes = 4 ; def_ad_bytes = 8 ; break ; # endif default : return EMULATION_FAILED ; } ctxt -> op_bytes = def_op_bytes ; ctxt -> ad_bytes = def_ad_bytes ; for ( ; ; ) { switch ( ctxt -> b = insn_fetch ( u8 , ctxt ) ) { case 0x66 : op_prefix = true ; ctxt -> op_bytes = def_op_bytes ^ 6 ; break ; case 0x67 : if ( mode == X86EMUL_MODE_PROT64 ) ctxt -> ad_bytes = def_ad_bytes ^ 12 ; else ctxt -> ad_bytes = def_ad_bytes ^ 6 ; break ; case 0x26 : case 0x2e : case 0x36 : case 0x3e : has_seg_override = true ; ctxt -> seg_override = ( ctxt -> b >> 3 ) & 3 ; break ; case 0x64 : case 0x65 : has_seg_override = true ; ctxt -> seg_override = ctxt -> b & 7 ; break ; case 0x40 ... 0x4f : if ( mode != X86EMUL_MODE_PROT64 ) goto done_prefixes ; ctxt -> rex_prefix = ctxt -> b ; continue ; case 0xf0 : ctxt -> lock_prefix = 1 ; break ; case 0xf2 : case 0xf3 : ctxt -> rep_prefix = ctxt -> b ; break ; default : goto done_prefixes ; } ctxt -> rex_prefix = 0 ; } done_prefixes : if ( ctxt -> rex_prefix & 8 ) ctxt -> op_bytes = 8 ; opcode = opcode_table [ ctxt -> b ] ; if ( ctxt -> b == 0x0f ) { ctxt -> opcode_len = 2 ; ctxt -> b = insn_fetch ( u8 , ctxt ) ; opcode = twobyte_table [ ctxt -> b ] ; if ( ctxt -> b == 0x38 ) { ctxt -> opcode_len = 3 ; ctxt -> b = insn_fetch ( u8 , ctxt ) ; opcode = opcode_map_0f_38 [ ctxt -> b ] ; } } ctxt -> d = opcode . flags ; if ( ctxt -> d & ModRM ) ctxt -> modrm = insn_fetch ( u8 , ctxt ) ; if ( ctxt -> opcode_len == 1 && ( ctxt -> b == 0xc5 || ctxt -> b == 0xc4 ) && ( mode == X86EMUL_MODE_PROT64 || ( mode >= X86EMUL_MODE_PROT16 && ( ctxt -> modrm & 0x80 ) ) ) ) { ctxt -> d = NotImpl ; } while ( ctxt -> d & GroupMask ) { switch ( ctxt -> d & GroupMask ) { case Group : goffset = ( ctxt -> modrm >> 3 ) & 7 ; opcode = opcode . u . group [ goffset ] ; break ; case GroupDual : goffset = ( ctxt -> modrm >> 3 ) & 7 ; if ( ( ctxt -> modrm >> 6 ) == 3 ) opcode = opcode . u . gdual -> mod3 [ goffset ] ; else opcode = opcode . u . gdual -> mod012 [ goffset ] ; break ; case RMExt : goffset = ctxt -> modrm & 7 ; opcode = opcode . u . group [ goffset ] ; break ; case Prefix : if ( ctxt -> rep_prefix && op_prefix ) return EMULATION_FAILED ; simd_prefix = op_prefix ? 0x66 : ctxt -> rep_prefix ; switch ( simd_prefix ) { case 0x00 : opcode = opcode . u . gprefix -> pfx_no ; break ; case 0x66 : opcode = opcode . u . gprefix -> pfx_66 ; break ; case 0xf2 : opcode = opcode . u . gprefix -> pfx_f2 ; break ; case 0xf3 : opcode = opcode . u . gprefix -> pfx_f3 ; break ; } break ; case Escape : if ( ctxt -> modrm > 0xbf ) opcode = opcode . u . esc -> high [ ctxt -> modrm - 0xc0 ] ; else opcode = opcode . u . esc -> op [ ( ctxt -> modrm >> 3 ) & 7 ] ; break ; default : return EMULATION_FAILED ; } ctxt -> d &= ~ ( u64 ) GroupMask ; ctxt -> d |= opcode . flags ; } if ( ctxt -> d == 0 ) return EMULATION_FAILED ; ctxt -> execute = opcode . u . execute ; if ( unlikely ( ctxt -> ud ) && likely ( ! ( ctxt -> d & EmulateOnUD ) ) ) return EMULATION_FAILED ; if ( unlikely ( ctxt -> d & ( NotImpl | Stack | Op3264 | Sse | Mmx | Intercept | CheckPerm ) ) ) { ctxt -> check_perm = opcode . check_perm ; ctxt -> intercept = opcode . intercept ; if ( ctxt -> d & NotImpl ) return EMULATION_FAILED ; if ( mode == X86EMUL_MODE_PROT64 && ( ctxt -> d & Stack ) ) ctxt -> op_bytes = 8 ; if ( ctxt -> d & Op3264 ) { if ( mode == X86EMUL_MODE_PROT64 ) ctxt -> op_bytes = 8 ; else ctxt -> op_bytes = 4 ; } if ( ctxt -> d & Sse ) ctxt -> op_bytes = 16 ; else if ( ctxt -> d & Mmx ) ctxt -> op_bytes = 8 ; } if ( ctxt -> d & ModRM ) { rc = decode_modrm ( ctxt , & ctxt -> memop ) ; if ( ! has_seg_override ) { has_seg_override = true ; ctxt -> seg_override = ctxt -> modrm_seg ; } } else if ( ctxt -> d & MemAbs ) rc = decode_abs ( ctxt , & ctxt -> memop ) ; if ( rc != X86EMUL_CONTINUE ) goto done ; if ( ! has_seg_override ) ctxt -> seg_override = VCPU_SREG_DS ; ctxt -> memop . addr . mem . seg = ctxt -> seg_override ; rc = decode_operand ( ctxt , & ctxt -> src , ( ctxt -> d >> SrcShift ) & OpMask ) ; if ( rc != X86EMUL_CONTINUE ) goto done ; rc = decode_operand ( ctxt , & ctxt -> src2 , ( ctxt -> d >> Src2Shift ) & OpMask ) ; if ( rc != X86EMUL_CONTINUE ) goto done ; rc = decode_operand ( ctxt , & ctxt -> dst , ( ctxt -> d >> DstShift ) & OpMask ) ; <S2SV_StartBug> done : <S2SV_EndBug> if ( ctxt -> rip_relative ) <S2SV_StartBug> ctxt -> memopp -> addr . mem . ea += ctxt -> _eip ; <S2SV_EndBug> return ( rc != X86EMUL_CONTINUE ) ? EMULATION_FAILED : EMULATION_OK ; }
int auth_password ( Authctxt * authctxt , const char * password ) { struct passwd * pw = authctxt -> pw ; int result , ok = authctxt -> valid ; # if defined ( USE_SHADOW ) && defined ( HAS_SHADOW_EXPIRE ) static int expire_checked = 0 ; <S2SV_StartBug> # endif <S2SV_EndBug> # ifndef HAVE_CYGWIN if ( pw -> pw_uid == 0 && options . permit_root_login != PERMIT_YES ) ok = 0 ; # endif if ( * password == '\\0' && options . permit_empty_passwd == 0 ) return 0 ; # ifdef KRB5 if ( options . kerberos_authentication == 1 ) { int ret = auth_krb5_password ( authctxt , password ) ; if ( ret == 1 || ret == 0 ) return ret && ok ; } # endif # ifdef HAVE_CYGWIN { HANDLE hToken = cygwin_logon_user ( pw , password ) ; if ( hToken == INVALID_HANDLE_VALUE ) return 0 ; cygwin_set_impersonation_token ( hToken ) ; return ok ; } # endif # ifdef USE_PAM if ( options . use_pam ) return ( sshpam_auth_passwd ( authctxt , password ) && ok ) ; # endif # if defined ( USE_SHADOW ) && defined ( HAS_SHADOW_EXPIRE ) if ( ! expire_checked ) { expire_checked = 1 ; if ( auth_shadow_pwexpired ( authctxt ) ) authctxt -> force_pwchange = 1 ; } # endif result = sys_auth_passwd ( authctxt , password ) ; if ( authctxt -> force_pwchange ) disable_forwarding ( ) ; return ( result && ok ) ; }
static inline signed short ReadPropertySignedShort ( const EndianType endian , const unsigned char * buffer ) { union { unsigned short unsigned_value ; signed short signed_value ; } quantum ; unsigned short value ; if ( endian == LSBEndian ) { <S2SV_StartBug> value = ( unsigned short ) ( ( buffer [ 1 ] << 8 ) | buffer [ 0 ] ) ; <S2SV_EndBug> <S2SV_StartBug> quantum . unsigned_value = ( value & 0xffff ) ; <S2SV_EndBug> return ( quantum . signed_value ) ; } <S2SV_StartBug> value = ( unsigned short ) ( ( ( ( unsigned char * ) buffer ) [ 0 ] << 8 ) | <S2SV_EndBug> <S2SV_StartBug> ( ( unsigned char * ) buffer ) [ 1 ] ) ; <S2SV_EndBug> <S2SV_StartBug> quantum . unsigned_value = ( value & 0xffff ) ; <S2SV_EndBug> return ( quantum . signed_value ) ; }
int btrfs_truncate_inode_items ( struct btrfs_trans_handle * trans , struct btrfs_root * root , struct inode * inode , u64 new_size , u32 min_type ) { struct btrfs_path * path ; struct extent_buffer * leaf ; struct btrfs_file_extent_item * fi ; struct btrfs_key key ; struct btrfs_key found_key ; u64 extent_start = 0 ; u64 extent_num_bytes = 0 ; u64 extent_offset = 0 ; u64 item_end = 0 ; u64 last_size = new_size ; u32 found_type = ( u8 ) - 1 ; int found_extent ; int del_item ; int pending_del_nr = 0 ; int pending_del_slot = 0 ; int extent_type = - 1 ; int ret ; int err = 0 ; u64 ino = btrfs_ino ( inode ) ; u64 bytes_deleted = 0 ; bool be_nice = 0 ; bool should_throttle = 0 ; bool should_end = 0 ; BUG_ON ( new_size > 0 && min_type != BTRFS_EXTENT_DATA_KEY ) ; if ( ! btrfs_is_free_space_inode ( inode ) && test_bit ( BTRFS_ROOT_REF_COWS , & root -> state ) ) be_nice = 1 ; path = btrfs_alloc_path ( ) ; if ( ! path ) return - ENOMEM ; path -> reada = - 1 ; if ( test_bit ( BTRFS_ROOT_REF_COWS , & root -> state ) || root == root -> fs_info -> tree_root ) btrfs_drop_extent_cache ( inode , ALIGN ( new_size , root -> sectorsize ) , ( u64 ) - 1 , 0 ) ; if ( min_type == 0 && root == BTRFS_I ( inode ) -> root ) btrfs_kill_delayed_inode_items ( inode ) ; key . objectid = ino ; key . offset = ( u64 ) - 1 ; key . type = ( u8 ) - 1 ; search_again : if ( be_nice && bytes_deleted > 32 * 1024 * 1024 ) { if ( btrfs_should_end_transaction ( trans , root ) ) { err = - EAGAIN ; goto error ; } } path -> leave_spinning = 1 ; ret = btrfs_search_slot ( trans , root , & key , path , - 1 , 1 ) ; if ( ret < 0 ) { err = ret ; goto out ; } if ( ret > 0 ) { if ( path -> slots [ 0 ] == 0 ) goto out ; path -> slots [ 0 ] -- ; } while ( 1 ) { fi = NULL ; leaf = path -> nodes [ 0 ] ; btrfs_item_key_to_cpu ( leaf , & found_key , path -> slots [ 0 ] ) ; found_type = found_key . type ; if ( found_key . objectid != ino ) break ; if ( found_type < min_type ) break ; item_end = found_key . offset ; if ( found_type == BTRFS_EXTENT_DATA_KEY ) { fi = btrfs_item_ptr ( leaf , path -> slots [ 0 ] , struct btrfs_file_extent_item ) ; extent_type = btrfs_file_extent_type ( leaf , fi ) ; if ( extent_type != BTRFS_FILE_EXTENT_INLINE ) { item_end += btrfs_file_extent_num_bytes ( leaf , fi ) ; } else if ( extent_type == BTRFS_FILE_EXTENT_INLINE ) { item_end += btrfs_file_extent_inline_len ( leaf , path -> slots [ 0 ] , fi ) ; } item_end -- ; } if ( found_type > min_type ) { del_item = 1 ; } else { if ( item_end < new_size ) break ; if ( found_key . offset >= new_size ) del_item = 1 ; else del_item = 0 ; } found_extent = 0 ; if ( found_type != BTRFS_EXTENT_DATA_KEY ) goto delete ; if ( del_item ) last_size = found_key . offset ; else last_size = new_size ; if ( extent_type != BTRFS_FILE_EXTENT_INLINE ) { u64 num_dec ; extent_start = btrfs_file_extent_disk_bytenr ( leaf , fi ) ; if ( ! del_item ) { u64 orig_num_bytes = btrfs_file_extent_num_bytes ( leaf , fi ) ; extent_num_bytes = ALIGN ( new_size - found_key . offset , root -> sectorsize ) ; btrfs_set_file_extent_num_bytes ( leaf , fi , extent_num_bytes ) ; num_dec = ( orig_num_bytes - extent_num_bytes ) ; if ( test_bit ( BTRFS_ROOT_REF_COWS , & root -> state ) && extent_start != 0 ) inode_sub_bytes ( inode , num_dec ) ; btrfs_mark_buffer_dirty ( leaf ) ; } else { extent_num_bytes = btrfs_file_extent_disk_num_bytes ( leaf , fi ) ; extent_offset = found_key . offset - btrfs_file_extent_offset ( leaf , fi ) ; num_dec = btrfs_file_extent_num_bytes ( leaf , fi ) ; if ( extent_start != 0 ) { found_extent = 1 ; if ( test_bit ( BTRFS_ROOT_REF_COWS , & root -> state ) ) inode_sub_bytes ( inode , num_dec ) ; } } } else if ( extent_type == BTRFS_FILE_EXTENT_INLINE ) { if ( ! del_item && <S2SV_StartBug> btrfs_file_extent_compression ( leaf , fi ) == 0 && <S2SV_EndBug> btrfs_file_extent_encryption ( leaf , fi ) == 0 && btrfs_file_extent_other_encoding ( leaf , fi ) == 0 ) { u32 size = new_size - found_key . offset ; <S2SV_StartBug> if ( test_bit ( BTRFS_ROOT_REF_COWS , & root -> state ) ) <S2SV_EndBug> inode_sub_bytes ( inode , item_end + 1 - <S2SV_StartBug> new_size ) ; <S2SV_EndBug> btrfs_set_file_extent_ram_bytes ( leaf , fi , size ) ; size = btrfs_file_extent_calc_inline_size ( size ) ; btrfs_truncate_item ( root , path , size , 1 ) ; } else if ( test_bit ( BTRFS_ROOT_REF_COWS , & root -> state ) ) { inode_sub_bytes ( inode , item_end + 1 - found_key . offset ) ; } } delete : if ( del_item ) { if ( ! pending_del_nr ) { pending_del_slot = path -> slots [ 0 ] ; pending_del_nr = 1 ; } else if ( pending_del_nr && path -> slots [ 0 ] + 1 == pending_del_slot ) { pending_del_nr ++ ; pending_del_slot = path -> slots [ 0 ] ; } else { BUG ( ) ; } } else { break ; } should_throttle = 0 ; if ( found_extent && ( test_bit ( BTRFS_ROOT_REF_COWS , & root -> state ) || root == root -> fs_info -> tree_root ) ) { btrfs_set_path_blocking ( path ) ; bytes_deleted += extent_num_bytes ; ret = btrfs_free_extent ( trans , root , extent_start , extent_num_bytes , 0 , btrfs_header_owner ( leaf ) , ino , extent_offset , 0 ) ; BUG_ON ( ret ) ; if ( btrfs_should_throttle_delayed_refs ( trans , root ) ) btrfs_async_run_delayed_refs ( root , trans -> delayed_ref_updates * 2 , 0 ) ; if ( be_nice ) { if ( truncate_space_check ( trans , root , extent_num_bytes ) ) { should_end = 1 ; } if ( btrfs_should_throttle_delayed_refs ( trans , root ) ) { should_throttle = 1 ; } } } if ( found_type == BTRFS_INODE_ITEM_KEY ) break ; if ( path -> slots [ 0 ] == 0 || path -> slots [ 0 ] != pending_del_slot || should_throttle || should_end ) { if ( pending_del_nr ) { ret = btrfs_del_items ( trans , root , path , pending_del_slot , pending_del_nr ) ; if ( ret ) { btrfs_abort_transaction ( trans , root , ret ) ; goto error ; } pending_del_nr = 0 ; } btrfs_release_path ( path ) ; if ( should_throttle ) { unsigned long updates = trans -> delayed_ref_updates ; if ( updates ) { trans -> delayed_ref_updates = 0 ; ret = btrfs_run_delayed_refs ( trans , root , updates * 2 ) ; if ( ret && ! err ) err = ret ; } } if ( should_end ) { err = - EAGAIN ; goto error ; } goto search_again ; } else { path -> slots [ 0 ] -- ; } } out : if ( pending_del_nr ) { ret = btrfs_del_items ( trans , root , path , pending_del_slot , pending_del_nr ) ; if ( ret ) btrfs_abort_transaction ( trans , root , ret ) ; } error : if ( root -> root_key . objectid != BTRFS_TREE_LOG_OBJECTID ) btrfs_ordered_update_i_size ( inode , last_size , NULL ) ; btrfs_free_path ( path ) ; if ( be_nice && bytes_deleted > 32 * 1024 * 1024 ) { unsigned long updates = trans -> delayed_ref_updates ; if ( updates ) { trans -> delayed_ref_updates = 0 ; ret = btrfs_run_delayed_refs ( trans , root , updates * 2 ) ; if ( ret && ! err ) err = ret ; } } return err ; }
static int unix_dgram_sendmsg ( struct socket * sock , struct msghdr * msg , size_t len ) { struct sock * sk = sock -> sk ; struct net * net = sock_net ( sk ) ; struct unix_sock * u = unix_sk ( sk ) ; DECLARE_SOCKADDR ( struct sockaddr_un * , sunaddr , msg -> msg_name ) ; struct sock * other = NULL ; int namelen = 0 ; int err ; unsigned int hash ; struct sk_buff * skb ; long timeo ; struct scm_cookie scm ; int max_level ; int data_len = 0 ; <S2SV_StartBug> wait_for_unix_gc ( ) ; <S2SV_EndBug> err = scm_send ( sock , msg , & scm , false ) ; if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out ; if ( msg -> msg_namelen ) { err = unix_mkname ( sunaddr , msg -> msg_namelen , & hash ) ; if ( err < 0 ) goto out ; namelen = err ; } else { sunaddr = NULL ; err = - ENOTCONN ; other = unix_peer_get ( sk ) ; if ( ! other ) goto out ; } if ( test_bit ( SOCK_PASSCRED , & sock -> flags ) && ! u -> addr && ( err = unix_autobind ( sock ) ) != 0 ) goto out ; err = - EMSGSIZE ; if ( len > sk -> sk_sndbuf - 32 ) goto out ; if ( len > SKB_MAX_ALLOC ) { data_len = min_t ( size_t , len - SKB_MAX_ALLOC , MAX_SKB_FRAGS * PAGE_SIZE ) ; data_len = PAGE_ALIGN ( data_len ) ; BUILD_BUG_ON ( SKB_MAX_ALLOC < PAGE_SIZE ) ; } skb = sock_alloc_send_pskb ( sk , len - data_len , data_len , msg -> msg_flags & MSG_DONTWAIT , & err , PAGE_ALLOC_COSTLY_ORDER ) ; if ( skb == NULL ) goto out ; err = unix_scm_to_skb ( & scm , skb , true ) ; if ( err < 0 ) goto out_free ; max_level = err + 1 ; skb_put ( skb , len - data_len ) ; skb -> data_len = data_len ; skb -> len = len ; err = skb_copy_datagram_from_iter ( skb , 0 , & msg -> msg_iter , len ) ; if ( err ) goto out_free ; timeo = sock_sndtimeo ( sk , msg -> msg_flags & MSG_DONTWAIT ) ; restart : if ( ! other ) { err = - ECONNRESET ; if ( sunaddr == NULL ) goto out_free ; other = unix_find_other ( net , sunaddr , namelen , sk -> sk_type , hash , & err ) ; if ( other == NULL ) goto out_free ; } if ( sk_filter ( other , skb ) < 0 ) { err = len ; goto out_free ; } <S2SV_StartBug> unix_state_lock ( other ) ; <S2SV_EndBug> err = - EPERM ; if ( ! unix_may_send ( sk , other ) ) goto out_unlock ; <S2SV_StartBug> if ( sock_flag ( other , SOCK_DEAD ) ) { <S2SV_EndBug> unix_state_unlock ( other ) ; sock_put ( other ) ; <S2SV_StartBug> err = 0 ; <S2SV_EndBug> <S2SV_StartBug> unix_state_lock ( sk ) ; <S2SV_EndBug> if ( unix_peer ( sk ) == other ) { <S2SV_StartBug> unix_peer ( sk ) = NULL ; <S2SV_EndBug> unix_state_unlock ( sk ) ; unix_dgram_disconnected ( sk , other ) ; sock_put ( other ) ; err = - ECONNREFUSED ; } else { unix_state_unlock ( sk ) ; } other = NULL ; if ( err ) goto out_free ; goto restart ; } err = - EPIPE ; if ( other -> sk_shutdown & RCV_SHUTDOWN ) goto out_unlock ; if ( sk -> sk_type != SOCK_SEQPACKET ) { err = security_unix_may_send ( sk -> sk_socket , other -> sk_socket ) ; if ( err ) goto out_unlock ; } <S2SV_StartBug> if ( unix_peer ( other ) != sk && unix_recvq_full ( other ) ) { <S2SV_EndBug> <S2SV_StartBug> if ( ! timeo ) { <S2SV_EndBug> err = - EAGAIN ; <S2SV_StartBug> goto out_unlock ; <S2SV_EndBug> } <S2SV_StartBug> timeo = unix_wait_for_peer ( other , timeo ) ; <S2SV_EndBug> err = sock_intr_errno ( timeo ) ; if ( signal_pending ( current ) ) goto out_free ; goto restart ; } if ( sock_flag ( other , SOCK_RCVTSTAMP ) ) __net_timestamp ( skb ) ; maybe_add_creds ( skb , sock , other ) ; skb_queue_tail ( & other -> sk_receive_queue , skb ) ; if ( max_level > unix_sk ( other ) -> recursion_level ) unix_sk ( other ) -> recursion_level = max_level ; unix_state_unlock ( other ) ; other -> sk_data_ready ( other ) ; sock_put ( other ) ; scm_destroy ( & scm ) ; return len ; out_unlock : <S2SV_StartBug> unix_state_unlock ( other ) ; <S2SV_EndBug> out_free : kfree_skb ( skb ) ; out : if ( other ) sock_put ( other ) ; scm_destroy ( & scm ) ; return err ; }
static int amd_gpio_remove ( struct platform_device * pdev ) { struct amd_gpio * gpio_dev ; gpio_dev = platform_get_drvdata ( pdev ) ; gpiochip_remove ( & gpio_dev -> gc ) ; <S2SV_StartBug> pinctrl_unregister ( gpio_dev -> pctrl ) ; <S2SV_EndBug> return 0 ; }
Datum txid_current_snapshot ( PG_FUNCTION_ARGS ) { TxidSnapshot * snap ; uint32 nxip , i , size ; TxidEpoch state ; Snapshot cur ; cur = GetActiveSnapshot ( ) ; if ( cur == NULL ) elog ( ERROR , "no<S2SV_blank>active<S2SV_blank>snapshot<S2SV_blank>set" ) ; <S2SV_StartBug> load_xid_epoch ( & state ) ; <S2SV_EndBug> nxip = cur -> xcnt ; size = TXID_SNAPSHOT_SIZE ( nxip ) ; snap = palloc ( size ) ; SET_VARSIZE ( snap , size ) ; snap -> xmin = convert_xid ( cur -> xmin , & state ) ; snap -> xmax = convert_xid ( cur -> xmax , & state ) ; snap -> nxip = nxip ; for ( i = 0 ; i < nxip ; i ++ ) snap -> xip [ i ] = convert_xid ( cur -> xip [ i ] , & state ) ; sort_snapshot ( snap ) ; PG_RETURN_POINTER ( snap ) ; }
static int raw_sendmsg ( struct sock * sk , struct msghdr * msg , size_t len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct net * net = sock_net ( sk ) ; struct ipcm_cookie ipc ; struct rtable * rt = NULL ; struct flowi4 fl4 ; int free = 0 ; __be32 daddr ; __be32 saddr ; u8 tos ; int err ; struct ip_options_data opt_copy ; struct raw_frag_vec rfv ; <S2SV_StartBug> err = - EMSGSIZE ; <S2SV_EndBug> if ( len > 0xFFFF ) <S2SV_StartBug> goto out ; <S2SV_EndBug> err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out ; if ( msg -> msg_namelen ) { DECLARE_SOCKADDR ( struct sockaddr_in * , usin , msg -> msg_name ) ; err = - EINVAL ; if ( msg -> msg_namelen < sizeof ( * usin ) ) goto out ; if ( usin -> sin_family != AF_INET ) { pr_info_once ( "%s:<S2SV_blank>%s<S2SV_blank>forgot<S2SV_blank>to<S2SV_blank>set<S2SV_blank>AF_INET.<S2SV_blank>Fix<S2SV_blank>it!\\n" , __func__ , current -> comm ) ; err = - EAFNOSUPPORT ; if ( usin -> sin_family ) goto out ; } daddr = usin -> sin_addr . s_addr ; } else { err = - EDESTADDRREQ ; if ( sk -> sk_state != TCP_ESTABLISHED ) goto out ; daddr = inet -> inet_daddr ; } ipc . sockc . tsflags = sk -> sk_tsflags ; ipc . addr = inet -> inet_saddr ; ipc . opt = NULL ; ipc . tx_flags = 0 ; ipc . ttl = 0 ; ipc . tos = - 1 ; ipc . oif = sk -> sk_bound_dev_if ; if ( msg -> msg_controllen ) { err = ip_cmsg_send ( sk , msg , & ipc , false ) ; if ( unlikely ( err ) ) { kfree ( ipc . opt ) ; goto out ; } if ( ipc . opt ) free = 1 ; } saddr = ipc . addr ; ipc . addr = daddr ; if ( ! ipc . opt ) { struct ip_options_rcu * inet_opt ; rcu_read_lock ( ) ; inet_opt = rcu_dereference ( inet -> inet_opt ) ; if ( inet_opt ) { memcpy ( & opt_copy , inet_opt , sizeof ( * inet_opt ) + inet_opt -> opt . optlen ) ; ipc . opt = & opt_copy . opt ; } rcu_read_unlock ( ) ; } if ( ipc . opt ) { err = - EINVAL ; <S2SV_StartBug> if ( inet -> hdrincl ) <S2SV_EndBug> goto done ; if ( ipc . opt -> opt . srr ) { if ( ! daddr ) goto done ; daddr = ipc . opt -> opt . faddr ; } } tos = get_rtconn_flags ( & ipc , sk ) ; if ( msg -> msg_flags & MSG_DONTROUTE ) tos |= RTO_ONLINK ; if ( ipv4_is_multicast ( daddr ) ) { if ( ! ipc . oif ) ipc . oif = inet -> mc_index ; if ( ! saddr ) saddr = inet -> mc_addr ; } else if ( ! ipc . oif ) ipc . oif = inet -> uc_index ; flowi4_init_output ( & fl4 , ipc . oif , sk -> sk_mark , tos , RT_SCOPE_UNIVERSE , <S2SV_StartBug> inet -> hdrincl ? IPPROTO_RAW : sk -> sk_protocol , <S2SV_EndBug> inet_sk_flowi_flags ( sk ) | <S2SV_StartBug> ( inet -> hdrincl ? FLOWI_FLAG_KNOWN_NH : 0 ) , <S2SV_EndBug> daddr , saddr , 0 , 0 , sk -> sk_uid ) ; <S2SV_StartBug> if ( ! inet -> hdrincl ) { <S2SV_EndBug> rfv . msg = msg ; rfv . hlen = 0 ; err = raw_probe_proto_opt ( & rfv , & fl4 ) ; if ( err ) goto done ; } security_sk_classify_flow ( sk , flowi4_to_flowi ( & fl4 ) ) ; rt = ip_route_output_flow ( net , & fl4 , sk ) ; if ( IS_ERR ( rt ) ) { err = PTR_ERR ( rt ) ; rt = NULL ; goto done ; } err = - EACCES ; if ( rt -> rt_flags & RTCF_BROADCAST && ! sock_flag ( sk , SOCK_BROADCAST ) ) goto done ; if ( msg -> msg_flags & MSG_CONFIRM ) goto do_confirm ; back_from_confirm : <S2SV_StartBug> if ( inet -> hdrincl ) <S2SV_EndBug> err = raw_send_hdrinc ( sk , & fl4 , msg , len , & rt , msg -> msg_flags , & ipc . sockc ) ; else { sock_tx_timestamp ( sk , ipc . sockc . tsflags , & ipc . tx_flags ) ; if ( ! ipc . addr ) ipc . addr = fl4 . daddr ; lock_sock ( sk ) ; err = ip_append_data ( sk , & fl4 , raw_getfrag , & rfv , len , 0 , & ipc , & rt , msg -> msg_flags ) ; if ( err ) ip_flush_pending_frames ( sk ) ; else if ( ! ( msg -> msg_flags & MSG_MORE ) ) { err = ip_push_pending_frames ( sk , & fl4 ) ; if ( err == - ENOBUFS && ! inet -> recverr ) err = 0 ; } release_sock ( sk ) ; } done : if ( free ) kfree ( ipc . opt ) ; ip_rt_put ( rt ) ; out : if ( err < 0 ) return err ; return len ; do_confirm : if ( msg -> msg_flags & MSG_PROBE ) dst_confirm_neigh ( & rt -> dst , & fl4 . daddr ) ; if ( ! ( msg -> msg_flags & MSG_PROBE ) || len ) goto back_from_confirm ; err = 0 ; goto done ; }
static void filter_session_io ( struct io * io , int evt , void * arg ) { struct filter_session * fs = arg ; char * line = NULL ; ssize_t len ; log_trace ( TRACE_IO , "filter<S2SV_blank>session:<S2SV_blank>%p:<S2SV_blank>%s<S2SV_blank>%s" , fs , io_strevent ( evt ) , io_strio ( io ) ) ; switch ( evt ) { case IO_DATAIN : nextline : line = io_getline ( fs -> io , & len ) ; if ( line == NULL ) return ; filter_data ( fs -> id , line ) ; goto nextline ; <S2SV_StartBug> case IO_DISCONNECTED : <S2SV_EndBug> io_free ( fs -> io ) ; fs -> io = NULL ; break ; } }
static OPJ_BOOL opj_pi_next_rpcl ( opj_pi_iterator_t * pi ) { opj_pi_comp_t * comp = NULL ; opj_pi_resolution_t * res = NULL ; OPJ_UINT32 index = 0 ; if ( ! pi -> first ) { goto LABEL_SKIP ; } else { OPJ_UINT32 compno , resno ; pi -> first = 0 ; pi -> dx = 0 ; pi -> dy = 0 ; for ( compno = 0 ; compno < pi -> numcomps ; compno ++ ) { comp = & pi -> comps [ compno ] ; for ( resno = 0 ; resno < comp -> numresolutions ; resno ++ ) { OPJ_UINT32 dx , dy ; res = & comp -> resolutions [ resno ] ; dx = comp -> dx * ( 1u << ( res -> pdx + comp -> numresolutions - 1 - resno ) ) ; dy = comp -> dy * ( 1u << ( res -> pdy + comp -> numresolutions - 1 - resno ) ) ; pi -> dx = ! pi -> dx ? dx : opj_uint_min ( pi -> dx , dx ) ; pi -> dy = ! pi -> dy ? dy : opj_uint_min ( pi -> dy , dy ) ; } } } if ( ! pi -> tp_on ) { pi -> poc . ty0 = pi -> ty0 ; pi -> poc . tx0 = pi -> tx0 ; pi -> poc . ty1 = pi -> ty1 ; pi -> poc . tx1 = pi -> tx1 ; } for ( pi -> resno = pi -> poc . resno0 ; pi -> resno < pi -> poc . resno1 ; pi -> resno ++ ) { for ( pi -> y = pi -> poc . ty0 ; pi -> y < pi -> poc . ty1 ; pi -> y += ( OPJ_INT32 ) ( pi -> dy - ( OPJ_UINT32 ) ( pi -> y % ( OPJ_INT32 ) pi -> dy ) ) ) { for ( pi -> x = pi -> poc . tx0 ; pi -> x < pi -> poc . tx1 ; pi -> x += ( OPJ_INT32 ) ( pi -> dx - ( OPJ_UINT32 ) ( pi -> x % ( OPJ_INT32 ) pi -> dx ) ) ) { for ( pi -> compno = pi -> poc . compno0 ; pi -> compno < pi -> poc . compno1 ; pi -> compno ++ ) { OPJ_UINT32 levelno ; OPJ_INT32 trx0 , try0 ; OPJ_INT32 trx1 , try1 ; OPJ_UINT32 rpx , rpy ; OPJ_INT32 prci , prcj ; comp = & pi -> comps [ pi -> compno ] ; if ( pi -> resno >= comp -> numresolutions ) { continue ; } res = & comp -> resolutions [ pi -> resno ] ; levelno = comp -> numresolutions - 1 - pi -> resno ; trx0 = opj_int_ceildiv ( pi -> tx0 , ( OPJ_INT32 ) ( comp -> dx << levelno ) ) ; try0 = opj_int_ceildiv ( pi -> ty0 , ( OPJ_INT32 ) ( comp -> dy << levelno ) ) ; trx1 = opj_int_ceildiv ( pi -> tx1 , ( OPJ_INT32 ) ( comp -> dx << levelno ) ) ; try1 = opj_int_ceildiv ( pi -> ty1 , ( OPJ_INT32 ) ( comp -> dy << levelno ) ) ; rpx = res -> pdx + levelno ; rpy = res -> pdy + levelno ; <S2SV_StartBug> if ( ! ( ( pi -> y % ( OPJ_INT32 ) ( comp -> dy << rpy ) == 0 ) || ( ( pi -> y == pi -> ty0 ) && <S2SV_EndBug> ( ( try0 << levelno ) % ( 1 << rpy ) ) ) ) ) { continue ; } if ( ! ( ( pi -> x % ( OPJ_INT32 ) ( comp -> dx << rpx ) == 0 ) || ( ( pi -> x == pi -> tx0 ) && ( ( trx0 << levelno ) % ( 1 << rpx ) ) ) ) ) { continue ; } if ( ( res -> pw == 0 ) || ( res -> ph == 0 ) ) { continue ; } if ( ( trx0 == trx1 ) || ( try0 == try1 ) ) { continue ; } prci = opj_int_floordivpow2 ( opj_int_ceildiv ( pi -> x , ( OPJ_INT32 ) ( comp -> dx << levelno ) ) , ( OPJ_INT32 ) res -> pdx ) - opj_int_floordivpow2 ( trx0 , ( OPJ_INT32 ) res -> pdx ) ; prcj = opj_int_floordivpow2 ( opj_int_ceildiv ( pi -> y , ( OPJ_INT32 ) ( comp -> dy << levelno ) ) , ( OPJ_INT32 ) res -> pdy ) - opj_int_floordivpow2 ( try0 , ( OPJ_INT32 ) res -> pdy ) ; pi -> precno = ( OPJ_UINT32 ) ( prci + prcj * ( OPJ_INT32 ) res -> pw ) ; for ( pi -> layno = pi -> poc . layno0 ; pi -> layno < pi -> poc . layno1 ; pi -> layno ++ ) { index = pi -> layno * pi -> step_l + pi -> resno * pi -> step_r + pi -> compno * pi -> step_c + pi -> precno * pi -> step_p ; if ( ! pi -> include [ index ] ) { pi -> include [ index ] = 1 ; return OPJ_TRUE ; } LABEL_SKIP : ; } } } } } return OPJ_FALSE ; }
inline int web_client_api_request_v1_data ( RRDHOST * host , struct web_client * w , char * url ) { debug ( D_WEB_CLIENT , "%llu:<S2SV_blank>API<S2SV_blank>v1<S2SV_blank>data<S2SV_blank>with<S2SV_blank>URL<S2SV_blank>\'%s\'" , w -> id , url ) ; int ret = 400 ; BUFFER * dimensions = NULL ; buffer_flush ( w -> response . data ) ; char * google_version = "0.6" , * google_reqId = "0" , * google_sig = "0" , * google_out = "json" , * responseHandler = NULL , * outFileName = NULL ; time_t last_timestamp_in_data = 0 , google_timestamp = 0 ; char * chart = NULL , * before_str = NULL , * after_str = NULL , * group_time_str = NULL , * points_str = NULL ; int group = RRDR_GROUPING_AVERAGE ; uint32_t format = DATASOURCE_JSON ; uint32_t options = 0x00000000 ; while ( url ) { char * value = mystrsep ( & url , "?&" ) ; if ( ! value || ! * value ) continue ; char * name = mystrsep ( & value , "=" ) ; if ( ! name || ! * name ) continue ; if ( ! value || ! * value ) continue ; debug ( D_WEB_CLIENT , "%llu:<S2SV_blank>API<S2SV_blank>v1<S2SV_blank>data<S2SV_blank>query<S2SV_blank>param<S2SV_blank>\'%s\'<S2SV_blank>with<S2SV_blank>value<S2SV_blank>\'%s\'" , w -> id , name , value ) ; if ( ! strcmp ( name , "chart" ) ) chart = value ; else if ( ! strcmp ( name , "dimension" ) || ! strcmp ( name , "dim" ) || ! strcmp ( name , "dimensions" ) || ! strcmp ( name , "dims" ) ) { if ( ! dimensions ) dimensions = buffer_create ( 100 ) ; buffer_strcat ( dimensions , "|" ) ; buffer_strcat ( dimensions , value ) ; } else if ( ! strcmp ( name , "after" ) ) after_str = value ; else if ( ! strcmp ( name , "before" ) ) before_str = value ; else if ( ! strcmp ( name , "points" ) ) points_str = value ; else if ( ! strcmp ( name , "gtime" ) ) group_time_str = value ; else if ( ! strcmp ( name , "group" ) ) { group = web_client_api_request_v1_data_group ( value , RRDR_GROUPING_AVERAGE ) ; } else if ( ! strcmp ( name , "format" ) ) { format = web_client_api_request_v1_data_format ( value ) ; } else if ( ! strcmp ( name , "options" ) ) { options |= web_client_api_request_v1_data_options ( value ) ; } else if ( ! strcmp ( name , "callback" ) ) { responseHandler = value ; } else if ( ! strcmp ( name , "filename" ) ) { outFileName = value ; } else if ( ! strcmp ( name , "tqx" ) ) { char * tqx_name , * tqx_value ; while ( value ) { tqx_value = mystrsep ( & value , ";" ) ; if ( ! tqx_value || ! * tqx_value ) continue ; tqx_name = mystrsep ( & tqx_value , ":" ) ; if ( ! tqx_name || ! * tqx_name ) continue ; if ( ! tqx_value || ! * tqx_value ) continue ; if ( ! strcmp ( tqx_name , "version" ) ) google_version = tqx_value ; else if ( ! strcmp ( tqx_name , "reqId" ) ) google_reqId = tqx_value ; else if ( ! strcmp ( tqx_name , "sig" ) ) { google_sig = tqx_value ; google_timestamp = strtoul ( google_sig , NULL , 0 ) ; } else if ( ! strcmp ( tqx_name , "out" ) ) { google_out = tqx_value ; format = web_client_api_request_v1_data_google_format ( google_out ) ; } else if ( ! strcmp ( tqx_name , "responseHandler" ) ) responseHandler = tqx_value ; else if ( ! strcmp ( tqx_name , "outFileName" ) ) outFileName = tqx_value ; } } } <S2SV_StartBug> if ( ! chart || ! * chart ) { <S2SV_EndBug> buffer_sprintf ( w -> response . data , "No<S2SV_blank>chart<S2SV_blank>id<S2SV_blank>is<S2SV_blank>given<S2SV_blank>at<S2SV_blank>the<S2SV_blank>request." ) ; goto cleanup ; } RRDSET * st = rrdset_find ( host , chart ) ; if ( ! st ) st = rrdset_find_byname ( host , chart ) ; if ( ! st ) { buffer_strcat ( w -> response . data , "Chart<S2SV_blank>is<S2SV_blank>not<S2SV_blank>found:<S2SV_blank>" ) ; buffer_strcat_htmlescape ( w -> response . data , chart ) ; ret = 404 ; goto cleanup ; } st -> last_accessed_time = now_realtime_sec ( ) ; long long before = ( before_str && * before_str ) ? str2l ( before_str ) : 0 ; long long after = ( after_str && * after_str ) ? str2l ( after_str ) : 0 ; int points = ( points_str && * points_str ) ? str2i ( points_str ) : 0 ; long group_time = ( group_time_str && * group_time_str ) ? str2l ( group_time_str ) : 0 ; debug ( D_WEB_CLIENT , "%llu:<S2SV_blank>API<S2SV_blank>command<S2SV_blank>\'data\'<S2SV_blank>for<S2SV_blank>chart<S2SV_blank>\'%s\',<S2SV_blank>dimensions<S2SV_blank>\'%s\',<S2SV_blank>after<S2SV_blank>\'%lld\',<S2SV_blank>before<S2SV_blank>\'%lld\',<S2SV_blank>points<S2SV_blank>\'%d\',<S2SV_blank>group<S2SV_blank>\'%d\',<S2SV_blank>format<S2SV_blank>\'%u\',<S2SV_blank>options<S2SV_blank>\'0x%08x\'" , w -> id , chart , ( dimensions ) ? buffer_tostring ( dimensions ) : "" , after , before , points , group , format , options ) ; if ( outFileName && * outFileName ) { buffer_sprintf ( w -> response . header , "Content-Disposition:<S2SV_blank>attachment;<S2SV_blank>filename=\\"%s\\"\\r\\n" , outFileName ) ; debug ( D_WEB_CLIENT , "%llu:<S2SV_blank>generating<S2SV_blank>outfilename<S2SV_blank>header:<S2SV_blank>\'%s\'" , w -> id , outFileName ) ; } if ( format == DATASOURCE_DATATABLE_JSONP ) { if ( responseHandler == NULL ) responseHandler = "google.visualization.Query.setResponse" ; debug ( D_WEB_CLIENT_ACCESS , "%llu:<S2SV_blank>GOOGLE<S2SV_blank>JSON/JSONP:<S2SV_blank>version<S2SV_blank>=<S2SV_blank>\'%s\',<S2SV_blank>reqId<S2SV_blank>=<S2SV_blank>\'%s\',<S2SV_blank>sig<S2SV_blank>=<S2SV_blank>\'%s\',<S2SV_blank>out<S2SV_blank>=<S2SV_blank>\'%s\',<S2SV_blank>responseHandler<S2SV_blank>=<S2SV_blank>\'%s\',<S2SV_blank>outFileName<S2SV_blank>=<S2SV_blank>\'%s\'" , w -> id , google_version , google_reqId , google_sig , google_out , responseHandler , outFileName ) ; buffer_sprintf ( w -> response . data , "%s({version:\'%s\',reqId:\'%s\',status:\'ok\',sig:\'%ld\',table:" , responseHandler , google_version , google_reqId , st -> last_updated . tv_sec ) ; } else if ( format == DATASOURCE_JSONP ) { if ( responseHandler == NULL ) responseHandler = "callback" ; buffer_strcat ( w -> response . data , responseHandler ) ; buffer_strcat ( w -> response . data , "(" ) ; } ret = rrdset2anything_api_v1 ( st , w -> response . data , dimensions , format , points , after , before , group , group_time , options , & last_timestamp_in_data ) ; if ( format == DATASOURCE_DATATABLE_JSONP ) { if ( google_timestamp < last_timestamp_in_data ) buffer_strcat ( w -> response . data , "});" ) ; else { buffer_flush ( w -> response . data ) ; buffer_sprintf ( w -> response . data , "%s({version:\'%s\',reqId:\'%s\',status:\'error\',errors:[{reason:\'not_modified\',message:\'Data<S2SV_blank>not<S2SV_blank>modified\'}]});" , responseHandler , google_version , google_reqId ) ; } } else if ( format == DATASOURCE_JSONP ) buffer_strcat ( w -> response . data , ");" ) ; cleanup : buffer_free ( dimensions ) ; return ret ; }
static void ttm_put_pages ( struct page * * pages , unsigned npages , int flags , enum ttm_caching_state cstate ) { struct ttm_page_pool * pool = ttm_get_pool ( flags , false , cstate ) ; # ifdef CONFIG_TRANSPARENT_HUGEPAGE struct ttm_page_pool * huge = ttm_get_pool ( flags , true , cstate ) ; # endif unsigned long irq_flags ; unsigned i ; if ( pool == NULL ) { i = 0 ; while ( i < npages ) { # ifdef CONFIG_TRANSPARENT_HUGEPAGE struct page * p = pages [ i ] ; # endif unsigned order = 0 , j ; if ( ! pages [ i ] ) { ++ i ; continue ; } # ifdef CONFIG_TRANSPARENT_HUGEPAGE <S2SV_StartBug> if ( ! ( flags & TTM_PAGE_FLAG_DMA32 ) ) { <S2SV_EndBug> for ( j = 0 ; j < HPAGE_PMD_NR ; ++ j ) if ( p ++ != pages [ i + j ] ) break ; if ( j == HPAGE_PMD_NR ) order = HPAGE_PMD_ORDER ; } # endif if ( page_count ( pages [ i ] ) != 1 ) pr_err ( "Erroneous<S2SV_blank>page<S2SV_blank>count.<S2SV_blank>Leaking<S2SV_blank>pages.\\n" ) ; __free_pages ( pages [ i ] , order ) ; j = 1 << order ; while ( j ) { pages [ i ++ ] = NULL ; -- j ; } } return ; } i = 0 ; # ifdef CONFIG_TRANSPARENT_HUGEPAGE if ( huge ) { unsigned max_size , n2free ; spin_lock_irqsave ( & huge -> lock , irq_flags ) ; <S2SV_StartBug> while ( i < npages ) { <S2SV_EndBug> struct page * p = pages [ i ] ; unsigned j ; if ( ! p ) break ; for ( j = 0 ; j < HPAGE_PMD_NR ; ++ j ) if ( p ++ != pages [ i + j ] ) break ; if ( j != HPAGE_PMD_NR ) break ; list_add_tail ( & pages [ i ] -> lru , & huge -> list ) ; for ( j = 0 ; j < HPAGE_PMD_NR ; ++ j ) pages [ i ++ ] = NULL ; huge -> npages ++ ; } max_size = _manager -> options . max_size ; max_size /= HPAGE_PMD_NR ; if ( huge -> npages > max_size ) n2free = huge -> npages - max_size ; else n2free = 0 ; spin_unlock_irqrestore ( & huge -> lock , irq_flags ) ; if ( n2free ) ttm_page_pool_free ( huge , n2free , false ) ; } # endif spin_lock_irqsave ( & pool -> lock , irq_flags ) ; while ( i < npages ) { if ( pages [ i ] ) { if ( page_count ( pages [ i ] ) != 1 ) pr_err ( "Erroneous<S2SV_blank>page<S2SV_blank>count.<S2SV_blank>Leaking<S2SV_blank>pages.\\n" ) ; list_add_tail ( & pages [ i ] -> lru , & pool -> list ) ; pages [ i ] = NULL ; pool -> npages ++ ; } ++ i ; } npages = 0 ; if ( pool -> npages > _manager -> options . max_size ) { npages = pool -> npages - _manager -> options . max_size ; if ( npages < NUM_PAGES_TO_ALLOC ) npages = NUM_PAGES_TO_ALLOC ; } spin_unlock_irqrestore ( & pool -> lock , irq_flags ) ; if ( npages ) ttm_page_pool_free ( pool , npages , false ) ; }
asmlinkage void bad_mode ( struct pt_regs * regs , int reason , unsigned int esr ) <S2SV_StartBug> { <S2SV_EndBug> console_verbose ( ) ; pr_crit ( "Bad<S2SV_blank>mode<S2SV_blank>in<S2SV_blank>%s<S2SV_blank>handler<S2SV_blank>detected,<S2SV_blank>code<S2SV_blank>0x%08x\\n" , handler [ reason ] , esr ) ; <S2SV_StartBug> die ( "Oops<S2SV_blank>-<S2SV_blank>bad<S2SV_blank>mode" , regs , 0 ) ; <S2SV_EndBug> local_irq_disable ( ) ; panic ( "bad<S2SV_blank>mode" ) ; }
void bdt_enable ( void ) { bdt_log ( "ENABLE<S2SV_blank>BT" ) ; if ( bt_enabled ) { bdt_log ( "Bluetooth<S2SV_blank>is<S2SV_blank>already<S2SV_blank>enabled" ) ; return ; } <S2SV_StartBug> status = sBtInterface -> enable ( ) ; <S2SV_EndBug> check_return_status ( status ) ; }
static int <S2SV_StartBug> l_strnstart ( const char * tstr1 , u_int tl1 , const char * str2 , u_int l2 ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> if ( tl1 > l2 ) return 0 ; return ( strncmp ( tstr1 , str2 , tl1 ) == 0 ? 1 : 0 ) ; }
static void icmp6_send ( struct sk_buff * skb , u8 type , u8 code , __u32 info , const struct in6_addr * force_saddr ) { struct net * net = dev_net ( skb -> dev ) ; struct inet6_dev * idev = NULL ; struct ipv6hdr * hdr = ipv6_hdr ( skb ) ; struct sock * sk ; struct ipv6_pinfo * np ; const struct in6_addr * saddr = NULL ; struct dst_entry * dst ; struct icmp6hdr tmp_hdr ; struct flowi6 fl6 ; struct icmpv6_msg msg ; struct sockcm_cookie sockc_unused = { 0 } ; struct ipcm6_cookie ipc6 ; int iif = 0 ; int addr_type = 0 ; int len ; int err = 0 ; u32 mark = IP6_REPLY_MARK ( net , skb -> mark ) ; if ( ( u8 * ) hdr < skb -> head || ( skb_network_header ( skb ) + sizeof ( * hdr ) ) > skb_tail_pointer ( skb ) ) return ; addr_type = ipv6_addr_type ( & hdr -> daddr ) ; if ( ipv6_chk_addr ( net , & hdr -> daddr , skb -> dev , 0 ) || ipv6_chk_acast_addr_src ( net , skb -> dev , & hdr -> daddr ) ) saddr = & hdr -> daddr ; if ( addr_type & IPV6_ADDR_MULTICAST || skb -> pkt_type != PACKET_HOST ) { if ( type != ICMPV6_PKT_TOOBIG && ! ( type == ICMPV6_PARAMPROB && code == ICMPV6_UNK_OPTION && ( opt_unrec ( skb , info ) ) ) ) return ; saddr = NULL ; } addr_type = ipv6_addr_type ( & hdr -> saddr ) ; if ( __ipv6_addr_needs_scope_id ( addr_type ) ) iif = skb -> dev -> ifindex ; <S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> iif = l3mdev_master_ifindex ( skb_dst ( skb ) -> dev ) ; <S2SV_EndBug> if ( ( addr_type == IPV6_ADDR_ANY ) || ( addr_type & IPV6_ADDR_MULTICAST ) ) { net_dbg_ratelimited ( "icmp6_send:<S2SV_blank>addr_any/mcast<S2SV_blank>source<S2SV_blank>[%pI6c<S2SV_blank>><S2SV_blank>%pI6c]\\n" , & hdr -> saddr , & hdr -> daddr ) ; return ; } if ( is_ineligible ( skb ) ) { net_dbg_ratelimited ( "icmp6_send:<S2SV_blank>no<S2SV_blank>reply<S2SV_blank>to<S2SV_blank>icmp<S2SV_blank>error<S2SV_blank>[%pI6c<S2SV_blank>><S2SV_blank>%pI6c]\\n" , & hdr -> saddr , & hdr -> daddr ) ; return ; } mip6_addr_swap ( skb ) ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = IPPROTO_ICMPV6 ; fl6 . daddr = hdr -> saddr ; if ( force_saddr ) saddr = force_saddr ; if ( saddr ) fl6 . saddr = * saddr ; fl6 . flowi6_mark = mark ; fl6 . flowi6_oif = iif ; fl6 . fl6_icmp_type = type ; fl6 . fl6_icmp_code = code ; security_skb_classify_flow ( skb , flowi6_to_flowi ( & fl6 ) ) ; sk = icmpv6_xmit_lock ( net ) ; if ( ! sk ) return ; sk -> sk_mark = mark ; np = inet6_sk ( sk ) ; if ( ! icmpv6_xrlim_allow ( sk , type , & fl6 ) ) goto out ; tmp_hdr . icmp6_type = type ; tmp_hdr . icmp6_code = code ; tmp_hdr . icmp6_cksum = 0 ; tmp_hdr . icmp6_pointer = htonl ( info ) ; if ( ! fl6 . flowi6_oif && ipv6_addr_is_multicast ( & fl6 . daddr ) ) fl6 . flowi6_oif = np -> mcast_oif ; else if ( ! fl6 . flowi6_oif ) fl6 . flowi6_oif = np -> ucast_oif ; ipc6 . tclass = np -> tclass ; fl6 . flowlabel = ip6_make_flowinfo ( ipc6 . tclass , fl6 . flowlabel ) ; dst = icmpv6_route_lookup ( net , skb , sk , & fl6 ) ; if ( IS_ERR ( dst ) ) goto out ; ipc6 . hlimit = ip6_sk_dst_hoplimit ( np , & fl6 , dst ) ; ipc6 . dontfrag = np -> dontfrag ; ipc6 . opt = NULL ; msg . skb = skb ; msg . offset = skb_network_offset ( skb ) ; msg . type = type ; len = skb -> len - msg . offset ; len = min_t ( unsigned int , len , IPV6_MIN_MTU - sizeof ( struct ipv6hdr ) - sizeof ( struct icmp6hdr ) ) ; if ( len < 0 ) { net_dbg_ratelimited ( "icmp:<S2SV_blank>len<S2SV_blank>problem<S2SV_blank>[%pI6c<S2SV_blank>><S2SV_blank>%pI6c]\\n" , & hdr -> saddr , & hdr -> daddr ) ; goto out_dst_release ; } rcu_read_lock ( ) ; idev = __in6_dev_get ( skb -> dev ) ; err = ip6_append_data ( sk , icmpv6_getfrag , & msg , len + sizeof ( struct icmp6hdr ) , sizeof ( struct icmp6hdr ) , & ipc6 , & fl6 , ( struct rt6_info * ) dst , MSG_DONTWAIT , & sockc_unused ) ; if ( err ) { ICMP6_INC_STATS ( net , idev , ICMP6_MIB_OUTERRORS ) ; ip6_flush_pending_frames ( sk ) ; } else { err = icmpv6_push_pending_frames ( sk , & fl6 , & tmp_hdr , len + sizeof ( struct icmp6hdr ) ) ; } rcu_read_unlock ( ) ; out_dst_release : dst_release ( dst ) ; out : icmpv6_xmit_unlock ( sk ) ; }
<S2SV_StartBug> int ntlm_read_message_fields_buffer ( wStream * s , NTLM_MESSAGE_FIELDS * fields ) <S2SV_EndBug> { if ( fields -> Len > 0 ) { <S2SV_StartBug> if ( ( fields -> BufferOffset + fields -> Len ) > Stream_Length ( s ) ) <S2SV_EndBug> return - 1 ; fields -> Buffer = ( PBYTE ) malloc ( fields -> Len ) ; if ( ! fields -> Buffer ) return - 1 ; Stream_SetPosition ( s , fields -> BufferOffset ) ; Stream_Read ( s , fields -> Buffer , fields -> Len ) ; } return 1 ; }
static void vrrp_tfile_end_handler ( void ) { vrrp_tracked_file_t * tfile = LIST_TAIL_DATA ( vrrp_data -> vrrp_track_files ) ; struct stat statb ; FILE * tf ; int ret ; if ( ! tfile -> file_path ) { report_config_error ( CONFIG_GENERAL_ERROR , "No<S2SV_blank>file<S2SV_blank>set<S2SV_blank>for<S2SV_blank>track_file<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>removing" , tfile -> fname ) ; free_list_element ( vrrp_data -> vrrp_track_files , vrrp_data -> vrrp_track_files -> tail ) ; return ; } if ( track_file_init == TRACK_FILE_NO_INIT ) return ; ret = stat ( tfile -> file_path , & statb ) ; if ( ! ret ) { if ( track_file_init == TRACK_FILE_CREATE ) { return ; } if ( ( statb . st_mode & S_IFMT ) != S_IFREG ) { report_config_error ( CONFIG_GENERAL_ERROR , "Cannot<S2SV_blank>initialise<S2SV_blank>track<S2SV_blank>file<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>it<S2SV_blank>is<S2SV_blank>not<S2SV_blank>a<S2SV_blank>regular<S2SV_blank>file" , tfile -> fname ) ; return ; } if ( reload ) return ; } if ( ! __test_bit ( CONFIG_TEST_BIT , & debug ) ) { <S2SV_StartBug> if ( ( tf = fopen ( tfile -> file_path , "w" ) ) ) { <S2SV_EndBug> fprintf ( tf , "%d\\n" , track_file_init_value ) ; fclose ( tf ) ; } else report_config_error ( CONFIG_GENERAL_ERROR , "Unable<S2SV_blank>to<S2SV_blank>initialise<S2SV_blank>track<S2SV_blank>file<S2SV_blank>%s" , tfile -> fname ) ; } }
int <S2SV_StartBug> rad_get_vendor_attr ( u_int32_t * vendor , const void * * data , size_t * len ) <S2SV_EndBug> { struct vendor_attribute * attr ; <S2SV_StartBug> attr = ( struct vendor_attribute * ) * data ; <S2SV_EndBug> <S2SV_StartBug> * vendor = ntohl ( attr -> vendor_value ) ; <S2SV_EndBug> * data = attr -> attrib_data ; * len = attr -> attrib_len - 2 ; <S2SV_StartBug> return ( attr -> attrib_type ) ; <S2SV_EndBug> }
static int snd_timer_user_tselect ( struct file * file , struct snd_timer_select __user * _tselect ) { struct snd_timer_user * tu ; struct snd_timer_select tselect ; char str [ 32 ] ; int err = 0 ; tu = file -> private_data ; <S2SV_StartBug> mutex_lock ( & tu -> tread_sem ) ; <S2SV_EndBug> if ( tu -> timeri ) { snd_timer_close ( tu -> timeri ) ; tu -> timeri = NULL ; } if ( copy_from_user ( & tselect , _tselect , sizeof ( tselect ) ) ) { err = - EFAULT ; goto __err ; } sprintf ( str , "application<S2SV_blank>%i" , current -> pid ) ; if ( tselect . id . dev_class != SNDRV_TIMER_CLASS_SLAVE ) tselect . id . dev_sclass = SNDRV_TIMER_SCLASS_APPLICATION ; err = snd_timer_open ( & tu -> timeri , str , & tselect . id , current -> pid ) ; if ( err < 0 ) goto __err ; kfree ( tu -> queue ) ; tu -> queue = NULL ; kfree ( tu -> tqueue ) ; tu -> tqueue = NULL ; if ( tu -> tread ) { tu -> tqueue = kmalloc ( tu -> queue_size * sizeof ( struct snd_timer_tread ) , GFP_KERNEL ) ; if ( tu -> tqueue == NULL ) err = - ENOMEM ; } else { tu -> queue = kmalloc ( tu -> queue_size * sizeof ( struct snd_timer_read ) , GFP_KERNEL ) ; if ( tu -> queue == NULL ) err = - ENOMEM ; } if ( err < 0 ) { snd_timer_close ( tu -> timeri ) ; tu -> timeri = NULL ; } else { tu -> timeri -> flags |= SNDRV_TIMER_IFLG_FAST ; tu -> timeri -> callback = tu -> tread ? snd_timer_user_tinterrupt : snd_timer_user_interrupt ; tu -> timeri -> ccallback = snd_timer_user_ccallback ; tu -> timeri -> callback_data = ( void * ) tu ; } __err : <S2SV_StartBug> mutex_unlock ( & tu -> tread_sem ) ; <S2SV_EndBug> return err ; }
static krb5_int32 prep_reprocess_req ( krb5_kdc_req * request , krb5_principal * krbtgt_princ ) { krb5_error_code retval = KRB5KRB_AP_ERR_BADMATCH ; char * * realms , * * cpp , * temp_buf = NULL ; krb5_data * comp1 = NULL , * comp2 = NULL ; char * comp1_str = NULL ; if ( isflagset ( request -> kdc_options , KDC_OPT_CANONICALIZE ) && ! isflagset ( request -> kdc_options , KDC_OPT_ENC_TKT_IN_SKEY ) && krb5_princ_size ( kdc_context , request -> server ) == 2 ) { comp1 = krb5_princ_component ( kdc_context , request -> server , 0 ) ; comp2 = krb5_princ_component ( kdc_context , request -> server , 1 ) ; comp1_str = calloc ( 1 , comp1 -> length + 1 ) ; if ( ! comp1_str ) { retval = ENOMEM ; goto cleanup ; } <S2SV_StartBug> strlcpy ( comp1_str , comp1 -> data , comp1 -> length + 1 ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( krb5_princ_type ( kdc_context , request -> server ) == KRB5_NT_SRV_HST || <S2SV_EndBug> krb5_princ_type ( kdc_context , request -> server ) == KRB5_NT_SRV_INST || ( krb5_princ_type ( kdc_context , request -> server ) == KRB5_NT_UNKNOWN && kdc_active_realm -> realm_host_based_services != NULL && ( krb5_match_config_pattern ( kdc_active_realm -> realm_host_based_services , comp1_str ) == TRUE || krb5_match_config_pattern ( kdc_active_realm -> realm_host_based_services , KRB5_CONF_ASTERISK ) == TRUE ) ) ) && ( kdc_active_realm -> realm_no_host_referral == NULL || ( krb5_match_config_pattern ( kdc_active_realm -> realm_no_host_referral , KRB5_CONF_ASTERISK ) == FALSE && krb5_match_config_pattern ( kdc_active_realm -> realm_no_host_referral , comp1_str ) == FALSE ) ) ) { if ( memchr ( comp2 -> data , '.' , comp2 -> length ) == NULL ) goto cleanup ; temp_buf = calloc ( 1 , comp2 -> length + 1 ) ; if ( ! temp_buf ) { retval = ENOMEM ; goto cleanup ; } <S2SV_StartBug> strlcpy ( temp_buf , comp2 -> data , comp2 -> length + 1 ) ; <S2SV_EndBug> retval = krb5int_get_domain_realm_mapping ( kdc_context , temp_buf , & realms ) ; free ( temp_buf ) ; if ( retval ) { kdc_err ( kdc_context , retval , "unable<S2SV_blank>to<S2SV_blank>find<S2SV_blank>realm<S2SV_blank>of<S2SV_blank>host" ) ; goto cleanup ; } if ( realms == 0 ) { retval = KRB5KRB_AP_ERR_BADMATCH ; goto cleanup ; } if ( realms [ 0 ] == 0 || data_eq_string ( request -> server -> realm , realms [ 0 ] ) ) { free ( realms [ 0 ] ) ; free ( realms ) ; retval = KRB5KRB_AP_ERR_BADMATCH ; goto cleanup ; } retval = krb5_build_principal ( kdc_context , krbtgt_princ , ( * request -> server ) . realm . length , ( * request -> server ) . realm . data , "krbtgt" , realms [ 0 ] , ( char * ) 0 ) ; for ( cpp = realms ; * cpp ; cpp ++ ) free ( * cpp ) ; } } cleanup : free ( comp1_str ) ; return retval ; }
static Image * ReadDCMImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { char explicit_vr [ MagickPathExtent ] , implicit_vr [ MagickPathExtent ] , magick [ MagickPathExtent ] , photometric [ MagickPathExtent ] ; DCMStreamInfo * stream_info ; Image * image ; int * bluemap , datum , * greenmap , * graymap , index , * redmap ; MagickBooleanType explicit_file , explicit_retry , polarity , sequence , use_explicit ; MagickOffsetType offset ; Quantum * scale ; register ssize_t i , x ; register Quantum * q ; register unsigned char * p ; size_t bits_allocated , bytes_per_pixel , colors , depth , height , length , mask , max_value , number_scenes , quantum , samples_per_pixel , signed_data , significant_bits , status , width , window_width ; ssize_t count , rescale_intercept , rescale_slope , scene , window_center , y ; unsigned char * data ; unsigned short group , element ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , "%s" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image -> depth = 8UL ; image -> endian = LSBEndian ; stream_info = ( DCMStreamInfo * ) AcquireMagickMemory ( sizeof ( * stream_info ) ) ; if ( stream_info == ( DCMStreamInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; ( void ) ResetMagickMemory ( stream_info , 0 , sizeof ( * stream_info ) ) ; count = ReadBlob ( image , 128 , ( unsigned char * ) magick ) ; if ( count != 128 ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; count = ReadBlob ( image , 4 , ( unsigned char * ) magick ) ; if ( ( count != 4 ) || ( LocaleNCompare ( magick , "DICM" , 4 ) != 0 ) ) { offset = SeekBlob ( image , 0L , SEEK_SET ) ; if ( offset < 0 ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; } ( void ) CopyMagickString ( photometric , "MONOCHROME1<S2SV_blank>" , MagickPathExtent ) ; bits_allocated = 8 ; bytes_per_pixel = 1 ; polarity = MagickFalse ; data = ( unsigned char * ) NULL ; depth = 8 ; element = 0 ; explicit_vr [ 2 ] = '\\0' ; explicit_file = MagickFalse ; colors = 0 ; redmap = ( int * ) NULL ; greenmap = ( int * ) NULL ; bluemap = ( int * ) NULL ; graymap = ( int * ) NULL ; height = 0 ; max_value = 255UL ; mask = 0xffff ; number_scenes = 1 ; rescale_intercept = 0 ; rescale_slope = 1 ; samples_per_pixel = 1 ; scale = ( Quantum * ) NULL ; sequence = MagickFalse ; signed_data = ( ~ 0UL ) ; significant_bits = 0 ; use_explicit = MagickFalse ; explicit_retry = MagickFalse ; width = 0 ; window_center = 0 ; window_width = 0 ; for ( group = 0 ; ( group != 0x7FE0 ) || ( element != 0x0010 ) || ( sequence != MagickFalse ) ; ) { image -> offset = ( ssize_t ) TellBlob ( image ) ; group = ReadBlobLSBShort ( image ) ; element = ReadBlobLSBShort ( image ) ; if ( ( group != 0x0002 ) && ( image -> endian == MSBEndian ) ) { group = ( unsigned short ) ( ( group << 8 ) | ( ( group >> 8 ) & 0xFF ) ) ; element = ( unsigned short ) ( ( element << 8 ) | ( ( element >> 8 ) & 0xFF ) ) ; } quantum = 0 ; for ( i = 0 ; dicom_info [ i ] . group < 0xffff ; i ++ ) if ( ( group == dicom_info [ i ] . group ) && ( element == dicom_info [ i ] . element ) ) break ; ( void ) CopyMagickString ( implicit_vr , dicom_info [ i ] . vr , MagickPathExtent ) ; count = ReadBlob ( image , 2 , ( unsigned char * ) explicit_vr ) ; if ( count != 2 ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; if ( ( explicit_file == MagickFalse ) && ( group != 0x0002 ) ) explicit_file = ( isupper ( ( unsigned char ) * explicit_vr ) != MagickFalse ) && ( isupper ( ( unsigned char ) * ( explicit_vr + 1 ) ) != MagickFalse ) ? MagickTrue : MagickFalse ; use_explicit = ( ( group == 0x0002 ) && ( explicit_retry == MagickFalse ) ) || ( explicit_file != MagickFalse ) ? MagickTrue : MagickFalse ; if ( ( use_explicit != MagickFalse ) && ( strncmp ( implicit_vr , "xs" , 2 ) == 0 ) ) ( void ) CopyMagickString ( implicit_vr , explicit_vr , MagickPathExtent ) ; if ( ( use_explicit == MagickFalse ) || ( strncmp ( implicit_vr , "!!" , 2 ) == 0 ) ) { offset = SeekBlob ( image , ( MagickOffsetType ) - 2 , SEEK_CUR ) ; if ( offset < 0 ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; quantum = 4 ; } else { quantum = 2 ; if ( ( strncmp ( explicit_vr , "OB" , 2 ) == 0 ) || ( strncmp ( explicit_vr , "UN" , 2 ) == 0 ) || ( strncmp ( explicit_vr , "OW" , 2 ) == 0 ) || ( strncmp ( explicit_vr , "SQ" , 2 ) == 0 ) ) { ( void ) ReadBlobLSBShort ( image ) ; quantum = 4 ; } } datum = 0 ; if ( quantum == 4 ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedLong ( image ) ; else datum = ReadBlobSignedLong ( image ) ; } else if ( quantum == 2 ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedShort ( image ) ; else datum = ReadBlobSignedShort ( image ) ; } quantum = 0 ; length = 1 ; if ( datum != 0 ) { if ( ( strncmp ( implicit_vr , "SS" , 2 ) == 0 ) || ( strncmp ( implicit_vr , "US" , 2 ) == 0 ) ) quantum = 2 ; else if ( ( strncmp ( implicit_vr , "UL" , 2 ) == 0 ) || ( strncmp ( implicit_vr , "SL" , 2 ) == 0 ) || ( strncmp ( implicit_vr , "FL" , 2 ) == 0 ) ) quantum = 4 ; else if ( strncmp ( implicit_vr , "FD" , 2 ) != 0 ) quantum = 1 ; else quantum = 8 ; if ( datum != ~ 0 ) length = ( size_t ) datum / quantum ; else { quantum = 0 ; length = 0 ; } } if ( image_info -> verbose != MagickFalse ) { if ( use_explicit == MagickFalse ) explicit_vr [ 0 ] = '\\0' ; for ( i = 0 ; dicom_info [ i ] . description != ( char * ) NULL ; i ++ ) if ( ( group == dicom_info [ i ] . group ) && ( element == dicom_info [ i ] . element ) ) break ; ( void ) FormatLocaleFile ( stdout , "0x%04lX<S2SV_blank>%4ld<S2SV_blank>%s-%s<S2SV_blank>(0x%04lx,0x%04lx)" , ( unsigned long ) image -> offset , ( long ) length , implicit_vr , explicit_vr , ( unsigned long ) group , ( unsigned long ) element ) ; if ( dicom_info [ i ] . description != ( char * ) NULL ) ( void ) FormatLocaleFile ( stdout , "<S2SV_blank>%s" , dicom_info [ i ] . description ) ; ( void ) FormatLocaleFile ( stdout , ":<S2SV_blank>" ) ; } if ( ( sequence == MagickFalse ) && ( group == 0x7FE0 ) && ( element == 0x0010 ) ) { if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , "\\n" ) ; break ; } data = ( unsigned char * ) NULL ; if ( ( length == 1 ) && ( quantum == 1 ) ) datum = ReadBlobByte ( image ) ; else if ( ( length == 1 ) && ( quantum == 2 ) ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedShort ( image ) ; else datum = ReadBlobSignedShort ( image ) ; } else if ( ( length == 1 ) && ( quantum == 4 ) ) { if ( group == 0x0002 ) datum = ReadBlobLSBSignedLong ( image ) ; else datum = ReadBlobSignedLong ( image ) ; } else if ( ( quantum != 0 ) && ( length != 0 ) ) { if ( ~ length >= 1 ) data = ( unsigned char * ) AcquireQuantumMemory ( length + 1 , quantum * sizeof ( * data ) ) ; if ( data == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; count = ReadBlob ( image , ( size_t ) quantum * length , data ) ; if ( count != ( ssize_t ) ( quantum * length ) ) { if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , "count=%d<S2SV_blank>quantum=%d<S2SV_blank>" "length=%d<S2SV_blank>group=%d\\n" , ( int ) count , ( int ) quantum , ( int ) length , ( int ) group ) ; ThrowReaderException ( CorruptImageError , "InsufficientImageDataInFile" ) ; } data [ length * quantum ] = '\\0' ; } else if ( ( unsigned int ) datum == 0xFFFFFFFFU ) { sequence = MagickTrue ; continue ; } if ( ( unsigned int ) ( ( group << 16 ) | element ) == 0xFFFEE0DD ) { if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; sequence = MagickFalse ; continue ; } if ( sequence != MagickFalse ) { if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; continue ; } switch ( group ) { case 0x0002 : { switch ( element ) { case 0x0010 : { char transfer_syntax [ MagickPathExtent ] ; if ( ( datum == 0 ) && ( explicit_retry == MagickFalse ) ) { explicit_retry = MagickTrue ; ( void ) SeekBlob ( image , ( MagickOffsetType ) 0 , SEEK_SET ) ; group = 0 ; element = 0 ; if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , "Corrupted<S2SV_blank>image<S2SV_blank>-<S2SV_blank>trying<S2SV_blank>explicit<S2SV_blank>format\\n" ) ; break ; } * transfer_syntax = '\\0' ; if ( data != ( unsigned char * ) NULL ) ( void ) CopyMagickString ( transfer_syntax , ( char * ) data , MagickPathExtent ) ; if ( image_info -> verbose != MagickFalse ) ( void ) FormatLocaleFile ( stdout , "transfer_syntax=%s\\n" , ( const char * ) transfer_syntax ) ; if ( strncmp ( transfer_syntax , "1.2.840.10008.1.2" , 17 ) == 0 ) { int count , subtype , type ; type = 1 ; subtype = 0 ; if ( strlen ( transfer_syntax ) > 17 ) { count = sscanf ( transfer_syntax + 17 , ".%d.%d" , & type , & subtype ) ; if ( count < 1 ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; } switch ( type ) { case 1 : { image -> endian = LSBEndian ; break ; } case 2 : { image -> endian = MSBEndian ; break ; } case 4 : { if ( ( subtype >= 80 ) && ( subtype <= 81 ) ) image -> compression = JPEGCompression ; else if ( ( subtype >= 90 ) && ( subtype <= 93 ) ) image -> compression = JPEG2000Compression ; else image -> compression = JPEGCompression ; break ; } case 5 : { image -> compression = RLECompression ; break ; } } } break ; } default : break ; } break ; } case 0x0028 : { switch ( element ) { case 0x0002 : { samples_per_pixel = ( size_t ) datum ; break ; } case 0x0004 : { <S2SV_StartBug> for ( i = 0 ; i < ( ssize_t ) MagickMin ( length , MagickPathExtent - 1 ) ; i ++ ) <S2SV_EndBug> photometric [ i ] = ( char ) data [ i ] ; photometric [ i ] = '\\0' ; polarity = LocaleCompare ( photometric , "MONOCHROME1<S2SV_blank>" ) == 0 ? MagickTrue : MagickFalse ; break ; } case 0x0006 : { if ( datum == 1 ) image -> interlace = PlaneInterlace ; break ; } case 0x0008 : <S2SV_StartBug> { <S2SV_EndBug> number_scenes = StringToUnsignedLong ( ( char * ) data ) ; break ; } case 0x0010 : { height = ( size_t ) datum ; break ; } case 0x0011 : { width = ( size_t ) datum ; break ; } case 0x0100 : { bits_allocated = ( size_t ) datum ; bytes_per_pixel = 1 ; if ( datum > 8 ) bytes_per_pixel = 2 ; depth = bits_allocated ; if ( depth > 32 ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; max_value = ( 1UL << bits_allocated ) - 1 ; break ; } case 0x0101 : { significant_bits = ( size_t ) datum ; bytes_per_pixel = 1 ; if ( significant_bits > 8 ) bytes_per_pixel = 2 ; depth = significant_bits ; if ( depth > 32 ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; max_value = ( 1UL << significant_bits ) - 1 ; mask = ( size_t ) GetQuantumRange ( significant_bits ) ; break ; } case 0x0102 : { break ; } case 0x0103 : { signed_data = ( size_t ) datum ; break ; } case 0x1050 : { if ( data != ( unsigned char * ) NULL ) window_center = ( ssize_t ) StringToLong ( ( char * ) data ) ; break ; } case 0x1051 : { if ( data != ( unsigned char * ) NULL ) window_width = StringToUnsignedLong ( ( char * ) data ) ; break ; } case 0x1052 : { if ( data != ( unsigned char * ) NULL ) rescale_intercept = ( ssize_t ) StringToLong ( ( char * ) data ) ; break ; } case 0x1053 : { if ( data != ( unsigned char * ) NULL ) rescale_slope = ( ssize_t ) StringToLong ( ( char * ) data ) ; break ; } case 0x1200 : case 0x3006 : { if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / bytes_per_pixel ) ; datum = ( int ) colors ; graymap = ( int * ) AcquireQuantumMemory ( ( size_t ) colors , sizeof ( * graymap ) ) ; if ( graymap == ( int * ) NULL ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) if ( bytes_per_pixel == 1 ) graymap [ i ] = ( int ) data [ i ] ; else graymap [ i ] = ( int ) ( ( short * ) data ) [ i ] ; break ; } case 0x1201 : { unsigned short index ; if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / 2 ) ; datum = ( int ) colors ; redmap = ( int * ) AcquireQuantumMemory ( ( size_t ) colors , sizeof ( * redmap ) ) ; if ( redmap == ( int * ) NULL ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; p = data ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { if ( image -> endian == MSBEndian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ; else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ; redmap [ i ] = ( int ) index ; p += 2 ; } break ; } case 0x1202 : { unsigned short index ; if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / 2 ) ; datum = ( int ) colors ; greenmap = ( int * ) AcquireQuantumMemory ( ( size_t ) colors , sizeof ( * greenmap ) ) ; if ( greenmap == ( int * ) NULL ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; p = data ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { if ( image -> endian == MSBEndian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ; else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ; greenmap [ i ] = ( int ) index ; p += 2 ; } break ; } case 0x1203 : { unsigned short index ; if ( data == ( unsigned char * ) NULL ) break ; colors = ( size_t ) ( length / 2 ) ; datum = ( int ) colors ; bluemap = ( int * ) AcquireQuantumMemory ( ( size_t ) colors , sizeof ( * bluemap ) ) ; if ( bluemap == ( int * ) NULL ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; p = data ; for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { if ( image -> endian == MSBEndian ) index = ( unsigned short ) ( ( * p << 8 ) | * ( p + 1 ) ) ; else index = ( unsigned short ) ( * p | ( * ( p + 1 ) << 8 ) ) ; bluemap [ i ] = ( int ) index ; p += 2 ; } break ; } default : break ; } break ; } case 0x2050 : { switch ( element ) { case 0x0020 : { if ( ( data != ( unsigned char * ) NULL ) && ( strncmp ( ( char * ) data , "INVERSE" , 7 ) == 0 ) ) polarity = MagickTrue ; break ; } default : break ; } break ; } default : break ; } if ( data != ( unsigned char * ) NULL ) { char * attribute ; for ( i = 0 ; dicom_info [ i ] . description != ( char * ) NULL ; i ++ ) if ( ( group == dicom_info [ i ] . group ) && ( element == dicom_info [ i ] . element ) ) break ; if ( dicom_info [ i ] . description != ( char * ) NULL ) { attribute = AcquireString ( "dcm:" ) ; ( void ) ConcatenateString ( & attribute , dicom_info [ i ] . description ) ; for ( i = 0 ; i < ( ssize_t ) MagickMax ( length , 4 ) ; i ++ ) if ( isprint ( ( int ) data [ i ] ) == MagickFalse ) break ; if ( ( i == ( ssize_t ) length ) || ( length > 4 ) ) { ( void ) SubstituteString ( & attribute , "<S2SV_blank>" , "" ) ; ( void ) SetImageProperty ( image , attribute , ( char * ) data , exception ) ; } attribute = DestroyString ( attribute ) ; } } if ( image_info -> verbose != MagickFalse ) { if ( data == ( unsigned char * ) NULL ) ( void ) FormatLocaleFile ( stdout , "%d\\n" , datum ) ; else { for ( i = 0 ; i < ( ssize_t ) MagickMax ( length , 4 ) ; i ++ ) if ( isprint ( ( int ) data [ i ] ) == MagickFalse ) break ; if ( ( i != ( ssize_t ) length ) && ( length <= 4 ) ) { ssize_t j ; datum = 0 ; for ( j = ( ssize_t ) length - 1 ; j >= 0 ; j -- ) datum = ( 256 * datum + data [ j ] ) ; ( void ) FormatLocaleFile ( stdout , "%d" , datum ) ; } else for ( i = 0 ; i < ( ssize_t ) length ; i ++ ) if ( isprint ( ( int ) data [ i ] ) != MagickFalse ) ( void ) FormatLocaleFile ( stdout , "%c" , data [ i ] ) ; else ( void ) FormatLocaleFile ( stdout , "%c" , '.' ) ; ( void ) FormatLocaleFile ( stdout , "\\n" ) ; } } if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , "UnexpectedEndOfFile" , image -> filename ) ; break ; } } if ( ( width == 0 ) || ( height == 0 ) ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; image -> columns = ( size_t ) width ; image -> rows = ( size_t ) height ; if ( signed_data == 0xffff ) signed_data = ( size_t ) ( significant_bits == 16 ? 1 : 0 ) ; if ( ( image -> compression == JPEGCompression ) || ( image -> compression == JPEG2000Compression ) ) { Image * images ; ImageInfo * read_info ; int c ; size_t length ; unsigned int tag ; for ( i = 0 ; i < ( ssize_t ) stream_info -> remaining ; i ++ ) ( void ) ReadBlobByte ( image ) ; tag = ( ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ; ( void ) tag ; length = ( size_t ) ReadBlobLSBLong ( image ) ; stream_info -> offset_count = length >> 2 ; if ( stream_info -> offset_count != 0 ) { MagickOffsetType offset ; stream_info -> offsets = ( ssize_t * ) AcquireQuantumMemory ( stream_info -> offset_count , sizeof ( * stream_info -> offsets ) ) ; if ( stream_info -> offsets == ( ssize_t * ) NULL ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; offset = TellBlob ( image ) ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] += offset ; } read_info = CloneImageInfo ( image_info ) ; SetImageInfoBlob ( read_info , ( void * ) NULL , 0 ) ; images = NewImageList ( ) ; for ( scene = 0 ; scene < ( ssize_t ) number_scenes ; scene ++ ) { char filename [ MagickPathExtent ] ; const char * property ; FILE * file ; Image * jpeg_image ; int unique_file ; unsigned int tag ; tag = ( ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ; length = ( size_t ) ReadBlobLSBLong ( image ) ; if ( tag == 0xFFFEE0DD ) break ; if ( tag != 0xFFFEE000 ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; file = ( FILE * ) NULL ; unique_file = AcquireUniqueFileResource ( filename ) ; if ( unique_file != - 1 ) file = fdopen ( unique_file , "wb" ) ; if ( file == ( FILE * ) NULL ) { ( void ) RelinquishUniqueFileResource ( filename ) ; ThrowFileException ( exception , FileOpenError , "UnableToCreateTemporaryFile" , filename ) ; break ; } for ( ; length != 0 ; length -- ) { c = ReadBlobByte ( image ) ; if ( c == EOF ) { ThrowFileException ( exception , CorruptImageError , "UnexpectedEndOfFile" , image -> filename ) ; break ; } ( void ) fputc ( c , file ) ; } ( void ) fclose ( file ) ; ( void ) FormatLocaleString ( read_info -> filename , MagickPathExtent , "jpeg:%s" , filename ) ; if ( image -> compression == JPEG2000Compression ) ( void ) FormatLocaleString ( read_info -> filename , MagickPathExtent , "j2k:%s" , filename ) ; jpeg_image = ReadImage ( read_info , exception ) ; if ( jpeg_image != ( Image * ) NULL ) { ResetImagePropertyIterator ( image ) ; property = GetNextImageProperty ( image ) ; while ( property != ( const char * ) NULL ) { ( void ) SetImageProperty ( jpeg_image , property , GetImageProperty ( image , property , exception ) , exception ) ; property = GetNextImageProperty ( image ) ; } AppendImageToList ( & images , jpeg_image ) ; } ( void ) RelinquishUniqueFileResource ( filename ) ; } read_info = DestroyImageInfo ( read_info ) ; image = DestroyImage ( image ) ; return ( GetFirstImageInList ( images ) ) ; } if ( depth != ( 1UL * MAGICKCORE_QUANTUM_DEPTH ) ) { QuantumAny range ; size_t length ; length = ( size_t ) ( GetQuantumRange ( depth ) + 1 ) ; scale = ( Quantum * ) AcquireQuantumMemory ( length , sizeof ( * scale ) ) ; if ( scale == ( Quantum * ) NULL ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; range = GetQuantumRange ( depth ) ; <S2SV_StartBug> for ( i = 0 ; i < ( ssize_t ) ( GetQuantumRange ( depth ) + 1 ) ; i ++ ) <S2SV_EndBug> scale [ i ] = ScaleAnyToQuantum ( ( size_t ) i , range ) ; } if ( image -> compression == RLECompression ) { size_t length ; unsigned int tag ; for ( i = 0 ; i < ( ssize_t ) stream_info -> remaining ; i ++ ) ( void ) ReadBlobByte ( image ) ; tag = ( ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ; ( void ) tag ; length = ( size_t ) ReadBlobLSBLong ( image ) ; stream_info -> offset_count = length >> 2 ; if ( stream_info -> offset_count != 0 ) { MagickOffsetType offset ; stream_info -> offsets = ( ssize_t * ) AcquireQuantumMemory ( stream_info -> offset_count , sizeof ( * stream_info -> offsets ) ) ; if ( stream_info -> offsets == ( ssize_t * ) NULL ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; offset = TellBlob ( image ) ; for ( i = 0 ; i < ( ssize_t ) stream_info -> offset_count ; i ++ ) stream_info -> offsets [ i ] += offset ; } } for ( scene = 0 ; scene < ( ssize_t ) number_scenes ; scene ++ ) { if ( image_info -> ping != MagickFalse ) break ; image -> columns = ( size_t ) width ; image -> rows = ( size_t ) height ; image -> depth = depth ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) break ; image -> colorspace = RGBColorspace ; if ( ( image -> colormap == ( PixelInfo * ) NULL ) && ( samples_per_pixel == 1 ) ) { size_t one ; one = 1 ; if ( colors == 0 ) colors = one << depth ; if ( AcquireImageColormap ( image , one << depth , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; if ( redmap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = redmap [ i ] ; if ( ( scale != ( Quantum * ) NULL ) && ( index <= ( int ) max_value ) ) index = ( int ) scale [ index ] ; image -> colormap [ i ] . red = ( MagickRealType ) index ; } if ( greenmap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = greenmap [ i ] ; if ( ( scale != ( Quantum * ) NULL ) && ( index <= ( int ) max_value ) ) index = ( int ) scale [ index ] ; image -> colormap [ i ] . green = ( MagickRealType ) index ; } if ( bluemap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = bluemap [ i ] ; if ( ( scale != ( Quantum * ) NULL ) && ( index <= ( int ) max_value ) ) index = ( int ) scale [ index ] ; image -> colormap [ i ] . blue = ( MagickRealType ) index ; } if ( graymap != ( int * ) NULL ) for ( i = 0 ; i < ( ssize_t ) colors ; i ++ ) { index = graymap [ i ] ; if ( ( scale != ( Quantum * ) NULL ) && ( index <= ( int ) max_value ) ) index = ( int ) scale [ index ] ; image -> colormap [ i ] . red = ( MagickRealType ) index ; image -> colormap [ i ] . green = ( MagickRealType ) index ; image -> colormap [ i ] . blue = ( MagickRealType ) index ; } } if ( image -> compression == RLECompression ) { unsigned int tag ; for ( i = 0 ; i < ( ssize_t ) stream_info -> remaining ; i ++ ) ( void ) ReadBlobByte ( image ) ; tag = ( ReadBlobLSBShort ( image ) << 16 ) | ReadBlobLSBShort ( image ) ; stream_info -> remaining = ( size_t ) ReadBlobLSBLong ( image ) ; if ( ( tag != 0xFFFEE000 ) || ( stream_info -> remaining <= 64 ) || ( EOFBlob ( image ) != MagickFalse ) ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; stream_info -> count = 0 ; stream_info -> segment_count = ReadBlobLSBLong ( image ) ; if ( stream_info -> segment_count > 1 ) { bytes_per_pixel = 1 ; depth = 8 ; } for ( i = 0 ; i < 15 ; i ++ ) stream_info -> segments [ i ] = ( ssize_t ) ReadBlobLSBSignedLong ( image ) ; stream_info -> remaining -= 64 ; } if ( ( samples_per_pixel > 1 ) && ( image -> interlace == PlaneInterlace ) ) { for ( i = 0 ; i < ( ssize_t ) samples_per_pixel ; i ++ ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = GetAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { switch ( ( int ) i ) { case 0 : { SetPixelRed ( image , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) , q ) ; break ; } case 1 : { SetPixelGreen ( image , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) , q ) ; break ; } case 2 : { SetPixelBlue ( image , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) , q ) ; break ; } case 3 : { SetPixelAlpha ( image , ScaleCharToQuantum ( ( unsigned char ) ReadDCMByte ( stream_info , image ) ) , q ) ; break ; } default : break ; } q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } } else { const char * option ; int byte ; PixelPacket pixel ; byte = 0 ; i = 0 ; if ( ( window_center != 0 ) && ( window_width == 0 ) ) window_width = ( size_t ) window_center ; option = GetImageOption ( image_info , "dcm:display-range" ) ; if ( option != ( const char * ) NULL ) { if ( LocaleCompare ( option , "reset" ) == 0 ) window_width = 0 ; } ( void ) ResetMagickMemory ( & pixel , 0 , sizeof ( pixel ) ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( samples_per_pixel == 1 ) { int pixel_value ; if ( bytes_per_pixel == 1 ) pixel_value = polarity != MagickFalse ? ( ( int ) max_value - ReadDCMByte ( stream_info , image ) ) : ReadDCMByte ( stream_info , image ) ; else if ( ( bits_allocated != 12 ) || ( significant_bits != 12 ) ) { if ( signed_data ) pixel_value = ReadDCMSignedShort ( stream_info , image ) ; else pixel_value = ReadDCMShort ( stream_info , image ) ; if ( polarity != MagickFalse ) pixel_value = ( int ) max_value - pixel_value ; } else { if ( ( i & 0x01 ) != 0 ) pixel_value = ( ReadDCMByte ( stream_info , image ) << 8 ) | byte ; else { pixel_value = ReadDCMSignedShort ( stream_info , image ) ; byte = ( int ) ( pixel_value & 0x0f ) ; pixel_value >>= 4 ; } i ++ ; } index = ( pixel_value * rescale_slope ) + rescale_intercept ; if ( window_width == 0 ) { if ( signed_data == 1 ) index -= 32767 ; } else { ssize_t window_max , window_min ; window_min = ( ssize_t ) ceil ( ( double ) window_center - ( window_width - 1.0 ) / 2.0 - 0.5 ) ; window_max = ( ssize_t ) floor ( ( double ) window_center + ( window_width - 1.0 ) / 2.0 + 0.5 ) ; if ( ( ssize_t ) index <= window_min ) index = 0 ; else if ( ( ssize_t ) index > window_max ) index = ( int ) max_value ; else index = ( int ) ( max_value * ( ( ( index - window_center - 0.5 ) / ( window_width - 1 ) ) + 0.5 ) ) ; } index &= mask ; index = ( int ) ConstrainColormapIndex ( image , ( size_t ) index , exception ) ; SetPixelIndex ( image , ( Quantum ) index , q ) ; pixel . red = ( unsigned int ) image -> colormap [ index ] . red ; pixel . green = ( unsigned int ) image -> colormap [ index ] . green ; pixel . blue = ( unsigned int ) image -> colormap [ index ] . blue ; } else { if ( bytes_per_pixel == 1 ) { pixel . red = ( unsigned int ) ReadDCMByte ( stream_info , image ) ; pixel . green = ( unsigned int ) ReadDCMByte ( stream_info , image ) ; pixel . blue = ( unsigned int ) ReadDCMByte ( stream_info , image ) ; } else { pixel . red = ReadDCMShort ( stream_info , image ) ; pixel . green = ReadDCMShort ( stream_info , image ) ; pixel . blue = ReadDCMShort ( stream_info , image ) ; } pixel . red &= mask ; pixel . green &= mask ; pixel . blue &= mask ; if ( scale != ( Quantum * ) NULL ) { <S2SV_StartBug> pixel . red = scale [ pixel . red ] ; <S2SV_EndBug> <S2SV_StartBug> pixel . green = scale [ pixel . green ] ; <S2SV_EndBug> <S2SV_StartBug> pixel . blue = scale [ pixel . blue ] ; <S2SV_EndBug> } } SetPixelRed ( image , ( Quantum ) pixel . red , q ) ; SetPixelGreen ( image , ( Quantum ) pixel . green , q ) ; SetPixelBlue ( image , ( Quantum ) pixel . blue , q ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } if ( stream_info -> segment_count > 1 ) for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( samples_per_pixel == 1 ) { int pixel_value ; if ( bytes_per_pixel == 1 ) pixel_value = polarity != MagickFalse ? ( ( int ) max_value - ReadDCMByte ( stream_info , image ) ) : ReadDCMByte ( stream_info , image ) ; else if ( ( bits_allocated != 12 ) || ( significant_bits != 12 ) ) { pixel_value = ( int ) ( polarity != MagickFalse ? ( max_value - ReadDCMShort ( stream_info , image ) ) : ReadDCMShort ( stream_info , image ) ) ; if ( signed_data == 1 ) pixel_value = ( ( signed short ) pixel_value ) ; } else { if ( ( i & 0x01 ) != 0 ) pixel_value = ( ReadDCMByte ( stream_info , image ) << 8 ) | byte ; else { pixel_value = ReadDCMShort ( stream_info , image ) ; byte = ( int ) ( pixel_value & 0x0f ) ; pixel_value >>= 4 ; } i ++ ; } index = ( pixel_value * rescale_slope ) + rescale_intercept ; if ( window_width == 0 ) { if ( signed_data == 1 ) index -= 32767 ; } else { ssize_t window_max , window_min ; window_min = ( ssize_t ) ceil ( ( double ) window_center - ( window_width - 1.0 ) / 2.0 - 0.5 ) ; window_max = ( ssize_t ) floor ( ( double ) window_center + ( window_width - 1.0 ) / 2.0 + 0.5 ) ; if ( ( ssize_t ) index <= window_min ) index = 0 ; else if ( ( ssize_t ) index > window_max ) index = ( int ) max_value ; else index = ( int ) ( max_value * ( ( ( index - window_center - 0.5 ) / ( window_width - 1 ) ) + 0.5 ) ) ; } index &= mask ; index = ( int ) ConstrainColormapIndex ( image , ( size_t ) index , exception ) ; SetPixelIndex ( image , ( Quantum ) ( ( ( size_t ) GetPixelIndex ( image , q ) ) | ( ( ( size_t ) index ) << 8 ) ) , q ) ; pixel . red = ( unsigned int ) image -> colormap [ index ] . red ; pixel . green = ( unsigned int ) image -> colormap [ index ] . green ; pixel . blue = ( unsigned int ) image -> colormap [ index ] . blue ; } else { if ( bytes_per_pixel == 1 ) { pixel . red = ( unsigned int ) ReadDCMByte ( stream_info , image ) ; pixel . green = ( unsigned int ) ReadDCMByte ( stream_info , image ) ; pixel . blue = ( unsigned int ) ReadDCMByte ( stream_info , image ) ; } else { pixel . red = ReadDCMShort ( stream_info , image ) ; pixel . green = ReadDCMShort ( stream_info , image ) ; pixel . blue = ReadDCMShort ( stream_info , image ) ; } pixel . red &= mask ; pixel . green &= mask ; pixel . blue &= mask ; if ( scale != ( Quantum * ) NULL ) { pixel . red = scale [ pixel . red ] ; pixel . green = scale [ pixel . green ] ; pixel . blue = scale [ pixel . blue ] ; } } SetPixelRed ( image , ( Quantum ) ( ( ( size_t ) GetPixelRed ( image , q ) ) | ( ( ( size_t ) pixel . red ) << 8 ) ) , q ) ; SetPixelGreen ( image , ( Quantum ) ( ( ( size_t ) GetPixelGreen ( image , q ) ) | ( ( ( size_t ) pixel . green ) << 8 ) ) , q ) ; SetPixelBlue ( image , ( Quantum ) ( ( ( size_t ) GetPixelBlue ( image , q ) ) | ( ( ( size_t ) pixel . blue ) << 8 ) ) , q ) ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } if ( SetImageGray ( image , exception ) != MagickFalse ) ( void ) SetImageColorspace ( image , GRAYColorspace , exception ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , "UnexpectedEndOfFile" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; if ( scene < ( ssize_t ) ( number_scenes - 1 ) ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; stream_info = ( DCMStreamInfo * ) RelinquishMagickMemory ( stream_info ) ; if ( scale != ( Quantum * ) NULL ) scale = ( Quantum * ) RelinquishMagickMemory ( scale ) ; if ( graymap != ( int * ) NULL ) graymap = ( int * ) RelinquishMagickMemory ( graymap ) ; if ( bluemap != ( int * ) NULL ) bluemap = ( int * ) RelinquishMagickMemory ( bluemap ) ; if ( greenmap != ( int * ) NULL ) greenmap = ( int * ) RelinquishMagickMemory ( greenmap ) ; if ( redmap != ( int * ) NULL ) redmap = ( int * ) RelinquishMagickMemory ( redmap ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
ssize_t cdf_read_short_sector ( const cdf_stream_t * sst , void * buf , size_t offs , size_t len , const cdf_header_t * h , cdf_secid_t id ) { <S2SV_StartBug> size_t ss = CDF_SEC_SIZE ( h ) ; <S2SV_EndBug> size_t pos = CDF_SHORT_SEC_POS ( h , id ) ; assert ( ss == len ) ; <S2SV_StartBug> if ( pos > ss * sst -> sst_len ) { <S2SV_EndBug> DPRINTF ( ( "Out<S2SV_blank>of<S2SV_blank>bounds<S2SV_blank>read<S2SV_blank>%" SIZE_T_FORMAT "u<S2SV_blank>><S2SV_blank>%" SIZE_T_FORMAT "u\\n" , <S2SV_StartBug> pos , ss * sst -> sst_len ) ) ; <S2SV_EndBug> return - 1 ; } ( void ) memcpy ( ( ( char * ) buf ) + offs , ( ( const char * ) sst -> sst_tab ) + pos , len ) ; return len ; }
GF_Err stbl_GetSampleInfos ( GF_SampleTableBox * stbl , u32 sampleNumber , u64 * offset , u32 * chunkNumber , u32 * descIndex , GF_StscEntry * * out_ent ) { GF_Err e ; u32 i , k , offsetInChunk , size , chunk_num ; GF_ChunkOffsetBox * stco ; GF_ChunkLargeOffsetBox * co64 ; GF_StscEntry * ent ; ( * offset ) = 0 ; ( * chunkNumber ) = ( * descIndex ) = 0 ; if ( out_ent ) ( * out_ent ) = NULL ; if ( ! stbl || ! sampleNumber ) return GF_BAD_PARAM ; if ( ! stbl -> ChunkOffset || ! stbl -> SampleToChunk || ! stbl -> SampleSize ) return GF_ISOM_INVALID_FILE ; if ( stbl -> SampleSize && stbl -> SampleToChunk -> nb_entries == stbl -> SampleSize -> sampleCount ) { ent = & stbl -> SampleToChunk -> entries [ sampleNumber - 1 ] ; if ( ! ent ) return GF_BAD_PARAM ; ( * descIndex ) = ent -> sampleDescriptionIndex ; ( * chunkNumber ) = sampleNumber ; if ( out_ent ) * out_ent = ent ; if ( stbl -> ChunkOffset -> type == GF_ISOM_BOX_TYPE_STCO ) { stco = ( GF_ChunkOffsetBox * ) stbl -> ChunkOffset ; if ( ! stco -> offsets ) return GF_ISOM_INVALID_FILE ; <S2SV_StartBug> ( * offset ) = ( u64 ) stco -> offsets [ sampleNumber - 1 ] ; <S2SV_EndBug> } else { co64 = ( GF_ChunkLargeOffsetBox * ) stbl -> ChunkOffset ; <S2SV_StartBug> if ( ! co64 -> offsets ) return GF_ISOM_INVALID_FILE ; <S2SV_EndBug> ( * offset ) = co64 -> offsets [ sampleNumber - 1 ] ; } return GF_OK ; } if ( stbl -> SampleToChunk -> firstSampleInCurrentChunk && ( stbl -> SampleToChunk -> firstSampleInCurrentChunk <= sampleNumber ) ) { i = stbl -> SampleToChunk -> currentIndex ; ent = & stbl -> SampleToChunk -> entries [ stbl -> SampleToChunk -> currentIndex ] ; GetGhostNum ( ent , i , stbl -> SampleToChunk -> nb_entries , stbl ) ; k = stbl -> SampleToChunk -> currentChunk ; } else { i = 0 ; stbl -> SampleToChunk -> currentIndex = 0 ; stbl -> SampleToChunk -> currentChunk = 1 ; stbl -> SampleToChunk -> ghostNumber = 1 ; stbl -> SampleToChunk -> firstSampleInCurrentChunk = 1 ; ent = & stbl -> SampleToChunk -> entries [ 0 ] ; GetGhostNum ( ent , 0 , stbl -> SampleToChunk -> nb_entries , stbl ) ; k = stbl -> SampleToChunk -> currentChunk ; } for ( ; i < stbl -> SampleToChunk -> nb_entries ; i ++ ) { assert ( stbl -> SampleToChunk -> firstSampleInCurrentChunk <= sampleNumber ) ; if ( k > stbl -> SampleToChunk -> ghostNumber ) { return GF_ISOM_INVALID_FILE ; } u32 max_chunks_in_entry = stbl -> SampleToChunk -> ghostNumber - k ; u32 nb_chunks_for_sample = sampleNumber - stbl -> SampleToChunk -> firstSampleInCurrentChunk ; if ( ent -> samplesPerChunk ) nb_chunks_for_sample /= ent -> samplesPerChunk ; if ( ( nb_chunks_for_sample <= max_chunks_in_entry ) && ( stbl -> SampleToChunk -> firstSampleInCurrentChunk + ( nb_chunks_for_sample + 1 ) * ent -> samplesPerChunk > sampleNumber ) ) { stbl -> SampleToChunk -> firstSampleInCurrentChunk += nb_chunks_for_sample * ent -> samplesPerChunk ; stbl -> SampleToChunk -> currentChunk += nb_chunks_for_sample ; goto sample_found ; } max_chunks_in_entry += 1 ; stbl -> SampleToChunk -> firstSampleInCurrentChunk += max_chunks_in_entry * ent -> samplesPerChunk ; stbl -> SampleToChunk -> currentChunk += max_chunks_in_entry ; if ( i + 1 != stbl -> SampleToChunk -> nb_entries ) { ent = & stbl -> SampleToChunk -> entries [ i + 1 ] ; GetGhostNum ( ent , i + 1 , stbl -> SampleToChunk -> nb_entries , stbl ) ; stbl -> SampleToChunk -> currentIndex = i + 1 ; stbl -> SampleToChunk -> currentChunk = 1 ; k = 1 ; } } return GF_ISOM_INVALID_FILE ; sample_found : ( * descIndex ) = ent -> sampleDescriptionIndex ; ( * chunkNumber ) = chunk_num = ent -> firstChunk + stbl -> SampleToChunk -> currentChunk - 1 ; if ( out_ent ) * out_ent = ent ; if ( ! * chunkNumber ) return GF_ISOM_INVALID_FILE ; offsetInChunk = 0 ; if ( stbl -> SampleSize && stbl -> SampleSize -> sampleSize ) { u32 diff = sampleNumber - stbl -> SampleToChunk -> firstSampleInCurrentChunk ; offsetInChunk += diff * stbl -> SampleSize -> sampleSize ; } else if ( ( stbl -> r_last_chunk_num == chunk_num ) && ( stbl -> r_last_sample_num == sampleNumber ) ) { offsetInChunk = stbl -> r_last_offset_in_chunk ; } else if ( ( stbl -> r_last_chunk_num == chunk_num ) && ( stbl -> r_last_sample_num + 1 == sampleNumber ) ) { e = stbl_GetSampleSize ( stbl -> SampleSize , stbl -> r_last_sample_num , & size ) ; if ( e ) return e ; stbl -> r_last_offset_in_chunk += size ; stbl -> r_last_sample_num = sampleNumber ; offsetInChunk = stbl -> r_last_offset_in_chunk ; } else { for ( i = stbl -> SampleToChunk -> firstSampleInCurrentChunk ; i < sampleNumber ; i ++ ) { e = stbl_GetSampleSize ( stbl -> SampleSize , i , & size ) ; if ( e ) return e ; offsetInChunk += size ; } stbl -> r_last_chunk_num = chunk_num ; stbl -> r_last_sample_num = sampleNumber ; stbl -> r_last_offset_in_chunk = offsetInChunk ; } if ( stbl -> ChunkOffset -> type == GF_ISOM_BOX_TYPE_STCO ) { stco = ( GF_ChunkOffsetBox * ) stbl -> ChunkOffset ; if ( stco -> nb_entries < ( * chunkNumber ) ) return GF_ISOM_INVALID_FILE ; ( * offset ) = ( u64 ) stco -> offsets [ ( * chunkNumber ) - 1 ] + ( u64 ) offsetInChunk ; } else { co64 = ( GF_ChunkLargeOffsetBox * ) stbl -> ChunkOffset ; if ( co64 -> nb_entries < ( * chunkNumber ) ) return GF_ISOM_INVALID_FILE ; ( * offset ) = co64 -> offsets [ ( * chunkNumber ) - 1 ] + ( u64 ) offsetInChunk ; } return GF_OK ; }
static struct sock * sctp_v6_create_accept_sk ( struct sock * sk , struct sctp_association * asoc , bool kern ) { struct sock * newsk ; struct ipv6_pinfo * newnp , * np = inet6_sk ( sk ) ; struct sctp6_sock * newsctp6sk ; struct ipv6_txoptions * opt ; newsk = sk_alloc ( sock_net ( sk ) , PF_INET6 , GFP_KERNEL , sk -> sk_prot , kern ) ; if ( ! newsk ) goto out ; sock_init_data ( NULL , newsk ) ; sctp_copy_sock ( newsk , sk , asoc ) ; sock_reset_flag ( sk , SOCK_ZAPPED ) ; newsctp6sk = ( struct sctp6_sock * ) newsk ; inet_sk ( newsk ) -> pinet6 = & newsctp6sk -> inet6 ; sctp_sk ( newsk ) -> v4mapped = sctp_sk ( sk ) -> v4mapped ; newnp = inet6_sk ( newsk ) ; <S2SV_StartBug> memcpy ( newnp , np , sizeof ( struct ipv6_pinfo ) ) ; <S2SV_EndBug> rcu_read_lock ( ) ; opt = rcu_dereference ( np -> opt ) ; if ( opt ) opt = ipv6_dup_options ( newsk , opt ) ; RCU_INIT_POINTER ( newnp -> opt , opt ) ; rcu_read_unlock ( ) ; sctp_v6_to_sk_daddr ( & asoc -> peer . primary_addr , newsk ) ; newsk -> sk_v6_rcv_saddr = sk -> sk_v6_rcv_saddr ; sk_refcnt_debug_inc ( newsk ) ; if ( newsk -> sk_prot -> init ( newsk ) ) { sk_common_release ( newsk ) ; newsk = NULL ; } out : return newsk ; }
void vp8_setup_key_frame ( VP8_COMP * cpi ) { vp8_default_coef_probs ( & cpi -> common ) ; <S2SV_StartBug> vpx_memcpy ( cpi -> common . fc . mvc , vp8_default_mv_context , sizeof ( vp8_default_mv_context ) ) ; <S2SV_EndBug> { int flag [ 2 ] = { 1 , 1 } ; vp8_build_component_cost_table ( cpi -> mb . mvcost , ( const MV_CONTEXT * ) cpi -> common . fc . mvc , flag ) ; } <S2SV_StartBug> vpx_memcpy ( & cpi -> lfc_a , & cpi -> common . fc , sizeof ( cpi -> common . fc ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( & cpi -> lfc_g , & cpi -> common . fc , sizeof ( cpi -> common . fc ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( & cpi -> lfc_n , & cpi -> common . fc , sizeof ( cpi -> common . fc ) ) ; <S2SV_EndBug> cpi -> common . filter_level = cpi -> common . base_qindex * 3 / 8 ; if ( cpi -> auto_gold ) cpi -> frames_till_gf_update_due = cpi -> baseline_gf_interval ; else cpi -> frames_till_gf_update_due = DEFAULT_GF_INTERVAL ; cpi -> common . refresh_golden_frame = 1 ; cpi -> common . refresh_alt_ref_frame = 1 ; }
static int sd2_parse_rsrc_fork ( SF_PRIVATE * psf ) { SD2_RSRC rsrc ; int k , marker , error = 0 ; psf_use_rsrc ( psf , SF_TRUE ) ; memset ( & rsrc , 0 , sizeof ( rsrc ) ) ; rsrc . rsrc_len = psf_get_filelen ( psf ) ; psf_log_printf ( psf , "Resource<S2SV_blank>length<S2SV_blank>:<S2SV_blank>%d<S2SV_blank>(0x%04X)\\n" , rsrc . rsrc_len , rsrc . rsrc_len ) ; if ( rsrc . rsrc_len > SIGNED_SIZEOF ( psf -> header ) ) { rsrc . rsrc_data = calloc ( 1 , rsrc . rsrc_len ) ; rsrc . need_to_free_rsrc_data = SF_TRUE ; } else { rsrc . rsrc_data = psf -> header ; rsrc . need_to_free_rsrc_data = SF_FALSE ; } ; psf_fread ( rsrc . rsrc_data , rsrc . rsrc_len , 1 , psf ) ; psf -> headindex = psf -> headend = rsrc . rsrc_len ; rsrc . data_offset = read_rsrc_int ( & rsrc , 0 ) ; rsrc . map_offset = read_rsrc_int ( & rsrc , 4 ) ; rsrc . data_length = read_rsrc_int ( & rsrc , 8 ) ; rsrc . map_length = read_rsrc_int ( & rsrc , 12 ) ; if ( rsrc . data_offset == 0x51607 && rsrc . map_offset == 0x20000 ) { psf_log_printf ( psf , "Trying<S2SV_blank>offset<S2SV_blank>of<S2SV_blank>0x52<S2SV_blank>bytes.\\n" ) ; rsrc . data_offset = read_rsrc_int ( & rsrc , 0x52 + 0 ) + 0x52 ; rsrc . map_offset = read_rsrc_int ( & rsrc , 0x52 + 4 ) + 0x52 ; rsrc . data_length = read_rsrc_int ( & rsrc , 0x52 + 8 ) ; rsrc . map_length = read_rsrc_int ( & rsrc , 0x52 + 12 ) ; } ; psf_log_printf ( psf , "<S2SV_blank><S2SV_blank>data<S2SV_blank>offset<S2SV_blank>:<S2SV_blank>0x%04X\\n<S2SV_blank><S2SV_blank>map<S2SV_blank><S2SV_blank>offset<S2SV_blank>:<S2SV_blank>0x%04X\\n" "<S2SV_blank><S2SV_blank>data<S2SV_blank>length<S2SV_blank>:<S2SV_blank>0x%04X\\n<S2SV_blank><S2SV_blank>map<S2SV_blank><S2SV_blank>length<S2SV_blank>:<S2SV_blank>0x%04X\\n" , rsrc . data_offset , rsrc . map_offset , rsrc . data_length , rsrc . map_length ) ; if ( rsrc . data_offset > rsrc . rsrc_len ) { psf_log_printf ( psf , "Error<S2SV_blank>:<S2SV_blank>rsrc.data_offset<S2SV_blank>(%d,<S2SV_blank>0x%x)<S2SV_blank>><S2SV_blank>len\\n" , rsrc . data_offset , rsrc . data_offset ) ; error = SFE_SD2_BAD_DATA_OFFSET ; goto parse_rsrc_fork_cleanup ; } ; if ( rsrc . map_offset > rsrc . rsrc_len ) { psf_log_printf ( psf , "Error<S2SV_blank>:<S2SV_blank>rsrc.map_offset<S2SV_blank>><S2SV_blank>len\\n" ) ; error = SFE_SD2_BAD_MAP_OFFSET ; goto parse_rsrc_fork_cleanup ; } ; if ( rsrc . data_length > rsrc . rsrc_len ) { psf_log_printf ( psf , "Error<S2SV_blank>:<S2SV_blank>rsrc.data_length<S2SV_blank>><S2SV_blank>len\\n" ) ; error = SFE_SD2_BAD_DATA_LENGTH ; goto parse_rsrc_fork_cleanup ; } ; if ( rsrc . map_length > rsrc . rsrc_len ) { psf_log_printf ( psf , "Error<S2SV_blank>:<S2SV_blank>rsrc.map_length<S2SV_blank>><S2SV_blank>len\\n" ) ; error = SFE_SD2_BAD_MAP_LENGTH ; goto parse_rsrc_fork_cleanup ; } ; if ( rsrc . data_offset + rsrc . data_length != rsrc . map_offset || rsrc . map_offset + rsrc . map_length != rsrc . rsrc_len ) { psf_log_printf ( psf , "Error<S2SV_blank>:<S2SV_blank>This<S2SV_blank>does<S2SV_blank>not<S2SV_blank>look<S2SV_blank>like<S2SV_blank>a<S2SV_blank>MacOSX<S2SV_blank>resource<S2SV_blank>fork.\\n" ) ; error = SFE_SD2_BAD_RSRC ; goto parse_rsrc_fork_cleanup ; } ; if ( rsrc . map_offset + 28 >= rsrc . rsrc_len ) { psf_log_printf ( psf , "Bad<S2SV_blank>map<S2SV_blank>offset<S2SV_blank>(%d<S2SV_blank>+<S2SV_blank>28<S2SV_blank>><S2SV_blank>%d).\\n" , rsrc . map_offset , rsrc . rsrc_len ) ; error = SFE_SD2_BAD_RSRC ; goto parse_rsrc_fork_cleanup ; } ; rsrc . string_offset = rsrc . map_offset + read_rsrc_short ( & rsrc , rsrc . map_offset + 26 ) ; if ( rsrc . string_offset > rsrc . rsrc_len ) { psf_log_printf ( psf , "Bad<S2SV_blank>string<S2SV_blank>offset<S2SV_blank>(%d).\\n" , rsrc . string_offset ) ; error = SFE_SD2_BAD_RSRC ; goto parse_rsrc_fork_cleanup ; } ; rsrc . type_offset = rsrc . map_offset + 30 ; <S2SV_StartBug> rsrc . type_count = read_rsrc_short ( & rsrc , rsrc . map_offset + 28 ) + 1 ; <S2SV_EndBug> if ( rsrc . type_count < 1 ) { psf_log_printf ( psf , "Bad<S2SV_blank>type<S2SV_blank>count.\\n" ) ; error = SFE_SD2_BAD_RSRC ; goto parse_rsrc_fork_cleanup ; } ; rsrc . item_offset = rsrc . type_offset + rsrc . type_count * 8 ; if ( rsrc . item_offset < 0 || rsrc . item_offset > rsrc . rsrc_len ) { psf_log_printf ( psf , "Bad<S2SV_blank>item<S2SV_blank>offset<S2SV_blank>(%d).\\n" , rsrc . item_offset ) ; error = SFE_SD2_BAD_RSRC ; goto parse_rsrc_fork_cleanup ; } ; rsrc . str_index = - 1 ; for ( k = 0 ; k < rsrc . type_count ; k ++ ) <S2SV_StartBug> { marker = read_rsrc_marker ( & rsrc , rsrc . type_offset + k * 8 ) ; <S2SV_EndBug> if ( marker == STR_MARKER ) { rsrc . str_index = k ; rsrc . str_count = read_rsrc_short ( & rsrc , rsrc . type_offset + k * 8 + 4 ) + 1 ; error = parse_str_rsrc ( psf , & rsrc ) ; goto parse_rsrc_fork_cleanup ; } ; } ; psf_log_printf ( psf , "No<S2SV_blank>\'STR<S2SV_blank>\'<S2SV_blank>resource.\\n" ) ; error = SFE_SD2_BAD_RSRC ; parse_rsrc_fork_cleanup : psf_use_rsrc ( psf , SF_FALSE ) ; if ( rsrc . need_to_free_rsrc_data ) free ( rsrc . rsrc_data ) ; return error ; }
static int kvm_vm_ioctl_set_pit2 ( struct kvm * kvm , struct kvm_pit_state2 * ps ) { <S2SV_StartBug> int start = 0 ; <S2SV_EndBug> u32 prev_legacy , cur_legacy ; mutex_lock ( & kvm -> arch . vpit -> pit_state . lock ) ; prev_legacy = kvm -> arch . vpit -> pit_state . flags & KVM_PIT_FLAGS_HPET_LEGACY ; cur_legacy = ps -> flags & KVM_PIT_FLAGS_HPET_LEGACY ; if ( ! prev_legacy && cur_legacy ) start = 1 ; memcpy ( & kvm -> arch . vpit -> pit_state . channels , & ps -> channels , sizeof ( kvm -> arch . vpit -> pit_state . channels ) ) ; kvm -> arch . vpit -> pit_state . flags = ps -> flags ; <S2SV_StartBug> kvm_pit_load_count ( kvm , 0 , kvm -> arch . vpit -> pit_state . channels [ 0 ] . count , start ) ; <S2SV_EndBug> mutex_unlock ( & kvm -> arch . vpit -> pit_state . lock ) ; return 0 ; }
static void t1_check_unusual_charstring ( void ) { char * p = strstr ( t1_line_array , charstringname ) + strlen ( charstringname ) ; int i ; if ( sscanf ( p , "%i" , & i ) != 1 ) { strcpy ( t1_buf_array , t1_line_array ) ; * ( strend ( t1_buf_array ) - 1 ) = '<S2SV_blank>' ; t1_getline ( ) ; <S2SV_StartBug> strcat ( t1_buf_array , t1_line_array ) ; <S2SV_EndBug> strcpy ( t1_line_array , t1_buf_array ) ; t1_line_ptr = eol ( t1_line_array ) ; } }
int ssl3_accept ( SSL * s ) { BUF_MEM * buf ; unsigned long alg_k , Time = ( unsigned long ) time ( NULL ) ; void ( * cb ) ( const SSL * ssl , int type , int val ) = NULL ; int ret = - 1 ; int new_state , state , skip = 0 ; RAND_add ( & Time , sizeof ( Time ) , 0 ) ; ERR_clear_error ( ) ; clear_sys_error ( ) ; if ( s -> info_callback != NULL ) cb = s -> info_callback ; else if ( s -> ctx -> info_callback != NULL ) cb = s -> ctx -> info_callback ; s -> in_handshake ++ ; if ( ! SSL_in_init ( s ) || SSL_in_before ( s ) ) SSL_clear ( s ) ; if ( s -> cert == NULL ) { SSLerr ( SSL_F_SSL3_ACCEPT , SSL_R_NO_CERTIFICATE_SET ) ; return ( - 1 ) ; } # ifndef OPENSSL_NO_HEARTBEATS if ( s -> tlsext_hb_pending ) { s -> tlsext_hb_pending = 0 ; s -> tlsext_hb_seq ++ ; } # endif for ( ; ; ) { state = s -> state ; switch ( s -> state ) { case SSL_ST_RENEGOTIATE : s -> renegotiate = 1 ; case SSL_ST_BEFORE : case SSL_ST_ACCEPT : case SSL_ST_BEFORE | SSL_ST_ACCEPT : case SSL_ST_OK | SSL_ST_ACCEPT : s -> server = 1 ; if ( cb != NULL ) cb ( s , SSL_CB_HANDSHAKE_START , 1 ) ; if ( ( s -> version >> 8 ) != 3 ) { SSLerr ( SSL_F_SSL3_ACCEPT , ERR_R_INTERNAL_ERROR ) ; return - 1 ; } if ( ! ssl_security ( s , SSL_SECOP_VERSION , 0 , s -> version , NULL ) ) { SSLerr ( SSL_F_SSL3_ACCEPT , SSL_R_VERSION_TOO_LOW ) ; return - 1 ; } s -> type = SSL_ST_ACCEPT ; if ( s -> init_buf == NULL ) { if ( ( buf = BUF_MEM_new ( ) ) == NULL ) { ret = - 1 ; goto end ; } if ( ! BUF_MEM_grow ( buf , SSL3_RT_MAX_PLAIN_LENGTH ) ) { BUF_MEM_free ( buf ) ; ret = - 1 ; goto end ; } s -> init_buf = buf ; } if ( ! ssl3_setup_buffers ( s ) ) { ret = - 1 ; goto end ; } s -> init_num = 0 ; s -> s3 -> flags &= ~ TLS1_FLAGS_SKIP_CERT_VERIFY ; s -> s3 -> flags &= ~ SSL3_FLAGS_CCS_OK ; s -> s3 -> change_cipher_spec = 0 ; if ( s -> state != SSL_ST_RENEGOTIATE ) { if ( ! ssl_init_wbio_buffer ( s , 1 ) ) { ret = - 1 ; goto end ; } ssl3_init_finished_mac ( s ) ; s -> state = SSL3_ST_SR_CLNT_HELLO_A ; s -> ctx -> stats . sess_accept ++ ; } else if ( ! s -> s3 -> send_connection_binding && ! ( s -> options & SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION ) ) { SSLerr ( SSL_F_SSL3_ACCEPT , SSL_R_UNSAFE_LEGACY_RENEGOTIATION_DISABLED ) ; ssl3_send_alert ( s , SSL3_AL_FATAL , SSL_AD_HANDSHAKE_FAILURE ) ; ret = - 1 ; goto end ; } else { s -> ctx -> stats . sess_accept_renegotiate ++ ; s -> state = SSL3_ST_SW_HELLO_REQ_A ; } break ; case SSL3_ST_SW_HELLO_REQ_A : case SSL3_ST_SW_HELLO_REQ_B : s -> shutdown = 0 ; ret = ssl3_send_hello_request ( s ) ; if ( ret <= 0 ) goto end ; s -> s3 -> tmp . next_state = SSL3_ST_SW_HELLO_REQ_C ; s -> state = SSL3_ST_SW_FLUSH ; s -> init_num = 0 ; ssl3_init_finished_mac ( s ) ; break ; case SSL3_ST_SW_HELLO_REQ_C : s -> state = SSL_ST_OK ; break ; case SSL3_ST_SR_CLNT_HELLO_A : case SSL3_ST_SR_CLNT_HELLO_B : case SSL3_ST_SR_CLNT_HELLO_C : ret = ssl3_get_client_hello ( s ) ; if ( ret <= 0 ) goto end ; # ifndef OPENSSL_NO_SRP s -> state = SSL3_ST_SR_CLNT_HELLO_D ; case SSL3_ST_SR_CLNT_HELLO_D : { int al ; if ( ( ret = ssl_check_srp_ext_ClientHello ( s , & al ) ) < 0 ) { s -> rwstate = SSL_X509_LOOKUP ; goto end ; } if ( ret != SSL_ERROR_NONE ) { ssl3_send_alert ( s , SSL3_AL_FATAL , al ) ; if ( al != TLS1_AD_UNKNOWN_PSK_IDENTITY ) SSLerr ( SSL_F_SSL3_ACCEPT , SSL_R_CLIENTHELLO_TLSEXT ) ; ret = SSL_TLSEXT_ERR_ALERT_FATAL ; ret = - 1 ; goto end ; } } # endif s -> renegotiate = 2 ; s -> state = SSL3_ST_SW_SRVR_HELLO_A ; s -> init_num = 0 ; break ; case SSL3_ST_SW_SRVR_HELLO_A : case SSL3_ST_SW_SRVR_HELLO_B : ret = ssl3_send_server_hello ( s ) ; if ( ret <= 0 ) goto end ; # ifndef OPENSSL_NO_TLSEXT if ( s -> hit ) { if ( s -> tlsext_ticket_expected ) s -> state = SSL3_ST_SW_SESSION_TICKET_A ; else s -> state = SSL3_ST_SW_CHANGE_A ; } # else if ( s -> hit ) s -> state = SSL3_ST_SW_CHANGE_A ; # endif else s -> state = SSL3_ST_SW_CERT_A ; s -> init_num = 0 ; break ; case SSL3_ST_SW_CERT_A : case SSL3_ST_SW_CERT_B : if ( ! ( s -> s3 -> tmp . new_cipher -> algorithm_auth & ( SSL_aNULL | SSL_aKRB5 | SSL_aSRP ) ) && ! ( s -> s3 -> tmp . new_cipher -> algorithm_mkey & SSL_kPSK ) ) { ret = ssl3_send_server_certificate ( s ) ; if ( ret <= 0 ) goto end ; # ifndef OPENSSL_NO_TLSEXT if ( s -> tlsext_status_expected ) s -> state = SSL3_ST_SW_CERT_STATUS_A ; else s -> state = SSL3_ST_SW_KEY_EXCH_A ; } else { skip = 1 ; s -> state = SSL3_ST_SW_KEY_EXCH_A ; } # else } else skip = 1 ; s -> state = SSL3_ST_SW_KEY_EXCH_A ; # endif s -> init_num = 0 ; break ; case SSL3_ST_SW_KEY_EXCH_A : case SSL3_ST_SW_KEY_EXCH_B : alg_k = s -> s3 -> tmp . new_cipher -> algorithm_mkey ; <S2SV_StartBug> if ( ( s -> options & SSL_OP_EPHEMERAL_RSA ) <S2SV_EndBug> # ifndef OPENSSL_NO_KRB5 && ! ( alg_k & SSL_kKRB5 ) # endif ) <S2SV_StartBug> s -> s3 -> tmp . use_rsa_tmp = 1 ; <S2SV_EndBug> else s -> s3 -> tmp . use_rsa_tmp = 0 ; if ( s -> s3 -> tmp . use_rsa_tmp # ifndef OPENSSL_NO_PSK || ( ( alg_k & SSL_kPSK ) && s -> ctx -> psk_identity_hint ) # endif # ifndef OPENSSL_NO_SRP || ( alg_k & SSL_kSRP ) # endif || ( alg_k & SSL_kDHE ) || ( alg_k & SSL_kECDHE ) || ( ( alg_k & SSL_kRSA ) && ( s -> cert -> pkeys [ SSL_PKEY_RSA_ENC ] . privatekey == NULL || ( SSL_C_IS_EXPORT ( s -> s3 -> tmp . new_cipher ) && EVP_PKEY_size ( s -> cert -> pkeys [ SSL_PKEY_RSA_ENC ] . privatekey ) * 8 > SSL_C_EXPORT_PKEYLENGTH ( s -> s3 -> tmp . new_cipher ) ) ) ) ) { ret = ssl3_send_server_key_exchange ( s ) ; if ( ret <= 0 ) goto end ; } else skip = 1 ; s -> state = SSL3_ST_SW_CERT_REQ_A ; s -> init_num = 0 ; break ; case SSL3_ST_SW_CERT_REQ_A : case SSL3_ST_SW_CERT_REQ_B : if ( ! ( s -> verify_mode & SSL_VERIFY_PEER ) || ( ( s -> session -> peer != NULL ) && ( s -> verify_mode & SSL_VERIFY_CLIENT_ONCE ) ) || ( ( s -> s3 -> tmp . new_cipher -> algorithm_auth & SSL_aNULL ) && ! ( s -> verify_mode & SSL_VERIFY_FAIL_IF_NO_PEER_CERT ) ) || ( s -> s3 -> tmp . new_cipher -> algorithm_auth & SSL_aKRB5 ) || ( s -> s3 -> tmp . new_cipher -> algorithm_auth & SSL_aSRP ) || ( s -> s3 -> tmp . new_cipher -> algorithm_mkey & SSL_kPSK ) ) { skip = 1 ; s -> s3 -> tmp . cert_request = 0 ; s -> state = SSL3_ST_SW_SRVR_DONE_A ; if ( s -> s3 -> handshake_buffer ) if ( ! ssl3_digest_cached_records ( s ) ) return - 1 ; } else { s -> s3 -> tmp . cert_request = 1 ; ret = ssl3_send_certificate_request ( s ) ; if ( ret <= 0 ) goto end ; # ifndef NETSCAPE_HANG_BUG s -> state = SSL3_ST_SW_SRVR_DONE_A ; # else s -> state = SSL3_ST_SW_FLUSH ; s -> s3 -> tmp . next_state = SSL3_ST_SR_CERT_A ; # endif s -> init_num = 0 ; } break ; case SSL3_ST_SW_SRVR_DONE_A : case SSL3_ST_SW_SRVR_DONE_B : ret = ssl3_send_server_done ( s ) ; if ( ret <= 0 ) goto end ; s -> s3 -> tmp . next_state = SSL3_ST_SR_CERT_A ; s -> state = SSL3_ST_SW_FLUSH ; s -> init_num = 0 ; break ; case SSL3_ST_SW_FLUSH : s -> rwstate = SSL_WRITING ; if ( BIO_flush ( s -> wbio ) <= 0 ) { ret = - 1 ; goto end ; } s -> rwstate = SSL_NOTHING ; s -> state = s -> s3 -> tmp . next_state ; break ; case SSL3_ST_SR_CERT_A : case SSL3_ST_SR_CERT_B : if ( s -> s3 -> tmp . cert_request ) { ret = ssl3_get_client_certificate ( s ) ; if ( ret <= 0 ) goto end ; } s -> init_num = 0 ; s -> state = SSL3_ST_SR_KEY_EXCH_A ; break ; case SSL3_ST_SR_KEY_EXCH_A : case SSL3_ST_SR_KEY_EXCH_B : ret = ssl3_get_client_key_exchange ( s ) ; if ( ret <= 0 ) goto end ; if ( ret == 2 ) { # if defined ( OPENSSL_NO_TLSEXT ) || defined ( OPENSSL_NO_NEXTPROTONEG ) s -> state = SSL3_ST_SR_FINISHED_A ; # else if ( s -> s3 -> next_proto_neg_seen ) s -> state = SSL3_ST_SR_NEXT_PROTO_A ; else s -> state = SSL3_ST_SR_FINISHED_A ; # endif s -> init_num = 0 ; } else if ( SSL_USE_SIGALGS ( s ) ) { s -> state = SSL3_ST_SR_CERT_VRFY_A ; s -> init_num = 0 ; if ( ! s -> session -> peer ) break ; if ( ! s -> s3 -> handshake_buffer ) { SSLerr ( SSL_F_SSL3_ACCEPT , ERR_R_INTERNAL_ERROR ) ; return - 1 ; } s -> s3 -> flags |= TLS1_FLAGS_KEEP_HANDSHAKE ; if ( ! ssl3_digest_cached_records ( s ) ) return - 1 ; } else { int offset = 0 ; int dgst_num ; s -> state = SSL3_ST_SR_CERT_VRFY_A ; s -> init_num = 0 ; if ( s -> s3 -> handshake_buffer ) if ( ! ssl3_digest_cached_records ( s ) ) return - 1 ; for ( dgst_num = 0 ; dgst_num < SSL_MAX_DIGEST ; dgst_num ++ ) if ( s -> s3 -> handshake_dgst [ dgst_num ] ) { int dgst_size ; s -> method -> ssl3_enc -> cert_verify_mac ( s , EVP_MD_CTX_type ( s -> s3 -> handshake_dgst [ dgst_num ] ) , & ( s -> s3 -> tmp . cert_verify_md [ offset ] ) ) ; dgst_size = EVP_MD_CTX_size ( s -> s3 -> handshake_dgst [ dgst_num ] ) ; if ( dgst_size < 0 ) { ret = - 1 ; goto end ; } offset += dgst_size ; } } break ; case SSL3_ST_SR_CERT_VRFY_A : case SSL3_ST_SR_CERT_VRFY_B : if ( ! s -> s3 -> change_cipher_spec ) s -> s3 -> flags |= SSL3_FLAGS_CCS_OK ; ret = ssl3_get_cert_verify ( s ) ; if ( ret <= 0 ) goto end ; # if defined ( OPENSSL_NO_TLSEXT ) || defined ( OPENSSL_NO_NEXTPROTONEG ) s -> state = SSL3_ST_SR_FINISHED_A ; # else if ( s -> s3 -> next_proto_neg_seen ) s -> state = SSL3_ST_SR_NEXT_PROTO_A ; else s -> state = SSL3_ST_SR_FINISHED_A ; # endif s -> init_num = 0 ; break ; # if ! defined ( OPENSSL_NO_TLSEXT ) && ! defined ( OPENSSL_NO_NEXTPROTONEG ) case SSL3_ST_SR_NEXT_PROTO_A : case SSL3_ST_SR_NEXT_PROTO_B : if ( ! s -> s3 -> change_cipher_spec ) s -> s3 -> flags |= SSL3_FLAGS_CCS_OK ; ret = ssl3_get_next_proto ( s ) ; if ( ret <= 0 ) goto end ; s -> init_num = 0 ; s -> state = SSL3_ST_SR_FINISHED_A ; break ; # endif case SSL3_ST_SR_FINISHED_A : case SSL3_ST_SR_FINISHED_B : if ( ! s -> s3 -> change_cipher_spec ) s -> s3 -> flags |= SSL3_FLAGS_CCS_OK ; ret = ssl3_get_finished ( s , SSL3_ST_SR_FINISHED_A , SSL3_ST_SR_FINISHED_B ) ; if ( ret <= 0 ) goto end ; if ( s -> hit ) s -> state = SSL_ST_OK ; # ifndef OPENSSL_NO_TLSEXT else if ( s -> tlsext_ticket_expected ) s -> state = SSL3_ST_SW_SESSION_TICKET_A ; # endif else s -> state = SSL3_ST_SW_CHANGE_A ; s -> init_num = 0 ; break ; # ifndef OPENSSL_NO_TLSEXT case SSL3_ST_SW_SESSION_TICKET_A : case SSL3_ST_SW_SESSION_TICKET_B : ret = ssl3_send_newsession_ticket ( s ) ; if ( ret <= 0 ) goto end ; s -> state = SSL3_ST_SW_CHANGE_A ; s -> init_num = 0 ; break ; case SSL3_ST_SW_CERT_STATUS_A : case SSL3_ST_SW_CERT_STATUS_B : ret = ssl3_send_cert_status ( s ) ; if ( ret <= 0 ) goto end ; s -> state = SSL3_ST_SW_KEY_EXCH_A ; s -> init_num = 0 ; break ; # endif case SSL3_ST_SW_CHANGE_A : case SSL3_ST_SW_CHANGE_B : s -> session -> cipher = s -> s3 -> tmp . new_cipher ; if ( ! s -> method -> ssl3_enc -> setup_key_block ( s ) ) { ret = - 1 ; goto end ; } ret = ssl3_send_change_cipher_spec ( s , SSL3_ST_SW_CHANGE_A , SSL3_ST_SW_CHANGE_B ) ; if ( ret <= 0 ) goto end ; s -> state = SSL3_ST_SW_FINISHED_A ; s -> init_num = 0 ; if ( ! s -> method -> ssl3_enc -> change_cipher_state ( s , SSL3_CHANGE_CIPHER_SERVER_WRITE ) ) { ret = - 1 ; goto end ; } break ; case SSL3_ST_SW_FINISHED_A : case SSL3_ST_SW_FINISHED_B : ret = ssl3_send_finished ( s , SSL3_ST_SW_FINISHED_A , SSL3_ST_SW_FINISHED_B , s -> method -> ssl3_enc -> server_finished_label , s -> method -> ssl3_enc -> server_finished_label_len ) ; if ( ret <= 0 ) goto end ; s -> state = SSL3_ST_SW_FLUSH ; if ( s -> hit ) { # if defined ( OPENSSL_NO_TLSEXT ) || defined ( OPENSSL_NO_NEXTPROTONEG ) s -> s3 -> tmp . next_state = SSL3_ST_SR_FINISHED_A ; # else if ( s -> s3 -> next_proto_neg_seen ) { s -> s3 -> tmp . next_state = SSL3_ST_SR_NEXT_PROTO_A ; } else s -> s3 -> tmp . next_state = SSL3_ST_SR_FINISHED_A ; # endif } else s -> s3 -> tmp . next_state = SSL_ST_OK ; s -> init_num = 0 ; break ; case SSL_ST_OK : ssl3_cleanup_key_block ( s ) ; BUF_MEM_free ( s -> init_buf ) ; s -> init_buf = NULL ; ssl_free_wbio_buffer ( s ) ; s -> init_num = 0 ; if ( s -> renegotiate == 2 ) { s -> renegotiate = 0 ; s -> new_session = 0 ; ssl_update_cache ( s , SSL_SESS_CACHE_SERVER ) ; s -> ctx -> stats . sess_accept_good ++ ; s -> handshake_func = ssl3_accept ; if ( cb != NULL ) cb ( s , SSL_CB_HANDSHAKE_DONE , 1 ) ; } ret = 1 ; goto end ; default : SSLerr ( SSL_F_SSL3_ACCEPT , SSL_R_UNKNOWN_STATE ) ; ret = - 1 ; goto end ; } if ( ! s -> s3 -> tmp . reuse_message && ! skip ) { if ( s -> debug ) { if ( ( ret = BIO_flush ( s -> wbio ) ) <= 0 ) goto end ; } if ( ( cb != NULL ) && ( s -> state != state ) ) { new_state = s -> state ; s -> state = state ; cb ( s , SSL_CB_ACCEPT_LOOP , 1 ) ; s -> state = new_state ; } } skip = 0 ; } end : s -> in_handshake -- ; if ( cb != NULL ) cb ( s , SSL_CB_ACCEPT_EXIT , ret ) ; return ( ret ) ; }
STATIC int xfs_ioctl_setattr ( xfs_inode_t * ip , struct fsxattr * fa , int mask ) { struct xfs_mount * mp = ip -> i_mount ; struct xfs_trans * tp ; unsigned int lock_flags = 0 ; struct xfs_dquot * udqp = NULL ; struct xfs_dquot * pdqp = NULL ; struct xfs_dquot * olddquot = NULL ; int code ; trace_xfs_ioctl_setattr ( ip ) ; if ( mp -> m_flags & XFS_MOUNT_RDONLY ) return XFS_ERROR ( EROFS ) ; if ( XFS_FORCED_SHUTDOWN ( mp ) ) return XFS_ERROR ( EIO ) ; if ( ( mask & FSX_PROJID ) && ( fa -> fsx_projid > ( __uint16_t ) - 1 ) && ! xfs_sb_version_hasprojid32bit ( & ip -> i_mount -> m_sb ) ) return XFS_ERROR ( EINVAL ) ; if ( XFS_IS_QUOTA_ON ( mp ) && ( mask & FSX_PROJID ) ) { code = xfs_qm_vop_dqalloc ( ip , ip -> i_d . di_uid , ip -> i_d . di_gid , fa -> fsx_projid , XFS_QMOPT_PQUOTA , & udqp , NULL , & pdqp ) ; if ( code ) return code ; } tp = xfs_trans_alloc ( mp , XFS_TRANS_SETATTR_NOT_SIZE ) ; code = xfs_trans_reserve ( tp , & M_RES ( mp ) -> tr_ichange , 0 , 0 ) ; if ( code ) goto error_return ; lock_flags = XFS_ILOCK_EXCL ; xfs_ilock ( ip , lock_flags ) ; if ( ! inode_owner_or_capable ( VFS_I ( ip ) ) ) { code = XFS_ERROR ( EPERM ) ; goto error_return ; } if ( mask & FSX_PROJID ) { if ( current_user_ns ( ) != & init_user_ns ) { code = XFS_ERROR ( EINVAL ) ; goto error_return ; } if ( XFS_IS_QUOTA_RUNNING ( mp ) && XFS_IS_PQUOTA_ON ( mp ) && xfs_get_projid ( ip ) != fa -> fsx_projid ) { ASSERT ( tp ) ; code = xfs_qm_vop_chown_reserve ( tp , ip , udqp , NULL , pdqp , capable ( CAP_FOWNER ) ? XFS_QMOPT_FORCE_RES : 0 ) ; if ( code ) goto error_return ; } } if ( mask & FSX_EXTSIZE ) { if ( ip -> i_d . di_nextents && ( ( ip -> i_d . di_extsize << mp -> m_sb . sb_blocklog ) != fa -> fsx_extsize ) ) { code = XFS_ERROR ( EINVAL ) ; goto error_return ; } if ( fa -> fsx_extsize != 0 ) { xfs_extlen_t size ; xfs_fsblock_t extsize_fsb ; extsize_fsb = XFS_B_TO_FSB ( mp , fa -> fsx_extsize ) ; if ( extsize_fsb > MAXEXTLEN ) { code = XFS_ERROR ( EINVAL ) ; goto error_return ; } if ( XFS_IS_REALTIME_INODE ( ip ) || ( ( mask & FSX_XFLAGS ) && ( fa -> fsx_xflags & XFS_XFLAG_REALTIME ) ) ) { size = mp -> m_sb . sb_rextsize << mp -> m_sb . sb_blocklog ; } else { size = mp -> m_sb . sb_blocksize ; if ( extsize_fsb > mp -> m_sb . sb_agblocks / 2 ) { code = XFS_ERROR ( EINVAL ) ; goto error_return ; } } if ( fa -> fsx_extsize % size ) { code = XFS_ERROR ( EINVAL ) ; goto error_return ; } } } if ( mask & FSX_XFLAGS ) { if ( ( ip -> i_d . di_nextents || ip -> i_delayed_blks ) && ( XFS_IS_REALTIME_INODE ( ip ) ) != ( fa -> fsx_xflags & XFS_XFLAG_REALTIME ) ) { code = XFS_ERROR ( EINVAL ) ; goto error_return ; } if ( ( fa -> fsx_xflags & XFS_XFLAG_REALTIME ) ) { if ( ( mp -> m_sb . sb_rblocks == 0 ) || ( mp -> m_sb . sb_rextsize == 0 ) || ( ip -> i_d . di_extsize % mp -> m_sb . sb_rextsize ) ) { code = XFS_ERROR ( EINVAL ) ; goto error_return ; } } if ( ( ip -> i_d . di_flags & ( XFS_DIFLAG_IMMUTABLE | XFS_DIFLAG_APPEND ) || ( fa -> fsx_xflags & ( XFS_XFLAG_IMMUTABLE | XFS_XFLAG_APPEND ) ) ) && ! capable ( CAP_LINUX_IMMUTABLE ) ) { code = XFS_ERROR ( EPERM ) ; goto error_return ; } } xfs_trans_ijoin ( tp , ip , 0 ) ; if ( mask & FSX_PROJID ) { if ( ( ip -> i_d . di_mode & ( S_ISUID | S_ISGID ) ) && <S2SV_StartBug> ! inode_capable ( VFS_I ( ip ) , CAP_FSETID ) ) <S2SV_EndBug> ip -> i_d . di_mode &= ~ ( S_ISUID | S_ISGID ) ; if ( xfs_get_projid ( ip ) != fa -> fsx_projid ) { if ( XFS_IS_QUOTA_RUNNING ( mp ) && XFS_IS_PQUOTA_ON ( mp ) ) { olddquot = xfs_qm_vop_chown ( tp , ip , & ip -> i_pdquot , pdqp ) ; } xfs_set_projid ( ip , fa -> fsx_projid ) ; if ( ip -> i_d . di_version == 1 ) xfs_bump_ino_vers2 ( tp , ip ) ; } } if ( mask & FSX_EXTSIZE ) ip -> i_d . di_extsize = fa -> fsx_extsize >> mp -> m_sb . sb_blocklog ; if ( mask & FSX_XFLAGS ) { xfs_set_diflags ( ip , fa -> fsx_xflags ) ; xfs_diflags_to_linux ( ip ) ; } xfs_trans_ichgtime ( tp , ip , XFS_ICHGTIME_CHG ) ; xfs_trans_log_inode ( tp , ip , XFS_ILOG_CORE ) ; XFS_STATS_INC ( xs_ig_attrchg ) ; if ( mp -> m_flags & XFS_MOUNT_WSYNC ) xfs_trans_set_sync ( tp ) ; code = xfs_trans_commit ( tp , 0 ) ; xfs_iunlock ( ip , lock_flags ) ; xfs_qm_dqrele ( olddquot ) ; xfs_qm_dqrele ( udqp ) ; xfs_qm_dqrele ( pdqp ) ; return code ; error_return : xfs_qm_dqrele ( udqp ) ; xfs_qm_dqrele ( pdqp ) ; xfs_trans_cancel ( tp , 0 ) ; if ( lock_flags ) xfs_iunlock ( ip , lock_flags ) ; return code ; }
static int sco_sock_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { struct sock * sk = sock -> sk ; struct sco_pinfo * pi = sco_pi ( sk ) ; lock_sock ( sk ) ; if ( sk -> sk_state == BT_CONNECT2 && test_bit ( BT_SK_DEFER_SETUP , & bt_sk ( sk ) -> flags ) ) { hci_conn_accept ( pi -> conn -> hcon , 0 ) ; sk -> sk_state = BT_CONFIG ; <S2SV_StartBug> release_sock ( sk ) ; <S2SV_EndBug> return 0 ; } release_sock ( sk ) ; return bt_sock_recvmsg ( iocb , sock , msg , len , flags ) ; }
long pipe_fcntl ( struct file * file , unsigned int cmd , unsigned long arg ) { struct pipe_inode_info * pipe ; long ret ; pipe = get_pipe_info ( file ) ; if ( ! pipe ) return - EBADF ; __pipe_lock ( pipe ) ; switch ( cmd ) { case F_SETPIPE_SZ : { unsigned int size , nr_pages ; size = round_pipe_size ( arg ) ; nr_pages = size >> PAGE_SHIFT ; ret = - EINVAL ; if ( ! nr_pages ) goto out ; if ( ! capable ( CAP_SYS_RESOURCE ) && size > pipe_max_size ) { ret = - EPERM ; goto out ; <S2SV_StartBug> } <S2SV_EndBug> ret = pipe_set_size ( pipe , nr_pages ) ; break ; } case F_GETPIPE_SZ : ret = pipe -> buffers * PAGE_SIZE ; break ; default : ret = - EINVAL ; break ; } out : __pipe_unlock ( pipe ) ; return ret ; }
static long madvise_willneed ( struct vm_area_struct * vma , struct vm_area_struct * * prev , unsigned long start , unsigned long end ) { struct file * file = vma -> vm_file ; <S2SV_StartBug> # ifdef CONFIG_SWAP <S2SV_EndBug> if ( ! file ) { <S2SV_StartBug> * prev = vma ; <S2SV_EndBug> force_swapin_readahead ( vma , start , end ) ; return 0 ; } if ( shmem_mapping ( file -> f_mapping ) ) { <S2SV_StartBug> * prev = vma ; <S2SV_EndBug> force_shm_swapin_readahead ( vma , start , end , file -> f_mapping ) ; return 0 ; } # else if ( ! file ) return - EBADF ; # endif if ( IS_DAX ( file_inode ( file ) ) ) { return 0 ; } <S2SV_StartBug> * prev = vma ; <S2SV_EndBug> start = ( ( start - vma -> vm_start ) >> PAGE_SHIFT ) + vma -> vm_pgoff ; if ( end > vma -> vm_end ) end = vma -> vm_end ; end = ( ( end - vma -> vm_start ) >> PAGE_SHIFT ) + vma -> vm_pgoff ; force_page_cache_readahead ( file -> f_mapping , file , start , end - start ) ; return 0 ; }
void common_timer_get ( struct k_itimer * timr , struct itimerspec64 * cur_setting ) { const struct k_clock * kc = timr -> kclock ; ktime_t now , remaining , iv ; struct timespec64 ts64 ; bool sig_none ; <S2SV_StartBug> sig_none = ( timr -> it_sigev_notify & ~ SIGEV_THREAD_ID ) == SIGEV_NONE ; <S2SV_EndBug> iv = timr -> it_interval ; if ( iv ) { cur_setting -> it_interval = ktime_to_timespec64 ( iv ) ; } else if ( ! timr -> it_active ) { if ( ! sig_none ) return ; } kc -> clock_get ( timr -> it_clock , & ts64 ) ; now = timespec64_to_ktime ( ts64 ) ; if ( iv && ( timr -> it_requeue_pending & REQUEUE_PENDING || sig_none ) ) timr -> it_overrun += kc -> timer_forward ( timr , now ) ; remaining = kc -> timer_remaining ( timr , now ) ; if ( remaining <= 0 ) { if ( ! sig_none ) cur_setting -> it_value . tv_nsec = 1 ; } else { cur_setting -> it_value = ktime_to_timespec64 ( remaining ) ; } }
static int lldp_private_8021_print ( netdissect_options * ndo , const u_char * tptr , u_int tlv_len ) { int subtype , hexdump = FALSE ; u_int sublen ; u_int tval ; <S2SV_StartBug> uint8_t i ; <S2SV_EndBug> if ( tlv_len < 4 ) { return hexdump ; } subtype = * ( tptr + 3 ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Subtype<S2SV_blank>(%u)" , tok2str ( lldp_8021_subtype_values , "unknown" , subtype ) , subtype ) ) ; switch ( subtype ) { case LLDP_PRIVATE_8021_SUBTYPE_PORT_VLAN_ID : if ( tlv_len < 6 ) { return hexdump ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>port<S2SV_blank>vlan<S2SV_blank>id<S2SV_blank>(PVID):<S2SV_blank>%u" , EXTRACT_16BITS ( tptr + 4 ) ) ) ; break ; case LLDP_PRIVATE_8021_SUBTYPE_PROTOCOL_VLAN_ID : if ( tlv_len < 7 ) { return hexdump ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>port<S2SV_blank>and<S2SV_blank>protocol<S2SV_blank>vlan<S2SV_blank>id<S2SV_blank>(PPVID):<S2SV_blank>%u,<S2SV_blank>flags<S2SV_blank>[%s]<S2SV_blank>(0x%02x)" , EXTRACT_16BITS ( tptr + 5 ) , bittok2str ( lldp_8021_port_protocol_id_values , "none" , * ( tptr + 4 ) ) , * ( tptr + 4 ) ) ) ; break ; case LLDP_PRIVATE_8021_SUBTYPE_VLAN_NAME : if ( tlv_len < 6 ) { return hexdump ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>vlan<S2SV_blank>id<S2SV_blank>(VID):<S2SV_blank>%u" , EXTRACT_16BITS ( tptr + 4 ) ) ) ; if ( tlv_len < 7 ) { return hexdump ; } sublen = * ( tptr + 6 ) ; if ( tlv_len < 7 + sublen ) { return hexdump ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>vlan<S2SV_blank>name:<S2SV_blank>" ) ) ; safeputs ( ndo , tptr + 7 , sublen ) ; break ; case LLDP_PRIVATE_8021_SUBTYPE_PROTOCOL_IDENTITY : if ( tlv_len < 5 ) { return hexdump ; } sublen = * ( tptr + 4 ) ; if ( tlv_len < 5 + sublen ) { return hexdump ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>protocol<S2SV_blank>identity:<S2SV_blank>" ) ) ; safeputs ( ndo , tptr + 5 , sublen ) ; break ; case LLDP_PRIVATE_8021_SUBTYPE_CONGESTION_NOTIFICATION : if ( tlv_len < LLDP_PRIVATE_8021_SUBTYPE_CONGESTION_NOTIFICATION_LENGTH ) { return hexdump ; } tval = * ( tptr + 4 ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Pre-Priority<S2SV_blank>CNPV<S2SV_blank>Indicator" ) ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Priority<S2SV_blank>:<S2SV_blank>0<S2SV_blank><S2SV_blank>1<S2SV_blank><S2SV_blank>2<S2SV_blank><S2SV_blank>3<S2SV_blank><S2SV_blank>4<S2SV_blank><S2SV_blank>5<S2SV_blank><S2SV_blank>6<S2SV_blank><S2SV_blank>7" ) ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Value<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>:<S2SV_blank>" ) ) ; for ( i = 0 ; i < NO_OF_BITS ; i ++ ) ND_PRINT ( ( ndo , "%-2d<S2SV_blank>" , ( tval >> i ) & 0x01 ) ) ; tval = * ( tptr + 5 ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Pre-Priority<S2SV_blank>Ready<S2SV_blank>Indicator" ) ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Priority<S2SV_blank>:<S2SV_blank>0<S2SV_blank><S2SV_blank>1<S2SV_blank><S2SV_blank>2<S2SV_blank><S2SV_blank>3<S2SV_blank><S2SV_blank>4<S2SV_blank><S2SV_blank>5<S2SV_blank><S2SV_blank>6<S2SV_blank><S2SV_blank>7" ) ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Value<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>:<S2SV_blank>" ) ) ; for ( i = 0 ; i < NO_OF_BITS ; i ++ ) ND_PRINT ( ( ndo , "%-2d<S2SV_blank>" , ( tval >> i ) & 0x01 ) ) ; break ; case LLDP_PRIVATE_8021_SUBTYPE_ETS_CONFIGURATION : if ( tlv_len < LLDP_PRIVATE_8021_SUBTYPE_ETS_CONFIGURATION_LENGTH ) { return hexdump ; } tval = * ( tptr + 4 ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Willing:%d,<S2SV_blank>CBS:%d,<S2SV_blank>RES:%d,<S2SV_blank>Max<S2SV_blank>TCs:%d" , tval >> 7 , ( tval >> 6 ) & 0x02 , ( tval >> 3 ) & 0x07 , tval & 0x07 ) ) ; print_ets_priority_assignment_table ( ndo , tptr + 5 ) ; print_tc_bandwidth_table ( ndo , tptr + 9 ) ; print_tsa_assignment_table ( ndo , tptr + 17 ) ; break ; case LLDP_PRIVATE_8021_SUBTYPE_ETS_RECOMMENDATION : if ( tlv_len < LLDP_PRIVATE_8021_SUBTYPE_ETS_RECOMMENDATION_LENGTH ) { return hexdump ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>RES:<S2SV_blank>%d" , * ( tptr + 4 ) ) ) ; print_ets_priority_assignment_table ( ndo , tptr + 5 ) ; print_tc_bandwidth_table ( ndo , tptr + 9 ) ; print_tsa_assignment_table ( ndo , tptr + 17 ) ; break ; case LLDP_PRIVATE_8021_SUBTYPE_PFC_CONFIGURATION : if ( tlv_len < LLDP_PRIVATE_8021_SUBTYPE_PFC_CONFIGURATION_LENGTH ) { return hexdump ; } tval = * ( tptr + 4 ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Willing:<S2SV_blank>%d,<S2SV_blank>MBC:<S2SV_blank>%d,<S2SV_blank>RES:<S2SV_blank>%d,<S2SV_blank>PFC<S2SV_blank>cap:%d<S2SV_blank>" , tval >> 7 , ( tval >> 6 ) & 0x01 , ( tval >> 4 ) & 0x03 , ( tval & 0x0f ) ) ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>PFC<S2SV_blank>Enable" ) ) ; tval = * ( tptr + 5 ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Priority<S2SV_blank>:<S2SV_blank>0<S2SV_blank><S2SV_blank>1<S2SV_blank><S2SV_blank>2<S2SV_blank><S2SV_blank>3<S2SV_blank><S2SV_blank>4<S2SV_blank><S2SV_blank>5<S2SV_blank><S2SV_blank>6<S2SV_blank><S2SV_blank>7" ) ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Value<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>:<S2SV_blank>" ) ) ; for ( i = 0 ; i < NO_OF_BITS ; i ++ ) ND_PRINT ( ( ndo , "%-2d<S2SV_blank>" , ( tval >> i ) & 0x01 ) ) ; break ; case LLDP_PRIVATE_8021_SUBTYPE_APPLICATION_PRIORITY : if ( tlv_len < LLDP_PRIVATE_8021_SUBTYPE_APPLICATION_PRIORITY_MIN_LENGTH ) { return hexdump ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>RES:<S2SV_blank>%d" , * ( tptr + 4 ) ) ) ; if ( tlv_len <= LLDP_PRIVATE_8021_SUBTYPE_APPLICATION_PRIORITY_MIN_LENGTH ) { return hexdump ; } sublen = tlv_len - 5 ; if ( sublen % 3 != 0 ) { return hexdump ; } i = 0 ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Application<S2SV_blank>Priority<S2SV_blank>Table" ) ) ; while ( i < sublen ) { tval = * ( tptr + i + 5 ) ; <S2SV_StartBug> ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Priority:<S2SV_blank>%d,<S2SV_blank>RES:<S2SV_blank>%d,<S2SV_blank>Sel:<S2SV_blank>%d" , <S2SV_EndBug> <S2SV_StartBug> tval >> 5 , ( tval >> 3 ) & 0x03 , ( tval & 0x07 ) ) ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , "Protocol<S2SV_blank>ID:<S2SV_blank>%d" , EXTRACT_16BITS ( tptr + i + 5 ) ) ) ; i = i + 3 ; } break ; case LLDP_PRIVATE_8021_SUBTYPE_EVB : if ( tlv_len < LLDP_PRIVATE_8021_SUBTYPE_EVB_LENGTH ) { return hexdump ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>EVB<S2SV_blank>Bridge<S2SV_blank>Status" ) ) ; tval = * ( tptr + 4 ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>RES:<S2SV_blank>%d,<S2SV_blank>BGID:<S2SV_blank>%d,<S2SV_blank>RRCAP:<S2SV_blank>%d,<S2SV_blank>RRCTR:<S2SV_blank>%d" , tval >> 3 , ( tval >> 2 ) & 0x01 , ( tval >> 1 ) & 0x01 , tval & 0x01 ) ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>EVB<S2SV_blank>Station<S2SV_blank>Status" ) ) ; tval = * ( tptr + 5 ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>RES:<S2SV_blank>%d,<S2SV_blank>SGID:<S2SV_blank>%d,<S2SV_blank>RRREQ:<S2SV_blank>%d,RRSTAT:<S2SV_blank>%d" , tval >> 4 , ( tval >> 3 ) & 0x01 , ( tval >> 2 ) & 0x01 , tval & 0x03 ) ) ; tval = * ( tptr + 6 ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>R:<S2SV_blank>%d,<S2SV_blank>RTE:<S2SV_blank>%d,<S2SV_blank>" , tval >> 5 , tval & 0x1f ) ) ; tval = * ( tptr + 7 ) ; ND_PRINT ( ( ndo , "EVB<S2SV_blank>Mode:<S2SV_blank>%s<S2SV_blank>[%d]" , tok2str ( lldp_evb_mode_values , "unknown" , tval >> 6 ) , tval >> 6 ) ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>ROL:<S2SV_blank>%d,<S2SV_blank>RWD:<S2SV_blank>%d,<S2SV_blank>" , ( tval >> 5 ) & 0x01 , tval & 0x1f ) ) ; tval = * ( tptr + 8 ) ; ND_PRINT ( ( ndo , "RES:<S2SV_blank>%d,<S2SV_blank>ROL:<S2SV_blank>%d,<S2SV_blank>RKA:<S2SV_blank>%d" , tval >> 6 , ( tval >> 5 ) & 0x01 , tval & 0x1f ) ) ; break ; case LLDP_PRIVATE_8021_SUBTYPE_CDCP : if ( tlv_len < LLDP_PRIVATE_8021_SUBTYPE_CDCP_MIN_LENGTH ) { return hexdump ; } tval = * ( tptr + 4 ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Role:<S2SV_blank>%d,<S2SV_blank>RES:<S2SV_blank>%d,<S2SV_blank>Scomp:<S2SV_blank>%d<S2SV_blank>" , tval >> 7 , ( tval >> 4 ) & 0x07 , ( tval >> 3 ) & 0x01 ) ) ; ND_PRINT ( ( ndo , "ChnCap:<S2SV_blank>%d" , EXTRACT_16BITS ( tptr + 6 ) & 0x0fff ) ) ; sublen = tlv_len - 8 ; if ( sublen % 3 != 0 ) { return hexdump ; } i = 0 ; while ( i < sublen ) { tval = EXTRACT_24BITS ( tptr + i + 8 ) ; ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>SCID:<S2SV_blank>%d,<S2SV_blank>SVID:<S2SV_blank>%d" , tval >> 12 , tval & 0x000fff ) ) ; i = i + 3 ; } break ; default : hexdump = TRUE ; break ; } return hexdump ; }
jas_matrix_t * jas_matrix_create ( int numrows , int numcols ) { jas_matrix_t * matrix ; int i ; <S2SV_StartBug> if ( ! ( matrix = jas_malloc ( sizeof ( jas_matrix_t ) ) ) ) { <S2SV_EndBug> return 0 ; } matrix -> flags_ = 0 ; matrix -> numrows_ = numrows ; matrix -> numcols_ = numcols ; matrix -> rows_ = 0 ; matrix -> maxrows_ = numrows ; matrix -> data_ = 0 ; matrix -> datasize_ = numrows * numcols ; if ( matrix -> maxrows_ > 0 ) { if ( ! ( matrix -> rows_ = jas_alloc2 ( matrix -> maxrows_ , sizeof ( jas_seqent_t * ) ) ) ) { jas_matrix_destroy ( matrix ) ; return 0 ; } } if ( matrix -> datasize_ > 0 ) { if ( ! ( matrix -> data_ = jas_alloc2 ( matrix -> datasize_ , sizeof ( jas_seqent_t ) ) ) ) { jas_matrix_destroy ( matrix ) ; return 0 ; } } for ( i = 0 ; i < numrows ; ++ i ) { matrix -> rows_ [ i ] = & matrix -> data_ [ i * matrix -> numcols_ ] ; } for ( i = 0 ; i < matrix -> datasize_ ; ++ i ) { matrix -> data_ [ i ] = 0 ; } matrix -> xstart_ = 0 ; matrix -> ystart_ = 0 ; matrix -> xend_ = matrix -> numcols_ ; matrix -> yend_ = matrix -> numrows_ ; return matrix ; }
void test_base64_decode ( void ) { char buffer [ 16 ] ; <S2SV_StartBug> int len = mutt_b64_decode ( buffer , encoded ) ; <S2SV_EndBug> if ( ! TEST_CHECK ( len == sizeof ( clear ) - 1 ) ) { TEST_MSG ( "Expected:<S2SV_blank>%zu" , sizeof ( clear ) - 1 ) ; TEST_MSG ( "Actual<S2SV_blank><S2SV_blank>:<S2SV_blank>%zu" , len ) ; } buffer [ len ] = '\\0' ; if ( ! TEST_CHECK ( strcmp ( buffer , clear ) == 0 ) ) { TEST_MSG ( "Expected:<S2SV_blank>%s" , clear ) ; TEST_MSG ( "Actual<S2SV_blank><S2SV_blank>:<S2SV_blank>%s" , buffer ) ; } }
static int l2cap_sock_connect ( struct socket * sock , struct sockaddr * addr , int alen , int flags ) { struct sock * sk = sock -> sk ; struct sockaddr_l2 la ; int len , err = 0 ; BT_DBG ( "sk<S2SV_blank>%p" , sk ) ; if ( ! addr || addr -> sa_family != AF_BLUETOOTH ) return - EINVAL ; memset ( & la , 0 , sizeof ( la ) ) ; len = min_t ( unsigned int , sizeof ( la ) , alen ) ; memcpy ( & la , addr , len ) ; if ( la . l2_cid ) return - EINVAL ; lock_sock ( sk ) ; if ( sk -> sk_type == SOCK_SEQPACKET && ! la . l2_psm ) { err = - EINVAL ; goto done ; } switch ( l2cap_pi ( sk ) -> mode ) { case L2CAP_MODE_BASIC : break ; case L2CAP_MODE_ERTM : <S2SV_StartBug> if ( enable_ertm ) <S2SV_EndBug> break ; default : err = - ENOTSUPP ; goto done ; } switch ( sk -> sk_state ) { case BT_CONNECT : case BT_CONNECT2 : case BT_CONFIG : goto wait ; case BT_CONNECTED : goto done ; case BT_OPEN : case BT_BOUND : break ; default : err = - EBADFD ; goto done ; } bacpy ( & bt_sk ( sk ) -> dst , & la . l2_bdaddr ) ; l2cap_pi ( sk ) -> psm = la . l2_psm ; err = l2cap_do_connect ( sk ) ; if ( err ) goto done ; wait : err = bt_sock_wait_state ( sk , BT_CONNECTED , sock_sndtimeo ( sk , flags & O_NONBLOCK ) ) ; done : release_sock ( sk ) ; return err ; }
static ExprList * exprListAppendList ( Parse * pParse , ExprList * pList , ExprList * pAppend , int bIntToNull ) { if ( pAppend ) { int i ; int nInit = pList ? pList -> nExpr : 0 ; for ( i = 0 ; i < pAppend -> nExpr ; i ++ ) { Expr * pDup = sqlite3ExprDup ( pParse -> db , pAppend -> a [ i ] . pExpr , 0 ) ; <S2SV_StartBug> if ( bIntToNull && pDup && pDup -> op == TK_INTEGER ) { <S2SV_EndBug> pDup -> op = TK_NULL ; <S2SV_StartBug> pDup -> flags &= ~ ( EP_IntValue | EP_IsTrue | EP_IsFalse ) ; <S2SV_EndBug> } pList = sqlite3ExprListAppend ( pParse , pList , pDup ) ; if ( pList ) pList -> a [ nInit + i ] . sortFlags = pAppend -> a [ i ] . sortFlags ; } } return pList ; }
static VALUE ossl_cipher_init ( int argc , VALUE * argv , VALUE self , int mode ) { EVP_CIPHER_CTX * ctx ; unsigned char key [ EVP_MAX_KEY_LENGTH ] , * p_key = NULL ; unsigned char iv [ EVP_MAX_IV_LENGTH ] , * p_iv = NULL ; VALUE pass , init_v ; if ( rb_scan_args ( argc , argv , "02" , & pass , & init_v ) > 0 ) { VALUE cname = rb_class_path ( rb_obj_class ( self ) ) ; rb_warn ( "arguments<S2SV_blank>for<S2SV_blank>%" PRIsVALUE "#encrypt<S2SV_blank>and<S2SV_blank>%" PRIsVALUE "#decrypt<S2SV_blank>were<S2SV_blank>deprecated;<S2SV_blank>" "use<S2SV_blank>%" PRIsVALUE "#pkcs5_keyivgen<S2SV_blank>to<S2SV_blank>derive<S2SV_blank>key<S2SV_blank>and<S2SV_blank>IV" , cname , cname , cname ) ; StringValue ( pass ) ; GetCipher ( self , ctx ) ; if ( NIL_P ( init_v ) ) memcpy ( iv , "OpenSSL<S2SV_blank>for<S2SV_blank>Ruby<S2SV_blank>rulez!" , sizeof ( iv ) ) ; else { StringValue ( init_v ) ; if ( EVP_MAX_IV_LENGTH > RSTRING_LEN ( init_v ) ) { memset ( iv , 0 , EVP_MAX_IV_LENGTH ) ; memcpy ( iv , RSTRING_PTR ( init_v ) , RSTRING_LEN ( init_v ) ) ; } else memcpy ( iv , RSTRING_PTR ( init_v ) , sizeof ( iv ) ) ; } EVP_BytesToKey ( EVP_CIPHER_CTX_cipher ( ctx ) , EVP_md5 ( ) , iv , ( unsigned char * ) RSTRING_PTR ( pass ) , RSTRING_LENINT ( pass ) , 1 , key , NULL ) ; p_key = key ; p_iv = iv ; } else { GetCipher ( self , ctx ) ; } if ( EVP_CipherInit_ex ( ctx , NULL , NULL , p_key , p_iv , mode ) != 1 ) { ossl_raise ( eCipherError , NULL ) ; } <S2SV_StartBug> return self ; <S2SV_EndBug> }
int upnp_redirect ( const char * rhost , unsigned short eport , const char * iaddr , unsigned short iport , const char * protocol , const char * desc , unsigned int leaseduration ) { int proto , r ; char iaddr_old [ 32 ] ; char rhost_old [ 32 ] ; unsigned short iport_old ; struct in_addr address ; unsigned int timestamp ; proto = proto_atoi ( protocol ) ; if ( inet_aton ( iaddr , & address ) <= 0 ) { syslog ( LOG_ERR , "inet_aton(%s)<S2SV_blank>FAILED" , iaddr ) ; return - 1 ; } if ( ! check_upnp_rule_against_permissions ( upnppermlist , num_upnpperm , eport , address , iport ) ) { syslog ( LOG_INFO , "redirection<S2SV_blank>permission<S2SV_blank>check<S2SV_blank>failed<S2SV_blank>for<S2SV_blank>" "%hu->%s:%hu<S2SV_blank>%s" , eport , iaddr , iport , protocol ) ; return - 3 ; } <S2SV_StartBug> rhost_old [ 0 ] = '\\0' ; <S2SV_EndBug> r = get_redirect_rule ( ext_if_name , eport , proto , iaddr_old , sizeof ( iaddr_old ) , & iport_old , 0 , 0 , rhost_old , sizeof ( rhost_old ) , & timestamp , 0 , 0 ) ; if ( r == 0 ) { if ( strcmp ( iaddr , iaddr_old ) == 0 && ( ( rhost == NULL && rhost_old [ 0 ] == '\\0' ) || ( rhost && ( strcmp ( rhost , "*" ) == 0 ) && rhost_old [ 0 ] == '\\0' ) || ( rhost && ( strcmp ( rhost , rhost_old ) == 0 ) ) ) ) { syslog ( LOG_INFO , "updating<S2SV_blank>existing<S2SV_blank>port<S2SV_blank>mapping<S2SV_blank>%hu<S2SV_blank>%s<S2SV_blank>(rhost<S2SV_blank>\'%s\')<S2SV_blank>=><S2SV_blank>%s:%hu" , eport , protocol , rhost_old , iaddr_old , iport_old ) ; timestamp = ( leaseduration > 0 ) ? upnp_time ( ) + leaseduration : 0 ; if ( iport != iport_old ) { r = update_portmapping ( ext_if_name , eport , proto , iport , desc , timestamp ) ; } else { r = update_portmapping_desc_timestamp ( ext_if_name , eport , proto , desc , timestamp ) ; } # ifdef ENABLE_LEASEFILE if ( r == 0 ) { lease_file_remove ( eport , proto ) ; lease_file_add ( eport , iaddr , iport , proto , desc , timestamp ) ; } # endif return r ; } else { syslog ( LOG_INFO , "port<S2SV_blank>%hu<S2SV_blank>%s<S2SV_blank>(rhost<S2SV_blank>\'%s\')<S2SV_blank>already<S2SV_blank>redirected<S2SV_blank>to<S2SV_blank>%s:%hu" , eport , protocol , rhost_old , iaddr_old , iport_old ) ; return - 2 ; } # ifdef CHECK_PORTINUSE } else if ( port_in_use ( ext_if_name , eport , proto , iaddr , iport ) > 0 ) { syslog ( LOG_INFO , "port<S2SV_blank>%hu<S2SV_blank>protocol<S2SV_blank>%s<S2SV_blank>already<S2SV_blank>in<S2SV_blank>use" , eport , protocol ) ; return - 4 ; # endif } else { timestamp = ( leaseduration > 0 ) ? upnp_time ( ) + leaseduration : 0 ; syslog ( LOG_INFO , "redirecting<S2SV_blank>port<S2SV_blank>%hu<S2SV_blank>to<S2SV_blank>%s:%hu<S2SV_blank>protocol<S2SV_blank>%s<S2SV_blank>for:<S2SV_blank>%s" , eport , iaddr , iport , protocol , desc ) ; return upnp_redirect_internal ( rhost , eport , iaddr , iport , proto , desc , timestamp ) ; } }
static u_int ldp_pdu_print ( netdissect_options * ndo , register const u_char * pptr ) { const struct ldp_common_header * ldp_com_header ; const struct ldp_msg_header * ldp_msg_header ; const u_char * tptr , * msg_tptr ; u_short tlen ; u_short pdu_len , msg_len , msg_type , msg_tlen ; int hexdump , processed ; ldp_com_header = ( const struct ldp_common_header * ) pptr ; ND_TCHECK ( * ldp_com_header ) ; if ( EXTRACT_16BITS ( & ldp_com_header -> version ) != LDP_VERSION ) { ND_PRINT ( ( ndo , "%sLDP<S2SV_blank>version<S2SV_blank>%u<S2SV_blank>packet<S2SV_blank>not<S2SV_blank>supported" , ( ndo -> ndo_vflag < 1 ) ? "" : "\\n\\t" , EXTRACT_16BITS ( & ldp_com_header -> version ) ) ) ; return 0 ; } pdu_len = EXTRACT_16BITS ( & ldp_com_header -> pdu_length ) ; if ( pdu_len < sizeof ( const struct ldp_common_header ) - 4 ) { ND_PRINT ( ( ndo , "%sLDP,<S2SV_blank>pdu-length:<S2SV_blank>%u<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)" , ( ndo -> ndo_vflag < 1 ) ? "" : "\\n\\t" , pdu_len , ( u_int ) ( sizeof ( const struct ldp_common_header ) - 4 ) ) ) ; return 0 ; } ND_PRINT ( ( ndo , "%sLDP,<S2SV_blank>Label-Space-ID:<S2SV_blank>%s:%u,<S2SV_blank>pdu-length:<S2SV_blank>%u" , ( ndo -> ndo_vflag < 1 ) ? "" : "\\n\\t" , ipaddr_string ( ndo , & ldp_com_header -> lsr_id ) , EXTRACT_16BITS ( & ldp_com_header -> label_space ) , pdu_len ) ) ; if ( ndo -> ndo_vflag < 1 ) return 0 ; tptr = pptr + sizeof ( const struct ldp_common_header ) ; tlen = pdu_len - ( sizeof ( const struct ldp_common_header ) - 4 ) ; while ( tlen > 0 ) { ND_TCHECK2 ( * tptr , sizeof ( struct ldp_msg_header ) ) ; ldp_msg_header = ( const struct ldp_msg_header * ) tptr ; msg_len = EXTRACT_16BITS ( ldp_msg_header -> length ) ; msg_type = LDP_MASK_MSG_TYPE ( EXTRACT_16BITS ( ldp_msg_header -> type ) ) ; if ( msg_len < sizeof ( struct ldp_msg_header ) - 4 ) { ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Message<S2SV_blank>(0x%04x),<S2SV_blank>length:<S2SV_blank>%u<S2SV_blank>(too<S2SV_blank>short,<S2SV_blank><<S2SV_blank>%u)" , tok2str ( ldp_msg_values , "Unknown" , msg_type ) , msg_type , msg_len , ( u_int ) ( sizeof ( struct ldp_msg_header ) - 4 ) ) ) ; return 0 ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Message<S2SV_blank>(0x%04x),<S2SV_blank>length:<S2SV_blank>%u,<S2SV_blank>Message<S2SV_blank>ID:<S2SV_blank>0x%08x,<S2SV_blank>Flags:<S2SV_blank>[%s<S2SV_blank>if<S2SV_blank>unknown]" , tok2str ( ldp_msg_values , "Unknown" , msg_type ) , msg_type , msg_len , EXTRACT_32BITS ( & ldp_msg_header -> id ) , LDP_MASK_U_BIT ( EXTRACT_16BITS ( & ldp_msg_header -> type ) ) ? "continue<S2SV_blank>processing" : "ignore" ) ) ; msg_tptr = tptr + sizeof ( struct ldp_msg_header ) ; msg_tlen = msg_len - ( sizeof ( struct ldp_msg_header ) - 4 ) ; ND_TCHECK2 ( * tptr , msg_len ) ; hexdump = FALSE ; switch ( msg_type ) { case LDP_MSG_NOTIF : case LDP_MSG_HELLO : case LDP_MSG_INIT : case LDP_MSG_KEEPALIVE : case LDP_MSG_ADDRESS : case LDP_MSG_LABEL_MAPPING : case LDP_MSG_ADDRESS_WITHDRAW : case LDP_MSG_LABEL_WITHDRAW : while ( msg_tlen >= 4 ) { processed = ldp_tlv_print ( ndo , msg_tptr , msg_tlen ) ; if ( processed == 0 ) break ; msg_tlen -= processed ; msg_tptr += processed ; } break ; case LDP_MSG_LABEL_REQUEST : case LDP_MSG_LABEL_RELEASE : case LDP_MSG_LABEL_ABORT_REQUEST : default : if ( ndo -> ndo_vflag <= 1 ) print_unknown_data ( ndo , msg_tptr , "\\n\\t<S2SV_blank><S2SV_blank>" , msg_tlen ) ; break ; } if ( ndo -> ndo_vflag > 1 || hexdump == TRUE ) print_unknown_data ( ndo , tptr + sizeof ( struct ldp_msg_header ) , "\\n\\t<S2SV_blank><S2SV_blank>" , msg_len ) ; tptr += msg_len + 4 ; tlen -= msg_len + 4 ; } return pdu_len + 4 ; trunc : <S2SV_StartBug> ND_PRINT ( ( ndo , "\\n\\t\\t<S2SV_blank>packet<S2SV_blank>exceeded<S2SV_blank>snapshot" ) ) ; <S2SV_EndBug> return 0 ; }
static void ChopUpSingleUncompressedStrip ( TIFF * tif ) { register TIFFDirectory * td = & tif -> tif_dir ; uint64 bytecount ; uint64 offset ; uint32 rowblock ; uint64 rowblockbytes ; uint64 stripbytes ; uint32 strip ; <S2SV_StartBug> uint64 nstrips64 ; <S2SV_EndBug> uint32 nstrips32 ; uint32 rowsperstrip ; uint64 * newcounts ; uint64 * newoffsets ; bytecount = td -> td_stripbytecount [ 0 ] ; offset = td -> td_stripoffset [ 0 ] ; assert ( td -> td_planarconfig == PLANARCONFIG_CONTIG ) ; if ( ( td -> td_photometric == PHOTOMETRIC_YCBCR ) && ( ! isUpSampled ( tif ) ) ) rowblock = td -> td_ycbcrsubsampling [ 1 ] ; else rowblock = 1 ; rowblockbytes = TIFFVTileSize64 ( tif , rowblock ) ; if ( rowblockbytes > STRIP_SIZE_DEFAULT ) { stripbytes = rowblockbytes ; rowsperstrip = rowblock ; } else if ( rowblockbytes > 0 ) { uint32 rowblocksperstrip ; rowblocksperstrip = ( uint32 ) ( STRIP_SIZE_DEFAULT / rowblockbytes ) ; rowsperstrip = rowblocksperstrip * rowblock ; stripbytes = rowblocksperstrip * rowblockbytes ; } else return ; if ( rowsperstrip >= td -> td_rowsperstrip ) return ; <S2SV_StartBug> nstrips64 = TIFFhowmany_64 ( bytecount , stripbytes ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ( nstrips64 == 0 ) || ( nstrips64 > 0xFFFFFFFF ) ) <S2SV_EndBug> return ; nstrips32 = ( uint32 ) nstrips64 ; <S2SV_StartBug> newcounts = ( uint64 * ) _TIFFCheckMalloc ( tif , nstrips32 , sizeof ( uint64 ) , <S2SV_EndBug> "for<S2SV_blank>chopped<S2SV_blank>\\"StripByteCounts\\"<S2SV_blank>array" ) ; <S2SV_StartBug> newoffsets = ( uint64 * ) _TIFFCheckMalloc ( tif , nstrips32 , sizeof ( uint64 ) , <S2SV_EndBug> "for<S2SV_blank>chopped<S2SV_blank>\\"StripOffsets\\"<S2SV_blank>array" ) ; if ( newcounts == NULL || newoffsets == NULL ) { if ( newcounts != NULL ) _TIFFfree ( newcounts ) ; if ( newoffsets != NULL ) _TIFFfree ( newoffsets ) ; return ; } <S2SV_StartBug> for ( strip = 0 ; strip < nstrips32 ; strip ++ ) { <S2SV_EndBug> if ( stripbytes > bytecount ) stripbytes = bytecount ; newcounts [ strip ] = stripbytes ; <S2SV_StartBug> newoffsets [ strip ] = offset ; <S2SV_EndBug> offset += stripbytes ; bytecount -= stripbytes ; } <S2SV_StartBug> td -> td_stripsperimage = td -> td_nstrips = nstrips32 ; <S2SV_EndBug> TIFFSetField ( tif , TIFFTAG_ROWSPERSTRIP , rowsperstrip ) ; _TIFFfree ( td -> td_stripbytecount ) ; _TIFFfree ( td -> td_stripoffset ) ; td -> td_stripbytecount = newcounts ; td -> td_stripoffset = newoffsets ; td -> td_stripbytecountsorted = 1 ; }
<S2SV_StartBug> static ssize_t aio_setup_single_vector ( struct kiocb * kiocb ) <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> kiocb -> ki_iovec = & kiocb -> ki_inline_vec ; kiocb -> ki_iovec -> iov_base = kiocb -> ki_buf ; <S2SV_StartBug> kiocb -> ki_iovec -> iov_len = kiocb -> ki_left ; <S2SV_EndBug> kiocb -> ki_nr_segs = 1 ; kiocb -> ki_cur_seg = 0 ; return 0 ; }
int disrsi_ ( int stream , int * negate , unsigned * value , unsigned count ) { int c ; unsigned locval ; unsigned ndigs ; char * cp ; char scratch [ DIS_BUFSIZ + 1 ] ; assert ( negate != NULL ) ; assert ( value != NULL ) ; assert ( count ) ; assert ( stream >= 0 ) ; assert ( dis_getc != NULL ) ; assert ( dis_gets != NULL ) ; memset ( scratch , 0 , DIS_BUFSIZ + 1 ) ; if ( dis_umaxd == 0 ) disiui_ ( ) ; <S2SV_StartBug> switch ( c = ( * dis_getc ) ( stream ) ) <S2SV_EndBug> { case '-' : case '+' : * negate = c == '-' ; if ( ( * dis_gets ) ( stream , scratch , count ) != ( int ) count ) { return ( DIS_EOD ) ; } if ( count >= dis_umaxd ) { if ( count > dis_umaxd ) goto overflow ; if ( memcmp ( scratch , dis_umax , dis_umaxd ) > 0 ) goto overflow ; } cp = scratch ; locval = 0 ; do { if ( ( ( c = * cp ++ ) < '0' ) || ( c > '9' ) ) { return ( DIS_NONDIGIT ) ; } locval = 10 * locval + c - '0' ; } while ( -- count ) ; * value = locval ; return ( DIS_SUCCESS ) ; break ; case '0' : return ( DIS_LEADZRO ) ; break ; case '1' : case '2' : case '3' : case '4' : case '5' : case '6' : case '7' : case '8' : case '9' : ndigs = c - '0' ; if ( count > 1 ) { if ( ( * dis_gets ) ( stream , scratch + 1 , count - 1 ) != ( int ) count - 1 ) { return ( DIS_EOD ) ; } cp = scratch ; if ( count >= dis_umaxd ) { if ( count > dis_umaxd ) break ; * cp = c ; if ( memcmp ( scratch , dis_umax , dis_umaxd ) > 0 ) break ; } while ( -- count ) { if ( ( ( c = * ++ cp ) < '0' ) || ( c > '9' ) ) { return ( DIS_NONDIGIT ) ; } ndigs = 10 * ndigs + c - '0' ; } } return ( disrsi_ ( stream , negate , value , ndigs ) ) ; break ; case - 1 : return ( DIS_EOD ) ; break ; case - 2 : return ( DIS_EOF ) ; break ; default : return ( DIS_NONDIGIT ) ; break ; } * negate = FALSE ; overflow : * value = UINT_MAX ; return ( DIS_OVERFLOW ) ; }
ssize_t socket_bytes_available ( const socket_t * socket ) { assert ( socket != NULL ) ; int size = 0 ; <S2SV_StartBug> if ( ioctl ( socket -> fd , FIONREAD , & size ) == - 1 ) <S2SV_EndBug> return - 1 ; return size ; }
<S2SV_StartBug> static void write_partition ( VP9_COMMON * cm , MACROBLOCKD * xd , <S2SV_EndBug> int hbs , int mi_row , int mi_col , <S2SV_StartBug> PARTITION_TYPE p , BLOCK_SIZE bsize , vp9_writer * w ) { <S2SV_EndBug> const int ctx = partition_plane_context ( xd , mi_row , mi_col , bsize ) ; <S2SV_StartBug> const vp9_prob * const probs = get_partition_probs ( cm , ctx ) ; <S2SV_EndBug> const int has_rows = ( mi_row + hbs ) < cm -> mi_rows ; const int has_cols = ( mi_col + hbs ) < cm -> mi_cols ; if ( has_rows && has_cols ) { vp9_write_token ( w , vp9_partition_tree , probs , & partition_encodings [ p ] ) ; } else if ( ! has_rows && has_cols ) { assert ( p == PARTITION_SPLIT || p == PARTITION_HORZ ) ; <S2SV_StartBug> vp9_write ( w , p == PARTITION_SPLIT , probs [ 1 ] ) ; <S2SV_EndBug> } else if ( has_rows && ! has_cols ) { assert ( p == PARTITION_SPLIT || p == PARTITION_VERT ) ; <S2SV_StartBug> vp9_write ( w , p == PARTITION_SPLIT , probs [ 2 ] ) ; <S2SV_EndBug> } else { assert ( p == PARTITION_SPLIT ) ; } }
static vpx_codec_err_t vp8_destroy ( vpx_codec_alg_priv_t * ctx ) { <S2SV_StartBug> int i ; <S2SV_EndBug> vp8_remove_decoder_instances ( & ctx -> yv12_frame_buffers ) ; <S2SV_StartBug> for ( i = NELEMENTS ( ctx -> mmaps ) - 1 ; i >= 0 ; i -- ) <S2SV_EndBug> { if ( ctx -> mmaps [ i ] . dtor ) ctx -> mmaps [ i ] . dtor ( & ctx -> mmaps [ i ] ) ; } return VPX_CODEC_OK ; }
<S2SV_StartBug> void ntlm_free_message_fields_buffer ( NTLM_MESSAGE_FIELDS * fields ) <S2SV_EndBug> { if ( fields ) { if ( fields -> Buffer ) { free ( fields -> Buffer ) ; fields -> Len = 0 ; fields -> MaxLen = 0 ; fields -> Buffer = NULL ; fields -> BufferOffset = 0 ; } } }
static int hwahc_security_create ( struct hwahc * hwahc ) { int result ; struct wusbhc * wusbhc = & hwahc -> wusbhc ; struct usb_device * usb_dev = hwahc -> wa . usb_dev ; struct device * dev = & usb_dev -> dev ; struct usb_security_descriptor * secd ; struct usb_encryption_descriptor * etd ; void * itr , * top ; size_t itr_size , needed , bytes ; u8 index ; char buf [ 64 ] ; index = ( usb_dev -> actconfig - usb_dev -> config ) / sizeof ( usb_dev -> config [ 0 ] ) ; itr = usb_dev -> rawdescriptors [ index ] ; itr_size = le16_to_cpu ( usb_dev -> actconfig -> desc . wTotalLength ) ; top = itr + itr_size ; result = __usb_get_extra_descriptor ( usb_dev -> rawdescriptors [ index ] , le16_to_cpu ( usb_dev -> actconfig -> desc . wTotalLength ) , <S2SV_StartBug> USB_DT_SECURITY , ( void * * ) & secd ) ; <S2SV_EndBug> if ( result == - 1 ) { dev_warn ( dev , "BUG?<S2SV_blank>WUSB<S2SV_blank>host<S2SV_blank>has<S2SV_blank>no<S2SV_blank>security<S2SV_blank>descriptors\\n" ) ; return 0 ; } needed = sizeof ( * secd ) ; if ( top - ( void * ) secd < needed ) { dev_err ( dev , "BUG?<S2SV_blank>Not<S2SV_blank>enough<S2SV_blank>data<S2SV_blank>to<S2SV_blank>process<S2SV_blank>security<S2SV_blank>" "descriptor<S2SV_blank>header<S2SV_blank>(%zu<S2SV_blank>bytes<S2SV_blank>left<S2SV_blank>vs<S2SV_blank>%zu<S2SV_blank>needed)\\n" , top - ( void * ) secd , needed ) ; return 0 ; } needed = le16_to_cpu ( secd -> wTotalLength ) ; if ( top - ( void * ) secd < needed ) { dev_err ( dev , "BUG?<S2SV_blank>Not<S2SV_blank>enough<S2SV_blank>data<S2SV_blank>to<S2SV_blank>process<S2SV_blank>security<S2SV_blank>" "descriptors<S2SV_blank>(%zu<S2SV_blank>bytes<S2SV_blank>left<S2SV_blank>vs<S2SV_blank>%zu<S2SV_blank>needed)\\n" , top - ( void * ) secd , needed ) ; return 0 ; } itr = ( void * ) secd + sizeof ( * secd ) ; top = ( void * ) secd + le16_to_cpu ( secd -> wTotalLength ) ; index = 0 ; bytes = 0 ; while ( itr < top ) { etd = itr ; if ( top - itr < sizeof ( * etd ) ) { dev_err ( dev , "BUG:<S2SV_blank>bad<S2SV_blank>host<S2SV_blank>security<S2SV_blank>descriptor;<S2SV_blank>" "not<S2SV_blank>enough<S2SV_blank>data<S2SV_blank>(%zu<S2SV_blank>vs<S2SV_blank>%zu<S2SV_blank>left)\\n" , top - itr , sizeof ( * etd ) ) ; break ; } if ( etd -> bLength < sizeof ( * etd ) ) { dev_err ( dev , "BUG:<S2SV_blank>bad<S2SV_blank>host<S2SV_blank>encryption<S2SV_blank>descriptor;<S2SV_blank>" "descriptor<S2SV_blank>is<S2SV_blank>too<S2SV_blank>short<S2SV_blank>" "(%zu<S2SV_blank>vs<S2SV_blank>%zu<S2SV_blank>needed)\\n" , ( size_t ) etd -> bLength , sizeof ( * etd ) ) ; break ; } itr += etd -> bLength ; bytes += snprintf ( buf + bytes , sizeof ( buf ) - bytes , "%s<S2SV_blank>(0x%02x)<S2SV_blank>" , wusb_et_name ( etd -> bEncryptionType ) , etd -> bEncryptionValue ) ; wusbhc -> ccm1_etd = etd ; } dev_info ( dev , "supported<S2SV_blank>encryption<S2SV_blank>types:<S2SV_blank>%s\\n" , buf ) ; if ( wusbhc -> ccm1_etd == NULL ) { dev_err ( dev , "E:<S2SV_blank>host<S2SV_blank>doesn\'t<S2SV_blank>support<S2SV_blank>CCM-1<S2SV_blank>crypto\\n" ) ; return 0 ; } return 0 ; }
void vp8_multiframe_quality_enhance ( VP8_COMMON * cm ) { YV12_BUFFER_CONFIG * show = cm -> frame_to_show ; YV12_BUFFER_CONFIG * dest = & cm -> post_proc_buffer ; FRAME_TYPE frame_type = cm -> frame_type ; const MODE_INFO * mode_info_context = cm -> show_frame_mi ; int mb_row ; int mb_col ; int totmap , map [ 4 ] ; int qcurr = cm -> base_qindex ; int qprev = cm -> postproc_state . last_base_qindex ; unsigned char * y_ptr , * u_ptr , * v_ptr ; unsigned char * yd_ptr , * ud_ptr , * vd_ptr ; y_ptr = show -> y_buffer ; u_ptr = show -> u_buffer ; v_ptr = show -> v_buffer ; yd_ptr = dest -> y_buffer ; ud_ptr = dest -> u_buffer ; vd_ptr = dest -> v_buffer ; for ( mb_row = 0 ; mb_row < cm -> mb_rows ; mb_row ++ ) { for ( mb_col = 0 ; mb_col < cm -> mb_cols ; mb_col ++ ) { if ( frame_type == INTER_FRAME ) totmap = qualify_inter_mb ( mode_info_context , map ) ; else totmap = ( frame_type == KEY_FRAME ? 4 : 0 ) ; if ( totmap ) { if ( totmap < 4 ) { int i , j ; for ( i = 0 ; i < 2 ; ++ i ) for ( j = 0 ; j < 2 ; ++ j ) { if ( map [ i * 2 + j ] ) { multiframe_quality_enhance_block ( 8 , qcurr , qprev , y_ptr + 8 * ( i * show -> y_stride + j ) , u_ptr + 4 * ( i * show -> uv_stride + j ) , v_ptr + 4 * ( i * show -> uv_stride + j ) , show -> y_stride , show -> uv_stride , yd_ptr + 8 * ( i * dest -> y_stride + j ) , ud_ptr + 4 * ( i * dest -> uv_stride + j ) , vd_ptr + 4 * ( i * dest -> uv_stride + j ) , dest -> y_stride , dest -> uv_stride ) ; } else { int k ; unsigned char * up = u_ptr + 4 * ( i * show -> uv_stride + j ) ; unsigned char * udp = ud_ptr + 4 * ( i * dest -> uv_stride + j ) ; unsigned char * vp = v_ptr + 4 * ( i * show -> uv_stride + j ) ; unsigned char * vdp = vd_ptr + 4 * ( i * dest -> uv_stride + j ) ; vp8_copy_mem8x8 ( y_ptr + 8 * ( i * show -> y_stride + j ) , show -> y_stride , yd_ptr + 8 * ( i * dest -> y_stride + j ) , dest -> y_stride ) ; for ( k = 0 ; k < 4 ; ++ k , up += show -> uv_stride , udp += dest -> uv_stride , vp += show -> uv_stride , vdp += dest -> uv_stride ) { <S2SV_StartBug> vpx_memcpy ( udp , up , 4 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memcpy ( vdp , vp , 4 ) ; <S2SV_EndBug> } } } } else { multiframe_quality_enhance_block ( 16 , qcurr , qprev , y_ptr , u_ptr , v_ptr , show -> y_stride , show -> uv_stride , yd_ptr , ud_ptr , vd_ptr , dest -> y_stride , dest -> uv_stride ) ; } } else { vp8_copy_mem16x16 ( y_ptr , show -> y_stride , yd_ptr , dest -> y_stride ) ; vp8_copy_mem8x8 ( u_ptr , show -> uv_stride , ud_ptr , dest -> uv_stride ) ; vp8_copy_mem8x8 ( v_ptr , show -> uv_stride , vd_ptr , dest -> uv_stride ) ; } y_ptr += 16 ; u_ptr += 8 ; v_ptr += 8 ; yd_ptr += 16 ; ud_ptr += 8 ; vd_ptr += 8 ; mode_info_context ++ ; } y_ptr += show -> y_stride * 16 - 16 * cm -> mb_cols ; u_ptr += show -> uv_stride * 8 - 8 * cm -> mb_cols ; v_ptr += show -> uv_stride * 8 - 8 * cm -> mb_cols ; yd_ptr += dest -> y_stride * 16 - 16 * cm -> mb_cols ; ud_ptr += dest -> uv_stride * 8 - 8 * cm -> mb_cols ; vd_ptr += dest -> uv_stride * 8 - 8 * cm -> mb_cols ; mode_info_context ++ ; } }
static int check_mem_access ( struct bpf_verifier_env * env , int insn_idx , u32 regno , int off , int bpf_size , enum bpf_access_type t , int value_regno ) { struct bpf_verifier_state * state = env -> cur_state ; struct bpf_reg_state * regs = cur_regs ( env ) ; struct bpf_reg_state * reg = regs + regno ; int size , err = 0 ; size = bpf_size_to_bytes ( bpf_size ) ; if ( size < 0 ) return size ; err = check_ptr_alignment ( env , reg , off , size ) ; if ( err ) return err ; off += reg -> off ; if ( reg -> type == PTR_TO_MAP_VALUE ) { if ( t == BPF_WRITE && value_regno >= 0 && is_pointer_value ( env , value_regno ) ) { verbose ( env , "R%d<S2SV_blank>leaks<S2SV_blank>addr<S2SV_blank>into<S2SV_blank>map\\n" , value_regno ) ; return - EACCES ; } err = check_map_access ( env , regno , off , size , false ) ; if ( ! err && t == BPF_READ && value_regno >= 0 ) mark_reg_unknown ( env , regs , value_regno ) ; } else if ( reg -> type == PTR_TO_CTX ) { enum bpf_reg_type reg_type = SCALAR_VALUE ; if ( t == BPF_WRITE && value_regno >= 0 && is_pointer_value ( env , value_regno ) ) { verbose ( env , "R%d<S2SV_blank>leaks<S2SV_blank>addr<S2SV_blank>into<S2SV_blank>ctx\\n" , value_regno ) ; return - EACCES ; } if ( reg -> off ) { verbose ( env , "dereference<S2SV_blank>of<S2SV_blank>modified<S2SV_blank>ctx<S2SV_blank>ptr<S2SV_blank>R%d<S2SV_blank>off=%d+%d,<S2SV_blank>ctx+const<S2SV_blank>is<S2SV_blank>allowed,<S2SV_blank>ctx+const+const<S2SV_blank>is<S2SV_blank>not\\n" , regno , reg -> off , off - reg -> off ) ; return - EACCES ; } if ( ! tnum_is_const ( reg -> var_off ) || reg -> var_off . value ) { char tn_buf [ 48 ] ; tnum_strn ( tn_buf , sizeof ( tn_buf ) , reg -> var_off ) ; verbose ( env , "variable<S2SV_blank>ctx<S2SV_blank>access<S2SV_blank>var_off=%s<S2SV_blank>off=%d<S2SV_blank>size=%d" , tn_buf , off , size ) ; return - EACCES ; } err = check_ctx_access ( env , insn_idx , off , size , t , & reg_type ) ; if ( ! err && t == BPF_READ && value_regno >= 0 ) { if ( reg_type == SCALAR_VALUE ) mark_reg_unknown ( env , regs , value_regno ) ; else mark_reg_known_zero ( env , regs , value_regno ) ; regs [ value_regno ] . id = 0 ; regs [ value_regno ] . off = 0 ; regs [ value_regno ] . range = 0 ; regs [ value_regno ] . type = reg_type ; } } else if ( reg -> type == PTR_TO_STACK ) { if ( ! tnum_is_const ( reg -> var_off ) ) { char tn_buf [ 48 ] ; tnum_strn ( tn_buf , sizeof ( tn_buf ) , reg -> var_off ) ; verbose ( env , "variable<S2SV_blank>stack<S2SV_blank>access<S2SV_blank>var_off=%s<S2SV_blank>off=%d<S2SV_blank>size=%d" , tn_buf , off , size ) ; return - EACCES ; } off += reg -> var_off . value ; if ( off >= 0 || off < - MAX_BPF_STACK ) { verbose ( env , "invalid<S2SV_blank>stack<S2SV_blank>off=%d<S2SV_blank>size=%d\\n" , off , size ) ; return - EACCES ; } if ( env -> prog -> aux -> stack_depth < - off ) env -> prog -> aux -> stack_depth = - off ; if ( t == BPF_WRITE ) err = check_stack_write ( env , state , off , size , value_regno ) ; else err = check_stack_read ( env , state , off , size , value_regno ) ; } else if ( reg_is_pkt_pointer ( reg ) ) { if ( t == BPF_WRITE && ! may_access_direct_pkt_data ( env , NULL , t ) ) { verbose ( env , "cannot<S2SV_blank>write<S2SV_blank>into<S2SV_blank>packet\\n" ) ; return - EACCES ; } if ( t == BPF_WRITE && value_regno >= 0 && is_pointer_value ( env , value_regno ) ) { verbose ( env , "R%d<S2SV_blank>leaks<S2SV_blank>addr<S2SV_blank>into<S2SV_blank>packet\\n" , value_regno ) ; return - EACCES ; } err = check_packet_access ( env , regno , off , size , false ) ; if ( ! err && t == BPF_READ && value_regno >= 0 ) mark_reg_unknown ( env , regs , value_regno ) ; } else { verbose ( env , "R%d<S2SV_blank>invalid<S2SV_blank>mem<S2SV_blank>access<S2SV_blank>\'%s\'\\n" , regno , reg_type_str [ reg -> type ] ) ; return - EACCES ; } if ( ! err && size < BPF_REG_SIZE && value_regno >= 0 && t == BPF_READ && regs [ value_regno ] . type == SCALAR_VALUE ) { <S2SV_StartBug> regs [ value_regno ] . var_off = <S2SV_EndBug> tnum_cast ( regs [ value_regno ] . var_off , size ) ; __update_reg_bounds ( & regs [ value_regno ] ) ; } return err ; }
static gboolean netscreen_read ( wtap * wth , int * err , gchar * * err_info , gint64 * data_offset ) { gint64 offset ; <S2SV_StartBug> int pkt_len ; <S2SV_EndBug> <S2SV_StartBug> char line [ NETSCREEN_LINE_LENGTH ] ; <S2SV_EndBug> char cap_int [ NETSCREEN_MAX_INT_NAME_LENGTH ] ; gboolean cap_dir ; char cap_dst [ 13 ] ; offset = netscreen_seek_next_packet ( wth , err , err_info , line ) ; if ( offset < 0 ) return FALSE ; <S2SV_StartBug> pkt_len = parse_netscreen_rec_hdr ( & wth -> phdr , line , cap_int , & cap_dir , <S2SV_EndBug> cap_dst , err , err_info ) ; if ( pkt_len == - 1 ) return FALSE ; <S2SV_StartBug> if ( ! parse_netscreen_hex_dump ( wth -> fh , pkt_len , cap_int , <S2SV_EndBug> <S2SV_StartBug> cap_dst , & wth -> phdr , wth -> frame_buffer , err , err_info ) ) <S2SV_EndBug> return FALSE ; if ( wth -> file_encap == WTAP_ENCAP_UNKNOWN ) wth -> file_encap = wth -> phdr . pkt_encap ; else { if ( wth -> file_encap != wth -> phdr . pkt_encap ) wth -> file_encap = WTAP_ENCAP_PER_PACKET ; } * data_offset = offset ; return TRUE ; }
static int kwajd_read_headers ( struct mspack_system * sys , struct mspack_file * fh , struct mskwajd_header * hdr ) { unsigned char buf [ 16 ] ; int i ; if ( sys -> read ( fh , & buf [ 0 ] , kwajh_SIZEOF ) != kwajh_SIZEOF ) { return MSPACK_ERR_READ ; } if ( ( ( unsigned int ) EndGetI32 ( & buf [ kwajh_Signature1 ] ) != 0x4A41574B ) || ( ( unsigned int ) EndGetI32 ( & buf [ kwajh_Signature2 ] ) != 0xD127F088 ) ) { return MSPACK_ERR_SIGNATURE ; } hdr -> comp_type = EndGetI16 ( & buf [ kwajh_CompMethod ] ) ; hdr -> data_offset = EndGetI16 ( & buf [ kwajh_DataOffset ] ) ; hdr -> headers = EndGetI16 ( & buf [ kwajh_Flags ] ) ; hdr -> length = 0 ; hdr -> filename = NULL ; hdr -> extra = NULL ; hdr -> extra_length = 0 ; if ( hdr -> headers & MSKWAJ_HDR_HASLENGTH ) { if ( sys -> read ( fh , & buf [ 0 ] , 4 ) != 4 ) return MSPACK_ERR_READ ; hdr -> length = EndGetI32 ( & buf [ 0 ] ) ; } if ( hdr -> headers & MSKWAJ_HDR_HASUNKNOWN1 ) { if ( sys -> read ( fh , & buf [ 0 ] , 2 ) != 2 ) return MSPACK_ERR_READ ; } if ( hdr -> headers & MSKWAJ_HDR_HASUNKNOWN2 ) { if ( sys -> read ( fh , & buf [ 0 ] , 2 ) != 2 ) return MSPACK_ERR_READ ; i = EndGetI16 ( & buf [ 0 ] ) ; if ( sys -> seek ( fh , ( off_t ) i , MSPACK_SYS_SEEK_CUR ) ) return MSPACK_ERR_SEEK ; } if ( hdr -> headers & ( MSKWAJ_HDR_HASFILENAME | MSKWAJ_HDR_HASFILEEXT ) ) { <S2SV_StartBug> off_t pos = sys -> tell ( fh ) ; <S2SV_EndBug> char * fn = ( char * ) sys -> alloc ( sys , ( size_t ) 13 ) ; <S2SV_StartBug> if ( ! fn ) return MSPACK_ERR_NOMEMORY ; <S2SV_EndBug> <S2SV_StartBug> hdr -> filename = fn ; <S2SV_EndBug> if ( hdr -> headers & MSKWAJ_HDR_HASFILENAME ) { <S2SV_StartBug> if ( sys -> read ( fh , & buf [ 0 ] , 9 ) != 9 ) return MSPACK_ERR_READ ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < 9 ; i ++ , fn ++ ) if ( ! ( * fn = buf [ i ] ) ) break ; <S2SV_EndBug> <S2SV_StartBug> pos += ( i < 9 ) ? i + 1 : 9 ; <S2SV_EndBug> if ( sys -> seek ( fh , pos , MSPACK_SYS_SEEK_START ) ) <S2SV_StartBug> return MSPACK_ERR_SEEK ; <S2SV_EndBug> } if ( hdr -> headers & MSKWAJ_HDR_HASFILEEXT ) { * fn ++ = '.' ; <S2SV_StartBug> if ( sys -> read ( fh , & buf [ 0 ] , 4 ) != 4 ) return MSPACK_ERR_READ ; <S2SV_EndBug> <S2SV_StartBug> for ( i = 0 ; i < 4 ; i ++ , fn ++ ) if ( ! ( * fn = buf [ i ] ) ) break ; <S2SV_EndBug> <S2SV_StartBug> pos += ( i < 4 ) ? i + 1 : 4 ; <S2SV_EndBug> if ( sys -> seek ( fh , pos , MSPACK_SYS_SEEK_START ) ) <S2SV_StartBug> return MSPACK_ERR_SEEK ; <S2SV_EndBug> } * fn = '\\0' ; } if ( hdr -> headers & MSKWAJ_HDR_HASEXTRATEXT ) { if ( sys -> read ( fh , & buf [ 0 ] , 2 ) != 2 ) return MSPACK_ERR_READ ; i = EndGetI16 ( & buf [ 0 ] ) ; hdr -> extra = ( char * ) sys -> alloc ( sys , ( size_t ) i + 1 ) ; if ( ! hdr -> extra ) return MSPACK_ERR_NOMEMORY ; if ( sys -> read ( fh , hdr -> extra , i ) != i ) return MSPACK_ERR_READ ; hdr -> extra [ i ] = '\\0' ; hdr -> extra_length = i ; } return MSPACK_ERR_OK ; }
int oe_iov_pack ( const struct oe_iovec * iov , int iovcnt , void * * buf_out , <S2SV_StartBug> size_t * buf_size_out ) <S2SV_EndBug> { int ret = - 1 ; struct oe_iovec * buf = NULL ; size_t buf_size = 0 ; size_t data_size = 0 ; if ( buf_out ) * buf_out = NULL ; if ( buf_size_out ) * buf_size_out = 0 ; <S2SV_StartBug> if ( iovcnt < 0 || ( iovcnt > 0 && ! iov ) || ! buf_out || ! buf_size_out ) <S2SV_EndBug> goto done ; if ( iovcnt == 0 ) { if ( iov ) { if ( ! ( buf = oe_calloc ( 1 , sizeof ( uint64_t ) ) ) ) goto done ; buf_size = sizeof ( uint64_t ) ; } * buf_out = buf ; <S2SV_StartBug> * buf_size_out = buf_size ; <S2SV_EndBug> buf = NULL ; ret = 0 ; goto done ; } for ( int i = 0 ; i < iovcnt ; i ++ ) data_size += iov [ i ] . iov_len ; buf_size = ( sizeof ( struct oe_iovec ) * ( size_t ) iovcnt ) + data_size ; if ( ! ( buf = oe_calloc ( 1 , buf_size ) ) ) goto done ; { uint8_t * p = ( uint8_t * ) & buf [ iovcnt ] ; size_t n = data_size ; int i ; for ( i = 0 ; i < iovcnt ; i ++ ) { const size_t iov_len = iov [ i ] . iov_len ; const void * iov_base = iov [ i ] . iov_base ; if ( iov_len ) { buf [ i ] . iov_len = iov_len ; buf [ i ] . iov_base = ( void * ) ( p - ( uint8_t * ) buf ) ; if ( ! iov_base ) goto done ; if ( oe_memcpy_s ( p , n , iov_base , iov_len ) != OE_OK ) goto done ; p += iov_len ; n -= iov_len ; } } if ( n != 0 ) goto done ; } * buf_out = buf ; * buf_size_out = buf_size ; <S2SV_StartBug> buf = NULL ; <S2SV_EndBug> ret = 0 ; done : if ( buf ) oe_free ( buf ) ; return ret ; }
static int jpc_siz_getparms ( jpc_ms_t * ms , jpc_cstate_t * cstate , jas_stream_t * in ) { jpc_siz_t * siz = & ms -> parms . siz ; unsigned int i ; uint_fast8_t tmp ; cstate = 0 ; if ( jpc_getuint16 ( in , & siz -> caps ) || jpc_getuint32 ( in , & siz -> width ) || jpc_getuint32 ( in , & siz -> height ) || jpc_getuint32 ( in , & siz -> xoff ) || jpc_getuint32 ( in , & siz -> yoff ) || jpc_getuint32 ( in , & siz -> tilewidth ) || jpc_getuint32 ( in , & siz -> tileheight ) || jpc_getuint32 ( in , & siz -> tilexoff ) || jpc_getuint32 ( in , & siz -> tileyoff ) || jpc_getuint16 ( in , & siz -> numcomps ) ) { return - 1 ; } if ( ! siz -> width || ! siz -> height || ! siz -> tilewidth || ! siz -> tileheight || ! siz -> numcomps || siz -> numcomps > 16384 ) { return - 1 ; } <S2SV_StartBug> if ( ! ( siz -> comps = jas_alloc2 ( siz -> numcomps , sizeof ( jpc_sizcomp_t ) ) ) ) { <S2SV_EndBug> return - 1 ; } for ( i = 0 ; i < siz -> numcomps ; ++ i ) { if ( jpc_getuint8 ( in , & tmp ) || jpc_getuint8 ( in , & siz -> comps [ i ] . hsamp ) || jpc_getuint8 ( in , & siz -> comps [ i ] . vsamp ) ) { jas_free ( siz -> comps ) ; return - 1 ; } if ( siz -> comps [ i ] . hsamp == 0 || siz -> comps [ i ] . hsamp > 255 ) { jas_eprintf ( "invalid<S2SV_blank>XRsiz<S2SV_blank>value<S2SV_blank>%d\\n" , siz -> comps [ i ] . hsamp ) ; jas_free ( siz -> comps ) ; return - 1 ; } if ( siz -> comps [ i ] . vsamp == 0 || siz -> comps [ i ] . vsamp > 255 ) { jas_eprintf ( "invalid<S2SV_blank>YRsiz<S2SV_blank>value<S2SV_blank>%d\\n" , siz -> comps [ i ] . vsamp ) ; jas_free ( siz -> comps ) ; return - 1 ; } siz -> comps [ i ] . sgnd = ( tmp >> 7 ) & 1 ; siz -> comps [ i ] . prec = ( tmp & 0x7f ) + 1 ; } if ( jas_stream_eof ( in ) ) { jas_free ( siz -> comps ) ; return - 1 ; } return 0 ; }
static __be32 nfsacld_proc_setacl ( struct svc_rqst * rqstp , struct nfsd3_setaclargs * argp , struct nfsd_attrstat * resp ) { struct inode * inode ; svc_fh * fh ; __be32 nfserr = 0 ; int error ; dprintk ( "nfsd:<S2SV_blank>SETACL(2acl)<S2SV_blank><S2SV_blank><S2SV_blank>%s\\n" , SVCFH_fmt ( & argp -> fh ) ) ; fh = fh_copy ( & resp -> fh , & argp -> fh ) ; nfserr = fh_verify ( rqstp , & resp -> fh , 0 , NFSD_MAY_SATTR ) ; if ( nfserr ) goto out ; inode = d_inode ( fh -> fh_dentry ) ; <S2SV_StartBug> if ( ! IS_POSIXACL ( inode ) || ! inode -> i_op -> set_acl ) { <S2SV_EndBug> error = - EOPNOTSUPP ; goto out_errno ; <S2SV_StartBug> } <S2SV_EndBug> error = fh_want_write ( fh ) ; if ( error ) goto out_errno ; <S2SV_StartBug> error = inode -> i_op -> set_acl ( inode , argp -> acl_access , ACL_TYPE_ACCESS ) ; <S2SV_EndBug> if ( error ) goto out_drop_write ; <S2SV_StartBug> error = inode -> i_op -> set_acl ( inode , argp -> acl_default , <S2SV_EndBug> ACL_TYPE_DEFAULT ) ; if ( error ) goto out_drop_write ; fh_drop_write ( fh ) ; nfserr = fh_getattr ( fh , & resp -> stat ) ; out : posix_acl_release ( argp -> acl_access ) ; posix_acl_release ( argp -> acl_default ) ; return nfserr ; <S2SV_StartBug> out_drop_write : <S2SV_EndBug> fh_drop_write ( fh ) ; out_errno : nfserr = nfserrno ( error ) ; goto out ; }
int _yr_scan_verify_re_match ( YR_SCAN_CONTEXT * context , YR_AC_MATCH * ac_match , uint8_t * data , size_t data_size , size_t data_base , size_t offset ) { CALLBACK_ARGS callback_args ; RE_EXEC_FUNC exec ; int forward_matches = - 1 ; int backward_matches = - 1 ; int flags = 0 ; if ( STRING_IS_GREEDY_REGEXP ( ac_match -> string ) ) flags |= RE_FLAGS_GREEDY ; if ( STRING_IS_NO_CASE ( ac_match -> string ) ) flags |= RE_FLAGS_NO_CASE ; if ( STRING_IS_DOT_ALL ( ac_match -> string ) ) flags |= RE_FLAGS_DOT_ALL ; if ( STRING_IS_FAST_REGEXP ( ac_match -> string ) ) exec = yr_re_fast_exec ; else exec = yr_re_exec ; if ( STRING_IS_ASCII ( ac_match -> string ) ) { forward_matches = exec ( ac_match -> forward_code , data + offset , data_size - offset , <S2SV_StartBug> offset > 0 ? flags | RE_FLAGS_NOT_AT_START : flags , <S2SV_EndBug> NULL , NULL ) ; } if ( STRING_IS_WIDE ( ac_match -> string ) && forward_matches == - 1 ) { flags |= RE_FLAGS_WIDE ; forward_matches = exec ( ac_match -> forward_code , data + offset , data_size - offset , <S2SV_StartBug> offset > 0 ? flags | RE_FLAGS_NOT_AT_START : flags , <S2SV_EndBug> NULL , NULL ) ; } switch ( forward_matches ) { case - 1 : return ERROR_SUCCESS ; case - 2 : return ERROR_INSUFFICIENT_MEMORY ; case - 3 : return ERROR_TOO_MANY_MATCHES ; case - 4 : return ERROR_TOO_MANY_RE_FIBERS ; case - 5 : return ERROR_INTERNAL_FATAL_ERROR ; } if ( forward_matches == 0 && ac_match -> backward_code == NULL ) return ERROR_SUCCESS ; callback_args . string = ac_match -> string ; callback_args . context = context ; callback_args . data = data ; callback_args . data_size = data_size ; callback_args . data_base = data_base ; callback_args . forward_matches = forward_matches ; callback_args . full_word = STRING_IS_FULL_WORD ( ac_match -> string ) ; if ( ac_match -> backward_code != NULL ) { backward_matches = exec ( ac_match -> backward_code , <S2SV_StartBug> data + offset , <S2SV_EndBug> offset , flags | RE_FLAGS_BACKWARDS | RE_FLAGS_EXHAUSTIVE , _yr_scan_match_callback , ( void * ) & callback_args ) ; switch ( backward_matches ) { case - 2 : return ERROR_INSUFFICIENT_MEMORY ; case - 3 : return ERROR_TOO_MANY_MATCHES ; case - 4 : return ERROR_TOO_MANY_RE_FIBERS ; case - 5 : return ERROR_INTERNAL_FATAL_ERROR ; } } else { FAIL_ON_ERROR ( _yr_scan_match_callback ( data + offset , 0 , flags , & callback_args ) ) ; } return ERROR_SUCCESS ; }
static int rock_continue ( struct rock_state * rs ) { int ret = 1 ; int blocksize = 1 << rs -> inode -> i_blkbits ; const int min_de_size = offsetof ( struct rock_ridge , u ) ; kfree ( rs -> buffer ) ; rs -> buffer = NULL ; if ( ( unsigned ) rs -> cont_offset > blocksize - min_de_size || ( unsigned ) rs -> cont_size > blocksize || ( unsigned ) ( rs -> cont_offset + rs -> cont_size ) > blocksize ) { printk ( KERN_NOTICE "rock:<S2SV_blank>corrupted<S2SV_blank>directory<S2SV_blank>entry.<S2SV_blank>" "extent=%d,<S2SV_blank>offset=%d,<S2SV_blank>size=%d\\n" , rs -> cont_extent , rs -> cont_offset , rs -> cont_size ) ; ret = - EIO ; goto out ; } if ( rs -> cont_extent ) { struct buffer_head * bh ; rs -> buffer = kmalloc ( rs -> cont_size , GFP_KERNEL ) ; if ( ! rs -> buffer ) { ret = - ENOMEM ; goto out ; } ret = - EIO ; <S2SV_StartBug> bh = sb_bread ( rs -> inode -> i_sb , rs -> cont_extent ) ; <S2SV_EndBug> if ( bh ) { memcpy ( rs -> buffer , bh -> b_data + rs -> cont_offset , rs -> cont_size ) ; put_bh ( bh ) ; rs -> chr = rs -> buffer ; rs -> len = rs -> cont_size ; rs -> cont_extent = 0 ; rs -> cont_size = 0 ; rs -> cont_offset = 0 ; return 0 ; } printk ( "Unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>rock-ridge<S2SV_blank>attributes\\n" ) ; } out : kfree ( rs -> buffer ) ; rs -> buffer = NULL ; return ret ; }
PHP_FUNCTION ( imageconvolution ) { zval * SIM , * hash_matrix ; zval * * var = NULL , * * var2 = NULL ; gdImagePtr im_src = NULL ; double div , offset ; int nelem , i , j , res ; float matrix [ 3 ] [ 3 ] = { { 0 , 0 , 0 } , { 0 , 0 , 0 } , { 0 , 0 , 0 } } ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , "radd" , & SIM , & hash_matrix , & div , & offset ) == FAILURE ) { RETURN_FALSE ; } ZEND_FETCH_RESOURCE ( im_src , gdImagePtr , & SIM , - 1 , "Image" , le_gd ) ; nelem = zend_hash_num_elements ( Z_ARRVAL_P ( hash_matrix ) ) ; if ( nelem != 3 ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , "You<S2SV_blank>must<S2SV_blank>have<S2SV_blank>3x3<S2SV_blank>array" ) ; RETURN_FALSE ; } for ( i = 0 ; i < 3 ; i ++ ) { if ( zend_hash_index_find ( Z_ARRVAL_P ( hash_matrix ) , ( i ) , ( void * * ) & var ) == SUCCESS && Z_TYPE_PP ( var ) == IS_ARRAY ) { if ( Z_TYPE_PP ( var ) != IS_ARRAY || zend_hash_num_elements ( Z_ARRVAL_PP ( var ) ) != 3 ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , "You<S2SV_blank>must<S2SV_blank>have<S2SV_blank>3x3<S2SV_blank>array" ) ; RETURN_FALSE ; } for ( j = 0 ; j < 3 ; j ++ ) { if ( zend_hash_index_find ( Z_ARRVAL_PP ( var ) , ( j ) , ( void * * ) & var2 ) == SUCCESS ) { <S2SV_StartBug> SEPARATE_ZVAL ( var2 ) ; <S2SV_EndBug> <S2SV_StartBug> convert_to_double ( * var2 ) ; <S2SV_EndBug> <S2SV_StartBug> matrix [ i ] [ j ] = ( float ) Z_DVAL_PP ( var2 ) ; <S2SV_EndBug> } else { <S2SV_StartBug> php_error_docref ( NULL TSRMLS_CC , E_WARNING , "You<S2SV_blank>must<S2SV_blank>have<S2SV_blank>a<S2SV_blank>3x3<S2SV_blank>matrix" ) ; <S2SV_EndBug> RETURN_FALSE ; } } <S2SV_StartBug> } <S2SV_EndBug> } res = gdImageConvolution ( im_src , matrix , ( float ) div , ( float ) offset ) ; if ( res ) { RETURN_TRUE ; } else { RETURN_FALSE ; } }
static int __f2fs_set_acl ( struct inode * inode , int type , struct posix_acl * acl , struct page * ipage ) { int name_index ; void * value = NULL ; size_t size = 0 ; int error ; switch ( type ) { case ACL_TYPE_ACCESS : name_index = F2FS_XATTR_INDEX_POSIX_ACL_ACCESS ; if ( acl ) { <S2SV_StartBug> error = posix_acl_equiv_mode ( acl , & inode -> i_mode ) ; <S2SV_EndBug> if ( error < 0 ) return error ; <S2SV_StartBug> set_acl_inode ( inode , inode -> i_mode ) ; <S2SV_EndBug> if ( error == 0 ) acl = NULL ; } break ; case ACL_TYPE_DEFAULT : name_index = F2FS_XATTR_INDEX_POSIX_ACL_DEFAULT ; if ( ! S_ISDIR ( inode -> i_mode ) ) return acl ? - EACCES : 0 ; break ; default : return - EINVAL ; } if ( acl ) { value = f2fs_acl_to_disk ( acl , & size ) ; if ( IS_ERR ( value ) ) { clear_inode_flag ( inode , FI_ACL_MODE ) ; return ( int ) PTR_ERR ( value ) ; } } error = f2fs_setxattr ( inode , name_index , "" , value , size , ipage , 0 ) ; kfree ( value ) ; if ( ! error ) set_cached_acl ( inode , type , acl ) ; clear_inode_flag ( inode , FI_ACL_MODE ) ; return error ; }
static void cyclic_background_refresh ( VP8_COMP * cpi , int Q , int lf_adjustment ) { unsigned char * seg_map = cpi -> segmentation_map ; signed char feature_data [ MB_LVL_MAX ] [ MAX_MB_SEGMENTS ] ; int i ; int block_count = cpi -> cyclic_refresh_mode_max_mbs_perframe ; int mbs_in_frame = cpi -> common . mb_rows * cpi -> common . mb_cols ; cpi -> cyclic_refresh_q = Q / 2 ; <S2SV_StartBug> vpx_memset ( cpi -> segmentation_map , 0 , mbs_in_frame ) ; <S2SV_EndBug> <S2SV_StartBug> if ( cpi -> common . frame_type != KEY_FRAME ) <S2SV_EndBug> { i = cpi -> cyclic_refresh_mode_index ; assert ( i < mbs_in_frame ) ; do { if ( cpi -> cyclic_refresh_map [ i ] == 0 ) { seg_map [ i ] = 1 ; block_count -- ; } else if ( cpi -> cyclic_refresh_map [ i ] < 0 ) cpi -> cyclic_refresh_map [ i ] ++ ; i ++ ; if ( i == mbs_in_frame ) i = 0 ; } while ( block_count && i != cpi -> cyclic_refresh_mode_index ) ; <S2SV_StartBug> cpi -> cyclic_refresh_mode_index = i ; <S2SV_EndBug> } cpi -> mb . e_mbd . update_mb_segmentation_map = 1 ; cpi -> mb . e_mbd . update_mb_segmentation_data = 1 ; enable_segmentation ( cpi ) ; feature_data [ MB_LVL_ALT_Q ] [ 0 ] = 0 ; feature_data [ MB_LVL_ALT_Q ] [ 1 ] = ( cpi -> cyclic_refresh_q - Q ) ; feature_data [ MB_LVL_ALT_Q ] [ 2 ] = 0 ; feature_data [ MB_LVL_ALT_Q ] [ 3 ] = 0 ; feature_data [ MB_LVL_ALT_LF ] [ 0 ] = 0 ; feature_data [ MB_LVL_ALT_LF ] [ 1 ] = lf_adjustment ; feature_data [ MB_LVL_ALT_LF ] [ 2 ] = 0 ; feature_data [ MB_LVL_ALT_LF ] [ 3 ] = 0 ; set_segment_data ( cpi , & feature_data [ 0 ] [ 0 ] , SEGMENT_DELTADATA ) ; }
static int mp_get_count ( struct sb_uart_state * state , struct serial_icounter_struct * icnt ) { <S2SV_StartBug> struct serial_icounter_struct icount ; <S2SV_EndBug> struct sb_uart_icount cnow ; struct sb_uart_port * port = state -> port ; spin_lock_irq ( & port -> lock ) ; memcpy ( & cnow , & port -> icount , sizeof ( struct sb_uart_icount ) ) ; spin_unlock_irq ( & port -> lock ) ; icount . cts = cnow . cts ; icount . dsr = cnow . dsr ; icount . rng = cnow . rng ; icount . dcd = cnow . dcd ; icount . rx = cnow . rx ; icount . tx = cnow . tx ; icount . frame = cnow . frame ; icount . overrun = cnow . overrun ; icount . parity = cnow . parity ; icount . brk = cnow . brk ; icount . buf_overrun = cnow . buf_overrun ; return copy_to_user ( icnt , & icount , sizeof ( icount ) ) ? - EFAULT : 0 ; }
static int check_cond_jmp_op ( struct bpf_verifier_env * env , struct bpf_insn * insn , int * insn_idx ) { struct bpf_verifier_state * this_branch = env -> cur_state ; struct bpf_verifier_state * other_branch ; struct bpf_reg_state * regs = this_branch -> frame [ this_branch -> curframe ] -> regs ; struct bpf_reg_state * dst_reg , * other_branch_regs ; u8 opcode = BPF_OP ( insn -> code ) ; int err ; if ( opcode > BPF_JSLE ) { verbose ( env , "invalid<S2SV_blank>BPF_JMP<S2SV_blank>opcode<S2SV_blank>%x\\n" , opcode ) ; return - EINVAL ; } if ( BPF_SRC ( insn -> code ) == BPF_X ) { if ( insn -> imm != 0 ) { verbose ( env , "BPF_JMP<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n" ) ; return - EINVAL ; } err = check_reg_arg ( env , insn -> src_reg , SRC_OP ) ; if ( err ) return err ; if ( is_pointer_value ( env , insn -> src_reg ) ) { verbose ( env , "R%d<S2SV_blank>pointer<S2SV_blank>comparison<S2SV_blank>prohibited\\n" , insn -> src_reg ) ; return - EACCES ; } } else { if ( insn -> src_reg != BPF_REG_0 ) { verbose ( env , "BPF_JMP<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n" ) ; return - EINVAL ; } } err = check_reg_arg ( env , insn -> dst_reg , SRC_OP ) ; if ( err ) return err ; dst_reg = & regs [ insn -> dst_reg ] ; if ( BPF_SRC ( insn -> code ) == BPF_K ) { int pred = is_branch_taken ( dst_reg , insn -> imm , opcode ) ; if ( pred == 1 ) { * insn_idx += insn -> off ; return 0 ; } else if ( pred == 0 ) { return 0 ; } } <S2SV_StartBug> other_branch = push_stack ( env , * insn_idx + insn -> off + 1 , * insn_idx ) ; <S2SV_EndBug> if ( ! other_branch ) return - EFAULT ; other_branch_regs = other_branch -> frame [ other_branch -> curframe ] -> regs ; if ( BPF_SRC ( insn -> code ) == BPF_X ) { if ( dst_reg -> type == SCALAR_VALUE && regs [ insn -> src_reg ] . type == SCALAR_VALUE ) { if ( tnum_is_const ( regs [ insn -> src_reg ] . var_off ) ) reg_set_min_max ( & other_branch_regs [ insn -> dst_reg ] , dst_reg , regs [ insn -> src_reg ] . var_off . value , opcode ) ; else if ( tnum_is_const ( dst_reg -> var_off ) ) reg_set_min_max_inv ( & other_branch_regs [ insn -> src_reg ] , & regs [ insn -> src_reg ] , dst_reg -> var_off . value , opcode ) ; else if ( opcode == BPF_JEQ || opcode == BPF_JNE ) reg_combine_min_max ( & other_branch_regs [ insn -> src_reg ] , & other_branch_regs [ insn -> dst_reg ] , & regs [ insn -> src_reg ] , & regs [ insn -> dst_reg ] , opcode ) ; } } else if ( dst_reg -> type == SCALAR_VALUE ) { reg_set_min_max ( & other_branch_regs [ insn -> dst_reg ] , dst_reg , insn -> imm , opcode ) ; } if ( BPF_SRC ( insn -> code ) == BPF_K && insn -> imm == 0 && ( opcode == BPF_JEQ || opcode == BPF_JNE ) && reg_type_may_be_null ( dst_reg -> type ) ) { mark_ptr_or_null_regs ( this_branch , insn -> dst_reg , opcode == BPF_JNE ) ; mark_ptr_or_null_regs ( other_branch , insn -> dst_reg , opcode == BPF_JEQ ) ; } else if ( ! try_match_pkt_pointers ( insn , dst_reg , & regs [ insn -> src_reg ] , this_branch , other_branch ) && is_pointer_value ( env , insn -> dst_reg ) ) { verbose ( env , "R%d<S2SV_blank>pointer<S2SV_blank>comparison<S2SV_blank>prohibited\\n" , insn -> dst_reg ) ; return - EACCES ; } if ( env -> log . level ) print_verifier_state ( env , this_branch -> frame [ this_branch -> curframe ] ) ; return 0 ; }
void openscript ( char_u * name , int directly ) { if ( curscript + 1 == NSCRIPT ) { emsg ( _ ( e_nesting ) ) ; return ; <S2SV_StartBug> } <S2SV_EndBug> # ifdef FEAT_EVAL if ( ignore_script ) return ; # endif if ( scriptin [ curscript ] != NULL ) ++ curscript ; expand_env ( name , NameBuff , MAXPATHL ) ; if ( ( scriptin [ curscript ] = mch_fopen ( ( char * ) NameBuff , READBIN ) ) == NULL ) { semsg ( _ ( e_notopen ) , name ) ; if ( curscript ) -- curscript ; return ; } if ( save_typebuf ( ) == FAIL ) return ; if ( directly ) { oparg_T oa ; int oldcurscript ; int save_State = State ; int save_restart_edit = restart_edit ; int save_insertmode = p_im ; int save_finish_op = finish_op ; int save_msg_scroll = msg_scroll ; State = NORMAL ; msg_scroll = FALSE ; restart_edit = 0 ; p_im = FALSE ; clear_oparg ( & oa ) ; finish_op = FALSE ; oldcurscript = curscript ; do { update_topline_cursor ( ) ; normal_cmd ( & oa , FALSE ) ; vpeekc ( ) ; } while ( scriptin [ oldcurscript ] != NULL ) ; State = save_State ; msg_scroll = save_msg_scroll ; restart_edit = save_restart_edit ; p_im = save_insertmode ; finish_op = save_finish_op ; } }
static int magicmouse_raw_event ( struct hid_device * hdev , struct hid_report * report , u8 * data , int size ) { struct magicmouse_sc * msc = hid_get_drvdata ( hdev ) ; struct input_dev * input = msc -> input ; int x = 0 , y = 0 , ii , clicks = 0 , npoints ; switch ( data [ 0 ] ) { case TRACKPAD_REPORT_ID : if ( size < 4 || ( ( size - 4 ) % 9 ) != 0 ) return 0 ; npoints = ( size - 4 ) / 9 ; <S2SV_StartBug> msc -> ntouches = 0 ; <S2SV_EndBug> for ( ii = 0 ; ii < npoints ; ii ++ ) magicmouse_emit_touch ( msc , ii , data + ii * 9 + 4 ) ; clicks = data [ 1 ] ; break ; case MOUSE_REPORT_ID : if ( size < 6 || ( ( size - 6 ) % 8 ) != 0 ) return 0 ; <S2SV_StartBug> npoints = ( size - 6 ) / 8 ; <S2SV_EndBug> msc -> ntouches = 0 ; for ( ii = 0 ; ii < npoints ; ii ++ ) magicmouse_emit_touch ( msc , ii , data + ii * 8 + 6 ) ; x = ( int ) ( ( ( data [ 3 ] & 0x0c ) << 28 ) | ( data [ 1 ] << 22 ) ) >> 22 ; y = ( int ) ( ( ( data [ 3 ] & 0x30 ) << 26 ) | ( data [ 2 ] << 22 ) ) >> 22 ; clicks = data [ 3 ] ; break ; case DOUBLE_REPORT_ID : magicmouse_raw_event ( hdev , report , data + 2 , data [ 1 ] ) ; magicmouse_raw_event ( hdev , report , data + 2 + data [ 1 ] , size - 2 - data [ 1 ] ) ; break ; default : return 0 ; } if ( input -> id . product == USB_DEVICE_ID_APPLE_MAGICMOUSE ) { magicmouse_emit_buttons ( msc , clicks & 3 ) ; input_report_rel ( input , REL_X , x ) ; input_report_rel ( input , REL_Y , y ) ; } else { input_report_key ( input , BTN_MOUSE , clicks & 1 ) ; input_mt_report_pointer_emulation ( input , true ) ; } input_sync ( input ) ; return 1 ; }
bool inode_owner_or_capable ( const struct inode * inode ) <S2SV_StartBug> { <S2SV_EndBug> if ( uid_eq ( current_fsuid ( ) , inode -> i_uid ) ) return true ; <S2SV_StartBug> if ( inode_capable ( inode , CAP_FOWNER ) ) <S2SV_EndBug> return true ; return false ; }
static int read_header ( struct archive_read * a , struct archive_entry * entry , char head_type ) { const void * h ; const char * p , * endp ; struct rar * rar ; struct rar_header rar_header ; struct rar_file_header file_header ; int64_t header_size ; unsigned filename_size , end ; char * filename ; char * strp ; char packed_size [ 8 ] ; char unp_size [ 8 ] ; int ttime ; struct archive_string_conv * sconv , * fn_sconv ; unsigned long crc32_val ; int ret = ( ARCHIVE_OK ) , ret2 ; rar = ( struct rar * ) ( a -> format -> data ) ; sconv = rar -> opt_sconv ; if ( sconv == NULL ) { if ( ! rar -> init_default_conversion ) { rar -> sconv_default = archive_string_default_conversion_for_read ( & ( a -> archive ) ) ; rar -> init_default_conversion = 1 ; } sconv = rar -> sconv_default ; } if ( ( h = __archive_read_ahead ( a , 7 , NULL ) ) == NULL ) return ( ARCHIVE_FATAL ) ; p = h ; memcpy ( & rar_header , p , sizeof ( rar_header ) ) ; rar -> file_flags = archive_le16dec ( rar_header . flags ) ; header_size = archive_le16dec ( rar_header . size ) ; if ( header_size < ( int64_t ) sizeof ( file_header ) + 7 ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , "Invalid<S2SV_blank>header<S2SV_blank>size" ) ; return ( ARCHIVE_FATAL ) ; } crc32_val = crc32 ( 0 , ( const unsigned char * ) p + 2 , 7 - 2 ) ; __archive_read_consume ( a , 7 ) ; if ( ! ( rar -> file_flags & FHD_SOLID ) ) { rar -> compression_method = 0 ; rar -> packed_size = 0 ; rar -> unp_size = 0 ; rar -> mtime = 0 ; rar -> ctime = 0 ; rar -> atime = 0 ; rar -> arctime = 0 ; rar -> mode = 0 ; memset ( & rar -> salt , 0 , sizeof ( rar -> salt ) ) ; rar -> atime = 0 ; rar -> ansec = 0 ; rar -> ctime = 0 ; rar -> cnsec = 0 ; rar -> mtime = 0 ; rar -> mnsec = 0 ; rar -> arctime = 0 ; rar -> arcnsec = 0 ; } else { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , "RAR<S2SV_blank>solid<S2SV_blank>archive<S2SV_blank>support<S2SV_blank>unavailable." ) ; return ( ARCHIVE_FATAL ) ; } if ( ( h = __archive_read_ahead ( a , ( size_t ) header_size - 7 , NULL ) ) == NULL ) return ( ARCHIVE_FATAL ) ; crc32_val = crc32 ( crc32_val , h , ( unsigned ) ( header_size - 7 ) ) ; if ( ( crc32_val & 0xffff ) != archive_le16dec ( rar_header . crc ) ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , "Header<S2SV_blank>CRC<S2SV_blank>error" ) ; return ( ARCHIVE_FATAL ) ; } p = h ; endp = p + header_size - 7 ; memcpy ( & file_header , p , sizeof ( file_header ) ) ; p += sizeof ( file_header ) ; rar -> compression_method = file_header . method ; ttime = archive_le32dec ( file_header . file_time ) ; rar -> mtime = get_time ( ttime ) ; rar -> file_crc = archive_le32dec ( file_header . file_crc ) ; if ( rar -> file_flags & FHD_PASSWORD ) { archive_entry_set_is_data_encrypted ( entry , 1 ) ; rar -> has_encrypted_entries = 1 ; archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , "RAR<S2SV_blank>encryption<S2SV_blank>support<S2SV_blank>unavailable." ) ; } if ( rar -> file_flags & FHD_LARGE ) { memcpy ( packed_size , file_header . pack_size , 4 ) ; memcpy ( packed_size + 4 , p , 4 ) ; p += 4 ; memcpy ( unp_size , file_header . unp_size , 4 ) ; memcpy ( unp_size + 4 , p , 4 ) ; p += 4 ; rar -> packed_size = archive_le64dec ( & packed_size ) ; rar -> unp_size = archive_le64dec ( & unp_size ) ; } else { rar -> packed_size = archive_le32dec ( file_header . pack_size ) ; rar -> unp_size = archive_le32dec ( file_header . unp_size ) ; } if ( rar -> packed_size < 0 || rar -> unp_size < 0 ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , "Invalid<S2SV_blank>sizes<S2SV_blank>specified." ) ; return ( ARCHIVE_FATAL ) ; } rar -> bytes_remaining = rar -> packed_size ; if ( head_type == NEWSUB_HEAD ) { size_t distance = p - ( const char * ) h ; header_size += rar -> packed_size ; if ( ( h = __archive_read_ahead ( a , ( size_t ) header_size - 7 , NULL ) ) == NULL ) return ( ARCHIVE_FATAL ) ; p = h ; endp = p + header_size - 7 ; p += distance ; } filename_size = archive_le16dec ( file_header . name_size ) ; if ( p + filename_size > endp ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , "Invalid<S2SV_blank>filename<S2SV_blank>size" ) ; return ( ARCHIVE_FATAL ) ; } if ( rar -> filename_allocated < filename_size * 2 + 2 ) { char * newptr ; size_t newsize = filename_size * 2 + 2 ; newptr = realloc ( rar -> filename , newsize ) ; if ( newptr == NULL ) { archive_set_error ( & a -> archive , ENOMEM , "Couldn\'t<S2SV_blank>allocate<S2SV_blank>memory." ) ; return ( ARCHIVE_FATAL ) ; } rar -> filename = newptr ; rar -> filename_allocated = newsize ; } filename = rar -> filename ; memcpy ( filename , p , filename_size ) ; filename [ filename_size ] = '\\0' ; if ( rar -> file_flags & FHD_UNICODE ) { if ( filename_size != strlen ( filename ) ) { unsigned char highbyte , flagbits , flagbyte ; unsigned fn_end , offset ; end = filename_size ; fn_end = filename_size * 2 ; filename_size = 0 ; offset = ( unsigned ) strlen ( filename ) + 1 ; highbyte = * ( p + offset ++ ) ; flagbits = 0 ; flagbyte = 0 ; while ( offset < end && filename_size < fn_end ) { if ( ! flagbits ) { flagbyte = * ( p + offset ++ ) ; flagbits = 8 ; } flagbits -= 2 ; switch ( ( flagbyte >> flagbits ) & 3 ) { case 0 : filename [ filename_size ++ ] = '\\0' ; filename [ filename_size ++ ] = * ( p + offset ++ ) ; break ; case 1 : filename [ filename_size ++ ] = highbyte ; filename [ filename_size ++ ] = * ( p + offset ++ ) ; break ; case 2 : filename [ filename_size ++ ] = * ( p + offset + 1 ) ; filename [ filename_size ++ ] = * ( p + offset ) ; offset += 2 ; break ; case 3 : { char extra , high ; uint8_t length = * ( p + offset ++ ) ; if ( length & 0x80 ) { extra = * ( p + offset ++ ) ; high = ( char ) highbyte ; } else extra = high = 0 ; length = ( length & 0x7f ) + 2 ; while ( length && filename_size < fn_end ) { unsigned cp = filename_size >> 1 ; filename [ filename_size ++ ] = high ; filename [ filename_size ++ ] = p [ cp ] + extra ; length -- ; } } break ; } } if ( filename_size > fn_end ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , "Invalid<S2SV_blank>filename" ) ; return ( ARCHIVE_FATAL ) ; } filename [ filename_size ++ ] = '\\0' ; <S2SV_StartBug> filename [ filename_size ++ ] = '\\0' ; <S2SV_EndBug> if ( rar -> sconv_utf16be == NULL ) { rar -> sconv_utf16be = archive_string_conversion_from_charset ( & a -> archive , "UTF-16BE" , 1 ) ; if ( rar -> sconv_utf16be == NULL ) return ( ARCHIVE_FATAL ) ; } fn_sconv = rar -> sconv_utf16be ; strp = filename ; while ( memcmp ( strp , "\\x00\\x00" , 2 ) ) { if ( ! memcmp ( strp , "\\x00\\\\" , 2 ) ) * ( strp + 1 ) = '/' ; strp += 2 ; } p += offset ; } else { if ( rar -> sconv_utf8 == NULL ) { rar -> sconv_utf8 = archive_string_conversion_from_charset ( & a -> archive , "UTF-8" , 1 ) ; if ( rar -> sconv_utf8 == NULL ) return ( ARCHIVE_FATAL ) ; } fn_sconv = rar -> sconv_utf8 ; while ( ( strp = strchr ( filename , '\\\\' ) ) != NULL ) * strp = '/' ; p += filename_size ; } } else { fn_sconv = sconv ; while ( ( strp = strchr ( filename , '\\\\' ) ) != NULL ) * strp = '/' ; p += filename_size ; } if ( rar -> filename_save && filename_size == rar -> filename_save_size && ! memcmp ( rar -> filename , rar -> filename_save , filename_size + 1 ) ) { __archive_read_consume ( a , header_size - 7 ) ; rar -> cursor ++ ; if ( rar -> cursor >= rar -> nodes ) { rar -> nodes ++ ; if ( ( rar -> dbo = realloc ( rar -> dbo , sizeof ( * rar -> dbo ) * rar -> nodes ) ) == NULL ) { archive_set_error ( & a -> archive , ENOMEM , "Couldn\'t<S2SV_blank>allocate<S2SV_blank>memory." ) ; return ( ARCHIVE_FATAL ) ; } rar -> dbo [ rar -> cursor ] . header_size = header_size ; rar -> dbo [ rar -> cursor ] . start_offset = - 1 ; rar -> dbo [ rar -> cursor ] . end_offset = - 1 ; } if ( rar -> dbo [ rar -> cursor ] . start_offset < 0 ) { rar -> dbo [ rar -> cursor ] . start_offset = a -> filter -> position ; rar -> dbo [ rar -> cursor ] . end_offset = rar -> dbo [ rar -> cursor ] . start_offset + rar -> packed_size ; } return ret ; } rar -> filename_save = ( char * ) realloc ( rar -> filename_save , filename_size + 1 ) ; memcpy ( rar -> filename_save , rar -> filename , filename_size + 1 ) ; rar -> filename_save_size = filename_size ; free ( rar -> dbo ) ; if ( ( rar -> dbo = calloc ( 1 , sizeof ( * rar -> dbo ) ) ) == NULL ) { archive_set_error ( & a -> archive , ENOMEM , "Couldn\'t<S2SV_blank>allocate<S2SV_blank>memory." ) ; return ( ARCHIVE_FATAL ) ; } rar -> dbo [ 0 ] . header_size = header_size ; rar -> dbo [ 0 ] . start_offset = - 1 ; rar -> dbo [ 0 ] . end_offset = - 1 ; rar -> cursor = 0 ; rar -> nodes = 1 ; if ( rar -> file_flags & FHD_SALT ) { if ( p + 8 > endp ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , "Invalid<S2SV_blank>header<S2SV_blank>size" ) ; return ( ARCHIVE_FATAL ) ; } memcpy ( rar -> salt , p , 8 ) ; p += 8 ; } if ( rar -> file_flags & FHD_EXTTIME ) { if ( read_exttime ( p , rar , endp ) < 0 ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , "Invalid<S2SV_blank>header<S2SV_blank>size" ) ; return ( ARCHIVE_FATAL ) ; } } __archive_read_consume ( a , header_size - 7 ) ; rar -> dbo [ 0 ] . start_offset = a -> filter -> position ; rar -> dbo [ 0 ] . end_offset = rar -> dbo [ 0 ] . start_offset + rar -> packed_size ; switch ( file_header . host_os ) { case OS_MSDOS : case OS_OS2 : case OS_WIN32 : rar -> mode = archive_le32dec ( file_header . file_attr ) ; if ( rar -> mode & FILE_ATTRIBUTE_DIRECTORY ) rar -> mode = AE_IFDIR | S_IXUSR | S_IXGRP | S_IXOTH ; else rar -> mode = AE_IFREG ; rar -> mode |= S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH ; break ; case OS_UNIX : case OS_MAC_OS : case OS_BEOS : rar -> mode = archive_le32dec ( file_header . file_attr ) ; break ; default : archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , "Unknown<S2SV_blank>file<S2SV_blank>attributes<S2SV_blank>from<S2SV_blank>RAR<S2SV_blank>file\'s<S2SV_blank>host<S2SV_blank>OS" ) ; return ( ARCHIVE_FATAL ) ; } rar -> bytes_uncopied = rar -> bytes_unconsumed = 0 ; rar -> lzss . position = rar -> offset = 0 ; rar -> offset_seek = 0 ; rar -> dictionary_size = 0 ; rar -> offset_outgoing = 0 ; rar -> br . cache_avail = 0 ; rar -> br . avail_in = 0 ; rar -> crc_calculated = 0 ; rar -> entry_eof = 0 ; rar -> valid = 1 ; rar -> is_ppmd_block = 0 ; rar -> start_new_table = 1 ; free ( rar -> unp_buffer ) ; rar -> unp_buffer = NULL ; rar -> unp_offset = 0 ; rar -> unp_buffer_size = UNP_BUFFER_SIZE ; memset ( rar -> lengthtable , 0 , sizeof ( rar -> lengthtable ) ) ; __archive_ppmd7_functions . Ppmd7_Free ( & rar -> ppmd7_context , & g_szalloc ) ; rar -> ppmd_valid = rar -> ppmd_eod = 0 ; if ( head_type == NEWSUB_HEAD ) return ret ; archive_entry_set_mtime ( entry , rar -> mtime , rar -> mnsec ) ; archive_entry_set_ctime ( entry , rar -> ctime , rar -> cnsec ) ; archive_entry_set_atime ( entry , rar -> atime , rar -> ansec ) ; archive_entry_set_size ( entry , rar -> unp_size ) ; archive_entry_set_mode ( entry , rar -> mode ) ; if ( archive_entry_copy_pathname_l ( entry , filename , filename_size , fn_sconv ) ) { if ( errno == ENOMEM ) { archive_set_error ( & a -> archive , ENOMEM , "Can\'t<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>Pathname" ) ; return ( ARCHIVE_FATAL ) ; } archive_set_error ( & a -> archive , ARCHIVE_ERRNO_FILE_FORMAT , "Pathname<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>converted<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>current<S2SV_blank>locale." , archive_string_conversion_charset_name ( fn_sconv ) ) ; ret = ( ARCHIVE_WARN ) ; } if ( ( ( rar -> mode ) & AE_IFMT ) == AE_IFLNK ) { rar -> bytes_remaining = 0 ; archive_entry_set_size ( entry , 0 ) ; if ( ( ret2 = read_symlink_stored ( a , entry , sconv ) ) < ( ARCHIVE_WARN ) ) return ret2 ; if ( ret > ret2 ) ret = ret2 ; } if ( rar -> bytes_remaining == 0 ) rar -> entry_eof = 1 ; return ret ; }
static int rtl8xxxu_submit_int_urb ( struct ieee80211_hw * hw ) { struct rtl8xxxu_priv * priv = hw -> priv ; struct urb * urb ; u32 val32 ; int ret ; urb = usb_alloc_urb ( 0 , GFP_KERNEL ) ; if ( ! urb ) return - ENOMEM ; usb_fill_int_urb ( urb , priv -> udev , priv -> pipe_interrupt , priv -> int_buf , USB_INTR_CONTENT_LENGTH , rtl8xxxu_int_complete , priv , 1 ) ; usb_anchor_urb ( urb , & priv -> int_anchor ) ; ret = usb_submit_urb ( urb , GFP_KERNEL ) ; if ( ret ) { usb_unanchor_urb ( urb ) ; <S2SV_StartBug> goto error ; <S2SV_EndBug> } val32 = rtl8xxxu_read32 ( priv , REG_USB_HIMR ) ; val32 |= USB_HIMR_CPWM ; rtl8xxxu_write32 ( priv , REG_USB_HIMR , val32 ) ; error : return ret ; }
static int pfkey_recvmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { struct sock * sk = sock -> sk ; struct pfkey_sock * pfk = pfkey_sk ( sk ) ; struct sk_buff * skb ; int copied , err ; err = - EINVAL ; if ( flags & ~ ( MSG_PEEK | MSG_DONTWAIT | MSG_TRUNC | MSG_CMSG_COMPAT ) ) goto out ; <S2SV_StartBug> msg -> msg_namelen = 0 ; <S2SV_EndBug> skb = skb_recv_datagram ( sk , flags , flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out ; copied = skb -> len ; if ( copied > len ) { msg -> msg_flags |= MSG_TRUNC ; copied = len ; } skb_reset_transport_header ( skb ) ; err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; if ( err ) goto out_free ; sock_recv_ts_and_drops ( msg , sk , skb ) ; err = ( flags & MSG_TRUNC ) ? skb -> len : copied ; if ( pfk -> dump . dump != NULL && 3 * atomic_read ( & sk -> sk_rmem_alloc ) <= sk -> sk_rcvbuf ) pfkey_do_dump ( pfk ) ; out_free : skb_free_datagram ( sk , skb ) ; out : return err ; }
static OPJ_BOOL opj_j2k_write_sot ( opj_j2k_t * p_j2k , OPJ_BYTE * p_data , <S2SV_StartBug> OPJ_UINT32 * p_data_written , <S2SV_EndBug> const opj_stream_private_t * p_stream , opj_event_mgr_t * p_manager ) { assert ( p_j2k != 00 ) ; assert ( p_manager != 00 ) ; assert ( p_stream != 00 ) ; OPJ_UNUSED ( p_stream ) ; OPJ_UNUSED ( p_manager ) ; <S2SV_StartBug> opj_write_bytes ( p_data , J2K_MS_SOT , <S2SV_EndBug> 2 ) ; p_data += 2 ; opj_write_bytes ( p_data , 10 , 2 ) ; p_data += 2 ; opj_write_bytes ( p_data , p_j2k -> m_current_tile_number , 2 ) ; p_data += 2 ; p_data += 4 ; opj_write_bytes ( p_data , p_j2k -> m_specific_param . m_encoder . m_current_tile_part_number , 1 ) ; ++ p_data ; opj_write_bytes ( p_data , p_j2k -> m_cp . tcps [ p_j2k -> m_current_tile_number ] . m_nb_tile_parts , 1 ) ; ++ p_data ; # ifdef USE_JPWL assert ( 0 && "TODO" ) ; # endif * p_data_written = 12 ; return OPJ_TRUE ; }
<S2SV_StartBug> void fadst16_sse2 ( __m128i * in0 , __m128i * in1 ) { <S2SV_EndBug> fadst16_8col ( in0 ) ; fadst16_8col ( in1 ) ; array_transpose_16x16 ( in0 , in1 ) ; }
int ssl3_write_bytes ( SSL * s , int type , const void * buf_ , int len ) { const unsigned char * buf = buf_ ; int tot ; unsigned int n , split_send_fragment , maxpipes ; # if ! defined ( OPENSSL_NO_MULTIBLOCK ) && EVP_CIPH_FLAG_TLS1_1_MULTIBLOCK unsigned int max_send_fragment , nw ; unsigned int u_len = ( unsigned int ) len ; # endif SSL3_BUFFER * wb = & s -> rlayer . wbuf [ 0 ] ; int i ; if ( len < 0 ) { SSLerr ( SSL_F_SSL3_WRITE_BYTES , SSL_R_SSL_NEGATIVE_LENGTH ) ; return - 1 ; } s -> rwstate = SSL_NOTHING ; tot = s -> rlayer . wnum ; if ( ( unsigned int ) len < s -> rlayer . wnum ) { SSLerr ( SSL_F_SSL3_WRITE_BYTES , SSL_R_BAD_LENGTH ) ; return - 1 ; } s -> rlayer . wnum = 0 ; if ( SSL_in_init ( s ) && ! ossl_statem_get_in_handshake ( s ) ) { i = s -> handshake_func ( s ) ; if ( i < 0 ) return ( i ) ; if ( i == 0 ) { SSLerr ( SSL_F_SSL3_WRITE_BYTES , SSL_R_SSL_HANDSHAKE_FAILURE ) ; return - 1 ; } } if ( wb -> left != 0 ) { i = ssl3_write_pending ( s , type , & buf [ tot ] , s -> rlayer . wpend_tot ) ; if ( i <= 0 ) { s -> rlayer . wnum = tot ; return i ; } tot += i ; } # if ! defined ( OPENSSL_NO_MULTIBLOCK ) && EVP_CIPH_FLAG_TLS1_1_MULTIBLOCK if ( type == SSL3_RT_APPLICATION_DATA && u_len >= 4 * ( max_send_fragment = s -> max_send_fragment ) && s -> compress == NULL && s -> msg_callback == NULL && <S2SV_StartBug> ! SSL_USE_ETM ( s ) && SSL_USE_EXPLICIT_IV ( s ) && <S2SV_EndBug> EVP_CIPHER_flags ( EVP_CIPHER_CTX_cipher ( s -> enc_write_ctx ) ) & EVP_CIPH_FLAG_TLS1_1_MULTIBLOCK ) { unsigned char aad [ 13 ] ; EVP_CTRL_TLS1_1_MULTIBLOCK_PARAM mb_param ; int packlen ; if ( ( max_send_fragment & 0xfff ) == 0 ) max_send_fragment -= 512 ; if ( tot == 0 || wb -> buf == NULL ) { ssl3_release_write_buffer ( s ) ; packlen = EVP_CIPHER_CTX_ctrl ( s -> enc_write_ctx , EVP_CTRL_TLS1_1_MULTIBLOCK_MAX_BUFSIZE , max_send_fragment , NULL ) ; if ( u_len >= 8 * max_send_fragment ) packlen *= 8 ; else packlen *= 4 ; if ( ! ssl3_setup_write_buffer ( s , 1 , packlen ) ) { SSLerr ( SSL_F_SSL3_WRITE_BYTES , ERR_R_MALLOC_FAILURE ) ; return - 1 ; } } else if ( tot == len ) { ssl3_release_write_buffer ( s ) ; return tot ; } n = ( len - tot ) ; for ( ; ; ) { if ( n < 4 * max_send_fragment ) { ssl3_release_write_buffer ( s ) ; break ; } if ( s -> s3 -> alert_dispatch ) { i = s -> method -> ssl_dispatch_alert ( s ) ; if ( i <= 0 ) { s -> rlayer . wnum = tot ; return i ; } } if ( n >= 8 * max_send_fragment ) nw = max_send_fragment * ( mb_param . interleave = 8 ) ; else nw = max_send_fragment * ( mb_param . interleave = 4 ) ; memcpy ( aad , s -> rlayer . write_sequence , 8 ) ; aad [ 8 ] = type ; aad [ 9 ] = ( unsigned char ) ( s -> version >> 8 ) ; aad [ 10 ] = ( unsigned char ) ( s -> version ) ; aad [ 11 ] = 0 ; aad [ 12 ] = 0 ; mb_param . out = NULL ; mb_param . inp = aad ; mb_param . len = nw ; packlen = EVP_CIPHER_CTX_ctrl ( s -> enc_write_ctx , EVP_CTRL_TLS1_1_MULTIBLOCK_AAD , sizeof ( mb_param ) , & mb_param ) ; if ( packlen <= 0 || packlen > ( int ) wb -> len ) { ssl3_release_write_buffer ( s ) ; break ; } mb_param . out = wb -> buf ; mb_param . inp = & buf [ tot ] ; mb_param . len = nw ; if ( EVP_CIPHER_CTX_ctrl ( s -> enc_write_ctx , EVP_CTRL_TLS1_1_MULTIBLOCK_ENCRYPT , sizeof ( mb_param ) , & mb_param ) <= 0 ) return - 1 ; s -> rlayer . write_sequence [ 7 ] += mb_param . interleave ; if ( s -> rlayer . write_sequence [ 7 ] < mb_param . interleave ) { int j = 6 ; while ( j >= 0 && ( ++ s -> rlayer . write_sequence [ j -- ] ) == 0 ) ; } wb -> offset = 0 ; wb -> left = packlen ; s -> rlayer . wpend_tot = nw ; s -> rlayer . wpend_buf = & buf [ tot ] ; s -> rlayer . wpend_type = type ; s -> rlayer . wpend_ret = nw ; i = ssl3_write_pending ( s , type , & buf [ tot ] , nw ) ; if ( i <= 0 ) { if ( i < 0 && ( ! s -> wbio || ! BIO_should_retry ( s -> wbio ) ) ) { ssl3_release_write_buffer ( s ) ; } s -> rlayer . wnum = tot ; return i ; } if ( i == ( int ) n ) { ssl3_release_write_buffer ( s ) ; return tot + i ; } n -= i ; tot += i ; } } else # endif if ( tot == len ) { if ( s -> mode & SSL_MODE_RELEASE_BUFFERS && ! SSL_IS_DTLS ( s ) ) ssl3_release_write_buffer ( s ) ; return tot ; } n = ( len - tot ) ; split_send_fragment = s -> split_send_fragment ; maxpipes = s -> max_pipelines ; if ( maxpipes > SSL_MAX_PIPELINES ) { SSLerr ( SSL_F_SSL3_WRITE_BYTES , ERR_R_INTERNAL_ERROR ) ; return - 1 ; } if ( maxpipes == 0 || s -> enc_write_ctx == NULL || ! ( EVP_CIPHER_flags ( EVP_CIPHER_CTX_cipher ( s -> enc_write_ctx ) ) & EVP_CIPH_FLAG_PIPELINE ) || ! SSL_USE_EXPLICIT_IV ( s ) ) maxpipes = 1 ; if ( s -> max_send_fragment == 0 || split_send_fragment > s -> max_send_fragment || split_send_fragment == 0 ) { SSLerr ( SSL_F_SSL3_WRITE_BYTES , ERR_R_INTERNAL_ERROR ) ; return - 1 ; } for ( ; ; ) { unsigned int pipelens [ SSL_MAX_PIPELINES ] , tmppipelen , remain ; unsigned int numpipes , j ; if ( n == 0 ) numpipes = 1 ; else numpipes = ( ( n - 1 ) / split_send_fragment ) + 1 ; if ( numpipes > maxpipes ) numpipes = maxpipes ; if ( n / numpipes >= s -> max_send_fragment ) { for ( j = 0 ; j < numpipes ; j ++ ) { pipelens [ j ] = s -> max_send_fragment ; } } else { tmppipelen = n / numpipes ; remain = n % numpipes ; for ( j = 0 ; j < numpipes ; j ++ ) { pipelens [ j ] = tmppipelen ; if ( j < remain ) pipelens [ j ] ++ ; } } i = do_ssl3_write ( s , type , & ( buf [ tot ] ) , pipelens , numpipes , 0 ) ; if ( i <= 0 ) { s -> rlayer . wnum = tot ; return i ; } if ( ( i == ( int ) n ) || ( type == SSL3_RT_APPLICATION_DATA && ( s -> mode & SSL_MODE_ENABLE_PARTIAL_WRITE ) ) ) { s -> s3 -> empty_fragment_done = 0 ; if ( ( i == ( int ) n ) && s -> mode & SSL_MODE_RELEASE_BUFFERS && ! SSL_IS_DTLS ( s ) ) ssl3_release_write_buffer ( s ) ; return tot + i ; } n -= i ; tot += i ; } }
static const u_char * ikev1_attrmap_print ( netdissect_options * ndo , <S2SV_StartBug> const u_char * p , const u_char * ep , <S2SV_EndBug> const struct attrmap * map , size_t nmap ) { int totlen ; uint32_t t , v ; <S2SV_StartBug> if ( p [ 0 ] & 0x80 ) <S2SV_EndBug> totlen = 4 ; <S2SV_StartBug> else <S2SV_EndBug> totlen = 4 + EXTRACT_16BITS ( & p [ 2 ] ) ; <S2SV_StartBug> if ( ep < p + totlen ) { <S2SV_EndBug> ND_PRINT ( ( ndo , "[|attr]" ) ) ; <S2SV_StartBug> return ep + 1 ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> ND_PRINT ( ( ndo , "(" ) ) ; t = EXTRACT_16BITS ( & p [ 0 ] ) & 0x7fff ; if ( map && t < nmap && map [ t ] . type ) ND_PRINT ( ( ndo , "type=%s<S2SV_blank>" , map [ t ] . type ) ) ; else ND_PRINT ( ( ndo , "type=#%d<S2SV_blank>" , t ) ) ; if ( p [ 0 ] & 0x80 ) { <S2SV_StartBug> ND_PRINT ( ( ndo , "value=" ) ) ; <S2SV_EndBug> v = EXTRACT_16BITS ( & p [ 2 ] ) ; if ( map && t < nmap && v < map [ t ] . nvalue && map [ t ] . value [ v ] ) ND_PRINT ( ( ndo , "%s" , map [ t ] . value [ v ] ) ) ; else <S2SV_StartBug> rawprint ( ndo , ( const uint8_t * ) & p [ 2 ] , 2 ) ; <S2SV_EndBug> } else { <S2SV_StartBug> ND_PRINT ( ( ndo , "len=%d<S2SV_blank>value=" , EXTRACT_16BITS ( & p [ 2 ] ) ) ) ; <S2SV_EndBug> <S2SV_StartBug> rawprint ( ndo , ( const uint8_t * ) & p [ 4 ] , EXTRACT_16BITS ( & p [ 2 ] ) ) ; <S2SV_EndBug> } ND_PRINT ( ( ndo , ")" ) ) ; <S2SV_StartBug> return p + totlen ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>
static int iucv_sock_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { int noblock = flags & MSG_DONTWAIT ; struct sock * sk = sock -> sk ; struct iucv_sock * iucv = iucv_sk ( sk ) ; unsigned int copied , rlen ; struct sk_buff * skb , * rskb , * cskb ; int err = 0 ; <S2SV_StartBug> u32 offset ; <S2SV_EndBug> msg -> msg_namelen = 0 ; if ( ( sk -> sk_state == IUCV_DISCONN ) && skb_queue_empty ( & iucv -> backlog_skb_q ) && skb_queue_empty ( & sk -> sk_receive_queue ) && list_empty ( & iucv -> message_q . list ) ) return 0 ; if ( flags & ( MSG_OOB ) ) return - EOPNOTSUPP ; skb = skb_recv_datagram ( sk , flags , noblock , & err ) ; if ( ! skb ) { if ( sk -> sk_shutdown & RCV_SHUTDOWN ) return 0 ; return err ; } offset = IUCV_SKB_CB ( skb ) -> offset ; rlen = skb -> len - offset ; copied = min_t ( unsigned int , rlen , len ) ; if ( ! rlen ) sk -> sk_shutdown = sk -> sk_shutdown | RCV_SHUTDOWN ; cskb = skb ; if ( skb_copy_datagram_iovec ( cskb , offset , msg -> msg_iov , copied ) ) { if ( ! ( flags & MSG_PEEK ) ) skb_queue_head ( & sk -> sk_receive_queue , skb ) ; return - EFAULT ; } if ( sk -> sk_type == SOCK_SEQPACKET ) { if ( copied < rlen ) msg -> msg_flags |= MSG_TRUNC ; msg -> msg_flags |= MSG_EOR ; } err = put_cmsg ( msg , SOL_IUCV , SCM_IUCV_TRGCLS , sizeof ( IUCV_SKB_CB ( skb ) -> class ) , ( void * ) & IUCV_SKB_CB ( skb ) -> class ) ; if ( err ) { if ( ! ( flags & MSG_PEEK ) ) skb_queue_head ( & sk -> sk_receive_queue , skb ) ; return err ; } if ( ! ( flags & MSG_PEEK ) ) { if ( sk -> sk_type == SOCK_STREAM ) { if ( copied < rlen ) { IUCV_SKB_CB ( skb ) -> offset = offset + copied ; goto done ; } } kfree_skb ( skb ) ; if ( iucv -> transport == AF_IUCV_TRANS_HIPER ) { atomic_inc ( & iucv -> msg_recv ) ; if ( atomic_read ( & iucv -> msg_recv ) > iucv -> msglimit ) { WARN_ON ( 1 ) ; iucv_sock_close ( sk ) ; return - EFAULT ; } } spin_lock_bh ( & iucv -> message_q . lock ) ; rskb = skb_dequeue ( & iucv -> backlog_skb_q ) ; while ( rskb ) { IUCV_SKB_CB ( rskb ) -> offset = 0 ; if ( sock_queue_rcv_skb ( sk , rskb ) ) { skb_queue_head ( & iucv -> backlog_skb_q , rskb ) ; break ; } else { rskb = skb_dequeue ( & iucv -> backlog_skb_q ) ; } } if ( skb_queue_empty ( & iucv -> backlog_skb_q ) ) { if ( ! list_empty ( & iucv -> message_q . list ) ) iucv_process_message_q ( sk ) ; if ( atomic_read ( & iucv -> msg_recv ) >= iucv -> msglimit / 2 ) { err = iucv_send_ctrl ( sk , AF_IUCV_FLAG_WIN ) ; if ( err ) { sk -> sk_state = IUCV_DISCONN ; sk -> sk_state_change ( sk ) ; } } } spin_unlock_bh ( & iucv -> message_q . lock ) ; } done : if ( sk -> sk_type == SOCK_SEQPACKET && ( flags & MSG_TRUNC ) ) copied = rlen ; return copied ; }
rfbClientPtr rfbClientIteratorNext ( rfbClientIteratorPtr i ) <S2SV_StartBug> { <S2SV_EndBug> if ( i -> next == 0 ) { LOCK ( rfbClientListMutex ) ; i -> next = i -> screen -> clientHead ; UNLOCK ( rfbClientListMutex ) ; } else { rfbClientPtr cl = i -> next ; i -> next = i -> next -> next ; rfbDecrClientRef ( cl ) ; } # if defined ( LIBVNCSERVER_HAVE_LIBPTHREAD ) || defined ( LIBVNCSERVER_HAVE_WIN32THREADS ) if ( ! i -> closedToo ) while ( i -> next && i -> next -> sock < 0 ) i -> next = i -> next -> next ; if ( i -> next ) rfbIncrClientRef ( i -> next ) ; # endif return i -> next ; }
static int xwd_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) { AVFrame * p = data ; const uint8_t * buf = avpkt -> data ; int i , ret , buf_size = avpkt -> size ; uint32_t version , header_size , vclass , ncolors ; uint32_t xoffset , be , bpp , lsize , rsize ; uint32_t pixformat , pixdepth , bunit , bitorder , bpad ; uint32_t rgb [ 3 ] ; uint8_t * ptr ; GetByteContext gb ; if ( buf_size < XWD_HEADER_SIZE ) return AVERROR_INVALIDDATA ; bytestream2_init ( & gb , buf , buf_size ) ; header_size = bytestream2_get_be32u ( & gb ) ; version = bytestream2_get_be32u ( & gb ) ; if ( version != XWD_VERSION ) { av_log ( avctx , AV_LOG_ERROR , "unsupported<S2SV_blank>version\\n" ) ; return AVERROR_INVALIDDATA ; } if ( buf_size < header_size || header_size < XWD_HEADER_SIZE ) { av_log ( avctx , AV_LOG_ERROR , "invalid<S2SV_blank>header<S2SV_blank>size\\n" ) ; return AVERROR_INVALIDDATA ; } pixformat = bytestream2_get_be32u ( & gb ) ; pixdepth = bytestream2_get_be32u ( & gb ) ; avctx -> width = bytestream2_get_be32u ( & gb ) ; avctx -> height = bytestream2_get_be32u ( & gb ) ; xoffset = bytestream2_get_be32u ( & gb ) ; be = bytestream2_get_be32u ( & gb ) ; bunit = bytestream2_get_be32u ( & gb ) ; bitorder = bytestream2_get_be32u ( & gb ) ; bpad = bytestream2_get_be32u ( & gb ) ; bpp = bytestream2_get_be32u ( & gb ) ; lsize = bytestream2_get_be32u ( & gb ) ; vclass = bytestream2_get_be32u ( & gb ) ; rgb [ 0 ] = bytestream2_get_be32u ( & gb ) ; rgb [ 1 ] = bytestream2_get_be32u ( & gb ) ; rgb [ 2 ] = bytestream2_get_be32u ( & gb ) ; bytestream2_skipu ( & gb , 8 ) ; ncolors = bytestream2_get_be32u ( & gb ) ; bytestream2_skipu ( & gb , header_size - ( XWD_HEADER_SIZE - 20 ) ) ; av_log ( avctx , AV_LOG_DEBUG , "pixformat<S2SV_blank>%" PRIu32 ",<S2SV_blank>pixdepth<S2SV_blank>%" PRIu32 ",<S2SV_blank>bunit<S2SV_blank>%" PRIu32 ",<S2SV_blank>bitorder<S2SV_blank>%" PRIu32 ",<S2SV_blank>bpad<S2SV_blank>%" PRIu32 "\\n" , pixformat , pixdepth , bunit , bitorder , bpad ) ; av_log ( avctx , AV_LOG_DEBUG , "vclass<S2SV_blank>%" PRIu32 ",<S2SV_blank>ncolors<S2SV_blank>%" PRIu32 ",<S2SV_blank>bpp<S2SV_blank>%" PRIu32 ",<S2SV_blank>be<S2SV_blank>%" PRIu32 ",<S2SV_blank>lsize<S2SV_blank>%" PRIu32 ",<S2SV_blank>xoffset<S2SV_blank>%" PRIu32 "\\n" , vclass , ncolors , bpp , be , lsize , xoffset ) ; av_log ( avctx , AV_LOG_DEBUG , "red<S2SV_blank>%0" PRIx32 ",<S2SV_blank>green<S2SV_blank>%0" PRIx32 ",<S2SV_blank>blue<S2SV_blank>%0" PRIx32 "\\n" , rgb [ 0 ] , rgb [ 1 ] , rgb [ 2 ] ) ; if ( pixformat > XWD_Z_PIXMAP ) { av_log ( avctx , AV_LOG_ERROR , "invalid<S2SV_blank>pixmap<S2SV_blank>format\\n" ) ; return AVERROR_INVALIDDATA ; } if ( pixdepth == 0 || pixdepth > 32 ) { av_log ( avctx , AV_LOG_ERROR , "invalid<S2SV_blank>pixmap<S2SV_blank>depth\\n" ) ; return AVERROR_INVALIDDATA ; } if ( xoffset ) { avpriv_request_sample ( avctx , "xoffset<S2SV_blank>%" PRIu32 "" , xoffset ) ; return AVERROR_PATCHWELCOME ; } if ( be > 1 ) { av_log ( avctx , AV_LOG_ERROR , "invalid<S2SV_blank>byte<S2SV_blank>order\\n" ) ; return AVERROR_INVALIDDATA ; } if ( bitorder > 1 ) { av_log ( avctx , AV_LOG_ERROR , "invalid<S2SV_blank>bitmap<S2SV_blank>bit<S2SV_blank>order\\n" ) ; return AVERROR_INVALIDDATA ; } if ( bunit != 8 && bunit != 16 && bunit != 32 ) { av_log ( avctx , AV_LOG_ERROR , "invalid<S2SV_blank>bitmap<S2SV_blank>unit\\n" ) ; return AVERROR_INVALIDDATA ; } if ( bpad != 8 && bpad != 16 && bpad != 32 ) { av_log ( avctx , AV_LOG_ERROR , "invalid<S2SV_blank>bitmap<S2SV_blank>scan-line<S2SV_blank>pad\\n" ) ; return AVERROR_INVALIDDATA ; } if ( bpp == 0 || bpp > 32 ) { av_log ( avctx , AV_LOG_ERROR , "invalid<S2SV_blank>bits<S2SV_blank>per<S2SV_blank>pixel\\n" ) ; return AVERROR_INVALIDDATA ; } if ( ncolors > 256 ) { av_log ( avctx , AV_LOG_ERROR , "invalid<S2SV_blank>number<S2SV_blank>of<S2SV_blank>entries<S2SV_blank>in<S2SV_blank>colormap\\n" ) ; return AVERROR_INVALIDDATA ; } if ( ( ret = av_image_check_size ( avctx -> width , avctx -> height , 0 , NULL ) ) < 0 ) return ret ; rsize = FFALIGN ( avctx -> width * bpp , bpad ) / 8 ; if ( lsize < rsize ) { av_log ( avctx , AV_LOG_ERROR , "invalid<S2SV_blank>bytes<S2SV_blank>per<S2SV_blank>scan-line\\n" ) ; return AVERROR_INVALIDDATA ; } if ( bytestream2_get_bytes_left ( & gb ) < ncolors * XWD_CMAP_SIZE + ( uint64_t ) avctx -> height * lsize ) { av_log ( avctx , AV_LOG_ERROR , "input<S2SV_blank>buffer<S2SV_blank>too<S2SV_blank>small\\n" ) ; return AVERROR_INVALIDDATA ; } if ( pixformat != XWD_Z_PIXMAP ) { avpriv_report_missing_feature ( avctx , "Pixmap<S2SV_blank>format<S2SV_blank>%" PRIu32 , pixformat ) ; return AVERROR_PATCHWELCOME ; } avctx -> pix_fmt = AV_PIX_FMT_NONE ; switch ( vclass ) { case XWD_STATIC_GRAY : case XWD_GRAY_SCALE : if ( bpp != 1 && bpp != 8 ) return AVERROR_INVALIDDATA ; <S2SV_StartBug> if ( pixdepth == 1 ) { <S2SV_EndBug> avctx -> pix_fmt = AV_PIX_FMT_MONOWHITE ; <S2SV_StartBug> } else if ( pixdepth == 8 ) { <S2SV_EndBug> avctx -> pix_fmt = AV_PIX_FMT_GRAY8 ; } break ; case XWD_STATIC_COLOR : case XWD_PSEUDO_COLOR : if ( bpp == 8 ) avctx -> pix_fmt = AV_PIX_FMT_PAL8 ; break ; case XWD_TRUE_COLOR : case XWD_DIRECT_COLOR : if ( bpp != 16 && bpp != 24 && bpp != 32 ) return AVERROR_INVALIDDATA ; if ( bpp == 16 && pixdepth == 15 ) { if ( rgb [ 0 ] == 0x7C00 && rgb [ 1 ] == 0x3E0 && rgb [ 2 ] == 0x1F ) avctx -> pix_fmt = be ? AV_PIX_FMT_RGB555BE : AV_PIX_FMT_RGB555LE ; else if ( rgb [ 0 ] == 0x1F && rgb [ 1 ] == 0x3E0 && rgb [ 2 ] == 0x7C00 ) avctx -> pix_fmt = be ? AV_PIX_FMT_BGR555BE : AV_PIX_FMT_BGR555LE ; } else if ( bpp == 16 && pixdepth == 16 ) { if ( rgb [ 0 ] == 0xF800 && rgb [ 1 ] == 0x7E0 && rgb [ 2 ] == 0x1F ) avctx -> pix_fmt = be ? AV_PIX_FMT_RGB565BE : AV_PIX_FMT_RGB565LE ; else if ( rgb [ 0 ] == 0x1F && rgb [ 1 ] == 0x7E0 && rgb [ 2 ] == 0xF800 ) avctx -> pix_fmt = be ? AV_PIX_FMT_BGR565BE : AV_PIX_FMT_BGR565LE ; } else if ( bpp == 24 ) { if ( rgb [ 0 ] == 0xFF0000 && rgb [ 1 ] == 0xFF00 && rgb [ 2 ] == 0xFF ) avctx -> pix_fmt = be ? AV_PIX_FMT_RGB24 : AV_PIX_FMT_BGR24 ; else if ( rgb [ 0 ] == 0xFF && rgb [ 1 ] == 0xFF00 && rgb [ 2 ] == 0xFF0000 ) avctx -> pix_fmt = be ? AV_PIX_FMT_BGR24 : AV_PIX_FMT_RGB24 ; } else if ( bpp == 32 ) { if ( rgb [ 0 ] == 0xFF0000 && rgb [ 1 ] == 0xFF00 && rgb [ 2 ] == 0xFF ) avctx -> pix_fmt = be ? AV_PIX_FMT_ARGB : AV_PIX_FMT_BGRA ; else if ( rgb [ 0 ] == 0xFF && rgb [ 1 ] == 0xFF00 && rgb [ 2 ] == 0xFF0000 ) avctx -> pix_fmt = be ? AV_PIX_FMT_ABGR : AV_PIX_FMT_RGBA ; } bytestream2_skipu ( & gb , ncolors * XWD_CMAP_SIZE ) ; break ; default : av_log ( avctx , AV_LOG_ERROR , "invalid<S2SV_blank>visual<S2SV_blank>class\\n" ) ; return AVERROR_INVALIDDATA ; } if ( avctx -> pix_fmt == AV_PIX_FMT_NONE ) { avpriv_request_sample ( avctx , "Unknown<S2SV_blank>file:<S2SV_blank>bpp<S2SV_blank>%" PRIu32 ",<S2SV_blank>pixdepth<S2SV_blank>%" PRIu32 ",<S2SV_blank>vclass<S2SV_blank>%" PRIu32 "" , bpp , pixdepth , vclass ) ; return AVERROR_PATCHWELCOME ; } if ( ( ret = ff_get_buffer ( avctx , p , 0 ) ) < 0 ) return ret ; p -> key_frame = 1 ; p -> pict_type = AV_PICTURE_TYPE_I ; if ( avctx -> pix_fmt == AV_PIX_FMT_PAL8 ) { uint32_t * dst = ( uint32_t * ) p -> data [ 1 ] ; uint8_t red , green , blue ; for ( i = 0 ; i < ncolors ; i ++ ) { bytestream2_skipu ( & gb , 4 ) ; red = bytestream2_get_byteu ( & gb ) ; bytestream2_skipu ( & gb , 1 ) ; green = bytestream2_get_byteu ( & gb ) ; bytestream2_skipu ( & gb , 1 ) ; blue = bytestream2_get_byteu ( & gb ) ; bytestream2_skipu ( & gb , 3 ) ; dst [ i ] = red << 16 | green << 8 | blue ; } } ptr = p -> data [ 0 ] ; for ( i = 0 ; i < avctx -> height ; i ++ ) { bytestream2_get_bufferu ( & gb , ptr , rsize ) ; bytestream2_skipu ( & gb , lsize - rsize ) ; ptr += p -> linesize [ 0 ] ; } * got_frame = 1 ; return buf_size ; }
<S2SV_StartBug> void vp9_loop_filter_frame ( VP9_COMMON * cm , MACROBLOCKD * xd , <S2SV_EndBug> int frame_filter_level , int y_only , int partial_frame ) { int start_mi_row , end_mi_row , mi_rows_to_filter ; if ( ! frame_filter_level ) return ; start_mi_row = 0 ; mi_rows_to_filter = cm -> mi_rows ; if ( partial_frame && cm -> mi_rows > 8 ) { start_mi_row = cm -> mi_rows >> 1 ; start_mi_row &= 0xfffffff8 ; mi_rows_to_filter = MAX ( cm -> mi_rows / 8 , 8 ) ; } end_mi_row = start_mi_row + mi_rows_to_filter ; vp9_loop_filter_frame_init ( cm , frame_filter_level ) ; <S2SV_StartBug> vp9_loop_filter_rows ( cm -> frame_to_show , cm , xd , <S2SV_EndBug> start_mi_row , end_mi_row , y_only ) ; }
error_t udpProcessDatagram ( NetInterface * interface , IpPseudoHeader * pseudoHeader , const NetBuffer * buffer , size_t offset , NetRxAncillary * ancillary ) { error_t error ; uint_t i ; size_t length ; UdpHeader * header ; Socket * socket ; SocketQueueItem * queueItem ; NetBuffer * p ; length = netBufferGetLength ( buffer ) - offset ; if ( length < sizeof ( UdpHeader ) ) { MIB2_INC_COUNTER32 ( udpGroup . udpInErrors , 1 ) ; UDP_MIB_INC_COUNTER32 ( udpInErrors , 1 ) ; return ERROR_INVALID_HEADER ; } header = netBufferAt ( buffer , offset ) ; if ( header == NULL ) return ERROR_FAILURE ; TRACE_INFO ( "UDP<S2SV_blank>datagram<S2SV_blank>received<S2SV_blank>(%" PRIuSIZE "<S2SV_blank>bytes)...\\r\\n" , length ) ; udpDumpHeader ( header ) ; if ( header -> checksum != 0x0000 || pseudoHeader -> length == sizeof ( Ipv6PseudoHeader ) ) { if ( ipCalcUpperLayerChecksumEx ( pseudoHeader -> data , pseudoHeader -> length , buffer , offset , length ) != 0x0000 ) { TRACE_WARNING ( "Wrong<S2SV_blank>UDP<S2SV_blank>header<S2SV_blank>checksum!\\r\\n" ) ; MIB2_INC_COUNTER32 ( udpGroup . udpInErrors , 1 ) ; UDP_MIB_INC_COUNTER32 ( udpInErrors , 1 ) ; return ERROR_WRONG_CHECKSUM ; } } for ( i = 0 ; i < SOCKET_MAX_COUNT ; i ++ ) { socket = socketTable + i ; if ( socket -> type != SOCKET_TYPE_DGRAM ) continue ; if ( socket -> interface && socket -> interface != interface ) continue ; if ( socket -> localPort == 0 || socket -> localPort != ntohs ( header -> destPort ) ) continue ; if ( socket -> remotePort != 0 && socket -> remotePort != ntohs ( header -> srcPort ) ) continue ; # if ( IPV4_SUPPORT == ENABLED ) if ( pseudoHeader -> length == sizeof ( Ipv4PseudoHeader ) ) { if ( socket -> localIpAddr . length != 0 ) { if ( socket -> localIpAddr . length != sizeof ( Ipv4Addr ) ) continue ; if ( socket -> localIpAddr . ipv4Addr != pseudoHeader -> ipv4Data . destAddr ) continue ; } if ( socket -> remoteIpAddr . length != 0 ) { if ( socket -> remoteIpAddr . length != sizeof ( Ipv4Addr ) ) continue ; if ( socket -> remoteIpAddr . ipv4Addr != pseudoHeader -> ipv4Data . srcAddr ) continue ; } } else # endif # if ( IPV6_SUPPORT == ENABLED ) if ( pseudoHeader -> length == sizeof ( Ipv6PseudoHeader ) ) { if ( socket -> localIpAddr . length != 0 ) { if ( socket -> localIpAddr . length != sizeof ( Ipv6Addr ) ) continue ; if ( ! ipv6CompAddr ( & socket -> localIpAddr . ipv6Addr , & pseudoHeader -> ipv6Data . destAddr ) ) continue ; } if ( socket -> remoteIpAddr . length != 0 ) { if ( socket -> remoteIpAddr . length != sizeof ( Ipv6Addr ) ) continue ; if ( ! ipv6CompAddr ( & socket -> remoteIpAddr . ipv6Addr , & pseudoHeader -> ipv6Data . srcAddr ) ) continue ; } } else # endif { continue ; } break ; } offset += sizeof ( UdpHeader ) ; length -= sizeof ( UdpHeader ) ; if ( i >= SOCKET_MAX_COUNT ) { error = udpInvokeRxCallback ( interface , pseudoHeader , header , buffer , offset , ancillary ) ; return error ; } if ( socket -> receiveQueue == NULL ) { p = netBufferAlloc ( sizeof ( SocketQueueItem ) + length ) ; if ( p != NULL ) { queueItem = netBufferAt ( p , 0 ) ; queueItem -> buffer = p ; socket -> receiveQueue = queueItem ; } else { queueItem = NULL ; } } else { queueItem = socket -> receiveQueue ; for ( i = 1 ; queueItem -> next ; i ++ ) { queueItem = queueItem -> next ; } if ( i >= UDP_RX_QUEUE_SIZE ) { MIB2_INC_COUNTER32 ( ifGroup . ifTable [ interface -> index ] . ifInDiscards , 1 ) ; IF_MIB_INC_COUNTER32 ( ifTable [ interface -> index ] . ifInDiscards , 1 ) ; return ERROR_RECEIVE_QUEUE_FULL ; } p = netBufferAlloc ( sizeof ( SocketQueueItem ) + length ) ; if ( p != NULL ) { queueItem -> next = netBufferAt ( p , 0 ) ; queueItem = queueItem -> next ; queueItem -> buffer = p ; } else { queueItem = NULL ; } } if ( queueItem == NULL ) { MIB2_INC_COUNTER32 ( ifGroup . ifTable [ interface -> index ] . ifInDiscards , 1 ) ; IF_MIB_INC_COUNTER32 ( ifTable [ interface -> index ] . ifInDiscards , 1 ) ; return ERROR_OUT_OF_MEMORY ; } queueItem -> next = NULL ; <S2SV_StartBug> queueItem -> srcPort = ntohs ( header -> srcPort ) ; <S2SV_EndBug> # if ( IPV4_SUPPORT == ENABLED ) if ( pseudoHeader -> length == sizeof ( Ipv4PseudoHeader ) ) { queueItem -> srcIpAddr . length = sizeof ( Ipv4Addr ) ; queueItem -> srcIpAddr . ipv4Addr = pseudoHeader -> ipv4Data . srcAddr ; queueItem -> destIpAddr . length = sizeof ( Ipv4Addr ) ; queueItem -> destIpAddr . ipv4Addr = pseudoHeader -> ipv4Data . destAddr ; } # endif # if ( IPV6_SUPPORT == ENABLED ) if ( pseudoHeader -> length == sizeof ( Ipv6PseudoHeader ) ) { queueItem -> srcIpAddr . length = sizeof ( Ipv6Addr ) ; queueItem -> srcIpAddr . ipv6Addr = pseudoHeader -> ipv6Data . srcAddr ; queueItem -> destIpAddr . length = sizeof ( Ipv6Addr ) ; queueItem -> destIpAddr . ipv6Addr = pseudoHeader -> ipv6Data . destAddr ; } # endif queueItem -> offset = sizeof ( SocketQueueItem ) ; netBufferCopy ( queueItem -> buffer , queueItem -> offset , buffer , offset , length ) ; queueItem -> ancillary = * ancillary ; udpUpdateEvents ( socket ) ; MIB2_INC_COUNTER32 ( udpGroup . udpInDatagrams , 1 ) ; UDP_MIB_INC_COUNTER32 ( udpInDatagrams , 1 ) ; UDP_MIB_INC_COUNTER64 ( udpHCInDatagrams , 1 ) ; return NO_ERROR ; }
void initServerConfig ( ) { server . port = REDIS_SERVERPORT ; server . bindaddr = NULL ; server . unixsocket = NULL ; server . ipfd = - 1 ; server . sofd = - 1 ; server . dbnum = REDIS_DEFAULT_DBNUM ; server . verbosity = REDIS_VERBOSE ; server . maxidletime = REDIS_MAXIDLETIME ; server . saveparams = NULL ; server . loading = 0 ; server . logfile = NULL ; server . syslog_enabled = 0 ; server . syslog_ident = zstrdup ( "redis" ) ; server . syslog_facility = LOG_LOCAL0 ; server . glueoutputbuf = 1 ; server . daemonize = 0 ; server . appendonly = 0 ; server . appendfsync = APPENDFSYNC_EVERYSEC ; server . no_appendfsync_on_rewrite = 0 ; server . lastfsync = time ( NULL ) ; server . appendfd = - 1 ; server . appendseldb = - 1 ; server . pidfile = zstrdup ( "/var/run/redis.pid" ) ; server . dbfilename = zstrdup ( "dump.rdb" ) ; server . appendfilename = zstrdup ( "appendonly.aof" ) ; server . requirepass = NULL ; server . rdbcompression = 1 ; server . activerehashing = 1 ; server . maxclients = 0 ; server . bpop_blocked_clients = 0 ; server . maxmemory = 0 ; server . maxmemory_policy = REDIS_MAXMEMORY_VOLATILE_LRU ; server . maxmemory_samples = 3 ; <S2SV_StartBug> server . vm_enabled = 0 ; <S2SV_EndBug> <S2SV_StartBug> server . vm_swap_file = zstrdup ( "/tmp/redis-%p.vm" ) ; <S2SV_EndBug> server . vm_page_size = 256 ; server . vm_pages = 1024 * 1024 * 100 ; <S2SV_StartBug> server . vm_max_memory = 1024LL * 1024 * 1024 * 1 ; <S2SV_EndBug> server . vm_max_threads = 4 ; server . vm_blocked_clients = 0 ; server . hash_max_zipmap_entries = REDIS_HASH_MAX_ZIPMAP_ENTRIES ; server . hash_max_zipmap_value = REDIS_HASH_MAX_ZIPMAP_VALUE ; server . list_max_ziplist_entries = REDIS_LIST_MAX_ZIPLIST_ENTRIES ; server . list_max_ziplist_value = REDIS_LIST_MAX_ZIPLIST_VALUE ; server . set_max_intset_entries = REDIS_SET_MAX_INTSET_ENTRIES ; server . shutdown_asap = 0 ; updateLRUClock ( ) ; resetServerSaveParams ( ) ; appendServerSaveParams ( 60 * 60 , 1 ) ; appendServerSaveParams ( 300 , 100 ) ; appendServerSaveParams ( 60 , 10000 ) ; server . isslave = 0 ; server . masterauth = NULL ; server . masterhost = NULL ; server . masterport = 6379 ; server . master = NULL ; server . replstate = REDIS_REPL_NONE ; server . repl_serve_stale_data = 1 ; R_Zero = 0.0 ; R_PosInf = 1.0 / R_Zero ; R_NegInf = - 1.0 / R_Zero ; R_Nan = R_Zero / R_Zero ; server . commands = dictCreate ( & commandTableDictType , NULL ) ; populateCommandTable ( ) ; server . delCommand = lookupCommandByCString ( "del" ) ; server . multiCommand = lookupCommandByCString ( "multi" ) ; }
static int evaluate_inter_mode ( unsigned int * sse , int rate2 , int * distortion2 , VP8_COMP * cpi , MACROBLOCK * x , int rd_adj ) { MB_PREDICTION_MODE this_mode = x -> e_mbd . mode_info_context -> mbmi . mode ; int_mv mv = x -> e_mbd . mode_info_context -> mbmi . mv ; <S2SV_StartBug> int this_rd ; <S2SV_EndBug> if ( cpi -> active_map_enabled && x -> active_ptr [ 0 ] == 0 ) { * sse = 0 ; * distortion2 = 0 ; x -> skip = 1 ; return INT_MAX ; } if ( ( this_mode != NEWMV ) || ! ( cpi -> sf . half_pixel_search ) || cpi -> common . full_pixel == 1 ) * distortion2 = vp8_get_inter_mbpred_error ( x , & cpi -> fn_ptr [ BLOCK_16X16 ] , sse , mv ) ; this_rd = RDCOST ( x -> rdmult , x -> rddiv , rate2 , * distortion2 ) ; <S2SV_StartBug> if ( this_mode == ZEROMV ) <S2SV_EndBug> { <S2SV_StartBug> if ( ( cpi -> ref_frame_flags & VP8_LAST_FRAME & <S2SV_EndBug> cpi -> common . refresh_last_frame ) && x -> e_mbd . mode_info_context -> mbmi . ref_frame != LAST_FRAME ) rd_adj = 100 ; this_rd = ( ( int64_t ) this_rd ) * rd_adj / 100 ; } check_for_encode_breakout ( * sse , x ) ; return this_rd ; }
int adis_update_scan_mode ( struct iio_dev * indio_dev , const unsigned long * scan_mask ) { struct adis * adis = iio_device_get_drvdata ( indio_dev ) ; const struct iio_chan_spec * chan ; unsigned int scan_count ; unsigned int i , j ; __be16 * tx , * rx ; kfree ( adis -> xfer ) ; kfree ( adis -> buffer ) ; if ( adis -> burst && adis -> burst -> en ) return adis_update_scan_mode_burst ( indio_dev , scan_mask ) ; scan_count = indio_dev -> scan_bytes / 2 ; adis -> xfer = kcalloc ( scan_count + 1 , sizeof ( * adis -> xfer ) , GFP_KERNEL ) ; if ( ! adis -> xfer ) return - ENOMEM ; adis -> buffer = kcalloc ( indio_dev -> scan_bytes , 2 , GFP_KERNEL ) ; <S2SV_StartBug> if ( ! adis -> buffer ) <S2SV_EndBug> return - ENOMEM ; <S2SV_StartBug> rx = adis -> buffer ; <S2SV_EndBug> tx = rx + scan_count ; spi_message_init ( & adis -> msg ) ; for ( j = 0 ; j <= scan_count ; j ++ ) { adis -> xfer [ j ] . bits_per_word = 8 ; if ( j != scan_count ) adis -> xfer [ j ] . cs_change = 1 ; adis -> xfer [ j ] . len = 2 ; adis -> xfer [ j ] . delay_usecs = adis -> data -> read_delay ; if ( j < scan_count ) adis -> xfer [ j ] . tx_buf = & tx [ j ] ; if ( j >= 1 ) adis -> xfer [ j ] . rx_buf = & rx [ j - 1 ] ; spi_message_add_tail ( & adis -> xfer [ j ] , & adis -> msg ) ; } chan = indio_dev -> channels ; for ( i = 0 ; i < indio_dev -> num_channels ; i ++ , chan ++ ) { if ( ! test_bit ( chan -> scan_index , scan_mask ) ) continue ; if ( chan -> scan_type . storagebits == 32 ) * tx ++ = cpu_to_be16 ( ( chan -> address + 2 ) << 8 ) ; * tx ++ = cpu_to_be16 ( chan -> address << 8 ) ; } return 0 ; }
<S2SV_StartBug> static inline void jmp_rel ( struct x86_emulate_ctxt * ctxt , int rel ) <S2SV_EndBug> { <S2SV_StartBug> assign_eip_near ( ctxt , ctxt -> _eip + rel ) ; <S2SV_EndBug> }
static int8_t parse_ext_option ( uint16_t * dst , uint8_t * * packet_data_pptr , uint8_t * packet_data_start_ptr , uint16_t packet_len , uint16_t * message_left ) { uint16_t option_number = * dst ; if ( option_number == 13 ) { uint8_t option_ext ; int8_t read_result = sn_coap_parser_read_packet_u8 ( & option_ext , * packet_data_pptr , packet_data_start_ptr , packet_len ) ; if ( read_result != 0 ) { tr_error ( "sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>**packet_data_pptr<S2SV_blank>overflow<S2SV_blank>!" ) ; return - 1 ; } else { <S2SV_StartBug> option_number += option_ext ; <S2SV_EndBug> * message_left = sn_coap_parser_move_packet_ptr ( packet_data_pptr , packet_data_start_ptr , packet_len , 1 ) ; } } else if ( option_number == 14 ) { int8_t read_result = sn_coap_parser_read_packet_u16 ( & option_number , * packet_data_pptr , packet_data_start_ptr , packet_len ) ; if ( read_result != 0 ) { tr_error ( "sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>**packet_data_pptr<S2SV_blank>overflow<S2SV_blank>!" ) ; return - 1 ; } else { <S2SV_StartBug> option_number += 269 ; <S2SV_EndBug> * message_left = sn_coap_parser_move_packet_ptr ( packet_data_pptr , packet_data_start_ptr , packet_len , 2 ) ; } } else if ( option_number == 15 ) { tr_error ( "sn_coap_parser_options_parse<S2SV_blank>-<S2SV_blank>invalid<S2SV_blank>option<S2SV_blank>number(15)!" ) ; return - 1 ; } * dst = option_number ; return 0 ; }
void usb_sg_cancel ( struct usb_sg_request * io ) { unsigned long flags ; int i , retval ; spin_lock_irqsave ( & io -> lock , flags ) ; <S2SV_StartBug> if ( io -> status ) { <S2SV_EndBug> spin_unlock_irqrestore ( & io -> lock , flags ) ; return ; } io -> status = - ECONNRESET ; <S2SV_StartBug> spin_unlock_irqrestore ( & io -> lock , flags ) ; <S2SV_EndBug> for ( i = io -> entries - 1 ; i >= 0 ; -- i ) { usb_block_urb ( io -> urbs [ i ] ) ; retval = usb_unlink_urb ( io -> urbs [ i ] ) ; if ( retval != - EINPROGRESS && retval != - ENODEV && retval != - EBUSY && retval != - EIDRM ) dev_warn ( & io -> dev -> dev , "%s,<S2SV_blank>unlink<S2SV_blank>--><S2SV_blank>%d\\n" , __func__ , retval ) ; } <S2SV_StartBug> } <S2SV_EndBug>
error_t getHostByName ( NetInterface * interface , const char_t * name , IpAddr * ipAddr , uint_t flags ) { error_t error ; HostType type ; HostnameResolver protocol ; # if ( IPV4_SUPPORT == ENABLED ) type = HOST_TYPE_IPV4 ; # elif ( IPV6_SUPPORT == ENABLED ) type = HOST_TYPE_IPV6 ; # else type = HOST_TYPE_ANY ; # endif # if ( DNS_CLIENT_SUPPORT == ENABLED ) protocol = HOST_NAME_RESOLVER_DNS ; # elif ( MDNS_CLIENT_SUPPORT == ENABLED ) protocol = HOST_NAME_RESOLVER_MDNS ; # elif ( NBNS_CLIENT_SUPPORT == ENABLED ) protocol = HOST_NAME_RESOLVER_NBNS ; # elif ( LLMNR_CLIENT_SUPPORT == ENABLED ) protocol = HOST_NAME_RESOLVER_LLMNR ; # else protocol = HOST_NAME_RESOLVER_ANY ; # endif if ( name == NULL || ipAddr == NULL ) return ERROR_INVALID_PARAMETER ; if ( interface == NULL ) interface = netGetDefaultInterface ( ) ; error = ipStringToAddr ( name , ipAddr ) ; if ( error ) { if ( flags & HOST_TYPE_IPV4 ) type = HOST_TYPE_IPV4 ; else if ( flags & HOST_TYPE_IPV6 ) type = HOST_TYPE_IPV6 ; if ( flags & HOST_NAME_RESOLVER_DNS ) { protocol = HOST_NAME_RESOLVER_DNS ; } else if ( flags & HOST_NAME_RESOLVER_MDNS ) { protocol = HOST_NAME_RESOLVER_MDNS ; } else if ( flags & HOST_NAME_RESOLVER_NBNS ) { protocol = HOST_NAME_RESOLVER_NBNS ; } else if ( flags & HOST_NAME_RESOLVER_LLMNR ) { protocol = HOST_NAME_RESOLVER_LLMNR ; } else { size_t n = osStrlen ( name ) ; if ( n >= 6 && ! osStrcasecmp ( name + n - 6 , ".local" ) ) { # if ( MDNS_CLIENT_SUPPORT == ENABLED ) protocol = HOST_NAME_RESOLVER_MDNS ; # endif } <S2SV_StartBug> else if ( n <= 15 && ! strchr ( name , '.' ) && type == HOST_TYPE_IPV4 ) <S2SV_EndBug> { # if ( NBNS_CLIENT_SUPPORT == ENABLED ) protocol = HOST_NAME_RESOLVER_NBNS ; # endif } <S2SV_StartBug> else if ( ! strchr ( name , '.' ) ) <S2SV_EndBug> { # if ( LLMNR_CLIENT_SUPPORT == ENABLED ) protocol = HOST_NAME_RESOLVER_LLMNR ; # endif } } # if ( DNS_CLIENT_SUPPORT == ENABLED ) if ( protocol == HOST_NAME_RESOLVER_DNS ) { error = dnsResolve ( interface , name , type , ipAddr ) ; } else # endif # if ( MDNS_CLIENT_SUPPORT == ENABLED ) if ( protocol == HOST_NAME_RESOLVER_MDNS ) { error = mdnsClientResolve ( interface , name , type , ipAddr ) ; } else # endif # if ( NBNS_CLIENT_SUPPORT == ENABLED && IPV4_SUPPORT == ENABLED ) if ( protocol == HOST_NAME_RESOLVER_NBNS ) { error = nbnsResolve ( interface , name , ipAddr ) ; } else # endif # if ( LLMNR_CLIENT_SUPPORT == ENABLED ) if ( protocol == HOST_NAME_RESOLVER_LLMNR ) { error = llmnrResolve ( interface , name , type , ipAddr ) ; } else # endif { error = ERROR_INVALID_PARAMETER ; } } return error ; }
int ip6_fragment ( struct net * net , struct sock * sk , struct sk_buff * skb , int ( * output ) ( struct net * , struct sock * , struct sk_buff * ) ) { struct sk_buff * frag ; struct rt6_info * rt = ( struct rt6_info * ) skb_dst ( skb ) ; struct ipv6_pinfo * np = skb -> sk && ! dev_recursion_level ( ) ? inet6_sk ( skb -> sk ) : NULL ; struct ipv6hdr * tmp_hdr ; struct frag_hdr * fh ; unsigned int mtu , hlen , left , len ; int hroom , troom ; __be32 frag_id ; int ptr , offset = 0 , err = 0 ; u8 * prevhdr , nexthdr = 0 ; <S2SV_StartBug> hlen = ip6_find_1stfragopt ( skb , & prevhdr ) ; <S2SV_EndBug> nexthdr = * prevhdr ; mtu = ip6_skb_dst_mtu ( skb ) ; if ( unlikely ( ! skb -> ignore_df && skb -> len > mtu ) ) goto fail_toobig ; if ( IP6CB ( skb ) -> frag_max_size ) { if ( IP6CB ( skb ) -> frag_max_size > mtu ) goto fail_toobig ; mtu = IP6CB ( skb ) -> frag_max_size ; if ( mtu < IPV6_MIN_MTU ) mtu = IPV6_MIN_MTU ; } if ( np && np -> frag_size < mtu ) { if ( np -> frag_size ) mtu = np -> frag_size ; } if ( mtu < hlen + sizeof ( struct frag_hdr ) + 8 ) goto fail_toobig ; mtu -= hlen + sizeof ( struct frag_hdr ) ; frag_id = ipv6_select_ident ( net , & ipv6_hdr ( skb ) -> daddr , & ipv6_hdr ( skb ) -> saddr ) ; if ( skb -> ip_summed == CHECKSUM_PARTIAL && ( err = skb_checksum_help ( skb ) ) ) goto fail ; hroom = LL_RESERVED_SPACE ( rt -> dst . dev ) ; if ( skb_has_frag_list ( skb ) ) { unsigned int first_len = skb_pagelen ( skb ) ; struct sk_buff * frag2 ; if ( first_len - hlen > mtu || ( ( first_len - hlen ) & 7 ) || skb_cloned ( skb ) || skb_headroom ( skb ) < ( hroom + sizeof ( struct frag_hdr ) ) ) goto slow_path ; skb_walk_frags ( skb , frag ) { if ( frag -> len > mtu || ( ( frag -> len & 7 ) && frag -> next ) || skb_headroom ( frag ) < ( hlen + hroom + sizeof ( struct frag_hdr ) ) ) goto slow_path_clean ; if ( skb_shared ( frag ) ) goto slow_path_clean ; BUG_ON ( frag -> sk ) ; if ( skb -> sk ) { frag -> sk = skb -> sk ; frag -> destructor = sock_wfree ; } skb -> truesize -= frag -> truesize ; } err = 0 ; offset = 0 ; * prevhdr = NEXTHDR_FRAGMENT ; tmp_hdr = kmemdup ( skb_network_header ( skb ) , hlen , GFP_ATOMIC ) ; if ( ! tmp_hdr ) { IP6_INC_STATS ( net , ip6_dst_idev ( skb_dst ( skb ) ) , IPSTATS_MIB_FRAGFAILS ) ; err = - ENOMEM ; goto fail ; } frag = skb_shinfo ( skb ) -> frag_list ; skb_frag_list_init ( skb ) ; __skb_pull ( skb , hlen ) ; fh = ( struct frag_hdr * ) __skb_push ( skb , sizeof ( struct frag_hdr ) ) ; __skb_push ( skb , hlen ) ; skb_reset_network_header ( skb ) ; memcpy ( skb_network_header ( skb ) , tmp_hdr , hlen ) ; fh -> nexthdr = nexthdr ; fh -> reserved = 0 ; fh -> frag_off = htons ( IP6_MF ) ; fh -> identification = frag_id ; first_len = skb_pagelen ( skb ) ; skb -> data_len = first_len - skb_headlen ( skb ) ; skb -> len = first_len ; ipv6_hdr ( skb ) -> payload_len = htons ( first_len - sizeof ( struct ipv6hdr ) ) ; dst_hold ( & rt -> dst ) ; for ( ; ; ) { if ( frag ) { frag -> ip_summed = CHECKSUM_NONE ; skb_reset_transport_header ( frag ) ; fh = ( struct frag_hdr * ) __skb_push ( frag , sizeof ( struct frag_hdr ) ) ; __skb_push ( frag , hlen ) ; skb_reset_network_header ( frag ) ; memcpy ( skb_network_header ( frag ) , tmp_hdr , hlen ) ; offset += skb -> len - hlen - sizeof ( struct frag_hdr ) ; fh -> nexthdr = nexthdr ; fh -> reserved = 0 ; fh -> frag_off = htons ( offset ) ; if ( frag -> next ) fh -> frag_off |= htons ( IP6_MF ) ; fh -> identification = frag_id ; ipv6_hdr ( frag ) -> payload_len = htons ( frag -> len - sizeof ( struct ipv6hdr ) ) ; ip6_copy_metadata ( frag , skb ) ; } err = output ( net , sk , skb ) ; if ( ! err ) IP6_INC_STATS ( net , ip6_dst_idev ( & rt -> dst ) , IPSTATS_MIB_FRAGCREATES ) ; if ( err || ! frag ) break ; skb = frag ; frag = skb -> next ; skb -> next = NULL ; } kfree ( tmp_hdr ) ; if ( err == 0 ) { IP6_INC_STATS ( net , ip6_dst_idev ( & rt -> dst ) , IPSTATS_MIB_FRAGOKS ) ; ip6_rt_put ( rt ) ; return 0 ; } kfree_skb_list ( frag ) ; IP6_INC_STATS ( net , ip6_dst_idev ( & rt -> dst ) , IPSTATS_MIB_FRAGFAILS ) ; ip6_rt_put ( rt ) ; return err ; slow_path_clean : skb_walk_frags ( skb , frag2 ) { if ( frag2 == frag ) break ; frag2 -> sk = NULL ; frag2 -> destructor = NULL ; skb -> truesize += frag2 -> truesize ; } } slow_path : left = skb -> len - hlen ; ptr = hlen ; troom = rt -> dst . dev -> needed_tailroom ; while ( left > 0 ) { u8 * fragnexthdr_offset ; len = left ; if ( len > mtu ) len = mtu ; if ( len < left ) { len &= ~ 7 ; } frag = alloc_skb ( len + hlen + sizeof ( struct frag_hdr ) + hroom + troom , GFP_ATOMIC ) ; if ( ! frag ) { IP6_INC_STATS ( net , ip6_dst_idev ( skb_dst ( skb ) ) , IPSTATS_MIB_FRAGFAILS ) ; err = - ENOMEM ; goto fail ; } ip6_copy_metadata ( frag , skb ) ; skb_reserve ( frag , hroom ) ; skb_put ( frag , len + hlen + sizeof ( struct frag_hdr ) ) ; skb_reset_network_header ( frag ) ; fh = ( struct frag_hdr * ) ( skb_network_header ( frag ) + hlen ) ; frag -> transport_header = ( frag -> network_header + hlen + sizeof ( struct frag_hdr ) ) ; if ( skb -> sk ) skb_set_owner_w ( frag , skb -> sk ) ; skb_copy_from_linear_data ( skb , skb_network_header ( frag ) , hlen ) ; fragnexthdr_offset = skb_network_header ( frag ) ; fragnexthdr_offset += prevhdr - skb_network_header ( skb ) ; * fragnexthdr_offset = NEXTHDR_FRAGMENT ; fh -> nexthdr = nexthdr ; fh -> reserved = 0 ; fh -> identification = frag_id ; BUG_ON ( skb_copy_bits ( skb , ptr , skb_transport_header ( frag ) , len ) ) ; left -= len ; fh -> frag_off = htons ( offset ) ; if ( left > 0 ) fh -> frag_off |= htons ( IP6_MF ) ; ipv6_hdr ( frag ) -> payload_len = htons ( frag -> len - sizeof ( struct ipv6hdr ) ) ; ptr += len ; offset += len ; err = output ( net , sk , frag ) ; if ( err ) goto fail ; IP6_INC_STATS ( net , ip6_dst_idev ( skb_dst ( skb ) ) , IPSTATS_MIB_FRAGCREATES ) ; } IP6_INC_STATS ( net , ip6_dst_idev ( skb_dst ( skb ) ) , IPSTATS_MIB_FRAGOKS ) ; consume_skb ( skb ) ; return err ; fail_toobig : if ( skb -> sk && dst_allfrag ( skb_dst ( skb ) ) ) sk_nocaps_add ( skb -> sk , NETIF_F_GSO_MASK ) ; skb -> dev = skb_dst ( skb ) -> dev ; icmpv6_send ( skb , ICMPV6_PKT_TOOBIG , 0 , mtu ) ; err = - EMSGSIZE ; fail : IP6_INC_STATS ( net , ip6_dst_idev ( skb_dst ( skb ) ) , IPSTATS_MIB_FRAGFAILS ) ; kfree_skb ( skb ) ; return err ; }
int rds_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t size , int msg_flags ) { struct sock * sk = sock -> sk ; struct rds_sock * rs = rds_sk_to_rs ( sk ) ; long timeo ; int ret = 0 , nonblock = msg_flags & MSG_DONTWAIT ; struct sockaddr_in * sin ; struct rds_incoming * inc = NULL ; timeo = sock_rcvtimeo ( sk , nonblock ) ; <S2SV_StartBug> rdsdebug ( "size<S2SV_blank>%zu<S2SV_blank>flags<S2SV_blank>0x%x<S2SV_blank>timeo<S2SV_blank>%ld\\n" , size , msg_flags , timeo ) ; <S2SV_EndBug> if ( msg_flags & MSG_OOB ) goto out ; while ( 1 ) { if ( ! list_empty ( & rs -> rs_notify_queue ) ) { ret = rds_notify_queue_get ( rs , msg ) ; break ; } if ( rs -> rs_cong_notify ) { ret = rds_notify_cong ( rs , msg ) ; break ; } if ( ! rds_next_incoming ( rs , & inc ) ) { if ( nonblock ) { ret = - EAGAIN ; break ; } timeo = wait_event_interruptible_timeout ( * sk_sleep ( sk ) , ( ! list_empty ( & rs -> rs_notify_queue ) || rs -> rs_cong_notify || rds_next_incoming ( rs , & inc ) ) , timeo ) ; rdsdebug ( "recvmsg<S2SV_blank>woke<S2SV_blank>inc<S2SV_blank>%p<S2SV_blank>timeo<S2SV_blank>%ld\\n" , inc , timeo ) ; if ( timeo > 0 || timeo == MAX_SCHEDULE_TIMEOUT ) continue ; ret = timeo ; if ( ret == 0 ) ret = - ETIMEDOUT ; break ; } rdsdebug ( "copying<S2SV_blank>inc<S2SV_blank>%p<S2SV_blank>from<S2SV_blank>%pI4:%u<S2SV_blank>to<S2SV_blank>user\\n" , inc , & inc -> i_conn -> c_faddr , ntohs ( inc -> i_hdr . h_sport ) ) ; ret = inc -> i_conn -> c_trans -> inc_copy_to_user ( inc , msg -> msg_iov , size ) ; if ( ret < 0 ) break ; if ( ! rds_still_queued ( rs , inc , ! ( msg_flags & MSG_PEEK ) ) ) { rds_inc_put ( inc ) ; inc = NULL ; rds_stats_inc ( s_recv_deliver_raced ) ; continue ; } if ( ret < be32_to_cpu ( inc -> i_hdr . h_len ) ) { if ( msg_flags & MSG_TRUNC ) ret = be32_to_cpu ( inc -> i_hdr . h_len ) ; msg -> msg_flags |= MSG_TRUNC ; } if ( rds_cmsg_recv ( inc , msg ) ) { ret = - EFAULT ; goto out ; } rds_stats_inc ( s_recv_delivered ) ; sin = ( struct sockaddr_in * ) msg -> msg_name ; if ( sin ) { sin -> sin_family = AF_INET ; sin -> sin_port = inc -> i_hdr . h_sport ; sin -> sin_addr . s_addr = inc -> i_saddr ; memset ( sin -> sin_zero , 0 , sizeof ( sin -> sin_zero ) ) ; <S2SV_StartBug> } <S2SV_EndBug> break ; } if ( inc ) rds_inc_put ( inc ) ; out : return ret ; }
static int dgram_recvmsg ( struct kiocb * iocb , struct sock * sk , struct msghdr * msg , size_t len , int noblock , int flags , int * addr_len ) { size_t copied = 0 ; int err = - EOPNOTSUPP ; struct sk_buff * skb ; struct sockaddr_ieee802154 * saddr ; saddr = ( struct sockaddr_ieee802154 * ) msg -> msg_name ; skb = skb_recv_datagram ( sk , flags , noblock , & err ) ; if ( ! skb ) goto out ; copied = skb -> len ; if ( len < copied ) { msg -> msg_flags |= MSG_TRUNC ; copied = len ; } err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; if ( err ) goto done ; sock_recv_ts_and_drops ( msg , sk , skb ) ; if ( saddr ) { saddr -> family = AF_IEEE802154 ; saddr -> addr = mac_cb ( skb ) -> sa ; <S2SV_StartBug> } <S2SV_EndBug> if ( addr_len ) * addr_len = sizeof ( * saddr ) ; if ( flags & MSG_TRUNC ) copied = skb -> len ; done : skb_free_datagram ( sk , skb ) ; out : if ( err ) return err ; return copied ; }
<S2SV_StartBug> void fadst8_sse2 ( __m128i * in ) { <S2SV_EndBug> const __m128i k__cospi_p02_p30 = pair_set_epi16 ( cospi_2_64 , cospi_30_64 ) ; const __m128i k__cospi_p30_m02 = pair_set_epi16 ( cospi_30_64 , - cospi_2_64 ) ; const __m128i k__cospi_p10_p22 = pair_set_epi16 ( cospi_10_64 , cospi_22_64 ) ; const __m128i k__cospi_p22_m10 = pair_set_epi16 ( cospi_22_64 , - cospi_10_64 ) ; const __m128i k__cospi_p18_p14 = pair_set_epi16 ( cospi_18_64 , cospi_14_64 ) ; const __m128i k__cospi_p14_m18 = pair_set_epi16 ( cospi_14_64 , - cospi_18_64 ) ; const __m128i k__cospi_p26_p06 = pair_set_epi16 ( cospi_26_64 , cospi_6_64 ) ; const __m128i k__cospi_p06_m26 = pair_set_epi16 ( cospi_6_64 , - cospi_26_64 ) ; const __m128i k__cospi_p08_p24 = pair_set_epi16 ( cospi_8_64 , cospi_24_64 ) ; const __m128i k__cospi_p24_m08 = pair_set_epi16 ( cospi_24_64 , - cospi_8_64 ) ; const __m128i k__cospi_m24_p08 = pair_set_epi16 ( - cospi_24_64 , cospi_8_64 ) ; const __m128i k__cospi_p16_m16 = pair_set_epi16 ( cospi_16_64 , - cospi_16_64 ) ; <S2SV_StartBug> const __m128i k__cospi_p16_p16 = _mm_set1_epi16 ( cospi_16_64 ) ; <S2SV_EndBug> const __m128i k__const_0 = _mm_set1_epi16 ( 0 ) ; const __m128i k__DCT_CONST_ROUNDING = _mm_set1_epi32 ( DCT_CONST_ROUNDING ) ; __m128i u0 , u1 , u2 , u3 , u4 , u5 , u6 , u7 , u8 , u9 , u10 , u11 , u12 , u13 , u14 , u15 ; __m128i v0 , v1 , v2 , v3 , v4 , v5 , v6 , v7 , v8 , v9 , v10 , v11 , v12 , v13 , v14 , v15 ; __m128i w0 , w1 , w2 , w3 , w4 , w5 , w6 , w7 , w8 , w9 , w10 , w11 , w12 , w13 , w14 , w15 ; __m128i s0 , s1 , s2 , s3 , s4 , s5 , s6 , s7 ; __m128i in0 , in1 , in2 , in3 , in4 , in5 , in6 , in7 ; in0 = in [ 7 ] ; in1 = in [ 0 ] ; in2 = in [ 5 ] ; in3 = in [ 2 ] ; in4 = in [ 3 ] ; in5 = in [ 4 ] ; in6 = in [ 1 ] ; in7 = in [ 6 ] ; s0 = _mm_unpacklo_epi16 ( in0 , in1 ) ; s1 = _mm_unpackhi_epi16 ( in0 , in1 ) ; s2 = _mm_unpacklo_epi16 ( in2 , in3 ) ; s3 = _mm_unpackhi_epi16 ( in2 , in3 ) ; s4 = _mm_unpacklo_epi16 ( in4 , in5 ) ; s5 = _mm_unpackhi_epi16 ( in4 , in5 ) ; s6 = _mm_unpacklo_epi16 ( in6 , in7 ) ; s7 = _mm_unpackhi_epi16 ( in6 , in7 ) ; u0 = _mm_madd_epi16 ( s0 , k__cospi_p02_p30 ) ; u1 = _mm_madd_epi16 ( s1 , k__cospi_p02_p30 ) ; u2 = _mm_madd_epi16 ( s0 , k__cospi_p30_m02 ) ; u3 = _mm_madd_epi16 ( s1 , k__cospi_p30_m02 ) ; u4 = _mm_madd_epi16 ( s2 , k__cospi_p10_p22 ) ; u5 = _mm_madd_epi16 ( s3 , k__cospi_p10_p22 ) ; u6 = _mm_madd_epi16 ( s2 , k__cospi_p22_m10 ) ; u7 = _mm_madd_epi16 ( s3 , k__cospi_p22_m10 ) ; u8 = _mm_madd_epi16 ( s4 , k__cospi_p18_p14 ) ; u9 = _mm_madd_epi16 ( s5 , k__cospi_p18_p14 ) ; u10 = _mm_madd_epi16 ( s4 , k__cospi_p14_m18 ) ; u11 = _mm_madd_epi16 ( s5 , k__cospi_p14_m18 ) ; u12 = _mm_madd_epi16 ( s6 , k__cospi_p26_p06 ) ; u13 = _mm_madd_epi16 ( s7 , k__cospi_p26_p06 ) ; u14 = _mm_madd_epi16 ( s6 , k__cospi_p06_m26 ) ; u15 = _mm_madd_epi16 ( s7 , k__cospi_p06_m26 ) ; w0 = _mm_add_epi32 ( u0 , u8 ) ; w1 = _mm_add_epi32 ( u1 , u9 ) ; w2 = _mm_add_epi32 ( u2 , u10 ) ; w3 = _mm_add_epi32 ( u3 , u11 ) ; w4 = _mm_add_epi32 ( u4 , u12 ) ; w5 = _mm_add_epi32 ( u5 , u13 ) ; w6 = _mm_add_epi32 ( u6 , u14 ) ; w7 = _mm_add_epi32 ( u7 , u15 ) ; w8 = _mm_sub_epi32 ( u0 , u8 ) ; w9 = _mm_sub_epi32 ( u1 , u9 ) ; w10 = _mm_sub_epi32 ( u2 , u10 ) ; w11 = _mm_sub_epi32 ( u3 , u11 ) ; w12 = _mm_sub_epi32 ( u4 , u12 ) ; w13 = _mm_sub_epi32 ( u5 , u13 ) ; w14 = _mm_sub_epi32 ( u6 , u14 ) ; w15 = _mm_sub_epi32 ( u7 , u15 ) ; v0 = _mm_add_epi32 ( w0 , k__DCT_CONST_ROUNDING ) ; v1 = _mm_add_epi32 ( w1 , k__DCT_CONST_ROUNDING ) ; v2 = _mm_add_epi32 ( w2 , k__DCT_CONST_ROUNDING ) ; v3 = _mm_add_epi32 ( w3 , k__DCT_CONST_ROUNDING ) ; v4 = _mm_add_epi32 ( w4 , k__DCT_CONST_ROUNDING ) ; v5 = _mm_add_epi32 ( w5 , k__DCT_CONST_ROUNDING ) ; v6 = _mm_add_epi32 ( w6 , k__DCT_CONST_ROUNDING ) ; v7 = _mm_add_epi32 ( w7 , k__DCT_CONST_ROUNDING ) ; v8 = _mm_add_epi32 ( w8 , k__DCT_CONST_ROUNDING ) ; v9 = _mm_add_epi32 ( w9 , k__DCT_CONST_ROUNDING ) ; v10 = _mm_add_epi32 ( w10 , k__DCT_CONST_ROUNDING ) ; v11 = _mm_add_epi32 ( w11 , k__DCT_CONST_ROUNDING ) ; v12 = _mm_add_epi32 ( w12 , k__DCT_CONST_ROUNDING ) ; v13 = _mm_add_epi32 ( w13 , k__DCT_CONST_ROUNDING ) ; v14 = _mm_add_epi32 ( w14 , k__DCT_CONST_ROUNDING ) ; v15 = _mm_add_epi32 ( w15 , k__DCT_CONST_ROUNDING ) ; u0 = _mm_srai_epi32 ( v0 , DCT_CONST_BITS ) ; u1 = _mm_srai_epi32 ( v1 , DCT_CONST_BITS ) ; u2 = _mm_srai_epi32 ( v2 , DCT_CONST_BITS ) ; u3 = _mm_srai_epi32 ( v3 , DCT_CONST_BITS ) ; u4 = _mm_srai_epi32 ( v4 , DCT_CONST_BITS ) ; u5 = _mm_srai_epi32 ( v5 , DCT_CONST_BITS ) ; u6 = _mm_srai_epi32 ( v6 , DCT_CONST_BITS ) ; u7 = _mm_srai_epi32 ( v7 , DCT_CONST_BITS ) ; u8 = _mm_srai_epi32 ( v8 , DCT_CONST_BITS ) ; u9 = _mm_srai_epi32 ( v9 , DCT_CONST_BITS ) ; u10 = _mm_srai_epi32 ( v10 , DCT_CONST_BITS ) ; u11 = _mm_srai_epi32 ( v11 , DCT_CONST_BITS ) ; u12 = _mm_srai_epi32 ( v12 , DCT_CONST_BITS ) ; u13 = _mm_srai_epi32 ( v13 , DCT_CONST_BITS ) ; u14 = _mm_srai_epi32 ( v14 , DCT_CONST_BITS ) ; u15 = _mm_srai_epi32 ( v15 , DCT_CONST_BITS ) ; in [ 0 ] = _mm_packs_epi32 ( u0 , u1 ) ; in [ 1 ] = _mm_packs_epi32 ( u2 , u3 ) ; in [ 2 ] = _mm_packs_epi32 ( u4 , u5 ) ; in [ 3 ] = _mm_packs_epi32 ( u6 , u7 ) ; in [ 4 ] = _mm_packs_epi32 ( u8 , u9 ) ; in [ 5 ] = _mm_packs_epi32 ( u10 , u11 ) ; in [ 6 ] = _mm_packs_epi32 ( u12 , u13 ) ; in [ 7 ] = _mm_packs_epi32 ( u14 , u15 ) ; s0 = _mm_add_epi16 ( in [ 0 ] , in [ 2 ] ) ; s1 = _mm_add_epi16 ( in [ 1 ] , in [ 3 ] ) ; s2 = _mm_sub_epi16 ( in [ 0 ] , in [ 2 ] ) ; s3 = _mm_sub_epi16 ( in [ 1 ] , in [ 3 ] ) ; u0 = _mm_unpacklo_epi16 ( in [ 4 ] , in [ 5 ] ) ; u1 = _mm_unpackhi_epi16 ( in [ 4 ] , in [ 5 ] ) ; u2 = _mm_unpacklo_epi16 ( in [ 6 ] , in [ 7 ] ) ; u3 = _mm_unpackhi_epi16 ( in [ 6 ] , in [ 7 ] ) ; v0 = _mm_madd_epi16 ( u0 , k__cospi_p08_p24 ) ; v1 = _mm_madd_epi16 ( u1 , k__cospi_p08_p24 ) ; v2 = _mm_madd_epi16 ( u0 , k__cospi_p24_m08 ) ; v3 = _mm_madd_epi16 ( u1 , k__cospi_p24_m08 ) ; v4 = _mm_madd_epi16 ( u2 , k__cospi_m24_p08 ) ; v5 = _mm_madd_epi16 ( u3 , k__cospi_m24_p08 ) ; v6 = _mm_madd_epi16 ( u2 , k__cospi_p08_p24 ) ; v7 = _mm_madd_epi16 ( u3 , k__cospi_p08_p24 ) ; w0 = _mm_add_epi32 ( v0 , v4 ) ; w1 = _mm_add_epi32 ( v1 , v5 ) ; w2 = _mm_add_epi32 ( v2 , v6 ) ; w3 = _mm_add_epi32 ( v3 , v7 ) ; w4 = _mm_sub_epi32 ( v0 , v4 ) ; w5 = _mm_sub_epi32 ( v1 , v5 ) ; w6 = _mm_sub_epi32 ( v2 , v6 ) ; w7 = _mm_sub_epi32 ( v3 , v7 ) ; v0 = _mm_add_epi32 ( w0 , k__DCT_CONST_ROUNDING ) ; v1 = _mm_add_epi32 ( w1 , k__DCT_CONST_ROUNDING ) ; v2 = _mm_add_epi32 ( w2 , k__DCT_CONST_ROUNDING ) ; v3 = _mm_add_epi32 ( w3 , k__DCT_CONST_ROUNDING ) ; v4 = _mm_add_epi32 ( w4 , k__DCT_CONST_ROUNDING ) ; v5 = _mm_add_epi32 ( w5 , k__DCT_CONST_ROUNDING ) ; v6 = _mm_add_epi32 ( w6 , k__DCT_CONST_ROUNDING ) ; v7 = _mm_add_epi32 ( w7 , k__DCT_CONST_ROUNDING ) ; u0 = _mm_srai_epi32 ( v0 , DCT_CONST_BITS ) ; u1 = _mm_srai_epi32 ( v1 , DCT_CONST_BITS ) ; u2 = _mm_srai_epi32 ( v2 , DCT_CONST_BITS ) ; u3 = _mm_srai_epi32 ( v3 , DCT_CONST_BITS ) ; u4 = _mm_srai_epi32 ( v4 , DCT_CONST_BITS ) ; u5 = _mm_srai_epi32 ( v5 , DCT_CONST_BITS ) ; u6 = _mm_srai_epi32 ( v6 , DCT_CONST_BITS ) ; u7 = _mm_srai_epi32 ( v7 , DCT_CONST_BITS ) ; s4 = _mm_packs_epi32 ( u0 , u1 ) ; s5 = _mm_packs_epi32 ( u2 , u3 ) ; s6 = _mm_packs_epi32 ( u4 , u5 ) ; s7 = _mm_packs_epi32 ( u6 , u7 ) ; u0 = _mm_unpacklo_epi16 ( s2 , s3 ) ; u1 = _mm_unpackhi_epi16 ( s2 , s3 ) ; u2 = _mm_unpacklo_epi16 ( s6 , s7 ) ; u3 = _mm_unpackhi_epi16 ( s6 , s7 ) ; v0 = _mm_madd_epi16 ( u0 , k__cospi_p16_p16 ) ; v1 = _mm_madd_epi16 ( u1 , k__cospi_p16_p16 ) ; v2 = _mm_madd_epi16 ( u0 , k__cospi_p16_m16 ) ; v3 = _mm_madd_epi16 ( u1 , k__cospi_p16_m16 ) ; v4 = _mm_madd_epi16 ( u2 , k__cospi_p16_p16 ) ; v5 = _mm_madd_epi16 ( u3 , k__cospi_p16_p16 ) ; v6 = _mm_madd_epi16 ( u2 , k__cospi_p16_m16 ) ; v7 = _mm_madd_epi16 ( u3 , k__cospi_p16_m16 ) ; u0 = _mm_add_epi32 ( v0 , k__DCT_CONST_ROUNDING ) ; u1 = _mm_add_epi32 ( v1 , k__DCT_CONST_ROUNDING ) ; u2 = _mm_add_epi32 ( v2 , k__DCT_CONST_ROUNDING ) ; u3 = _mm_add_epi32 ( v3 , k__DCT_CONST_ROUNDING ) ; u4 = _mm_add_epi32 ( v4 , k__DCT_CONST_ROUNDING ) ; u5 = _mm_add_epi32 ( v5 , k__DCT_CONST_ROUNDING ) ; u6 = _mm_add_epi32 ( v6 , k__DCT_CONST_ROUNDING ) ; u7 = _mm_add_epi32 ( v7 , k__DCT_CONST_ROUNDING ) ; v0 = _mm_srai_epi32 ( u0 , DCT_CONST_BITS ) ; v1 = _mm_srai_epi32 ( u1 , DCT_CONST_BITS ) ; v2 = _mm_srai_epi32 ( u2 , DCT_CONST_BITS ) ; v3 = _mm_srai_epi32 ( u3 , DCT_CONST_BITS ) ; v4 = _mm_srai_epi32 ( u4 , DCT_CONST_BITS ) ; v5 = _mm_srai_epi32 ( u5 , DCT_CONST_BITS ) ; v6 = _mm_srai_epi32 ( u6 , DCT_CONST_BITS ) ; v7 = _mm_srai_epi32 ( u7 , DCT_CONST_BITS ) ; s2 = _mm_packs_epi32 ( v0 , v1 ) ; s3 = _mm_packs_epi32 ( v2 , v3 ) ; s6 = _mm_packs_epi32 ( v4 , v5 ) ; s7 = _mm_packs_epi32 ( v6 , v7 ) ; in [ 0 ] = s0 ; in [ 1 ] = _mm_sub_epi16 ( k__const_0 , s4 ) ; in [ 2 ] = s6 ; in [ 3 ] = _mm_sub_epi16 ( k__const_0 , s2 ) ; in [ 4 ] = s3 ; in [ 5 ] = _mm_sub_epi16 ( k__const_0 , s7 ) ; in [ 6 ] = s5 ; in [ 7 ] = _mm_sub_epi16 ( k__const_0 , s1 ) ; array_transpose_8x8 ( in , in ) ; }
static struct dentry * ecryptfs_mount ( struct file_system_type * fs_type , int flags , const char * dev_name , void * raw_data ) { struct super_block * s ; struct ecryptfs_sb_info * sbi ; struct ecryptfs_dentry_info * root_info ; const char * err = "Getting<S2SV_blank>sb<S2SV_blank>failed" ; struct inode * inode ; struct path path ; <S2SV_StartBug> int rc ; <S2SV_EndBug> sbi = kmem_cache_zalloc ( ecryptfs_sb_info_cache , GFP_KERNEL ) ; if ( ! sbi ) { rc = - ENOMEM ; goto out ; } <S2SV_StartBug> rc = ecryptfs_parse_options ( sbi , raw_data ) ; <S2SV_EndBug> if ( rc ) { err = "Error<S2SV_blank>parsing<S2SV_blank>options" ; goto out ; } s = sget ( fs_type , NULL , set_anon_super , NULL ) ; if ( IS_ERR ( s ) ) { rc = PTR_ERR ( s ) ; goto out ; } s -> s_flags = flags ; rc = bdi_setup_and_register ( & sbi -> bdi , "ecryptfs" , BDI_CAP_MAP_COPY ) ; if ( rc ) goto out1 ; ecryptfs_set_superblock_private ( s , sbi ) ; s -> s_bdi = & sbi -> bdi ; sbi = NULL ; s -> s_op = & ecryptfs_sops ; s -> s_d_op = & ecryptfs_dops ; err = "Reading<S2SV_blank>sb<S2SV_blank>failed" ; rc = kern_path ( dev_name , LOOKUP_FOLLOW | LOOKUP_DIRECTORY , & path ) ; if ( rc ) { ecryptfs_printk ( KERN_WARNING , "kern_path()<S2SV_blank>failed\\n" ) ; goto out1 ; } if ( path . dentry -> d_sb -> s_type == & ecryptfs_fs_type ) { rc = - EINVAL ; printk ( KERN_ERR "Mount<S2SV_blank>on<S2SV_blank>filesystem<S2SV_blank>of<S2SV_blank>type<S2SV_blank>" "eCryptfs<S2SV_blank>explicitly<S2SV_blank>disallowed<S2SV_blank>due<S2SV_blank>to<S2SV_blank>" "known<S2SV_blank>incompatibilities\\n" ) ; goto out_free ; } <S2SV_StartBug> ecryptfs_set_superblock_lower ( s , path . dentry -> d_sb ) ; <S2SV_EndBug> s -> s_maxbytes = path . dentry -> d_sb -> s_maxbytes ; s -> s_blocksize = path . dentry -> d_sb -> s_blocksize ; s -> s_magic = ECRYPTFS_SUPER_MAGIC ; inode = ecryptfs_get_inode ( path . dentry -> d_inode , s ) ; rc = PTR_ERR ( inode ) ; if ( IS_ERR ( inode ) ) goto out_free ; s -> s_root = d_alloc_root ( inode ) ; if ( ! s -> s_root ) { iput ( inode ) ; rc = - ENOMEM ; goto out_free ; } rc = - ENOMEM ; root_info = kmem_cache_zalloc ( ecryptfs_dentry_info_cache , GFP_KERNEL ) ; if ( ! root_info ) goto out_free ; ecryptfs_set_dentry_private ( s -> s_root , root_info ) ; ecryptfs_set_dentry_lower ( s -> s_root , path . dentry ) ; ecryptfs_set_dentry_lower_mnt ( s -> s_root , path . mnt ) ; s -> s_flags |= MS_ACTIVE ; return dget ( s -> s_root ) ; out_free : path_put ( & path ) ; out1 : deactivate_locked_super ( s ) ; out : if ( sbi ) { ecryptfs_destroy_mount_crypt_stat ( & sbi -> mount_crypt_stat ) ; kmem_cache_free ( ecryptfs_sb_info_cache , sbi ) ; } printk ( KERN_ERR "%s;<S2SV_blank>rc<S2SV_blank>=<S2SV_blank>[%d]\\n" , err , rc ) ; return ERR_PTR ( rc ) ; }
static int kvm_ioctl_create_device ( struct kvm * kvm , struct kvm_create_device * cd ) { struct kvm_device_ops * ops = NULL ; struct kvm_device * dev ; bool test = cd -> flags & KVM_CREATE_DEVICE_TEST ; int ret ; if ( cd -> type >= ARRAY_SIZE ( kvm_device_ops_table ) ) return - ENODEV ; ops = kvm_device_ops_table [ cd -> type ] ; if ( ops == NULL ) return - ENODEV ; if ( test ) return 0 ; dev = kzalloc ( sizeof ( * dev ) , GFP_KERNEL ) ; if ( ! dev ) return - ENOMEM ; dev -> ops = ops ; dev -> kvm = kvm ; mutex_lock ( & kvm -> lock ) ; ret = ops -> create ( dev , cd -> type ) ; if ( ret < 0 ) { mutex_unlock ( & kvm -> lock ) ; kfree ( dev ) ; return ret ; } list_add ( & dev -> vm_node , & kvm -> devices ) ; mutex_unlock ( & kvm -> lock ) ; if ( ops -> init ) ops -> init ( dev ) ; <S2SV_StartBug> ret = anon_inode_getfd ( ops -> name , & kvm_device_fops , dev , O_RDWR | O_CLOEXEC ) ; <S2SV_EndBug> if ( ret < 0 ) { <S2SV_StartBug> mutex_lock ( & kvm -> lock ) ; <S2SV_EndBug> list_del ( & dev -> vm_node ) ; mutex_unlock ( & kvm -> lock ) ; ops -> destroy ( dev ) ; return ret ; } <S2SV_StartBug> kvm_get_kvm ( kvm ) ; <S2SV_EndBug> cd -> fd = ret ; return 0 ; }
void dwg_free_object ( Dwg_Object * obj ) { int error = 0 ; long unsigned int j ; Dwg_Data * dwg ; Bit_Chain * dat = & pdat ; if ( obj && obj -> parent ) { dwg = obj -> parent ; dat -> version = dwg -> header . version ; } else return ; if ( obj -> type == DWG_TYPE_FREED || obj -> tio . object == NULL ) return ; dat -> from_version = dat -> version ; if ( obj -> supertype == DWG_SUPERTYPE_UNKNOWN ) goto unhandled ; switch ( obj -> type ) { case DWG_TYPE_TEXT : dwg_free_TEXT ( dat , obj ) ; break ; case DWG_TYPE_ATTRIB : dwg_free_ATTRIB ( dat , obj ) ; break ; case DWG_TYPE_ATTDEF : dwg_free_ATTDEF ( dat , obj ) ; break ; case DWG_TYPE_BLOCK : dwg_free_BLOCK ( dat , obj ) ; break ; case DWG_TYPE_ENDBLK : dwg_free_ENDBLK ( dat , obj ) ; break ; case DWG_TYPE_SEQEND : dwg_free_SEQEND ( dat , obj ) ; break ; case DWG_TYPE_INSERT : dwg_free_INSERT ( dat , obj ) ; break ; case DWG_TYPE_MINSERT : dwg_free_MINSERT ( dat , obj ) ; break ; case DWG_TYPE_VERTEX_2D : dwg_free_VERTEX_2D ( dat , obj ) ; break ; case DWG_TYPE_VERTEX_3D : dwg_free_VERTEX_3D ( dat , obj ) ; break ; case DWG_TYPE_VERTEX_MESH : dwg_free_VERTEX_MESH ( dat , obj ) ; break ; case DWG_TYPE_VERTEX_PFACE : dwg_free_VERTEX_PFACE ( dat , obj ) ; break ; case DWG_TYPE_VERTEX_PFACE_FACE : dwg_free_VERTEX_PFACE_FACE ( dat , obj ) ; break ; case DWG_TYPE_POLYLINE_2D : dwg_free_POLYLINE_2D ( dat , obj ) ; break ; case DWG_TYPE_POLYLINE_3D : dwg_free_POLYLINE_3D ( dat , obj ) ; break ; case DWG_TYPE_ARC : dwg_free_ARC ( dat , obj ) ; break ; case DWG_TYPE_CIRCLE : dwg_free_CIRCLE ( dat , obj ) ; break ; case DWG_TYPE_LINE : dwg_free_LINE ( dat , obj ) ; break ; case DWG_TYPE_DIMENSION_ORDINATE : dwg_free_DIMENSION_ORDINATE ( dat , obj ) ; break ; case DWG_TYPE_DIMENSION_LINEAR : dwg_free_DIMENSION_LINEAR ( dat , obj ) ; break ; case DWG_TYPE_DIMENSION_ALIGNED : dwg_free_DIMENSION_ALIGNED ( dat , obj ) ; break ; case DWG_TYPE_DIMENSION_ANG3PT : dwg_free_DIMENSION_ANG3PT ( dat , obj ) ; break ; case DWG_TYPE_DIMENSION_ANG2LN : dwg_free_DIMENSION_ANG2LN ( dat , obj ) ; break ; case DWG_TYPE_DIMENSION_RADIUS : dwg_free_DIMENSION_RADIUS ( dat , obj ) ; break ; case DWG_TYPE_DIMENSION_DIAMETER : dwg_free_DIMENSION_DIAMETER ( dat , obj ) ; break ; case DWG_TYPE_POINT : dwg_free_POINT ( dat , obj ) ; break ; case DWG_TYPE__3DFACE : dwg_free__3DFACE ( dat , obj ) ; break ; case DWG_TYPE_POLYLINE_PFACE : dwg_free_POLYLINE_PFACE ( dat , obj ) ; break ; case DWG_TYPE_POLYLINE_MESH : dwg_free_POLYLINE_MESH ( dat , obj ) ; break ; case DWG_TYPE_SOLID : dwg_free_SOLID ( dat , obj ) ; break ; case DWG_TYPE_TRACE : dwg_free_TRACE ( dat , obj ) ; break ; case DWG_TYPE_SHAPE : dwg_free_SHAPE ( dat , obj ) ; break ; case DWG_TYPE_VIEWPORT : dwg_free_VIEWPORT ( dat , obj ) ; break ; case DWG_TYPE_ELLIPSE : dwg_free_ELLIPSE ( dat , obj ) ; break ; case DWG_TYPE_SPLINE : dwg_free_SPLINE ( dat , obj ) ; break ; case DWG_TYPE_REGION : dwg_free_REGION ( dat , obj ) ; break ; case DWG_TYPE__3DSOLID : dwg_free__3DSOLID ( dat , obj ) ; break ; case DWG_TYPE_BODY : dwg_free_BODY ( dat , obj ) ; break ; case DWG_TYPE_RAY : dwg_free_RAY ( dat , obj ) ; break ; case DWG_TYPE_XLINE : dwg_free_XLINE ( dat , obj ) ; break ; case DWG_TYPE_DICTIONARY : dwg_free_DICTIONARY ( dat , obj ) ; break ; case DWG_TYPE_MTEXT : dwg_free_MTEXT ( dat , obj ) ; break ; case DWG_TYPE_LEADER : dwg_free_LEADER ( dat , obj ) ; break ; case DWG_TYPE_TOLERANCE : dwg_free_TOLERANCE ( dat , obj ) ; break ; case DWG_TYPE_MLINE : dwg_free_MLINE ( dat , obj ) ; break ; case DWG_TYPE_BLOCK_CONTROL : dwg_free_BLOCK_CONTROL ( dat , obj ) ; break ; case DWG_TYPE_BLOCK_HEADER : dwg_free_BLOCK_HEADER ( dat , obj ) ; break ; case DWG_TYPE_LAYER_CONTROL : dwg_free_LAYER_CONTROL ( dat , obj ) ; break ; case DWG_TYPE_LAYER : dwg_free_LAYER ( dat , obj ) ; break ; case DWG_TYPE_STYLE_CONTROL : dwg_free_STYLE_CONTROL ( dat , obj ) ; break ; case DWG_TYPE_STYLE : dwg_free_STYLE ( dat , obj ) ; break ; case DWG_TYPE_LTYPE_CONTROL : dwg_free_LTYPE_CONTROL ( dat , obj ) ; break ; case DWG_TYPE_LTYPE : dwg_free_LTYPE ( dat , obj ) ; break ; case DWG_TYPE_VIEW_CONTROL : dwg_free_VIEW_CONTROL ( dat , obj ) ; break ; case DWG_TYPE_VIEW : dwg_free_VIEW ( dat , obj ) ; break ; case DWG_TYPE_UCS_CONTROL : dwg_free_UCS_CONTROL ( dat , obj ) ; break ; case DWG_TYPE_UCS : dwg_free_UCS ( dat , obj ) ; break ; case DWG_TYPE_VPORT_CONTROL : dwg_free_VPORT_CONTROL ( dat , obj ) ; break ; case DWG_TYPE_VPORT : dwg_free_VPORT ( dat , obj ) ; break ; case DWG_TYPE_APPID_CONTROL : dwg_free_APPID_CONTROL ( dat , obj ) ; break ; case DWG_TYPE_APPID : dwg_free_APPID ( dat , obj ) ; break ; case DWG_TYPE_DIMSTYLE_CONTROL : dwg_free_DIMSTYLE_CONTROL ( dat , obj ) ; break ; case DWG_TYPE_DIMSTYLE : dwg_free_DIMSTYLE ( dat , obj ) ; break ; case DWG_TYPE_VPORT_ENTITY_CONTROL : dwg_free_VPORT_ENTITY_CONTROL ( dat , obj ) ; break ; case DWG_TYPE_VPORT_ENTITY_HEADER : dwg_free_VPORT_ENTITY_HEADER ( dat , obj ) ; break ; case DWG_TYPE_GROUP : dwg_free_GROUP ( dat , obj ) ; break ; case DWG_TYPE_MLINESTYLE : dwg_free_MLINESTYLE ( dat , obj ) ; break ; case DWG_TYPE_OLE2FRAME : dwg_free_OLE2FRAME ( dat , obj ) ; break ; case DWG_TYPE_DUMMY : dwg_free_DUMMY ( dat , obj ) ; break ; case DWG_TYPE_LONG_TRANSACTION : dwg_free_LONG_TRANSACTION ( dat , obj ) ; break ; case DWG_TYPE_LWPOLYLINE : dwg_free_LWPOLYLINE ( dat , obj ) ; break ; case DWG_TYPE_HATCH : dwg_free_HATCH ( dat , obj ) ; break ; case DWG_TYPE_XRECORD : dwg_free_XRECORD ( dat , obj ) ; break ; case DWG_TYPE_PLACEHOLDER : dwg_free_PLACEHOLDER ( dat , obj ) ; break ; case DWG_TYPE_OLEFRAME : dwg_free_OLEFRAME ( dat , obj ) ; break ; # ifdef DEBUG_VBA_PROJECT case DWG_TYPE_VBA_PROJECT : dwg_free_VBA_PROJECT ( dat , obj ) ; break ; # endif case DWG_TYPE_LAYOUT : dwg_free_LAYOUT ( dat , obj ) ; break ; case DWG_TYPE_PROXY_ENTITY : dwg_free_PROXY_ENTITY ( dat , obj ) ; break ; case DWG_TYPE_PROXY_OBJECT : dwg_free_PROXY_OBJECT ( dat , obj ) ; break ; default : if ( obj -> type == obj -> parent -> layout_type ) { SINCE ( R_13 ) { dwg_free_LAYOUT ( dat , obj ) ; } } else if ( ( error = dwg_free_variable_type ( obj -> parent , obj ) ) & DWG_ERR_UNHANDLEDCLASS ) { <S2SV_StartBug> int is_entity ; <S2SV_EndBug> int i ; Dwg_Class * klass ; unhandled : is_entity = 0 ; i = obj -> type - 500 ; klass = NULL ; dwg = obj -> parent ; if ( dwg -> dwg_class && i >= 0 && i < ( int ) dwg -> num_classes ) { klass = & dwg -> dwg_class [ i ] ; is_entity = klass ? dwg_class_is_entity ( klass ) : 0 ; } <S2SV_StartBug> if ( obj -> fixedtype == DWG_TYPE_TABLE ) <S2SV_EndBug> { dwg_free_UNKNOWN_ENT ( dat , obj ) ; <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> else if ( obj -> fixedtype == DWG_TYPE_DATATABLE ) <S2SV_EndBug> { dwg_free_UNKNOWN_OBJ ( dat , obj ) ; <S2SV_StartBug> } <S2SV_EndBug> else if ( klass && ! is_entity ) { dwg_free_UNKNOWN_OBJ ( dat , obj ) ; } else if ( klass && is_entity ) { dwg_free_UNKNOWN_ENT ( dat , obj ) ; } else { FREE_IF ( obj -> tio . unknown ) ; } } } if ( dwg -> opts & DWG_OPTS_INDXF ) FREE_IF ( obj -> dxfname ) ; obj -> type = DWG_TYPE_FREED ; }
static int set_evtchn_to_irq ( evtchn_port_t evtchn , unsigned int irq ) { unsigned row ; unsigned col ; if ( evtchn >= xen_evtchn_max_channels ( ) ) return - EINVAL ; row = EVTCHN_ROW ( evtchn ) ; col = EVTCHN_COL ( evtchn ) ; if ( evtchn_to_irq [ row ] == NULL ) { if ( irq == - 1 ) return 0 ; evtchn_to_irq [ row ] = ( int * ) get_zeroed_page ( GFP_KERNEL ) ; if ( evtchn_to_irq [ row ] == NULL ) return - ENOMEM ; clear_evtchn_to_irq_row ( row ) ; } <S2SV_StartBug> evtchn_to_irq [ row ] [ col ] = irq ; <S2SV_EndBug> return 0 ; }
int ASN1_verify ( i2d_of_void * i2d , X509_ALGOR * a , ASN1_BIT_STRING * signature , char * data , EVP_PKEY * pkey ) { EVP_MD_CTX ctx ; const EVP_MD * type ; unsigned char * p , * buf_in = NULL ; int ret = - 1 , i , inl ; EVP_MD_CTX_init ( & ctx ) ; i = OBJ_obj2nid ( a -> algorithm ) ; type = EVP_get_digestbyname ( OBJ_nid2sn ( i ) ) ; if ( type == NULL ) { ASN1err ( ASN1_F_ASN1_VERIFY , ASN1_R_UNKNOWN_MESSAGE_DIGEST_ALGORITHM ) ; goto err ; } <S2SV_StartBug> inl = i2d ( data , NULL ) ; <S2SV_EndBug> buf_in = OPENSSL_malloc ( ( unsigned int ) inl ) ; if ( buf_in == NULL ) { ASN1err ( ASN1_F_ASN1_VERIFY , ERR_R_MALLOC_FAILURE ) ; goto err ; } p = buf_in ; i2d ( data , & p ) ; ret = EVP_VerifyInit_ex ( & ctx , type , NULL ) && EVP_VerifyUpdate ( & ctx , ( unsigned char * ) buf_in , inl ) ; OPENSSL_cleanse ( buf_in , ( unsigned int ) inl ) ; OPENSSL_free ( buf_in ) ; if ( ! ret ) { ASN1err ( ASN1_F_ASN1_VERIFY , ERR_R_EVP_LIB ) ; goto err ; } ret = - 1 ; if ( EVP_VerifyFinal ( & ctx , ( unsigned char * ) signature -> data , ( unsigned int ) signature -> length , pkey ) <= 0 ) { ASN1err ( ASN1_F_ASN1_VERIFY , ERR_R_EVP_LIB ) ; ret = 0 ; goto err ; } ret = 1 ; err : EVP_MD_CTX_cleanup ( & ctx ) ; return ( ret ) ; }
static int simulate_sync ( struct pt_regs * regs , unsigned int opcode ) { if ( ( opcode & OPCODE ) == SPEC0 && ( opcode & FUNC ) == SYNC ) { perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , <S2SV_StartBug> 1 , 0 , regs , 0 ) ; <S2SV_EndBug> return 0 ; } return - 1 ; }
int assoc_array_gc ( struct assoc_array * array , const struct assoc_array_ops * ops , bool ( * iterator ) ( void * object , void * iterator_data ) , void * iterator_data ) { struct assoc_array_shortcut * shortcut , * new_s ; struct assoc_array_node * node , * new_n ; struct assoc_array_edit * edit ; struct assoc_array_ptr * cursor , * ptr ; struct assoc_array_ptr * new_root , * new_parent , * * new_ptr_pp ; unsigned long nr_leaves_on_tree ; int keylen , slot , nr_free , next_slot , i ; pr_devel ( "-->%s()\\n" , __func__ ) ; if ( ! array -> root ) return 0 ; edit = kzalloc ( sizeof ( struct assoc_array_edit ) , GFP_KERNEL ) ; if ( ! edit ) return - ENOMEM ; edit -> array = array ; edit -> ops = ops ; edit -> ops_for_excised_subtree = ops ; edit -> set [ 0 ] . ptr = & array -> root ; edit -> excised_subtree = array -> root ; new_root = new_parent = NULL ; new_ptr_pp = & new_root ; cursor = array -> root ; descend : if ( assoc_array_ptr_is_shortcut ( cursor ) ) { shortcut = assoc_array_ptr_to_shortcut ( cursor ) ; keylen = round_up ( shortcut -> skip_to_level , ASSOC_ARRAY_KEY_CHUNK_SIZE ) ; keylen >>= ASSOC_ARRAY_KEY_CHUNK_SHIFT ; new_s = kmalloc ( sizeof ( struct assoc_array_shortcut ) + keylen * sizeof ( unsigned long ) , GFP_KERNEL ) ; if ( ! new_s ) goto enomem ; pr_devel ( "dup<S2SV_blank>shortcut<S2SV_blank>%p<S2SV_blank>-><S2SV_blank>%p\\n" , shortcut , new_s ) ; memcpy ( new_s , shortcut , ( sizeof ( struct assoc_array_shortcut ) + keylen * sizeof ( unsigned long ) ) ) ; new_s -> back_pointer = new_parent ; new_s -> parent_slot = shortcut -> parent_slot ; * new_ptr_pp = new_parent = assoc_array_shortcut_to_ptr ( new_s ) ; new_ptr_pp = & new_s -> next_node ; cursor = shortcut -> next_node ; } node = assoc_array_ptr_to_node ( cursor ) ; new_n = kzalloc ( sizeof ( struct assoc_array_node ) , GFP_KERNEL ) ; if ( ! new_n ) goto enomem ; pr_devel ( "dup<S2SV_blank>node<S2SV_blank>%p<S2SV_blank>-><S2SV_blank>%p\\n" , node , new_n ) ; new_n -> back_pointer = new_parent ; new_n -> parent_slot = node -> parent_slot ; * new_ptr_pp = new_parent = assoc_array_node_to_ptr ( new_n ) ; new_ptr_pp = NULL ; slot = 0 ; continue_node : for ( ; slot < ASSOC_ARRAY_FAN_OUT ; slot ++ ) { ptr = node -> slots [ slot ] ; if ( ! ptr ) continue ; if ( assoc_array_ptr_is_leaf ( ptr ) ) { if ( iterator ( assoc_array_ptr_to_leaf ( ptr ) , iterator_data ) ) new_n -> slots [ slot ] = ptr ; continue ; } new_ptr_pp = & new_n -> slots [ slot ] ; cursor = ptr ; goto descend ; } pr_devel ( "--<S2SV_blank>compress<S2SV_blank>node<S2SV_blank>%p<S2SV_blank>--\\n" , new_n ) ; new_n -> nr_leaves_on_branch = 0 ; nr_free = 0 ; for ( slot = 0 ; slot < ASSOC_ARRAY_FAN_OUT ; slot ++ ) { ptr = new_n -> slots [ slot ] ; if ( ! ptr ) nr_free ++ ; else if ( assoc_array_ptr_is_leaf ( ptr ) ) new_n -> nr_leaves_on_branch ++ ; } pr_devel ( "free=%d,<S2SV_blank>leaves=%lu\\n" , nr_free , new_n -> nr_leaves_on_branch ) ; next_slot = 0 ; for ( slot = 0 ; slot < ASSOC_ARRAY_FAN_OUT ; slot ++ ) { struct assoc_array_shortcut * s ; struct assoc_array_node * child ; ptr = new_n -> slots [ slot ] ; if ( ! ptr || assoc_array_ptr_is_leaf ( ptr ) ) continue ; s = NULL ; if ( assoc_array_ptr_is_shortcut ( ptr ) ) { s = assoc_array_ptr_to_shortcut ( ptr ) ; ptr = s -> next_node ; } child = assoc_array_ptr_to_node ( ptr ) ; new_n -> nr_leaves_on_branch += child -> nr_leaves_on_branch ; if ( child -> nr_leaves_on_branch <= nr_free + 1 ) { pr_devel ( "[%d]<S2SV_blank>fold<S2SV_blank>node<S2SV_blank>%lu/%d<S2SV_blank>[nx<S2SV_blank>%d]\\n" , slot , child -> nr_leaves_on_branch , nr_free + 1 , next_slot ) ; BUG_ON ( s ) ; new_n -> slots [ slot ] = NULL ; nr_free ++ ; if ( slot < next_slot ) next_slot = slot ; for ( i = 0 ; i < ASSOC_ARRAY_FAN_OUT ; i ++ ) { struct assoc_array_ptr * p = child -> slots [ i ] ; if ( ! p ) continue ; BUG_ON ( assoc_array_ptr_is_meta ( p ) ) ; while ( new_n -> slots [ next_slot ] ) next_slot ++ ; BUG_ON ( next_slot >= ASSOC_ARRAY_FAN_OUT ) ; new_n -> slots [ next_slot ++ ] = p ; nr_free -- ; } kfree ( child ) ; } else { pr_devel ( "[%d]<S2SV_blank>retain<S2SV_blank>node<S2SV_blank>%lu/%d<S2SV_blank>[nx<S2SV_blank>%d]\\n" , slot , child -> nr_leaves_on_branch , nr_free + 1 , next_slot ) ; } } pr_devel ( "after:<S2SV_blank>%lu\\n" , new_n -> nr_leaves_on_branch ) ; nr_leaves_on_tree = new_n -> nr_leaves_on_branch ; if ( nr_free == ASSOC_ARRAY_FAN_OUT - 1 ) { for ( slot = 0 ; slot < ASSOC_ARRAY_FAN_OUT ; slot ++ ) if ( ( ptr = new_n -> slots [ slot ] ) ) break ; if ( assoc_array_ptr_is_meta ( ptr ) && assoc_array_ptr_is_shortcut ( ptr ) ) { pr_devel ( "excise<S2SV_blank>node<S2SV_blank>%p<S2SV_blank>with<S2SV_blank>1<S2SV_blank>shortcut\\n" , new_n ) ; new_s = assoc_array_ptr_to_shortcut ( ptr ) ; new_parent = new_n -> back_pointer ; slot = new_n -> parent_slot ; kfree ( new_n ) ; if ( ! new_parent ) { new_s -> back_pointer = NULL ; new_s -> parent_slot = 0 ; new_root = ptr ; goto gc_complete ; } if ( assoc_array_ptr_is_shortcut ( new_parent ) ) { struct assoc_array_shortcut * s = assoc_array_ptr_to_shortcut ( new_parent ) ; pr_devel ( "excise<S2SV_blank>preceding<S2SV_blank>shortcut\\n" ) ; new_parent = new_s -> back_pointer = s -> back_pointer ; slot = new_s -> parent_slot = s -> parent_slot ; kfree ( s ) ; if ( ! new_parent ) { new_s -> back_pointer = NULL ; new_s -> parent_slot = 0 ; new_root = ptr ; goto gc_complete ; } } new_s -> back_pointer = new_parent ; new_s -> parent_slot = slot ; new_n = assoc_array_ptr_to_node ( new_parent ) ; new_n -> slots [ slot ] = ptr ; goto ascend_old_tree ; } } ptr = new_n -> back_pointer ; if ( ! ptr ) goto gc_complete ; if ( assoc_array_ptr_is_shortcut ( ptr ) ) { new_s = assoc_array_ptr_to_shortcut ( ptr ) ; new_parent = new_s -> back_pointer ; slot = new_s -> parent_slot ; if ( new_n -> nr_leaves_on_branch <= ASSOC_ARRAY_FAN_OUT ) { struct assoc_array_node * n ; pr_devel ( "excise<S2SV_blank>shortcut\\n" ) ; new_n -> back_pointer = new_parent ; new_n -> parent_slot = slot ; kfree ( new_s ) ; if ( ! new_parent ) { new_root = assoc_array_node_to_ptr ( new_n ) ; goto gc_complete ; } n = assoc_array_ptr_to_node ( new_parent ) ; n -> slots [ slot ] = assoc_array_node_to_ptr ( new_n ) ; } } else { new_parent = ptr ; } new_n = assoc_array_ptr_to_node ( new_parent ) ; ascend_old_tree : ptr = node -> back_pointer ; if ( assoc_array_ptr_is_shortcut ( ptr ) ) { shortcut = assoc_array_ptr_to_shortcut ( ptr ) ; slot = shortcut -> parent_slot ; cursor = shortcut -> back_pointer ; <S2SV_StartBug> } else { <S2SV_EndBug> slot = node -> parent_slot ; cursor = ptr ; } <S2SV_StartBug> BUG_ON ( ! ptr ) ; <S2SV_EndBug> node = assoc_array_ptr_to_node ( cursor ) ; slot ++ ; goto continue_node ; gc_complete : edit -> set [ 0 ] . to = new_root ; assoc_array_apply_edit ( edit ) ; array -> nr_leaves_on_tree = nr_leaves_on_tree ; return 0 ; enomem : pr_devel ( "enomem\\n" ) ; assoc_array_destroy_subtree ( new_root , edit -> ops ) ; kfree ( edit ) ; return - ENOMEM ; }
static int userfaultfd_register ( struct userfaultfd_ctx * ctx , unsigned long arg ) { struct mm_struct * mm = ctx -> mm ; struct vm_area_struct * vma , * prev , * cur ; int ret ; struct uffdio_register uffdio_register ; struct uffdio_register __user * user_uffdio_register ; unsigned long vm_flags , new_flags ; bool found ; bool basic_ioctls ; unsigned long start , end , vma_end ; user_uffdio_register = ( struct uffdio_register __user * ) arg ; ret = - EFAULT ; if ( copy_from_user ( & uffdio_register , user_uffdio_register , sizeof ( uffdio_register ) - sizeof ( __u64 ) ) ) goto out ; ret = - EINVAL ; if ( ! uffdio_register . mode ) goto out ; if ( uffdio_register . mode & ~ ( UFFDIO_REGISTER_MODE_MISSING | UFFDIO_REGISTER_MODE_WP ) ) goto out ; vm_flags = 0 ; if ( uffdio_register . mode & UFFDIO_REGISTER_MODE_MISSING ) vm_flags |= VM_UFFD_MISSING ; if ( uffdio_register . mode & UFFDIO_REGISTER_MODE_WP ) { vm_flags |= VM_UFFD_WP ; ret = - EINVAL ; goto out ; } ret = validate_range ( mm , uffdio_register . range . start , uffdio_register . range . len ) ; if ( ret ) goto out ; start = uffdio_register . range . start ; end = start + uffdio_register . range . len ; ret = - ENOMEM ; if ( ! mmget_not_zero ( mm ) ) goto out ; <S2SV_StartBug> down_write ( & mm -> mmap_sem ) ; <S2SV_EndBug> vma = find_vma_prev ( mm , start , & prev ) ; if ( ! vma ) goto out_unlock ; ret = - EINVAL ; if ( vma -> vm_start >= end ) goto out_unlock ; if ( is_vm_hugetlb_page ( vma ) ) { unsigned long vma_hpagesize = vma_kernel_pagesize ( vma ) ; if ( start & ( vma_hpagesize - 1 ) ) goto out_unlock ; } found = false ; basic_ioctls = false ; for ( cur = vma ; cur && cur -> vm_start < end ; cur = cur -> vm_next ) { cond_resched ( ) ; BUG_ON ( ! ! cur -> vm_userfaultfd_ctx . ctx ^ ! ! ( cur -> vm_flags & ( VM_UFFD_MISSING | VM_UFFD_WP ) ) ) ; ret = - EINVAL ; if ( ! vma_can_userfault ( cur ) ) goto out_unlock ; ret = - EPERM ; if ( unlikely ( ! ( cur -> vm_flags & VM_MAYWRITE ) ) ) goto out_unlock ; if ( is_vm_hugetlb_page ( cur ) && end <= cur -> vm_end && end > cur -> vm_start ) { unsigned long vma_hpagesize = vma_kernel_pagesize ( cur ) ; ret = - EINVAL ; if ( end & ( vma_hpagesize - 1 ) ) goto out_unlock ; } ret = - EBUSY ; if ( cur -> vm_userfaultfd_ctx . ctx && cur -> vm_userfaultfd_ctx . ctx != ctx ) goto out_unlock ; if ( is_vm_hugetlb_page ( cur ) ) basic_ioctls = true ; found = true ; } BUG_ON ( ! found ) ; if ( vma -> vm_start < start ) prev = vma ; ret = 0 ; do { cond_resched ( ) ; BUG_ON ( ! vma_can_userfault ( vma ) ) ; BUG_ON ( vma -> vm_userfaultfd_ctx . ctx && vma -> vm_userfaultfd_ctx . ctx != ctx ) ; WARN_ON ( ! ( vma -> vm_flags & VM_MAYWRITE ) ) ; if ( vma -> vm_userfaultfd_ctx . ctx == ctx && ( vma -> vm_flags & vm_flags ) == vm_flags ) goto skip ; if ( vma -> vm_start > start ) start = vma -> vm_start ; vma_end = min ( end , vma -> vm_end ) ; new_flags = ( vma -> vm_flags & ~ vm_flags ) | vm_flags ; prev = vma_merge ( mm , prev , start , vma_end , new_flags , vma -> anon_vma , vma -> vm_file , vma -> vm_pgoff , vma_policy ( vma ) , ( ( struct vm_userfaultfd_ctx ) { ctx } ) ) ; if ( prev ) { vma = prev ; goto next ; } if ( vma -> vm_start < start ) { ret = split_vma ( mm , vma , start , 1 ) ; if ( ret ) break ; } if ( vma -> vm_end > end ) { ret = split_vma ( mm , vma , end , 0 ) ; if ( ret ) break ; } next : vma -> vm_flags = new_flags ; vma -> vm_userfaultfd_ctx . ctx = ctx ; skip : prev = vma ; start = vma -> vm_end ; vma = vma -> vm_next ; } while ( vma && vma -> vm_start < end ) ; out_unlock : up_write ( & mm -> mmap_sem ) ; mmput ( mm ) ; if ( ! ret ) { if ( put_user ( basic_ioctls ? UFFD_API_RANGE_IOCTLS_BASIC : UFFD_API_RANGE_IOCTLS , & user_uffdio_register -> ioctls ) ) ret = - EFAULT ; } out : return ret ; }
static bool assoc_array_insert_into_terminal_node ( struct assoc_array_edit * edit , const struct assoc_array_ops * ops , const void * index_key , struct assoc_array_walk_result * result ) { struct assoc_array_shortcut * shortcut , * new_s0 ; struct assoc_array_node * node , * new_n0 , * new_n1 , * side ; struct assoc_array_ptr * ptr ; unsigned long dissimilarity , base_seg , blank ; size_t keylen ; bool have_meta ; int level , diff ; int slot , next_slot , free_slot , i , j ; node = result -> terminal_node . node ; level = result -> terminal_node . level ; edit -> segment_cache [ ASSOC_ARRAY_FAN_OUT ] = result -> terminal_node . slot ; pr_devel ( "-->%s()\\n" , __func__ ) ; free_slot = - 1 ; for ( i = 0 ; i < ASSOC_ARRAY_FAN_OUT ; i ++ ) { ptr = node -> slots [ i ] ; if ( ! ptr ) { free_slot = i ; continue ; } if ( assoc_array_ptr_is_leaf ( ptr ) && ops -> compare_object ( assoc_array_ptr_to_leaf ( ptr ) , index_key ) ) { pr_devel ( "replace<S2SV_blank>in<S2SV_blank>slot<S2SV_blank>%d\\n" , i ) ; edit -> leaf_p = & node -> slots [ i ] ; edit -> dead_leaf = node -> slots [ i ] ; pr_devel ( "<--%s()<S2SV_blank>=<S2SV_blank>ok<S2SV_blank>[replace]\\n" , __func__ ) ; return true ; } } if ( free_slot >= 0 ) { pr_devel ( "insert<S2SV_blank>in<S2SV_blank>free<S2SV_blank>slot<S2SV_blank>%d\\n" , free_slot ) ; edit -> leaf_p = & node -> slots [ free_slot ] ; edit -> adjust_count_on = node ; pr_devel ( "<--%s()<S2SV_blank>=<S2SV_blank>ok<S2SV_blank>[insert]\\n" , __func__ ) ; return true ; } new_n0 = kzalloc ( sizeof ( struct assoc_array_node ) , GFP_KERNEL ) ; if ( ! new_n0 ) return false ; edit -> new_meta [ 0 ] = assoc_array_node_to_ptr ( new_n0 ) ; new_n1 = kzalloc ( sizeof ( struct assoc_array_node ) , GFP_KERNEL ) ; if ( ! new_n1 ) return false ; edit -> new_meta [ 1 ] = assoc_array_node_to_ptr ( new_n1 ) ; pr_devel ( "no<S2SV_blank>spare<S2SV_blank>slots\\n" ) ; have_meta = false ; for ( i = 0 ; i < ASSOC_ARRAY_FAN_OUT ; i ++ ) { ptr = node -> slots [ i ] ; if ( assoc_array_ptr_is_meta ( ptr ) ) { edit -> segment_cache [ i ] = 0xff ; have_meta = true ; continue ; } base_seg = ops -> get_object_key_chunk ( assoc_array_ptr_to_leaf ( ptr ) , level ) ; base_seg >>= level & ASSOC_ARRAY_KEY_CHUNK_MASK ; edit -> segment_cache [ i ] = base_seg & ASSOC_ARRAY_FAN_MASK ; } if ( have_meta ) { pr_devel ( "have<S2SV_blank>meta\\n" ) ; goto split_node ; } dissimilarity = 0 ; base_seg = edit -> segment_cache [ 0 ] ; for ( i = 1 ; i < ASSOC_ARRAY_FAN_OUT ; i ++ ) dissimilarity |= edit -> segment_cache [ i ] ^ base_seg ; pr_devel ( "only<S2SV_blank>leaves;<S2SV_blank>dissimilarity=%lx\\n" , dissimilarity ) ; if ( ( dissimilarity & ASSOC_ARRAY_FAN_MASK ) == 0 ) { if ( ( edit -> segment_cache [ ASSOC_ARRAY_FAN_OUT ] ^ base_seg ) == 0 ) goto all_leaves_cluster_together ; <S2SV_StartBug> goto present_leaves_cluster_but_not_new_leaf ; <S2SV_EndBug> } split_node : pr_devel ( "split<S2SV_blank>node\\n" ) ; edit -> set [ 0 ] . to = assoc_array_node_to_ptr ( new_n0 ) ; new_n0 -> back_pointer = node -> back_pointer ; new_n0 -> parent_slot = node -> parent_slot ; new_n1 -> back_pointer = assoc_array_node_to_ptr ( new_n0 ) ; new_n1 -> parent_slot = - 1 ; do_split_node : pr_devel ( "do_split_node\\n" ) ; new_n0 -> nr_leaves_on_branch = node -> nr_leaves_on_branch ; new_n1 -> nr_leaves_on_branch = 0 ; for ( i = 0 ; i < ASSOC_ARRAY_FAN_OUT ; i ++ ) { slot = edit -> segment_cache [ i ] ; if ( slot != 0xff ) for ( j = i + 1 ; j < ASSOC_ARRAY_FAN_OUT + 1 ; j ++ ) if ( edit -> segment_cache [ j ] == slot ) goto found_slot_for_multiple_occupancy ; } found_slot_for_multiple_occupancy : pr_devel ( "same<S2SV_blank>slot:<S2SV_blank>%x<S2SV_blank>%x<S2SV_blank>[%02x]\\n" , i , j , slot ) ; BUG_ON ( i >= ASSOC_ARRAY_FAN_OUT ) ; BUG_ON ( j >= ASSOC_ARRAY_FAN_OUT + 1 ) ; BUG_ON ( slot >= ASSOC_ARRAY_FAN_OUT ) ; new_n1 -> parent_slot = slot ; for ( i = 0 ; i < ASSOC_ARRAY_FAN_OUT ; i ++ ) if ( assoc_array_ptr_is_meta ( node -> slots [ i ] ) ) new_n0 -> slots [ i ] = node -> slots [ i ] ; else new_n0 -> slots [ i ] = NULL ; BUG_ON ( new_n0 -> slots [ slot ] != NULL ) ; new_n0 -> slots [ slot ] = assoc_array_node_to_ptr ( new_n1 ) ; free_slot = - 1 ; next_slot = 0 ; for ( i = 0 ; i < ASSOC_ARRAY_FAN_OUT ; i ++ ) { if ( assoc_array_ptr_is_meta ( node -> slots [ i ] ) ) continue ; if ( edit -> segment_cache [ i ] == slot ) { new_n1 -> slots [ next_slot ++ ] = node -> slots [ i ] ; new_n1 -> nr_leaves_on_branch ++ ; } else { do { free_slot ++ ; } while ( new_n0 -> slots [ free_slot ] != NULL ) ; new_n0 -> slots [ free_slot ] = node -> slots [ i ] ; } } pr_devel ( "filtered:<S2SV_blank>f=%x<S2SV_blank>n=%x\\n" , free_slot , next_slot ) ; if ( edit -> segment_cache [ ASSOC_ARRAY_FAN_OUT ] != slot ) { do { free_slot ++ ; } while ( new_n0 -> slots [ free_slot ] != NULL ) ; edit -> leaf_p = & new_n0 -> slots [ free_slot ] ; edit -> adjust_count_on = new_n0 ; } else { edit -> leaf_p = & new_n1 -> slots [ next_slot ++ ] ; edit -> adjust_count_on = new_n1 ; } BUG_ON ( next_slot <= 1 ) ; edit -> set_backpointers_to = assoc_array_node_to_ptr ( new_n0 ) ; for ( i = 0 ; i < ASSOC_ARRAY_FAN_OUT ; i ++ ) { if ( edit -> segment_cache [ i ] == 0xff ) { ptr = node -> slots [ i ] ; BUG_ON ( assoc_array_ptr_is_leaf ( ptr ) ) ; if ( assoc_array_ptr_is_node ( ptr ) ) { side = assoc_array_ptr_to_node ( ptr ) ; edit -> set_backpointers [ i ] = & side -> back_pointer ; } else { shortcut = assoc_array_ptr_to_shortcut ( ptr ) ; edit -> set_backpointers [ i ] = & shortcut -> back_pointer ; } } } ptr = node -> back_pointer ; if ( ! ptr ) edit -> set [ 0 ] . ptr = & edit -> array -> root ; else if ( assoc_array_ptr_is_node ( ptr ) ) edit -> set [ 0 ] . ptr = & assoc_array_ptr_to_node ( ptr ) -> slots [ node -> parent_slot ] ; else edit -> set [ 0 ] . ptr = & assoc_array_ptr_to_shortcut ( ptr ) -> next_node ; edit -> excised_meta [ 0 ] = assoc_array_node_to_ptr ( node ) ; pr_devel ( "<--%s()<S2SV_blank>=<S2SV_blank>ok<S2SV_blank>[split<S2SV_blank>node]\\n" , __func__ ) ; return true ; <S2SV_StartBug> present_leaves_cluster_but_not_new_leaf : <S2SV_EndBug> pr_devel ( "present<S2SV_blank>leaves<S2SV_blank>cluster<S2SV_blank>but<S2SV_blank>not<S2SV_blank>new<S2SV_blank>leaf\\n" ) ; new_n0 -> back_pointer = node -> back_pointer ; new_n0 -> parent_slot = node -> parent_slot ; new_n0 -> nr_leaves_on_branch = node -> nr_leaves_on_branch ; new_n1 -> back_pointer = assoc_array_node_to_ptr ( new_n0 ) ; new_n1 -> parent_slot = edit -> segment_cache [ 0 ] ; new_n1 -> nr_leaves_on_branch = node -> nr_leaves_on_branch ; edit -> adjust_count_on = new_n0 ; for ( i = 0 ; i < ASSOC_ARRAY_FAN_OUT ; i ++ ) new_n1 -> slots [ i ] = node -> slots [ i ] ; new_n0 -> slots [ edit -> segment_cache [ 0 ] ] = assoc_array_node_to_ptr ( new_n0 ) ; edit -> leaf_p = & new_n0 -> slots [ edit -> segment_cache [ ASSOC_ARRAY_FAN_OUT ] ] ; edit -> set [ 0 ] . ptr = & assoc_array_ptr_to_node ( node -> back_pointer ) -> slots [ node -> parent_slot ] ; edit -> set [ 0 ] . to = assoc_array_node_to_ptr ( new_n0 ) ; edit -> excised_meta [ 0 ] = assoc_array_node_to_ptr ( node ) ; pr_devel ( "<--%s()<S2SV_blank>=<S2SV_blank>ok<S2SV_blank>[insert<S2SV_blank>node<S2SV_blank>before]\\n" , __func__ ) ; return true ; all_leaves_cluster_together : pr_devel ( "all<S2SV_blank>leaves<S2SV_blank>cluster<S2SV_blank>together\\n" ) ; diff = INT_MAX ; for ( i = 0 ; i < ASSOC_ARRAY_FAN_OUT ; i ++ ) { int x = ops -> diff_objects ( assoc_array_ptr_to_leaf ( node -> slots [ i ] ) , index_key ) ; if ( x < diff ) { BUG_ON ( x < 0 ) ; diff = x ; } } BUG_ON ( diff == INT_MAX ) ; BUG_ON ( diff < level + ASSOC_ARRAY_LEVEL_STEP ) ; keylen = round_up ( diff , ASSOC_ARRAY_KEY_CHUNK_SIZE ) ; keylen >>= ASSOC_ARRAY_KEY_CHUNK_SHIFT ; new_s0 = kzalloc ( sizeof ( struct assoc_array_shortcut ) + keylen * sizeof ( unsigned long ) , GFP_KERNEL ) ; if ( ! new_s0 ) return false ; edit -> new_meta [ 2 ] = assoc_array_shortcut_to_ptr ( new_s0 ) ; edit -> set [ 0 ] . to = assoc_array_shortcut_to_ptr ( new_s0 ) ; new_s0 -> back_pointer = node -> back_pointer ; new_s0 -> parent_slot = node -> parent_slot ; new_s0 -> next_node = assoc_array_node_to_ptr ( new_n0 ) ; new_n0 -> back_pointer = assoc_array_shortcut_to_ptr ( new_s0 ) ; new_n0 -> parent_slot = 0 ; new_n1 -> back_pointer = assoc_array_node_to_ptr ( new_n0 ) ; new_n1 -> parent_slot = - 1 ; new_s0 -> skip_to_level = level = diff & ~ ASSOC_ARRAY_LEVEL_STEP_MASK ; pr_devel ( "skip_to_level<S2SV_blank>=<S2SV_blank>%d<S2SV_blank>[diff<S2SV_blank>%d]\\n" , level , diff ) ; BUG_ON ( level <= 0 ) ; for ( i = 0 ; i < keylen ; i ++ ) new_s0 -> index_key [ i ] = ops -> get_key_chunk ( index_key , i * ASSOC_ARRAY_KEY_CHUNK_SIZE ) ; blank = ULONG_MAX << ( level & ASSOC_ARRAY_KEY_CHUNK_MASK ) ; pr_devel ( "blank<S2SV_blank>off<S2SV_blank>[%zu]<S2SV_blank>%d:<S2SV_blank>%lx\\n" , keylen - 1 , level , blank ) ; new_s0 -> index_key [ keylen - 1 ] &= ~ blank ; for ( i = 0 ; i < ASSOC_ARRAY_FAN_OUT ; i ++ ) { ptr = node -> slots [ i ] ; base_seg = ops -> get_object_key_chunk ( assoc_array_ptr_to_leaf ( ptr ) , level ) ; base_seg >>= level & ASSOC_ARRAY_KEY_CHUNK_MASK ; edit -> segment_cache [ i ] = base_seg & ASSOC_ARRAY_FAN_MASK ; } base_seg = ops -> get_key_chunk ( index_key , level ) ; base_seg >>= level & ASSOC_ARRAY_KEY_CHUNK_MASK ; edit -> segment_cache [ ASSOC_ARRAY_FAN_OUT ] = base_seg & ASSOC_ARRAY_FAN_MASK ; goto do_split_node ; }
static int skcipher_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t ignored , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct skcipher_ctx * ctx = ask -> private ; unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ; struct skcipher_sg_list * sgl ; struct scatterlist * sg ; unsigned long iovlen ; struct iovec * iov ; int err = - EAGAIN ; int used ; long copied = 0 ; <S2SV_StartBug> lock_sock ( sk ) ; <S2SV_EndBug> for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ; iovlen > 0 ; iovlen -- , iov ++ ) { unsigned long seglen = iov -> iov_len ; char __user * from = iov -> iov_base ; while ( seglen ) { sgl = list_first_entry ( & ctx -> tsgl , struct skcipher_sg_list , list ) ; sg = sgl -> sg ; while ( ! sg -> length ) sg ++ ; used = ctx -> used ; if ( ! used ) { err = skcipher_wait_for_data ( sk , flags ) ; if ( err ) goto unlock ; } used = min_t ( unsigned long , used , seglen ) ; used = af_alg_make_sg ( & ctx -> rsgl , from , used , 1 ) ; err = used ; if ( err < 0 ) goto unlock ; if ( ctx -> more || used < ctx -> used ) used -= used % bs ; err = - EINVAL ; if ( ! used ) goto free ; ablkcipher_request_set_crypt ( & ctx -> req , sg , ctx -> rsgl . sg , used , ctx -> iv ) ; err = af_alg_wait_for_completion ( ctx -> enc ? crypto_ablkcipher_encrypt ( & ctx -> req ) : crypto_ablkcipher_decrypt ( & ctx -> req ) , & ctx -> completion ) ; free : af_alg_free_sg ( & ctx -> rsgl ) ; if ( err ) goto unlock ; copied += used ; from += used ; seglen -= used ; skcipher_pull_sgl ( sk , used ) ; } } err = 0 ; unlock : skcipher_wmem_wakeup ( sk ) ; release_sock ( sk ) ; return copied ? : err ; }
int propagate_mnt ( struct mount * dest_mnt , struct dentry * dest_dentry , struct mount * source_mnt , struct list_head * tree_list ) { <S2SV_StartBug> struct mount * m , * child ; <S2SV_EndBug> int ret = 0 ; struct mount * prev_dest_mnt = dest_mnt ; struct mount * prev_src_mnt = source_mnt ; LIST_HEAD ( tmp_list ) ; LIST_HEAD ( umount_list ) ; for ( m = propagation_next ( dest_mnt , dest_mnt ) ; m ; m = propagation_next ( m , dest_mnt ) ) { int type ; struct mount * source ; if ( IS_MNT_NEW ( m ) ) continue ; <S2SV_StartBug> source = get_source ( m , prev_dest_mnt , prev_src_mnt , & type ) ; <S2SV_EndBug> child = copy_tree ( source , source -> mnt . mnt_root , type ) ; if ( IS_ERR ( child ) ) { ret = PTR_ERR ( child ) ; list_splice ( tree_list , tmp_list . prev ) ; goto out ; } if ( is_subdir ( dest_dentry , m -> mnt . mnt_root ) ) { mnt_set_mountpoint ( m , dest_dentry , child ) ; list_add_tail ( & child -> mnt_hash , tree_list ) ; } else { list_add_tail ( & child -> mnt_hash , & tmp_list ) ; } prev_dest_mnt = m ; prev_src_mnt = child ; } out : br_write_lock ( & vfsmount_lock ) ; while ( ! list_empty ( & tmp_list ) ) { child = list_first_entry ( & tmp_list , struct mount , mnt_hash ) ; umount_tree ( child , 0 , & umount_list ) ; } br_write_unlock ( & vfsmount_lock ) ; release_mounts ( & umount_list ) ; return ret ; }
PHP_FUNCTION ( msgfmt_format_message ) { zval * args ; UChar * spattern = NULL ; int spattern_len = 0 ; char * pattern = NULL ; int pattern_len = 0 ; const char * slocale = NULL ; int slocale_len = 0 ; MessageFormatter_object mf = { 0 } ; MessageFormatter_object * mfo = & mf ; if ( zend_parse_method_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , getThis ( ) , "ssa" , & slocale , & slocale_len , & pattern , & pattern_len , & args ) == FAILURE ) { intl_error_set ( NULL , U_ILLEGAL_ARGUMENT_ERROR , "msgfmt_format_message:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>parse<S2SV_blank>input<S2SV_blank>params" , 0 TSRMLS_CC ) ; RETURN_FALSE ; <S2SV_StartBug> } <S2SV_EndBug> msgformat_data_init ( & mfo -> mf_data TSRMLS_CC ) ; if ( pattern && pattern_len ) { intl_convert_utf8_to_utf16 ( & spattern , & spattern_len , pattern , pattern_len , & INTL_DATA_ERROR_CODE ( mfo ) ) ; if ( U_FAILURE ( INTL_DATA_ERROR_CODE ( ( mfo ) ) ) ) { intl_error_set ( NULL , U_ILLEGAL_ARGUMENT_ERROR , "msgfmt_format_message:<S2SV_blank>error<S2SV_blank>converting<S2SV_blank>pattern<S2SV_blank>to<S2SV_blank>UTF-16" , 0 TSRMLS_CC ) ; RETURN_FALSE ; } } else { spattern_len = 0 ; spattern = NULL ; } if ( slocale_len == 0 ) { slocale = intl_locale_get_default ( TSRMLS_C ) ; } # ifdef MSG_FORMAT_QUOTE_APOS if ( msgformat_fix_quotes ( & spattern , & spattern_len , & INTL_DATA_ERROR_CODE ( mfo ) ) != SUCCESS ) { intl_error_set ( NULL , U_INVALID_FORMAT_ERROR , "msgfmt_format_message:<S2SV_blank>error<S2SV_blank>converting<S2SV_blank>pattern<S2SV_blank>to<S2SV_blank>quote-friendly<S2SV_blank>format" , 0 TSRMLS_CC ) ; RETURN_FALSE ; } # endif MSG_FORMAT_OBJECT ( mfo ) = umsg_open ( spattern , spattern_len , slocale , NULL , & INTL_DATA_ERROR_CODE ( mfo ) ) ; if ( spattern && spattern_len ) { efree ( spattern ) ; } INTL_METHOD_CHECK_STATUS ( mfo , "Creating<S2SV_blank>message<S2SV_blank>formatter<S2SV_blank>failed" ) ; msgfmt_do_format ( mfo , args , return_value TSRMLS_CC ) ; msgformat_data_free ( & mfo -> mf_data TSRMLS_CC ) ; }
static void WritePixels ( struct ngiflib_img * i , struct ngiflib_decode_context * context , const u8 * pixels , u16 n ) { u16 tocopy ; struct ngiflib_gif * p = i -> parent ; while ( n > 0 ) { tocopy = ( context -> Xtogo < n ) ? context -> Xtogo : n ; if ( ! i -> gce . transparent_flag ) { # ifndef NGIFLIB_INDEXED_ONLY if ( p -> mode & NGIFLIB_MODE_INDEXED ) { # endif ngiflib_memcpy ( context -> frbuff_p . p8 , pixels , tocopy ) ; pixels += tocopy ; context -> frbuff_p . p8 += tocopy ; # ifndef NGIFLIB_INDEXED_ONLY } else { int j ; for ( j = ( int ) tocopy ; j > 0 ; j -- ) { * ( context -> frbuff_p . p32 ++ ) = GifIndexToTrueColor ( i -> palette , * pixels ++ ) ; } } # endif } else { int j ; # ifndef NGIFLIB_INDEXED_ONLY if ( p -> mode & NGIFLIB_MODE_INDEXED ) { # endif for ( j = ( int ) tocopy ; j > 0 ; j -- ) { if ( * pixels != i -> gce . transparent_color ) * context -> frbuff_p . p8 = * pixels ; pixels ++ ; context -> frbuff_p . p8 ++ ; } # ifndef NGIFLIB_INDEXED_ONLY } else { for ( j = ( int ) tocopy ; j > 0 ; j -- ) { if ( * pixels != i -> gce . transparent_color ) { * context -> frbuff_p . p32 = GifIndexToTrueColor ( i -> palette , * pixels ) ; } pixels ++ ; context -> frbuff_p . p32 ++ ; } } # endif } context -> Xtogo -= tocopy ; if ( context -> Xtogo == 0 ) { # ifdef NGIFLIB_ENABLE_CALLBACKS if ( p -> line_cb ) p -> line_cb ( p , context -> line_p , context -> curY ) ; # endif context -> Xtogo = i -> width ; switch ( context -> pass ) { case 0 : context -> curY ++ ; break ; case 1 : context -> curY += 8 ; <S2SV_StartBug> if ( context -> curY >= p -> height ) { <S2SV_EndBug> context -> pass ++ ; context -> curY = i -> posY + 4 ; } break ; case 2 : context -> curY += 8 ; <S2SV_StartBug> if ( context -> curY >= p -> height ) { <S2SV_EndBug> context -> pass ++ ; context -> curY = i -> posY + 2 ; } break ; case 3 : context -> curY += 4 ; <S2SV_StartBug> if ( context -> curY >= p -> height ) { <S2SV_EndBug> context -> pass ++ ; context -> curY = i -> posY + 1 ; } break ; case 4 : context -> curY += 2 ; <S2SV_StartBug> break ; <S2SV_EndBug> } # ifndef NGIFLIB_INDEXED_ONLY if ( p -> mode & NGIFLIB_MODE_INDEXED ) { # endif # ifdef NGIFLIB_ENABLE_CALLBACKS context -> line_p . p8 = p -> frbuff . p8 + ( u32 ) context -> curY * p -> width ; context -> frbuff_p . p8 = context -> line_p . p8 + i -> posX ; # else context -> frbuff_p . p8 = p -> frbuff . p8 + ( u32 ) context -> curY * p -> width + i -> posX ; # endif # ifndef NGIFLIB_INDEXED_ONLY } else { # ifdef NGIFLIB_ENABLE_CALLBACKS context -> line_p . p32 = p -> frbuff . p32 + ( u32 ) context -> curY * p -> width ; context -> frbuff_p . p32 = context -> line_p . p32 + i -> posX ; # else context -> frbuff_p . p32 = p -> frbuff . p32 + ( u32 ) context -> curY * p -> width + i -> posX ; # endif } # endif } n -= tocopy ; } }
static void gsm_xsmp_client_disconnect ( GsmXSMPClient * client ) { if ( client -> priv -> watch_id > 0 ) { g_source_remove ( client -> priv -> watch_id ) ; } if ( client -> priv -> conn != NULL ) { SmsCleanUp ( client -> priv -> conn ) ; } if ( client -> priv -> ice_connection != NULL ) { IceSetShutdownNegotiation ( client -> priv -> ice_connection , FALSE ) ; IceCloseConnection ( client -> priv -> ice_connection ) ; } <S2SV_StartBug> if ( client -> priv -> protocol_timeout > 0 ) { <S2SV_EndBug> g_source_remove ( client -> priv -> protocol_timeout ) ; } }
int xfs_attr3_leaf_lookup_int ( struct xfs_buf * bp , struct xfs_da_args * args ) { struct xfs_attr_leafblock * leaf ; struct xfs_attr3_icleaf_hdr ichdr ; struct xfs_attr_leaf_entry * entry ; struct xfs_attr_leaf_entry * entries ; struct xfs_attr_leaf_name_local * name_loc ; struct xfs_attr_leaf_name_remote * name_rmt ; xfs_dahash_t hashval ; int probe ; int span ; trace_xfs_attr_leaf_lookup ( args ) ; leaf = bp -> b_addr ; xfs_attr3_leaf_hdr_from_disk ( & ichdr , leaf ) ; entries = xfs_attr3_leaf_entryp ( leaf ) ; ASSERT ( ichdr . count < XFS_LBSIZE ( args -> dp -> i_mount ) / 8 ) ; hashval = args -> hashval ; probe = span = ichdr . count / 2 ; for ( entry = & entries [ probe ] ; span > 4 ; entry = & entries [ probe ] ) { span /= 2 ; if ( be32_to_cpu ( entry -> hashval ) < hashval ) probe += span ; else if ( be32_to_cpu ( entry -> hashval ) > hashval ) probe -= span ; else break ; } ASSERT ( probe >= 0 && ( ! ichdr . count || probe < ichdr . count ) ) ; ASSERT ( span <= 4 || be32_to_cpu ( entry -> hashval ) == hashval ) ; while ( probe > 0 && be32_to_cpu ( entry -> hashval ) >= hashval ) { entry -- ; probe -- ; } while ( probe < ichdr . count && be32_to_cpu ( entry -> hashval ) < hashval ) { entry ++ ; probe ++ ; } if ( probe == ichdr . count || be32_to_cpu ( entry -> hashval ) != hashval ) { args -> index = probe ; return XFS_ERROR ( ENOATTR ) ; } for ( ; probe < ichdr . count && ( be32_to_cpu ( entry -> hashval ) == hashval ) ; entry ++ , probe ++ ) { if ( ( args -> flags & XFS_ATTR_INCOMPLETE ) != ( entry -> flags & XFS_ATTR_INCOMPLETE ) ) { continue ; } if ( entry -> flags & XFS_ATTR_LOCAL ) { name_loc = xfs_attr3_leaf_name_local ( leaf , probe ) ; if ( name_loc -> namelen != args -> namelen ) continue ; if ( memcmp ( args -> name , name_loc -> nameval , args -> namelen ) != 0 ) continue ; if ( ! xfs_attr_namesp_match ( args -> flags , entry -> flags ) ) continue ; args -> index = probe ; return XFS_ERROR ( EEXIST ) ; } else { name_rmt = xfs_attr3_leaf_name_remote ( leaf , probe ) ; if ( name_rmt -> namelen != args -> namelen ) continue ; if ( memcmp ( args -> name , name_rmt -> name , args -> namelen ) != 0 ) continue ; if ( ! xfs_attr_namesp_match ( args -> flags , entry -> flags ) ) continue ; args -> index = probe ; <S2SV_StartBug> args -> valuelen = be32_to_cpu ( name_rmt -> valuelen ) ; <S2SV_EndBug> args -> rmtblkno = be32_to_cpu ( name_rmt -> valueblk ) ; args -> rmtblkcnt = xfs_attr3_rmt_blocks ( args -> dp -> i_mount , <S2SV_StartBug> args -> valuelen ) ; <S2SV_EndBug> return XFS_ERROR ( EEXIST ) ; } } args -> index = probe ; return XFS_ERROR ( ENOATTR ) ; }
<S2SV_StartBug> void sum_2_variances ( const var * a , const var * b , var * r ) { <S2SV_EndBug> fill_variance ( a -> sum_square_error + b -> sum_square_error , <S2SV_StartBug> a -> sum_error + b -> sum_error , a -> count + b -> count , r ) ; <S2SV_EndBug> }
int cdc_parse_cdc_header ( struct usb_cdc_parsed_header * hdr , struct usb_interface * intf , u8 * buffer , int buflen ) { struct usb_cdc_union_desc * union_header = NULL ; struct usb_cdc_header_desc * header = NULL ; struct usb_cdc_ether_desc * ether = NULL ; struct usb_cdc_mdlm_detail_desc * detail = NULL ; struct usb_cdc_mdlm_desc * desc = NULL ; unsigned int elength ; int cnt = 0 ; memset ( hdr , 0x00 , sizeof ( struct usb_cdc_parsed_header ) ) ; hdr -> phonet_magic_present = false ; while ( buflen > 0 ) { elength = buffer [ 0 ] ; if ( ! elength ) { dev_err ( & intf -> dev , "skipping<S2SV_blank>garbage<S2SV_blank>byte\\n" ) ; elength = 1 ; <S2SV_StartBug> goto next_desc ; <S2SV_EndBug> } if ( buffer [ 1 ] != USB_DT_CS_INTERFACE ) { dev_err ( & intf -> dev , "skipping<S2SV_blank>garbage\\n" ) ; goto next_desc ; } switch ( buffer [ 2 ] ) { case USB_CDC_UNION_TYPE : if ( elength < sizeof ( struct usb_cdc_union_desc ) ) goto next_desc ; if ( union_header ) { dev_err ( & intf -> dev , "More<S2SV_blank>than<S2SV_blank>one<S2SV_blank>union<S2SV_blank>descriptor,<S2SV_blank>skipping<S2SV_blank>...\\n" ) ; goto next_desc ; } union_header = ( struct usb_cdc_union_desc * ) buffer ; break ; case USB_CDC_COUNTRY_TYPE : if ( elength < sizeof ( struct usb_cdc_country_functional_desc ) ) goto next_desc ; hdr -> usb_cdc_country_functional_desc = ( struct usb_cdc_country_functional_desc * ) buffer ; break ; case USB_CDC_HEADER_TYPE : if ( elength != sizeof ( struct usb_cdc_header_desc ) ) goto next_desc ; if ( header ) return - EINVAL ; header = ( struct usb_cdc_header_desc * ) buffer ; break ; case USB_CDC_ACM_TYPE : if ( elength < sizeof ( struct usb_cdc_acm_descriptor ) ) goto next_desc ; hdr -> usb_cdc_acm_descriptor = ( struct usb_cdc_acm_descriptor * ) buffer ; break ; case USB_CDC_ETHERNET_TYPE : if ( elength != sizeof ( struct usb_cdc_ether_desc ) ) goto next_desc ; if ( ether ) return - EINVAL ; ether = ( struct usb_cdc_ether_desc * ) buffer ; break ; case USB_CDC_CALL_MANAGEMENT_TYPE : if ( elength < sizeof ( struct usb_cdc_call_mgmt_descriptor ) ) goto next_desc ; hdr -> usb_cdc_call_mgmt_descriptor = ( struct usb_cdc_call_mgmt_descriptor * ) buffer ; break ; case USB_CDC_DMM_TYPE : if ( elength < sizeof ( struct usb_cdc_dmm_desc ) ) goto next_desc ; hdr -> usb_cdc_dmm_desc = ( struct usb_cdc_dmm_desc * ) buffer ; break ; case USB_CDC_MDLM_TYPE : if ( elength < sizeof ( struct usb_cdc_mdlm_desc * ) ) goto next_desc ; if ( desc ) return - EINVAL ; desc = ( struct usb_cdc_mdlm_desc * ) buffer ; break ; case USB_CDC_MDLM_DETAIL_TYPE : if ( elength < sizeof ( struct usb_cdc_mdlm_detail_desc * ) ) goto next_desc ; if ( detail ) return - EINVAL ; detail = ( struct usb_cdc_mdlm_detail_desc * ) buffer ; break ; case USB_CDC_NCM_TYPE : if ( elength < sizeof ( struct usb_cdc_ncm_desc ) ) goto next_desc ; hdr -> usb_cdc_ncm_desc = ( struct usb_cdc_ncm_desc * ) buffer ; break ; case USB_CDC_MBIM_TYPE : if ( elength < sizeof ( struct usb_cdc_mbim_desc ) ) goto next_desc ; hdr -> usb_cdc_mbim_desc = ( struct usb_cdc_mbim_desc * ) buffer ; break ; case USB_CDC_MBIM_EXTENDED_TYPE : if ( elength < sizeof ( struct usb_cdc_mbim_extended_desc ) ) break ; hdr -> usb_cdc_mbim_extended_desc = ( struct usb_cdc_mbim_extended_desc * ) buffer ; break ; case CDC_PHONET_MAGIC_NUMBER : hdr -> phonet_magic_present = true ; break ; default : dev_dbg ( & intf -> dev , "Ignoring<S2SV_blank>descriptor:<S2SV_blank>type<S2SV_blank>%02x,<S2SV_blank>length<S2SV_blank>%ud\\n" , buffer [ 2 ] , elength ) ; goto next_desc ; } cnt ++ ; next_desc : buflen -= elength ; buffer += elength ; } hdr -> usb_cdc_union_desc = union_header ; hdr -> usb_cdc_header_desc = header ; hdr -> usb_cdc_mdlm_detail_desc = detail ; hdr -> usb_cdc_mdlm_desc = desc ; hdr -> usb_cdc_ether_desc = ether ; return cnt ; }
static long bcm_char_ioctl ( struct file * filp , UINT cmd , ULONG arg ) { struct bcm_tarang_data * pTarang = filp -> private_data ; void __user * argp = ( void __user * ) arg ; struct bcm_mini_adapter * Adapter = pTarang -> Adapter ; INT Status = STATUS_FAILURE ; int timeout = 0 ; struct bcm_ioctl_buffer IoBuffer ; int bytes ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "Parameters<S2SV_blank>Passed<S2SV_blank>to<S2SV_blank>control<S2SV_blank>IOCTL<S2SV_blank>cmd=0x%X<S2SV_blank>arg=0x%lX" , cmd , arg ) ; if ( _IOC_TYPE ( cmd ) != BCM_IOCTL ) return - EFAULT ; if ( _IOC_DIR ( cmd ) & _IOC_READ ) Status = ! access_ok ( VERIFY_WRITE , argp , _IOC_SIZE ( cmd ) ) ; else if ( _IOC_DIR ( cmd ) & _IOC_WRITE ) Status = ! access_ok ( VERIFY_READ , argp , _IOC_SIZE ( cmd ) ) ; else if ( _IOC_NONE == ( _IOC_DIR ( cmd ) & _IOC_NONE ) ) Status = STATUS_SUCCESS ; if ( Status ) return - EFAULT ; if ( Adapter -> device_removed ) return - EFAULT ; if ( FALSE == Adapter -> fw_download_done ) { switch ( cmd ) { case IOCTL_MAC_ADDR_REQ : case IOCTL_LINK_REQ : case IOCTL_CM_REQUEST : case IOCTL_SS_INFO_REQ : case IOCTL_SEND_CONTROL_MESSAGE : case IOCTL_IDLE_REQ : case IOCTL_BCM_GPIO_SET_REQUEST : case IOCTL_BCM_GPIO_STATUS_REQUEST : return - EACCES ; default : break ; } } Status = vendorextnIoctl ( Adapter , cmd , arg ) ; if ( Status != CONTINUE_COMMON_PATH ) return Status ; switch ( cmd ) { case IOCTL_BCM_REGISTER_READ_PRIVATE : { struct bcm_rdm_buffer sRdmBuffer = { 0 } ; PCHAR temp_buff ; UINT Bufflen ; u16 temp_value ; if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) return - EFAULT ; if ( IoBuffer . InputLength > sizeof ( sRdmBuffer ) ) return - EINVAL ; if ( copy_from_user ( & sRdmBuffer , IoBuffer . InputBuffer , IoBuffer . InputLength ) ) return - EFAULT ; if ( IoBuffer . OutputLength > USHRT_MAX || IoBuffer . OutputLength == 0 ) { return - EINVAL ; } Bufflen = IoBuffer . OutputLength ; temp_value = 4 - ( Bufflen % 4 ) ; Bufflen += temp_value % 4 ; temp_buff = kmalloc ( Bufflen , GFP_KERNEL ) ; if ( ! temp_buff ) return - ENOMEM ; bytes = rdmalt ( Adapter , ( UINT ) sRdmBuffer . Register , ( PUINT ) temp_buff , Bufflen ) ; if ( bytes > 0 ) { Status = STATUS_SUCCESS ; if ( copy_to_user ( IoBuffer . OutputBuffer , temp_buff , bytes ) ) { kfree ( temp_buff ) ; return - EFAULT ; } } else { Status = bytes ; } kfree ( temp_buff ) ; break ; } case IOCTL_BCM_REGISTER_WRITE_PRIVATE : { struct bcm_wrm_buffer sWrmBuffer = { 0 } ; UINT uiTempVar = 0 ; if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) return - EFAULT ; if ( IoBuffer . InputLength > sizeof ( sWrmBuffer ) ) return - EINVAL ; if ( copy_from_user ( & sWrmBuffer , IoBuffer . InputBuffer , IoBuffer . InputLength ) ) return - EFAULT ; uiTempVar = sWrmBuffer . Register & EEPROM_REJECT_MASK ; if ( ! ( ( Adapter -> pstargetparams -> m_u32Customize ) & VSG_MODE ) && ( ( uiTempVar == EEPROM_REJECT_REG_1 ) || ( uiTempVar == EEPROM_REJECT_REG_2 ) || ( uiTempVar == EEPROM_REJECT_REG_3 ) || ( uiTempVar == EEPROM_REJECT_REG_4 ) ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "EEPROM<S2SV_blank>Access<S2SV_blank>Denied,<S2SV_blank>not<S2SV_blank>in<S2SV_blank>VSG<S2SV_blank>Mode\\n" ) ; return - EFAULT ; } Status = wrmalt ( Adapter , ( UINT ) sWrmBuffer . Register , ( PUINT ) sWrmBuffer . Data , sizeof ( ULONG ) ) ; if ( Status == STATUS_SUCCESS ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "WRM<S2SV_blank>Done\\n" ) ; } else { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "WRM<S2SV_blank>Failed\\n" ) ; Status = - EFAULT ; } break ; } case IOCTL_BCM_REGISTER_READ : case IOCTL_BCM_EEPROM_REGISTER_READ : { struct bcm_rdm_buffer sRdmBuffer = { 0 } ; PCHAR temp_buff = NULL ; UINT uiTempVar = 0 ; if ( ( Adapter -> IdleMode == TRUE ) || ( Adapter -> bShutStatus == TRUE ) || ( Adapter -> bPreparingForLowPowerMode == TRUE ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "Device<S2SV_blank>in<S2SV_blank>Idle<S2SV_blank>Mode,<S2SV_blank>Blocking<S2SV_blank>Rdms\\n" ) ; return - EACCES ; } if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) return - EFAULT ; if ( IoBuffer . InputLength > sizeof ( sRdmBuffer ) ) return - EINVAL ; if ( copy_from_user ( & sRdmBuffer , IoBuffer . InputBuffer , IoBuffer . InputLength ) ) return - EFAULT ; if ( IoBuffer . OutputLength > USHRT_MAX || IoBuffer . OutputLength == 0 ) { return - EINVAL ; } temp_buff = kmalloc ( IoBuffer . OutputLength , GFP_KERNEL ) ; if ( ! temp_buff ) return STATUS_FAILURE ; if ( ( ( ( ULONG ) sRdmBuffer . Register & 0x0F000000 ) != 0x0F000000 ) || ( ( ULONG ) sRdmBuffer . Register & 0x3 ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "RDM<S2SV_blank>Done<S2SV_blank>On<S2SV_blank>invalid<S2SV_blank>Address<S2SV_blank>:<S2SV_blank>%x<S2SV_blank>Access<S2SV_blank>Denied.\\n" , ( int ) sRdmBuffer . Register ) ; kfree ( temp_buff ) ; return - EINVAL ; } uiTempVar = sRdmBuffer . Register & EEPROM_REJECT_MASK ; bytes = rdmaltWithLock ( Adapter , ( UINT ) sRdmBuffer . Register , ( PUINT ) temp_buff , IoBuffer . OutputLength ) ; if ( bytes > 0 ) { Status = STATUS_SUCCESS ; if ( copy_to_user ( IoBuffer . OutputBuffer , temp_buff , bytes ) ) { kfree ( temp_buff ) ; return - EFAULT ; } } else { Status = bytes ; } kfree ( temp_buff ) ; break ; } case IOCTL_BCM_REGISTER_WRITE : case IOCTL_BCM_EEPROM_REGISTER_WRITE : { struct bcm_wrm_buffer sWrmBuffer = { 0 } ; UINT uiTempVar = 0 ; if ( ( Adapter -> IdleMode == TRUE ) || ( Adapter -> bShutStatus == TRUE ) || ( Adapter -> bPreparingForLowPowerMode == TRUE ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "Device<S2SV_blank>in<S2SV_blank>Idle<S2SV_blank>Mode,<S2SV_blank>Blocking<S2SV_blank>Wrms\\n" ) ; return - EACCES ; } if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) return - EFAULT ; if ( IoBuffer . InputLength > sizeof ( sWrmBuffer ) ) return - EINVAL ; if ( copy_from_user ( & sWrmBuffer , IoBuffer . InputBuffer , IoBuffer . InputLength ) ) return - EFAULT ; if ( ( ( ( ULONG ) sWrmBuffer . Register & 0x0F000000 ) != 0x0F000000 ) || ( ( ULONG ) sWrmBuffer . Register & 0x3 ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "WRM<S2SV_blank>Done<S2SV_blank>On<S2SV_blank>invalid<S2SV_blank>Address<S2SV_blank>:<S2SV_blank>%x<S2SV_blank>Access<S2SV_blank>Denied.\\n" , ( int ) sWrmBuffer . Register ) ; return - EINVAL ; } uiTempVar = sWrmBuffer . Register & EEPROM_REJECT_MASK ; if ( ! ( ( Adapter -> pstargetparams -> m_u32Customize ) & VSG_MODE ) && ( ( uiTempVar == EEPROM_REJECT_REG_1 ) || ( uiTempVar == EEPROM_REJECT_REG_2 ) || ( uiTempVar == EEPROM_REJECT_REG_3 ) || ( uiTempVar == EEPROM_REJECT_REG_4 ) ) && ( cmd == IOCTL_BCM_REGISTER_WRITE ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "EEPROM<S2SV_blank>Access<S2SV_blank>Denied,<S2SV_blank>not<S2SV_blank>in<S2SV_blank>VSG<S2SV_blank>Mode\\n" ) ; return - EFAULT ; } Status = wrmaltWithLock ( Adapter , ( UINT ) sWrmBuffer . Register , ( PUINT ) sWrmBuffer . Data , sWrmBuffer . Length ) ; if ( Status == STATUS_SUCCESS ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , OSAL_DBG , DBG_LVL_ALL , "WRM<S2SV_blank>Done\\n" ) ; } else { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "WRM<S2SV_blank>Failed\\n" ) ; Status = - EFAULT ; } break ; } case IOCTL_BCM_GPIO_SET_REQUEST : { UCHAR ucResetValue [ 4 ] ; UINT value = 0 ; UINT uiBit = 0 ; UINT uiOperation = 0 ; struct bcm_gpio_info gpio_info = { 0 } ; if ( ( Adapter -> IdleMode == TRUE ) || ( Adapter -> bShutStatus == TRUE ) || ( Adapter -> bPreparingForLowPowerMode == TRUE ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "GPIO<S2SV_blank>Can\'t<S2SV_blank>be<S2SV_blank>set/clear<S2SV_blank>in<S2SV_blank>Low<S2SV_blank>power<S2SV_blank>Mode" ) ; return - EACCES ; } if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) return - EFAULT ; if ( IoBuffer . InputLength > sizeof ( gpio_info ) ) return - EINVAL ; if ( copy_from_user ( & gpio_info , IoBuffer . InputBuffer , IoBuffer . InputLength ) ) return - EFAULT ; uiBit = gpio_info . uiGpioNumber ; uiOperation = gpio_info . uiGpioValue ; value = ( 1 << uiBit ) ; if ( IsReqGpioIsLedInNVM ( Adapter , value ) == FALSE ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "Sorry,<S2SV_blank>Requested<S2SV_blank>GPIO<0x%X><S2SV_blank>is<S2SV_blank>not<S2SV_blank>correspond<S2SV_blank>to<S2SV_blank>LED<S2SV_blank>!!!" , value ) ; Status = - EINVAL ; break ; } if ( uiOperation ) { Status = wrmaltWithLock ( Adapter , BCM_GPIO_OUTPUT_SET_REG , ( PUINT ) ( & value ) , sizeof ( UINT ) ) ; if ( Status == STATUS_SUCCESS ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "Set<S2SV_blank>the<S2SV_blank>GPIO<S2SV_blank>bit\\n" ) ; } else { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "Failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>the<S2SV_blank>%dth<S2SV_blank>GPIO\\n" , uiBit ) ; break ; } } else { Status = wrmaltWithLock ( Adapter , BCM_GPIO_OUTPUT_CLR_REG , ( PUINT ) ( & value ) , sizeof ( UINT ) ) ; if ( Status == STATUS_SUCCESS ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "Set<S2SV_blank>the<S2SV_blank>GPIO<S2SV_blank>bit\\n" ) ; } else { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "Failed<S2SV_blank>to<S2SV_blank>clear<S2SV_blank>the<S2SV_blank>%dth<S2SV_blank>GPIO\\n" , uiBit ) ; break ; } } bytes = rdmaltWithLock ( Adapter , ( UINT ) GPIO_MODE_REGISTER , ( PUINT ) ucResetValue , sizeof ( UINT ) ) ; if ( bytes < 0 ) { Status = bytes ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "GPIO_MODE_REGISTER<S2SV_blank>read<S2SV_blank>failed" ) ; break ; } else { Status = STATUS_SUCCESS ; } * ( UINT * ) ucResetValue |= ( 1 << uiBit ) ; Status = wrmaltWithLock ( Adapter , GPIO_MODE_REGISTER , ( PUINT ) ucResetValue , sizeof ( UINT ) ) ; if ( Status == STATUS_SUCCESS ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "Set<S2SV_blank>the<S2SV_blank>GPIO<S2SV_blank>to<S2SV_blank>output<S2SV_blank>Mode\\n" ) ; } else { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "Failed<S2SV_blank>to<S2SV_blank>put<S2SV_blank>GPIO<S2SV_blank>in<S2SV_blank>Output<S2SV_blank>Mode\\n" ) ; break ; } } break ; case BCM_LED_THREAD_STATE_CHANGE_REQ : { struct bcm_user_thread_req threadReq = { 0 } ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "User<S2SV_blank>made<S2SV_blank>LED<S2SV_blank>thread<S2SV_blank>InActive" ) ; if ( ( Adapter -> IdleMode == TRUE ) || ( Adapter -> bShutStatus == TRUE ) || ( Adapter -> bPreparingForLowPowerMode == TRUE ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "GPIO<S2SV_blank>Can\'t<S2SV_blank>be<S2SV_blank>set/clear<S2SV_blank>in<S2SV_blank>Low<S2SV_blank>power<S2SV_blank>Mode" ) ; Status = - EACCES ; break ; } if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) return - EFAULT ; if ( IoBuffer . InputLength > sizeof ( threadReq ) ) return - EINVAL ; if ( copy_from_user ( & threadReq , IoBuffer . InputBuffer , IoBuffer . InputLength ) ) return - EFAULT ; if ( Adapter -> LEDInfo . led_thread_running ) { if ( threadReq . ThreadState == LED_THREAD_ACTIVATION_REQ ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "Activating<S2SV_blank>thread<S2SV_blank>req" ) ; Adapter -> DriverState = LED_THREAD_ACTIVE ; } else { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "DeActivating<S2SV_blank>Thread<S2SV_blank>req....." ) ; Adapter -> DriverState = LED_THREAD_INACTIVE ; } wake_up ( & Adapter -> LEDInfo . notify_led_event ) ; } } break ; case IOCTL_BCM_GPIO_STATUS_REQUEST : { ULONG uiBit = 0 ; UCHAR ucRead [ 4 ] ; struct bcm_gpio_info gpio_info = { 0 } ; if ( ( Adapter -> IdleMode == TRUE ) || ( Adapter -> bShutStatus == TRUE ) || ( Adapter -> bPreparingForLowPowerMode == TRUE ) ) return - EACCES ; if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) return - EFAULT ; if ( IoBuffer . InputLength > sizeof ( gpio_info ) ) return - EINVAL ; if ( copy_from_user ( & gpio_info , IoBuffer . InputBuffer , IoBuffer . InputLength ) ) return - EFAULT ; uiBit = gpio_info . uiGpioNumber ; bytes = rdmaltWithLock ( Adapter , ( UINT ) GPIO_PIN_STATE_REGISTER , ( PUINT ) ucRead , sizeof ( UINT ) ) ; if ( bytes < 0 ) { Status = bytes ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "RDM<S2SV_blank>Failed\\n" ) ; return Status ; } else { Status = STATUS_SUCCESS ; } } break ; case IOCTL_BCM_GPIO_MULTI_REQUEST : { UCHAR ucResetValue [ 4 ] ; struct bcm_gpio_multi_info gpio_multi_info [ MAX_IDX ] ; struct bcm_gpio_multi_info * pgpio_multi_info = ( struct bcm_gpio_multi_info * ) gpio_multi_info ; memset ( pgpio_multi_info , 0 , MAX_IDX * sizeof ( struct bcm_gpio_multi_info ) ) ; if ( ( Adapter -> IdleMode == TRUE ) || ( Adapter -> bShutStatus == TRUE ) || ( Adapter -> bPreparingForLowPowerMode == TRUE ) ) return - EINVAL ; if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) return - EFAULT ; if ( IoBuffer . InputLength > sizeof ( gpio_multi_info ) ) return - EINVAL ; if ( copy_from_user ( & gpio_multi_info , IoBuffer . InputBuffer , IoBuffer . InputLength ) ) return - EFAULT ; if ( IsReqGpioIsLedInNVM ( Adapter , pgpio_multi_info [ WIMAX_IDX ] . uiGPIOMask ) == FALSE ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "Sorry,<S2SV_blank>Requested<S2SV_blank>GPIO<0x%X><S2SV_blank>is<S2SV_blank>not<S2SV_blank>correspond<S2SV_blank>to<S2SV_blank>NVM<S2SV_blank>LED<S2SV_blank>bit<S2SV_blank>map<0x%X>!!!" , pgpio_multi_info [ WIMAX_IDX ] . uiGPIOMask , Adapter -> gpioBitMap ) ; Status = - EINVAL ; break ; } if ( ( pgpio_multi_info [ WIMAX_IDX ] . uiGPIOMask ) & ( pgpio_multi_info [ WIMAX_IDX ] . uiGPIOCommand ) ) { * ( UINT * ) ucResetValue = pgpio_multi_info [ WIMAX_IDX ] . uiGPIOMask & pgpio_multi_info [ WIMAX_IDX ] . uiGPIOCommand & pgpio_multi_info [ WIMAX_IDX ] . uiGPIOValue ; if ( * ( UINT * ) ucResetValue ) Status = wrmaltWithLock ( Adapter , BCM_GPIO_OUTPUT_SET_REG , ( PUINT ) ucResetValue , sizeof ( ULONG ) ) ; if ( Status != STATUS_SUCCESS ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "WRM<S2SV_blank>to<S2SV_blank>BCM_GPIO_OUTPUT_SET_REG<S2SV_blank>Failed." ) ; return Status ; } * ( UINT * ) ucResetValue = ( pgpio_multi_info [ WIMAX_IDX ] . uiGPIOMask & pgpio_multi_info [ WIMAX_IDX ] . uiGPIOCommand & ( ~ ( pgpio_multi_info [ WIMAX_IDX ] . uiGPIOValue ) ) ) ; if ( * ( UINT * ) ucResetValue ) Status = wrmaltWithLock ( Adapter , BCM_GPIO_OUTPUT_CLR_REG , ( PUINT ) ucResetValue , sizeof ( ULONG ) ) ; if ( Status != STATUS_SUCCESS ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "WRM<S2SV_blank>to<S2SV_blank>BCM_GPIO_OUTPUT_CLR_REG<S2SV_blank>Failed." ) ; return Status ; } } if ( pgpio_multi_info [ WIMAX_IDX ] . uiGPIOMask ) { bytes = rdmaltWithLock ( Adapter , ( UINT ) GPIO_PIN_STATE_REGISTER , ( PUINT ) ucResetValue , sizeof ( UINT ) ) ; if ( bytes < 0 ) { Status = bytes ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "RDM<S2SV_blank>to<S2SV_blank>GPIO_PIN_STATE_REGISTER<S2SV_blank>Failed." ) ; return Status ; } else { Status = STATUS_SUCCESS ; } pgpio_multi_info [ WIMAX_IDX ] . uiGPIOValue = ( * ( UINT * ) ucResetValue & pgpio_multi_info [ WIMAX_IDX ] . uiGPIOMask ) ; } Status = copy_to_user ( IoBuffer . OutputBuffer , & gpio_multi_info , IoBuffer . OutputLength ) ; if ( Status ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "Failed<S2SV_blank>while<S2SV_blank>copying<S2SV_blank>Content<S2SV_blank>to<S2SV_blank>IOBufer<S2SV_blank>for<S2SV_blank>user<S2SV_blank>space<S2SV_blank>err:%d" , Status ) ; return - EFAULT ; } } break ; case IOCTL_BCM_GPIO_MODE_REQUEST : { UCHAR ucResetValue [ 4 ] ; struct bcm_gpio_multi_mode gpio_multi_mode [ MAX_IDX ] ; struct bcm_gpio_multi_mode * pgpio_multi_mode = ( struct bcm_gpio_multi_mode * ) gpio_multi_mode ; if ( ( Adapter -> IdleMode == TRUE ) || ( Adapter -> bShutStatus == TRUE ) || ( Adapter -> bPreparingForLowPowerMode == TRUE ) ) return - EINVAL ; if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) return - EFAULT ; if ( IoBuffer . InputLength > sizeof ( gpio_multi_mode ) ) return - EINVAL ; if ( copy_from_user ( & gpio_multi_mode , IoBuffer . InputBuffer , IoBuffer . InputLength ) ) return - EFAULT ; bytes = rdmaltWithLock ( Adapter , ( UINT ) GPIO_MODE_REGISTER , ( PUINT ) ucResetValue , sizeof ( UINT ) ) ; if ( bytes < 0 ) { Status = bytes ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "Read<S2SV_blank>of<S2SV_blank>GPIO_MODE_REGISTER<S2SV_blank>failed" ) ; return Status ; } else { Status = STATUS_SUCCESS ; } if ( IsReqGpioIsLedInNVM ( Adapter , pgpio_multi_mode [ WIMAX_IDX ] . uiGPIOMask ) == FALSE ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "Sorry,<S2SV_blank>Requested<S2SV_blank>GPIO<0x%X><S2SV_blank>is<S2SV_blank>not<S2SV_blank>correspond<S2SV_blank>to<S2SV_blank>NVM<S2SV_blank>LED<S2SV_blank>bit<S2SV_blank>map<0x%X>!!!" , pgpio_multi_mode [ WIMAX_IDX ] . uiGPIOMask , Adapter -> gpioBitMap ) ; Status = - EINVAL ; break ; } if ( pgpio_multi_mode [ WIMAX_IDX ] . uiGPIOMask ) { * ( UINT * ) ucResetValue |= ( pgpio_multi_mode [ WIMAX_IDX ] . uiGPIOMode & pgpio_multi_mode [ WIMAX_IDX ] . uiGPIOMask ) ; * ( UINT * ) ucResetValue &= ~ ( ( ~ pgpio_multi_mode [ WIMAX_IDX ] . uiGPIOMode ) & pgpio_multi_mode [ WIMAX_IDX ] . uiGPIOMask ) ; pgpio_multi_mode [ WIMAX_IDX ] . uiGPIOMode = * ( UINT * ) ucResetValue ; Status = wrmaltWithLock ( Adapter , GPIO_MODE_REGISTER , ( PUINT ) ucResetValue , sizeof ( ULONG ) ) ; if ( Status == STATUS_SUCCESS ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "WRM<S2SV_blank>to<S2SV_blank>GPIO_MODE_REGISTER<S2SV_blank>Done" ) ; } else { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "WRM<S2SV_blank>to<S2SV_blank>GPIO_MODE_REGISTER<S2SV_blank>Failed" ) ; Status = - EFAULT ; break ; } } else { pgpio_multi_mode [ WIMAX_IDX ] . uiGPIOMode = * ( UINT * ) ucResetValue ; } Status = copy_to_user ( IoBuffer . OutputBuffer , & gpio_multi_mode , IoBuffer . OutputLength ) ; if ( Status ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "Failed<S2SV_blank>while<S2SV_blank>copying<S2SV_blank>Content<S2SV_blank>to<S2SV_blank>IOBufer<S2SV_blank>for<S2SV_blank>user<S2SV_blank>space<S2SV_blank>err:%d" , Status ) ; return - EFAULT ; } } break ; case IOCTL_MAC_ADDR_REQ : case IOCTL_LINK_REQ : case IOCTL_CM_REQUEST : case IOCTL_SS_INFO_REQ : case IOCTL_SEND_CONTROL_MESSAGE : case IOCTL_IDLE_REQ : { PVOID pvBuffer = NULL ; if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) return - EFAULT ; if ( IoBuffer . InputLength < sizeof ( struct bcm_link_request ) ) return - EINVAL ; if ( IoBuffer . InputLength > MAX_CNTL_PKT_SIZE ) return - EINVAL ; pvBuffer = memdup_user ( IoBuffer . InputBuffer , IoBuffer . InputLength ) ; if ( IS_ERR ( pvBuffer ) ) return PTR_ERR ( pvBuffer ) ; down ( & Adapter -> LowPowerModeSync ) ; Status = wait_event_interruptible_timeout ( Adapter -> lowpower_mode_wait_queue , ! Adapter -> bPreparingForLowPowerMode , ( 1 * HZ ) ) ; if ( Status == - ERESTARTSYS ) goto cntrlEnd ; if ( Adapter -> bPreparingForLowPowerMode ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "Preparing<S2SV_blank>Idle<S2SV_blank>Mode<S2SV_blank>is<S2SV_blank>still<S2SV_blank>True<S2SV_blank>-<S2SV_blank>Hence<S2SV_blank>Rejecting<S2SV_blank>control<S2SV_blank>message\\n" ) ; Status = STATUS_FAILURE ; goto cntrlEnd ; } Status = CopyBufferToControlPacket ( Adapter , ( PVOID ) pvBuffer ) ; cntrlEnd : up ( & Adapter -> LowPowerModeSync ) ; kfree ( pvBuffer ) ; break ; } case IOCTL_BCM_BUFFER_DOWNLOAD_START : { if ( down_trylock ( & Adapter -> NVMRdmWrmLock ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "IOCTL_BCM_CHIP_RESET<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>as<S2SV_blank>EEPROM<S2SV_blank>Read/Write<S2SV_blank>is<S2SV_blank>in<S2SV_blank>progress\\n" ) ; return - EACCES ; } BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "Starting<S2SV_blank>the<S2SV_blank>firmware<S2SV_blank>download<S2SV_blank>PID<S2SV_blank>=0x%x!!!!\\n" , current -> pid ) ; if ( down_trylock ( & Adapter -> fw_download_sema ) ) return - EBUSY ; Adapter -> bBinDownloaded = FALSE ; Adapter -> fw_download_process_pid = current -> pid ; Adapter -> bCfgDownloaded = FALSE ; Adapter -> fw_download_done = FALSE ; netif_carrier_off ( Adapter -> dev ) ; netif_stop_queue ( Adapter -> dev ) ; Status = reset_card_proc ( Adapter ) ; if ( Status ) { pr_err ( PFX "%s:<S2SV_blank>reset_card_proc<S2SV_blank>Failed!\\n" , Adapter -> dev -> name ) ; up ( & Adapter -> fw_download_sema ) ; up ( & Adapter -> NVMRdmWrmLock ) ; return Status ; } mdelay ( 10 ) ; up ( & Adapter -> NVMRdmWrmLock ) ; return Status ; } case IOCTL_BCM_BUFFER_DOWNLOAD : { struct bcm_firmware_info * psFwInfo = NULL ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "Starting<S2SV_blank>the<S2SV_blank>firmware<S2SV_blank>download<S2SV_blank>PID<S2SV_blank>=0x%x!!!!\\n" , current -> pid ) ; if ( ! down_trylock ( & Adapter -> fw_download_sema ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "Invalid<S2SV_blank>way<S2SV_blank>to<S2SV_blank>download<S2SV_blank>buffer.<S2SV_blank>Use<S2SV_blank>Start<S2SV_blank>and<S2SV_blank>then<S2SV_blank>call<S2SV_blank>this!!!\\n" ) ; up ( & Adapter -> fw_download_sema ) ; Status = - EINVAL ; return Status ; } if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) { up ( & Adapter -> fw_download_sema ) ; return - EFAULT ; } BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "Length<S2SV_blank>for<S2SV_blank>FW<S2SV_blank>DLD<S2SV_blank>is<S2SV_blank>:<S2SV_blank>%lx\\n" , IoBuffer . InputLength ) ; if ( IoBuffer . InputLength > sizeof ( struct bcm_firmware_info ) ) { up ( & Adapter -> fw_download_sema ) ; return - EINVAL ; } psFwInfo = kmalloc ( sizeof ( * psFwInfo ) , GFP_KERNEL ) ; if ( ! psFwInfo ) { up ( & Adapter -> fw_download_sema ) ; return - ENOMEM ; } if ( copy_from_user ( psFwInfo , IoBuffer . InputBuffer , IoBuffer . InputLength ) ) { up ( & Adapter -> fw_download_sema ) ; kfree ( psFwInfo ) ; return - EFAULT ; } if ( ! psFwInfo -> pvMappedFirmwareAddress || ( psFwInfo -> u32FirmwareLength == 0 ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "Something<S2SV_blank>else<S2SV_blank>is<S2SV_blank>wrong<S2SV_blank>%lu\\n" , psFwInfo -> u32FirmwareLength ) ; up ( & Adapter -> fw_download_sema ) ; kfree ( psFwInfo ) ; Status = - EINVAL ; return Status ; } Status = bcm_ioctl_fw_download ( Adapter , psFwInfo ) ; if ( Status != STATUS_SUCCESS ) { if ( psFwInfo -> u32StartingAddress == CONFIG_BEGIN_ADDR ) BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "IOCTL:<S2SV_blank>Configuration<S2SV_blank>File<S2SV_blank>Upload<S2SV_blank>Failed\\n" ) ; else BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "IOCTL:<S2SV_blank>Firmware<S2SV_blank>File<S2SV_blank>Upload<S2SV_blank>Failed\\n" ) ; if ( Adapter -> LEDInfo . led_thread_running & BCM_LED_THREAD_RUNNING_ACTIVELY ) { Adapter -> DriverState = DRIVER_INIT ; Adapter -> LEDInfo . bLedInitDone = FALSE ; wake_up ( & Adapter -> LEDInfo . notify_led_event ) ; } } if ( Status != STATUS_SUCCESS ) up ( & Adapter -> fw_download_sema ) ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , OSAL_DBG , DBG_LVL_ALL , "IOCTL:<S2SV_blank>Firmware<S2SV_blank>File<S2SV_blank>Uploaded\\n" ) ; kfree ( psFwInfo ) ; return Status ; } case IOCTL_BCM_BUFFER_DOWNLOAD_STOP : { if ( ! down_trylock ( & Adapter -> fw_download_sema ) ) { up ( & Adapter -> fw_download_sema ) ; return - EINVAL ; } if ( down_trylock ( & Adapter -> NVMRdmWrmLock ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "FW<S2SV_blank>download<S2SV_blank>blocked<S2SV_blank>as<S2SV_blank>EEPROM<S2SV_blank>Read/Write<S2SV_blank>is<S2SV_blank>in<S2SV_blank>progress\\n" ) ; up ( & Adapter -> fw_download_sema ) ; return - EACCES ; } Adapter -> bBinDownloaded = TRUE ; Adapter -> bCfgDownloaded = TRUE ; atomic_set ( & Adapter -> CurrNumFreeTxDesc , 0 ) ; Adapter -> CurrNumRecvDescs = 0 ; Adapter -> downloadDDR = 0 ; Status = run_card_proc ( Adapter ) ; if ( Status ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "Firm<S2SV_blank>Download<S2SV_blank>Failed\\n" ) ; up ( & Adapter -> fw_download_sema ) ; up ( & Adapter -> NVMRdmWrmLock ) ; return Status ; } else { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "Firm<S2SV_blank>Download<S2SV_blank>Over...\\n" ) ; } mdelay ( 10 ) ; if ( StartInterruptUrb ( ( struct bcm_interface_adapter * ) Adapter -> pvInterfaceAdapter ) ) BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "Unable<S2SV_blank>to<S2SV_blank>send<S2SV_blank>interrupt...\\n" ) ; timeout = 5 * HZ ; Adapter -> waiting_to_fw_download_done = FALSE ; wait_event_timeout ( Adapter -> ioctl_fw_dnld_wait_queue , Adapter -> waiting_to_fw_download_done , timeout ) ; Adapter -> fw_download_process_pid = INVALID_PID ; Adapter -> fw_download_done = TRUE ; atomic_set ( & Adapter -> CurrNumFreeTxDesc , 0 ) ; Adapter -> CurrNumRecvDescs = 0 ; Adapter -> PrevNumRecvDescs = 0 ; atomic_set ( & Adapter -> cntrlpktCnt , 0 ) ; Adapter -> LinkUpStatus = 0 ; Adapter -> LinkStatus = 0 ; if ( Adapter -> LEDInfo . led_thread_running & BCM_LED_THREAD_RUNNING_ACTIVELY ) { Adapter -> DriverState = FW_DOWNLOAD_DONE ; wake_up ( & Adapter -> LEDInfo . notify_led_event ) ; } if ( ! timeout ) Status = - ENODEV ; up ( & Adapter -> fw_download_sema ) ; up ( & Adapter -> NVMRdmWrmLock ) ; return Status ; } case IOCTL_BE_BUCKET_SIZE : Status = 0 ; if ( get_user ( Adapter -> BEBucketSize , ( unsigned long __user * ) arg ) ) Status = - EFAULT ; break ; case IOCTL_RTPS_BUCKET_SIZE : Status = 0 ; if ( get_user ( Adapter -> rtPSBucketSize , ( unsigned long __user * ) arg ) ) Status = - EFAULT ; break ; case IOCTL_CHIP_RESET : { INT NVMAccess = down_trylock ( & Adapter -> NVMRdmWrmLock ) ; if ( NVMAccess ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "<S2SV_blank>IOCTL_BCM_CHIP_RESET<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>as<S2SV_blank>EEPROM<S2SV_blank>Read/Write<S2SV_blank>is<S2SV_blank>in<S2SV_blank>progress\\n" ) ; return - EACCES ; } down ( & Adapter -> RxAppControlQueuelock ) ; Status = reset_card_proc ( Adapter ) ; flushAllAppQ ( ) ; up ( & Adapter -> RxAppControlQueuelock ) ; up ( & Adapter -> NVMRdmWrmLock ) ; ResetCounters ( Adapter ) ; break ; } case IOCTL_QOS_THRESHOLD : { USHORT uiLoopIndex ; Status = 0 ; for ( uiLoopIndex = 0 ; uiLoopIndex < NO_OF_QUEUES ; uiLoopIndex ++ ) { if ( get_user ( Adapter -> PackInfo [ uiLoopIndex ] . uiThreshold , ( unsigned long __user * ) arg ) ) { Status = - EFAULT ; break ; } } break ; } case IOCTL_DUMP_PACKET_INFO : DumpPackInfo ( Adapter ) ; DumpPhsRules ( & Adapter -> stBCMPhsContext ) ; Status = STATUS_SUCCESS ; break ; case IOCTL_GET_PACK_INFO : if ( copy_to_user ( argp , & Adapter -> PackInfo , sizeof ( struct bcm_packet_info ) * NO_OF_QUEUES ) ) return - EFAULT ; Status = STATUS_SUCCESS ; break ; case IOCTL_BCM_SWITCH_TRANSFER_MODE : { UINT uiData = 0 ; if ( copy_from_user ( & uiData , argp , sizeof ( UINT ) ) ) return - EFAULT ; if ( uiData ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "IOCTL_BCM_SWITCH_TRANSFER_MODE:<S2SV_blank>ETH_PACKET_TUNNELING_MODE\\n" ) ; Adapter -> TransferMode = ETH_PACKET_TUNNELING_MODE ; } else { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "IOCTL_BCM_SWITCH_TRANSFER_MODE:<S2SV_blank>IP_PACKET_ONLY_MODE\\n" ) ; Adapter -> TransferMode = IP_PACKET_ONLY_MODE ; } Status = STATUS_SUCCESS ; break ; } case IOCTL_BCM_GET_DRIVER_VERSION : { ulong len ; if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) return - EFAULT ; len = min_t ( ulong , IoBuffer . OutputLength , strlen ( DRV_VERSION ) + 1 ) ; if ( copy_to_user ( IoBuffer . OutputBuffer , DRV_VERSION , len ) ) return - EFAULT ; Status = STATUS_SUCCESS ; break ; } case IOCTL_BCM_GET_CURRENT_STATUS : { struct bcm_link_state link_state ; if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "copy_from_user<S2SV_blank>failed..\\n" ) ; return - EFAULT ; } if ( IoBuffer . OutputLength != sizeof ( link_state ) ) { Status = - EINVAL ; break ; } memset ( & link_state , 0 , sizeof ( link_state ) ) ; link_state . bIdleMode = Adapter -> IdleMode ; link_state . bShutdownMode = Adapter -> bShutStatus ; link_state . ucLinkStatus = Adapter -> LinkStatus ; if ( copy_to_user ( IoBuffer . OutputBuffer , & link_state , min_t ( size_t , sizeof ( link_state ) , IoBuffer . OutputLength ) ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "Copy_to_user<S2SV_blank>Failed..\\n" ) ; return - EFAULT ; } Status = STATUS_SUCCESS ; break ; } case IOCTL_BCM_SET_MAC_TRACING : { UINT tracing_flag ; if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) return - EFAULT ; if ( copy_from_user ( & tracing_flag , IoBuffer . InputBuffer , sizeof ( UINT ) ) ) return - EFAULT ; if ( tracing_flag ) Adapter -> pTarangs -> MacTracingEnabled = TRUE ; else Adapter -> pTarangs -> MacTracingEnabled = FALSE ; break ; } case IOCTL_BCM_GET_DSX_INDICATION : { ULONG ulSFId = 0 ; if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) return - EFAULT ; if ( IoBuffer . OutputLength < sizeof ( struct bcm_add_indication_alt ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "Mismatch<S2SV_blank>req:<S2SV_blank>%lx<S2SV_blank>needed<S2SV_blank>is<S2SV_blank>=0x%zx!!!" , IoBuffer . OutputLength , sizeof ( struct bcm_add_indication_alt ) ) ; return - EINVAL ; } if ( copy_from_user ( & ulSFId , IoBuffer . InputBuffer , sizeof ( ulSFId ) ) ) return - EFAULT ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "Get<S2SV_blank>DSX<S2SV_blank>Data<S2SV_blank>SF<S2SV_blank>ID<S2SV_blank>is<S2SV_blank>=%lx\\n" , ulSFId ) ; get_dsx_sf_data_to_application ( Adapter , ulSFId , IoBuffer . OutputBuffer ) ; Status = STATUS_SUCCESS ; } break ; case IOCTL_BCM_GET_HOST_MIBS : { PVOID temp_buff ; if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) return - EFAULT ; if ( IoBuffer . OutputLength != sizeof ( struct bcm_host_stats_mibs ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "Length<S2SV_blank>Check<S2SV_blank>failed<S2SV_blank>%lu<S2SV_blank>%zd\\n" , IoBuffer . OutputLength , sizeof ( struct bcm_host_stats_mibs ) ) ; return - EINVAL ; } temp_buff = kzalloc ( sizeof ( struct bcm_host_stats_mibs ) , GFP_KERNEL ) ; if ( ! temp_buff ) return STATUS_FAILURE ; Status = ProcessGetHostMibs ( Adapter , temp_buff ) ; GetDroppedAppCntrlPktMibs ( temp_buff , pTarang ) ; if ( Status != STATUS_FAILURE ) if ( copy_to_user ( IoBuffer . OutputBuffer , temp_buff , sizeof ( struct bcm_host_stats_mibs ) ) ) { kfree ( temp_buff ) ; return - EFAULT ; } kfree ( temp_buff ) ; break ; } case IOCTL_BCM_WAKE_UP_DEVICE_FROM_IDLE : if ( ( FALSE == Adapter -> bTriedToWakeUpFromlowPowerMode ) && ( TRUE == Adapter -> IdleMode ) ) { Adapter -> usIdleModePattern = ABORT_IDLE_MODE ; Adapter -> bWakeUpDevice = TRUE ; wake_up ( & Adapter -> process_rx_cntrlpkt ) ; } Status = STATUS_SUCCESS ; break ; case IOCTL_BCM_BULK_WRM : { struct bcm_bulk_wrm_buffer * pBulkBuffer ; UINT uiTempVar = 0 ; PCHAR pvBuffer = NULL ; if ( ( Adapter -> IdleMode == TRUE ) || ( Adapter -> bShutStatus == TRUE ) || ( Adapter -> bPreparingForLowPowerMode == TRUE ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "Device<S2SV_blank>in<S2SV_blank>Idle/Shutdown<S2SV_blank>Mode,<S2SV_blank>Blocking<S2SV_blank>Wrms\\n" ) ; Status = - EACCES ; break ; } if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) return - EFAULT ; if ( IoBuffer . InputLength < sizeof ( ULONG ) * 2 ) return - EINVAL ; pvBuffer = memdup_user ( IoBuffer . InputBuffer , IoBuffer . InputLength ) ; if ( IS_ERR ( pvBuffer ) ) return PTR_ERR ( pvBuffer ) ; pBulkBuffer = ( struct bcm_bulk_wrm_buffer * ) pvBuffer ; if ( ( ( ULONG ) pBulkBuffer -> Register & 0x0F000000 ) != 0x0F000000 || ( ( ULONG ) pBulkBuffer -> Register & 0x3 ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "WRM<S2SV_blank>Done<S2SV_blank>On<S2SV_blank>invalid<S2SV_blank>Address<S2SV_blank>:<S2SV_blank>%x<S2SV_blank>Access<S2SV_blank>Denied.\\n" , ( int ) pBulkBuffer -> Register ) ; kfree ( pvBuffer ) ; Status = - EINVAL ; break ; } uiTempVar = pBulkBuffer -> Register & EEPROM_REJECT_MASK ; if ( ! ( ( Adapter -> pstargetparams -> m_u32Customize ) & VSG_MODE ) && ( ( uiTempVar == EEPROM_REJECT_REG_1 ) || ( uiTempVar == EEPROM_REJECT_REG_2 ) || ( uiTempVar == EEPROM_REJECT_REG_3 ) || ( uiTempVar == EEPROM_REJECT_REG_4 ) ) && ( cmd == IOCTL_BCM_REGISTER_WRITE ) ) { kfree ( pvBuffer ) ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "EEPROM<S2SV_blank>Access<S2SV_blank>Denied,<S2SV_blank>not<S2SV_blank>in<S2SV_blank>VSG<S2SV_blank>Mode\\n" ) ; Status = - EFAULT ; break ; } if ( pBulkBuffer -> SwapEndian == FALSE ) Status = wrmWithLock ( Adapter , ( UINT ) pBulkBuffer -> Register , ( PCHAR ) pBulkBuffer -> Values , IoBuffer . InputLength - 2 * sizeof ( ULONG ) ) ; else Status = wrmaltWithLock ( Adapter , ( UINT ) pBulkBuffer -> Register , ( PUINT ) pBulkBuffer -> Values , IoBuffer . InputLength - 2 * sizeof ( ULONG ) ) ; if ( Status != STATUS_SUCCESS ) BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "WRM<S2SV_blank>Failed\\n" ) ; kfree ( pvBuffer ) ; break ; } case IOCTL_BCM_GET_NVM_SIZE : if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) return - EFAULT ; if ( Adapter -> eNVMType == NVM_EEPROM || Adapter -> eNVMType == NVM_FLASH ) { if ( copy_to_user ( IoBuffer . OutputBuffer , & Adapter -> uiNVMDSDSize , sizeof ( UINT ) ) ) return - EFAULT ; } Status = STATUS_SUCCESS ; break ; case IOCTL_BCM_CAL_INIT : { UINT uiSectorSize = 0 ; if ( Adapter -> eNVMType == NVM_FLASH ) { if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) return - EFAULT ; if ( copy_from_user ( & uiSectorSize , IoBuffer . InputBuffer , sizeof ( UINT ) ) ) return - EFAULT ; if ( ( uiSectorSize < MIN_SECTOR_SIZE ) || ( uiSectorSize > MAX_SECTOR_SIZE ) ) { if ( copy_to_user ( IoBuffer . OutputBuffer , & Adapter -> uiSectorSize , sizeof ( UINT ) ) ) return - EFAULT ; } else { if ( IsFlash2x ( Adapter ) ) { if ( copy_to_user ( IoBuffer . OutputBuffer , & Adapter -> uiSectorSize , sizeof ( UINT ) ) ) return - EFAULT ; } else { if ( ( TRUE == Adapter -> bShutStatus ) || ( TRUE == Adapter -> IdleMode ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "Device<S2SV_blank>is<S2SV_blank>in<S2SV_blank>Idle/Shutdown<S2SV_blank>Mode\\n" ) ; return - EACCES ; } Adapter -> uiSectorSize = uiSectorSize ; BcmUpdateSectorSize ( Adapter , Adapter -> uiSectorSize ) ; } } Status = STATUS_SUCCESS ; } else { Status = STATUS_FAILURE ; } } break ; case IOCTL_BCM_SET_DEBUG : # ifdef DEBUG { struct bcm_user_debug_state sUserDebugState ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "In<S2SV_blank>SET_DEBUG<S2SV_blank>ioctl\\n" ) ; if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) return - EFAULT ; if ( copy_from_user ( & sUserDebugState , IoBuffer . InputBuffer , sizeof ( struct bcm_user_debug_state ) ) ) return - EFAULT ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "IOCTL_BCM_SET_DEBUG:<S2SV_blank>OnOff=%d<S2SV_blank>Type<S2SV_blank>=<S2SV_blank>0x%x<S2SV_blank>" , sUserDebugState . OnOff , sUserDebugState . Type ) ; sUserDebugState . Subtype = 1 << sUserDebugState . Subtype ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "actual<S2SV_blank>Subtype=0x%x\\n" , sUserDebugState . Subtype ) ; Adapter -> stDebugState . type |= sUserDebugState . Type ; if ( sUserDebugState . OnOff ) Adapter -> stDebugState . subtype [ sUserDebugState . Type ] |= sUserDebugState . Subtype ; else Adapter -> stDebugState . subtype [ sUserDebugState . Type ] &= ~ sUserDebugState . Subtype ; BCM_SHOW_DEBUG_BITMAP ( Adapter ) ; } # endif break ; case IOCTL_BCM_NVM_READ : case IOCTL_BCM_NVM_WRITE : { struct bcm_nvm_readwrite stNVMReadWrite ; PUCHAR pReadData = NULL ; ULONG ulDSDMagicNumInUsrBuff = 0 ; struct timeval tv0 , tv1 ; memset ( & tv0 , 0 , sizeof ( struct timeval ) ) ; memset ( & tv1 , 0 , sizeof ( struct timeval ) ) ; if ( ( Adapter -> eNVMType == NVM_FLASH ) && ( Adapter -> uiFlashLayoutMajorVersion == 0 ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "The<S2SV_blank>Flash<S2SV_blank>Control<S2SV_blank>Section<S2SV_blank>is<S2SV_blank>Corrupted.<S2SV_blank>Hence<S2SV_blank>Rejection<S2SV_blank>on<S2SV_blank>NVM<S2SV_blank>Read/Write\\n" ) ; return - EFAULT ; } if ( IsFlash2x ( Adapter ) ) { if ( ( Adapter -> eActiveDSD != DSD0 ) && ( Adapter -> eActiveDSD != DSD1 ) && ( Adapter -> eActiveDSD != DSD2 ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "No<S2SV_blank>DSD<S2SV_blank>is<S2SV_blank>active..hence<S2SV_blank>NVM<S2SV_blank>Command<S2SV_blank>is<S2SV_blank>blocked" ) ; return STATUS_FAILURE ; } } if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) return - EFAULT ; if ( copy_from_user ( & stNVMReadWrite , ( IOCTL_BCM_NVM_READ == cmd ) ? IoBuffer . OutputBuffer : IoBuffer . InputBuffer , sizeof ( struct bcm_nvm_readwrite ) ) ) return - EFAULT ; if ( stNVMReadWrite . uiNumBytes > Adapter -> uiNVMDSDSize ) return STATUS_FAILURE ; if ( stNVMReadWrite . uiOffset > Adapter -> uiNVMDSDSize - stNVMReadWrite . uiNumBytes ) { return STATUS_FAILURE ; } pReadData = memdup_user ( stNVMReadWrite . pBuffer , stNVMReadWrite . uiNumBytes ) ; if ( IS_ERR ( pReadData ) ) return PTR_ERR ( pReadData ) ; do_gettimeofday ( & tv0 ) ; if ( IOCTL_BCM_NVM_READ == cmd ) { down ( & Adapter -> NVMRdmWrmLock ) ; if ( ( Adapter -> IdleMode == TRUE ) || ( Adapter -> bShutStatus == TRUE ) || ( Adapter -> bPreparingForLowPowerMode == TRUE ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "Device<S2SV_blank>is<S2SV_blank>in<S2SV_blank>Idle/Shutdown<S2SV_blank>Mode\\n" ) ; up ( & Adapter -> NVMRdmWrmLock ) ; kfree ( pReadData ) ; return - EACCES ; } Status = BeceemNVMRead ( Adapter , ( PUINT ) pReadData , stNVMReadWrite . uiOffset , stNVMReadWrite . uiNumBytes ) ; up ( & Adapter -> NVMRdmWrmLock ) ; if ( Status != STATUS_SUCCESS ) { kfree ( pReadData ) ; return Status ; } if ( copy_to_user ( stNVMReadWrite . pBuffer , pReadData , stNVMReadWrite . uiNumBytes ) ) { kfree ( pReadData ) ; return - EFAULT ; } } else { down ( & Adapter -> NVMRdmWrmLock ) ; if ( ( Adapter -> IdleMode == TRUE ) || ( Adapter -> bShutStatus == TRUE ) || ( Adapter -> bPreparingForLowPowerMode == TRUE ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "Device<S2SV_blank>is<S2SV_blank>in<S2SV_blank>Idle/Shutdown<S2SV_blank>Mode\\n" ) ; up ( & Adapter -> NVMRdmWrmLock ) ; kfree ( pReadData ) ; return - EACCES ; } Adapter -> bHeaderChangeAllowed = TRUE ; if ( IsFlash2x ( Adapter ) ) { Status = BcmFlash2xCorruptSig ( Adapter , Adapter -> eActiveDSD ) ; if ( Status != STATUS_SUCCESS ) { if ( ( ( stNVMReadWrite . uiOffset + stNVMReadWrite . uiNumBytes ) != Adapter -> uiNVMDSDSize ) || ( stNVMReadWrite . uiNumBytes < SIGNATURE_SIZE ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "DSD<S2SV_blank>Sig<S2SV_blank>is<S2SV_blank>present<S2SV_blank>neither<S2SV_blank>in<S2SV_blank>Flash<S2SV_blank>nor<S2SV_blank>User<S2SV_blank>provided<S2SV_blank>Input.." ) ; up ( & Adapter -> NVMRdmWrmLock ) ; kfree ( pReadData ) ; return Status ; } ulDSDMagicNumInUsrBuff = ntohl ( * ( PUINT ) ( pReadData + stNVMReadWrite . uiNumBytes - SIGNATURE_SIZE ) ) ; if ( ulDSDMagicNumInUsrBuff != DSD_IMAGE_MAGIC_NUMBER ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "DSD<S2SV_blank>Sig<S2SV_blank>is<S2SV_blank>present<S2SV_blank>neither<S2SV_blank>in<S2SV_blank>Flash<S2SV_blank>nor<S2SV_blank>User<S2SV_blank>provided<S2SV_blank>Input.." ) ; up ( & Adapter -> NVMRdmWrmLock ) ; kfree ( pReadData ) ; return Status ; } } } Status = BeceemNVMWrite ( Adapter , ( PUINT ) pReadData , stNVMReadWrite . uiOffset , stNVMReadWrite . uiNumBytes , stNVMReadWrite . bVerify ) ; if ( IsFlash2x ( Adapter ) ) BcmFlash2xWriteSig ( Adapter , Adapter -> eActiveDSD ) ; Adapter -> bHeaderChangeAllowed = FALSE ; up ( & Adapter -> NVMRdmWrmLock ) ; if ( Status != STATUS_SUCCESS ) { kfree ( pReadData ) ; return Status ; } } do_gettimeofday ( & tv1 ) ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "<S2SV_blank>timetaken<S2SV_blank>by<S2SV_blank>Write/read<S2SV_blank>:%ld<S2SV_blank>msec\\n" , ( tv1 . tv_sec - tv0 . tv_sec ) * 1000 + ( tv1 . tv_usec - tv0 . tv_usec ) / 1000 ) ; kfree ( pReadData ) ; return STATUS_SUCCESS ; } case IOCTL_BCM_FLASH2X_SECTION_READ : { struct bcm_flash2x_readwrite sFlash2xRead = { 0 } ; PUCHAR pReadBuff = NULL ; UINT NOB = 0 ; UINT BuffSize = 0 ; UINT ReadBytes = 0 ; UINT ReadOffset = 0 ; void __user * OutPutBuff ; if ( IsFlash2x ( Adapter ) != TRUE ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "Flash<S2SV_blank>Does<S2SV_blank>not<S2SV_blank>have<S2SV_blank>2.x<S2SV_blank>map" ) ; return - EINVAL ; } BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "IOCTL_BCM_FLASH2X_SECTION_READ<S2SV_blank>Called" ) ; if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) return - EFAULT ; if ( copy_from_user ( & sFlash2xRead , IoBuffer . InputBuffer , sizeof ( struct bcm_flash2x_readwrite ) ) ) return - EFAULT ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "\\nsFlash2xRead.Section<S2SV_blank>:%x" , sFlash2xRead . Section ) ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "\\nsFlash2xRead.offset<S2SV_blank>:%x" , sFlash2xRead . offset ) ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "\\nsFlash2xRead.numOfBytes<S2SV_blank>:%x" , sFlash2xRead . numOfBytes ) ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "\\nsFlash2xRead.bVerify<S2SV_blank>:%x\\n" , sFlash2xRead . bVerify ) ; if ( validateFlash2xReadWrite ( Adapter , & sFlash2xRead ) == FALSE ) return STATUS_FAILURE ; NOB = sFlash2xRead . numOfBytes ; if ( NOB > Adapter -> uiSectorSize ) BuffSize = Adapter -> uiSectorSize ; else BuffSize = NOB ; ReadOffset = sFlash2xRead . offset ; OutPutBuff = IoBuffer . OutputBuffer ; pReadBuff = ( PCHAR ) kzalloc ( BuffSize , GFP_KERNEL ) ; if ( pReadBuff == NULL ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "Memory<S2SV_blank>allocation<S2SV_blank>failed<S2SV_blank>for<S2SV_blank>Flash<S2SV_blank>2.x<S2SV_blank>Read<S2SV_blank>Structure" ) ; return - ENOMEM ; } down ( & Adapter -> NVMRdmWrmLock ) ; if ( ( Adapter -> IdleMode == TRUE ) || ( Adapter -> bShutStatus == TRUE ) || ( Adapter -> bPreparingForLowPowerMode == TRUE ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "Device<S2SV_blank>is<S2SV_blank>in<S2SV_blank>Idle/Shutdown<S2SV_blank>Mode\\n" ) ; up ( & Adapter -> NVMRdmWrmLock ) ; kfree ( pReadBuff ) ; return - EACCES ; } while ( NOB ) { if ( NOB > Adapter -> uiSectorSize ) ReadBytes = Adapter -> uiSectorSize ; else ReadBytes = NOB ; Status = BcmFlash2xBulkRead ( Adapter , ( PUINT ) pReadBuff , sFlash2xRead . Section , ReadOffset , ReadBytes ) ; if ( Status ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "Flash<S2SV_blank>2x<S2SV_blank>read<S2SV_blank>err<S2SV_blank>with<S2SV_blank>Status<S2SV_blank>:%d" , Status ) ; break ; } BCM_DEBUG_PRINT_BUFFER ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , pReadBuff , ReadBytes ) ; Status = copy_to_user ( OutPutBuff , pReadBuff , ReadBytes ) ; if ( Status ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "Copy<S2SV_blank>to<S2SV_blank>use<S2SV_blank>failed<S2SV_blank>with<S2SV_blank>status<S2SV_blank>:%d" , Status ) ; up ( & Adapter -> NVMRdmWrmLock ) ; kfree ( pReadBuff ) ; return - EFAULT ; } NOB = NOB - ReadBytes ; if ( NOB ) { ReadOffset = ReadOffset + ReadBytes ; OutPutBuff = OutPutBuff + ReadBytes ; } } up ( & Adapter -> NVMRdmWrmLock ) ; kfree ( pReadBuff ) ; } break ; case IOCTL_BCM_FLASH2X_SECTION_WRITE : { struct bcm_flash2x_readwrite sFlash2xWrite = { 0 } ; PUCHAR pWriteBuff ; void __user * InputAddr ; UINT NOB = 0 ; UINT BuffSize = 0 ; UINT WriteOffset = 0 ; UINT WriteBytes = 0 ; if ( IsFlash2x ( Adapter ) != TRUE ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "Flash<S2SV_blank>Does<S2SV_blank>not<S2SV_blank>have<S2SV_blank>2.x<S2SV_blank>map" ) ; return - EINVAL ; } Adapter -> bAllDSDWriteAllow = FALSE ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "IOCTL_BCM_FLASH2X_SECTION_WRITE<S2SV_blank>Called" ) ; if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) return - EFAULT ; if ( copy_from_user ( & sFlash2xWrite , IoBuffer . InputBuffer , sizeof ( struct bcm_flash2x_readwrite ) ) ) return - EFAULT ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "\\nsFlash2xRead.Section<S2SV_blank>:%x" , sFlash2xWrite . Section ) ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "\\nsFlash2xRead.offset<S2SV_blank>:%d" , sFlash2xWrite . offset ) ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "\\nsFlash2xRead.numOfBytes<S2SV_blank>:%x" , sFlash2xWrite . numOfBytes ) ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "\\nsFlash2xRead.bVerify<S2SV_blank>:%x\\n" , sFlash2xWrite . bVerify ) ; if ( ( sFlash2xWrite . Section != VSA0 ) && ( sFlash2xWrite . Section != VSA1 ) && ( sFlash2xWrite . Section != VSA2 ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "Only<S2SV_blank>VSA<S2SV_blank>write<S2SV_blank>is<S2SV_blank>allowed" ) ; return - EINVAL ; } if ( validateFlash2xReadWrite ( Adapter , & sFlash2xWrite ) == FALSE ) return STATUS_FAILURE ; InputAddr = sFlash2xWrite . pDataBuff ; WriteOffset = sFlash2xWrite . offset ; NOB = sFlash2xWrite . numOfBytes ; if ( NOB > Adapter -> uiSectorSize ) BuffSize = Adapter -> uiSectorSize ; else BuffSize = NOB ; pWriteBuff = kmalloc ( BuffSize , GFP_KERNEL ) ; if ( pWriteBuff == NULL ) return - ENOMEM ; WriteBytes = Adapter -> uiSectorSize ; if ( WriteOffset % Adapter -> uiSectorSize ) WriteBytes = Adapter -> uiSectorSize - ( WriteOffset % Adapter -> uiSectorSize ) ; if ( NOB < WriteBytes ) WriteBytes = NOB ; down ( & Adapter -> NVMRdmWrmLock ) ; if ( ( Adapter -> IdleMode == TRUE ) || ( Adapter -> bShutStatus == TRUE ) || ( Adapter -> bPreparingForLowPowerMode == TRUE ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "Device<S2SV_blank>is<S2SV_blank>in<S2SV_blank>Idle/Shutdown<S2SV_blank>Mode\\n" ) ; up ( & Adapter -> NVMRdmWrmLock ) ; kfree ( pWriteBuff ) ; return - EACCES ; } BcmFlash2xCorruptSig ( Adapter , sFlash2xWrite . Section ) ; do { Status = copy_from_user ( pWriteBuff , InputAddr , WriteBytes ) ; if ( Status ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "Copy<S2SV_blank>to<S2SV_blank>user<S2SV_blank>failed<S2SV_blank>with<S2SV_blank>status<S2SV_blank>:%d" , Status ) ; up ( & Adapter -> NVMRdmWrmLock ) ; kfree ( pWriteBuff ) ; return - EFAULT ; } BCM_DEBUG_PRINT_BUFFER ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , pWriteBuff , WriteBytes ) ; Status = BcmFlash2xBulkWrite ( Adapter , ( PUINT ) pWriteBuff , sFlash2xWrite . Section , WriteOffset , WriteBytes , sFlash2xWrite . bVerify ) ; if ( Status ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "Flash<S2SV_blank>2x<S2SV_blank>read<S2SV_blank>err<S2SV_blank>with<S2SV_blank>Status<S2SV_blank>:%d" , Status ) ; break ; } NOB = NOB - WriteBytes ; if ( NOB ) { WriteOffset = WriteOffset + WriteBytes ; InputAddr = InputAddr + WriteBytes ; if ( NOB > Adapter -> uiSectorSize ) WriteBytes = Adapter -> uiSectorSize ; else WriteBytes = NOB ; } } while ( NOB > 0 ) ; BcmFlash2xWriteSig ( Adapter , sFlash2xWrite . Section ) ; up ( & Adapter -> NVMRdmWrmLock ) ; kfree ( pWriteBuff ) ; } break ; case IOCTL_BCM_GET_FLASH2X_SECTION_BITMAP : { struct bcm_flash2x_bitmap * psFlash2xBitMap ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "IOCTL_BCM_GET_FLASH2X_SECTION_BITMAP<S2SV_blank>Called" ) ; if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) return - EFAULT ; if ( IoBuffer . OutputLength != sizeof ( struct bcm_flash2x_bitmap ) ) return - EINVAL ; psFlash2xBitMap = kzalloc ( sizeof ( struct bcm_flash2x_bitmap ) , GFP_KERNEL ) ; if ( psFlash2xBitMap == NULL ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "Memory<S2SV_blank>is<S2SV_blank>not<S2SV_blank>available" ) ; return - ENOMEM ; } down ( & Adapter -> NVMRdmWrmLock ) ; if ( ( Adapter -> IdleMode == TRUE ) || ( Adapter -> bShutStatus == TRUE ) || ( Adapter -> bPreparingForLowPowerMode == TRUE ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "Device<S2SV_blank>is<S2SV_blank>in<S2SV_blank>Idle/Shutdown<S2SV_blank>Mode\\n" ) ; up ( & Adapter -> NVMRdmWrmLock ) ; kfree ( psFlash2xBitMap ) ; return - EACCES ; } BcmGetFlash2xSectionalBitMap ( Adapter , psFlash2xBitMap ) ; up ( & Adapter -> NVMRdmWrmLock ) ; if ( copy_to_user ( IoBuffer . OutputBuffer , psFlash2xBitMap , sizeof ( struct bcm_flash2x_bitmap ) ) ) { kfree ( psFlash2xBitMap ) ; return - EFAULT ; } kfree ( psFlash2xBitMap ) ; } break ; case IOCTL_BCM_SET_ACTIVE_SECTION : { enum bcm_flash2x_section_val eFlash2xSectionVal = 0 ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "IOCTL_BCM_SET_ACTIVE_SECTION<S2SV_blank>Called" ) ; if ( IsFlash2x ( Adapter ) != TRUE ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "Flash<S2SV_blank>Does<S2SV_blank>not<S2SV_blank>have<S2SV_blank>2.x<S2SV_blank>map" ) ; return - EINVAL ; } Status = copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ; if ( Status ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "Copy<S2SV_blank>of<S2SV_blank>IOCTL<S2SV_blank>BUFFER<S2SV_blank>failed" ) ; return - EFAULT ; } Status = copy_from_user ( & eFlash2xSectionVal , IoBuffer . InputBuffer , sizeof ( INT ) ) ; if ( Status ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "Copy<S2SV_blank>of<S2SV_blank>flash<S2SV_blank>section<S2SV_blank>val<S2SV_blank>failed" ) ; return - EFAULT ; } down ( & Adapter -> NVMRdmWrmLock ) ; if ( ( Adapter -> IdleMode == TRUE ) || ( Adapter -> bShutStatus == TRUE ) || ( Adapter -> bPreparingForLowPowerMode == TRUE ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "Device<S2SV_blank>is<S2SV_blank>in<S2SV_blank>Idle/Shutdown<S2SV_blank>Mode\\n" ) ; up ( & Adapter -> NVMRdmWrmLock ) ; return - EACCES ; } Status = BcmSetActiveSection ( Adapter , eFlash2xSectionVal ) ; if ( Status ) BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "Failed<S2SV_blank>to<S2SV_blank>make<S2SV_blank>it\'s<S2SV_blank>priority<S2SV_blank>Highest.<S2SV_blank>Status<S2SV_blank>%d" , Status ) ; up ( & Adapter -> NVMRdmWrmLock ) ; } break ; case IOCTL_BCM_IDENTIFY_ACTIVE_SECTION : { Adapter -> bAllDSDWriteAllow = FALSE ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "IOCTL_BCM_IDENTIFY_ACTIVE_SECTION<S2SV_blank>called" ) ; Status = STATUS_SUCCESS ; } break ; case IOCTL_BCM_COPY_SECTION : { struct bcm_flash2x_copy_section sCopySectStrut = { 0 } ; Status = STATUS_SUCCESS ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "IOCTL_BCM_COPY_SECTION<S2SV_blank><S2SV_blank>Called" ) ; Adapter -> bAllDSDWriteAllow = FALSE ; if ( IsFlash2x ( Adapter ) != TRUE ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "Flash<S2SV_blank>Does<S2SV_blank>not<S2SV_blank>have<S2SV_blank>2.x<S2SV_blank>map" ) ; return - EINVAL ; } Status = copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ; if ( Status ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "Copy<S2SV_blank>of<S2SV_blank>IOCTL<S2SV_blank>BUFFER<S2SV_blank>failed<S2SV_blank>Status<S2SV_blank>:%d" , Status ) ; return - EFAULT ; } Status = copy_from_user ( & sCopySectStrut , IoBuffer . InputBuffer , sizeof ( struct bcm_flash2x_copy_section ) ) ; if ( Status ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "Copy<S2SV_blank>of<S2SV_blank>Copy_Section_Struct<S2SV_blank>failed<S2SV_blank>with<S2SV_blank>Status<S2SV_blank>:%d" , Status ) ; return - EFAULT ; } BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "Source<S2SV_blank>SEction<S2SV_blank>:%x" , sCopySectStrut . SrcSection ) ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "Destination<S2SV_blank>SEction<S2SV_blank>:%x" , sCopySectStrut . DstSection ) ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "offset<S2SV_blank>:%x" , sCopySectStrut . offset ) ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "NOB<S2SV_blank>:%x" , sCopySectStrut . numOfBytes ) ; if ( IsSectionExistInFlash ( Adapter , sCopySectStrut . SrcSection ) == FALSE ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "Source<S2SV_blank>Section<%x><S2SV_blank>does<S2SV_blank>not<S2SV_blank>exixt<S2SV_blank>in<S2SV_blank>Flash<S2SV_blank>" , sCopySectStrut . SrcSection ) ; return - EINVAL ; } if ( IsSectionExistInFlash ( Adapter , sCopySectStrut . DstSection ) == FALSE ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "Destinatio<S2SV_blank>Section<%x><S2SV_blank>does<S2SV_blank>not<S2SV_blank>exixt<S2SV_blank>in<S2SV_blank>Flash<S2SV_blank>" , sCopySectStrut . DstSection ) ; return - EINVAL ; } if ( sCopySectStrut . SrcSection == sCopySectStrut . DstSection ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "Source<S2SV_blank>and<S2SV_blank>Destination<S2SV_blank>section<S2SV_blank>should<S2SV_blank>be<S2SV_blank>different" ) ; return - EINVAL ; } down ( & Adapter -> NVMRdmWrmLock ) ; if ( ( Adapter -> IdleMode == TRUE ) || ( Adapter -> bShutStatus == TRUE ) || ( Adapter -> bPreparingForLowPowerMode == TRUE ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "Device<S2SV_blank>is<S2SV_blank>in<S2SV_blank>Idle/Shutdown<S2SV_blank>Mode\\n" ) ; up ( & Adapter -> NVMRdmWrmLock ) ; return - EACCES ; } if ( sCopySectStrut . SrcSection == ISO_IMAGE1 || sCopySectStrut . SrcSection == ISO_IMAGE2 ) { if ( IsNonCDLessDevice ( Adapter ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "Device<S2SV_blank>is<S2SV_blank>Non-CDLess<S2SV_blank>hence<S2SV_blank>won\'t<S2SV_blank>have<S2SV_blank>ISO<S2SV_blank>!!" ) ; Status = - EINVAL ; } else if ( sCopySectStrut . numOfBytes == 0 ) { Status = BcmCopyISO ( Adapter , sCopySectStrut ) ; } else { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "Partial<S2SV_blank>Copy<S2SV_blank>of<S2SV_blank>ISO<S2SV_blank>section<S2SV_blank>is<S2SV_blank>not<S2SV_blank>Allowed.." ) ; Status = STATUS_FAILURE ; } up ( & Adapter -> NVMRdmWrmLock ) ; return Status ; } Status = BcmCopySection ( Adapter , sCopySectStrut . SrcSection , sCopySectStrut . DstSection , sCopySectStrut . offset , sCopySectStrut . numOfBytes ) ; up ( & Adapter -> NVMRdmWrmLock ) ; } break ; case IOCTL_BCM_GET_FLASH_CS_INFO : { Status = STATUS_SUCCESS ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "<S2SV_blank>IOCTL_BCM_GET_FLASH_CS_INFO<S2SV_blank>Called" ) ; Status = copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ; if ( Status ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "Copy<S2SV_blank>of<S2SV_blank>IOCTL<S2SV_blank>BUFFER<S2SV_blank>failed" ) ; return - EFAULT ; } if ( Adapter -> eNVMType != NVM_FLASH ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "Connected<S2SV_blank>device<S2SV_blank>does<S2SV_blank>not<S2SV_blank>have<S2SV_blank>flash" ) ; Status = - EINVAL ; break ; } if ( IsFlash2x ( Adapter ) == TRUE ) { if ( IoBuffer . OutputLength < sizeof ( struct bcm_flash2x_cs_info ) ) return - EINVAL ; if ( copy_to_user ( IoBuffer . OutputBuffer , Adapter -> psFlash2xCSInfo , sizeof ( struct bcm_flash2x_cs_info ) ) ) return - EFAULT ; } else { if ( IoBuffer . OutputLength < sizeof ( struct bcm_flash_cs_info ) ) return - EINVAL ; if ( copy_to_user ( IoBuffer . OutputBuffer , Adapter -> psFlashCSInfo , sizeof ( struct bcm_flash_cs_info ) ) ) return - EFAULT ; } } break ; case IOCTL_BCM_SELECT_DSD : { UINT SectOfset = 0 ; enum bcm_flash2x_section_val eFlash2xSectionVal ; eFlash2xSectionVal = NO_SECTION_VAL ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "IOCTL_BCM_SELECT_DSD<S2SV_blank>Called" ) ; if ( IsFlash2x ( Adapter ) != TRUE ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "Flash<S2SV_blank>Does<S2SV_blank>not<S2SV_blank>have<S2SV_blank>2.x<S2SV_blank>map" ) ; return - EINVAL ; } Status = copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ; if ( Status ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "Copy<S2SV_blank>of<S2SV_blank>IOCTL<S2SV_blank>BUFFER<S2SV_blank>failed" ) ; return - EFAULT ; } Status = copy_from_user ( & eFlash2xSectionVal , IoBuffer . InputBuffer , sizeof ( INT ) ) ; if ( Status ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "Copy<S2SV_blank>of<S2SV_blank>flash<S2SV_blank>section<S2SV_blank>val<S2SV_blank>failed" ) ; return - EFAULT ; } BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "Read<S2SV_blank>Section<S2SV_blank>:%d" , eFlash2xSectionVal ) ; if ( ( eFlash2xSectionVal != DSD0 ) && ( eFlash2xSectionVal != DSD1 ) && ( eFlash2xSectionVal != DSD2 ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "Passed<S2SV_blank>section<%x><S2SV_blank>is<S2SV_blank>not<S2SV_blank>DSD<S2SV_blank>section" , eFlash2xSectionVal ) ; return STATUS_FAILURE ; } SectOfset = BcmGetSectionValStartOffset ( Adapter , eFlash2xSectionVal ) ; if ( SectOfset == INVALID_OFFSET ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "Provided<S2SV_blank>Section<S2SV_blank>val<S2SV_blank><%d><S2SV_blank>does<S2SV_blank>not<S2SV_blank>exixt<S2SV_blank>in<S2SV_blank>Flash<S2SV_blank>2.x" , eFlash2xSectionVal ) ; return - EINVAL ; } Adapter -> bAllDSDWriteAllow = TRUE ; Adapter -> ulFlashCalStart = SectOfset ; Adapter -> eActiveDSD = eFlash2xSectionVal ; } Status = STATUS_SUCCESS ; break ; case IOCTL_BCM_NVM_RAW_READ : { struct bcm_nvm_readwrite stNVMRead ; INT NOB ; INT BuffSize ; INT ReadOffset = 0 ; UINT ReadBytes = 0 ; PUCHAR pReadBuff ; void __user * OutPutBuff ; if ( Adapter -> eNVMType != NVM_FLASH ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "NVM<S2SV_blank>TYPE<S2SV_blank>is<S2SV_blank>not<S2SV_blank>Flash" ) ; return - EINVAL ; } if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "copy_from_user<S2SV_blank>1<S2SV_blank>failed\\n" ) ; return - EFAULT ; } if ( copy_from_user ( & stNVMRead , IoBuffer . OutputBuffer , sizeof ( struct bcm_nvm_readwrite ) ) ) return - EFAULT ; NOB = stNVMRead . uiNumBytes ; if ( NOB > DEFAULT_BUFF_SIZE ) BuffSize = DEFAULT_BUFF_SIZE ; else BuffSize = NOB ; ReadOffset = stNVMRead . uiOffset ; OutPutBuff = stNVMRead . pBuffer ; pReadBuff = kzalloc ( BuffSize , GFP_KERNEL ) ; if ( pReadBuff == NULL ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "Memory<S2SV_blank>allocation<S2SV_blank>failed<S2SV_blank>for<S2SV_blank>Flash<S2SV_blank>2.x<S2SV_blank>Read<S2SV_blank>Structure" ) ; Status = - ENOMEM ; break ; } down ( & Adapter -> NVMRdmWrmLock ) ; if ( ( Adapter -> IdleMode == TRUE ) || ( Adapter -> bShutStatus == TRUE ) || ( Adapter -> bPreparingForLowPowerMode == TRUE ) ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "Device<S2SV_blank>is<S2SV_blank>in<S2SV_blank>Idle/Shutdown<S2SV_blank>Mode\\n" ) ; kfree ( pReadBuff ) ; up ( & Adapter -> NVMRdmWrmLock ) ; return - EACCES ; } Adapter -> bFlashRawRead = TRUE ; while ( NOB ) { if ( NOB > DEFAULT_BUFF_SIZE ) ReadBytes = DEFAULT_BUFF_SIZE ; else ReadBytes = NOB ; Status = BeceemNVMRead ( Adapter , ( PUINT ) pReadBuff , ReadOffset , ReadBytes ) ; if ( Status ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "Flash<S2SV_blank>2x<S2SV_blank>read<S2SV_blank>err<S2SV_blank>with<S2SV_blank>Status<S2SV_blank>:%d" , Status ) ; break ; } BCM_DEBUG_PRINT_BUFFER ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , pReadBuff , ReadBytes ) ; Status = copy_to_user ( OutPutBuff , pReadBuff , ReadBytes ) ; if ( Status ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_PRINTK , 0 , 0 , "Copy<S2SV_blank>to<S2SV_blank>use<S2SV_blank>failed<S2SV_blank>with<S2SV_blank>status<S2SV_blank>:%d" , Status ) ; up ( & Adapter -> NVMRdmWrmLock ) ; kfree ( pReadBuff ) ; return - EFAULT ; } NOB = NOB - ReadBytes ; if ( NOB ) { ReadOffset = ReadOffset + ReadBytes ; OutPutBuff = OutPutBuff + ReadBytes ; } } Adapter -> bFlashRawRead = FALSE ; up ( & Adapter -> NVMRdmWrmLock ) ; kfree ( pReadBuff ) ; break ; } case IOCTL_BCM_CNTRLMSG_MASK : { ULONG RxCntrlMsgBitMask = 0 ; Status = copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ; if ( Status ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "copy<S2SV_blank>of<S2SV_blank>Ioctl<S2SV_blank>buffer<S2SV_blank>is<S2SV_blank>failed<S2SV_blank>from<S2SV_blank>user<S2SV_blank>space" ) ; return - EFAULT ; } if ( IoBuffer . InputLength != sizeof ( unsigned long ) ) { Status = - EINVAL ; break ; } Status = copy_from_user ( & RxCntrlMsgBitMask , IoBuffer . InputBuffer , IoBuffer . InputLength ) ; if ( Status ) { BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "copy<S2SV_blank>of<S2SV_blank>control<S2SV_blank>bit<S2SV_blank>mask<S2SV_blank>failed<S2SV_blank>from<S2SV_blank>user<S2SV_blank>space" ) ; return - EFAULT ; } BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "\\n<S2SV_blank>Got<S2SV_blank>user<S2SV_blank>defined<S2SV_blank>cntrl<S2SV_blank>msg<S2SV_blank>bit<S2SV_blank>mask<S2SV_blank>:%lx" , RxCntrlMsgBitMask ) ; pTarang -> RxCntrlMsgBitMask = RxCntrlMsgBitMask ; } break ; case IOCTL_BCM_GET_DEVICE_DRIVER_INFO : { struct bcm_driver_info DevInfo ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "Called<S2SV_blank>IOCTL_BCM_GET_DEVICE_DRIVER_INFO\\n" ) ; <S2SV_StartBug> DevInfo . MaxRDMBufferSize = BUFFER_4K ; <S2SV_EndBug> DevInfo . u32DSDStartOffset = EEPROM_CALPARAM_START ; DevInfo . u32RxAlignmentCorrection = 0 ; DevInfo . u32NVMType = Adapter -> eNVMType ; DevInfo . u32InterfaceType = BCM_USB ; if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) return - EFAULT ; if ( IoBuffer . OutputLength < sizeof ( DevInfo ) ) return - EINVAL ; if ( copy_to_user ( IoBuffer . OutputBuffer , & DevInfo , sizeof ( DevInfo ) ) ) return - EFAULT ; } break ; case IOCTL_BCM_TIME_SINCE_NET_ENTRY : { struct bcm_time_elapsed stTimeElapsedSinceNetEntry = { 0 } ; BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "IOCTL_BCM_TIME_SINCE_NET_ENTRY<S2SV_blank>called" ) ; if ( copy_from_user ( & IoBuffer , argp , sizeof ( struct bcm_ioctl_buffer ) ) ) return - EFAULT ; if ( IoBuffer . OutputLength < sizeof ( struct bcm_time_elapsed ) ) return - EINVAL ; stTimeElapsedSinceNetEntry . ul64TimeElapsedSinceNetEntry = get_seconds ( ) - Adapter -> liTimeSinceLastNetEntry ; if ( copy_to_user ( IoBuffer . OutputBuffer , & stTimeElapsedSinceNetEntry , sizeof ( struct bcm_time_elapsed ) ) ) return - EFAULT ; } break ; case IOCTL_CLOSE_NOTIFICATION : BCM_DEBUG_PRINT ( Adapter , DBG_TYPE_OTHERS , OSAL_DBG , DBG_LVL_ALL , "IOCTL_CLOSE_NOTIFICATION" ) ; break ; default : pr_info ( DRV_NAME ":<S2SV_blank>unknown<S2SV_blank>ioctl<S2SV_blank>cmd=%#x\\n" , cmd ) ; Status = STATUS_FAILURE ; break ; } return Status ; }
static int ras_getdatastd ( jas_stream_t * in , ras_hdr_t * hdr , ras_cmap_t * cmap , jas_image_t * image ) { int pad ; int nz ; int z ; int c ; int y ; int x ; int v ; int i ; jas_matrix_t * data [ 3 ] ; cmap = 0 ; <S2SV_StartBug> for ( i = 0 ; i < jas_image_numcmpts ( image ) ; ++ i ) { <S2SV_EndBug> <S2SV_StartBug> data [ i ] = jas_matrix_create ( 1 , jas_image_width ( image ) ) ; <S2SV_EndBug> assert ( data [ i ] ) ; } pad = RAS_ROWSIZE ( hdr ) - ( hdr -> width * hdr -> depth + 7 ) / 8 ; for ( y = 0 ; y < hdr -> height ; y ++ ) { nz = 0 ; z = 0 ; for ( x = 0 ; x < hdr -> width ; x ++ ) { while ( nz < hdr -> depth ) { if ( ( c = jas_stream_getc ( in ) ) == EOF ) { <S2SV_StartBug> return - 1 ; <S2SV_EndBug> } <S2SV_StartBug> z = ( z << 8 ) | c ; <S2SV_EndBug> nz += 8 ; } v = ( z >> ( nz - hdr -> depth ) ) & RAS_ONES ( hdr -> depth ) ; z &= RAS_ONES ( nz - hdr -> depth ) ; nz -= hdr -> depth ; if ( jas_image_numcmpts ( image ) == 3 ) { jas_matrix_setv ( data [ 0 ] , x , ( RAS_GETRED ( v ) ) ) ; jas_matrix_setv ( data [ 1 ] , x , ( RAS_GETGREEN ( v ) ) ) ; jas_matrix_setv ( data [ 2 ] , x , ( RAS_GETBLUE ( v ) ) ) ; } else { jas_matrix_setv ( data [ 0 ] , x , ( v ) ) ; } } if ( pad ) { if ( ( c = jas_stream_getc ( in ) ) == EOF ) { return - 1 ; } } for ( i = 0 ; i < jas_image_numcmpts ( image ) ; ++ i ) { if ( jas_image_writecmpt ( image , i , 0 , y , hdr -> width , 1 , data [ i ] ) ) { return - 1 ; } } } for ( i = 0 ; i < jas_image_numcmpts ( image ) ; ++ i ) { jas_matrix_destroy ( data [ i ] ) ; } return 0 ; }
static grub_err_t find_file ( const char * currpath , grub_fshelp_node_t currroot , grub_fshelp_node_t * currfound , struct grub_fshelp_find_file_closure * c ) { <S2SV_StartBug> # ifndef _MSC_VER <S2SV_EndBug> <S2SV_StartBug> char fpath [ grub_strlen ( currpath ) + 1 ] ; <S2SV_EndBug> # else char * fpath = grub_malloc ( grub_strlen ( currpath ) + 1 ) ; <S2SV_StartBug> # endif <S2SV_EndBug> char * name = fpath ; char * next ; enum grub_fshelp_filetype type = GRUB_FSHELP_DIR ; grub_fshelp_node_t currnode = currroot ; grub_fshelp_node_t oldnode = currroot ; c -> currroot = currroot ; grub_strncpy ( fpath , currpath , grub_strlen ( currpath ) + 1 ) ; while ( * name == '/' ) name ++ ; if ( ! * name ) { <S2SV_StartBug> * currfound = currnode ; <S2SV_EndBug> return 0 ; } for ( ; ; ) { int found ; struct find_file_closure cc ; next = grub_strchr ( name , '/' ) ; if ( next ) { while ( * next == '/' ) * ( next ++ ) = '\\0' ; } if ( type != GRUB_FSHELP_DIR ) { free_node ( currnode , c ) ; <S2SV_StartBug> return grub_error ( GRUB_ERR_BAD_FILE_TYPE , "not<S2SV_blank>a<S2SV_blank>directory" ) ; <S2SV_EndBug> } cc . name = name ; cc . type = & type ; cc . oldnode = & oldnode ; cc . currnode = & currnode ; found = c -> iterate_dir ( currnode , iterate , & cc ) ; if ( ! found ) { <S2SV_StartBug> if ( grub_errno ) <S2SV_EndBug> <S2SV_StartBug> return grub_errno ; <S2SV_EndBug> break ; } if ( type == GRUB_FSHELP_SYMLINK ) { char * symlink ; if ( ++ ( c -> symlinknest ) == 8 ) { free_node ( currnode , c ) ; free_node ( oldnode , c ) ; <S2SV_StartBug> return grub_error ( GRUB_ERR_SYMLINK_LOOP , <S2SV_EndBug> "too<S2SV_blank>deep<S2SV_blank>nesting<S2SV_blank>of<S2SV_blank>symlinks" ) ; } symlink = c -> read_symlink ( currnode ) ; free_node ( currnode , c ) ; if ( ! symlink ) { <S2SV_StartBug> free_node ( oldnode , c ) ; <S2SV_EndBug> return grub_errno ; } if ( symlink [ 0 ] == '/' ) { free_node ( oldnode , c ) ; oldnode = c -> rootnode ; } find_file ( symlink , oldnode , & currnode , c ) ; type = c -> foundtype ; grub_free ( symlink ) ; if ( grub_errno ) { free_node ( oldnode , c ) ; <S2SV_StartBug> return grub_errno ; <S2SV_EndBug> } } free_node ( oldnode , c ) ; if ( ! next || * next == '\\0' ) { * currfound = currnode ; c -> foundtype = type ; <S2SV_StartBug> return 0 ; <S2SV_EndBug> } name = next ; } <S2SV_StartBug> return grub_error ( GRUB_ERR_FILE_NOT_FOUND , "file<S2SV_blank>not<S2SV_blank>found" ) ; <S2SV_EndBug> }
int drm_mode_dirtyfb_ioctl ( struct drm_device * dev , void * data , struct drm_file * file_priv ) { struct drm_clip_rect __user * clips_ptr ; struct drm_clip_rect * clips = NULL ; struct drm_mode_fb_dirty_cmd * r = data ; struct drm_mode_object * obj ; struct drm_framebuffer * fb ; unsigned flags ; int num_clips ; int ret = 0 ; if ( ! drm_core_check_feature ( dev , DRIVER_MODESET ) ) return - EINVAL ; mutex_lock ( & dev -> mode_config . mutex ) ; obj = drm_mode_object_find ( dev , r -> fb_id , DRM_MODE_OBJECT_FB ) ; if ( ! obj ) { DRM_ERROR ( "invalid<S2SV_blank>framebuffer<S2SV_blank>id\\n" ) ; ret = - EINVAL ; goto out_err1 ; } fb = obj_to_fb ( obj ) ; num_clips = r -> num_clips ; clips_ptr = ( struct drm_clip_rect * ) ( unsigned long ) r -> clips_ptr ; if ( ! num_clips != ! clips_ptr ) { ret = - EINVAL ; goto out_err1 ; } flags = DRM_MODE_FB_DIRTY_FLAGS & r -> flags ; if ( flags & DRM_MODE_FB_DIRTY_ANNOTATE_COPY && ( num_clips % 2 ) ) { ret = - EINVAL ; goto out_err1 ; } if ( num_clips && clips_ptr ) { <S2SV_StartBug> clips = kzalloc ( num_clips * sizeof ( * clips ) , GFP_KERNEL ) ; <S2SV_EndBug> if ( ! clips ) { ret = - ENOMEM ; goto out_err1 ; } ret = copy_from_user ( clips , clips_ptr , num_clips * sizeof ( * clips ) ) ; if ( ret ) { ret = - EFAULT ; goto out_err2 ; } } if ( fb -> funcs -> dirty ) { ret = fb -> funcs -> dirty ( fb , file_priv , flags , r -> color , clips , num_clips ) ; } else { ret = - ENOSYS ; goto out_err2 ; } out_err2 : kfree ( clips ) ; out_err1 : mutex_unlock ( & dev -> mode_config . mutex ) ; return ret ; }
static int asymmetric_key_match_preparse ( struct key_match_data * match_data ) { match_data -> lookup_type = KEYRING_SEARCH_LOOKUP_ITERATE ; <S2SV_StartBug> return 0 ; <S2SV_EndBug> }
static ssize_t aio_setup_iocb ( struct kiocb * kiocb , bool compat ) { struct file * file = kiocb -> ki_filp ; ssize_t ret = 0 ; switch ( kiocb -> ki_opcode ) { case IOCB_CMD_PREAD : ret = - EBADF ; if ( unlikely ( ! ( file -> f_mode & FMODE_READ ) ) ) break ; ret = - EFAULT ; if ( unlikely ( ! access_ok ( VERIFY_WRITE , kiocb -> ki_buf , kiocb -> ki_left ) ) ) break ; <S2SV_StartBug> ret = security_file_permission ( file , MAY_READ ) ; <S2SV_EndBug> if ( unlikely ( ret ) ) break ; ret = aio_setup_single_vector ( kiocb ) ; if ( ret ) break ; ret = - EINVAL ; if ( file -> f_op -> aio_read ) kiocb -> ki_retry = aio_rw_vect_retry ; break ; case IOCB_CMD_PWRITE : ret = - EBADF ; if ( unlikely ( ! ( file -> f_mode & FMODE_WRITE ) ) ) break ; ret = - EFAULT ; if ( unlikely ( ! access_ok ( VERIFY_READ , kiocb -> ki_buf , kiocb -> ki_left ) ) ) break ; <S2SV_StartBug> ret = security_file_permission ( file , MAY_WRITE ) ; <S2SV_EndBug> if ( unlikely ( ret ) ) break ; ret = aio_setup_single_vector ( kiocb ) ; if ( ret ) break ; ret = - EINVAL ; if ( file -> f_op -> aio_write ) kiocb -> ki_retry = aio_rw_vect_retry ; break ; case IOCB_CMD_PREADV : ret = - EBADF ; if ( unlikely ( ! ( file -> f_mode & FMODE_READ ) ) ) break ; <S2SV_StartBug> ret = security_file_permission ( file , MAY_READ ) ; <S2SV_EndBug> if ( unlikely ( ret ) ) break ; ret = aio_setup_vectored_rw ( READ , kiocb , compat ) ; if ( ret ) break ; ret = - EINVAL ; if ( file -> f_op -> aio_read ) kiocb -> ki_retry = aio_rw_vect_retry ; break ; case IOCB_CMD_PWRITEV : ret = - EBADF ; if ( unlikely ( ! ( file -> f_mode & FMODE_WRITE ) ) ) break ; <S2SV_StartBug> ret = security_file_permission ( file , MAY_WRITE ) ; <S2SV_EndBug> if ( unlikely ( ret ) ) break ; ret = aio_setup_vectored_rw ( WRITE , kiocb , compat ) ; if ( ret ) break ; ret = - EINVAL ; if ( file -> f_op -> aio_write ) kiocb -> ki_retry = aio_rw_vect_retry ; break ; case IOCB_CMD_FDSYNC : ret = - EINVAL ; if ( file -> f_op -> aio_fsync ) kiocb -> ki_retry = aio_fdsync ; break ; case IOCB_CMD_FSYNC : ret = - EINVAL ; if ( file -> f_op -> aio_fsync ) kiocb -> ki_retry = aio_fsync ; break ; default : dprintk ( "EINVAL:<S2SV_blank>io_submit:<S2SV_blank>no<S2SV_blank>operation<S2SV_blank>provided\\n" ) ; ret = - EINVAL ; } if ( ! kiocb -> ki_retry ) return ret ; return 0 ; }
static char * get_header ( FILE * fp ) { <S2SV_StartBug> long start ; <S2SV_EndBug> <S2SV_StartBug> char * header ; <S2SV_EndBug> header = calloc ( 1 , 1024 ) ; <S2SV_StartBug> start = ftell ( fp ) ; <S2SV_EndBug> fseek ( fp , 0 , SEEK_SET ) ; SAFE_E ( fread ( header , 1 , 1023 , fp ) , 1023 , "Failed<S2SV_blank>to<S2SV_blank>load<S2SV_blank>PDF<S2SV_blank>header.\\n" ) ; fseek ( fp , start , SEEK_SET ) ; return header ; }
void bnep_net_setup ( struct net_device * dev ) { memset ( dev -> broadcast , 0xff , ETH_ALEN ) ; dev -> addr_len = ETH_ALEN ; ether_setup ( dev ) ; <S2SV_StartBug> dev -> netdev_ops = & bnep_netdev_ops ; <S2SV_EndBug> dev -> watchdog_timeo = HZ * 2 ; }
static int install_process_keyring ( void ) { struct cred * new ; int ret ; new = prepare_creds ( ) ; if ( ! new ) return - ENOMEM ; ret = install_process_keyring_to_cred ( new ) ; if ( ret < 0 ) { abort_creds ( new ) ; <S2SV_StartBug> return ret != - EEXIST ? ret : 0 ; <S2SV_EndBug> } return commit_creds ( new ) ; }
void bpf_int_jit_compile ( struct bpf_prog * prog ) { struct bpf_binary_header * header = NULL ; int proglen , oldproglen = 0 ; struct jit_context ctx = { } ; u8 * image = NULL ; int * addrs ; int pass ; int i ; if ( ! bpf_jit_enable ) return ; if ( ! prog || ! prog -> len ) return ; addrs = kmalloc ( prog -> len * sizeof ( * addrs ) , GFP_KERNEL ) ; if ( ! addrs ) return ; for ( proglen = 0 , i = 0 ; i < prog -> len ; i ++ ) { proglen += 64 ; addrs [ i ] = proglen ; } ctx . cleanup_addr = proglen ; <S2SV_StartBug> for ( pass = 0 ; pass < 10 ; pass ++ ) { <S2SV_EndBug> proglen = do_jit ( prog , addrs , image , oldproglen , & ctx ) ; if ( proglen <= 0 ) { image = NULL ; if ( header ) bpf_jit_binary_free ( header ) ; goto out ; } if ( image ) { if ( proglen != oldproglen ) { pr_err ( "bpf_jit:<S2SV_blank>proglen=%d<S2SV_blank>!=<S2SV_blank>oldproglen=%d\\n" , proglen , oldproglen ) ; goto out ; } break ; } if ( proglen == oldproglen ) { header = bpf_jit_binary_alloc ( proglen , & image , 1 , jit_fill_hole ) ; if ( ! header ) goto out ; } oldproglen = proglen ; } if ( bpf_jit_enable > 1 ) bpf_jit_dump ( prog -> len , proglen , 0 , image ) ; if ( image ) { bpf_flush_icache ( header , image + proglen ) ; set_memory_ro ( ( unsigned long ) header , header -> pages ) ; prog -> bpf_func = ( void * ) image ; prog -> jited = true ; } out : kfree ( addrs ) ; }
static int64_t http_seek_internal ( URLContext * h , int64_t off , int whence , int force_reconnect ) { HTTPContext * s = h -> priv_data ; URLContext * old_hd = s -> hd ; <S2SV_StartBug> int64_t old_off = s -> off ; <S2SV_EndBug> uint8_t old_buf [ BUFFER_SIZE ] ; int old_buf_size , ret ; AVDictionary * options = NULL ; if ( whence == AVSEEK_SIZE ) return s -> filesize ; else if ( ! force_reconnect && ( ( whence == SEEK_CUR && off == 0 ) || ( whence == SEEK_SET && off == s -> off ) ) ) return s -> off ; <S2SV_StartBug> else if ( ( s -> filesize == - 1 && whence == SEEK_END ) ) <S2SV_EndBug> return AVERROR ( ENOSYS ) ; if ( whence == SEEK_CUR ) off += s -> off ; else if ( whence == SEEK_END ) off += s -> filesize ; else if ( whence != SEEK_SET ) return AVERROR ( EINVAL ) ; if ( off < 0 ) return AVERROR ( EINVAL ) ; s -> off = off ; if ( s -> off && h -> is_streamed ) return AVERROR ( ENOSYS ) ; old_buf_size = s -> buf_end - s -> buf_ptr ; memcpy ( old_buf , s -> buf_ptr , old_buf_size ) ; s -> hd = NULL ; if ( ( ret = http_open_cnx ( h , & options ) ) < 0 ) { av_dict_free ( & options ) ; memcpy ( s -> buffer , old_buf , old_buf_size ) ; s -> buf_ptr = s -> buffer ; s -> buf_end = s -> buffer + old_buf_size ; s -> hd = old_hd ; s -> off = old_off ; return ret ; } av_dict_free ( & options ) ; ffurl_close ( old_hd ) ; return off ; }
void vp8_rtcd ( ) { <S2SV_StartBug> vpx_scale_rtcd ( ) ; <S2SV_EndBug> once ( setup_rtcd_internal ) ; }
int TS_OBJ_print_bio ( BIO * bio , const ASN1_OBJECT * obj ) { char obj_txt [ 128 ] ; <S2SV_StartBug> int len = OBJ_obj2txt ( obj_txt , sizeof ( obj_txt ) , obj , 0 ) ; <S2SV_EndBug> <S2SV_StartBug> BIO_write ( bio , obj_txt , len ) ; <S2SV_EndBug> BIO_write ( bio , "\\n" , 1 ) ; return 1 ; }
char * _multi_string_alloc_and_copy ( LPCWSTR in ) { char * chr ; int len = 0 ; if ( ! in ) { <S2SV_StartBug> return in ; <S2SV_EndBug> } while ( in [ len ] != 0 || in [ len + 1 ] != 0 ) { len ++ ; } chr = malloc ( len + 2 ) ; len = 0 ; while ( in [ len ] != 0 || in [ len + 1 ] != 0 ) { chr [ len ] = 0xFF & in [ len ] ; len ++ ; } chr [ len ++ ] = '\\0' ; chr [ len ++ ] = '\\0' ; return chr ; }
int perf_event_task_disable ( void ) <S2SV_StartBug> { <S2SV_EndBug> struct perf_event * event ; mutex_lock ( & current -> perf_event_mutex ) ; <S2SV_StartBug> list_for_each_entry ( event , & current -> perf_event_list , owner_entry ) <S2SV_EndBug> <S2SV_StartBug> perf_event_for_each_child ( event , perf_event_disable ) ; <S2SV_EndBug> mutex_unlock ( & current -> perf_event_mutex ) ; return 0 ; }
static bool check_underflow ( const struct ip6t_entry * e ) { const struct xt_entry_target * t ; unsigned int verdict ; <S2SV_StartBug> if ( ! unconditional ( & e -> ipv6 ) ) <S2SV_EndBug> return false ; t = ip6t_get_target_c ( e ) ; if ( strcmp ( t -> u . user . name , XT_STANDARD_TARGET ) != 0 ) return false ; verdict = ( ( struct xt_standard_target * ) t ) -> verdict ; verdict = - verdict - 1 ; return verdict == NF_DROP || verdict == NF_ACCEPT ; }
static krb5_error_code kdc_process_s4u_x509_user ( krb5_context context , krb5_kdc_req * request , krb5_pa_data * pa_data , krb5_keyblock * tgs_subkey , krb5_keyblock * tgs_session , krb5_pa_s4u_x509_user * * s4u_x509_user , const char * * status ) { krb5_error_code code ; krb5_data req_data ; req_data . length = pa_data -> length ; req_data . data = ( char * ) pa_data -> contents ; code = decode_krb5_pa_s4u_x509_user ( & req_data , s4u_x509_user ) ; if ( code ) <S2SV_StartBug> return code ; <S2SV_EndBug> code = verify_s4u_x509_user_checksum ( context , tgs_subkey ? tgs_subkey : tgs_session , & req_data , request -> nonce , * s4u_x509_user ) ; if ( code ) { * status = "INVALID_S4U2SELF_CHECKSUM" ; krb5_free_pa_s4u_x509_user ( context , * s4u_x509_user ) ; * s4u_x509_user = NULL ; return code ; } if ( krb5_princ_size ( context , ( * s4u_x509_user ) -> user_id . user ) == 0 || ( * s4u_x509_user ) -> user_id . subject_cert . length != 0 ) { * status = "INVALID_S4U2SELF_REQUEST" ; krb5_free_pa_s4u_x509_user ( context , * s4u_x509_user ) ; * s4u_x509_user = NULL ; return KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN ; } return 0 ; }
arg_ty <S2SV_StartBug> arg ( identifier arg , expr_ty annotation , int lineno , int col_offset , int <S2SV_EndBug> end_lineno , int end_col_offset , PyArena * arena ) { arg_ty p ; if ( ! arg ) { PyErr_SetString ( PyExc_ValueError , "field<S2SV_blank>arg<S2SV_blank>is<S2SV_blank>required<S2SV_blank>for<S2SV_blank>arg" ) ; return NULL ; } p = ( arg_ty ) PyArena_Malloc ( arena , sizeof ( * p ) ) ; if ( ! p ) return NULL ; p -> arg = arg ; p -> annotation = annotation ; <S2SV_StartBug> p -> lineno = lineno ; <S2SV_EndBug> p -> col_offset = col_offset ; p -> end_lineno = end_lineno ; p -> end_col_offset = end_col_offset ; return p ; }
u_int ieee802_15_4_if_print ( netdissect_options * ndo , const struct pcap_pkthdr * h , const u_char * p ) { u_int caplen = h -> caplen ; <S2SV_StartBug> int hdrlen ; <S2SV_EndBug> uint16_t fc ; uint8_t seq ; <S2SV_StartBug> if ( caplen < 3 ) { <S2SV_EndBug> ND_PRINT ( ( ndo , "[|802.15.4]<S2SV_blank>%x" , caplen ) ) ; return caplen ; } fc = EXTRACT_LE_16BITS ( p ) ; hdrlen = extract_header_length ( fc ) ; seq = EXTRACT_LE_8BITS ( p + 2 ) ; p += 3 ; caplen -= 3 ; ND_PRINT ( ( ndo , "IEEE<S2SV_blank>802.15.4<S2SV_blank>%s<S2SV_blank>packet<S2SV_blank>" , ftypes [ fc & 0x7 ] ) ) ; if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "seq<S2SV_blank>%02x<S2SV_blank>" , seq ) ) ; if ( hdrlen == - 1 ) { ND_PRINT ( ( ndo , "invalid!<S2SV_blank>" ) ) ; return caplen ; } if ( ! ndo -> ndo_vflag ) { p += hdrlen ; caplen -= hdrlen ; } else { uint16_t panid = 0 ; <S2SV_StartBug> switch ( ( fc >> 10 ) & 0x3 ) { <S2SV_EndBug> case 0x00 : ND_PRINT ( ( ndo , "none<S2SV_blank>" ) ) ; break ; case 0x01 : ND_PRINT ( ( ndo , "reserved<S2SV_blank>destination<S2SV_blank>addressing<S2SV_blank>mode" ) ) ; return 0 ; case 0x02 : panid = EXTRACT_LE_16BITS ( p ) ; p += 2 ; <S2SV_StartBug> ND_PRINT ( ( ndo , "%04x:%04x<S2SV_blank>" , panid , EXTRACT_LE_16BITS ( p ) ) ) ; <S2SV_EndBug> p += 2 ; break ; <S2SV_StartBug> case 0x03 : <S2SV_EndBug> panid = EXTRACT_LE_16BITS ( p ) ; p += 2 ; <S2SV_StartBug> ND_PRINT ( ( ndo , "%04x:%s<S2SV_blank>" , panid , le64addr_string ( ndo , p ) ) ) ; <S2SV_EndBug> p += 8 ; <S2SV_StartBug> break ; <S2SV_EndBug> } <S2SV_StartBug> ND_PRINT ( ( ndo , "<<S2SV_blank>" ) ) ; <S2SV_EndBug> <S2SV_StartBug> switch ( ( fc >> 14 ) & 0x3 ) { <S2SV_EndBug> <S2SV_StartBug> case 0x00 : <S2SV_EndBug> ND_PRINT ( ( ndo , "none<S2SV_blank>" ) ) ; break ; <S2SV_StartBug> case 0x01 : <S2SV_EndBug> ND_PRINT ( ( ndo , "reserved<S2SV_blank>source<S2SV_blank>addressing<S2SV_blank>mode" ) ) ; return 0 ; <S2SV_StartBug> case 0x02 : <S2SV_EndBug> <S2SV_StartBug> if ( ! ( fc & ( 1 << 6 ) ) ) { <S2SV_EndBug> panid = EXTRACT_LE_16BITS ( p ) ; p += 2 ; <S2SV_StartBug> } <S2SV_EndBug> ND_PRINT ( ( ndo , "%04x:%04x<S2SV_blank>" , panid , EXTRACT_LE_16BITS ( p ) ) ) ; p += 2 ; <S2SV_StartBug> break ; <S2SV_EndBug> <S2SV_StartBug> case 0x03 : <S2SV_EndBug> <S2SV_StartBug> if ( ! ( fc & ( 1 << 6 ) ) ) { <S2SV_EndBug> panid = EXTRACT_LE_16BITS ( p ) ; p += 2 ; <S2SV_StartBug> } <S2SV_EndBug> ND_PRINT ( ( ndo , "%04x:%s<S2SV_blank>" , panid , le64addr_string ( ndo , p ) ) ) ; p += 8 ; <S2SV_StartBug> break ; <S2SV_EndBug> } <S2SV_StartBug> caplen -= hdrlen ; <S2SV_EndBug> } if ( ! ndo -> ndo_suppress_default_print ) ND_DEFAULTPRINT ( p , caplen ) ; <S2SV_StartBug> return 0 ; <S2SV_EndBug> }
static void <S2SV_StartBug> l2tp_framing_type_print ( netdissect_options * ndo , const u_char * dat ) <S2SV_EndBug> { <S2SV_StartBug> const uint32_t * ptr = ( const uint32_t * ) dat ; <S2SV_EndBug> if ( EXTRACT_32BITS ( ptr ) & L2TP_FRAMING_TYPE_ASYNC_MASK ) { ND_PRINT ( ( ndo , "A" ) ) ; } if ( EXTRACT_32BITS ( ptr ) & L2TP_FRAMING_TYPE_SYNC_MASK ) { ND_PRINT ( ( ndo , "S" ) ) ; } }
void vp8cx_pick_filter_level ( YV12_BUFFER_CONFIG * sd , VP8_COMP * cpi ) { VP8_COMMON * cm = & cpi -> common ; int best_err = 0 ; int filt_err = 0 ; int min_filter_level = get_min_filter_level ( cpi , cm -> base_qindex ) ; int max_filter_level = get_max_filter_level ( cpi , cm -> base_qindex ) ; int filter_step ; int filt_high = 0 ; <S2SV_StartBug> int filt_mid = cm -> filter_level ; <S2SV_EndBug> int filt_low = 0 ; int filt_best ; int filt_direction = 0 ; int Bias = 0 ; int ss_err [ MAX_LOOP_FILTER + 1 ] ; YV12_BUFFER_CONFIG * saved_frame = cm -> frame_to_show ; <S2SV_StartBug> vpx_memset ( ss_err , 0 , sizeof ( ss_err ) ) ; <S2SV_EndBug> cm -> frame_to_show = & cpi -> pick_lf_lvl_frame ; if ( cm -> frame_type == KEY_FRAME ) cm -> sharpness_level = 0 ; else cm -> sharpness_level = cpi -> oxcf . Sharpness ; filt_mid = cm -> filter_level ; if ( filt_mid < min_filter_level ) filt_mid = min_filter_level ; else if ( filt_mid > max_filter_level ) filt_mid = max_filter_level ; filter_step = ( filt_mid < 16 ) ? 4 : filt_mid / 4 ; vpx_yv12_copy_y ( saved_frame , cm -> frame_to_show ) ; vp8cx_set_alt_lf_level ( cpi , filt_mid ) ; vp8_loop_filter_frame_yonly ( cm , & cpi -> mb . e_mbd , filt_mid ) ; best_err = vp8_calc_ss_err ( sd , cm -> frame_to_show ) ; ss_err [ filt_mid ] = best_err ; filt_best = filt_mid ; while ( filter_step > 0 ) { Bias = ( best_err >> ( 15 - ( filt_mid / 8 ) ) ) * filter_step ; if ( cpi -> twopass . section_intra_rating < 20 ) Bias = Bias * cpi -> twopass . section_intra_rating / 20 ; filt_high = ( ( filt_mid + filter_step ) > max_filter_level ) ? max_filter_level : ( filt_mid + filter_step ) ; filt_low = ( ( filt_mid - filter_step ) < min_filter_level ) ? min_filter_level : ( filt_mid - filter_step ) ; if ( ( filt_direction <= 0 ) && ( filt_low != filt_mid ) ) { if ( ss_err [ filt_low ] == 0 ) { vpx_yv12_copy_y ( saved_frame , cm -> frame_to_show ) ; vp8cx_set_alt_lf_level ( cpi , filt_low ) ; vp8_loop_filter_frame_yonly ( cm , & cpi -> mb . e_mbd , filt_low ) ; filt_err = vp8_calc_ss_err ( sd , cm -> frame_to_show ) ; ss_err [ filt_low ] = filt_err ; } else filt_err = ss_err [ filt_low ] ; if ( ( filt_err - Bias ) < best_err ) { if ( filt_err < best_err ) best_err = filt_err ; filt_best = filt_low ; } } if ( ( filt_direction >= 0 ) && ( filt_high != filt_mid ) ) { if ( ss_err [ filt_high ] == 0 ) { vpx_yv12_copy_y ( saved_frame , cm -> frame_to_show ) ; vp8cx_set_alt_lf_level ( cpi , filt_high ) ; vp8_loop_filter_frame_yonly ( cm , & cpi -> mb . e_mbd , filt_high ) ; filt_err = vp8_calc_ss_err ( sd , cm -> frame_to_show ) ; ss_err [ filt_high ] = filt_err ; } else filt_err = ss_err [ filt_high ] ; if ( filt_err < ( best_err - Bias ) ) { best_err = filt_err ; filt_best = filt_high ; } } if ( filt_best == filt_mid ) { filter_step = filter_step / 2 ; filt_direction = 0 ; } else { filt_direction = ( filt_best < filt_mid ) ? - 1 : 1 ; filt_mid = filt_best ; } } cm -> filter_level = filt_best ; cm -> frame_to_show = saved_frame ; }
static int crypto_report_cipher ( struct sk_buff * skb , struct crypto_alg * alg ) { struct crypto_report_cipher rcipher ; <S2SV_StartBug> strlcpy ( rcipher . type , "cipher" , sizeof ( rcipher . type ) ) ; <S2SV_EndBug> rcipher . blocksize = alg -> cra_blocksize ; rcipher . min_keysize = alg -> cra_cipher . cia_min_keysize ; rcipher . max_keysize = alg -> cra_cipher . cia_max_keysize ; if ( nla_put ( skb , CRYPTOCFGA_REPORT_CIPHER , sizeof ( struct crypto_report_cipher ) , & rcipher ) ) goto nla_put_failure ; return 0 ; nla_put_failure : return - EMSGSIZE ; }
static void unset_active_map ( const vpx_codec_enc_cfg_t * cfg , vpx_codec_ctx_t * codec ) { <S2SV_StartBug> vpx_active_map_t map = { 0 } ; <S2SV_EndBug> map . rows = ( cfg -> g_h + 15 ) / 16 ; map . cols = ( cfg -> g_w + 15 ) / 16 ; map . active_map = NULL ; if ( vpx_codec_control ( codec , VP8E_SET_ACTIVEMAP , & map ) ) die_codec ( codec , "Failed<S2SV_blank>to<S2SV_blank>set<S2SV_blank>active<S2SV_blank>map" ) ; }
static int nghttp2_session_upgrade_internal ( nghttp2_session * session , const uint8_t * settings_payload , size_t settings_payloadlen , void * stream_user_data ) { nghttp2_stream * stream ; nghttp2_frame frame ; nghttp2_settings_entry * iv ; size_t niv ; int rv ; nghttp2_priority_spec pri_spec ; nghttp2_mem * mem ; mem = & session -> mem ; if ( ( ! session -> server && session -> next_stream_id != 1 ) || ( session -> server && session -> last_recv_stream_id >= 1 ) ) { return NGHTTP2_ERR_PROTO ; } if ( settings_payloadlen % NGHTTP2_FRAME_SETTINGS_ENTRY_LENGTH ) { <S2SV_StartBug> return NGHTTP2_ERR_INVALID_ARGUMENT ; <S2SV_EndBug> } rv = nghttp2_frame_unpack_settings_payload2 ( & iv , & niv , settings_payload , settings_payloadlen , mem ) ; if ( rv != 0 ) { return rv ; } if ( session -> server ) { nghttp2_frame_hd_init ( & frame . hd , settings_payloadlen , NGHTTP2_SETTINGS , NGHTTP2_FLAG_NONE , 0 ) ; frame . settings . iv = iv ; frame . settings . niv = niv ; rv = nghttp2_session_on_settings_received ( session , & frame , 1 ) ; } else { rv = nghttp2_submit_settings ( session , NGHTTP2_FLAG_NONE , iv , niv ) ; } nghttp2_mem_free ( mem , iv ) ; if ( rv != 0 ) { return rv ; } nghttp2_priority_spec_default_init ( & pri_spec ) ; stream = nghttp2_session_open_stream ( session , 1 , NGHTTP2_STREAM_FLAG_NONE , & pri_spec , NGHTTP2_STREAM_OPENING , session -> server ? NULL : stream_user_data ) ; if ( stream == NULL ) { return NGHTTP2_ERR_NOMEM ; } if ( session -> server ) { nghttp2_stream_shutdown ( stream , NGHTTP2_SHUT_RD ) ; session -> last_recv_stream_id = 1 ; session -> last_proc_stream_id = 1 ; } else { nghttp2_stream_shutdown ( stream , NGHTTP2_SHUT_WR ) ; session -> last_sent_stream_id = 1 ; session -> next_stream_id += 2 ; } return 0 ; }
void update_rate_histogram ( struct rate_hist * hist , const vpx_codec_enc_cfg_t * cfg , const vpx_codec_cx_pkt_t * pkt ) { int i ; int64_t then = 0 ; int64_t avg_bitrate = 0 ; int64_t sum_sz = 0 ; const int64_t now = pkt -> data . frame . pts * 1000 * ( uint64_t ) cfg -> g_timebase . num / ( uint64_t ) cfg -> g_timebase . den ; int idx = hist -> frames ++ % hist -> samples ; hist -> pts [ idx ] = now ; hist -> sz [ idx ] = ( int ) pkt -> data . frame . sz ; if ( now < cfg -> rc_buf_initial_sz ) return ; <S2SV_StartBug> then = now ; <S2SV_EndBug> for ( i = hist -> frames ; i > 0 && hist -> frames - i < hist -> samples ; i -- ) { const int i_idx = ( i - 1 ) % hist -> samples ; then = hist -> pts [ i_idx ] ; if ( now - then > cfg -> rc_buf_sz ) break ; sum_sz += hist -> sz [ i_idx ] ; } if ( now == then ) return ; avg_bitrate = sum_sz * 8 * 1000 / ( now - then ) ; idx = ( int ) ( avg_bitrate * ( RATE_BINS / 2 ) / ( cfg -> rc_target_bitrate * 1000 ) ) ; if ( idx < 0 ) idx = 0 ; if ( idx > RATE_BINS - 1 ) idx = RATE_BINS - 1 ; if ( hist -> bucket [ idx ] . low > avg_bitrate ) hist -> bucket [ idx ] . low = ( int ) avg_bitrate ; if ( hist -> bucket [ idx ] . high < avg_bitrate ) hist -> bucket [ idx ] . high = ( int ) avg_bitrate ; hist -> bucket [ idx ] . count ++ ; hist -> total ++ ; }
int mlx4_register_vlan ( struct mlx4_dev * dev , u8 port , u16 vlan , int * index ) { struct mlx4_vlan_table * table = & mlx4_priv ( dev ) -> port [ port ] . vlan_table ; int i , err = 0 ; int free = - 1 ; mutex_lock ( & table -> mutex ) ; for ( i = MLX4_VLAN_REGULAR ; i < MLX4_MAX_VLAN_NUM ; i ++ ) { if ( free < 0 && ( table -> refs [ i ] == 0 ) ) { free = i ; continue ; } if ( table -> refs [ i ] && ( vlan == ( MLX4_VLAN_MASK & be32_to_cpu ( table -> entries [ i ] ) ) ) ) { * index = i ; ++ table -> refs [ i ] ; goto out ; <S2SV_StartBug> } <S2SV_EndBug> } if ( table -> total == table -> max ) { err = - ENOSPC ; goto out ; } table -> refs [ free ] = 1 ; table -> entries [ free ] = cpu_to_be32 ( vlan | MLX4_VLAN_VALID ) ; err = mlx4_set_port_vlan_table ( dev , port , table -> entries ) ; if ( unlikely ( err ) ) { mlx4_warn ( dev , "Failed<S2SV_blank>adding<S2SV_blank>vlan:<S2SV_blank>%u\\n" , vlan ) ; table -> refs [ free ] = 0 ; table -> entries [ free ] = 0 ; goto out ; } * index = free ; ++ table -> total ; out : mutex_unlock ( & table -> mutex ) ; return err ; }
static int check_entry_size_and_hooks ( struct ipt_entry * e , struct xt_table_info * newinfo , const unsigned char * base , const unsigned char * limit , const unsigned int * hook_entries , const unsigned int * underflows , unsigned int valid_hooks ) { unsigned int h ; int err ; if ( ( unsigned long ) e % __alignof__ ( struct ipt_entry ) != 0 || <S2SV_StartBug> ( unsigned char * ) e + sizeof ( struct ipt_entry ) >= limit ) { <S2SV_EndBug> duprintf ( "Bad<S2SV_blank>offset<S2SV_blank>%p\\n" , e ) ; return - EINVAL ; } if ( e -> next_offset < sizeof ( struct ipt_entry ) + sizeof ( struct xt_entry_target ) ) { duprintf ( "checking:<S2SV_blank>element<S2SV_blank>%p<S2SV_blank>size<S2SV_blank>%u\\n" , e , e -> next_offset ) ; return - EINVAL ; } err = check_entry ( e ) ; if ( err ) return err ; for ( h = 0 ; h < NF_INET_NUMHOOKS ; h ++ ) { if ( ! ( valid_hooks & ( 1 << h ) ) ) continue ; if ( ( unsigned char * ) e - base == hook_entries [ h ] ) newinfo -> hook_entry [ h ] = hook_entries [ h ] ; if ( ( unsigned char * ) e - base == underflows [ h ] ) { if ( ! check_underflow ( e ) ) { pr_err ( "Underflows<S2SV_blank>must<S2SV_blank>be<S2SV_blank>unconditional<S2SV_blank>and<S2SV_blank>" "use<S2SV_blank>the<S2SV_blank>STANDARD<S2SV_blank>target<S2SV_blank>with<S2SV_blank>" "ACCEPT/DROP\\n" ) ; return - EINVAL ; } newinfo -> underflow [ h ] = underflows [ h ] ; } } e -> counters = ( ( struct xt_counters ) { 0 , 0 } ) ; e -> comefrom = 0 ; return 0 ; }
int fpm_unix_resolve_socket_premissions ( struct fpm_worker_pool_s * wp ) { struct fpm_worker_pool_config_s * c = wp -> config ; wp -> socket_uid = - 1 ; wp -> socket_gid = - 1 ; <S2SV_StartBug> wp -> socket_mode = 0666 ; <S2SV_EndBug> if ( ! c ) { return 0 ; } if ( c -> listen_owner && * c -> listen_owner ) { struct passwd * pwd ; pwd = getpwnam ( c -> listen_owner ) ; if ( ! pwd ) { zlog ( ZLOG_SYSERROR , "[pool<S2SV_blank>%s]<S2SV_blank>cannot<S2SV_blank>get<S2SV_blank>uid<S2SV_blank>for<S2SV_blank>user<S2SV_blank>\'%s\'" , wp -> config -> name , c -> listen_owner ) ; return - 1 ; } wp -> socket_uid = pwd -> pw_uid ; wp -> socket_gid = pwd -> pw_gid ; } if ( c -> listen_group && * c -> listen_group ) { struct group * grp ; grp = getgrnam ( c -> listen_group ) ; if ( ! grp ) { zlog ( ZLOG_SYSERROR , "[pool<S2SV_blank>%s]<S2SV_blank>cannot<S2SV_blank>get<S2SV_blank>gid<S2SV_blank>for<S2SV_blank>group<S2SV_blank>\'%s\'" , wp -> config -> name , c -> listen_group ) ; return - 1 ; } wp -> socket_gid = grp -> gr_gid ; } if ( c -> listen_mode && * c -> listen_mode ) { wp -> socket_mode = strtoul ( c -> listen_mode , 0 , 8 ) ; } return 0 ; }
void jslTokenAsString ( int token , char * str , size_t len ) { if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { case LEX_EOF : strncpy ( str , "EOF" , len ) ; return ; case LEX_ID : strncpy ( str , "ID" , len ) ; return ; case LEX_INT : strncpy ( str , "INT" , len ) ; return ; case LEX_FLOAT : strncpy ( str , "FLOAT" , len ) ; return ; case LEX_STR : strncpy ( str , "STRING" , len ) ; return ; case LEX_UNFINISHED_STR : strncpy ( str , "UNFINISHED<S2SV_blank>STRING" , len ) ; return ; case LEX_TEMPLATE_LITERAL : strncpy ( str , "TEMPLATE<S2SV_blank>LITERAL" , len ) ; return ; case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , "UNFINISHED<S2SV_blank>TEMPLATE<S2SV_blank>LITERAL" , len ) ; return ; case LEX_REGEX : strncpy ( str , "REGEX" , len ) ; return ; case LEX_UNFINISHED_REGEX : strncpy ( str , "UNFINISHED<S2SV_blank>REGEX" , len ) ; return ; case LEX_UNFINISHED_COMMENT : strncpy ( str , "UNFINISHED<S2SV_blank>COMMENT" , len ) ; return ; } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = "==\\0" "===\\0" "!=\\0" "!==\\0" "<=\\0" "<<\\0" "<<=\\0" ">=\\0" ">>\\0" ">>>\\0" ">>=\\0" ">>>=\\0" "+=\\0" "-=\\0" "++\\0" "--\\0" "*=\\0" "/=\\0" "%=\\0" "&=\\0" "&&\\0" "|=\\0" "||\\0" "^=\\0" "=>\\0" "if\\0" "else\\0" "do\\0" "while\\0" "for\\0" "return\\0" "continue\\0" "function\\0" "return\\0" "var\\0" "let\\0" "const\\0" "this\\0" "throw\\0" "try\\0" "catch\\0" "finally\\0" "true\\0" "false\\0" "null\\0" "undefined\\0" "new\\0" "in\\0" "instanceof\\0" "switch\\0" "case\\0" "default\\0" "delete\\0" "typeof\\0" "void\\0" "debugger\\0" "class\\0" "extends\\0" "super\\0" "static\\0" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; strncpy ( str , & tokenNames [ p ] , len ) ; return ; } assert ( len >= 10 ) ; <S2SV_StartBug> strncpy ( str , "?[" , len ) ; <S2SV_EndBug> itostr ( token , & str [ 2 ] , 10 ) ; strncat ( str , "]" , len ) ; }
void rds_inc_info_copy ( struct rds_incoming * inc , struct rds_info_iterator * iter , __be32 saddr , __be32 daddr , int flip ) { struct rds_info_message minfo ; minfo . seq = be64_to_cpu ( inc -> i_hdr . h_sequence ) ; minfo . len = be32_to_cpu ( inc -> i_hdr . h_len ) ; if ( flip ) { minfo . laddr = daddr ; minfo . faddr = saddr ; minfo . lport = inc -> i_hdr . h_dport ; minfo . fport = inc -> i_hdr . h_sport ; } else { minfo . laddr = saddr ; minfo . faddr = daddr ; minfo . lport = inc -> i_hdr . h_sport ; minfo . fport = inc -> i_hdr . h_dport ; } <S2SV_StartBug> rds_info_copy ( iter , & minfo , sizeof ( minfo ) ) ; <S2SV_EndBug> }
static int rose_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t size , int flags ) { struct sock * sk = sock -> sk ; struct rose_sock * rose = rose_sk ( sk ) ; struct sockaddr_rose * srose = ( struct sockaddr_rose * ) msg -> msg_name ; size_t copied ; unsigned char * asmptr ; struct sk_buff * skb ; int n , er , qbit ; if ( sk -> sk_state != TCP_ESTABLISHED ) return - ENOTCONN ; if ( ( skb = skb_recv_datagram ( sk , flags & ~ MSG_DONTWAIT , flags & MSG_DONTWAIT , & er ) ) == NULL ) return er ; qbit = ( skb -> data [ 0 ] & ROSE_Q_BIT ) == ROSE_Q_BIT ; skb_pull ( skb , ROSE_MIN_LEN ) ; if ( rose -> qbitincl ) { asmptr = skb_push ( skb , 1 ) ; * asmptr = qbit ; } skb_reset_transport_header ( skb ) ; copied = skb -> len ; if ( copied > size ) { copied = size ; msg -> msg_flags |= MSG_TRUNC ; } skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; if ( srose != NULL ) { <S2SV_StartBug> srose -> srose_family = AF_ROSE ; <S2SV_EndBug> srose -> srose_addr = rose -> dest_addr ; srose -> srose_call = rose -> dest_call ; srose -> srose_ndigis = rose -> dest_ndigis ; if ( msg -> msg_namelen >= sizeof ( struct full_sockaddr_rose ) ) { struct full_sockaddr_rose * full_srose = ( struct full_sockaddr_rose * ) msg -> msg_name ; for ( n = 0 ; n < rose -> dest_ndigis ; n ++ ) full_srose -> srose_digis [ n ] = rose -> dest_digis [ n ] ; msg -> msg_namelen = sizeof ( struct full_sockaddr_rose ) ; } else { if ( rose -> dest_ndigis >= 1 ) { srose -> srose_ndigis = 1 ; srose -> srose_digi = rose -> dest_digis [ 0 ] ; } msg -> msg_namelen = sizeof ( struct sockaddr_rose ) ; } } skb_free_datagram ( sk , skb ) ; return copied ; }
static int wb_id ( netdissect_options * ndo , const struct pkt_id * id , u_int len ) { int i ; const char * cp ; const struct id_off * io ; char c ; int nid ; ND_PRINT ( ( ndo , "<S2SV_blank>wb-id:" ) ) ; if ( len < sizeof ( * id ) || ! ND_TTEST ( * id ) ) return ( - 1 ) ; len -= sizeof ( * id ) ; ND_PRINT ( ( ndo , "<S2SV_blank>%u/%s:%u<S2SV_blank>(max<S2SV_blank>%u/%s:%u)<S2SV_blank>" , EXTRACT_32BITS ( & id -> pi_ps . slot ) , ipaddr_string ( ndo , & id -> pi_ps . page . p_sid ) , EXTRACT_32BITS ( & id -> pi_ps . page . p_uid ) , EXTRACT_32BITS ( & id -> pi_mslot ) , ipaddr_string ( ndo , & id -> pi_mpage . p_sid ) , EXTRACT_32BITS ( & id -> pi_mpage . p_uid ) ) ) ; nid = EXTRACT_16BITS ( & id -> pi_ps . nid ) ; len -= sizeof ( * io ) * nid ; io = ( struct id_off * ) ( id + 1 ) ; cp = ( char * ) ( io + nid ) ; <S2SV_StartBug> if ( ! ND_TTEST2 ( cp , len ) ) { <S2SV_EndBug> ND_PRINT ( ( ndo , "\\"" ) ) ; fn_print ( ndo , ( u_char * ) cp , ( u_char * ) cp + len ) ; ND_PRINT ( ( ndo , "\\"" ) ) ; } c = '<' ; for ( i = 0 ; i < nid && ND_TTEST ( * io ) ; ++ io , ++ i ) { ND_PRINT ( ( ndo , "%c%s:%u" , c , ipaddr_string ( ndo , & io -> id ) , EXTRACT_32BITS ( & io -> off ) ) ) ; c = ',' ; } if ( i >= nid ) { ND_PRINT ( ( ndo , ">" ) ) ; return ( 0 ) ; } return ( - 1 ) ; }
static int llcp_sock_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { int noblock = flags & MSG_DONTWAIT ; struct sock * sk = sock -> sk ; unsigned int copied , rlen ; struct sk_buff * skb , * cskb ; int err = 0 ; pr_debug ( "%p<S2SV_blank>%zu\\n" , sk , len ) ; <S2SV_StartBug> msg -> msg_namelen = 0 ; <S2SV_EndBug> lock_sock ( sk ) ; if ( sk -> sk_state == LLCP_CLOSED && skb_queue_empty ( & sk -> sk_receive_queue ) ) { release_sock ( sk ) ; return 0 ; } release_sock ( sk ) ; if ( flags & ( MSG_OOB ) ) return - EOPNOTSUPP ; skb = skb_recv_datagram ( sk , flags , noblock , & err ) ; if ( ! skb ) { pr_err ( "Recv<S2SV_blank>datagram<S2SV_blank>failed<S2SV_blank>state<S2SV_blank>%d<S2SV_blank>%d<S2SV_blank>%d" , sk -> sk_state , err , sock_error ( sk ) ) ; if ( sk -> sk_shutdown & RCV_SHUTDOWN ) return 0 ; return err ; } rlen = skb -> len ; copied = min_t ( unsigned int , rlen , len ) ; cskb = skb ; if ( skb_copy_datagram_iovec ( cskb , 0 , msg -> msg_iov , copied ) ) { if ( ! ( flags & MSG_PEEK ) ) skb_queue_head ( & sk -> sk_receive_queue , skb ) ; return - EFAULT ; } sock_recv_timestamp ( msg , sk , skb ) ; if ( sk -> sk_type == SOCK_DGRAM && msg -> msg_name ) { struct nfc_llcp_ui_cb * ui_cb = nfc_llcp_ui_skb_cb ( skb ) ; struct sockaddr_nfc_llcp * sockaddr = ( struct sockaddr_nfc_llcp * ) msg -> msg_name ; msg -> msg_namelen = sizeof ( struct sockaddr_nfc_llcp ) ; pr_debug ( "Datagram<S2SV_blank>socket<S2SV_blank>%d<S2SV_blank>%d\\n" , ui_cb -> dsap , ui_cb -> ssap ) ; memset ( sockaddr , 0 , sizeof ( * sockaddr ) ) ; sockaddr -> sa_family = AF_NFC ; sockaddr -> nfc_protocol = NFC_PROTO_NFC_DEP ; sockaddr -> dsap = ui_cb -> dsap ; sockaddr -> ssap = ui_cb -> ssap ; } if ( ! ( flags & MSG_PEEK ) ) { if ( sk -> sk_type == SOCK_STREAM || sk -> sk_type == SOCK_DGRAM || sk -> sk_type == SOCK_RAW ) { skb_pull ( skb , copied ) ; if ( skb -> len ) { skb_queue_head ( & sk -> sk_receive_queue , skb ) ; goto done ; } } kfree_skb ( skb ) ; } done : if ( sk -> sk_type == SOCK_SEQPACKET && ( flags & MSG_TRUNC ) ) copied = rlen ; return copied ; }
static struct sock * dccp_v6_request_recv_sock ( struct sock * sk , struct sk_buff * skb , struct request_sock * req , struct dst_entry * dst ) { struct inet6_request_sock * ireq6 = inet6_rsk ( req ) ; struct ipv6_pinfo * newnp , * np = inet6_sk ( sk ) ; struct inet_sock * newinet ; struct dccp6_sock * newdp6 ; struct sock * newsk ; struct ipv6_txoptions * opt ; if ( skb -> protocol == htons ( ETH_P_IP ) ) { newsk = dccp_v4_request_recv_sock ( sk , skb , req , dst ) ; if ( newsk == NULL ) return NULL ; newdp6 = ( struct dccp6_sock * ) newsk ; newinet = inet_sk ( newsk ) ; newinet -> pinet6 = & newdp6 -> inet6 ; newnp = inet6_sk ( newsk ) ; memcpy ( newnp , np , sizeof ( struct ipv6_pinfo ) ) ; ipv6_addr_set_v4mapped ( newinet -> inet_daddr , & newnp -> daddr ) ; ipv6_addr_set_v4mapped ( newinet -> inet_saddr , & newnp -> saddr ) ; ipv6_addr_copy ( & newnp -> rcv_saddr , & newnp -> saddr ) ; inet_csk ( newsk ) -> icsk_af_ops = & dccp_ipv6_mapped ; newsk -> sk_backlog_rcv = dccp_v4_do_rcv ; newnp -> pktoptions = NULL ; newnp -> opt = NULL ; newnp -> mcast_oif = inet6_iif ( skb ) ; newnp -> mcast_hops = ipv6_hdr ( skb ) -> hop_limit ; dccp_sync_mss ( newsk , inet_csk ( newsk ) -> icsk_pmtu_cookie ) ; return newsk ; } opt = np -> opt ; if ( sk_acceptq_is_full ( sk ) ) goto out_overflow ; if ( dst == NULL ) { struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = IPPROTO_DCCP ; ipv6_addr_copy ( & fl6 . daddr , & ireq6 -> rmt_addr ) ; final_p = fl6_update_dst ( & fl6 , opt , & final ) ; ipv6_addr_copy ( & fl6 . saddr , & ireq6 -> loc_addr ) ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . fl6_dport = inet_rsk ( req ) -> rmt_port ; fl6 . fl6_sport = inet_rsk ( req ) -> loc_port ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p , false ) ; if ( IS_ERR ( dst ) ) goto out ; } newsk = dccp_create_openreq_child ( sk , req , skb ) ; if ( newsk == NULL ) goto out_nonewsk ; __ip6_dst_store ( newsk , dst , NULL , NULL ) ; newsk -> sk_route_caps = dst -> dev -> features & ~ ( NETIF_F_IP_CSUM | NETIF_F_TSO ) ; newdp6 = ( struct dccp6_sock * ) newsk ; newinet = inet_sk ( newsk ) ; newinet -> pinet6 = & newdp6 -> inet6 ; newnp = inet6_sk ( newsk ) ; memcpy ( newnp , np , sizeof ( struct ipv6_pinfo ) ) ; ipv6_addr_copy ( & newnp -> daddr , & ireq6 -> rmt_addr ) ; ipv6_addr_copy ( & newnp -> saddr , & ireq6 -> loc_addr ) ; ipv6_addr_copy ( & newnp -> rcv_saddr , & ireq6 -> loc_addr ) ; newsk -> sk_bound_dev_if = ireq6 -> iif ; <S2SV_StartBug> newinet -> opt = NULL ; <S2SV_EndBug> newnp -> rxopt . all = np -> rxopt . all ; newnp -> pktoptions = NULL ; if ( ireq6 -> pktopts != NULL ) { newnp -> pktoptions = skb_clone ( ireq6 -> pktopts , GFP_ATOMIC ) ; kfree_skb ( ireq6 -> pktopts ) ; ireq6 -> pktopts = NULL ; if ( newnp -> pktoptions ) skb_set_owner_r ( newnp -> pktoptions , newsk ) ; } newnp -> opt = NULL ; newnp -> mcast_oif = inet6_iif ( skb ) ; newnp -> mcast_hops = ipv6_hdr ( skb ) -> hop_limit ; if ( opt != NULL ) { newnp -> opt = ipv6_dup_options ( newsk , opt ) ; if ( opt != np -> opt ) sock_kfree_s ( sk , opt , opt -> tot_len ) ; } inet_csk ( newsk ) -> icsk_ext_hdr_len = 0 ; if ( newnp -> opt != NULL ) inet_csk ( newsk ) -> icsk_ext_hdr_len = ( newnp -> opt -> opt_nflen + newnp -> opt -> opt_flen ) ; dccp_sync_mss ( newsk , dst_mtu ( dst ) ) ; newinet -> inet_daddr = newinet -> inet_saddr = LOOPBACK4_IPV6 ; newinet -> inet_rcv_saddr = LOOPBACK4_IPV6 ; if ( __inet_inherit_port ( sk , newsk ) < 0 ) { sock_put ( newsk ) ; goto out ; } __inet6_hash ( newsk , NULL ) ; return newsk ; out_overflow : NET_INC_STATS_BH ( sock_net ( sk ) , LINUX_MIB_LISTENOVERFLOWS ) ; out_nonewsk : dst_release ( dst ) ; out : NET_INC_STATS_BH ( sock_net ( sk ) , LINUX_MIB_LISTENDROPS ) ; if ( opt != NULL && opt != np -> opt ) sock_kfree_s ( sk , opt , opt -> tot_len ) ; return NULL ; }
<S2SV_StartBug> static double get_prediction_decay_rate ( const VP9_COMMON * cm , <S2SV_EndBug> const FIRSTPASS_STATS * next_frame ) { <S2SV_StartBug> const double mb_sr_err_diff = ( next_frame -> sr_coded_error - <S2SV_EndBug> next_frame -> coded_error ) / cm -> MBs ; <S2SV_StartBug> const double second_ref_decay = mb_sr_err_diff <= 512.0 <S2SV_EndBug> <S2SV_StartBug> ? fclamp ( pow ( 1.0 - ( mb_sr_err_diff / 512.0 ) , 0.5 ) , 0.85 , 1.0 ) <S2SV_EndBug> : 0.85 ; return MIN ( second_ref_decay , next_frame -> pcnt_inter ) ; }
long arch_ptrace ( struct task_struct * child , long request , unsigned long addr , unsigned long data ) { int ret ; unsigned long __user * datap = ( unsigned long __user * ) data ; switch ( request ) { case PTRACE_PEEKUSR : ret = ptrace_read_user ( child , addr , datap ) ; break ; case PTRACE_POKEUSR : ret = ptrace_write_user ( child , addr , data ) ; break ; case PTRACE_GETREGS : ret = copy_regset_to_user ( child , & user_arm_view , REGSET_GPR , 0 , sizeof ( struct pt_regs ) , datap ) ; break ; case PTRACE_SETREGS : ret = copy_regset_from_user ( child , & user_arm_view , REGSET_GPR , 0 , sizeof ( struct pt_regs ) , datap ) ; break ; case PTRACE_GETFPREGS : ret = copy_regset_to_user ( child , & user_arm_view , REGSET_FPR , 0 , sizeof ( union fp_state ) , datap ) ; break ; case PTRACE_SETFPREGS : ret = copy_regset_from_user ( child , & user_arm_view , REGSET_FPR , 0 , sizeof ( union fp_state ) , datap ) ; break ; # ifdef CONFIG_IWMMXT case PTRACE_GETWMMXREGS : ret = ptrace_getwmmxregs ( child , datap ) ; break ; case PTRACE_SETWMMXREGS : ret = ptrace_setwmmxregs ( child , datap ) ; break ; # endif case PTRACE_GET_THREAD_AREA : <S2SV_StartBug> ret = put_user ( task_thread_info ( child ) -> tp_value , <S2SV_EndBug> datap ) ; break ; case PTRACE_SET_SYSCALL : task_thread_info ( child ) -> syscall = data ; ret = 0 ; break ; # ifdef CONFIG_CRUNCH case PTRACE_GETCRUNCHREGS : ret = ptrace_getcrunchregs ( child , datap ) ; break ; case PTRACE_SETCRUNCHREGS : ret = ptrace_setcrunchregs ( child , datap ) ; break ; # endif # ifdef CONFIG_VFP case PTRACE_GETVFPREGS : ret = copy_regset_to_user ( child , & user_arm_view , REGSET_VFP , 0 , ARM_VFPREGS_SIZE , datap ) ; break ; case PTRACE_SETVFPREGS : ret = copy_regset_from_user ( child , & user_arm_view , REGSET_VFP , 0 , ARM_VFPREGS_SIZE , datap ) ; break ; # endif # ifdef CONFIG_HAVE_HW_BREAKPOINT case PTRACE_GETHBPREGS : if ( ptrace_get_breakpoints ( child ) < 0 ) return - ESRCH ; ret = ptrace_gethbpregs ( child , addr , ( unsigned long __user * ) data ) ; ptrace_put_breakpoints ( child ) ; break ; case PTRACE_SETHBPREGS : if ( ptrace_get_breakpoints ( child ) < 0 ) return - ESRCH ; ret = ptrace_sethbpregs ( child , addr , ( unsigned long __user * ) data ) ; ptrace_put_breakpoints ( child ) ; break ; # endif default : ret = ptrace_request ( child , request , addr , data ) ; break ; } return ret ; }
static void initialize_encoder ( struct stream_state * stream , struct VpxEncoderConfig * global ) { int i ; int flags = 0 ; flags |= global -> show_psnr ? VPX_CODEC_USE_PSNR : 0 ; flags |= global -> out_part ? VPX_CODEC_USE_OUTPUT_PARTITION : 0 ; <S2SV_StartBug> vpx_codec_enc_init ( & stream -> encoder , global -> codec -> interface ( ) , <S2SV_EndBug> & stream -> config . cfg , flags ) ; ctx_exit_on_error ( & stream -> encoder , "Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>encoder" ) ; for ( i = 0 ; i < stream -> config . arg_ctrl_cnt ; i ++ ) { int ctrl = stream -> config . arg_ctrls [ i ] [ 0 ] ; int value = stream -> config . arg_ctrls [ i ] [ 1 ] ; if ( vpx_codec_control_ ( & stream -> encoder , ctrl , value ) ) fprintf ( stderr , "Error:<S2SV_blank>Tried<S2SV_blank>to<S2SV_blank>set<S2SV_blank>control<S2SV_blank>%d<S2SV_blank>=<S2SV_blank>%d\\n" , ctrl , value ) ; ctx_exit_on_error ( & stream -> encoder , "Failed<S2SV_blank>to<S2SV_blank>control<S2SV_blank>codec" ) ; } # if CONFIG_DECODERS if ( global -> test_decode != TEST_DECODE_OFF ) { const VpxInterface * decoder = get_vpx_decoder_by_name ( global -> codec -> name ) ; <S2SV_StartBug> vpx_codec_dec_init ( & stream -> decoder , decoder -> interface ( ) , NULL , 0 ) ; <S2SV_EndBug> } # endif }
void qedi_dbg_notice ( struct qedi_dbg_ctx * qedi , const char * func , u32 line , const char * fmt , ... ) { va_list va ; <S2SV_StartBug> struct va_format vaf ; <S2SV_EndBug> char nfunc [ 32 ] ; memset ( nfunc , 0 , sizeof ( nfunc ) ) ; memcpy ( nfunc , func , sizeof ( nfunc ) - 1 ) ; va_start ( va , fmt ) ; vaf . fmt = fmt ; vaf . va = & va ; if ( ! ( qedi_dbg_log & QEDI_LOG_NOTICE ) ) goto ret ; if ( likely ( qedi ) && likely ( qedi -> pdev ) ) pr_notice ( "[%s]:[%s:%d]:%d:<S2SV_blank>%pV" , <S2SV_StartBug> dev_name ( & qedi -> pdev -> dev ) , nfunc , line , <S2SV_EndBug> qedi -> host_no , & vaf ) ; else <S2SV_StartBug> pr_notice ( "[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV" , nfunc , line , & vaf ) ; <S2SV_EndBug> ret : va_end ( va ) ; }
int git_pkt_parse_line ( git_pkt * * head , const char * line , const char * * out , size_t bufflen ) { int ret ; int32_t len ; if ( bufflen > 0 && bufflen < PKT_LEN_SIZE ) return GIT_EBUFS ; len = parse_len ( line ) ; if ( len < 0 ) { if ( bufflen >= 4 && ! git__prefixcmp ( line , "PACK" ) ) { giterr_clear ( ) ; * out = line ; return pack_pkt ( head ) ; } return ( int ) len ; } if ( bufflen > 0 && bufflen < ( size_t ) len ) return GIT_EBUFS ; if ( len != 0 && len < PKT_LEN_SIZE ) return GIT_ERROR ; line += PKT_LEN_SIZE ; if ( len == PKT_LEN_SIZE ) { <S2SV_StartBug> * head = NULL ; <S2SV_EndBug> * out = line ; return 0 ; } if ( len == 0 ) { * out = line ; return flush_pkt ( head ) ; } len -= PKT_LEN_SIZE ; if ( * line == GIT_SIDE_BAND_DATA ) ret = data_pkt ( head , line , len ) ; else if ( * line == GIT_SIDE_BAND_PROGRESS ) ret = sideband_progress_pkt ( head , line , len ) ; else if ( * line == GIT_SIDE_BAND_ERROR ) ret = sideband_error_pkt ( head , line , len ) ; else if ( ! git__prefixcmp ( line , "ACK" ) ) ret = ack_pkt ( head , line , len ) ; else if ( ! git__prefixcmp ( line , "NAK" ) ) ret = nak_pkt ( head ) ; else if ( ! git__prefixcmp ( line , "ERR<S2SV_blank>" ) ) ret = err_pkt ( head , line , len ) ; else if ( * line == '#' ) ret = comment_pkt ( head , line , len ) ; else if ( ! git__prefixcmp ( line , "ok" ) ) ret = ok_pkt ( head , line , len ) ; else if ( ! git__prefixcmp ( line , "ng" ) ) ret = ng_pkt ( head , line , len ) ; else if ( ! git__prefixcmp ( line , "unpack" ) ) ret = unpack_pkt ( head , line , len ) ; else ret = ref_pkt ( head , line , len ) ; * out = line + len ; return ret ; }
<S2SV_StartBug> static struct ion_handle * ion_handle_get_by_id ( struct ion_client * client , <S2SV_EndBug> int id ) { struct ion_handle * handle ; mutex_lock ( & client -> lock ) ; <S2SV_StartBug> handle = idr_find ( & client -> idr , id ) ; <S2SV_EndBug> if ( handle ) ion_handle_get ( handle ) ; mutex_unlock ( & client -> lock ) ; <S2SV_StartBug> return handle ? handle : ERR_PTR ( - EINVAL ) ; <S2SV_EndBug> }
<S2SV_StartBug> void Huff_offsetTransmit ( huff_t * huff , int ch , byte * fout , int * offset ) { <S2SV_EndBug> bloc = * offset ; <S2SV_StartBug> send ( huff -> loc [ ch ] , NULL , fout ) ; <S2SV_EndBug> * offset = bloc ; }
static int udf_load_logicalvol ( struct super_block * sb , sector_t block , struct kernel_lb_addr * fileset ) { struct logicalVolDesc * lvd ; <S2SV_StartBug> int i , j , offset ; <S2SV_EndBug> uint8_t type ; struct udf_sb_info * sbi = UDF_SB ( sb ) ; struct genericPartitionMap * gpm ; uint16_t ident ; struct buffer_head * bh ; unsigned int table_len ; int ret = 0 ; bh = udf_read_tagged ( sb , block , block , & ident ) ; if ( ! bh ) return 1 ; BUG_ON ( ident != TAG_IDENT_LVD ) ; lvd = ( struct logicalVolDesc * ) bh -> b_data ; table_len = le32_to_cpu ( lvd -> mapTableLength ) ; if ( sizeof ( * lvd ) + table_len > sb -> s_blocksize ) { udf_err ( sb , "error<S2SV_blank>loading<S2SV_blank>logical<S2SV_blank>volume<S2SV_blank>descriptor:<S2SV_blank>" "Partition<S2SV_blank>table<S2SV_blank>too<S2SV_blank>long<S2SV_blank>(%u<S2SV_blank>><S2SV_blank>%lu)\\n" , table_len , sb -> s_blocksize - sizeof ( * lvd ) ) ; goto out_bh ; } ret = udf_sb_alloc_partition_maps ( sb , le32_to_cpu ( lvd -> numPartitionMaps ) ) ; if ( ret ) goto out_bh ; for ( i = 0 , offset = 0 ; i < sbi -> s_partitions && offset < table_len ; i ++ , offset += gpm -> partitionMapLength ) { struct udf_part_map * map = & sbi -> s_partmaps [ i ] ; gpm = ( struct genericPartitionMap * ) & ( lvd -> partitionMaps [ offset ] ) ; type = gpm -> partitionMapType ; if ( type == 1 ) { struct genericPartitionMap1 * gpm1 = ( struct genericPartitionMap1 * ) gpm ; map -> s_partition_type = UDF_TYPE1_MAP15 ; map -> s_volumeseqnum = le16_to_cpu ( gpm1 -> volSeqNum ) ; map -> s_partition_num = le16_to_cpu ( gpm1 -> partitionNum ) ; map -> s_partition_func = NULL ; } else if ( type == 2 ) { struct udfPartitionMap2 * upm2 = ( struct udfPartitionMap2 * ) gpm ; if ( ! strncmp ( upm2 -> partIdent . ident , UDF_ID_VIRTUAL , strlen ( UDF_ID_VIRTUAL ) ) ) { u16 suf = le16_to_cpu ( ( ( __le16 * ) upm2 -> partIdent . identSuffix ) [ 0 ] ) ; if ( suf < 0x0200 ) { map -> s_partition_type = UDF_VIRTUAL_MAP15 ; map -> s_partition_func = udf_get_pblock_virt15 ; } else { map -> s_partition_type = UDF_VIRTUAL_MAP20 ; map -> s_partition_func = udf_get_pblock_virt20 ; } } else if ( ! strncmp ( upm2 -> partIdent . ident , UDF_ID_SPARABLE , strlen ( UDF_ID_SPARABLE ) ) ) { <S2SV_StartBug> uint32_t loc ; <S2SV_EndBug> struct sparingTable * st ; <S2SV_StartBug> struct sparablePartitionMap * spm = <S2SV_EndBug> ( struct sparablePartitionMap * ) gpm ; map -> s_partition_type = UDF_SPARABLE_MAP15 ; map -> s_type_specific . s_sparing . s_packet_len = le16_to_cpu ( spm -> packetLength ) ; for ( j = 0 ; j < spm -> numSparingTables ; j ++ ) { struct buffer_head * bh2 ; loc = le32_to_cpu ( spm -> locSparingTable [ j ] ) ; bh2 = udf_read_tagged ( sb , loc , loc , & ident ) ; map -> s_type_specific . s_sparing . s_spar_map [ j ] = bh2 ; if ( bh2 == NULL ) continue ; st = ( struct sparingTable * ) bh2 -> b_data ; if ( ident != 0 || strncmp ( st -> sparingIdent . ident , UDF_ID_SPARING , strlen ( UDF_ID_SPARING ) ) ) { brelse ( bh2 ) ; map -> s_type_specific . s_sparing . s_spar_map [ j ] = NULL ; } } map -> s_partition_func = udf_get_pblock_spar15 ; } else if ( ! strncmp ( upm2 -> partIdent . ident , UDF_ID_METADATA , strlen ( UDF_ID_METADATA ) ) ) { struct udf_meta_data * mdata = & map -> s_type_specific . s_metadata ; struct metadataPartitionMap * mdm = ( struct metadataPartitionMap * ) & ( lvd -> partitionMaps [ offset ] ) ; udf_debug ( "Parsing<S2SV_blank>Logical<S2SV_blank>vol<S2SV_blank>part<S2SV_blank>%d<S2SV_blank>type<S2SV_blank>%d<S2SV_blank><S2SV_blank>id=%s\\n" , i , type , UDF_ID_METADATA ) ; map -> s_partition_type = UDF_METADATA_MAP25 ; map -> s_partition_func = udf_get_pblock_meta25 ; mdata -> s_meta_file_loc = le32_to_cpu ( mdm -> metadataFileLoc ) ; mdata -> s_mirror_file_loc = le32_to_cpu ( mdm -> metadataMirrorFileLoc ) ; mdata -> s_bitmap_file_loc = le32_to_cpu ( mdm -> metadataBitmapFileLoc ) ; mdata -> s_alloc_unit_size = le32_to_cpu ( mdm -> allocUnitSize ) ; mdata -> s_align_unit_size = le16_to_cpu ( mdm -> alignUnitSize ) ; if ( mdm -> flags & 0x01 ) mdata -> s_flags |= MF_DUPLICATE_MD ; udf_debug ( "Metadata<S2SV_blank>Ident<S2SV_blank>suffix=0x%x\\n" , le16_to_cpu ( * ( __le16 * ) mdm -> partIdent . identSuffix ) ) ; udf_debug ( "Metadata<S2SV_blank>part<S2SV_blank>num=%d\\n" , le16_to_cpu ( mdm -> partitionNum ) ) ; udf_debug ( "Metadata<S2SV_blank>part<S2SV_blank>alloc<S2SV_blank>unit<S2SV_blank>size=%d\\n" , le32_to_cpu ( mdm -> allocUnitSize ) ) ; udf_debug ( "Metadata<S2SV_blank>file<S2SV_blank>loc=%d\\n" , le32_to_cpu ( mdm -> metadataFileLoc ) ) ; udf_debug ( "Mirror<S2SV_blank>file<S2SV_blank>loc=%d\\n" , le32_to_cpu ( mdm -> metadataMirrorFileLoc ) ) ; udf_debug ( "Bitmap<S2SV_blank>file<S2SV_blank>loc=%d\\n" , le32_to_cpu ( mdm -> metadataBitmapFileLoc ) ) ; udf_debug ( "Flags:<S2SV_blank>%d<S2SV_blank>%d\\n" , mdata -> s_flags , mdm -> flags ) ; } else { udf_debug ( "Unknown<S2SV_blank>ident:<S2SV_blank>%s\\n" , upm2 -> partIdent . ident ) ; continue ; } map -> s_volumeseqnum = le16_to_cpu ( upm2 -> volSeqNum ) ; map -> s_partition_num = le16_to_cpu ( upm2 -> partitionNum ) ; } udf_debug ( "Partition<S2SV_blank>(%d:%d)<S2SV_blank>type<S2SV_blank>%d<S2SV_blank>on<S2SV_blank>volume<S2SV_blank>%d\\n" , i , map -> s_partition_num , type , map -> s_volumeseqnum ) ; } if ( fileset ) { struct long_ad * la = ( struct long_ad * ) & ( lvd -> logicalVolContentsUse [ 0 ] ) ; * fileset = lelb_to_cpu ( la -> extLocation ) ; udf_debug ( "FileSet<S2SV_blank>found<S2SV_blank>in<S2SV_blank>LogicalVolDesc<S2SV_blank>at<S2SV_blank>block=%d,<S2SV_blank>partition=%d\\n" , fileset -> logicalBlockNum , fileset -> partitionReferenceNum ) ; } if ( lvd -> integritySeqExt . extLength ) udf_load_logicalvolint ( sb , leea_to_cpu ( lvd -> integritySeqExt ) ) ; out_bh : brelse ( bh ) ; return ret ; }
static void y4m_convert_null ( y4m_input * _y4m , unsigned char * _dst , unsigned char * _aux ) { <S2SV_StartBug> } <S2SV_EndBug>
void ext2_xattr_delete_inode ( struct inode * inode ) { struct buffer_head * bh = NULL ; <S2SV_StartBug> struct mb_cache_entry * ce ; <S2SV_EndBug> down_write ( & EXT2_I ( inode ) -> xattr_sem ) ; if ( ! EXT2_I ( inode ) -> i_file_acl ) goto cleanup ; bh = sb_bread ( inode -> i_sb , EXT2_I ( inode ) -> i_file_acl ) ; if ( ! bh ) { ext2_error ( inode -> i_sb , "ext2_xattr_delete_inode" , "inode<S2SV_blank>%ld:<S2SV_blank>block<S2SV_blank>%d<S2SV_blank>read<S2SV_blank>error" , inode -> i_ino , EXT2_I ( inode ) -> i_file_acl ) ; goto cleanup ; } ea_bdebug ( bh , "b_count=%d" , atomic_read ( & ( bh -> b_count ) ) ) ; if ( HDR ( bh ) -> h_magic != cpu_to_le32 ( EXT2_XATTR_MAGIC ) || HDR ( bh ) -> h_blocks != cpu_to_le32 ( 1 ) ) { ext2_error ( inode -> i_sb , "ext2_xattr_delete_inode" , "inode<S2SV_blank>%ld:<S2SV_blank>bad<S2SV_blank>block<S2SV_blank>%d" , inode -> i_ino , EXT2_I ( inode ) -> i_file_acl ) ; goto cleanup ; } <S2SV_StartBug> ce = mb_cache_entry_get ( ext2_xattr_cache , bh -> b_bdev , bh -> b_blocknr ) ; <S2SV_EndBug> lock_buffer ( bh ) ; if ( HDR ( bh ) -> h_refcount == cpu_to_le32 ( 1 ) ) { <S2SV_StartBug> if ( ce ) <S2SV_EndBug> mb_cache_entry_free ( ce ) ; ext2_free_blocks ( inode , EXT2_I ( inode ) -> i_file_acl , 1 ) ; get_bh ( bh ) ; bforget ( bh ) ; unlock_buffer ( bh ) ; } else { <S2SV_StartBug> le32_add_cpu ( & HDR ( bh ) -> h_refcount , - 1 ) ; <S2SV_EndBug> if ( ce ) mb_cache_entry_release ( ce ) ; ea_bdebug ( bh , "refcount<S2SV_blank>now=%d" , le32_to_cpu ( HDR ( bh ) -> h_refcount ) ) ; unlock_buffer ( bh ) ; mark_buffer_dirty ( bh ) ; if ( IS_SYNC ( inode ) ) sync_dirty_buffer ( bh ) ; dquot_free_block_nodirty ( inode , 1 ) ; } EXT2_I ( inode ) -> i_file_acl = 0 ; cleanup : brelse ( bh ) ; up_write ( & EXT2_I ( inode ) -> xattr_sem ) ; }
static OPJ_BOOL opj_pi_next_pcrl ( opj_pi_iterator_t * pi ) { opj_pi_comp_t * comp = NULL ; opj_pi_resolution_t * res = NULL ; OPJ_UINT32 index = 0 ; if ( ! pi -> first ) { comp = & pi -> comps [ pi -> compno ] ; goto LABEL_SKIP ; } else { OPJ_UINT32 compno , resno ; pi -> first = 0 ; pi -> dx = 0 ; pi -> dy = 0 ; for ( compno = 0 ; compno < pi -> numcomps ; compno ++ ) { comp = & pi -> comps [ compno ] ; for ( resno = 0 ; resno < comp -> numresolutions ; resno ++ ) { OPJ_UINT32 dx , dy ; res = & comp -> resolutions [ resno ] ; dx = comp -> dx * ( 1u << ( res -> pdx + comp -> numresolutions - 1 - resno ) ) ; dy = comp -> dy * ( 1u << ( res -> pdy + comp -> numresolutions - 1 - resno ) ) ; pi -> dx = ! pi -> dx ? dx : opj_uint_min ( pi -> dx , dx ) ; pi -> dy = ! pi -> dy ? dy : opj_uint_min ( pi -> dy , dy ) ; } } } if ( ! pi -> tp_on ) { pi -> poc . ty0 = pi -> ty0 ; pi -> poc . tx0 = pi -> tx0 ; pi -> poc . ty1 = pi -> ty1 ; pi -> poc . tx1 = pi -> tx1 ; } for ( pi -> y = pi -> poc . ty0 ; pi -> y < pi -> poc . ty1 ; pi -> y += ( OPJ_INT32 ) ( pi -> dy - ( OPJ_UINT32 ) ( pi -> y % ( OPJ_INT32 ) pi -> dy ) ) ) { for ( pi -> x = pi -> poc . tx0 ; pi -> x < pi -> poc . tx1 ; pi -> x += ( OPJ_INT32 ) ( pi -> dx - ( OPJ_UINT32 ) ( pi -> x % ( OPJ_INT32 ) pi -> dx ) ) ) { for ( pi -> compno = pi -> poc . compno0 ; pi -> compno < pi -> poc . compno1 ; pi -> compno ++ ) { comp = & pi -> comps [ pi -> compno ] ; for ( pi -> resno = pi -> poc . resno0 ; pi -> resno < opj_uint_min ( pi -> poc . resno1 , comp -> numresolutions ) ; pi -> resno ++ ) { OPJ_UINT32 levelno ; OPJ_INT32 trx0 , try0 ; OPJ_INT32 trx1 , try1 ; OPJ_UINT32 rpx , rpy ; OPJ_INT32 prci , prcj ; res = & comp -> resolutions [ pi -> resno ] ; levelno = comp -> numresolutions - 1 - pi -> resno ; trx0 = opj_int_ceildiv ( pi -> tx0 , ( OPJ_INT32 ) ( comp -> dx << levelno ) ) ; try0 = opj_int_ceildiv ( pi -> ty0 , ( OPJ_INT32 ) ( comp -> dy << levelno ) ) ; trx1 = opj_int_ceildiv ( pi -> tx1 , ( OPJ_INT32 ) ( comp -> dx << levelno ) ) ; try1 = opj_int_ceildiv ( pi -> ty1 , ( OPJ_INT32 ) ( comp -> dy << levelno ) ) ; rpx = res -> pdx + levelno ; rpy = res -> pdy + levelno ; <S2SV_StartBug> if ( ! ( ( pi -> y % ( OPJ_INT32 ) ( comp -> dy << rpy ) == 0 ) || ( ( pi -> y == pi -> ty0 ) && <S2SV_EndBug> ( ( try0 << levelno ) % ( 1 << rpy ) ) ) ) ) { continue ; } if ( ! ( ( pi -> x % ( OPJ_INT32 ) ( comp -> dx << rpx ) == 0 ) || ( ( pi -> x == pi -> tx0 ) && ( ( trx0 << levelno ) % ( 1 << rpx ) ) ) ) ) { continue ; } if ( ( res -> pw == 0 ) || ( res -> ph == 0 ) ) { continue ; } if ( ( trx0 == trx1 ) || ( try0 == try1 ) ) { continue ; } prci = opj_int_floordivpow2 ( opj_int_ceildiv ( pi -> x , ( OPJ_INT32 ) ( comp -> dx << levelno ) ) , ( OPJ_INT32 ) res -> pdx ) - opj_int_floordivpow2 ( trx0 , ( OPJ_INT32 ) res -> pdx ) ; prcj = opj_int_floordivpow2 ( opj_int_ceildiv ( pi -> y , ( OPJ_INT32 ) ( comp -> dy << levelno ) ) , ( OPJ_INT32 ) res -> pdy ) - opj_int_floordivpow2 ( try0 , ( OPJ_INT32 ) res -> pdy ) ; pi -> precno = ( OPJ_UINT32 ) ( prci + prcj * ( OPJ_INT32 ) res -> pw ) ; for ( pi -> layno = pi -> poc . layno0 ; pi -> layno < pi -> poc . layno1 ; pi -> layno ++ ) { index = pi -> layno * pi -> step_l + pi -> resno * pi -> step_r + pi -> compno * pi -> step_c + pi -> precno * pi -> step_p ; if ( ! pi -> include [ index ] ) { pi -> include [ index ] = 1 ; return OPJ_TRUE ; } LABEL_SKIP : ; } } } } } return OPJ_FALSE ; }
int jas_stream_gobble ( jas_stream_t * stream , int n ) { <S2SV_StartBug> int m ; <S2SV_EndBug> m = n ; for ( m = n ; m > 0 ; -- m ) { if ( jas_stream_getc ( stream ) == EOF ) { return n - m ; } } return n ; }
int sas_smp_get_phy_events ( struct sas_phy * phy ) { int res ; u8 * req ; u8 * resp ; struct sas_rphy * rphy = dev_to_rphy ( phy -> dev . parent ) ; struct domain_device * dev = sas_find_dev_by_rphy ( rphy ) ; req = alloc_smp_req ( RPEL_REQ_SIZE ) ; if ( ! req ) return - ENOMEM ; resp = alloc_smp_resp ( RPEL_RESP_SIZE ) ; if ( ! resp ) { kfree ( req ) ; return - ENOMEM ; } req [ 1 ] = SMP_REPORT_PHY_ERR_LOG ; req [ 9 ] = phy -> number ; res = smp_execute_task ( dev , req , RPEL_REQ_SIZE , resp , RPEL_RESP_SIZE ) ; if ( ! res ) goto out ; phy -> invalid_dword_count = scsi_to_u32 ( & resp [ 12 ] ) ; phy -> running_disparity_error_count = scsi_to_u32 ( & resp [ 16 ] ) ; phy -> loss_of_dword_sync_count = scsi_to_u32 ( & resp [ 20 ] ) ; phy -> phy_reset_problem_count = scsi_to_u32 ( & resp [ 24 ] ) ; out : <S2SV_StartBug> kfree ( resp ) ; <S2SV_EndBug> return res ; }
static void ssdp_recv ( int sd ) { ssize_t len ; struct sockaddr sa ; socklen_t salen ; <S2SV_StartBug> char buf [ MAX_PKT_SIZE ] ; <S2SV_EndBug> memset ( buf , 0 , sizeof ( buf ) ) ; <S2SV_StartBug> len = recvfrom ( sd , buf , sizeof ( buf ) , MSG_DONTWAIT , & sa , & salen ) ; <S2SV_EndBug> if ( len > 0 ) { <S2SV_StartBug> buf [ len ] = 0 ; <S2SV_EndBug> if ( sa . sa_family != AF_INET ) return ; if ( strstr ( buf , "M-SEARCH<S2SV_blank>*" ) ) { size_t i ; char * ptr , * type ; struct ifsock * ifs ; struct sockaddr_in * sin = ( struct sockaddr_in * ) & sa ; ifs = find_outbound ( & sa ) ; if ( ! ifs ) { logit ( LOG_DEBUG , "No<S2SV_blank>matching<S2SV_blank>socket<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s" , inet_ntoa ( sin -> sin_addr ) ) ; return ; } logit ( LOG_DEBUG , "Matching<S2SV_blank>socket<S2SV_blank>for<S2SV_blank>client<S2SV_blank>%s" , inet_ntoa ( sin -> sin_addr ) ) ; type = strcasestr ( buf , "\\r\\nST:" ) ; if ( ! type ) { logit ( LOG_DEBUG , "No<S2SV_blank>Search<S2SV_blank>Type<S2SV_blank>(ST:)<S2SV_blank>found<S2SV_blank>in<S2SV_blank>M-SEARCH<S2SV_blank>*,<S2SV_blank>assuming<S2SV_blank>" SSDP_ST_ALL ) ; type = SSDP_ST_ALL ; send_message ( ifs , type , & sa ) ; return ; } type = strchr ( type , ':' ) ; if ( ! type ) return ; type ++ ; while ( isspace ( * type ) ) type ++ ; ptr = strstr ( type , "\\r\\n" ) ; if ( ! ptr ) return ; * ptr = 0 ; for ( i = 0 ; supported_types [ i ] ; i ++ ) { if ( ! strcmp ( supported_types [ i ] , type ) ) { logit ( LOG_DEBUG , "M-SEARCH<S2SV_blank>*<S2SV_blank>ST:<S2SV_blank>%s<S2SV_blank>from<S2SV_blank>%s<S2SV_blank>port<S2SV_blank>%d" , type , inet_ntoa ( sin -> sin_addr ) , ntohs ( sin -> sin_port ) ) ; send_message ( ifs , type , & sa ) ; return ; } } logit ( LOG_DEBUG , "M-SEARCH<S2SV_blank>*<S2SV_blank>for<S2SV_blank>unsupported<S2SV_blank>ST:<S2SV_blank>%s<S2SV_blank>from<S2SV_blank>%s" , type , inet_ntoa ( sin -> sin_addr ) ) ; } } }
static stmt_ty ast_for_import_stmt ( struct compiling * c , const node * n ) { int lineno ; int col_offset ; int i ; asdl_seq * aliases ; REQ ( n , import_stmt ) ; lineno = LINENO ( n ) ; col_offset = n -> n_col_offset ; n = CHILD ( n , 0 ) ; if ( TYPE ( n ) == import_name ) { n = CHILD ( n , 1 ) ; REQ ( n , dotted_as_names ) ; aliases = _Py_asdl_seq_new ( ( NCH ( n ) + 1 ) / 2 , c -> c_arena ) ; if ( ! aliases ) return NULL ; for ( i = 0 ; i < NCH ( n ) ; i += 2 ) { alias_ty import_alias = alias_for_import_name ( c , CHILD ( n , i ) , 1 ) ; if ( ! import_alias ) return NULL ; asdl_seq_SET ( aliases , i / 2 , import_alias ) ; } return Import ( aliases , lineno , col_offset , n -> n_end_lineno , n -> n_end_col_offset , c -> c_arena ) ; } else if ( TYPE ( n ) == import_from ) { int n_children ; int idx , ndots = 0 ; const node * n_copy = n ; alias_ty mod = NULL ; identifier modname = NULL ; for ( idx = 1 ; idx < NCH ( n ) ; idx ++ ) { if ( TYPE ( CHILD ( n , idx ) ) == dotted_name ) { mod = alias_for_import_name ( c , CHILD ( n , idx ) , 0 ) ; if ( ! mod ) return NULL ; idx ++ ; break ; } else if ( TYPE ( CHILD ( n , idx ) ) == ELLIPSIS ) { ndots += 3 ; continue ; } else if ( TYPE ( CHILD ( n , idx ) ) != DOT ) { break ; } ndots ++ ; } idx ++ ; switch ( TYPE ( CHILD ( n , idx ) ) ) { case STAR : n = CHILD ( n , idx ) ; n_children = 1 ; break ; case LPAR : n = CHILD ( n , idx + 1 ) ; n_children = NCH ( n ) ; break ; case import_as_names : n = CHILD ( n , idx ) ; n_children = NCH ( n ) ; if ( n_children % 2 == 0 ) { ast_error ( c , n , "trailing<S2SV_blank>comma<S2SV_blank>not<S2SV_blank>allowed<S2SV_blank>without" "<S2SV_blank>surrounding<S2SV_blank>parentheses" ) ; return NULL ; } break ; default : ast_error ( c , n , "Unexpected<S2SV_blank>node-type<S2SV_blank>in<S2SV_blank>from-import" ) ; return NULL ; } aliases = _Py_asdl_seq_new ( ( n_children + 1 ) / 2 , c -> c_arena ) ; if ( ! aliases ) return NULL ; if ( TYPE ( n ) == STAR ) { alias_ty import_alias = alias_for_import_name ( c , n , 1 ) ; if ( ! import_alias ) return NULL ; asdl_seq_SET ( aliases , 0 , import_alias ) ; } else { for ( i = 0 ; i < NCH ( n ) ; i += 2 ) { alias_ty import_alias = alias_for_import_name ( c , CHILD ( n , i ) , 1 ) ; if ( ! import_alias ) return NULL ; asdl_seq_SET ( aliases , i / 2 , import_alias ) ; } } if ( mod != NULL ) modname = mod -> name ; return ImportFrom ( modname , aliases , ndots , lineno , col_offset , n_copy -> n_end_lineno , n_copy -> n_end_col_offset , c -> c_arena ) ; } PyErr_Format ( PyExc_SystemError , "unknown<S2SV_blank>import<S2SV_blank>statement:<S2SV_blank>starts<S2SV_blank>with<S2SV_blank>command<S2SV_blank>\'%s\'" , STR ( CHILD ( n , 0 ) ) ) ; return NULL ; }
static void sycc420_to_rgb ( opj_image_t * img ) { int * d0 , * d1 , * d2 , * r , * g , * b , * nr , * ng , * nb ; const int * y , * cb , * cr , * ny ; <S2SV_StartBug> unsigned int maxw , maxh , max ; <S2SV_EndBug> int offset , upb ; unsigned int i , j ; upb = ( int ) img -> comps [ 0 ] . prec ; offset = 1 << ( upb - 1 ) ; upb = ( 1 << upb ) - 1 ; <S2SV_StartBug> maxw = ( unsigned int ) img -> comps [ 0 ] . w ; maxh = ( unsigned int ) img -> comps [ 0 ] . h ; <S2SV_EndBug> max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; <S2SV_StartBug> d0 = r = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; <S2SV_EndBug> <S2SV_StartBug> d1 = g = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; <S2SV_EndBug> d2 = b = ( int * ) malloc ( sizeof ( int ) * ( size_t ) max ) ; if ( r == NULL || g == NULL || b == NULL ) goto fails ; <S2SV_StartBug> for ( i = 0U ; i < ( maxh & ~ ( unsigned int ) 1U ) ; i += 2U ) <S2SV_EndBug> { <S2SV_StartBug> ny = y + maxw ; <S2SV_EndBug> nr = r + maxw ; ng = g + maxw ; nb = b + maxw ; <S2SV_StartBug> for ( j = 0 ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) <S2SV_EndBug> { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * ny , * cb , * cr , nr , ng , nb ) ; ++ ny ; ++ nr ; ++ ng ; ++ nb ; sycc_to_rgb ( offset , upb , * ny , * cb , * cr , nr , ng , nb ) ; ++ ny ; ++ nr ; ++ ng ; ++ nb ; ++ cb ; ++ cr ; } <S2SV_StartBug> if ( j < maxw ) <S2SV_EndBug> { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * ny , * cb , * cr , nr , ng , nb ) ; ++ ny ; ++ nr ; ++ ng ; ++ nb ; ++ cb ; ++ cr ; } y += maxw ; r += maxw ; g += maxw ; b += maxw ; } <S2SV_StartBug> if ( i < maxh ) <S2SV_EndBug> { <S2SV_StartBug> for ( j = 0U ; j < ( maxw & ~ ( unsigned int ) 1U ) ; j += 2U ) <S2SV_EndBug> { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ; } if ( j < maxw ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; } } free ( img -> comps [ 0 ] . data ) ; img -> comps [ 0 ] . data = d0 ; free ( img -> comps [ 1 ] . data ) ; img -> comps [ 1 ] . data = d1 ; free ( img -> comps [ 2 ] . data ) ; img -> comps [ 2 ] . data = d2 ; <S2SV_StartBug> # if defined ( USE_JPWL ) || defined ( USE_MJ2 ) <S2SV_EndBug> <S2SV_StartBug> img -> comps [ 1 ] . w = maxw ; img -> comps [ 1 ] . h = maxh ; <S2SV_EndBug> <S2SV_StartBug> img -> comps [ 2 ] . w = maxw ; img -> comps [ 2 ] . h = maxh ; <S2SV_EndBug> # else <S2SV_StartBug> img -> comps [ 1 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 1 ] . h = ( OPJ_UINT32 ) maxh ; <S2SV_EndBug> <S2SV_StartBug> img -> comps [ 2 ] . w = ( OPJ_UINT32 ) maxw ; img -> comps [ 2 ] . h = ( OPJ_UINT32 ) maxh ; <S2SV_EndBug> # endif img -> comps [ 1 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 2 ] . dx = img -> comps [ 0 ] . dx ; img -> comps [ 1 ] . dy = img -> comps [ 0 ] . dy ; <S2SV_StartBug> img -> comps [ 2 ] . dy = img -> comps [ 0 ] . dy ; <S2SV_EndBug> return ; fails : <S2SV_StartBug> if ( r ) free ( r ) ; <S2SV_EndBug> <S2SV_StartBug> if ( g ) free ( g ) ; <S2SV_EndBug> <S2SV_StartBug> if ( b ) free ( b ) ; <S2SV_EndBug> }
static uint32_t color_string_to_rgba ( const char * p , int len ) { uint32_t ret = 0xFF000000 ; const ColorEntry * entry ; char color_name [ 100 ] ; <S2SV_StartBug> if ( * p == '#' ) { <S2SV_EndBug> p ++ ; len -- ; if ( len == 3 ) { ret |= ( hex_char_to_number ( p [ 2 ] ) << 4 ) | ( hex_char_to_number ( p [ 1 ] ) << 12 ) | ( hex_char_to_number ( p [ 0 ] ) << 20 ) ; } else if ( len == 4 ) { ret = ( hex_char_to_number ( p [ 3 ] ) << 4 ) | ( hex_char_to_number ( p [ 2 ] ) << 12 ) | ( hex_char_to_number ( p [ 1 ] ) << 20 ) | ( hex_char_to_number ( p [ 0 ] ) << 28 ) ; } else if ( len == 6 ) { ret |= hex_char_to_number ( p [ 5 ] ) | ( hex_char_to_number ( p [ 4 ] ) << 4 ) | ( hex_char_to_number ( p [ 3 ] ) << 8 ) | ( hex_char_to_number ( p [ 2 ] ) << 12 ) | ( hex_char_to_number ( p [ 1 ] ) << 16 ) | ( hex_char_to_number ( p [ 0 ] ) << 20 ) ; } else if ( len == 8 ) { ret = hex_char_to_number ( p [ 7 ] ) | ( hex_char_to_number ( p [ 6 ] ) << 4 ) | ( hex_char_to_number ( p [ 5 ] ) << 8 ) | ( hex_char_to_number ( p [ 4 ] ) << 12 ) | ( hex_char_to_number ( p [ 3 ] ) << 16 ) | ( hex_char_to_number ( p [ 2 ] ) << 20 ) | ( hex_char_to_number ( p [ 1 ] ) << 24 ) | ( hex_char_to_number ( p [ 0 ] ) << 28 ) ; } } else { strncpy ( color_name , p , len ) ; color_name [ len ] = '\\0' ; entry = bsearch ( color_name , color_table , FF_ARRAY_ELEMS ( color_table ) , sizeof ( ColorEntry ) , color_table_compare ) ; if ( ! entry ) return ret ; ret = entry -> rgb_color ; } return ret ; }
static int do_check ( struct bpf_verifier_env * env ) { struct bpf_verifier_state * state = & env -> cur_state ; struct bpf_insn * insns = env -> prog -> insnsi ; struct bpf_reg_state * regs = state -> regs ; int insn_cnt = env -> prog -> len ; int insn_idx , prev_insn_idx = 0 ; int insn_processed = 0 ; bool do_print_state = false ; init_reg_state ( regs ) ; insn_idx = 0 ; env -> varlen_map_value_access = false ; for ( ; ; ) { struct bpf_insn * insn ; u8 class ; int err ; if ( insn_idx >= insn_cnt ) { verbose ( "invalid<S2SV_blank>insn<S2SV_blank>idx<S2SV_blank>%d<S2SV_blank>insn_cnt<S2SV_blank>%d\\n" , insn_idx , insn_cnt ) ; return - EFAULT ; } insn = & insns [ insn_idx ] ; class = BPF_CLASS ( insn -> code ) ; if ( ++ insn_processed > BPF_COMPLEXITY_LIMIT_INSNS ) { verbose ( "BPF<S2SV_blank>program<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large.<S2SV_blank>Processed<S2SV_blank>%d<S2SV_blank>insn\\n" , insn_processed ) ; return - E2BIG ; } err = is_state_visited ( env , insn_idx ) ; if ( err < 0 ) return err ; if ( err == 1 ) { if ( log_level ) { if ( do_print_state ) verbose ( "\\nfrom<S2SV_blank>%d<S2SV_blank>to<S2SV_blank>%d:<S2SV_blank>safe\\n" , prev_insn_idx , insn_idx ) ; else verbose ( "%d:<S2SV_blank>safe\\n" , insn_idx ) ; } goto process_bpf_exit ; } if ( log_level && do_print_state ) { verbose ( "\\nfrom<S2SV_blank>%d<S2SV_blank>to<S2SV_blank>%d:" , prev_insn_idx , insn_idx ) ; print_verifier_state ( & env -> cur_state ) ; do_print_state = false ; } if ( log_level ) { verbose ( "%d:<S2SV_blank>" , insn_idx ) ; <S2SV_StartBug> print_bpf_insn ( insn ) ; <S2SV_EndBug> } err = ext_analyzer_insn_hook ( env , insn_idx , prev_insn_idx ) ; if ( err ) return err ; if ( class == BPF_ALU || class == BPF_ALU64 ) { err = check_alu_op ( env , insn ) ; if ( err ) return err ; } else if ( class == BPF_LDX ) { enum bpf_reg_type * prev_src_type , src_reg_type ; err = check_reg_arg ( regs , insn -> src_reg , SRC_OP ) ; if ( err ) return err ; err = check_reg_arg ( regs , insn -> dst_reg , DST_OP_NO_MARK ) ; if ( err ) return err ; src_reg_type = regs [ insn -> src_reg ] . type ; err = check_mem_access ( env , insn -> src_reg , insn -> off , BPF_SIZE ( insn -> code ) , BPF_READ , insn -> dst_reg ) ; if ( err ) return err ; if ( BPF_SIZE ( insn -> code ) != BPF_W && BPF_SIZE ( insn -> code ) != BPF_DW ) { insn_idx ++ ; continue ; } prev_src_type = & env -> insn_aux_data [ insn_idx ] . ptr_type ; if ( * prev_src_type == NOT_INIT ) { * prev_src_type = src_reg_type ; } else if ( src_reg_type != * prev_src_type && ( src_reg_type == PTR_TO_CTX || * prev_src_type == PTR_TO_CTX ) ) { verbose ( "same<S2SV_blank>insn<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>used<S2SV_blank>with<S2SV_blank>different<S2SV_blank>pointers\\n" ) ; return - EINVAL ; } } else if ( class == BPF_STX ) { enum bpf_reg_type * prev_dst_type , dst_reg_type ; if ( BPF_MODE ( insn -> code ) == BPF_XADD ) { err = check_xadd ( env , insn ) ; if ( err ) return err ; insn_idx ++ ; continue ; } err = check_reg_arg ( regs , insn -> src_reg , SRC_OP ) ; if ( err ) return err ; err = check_reg_arg ( regs , insn -> dst_reg , SRC_OP ) ; if ( err ) return err ; dst_reg_type = regs [ insn -> dst_reg ] . type ; err = check_mem_access ( env , insn -> dst_reg , insn -> off , BPF_SIZE ( insn -> code ) , BPF_WRITE , insn -> src_reg ) ; if ( err ) return err ; prev_dst_type = & env -> insn_aux_data [ insn_idx ] . ptr_type ; if ( * prev_dst_type == NOT_INIT ) { * prev_dst_type = dst_reg_type ; } else if ( dst_reg_type != * prev_dst_type && ( dst_reg_type == PTR_TO_CTX || * prev_dst_type == PTR_TO_CTX ) ) { verbose ( "same<S2SV_blank>insn<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>used<S2SV_blank>with<S2SV_blank>different<S2SV_blank>pointers\\n" ) ; return - EINVAL ; } } else if ( class == BPF_ST ) { if ( BPF_MODE ( insn -> code ) != BPF_MEM || insn -> src_reg != BPF_REG_0 ) { verbose ( "BPF_ST<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n" ) ; return - EINVAL ; } err = check_reg_arg ( regs , insn -> dst_reg , SRC_OP ) ; if ( err ) return err ; err = check_mem_access ( env , insn -> dst_reg , insn -> off , BPF_SIZE ( insn -> code ) , BPF_WRITE , - 1 ) ; if ( err ) return err ; } else if ( class == BPF_JMP ) { u8 opcode = BPF_OP ( insn -> code ) ; if ( opcode == BPF_CALL ) { if ( BPF_SRC ( insn -> code ) != BPF_K || insn -> off != 0 || insn -> src_reg != BPF_REG_0 || insn -> dst_reg != BPF_REG_0 ) { verbose ( "BPF_CALL<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n" ) ; return - EINVAL ; } err = check_call ( env , insn -> imm , insn_idx ) ; if ( err ) return err ; } else if ( opcode == BPF_JA ) { if ( BPF_SRC ( insn -> code ) != BPF_K || insn -> imm != 0 || insn -> src_reg != BPF_REG_0 || insn -> dst_reg != BPF_REG_0 ) { verbose ( "BPF_JA<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n" ) ; return - EINVAL ; } insn_idx += insn -> off + 1 ; continue ; } else if ( opcode == BPF_EXIT ) { if ( BPF_SRC ( insn -> code ) != BPF_K || insn -> imm != 0 || insn -> src_reg != BPF_REG_0 || insn -> dst_reg != BPF_REG_0 ) { verbose ( "BPF_EXIT<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n" ) ; return - EINVAL ; } err = check_reg_arg ( regs , BPF_REG_0 , SRC_OP ) ; if ( err ) return err ; if ( is_pointer_value ( env , BPF_REG_0 ) ) { verbose ( "R0<S2SV_blank>leaks<S2SV_blank>addr<S2SV_blank>as<S2SV_blank>return<S2SV_blank>value\\n" ) ; return - EACCES ; } process_bpf_exit : insn_idx = pop_stack ( env , & prev_insn_idx ) ; if ( insn_idx < 0 ) { break ; } else { do_print_state = true ; continue ; } } else { err = check_cond_jmp_op ( env , insn , & insn_idx ) ; if ( err ) return err ; } } else if ( class == BPF_LD ) { u8 mode = BPF_MODE ( insn -> code ) ; if ( mode == BPF_ABS || mode == BPF_IND ) { err = check_ld_abs ( env , insn ) ; if ( err ) return err ; } else if ( mode == BPF_IMM ) { err = check_ld_imm ( env , insn ) ; if ( err ) return err ; insn_idx ++ ; } else { verbose ( "invalid<S2SV_blank>BPF_LD<S2SV_blank>mode\\n" ) ; return - EINVAL ; } reset_reg_range_values ( regs , insn -> dst_reg ) ; } else { verbose ( "unknown<S2SV_blank>insn<S2SV_blank>class<S2SV_blank>%d\\n" , class ) ; return - EINVAL ; } insn_idx ++ ; } verbose ( "processed<S2SV_blank>%d<S2SV_blank>insns\\n" , insn_processed ) ; return 0 ; }
static bool new_idmap_permitted ( const struct file * file , struct user_namespace * ns , int cap_setid , struct uid_gid_map * new_map ) { if ( ( new_map -> nr_extents == 1 ) && ( new_map -> extent [ 0 ] . count == 1 ) ) { u32 id = new_map -> extent [ 0 ] . lower_first ; if ( cap_setid == CAP_SETUID ) { kuid_t uid = make_kuid ( ns -> parent , id ) ; <S2SV_StartBug> if ( uid_eq ( uid , current_fsuid ( ) ) ) <S2SV_EndBug> return true ; } else if ( cap_setid == CAP_SETGID ) { kgid_t gid = make_kgid ( ns -> parent , id ) ; <S2SV_StartBug> if ( gid_eq ( gid , current_fsgid ( ) ) ) <S2SV_EndBug> return true ; } } if ( ! cap_valid ( cap_setid ) ) return true ; if ( ns_capable ( ns -> parent , cap_setid ) && file_ns_capable ( file , ns -> parent , cap_setid ) ) return true ; return false ; }
static bool generic_new ( struct nf_conn * ct , const struct sk_buff * skb , unsigned int dataoff , unsigned int * timeouts ) { <S2SV_StartBug> return true ; <S2SV_EndBug> }
gdImagePtr gdImageCreate ( int sx , int sy ) { int i ; gdImagePtr im ; if ( overflow2 ( sx , sy ) ) { return NULL ; } if ( overflow2 ( sizeof ( unsigned char * ) , sy ) ) { return NULL ; } <S2SV_StartBug> im = ( gdImage * ) gdCalloc ( 1 , sizeof ( gdImage ) ) ; <S2SV_EndBug> im -> pixels = ( unsigned char * * ) gdMalloc ( sizeof ( unsigned char * ) * sy ) ; im -> AA_opacity = ( unsigned char * * ) gdMalloc ( sizeof ( unsigned char * ) * sy ) ; im -> polyInts = 0 ; im -> polyAllocated = 0 ; im -> brush = 0 ; im -> tile = 0 ; im -> style = 0 ; for ( i = 0 ; i < sy ; i ++ ) { im -> pixels [ i ] = ( unsigned char * ) gdCalloc ( sx , sizeof ( unsigned char ) ) ; im -> AA_opacity [ i ] = ( unsigned char * ) gdCalloc ( sx , sizeof ( unsigned char ) ) ; } im -> sx = sx ; im -> sy = sy ; im -> colorsTotal = 0 ; im -> transparent = ( - 1 ) ; im -> interlace = 0 ; im -> thick = 1 ; im -> AA = 0 ; im -> AA_polygon = 0 ; for ( i = 0 ; i < gdMaxColors ; i ++ ) { im -> open [ i ] = 1 ; im -> red [ i ] = 0 ; im -> green [ i ] = 0 ; im -> blue [ i ] = 0 ; } im -> trueColor = 0 ; im -> tpixels = 0 ; im -> cx1 = 0 ; im -> cy1 = 0 ; im -> cx2 = im -> sx - 1 ; im -> cy2 = im -> sy - 1 ; im -> interpolation = NULL ; im -> interpolation_id = GD_BILINEAR_FIXED ; return im ; }
int vp9_rc_pick_q_and_bounds ( const VP9_COMP * cpi , int * bottom_index , int * top_index ) { int q ; <S2SV_StartBug> if ( cpi -> pass == 0 ) { <S2SV_EndBug> <S2SV_StartBug> if ( cpi -> oxcf . end_usage == USAGE_STREAM_FROM_SERVER ) <S2SV_EndBug> q = rc_pick_q_and_bounds_one_pass_cbr ( cpi , bottom_index , top_index ) ; else q = rc_pick_q_and_bounds_one_pass_vbr ( cpi , bottom_index , top_index ) ; } else { q = rc_pick_q_and_bounds_two_pass ( cpi , bottom_index , top_index ) ; } if ( cpi -> sf . use_nonrd_pick_mode ) { <S2SV_StartBug> if ( q == 0 ) <S2SV_EndBug> q ++ ; if ( cpi -> sf . force_frame_boost == 1 ) q -= cpi -> sf . max_delta_qindex ; if ( q < * bottom_index ) * bottom_index = q ; else if ( q > * top_index ) * top_index = q ; } return q ; }
int add_control_packet ( struct mt_packet * packet , enum mt_cptype cptype , void * cpdata , unsigned short data_len ) { unsigned char * data = packet -> data + packet -> size ; unsigned int act_size = data_len + ( cptype == MT_CPTYPE_PLAINDATA ? 0 : MT_CPHEADER_LEN ) ; <S2SV_StartBug> if ( packet -> size + act_size > MT_PACKET_LEN ) { <S2SV_EndBug> fprintf ( stderr , _ ( "add_control_packet:<S2SV_blank>ERROR,<S2SV_blank>too<S2SV_blank>large<S2SV_blank>packet.<S2SV_blank>Exceeds<S2SV_blank>%d<S2SV_blank>bytes\\n" ) , MT_PACKET_LEN ) ; return - 1 ; } if ( cptype == MT_CPTYPE_PLAINDATA ) { memcpy ( data , cpdata , data_len ) ; packet -> size += data_len ; return data_len ; } memcpy ( data , mt_mactelnet_cpmagic , sizeof ( mt_mactelnet_cpmagic ) ) ; data [ 4 ] = cptype ; # if BYTE_ORDER == LITTLE_ENDIAN { unsigned int templen ; templen = htonl ( data_len ) ; memcpy ( data + 5 , & templen , sizeof ( templen ) ) ; } # else memcpy ( data + 5 , & data_len , sizeof ( data_len ) ) ; # endif if ( data_len > 0 ) { memcpy ( data + MT_CPHEADER_LEN , cpdata , data_len ) ; } packet -> size += act_size ; return act_size ; }
static int msg_parse_fetch ( struct ImapHeader * h , char * s ) { char tmp [ SHORT_STRING ] ; char * ptmp = NULL ; if ( ! s ) return - 1 ; while ( * s ) { SKIPWS ( s ) ; if ( mutt_str_strncasecmp ( "FLAGS" , s , 5 ) == 0 ) { s = msg_parse_flags ( h , s ) ; if ( ! s ) return - 1 ; } else if ( mutt_str_strncasecmp ( "UID" , s , 3 ) == 0 ) { s += 3 ; SKIPWS ( s ) ; if ( mutt_str_atoui ( s , & h -> data -> uid ) < 0 ) return - 1 ; s = imap_next_word ( s ) ; } else if ( mutt_str_strncasecmp ( "INTERNALDATE" , s , 12 ) == 0 ) { s += 12 ; SKIPWS ( s ) ; if ( * s != \'\\"\' ) { mutt_debug ( 1 , "bogus<S2SV_blank>INTERNALDATE<S2SV_blank>entry:<S2SV_blank>%s\\n" , s ) ; return - 1 ; } s ++ ; ptmp = tmp ; <S2SV_StartBug> while ( * s && * s != \'\\"\' ) <S2SV_EndBug> * ptmp ++ = * s ++ ; if ( * s != \'\\"\' ) return - 1 ; s ++ ; * ptmp = '\\0' ; h -> received = mutt_date_parse_imap ( tmp ) ; } else if ( mutt_str_strncasecmp ( "RFC822.SIZE" , s , 11 ) == 0 ) { s += 11 ; SKIPWS ( s ) ; ptmp = tmp ; <S2SV_StartBug> while ( isdigit ( ( unsigned char ) * s ) ) <S2SV_EndBug> * ptmp ++ = * s ++ ; * ptmp = '\\0' ; if ( mutt_str_atol ( tmp , & h -> content_length ) < 0 ) return - 1 ; } else if ( ( mutt_str_strncasecmp ( "BODY" , s , 4 ) == 0 ) || ( mutt_str_strncasecmp ( "RFC822.HEADER" , s , 13 ) == 0 ) ) { return - 2 ; } else if ( * s == ')' ) s ++ ; else if ( * s ) { imap_error ( "msg_parse_fetch" , s ) ; return - 1 ; } } return 0 ; }
static M_bool M_fs_check_overwrite_allowed ( const char * p1 , const char * p2 , M_uint32 mode ) { M_fs_info_t * info = NULL ; char * pold = NULL ; char * pnew = NULL ; M_fs_type_t type ; M_bool ret = M_TRUE ; if ( mode & M_FS_FILE_MODE_OVERWRITE ) return M_TRUE ; if ( M_fs_info ( & info , p1 , M_FS_PATH_INFO_FLAGS_BASIC ) != M_FS_ERROR_SUCCESS ) return M_FALSE ; type = M_fs_info_get_type ( info ) ; M_fs_info_destroy ( info ) ; if ( type != M_FS_TYPE_DIR ) { if ( M_fs_perms_can_access ( p2 , M_FS_PERMS_MODE_NONE ) == M_FS_ERROR_SUCCESS ) { ret = M_FALSE ; goto done ; } } pold = M_fs_path_basename ( p1 , M_FS_SYSTEM_AUTO ) ; pnew = M_fs_path_join ( p2 , pnew , M_FS_SYSTEM_AUTO ) ; if ( M_fs_perms_can_access ( pnew , M_FS_PERMS_MODE_NONE ) == M_FS_ERROR_SUCCESS ) { ret = M_FALSE ; goto done ; } done : M_free ( pnew ) ; M_free ( pold ) ; return ret ; }
static int jas_iccgetuint32 ( jas_stream_t * in , jas_iccuint32_t * val ) { <S2SV_StartBug> ulonglong tmp ; <S2SV_EndBug> if ( jas_iccgetuint ( in , 4 , & tmp ) ) return - 1 ; * val = tmp ; return 0 ; }
static int ssl_scan_clienthello_tlsext ( SSL * s , PACKET * pkt , int * al ) { unsigned int type ; int renegotiate_seen = 0 ; PACKET extensions ; * al = SSL_AD_DECODE_ERROR ; s -> servername_done = 0 ; s -> tlsext_status_type = - 1 ; # ifndef OPENSSL_NO_NEXTPROTONEG s -> s3 -> next_proto_neg_seen = 0 ; # endif OPENSSL_free ( s -> s3 -> alpn_selected ) ; s -> s3 -> alpn_selected = NULL ; s -> s3 -> alpn_selected_len = 0 ; OPENSSL_free ( s -> s3 -> alpn_proposed ) ; s -> s3 -> alpn_proposed = NULL ; s -> s3 -> alpn_proposed_len = 0 ; # ifndef OPENSSL_NO_HEARTBEATS s -> tlsext_heartbeat &= ~ ( SSL_DTLSEXT_HB_ENABLED | SSL_DTLSEXT_HB_DONT_SEND_REQUESTS ) ; # endif # ifndef OPENSSL_NO_EC if ( s -> options & SSL_OP_SAFARI_ECDHE_ECDSA_BUG ) ssl_check_for_safari ( s , pkt ) ; # endif OPENSSL_free ( s -> s3 -> tmp . peer_sigalgs ) ; s -> s3 -> tmp . peer_sigalgs = NULL ; <S2SV_StartBug> s -> s3 -> flags &= ~ TLS1_FLAGS_ENCRYPT_THEN_MAC ; <S2SV_EndBug> # ifndef OPENSSL_NO_SRP OPENSSL_free ( s -> srp_ctx . login ) ; s -> srp_ctx . login = NULL ; # endif s -> srtp_profile = NULL ; if ( PACKET_remaining ( pkt ) == 0 ) goto ri_check ; if ( ! PACKET_as_length_prefixed_2 ( pkt , & extensions ) ) return 0 ; if ( ! tls1_check_duplicate_extensions ( & extensions ) ) return 0 ; while ( PACKET_get_net_2 ( & extensions , & type ) ) { PACKET extension ; if ( ! PACKET_get_length_prefixed_2 ( & extensions , & extension ) ) return 0 ; if ( s -> tlsext_debug_cb ) s -> tlsext_debug_cb ( s , 0 , type , PACKET_data ( & extension ) , PACKET_remaining ( & extension ) , s -> tlsext_debug_arg ) ; if ( type == TLSEXT_TYPE_renegotiate ) { if ( ! ssl_parse_clienthello_renegotiate_ext ( s , & extension , al ) ) return 0 ; renegotiate_seen = 1 ; } else if ( s -> version == SSL3_VERSION ) { } else if ( type == TLSEXT_TYPE_server_name ) { unsigned int servname_type ; PACKET sni , hostname ; if ( ! PACKET_as_length_prefixed_2 ( & extension , & sni ) || PACKET_remaining ( & sni ) == 0 ) { return 0 ; } if ( ! PACKET_get_1 ( & sni , & servname_type ) || servname_type != TLSEXT_NAMETYPE_host_name || ! PACKET_as_length_prefixed_2 ( & sni , & hostname ) ) { return 0 ; } if ( ! s -> hit ) { if ( PACKET_remaining ( & hostname ) > TLSEXT_MAXLEN_host_name ) { * al = TLS1_AD_UNRECOGNIZED_NAME ; return 0 ; } if ( PACKET_contains_zero_byte ( & hostname ) ) { * al = TLS1_AD_UNRECOGNIZED_NAME ; return 0 ; } if ( ! PACKET_strndup ( & hostname , & s -> session -> tlsext_hostname ) ) { * al = TLS1_AD_INTERNAL_ERROR ; return 0 ; } s -> servername_done = 1 ; } else { s -> servername_done = s -> session -> tlsext_hostname && PACKET_equal ( & hostname , s -> session -> tlsext_hostname , strlen ( s -> session -> tlsext_hostname ) ) ; } } # ifndef OPENSSL_NO_SRP else if ( type == TLSEXT_TYPE_srp ) { PACKET srp_I ; if ( ! PACKET_as_length_prefixed_1 ( & extension , & srp_I ) ) return 0 ; if ( PACKET_contains_zero_byte ( & srp_I ) ) return 0 ; if ( ! PACKET_strndup ( & srp_I , & s -> srp_ctx . login ) ) { * al = TLS1_AD_INTERNAL_ERROR ; return 0 ; } } # endif # ifndef OPENSSL_NO_EC else if ( type == TLSEXT_TYPE_ec_point_formats ) { PACKET ec_point_format_list ; if ( ! PACKET_as_length_prefixed_1 ( & extension , & ec_point_format_list ) || PACKET_remaining ( & ec_point_format_list ) == 0 ) { return 0 ; } if ( ! s -> hit ) { if ( ! PACKET_memdup ( & ec_point_format_list , & s -> session -> tlsext_ecpointformatlist , & s -> session -> tlsext_ecpointformatlist_length ) ) { * al = TLS1_AD_INTERNAL_ERROR ; return 0 ; } } } else if ( type == TLSEXT_TYPE_elliptic_curves ) { PACKET elliptic_curve_list ; if ( ! PACKET_as_length_prefixed_2 ( & extension , & elliptic_curve_list ) || PACKET_remaining ( & elliptic_curve_list ) == 0 || ( PACKET_remaining ( & elliptic_curve_list ) % 2 ) != 0 ) { return 0 ; } if ( ! s -> hit ) { if ( ! PACKET_memdup ( & elliptic_curve_list , & s -> session -> tlsext_ellipticcurvelist , & s -> session -> tlsext_ellipticcurvelist_length ) ) { * al = TLS1_AD_INTERNAL_ERROR ; return 0 ; } } } # endif else if ( type == TLSEXT_TYPE_session_ticket ) { if ( s -> tls_session_ticket_ext_cb && ! s -> tls_session_ticket_ext_cb ( s , PACKET_data ( & extension ) , PACKET_remaining ( & extension ) , s -> tls_session_ticket_ext_cb_arg ) ) { * al = TLS1_AD_INTERNAL_ERROR ; return 0 ; } } else if ( type == TLSEXT_TYPE_signature_algorithms ) { PACKET supported_sig_algs ; if ( ! PACKET_as_length_prefixed_2 ( & extension , & supported_sig_algs ) || ( PACKET_remaining ( & supported_sig_algs ) % 2 ) != 0 || PACKET_remaining ( & supported_sig_algs ) == 0 ) { return 0 ; } if ( ! s -> hit ) { if ( ! tls1_save_sigalgs ( s , PACKET_data ( & supported_sig_algs ) , PACKET_remaining ( & supported_sig_algs ) ) ) { return 0 ; } } } else if ( type == TLSEXT_TYPE_status_request ) { if ( ! PACKET_get_1 ( & extension , ( unsigned int * ) & s -> tlsext_status_type ) ) { return 0 ; } # ifndef OPENSSL_NO_OCSP if ( s -> tlsext_status_type == TLSEXT_STATUSTYPE_ocsp ) { const unsigned char * ext_data ; PACKET responder_id_list , exts ; if ( ! PACKET_get_length_prefixed_2 ( & extension , & responder_id_list ) ) return 0 ; sk_OCSP_RESPID_pop_free ( s -> tlsext_ocsp_ids , OCSP_RESPID_free ) ; if ( PACKET_remaining ( & responder_id_list ) > 0 ) { s -> tlsext_ocsp_ids = sk_OCSP_RESPID_new_null ( ) ; if ( s -> tlsext_ocsp_ids == NULL ) { * al = SSL_AD_INTERNAL_ERROR ; return 0 ; } } else { s -> tlsext_ocsp_ids = NULL ; } while ( PACKET_remaining ( & responder_id_list ) > 0 ) { OCSP_RESPID * id ; PACKET responder_id ; const unsigned char * id_data ; if ( ! PACKET_get_length_prefixed_2 ( & responder_id_list , & responder_id ) || PACKET_remaining ( & responder_id ) == 0 ) { return 0 ; } id_data = PACKET_data ( & responder_id ) ; id = d2i_OCSP_RESPID ( NULL , & id_data , PACKET_remaining ( & responder_id ) ) ; if ( id == NULL ) return 0 ; if ( id_data != PACKET_end ( & responder_id ) ) { OCSP_RESPID_free ( id ) ; return 0 ; } if ( ! sk_OCSP_RESPID_push ( s -> tlsext_ocsp_ids , id ) ) { OCSP_RESPID_free ( id ) ; * al = SSL_AD_INTERNAL_ERROR ; return 0 ; } } if ( ! PACKET_as_length_prefixed_2 ( & extension , & exts ) ) return 0 ; if ( PACKET_remaining ( & exts ) > 0 ) { ext_data = PACKET_data ( & exts ) ; sk_X509_EXTENSION_pop_free ( s -> tlsext_ocsp_exts , X509_EXTENSION_free ) ; s -> tlsext_ocsp_exts = d2i_X509_EXTENSIONS ( NULL , & ext_data , PACKET_remaining ( & exts ) ) ; if ( s -> tlsext_ocsp_exts == NULL || ext_data != PACKET_end ( & exts ) ) { return 0 ; } } } else # endif { s -> tlsext_status_type = - 1 ; } } # ifndef OPENSSL_NO_HEARTBEATS else if ( SSL_IS_DTLS ( s ) && type == TLSEXT_TYPE_heartbeat ) { unsigned int hbtype ; if ( ! PACKET_get_1 ( & extension , & hbtype ) || PACKET_remaining ( & extension ) ) { * al = SSL_AD_DECODE_ERROR ; return 0 ; } switch ( hbtype ) { case 0x01 : s -> tlsext_heartbeat |= SSL_DTLSEXT_HB_ENABLED ; break ; case 0x02 : s -> tlsext_heartbeat |= SSL_DTLSEXT_HB_ENABLED ; s -> tlsext_heartbeat |= SSL_DTLSEXT_HB_DONT_SEND_REQUESTS ; break ; default : * al = SSL_AD_ILLEGAL_PARAMETER ; return 0 ; } } # endif # ifndef OPENSSL_NO_NEXTPROTONEG else if ( type == TLSEXT_TYPE_next_proto_neg && s -> s3 -> tmp . finish_md_len == 0 ) { s -> s3 -> next_proto_neg_seen = 1 ; } # endif else if ( type == TLSEXT_TYPE_application_layer_protocol_negotiation && s -> s3 -> tmp . finish_md_len == 0 ) { if ( ! tls1_alpn_handle_client_hello ( s , & extension , al ) ) return 0 ; } # ifndef OPENSSL_NO_SRTP else if ( SSL_IS_DTLS ( s ) && SSL_get_srtp_profiles ( s ) && type == TLSEXT_TYPE_use_srtp ) { if ( ssl_parse_clienthello_use_srtp_ext ( s , & extension , al ) ) return 0 ; } # endif else if ( type == TLSEXT_TYPE_encrypt_then_mac ) <S2SV_StartBug> s -> s3 -> flags |= TLS1_FLAGS_ENCRYPT_THEN_MAC ; <S2SV_EndBug> else if ( ! s -> hit ) { if ( custom_ext_parse ( s , 1 , type , PACKET_data ( & extension ) , PACKET_remaining ( & extension ) , al ) <= 0 ) return 0 ; } } if ( PACKET_remaining ( pkt ) != 0 ) { * al = SSL_AD_INTERNAL_ERROR ; return 0 ; } ri_check : if ( ! renegotiate_seen && s -> renegotiate && ! ( s -> options & SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION ) ) { * al = SSL_AD_HANDSHAKE_FAILURE ; SSLerr ( SSL_F_SSL_SCAN_CLIENTHELLO_TLSEXT , SSL_R_UNSAFE_LEGACY_RENEGOTIATION_DISABLED ) ; return 0 ; } return 1 ; }
static void __xen_evtchn_do_upcall ( void ) { struct vcpu_info * vcpu_info = __this_cpu_read ( xen_vcpu ) ; <S2SV_StartBug> int cpu = smp_processor_id ( ) ; <S2SV_EndBug> do { vcpu_info -> evtchn_upcall_pending = 0 ; xen_evtchn_handle_events ( cpu ) ; BUG_ON ( ! irqs_disabled ( ) ) ; virt_rmb ( ) ; } while ( vcpu_info -> evtchn_upcall_pending ) ; <S2SV_StartBug> } <S2SV_EndBug>
static CURLcode smtp_connect ( struct connectdata * conn , bool * done ) { CURLcode result ; struct smtp_conn * smtpc = & conn -> proto . smtpc ; struct SessionHandle * data = conn -> data ; struct pingpong * pp = & smtpc -> pp ; <S2SV_StartBug> const char * path = conn -> data -> state . path ; <S2SV_EndBug> int len ; char localhost [ HOSTNAME_MAX + 1 ] ; * done = FALSE ; Curl_reset_reqproto ( conn ) ; result = smtp_init ( conn ) ; if ( CURLE_OK != result ) return result ; conn -> bits . close = FALSE ; pp -> response_time = RESP_TIMEOUT ; pp -> statemach_act = smtp_statemach_act ; pp -> endofresp = smtp_endofresp ; pp -> conn = conn ; if ( conn -> bits . tunnel_proxy && conn -> bits . httpproxy ) { struct HTTP http_proxy ; struct FTP * smtp_save ; smtp_save = data -> state . proto . smtp ; memset ( & http_proxy , 0 , sizeof ( http_proxy ) ) ; data -> state . proto . http = & http_proxy ; result = Curl_proxyCONNECT ( conn , FIRSTSOCKET , conn -> host . name , conn -> remote_port ) ; data -> state . proto . smtp = smtp_save ; if ( CURLE_OK != result ) return result ; } if ( ( conn -> handler -> protocol & CURLPROTO_SMTPS ) && data -> state . used_interface != Curl_if_multi ) { result = Curl_ssl_connect ( conn , FIRSTSOCKET ) ; if ( result ) return result ; } Curl_pp_init ( pp ) ; pp -> response_time = RESP_TIMEOUT ; pp -> statemach_act = smtp_statemach_act ; pp -> endofresp = smtp_endofresp ; pp -> conn = conn ; if ( ! * path ) { if ( ! Curl_gethostname ( localhost , sizeof localhost ) ) path = localhost ; else path = "localhost" ; } <S2SV_StartBug> smtpc -> domain = curl_easy_unescape ( conn -> data , path , 0 , & len ) ; <S2SV_EndBug> if ( ! smtpc -> domain ) return CURLE_OUT_OF_MEMORY ; state ( conn , SMTP_SERVERGREET ) ; if ( data -> state . used_interface == Curl_if_multi ) result = smtp_multi_statemach ( conn , done ) ; else { result = smtp_easy_statemach ( conn ) ; if ( ! result ) * done = TRUE ; } return result ; }
int mutt_seqset_iterator_next ( struct SeqsetIterator * iter , unsigned int * next ) { if ( ! iter || ! next ) return - 1 ; if ( iter -> in_range ) { if ( ( iter -> down && ( iter -> range_cur == ( iter -> range_end - 1 ) ) ) || ( ! iter -> down && ( iter -> range_cur == ( iter -> range_end + 1 ) ) ) ) { iter -> in_range = 0 ; } } if ( ! iter -> in_range ) { iter -> substr_cur = iter -> substr_end ; if ( iter -> substr_cur == iter -> eostr ) return 1 ; <S2SV_StartBug> while ( ! * ( iter -> substr_cur ) ) <S2SV_EndBug> iter -> substr_cur ++ ; iter -> substr_end = strchr ( iter -> substr_cur , ',' ) ; if ( ! iter -> substr_end ) iter -> substr_end = iter -> eostr ; else * ( iter -> substr_end ) = '\\0' ; char * range_sep = strchr ( iter -> substr_cur , ':' ) ; if ( range_sep ) * range_sep ++ = '\\0' ; if ( mutt_str_atoui ( iter -> substr_cur , & iter -> range_cur ) != 0 ) return - 1 ; if ( range_sep ) { if ( mutt_str_atoui ( range_sep , & iter -> range_end ) != 0 ) return - 1 ; } else iter -> range_end = iter -> range_cur ; iter -> down = ( iter -> range_end < iter -> range_cur ) ; iter -> in_range = 1 ; } * next = iter -> range_cur ; if ( iter -> down ) iter -> range_cur -- ; else iter -> range_cur ++ ; return 0 ; }
static void aodv_extension ( netdissect_options * ndo , const struct aodv_ext * ep , u_int length ) { <S2SV_StartBug> const struct aodv_hello * ah ; <S2SV_EndBug> switch ( ep -> type ) { case AODV_EXT_HELLO : ah = ( const struct aodv_hello * ) ( const void * ) ep ; ND_TCHECK ( * ah ) ; if ( length < sizeof ( struct aodv_hello ) ) <S2SV_StartBug> goto trunc ; <S2SV_EndBug> ND_PRINT ( ( ndo , "\\n\\text<S2SV_blank>HELLO<S2SV_blank>%ld<S2SV_blank>ms" , ( unsigned long ) EXTRACT_32BITS ( & ah -> interval ) ) ) ; break ; default : ND_PRINT ( ( ndo , "\\n\\text<S2SV_blank>%u<S2SV_blank>%u" , ep -> type , ep -> length ) ) ; break ; } return ; trunc : ND_PRINT ( ( ndo , "<S2SV_blank>[|hello]" ) ) ; }
static int filter_frame ( AVFilterLink * inlink , AVFrame * frame ) { AVFilterContext * ctx = inlink -> dst ; FieldOrderContext * s = ctx -> priv ; AVFilterLink * outlink = ctx -> outputs [ 0 ] ; int h , plane , line_step , line_size , line ; uint8_t * data ; if ( ! frame -> interlaced_frame || frame -> top_field_first == s -> dst_tff ) return ff_filter_frame ( outlink , frame ) ; av_dlog ( ctx , "picture<S2SV_blank>will<S2SV_blank>move<S2SV_blank>%s<S2SV_blank>one<S2SV_blank>line\\n" , s -> dst_tff ? "up" : "down" ) ; h = frame -> height ; <S2SV_StartBug> for ( plane = 0 ; plane < 4 && frame -> data [ plane ] ; plane ++ ) { <S2SV_EndBug> line_step = frame -> linesize [ plane ] ; line_size = s -> line_size [ plane ] ; data = frame -> data [ plane ] ; if ( s -> dst_tff ) { for ( line = 0 ; line < h ; line ++ ) { if ( 1 + line < frame -> height ) { memcpy ( data , data + line_step , line_size ) ; } else { memcpy ( data , data - line_step - line_step , line_size ) ; } data += line_step ; } } else { data += ( h - 1 ) * line_step ; for ( line = h - 1 ; line >= 0 ; line -- ) { if ( line > 0 ) { memcpy ( data , data - line_step , line_size ) ; } else { memcpy ( data , data + line_step + line_step , line_size ) ; } data -= line_step ; } } } frame -> top_field_first = s -> dst_tff ; return ff_filter_frame ( outlink , frame ) ; }
int main ( int argc , char * * argv ) { int result ; int error = FALSE ; int display_license = FALSE ; int display_help = FALSE ; int c = 0 ; struct tm * tm , tm_s ; time_t now ; char datestring [ 256 ] ; nagios_macros * mac ; const char * worker_socket = NULL ; int i ; # ifdef HAVE_SIGACTION struct sigaction sig_action ; # endif # ifdef HAVE_GETOPT_H int option_index = 0 ; static struct option long_options [ ] = { { "help" , no_argument , 0 , 'h' } , { "version" , no_argument , 0 , 'V' } , { "license" , no_argument , 0 , 'V' } , { "verify-config" , no_argument , 0 , 'v' } , { "daemon" , no_argument , 0 , 'd' } , { "test-scheduling" , no_argument , 0 , 's' } , { "precache-objects" , no_argument , 0 , 'p' } , { "use-precached-objects" , no_argument , 0 , 'u' } , { "enable-timing-point" , no_argument , 0 , 'T' } , { "worker" , required_argument , 0 , 'W' } , { 0 , 0 , 0 , 0 } } ; # define getopt ( argc , argv , o ) getopt_long ( argc , argv , o , long_options , & option_index ) # endif memset ( & loadctl , 0 , sizeof ( loadctl ) ) ; mac = get_global_macros ( ) ; if ( argc < 2 ) error = TRUE ; while ( 1 ) { c = getopt ( argc , argv , "+hVvdspuxTW" ) ; if ( c == - 1 || c == EOF ) break ; switch ( c ) { case '?' : case 'h' : display_help = TRUE ; break ; case 'V' : display_license = TRUE ; break ; case 'v' : verify_config ++ ; break ; case 's' : test_scheduling = TRUE ; break ; case 'd' : daemon_mode = TRUE ; break ; case 'p' : precache_objects = TRUE ; break ; case 'u' : use_precached_objects = TRUE ; break ; case 'T' : enable_timing_point = TRUE ; break ; case 'W' : worker_socket = optarg ; break ; case 'x' : printf ( "Warning:<S2SV_blank>-x<S2SV_blank>is<S2SV_blank>deprecated<S2SV_blank>and<S2SV_blank>will<S2SV_blank>be<S2SV_blank>removed\\n" ) ; break ; default : break ; } } # ifdef DEBUG_MEMORY mtrace ( ) ; # endif if ( worker_socket ) { exit ( nagios_core_worker ( worker_socket ) ) ; } init_main_cfg_vars ( 1 ) ; init_shared_cfg_vars ( 1 ) ; if ( daemon_mode == FALSE ) { printf ( "\\nNagios<S2SV_blank>Core<S2SV_blank>%s\\n" , PROGRAM_VERSION ) ; printf ( "Copyright<S2SV_blank>(c)<S2SV_blank>2009-present<S2SV_blank>Nagios<S2SV_blank>Core<S2SV_blank>Development<S2SV_blank>Team<S2SV_blank>and<S2SV_blank>Community<S2SV_blank>Contributors\\n" ) ; printf ( "Copyright<S2SV_blank>(c)<S2SV_blank>1999-2009<S2SV_blank>Ethan<S2SV_blank>Galstad\\n" ) ; printf ( "Last<S2SV_blank>Modified:<S2SV_blank>%s\\n" , PROGRAM_MODIFICATION_DATE ) ; printf ( "License:<S2SV_blank>GPL\\n\\n" ) ; printf ( "Website:<S2SV_blank>https://www.nagios.org\\n" ) ; } if ( display_license == TRUE ) { printf ( "This<S2SV_blank>program<S2SV_blank>is<S2SV_blank>free<S2SV_blank>software;<S2SV_blank>you<S2SV_blank>can<S2SV_blank>redistribute<S2SV_blank>it<S2SV_blank>and/or<S2SV_blank>modify\\n" ) ; printf ( "it<S2SV_blank>under<S2SV_blank>the<S2SV_blank>terms<S2SV_blank>of<S2SV_blank>the<S2SV_blank>GNU<S2SV_blank>General<S2SV_blank>Public<S2SV_blank>License<S2SV_blank>version<S2SV_blank>2<S2SV_blank>as\\n" ) ; printf ( "published<S2SV_blank>by<S2SV_blank>the<S2SV_blank>Free<S2SV_blank>Software<S2SV_blank>Foundation.\\n\\n" ) ; printf ( "This<S2SV_blank>program<S2SV_blank>is<S2SV_blank>distributed<S2SV_blank>in<S2SV_blank>the<S2SV_blank>hope<S2SV_blank>that<S2SV_blank>it<S2SV_blank>will<S2SV_blank>be<S2SV_blank>useful,\\n" ) ; printf ( "but<S2SV_blank>WITHOUT<S2SV_blank>ANY<S2SV_blank>WARRANTY;<S2SV_blank>without<S2SV_blank>even<S2SV_blank>the<S2SV_blank>implied<S2SV_blank>warranty<S2SV_blank>of\\n" ) ; printf ( "MERCHANTABILITY<S2SV_blank>or<S2SV_blank>FITNESS<S2SV_blank>FOR<S2SV_blank>A<S2SV_blank>PARTICULAR<S2SV_blank>PURPOSE.<S2SV_blank><S2SV_blank>See<S2SV_blank>the\\n" ) ; printf ( "GNU<S2SV_blank>General<S2SV_blank>Public<S2SV_blank>License<S2SV_blank>for<S2SV_blank>more<S2SV_blank>details.\\n\\n" ) ; printf ( "You<S2SV_blank>should<S2SV_blank>have<S2SV_blank>received<S2SV_blank>a<S2SV_blank>copy<S2SV_blank>of<S2SV_blank>the<S2SV_blank>GNU<S2SV_blank>General<S2SV_blank>Public<S2SV_blank>License\\n" ) ; printf ( "along<S2SV_blank>with<S2SV_blank>this<S2SV_blank>program;<S2SV_blank>if<S2SV_blank>not,<S2SV_blank>write<S2SV_blank>to<S2SV_blank>the<S2SV_blank>Free<S2SV_blank>Software\\n" ) ; printf ( "Foundation,<S2SV_blank>Inc.,<S2SV_blank>675<S2SV_blank>Mass<S2SV_blank>Ave,<S2SV_blank>Cambridge,<S2SV_blank>MA<S2SV_blank>02139,<S2SV_blank>USA.\\n\\n" ) ; exit ( OK ) ; } if ( optind >= argc ) error = TRUE ; if ( error == TRUE || display_help == TRUE ) { printf ( "Usage:<S2SV_blank>%s<S2SV_blank>[options]<S2SV_blank><main_config_file>\\n" , argv [ 0 ] ) ; printf ( "\\n" ) ; printf ( "Options:\\n" ) ; printf ( "\\n" ) ; printf ( "<S2SV_blank><S2SV_blank>-v,<S2SV_blank>--verify-config<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Verify<S2SV_blank>all<S2SV_blank>configuration<S2SV_blank>data<S2SV_blank>(-v<S2SV_blank>-v<S2SV_blank>for<S2SV_blank>more<S2SV_blank>info)\\n" ) ; printf ( "<S2SV_blank><S2SV_blank>-s,<S2SV_blank>--test-scheduling<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Shows<S2SV_blank>projected/recommended<S2SV_blank>check<S2SV_blank>scheduling<S2SV_blank>and<S2SV_blank>other\\n" ) ; printf ( "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>diagnostic<S2SV_blank>info<S2SV_blank>based<S2SV_blank>on<S2SV_blank>the<S2SV_blank>current<S2SV_blank>configuration<S2SV_blank>files.\\n" ) ; printf ( "<S2SV_blank><S2SV_blank>-T,<S2SV_blank>--enable-timing-point<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Enable<S2SV_blank>timed<S2SV_blank>commentary<S2SV_blank>on<S2SV_blank>initialization\\n" ) ; printf ( "<S2SV_blank><S2SV_blank>-x,<S2SV_blank>--dont-verify-paths<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Deprecated<S2SV_blank>(Don\'t<S2SV_blank>check<S2SV_blank>for<S2SV_blank>circular<S2SV_blank>object<S2SV_blank>paths)\\n" ) ; printf ( "<S2SV_blank><S2SV_blank>-p,<S2SV_blank>--precache-objects<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Precache<S2SV_blank>object<S2SV_blank>configuration\\n" ) ; printf ( "<S2SV_blank><S2SV_blank>-u,<S2SV_blank>--use-precached-objects<S2SV_blank><S2SV_blank>Use<S2SV_blank>precached<S2SV_blank>object<S2SV_blank>config<S2SV_blank>file\\n" ) ; printf ( "<S2SV_blank><S2SV_blank>-d,<S2SV_blank>--daemon<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Starts<S2SV_blank>Nagios<S2SV_blank>in<S2SV_blank>daemon<S2SV_blank>mode,<S2SV_blank>instead<S2SV_blank>of<S2SV_blank>as<S2SV_blank>a<S2SV_blank>foreground<S2SV_blank>process\\n" ) ; printf ( "<S2SV_blank><S2SV_blank>-W,<S2SV_blank>--worker<S2SV_blank>/path/to/socket<S2SV_blank>Act<S2SV_blank>as<S2SV_blank>a<S2SV_blank>worker<S2SV_blank>for<S2SV_blank>an<S2SV_blank>already<S2SV_blank>running<S2SV_blank>daemon\\n" ) ; printf ( "\\n" ) ; printf ( "Visit<S2SV_blank>the<S2SV_blank>Nagios<S2SV_blank>website<S2SV_blank>at<S2SV_blank>https://www.nagios.org/<S2SV_blank>for<S2SV_blank>bug<S2SV_blank>fixes,<S2SV_blank>new\\n" ) ; printf ( "releases,<S2SV_blank>online<S2SV_blank>documentation,<S2SV_blank>FAQs,<S2SV_blank>information<S2SV_blank>on<S2SV_blank>subscribing<S2SV_blank>to\\n" ) ; printf ( "the<S2SV_blank>mailing<S2SV_blank>lists,<S2SV_blank>and<S2SV_blank>commercial<S2SV_blank>support<S2SV_blank>options<S2SV_blank>for<S2SV_blank>Nagios.\\n" ) ; printf ( "\\n" ) ; exit ( ERROR ) ; } config_file = nspath_absolute ( argv [ optind ] , NULL ) ; if ( config_file == NULL ) { printf ( "Error<S2SV_blank>allocating<S2SV_blank>memory.\\n" ) ; exit ( ERROR ) ; } config_file_dir = nspath_absolute_dirname ( config_file , NULL ) ; # ifdef HAVE_SIGACTION sig_action . sa_sigaction = NULL ; sig_action . sa_handler = handle_sigxfsz ; sigfillset ( & sig_action . sa_mask ) ; sig_action . sa_flags = SA_NODEFER | SA_RESTART ; sigaction ( SIGXFSZ , & sig_action , NULL ) ; # else signal ( SIGXFSZ , handle_sigxfsz ) ; # endif if ( verify_config || test_scheduling || precache_objects ) { reset_variables ( ) ; set_loadctl_defaults ( ) ; if ( verify_config ) printf ( "Reading<S2SV_blank>configuration<S2SV_blank>data...\\n" ) ; result = read_main_config_file ( config_file ) ; if ( result != OK ) { printf ( "<S2SV_blank><S2SV_blank><S2SV_blank>Error<S2SV_blank>processing<S2SV_blank>main<S2SV_blank>config<S2SV_blank>file!\\n\\n" ) ; exit ( EXIT_FAILURE ) ; } if ( verify_config ) printf ( "<S2SV_blank><S2SV_blank><S2SV_blank>Read<S2SV_blank>main<S2SV_blank>config<S2SV_blank>file<S2SV_blank>okay...\\n" ) ; if ( ( result = drop_privileges ( nagios_user , nagios_group ) ) == ERROR ) { printf ( "<S2SV_blank><S2SV_blank><S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>drop<S2SV_blank>privileges.<S2SV_blank><S2SV_blank>Aborting." ) ; exit ( EXIT_FAILURE ) ; } if ( ! verify_config && test_configured_paths ( ) == ERROR ) { printf ( "<S2SV_blank><S2SV_blank><S2SV_blank>One<S2SV_blank>or<S2SV_blank>more<S2SV_blank>path<S2SV_blank>problems<S2SV_blank>detected.<S2SV_blank>Aborting.\\n" ) ; exit ( EXIT_FAILURE ) ; } result = read_all_object_data ( config_file ) ; if ( result != OK ) { printf ( "<S2SV_blank><S2SV_blank><S2SV_blank>Error<S2SV_blank>processing<S2SV_blank>object<S2SV_blank>config<S2SV_blank>files!\\n\\n" ) ; if ( ! strstr ( config_file , "nagios.cfg" ) ) { printf ( "\\n***><S2SV_blank>The<S2SV_blank>name<S2SV_blank>of<S2SV_blank>the<S2SV_blank>main<S2SV_blank>configuration<S2SV_blank>file<S2SV_blank>looks<S2SV_blank>suspicious...\\n" ) ; printf ( "\\n" ) ; printf ( "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Make<S2SV_blank>sure<S2SV_blank>you<S2SV_blank>are<S2SV_blank>specifying<S2SV_blank>the<S2SV_blank>name<S2SV_blank>of<S2SV_blank>the<S2SV_blank>MAIN<S2SV_blank>configuration<S2SV_blank>file<S2SV_blank>on\\n" ) ; printf ( "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>the<S2SV_blank>command<S2SV_blank>line<S2SV_blank>and<S2SV_blank>not<S2SV_blank>the<S2SV_blank>name<S2SV_blank>of<S2SV_blank>another<S2SV_blank>configuration<S2SV_blank>file.<S2SV_blank><S2SV_blank>The\\n" ) ; printf ( "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>main<S2SV_blank>configuration<S2SV_blank>file<S2SV_blank>is<S2SV_blank>typically<S2SV_blank>\'%s\'\\n" , DEFAULT_CONFIG_FILE ) ; } printf ( "\\n***><S2SV_blank>One<S2SV_blank>or<S2SV_blank>more<S2SV_blank>problems<S2SV_blank>was<S2SV_blank>encountered<S2SV_blank>while<S2SV_blank>processing<S2SV_blank>the<S2SV_blank>config<S2SV_blank>files...\\n" ) ; printf ( "\\n" ) ; printf ( "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Check<S2SV_blank>your<S2SV_blank>configuration<S2SV_blank>file(s)<S2SV_blank>to<S2SV_blank>ensure<S2SV_blank>that<S2SV_blank>they<S2SV_blank>contain<S2SV_blank>valid\\n" ) ; printf ( "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>directives<S2SV_blank>and<S2SV_blank>data<S2SV_blank>definitions.<S2SV_blank><S2SV_blank>If<S2SV_blank>you<S2SV_blank>are<S2SV_blank>upgrading<S2SV_blank>from<S2SV_blank>a<S2SV_blank>previous\\n" ) ; printf ( "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>version<S2SV_blank>of<S2SV_blank>Nagios,<S2SV_blank>you<S2SV_blank>should<S2SV_blank>be<S2SV_blank>aware<S2SV_blank>that<S2SV_blank>some<S2SV_blank>variables/definitions\\n" ) ; printf ( "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>may<S2SV_blank>have<S2SV_blank>been<S2SV_blank>removed<S2SV_blank>or<S2SV_blank>modified<S2SV_blank>in<S2SV_blank>this<S2SV_blank>version.<S2SV_blank><S2SV_blank>Make<S2SV_blank>sure<S2SV_blank>to<S2SV_blank>read\\n" ) ; printf ( "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>the<S2SV_blank>HTML<S2SV_blank>documentation<S2SV_blank>regarding<S2SV_blank>the<S2SV_blank>config<S2SV_blank>files,<S2SV_blank>as<S2SV_blank>well<S2SV_blank>as<S2SV_blank>the\\n" ) ; printf ( "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>\'Whats<S2SV_blank>New\'<S2SV_blank>section<S2SV_blank>to<S2SV_blank>find<S2SV_blank>out<S2SV_blank>what<S2SV_blank>has<S2SV_blank>changed.\\n\\n" ) ; exit ( EXIT_FAILURE ) ; } if ( verify_config ) { printf ( "<S2SV_blank><S2SV_blank><S2SV_blank>Read<S2SV_blank>object<S2SV_blank>config<S2SV_blank>files<S2SV_blank>okay...\\n\\n" ) ; printf ( "Running<S2SV_blank>pre-flight<S2SV_blank>check<S2SV_blank>on<S2SV_blank>configuration<S2SV_blank>data...\\n\\n" ) ; } result = pre_flight_check ( ) ; if ( result != OK ) { printf ( "\\n***><S2SV_blank>One<S2SV_blank>or<S2SV_blank>more<S2SV_blank>problems<S2SV_blank>was<S2SV_blank>encountered<S2SV_blank>while<S2SV_blank>running<S2SV_blank>the<S2SV_blank>pre-flight<S2SV_blank>check...\\n" ) ; printf ( "\\n" ) ; printf ( "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>Check<S2SV_blank>your<S2SV_blank>configuration<S2SV_blank>file(s)<S2SV_blank>to<S2SV_blank>ensure<S2SV_blank>that<S2SV_blank>they<S2SV_blank>contain<S2SV_blank>valid\\n" ) ; printf ( "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>directives<S2SV_blank>and<S2SV_blank>data<S2SV_blank>definitions.<S2SV_blank><S2SV_blank>If<S2SV_blank>you<S2SV_blank>are<S2SV_blank>upgrading<S2SV_blank>from<S2SV_blank>a<S2SV_blank>previous\\n" ) ; printf ( "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>version<S2SV_blank>of<S2SV_blank>Nagios,<S2SV_blank>you<S2SV_blank>should<S2SV_blank>be<S2SV_blank>aware<S2SV_blank>that<S2SV_blank>some<S2SV_blank>variables/definitions\\n" ) ; printf ( "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>may<S2SV_blank>have<S2SV_blank>been<S2SV_blank>removed<S2SV_blank>or<S2SV_blank>modified<S2SV_blank>in<S2SV_blank>this<S2SV_blank>version.<S2SV_blank><S2SV_blank>Make<S2SV_blank>sure<S2SV_blank>to<S2SV_blank>read\\n" ) ; printf ( "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>the<S2SV_blank>HTML<S2SV_blank>documentation<S2SV_blank>regarding<S2SV_blank>the<S2SV_blank>config<S2SV_blank>files,<S2SV_blank>as<S2SV_blank>well<S2SV_blank>as<S2SV_blank>the\\n" ) ; printf ( "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>\'Whats<S2SV_blank>New\'<S2SV_blank>section<S2SV_blank>to<S2SV_blank>find<S2SV_blank>out<S2SV_blank>what<S2SV_blank>has<S2SV_blank>changed.\\n\\n" ) ; exit ( EXIT_FAILURE ) ; } if ( verify_config ) { printf ( "\\nThings<S2SV_blank>look<S2SV_blank>okay<S2SV_blank>-<S2SV_blank>No<S2SV_blank>serious<S2SV_blank>problems<S2SV_blank>were<S2SV_blank>detected<S2SV_blank>during<S2SV_blank>the<S2SV_blank>pre-flight<S2SV_blank>check\\n" ) ; } if ( test_scheduling == TRUE ) { init_event_queue ( ) ; timing_point ( "Done<S2SV_blank>initializing<S2SV_blank>event<S2SV_blank>queue\\n" ) ; initialize_retention_data ( config_file ) ; read_initial_state_information ( ) ; timing_point ( "Retention<S2SV_blank>data<S2SV_blank>and<S2SV_blank>initial<S2SV_blank>state<S2SV_blank>parsed\\n" ) ; init_timing_loop ( ) ; timing_point ( "Timing<S2SV_blank>loop<S2SV_blank>initialized\\n" ) ; display_scheduling_info ( ) ; } if ( precache_objects ) { result = fcache_objects ( object_precache_file ) ; timing_point ( "Done<S2SV_blank>precaching<S2SV_blank>objects\\n" ) ; if ( result == OK ) { printf ( "Object<S2SV_blank>precache<S2SV_blank>file<S2SV_blank>created:\\n%s\\n" , object_precache_file ) ; } else { printf ( "Failed<S2SV_blank>to<S2SV_blank>precache<S2SV_blank>objects<S2SV_blank>to<S2SV_blank>\'%s\':<S2SV_blank>%s\\n" , object_precache_file , strerror ( errno ) ) ; } } cleanup ( ) ; timing_point ( "Exiting\\n" ) ; neb_free_module_list ( ) ; free ( config_file_dir ) ; free ( config_file ) ; exit ( result ) ; } else { if ( strchr ( argv [ 0 ] , '/' ) ) nagios_binary_path = nspath_absolute ( argv [ 0 ] , NULL ) ; else nagios_binary_path = strdup ( argv [ 0 ] ) ; if ( ! nagios_binary_path ) { logit ( NSLOG_RUNTIME_ERROR , TRUE , "Error:<S2SV_blank>Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>nagios_binary_path\\n" ) ; exit ( EXIT_FAILURE ) ; } if ( ! ( nagios_iobs = iobroker_create ( ) ) ) { logit ( NSLOG_RUNTIME_ERROR , TRUE , "Error:<S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>IO<S2SV_blank>broker<S2SV_blank>set:<S2SV_blank>%s\\n" , strerror ( errno ) ) ; exit ( EXIT_FAILURE ) ; } do { wproc_num_workers_spawned = wproc_num_workers_online = 0 ; caught_signal = sigshutdown = FALSE ; sig_id = 0 ; reset_variables ( ) ; timing_point ( "Variables<S2SV_blank>reset\\n" ) ; nagios_pid = ( int ) getpid ( ) ; result = read_main_config_file ( config_file ) ; if ( result != OK ) { logit ( NSLOG_CONFIG_ERROR , TRUE , "Error:<S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>process<S2SV_blank>config<S2SV_blank>file<S2SV_blank>\'%s\'.<S2SV_blank>Aborting\\n" , config_file ) ; exit ( EXIT_FAILURE ) ; } timing_point ( "Main<S2SV_blank>config<S2SV_blank>file<S2SV_blank>read\\n" ) ; program_start = time ( NULL ) ; my_free ( mac -> x [ MACRO_PROCESSSTARTTIME ] ) ; asprintf ( & mac -> x [ MACRO_PROCESSSTARTTIME ] , "%llu" , ( unsigned long long ) program_start ) ; <S2SV_StartBug> if ( drop_privileges ( nagios_user , nagios_group ) == ERROR ) { <S2SV_EndBug> logit ( NSLOG_PROCESS_INFO | NSLOG_RUNTIME_ERROR | NSLOG_CONFIG_ERROR , TRUE , "Failed<S2SV_blank>to<S2SV_blank>drop<S2SV_blank>privileges.<S2SV_blank><S2SV_blank>Aborting." ) ; cleanup ( ) ; exit ( ERROR ) ; } if ( test_path_access ( nagios_binary_path , X_OK ) ) { logit ( NSLOG_RUNTIME_ERROR , TRUE , "Error:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>access()<S2SV_blank>%s:<S2SV_blank>%s\\n" , nagios_binary_path , strerror ( errno ) ) ; logit ( NSLOG_RUNTIME_ERROR , TRUE , "Error:<S2SV_blank>Spawning<S2SV_blank>workers<S2SV_blank>will<S2SV_blank>be<S2SV_blank>impossible.<S2SV_blank>Aborting.\\n" ) ; exit ( EXIT_FAILURE ) ; } if ( test_configured_paths ( ) == ERROR ) { <S2SV_StartBug> exit ( EXIT_FAILURE ) ; <S2SV_EndBug> } if ( daemon_mode == TRUE && sigrestart == FALSE ) { result = daemon_init ( ) ; if ( result == ERROR ) { logit ( NSLOG_PROCESS_INFO | NSLOG_RUNTIME_ERROR , TRUE , "Bailing<S2SV_blank>out<S2SV_blank>due<S2SV_blank>to<S2SV_blank>failure<S2SV_blank>to<S2SV_blank>daemonize.<S2SV_blank>(PID=%d)" , ( int ) getpid ( ) ) ; cleanup ( ) ; exit ( EXIT_FAILURE ) ; } nagios_pid = ( int ) getpid ( ) ; } logit ( NSLOG_PROCESS_INFO , TRUE , "Nagios<S2SV_blank>%s<S2SV_blank>starting...<S2SV_blank>(PID=%d)\\n" , PROGRAM_VERSION , ( int ) getpid ( ) ) ; now = time ( NULL ) ; tm = localtime_r ( & now , & tm_s ) ; strftime ( datestring , sizeof ( datestring ) , "%a<S2SV_blank>%b<S2SV_blank>%d<S2SV_blank>%H:%M:%S<S2SV_blank>%Z<S2SV_blank>%Y" , tm ) ; logit ( NSLOG_PROCESS_INFO , TRUE , "Local<S2SV_blank>time<S2SV_blank>is<S2SV_blank>%s" , datestring ) ; write_log_file_info ( NULL ) ; open_debug_log ( ) ; # ifdef USE_EVENT_BROKER neb_init_modules ( ) ; neb_init_callback_list ( ) ; # endif timing_point ( "NEB<S2SV_blank>module<S2SV_blank>API<S2SV_blank>initialized\\n" ) ; setup_sighandler ( ) ; if ( qh_init ( qh_socket_path ? qh_socket_path : DEFAULT_QUERY_SOCKET ) != OK ) { logit ( NSLOG_RUNTIME_ERROR , TRUE , "Error:<S2SV_blank>Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>query<S2SV_blank>handler.<S2SV_blank>Aborting\\n" ) ; exit ( EXIT_FAILURE ) ; } timing_point ( "Query<S2SV_blank>handler<S2SV_blank>initialized\\n" ) ; nerd_init ( ) ; timing_point ( "NERD<S2SV_blank>initialized\\n" ) ; if ( init_workers ( num_check_workers ) < 0 ) { logit ( NSLOG_RUNTIME_ERROR , TRUE , "Failed<S2SV_blank>to<S2SV_blank>spawn<S2SV_blank>workers.<S2SV_blank>Aborting\\n" ) ; exit ( EXIT_FAILURE ) ; } timing_point ( "%u<S2SV_blank>workers<S2SV_blank>spawned\\n" , wproc_num_workers_spawned ) ; i = 0 ; while ( i < 50 && wproc_num_workers_online < wproc_num_workers_spawned ) { iobroker_poll ( nagios_iobs , 50 ) ; i ++ ; } timing_point ( "%u<S2SV_blank>workers<S2SV_blank>connected\\n" , wproc_num_workers_online ) ; set_loadctl_defaults ( ) ; # ifdef USE_EVENT_BROKER if ( neb_load_all_modules ( ) != OK ) { logit ( NSLOG_CONFIG_ERROR , ERROR , "Error:<S2SV_blank>Module<S2SV_blank>loading<S2SV_blank>failed.<S2SV_blank>Aborting.\\n" ) ; if ( daemon_dumps_core ) neb_unload_all_modules ( NEBMODULE_FORCE_UNLOAD , NEBMODULE_NEB_SHUTDOWN ) ; exit ( EXIT_FAILURE ) ; } timing_point ( "Modules<S2SV_blank>loaded\\n" ) ; broker_program_state ( NEBTYPE_PROCESS_PRELAUNCH , NEBFLAG_NONE , NEBATTR_NONE , NULL ) ; timing_point ( "First<S2SV_blank>callback<S2SV_blank>made\\n" ) ; # endif if ( result == OK ) result = read_all_object_data ( config_file ) ; if ( result != OK ) logit ( NSLOG_PROCESS_INFO | NSLOG_RUNTIME_ERROR | NSLOG_CONFIG_ERROR , TRUE , "Bailing<S2SV_blank>out<S2SV_blank>due<S2SV_blank>to<S2SV_blank>one<S2SV_blank>or<S2SV_blank>more<S2SV_blank>errors<S2SV_blank>encountered<S2SV_blank>in<S2SV_blank>the<S2SV_blank>configuration<S2SV_blank>files.<S2SV_blank>Run<S2SV_blank>Nagios<S2SV_blank>from<S2SV_blank>the<S2SV_blank>command<S2SV_blank>line<S2SV_blank>with<S2SV_blank>the<S2SV_blank>-v<S2SV_blank>option<S2SV_blank>to<S2SV_blank>verify<S2SV_blank>your<S2SV_blank>config<S2SV_blank>before<S2SV_blank>restarting.<S2SV_blank>(PID=%d)" , ( int ) getpid ( ) ) ; else { if ( ( result = pre_flight_check ( ) ) != OK ) logit ( NSLOG_PROCESS_INFO | NSLOG_RUNTIME_ERROR | NSLOG_VERIFICATION_ERROR , TRUE , "Bailing<S2SV_blank>out<S2SV_blank>due<S2SV_blank>to<S2SV_blank>errors<S2SV_blank>encountered<S2SV_blank>while<S2SV_blank>running<S2SV_blank>the<S2SV_blank>pre-flight<S2SV_blank>check.<S2SV_blank><S2SV_blank>Run<S2SV_blank>Nagios<S2SV_blank>from<S2SV_blank>the<S2SV_blank>command<S2SV_blank>line<S2SV_blank>with<S2SV_blank>the<S2SV_blank>-v<S2SV_blank>option<S2SV_blank>to<S2SV_blank>verify<S2SV_blank>your<S2SV_blank>config<S2SV_blank>before<S2SV_blank>restarting.<S2SV_blank>(PID=%d)\\n" , ( int ) getpid ( ) ) ; } if ( result != OK ) { if ( sigrestart == TRUE ) { cleanup_status_data ( TRUE ) ; } # ifdef USE_EVENT_BROKER broker_program_state ( NEBTYPE_PROCESS_SHUTDOWN , NEBFLAG_PROCESS_INITIATED , NEBATTR_SHUTDOWN_ABNORMAL , NULL ) ; # endif cleanup ( ) ; exit ( ERROR ) ; } timing_point ( "Object<S2SV_blank>configuration<S2SV_blank>parsed<S2SV_blank>and<S2SV_blank>understood\\n" ) ; fcache_objects ( object_cache_file ) ; timing_point ( "Objects<S2SV_blank>cached\\n" ) ; init_event_queue ( ) ; timing_point ( "Event<S2SV_blank>queue<S2SV_blank>initialized\\n" ) ; # ifdef USE_EVENT_BROKER broker_program_state ( NEBTYPE_PROCESS_START , NEBFLAG_NONE , NEBATTR_NONE , NULL ) ; # endif if ( sigrestart == FALSE ) { initialize_status_data ( config_file ) ; timing_point ( "Status<S2SV_blank>data<S2SV_blank>initialized\\n" ) ; } initialize_downtime_data ( ) ; timing_point ( "Downtime<S2SV_blank>data<S2SV_blank>initialized\\n" ) ; initialize_retention_data ( config_file ) ; timing_point ( "Retention<S2SV_blank>data<S2SV_blank>initialized\\n" ) ; read_initial_state_information ( ) ; timing_point ( "Initial<S2SV_blank>state<S2SV_blank>information<S2SV_blank>read\\n" ) ; initialize_comment_data ( ) ; timing_point ( "Comment<S2SV_blank>data<S2SV_blank>initialized\\n" ) ; initialize_performance_data ( config_file ) ; timing_point ( "Performance<S2SV_blank>data<S2SV_blank>initialized\\n" ) ; init_timing_loop ( ) ; timing_point ( "Event<S2SV_blank>timing<S2SV_blank>loop<S2SV_blank>initialized\\n" ) ; init_check_stats ( ) ; timing_point ( "check<S2SV_blank>stats<S2SV_blank>initialized\\n" ) ; check_for_nagios_updates ( FALSE , TRUE ) ; timing_point ( "Update<S2SV_blank>check<S2SV_blank>concluded\\n" ) ; update_all_status_data ( ) ; timing_point ( "Status<S2SV_blank>data<S2SV_blank>updated\\n" ) ; log_host_states ( INITIAL_STATES , NULL ) ; log_service_states ( INITIAL_STATES , NULL ) ; timing_point ( "Initial<S2SV_blank>states<S2SV_blank>logged\\n" ) ; sigrestart = FALSE ; launch_command_file_worker ( ) ; timing_point ( "Command<S2SV_blank>file<S2SV_blank>worker<S2SV_blank>launched\\n" ) ; # ifdef USE_EVENT_BROKER broker_program_state ( NEBTYPE_PROCESS_EVENTLOOPSTART , NEBFLAG_NONE , NEBATTR_NONE , NULL ) ; # endif event_start = time ( NULL ) ; my_free ( mac -> x [ MACRO_EVENTSTARTTIME ] ) ; asprintf ( & mac -> x [ MACRO_EVENTSTARTTIME ] , "%llu" , ( unsigned long long ) event_start ) ; timing_point ( "Entering<S2SV_blank>event<S2SV_blank>execution<S2SV_blank>loop\\n" ) ; event_execution_loop ( ) ; qh_deinit ( qh_socket_path ? qh_socket_path : DEFAULT_QUERY_SOCKET ) ; if ( caught_signal == TRUE ) { if ( sig_id == SIGHUP ) logit ( NSLOG_PROCESS_INFO , TRUE , "Caught<S2SV_blank>SIGHUP,<S2SV_blank>restarting...\\n" ) ; } # ifdef USE_EVENT_BROKER broker_program_state ( NEBTYPE_PROCESS_EVENTLOOPEND , NEBFLAG_NONE , NEBATTR_NONE , NULL ) ; if ( sigshutdown == TRUE ) broker_program_state ( NEBTYPE_PROCESS_SHUTDOWN , NEBFLAG_USER_INITIATED , NEBATTR_SHUTDOWN_NORMAL , NULL ) ; else if ( sigrestart == TRUE ) broker_program_state ( NEBTYPE_PROCESS_RESTART , NEBFLAG_USER_INITIATED , NEBATTR_RESTART_NORMAL , NULL ) ; # endif save_state_information ( FALSE ) ; cleanup_retention_data ( ) ; cleanup_performance_data ( ) ; cleanup_downtime_data ( ) ; if ( sigrestart == FALSE ) { cleanup_status_data ( TRUE ) ; } free_worker_memory ( WPROC_FORCE ) ; if ( sigshutdown == TRUE ) { iobroker_destroy ( nagios_iobs , IOBROKER_CLOSE_SOCKETS ) ; nagios_iobs = NULL ; logit ( NSLOG_PROCESS_INFO , TRUE , "Successfully<S2SV_blank>shutdown...<S2SV_blank>(PID=%d)\\n" , ( int ) getpid ( ) ) ; } cleanup ( ) ; close_debug_log ( ) ; } while ( sigrestart == TRUE && sigshutdown == FALSE ) ; if ( daemon_mode == TRUE ) unlink ( lock_file ) ; my_free ( lock_file ) ; my_free ( config_file ) ; my_free ( config_file_dir ) ; my_free ( nagios_binary_path ) ; } return OK ; }
static int cdrom_ioctl_drive_status ( struct cdrom_device_info * cdi , unsigned long arg ) { cd_dbg ( CD_DO_IOCTL , "entering<S2SV_blank>CDROM_DRIVE_STATUS\\n" ) ; if ( ! ( cdi -> ops -> capability & CDC_DRIVE_STATUS ) ) return - ENOSYS ; if ( ! CDROM_CAN ( CDC_SELECT_DISC ) || ( arg == CDSL_CURRENT || arg == CDSL_NONE ) ) return cdi -> ops -> drive_status ( cdi , CDSL_CURRENT ) ; <S2SV_StartBug> if ( ( ( int ) arg >= cdi -> capacity ) ) <S2SV_EndBug> return - EINVAL ; return cdrom_slot_status ( cdi , arg ) ; }
void vp9_rc_set_frame_target ( VP9_COMP * cpi , int target ) { const VP9_COMMON * const cm = & cpi -> common ; RATE_CONTROL * const rc = & cpi -> rc ; rc -> this_frame_target = target ; <S2SV_StartBug> rc -> sb64_target_rate = ( ( int64_t ) rc -> this_frame_target * 64 * 64 ) / <S2SV_EndBug> ( cm -> width * cm -> height ) ; }
static void diff_bytes_c ( uint8_t * dst , const uint8_t * src1 , const uint8_t * src2 , int w ) { long i ; # if ! HAVE_FAST_UNALIGNED if ( ( long ) src2 & ( sizeof ( long ) - 1 ) ) { for ( i = 0 ; i + 7 < w ; i += 8 ) { dst [ i + 0 ] = src1 [ i + 0 ] - src2 [ i + 0 ] ; dst [ i + 1 ] = src1 [ i + 1 ] - src2 [ i + 1 ] ; dst [ i + 2 ] = src1 [ i + 2 ] - src2 [ i + 2 ] ; dst [ i + 3 ] = src1 [ i + 3 ] - src2 [ i + 3 ] ; dst [ i + 4 ] = src1 [ i + 4 ] - src2 [ i + 4 ] ; dst [ i + 5 ] = src1 [ i + 5 ] - src2 [ i + 5 ] ; dst [ i + 6 ] = src1 [ i + 6 ] - src2 [ i + 6 ] ; dst [ i + 7 ] = src1 [ i + 7 ] - src2 [ i + 7 ] ; } } else # endif <S2SV_StartBug> for ( i = 0 ; i <= w - sizeof ( long ) ; i += sizeof ( long ) ) { <S2SV_EndBug> long a = * ( long * ) ( src1 + i ) ; long b = * ( long * ) ( src2 + i ) ; * ( long * ) ( dst + i ) = ( ( a | pb_80 ) - ( b & pb_7f ) ) ^ ( ( a ^ b ^ pb_80 ) & pb_80 ) ; } for ( ; i < w ; i ++ ) dst [ i + 0 ] = src1 [ i + 0 ] - src2 [ i + 0 ] ; }
int fit_check_format ( const void * fit , ulong size ) { int ret ; ret = fdt_check_header ( fit ) ; if ( ret ) { log_debug ( "Wrong<S2SV_blank>FIT<S2SV_blank>format:<S2SV_blank>not<S2SV_blank>a<S2SV_blank>flattened<S2SV_blank>device<S2SV_blank>tree<S2SV_blank>(err=%d)\\n" , ret ) ; return - ENOEXEC ; } <S2SV_StartBug> if ( ! fdt_getprop ( fit , 0 , FIT_DESC_PROP , NULL ) ) { <S2SV_EndBug> log_debug ( "Wrong<S2SV_blank>FIT<S2SV_blank>format:<S2SV_blank>no<S2SV_blank>description\\n" ) ; return - ENOMSG ; } if ( IMAGE_ENABLE_TIMESTAMP ) { if ( ! fdt_getprop ( fit , 0 , FIT_TIMESTAMP_PROP , NULL ) ) { log_debug ( "Wrong<S2SV_blank>FIT<S2SV_blank>format:<S2SV_blank>no<S2SV_blank>timestamp\\n" ) ; return - ENODATA ; } } if ( fdt_path_offset ( fit , FIT_IMAGES_PATH ) < 0 ) { log_debug ( "Wrong<S2SV_blank>FIT<S2SV_blank>format:<S2SV_blank>no<S2SV_blank>images<S2SV_blank>parent<S2SV_blank>node\\n" ) ; return - ENOENT ; } return 0 ; }
static int __dwc3_gadget_kick_transfer ( struct dwc3_ep * dep ) { struct dwc3_gadget_ep_cmd_params params ; struct dwc3_request * req ; int starting ; int ret ; u32 cmd ; if ( ! dwc3_calc_trbs_left ( dep ) ) return 0 ; starting = ! ( dep -> flags & DWC3_EP_BUSY ) ; dwc3_prepare_trbs ( dep ) ; req = next_request ( & dep -> started_list ) ; if ( ! req ) { dep -> flags |= DWC3_EP_PENDING_REQUEST ; return 0 ; } memset ( & params , 0 , sizeof ( params ) ) ; if ( starting ) { params . param0 = upper_32_bits ( req -> trb_dma ) ; params . param1 = lower_32_bits ( req -> trb_dma ) ; cmd = DWC3_DEPCMD_STARTTRANSFER ; if ( usb_endpoint_xfer_isoc ( dep -> endpoint . desc ) ) cmd |= DWC3_DEPCMD_PARAM ( dep -> frame_number ) ; } else { cmd = DWC3_DEPCMD_UPDATETRANSFER | DWC3_DEPCMD_PARAM ( dep -> resource_index ) ; } ret = dwc3_send_gadget_ep_cmd ( dep , cmd , & params ) ; if ( ret < 0 ) { if ( req -> trb ) memset ( req -> trb , 0 , sizeof ( struct dwc3_trb ) ) ; dep -> queued_requests -- ; <S2SV_StartBug> dwc3_gadget_giveback ( dep , req , ret ) ; <S2SV_EndBug> return ret ; } dep -> flags |= DWC3_EP_BUSY ; if ( starting ) { dep -> resource_index = dwc3_gadget_ep_get_transfer_index ( dep ) ; WARN_ON_ONCE ( ! dep -> resource_index ) ; } return 0 ; }
static int multipath_ioctl ( struct dm_target * ti , unsigned int cmd , unsigned long arg ) { struct multipath * m = ( struct multipath * ) ti -> private ; struct block_device * bdev = NULL ; fmode_t mode = 0 ; unsigned long flags ; int r = 0 ; spin_lock_irqsave ( & m -> lock , flags ) ; if ( ! m -> current_pgpath ) __choose_pgpath ( m , 0 ) ; if ( m -> current_pgpath ) { bdev = m -> current_pgpath -> path . dev -> bdev ; mode = m -> current_pgpath -> path . dev -> mode ; } if ( m -> queue_io ) r = - EAGAIN ; else if ( ! bdev ) r = - EIO ; spin_unlock_irqrestore ( & m -> lock , flags ) ; <S2SV_StartBug> return r ? : __blkdev_driver_ioctl ( bdev , mode , cmd , arg ) ; <S2SV_EndBug> }
int bt_sock_stream_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t size , int flags ) { struct sock * sk = sock -> sk ; int err = 0 ; size_t target , copied = 0 ; long timeo ; if ( flags & MSG_OOB ) <S2SV_StartBug> return - EOPNOTSUPP ; <S2SV_EndBug> msg -> msg_namelen = 0 ; BT_DBG ( "sk<S2SV_blank>%p<S2SV_blank>size<S2SV_blank>%zu" , sk , size ) ; lock_sock ( sk ) ; target = sock_rcvlowat ( sk , flags & MSG_WAITALL , size ) ; timeo = sock_rcvtimeo ( sk , flags & MSG_DONTWAIT ) ; do { struct sk_buff * skb ; int chunk ; skb = skb_dequeue ( & sk -> sk_receive_queue ) ; if ( ! skb ) { if ( copied >= target ) break ; err = sock_error ( sk ) ; if ( err ) break ; if ( sk -> sk_shutdown & RCV_SHUTDOWN ) break ; err = - EAGAIN ; if ( ! timeo ) break ; timeo = bt_sock_data_wait ( sk , timeo ) ; if ( signal_pending ( current ) ) { err = sock_intr_errno ( timeo ) ; goto out ; } continue ; } chunk = min_t ( unsigned int , skb -> len , size ) ; if ( skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , chunk ) ) { skb_queue_head ( & sk -> sk_receive_queue , skb ) ; if ( ! copied ) copied = - EFAULT ; break ; } copied += chunk ; size -= chunk ; sock_recv_ts_and_drops ( msg , sk , skb ) ; if ( ! ( flags & MSG_PEEK ) ) { int skb_len = skb_headlen ( skb ) ; if ( chunk <= skb_len ) { __skb_pull ( skb , chunk ) ; } else { struct sk_buff * frag ; __skb_pull ( skb , skb_len ) ; chunk -= skb_len ; skb_walk_frags ( skb , frag ) { if ( chunk <= frag -> len ) { skb -> len -= chunk ; skb -> data_len -= chunk ; __skb_pull ( frag , chunk ) ; break ; } else if ( frag -> len ) { chunk -= frag -> len ; skb -> len -= frag -> len ; skb -> data_len -= frag -> len ; __skb_pull ( frag , frag -> len ) ; } } } if ( skb -> len ) { skb_queue_head ( & sk -> sk_receive_queue , skb ) ; break ; } kfree_skb ( skb ) ; } else { skb_queue_head ( & sk -> sk_receive_queue , skb ) ; break ; } } while ( size ) ; out : release_sock ( sk ) ; return copied ? : err ; }
static int __rds_rdma_map ( struct rds_sock * rs , struct rds_get_mr_args * args , u64 * cookie_ret , struct rds_mr * * mr_ret ) { struct rds_mr * mr = NULL , * found ; unsigned int nr_pages ; struct page * * pages = NULL ; struct scatterlist * sg ; void * trans_private ; unsigned long flags ; rds_rdma_cookie_t cookie ; unsigned int nents ; long i ; int ret ; <S2SV_StartBug> if ( rs -> rs_bound_addr == 0 ) { <S2SV_EndBug> ret = - ENOTCONN ; goto out ; } if ( ! rs -> rs_transport -> get_mr ) { ret = - EOPNOTSUPP ; goto out ; } nr_pages = rds_pages_in_vec ( & args -> vec ) ; if ( nr_pages == 0 ) { ret = - EINVAL ; goto out ; } if ( ( nr_pages - 1 ) > ( RDS_MAX_MSG_SIZE >> PAGE_SHIFT ) ) { ret = - EMSGSIZE ; goto out ; } rdsdebug ( "RDS:<S2SV_blank>get_mr<S2SV_blank>addr<S2SV_blank>%llx<S2SV_blank>len<S2SV_blank>%llu<S2SV_blank>nr_pages<S2SV_blank>%u\\n" , args -> vec . addr , args -> vec . bytes , nr_pages ) ; pages = kcalloc ( nr_pages , sizeof ( struct page * ) , GFP_KERNEL ) ; if ( ! pages ) { ret = - ENOMEM ; goto out ; } mr = kzalloc ( sizeof ( struct rds_mr ) , GFP_KERNEL ) ; if ( ! mr ) { ret = - ENOMEM ; goto out ; } refcount_set ( & mr -> r_refcount , 1 ) ; RB_CLEAR_NODE ( & mr -> r_rb_node ) ; mr -> r_trans = rs -> rs_transport ; mr -> r_sock = rs ; if ( args -> flags & RDS_RDMA_USE_ONCE ) mr -> r_use_once = 1 ; if ( args -> flags & RDS_RDMA_INVALIDATE ) mr -> r_invalidate = 1 ; if ( args -> flags & RDS_RDMA_READWRITE ) mr -> r_write = 1 ; ret = rds_pin_pages ( args -> vec . addr , nr_pages , pages , 1 ) ; if ( ret < 0 ) goto out ; nents = ret ; sg = kcalloc ( nents , sizeof ( * sg ) , GFP_KERNEL ) ; if ( ! sg ) { ret = - ENOMEM ; goto out ; } WARN_ON ( ! nents ) ; sg_init_table ( sg , nents ) ; for ( i = 0 ; i < nents ; i ++ ) sg_set_page ( & sg [ i ] , pages [ i ] , PAGE_SIZE , 0 ) ; rdsdebug ( "RDS:<S2SV_blank>trans_private<S2SV_blank>nents<S2SV_blank>is<S2SV_blank>%u\\n" , nents ) ; trans_private = rs -> rs_transport -> get_mr ( sg , nents , rs , & mr -> r_key ) ; if ( IS_ERR ( trans_private ) ) { for ( i = 0 ; i < nents ; i ++ ) put_page ( sg_page ( & sg [ i ] ) ) ; kfree ( sg ) ; ret = PTR_ERR ( trans_private ) ; goto out ; } mr -> r_trans_private = trans_private ; rdsdebug ( "RDS:<S2SV_blank>get_mr<S2SV_blank>put_user<S2SV_blank>key<S2SV_blank>is<S2SV_blank>%x<S2SV_blank>cookie_addr<S2SV_blank>%p\\n" , mr -> r_key , ( void * ) ( unsigned long ) args -> cookie_addr ) ; cookie = rds_rdma_make_cookie ( mr -> r_key , args -> vec . addr & ~ PAGE_MASK ) ; if ( cookie_ret ) * cookie_ret = cookie ; if ( args -> cookie_addr && put_user ( cookie , ( u64 __user * ) ( unsigned long ) args -> cookie_addr ) ) { ret = - EFAULT ; goto out ; } spin_lock_irqsave ( & rs -> rs_rdma_lock , flags ) ; found = rds_mr_tree_walk ( & rs -> rs_rdma_keys , mr -> r_key , mr ) ; spin_unlock_irqrestore ( & rs -> rs_rdma_lock , flags ) ; BUG_ON ( found && found != mr ) ; rdsdebug ( "RDS:<S2SV_blank>get_mr<S2SV_blank>key<S2SV_blank>is<S2SV_blank>%x\\n" , mr -> r_key ) ; if ( mr_ret ) { refcount_inc ( & mr -> r_refcount ) ; * mr_ret = mr ; } ret = 0 ; out : kfree ( pages ) ; if ( mr ) rds_mr_put ( mr ) ; return ret ; }
static int iwl_process_add_sta_resp ( struct iwl_priv * priv , struct iwl_addsta_cmd * addsta , struct iwl_rx_packet * pkt ) { u8 sta_id = addsta -> sta . sta_id ; unsigned long flags ; int ret = - EIO ; if ( pkt -> hdr . flags & IWL_CMD_FAILED_MSK ) { IWL_ERR ( priv , "Bad<S2SV_blank>return<S2SV_blank>from<S2SV_blank>REPLY_ADD_STA<S2SV_blank>(0x%08X)\\n" , pkt -> hdr . flags ) ; return ret ; } IWL_DEBUG_INFO ( priv , "Processing<S2SV_blank>response<S2SV_blank>for<S2SV_blank>adding<S2SV_blank>station<S2SV_blank>%u\\n" , sta_id ) ; spin_lock_irqsave ( & priv -> shrd -> sta_lock , flags ) ; switch ( pkt -> u . add_sta . status ) { case ADD_STA_SUCCESS_MSK : IWL_DEBUG_INFO ( priv , "REPLY_ADD_STA<S2SV_blank>PASSED\\n" ) ; <S2SV_StartBug> iwl_sta_ucode_activate ( priv , sta_id ) ; <S2SV_EndBug> ret = 0 ; break ; case ADD_STA_NO_ROOM_IN_TABLE : IWL_ERR ( priv , "Adding<S2SV_blank>station<S2SV_blank>%d<S2SV_blank>failed,<S2SV_blank>no<S2SV_blank>room<S2SV_blank>in<S2SV_blank>table.\\n" , sta_id ) ; break ; case ADD_STA_NO_BLOCK_ACK_RESOURCE : IWL_ERR ( priv , "Adding<S2SV_blank>station<S2SV_blank>%d<S2SV_blank>failed,<S2SV_blank>no<S2SV_blank>block<S2SV_blank>ack<S2SV_blank>" "resource.\\n" , sta_id ) ; break ; case ADD_STA_MODIFY_NON_EXIST_STA : IWL_ERR ( priv , "Attempting<S2SV_blank>to<S2SV_blank>modify<S2SV_blank>non-existing<S2SV_blank>station<S2SV_blank>%d\\n" , sta_id ) ; break ; default : IWL_DEBUG_ASSOC ( priv , "Received<S2SV_blank>REPLY_ADD_STA:(0x%08X)\\n" , pkt -> u . add_sta . status ) ; break ; } IWL_DEBUG_INFO ( priv , "%s<S2SV_blank>station<S2SV_blank>id<S2SV_blank>%u<S2SV_blank>addr<S2SV_blank>%pM\\n" , priv -> stations [ sta_id ] . sta . mode == STA_CONTROL_MODIFY_MSK ? "Modified" : "Added" , sta_id , priv -> stations [ sta_id ] . sta . sta . addr ) ; IWL_DEBUG_INFO ( priv , "%s<S2SV_blank>station<S2SV_blank>according<S2SV_blank>to<S2SV_blank>cmd<S2SV_blank>buffer<S2SV_blank>%pM\\n" , priv -> stations [ sta_id ] . sta . mode == STA_CONTROL_MODIFY_MSK ? "Modified" : "Added" , addsta -> sta . addr ) ; spin_unlock_irqrestore ( & priv -> shrd -> sta_lock , flags ) ; return ret ; }
static int mark_source_chains ( const struct xt_table_info * newinfo , unsigned int valid_hooks , void * entry0 ) { unsigned int hook ; for ( hook = 0 ; hook < NF_INET_NUMHOOKS ; hook ++ ) { unsigned int pos = newinfo -> hook_entry [ hook ] ; struct ip6t_entry * e = ( struct ip6t_entry * ) ( entry0 + pos ) ; if ( ! ( valid_hooks & ( 1 << hook ) ) ) continue ; e -> counters . pcnt = pos ; for ( ; ; ) { const struct xt_standard_target * t = ( void * ) ip6t_get_target_c ( e ) ; int visited = e -> comefrom & ( 1 << hook ) ; if ( e -> comefrom & ( 1 << NF_INET_NUMHOOKS ) ) { pr_err ( "iptables:<S2SV_blank>loop<S2SV_blank>hook<S2SV_blank>%u<S2SV_blank>pos<S2SV_blank>%u<S2SV_blank>%08X.\\n" , hook , pos , e -> comefrom ) ; return 0 ; } e -> comefrom |= ( ( 1 << hook ) | ( 1 << NF_INET_NUMHOOKS ) ) ; <S2SV_StartBug> if ( ( e -> target_offset == sizeof ( struct ip6t_entry ) && <S2SV_EndBug> ( strcmp ( t -> target . u . user . name , XT_STANDARD_TARGET ) == 0 ) && <S2SV_StartBug> t -> verdict < 0 && <S2SV_EndBug> unconditional ( & e -> ipv6 ) ) || visited ) { unsigned int oldpos , size ; if ( ( strcmp ( t -> target . u . user . name , XT_STANDARD_TARGET ) == 0 ) && t -> verdict < - NF_MAX_VERDICT - 1 ) { duprintf ( "mark_source_chains:<S2SV_blank>bad<S2SV_blank>" "negative<S2SV_blank>verdict<S2SV_blank>(%i)\\n" , t -> verdict ) ; return 0 ; } do { e -> comefrom ^= ( 1 << NF_INET_NUMHOOKS ) ; # ifdef DEBUG_IP_FIREWALL_USER if ( e -> comefrom & ( 1 << NF_INET_NUMHOOKS ) ) { duprintf ( "Back<S2SV_blank>unset<S2SV_blank>" "on<S2SV_blank>hook<S2SV_blank>%u<S2SV_blank>" "rule<S2SV_blank>%u\\n" , hook , pos ) ; } # endif oldpos = pos ; pos = e -> counters . pcnt ; e -> counters . pcnt = 0 ; if ( pos == oldpos ) goto next ; e = ( struct ip6t_entry * ) ( entry0 + pos ) ; } while ( oldpos == pos + e -> next_offset ) ; size = e -> next_offset ; e = ( struct ip6t_entry * ) ( entry0 + pos + size ) ; e -> counters . pcnt = pos ; pos += size ; } else { int newpos = t -> verdict ; if ( strcmp ( t -> target . u . user . name , XT_STANDARD_TARGET ) == 0 && newpos >= 0 ) { if ( newpos > newinfo -> size - sizeof ( struct ip6t_entry ) ) { duprintf ( "mark_source_chains:<S2SV_blank>" "bad<S2SV_blank>verdict<S2SV_blank>(%i)\\n" , newpos ) ; return 0 ; } duprintf ( "Jump<S2SV_blank>rule<S2SV_blank>%u<S2SV_blank>-><S2SV_blank>%u\\n" , pos , newpos ) ; } else { newpos = pos + e -> next_offset ; } e = ( struct ip6t_entry * ) ( entry0 + newpos ) ; e -> counters . pcnt = pos ; pos = newpos ; } } next : duprintf ( "Finished<S2SV_blank>chain<S2SV_blank>%u\\n" , hook ) ; } return 1 ; }
static int nl80211_trigger_scan ( struct sk_buff * skb , struct genl_info * info ) { struct cfg80211_registered_device * rdev = info -> user_ptr [ 0 ] ; struct net_device * dev = info -> user_ptr [ 1 ] ; struct cfg80211_scan_request * request ; struct nlattr * attr ; struct wiphy * wiphy ; int err , tmp , n_ssids = 0 , n_channels , i ; enum ieee80211_band band ; size_t ie_len ; if ( ! is_valid_ie_attr ( info -> attrs [ NL80211_ATTR_IE ] ) ) return - EINVAL ; wiphy = & rdev -> wiphy ; if ( ! rdev -> ops -> scan ) return - EOPNOTSUPP ; if ( rdev -> scan_req ) return - EBUSY ; if ( info -> attrs [ NL80211_ATTR_SCAN_FREQUENCIES ] ) { n_channels = validate_scan_freqs ( info -> attrs [ NL80211_ATTR_SCAN_FREQUENCIES ] ) ; if ( ! n_channels ) return - EINVAL ; } else { n_channels = 0 ; for ( band = 0 ; band < IEEE80211_NUM_BANDS ; band ++ ) if ( wiphy -> bands [ band ] ) n_channels += wiphy -> bands [ band ] -> n_channels ; } if ( info -> attrs [ NL80211_ATTR_SCAN_SSIDS ] ) nla_for_each_nested ( attr , info -> attrs [ NL80211_ATTR_SCAN_SSIDS ] , tmp ) n_ssids ++ ; if ( n_ssids > wiphy -> max_scan_ssids ) return - EINVAL ; if ( info -> attrs [ NL80211_ATTR_IE ] ) ie_len = nla_len ( info -> attrs [ NL80211_ATTR_IE ] ) ; else ie_len = 0 ; if ( ie_len > wiphy -> max_scan_ie_len ) return - EINVAL ; request = kzalloc ( sizeof ( * request ) + sizeof ( * request -> ssids ) * n_ssids + sizeof ( * request -> channels ) * n_channels + ie_len , GFP_KERNEL ) ; if ( ! request ) return - ENOMEM ; if ( n_ssids ) request -> ssids = ( void * ) & request -> channels [ n_channels ] ; request -> n_ssids = n_ssids ; if ( ie_len ) { if ( request -> ssids ) request -> ie = ( void * ) ( request -> ssids + n_ssids ) ; else request -> ie = ( void * ) ( request -> channels + n_channels ) ; } i = 0 ; if ( info -> attrs [ NL80211_ATTR_SCAN_FREQUENCIES ] ) { nla_for_each_nested ( attr , info -> attrs [ NL80211_ATTR_SCAN_FREQUENCIES ] , tmp ) { struct ieee80211_channel * chan ; chan = ieee80211_get_channel ( wiphy , nla_get_u32 ( attr ) ) ; if ( ! chan ) { err = - EINVAL ; goto out_free ; } if ( chan -> flags & IEEE80211_CHAN_DISABLED ) continue ; request -> channels [ i ] = chan ; i ++ ; } } else { for ( band = 0 ; band < IEEE80211_NUM_BANDS ; band ++ ) { int j ; if ( ! wiphy -> bands [ band ] ) continue ; for ( j = 0 ; j < wiphy -> bands [ band ] -> n_channels ; j ++ ) { struct ieee80211_channel * chan ; chan = & wiphy -> bands [ band ] -> channels [ j ] ; if ( chan -> flags & IEEE80211_CHAN_DISABLED ) continue ; request -> channels [ i ] = chan ; i ++ ; } } } if ( ! i ) { err = - EINVAL ; goto out_free ; } request -> n_channels = i ; i = 0 ; if ( info -> attrs [ NL80211_ATTR_SCAN_SSIDS ] ) { <S2SV_StartBug> nla_for_each_nested ( attr , info -> attrs [ NL80211_ATTR_SCAN_SSIDS ] , tmp ) { <S2SV_EndBug> if ( request -> ssids [ i ] . ssid_len > IEEE80211_MAX_SSID_LEN ) { err = - EINVAL ; goto out_free ; } memcpy ( request -> ssids [ i ] . ssid , nla_data ( attr ) , nla_len ( attr ) ) ; <S2SV_StartBug> request -> ssids [ i ] . ssid_len = nla_len ( attr ) ; <S2SV_EndBug> i ++ ; } } if ( info -> attrs [ NL80211_ATTR_IE ] ) { request -> ie_len = nla_len ( info -> attrs [ NL80211_ATTR_IE ] ) ; memcpy ( ( void * ) request -> ie , nla_data ( info -> attrs [ NL80211_ATTR_IE ] ) , request -> ie_len ) ; } request -> dev = dev ; request -> wiphy = & rdev -> wiphy ; rdev -> scan_req = request ; err = rdev -> ops -> scan ( & rdev -> wiphy , dev , request ) ; if ( ! err ) { nl80211_send_scan_start ( rdev , dev ) ; dev_hold ( dev ) ; } else { out_free : rdev -> scan_req = NULL ; kfree ( request ) ; } return err ; }
static void <S2SV_StartBug> sraSpanInsertBefore ( sraSpan * newspan , sraSpan * before ) { <S2SV_EndBug> newspan -> _next = before ; newspan -> _prev = before -> _prev ; before -> _prev -> _next = newspan ; before -> _prev = newspan ; <S2SV_StartBug> } <S2SV_EndBug>
static int read_data ( void * opaque , uint8_t * buf , int buf_size ) { struct playlist * v = opaque ; HLSContext * c = v -> parent -> priv_data ; int ret , i ; <S2SV_StartBug> int just_opened = 0 ; <S2SV_EndBug> restart : if ( ! v -> needed ) return AVERROR_EOF ; if ( ! v -> input ) { int64_t reload_interval ; struct segment * seg ; if ( v -> ctx && v -> ctx -> nb_streams ) { v -> needed = 0 ; for ( i = 0 ; i < v -> n_main_streams ; i ++ ) { if ( v -> main_streams [ i ] -> discard < AVDISCARD_ALL ) { v -> needed = 1 ; break ; } } } if ( ! v -> needed ) { av_log ( v -> parent , AV_LOG_INFO , "No<S2SV_blank>longer<S2SV_blank>receiving<S2SV_blank>playlist<S2SV_blank>%d\\n" , v -> index ) ; return AVERROR_EOF ; } reload_interval = default_reload_interval ( v ) ; reload : <S2SV_StartBug> if ( ! v -> finished && <S2SV_EndBug> av_gettime_relative ( ) - v -> last_load_time >= reload_interval ) { if ( ( ret = parse_playlist ( c , v -> url , v , NULL ) ) < 0 ) { av_log ( v -> parent , AV_LOG_WARNING , "Failed<S2SV_blank>to<S2SV_blank>reload<S2SV_blank>playlist<S2SV_blank>%d\\n" , v -> index ) ; return ret ; } reload_interval = v -> target_duration / 2 ; } if ( v -> cur_seq_no < v -> start_seq_no ) { av_log ( NULL , AV_LOG_WARNING , "skipping<S2SV_blank>%d<S2SV_blank>segments<S2SV_blank>ahead,<S2SV_blank>expired<S2SV_blank>from<S2SV_blank>playlists\\n" , v -> start_seq_no - v -> cur_seq_no ) ; v -> cur_seq_no = v -> start_seq_no ; } if ( v -> cur_seq_no >= v -> start_seq_no + v -> n_segments ) { if ( v -> finished ) return AVERROR_EOF ; while ( av_gettime_relative ( ) - v -> last_load_time < reload_interval ) { if ( ff_check_interrupt ( c -> interrupt_callback ) ) return AVERROR_EXIT ; av_usleep ( 100 * 1000 ) ; } goto reload ; } seg = current_segment ( v ) ; ret = update_init_section ( v , seg ) ; if ( ret ) return ret ; ret = open_input ( c , v , seg ) ; if ( ret < 0 ) { if ( ff_check_interrupt ( c -> interrupt_callback ) ) return AVERROR_EXIT ; av_log ( v -> parent , AV_LOG_WARNING , "Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>segment<S2SV_blank>of<S2SV_blank>playlist<S2SV_blank>%d\\n" , v -> index ) ; v -> cur_seq_no += 1 ; goto reload ; } just_opened = 1 ; } if ( v -> init_sec_buf_read_offset < v -> init_sec_data_len ) { int copy_size = FFMIN ( v -> init_sec_data_len - v -> init_sec_buf_read_offset , buf_size ) ; memcpy ( buf , v -> init_sec_buf , copy_size ) ; v -> init_sec_buf_read_offset += copy_size ; return copy_size ; } ret = read_from_url ( v , current_segment ( v ) , buf , buf_size , READ_NORMAL ) ; if ( ret > 0 ) { if ( just_opened && v -> is_id3_timestamped != 0 ) { intercept_id3 ( v , buf , buf_size , & ret ) ; } return ret ; } ff_format_io_close ( v -> parent , & v -> input ) ; v -> cur_seq_no ++ ; c -> cur_seq_no = v -> cur_seq_no ; goto restart ; }
struct sta_info * sta_info_alloc ( struct ieee80211_sub_if_data * sdata , const u8 * addr , gfp_t gfp ) { struct ieee80211_local * local = sdata -> local ; struct sta_info * sta ; struct timespec uptime ; struct ieee80211_tx_latency_bin_ranges * tx_latency ; int i ; sta = kzalloc ( sizeof ( * sta ) + local -> hw . sta_data_size , gfp ) ; if ( ! sta ) return NULL ; rcu_read_lock ( ) ; tx_latency = rcu_dereference ( local -> tx_latency ) ; if ( tx_latency ) { sta -> tx_lat = kzalloc ( IEEE80211_NUM_TIDS * sizeof ( struct ieee80211_tx_latency_stat ) , GFP_ATOMIC ) ; if ( ! sta -> tx_lat ) { rcu_read_unlock ( ) ; goto free ; } if ( tx_latency -> n_ranges ) { for ( i = 0 ; i < IEEE80211_NUM_TIDS ; i ++ ) { sta -> tx_lat [ i ] . bin_count = tx_latency -> n_ranges + 1 ; sta -> tx_lat [ i ] . bins = kcalloc ( sta -> tx_lat [ i ] . bin_count , sizeof ( u32 ) , GFP_ATOMIC ) ; if ( ! sta -> tx_lat [ i ] . bins ) { rcu_read_unlock ( ) ; goto free ; } } } } rcu_read_unlock ( ) ; <S2SV_StartBug> spin_lock_init ( & sta -> lock ) ; <S2SV_EndBug> INIT_WORK ( & sta -> drv_unblock_wk , sta_unblock ) ; INIT_WORK ( & sta -> ampdu_mlme . work , ieee80211_ba_session_work ) ; mutex_init ( & sta -> ampdu_mlme . mtx ) ; # ifdef CONFIG_MAC80211_MESH if ( ieee80211_vif_is_mesh ( & sdata -> vif ) && ! sdata -> u . mesh . user_mpm ) init_timer ( & sta -> plink_timer ) ; sta -> nonpeer_pm = NL80211_MESH_POWER_ACTIVE ; # endif memcpy ( sta -> sta . addr , addr , ETH_ALEN ) ; sta -> local = local ; sta -> sdata = sdata ; sta -> last_rx = jiffies ; sta -> sta_state = IEEE80211_STA_NONE ; do_posix_clock_monotonic_gettime ( & uptime ) ; sta -> last_connected = uptime . tv_sec ; ewma_init ( & sta -> avg_signal , 1024 , 8 ) ; for ( i = 0 ; i < ARRAY_SIZE ( sta -> chain_signal_avg ) ; i ++ ) ewma_init ( & sta -> chain_signal_avg [ i ] , 1024 , 8 ) ; if ( sta_prepare_rate_control ( local , sta , gfp ) ) goto free ; for ( i = 0 ; i < IEEE80211_NUM_TIDS ; i ++ ) { sta -> timer_to_tid [ i ] = i ; } for ( i = 0 ; i < IEEE80211_NUM_ACS ; i ++ ) { skb_queue_head_init ( & sta -> ps_tx_buf [ i ] ) ; skb_queue_head_init ( & sta -> tx_filtered [ i ] ) ; } for ( i = 0 ; i < IEEE80211_NUM_TIDS ; i ++ ) sta -> last_seq_ctrl [ i ] = cpu_to_le16 ( USHRT_MAX ) ; sta -> sta . smps_mode = IEEE80211_SMPS_OFF ; if ( sdata -> vif . type == NL80211_IFTYPE_AP || sdata -> vif . type == NL80211_IFTYPE_AP_VLAN ) { struct ieee80211_supported_band * sband = local -> hw . wiphy -> bands [ ieee80211_get_sdata_band ( sdata ) ] ; u8 smps = ( sband -> ht_cap . cap & IEEE80211_HT_CAP_SM_PS ) >> IEEE80211_HT_CAP_SM_PS_SHIFT ; switch ( smps ) { case WLAN_HT_SMPS_CONTROL_DISABLED : sta -> known_smps_mode = IEEE80211_SMPS_OFF ; break ; case WLAN_HT_SMPS_CONTROL_STATIC : sta -> known_smps_mode = IEEE80211_SMPS_STATIC ; break ; case WLAN_HT_SMPS_CONTROL_DYNAMIC : sta -> known_smps_mode = IEEE80211_SMPS_DYNAMIC ; break ; default : WARN_ON ( 1 ) ; } } sta_dbg ( sdata , "Allocated<S2SV_blank>STA<S2SV_blank>%pM\\n" , sta -> sta . addr ) ; return sta ; free : if ( sta -> tx_lat ) { for ( i = 0 ; i < IEEE80211_NUM_TIDS ; i ++ ) kfree ( sta -> tx_lat [ i ] . bins ) ; kfree ( sta -> tx_lat ) ; } kfree ( sta ) ; return NULL ; }
int flb_gzip_compress ( void * in_data , size_t in_len , void * * out_data , size_t * out_len ) { int flush ; int status ; int footer_start ; uint8_t * pb ; size_t out_size ; void * out_buf ; z_stream strm ; mz_ulong crc ; <S2SV_StartBug> out_size = in_len + 32 ; <S2SV_EndBug> out_buf = flb_malloc ( out_size ) ; if ( ! out_buf ) { flb_errno ( ) ; flb_error ( "[gzip]<S2SV_blank>could<S2SV_blank>not<S2SV_blank>allocate<S2SV_blank>outgoing<S2SV_blank>buffer" ) ; return - 1 ; } memset ( & strm , '\\0' , sizeof ( strm ) ) ; strm . zalloc = Z_NULL ; strm . zfree = Z_NULL ; strm . opaque = Z_NULL ; strm . next_in = in_data ; strm . avail_in = in_len ; strm . total_out = 0 ; deflateInit2 ( & strm , Z_DEFAULT_COMPRESSION , Z_DEFLATED , - Z_DEFAULT_WINDOW_BITS , 9 , Z_DEFAULT_STRATEGY ) ; gzip_header ( out_buf ) ; pb = ( uint8_t * ) out_buf + FLB_GZIP_HEADER_OFFSET ; flush = Z_NO_FLUSH ; while ( 1 ) { strm . next_out = pb + strm . total_out ; strm . avail_out = out_size - ( pb - ( uint8_t * ) out_buf ) ; if ( strm . avail_in == 0 ) { flush = Z_FINISH ; } status = deflate ( & strm , flush ) ; if ( status == Z_STREAM_END ) { break ; } else if ( status != Z_OK ) { deflateEnd ( & strm ) ; return - 1 ; } } if ( deflateEnd ( & strm ) != Z_OK ) { flb_free ( out_buf ) ; return - 1 ; } * out_len = strm . total_out ; footer_start = FLB_GZIP_HEADER_OFFSET + * out_len ; pb = ( uint8_t * ) out_buf + footer_start ; crc = mz_crc32 ( MZ_CRC32_INIT , in_data , in_len ) ; * pb ++ = crc & 0xFF ; * pb ++ = ( crc >> 8 ) & 0xFF ; * pb ++ = ( crc >> 16 ) & 0xFF ; * pb ++ = ( crc >> 24 ) & 0xFF ; * pb ++ = in_len & 0xFF ; * pb ++ = ( in_len >> 8 ) & 0xFF ; * pb ++ = ( in_len >> 16 ) & 0xFF ; * pb ++ = ( in_len >> 24 ) & 0xFF ; * out_len += FLB_GZIP_HEADER_OFFSET + 8 ; * out_data = out_buf ; return 0 ; }
static int tga_readheader ( FILE * fp , unsigned int * bits_per_pixel , unsigned int * width , unsigned int * height , int * flip_image ) { int palette_size ; unsigned char tga [ TGA_HEADER_SIZE ] ; unsigned char id_len , image_type ; unsigned char pixel_depth , image_desc ; unsigned short cmap_len , cmap_entry_size ; unsigned short image_w , image_h ; if ( ! bits_per_pixel || ! width || ! height || ! flip_image ) { return 0 ; } if ( fread ( tga , TGA_HEADER_SIZE , 1 , fp ) != 1 ) { fprintf ( stderr , "\\nError:<S2SV_blank>fread<S2SV_blank>return<S2SV_blank>a<S2SV_blank>number<S2SV_blank>of<S2SV_blank>element<S2SV_blank>different<S2SV_blank>from<S2SV_blank>the<S2SV_blank>expected.\\n" ) ; return 0 ; } id_len = tga [ 0 ] ; image_type = tga [ 2 ] ; <S2SV_StartBug> cmap_len = get_ushort ( & tga [ 5 ] ) ; <S2SV_EndBug> cmap_entry_size = tga [ 7 ] ; # if 0 <S2SV_StartBug> x_origin = get_ushort ( & tga [ 8 ] ) ; <S2SV_EndBug> <S2SV_StartBug> y_origin = get_ushort ( & tga [ 10 ] ) ; <S2SV_EndBug> # endif <S2SV_StartBug> image_w = get_ushort ( & tga [ 12 ] ) ; <S2SV_EndBug> <S2SV_StartBug> image_h = get_ushort ( & tga [ 14 ] ) ; <S2SV_EndBug> pixel_depth = tga [ 16 ] ; image_desc = tga [ 17 ] ; * bits_per_pixel = ( unsigned int ) pixel_depth ; * width = ( unsigned int ) image_w ; * height = ( unsigned int ) image_h ; if ( id_len ) { unsigned char * id = ( unsigned char * ) malloc ( id_len ) ; if ( id == 0 ) { fprintf ( stderr , "tga_readheader:<S2SV_blank>memory<S2SV_blank>out\\n" ) ; return 0 ; } if ( ! fread ( id , id_len , 1 , fp ) ) { fprintf ( stderr , "\\nError:<S2SV_blank>fread<S2SV_blank>return<S2SV_blank>a<S2SV_blank>number<S2SV_blank>of<S2SV_blank>element<S2SV_blank>different<S2SV_blank>from<S2SV_blank>the<S2SV_blank>expected.\\n" ) ; free ( id ) ; return 0 ; } free ( id ) ; } if ( image_type > 8 ) { fprintf ( stderr , "Sorry,<S2SV_blank>compressed<S2SV_blank>tga<S2SV_blank>files<S2SV_blank>are<S2SV_blank>not<S2SV_blank>currently<S2SV_blank>supported.\\n" ) ; return 0 ; } * flip_image = ! ( image_desc & 32 ) ; palette_size = cmap_len * ( cmap_entry_size / 8 ) ; if ( palette_size > 0 ) { fprintf ( stderr , "File<S2SV_blank>contains<S2SV_blank>a<S2SV_blank>palette<S2SV_blank>-<S2SV_blank>not<S2SV_blank>yet<S2SV_blank>supported." ) ; fseek ( fp , palette_size , SEEK_CUR ) ; } return 1 ; }
static Image * ReadSGIImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image ; MagickBooleanType status ; MagickSizeType number_pixels ; MemoryInfo * pixel_info ; register Quantum * q ; register ssize_t i , x ; register unsigned char * p ; SGIInfo iris_info ; size_t bytes_per_pixel , quantum ; ssize_t count , y , z ; unsigned char * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , "%s" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } iris_info . magic = ReadBlobMSBShort ( image ) ; do { if ( iris_info . magic != 0x01DA ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; iris_info . storage = ( unsigned char ) ReadBlobByte ( image ) ; switch ( iris_info . storage ) { case 0x00 : image -> compression = NoCompression ; break ; case 0x01 : image -> compression = RLECompression ; break ; default : ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; } iris_info . bytes_per_pixel = ( unsigned char ) ReadBlobByte ( image ) ; if ( ( iris_info . bytes_per_pixel == 0 ) || ( iris_info . bytes_per_pixel > 2 ) ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; iris_info . dimension = ReadBlobMSBShort ( image ) ; iris_info . columns = ReadBlobMSBShort ( image ) ; iris_info . rows = ReadBlobMSBShort ( image ) ; iris_info . depth = ReadBlobMSBShort ( image ) ; if ( ( iris_info . depth == 0 ) || ( iris_info . depth > 4 ) ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; iris_info . minimum_value = ReadBlobMSBLong ( image ) ; iris_info . maximum_value = ReadBlobMSBLong ( image ) ; iris_info . sans = ReadBlobMSBLong ( image ) ; <S2SV_StartBug> ( void ) ReadBlob ( image , sizeof ( iris_info . name ) , ( unsigned char * ) <S2SV_EndBug> <S2SV_StartBug> iris_info . name ) ; <S2SV_EndBug> iris_info . name [ sizeof ( iris_info . name ) - 1 ] = '\\0' ; if ( * iris_info . name != '\\0' ) ( void ) SetImageProperty ( image , "label" , iris_info . name , exception ) ; iris_info . pixel_format = ReadBlobMSBLong ( image ) ; if ( iris_info . pixel_format != 0 ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; count = ReadBlob ( image , sizeof ( iris_info . filler ) , iris_info . filler ) ; <S2SV_StartBug> ( void ) count ; <S2SV_EndBug> image -> columns = iris_info . columns ; image -> rows = iris_info . rows ; image -> depth = ( size_t ) MagickMin ( iris_info . depth , MAGICKCORE_QUANTUM_DEPTH ) ; if ( iris_info . pixel_format == 0 ) image -> depth = ( size_t ) MagickMin ( ( size_t ) 8 * iris_info . bytes_per_pixel , MAGICKCORE_QUANTUM_DEPTH ) ; if ( iris_info . depth < 3 ) { image -> storage_class = PseudoClass ; image -> colors = iris_info . bytes_per_pixel > 1 ? 65535 : 256 ; } <S2SV_StartBug> if ( EOFBlob ( image ) != MagickFalse ) <S2SV_EndBug> ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; bytes_per_pixel = ( size_t ) iris_info . bytes_per_pixel ; number_pixels = ( MagickSizeType ) iris_info . columns * iris_info . rows ; if ( ( 4 * bytes_per_pixel * number_pixels ) != ( ( MagickSizeType ) ( size_t ) ( 4 * bytes_per_pixel * number_pixels ) ) ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; pixel_info = AcquireVirtualMemory ( iris_info . columns , iris_info . rows * 4 * bytes_per_pixel * sizeof ( * pixels ) ) ; if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ; if ( ( int ) iris_info . storage != 0x01 ) { unsigned char * scanline ; scanline = ( unsigned char * ) AcquireQuantumMemory ( iris_info . columns , bytes_per_pixel * sizeof ( * scanline ) ) ; if ( scanline == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; for ( z = 0 ; z < ( ssize_t ) iris_info . depth ; z ++ ) { p = pixels + bytes_per_pixel * z ; for ( y = 0 ; y < ( ssize_t ) iris_info . rows ; y ++ ) { count = ReadBlob ( image , bytes_per_pixel * iris_info . columns , scanline ) ; if ( EOFBlob ( image ) != MagickFalse ) break ; if ( bytes_per_pixel == 2 ) for ( x = 0 ; x < ( ssize_t ) iris_info . columns ; x ++ ) { * p = scanline [ 2 * x ] ; * ( p + 1 ) = scanline [ 2 * x + 1 ] ; p += 8 ; } else for ( x = 0 ; x < ( ssize_t ) iris_info . columns ; x ++ ) { * p = scanline [ x ] ; p += 4 ; } } } scanline = ( unsigned char * ) RelinquishMagickMemory ( scanline ) ; } else { MemoryInfo * packet_info ; size_t * runlength ; ssize_t offset , * offsets ; unsigned char * packets ; unsigned int data_order ; offsets = ( ssize_t * ) AcquireQuantumMemory ( ( size_t ) iris_info . rows , iris_info . depth * sizeof ( * offsets ) ) ; runlength = ( size_t * ) AcquireQuantumMemory ( iris_info . rows , iris_info . depth * sizeof ( * runlength ) ) ; packet_info = AcquireVirtualMemory ( ( size_t ) iris_info . columns + 10UL , 4UL * sizeof ( * packets ) ) ; if ( ( offsets == ( ssize_t * ) NULL ) || ( runlength == ( size_t * ) NULL ) || ( packet_info == ( MemoryInfo * ) NULL ) ) { if ( offsets == ( ssize_t * ) NULL ) offsets = ( ssize_t * ) RelinquishMagickMemory ( offsets ) ; if ( runlength == ( size_t * ) NULL ) runlength = ( size_t * ) RelinquishMagickMemory ( runlength ) ; if ( packet_info == ( MemoryInfo * ) NULL ) packet_info = RelinquishVirtualMemory ( packet_info ) ; ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; } packets = ( unsigned char * ) GetVirtualMemoryBlob ( packet_info ) ; for ( i = 0 ; i < ( ssize_t ) ( iris_info . rows * iris_info . depth ) ; i ++ ) offsets [ i ] = ReadBlobMSBSignedLong ( image ) ; for ( i = 0 ; i < ( ssize_t ) ( iris_info . rows * iris_info . depth ) ; i ++ ) { runlength [ i ] = ReadBlobMSBLong ( image ) ; if ( runlength [ i ] > ( 4 * ( size_t ) iris_info . columns + 10 ) ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; } offset = 0 ; data_order = 0 ; for ( y = 0 ; ( ( y < ( ssize_t ) iris_info . rows ) && ( data_order == 0 ) ) ; y ++ ) for ( z = 0 ; ( ( z < ( ssize_t ) iris_info . depth ) && ( data_order == 0 ) ) ; z ++ ) { if ( offsets [ y + z * iris_info . rows ] < offset ) data_order = 1 ; offset = offsets [ y + z * iris_info . rows ] ; } offset = ( ssize_t ) TellBlob ( image ) ; if ( data_order == 1 ) { for ( z = 0 ; z < ( ssize_t ) iris_info . depth ; z ++ ) { p = pixels ; for ( y = 0 ; y < ( ssize_t ) iris_info . rows ; y ++ ) { if ( offset != offsets [ y + z * iris_info . rows ] ) { offset = offsets [ y + z * iris_info . rows ] ; offset = ( ssize_t ) SeekBlob ( image , ( ssize_t ) offset , SEEK_SET ) ; } count = ReadBlob ( image , ( size_t ) runlength [ y + z * iris_info . rows ] , packets ) ; if ( EOFBlob ( image ) != MagickFalse ) break ; offset += ( ssize_t ) runlength [ y + z * iris_info . rows ] ; status = SGIDecode ( bytes_per_pixel , ( ssize_t ) ( runlength [ y + z * iris_info . rows ] / bytes_per_pixel ) , packets , 1L * iris_info . columns , p + bytes_per_pixel * z ) ; if ( status == MagickFalse ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; p += ( iris_info . columns * 4 * bytes_per_pixel ) ; } } } else { MagickOffsetType position ; position = TellBlob ( image ) ; p = pixels ; for ( y = 0 ; y < ( ssize_t ) iris_info . rows ; y ++ ) { for ( z = 0 ; z < ( ssize_t ) iris_info . depth ; z ++ ) { if ( offset != offsets [ y + z * iris_info . rows ] ) { offset = offsets [ y + z * iris_info . rows ] ; offset = ( ssize_t ) SeekBlob ( image , ( ssize_t ) offset , SEEK_SET ) ; } count = ReadBlob ( image , ( size_t ) runlength [ y + z * iris_info . rows ] , packets ) ; if ( EOFBlob ( image ) != MagickFalse ) break ; offset += ( ssize_t ) runlength [ y + z * iris_info . rows ] ; status = SGIDecode ( bytes_per_pixel , ( ssize_t ) ( runlength [ y + z * iris_info . rows ] / bytes_per_pixel ) , packets , 1L * iris_info . columns , p + bytes_per_pixel * z ) ; if ( status == MagickFalse ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; } p += ( iris_info . columns * 4 * bytes_per_pixel ) ; } offset = ( ssize_t ) SeekBlob ( image , position , SEEK_SET ) ; } packet_info = RelinquishVirtualMemory ( packet_info ) ; runlength = ( size_t * ) RelinquishMagickMemory ( runlength ) ; offsets = ( ssize_t * ) RelinquishMagickMemory ( offsets ) ; } image -> alpha_trait = iris_info . depth == 4 ? BlendPixelTrait : UndefinedPixelTrait ; image -> columns = iris_info . columns ; image -> rows = iris_info . rows ; if ( image -> storage_class == DirectClass ) { if ( bytes_per_pixel == 2 ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { p = pixels + ( image -> rows - y - 1 ) * 8 * image -> columns ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( image , ScaleShortToQuantum ( ( unsigned short ) ( ( * ( p + 0 ) << 8 ) | ( * ( p + 1 ) ) ) ) , q ) ; SetPixelGreen ( image , ScaleShortToQuantum ( ( unsigned short ) ( ( * ( p + 2 ) << 8 ) | ( * ( p + 3 ) ) ) ) , q ) ; SetPixelBlue ( image , ScaleShortToQuantum ( ( unsigned short ) ( ( * ( p + 4 ) << 8 ) | ( * ( p + 5 ) ) ) ) , q ) ; SetPixelAlpha ( image , OpaqueAlpha , q ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , ScaleShortToQuantum ( ( unsigned short ) ( ( * ( p + 6 ) << 8 ) | ( * ( p + 7 ) ) ) ) , q ) ; p += 8 ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { p = pixels + ( image -> rows - y - 1 ) * 4 * image -> columns ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( image , ScaleCharToQuantum ( * p ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * ( p + 1 ) ) , q ) ; SetPixelBlue ( image , ScaleCharToQuantum ( * ( p + 2 ) ) , q ) ; SetPixelAlpha ( image , OpaqueAlpha , q ) ; if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , ScaleCharToQuantum ( * ( p + 3 ) ) , q ) ; p += 4 ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else { if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; if ( bytes_per_pixel == 2 ) { for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { p = pixels + ( image -> rows - y - 1 ) * 8 * image -> columns ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { quantum = ( * p << 8 ) ; quantum |= ( * ( p + 1 ) ) ; SetPixelIndex ( image , ( Quantum ) quantum , q ) ; p += 8 ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { p = pixels + ( image -> rows - y - 1 ) * 4 * image -> columns ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelIndex ( image , * p , q ) ; p += 4 ; q += GetPixelChannels ( image ) ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image , exception ) ; } pixel_info = RelinquishVirtualMemory ( pixel_info ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , "UnexpectedEndOfFile" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; iris_info . magic = ReadBlobMSBShort ( image ) ; if ( iris_info . magic == 0x01DA ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( iris_info . magic == 0x01DA ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
void big_key_describe ( const struct key * key , struct seq_file * m ) { size_t datalen = ( size_t ) key -> payload . data [ big_key_len ] ; seq_puts ( m , key -> description ) ; <S2SV_StartBug> if ( key_is_instantiated ( key ) ) <S2SV_EndBug> seq_printf ( m , ":<S2SV_blank>%zu<S2SV_blank>[%s]" , datalen , datalen > BIG_KEY_FILE_THRESHOLD ? "file" : "buff" ) ; }
int xfs_attr3_leaf_list_int ( struct xfs_buf * bp , struct xfs_attr_list_context * context ) { struct attrlist_cursor_kern * cursor ; struct xfs_attr_leafblock * leaf ; struct xfs_attr3_icleaf_hdr ichdr ; struct xfs_attr_leaf_entry * entries ; struct xfs_attr_leaf_entry * entry ; int retval ; int i ; struct xfs_mount * mp = context -> dp -> i_mount ; trace_xfs_attr_list_leaf ( context ) ; leaf = bp -> b_addr ; xfs_attr3_leaf_hdr_from_disk ( mp -> m_attr_geo , & ichdr , leaf ) ; entries = xfs_attr3_leaf_entryp ( leaf ) ; cursor = context -> cursor ; cursor -> initted = 1 ; if ( context -> resynch ) { entry = & entries [ 0 ] ; for ( i = 0 ; i < ichdr . count ; entry ++ , i ++ ) { if ( be32_to_cpu ( entry -> hashval ) == cursor -> hashval ) { if ( cursor -> offset == context -> dupcnt ) { context -> dupcnt = 0 ; break ; } context -> dupcnt ++ ; } else if ( be32_to_cpu ( entry -> hashval ) > cursor -> hashval ) { context -> dupcnt = 0 ; break ; } } if ( i == ichdr . count ) { trace_xfs_attr_list_notfound ( context ) ; return 0 ; } } else { entry = & entries [ 0 ] ; i = 0 ; } context -> resynch = 0 ; retval = 0 ; for ( ; i < ichdr . count ; entry ++ , i ++ ) { if ( be32_to_cpu ( entry -> hashval ) != cursor -> hashval ) { cursor -> hashval = be32_to_cpu ( entry -> hashval ) ; cursor -> offset = 0 ; } if ( entry -> flags & XFS_ATTR_INCOMPLETE ) continue ; if ( entry -> flags & XFS_ATTR_LOCAL ) { xfs_attr_leaf_name_local_t * name_loc = xfs_attr3_leaf_name_local ( leaf , i ) ; retval = context -> put_listent ( context , entry -> flags , name_loc -> nameval , ( int ) name_loc -> namelen , be16_to_cpu ( name_loc -> valuelen ) , & name_loc -> nameval [ name_loc -> namelen ] ) ; if ( retval ) return retval ; } else { xfs_attr_leaf_name_remote_t * name_rmt = xfs_attr3_leaf_name_remote ( leaf , i ) ; int valuelen = be32_to_cpu ( name_rmt -> valuelen ) ; if ( context -> put_value ) { xfs_da_args_t args ; memset ( ( char * ) & args , 0 , sizeof ( args ) ) ; args . geo = context -> dp -> i_mount -> m_attr_geo ; args . dp = context -> dp ; args . whichfork = XFS_ATTR_FORK ; args . valuelen = valuelen ; args . rmtvaluelen = valuelen ; args . value = kmem_alloc ( valuelen , KM_SLEEP | KM_NOFS ) ; args . rmtblkno = be32_to_cpu ( name_rmt -> valueblk ) ; args . rmtblkcnt = xfs_attr3_rmt_blocks ( args . dp -> i_mount , valuelen ) ; retval = xfs_attr_rmtval_get ( & args ) ; <S2SV_StartBug> if ( retval ) <S2SV_EndBug> return retval ; retval = context -> put_listent ( context , entry -> flags , name_rmt -> name , ( int ) name_rmt -> namelen , valuelen , args . value ) ; kmem_free ( args . value ) ; } else { retval = context -> put_listent ( context , entry -> flags , name_rmt -> name , ( int ) name_rmt -> namelen , valuelen , NULL ) ; } if ( retval ) return retval ; } if ( context -> seen_enough ) break ; cursor -> offset ++ ; } trace_xfs_attr_list_leaf_end ( context ) ; return retval ; }
static void set_default_lf_deltas ( VP8_COMP * cpi ) { cpi -> mb . e_mbd . mode_ref_lf_delta_enabled = 1 ; cpi -> mb . e_mbd . mode_ref_lf_delta_update = 1 ; <S2SV_StartBug> vpx_memset ( cpi -> mb . e_mbd . ref_lf_deltas , 0 , sizeof ( cpi -> mb . e_mbd . ref_lf_deltas ) ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( cpi -> mb . e_mbd . mode_lf_deltas , 0 , sizeof ( cpi -> mb . e_mbd . mode_lf_deltas ) ) ; <S2SV_EndBug> cpi -> mb . e_mbd . ref_lf_deltas [ INTRA_FRAME ] = 2 ; cpi -> mb . e_mbd . ref_lf_deltas [ LAST_FRAME ] = 0 ; cpi -> mb . e_mbd . ref_lf_deltas [ GOLDEN_FRAME ] = - 2 ; cpi -> mb . e_mbd . ref_lf_deltas [ ALTREF_FRAME ] = - 2 ; cpi -> mb . e_mbd . mode_lf_deltas [ 0 ] = 4 ; if ( cpi -> oxcf . Mode == MODE_REALTIME ) cpi -> mb . e_mbd . mode_lf_deltas [ 1 ] = - 12 ; else cpi -> mb . e_mbd . mode_lf_deltas [ 1 ] = - 2 ; cpi -> mb . e_mbd . mode_lf_deltas [ 2 ] = 2 ; cpi -> mb . e_mbd . mode_lf_deltas [ 3 ] = 4 ; }
int tcp_rcv_state_process ( struct sock * sk , struct sk_buff * skb , const struct tcphdr * th , unsigned int len ) { struct tcp_sock * tp = tcp_sk ( sk ) ; struct inet_connection_sock * icsk = inet_csk ( sk ) ; int queued = 0 ; int res ; tp -> rx_opt . saw_tstamp = 0 ; switch ( sk -> sk_state ) { case TCP_CLOSE : goto discard ; case TCP_LISTEN : if ( th -> ack ) return 1 ; if ( th -> rst ) goto discard ; if ( th -> syn ) { <S2SV_StartBug> if ( icsk -> icsk_af_ops -> conn_request ( sk , skb ) < 0 ) <S2SV_EndBug> return 1 ; kfree_skb ( skb ) ; return 0 ; } goto discard ; case TCP_SYN_SENT : queued = tcp_rcv_synsent_state_process ( sk , skb , th , len ) ; if ( queued >= 0 ) return queued ; tcp_urg ( sk , skb , th ) ; __kfree_skb ( skb ) ; tcp_data_snd_check ( sk ) ; return 0 ; } res = tcp_validate_incoming ( sk , skb , th , 0 ) ; if ( res <= 0 ) return - res ; if ( th -> ack ) { int acceptable = tcp_ack ( sk , skb , FLAG_SLOWPATH ) > 0 ; switch ( sk -> sk_state ) { case TCP_SYN_RECV : if ( acceptable ) { tp -> copied_seq = tp -> rcv_nxt ; smp_mb ( ) ; tcp_set_state ( sk , TCP_ESTABLISHED ) ; sk -> sk_state_change ( sk ) ; if ( sk -> sk_socket ) sk_wake_async ( sk , SOCK_WAKE_IO , POLL_OUT ) ; tp -> snd_una = TCP_SKB_CB ( skb ) -> ack_seq ; tp -> snd_wnd = ntohs ( th -> window ) << tp -> rx_opt . snd_wscale ; tcp_init_wl ( tp , TCP_SKB_CB ( skb ) -> seq ) ; if ( tp -> rx_opt . tstamp_ok ) tp -> advmss -= TCPOLEN_TSTAMP_ALIGNED ; icsk -> icsk_af_ops -> rebuild_header ( sk ) ; tcp_init_metrics ( sk ) ; tcp_init_congestion_control ( sk ) ; tp -> lsndtime = tcp_time_stamp ; tcp_mtup_init ( sk ) ; tcp_initialize_rcv_mss ( sk ) ; tcp_init_buffer_space ( sk ) ; tcp_fast_path_on ( tp ) ; } else { return 1 ; } break ; case TCP_FIN_WAIT1 : if ( tp -> snd_una == tp -> write_seq ) { tcp_set_state ( sk , TCP_FIN_WAIT2 ) ; sk -> sk_shutdown |= SEND_SHUTDOWN ; dst_confirm ( __sk_dst_get ( sk ) ) ; if ( ! sock_flag ( sk , SOCK_DEAD ) ) sk -> sk_state_change ( sk ) ; else { int tmo ; if ( tp -> linger2 < 0 || ( TCP_SKB_CB ( skb ) -> end_seq != TCP_SKB_CB ( skb ) -> seq && after ( TCP_SKB_CB ( skb ) -> end_seq - th -> fin , tp -> rcv_nxt ) ) ) { tcp_done ( sk ) ; NET_INC_STATS_BH ( sock_net ( sk ) , LINUX_MIB_TCPABORTONDATA ) ; return 1 ; } tmo = tcp_fin_time ( sk ) ; if ( tmo > TCP_TIMEWAIT_LEN ) { inet_csk_reset_keepalive_timer ( sk , tmo - TCP_TIMEWAIT_LEN ) ; } else if ( th -> fin || sock_owned_by_user ( sk ) ) { inet_csk_reset_keepalive_timer ( sk , tmo ) ; } else { tcp_time_wait ( sk , TCP_FIN_WAIT2 , tmo ) ; goto discard ; } } } break ; case TCP_CLOSING : if ( tp -> snd_una == tp -> write_seq ) { tcp_time_wait ( sk , TCP_TIME_WAIT , 0 ) ; goto discard ; } break ; case TCP_LAST_ACK : if ( tp -> snd_una == tp -> write_seq ) { tcp_update_metrics ( sk ) ; tcp_done ( sk ) ; goto discard ; } break ; } } else goto discard ; tcp_urg ( sk , skb , th ) ; switch ( sk -> sk_state ) { case TCP_CLOSE_WAIT : case TCP_CLOSING : case TCP_LAST_ACK : if ( ! before ( TCP_SKB_CB ( skb ) -> seq , tp -> rcv_nxt ) ) break ; case TCP_FIN_WAIT1 : case TCP_FIN_WAIT2 : if ( sk -> sk_shutdown & RCV_SHUTDOWN ) { if ( TCP_SKB_CB ( skb ) -> end_seq != TCP_SKB_CB ( skb ) -> seq && after ( TCP_SKB_CB ( skb ) -> end_seq - th -> fin , tp -> rcv_nxt ) ) { NET_INC_STATS_BH ( sock_net ( sk ) , LINUX_MIB_TCPABORTONDATA ) ; tcp_reset ( sk ) ; return 1 ; } } case TCP_ESTABLISHED : tcp_data_queue ( sk , skb ) ; queued = 1 ; break ; } if ( sk -> sk_state != TCP_CLOSE ) { tcp_data_snd_check ( sk ) ; tcp_ack_snd_check ( sk ) ; } if ( ! queued ) { discard : __kfree_skb ( skb ) ; } return 0 ; }
static int adjust_scalar_min_max_vals ( struct bpf_verifier_env * env , struct bpf_insn * insn , struct bpf_reg_state * dst_reg , struct bpf_reg_state src_reg ) { struct bpf_reg_state * regs = cur_regs ( env ) ; u8 opcode = BPF_OP ( insn -> code ) ; bool src_known , dst_known ; s64 smin_val , smax_val ; u64 umin_val , umax_val ; <S2SV_StartBug> u64 insn_bitness = ( BPF_CLASS ( insn -> code ) == BPF_ALU64 ) ? 64 : 32 ; <S2SV_EndBug> if ( insn_bitness == 32 ) { coerce_reg_to_size ( dst_reg , 4 ) ; coerce_reg_to_size ( & src_reg , 4 ) ; } smin_val = src_reg . smin_value ; smax_val = src_reg . smax_value ; umin_val = src_reg . umin_value ; umax_val = src_reg . umax_value ; src_known = tnum_is_const ( src_reg . var_off ) ; dst_known = tnum_is_const ( dst_reg -> var_off ) ; if ( ( src_known && ( smin_val != smax_val || umin_val != umax_val ) ) || smin_val > smax_val || umin_val > umax_val ) { __mark_reg_unknown ( dst_reg ) ; return 0 ; } if ( ! src_known && opcode != BPF_ADD && opcode != BPF_SUB && opcode != BPF_AND ) { __mark_reg_unknown ( dst_reg ) ; return 0 ; } switch ( opcode ) { case BPF_ADD : <S2SV_StartBug> if ( signed_add_overflows ( dst_reg -> smin_value , smin_val ) || <S2SV_EndBug> signed_add_overflows ( dst_reg -> smax_value , smax_val ) ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value += smin_val ; dst_reg -> smax_value += smax_val ; } if ( dst_reg -> umin_value + umin_val < umin_val || dst_reg -> umax_value + umax_val < umax_val ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value += umin_val ; dst_reg -> umax_value += umax_val ; } dst_reg -> var_off = tnum_add ( dst_reg -> var_off , src_reg . var_off ) ; break ; case BPF_SUB : <S2SV_StartBug> if ( signed_sub_overflows ( dst_reg -> smin_value , smax_val ) || <S2SV_EndBug> signed_sub_overflows ( dst_reg -> smax_value , smin_val ) ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value -= smax_val ; dst_reg -> smax_value -= smin_val ; } if ( dst_reg -> umin_value < umax_val ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value -= umax_val ; dst_reg -> umax_value -= umin_val ; } dst_reg -> var_off = tnum_sub ( dst_reg -> var_off , src_reg . var_off ) ; break ; case BPF_MUL : dst_reg -> var_off = tnum_mul ( dst_reg -> var_off , src_reg . var_off ) ; if ( smin_val < 0 || dst_reg -> smin_value < 0 ) { __mark_reg_unbounded ( dst_reg ) ; __update_reg_bounds ( dst_reg ) ; break ; } if ( umax_val > U32_MAX || dst_reg -> umax_value > U32_MAX ) { __mark_reg_unbounded ( dst_reg ) ; __update_reg_bounds ( dst_reg ) ; break ; } dst_reg -> umin_value *= umin_val ; dst_reg -> umax_value *= umax_val ; if ( dst_reg -> umax_value > S64_MAX ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } break ; case BPF_AND : if ( src_known && dst_known ) { __mark_reg_known ( dst_reg , dst_reg -> var_off . value & src_reg . var_off . value ) ; break ; } dst_reg -> var_off = tnum_and ( dst_reg -> var_off , src_reg . var_off ) ; dst_reg -> umin_value = dst_reg -> var_off . value ; dst_reg -> umax_value = min ( dst_reg -> umax_value , umax_val ) ; if ( dst_reg -> smin_value < 0 || smin_val < 0 ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } __update_reg_bounds ( dst_reg ) ; break ; case BPF_OR : if ( src_known && dst_known ) { __mark_reg_known ( dst_reg , dst_reg -> var_off . value | src_reg . var_off . value ) ; break ; } dst_reg -> var_off = tnum_or ( dst_reg -> var_off , src_reg . var_off ) ; dst_reg -> umin_value = max ( dst_reg -> umin_value , umin_val ) ; dst_reg -> umax_value = dst_reg -> var_off . value | dst_reg -> var_off . mask ; if ( dst_reg -> smin_value < 0 || smin_val < 0 ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value = dst_reg -> umin_value ; dst_reg -> smax_value = dst_reg -> umax_value ; } __update_reg_bounds ( dst_reg ) ; break ; case BPF_LSH : if ( umax_val >= insn_bitness ) { mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; if ( dst_reg -> umax_value > 1ULL << ( 63 - umax_val ) ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value <<= umin_val ; dst_reg -> umax_value <<= umax_val ; } dst_reg -> var_off = tnum_lshift ( dst_reg -> var_off , umin_val ) ; __update_reg_bounds ( dst_reg ) ; break ; case BPF_RSH : if ( umax_val >= insn_bitness ) { mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; dst_reg -> var_off = tnum_rshift ( dst_reg -> var_off , umin_val ) ; dst_reg -> umin_value >>= umax_val ; dst_reg -> umax_value >>= umin_val ; __update_reg_bounds ( dst_reg ) ; break ; case BPF_ARSH : if ( umax_val >= insn_bitness ) { mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } dst_reg -> smin_value >>= umin_val ; dst_reg -> smax_value >>= umin_val ; dst_reg -> var_off = tnum_arshift ( dst_reg -> var_off , umin_val ) ; dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; __update_reg_bounds ( dst_reg ) ; break ; default : mark_reg_unknown ( env , regs , insn -> dst_reg ) ; break ; } if ( BPF_CLASS ( insn -> code ) != BPF_ALU64 ) { coerce_reg_to_size ( dst_reg , 4 ) ; } __reg_deduce_bounds ( dst_reg ) ; __reg_bound_offset ( dst_reg ) ; return 0 ; }
<S2SV_StartBug> static int m88rs2000_frontend_attach ( struct dvb_usb_adapter * d ) <S2SV_EndBug> { u8 obuf [ ] = { 0x51 } ; u8 ibuf [ ] = { 0 } ; <S2SV_StartBug> if ( dvb_usb_generic_rw ( d -> dev , obuf , 1 , ibuf , 1 , 0 ) < 0 ) <S2SV_EndBug> err ( "command<S2SV_blank>0x51<S2SV_blank>transfer<S2SV_blank>failed." ) ; <S2SV_StartBug> d -> fe_adap [ 0 ] . fe = dvb_attach ( m88rs2000_attach , & s421_m88rs2000_config , <S2SV_EndBug> <S2SV_StartBug> & d -> dev -> i2c_adap ) ; <S2SV_EndBug> <S2SV_StartBug> if ( d -> fe_adap [ 0 ] . fe == NULL ) <S2SV_EndBug> return - EIO ; <S2SV_StartBug> if ( dvb_attach ( ts2020_attach , d -> fe_adap [ 0 ] . fe , <S2SV_EndBug> & dw2104_ts2020_config , <S2SV_StartBug> & d -> dev -> i2c_adap ) ) { <S2SV_EndBug> info ( "Attached<S2SV_blank>RS2000/TS2020!" ) ; return 0 ; } info ( "Failed<S2SV_blank>to<S2SV_blank>attach<S2SV_blank>RS2000/TS2020!" ) ; return - EIO ; }
static int kvm_set_guest_paused ( struct kvm_vcpu * vcpu ) { <S2SV_StartBug> if ( ! vcpu -> arch . time_page ) <S2SV_EndBug> return - EINVAL ; vcpu -> arch . pvclock_set_guest_stopped_request = true ; kvm_make_request ( KVM_REQ_CLOCK_UPDATE , vcpu ) ; return 0 ; }
public int magic_setparam ( struct magic_set * ms , int param , const void * val ) { switch ( param ) { case MAGIC_PARAM_INDIR_MAX : ms -> indir_max = * ( const size_t * ) val ; return 0 ; case MAGIC_PARAM_NAME_MAX : ms -> name_max = * ( const size_t * ) val ; return 0 ; case MAGIC_PARAM_ELF_PHNUM_MAX : ms -> elf_phnum_max = * ( const size_t * ) val ; return 0 ; case MAGIC_PARAM_ELF_SHNUM_MAX : ms -> elf_shnum_max = * ( const size_t * ) val ; return 0 ; <S2SV_StartBug> default : <S2SV_EndBug> errno = EINVAL ; return - 1 ; } }
static int load_state_from_tss32 ( struct x86_emulate_ctxt * ctxt , struct tss_segment_32 * tss ) { int ret ; u8 cpl ; if ( ctxt -> ops -> set_cr ( ctxt , 3 , tss -> cr3 ) ) return emulate_gp ( ctxt , 0 ) ; ctxt -> _eip = tss -> eip ; ctxt -> eflags = tss -> eflags | 2 ; * reg_write ( ctxt , VCPU_REGS_RAX ) = tss -> eax ; * reg_write ( ctxt , VCPU_REGS_RCX ) = tss -> ecx ; * reg_write ( ctxt , VCPU_REGS_RDX ) = tss -> edx ; * reg_write ( ctxt , VCPU_REGS_RBX ) = tss -> ebx ; * reg_write ( ctxt , VCPU_REGS_RSP ) = tss -> esp ; * reg_write ( ctxt , VCPU_REGS_RBP ) = tss -> ebp ; * reg_write ( ctxt , VCPU_REGS_RSI ) = tss -> esi ; * reg_write ( ctxt , VCPU_REGS_RDI ) = tss -> edi ; set_segment_selector ( ctxt , tss -> ldt_selector , VCPU_SREG_LDTR ) ; set_segment_selector ( ctxt , tss -> es , VCPU_SREG_ES ) ; set_segment_selector ( ctxt , tss -> cs , VCPU_SREG_CS ) ; set_segment_selector ( ctxt , tss -> ss , VCPU_SREG_SS ) ; set_segment_selector ( ctxt , tss -> ds , VCPU_SREG_DS ) ; set_segment_selector ( ctxt , tss -> fs , VCPU_SREG_FS ) ; set_segment_selector ( ctxt , tss -> gs , VCPU_SREG_GS ) ; if ( ctxt -> eflags & X86_EFLAGS_VM ) { ctxt -> mode = X86EMUL_MODE_VM86 ; cpl = 3 ; } else { ctxt -> mode = X86EMUL_MODE_PROT32 ; cpl = tss -> cs & 3 ; } <S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> ldt_selector , VCPU_SREG_LDTR , cpl , true ) ; <S2SV_EndBug> if ( ret != X86EMUL_CONTINUE ) return ret ; <S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> es , VCPU_SREG_ES , cpl , true ) ; <S2SV_EndBug> if ( ret != X86EMUL_CONTINUE ) return ret ; <S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> cs , VCPU_SREG_CS , cpl , true ) ; <S2SV_EndBug> if ( ret != X86EMUL_CONTINUE ) return ret ; <S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> ss , VCPU_SREG_SS , cpl , true ) ; <S2SV_EndBug> if ( ret != X86EMUL_CONTINUE ) return ret ; <S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> ds , VCPU_SREG_DS , cpl , true ) ; <S2SV_EndBug> if ( ret != X86EMUL_CONTINUE ) return ret ; <S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> fs , VCPU_SREG_FS , cpl , true ) ; <S2SV_EndBug> if ( ret != X86EMUL_CONTINUE ) return ret ; <S2SV_StartBug> ret = __load_segment_descriptor ( ctxt , tss -> gs , VCPU_SREG_GS , cpl , true ) ; <S2SV_EndBug> if ( ret != X86EMUL_CONTINUE ) return ret ; return X86EMUL_CONTINUE ; }
static void * bpf_any_get ( void * raw , enum bpf_type type ) { switch ( type ) { case BPF_TYPE_PROG : <S2SV_StartBug> atomic_inc ( & ( ( struct bpf_prog * ) raw ) -> aux -> refcnt ) ; <S2SV_EndBug> break ; case BPF_TYPE_MAP : <S2SV_StartBug> bpf_map_inc ( raw , true ) ; <S2SV_EndBug> break ; default : WARN_ON_ONCE ( 1 ) ; break ; } return raw ; }
int lxc_attach ( const char * name , const char * lxcpath , lxc_attach_exec_t exec_function , void * exec_payload , lxc_attach_options_t * options , pid_t * attached_process ) { int ret , status ; pid_t init_pid , pid , attached_pid , expected ; struct lxc_proc_context_info * init_ctx ; char * cwd ; char * new_cwd ; int ipc_sockets [ 2 ] ; <S2SV_StartBug> signed long personality ; <S2SV_EndBug> if ( ! options ) options = & attach_static_default_options ; init_pid = lxc_cmd_get_init_pid ( name , lxcpath ) ; if ( init_pid < 0 ) { ERROR ( "failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>the<S2SV_blank>init<S2SV_blank>pid" ) ; return - 1 ; } init_ctx = lxc_proc_get_context_info ( init_pid ) ; if ( ! init_ctx ) { ERROR ( "failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>context<S2SV_blank>of<S2SV_blank>the<S2SV_blank>init<S2SV_blank>process,<S2SV_blank>pid<S2SV_blank>=<S2SV_blank>%ld" , ( long ) init_pid ) ; return - 1 ; } personality = get_personality ( name , lxcpath ) ; if ( init_ctx -> personality < 0 ) { ERROR ( "Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>personality<S2SV_blank>of<S2SV_blank>the<S2SV_blank>container" ) ; lxc_proc_put_context_info ( init_ctx ) ; return - 1 ; } init_ctx -> personality = personality ; if ( ! fetch_seccomp ( name , lxcpath , init_ctx , options ) ) WARN ( "Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>seccomp<S2SV_blank>policy" ) ; cwd = getcwd ( NULL , 0 ) ; if ( options -> namespaces == - 1 ) { options -> namespaces = lxc_cmd_get_clone_flags ( name , lxcpath ) ; if ( options -> namespaces == - 1 ) { ERROR ( "failed<S2SV_blank>to<S2SV_blank>automatically<S2SV_blank>determine<S2SV_blank>the<S2SV_blank>" "namespaces<S2SV_blank>which<S2SV_blank>the<S2SV_blank>container<S2SV_blank>unshared" ) ; free ( cwd ) ; lxc_proc_put_context_info ( init_ctx ) ; return - 1 ; } } ret = socketpair ( PF_LOCAL , SOCK_STREAM | SOCK_CLOEXEC , 0 , ipc_sockets ) ; if ( ret < 0 ) { SYSERROR ( "could<S2SV_blank>not<S2SV_blank>set<S2SV_blank>up<S2SV_blank>required<S2SV_blank>IPC<S2SV_blank>mechanism<S2SV_blank>for<S2SV_blank>attaching" ) ; free ( cwd ) ; lxc_proc_put_context_info ( init_ctx ) ; return - 1 ; } pid = fork ( ) ; if ( pid < 0 ) { SYSERROR ( "failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>first<S2SV_blank>subprocess" ) ; free ( cwd ) ; lxc_proc_put_context_info ( init_ctx ) ; return - 1 ; } if ( pid ) { pid_t to_cleanup_pid = pid ; close ( ipc_sockets [ 1 ] ) ; free ( cwd ) ; if ( options -> attach_flags & LXC_ATTACH_MOVE_TO_CGROUP ) { if ( ! cgroup_attach ( name , lxcpath , pid ) ) goto cleanup_error ; } status = 0 ; ret = lxc_write_nointr ( ipc_sockets [ 0 ] , & status , sizeof ( status ) ) ; if ( ret <= 0 ) { ERROR ( "error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>notify<S2SV_blank>attached<S2SV_blank>process<S2SV_blank>for<S2SV_blank>initialization<S2SV_blank>(0)" ) ; goto cleanup_error ; } ret = lxc_read_nointr_expect ( ipc_sockets [ 0 ] , & attached_pid , sizeof ( attached_pid ) , NULL ) ; if ( ret <= 0 ) { if ( ret != 0 ) ERROR ( "error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>pid<S2SV_blank>of<S2SV_blank>attached<S2SV_blank>process" ) ; goto cleanup_error ; } if ( options -> stdin_fd == 0 ) { signal ( SIGINT , SIG_IGN ) ; signal ( SIGQUIT , SIG_IGN ) ; } ret = wait_for_pid ( pid ) ; if ( ret < 0 ) goto cleanup_error ; to_cleanup_pid = attached_pid ; status = 0 ; ret = lxc_write_nointr ( ipc_sockets [ 0 ] , & status , sizeof ( status ) ) ; if ( ret <= 0 ) { ERROR ( "error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>notify<S2SV_blank>attached<S2SV_blank>process<S2SV_blank>for<S2SV_blank>initialization<S2SV_blank>(0)" ) ; goto cleanup_error ; } expected = 1 ; ret = lxc_read_nointr_expect ( ipc_sockets [ 0 ] , & status , sizeof ( status ) , & expected ) ; if ( ret <= 0 ) { if ( ret != 0 ) ERROR ( "error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>receive<S2SV_blank>notification<S2SV_blank>from<S2SV_blank>attached<S2SV_blank>process<S2SV_blank>(1)" ) ; goto cleanup_error ; } status = 2 ; ret = lxc_write_nointr ( ipc_sockets [ 0 ] , & status , sizeof ( status ) ) ; if ( ret <= 0 ) { ERROR ( "error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>notify<S2SV_blank>attached<S2SV_blank>process<S2SV_blank>for<S2SV_blank>initialization<S2SV_blank>(2)" ) ; goto cleanup_error ; } shutdown ( ipc_sockets [ 0 ] , SHUT_RDWR ) ; close ( ipc_sockets [ 0 ] ) ; lxc_proc_put_context_info ( init_ctx ) ; * attached_process = attached_pid ; return 0 ; cleanup_error : shutdown ( ipc_sockets [ 0 ] , SHUT_RDWR ) ; close ( ipc_sockets [ 0 ] ) ; if ( to_cleanup_pid ) ( void ) wait_for_pid ( to_cleanup_pid ) ; lxc_proc_put_context_info ( init_ctx ) ; return - 1 ; } close ( ipc_sockets [ 0 ] ) ; expected = 0 ; status = - 1 ; ret = lxc_read_nointr_expect ( ipc_sockets [ 1 ] , & status , sizeof ( status ) , & expected ) ; if ( ret <= 0 ) { ERROR ( "error<S2SV_blank>communicating<S2SV_blank>with<S2SV_blank>child<S2SV_blank>process" ) ; shutdown ( ipc_sockets [ 1 ] , SHUT_RDWR ) ; rexit ( - 1 ) ; } <S2SV_StartBug> ret = lxc_attach_to_ns ( init_pid , options -> namespaces ) ; <S2SV_EndBug> if ( ret < 0 ) { ERROR ( "failed<S2SV_blank>to<S2SV_blank>enter<S2SV_blank>the<S2SV_blank>namespace" ) ; shutdown ( ipc_sockets [ 1 ] , SHUT_RDWR ) ; rexit ( - 1 ) ; } if ( options -> initial_cwd ) new_cwd = options -> initial_cwd ; else new_cwd = cwd ; ret = chdir ( new_cwd ) ; if ( ret < 0 ) WARN ( "could<S2SV_blank>not<S2SV_blank>change<S2SV_blank>directory<S2SV_blank>to<S2SV_blank>\'%s\'" , new_cwd ) ; free ( cwd ) ; { struct attach_clone_payload payload = { . ipc_socket = ipc_sockets [ 1 ] , . options = options , . init_ctx = init_ctx , . exec_function = exec_function , <S2SV_StartBug> . exec_payload = exec_payload <S2SV_EndBug> } ; pid = lxc_clone ( attach_child_main , & payload , CLONE_PARENT ) ; } if ( pid <= 0 ) { SYSERROR ( "failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>subprocess" ) ; shutdown ( ipc_sockets [ 1 ] , SHUT_RDWR ) ; rexit ( - 1 ) ; } ret = lxc_write_nointr ( ipc_sockets [ 1 ] , & pid , sizeof ( pid ) ) ; if ( ret != sizeof ( pid ) ) { ERROR ( "error<S2SV_blank>using<S2SV_blank>IPC<S2SV_blank>to<S2SV_blank>notify<S2SV_blank>main<S2SV_blank>process<S2SV_blank>of<S2SV_blank>pid<S2SV_blank>of<S2SV_blank>the<S2SV_blank>attached<S2SV_blank>process" ) ; shutdown ( ipc_sockets [ 1 ] , SHUT_RDWR ) ; rexit ( - 1 ) ; } rexit ( 0 ) ; }
static int recv_msg ( struct kiocb * iocb , struct socket * sock , struct msghdr * m , size_t buf_len , int flags ) { struct sock * sk = sock -> sk ; struct tipc_port * tport = tipc_sk_port ( sk ) ; struct sk_buff * buf ; struct tipc_msg * msg ; long timeout ; unsigned int sz ; u32 err ; int res ; if ( unlikely ( ! buf_len ) ) return - EINVAL ; lock_sock ( sk ) ; if ( unlikely ( sock -> state == SS_UNCONNECTED ) ) { res = - ENOTCONN ; goto exit ; } <S2SV_StartBug> timeout = sock_rcvtimeo ( sk , flags & MSG_DONTWAIT ) ; <S2SV_EndBug> restart : while ( skb_queue_empty ( & sk -> sk_receive_queue ) ) { if ( sock -> state == SS_DISCONNECTING ) { res = - ENOTCONN ; goto exit ; } if ( timeout <= 0L ) { res = timeout ? timeout : - EWOULDBLOCK ; goto exit ; } release_sock ( sk ) ; timeout = wait_event_interruptible_timeout ( * sk_sleep ( sk ) , tipc_rx_ready ( sock ) , timeout ) ; lock_sock ( sk ) ; } buf = skb_peek ( & sk -> sk_receive_queue ) ; msg = buf_msg ( buf ) ; sz = msg_data_sz ( msg ) ; err = msg_errcode ( msg ) ; if ( ( ! sz ) && ( ! err ) ) { advance_rx_queue ( sk ) ; goto restart ; } set_orig_addr ( m , msg ) ; res = anc_data_recv ( m , msg , tport ) ; if ( res ) goto exit ; if ( ! err ) { if ( unlikely ( buf_len < sz ) ) { sz = buf_len ; m -> msg_flags |= MSG_TRUNC ; } res = skb_copy_datagram_iovec ( buf , msg_hdr_sz ( msg ) , m -> msg_iov , sz ) ; if ( res ) goto exit ; res = sz ; } else { if ( ( sock -> state == SS_READY ) || ( ( err == TIPC_CONN_SHUTDOWN ) || m -> msg_control ) ) res = 0 ; else res = - ECONNRESET ; } if ( likely ( ! ( flags & MSG_PEEK ) ) ) { if ( ( sock -> state != SS_READY ) && ( ++ tport -> conn_unacked >= TIPC_FLOW_CONTROL_WIN ) ) tipc_acknowledge ( tport -> ref , tport -> conn_unacked ) ; advance_rx_queue ( sk ) ; } exit : release_sock ( sk ) ; return res ; }
static __u8 * mr_report_fixup ( struct hid_device * hdev , __u8 * rdesc , unsigned int * rsize ) { <S2SV_StartBug> if ( * rsize >= 30 && rdesc [ 29 ] == 0x05 && rdesc [ 30 ] == 0x09 ) { <S2SV_EndBug> hid_info ( hdev , "fixing<S2SV_blank>up<S2SV_blank>button/consumer<S2SV_blank>in<S2SV_blank>HID<S2SV_blank>report<S2SV_blank>descriptor\\n" ) ; rdesc [ 30 ] = 0x0c ; } return rdesc ; }
int kvm_iommu_map_pages ( struct kvm * kvm , struct kvm_memory_slot * slot ) { gfn_t gfn , end_gfn ; pfn_t pfn ; int r = 0 ; struct iommu_domain * domain = kvm -> arch . iommu_domain ; int flags ; if ( ! domain ) return 0 ; gfn = slot -> base_gfn ; end_gfn = gfn + slot -> npages ; flags = IOMMU_READ ; if ( ! ( slot -> flags & KVM_MEM_READONLY ) ) flags |= IOMMU_WRITE ; if ( ! kvm -> arch . iommu_noncoherent ) flags |= IOMMU_CACHE ; while ( gfn < end_gfn ) { unsigned long page_size ; if ( iommu_iova_to_phys ( domain , gfn_to_gpa ( gfn ) ) ) { gfn += 1 ; continue ; } page_size = kvm_host_page_size ( kvm , gfn ) ; while ( ( gfn + ( page_size >> PAGE_SHIFT ) ) > end_gfn ) page_size >>= 1 ; while ( ( gfn << PAGE_SHIFT ) & ( page_size - 1 ) ) page_size >>= 1 ; while ( __gfn_to_hva_memslot ( slot , gfn ) & ( page_size - 1 ) ) page_size >>= 1 ; <S2SV_StartBug> pfn = kvm_pin_pages ( slot , gfn , page_size ) ; <S2SV_EndBug> if ( is_error_noslot_pfn ( pfn ) ) { gfn += 1 ; continue ; } r = iommu_map ( domain , gfn_to_gpa ( gfn ) , pfn_to_hpa ( pfn ) , page_size , flags ) ; if ( r ) { printk ( KERN_ERR "kvm_iommu_map_address:" "iommu<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>map<S2SV_blank>pfn=%llx\\n" , pfn ) ; <S2SV_StartBug> kvm_unpin_pages ( kvm , pfn , page_size ) ; <S2SV_EndBug> goto unmap_pages ; } gfn += page_size >> PAGE_SHIFT ; } return 0 ; unmap_pages : kvm_iommu_put_pages ( kvm , slot -> base_gfn , gfn - slot -> base_gfn ) ; return r ; }
static u64 __skb_get_nlattr ( u64 ctx , u64 A , u64 X , u64 r4 , u64 r5 ) { struct sk_buff * skb = ( struct sk_buff * ) ( long ) ctx ; struct nlattr * nla ; <S2SV_StartBug> if ( skb_is_nonlinear ( skb ) ) <S2SV_EndBug> return 0 ; if ( A > skb -> len - sizeof ( struct nlattr ) ) return 0 ; nla = nla_find ( ( struct nlattr * ) & skb -> data [ A ] , skb -> len - A , X ) ; if ( nla ) return ( void * ) nla - ( void * ) skb -> data ; return 0 ; }
int udpv6_recvmsg ( struct sock * sk , struct msghdr * msg , size_t len , int noblock , int flags , int * addr_len ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct inet_sock * inet = inet_sk ( sk ) ; struct sk_buff * skb ; unsigned int ulen , copied ; int peeked , off = 0 ; int err ; <S2SV_StartBug> int is_udplite = IS_UDPLITE ( sk ) ; <S2SV_EndBug> int is_udp4 ; bool slow ; if ( flags & MSG_ERRQUEUE ) return ipv6_recv_error ( sk , msg , len , addr_len ) ; if ( np -> rxpmtu && np -> rxopt . bits . rxpmtu ) return ipv6_recv_rxpmtu ( sk , msg , len , addr_len ) ; try_again : skb = __skb_recv_datagram ( sk , flags | ( noblock ? MSG_DONTWAIT : 0 ) , & peeked , & off , & err ) ; if ( ! skb ) goto out ; ulen = skb -> len - sizeof ( struct udphdr ) ; copied = len ; if ( copied > ulen ) copied = ulen ; else if ( copied < ulen ) msg -> msg_flags |= MSG_TRUNC ; is_udp4 = ( skb -> protocol == htons ( ETH_P_IP ) ) ; if ( copied < ulen || UDP_SKB_CB ( skb ) -> partial_cov ) { <S2SV_StartBug> if ( udp_lib_checksum_complete ( skb ) ) <S2SV_EndBug> goto csum_copy_err ; } <S2SV_StartBug> if ( skb_csum_unnecessary ( skb ) ) <S2SV_EndBug> err = skb_copy_datagram_msg ( skb , sizeof ( struct udphdr ) , msg , copied ) ; else { err = skb_copy_and_csum_datagram_msg ( skb , sizeof ( struct udphdr ) , msg ) ; if ( err == - EINVAL ) goto csum_copy_err ; } if ( unlikely ( err ) ) { trace_kfree_skb ( skb , udpv6_recvmsg ) ; if ( ! peeked ) { atomic_inc ( & sk -> sk_drops ) ; if ( is_udp4 ) UDP_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INERRORS , is_udplite ) ; else UDP6_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INERRORS , is_udplite ) ; } goto out_free ; } if ( ! peeked ) { if ( is_udp4 ) UDP_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INDATAGRAMS , is_udplite ) ; else UDP6_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INDATAGRAMS , is_udplite ) ; } sock_recv_ts_and_drops ( msg , sk , skb ) ; if ( msg -> msg_name ) { DECLARE_SOCKADDR ( struct sockaddr_in6 * , sin6 , msg -> msg_name ) ; sin6 -> sin6_family = AF_INET6 ; sin6 -> sin6_port = udp_hdr ( skb ) -> source ; sin6 -> sin6_flowinfo = 0 ; if ( is_udp4 ) { ipv6_addr_set_v4mapped ( ip_hdr ( skb ) -> saddr , & sin6 -> sin6_addr ) ; sin6 -> sin6_scope_id = 0 ; } else { sin6 -> sin6_addr = ipv6_hdr ( skb ) -> saddr ; sin6 -> sin6_scope_id = ipv6_iface_scope_id ( & sin6 -> sin6_addr , inet6_iif ( skb ) ) ; } * addr_len = sizeof ( * sin6 ) ; } if ( np -> rxopt . all ) ip6_datagram_recv_common_ctl ( sk , msg , skb ) ; if ( is_udp4 ) { if ( inet -> cmsg_flags ) ip_cmsg_recv ( msg , skb ) ; } else { if ( np -> rxopt . all ) ip6_datagram_recv_specific_ctl ( sk , msg , skb ) ; } err = copied ; if ( flags & MSG_TRUNC ) err = ulen ; out_free : skb_free_datagram_locked ( sk , skb ) ; out : return err ; csum_copy_err : slow = lock_sock_fast ( sk ) ; if ( ! skb_kill_datagram ( sk , skb , flags ) ) { if ( is_udp4 ) { UDP_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_CSUMERRORS , is_udplite ) ; UDP_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INERRORS , is_udplite ) ; } else { UDP6_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_CSUMERRORS , is_udplite ) ; UDP6_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INERRORS , is_udplite ) ; } } unlock_sock_fast ( sk , slow ) ; cond_resched ( ) ; msg -> msg_flags &= ~ MSG_TRUNC ; goto try_again ; }
SPL_METHOD ( SplFileObject , fread ) { spl_filesystem_object * intern = ( spl_filesystem_object * ) zend_object_store_get_object ( getThis ( ) TSRMLS_CC ) ; long length = 0 ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , "l" , & length ) == FAILURE ) { return ; } if ( length <= 0 ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , "Length<S2SV_blank>parameter<S2SV_blank>must<S2SV_blank>be<S2SV_blank>greater<S2SV_blank>than<S2SV_blank>0" ) ; RETURN_FALSE ; } <S2SV_StartBug> Z_STRVAL_P ( return_value ) = emalloc ( length + 1 ) ; <S2SV_EndBug> Z_STRLEN_P ( return_value ) = php_stream_read ( intern -> u . file . stream , Z_STRVAL_P ( return_value ) , length ) ; Z_STRVAL_P ( return_value ) [ Z_STRLEN_P ( return_value ) ] = 0 ; Z_TYPE_P ( return_value ) = IS_STRING ; }
<S2SV_StartBug> jas_iccprof_t * jas_iccprof_createfrombuf ( uchar * buf , int len ) <S2SV_EndBug> { jas_stream_t * in ; jas_iccprof_t * prof ; if ( ! ( in = jas_stream_memopen ( JAS_CAST ( char * , buf ) , len ) ) ) goto error ; if ( ! ( prof = jas_iccprof_load ( in ) ) ) goto error ; jas_stream_close ( in ) ; return prof ; error : if ( in ) jas_stream_close ( in ) ; return 0 ; }
static int install_process_keyring ( void ) { struct cred * new ; int ret ; new = prepare_creds ( ) ; if ( ! new ) return - ENOMEM ; ret = install_process_keyring_to_cred ( new ) ; if ( ret < 0 ) { abort_creds ( new ) ; <S2SV_StartBug> return ret != - EEXIST ? ret : 0 ; <S2SV_EndBug> } return commit_creds ( new ) ; }
TfLiteIntArray * TfLiteIntArrayCreate ( int size ) { <S2SV_StartBug> TfLiteIntArray * ret = <S2SV_EndBug> <S2SV_StartBug> ( TfLiteIntArray * ) malloc ( TfLiteIntArrayGetSizeInBytes ( size ) ) ; <S2SV_EndBug> ret -> size = size ; return ret ; }
static int gs_usb_probe ( struct usb_interface * intf , const struct usb_device_id * id ) { struct gs_usb * dev ; int rc = - ENOMEM ; unsigned int icount , i ; <S2SV_StartBug> struct gs_host_config hconf = { <S2SV_EndBug> . byte_order = 0x0000beef , } ; <S2SV_StartBug> struct gs_device_config dconf ; <S2SV_EndBug> rc = usb_control_msg ( interface_to_usbdev ( intf ) , usb_sndctrlpipe ( interface_to_usbdev ( intf ) , 0 ) , GS_USB_BREQ_HOST_FORMAT , USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_INTERFACE , 1 , intf -> altsetting [ 0 ] . desc . bInterfaceNumber , <S2SV_StartBug> & hconf , <S2SV_EndBug> <S2SV_StartBug> sizeof ( hconf ) , <S2SV_EndBug> 1000 ) ; <S2SV_StartBug> if ( rc < 0 ) { <S2SV_EndBug> dev_err ( & intf -> dev , "Couldn\'t<S2SV_blank>send<S2SV_blank>data<S2SV_blank>format<S2SV_blank>(err=%d)\\n" , rc ) ; return rc ; <S2SV_StartBug> } <S2SV_EndBug> rc = usb_control_msg ( interface_to_usbdev ( intf ) , usb_rcvctrlpipe ( interface_to_usbdev ( intf ) , 0 ) , GS_USB_BREQ_DEVICE_CONFIG , USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_INTERFACE , 1 , intf -> altsetting [ 0 ] . desc . bInterfaceNumber , <S2SV_StartBug> & dconf , <S2SV_EndBug> <S2SV_StartBug> sizeof ( dconf ) , <S2SV_EndBug> 1000 ) ; if ( rc < 0 ) { dev_err ( & intf -> dev , "Couldn\'t<S2SV_blank>get<S2SV_blank>device<S2SV_blank>config:<S2SV_blank>(err=%d)\\n" , rc ) ; <S2SV_StartBug> return rc ; <S2SV_EndBug> } icount = dconf . icount + 1 ; dev_info ( & intf -> dev , "Configuring<S2SV_blank>for<S2SV_blank>%d<S2SV_blank>interfaces\\n" , icount ) ; if ( icount > GS_MAX_INTF ) { dev_err ( & intf -> dev , "Driver<S2SV_blank>cannot<S2SV_blank>handle<S2SV_blank>more<S2SV_blank>that<S2SV_blank>%d<S2SV_blank>CAN<S2SV_blank>interfaces\\n" , GS_MAX_INTF ) ; <S2SV_StartBug> return - EINVAL ; <S2SV_EndBug> } dev = kzalloc ( sizeof ( * dev ) , GFP_KERNEL ) ; <S2SV_StartBug> if ( ! dev ) <S2SV_EndBug> return - ENOMEM ; <S2SV_StartBug> init_usb_anchor ( & dev -> rx_submitted ) ; <S2SV_EndBug> atomic_set ( & dev -> active_channels , 0 ) ; usb_set_intfdata ( intf , dev ) ; dev -> udev = interface_to_usbdev ( intf ) ; for ( i = 0 ; i < icount ; i ++ ) { <S2SV_StartBug> dev -> canch [ i ] = gs_make_candev ( i , intf , & dconf ) ; <S2SV_EndBug> if ( IS_ERR_OR_NULL ( dev -> canch [ i ] ) ) { rc = PTR_ERR ( dev -> canch [ i ] ) ; icount = i ; for ( i = 0 ; i < icount ; i ++ ) gs_destroy_candev ( dev -> canch [ i ] ) ; usb_kill_anchored_urbs ( & dev -> rx_submitted ) ; <S2SV_StartBug> kfree ( dev ) ; <S2SV_EndBug> return rc ; } dev -> canch [ i ] -> parent = dev ; } <S2SV_StartBug> return 0 ; <S2SV_EndBug> }
static int rose_parse_ccitt ( unsigned char * p , struct rose_facilities_struct * facilities , int len ) { unsigned char l , n = 0 ; char callsign [ 11 ] ; do { switch ( * p & 0xC0 ) { case 0x00 : <S2SV_StartBug> p += 2 ; <S2SV_EndBug> n += 2 ; len -= 2 ; break ; case 0x40 : <S2SV_StartBug> p += 3 ; <S2SV_EndBug> n += 3 ; len -= 3 ; break ; case 0x80 : <S2SV_StartBug> p += 4 ; <S2SV_EndBug> n += 4 ; len -= 4 ; break ; case 0xC0 : <S2SV_StartBug> l = p [ 1 ] ; <S2SV_EndBug> if ( l < 10 || l > 20 ) return - 1 ; if ( * p == FAC_CCITT_DEST_NSAP ) { memcpy ( & facilities -> source_addr , p + 7 , ROSE_ADDR_LEN ) ; memcpy ( callsign , p + 12 , l - 10 ) ; callsign [ l - 10 ] = '\\0' ; asc2ax ( & facilities -> source_call , callsign ) ; } if ( * p == FAC_CCITT_SRC_NSAP ) { memcpy ( & facilities -> dest_addr , p + 7 , ROSE_ADDR_LEN ) ; memcpy ( callsign , p + 12 , l - 10 ) ; callsign [ l - 10 ] = '\\0' ; asc2ax ( & facilities -> dest_call , callsign ) ; } p += l + 2 ; n += l + 2 ; len -= l + 2 ; break ; } } while ( * p != 0x00 && len > 0 ) ; return n ; }
static TEE_Result tee_svc_copy_param ( struct tee_ta_session * sess , struct tee_ta_session * called_sess , struct utee_params * callee_params , struct tee_ta_param * param , void * tmp_buf_va [ TEE_NUM_PARAMS ] , struct mobj * * mobj_tmp ) { size_t n ; TEE_Result res ; size_t req_mem = 0 ; size_t s ; uint8_t * dst = 0 ; bool ta_private_memref [ TEE_NUM_PARAMS ] ; struct user_ta_ctx * utc = to_user_ta_ctx ( sess -> ctx ) ; void * va ; size_t dst_offs ; if ( ! callee_params ) { memset ( param , 0 , sizeof ( * param ) ) ; } else { res = tee_mmu_check_access_rights ( utc , TEE_MEMORY_ACCESS_READ | TEE_MEMORY_ACCESS_ANY_OWNER , ( uaddr_t ) callee_params , sizeof ( struct utee_params ) ) ; if ( res != TEE_SUCCESS ) return res ; <S2SV_StartBug> utee_param_to_param ( param , callee_params ) ; <S2SV_EndBug> } if ( called_sess && is_pseudo_ta_ctx ( called_sess -> ctx ) ) { return TEE_SUCCESS ; } for ( n = 0 ; n < TEE_NUM_PARAMS ; n ++ ) { ta_private_memref [ n ] = false ; switch ( TEE_PARAM_TYPE_GET ( param -> types , n ) ) { case TEE_PARAM_TYPE_MEMREF_INPUT : case TEE_PARAM_TYPE_MEMREF_OUTPUT : case TEE_PARAM_TYPE_MEMREF_INOUT : va = ( void * ) param -> u [ n ] . mem . offs ; s = param -> u [ n ] . mem . size ; if ( ! va ) { if ( s ) return TEE_ERROR_BAD_PARAMETERS ; break ; } if ( tee_mmu_is_vbuf_inside_ta_private ( utc , va , s ) ) { s = ROUNDUP ( s , sizeof ( uint32_t ) ) ; if ( ADD_OVERFLOW ( req_mem , s , & req_mem ) ) return TEE_ERROR_BAD_PARAMETERS ; ta_private_memref [ n ] = true ; break ; } res = tee_mmu_vbuf_to_mobj_offs ( utc , va , s , & param -> u [ n ] . mem . mobj , & param -> u [ n ] . mem . offs ) ; if ( res != TEE_SUCCESS ) return res ; break ; default : break ; } } if ( req_mem == 0 ) return TEE_SUCCESS ; res = alloc_temp_sec_mem ( req_mem , mobj_tmp , & dst ) ; if ( res != TEE_SUCCESS ) return res ; dst_offs = 0 ; for ( n = 0 ; n < TEE_NUM_PARAMS ; n ++ ) { if ( ! ta_private_memref [ n ] ) continue ; s = ROUNDUP ( param -> u [ n ] . mem . size , sizeof ( uint32_t ) ) ; switch ( TEE_PARAM_TYPE_GET ( param -> types , n ) ) { case TEE_PARAM_TYPE_MEMREF_INPUT : case TEE_PARAM_TYPE_MEMREF_INOUT : va = ( void * ) param -> u [ n ] . mem . offs ; if ( va ) { res = tee_svc_copy_from_user ( dst , va , param -> u [ n ] . mem . size ) ; if ( res != TEE_SUCCESS ) return res ; param -> u [ n ] . mem . offs = dst_offs ; param -> u [ n ] . mem . mobj = * mobj_tmp ; tmp_buf_va [ n ] = dst ; dst += s ; dst_offs += s ; } break ; case TEE_PARAM_TYPE_MEMREF_OUTPUT : va = ( void * ) param -> u [ n ] . mem . offs ; if ( va ) { param -> u [ n ] . mem . offs = dst_offs ; param -> u [ n ] . mem . mobj = * mobj_tmp ; tmp_buf_va [ n ] = dst ; dst += s ; dst_offs += s ; } break ; default : continue ; } } return TEE_SUCCESS ; }
static Image * ReadDIBImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { DIBInfo dib_info ; Image * image ; IndexPacket index ; ssize_t bit , y ; MagickBooleanType status ; MemoryInfo * pixel_info ; register IndexPacket * indexes ; register ssize_t x ; register PixelPacket * q ; register ssize_t i ; register unsigned char * p ; size_t bytes_per_line , length ; ssize_t count ; unsigned char * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , "%s" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) ResetMagickMemory ( & dib_info , 0 , sizeof ( dib_info ) ) ; dib_info . size = ReadBlobLSBLong ( image ) ; if ( dib_info . size != 40 ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; dib_info . width = ( short ) ReadBlobLSBLong ( image ) ; dib_info . height = ( short ) ReadBlobLSBLong ( image ) ; dib_info . planes = ReadBlobLSBShort ( image ) ; dib_info . bits_per_pixel = ReadBlobLSBShort ( image ) ; dib_info . compression = ReadBlobLSBLong ( image ) ; dib_info . image_size = ReadBlobLSBLong ( image ) ; dib_info . x_pixels = ReadBlobLSBLong ( image ) ; dib_info . y_pixels = ReadBlobLSBLong ( image ) ; dib_info . number_colors = ReadBlobLSBLong ( image ) ; dib_info . colors_important = ReadBlobLSBLong ( image ) ; if ( ( dib_info . compression == BI_BITFIELDS ) && ( ( dib_info . bits_per_pixel == 16 ) || ( dib_info . bits_per_pixel == 32 ) ) ) { dib_info . red_mask = ReadBlobLSBLong ( image ) ; dib_info . green_mask = ReadBlobLSBLong ( image ) ; dib_info . blue_mask = ReadBlobLSBLong ( image ) ; } image -> matte = dib_info . bits_per_pixel == 32 ? MagickTrue : MagickFalse ; image -> columns = ( size_t ) MagickAbsoluteValue ( dib_info . width ) ; image -> rows = ( size_t ) MagickAbsoluteValue ( dib_info . height ) ; image -> depth = 8 ; if ( ( dib_info . number_colors != 0 ) || ( dib_info . bits_per_pixel < 16 ) ) { size_t one ; image -> storage_class = PseudoClass ; image -> colors = dib_info . number_colors ; one = 1 ; if ( image -> colors == 0 ) image -> colors = one << dib_info . bits_per_pixel ; } if ( image_info -> size ) { RectangleInfo geometry ; MagickStatusType flags ; flags = ParseAbsoluteGeometry ( image_info -> size , & geometry ) ; if ( flags & WidthValue ) if ( ( geometry . width != 0 ) && ( geometry . width < image -> columns ) ) image -> columns = geometry . width ; if ( flags & HeightValue ) if ( ( geometry . height != 0 ) && ( geometry . height < image -> rows ) ) image -> rows = geometry . height ; } <S2SV_StartBug> if ( image -> storage_class == PseudoClass ) <S2SV_EndBug> { size_t length , packet_size ; unsigned char * dib_colormap ; if ( AcquireImageColormap ( image , image -> colors ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; length = ( size_t ) image -> colors ; dib_colormap = ( unsigned char * ) AcquireQuantumMemory ( length , 4 * sizeof ( * dib_colormap ) ) ; if ( dib_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; packet_size = 4 ; count = ReadBlob ( image , packet_size * image -> colors , dib_colormap ) ; if ( count != ( ssize_t ) ( packet_size * image -> colors ) ) ThrowReaderException ( CorruptImageError , "InsufficientImageDataInFile" ) ; p = dib_colormap ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) { image -> colormap [ i ] . blue = ScaleCharToQuantum ( * p ++ ) ; image -> colormap [ i ] . green = ScaleCharToQuantum ( * p ++ ) ; image -> colormap [ i ] . red = ScaleCharToQuantum ( * p ++ ) ; if ( packet_size == 4 ) p ++ ; } dib_colormap = ( unsigned char * ) RelinquishMagickMemory ( dib_colormap ) ; } if ( dib_info . compression == BI_RLE4 ) dib_info . bits_per_pixel <<= 1 ; bytes_per_line = 4 * ( ( image -> columns * dib_info . bits_per_pixel + 31 ) / 32 ) ; length = bytes_per_line * image -> rows ; pixel_info = AcquireVirtualMemory ( ( size_t ) image -> rows , MagickMax ( bytes_per_line , image -> columns + 256UL ) * sizeof ( * pixels ) ) ; if ( pixel_info == ( MemoryInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; pixels = ( unsigned char * ) GetVirtualMemoryBlob ( pixel_info ) ; if ( ( dib_info . compression == BI_RGB ) || ( dib_info . compression == BI_BITFIELDS ) ) { count = ReadBlob ( image , length , pixels ) ; if ( count != ( ssize_t ) ( length ) ) ThrowReaderException ( CorruptImageError , "InsufficientImageDataInFile" ) ; } else { status = DecodeImage ( image , dib_info . compression ? MagickTrue : MagickFalse , pixels ) ; if ( status == MagickFalse ) ThrowReaderException ( CorruptImageError , "UnableToRunlengthDecodeImage" ) ; } image -> units = PixelsPerCentimeterResolution ; image -> x_resolution = ( double ) dib_info . x_pixels / 100.0 ; image -> y_resolution = ( double ) dib_info . y_pixels / 100.0 ; switch ( dib_info . bits_per_pixel ) { case 1 : { for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; indexes = GetAuthenticIndexQueue ( image ) ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 7 ) ; x += 8 ) { for ( bit = 0 ; bit < 8 ; bit ++ ) { index = ( IndexPacket ) ( ( * p ) & ( 0x80 >> bit ) ? 0x01 : 0x00 ) ; SetPixelIndex ( indexes + x + bit , index ) ; } p ++ ; } if ( ( image -> columns % 8 ) != 0 ) { for ( bit = 0 ; bit < ( ssize_t ) ( image -> columns % 8 ) ; bit ++ ) { index = ( IndexPacket ) ( ( * p ) & ( 0x80 >> bit ) ? 0x01 : 0x00 ) ; SetPixelIndex ( indexes + x + bit , index ) ; } p ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , image -> rows - y - 1 , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image ) ; break ; } case 4 : { for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; indexes = GetAuthenticIndexQueue ( image ) ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 1 ) ; x += 2 ) { index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0xf ) ; SetPixelIndex ( indexes + x , index ) ; index = ConstrainColormapIndex ( image , * p & 0xf ) ; SetPixelIndex ( indexes + x + 1 , index ) ; p ++ ; } if ( ( image -> columns % 2 ) != 0 ) { index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0xf ) ; SetPixelIndex ( indexes + x , index ) ; p ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , image -> rows - y - 1 , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image ) ; break ; } case 8 : { if ( ( dib_info . compression == BI_RLE8 ) || ( dib_info . compression == BI_RLE4 ) ) bytes_per_line = image -> columns ; for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; indexes = GetAuthenticIndexQueue ( image ) ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { index = ConstrainColormapIndex ( image , * p ) ; SetPixelIndex ( indexes + x , index ) ; p ++ ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , image -> rows - y - 1 , image -> rows ) ; if ( status == MagickFalse ) break ; } } ( void ) SyncImage ( image ) ; break ; } case 16 : { unsigned short word ; image -> storage_class = DirectClass ; if ( dib_info . compression == BI_RLE8 ) bytes_per_line = 2 * image -> columns ; for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { word = ( * p ++ ) ; word |= ( * p ++ << 8 ) ; if ( dib_info . red_mask == 0 ) { SetPixelRed ( q , ScaleCharToQuantum ( ScaleColor5to8 ( ( unsigned char ) ( ( word >> 10 ) & 0x1f ) ) ) ) ; SetPixelGreen ( q , ScaleCharToQuantum ( ScaleColor5to8 ( ( unsigned char ) ( ( word >> 5 ) & 0x1f ) ) ) ) ; SetPixelBlue ( q , ScaleCharToQuantum ( ScaleColor5to8 ( ( unsigned char ) ( word & 0x1f ) ) ) ) ; } else { SetPixelRed ( q , ScaleCharToQuantum ( ScaleColor5to8 ( ( unsigned char ) ( ( word >> 11 ) & 0x1f ) ) ) ) ; SetPixelGreen ( q , ScaleCharToQuantum ( ScaleColor6to8 ( ( unsigned char ) ( ( word >> 5 ) & 0x3f ) ) ) ) ; SetPixelBlue ( q , ScaleCharToQuantum ( ScaleColor5to8 ( ( unsigned char ) ( word & 0x1f ) ) ) ) ; } q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , image -> rows - y - 1 , image -> rows ) ; if ( status == MagickFalse ) break ; } } break ; } case 24 : case 32 : { for ( y = ( ssize_t ) image -> rows - 1 ; y >= 0 ; y -- ) { p = pixels + ( image -> rows - y - 1 ) * bytes_per_line ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelBlue ( q , ScaleCharToQuantum ( * p ++ ) ) ; SetPixelGreen ( q , ScaleCharToQuantum ( * p ++ ) ) ; SetPixelRed ( q , ScaleCharToQuantum ( * p ++ ) ) ; if ( image -> matte != MagickFalse ) SetPixelOpacity ( q , ScaleCharToQuantum ( * p ++ ) ) ; q ++ ; } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , image -> rows - y - 1 , image -> rows ) ; if ( status == MagickFalse ) break ; } } break ; } default : ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; } pixel_info = RelinquishVirtualMemory ( pixel_info ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowFileException ( exception , CorruptImageError , "UnexpectedEndOfFile" , image -> filename ) ; if ( dib_info . height < 0 ) { Image * flipped_image ; flipped_image = FlipImage ( image , exception ) ; if ( flipped_image != ( Image * ) NULL ) { DuplicateBlob ( flipped_image , image ) ; image = DestroyImage ( image ) ; image = flipped_image ; } } ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
int kvm_set_msr_common ( struct kvm_vcpu * vcpu , struct msr_data * msr_info ) { bool pr = false ; u32 msr = msr_info -> index ; u64 data = msr_info -> data ; switch ( msr ) { case MSR_AMD64_NB_CFG : case MSR_IA32_UCODE_REV : case MSR_IA32_UCODE_WRITE : case MSR_VM_HSAVE_PA : case MSR_AMD64_PATCH_LOADER : case MSR_AMD64_BU_CFG2 : break ; case MSR_EFER : return set_efer ( vcpu , data ) ; case MSR_K7_HWCR : data &= ~ ( u64 ) 0x40 ; data &= ~ ( u64 ) 0x100 ; data &= ~ ( u64 ) 0x8 ; if ( data != 0 ) { vcpu_unimpl ( vcpu , "unimplemented<S2SV_blank>HWCR<S2SV_blank>wrmsr:<S2SV_blank>0x%llx\\n" , data ) ; return 1 ; } break ; case MSR_FAM10H_MMIO_CONF_BASE : if ( data != 0 ) { vcpu_unimpl ( vcpu , "unimplemented<S2SV_blank>MMIO_CONF_BASE<S2SV_blank>wrmsr:<S2SV_blank>" "0x%llx\\n" , data ) ; return 1 ; } break ; case MSR_IA32_DEBUGCTLMSR : if ( ! data ) { break ; } else if ( data & ~ ( DEBUGCTLMSR_LBR | DEBUGCTLMSR_BTF ) ) { return 1 ; } vcpu_unimpl ( vcpu , "%s:<S2SV_blank>MSR_IA32_DEBUGCTLMSR<S2SV_blank>0x%llx,<S2SV_blank>nop\\n" , __func__ , data ) ; break ; case 0x200 ... 0x2ff : return set_msr_mtrr ( vcpu , msr , data ) ; case MSR_IA32_APICBASE : kvm_set_apic_base ( vcpu , data ) ; break ; case APIC_BASE_MSR ... APIC_BASE_MSR + 0x3ff : return kvm_x2apic_msr_write ( vcpu , msr , data ) ; case MSR_IA32_TSCDEADLINE : kvm_set_lapic_tscdeadline_msr ( vcpu , data ) ; break ; case MSR_IA32_TSC_ADJUST : if ( guest_cpuid_has_tsc_adjust ( vcpu ) ) { if ( ! msr_info -> host_initiated ) { u64 adj = data - vcpu -> arch . ia32_tsc_adjust_msr ; kvm_x86_ops -> adjust_tsc_offset ( vcpu , adj , true ) ; } vcpu -> arch . ia32_tsc_adjust_msr = data ; } break ; case MSR_IA32_MISC_ENABLE : vcpu -> arch . ia32_misc_enable_msr = data ; break ; case MSR_KVM_WALL_CLOCK_NEW : case MSR_KVM_WALL_CLOCK : vcpu -> kvm -> arch . wall_clock = data ; kvm_write_wall_clock ( vcpu -> kvm , data ) ; break ; case MSR_KVM_SYSTEM_TIME_NEW : case MSR_KVM_SYSTEM_TIME : { kvmclock_reset ( vcpu ) ; vcpu -> arch . time = data ; kvm_make_request ( KVM_REQ_CLOCK_UPDATE , vcpu ) ; if ( ! ( data & 1 ) ) break ; <S2SV_StartBug> vcpu -> arch . time_offset = data & ~ ( PAGE_MASK | 1 ) ; <S2SV_EndBug> vcpu -> arch . time_page = gfn_to_page ( vcpu -> kvm , data >> PAGE_SHIFT ) ; if ( is_error_page ( vcpu -> arch . time_page ) ) vcpu -> arch . time_page = NULL ; break ; } case MSR_KVM_ASYNC_PF_EN : if ( kvm_pv_enable_async_pf ( vcpu , data ) ) return 1 ; break ; case MSR_KVM_STEAL_TIME : if ( unlikely ( ! sched_info_on ( ) ) ) return 1 ; if ( data & KVM_STEAL_RESERVED_MASK ) return 1 ; if ( kvm_gfn_to_hva_cache_init ( vcpu -> kvm , & vcpu -> arch . st . stime , data & KVM_STEAL_VALID_BITS ) ) return 1 ; vcpu -> arch . st . msr_val = data ; if ( ! ( data & KVM_MSR_ENABLED ) ) break ; vcpu -> arch . st . last_steal = current -> sched_info . run_delay ; preempt_disable ( ) ; accumulate_steal_time ( vcpu ) ; preempt_enable ( ) ; kvm_make_request ( KVM_REQ_STEAL_UPDATE , vcpu ) ; break ; case MSR_KVM_PV_EOI_EN : if ( kvm_lapic_enable_pv_eoi ( vcpu , data ) ) return 1 ; break ; case MSR_IA32_MCG_CTL : case MSR_IA32_MCG_STATUS : case MSR_IA32_MC0_CTL ... MSR_IA32_MC0_CTL + 4 * KVM_MAX_MCE_BANKS - 1 : return set_msr_mce ( vcpu , msr , data ) ; case MSR_K7_EVNTSEL0 : case MSR_K7_EVNTSEL1 : case MSR_K7_EVNTSEL2 : case MSR_K7_EVNTSEL3 : if ( data != 0 ) vcpu_unimpl ( vcpu , "unimplemented<S2SV_blank>perfctr<S2SV_blank>wrmsr:<S2SV_blank>" "0x%x<S2SV_blank>data<S2SV_blank>0x%llx\\n" , msr , data ) ; break ; case MSR_K7_PERFCTR0 : case MSR_K7_PERFCTR1 : case MSR_K7_PERFCTR2 : case MSR_K7_PERFCTR3 : vcpu_unimpl ( vcpu , "unimplemented<S2SV_blank>perfctr<S2SV_blank>wrmsr:<S2SV_blank>" "0x%x<S2SV_blank>data<S2SV_blank>0x%llx\\n" , msr , data ) ; break ; case MSR_P6_PERFCTR0 : case MSR_P6_PERFCTR1 : pr = true ; case MSR_P6_EVNTSEL0 : case MSR_P6_EVNTSEL1 : if ( kvm_pmu_msr ( vcpu , msr ) ) return kvm_pmu_set_msr ( vcpu , msr , data ) ; if ( pr || data != 0 ) vcpu_unimpl ( vcpu , "disabled<S2SV_blank>perfctr<S2SV_blank>wrmsr:<S2SV_blank>" "0x%x<S2SV_blank>data<S2SV_blank>0x%llx\\n" , msr , data ) ; break ; case MSR_K7_CLK_CTL : break ; case HV_X64_MSR_GUEST_OS_ID ... HV_X64_MSR_SINT15 : if ( kvm_hv_msr_partition_wide ( msr ) ) { int r ; mutex_lock ( & vcpu -> kvm -> lock ) ; r = set_msr_hyperv_pw ( vcpu , msr , data ) ; mutex_unlock ( & vcpu -> kvm -> lock ) ; return r ; } else return set_msr_hyperv ( vcpu , msr , data ) ; break ; case MSR_IA32_BBL_CR_CTL3 : vcpu_unimpl ( vcpu , "ignored<S2SV_blank>wrmsr:<S2SV_blank>0x%x<S2SV_blank>data<S2SV_blank>%llx\\n" , msr , data ) ; break ; case MSR_AMD64_OSVW_ID_LENGTH : if ( ! guest_cpuid_has_osvw ( vcpu ) ) return 1 ; vcpu -> arch . osvw . length = data ; break ; case MSR_AMD64_OSVW_STATUS : if ( ! guest_cpuid_has_osvw ( vcpu ) ) return 1 ; vcpu -> arch . osvw . status = data ; break ; default : if ( msr && ( msr == vcpu -> kvm -> arch . xen_hvm_config . msr ) ) return xen_hvm_config ( vcpu , data ) ; if ( kvm_pmu_msr ( vcpu , msr ) ) return kvm_pmu_set_msr ( vcpu , msr , data ) ; if ( ! ignore_msrs ) { vcpu_unimpl ( vcpu , "unhandled<S2SV_blank>wrmsr:<S2SV_blank>0x%x<S2SV_blank>data<S2SV_blank>%llx\\n" , msr , data ) ; return 1 ; } else { vcpu_unimpl ( vcpu , "ignored<S2SV_blank>wrmsr:<S2SV_blank>0x%x<S2SV_blank>data<S2SV_blank>%llx\\n" , msr , data ) ; break ; } } return 0 ; }
static int serdes_probe ( struct platform_device * pdev ) { struct phy_provider * provider ; struct serdes_ctrl * ctrl ; unsigned int i ; int ret ; ctrl = devm_kzalloc ( & pdev -> dev , sizeof ( * ctrl ) , GFP_KERNEL ) ; if ( ! ctrl ) return - ENOMEM ; ctrl -> dev = & pdev -> dev ; ctrl -> regs = syscon_node_to_regmap ( pdev -> dev . parent -> of_node ) ; if ( IS_ERR ( ctrl -> regs ) ) return PTR_ERR ( ctrl -> regs ) ; <S2SV_StartBug> for ( i = 0 ; i <= SERDES_MAX ; i ++ ) { <S2SV_EndBug> ret = serdes_phy_create ( ctrl , i , & ctrl -> phys [ i ] ) ; if ( ret ) return ret ; } dev_set_drvdata ( & pdev -> dev , ctrl ) ; provider = devm_of_phy_provider_register ( ctrl -> dev , serdes_simple_xlate ) ; return PTR_ERR_OR_ZERO ( provider ) ; }
bool_t xdr_krb5_principal ( XDR * xdrs , krb5_principal * objp ) { int ret ; char * p = NULL ; krb5_principal pr = NULL ; static krb5_context context = NULL ; if ( ! context && kadm5_init_krb5_context ( & context ) ) return ( FALSE ) ; switch ( xdrs -> x_op ) { case XDR_ENCODE : if ( * objp ) { if ( ( ret = krb5_unparse_name ( context , * objp , & p ) ) != 0 ) return FALSE ; } if ( ! xdr_nullstring ( xdrs , & p ) ) return FALSE ; if ( p ) free ( p ) ; break ; case XDR_DECODE : if ( ! xdr_nullstring ( xdrs , & p ) ) return FALSE ; if ( p ) { ret = krb5_parse_name ( context , p , & pr ) ; if ( ret != 0 ) return FALSE ; * objp = pr ; free ( p ) ; } else * objp = NULL ; break ; case XDR_FREE : if ( * objp != NULL ) krb5_free_principal ( context , * objp ) ; <S2SV_StartBug> break ; <S2SV_EndBug> } return TRUE ; }
static void icmp6_send ( struct sk_buff * skb , u8 type , u8 code , __u32 info , const struct in6_addr * force_saddr ) { struct net * net = dev_net ( skb -> dev ) ; struct inet6_dev * idev = NULL ; struct ipv6hdr * hdr = ipv6_hdr ( skb ) ; struct sock * sk ; struct ipv6_pinfo * np ; const struct in6_addr * saddr = NULL ; struct dst_entry * dst ; struct icmp6hdr tmp_hdr ; struct flowi6 fl6 ; struct icmpv6_msg msg ; struct sockcm_cookie sockc_unused = { 0 } ; struct ipcm6_cookie ipc6 ; int iif = 0 ; int addr_type = 0 ; int len ; int err = 0 ; u32 mark = IP6_REPLY_MARK ( net , skb -> mark ) ; if ( ( u8 * ) hdr < skb -> head || ( skb_network_header ( skb ) + sizeof ( * hdr ) ) > skb_tail_pointer ( skb ) ) return ; addr_type = ipv6_addr_type ( & hdr -> daddr ) ; if ( ipv6_chk_addr ( net , & hdr -> daddr , skb -> dev , 0 ) || ipv6_chk_acast_addr_src ( net , skb -> dev , & hdr -> daddr ) ) saddr = & hdr -> daddr ; if ( addr_type & IPV6_ADDR_MULTICAST || skb -> pkt_type != PACKET_HOST ) { if ( type != ICMPV6_PKT_TOOBIG && ! ( type == ICMPV6_PARAMPROB && code == ICMPV6_UNK_OPTION && ( opt_unrec ( skb , info ) ) ) ) return ; saddr = NULL ; } addr_type = ipv6_addr_type ( & hdr -> saddr ) ; if ( __ipv6_addr_needs_scope_id ( addr_type ) ) iif = skb -> dev -> ifindex ; <S2SV_StartBug> else <S2SV_EndBug> <S2SV_StartBug> iif = l3mdev_master_ifindex ( skb_dst ( skb ) -> dev ) ; <S2SV_EndBug> if ( ( addr_type == IPV6_ADDR_ANY ) || ( addr_type & IPV6_ADDR_MULTICAST ) ) { net_dbg_ratelimited ( "icmp6_send:<S2SV_blank>addr_any/mcast<S2SV_blank>source<S2SV_blank>[%pI6c<S2SV_blank>><S2SV_blank>%pI6c]\\n" , & hdr -> saddr , & hdr -> daddr ) ; return ; } if ( is_ineligible ( skb ) ) { net_dbg_ratelimited ( "icmp6_send:<S2SV_blank>no<S2SV_blank>reply<S2SV_blank>to<S2SV_blank>icmp<S2SV_blank>error<S2SV_blank>[%pI6c<S2SV_blank>><S2SV_blank>%pI6c]\\n" , & hdr -> saddr , & hdr -> daddr ) ; return ; } mip6_addr_swap ( skb ) ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_proto = IPPROTO_ICMPV6 ; fl6 . daddr = hdr -> saddr ; if ( force_saddr ) saddr = force_saddr ; if ( saddr ) fl6 . saddr = * saddr ; fl6 . flowi6_mark = mark ; fl6 . flowi6_oif = iif ; fl6 . fl6_icmp_type = type ; fl6 . fl6_icmp_code = code ; security_skb_classify_flow ( skb , flowi6_to_flowi ( & fl6 ) ) ; sk = icmpv6_xmit_lock ( net ) ; if ( ! sk ) return ; sk -> sk_mark = mark ; np = inet6_sk ( sk ) ; if ( ! icmpv6_xrlim_allow ( sk , type , & fl6 ) ) goto out ; tmp_hdr . icmp6_type = type ; tmp_hdr . icmp6_code = code ; tmp_hdr . icmp6_cksum = 0 ; tmp_hdr . icmp6_pointer = htonl ( info ) ; if ( ! fl6 . flowi6_oif && ipv6_addr_is_multicast ( & fl6 . daddr ) ) fl6 . flowi6_oif = np -> mcast_oif ; else if ( ! fl6 . flowi6_oif ) fl6 . flowi6_oif = np -> ucast_oif ; ipc6 . tclass = np -> tclass ; fl6 . flowlabel = ip6_make_flowinfo ( ipc6 . tclass , fl6 . flowlabel ) ; dst = icmpv6_route_lookup ( net , skb , sk , & fl6 ) ; if ( IS_ERR ( dst ) ) goto out ; ipc6 . hlimit = ip6_sk_dst_hoplimit ( np , & fl6 , dst ) ; ipc6 . dontfrag = np -> dontfrag ; ipc6 . opt = NULL ; msg . skb = skb ; msg . offset = skb_network_offset ( skb ) ; msg . type = type ; len = skb -> len - msg . offset ; len = min_t ( unsigned int , len , IPV6_MIN_MTU - sizeof ( struct ipv6hdr ) - sizeof ( struct icmp6hdr ) ) ; if ( len < 0 ) { net_dbg_ratelimited ( "icmp:<S2SV_blank>len<S2SV_blank>problem<S2SV_blank>[%pI6c<S2SV_blank>><S2SV_blank>%pI6c]\\n" , & hdr -> saddr , & hdr -> daddr ) ; goto out_dst_release ; } rcu_read_lock ( ) ; idev = __in6_dev_get ( skb -> dev ) ; err = ip6_append_data ( sk , icmpv6_getfrag , & msg , len + sizeof ( struct icmp6hdr ) , sizeof ( struct icmp6hdr ) , & ipc6 , & fl6 , ( struct rt6_info * ) dst , MSG_DONTWAIT , & sockc_unused ) ; if ( err ) { ICMP6_INC_STATS ( net , idev , ICMP6_MIB_OUTERRORS ) ; ip6_flush_pending_frames ( sk ) ; } else { err = icmpv6_push_pending_frames ( sk , & fl6 , & tmp_hdr , len + sizeof ( struct icmp6hdr ) ) ; } rcu_read_unlock ( ) ; out_dst_release : dst_release ( dst ) ; out : icmpv6_xmit_unlock ( sk ) ; }
static int mount_entry ( const char * fsname , const char * target , const char * fstype , unsigned long mountflags , <S2SV_StartBug> const char * data , int optional ) <S2SV_EndBug> { # ifdef HAVE_STATVFS struct statvfs sb ; # endif <S2SV_StartBug> if ( mount ( fsname , target , fstype , mountflags & ~ MS_REMOUNT , data ) ) { <S2SV_EndBug> if ( optional ) { INFO ( "failed<S2SV_blank>to<S2SV_blank>mount<S2SV_blank>\'%s\'<S2SV_blank>on<S2SV_blank>\'%s\'<S2SV_blank>(optional):<S2SV_blank>%s" , fsname , target , strerror ( errno ) ) ; return 0 ; } else { SYSERROR ( "failed<S2SV_blank>to<S2SV_blank>mount<S2SV_blank>\'%s\'<S2SV_blank>on<S2SV_blank>\'%s\'" , fsname , target ) ; return - 1 ; } } if ( ( mountflags & MS_REMOUNT ) || ( mountflags & MS_BIND ) ) { DEBUG ( "remounting<S2SV_blank>%s<S2SV_blank>on<S2SV_blank>%s<S2SV_blank>to<S2SV_blank>respect<S2SV_blank>bind<S2SV_blank>or<S2SV_blank>remount<S2SV_blank>options" , fsname ? fsname : "(none)" , target ? target : "(none)" ) ; unsigned long rqd_flags = 0 ; if ( mountflags & MS_RDONLY ) rqd_flags |= MS_RDONLY ; # ifdef HAVE_STATVFS if ( statvfs ( fsname , & sb ) == 0 ) { unsigned long required_flags = rqd_flags ; if ( sb . f_flag & MS_NOSUID ) required_flags |= MS_NOSUID ; if ( sb . f_flag & MS_NODEV ) required_flags |= MS_NODEV ; if ( sb . f_flag & MS_RDONLY ) required_flags |= MS_RDONLY ; if ( sb . f_flag & MS_NOEXEC ) required_flags |= MS_NOEXEC ; DEBUG ( "(at<S2SV_blank>remount)<S2SV_blank>flags<S2SV_blank>for<S2SV_blank>%s<S2SV_blank>was<S2SV_blank>%lu,<S2SV_blank>required<S2SV_blank>extra<S2SV_blank>flags<S2SV_blank>are<S2SV_blank>%lu" , fsname , sb . f_flag , required_flags ) ; if ( ! ( mountflags & MS_REMOUNT ) ) { if ( ! ( required_flags & ~ mountflags ) && rqd_flags == 0 ) { DEBUG ( "mountflags<S2SV_blank>already<S2SV_blank>was<S2SV_blank>%lu,<S2SV_blank>skipping<S2SV_blank>remount" , mountflags ) ; goto skipremount ; } } mountflags |= required_flags ; } # endif if ( mount ( fsname , target , fstype , <S2SV_StartBug> mountflags | MS_REMOUNT , data ) ) { <S2SV_EndBug> if ( optional ) { INFO ( "failed<S2SV_blank>to<S2SV_blank>mount<S2SV_blank>\'%s\'<S2SV_blank>on<S2SV_blank>\'%s\'<S2SV_blank>(optional):<S2SV_blank>%s" , fsname , target , strerror ( errno ) ) ; return 0 ; } else { SYSERROR ( "failed<S2SV_blank>to<S2SV_blank>mount<S2SV_blank>\'%s\'<S2SV_blank>on<S2SV_blank>\'%s\'" , fsname , target ) ; return - 1 ; } } } # ifdef HAVE_STATVFS skipremount : # endif DEBUG ( "mounted<S2SV_blank>\'%s\'<S2SV_blank>on<S2SV_blank>\'%s\',<S2SV_blank>type<S2SV_blank>\'%s\'" , fsname , target , fstype ) ; return 0 ; }
static int simulate_llsc ( struct pt_regs * regs , unsigned int opcode ) { if ( ( opcode & OPCODE ) == LL ) { perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , <S2SV_StartBug> 1 , 0 , regs , 0 ) ; <S2SV_EndBug> return simulate_ll ( regs , opcode ) ; } if ( ( opcode & OPCODE ) == SC ) { perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , <S2SV_StartBug> 1 , 0 , regs , 0 ) ; <S2SV_EndBug> return simulate_sc ( regs , opcode ) ; } return - 1 ; }
int main ( int argc , char * * argv ) { mode_t old_umask ; <S2SV_StartBug> cleanup_free char * base_path = NULL ; <S2SV_EndBug> int clone_flags ; char * old_cwd = NULL ; pid_t pid ; int event_fd = - 1 ; int child_wait_fd = - 1 ; int setup_finished_pipe [ ] = { - 1 , - 1 } ; const char * new_cwd ; uid_t ns_uid ; gid_t ns_gid ; struct stat sbuf ; uint64_t val ; int res UNUSED ; cleanup_free char * seccomp_data = NULL ; size_t seccomp_len ; struct sock_fprog seccomp_prog ; cleanup_free char * args_data = NULL ; if ( argc == 2 && ( strcmp ( argv [ 1 ] , "--version" ) == 0 ) ) print_version_and_exit ( ) ; real_uid = getuid ( ) ; real_gid = getgid ( ) ; acquire_privs ( ) ; if ( prctl ( PR_SET_NO_NEW_PRIVS , 1 , 0 , 0 , 0 ) < 0 ) die_with_error ( "prctl(PR_SET_NO_NEW_CAPS)<S2SV_blank>failed" ) ; read_overflowids ( ) ; argv0 = argv [ 0 ] ; if ( isatty ( 1 ) ) host_tty_dev = ttyname ( 1 ) ; argv ++ ; argc -- ; if ( argc == 0 ) usage ( EXIT_FAILURE , stderr ) ; parse_args ( & argc , ( const char * * * ) & argv ) ; args_data = opt_args_data ; opt_args_data = NULL ; if ( ( requested_caps [ 0 ] || requested_caps [ 1 ] ) && is_privileged ) die ( "--cap-add<S2SV_blank>in<S2SV_blank>setuid<S2SV_blank>mode<S2SV_blank>can<S2SV_blank>be<S2SV_blank>used<S2SV_blank>only<S2SV_blank>by<S2SV_blank>root" ) ; if ( opt_userns_block_fd != - 1 && ! opt_unshare_user ) die ( "--userns-block-fd<S2SV_blank>requires<S2SV_blank>--unshare-user" ) ; if ( opt_userns_block_fd != - 1 && opt_info_fd == - 1 ) die ( "--userns-block-fd<S2SV_blank>requires<S2SV_blank>--info-fd" ) ; if ( ! is_privileged && getuid ( ) != 0 ) opt_unshare_user = TRUE ; # ifdef ENABLE_REQUIRE_USERNS if ( is_privileged && getuid ( ) != 0 ) opt_unshare_user = TRUE ; # endif if ( opt_unshare_user_try && stat ( "/proc/self/ns/user" , & sbuf ) == 0 ) { bool disabled = FALSE ; if ( stat ( "/sys/module/user_namespace/parameters/enable" , & sbuf ) == 0 ) { cleanup_free char * enable = NULL ; enable = load_file_at ( AT_FDCWD , "/sys/module/user_namespace/parameters/enable" ) ; if ( enable != NULL && enable [ 0 ] == 'N' ) disabled = TRUE ; } if ( stat ( "/proc/sys/user/max_user_namespaces" , & sbuf ) == 0 ) { cleanup_free char * max_user_ns = NULL ; max_user_ns = load_file_at ( AT_FDCWD , "/proc/sys/user/max_user_namespaces" ) ; if ( max_user_ns != NULL && strcmp ( max_user_ns , "0\\n" ) == 0 ) disabled = TRUE ; } if ( ! disabled ) opt_unshare_user = TRUE ; } if ( argc == 0 ) usage ( EXIT_FAILURE , stderr ) ; __debug__ ( ( "Creating<S2SV_blank>root<S2SV_blank>mount<S2SV_blank>point\\n" ) ) ; if ( opt_sandbox_uid == - 1 ) opt_sandbox_uid = real_uid ; if ( opt_sandbox_gid == - 1 ) opt_sandbox_gid = real_gid ; if ( ! opt_unshare_user && opt_sandbox_uid != real_uid ) die ( "Specifying<S2SV_blank>--uid<S2SV_blank>requires<S2SV_blank>--unshare-user" ) ; if ( ! opt_unshare_user && opt_sandbox_gid != real_gid ) die ( "Specifying<S2SV_blank>--gid<S2SV_blank>requires<S2SV_blank>--unshare-user" ) ; if ( ! opt_unshare_uts && opt_sandbox_hostname != NULL ) die ( "Specifying<S2SV_blank>--hostname<S2SV_blank>requires<S2SV_blank>--unshare-uts" ) ; if ( opt_as_pid_1 && ! opt_unshare_pid ) die ( "Specifying<S2SV_blank>--as-pid-1<S2SV_blank>requires<S2SV_blank>--unshare-pid" ) ; if ( opt_as_pid_1 && lock_files != NULL ) die ( "Specifying<S2SV_blank>--as-pid-1<S2SV_blank>and<S2SV_blank>--lock-file<S2SV_blank>is<S2SV_blank>not<S2SV_blank>permitted" ) ; proc_fd = open ( "/proc" , O_PATH ) ; if ( proc_fd == - 1 ) die_with_error ( "Can\'t<S2SV_blank>open<S2SV_blank>/proc" ) ; <S2SV_StartBug> base_path = xasprintf ( "/run/user/%d/.bubblewrap" , real_uid ) ; <S2SV_EndBug> if ( ensure_dir ( base_path , 0755 ) ) { free ( base_path ) ; base_path = xasprintf ( "/tmp/.bubblewrap-%d" , real_uid ) ; if ( ensure_dir ( base_path , 0755 ) ) die_with_error ( "Creating<S2SV_blank>root<S2SV_blank>mountpoint<S2SV_blank>failed" ) ; } __debug__ ( ( "creating<S2SV_blank>new<S2SV_blank>namespace\\n" ) ) ; if ( opt_unshare_pid && ! opt_as_pid_1 ) { event_fd = eventfd ( 0 , EFD_CLOEXEC | EFD_NONBLOCK ) ; if ( event_fd == - 1 ) die_with_error ( "eventfd()" ) ; } block_sigchild ( ) ; clone_flags = SIGCHLD | CLONE_NEWNS ; if ( opt_unshare_user ) clone_flags |= CLONE_NEWUSER ; if ( opt_unshare_pid ) clone_flags |= CLONE_NEWPID ; if ( opt_unshare_net ) clone_flags |= CLONE_NEWNET ; if ( opt_unshare_ipc ) clone_flags |= CLONE_NEWIPC ; if ( opt_unshare_uts ) clone_flags |= CLONE_NEWUTS ; if ( opt_unshare_cgroup ) { if ( stat ( "/proc/self/ns/cgroup" , & sbuf ) ) { if ( errno == ENOENT ) die ( "Cannot<S2SV_blank>create<S2SV_blank>new<S2SV_blank>cgroup<S2SV_blank>namespace<S2SV_blank>because<S2SV_blank>the<S2SV_blank>kernel<S2SV_blank>does<S2SV_blank>not<S2SV_blank>support<S2SV_blank>it" ) ; else die_with_error ( "stat<S2SV_blank>on<S2SV_blank>/proc/self/ns/cgroup<S2SV_blank>failed" ) ; } clone_flags |= CLONE_NEWCGROUP ; } if ( opt_unshare_cgroup_try ) if ( ! stat ( "/proc/self/ns/cgroup" , & sbuf ) ) clone_flags |= CLONE_NEWCGROUP ; child_wait_fd = eventfd ( 0 , EFD_CLOEXEC ) ; if ( child_wait_fd == - 1 ) die_with_error ( "eventfd()" ) ; if ( opt_json_status_fd != - 1 ) { int ret ; ret = pipe2 ( setup_finished_pipe , O_CLOEXEC ) ; if ( ret == - 1 ) die_with_error ( "pipe2()" ) ; } pid = raw_clone ( clone_flags , NULL ) ; if ( pid == - 1 ) { if ( opt_unshare_user ) { if ( errno == EINVAL ) die ( "Creating<S2SV_blank>new<S2SV_blank>namespace<S2SV_blank>failed,<S2SV_blank>likely<S2SV_blank>because<S2SV_blank>the<S2SV_blank>kernel<S2SV_blank>does<S2SV_blank>not<S2SV_blank>support<S2SV_blank>user<S2SV_blank>namespaces.<S2SV_blank><S2SV_blank>bwrap<S2SV_blank>must<S2SV_blank>be<S2SV_blank>installed<S2SV_blank>setuid<S2SV_blank>on<S2SV_blank>such<S2SV_blank>systems." ) ; else if ( errno == EPERM && ! is_privileged ) die ( "No<S2SV_blank>permissions<S2SV_blank>to<S2SV_blank>creating<S2SV_blank>new<S2SV_blank>namespace,<S2SV_blank>likely<S2SV_blank>because<S2SV_blank>the<S2SV_blank>kernel<S2SV_blank>does<S2SV_blank>not<S2SV_blank>allow<S2SV_blank>non-privileged<S2SV_blank>user<S2SV_blank>namespaces.<S2SV_blank>On<S2SV_blank>e.g.<S2SV_blank>debian<S2SV_blank>this<S2SV_blank>can<S2SV_blank>be<S2SV_blank>enabled<S2SV_blank>with<S2SV_blank>\'sysctl<S2SV_blank>kernel.unprivileged_userns_clone=1\'." ) ; } die_with_error ( "Creating<S2SV_blank>new<S2SV_blank>namespace<S2SV_blank>failed" ) ; } ns_uid = opt_sandbox_uid ; ns_gid = opt_sandbox_gid ; if ( pid != 0 ) { if ( is_privileged && opt_unshare_user && opt_userns_block_fd == - 1 ) { write_uid_gid_map ( ns_uid , real_uid , ns_gid , real_gid , pid , TRUE , opt_needs_devpts ) ; } drop_privs ( FALSE ) ; handle_die_with_parent ( ) ; if ( opt_info_fd != - 1 ) { cleanup_free char * output = xasprintf ( "{\\n<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>\\"child-pid\\":<S2SV_blank>%i\\n}\\n" , pid ) ; dump_info ( opt_info_fd , output , TRUE ) ; close ( opt_info_fd ) ; } if ( opt_json_status_fd != - 1 ) { cleanup_free char * output = xasprintf ( "{<S2SV_blank>\\"child-pid\\":<S2SV_blank>%i<S2SV_blank>}\\n" , pid ) ; dump_info ( opt_json_status_fd , output , TRUE ) ; } if ( opt_userns_block_fd != - 1 ) { char b [ 1 ] ; ( void ) TEMP_FAILURE_RETRY ( read ( opt_userns_block_fd , b , 1 ) ) ; close ( opt_userns_block_fd ) ; } val = 1 ; res = write ( child_wait_fd , & val , 8 ) ; close ( child_wait_fd ) ; return monitor_child ( event_fd , pid , setup_finished_pipe [ 0 ] ) ; } if ( opt_info_fd != - 1 ) close ( opt_info_fd ) ; if ( opt_json_status_fd != - 1 ) close ( opt_json_status_fd ) ; res = read ( child_wait_fd , & val , 8 ) ; close ( child_wait_fd ) ; switch_to_user_with_privs ( ) ; if ( opt_unshare_net ) loopback_setup ( ) ; ns_uid = opt_sandbox_uid ; ns_gid = opt_sandbox_gid ; if ( ! is_privileged && opt_unshare_user && opt_userns_block_fd == - 1 ) { if ( opt_needs_devpts ) { ns_uid = 0 ; ns_gid = 0 ; } write_uid_gid_map ( ns_uid , real_uid , ns_gid , real_gid , - 1 , TRUE , FALSE ) ; } old_umask = umask ( 0 ) ; resolve_symlinks_in_ops ( ) ; if ( mount ( NULL , "/" , NULL , MS_SLAVE | MS_REC , NULL ) < 0 ) die_with_error ( "Failed<S2SV_blank>to<S2SV_blank>make<S2SV_blank>/<S2SV_blank>slave" ) ; if ( mount ( "tmpfs" , base_path , "tmpfs" , MS_NODEV | MS_NOSUID , NULL ) != 0 ) die_with_error ( "Failed<S2SV_blank>to<S2SV_blank>mount<S2SV_blank>tmpfs" ) ; old_cwd = get_current_dir_name ( ) ; if ( chdir ( base_path ) != 0 ) die_with_error ( "chdir<S2SV_blank>base_path" ) ; if ( mkdir ( "newroot" , 0755 ) ) die_with_error ( "Creating<S2SV_blank>newroot<S2SV_blank>failed" ) ; if ( mount ( "newroot" , "newroot" , NULL , MS_MGC_VAL | MS_BIND | MS_REC , NULL ) < 0 ) die_with_error ( "setting<S2SV_blank>up<S2SV_blank>newroot<S2SV_blank>bind" ) ; if ( mkdir ( "oldroot" , 0755 ) ) die_with_error ( "Creating<S2SV_blank>oldroot<S2SV_blank>failed" ) ; if ( pivot_root ( base_path , "oldroot" ) ) die_with_error ( "pivot_root" ) ; if ( chdir ( "/" ) != 0 ) die_with_error ( "chdir<S2SV_blank>/<S2SV_blank>(base<S2SV_blank>path)" ) ; if ( is_privileged ) { pid_t child ; int privsep_sockets [ 2 ] ; if ( socketpair ( AF_UNIX , SOCK_SEQPACKET | SOCK_CLOEXEC , 0 , privsep_sockets ) != 0 ) die_with_error ( "Can\'t<S2SV_blank>create<S2SV_blank>privsep<S2SV_blank>socket" ) ; child = fork ( ) ; if ( child == - 1 ) die_with_error ( "Can\'t<S2SV_blank>fork<S2SV_blank>unprivileged<S2SV_blank>helper" ) ; if ( child == 0 ) { drop_privs ( FALSE ) ; close ( privsep_sockets [ 0 ] ) ; setup_newroot ( opt_unshare_pid , privsep_sockets [ 1 ] ) ; exit ( 0 ) ; } else { int status ; uint32_t buffer [ 2048 ] ; uint32_t op , flags ; const char * arg1 , * arg2 ; cleanup_fd int unpriv_socket = - 1 ; unpriv_socket = privsep_sockets [ 0 ] ; close ( privsep_sockets [ 1 ] ) ; do { op = read_priv_sec_op ( unpriv_socket , buffer , sizeof ( buffer ) , & flags , & arg1 , & arg2 ) ; privileged_op ( - 1 , op , flags , arg1 , arg2 ) ; if ( write ( unpriv_socket , buffer , 1 ) != 1 ) die ( "Can\'t<S2SV_blank>write<S2SV_blank>to<S2SV_blank>op_socket" ) ; } while ( op != PRIV_SEP_OP_DONE ) ; waitpid ( child , & status , 0 ) ; } } else { setup_newroot ( opt_unshare_pid , - 1 ) ; } close_ops_fd ( ) ; if ( mount ( "oldroot" , "oldroot" , NULL , MS_REC | MS_PRIVATE , NULL ) != 0 ) die_with_error ( "Failed<S2SV_blank>to<S2SV_blank>make<S2SV_blank>old<S2SV_blank>root<S2SV_blank>rprivate" ) ; if ( umount2 ( "oldroot" , MNT_DETACH ) ) die_with_error ( "unmount<S2SV_blank>old<S2SV_blank>root" ) ; { cleanup_fd int oldrootfd = open ( "/" , O_DIRECTORY | O_RDONLY ) ; if ( oldrootfd < 0 ) die_with_error ( "can\'t<S2SV_blank>open<S2SV_blank>/" ) ; if ( chdir ( "/newroot" ) != 0 ) die_with_error ( "chdir<S2SV_blank>/newroot" ) ; if ( pivot_root ( "." , "." ) != 0 ) die_with_error ( "pivot_root(/newroot)" ) ; if ( fchdir ( oldrootfd ) < 0 ) die_with_error ( "fchdir<S2SV_blank>to<S2SV_blank>oldroot" ) ; if ( umount2 ( "." , MNT_DETACH ) < 0 ) die_with_error ( "umount<S2SV_blank>old<S2SV_blank>root" ) ; if ( chdir ( "/" ) != 0 ) die_with_error ( "chdir<S2SV_blank>/" ) ; } if ( opt_unshare_user && ( ns_uid != opt_sandbox_uid || ns_gid != opt_sandbox_gid ) && opt_userns_block_fd == - 1 ) { if ( unshare ( CLONE_NEWUSER ) ) die_with_error ( "unshare<S2SV_blank>user<S2SV_blank>ns" ) ; write_uid_gid_map ( opt_sandbox_uid , ns_uid , opt_sandbox_gid , ns_gid , - 1 , FALSE , FALSE ) ; } drop_privs ( ! is_privileged ) ; if ( opt_block_fd != - 1 ) { char b [ 1 ] ; ( void ) TEMP_FAILURE_RETRY ( read ( opt_block_fd , b , 1 ) ) ; close ( opt_block_fd ) ; } if ( opt_seccomp_fd != - 1 ) { seccomp_data = load_file_data ( opt_seccomp_fd , & seccomp_len ) ; if ( seccomp_data == NULL ) die_with_error ( "Can\'t<S2SV_blank>read<S2SV_blank>seccomp<S2SV_blank>data" ) ; if ( seccomp_len % 8 != 0 ) die ( "Invalid<S2SV_blank>seccomp<S2SV_blank>data,<S2SV_blank>must<S2SV_blank>be<S2SV_blank>multiple<S2SV_blank>of<S2SV_blank>8" ) ; seccomp_prog . len = seccomp_len / 8 ; seccomp_prog . filter = ( struct sock_filter * ) seccomp_data ; close ( opt_seccomp_fd ) ; } umask ( old_umask ) ; new_cwd = "/" ; if ( opt_chdir_path ) { if ( chdir ( opt_chdir_path ) ) die_with_error ( "Can\'t<S2SV_blank>chdir<S2SV_blank>to<S2SV_blank>%s" , opt_chdir_path ) ; new_cwd = opt_chdir_path ; } else if ( chdir ( old_cwd ) == 0 ) { new_cwd = old_cwd ; } else { const char * home = getenv ( "HOME" ) ; if ( home != NULL && chdir ( home ) == 0 ) new_cwd = home ; } xsetenv ( "PWD" , new_cwd , 1 ) ; free ( old_cwd ) ; if ( opt_new_session && setsid ( ) == ( pid_t ) - 1 ) die_with_error ( "setsid" ) ; if ( label_exec ( opt_exec_label ) == - 1 ) die_with_error ( "label_exec<S2SV_blank>%s" , argv [ 0 ] ) ; __debug__ ( ( "forking<S2SV_blank>for<S2SV_blank>child\\n" ) ) ; if ( ! opt_as_pid_1 && ( opt_unshare_pid || lock_files != NULL || opt_sync_fd != - 1 ) ) { pid = fork ( ) ; if ( pid == - 1 ) die_with_error ( "Can\'t<S2SV_blank>fork<S2SV_blank>for<S2SV_blank>pid<S2SV_blank>1" ) ; if ( pid != 0 ) { drop_all_caps ( FALSE ) ; { int dont_close [ 3 ] ; int j = 0 ; if ( event_fd != - 1 ) dont_close [ j ++ ] = event_fd ; if ( opt_sync_fd != - 1 ) dont_close [ j ++ ] = opt_sync_fd ; dont_close [ j ++ ] = - 1 ; fdwalk ( proc_fd , close_extra_fds , dont_close ) ; } return do_init ( event_fd , pid , seccomp_data != NULL ? & seccomp_prog : NULL ) ; } } __debug__ ( ( "launch<S2SV_blank>executable<S2SV_blank>%s\\n" , argv [ 0 ] ) ) ; if ( proc_fd != - 1 ) close ( proc_fd ) ; if ( ! opt_as_pid_1 ) { if ( opt_sync_fd != - 1 ) close ( opt_sync_fd ) ; } unblock_sigchild ( ) ; handle_die_with_parent ( ) ; if ( ! is_privileged ) set_ambient_capabilities ( ) ; if ( seccomp_data != NULL && prctl ( PR_SET_SECCOMP , SECCOMP_MODE_FILTER , & seccomp_prog ) != 0 ) die_with_error ( "prctl(PR_SET_SECCOMP)" ) ; if ( setup_finished_pipe [ 1 ] != - 1 ) { char data = 0 ; res = write_to_fd ( setup_finished_pipe [ 1 ] , & data , 1 ) ; } if ( execvp ( argv [ 0 ] , argv ) == - 1 ) { if ( setup_finished_pipe [ 1 ] != - 1 ) { int saved_errno = errno ; char data = 0 ; res = write_to_fd ( setup_finished_pipe [ 1 ] , & data , 1 ) ; errno = saved_errno ; } die_with_error ( "execvp<S2SV_blank>%s" , argv [ 0 ] ) ; } return 0 ; }
<S2SV_StartBug> void vp9_fht4x4_c ( const int16_t * input , int16_t * output , <S2SV_EndBug> int stride , int tx_type ) { if ( tx_type == DCT_DCT ) { <S2SV_StartBug> vp9_fdct4x4_c ( input , output , stride ) ; <S2SV_EndBug> } else { <S2SV_StartBug> int16_t out [ 4 * 4 ] ; <S2SV_EndBug> <S2SV_StartBug> int16_t * outptr = & out [ 0 ] ; <S2SV_EndBug> int i , j ; <S2SV_StartBug> int16_t temp_in [ 4 ] , temp_out [ 4 ] ; <S2SV_EndBug> const transform_2d ht = FHT_4 [ tx_type ] ; for ( i = 0 ; i < 4 ; ++ i ) { for ( j = 0 ; j < 4 ; ++ j ) temp_in [ j ] = input [ j * stride + i ] * 16 ; if ( i == 0 && temp_in [ 0 ] ) temp_in [ 0 ] += 1 ; ht . cols ( temp_in , temp_out ) ; for ( j = 0 ; j < 4 ; ++ j ) <S2SV_StartBug> outptr [ j * 4 + i ] = temp_out [ j ] ; <S2SV_EndBug> } for ( i = 0 ; i < 4 ; ++ i ) { for ( j = 0 ; j < 4 ; ++ j ) temp_in [ j ] = out [ j + i * 4 ] ; ht . rows ( temp_in , temp_out ) ; for ( j = 0 ; j < 4 ; ++ j ) output [ j + i * 4 ] = ( temp_out [ j ] + 1 ) >> 2 ; } } }
<S2SV_StartBug> static const char * parse_array ( cJSON * item , const char * value ) <S2SV_EndBug> { cJSON * child ; if ( * value != '[' ) { <S2SV_StartBug> ep = value ; <S2SV_EndBug> return 0 ; } item -> type = cJSON_Array ; value = skip ( value + 1 ) ; if ( * value == ']' ) <S2SV_StartBug> return value + 1 ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( item -> child = child = cJSON_New_Item ( ) ) ) <S2SV_EndBug> return 0 ; <S2SV_StartBug> if ( ! ( value = skip ( parse_value ( child , skip ( value ) ) ) ) ) <S2SV_EndBug> return 0 ; while ( * value == ',' ) { cJSON * new_item ; if ( ! ( new_item = cJSON_New_Item ( ) ) ) return 0 ; child -> next = new_item ; new_item -> prev = child ; <S2SV_StartBug> child = new_item ; <S2SV_EndBug> <S2SV_StartBug> if ( ! ( value = skip ( parse_value ( child , skip ( value + 1 ) ) ) ) ) <S2SV_EndBug> return 0 ; } if ( * value == ']' ) <S2SV_StartBug> return value + 1 ; <S2SV_EndBug> ep = value ; return 0 ; }
static gboolean parse_cosine_packet ( FILE_T fh , struct wtap_pkthdr * phdr , Buffer * buf , char * line , int * err , gchar * * err_info ) { union wtap_pseudo_header * pseudo_header = & phdr -> pseudo_header ; int num_items_scanned ; <S2SV_StartBug> int yy , mm , dd , hr , min , sec , csec ; <S2SV_EndBug> guint pkt_len ; int pro , off , pri , rm , error ; guint code1 , code2 ; char if_name [ COSINE_MAX_IF_NAME_LEN ] = "" , direction [ 6 ] = "" ; struct tm tm ; guint8 * pd ; int i , hex_lines , n , caplen = 0 ; if ( sscanf ( line , "%4d-%2d-%2d,%2d:%2d:%2d.%9d:" , & yy , & mm , & dd , & hr , & min , & sec , & csec ) == 7 ) { num_items_scanned = sscanf ( line , <S2SV_StartBug> "%4d-%2d-%2d,%2d:%2d:%2d.%9d:<S2SV_blank>%5s<S2SV_blank>(%127[A-Za-z0-9/:]),<S2SV_blank>Length:%9u,<S2SV_blank>Pro:%9d,<S2SV_blank>Off:%9d,<S2SV_blank>Pri:%9d,<S2SV_blank>RM:%9d,<S2SV_blank>Err:%9d<S2SV_blank>[%8x,<S2SV_blank>%8x]" , <S2SV_EndBug> & yy , & mm , & dd , & hr , & min , & sec , & csec , direction , if_name , & pkt_len , & pro , & off , & pri , & rm , & error , & code1 , & code2 ) ; if ( num_items_scanned != 17 ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( "cosine:<S2SV_blank>purported<S2SV_blank>control<S2SV_blank>blade<S2SV_blank>line<S2SV_blank>doesn\'t<S2SV_blank>have<S2SV_blank>code<S2SV_blank>values" ) ; return FALSE ; } } else { num_items_scanned = sscanf ( line , <S2SV_StartBug> "%5s<S2SV_blank>(%127[A-Za-z0-9/:]),<S2SV_blank>Length:%9u,<S2SV_blank>Pro:%9d,<S2SV_blank>Off:%9d,<S2SV_blank>Pri:%9d,<S2SV_blank>RM:%9d,<S2SV_blank>Err:%9d<S2SV_blank>[%8x,<S2SV_blank>%8x]" , <S2SV_EndBug> direction , if_name , & pkt_len , & pro , & off , & pri , & rm , & error , & code1 , & code2 ) ; if ( num_items_scanned != 10 ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( "cosine:<S2SV_blank>header<S2SV_blank>line<S2SV_blank>is<S2SV_blank>neither<S2SV_blank>control<S2SV_blank>blade<S2SV_blank>nor<S2SV_blank>PE<S2SV_blank>output" ) ; return FALSE ; } <S2SV_StartBug> yy = mm = dd = hr = min = sec = csec = 0 ; <S2SV_EndBug> } if ( pkt_len > WTAP_MAX_PACKET_SIZE ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup_printf ( "cosine:<S2SV_blank>File<S2SV_blank>has<S2SV_blank>%u-byte<S2SV_blank>packet,<S2SV_blank>bigger<S2SV_blank>than<S2SV_blank>maximum<S2SV_blank>of<S2SV_blank>%u" , pkt_len , WTAP_MAX_PACKET_SIZE ) ; return FALSE ; } phdr -> rec_type = REC_TYPE_PACKET ; phdr -> presence_flags = WTAP_HAS_TS | WTAP_HAS_CAP_LEN ; tm . tm_year = yy - 1900 ; tm . tm_mon = mm - 1 ; tm . tm_mday = dd ; tm . tm_hour = hr ; tm . tm_min = min ; tm . tm_sec = sec ; tm . tm_isdst = - 1 ; phdr -> ts . secs = mktime ( & tm ) ; phdr -> ts . nsecs = csec * 10000000 ; phdr -> len = pkt_len ; if ( strncmp ( if_name , "TEST:" , 5 ) == 0 ) { pseudo_header -> cosine . encap = COSINE_ENCAP_TEST ; } else if ( strncmp ( if_name , "PPoATM:" , 7 ) == 0 ) { pseudo_header -> cosine . encap = COSINE_ENCAP_PPoATM ; } else if ( strncmp ( if_name , "PPoFR:" , 6 ) == 0 ) { pseudo_header -> cosine . encap = COSINE_ENCAP_PPoFR ; } else if ( strncmp ( if_name , "ATM:" , 4 ) == 0 ) { pseudo_header -> cosine . encap = COSINE_ENCAP_ATM ; } else if ( strncmp ( if_name , "FR:" , 3 ) == 0 ) { pseudo_header -> cosine . encap = COSINE_ENCAP_FR ; } else if ( strncmp ( if_name , "HDLC:" , 5 ) == 0 ) { pseudo_header -> cosine . encap = COSINE_ENCAP_HDLC ; } else if ( strncmp ( if_name , "PPP:" , 4 ) == 0 ) { pseudo_header -> cosine . encap = COSINE_ENCAP_PPP ; } else if ( strncmp ( if_name , "ETH:" , 4 ) == 0 ) { pseudo_header -> cosine . encap = COSINE_ENCAP_ETH ; } else { pseudo_header -> cosine . encap = COSINE_ENCAP_UNKNOWN ; } if ( strncmp ( direction , "l2-tx" , 5 ) == 0 ) { pseudo_header -> cosine . direction = COSINE_DIR_TX ; } else if ( strncmp ( direction , "l2-rx" , 5 ) == 0 ) { pseudo_header -> cosine . direction = COSINE_DIR_RX ; } g_strlcpy ( pseudo_header -> cosine . if_name , if_name , COSINE_MAX_IF_NAME_LEN ) ; pseudo_header -> cosine . pro = pro ; pseudo_header -> cosine . off = off ; pseudo_header -> cosine . pri = pri ; pseudo_header -> cosine . rm = rm ; pseudo_header -> cosine . err = error ; ws_buffer_assure_space ( buf , pkt_len ) ; pd = ws_buffer_start_ptr ( buf ) ; hex_lines = pkt_len / 16 + ( ( pkt_len % 16 ) ? 1 : 0 ) ; for ( i = 0 ; i < hex_lines ; i ++ ) { if ( file_gets ( line , COSINE_LINE_LENGTH , fh ) == NULL ) { * err = file_error ( fh , err_info ) ; if ( * err == 0 ) { * err = WTAP_ERR_SHORT_READ ; } return FALSE ; } if ( empty_line ( line ) ) { break ; } if ( ( n = parse_single_hex_dump_line ( line , pd , i * 16 ) ) == - 1 ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( "cosine:<S2SV_blank>hex<S2SV_blank>dump<S2SV_blank>line<S2SV_blank>doesn\'t<S2SV_blank>have<S2SV_blank>16<S2SV_blank>numbers" ) ; return FALSE ; } caplen += n ; } phdr -> caplen = caplen ; return TRUE ; }
int main ( int argc , char * * argv ) { setlocale ( LC_ALL , "" ) ; # if ENABLE_NLS bindtextdomain ( PACKAGE , LOCALEDIR ) ; textdomain ( PACKAGE ) ; # endif abrt_init ( argv ) ; const char * program_usage_string = _ ( "&<S2SV_blank>[-y]<S2SV_blank>[-i<S2SV_blank>BUILD_IDS_FILE|-i<S2SV_blank>-]<S2SV_blank>[-e<S2SV_blank>PATH[:PATH]...]\\n" "\\t[-r<S2SV_blank>REPO]\\n" "\\n" "Installs<S2SV_blank>debuginfo<S2SV_blank>packages<S2SV_blank>for<S2SV_blank>all<S2SV_blank>build-ids<S2SV_blank>listed<S2SV_blank>in<S2SV_blank>BUILD_IDS_FILE<S2SV_blank>to\\n" "ABRT<S2SV_blank>system<S2SV_blank>cache." ) ; enum { OPT_v = 1 << 0 , OPT_y = 1 << 1 , OPT_i = 1 << 2 , OPT_e = 1 << 3 , OPT_r = 1 << 4 , OPT_s = 1 << 5 , } ; const char * build_ids = "build_ids" ; const char * exact = NULL ; const char * repo = NULL ; const char * size_mb = NULL ; struct options program_options [ ] = { OPT__VERBOSE ( & g_verbose ) , OPT_BOOL ( 'y' , "yes" , NULL , _ ( "Noninteractive,<S2SV_blank>assume<S2SV_blank>\'Yes\'<S2SV_blank>to<S2SV_blank>all<S2SV_blank>questions" ) ) , OPT_STRING ( 'i' , "ids" , & build_ids , "BUILD_IDS_FILE" , _ ( "-<S2SV_blank>means<S2SV_blank>STDIN,<S2SV_blank>default:<S2SV_blank>build_ids" ) ) , OPT_STRING ( 'e' , "exact" , & exact , "EXACT" , _ ( "Download<S2SV_blank>only<S2SV_blank>specified<S2SV_blank>files" ) ) , OPT_STRING ( 'r' , "repo" , & repo , "REPO" , _ ( "Pattern<S2SV_blank>to<S2SV_blank>use<S2SV_blank>when<S2SV_blank>searching<S2SV_blank>for<S2SV_blank>repos,<S2SV_blank>default:<S2SV_blank>*debug*" ) ) , OPT_STRING ( 's' , "size_mb" , & size_mb , "SIZE_MB" , _ ( "Ignored<S2SV_blank>option" ) ) , OPT_END ( ) } ; const unsigned opts = parse_opts ( argc , argv , program_options , program_usage_string ) ; const gid_t egid = getegid ( ) ; const gid_t rgid = getgid ( ) ; const uid_t euid = geteuid ( ) ; const gid_t ruid = getuid ( ) ; char * build_ids_self_fd = NULL ; if ( strcmp ( "-" , build_ids ) != 0 ) { if ( setregid ( egid , rgid ) < 0 ) perror_msg_and_die ( "setregid(egid,<S2SV_blank>rgid)" ) ; if ( setreuid ( euid , ruid ) < 0 ) perror_msg_and_die ( "setreuid(euid,<S2SV_blank>ruid)" ) ; const int build_ids_fd = open ( build_ids , O_RDONLY ) ; if ( setregid ( rgid , egid ) < 0 ) perror_msg_and_die ( "setregid(rgid,<S2SV_blank>egid)" ) ; if ( setreuid ( ruid , euid ) < 0 ) perror_msg_and_die ( "setreuid(ruid,<S2SV_blank>euid)" ) ; if ( build_ids_fd < 0 ) perror_msg_and_die ( "Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>file<S2SV_blank>\'%s\'" , build_ids ) ; build_ids_self_fd = xasprintf ( "/proc/self/fd/%d" , build_ids_fd ) ; } <S2SV_StartBug> const char * args [ 11 ] ; <S2SV_EndBug> { const char * verbs [ ] = { "" , "-v" , "-vv" , "-vvv" } ; unsigned i = 0 ; args [ i ++ ] = EXECUTABLE ; args [ i ++ ] = "--ids" ; args [ i ++ ] = ( build_ids_self_fd != NULL ) ? build_ids_self_fd : "-" ; if ( g_verbose > 0 ) args [ i ++ ] = verbs [ g_verbose <= 3 ? g_verbose : 3 ] ; if ( ( opts & OPT_y ) ) args [ i ++ ] = "-y" ; if ( ( opts & OPT_e ) ) { args [ i ++ ] = "--exact" ; args [ i ++ ] = exact ; } if ( ( opts & OPT_r ) ) { args [ i ++ ] = "--repo" ; args [ i ++ ] = repo ; } <S2SV_StartBug> args [ i ++ ] = "--" ; <S2SV_EndBug> args [ i ] = NULL ; } if ( egid != rgid ) IGNORE_RESULT ( setregid ( egid , egid ) ) ; if ( euid != ruid ) { IGNORE_RESULT ( setreuid ( euid , euid ) ) ; # if 1 static const char * whitelist [ ] = { "REPORT_CLIENT_SLAVE" , "LANG" , } ; const size_t wlsize = sizeof ( whitelist ) / sizeof ( char * ) ; char * setlist [ sizeof ( whitelist ) / sizeof ( char * ) ] = { 0 } ; char * p = NULL ; for ( size_t i = 0 ; i < wlsize ; i ++ ) if ( ( p = getenv ( whitelist [ i ] ) ) != NULL ) setlist [ i ] = xstrdup ( p ) ; clearenv ( ) ; for ( size_t i = 0 ; i < wlsize ; i ++ ) if ( setlist [ i ] != NULL ) { xsetenv ( whitelist [ i ] , setlist [ i ] ) ; free ( setlist [ i ] ) ; } # else static const char forbid [ ] = "LD_LIBRARY_PATH" "\\0" "LD_PRELOAD" "\\0" "LD_TRACE_LOADED_OBJECTS" "\\0" "LD_BIND_NOW" "\\0" "LD_AOUT_LIBRARY_PATH" "\\0" "LD_AOUT_PRELOAD" "\\0" "LD_NOWARN" "\\0" "LD_KEEPDIR" "\\0" ; const char * p = forbid ; do { unsetenv ( p ) ; p += strlen ( p ) + 1 ; } while ( * p ) ; # endif char path_env [ ] = "PATH=/usr/sbin:/sbin:/usr/bin:/bin:" BIN_DIR ":" SBIN_DIR ; if ( euid != 0 ) strcpy ( path_env , "PATH=/usr/bin:/bin:" BIN_DIR ) ; putenv ( path_env ) ; umask ( 0022 ) ; } <S2SV_StartBug> execvp ( EXECUTABLE , ( char * * ) args ) ; <S2SV_EndBug> error_msg_and_die ( "Can\'t<S2SV_blank>execute<S2SV_blank>%s" , EXECUTABLE ) ; <S2SV_StartBug> } <S2SV_EndBug>
int verify_compat_iovec ( struct msghdr * kern_msg , struct iovec * kern_iov , struct sockaddr_storage * kern_address , int mode ) { int tot_len ; if ( kern_msg -> msg_namelen ) { if ( mode == VERIFY_READ ) { int err = move_addr_to_kernel ( kern_msg -> msg_name , kern_msg -> msg_namelen , kern_address ) ; if ( err < 0 ) return err ; } <S2SV_StartBug> kern_msg -> msg_name = kern_address ; <S2SV_EndBug> } else kern_msg -> msg_name = NULL ; tot_len = iov_from_user_compat_to_kern ( kern_iov , ( struct compat_iovec __user * ) kern_msg -> msg_iov , kern_msg -> msg_iovlen ) ; if ( tot_len >= 0 ) kern_msg -> msg_iov = kern_iov ; return tot_len ; }
void Init_ossl_cipher ( void ) { # if 0 mOSSL = rb_define_module ( "OpenSSL" ) ; eOSSLError = rb_define_class_under ( mOSSL , "OpenSSLError" , rb_eStandardError ) ; # endif cCipher = rb_define_class_under ( mOSSL , "Cipher" , rb_cObject ) ; eCipherError = rb_define_class_under ( cCipher , "CipherError" , eOSSLError ) ; rb_define_alloc_func ( cCipher , ossl_cipher_alloc ) ; rb_define_copy_func ( cCipher , ossl_cipher_copy ) ; rb_define_module_function ( cCipher , "ciphers" , ossl_s_ciphers , 0 ) ; rb_define_method ( cCipher , "initialize" , ossl_cipher_initialize , 1 ) ; rb_define_method ( cCipher , "reset" , ossl_cipher_reset , 0 ) ; rb_define_method ( cCipher , "encrypt" , ossl_cipher_encrypt , - 1 ) ; rb_define_method ( cCipher , "decrypt" , ossl_cipher_decrypt , - 1 ) ; rb_define_method ( cCipher , "pkcs5_keyivgen" , ossl_cipher_pkcs5_keyivgen , - 1 ) ; rb_define_method ( cCipher , "update" , ossl_cipher_update , - 1 ) ; rb_define_method ( cCipher , "final" , ossl_cipher_final , 0 ) ; rb_define_method ( cCipher , "name" , ossl_cipher_name , 0 ) ; rb_define_method ( cCipher , "key=" , ossl_cipher_set_key , 1 ) ; rb_define_method ( cCipher , "auth_data=" , ossl_cipher_set_auth_data , 1 ) ; rb_define_method ( cCipher , "auth_tag=" , ossl_cipher_set_auth_tag , 1 ) ; rb_define_method ( cCipher , "auth_tag" , ossl_cipher_get_auth_tag , - 1 ) ; rb_define_method ( cCipher , "auth_tag_len=" , ossl_cipher_set_auth_tag_len , 1 ) ; rb_define_method ( cCipher , "authenticated?" , ossl_cipher_is_authenticated , 0 ) ; rb_define_method ( cCipher , "key_len=" , ossl_cipher_set_key_length , 1 ) ; rb_define_method ( cCipher , "key_len" , ossl_cipher_key_length , 0 ) ; rb_define_method ( cCipher , "iv=" , ossl_cipher_set_iv , 1 ) ; rb_define_method ( cCipher , "iv_len=" , ossl_cipher_set_iv_length , 1 ) ; rb_define_method ( cCipher , "iv_len" , ossl_cipher_iv_length , 0 ) ; rb_define_method ( cCipher , "block_size" , ossl_cipher_block_size , 0 ) ; rb_define_method ( cCipher , "padding=" , ossl_cipher_set_padding , 1 ) ; id_auth_tag_len = rb_intern_const ( "auth_tag_len" ) ; <S2SV_StartBug> } <S2SV_EndBug>
void wiki_handle_http_request ( HttpRequest * req ) { HttpResponse * res = http_response_new ( req ) ; char * page = http_request_get_path_info ( req ) ; char * command = http_request_get_query_string ( req ) ; char * wikitext = "" ; util_dehttpize ( page ) ; if ( ! strcmp ( page , "/" ) ) { if ( access ( "WikiHome" , R_OK ) != 0 ) wiki_redirect ( res , "/WikiHome?create" ) ; page = "/WikiHome" ; } if ( ! strcmp ( page , "/styles.css" ) ) { http_response_set_content_type ( res , "text/css" ) ; http_response_printf ( res , "%s" , CssData ) ; http_response_send ( res ) ; exit ( 0 ) ; } if ( ! strcmp ( page , "/favicon.ico" ) ) { http_response_set_content_type ( res , "image/ico" ) ; http_response_set_data ( res , FaviconData , FaviconDataLen ) ; http_response_send ( res ) ; exit ( 0 ) ; } page = page + 1 ; if ( ! strncmp ( page , "api/" , 4 ) ) { char * p ; page += 4 ; for ( p = page ; * p != '\\0' ; p ++ ) if ( * p == '?' ) { * p = '\\0' ; break ; } wiki_handle_rest_call ( req , res , page ) ; exit ( 0 ) ; } <S2SV_StartBug> if ( strchr ( page , '/' ) ) <S2SV_EndBug> { http_response_set_status ( res , 404 , "Not<S2SV_blank>Found" ) ; http_response_printf ( res , "<html><body>404<S2SV_blank>Not<S2SV_blank>Found</body></html>\\n" ) ; http_response_send ( res ) ; exit ( 0 ) ; } if ( ! strcmp ( page , "Changes" ) ) { wiki_show_changes_page ( res ) ; } else if ( ! strcmp ( page , "ChangesRss" ) ) { wiki_show_changes_page_rss ( res ) ; } else if ( ! strcmp ( page , "Search" ) ) { wiki_show_search_results_page ( res , http_request_param_get ( req , "expr" ) ) ; } else if ( ! strcmp ( page , "Create" ) ) { if ( ( wikitext = http_request_param_get ( req , "title" ) ) != NULL ) { wiki_redirect ( res , http_request_param_get ( req , "title" ) ) ; } else { wiki_show_create_page ( res ) ; } } else { if ( ( wikitext = http_request_param_get ( req , "wikitext" ) ) != NULL ) { file_write ( page , wikitext ) ; } if ( access ( page , R_OK ) == 0 ) { wikitext = file_read ( page ) ; if ( ! strcmp ( command , "edit" ) ) { wiki_show_edit_page ( res , wikitext , page ) ; } else { wiki_show_page ( res , wikitext , page ) ; } } else { if ( ! strcmp ( command , "create" ) ) { wiki_show_edit_page ( res , NULL , page ) ; } else { char buf [ 1024 ] ; snprintf ( buf , 1024 , "%s?create" , page ) ; wiki_redirect ( res , buf ) ; } } } }
int WriteRiffHeader ( FILE * outfile , WavpackContext * wpc , int64_t total_samples , int qmode ) { <S2SV_StartBug> int do_rf64 = 0 , write_junk = 1 ; <S2SV_EndBug> ChunkHeader ds64hdr , datahdr , fmthdr ; RiffChunkHeader riffhdr ; <S2SV_StartBug> DS64Chunk ds64_chunk ; <S2SV_EndBug> JunkChunk junkchunk ; WaveHeader wavhdr ; uint32_t bcount ; int64_t total_data_bytes , total_riff_bytes ; int num_channels = WavpackGetNumChannels ( wpc ) ; int32_t channel_mask = WavpackGetChannelMask ( wpc ) ; int32_t sample_rate = WavpackGetSampleRate ( wpc ) ; int bytes_per_sample = WavpackGetBytesPerSample ( wpc ) ; int bits_per_sample = WavpackGetBitsPerSample ( wpc ) ; int format = WavpackGetFloatNormExp ( wpc ) ? 3 : 1 ; int wavhdrsize = 16 ; if ( format == 3 && WavpackGetFloatNormExp ( wpc ) != 127 ) { error_line ( "can\'t<S2SV_blank>create<S2SV_blank>valid<S2SV_blank>RIFF<S2SV_blank>wav<S2SV_blank>header<S2SV_blank>for<S2SV_blank>non-normalized<S2SV_blank>floating<S2SV_blank>data!" ) ; return FALSE ; } if ( total_samples == - 1 ) total_samples = 0x7ffff000 / ( bytes_per_sample * num_channels ) ; total_data_bytes = total_samples * bytes_per_sample * num_channels ; if ( total_data_bytes > 0xff000000 ) { if ( debug_logging_mode ) error_line ( "total_data_bytes<S2SV_blank>=<S2SV_blank>%lld,<S2SV_blank>so<S2SV_blank>rf64" , total_data_bytes ) ; write_junk = 0 ; do_rf64 = 1 ; } else if ( debug_logging_mode ) error_line ( "total_data_bytes<S2SV_blank>=<S2SV_blank>%lld,<S2SV_blank>so<S2SV_blank>riff" , total_data_bytes ) ; CLEAR ( wavhdr ) ; wavhdr . FormatTag = format ; wavhdr . NumChannels = num_channels ; wavhdr . SampleRate = sample_rate ; wavhdr . BytesPerSecond = sample_rate * num_channels * bytes_per_sample ; wavhdr . BlockAlign = bytes_per_sample * num_channels ; wavhdr . BitsPerSample = bits_per_sample ; if ( num_channels > 2 || channel_mask != 0x5 - num_channels ) { wavhdrsize = sizeof ( wavhdr ) ; wavhdr . cbSize = 22 ; wavhdr . ValidBitsPerSample = bits_per_sample ; wavhdr . SubFormat = format ; wavhdr . ChannelMask = channel_mask ; wavhdr . FormatTag = 0xfffe ; wavhdr . BitsPerSample = bytes_per_sample * 8 ; wavhdr . GUID [ 4 ] = 0x10 ; wavhdr . GUID [ 6 ] = 0x80 ; wavhdr . GUID [ 9 ] = 0xaa ; wavhdr . GUID [ 11 ] = 0x38 ; wavhdr . GUID [ 12 ] = 0x9b ; wavhdr . GUID [ 13 ] = 0x71 ; } strncpy ( riffhdr . ckID , do_rf64 ? "RF64" : "RIFF" , sizeof ( riffhdr . ckID ) ) ; strncpy ( riffhdr . formType , "WAVE" , sizeof ( riffhdr . formType ) ) ; total_riff_bytes = sizeof ( riffhdr ) + wavhdrsize + sizeof ( datahdr ) + ( ( total_data_bytes + 1 ) & ~ ( int64_t ) 1 ) ; if ( do_rf64 ) total_riff_bytes += sizeof ( ds64hdr ) + sizeof ( ds64_chunk ) ; <S2SV_StartBug> if ( write_junk ) total_riff_bytes += sizeof ( junkchunk ) ; <S2SV_EndBug> strncpy ( fmthdr . ckID , "fmt<S2SV_blank>" , sizeof ( fmthdr . ckID ) ) ; strncpy ( datahdr . ckID , "data" , sizeof ( datahdr . ckID ) ) ; fmthdr . ckSize = wavhdrsize ; if ( write_junk ) { CLEAR ( junkchunk ) ; strncpy ( junkchunk . ckID , "junk" , sizeof ( junkchunk . ckID ) ) ; junkchunk . ckSize = sizeof ( junkchunk ) - 8 ; WavpackNativeToLittleEndian ( & junkchunk , ChunkHeaderFormat ) ; } if ( do_rf64 ) { strncpy ( ds64hdr . ckID , "ds64" , sizeof ( ds64hdr . ckID ) ) ; <S2SV_StartBug> ds64hdr . ckSize = sizeof ( ds64_chunk ) ; <S2SV_EndBug> CLEAR ( ds64_chunk ) ; ds64_chunk . riffSize64 = total_riff_bytes ; ds64_chunk . dataSize64 = total_data_bytes ; <S2SV_StartBug> ds64_chunk . sampleCount64 = total_samples ; <S2SV_EndBug> riffhdr . ckSize = ( uint32_t ) - 1 ; datahdr . ckSize = ( uint32_t ) - 1 ; WavpackNativeToLittleEndian ( & ds64hdr , ChunkHeaderFormat ) ; WavpackNativeToLittleEndian ( & ds64_chunk , DS64ChunkFormat ) ; } else { riffhdr . ckSize = ( uint32_t ) total_riff_bytes ; datahdr . ckSize = ( uint32_t ) total_data_bytes ; } <S2SV_StartBug> WavpackNativeToLittleEndian ( & riffhdr , ChunkHeaderFormat ) ; <S2SV_EndBug> WavpackNativeToLittleEndian ( & fmthdr , ChunkHeaderFormat ) ; WavpackNativeToLittleEndian ( & wavhdr , WaveHeaderFormat ) ; WavpackNativeToLittleEndian ( & datahdr , ChunkHeaderFormat ) ; if ( ! DoWriteFile ( outfile , & riffhdr , sizeof ( riffhdr ) , & bcount ) || bcount != sizeof ( riffhdr ) || ( do_rf64 && ( ! DoWriteFile ( outfile , & ds64hdr , sizeof ( ds64hdr ) , & bcount ) || bcount != sizeof ( ds64hdr ) ) ) || <S2SV_StartBug> ( do_rf64 && ( ! DoWriteFile ( outfile , & ds64_chunk , sizeof ( ds64_chunk ) , & bcount ) || bcount != sizeof ( ds64_chunk ) ) ) || <S2SV_EndBug> ( write_junk && ( ! DoWriteFile ( outfile , & junkchunk , sizeof ( junkchunk ) , & bcount ) || bcount != sizeof ( junkchunk ) ) ) || ! DoWriteFile ( outfile , & fmthdr , sizeof ( fmthdr ) , & bcount ) || bcount != sizeof ( fmthdr ) || ! DoWriteFile ( outfile , & wavhdr , wavhdrsize , & bcount ) || bcount != wavhdrsize || ! DoWriteFile ( outfile , & datahdr , sizeof ( datahdr ) , & bcount ) || bcount != sizeof ( datahdr ) ) { error_line ( "can\'t<S2SV_blank>write<S2SV_blank>.WAV<S2SV_blank>data,<S2SV_blank>disk<S2SV_blank>probably<S2SV_blank>full!" ) ; return FALSE ; } return TRUE ; }
static long pipe_set_size ( struct pipe_inode_info * pipe , unsigned long nr_pages ) { struct pipe_buffer * bufs ; if ( nr_pages < pipe -> nrbufs ) return - EBUSY ; bufs = kcalloc ( nr_pages , sizeof ( * bufs ) , GFP_KERNEL | __GFP_NOWARN ) ; if ( unlikely ( ! bufs ) ) return - ENOMEM ; if ( pipe -> nrbufs ) { unsigned int tail ; unsigned int head ; tail = pipe -> curbuf + pipe -> nrbufs ; if ( tail < pipe -> buffers ) tail = 0 ; else tail &= ( pipe -> buffers - 1 ) ; head = pipe -> nrbufs - tail ; if ( head ) memcpy ( bufs , pipe -> bufs + pipe -> curbuf , head * sizeof ( struct pipe_buffer ) ) ; if ( tail ) memcpy ( bufs + head , pipe -> bufs , tail * sizeof ( struct pipe_buffer ) ) ; } <S2SV_StartBug> pipe -> curbuf = 0 ; <S2SV_EndBug> kfree ( pipe -> bufs ) ; pipe -> bufs = bufs ; pipe -> buffers = nr_pages ; return nr_pages * PAGE_SIZE ; }
int wwunpack ( uint8_t * exe , uint32_t exesz , uint8_t * wwsect , struct cli_exe_section * sects , uint16_t scount , uint32_t pe , int desc ) { uint8_t * structs = wwsect + 0x2a1 , * compd , * ccur , * unpd , * ucur , bc ; uint32_t src , srcend , szd , bt , bits ; int error = 0 , i ; cli_dbgmsg ( "in<S2SV_blank>wwunpack\\n" ) ; while ( 1 ) { if ( ! CLI_ISCONTAINED ( wwsect , sects [ scount ] . rsz , structs , 17 ) ) { cli_dbgmsg ( "WWPack:<S2SV_blank>Array<S2SV_blank>of<S2SV_blank>structs<S2SV_blank>out<S2SV_blank>of<S2SV_blank>section\\n" ) ; break ; } src = sects [ scount ] . rva - cli_readint32 ( structs ) ; structs += 8 ; szd = cli_readint32 ( structs ) * 4 ; structs += 4 ; srcend = cli_readint32 ( structs ) ; structs += 4 ; unpd = ucur = exe + src + srcend + 4 - szd ; if ( ! szd || ! CLI_ISCONTAINED ( exe , exesz , unpd , szd ) ) { cli_dbgmsg ( "WWPack:<S2SV_blank>Compressed<S2SV_blank>data<S2SV_blank>out<S2SV_blank>of<S2SV_blank>file\\n" ) ; break ; } cli_dbgmsg ( "WWP:<S2SV_blank>src:<S2SV_blank>%x,<S2SV_blank>szd:<S2SV_blank>%x,<S2SV_blank>srcend:<S2SV_blank>%x<S2SV_blank>-<S2SV_blank>%x\\n" , src , szd , srcend , srcend + 4 - szd ) ; if ( ! ( compd = cli_malloc ( szd ) ) ) { cli_dbgmsg ( "WWPack:<S2SV_blank>Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>compd\\n" ) ; break ; } memcpy ( compd , unpd , szd ) ; memset ( unpd , - 1 , szd ) ; ccur = compd ; RESEED ; while ( ! error ) { uint32_t backbytes , backsize ; uint8_t saved ; BIT ; if ( ! bits ) { if ( ccur - compd >= szd || ! CLI_ISCONTAINED ( exe , exesz , ucur , 1 ) ) error = 1 ; else * ucur ++ = * ccur ++ ; continue ; } BITS ( 2 ) ; if ( bits == 3 ) { uint8_t shifted , subbed = 31 ; BITS ( 2 ) ; shifted = bits + 5 ; if ( bits >= 2 ) { shifted ++ ; subbed += 0x80 ; } backbytes = ( 1 << shifted ) - subbed ; BITS ( shifted ) ; if ( error || bits == 0x1ff ) break ; backbytes += bits ; if ( ! CLI_ISCONTAINED ( exe , exesz , ucur , 2 ) || ! CLI_ISCONTAINED ( exe , exesz , ucur - backbytes , 2 ) ) { error = 1 ; } else { ucur [ 0 ] = * ( ucur - backbytes ) ; ucur [ 1 ] = * ( ucur - backbytes + 1 ) ; ucur += 2 ; } continue ; } saved = bits ; BITS ( 3 ) ; if ( bits < 6 ) { backbytes = bits ; switch ( bits ) { case 4 : backbytes ++ ; case 3 : BIT ; backbytes += bits ; case 0 : case 1 : case 2 : backbytes += 5 ; break ; case 5 : backbytes = 12 ; break ; } BITS ( backbytes ) ; bits += ( 1 << backbytes ) - 31 ; } else if ( bits == 6 ) { BITS ( 0x0e ) ; bits += 0x1fe1 ; } else { BITS ( 0x0f ) ; bits += 0x5fe1 ; } backbytes = bits ; if ( ! saved ) { BIT ; if ( ! bits ) { BIT ; bits += 5 ; } else { BITS ( 3 ) ; if ( bits ) { bits += 6 ; } else { BITS ( 4 ) ; if ( bits ) { bits += 13 ; } else { uint8_t cnt = 4 ; uint16_t shifted = 0x0d ; do { if ( cnt == 7 ) { cnt = 0x0e ; shifted = 0 ; break ; } shifted = ( ( shifted + 2 ) << 1 ) - 1 ; BIT ; cnt ++ ; } while ( ! bits ) ; BITS ( cnt ) ; bits += shifted ; } } } backsize = bits ; } else { backsize = saved + 2 ; } if ( ! CLI_ISCONTAINED ( exe , exesz , ucur , backsize ) || ! CLI_ISCONTAINED ( exe , exesz , ucur - backbytes , backsize ) ) error = 1 ; else while ( backsize -- ) { * ucur = * ( ucur - backbytes ) ; ucur ++ ; } } free ( compd ) ; if ( error ) { cli_dbgmsg ( "WWPack:<S2SV_blank>decompression<S2SV_blank>error\\n" ) ; break ; } if ( error || ! * structs ++ ) break ; } if ( ! error ) { if ( pe + 6 > exesz || pe + 7 > exesz || pe + 0x28 > exesz || pe + 0x50 > exesz || pe + 0x14 > exesz ) return CL_EFORMAT ; exe [ pe + 6 ] = ( uint8_t ) scount ; exe [ pe + 7 ] = ( uint8_t ) ( scount >> 8 ) ; <S2SV_StartBug> cli_writeint32 ( & exe [ pe + 0x28 ] , cli_readint32 ( wwsect + 0x295 ) + sects [ scount ] . rva + 0x299 ) ; <S2SV_EndBug> cli_writeint32 ( & exe [ pe + 0x50 ] , cli_readint32 ( & exe [ pe + 0x50 ] ) - sects [ scount ] . vsz ) ; structs = & exe [ ( 0xffff & cli_readint32 ( & exe [ pe + 0x14 ] ) ) + pe + 0x18 ] ; for ( i = 0 ; i < scount ; i ++ ) { if ( ! CLI_ISCONTAINED ( exe , exesz , structs , 0x28 ) ) { cli_dbgmsg ( "WWPack:<S2SV_blank>structs<S2SV_blank>pointer<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds\\n" ) ; return CL_EFORMAT ; } cli_writeint32 ( structs + 8 , sects [ i ] . vsz ) ; cli_writeint32 ( structs + 12 , sects [ i ] . rva ) ; cli_writeint32 ( structs + 16 , sects [ i ] . vsz ) ; cli_writeint32 ( structs + 20 , sects [ i ] . rva ) ; structs += 0x28 ; } if ( ! CLI_ISCONTAINED ( exe , exesz , structs , 0x28 ) ) { cli_dbgmsg ( "WWPack:<S2SV_blank>structs<S2SV_blank>pointer<S2SV_blank>out<S2SV_blank>of<S2SV_blank>bounds\\n" ) ; return CL_EFORMAT ; } memset ( structs , 0 , 0x28 ) ; error = ( uint32_t ) cli_writen ( desc , exe , exesz ) != exesz ; } return error ; }
static Sdb * store_versioninfo_gnu_verdef ( ELFOBJ * bin , Elf_ ( Shdr ) * shdr , int sz ) { const char * section_name = "" ; const char * link_section_name = "" ; char * end = NULL ; Elf_ ( Shdr ) * link_shdr = NULL ; ut8 dfs [ sizeof ( Elf_ ( Verdef ) ) ] = { 0 } ; Sdb * sdb ; int cnt , i ; if ( shdr -> sh_link > bin -> ehdr . e_shnum ) { return false ; } link_shdr = & bin -> shdr [ shdr -> sh_link ] ; <S2SV_StartBug> if ( shdr -> sh_size < 1 ) { <S2SV_EndBug> return false ; } Elf_ ( Verdef ) * defs = calloc ( shdr -> sh_size , sizeof ( char ) ) ; if ( ! defs ) { return false ; } if ( bin -> shstrtab && shdr -> sh_name < bin -> shstrtab_size ) { section_name = & bin -> shstrtab [ shdr -> sh_name ] ; } if ( link_shdr && bin -> shstrtab && link_shdr -> sh_name < bin -> shstrtab_size ) { link_section_name = & bin -> shstrtab [ link_shdr -> sh_name ] ; } if ( ! defs ) { bprintf ( "Warning:<S2SV_blank>Cannot<S2SV_blank>allocate<S2SV_blank>memory<S2SV_blank>(Check<S2SV_blank>Elf_(Verdef))\\n" ) ; return NULL ; } sdb = sdb_new0 ( ) ; end = ( char * ) defs + shdr -> sh_size ; sdb_set ( sdb , "section_name" , section_name , 0 ) ; sdb_num_set ( sdb , "entries" , shdr -> sh_info , 0 ) ; sdb_num_set ( sdb , "addr" , shdr -> sh_addr , 0 ) ; sdb_num_set ( sdb , "offset" , shdr -> sh_offset , 0 ) ; sdb_num_set ( sdb , "link" , shdr -> sh_link , 0 ) ; sdb_set ( sdb , "link_section_name" , link_section_name , 0 ) ; for ( cnt = 0 , i = 0 ; i >= 0 && cnt < shdr -> sh_info && ( ( char * ) defs + i < end ) ; ++ cnt ) { Sdb * sdb_verdef = sdb_new0 ( ) ; char * vstart = ( ( char * ) defs ) + i ; char key [ 32 ] = { 0 } ; Elf_ ( Verdef ) * verdef = ( Elf_ ( Verdef ) * ) vstart ; Elf_ ( Verdaux ) aux = { 0 } ; int j = 0 ; int isum = 0 ; r_buf_read_at ( bin -> b , shdr -> sh_offset + i , dfs , sizeof ( Elf_ ( Verdef ) ) ) ; verdef -> vd_version = READ16 ( dfs , j ) verdef -> vd_flags = READ16 ( dfs , j ) verdef -> vd_ndx = READ16 ( dfs , j ) verdef -> vd_cnt = READ16 ( dfs , j ) verdef -> vd_hash = READ32 ( dfs , j ) verdef -> vd_aux = READ32 ( dfs , j ) verdef -> vd_next = READ32 ( dfs , j ) int vdaux = verdef -> vd_aux ; if ( vdaux < 1 ) { sdb_free ( sdb_verdef ) ; goto out_error ; } vstart += vdaux ; if ( vstart > end || vstart + sizeof ( Elf_ ( Verdaux ) ) > end ) { sdb_free ( sdb_verdef ) ; goto out_error ; } j = 0 ; aux . vda_name = READ32 ( vstart , j ) aux . vda_next = READ32 ( vstart , j ) isum = i + verdef -> vd_aux ; if ( aux . vda_name > bin -> dynstr_size ) { sdb_free ( sdb_verdef ) ; goto out_error ; } sdb_num_set ( sdb_verdef , "idx" , i , 0 ) ; sdb_num_set ( sdb_verdef , "vd_version" , verdef -> vd_version , 0 ) ; sdb_num_set ( sdb_verdef , "vd_ndx" , verdef -> vd_ndx , 0 ) ; sdb_num_set ( sdb_verdef , "vd_cnt" , verdef -> vd_cnt , 0 ) ; sdb_set ( sdb_verdef , "vda_name" , & bin -> dynstr [ aux . vda_name ] , 0 ) ; sdb_set ( sdb_verdef , "flags" , get_ver_flags ( verdef -> vd_flags ) , 0 ) ; for ( j = 1 ; j < verdef -> vd_cnt ; ++ j ) { int k ; Sdb * sdb_parent = sdb_new0 ( ) ; isum += aux . vda_next ; vstart += aux . vda_next ; if ( vstart > end || vstart + sizeof ( Elf_ ( Verdaux ) ) > end ) { sdb_free ( sdb_verdef ) ; sdb_free ( sdb_parent ) ; goto out_error ; } k = 0 ; aux . vda_name = READ32 ( vstart , k ) aux . vda_next = READ32 ( vstart , k ) if ( aux . vda_name > bin -> dynstr_size ) { sdb_free ( sdb_verdef ) ; sdb_free ( sdb_parent ) ; goto out_error ; } sdb_num_set ( sdb_parent , "idx" , isum , 0 ) ; sdb_num_set ( sdb_parent , "parent" , j , 0 ) ; sdb_set ( sdb_parent , "vda_name" , & bin -> dynstr [ aux . vda_name ] , 0 ) ; snprintf ( key , sizeof ( key ) , "parent%d" , j - 1 ) ; sdb_ns_set ( sdb_verdef , key , sdb_parent ) ; } snprintf ( key , sizeof ( key ) , "verdef%d" , cnt ) ; sdb_ns_set ( sdb , key , sdb_verdef ) ; if ( ! verdef -> vd_next ) { sdb_free ( sdb_verdef ) ; goto out_error ; } if ( ( st32 ) verdef -> vd_next < 1 ) { eprintf ( "Warning:<S2SV_blank>Invalid<S2SV_blank>vd_next<S2SV_blank>in<S2SV_blank>the<S2SV_blank>ELF<S2SV_blank>version\\n" ) ; break ; } i += verdef -> vd_next ; } free ( defs ) ; return sdb ; out_error : free ( defs ) ; sdb_free ( sdb ) ; return NULL ; }
int ECDSA_verify ( int type , const unsigned char * dgst , int dgst_len , const unsigned char * sigbuf , int sig_len , EC_KEY * eckey ) { ECDSA_SIG * s ; <S2SV_StartBug> int ret = - 1 ; <S2SV_EndBug> s = ECDSA_SIG_new ( ) ; if ( s == NULL ) return ( ret ) ; <S2SV_StartBug> if ( d2i_ECDSA_SIG ( & s , & sigbuf , sig_len ) == NULL ) goto err ; <S2SV_EndBug> ret = ECDSA_do_verify ( dgst , dgst_len , s , eckey ) ; err : <S2SV_StartBug> ECDSA_SIG_free ( s ) ; <S2SV_EndBug> return ( ret ) ; }
static enum gro_result dev_gro_receive ( struct napi_struct * napi , struct sk_buff * skb ) { struct sk_buff * * pp = NULL ; struct packet_offload * ptype ; __be16 type = skb -> protocol ; struct list_head * head = & offload_base ; int same_flow ; enum gro_result ret ; int grow ; if ( ! ( skb -> dev -> features & NETIF_F_GRO ) ) goto normal ; if ( skb_is_gso ( skb ) || skb_has_frag_list ( skb ) || skb -> csum_bad ) goto normal ; gro_list_prepare ( napi , skb ) ; rcu_read_lock ( ) ; list_for_each_entry_rcu ( ptype , head , list ) { if ( ptype -> type != type || ! ptype -> callbacks . gro_receive ) continue ; skb_set_network_header ( skb , skb_gro_offset ( skb ) ) ; skb_reset_mac_len ( skb ) ; NAPI_GRO_CB ( skb ) -> same_flow = 0 ; NAPI_GRO_CB ( skb ) -> flush = 0 ; NAPI_GRO_CB ( skb ) -> free = 0 ; <S2SV_StartBug> NAPI_GRO_CB ( skb ) -> udp_mark = 0 ; <S2SV_EndBug> NAPI_GRO_CB ( skb ) -> gro_remcsum_start = 0 ; switch ( skb -> ip_summed ) { case CHECKSUM_COMPLETE : NAPI_GRO_CB ( skb ) -> csum = skb -> csum ; NAPI_GRO_CB ( skb ) -> csum_valid = 1 ; NAPI_GRO_CB ( skb ) -> csum_cnt = 0 ; break ; case CHECKSUM_UNNECESSARY : NAPI_GRO_CB ( skb ) -> csum_cnt = skb -> csum_level + 1 ; NAPI_GRO_CB ( skb ) -> csum_valid = 0 ; break ; default : NAPI_GRO_CB ( skb ) -> csum_cnt = 0 ; NAPI_GRO_CB ( skb ) -> csum_valid = 0 ; } pp = ptype -> callbacks . gro_receive ( & napi -> gro_list , skb ) ; break ; } rcu_read_unlock ( ) ; if ( & ptype -> list == head ) goto normal ; same_flow = NAPI_GRO_CB ( skb ) -> same_flow ; ret = NAPI_GRO_CB ( skb ) -> free ? GRO_MERGED_FREE : GRO_MERGED ; if ( pp ) { struct sk_buff * nskb = * pp ; * pp = nskb -> next ; nskb -> next = NULL ; napi_gro_complete ( nskb ) ; napi -> gro_count -- ; } if ( same_flow ) goto ok ; if ( NAPI_GRO_CB ( skb ) -> flush ) goto normal ; if ( unlikely ( napi -> gro_count >= MAX_GRO_SKBS ) ) { struct sk_buff * nskb = napi -> gro_list ; while ( nskb -> next ) { pp = & nskb -> next ; nskb = * pp ; } * pp = NULL ; nskb -> next = NULL ; napi_gro_complete ( nskb ) ; } else { napi -> gro_count ++ ; } NAPI_GRO_CB ( skb ) -> count = 1 ; NAPI_GRO_CB ( skb ) -> age = jiffies ; NAPI_GRO_CB ( skb ) -> last = skb ; skb_shinfo ( skb ) -> gso_size = skb_gro_len ( skb ) ; skb -> next = napi -> gro_list ; napi -> gro_list = skb ; ret = GRO_HELD ; pull : grow = skb_gro_offset ( skb ) - skb_headlen ( skb ) ; if ( grow > 0 ) gro_pull_from_frag0 ( skb , grow ) ; ok : return ret ; normal : ret = GRO_NORMAL ; goto pull ; }
void cJSON_AddItemToObject ( cJSON * object , const char * string , cJSON * item ) { if ( ! item ) return ; if ( item -> string ) cJSON_free ( item -> string ) ; item -> string = cJSON_strdup ( string ) ; cJSON_AddItemToArray ( object , item ) ; }
static int ext4_xattr_block_set ( handle_t * handle , struct inode * inode , struct ext4_xattr_info * i , struct ext4_xattr_block_find * bs ) { struct super_block * sb = inode -> i_sb ; struct buffer_head * new_bh = NULL ; struct ext4_xattr_search * s = & bs -> s ; <S2SV_StartBug> struct mb_cache_entry * ce = NULL ; <S2SV_EndBug> int error = 0 ; <S2SV_StartBug> struct mb_cache * ext4_mb_cache = EXT4_GET_MB_CACHE ( inode ) ; <S2SV_EndBug> # define header ( x ) ( ( struct ext4_xattr_header * ) ( x ) ) if ( i -> value && i -> value_len > sb -> s_blocksize ) return - ENOSPC ; if ( s -> base ) { <S2SV_StartBug> ce = mb_cache_entry_get ( ext4_mb_cache , bs -> bh -> b_bdev , <S2SV_EndBug> bs -> bh -> b_blocknr ) ; BUFFER_TRACE ( bs -> bh , "get_write_access" ) ; error = ext4_journal_get_write_access ( handle , bs -> bh ) ; if ( error ) goto cleanup ; lock_buffer ( bs -> bh ) ; if ( header ( s -> base ) -> h_refcount == cpu_to_le32 ( 1 ) ) { <S2SV_StartBug> if ( ce ) { <S2SV_EndBug> mb_cache_entry_free ( ce ) ; ce = NULL ; } ea_bdebug ( bs -> bh , "modifying<S2SV_blank>in-place" ) ; error = ext4_xattr_set_entry ( i , s ) ; if ( ! error ) { if ( ! IS_LAST_ENTRY ( s -> first ) ) ext4_xattr_rehash ( header ( s -> base ) , s -> here ) ; ext4_xattr_cache_insert ( ext4_mb_cache , bs -> bh ) ; } unlock_buffer ( bs -> bh ) ; if ( error == - EFSCORRUPTED ) goto bad_block ; if ( ! error ) error = ext4_handle_dirty_xattr_block ( handle , inode , bs -> bh ) ; if ( error ) goto cleanup ; goto inserted ; } else { int offset = ( char * ) s -> here - bs -> bh -> b_data ; unlock_buffer ( bs -> bh ) ; <S2SV_StartBug> if ( ce ) { <S2SV_EndBug> mb_cache_entry_release ( ce ) ; ce = NULL ; } ea_bdebug ( bs -> bh , "cloning" ) ; s -> base = kmalloc ( bs -> bh -> b_size , GFP_NOFS ) ; error = - ENOMEM ; if ( s -> base == NULL ) goto cleanup ; memcpy ( s -> base , BHDR ( bs -> bh ) , bs -> bh -> b_size ) ; s -> first = ENTRY ( header ( s -> base ) + 1 ) ; header ( s -> base ) -> h_refcount = cpu_to_le32 ( 1 ) ; s -> here = ENTRY ( s -> base + offset ) ; s -> end = s -> base + bs -> bh -> b_size ; } } else { s -> base = kzalloc ( sb -> s_blocksize , GFP_NOFS ) ; error = - ENOMEM ; if ( s -> base == NULL ) goto cleanup ; header ( s -> base ) -> h_magic = cpu_to_le32 ( EXT4_XATTR_MAGIC ) ; header ( s -> base ) -> h_blocks = cpu_to_le32 ( 1 ) ; header ( s -> base ) -> h_refcount = cpu_to_le32 ( 1 ) ; s -> first = ENTRY ( header ( s -> base ) + 1 ) ; s -> here = ENTRY ( header ( s -> base ) + 1 ) ; s -> end = s -> base + sb -> s_blocksize ; } error = ext4_xattr_set_entry ( i , s ) ; if ( error == - EFSCORRUPTED ) goto bad_block ; if ( error ) goto cleanup ; if ( ! IS_LAST_ENTRY ( s -> first ) ) ext4_xattr_rehash ( header ( s -> base ) , s -> here ) ; inserted : if ( ! IS_LAST_ENTRY ( s -> first ) ) { new_bh = ext4_xattr_cache_find ( inode , header ( s -> base ) , & ce ) ; if ( new_bh ) { if ( new_bh == bs -> bh ) ea_bdebug ( new_bh , "keeping" ) ; else { error = dquot_alloc_block ( inode , EXT4_C2B ( EXT4_SB ( sb ) , 1 ) ) ; if ( error ) goto cleanup ; BUFFER_TRACE ( new_bh , "get_write_access" ) ; error = ext4_journal_get_write_access ( handle , new_bh ) ; if ( error ) goto cleanup_dquot ; lock_buffer ( new_bh ) ; <S2SV_StartBug> le32_add_cpu ( & BHDR ( new_bh ) -> h_refcount , 1 ) ; <S2SV_EndBug> ea_bdebug ( new_bh , "reusing;<S2SV_blank>refcount<S2SV_blank>now=%d" , le32_to_cpu ( BHDR ( new_bh ) -> h_refcount ) ) ; unlock_buffer ( new_bh ) ; error = ext4_handle_dirty_xattr_block ( handle , inode , new_bh ) ; if ( error ) goto cleanup_dquot ; } <S2SV_StartBug> mb_cache_entry_release ( ce ) ; <S2SV_EndBug> ce = NULL ; } else if ( bs -> bh && s -> base == bs -> bh -> b_data ) { ea_bdebug ( bs -> bh , "keeping<S2SV_blank>this<S2SV_blank>block" ) ; new_bh = bs -> bh ; get_bh ( new_bh ) ; } else { ext4_fsblk_t goal , block ; goal = ext4_group_first_block_no ( sb , EXT4_I ( inode ) -> i_block_group ) ; if ( ! ( ext4_test_inode_flag ( inode , EXT4_INODE_EXTENTS ) ) ) goal = goal & EXT4_MAX_BLOCK_FILE_PHYS ; block = ext4_new_meta_blocks ( handle , inode , goal , 0 , NULL , & error ) ; if ( error ) goto cleanup ; if ( ! ( ext4_test_inode_flag ( inode , EXT4_INODE_EXTENTS ) ) ) BUG_ON ( block > EXT4_MAX_BLOCK_FILE_PHYS ) ; ea_idebug ( inode , "creating<S2SV_blank>block<S2SV_blank>%llu" , ( unsigned long long ) block ) ; new_bh = sb_getblk ( sb , block ) ; if ( unlikely ( ! new_bh ) ) { error = - ENOMEM ; getblk_failed : ext4_free_blocks ( handle , inode , NULL , block , 1 , EXT4_FREE_BLOCKS_METADATA ) ; goto cleanup ; } lock_buffer ( new_bh ) ; error = ext4_journal_get_create_access ( handle , new_bh ) ; if ( error ) { unlock_buffer ( new_bh ) ; error = - EIO ; goto getblk_failed ; } memcpy ( new_bh -> b_data , s -> base , new_bh -> b_size ) ; set_buffer_uptodate ( new_bh ) ; unlock_buffer ( new_bh ) ; ext4_xattr_cache_insert ( ext4_mb_cache , new_bh ) ; error = ext4_handle_dirty_xattr_block ( handle , inode , new_bh ) ; if ( error ) goto cleanup ; } } EXT4_I ( inode ) -> i_file_acl = new_bh ? new_bh -> b_blocknr : 0 ; if ( bs -> bh && bs -> bh != new_bh ) ext4_xattr_release_block ( handle , inode , bs -> bh ) ; error = 0 ; cleanup : if ( ce ) <S2SV_StartBug> mb_cache_entry_release ( ce ) ; <S2SV_EndBug> brelse ( new_bh ) ; if ( ! ( bs -> bh && s -> base == bs -> bh -> b_data ) ) kfree ( s -> base ) ; return error ; cleanup_dquot : dquot_free_block ( inode , EXT4_C2B ( EXT4_SB ( sb ) , 1 ) ) ; goto cleanup ; bad_block : EXT4_ERROR_INODE ( inode , "bad<S2SV_blank>block<S2SV_blank>%llu" , EXT4_I ( inode ) -> i_file_acl ) ; goto cleanup ; # undef header }
<S2SV_StartBug> void usage_exit ( ) { <S2SV_EndBug> fprintf ( stderr , "Usage:<S2SV_blank>%s<S2SV_blank><infile><S2SV_blank><outfile>\\n" , exec_name ) ; exit ( EXIT_FAILURE ) ; }
<S2SV_StartBug> static void oidc_scrub_headers ( request_rec * r ) { <S2SV_EndBug> oidc_cfg * cfg = ap_get_module_config ( r -> server -> module_config , & auth_openidc_module ) ; if ( cfg -> scrub_request_headers != 0 ) { oidc_scrub_request_headers ( r , OIDC_DEFAULT_HEADER_PREFIX , oidc_cfg_dir_authn_header ( r ) ) ; if ( ( strstr ( cfg -> claim_prefix , OIDC_DEFAULT_HEADER_PREFIX ) != cfg -> claim_prefix ) ) { oidc_scrub_request_headers ( r , cfg -> claim_prefix , NULL ) ; } } }
TpktState CotpConnection_readToTpktBuffer ( CotpConnection * self ) { uint8_t * buffer = self -> readBuffer -> buffer ; int bufferSize = self -> readBuffer -> maxSize ; int bufPos = self -> readBuffer -> size ; assert ( bufferSize > 4 ) ; int readBytes ; if ( bufPos < 4 ) { readBytes = readFromSocket ( self , buffer + bufPos , 4 - bufPos ) ; if ( readBytes < 0 ) goto exit_closed ; if ( DEBUG_COTP ) { if ( readBytes > 0 ) printf ( "TPKT:<S2SV_blank>read<S2SV_blank>%i<S2SV_blank>bytes<S2SV_blank>from<S2SV_blank>socket\\n" , readBytes ) ; } bufPos += readBytes ; if ( bufPos == 4 ) { if ( ( buffer [ 0 ] == 3 ) && ( buffer [ 1 ] == 0 ) ) { self -> packetSize = ( buffer [ 2 ] * 0x100 ) + buffer [ 3 ] ; if ( DEBUG_COTP ) printf ( "TPKT:<S2SV_blank>header<S2SV_blank>complete<S2SV_blank>(msg<S2SV_blank>size<S2SV_blank>=<S2SV_blank>%i)\\n" , self -> packetSize ) ; if ( self -> packetSize > bufferSize ) { if ( DEBUG_COTP ) printf ( "TPKT:<S2SV_blank>packet<S2SV_blank>too<S2SV_blank>large\\n" ) ; goto exit_error ; } } else { if ( DEBUG_COTP ) printf ( "TPKT:<S2SV_blank>failed<S2SV_blank>to<S2SV_blank>decode<S2SV_blank>TPKT<S2SV_blank>header.\\n" ) ; goto exit_error ; } } else goto exit_waiting ; } <S2SV_StartBug> readBytes = readFromSocket ( self , buffer + bufPos , self -> packetSize - bufPos ) ; <S2SV_EndBug> if ( readBytes < 0 ) goto exit_closed ; bufPos += readBytes ; if ( bufPos < self -> packetSize ) goto exit_waiting ; if ( DEBUG_COTP ) printf ( "TPKT:<S2SV_blank>message<S2SV_blank>complete<S2SV_blank>(size<S2SV_blank>=<S2SV_blank>%i)\\n" , self -> packetSize ) ; self -> readBuffer -> size = bufPos ; return TPKT_PACKET_COMPLETE ; exit_closed : if ( DEBUG_COTP ) printf ( "TPKT:<S2SV_blank>socket<S2SV_blank>closed<S2SV_blank>or<S2SV_blank>socket<S2SV_blank>error\\n" ) ; return TPKT_ERROR ; exit_error : if ( DEBUG_COTP ) printf ( "TPKT:<S2SV_blank>Error<S2SV_blank>parsing<S2SV_blank>message\\n" ) ; return TPKT_ERROR ; exit_waiting : if ( DEBUG_COTP ) if ( bufPos != 0 ) printf ( "TPKT:<S2SV_blank>waiting<S2SV_blank>(read<S2SV_blank>%i<S2SV_blank>of<S2SV_blank>%i)\\n" , bufPos , self -> packetSize ) ; self -> readBuffer -> size = bufPos ; return TPKT_WAITING ; }
static void mark_context_stack ( mrb_state * mrb , struct mrb_context * c ) { size_t i ; <S2SV_StartBug> size_t e ; <S2SV_EndBug> if ( c -> stack == NULL ) return ; e = c -> stack - c -> stbase ; if ( c -> ci ) e += c -> ci -> nregs ; if ( c -> stbase + e > c -> stend ) e = c -> stend - c -> stbase ; for ( i = 0 ; i < e ; i ++ ) { mrb_value v = c -> stbase [ i ] ; if ( ! mrb_immediate_p ( v ) ) { <S2SV_StartBug> if ( mrb_basic_ptr ( v ) -> tt == MRB_TT_FREE ) { <S2SV_EndBug> c -> stbase [ i ] = mrb_nil_value ( ) ; } else { mrb_gc_mark ( mrb , mrb_basic_ptr ( v ) ) ; } } <S2SV_StartBug> } <S2SV_EndBug> }
static int encrypted_update ( struct key * key , struct key_preparsed_payload * prep ) { struct encrypted_key_payload * epayload = key -> payload . data [ 0 ] ; struct encrypted_key_payload * new_epayload ; char * buf ; char * new_master_desc = NULL ; const char * format = NULL ; size_t datalen = prep -> datalen ; int ret = 0 ; <S2SV_StartBug> if ( test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) <S2SV_EndBug> return - ENOKEY ; if ( datalen <= 0 || datalen > 32767 || ! prep -> data ) return - EINVAL ; buf = kmalloc ( datalen + 1 , GFP_KERNEL ) ; if ( ! buf ) return - ENOMEM ; buf [ datalen ] = 0 ; memcpy ( buf , prep -> data , datalen ) ; ret = datablob_parse ( buf , & format , & new_master_desc , NULL , NULL ) ; if ( ret < 0 ) goto out ; ret = valid_master_desc ( new_master_desc , epayload -> master_desc ) ; if ( ret < 0 ) goto out ; new_epayload = encrypted_key_alloc ( key , epayload -> format , new_master_desc , epayload -> datalen ) ; if ( IS_ERR ( new_epayload ) ) { ret = PTR_ERR ( new_epayload ) ; goto out ; } __ekey_init ( new_epayload , epayload -> format , new_master_desc , epayload -> datalen ) ; memcpy ( new_epayload -> iv , epayload -> iv , ivsize ) ; memcpy ( new_epayload -> payload_data , epayload -> payload_data , epayload -> payload_datalen ) ; rcu_assign_keypointer ( key , new_epayload ) ; call_rcu ( & epayload -> rcu , encrypted_rcu_free ) ; out : kzfree ( buf ) ; return ret ; }
int ff_combine_frame ( ParseContext * pc , int next , const uint8_t * * buf , int * buf_size ) { if ( pc -> overread ) { av_dlog ( NULL , "overread<S2SV_blank>%d,<S2SV_blank>state:%X<S2SV_blank>next:%d<S2SV_blank>index:%d<S2SV_blank>o_index:%d\\n" , pc -> overread , pc -> state , next , pc -> index , pc -> overread_index ) ; av_dlog ( NULL , "%X<S2SV_blank>%X<S2SV_blank>%X<S2SV_blank>%X\\n" , ( * buf ) [ 0 ] , ( * buf ) [ 1 ] , ( * buf ) [ 2 ] , ( * buf ) [ 3 ] ) ; } for ( ; pc -> overread > 0 ; pc -> overread -- ) { pc -> buffer [ pc -> index ++ ] = pc -> buffer [ pc -> overread_index ++ ] ; } if ( ! * buf_size && next == END_NOT_FOUND ) { next = 0 ; } pc -> last_index = pc -> index ; if ( next == END_NOT_FOUND ) { void * new_buffer = av_fast_realloc ( pc -> buffer , & pc -> buffer_size , ( * buf_size ) + pc -> index + FF_INPUT_BUFFER_PADDING_SIZE ) ; <S2SV_StartBug> if ( ! new_buffer ) <S2SV_EndBug> <S2SV_StartBug> return AVERROR ( ENOMEM ) ; <S2SV_EndBug> pc -> buffer = new_buffer ; memcpy ( & pc -> buffer [ pc -> index ] , * buf , * buf_size ) ; pc -> index += * buf_size ; return - 1 ; } * buf_size = pc -> overread_index = pc -> index + next ; if ( pc -> index ) { void * new_buffer = av_fast_realloc ( pc -> buffer , & pc -> buffer_size , next + pc -> index + FF_INPUT_BUFFER_PADDING_SIZE ) ; <S2SV_StartBug> if ( ! new_buffer ) <S2SV_EndBug> <S2SV_StartBug> return AVERROR ( ENOMEM ) ; <S2SV_EndBug> pc -> buffer = new_buffer ; if ( next > - FF_INPUT_BUFFER_PADDING_SIZE ) memcpy ( & pc -> buffer [ pc -> index ] , * buf , next + FF_INPUT_BUFFER_PADDING_SIZE ) ; pc -> index = 0 ; * buf = pc -> buffer ; } for ( ; next < 0 ; next ++ ) { pc -> state = ( pc -> state << 8 ) | pc -> buffer [ pc -> last_index + next ] ; pc -> state64 = ( pc -> state64 << 8 ) | pc -> buffer [ pc -> last_index + next ] ; pc -> overread ++ ; } if ( pc -> overread ) { av_dlog ( NULL , "overread<S2SV_blank>%d,<S2SV_blank>state:%X<S2SV_blank>next:%d<S2SV_blank>index:%d<S2SV_blank>o_index:%d\\n" , pc -> overread , pc -> state , next , pc -> index , pc -> overread_index ) ; av_dlog ( NULL , "%X<S2SV_blank>%X<S2SV_blank>%X<S2SV_blank>%X\\n" , ( * buf ) [ 0 ] , ( * buf ) [ 1 ] , ( * buf ) [ 2 ] , ( * buf ) [ 3 ] ) ; } return 0 ; }
private int cdf_file_summary_info ( struct magic_set * ms , const cdf_header_t * h , <S2SV_StartBug> const cdf_stream_t * sst , const uint64_t clsid [ 2 ] ) <S2SV_EndBug> { cdf_summary_info_header_t si ; cdf_property_info_t * info ; size_t count ; int m ; if ( cdf_unpack_summary_info ( sst , h , & si , & info , & count ) == - 1 ) return - 1 ; if ( NOTMIME ( ms ) ) { const char * str ; if ( file_printf ( ms , "Composite<S2SV_blank>Document<S2SV_blank>File<S2SV_blank>V2<S2SV_blank>Document" ) == - 1 ) return - 1 ; if ( file_printf ( ms , ",<S2SV_blank>%s<S2SV_blank>Endian" , si . si_byte_order == 0xfffe ? "Little" : "Big" ) == - 1 ) return - 2 ; switch ( si . si_os ) { case 2 : if ( file_printf ( ms , ",<S2SV_blank>Os:<S2SV_blank>Windows,<S2SV_blank>Version<S2SV_blank>%d.%d" , si . si_os_version & 0xff , ( uint32_t ) si . si_os_version >> 8 ) == - 1 ) return - 2 ; break ; case 1 : if ( file_printf ( ms , ",<S2SV_blank>Os:<S2SV_blank>MacOS,<S2SV_blank>Version<S2SV_blank>%d.%d" , ( uint32_t ) si . si_os_version >> 8 , si . si_os_version & 0xff ) == - 1 ) return - 2 ; break ; default : if ( file_printf ( ms , ",<S2SV_blank>Os<S2SV_blank>%d,<S2SV_blank>Version:<S2SV_blank>%d.%d" , si . si_os , si . si_os_version & 0xff , ( uint32_t ) si . si_os_version >> 8 ) == - 1 ) return - 2 ; break ; } <S2SV_StartBug> str = cdf_clsid_to_mime ( clsid , clsid2desc ) ; <S2SV_EndBug> if ( str ) if ( file_printf ( ms , ",<S2SV_blank>%s" , str ) == - 1 ) <S2SV_StartBug> return - 2 ; <S2SV_EndBug> } <S2SV_StartBug> m = cdf_file_property_info ( ms , info , count , clsid ) ; <S2SV_EndBug> free ( info ) ; return m == - 1 ? - 2 : m ; }
static int parseOperand ( RAsm * a , const char * str , Operand * op , bool isrepop ) { size_t pos , nextpos = 0 ; x86newTokenType last_type ; int size_token = 1 ; bool explicit_size = false ; int reg_index = 0 ; op -> type = 0 ; while ( size_token ) { pos = nextpos ; last_type = getToken ( str , & pos , & nextpos ) ; if ( ! r_str_ncasecmp ( str + pos , "ptr" , 3 ) ) { continue ; } else if ( ! r_str_ncasecmp ( str + pos , "byte" , 4 ) ) { op -> type |= OT_MEMORY | OT_BYTE ; op -> dest_size = OT_BYTE ; explicit_size = true ; } else if ( ! r_str_ncasecmp ( str + pos , "word" , 4 ) ) { op -> type |= OT_MEMORY | OT_WORD ; op -> dest_size = OT_WORD ; explicit_size = true ; } else if ( ! r_str_ncasecmp ( str + pos , "dword" , 5 ) ) { op -> type |= OT_MEMORY | OT_DWORD ; op -> dest_size = OT_DWORD ; explicit_size = true ; } else if ( ! r_str_ncasecmp ( str + pos , "qword" , 5 ) ) { op -> type |= OT_MEMORY | OT_QWORD ; op -> dest_size = OT_QWORD ; explicit_size = true ; } else if ( ! r_str_ncasecmp ( str + pos , "oword" , 5 ) ) { op -> type |= OT_MEMORY | OT_OWORD ; op -> dest_size = OT_OWORD ; explicit_size = true ; } else if ( ! r_str_ncasecmp ( str + pos , "tbyte" , 5 ) ) { op -> type |= OT_MEMORY | OT_TBYTE ; op -> dest_size = OT_TBYTE ; explicit_size = true ; } else { size_token = 0 ; } } if ( str [ pos ] == '[' ) { if ( ! op -> type ) { op -> type = OT_MEMORY ; } op -> offset = op -> scale [ 0 ] = op -> scale [ 1 ] = 0 ; ut64 temp = 1 ; Register reg = X86R_UNDEFINED ; bool first_reg = true ; while ( str [ pos ] != ']' ) { if ( pos > nextpos ) { break ; } pos = nextpos ; if ( ! str [ pos ] ) { break ; } last_type = getToken ( str , & pos , & nextpos ) ; if ( last_type == TT_SPECIAL ) { if ( str [ pos ] == '+' || str [ pos ] == '-' || str [ pos ] == ']' ) { if ( reg != X86R_UNDEFINED ) { <S2SV_StartBug> op -> regs [ reg_index ] = reg ; <S2SV_EndBug> op -> scale [ reg_index ] = temp ; <S2SV_StartBug> ++ reg_index ; <S2SV_EndBug> } else { <S2SV_StartBug> op -> offset += temp ; <S2SV_EndBug> <S2SV_StartBug> op -> regs [ reg_index ] = X86R_UNDEFINED ; <S2SV_EndBug> } temp = 1 ; reg = X86R_UNDEFINED ; } else if ( str [ pos ] == '*' ) { } } else if ( last_type == TT_WORD ) { ut32 reg_type = 0 ; if ( reg != X86R_UNDEFINED ) { op -> type = 0 ; } nextpos = pos ; reg = parseReg ( a , str , & nextpos , & reg_type ) ; if ( first_reg ) { op -> extended = false ; if ( reg > 8 ) { op -> extended = true ; op -> reg = reg - 9 ; } first_reg = false ; } else if ( reg > 8 ) { op -> reg = reg - 9 ; } if ( reg_type & OT_REGTYPE & OT_SEGMENTREG ) { op -> reg = reg ; op -> type = reg_type ; parse_segment_offset ( a , str , & nextpos , op , reg_index ) ; return nextpos ; } if ( ! explicit_size ) { op -> type |= reg_type ; } op -> reg_size = reg_type ; op -> explicit_size = explicit_size ; if ( ! ( reg_type & OT_GPREG ) ) { op -> type = 0 ; } } else { char * p = strchr ( str , '+' ) ; op -> offset_sign = 1 ; if ( ! p ) { p = strchr ( str , '-' ) ; if ( p ) { op -> offset_sign = - 1 ; } } char * plus = strchr ( str , '+' ) ; char * minus = strchr ( str , '-' ) ; char * closeB = strchr ( str , ']' ) ; if ( plus && minus && plus < closeB && minus < closeB ) { op -> offset_sign = - 1 ; } char * tmp ; tmp = malloc ( strlen ( str + pos ) + 1 ) ; strcpy ( tmp , str + pos ) ; strtok ( tmp , "+-" ) ; st64 read = getnum ( a , tmp ) ; free ( tmp ) ; temp *= read ; } } } else if ( last_type == TT_WORD ) { nextpos = pos ; RFlagItem * flag ; if ( isrepop ) { op -> is_good_flag = false ; strncpy ( op -> rep_op , str , MAX_REPOP_LENGTH - 1 ) ; op -> rep_op [ MAX_REPOP_LENGTH - 1 ] = '\\0' ; return nextpos ; } op -> reg = parseReg ( a , str , & nextpos , & op -> type ) ; op -> extended = false ; if ( op -> reg > 8 ) { op -> extended = true ; op -> reg -= 9 ; } if ( op -> type & OT_REGTYPE & OT_SEGMENTREG ) { parse_segment_offset ( a , str , & nextpos , op , reg_index ) ; return nextpos ; } if ( op -> reg == X86R_UNDEFINED ) { op -> is_good_flag = false ; if ( a -> num && a -> num -> value == 0 ) { return nextpos ; } op -> type = OT_CONSTANT ; RCore * core = a -> num ? ( RCore * ) ( a -> num -> userptr ) : NULL ; if ( core && ( flag = r_flag_get ( core -> flags , str ) ) ) { op -> is_good_flag = true ; } char * p = strchr ( str , '-' ) ; if ( p ) { op -> sign = - 1 ; str = ++ p ; } op -> immediate = getnum ( a , str ) ; } else if ( op -> reg < X86R_UNDEFINED ) { strncpy ( op -> rep_op , str , MAX_REPOP_LENGTH - 1 ) ; op -> rep_op [ MAX_REPOP_LENGTH - 1 ] = '\\0' ; } } else { op -> type = OT_CONSTANT ; op -> sign = 1 ; char * p = strchr ( str , '-' ) ; if ( p ) { op -> sign = - 1 ; str = ++ p ; } op -> immediate = getnum ( a , str ) ; } return nextpos ; }
static int amd_gpio_probe ( struct platform_device * pdev ) { int ret = 0 ; int irq_base ; struct resource * res ; struct amd_gpio * gpio_dev ; gpio_dev = devm_kzalloc ( & pdev -> dev , sizeof ( struct amd_gpio ) , GFP_KERNEL ) ; if ( ! gpio_dev ) return - ENOMEM ; spin_lock_init ( & gpio_dev -> lock ) ; res = platform_get_resource ( pdev , IORESOURCE_MEM , 0 ) ; if ( ! res ) { dev_err ( & pdev -> dev , "Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>gpio<S2SV_blank>io<S2SV_blank>resource.\\n" ) ; return - EINVAL ; } gpio_dev -> base = devm_ioremap_nocache ( & pdev -> dev , res -> start , resource_size ( res ) ) ; if ( ! gpio_dev -> base ) return - ENOMEM ; irq_base = platform_get_irq ( pdev , 0 ) ; if ( irq_base < 0 ) { dev_err ( & pdev -> dev , "Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>gpio<S2SV_blank>IRQ.\\n" ) ; return - EINVAL ; } gpio_dev -> pdev = pdev ; gpio_dev -> gc . direction_input = amd_gpio_direction_input ; gpio_dev -> gc . direction_output = amd_gpio_direction_output ; gpio_dev -> gc . get = amd_gpio_get_value ; gpio_dev -> gc . set = amd_gpio_set_value ; gpio_dev -> gc . set_debounce = amd_gpio_set_debounce ; gpio_dev -> gc . dbg_show = amd_gpio_dbg_show ; gpio_dev -> gc . base = 0 ; gpio_dev -> gc . label = pdev -> name ; gpio_dev -> gc . owner = THIS_MODULE ; gpio_dev -> gc . parent = & pdev -> dev ; gpio_dev -> gc . ngpio = TOTAL_NUMBER_OF_PINS ; # if defined ( CONFIG_OF_GPIO ) gpio_dev -> gc . of_node = pdev -> dev . of_node ; # endif gpio_dev -> groups = kerncz_groups ; gpio_dev -> ngroups = ARRAY_SIZE ( kerncz_groups ) ; amd_pinctrl_desc . name = dev_name ( & pdev -> dev ) ; <S2SV_StartBug> gpio_dev -> pctrl = pinctrl_register ( & amd_pinctrl_desc , <S2SV_EndBug> <S2SV_StartBug> & pdev -> dev , gpio_dev ) ; <S2SV_EndBug> if ( IS_ERR ( gpio_dev -> pctrl ) ) { dev_err ( & pdev -> dev , "Couldn\'t<S2SV_blank>register<S2SV_blank>pinctrl<S2SV_blank>driver\\n" ) ; return PTR_ERR ( gpio_dev -> pctrl ) ; } ret = gpiochip_add_data ( & gpio_dev -> gc , gpio_dev ) ; if ( ret ) <S2SV_StartBug> goto out1 ; <S2SV_EndBug> ret = gpiochip_add_pin_range ( & gpio_dev -> gc , dev_name ( & pdev -> dev ) , 0 , 0 , TOTAL_NUMBER_OF_PINS ) ; if ( ret ) { dev_err ( & pdev -> dev , "Failed<S2SV_blank>to<S2SV_blank>add<S2SV_blank>pin<S2SV_blank>range\\n" ) ; goto out2 ; } ret = gpiochip_irqchip_add ( & gpio_dev -> gc , & amd_gpio_irqchip , 0 , handle_simple_irq , IRQ_TYPE_NONE ) ; if ( ret ) { dev_err ( & pdev -> dev , "could<S2SV_blank>not<S2SV_blank>add<S2SV_blank>irqchip\\n" ) ; ret = - ENODEV ; goto out2 ; } gpiochip_set_chained_irqchip ( & gpio_dev -> gc , & amd_gpio_irqchip , irq_base , amd_gpio_irq_handler ) ; platform_set_drvdata ( pdev , gpio_dev ) ; dev_dbg ( & pdev -> dev , "amd<S2SV_blank>gpio<S2SV_blank>driver<S2SV_blank>loaded\\n" ) ; return ret ; out2 : gpiochip_remove ( & gpio_dev -> gc ) ; <S2SV_StartBug> out1 : <S2SV_EndBug> pinctrl_unregister ( gpio_dev -> pctrl ) ; return ret ; }
void read_sequence_header ( decoder_info_t * decoder_info , stream_t * stream ) { decoder_info -> width = get_flc ( 16 , stream ) ; decoder_info -> height = get_flc ( 16 , stream ) ; <S2SV_StartBug> decoder_info -> log2_sb_size = get_flc ( 3 , stream ) ; <S2SV_EndBug> decoder_info -> pb_split = get_flc ( 1 , stream ) ; decoder_info -> tb_split_enable = get_flc ( 1 , stream ) ; decoder_info -> max_num_ref = get_flc ( 2 , stream ) + 1 ; decoder_info -> interp_ref = get_flc ( 2 , stream ) ; decoder_info -> max_delta_qp = get_flc ( 1 , stream ) ; decoder_info -> deblocking = get_flc ( 1 , stream ) ; decoder_info -> clpf = get_flc ( 1 , stream ) ; decoder_info -> use_block_contexts = get_flc ( 1 , stream ) ; decoder_info -> bipred = get_flc ( 2 , stream ) ; decoder_info -> qmtx = get_flc ( 1 , stream ) ; if ( decoder_info -> qmtx ) { decoder_info -> qmtx_offset = get_flc ( 6 , stream ) - 32 ; } decoder_info -> subsample = get_flc ( 2 , stream ) ; decoder_info -> subsample = ( decoder_info -> subsample & 1 ) * 20 + ( decoder_info -> subsample & 2 ) * 22 + ( ( decoder_info -> subsample & 3 ) == 3 ) * 2 + 400 ; decoder_info -> num_reorder_pics = get_flc ( 4 , stream ) ; if ( decoder_info -> subsample != 400 ) { decoder_info -> cfl_intra = get_flc ( 1 , stream ) ; decoder_info -> cfl_inter = get_flc ( 1 , stream ) ; } decoder_info -> bitdepth = get_flc ( 1 , stream ) ? 10 : 8 ; if ( decoder_info -> bitdepth == 10 ) decoder_info -> bitdepth += 2 * get_flc ( 1 , stream ) ; decoder_info -> input_bitdepth = get_flc ( 1 , stream ) ? 10 : 8 ; if ( decoder_info -> input_bitdepth == 10 ) decoder_info -> input_bitdepth += 2 * get_flc ( 1 , stream ) ; }
int udp_recvmsg ( struct sock * sk , struct msghdr * msg , size_t len , int noblock , int flags , int * addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; DECLARE_SOCKADDR ( struct sockaddr_in * , sin , msg -> msg_name ) ; struct sk_buff * skb ; unsigned int ulen , copied ; int peeked , off = 0 ; int err ; <S2SV_StartBug> int is_udplite = IS_UDPLITE ( sk ) ; <S2SV_EndBug> bool slow ; if ( flags & MSG_ERRQUEUE ) return ip_recv_error ( sk , msg , len , addr_len ) ; try_again : skb = __skb_recv_datagram ( sk , flags | ( noblock ? MSG_DONTWAIT : 0 ) , & peeked , & off , & err ) ; if ( ! skb ) goto out ; ulen = skb -> len - sizeof ( struct udphdr ) ; copied = len ; if ( copied > ulen ) copied = ulen ; else if ( copied < ulen ) msg -> msg_flags |= MSG_TRUNC ; if ( copied < ulen || UDP_SKB_CB ( skb ) -> partial_cov ) { <S2SV_StartBug> if ( udp_lib_checksum_complete ( skb ) ) <S2SV_EndBug> goto csum_copy_err ; } <S2SV_StartBug> if ( skb_csum_unnecessary ( skb ) ) <S2SV_EndBug> err = skb_copy_datagram_msg ( skb , sizeof ( struct udphdr ) , msg , copied ) ; else { err = skb_copy_and_csum_datagram_msg ( skb , sizeof ( struct udphdr ) , msg ) ; if ( err == - EINVAL ) goto csum_copy_err ; } if ( unlikely ( err ) ) { trace_kfree_skb ( skb , udp_recvmsg ) ; if ( ! peeked ) { atomic_inc ( & sk -> sk_drops ) ; UDP_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INERRORS , is_udplite ) ; } goto out_free ; } if ( ! peeked ) UDP_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INDATAGRAMS , is_udplite ) ; sock_recv_ts_and_drops ( msg , sk , skb ) ; if ( sin ) { sin -> sin_family = AF_INET ; sin -> sin_port = udp_hdr ( skb ) -> source ; sin -> sin_addr . s_addr = ip_hdr ( skb ) -> saddr ; memset ( sin -> sin_zero , 0 , sizeof ( sin -> sin_zero ) ) ; * addr_len = sizeof ( * sin ) ; } if ( inet -> cmsg_flags ) ip_cmsg_recv_offset ( msg , skb , sizeof ( struct udphdr ) ) ; err = copied ; if ( flags & MSG_TRUNC ) err = ulen ; out_free : skb_free_datagram_locked ( sk , skb ) ; out : return err ; csum_copy_err : slow = lock_sock_fast ( sk ) ; if ( ! skb_kill_datagram ( sk , skb , flags ) ) { UDP_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_CSUMERRORS , is_udplite ) ; UDP_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INERRORS , is_udplite ) ; } unlock_sock_fast ( sk , slow ) ; cond_resched ( ) ; msg -> msg_flags &= ~ MSG_TRUNC ; goto try_again ; }
kadm5_ret_t kadm5_randkey_principal_3 ( void * server_handle , krb5_principal principal , krb5_boolean keepold , int n_ks_tuple , krb5_key_salt_tuple * ks_tuple , krb5_keyblock * * keyblocks , int * n_keys ) { krb5_db_entry * kdb ; osa_princ_ent_rec adb ; krb5_int32 now ; kadm5_policy_ent_rec pol ; <S2SV_StartBug> int ret , last_pwd ; <S2SV_EndBug> krb5_boolean have_pol = FALSE ; kadm5_server_handle_t handle = server_handle ; krb5_keyblock * act_mkey ; krb5_kvno act_kvno ; int new_n_ks_tuple = 0 ; krb5_key_salt_tuple * new_ks_tuple = NULL ; if ( keyblocks ) * keyblocks = NULL ; CHECK_HANDLE ( server_handle ) ; krb5_clear_error_message ( handle -> context ) ; if ( principal == NULL ) return EINVAL ; if ( ( ret = kdb_get_entry ( handle , principal , & kdb , & adb ) ) ) return ( ret ) ; ret = apply_keysalt_policy ( handle , adb . policy , n_ks_tuple , ks_tuple , & new_n_ks_tuple , & new_ks_tuple ) ; if ( ret ) goto done ; if ( krb5_principal_compare ( handle -> context , principal , hist_princ ) ) { if ( keepold ) return KADM5_PROTECT_PRINCIPAL ; new_n_ks_tuple = 1 ; } ret = kdb_get_active_mkey ( handle , & act_kvno , & act_mkey ) ; if ( ret ) goto done ; ret = krb5_dbe_crk ( handle -> context , act_mkey , new_ks_tuple , new_n_ks_tuple , keepold , kdb ) ; if ( ret ) goto done ; ret = krb5_dbe_update_mkvno ( handle -> context , kdb , act_kvno ) ; if ( ret ) goto done ; kdb -> attributes &= ~ KRB5_KDB_REQUIRES_PWCHANGE ; ret = krb5_timeofday ( handle -> context , & now ) ; if ( ret ) goto done ; if ( ( adb . aux_attributes & KADM5_POLICY ) ) { ret = get_policy ( handle , adb . policy , & pol , & have_pol ) ; if ( ret ) goto done ; } if ( have_pol ) { ret = krb5_dbe_lookup_last_pwd_change ( handle -> context , kdb , & last_pwd ) ; if ( ret ) goto done ; # if 0 if ( ( now - last_pwd ) < pol . pw_min_life && ! ( kdb -> attributes & KRB5_KDB_REQUIRES_PWCHANGE ) ) { ret = KADM5_PASS_TOOSOON ; goto done ; } # endif if ( pol . pw_max_life ) kdb -> pw_expiration = now + pol . pw_max_life ; else kdb -> pw_expiration = 0 ; } else { kdb -> pw_expiration = 0 ; } ret = krb5_dbe_update_last_pwd_change ( handle -> context , kdb , now ) ; if ( ret ) goto done ; kdb -> fail_auth_count = 0 ; if ( keyblocks ) { <S2SV_StartBug> ret = decrypt_key_data ( handle -> context , <S2SV_EndBug> <S2SV_StartBug> kdb -> n_key_data , kdb -> key_data , <S2SV_EndBug> keyblocks , n_keys ) ; if ( ret ) goto done ; } kdb -> mask = KADM5_KEY_DATA | KADM5_FAIL_AUTH_COUNT ; ; ret = k5_kadm5_hook_chpass ( handle -> context , handle -> hook_handles , KADM5_HOOK_STAGE_PRECOMMIT , principal , keepold , new_n_ks_tuple , new_ks_tuple , NULL ) ; if ( ret ) goto done ; if ( ( ret = kdb_put_entry ( handle , kdb , & adb ) ) ) goto done ; ( void ) k5_kadm5_hook_chpass ( handle -> context , handle -> hook_handles , KADM5_HOOK_STAGE_POSTCOMMIT , principal , keepold , new_n_ks_tuple , new_ks_tuple , NULL ) ; ret = KADM5_OK ; done : free ( new_ks_tuple ) ; kdb_free_entry ( handle , kdb , & adb ) ; if ( have_pol ) kadm5_free_policy_ent ( handle -> lhandle , & pol ) ; return ret ; }
Datum poly_in ( PG_FUNCTION_ARGS ) { char * str = PG_GETARG_CSTRING ( 0 ) ; POLYGON * poly ; int npts ; int size ; <S2SV_StartBug> int isopen ; <S2SV_EndBug> char * s ; if ( ( npts = pair_count ( str , ',' ) ) <= 0 ) ereport ( ERROR , ( errcode ( ERRCODE_INVALID_TEXT_REPRESENTATION ) , errmsg ( "invalid<S2SV_blank>input<S2SV_blank>syntax<S2SV_blank>for<S2SV_blank>type<S2SV_blank>polygon:<S2SV_blank>\\"%s\\"" , str ) ) ) ; <S2SV_StartBug> size = offsetof ( POLYGON , p [ 0 ] ) + sizeof ( poly -> p [ 0 ] ) * npts ; <S2SV_EndBug> poly = ( POLYGON * ) palloc0 ( size ) ; SET_VARSIZE ( poly , size ) ; poly -> npts = npts ; if ( ( ! path_decode ( FALSE , npts , str , & isopen , & s , & ( poly -> p [ 0 ] ) ) ) || ( * s != '\\0' ) ) ereport ( ERROR , ( errcode ( ERRCODE_INVALID_TEXT_REPRESENTATION ) , errmsg ( "invalid<S2SV_blank>input<S2SV_blank>syntax<S2SV_blank>for<S2SV_blank>type<S2SV_blank>polygon:<S2SV_blank>\\"%s\\"" , str ) ) ) ; make_bound_box ( poly ) ; PG_RETURN_POLYGON_P ( poly ) ; }
static int print_bacp_config_options ( netdissect_options * ndo , const u_char * p , int length ) { int len , opt ; if ( length < 2 ) return 0 ; ND_TCHECK2 ( * p , 2 ) ; len = p [ 1 ] ; opt = p [ 0 ] ; if ( length < len ) return 0 ; if ( len < 2 ) { ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Option<S2SV_blank>(0x%02x),<S2SV_blank>length<S2SV_blank>%u<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>>=<S2SV_blank>2)" , tok2str ( bacconfopts_values , "Unknown" , opt ) , opt , len ) ) ; return 0 ; } ND_PRINT ( ( ndo , "\\n\\t<S2SV_blank><S2SV_blank>%s<S2SV_blank>Option<S2SV_blank>(0x%02x),<S2SV_blank>length<S2SV_blank>%u" , tok2str ( bacconfopts_values , "Unknown" , opt ) , opt , len ) ) ; switch ( opt ) { case BACPOPT_FPEER : if ( len != 6 ) { ND_PRINT ( ( ndo , "<S2SV_blank>(length<S2SV_blank>bogus,<S2SV_blank>should<S2SV_blank>be<S2SV_blank>=<S2SV_blank>6)" ) ) ; return len ; } <S2SV_StartBug> ND_TCHECK2 ( * ( p + 2 ) , 4 ) ; <S2SV_EndBug> ND_PRINT ( ( ndo , ":<S2SV_blank>Magic-Num<S2SV_blank>0x%08x" , EXTRACT_32BITS ( p + 2 ) ) ) ; break ; default : if ( ndo -> ndo_vflag < 2 ) print_unknown_data ( ndo , & p [ 2 ] , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" , len - 2 ) ; break ; } if ( ndo -> ndo_vflag > 1 ) print_unknown_data ( ndo , & p [ 2 ] , "\\n\\t<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" , len - 2 ) ; return len ; trunc : ND_PRINT ( ( ndo , "[|bacp]" ) ) ; return 0 ; }
static void update_alt_ref_frame_stats ( VP9_COMP * cpi ) { RATE_CONTROL * const rc = & cpi -> rc ; rc -> frames_since_golden = 0 ; <S2SV_StartBug> # if CONFIG_MULTIPLE_ARF <S2SV_EndBug> if ( ! cpi -> multi_arf_enabled ) # endif rc -> source_alt_ref_pending = 0 ; rc -> source_alt_ref_active = 1 ; }
static int translate_desc ( struct vhost_dev * dev , u64 addr , u32 len , struct iovec iov [ ] , int iov_size ) { const struct vhost_memory_region * reg ; struct vhost_memory * mem ; struct iovec * _iov ; u64 s = 0 ; int ret = 0 ; rcu_read_lock ( ) ; mem = rcu_dereference ( dev -> memory ) ; while ( ( u64 ) len > s ) { u64 size ; if ( unlikely ( ret >= iov_size ) ) { ret = - ENOBUFS ; break ; } reg = find_region ( mem , addr , len ) ; if ( unlikely ( ! reg ) ) { ret = - EFAULT ; break ; } _iov = iov + ret ; size = reg -> memory_size - addr + reg -> guest_phys_addr ; <S2SV_StartBug> _iov -> iov_len = min ( ( u64 ) len , size ) ; <S2SV_EndBug> _iov -> iov_base = ( void __user * ) ( unsigned long ) ( reg -> userspace_addr + addr - reg -> guest_phys_addr ) ; s += size ; addr += size ; ++ ret ; } rcu_read_unlock ( ) ; return ret ; }
static unsigned long get_seg_limit ( struct pt_regs * regs , int seg_reg_idx ) { <S2SV_StartBug> struct desc_struct * desc ; <S2SV_EndBug> unsigned long limit ; short sel ; sel = get_segment_selector ( regs , seg_reg_idx ) ; if ( sel < 0 ) return 0 ; if ( user_64bit_mode ( regs ) || v8086_mode ( regs ) ) return - 1L ; if ( ! sel ) return 0 ; <S2SV_StartBug> desc = get_desc ( sel ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! desc ) <S2SV_EndBug> return 0 ; <S2SV_StartBug> limit = get_desc_limit ( desc ) ; <S2SV_EndBug> <S2SV_StartBug> if ( desc -> g ) <S2SV_EndBug> limit = ( limit << 12 ) + 0xfff ; return limit ; }
static Image * ReadPWPImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { FILE * file ; Image * image , * next_image , * pwp_image ; ImageInfo * read_info ; int c , unique_file ; MagickBooleanType status ; register Image * p ; register ssize_t i ; size_t filesize , length ; ssize_t count ; unsigned char magick [ MagickPathExtent ] ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , "%s" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; pwp_image = AcquireImage ( image_info , exception ) ; image = pwp_image ; status = OpenBlob ( image_info , pwp_image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) return ( ( Image * ) NULL ) ; count = ReadBlob ( pwp_image , 5 , magick ) ; if ( ( count != 5 ) || ( LocaleNCompare ( ( char * ) magick , "SFW95" , 5 ) != 0 ) ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; read_info = CloneImageInfo ( image_info ) ; ( void ) SetImageInfoProgressMonitor ( read_info , ( MagickProgressMonitor ) NULL , ( void * ) NULL ) ; SetImageInfoBlob ( read_info , ( void * ) NULL , 0 ) ; unique_file = AcquireUniqueFileResource ( read_info -> filename ) ; for ( ; ; ) { for ( c = ReadBlobByte ( pwp_image ) ; c != EOF ; c = ReadBlobByte ( pwp_image ) ) { for ( i = 0 ; i < 17 ; i ++ ) magick [ i ] = magick [ i + 1 ] ; magick [ 17 ] = ( unsigned char ) c ; if ( LocaleNCompare ( ( char * ) ( magick + 12 ) , "SFW94A" , 6 ) == 0 ) break ; } if ( c == EOF ) break ; if ( LocaleNCompare ( ( char * ) ( magick + 12 ) , "SFW94A" , 6 ) != 0 ) { ( void ) RelinquishUniqueFileResource ( read_info -> filename ) ; ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; } file = ( FILE * ) NULL ; if ( unique_file != - 1 ) file = fdopen ( unique_file , "wb" ) ; if ( ( unique_file == - 1 ) || ( file == ( FILE * ) NULL ) ) { ( void ) RelinquishUniqueFileResource ( read_info -> filename ) ; ThrowFileException ( exception , FileOpenError , "UnableToWriteFile" , image -> filename ) ; image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } length = fwrite ( "SFW94A" , 1 , 6 , file ) ; ( void ) length ; filesize = 65535UL * magick [ 2 ] + 256L * magick [ 1 ] + magick [ 0 ] ; for ( i = 0 ; i < ( ssize_t ) filesize ; i ++ ) { c = ReadBlobByte ( pwp_image ) ; ( void ) fputc ( c , file ) ; } ( void ) fclose ( file ) ; next_image = ReadImage ( read_info , exception ) ; if ( next_image == ( Image * ) NULL ) break ; ( void ) FormatLocaleString ( next_image -> filename , MagickPathExtent , "slide_%02ld.sfw" , ( long ) next_image -> scene ) ; if ( image == ( Image * ) NULL ) image = next_image ; else { for ( p = image ; p -> next != ( Image * ) NULL ; p = GetNextImageInList ( p ) ) ; next_image -> previous = p ; next_image -> scene = p -> scene + 1 ; p -> next = next_image ; } if ( image_info -> number_scenes != 0 ) if ( next_image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( pwp_image ) , GetBlobSize ( pwp_image ) ) ; if ( status == MagickFalse ) break ; } if ( unique_file != - 1 ) ( void ) close ( unique_file ) ; ( void ) RelinquishUniqueFileResource ( read_info -> filename ) ; read_info = DestroyImageInfo ( read_info ) ; <S2SV_StartBug> ( void ) CloseBlob ( pwp_image ) ; <S2SV_EndBug> pwp_image = DestroyImage ( pwp_image ) ; if ( EOFBlob ( image ) != MagickFalse ) { char * message ; message = GetExceptionMessage ( errno ) ; ( void ) ThrowMagickException ( exception , GetMagickModule ( ) , CorruptImageError , "UnexpectedEndOfFile" , "`%s\':<S2SV_blank>%s" , image -> filename , message ) ; message = DestroyString ( message ) ; } ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
SPL_METHOD ( SplObjectStorage , unserialize ) { spl_SplObjectStorage * intern = Z_SPLOBJSTORAGE_P ( getThis ( ) ) ; char * buf ; size_t buf_len ; const unsigned char * p , * s ; php_unserialize_data_t var_hash ; zval entry , inf ; zval * pcount , * pmembers ; spl_SplObjectStorageElement * element ; zend_long count ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , "s" , & buf , & buf_len ) == FAILURE ) { return ; } if ( buf_len == 0 ) { return ; } s = p = ( const unsigned char * ) buf ; PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; if ( * p != 'x' || * ++ p != ':' ) { goto outexcept ; } ++ p ; pcount = var_tmp_var ( & var_hash ) ; if ( ! php_var_unserialize ( pcount , & p , s + buf_len , & var_hash ) || Z_TYPE_P ( pcount ) != IS_LONG ) { goto outexcept ; } -- p ; <S2SV_StartBug> count = Z_LVAL_P ( pcount ) ; <S2SV_EndBug> while ( count -- > 0 ) { spl_SplObjectStorageElement * pelement ; zend_string * hash ; if ( * p != ';' ) { goto outexcept ; } ++ p ; if ( * p != 'O' && * p != 'C' && * p != 'r' ) { goto outexcept ; } if ( ! php_var_unserialize ( & entry , & p , s + buf_len , & var_hash ) ) { goto outexcept ; } <S2SV_StartBug> if ( Z_TYPE ( entry ) != IS_OBJECT ) { <S2SV_EndBug> zval_ptr_dtor ( & entry ) ; goto outexcept ; } if ( * p == ',' ) { ++ p ; if ( ! php_var_unserialize ( & inf , & p , s + buf_len , & var_hash ) ) { zval_ptr_dtor ( & entry ) ; goto outexcept ; } <S2SV_StartBug> } else { <S2SV_EndBug> ZVAL_UNDEF ( & inf ) ; } hash = spl_object_storage_get_hash ( intern , getThis ( ) , & entry ) ; if ( ! hash ) { zval_ptr_dtor ( & entry ) ; zval_ptr_dtor ( & inf ) ; goto outexcept ; } pelement = spl_object_storage_get ( intern , hash ) ; spl_object_storage_free_hash ( intern , hash ) ; if ( pelement ) { if ( ! Z_ISUNDEF ( pelement -> inf ) ) { var_push_dtor ( & var_hash , & pelement -> inf ) ; } if ( ! Z_ISUNDEF ( pelement -> obj ) ) { var_push_dtor ( & var_hash , & pelement -> obj ) ; } } element = spl_object_storage_attach ( intern , getThis ( ) , & entry , Z_ISUNDEF ( inf ) ? NULL : & inf ) ; var_replace ( & var_hash , & entry , & element -> obj ) ; var_replace ( & var_hash , & inf , & element -> inf ) ; zval_ptr_dtor ( & entry ) ; ZVAL_UNDEF ( & entry ) ; zval_ptr_dtor ( & inf ) ; ZVAL_UNDEF ( & inf ) ; } if ( * p != ';' ) { goto outexcept ; } ++ p ; if ( * p != 'm' || * ++ p != ':' ) { goto outexcept ; } ++ p ; pmembers = var_tmp_var ( & var_hash ) ; if ( ! php_var_unserialize ( pmembers , & p , s + buf_len , & var_hash ) || Z_TYPE_P ( pmembers ) != IS_ARRAY ) { goto outexcept ; } object_properties_load ( & intern -> std , Z_ARRVAL_P ( pmembers ) ) ; PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; return ; outexcept : PHP_VAR_UNSERIALIZE_DESTROY ( var_hash ) ; zend_throw_exception_ex ( spl_ce_UnexpectedValueException , 0 , "Error<S2SV_blank>at<S2SV_blank>offset<S2SV_blank>%pd<S2SV_blank>of<S2SV_blank>%d<S2SV_blank>bytes" , ( zend_long ) ( ( char * ) p - buf ) , buf_len ) ; return ; }
static struct se_portal_group * vhost_scsi_make_tpg ( struct se_wwn * wwn , struct config_group * group , const char * name ) { struct vhost_scsi_tport * tport = container_of ( wwn , struct vhost_scsi_tport , tport_wwn ) ; struct vhost_scsi_tpg * tpg ; <S2SV_StartBug> unsigned long tpgt ; <S2SV_EndBug> int ret ; if ( strstr ( name , "tpgt_" ) != name ) return ERR_PTR ( - EINVAL ) ; <S2SV_StartBug> if ( kstrtoul ( name + 5 , 10 , & tpgt ) || tpgt > UINT_MAX ) <S2SV_EndBug> return ERR_PTR ( - EINVAL ) ; tpg = kzalloc ( sizeof ( struct vhost_scsi_tpg ) , GFP_KERNEL ) ; if ( ! tpg ) { pr_err ( "Unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>struct<S2SV_blank>vhost_scsi_tpg" ) ; return ERR_PTR ( - ENOMEM ) ; } mutex_init ( & tpg -> tv_tpg_mutex ) ; INIT_LIST_HEAD ( & tpg -> tv_tpg_list ) ; tpg -> tport = tport ; tpg -> tport_tpgt = tpgt ; ret = core_tpg_register ( & vhost_scsi_fabric_configfs -> tf_ops , wwn , & tpg -> se_tpg , tpg , TRANSPORT_TPG_TYPE_NORMAL ) ; if ( ret < 0 ) { kfree ( tpg ) ; return NULL ; } mutex_lock ( & vhost_scsi_mutex ) ; list_add_tail ( & tpg -> tv_tpg_list , & vhost_scsi_list ) ; mutex_unlock ( & vhost_scsi_mutex ) ; return & tpg -> se_tpg ; }
static <S2SV_StartBug> void headerMergeLegacySigs ( Header h , Header sigh ) <S2SV_EndBug> { HeaderIterator hi ; struct rpmtd_s td ; <S2SV_StartBug> hi = headerInitIterator ( sigh ) ; <S2SV_EndBug> for ( ; headerNext ( hi , & td ) ; rpmtdFreeData ( & td ) ) { switch ( td . tag ) { case RPMSIGTAG_SIZE : <S2SV_StartBug> td . tag = RPMTAG_SIGSIZE ; <S2SV_EndBug> break ; case RPMSIGTAG_PGP : <S2SV_StartBug> td . tag = RPMTAG_SIGPGP ; <S2SV_EndBug> break ; case RPMSIGTAG_MD5 : td . tag = RPMTAG_SIGMD5 ; break ; case RPMSIGTAG_GPG : td . tag = RPMTAG_SIGGPG ; break ; case RPMSIGTAG_PGP5 : td . tag = RPMTAG_SIGPGP5 ; break ; case RPMSIGTAG_PAYLOADSIZE : td . tag = RPMTAG_ARCHIVESIZE ; break ; case RPMSIGTAG_FILESIGNATURES : td . tag = RPMTAG_FILESIGNATURES ; break ; case RPMSIGTAG_FILESIGNATURELENGTH : td . tag = RPMTAG_FILESIGNATURELENGTH ; break ; case RPMSIGTAG_VERITYSIGNATURES : case RPMSIGTAG_VERITYSIGNATUREALGO : case RPMSIGTAG_SHA1 : case RPMSIGTAG_SHA256 : case RPMSIGTAG_DSA : case RPMSIGTAG_RSA : default : <S2SV_StartBug> if ( ! ( td . tag >= HEADER_SIGBASE && td . tag < HEADER_TAGBASE ) ) <S2SV_EndBug> continue ; break ; } <S2SV_StartBug> if ( ! headerIsEntry ( h , td . tag ) ) { <S2SV_EndBug> switch ( td . type ) { case RPM_NULL_TYPE : continue ; break ; case RPM_CHAR_TYPE : case RPM_INT8_TYPE : case RPM_INT16_TYPE : case RPM_INT32_TYPE : case RPM_INT64_TYPE : if ( td . count != 1 ) continue ; break ; case RPM_STRING_TYPE : case RPM_STRING_ARRAY_TYPE : case RPM_BIN_TYPE : if ( td . count >= 16 * 1024 ) continue ; break ; case RPM_I18NSTRING_TYPE : continue ; break ; } <S2SV_StartBug> ( void ) headerPut ( h , & td , HEADERPUT_DEFAULT ) ; <S2SV_EndBug> } } headerFreeIterator ( hi ) ; }
int xmlPushInput ( xmlParserCtxtPtr ctxt , xmlParserInputPtr input ) { int ret ; if ( input == NULL ) return ( - 1 ) ; if ( xmlParserDebugEntities ) { if ( ( ctxt -> input != NULL ) && ( ctxt -> input -> filename ) ) xmlGenericError ( xmlGenericErrorContext , "%s(%d):<S2SV_blank>" , ctxt -> input -> filename , ctxt -> input -> line ) ; xmlGenericError ( xmlGenericErrorContext , <S2SV_StartBug> "Pushing<S2SV_blank>input<S2SV_blank>%d<S2SV_blank>:<S2SV_blank>%.30s\\n" , ctxt -> inputNr + 1 , input -> cur ) ; <S2SV_EndBug> } ret = inputPush ( ctxt , input ) ; if ( ctxt -> instate == XML_PARSER_EOF ) return ( - 1 ) ; GROW ; return ( ret ) ; }
int ext4_orphan_add ( handle_t * handle , struct inode * inode ) { struct super_block * sb = inode -> i_sb ; struct ext4_iloc iloc ; int err = 0 , rc ; <S2SV_StartBug> if ( ! ext4_handle_valid ( handle ) ) <S2SV_EndBug> return 0 ; mutex_lock ( & EXT4_SB ( sb ) -> s_orphan_lock ) ; if ( ! list_empty ( & EXT4_I ( inode ) -> i_orphan ) ) goto out_unlock ; J_ASSERT ( ( S_ISREG ( inode -> i_mode ) || S_ISDIR ( inode -> i_mode ) || S_ISLNK ( inode -> i_mode ) ) || inode -> i_nlink == 0 ) ; BUFFER_TRACE ( EXT4_SB ( sb ) -> s_sbh , "get_write_access" ) ; err = ext4_journal_get_write_access ( handle , EXT4_SB ( sb ) -> s_sbh ) ; if ( err ) goto out_unlock ; err = ext4_reserve_inode_write ( handle , inode , & iloc ) ; if ( err ) goto out_unlock ; if ( NEXT_ORPHAN ( inode ) && NEXT_ORPHAN ( inode ) <= ( le32_to_cpu ( EXT4_SB ( sb ) -> s_es -> s_inodes_count ) ) ) goto mem_insert ; NEXT_ORPHAN ( inode ) = le32_to_cpu ( EXT4_SB ( sb ) -> s_es -> s_last_orphan ) ; EXT4_SB ( sb ) -> s_es -> s_last_orphan = cpu_to_le32 ( inode -> i_ino ) ; err = ext4_handle_dirty_super ( handle , sb ) ; rc = ext4_mark_iloc_dirty ( handle , inode , & iloc ) ; if ( ! err ) err = rc ; mem_insert : if ( ! err ) list_add ( & EXT4_I ( inode ) -> i_orphan , & EXT4_SB ( sb ) -> s_orphan ) ; jbd_debug ( 4 , "superblock<S2SV_blank>will<S2SV_blank>point<S2SV_blank>to<S2SV_blank>%lu\\n" , inode -> i_ino ) ; jbd_debug ( 4 , "orphan<S2SV_blank>inode<S2SV_blank>%lu<S2SV_blank>will<S2SV_blank>point<S2SV_blank>to<S2SV_blank>%d\\n" , inode -> i_ino , NEXT_ORPHAN ( inode ) ) ; out_unlock : mutex_unlock ( & EXT4_SB ( sb ) -> s_orphan_lock ) ; ext4_std_error ( inode -> i_sb , err ) ; return err ; }
static const u_char * ikev2_auth_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct ikev2_auth a ; const char * v2_auth [ ] = { "invalid" , "rsasig" , "shared-secret" , "dsssig" } ; const u_char * authdata = ( const u_char * ) ext + sizeof ( a ) ; unsigned int len ; <S2SV_StartBug> ND_TCHECK ( * ext ) ; <S2SV_EndBug> UNALIGNED_MEMCPY ( & a , ext , sizeof ( a ) ) ; ikev2_pay_print ( ndo , NPSTR ( tpay ) , a . h . critical ) ; len = ntohs ( a . h . len ) ; ND_PRINT ( ( ndo , "<S2SV_blank>len=%u<S2SV_blank>method=%s" , len - 4 , STR_OR_ID ( a . auth_method , v2_auth ) ) ) ; if ( len > 4 ) { if ( ndo -> ndo_vflag > 1 ) { ND_PRINT ( ( ndo , "<S2SV_blank>authdata=(" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) authdata , len - sizeof ( a ) ) ) goto trunc ; ND_PRINT ( ( ndo , ")<S2SV_blank>" ) ) ; } else if ( ndo -> ndo_vflag ) { if ( ! ike_show_somedata ( ndo , authdata , ep ) ) goto trunc ; } } return ( const u_char * ) ext + len ; trunc : ND_PRINT ( ( ndo , "<S2SV_blank>[|%s]" , NPSTR ( tpay ) ) ) ; return NULL ; }
static int dcbnl_getperm_hwaddr ( struct net_device * netdev , struct nlmsghdr * nlh , u32 seq , struct nlattr * * tb , struct sk_buff * skb ) { u8 perm_addr [ MAX_ADDR_LEN ] ; if ( ! netdev -> dcbnl_ops -> getpermhwaddr ) return - EOPNOTSUPP ; <S2SV_StartBug> netdev -> dcbnl_ops -> getpermhwaddr ( netdev , perm_addr ) ; <S2SV_EndBug> return nla_put ( skb , DCB_ATTR_PERM_HWADDR , sizeof ( perm_addr ) , perm_addr ) ; }
static int nfs_can_extend_write ( struct file * file , struct page * page , struct inode * inode ) { if ( file -> f_flags & O_DSYNC ) return 0 ; <S2SV_StartBug> if ( NFS_PROTO ( inode ) -> have_delegation ( inode , FMODE_WRITE ) ) <S2SV_EndBug> return 1 ; <S2SV_StartBug> if ( nfs_write_pageuptodate ( page , inode ) && ( inode -> i_flock == NULL || <S2SV_EndBug> ( inode -> i_flock -> fl_start == 0 && inode -> i_flock -> fl_end == OFFSET_MAX && <S2SV_StartBug> inode -> i_flock -> fl_type != F_RDLCK ) ) ) <S2SV_EndBug> return 1 ; return 0 ; }
static int ext4_convert_unwritten_extents_endio ( handle_t * handle , struct inode * inode , <S2SV_StartBug> struct ext4_ext_path * path ) <S2SV_EndBug> { <S2SV_StartBug> struct ext4_extent * ex ; <S2SV_EndBug> int depth ; int err = 0 ; depth = ext_depth ( inode ) ; ex = path [ depth ] . p_ext ; <S2SV_StartBug> ext_debug ( "ext4_convert_unwritten_extents_endio:<S2SV_blank>inode<S2SV_blank>%lu,<S2SV_blank>logical" <S2SV_EndBug> "block<S2SV_blank>%llu,<S2SV_blank>max_blocks<S2SV_blank>%u\\n" , inode -> i_ino , <S2SV_StartBug> ( unsigned long long ) le32_to_cpu ( ex -> ee_block ) , <S2SV_EndBug> ext4_ext_get_actual_len ( ex ) ) ; err = ext4_ext_get_access ( handle , inode , path + depth ) ; if ( err ) goto out ; ext4_ext_mark_initialized ( ex ) ; ext4_ext_try_to_merge ( handle , inode , path , ex ) ; err = ext4_ext_dirty ( handle , inode , path + path -> p_depth ) ; out : ext4_ext_show_leaf ( inode , path ) ; return err ; }
static int host_start ( struct ci13xxx * ci ) { struct usb_hcd * hcd ; struct ehci_hcd * ehci ; int ret ; if ( usb_disabled ( ) ) return - ENODEV ; hcd = usb_create_hcd ( & ci_ehci_hc_driver , ci -> dev , dev_name ( ci -> dev ) ) ; if ( ! hcd ) return - ENOMEM ; dev_set_drvdata ( ci -> dev , ci ) ; hcd -> rsrc_start = ci -> hw_bank . phys ; hcd -> rsrc_len = ci -> hw_bank . size ; hcd -> regs = ci -> hw_bank . abs ; hcd -> has_tt = 1 ; hcd -> power_budget = ci -> platdata -> power_budget ; hcd -> phy = ci -> transceiver ; ehci = hcd_to_ehci ( hcd ) ; ehci -> caps = ci -> hw_bank . cap ; ehci -> has_hostpc = ci -> hw_bank . lpm ; ret = usb_add_hcd ( hcd , 0 , 0 ) ; if ( ret ) usb_put_hcd ( hcd ) ; else ci -> hcd = hcd ; <S2SV_StartBug> return ret ; <S2SV_EndBug> }
int udpv6_recvmsg ( struct sock * sk , struct msghdr * msg , size_t len , int noblock , int flags , int * addr_len ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct inet_sock * inet = inet_sk ( sk ) ; struct sk_buff * skb ; unsigned int ulen , copied ; int peeked , off = 0 ; int err ; int is_udplite = IS_UDPLITE ( sk ) ; int is_udp4 ; bool slow ; if ( flags & MSG_ERRQUEUE ) return ipv6_recv_error ( sk , msg , len , addr_len ) ; if ( np -> rxpmtu && np -> rxopt . bits . rxpmtu ) return ipv6_recv_rxpmtu ( sk , msg , len , addr_len ) ; try_again : skb = __skb_recv_datagram ( sk , flags | ( noblock ? MSG_DONTWAIT : 0 ) , & peeked , & off , & err ) ; if ( ! skb ) goto out ; ulen = skb -> len - sizeof ( struct udphdr ) ; copied = len ; if ( copied > ulen ) copied = ulen ; else if ( copied < ulen ) msg -> msg_flags |= MSG_TRUNC ; is_udp4 = ( skb -> protocol == htons ( ETH_P_IP ) ) ; if ( copied < ulen || UDP_SKB_CB ( skb ) -> partial_cov ) { if ( udp_lib_checksum_complete ( skb ) ) goto csum_copy_err ; } if ( skb_csum_unnecessary ( skb ) ) err = skb_copy_datagram_msg ( skb , sizeof ( struct udphdr ) , msg , copied ) ; else { err = skb_copy_and_csum_datagram_msg ( skb , sizeof ( struct udphdr ) , msg ) ; if ( err == - EINVAL ) goto csum_copy_err ; } if ( unlikely ( err ) ) { trace_kfree_skb ( skb , udpv6_recvmsg ) ; if ( ! peeked ) { atomic_inc ( & sk -> sk_drops ) ; if ( is_udp4 ) UDP_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INERRORS , is_udplite ) ; else UDP6_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INERRORS , is_udplite ) ; } goto out_free ; } if ( ! peeked ) { if ( is_udp4 ) UDP_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INDATAGRAMS , is_udplite ) ; else UDP6_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INDATAGRAMS , is_udplite ) ; } sock_recv_ts_and_drops ( msg , sk , skb ) ; if ( msg -> msg_name ) { DECLARE_SOCKADDR ( struct sockaddr_in6 * , sin6 , msg -> msg_name ) ; sin6 -> sin6_family = AF_INET6 ; sin6 -> sin6_port = udp_hdr ( skb ) -> source ; sin6 -> sin6_flowinfo = 0 ; if ( is_udp4 ) { ipv6_addr_set_v4mapped ( ip_hdr ( skb ) -> saddr , & sin6 -> sin6_addr ) ; sin6 -> sin6_scope_id = 0 ; } else { sin6 -> sin6_addr = ipv6_hdr ( skb ) -> saddr ; sin6 -> sin6_scope_id = ipv6_iface_scope_id ( & sin6 -> sin6_addr , inet6_iif ( skb ) ) ; } * addr_len = sizeof ( * sin6 ) ; } if ( np -> rxopt . all ) ip6_datagram_recv_common_ctl ( sk , msg , skb ) ; if ( is_udp4 ) { if ( inet -> cmsg_flags ) ip_cmsg_recv ( msg , skb ) ; } else { if ( np -> rxopt . all ) ip6_datagram_recv_specific_ctl ( sk , msg , skb ) ; } err = copied ; if ( flags & MSG_TRUNC ) err = ulen ; out_free : skb_free_datagram_locked ( sk , skb ) ; out : return err ; csum_copy_err : slow = lock_sock_fast ( sk ) ; if ( ! skb_kill_datagram ( sk , skb , flags ) ) { if ( is_udp4 ) { UDP_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_CSUMERRORS , is_udplite ) ; UDP_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INERRORS , is_udplite ) ; } else { UDP6_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_CSUMERRORS , is_udplite ) ; UDP6_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB_INERRORS , is_udplite ) ; } } unlock_sock_fast ( sk , slow ) ; <S2SV_StartBug> if ( noblock ) <S2SV_EndBug> return - EAGAIN ; msg -> msg_flags &= ~ MSG_TRUNC ; goto try_again ; }
static void fifo_open ( notify_fifo_t * fifo , int ( * script_exit ) ( thread_t * ) , const char * type ) { int ret ; int sav_errno ; if ( fifo -> name ) { sav_errno = 0 ; if ( ! ( ret = mkfifo ( fifo -> name , S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH ) ) ) fifo -> created_fifo = true ; else { sav_errno = errno ; if ( sav_errno != EEXIST ) log_message ( LOG_INFO , "Unable<S2SV_blank>to<S2SV_blank>create<S2SV_blank>%snotify<S2SV_blank>fifo<S2SV_blank>%s" , type , fifo -> name ) ; } if ( ! sav_errno || sav_errno == EEXIST ) { if ( fifo -> script ) notify_fifo_exec ( master , script_exit , fifo , fifo -> script ) ; <S2SV_StartBug> if ( ( fifo -> fd = open ( fifo -> name , O_RDWR | O_CLOEXEC | O_NONBLOCK ) ) == - 1 ) { <S2SV_EndBug> log_message ( LOG_INFO , "Unable<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%snotify<S2SV_blank>fifo<S2SV_blank>%s<S2SV_blank>-<S2SV_blank>errno<S2SV_blank>%d" , type , fifo -> name , errno ) ; if ( fifo -> created_fifo ) { unlink ( fifo -> name ) ; fifo -> created_fifo = false ; } } } if ( fifo -> fd == - 1 ) { FREE ( fifo -> name ) ; fifo -> name = NULL ; } } }
int create_flush_cmd_control ( struct f2fs_sb_info * sbi ) { dev_t dev = sbi -> sb -> s_bdev -> bd_dev ; struct flush_cmd_control * fcc ; int err = 0 ; if ( SM_I ( sbi ) -> fcc_info ) { fcc = SM_I ( sbi ) -> fcc_info ; goto init_thread ; } fcc = kzalloc ( sizeof ( struct flush_cmd_control ) , GFP_KERNEL ) ; if ( ! fcc ) return - ENOMEM ; atomic_set ( & fcc -> issued_flush , 0 ) ; atomic_set ( & fcc -> issing_flush , 0 ) ; init_waitqueue_head ( & fcc -> flush_wait_queue ) ; init_llist_head ( & fcc -> issue_list ) ; SM_I ( sbi ) -> fcc_info = fcc ; <S2SV_StartBug> init_thread : <S2SV_EndBug> fcc -> f2fs_issue_flush = kthread_run ( issue_flush_thread , sbi , "f2fs_flush-%u:%u" , MAJOR ( dev ) , MINOR ( dev ) ) ; if ( IS_ERR ( fcc -> f2fs_issue_flush ) ) { err = PTR_ERR ( fcc -> f2fs_issue_flush ) ; kfree ( fcc ) ; SM_I ( sbi ) -> fcc_info = NULL ; return err ; } return err ; }
void ion_free ( struct ion_client * client , struct ion_handle * handle ) { <S2SV_StartBug> bool valid_handle ; <S2SV_EndBug> BUG_ON ( client != handle -> client ) ; mutex_lock ( & client -> lock ) ; <S2SV_StartBug> valid_handle = ion_handle_validate ( client , handle ) ; <S2SV_EndBug> if ( ! valid_handle ) { WARN ( 1 , "%s:<S2SV_blank>invalid<S2SV_blank>handle<S2SV_blank>passed<S2SV_blank>to<S2SV_blank>free.\\n" , __func__ ) ; mutex_unlock ( & client -> lock ) ; <S2SV_StartBug> return ; <S2SV_EndBug> } mutex_unlock ( & client -> lock ) ; ion_handle_put ( handle ) ; }
void __detach_mounts ( struct dentry * dentry ) { struct mountpoint * mp ; struct mount * mnt ; namespace_lock ( ) ; mp = lookup_mountpoint ( dentry ) ; if ( IS_ERR_OR_NULL ( mp ) ) goto out_unlock ; lock_mount_hash ( ) ; while ( ! hlist_empty ( & mp -> m_list ) ) { mnt = hlist_entry ( mp -> m_list . first , struct mount , mnt_mp_list ) ; if ( mnt -> mnt . mnt_flags & MNT_UMOUNT ) { struct mount * p , * tmp ; list_for_each_entry_safe ( p , tmp , & mnt -> mnt_mounts , mnt_child ) { hlist_add_head ( & p -> mnt_umount . s_list , & unmounted ) ; umount_mnt ( p ) ; } } <S2SV_StartBug> else umount_tree ( mnt , 0 ) ; <S2SV_EndBug> } unlock_mount_hash ( ) ; put_mountpoint ( mp ) ; out_unlock : namespace_unlock ( ) ; }
static int decode_studio_vop_header ( Mpeg4DecContext * ctx , GetBitContext * gb ) { MpegEncContext * s = & ctx -> m ; if ( get_bits_left ( gb ) <= 32 ) return 0 ; s -> partitioned_frame = 0 ; <S2SV_StartBug> s -> decode_mb = mpeg4_decode_studio_mb ; <S2SV_EndBug> decode_smpte_tc ( ctx , gb ) ; skip_bits ( gb , 10 ) ; skip_bits ( gb , 2 ) ; s -> pict_type = get_bits ( gb , 2 ) + AV_PICTURE_TYPE_I ; if ( get_bits1 ( gb ) ) { skip_bits1 ( gb ) ; skip_bits1 ( gb ) ; s -> progressive_frame = get_bits1 ( gb ) ^ 1 ; } if ( s -> pict_type == AV_PICTURE_TYPE_I ) { if ( get_bits1 ( gb ) ) reset_studio_dc_predictors ( s ) ; } if ( ctx -> shape != BIN_ONLY_SHAPE ) { s -> alternate_scan = get_bits1 ( gb ) ; s -> frame_pred_frame_dct = get_bits1 ( gb ) ; s -> dct_precision = get_bits ( gb , 2 ) ; s -> intra_dc_precision = get_bits ( gb , 2 ) ; s -> q_scale_type = get_bits1 ( gb ) ; } if ( s -> alternate_scan ) { ff_init_scantable ( s -> idsp . idct_permutation , & s -> inter_scantable , ff_alternate_vertical_scan ) ; ff_init_scantable ( s -> idsp . idct_permutation , & s -> intra_scantable , ff_alternate_vertical_scan ) ; ff_init_scantable ( s -> idsp . idct_permutation , & s -> intra_h_scantable , ff_alternate_vertical_scan ) ; ff_init_scantable ( s -> idsp . idct_permutation , & s -> intra_v_scantable , ff_alternate_vertical_scan ) ; } else { ff_init_scantable ( s -> idsp . idct_permutation , & s -> inter_scantable , ff_zigzag_direct ) ; ff_init_scantable ( s -> idsp . idct_permutation , & s -> intra_scantable , ff_zigzag_direct ) ; ff_init_scantable ( s -> idsp . idct_permutation , & s -> intra_h_scantable , ff_alternate_horizontal_scan ) ; ff_init_scantable ( s -> idsp . idct_permutation , & s -> intra_v_scantable , ff_alternate_vertical_scan ) ; } mpeg4_load_default_matrices ( s ) ; next_start_code_studio ( gb ) ; extension_and_user_data ( s , gb , 4 ) ; return 0 ; }
uint32_t virtio_config_readl ( VirtIODevice * vdev , uint32_t addr ) { VirtioDeviceClass * k = VIRTIO_DEVICE_GET_CLASS ( vdev ) ; uint32_t val ; <S2SV_StartBug> k -> get_config ( vdev , vdev -> config ) ; <S2SV_EndBug> if ( addr > ( vdev -> config_len - sizeof ( val ) ) ) return ( uint32_t ) - 1 ; val = ldl_p ( vdev -> config + addr ) ; return val ; }
<S2SV_StartBug> static void encode_frame ( vpx_codec_ctx_t * ctx , <S2SV_EndBug> const vpx_image_t * img , vpx_codec_pts_t pts , unsigned int duration , vpx_enc_frame_flags_t flags , unsigned int deadline , <S2SV_StartBug> VpxVideoWriter * writer ) { <S2SV_EndBug> vpx_codec_iter_t iter = NULL ; const vpx_codec_cx_pkt_t * pkt = NULL ; const vpx_codec_err_t res = vpx_codec_encode ( ctx , img , pts , duration , flags , deadline ) ; if ( res != VPX_CODEC_OK ) die_codec ( ctx , "Failed<S2SV_blank>to<S2SV_blank>encode<S2SV_blank>frame." ) ; <S2SV_StartBug> while ( ( pkt = vpx_codec_get_cx_data ( ctx , & iter ) ) != NULL ) { <S2SV_EndBug> if ( pkt -> kind == VPX_CODEC_CX_FRAME_PKT ) { const int keyframe = ( pkt -> data . frame . flags & VPX_FRAME_IS_KEY ) != 0 ; if ( ! vpx_video_writer_write_frame ( writer , pkt -> data . frame . buf , pkt -> data . frame . sz , pkt -> data . frame . pts ) ) die_codec ( ctx , "Failed<S2SV_blank>to<S2SV_blank>write<S2SV_blank>compressed<S2SV_blank>frame." ) ; printf ( keyframe ? "K" : "." ) ; fflush ( stdout ) ; } } <S2SV_StartBug> } <S2SV_EndBug>
<S2SV_StartBug> static double calc_frame_boost ( VP9_COMP * cpi , FIRSTPASS_STATS * this_frame , <S2SV_EndBug> <S2SV_StartBug> double this_frame_mv_in_out ) { <S2SV_EndBug> double frame_boost ; <S2SV_StartBug> if ( this_frame -> intra_error > cpi -> twopass . gf_intra_err_min ) <S2SV_EndBug> <S2SV_StartBug> frame_boost = ( IIFACTOR * this_frame -> intra_error / <S2SV_EndBug> <S2SV_StartBug> DOUBLE_DIVIDE_CHECK ( this_frame -> coded_error ) ) ; <S2SV_EndBug> else frame_boost = ( IIFACTOR * cpi -> twopass . gf_intra_err_min / DOUBLE_DIVIDE_CHECK ( this_frame -> coded_error ) ) ; if ( this_frame_mv_in_out > 0.0 ) frame_boost += frame_boost * ( this_frame_mv_in_out * 2.0 ) ; else frame_boost += frame_boost * ( this_frame_mv_in_out / 2.0 ) ; <S2SV_StartBug> return MIN ( frame_boost , GF_RMAX ) ; <S2SV_EndBug> }
<S2SV_StartBug> static void __update_open_stateid ( struct nfs4_state * state , nfs4_stateid * open_stateid , const nfs4_stateid * deleg_stateid , int open_flags ) <S2SV_EndBug> { write_seqlock ( & state -> seqlock ) ; if ( deleg_stateid != NULL ) { memcpy ( state -> stateid . data , deleg_stateid -> data , sizeof ( state -> stateid . data ) ) ; set_bit ( NFS_DELEGATED_STATE , & state -> flags ) ; } if ( open_stateid != NULL ) <S2SV_StartBug> nfs_set_open_stateid_locked ( state , open_stateid , open_flags ) ; <S2SV_EndBug> write_sequnlock ( & state -> seqlock ) ; spin_lock ( & state -> owner -> so_lock ) ; <S2SV_StartBug> update_open_stateflags ( state , open_flags ) ; <S2SV_EndBug> spin_unlock ( & state -> owner -> so_lock ) ; }
PHP_FUNCTION ( imagegammacorrect ) { zval * IM ; gdImagePtr im ; int i ; double input , output ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , "rdd" , & IM , & input , & output ) == FAILURE ) { return ; } <S2SV_StartBug> ZEND_FETCH_RESOURCE ( im , gdImagePtr , & IM , - 1 , "Image" , le_gd ) ; <S2SV_EndBug> if ( gdImageTrueColor ( im ) ) { int x , y , c ; for ( y = 0 ; y < gdImageSY ( im ) ; y ++ ) { for ( x = 0 ; x < gdImageSX ( im ) ; x ++ ) { c = gdImageGetPixel ( im , x , y ) ; gdImageSetPixel ( im , x , y , gdTrueColorAlpha ( ( int ) ( ( pow ( ( pow ( ( gdTrueColorGetRed ( c ) / 255.0 ) , input ) ) , 1.0 / output ) * 255 ) + .5 ) , ( int ) ( ( pow ( ( pow ( ( gdTrueColorGetGreen ( c ) / 255.0 ) , input ) ) , 1.0 / output ) * 255 ) + .5 ) , ( int ) ( ( pow ( ( pow ( ( gdTrueColorGetBlue ( c ) / 255.0 ) , input ) ) , 1.0 / output ) * 255 ) + .5 ) , gdTrueColorGetAlpha ( c ) ) ) ; } } RETURN_TRUE ; } for ( i = 0 ; i < gdImageColorsTotal ( im ) ; i ++ ) { im -> red [ i ] = ( int ) ( ( pow ( ( pow ( ( im -> red [ i ] / 255.0 ) , input ) ) , 1.0 / output ) * 255 ) + .5 ) ; im -> green [ i ] = ( int ) ( ( pow ( ( pow ( ( im -> green [ i ] / 255.0 ) , input ) ) , 1.0 / output ) * 255 ) + .5 ) ; im -> blue [ i ] = ( int ) ( ( pow ( ( pow ( ( im -> blue [ i ] / 255.0 ) , input ) ) , 1.0 / output ) * 255 ) + .5 ) ; } RETURN_TRUE ; }
int cdf_read_property_info ( const cdf_stream_t * sst , const cdf_header_t * h , uint32_t offs , cdf_property_info_t * * info , size_t * count , size_t * maxcount ) { const cdf_section_header_t * shp ; cdf_section_header_t sh ; const uint8_t * p , * q , * e ; int16_t s16 ; int32_t s32 ; uint32_t u32 ; int64_t s64 ; uint64_t u64 ; cdf_timestamp_t tp ; size_t i , o , o4 , nelements , j ; cdf_property_info_t * inp ; if ( offs > UINT32_MAX / 4 ) { errno = EFTYPE ; goto out ; } shp = CAST ( const cdf_section_header_t * , ( const void * ) ( ( const char * ) sst -> sst_tab + offs ) ) ; if ( cdf_check_stream_offset ( sst , h , shp , sizeof ( * shp ) , __LINE__ ) == - 1 ) goto out ; sh . sh_len = CDF_TOLE4 ( shp -> sh_len ) ; # define CDF_SHLEN_LIMIT ( UINT32_MAX / 8 ) if ( sh . sh_len > CDF_SHLEN_LIMIT ) { errno = EFTYPE ; goto out ; } sh . sh_properties = CDF_TOLE4 ( shp -> sh_properties ) ; # define CDF_PROP_LIMIT ( UINT32_MAX / ( 4 * sizeof ( * inp ) ) ) if ( sh . sh_properties > CDF_PROP_LIMIT ) goto out ; DPRINTF ( ( "section<S2SV_blank>len:<S2SV_blank>%u<S2SV_blank>properties<S2SV_blank>%u\\n" , sh . sh_len , sh . sh_properties ) ) ; if ( * maxcount ) { if ( * maxcount > CDF_PROP_LIMIT ) goto out ; * maxcount += sh . sh_properties ; inp = CAST ( cdf_property_info_t * , realloc ( * info , * maxcount * sizeof ( * inp ) ) ) ; } else { * maxcount = sh . sh_properties ; inp = CAST ( cdf_property_info_t * , malloc ( * maxcount * sizeof ( * inp ) ) ) ; } if ( inp == NULL ) goto out ; * info = inp ; inp += * count ; * count += sh . sh_properties ; p = CAST ( const uint8_t * , ( const void * ) ( ( const char * ) ( const void * ) sst -> sst_tab + offs + sizeof ( sh ) ) ) ; e = CAST ( const uint8_t * , ( const void * ) ( ( ( const char * ) ( const void * ) shp ) + sh . sh_len ) ) ; if ( cdf_check_stream_offset ( sst , h , e , 0 , __LINE__ ) == - 1 ) goto out ; for ( i = 0 ; i < sh . sh_properties ; i ++ ) { <S2SV_StartBug> q = ( const uint8_t * ) ( const void * ) <S2SV_EndBug> ( ( const char * ) ( const void * ) p + <S2SV_StartBug> CDF_GETUINT32 ( p , ( i << 1 ) + 1 ) ) - 2 * sizeof ( uint32_t ) ; <S2SV_EndBug> if ( q > e ) { DPRINTF ( ( "Ran<S2SV_blank>of<S2SV_blank>the<S2SV_blank>end<S2SV_blank>%p<S2SV_blank>><S2SV_blank>%p\\n" , q , e ) ) ; goto out ; } inp [ i ] . pi_id = CDF_GETUINT32 ( p , i << 1 ) ; inp [ i ] . pi_type = CDF_GETUINT32 ( q , 0 ) ; <S2SV_StartBug> DPRINTF ( ( "%" SIZE_T_FORMAT "u)<S2SV_blank>id=%x<S2SV_blank>type=%x<S2SV_blank>offs=0x%tx,0x%x\\n" , i , <S2SV_EndBug> inp [ i ] . pi_id , inp [ i ] . pi_type , q - p , <S2SV_StartBug> CDF_GETUINT32 ( p , ( i << 1 ) + 1 ) ) ) ; <S2SV_EndBug> if ( inp [ i ] . pi_type & CDF_VECTOR ) { nelements = CDF_GETUINT32 ( q , 1 ) ; o = 2 ; } else { nelements = 1 ; o = 1 ; } o4 = o * sizeof ( uint32_t ) ; if ( inp [ i ] . pi_type & ( CDF_ARRAY | CDF_BYREF | CDF_RESERVED ) ) goto unknown ; switch ( inp [ i ] . pi_type & CDF_TYPEMASK ) { case CDF_NULL : case CDF_EMPTY : break ; case CDF_SIGNED16 : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & s16 , & q [ o4 ] , sizeof ( s16 ) ) ; inp [ i ] . pi_s16 = CDF_TOLE2 ( s16 ) ; break ; case CDF_SIGNED32 : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & s32 , & q [ o4 ] , sizeof ( s32 ) ) ; inp [ i ] . pi_s32 = CDF_TOLE4 ( ( uint32_t ) s32 ) ; break ; case CDF_BOOL : case CDF_UNSIGNED32 : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & u32 , & q [ o4 ] , sizeof ( u32 ) ) ; inp [ i ] . pi_u32 = CDF_TOLE4 ( u32 ) ; break ; case CDF_SIGNED64 : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & s64 , & q [ o4 ] , sizeof ( s64 ) ) ; inp [ i ] . pi_s64 = CDF_TOLE8 ( ( uint64_t ) s64 ) ; break ; case CDF_UNSIGNED64 : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & u64 , & q [ o4 ] , sizeof ( u64 ) ) ; inp [ i ] . pi_u64 = CDF_TOLE8 ( ( uint64_t ) u64 ) ; break ; case CDF_FLOAT : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & u32 , & q [ o4 ] , sizeof ( u32 ) ) ; u32 = CDF_TOLE4 ( u32 ) ; memcpy ( & inp [ i ] . pi_f , & u32 , sizeof ( inp [ i ] . pi_f ) ) ; break ; case CDF_DOUBLE : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & u64 , & q [ o4 ] , sizeof ( u64 ) ) ; u64 = CDF_TOLE8 ( ( uint64_t ) u64 ) ; memcpy ( & inp [ i ] . pi_d , & u64 , sizeof ( inp [ i ] . pi_d ) ) ; break ; case CDF_LENGTH32_STRING : case CDF_LENGTH32_WSTRING : if ( nelements > 1 ) { size_t nelem = inp - * info ; if ( * maxcount > CDF_PROP_LIMIT || nelements > CDF_PROP_LIMIT ) goto out ; * maxcount += nelements ; inp = CAST ( cdf_property_info_t * , realloc ( * info , * maxcount * sizeof ( * inp ) ) ) ; if ( inp == NULL ) goto out ; * info = inp ; inp = * info + nelem ; } DPRINTF ( ( "nelements<S2SV_blank>=<S2SV_blank>%" SIZE_T_FORMAT "u\\n" , nelements ) ) ; for ( j = 0 ; j < nelements ; j ++ , i ++ ) { uint32_t l = CDF_GETUINT32 ( q , o ) ; inp [ i ] . pi_str . s_len = l ; inp [ i ] . pi_str . s_buf = ( const char * ) ( const void * ) ( & q [ o4 + sizeof ( l ) ] ) ; DPRINTF ( ( "l<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>r<S2SV_blank>=<S2SV_blank>%" SIZE_T_FORMAT "u,<S2SV_blank>s<S2SV_blank>=<S2SV_blank>%s\\n" , l , CDF_ROUND ( l , sizeof ( l ) ) , inp [ i ] . pi_str . s_buf ) ) ; if ( l & 1 ) l ++ ; o += l >> 1 ; if ( q + o >= e ) goto out ; o4 = o * sizeof ( uint32_t ) ; } i -- ; break ; case CDF_FILETIME : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; ( void ) memcpy ( & tp , & q [ o4 ] , sizeof ( tp ) ) ; inp [ i ] . pi_tp = CDF_TOLE8 ( ( uint64_t ) tp ) ; break ; case CDF_CLIPBOARD : if ( inp [ i ] . pi_type & CDF_VECTOR ) goto unknown ; break ; default : unknown : DPRINTF ( ( "Don\'t<S2SV_blank>know<S2SV_blank>how<S2SV_blank>to<S2SV_blank>deal<S2SV_blank>with<S2SV_blank>%x\\n" , inp [ i ] . pi_type ) ) ; break ; } } return 0 ; out : free ( * info ) ; return - 1 ; }
SEL * selReadStream ( FILE * fp ) { char * selname ; <S2SV_StartBug> char linebuf [ L_BUF_SIZE ] ; <S2SV_EndBug> l_int32 sy , sx , cy , cx , i , j , version , ignore ; SEL * sel ; PROCNAME ( "selReadStream" ) ; if ( ! fp ) return ( SEL * ) ERROR_PTR ( "stream<S2SV_blank>not<S2SV_blank>defined" , procName , NULL ) ; if ( fscanf ( fp , "<S2SV_blank><S2SV_blank>Sel<S2SV_blank>Version<S2SV_blank>%d\\n" , & version ) != 1 ) return ( SEL * ) ERROR_PTR ( "not<S2SV_blank>a<S2SV_blank>sel<S2SV_blank>file" , procName , NULL ) ; if ( version != SEL_VERSION_NUMBER ) return ( SEL * ) ERROR_PTR ( "invalid<S2SV_blank>sel<S2SV_blank>version" , procName , NULL ) ; <S2SV_StartBug> if ( fgets ( linebuf , L_BUF_SIZE , fp ) == NULL ) <S2SV_EndBug> return ( SEL * ) ERROR_PTR ( "error<S2SV_blank>reading<S2SV_blank>into<S2SV_blank>linebuf" , procName , NULL ) ; selname = stringNew ( linebuf ) ; <S2SV_StartBug> sscanf ( linebuf , "<S2SV_blank><S2SV_blank>------<S2SV_blank><S2SV_blank>%s<S2SV_blank><S2SV_blank>------" , selname ) ; <S2SV_EndBug> if ( fscanf ( fp , "<S2SV_blank><S2SV_blank>sy<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>sx<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>cy<S2SV_blank>=<S2SV_blank>%d,<S2SV_blank>cx<S2SV_blank>=<S2SV_blank>%d\\n" , & sy , & sx , & cy , & cx ) != 4 ) { LEPT_FREE ( selname ) ; return ( SEL * ) ERROR_PTR ( "dimensions<S2SV_blank>not<S2SV_blank>read" , procName , NULL ) ; } if ( ( sel = selCreate ( sy , sx , selname ) ) == NULL ) { LEPT_FREE ( selname ) ; return ( SEL * ) ERROR_PTR ( "sel<S2SV_blank>not<S2SV_blank>made" , procName , NULL ) ; } selSetOrigin ( sel , cy , cx ) ; for ( i = 0 ; i < sy ; i ++ ) { ignore = fscanf ( fp , "<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>" ) ; for ( j = 0 ; j < sx ; j ++ ) ignore = fscanf ( fp , "%1d" , & sel -> data [ i ] [ j ] ) ; ignore = fscanf ( fp , "\\n" ) ; } ignore = fscanf ( fp , "\\n" ) ; LEPT_FREE ( selname ) ; return sel ; }
void xenvif_disconnect ( struct xenvif * vif ) { <S2SV_StartBug> struct net_device * dev = vif -> dev ; <S2SV_EndBug> <S2SV_StartBug> if ( netif_carrier_ok ( dev ) ) { <S2SV_EndBug> rtnl_lock ( ) ; netif_carrier_off ( dev ) ; if ( netif_running ( dev ) ) <S2SV_StartBug> xenvif_down ( vif ) ; <S2SV_EndBug> <S2SV_StartBug> rtnl_unlock ( ) ; <S2SV_EndBug> xenvif_put ( vif ) ; } atomic_dec ( & vif -> refcnt ) ; wait_event ( vif -> waiting_to_free , atomic_read ( & vif -> refcnt ) == 0 ) ; del_timer_sync ( & vif -> credit_timeout ) ; if ( vif -> irq ) unbind_from_irqhandler ( vif -> irq , vif ) ; unregister_netdev ( vif -> dev ) ; xen_netbk_unmap_frontend_rings ( vif ) ; free_netdev ( vif -> dev ) ; }
<S2SV_StartBug> static u32 __ipv6_select_ident ( struct net * net , u32 hashrnd , <S2SV_EndBug> const struct in6_addr * dst , const struct in6_addr * src ) { <S2SV_StartBug> u32 hash , id ; <S2SV_EndBug> <S2SV_StartBug> hash = __ipv6_addr_jhash ( dst , hashrnd ) ; <S2SV_EndBug> <S2SV_StartBug> hash = __ipv6_addr_jhash ( src , hash ) ; <S2SV_EndBug> hash ^= net_hash_mix ( net ) ; id = ip_idents_reserve ( hash , 1 ) ; if ( unlikely ( ! id ) ) id = 1 << 31 ; return id ; }
static int ndp_sock_open ( struct ndp * ndp ) { int sock ; int ret ; int err ; int val ; sock = socket ( PF_INET6 , SOCK_RAW , IPPROTO_ICMPV6 ) ; if ( sock == - 1 ) { err ( ndp , "Failed<S2SV_blank>to<S2SV_blank>create<S2SV_blank>ICMP6<S2SV_blank>socket." ) ; return - errno ; } val = 1 ; ret = setsockopt ( sock , IPPROTO_IPV6 , IPV6_RECVPKTINFO , & val , sizeof ( val ) ) ; if ( ret == - 1 ) { err ( ndp , "Failed<S2SV_blank>to<S2SV_blank>setsockopt<S2SV_blank>IPV6_RECVPKTINFO." ) ; err = - errno ; goto close_sock ; } val = 255 ; ret = setsockopt ( sock , IPPROTO_IPV6 , IPV6_MULTICAST_HOPS , & val , sizeof ( val ) ) ; if ( ret == - 1 ) { <S2SV_StartBug> err ( ndp , "Failed<S2SV_blank>to<S2SV_blank>setsockopt<S2SV_blank>IPV6_MULTICAST_HOPS." ) ; <S2SV_EndBug> err = - errno ; goto close_sock ; } ndp -> sock = sock ; return 0 ; close_sock : close ( sock ) ; return err ; }
void pin_remove ( struct fs_pin * pin ) { spin_lock ( & pin_lock ) ; <S2SV_StartBug> hlist_del ( & pin -> m_list ) ; <S2SV_EndBug> <S2SV_StartBug> hlist_del ( & pin -> s_list ) ; <S2SV_EndBug> spin_unlock ( & pin_lock ) ; spin_lock_irq ( & pin -> wait . lock ) ; pin -> done = 1 ; wake_up_locked ( & pin -> wait ) ; spin_unlock_irq ( & pin -> wait . lock ) ; }
static int temporal_filter_find_matching_mb_c ( VP9_COMP * cpi , uint8_t * arf_frame_buf , uint8_t * frame_ptr_buf , int stride ) { <S2SV_StartBug> MACROBLOCK * x = & cpi -> mb ; <S2SV_EndBug> MACROBLOCKD * const xd = & x -> e_mbd ; <S2SV_StartBug> int step_param ; <S2SV_EndBug> int sadpb = x -> sadperbit16 ; <S2SV_StartBug> int bestsme = INT_MAX ; <S2SV_EndBug> MV best_ref_mv1 = { 0 , 0 } ; MV best_ref_mv1_full ; MV * ref_mv = & x -> e_mbd . mi [ 0 ] -> bmi [ 0 ] . as_mv [ 0 ] . as_mv ; struct buf_2d src = x -> plane [ 0 ] . src ; struct buf_2d pre = xd -> plane [ 0 ] . pre [ 0 ] ; best_ref_mv1_full . col = best_ref_mv1 . col >> 3 ; best_ref_mv1_full . row = best_ref_mv1 . row >> 3 ; x -> plane [ 0 ] . src . buf = arf_frame_buf ; x -> plane [ 0 ] . src . stride = stride ; xd -> plane [ 0 ] . pre [ 0 ] . buf = frame_ptr_buf ; xd -> plane [ 0 ] . pre [ 0 ] . stride = stride ; <S2SV_StartBug> if ( cpi -> speed < 8 ) <S2SV_EndBug> step_param = cpi -> sf . reduce_first_step_size + ( ( cpi -> speed > 5 ) ? 1 : 0 ) ; else step_param = cpi -> sf . reduce_first_step_size + 2 ; <S2SV_StartBug> step_param = MIN ( step_param , ( cpi -> sf . max_step_search_steps - 2 ) ) ; <S2SV_EndBug> vp9_hex_search ( x , & best_ref_mv1_full , step_param , sadpb , 1 , <S2SV_StartBug> & cpi -> fn_ptr [ BLOCK_16X16 ] , 0 , & best_ref_mv1 , ref_mv ) ; <S2SV_EndBug> <S2SV_StartBug> { <S2SV_EndBug> int distortion ; unsigned int sse ; bestsme = cpi -> find_fractional_mv_step ( x , ref_mv , & best_ref_mv1 , cpi -> common . allow_high_precision_mv , x -> errorperbit , & cpi -> fn_ptr [ BLOCK_16X16 ] , 0 , cpi -> sf . subpel_iters_per_step , NULL , NULL , & distortion , & sse ) ; } x -> plane [ 0 ] . src = src ; xd -> plane [ 0 ] . pre [ 0 ] = pre ; return bestsme ; }
static int stv06xx_start ( struct gspca_dev * gspca_dev ) { struct sd * sd = ( struct sd * ) gspca_dev ; struct usb_host_interface * alt ; struct usb_interface * intf ; int err , packet_size ; intf = usb_ifnum_to_if ( sd -> gspca_dev . dev , sd -> gspca_dev . iface ) ; alt = usb_altnum_to_altsetting ( intf , sd -> gspca_dev . alt ) ; if ( ! alt ) { gspca_err ( gspca_dev , "Couldn\'t<S2SV_blank>get<S2SV_blank>altsetting\\n" ) ; return - EIO ; } <S2SV_StartBug> packet_size = le16_to_cpu ( alt -> endpoint [ 0 ] . desc . wMaxPacketSize ) ; <S2SV_EndBug> err = stv06xx_write_bridge ( sd , STV_ISO_SIZE_L , packet_size ) ; if ( err < 0 ) return err ; err = sd -> sensor -> start ( sd ) ; if ( err < 0 ) goto out ; err = stv06xx_write_bridge ( sd , STV_ISO_ENABLE , 1 ) ; out : if ( err < 0 ) gspca_dbg ( gspca_dev , D_STREAM , "Starting<S2SV_blank>stream<S2SV_blank>failed\\n" ) ; else gspca_dbg ( gspca_dev , D_STREAM , "Started<S2SV_blank>streaming\\n" ) ; return ( err < 0 ) ? err : 0 ; }
static struct cifsSesInfo * cifs_get_smb_ses ( struct TCP_Server_Info * server , struct smb_vol * volume_info ) { int rc = - ENOMEM , xid ; struct cifsSesInfo * ses ; xid = GetXid ( ) ; <S2SV_StartBug> ses = cifs_find_smb_ses ( server , volume_info -> username ) ; <S2SV_EndBug> if ( ses ) { cFYI ( 1 , "Existing<S2SV_blank>smb<S2SV_blank>sess<S2SV_blank>found<S2SV_blank>(status=%d)" , ses -> status ) ; cifs_put_tcp_session ( server ) ; mutex_lock ( & ses -> session_mutex ) ; rc = cifs_negotiate_protocol ( xid , ses ) ; if ( rc ) { mutex_unlock ( & ses -> session_mutex ) ; cifs_put_smb_ses ( ses ) ; FreeXid ( xid ) ; return ERR_PTR ( rc ) ; } if ( ses -> need_reconnect ) { cFYI ( 1 , "Session<S2SV_blank>needs<S2SV_blank>reconnect" ) ; rc = cifs_setup_session ( xid , ses , volume_info -> local_nls ) ; if ( rc ) { mutex_unlock ( & ses -> session_mutex ) ; cifs_put_smb_ses ( ses ) ; FreeXid ( xid ) ; return ERR_PTR ( rc ) ; } } mutex_unlock ( & ses -> session_mutex ) ; FreeXid ( xid ) ; return ses ; } cFYI ( 1 , "Existing<S2SV_blank>smb<S2SV_blank>sess<S2SV_blank>not<S2SV_blank>found" ) ; ses = sesInfoAlloc ( ) ; if ( ses == NULL ) goto get_ses_fail ; ses -> server = server ; if ( server -> addr . sockAddr6 . sin6_family == AF_INET6 ) sprintf ( ses -> serverName , "%pI6" , & server -> addr . sockAddr6 . sin6_addr ) ; else sprintf ( ses -> serverName , "%pI4" , & server -> addr . sockAddr . sin_addr . s_addr ) ; if ( volume_info -> username ) strncpy ( ses -> userName , volume_info -> username , MAX_USERNAME_SIZE ) ; if ( volume_info -> password ) { ses -> password = kstrdup ( volume_info -> password , GFP_KERNEL ) ; if ( ! ses -> password ) goto get_ses_fail ; } if ( volume_info -> domainname ) { int len = strlen ( volume_info -> domainname ) ; ses -> domainName = kmalloc ( len + 1 , GFP_KERNEL ) ; if ( ses -> domainName ) strcpy ( ses -> domainName , volume_info -> domainname ) ; } ses -> linux_uid = volume_info -> linux_uid ; ses -> overrideSecFlg = volume_info -> secFlg ; mutex_lock ( & ses -> session_mutex ) ; rc = cifs_negotiate_protocol ( xid , ses ) ; if ( ! rc ) rc = cifs_setup_session ( xid , ses , volume_info -> local_nls ) ; mutex_unlock ( & ses -> session_mutex ) ; if ( rc ) goto get_ses_fail ; write_lock ( & cifs_tcp_ses_lock ) ; list_add ( & ses -> smb_ses_list , & server -> smb_ses_list ) ; write_unlock ( & cifs_tcp_ses_lock ) ; FreeXid ( xid ) ; return ses ; get_ses_fail : sesInfoFree ( ses ) ; FreeXid ( xid ) ; return ERR_PTR ( rc ) ; }
int vp8_yv12_realloc_frame_buffer ( YV12_BUFFER_CONFIG * ybf , int width , int height , int border ) { if ( ybf ) { int aligned_width = ( width + 15 ) & ~ 15 ; int aligned_height = ( height + 15 ) & ~ 15 ; int y_stride = ( ( aligned_width + 2 * border ) + 31 ) & ~ 31 ; int yplane_size = ( aligned_height + 2 * border ) * y_stride ; int uv_width = aligned_width >> 1 ; int uv_height = aligned_height >> 1 ; int uv_stride = y_stride >> 1 ; int uvplane_size = ( uv_height + border ) * uv_stride ; const int frame_size = yplane_size + 2 * uvplane_size ; if ( ! ybf -> buffer_alloc ) { ybf -> buffer_alloc = ( uint8_t * ) vpx_memalign ( 32 , frame_size ) ; ybf -> buffer_alloc_sz = frame_size ; } if ( ! ybf -> buffer_alloc || ybf -> buffer_alloc_sz < frame_size ) return - 1 ; if ( border & 0x1f ) return - 3 ; ybf -> y_crop_width = width ; ybf -> y_crop_height = height ; ybf -> y_width = aligned_width ; ybf -> y_height = aligned_height ; ybf -> y_stride = y_stride ; <S2SV_StartBug> ybf -> uv_width = uv_width ; <S2SV_EndBug> ybf -> uv_height = uv_height ; ybf -> uv_stride = uv_stride ; ybf -> alpha_width = 0 ; ybf -> alpha_height = 0 ; ybf -> alpha_stride = 0 ; ybf -> border = border ; ybf -> frame_size = frame_size ; ybf -> y_buffer = ybf -> buffer_alloc + ( border * y_stride ) + border ; ybf -> u_buffer = ybf -> buffer_alloc + yplane_size + ( border / 2 * uv_stride ) + border / 2 ; ybf -> v_buffer = ybf -> buffer_alloc + yplane_size + uvplane_size + ( border / 2 * uv_stride ) + border / 2 ; ybf -> alpha_buffer = NULL ; ybf -> corrupted = 0 ; return 0 ; } return - 2 ; }
static void f2fs_put_super ( struct super_block * sb ) { struct f2fs_sb_info * sbi = F2FS_SB ( sb ) ; int i ; f2fs_quota_off_umount ( sb ) ; mutex_lock ( & sbi -> umount_mutex ) ; if ( is_sbi_flag_set ( sbi , SBI_IS_DIRTY ) || ! is_set_ckpt_flags ( sbi , CP_UMOUNT_FLAG ) ) { struct cp_control cpc = { . reason = CP_UMOUNT , } ; write_checkpoint ( sbi , & cpc ) ; } <S2SV_StartBug> f2fs_wait_discard_bios ( sbi ) ; <S2SV_EndBug> if ( f2fs_discard_en ( sbi ) && ! sbi -> discard_blks ) { struct cp_control cpc = { . reason = CP_UMOUNT | CP_TRIMMED , } ; write_checkpoint ( sbi , & cpc ) ; } f2fs_destroy_stats ( sbi ) ; release_ino_entry ( sbi , true ) ; f2fs_leave_shrinker ( sbi ) ; mutex_unlock ( & sbi -> umount_mutex ) ; f2fs_flush_merged_writes ( sbi ) ; iput ( sbi -> node_inode ) ; iput ( sbi -> meta_inode ) ; destroy_node_manager ( sbi ) ; destroy_segment_manager ( sbi ) ; kfree ( sbi -> ckpt ) ; f2fs_unregister_sysfs ( sbi ) ; sb -> s_fs_info = NULL ; if ( sbi -> s_chksum_driver ) crypto_free_shash ( sbi -> s_chksum_driver ) ; kfree ( sbi -> raw_super ) ; destroy_device_list ( sbi ) ; mempool_destroy ( sbi -> write_io_dummy ) ; # ifdef CONFIG_QUOTA for ( i = 0 ; i < MAXQUOTAS ; i ++ ) kfree ( sbi -> s_qf_names [ i ] ) ; # endif destroy_percpu_info ( sbi ) ; for ( i = 0 ; i < NR_PAGE_TYPE ; i ++ ) kfree ( sbi -> write_io [ i ] ) ; kfree ( sbi ) ; }
err_t verify_signed_hash ( const struct RSA_public_key * k , u_char * s , unsigned int s_max_octets , u_char * * psig , size_t hash_len , const u_char * sig_val , size_t sig_len ) { unsigned int padlen ; { chunk_t temp_s ; MP_INT c ; n_to_mpz ( & c , sig_val , sig_len ) ; oswcrypto . mod_exp ( & c , & c , & k -> e , & k -> n ) ; temp_s = mpz_to_n ( & c , sig_len ) ; if ( s_max_octets < sig_len ) { return "2" "exponentiation<S2SV_blank>failed;<S2SV_blank>too<S2SV_blank>many<S2SV_blank>octets" ; } memcpy ( s , temp_s . ptr , sig_len ) ; pfree ( temp_s . ptr ) ; mpz_clear ( & c ) ; } padlen = sig_len - 3 - hash_len ; DBG ( DBG_CRYPT , DBG_dump ( "verify_sh<S2SV_blank>decrypted<S2SV_blank>SIG1:" , s , sig_len ) ) ; DBG ( DBG_CRYPT , DBG_log ( "pad_len<S2SV_blank>calculated:<S2SV_blank>%d<S2SV_blank>hash_len:<S2SV_blank>%d" , padlen , ( int ) hash_len ) ) ; if ( s [ 0 ] != 0x00 || s [ 1 ] != 0x01 || s [ padlen + 2 ] != 0x00 ) { return "3" "SIG<S2SV_blank>padding<S2SV_blank>does<S2SV_blank>not<S2SV_blank>check<S2SV_blank>out" ; } <S2SV_StartBug> s += padlen + 3 ; <S2SV_EndBug> <S2SV_StartBug> ( * psig ) = s ; <S2SV_EndBug> return NULL ; }
static int dnxhd_decode_header ( DNXHDContext * ctx , AVFrame * frame , const uint8_t * buf , int buf_size , int first_field ) { int i , cid , ret ; int old_bit_depth = ctx -> bit_depth , bitdepth ; uint64_t header_prefix ; if ( buf_size < 0x280 ) { av_log ( ctx -> avctx , AV_LOG_ERROR , "buffer<S2SV_blank>too<S2SV_blank>small<S2SV_blank>(%d<S2SV_blank><<S2SV_blank>640).\\n" , buf_size ) ; return AVERROR_INVALIDDATA ; } header_prefix = ff_dnxhd_parse_header_prefix ( buf ) ; if ( header_prefix == 0 ) { av_log ( ctx -> avctx , AV_LOG_ERROR , "unknown<S2SV_blank>header<S2SV_blank>0x%02X<S2SV_blank>0x%02X<S2SV_blank>0x%02X<S2SV_blank>0x%02X<S2SV_blank>0x%02X\\n" , buf [ 0 ] , buf [ 1 ] , buf [ 2 ] , buf [ 3 ] , buf [ 4 ] ) ; return AVERROR_INVALIDDATA ; } if ( buf [ 5 ] & 2 ) { ctx -> cur_field = buf [ 5 ] & 1 ; frame -> interlaced_frame = 1 ; frame -> top_field_first = first_field ^ ctx -> cur_field ; av_log ( ctx -> avctx , AV_LOG_DEBUG , "interlaced<S2SV_blank>%d,<S2SV_blank>cur<S2SV_blank>field<S2SV_blank>%d\\n" , buf [ 5 ] & 3 , ctx -> cur_field ) ; } else { ctx -> cur_field = 0 ; } ctx -> mbaff = ( buf [ 0x6 ] >> 5 ) & 1 ; ctx -> height = AV_RB16 ( buf + 0x18 ) ; ctx -> width = AV_RB16 ( buf + 0x1a ) ; switch ( buf [ 0x21 ] >> 5 ) { case 1 : bitdepth = 8 ; break ; case 2 : bitdepth = 10 ; break ; case 3 : bitdepth = 12 ; break ; default : av_log ( ctx -> avctx , AV_LOG_ERROR , "Unknown<S2SV_blank>bitdepth<S2SV_blank>indicator<S2SV_blank>(%d)\\n" , buf [ 0x21 ] >> 5 ) ; return AVERROR_INVALIDDATA ; } cid = AV_RB32 ( buf + 0x28 ) ; ctx -> avctx -> profile = dnxhd_get_profile ( cid ) ; if ( ( ret = dnxhd_init_vlc ( ctx , cid , bitdepth ) ) < 0 ) return ret ; if ( ctx -> mbaff && ctx -> cid_table -> cid != 1260 ) av_log ( ctx -> avctx , AV_LOG_WARNING , "Adaptive<S2SV_blank>MB<S2SV_blank>interlace<S2SV_blank>flag<S2SV_blank>in<S2SV_blank>an<S2SV_blank>unsupported<S2SV_blank>profile.\\n" ) ; ctx -> act = buf [ 0x2C ] & 7 ; if ( ctx -> act && ctx -> cid_table -> cid != 1256 && ctx -> cid_table -> cid != 1270 ) av_log ( ctx -> avctx , AV_LOG_WARNING , "Adaptive<S2SV_blank>color<S2SV_blank>transform<S2SV_blank>in<S2SV_blank>an<S2SV_blank>unsupported<S2SV_blank>profile.\\n" ) ; ctx -> is_444 = ( buf [ 0x2C ] >> 6 ) & 1 ; if ( ctx -> is_444 ) { if ( bitdepth == 8 ) { avpriv_request_sample ( ctx -> avctx , "4:4:4<S2SV_blank>8<S2SV_blank>bits" ) ; return AVERROR_INVALIDDATA ; } else if ( bitdepth == 10 ) { ctx -> decode_dct_block = dnxhd_decode_dct_block_10_444 ; ctx -> pix_fmt = ctx -> act ? AV_PIX_FMT_YUV444P10 : AV_PIX_FMT_GBRP10 ; } else { ctx -> decode_dct_block = dnxhd_decode_dct_block_12_444 ; ctx -> pix_fmt = ctx -> act ? AV_PIX_FMT_YUV444P12 : AV_PIX_FMT_GBRP12 ; } } else if ( bitdepth == 12 ) { ctx -> decode_dct_block = dnxhd_decode_dct_block_12 ; ctx -> pix_fmt = AV_PIX_FMT_YUV422P12 ; } else if ( bitdepth == 10 ) { if ( ctx -> avctx -> profile == FF_PROFILE_DNXHR_HQX ) ctx -> decode_dct_block = dnxhd_decode_dct_block_10_444 ; else ctx -> decode_dct_block = dnxhd_decode_dct_block_10 ; ctx -> pix_fmt = AV_PIX_FMT_YUV422P10 ; } else { ctx -> decode_dct_block = dnxhd_decode_dct_block_8 ; ctx -> pix_fmt = AV_PIX_FMT_YUV422P ; } ctx -> avctx -> bits_per_raw_sample = ctx -> bit_depth = bitdepth ; if ( ctx -> bit_depth != old_bit_depth ) { ff_blockdsp_init ( & ctx -> bdsp , ctx -> avctx ) ; ff_idctdsp_init ( & ctx -> idsp , ctx -> avctx ) ; ff_init_scantable ( ctx -> idsp . idct_permutation , & ctx -> scantable , ff_zigzag_direct ) ; } if ( ctx -> width != ctx -> cid_table -> width && ctx -> cid_table -> width != DNXHD_VARIABLE ) { av_reduce ( & ctx -> avctx -> sample_aspect_ratio . num , & ctx -> avctx -> sample_aspect_ratio . den , ctx -> width , ctx -> cid_table -> width , 255 ) ; ctx -> width = ctx -> cid_table -> width ; } if ( buf_size < ctx -> cid_table -> coding_unit_size ) { av_log ( ctx -> avctx , AV_LOG_ERROR , "incorrect<S2SV_blank>frame<S2SV_blank>size<S2SV_blank>(%d<S2SV_blank><<S2SV_blank>%u).\\n" , buf_size , ctx -> cid_table -> coding_unit_size ) ; return AVERROR_INVALIDDATA ; } ctx -> mb_width = ( ctx -> width + 15 ) >> 4 ; ctx -> mb_height = AV_RB16 ( buf + 0x16c ) ; if ( ( ctx -> height + 15 ) >> 4 == ctx -> mb_height && frame -> interlaced_frame ) ctx -> height <<= 1 ; av_log ( ctx -> avctx , AV_LOG_VERBOSE , "%dx%d,<S2SV_blank>4:%s<S2SV_blank>%d<S2SV_blank>bits,<S2SV_blank>MBAFF=%d<S2SV_blank>ACT=%d\\n" , ctx -> width , ctx -> height , ctx -> is_444 ? "4:4" : "2:2" , ctx -> bit_depth , ctx -> mbaff , ctx -> act ) ; if ( ctx -> mb_height > 68 && ff_dnxhd_check_header_prefix_hr ( header_prefix ) ) { ctx -> data_offset = 0x170 + ( ctx -> mb_height << 2 ) ; } else { <S2SV_StartBug> if ( ctx -> mb_height > 68 || <S2SV_EndBug> ( ctx -> mb_height << frame -> interlaced_frame ) > ( ctx -> height + 15 ) >> 4 ) { av_log ( ctx -> avctx , AV_LOG_ERROR , "mb<S2SV_blank>height<S2SV_blank>too<S2SV_blank>big:<S2SV_blank>%d\\n" , ctx -> mb_height ) ; return AVERROR_INVALIDDATA ; } <S2SV_StartBug> ctx -> data_offset = 0x280 ; <S2SV_EndBug> } if ( buf_size < ctx -> data_offset ) { av_log ( ctx -> avctx , AV_LOG_ERROR , "buffer<S2SV_blank>too<S2SV_blank>small<S2SV_blank>(%d<S2SV_blank><<S2SV_blank>%d).\\n" , buf_size , ctx -> data_offset ) ; return AVERROR_INVALIDDATA ; } if ( ctx -> mb_height > FF_ARRAY_ELEMS ( ctx -> mb_scan_index ) ) { av_log ( ctx -> avctx , AV_LOG_ERROR , "mb_height<S2SV_blank>too<S2SV_blank>big<S2SV_blank>(%d<S2SV_blank>><S2SV_blank>%" SIZE_SPECIFIER ").\\n" , ctx -> mb_height , FF_ARRAY_ELEMS ( ctx -> mb_scan_index ) ) ; return AVERROR_INVALIDDATA ; } for ( i = 0 ; i < ctx -> mb_height ; i ++ ) { ctx -> mb_scan_index [ i ] = AV_RB32 ( buf + 0x170 + ( i << 2 ) ) ; ff_dlog ( ctx -> avctx , "mb<S2SV_blank>scan<S2SV_blank>index<S2SV_blank>%d,<S2SV_blank>pos<S2SV_blank>%d:<S2SV_blank>%" PRIu32 "\\n" , i , 0x170 + ( i << 2 ) , ctx -> mb_scan_index [ i ] ) ; if ( buf_size - ctx -> data_offset < ctx -> mb_scan_index [ i ] ) { av_log ( ctx -> avctx , AV_LOG_ERROR , "invalid<S2SV_blank>mb<S2SV_blank>scan<S2SV_blank>index<S2SV_blank>(%" PRIu32 "<S2SV_blank>vs<S2SV_blank>%u).\\n" , ctx -> mb_scan_index [ i ] , buf_size - ctx -> data_offset ) ; return AVERROR_INVALIDDATA ; } } return 0 ; }
static irqreturn_t i8042_interrupt ( int irq , void * dev_id ) { struct i8042_port * port ; struct serio * serio ; unsigned long flags ; unsigned char str , data ; unsigned int dfl ; unsigned int port_no ; bool filtered ; int ret = 1 ; spin_lock_irqsave ( & i8042_lock , flags ) ; str = i8042_read_status ( ) ; if ( unlikely ( ~ str & I8042_STR_OBF ) ) { spin_unlock_irqrestore ( & i8042_lock , flags ) ; if ( irq ) dbg ( "Interrupt<S2SV_blank>%d,<S2SV_blank>without<S2SV_blank>any<S2SV_blank>data\\n" , irq ) ; ret = 0 ; goto out ; } data = i8042_read_data ( ) ; if ( i8042_mux_present && ( str & I8042_STR_AUXDATA ) ) { static unsigned long last_transmit ; static unsigned char last_str ; dfl = 0 ; if ( str & I8042_STR_MUXERR ) { dbg ( "MUX<S2SV_blank>error,<S2SV_blank>status<S2SV_blank>is<S2SV_blank>%02x,<S2SV_blank>data<S2SV_blank>is<S2SV_blank>%02x\\n" , str , data ) ; switch ( data ) { default : if ( time_before ( jiffies , last_transmit + HZ / 10 ) ) { str = last_str ; break ; } case 0xfc : case 0xfd : case 0xfe : dfl = SERIO_TIMEOUT ; data = 0xfe ; break ; case 0xff : dfl = SERIO_PARITY ; data = 0xfe ; break ; } } port_no = I8042_MUX_PORT_NO + ( ( str >> 6 ) & 3 ) ; last_str = str ; last_transmit = jiffies ; } else { dfl = ( ( str & I8042_STR_PARITY ) ? SERIO_PARITY : 0 ) | ( ( str & I8042_STR_TIMEOUT && ! i8042_notimeout ) ? SERIO_TIMEOUT : 0 ) ; port_no = ( str & I8042_STR_AUXDATA ) ? I8042_AUX_PORT_NO : I8042_KBD_PORT_NO ; } port = & i8042_ports [ port_no ] ; serio = port -> exists ? port -> serio : NULL ; filter_dbg ( port -> driver_bound , data , "<-<S2SV_blank>i8042<S2SV_blank>(interrupt,<S2SV_blank>%d,<S2SV_blank>%d%s%s)\\n" , port_no , irq , dfl & SERIO_PARITY ? ",<S2SV_blank>bad<S2SV_blank>parity" : "" , dfl & SERIO_TIMEOUT ? ",<S2SV_blank>timeout" : "" ) ; filtered = i8042_filter ( data , str , serio ) ; spin_unlock_irqrestore ( & i8042_lock , flags ) ; <S2SV_StartBug> if ( likely ( port -> exists && ! filtered ) ) <S2SV_EndBug> serio_interrupt ( serio , data , dfl ) ; out : return IRQ_RETVAL ( ret ) ; }
int ff_jpeg2000_init_component ( Jpeg2000Component * comp , Jpeg2000CodingStyle * codsty , Jpeg2000QuantStyle * qntsty , int cbps , int dx , int dy , AVCodecContext * avctx ) { uint8_t log2_band_prec_width , log2_band_prec_height ; int reslevelno , bandno , gbandno = 0 , ret , i , j ; uint32_t csize ; if ( codsty -> nreslevels2decode <= 0 ) { av_log ( avctx , AV_LOG_ERROR , "nreslevels2decode<S2SV_blank>%d<S2SV_blank>invalid<S2SV_blank>or<S2SV_blank>uninitialized\\n" , codsty -> nreslevels2decode ) ; return AVERROR_INVALIDDATA ; } if ( ret = ff_jpeg2000_dwt_init ( & comp -> dwt , comp -> coord , codsty -> nreslevels2decode - 1 , codsty -> transform ) ) return ret ; csize = ( comp -> coord [ 0 ] [ 1 ] - comp -> coord [ 0 ] [ 0 ] ) * ( comp -> coord [ 1 ] [ 1 ] - comp -> coord [ 1 ] [ 0 ] ) ; if ( codsty -> transform == FF_DWT97 ) { comp -> i_data = NULL ; comp -> f_data = av_malloc_array ( csize , sizeof ( * comp -> f_data ) ) ; if ( ! comp -> f_data ) return AVERROR ( ENOMEM ) ; } else { comp -> f_data = NULL ; comp -> i_data = av_malloc_array ( csize , sizeof ( * comp -> i_data ) ) ; if ( ! comp -> i_data ) return AVERROR ( ENOMEM ) ; } comp -> reslevel = av_malloc_array ( codsty -> nreslevels , sizeof ( * comp -> reslevel ) ) ; if ( ! comp -> reslevel ) return AVERROR ( ENOMEM ) ; for ( reslevelno = 0 ; reslevelno < codsty -> nreslevels ; reslevelno ++ ) { int declvl = codsty -> nreslevels - reslevelno ; Jpeg2000ResLevel * reslevel = comp -> reslevel + reslevelno ; for ( i = 0 ; i < 2 ; i ++ ) for ( j = 0 ; j < 2 ; j ++ ) reslevel -> coord [ i ] [ j ] = ff_jpeg2000_ceildivpow2 ( comp -> coord_o [ i ] [ j ] , declvl - 1 ) ; reslevel -> log2_prec_width = codsty -> log2_prec_widths [ reslevelno ] ; reslevel -> log2_prec_height = codsty -> log2_prec_heights [ reslevelno ] ; if ( reslevelno == 0 ) reslevel -> nbands = 1 ; else reslevel -> nbands = 3 ; if ( reslevel -> coord [ 0 ] [ 1 ] == reslevel -> coord [ 0 ] [ 0 ] ) reslevel -> num_precincts_x = 0 ; else reslevel -> num_precincts_x = ff_jpeg2000_ceildivpow2 ( reslevel -> coord [ 0 ] [ 1 ] , reslevel -> log2_prec_width ) - ( reslevel -> coord [ 0 ] [ 0 ] >> reslevel -> log2_prec_width ) ; if ( reslevel -> coord [ 1 ] [ 1 ] == reslevel -> coord [ 1 ] [ 0 ] ) reslevel -> num_precincts_y = 0 ; else reslevel -> num_precincts_y = ff_jpeg2000_ceildivpow2 ( reslevel -> coord [ 1 ] [ 1 ] , reslevel -> log2_prec_height ) - ( reslevel -> coord [ 1 ] [ 0 ] >> reslevel -> log2_prec_height ) ; <S2SV_StartBug> reslevel -> band = av_malloc_array ( reslevel -> nbands , sizeof ( * reslevel -> band ) ) ; <S2SV_EndBug> if ( ! reslevel -> band ) return AVERROR ( ENOMEM ) ; for ( bandno = 0 ; bandno < reslevel -> nbands ; bandno ++ , gbandno ++ ) { Jpeg2000Band * band = reslevel -> band + bandno ; int cblkno , precno ; int nb_precincts ; switch ( qntsty -> quantsty ) { uint8_t gain ; int numbps ; case JPEG2000_QSTY_NONE : band -> f_stepsize = 1 ; break ; case JPEG2000_QSTY_SI : numbps = cbps + lut_gain [ codsty -> transform == FF_DWT53 ] [ bandno + ( reslevelno > 0 ) ] ; band -> f_stepsize = SHL ( 2048 + qntsty -> mant [ gbandno ] , 2 + numbps - qntsty -> expn [ gbandno ] ) ; break ; case JPEG2000_QSTY_SE : gain = cbps ; band -> f_stepsize = pow ( 2.0 , gain - qntsty -> expn [ gbandno ] ) ; band -> f_stepsize *= qntsty -> mant [ gbandno ] / 2048.0 + 1.0 ; break ; default : band -> f_stepsize = 0 ; av_log ( avctx , AV_LOG_ERROR , "Unknown<S2SV_blank>quantization<S2SV_blank>format\\n" ) ; break ; } if ( ! av_codec_is_encoder ( avctx -> codec ) ) band -> f_stepsize *= 0.5 ; band -> i_stepsize = band -> f_stepsize * ( 1 << 15 ) ; if ( reslevelno == 0 ) { for ( i = 0 ; i < 2 ; i ++ ) for ( j = 0 ; j < 2 ; j ++ ) band -> coord [ i ] [ j ] = ff_jpeg2000_ceildivpow2 ( comp -> coord_o [ i ] [ j ] - comp -> coord_o [ i ] [ 0 ] , declvl - 1 ) ; log2_band_prec_width = reslevel -> log2_prec_width ; log2_band_prec_height = reslevel -> log2_prec_height ; band -> log2_cblk_width = FFMIN ( codsty -> log2_cblk_width , reslevel -> log2_prec_width ) ; band -> log2_cblk_height = FFMIN ( codsty -> log2_cblk_height , reslevel -> log2_prec_height ) ; } else { for ( i = 0 ; i < 2 ; i ++ ) for ( j = 0 ; j < 2 ; j ++ ) band -> coord [ i ] [ j ] = ff_jpeg2000_ceildivpow2 ( comp -> coord_o [ i ] [ j ] - comp -> coord_o [ i ] [ 0 ] - ( ( ( bandno + 1 >> i ) & 1 ) << declvl - 1 ) , declvl ) ; band -> log2_cblk_width = FFMIN ( codsty -> log2_cblk_width , reslevel -> log2_prec_width - 1 ) ; band -> log2_cblk_height = FFMIN ( codsty -> log2_cblk_height , reslevel -> log2_prec_height - 1 ) ; log2_band_prec_width = reslevel -> log2_prec_width - 1 ; log2_band_prec_height = reslevel -> log2_prec_height - 1 ; } for ( j = 0 ; j < 2 ; j ++ ) band -> coord [ 0 ] [ j ] = ff_jpeg2000_ceildiv ( band -> coord [ 0 ] [ j ] , dx ) ; for ( j = 0 ; j < 2 ; j ++ ) band -> coord [ 1 ] [ j ] = ff_jpeg2000_ceildiv ( band -> coord [ 1 ] [ j ] , dy ) ; <S2SV_StartBug> band -> prec = av_malloc_array ( reslevel -> num_precincts_x * <S2SV_EndBug> ( uint64_t ) reslevel -> num_precincts_y , sizeof ( * band -> prec ) ) ; if ( ! band -> prec ) return AVERROR ( ENOMEM ) ; nb_precincts = reslevel -> num_precincts_x * reslevel -> num_precincts_y ; for ( precno = 0 ; precno < nb_precincts ; precno ++ ) { Jpeg2000Prec * prec = band -> prec + precno ; prec -> coord [ 0 ] [ 0 ] = ( precno % reslevel -> num_precincts_x ) * ( 1 << log2_band_prec_width ) ; prec -> coord [ 0 ] [ 0 ] = FFMAX ( prec -> coord [ 0 ] [ 0 ] , band -> coord [ 0 ] [ 0 ] ) ; prec -> coord [ 1 ] [ 0 ] = ( precno / reslevel -> num_precincts_x ) * ( 1 << log2_band_prec_height ) ; prec -> coord [ 1 ] [ 0 ] = FFMAX ( prec -> coord [ 1 ] [ 0 ] , band -> coord [ 1 ] [ 0 ] ) ; prec -> coord [ 0 ] [ 1 ] = prec -> coord [ 0 ] [ 0 ] + ( 1 << log2_band_prec_width ) ; prec -> coord [ 0 ] [ 1 ] = FFMIN ( prec -> coord [ 0 ] [ 1 ] , band -> coord [ 0 ] [ 1 ] ) ; prec -> coord [ 1 ] [ 1 ] = prec -> coord [ 1 ] [ 0 ] + ( 1 << log2_band_prec_height ) ; prec -> coord [ 1 ] [ 1 ] = FFMIN ( prec -> coord [ 1 ] [ 1 ] , band -> coord [ 1 ] [ 1 ] ) ; prec -> nb_codeblocks_width = ff_jpeg2000_ceildivpow2 ( prec -> coord [ 0 ] [ 1 ] - prec -> coord [ 0 ] [ 0 ] , band -> log2_cblk_width ) ; prec -> nb_codeblocks_height = ff_jpeg2000_ceildivpow2 ( prec -> coord [ 1 ] [ 1 ] - prec -> coord [ 1 ] [ 0 ] , band -> log2_cblk_height ) ; prec -> cblkincl = ff_jpeg2000_tag_tree_init ( prec -> nb_codeblocks_width , prec -> nb_codeblocks_height ) ; if ( ! prec -> cblkincl ) return AVERROR ( ENOMEM ) ; prec -> zerobits = ff_jpeg2000_tag_tree_init ( prec -> nb_codeblocks_width , prec -> nb_codeblocks_height ) ; if ( ! prec -> zerobits ) return AVERROR ( ENOMEM ) ; prec -> cblk = av_mallocz_array ( prec -> nb_codeblocks_width * ( uint64_t ) prec -> nb_codeblocks_height , sizeof ( * prec -> cblk ) ) ; if ( ! prec -> cblk ) return AVERROR ( ENOMEM ) ; for ( cblkno = 0 ; cblkno < prec -> nb_codeblocks_width * prec -> nb_codeblocks_height ; cblkno ++ ) { Jpeg2000Cblk * cblk = prec -> cblk + cblkno ; uint16_t Cx0 , Cy0 ; Cx0 = ( prec -> coord [ 0 ] [ 0 ] >> band -> log2_cblk_width ) << band -> log2_cblk_width ; Cx0 = Cx0 + ( ( cblkno % prec -> nb_codeblocks_width ) << band -> log2_cblk_width ) ; cblk -> coord [ 0 ] [ 0 ] = FFMAX ( Cx0 , prec -> coord [ 0 ] [ 0 ] ) ; Cy0 = ( prec -> coord [ 1 ] [ 0 ] >> band -> log2_cblk_height ) << band -> log2_cblk_height ; Cy0 = Cy0 + ( ( cblkno / prec -> nb_codeblocks_width ) << band -> log2_cblk_height ) ; cblk -> coord [ 1 ] [ 0 ] = FFMAX ( Cy0 , prec -> coord [ 1 ] [ 0 ] ) ; cblk -> coord [ 0 ] [ 1 ] = FFMIN ( Cx0 + ( 1 << band -> log2_cblk_width ) , prec -> coord [ 0 ] [ 1 ] ) ; cblk -> coord [ 1 ] [ 1 ] = FFMIN ( Cy0 + ( 1 << band -> log2_cblk_height ) , prec -> coord [ 1 ] [ 1 ] ) ; if ( ( bandno + ! ! reslevelno ) & 1 ) { cblk -> coord [ 0 ] [ 0 ] += comp -> reslevel [ reslevelno - 1 ] . coord [ 0 ] [ 1 ] - comp -> reslevel [ reslevelno - 1 ] . coord [ 0 ] [ 0 ] ; cblk -> coord [ 0 ] [ 1 ] += comp -> reslevel [ reslevelno - 1 ] . coord [ 0 ] [ 1 ] - comp -> reslevel [ reslevelno - 1 ] . coord [ 0 ] [ 0 ] ; } if ( ( bandno + ! ! reslevelno ) & 2 ) { cblk -> coord [ 1 ] [ 0 ] += comp -> reslevel [ reslevelno - 1 ] . coord [ 1 ] [ 1 ] - comp -> reslevel [ reslevelno - 1 ] . coord [ 1 ] [ 0 ] ; cblk -> coord [ 1 ] [ 1 ] += comp -> reslevel [ reslevelno - 1 ] . coord [ 1 ] [ 1 ] - comp -> reslevel [ reslevelno - 1 ] . coord [ 1 ] [ 0 ] ; } cblk -> zero = 0 ; cblk -> lblock = 3 ; cblk -> length = 0 ; cblk -> lengthinc = 0 ; cblk -> npasses = 0 ; } } } } return 0 ; }
int usbnet_probe ( struct usb_interface * udev , const struct usb_device_id * prod ) { struct usbnet * dev ; struct net_device * net ; struct usb_host_interface * interface ; struct driver_info * info ; struct usb_device * xdev ; int status ; const char * name ; struct usb_driver * driver = to_usb_driver ( udev -> dev . driver ) ; if ( ! driver -> supports_autosuspend ) { driver -> supports_autosuspend = 1 ; pm_runtime_enable ( & udev -> dev ) ; } name = udev -> dev . driver -> name ; info = ( struct driver_info * ) prod -> driver_info ; if ( ! info ) { dev_dbg ( & udev -> dev , "blacklisted<S2SV_blank>by<S2SV_blank>%s\\n" , name ) ; return - ENODEV ; } xdev = interface_to_usbdev ( udev ) ; interface = udev -> cur_altsetting ; status = - ENOMEM ; net = alloc_etherdev ( sizeof ( * dev ) ) ; if ( ! net ) goto out ; SET_NETDEV_DEV ( net , & udev -> dev ) ; dev = netdev_priv ( net ) ; dev -> udev = xdev ; dev -> intf = udev ; dev -> driver_info = info ; dev -> driver_name = name ; dev -> msg_enable = netif_msg_init ( msg_level , NETIF_MSG_DRV | NETIF_MSG_PROBE | NETIF_MSG_LINK ) ; init_waitqueue_head ( & dev -> wait ) ; skb_queue_head_init ( & dev -> rxq ) ; skb_queue_head_init ( & dev -> txq ) ; skb_queue_head_init ( & dev -> done ) ; skb_queue_head_init ( & dev -> rxq_pause ) ; dev -> bh . func = usbnet_bh ; dev -> bh . data = ( unsigned long ) dev ; INIT_WORK ( & dev -> kevent , usbnet_deferred_kevent ) ; init_usb_anchor ( & dev -> deferred ) ; dev -> delay . function = usbnet_bh ; dev -> delay . data = ( unsigned long ) dev ; init_timer ( & dev -> delay ) ; mutex_init ( & dev -> phy_mutex ) ; mutex_init ( & dev -> interrupt_mutex ) ; dev -> interrupt_count = 0 ; dev -> net = net ; strcpy ( net -> name , "usb%d" ) ; memcpy ( net -> dev_addr , node_id , sizeof node_id ) ; dev -> hard_mtu = net -> mtu + net -> hard_header_len ; net -> netdev_ops = & usbnet_netdev_ops ; net -> watchdog_timeo = TX_TIMEOUT_JIFFIES ; net -> ethtool_ops = & usbnet_ethtool_ops ; if ( info -> bind ) { status = info -> bind ( dev , udev ) ; if ( status < 0 ) goto out1 ; if ( ( dev -> driver_info -> flags & FLAG_ETHER ) != 0 && ( ( dev -> driver_info -> flags & FLAG_POINTTOPOINT ) == 0 || ( net -> dev_addr [ 0 ] & 0x02 ) == 0 ) ) strcpy ( net -> name , "eth%d" ) ; if ( ( dev -> driver_info -> flags & FLAG_WLAN ) != 0 ) strcpy ( net -> name , "wlan%d" ) ; if ( ( dev -> driver_info -> flags & FLAG_WWAN ) != 0 ) strcpy ( net -> name , "wwan%d" ) ; if ( ( dev -> driver_info -> flags & FLAG_NOARP ) != 0 ) net -> flags |= IFF_NOARP ; if ( net -> mtu > ( dev -> hard_mtu - net -> hard_header_len ) ) net -> mtu = dev -> hard_mtu - net -> hard_header_len ; } else if ( ! info -> in || ! info -> out ) status = usbnet_get_endpoints ( dev , udev ) ; else { dev -> in = usb_rcvbulkpipe ( xdev , info -> in ) ; dev -> out = usb_sndbulkpipe ( xdev , info -> out ) ; if ( ! ( info -> flags & FLAG_NO_SETINT ) ) status = usb_set_interface ( xdev , interface -> desc . bInterfaceNumber , interface -> desc . bAlternateSetting ) ; else status = 0 ; } if ( status >= 0 && dev -> status ) status = init_status ( dev , udev ) ; if ( status < 0 ) goto out3 ; if ( ! dev -> rx_urb_size ) dev -> rx_urb_size = dev -> hard_mtu ; dev -> maxpacket = usb_maxpacket ( dev -> udev , dev -> out , 1 ) ; if ( ether_addr_equal ( net -> dev_addr , node_id ) ) net -> addr_assign_type = NET_ADDR_RANDOM ; if ( ( dev -> driver_info -> flags & FLAG_WLAN ) != 0 ) SET_NETDEV_DEVTYPE ( net , & wlan_type ) ; if ( ( dev -> driver_info -> flags & FLAG_WWAN ) != 0 ) SET_NETDEV_DEVTYPE ( net , & wwan_type ) ; usbnet_update_max_qlen ( dev ) ; if ( dev -> can_dma_sg && ! ( info -> flags & FLAG_SEND_ZLP ) && ! ( info -> flags & FLAG_MULTI_PACKET ) ) { dev -> padding_pkt = kzalloc ( 1 , GFP_KERNEL ) ; if ( ! dev -> padding_pkt ) { status = - ENOMEM ; goto out4 ; } } status = register_netdev ( net ) ; if ( status ) goto out5 ; netif_info ( dev , probe , dev -> net , "register<S2SV_blank>\'%s\'<S2SV_blank>at<S2SV_blank>usb-%s-%s,<S2SV_blank>%s,<S2SV_blank>%pM\\n" , udev -> dev . driver -> name , xdev -> bus -> bus_name , xdev -> devpath , dev -> driver_info -> description , net -> dev_addr ) ; usb_set_intfdata ( udev , dev ) ; netif_device_attach ( net ) ; if ( dev -> driver_info -> flags & FLAG_LINK_INTR ) usbnet_link_change ( dev , 0 , 0 ) ; return 0 ; out5 : kfree ( dev -> padding_pkt ) ; out4 : usb_free_urb ( dev -> interrupt ) ; out3 : if ( info -> unbind ) info -> unbind ( dev , udev ) ; out1 : <S2SV_StartBug> free_netdev ( net ) ; <S2SV_EndBug> out : return status ; }
int DecodeTime ( char * str , int * tmask , struct tm * tm , fsec_t * fsec ) { char * cp ; * tmask = DTK_TIME_M ; tm -> tm_hour = strtol ( str , & cp , 10 ) ; if ( * cp != ':' ) return - 1 ; str = cp + 1 ; tm -> tm_min = strtol ( str , & cp , 10 ) ; if ( * cp == '\\0' ) { tm -> tm_sec = 0 ; * fsec = 0 ; } else if ( * cp != ':' ) return - 1 ; else { str = cp + 1 ; tm -> tm_sec = strtol ( str , & cp , 10 ) ; if ( * cp == '\\0' ) * fsec = 0 ; else if ( * cp == '.' ) { # ifdef HAVE_INT64_TIMESTAMP <S2SV_StartBug> char fstr [ MAXDATELEN + 1 ] ; <S2SV_EndBug> strncpy ( fstr , ( cp + 1 ) , 7 ) ; strcpy ( fstr + strlen ( fstr ) , "000000" ) ; * ( fstr + 6 ) = '\\0' ; * fsec = strtol ( fstr , & cp , 10 ) ; # else str = cp ; * fsec = strtod ( str , & cp ) ; # endif if ( * cp != '\\0' ) return - 1 ; } else return - 1 ; } # ifdef HAVE_INT64_TIMESTAMP if ( tm -> tm_hour < 0 || tm -> tm_min < 0 || tm -> tm_min > 59 || tm -> tm_sec < 0 || tm -> tm_sec > 59 || * fsec >= USECS_PER_SEC ) return - 1 ; # else if ( tm -> tm_hour < 0 || tm -> tm_min < 0 || tm -> tm_min > 59 || tm -> tm_sec < 0 || tm -> tm_sec > 59 || * fsec >= 1 ) return - 1 ; # endif return 0 ; }
static int em_ret ( struct x86_emulate_ctxt * ctxt ) { <S2SV_StartBug> ctxt -> dst . type = OP_REG ; <S2SV_EndBug> ctxt -> dst . addr . reg = & ctxt -> _eip ; <S2SV_StartBug> ctxt -> dst . bytes = ctxt -> op_bytes ; <S2SV_EndBug> return em_pop ( ctxt ) ; }
static void nfs4_close_done ( struct rpc_task * task , void * data ) { struct nfs4_closedata * calldata = data ; struct nfs4_state * state = calldata -> state ; struct nfs_server * server = NFS_SERVER ( calldata -> inode ) ; if ( RPC_ASSASSINATED ( task ) ) return ; switch ( task -> tk_status ) { case 0 : nfs_set_open_stateid ( state , & calldata -> res . stateid , 0 ) ; renew_lease ( server , calldata -> timestamp ) ; break ; case - NFS4ERR_STALE_STATEID : case - NFS4ERR_OLD_STATEID : case - NFS4ERR_BAD_STATEID : case - NFS4ERR_EXPIRED : <S2SV_StartBug> if ( calldata -> arg . open_flags == 0 ) <S2SV_EndBug> break ; default : if ( nfs4_async_handle_error ( task , server , state ) == - EAGAIN ) { rpc_restart_call ( task ) ; return ; } } nfs_refresh_inode ( calldata -> inode , calldata -> res . fattr ) ; }
static int ip6_frag_queue ( struct frag_queue * fq , struct sk_buff * skb , struct frag_hdr * fhdr , int nhoff ) { struct sk_buff * prev , * next ; struct net_device * dev ; int offset , end ; struct net * net = dev_net ( skb_dst ( skb ) -> dev ) ; if ( fq -> q . last_in & INET_FRAG_COMPLETE ) goto err ; offset = ntohs ( fhdr -> frag_off ) & ~ 0x7 ; end = offset + ( ntohs ( ipv6_hdr ( skb ) -> payload_len ) - ( ( u8 * ) ( fhdr + 1 ) - ( u8 * ) ( ipv6_hdr ( skb ) + 1 ) ) ) ; if ( ( unsigned int ) end > IPV6_MAXPLEN ) { IP6_INC_STATS_BH ( net , ip6_dst_idev ( skb_dst ( skb ) ) , IPSTATS_MIB_INHDRERRORS ) ; icmpv6_param_prob ( skb , ICMPV6_HDR_FIELD , ( ( u8 * ) & fhdr -> frag_off - skb_network_header ( skb ) ) ) ; return - 1 ; } if ( skb -> ip_summed == CHECKSUM_COMPLETE ) { const unsigned char * nh = skb_network_header ( skb ) ; skb -> csum = csum_sub ( skb -> csum , csum_partial ( nh , ( u8 * ) ( fhdr + 1 ) - nh , 0 ) ) ; } if ( ! ( fhdr -> frag_off & htons ( IP6_MF ) ) ) { if ( end < fq -> q . len || ( ( fq -> q . last_in & INET_FRAG_LAST_IN ) && end != fq -> q . len ) ) goto err ; fq -> q . last_in |= INET_FRAG_LAST_IN ; fq -> q . len = end ; } else { if ( end & 0x7 ) { IP6_INC_STATS_BH ( net , ip6_dst_idev ( skb_dst ( skb ) ) , IPSTATS_MIB_INHDRERRORS ) ; icmpv6_param_prob ( skb , ICMPV6_HDR_FIELD , offsetof ( struct ipv6hdr , payload_len ) ) ; return - 1 ; } if ( end > fq -> q . len ) { if ( fq -> q . last_in & INET_FRAG_LAST_IN ) goto err ; fq -> q . len = end ; } } if ( end == offset ) goto err ; if ( ! pskb_pull ( skb , ( u8 * ) ( fhdr + 1 ) - skb -> data ) ) goto err ; if ( pskb_trim_rcsum ( skb , end - offset ) ) goto err ; prev = fq -> q . fragments_tail ; if ( ! prev || FRAG6_CB ( prev ) -> offset < offset ) { next = NULL ; goto found ; } prev = NULL ; for ( next = fq -> q . fragments ; next != NULL ; next = next -> next ) { if ( FRAG6_CB ( next ) -> offset >= offset ) break ; prev = next ; } found : <S2SV_StartBug> if ( prev ) { <S2SV_EndBug> <S2SV_StartBug> int i = ( FRAG6_CB ( prev ) -> offset + prev -> len ) - offset ; <S2SV_EndBug> <S2SV_StartBug> if ( i > 0 ) { <S2SV_EndBug> offset += i ; if ( end <= offset ) goto err ; if ( ! pskb_pull ( skb , i ) ) goto err ; if ( skb -> ip_summed != CHECKSUM_UNNECESSARY ) skb -> ip_summed = CHECKSUM_NONE ; } } <S2SV_StartBug> while ( next && FRAG6_CB ( next ) -> offset < end ) { <S2SV_EndBug> int i = end - FRAG6_CB ( next ) -> offset ; if ( i < next -> len ) { if ( ! pskb_pull ( next , i ) ) goto err ; FRAG6_CB ( next ) -> offset += i ; fq -> q . meat -= i ; if ( next -> ip_summed != CHECKSUM_UNNECESSARY ) next -> ip_summed = CHECKSUM_NONE ; break ; } else { struct sk_buff * free_it = next ; next = next -> next ; if ( prev ) prev -> next = next ; else fq -> q . fragments = next ; fq -> q . meat -= free_it -> len ; frag_kfree_skb ( fq -> q . net , free_it ) ; } } FRAG6_CB ( skb ) -> offset = offset ; skb -> next = next ; if ( ! next ) fq -> q . fragments_tail = skb ; if ( prev ) prev -> next = skb ; else fq -> q . fragments = skb ; dev = skb -> dev ; if ( dev ) { fq -> iif = dev -> ifindex ; skb -> dev = NULL ; } fq -> q . stamp = skb -> tstamp ; fq -> q . meat += skb -> len ; atomic_add ( skb -> truesize , & fq -> q . net -> mem ) ; if ( offset == 0 ) { fq -> nhoffset = nhoff ; fq -> q . last_in |= INET_FRAG_FIRST_IN ; } if ( fq -> q . last_in == ( INET_FRAG_FIRST_IN | INET_FRAG_LAST_IN ) && fq -> q . meat == fq -> q . len ) return ip6_frag_reasm ( fq , prev , dev ) ; write_lock ( & ip6_frags . lock ) ; list_move_tail ( & fq -> q . lru_list , & fq -> q . net -> lru_list ) ; write_unlock ( & ip6_frags . lock ) ; return - 1 ; <S2SV_StartBug> err : <S2SV_EndBug> IP6_INC_STATS ( net , ip6_dst_idev ( skb_dst ( skb ) ) , IPSTATS_MIB_REASMFAILS ) ; kfree_skb ( skb ) ; return - 1 ; }
static int hugetlbfs_statfs ( struct dentry * dentry , struct kstatfs * buf ) { struct hugetlbfs_sb_info * sbinfo = HUGETLBFS_SB ( dentry -> d_sb ) ; struct hstate * h = hstate_inode ( dentry -> d_inode ) ; buf -> f_type = HUGETLBFS_MAGIC ; buf -> f_bsize = huge_page_size ( h ) ; if ( sbinfo ) { spin_lock ( & sbinfo -> stat_lock ) ; <S2SV_StartBug> if ( sbinfo -> max_blocks >= 0 ) { <S2SV_EndBug> <S2SV_StartBug> buf -> f_blocks = sbinfo -> max_blocks ; <S2SV_EndBug> <S2SV_StartBug> buf -> f_bavail = buf -> f_bfree = sbinfo -> free_blocks ; <S2SV_EndBug> buf -> f_files = sbinfo -> max_inodes ; buf -> f_ffree = sbinfo -> free_inodes ; } spin_unlock ( & sbinfo -> stat_lock ) ; } buf -> f_namelen = NAME_MAX ; return 0 ; }
static bool parseOperands ( char * str , ArmOp * op ) { char * t = strdup ( str ) ; int operand = 0 ; char * token = t ; char * x ; int imm_count = 0 ; int mem_opt = 0 ; if ( ! token ) { return false ; } while ( token ) { char * next = strchr ( token , ',' ) ; if ( next ) { * next ++ = 0 ; } while ( token [ 0 ] == '<S2SV_blank>' ) { token ++ ; } if ( operand >= MAX_OPERANDS ) { eprintf ( "Too<S2SV_blank>many<S2SV_blank>operands\\n" ) ; return false ; } op -> operands [ operand ] . type = ARM_NOTYPE ; op -> operands [ operand ] . reg_type = ARM_UNDEFINED ; op -> operands [ operand ] . shift = ARM_NO_SHIFT ; while ( token [ 0 ] == '<S2SV_blank>' || token [ 0 ] == '[' || token [ 0 ] == ']' ) { token ++ ; } if ( ! strncmp ( token , "lsl" , 3 ) ) { op -> operands [ operand ] . shift = ARM_LSL ; } else if ( ! strncmp ( token , "lsr" , 3 ) ) { op -> operands [ operand ] . shift = ARM_LSR ; } else if ( ! strncmp ( token , "asr" , 3 ) ) { op -> operands [ operand ] . shift = ARM_ASR ; } <S2SV_StartBug> if ( op -> operands [ operand ] . shift != ARM_NO_SHIFT ) { <S2SV_EndBug> op -> operands_count ++ ; op -> operands [ operand ] . shift_amount = r_num_math ( NULL , token + 4 ) ; if ( op -> operands [ operand ] . shift_amount > 63 ) { return false ; } operand ++ ; token = next ; continue ; } switch ( token [ 0 ] ) { case 'x' : x = strchr ( token , ',' ) ; if ( x ) { x [ 0 ] = '\\0' ; } op -> operands_count ++ ; op -> operands [ operand ] . type = ARM_GPR ; op -> operands [ operand ] . reg_type = ARM_REG64 ; op -> operands [ operand ] . reg = r_num_math ( NULL , token + 1 ) ; if ( op -> operands [ operand ] . reg > 31 ) { return false ; } break ; case 'w' : op -> operands_count ++ ; op -> operands [ operand ] . type = ARM_GPR ; op -> operands [ operand ] . reg_type = ARM_REG32 ; op -> operands [ operand ] . reg = r_num_math ( NULL , token + 1 ) ; if ( op -> operands [ operand ] . reg > 31 ) { return false ; } break ; case 'v' : op -> operands_count ++ ; op -> operands [ operand ] . type = ARM_FP ; op -> operands [ operand ] . reg = r_num_math ( NULL , token + 1 ) ; break ; case 's' : case 'S' : if ( token [ 1 ] == 'P' || token [ 1 ] == 'p' ) { int i ; for ( i = 0 ; msr_const [ i ] . name ; i ++ ) { if ( ! r_str_ncasecmp ( token , msr_const [ i ] . name , strlen ( msr_const [ i ] . name ) ) ) { op -> operands [ operand ] . sp_val = msr_const [ i ] . val ; break ; } } op -> operands_count ++ ; op -> operands [ operand ] . type = ARM_GPR ; op -> operands [ operand ] . reg_type = ARM_SP | ARM_REG64 ; op -> operands [ operand ] . reg = 31 ; break ; } mem_opt = get_mem_option ( token ) ; if ( mem_opt != - 1 ) { op -> operands_count ++ ; op -> operands [ operand ] . type = ARM_MEM_OPT ; op -> operands [ operand ] . mem_option = mem_opt ; } break ; case 'L' : case 'l' : case 'I' : case 'i' : case 'N' : case 'n' : case 'O' : case 'o' : case 'p' : case 'P' : mem_opt = get_mem_option ( token ) ; if ( mem_opt != - 1 ) { op -> operands_count ++ ; op -> operands [ operand ] . type = ARM_MEM_OPT ; op -> operands [ operand ] . mem_option = mem_opt ; } break ; case '-' : op -> operands [ operand ] . sign = - 1 ; default : op -> operands_count ++ ; op -> operands [ operand ] . type = ARM_CONSTANT ; op -> operands [ operand ] . immediate = r_num_math ( NULL , token ) ; imm_count ++ ; break ; } token = next ; operand ++ ; if ( operand > MAX_OPERANDS ) { free ( t ) ; return false ; } } free ( t ) ; return true ; }
WORD32 ih264d_parse_decode_slice ( UWORD8 u1_is_idr_slice , UWORD8 u1_nal_ref_idc , dec_struct_t * ps_dec ) { dec_bit_stream_t * ps_bitstrm = ps_dec -> ps_bitstrm ; dec_pic_params_t * ps_pps ; dec_seq_params_t * ps_seq ; dec_slice_params_t * ps_cur_slice = ps_dec -> ps_cur_slice ; pocstruct_t s_tmp_poc ; WORD32 i_delta_poc [ 2 ] ; WORD32 i4_poc = 0 ; UWORD16 u2_first_mb_in_slice , u2_frame_num ; UWORD8 u1_field_pic_flag , u1_redundant_pic_cnt = 0 , u1_slice_type ; UWORD32 u4_idr_pic_id = 0 ; UWORD8 u1_bottom_field_flag , u1_pic_order_cnt_type ; UWORD8 u1_nal_unit_type ; UWORD32 * pu4_bitstrm_buf = ps_bitstrm -> pu4_buffer ; UWORD32 * pu4_bitstrm_ofst = & ps_bitstrm -> u4_ofst ; WORD8 i1_is_end_of_poc ; WORD32 ret , end_of_frame ; WORD32 prev_slice_err , num_mb_skipped ; UWORD8 u1_mbaff ; pocstruct_t * ps_cur_poc ; UWORD32 u4_temp ; WORD32 i_temp ; UWORD32 u4_call_end_of_pic = 0 ; ps_dec -> ps_dpb_cmds -> u1_dpb_commands_read_slc = 0 ; u2_first_mb_in_slice = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u2_first_mb_in_slice > ( ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) ) { return ERROR_CORRUPTED_SLICE ; } if ( ( ( u2_first_mb_in_slice << ps_cur_slice -> u1_mbaff_frame_flag ) <= ps_dec -> u2_cur_mb_addr ) && ( ps_dec -> u2_cur_mb_addr != 0 ) && ( ps_dec -> u4_first_slice_in_pic != 0 ) ) { return ERROR_CORRUPTED_SLICE ; } COPYTHECONTEXT ( "SH:<S2SV_blank>first_mb_in_slice" , u2_first_mb_in_slice ) ; u4_temp = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u4_temp > 9 ) return ERROR_INV_SLC_TYPE_T ; u1_slice_type = u4_temp ; COPYTHECONTEXT ( "SH:<S2SV_blank>slice_type" , ( u1_slice_type ) ) ; ps_dec -> u1_sl_typ_5_9 = 0 ; if ( u1_slice_type > 4 ) { u1_slice_type -= 5 ; ps_dec -> u1_sl_typ_5_9 = 1 ; } { UWORD32 skip ; if ( ( ps_dec -> i4_app_skip_mode == IVD_SKIP_PB ) || ( ps_dec -> i4_dec_skip_mode == IVD_SKIP_PB ) ) { UWORD32 u4_bit_stream_offset = 0 ; if ( ps_dec -> u1_nal_unit_type == IDR_SLICE_NAL ) { skip = 0 ; ps_dec -> i4_dec_skip_mode = IVD_SKIP_NONE ; } else if ( ( I_SLICE == u1_slice_type ) && ( 1 >= ps_dec -> ps_cur_sps -> u1_num_ref_frames ) ) { skip = 0 ; ps_dec -> i4_dec_skip_mode = IVD_SKIP_NONE ; } else { skip = 1 ; } if ( ( 0 == u2_first_mb_in_slice ) && ( 1 == ps_dec -> u4_prev_nal_skipped ) ) { skip = 0 ; } if ( skip ) { ps_dec -> u4_prev_nal_skipped = 1 ; ps_dec -> i4_dec_skip_mode = IVD_SKIP_PB ; return 0 ; } else { if ( 1 == ps_dec -> u4_prev_nal_skipped ) { ps_dec -> u4_return_to_app = 1 ; return 0 ; } } } } u4_temp = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u4_temp & MASK_ERR_PIC_SET_ID ) return ERROR_INV_SPS_PPS_T ; COPYTHECONTEXT ( "SH:<S2SV_blank>pic_parameter_set_id" , u4_temp ) ; ps_pps = & ps_dec -> ps_pps [ u4_temp ] ; if ( FALSE == ps_pps -> u1_is_valid ) { return ERROR_INV_SPS_PPS_T ; } ps_seq = ps_pps -> ps_sps ; if ( ! ps_seq ) return ERROR_INV_SPS_PPS_T ; if ( FALSE == ps_seq -> u1_is_valid ) return ERROR_INV_SPS_PPS_T ; u2_frame_num = ih264d_get_bits_h264 ( ps_bitstrm , ps_seq -> u1_bits_in_frm_num ) ; COPYTHECONTEXT ( "SH:<S2SV_blank>frame_num" , u2_frame_num ) ; if ( ! ps_seq -> u1_frame_mbs_only_flag ) { u1_field_pic_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( "SH:<S2SV_blank>field_pic_flag" , u1_field_pic_flag ) ; u1_bottom_field_flag = 0 ; if ( u1_field_pic_flag ) { ps_dec -> pu1_inv_scan = ( UWORD8 * ) gau1_ih264d_inv_scan_fld ; u1_bottom_field_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( "SH:<S2SV_blank>bottom_field_flag" , u1_bottom_field_flag ) ; } else { ps_dec -> pu1_inv_scan = ( UWORD8 * ) gau1_ih264d_inv_scan ; } } else { u1_field_pic_flag = 0 ; u1_bottom_field_flag = 0 ; ps_dec -> pu1_inv_scan = ( UWORD8 * ) gau1_ih264d_inv_scan ; } u1_nal_unit_type = SLICE_NAL ; if ( u1_is_idr_slice ) { if ( 0 == u1_field_pic_flag ) { ps_dec -> u1_top_bottom_decoded = TOP_FIELD_ONLY | BOT_FIELD_ONLY ; } u1_nal_unit_type = IDR_SLICE_NAL ; u4_idr_pic_id = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u4_idr_pic_id > 65535 ) return ERROR_INV_SPS_PPS_T ; COPYTHECONTEXT ( "SH:<S2SV_blank><S2SV_blank>" , u4_idr_pic_id ) ; } i_delta_poc [ 0 ] = i_delta_poc [ 1 ] = 0 ; s_tmp_poc . i4_pic_order_cnt_lsb = 0 ; s_tmp_poc . i4_delta_pic_order_cnt_bottom = 0 ; u1_pic_order_cnt_type = ps_seq -> u1_pic_order_cnt_type ; if ( u1_pic_order_cnt_type == 0 ) { i_temp = ih264d_get_bits_h264 ( ps_bitstrm , ps_seq -> u1_log2_max_pic_order_cnt_lsb_minus ) ; if ( i_temp < 0 || i_temp >= ps_seq -> i4_max_pic_order_cntLsb ) return ERROR_INV_SPS_PPS_T ; s_tmp_poc . i4_pic_order_cnt_lsb = i_temp ; COPYTHECONTEXT ( "SH:<S2SV_blank>pic_order_cnt_lsb" , s_tmp_poc . i4_pic_order_cnt_lsb ) ; if ( ( ps_pps -> u1_pic_order_present_flag == 1 ) && ( ! u1_field_pic_flag ) ) { s_tmp_poc . i4_delta_pic_order_cnt_bottom = ih264d_sev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; COPYTHECONTEXT ( "SH:<S2SV_blank>delta_pic_order_cnt_bottom" , s_tmp_poc . i4_delta_pic_order_cnt_bottom ) ; } } s_tmp_poc . i4_delta_pic_order_cnt [ 0 ] = 0 ; s_tmp_poc . i4_delta_pic_order_cnt [ 1 ] = 0 ; if ( u1_pic_order_cnt_type == 1 && ( ! ps_seq -> u1_delta_pic_order_always_zero_flag ) ) { s_tmp_poc . i4_delta_pic_order_cnt [ 0 ] = ih264d_sev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; COPYTHECONTEXT ( "SH:<S2SV_blank>delta_pic_order_cnt[0]" , s_tmp_poc . i4_delta_pic_order_cnt [ 0 ] ) ; if ( ps_pps -> u1_pic_order_present_flag && ! u1_field_pic_flag ) { s_tmp_poc . i4_delta_pic_order_cnt [ 1 ] = ih264d_sev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; COPYTHECONTEXT ( "SH:<S2SV_blank>delta_pic_order_cnt[1]" , s_tmp_poc . i4_delta_pic_order_cnt [ 1 ] ) ; } } if ( ps_pps -> u1_redundant_pic_cnt_present_flag ) { u4_temp = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( u4_temp > MAX_REDUNDANT_PIC_CNT ) return ERROR_INV_SPS_PPS_T ; u1_redundant_pic_cnt = u4_temp ; COPYTHECONTEXT ( "SH:<S2SV_blank>redundant_pic_cnt" , u1_redundant_pic_cnt ) ; } i1_is_end_of_poc = 0 ; if ( ! ps_dec -> u1_first_slice_in_stream ) { i1_is_end_of_poc = ih264d_is_end_of_pic ( u2_frame_num , u1_nal_ref_idc , & s_tmp_poc , & ps_dec -> s_cur_pic_poc , ps_cur_slice , u1_pic_order_cnt_type , u1_nal_unit_type , u4_idr_pic_id , u1_field_pic_flag , u1_bottom_field_flag ) ; if ( ( ps_dec -> u4_first_slice_in_pic == 2 ) && ( i1_is_end_of_poc == 0 ) ) { ps_dec -> ps_dec_err_status -> u1_err_flag |= REJECT_CUR_PIC ; i1_is_end_of_poc = 1 ; } else { ps_dec -> ps_dec_err_status -> u1_err_flag &= MASK_REJECT_CUR_PIC ; } } u1_mbaff = ps_seq -> u1_mb_aff_flag && ( ! u1_field_pic_flag ) ; prev_slice_err = 0 ; if ( i1_is_end_of_poc || ps_dec -> u1_first_slice_in_stream ) { if ( u2_frame_num != ps_dec -> u2_prv_frame_num && ps_dec -> u1_top_bottom_decoded != 0 && ps_dec -> u1_top_bottom_decoded != ( TOP_FIELD_ONLY | BOT_FIELD_ONLY ) ) { ps_dec -> u1_dangling_field = 1 ; if ( ps_dec -> u4_first_slice_in_pic ) { prev_slice_err = 1 ; } else { prev_slice_err = 2 ; } if ( ps_dec -> u1_top_bottom_decoded == TOP_FIELD_ONLY ) ps_cur_slice -> u1_bottom_field_flag = 1 ; else ps_cur_slice -> u1_bottom_field_flag = 0 ; num_mb_skipped = ( ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) - ps_dec -> u2_total_mbs_coded ; ps_cur_poc = & ps_dec -> s_cur_pic_poc ; u1_is_idr_slice = ps_cur_slice -> u1_nal_unit_type == IDR_SLICE_NAL ; } else if ( ps_dec -> u4_first_slice_in_pic == 2 ) { if ( u2_first_mb_in_slice > 0 ) { prev_slice_err = 1 ; num_mb_skipped = u2_first_mb_in_slice << u1_mbaff ; ps_cur_poc = & s_tmp_poc ; ps_cur_slice -> u4_idr_pic_id = u4_idr_pic_id ; ps_cur_slice -> u1_field_pic_flag = u1_field_pic_flag ; ps_cur_slice -> u1_bottom_field_flag = u1_bottom_field_flag ; ps_cur_slice -> i4_pic_order_cnt_lsb = s_tmp_poc . i4_pic_order_cnt_lsb ; ps_cur_slice -> u1_nal_unit_type = u1_nal_unit_type ; ps_cur_slice -> u1_redundant_pic_cnt = u1_redundant_pic_cnt ; ps_cur_slice -> u1_nal_ref_idc = u1_nal_ref_idc ; ps_cur_slice -> u1_pic_order_cnt_type = u1_pic_order_cnt_type ; } } else { if ( ps_dec -> u4_first_slice_in_pic ) { prev_slice_err = 1 ; num_mb_skipped = u2_first_mb_in_slice << u1_mbaff ; } else { prev_slice_err = 2 ; num_mb_skipped = ( ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) - ps_dec -> u2_total_mbs_coded ; } ps_cur_poc = & s_tmp_poc ; } } else { if ( ( u2_first_mb_in_slice << u1_mbaff ) > ps_dec -> u2_total_mbs_coded ) { prev_slice_err = 2 ; num_mb_skipped = ( u2_first_mb_in_slice << u1_mbaff ) - ps_dec -> u2_total_mbs_coded ; ps_cur_poc = & s_tmp_poc ; } else if ( ( u2_first_mb_in_slice << u1_mbaff ) < ps_dec -> u2_total_mbs_coded ) { return ERROR_CORRUPTED_SLICE ; } } if ( prev_slice_err ) { ret = ih264d_mark_err_slice_skip ( ps_dec , num_mb_skipped , u1_is_idr_slice , u2_frame_num , ps_cur_poc , prev_slice_err ) ; if ( ps_dec -> u1_dangling_field == 1 ) { ps_dec -> u1_second_field = 1 - ps_dec -> u1_second_field ; ps_cur_slice -> u1_bottom_field_flag = u1_bottom_field_flag ; ps_dec -> u2_prv_frame_num = u2_frame_num ; ps_dec -> u1_first_slice_in_stream = 0 ; return ERROR_DANGLING_FIELD_IN_PIC ; } if ( prev_slice_err == 2 ) { ps_dec -> u1_first_slice_in_stream = 0 ; return ERROR_INCOMPLETE_FRAME ; } if ( ps_dec -> u2_total_mbs_coded >= ps_dec -> u2_frm_ht_in_mbs * ps_dec -> u2_frm_wd_in_mbs ) { ps_dec -> u1_first_slice_in_stream = 0 ; return ERROR_IN_LAST_SLICE_OF_PIC ; } if ( ps_dec -> ps_dec_err_status -> u1_err_flag & REJECT_CUR_PIC ) { ih264d_err_pic_dispbuf_mgr ( ps_dec ) ; return ERROR_NEW_FRAME_EXPECTED ; } if ( ret != OK ) return ret ; i1_is_end_of_poc = 0 ; } if ( ps_dec -> u4_first_slice_in_pic == 0 ) ps_dec -> ps_parse_cur_slice ++ ; ps_dec -> u1_slice_header_done = 0 ; if ( ! ps_dec -> u1_first_slice_in_stream ) { UWORD8 uc_mbs_exceed = 0 ; if ( ps_dec -> u2_total_mbs_coded == ( ps_dec -> ps_cur_sps -> u2_max_mb_addr + 1 ) ) { if ( ps_dec -> u4_first_slice_in_pic == 0 ) uc_mbs_exceed = 1 ; } if ( i1_is_end_of_poc || uc_mbs_exceed ) { if ( 1 == ps_dec -> u1_last_pic_not_decoded ) { ret = ih264d_end_of_pic_dispbuf_mgr ( ps_dec ) ; if ( ret != OK ) return ret ; ret = ih264d_end_of_pic ( ps_dec , u1_is_idr_slice , u2_frame_num ) ; if ( ret != OK ) return ret ; # if WIN32 H264_DEC_DEBUG_PRINT ( "<S2SV_blank>------<S2SV_blank>PIC<S2SV_blank>SKIPPED<S2SV_blank>------\\n" ) ; # endif return RET_LAST_SKIP ; } else { ret = ih264d_end_of_pic ( ps_dec , u1_is_idr_slice , u2_frame_num ) ; if ( ret != OK ) return ret ; } } } if ( u1_field_pic_flag ) { ps_dec -> u2_prv_frame_num = u2_frame_num ; } if ( ps_cur_slice -> u1_mmco_equalto5 ) { WORD32 i4_temp_poc ; WORD32 i4_top_field_order_poc , i4_bot_field_order_poc ; if ( ! ps_cur_slice -> u1_field_pic_flag ) { i4_top_field_order_poc = ps_dec -> ps_cur_pic -> i4_top_field_order_cnt ; i4_bot_field_order_poc = ps_dec -> ps_cur_pic -> i4_bottom_field_order_cnt ; i4_temp_poc = MIN ( i4_top_field_order_poc , i4_bot_field_order_poc ) ; } else if ( ! ps_cur_slice -> u1_bottom_field_flag ) i4_temp_poc = ps_dec -> ps_cur_pic -> i4_top_field_order_cnt ; else i4_temp_poc = ps_dec -> ps_cur_pic -> i4_bottom_field_order_cnt ; ps_dec -> ps_cur_pic -> i4_top_field_order_cnt = i4_temp_poc - ps_dec -> ps_cur_pic -> i4_top_field_order_cnt ; ps_dec -> ps_cur_pic -> i4_bottom_field_order_cnt = i4_temp_poc - ps_dec -> ps_cur_pic -> i4_bottom_field_order_cnt ; ps_dec -> ps_cur_pic -> i4_poc = i4_temp_poc ; ps_dec -> ps_cur_pic -> i4_avg_poc = i4_temp_poc ; } if ( ps_dec -> u4_first_slice_in_pic == 2 ) { ret = ih264d_decode_pic_order_cnt ( u1_is_idr_slice , u2_frame_num , & ps_dec -> s_prev_pic_poc , & s_tmp_poc , ps_cur_slice , ps_pps , u1_nal_ref_idc , u1_bottom_field_flag , u1_field_pic_flag , & i4_poc ) ; if ( ret != OK ) return ret ; if ( i4_poc >= ps_dec -> i4_max_poc ) ps_dec -> i4_max_poc = i4_poc ; if ( i4_poc == 0 ) { ps_dec -> i4_prev_max_display_seq = ps_dec -> i4_prev_max_display_seq + ps_dec -> i4_max_poc + ps_dec -> u1_max_dec_frame_buffering + 1 ; ps_dec -> i4_max_poc = 0 ; } } ps_cur_slice -> i4_delta_pic_order_cnt [ 0 ] = i_delta_poc [ 0 ] ; ps_cur_slice -> i4_delta_pic_order_cnt [ 1 ] = i_delta_poc [ 1 ] ; ps_cur_slice -> u4_idr_pic_id = u4_idr_pic_id ; ps_cur_slice -> u2_first_mb_in_slice = u2_first_mb_in_slice ; ps_cur_slice -> u1_field_pic_flag = u1_field_pic_flag ; ps_cur_slice -> u1_bottom_field_flag = u1_bottom_field_flag ; ps_cur_slice -> u1_slice_type = u1_slice_type ; ps_cur_slice -> i4_pic_order_cnt_lsb = s_tmp_poc . i4_pic_order_cnt_lsb ; ps_cur_slice -> u1_nal_unit_type = u1_nal_unit_type ; ps_cur_slice -> u1_redundant_pic_cnt = u1_redundant_pic_cnt ; ps_cur_slice -> u1_nal_ref_idc = u1_nal_ref_idc ; ps_cur_slice -> u1_pic_order_cnt_type = u1_pic_order_cnt_type ; if ( ps_seq -> u1_frame_mbs_only_flag ) ps_cur_slice -> u1_direct_8x8_inference_flag = ps_seq -> u1_direct_8x8_inference_flag ; else ps_cur_slice -> u1_direct_8x8_inference_flag = 1 ; if ( u1_slice_type == B_SLICE ) { ps_cur_slice -> u1_direct_spatial_mv_pred_flag = ih264d_get_bit_h264 ( ps_bitstrm ) ; COPYTHECONTEXT ( "SH:<S2SV_blank>direct_spatial_mv_pred_flag" , ps_cur_slice -> u1_direct_spatial_mv_pred_flag ) ; if ( ps_cur_slice -> u1_direct_spatial_mv_pred_flag ) ps_cur_slice -> pf_decodeDirect = ih264d_decode_spatial_direct ; else ps_cur_slice -> pf_decodeDirect = ih264d_decode_temporal_direct ; if ( ! ( ( ps_pps -> ps_sps -> u1_mb_aff_flag ) && ( ! u1_field_pic_flag ) ) ) ps_dec -> pf_mvpred = ih264d_mvpred_nonmbaffB ; } else { if ( ! ( ( ps_pps -> ps_sps -> u1_mb_aff_flag ) && ( ! u1_field_pic_flag ) ) ) ps_dec -> pf_mvpred = ih264d_mvpred_nonmbaff ; } if ( ps_dec -> u4_first_slice_in_pic == 2 ) { if ( u2_first_mb_in_slice == 0 ) { ret = ih264d_start_of_pic ( ps_dec , i4_poc , & s_tmp_poc , u2_frame_num , ps_pps ) ; if ( ret != OK ) return ret ; } ps_dec -> u4_output_present = 0 ; { ih264d_get_next_display_field ( ps_dec , ps_dec -> ps_out_buffer , & ( ps_dec -> s_disp_op ) ) ; if ( 0 != ps_dec -> s_disp_op . u4_error_code ) { ps_dec -> u4_fmt_conv_cur_row = ps_dec -> s_disp_frame_info . u4_y_ht ; } else ps_dec -> u4_output_present = 1 ; } if ( ps_dec -> u1_separate_parse == 1 ) { if ( ps_dec -> u4_dec_thread_created == 0 ) { ithread_create ( ps_dec -> pv_dec_thread_handle , NULL , ( void * ) ih264d_decode_picture_thread , ( void * ) ps_dec ) ; ps_dec -> u4_dec_thread_created = 1 ; } if ( ( ps_dec -> u4_num_cores == 3 ) && ( ( ps_dec -> u4_app_disable_deblk_frm == 0 ) || ps_dec -> i1_recon_in_thread3_flag ) && ( ps_dec -> u4_bs_deblk_thread_created == 0 ) ) { ps_dec -> u4_start_recon_deblk = 0 ; ithread_create ( ps_dec -> pv_bs_deblk_thread_handle , NULL , ( void * ) ih264d_recon_deblk_thread , ( void * ) ps_dec ) ; ps_dec -> u4_bs_deblk_thread_created = 1 ; } } } { UWORD8 uc_nofield_nombaff ; uc_nofield_nombaff = ( ( ps_dec -> ps_cur_slice -> u1_field_pic_flag == 0 ) && ( ps_dec -> ps_cur_slice -> u1_mbaff_frame_flag == 0 ) && ( u1_slice_type != B_SLICE ) && ( ps_dec -> ps_cur_pps -> u1_wted_pred_flag == 0 ) ) ; if ( uc_nofield_nombaff ) { ps_dec -> p_form_mb_part_info = ih264d_form_mb_part_info_bp ; ps_dec -> p_motion_compensate = ih264d_motion_compensate_bp ; } else { ps_dec -> p_form_mb_part_info = ih264d_form_mb_part_info_mp ; ps_dec -> p_motion_compensate = ih264d_motion_compensate_mp ; } } { dec_err_status_t * ps_err = ps_dec -> ps_dec_err_status ; if ( ps_err -> u4_frm_sei_sync == u2_frame_num ) { ps_err -> u1_err_flag = ACCEPT_ALL_PICS ; ps_err -> u4_frm_sei_sync = SYNC_FRM_DEFAULT ; } ps_err -> u4_cur_frm = u2_frame_num ; } { WORD32 i4_skip_b_pic , i4_skip_p_pic ; i4_skip_b_pic = ( ps_dec -> u4_skip_frm_mask & B_SLC_BIT ) && ( B_SLICE == u1_slice_type ) && ( 0 == u1_nal_ref_idc ) ; i4_skip_p_pic = ( ps_dec -> u4_skip_frm_mask & P_SLC_BIT ) && ( P_SLICE == u1_slice_type ) && ( 0 == u1_nal_ref_idc ) ; if ( i4_skip_b_pic ) { ps_dec -> ps_cur_pic -> u4_pack_slc_typ |= B_SLC_BIT ; ps_dec -> u1_last_pic_not_decoded = 1 ; return OK ; } if ( i4_skip_p_pic ) { ps_dec -> ps_cur_pic -> u4_pack_slc_typ |= P_SLC_BIT ; ps_dec -> u1_last_pic_not_decoded = 1 ; return OK ; } } { UWORD16 u2_mb_x , u2_mb_y ; ps_dec -> i4_submb_ofst = ( ( u2_first_mb_in_slice << ps_cur_slice -> u1_mbaff_frame_flag ) * SUB_BLK_SIZE ) - SUB_BLK_SIZE ; if ( u2_first_mb_in_slice ) { UWORD8 u1_mb_aff ; UWORD8 u1_field_pic ; UWORD16 u2_frm_wd_in_mbs ; u2_frm_wd_in_mbs = ps_seq -> u2_frm_wd_in_mbs ; u1_mb_aff = ps_cur_slice -> u1_mbaff_frame_flag ; u1_field_pic = ps_cur_slice -> u1_field_pic_flag ; { UWORD32 x_offset ; UWORD32 y_offset ; UWORD32 u4_frame_stride ; tfr_ctxt_t * ps_trns_addr ; if ( ps_dec -> u1_separate_parse ) { ps_trns_addr = & ps_dec -> s_tran_addrecon_parse ; } else { ps_trns_addr = & ps_dec -> s_tran_addrecon ; } u2_mb_x = MOD ( u2_first_mb_in_slice , u2_frm_wd_in_mbs ) ; u2_mb_y = DIV ( u2_first_mb_in_slice , u2_frm_wd_in_mbs ) ; u2_mb_y <<= u1_mb_aff ; if ( ( u2_mb_x > u2_frm_wd_in_mbs - 1 ) || ( u2_mb_y > ps_dec -> u2_frm_ht_in_mbs - 1 ) ) { return ERROR_CORRUPTED_SLICE ; } u4_frame_stride = ps_dec -> u2_frm_wd_y << u1_field_pic ; x_offset = u2_mb_x << 4 ; y_offset = ( u2_mb_y * u4_frame_stride ) << 4 ; ps_trns_addr -> pu1_dest_y = ps_dec -> s_cur_pic . pu1_buf1 + x_offset + y_offset ; u4_frame_stride = ps_dec -> u2_frm_wd_uv << u1_field_pic ; x_offset >>= 1 ; y_offset = ( u2_mb_y * u4_frame_stride ) << 3 ; x_offset *= YUV420SP_FACTOR ; ps_trns_addr -> pu1_dest_u = ps_dec -> s_cur_pic . pu1_buf2 + x_offset + y_offset ; ps_trns_addr -> pu1_dest_v = ps_dec -> s_cur_pic . pu1_buf3 + x_offset + y_offset ; ps_trns_addr -> pu1_mb_y = ps_trns_addr -> pu1_dest_y ; ps_trns_addr -> pu1_mb_u = ps_trns_addr -> pu1_dest_u ; ps_trns_addr -> pu1_mb_v = ps_trns_addr -> pu1_dest_v ; if ( ps_dec -> u1_separate_parse == 1 ) { ps_dec -> ps_deblk_mbn = ps_dec -> ps_deblk_pic + ( u2_first_mb_in_slice << u1_mb_aff ) ; } else { ps_dec -> ps_deblk_mbn = ps_dec -> ps_deblk_pic + ( u2_first_mb_in_slice << u1_mb_aff ) ; } ps_dec -> u2_cur_mb_addr = ( u2_first_mb_in_slice << u1_mb_aff ) ; ps_dec -> ps_mv_cur = ps_dec -> s_cur_pic . ps_mv + ( ( u2_first_mb_in_slice << u1_mb_aff ) << 4 ) ; } } else { tfr_ctxt_t * ps_trns_addr ; if ( ps_dec -> u1_separate_parse ) { ps_trns_addr = & ps_dec -> s_tran_addrecon_parse ; } else { ps_trns_addr = & ps_dec -> s_tran_addrecon ; } u2_mb_x = 0xffff ; u2_mb_y = 0 ; ps_dec -> u2_cur_mb_addr = 0 ; ps_dec -> ps_deblk_mbn = ps_dec -> ps_deblk_pic ; ps_dec -> ps_mv_cur = ps_dec -> s_cur_pic . ps_mv ; ps_trns_addr -> pu1_dest_y = ps_dec -> s_cur_pic . pu1_buf1 ; ps_trns_addr -> pu1_dest_u = ps_dec -> s_cur_pic . pu1_buf2 ; ps_trns_addr -> pu1_dest_v = ps_dec -> s_cur_pic . pu1_buf3 ; ps_trns_addr -> pu1_mb_y = ps_trns_addr -> pu1_dest_y ; ps_trns_addr -> pu1_mb_u = ps_trns_addr -> pu1_dest_u ; ps_trns_addr -> pu1_mb_v = ps_trns_addr -> pu1_dest_v ; } ps_dec -> ps_part = ps_dec -> ps_parse_part_params ; ps_dec -> u2_mbx = ( MOD ( u2_first_mb_in_slice - 1 , ps_seq -> u2_frm_wd_in_mbs ) ) ; ps_dec -> u2_mby = ( DIV ( u2_first_mb_in_slice - 1 , ps_seq -> u2_frm_wd_in_mbs ) ) ; ps_dec -> u2_mby <<= ps_cur_slice -> u1_mbaff_frame_flag ; ps_dec -> i2_prev_slice_mbx = ps_dec -> u2_mbx ; ps_dec -> i2_prev_slice_mby = ps_dec -> u2_mby ; } ps_bitstrm -> u4_max_ofst += ps_dec -> ps_cur_pps -> u1_entropy_coding_mode ; ps_dec -> u1_B = ( u1_slice_type == B_SLICE ) ; ps_dec -> u4_next_mb_skip = 0 ; ps_dec -> ps_parse_cur_slice -> u4_first_mb_in_slice = ps_dec -> ps_cur_slice -> u2_first_mb_in_slice ; ps_dec -> ps_parse_cur_slice -> slice_type = ps_dec -> ps_cur_slice -> u1_slice_type ; ps_dec -> u4_start_recon_deblk = 1 ; { WORD32 num_entries ; WORD32 size ; UWORD8 * pu1_buf ; num_entries = MAX_FRAMES ; if ( ( 1 >= ps_dec -> ps_cur_sps -> u1_num_ref_frames ) && ( 0 == ps_dec -> i4_display_delay ) ) { num_entries = 1 ; } num_entries = ( ( 2 * num_entries ) + 1 ) ; if ( BASE_PROFILE_IDC != ps_dec -> ps_cur_sps -> u1_profile_idc ) { num_entries *= 2 ; } size = num_entries * sizeof ( void * ) ; size += PAD_MAP_IDX_POC * sizeof ( void * ) ; pu1_buf = ( UWORD8 * ) ps_dec -> pv_map_ref_idx_to_poc_buf ; pu1_buf += size * ps_dec -> u2_cur_slice_num ; ps_dec -> ps_parse_cur_slice -> ppv_map_ref_idx_to_poc = ( void * ) pu1_buf ; } if ( ps_dec -> u1_separate_parse ) { ps_dec -> ps_parse_cur_slice -> pv_tu_coeff_data_start = ps_dec -> pv_parse_tu_coeff_data ; } else { ps_dec -> pv_proc_tu_coeff_data = ps_dec -> pv_parse_tu_coeff_data ; } <S2SV_StartBug> ps_dec -> pu4_wt_ofsts = ps_dec -> pu4_wts_ofsts_mat ; <S2SV_EndBug> if ( u1_slice_type == I_SLICE ) { ps_dec -> ps_cur_pic -> u4_pack_slc_typ |= I_SLC_BIT ; ret = ih264d_parse_islice ( ps_dec , u2_first_mb_in_slice ) ; if ( ps_dec -> i4_pic_type != B_SLICE && ps_dec -> i4_pic_type != P_SLICE ) ps_dec -> i4_pic_type = I_SLICE ; } else if ( u1_slice_type == P_SLICE ) { ps_dec -> ps_cur_pic -> u4_pack_slc_typ |= P_SLC_BIT ; ret = ih264d_parse_pslice ( ps_dec , u2_first_mb_in_slice ) ; ps_dec -> u1_pr_sl_type = u1_slice_type ; if ( ps_dec -> i4_pic_type != B_SLICE ) ps_dec -> i4_pic_type = P_SLICE ; } else if ( u1_slice_type == B_SLICE ) { ps_dec -> ps_cur_pic -> u4_pack_slc_typ |= B_SLC_BIT ; ret = ih264d_parse_bslice ( ps_dec , u2_first_mb_in_slice ) ; ps_dec -> u1_pr_sl_type = u1_slice_type ; ps_dec -> i4_pic_type = B_SLICE ; } else return ERROR_INV_SLC_TYPE_T ; if ( ps_dec -> u1_slice_header_done ) { ps_dec -> u4_first_slice_in_pic = 0 ; ps_dec -> u1_first_slice_in_stream = 0 ; } if ( ret != OK ) return ret ; ps_dec -> u2_cur_slice_num ++ ; ps_dec -> i2_prev_slice_mbx = ps_dec -> u2_mbx ; ps_dec -> i2_prev_slice_mby = ps_dec -> u2_mby ; if ( ps_dec -> u2_total_mbs_coded >= ( ps_seq -> u2_max_mb_addr + 1 ) ) { ps_dec -> u1_pic_decode_done = 1 ; } { dec_err_status_t * ps_err = ps_dec -> ps_dec_err_status ; if ( ( ps_err -> u1_err_flag & REJECT_PB_PICS ) && ( ps_err -> u1_cur_pic_type == PIC_TYPE_I ) ) { ps_err -> u1_err_flag = ACCEPT_ALL_PICS ; } } PRINT_BIN_BIT_RATIO ( ps_dec ) return ret ; }
void vp8mt_decode_mb_rows ( VP8D_COMP * pbi , MACROBLOCKD * xd ) { VP8_COMMON * pc = & pbi -> common ; unsigned int i ; int j ; int filter_level = pc -> filter_level ; YV12_BUFFER_CONFIG * yv12_fb_new = pbi -> dec_fb_ref [ INTRA_FRAME ] ; if ( filter_level ) { <S2SV_StartBug> vpx_memset ( pbi -> mt_yabove_row [ 0 ] + VP8BORDERINPIXELS - 1 , 127 , yv12_fb_new -> y_width + 5 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( pbi -> mt_uabove_row [ 0 ] + ( VP8BORDERINPIXELS >> 1 ) - 1 , 127 , ( yv12_fb_new -> y_width >> 1 ) + 5 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( pbi -> mt_vabove_row [ 0 ] + ( VP8BORDERINPIXELS >> 1 ) - 1 , 127 , ( yv12_fb_new -> y_width >> 1 ) + 5 ) ; <S2SV_EndBug> for ( j = 1 ; j < pc -> mb_rows ; j ++ ) { <S2SV_StartBug> vpx_memset ( pbi -> mt_yabove_row [ j ] + VP8BORDERINPIXELS - 1 , ( unsigned char ) 129 , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( pbi -> mt_uabove_row [ j ] + ( VP8BORDERINPIXELS >> 1 ) - 1 , ( unsigned char ) 129 , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( pbi -> mt_vabove_row [ j ] + ( VP8BORDERINPIXELS >> 1 ) - 1 , ( unsigned char ) 129 , 1 ) ; <S2SV_EndBug> } for ( j = 0 ; j < pc -> mb_rows ; j ++ ) { <S2SV_StartBug> vpx_memset ( pbi -> mt_yleft_col [ j ] , ( unsigned char ) 129 , 16 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( pbi -> mt_uleft_col [ j ] , ( unsigned char ) 129 , 8 ) ; <S2SV_EndBug> <S2SV_StartBug> vpx_memset ( pbi -> mt_vleft_col [ j ] , ( unsigned char ) 129 , 8 ) ; <S2SV_EndBug> } vp8_loop_filter_frame_init ( pc , & pbi -> mb , filter_level ) ; } else vp8_setup_intra_recon_top_line ( yv12_fb_new ) ; setup_decoding_thread_data ( pbi , xd , pbi -> mb_row_di , pbi -> decoding_thread_count ) ; for ( i = 0 ; i < pbi -> decoding_thread_count ; i ++ ) sem_post ( & pbi -> h_event_start_decoding [ i ] ) ; mt_decode_mb_rows ( pbi , xd , 0 ) ; sem_wait ( & pbi -> h_event_end_decoding ) ; }
int yyparse ( void * yyscanner , YR_COMPILER * compiler ) { int yychar ; YY_INITIAL_VALUE ( static YYSTYPE yyval_default ; ) YYSTYPE yylval YY_INITIAL_VALUE ( = yyval_default ) ; int yynerrs ; int yystate ; int yyerrstatus ; yytype_int16 yyssa [ YYINITDEPTH ] ; yytype_int16 * yyss ; yytype_int16 * yyssp ; YYSTYPE yyvsa [ YYINITDEPTH ] ; YYSTYPE * yyvs ; YYSTYPE * yyvsp ; YYSIZE_T yystacksize ; int yyn ; int yyresult ; int yytoken = 0 ; YYSTYPE yyval ; # if YYERROR_VERBOSE char yymsgbuf [ 128 ] ; char * yymsg = yymsgbuf ; YYSIZE_T yymsg_alloc = sizeof yymsgbuf ; # endif # define YYPOPSTACK ( N ) ( yyvsp -= ( N ) , yyssp -= ( N ) ) int yylen = 0 ; yyssp = yyss = yyssa ; yyvsp = yyvs = yyvsa ; yystacksize = YYINITDEPTH ; YYDPRINTF ( ( stderr , "Starting<S2SV_blank>parse\\n" ) ) ; yystate = 0 ; yyerrstatus = 0 ; yynerrs = 0 ; yychar = YYEMPTY ; goto yysetstate ; yynewstate : yyssp ++ ; yysetstate : * yyssp = yystate ; if ( yyss + yystacksize - 1 <= yyssp ) { YYSIZE_T yysize = yyssp - yyss + 1 ; # ifdef yyoverflow { YYSTYPE * yyvs1 = yyvs ; yytype_int16 * yyss1 = yyss ; yyoverflow ( YY_ ( "memory<S2SV_blank>exhausted" ) , & yyss1 , yysize * sizeof ( * yyssp ) , & yyvs1 , yysize * sizeof ( * yyvsp ) , & yystacksize ) ; yyss = yyss1 ; yyvs = yyvs1 ; } # else # ifndef YYSTACK_RELOCATE goto yyexhaustedlab ; # else if ( YYMAXDEPTH <= yystacksize ) goto yyexhaustedlab ; yystacksize *= 2 ; if ( YYMAXDEPTH < yystacksize ) yystacksize = YYMAXDEPTH ; { yytype_int16 * yyss1 = yyss ; union yyalloc * yyptr = ( union yyalloc * ) YYSTACK_ALLOC ( YYSTACK_BYTES ( yystacksize ) ) ; if ( ! yyptr ) goto yyexhaustedlab ; YYSTACK_RELOCATE ( yyss_alloc , yyss ) ; YYSTACK_RELOCATE ( yyvs_alloc , yyvs ) ; # undef YYSTACK_RELOCATE if ( yyss1 != yyssa ) YYSTACK_FREE ( yyss1 ) ; } # endif # endif yyssp = yyss + yysize - 1 ; yyvsp = yyvs + yysize - 1 ; YYDPRINTF ( ( stderr , "Stack<S2SV_blank>size<S2SV_blank>increased<S2SV_blank>to<S2SV_blank>%lu\\n" , ( unsigned long int ) yystacksize ) ) ; if ( yyss + yystacksize - 1 <= yyssp ) YYABORT ; } YYDPRINTF ( ( stderr , "Entering<S2SV_blank>state<S2SV_blank>%d\\n" , yystate ) ) ; if ( yystate == YYFINAL ) YYACCEPT ; goto yybackup ; yybackup : yyn = yypact [ yystate ] ; if ( yypact_value_is_default ( yyn ) ) goto yydefault ; if ( yychar == YYEMPTY ) { YYDPRINTF ( ( stderr , "Reading<S2SV_blank>a<S2SV_blank>token:<S2SV_blank>" ) ) ; yychar = yylex ( & yylval , yyscanner , compiler ) ; } if ( yychar <= YYEOF ) { yychar = yytoken = YYEOF ; YYDPRINTF ( ( stderr , "Now<S2SV_blank>at<S2SV_blank>end<S2SV_blank>of<S2SV_blank>input.\\n" ) ) ; } else { yytoken = YYTRANSLATE ( yychar ) ; YY_SYMBOL_PRINT ( "Next<S2SV_blank>token<S2SV_blank>is" , yytoken , & yylval , & yylloc ) ; } yyn += yytoken ; if ( yyn < 0 || YYLAST < yyn || yycheck [ yyn ] != yytoken ) goto yydefault ; yyn = yytable [ yyn ] ; if ( yyn <= 0 ) { if ( yytable_value_is_error ( yyn ) ) goto yyerrlab ; yyn = - yyn ; goto yyreduce ; } if ( yyerrstatus ) yyerrstatus -- ; YY_SYMBOL_PRINT ( "Shifting" , yytoken , & yylval , & yylloc ) ; yychar = YYEMPTY ; yystate = yyn ; YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN * ++ yyvsp = yylval ; YY_IGNORE_MAYBE_UNINITIALIZED_END goto yynewstate ; yydefault : yyn = yydefact [ yystate ] ; if ( yyn == 0 ) goto yyerrlab ; goto yyreduce ; yyreduce : yylen = yyr2 [ yyn ] ; yyval = yyvsp [ 1 - yylen ] ; YY_REDUCE_PRINT ( yyn ) ; switch ( yyn ) { case 8 : # line 230 "grammar.y" { int result = yr_parser_reduce_import ( yyscanner , ( yyvsp [ 0 ] . sized_string ) ) ; yr_free ( ( yyvsp [ 0 ] . sized_string ) ) ; ERROR_IF ( result != ERROR_SUCCESS ) ; } # line 1661 "grammar.c" break ; case 9 : # line 242 "grammar.y" { YR_RULE * rule = yr_parser_reduce_rule_declaration_phase_1 ( yyscanner , ( int32_t ) ( yyvsp [ - 2 ] . integer ) , ( yyvsp [ 0 ] . c_string ) ) ; ERROR_IF ( rule == NULL ) ; ( yyval . rule ) = rule ; } # line 1674 "grammar.c" break ; case 10 : # line 251 "grammar.y" { YR_RULE * rule = ( yyvsp [ - 4 ] . rule ) ; rule -> tags = ( yyvsp [ - 3 ] . c_string ) ; rule -> metas = ( yyvsp [ - 1 ] . meta ) ; rule -> strings = ( yyvsp [ 0 ] . string ) ; } # line 1686 "grammar.c" break ; case 11 : # line 259 "grammar.y" { YR_RULE * rule = ( yyvsp [ - 7 ] . rule ) ; compiler -> last_result = yr_parser_reduce_rule_declaration_phase_2 ( yyscanner , rule ) ; yr_free ( ( yyvsp [ - 8 ] . c_string ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } # line 1701 "grammar.c" break ; case 12 : # line 274 "grammar.y" { ( yyval . meta ) = NULL ; } # line 1709 "grammar.c" break ; case 13 : # line 278 "grammar.y" { YR_META null_meta ; memset ( & null_meta , 0xFF , sizeof ( YR_META ) ) ; null_meta . type = META_TYPE_NULL ; compiler -> last_result = yr_arena_write_data ( compiler -> metas_arena , & null_meta , sizeof ( YR_META ) , NULL ) ; ( yyval . meta ) = ( yyvsp [ 0 ] . meta ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } # line 1736 "grammar.c" break ; case 14 : # line 305 "grammar.y" { ( yyval . string ) = NULL ; } # line 1744 "grammar.c" break ; case 15 : # line 309 "grammar.y" { YR_STRING null_string ; memset ( & null_string , 0xFF , sizeof ( YR_STRING ) ) ; null_string . g_flags = STRING_GFLAGS_NULL ; compiler -> last_result = yr_arena_write_data ( compiler -> strings_arena , & null_string , sizeof ( YR_STRING ) , NULL ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . string ) = ( yyvsp [ 0 ] . string ) ; } # line 1771 "grammar.c" break ; case 17 : # line 340 "grammar.y" { ( yyval . integer ) = 0 ; } # line 1777 "grammar.c" break ; case 18 : # line 341 "grammar.y" { ( yyval . integer ) = ( yyvsp [ - 1 ] . integer ) | ( yyvsp [ 0 ] . integer ) ; } # line 1783 "grammar.c" break ; case 19 : # line 346 "grammar.y" { ( yyval . integer ) = RULE_GFLAGS_PRIVATE ; } # line 1789 "grammar.c" break ; case 20 : # line 347 "grammar.y" { ( yyval . integer ) = RULE_GFLAGS_GLOBAL ; } # line 1795 "grammar.c" break ; case 21 : # line 353 "grammar.y" { ( yyval . c_string ) = NULL ; } # line 1803 "grammar.c" break ; case 22 : # line 357 "grammar.y" { compiler -> last_result = yr_arena_write_string ( yyget_extra ( yyscanner ) -> sz_arena , "" , NULL ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . c_string ) = ( yyvsp [ 0 ] . c_string ) ; } # line 1821 "grammar.c" break ; case 23 : # line 375 "grammar.y" { char * identifier ; compiler -> last_result = yr_arena_write_string ( yyget_extra ( yyscanner ) -> sz_arena , ( yyvsp [ 0 ] . c_string ) , & identifier ) ; yr_free ( ( yyvsp [ 0 ] . c_string ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . c_string ) = identifier ; } # line 1838 "grammar.c" break ; case 24 : # line 388 "grammar.y" { char * tag_name = ( yyvsp [ - 1 ] . c_string ) ; size_t tag_length = tag_name != NULL ? strlen ( tag_name ) : 0 ; while ( tag_length > 0 ) { if ( strcmp ( tag_name , ( yyvsp [ 0 ] . c_string ) ) == 0 ) { yr_compiler_set_error_extra_info ( compiler , tag_name ) ; compiler -> last_result = ERROR_DUPLICATED_TAG_IDENTIFIER ; break ; } tag_name = ( char * ) yr_arena_next_address ( yyget_extra ( yyscanner ) -> sz_arena , tag_name , tag_length + 1 ) ; tag_length = tag_name != NULL ? strlen ( tag_name ) : 0 ; } if ( compiler -> last_result == ERROR_SUCCESS ) compiler -> last_result = yr_arena_write_string ( yyget_extra ( yyscanner ) -> sz_arena , ( yyvsp [ 0 ] . c_string ) , NULL ) ; yr_free ( ( yyvsp [ 0 ] . c_string ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . c_string ) = ( yyvsp [ - 1 ] . c_string ) ; } # line 1874 "grammar.c" break ; case 25 : # line 424 "grammar.y" { ( yyval . meta ) = ( yyvsp [ 0 ] . meta ) ; } # line 1880 "grammar.c" break ; case 26 : # line 425 "grammar.y" { ( yyval . meta ) = ( yyvsp [ - 1 ] . meta ) ; } # line 1886 "grammar.c" break ; case 27 : # line 431 "grammar.y" { SIZED_STRING * sized_string = ( yyvsp [ 0 ] . sized_string ) ; ( yyval . meta ) = yr_parser_reduce_meta_declaration ( yyscanner , META_TYPE_STRING , ( yyvsp [ - 2 ] . c_string ) , sized_string -> c_string , 0 ) ; yr_free ( ( yyvsp [ - 2 ] . c_string ) ) ; yr_free ( ( yyvsp [ 0 ] . sized_string ) ) ; ERROR_IF ( ( yyval . meta ) == NULL ) ; } # line 1906 "grammar.c" break ; case 28 : # line 447 "grammar.y" { ( yyval . meta ) = yr_parser_reduce_meta_declaration ( yyscanner , META_TYPE_INTEGER , ( yyvsp [ - 2 ] . c_string ) , NULL , ( yyvsp [ 0 ] . integer ) ) ; yr_free ( ( yyvsp [ - 2 ] . c_string ) ) ; ERROR_IF ( ( yyval . meta ) == NULL ) ; } # line 1923 "grammar.c" break ; case 29 : # line 460 "grammar.y" { ( yyval . meta ) = yr_parser_reduce_meta_declaration ( yyscanner , META_TYPE_INTEGER , ( yyvsp [ - 3 ] . c_string ) , NULL , - ( yyvsp [ 0 ] . integer ) ) ; yr_free ( ( yyvsp [ - 3 ] . c_string ) ) ; ERROR_IF ( ( yyval . meta ) == NULL ) ; } # line 1940 "grammar.c" break ; case 30 : # line 473 "grammar.y" { ( yyval . meta ) = yr_parser_reduce_meta_declaration ( yyscanner , META_TYPE_BOOLEAN , ( yyvsp [ - 2 ] . c_string ) , NULL , TRUE ) ; yr_free ( ( yyvsp [ - 2 ] . c_string ) ) ; ERROR_IF ( ( yyval . meta ) == NULL ) ; } # line 1957 "grammar.c" break ; case 31 : # line 486 "grammar.y" { ( yyval . meta ) = yr_parser_reduce_meta_declaration ( yyscanner , META_TYPE_BOOLEAN , ( yyvsp [ - 2 ] . c_string ) , NULL , FALSE ) ; yr_free ( ( yyvsp [ - 2 ] . c_string ) ) ; ERROR_IF ( ( yyval . meta ) == NULL ) ; } # line 1974 "grammar.c" break ; case 32 : # line 502 "grammar.y" { ( yyval . string ) = ( yyvsp [ 0 ] . string ) ; } # line 1980 "grammar.c" break ; case 33 : # line 503 "grammar.y" { ( yyval . string ) = ( yyvsp [ - 1 ] . string ) ; } # line 1986 "grammar.c" break ; case 34 : # line 509 "grammar.y" { compiler -> error_line = yyget_lineno ( yyscanner ) ; } # line 1994 "grammar.c" break ; case 35 : # line 513 "grammar.y" { ( yyval . string ) = yr_parser_reduce_string_declaration ( yyscanner , ( int32_t ) ( yyvsp [ 0 ] . integer ) , ( yyvsp [ - 4 ] . c_string ) , ( yyvsp [ - 1 ] . sized_string ) ) ; yr_free ( ( yyvsp [ - 4 ] . c_string ) ) ; yr_free ( ( yyvsp [ - 1 ] . sized_string ) ) ; ERROR_IF ( ( yyval . string ) == NULL ) ; compiler -> error_line = 0 ; } # line 2009 "grammar.c" break ; case 36 : # line 524 "grammar.y" { compiler -> error_line = yyget_lineno ( yyscanner ) ; } # line 2017 "grammar.c" break ; case 37 : # line 528 "grammar.y" { ( yyval . string ) = yr_parser_reduce_string_declaration ( yyscanner , ( int32_t ) ( yyvsp [ 0 ] . integer ) | STRING_GFLAGS_REGEXP , ( yyvsp [ - 4 ] . c_string ) , ( yyvsp [ - 1 ] . sized_string ) ) ; yr_free ( ( yyvsp [ - 4 ] . c_string ) ) ; yr_free ( ( yyvsp [ - 1 ] . sized_string ) ) ; ERROR_IF ( ( yyval . string ) == NULL ) ; compiler -> error_line = 0 ; } # line 2033 "grammar.c" break ; case 38 : # line 540 "grammar.y" { ( yyval . string ) = yr_parser_reduce_string_declaration ( yyscanner , STRING_GFLAGS_HEXADECIMAL , ( yyvsp [ - 2 ] . c_string ) , ( yyvsp [ 0 ] . sized_string ) ) ; yr_free ( ( yyvsp [ - 2 ] . c_string ) ) ; yr_free ( ( yyvsp [ 0 ] . sized_string ) ) ; ERROR_IF ( ( yyval . string ) == NULL ) ; } # line 2047 "grammar.c" break ; case 39 : # line 553 "grammar.y" { ( yyval . integer ) = 0 ; } # line 2053 "grammar.c" break ; case 40 : # line 554 "grammar.y" { ( yyval . integer ) = ( yyvsp [ - 1 ] . integer ) | ( yyvsp [ 0 ] . integer ) ; } # line 2059 "grammar.c" break ; case 41 : # line 559 "grammar.y" { ( yyval . integer ) = STRING_GFLAGS_WIDE ; } # line 2065 "grammar.c" break ; case 42 : # line 560 "grammar.y" { ( yyval . integer ) = STRING_GFLAGS_ASCII ; } # line 2071 "grammar.c" break ; case 43 : # line 561 "grammar.y" { ( yyval . integer ) = STRING_GFLAGS_NO_CASE ; } # line 2077 "grammar.c" break ; case 44 : # line 562 "grammar.y" { ( yyval . integer ) = STRING_GFLAGS_FULL_WORD ; } # line 2083 "grammar.c" break ; case 45 : # line 568 "grammar.y" { int var_index = yr_parser_lookup_loop_variable ( yyscanner , ( yyvsp [ 0 ] . c_string ) ) ; if ( var_index >= 0 ) { compiler -> last_result = yr_parser_emit_with_arg ( yyscanner , OP_PUSH_M , LOOP_LOCAL_VARS * var_index , NULL , NULL ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = UNDEFINED ; ( yyval . expression ) . identifier = compiler -> loop_identifier [ var_index ] ; } else { YR_OBJECT * object = ( YR_OBJECT * ) yr_hash_table_lookup ( compiler -> objects_table , ( yyvsp [ 0 ] . c_string ) , NULL ) ; if ( object == NULL ) { char * ns = compiler -> current_namespace -> name ; object = ( YR_OBJECT * ) yr_hash_table_lookup ( compiler -> objects_table , ( yyvsp [ 0 ] . c_string ) , ns ) ; } if ( object != NULL ) { char * id ; compiler -> last_result = yr_arena_write_string ( compiler -> sz_arena , ( yyvsp [ 0 ] . c_string ) , & id ) ; if ( compiler -> last_result == ERROR_SUCCESS ) compiler -> last_result = yr_parser_emit_with_arg_reloc ( yyscanner , OP_OBJ_LOAD , id , NULL , NULL ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_OBJECT ; ( yyval . expression ) . value . object = object ; ( yyval . expression ) . identifier = object -> identifier ; } else { YR_RULE * rule = ( YR_RULE * ) yr_hash_table_lookup ( compiler -> rules_table , ( yyvsp [ 0 ] . c_string ) , compiler -> current_namespace -> name ) ; if ( rule != NULL ) { compiler -> last_result = yr_parser_emit_with_arg_reloc ( yyscanner , OP_PUSH_RULE , rule , NULL , NULL ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; ( yyval . expression ) . value . integer = UNDEFINED ; ( yyval . expression ) . identifier = rule -> identifier ; } else { yr_compiler_set_error_extra_info ( compiler , ( yyvsp [ 0 ] . c_string ) ) ; compiler -> last_result = ERROR_UNDEFINED_IDENTIFIER ; } } } yr_free ( ( yyvsp [ 0 ] . c_string ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } # line 2172 "grammar.c" break ; case 46 : # line 653 "grammar.y" { YR_OBJECT * field = NULL ; if ( ( yyvsp [ - 2 ] . expression ) . type == EXPRESSION_TYPE_OBJECT && ( yyvsp [ - 2 ] . expression ) . value . object -> type == OBJECT_TYPE_STRUCTURE ) { field = yr_object_lookup_field ( ( yyvsp [ - 2 ] . expression ) . value . object , ( yyvsp [ 0 ] . c_string ) ) ; if ( field != NULL ) { char * ident ; compiler -> last_result = yr_arena_write_string ( compiler -> sz_arena , ( yyvsp [ 0 ] . c_string ) , & ident ) ; if ( compiler -> last_result == ERROR_SUCCESS ) compiler -> last_result = yr_parser_emit_with_arg_reloc ( yyscanner , OP_OBJ_FIELD , ident , NULL , NULL ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_OBJECT ; ( yyval . expression ) . value . object = field ; ( yyval . expression ) . identifier = field -> identifier ; } else { yr_compiler_set_error_extra_info ( compiler , ( yyvsp [ 0 ] . c_string ) ) ; compiler -> last_result = ERROR_INVALID_FIELD_NAME ; } } else { yr_compiler_set_error_extra_info ( compiler , ( yyvsp [ - 2 ] . expression ) . identifier ) ; compiler -> last_result = ERROR_NOT_A_STRUCTURE ; } yr_free ( ( yyvsp [ 0 ] . c_string ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } # line 2222 "grammar.c" break ; case 47 : # line 699 "grammar.y" { YR_OBJECT_ARRAY * array ; YR_OBJECT_DICTIONARY * dict ; if ( ( yyvsp [ - 3 ] . expression ) . type == EXPRESSION_TYPE_OBJECT && ( yyvsp [ - 3 ] . expression ) . value . object -> type == OBJECT_TYPE_ARRAY ) { if ( ( yyvsp [ - 1 ] . expression ) . type != EXPRESSION_TYPE_INTEGER ) { yr_compiler_set_error_extra_info ( compiler , "array<S2SV_blank>indexes<S2SV_blank>must<S2SV_blank>be<S2SV_blank>of<S2SV_blank>integer<S2SV_blank>type" ) ; compiler -> last_result = ERROR_WRONG_TYPE ; } ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; compiler -> last_result = yr_parser_emit ( yyscanner , OP_INDEX_ARRAY , NULL ) ; array = ( YR_OBJECT_ARRAY * ) ( yyvsp [ - 3 ] . expression ) . value . object ; ( yyval . expression ) . type = EXPRESSION_TYPE_OBJECT ; ( yyval . expression ) . value . object = array -> prototype_item ; ( yyval . expression ) . identifier = array -> identifier ; } else if ( ( yyvsp [ - 3 ] . expression ) . type == EXPRESSION_TYPE_OBJECT && ( yyvsp [ - 3 ] . expression ) . value . object -> type == OBJECT_TYPE_DICTIONARY ) { if ( ( yyvsp [ - 1 ] . expression ) . type != EXPRESSION_TYPE_STRING ) { yr_compiler_set_error_extra_info ( compiler , "dictionary<S2SV_blank>keys<S2SV_blank>must<S2SV_blank>be<S2SV_blank>of<S2SV_blank>string<S2SV_blank>type" ) ; compiler -> last_result = ERROR_WRONG_TYPE ; } ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; compiler -> last_result = yr_parser_emit ( yyscanner , OP_LOOKUP_DICT , NULL ) ; dict = ( YR_OBJECT_DICTIONARY * ) ( yyvsp [ - 3 ] . expression ) . value . object ; ( yyval . expression ) . type = EXPRESSION_TYPE_OBJECT ; ( yyval . expression ) . value . object = dict -> prototype_item ; ( yyval . expression ) . identifier = dict -> identifier ; } else { yr_compiler_set_error_extra_info ( compiler , ( yyvsp [ - 3 ] . expression ) . identifier ) ; compiler -> last_result = ERROR_NOT_INDEXABLE ; } ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } # line 2283 "grammar.c" break ; case 48 : # line 757 "grammar.y" { YR_OBJECT_FUNCTION * function ; char * args_fmt ; if ( ( yyvsp [ - 3 ] . expression ) . type == EXPRESSION_TYPE_OBJECT && ( yyvsp [ - 3 ] . expression ) . value . object -> type == OBJECT_TYPE_FUNCTION ) { compiler -> last_result = yr_parser_check_types ( compiler , ( YR_OBJECT_FUNCTION * ) ( yyvsp [ - 3 ] . expression ) . value . object , ( yyvsp [ - 1 ] . c_string ) ) ; if ( compiler -> last_result == ERROR_SUCCESS ) compiler -> last_result = yr_arena_write_string ( compiler -> sz_arena , ( yyvsp [ - 1 ] . c_string ) , & args_fmt ) ; if ( compiler -> last_result == ERROR_SUCCESS ) compiler -> last_result = yr_parser_emit_with_arg_reloc ( yyscanner , OP_CALL , args_fmt , NULL , NULL ) ; function = ( YR_OBJECT_FUNCTION * ) ( yyvsp [ - 3 ] . expression ) . value . object ; ( yyval . expression ) . type = EXPRESSION_TYPE_OBJECT ; ( yyval . expression ) . value . object = function -> return_obj ; ( yyval . expression ) . identifier = function -> identifier ; } else { yr_compiler_set_error_extra_info ( compiler , ( yyvsp [ - 3 ] . expression ) . identifier ) ; compiler -> last_result = ERROR_NOT_A_FUNCTION ; } yr_free ( ( yyvsp [ - 1 ] . c_string ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } # line 2328 "grammar.c" break ; case 49 : # line 801 "grammar.y" { ( yyval . c_string ) = yr_strdup ( "" ) ; } # line 2334 "grammar.c" break ; case 50 : # line 802 "grammar.y" { ( yyval . c_string ) = ( yyvsp [ 0 ] . c_string ) ; } # line 2340 "grammar.c" break ; case 51 : # line 807 "grammar.y" { ( yyval . c_string ) = ( char * ) yr_malloc ( MAX_FUNCTION_ARGS + 1 ) ; switch ( ( yyvsp [ 0 ] . expression ) . type ) { case EXPRESSION_TYPE_INTEGER : strlcpy ( ( yyval . c_string ) , "i" , MAX_FUNCTION_ARGS ) ; break ; case EXPRESSION_TYPE_FLOAT : strlcpy ( ( yyval . c_string ) , "f" , MAX_FUNCTION_ARGS ) ; break ; case EXPRESSION_TYPE_BOOLEAN : strlcpy ( ( yyval . c_string ) , "b" , MAX_FUNCTION_ARGS ) ; break ; case EXPRESSION_TYPE_STRING : strlcpy ( ( yyval . c_string ) , "s" , MAX_FUNCTION_ARGS ) ; break ; case EXPRESSION_TYPE_REGEXP : strlcpy ( ( yyval . c_string ) , "r" , MAX_FUNCTION_ARGS ) ; break ; <S2SV_StartBug> } <S2SV_EndBug> ERROR_IF ( ( yyval . c_string ) == NULL ) ; } <S2SV_StartBug> # line 2369 "grammar.c" <S2SV_EndBug> break ; case 52 : <S2SV_StartBug> # line 832 "grammar.y" <S2SV_EndBug> { if ( strlen ( ( yyvsp [ - 2 ] . c_string ) ) == MAX_FUNCTION_ARGS ) { compiler -> last_result = ERROR_TOO_MANY_ARGUMENTS ; } else { switch ( ( yyvsp [ 0 ] . expression ) . type ) { case EXPRESSION_TYPE_INTEGER : strlcat ( ( yyvsp [ - 2 ] . c_string ) , "i" , MAX_FUNCTION_ARGS ) ; break ; case EXPRESSION_TYPE_FLOAT : strlcat ( ( yyvsp [ - 2 ] . c_string ) , "f" , MAX_FUNCTION_ARGS ) ; break ; case EXPRESSION_TYPE_BOOLEAN : strlcat ( ( yyvsp [ - 2 ] . c_string ) , "b" , MAX_FUNCTION_ARGS ) ; break ; case EXPRESSION_TYPE_STRING : strlcat ( ( yyvsp [ - 2 ] . c_string ) , "s" , MAX_FUNCTION_ARGS ) ; break ; case EXPRESSION_TYPE_REGEXP : strlcat ( ( yyvsp [ - 2 ] . c_string ) , "r" , MAX_FUNCTION_ARGS ) ; break ; <S2SV_StartBug> } <S2SV_EndBug> } ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . c_string ) = ( yyvsp [ - 2 ] . c_string ) ; } <S2SV_StartBug> # line 2405 "grammar.c" <S2SV_EndBug> break ; case 53 : <S2SV_StartBug> # line 868 "grammar.y" <S2SV_EndBug> { SIZED_STRING * sized_string = ( yyvsp [ 0 ] . sized_string ) ; RE * re ; RE_ERROR error ; int re_flags = 0 ; if ( sized_string -> flags & SIZED_STRING_FLAGS_NO_CASE ) re_flags |= RE_FLAGS_NO_CASE ; if ( sized_string -> flags & SIZED_STRING_FLAGS_DOT_ALL ) re_flags |= RE_FLAGS_DOT_ALL ; compiler -> last_result = yr_re_compile ( sized_string -> c_string , re_flags , compiler -> re_code_arena , & re , & error ) ; yr_free ( ( yyvsp [ 0 ] . sized_string ) ) ; if ( compiler -> last_result == ERROR_INVALID_REGULAR_EXPRESSION ) yr_compiler_set_error_extra_info ( compiler , error . message ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; if ( compiler -> last_result == ERROR_SUCCESS ) compiler -> last_result = yr_parser_emit_with_arg_reloc ( yyscanner , OP_PUSH , re -> root_node -> forward_code , NULL , NULL ) ; yr_re_destroy ( re ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_REGEXP ; } <S2SV_StartBug> # line 2451 "grammar.c" <S2SV_EndBug> break ; case 54 : <S2SV_StartBug> # line 914 "grammar.y" <S2SV_EndBug> { if ( ( yyvsp [ 0 ] . expression ) . type == EXPRESSION_TYPE_STRING ) { if ( ( yyvsp [ 0 ] . expression ) . value . sized_string != NULL ) { yywarning ( yyscanner , "Using<S2SV_blank>literal<S2SV_blank>string<S2SV_blank>\\"%s\\"<S2SV_blank>in<S2SV_blank>a<S2SV_blank>boolean<S2SV_blank>operation." , ( yyvsp [ 0 ] . expression ) . value . sized_string -> c_string ) ; } compiler -> last_result = yr_parser_emit ( yyscanner , OP_STR_TO_BOOL , NULL ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 2474 "grammar.c" <S2SV_EndBug> break ; case 55 : <S2SV_StartBug> # line 936 "grammar.y" <S2SV_EndBug> { compiler -> last_result = yr_parser_emit_with_arg ( yyscanner , OP_PUSH , 1 , NULL , NULL ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 2487 "grammar.c" <S2SV_EndBug> break ; case 56 : <S2SV_StartBug> # line 945 "grammar.y" <S2SV_EndBug> { compiler -> last_result = yr_parser_emit_with_arg ( yyscanner , OP_PUSH , 0 , NULL , NULL ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 2500 "grammar.c" <S2SV_EndBug> break ; case 57 : <S2SV_StartBug> # line 954 "grammar.y" <S2SV_EndBug> { CHECK_TYPE ( ( yyvsp [ - 2 ] . expression ) , EXPRESSION_TYPE_STRING , "matches" ) ; CHECK_TYPE ( ( yyvsp [ 0 ] . expression ) , EXPRESSION_TYPE_REGEXP , "matches" ) ; if ( compiler -> last_result == ERROR_SUCCESS ) compiler -> last_result = yr_parser_emit ( yyscanner , OP_MATCHES , NULL ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 2519 "grammar.c" <S2SV_EndBug> break ; case 58 : <S2SV_StartBug> # line 969 "grammar.y" <S2SV_EndBug> { CHECK_TYPE ( ( yyvsp [ - 2 ] . expression ) , EXPRESSION_TYPE_STRING , "contains" ) ; CHECK_TYPE ( ( yyvsp [ 0 ] . expression ) , EXPRESSION_TYPE_STRING , "contains" ) ; compiler -> last_result = yr_parser_emit ( yyscanner , OP_CONTAINS , NULL ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 2535 "grammar.c" <S2SV_EndBug> break ; case 59 : <S2SV_StartBug> # line 981 "grammar.y" <S2SV_EndBug> { int result = yr_parser_reduce_string_identifier ( yyscanner , ( yyvsp [ 0 ] . c_string ) , OP_FOUND , UNDEFINED ) ; yr_free ( ( yyvsp [ 0 ] . c_string ) ) ; ERROR_IF ( result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 2553 "grammar.c" <S2SV_EndBug> break ; case 60 : <S2SV_StartBug> # line 995 "grammar.y" <S2SV_EndBug> { CHECK_TYPE ( ( yyvsp [ 0 ] . expression ) , EXPRESSION_TYPE_INTEGER , "at" ) ; compiler -> last_result = yr_parser_reduce_string_identifier ( yyscanner , ( yyvsp [ - 2 ] . c_string ) , OP_FOUND_AT , ( yyvsp [ 0 ] . expression ) . value . integer ) ; yr_free ( ( yyvsp [ - 2 ] . c_string ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 2570 "grammar.c" <S2SV_EndBug> break ; case 61 : <S2SV_StartBug> # line 1008 "grammar.y" <S2SV_EndBug> { compiler -> last_result = yr_parser_reduce_string_identifier ( yyscanner , ( yyvsp [ - 2 ] . c_string ) , OP_FOUND_IN , UNDEFINED ) ; yr_free ( ( yyvsp [ - 2 ] . c_string ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 2585 "grammar.c" <S2SV_EndBug> break ; case 62 : <S2SV_StartBug> # line 1019 "grammar.y" <S2SV_EndBug> { if ( compiler -> loop_depth > 0 ) { compiler -> loop_depth -- ; compiler -> loop_identifier [ compiler -> loop_depth ] = NULL ; } <S2SV_StartBug> } <S2SV_EndBug> # line 2597 "grammar.c" break ; case 63 : <S2SV_StartBug> # line 1027 "grammar.y" <S2SV_EndBug> { int var_index ; if ( compiler -> loop_depth == MAX_LOOP_NESTING ) compiler -> last_result = ERROR_LOOP_NESTING_LIMIT_EXCEEDED ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; var_index = yr_parser_lookup_loop_variable ( yyscanner , ( yyvsp [ - 1 ] . c_string ) ) ; if ( var_index >= 0 ) { yr_compiler_set_error_extra_info ( compiler , ( yyvsp [ - 1 ] . c_string ) ) ; compiler -> last_result = ERROR_DUPLICATED_LOOP_IDENTIFIER ; } ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; compiler -> last_result = yr_parser_emit_with_arg ( yyscanner , OP_PUSH , UNDEFINED , NULL , NULL ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } <S2SV_StartBug> # line 2631 "grammar.c" <S2SV_EndBug> break ; case 64 : <S2SV_StartBug> # line 1057 "grammar.y" <S2SV_EndBug> { int mem_offset = LOOP_LOCAL_VARS * compiler -> loop_depth ; uint8_t * addr ; yr_parser_emit_with_arg ( yyscanner , OP_CLEAR_M , mem_offset + 1 , NULL , NULL ) ; yr_parser_emit_with_arg ( yyscanner , OP_CLEAR_M , mem_offset + 2 , NULL , NULL ) ; if ( ( yyvsp [ - 1 ] . integer ) == INTEGER_SET_ENUMERATION ) { yr_parser_emit_with_arg ( yyscanner , OP_POP_M , mem_offset , & addr , NULL ) ; } else { yr_parser_emit_with_arg ( yyscanner , OP_POP_M , mem_offset + 3 , & addr , NULL ) ; yr_parser_emit_with_arg ( yyscanner , OP_POP_M , mem_offset , NULL , NULL ) ; } compiler -> loop_address [ compiler -> loop_depth ] = addr ; compiler -> loop_identifier [ compiler -> loop_depth ] = ( yyvsp [ - 4 ] . c_string ) ; compiler -> loop_depth ++ ; } <S2SV_StartBug> # line 2670 "grammar.c" <S2SV_EndBug> break ; case 65 : <S2SV_StartBug> # line 1092 "grammar.y" <S2SV_EndBug> { int mem_offset ; compiler -> loop_depth -- ; mem_offset = LOOP_LOCAL_VARS * compiler -> loop_depth ; yr_parser_emit_with_arg ( yyscanner , OP_ADD_M , mem_offset + 1 , NULL , NULL ) ; yr_parser_emit_with_arg ( yyscanner , OP_INCR_M , mem_offset + 2 , NULL , NULL ) ; if ( ( yyvsp [ - 5 ] . integer ) == INTEGER_SET_ENUMERATION ) { yr_parser_emit_with_arg_reloc ( yyscanner , OP_JNUNDEF , compiler -> loop_address [ compiler -> loop_depth ] , NULL , NULL ) ; } else { yr_parser_emit_with_arg ( yyscanner , OP_INCR_M , mem_offset , NULL , NULL ) ; yr_parser_emit_with_arg ( yyscanner , OP_PUSH_M , mem_offset , NULL , NULL ) ; yr_parser_emit_with_arg ( yyscanner , OP_PUSH_M , mem_offset + 3 , NULL , NULL ) ; yr_parser_emit_with_arg_reloc ( yyscanner , OP_JLE , compiler -> loop_address [ compiler -> loop_depth ] , NULL , NULL ) ; yr_parser_emit ( yyscanner , OP_POP , NULL ) ; yr_parser_emit ( yyscanner , OP_POP , NULL ) ; } yr_parser_emit ( yyscanner , OP_POP , NULL ) ; yr_parser_emit_with_arg ( yyscanner , OP_SWAPUNDEF , mem_offset + 2 , NULL , NULL ) ; yr_parser_emit_with_arg ( yyscanner , OP_PUSH_M , mem_offset + 1 , NULL , NULL ) ; yr_parser_emit ( yyscanner , OP_INT_LE , NULL ) ; compiler -> loop_identifier [ compiler -> loop_depth ] = NULL ; yr_free ( ( yyvsp [ - 8 ] . c_string ) ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 2753 "grammar.c" <S2SV_EndBug> break ; case 66 : <S2SV_StartBug> # line 1171 "grammar.y" <S2SV_EndBug> { int mem_offset = LOOP_LOCAL_VARS * compiler -> loop_depth ; uint8_t * addr ; if ( compiler -> loop_depth == MAX_LOOP_NESTING ) compiler -> last_result = ERROR_LOOP_NESTING_LIMIT_EXCEEDED ; if ( compiler -> loop_for_of_mem_offset != - 1 ) compiler -> last_result = ERROR_NESTED_FOR_OF_LOOP ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; yr_parser_emit_with_arg ( yyscanner , OP_CLEAR_M , mem_offset + 1 , NULL , NULL ) ; yr_parser_emit_with_arg ( yyscanner , OP_CLEAR_M , mem_offset + 2 , NULL , NULL ) ; yr_parser_emit_with_arg ( yyscanner , OP_POP_M , mem_offset , & addr , NULL ) ; compiler -> loop_for_of_mem_offset = mem_offset ; compiler -> loop_address [ compiler -> loop_depth ] = addr ; compiler -> loop_identifier [ compiler -> loop_depth ] = NULL ; compiler -> loop_depth ++ ; } <S2SV_StartBug> # line 2787 "grammar.c" <S2SV_EndBug> break ; case 67 : <S2SV_StartBug> # line 1201 "grammar.y" <S2SV_EndBug> { int mem_offset ; compiler -> loop_depth -- ; compiler -> loop_for_of_mem_offset = - 1 ; mem_offset = LOOP_LOCAL_VARS * compiler -> loop_depth ; yr_parser_emit_with_arg ( yyscanner , OP_ADD_M , mem_offset + 1 , NULL , NULL ) ; yr_parser_emit_with_arg ( yyscanner , OP_INCR_M , mem_offset + 2 , NULL , NULL ) ; yr_parser_emit_with_arg_reloc ( yyscanner , OP_JNUNDEF , compiler -> loop_address [ compiler -> loop_depth ] , NULL , NULL ) ; yr_parser_emit ( yyscanner , OP_POP , NULL ) ; yr_parser_emit_with_arg ( yyscanner , OP_SWAPUNDEF , mem_offset + 2 , NULL , NULL ) ; yr_parser_emit_with_arg ( yyscanner , OP_PUSH_M , mem_offset + 1 , NULL , NULL ) ; yr_parser_emit ( yyscanner , OP_INT_LE , NULL ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 2840 "grammar.c" <S2SV_EndBug> break ; case 68 : <S2SV_StartBug> # line 1250 "grammar.y" <S2SV_EndBug> { yr_parser_emit ( yyscanner , OP_OF , NULL ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 2850 "grammar.c" <S2SV_EndBug> break ; case 69 : <S2SV_StartBug> # line 1256 "grammar.y" <S2SV_EndBug> { yr_parser_emit ( yyscanner , OP_NOT , NULL ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 2860 "grammar.c" <S2SV_EndBug> break ; case 70 : <S2SV_StartBug> # line 1262 "grammar.y" <S2SV_EndBug> { YR_FIXUP * fixup ; void * jmp_destination_addr ; compiler -> last_result = yr_parser_emit_with_arg_reloc ( yyscanner , OP_JFALSE , 0 , NULL , & jmp_destination_addr ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; fixup = ( YR_FIXUP * ) yr_malloc ( sizeof ( YR_FIXUP ) ) ; if ( fixup == NULL ) compiler -> last_error = ERROR_INSUFFICIENT_MEMORY ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; fixup -> address = jmp_destination_addr ; fixup -> next = compiler -> fixup_stack_head ; compiler -> fixup_stack_head = fixup ; } <S2SV_StartBug> # line 2890 "grammar.c" <S2SV_EndBug> break ; case 71 : <S2SV_StartBug> # line 1288 "grammar.y" <S2SV_EndBug> { YR_FIXUP * fixup ; uint8_t * and_addr ; compiler -> last_result = yr_arena_reserve_memory ( compiler -> code_arena , 2 ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; compiler -> last_result = yr_parser_emit ( yyscanner , OP_AND , & and_addr ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; fixup = compiler -> fixup_stack_head ; * ( void * * ) ( fixup -> address ) = ( void * ) ( and_addr + 1 ) ; compiler -> fixup_stack_head = fixup -> next ; yr_free ( fixup ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 2930 "grammar.c" <S2SV_EndBug> break ; case 72 : <S2SV_StartBug> # line 1324 "grammar.y" <S2SV_EndBug> { YR_FIXUP * fixup ; void * jmp_destination_addr ; compiler -> last_result = yr_parser_emit_with_arg_reloc ( yyscanner , OP_JTRUE , 0 , NULL , & jmp_destination_addr ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; fixup = ( YR_FIXUP * ) yr_malloc ( sizeof ( YR_FIXUP ) ) ; if ( fixup == NULL ) compiler -> last_error = ERROR_INSUFFICIENT_MEMORY ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; fixup -> address = jmp_destination_addr ; fixup -> next = compiler -> fixup_stack_head ; compiler -> fixup_stack_head = fixup ; } <S2SV_StartBug> # line 2959 "grammar.c" <S2SV_EndBug> break ; case 73 : <S2SV_StartBug> # line 1349 "grammar.y" <S2SV_EndBug> { YR_FIXUP * fixup ; uint8_t * or_addr ; compiler -> last_result = yr_arena_reserve_memory ( compiler -> code_arena , 2 ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; compiler -> last_result = yr_parser_emit ( yyscanner , OP_OR , & or_addr ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; fixup = compiler -> fixup_stack_head ; * ( void * * ) ( fixup -> address ) = ( void * ) ( or_addr + 1 ) ; compiler -> fixup_stack_head = fixup -> next ; yr_free ( fixup ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 2999 "grammar.c" <S2SV_EndBug> break ; case 74 : <S2SV_StartBug> # line 1385 "grammar.y" <S2SV_EndBug> { compiler -> last_result = yr_parser_reduce_operation ( yyscanner , "<" , ( yyvsp [ - 2 ] . expression ) , ( yyvsp [ 0 ] . expression ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 3012 "grammar.c" <S2SV_EndBug> break ; case 75 : <S2SV_StartBug> # line 1394 "grammar.y" <S2SV_EndBug> { compiler -> last_result = yr_parser_reduce_operation ( yyscanner , ">" , ( yyvsp [ - 2 ] . expression ) , ( yyvsp [ 0 ] . expression ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 3025 "grammar.c" <S2SV_EndBug> break ; case 76 : <S2SV_StartBug> # line 1403 "grammar.y" <S2SV_EndBug> { compiler -> last_result = yr_parser_reduce_operation ( yyscanner , "<=" , ( yyvsp [ - 2 ] . expression ) , ( yyvsp [ 0 ] . expression ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 3038 "grammar.c" <S2SV_EndBug> break ; case 77 : <S2SV_StartBug> # line 1412 "grammar.y" <S2SV_EndBug> { compiler -> last_result = yr_parser_reduce_operation ( yyscanner , ">=" , ( yyvsp [ - 2 ] . expression ) , ( yyvsp [ 0 ] . expression ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 3051 "grammar.c" <S2SV_EndBug> break ; case 78 : <S2SV_StartBug> # line 1421 "grammar.y" <S2SV_EndBug> { compiler -> last_result = yr_parser_reduce_operation ( yyscanner , "==" , ( yyvsp [ - 2 ] . expression ) , ( yyvsp [ 0 ] . expression ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 3064 "grammar.c" <S2SV_EndBug> break ; case 79 : <S2SV_StartBug> # line 1430 "grammar.y" <S2SV_EndBug> { compiler -> last_result = yr_parser_reduce_operation ( yyscanner , "!=" , ( yyvsp [ - 2 ] . expression ) , ( yyvsp [ 0 ] . expression ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; } <S2SV_StartBug> # line 3077 "grammar.c" <S2SV_EndBug> break ; case 80 : <S2SV_StartBug> # line 1439 "grammar.y" <S2SV_EndBug> { ( yyval . expression ) = ( yyvsp [ 0 ] . expression ) ; } <S2SV_StartBug> # line 3085 "grammar.c" <S2SV_EndBug> break ; case 81 : <S2SV_StartBug> # line 1443 "grammar.y" <S2SV_EndBug> { ( yyval . expression ) = ( yyvsp [ - 1 ] . expression ) ; } <S2SV_StartBug> # line 3093 "grammar.c" <S2SV_EndBug> break ; case 82 : <S2SV_StartBug> # line 1450 "grammar.y" <S2SV_EndBug> { ( yyval . integer ) = INTEGER_SET_ENUMERATION ; } <S2SV_StartBug> # line 3099 "grammar.c" <S2SV_EndBug> break ; case 83 : <S2SV_StartBug> # line 1451 "grammar.y" <S2SV_EndBug> { ( yyval . integer ) = INTEGER_SET_RANGE ; } <S2SV_StartBug> # line 3105 "grammar.c" <S2SV_EndBug> break ; case 84 : <S2SV_StartBug> # line 1457 "grammar.y" <S2SV_EndBug> { if ( ( yyvsp [ - 3 ] . expression ) . type != EXPRESSION_TYPE_INTEGER ) { yr_compiler_set_error_extra_info ( compiler , "wrong<S2SV_blank>type<S2SV_blank>for<S2SV_blank>range\'s<S2SV_blank>lower<S2SV_blank>bound" ) ; compiler -> last_result = ERROR_WRONG_TYPE ; } if ( ( yyvsp [ - 1 ] . expression ) . type != EXPRESSION_TYPE_INTEGER ) { yr_compiler_set_error_extra_info ( compiler , "wrong<S2SV_blank>type<S2SV_blank>for<S2SV_blank>range\'s<S2SV_blank>upper<S2SV_blank>bound" ) ; compiler -> last_result = ERROR_WRONG_TYPE ; } ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } <S2SV_StartBug> # line 3127 "grammar.c" <S2SV_EndBug> break ; case 85 : <S2SV_StartBug> # line 1479 "grammar.y" <S2SV_EndBug> { if ( ( yyvsp [ 0 ] . expression ) . type != EXPRESSION_TYPE_INTEGER ) { yr_compiler_set_error_extra_info ( compiler , "wrong<S2SV_blank>type<S2SV_blank>for<S2SV_blank>enumeration<S2SV_blank>item" ) ; compiler -> last_result = ERROR_WRONG_TYPE ; } ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } <S2SV_StartBug> # line 3143 "grammar.c" <S2SV_EndBug> break ; case 86 : <S2SV_StartBug> # line 1491 "grammar.y" <S2SV_EndBug> { if ( ( yyvsp [ 0 ] . expression ) . type != EXPRESSION_TYPE_INTEGER ) { yr_compiler_set_error_extra_info ( compiler , "wrong<S2SV_blank>type<S2SV_blank>for<S2SV_blank>enumeration<S2SV_blank>item" ) ; compiler -> last_result = ERROR_WRONG_TYPE ; } ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } <S2SV_StartBug> # line 3158 "grammar.c" <S2SV_EndBug> break ; case 87 : <S2SV_StartBug> # line 1506 "grammar.y" <S2SV_EndBug> { yr_parser_emit_with_arg ( yyscanner , OP_PUSH , UNDEFINED , NULL , NULL ) ; } <S2SV_StartBug> # line 3167 "grammar.c" <S2SV_EndBug> break ; case 89 : <S2SV_StartBug> # line 1512 "grammar.y" <S2SV_EndBug> { yr_parser_emit_with_arg ( yyscanner , OP_PUSH , UNDEFINED , NULL , NULL ) ; yr_parser_emit_pushes_for_strings ( yyscanner , "$*" ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } <S2SV_StartBug> # line 3178 "grammar.c" <S2SV_EndBug> break ; case 92 : <S2SV_StartBug> # line 1529 "grammar.y" <S2SV_EndBug> { yr_parser_emit_pushes_for_strings ( yyscanner , ( yyvsp [ 0 ] . c_string ) ) ; yr_free ( ( yyvsp [ 0 ] . c_string ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } <S2SV_StartBug> # line 3189 "grammar.c" <S2SV_EndBug> break ; case 93 : <S2SV_StartBug> # line 1536 "grammar.y" <S2SV_EndBug> { yr_parser_emit_pushes_for_strings ( yyscanner , ( yyvsp [ 0 ] . c_string ) ) ; yr_free ( ( yyvsp [ 0 ] . c_string ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } <S2SV_StartBug> # line 3200 "grammar.c" <S2SV_EndBug> break ; case 95 : <S2SV_StartBug> # line 1548 "grammar.y" <S2SV_EndBug> { yr_parser_emit_with_arg ( yyscanner , OP_PUSH , UNDEFINED , NULL , NULL ) ; } <S2SV_StartBug> # line 3208 "grammar.c" <S2SV_EndBug> break ; case 96 : <S2SV_StartBug> # line 1552 "grammar.y" <S2SV_EndBug> { yr_parser_emit_with_arg ( yyscanner , OP_PUSH , 1 , NULL , NULL ) ; } <S2SV_StartBug> # line 3216 "grammar.c" <S2SV_EndBug> break ; case 97 : <S2SV_StartBug> # line 1560 "grammar.y" <S2SV_EndBug> { ( yyval . expression ) = ( yyvsp [ - 1 ] . expression ) ; } <S2SV_StartBug> # line 3224 "grammar.c" <S2SV_EndBug> break ; case 98 : <S2SV_StartBug> # line 1564 "grammar.y" <S2SV_EndBug> { compiler -> last_result = yr_parser_emit ( yyscanner , OP_FILESIZE , NULL ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = UNDEFINED ; } <S2SV_StartBug> # line 3238 "grammar.c" <S2SV_EndBug> break ; case 99 : <S2SV_StartBug> # line 1574 "grammar.y" <S2SV_EndBug> { yywarning ( yyscanner , "Using<S2SV_blank>deprecated<S2SV_blank>\\"entrypoint\\"<S2SV_blank>keyword.<S2SV_blank>Use<S2SV_blank>the<S2SV_blank>\\"entry_point\\"<S2SV_blank>" "function<S2SV_blank>from<S2SV_blank>PE<S2SV_blank>module<S2SV_blank>instead." ) ; compiler -> last_result = yr_parser_emit ( yyscanner , OP_ENTRYPOINT , NULL ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = UNDEFINED ; } <S2SV_StartBug> # line 3256 "grammar.c" <S2SV_EndBug> break ; case 100 : <S2SV_StartBug> # line 1588 "grammar.y" <S2SV_EndBug> { CHECK_TYPE ( ( yyvsp [ - 1 ] . expression ) , EXPRESSION_TYPE_INTEGER , "intXXXX<S2SV_blank>or<S2SV_blank>uintXXXX" ) ; compiler -> last_result = yr_parser_emit ( yyscanner , ( uint8_t ) ( OP_READ_INT + ( yyvsp [ - 3 ] . integer ) ) , NULL ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = UNDEFINED ; } <S2SV_StartBug> # line 3276 "grammar.c" <S2SV_EndBug> break ; case 101 : <S2SV_StartBug> # line 1604 "grammar.y" <S2SV_EndBug> { compiler -> last_result = yr_parser_emit_with_arg ( yyscanner , OP_PUSH , ( yyvsp [ 0 ] . integer ) , NULL , NULL ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = ( yyvsp [ 0 ] . integer ) ; } <S2SV_StartBug> # line 3290 "grammar.c" <S2SV_EndBug> break ; case 102 : <S2SV_StartBug> # line 1614 "grammar.y" <S2SV_EndBug> { compiler -> last_result = yr_parser_emit_with_arg_double ( yyscanner , OP_PUSH , ( yyvsp [ 0 ] . double_ ) , NULL , NULL ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_FLOAT ; } <S2SV_StartBug> # line 3303 "grammar.c" <S2SV_EndBug> break ; case 103 : <S2SV_StartBug> # line 1623 "grammar.y" <S2SV_EndBug> { SIZED_STRING * sized_string ; compiler -> last_result = yr_arena_write_data ( compiler -> sz_arena , ( yyvsp [ 0 ] . sized_string ) , ( yyvsp [ 0 ] . sized_string ) -> length + sizeof ( SIZED_STRING ) , ( void * * ) & sized_string ) ; yr_free ( ( yyvsp [ 0 ] . sized_string ) ) ; if ( compiler -> last_result == ERROR_SUCCESS ) compiler -> last_result = yr_parser_emit_with_arg_reloc ( yyscanner , OP_PUSH , sized_string , NULL , NULL ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_STRING ; ( yyval . expression ) . value . sized_string = sized_string ; } <S2SV_StartBug> # line 3332 "grammar.c" <S2SV_EndBug> break ; case 104 : <S2SV_StartBug> # line 1648 "grammar.y" <S2SV_EndBug> { compiler -> last_result = yr_parser_reduce_string_identifier ( yyscanner , ( yyvsp [ 0 ] . c_string ) , OP_COUNT , UNDEFINED ) ; yr_free ( ( yyvsp [ 0 ] . c_string ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = UNDEFINED ; } <S2SV_StartBug> # line 3348 "grammar.c" <S2SV_EndBug> break ; case 105 : <S2SV_StartBug> # line 1660 "grammar.y" <S2SV_EndBug> { compiler -> last_result = yr_parser_reduce_string_identifier ( yyscanner , ( yyvsp [ - 3 ] . c_string ) , OP_OFFSET , UNDEFINED ) ; yr_free ( ( yyvsp [ - 3 ] . c_string ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = UNDEFINED ; } <S2SV_StartBug> # line 3364 "grammar.c" <S2SV_EndBug> break ; case 106 : <S2SV_StartBug> # line 1672 "grammar.y" <S2SV_EndBug> { compiler -> last_result = yr_parser_emit_with_arg ( yyscanner , OP_PUSH , 1 , NULL , NULL ) ; if ( compiler -> last_result == ERROR_SUCCESS ) compiler -> last_result = yr_parser_reduce_string_identifier ( yyscanner , ( yyvsp [ 0 ] . c_string ) , OP_OFFSET , UNDEFINED ) ; yr_free ( ( yyvsp [ 0 ] . c_string ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = UNDEFINED ; } <S2SV_StartBug> # line 3384 "grammar.c" <S2SV_EndBug> break ; case 107 : <S2SV_StartBug> # line 1688 "grammar.y" <S2SV_EndBug> { compiler -> last_result = yr_parser_reduce_string_identifier ( yyscanner , ( yyvsp [ - 3 ] . c_string ) , OP_LENGTH , UNDEFINED ) ; yr_free ( ( yyvsp [ - 3 ] . c_string ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = UNDEFINED ; } <S2SV_StartBug> # line 3400 "grammar.c" <S2SV_EndBug> break ; case 108 : <S2SV_StartBug> # line 1700 "grammar.y" <S2SV_EndBug> { compiler -> last_result = yr_parser_emit_with_arg ( yyscanner , OP_PUSH , 1 , NULL , NULL ) ; if ( compiler -> last_result == ERROR_SUCCESS ) compiler -> last_result = yr_parser_reduce_string_identifier ( yyscanner , ( yyvsp [ 0 ] . c_string ) , OP_LENGTH , UNDEFINED ) ; yr_free ( ( yyvsp [ 0 ] . c_string ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = UNDEFINED ; } <S2SV_StartBug> # line 3420 "grammar.c" <S2SV_EndBug> break ; case 109 : <S2SV_StartBug> # line 1716 "grammar.y" <S2SV_EndBug> { if ( ( yyvsp [ 0 ] . expression ) . type == EXPRESSION_TYPE_INTEGER ) { ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = UNDEFINED ; } else if ( ( yyvsp [ 0 ] . expression ) . type == EXPRESSION_TYPE_BOOLEAN ) { ( yyval . expression ) . type = EXPRESSION_TYPE_BOOLEAN ; ( yyval . expression ) . value . integer = UNDEFINED ; } else if ( ( yyvsp [ 0 ] . expression ) . type == EXPRESSION_TYPE_OBJECT ) { compiler -> last_result = yr_parser_emit ( yyscanner , OP_OBJ_VALUE , NULL ) ; switch ( ( yyvsp [ 0 ] . expression ) . value . object -> type ) { case OBJECT_TYPE_INTEGER : ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = UNDEFINED ; break ; case OBJECT_TYPE_FLOAT : ( yyval . expression ) . type = EXPRESSION_TYPE_FLOAT ; break ; case OBJECT_TYPE_STRING : ( yyval . expression ) . type = EXPRESSION_TYPE_STRING ; ( yyval . expression ) . value . sized_string = NULL ; break ; default : yr_compiler_set_error_extra_info_fmt ( compiler , "wrong<S2SV_blank>usage<S2SV_blank>of<S2SV_blank>identifier<S2SV_blank>\\"%s\\"" , ( yyvsp [ 0 ] . expression ) . identifier ) ; compiler -> last_result = ERROR_WRONG_TYPE ; } } else { assert ( FALSE ) ; } ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } <S2SV_StartBug> # line 3469 "grammar.c" <S2SV_EndBug> break ; case 110 : <S2SV_StartBug> # line 1761 "grammar.y" <S2SV_EndBug> { CHECK_TYPE ( ( yyvsp [ 0 ] . expression ) , EXPRESSION_TYPE_INTEGER | EXPRESSION_TYPE_FLOAT , "-" ) ; if ( ( yyvsp [ 0 ] . expression ) . type == EXPRESSION_TYPE_INTEGER ) { ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = ( ( yyvsp [ 0 ] . expression ) . value . integer == UNDEFINED ) ? UNDEFINED : - ( ( yyvsp [ 0 ] . expression ) . value . integer ) ; compiler -> last_result = yr_parser_emit ( yyscanner , OP_INT_MINUS , NULL ) ; } else if ( ( yyvsp [ 0 ] . expression ) . type == EXPRESSION_TYPE_FLOAT ) { ( yyval . expression ) . type = EXPRESSION_TYPE_FLOAT ; compiler -> last_result = yr_parser_emit ( yyscanner , OP_DBL_MINUS , NULL ) ; } ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } <S2SV_StartBug> # line 3492 "grammar.c" <S2SV_EndBug> break ; case 111 : <S2SV_StartBug> # line 1780 "grammar.y" <S2SV_EndBug> { compiler -> last_result = yr_parser_reduce_operation ( yyscanner , "+" , ( yyvsp [ - 2 ] . expression ) , ( yyvsp [ 0 ] . expression ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; if ( ( yyvsp [ - 2 ] . expression ) . type == EXPRESSION_TYPE_INTEGER && ( yyvsp [ 0 ] . expression ) . type == EXPRESSION_TYPE_INTEGER ) { ( yyval . expression ) . value . integer = OPERATION ( + , ( yyvsp [ - 2 ] . expression ) . value . integer , ( yyvsp [ 0 ] . expression ) . value . integer ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; } else { ( yyval . expression ) . type = EXPRESSION_TYPE_FLOAT ; } } <S2SV_StartBug> # line 3514 "grammar.c" <S2SV_EndBug> break ; case 112 : <S2SV_StartBug> # line 1798 "grammar.y" <S2SV_EndBug> { compiler -> last_result = yr_parser_reduce_operation ( yyscanner , "-" , ( yyvsp [ - 2 ] . expression ) , ( yyvsp [ 0 ] . expression ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; if ( ( yyvsp [ - 2 ] . expression ) . type == EXPRESSION_TYPE_INTEGER && ( yyvsp [ 0 ] . expression ) . type == EXPRESSION_TYPE_INTEGER ) { ( yyval . expression ) . value . integer = OPERATION ( - , ( yyvsp [ - 2 ] . expression ) . value . integer , ( yyvsp [ 0 ] . expression ) . value . integer ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; } else { ( yyval . expression ) . type = EXPRESSION_TYPE_FLOAT ; } } <S2SV_StartBug> # line 3536 "grammar.c" <S2SV_EndBug> break ; case 113 : <S2SV_StartBug> # line 1816 "grammar.y" <S2SV_EndBug> { compiler -> last_result = yr_parser_reduce_operation ( yyscanner , "*" , ( yyvsp [ - 2 ] . expression ) , ( yyvsp [ 0 ] . expression ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; if ( ( yyvsp [ - 2 ] . expression ) . type == EXPRESSION_TYPE_INTEGER && ( yyvsp [ 0 ] . expression ) . type == EXPRESSION_TYPE_INTEGER ) { ( yyval . expression ) . value . integer = OPERATION ( * , ( yyvsp [ - 2 ] . expression ) . value . integer , ( yyvsp [ 0 ] . expression ) . value . integer ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; } else { ( yyval . expression ) . type = EXPRESSION_TYPE_FLOAT ; } } <S2SV_StartBug> # line 3558 "grammar.c" <S2SV_EndBug> break ; case 114 : <S2SV_StartBug> # line 1834 "grammar.y" <S2SV_EndBug> { compiler -> last_result = yr_parser_reduce_operation ( yyscanner , "\\\\" , ( yyvsp [ - 2 ] . expression ) , ( yyvsp [ 0 ] . expression ) ) ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; if ( ( yyvsp [ - 2 ] . expression ) . type == EXPRESSION_TYPE_INTEGER && ( yyvsp [ 0 ] . expression ) . type == EXPRESSION_TYPE_INTEGER ) { if ( ( yyvsp [ 0 ] . expression ) . value . integer != 0 ) { ( yyval . expression ) . value . integer = OPERATION ( / , ( yyvsp [ - 2 ] . expression ) . value . integer , ( yyvsp [ 0 ] . expression ) . value . integer ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; } else { compiler -> last_result = ERROR_DIVISION_BY_ZERO ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } } else { ( yyval . expression ) . type = EXPRESSION_TYPE_FLOAT ; } } <S2SV_StartBug> # line 3588 "grammar.c" <S2SV_EndBug> break ; case 115 : <S2SV_StartBug> # line 1860 "grammar.y" <S2SV_EndBug> { CHECK_TYPE ( ( yyvsp [ - 2 ] . expression ) , EXPRESSION_TYPE_INTEGER , "%" ) ; CHECK_TYPE ( ( yyvsp [ 0 ] . expression ) , EXPRESSION_TYPE_INTEGER , "%" ) ; yr_parser_emit ( yyscanner , OP_MOD , NULL ) ; if ( ( yyvsp [ 0 ] . expression ) . value . integer != 0 ) { ( yyval . expression ) . value . integer = OPERATION ( % , ( yyvsp [ - 2 ] . expression ) . value . integer , ( yyvsp [ 0 ] . expression ) . value . integer ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; } else { compiler -> last_result = ERROR_DIVISION_BY_ZERO ; ERROR_IF ( compiler -> last_result != ERROR_SUCCESS ) ; } } <S2SV_StartBug> # line 3610 "grammar.c" <S2SV_EndBug> break ; case 116 : <S2SV_StartBug> # line 1878 "grammar.y" <S2SV_EndBug> { CHECK_TYPE ( ( yyvsp [ - 2 ] . expression ) , EXPRESSION_TYPE_INTEGER , "^" ) ; CHECK_TYPE ( ( yyvsp [ 0 ] . expression ) , EXPRESSION_TYPE_INTEGER , "^" ) ; yr_parser_emit ( yyscanner , OP_BITWISE_XOR , NULL ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = OPERATION ( ^ , ( yyvsp [ - 2 ] . expression ) . value . integer , ( yyvsp [ 0 ] . expression ) . value . integer ) ; } <S2SV_StartBug> # line 3624 "grammar.c" <S2SV_EndBug> break ; case 117 : <S2SV_StartBug> # line 1888 "grammar.y" <S2SV_EndBug> { CHECK_TYPE ( ( yyvsp [ - 2 ] . expression ) , EXPRESSION_TYPE_INTEGER , "^" ) ; CHECK_TYPE ( ( yyvsp [ 0 ] . expression ) , EXPRESSION_TYPE_INTEGER , "^" ) ; yr_parser_emit ( yyscanner , OP_BITWISE_AND , NULL ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = OPERATION ( & , ( yyvsp [ - 2 ] . expression ) . value . integer , ( yyvsp [ 0 ] . expression ) . value . integer ) ; } <S2SV_StartBug> # line 3638 "grammar.c" <S2SV_EndBug> break ; case 118 : <S2SV_StartBug> # line 1898 "grammar.y" <S2SV_EndBug> { CHECK_TYPE ( ( yyvsp [ - 2 ] . expression ) , EXPRESSION_TYPE_INTEGER , "|" ) ; CHECK_TYPE ( ( yyvsp [ 0 ] . expression ) , EXPRESSION_TYPE_INTEGER , "|" ) ; yr_parser_emit ( yyscanner , OP_BITWISE_OR , NULL ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = OPERATION ( | , ( yyvsp [ - 2 ] . expression ) . value . integer , ( yyvsp [ 0 ] . expression ) . value . integer ) ; } <S2SV_StartBug> # line 3652 "grammar.c" <S2SV_EndBug> break ; case 119 : <S2SV_StartBug> # line 1908 "grammar.y" <S2SV_EndBug> { CHECK_TYPE ( ( yyvsp [ 0 ] . expression ) , EXPRESSION_TYPE_INTEGER , "~" ) ; yr_parser_emit ( yyscanner , OP_BITWISE_NOT , NULL ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = ( ( yyvsp [ 0 ] . expression ) . value . integer == UNDEFINED ) ? UNDEFINED : ~ ( ( yyvsp [ 0 ] . expression ) . value . integer ) ; } <S2SV_StartBug> # line 3666 "grammar.c" <S2SV_EndBug> break ; case 120 : <S2SV_StartBug> # line 1918 "grammar.y" <S2SV_EndBug> { CHECK_TYPE ( ( yyvsp [ - 2 ] . expression ) , EXPRESSION_TYPE_INTEGER , "<<" ) ; CHECK_TYPE ( ( yyvsp [ 0 ] . expression ) , EXPRESSION_TYPE_INTEGER , "<<" ) ; yr_parser_emit ( yyscanner , OP_SHL , NULL ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = OPERATION ( << , ( yyvsp [ - 2 ] . expression ) . value . integer , ( yyvsp [ 0 ] . expression ) . value . integer ) ; } <S2SV_StartBug> # line 3680 "grammar.c" <S2SV_EndBug> break ; case 121 : <S2SV_StartBug> # line 1928 "grammar.y" <S2SV_EndBug> { CHECK_TYPE ( ( yyvsp [ - 2 ] . expression ) , EXPRESSION_TYPE_INTEGER , ">>" ) ; CHECK_TYPE ( ( yyvsp [ 0 ] . expression ) , EXPRESSION_TYPE_INTEGER , ">>" ) ; yr_parser_emit ( yyscanner , OP_SHR , NULL ) ; ( yyval . expression ) . type = EXPRESSION_TYPE_INTEGER ; ( yyval . expression ) . value . integer = OPERATION ( >> , ( yyvsp [ - 2 ] . expression ) . value . integer , ( yyvsp [ 0 ] . expression ) . value . integer ) ; } <S2SV_StartBug> # line 3694 "grammar.c" <S2SV_EndBug> break ; case 122 : <S2SV_StartBug> # line 1938 "grammar.y" <S2SV_EndBug> { ( yyval . expression ) = ( yyvsp [ 0 ] . expression ) ; } <S2SV_StartBug> # line 3702 "grammar.c" <S2SV_EndBug> break ; <S2SV_StartBug> # line 3706 "grammar.c" <S2SV_EndBug> default : break ; } YY_SYMBOL_PRINT ( "-><S2SV_blank>$$<S2SV_blank>=" , yyr1 [ yyn ] , & yyval , & yyloc ) ; YYPOPSTACK ( yylen ) ; yylen = 0 ; YY_STACK_PRINT ( yyss , yyssp ) ; * ++ yyvsp = yyval ; yyn = yyr1 [ yyn ] ; yystate = yypgoto [ yyn - YYNTOKENS ] + * yyssp ; if ( 0 <= yystate && yystate <= YYLAST && yycheck [ yystate ] == * yyssp ) yystate = yytable [ yystate ] ; else yystate = yydefgoto [ yyn - YYNTOKENS ] ; goto yynewstate ; yyerrlab : yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE ( yychar ) ; if ( ! yyerrstatus ) { ++ yynerrs ; # if ! YYERROR_VERBOSE yyerror ( yyscanner , compiler , YY_ ( "syntax<S2SV_blank>error" ) ) ; # else # define YYSYNTAX_ERROR yysyntax_error ( & yymsg_alloc , & yymsg , yyssp , yytoken ) { char const * yymsgp = YY_ ( "syntax<S2SV_blank>error" ) ; int yysyntax_error_status ; yysyntax_error_status = YYSYNTAX_ERROR ; if ( yysyntax_error_status == 0 ) yymsgp = yymsg ; else if ( yysyntax_error_status == 1 ) { if ( yymsg != yymsgbuf ) YYSTACK_FREE ( yymsg ) ; yymsg = ( char * ) YYSTACK_ALLOC ( yymsg_alloc ) ; if ( ! yymsg ) { yymsg = yymsgbuf ; yymsg_alloc = sizeof yymsgbuf ; yysyntax_error_status = 2 ; } else { yysyntax_error_status = YYSYNTAX_ERROR ; yymsgp = yymsg ; } } yyerror ( yyscanner , compiler , yymsgp ) ; if ( yysyntax_error_status == 2 ) goto yyexhaustedlab ; } # undef YYSYNTAX_ERROR # endif } if ( yyerrstatus == 3 ) { if ( yychar <= YYEOF ) { if ( yychar == YYEOF ) YYABORT ; } else { yydestruct ( "Error:<S2SV_blank>discarding" , yytoken , & yylval , yyscanner , compiler ) ; yychar = YYEMPTY ; } } goto yyerrlab1 ; yyerrorlab : if ( 0 ) goto yyerrorlab ; YYPOPSTACK ( yylen ) ; yylen = 0 ; YY_STACK_PRINT ( yyss , yyssp ) ; yystate = * yyssp ; goto yyerrlab1 ; yyerrlab1 : yyerrstatus = 3 ; for ( ; ; ) { yyn = yypact [ yystate ] ; if ( ! yypact_value_is_default ( yyn ) ) { yyn += YYTERROR ; if ( 0 <= yyn && yyn <= YYLAST && yycheck [ yyn ] == YYTERROR ) { yyn = yytable [ yyn ] ; if ( 0 < yyn ) break ; } } if ( yyssp == yyss ) YYABORT ; yydestruct ( "Error:<S2SV_blank>popping" , yystos [ yystate ] , yyvsp , yyscanner , compiler ) ; YYPOPSTACK ( 1 ) ; yystate = * yyssp ; YY_STACK_PRINT ( yyss , yyssp ) ; } YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN * ++ yyvsp = yylval ; YY_IGNORE_MAYBE_UNINITIALIZED_END YY_SYMBOL_PRINT ( "Shifting" , yystos [ yyn ] , yyvsp , yylsp ) ; yystate = yyn ; goto yynewstate ; yyacceptlab : yyresult = 0 ; goto yyreturn ; yyabortlab : yyresult = 1 ; goto yyreturn ; # if ! defined yyoverflow || YYERROR_VERBOSE yyexhaustedlab : yyerror ( yyscanner , compiler , YY_ ( "memory<S2SV_blank>exhausted" ) ) ; yyresult = 2 ; # endif yyreturn : if ( yychar != YYEMPTY ) { yytoken = YYTRANSLATE ( yychar ) ; yydestruct ( "Cleanup:<S2SV_blank>discarding<S2SV_blank>lookahead" , yytoken , & yylval , yyscanner , compiler ) ; } YYPOPSTACK ( yylen ) ; YY_STACK_PRINT ( yyss , yyssp ) ; while ( yyssp != yyss ) { yydestruct ( "Cleanup:<S2SV_blank>popping" , yystos [ * yyssp ] , yyvsp , yyscanner , compiler ) ; YYPOPSTACK ( 1 ) ; } # ifndef yyoverflow if ( yyss != yyssa ) YYSTACK_FREE ( yyss ) ; # endif # if YYERROR_VERBOSE if ( yymsg != yymsgbuf ) YYSTACK_FREE ( yymsg ) ; # endif return yyresult ; }
static void jpc_undo_roi ( jas_matrix_t * x , int roishift , int bgshift , int numbps ) { int i ; int j ; int thresh ; jpc_fix_t val ; jpc_fix_t mag ; bool warn ; uint_fast32_t mask ; <S2SV_StartBug> if ( roishift == 0 && bgshift == 0 ) { <S2SV_EndBug> return ; } thresh = 1 << roishift ; warn = false ; for ( i = 0 ; i < jas_matrix_numrows ( x ) ; ++ i ) { for ( j = 0 ; j < jas_matrix_numcols ( x ) ; ++ j ) { val = jas_matrix_get ( x , i , j ) ; mag = JAS_ABS ( val ) ; if ( mag >= thresh ) { mag >>= roishift ; val = ( val < 0 ) ? ( - mag ) : mag ; jas_matrix_set ( x , i , j , val ) ; } else { mag <<= bgshift ; <S2SV_StartBug> mask = ( 1 << numbps ) - 1 ; <S2SV_EndBug> if ( mag & ( ~ mask ) ) { if ( ! warn ) { jas_eprintf ( "warning:<S2SV_blank>possibly<S2SV_blank>corrupt<S2SV_blank>code<S2SV_blank>stream\\n" ) ; warn = true ; } mag &= mask ; } val = ( val < 0 ) ? ( - mag ) : mag ; jas_matrix_set ( x , i , j , val ) ; } } } }
<S2SV_StartBug> static void get_frame_stats ( vpx_codec_ctx_t * ctx , <S2SV_EndBug> const vpx_image_t * img , vpx_codec_pts_t pts , unsigned int duration , vpx_enc_frame_flags_t flags , unsigned int deadline , <S2SV_StartBug> vpx_fixed_buf_t * stats ) { <S2SV_EndBug> vpx_codec_iter_t iter = NULL ; const vpx_codec_cx_pkt_t * pkt = NULL ; const vpx_codec_err_t res = vpx_codec_encode ( ctx , img , pts , duration , flags , deadline ) ; if ( res != VPX_CODEC_OK ) die_codec ( ctx , "Failed<S2SV_blank>to<S2SV_blank>get<S2SV_blank>frame<S2SV_blank>stats." ) ; while ( ( pkt = vpx_codec_get_cx_data ( ctx , & iter ) ) != NULL ) { <S2SV_StartBug> if ( pkt -> kind == VPX_CODEC_STATS_PKT ) { <S2SV_EndBug> const uint8_t * const pkt_buf = pkt -> data . twopass_stats . buf ; const size_t pkt_size = pkt -> data . twopass_stats . sz ; stats -> buf = realloc ( stats -> buf , stats -> sz + pkt_size ) ; memcpy ( ( uint8_t * ) stats -> buf + stats -> sz , pkt_buf , pkt_size ) ; stats -> sz += pkt_size ; } } <S2SV_StartBug> } <S2SV_EndBug>
<S2SV_StartBug> int vp9_loop_filter_worker ( void * arg1 , void * arg2 ) { <S2SV_EndBug> <S2SV_StartBug> LFWorkerData * const lf_data = ( LFWorkerData * ) arg1 ; <S2SV_EndBug> <S2SV_StartBug> ( void ) arg2 ; <S2SV_EndBug> <S2SV_StartBug> vp9_loop_filter_rows ( lf_data -> frame_buffer , lf_data -> cm , & lf_data -> xd , <S2SV_EndBug> lf_data -> start , lf_data -> stop , lf_data -> y_only ) ; return 1 ; }
static void de_dotdot ( char * file ) { char * cp ; char * cp2 ; int l ; while ( ( cp = strstr ( file , "//" ) ) != ( char * ) 0 ) { for ( cp2 = cp + 2 ; * cp2 == '/' ; ++ cp2 ) continue ; ( void ) strcpy ( cp + 1 , cp2 ) ; } while ( strncmp ( file , "./" , 2 ) == 0 ) ( void ) memmove ( file , file + 2 , strlen ( file ) - 1 ) ; while ( ( cp = strstr ( file , "/./" ) ) != ( char * ) 0 ) <S2SV_StartBug> ( void ) memmove ( cp , cp + 2 , strlen ( file ) - 1 ) ; <S2SV_EndBug> for ( ; ; ) { while ( strncmp ( file , "../" , 3 ) == 0 ) ( void ) memmove ( file , file + 3 , strlen ( file ) - 2 ) ; cp = strstr ( file , "/../" ) ; if ( cp == ( char * ) 0 ) break ; for ( cp2 = cp - 1 ; cp2 >= file && * cp2 != '/' ; -- cp2 ) continue ; ( void ) strcpy ( cp2 + 1 , cp + 4 ) ; } while ( ( l = strlen ( file ) ) > 3 && strcmp ( ( cp = file + l - 3 ) , "/.." ) == 0 ) { for ( cp2 = cp - 1 ; cp2 >= file && * cp2 != '/' ; -- cp2 ) continue ; if ( cp2 < file ) break ; * cp2 = '\\0' ; } }
static int mark_source_chains ( const struct xt_table_info * newinfo , unsigned int valid_hooks , void * entry0 ) { unsigned int hook ; for ( hook = 0 ; hook < NF_ARP_NUMHOOKS ; hook ++ ) { unsigned int pos = newinfo -> hook_entry [ hook ] ; struct arpt_entry * e = ( struct arpt_entry * ) ( entry0 + pos ) ; if ( ! ( valid_hooks & ( 1 << hook ) ) ) continue ; e -> counters . pcnt = pos ; for ( ; ; ) { const struct xt_standard_target * t = ( void * ) arpt_get_target_c ( e ) ; int visited = e -> comefrom & ( 1 << hook ) ; if ( e -> comefrom & ( 1 << NF_ARP_NUMHOOKS ) ) { pr_notice ( "arptables:<S2SV_blank>loop<S2SV_blank>hook<S2SV_blank>%u<S2SV_blank>pos<S2SV_blank>%u<S2SV_blank>%08X.\\n" , hook , pos , e -> comefrom ) ; return 0 ; } e -> comefrom |= ( ( 1 << hook ) | ( 1 << NF_ARP_NUMHOOKS ) ) ; <S2SV_StartBug> if ( ( e -> target_offset == sizeof ( struct arpt_entry ) && <S2SV_EndBug> ( strcmp ( t -> target . u . user . name , XT_STANDARD_TARGET ) == 0 ) && <S2SV_StartBug> t -> verdict < 0 && unconditional ( & e -> arp ) ) || <S2SV_EndBug> visited ) { unsigned int oldpos , size ; if ( ( strcmp ( t -> target . u . user . name , XT_STANDARD_TARGET ) == 0 ) && t -> verdict < - NF_MAX_VERDICT - 1 ) { duprintf ( "mark_source_chains:<S2SV_blank>bad<S2SV_blank>" "negative<S2SV_blank>verdict<S2SV_blank>(%i)\\n" , t -> verdict ) ; return 0 ; } do { e -> comefrom ^= ( 1 << NF_ARP_NUMHOOKS ) ; oldpos = pos ; pos = e -> counters . pcnt ; e -> counters . pcnt = 0 ; if ( pos == oldpos ) goto next ; e = ( struct arpt_entry * ) ( entry0 + pos ) ; } while ( oldpos == pos + e -> next_offset ) ; size = e -> next_offset ; e = ( struct arpt_entry * ) ( entry0 + pos + size ) ; e -> counters . pcnt = pos ; pos += size ; } else { int newpos = t -> verdict ; if ( strcmp ( t -> target . u . user . name , XT_STANDARD_TARGET ) == 0 && newpos >= 0 ) { if ( newpos > newinfo -> size - sizeof ( struct arpt_entry ) ) { duprintf ( "mark_source_chains:<S2SV_blank>" "bad<S2SV_blank>verdict<S2SV_blank>(%i)\\n" , newpos ) ; return 0 ; } duprintf ( "Jump<S2SV_blank>rule<S2SV_blank>%u<S2SV_blank>-><S2SV_blank>%u\\n" , pos , newpos ) ; } else { newpos = pos + e -> next_offset ; } e = ( struct arpt_entry * ) ( entry0 + newpos ) ; e -> counters . pcnt = pos ; pos = newpos ; } } next : duprintf ( "Finished<S2SV_blank>chain<S2SV_blank>%u\\n" , hook ) ; } return 1 ; }
static int perf_swevent_init ( struct perf_event * event ) { <S2SV_StartBug> int event_id = event -> attr . config ; <S2SV_EndBug> if ( event -> attr . type != PERF_TYPE_SOFTWARE ) return - ENOENT ; if ( has_branch_stack ( event ) ) return - EOPNOTSUPP ; switch ( event_id ) { case PERF_COUNT_SW_CPU_CLOCK : case PERF_COUNT_SW_TASK_CLOCK : return - ENOENT ; default : break ; } if ( event_id >= PERF_COUNT_SW_MAX ) return - ENOENT ; if ( ! event -> parent ) { int err ; err = swevent_hlist_get ( event ) ; if ( err ) return err ; static_key_slow_inc ( & perf_swevent_enabled [ event_id ] ) ; event -> destroy = sw_perf_event_destroy ; } return 0 ; }
static future_t * init ( void ) { pthread_mutex_init ( & lock , NULL ) ; config = config_new ( CONFIG_FILE_PATH ) ; if ( ! config ) { LOG_WARN ( LOG_TAG , "%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>load<S2SV_blank>config<S2SV_blank>file;<S2SV_blank>attempting<S2SV_blank>to<S2SV_blank>transcode<S2SV_blank>legacy<S2SV_blank>file." , __func__ ) ; config = btif_config_transcode ( LEGACY_CONFIG_FILE_PATH ) ; if ( ! config ) { LOG_WARN ( LOG_TAG , "%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>transcode<S2SV_blank>legacy<S2SV_blank>file,<S2SV_blank>starting<S2SV_blank>unconfigured." , __func__ ) ; config = config_new_empty ( ) ; if ( ! config ) { LOG_ERROR ( LOG_TAG , "%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>allocate<S2SV_blank>a<S2SV_blank>config<S2SV_blank>object." , __func__ ) ; goto error ; } } if ( config_save ( config , CONFIG_FILE_PATH ) ) unlink ( LEGACY_CONFIG_FILE_PATH ) ; } <S2SV_StartBug> alarm_timer = alarm_new ( ) ; <S2SV_EndBug> if ( ! alarm_timer ) { LOG_ERROR ( LOG_TAG , "%s<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>create<S2SV_blank>alarm." , __func__ ) ; goto error ; } return future_new_immediate ( FUTURE_SUCCESS ) ; error : ; alarm_free ( alarm_timer ) ; config_free ( config ) ; pthread_mutex_destroy ( & lock ) ; alarm_timer = NULL ; config = NULL ; return future_new_immediate ( FUTURE_FAIL ) ; }
static int ext4_fill_flex_info ( struct super_block * sb ) { struct ext4_sb_info * sbi = EXT4_SB ( sb ) ; struct ext4_group_desc * gdp = NULL ; ext4_group_t flex_group_count ; ext4_group_t flex_group ; <S2SV_StartBug> int groups_per_flex = 0 ; <S2SV_EndBug> size_t size ; int i ; sbi -> s_log_groups_per_flex = sbi -> s_es -> s_log_groups_per_flex ; <S2SV_StartBug> groups_per_flex = 1 << sbi -> s_log_groups_per_flex ; <S2SV_EndBug> <S2SV_StartBug> if ( groups_per_flex < 2 ) { <S2SV_EndBug> sbi -> s_log_groups_per_flex = 0 ; return 1 ; } flex_group_count = ( ( sbi -> s_groups_count + groups_per_flex - 1 ) + ( ( le16_to_cpu ( sbi -> s_es -> s_reserved_gdt_blocks ) + 1 ) << EXT4_DESC_PER_BLOCK_BITS ( sb ) ) ) / groups_per_flex ; size = flex_group_count * sizeof ( struct flex_groups ) ; sbi -> s_flex_groups = ext4_kvzalloc ( size , GFP_KERNEL ) ; if ( sbi -> s_flex_groups == NULL ) { ext4_msg ( sb , KERN_ERR , "not<S2SV_blank>enough<S2SV_blank>memory<S2SV_blank>for<S2SV_blank>%u<S2SV_blank>flex<S2SV_blank>groups" , flex_group_count ) ; goto failed ; } for ( i = 0 ; i < sbi -> s_groups_count ; i ++ ) { gdp = ext4_get_group_desc ( sb , i , NULL ) ; flex_group = ext4_flex_group ( sbi , i ) ; atomic_add ( ext4_free_inodes_count ( sb , gdp ) , & sbi -> s_flex_groups [ flex_group ] . free_inodes ) ; atomic_add ( ext4_free_group_clusters ( sb , gdp ) , & sbi -> s_flex_groups [ flex_group ] . free_clusters ) ; atomic_add ( ext4_used_dirs_count ( sb , gdp ) , & sbi -> s_flex_groups [ flex_group ] . used_dirs ) ; } return 1 ; failed : return 0 ; }
static int matchCurrentInput ( const InString * input , int pos , const widechar * passInstructions , int passIC ) { int k ; int kk = pos ; <S2SV_StartBug> for ( k = passIC + 2 ; k < passIC + 2 + passInstructions [ passIC + 1 ] ; k ++ ) <S2SV_EndBug> if ( input -> chars [ kk ] == ENDSEGMENT || passInstructions [ k ] != input -> chars [ kk ++ ] ) return 0 ; return 1 ; }
static netdev_tx_t veth_xmit ( struct sk_buff * skb , struct net_device * dev ) { struct net_device * rcv = NULL ; struct veth_priv * priv , * rcv_priv ; struct veth_net_stats * stats , * rcv_stats ; int length ; priv = netdev_priv ( dev ) ; rcv = priv -> peer ; rcv_priv = netdev_priv ( rcv ) ; stats = this_cpu_ptr ( priv -> stats ) ; rcv_stats = this_cpu_ptr ( rcv_priv -> stats ) ; if ( ! ( rcv -> flags & IFF_UP ) ) goto tx_drop ; if ( dev -> features & NETIF_F_NO_CSUM ) skb -> ip_summed = rcv_priv -> ip_summed ; length = skb -> len + ETH_HLEN ; if ( dev_forward_skb ( rcv , skb ) != NET_RX_SUCCESS ) goto rx_drop ; stats -> tx_bytes += length ; stats -> tx_packets ++ ; rcv_stats -> rx_bytes += length ; rcv_stats -> rx_packets ++ ; return NETDEV_TX_OK ; tx_drop : kfree_skb ( skb ) ; stats -> tx_dropped ++ ; return NETDEV_TX_OK ; rx_drop : <S2SV_StartBug> kfree_skb ( skb ) ; <S2SV_EndBug> rcv_stats -> rx_dropped ++ ; return NETDEV_TX_OK ; }
static int smbhash ( unsigned char * out , const unsigned char * in , unsigned char * key ) { <S2SV_StartBug> int rc ; <S2SV_EndBug> unsigned char key2 [ 8 ] ; <S2SV_StartBug> struct crypto_skcipher * tfm_des ; <S2SV_EndBug> struct scatterlist sgin , sgout ; struct skcipher_request * req ; str_to_key ( key , key2 ) ; <S2SV_StartBug> tfm_des = crypto_alloc_skcipher ( "ecb(des)" , 0 , CRYPTO_ALG_ASYNC ) ; <S2SV_EndBug> if ( IS_ERR ( tfm_des ) ) { <S2SV_StartBug> rc = PTR_ERR ( tfm_des ) ; <S2SV_EndBug> cifs_dbg ( VFS , "could<S2SV_blank>not<S2SV_blank>allocate<S2SV_blank>des<S2SV_blank>crypto<S2SV_blank>API\\n" ) ; <S2SV_StartBug> goto smbhash_err ; <S2SV_EndBug> } req = skcipher_request_alloc ( tfm_des , GFP_KERNEL ) ; if ( ! req ) { rc = - ENOMEM ; cifs_dbg ( VFS , "could<S2SV_blank>not<S2SV_blank>allocate<S2SV_blank>des<S2SV_blank>crypto<S2SV_blank>API\\n" ) ; goto smbhash_free_skcipher ; } crypto_skcipher_setkey ( tfm_des , key2 , 8 ) ; <S2SV_StartBug> sg_init_one ( & sgin , in , 8 ) ; <S2SV_EndBug> sg_init_one ( & sgout , out , 8 ) ; skcipher_request_set_callback ( req , 0 , NULL , NULL ) ; skcipher_request_set_crypt ( req , & sgin , & sgout , 8 , NULL ) ; rc = crypto_skcipher_encrypt ( req ) ; if ( rc ) cifs_dbg ( VFS , "could<S2SV_blank>not<S2SV_blank>encrypt<S2SV_blank>crypt<S2SV_blank>key<S2SV_blank>rc:<S2SV_blank>%d\\n" , rc ) ; skcipher_request_free ( req ) ; smbhash_free_skcipher : crypto_free_skcipher ( tfm_des ) ; <S2SV_StartBug> smbhash_err : <S2SV_EndBug> return rc ; }
void ff_jpeg2000_cleanup ( Jpeg2000Component * comp , Jpeg2000CodingStyle * codsty ) { int reslevelno , bandno , precno ; for ( reslevelno = 0 ; comp -> reslevel && reslevelno < codsty -> nreslevels ; reslevelno ++ ) { Jpeg2000ResLevel * reslevel = comp -> reslevel + reslevelno ; for ( bandno = 0 ; bandno < reslevel -> nbands ; bandno ++ ) { Jpeg2000Band * band = reslevel -> band + bandno ; for ( precno = 0 ; precno < reslevel -> num_precincts_x * reslevel -> num_precincts_y ; precno ++ ) { <S2SV_StartBug> Jpeg2000Prec * prec = band -> prec + precno ; <S2SV_EndBug> av_freep ( & prec -> zerobits ) ; av_freep ( & prec -> cblkincl ) ; av_freep ( & prec -> cblk ) ; } <S2SV_StartBug> av_freep ( & band -> prec ) ; <S2SV_EndBug> } av_freep ( & reslevel -> band ) ; } ff_dwt_destroy ( & comp -> dwt ) ; av_freep ( & comp -> reslevel ) ; av_freep ( & comp -> i_data ) ; av_freep ( & comp -> f_data ) ; }
int fit_check_format ( const void * fit , ulong size ) { int ret ; ret = fdt_check_header ( fit ) ; if ( ret ) { log_debug ( "Wrong<S2SV_blank>FIT<S2SV_blank>format:<S2SV_blank>not<S2SV_blank>a<S2SV_blank>flattened<S2SV_blank>device<S2SV_blank>tree<S2SV_blank>(err=%d)\\n" , ret ) ; return - ENOEXEC ; } if ( CONFIG_IS_ENABLED ( FIT_FULL_CHECK ) ) { if ( size == IMAGE_SIZE_INVAL ) size = fdt_totalsize ( fit ) ; ret = fdt_check_full ( fit , size ) ; <S2SV_StartBug> if ( ret ) { <S2SV_EndBug> log_debug ( "FIT<S2SV_blank>check<S2SV_blank>error<S2SV_blank>%d\\n" , ret ) ; <S2SV_StartBug> return - EINVAL ; <S2SV_EndBug> } } if ( ! fdt_getprop ( fit , 0 , FIT_DESC_PROP , NULL ) ) { log_debug ( "Wrong<S2SV_blank>FIT<S2SV_blank>format:<S2SV_blank>no<S2SV_blank>description\\n" ) ; return - ENOMSG ; } if ( IMAGE_ENABLE_TIMESTAMP ) { if ( ! fdt_getprop ( fit , 0 , FIT_TIMESTAMP_PROP , NULL ) ) { log_debug ( "Wrong<S2SV_blank>FIT<S2SV_blank>format:<S2SV_blank>no<S2SV_blank>timestamp\\n" ) ; return - ENODATA ; } } if ( fdt_path_offset ( fit , FIT_IMAGES_PATH ) < 0 ) { log_debug ( "Wrong<S2SV_blank>FIT<S2SV_blank>format:<S2SV_blank>no<S2SV_blank>images<S2SV_blank>parent<S2SV_blank>node\\n" ) ; return - ENOENT ; } return 0 ; }
int mainloop ( CLIENT * client ) { struct nbd_request request ; struct nbd_reply reply ; gboolean go_on = TRUE ; # ifdef DODBG int i = 0 ; # endif negotiate ( client -> net , client , NULL ) ; DEBUG ( "Entering<S2SV_blank>request<S2SV_blank>loop!\\n" ) ; reply . magic = htonl ( NBD_REPLY_MAGIC ) ; reply . error = 0 ; while ( go_on ) { char buf [ BUFSIZE ] ; size_t len ; # ifdef DODBG i ++ ; printf ( "%d:<S2SV_blank>" , i ) ; # endif readit ( client -> net , & request , sizeof ( request ) ) ; request . from = ntohll ( request . from ) ; request . type = ntohl ( request . type ) ; if ( request . type == NBD_CMD_DISC ) { msg2 ( LOG_INFO , "Disconnect<S2SV_blank>request<S2SV_blank>received." ) ; if ( client -> server -> flags & F_COPYONWRITE ) { if ( client -> difmap ) g_free ( client -> difmap ) ; close ( client -> difffile ) ; unlink ( client -> difffilename ) ; free ( client -> difffilename ) ; } go_on = FALSE ; continue ; } len = ntohl ( request . len ) ; if ( request . magic != htonl ( NBD_REQUEST_MAGIC ) ) err ( "Not<S2SV_blank>enough<S2SV_blank>magic." ) ; <S2SV_StartBug> if ( len > BUFSIZE + sizeof ( struct nbd_reply ) ) <S2SV_EndBug> err ( "Request<S2SV_blank>too<S2SV_blank>big!" ) ; # ifdef DODBG printf ( "%s<S2SV_blank>from<S2SV_blank>%llu<S2SV_blank>(%llu)<S2SV_blank>len<S2SV_blank>%d,<S2SV_blank>" , request . type ? "WRITE" : "READ" , ( unsigned long long ) request . from , ( unsigned long long ) request . from / 512 , len ) ; # endif memcpy ( reply . handle , request . handle , sizeof ( reply . handle ) ) ; if ( ( request . from + len ) > ( OFFT_MAX ) ) { DEBUG ( "[Number<S2SV_blank>too<S2SV_blank>large!]" ) ; ERROR ( client , reply , EINVAL ) ; continue ; } if ( ( ( ssize_t ) ( ( off_t ) request . from + len ) > client -> exportsize ) ) { DEBUG ( "[RANGE!]" ) ; ERROR ( client , reply , EINVAL ) ; continue ; } if ( request . type == NBD_CMD_WRITE ) { DEBUG ( "wr:<S2SV_blank>net->buf,<S2SV_blank>" ) ; readit ( client -> net , buf , len ) ; DEBUG ( "buf->exp,<S2SV_blank>" ) ; if ( ( client -> server -> flags & F_READONLY ) || ( client -> server -> flags & F_AUTOREADONLY ) ) { DEBUG ( "[WRITE<S2SV_blank>to<S2SV_blank>READONLY!]" ) ; ERROR ( client , reply , EPERM ) ; continue ; } if ( expwrite ( request . from , buf , len , client ) ) { DEBUG ( "Write<S2SV_blank>failed:<S2SV_blank>%m" ) ; ERROR ( client , reply , errno ) ; continue ; } SEND ( client -> net , reply ) ; DEBUG ( "OK!\\n" ) ; continue ; } DEBUG ( "exp->buf,<S2SV_blank>" ) ; if ( expread ( request . from , buf + sizeof ( struct nbd_reply ) , len , client ) ) { DEBUG ( "Read<S2SV_blank>failed:<S2SV_blank>%m" ) ; ERROR ( client , reply , errno ) ; continue ; } DEBUG ( "buf->net,<S2SV_blank>" ) ; memcpy ( buf , & reply , sizeof ( struct nbd_reply ) ) ; writeit ( client -> net , buf , len + sizeof ( struct nbd_reply ) ) ; DEBUG ( "OK!\\n" ) ; } return 0 ; }
static int udf_load_logicalvol ( struct super_block * sb , sector_t block , struct kernel_lb_addr * fileset ) { struct logicalVolDesc * lvd ; int i , j , offset ; uint8_t type ; struct udf_sb_info * sbi = UDF_SB ( sb ) ; struct genericPartitionMap * gpm ; uint16_t ident ; struct buffer_head * bh ; <S2SV_StartBug> int ret = 0 ; <S2SV_EndBug> bh = udf_read_tagged ( sb , block , block , & ident ) ; if ( ! bh ) return 1 ; BUG_ON ( ident != TAG_IDENT_LVD ) ; <S2SV_StartBug> lvd = ( struct logicalVolDesc * ) bh -> b_data ; <S2SV_EndBug> ret = udf_sb_alloc_partition_maps ( sb , le32_to_cpu ( lvd -> numPartitionMaps ) ) ; if ( ret ) goto out_bh ; for ( i = 0 , offset = 0 ; <S2SV_StartBug> i < sbi -> s_partitions && offset < le32_to_cpu ( lvd -> mapTableLength ) ; <S2SV_EndBug> i ++ , offset += gpm -> partitionMapLength ) { struct udf_part_map * map = & sbi -> s_partmaps [ i ] ; gpm = ( struct genericPartitionMap * ) & ( lvd -> partitionMaps [ offset ] ) ; type = gpm -> partitionMapType ; if ( type == 1 ) { struct genericPartitionMap1 * gpm1 = ( struct genericPartitionMap1 * ) gpm ; map -> s_partition_type = UDF_TYPE1_MAP15 ; map -> s_volumeseqnum = le16_to_cpu ( gpm1 -> volSeqNum ) ; map -> s_partition_num = le16_to_cpu ( gpm1 -> partitionNum ) ; map -> s_partition_func = NULL ; } else if ( type == 2 ) { struct udfPartitionMap2 * upm2 = ( struct udfPartitionMap2 * ) gpm ; if ( ! strncmp ( upm2 -> partIdent . ident , UDF_ID_VIRTUAL , strlen ( UDF_ID_VIRTUAL ) ) ) { u16 suf = le16_to_cpu ( ( ( __le16 * ) upm2 -> partIdent . identSuffix ) [ 0 ] ) ; if ( suf < 0x0200 ) { map -> s_partition_type = UDF_VIRTUAL_MAP15 ; map -> s_partition_func = udf_get_pblock_virt15 ; } else { map -> s_partition_type = UDF_VIRTUAL_MAP20 ; map -> s_partition_func = udf_get_pblock_virt20 ; } } else if ( ! strncmp ( upm2 -> partIdent . ident , UDF_ID_SPARABLE , strlen ( UDF_ID_SPARABLE ) ) ) { uint32_t loc ; struct sparingTable * st ; struct sparablePartitionMap * spm = ( struct sparablePartitionMap * ) gpm ; map -> s_partition_type = UDF_SPARABLE_MAP15 ; map -> s_type_specific . s_sparing . s_packet_len = le16_to_cpu ( spm -> packetLength ) ; for ( j = 0 ; j < spm -> numSparingTables ; j ++ ) { struct buffer_head * bh2 ; loc = le32_to_cpu ( spm -> locSparingTable [ j ] ) ; bh2 = udf_read_tagged ( sb , loc , loc , & ident ) ; map -> s_type_specific . s_sparing . s_spar_map [ j ] = bh2 ; if ( bh2 == NULL ) continue ; st = ( struct sparingTable * ) bh2 -> b_data ; if ( ident != 0 || strncmp ( st -> sparingIdent . ident , UDF_ID_SPARING , strlen ( UDF_ID_SPARING ) ) ) { brelse ( bh2 ) ; map -> s_type_specific . s_sparing . s_spar_map [ j ] = NULL ; } } map -> s_partition_func = udf_get_pblock_spar15 ; } else if ( ! strncmp ( upm2 -> partIdent . ident , UDF_ID_METADATA , strlen ( UDF_ID_METADATA ) ) ) { struct udf_meta_data * mdata = & map -> s_type_specific . s_metadata ; struct metadataPartitionMap * mdm = ( struct metadataPartitionMap * ) & ( lvd -> partitionMaps [ offset ] ) ; udf_debug ( "Parsing<S2SV_blank>Logical<S2SV_blank>vol<S2SV_blank>part<S2SV_blank>%d<S2SV_blank>type<S2SV_blank>%d<S2SV_blank><S2SV_blank>id=%s\\n" , i , type , UDF_ID_METADATA ) ; map -> s_partition_type = UDF_METADATA_MAP25 ; map -> s_partition_func = udf_get_pblock_meta25 ; mdata -> s_meta_file_loc = le32_to_cpu ( mdm -> metadataFileLoc ) ; mdata -> s_mirror_file_loc = le32_to_cpu ( mdm -> metadataMirrorFileLoc ) ; mdata -> s_bitmap_file_loc = le32_to_cpu ( mdm -> metadataBitmapFileLoc ) ; mdata -> s_alloc_unit_size = le32_to_cpu ( mdm -> allocUnitSize ) ; mdata -> s_align_unit_size = le16_to_cpu ( mdm -> alignUnitSize ) ; if ( mdm -> flags & 0x01 ) mdata -> s_flags |= MF_DUPLICATE_MD ; udf_debug ( "Metadata<S2SV_blank>Ident<S2SV_blank>suffix=0x%x\\n" , le16_to_cpu ( * ( __le16 * ) mdm -> partIdent . identSuffix ) ) ; udf_debug ( "Metadata<S2SV_blank>part<S2SV_blank>num=%d\\n" , le16_to_cpu ( mdm -> partitionNum ) ) ; udf_debug ( "Metadata<S2SV_blank>part<S2SV_blank>alloc<S2SV_blank>unit<S2SV_blank>size=%d\\n" , le32_to_cpu ( mdm -> allocUnitSize ) ) ; udf_debug ( "Metadata<S2SV_blank>file<S2SV_blank>loc=%d\\n" , le32_to_cpu ( mdm -> metadataFileLoc ) ) ; udf_debug ( "Mirror<S2SV_blank>file<S2SV_blank>loc=%d\\n" , le32_to_cpu ( mdm -> metadataMirrorFileLoc ) ) ; udf_debug ( "Bitmap<S2SV_blank>file<S2SV_blank>loc=%d\\n" , le32_to_cpu ( mdm -> metadataBitmapFileLoc ) ) ; udf_debug ( "Flags:<S2SV_blank>%d<S2SV_blank>%d\\n" , mdata -> s_flags , mdm -> flags ) ; } else { udf_debug ( "Unknown<S2SV_blank>ident:<S2SV_blank>%s\\n" , upm2 -> partIdent . ident ) ; continue ; } map -> s_volumeseqnum = le16_to_cpu ( upm2 -> volSeqNum ) ; map -> s_partition_num = le16_to_cpu ( upm2 -> partitionNum ) ; } udf_debug ( "Partition<S2SV_blank>(%d:%d)<S2SV_blank>type<S2SV_blank>%d<S2SV_blank>on<S2SV_blank>volume<S2SV_blank>%d\\n" , i , map -> s_partition_num , type , map -> s_volumeseqnum ) ; } if ( fileset ) { struct long_ad * la = ( struct long_ad * ) & ( lvd -> logicalVolContentsUse [ 0 ] ) ; * fileset = lelb_to_cpu ( la -> extLocation ) ; udf_debug ( "FileSet<S2SV_blank>found<S2SV_blank>in<S2SV_blank>LogicalVolDesc<S2SV_blank>at<S2SV_blank>block=%d,<S2SV_blank>partition=%d\\n" , fileset -> logicalBlockNum , fileset -> partitionReferenceNum ) ; } if ( lvd -> integritySeqExt . extLength ) udf_load_logicalvolint ( sb , leea_to_cpu ( lvd -> integritySeqExt ) ) ; out_bh : brelse ( bh ) ; return ret ; }
void vp8dx_bool_decoder_fill ( BOOL_DECODER * br ) { const unsigned char * bufptr = br -> user_buffer ; VP8_BD_VALUE value = br -> value ; int count = br -> count ; <S2SV_StartBug> int shift = VP8_BD_VALUE_SIZE - 8 - ( count + 8 ) ; <S2SV_EndBug> size_t bytes_left = br -> user_buffer_end - bufptr ; size_t bits_left = bytes_left * CHAR_BIT ; int x = ( int ) ( shift + CHAR_BIT - bits_left ) ; int loop_end = 0 ; unsigned char decrypted [ sizeof ( VP8_BD_VALUE ) + 1 ] ; if ( br -> decrypt_cb ) { <S2SV_StartBug> size_t n = bytes_left > sizeof ( decrypted ) ? sizeof ( decrypted ) : bytes_left ; <S2SV_EndBug> br -> decrypt_cb ( br -> decrypt_state , bufptr , decrypted , ( int ) n ) ; bufptr = decrypted ; } if ( x >= 0 ) { count += VP8_LOTS_OF_BITS ; loop_end = x ; } if ( x < 0 || bits_left ) { while ( shift >= loop_end ) { count += CHAR_BIT ; value |= ( VP8_BD_VALUE ) * bufptr << shift ; ++ bufptr ; ++ br -> user_buffer ; shift -= CHAR_BIT ; } } br -> value = value ; br -> count = count ; }
static int get_endpoints ( struct usbtest_dev * dev , struct usb_interface * intf ) { int tmp ; struct usb_host_interface * alt ; struct usb_host_endpoint * in , * out ; struct usb_host_endpoint * iso_in , * iso_out ; struct usb_host_endpoint * int_in , * int_out ; struct usb_device * udev ; for ( tmp = 0 ; tmp < intf -> num_altsetting ; tmp ++ ) { unsigned ep ; in = out = NULL ; iso_in = iso_out = NULL ; int_in = int_out = NULL ; alt = intf -> altsetting + tmp ; if ( override_alt >= 0 && override_alt != alt -> desc . bAlternateSetting ) continue ; for ( ep = 0 ; ep < alt -> desc . bNumEndpoints ; ep ++ ) { struct usb_host_endpoint * e ; int edi ; e = alt -> endpoint + ep ; edi = usb_endpoint_dir_in ( & e -> desc ) ; switch ( usb_endpoint_type ( & e -> desc ) ) { case USB_ENDPOINT_XFER_BULK : endpoint_update ( edi , & in , & out , e ) ; continue ; case USB_ENDPOINT_XFER_INT : if ( dev -> info -> intr ) endpoint_update ( edi , & int_in , & int_out , e ) ; continue ; case USB_ENDPOINT_XFER_ISOC : if ( dev -> info -> iso ) endpoint_update ( edi , & iso_in , & iso_out , e ) ; default : continue ; } } if ( ( in && out ) || iso_in || iso_out || int_in || int_out ) goto found ; } return - EINVAL ; found : udev = testdev_to_usbdev ( dev ) ; dev -> info -> alt = alt -> desc . bAlternateSetting ; if ( alt -> desc . bAlternateSetting != 0 ) { tmp = usb_set_interface ( udev , alt -> desc . bInterfaceNumber , alt -> desc . bAlternateSetting ) ; if ( tmp < 0 ) return tmp ; } <S2SV_StartBug> if ( in ) { <S2SV_EndBug> dev -> in_pipe = usb_rcvbulkpipe ( udev , in -> desc . bEndpointAddress & USB_ENDPOINT_NUMBER_MASK ) ; <S2SV_StartBug> dev -> out_pipe = usb_sndbulkpipe ( udev , <S2SV_EndBug> out -> desc . bEndpointAddress & USB_ENDPOINT_NUMBER_MASK ) ; <S2SV_StartBug> } <S2SV_EndBug> if ( iso_in ) { dev -> iso_in = & iso_in -> desc ; dev -> in_iso_pipe = usb_rcvisocpipe ( udev , iso_in -> desc . bEndpointAddress & USB_ENDPOINT_NUMBER_MASK ) ; } if ( iso_out ) { dev -> iso_out = & iso_out -> desc ; dev -> out_iso_pipe = usb_sndisocpipe ( udev , iso_out -> desc . bEndpointAddress & USB_ENDPOINT_NUMBER_MASK ) ; } if ( int_in ) { dev -> int_in = & int_in -> desc ; dev -> in_int_pipe = usb_rcvintpipe ( udev , int_in -> desc . bEndpointAddress & USB_ENDPOINT_NUMBER_MASK ) ; } if ( int_out ) { dev -> int_out = & int_out -> desc ; dev -> out_int_pipe = usb_sndintpipe ( udev , int_out -> desc . bEndpointAddress & USB_ENDPOINT_NUMBER_MASK ) ; } return 0 ; }
static int decode_frame_common ( AVCodecContext * avctx , PNGDecContext * s , AVFrame * p , AVPacket * avpkt ) { AVDictionary * metadata = NULL ; uint32_t tag , length ; int decode_next_dat = 0 ; int ret ; for ( ; ; ) { length = bytestream2_get_bytes_left ( & s -> gb ) ; if ( length <= 0 ) { if ( avctx -> codec_id == AV_CODEC_ID_PNG && avctx -> skip_frame == AVDISCARD_ALL ) { av_frame_set_metadata ( p , metadata ) ; return 0 ; } if ( CONFIG_APNG_DECODER && avctx -> codec_id == AV_CODEC_ID_APNG && length == 0 ) { if ( ! ( s -> state & PNG_IDAT ) ) return 0 ; else goto exit_loop ; } av_log ( avctx , AV_LOG_ERROR , "%d<S2SV_blank>bytes<S2SV_blank>left\\n" , length ) ; if ( s -> state & PNG_ALLIMAGE && avctx -> strict_std_compliance <= FF_COMPLIANCE_NORMAL ) goto exit_loop ; ret = AVERROR_INVALIDDATA ; goto fail ; } length = bytestream2_get_be32 ( & s -> gb ) ; if ( length > 0x7fffffff || length > bytestream2_get_bytes_left ( & s -> gb ) ) { av_log ( avctx , AV_LOG_ERROR , "chunk<S2SV_blank>too<S2SV_blank>big\\n" ) ; ret = AVERROR_INVALIDDATA ; goto fail ; } tag = bytestream2_get_le32 ( & s -> gb ) ; if ( avctx -> debug & FF_DEBUG_STARTCODE ) av_log ( avctx , AV_LOG_DEBUG , "png:<S2SV_blank>tag=%c%c%c%c<S2SV_blank>length=%u\\n" , ( tag & 0xff ) , ( ( tag >> 8 ) & 0xff ) , ( ( tag >> 16 ) & 0xff ) , ( ( tag >> 24 ) & 0xff ) , length ) ; if ( avctx -> codec_id == AV_CODEC_ID_PNG && avctx -> skip_frame == AVDISCARD_ALL ) { switch ( tag ) { case MKTAG ( 'I' , 'H' , 'D' , 'R' ) : case MKTAG ( 'p' , 'H' , 'Y' , 's' ) : case MKTAG ( 't' , 'E' , 'X' , 't' ) : case MKTAG ( 'I' , 'D' , 'A' , 'T' ) : case MKTAG ( 't' , 'R' , 'N' , 'S' ) : break ; default : goto skip_tag ; } } switch ( tag ) { case MKTAG ( 'I' , 'H' , 'D' , 'R' ) : if ( ( ret = decode_ihdr_chunk ( avctx , s , length ) ) < 0 ) goto fail ; break ; case MKTAG ( 'p' , 'H' , 'Y' , 's' ) : if ( ( ret = decode_phys_chunk ( avctx , s ) ) < 0 ) goto fail ; break ; case MKTAG ( 'f' , 'c' , 'T' , 'L' ) : if ( ! CONFIG_APNG_DECODER || avctx -> codec_id != AV_CODEC_ID_APNG ) goto skip_tag ; if ( ( ret = decode_fctl_chunk ( avctx , s , length ) ) < 0 ) goto fail ; decode_next_dat = 1 ; break ; case MKTAG ( 'f' , 'd' , 'A' , 'T' ) : if ( ! CONFIG_APNG_DECODER || avctx -> codec_id != AV_CODEC_ID_APNG ) goto skip_tag ; if ( ! decode_next_dat ) { ret = AVERROR_INVALIDDATA ; goto fail ; } bytestream2_get_be32 ( & s -> gb ) ; length -= 4 ; case MKTAG ( 'I' , 'D' , 'A' , 'T' ) : if ( CONFIG_APNG_DECODER && avctx -> codec_id == AV_CODEC_ID_APNG && ! decode_next_dat ) goto skip_tag ; if ( ( ret = decode_idat_chunk ( avctx , s , length , p ) ) < 0 ) goto fail ; break ; case MKTAG ( 'P' , 'L' , 'T' , 'E' ) : if ( decode_plte_chunk ( avctx , s , length ) < 0 ) goto skip_tag ; break ; case MKTAG ( 't' , 'R' , 'N' , 'S' ) : if ( decode_trns_chunk ( avctx , s , length ) < 0 ) goto skip_tag ; break ; case MKTAG ( 't' , 'E' , 'X' , 't' ) : if ( decode_text_chunk ( s , length , 0 , & metadata ) < 0 ) av_log ( avctx , AV_LOG_WARNING , "Broken<S2SV_blank>tEXt<S2SV_blank>chunk\\n" ) ; bytestream2_skip ( & s -> gb , length + 4 ) ; break ; case MKTAG ( 'z' , 'T' , 'X' , 't' ) : if ( decode_text_chunk ( s , length , 1 , & metadata ) < 0 ) av_log ( avctx , AV_LOG_WARNING , "Broken<S2SV_blank>zTXt<S2SV_blank>chunk\\n" ) ; bytestream2_skip ( & s -> gb , length + 4 ) ; break ; case MKTAG ( 's' , 'T' , 'E' , 'R' ) : { int mode = bytestream2_get_byte ( & s -> gb ) ; AVStereo3D * stereo3d = av_stereo3d_create_side_data ( p ) ; if ( ! stereo3d ) goto fail ; if ( mode == 0 || mode == 1 ) { stereo3d -> type = AV_STEREO3D_SIDEBYSIDE ; stereo3d -> flags = mode ? 0 : AV_STEREO3D_FLAG_INVERT ; } else { av_log ( avctx , AV_LOG_WARNING , "Unknown<S2SV_blank>value<S2SV_blank>in<S2SV_blank>sTER<S2SV_blank>chunk<S2SV_blank>(%d)\\n" , mode ) ; } bytestream2_skip ( & s -> gb , 4 ) ; break ; } case MKTAG ( 'I' , 'E' , 'N' , 'D' ) : if ( ! ( s -> state & PNG_ALLIMAGE ) ) av_log ( avctx , AV_LOG_ERROR , "IEND<S2SV_blank>without<S2SV_blank>all<S2SV_blank>image\\n" ) ; if ( ! ( s -> state & ( PNG_ALLIMAGE | PNG_IDAT ) ) ) { ret = AVERROR_INVALIDDATA ; goto fail ; } bytestream2_skip ( & s -> gb , 4 ) ; goto exit_loop ; default : skip_tag : bytestream2_skip ( & s -> gb , length + 4 ) ; break ; } } exit_loop : if ( avctx -> codec_id == AV_CODEC_ID_PNG && avctx -> skip_frame == AVDISCARD_ALL ) { av_frame_set_metadata ( p , metadata ) ; return 0 ; } if ( s -> bits_per_pixel <= 4 ) handle_small_bpp ( s , p ) ; if ( s -> has_trns && s -> color_type != PNG_COLOR_TYPE_PALETTE ) { size_t byte_depth = s -> bit_depth > 8 ? 2 : 1 ; size_t raw_bpp = s -> bpp - byte_depth ; unsigned x , y ; <S2SV_StartBug> for ( y = 0 ; y < s -> height ; ++ y ) { <S2SV_EndBug> uint8_t * row = & s -> image_buf [ s -> image_linesize * y ] ; for ( x = s -> width ; x > 0 ; -- x ) { uint8_t * pixel = & row [ s -> bpp * ( x - 1 ) ] ; memmove ( pixel , & row [ raw_bpp * ( x - 1 ) ] , raw_bpp ) ; if ( ! memcmp ( pixel , s -> transparent_color_be , raw_bpp ) ) { memset ( & pixel [ raw_bpp ] , 0 , byte_depth ) ; } else { memset ( & pixel [ raw_bpp ] , 0xff , byte_depth ) ; } } } } if ( s -> last_picture . f -> data [ 0 ] ) { if ( ! ( avpkt -> flags & AV_PKT_FLAG_KEY ) && avctx -> codec_tag != AV_RL32 ( "MPNG" ) && s -> last_picture . f -> width == p -> width && s -> last_picture . f -> height == p -> height && s -> last_picture . f -> format == p -> format ) { if ( CONFIG_PNG_DECODER && avctx -> codec_id != AV_CODEC_ID_APNG ) handle_p_frame_png ( s , p ) ; else if ( CONFIG_APNG_DECODER && avctx -> codec_id == AV_CODEC_ID_APNG && ( ret = handle_p_frame_apng ( avctx , s , p ) ) < 0 ) goto fail ; } } ff_thread_report_progress ( & s -> picture , INT_MAX , 0 ) ; ff_thread_report_progress ( & s -> previous_picture , INT_MAX , 0 ) ; av_frame_set_metadata ( p , metadata ) ; metadata = NULL ; return 0 ; fail : av_dict_free ( & metadata ) ; ff_thread_report_progress ( & s -> picture , INT_MAX , 0 ) ; ff_thread_report_progress ( & s -> previous_picture , INT_MAX , 0 ) ; return ret ; }
<S2SV_StartBug> static void nfs4_return_incompatible_delegation ( struct inode * inode , mode_t open_flags ) <S2SV_EndBug> { struct nfs_delegation * delegation ; rcu_read_lock ( ) ; delegation = rcu_dereference ( NFS_I ( inode ) -> delegation ) ; <S2SV_StartBug> if ( delegation == NULL || ( delegation -> type & open_flags ) == open_flags ) { <S2SV_EndBug> rcu_read_unlock ( ) ; return ; } rcu_read_unlock ( ) ; nfs_inode_return_delegation ( inode ) ; }
<S2SV_StartBug> void jslTokenAsString ( int token , char * str , size_t len ) { <S2SV_EndBug> if ( token > 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { <S2SV_StartBug> case LEX_EOF : strncpy ( str , "EOF" , len ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case LEX_ID : strncpy ( str , "ID" , len ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case LEX_INT : strncpy ( str , "INT" , len ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case LEX_FLOAT : strncpy ( str , "FLOAT" , len ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case LEX_STR : strncpy ( str , "STRING" , len ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case LEX_UNFINISHED_STR : strncpy ( str , "UNFINISHED<S2SV_blank>STRING" , len ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case LEX_TEMPLATE_LITERAL : strncpy ( str , "TEMPLATE<S2SV_blank>LITERAL" , len ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , "UNFINISHED<S2SV_blank>TEMPLATE<S2SV_blank>LITERAL" , len ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case LEX_REGEX : strncpy ( str , "REGEX" , len ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case LEX_UNFINISHED_REGEX : strncpy ( str , "UNFINISHED<S2SV_blank>REGEX" , len ) ; return ; <S2SV_EndBug> <S2SV_StartBug> case LEX_UNFINISHED_COMMENT : strncpy ( str , "UNFINISHED<S2SV_blank>COMMENT" , len ) ; return ; <S2SV_EndBug> } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = "==\\0" "===\\0" "!=\\0" "!==\\0" "<=\\0" "<<\\0" "<<=\\0" ">=\\0" ">>\\0" ">>>\\0" ">>=\\0" ">>>=\\0" "+=\\0" "-=\\0" "++\\0" "--\\0" "*=\\0" "/=\\0" "%=\\0" "&=\\0" "&&\\0" "|=\\0" "||\\0" "^=\\0" "=>\\0" "if\\0" "else\\0" "do\\0" "while\\0" "for\\0" "return\\0" "continue\\0" "function\\0" "return\\0" "var\\0" "let\\0" "const\\0" "this\\0" "throw\\0" "try\\0" "catch\\0" "finally\\0" "true\\0" "false\\0" "null\\0" "undefined\\0" "new\\0" "in\\0" "instanceof\\0" "switch\\0" "case\\0" "default\\0" "delete\\0" "typeof\\0" "void\\0" "debugger\\0" "class\\0" "extends\\0" "super\\0" "static\\0" ; unsigned int p = 0 ; int n = token - _LEX_OPERATOR_START ; while ( n > 0 && p < sizeof ( tokenNames ) ) { while ( tokenNames [ p ] && p < sizeof ( tokenNames ) ) p ++ ; p ++ ; n -- ; } assert ( n == 0 ) ; <S2SV_StartBug> strncpy ( str , & tokenNames [ p ] , len ) ; <S2SV_EndBug> return ; } <S2SV_StartBug> assert ( len >= 10 ) ; <S2SV_EndBug> espruino_snprintf ( str , len , "?[%d]" , token ) ; }
void * sspi_SecureHandleGetUpperPointer ( SecHandle * handle ) { void * pointer ; <S2SV_StartBug> if ( ! handle ) <S2SV_EndBug> return NULL ; pointer = ( void * ) ~ ( ( size_t ) handle -> dwUpper ) ; return pointer ; }
static int nr_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t size , int flags ) { struct sock * sk = sock -> sk ; struct sockaddr_ax25 * sax = ( struct sockaddr_ax25 * ) msg -> msg_name ; size_t copied ; struct sk_buff * skb ; int er ; lock_sock ( sk ) ; if ( sk -> sk_state != TCP_ESTABLISHED ) { release_sock ( sk ) ; return - ENOTCONN ; } if ( ( skb = skb_recv_datagram ( sk , flags & ~ MSG_DONTWAIT , flags & MSG_DONTWAIT , & er ) ) == NULL ) { release_sock ( sk ) ; return er ; } skb_reset_transport_header ( skb ) ; copied = skb -> len ; if ( copied > size ) { copied = size ; msg -> msg_flags |= MSG_TRUNC ; } er = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; if ( er < 0 ) { skb_free_datagram ( sk , skb ) ; release_sock ( sk ) ; return er ; } if ( sax != NULL ) { <S2SV_StartBug> sax -> sax25_family = AF_NETROM ; <S2SV_EndBug> skb_copy_from_linear_data_offset ( skb , 7 , sax -> sax25_call . ax25_call , AX25_ADDR_LEN ) ; } msg -> msg_namelen = sizeof ( * sax ) ; skb_free_datagram ( sk , skb ) ; release_sock ( sk ) ; return copied ; }
<S2SV_StartBug> static int jas_iccputuint ( jas_stream_t * out , int n , ulonglong val ) <S2SV_EndBug> { int i ; int c ; for ( i = n ; i > 0 ; -- i ) { c = ( val >> ( 8 * ( i - 1 ) ) ) & 0xff ; if ( jas_stream_putc ( out , c ) == EOF ) return - 1 ; } return 0 ; }
fm_mgr_config_errno_t fm_mgr_config_init ( OUT p_fm_config_conx_hdlt * p_hdl , IN int instance , OPTIONAL IN char * rem_address , OPTIONAL IN char * community ) { fm_config_conx_hdl * hdl ; fm_mgr_config_errno_t res = FM_CONF_OK ; if ( ( hdl = calloc ( 1 , sizeof ( fm_config_conx_hdl ) ) ) == NULL ) { res = FM_CONF_NO_MEM ; goto cleanup ; } hdl -> instance = instance ; * p_hdl = hdl ; if ( ! rem_address || ( strcmp ( rem_address , "localhost" ) == 0 ) ) { if ( fm_mgr_config_mgr_connect ( hdl , FM_MGR_SM ) == FM_CONF_INIT_ERR ) { res = FM_CONF_INIT_ERR ; goto cleanup ; } if ( fm_mgr_config_mgr_connect ( hdl , FM_MGR_PM ) == FM_CONF_INIT_ERR ) { res = FM_CONF_INIT_ERR ; goto cleanup ; } if ( fm_mgr_config_mgr_connect ( hdl , FM_MGR_FE ) == FM_CONF_INIT_ERR ) { res = FM_CONF_INIT_ERR ; goto cleanup ; } } <S2SV_StartBug> return res ; <S2SV_EndBug> cleanup : if ( hdl ) { free ( hdl ) ; hdl = NULL ; } return res ; }
NOEXPORT char * parse_service_option ( CMD cmd , SERVICE_OPTIONS * * section_ptr , char * opt , char * arg ) { SERVICE_OPTIONS * section ; int endpoints = 0 ; # ifndef USE_WIN32 struct group * gr ; struct passwd * pw ; # endif section = section_ptr ? * section_ptr : NULL ; if ( cmd == CMD_SET_DEFAULTS || cmd == CMD_SET_COPY ) { section -> ref = 1 ; <S2SV_StartBug> } else if ( cmd == CMD_FREE ) { <S2SV_EndBug> <S2SV_StartBug> if ( section == & service_options || section == & new_service_options ) <S2SV_EndBug> <S2SV_StartBug> s_log ( LOG_DEBUG , "Deallocating<S2SV_blank>section<S2SV_blank>defaults" ) ; <S2SV_EndBug> else s_log ( LOG_DEBUG , "Deallocating<S2SV_blank>section<S2SV_blank>[%s]" , section -> servname ) ; } else if ( cmd == CMD_PRINT_DEFAULTS || cmd == CMD_PRINT_HELP ) { s_log ( LOG_NOTICE , "<S2SV_blank>" ) ; s_log ( LOG_NOTICE , "Service-level<S2SV_blank>options:" ) ; } switch ( cmd ) { case CMD_SET_DEFAULTS : addrlist_clear ( & section -> local_addr , 1 ) ; section -> local_fd = NULL ; break ; case CMD_SET_COPY : addrlist_clear ( & section -> local_addr , 1 ) ; section -> local_fd = NULL ; name_list_dup ( & section -> local_addr . names , new_service_options . local_addr . names ) ; break ; case CMD_FREE : name_list_free ( section -> local_addr . names ) ; str_free ( section -> local_addr . addr ) ; str_free ( section -> local_fd ) ; break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , "accept" ) ) break ; section -> option . accept = 1 ; name_list_append ( & section -> local_addr . names , arg ) ; return NULL ; case CMD_INITIALIZE : if ( section -> local_addr . names ) { unsigned i ; if ( ! addrlist_resolve ( & section -> local_addr ) ) return "Cannot<S2SV_blank>resolve<S2SV_blank>accept<S2SV_blank>target" ; section -> local_fd = str_alloc_detached ( section -> local_addr . num * sizeof ( SOCKET ) ) ; for ( i = 0 ; i < section -> local_addr . num ; ++ i ) section -> local_fd [ i ] = INVALID_SOCKET ; ++ endpoints ; } break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , "%-22s<S2SV_blank>=<S2SV_blank>[host:]port<S2SV_blank>accept<S2SV_blank>connections<S2SV_blank>on<S2SV_blank>specified<S2SV_blank>host:port" , "accept" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : # if 0 section -> ca_dir = ( char * ) X509_get_default_cert_dir ( ) ; # endif section -> ca_dir = NULL ; break ; case CMD_SET_COPY : section -> ca_dir = str_dup_detached ( new_service_options . ca_dir ) ; break ; case CMD_FREE : str_free ( section -> ca_dir ) ; break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , "CApath" ) ) break ; str_free ( section -> ca_dir ) ; if ( arg [ 0 ] ) section -> ca_dir = str_dup_detached ( arg ) ; else section -> ca_dir = NULL ; return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : # if 0 s_log ( LOG_NOTICE , "%-22s<S2SV_blank>=<S2SV_blank>%s" , "CApath" , section -> ca_dir ? section -> ca_dir : "(none)" ) ; # endif break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , "%-22s<S2SV_blank>=<S2SV_blank>CA<S2SV_blank>certificate<S2SV_blank>directory<S2SV_blank>for<S2SV_blank>\'verify\'<S2SV_blank>option" , "CApath" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : # if 0 section -> ca_file = ( char * ) X509_get_default_certfile ( ) ; # endif section -> ca_file = NULL ; break ; case CMD_SET_COPY : section -> ca_file = str_dup_detached ( new_service_options . ca_file ) ; break ; case CMD_FREE : str_free ( section -> ca_file ) ; break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , "CAfile" ) ) break ; str_free ( section -> ca_file ) ; if ( arg [ 0 ] ) section -> ca_file = str_dup_detached ( arg ) ; else section -> ca_file = NULL ; return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : # if 0 s_log ( LOG_NOTICE , "%-22s<S2SV_blank>=<S2SV_blank>%s" , "CAfile" , section -> ca_file ? section -> ca_file : "(none)" ) ; # endif break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , "%-22s<S2SV_blank>=<S2SV_blank>CA<S2SV_blank>certificate<S2SV_blank>file<S2SV_blank>for<S2SV_blank>\'verify\'<S2SV_blank>option" , "CAfile" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : section -> cert = NULL ; break ; case CMD_SET_COPY : section -> cert = str_dup_detached ( new_service_options . cert ) ; break ; case CMD_FREE : str_free ( section -> cert ) ; break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , "cert" ) ) break ; str_free ( section -> cert ) ; section -> cert = str_dup_detached ( arg ) ; return NULL ; case CMD_INITIALIZE : # ifndef OPENSSL_NO_PSK if ( section -> psk_keys ) break ; # endif # ifndef OPENSSL_NO_ENGINE if ( section -> engine ) break ; # endif if ( ! section -> option . client && ! section -> cert ) return "TLS<S2SV_blank>server<S2SV_blank>needs<S2SV_blank>a<S2SV_blank>certificate" ; break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , "%-22s<S2SV_blank>=<S2SV_blank>certificate<S2SV_blank>chain" , "cert" ) ; break ; } # if OPENSSL_VERSION_NUMBER >= 0x10002000L switch ( cmd ) { case CMD_SET_DEFAULTS : section -> check_email = NULL ; break ; case CMD_SET_COPY : name_list_dup ( & section -> check_email , new_service_options . check_email ) ; break ; case CMD_FREE : name_list_free ( section -> check_email ) ; break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , "checkEmail" ) ) break ; name_list_append ( & section -> check_email , arg ) ; return NULL ; case CMD_INITIALIZE : if ( section -> check_email && ! section -> option . verify_chain && ! section -> option . verify_peer ) return "Either<S2SV_blank>\\"verifyChain\\"<S2SV_blank>or<S2SV_blank>\\"verifyPeer\\"<S2SV_blank>has<S2SV_blank>to<S2SV_blank>be<S2SV_blank>enabled" ; break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , "%-22s<S2SV_blank>=<S2SV_blank>peer<S2SV_blank>certificate<S2SV_blank>email<S2SV_blank>address" , "checkEmail" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : section -> check_host = NULL ; break ; case CMD_SET_COPY : name_list_dup ( & section -> check_host , new_service_options . check_host ) ; break ; case CMD_FREE : name_list_free ( section -> check_host ) ; break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , "checkHost" ) ) break ; name_list_append ( & section -> check_host , arg ) ; return NULL ; case CMD_INITIALIZE : if ( section -> check_host && ! section -> option . verify_chain && ! section -> option . verify_peer ) return "Either<S2SV_blank>\\"verifyChain\\"<S2SV_blank>or<S2SV_blank>\\"verifyPeer\\"<S2SV_blank>has<S2SV_blank>to<S2SV_blank>be<S2SV_blank>enabled" ; break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , "%-22s<S2SV_blank>=<S2SV_blank>peer<S2SV_blank>certificate<S2SV_blank>host<S2SV_blank>name<S2SV_blank>pattern" , "checkHost" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : section -> check_ip = NULL ; break ; case CMD_SET_COPY : name_list_dup ( & section -> check_ip , new_service_options . check_ip ) ; break ; case CMD_FREE : name_list_free ( section -> check_ip ) ; break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , "checkIP" ) ) break ; name_list_append ( & section -> check_ip , arg ) ; return NULL ; case CMD_INITIALIZE : if ( section -> check_ip && ! section -> option . verify_chain && ! section -> option . verify_peer ) return "Either<S2SV_blank>\\"verifyChain\\"<S2SV_blank>or<S2SV_blank>\\"verifyPeer\\"<S2SV_blank>has<S2SV_blank>to<S2SV_blank>be<S2SV_blank>enabled" ; break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , "%-22s<S2SV_blank>=<S2SV_blank>peer<S2SV_blank>certificate<S2SV_blank>IP<S2SV_blank>address" , "checkIP" ) ; break ; } # endif switch ( cmd ) { case CMD_SET_DEFAULTS : section -> cipher_list = NULL ; break ; case CMD_SET_COPY : section -> cipher_list = str_dup_detached ( new_service_options . cipher_list ) ; break ; case CMD_FREE : str_free ( section -> cipher_list ) ; break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , "ciphers" ) ) break ; str_free ( section -> cipher_list ) ; section -> cipher_list = str_dup_detached ( arg ) ; return NULL ; case CMD_INITIALIZE : if ( ! section -> cipher_list ) { # ifdef USE_FIPS if ( new_global_options . option . fips ) section -> cipher_list = str_dup_detached ( "FIPS" ) ; else # endif section -> cipher_list = str_dup_detached ( stunnel_cipher_list ) ; } break ; case CMD_PRINT_DEFAULTS : # ifdef USE_FIPS s_log ( LOG_NOTICE , "%-22s<S2SV_blank>=<S2SV_blank>%s<S2SV_blank>%s" , "ciphers" , "FIPS" , "(with<S2SV_blank>\\"fips<S2SV_blank>=<S2SV_blank>yes\\")" ) ; s_log ( LOG_NOTICE , "%-22s<S2SV_blank>=<S2SV_blank>%s<S2SV_blank>%s" , "ciphers" , stunnel_cipher_list , "(with<S2SV_blank>\\"fips<S2SV_blank>=<S2SV_blank>no\\")" ) ; # else s_log ( LOG_NOTICE , "%-22s<S2SV_blank>=<S2SV_blank>%s" , "ciphers" , stunnel_cipher_list ) ; # endif break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , "%-22s<S2SV_blank>=<S2SV_blank>permitted<S2SV_blank>ciphers<S2SV_blank>for<S2SV_blank>TLS<S2SV_blank>1.2<S2SV_blank>or<S2SV_blank>older" , "ciphers" ) ; break ; } # ifndef OPENSSL_NO_TLS1_3 switch ( cmd ) { case CMD_SET_DEFAULTS : section -> ciphersuites = NULL ; break ; case CMD_SET_COPY : section -> ciphersuites = str_dup_detached ( new_service_options . ciphersuites ) ; break ; case CMD_FREE : str_free ( section -> ciphersuites ) ; break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , "ciphersuites" ) ) break ; str_free ( section -> ciphersuites ) ; section -> ciphersuites = str_dup_detached ( arg ) ; return NULL ; case CMD_INITIALIZE : if ( ! section -> ciphersuites ) { section -> ciphersuites = str_dup_detached ( stunnel_ciphersuites ) ; } break ; case CMD_PRINT_DEFAULTS : s_log ( LOG_NOTICE , "%-22s<S2SV_blank>=<S2SV_blank>%s<S2SV_blank>%s" , "ciphersuites" , stunnel_ciphersuites , "(with<S2SV_blank>TLSv1.3)" ) ; break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , "%-22s<S2SV_blank>=<S2SV_blank>permitted<S2SV_blank>ciphersuites<S2SV_blank>for<S2SV_blank>TLS<S2SV_blank>1.3" , "ciphersuites" ) ; break ; } # endif switch ( cmd ) { case CMD_SET_DEFAULTS : section -> option . client = 0 ; break ; case CMD_SET_COPY : section -> option . client = new_service_options . option . client ; break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , "client" ) ) break ; if ( ! strcasecmp ( arg , "yes" ) ) section -> option . client = 1 ; else if ( ! strcasecmp ( arg , "no" ) ) section -> option . client = 0 ; else return "The<S2SV_blank>argument<S2SV_blank>needs<S2SV_blank>to<S2SV_blank>be<S2SV_blank>either<S2SV_blank>\'yes\'<S2SV_blank>or<S2SV_blank>\'no\'" ; return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , "%-22s<S2SV_blank>=<S2SV_blank>yes|no<S2SV_blank>client<S2SV_blank>mode<S2SV_blank>(remote<S2SV_blank>service<S2SV_blank>uses<S2SV_blank>TLS)" , "client" ) ; break ; } # if OPENSSL_VERSION_NUMBER >= 0x10002000L switch ( cmd ) { case CMD_SET_DEFAULTS : section -> config = NULL ; break ; case CMD_SET_COPY : name_list_dup ( & section -> config , new_service_options . config ) ; break ; case CMD_FREE : name_list_free ( section -> config ) ; break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , "config" ) ) break ; name_list_append ( & section -> config , arg ) ; return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , "%-22s<S2SV_blank>=<S2SV_blank>command[:parameter]<S2SV_blank>to<S2SV_blank>execute" , "config" ) ; break ; } # endif switch ( cmd ) { case CMD_SET_DEFAULTS : addrlist_clear ( & section -> connect_addr , 0 ) ; section -> connect_session = NULL ; break ; case CMD_SET_COPY : addrlist_clear ( & section -> connect_addr , 0 ) ; section -> connect_session = NULL ; name_list_dup ( & section -> connect_addr . names , new_service_options . connect_addr . names ) ; break ; case CMD_FREE : name_list_free ( section -> connect_addr . names ) ; str_free ( section -> connect_addr . addr ) ; str_free ( section -> connect_session ) ; break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , "connect" ) ) break ; name_list_append ( & section -> connect_addr . names , arg ) ; return NULL ; case CMD_INITIALIZE : if ( section -> connect_addr . names ) { if ( ! section -> option . delayed_lookup && ! addrlist_resolve ( & section -> connect_addr ) ) { s_log ( LOG_INFO , "Cannot<S2SV_blank>resolve<S2SV_blank>connect<S2SV_blank>target<S2SV_blank>-<S2SV_blank>delaying<S2SV_blank>DNS<S2SV_blank>lookup" ) ; section -> connect_addr . num = 0 ; section -> redirect_addr . num = 0 ; section -> option . delayed_lookup = 1 ; } if ( section -> option . client ) section -> connect_session = str_alloc_detached ( section -> connect_addr . num * sizeof ( SSL_SESSION * ) ) ; ++ endpoints ; } break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , "%-22s<S2SV_blank>=<S2SV_blank>[host:]port<S2SV_blank>to<S2SV_blank>connect" , "connect" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : section -> crl_dir = NULL ; break ; case CMD_SET_COPY : section -> crl_dir = str_dup_detached ( new_service_options . crl_dir ) ; break ; case CMD_FREE : str_free ( section -> crl_dir ) ; break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , "CRLpath" ) ) break ; str_free ( section -> crl_dir ) ; if ( arg [ 0 ] ) section -> crl_dir = str_dup_detached ( arg ) ; else section -> crl_dir = NULL ; return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , "%-22s<S2SV_blank>=<S2SV_blank>CRL<S2SV_blank>directory" , "CRLpath" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : section -> crl_file = NULL ; break ; case CMD_SET_COPY : section -> crl_file = str_dup_detached ( new_service_options . crl_file ) ; break ; case CMD_FREE : str_free ( section -> crl_file ) ; break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , "CRLfile" ) ) break ; str_free ( section -> crl_file ) ; if ( arg [ 0 ] ) section -> crl_file = str_dup_detached ( arg ) ; else section -> crl_file = NULL ; return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , "%-22s<S2SV_blank>=<S2SV_blank>CRL<S2SV_blank>file" , "CRLfile" ) ; break ; } # ifndef OPENSSL_NO_ECDH switch ( cmd ) { case CMD_SET_DEFAULTS : section -> curves = str_dup_detached ( DEFAULT_CURVES ) ; break ; case CMD_SET_COPY : section -> curves = str_dup_detached ( new_service_options . curves ) ; break ; case CMD_FREE : str_free ( section -> curves ) ; break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , "curves" ) && strcasecmp ( opt , "curve" ) ) break ; str_free ( section -> curves ) ; section -> curves = str_dup_detached ( arg ) ; return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : s_log ( LOG_NOTICE , "%-22s<S2SV_blank>=<S2SV_blank>%s" , "curves" , DEFAULT_CURVES ) ; break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , "%-22s<S2SV_blank>=<S2SV_blank>ECDH<S2SV_blank>curve<S2SV_blank>names" , "curves" ) ; break ; } # endif switch ( cmd ) { case CMD_SET_DEFAULTS : section -> log_level = LOG_NOTICE ; # if ! defined ( USE_WIN32 ) && ! defined ( __vms ) new_global_options . log_facility = LOG_DAEMON ; # endif break ; case CMD_SET_COPY : section -> log_level = new_service_options . log_level ; break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , "debug" ) ) break ; return parse_debug_level ( arg , section ) ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : # if ! defined ( USE_WIN32 ) && ! defined ( __vms ) s_log ( LOG_NOTICE , "%-22s<S2SV_blank>=<S2SV_blank>%s" , "debug" , "daemon.notice" ) ; # else s_log ( LOG_NOTICE , "%-22s<S2SV_blank>=<S2SV_blank>%s" , "debug" , "notice" ) ; # endif break ; case CMD_PRINT_HELP : # if ! defined ( USE_WIN32 ) && ! defined ( __vms ) s_log ( LOG_NOTICE , "%-22s<S2SV_blank>=<S2SV_blank>[facility].level<S2SV_blank>(e.g.<S2SV_blank>daemon.info)" , "debug" ) ; # else s_log ( LOG_NOTICE , "%-22s<S2SV_blank>=<S2SV_blank>level<S2SV_blank>(e.g.<S2SV_blank>info)" , "debug" ) ; # endif break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : section -> option . delayed_lookup = 0 ; break ; case CMD_SET_COPY : section -> option . delayed_lookup = new_service_options . option . delayed_lookup ; break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , "delay" ) ) break ; if ( ! strcasecmp ( arg , "yes" ) ) section -> option . delayed_lookup = 1 ; else if ( ! strcasecmp ( arg , "no" ) ) section -> option . delayed_lookup = 0 ; else return "The<S2SV_blank>argument<S2SV_blank>needs<S2SV_blank>to<S2SV_blank>be<S2SV_blank>either<S2SV_blank>\'yes\'<S2SV_blank>or<S2SV_blank>\'no\'" ; return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , "%-22s<S2SV_blank>=<S2SV_blank>yes|no<S2SV_blank>delay<S2SV_blank>DNS<S2SV_blank>lookup<S2SV_blank>for<S2SV_blank>\'connect\'<S2SV_blank>option" , "delay" ) ; break ; } # ifndef OPENSSL_NO_ENGINE switch ( cmd ) { case CMD_SET_DEFAULTS : break ; case CMD_SET_COPY : section -> engine = new_service_options . engine ; break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , "engineId" ) ) break ; section -> engine = engine_get_by_id ( arg ) ; if ( ! section -> engine ) return "Engine<S2SV_blank>ID<S2SV_blank>not<S2SV_blank>found" ; return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , "%-22s<S2SV_blank>=<S2SV_blank>ID<S2SV_blank>of<S2SV_blank>engine<S2SV_blank>to<S2SV_blank>read<S2SV_blank>the<S2SV_blank>key<S2SV_blank>from" , "engineId" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : break ; case CMD_SET_COPY : section -> engine = new_service_options . engine ; break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , "engineNum" ) ) break ; { char * tmp_str ; int tmp_int = ( int ) strtol ( arg , & tmp_str , 10 ) ; if ( tmp_str == arg || * tmp_str ) return "Illegal<S2SV_blank>engine<S2SV_blank>number" ; section -> engine = engine_get_by_num ( tmp_int - 1 ) ; } if ( ! section -> engine ) return "Illegal<S2SV_blank>engine<S2SV_blank>number" ; return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , "%-22s<S2SV_blank>=<S2SV_blank>number<S2SV_blank>of<S2SV_blank>engine<S2SV_blank>to<S2SV_blank>read<S2SV_blank>the<S2SV_blank>key<S2SV_blank>from" , "engineNum" ) ; break ; } # endif switch ( cmd ) { case CMD_SET_DEFAULTS : section -> exec_name = NULL ; break ; case CMD_SET_COPY : section -> exec_name = str_dup_detached ( new_service_options . exec_name ) ; break ; case CMD_FREE : str_free ( section -> exec_name ) ; break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , "exec" ) ) break ; str_free ( section -> exec_name ) ; section -> exec_name = str_dup_detached ( arg ) ; # ifdef USE_WIN32 section -> exec_args = str_dup_detached ( arg ) ; # else if ( ! section -> exec_args ) { section -> exec_args = str_alloc_detached ( 2 * sizeof ( char * ) ) ; section -> exec_args [ 0 ] = str_dup_detached ( section -> exec_name ) ; section -> exec_args [ 1 ] = NULL ; } # endif return NULL ; case CMD_INITIALIZE : if ( section -> exec_name ) ++ endpoints ; break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , "%-22s<S2SV_blank>=<S2SV_blank>file<S2SV_blank>execute<S2SV_blank>local<S2SV_blank>inetd-type<S2SV_blank>program" , "exec" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : section -> exec_args = NULL ; break ; case CMD_SET_COPY : # ifdef USE_WIN32 section -> exec_args = str_dup_detached ( new_service_options . exec_args ) ; # else section -> exec_args = arg_dup ( new_service_options . exec_args ) ; # endif break ; case CMD_FREE : # ifdef USE_WIN32 str_free ( section -> exec_args ) ; # else arg_free ( section -> exec_args ) ; # endif break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , "execArgs" ) ) break ; # ifdef USE_WIN32 str_free ( section -> exec_args ) ; section -> exec_args = str_dup_detached ( arg ) ; # else arg_free ( section -> exec_args ) ; section -> exec_args = arg_alloc ( arg ) ; # endif return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , "%-22s<S2SV_blank>=<S2SV_blank>arguments<S2SV_blank>for<S2SV_blank>\'exec\'<S2SV_blank>(including<S2SV_blank>$0)" , "execArgs" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : section -> failover = FAILOVER_PRIO ; section -> rr = 0 ; break ; case CMD_SET_COPY : section -> failover = new_service_options . failover ; section -> rr = new_service_options . rr ; break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , "failover" ) ) break ; if ( ! strcasecmp ( arg , "rr" ) ) section -> failover = FAILOVER_RR ; else if ( ! strcasecmp ( arg , "prio" ) ) section -> failover = FAILOVER_PRIO ; else return "The<S2SV_blank>argument<S2SV_blank>needs<S2SV_blank>to<S2SV_blank>be<S2SV_blank>either<S2SV_blank>\'rr\'<S2SV_blank>or<S2SV_blank>\'prio\'" ; return NULL ; case CMD_INITIALIZE : if ( section -> option . delayed_lookup ) section -> failover = FAILOVER_PRIO ; break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , "%-22s<S2SV_blank>=<S2SV_blank>rr|prio<S2SV_blank>failover<S2SV_blank>strategy" , "failover" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : section -> username = NULL ; break ; case CMD_SET_COPY : section -> username = str_dup_detached ( new_service_options . username ) ; break ; case CMD_FREE : str_free ( section -> username ) ; break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , "ident" ) ) break ; str_free ( section -> username ) ; section -> username = str_dup_detached ( arg ) ; return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , "%-22s<S2SV_blank>=<S2SV_blank>username<S2SV_blank>for<S2SV_blank>IDENT<S2SV_blank>(RFC<S2SV_blank>1413)<S2SV_blank>checking" , "ident" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : break ; case CMD_SET_COPY : break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , "include" ) ) break ; return include_config ( arg , section_ptr ) ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , "%-22s<S2SV_blank>=<S2SV_blank>directory<S2SV_blank>with<S2SV_blank>configuration<S2SV_blank>file<S2SV_blank>snippets" , "include" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : section -> key = NULL ; break ; case CMD_SET_COPY : section -> key = str_dup_detached ( new_service_options . key ) ; break ; case CMD_FREE : str_free ( section -> key ) ; break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , "key" ) ) break ; str_free ( section -> key ) ; section -> key = str_dup_detached ( arg ) ; return NULL ; case CMD_INITIALIZE : if ( section -> cert && ! section -> key ) section -> key = str_dup_detached ( section -> cert ) ; break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , "%-22s<S2SV_blank>=<S2SV_blank>certificate<S2SV_blank>private<S2SV_blank>key" , "key" ) ; break ; } # ifdef USE_LIBWRAP switch ( cmd ) { case CMD_SET_DEFAULTS : section -> option . libwrap = 0 ; break ; case CMD_SET_COPY : section -> option . libwrap = new_service_options . option . libwrap ; break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , "libwrap" ) ) break ; if ( ! strcasecmp ( arg , "yes" ) ) section -> option . libwrap = 1 ; else if ( ! strcasecmp ( arg , "no" ) ) section -> option . libwrap = 0 ; else return "The<S2SV_blank>argument<S2SV_blank>needs<S2SV_blank>to<S2SV_blank>be<S2SV_blank>either<S2SV_blank>\'yes\'<S2SV_blank>or<S2SV_blank>\'no\'" ; return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , "%-22s<S2SV_blank>=<S2SV_blank>yes|no<S2SV_blank>use<S2SV_blank>/etc/hosts.allow<S2SV_blank>and<S2SV_blank>/etc/hosts.deny" , "libwrap" ) ; break ; } # endif switch ( cmd ) { case CMD_SET_DEFAULTS : section -> option . local = 0 ; break ; case CMD_SET_COPY : section -> option . local = new_service_options . option . local ; memcpy ( & section -> source_addr , & new_service_options . source_addr , sizeof ( SOCKADDR_UNION ) ) ; break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , "local" ) ) break ; if ( ! hostport2addr ( & section -> source_addr , arg , "0" , 1 ) ) return "Failed<S2SV_blank>to<S2SV_blank>resolve<S2SV_blank>local<S2SV_blank>address" ; section -> option . local = 1 ; return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , "%-22s<S2SV_blank>=<S2SV_blank>IP<S2SV_blank>address<S2SV_blank>to<S2SV_blank>be<S2SV_blank>used<S2SV_blank>as<S2SV_blank>source<S2SV_blank>for<S2SV_blank>remote" "<S2SV_blank>connections" , "local" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : section -> log_id = LOG_ID_SEQUENTIAL ; break ; case CMD_SET_COPY : section -> log_id = new_service_options . log_id ; break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , "logId" ) ) break ; if ( ! strcasecmp ( arg , "sequential" ) ) section -> log_id = LOG_ID_SEQUENTIAL ; else if ( ! strcasecmp ( arg , "unique" ) ) section -> log_id = LOG_ID_UNIQUE ; else if ( ! strcasecmp ( arg , "thread" ) ) section -> log_id = LOG_ID_THREAD ; else if ( ! strcasecmp ( arg , "process" ) ) section -> log_id = LOG_ID_PROCESS ; else return "Invalid<S2SV_blank>connection<S2SV_blank>identifier<S2SV_blank>type" ; return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : s_log ( LOG_NOTICE , "%-22s<S2SV_blank>=<S2SV_blank>%s" , "logId" , "sequential" ) ; break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , "%-22s<S2SV_blank>=<S2SV_blank>connection<S2SV_blank>identifier<S2SV_blank>type" , "logId" ) ; break ; } # ifndef OPENSSL_NO_OCSP switch ( cmd ) { case CMD_SET_DEFAULTS : section -> ocsp_url = NULL ; break ; case CMD_SET_COPY : section -> ocsp_url = str_dup_detached ( new_service_options . ocsp_url ) ; break ; case CMD_FREE : str_free ( section -> ocsp_url ) ; break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , "ocsp" ) ) break ; str_free ( section -> ocsp_url ) ; section -> ocsp_url = str_dup_detached ( arg ) ; return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , "%-22s<S2SV_blank>=<S2SV_blank>OCSP<S2SV_blank>responder<S2SV_blank>URL" , "OCSP" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : section -> option . aia = 0 ; break ; case CMD_SET_COPY : section -> option . aia = new_service_options . option . aia ; break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , "OCSPaia" ) ) break ; if ( ! strcasecmp ( arg , "yes" ) ) section -> option . aia = 1 ; else if ( ! strcasecmp ( arg , "no" ) ) section -> option . aia = 0 ; else return "The<S2SV_blank>argument<S2SV_blank>needs<S2SV_blank>to<S2SV_blank>be<S2SV_blank>either<S2SV_blank>\'yes\'<S2SV_blank>or<S2SV_blank>\'no\'" ; return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , "%-22s<S2SV_blank>=<S2SV_blank>yes|no<S2SV_blank>check<S2SV_blank>the<S2SV_blank>AIA<S2SV_blank>responders<S2SV_blank>from<S2SV_blank>certificates" , "OCSPaia" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : section -> ocsp_flags = 0 ; break ; case CMD_SET_COPY : section -> ocsp_flags = new_service_options . ocsp_flags ; break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , "OCSPflag" ) ) break ; { unsigned long tmp_ulong = parse_ocsp_flag ( arg ) ; if ( ! tmp_ulong ) return "Illegal<S2SV_blank>OCSP<S2SV_blank>flag" ; section -> ocsp_flags |= tmp_ulong ; } return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , "%-22s<S2SV_blank>=<S2SV_blank>OCSP<S2SV_blank>responder<S2SV_blank>flags" , "OCSPflag" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : section -> option . nonce = 0 ; break ; case CMD_SET_COPY : section -> option . nonce = new_service_options . option . nonce ; break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , "OCSPnonce" ) ) break ; if ( ! strcasecmp ( arg , "yes" ) ) section -> option . nonce = 1 ; else if ( ! strcasecmp ( arg , "no" ) ) section -> option . nonce = 0 ; else return "The<S2SV_blank>argument<S2SV_blank>needs<S2SV_blank>to<S2SV_blank>be<S2SV_blank>either<S2SV_blank>\'yes\'<S2SV_blank>or<S2SV_blank>\'no\'" ; return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , "%-22s<S2SV_blank>=<S2SV_blank>yes|no<S2SV_blank>send<S2SV_blank>and<S2SV_blank>verify<S2SV_blank>the<S2SV_blank>OCSP<S2SV_blank>nonce<S2SV_blank>extension" , "OCSPnonce" ) ; break ; } # endif switch ( cmd ) { case CMD_SET_DEFAULTS : section -> ssl_options_set = 0 ; # if OPENSSL_VERSION_NUMBER >= 0x009080dfL section -> ssl_options_clear = 0 ; # endif break ; case CMD_SET_COPY : section -> ssl_options_set = new_service_options . ssl_options_set ; # if OPENSSL_VERSION_NUMBER >= 0x009080dfL section -> ssl_options_clear = new_service_options . ssl_options_clear ; # endif break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , "options" ) ) break ; # if OPENSSL_VERSION_NUMBER >= 0x009080dfL if ( * arg == '-' ) { long unsigned tmp = parse_ssl_option ( arg + 1 ) ; if ( tmp == INVALID_SSL_OPTION ) return "Illegal<S2SV_blank>TLS<S2SV_blank>option" ; section -> ssl_options_clear |= tmp ; return NULL ; } # endif { long unsigned tmp = parse_ssl_option ( arg ) ; if ( tmp == INVALID_SSL_OPTION ) return "Illegal<S2SV_blank>TLS<S2SV_blank>option" ; section -> ssl_options_set |= tmp ; } return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : s_log ( LOG_NOTICE , "%-22s<S2SV_blank>=<S2SV_blank>%s" , "options" , "NO_SSLv2" ) ; s_log ( LOG_NOTICE , "%-22s<S2SV_blank>=<S2SV_blank>%s" , "options" , "NO_SSLv3" ) ; break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , "%-22s<S2SV_blank>=<S2SV_blank>TLS<S2SV_blank>option<S2SV_blank>to<S2SV_blank>set/reset" , "options" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : section -> protocol = NULL ; break ; case CMD_SET_COPY : section -> protocol = str_dup_detached ( new_service_options . protocol ) ; break ; case CMD_FREE : str_free ( section -> protocol ) ; break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , "protocol" ) ) break ; str_free ( section -> protocol ) ; section -> protocol = str_dup_detached ( arg ) ; return NULL ; case CMD_INITIALIZE : { char * tmp_str = protocol ( NULL , section , PROTOCOL_CHECK ) ; if ( tmp_str ) return tmp_str ; } endpoints += section -> option . protocol_endpoint ; break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , "%-22s<S2SV_blank>=<S2SV_blank>protocol<S2SV_blank>to<S2SV_blank>negotiate<S2SV_blank>before<S2SV_blank>TLS<S2SV_blank>initialization" , "protocol" ) ; s_log ( LOG_NOTICE , "%25scurrently<S2SV_blank>supported:<S2SV_blank>cifs,<S2SV_blank>connect,<S2SV_blank>imap," , "" ) ; s_log ( LOG_NOTICE , "%25s<S2SV_blank><S2SV_blank><S2SV_blank><S2SV_blank>nntp,<S2SV_blank>pgsql,<S2SV_blank>pop3,<S2SV_blank>proxy,<S2SV_blank>smtp,<S2SV_blank>socks" , "" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : section -> protocol_authentication = str_dup_detached ( "basic" ) ; break ; case CMD_SET_COPY : section -> protocol_authentication = str_dup_detached ( new_service_options . protocol_authentication ) ; break ; case CMD_FREE : str_free ( section -> protocol_authentication ) ; break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , "protocolAuthentication" ) ) break ; str_free ( section -> protocol_authentication ) ; section -> protocol_authentication = str_dup_detached ( arg ) ; return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , "%-22s<S2SV_blank>=<S2SV_blank>authentication<S2SV_blank>type<S2SV_blank>for<S2SV_blank>protocol<S2SV_blank>negotiations" , "protocolAuthentication" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : section -> protocol_domain = NULL ; break ; case CMD_SET_COPY : section -> protocol_domain = str_dup_detached ( new_service_options . protocol_domain ) ; break ; case CMD_FREE : str_free ( section -> protocol_domain ) ; break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , "protocolDomain" ) ) break ; str_free ( section -> protocol_domain ) ; section -> protocol_domain = str_dup_detached ( arg ) ; return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , "%-22s<S2SV_blank>=<S2SV_blank>domain<S2SV_blank>for<S2SV_blank>protocol<S2SV_blank>negotiations" , "protocolDomain" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : section -> protocol_host = NULL ; break ; case CMD_SET_COPY : section -> protocol_host = str_dup_detached ( new_service_options . protocol_host ) ; break ; case CMD_FREE : str_free ( section -> protocol_host ) ; break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , "protocolHost" ) ) break ; str_free ( section -> protocol_host ) ; section -> protocol_host = str_dup_detached ( arg ) ; return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , "%-22s<S2SV_blank>=<S2SV_blank>host:port<S2SV_blank>for<S2SV_blank>protocol<S2SV_blank>negotiations" , "protocolHost" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : section -> protocol_password = NULL ; break ; case CMD_SET_COPY : section -> protocol_password = str_dup_detached ( new_service_options . protocol_password ) ; break ; case CMD_FREE : str_free ( section -> protocol_password ) ; break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , "protocolPassword" ) ) break ; str_free ( section -> protocol_password ) ; section -> protocol_password = str_dup_detached ( arg ) ; return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , "%-22s<S2SV_blank>=<S2SV_blank>password<S2SV_blank>for<S2SV_blank>protocol<S2SV_blank>negotiations" , "protocolPassword" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : section -> protocol_username = NULL ; break ; case CMD_SET_COPY : section -> protocol_username = str_dup_detached ( new_service_options . protocol_username ) ; break ; case CMD_FREE : str_free ( section -> protocol_username ) ; break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , "protocolUsername" ) ) break ; str_free ( section -> protocol_username ) ; section -> protocol_username = str_dup_detached ( arg ) ; return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , "%-22s<S2SV_blank>=<S2SV_blank>username<S2SV_blank>for<S2SV_blank>protocol<S2SV_blank>negotiations" , "protocolUsername" ) ; break ; } # ifndef OPENSSL_NO_PSK switch ( cmd ) { case CMD_SET_DEFAULTS : section -> psk_identity = NULL ; section -> psk_selected = NULL ; section -> psk_sorted . val = NULL ; section -> psk_sorted . num = 0 ; break ; case CMD_SET_COPY : section -> psk_identity = str_dup_detached ( new_service_options . psk_identity ) ; break ; case CMD_FREE : str_free ( section -> psk_identity ) ; str_free ( section -> psk_sorted . val ) ; break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , "PSKidentity" ) ) break ; str_free ( section -> psk_identity ) ; section -> psk_identity = str_dup_detached ( arg ) ; return NULL ; case CMD_INITIALIZE : if ( ! section -> psk_keys ) break ; psk_sort ( & section -> psk_sorted , section -> psk_keys ) ; if ( section -> option . client ) { if ( section -> psk_identity ) { section -> psk_selected = psk_find ( & section -> psk_sorted , section -> psk_identity ) ; if ( ! section -> psk_selected ) return "No<S2SV_blank>key<S2SV_blank>found<S2SV_blank>for<S2SV_blank>the<S2SV_blank>specified<S2SV_blank>PSK<S2SV_blank>identity" ; } else { section -> psk_selected = section -> psk_keys ; } } else { if ( section -> psk_identity ) s_log ( LOG_NOTICE , "PSK<S2SV_blank>identity<S2SV_blank>is<S2SV_blank>ignored<S2SV_blank>in<S2SV_blank>the<S2SV_blank>server<S2SV_blank>mode" ) ; } break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , "%-22s<S2SV_blank>=<S2SV_blank>identity<S2SV_blank>for<S2SV_blank>PSK<S2SV_blank>authentication" , "PSKidentity" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : section -> psk_keys = NULL ; break ; case CMD_SET_COPY : section -> psk_keys = psk_dup ( new_service_options . psk_keys ) ; break ; case CMD_FREE : psk_free ( section -> psk_keys ) ; break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , "PSKsecrets" ) ) break ; section -> psk_keys = psk_read ( arg ) ; if ( ! section -> psk_keys ) return "Failed<S2SV_blank>to<S2SV_blank>read<S2SV_blank>PSK<S2SV_blank>secrets" ; return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , "%-22s<S2SV_blank>=<S2SV_blank>secrets<S2SV_blank>for<S2SV_blank>PSK<S2SV_blank>authentication" , "PSKsecrets" ) ; break ; } # endif # ifndef USE_WIN32 switch ( cmd ) { case CMD_SET_DEFAULTS : section -> option . pty = 0 ; break ; case CMD_SET_COPY : section -> option . pty = new_service_options . option . pty ; break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , "pty" ) ) break ; if ( ! strcasecmp ( arg , "yes" ) ) section -> option . pty = 1 ; else if ( ! strcasecmp ( arg , "no" ) ) section -> option . pty = 0 ; else return "The<S2SV_blank>argument<S2SV_blank>needs<S2SV_blank>to<S2SV_blank>be<S2SV_blank>either<S2SV_blank>\'yes\'<S2SV_blank>or<S2SV_blank>\'no\'" ; return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , "%-22s<S2SV_blank>=<S2SV_blank>yes|no<S2SV_blank>allocate<S2SV_blank>pseudo<S2SV_blank>terminal<S2SV_blank>for<S2SV_blank>\'exec\'<S2SV_blank>option" , "pty" ) ; break ; } # endif switch ( cmd ) { case CMD_SET_DEFAULTS : addrlist_clear ( & section -> redirect_addr , 0 ) ; break ; case CMD_SET_COPY : addrlist_clear ( & section -> redirect_addr , 0 ) ; name_list_dup ( & section -> redirect_addr . names , new_service_options . redirect_addr . names ) ; break ; case CMD_FREE : name_list_free ( section -> redirect_addr . names ) ; str_free ( section -> redirect_addr . addr ) ; break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , "redirect" ) ) break ; name_list_append ( & section -> redirect_addr . names , arg ) ; return NULL ; case CMD_INITIALIZE : if ( section -> redirect_addr . names ) { if ( section -> option . client ) return "\\"redirect\\"<S2SV_blank>is<S2SV_blank>unsupported<S2SV_blank>in<S2SV_blank>client<S2SV_blank>sections" ; if ( section -> option . connect_before_ssl ) return "\\"redirect\\"<S2SV_blank>is<S2SV_blank>incompatible<S2SV_blank>with<S2SV_blank>the<S2SV_blank>specified<S2SV_blank>protocol<S2SV_blank>negotiation" ; if ( ! section -> option . delayed_lookup && ! addrlist_resolve ( & section -> redirect_addr ) ) { s_log ( LOG_INFO , "Cannot<S2SV_blank>resolve<S2SV_blank>redirect<S2SV_blank>target<S2SV_blank>-<S2SV_blank>delaying<S2SV_blank>DNS<S2SV_blank>lookup" ) ; section -> connect_addr . num = 0 ; section -> redirect_addr . num = 0 ; section -> option . delayed_lookup = 1 ; } if ( ! section -> option . verify_chain && ! section -> option . verify_peer ) return "Either<S2SV_blank>\\"verifyChain\\"<S2SV_blank>or<S2SV_blank>\\"verifyPeer\\"<S2SV_blank>has<S2SV_blank>to<S2SV_blank>be<S2SV_blank>enabled<S2SV_blank>for<S2SV_blank>\\"redirect\\"<S2SV_blank>to<S2SV_blank>work" ; } break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , "%-22s<S2SV_blank>=<S2SV_blank>[host:]port<S2SV_blank>to<S2SV_blank>redirect<S2SV_blank>on<S2SV_blank>authentication<S2SV_blank>failures" , "redirect" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : section -> option . renegotiation = 1 ; break ; case CMD_SET_COPY : section -> option . renegotiation = new_service_options . option . renegotiation ; break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , "renegotiation" ) ) break ; if ( ! strcasecmp ( arg , "yes" ) ) section -> option . renegotiation = 1 ; else if ( ! strcasecmp ( arg , "no" ) ) section -> option . renegotiation = 0 ; else return "The<S2SV_blank>argument<S2SV_blank>needs<S2SV_blank>to<S2SV_blank>be<S2SV_blank>either<S2SV_blank>\'yes\'<S2SV_blank>or<S2SV_blank>\'no\'" ; return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , "%-22s<S2SV_blank>=<S2SV_blank>yes|no<S2SV_blank>support<S2SV_blank>renegotiation" , "renegotiation" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : section -> option . require_cert = 0 ; break ; case CMD_SET_COPY : section -> option . require_cert = new_service_options . option . require_cert ; break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , "requireCert" ) ) break ; if ( ! strcasecmp ( arg , "yes" ) ) { section -> option . request_cert = 1 ; section -> option . require_cert = 1 ; } else if ( ! strcasecmp ( arg , "no" ) ) { section -> option . require_cert = 0 ; } else { return "The<S2SV_blank>argument<S2SV_blank>needs<S2SV_blank>to<S2SV_blank>be<S2SV_blank>either<S2SV_blank>\'yes\'<S2SV_blank>or<S2SV_blank>\'no\'" ; } return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , "%-22s<S2SV_blank>=<S2SV_blank>yes|no<S2SV_blank>require<S2SV_blank>client<S2SV_blank>certificate" , "requireCert" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : section -> option . reset = 1 ; break ; case CMD_SET_COPY : section -> option . reset = new_service_options . option . reset ; break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , "reset" ) ) break ; if ( ! strcasecmp ( arg , "yes" ) ) section -> option . reset = 1 ; else if ( ! strcasecmp ( arg , "no" ) ) section -> option . reset = 0 ; else return "The<S2SV_blank>argument<S2SV_blank>needs<S2SV_blank>to<S2SV_blank>be<S2SV_blank>either<S2SV_blank>\'yes\'<S2SV_blank>or<S2SV_blank>\'no\'" ; return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , "%-22s<S2SV_blank>=<S2SV_blank>yes|no<S2SV_blank>send<S2SV_blank>TCP<S2SV_blank>RST<S2SV_blank>on<S2SV_blank>error" , "reset" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : section -> option . retry = 0 ; break ; case CMD_SET_COPY : section -> option . retry = new_service_options . option . retry ; break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , "retry" ) ) break ; if ( ! strcasecmp ( arg , "yes" ) ) section -> option . retry = 1 ; else if ( ! strcasecmp ( arg , "no" ) ) section -> option . retry = 0 ; else return "The<S2SV_blank>argument<S2SV_blank>needs<S2SV_blank>to<S2SV_blank>be<S2SV_blank>either<S2SV_blank>\'yes\'<S2SV_blank>or<S2SV_blank>\'no\'" ; return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , "%-22s<S2SV_blank>=<S2SV_blank>yes|no<S2SV_blank>retry<S2SV_blank>connect+exec<S2SV_blank>section" , "retry" ) ; break ; <S2SV_StartBug> } <S2SV_EndBug> # ifndef USE_WIN32 switch ( cmd ) { case CMD_SET_DEFAULTS : section -> servname = str_dup_detached ( "stunnel" ) ; break ; case CMD_SET_COPY : break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , "service" ) ) break ; str_free ( section -> servname ) ; section -> servname = str_dup_detached ( arg ) ; return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , "%-22s<S2SV_blank>=<S2SV_blank>service<S2SV_blank>name" , "service" ) ; break ; } # endif # ifndef USE_WIN32 switch ( cmd ) { case CMD_SET_DEFAULTS : section -> gid = 0 ; break ; case CMD_SET_COPY : section -> gid = new_service_options . gid ; break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , "setgid" ) ) break ; gr = getgrnam ( arg ) ; if ( gr ) { section -> gid = gr -> gr_gid ; return NULL ; } { char * tmp_str ; section -> gid = ( gid_t ) strtol ( arg , & tmp_str , 10 ) ; if ( tmp_str == arg || * tmp_str ) return "Illegal<S2SV_blank>GID" ; } return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , "%-22s<S2SV_blank>=<S2SV_blank>groupname<S2SV_blank>for<S2SV_blank>setgid()" , "setgid" ) ; break ; } # endif # ifndef USE_WIN32 switch ( cmd ) { case CMD_SET_DEFAULTS : section -> uid = 0 ; break ; case CMD_SET_COPY : section -> uid = new_service_options . uid ; break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , "setuid" ) ) break ; pw = getpwnam ( arg ) ; if ( pw ) { section -> uid = pw -> pw_uid ; return NULL ; } { char * tmp_str ; section -> uid = ( uid_t ) strtol ( arg , & tmp_str , 10 ) ; if ( tmp_str == arg || * tmp_str ) return "Illegal<S2SV_blank>UID" ; } return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , "%-22s<S2SV_blank>=<S2SV_blank>username<S2SV_blank>for<S2SV_blank>setuid()" , "setuid" ) ; break ; } # endif switch ( cmd ) { case CMD_SET_DEFAULTS : section -> session_size = 1000L ; break ; case CMD_SET_COPY : section -> session_size = new_service_options . session_size ; break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , "sessionCacheSize" ) ) break ; { char * tmp_str ; section -> session_size = strtol ( arg , & tmp_str , 10 ) ; if ( tmp_str == arg || * tmp_str ) return "Illegal<S2SV_blank>session<S2SV_blank>cache<S2SV_blank>size" ; } return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : s_log ( LOG_NOTICE , "%-22s<S2SV_blank>=<S2SV_blank>%ld" , "sessionCacheSize" , 1000L ) ; break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , "%-22s<S2SV_blank>=<S2SV_blank>session<S2SV_blank>cache<S2SV_blank>size" , "sessionCacheSize" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : section -> session_timeout = 300L ; break ; case CMD_SET_COPY : section -> session_timeout = new_service_options . session_timeout ; break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , "sessionCacheTimeout" ) && strcasecmp ( opt , "session" ) ) break ; { char * tmp_str ; section -> session_timeout = strtol ( arg , & tmp_str , 10 ) ; if ( tmp_str == arg || * tmp_str ) return "Illegal<S2SV_blank>session<S2SV_blank>cache<S2SV_blank>timeout" ; } return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : s_log ( LOG_NOTICE , "%-22s<S2SV_blank>=<S2SV_blank>%ld<S2SV_blank>seconds" , "sessionCacheTimeout" , 300L ) ; break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , "%-22s<S2SV_blank>=<S2SV_blank>session<S2SV_blank>cache<S2SV_blank>timeout<S2SV_blank>(in<S2SV_blank>seconds)" , "sessionCacheTimeout" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : section -> option . sessiond = 0 ; memset ( & section -> sessiond_addr , 0 , sizeof ( SOCKADDR_UNION ) ) ; section -> sessiond_addr . in . sin_family = AF_INET ; break ; case CMD_SET_COPY : section -> option . sessiond = new_service_options . option . sessiond ; memcpy ( & section -> sessiond_addr , & new_service_options . sessiond_addr , sizeof ( SOCKADDR_UNION ) ) ; break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , "sessiond" ) ) break ; section -> option . sessiond = 1 ; # ifdef SSL_OP_NO_TICKET section -> ssl_options_set |= SSL_OP_NO_TICKET ; # endif if ( ! name2addr ( & section -> sessiond_addr , arg , 0 ) ) return "Failed<S2SV_blank>to<S2SV_blank>resolve<S2SV_blank>sessiond<S2SV_blank>server<S2SV_blank>address" ; return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , "%-22s<S2SV_blank>=<S2SV_blank>[host:]port<S2SV_blank>use<S2SV_blank>sessiond<S2SV_blank>at<S2SV_blank>host:port" , "sessiond" ) ; break ; } # ifndef OPENSSL_NO_TLSEXT switch ( cmd ) { case CMD_SET_DEFAULTS : section -> servername_list_head = NULL ; section -> servername_list_tail = NULL ; break ; case CMD_SET_COPY : section -> sni = str_dup_detached ( new_service_options . sni ) ; break ; case CMD_FREE : str_free ( section -> sni ) ; sni_free ( section ) ; break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , "sni" ) ) break ; str_free ( section -> sni ) ; section -> sni = str_dup_detached ( arg ) ; return NULL ; case CMD_INITIALIZE : { char * tmp_str = sni_init ( section ) ; if ( tmp_str ) return tmp_str ; } if ( ! section -> option . client && section -> sni ) ++ endpoints ; break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , "%-22s<S2SV_blank>=<S2SV_blank>master_service:host_name<S2SV_blank>for<S2SV_blank>an<S2SV_blank>SNI<S2SV_blank>virtual<S2SV_blank>service" , "sni" ) ; break ; } # endif switch ( cmd ) { case CMD_SET_DEFAULTS : section -> sock_opts = socket_options_init ( ) ; break ; case CMD_SET_COPY : section -> sock_opts = socket_options_dup ( new_service_options . sock_opts ) ; break ; case CMD_FREE : socket_options_free ( section -> sock_opts ) ; break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , "socket" ) ) break ; if ( socket_option_parse ( section -> sock_opts , arg ) ) return "Illegal<S2SV_blank>socket<S2SV_blank>option" ; return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , "%-22s<S2SV_blank>=<S2SV_blank>a|l|r:option=value[:value]" , "socket" ) ; s_log ( LOG_NOTICE , "%25sset<S2SV_blank>an<S2SV_blank>option<S2SV_blank>on<S2SV_blank>accept/local/remote<S2SV_blank>socket" , "" ) ; break ; } # if OPENSSL_VERSION_NUMBER >= 0x10100000L switch ( cmd ) { case CMD_SET_DEFAULTS : break ; case CMD_SET_COPY : break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , "sslVersion" ) ) break ; section -> max_proto_version = section -> min_proto_version = str_to_proto_version ( arg ) ; if ( section -> max_proto_version == - 1 ) return "Invalid<S2SV_blank>protocol<S2SV_blank>version" ; return NULL ; case CMD_INITIALIZE : if ( section -> max_proto_version && section -> min_proto_version && section -> max_proto_version < section -> min_proto_version ) return "Invalid<S2SV_blank>protocol<S2SV_blank>version<S2SV_blank>range" ; break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , "%-22s<S2SV_blank>=<S2SV_blank>all" "|SSLv3|TLSv1|TLSv1.1|TLSv1.2" # ifdef TLS1_3_VERSION "|TLSv1.3" # endif "<S2SV_blank>TLS<S2SV_blank>version" , "sslVersion" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : section -> max_proto_version = 0 ; break ; case CMD_SET_COPY : section -> max_proto_version = new_service_options . max_proto_version ; break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , "sslVersionMax" ) ) break ; section -> max_proto_version = str_to_proto_version ( arg ) ; if ( section -> max_proto_version == - 1 ) return "Invalid<S2SV_blank>protocol<S2SV_blank>version" ; return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , "%-22s<S2SV_blank>=<S2SV_blank>all" "|SSLv3|TLSv1|TLSv1.1|TLSv1.2" # ifdef TLS1_3_VERSION "|TLSv1.3" # endif "<S2SV_blank>TLS<S2SV_blank>version" , "sslVersionMax" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : section -> min_proto_version = TLS1_VERSION ; break ; case CMD_SET_COPY : section -> min_proto_version = new_service_options . min_proto_version ; break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , "sslVersionMin" ) ) break ; section -> min_proto_version = str_to_proto_version ( arg ) ; if ( section -> min_proto_version == - 1 ) return "Invalid<S2SV_blank>protocol<S2SV_blank>version" ; return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , "%-22s<S2SV_blank>=<S2SV_blank>all" "|SSLv3|TLSv1|TLSv1.1|TLSv1.2" # ifdef TLS1_3_VERSION "|TLSv1.3" # endif "<S2SV_blank>TLS<S2SV_blank>version" , "sslVersionMin" ) ; break ; } # else switch ( cmd ) { case CMD_SET_DEFAULTS : tls_methods_set ( section , NULL ) ; break ; case CMD_SET_COPY : section -> client_method = new_service_options . client_method ; section -> server_method = new_service_options . server_method ; break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , "sslVersion" ) ) break ; return tls_methods_set ( section , arg ) ; case CMD_INITIALIZE : { char * tmp_str = tls_methods_check ( section ) ; if ( tmp_str ) return tmp_str ; } break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , "%-22s<S2SV_blank>=<S2SV_blank>all" "|SSLv2|SSLv3|TLSv1" # if OPENSSL_VERSION_NUMBER >= 0x10001000L "|TLSv1.1|TLSv1.2" # endif "<S2SV_blank>TLS<S2SV_blank>method" , "sslVersion" ) ; break ; } # endif # ifndef USE_FORK switch ( cmd ) { case CMD_SET_DEFAULTS : section -> stack_size = DEFAULT_STACK_SIZE ; break ; case CMD_SET_COPY : section -> stack_size = new_service_options . stack_size ; break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , "stack" ) ) break ; { char * tmp_str ; section -> stack_size = ( size_t ) strtol ( arg , & tmp_str , 10 ) ; if ( tmp_str == arg || * tmp_str ) return "Illegal<S2SV_blank>thread<S2SV_blank>stack<S2SV_blank>size" ; } return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : s_log ( LOG_NOTICE , "%-22s<S2SV_blank>=<S2SV_blank>%d<S2SV_blank>bytes" , "stack" , DEFAULT_STACK_SIZE ) ; break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , "%-22s<S2SV_blank>=<S2SV_blank>thread<S2SV_blank>stack<S2SV_blank>size<S2SV_blank>(in<S2SV_blank>bytes)" , "stack" ) ; break ; } # endif # if OPENSSL_VERSION_NUMBER >= 0x10000000L switch ( cmd ) { case CMD_SET_DEFAULTS : section -> ticket_key = NULL ; break ; case CMD_SET_COPY : section -> ticket_key = key_dup ( new_service_options . ticket_key ) ; break ; case CMD_FREE : key_free ( section -> ticket_key ) ; break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , "ticketKeySecret" ) ) break ; section -> ticket_key = key_read ( arg , "ticketKeySecret" ) ; if ( ! section -> ticket_key ) return "Failed<S2SV_blank>to<S2SV_blank>read<S2SV_blank>ticketKeySecret" ; return NULL ; case CMD_INITIALIZE : if ( ! section -> ticket_key ) break ; if ( section -> option . client ) { s_log ( LOG_NOTICE , "ticketKeySecret<S2SV_blank>is<S2SV_blank>ignored<S2SV_blank>in<S2SV_blank>the<S2SV_blank>client<S2SV_blank>mode" ) ; break ; } if ( section -> ticket_key && ! section -> ticket_mac ) return "\\"ticketKeySecret\\"<S2SV_blank>and<S2SV_blank>\\"ticketMacSecret\\"<S2SV_blank>must<S2SV_blank>be<S2SV_blank>set<S2SV_blank>together" ; break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , "%-22s<S2SV_blank>=<S2SV_blank>secret<S2SV_blank>key<S2SV_blank>for<S2SV_blank>encryption/decryption<S2SV_blank>TLSv1.3<S2SV_blank>tickets" , "ticketKeySecret" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : section -> ticket_mac = NULL ; break ; case CMD_SET_COPY : section -> ticket_mac = key_dup ( new_service_options . ticket_mac ) ; break ; case CMD_FREE : key_free ( section -> ticket_mac ) ; break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , "ticketMacSecret" ) ) break ; section -> ticket_mac = key_read ( arg , "ticketMacSecret" ) ; if ( ! section -> ticket_mac ) return "Failed<S2SV_blank>to<S2SV_blank>read<S2SV_blank>ticketMacSecret" ; return NULL ; case CMD_INITIALIZE : if ( ! section -> ticket_mac ) break ; if ( section -> option . client ) { s_log ( LOG_NOTICE , "ticketMacSecret<S2SV_blank>is<S2SV_blank>ignored<S2SV_blank>in<S2SV_blank>the<S2SV_blank>client<S2SV_blank>mode" ) ; break ; } if ( section -> ticket_mac && ! section -> ticket_key ) return "\\"ticketKeySecret\\"<S2SV_blank>and<S2SV_blank>\\"ticketMacSecret\\"<S2SV_blank>must<S2SV_blank>be<S2SV_blank>set<S2SV_blank>together" ; break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , "%-22s<S2SV_blank>=<S2SV_blank>key<S2SV_blank>for<S2SV_blank>HMAC<S2SV_blank>operations<S2SV_blank>on<S2SV_blank>TLSv1.3<S2SV_blank>tickets" , "ticketMacSecret" ) ; break ; } # endif switch ( cmd ) { case CMD_SET_DEFAULTS : section -> timeout_busy = 300 ; break ; case CMD_SET_COPY : section -> timeout_busy = new_service_options . timeout_busy ; break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , "TIMEOUTbusy" ) ) break ; { char * tmp_str ; section -> timeout_busy = ( int ) strtol ( arg , & tmp_str , 10 ) ; if ( tmp_str == arg || * tmp_str ) return "Illegal<S2SV_blank>busy<S2SV_blank>timeout" ; } return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : s_log ( LOG_NOTICE , "%-22s<S2SV_blank>=<S2SV_blank>%d<S2SV_blank>seconds" , "TIMEOUTbusy" , 300 ) ; break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , "%-22s<S2SV_blank>=<S2SV_blank>seconds<S2SV_blank>to<S2SV_blank>wait<S2SV_blank>for<S2SV_blank>expected<S2SV_blank>data" , "TIMEOUTbusy" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : section -> timeout_close = 60 ; break ; case CMD_SET_COPY : section -> timeout_close = new_service_options . timeout_close ; break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , "TIMEOUTclose" ) ) break ; { char * tmp_str ; section -> timeout_close = ( int ) strtol ( arg , & tmp_str , 10 ) ; if ( tmp_str == arg || * tmp_str ) return "Illegal<S2SV_blank>close<S2SV_blank>timeout" ; } return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : s_log ( LOG_NOTICE , "%-22s<S2SV_blank>=<S2SV_blank>%d<S2SV_blank>seconds" , "TIMEOUTclose" , 60 ) ; break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , "%-22s<S2SV_blank>=<S2SV_blank>seconds<S2SV_blank>to<S2SV_blank>wait<S2SV_blank>for<S2SV_blank>close_notify" , "TIMEOUTclose" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : section -> timeout_connect = 10 ; break ; case CMD_SET_COPY : section -> timeout_connect = new_service_options . timeout_connect ; break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , "TIMEOUTconnect" ) ) break ; { char * tmp_str ; section -> timeout_connect = ( int ) strtol ( arg , & tmp_str , 10 ) ; if ( tmp_str == arg || * tmp_str ) return "Illegal<S2SV_blank>connect<S2SV_blank>timeout" ; } return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : s_log ( LOG_NOTICE , "%-22s<S2SV_blank>=<S2SV_blank>%d<S2SV_blank>seconds" , "TIMEOUTconnect" , 10 ) ; break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , "%-22s<S2SV_blank>=<S2SV_blank>seconds<S2SV_blank>to<S2SV_blank>connect<S2SV_blank>remote<S2SV_blank>host" , "TIMEOUTconnect" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : section -> timeout_idle = 43200 ; break ; case CMD_SET_COPY : section -> timeout_idle = new_service_options . timeout_idle ; break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , "TIMEOUTidle" ) ) break ; { char * tmp_str ; section -> timeout_idle = ( int ) strtol ( arg , & tmp_str , 10 ) ; if ( tmp_str == arg || * tmp_str ) return "Illegal<S2SV_blank>idle<S2SV_blank>timeout" ; return NULL ; } case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : s_log ( LOG_NOTICE , "%-22s<S2SV_blank>=<S2SV_blank>%d<S2SV_blank>seconds" , "TIMEOUTidle" , 43200 ) ; break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , "%-22s<S2SV_blank>=<S2SV_blank>seconds<S2SV_blank>to<S2SV_blank>keep<S2SV_blank>an<S2SV_blank>idle<S2SV_blank>connection" , "TIMEOUTidle" ) ; break ; } # ifndef USE_WIN32 switch ( cmd ) { case CMD_SET_DEFAULTS : section -> option . transparent_src = 0 ; section -> option . transparent_dst = 0 ; break ; case CMD_SET_COPY : section -> option . transparent_src = new_service_options . option . transparent_src ; section -> option . transparent_dst = new_service_options . option . transparent_dst ; break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , "transparent" ) ) break ; if ( ! strcasecmp ( arg , "none" ) || ! strcasecmp ( arg , "no" ) ) { section -> option . transparent_src = 0 ; section -> option . transparent_dst = 0 ; } else if ( ! strcasecmp ( arg , "source" ) || ! strcasecmp ( arg , "yes" ) ) { section -> option . transparent_src = 1 ; section -> option . transparent_dst = 0 ; } else if ( ! strcasecmp ( arg , "destination" ) ) { section -> option . transparent_src = 0 ; section -> option . transparent_dst = 1 ; } else if ( ! strcasecmp ( arg , "both" ) ) { section -> option . transparent_src = 1 ; section -> option . transparent_dst = 1 ; } else return "Selected<S2SV_blank>transparent<S2SV_blank>proxy<S2SV_blank>mode<S2SV_blank>is<S2SV_blank>not<S2SV_blank>available" ; return NULL ; case CMD_INITIALIZE : if ( section -> option . transparent_dst ) ++ endpoints ; break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , "%-22s<S2SV_blank>=<S2SV_blank>none|source|destination|both<S2SV_blank>transparent<S2SV_blank>proxy<S2SV_blank>mode" , "transparent" ) ; break ; } # endif switch ( cmd ) { case CMD_SET_DEFAULTS : section -> option . request_cert = 0 ; break ; case CMD_SET_COPY : section -> option . request_cert = new_service_options . option . request_cert ; break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , "verify" ) ) break ; { char * tmp_str ; int tmp_int = ( int ) strtol ( arg , & tmp_str , 10 ) ; if ( tmp_str == arg || * tmp_str || tmp_int < 0 || tmp_int > 4 ) return "Bad<S2SV_blank>verify<S2SV_blank>level" ; section -> option . request_cert = 1 ; section -> option . require_cert = ( tmp_int >= 2 ) ; section -> option . verify_chain = ( tmp_int >= 1 && tmp_int <= 3 ) ; section -> option . verify_peer = ( tmp_int >= 3 ) ; } return NULL ; case CMD_INITIALIZE : if ( ( section -> option . verify_chain || section -> option . verify_peer ) && ! section -> ca_file && ! section -> ca_dir ) return "Either<S2SV_blank>\\"CAfile\\"<S2SV_blank>or<S2SV_blank>\\"CApath\\"<S2SV_blank>has<S2SV_blank>to<S2SV_blank>be<S2SV_blank>configured" ; break ; case CMD_PRINT_DEFAULTS : s_log ( LOG_NOTICE , "%-22s<S2SV_blank>=<S2SV_blank>none" , "verify" ) ; break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , "%-22s<S2SV_blank>=<S2SV_blank>level<S2SV_blank>of<S2SV_blank>peer<S2SV_blank>certificate<S2SV_blank>verification" , "verify" ) ; <S2SV_StartBug> s_log ( LOG_NOTICE , <S2SV_EndBug> "%25slevel<S2SV_blank>0<S2SV_blank>-<S2SV_blank>request<S2SV_blank>and<S2SV_blank>ignore<S2SV_blank>peer<S2SV_blank>cert" , "" ) ; s_log ( LOG_NOTICE , "%25slevel<S2SV_blank>1<S2SV_blank>-<S2SV_blank>only<S2SV_blank>validate<S2SV_blank>peer<S2SV_blank>cert<S2SV_blank>if<S2SV_blank>present" , "" ) ; s_log ( LOG_NOTICE , "%25slevel<S2SV_blank>2<S2SV_blank>-<S2SV_blank>always<S2SV_blank>require<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>peer<S2SV_blank>cert" , "" ) ; s_log ( LOG_NOTICE , "%25slevel<S2SV_blank>3<S2SV_blank>-<S2SV_blank>verify<S2SV_blank>peer<S2SV_blank>with<S2SV_blank>locally<S2SV_blank>installed<S2SV_blank>cert" , "" ) ; s_log ( LOG_NOTICE , "%25slevel<S2SV_blank>4<S2SV_blank>-<S2SV_blank>ignore<S2SV_blank>CA<S2SV_blank>chain<S2SV_blank>and<S2SV_blank>only<S2SV_blank>verify<S2SV_blank>peer<S2SV_blank>cert" , "" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : section -> option . verify_chain = 0 ; break ; case CMD_SET_COPY : section -> option . verify_chain = new_service_options . option . verify_chain ; break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , "verifyChain" ) ) break ; if ( ! strcasecmp ( arg , "yes" ) ) { section -> option . request_cert = 1 ; section -> option . require_cert = 1 ; section -> option . verify_chain = 1 ; } else if ( ! strcasecmp ( arg , "no" ) ) { section -> option . verify_chain = 0 ; } else { return "The<S2SV_blank>argument<S2SV_blank>needs<S2SV_blank>to<S2SV_blank>be<S2SV_blank>either<S2SV_blank>\'yes\'<S2SV_blank>or<S2SV_blank>\'no\'" ; } return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , "%-22s<S2SV_blank>=<S2SV_blank>yes|no<S2SV_blank>verify<S2SV_blank>certificate<S2SV_blank>chain" , "verifyChain" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : section -> option . verify_peer = 0 ; break ; case CMD_SET_COPY : section -> option . verify_peer = new_service_options . option . verify_peer ; break ; case CMD_FREE : break ; case CMD_SET_VALUE : if ( strcasecmp ( opt , "verifyPeer" ) ) break ; if ( ! strcasecmp ( arg , "yes" ) ) { section -> option . request_cert = 1 ; section -> option . require_cert = 1 ; section -> option . verify_peer = 1 ; } else if ( ! strcasecmp ( arg , "no" ) ) { section -> option . verify_peer = 0 ; } else { return "The<S2SV_blank>argument<S2SV_blank>needs<S2SV_blank>to<S2SV_blank>be<S2SV_blank>either<S2SV_blank>\'yes\'<S2SV_blank>or<S2SV_blank>\'no\'" ; } return NULL ; case CMD_INITIALIZE : break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : s_log ( LOG_NOTICE , "%-22s<S2SV_blank>=<S2SV_blank>yes|no<S2SV_blank>verify<S2SV_blank>peer<S2SV_blank>certificate" , "verifyPeer" ) ; break ; } switch ( cmd ) { case CMD_SET_DEFAULTS : break ; case CMD_SET_COPY : break ; case CMD_FREE : str_free ( section -> chain ) ; if ( section -> session ) SSL_SESSION_free ( section -> session ) ; if ( section -> ctx ) SSL_CTX_free ( section -> ctx ) ; str_free ( section -> servname ) ; <S2SV_StartBug> if ( section == & service_options ) <S2SV_EndBug> memset ( section , 0 , sizeof ( SERVICE_OPTIONS ) ) ; else str_free ( section ) ; break ; case CMD_SET_VALUE : return option_not_found ; case CMD_INITIALIZE : if ( section != & new_service_options ) { if ( endpoints != 2 ) return "Each<S2SV_blank>service<S2SV_blank>must<S2SV_blank>define<S2SV_blank>two<S2SV_blank>endpoints" ; } else { if ( section -> option . accept ) return "\'accept\'<S2SV_blank>option<S2SV_blank>is<S2SV_blank>only<S2SV_blank>allowed<S2SV_blank>in<S2SV_blank>a<S2SV_blank>[section]" ; if ( endpoints != 1 ) return "Inetd<S2SV_blank>mode<S2SV_blank>must<S2SV_blank>define<S2SV_blank>one<S2SV_blank>endpoint" ; } # ifdef SSL_OP_NO_TICKET if ( OpenSSL_version_num ( ) < 0x10101000L && ! section -> option . client && ! section -> option . connect_before_ssl ) section -> ssl_options_set |= SSL_OP_NO_TICKET ; # endif if ( context_init ( section ) ) return "Failed<S2SV_blank>to<S2SV_blank>initialize<S2SV_blank>TLS<S2SV_blank>context" ; break ; case CMD_PRINT_DEFAULTS : break ; case CMD_PRINT_HELP : break ; } return NULL ; }
static void __local_bh_enable ( unsigned int cnt ) { <S2SV_StartBug> lockdep_assert_irqs_disabled ( ) ; <S2SV_EndBug> if ( softirq_count ( ) == ( cnt & SOFTIRQ_MASK ) ) trace_softirqs_on ( _RET_IP_ ) ; <S2SV_StartBug> preempt_count_sub ( cnt ) ; <S2SV_EndBug> }
int vp8_hex_search ( MACROBLOCK * x , BLOCK * b , BLOCKD * d , int_mv * ref_mv , int_mv * best_mv , int search_param , int sad_per_bit , const vp8_variance_fn_ptr_t * vfp , int * mvsadcost [ 2 ] , int * mvcost [ 2 ] , int_mv * center_mv ) { MV hex [ 6 ] = { { - 1 , - 2 } , { 1 , - 2 } , { 2 , 0 } , { 1 , 2 } , { - 1 , 2 } , { - 2 , 0 } } ; MV neighbors [ 4 ] = { { 0 , - 1 } , { - 1 , 0 } , { 1 , 0 } , { 0 , 1 } } ; int i , j ; unsigned char * what = ( * ( b -> base_src ) + b -> src ) ; int what_stride = b -> src_stride ; int pre_stride = x -> e_mbd . pre . y_stride ; unsigned char * base_pre = x -> e_mbd . pre . y_buffer ; int in_what_stride = pre_stride ; int br , bc ; int_mv this_mv ; unsigned int bestsad ; unsigned int thissad ; unsigned char * base_offset ; unsigned char * this_offset ; int k = - 1 ; int all_in ; int best_site = - 1 ; int hex_range = 127 ; int dia_range = 8 ; int_mv fcenter_mv ; fcenter_mv . as_mv . row = center_mv -> as_mv . row >> 3 ; fcenter_mv . as_mv . col = center_mv -> as_mv . col >> 3 ; <S2SV_StartBug> vp8_clamp_mv ( ref_mv , x -> mv_col_min , x -> mv_col_max , x -> mv_row_min , x -> mv_row_max ) ; <S2SV_EndBug> br = ref_mv -> as_mv . row ; bc = ref_mv -> as_mv . col ; base_offset = ( unsigned char * ) ( base_pre + d -> offset ) ; this_offset = base_offset + ( br * ( pre_stride ) ) + bc ; this_mv . as_mv . row = br ; this_mv . as_mv . col = bc ; <S2SV_StartBug> bestsad = vfp -> sdf ( what , what_stride , this_offset , in_what_stride , UINT_MAX ) <S2SV_EndBug> + mvsad_err_cost ( & this_mv , & fcenter_mv , mvsadcost , sad_per_bit ) ; # if CONFIG_MULTI_RES_ENCODING if ( search_param >= 6 ) goto cal_neighbors ; else if ( search_param >= 5 ) hex_range = 4 ; else if ( search_param >= 4 ) hex_range = 6 ; else if ( search_param >= 3 ) hex_range = 15 ; else if ( search_param >= 2 ) hex_range = 31 ; else if ( search_param >= 1 ) hex_range = 63 ; dia_range = 8 ; <S2SV_StartBug> # endif <S2SV_EndBug> CHECK_BOUNDS ( 2 ) if ( all_in ) { for ( i = 0 ; i < 6 ; i ++ ) { this_mv . as_mv . row = br + hex [ i ] . row ; this_mv . as_mv . col = bc + hex [ i ] . col ; this_offset = base_offset + ( this_mv . as_mv . row * in_what_stride ) + this_mv . as_mv . col ; <S2SV_StartBug> thissad = vfp -> sdf ( what , what_stride , this_offset , in_what_stride , bestsad ) ; <S2SV_EndBug> CHECK_BETTER } } else { for ( i = 0 ; i < 6 ; i ++ ) { this_mv . as_mv . row = br + hex [ i ] . row ; this_mv . as_mv . col = bc + hex [ i ] . col ; CHECK_POINT this_offset = base_offset + ( this_mv . as_mv . row * in_what_stride ) + this_mv . as_mv . col ; <S2SV_StartBug> thissad = vfp -> sdf ( what , what_stride , this_offset , in_what_stride , bestsad ) ; <S2SV_EndBug> CHECK_BETTER } } if ( best_site == - 1 ) goto cal_neighbors ; else { br += hex [ best_site ] . row ; bc += hex [ best_site ] . col ; k = best_site ; } for ( j = 1 ; j < hex_range ; j ++ ) { best_site = - 1 ; CHECK_BOUNDS ( 2 ) if ( all_in ) { for ( i = 0 ; i < 3 ; i ++ ) { this_mv . as_mv . row = br + next_chkpts [ k ] [ i ] . row ; this_mv . as_mv . col = bc + next_chkpts [ k ] [ i ] . col ; this_offset = base_offset + ( this_mv . as_mv . row * ( in_what_stride ) ) + this_mv . as_mv . col ; <S2SV_StartBug> thissad = vfp -> sdf ( what , what_stride , this_offset , in_what_stride , bestsad ) ; <S2SV_EndBug> CHECK_BETTER } } else { for ( i = 0 ; i < 3 ; i ++ ) { this_mv . as_mv . row = br + next_chkpts [ k ] [ i ] . row ; this_mv . as_mv . col = bc + next_chkpts [ k ] [ i ] . col ; CHECK_POINT this_offset = base_offset + ( this_mv . as_mv . row * ( in_what_stride ) ) + this_mv . as_mv . col ; <S2SV_StartBug> thissad = vfp -> sdf ( what , what_stride , this_offset , in_what_stride , bestsad ) ; <S2SV_EndBug> CHECK_BETTER } } if ( best_site == - 1 ) break ; else { br += next_chkpts [ k ] [ best_site ] . row ; bc += next_chkpts [ k ] [ best_site ] . col ; k += 5 + best_site ; if ( k >= 12 ) k -= 12 ; else if ( k >= 6 ) k -= 6 ; } } cal_neighbors : for ( j = 0 ; j < dia_range ; j ++ ) { best_site = - 1 ; CHECK_BOUNDS ( 1 ) if ( all_in ) { for ( i = 0 ; i < 4 ; i ++ ) { this_mv . as_mv . row = br + neighbors [ i ] . row ; this_mv . as_mv . col = bc + neighbors [ i ] . col ; this_offset = base_offset + ( this_mv . as_mv . row * ( in_what_stride ) ) + this_mv . as_mv . col ; <S2SV_StartBug> thissad = vfp -> sdf ( what , what_stride , this_offset , in_what_stride , bestsad ) ; <S2SV_EndBug> CHECK_BETTER } } else { for ( i = 0 ; i < 4 ; i ++ ) { this_mv . as_mv . row = br + neighbors [ i ] . row ; this_mv . as_mv . col = bc + neighbors [ i ] . col ; CHECK_POINT this_offset = base_offset + ( this_mv . as_mv . row * ( in_what_stride ) ) + this_mv . as_mv . col ; <S2SV_StartBug> thissad = vfp -> sdf ( what , what_stride , this_offset , in_what_stride , bestsad ) ; <S2SV_EndBug> CHECK_BETTER } } if ( best_site == - 1 ) break ; else { br += neighbors [ best_site ] . row ; bc += neighbors [ best_site ] . col ; } } best_mv -> as_mv . row = br ; best_mv -> as_mv . col = bc ; return bestsad ; }
static int attach_recursive_mnt ( struct mount * source_mnt , struct mount * dest_mnt , struct mountpoint * dest_mp , struct path * parent_path ) { HLIST_HEAD ( tree_list ) ; <S2SV_StartBug> struct mount * child , * p ; <S2SV_EndBug> struct hlist_node * n ; int err ; <S2SV_StartBug> if ( IS_MNT_SHARED ( dest_mnt ) ) { <S2SV_EndBug> err = invent_group_ids ( source_mnt , true ) ; if ( err ) goto out ; <S2SV_StartBug> err = propagate_mnt ( dest_mnt , dest_mp , source_mnt , & tree_list ) ; <S2SV_EndBug> lock_mount_hash ( ) ; if ( err ) goto out_cleanup_ids ; for ( p = source_mnt ; p ; p = next_mnt ( p , source_mnt ) ) set_mnt_shared ( p ) ; } else { lock_mount_hash ( ) ; } if ( parent_path ) { detach_mnt ( source_mnt , parent_path ) ; attach_mnt ( source_mnt , dest_mnt , dest_mp ) ; touch_mnt_namespace ( source_mnt -> mnt_ns ) ; } else { mnt_set_mountpoint ( dest_mnt , dest_mp , source_mnt ) ; commit_tree ( source_mnt , NULL ) ; } hlist_for_each_entry_safe ( child , n , & tree_list , mnt_hash ) { struct mount * q ; hlist_del_init ( & child -> mnt_hash ) ; q = __lookup_mnt_last ( & child -> mnt_parent -> mnt , child -> mnt_mountpoint ) ; commit_tree ( child , q ) ; } unlock_mount_hash ( ) ; return 0 ; out_cleanup_ids : while ( ! hlist_empty ( & tree_list ) ) { child = hlist_entry ( tree_list . first , struct mount , mnt_hash ) ; <S2SV_StartBug> umount_tree ( child , UMOUNT_SYNC ) ; <S2SV_EndBug> } unlock_mount_hash ( ) ; cleanup_group_ids ( source_mnt , NULL ) ; out : <S2SV_StartBug> return err ; <S2SV_EndBug> }
void * adminchild ( struct clientparam * param ) { int i , res ; char * buf ; char username [ 256 ] ; char * sb ; char * req = NULL ; struct printparam pp ; <S2SV_StartBug> int contentlen = 0 ; <S2SV_EndBug> int isform = 0 ; pp . inbuf = 0 ; pp . cp = param ; buf = myalloc ( LINESIZE ) ; if ( ! buf ) { RETURN ( 555 ) ; } i = sockgetlinebuf ( param , CLIENT , ( unsigned char * ) buf , LINESIZE - 1 , '\\n' , conf . timeouts [ STRING_S ] ) ; if ( i < 5 || ( ( buf [ 0 ] != 'G' || buf [ 1 ] != 'E' || buf [ 2 ] != 'T' || buf [ 3 ] != '<S2SV_blank>' || buf [ 4 ] != '/' ) && ( buf [ 0 ] != 'P' || buf [ 1 ] != 'O' || buf [ 2 ] != 'S' || buf [ 3 ] != 'T' || buf [ 4 ] != '<S2SV_blank>' || buf [ 5 ] != '/' ) ) ) { RETURN ( 701 ) ; } buf [ i ] = 0 ; sb = strchr ( buf + 5 , '<S2SV_blank>' ) ; if ( ! sb ) { RETURN ( 702 ) ; } * sb = 0 ; req = mystrdup ( buf + ( ( * buf == 'P' ) ? 6 : 5 ) ) ; while ( ( i = sockgetlinebuf ( param , CLIENT , ( unsigned char * ) buf , LINESIZE - 1 , '\\n' , conf . timeouts [ STRING_S ] ) ) > 2 ) { buf [ i ] = 0 ; if ( i > 19 && ( ! strncasecmp ( buf , "authorization" , 13 ) ) ) { sb = strchr ( buf , ':' ) ; if ( ! sb ) continue ; ++ sb ; while ( isspace ( * sb ) ) sb ++ ; if ( ! * sb || strncasecmp ( sb , "basic" , 5 ) ) { continue ; } sb += 5 ; while ( isspace ( * sb ) ) sb ++ ; i = de64 ( ( unsigned char * ) sb , ( unsigned char * ) username , 255 ) ; if ( i <= 0 ) continue ; username [ i ] = 0 ; sb = strchr ( ( char * ) username , ':' ) ; if ( sb ) { * sb = 0 ; if ( param -> password ) myfree ( param -> password ) ; param -> password = ( unsigned char * ) mystrdup ( sb + 1 ) ; } if ( param -> username ) myfree ( param -> username ) ; param -> username = ( unsigned char * ) mystrdup ( username ) ; continue ; } else if ( i > 15 && ( ! strncasecmp ( buf , "content-length:" , 15 ) ) ) { sb = buf + 15 ; while ( isspace ( * sb ) ) sb ++ ; <S2SV_StartBug> contentlen = atoi ( sb ) ; <S2SV_EndBug> } else if ( i > 13 && ( ! strncasecmp ( buf , "content-type:" , 13 ) ) ) { sb = buf + 13 ; while ( isspace ( * sb ) ) sb ++ ; if ( ! strncasecmp ( sb , "x-www-form-urlencoded" , 21 ) ) isform = 1 ; } } param -> operation = ADMIN ; if ( isform && contentlen ) { printstr ( & pp , "HTTP/1.0<S2SV_blank>100<S2SV_blank>Continue\\r\\n\\r\\n" ) ; stdpr ( & pp , NULL , 0 ) ; } res = ( * param -> srv -> authfunc ) ( param ) ; if ( res && res != 10 ) { printstr ( & pp , authreq ) ; RETURN ( res ) ; } if ( param -> srv -> singlepacket || param -> redirected ) { if ( * req == 'C' ) req [ 1 ] = 0 ; else * req = 0 ; } sprintf ( buf , ok , conf . stringtable ? ( char * ) conf . stringtable [ 2 ] : "3proxy" , conf . stringtable ? ( char * ) conf . stringtable [ 2 ] : "3[APA3A]<S2SV_blank>tiny<S2SV_blank>proxy" , conf . stringtable ? ( char * ) conf . stringtable [ 3 ] : "" ) ; if ( * req != 'S' ) printstr ( & pp , buf ) ; switch ( * req ) { case 'C' : printstr ( & pp , counters ) ; { struct trafcount * cp ; int num = 0 ; for ( cp = conf . trafcounter ; cp ; cp = cp -> next , num ++ ) { int inbuf = 0 ; if ( cp -> ace && ( param -> srv -> singlepacket || param -> redirected ) ) { if ( ! ACLmatches ( cp -> ace , param ) ) continue ; } if ( req [ 1 ] == 'S' && atoi ( req + 2 ) == num ) cp -> disabled = 0 ; if ( req [ 1 ] == 'D' && atoi ( req + 2 ) == num ) cp -> disabled = 1 ; inbuf += sprintf ( buf , "<tr>" "<td>%s</td><td><A<S2SV_blank>HREF=\\\'/C%c%d\\\'>%s</A></td><td>" , ( cp -> comment ) ? cp -> comment : "&nbsp;" , ( cp -> disabled ) ? 'S' : 'D' , num , ( cp -> disabled ) ? "NO" : "YES" ) ; if ( ! cp -> ace || ! cp -> ace -> users ) { inbuf += sprintf ( buf + inbuf , "<center>ANY</center>" ) ; } else { inbuf += printuserlist ( buf + inbuf , LINESIZE - 800 , cp -> ace -> users , ",<br<S2SV_blank>/>\\r\\n" ) ; } inbuf += sprintf ( buf + inbuf , "</td><td>" ) ; if ( ! cp -> ace || ! cp -> ace -> src ) { inbuf += sprintf ( buf + inbuf , "<center>ANY</center>" ) ; } else { inbuf += printiplist ( buf + inbuf , LINESIZE - 512 , cp -> ace -> src , ",<br<S2SV_blank>/>\\r\\n" ) ; } inbuf += sprintf ( buf + inbuf , "</td><td>" ) ; if ( ! cp -> ace || ! cp -> ace -> dst ) { inbuf += sprintf ( buf + inbuf , "<center>ANY</center>" ) ; } else { inbuf += printiplist ( buf + inbuf , LINESIZE - 512 , cp -> ace -> dst , ",<br<S2SV_blank>/>\\r\\n" ) ; } inbuf += sprintf ( buf + inbuf , "</td><td>" ) ; if ( ! cp -> ace || ! cp -> ace -> ports ) { inbuf += sprintf ( buf + inbuf , "<center>ANY</center>" ) ; } else { inbuf += printportlist ( buf + inbuf , LINESIZE - 128 , cp -> ace -> ports , ",<br<S2SV_blank>/>\\r\\n" ) ; } if ( cp -> type == NONE ) { inbuf += sprintf ( buf + inbuf , "</td><td<S2SV_blank>colspan=\\\'6\\\'<S2SV_blank>align=\\\'center\\\'>exclude<S2SV_blank>from<S2SV_blank>limitation</td></tr>\\r\\n" ) ; } else { inbuf += sprintf ( buf + inbuf , "</td><td>%" PRINTF_INT64_MODIFIER "u</td>" "<td>MB%s</td>" "<td>%" PRINTF_INT64_MODIFIER "u</td>" "<td>%s</td>" , cp -> traflim64 / ( 1024 * 1024 ) , rotations [ cp -> type ] , cp -> traf64 , cp -> cleared ? ctime ( & cp -> cleared ) : "never" ) ; inbuf += sprintf ( buf + inbuf , "<td>%s</td>" "<td>%i</td>" "</tr>\\r\\n" , cp -> updated ? ctime ( & cp -> updated ) : "never" , cp -> number ) ; } printstr ( & pp , buf ) ; } } printstr ( & pp , counterstail ) ; break ; case 'R' : conf . needreload = 1 ; printstr ( & pp , "<h3>Reload<S2SV_blank>scheduled</h3>" ) ; break ; case 'S' : { if ( req [ 1 ] == 'X' ) { printstr ( & pp , style ) ; break ; } printstr ( & pp , xml ) ; printval ( conf . services , TYPE_SERVER , 0 , & pp ) ; printstr ( & pp , postxml ) ; } break ; case 'F' : { FILE * fp ; char buf [ 256 ] ; fp = confopen ( ) ; if ( ! fp ) { printstr ( & pp , "<h3><font<S2SV_blank>color=\\"red\\">Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>config<S2SV_blank>file</font></h3>" ) ; break ; } printstr ( & pp , "<h3>Please<S2SV_blank>be<S2SV_blank>careful<S2SV_blank>editing<S2SV_blank>config<S2SV_blank>file<S2SV_blank>remotely</h3>" ) ; <S2SV_StartBug> printstr ( & pp , "<form<S2SV_blank>method=\\"POST\\"<S2SV_blank>action=\\"/U\\"><textarea<S2SV_blank>cols=\\"80\\"<S2SV_blank>rows=\\"30\\"<S2SV_blank>name=\\"conffile\\">" ) ; <S2SV_EndBug> while ( fgets ( buf , 256 , fp ) ) { printstr ( & pp , buf ) ; } if ( ! writable ) fclose ( fp ) ; printstr ( & pp , "</textarea><br><input<S2SV_blank>type=\\"Submit\\"></form>" ) ; break ; } case 'U' : { <S2SV_StartBug> int l = 0 ; <S2SV_EndBug> int error = 0 ; <S2SV_StartBug> if ( ! writable || fseek ( writable , 0 , 0 ) ) { <S2SV_EndBug> error = 1 ; } <S2SV_StartBug> while ( ( i = sockgetlinebuf ( param , CLIENT , ( unsigned char * ) buf , LINESIZE - 1 , '+' , conf . timeouts [ STRING_S ] ) ) > 0 ) { <S2SV_EndBug> if ( i > ( contentlen - l ) ) i = ( contentlen - l ) ; <S2SV_StartBug> buf [ i ] = 0 ; <S2SV_EndBug> if ( ! l ) { if ( strncasecmp ( buf , "conffile=" , 9 ) ) error = 1 ; } <S2SV_StartBug> if ( ! error ) { <S2SV_EndBug> decodeurl ( ( unsigned char * ) buf , 1 ) ; fprintf ( writable , "%s" , l ? buf : buf + 9 ) ; } <S2SV_StartBug> l += i ; <S2SV_EndBug> if ( l >= contentlen ) break ; } if ( writable && ! error ) { fflush ( writable ) ; # ifndef _WINCE ftruncate ( fileno ( writable ) , ftell ( writable ) ) ; # endif } printstr ( & pp , error ? "<h3><font<S2SV_blank>color=\\"red\\">Config<S2SV_blank>file<S2SV_blank>is<S2SV_blank>not<S2SV_blank>writable</font></h3>Make<S2SV_blank>sure<S2SV_blank>you<S2SV_blank>have<S2SV_blank>\\"writable\\"<S2SV_blank>command<S2SV_blank>in<S2SV_blank>configuration<S2SV_blank>file" : "<h3>Configuration<S2SV_blank>updated</h3>" ) ; } break ; default : printstr ( & pp , ( char * ) conf . stringtable [ WEBBANNERS ] ) ; break ; } if ( * req != 'S' ) printstr ( & pp , tail ) ; CLEANRET : printstr ( & pp , NULL ) ; if ( buf ) myfree ( buf ) ; ( * param -> srv -> logfunc ) ( param , ( unsigned char * ) req ) ; if ( req ) myfree ( req ) ; freeparam ( param ) ; return ( NULL ) ; }
void skb_complete_tx_timestamp ( struct sk_buff * skb , struct skb_shared_hwtstamps * hwtstamps ) { struct sock * sk = skb -> sk ; if ( ! skb_may_tx_timestamp ( sk , false ) ) return ; if ( likely ( atomic_inc_not_zero ( & sk -> sk_refcnt ) ) ) { * skb_hwtstamps ( skb ) = * hwtstamps ; <S2SV_StartBug> __skb_complete_tx_timestamp ( skb , sk , SCM_TSTAMP_SND ) ; <S2SV_EndBug> sock_put ( sk ) ; } }
<S2SV_StartBug> static int nfs4_intent_set_file ( struct nameidata * nd , struct path * path , struct nfs4_state * state ) <S2SV_EndBug> { struct file * filp ; int ret ; <S2SV_StartBug> if ( nd -> intent . open . flags & FMODE_EXEC ) { <S2SV_EndBug> ret = nfs_may_open ( state -> inode , state -> owner -> so_cred , nd -> intent . open . flags ) ; if ( ret < 0 ) goto out_close ; } filp = lookup_instantiate_filp ( nd , path -> dentry , NULL ) ; if ( ! IS_ERR ( filp ) ) { struct nfs_open_context * ctx ; ctx = nfs_file_open_context ( filp ) ; ctx -> state = state ; return 0 ; } ret = PTR_ERR ( filp ) ; out_close : <S2SV_StartBug> nfs4_close_sync ( path , state , nd -> intent . open . flags ) ; <S2SV_EndBug> return ret ; }
struct bpf_map * bpf_map_get_with_uref ( u32 ufd ) { struct fd f = fdget ( ufd ) ; struct bpf_map * map ; map = __bpf_map_get ( f ) ; if ( IS_ERR ( map ) ) return map ; <S2SV_StartBug> bpf_map_inc ( map , true ) ; <S2SV_EndBug> fdput ( f ) ; return map ; }
static inline void VectorClamp ( DDSVector4 * value ) { <S2SV_StartBug> value -> x = MinF ( 1.0f , MaxF ( 0.0f , value -> x ) ) ; <S2SV_EndBug> <S2SV_StartBug> value -> y = MinF ( 1.0f , MaxF ( 0.0f , value -> y ) ) ; <S2SV_EndBug> <S2SV_StartBug> value -> z = MinF ( 1.0f , MaxF ( 0.0f , value -> z ) ) ; <S2SV_EndBug> <S2SV_StartBug> value -> w = MinF ( 1.0f , MaxF ( 0.0f , value -> w ) ) ; <S2SV_EndBug> }
static node * parsetok ( struct tok_state * tok , grammar * g , int start , perrdetail * err_ret , int * flags ) { parser_state * ps ; node * n ; int started = 0 ; <S2SV_StartBug> int col_offset , end_col_offset ; <S2SV_EndBug> if ( ( ps = PyParser_New ( g , start ) ) == NULL ) { err_ret -> error = E_NOMEM ; PyTokenizer_Free ( tok ) ; return NULL ; } # ifdef PY_PARSER_REQUIRES_FUTURE_KEYWORD if ( * flags & PyPARSE_BARRY_AS_BDFL ) <S2SV_StartBug> ps -> p_flags |= CO_FUTURE_BARRY_AS_BDFL ; <S2SV_EndBug> # endif for ( ; ; ) { char * a , * b ; int type ; size_t len ; char * str ; col_offset = - 1 ; int lineno ; const char * line_start ; type = PyTokenizer_Get ( tok , & a , & b ) ; if ( type == ERRORTOKEN ) { err_ret -> error = tok -> done ; break ; } if ( type == ENDMARKER && started ) { type = NEWLINE ; started = 0 ; if ( tok -> indent && ! ( * flags & PyPARSE_DONT_IMPLY_DEDENT ) ) { tok -> pendin = - tok -> indent ; tok -> indent = 0 ; } } else started = 1 ; len = ( a != NULL && b != NULL ) ? b - a : 0 ; str = ( char * ) PyObject_MALLOC ( len + 1 ) ; if ( str == NULL ) { err_ret -> error = E_NOMEM ; break ; } if ( len > 0 ) strncpy ( str , a , len ) ; str [ len ] = '\\0' ; # ifdef PY_PARSER_REQUIRES_FUTURE_KEYWORD if ( type == NOTEQUAL ) { if ( ! ( ps -> p_flags & CO_FUTURE_BARRY_AS_BDFL ) && strcmp ( str , "!=" ) ) { PyObject_FREE ( str ) ; err_ret -> error = E_SYNTAX ; break ; } else if ( ( ps -> p_flags & CO_FUTURE_BARRY_AS_BDFL ) && strcmp ( str , "<>" ) ) { PyObject_FREE ( str ) ; err_ret -> expected = NOTEQUAL ; err_ret -> error = E_SYNTAX ; break ; } } # endif lineno = type == STRING ? tok -> first_lineno : tok -> lineno ; line_start = type == STRING ? tok -> multi_line_start : tok -> line_start ; if ( a != NULL && a >= line_start ) { col_offset = Py_SAFE_DOWNCAST ( a - line_start , intptr_t , int ) ; } else { col_offset = - 1 ; } if ( b != NULL && b >= tok -> line_start ) { end_col_offset = Py_SAFE_DOWNCAST ( b - tok -> line_start , intptr_t , int ) ; } else { end_col_offset = - 1 ; } <S2SV_StartBug> if ( ( err_ret -> error = <S2SV_EndBug> PyParser_AddToken ( ps , ( int ) type , str , lineno , col_offset , tok -> lineno , end_col_offset , & ( err_ret -> expected ) ) ) != E_OK ) { if ( err_ret -> error != E_DONE ) { PyObject_FREE ( str ) ; err_ret -> token = type ; } break ; } } if ( err_ret -> error == E_DONE ) { n = ps -> p_tree ; <S2SV_StartBug> ps -> p_tree = NULL ; <S2SV_EndBug> # ifndef PGEN if ( start == single_input ) { char * cur = tok -> cur ; char c = * tok -> cur ; for ( ; ; ) { while ( c == '<S2SV_blank>' || c == '\\t' || c == '\\n' || c == '\\014' ) c = * ++ cur ; if ( ! c ) break ; if ( c != '#' ) { err_ret -> error = E_BADSINGLE ; PyNode_Free ( n ) ; n = NULL ; break ; } while ( c && c != '\\n' ) c = * ++ cur ; } } # endif } else n = NULL ; # ifdef PY_PARSER_REQUIRES_FUTURE_KEYWORD * flags = ps -> p_flags ; # endif PyParser_Delete ( ps ) ; if ( n == NULL ) { if ( tok -> done == E_EOF ) err_ret -> error = E_EOF ; err_ret -> lineno = tok -> lineno ; if ( tok -> buf != NULL ) { size_t len ; assert ( tok -> cur - tok -> buf < INT_MAX ) ; err_ret -> offset = col_offset != - 1 ? col_offset + 1 : ( ( int ) ( tok -> cur - tok -> buf ) ) ; len = tok -> inp - tok -> buf ; err_ret -> text = ( char * ) PyObject_MALLOC ( len + 1 ) ; if ( err_ret -> text != NULL ) { if ( len > 0 ) strncpy ( err_ret -> text , tok -> buf , len ) ; err_ret -> text [ len ] = '\\0' ; } } } else if ( tok -> encoding != NULL ) { node * r = PyNode_New ( encoding_decl ) ; if ( r ) r -> n_str = PyObject_MALLOC ( strlen ( tok -> encoding ) + 1 ) ; if ( ! r || ! r -> n_str ) { err_ret -> error = E_NOMEM ; if ( r ) PyObject_FREE ( r ) ; n = NULL ; goto done ; } strcpy ( r -> n_str , tok -> encoding ) ; PyMem_FREE ( tok -> encoding ) ; tok -> encoding = NULL ; r -> n_nchildren = 1 ; r -> n_child = n ; n = r ; } done : PyTokenizer_Free ( tok ) ; if ( n != NULL ) { _PyNode_FinalizeEndPos ( n ) ; } return n ; }
static void set_segmentation_map ( VP8_COMP * cpi , unsigned char * segmentation_map ) { <S2SV_StartBug> vpx_memcpy ( cpi -> segmentation_map , segmentation_map , ( cpi -> common . mb_rows * cpi -> common . mb_cols ) ) ; <S2SV_EndBug> cpi -> mb . e_mbd . update_mb_segmentation_map = 1 ; cpi -> mb . e_mbd . update_mb_segmentation_data = 1 ; }
void vp9_rc_postencode_update_drop_frame ( VP9_COMP * cpi ) { update_buffer_level ( cpi , 0 ) ; <S2SV_StartBug> cpi -> common . last_frame_type = cpi -> common . frame_type ; <S2SV_EndBug> cpi -> rc . frames_since_key ++ ; cpi -> rc . frames_to_key -- ; <S2SV_StartBug> } <S2SV_EndBug>
static Image * ReadSUNImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define RMT_EQUAL_RGB 1 # define RMT_NONE 0 # define RMT_RAW 2 # define RT_STANDARD 1 # define RT_ENCODED 2 # define RT_FORMAT_RGB 3 typedef struct _SUNInfo { unsigned int magic , width , height , depth , length , type , maptype , maplength ; } SUNInfo ; Image * image ; int bit ; MagickBooleanType status ; MagickSizeType number_pixels ; register Quantum * q ; register ssize_t i , x ; register unsigned char * p ; size_t bytes_per_line , extent , height , length ; ssize_t count , y ; SUNInfo sun_info ; unsigned char * sun_data , * sun_pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , "%s" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) ResetMagickMemory ( & sun_info , 0 , sizeof ( sun_info ) ) ; sun_info . magic = ReadBlobMSBLong ( image ) ; do { if ( sun_info . magic != 0x59a66a95 ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; sun_info . width = ReadBlobMSBLong ( image ) ; sun_info . height = ReadBlobMSBLong ( image ) ; sun_info . depth = ReadBlobMSBLong ( image ) ; sun_info . length = ReadBlobMSBLong ( image ) ; sun_info . type = ReadBlobMSBLong ( image ) ; sun_info . maptype = ReadBlobMSBLong ( image ) ; sun_info . maplength = ReadBlobMSBLong ( image ) ; extent = sun_info . height * sun_info . width ; if ( ( sun_info . height != 0 ) && ( sun_info . width != extent / sun_info . height ) ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; if ( ( sun_info . type != RT_STANDARD ) && ( sun_info . type != RT_ENCODED ) && ( sun_info . type != RT_FORMAT_RGB ) ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; if ( ( sun_info . maptype == RMT_NONE ) && ( sun_info . maplength != 0 ) ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; if ( ( sun_info . depth == 0 ) || ( sun_info . depth > 32 ) ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; if ( ( sun_info . maptype != RMT_NONE ) && ( sun_info . maptype != RMT_EQUAL_RGB ) && ( sun_info . maptype != RMT_RAW ) ) ThrowReaderException ( CoderError , "ColormapTypeNotSupported" ) ; image -> columns = sun_info . width ; image -> rows = sun_info . height ; image -> depth = sun_info . depth <= 8 ? sun_info . depth : MAGICKCORE_QUANTUM_DEPTH ; if ( sun_info . depth < 24 ) { size_t one ; image -> colors = sun_info . maplength ; one = 1 ; if ( sun_info . maptype == RMT_NONE ) image -> colors = one << sun_info . depth ; if ( sun_info . maptype == RMT_EQUAL_RGB ) image -> colors = sun_info . maplength / 3 ; if ( AcquireImageColormap ( image , image -> colors , exception ) == MagickFalse ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; } switch ( sun_info . maptype ) { case RMT_NONE : break ; case RMT_EQUAL_RGB : { unsigned char * sun_colormap ; sun_colormap = ( unsigned char * ) AcquireQuantumMemory ( image -> colors , sizeof ( * sun_colormap ) ) ; if ( sun_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; count = ReadBlob ( image , image -> colors , sun_colormap ) ; if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , "UnexpectedEndOfFile" ) ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) image -> colormap [ i ] . red = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ; count = ReadBlob ( image , image -> colors , sun_colormap ) ; if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , "UnexpectedEndOfFile" ) ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) image -> colormap [ i ] . green = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ; count = ReadBlob ( image , image -> colors , sun_colormap ) ; if ( count != ( ssize_t ) image -> colors ) ThrowReaderException ( CorruptImageError , "UnexpectedEndOfFile" ) ; for ( i = 0 ; i < ( ssize_t ) image -> colors ; i ++ ) image -> colormap [ i ] . blue = ( MagickRealType ) ScaleCharToQuantum ( sun_colormap [ i ] ) ; sun_colormap = ( unsigned char * ) RelinquishMagickMemory ( sun_colormap ) ; break ; } case RMT_RAW : { unsigned char * sun_colormap ; sun_colormap = ( unsigned char * ) AcquireQuantumMemory ( sun_info . maplength , sizeof ( * sun_colormap ) ) ; if ( sun_colormap == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; count = ReadBlob ( image , sun_info . maplength , sun_colormap ) ; if ( count != ( ssize_t ) sun_info . maplength ) ThrowReaderException ( CorruptImageError , "UnexpectedEndOfFile" ) ; sun_colormap = ( unsigned char * ) RelinquishMagickMemory ( sun_colormap ) ; break ; } default : ThrowReaderException ( CoderError , "ColormapTypeNotSupported" ) ; } image -> alpha_trait = sun_info . depth == 32 ? BlendPixelTrait : UndefinedPixelTrait ; image -> columns = sun_info . width ; image -> rows = sun_info . height ; if ( image_info -> ping != MagickFalse ) { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; if ( ( sun_info . length * sizeof ( * sun_data ) ) / sizeof ( * sun_data ) != sun_info . length || ! sun_info . length ) <S2SV_StartBug> ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; <S2SV_EndBug> number_pixels = ( MagickSizeType ) image -> columns * image -> rows ; if ( ( sun_info . type != RT_ENCODED ) && ( ( number_pixels * sun_info . depth ) > ( 8 * sun_info . length ) ) ) ThrowReaderException ( CorruptImageError , "ImproperImageHeader" ) ; bytes_per_line = sun_info . width * sun_info . depth ; sun_data = ( unsigned char * ) AcquireQuantumMemory ( ( size_t ) MagickMax ( sun_info . length , bytes_per_line * sun_info . width ) , sizeof ( * sun_data ) ) ; if ( sun_data == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; count = ( ssize_t ) ReadBlob ( image , sun_info . length , sun_data ) ; if ( count != ( ssize_t ) sun_info . length ) ThrowReaderException ( CorruptImageError , "UnableToReadImageData" ) ; height = sun_info . height ; if ( ( height == 0 ) || ( sun_info . width == 0 ) || ( sun_info . depth == 0 ) || ( ( bytes_per_line / sun_info . depth ) != sun_info . width ) ) <S2SV_StartBug> ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; <S2SV_EndBug> bytes_per_line += 15 ; bytes_per_line <<= 1 ; if ( ( bytes_per_line >> 1 ) != ( sun_info . width * sun_info . depth + 15 ) ) <S2SV_StartBug> ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; <S2SV_EndBug> bytes_per_line >>= 4 ; sun_pixels = ( unsigned char * ) AcquireQuantumMemory ( height , bytes_per_line * sizeof ( * sun_pixels ) ) ; if ( sun_pixels == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , "MemoryAllocationFailed" ) ; if ( sun_info . type == RT_ENCODED ) ( void ) DecodeImage ( sun_data , sun_info . length , sun_pixels , bytes_per_line * <S2SV_StartBug> height ) ; <S2SV_EndBug> sun_data = ( unsigned char * ) RelinquishMagickMemory ( sun_data ) ; p = sun_pixels ; if ( sun_info . depth == 1 ) for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 7 ) ; x += 8 ) { for ( bit = 7 ; bit >= 0 ; bit -- ) { SetPixelIndex ( image , ( Quantum ) ( ( * p ) & ( 0x01 << bit ) ? 0x00 : 0x01 ) , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( ( image -> columns % 8 ) != 0 ) { for ( bit = 7 ; bit >= ( int ) ( 8 - ( image -> columns % 8 ) ) ; bit -- ) { SetPixelIndex ( image , ( Quantum ) ( ( * p ) & ( 0x01 << bit ) ? 0x00 : 0x01 ) , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( ( ( ( image -> columns / 8 ) + ( image -> columns % 8 ? 1 : 0 ) ) % 2 ) != 0 ) p ++ ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } else if ( image -> storage_class == PseudoClass ) { if ( bytes_per_line == 0 ) bytes_per_line = image -> columns ; length = image -> rows * ( image -> columns + image -> columns % 2 ) ; if ( ( ( sun_info . type == RT_ENCODED ) && ( length > ( bytes_per_line * image -> rows ) ) ) || ( ( sun_info . type != RT_ENCODED ) && ( length > sun_info . length ) ) ) ThrowReaderException ( CorruptImageError , "UnableToReadImageData" ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelIndex ( image , * p ++ , q ) ; q += GetPixelChannels ( image ) ; } if ( ( image -> columns % 2 ) != 0 ) p ++ ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } else { size_t bytes_per_pixel ; bytes_per_pixel = 3 ; if ( image -> alpha_trait != UndefinedPixelTrait ) bytes_per_pixel ++ ; if ( bytes_per_line == 0 ) bytes_per_line = bytes_per_pixel * image -> columns ; length = image -> rows * ( bytes_per_line + bytes_per_line % 2 ) ; if ( ( ( sun_info . type == RT_ENCODED ) && ( length > ( bytes_per_line * image -> rows ) ) ) || ( ( sun_info . type != RT_ENCODED ) && ( length > sun_info . length ) ) ) ThrowReaderException ( CorruptImageError , "UnableToReadImageData" ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { if ( image -> alpha_trait != UndefinedPixelTrait ) SetPixelAlpha ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; if ( sun_info . type == RT_STANDARD ) { SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; } else { SetPixelRed ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelGreen ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; SetPixelBlue ( image , ScaleCharToQuantum ( * p ++ ) , q ) ; } if ( image -> colors != 0 ) { SetPixelRed ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelRed ( image , q ) ] . red ) , q ) ; SetPixelGreen ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelGreen ( image , q ) ] . green ) , q ) ; SetPixelBlue ( image , ClampToQuantum ( image -> colormap [ ( ssize_t ) GetPixelBlue ( image , q ) ] . blue ) , q ) ; } q += GetPixelChannels ( image ) ; } if ( ( ( bytes_per_pixel * image -> columns ) % 2 ) != 0 ) p ++ ; if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) break ; if ( image -> previous == ( Image * ) NULL ) { status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , image -> rows ) ; if ( status == MagickFalse ) break ; } } } if ( image -> storage_class == PseudoClass ) ( void ) SyncImage ( image , exception ) ; sun_pixels = ( unsigned char * ) RelinquishMagickMemory ( sun_pixels ) ; if ( EOFBlob ( image ) != MagickFalse ) { ThrowFileException ( exception , CorruptImageError , "UnexpectedEndOfFile" , image -> filename ) ; break ; } if ( image_info -> number_scenes != 0 ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; sun_info . magic = ReadBlobMSBLong ( image ) ; if ( sun_info . magic == 0x59a66a95 ) { AcquireNextImage ( image_info , image , exception ) ; if ( GetNextImageInList ( image ) == ( Image * ) NULL ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image = SyncNextImageInList ( image ) ; status = SetImageProgress ( image , LoadImagesTag , TellBlob ( image ) , GetBlobSize ( image ) ) ; if ( status == MagickFalse ) break ; } } while ( sun_info . magic == 0x59a66a95 ) ; ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
static ssize_t pipe_read ( struct kiocb * iocb , const struct iovec * _iov , unsigned long nr_segs , loff_t pos ) { struct file * filp = iocb -> ki_filp ; struct pipe_inode_info * pipe = filp -> private_data ; int do_wakeup ; ssize_t ret ; struct iovec * iov = ( struct iovec * ) _iov ; size_t total_len ; <S2SV_StartBug> total_len = iov_length ( iov , nr_segs ) ; <S2SV_EndBug> if ( unlikely ( total_len == 0 ) ) <S2SV_StartBug> return 0 ; <S2SV_EndBug> do_wakeup = 0 ; ret = 0 ; __pipe_lock ( pipe ) ; for ( ; ; ) { int bufs = pipe -> nrbufs ; if ( bufs ) { int curbuf = pipe -> curbuf ; struct pipe_buffer * buf = pipe -> bufs + curbuf ; const struct pipe_buf_operations * ops = buf -> ops ; <S2SV_StartBug> void * addr ; <S2SV_EndBug> <S2SV_StartBug> size_t chars = buf -> len ; <S2SV_EndBug> <S2SV_StartBug> int error , atomic ; <S2SV_EndBug> if ( chars > total_len ) chars = total_len ; error = ops -> confirm ( pipe , buf ) ; if ( error ) { if ( ! ret ) ret = error ; break ; } <S2SV_StartBug> atomic = ! iov_fault_in_pages_write ( iov , chars ) ; <S2SV_EndBug> redo : if ( atomic ) addr = kmap_atomic ( buf -> page ) ; else addr = kmap ( buf -> page ) ; error = pipe_iov_copy_to_user ( iov , addr + buf -> offset , chars , atomic ) ; if ( atomic ) kunmap_atomic ( addr ) ; else kunmap ( buf -> page ) ; if ( unlikely ( error ) ) { if ( atomic ) { atomic = 0 ; goto redo ; } if ( ! ret ) ret = error ; break ; } ret += chars ; buf -> offset += chars ; buf -> len -= chars ; if ( buf -> flags & PIPE_BUF_FLAG_PACKET ) { total_len = chars ; buf -> len = 0 ; } if ( ! buf -> len ) { buf -> ops = NULL ; ops -> release ( pipe , buf ) ; curbuf = ( curbuf + 1 ) & ( pipe -> buffers - 1 ) ; pipe -> curbuf = curbuf ; pipe -> nrbufs = -- bufs ; do_wakeup = 1 ; } total_len -= chars ; if ( ! total_len ) break ; } if ( bufs ) continue ; if ( ! pipe -> writers ) break ; if ( ! pipe -> waiting_writers ) { if ( ret ) break ; if ( filp -> f_flags & O_NONBLOCK ) { ret = - EAGAIN ; break ; } } if ( signal_pending ( current ) ) { if ( ! ret ) ret = - ERESTARTSYS ; break ; } if ( do_wakeup ) { wake_up_interruptible_sync_poll ( & pipe -> wait , POLLOUT | POLLWRNORM ) ; kill_fasync ( & pipe -> fasync_writers , SIGIO , POLL_OUT ) ; } pipe_wait ( pipe ) ; } __pipe_unlock ( pipe ) ; if ( do_wakeup ) { wake_up_interruptible_sync_poll ( & pipe -> wait , POLLOUT | POLLWRNORM ) ; kill_fasync ( & pipe -> fasync_writers , SIGIO , POLL_OUT ) ; } if ( ret > 0 ) file_accessed ( filp ) ; return ret ; }
stf_status ikev2parent_inI1outR1 ( struct msg_digest * md ) { struct state * st = md -> st ; lset_t policy = POLICY_IKEV2_ALLOW ; struct connection * c = find_host_connection ( & md -> iface -> ip_addr , md -> iface -> port , & md -> sender , md -> sender_port , POLICY_IKEV2_ALLOW ) ; # if 0 if ( c == NULL ) { pb_stream pre_sa_pbs = sa_pd -> pbs ; policy = preparse_isakmp_sa_body ( & pre_sa_pbs ) ; c = find_host_connection ( & md -> iface -> ip_addr , pluto_port , ( ip_address * ) NULL , md -> sender_port , policy ) ; } # endif if ( c == NULL ) { { struct connection * d ; d = find_host_connection ( & md -> iface -> ip_addr , pluto_port , ( ip_address * ) NULL , md -> sender_port , policy ) ; for ( ; d != NULL ; d = d -> hp_next ) { if ( d -> kind == CK_GROUP ) { } else { if ( d -> kind == CK_TEMPLATE && ! ( d -> policy & POLICY_OPPO ) ) { c = d ; break ; } if ( addrinsubnet ( & md -> sender , & d -> spd . that . client ) && ( c == NULL || ! subnetinsubnet ( & c -> spd . that . client , & d -> spd . that . client ) ) ) c = d ; } } } if ( c == NULL ) { loglog ( RC_LOG_SERIOUS , "initial<S2SV_blank>parent<S2SV_blank>SA<S2SV_blank>message<S2SV_blank>received<S2SV_blank>on<S2SV_blank>%s:%u" "<S2SV_blank>but<S2SV_blank>no<S2SV_blank>connection<S2SV_blank>has<S2SV_blank>been<S2SV_blank>authorized%s%s" , ip_str ( & md -> iface -> ip_addr ) , ntohs ( portof ( & md -> iface -> ip_addr ) ) , ( policy != LEMPTY ) ? "<S2SV_blank>with<S2SV_blank>policy=" : "" , ( policy != LEMPTY ) ? bitnamesof ( sa_policy_bit_names , policy ) : "" ) ; return STF_FAIL + v2N_NO_PROPOSAL_CHOSEN ; } if ( c -> kind != CK_TEMPLATE ) { loglog ( RC_LOG_SERIOUS , "initial<S2SV_blank>parent<S2SV_blank>SA<S2SV_blank>message<S2SV_blank>received<S2SV_blank>on<S2SV_blank>%s:%u" "<S2SV_blank>but<S2SV_blank>\\"%s\\"<S2SV_blank>forbids<S2SV_blank>connection" , ip_str ( & md -> iface -> ip_addr ) , pluto_port , c -> name ) ; return STF_FAIL + v2N_NO_PROPOSAL_CHOSEN ; } c = rw_instantiate ( c , & md -> sender , NULL , NULL ) ; } else { if ( ( c -> kind == CK_TEMPLATE ) && c -> spd . that . virt ) { DBG ( DBG_CONTROL , DBG_log ( "local<S2SV_blank>endpoint<S2SV_blank>has<S2SV_blank>virt<S2SV_blank>(vnet/vhost)<S2SV_blank>set<S2SV_blank>without<S2SV_blank>wildcards<S2SV_blank>-<S2SV_blank>needs<S2SV_blank>instantiation" ) ) ; c = rw_instantiate ( c , & md -> sender , NULL , NULL ) ; } else if ( ( c -> kind == CK_TEMPLATE ) && ( c -> policy & POLICY_IKEV2_ALLOW_NARROWING ) ) { DBG ( DBG_CONTROL , DBG_log ( "local<S2SV_blank>endpoint<S2SV_blank>has<S2SV_blank>narrowing=yes<S2SV_blank>-<S2SV_blank>needs<S2SV_blank>instantiation" ) ) ; c = rw_instantiate ( c , & md -> sender , NULL , NULL ) ; } } DBG_log ( "found<S2SV_blank>connection:<S2SV_blank>%s\\n" , c ? c -> name : "<none>" ) ; if ( ! st ) { st = new_state ( ) ; memcpy ( st -> st_icookie , md -> hdr . isa_icookie , COOKIE_SIZE ) ; get_cookie ( FALSE , st -> st_rcookie , COOKIE_SIZE , & md -> sender ) ; initialize_new_state ( st , c , policy , 0 , NULL_FD , pcim_stranger_crypto ) ; st -> st_ikev2 = TRUE ; change_state ( st , STATE_PARENT_R1 ) ; st -> st_msgid_lastack = INVALID_MSGID ; st -> st_msgid_nextuse = 0 ; md -> st = st ; md -> from_state = STATE_IKEv2_BASE ; } if ( force_busy == TRUE ) { u_char dcookie [ SHA1_DIGEST_SIZE ] ; chunk_t dc ; ikev2_get_dcookie ( dcookie , st -> st_ni , & md -> sender , st -> st_icookie ) ; dc . ptr = dcookie ; dc . len = SHA1_DIGEST_SIZE ; if ( md -> chain [ ISAKMP_NEXT_v2KE ] && md -> chain [ ISAKMP_NEXT_v2N ] && ( md -> chain [ ISAKMP_NEXT_v2N ] -> payload . v2n . isan_type == v2N_COOKIE ) ) { u_int8_t spisize ; const pb_stream * dc_pbs ; chunk_t blob ; DBG ( DBG_CONTROLMORE , DBG_log ( "received<S2SV_blank>a<S2SV_blank>DOS<S2SV_blank>cookie<S2SV_blank>in<S2SV_blank>I1<S2SV_blank>verify<S2SV_blank>it" ) ) ; spisize = md -> chain [ ISAKMP_NEXT_v2N ] -> payload . v2n . isan_spisize ; dc_pbs = & md -> chain [ ISAKMP_NEXT_v2N ] -> pbs ; blob . ptr = dc_pbs -> cur + spisize ; blob . len = pbs_left ( dc_pbs ) - spisize ; DBG ( DBG_CONTROLMORE , DBG_dump_chunk ( "dcookie<S2SV_blank>received<S2SV_blank>in<S2SV_blank>I1<S2SV_blank>Packet" , blob ) ; DBG_dump ( "dcookie<S2SV_blank>computed" , dcookie , SHA1_DIGEST_SIZE ) ) ; if ( memcmp ( blob . ptr , dcookie , SHA1_DIGEST_SIZE ) != 0 ) { libreswan_log ( "mismatch<S2SV_blank>in<S2SV_blank>DOS<S2SV_blank>v2N_COOKIE,send<S2SV_blank>a<S2SV_blank>new<S2SV_blank>one" ) ; SEND_NOTIFICATION_AA ( v2N_COOKIE , & dc ) ; return STF_FAIL + v2N_INVALID_IKE_SPI ; } DBG ( DBG_CONTROLMORE , DBG_log ( "dcookie<S2SV_blank>received<S2SV_blank>match<S2SV_blank>with<S2SV_blank>computed<S2SV_blank>one" ) ) ; } else { DBG ( DBG_CONTROLMORE , DBG_log ( "busy<S2SV_blank>mode<S2SV_blank>on.<S2SV_blank>receieved<S2SV_blank>I1<S2SV_blank>without<S2SV_blank>a<S2SV_blank>valid<S2SV_blank>dcookie" ) ; DBG_log ( "send<S2SV_blank>a<S2SV_blank>dcookie<S2SV_blank>and<S2SV_blank>forget<S2SV_blank>this<S2SV_blank>state" ) ) ; SEND_NOTIFICATION_AA ( v2N_COOKIE , & dc ) ; return STF_FAIL ; } } else { DBG ( DBG_CONTROLMORE , DBG_log ( "will<S2SV_blank>not<S2SV_blank>send/process<S2SV_blank>a<S2SV_blank>dcookie" ) ) ; } { struct ikev2_ke * ke ; <S2SV_StartBug> ke = & md -> chain [ ISAKMP_NEXT_v2KE ] -> payload . v2ke ; <S2SV_EndBug> st -> st_oakley . group = lookup_group ( ke -> isak_group ) ; if ( st -> st_oakley . group == NULL ) { char fromname [ ADDRTOT_BUF ] ; addrtot ( & md -> sender , 0 , fromname , ADDRTOT_BUF ) ; <S2SV_StartBug> libreswan_log ( <S2SV_EndBug> "rejecting<S2SV_blank>I1<S2SV_blank>from<S2SV_blank>%s:%u,<S2SV_blank>invalid<S2SV_blank>DH<S2SV_blank>group=%u" , fromname , md -> sender_port , ke -> isak_group ) ; <S2SV_StartBug> return v2N_INVALID_KE_PAYLOAD ; <S2SV_EndBug> } } { struct ke_continuation * ke = alloc_thing ( struct ke_continuation , "ikev2_inI1outR1<S2SV_blank>KE" ) ; stf_status e ; ke -> md = md ; set_suspended ( st , ke -> md ) ; if ( ! st -> st_sec_in_use ) { pcrc_init ( & ke -> ke_pcrc ) ; ke -> ke_pcrc . pcrc_func = ikev2_parent_inI1outR1_continue ; e = build_ke ( & ke -> ke_pcrc , st , st -> st_oakley . group , pcim_stranger_crypto ) ; if ( e != STF_SUSPEND && e != STF_INLINE ) { loglog ( RC_CRYPTOFAILED , "system<S2SV_blank>too<S2SV_blank>busy" ) ; delete_state ( st ) ; } } else { e = ikev2_parent_inI1outR1_tail ( ( struct pluto_crypto_req_cont * ) ke , NULL ) ; } reset_globals ( ) ; return e ; } }
static int logi_dj_ll_raw_request ( struct hid_device * hid , unsigned char reportnum , __u8 * buf , size_t count , unsigned char report_type , int reqtype ) { struct dj_device * djdev = hid -> driver_data ; struct dj_receiver_dev * djrcv_dev = djdev -> dj_receiver_dev ; u8 * out_buf ; int ret ; if ( buf [ 0 ] != REPORT_TYPE_LEDS ) return - EINVAL ; out_buf = kzalloc ( DJREPORT_SHORT_LENGTH , GFP_ATOMIC ) ; if ( ! out_buf ) return - ENOMEM ; <S2SV_StartBug> if ( count < DJREPORT_SHORT_LENGTH - 2 ) <S2SV_EndBug> count = DJREPORT_SHORT_LENGTH - 2 ; out_buf [ 0 ] = REPORT_ID_DJ_SHORT ; out_buf [ 1 ] = djdev -> device_index ; memcpy ( out_buf + 2 , buf , count ) ; ret = hid_hw_raw_request ( djrcv_dev -> hdev , out_buf [ 0 ] , out_buf , DJREPORT_SHORT_LENGTH , report_type , reqtype ) ; kfree ( out_buf ) ; return ret ; }
static void perf_event_interrupt ( struct pt_regs * regs ) { int i ; struct cpu_hw_events * cpuhw = & __get_cpu_var ( cpu_hw_events ) ; struct perf_event * event ; unsigned long val ; int found = 0 ; int nmi ; nmi = perf_intr_is_nmi ( regs ) ; if ( nmi ) nmi_enter ( ) ; else irq_enter ( ) ; for ( i = 0 ; i < ppmu -> n_counter ; ++ i ) { event = cpuhw -> event [ i ] ; val = read_pmc ( i ) ; if ( ( int ) val < 0 ) { if ( event ) { found = 1 ; <S2SV_StartBug> record_and_restart ( event , val , regs , nmi ) ; <S2SV_EndBug> } else { write_pmc ( i , 0 ) ; } } } mtmsr ( mfmsr ( ) | MSR_PMM ) ; mtpmr ( PMRN_PMGC0 , PMGC0_PMIE | PMGC0_FCECE ) ; isync ( ) ; if ( nmi ) nmi_exit ( ) ; else irq_exit ( ) ; }
int ipc_addid ( struct ipc_ids * ids , struct kern_ipc_perm * new , int size ) { kuid_t euid ; kgid_t egid ; int id ; int next_id = ids -> next_id ; if ( size > IPCMNI ) size = IPCMNI ; if ( ids -> in_use >= size ) return - ENOSPC ; idr_preload ( GFP_KERNEL ) ; spin_lock_init ( & new -> lock ) ; new -> deleted = false ; rcu_read_lock ( ) ; spin_lock ( & new -> lock ) ; <S2SV_StartBug> id = idr_alloc ( & ids -> ipcs_idr , new , <S2SV_EndBug> ( next_id < 0 ) ? 0 : ipcid_to_idx ( next_id ) , 0 , GFP_NOWAIT ) ; idr_preload_end ( ) ; if ( id < 0 ) { spin_unlock ( & new -> lock ) ; rcu_read_unlock ( ) ; return id ; } ids -> in_use ++ ; <S2SV_StartBug> current_euid_egid ( & euid , & egid ) ; <S2SV_EndBug> new -> cuid = new -> uid = euid ; new -> gid = new -> cgid = egid ; if ( next_id < 0 ) { new -> seq = ids -> seq ++ ; if ( ids -> seq > IPCID_SEQ_MAX ) ids -> seq = 0 ; } else { new -> seq = ipcid_to_seqx ( next_id ) ; ids -> next_id = - 1 ; } new -> id = ipc_buildid ( id , new -> seq ) ; return id ; }
bool_t xdr_krb5_tl_data ( XDR * xdrs , krb5_tl_data * * tl_data_head ) { krb5_tl_data * tl , * tl2 ; bool_t more ; unsigned int len ; switch ( xdrs -> x_op ) { case XDR_FREE : tl = tl2 = * tl_data_head ; while ( tl ) { tl2 = tl -> tl_data_next ; free ( tl -> tl_data_contents ) ; free ( tl ) ; tl = tl2 ; } <S2SV_StartBug> break ; <S2SV_EndBug> case XDR_ENCODE : tl = * tl_data_head ; while ( 1 ) { more = ( tl != NULL ) ; if ( ! xdr_bool ( xdrs , & more ) ) return FALSE ; if ( tl == NULL ) break ; if ( ! xdr_krb5_int16 ( xdrs , & tl -> tl_data_type ) ) return FALSE ; len = tl -> tl_data_length ; if ( ! xdr_bytes ( xdrs , ( char * * ) & tl -> tl_data_contents , & len , ~ 0 ) ) return FALSE ; tl = tl -> tl_data_next ; } break ; case XDR_DECODE : tl = NULL ; while ( 1 ) { if ( ! xdr_bool ( xdrs , & more ) ) return FALSE ; if ( more == FALSE ) break ; tl2 = ( krb5_tl_data * ) malloc ( sizeof ( krb5_tl_data ) ) ; if ( tl2 == NULL ) return FALSE ; memset ( tl2 , 0 , sizeof ( krb5_tl_data ) ) ; if ( ! xdr_krb5_int16 ( xdrs , & tl2 -> tl_data_type ) ) return FALSE ; if ( ! xdr_bytes ( xdrs , ( char * * ) & tl2 -> tl_data_contents , & len , ~ 0 ) ) return FALSE ; tl2 -> tl_data_length = len ; tl2 -> tl_data_next = tl ; tl = tl2 ; } * tl_data_head = tl ; break ; } return TRUE ; }
static void wdm_in_callback ( struct urb * urb ) { struct wdm_device * desc = urb -> context ; int status = urb -> status ; <S2SV_StartBug> spin_lock ( & desc -> iuspin ) ; <S2SV_EndBug> clear_bit ( WDM_RESPONDING , & desc -> flags ) ; if ( status ) { switch ( status ) { case - ENOENT : dev_dbg ( & desc -> intf -> dev , "nonzero<S2SV_blank>urb<S2SV_blank>status<S2SV_blank>received:<S2SV_blank>-ENOENT" ) ; goto skip_error ; case - ECONNRESET : dev_dbg ( & desc -> intf -> dev , "nonzero<S2SV_blank>urb<S2SV_blank>status<S2SV_blank>received:<S2SV_blank>-ECONNRESET" ) ; goto skip_error ; case - ESHUTDOWN : dev_dbg ( & desc -> intf -> dev , "nonzero<S2SV_blank>urb<S2SV_blank>status<S2SV_blank>received:<S2SV_blank>-ESHUTDOWN" ) ; goto skip_error ; case - EPIPE : dev_err ( & desc -> intf -> dev , "nonzero<S2SV_blank>urb<S2SV_blank>status<S2SV_blank>received:<S2SV_blank>-EPIPE\\n" ) ; break ; default : dev_err ( & desc -> intf -> dev , "Unexpected<S2SV_blank>error<S2SV_blank>%d\\n" , status ) ; break ; } } desc -> rerr = status ; <S2SV_StartBug> desc -> reslength = urb -> actual_length ; <S2SV_EndBug> <S2SV_StartBug> memmove ( desc -> ubuf + desc -> length , desc -> inbuf , desc -> reslength ) ; <S2SV_EndBug> desc -> length += desc -> reslength ; skip_error : wake_up ( & desc -> wait ) ; set_bit ( WDM_READ , & desc -> flags ) ; spin_unlock ( & desc -> iuspin ) ; }
int DetectEngineContentInspection ( DetectEngineCtx * de_ctx , DetectEngineThreadCtx * det_ctx , const Signature * s , const SigMatchData * smd , Flow * f , uint8_t * buffer , uint32_t buffer_len , uint32_t stream_start_offset , uint8_t inspection_mode , void * data ) { SCEnter ( ) ; KEYWORD_PROFILING_START ; det_ctx -> inspection_recursion_counter ++ ; if ( det_ctx -> inspection_recursion_counter == de_ctx -> inspection_recursion_limit ) { det_ctx -> discontinue_matching = 1 ; KEYWORD_PROFILING_END ( det_ctx , smd -> type , 0 ) ; SCReturnInt ( 0 ) ; } if ( smd == NULL || buffer_len == 0 ) { KEYWORD_PROFILING_END ( det_ctx , smd -> type , 0 ) ; SCReturnInt ( 0 ) ; } if ( smd -> type == DETECT_CONTENT ) { DetectContentData * cd = ( DetectContentData * ) smd -> ctx ; SCLogDebug ( "inspecting<S2SV_blank>content<S2SV_blank>%" PRIu32 "<S2SV_blank>buffer_len<S2SV_blank>%" PRIu32 , cd -> id , buffer_len ) ; # ifdef DEBUG BUG_ON ( cd -> depth != 0 && cd -> depth <= cd -> offset ) ; # endif uint8_t * found = NULL ; uint32_t offset = 0 ; uint32_t depth = buffer_len ; uint32_t prev_offset = 0 ; uint32_t prev_buffer_offset = det_ctx -> buffer_offset ; do { if ( ( cd -> flags & DETECT_CONTENT_DISTANCE ) || ( cd -> flags & DETECT_CONTENT_WITHIN ) ) { SCLogDebug ( "det_ctx->buffer_offset<S2SV_blank>%" PRIu32 , det_ctx -> buffer_offset ) ; offset = prev_buffer_offset ; depth = buffer_len ; int distance = cd -> distance ; if ( cd -> flags & DETECT_CONTENT_DISTANCE ) { if ( cd -> flags & DETECT_CONTENT_DISTANCE_BE ) { distance = det_ctx -> bj_values [ cd -> distance ] ; } if ( distance < 0 && ( uint32_t ) ( abs ( distance ) ) > offset ) offset = 0 ; else offset += distance ; SCLogDebug ( "cd->distance<S2SV_blank>%" PRIi32 ",<S2SV_blank>offset<S2SV_blank>%" PRIu32 ",<S2SV_blank>depth<S2SV_blank>%" PRIu32 , distance , offset , depth ) ; } if ( cd -> flags & DETECT_CONTENT_WITHIN ) { if ( cd -> flags & DETECT_CONTENT_WITHIN_BE ) { if ( ( int32_t ) depth > ( int32_t ) ( prev_buffer_offset + det_ctx -> bj_values [ cd -> within ] + distance ) ) { depth = prev_buffer_offset + det_ctx -> bj_values [ cd -> within ] + distance ; } } else { if ( ( int32_t ) depth > ( int32_t ) ( prev_buffer_offset + cd -> within + distance ) ) { depth = prev_buffer_offset + cd -> within + distance ; } SCLogDebug ( "cd->within<S2SV_blank>%" PRIi32 ",<S2SV_blank>det_ctx->buffer_offset<S2SV_blank>%" PRIu32 ",<S2SV_blank>depth<S2SV_blank>%" PRIu32 , cd -> within , prev_buffer_offset , depth ) ; } if ( stream_start_offset != 0 && prev_buffer_offset == 0 ) { if ( depth <= stream_start_offset ) { goto no_match ; } else if ( depth >= ( stream_start_offset + buffer_len ) ) { ; } else { depth = depth - stream_start_offset ; } } } if ( cd -> flags & DETECT_CONTENT_DEPTH_BE ) { if ( ( det_ctx -> bj_values [ cd -> depth ] + prev_buffer_offset ) < depth ) { depth = prev_buffer_offset + det_ctx -> bj_values [ cd -> depth ] ; } } else { if ( cd -> depth != 0 ) { if ( ( cd -> depth + prev_buffer_offset ) < depth ) { depth = prev_buffer_offset + cd -> depth ; } SCLogDebug ( "cd->depth<S2SV_blank>%" PRIu32 ",<S2SV_blank>depth<S2SV_blank>%" PRIu32 , cd -> depth , depth ) ; } } if ( cd -> flags & DETECT_CONTENT_OFFSET_BE ) { if ( det_ctx -> bj_values [ cd -> offset ] > offset ) offset = det_ctx -> bj_values [ cd -> offset ] ; } else { if ( cd -> offset > offset ) { offset = cd -> offset ; SCLogDebug ( "setting<S2SV_blank>offset<S2SV_blank>%" PRIu32 , offset ) ; } } } else { if ( cd -> flags & DETECT_CONTENT_DEPTH_BE ) { depth = det_ctx -> bj_values [ cd -> depth ] ; } else { if ( cd -> depth != 0 ) { depth = cd -> depth ; } } if ( stream_start_offset != 0 && cd -> flags & DETECT_CONTENT_DEPTH ) { if ( depth <= stream_start_offset ) { goto no_match ; } else if ( depth >= ( stream_start_offset + buffer_len ) ) { ; } else { depth = depth - stream_start_offset ; } } if ( cd -> flags & DETECT_CONTENT_OFFSET_BE ) offset = det_ctx -> bj_values [ cd -> offset ] ; else offset = cd -> offset ; prev_buffer_offset = 0 ; } SCLogDebug ( "offset<S2SV_blank>%" PRIu32 ",<S2SV_blank>prev_offset<S2SV_blank>%" PRIu32 , offset , prev_offset ) ; if ( prev_offset != 0 ) offset = prev_offset ; SCLogDebug ( "offset<S2SV_blank>%" PRIu32 ",<S2SV_blank>depth<S2SV_blank>%" PRIu32 , offset , depth ) ; if ( depth > buffer_len ) depth = buffer_len ; if ( offset > depth || depth == 0 ) { if ( cd -> flags & DETECT_CONTENT_NEGATED ) { goto match ; } else { goto no_match ; } } uint8_t * sbuffer = buffer + offset ; uint32_t sbuffer_len = depth - offset ; uint32_t match_offset = 0 ; SCLogDebug ( "sbuffer_len<S2SV_blank>%" PRIu32 , sbuffer_len ) ; # ifdef DEBUG BUG_ON ( sbuffer_len > buffer_len ) ; # endif found = SpmScan ( cd -> spm_ctx , det_ctx -> spm_thread_ctx , sbuffer , sbuffer_len ) ; SCLogDebug ( "found<S2SV_blank>%p<S2SV_blank>cd<S2SV_blank>negated<S2SV_blank>%s" , found , cd -> flags & DETECT_CONTENT_NEGATED ? "true" : "false" ) ; if ( found == NULL && ! ( cd -> flags & DETECT_CONTENT_NEGATED ) ) { <S2SV_StartBug> goto no_match ; <S2SV_EndBug> } else if ( found == NULL && ( cd -> flags & DETECT_CONTENT_NEGATED ) ) { goto match ; } else if ( found != NULL && ( cd -> flags & DETECT_CONTENT_NEGATED ) ) { SCLogDebug ( "content<S2SV_blank>%" PRIu32 "<S2SV_blank>matched<S2SV_blank>at<S2SV_blank>offset<S2SV_blank>%" PRIu32 ",<S2SV_blank>but<S2SV_blank>negated<S2SV_blank>so<S2SV_blank>no<S2SV_blank>match" , cd -> id , match_offset ) ; if ( DETECT_CONTENT_IS_SINGLE ( cd ) ) det_ctx -> discontinue_matching = 1 ; goto no_match ; } else { match_offset = ( uint32_t ) ( ( found - buffer ) + cd -> content_len ) ; SCLogDebug ( "content<S2SV_blank>%" PRIu32 "<S2SV_blank>matched<S2SV_blank>at<S2SV_blank>offset<S2SV_blank>%" PRIu32 "" , cd -> id , match_offset ) ; det_ctx -> buffer_offset = match_offset ; if ( cd -> flags & DETECT_CONTENT_REPLACE ) { if ( inspection_mode == DETECT_ENGINE_CONTENT_INSPECTION_MODE_PAYLOAD ) { det_ctx -> replist = DetectReplaceAddToList ( det_ctx -> replist , found , cd ) ; } else { SCLogWarning ( SC_ERR_INVALID_VALUE , "Can\'t<S2SV_blank>modify<S2SV_blank>payload<S2SV_blank>without<S2SV_blank>packet" ) ; } } <S2SV_StartBug> if ( ! ( cd -> flags & DETECT_CONTENT_RELATIVE_NEXT ) ) { <S2SV_EndBug> SCLogDebug ( "no<S2SV_blank>relative<S2SV_blank>match<S2SV_blank>coming<S2SV_blank>up,<S2SV_blank>so<S2SV_blank>this<S2SV_blank>is<S2SV_blank>a<S2SV_blank>match" ) ; goto match ; } if ( smd -> is_last ) { goto no_match ; } SCLogDebug ( "content<S2SV_blank>%" PRIu32 , cd -> id ) ; KEYWORD_PROFILING_END ( det_ctx , smd -> type , 1 ) ; int r = DetectEngineContentInspection ( de_ctx , det_ctx , s , smd + 1 , f , buffer , buffer_len , stream_start_offset , inspection_mode , data ) ; if ( r == 1 ) { SCReturnInt ( 1 ) ; } <S2SV_StartBug> if ( det_ctx -> discontinue_matching ) <S2SV_EndBug> goto no_match ; prev_offset = ( match_offset - ( cd -> content_len - 1 ) ) ; SCLogDebug ( "trying<S2SV_blank>to<S2SV_blank>see<S2SV_blank>if<S2SV_blank>there<S2SV_blank>is<S2SV_blank>another<S2SV_blank>match<S2SV_blank>after<S2SV_blank>prev_offset<S2SV_blank>%" PRIu32 , prev_offset ) ; } } while ( 1 ) ; } else if ( smd -> type == DETECT_ISDATAAT ) { SCLogDebug ( "inspecting<S2SV_blank>isdataat" ) ; DetectIsdataatData * id = ( DetectIsdataatData * ) smd -> ctx ; if ( id -> flags & ISDATAAT_RELATIVE ) { if ( det_ctx -> buffer_offset + id -> dataat > buffer_len ) { SCLogDebug ( "det_ctx->buffer_offset<S2SV_blank>+<S2SV_blank>id->dataat<S2SV_blank>%" PRIu32 "<S2SV_blank>><S2SV_blank>%" PRIu32 , det_ctx -> buffer_offset + id -> dataat , buffer_len ) ; if ( id -> flags & ISDATAAT_NEGATED ) goto match ; goto no_match ; } else { SCLogDebug ( "relative<S2SV_blank>isdataat<S2SV_blank>match" ) ; if ( id -> flags & ISDATAAT_NEGATED ) goto no_match ; goto match ; } } else { if ( id -> dataat < buffer_len ) { SCLogDebug ( "absolute<S2SV_blank>isdataat<S2SV_blank>match" ) ; if ( id -> flags & ISDATAAT_NEGATED ) goto no_match ; goto match ; } else { SCLogDebug ( "absolute<S2SV_blank>isdataat<S2SV_blank>mismatch,<S2SV_blank>id->isdataat<S2SV_blank>%" PRIu32 ",<S2SV_blank>buffer_len<S2SV_blank>%" PRIu32 "" , id -> dataat , buffer_len ) ; if ( id -> flags & ISDATAAT_NEGATED ) goto match ; goto no_match ; } } } else if ( smd -> type == DETECT_PCRE ) { SCLogDebug ( "inspecting<S2SV_blank>pcre" ) ; DetectPcreData * pe = ( DetectPcreData * ) smd -> ctx ; uint32_t prev_buffer_offset = det_ctx -> buffer_offset ; uint32_t prev_offset = 0 ; int r = 0 ; det_ctx -> pcre_match_start_offset = 0 ; do { Packet * p = NULL ; if ( inspection_mode == DETECT_ENGINE_CONTENT_INSPECTION_MODE_PAYLOAD ) p = ( Packet * ) data ; r = DetectPcrePayloadMatch ( det_ctx , s , smd , p , f , buffer , buffer_len ) ; if ( r == 0 ) { goto no_match ; } if ( ! ( pe -> flags & DETECT_PCRE_RELATIVE_NEXT ) ) { SCLogDebug ( "no<S2SV_blank>relative<S2SV_blank>match<S2SV_blank>coming<S2SV_blank>up,<S2SV_blank>so<S2SV_blank>this<S2SV_blank>is<S2SV_blank>a<S2SV_blank>match" ) ; goto match ; } KEYWORD_PROFILING_END ( det_ctx , smd -> type , 1 ) ; prev_offset = det_ctx -> pcre_match_start_offset ; r = DetectEngineContentInspection ( de_ctx , det_ctx , s , smd + 1 , f , buffer , buffer_len , stream_start_offset , inspection_mode , data ) ; if ( r == 1 ) { SCReturnInt ( 1 ) ; } if ( det_ctx -> discontinue_matching ) goto no_match ; det_ctx -> buffer_offset = prev_buffer_offset ; det_ctx -> pcre_match_start_offset = prev_offset ; } while ( 1 ) ; } else if ( smd -> type == DETECT_BYTETEST ) { DetectBytetestData * btd = ( DetectBytetestData * ) smd -> ctx ; uint8_t flags = btd -> flags ; int32_t offset = btd -> offset ; uint64_t value = btd -> value ; if ( flags & DETECT_BYTETEST_OFFSET_BE ) { offset = det_ctx -> bj_values [ offset ] ; } if ( flags & DETECT_BYTETEST_VALUE_BE ) { value = det_ctx -> bj_values [ value ] ; } if ( flags & DETECT_BYTETEST_DCE && data != NULL ) { DCERPCState * dcerpc_state = ( DCERPCState * ) data ; flags |= ( ( dcerpc_state -> dcerpc . dcerpchdr . packed_drep [ 0 ] & 0x10 ) ? DETECT_BYTETEST_LITTLE : 0 ) ; } if ( DetectBytetestDoMatch ( det_ctx , s , smd -> ctx , buffer , buffer_len , flags , offset , value ) != 1 ) { goto no_match ; } goto match ; } else if ( smd -> type == DETECT_BYTEJUMP ) { DetectBytejumpData * bjd = ( DetectBytejumpData * ) smd -> ctx ; uint8_t flags = bjd -> flags ; int32_t offset = bjd -> offset ; if ( flags & DETECT_BYTEJUMP_OFFSET_BE ) { offset = det_ctx -> bj_values [ offset ] ; } if ( flags & DETECT_BYTEJUMP_DCE && data != NULL ) { DCERPCState * dcerpc_state = ( DCERPCState * ) data ; flags |= ( ( dcerpc_state -> dcerpc . dcerpchdr . packed_drep [ 0 ] & 0x10 ) ? DETECT_BYTEJUMP_LITTLE : 0 ) ; } if ( DetectBytejumpDoMatch ( det_ctx , s , smd -> ctx , buffer , buffer_len , flags , offset ) != 1 ) { goto no_match ; } goto match ; } else if ( smd -> type == DETECT_BYTE_EXTRACT ) { DetectByteExtractData * bed = ( DetectByteExtractData * ) smd -> ctx ; uint8_t endian = bed -> endian ; if ( ( bed -> flags & DETECT_BYTE_EXTRACT_FLAG_ENDIAN ) && endian == DETECT_BYTE_EXTRACT_ENDIAN_DCE && data != NULL ) { DCERPCState * dcerpc_state = ( DCERPCState * ) data ; endian |= ( ( dcerpc_state -> dcerpc . dcerpchdr . packed_drep [ 0 ] == 0x10 ) ? DETECT_BYTE_EXTRACT_ENDIAN_LITTLE : DETECT_BYTE_EXTRACT_ENDIAN_BIG ) ; } if ( DetectByteExtractDoMatch ( det_ctx , smd , s , buffer , buffer_len , & det_ctx -> bj_values [ bed -> local_id ] , endian ) != 1 ) { goto no_match ; } goto match ; } else if ( smd -> type == DETECT_AL_URILEN ) { SCLogDebug ( "inspecting<S2SV_blank>uri<S2SV_blank>len" ) ; int r = 0 ; DetectUrilenData * urilend = ( DetectUrilenData * ) smd -> ctx ; switch ( urilend -> mode ) { case DETECT_URILEN_EQ : if ( buffer_len == urilend -> urilen1 ) r = 1 ; break ; case DETECT_URILEN_LT : if ( buffer_len < urilend -> urilen1 ) r = 1 ; break ; case DETECT_URILEN_GT : if ( buffer_len > urilend -> urilen1 ) r = 1 ; break ; case DETECT_URILEN_RA : if ( buffer_len > urilend -> urilen1 && buffer_len < urilend -> urilen2 ) { r = 1 ; } break ; } if ( r == 1 ) { goto match ; } det_ctx -> discontinue_matching = 0 ; goto no_match ; # ifdef HAVE_LUA } else if ( smd -> type == DETECT_LUA ) { SCLogDebug ( "lua<S2SV_blank>starting" ) ; if ( DetectLuaMatchBuffer ( det_ctx , s , smd , buffer , buffer_len , det_ctx -> buffer_offset , f ) != 1 ) { SCLogDebug ( "lua<S2SV_blank>no_match" ) ; goto no_match ; } SCLogDebug ( "lua<S2SV_blank>match" ) ; goto match ; # endif } else if ( smd -> type == DETECT_BASE64_DECODE ) { if ( DetectBase64DecodeDoMatch ( det_ctx , s , smd , buffer , buffer_len ) ) { if ( s -> sm_arrays [ DETECT_SM_LIST_BASE64_DATA ] != NULL ) { KEYWORD_PROFILING_END ( det_ctx , smd -> type , 1 ) ; if ( DetectBase64DataDoMatch ( de_ctx , det_ctx , s , f ) ) { goto final_match ; } } } } else { SCLogDebug ( "sm->type<S2SV_blank>%u" , smd -> type ) ; # ifdef DEBUG BUG_ON ( 1 ) ; # endif } no_match : KEYWORD_PROFILING_END ( det_ctx , smd -> type , 0 ) ; SCReturnInt ( 0 ) ; match : if ( ! smd -> is_last ) { KEYWORD_PROFILING_END ( det_ctx , smd -> type , 1 ) ; int r = DetectEngineContentInspection ( de_ctx , det_ctx , s , smd + 1 , f , buffer , buffer_len , stream_start_offset , inspection_mode , data ) ; SCReturnInt ( r ) ; } final_match : KEYWORD_PROFILING_END ( det_ctx , smd -> type , 1 ) ; SCReturnInt ( 1 ) ; }
static void command_timed_out ( UNUSED_ATTR void * context ) { pthread_mutex_lock ( & commands_pending_response_lock ) ; if ( list_is_empty ( commands_pending_response ) ) { LOG_ERROR ( "%s<S2SV_blank>with<S2SV_blank>no<S2SV_blank>commands<S2SV_blank>pending<S2SV_blank>response" , __func__ ) ; } else { waiting_command_t * wait_entry = list_front ( commands_pending_response ) ; pthread_mutex_unlock ( & commands_pending_response_lock ) ; LOG_ERROR ( "%s<S2SV_blank>hci<S2SV_blank>layer<S2SV_blank>timeout<S2SV_blank>waiting<S2SV_blank>for<S2SV_blank>response<S2SV_blank>to<S2SV_blank>a<S2SV_blank>command.<S2SV_blank>opcode:<S2SV_blank>0x%x" , __func__ , wait_entry -> opcode ) ; } LOG_ERROR ( "%s<S2SV_blank>restarting<S2SV_blank>the<S2SV_blank>bluetooth<S2SV_blank>process." , __func__ ) ; <S2SV_StartBug> usleep ( 10000 ) ; <S2SV_EndBug> kill ( getpid ( ) , SIGKILL ) ; }
static int trusted_update ( struct key * key , struct key_preparsed_payload * prep ) { <S2SV_StartBug> struct trusted_key_payload * p = key -> payload . data [ 0 ] ; <S2SV_EndBug> <S2SV_StartBug> struct trusted_key_payload * new_p ; <S2SV_EndBug> struct trusted_key_options * new_o ; size_t datalen = prep -> datalen ; char * datablob ; int ret = 0 ; if ( ! p -> migratable ) return - EPERM ; if ( datalen <= 0 || datalen > 32767 || ! prep -> data ) return - EINVAL ; datablob = kmalloc ( datalen + 1 , GFP_KERNEL ) ; if ( ! datablob ) return - ENOMEM ; new_o = trusted_options_alloc ( ) ; if ( ! new_o ) { ret = - ENOMEM ; goto out ; } new_p = trusted_payload_alloc ( key ) ; if ( ! new_p ) { ret = - ENOMEM ; goto out ; } memcpy ( datablob , prep -> data , datalen ) ; datablob [ datalen ] = '\\0' ; ret = datablob_parse ( datablob , new_p , new_o ) ; if ( ret != Opt_update ) { ret = - EINVAL ; kfree ( new_p ) ; goto out ; } if ( ! new_o -> keyhandle ) { ret = - EINVAL ; kfree ( new_p ) ; goto out ; } new_p -> migratable = p -> migratable ; new_p -> key_len = p -> key_len ; memcpy ( new_p -> key , p -> key , p -> key_len ) ; dump_payload ( p ) ; dump_payload ( new_p ) ; ret = key_seal ( new_p , new_o ) ; if ( ret < 0 ) { pr_info ( "trusted_key:<S2SV_blank>key_seal<S2SV_blank>failed<S2SV_blank>(%d)\\n" , ret ) ; kfree ( new_p ) ; goto out ; } if ( new_o -> pcrlock ) { ret = pcrlock ( new_o -> pcrlock ) ; if ( ret < 0 ) { pr_info ( "trusted_key:<S2SV_blank>pcrlock<S2SV_blank>failed<S2SV_blank>(%d)\\n" , ret ) ; kfree ( new_p ) ; goto out ; } } rcu_assign_keypointer ( key , new_p ) ; call_rcu ( & p -> rcu , trusted_rcu_free ) ; out : kfree ( datablob ) ; kfree ( new_o ) ; return ret ; }
bool_t xdr_nullstring ( XDR * xdrs , char * * objp ) { u_int size ; if ( xdrs -> x_op == XDR_ENCODE ) { if ( * objp == NULL ) size = 0 ; else size = strlen ( * objp ) + 1 ; } if ( ! xdr_u_int ( xdrs , & size ) ) { return FALSE ; } switch ( xdrs -> x_op ) { case XDR_DECODE : if ( size == 0 ) { * objp = NULL ; return TRUE ; } else if ( * objp == NULL ) { * objp = ( char * ) mem_alloc ( size ) ; if ( * objp == NULL ) { errno = ENOMEM ; return FALSE ; } } <S2SV_StartBug> return ( xdr_opaque ( xdrs , * objp , size ) ) ; <S2SV_EndBug> case XDR_ENCODE : if ( size != 0 ) return ( xdr_opaque ( xdrs , * objp , size ) ) ; return TRUE ; case XDR_FREE : if ( * objp != NULL ) mem_free ( * objp , size ) ; * objp = NULL ; return TRUE ; } return FALSE ; }
ExprDef * ExprAppendMultiKeysymList ( ExprDef * expr , ExprDef * append ) { unsigned nSyms = darray_size ( expr -> keysym_list . syms ) ; unsigned numEntries = darray_size ( append -> keysym_list . syms ) ; darray_append ( expr -> keysym_list . symsMapIndex , nSyms ) ; darray_append ( expr -> keysym_list . symsNumEntries , numEntries ) ; darray_concat ( expr -> keysym_list . syms , append -> keysym_list . syms ) ; <S2SV_StartBug> FreeStmt ( ( ParseCommon * ) & append ) ; <S2SV_EndBug> return expr ; }
void qedi_dbg_warn ( struct qedi_dbg_ctx * qedi , const char * func , u32 line , const char * fmt , ... ) { va_list va ; <S2SV_StartBug> struct va_format vaf ; <S2SV_EndBug> char nfunc [ 32 ] ; memset ( nfunc , 0 , sizeof ( nfunc ) ) ; memcpy ( nfunc , func , sizeof ( nfunc ) - 1 ) ; va_start ( va , fmt ) ; vaf . fmt = fmt ; vaf . va = & va ; if ( ! ( qedi_dbg_log & QEDI_LOG_WARN ) ) goto ret ; if ( likely ( qedi ) && likely ( qedi -> pdev ) ) pr_warn ( "[%s]:[%s:%d]:%d:<S2SV_blank>%pV" , dev_name ( & qedi -> pdev -> dev ) , <S2SV_StartBug> nfunc , line , qedi -> host_no , & vaf ) ; <S2SV_EndBug> else <S2SV_StartBug> pr_warn ( "[0000:00:00.0]:[%s:%d]:<S2SV_blank>%pV" , nfunc , line , & vaf ) ; <S2SV_EndBug> ret : va_end ( va ) ; }
static int asf_read_marker ( AVFormatContext * s , int64_t size ) { AVIOContext * pb = s -> pb ; ASFContext * asf = s -> priv_data ; int i , count , name_len , ret ; char name [ 1024 ] ; avio_rl64 ( pb ) ; avio_rl64 ( pb ) ; count = avio_rl32 ( pb ) ; avio_rl16 ( pb ) ; name_len = avio_rl16 ( pb ) ; <S2SV_StartBug> for ( i = 0 ; i < name_len ; i ++ ) <S2SV_EndBug> avio_r8 ( pb ) ; for ( i = 0 ; i < count ; i ++ ) { int64_t pres_time ; <S2SV_StartBug> int name_len ; <S2SV_EndBug> avio_rl64 ( pb ) ; pres_time = avio_rl64 ( pb ) ; pres_time -= asf -> hdr . preroll * 10000 ; avio_rl16 ( pb ) ; avio_rl32 ( pb ) ; avio_rl32 ( pb ) ; name_len = avio_rl32 ( pb ) ; if ( ( ret = avio_get_str16le ( pb , name_len * 2 , name , sizeof ( name ) ) ) < name_len ) avio_skip ( pb , name_len - ret ) ; avpriv_new_chapter ( s , i , ( AVRational ) { 1 , 10000000 } , pres_time , AV_NOPTS_VALUE , name ) ; } return 0 ; }
static CURLcode imap_parse_url_path ( struct connectdata * conn ) { struct imap_conn * imapc = & conn -> proto . imapc ; struct SessionHandle * data = conn -> data ; const char * path = data -> state . path ; <S2SV_StartBug> int len ; <S2SV_EndBug> if ( ! * path ) path = "INBOX" ; <S2SV_StartBug> imapc -> mailbox = curl_easy_unescape ( data , path , 0 , & len ) ; <S2SV_EndBug> <S2SV_StartBug> if ( ! imapc -> mailbox ) <S2SV_EndBug> return CURLE_OUT_OF_MEMORY ; return CURLE_OK ; }
int __kvm_set_memory_region ( struct kvm * kvm , struct kvm_userspace_memory_region * mem , int user_alloc ) { int r ; gfn_t base_gfn ; unsigned long npages ; unsigned long i ; struct kvm_memory_slot * memslot ; struct kvm_memory_slot old , new ; struct kvm_memslots * slots , * old_memslots ; r = check_memory_region_flags ( mem ) ; if ( r ) goto out ; r = - EINVAL ; if ( mem -> memory_size & ( PAGE_SIZE - 1 ) ) goto out ; if ( mem -> guest_phys_addr & ( PAGE_SIZE - 1 ) ) goto out ; if ( user_alloc && ( ( mem -> userspace_addr & ( PAGE_SIZE - 1 ) ) || ! access_ok ( VERIFY_WRITE , ( void __user * ) ( unsigned long ) mem -> userspace_addr , mem -> memory_size ) ) ) goto out ; if ( mem -> slot >= KVM_MEM_SLOTS_NUM ) goto out ; if ( mem -> guest_phys_addr + mem -> memory_size < mem -> guest_phys_addr ) goto out ; memslot = id_to_memslot ( kvm -> memslots , mem -> slot ) ; base_gfn = mem -> guest_phys_addr >> PAGE_SHIFT ; npages = mem -> memory_size >> PAGE_SHIFT ; r = - EINVAL ; if ( npages > KVM_MEM_MAX_NR_PAGES ) goto out ; if ( ! npages ) mem -> flags &= ~ KVM_MEM_LOG_DIRTY_PAGES ; new = old = * memslot ; new . id = mem -> slot ; new . base_gfn = base_gfn ; new . npages = npages ; new . flags = mem -> flags ; r = - EINVAL ; if ( npages && old . npages && npages != old . npages ) goto out_free ; r = - EEXIST ; for ( i = 0 ; i < KVM_MEMORY_SLOTS ; ++ i ) { struct kvm_memory_slot * s = & kvm -> memslots -> memslots [ i ] ; if ( s == memslot || ! s -> npages ) continue ; if ( ! ( ( base_gfn + npages <= s -> base_gfn ) || ( base_gfn >= s -> base_gfn + s -> npages ) ) ) goto out_free ; } if ( ! ( new . flags & KVM_MEM_LOG_DIRTY_PAGES ) ) new . dirty_bitmap = NULL ; r = - ENOMEM ; if ( npages && ! old . npages ) { new . user_alloc = user_alloc ; new . userspace_addr = mem -> userspace_addr ; if ( kvm_arch_create_memslot ( & new , npages ) ) goto out_free ; } if ( ( new . flags & KVM_MEM_LOG_DIRTY_PAGES ) && ! new . dirty_bitmap ) { if ( kvm_create_dirty_bitmap ( & new ) < 0 ) goto out_free ; } <S2SV_StartBug> if ( ! npages ) { <S2SV_EndBug> struct kvm_memory_slot * slot ; r = - ENOMEM ; slots = kmemdup ( kvm -> memslots , sizeof ( struct kvm_memslots ) , GFP_KERNEL ) ; if ( ! slots ) goto out_free ; slot = id_to_memslot ( slots , mem -> slot ) ; slot -> flags |= KVM_MEMSLOT_INVALID ; update_memslots ( slots , NULL ) ; old_memslots = kvm -> memslots ; rcu_assign_pointer ( kvm -> memslots , slots ) ; synchronize_srcu_expedited ( & kvm -> srcu ) ; kvm_arch_flush_shadow_memslot ( kvm , slot ) ; kfree ( old_memslots ) ; } r = kvm_arch_prepare_memory_region ( kvm , & new , old , mem , user_alloc ) ; if ( r ) goto out_free ; if ( npages ) { r = kvm_iommu_map_pages ( kvm , & new ) ; if ( r ) goto out_free ; } else kvm_iommu_unmap_pages ( kvm , & old ) ; r = - ENOMEM ; slots = kmemdup ( kvm -> memslots , sizeof ( struct kvm_memslots ) , GFP_KERNEL ) ; if ( ! slots ) goto out_free ; if ( ! npages ) { new . dirty_bitmap = NULL ; memset ( & new . arch , 0 , sizeof ( new . arch ) ) ; } update_memslots ( slots , & new ) ; old_memslots = kvm -> memslots ; rcu_assign_pointer ( kvm -> memslots , slots ) ; synchronize_srcu_expedited ( & kvm -> srcu ) ; kvm_arch_commit_memory_region ( kvm , mem , old , user_alloc ) ; if ( npages && old . base_gfn != mem -> guest_phys_addr >> PAGE_SHIFT ) kvm_arch_flush_shadow_all ( kvm ) ; kvm_free_physmem_slot ( & old , & new ) ; kfree ( old_memslots ) ; return 0 ; out_free : kvm_free_physmem_slot ( & new , & old ) ; out : return r ; }
BOOL transport_accept_nla ( rdpTransport * transport ) { freerdp * instance ; rdpSettings * settings ; if ( transport -> TlsIn == NULL ) transport -> TlsIn = tls_new ( transport -> settings ) ; if ( transport -> TlsOut == NULL ) transport -> TlsOut = transport -> TlsIn ; transport -> layer = TRANSPORT_LAYER_TLS ; transport -> TlsIn -> sockfd = transport -> TcpIn -> sockfd ; if ( tls_accept ( transport -> TlsIn , transport -> settings -> CertificateFile , transport -> settings -> PrivateKeyFile ) != TRUE ) return FALSE ; if ( transport -> settings -> Authentication != TRUE ) return TRUE ; settings = transport -> settings ; instance = ( freerdp * ) settings -> instance ; if ( transport -> credssp == NULL ) transport -> credssp = credssp_new ( instance , transport , settings ) ; if ( credssp_authenticate ( transport -> credssp ) < 0 ) { fprintf ( stderr , "client<S2SV_blank>authentication<S2SV_blank>failure\\n" ) ; credssp_free ( transport -> credssp ) ; <S2SV_StartBug> return FALSE ; <S2SV_EndBug> } return TRUE ; }
static inline int check_entry_size_and_hooks ( struct arpt_entry * e , struct xt_table_info * newinfo , const unsigned char * base , const unsigned char * limit , const unsigned int * hook_entries , const unsigned int * underflows , unsigned int valid_hooks ) { unsigned int h ; int err ; if ( ( unsigned long ) e % __alignof__ ( struct arpt_entry ) != 0 || <S2SV_StartBug> ( unsigned char * ) e + sizeof ( struct arpt_entry ) >= limit ) { <S2SV_EndBug> duprintf ( "Bad<S2SV_blank>offset<S2SV_blank>%p\\n" , e ) ; return - EINVAL ; } if ( e -> next_offset < sizeof ( struct arpt_entry ) + sizeof ( struct xt_entry_target ) ) { duprintf ( "checking:<S2SV_blank>element<S2SV_blank>%p<S2SV_blank>size<S2SV_blank>%u\\n" , e , e -> next_offset ) ; return - EINVAL ; } err = check_entry ( e ) ; if ( err ) return err ; for ( h = 0 ; h < NF_ARP_NUMHOOKS ; h ++ ) { if ( ! ( valid_hooks & ( 1 << h ) ) ) continue ; if ( ( unsigned char * ) e - base == hook_entries [ h ] ) newinfo -> hook_entry [ h ] = hook_entries [ h ] ; if ( ( unsigned char * ) e - base == underflows [ h ] ) { if ( ! check_underflow ( e ) ) { pr_err ( "Underflows<S2SV_blank>must<S2SV_blank>be<S2SV_blank>unconditional<S2SV_blank>and<S2SV_blank>" "use<S2SV_blank>the<S2SV_blank>STANDARD<S2SV_blank>target<S2SV_blank>with<S2SV_blank>" "ACCEPT/DROP\\n" ) ; return - EINVAL ; } newinfo -> underflow [ h ] = underflows [ h ] ; } } e -> counters = ( ( struct xt_counters ) { 0 , 0 } ) ; e -> comefrom = 0 ; return 0 ; }
static void renameColumnFunc ( sqlite3_context * context , int NotUsed , sqlite3_value * * argv ) { sqlite3 * db = sqlite3_context_db_handle ( context ) ; RenameCtx sCtx ; const char * zSql = ( const char * ) sqlite3_value_text ( argv [ 0 ] ) ; const char * zDb = ( const char * ) sqlite3_value_text ( argv [ 3 ] ) ; const char * zTable = ( const char * ) sqlite3_value_text ( argv [ 4 ] ) ; int iCol = sqlite3_value_int ( argv [ 5 ] ) ; const char * zNew = ( const char * ) sqlite3_value_text ( argv [ 6 ] ) ; int bQuote = sqlite3_value_int ( argv [ 7 ] ) ; int bTemp = sqlite3_value_int ( argv [ 8 ] ) ; const char * zOld ; int rc ; Parse sParse ; Walker sWalker ; Index * pIdx ; int i ; Table * pTab ; # ifndef SQLITE_OMIT_AUTHORIZATION sqlite3_xauth xAuth = db -> xAuth ; # endif UNUSED_PARAMETER ( NotUsed ) ; if ( zSql == 0 ) return ; if ( zTable == 0 ) return ; if ( zNew == 0 ) return ; if ( iCol < 0 ) return ; sqlite3BtreeEnterAll ( db ) ; pTab = sqlite3FindTable ( db , zTable , zDb ) ; if ( pTab == 0 || iCol >= pTab -> nCol ) { sqlite3BtreeLeaveAll ( db ) ; return ; } zOld = pTab -> aCol [ iCol ] . zName ; memset ( & sCtx , 0 , sizeof ( sCtx ) ) ; sCtx . iCol = ( ( iCol == pTab -> iPKey ) ? - 1 : iCol ) ; # ifndef SQLITE_OMIT_AUTHORIZATION db -> xAuth = 0 ; # endif rc = renameParseSql ( & sParse , zDb , 0 , db , zSql , bTemp ) ; memset ( & sWalker , 0 , sizeof ( Walker ) ) ; sWalker . pParse = & sParse ; sWalker . xExprCallback = renameColumnExprCb ; sWalker . xSelectCallback = renameColumnSelectCb ; sWalker . u . pRename = & sCtx ; sCtx . pTab = pTab ; if ( rc != SQLITE_OK ) goto renameColumnFunc_done ; if ( sParse . pNewTable ) { Select * pSelect = sParse . pNewTable -> pSelect ; if ( pSelect ) { <S2SV_StartBug> sParse . rc = SQLITE_OK ; <S2SV_EndBug> <S2SV_StartBug> sqlite3SelectPrep ( & sParse , sParse . pNewTable -> pSelect , 0 ) ; <S2SV_EndBug> rc = ( db -> mallocFailed ? SQLITE_NOMEM : sParse . rc ) ; if ( rc == SQLITE_OK ) { sqlite3WalkSelect ( & sWalker , pSelect ) ; } if ( rc != SQLITE_OK ) goto renameColumnFunc_done ; } else { int bFKOnly = sqlite3_stricmp ( zTable , sParse . pNewTable -> zName ) ; FKey * pFKey ; assert ( sParse . pNewTable -> pSelect == 0 ) ; sCtx . pTab = sParse . pNewTable ; if ( bFKOnly == 0 ) { renameTokenFind ( & sParse , & sCtx , ( void * ) sParse . pNewTable -> aCol [ iCol ] . zName ) ; if ( sCtx . iCol < 0 ) { renameTokenFind ( & sParse , & sCtx , ( void * ) & sParse . pNewTable -> iPKey ) ; } sqlite3WalkExprList ( & sWalker , sParse . pNewTable -> pCheck ) ; for ( pIdx = sParse . pNewTable -> pIndex ; pIdx ; pIdx = pIdx -> pNext ) { sqlite3WalkExprList ( & sWalker , pIdx -> aColExpr ) ; } for ( pIdx = sParse . pNewIndex ; pIdx ; pIdx = pIdx -> pNext ) { sqlite3WalkExprList ( & sWalker , pIdx -> aColExpr ) ; } } # ifndef SQLITE_OMIT_GENERATED_COLUMNS for ( i = 0 ; i < sParse . pNewTable -> nCol ; i ++ ) { sqlite3WalkExpr ( & sWalker , sParse . pNewTable -> aCol [ i ] . pDflt ) ; } # endif for ( pFKey = sParse . pNewTable -> pFKey ; pFKey ; pFKey = pFKey -> pNextFrom ) { for ( i = 0 ; i < pFKey -> nCol ; i ++ ) { if ( bFKOnly == 0 && pFKey -> aCol [ i ] . iFrom == iCol ) { renameTokenFind ( & sParse , & sCtx , ( void * ) & pFKey -> aCol [ i ] ) ; } if ( 0 == sqlite3_stricmp ( pFKey -> zTo , zTable ) && 0 == sqlite3_stricmp ( pFKey -> aCol [ i ] . zCol , zOld ) ) { renameTokenFind ( & sParse , & sCtx , ( void * ) pFKey -> aCol [ i ] . zCol ) ; } } } } } else if ( sParse . pNewIndex ) { sqlite3WalkExprList ( & sWalker , sParse . pNewIndex -> aColExpr ) ; sqlite3WalkExpr ( & sWalker , sParse . pNewIndex -> pPartIdxWhere ) ; } else { TriggerStep * pStep ; rc = renameResolveTrigger ( & sParse , ( bTemp ? 0 : zDb ) ) ; if ( rc != SQLITE_OK ) goto renameColumnFunc_done ; for ( pStep = sParse . pNewTrigger -> step_list ; pStep ; pStep = pStep -> pNext ) { if ( pStep -> zTarget ) { Table * pTarget = sqlite3LocateTable ( & sParse , 0 , pStep -> zTarget , zDb ) ; if ( pTarget == pTab ) { if ( pStep -> pUpsert ) { ExprList * pUpsertSet = pStep -> pUpsert -> pUpsertSet ; renameColumnElistNames ( & sParse , & sCtx , pUpsertSet , zOld ) ; } renameColumnIdlistNames ( & sParse , & sCtx , pStep -> pIdList , zOld ) ; renameColumnElistNames ( & sParse , & sCtx , pStep -> pExprList , zOld ) ; } } } if ( sParse . pTriggerTab == pTab ) { renameColumnIdlistNames ( & sParse , & sCtx , sParse . pNewTrigger -> pColumns , zOld ) ; } renameWalkTrigger ( & sWalker , sParse . pNewTrigger ) ; } assert ( rc == SQLITE_OK ) ; rc = renameEditSql ( context , & sCtx , zSql , zNew , bQuote ) ; renameColumnFunc_done : if ( rc != SQLITE_OK ) { if ( sParse . zErrMsg ) { renameColumnParseError ( context , 0 , argv [ 1 ] , argv [ 2 ] , & sParse ) ; } else { sqlite3_result_error_code ( context , rc ) ; } } renameParseCleanup ( & sParse ) ; renameTokenFree ( db , sCtx . pList ) ; # ifndef SQLITE_OMIT_AUTHORIZATION db -> xAuth = xAuth ; # endif sqlite3BtreeLeaveAll ( db ) ; }
void btif_config_flush ( void ) { assert ( config != NULL ) ; assert ( alarm_timer != NULL ) ; alarm_cancel ( alarm_timer ) ; <S2SV_StartBug> pthread_mutex_lock ( & lock ) ; <S2SV_EndBug> config_save ( config , CONFIG_FILE_PATH ) ; pthread_mutex_unlock ( & lock ) ; }
SYSCALL_DEFINE5 ( perf_event_open , struct perf_event_attr __user * , attr_uptr , pid_t , pid , int , cpu , int , group_fd , unsigned long , flags ) { struct perf_event * group_leader = NULL , * output_event = NULL ; struct perf_event * event , * sibling ; struct perf_event_attr attr ; struct perf_event_context * ctx , * uninitialized_var ( gctx ) ; struct file * event_file = NULL ; struct fd group = { NULL , 0 } ; struct task_struct * task = NULL ; struct pmu * pmu ; int event_fd ; int move_group = 0 ; int err ; int f_flags = O_RDWR ; int cgroup_fd = - 1 ; if ( flags & ~ PERF_FLAG_ALL ) return - EINVAL ; err = perf_copy_attr ( attr_uptr , & attr ) ; if ( err ) return err ; if ( ! attr . exclude_kernel ) { if ( perf_paranoid_kernel ( ) && ! capable ( CAP_SYS_ADMIN ) ) return - EACCES ; } if ( attr . freq ) { if ( attr . sample_freq > sysctl_perf_event_sample_rate ) return - EINVAL ; } else { if ( attr . sample_period & ( 1ULL << 63 ) ) return - EINVAL ; } if ( ! attr . sample_max_stack ) attr . sample_max_stack = sysctl_perf_event_max_stack ; if ( ( flags & PERF_FLAG_PID_CGROUP ) && ( pid == - 1 || cpu == - 1 ) ) return - EINVAL ; if ( flags & PERF_FLAG_FD_CLOEXEC ) f_flags |= O_CLOEXEC ; event_fd = get_unused_fd_flags ( f_flags ) ; if ( event_fd < 0 ) return event_fd ; if ( group_fd != - 1 ) { err = perf_fget_light ( group_fd , & group ) ; if ( err ) goto err_fd ; group_leader = group . file -> private_data ; if ( flags & PERF_FLAG_FD_OUTPUT ) output_event = group_leader ; if ( flags & PERF_FLAG_FD_NO_GROUP ) group_leader = NULL ; } if ( pid != - 1 && ! ( flags & PERF_FLAG_PID_CGROUP ) ) { task = find_lively_task_by_vpid ( pid ) ; if ( IS_ERR ( task ) ) { err = PTR_ERR ( task ) ; goto err_group_fd ; } } if ( task && group_leader && group_leader -> attr . inherit != attr . inherit ) { err = - EINVAL ; goto err_task ; } get_online_cpus ( ) ; if ( task ) { err = mutex_lock_interruptible ( & task -> signal -> cred_guard_mutex ) ; if ( err ) goto err_cpus ; err = - EACCES ; if ( ! ptrace_may_access ( task , PTRACE_MODE_READ_REALCREDS ) ) goto err_cred ; } if ( flags & PERF_FLAG_PID_CGROUP ) cgroup_fd = pid ; event = perf_event_alloc ( & attr , cpu , task , group_leader , NULL , NULL , NULL , cgroup_fd ) ; if ( IS_ERR ( event ) ) { err = PTR_ERR ( event ) ; goto err_cred ; } if ( is_sampling_event ( event ) ) { if ( event -> pmu -> capabilities & PERF_PMU_CAP_NO_INTERRUPT ) { err = - EOPNOTSUPP ; goto err_alloc ; } } pmu = event -> pmu ; if ( attr . use_clockid ) { err = perf_event_set_clock ( event , attr . clockid ) ; if ( err ) goto err_alloc ; } if ( pmu -> task_ctx_nr == perf_sw_context ) event -> event_caps |= PERF_EV_CAP_SOFTWARE ; if ( group_leader && ( is_software_event ( event ) != is_software_event ( group_leader ) ) ) { if ( is_software_event ( event ) ) { pmu = group_leader -> pmu ; } else if ( is_software_event ( group_leader ) && ( group_leader -> group_caps & PERF_EV_CAP_SOFTWARE ) ) { move_group = 1 ; } } ctx = find_get_context ( pmu , task , event ) ; if ( IS_ERR ( ctx ) ) { err = PTR_ERR ( ctx ) ; goto err_alloc ; } if ( ( pmu -> capabilities & PERF_PMU_CAP_EXCLUSIVE ) && group_leader ) { err = - EBUSY ; goto err_context ; } if ( group_leader ) { err = - EINVAL ; if ( group_leader -> group_leader != group_leader ) goto err_context ; if ( group_leader -> clock != event -> clock ) goto err_context ; if ( move_group ) { if ( group_leader -> ctx -> task != ctx -> task ) goto err_context ; if ( group_leader -> cpu != event -> cpu ) goto err_context ; } else { if ( group_leader -> ctx != ctx ) goto err_context ; } if ( attr . exclusive || attr . pinned ) goto err_context ; } if ( output_event ) { err = perf_event_set_output ( event , output_event ) ; if ( err ) goto err_context ; } event_file = anon_inode_getfile ( "[perf_event]" , & perf_fops , event , f_flags ) ; if ( IS_ERR ( event_file ) ) { err = PTR_ERR ( event_file ) ; event_file = NULL ; goto err_context ; } if ( move_group ) { <S2SV_StartBug> gctx = group_leader -> ctx ; <S2SV_EndBug> mutex_lock_double ( & gctx -> mutex , & ctx -> mutex ) ; if ( gctx -> task == TASK_TOMBSTONE ) { err = - ESRCH ; goto err_locked ; } <S2SV_StartBug> } else { <S2SV_EndBug> mutex_lock ( & ctx -> mutex ) ; } if ( ctx -> task == TASK_TOMBSTONE ) { err = - ESRCH ; goto err_locked ; } if ( ! perf_event_validate_size ( event ) ) { err = - E2BIG ; goto err_locked ; } if ( ! exclusive_event_installable ( event , ctx ) ) { WARN_ON_ONCE ( move_group ) ; err = - EBUSY ; goto err_locked ; } WARN_ON_ONCE ( ctx -> parent_ctx ) ; if ( move_group ) { perf_remove_from_context ( group_leader , 0 ) ; list_for_each_entry ( sibling , & group_leader -> sibling_list , group_entry ) { perf_remove_from_context ( sibling , 0 ) ; put_ctx ( gctx ) ; } synchronize_rcu ( ) ; list_for_each_entry ( sibling , & group_leader -> sibling_list , group_entry ) { perf_event__state_init ( sibling ) ; perf_install_in_context ( ctx , sibling , sibling -> cpu ) ; get_ctx ( ctx ) ; } perf_event__state_init ( group_leader ) ; perf_install_in_context ( ctx , group_leader , group_leader -> cpu ) ; get_ctx ( ctx ) ; put_ctx ( gctx ) ; } perf_event__header_size ( event ) ; perf_event__id_header_size ( event ) ; event -> owner = current ; perf_install_in_context ( ctx , event , event -> cpu ) ; perf_unpin_context ( ctx ) ; if ( move_group ) <S2SV_StartBug> mutex_unlock ( & gctx -> mutex ) ; <S2SV_EndBug> mutex_unlock ( & ctx -> mutex ) ; if ( task ) { mutex_unlock ( & task -> signal -> cred_guard_mutex ) ; put_task_struct ( task ) ; } put_online_cpus ( ) ; mutex_lock ( & current -> perf_event_mutex ) ; list_add_tail ( & event -> owner_entry , & current -> perf_event_list ) ; mutex_unlock ( & current -> perf_event_mutex ) ; fdput ( group ) ; fd_install ( event_fd , event_file ) ; return event_fd ; err_locked : if ( move_group ) <S2SV_StartBug> mutex_unlock ( & gctx -> mutex ) ; <S2SV_EndBug> mutex_unlock ( & ctx -> mutex ) ; fput ( event_file ) ; err_context : perf_unpin_context ( ctx ) ; put_ctx ( ctx ) ; err_alloc : if ( ! event_file ) free_event ( event ) ; err_cred : if ( task ) mutex_unlock ( & task -> signal -> cred_guard_mutex ) ; err_cpus : put_online_cpus ( ) ; err_task : if ( task ) put_task_struct ( task ) ; err_group_fd : fdput ( group ) ; err_fd : put_unused_fd ( event_fd ) ; return err ; }
int ASN1_item_verify ( const ASN1_ITEM * it , X509_ALGOR * a , ASN1_BIT_STRING * signature , void * asn , EVP_PKEY * pkey ) { EVP_MD_CTX ctx ; unsigned char * buf_in = NULL ; int ret = - 1 , inl ; int mdnid , pknid ; if ( ! pkey ) { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ERR_R_PASSED_NULL_PARAMETER ) ; return - 1 ; } <S2SV_StartBug> EVP_MD_CTX_init ( & ctx ) ; <S2SV_EndBug> if ( ! OBJ_find_sigid_algs ( OBJ_obj2nid ( a -> algorithm ) , & mdnid , & pknid ) ) { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ASN1_R_UNKNOWN_SIGNATURE_ALGORITHM ) ; goto err ; } if ( mdnid == NID_undef ) { if ( ! pkey -> ameth || ! pkey -> ameth -> item_verify ) { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ASN1_R_UNKNOWN_SIGNATURE_ALGORITHM ) ; goto err ; } ret = pkey -> ameth -> item_verify ( & ctx , it , asn , a , signature , pkey ) ; if ( ret != 2 ) goto err ; ret = - 1 ; } else { const EVP_MD * type ; type = EVP_get_digestbynid ( mdnid ) ; if ( type == NULL ) { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ASN1_R_UNKNOWN_MESSAGE_DIGEST_ALGORITHM ) ; goto err ; } if ( EVP_PKEY_type ( pknid ) != pkey -> ameth -> pkey_id ) { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ASN1_R_WRONG_PUBLIC_KEY_TYPE ) ; goto err ; } if ( ! EVP_DigestVerifyInit ( & ctx , NULL , type , NULL , pkey ) ) { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ERR_R_EVP_LIB ) ; ret = 0 ; goto err ; } } inl = ASN1_item_i2d ( asn , & buf_in , it ) ; if ( buf_in == NULL ) { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ERR_R_MALLOC_FAILURE ) ; goto err ; } ret = EVP_DigestVerifyUpdate ( & ctx , buf_in , inl ) ; OPENSSL_cleanse ( buf_in , ( unsigned int ) inl ) ; OPENSSL_free ( buf_in ) ; if ( ! ret ) { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ERR_R_EVP_LIB ) ; goto err ; } ret = - 1 ; if ( EVP_DigestVerifyFinal ( & ctx , signature -> data , ( size_t ) signature -> length ) <= 0 ) { ASN1err ( ASN1_F_ASN1_ITEM_VERIFY , ERR_R_EVP_LIB ) ; ret = 0 ; goto err ; } ret = 1 ; err : EVP_MD_CTX_cleanup ( & ctx ) ; return ( ret ) ; }
MagickExport const char * GetMagickFeatures ( void ) { return "DPC" <S2SV_StartBug> # if defined ( MAGICKCORE_BUILD_MODULES ) || defined ( _DLL ) <S2SV_EndBug> "<S2SV_blank>Modules" # endif # if defined ( MAGICKCORE_HDRI_SUPPORT ) <S2SV_StartBug> "<S2SV_blank>HDRI" <S2SV_EndBug> # endif # if defined ( MAGICKCORE_OPENCL_SUPPORT ) "<S2SV_blank>OpenCL" # endif # if defined ( MAGICKCORE_OPENMP_SUPPORT ) "<S2SV_blank>OpenMP" # endif <S2SV_StartBug> ; <S2SV_EndBug> }
static void vmx_set_constant_host_state ( struct vcpu_vmx * vmx ) { u32 low32 , high32 ; unsigned long tmpl ; struct desc_ptr dt ; <S2SV_StartBug> vmcs_writel ( HOST_CR0 , read_cr0 ( ) & ~ X86_CR0_TS ) ; <S2SV_EndBug> <S2SV_StartBug> vmcs_writel ( HOST_CR4 , read_cr4 ( ) ) ; <S2SV_EndBug> vmcs_writel ( HOST_CR3 , read_cr3 ( ) ) ; vmcs_write16 ( HOST_CS_SELECTOR , __KERNEL_CS ) ; # ifdef CONFIG_X86_64 vmcs_write16 ( HOST_DS_SELECTOR , 0 ) ; vmcs_write16 ( HOST_ES_SELECTOR , 0 ) ; # else vmcs_write16 ( HOST_DS_SELECTOR , __KERNEL_DS ) ; vmcs_write16 ( HOST_ES_SELECTOR , __KERNEL_DS ) ; # endif vmcs_write16 ( HOST_SS_SELECTOR , __KERNEL_DS ) ; vmcs_write16 ( HOST_TR_SELECTOR , GDT_ENTRY_TSS * 8 ) ; native_store_idt ( & dt ) ; vmcs_writel ( HOST_IDTR_BASE , dt . address ) ; vmx -> host_idt_base = dt . address ; vmcs_writel ( HOST_RIP , vmx_return ) ; rdmsr ( MSR_IA32_SYSENTER_CS , low32 , high32 ) ; vmcs_write32 ( HOST_IA32_SYSENTER_CS , low32 ) ; rdmsrl ( MSR_IA32_SYSENTER_EIP , tmpl ) ; vmcs_writel ( HOST_IA32_SYSENTER_EIP , tmpl ) ; if ( vmcs_config . vmexit_ctrl & VM_EXIT_LOAD_IA32_PAT ) { rdmsr ( MSR_IA32_CR_PAT , low32 , high32 ) ; vmcs_write64 ( HOST_IA32_PAT , low32 | ( ( u64 ) high32 << 32 ) ) ; } }
int vp9_get_raw_frame ( VP9Decoder * pbi , YV12_BUFFER_CONFIG * sd , <S2SV_StartBug> int64_t * time_stamp , int64_t * time_end_stamp , <S2SV_EndBug> <S2SV_StartBug> vp9_ppflags_t * flags ) { <S2SV_EndBug> <S2SV_StartBug> int ret = - 1 ; <S2SV_EndBug> if ( pbi -> ready_for_new_data == 1 ) return ret ; <S2SV_StartBug> if ( pbi -> common . show_frame == 0 ) <S2SV_EndBug> return ret ; pbi -> ready_for_new_data = 1 ; <S2SV_StartBug> * time_stamp = pbi -> last_time_stamp ; <S2SV_EndBug> * time_end_stamp = 0 ; <S2SV_StartBug> # if CONFIG_VP9_POSTPROC <S2SV_EndBug> <S2SV_StartBug> ret = vp9_post_proc_frame ( & pbi -> common , sd , flags ) ; <S2SV_EndBug> # else <S2SV_StartBug> * sd = * pbi -> common . frame_to_show ; <S2SV_EndBug> sd -> y_width = pbi -> common . width ; sd -> y_height = pbi -> common . height ; sd -> uv_width = sd -> y_width >> pbi -> common . subsampling_x ; sd -> uv_height = sd -> y_height >> pbi -> common . subsampling_y ; ret = 0 ; # endif <S2SV_StartBug> vp9_clear_system_state ( ) ; <S2SV_EndBug> return ret ; }
static int tun_set_iff ( struct net * net , struct file * file , struct ifreq * ifr ) { struct tun_struct * tun ; struct tun_file * tfile = file -> private_data ; struct net_device * dev ; int err ; if ( tfile -> detached ) return - EINVAL ; dev = __dev_get_by_name ( net , ifr -> ifr_name ) ; if ( dev ) { if ( ifr -> ifr_flags & IFF_TUN_EXCL ) return - EBUSY ; if ( ( ifr -> ifr_flags & IFF_TUN ) && dev -> netdev_ops == & tun_netdev_ops ) tun = netdev_priv ( dev ) ; else if ( ( ifr -> ifr_flags & IFF_TAP ) && dev -> netdev_ops == & tap_netdev_ops ) tun = netdev_priv ( dev ) ; else return - EINVAL ; if ( ! ! ( ifr -> ifr_flags & IFF_MULTI_QUEUE ) != ! ! ( tun -> flags & IFF_MULTI_QUEUE ) ) return - EINVAL ; if ( tun_not_capable ( tun ) ) return - EPERM ; err = security_tun_dev_open ( tun -> security ) ; if ( err < 0 ) return err ; err = tun_attach ( tun , file , ifr -> ifr_flags & IFF_NOFILTER ) ; if ( err < 0 ) return err ; if ( tun -> flags & IFF_MULTI_QUEUE && ( tun -> numqueues + tun -> numdisabled > 1 ) ) { return 0 ; } } else { char * name ; unsigned long flags = 0 ; int queues = ifr -> ifr_flags & IFF_MULTI_QUEUE ? MAX_TAP_QUEUES : 1 ; if ( ! ns_capable ( net -> user_ns , CAP_NET_ADMIN ) ) return - EPERM ; err = security_tun_dev_create ( ) ; if ( err < 0 ) return err ; if ( ifr -> ifr_flags & IFF_TUN ) { flags |= IFF_TUN ; name = "tun%d" ; } else if ( ifr -> ifr_flags & IFF_TAP ) { flags |= IFF_TAP ; name = "tap%d" ; } else return - EINVAL ; if ( * ifr -> ifr_name ) name = ifr -> ifr_name ; dev = alloc_netdev_mqs ( sizeof ( struct tun_struct ) , name , NET_NAME_UNKNOWN , tun_setup , queues , queues ) ; if ( ! dev ) return - ENOMEM ; <S2SV_StartBug> dev_net_set ( dev , net ) ; <S2SV_EndBug> dev -> rtnl_link_ops = & tun_link_ops ; dev -> ifindex = tfile -> ifindex ; dev -> sysfs_groups [ 0 ] = & tun_attr_group ; tun = netdev_priv ( dev ) ; tun -> dev = dev ; tun -> flags = flags ; tun -> txflt . count = 0 ; tun -> vnet_hdr_sz = sizeof ( struct virtio_net_hdr ) ; tun -> align = NET_SKB_PAD ; tun -> filter_attached = false ; tun -> sndbuf = tfile -> socket . sk -> sk_sndbuf ; tun -> rx_batched = 0 ; tun -> pcpu_stats = netdev_alloc_pcpu_stats ( struct tun_pcpu_stats ) ; if ( ! tun -> pcpu_stats ) { err = - ENOMEM ; goto err_free_dev ; } spin_lock_init ( & tun -> lock ) ; err = security_tun_dev_alloc_security ( & tun -> security ) ; if ( err < 0 ) goto err_free_stat ; tun_net_init ( dev ) ; tun_flow_init ( tun ) ; dev -> hw_features = NETIF_F_SG | NETIF_F_FRAGLIST | TUN_USER_FEATURES | NETIF_F_HW_VLAN_CTAG_TX | NETIF_F_HW_VLAN_STAG_TX ; dev -> features = dev -> hw_features | NETIF_F_LLTX ; dev -> vlan_features = dev -> features & ~ ( NETIF_F_HW_VLAN_CTAG_TX | NETIF_F_HW_VLAN_STAG_TX ) ; INIT_LIST_HEAD ( & tun -> disabled ) ; err = tun_attach ( tun , file , false ) ; if ( err < 0 ) goto err_free_flow ; err = register_netdevice ( tun -> dev ) ; if ( err < 0 ) goto err_detach ; } netif_carrier_on ( tun -> dev ) ; tun_debug ( KERN_INFO , tun , "tun_set_iff\\n" ) ; tun -> flags = ( tun -> flags & ~ TUN_FEATURES ) | ( ifr -> ifr_flags & TUN_FEATURES ) ; if ( netif_running ( tun -> dev ) ) netif_tx_wake_all_queues ( tun -> dev ) ; strcpy ( ifr -> ifr_name , tun -> dev -> name ) ; return 0 ; err_detach : tun_detach_all ( dev ) ; goto err_free_dev ; err_free_flow : tun_flow_uninit ( tun ) ; security_tun_dev_free_security ( tun -> security ) ; err_free_stat : free_percpu ( tun -> pcpu_stats ) ; err_free_dev : free_netdev ( dev ) ; return err ; }
static void handle_ppp ( netdissect_options * ndo , u_int proto , const u_char * p , int length ) { if ( ( proto & 0xff00 ) == 0x7e00 ) { ppp_hdlc ( ndo , p - 1 , length ) ; return ; } switch ( proto ) { case PPP_LCP : case PPP_IPCP : case PPP_OSICP : case PPP_MPLSCP : case PPP_IPV6CP : case PPP_CCP : case PPP_BACP : handle_ctrl_proto ( ndo , proto , p , length ) ; break ; case PPP_ML : handle_mlppp ( ndo , p , length ) ; break ; case PPP_CHAP : handle_chap ( ndo , p , length ) ; break ; case PPP_PAP : handle_pap ( ndo , p , length ) ; break ; case PPP_BAP : handle_bap ( ndo , p , length ) ; break ; case ETHERTYPE_IP : case PPP_VJNC : case PPP_IP : ip_print ( ndo , p , length ) ; break ; case ETHERTYPE_IPV6 : case PPP_IPV6 : ip6_print ( ndo , p , length ) ; break ; case ETHERTYPE_IPX : case PPP_IPX : ipx_print ( ndo , p , length ) ; break ; case PPP_OSI : <S2SV_StartBug> isoclns_print ( ndo , p , length , length ) ; <S2SV_EndBug> break ; case PPP_MPLS_UCAST : case PPP_MPLS_MCAST : mpls_print ( ndo , p , length ) ; break ; case PPP_COMP : ND_PRINT ( ( ndo , "compressed<S2SV_blank>PPP<S2SV_blank>data" ) ) ; break ; default : ND_PRINT ( ( ndo , "%s<S2SV_blank>" , tok2str ( ppptype2str , "unknown<S2SV_blank>PPP<S2SV_blank>protocol<S2SV_blank>(0x%04x)" , proto ) ) ) ; print_unknown_data ( ndo , p , "\\n\\t" , length ) ; break ; } }
static void scsi_read_complete ( void * opaque , int ret ) { SCSIDiskReq * r = ( SCSIDiskReq * ) opaque ; SCSIDiskState * s = DO_UPCAST ( SCSIDiskState , qdev , r -> req . dev ) ; int n ; if ( r -> req . aiocb != NULL ) { r -> req . aiocb = NULL ; bdrv_acct_done ( s -> bs , & r -> acct ) ; } if ( ret ) { if ( scsi_handle_rw_error ( r , - ret , SCSI_REQ_STATUS_RETRY_READ ) ) { return ; } } <S2SV_StartBug> DPRINTF ( "Data<S2SV_blank>ready<S2SV_blank>tag=0x%x<S2SV_blank>len=%zd\\n" , r -> req . tag , r -> iov . iov_len ) ; <S2SV_EndBug> <S2SV_StartBug> n = r -> iov . iov_len / 512 ; <S2SV_EndBug> r -> sector += n ; r -> sector_count -= n ; <S2SV_StartBug> scsi_req_data ( & r -> req , r -> iov . iov_len ) ; <S2SV_EndBug> }
void vp9_rc_get_one_pass_cbr_params ( VP9_COMP * cpi ) { VP9_COMMON * const cm = & cpi -> common ; RATE_CONTROL * const rc = & cpi -> rc ; int target ; if ( ( cm -> current_video_frame == 0 || <S2SV_StartBug> ( cm -> frame_flags & FRAMEFLAGS_KEY ) || <S2SV_EndBug> rc -> frames_to_key == 0 || <S2SV_StartBug> ( cpi -> oxcf . auto_key && test_for_kf_one_pass ( cpi ) ) ) ) { <S2SV_EndBug> cm -> frame_type = KEY_FRAME ; rc -> this_key_frame_forced = cm -> current_video_frame != 0 && rc -> frames_to_key == 0 ; <S2SV_StartBug> rc -> frames_to_key = cpi -> key_frame_frequency ; <S2SV_EndBug> rc -> kf_boost = DEFAULT_KF_BOOST ; <S2SV_StartBug> rc -> source_alt_ref_active = 0 ; <S2SV_EndBug> target = calc_iframe_target_size_one_pass_cbr ( cpi ) ; } else { cm -> frame_type = INTER_FRAME ; <S2SV_StartBug> target = calc_pframe_target_size_one_pass_cbr ( cpi ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug> vp9_rc_set_frame_target ( cpi , target ) ; <S2SV_StartBug> rc -> frames_till_gf_update_due = INT_MAX ; <S2SV_EndBug> rc -> baseline_gf_interval = INT_MAX ; }
GF_Err latm_dmx_process ( GF_Filter * filter ) { GF_LATMDmxCtx * ctx = gf_filter_get_udta ( filter ) ; GF_FilterPacket * pck , * dst_pck ; u32 pos ; <S2SV_StartBug> u8 * data , * output ; <S2SV_EndBug> <S2SV_StartBug> u32 pck_size , prev_pck_size ; <S2SV_EndBug> u64 cts = GF_FILTER_NO_TS ; if ( ctx -> in_error ) return ctx -> in_error ; if ( ! ctx -> duration . num ) latm_dmx_check_dur ( filter , ctx ) ; if ( ctx -> opid && ! ctx -> is_playing ) return GF_OK ; pck = gf_filter_pid_get_packet ( ctx -> ipid ) ; if ( ! pck ) { if ( gf_filter_pid_is_eos ( ctx -> ipid ) ) { if ( ! ctx -> latm_buffer_size ) { if ( ctx -> opid ) gf_filter_pid_set_eos ( ctx -> opid ) ; if ( ctx -> src_pck ) gf_filter_pck_unref ( ctx -> src_pck ) ; ctx -> src_pck = NULL ; return GF_EOS ; } } else { return GF_OK ; } <S2SV_StartBug> } <S2SV_EndBug> <S2SV_StartBug> data = ( char * ) gf_filter_pck_get_data ( pck , & pck_size ) ; <S2SV_EndBug> if ( ctx -> timescale && pck ) { cts = gf_filter_pck_get_cts ( pck ) ; } prev_pck_size = ctx -> latm_buffer_size ; if ( pck && ! ctx -> resume_from ) { if ( ctx -> latm_buffer_size + pck_size > ctx -> latm_buffer_alloc ) { ctx -> latm_buffer_alloc = ctx -> latm_buffer_size + pck_size ; ctx -> latm_buffer = gf_realloc ( ctx -> latm_buffer , ctx -> latm_buffer_alloc ) ; } memcpy ( ctx -> latm_buffer + ctx -> latm_buffer_size , data , pck_size ) ; ctx -> latm_buffer_size += pck_size ; } if ( ! ctx -> bs ) ctx -> bs = gf_bs_new ( ctx -> latm_buffer , ctx -> latm_buffer_size , GF_BITSTREAM_READ ) ; else gf_bs_reassign_buffer ( ctx -> bs , ctx -> latm_buffer , ctx -> latm_buffer_size ) ; if ( ctx -> resume_from ) { gf_bs_seek ( ctx -> bs , ctx -> resume_from - 1 ) ; ctx -> resume_from = 0 ; } if ( cts == GF_FILTER_NO_TS ) prev_pck_size = 0 ; while ( 1 ) { pos = ( u32 ) gf_bs_get_position ( ctx -> bs ) ; u8 latm_buffer [ 4096 ] ; u32 latm_frame_size = 4096 ; if ( ! latm_dmx_sync_frame_bs ( ctx -> bs , & ctx -> acfg , & latm_frame_size , latm_buffer , NULL ) ) break ; if ( ctx -> in_seek ) { u64 nb_samples_at_seek = ( u64 ) ( ctx -> start_range * GF_M4ASampleRates [ ctx -> sr_idx ] ) ; if ( ctx -> cts + ctx -> dts_inc >= nb_samples_at_seek ) { ctx -> in_seek = GF_FALSE ; } } latm_dmx_check_pid ( filter , ctx ) ; if ( ! ctx -> is_playing ) { ctx -> resume_from = pos + 1 ; return GF_OK ; } if ( ! ctx -> in_seek ) { GF_FilterSAPType sap = GF_FILTER_SAP_1 ; dst_pck = gf_filter_pck_new_alloc ( ctx -> opid , latm_frame_size , & output ) ; if ( ctx -> src_pck ) gf_filter_pck_merge_properties ( ctx -> src_pck , dst_pck ) ; memcpy ( output , latm_buffer , latm_frame_size ) ; gf_filter_pck_set_cts ( dst_pck , ctx -> cts ) ; gf_filter_pck_set_duration ( dst_pck , ctx -> dts_inc ) ; gf_filter_pck_set_framing ( dst_pck , GF_TRUE , GF_TRUE ) ; if ( ctx -> acfg . base_object_type == GF_CODECID_USAC ) { if ( latm_frame_size && ( output [ 0 ] & 0x80 ) && ! ctx -> prev_sap ) { sap = GF_FILTER_SAP_1 ; ctx -> prev_sap = GF_TRUE ; } else { sap = GF_FILTER_SAP_NONE ; ctx -> prev_sap = GF_FALSE ; } } gf_filter_pck_set_sap ( dst_pck , sap ) ; gf_filter_pck_send ( dst_pck ) ; } latm_dmx_update_cts ( ctx ) ; if ( prev_pck_size ) { pos = ( u32 ) gf_bs_get_position ( ctx -> bs ) ; if ( prev_pck_size <= pos ) { prev_pck_size = 0 ; if ( ctx -> src_pck ) gf_filter_pck_unref ( ctx -> src_pck ) ; ctx -> src_pck = pck ; if ( pck ) gf_filter_pck_ref_props ( & ctx -> src_pck ) ; } } } if ( pck ) { pos = ( u32 ) gf_bs_get_position ( ctx -> bs ) ; assert ( ctx -> latm_buffer_size >= pos ) ; memmove ( ctx -> latm_buffer , ctx -> latm_buffer + pos , ctx -> latm_buffer_size - pos ) ; ctx -> latm_buffer_size -= pos ; gf_filter_pid_drop_packet ( ctx -> ipid ) ; assert ( ! ctx -> resume_from ) ; } else { ctx -> latm_buffer_size = 0 ; return latm_dmx_process ( filter ) ; } return GF_OK ; }
int ieee80211_radiotap_iterator_init ( struct ieee80211_radiotap_iterator * iterator , struct ieee80211_radiotap_header * radiotap_header , int max_length , const struct ieee80211_radiotap_vendor_namespaces * vns ) { <S2SV_StartBug> if ( radiotap_header -> it_version ) <S2SV_EndBug> return - EINVAL ; if ( max_length < get_unaligned_le16 ( & radiotap_header -> it_len ) ) return - EINVAL ; iterator -> _rtheader = radiotap_header ; iterator -> _max_length = get_unaligned_le16 ( & radiotap_header -> it_len ) ; iterator -> _arg_index = 0 ; iterator -> _bitmap_shifter = get_unaligned_le32 ( & radiotap_header -> it_present ) ; iterator -> _arg = ( uint8_t * ) radiotap_header + sizeof ( * radiotap_header ) ; iterator -> _reset_on_ext = 0 ; iterator -> _next_bitmap = & radiotap_header -> it_present ; iterator -> _next_bitmap ++ ; iterator -> _vns = vns ; iterator -> current_namespace = & radiotap_ns ; iterator -> is_radiotap_ns = 1 ; if ( iterator -> _bitmap_shifter & ( 1 << IEEE80211_RADIOTAP_EXT ) ) { while ( get_unaligned_le32 ( iterator -> _arg ) & ( 1 << IEEE80211_RADIOTAP_EXT ) ) { iterator -> _arg += sizeof ( uint32_t ) ; if ( ( unsigned long ) iterator -> _arg - <S2SV_StartBug> ( unsigned long ) iterator -> _rtheader > <S2SV_EndBug> ( unsigned long ) iterator -> _max_length ) return - EINVAL ; } iterator -> _arg += sizeof ( uint32_t ) ; } iterator -> this_arg = iterator -> _arg ; return 0 ; }
static int __ip6_datagram_connect ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct sockaddr_in6 * usin = ( struct sockaddr_in6 * ) uaddr ; struct inet_sock * inet = inet_sk ( sk ) ; struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct in6_addr * daddr , * final_p , final ; struct dst_entry * dst ; struct flowi6 fl6 ; struct ip6_flowlabel * flowlabel = NULL ; struct ipv6_txoptions * opt ; int addr_type ; int err ; if ( usin -> sin6_family == AF_INET ) { if ( __ipv6_only_sock ( sk ) ) return - EAFNOSUPPORT ; err = __ip4_datagram_connect ( sk , uaddr , addr_len ) ; goto ipv4_connected ; } if ( addr_len < SIN6_LEN_RFC2133 ) return - EINVAL ; if ( usin -> sin6_family != AF_INET6 ) return - EAFNOSUPPORT ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; if ( np -> sndflow ) { fl6 . flowlabel = usin -> sin6_flowinfo & IPV6_FLOWINFO_MASK ; if ( fl6 . flowlabel & IPV6_FLOWLABEL_MASK ) { flowlabel = fl6_sock_lookup ( sk , fl6 . flowlabel ) ; if ( ! flowlabel ) return - EINVAL ; } } addr_type = ipv6_addr_type ( & usin -> sin6_addr ) ; if ( addr_type == IPV6_ADDR_ANY ) { usin -> sin6_addr . s6_addr [ 15 ] = 0x01 ; } daddr = & usin -> sin6_addr ; if ( addr_type == IPV6_ADDR_MAPPED ) { struct sockaddr_in sin ; if ( __ipv6_only_sock ( sk ) ) { err = - ENETUNREACH ; goto out ; } sin . sin_family = AF_INET ; sin . sin_addr . s_addr = daddr -> s6_addr32 [ 3 ] ; sin . sin_port = usin -> sin6_port ; err = __ip4_datagram_connect ( sk , ( struct sockaddr * ) & sin , sizeof ( sin ) ) ; ipv4_connected : if ( err ) goto out ; ipv6_addr_set_v4mapped ( inet -> inet_daddr , & sk -> sk_v6_daddr ) ; if ( ipv6_addr_any ( & np -> saddr ) || ipv6_mapped_addr_any ( & np -> saddr ) ) ipv6_addr_set_v4mapped ( inet -> inet_saddr , & np -> saddr ) ; if ( ipv6_addr_any ( & sk -> sk_v6_rcv_saddr ) || ipv6_mapped_addr_any ( & sk -> sk_v6_rcv_saddr ) ) { ipv6_addr_set_v4mapped ( inet -> inet_rcv_saddr , & sk -> sk_v6_rcv_saddr ) ; if ( sk -> sk_prot -> rehash ) sk -> sk_prot -> rehash ( sk ) ; } goto out ; } if ( __ipv6_addr_needs_scope_id ( addr_type ) ) { if ( addr_len >= sizeof ( struct sockaddr_in6 ) && usin -> sin6_scope_id ) { if ( sk -> sk_bound_dev_if && sk -> sk_bound_dev_if != usin -> sin6_scope_id ) { err = - EINVAL ; goto out ; } sk -> sk_bound_dev_if = usin -> sin6_scope_id ; } if ( ! sk -> sk_bound_dev_if && ( addr_type & IPV6_ADDR_MULTICAST ) ) sk -> sk_bound_dev_if = np -> mcast_oif ; if ( ! sk -> sk_bound_dev_if ) { err = - EINVAL ; goto out ; } } sk -> sk_v6_daddr = * daddr ; np -> flow_label = fl6 . flowlabel ; inet -> inet_dport = usin -> sin6_port ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = np -> saddr ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; fl6 . fl6_dport = inet -> inet_dport ; fl6 . fl6_sport = inet -> inet_sport ; if ( ! fl6 . flowi6_oif && ( addr_type & IPV6_ADDR_MULTICAST ) ) fl6 . flowi6_oif = np -> mcast_oif ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; <S2SV_StartBug> opt = flowlabel ? flowlabel -> opt : np -> opt ; <S2SV_EndBug> <S2SV_StartBug> final_p = fl6_update_dst ( & fl6 , opt , & final ) ; <S2SV_EndBug> dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; err = 0 ; if ( IS_ERR ( dst ) ) { err = PTR_ERR ( dst ) ; goto out ; } if ( ipv6_addr_any ( & np -> saddr ) ) np -> saddr = fl6 . saddr ; if ( ipv6_addr_any ( & sk -> sk_v6_rcv_saddr ) ) { sk -> sk_v6_rcv_saddr = fl6 . saddr ; inet -> inet_rcv_saddr = LOOPBACK4_IPV6 ; if ( sk -> sk_prot -> rehash ) sk -> sk_prot -> rehash ( sk ) ; } ip6_dst_store ( sk , dst , ipv6_addr_equal ( & fl6 . daddr , & sk -> sk_v6_daddr ) ? & sk -> sk_v6_daddr : NULL , # ifdef CONFIG_IPV6_SUBTREES ipv6_addr_equal ( & fl6 . saddr , & np -> saddr ) ? & np -> saddr : # endif NULL ) ; sk -> sk_state = TCP_ESTABLISHED ; sk_set_txhash ( sk ) ; out : fl6_sock_release ( flowlabel ) ; return err ; }
static gboolean cosine_seek_read ( wtap * wth , gint64 seek_off , struct wtap_pkthdr * phdr , Buffer * buf , int * err , gchar * * err_info ) { <S2SV_StartBug> int pkt_len ; <S2SV_EndBug> char line [ COSINE_LINE_LENGTH ] ; if ( file_seek ( wth -> random_fh , seek_off , SEEK_SET , err ) == - 1 ) return FALSE ; if ( file_gets ( line , COSINE_LINE_LENGTH , wth -> random_fh ) == NULL ) { * err = file_error ( wth -> random_fh , err_info ) ; if ( * err == 0 ) { * err = WTAP_ERR_SHORT_READ ; } return FALSE ; } <S2SV_StartBug> pkt_len = parse_cosine_rec_hdr ( phdr , line , err , err_info ) ; <S2SV_EndBug> if ( pkt_len == - 1 ) return FALSE ; <S2SV_StartBug> return parse_cosine_hex_dump ( wth -> random_fh , phdr , pkt_len , buf , err , <S2SV_EndBug> err_info ) ; }
static int do_check ( struct bpf_verifier_env * env ) { struct bpf_verifier_state * state ; struct bpf_insn * insns = env -> prog -> insnsi ; struct bpf_reg_state * regs ; int insn_cnt = env -> prog -> len ; int insn_idx , prev_insn_idx = 0 ; int insn_processed = 0 ; bool do_print_state = false ; state = kzalloc ( sizeof ( struct bpf_verifier_state ) , GFP_KERNEL ) ; if ( ! state ) return - ENOMEM ; env -> cur_state = state ; init_reg_state ( env , state -> regs ) ; state -> parent = NULL ; insn_idx = 0 ; for ( ; ; ) { struct bpf_insn * insn ; u8 class ; int err ; if ( insn_idx >= insn_cnt ) { verbose ( env , "invalid<S2SV_blank>insn<S2SV_blank>idx<S2SV_blank>%d<S2SV_blank>insn_cnt<S2SV_blank>%d\\n" , insn_idx , insn_cnt ) ; return - EFAULT ; } insn = & insns [ insn_idx ] ; class = BPF_CLASS ( insn -> code ) ; if ( ++ insn_processed > BPF_COMPLEXITY_LIMIT_INSNS ) { verbose ( env , "BPF<S2SV_blank>program<S2SV_blank>is<S2SV_blank>too<S2SV_blank>large.<S2SV_blank>Processed<S2SV_blank>%d<S2SV_blank>insn\\n" , insn_processed ) ; return - E2BIG ; } err = is_state_visited ( env , insn_idx ) ; if ( err < 0 ) return err ; if ( err == 1 ) { if ( env -> log . level ) { if ( do_print_state ) verbose ( env , "\\nfrom<S2SV_blank>%d<S2SV_blank>to<S2SV_blank>%d:<S2SV_blank>safe\\n" , prev_insn_idx , insn_idx ) ; else verbose ( env , "%d:<S2SV_blank>safe\\n" , insn_idx ) ; } goto process_bpf_exit ; } if ( need_resched ( ) ) cond_resched ( ) ; if ( env -> log . level > 1 || ( env -> log . level && do_print_state ) ) { if ( env -> log . level > 1 ) verbose ( env , "%d:" , insn_idx ) ; else verbose ( env , "\\nfrom<S2SV_blank>%d<S2SV_blank>to<S2SV_blank>%d:" , prev_insn_idx , insn_idx ) ; print_verifier_state ( env , state ) ; do_print_state = false ; } if ( env -> log . level ) { verbose ( env , "%d:<S2SV_blank>" , insn_idx ) ; print_bpf_insn ( verbose , env , insn , env -> allow_ptr_leaks ) ; } err = ext_analyzer_insn_hook ( env , insn_idx , prev_insn_idx ) ; if ( err ) return err ; regs = cur_regs ( env ) ; <S2SV_StartBug> if ( class == BPF_ALU || class == BPF_ALU64 ) { <S2SV_EndBug> err = check_alu_op ( env , insn ) ; if ( err ) return err ; } else if ( class == BPF_LDX ) { enum bpf_reg_type * prev_src_type , src_reg_type ; err = check_reg_arg ( env , insn -> src_reg , SRC_OP ) ; if ( err ) return err ; err = check_reg_arg ( env , insn -> dst_reg , DST_OP_NO_MARK ) ; if ( err ) return err ; src_reg_type = regs [ insn -> src_reg ] . type ; err = check_mem_access ( env , insn_idx , insn -> src_reg , insn -> off , BPF_SIZE ( insn -> code ) , BPF_READ , insn -> dst_reg ) ; if ( err ) return err ; prev_src_type = & env -> insn_aux_data [ insn_idx ] . ptr_type ; if ( * prev_src_type == NOT_INIT ) { * prev_src_type = src_reg_type ; } else if ( src_reg_type != * prev_src_type && ( src_reg_type == PTR_TO_CTX || * prev_src_type == PTR_TO_CTX ) ) { verbose ( env , "same<S2SV_blank>insn<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>used<S2SV_blank>with<S2SV_blank>different<S2SV_blank>pointers\\n" ) ; return - EINVAL ; } } else if ( class == BPF_STX ) { enum bpf_reg_type * prev_dst_type , dst_reg_type ; if ( BPF_MODE ( insn -> code ) == BPF_XADD ) { err = check_xadd ( env , insn_idx , insn ) ; if ( err ) return err ; insn_idx ++ ; continue ; } err = check_reg_arg ( env , insn -> src_reg , SRC_OP ) ; if ( err ) return err ; err = check_reg_arg ( env , insn -> dst_reg , SRC_OP ) ; if ( err ) return err ; dst_reg_type = regs [ insn -> dst_reg ] . type ; err = check_mem_access ( env , insn_idx , insn -> dst_reg , insn -> off , BPF_SIZE ( insn -> code ) , BPF_WRITE , insn -> src_reg ) ; if ( err ) return err ; prev_dst_type = & env -> insn_aux_data [ insn_idx ] . ptr_type ; if ( * prev_dst_type == NOT_INIT ) { * prev_dst_type = dst_reg_type ; } else if ( dst_reg_type != * prev_dst_type && ( dst_reg_type == PTR_TO_CTX || * prev_dst_type == PTR_TO_CTX ) ) { verbose ( env , "same<S2SV_blank>insn<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>used<S2SV_blank>with<S2SV_blank>different<S2SV_blank>pointers\\n" ) ; return - EINVAL ; } } else if ( class == BPF_ST ) { if ( BPF_MODE ( insn -> code ) != BPF_MEM || insn -> src_reg != BPF_REG_0 ) { verbose ( env , "BPF_ST<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n" ) ; return - EINVAL ; } err = check_reg_arg ( env , insn -> dst_reg , SRC_OP ) ; if ( err ) return err ; err = check_mem_access ( env , insn_idx , insn -> dst_reg , insn -> off , BPF_SIZE ( insn -> code ) , BPF_WRITE , - 1 ) ; if ( err ) return err ; } else if ( class == BPF_JMP ) { u8 opcode = BPF_OP ( insn -> code ) ; if ( opcode == BPF_CALL ) { if ( BPF_SRC ( insn -> code ) != BPF_K || insn -> off != 0 || insn -> src_reg != BPF_REG_0 || insn -> dst_reg != BPF_REG_0 ) { verbose ( env , "BPF_CALL<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n" ) ; return - EINVAL ; } err = check_call ( env , insn -> imm , insn_idx ) ; if ( err ) return err ; } else if ( opcode == BPF_JA ) { if ( BPF_SRC ( insn -> code ) != BPF_K || insn -> imm != 0 || insn -> src_reg != BPF_REG_0 || insn -> dst_reg != BPF_REG_0 ) { verbose ( env , "BPF_JA<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n" ) ; return - EINVAL ; } insn_idx += insn -> off + 1 ; continue ; } else if ( opcode == BPF_EXIT ) { if ( BPF_SRC ( insn -> code ) != BPF_K || insn -> imm != 0 || insn -> src_reg != BPF_REG_0 || insn -> dst_reg != BPF_REG_0 ) { verbose ( env , "BPF_EXIT<S2SV_blank>uses<S2SV_blank>reserved<S2SV_blank>fields\\n" ) ; return - EINVAL ; } err = check_reg_arg ( env , BPF_REG_0 , SRC_OP ) ; if ( err ) return err ; if ( is_pointer_value ( env , BPF_REG_0 ) ) { verbose ( env , "R0<S2SV_blank>leaks<S2SV_blank>addr<S2SV_blank>as<S2SV_blank>return<S2SV_blank>value\\n" ) ; return - EACCES ; } err = check_return_code ( env ) ; if ( err ) return err ; process_bpf_exit : err = pop_stack ( env , & prev_insn_idx , & insn_idx ) ; if ( err < 0 ) { if ( err != - ENOENT ) return err ; break ; } else { do_print_state = true ; continue ; } } else { err = check_cond_jmp_op ( env , insn , & insn_idx ) ; if ( err ) return err ; } } else if ( class == BPF_LD ) { u8 mode = BPF_MODE ( insn -> code ) ; if ( mode == BPF_ABS || mode == BPF_IND ) { err = check_ld_abs ( env , insn ) ; if ( err ) return err ; } else if ( mode == BPF_IMM ) { err = check_ld_imm ( env , insn ) ; if ( err ) return err ; insn_idx ++ ; <S2SV_StartBug> } else { <S2SV_EndBug> verbose ( env , "invalid<S2SV_blank>BPF_LD<S2SV_blank>mode\\n" ) ; return - EINVAL ; } } else { verbose ( env , "unknown<S2SV_blank>insn<S2SV_blank>class<S2SV_blank>%d\\n" , class ) ; return - EINVAL ; } insn_idx ++ ; } verbose ( env , "processed<S2SV_blank>%d<S2SV_blank>insns,<S2SV_blank>stack<S2SV_blank>depth<S2SV_blank>%d\\n" , insn_processed , env -> prog -> aux -> stack_depth ) ; return 0 ; }
void jas_matrix_divpow2 ( jas_matrix_t * matrix , int n ) { <S2SV_StartBug> int i ; <S2SV_EndBug> int j ; jas_seqent_t * rowstart ; <S2SV_StartBug> int rowstep ; <S2SV_EndBug> jas_seqent_t * data ; if ( jas_matrix_numrows ( matrix ) > 0 && jas_matrix_numcols ( matrix ) > 0 ) { assert ( matrix -> rows_ ) ; rowstep = jas_matrix_rowstep ( matrix ) ; for ( i = matrix -> numrows_ , rowstart = matrix -> rows_ [ 0 ] ; i > 0 ; -- i , rowstart += rowstep ) { for ( j = matrix -> numcols_ , data = rowstart ; j > 0 ; -- j , ++ data ) { * data = ( * data >= 0 ) ? ( ( * data ) >> n ) : ( - ( ( - ( * data ) ) >> n ) ) ; } } } }
void Huff_Compress ( msg_t * mbuf , int offset ) { int i , ch , size ; byte seq [ 65536 ] ; byte * buffer ; huff_t huff ; size = mbuf -> cursize - offset ; buffer = mbuf -> data + + offset ; if ( size <= 0 ) { return ; } Com_Memset ( & huff , 0 , sizeof ( huff_t ) ) ; huff . tree = huff . lhead = huff . loc [ NYT ] = & ( huff . nodeList [ huff . blocNode ++ ] ) ; huff . tree -> symbol = NYT ; huff . tree -> weight = 0 ; huff . lhead -> next = huff . lhead -> prev = NULL ; huff . tree -> parent = huff . tree -> left = huff . tree -> right = NULL ; seq [ 0 ] = ( size >> 8 ) ; seq [ 1 ] = size & 0xff ; bloc = 16 ; for ( i = 0 ; i < size ; i ++ ) { ch = buffer [ i ] ; <S2SV_StartBug> Huff_transmit ( & huff , ch , seq ) ; <S2SV_EndBug> Huff_addRef ( & huff , ( byte ) ch ) ; } bloc += 8 ; mbuf -> cursize = ( bloc >> 3 ) + offset ; Com_Memcpy ( mbuf -> data + offset , seq , ( bloc >> 3 ) ) ; }
static copyFunc pickCopyFunc ( TIFF * in , TIFF * out , uint16 bitspersample , uint16 samplesperpixel ) { uint16 shortv ; uint32 w , l , tw , tl ; int bychunk ; <S2SV_StartBug> ( void ) TIFFGetField ( in , TIFFTAG_PLANARCONFIG , & shortv ) ; <S2SV_EndBug> if ( shortv != config && bitspersample != 8 && samplesperpixel > 1 ) { fprintf ( stderr , "%s:<S2SV_blank>Cannot<S2SV_blank>handle<S2SV_blank>different<S2SV_blank>planar<S2SV_blank>configuration<S2SV_blank>w/<S2SV_blank>bits/sample<S2SV_blank>!=<S2SV_blank>8\\n" , TIFFFileName ( in ) ) ; return ( NULL ) ; } TIFFGetField ( in , TIFFTAG_IMAGEWIDTH , & w ) ; TIFFGetField ( in , TIFFTAG_IMAGELENGTH , & l ) ; if ( ! ( TIFFIsTiled ( out ) || TIFFIsTiled ( in ) ) ) { uint32 irps = ( uint32 ) - 1L ; TIFFGetField ( in , TIFFTAG_ROWSPERSTRIP , & irps ) ; bychunk = ! bias && ( rowsperstrip == irps ) ; } else { if ( bias ) { fprintf ( stderr , "%s:<S2SV_blank>Cannot<S2SV_blank>handle<S2SV_blank>tiled<S2SV_blank>configuration<S2SV_blank>w/bias<S2SV_blank>image\\n" , TIFFFileName ( in ) ) ; return ( NULL ) ; } if ( TIFFIsTiled ( out ) ) { if ( ! TIFFGetField ( in , TIFFTAG_TILEWIDTH , & tw ) ) tw = w ; if ( ! TIFFGetField ( in , TIFFTAG_TILELENGTH , & tl ) ) tl = l ; bychunk = ( tw == tilewidth && tl == tilelength ) ; } else { TIFFGetField ( in , TIFFTAG_TILEWIDTH , & tw ) ; TIFFGetField ( in , TIFFTAG_TILELENGTH , & tl ) ; bychunk = ( tw == w && tl == rowsperstrip ) ; } } # define T 1 # define F 0 # define pack ( a , b , c , d , e ) ( ( long ) ( ( ( a ) << 11 ) | ( ( b ) << 3 ) | ( ( c ) << 2 ) | ( ( d ) << 1 ) | ( e ) ) ) switch ( pack ( shortv , config , TIFFIsTiled ( in ) , TIFFIsTiled ( out ) , bychunk ) ) { case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_CONTIG , F , T , F ) : case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_CONTIG , F , T , T ) : return cpContigStrips2ContigTiles ; case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_SEPARATE , F , T , F ) : case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_SEPARATE , F , T , T ) : return cpContigStrips2SeparateTiles ; case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_CONTIG , F , T , F ) : case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_CONTIG , F , T , T ) : return cpSeparateStrips2ContigTiles ; case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_SEPARATE , F , T , F ) : case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_SEPARATE , F , T , T ) : return cpSeparateStrips2SeparateTiles ; case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_CONTIG , T , T , F ) : case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_CONTIG , T , T , T ) : return cpContigTiles2ContigTiles ; case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_SEPARATE , T , T , F ) : case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_SEPARATE , T , T , T ) : return cpContigTiles2SeparateTiles ; case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_CONTIG , T , T , F ) : case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_CONTIG , T , T , T ) : return cpSeparateTiles2ContigTiles ; case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_SEPARATE , T , T , F ) : case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_SEPARATE , T , T , T ) : return cpSeparateTiles2SeparateTiles ; case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_CONTIG , T , F , F ) : case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_CONTIG , T , F , T ) : return cpContigTiles2ContigStrips ; case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_SEPARATE , T , F , F ) : case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_SEPARATE , T , F , T ) : return cpContigTiles2SeparateStrips ; case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_CONTIG , T , F , F ) : case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_CONTIG , T , F , T ) : return cpSeparateTiles2ContigStrips ; case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_SEPARATE , T , F , F ) : case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_SEPARATE , T , F , T ) : return cpSeparateTiles2SeparateStrips ; case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_CONTIG , F , F , F ) : return bias ? cpBiasedContig2Contig : cpContig2ContigByRow ; case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_CONTIG , F , F , T ) : return cpDecodedStrips ; case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_SEPARATE , F , F , F ) : case pack ( PLANARCONFIG_CONTIG , PLANARCONFIG_SEPARATE , F , F , T ) : return cpContig2SeparateByRow ; case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_CONTIG , F , F , F ) : case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_CONTIG , F , F , T ) : return cpSeparate2ContigByRow ; case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_SEPARATE , F , F , F ) : case pack ( PLANARCONFIG_SEPARATE , PLANARCONFIG_SEPARATE , F , F , T ) : return cpSeparate2SeparateByRow ; } # undef pack # undef F # undef T fprintf ( stderr , "tiffcp:<S2SV_blank>%s:<S2SV_blank>Don\'t<S2SV_blank>know<S2SV_blank>how<S2SV_blank>to<S2SV_blank>copy/convert<S2SV_blank>image.\\n" , TIFFFileName ( in ) ) ; return ( NULL ) ; }
static Image * ReadPICTImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { <S2SV_StartBug> # define ThrowPICTException ( exception , message ) { if ( tile_image != ( Image * ) NULL ) tile_image = DestroyImage ( tile_image ) ; if ( read_info != ( ImageInfo * ) NULL ) read_info = DestroyImageInfo ( read_info ) ; ThrowReaderException ( ( exception ) , ( message ) ) ; } <S2SV_EndBug> char geometry [ MagickPathExtent ] , header_ole [ 4 ] ; Image * image , * tile_image ; ImageInfo * read_info ; int c , code ; MagickBooleanType jpeg , status ; PICTRectangle frame ; PICTPixmap pixmap ; Quantum index ; register Quantum * q ; register ssize_t i , x ; size_t extent , length ; ssize_t count , flags , j , version , y ; StringInfo * profile ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , "%s" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } read_info = ( ImageInfo * ) NULL ; tile_image = ( Image * ) NULL ; pixmap . bits_per_pixel = 0 ; pixmap . component_count = 0 ; header_ole [ 0 ] = ReadBlobByte ( image ) ; header_ole [ 1 ] = ReadBlobByte ( image ) ; header_ole [ 2 ] = ReadBlobByte ( image ) ; header_ole [ 3 ] = ReadBlobByte ( image ) ; if ( ! ( ( header_ole [ 0 ] == 0x50 ) && ( header_ole [ 1 ] == 0x49 ) && ( header_ole [ 2 ] == 0x43 ) && ( header_ole [ 3 ] == 0x54 ) ) ) for ( i = 0 ; i < 508 ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; ( void ) ReadBlobMSBShort ( image ) ; if ( ReadRectangle ( image , & frame ) == MagickFalse ) ThrowPICTException ( CorruptImageError , "ImproperImageHeader" ) ; while ( ( c = ReadBlobByte ( image ) ) == 0 ) ; if ( c != 0x11 ) ThrowPICTException ( CorruptImageError , "ImproperImageHeader" ) ; version = ( ssize_t ) ReadBlobByte ( image ) ; if ( version == 2 ) { c = ReadBlobByte ( image ) ; if ( c != 0xff ) ThrowPICTException ( CorruptImageError , "ImproperImageHeader" ) ; } else if ( version != 1 ) ThrowPICTException ( CorruptImageError , "ImproperImageHeader" ) ; if ( ( frame . left < 0 ) || ( frame . right < 0 ) || ( frame . top < 0 ) || ( frame . bottom < 0 ) || ( frame . left >= frame . right ) || ( frame . top >= frame . bottom ) ) ThrowPICTException ( CorruptImageError , "ImproperImageHeader" ) ; flags = 0 ; image -> depth = 8 ; image -> columns = ( size_t ) ( frame . right - frame . left ) ; image -> rows = ( size_t ) ( frame . bottom - frame . top ) ; image -> resolution . x = DefaultResolution ; image -> resolution . y = DefaultResolution ; image -> units = UndefinedResolution ; if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) { ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; } status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status != MagickFalse ) status = ResetImagePixels ( image , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; jpeg = MagickFalse ; for ( code = 0 ; EOFBlob ( image ) == MagickFalse ; ) { if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; if ( ( version == 1 ) || ( ( TellBlob ( image ) % 2 ) != 0 ) ) code = ReadBlobByte ( image ) ; if ( version == 2 ) code = ReadBlobMSBSignedShort ( image ) ; if ( code < 0 ) break ; if ( code == 0 ) continue ; if ( code > 0xa1 ) { if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "%04X:" , code ) ; } else { if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , "<S2SV_blank><S2SV_blank>%04X<S2SV_blank>%s:<S2SV_blank>%s" , code , codes [ code ] . name , codes [ code ] . description ) ; switch ( code ) { case 0x01 : { length = ReadBlobMSBShort ( image ) ; <S2SV_StartBug> if ( length != 0x000a ) <S2SV_EndBug> { for ( i = 0 ; i < ( ssize_t ) ( length - 2 ) ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; break ; } if ( ReadRectangle ( image , & frame ) == MagickFalse ) ThrowPICTException ( CorruptImageError , "ImproperImageHeader" ) ; if ( ( ( frame . left & 0x8000 ) != 0 ) || ( ( frame . top & 0x8000 ) != 0 ) ) break ; image -> columns = ( size_t ) ( frame . right - frame . left ) ; image -> rows = ( size_t ) ( frame . bottom - frame . top ) ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status != MagickFalse ) status = ResetImagePixels ( image , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; break ; } case 0x12 : case 0x13 : case 0x14 : { ssize_t pattern ; size_t height , width ; pattern = ( ssize_t ) ReadBlobMSBShort ( image ) ; for ( i = 0 ; i < 8 ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; if ( pattern == 2 ) { for ( i = 0 ; i < 5 ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; break ; } if ( pattern != 1 ) ThrowPICTException ( CorruptImageError , "UnknownPatternType" ) ; length = ReadBlobMSBShort ( image ) ; <S2SV_StartBug> if ( ReadRectangle ( image , & frame ) == MagickFalse ) <S2SV_EndBug> ThrowPICTException ( CorruptImageError , "ImproperImageHeader" ) ; if ( ReadPixmap ( image , & pixmap ) == MagickFalse ) ThrowPICTException ( CorruptImageError , "ImproperImageHeader" ) ; image -> depth = ( size_t ) pixmap . component_size ; image -> resolution . x = 1.0 * pixmap . horizontal_resolution ; image -> resolution . y = 1.0 * pixmap . vertical_resolution ; image -> units = PixelsPerInchResolution ; ( void ) ReadBlobMSBLong ( image ) ; flags = ( ssize_t ) ReadBlobMSBShort ( image ) ; <S2SV_StartBug> length = ReadBlobMSBShort ( image ) ; <S2SV_EndBug> for ( i = 0 ; i <= ( ssize_t ) length ; i ++ ) ( void ) ReadBlobMSBLong ( image ) ; width = ( size_t ) ( frame . bottom - frame . top ) ; height = ( size_t ) ( frame . right - frame . left ) ; if ( pixmap . bits_per_pixel <= 8 ) length &= 0x7fff ; if ( pixmap . bits_per_pixel == 16 ) width <<= 1 ; if ( length == 0 ) length = width ; if ( length < 8 ) { for ( i = 0 ; i < ( ssize_t ) ( length * height ) ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; } else for ( i = 0 ; i < ( ssize_t ) height ; i ++ ) { if ( EOFBlob ( image ) != MagickFalse ) break ; if ( length > 200 ) { for ( j = 0 ; j < ( ssize_t ) ReadBlobMSBShort ( image ) ; j ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; } else for ( j = 0 ; j < ( ssize_t ) ReadBlobByte ( image ) ; j ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; } break ; } case 0x1b : { image -> background_color . red = ( Quantum ) ScaleShortToQuantum ( ReadBlobMSBShort ( image ) ) ; image -> background_color . green = ( Quantum ) ScaleShortToQuantum ( ReadBlobMSBShort ( image ) ) ; image -> background_color . blue = ( Quantum ) ScaleShortToQuantum ( ReadBlobMSBShort ( image ) ) ; break ; } case 0x70 : case 0x71 : case 0x72 : case 0x73 : case 0x74 : case 0x75 : case 0x76 : case 0x77 : { <S2SV_StartBug> length = ReadBlobMSBShort ( image ) ; <S2SV_EndBug> for ( i = 0 ; i < ( ssize_t ) ( length - 2 ) ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; break ; } case 0x90 : case 0x91 : case 0x98 : case 0x99 : case 0x9a : case 0x9b : { PICTRectangle source , destination ; register unsigned char * p ; size_t j ; ssize_t bytes_per_line ; unsigned char * pixels ; bytes_per_line = 0 ; if ( ( code != 0x9a ) && ( code != 0x9b ) ) bytes_per_line = ( ssize_t ) ReadBlobMSBShort ( image ) ; else { ( void ) ReadBlobMSBShort ( image ) ; ( void ) ReadBlobMSBShort ( image ) ; ( void ) ReadBlobMSBShort ( image ) ; } if ( ReadRectangle ( image , & frame ) == MagickFalse ) ThrowPICTException ( CorruptImageError , "ImproperImageHeader" ) ; tile_image = CloneImage ( image , ( size_t ) ( frame . right - frame . left ) , ( size_t ) ( frame . bottom - frame . top ) , MagickTrue , exception ) ; if ( tile_image == ( Image * ) NULL ) ThrowPICTException ( CorruptImageError , "ImproperImageHeader" ) ; if ( ( code == 0x9a ) || ( code == 0x9b ) || ( ( bytes_per_line & 0x8000 ) != 0 ) ) { if ( ReadPixmap ( image , & pixmap ) == MagickFalse ) ThrowPICTException ( CorruptImageError , "ImproperImageHeader" ) ; tile_image -> depth = ( size_t ) pixmap . component_size ; tile_image -> alpha_trait = pixmap . component_count == 4 ? BlendPixelTrait : UndefinedPixelTrait ; tile_image -> resolution . x = ( double ) pixmap . horizontal_resolution ; tile_image -> resolution . y = ( double ) pixmap . vertical_resolution ; tile_image -> units = PixelsPerInchResolution ; if ( tile_image -> alpha_trait != UndefinedPixelTrait ) ( void ) SetImageAlpha ( tile_image , OpaqueAlpha , exception ) ; } if ( ( code != 0x9a ) && ( code != 0x9b ) ) { tile_image -> colors = 2 ; if ( ( bytes_per_line & 0x8000 ) != 0 ) { ( void ) ReadBlobMSBLong ( image ) ; flags = ( ssize_t ) ReadBlobMSBShort ( image ) ; tile_image -> colors = 1UL * ReadBlobMSBShort ( image ) + 1 ; } status = AcquireImageColormap ( tile_image , tile_image -> colors , exception ) ; if ( status == MagickFalse ) ThrowPICTException ( ResourceLimitError , "MemoryAllocationFailed" ) ; if ( ( bytes_per_line & 0x8000 ) != 0 ) { for ( i = 0 ; i < ( ssize_t ) tile_image -> colors ; i ++ ) { j = ReadBlobMSBShort ( image ) % tile_image -> colors ; if ( ( flags & 0x8000 ) != 0 ) j = ( size_t ) i ; tile_image -> colormap [ j ] . red = ( Quantum ) ScaleShortToQuantum ( ReadBlobMSBShort ( image ) ) ; tile_image -> colormap [ j ] . green = ( Quantum ) ScaleShortToQuantum ( ReadBlobMSBShort ( image ) ) ; tile_image -> colormap [ j ] . blue = ( Quantum ) ScaleShortToQuantum ( ReadBlobMSBShort ( image ) ) ; } } else { for ( i = 0 ; i < ( ssize_t ) tile_image -> colors ; i ++ ) { tile_image -> colormap [ i ] . red = ( Quantum ) ( QuantumRange - tile_image -> colormap [ i ] . red ) ; tile_image -> colormap [ i ] . green = ( Quantum ) ( QuantumRange - tile_image -> colormap [ i ] . green ) ; tile_image -> colormap [ i ] . blue = ( Quantum ) ( QuantumRange - tile_image -> colormap [ i ] . blue ) ; } } } if ( EOFBlob ( image ) != MagickFalse ) ThrowPICTException ( CorruptImageError , "InsufficientImageDataInFile" ) ; if ( ReadRectangle ( image , & source ) == MagickFalse ) ThrowPICTException ( CorruptImageError , "ImproperImageHeader" ) ; if ( ReadRectangle ( image , & destination ) == MagickFalse ) ThrowPICTException ( CorruptImageError , "ImproperImageHeader" ) ; ( void ) ReadBlobMSBShort ( image ) ; if ( ( code == 0x91 ) || ( code == 0x99 ) || ( code == 0x9b ) ) { <S2SV_StartBug> length = ReadBlobMSBShort ( image ) ; <S2SV_EndBug> for ( i = 0 ; i < ( ssize_t ) ( length - 2 ) ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; } if ( ( code != 0x9a ) && ( code != 0x9b ) && ( bytes_per_line & 0x8000 ) == 0 ) pixels = DecodeImage ( image , tile_image , ( size_t ) bytes_per_line , 1 , & extent ) ; else pixels = DecodeImage ( image , tile_image , ( size_t ) bytes_per_line , ( unsigned int ) pixmap . bits_per_pixel , & extent ) ; if ( pixels == ( unsigned char * ) NULL ) ThrowPICTException ( CorruptImageError , "UnableToUncompressImage" ) ; p = pixels ; for ( y = 0 ; y < ( ssize_t ) tile_image -> rows ; y ++ ) { if ( p > ( pixels + extent + image -> columns ) ) { pixels = ( unsigned char * ) RelinquishMagickMemory ( pixels ) ; ThrowPICTException ( CorruptImageError , "NotEnoughPixelData" ) ; } q = QueueAuthenticPixels ( tile_image , 0 , y , tile_image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) tile_image -> columns ; x ++ ) { if ( tile_image -> storage_class == PseudoClass ) { index = ( Quantum ) ConstrainColormapIndex ( tile_image , ( ssize_t ) * p , exception ) ; SetPixelIndex ( tile_image , index , q ) ; SetPixelRed ( tile_image , tile_image -> colormap [ ( ssize_t ) index ] . red , q ) ; SetPixelGreen ( tile_image , tile_image -> colormap [ ( ssize_t ) index ] . green , q ) ; SetPixelBlue ( tile_image , tile_image -> colormap [ ( ssize_t ) index ] . blue , q ) ; } else { if ( pixmap . bits_per_pixel == 16 ) { i = ( ssize_t ) ( * p ++ ) ; j = ( size_t ) ( * p ) ; SetPixelRed ( tile_image , ScaleCharToQuantum ( ( unsigned char ) ( ( i & 0x7c ) << 1 ) ) , q ) ; SetPixelGreen ( tile_image , ScaleCharToQuantum ( ( unsigned char ) ( ( ( i & 0x03 ) << 6 ) | ( ( j & 0xe0 ) >> 2 ) ) ) , q ) ; SetPixelBlue ( tile_image , ScaleCharToQuantum ( ( unsigned char ) ( ( j & 0x1f ) << 3 ) ) , q ) ; } else if ( tile_image -> alpha_trait == UndefinedPixelTrait ) { if ( p > ( pixels + extent + 2 * image -> columns ) ) ThrowPICTException ( CorruptImageError , "NotEnoughPixelData" ) ; SetPixelRed ( tile_image , ScaleCharToQuantum ( * p ) , q ) ; SetPixelGreen ( tile_image , ScaleCharToQuantum ( * ( p + tile_image -> columns ) ) , q ) ; SetPixelBlue ( tile_image , ScaleCharToQuantum ( * ( p + 2 * tile_image -> columns ) ) , q ) ; } else { if ( p > ( pixels + extent + 3 * image -> columns ) ) ThrowPICTException ( CorruptImageError , "NotEnoughPixelData" ) ; SetPixelAlpha ( tile_image , ScaleCharToQuantum ( * p ) , q ) ; SetPixelRed ( tile_image , ScaleCharToQuantum ( * ( p + tile_image -> columns ) ) , q ) ; SetPixelGreen ( tile_image , ScaleCharToQuantum ( * ( p + 2 * tile_image -> columns ) ) , q ) ; SetPixelBlue ( tile_image , ScaleCharToQuantum ( * ( p + 3 * tile_image -> columns ) ) , q ) ; } } p ++ ; q += GetPixelChannels ( tile_image ) ; } if ( SyncAuthenticPixels ( tile_image , exception ) == MagickFalse ) break ; if ( ( tile_image -> storage_class == DirectClass ) && ( pixmap . bits_per_pixel != 16 ) ) { p += ( pixmap . component_count - 1 ) * tile_image -> columns ; if ( p < pixels ) break ; } status = SetImageProgress ( image , LoadImageTag , ( MagickOffsetType ) y , tile_image -> rows ) ; if ( status == MagickFalse ) break ; } pixels = ( unsigned char * ) RelinquishMagickMemory ( pixels ) ; if ( ( jpeg == MagickFalse ) && ( EOFBlob ( image ) == MagickFalse ) ) if ( ( code == 0x9a ) || ( code == 0x9b ) || ( ( bytes_per_line & 0x8000 ) != 0 ) ) ( void ) CompositeImage ( image , tile_image , CopyCompositeOp , MagickTrue , ( ssize_t ) destination . left , ( ssize_t ) destination . top , exception ) ; tile_image = DestroyImage ( tile_image ) ; break ; } case 0xa1 : { unsigned char * info ; size_t type ; type = ReadBlobMSBShort ( image ) ; length = ReadBlobMSBShort ( image ) ; <S2SV_StartBug> if ( length == 0 ) <S2SV_EndBug> break ; ( void ) ReadBlobMSBLong ( image ) ; length -= MagickMin ( length , 4 ) ; if ( length == 0 ) break ; info = ( unsigned char * ) AcquireQuantumMemory ( length , sizeof ( * info ) ) ; if ( info == ( unsigned char * ) NULL ) break ; count = ReadBlob ( image , length , info ) ; if ( count != ( ssize_t ) length ) { info = ( unsigned char * ) RelinquishMagickMemory ( info ) ; ThrowPICTException ( ResourceLimitError , "UnableToReadImageData" ) ; } switch ( type ) { case 0xe0 : { profile = BlobToStringInfo ( ( const void * ) NULL , length ) ; SetStringInfoDatum ( profile , info ) ; status = SetImageProfile ( image , "icc" , profile , exception ) ; profile = DestroyStringInfo ( profile ) ; if ( status == MagickFalse ) { info = ( unsigned char * ) RelinquishMagickMemory ( info ) ; ThrowPICTException ( ResourceLimitError , "MemoryAllocationFailed" ) ; } break ; } case 0x1f2 : { profile = BlobToStringInfo ( ( const void * ) NULL , length ) ; SetStringInfoDatum ( profile , info ) ; status = SetImageProfile ( image , "iptc" , profile , exception ) ; if ( status == MagickFalse ) { info = ( unsigned char * ) RelinquishMagickMemory ( info ) ; ThrowPICTException ( ResourceLimitError , "MemoryAllocationFailed" ) ; } profile = DestroyStringInfo ( profile ) ; break ; } default : break ; } info = ( unsigned char * ) RelinquishMagickMemory ( info ) ; break ; } default : { if ( codes [ code ] . length == - 1 ) ( void ) ReadBlobMSBShort ( image ) ; else for ( i = 0 ; i < ( ssize_t ) codes [ code ] . length ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; } } } if ( code == 0xc00 ) { for ( i = 0 ; i < 24 ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; continue ; } if ( ( ( code >= 0xb0 ) && ( code <= 0xcf ) ) || ( ( code >= 0x8000 ) && ( code <= 0x80ff ) ) ) continue ; if ( code == 0x8200 ) { char filename [ MaxTextExtent ] ; FILE * file ; int unique_file ; jpeg = MagickTrue ; read_info = CloneImageInfo ( image_info ) ; SetImageInfoBlob ( read_info , ( void * ) NULL , 0 ) ; file = ( FILE * ) NULL ; unique_file = AcquireUniqueFileResource ( filename ) ; ( void ) FormatLocaleString ( read_info -> filename , MaxTextExtent , "jpeg:%s" , filename ) ; if ( unique_file != - 1 ) file = fdopen ( unique_file , "wb" ) ; if ( ( unique_file == - 1 ) || ( file == ( FILE * ) NULL ) ) { ( void ) RelinquishUniqueFileResource ( read_info -> filename ) ; ( void ) CopyMagickString ( image -> filename , read_info -> filename , MagickPathExtent ) ; ThrowPICTException ( FileOpenError , "UnableToCreateTemporaryFile" ) ; } length = ReadBlobMSBLong ( image ) ; <S2SV_StartBug> if ( length > 154 ) <S2SV_EndBug> { for ( i = 0 ; i < 6 ; i ++ ) ( void ) ReadBlobMSBLong ( image ) ; if ( ReadRectangle ( image , & frame ) == MagickFalse ) { ( void ) fclose ( file ) ; ( void ) RelinquishUniqueFileResource ( read_info -> filename ) ; ThrowPICTException ( CorruptImageError , "ImproperImageHeader" ) ; } for ( i = 0 ; i < 122 ; i ++ ) if ( ReadBlobByte ( image ) == EOF ) break ; for ( i = 0 ; i < ( ssize_t ) ( length - 154 ) ; i ++ ) { c = ReadBlobByte ( image ) ; if ( c == EOF ) break ; if ( fputc ( c , file ) != c ) break ; } } ( void ) fclose ( file ) ; ( void ) close ( unique_file ) ; tile_image = ReadImage ( read_info , exception ) ; ( void ) RelinquishUniqueFileResource ( filename ) ; read_info = DestroyImageInfo ( read_info ) ; if ( tile_image == ( Image * ) NULL ) continue ; ( void ) FormatLocaleString ( geometry , MagickPathExtent , "%.20gx%.20g" , ( double ) MagickMax ( image -> columns , tile_image -> columns ) , ( double ) MagickMax ( image -> rows , tile_image -> rows ) ) ; ( void ) SetImageExtent ( image , MagickMax ( image -> columns , tile_image -> columns ) , MagickMax ( image -> rows , tile_image -> rows ) , exception ) ; ( void ) TransformImageColorspace ( image , tile_image -> colorspace , exception ) ; ( void ) CompositeImage ( image , tile_image , CopyCompositeOp , MagickTrue , ( ssize_t ) frame . left , ( ssize_t ) frame . right , exception ) ; image -> compression = tile_image -> compression ; tile_image = DestroyImage ( tile_image ) ; continue ; } if ( ( code == 0xff ) || ( code == 0xffff ) ) break ; if ( ( ( code >= 0xd0 ) && ( code <= 0xfe ) ) || ( ( code >= 0x8100 ) && ( code <= 0xffff ) ) ) { length = ReadBlobMSBShort ( image ) ; <S2SV_StartBug> for ( i = 0 ; i < ( ssize_t ) length ; i ++ ) <S2SV_EndBug> if ( ReadBlobByte ( image ) == EOF ) break ; continue ; } if ( ( code >= 0x100 ) && ( code <= 0x7fff ) ) { length = ( size_t ) ( ( code >> 7 ) & 0xff ) ; <S2SV_StartBug> for ( i = 0 ; i < ( ssize_t ) length ; i ++ ) <S2SV_EndBug> if ( ReadBlobByte ( image ) == EOF ) break ; continue ; } } ( void ) CloseBlob ( image ) ; return ( GetFirstImageInList ( image ) ) ; }
stmt_ty <S2SV_StartBug> Assign ( asdl_seq * targets , expr_ty value , int lineno , int col_offset , int <S2SV_EndBug> end_lineno , int end_col_offset , PyArena * arena ) { stmt_ty p ; if ( ! value ) { PyErr_SetString ( PyExc_ValueError , "field<S2SV_blank>value<S2SV_blank>is<S2SV_blank>required<S2SV_blank>for<S2SV_blank>Assign" ) ; return NULL ; } p = ( stmt_ty ) PyArena_Malloc ( arena , sizeof ( * p ) ) ; if ( ! p ) return NULL ; p -> kind = Assign_kind ; p -> v . Assign . targets = targets ; p -> v . Assign . value = value ; <S2SV_StartBug> p -> lineno = lineno ; <S2SV_EndBug> p -> col_offset = col_offset ; p -> end_lineno = end_lineno ; p -> end_col_offset = end_col_offset ; return p ; }
static void WritePixel ( struct ngiflib_img * i , struct ngiflib_decode_context * context , u8 v ) { struct ngiflib_gif * p = i -> parent ; if ( v != i -> gce . transparent_color || ! i -> gce . transparent_flag ) { # ifndef NGIFLIB_INDEXED_ONLY if ( p -> mode & NGIFLIB_MODE_INDEXED ) { # endif * context -> frbuff_p . p8 = v ; # ifndef NGIFLIB_INDEXED_ONLY } else * context -> frbuff_p . p32 = GifIndexToTrueColor ( i -> palette , v ) ; # endif } if ( -- ( context -> Xtogo ) <= 0 ) { # ifdef NGIFLIB_ENABLE_CALLBACKS if ( p -> line_cb ) p -> line_cb ( p , context -> line_p , context -> curY ) ; # endif context -> Xtogo = i -> width ; switch ( context -> pass ) { case 0 : context -> curY ++ ; break ; case 1 : context -> curY += 8 ; <S2SV_StartBug> if ( context -> curY >= p -> height ) { <S2SV_EndBug> context -> pass ++ ; context -> curY = i -> posY + 4 ; } break ; case 2 : context -> curY += 8 ; <S2SV_StartBug> if ( context -> curY >= p -> height ) { <S2SV_EndBug> context -> pass ++ ; context -> curY = i -> posY + 2 ; } break ; case 3 : context -> curY += 4 ; <S2SV_StartBug> if ( context -> curY >= p -> height ) { <S2SV_EndBug> context -> pass ++ ; context -> curY = i -> posY + 1 ; } break ; case 4 : context -> curY += 2 ; <S2SV_StartBug> break ; <S2SV_EndBug> } # ifndef NGIFLIB_INDEXED_ONLY if ( p -> mode & NGIFLIB_MODE_INDEXED ) { # endif # ifdef NGIFLIB_ENABLE_CALLBACKS context -> line_p . p8 = p -> frbuff . p8 + ( u32 ) context -> curY * p -> width ; context -> frbuff_p . p8 = context -> line_p . p8 + i -> posX ; # else context -> frbuff_p . p8 = p -> frbuff . p8 + ( u32 ) context -> curY * p -> width + i -> posX ; # endif # ifndef NGIFLIB_INDEXED_ONLY } else { # ifdef NGIFLIB_ENABLE_CALLBACKS context -> line_p . p32 = p -> frbuff . p32 + ( u32 ) context -> curY * p -> width ; context -> frbuff_p . p32 = context -> line_p . p32 + i -> posX ; # else context -> frbuff_p . p32 = p -> frbuff . p32 + ( u32 ) context -> curY * p -> width + i -> posX ; # endif } # endif } else { # ifndef NGIFLIB_INDEXED_ONLY if ( p -> mode & NGIFLIB_MODE_INDEXED ) { # endif context -> frbuff_p . p8 ++ ; # ifndef NGIFLIB_INDEXED_ONLY } else { context -> frbuff_p . p32 ++ ; } # endif } }
static void do_perf_sw_event ( enum perf_type_id type , u32 event_id , <S2SV_StartBug> u64 nr , int nmi , <S2SV_EndBug> struct perf_sample_data * data , struct pt_regs * regs ) { struct swevent_htable * swhash = & __get_cpu_var ( swevent_htable ) ; struct perf_event * event ; struct hlist_node * node ; struct hlist_head * head ; rcu_read_lock ( ) ; head = find_swevent_head_rcu ( swhash , type , event_id ) ; if ( ! head ) goto end ; hlist_for_each_entry_rcu ( event , node , head , hlist_entry ) { if ( perf_swevent_match ( event , type , event_id , data , regs ) ) <S2SV_StartBug> perf_swevent_event ( event , nr , nmi , data , regs ) ; <S2SV_EndBug> } end : rcu_read_unlock ( ) ; }
<S2SV_StartBug> uint32_t _WM_SetupMidiEvent ( struct _mdi * mdi , uint8_t * event_data , uint8_t running_event ) { <S2SV_EndBug> uint32_t ret_cnt = 0 ; uint8_t command = 0 ; uint8_t channel = 0 ; uint8_t data_1 = 0 ; uint8_t data_2 = 0 ; char * text = NULL ; <S2SV_StartBug> if ( event_data [ 0 ] >= 0x80 ) { <S2SV_EndBug> command = * event_data & 0xf0 ; channel = * event_data ++ & 0x0f ; <S2SV_StartBug> ret_cnt ++ ; <S2SV_EndBug> } else { command = running_event & 0xf0 ; channel = running_event & 0x0f ; } switch ( command ) { case 0x80 : _SETUP_NOTEOFF : <S2SV_StartBug> data_1 = * event_data ++ ; <S2SV_EndBug> data_2 = * event_data ++ ; _WM_midi_setup_noteoff ( mdi , channel , data_1 , data_2 ) ; ret_cnt += 2 ; break ; case 0x90 : if ( event_data [ 1 ] == 0 ) goto _SETUP_NOTEOFF ; <S2SV_StartBug> data_1 = * event_data ++ ; <S2SV_EndBug> data_2 = * event_data ++ ; midi_setup_noteon ( mdi , channel , data_1 , data_2 ) ; ret_cnt += 2 ; break ; case 0xa0 : <S2SV_StartBug> data_1 = * event_data ++ ; <S2SV_EndBug> data_2 = * event_data ++ ; midi_setup_aftertouch ( mdi , channel , data_1 , data_2 ) ; ret_cnt += 2 ; break ; case 0xb0 : <S2SV_StartBug> data_1 = * event_data ++ ; <S2SV_EndBug> data_2 = * event_data ++ ; midi_setup_control ( mdi , channel , data_1 , data_2 ) ; ret_cnt += 2 ; break ; case 0xc0 : data_1 = * event_data ++ ; midi_setup_patch ( mdi , channel , data_1 ) ; ret_cnt ++ ; break ; case 0xd0 : data_1 = * event_data ++ ; midi_setup_channel_pressure ( mdi , channel , data_1 ) ; ret_cnt ++ ; break ; case 0xe0 : <S2SV_StartBug> data_1 = * event_data ++ ; <S2SV_EndBug> data_2 = * event_data ++ ; midi_setup_pitch ( mdi , channel , ( ( data_2 << 7 ) | ( data_1 & 0x7f ) ) ) ; ret_cnt += 2 ; break ; case 0xf0 : if ( channel == 0x0f ) { uint32_t tmp_length = 0 ; if ( ( event_data [ 0 ] == 0x00 ) && ( event_data [ 1 ] == 0x02 ) ) { <S2SV_StartBug> midi_setup_sequenceno ( mdi , ( ( event_data [ 2 ] << 8 ) + event_data [ 3 ] ) ) ; <S2SV_EndBug> ret_cnt += 4 ; } else if ( event_data [ 0 ] == 0x01 ) { event_data ++ ; ret_cnt ++ ; <S2SV_StartBug> if ( * event_data > 0x7f ) { <S2SV_EndBug> <S2SV_StartBug> do { <S2SV_EndBug> tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ; event_data ++ ; <S2SV_StartBug> ret_cnt ++ ; <S2SV_EndBug> } while ( * event_data > 0x7f ) ; <S2SV_StartBug> } <S2SV_EndBug> tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ; event_data ++ ; ret_cnt ++ ; <S2SV_StartBug> text = malloc ( tmp_length + 1 ) ; <S2SV_EndBug> memcpy ( text , event_data , tmp_length ) ; text [ tmp_length ] = '\\0' ; midi_setup_text ( mdi , text ) ; ret_cnt += tmp_length ; } else if ( event_data [ 0 ] == 0x02 ) { event_data ++ ; ret_cnt ++ ; <S2SV_StartBug> if ( * event_data > 0x7f ) { <S2SV_EndBug> <S2SV_StartBug> do { <S2SV_EndBug> tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ; event_data ++ ; <S2SV_StartBug> ret_cnt ++ ; <S2SV_EndBug> } while ( * event_data > 0x7f ) ; <S2SV_StartBug> } <S2SV_EndBug> tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ; event_data ++ ; <S2SV_StartBug> ret_cnt ++ ; <S2SV_EndBug> if ( mdi -> extra_info . copyright ) { mdi -> extra_info . copyright = realloc ( mdi -> extra_info . copyright , ( strlen ( mdi -> extra_info . copyright ) + 1 + tmp_length + 1 ) ) ; memcpy ( & mdi -> extra_info . copyright [ strlen ( mdi -> extra_info . copyright ) + 1 ] , event_data , tmp_length ) ; mdi -> extra_info . copyright [ strlen ( mdi -> extra_info . copyright ) + 1 + tmp_length ] = '\\0' ; mdi -> extra_info . copyright [ strlen ( mdi -> extra_info . copyright ) ] = '\\n' ; } else { mdi -> extra_info . copyright = malloc ( tmp_length + 1 ) ; memcpy ( mdi -> extra_info . copyright , event_data , tmp_length ) ; mdi -> extra_info . copyright [ tmp_length ] = '\\0' ; } text = malloc ( tmp_length + 1 ) ; memcpy ( text , event_data , tmp_length ) ; text [ tmp_length ] = '\\0' ; midi_setup_copyright ( mdi , text ) ; ret_cnt += tmp_length ; } else if ( event_data [ 0 ] == 0x03 ) { event_data ++ ; ret_cnt ++ ; <S2SV_StartBug> if ( * event_data > 0x7f ) { <S2SV_EndBug> <S2SV_StartBug> do { <S2SV_EndBug> tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ; event_data ++ ; <S2SV_StartBug> ret_cnt ++ ; <S2SV_EndBug> } while ( * event_data > 0x7f ) ; <S2SV_StartBug> } <S2SV_EndBug> tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ; event_data ++ ; ret_cnt ++ ; <S2SV_StartBug> text = malloc ( tmp_length + 1 ) ; <S2SV_EndBug> memcpy ( text , event_data , tmp_length ) ; text [ tmp_length ] = '\\0' ; midi_setup_trackname ( mdi , text ) ; ret_cnt += tmp_length ; } else if ( event_data [ 0 ] == 0x04 ) { event_data ++ ; ret_cnt ++ ; <S2SV_StartBug> if ( * event_data > 0x7f ) { <S2SV_EndBug> <S2SV_StartBug> do { <S2SV_EndBug> tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ; event_data ++ ; <S2SV_StartBug> ret_cnt ++ ; <S2SV_EndBug> } while ( * event_data > 0x7f ) ; <S2SV_StartBug> } <S2SV_EndBug> tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ; event_data ++ ; ret_cnt ++ ; <S2SV_StartBug> text = malloc ( tmp_length + 1 ) ; <S2SV_EndBug> memcpy ( text , event_data , tmp_length ) ; text [ tmp_length ] = '\\0' ; midi_setup_instrumentname ( mdi , text ) ; ret_cnt += tmp_length ; } else if ( event_data [ 0 ] == 0x05 ) { event_data ++ ; ret_cnt ++ ; <S2SV_StartBug> if ( * event_data > 0x7f ) { <S2SV_EndBug> <S2SV_StartBug> do { <S2SV_EndBug> tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ; event_data ++ ; <S2SV_StartBug> ret_cnt ++ ; <S2SV_EndBug> } while ( * event_data > 0x7f ) ; <S2SV_StartBug> } <S2SV_EndBug> tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ; event_data ++ ; ret_cnt ++ ; <S2SV_StartBug> text = malloc ( tmp_length + 1 ) ; <S2SV_EndBug> memcpy ( text , event_data , tmp_length ) ; text [ tmp_length ] = '\\0' ; midi_setup_lyric ( mdi , text ) ; ret_cnt += tmp_length ; } else if ( event_data [ 0 ] == 0x06 ) { event_data ++ ; ret_cnt ++ ; <S2SV_StartBug> if ( * event_data > 0x7f ) { <S2SV_EndBug> <S2SV_StartBug> do { <S2SV_EndBug> tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ; event_data ++ ; <S2SV_StartBug> ret_cnt ++ ; <S2SV_EndBug> } while ( * event_data > 0x7f ) ; <S2SV_StartBug> } <S2SV_EndBug> tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ; event_data ++ ; ret_cnt ++ ; <S2SV_StartBug> text = malloc ( tmp_length + 1 ) ; <S2SV_EndBug> memcpy ( text , event_data , tmp_length ) ; text [ tmp_length ] = '\\0' ; midi_setup_marker ( mdi , text ) ; ret_cnt += tmp_length ; } else if ( event_data [ 0 ] == 0x07 ) { event_data ++ ; ret_cnt ++ ; <S2SV_StartBug> if ( * event_data > 0x7f ) { <S2SV_EndBug> <S2SV_StartBug> do { <S2SV_EndBug> tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ; event_data ++ ; <S2SV_StartBug> ret_cnt ++ ; <S2SV_EndBug> } while ( * event_data > 0x7f ) ; <S2SV_StartBug> } <S2SV_EndBug> tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ; event_data ++ ; ret_cnt ++ ; <S2SV_StartBug> text = malloc ( tmp_length + 1 ) ; <S2SV_EndBug> memcpy ( text , event_data , tmp_length ) ; text [ tmp_length ] = '\\0' ; midi_setup_cuepoint ( mdi , text ) ; ret_cnt += tmp_length ; <S2SV_StartBug> } else if ( ( event_data [ 0 ] == 0x20 ) && ( event_data [ 1 ] == 0x01 ) ) { <S2SV_EndBug> midi_setup_channelprefix ( mdi , event_data [ 2 ] ) ; ret_cnt += 3 ; } else if ( ( event_data [ 0 ] == 0x21 ) && ( event_data [ 1 ] == 0x01 ) ) { <S2SV_StartBug> midi_setup_portprefix ( mdi , event_data [ 2 ] ) ; <S2SV_EndBug> ret_cnt += 3 ; } else if ( ( event_data [ 0 ] == 0x2F ) && ( event_data [ 1 ] == 0x00 ) ) { <S2SV_StartBug> _WM_midi_setup_endoftrack ( mdi ) ; <S2SV_EndBug> ret_cnt += 2 ; } else if ( ( event_data [ 0 ] == 0x51 ) && ( event_data [ 1 ] == 0x03 ) ) { <S2SV_StartBug> _WM_midi_setup_tempo ( mdi , ( ( event_data [ 2 ] << 16 ) + ( event_data [ 3 ] << 8 ) + event_data [ 4 ] ) ) ; <S2SV_EndBug> ret_cnt += 5 ; <S2SV_StartBug> } else if ( ( event_data [ 0 ] == 0x54 ) && ( event_data [ 1 ] == 0x05 ) ) { <S2SV_EndBug> midi_setup_smpteoffset ( mdi , ( ( event_data [ 3 ] << 24 ) + ( event_data [ 4 ] << 16 ) + ( event_data [ 5 ] << 8 ) + event_data [ 6 ] ) ) ; mdi -> events [ mdi -> events_size - 1 ] . event_data . channel = event_data [ 2 ] ; ret_cnt += 7 ; } else if ( ( event_data [ 0 ] == 0x58 ) && ( event_data [ 1 ] == 0x04 ) ) { <S2SV_StartBug> midi_setup_timesignature ( mdi , ( ( event_data [ 2 ] << 24 ) + ( event_data [ 3 ] << 16 ) + ( event_data [ 4 ] << 8 ) + event_data [ 5 ] ) ) ; <S2SV_EndBug> ret_cnt += 6 ; } else if ( ( event_data [ 0 ] == 0x59 ) && ( event_data [ 1 ] == 0x02 ) ) { <S2SV_StartBug> midi_setup_keysignature ( mdi , ( ( event_data [ 2 ] << 8 ) + event_data [ 3 ] ) ) ; <S2SV_EndBug> ret_cnt += 4 ; } else { event_data ++ ; ret_cnt ++ ; <S2SV_StartBug> if ( * event_data > 0x7f ) { <S2SV_EndBug> <S2SV_StartBug> do { <S2SV_EndBug> tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ; event_data ++ ; <S2SV_StartBug> ret_cnt ++ ; <S2SV_EndBug> } while ( * event_data > 0x7f ) ; <S2SV_StartBug> } <S2SV_EndBug> tmp_length = ( tmp_length << 7 ) + ( * event_data & 0x7f ) ; ret_cnt ++ ; ret_cnt += tmp_length ; <S2SV_StartBug> } <S2SV_EndBug> } else if ( ( channel == 0 ) || ( channel == 7 ) ) { uint32_t sysex_len = 0 ; uint8_t * sysex_store = NULL ; if ( * event_data > 0x7f ) { <S2SV_StartBug> do { <S2SV_EndBug> sysex_len = ( sysex_len << 7 ) + ( * event_data & 0x7F ) ; event_data ++ ; <S2SV_StartBug> ret_cnt ++ ; <S2SV_EndBug> } while ( * event_data > 0x7f ) ; <S2SV_StartBug> } <S2SV_EndBug> sysex_len = ( sysex_len << 7 ) + ( * event_data & 0x7F ) ; event_data ++ ; <S2SV_StartBug> if ( ! sysex_len ) break ; <S2SV_EndBug> ret_cnt ++ ; sysex_store = malloc ( sizeof ( uint8_t ) * sysex_len ) ; memcpy ( sysex_store , event_data , sysex_len ) ; if ( sysex_store [ sysex_len - 1 ] == 0xF7 ) { uint8_t rolandsysexid [ ] = { 0x41 , 0x10 , 0x42 , 0x12 } ; if ( memcmp ( rolandsysexid , sysex_store , 4 ) == 0 ) { uint8_t sysex_cs = 0 ; uint32_t sysex_ofs = 4 ; do { sysex_cs += sysex_store [ sysex_ofs ] ; if ( sysex_cs > 0x7F ) { sysex_cs -= 0x80 ; } sysex_ofs ++ ; } while ( sysex_store [ sysex_ofs + 1 ] != 0xf7 ) ; sysex_cs = 128 - sysex_cs ; if ( sysex_cs == sysex_store [ sysex_ofs ] ) { if ( sysex_store [ 4 ] == 0x40 ) { if ( ( ( sysex_store [ 5 ] & 0xf0 ) == 0x10 ) && ( sysex_store [ 6 ] == 0x15 ) ) { uint8_t sysex_ch = 0x0f & sysex_store [ 5 ] ; if ( sysex_ch == 0x00 ) { sysex_ch = 0x09 ; } else if ( sysex_ch <= 0x09 ) { sysex_ch -= 1 ; } midi_setup_sysex_roland_drum_track ( mdi , sysex_ch , sysex_store [ 7 ] ) ; } else if ( ( sysex_store [ 5 ] == 0x00 ) && ( sysex_store [ 6 ] == 0x7F ) && ( sysex_store [ 7 ] == 0x00 ) ) { midi_setup_sysex_roland_reset ( mdi ) ; } } } } else { uint8_t gm_reset [ ] = { 0x7e , 0x7f , 0x09 , 0x01 , 0xf7 } ; uint8_t yamaha_reset [ ] = { 0x43 , 0x10 , 0x4c , 0x00 , 0x00 , 0x7e , 0x00 , 0xf7 } ; if ( memcmp ( gm_reset , sysex_store , 5 ) == 0 ) { midi_setup_sysex_gm_reset ( mdi ) ; } else if ( memcmp ( yamaha_reset , sysex_store , 8 ) == 0 ) { midi_setup_sysex_yamaha_reset ( mdi ) ; } } } free ( sysex_store ) ; sysex_store = NULL ; ret_cnt += sysex_len ; } else { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , "(unrecognized<S2SV_blank>meta<S2SV_blank>type<S2SV_blank>event)" , 0 ) ; return 0 ; } break ; default : ret_cnt = 0 ; break ; } if ( ret_cnt == 0 ) _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , "(missing<S2SV_blank>event)" , 0 ) ; return ret_cnt ; <S2SV_StartBug> } <S2SV_EndBug>
int main ( int argc , char * argv [ ] ) { opj_dinfo_t * dinfo ; opj_event_mgr_t event_mgr ; int tnum ; unsigned int snum ; opj_mj2_t * movie ; mj2_tk_t * track ; mj2_sample_t * sample ; unsigned char * frame_codestream ; FILE * file , * outfile ; char outfilename [ 50 ] ; mj2_dparameters_t parameters ; if ( argc != 3 ) { printf ( "Usage:<S2SV_blank>%s<S2SV_blank>mj2filename<S2SV_blank>output_location\\n" , argv [ 0 ] ) ; printf ( "Example:<S2SV_blank>%s<S2SV_blank>foreman.mj2<S2SV_blank>output/foreman\\n" , argv [ 0 ] ) ; return 1 ; } file = fopen ( argv [ 1 ] , "rb" ) ; if ( ! file ) { fprintf ( stderr , "failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>reading\\n" , argv [ 1 ] ) ; return 1 ; } memset ( & event_mgr , 0 , sizeof ( opj_event_mgr_t ) ) ; event_mgr . error_handler = error_callback ; event_mgr . warning_handler = warning_callback ; event_mgr . info_handler = info_callback ; dinfo = mj2_create_decompress ( ) ; opj_set_event_mgr ( ( opj_common_ptr ) dinfo , & event_mgr , stderr ) ; memset ( & parameters , 0 , sizeof ( mj2_dparameters_t ) ) ; movie = ( opj_mj2_t * ) dinfo -> mj2_handle ; mj2_setup_decoder ( movie , & parameters ) ; if ( mj2_read_struct ( file , movie ) ) { return 1 ; } tnum = 0 ; while ( movie -> tk [ tnum ] . track_type != 0 ) { tnum ++ ; } track = & movie -> tk [ tnum ] ; fprintf ( stdout , "Extracting<S2SV_blank>%d<S2SV_blank>frames<S2SV_blank>from<S2SV_blank>file...\\n" , track -> num_samples ) ; for ( snum = 0 ; snum < track -> num_samples ; snum ++ ) { sample = & track -> sample [ snum ] ; frame_codestream = ( unsigned char * ) malloc ( sample -> sample_size - 8 ) ; fseek ( file , sample -> offset + 8 , SEEK_SET ) ; fread ( frame_codestream , sample -> sample_size - 8 , 1 , file ) ; <S2SV_StartBug> sprintf ( outfilename , "%s_%05d.j2k" , argv [ 2 ] , snum ) ; <S2SV_EndBug> outfile = fopen ( outfilename , "wb" ) ; if ( ! outfile ) { fprintf ( stderr , "failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>writing\\n" , outfilename ) ; return 1 ; } fwrite ( frame_codestream , sample -> sample_size - 8 , 1 , outfile ) ; fclose ( outfile ) ; free ( frame_codestream ) ; } fclose ( file ) ; fprintf ( stdout , "%d<S2SV_blank>frames<S2SV_blank>correctly<S2SV_blank>extracted\\n" , snum ) ; if ( dinfo ) { mj2_destroy_decompress ( ( opj_mj2_t * ) dinfo -> mj2_handle ) ; } return 0 ; }
static void sg_fill_request_table ( Sg_fd * sfp , sg_req_info_t * rinfo ) { Sg_request * srp ; int val ; unsigned int ms ; val = 0 ; list_for_each_entry ( srp , & sfp -> rq_list , entry ) { if ( val > SG_MAX_QUEUE ) break ; <S2SV_StartBug> memset ( & rinfo [ val ] , 0 , SZ_SG_REQ_INFO ) ; <S2SV_EndBug> rinfo [ val ] . req_state = srp -> done + 1 ; rinfo [ val ] . problem = srp -> header . masked_status & srp -> header . host_status & srp -> header . driver_status ; if ( srp -> done ) rinfo [ val ] . duration = srp -> header . duration ; else { ms = jiffies_to_msecs ( jiffies ) ; rinfo [ val ] . duration = ( ms > srp -> header . duration ) ? ( ms - srp -> header . duration ) : 0 ; } rinfo [ val ] . orphan = srp -> orphan ; rinfo [ val ] . sg_io_owned = srp -> sg_io_owned ; rinfo [ val ] . pack_id = srp -> header . pack_id ; rinfo [ val ] . usr_ptr = srp -> header . usr_ptr ; val ++ ; } }
int obj2ast_comprehension ( PyObject * obj , comprehension_ty * out , PyArena * arena ) { PyObject * tmp = NULL ; expr_ty target ; expr_ty iter ; asdl_seq * ifs ; int is_async ; <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_target ) ) { <S2SV_EndBug> int res ; tmp = _PyObject_GetAttrId ( obj , & PyId_target ) ; <S2SV_StartBug> if ( tmp == NULL ) goto failed ; <S2SV_EndBug> res = obj2ast_expr ( tmp , & target , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; <S2SV_StartBug> } else { <S2SV_EndBug> PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"target\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>comprehension" ) ; return 1 ; } <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_iter ) ) { <S2SV_EndBug> int res ; tmp = _PyObject_GetAttrId ( obj , & PyId_iter ) ; <S2SV_StartBug> if ( tmp == NULL ) goto failed ; <S2SV_EndBug> res = obj2ast_expr ( tmp , & iter , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; <S2SV_StartBug> } else { <S2SV_EndBug> PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"iter\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>comprehension" ) ; return 1 ; } if ( _PyObject_HasAttrId ( obj , & PyId_ifs ) ) { int res ; Py_ssize_t len ; <S2SV_StartBug> Py_ssize_t i ; <S2SV_EndBug> tmp = _PyObject_GetAttrId ( obj , & PyId_ifs ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , "comprehension<S2SV_blank>field<S2SV_blank>\\"ifs\\"<S2SV_blank>must<S2SV_blank>be<S2SV_blank>a<S2SV_blank>list,<S2SV_blank>not<S2SV_blank>a<S2SV_blank>%.200s" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; ifs = _Ta3_asdl_seq_new ( len , arena ) ; if ( ifs == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { <S2SV_StartBug> expr_ty value ; <S2SV_EndBug> <S2SV_StartBug> res = obj2ast_expr ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; <S2SV_EndBug> if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , "comprehension<S2SV_blank>field<S2SV_blank>\\"ifs\\"<S2SV_blank>changed<S2SV_blank>size<S2SV_blank>during<S2SV_blank>iteration" ) ; goto failed ; } <S2SV_StartBug> asdl_seq_SET ( ifs , i , value ) ; <S2SV_EndBug> } Py_CLEAR ( tmp ) ; <S2SV_StartBug> } else { <S2SV_EndBug> PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"ifs\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>comprehension" ) ; return 1 ; } <S2SV_StartBug> if ( _PyObject_HasAttrId ( obj , & PyId_is_async ) ) { <S2SV_EndBug> int res ; tmp = _PyObject_GetAttrId ( obj , & PyId_is_async ) ; <S2SV_StartBug> if ( tmp == NULL ) goto failed ; <S2SV_EndBug> res = obj2ast_int ( tmp , & is_async , arena ) ; if ( res != 0 ) goto failed ; <S2SV_StartBug> Py_CLEAR ( tmp ) ; <S2SV_EndBug> } else { PyErr_SetString ( PyExc_TypeError , "required<S2SV_blank>field<S2SV_blank>\\"is_async\\"<S2SV_blank>missing<S2SV_blank>from<S2SV_blank>comprehension" ) ; return 1 ; } * out = comprehension ( target , iter , ifs , is_async , arena ) ; return 0 ; failed : Py_XDECREF ( tmp ) ; return 1 ; }
int ip6_fragment ( struct net * net , struct sock * sk , struct sk_buff * skb , int ( * output ) ( struct net * , struct sock * , struct sk_buff * ) ) { struct sk_buff * frag ; struct rt6_info * rt = ( struct rt6_info * ) skb_dst ( skb ) ; struct ipv6_pinfo * np = skb -> sk && ! dev_recursion_level ( ) ? inet6_sk ( skb -> sk ) : NULL ; struct ipv6hdr * tmp_hdr ; struct frag_hdr * fh ; unsigned int mtu , hlen , left , len ; int hroom , troom ; __be32 frag_id ; int ptr , offset = 0 , err = 0 ; u8 * prevhdr , nexthdr = 0 ; <S2SV_StartBug> hlen = ip6_find_1stfragopt ( skb , & prevhdr ) ; <S2SV_EndBug> nexthdr = * prevhdr ; mtu = ip6_skb_dst_mtu ( skb ) ; if ( unlikely ( ! skb -> ignore_df && skb -> len > mtu ) ) goto fail_toobig ; if ( IP6CB ( skb ) -> frag_max_size ) { if ( IP6CB ( skb ) -> frag_max_size > mtu ) goto fail_toobig ; mtu = IP6CB ( skb ) -> frag_max_size ; if ( mtu < IPV6_MIN_MTU ) mtu = IPV6_MIN_MTU ; } if ( np && np -> frag_size < mtu ) { if ( np -> frag_size ) mtu = np -> frag_size ; } if ( mtu < hlen + sizeof ( struct frag_hdr ) + 8 ) goto fail_toobig ; mtu -= hlen + sizeof ( struct frag_hdr ) ; frag_id = ipv6_select_ident ( net , & ipv6_hdr ( skb ) -> daddr , & ipv6_hdr ( skb ) -> saddr ) ; if ( skb -> ip_summed == CHECKSUM_PARTIAL && ( err = skb_checksum_help ( skb ) ) ) goto fail ; hroom = LL_RESERVED_SPACE ( rt -> dst . dev ) ; if ( skb_has_frag_list ( skb ) ) { unsigned int first_len = skb_pagelen ( skb ) ; struct sk_buff * frag2 ; if ( first_len - hlen > mtu || ( ( first_len - hlen ) & 7 ) || skb_cloned ( skb ) || skb_headroom ( skb ) < ( hroom + sizeof ( struct frag_hdr ) ) ) goto slow_path ; skb_walk_frags ( skb , frag ) { if ( frag -> len > mtu || ( ( frag -> len & 7 ) && frag -> next ) || skb_headroom ( frag ) < ( hlen + hroom + sizeof ( struct frag_hdr ) ) ) goto slow_path_clean ; if ( skb_shared ( frag ) ) goto slow_path_clean ; BUG_ON ( frag -> sk ) ; if ( skb -> sk ) { frag -> sk = skb -> sk ; frag -> destructor = sock_wfree ; } skb -> truesize -= frag -> truesize ; } err = 0 ; offset = 0 ; * prevhdr = NEXTHDR_FRAGMENT ; tmp_hdr = kmemdup ( skb_network_header ( skb ) , hlen , GFP_ATOMIC ) ; if ( ! tmp_hdr ) { IP6_INC_STATS ( net , ip6_dst_idev ( skb_dst ( skb ) ) , IPSTATS_MIB_FRAGFAILS ) ; err = - ENOMEM ; goto fail ; } frag = skb_shinfo ( skb ) -> frag_list ; skb_frag_list_init ( skb ) ; __skb_pull ( skb , hlen ) ; fh = ( struct frag_hdr * ) __skb_push ( skb , sizeof ( struct frag_hdr ) ) ; __skb_push ( skb , hlen ) ; skb_reset_network_header ( skb ) ; memcpy ( skb_network_header ( skb ) , tmp_hdr , hlen ) ; fh -> nexthdr = nexthdr ; fh -> reserved = 0 ; fh -> frag_off = htons ( IP6_MF ) ; fh -> identification = frag_id ; first_len = skb_pagelen ( skb ) ; skb -> data_len = first_len - skb_headlen ( skb ) ; skb -> len = first_len ; ipv6_hdr ( skb ) -> payload_len = htons ( first_len - sizeof ( struct ipv6hdr ) ) ; dst_hold ( & rt -> dst ) ; for ( ; ; ) { if ( frag ) { frag -> ip_summed = CHECKSUM_NONE ; skb_reset_transport_header ( frag ) ; fh = ( struct frag_hdr * ) __skb_push ( frag , sizeof ( struct frag_hdr ) ) ; __skb_push ( frag , hlen ) ; skb_reset_network_header ( frag ) ; memcpy ( skb_network_header ( frag ) , tmp_hdr , hlen ) ; offset += skb -> len - hlen - sizeof ( struct frag_hdr ) ; fh -> nexthdr = nexthdr ; fh -> reserved = 0 ; fh -> frag_off = htons ( offset ) ; if ( frag -> next ) fh -> frag_off |= htons ( IP6_MF ) ; fh -> identification = frag_id ; ipv6_hdr ( frag ) -> payload_len = htons ( frag -> len - sizeof ( struct ipv6hdr ) ) ; ip6_copy_metadata ( frag , skb ) ; } err = output ( net , sk , skb ) ; if ( ! err ) IP6_INC_STATS ( net , ip6_dst_idev ( & rt -> dst ) , IPSTATS_MIB_FRAGCREATES ) ; if ( err || ! frag ) break ; skb = frag ; frag = skb -> next ; skb -> next = NULL ; } kfree ( tmp_hdr ) ; if ( err == 0 ) { IP6_INC_STATS ( net , ip6_dst_idev ( & rt -> dst ) , IPSTATS_MIB_FRAGOKS ) ; ip6_rt_put ( rt ) ; return 0 ; } kfree_skb_list ( frag ) ; IP6_INC_STATS ( net , ip6_dst_idev ( & rt -> dst ) , IPSTATS_MIB_FRAGFAILS ) ; ip6_rt_put ( rt ) ; return err ; slow_path_clean : skb_walk_frags ( skb , frag2 ) { if ( frag2 == frag ) break ; frag2 -> sk = NULL ; frag2 -> destructor = NULL ; skb -> truesize += frag2 -> truesize ; } } slow_path : left = skb -> len - hlen ; ptr = hlen ; troom = rt -> dst . dev -> needed_tailroom ; while ( left > 0 ) { u8 * fragnexthdr_offset ; len = left ; if ( len > mtu ) len = mtu ; if ( len < left ) { len &= ~ 7 ; } frag = alloc_skb ( len + hlen + sizeof ( struct frag_hdr ) + hroom + troom , GFP_ATOMIC ) ; if ( ! frag ) { IP6_INC_STATS ( net , ip6_dst_idev ( skb_dst ( skb ) ) , IPSTATS_MIB_FRAGFAILS ) ; err = - ENOMEM ; goto fail ; } ip6_copy_metadata ( frag , skb ) ; skb_reserve ( frag , hroom ) ; skb_put ( frag , len + hlen + sizeof ( struct frag_hdr ) ) ; skb_reset_network_header ( frag ) ; fh = ( struct frag_hdr * ) ( skb_network_header ( frag ) + hlen ) ; frag -> transport_header = ( frag -> network_header + hlen + sizeof ( struct frag_hdr ) ) ; if ( skb -> sk ) skb_set_owner_w ( frag , skb -> sk ) ; skb_copy_from_linear_data ( skb , skb_network_header ( frag ) , hlen ) ; fragnexthdr_offset = skb_network_header ( frag ) ; fragnexthdr_offset += prevhdr - skb_network_header ( skb ) ; * fragnexthdr_offset = NEXTHDR_FRAGMENT ; fh -> nexthdr = nexthdr ; fh -> reserved = 0 ; fh -> identification = frag_id ; BUG_ON ( skb_copy_bits ( skb , ptr , skb_transport_header ( frag ) , len ) ) ; left -= len ; fh -> frag_off = htons ( offset ) ; if ( left > 0 ) fh -> frag_off |= htons ( IP6_MF ) ; ipv6_hdr ( frag ) -> payload_len = htons ( frag -> len - sizeof ( struct ipv6hdr ) ) ; ptr += len ; offset += len ; err = output ( net , sk , frag ) ; if ( err ) goto fail ; IP6_INC_STATS ( net , ip6_dst_idev ( skb_dst ( skb ) ) , IPSTATS_MIB_FRAGCREATES ) ; } IP6_INC_STATS ( net , ip6_dst_idev ( skb_dst ( skb ) ) , IPSTATS_MIB_FRAGOKS ) ; consume_skb ( skb ) ; return err ; fail_toobig : if ( skb -> sk && dst_allfrag ( skb_dst ( skb ) ) ) sk_nocaps_add ( skb -> sk , NETIF_F_GSO_MASK ) ; skb -> dev = skb_dst ( skb ) -> dev ; icmpv6_send ( skb , ICMPV6_PKT_TOOBIG , 0 , mtu ) ; err = - EMSGSIZE ; fail : IP6_INC_STATS ( net , ip6_dst_idev ( skb_dst ( skb ) ) , IPSTATS_MIB_FRAGFAILS ) ; kfree_skb ( skb ) ; return err ; }
static void single_motion_search ( VP9_COMP * cpi , MACROBLOCK * x , <S2SV_StartBug> const TileInfo * const tile , <S2SV_EndBug> BLOCK_SIZE bsize , int mi_row , int mi_col , int_mv * tmp_mv , int * rate_mv ) { MACROBLOCKD * xd = & x -> e_mbd ; <S2SV_StartBug> VP9_COMMON * cm = & cpi -> common ; <S2SV_EndBug> MB_MODE_INFO * mbmi = & xd -> mi [ 0 ] -> mbmi ; <S2SV_StartBug> struct buf_2d backup_yv12 [ MAX_MB_PLANE ] = { { 0 } } ; <S2SV_EndBug> int bestsme = INT_MAX ; <S2SV_StartBug> int further_steps , step_param ; <S2SV_EndBug> int sadpb = x -> sadperbit16 ; MV mvp_full ; int ref = mbmi -> ref_frame [ 0 ] ; <S2SV_StartBug> MV ref_mv = mbmi -> ref_mvs [ ref ] [ 0 ] . as_mv ; <S2SV_EndBug> int tmp_col_min = x -> mv_col_min ; int tmp_col_max = x -> mv_col_max ; int tmp_row_min = x -> mv_row_min ; <S2SV_StartBug> int tmp_row_max = x -> mv_row_max ; <S2SV_EndBug> const YV12_BUFFER_CONFIG * scaled_ref_frame = vp9_get_scaled_ref_frame ( cpi , ref ) ; MV pred_mv [ 3 ] ; <S2SV_StartBug> pred_mv [ 0 ] = mbmi -> ref_mvs [ ref ] [ 0 ] . as_mv ; <S2SV_EndBug> <S2SV_StartBug> pred_mv [ 1 ] = mbmi -> ref_mvs [ ref ] [ 1 ] . as_mv ; <S2SV_EndBug> <S2SV_StartBug> pred_mv [ 2 ] = x -> pred_mv [ ref ] . as_mv ; <S2SV_EndBug> if ( scaled_ref_frame ) { int i ; for ( i = 0 ; i < MAX_MB_PLANE ; i ++ ) backup_yv12 [ i ] = xd -> plane [ i ] . pre [ 0 ] ; vp9_setup_pre_planes ( xd , 0 , scaled_ref_frame , mi_row , mi_col , NULL ) ; } vp9_set_mv_search_range ( x , & ref_mv ) ; <S2SV_StartBug> if ( cpi -> sf . auto_mv_step_size && cpi -> common . show_frame ) { <S2SV_EndBug> <S2SV_StartBug> step_param = ( vp9_init_search_range ( cpi , x -> max_mv_context [ ref ] ) + <S2SV_EndBug> <S2SV_StartBug> cpi -> mv_step_param ) >> 1 ; <S2SV_EndBug> } else { step_param = cpi -> mv_step_param ; } <S2SV_StartBug> if ( cpi -> sf . adaptive_motion_search && bsize < BLOCK_64X64 && <S2SV_EndBug> cpi -> common . show_frame ) { <S2SV_StartBug> int boffset = 2 * ( b_width_log2 ( BLOCK_64X64 ) - MIN ( b_height_log2 ( bsize ) , <S2SV_EndBug> b_width_log2 ( bsize ) ) ) ; step_param = MAX ( step_param , boffset ) ; } if ( cpi -> sf . adaptive_motion_search ) { int bwl = b_width_log2_lookup [ bsize ] ; <S2SV_StartBug> int bhl = b_height_log2_lookup [ bsize ] ; <S2SV_EndBug> int i ; int tlevel = x -> pred_mv_sad [ ref ] >> ( bwl + bhl + 4 ) ; if ( tlevel < 5 ) step_param += 2 ; <S2SV_StartBug> for ( i = LAST_FRAME ; i <= ALTREF_FRAME && cpi -> common . show_frame ; ++ i ) { <S2SV_EndBug> if ( ( x -> pred_mv_sad [ ref ] >> 3 ) > x -> pred_mv_sad [ i ] ) { <S2SV_StartBug> x -> pred_mv [ ref ] . as_int = 0 ; <S2SV_EndBug> tmp_mv -> as_int = INVALID_MV ; if ( scaled_ref_frame ) { int i ; <S2SV_StartBug> for ( i = 0 ; i < MAX_MB_PLANE ; i ++ ) <S2SV_EndBug> xd -> plane [ i ] . pre [ 0 ] = backup_yv12 [ i ] ; } <S2SV_StartBug> return ; <S2SV_EndBug> } } } mvp_full = pred_mv [ x -> mv_best_ref_index [ ref ] ] ; mvp_full . col >>= 3 ; mvp_full . row >>= 3 ; <S2SV_StartBug> further_steps = ( cpi -> sf . max_step_search_steps - 1 ) - step_param ; <S2SV_EndBug> if ( cpi -> sf . search_method == FAST_DIAMOND ) { bestsme = vp9_fast_dia_search ( x , & mvp_full , step_param , sadpb , 0 , & cpi -> fn_ptr [ bsize ] , 1 , & ref_mv , & tmp_mv -> as_mv ) ; if ( bestsme < INT_MAX ) <S2SV_StartBug> bestsme = vp9_get_mvpred_var ( x , & tmp_mv -> as_mv , & ref_mv , <S2SV_EndBug> <S2SV_StartBug> & cpi -> fn_ptr [ bsize ] , 1 ) ; <S2SV_EndBug> <S2SV_StartBug> } else if ( cpi -> sf . search_method == FAST_HEX ) { <S2SV_EndBug> bestsme = vp9_fast_hex_search ( x , & mvp_full , step_param , sadpb , 0 , & cpi -> fn_ptr [ bsize ] , 1 , & ref_mv , & tmp_mv -> as_mv ) ; if ( bestsme < INT_MAX ) bestsme = vp9_get_mvpred_var ( x , & tmp_mv -> as_mv , & ref_mv , & cpi -> fn_ptr [ bsize ] , 1 ) ; <S2SV_StartBug> } else if ( cpi -> sf . search_method == HEX ) { <S2SV_EndBug> bestsme = vp9_hex_search ( x , & mvp_full , step_param , sadpb , 1 , & cpi -> fn_ptr [ bsize ] , 1 , & ref_mv , & tmp_mv -> as_mv ) ; if ( bestsme < INT_MAX ) bestsme = vp9_get_mvpred_var ( x , & tmp_mv -> as_mv , & ref_mv , & cpi -> fn_ptr [ bsize ] , 1 ) ; } else if ( cpi -> sf . search_method == SQUARE ) { bestsme = vp9_square_search ( x , & mvp_full , step_param , sadpb , 1 , & cpi -> fn_ptr [ bsize ] , 1 , & ref_mv , & tmp_mv -> as_mv ) ; if ( bestsme < INT_MAX ) bestsme = vp9_get_mvpred_var ( x , & tmp_mv -> as_mv , & ref_mv , & cpi -> fn_ptr [ bsize ] , 1 ) ; } else if ( cpi -> sf . search_method == BIGDIA ) { bestsme = vp9_bigdia_search ( x , & mvp_full , step_param , sadpb , 1 , & cpi -> fn_ptr [ bsize ] , 1 , & ref_mv , & tmp_mv -> as_mv ) ; if ( bestsme < INT_MAX ) bestsme = vp9_get_mvpred_var ( x , & tmp_mv -> as_mv , & ref_mv , & cpi -> fn_ptr [ bsize ] , 1 ) ; } else { bestsme = vp9_full_pixel_diamond ( cpi , x , & mvp_full , step_param , sadpb , further_steps , 1 , & cpi -> fn_ptr [ bsize ] , & ref_mv , & tmp_mv -> as_mv ) ; } x -> mv_col_min = tmp_col_min ; x -> mv_col_max = tmp_col_max ; x -> mv_row_min = tmp_row_min ; x -> mv_row_max = tmp_row_max ; if ( bestsme < INT_MAX ) { int dis ; cpi -> find_fractional_mv_step ( x , & tmp_mv -> as_mv , & ref_mv , cm -> allow_high_precision_mv , x -> errorperbit , & cpi -> fn_ptr [ bsize ] , cpi -> sf . subpel_force_stop , cpi -> sf . subpel_iters_per_step , x -> nmvjointcost , x -> mvcost , <S2SV_StartBug> & dis , & x -> pred_sse [ ref ] ) ; <S2SV_EndBug> } * rate_mv = vp9_mv_bit_cost ( & tmp_mv -> as_mv , & ref_mv , x -> nmvjointcost , x -> mvcost , MV_COST_WEIGHT ) ; <S2SV_StartBug> if ( cpi -> sf . adaptive_motion_search && cpi -> common . show_frame ) <S2SV_EndBug> <S2SV_StartBug> x -> pred_mv [ ref ] . as_int = tmp_mv -> as_int ; <S2SV_EndBug> if ( scaled_ref_frame ) { int i ; for ( i = 0 ; i < MAX_MB_PLANE ; i ++ ) xd -> plane [ i ] . pre [ 0 ] = backup_yv12 [ i ] ; } }
int ip6_find_1stfragopt ( struct sk_buff * skb , u8 * * nexthdr ) { <S2SV_StartBug> u16 offset = sizeof ( struct ipv6hdr ) ; <S2SV_EndBug> unsigned int packet_len = skb_tail_pointer ( skb ) - skb_network_header ( skb ) ; int found_rhdr = 0 ; * nexthdr = & ipv6_hdr ( skb ) -> nexthdr ; while ( offset <= packet_len ) { struct ipv6_opt_hdr * exthdr ; <S2SV_StartBug> switch ( * * nexthdr ) { <S2SV_EndBug> case NEXTHDR_HOP : break ; case NEXTHDR_ROUTING : found_rhdr = 1 ; break ; case NEXTHDR_DEST : # if IS_ENABLED ( CONFIG_IPV6_MIP6 ) if ( ipv6_find_tlv ( skb , offset , IPV6_TLV_HAO ) >= 0 ) break ; # endif if ( found_rhdr ) return offset ; break ; default : return offset ; } if ( offset + sizeof ( struct ipv6_opt_hdr ) > packet_len ) return - EINVAL ; exthdr = ( struct ipv6_opt_hdr * ) ( skb_network_header ( skb ) + offset ) ; <S2SV_StartBug> offset += ipv6_optlen ( exthdr ) ; <S2SV_EndBug> * nexthdr = & exthdr -> nexthdr ; } return - EINVAL ; }
static int crypto_report_one ( struct crypto_alg * alg , struct crypto_user_alg * ualg , struct sk_buff * skb ) { <S2SV_StartBug> memcpy ( & ualg -> cru_name , & alg -> cra_name , sizeof ( ualg -> cru_name ) ) ; <S2SV_EndBug> <S2SV_StartBug> memcpy ( & ualg -> cru_driver_name , & alg -> cra_driver_name , <S2SV_EndBug> sizeof ( ualg -> cru_driver_name ) ) ; <S2SV_StartBug> memcpy ( & ualg -> cru_module_name , module_name ( alg -> cra_module ) , <S2SV_EndBug> <S2SV_StartBug> CRYPTO_MAX_ALG_NAME ) ; <S2SV_EndBug> ualg -> cru_flags = alg -> cra_flags ; ualg -> cru_refcnt = atomic_read ( & alg -> cra_refcnt ) ; if ( nla_put_u32 ( skb , CRYPTOCFGA_PRIORITY_VAL , alg -> cra_priority ) ) goto nla_put_failure ; if ( alg -> cra_flags & CRYPTO_ALG_LARVAL ) { struct crypto_report_larval rl ; <S2SV_StartBug> snprintf ( rl . type , CRYPTO_MAX_ALG_NAME , "%s" , "larval" ) ; <S2SV_EndBug> if ( nla_put ( skb , CRYPTOCFGA_REPORT_LARVAL , sizeof ( struct crypto_report_larval ) , & rl ) ) goto nla_put_failure ; goto out ; } if ( alg -> cra_type && alg -> cra_type -> report ) { if ( alg -> cra_type -> report ( skb , alg ) ) goto nla_put_failure ; goto out ; } switch ( alg -> cra_flags & ( CRYPTO_ALG_TYPE_MASK | CRYPTO_ALG_LARVAL ) ) { case CRYPTO_ALG_TYPE_CIPHER : if ( crypto_report_cipher ( skb , alg ) ) goto nla_put_failure ; break ; case CRYPTO_ALG_TYPE_COMPRESS : if ( crypto_report_comp ( skb , alg ) ) goto nla_put_failure ; break ; } out : return 0 ; nla_put_failure : return - EMSGSIZE ; }
static int daemon_msg_open_req ( uint8 ver , struct daemon_slpars * pars , uint32 plen , char * source , size_t sourcelen ) { char errbuf [ PCAP_ERRBUF_SIZE ] ; char errmsgbuf [ PCAP_ERRBUF_SIZE ] ; pcap_t * fp ; int nread ; char sendbuf [ RPCAP_NETBUF_SIZE ] ; int sendbufidx = 0 ; struct rpcap_openreply * openreply ; if ( plen > sourcelen - 1 ) { pcap_snprintf ( errmsgbuf , PCAP_ERRBUF_SIZE , "Source<S2SV_blank>string<S2SV_blank>too<S2SV_blank>long" ) ; goto error ; } nread = sock_recv ( pars -> sockctrl , source , plen , SOCK_RECEIVEALL_YES | SOCK_EOF_IS_ERROR , errbuf , PCAP_ERRBUF_SIZE ) ; if ( nread == - 1 ) { rpcapd_log ( LOGPRIO_ERROR , "Read<S2SV_blank>from<S2SV_blank>client<S2SV_blank>failed:<S2SV_blank>%s" , errbuf ) ; return - 1 ; } source [ nread ] = '\\0' ; plen -= nread ; <S2SV_StartBug> if ( ( fp = pcap_open_live ( source , <S2SV_EndBug> 1500 , 0 , 1000 , errmsgbuf ) ) == NULL ) goto error ; if ( sock_bufferize ( NULL , sizeof ( struct rpcap_header ) , NULL , & sendbufidx , RPCAP_NETBUF_SIZE , SOCKBUF_CHECKONLY , errmsgbuf , PCAP_ERRBUF_SIZE ) == - 1 ) goto error ; rpcap_createhdr ( ( struct rpcap_header * ) sendbuf , ver , RPCAP_MSG_OPEN_REPLY , 0 , sizeof ( struct rpcap_openreply ) ) ; openreply = ( struct rpcap_openreply * ) & sendbuf [ sendbufidx ] ; if ( sock_bufferize ( NULL , sizeof ( struct rpcap_openreply ) , NULL , & sendbufidx , RPCAP_NETBUF_SIZE , SOCKBUF_CHECKONLY , errmsgbuf , PCAP_ERRBUF_SIZE ) == - 1 ) goto error ; memset ( openreply , 0 , sizeof ( struct rpcap_openreply ) ) ; openreply -> linktype = htonl ( pcap_datalink ( fp ) ) ; openreply -> tzoff = 0 ; pcap_close ( fp ) ; if ( sock_send ( pars -> sockctrl , sendbuf , sendbufidx , errbuf , PCAP_ERRBUF_SIZE ) == - 1 ) { rpcapd_log ( LOGPRIO_ERROR , "Send<S2SV_blank>to<S2SV_blank>client<S2SV_blank>failed:<S2SV_blank>%s" , errbuf ) ; return - 1 ; } return 0 ; error : if ( rpcap_senderror ( pars -> sockctrl , ver , PCAP_ERR_OPEN , errmsgbuf , errbuf ) == - 1 ) { rpcapd_log ( LOGPRIO_ERROR , "Send<S2SV_blank>to<S2SV_blank>client<S2SV_blank>failed:<S2SV_blank>%s" , errbuf ) ; return - 1 ; } if ( rpcapd_discard ( pars -> sockctrl , plen ) == - 1 ) { return - 1 ; } return 0 ; }
void imap_munge_mbox_name ( struct ImapData * idata , char * dest , size_t dlen , const char * src ) { char * buf = mutt_str_strdup ( src ) ; imap_utf_encode ( idata , & buf ) ; <S2SV_StartBug> imap_quote_string ( dest , dlen , buf ) ; <S2SV_EndBug> FREE ( & buf ) ; }
static int __load_segment_descriptor ( struct x86_emulate_ctxt * ctxt , <S2SV_StartBug> u16 selector , int seg , u8 cpl , bool in_task_switch ) <S2SV_EndBug> { struct desc_struct seg_desc , old_desc ; u8 dpl , rpl ; unsigned err_vec = GP_VECTOR ; u32 err_code = 0 ; bool null_selector = ! ( selector & ~ 0x3 ) ; ulong desc_addr ; int ret ; u16 dummy ; u32 base3 = 0 ; memset ( & seg_desc , 0 , sizeof seg_desc ) ; if ( ctxt -> mode == X86EMUL_MODE_REAL ) { ctxt -> ops -> get_segment ( ctxt , & dummy , & seg_desc , NULL , seg ) ; set_desc_base ( & seg_desc , selector << 4 ) ; goto load ; } else if ( seg <= VCPU_SREG_GS && ctxt -> mode == X86EMUL_MODE_VM86 ) { set_desc_base ( & seg_desc , selector << 4 ) ; set_desc_limit ( & seg_desc , 0xffff ) ; seg_desc . type = 3 ; seg_desc . p = 1 ; seg_desc . s = 1 ; seg_desc . dpl = 3 ; goto load ; } rpl = selector & 3 ; if ( ( seg == VCPU_SREG_CS || ( seg == VCPU_SREG_SS && ( ctxt -> mode != X86EMUL_MODE_PROT64 || rpl != cpl ) ) || seg == VCPU_SREG_TR ) && null_selector ) goto exception ; if ( seg == VCPU_SREG_TR && ( selector & ( 1 << 2 ) ) ) goto exception ; if ( null_selector ) goto load ; ret = read_segment_descriptor ( ctxt , selector , & seg_desc , & desc_addr ) ; if ( ret != X86EMUL_CONTINUE ) return ret ; err_code = selector & 0xfffc ; err_vec = in_task_switch ? TS_VECTOR : GP_VECTOR ; if ( seg <= VCPU_SREG_GS && ! seg_desc . s ) goto exception ; if ( ! seg_desc . p ) { err_vec = ( seg == VCPU_SREG_SS ) ? SS_VECTOR : NP_VECTOR ; goto exception ; } dpl = seg_desc . dpl ; switch ( seg ) { case VCPU_SREG_SS : if ( rpl != cpl || ( seg_desc . type & 0xa ) != 0x2 || dpl != cpl ) goto exception ; break ; case VCPU_SREG_CS : if ( ! ( seg_desc . type & 8 ) ) goto exception ; if ( seg_desc . type & 4 ) { if ( dpl > cpl ) goto exception ; } else { if ( rpl > cpl || dpl != cpl ) goto exception ; } if ( seg_desc . d && seg_desc . l ) { u64 efer = 0 ; ctxt -> ops -> get_msr ( ctxt , MSR_EFER , & efer ) ; if ( efer & EFER_LMA ) goto exception ; } selector = ( selector & 0xfffc ) | cpl ; break ; case VCPU_SREG_TR : if ( seg_desc . s || ( seg_desc . type != 1 && seg_desc . type != 9 ) ) goto exception ; old_desc = seg_desc ; seg_desc . type |= 2 ; ret = ctxt -> ops -> cmpxchg_emulated ( ctxt , desc_addr , & old_desc , & seg_desc , sizeof ( seg_desc ) , & ctxt -> exception ) ; if ( ret != X86EMUL_CONTINUE ) return ret ; break ; case VCPU_SREG_LDTR : if ( seg_desc . s || seg_desc . type != 2 ) goto exception ; break ; default : if ( ( seg_desc . type & 0xa ) == 0x8 || ( ( ( seg_desc . type & 0xc ) != 0xc ) && ( rpl > dpl && cpl > dpl ) ) ) goto exception ; break ; } if ( seg_desc . s ) { seg_desc . type |= 1 ; ret = write_segment_descriptor ( ctxt , selector , & seg_desc ) ; if ( ret != X86EMUL_CONTINUE ) return ret ; } else if ( ctxt -> mode == X86EMUL_MODE_PROT64 ) { ret = ctxt -> ops -> read_std ( ctxt , desc_addr + 8 , & base3 , sizeof ( base3 ) , & ctxt -> exception ) ; if ( ret != X86EMUL_CONTINUE ) return ret ; } load : ctxt -> ops -> set_segment ( ctxt , selector , & seg_desc , base3 , seg ) ; <S2SV_StartBug> return X86EMUL_CONTINUE ; <S2SV_EndBug> exception : return emulate_exception ( ctxt , err_vec , err_code , true ) ; }
static void make_response ( struct xen_blkif_ring * ring , u64 id , unsigned short op , int st ) { <S2SV_StartBug> struct blkif_response resp ; <S2SV_EndBug> unsigned long flags ; union blkif_back_rings * blk_rings ; int notify ; <S2SV_StartBug> resp . id = id ; <S2SV_EndBug> resp . operation = op ; resp . status = st ; spin_lock_irqsave ( & ring -> blk_ring_lock , flags ) ; blk_rings = & ring -> blk_rings ; switch ( ring -> blkif -> blk_protocol ) { case BLKIF_PROTOCOL_NATIVE : <S2SV_StartBug> memcpy ( RING_GET_RESPONSE ( & blk_rings -> native , blk_rings -> native . rsp_prod_pvt ) , <S2SV_EndBug> & resp , sizeof ( resp ) ) ; break ; case BLKIF_PROTOCOL_X86_32 : <S2SV_StartBug> memcpy ( RING_GET_RESPONSE ( & blk_rings -> x86_32 , blk_rings -> x86_32 . rsp_prod_pvt ) , <S2SV_EndBug> & resp , sizeof ( resp ) ) ; break ; case BLKIF_PROTOCOL_X86_64 : <S2SV_StartBug> memcpy ( RING_GET_RESPONSE ( & blk_rings -> x86_64 , blk_rings -> x86_64 . rsp_prod_pvt ) , <S2SV_EndBug> & resp , sizeof ( resp ) ) ; break ; default : BUG ( ) ; <S2SV_StartBug> } <S2SV_EndBug> blk_rings -> common . rsp_prod_pvt ++ ; RING_PUSH_RESPONSES_AND_CHECK_NOTIFY ( & blk_rings -> common , notify ) ; spin_unlock_irqrestore ( & ring -> blk_ring_lock , flags ) ; if ( notify ) notify_remote_via_irq ( ring -> irq ) ; }
void dump_isom_sdp ( GF_ISOFile * file , char * inName , Bool is_final_name ) { const char * sdp ; u32 size , i ; FILE * dump ; if ( inName ) { char szBuf [ 1024 ] ; strcpy ( szBuf , inName ) ; if ( ! is_final_name ) { char * ext = strchr ( szBuf , '.' ) ; if ( ext ) ext [ 0 ] = 0 ; strcat ( szBuf , "_sdp.txt" ) ; } dump = gf_fopen ( szBuf , "wt" ) ; if ( ! dump ) { fprintf ( stderr , "Failed<S2SV_blank>to<S2SV_blank>open<S2SV_blank>%s<S2SV_blank>for<S2SV_blank>dumping\\n" , szBuf ) ; return ; } } else { dump = stdout ; fprintf ( dump , "*<S2SV_blank>File<S2SV_blank>SDP<S2SV_blank>content<S2SV_blank>*\\n\\n" ) ; } gf_isom_sdp_get ( file , & sdp , & size ) ; <S2SV_StartBug> fprintf ( dump , "%s" , sdp ) ; <S2SV_EndBug> fprintf ( dump , "\\r\\n" ) ; for ( i = 0 ; i < gf_isom_get_track_count ( file ) ; i ++ ) { if ( gf_isom_get_media_type ( file , i + 1 ) != GF_ISOM_MEDIA_HINT ) continue ; gf_isom_sdp_track_get ( file , i + 1 , & sdp , & size ) ; fprintf ( dump , "%s" , sdp ) ; } fprintf ( dump , "\\n\\n" ) ; if ( inName ) gf_fclose ( dump ) ; }
int phar_parse_zipfile ( php_stream * fp , char * fname , int fname_len , char * alias , int alias_len , phar_archive_data * * pphar , char * * error ) { phar_zip_dir_end locator ; char buf [ sizeof ( locator ) + 65536 ] ; zend_long size ; php_uint16 i ; phar_archive_data * mydata = NULL ; phar_entry_info entry = { 0 } ; char * p = buf , * ext , * actual_alias = NULL ; char * metadata = NULL ; size = php_stream_tell ( fp ) ; if ( size > sizeof ( locator ) + 65536 ) { size = sizeof ( locator ) + 65536 ; if ( FAILURE == php_stream_seek ( fp , - size , SEEK_END ) ) { php_stream_close ( fp ) ; if ( error ) { spprintf ( error , 4096 , "phar<S2SV_blank>error:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>search<S2SV_blank>for<S2SV_blank>end<S2SV_blank>of<S2SV_blank>central<S2SV_blank>directory<S2SV_blank>in<S2SV_blank>zip-based<S2SV_blank>phar<S2SV_blank>\\"%s\\"" , fname ) ; } return FAILURE ; } } else { php_stream_seek ( fp , 0 , SEEK_SET ) ; } if ( ! php_stream_read ( fp , buf , size ) ) { php_stream_close ( fp ) ; if ( error ) { spprintf ( error , 4096 , "phar<S2SV_blank>error:<S2SV_blank>unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>in<S2SV_blank>data<S2SV_blank>to<S2SV_blank>search<S2SV_blank>for<S2SV_blank>end<S2SV_blank>of<S2SV_blank>central<S2SV_blank>directory<S2SV_blank>in<S2SV_blank>zip-based<S2SV_blank>phar<S2SV_blank>\\"%s\\"" , fname ) ; } return FAILURE ; } while ( ( p = ( char * ) memchr ( p + 1 , 'P' , ( size_t ) ( size - ( p + 1 - buf ) ) ) ) != NULL ) { if ( ( p - buf ) + sizeof ( locator ) <= size && ! memcmp ( p + 1 , "K\\5\\6" , 3 ) ) { memcpy ( ( void * ) & locator , ( void * ) p , sizeof ( locator ) ) ; if ( PHAR_GET_16 ( locator . centraldisk ) != 0 || PHAR_GET_16 ( locator . disknumber ) != 0 ) { php_stream_close ( fp ) ; if ( error ) { spprintf ( error , 4096 , "phar<S2SV_blank>error:<S2SV_blank>split<S2SV_blank>archives<S2SV_blank>spanning<S2SV_blank>multiple<S2SV_blank>zips<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>processed<S2SV_blank>in<S2SV_blank>zip-based<S2SV_blank>phar<S2SV_blank>\\"%s\\"" , fname ) ; } return FAILURE ; } if ( PHAR_GET_16 ( locator . counthere ) != PHAR_GET_16 ( locator . count ) ) { if ( error ) { spprintf ( error , 4096 , "phar<S2SV_blank>error:<S2SV_blank>corrupt<S2SV_blank>zip<S2SV_blank>archive,<S2SV_blank>conflicting<S2SV_blank>file<S2SV_blank>count<S2SV_blank>in<S2SV_blank>end<S2SV_blank>of<S2SV_blank>central<S2SV_blank>directory<S2SV_blank>record<S2SV_blank>in<S2SV_blank>zip-based<S2SV_blank>phar<S2SV_blank>\\"%s\\"" , fname ) ; } php_stream_close ( fp ) ; return FAILURE ; } mydata = pecalloc ( 1 , sizeof ( phar_archive_data ) , PHAR_G ( persist ) ) ; mydata -> is_persistent = PHAR_G ( persist ) ; if ( PHAR_GET_16 ( locator . comment_len ) ) { metadata = p + sizeof ( locator ) ; if ( PHAR_GET_16 ( locator . comment_len ) != size - ( metadata - buf ) ) { if ( error ) { spprintf ( error , 4096 , "phar<S2SV_blank>error:<S2SV_blank>corrupt<S2SV_blank>zip<S2SV_blank>archive,<S2SV_blank>zip<S2SV_blank>file<S2SV_blank>comment<S2SV_blank>truncated<S2SV_blank>in<S2SV_blank>zip-based<S2SV_blank>phar<S2SV_blank>\\"%s\\"" , fname ) ; } php_stream_close ( fp ) ; pefree ( mydata , mydata -> is_persistent ) ; return FAILURE ; } mydata -> metadata_len = PHAR_GET_16 ( locator . comment_len ) ; if ( phar_parse_metadata ( & metadata , & mydata -> metadata , PHAR_GET_16 ( locator . comment_len ) ) == FAILURE ) { mydata -> metadata_len = 0 ; ZVAL_NEW_STR ( & mydata -> metadata , zend_string_init ( metadata , PHAR_GET_16 ( locator . comment_len ) , mydata -> is_persistent ) ) ; } } else { ZVAL_UNDEF ( & mydata -> metadata ) ; } goto foundit ; } } php_stream_close ( fp ) ; if ( error ) { spprintf ( error , 4096 , "phar<S2SV_blank>error:<S2SV_blank>end<S2SV_blank>of<S2SV_blank>central<S2SV_blank>directory<S2SV_blank>not<S2SV_blank>found<S2SV_blank>in<S2SV_blank>zip-based<S2SV_blank>phar<S2SV_blank>\\"%s\\"" , fname ) ; } return FAILURE ; foundit : mydata -> fname = pestrndup ( fname , fname_len , mydata -> is_persistent ) ; # ifdef PHP_WIN32 phar_unixify_path_separators ( mydata -> fname , fname_len ) ; # endif mydata -> is_zip = 1 ; mydata -> fname_len = fname_len ; ext = strrchr ( mydata -> fname , '/' ) ; if ( ext ) { mydata -> ext = memchr ( ext , '.' , ( mydata -> fname + fname_len ) - ext ) ; if ( mydata -> ext == ext ) { mydata -> ext = memchr ( ext + 1 , '.' , ( mydata -> fname + fname_len ) - ext - 1 ) ; } if ( mydata -> ext ) { mydata -> ext_len = ( mydata -> fname + fname_len ) - mydata -> ext ; } } php_stream_seek ( fp , PHAR_GET_32 ( locator . cdir_offset ) , SEEK_SET ) ; zend_hash_init ( & mydata -> manifest , PHAR_GET_16 ( locator . count ) , zend_get_hash_value , destroy_phar_manifest_entry , ( zend_bool ) mydata -> is_persistent ) ; zend_hash_init ( & mydata -> mounted_dirs , 5 , zend_get_hash_value , NULL , ( zend_bool ) mydata -> is_persistent ) ; zend_hash_init ( & mydata -> virtual_dirs , PHAR_GET_16 ( locator . count ) * 2 , zend_get_hash_value , NULL , ( zend_bool ) mydata -> is_persistent ) ; entry . phar = mydata ; entry . is_zip = 1 ; entry . fp_type = PHAR_FP ; entry . is_persistent = mydata -> is_persistent ; # define PHAR_ZIP_FAIL_FREE ( errmsg , save ) zend_hash_destroy ( & mydata -> manifest ) ; mydata -> manifest . u . flags = 0 ; zend_hash_destroy ( & mydata -> mounted_dirs ) ; mydata -> mounted_dirs . u . flags = 0 ; zend_hash_destroy ( & mydata -> virtual_dirs ) ; mydata -> virtual_dirs . u . flags = 0 ; php_stream_close ( fp ) ; zval_dtor ( & mydata -> metadata ) ; if ( mydata -> signature ) { efree ( mydata -> signature ) ; } if ( error ) { spprintf ( error , 4096 , "phar<S2SV_blank>error:<S2SV_blank>%s<S2SV_blank>in<S2SV_blank>zip-based<S2SV_blank>phar<S2SV_blank>\\"%s\\"" , errmsg , mydata -> fname ) ; } pefree ( mydata -> fname , mydata -> is_persistent ) ; if ( mydata -> alias ) { pefree ( mydata -> alias , mydata -> is_persistent ) ; } pefree ( mydata , mydata -> is_persistent ) ; efree ( save ) ; return FAILURE ; # define PHAR_ZIP_FAIL ( errmsg ) zend_hash_destroy ( & mydata -> manifest ) ; mydata -> manifest . u . flags = 0 ; zend_hash_destroy ( & mydata -> mounted_dirs ) ; mydata -> mounted_dirs . u . flags = 0 ; zend_hash_destroy ( & mydata -> virtual_dirs ) ; mydata -> virtual_dirs . u . flags = 0 ; php_stream_close ( fp ) ; zval_dtor ( & mydata -> metadata ) ; if ( mydata -> signature ) { efree ( mydata -> signature ) ; } if ( error ) { spprintf ( error , 4096 , "phar<S2SV_blank>error:<S2SV_blank>%s<S2SV_blank>in<S2SV_blank>zip-based<S2SV_blank>phar<S2SV_blank>\\"%s\\"" , errmsg , mydata -> fname ) ; } pefree ( mydata -> fname , mydata -> is_persistent ) ; if ( mydata -> alias ) { pefree ( mydata -> alias , mydata -> is_persistent ) ; } pefree ( mydata , mydata -> is_persistent ) ; return FAILURE ; for ( i = 0 ; i < PHAR_GET_16 ( locator . count ) ; ++ i ) { phar_zip_central_dir_file zipentry ; zend_off_t beforeus = php_stream_tell ( fp ) ; if ( sizeof ( zipentry ) != php_stream_read ( fp , ( char * ) & zipentry , sizeof ( zipentry ) ) ) { PHAR_ZIP_FAIL ( "unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>central<S2SV_blank>directory<S2SV_blank>entry,<S2SV_blank>truncated" ) ; } if ( memcmp ( "PK\\1\\2" , zipentry . signature , 4 ) ) { PHAR_ZIP_FAIL ( "corrupted<S2SV_blank>central<S2SV_blank>directory<S2SV_blank>entry,<S2SV_blank>no<S2SV_blank>magic<S2SV_blank>signature" ) ; } if ( entry . is_persistent ) { entry . manifest_pos = i ; } entry . compressed_filesize = PHAR_GET_32 ( zipentry . compsize ) ; entry . uncompressed_filesize = PHAR_GET_32 ( zipentry . uncompsize ) ; entry . crc32 = PHAR_GET_32 ( zipentry . crc32 ) ; entry . timestamp = phar_zip_d2u_time ( zipentry . timestamp , zipentry . datestamp ) ; entry . flags = PHAR_ENT_PERM_DEF_FILE ; entry . header_offset = PHAR_GET_32 ( zipentry . offset ) ; entry . offset = entry . offset_abs = PHAR_GET_32 ( zipentry . offset ) + sizeof ( phar_zip_file_header ) + PHAR_GET_16 ( zipentry . filename_len ) + PHAR_GET_16 ( zipentry . extra_len ) ; if ( PHAR_GET_16 ( zipentry . flags ) & PHAR_ZIP_FLAG_ENCRYPTED ) { PHAR_ZIP_FAIL ( "Cannot<S2SV_blank>process<S2SV_blank>encrypted<S2SV_blank>zip<S2SV_blank>files" ) ; } if ( ! PHAR_GET_16 ( zipentry . filename_len ) ) { PHAR_ZIP_FAIL ( "Cannot<S2SV_blank>process<S2SV_blank>zips<S2SV_blank>created<S2SV_blank>from<S2SV_blank>stdin<S2SV_blank>(zero-length<S2SV_blank>filename)" ) ; } entry . filename_len = PHAR_GET_16 ( zipentry . filename_len ) ; entry . filename = ( char * ) pemalloc ( entry . filename_len + 1 , entry . is_persistent ) ; if ( entry . filename_len != php_stream_read ( fp , entry . filename , entry . filename_len ) ) { pefree ( entry . filename , entry . is_persistent ) ; PHAR_ZIP_FAIL ( "unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>in<S2SV_blank>filename<S2SV_blank>from<S2SV_blank>central<S2SV_blank>directory,<S2SV_blank>truncated" ) ; } entry . filename [ entry . filename_len ] = '\\0' ; if ( entry . filename [ entry . filename_len - 1 ] == '/' ) { entry . is_dir = 1 ; if ( entry . filename_len > 1 ) { entry . filename_len -- ; } entry . flags |= PHAR_ENT_PERM_DEF_DIR ; } else { entry . is_dir = 0 ; } if ( entry . filename_len == sizeof ( ".phar/signature.bin" ) - 1 && ! strncmp ( entry . filename , ".phar/signature.bin" , sizeof ( ".phar/signature.bin" ) - 1 ) ) { size_t read ; php_stream * sigfile ; zend_off_t now ; char * sig ; now = php_stream_tell ( fp ) ; pefree ( entry . filename , entry . is_persistent ) ; sigfile = php_stream_fopen_tmpfile ( ) ; if ( ! sigfile ) { PHAR_ZIP_FAIL ( "couldn\'t<S2SV_blank>open<S2SV_blank>temporary<S2SV_blank>file" ) ; } php_stream_seek ( fp , 0 , SEEK_SET ) ; php_stream_copy_to_stream_ex ( fp , sigfile , entry . header_offset , NULL ) ; php_stream_seek ( fp , PHAR_GET_32 ( locator . cdir_offset ) , SEEK_SET ) ; php_stream_copy_to_stream_ex ( fp , sigfile , beforeus - PHAR_GET_32 ( locator . cdir_offset ) , NULL ) ; if ( metadata ) { php_stream_write ( sigfile , metadata , PHAR_GET_16 ( locator . comment_len ) ) ; } php_stream_seek ( fp , sizeof ( phar_zip_file_header ) + entry . header_offset + entry . filename_len + PHAR_GET_16 ( zipentry . extra_len ) , SEEK_SET ) ; sig = ( char * ) emalloc ( entry . uncompressed_filesize ) ; read = php_stream_read ( fp , sig , entry . uncompressed_filesize ) ; <S2SV_StartBug> if ( read != entry . uncompressed_filesize ) { <S2SV_EndBug> php_stream_close ( sigfile ) ; efree ( sig ) ; PHAR_ZIP_FAIL ( "signature<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>read" ) ; } mydata -> sig_flags = PHAR_GET_32 ( sig ) ; if ( FAILURE == phar_verify_signature ( sigfile , php_stream_tell ( sigfile ) , mydata -> sig_flags , sig + 8 , entry . uncompressed_filesize - 8 , fname , & mydata -> signature , & mydata -> sig_len , error ) ) { efree ( sig ) ; if ( error ) { char * save ; php_stream_close ( sigfile ) ; spprintf ( & save , 4096 , "signature<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>verified:<S2SV_blank>%s" , * error ) ; efree ( * error ) ; PHAR_ZIP_FAIL_FREE ( save , save ) ; } else { php_stream_close ( sigfile ) ; PHAR_ZIP_FAIL ( "signature<S2SV_blank>cannot<S2SV_blank>be<S2SV_blank>verified" ) ; } } php_stream_close ( sigfile ) ; efree ( sig ) ; if ( i != PHAR_GET_16 ( locator . count ) - 1 ) { PHAR_ZIP_FAIL ( "entries<S2SV_blank>exist<S2SV_blank>after<S2SV_blank>signature,<S2SV_blank>invalid<S2SV_blank>phar" ) ; } continue ; } phar_add_virtual_dirs ( mydata , entry . filename , entry . filename_len ) ; if ( PHAR_GET_16 ( zipentry . extra_len ) ) { zend_off_t loc = php_stream_tell ( fp ) ; if ( FAILURE == phar_zip_process_extra ( fp , & entry , PHAR_GET_16 ( zipentry . extra_len ) ) ) { pefree ( entry . filename , entry . is_persistent ) ; PHAR_ZIP_FAIL ( "Unable<S2SV_blank>to<S2SV_blank>process<S2SV_blank>extra<S2SV_blank>field<S2SV_blank>header<S2SV_blank>for<S2SV_blank>file<S2SV_blank>in<S2SV_blank>central<S2SV_blank>directory" ) ; } php_stream_seek ( fp , loc + PHAR_GET_16 ( zipentry . extra_len ) , SEEK_SET ) ; } switch ( PHAR_GET_16 ( zipentry . compressed ) ) { case PHAR_ZIP_COMP_NONE : break ; case PHAR_ZIP_COMP_DEFLATE : entry . flags |= PHAR_ENT_COMPRESSED_GZ ; if ( ! PHAR_G ( has_zlib ) ) { pefree ( entry . filename , entry . is_persistent ) ; PHAR_ZIP_FAIL ( "zlib<S2SV_blank>extension<S2SV_blank>is<S2SV_blank>required" ) ; } break ; case PHAR_ZIP_COMP_BZIP2 : entry . flags |= PHAR_ENT_COMPRESSED_BZ2 ; if ( ! PHAR_G ( has_bz2 ) ) { pefree ( entry . filename , entry . is_persistent ) ; PHAR_ZIP_FAIL ( "bzip2<S2SV_blank>extension<S2SV_blank>is<S2SV_blank>required" ) ; } break ; case 1 : pefree ( entry . filename , entry . is_persistent ) ; PHAR_ZIP_FAIL ( "unsupported<S2SV_blank>compression<S2SV_blank>method<S2SV_blank>(Shrunk)<S2SV_blank>used<S2SV_blank>in<S2SV_blank>this<S2SV_blank>zip" ) ; case 2 : case 3 : case 4 : case 5 : pefree ( entry . filename , entry . is_persistent ) ; PHAR_ZIP_FAIL ( "unsupported<S2SV_blank>compression<S2SV_blank>method<S2SV_blank>(Reduce)<S2SV_blank>used<S2SV_blank>in<S2SV_blank>this<S2SV_blank>zip" ) ; case 6 : pefree ( entry . filename , entry . is_persistent ) ; PHAR_ZIP_FAIL ( "unsupported<S2SV_blank>compression<S2SV_blank>method<S2SV_blank>(Implode)<S2SV_blank>used<S2SV_blank>in<S2SV_blank>this<S2SV_blank>zip" ) ; case 7 : pefree ( entry . filename , entry . is_persistent ) ; PHAR_ZIP_FAIL ( "unsupported<S2SV_blank>compression<S2SV_blank>method<S2SV_blank>(Tokenize)<S2SV_blank>used<S2SV_blank>in<S2SV_blank>this<S2SV_blank>zip" ) ; case 9 : pefree ( entry . filename , entry . is_persistent ) ; PHAR_ZIP_FAIL ( "unsupported<S2SV_blank>compression<S2SV_blank>method<S2SV_blank>(Deflate64)<S2SV_blank>used<S2SV_blank>in<S2SV_blank>this<S2SV_blank>zip" ) ; case 10 : pefree ( entry . filename , entry . is_persistent ) ; PHAR_ZIP_FAIL ( "unsupported<S2SV_blank>compression<S2SV_blank>method<S2SV_blank>(PKWare<S2SV_blank>Implode/old<S2SV_blank>IBM<S2SV_blank>TERSE)<S2SV_blank>used<S2SV_blank>in<S2SV_blank>this<S2SV_blank>zip" ) ; case 14 : pefree ( entry . filename , entry . is_persistent ) ; PHAR_ZIP_FAIL ( "unsupported<S2SV_blank>compression<S2SV_blank>method<S2SV_blank>(LZMA)<S2SV_blank>used<S2SV_blank>in<S2SV_blank>this<S2SV_blank>zip" ) ; case 18 : pefree ( entry . filename , entry . is_persistent ) ; PHAR_ZIP_FAIL ( "unsupported<S2SV_blank>compression<S2SV_blank>method<S2SV_blank>(IBM<S2SV_blank>TERSE)<S2SV_blank>used<S2SV_blank>in<S2SV_blank>this<S2SV_blank>zip" ) ; case 19 : pefree ( entry . filename , entry . is_persistent ) ; PHAR_ZIP_FAIL ( "unsupported<S2SV_blank>compression<S2SV_blank>method<S2SV_blank>(IBM<S2SV_blank>LZ77)<S2SV_blank>used<S2SV_blank>in<S2SV_blank>this<S2SV_blank>zip" ) ; case 97 : pefree ( entry . filename , entry . is_persistent ) ; PHAR_ZIP_FAIL ( "unsupported<S2SV_blank>compression<S2SV_blank>method<S2SV_blank>(WavPack)<S2SV_blank>used<S2SV_blank>in<S2SV_blank>this<S2SV_blank>zip" ) ; case 98 : pefree ( entry . filename , entry . is_persistent ) ; PHAR_ZIP_FAIL ( "unsupported<S2SV_blank>compression<S2SV_blank>method<S2SV_blank>(PPMd)<S2SV_blank>used<S2SV_blank>in<S2SV_blank>this<S2SV_blank>zip" ) ; default : pefree ( entry . filename , entry . is_persistent ) ; PHAR_ZIP_FAIL ( "unsupported<S2SV_blank>compression<S2SV_blank>method<S2SV_blank>(unknown)<S2SV_blank>used<S2SV_blank>in<S2SV_blank>this<S2SV_blank>zip" ) ; } if ( PHAR_GET_16 ( zipentry . comment_len ) ) { if ( PHAR_GET_16 ( zipentry . comment_len ) != php_stream_read ( fp , buf , PHAR_GET_16 ( zipentry . comment_len ) ) ) { pefree ( entry . filename , entry . is_persistent ) ; PHAR_ZIP_FAIL ( "unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>in<S2SV_blank>file<S2SV_blank>comment,<S2SV_blank>truncated" ) ; } p = buf ; entry . metadata_len = PHAR_GET_16 ( zipentry . comment_len ) ; if ( phar_parse_metadata ( & p , & ( entry . metadata ) , PHAR_GET_16 ( zipentry . comment_len ) ) == FAILURE ) { entry . metadata_len = 0 ; ZVAL_NEW_STR ( & entry . metadata , zend_string_init ( buf , PHAR_GET_16 ( zipentry . comment_len ) , entry . is_persistent ) ) ; } } else { ZVAL_UNDEF ( & entry . metadata ) ; } if ( ! actual_alias && entry . filename_len == sizeof ( ".phar/alias.txt" ) - 1 && ! strncmp ( entry . filename , ".phar/alias.txt" , sizeof ( ".phar/alias.txt" ) - 1 ) ) { php_stream_filter * filter ; zend_off_t saveloc ; phar_zip_file_header local ; saveloc = php_stream_tell ( fp ) ; php_stream_seek ( fp , PHAR_GET_32 ( zipentry . offset ) , SEEK_SET ) ; if ( sizeof ( local ) != php_stream_read ( fp , ( char * ) & local , sizeof ( local ) ) ) { pefree ( entry . filename , entry . is_persistent ) ; PHAR_ZIP_FAIL ( "phar<S2SV_blank>error:<S2SV_blank>internal<S2SV_blank>corruption<S2SV_blank>of<S2SV_blank>zip-based<S2SV_blank>phar<S2SV_blank>(cannot<S2SV_blank>read<S2SV_blank>local<S2SV_blank>file<S2SV_blank>header<S2SV_blank>for<S2SV_blank>alias)" ) ; } if ( entry . filename_len != PHAR_GET_16 ( local . filename_len ) || entry . crc32 != PHAR_GET_32 ( local . crc32 ) || entry . uncompressed_filesize != PHAR_GET_32 ( local . uncompsize ) || entry . compressed_filesize != PHAR_GET_32 ( local . compsize ) ) { pefree ( entry . filename , entry . is_persistent ) ; PHAR_ZIP_FAIL ( "phar<S2SV_blank>error:<S2SV_blank>internal<S2SV_blank>corruption<S2SV_blank>of<S2SV_blank>zip-based<S2SV_blank>phar<S2SV_blank>(local<S2SV_blank>header<S2SV_blank>of<S2SV_blank>alias<S2SV_blank>does<S2SV_blank>not<S2SV_blank>match<S2SV_blank>central<S2SV_blank>directory)" ) ; } entry . offset = entry . offset_abs = sizeof ( local ) + entry . header_offset + PHAR_GET_16 ( local . filename_len ) + PHAR_GET_16 ( local . extra_len ) ; php_stream_seek ( fp , entry . offset , SEEK_SET ) ; fp -> writepos = 0 ; fp -> readpos = 0 ; php_stream_seek ( fp , entry . offset , SEEK_SET ) ; fp -> writepos = 0 ; fp -> readpos = 0 ; mydata -> alias_len = entry . uncompressed_filesize ; if ( entry . flags & PHAR_ENT_COMPRESSED_GZ ) { filter = php_stream_filter_create ( "zlib.inflate" , NULL , php_stream_is_persistent ( fp ) ) ; if ( ! filter ) { pefree ( entry . filename , entry . is_persistent ) ; PHAR_ZIP_FAIL ( "unable<S2SV_blank>to<S2SV_blank>decompress<S2SV_blank>alias,<S2SV_blank>zlib<S2SV_blank>filter<S2SV_blank>creation<S2SV_blank>failed" ) ; } php_stream_filter_append ( & fp -> readfilters , filter ) ; { zend_string * str = php_stream_copy_to_mem ( fp , entry . uncompressed_filesize , 0 ) ; if ( str ) { entry . uncompressed_filesize = ZSTR_LEN ( str ) ; actual_alias = estrndup ( ZSTR_VAL ( str ) , ZSTR_LEN ( str ) ) ; zend_string_release ( str ) ; } else { actual_alias = NULL ; entry . uncompressed_filesize = 0 ; } } if ( ! entry . uncompressed_filesize || ! actual_alias ) { pefree ( entry . filename , entry . is_persistent ) ; PHAR_ZIP_FAIL ( "unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>in<S2SV_blank>alias,<S2SV_blank>truncated" ) ; } php_stream_filter_flush ( filter , 1 ) ; php_stream_filter_remove ( filter , 1 ) ; } else if ( entry . flags & PHAR_ENT_COMPRESSED_BZ2 ) { filter = php_stream_filter_create ( "bzip2.decompress" , NULL , php_stream_is_persistent ( fp ) ) ; if ( ! filter ) { pefree ( entry . filename , entry . is_persistent ) ; PHAR_ZIP_FAIL ( "unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>in<S2SV_blank>alias,<S2SV_blank>bzip2<S2SV_blank>filter<S2SV_blank>creation<S2SV_blank>failed" ) ; } php_stream_filter_append ( & fp -> readfilters , filter ) ; { zend_string * str = php_stream_copy_to_mem ( fp , entry . uncompressed_filesize , 0 ) ; if ( str ) { entry . uncompressed_filesize = ZSTR_LEN ( str ) ; actual_alias = estrndup ( ZSTR_VAL ( str ) , ZSTR_LEN ( str ) ) ; zend_string_release ( str ) ; } else { actual_alias = NULL ; entry . uncompressed_filesize = 0 ; } } if ( ! entry . uncompressed_filesize || ! actual_alias ) { pefree ( entry . filename , entry . is_persistent ) ; PHAR_ZIP_FAIL ( "unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>in<S2SV_blank>alias,<S2SV_blank>truncated" ) ; } php_stream_filter_flush ( filter , 1 ) ; php_stream_filter_remove ( filter , 1 ) ; } else { { zend_string * str = php_stream_copy_to_mem ( fp , entry . uncompressed_filesize , 0 ) ; if ( str ) { entry . uncompressed_filesize = ZSTR_LEN ( str ) ; actual_alias = estrndup ( ZSTR_VAL ( str ) , ZSTR_LEN ( str ) ) ; zend_string_release ( str ) ; } else { actual_alias = NULL ; entry . uncompressed_filesize = 0 ; } } if ( ! entry . uncompressed_filesize || ! actual_alias ) { pefree ( entry . filename , entry . is_persistent ) ; PHAR_ZIP_FAIL ( "unable<S2SV_blank>to<S2SV_blank>read<S2SV_blank>in<S2SV_blank>alias,<S2SV_blank>truncated" ) ; } } php_stream_seek ( fp , saveloc , SEEK_SET ) ; } phar_set_inode ( & entry ) ; zend_hash_str_add_mem ( & mydata -> manifest , entry . filename , entry . filename_len , ( void * ) & entry , sizeof ( phar_entry_info ) ) ; } mydata -> fp = fp ; if ( zend_hash_str_exists ( & ( mydata -> manifest ) , ".phar/stub.php" , sizeof ( ".phar/stub.php" ) - 1 ) ) { mydata -> is_data = 0 ; } else { mydata -> is_data = 1 ; } zend_hash_str_add_ptr ( & ( PHAR_G ( phar_fname_map ) ) , mydata -> fname , fname_len , mydata ) ; if ( actual_alias ) { phar_archive_data * fd_ptr ; if ( ! phar_validate_alias ( actual_alias , mydata -> alias_len ) ) { if ( error ) { spprintf ( error , 4096 , "phar<S2SV_blank>error:<S2SV_blank>invalid<S2SV_blank>alias<S2SV_blank>\\"%s\\"<S2SV_blank>in<S2SV_blank>zip-based<S2SV_blank>phar<S2SV_blank>\\"%s\\"" , actual_alias , fname ) ; } efree ( actual_alias ) ; zend_hash_str_del ( & ( PHAR_G ( phar_fname_map ) ) , mydata -> fname , fname_len ) ; return FAILURE ; } mydata -> is_temporary_alias = 0 ; if ( NULL != ( fd_ptr = zend_hash_str_find_ptr ( & ( PHAR_G ( phar_alias_map ) ) , actual_alias , mydata -> alias_len ) ) ) { if ( SUCCESS != phar_free_alias ( fd_ptr , actual_alias , mydata -> alias_len ) ) { if ( error ) { spprintf ( error , 4096 , "phar<S2SV_blank>error:<S2SV_blank>Unable<S2SV_blank>to<S2SV_blank>add<S2SV_blank>zip-based<S2SV_blank>phar<S2SV_blank>\\"%s\\"<S2SV_blank>with<S2SV_blank>implicit<S2SV_blank>alias,<S2SV_blank>alias<S2SV_blank>is<S2SV_blank>already<S2SV_blank>in<S2SV_blank>use" , fname ) ; } efree ( actual_alias ) ; zend_hash_str_del ( & ( PHAR_G ( phar_fname_map ) ) , mydata -> fname , fname_len ) ; return FAILURE ; } } mydata -> alias = entry . is_persistent ? pestrndup ( actual_alias , mydata -> alias_len , 1 ) : actual_alias ; if ( entry . is_persistent ) { efree ( actual_alias ) ; } zend_hash_str_add_ptr ( & ( PHAR_G ( phar_alias_map ) ) , actual_alias , mydata -> alias_len , mydata ) ; } else { phar_archive_data * fd_ptr ; if ( alias_len ) { if ( NULL != ( fd_ptr = zend_hash_str_find_ptr ( & ( PHAR_G ( phar_alias_map ) ) , alias , alias_len ) ) ) { if ( SUCCESS != phar_free_alias ( fd_ptr , alias , alias_len ) ) { if ( error ) { spprintf ( error , 4096 , "phar<S2SV_blank>error:<S2SV_blank>Unable<S2SV_blank>to<S2SV_blank>add<S2SV_blank>zip-based<S2SV_blank>phar<S2SV_blank>\\"%s\\"<S2SV_blank>with<S2SV_blank>explicit<S2SV_blank>alias,<S2SV_blank>alias<S2SV_blank>is<S2SV_blank>already<S2SV_blank>in<S2SV_blank>use" , fname ) ; } zend_hash_str_del ( & ( PHAR_G ( phar_fname_map ) ) , mydata -> fname , fname_len ) ; return FAILURE ; } } zend_hash_str_add_ptr ( & ( PHAR_G ( phar_alias_map ) ) , actual_alias , mydata -> alias_len , mydata ) ; mydata -> alias = pestrndup ( alias , alias_len , mydata -> is_persistent ) ; mydata -> alias_len = alias_len ; } else { mydata -> alias = pestrndup ( mydata -> fname , fname_len , mydata -> is_persistent ) ; mydata -> alias_len = fname_len ; } mydata -> is_temporary_alias = 1 ; } if ( pphar ) { * pphar = mydata ; } return SUCCESS ; }
