static void skcipher_release ( void * private ) { <S2SV_StartBug> crypto_free_skcipher ( private ) ; <S2SV_EndBug> }
void _modinit ( module_t * m ) { service_named_bind_command ( "chanserv" , & cs_flags ) ; <S2SV_StartBug> } <S2SV_EndBug>
<S2SV_StartBug> void * H264SwDecMalloc ( u32 size ) <S2SV_EndBug> { <S2SV_StartBug> return malloc ( size ) ; <S2SV_EndBug> }
static void ast_dealloc ( AST_object * self ) <S2SV_StartBug> { <S2SV_EndBug> Py_CLEAR ( self -> dict ) ; Py_TYPE ( self ) -> tp_free ( self ) ; }
static void mark_commit ( struct commit * c , void * data ) { <S2SV_StartBug> mark_object ( & c -> object , NULL , NULL , data ) ; <S2SV_EndBug> }
static int sock_close ( struct inode * inode , struct file * filp ) { <S2SV_StartBug> sock_release ( SOCKET_I ( inode ) ) ; <S2SV_EndBug> return 0 ; }
int pure_strcmp ( const char * const s1 , const char * const s2 ) { <S2SV_StartBug> return pure_memcmp ( s1 , s2 , strlen ( s1 ) + 1U ) ; <S2SV_EndBug> }
<S2SV_StartBug> static char * print_string ( cJSON * item ) <S2SV_EndBug> { <S2SV_StartBug> return print_string_ptr ( item -> valuestring ) ; <S2SV_EndBug> }
static inline int mount_entry_on_systemfs ( struct mntent * mntent ) { <S2SV_StartBug> return mount_entry_on_generic ( mntent , mntent -> mnt_dir ) ; <S2SV_EndBug> }
static vpx_codec_err_t encoder_init ( vpx_codec_ctx_t * ctx , vpx_codec_priv_enc_mr_cfg_t * data ) { <S2SV_StartBug> return encoder_common_init ( ctx ) ; <S2SV_EndBug> }
static int hns_xgmac_get_sset_count ( int stringset ) { <S2SV_StartBug> if ( stringset == ETH_SS_STATS ) <S2SV_EndBug> return ARRAY_SIZE ( g_xgmac_stats_string ) ; return 0 ; }
void recovery_delete_character ( void ) <S2SV_StartBug> { <S2SV_EndBug> if ( strlen ( mnemonic ) > 0 ) { mnemonic [ strlen ( mnemonic ) - 1 ] = '\\0' ; } next_character ( ) ; }
<S2SV_StartBug> void generic_pipe_buf_get ( struct pipe_inode_info * pipe , struct pipe_buffer * buf ) <S2SV_EndBug> { <S2SV_StartBug> get_page ( buf -> page ) ; <S2SV_EndBug> }
static char * pool_strdup ( const char * s ) { <S2SV_StartBug> char * r = pool_alloc ( strlen ( s ) + 1 ) ; <S2SV_EndBug> <S2SV_StartBug> strcpy ( r , s ) ; <S2SV_EndBug> return r ; }
static void * skcipher_bind ( const char * name , u32 type , u32 mask ) { <S2SV_StartBug> return crypto_alloc_skcipher ( name , type , mask ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>
void vp9_frame_init_quantizer ( VP9_COMP * cpi ) { <S2SV_StartBug> cpi -> zbin_mode_boost = 0 ; <S2SV_EndBug> <S2SV_StartBug> vp9_init_plane_quantizers ( cpi , & cpi -> mb ) ; <S2SV_EndBug> }
static void ieee80211_if_setup ( struct net_device * dev ) { ether_setup ( dev ) ; <S2SV_StartBug> dev -> netdev_ops = & ieee80211_dataif_ops ; <S2SV_EndBug> dev -> destructor = free_netdev ; }
int X509_verify ( X509 * a , EVP_PKEY * r ) <S2SV_StartBug> { <S2SV_EndBug> return ( ASN1_item_verify ( ASN1_ITEM_rptr ( X509_CINF ) , a -> sig_alg , a -> signature , a -> cert_info , r ) ) ; }
static int remove_bond ( const bt_bdaddr_t * bd_addr ) <S2SV_StartBug> { <S2SV_EndBug> if ( interface_ready ( ) == FALSE ) return BT_STATUS_NOT_READY ; return btif_dm_remove_bond ( bd_addr ) ; }
static int snd_seq_device_dev_free ( struct snd_device * device ) { struct snd_seq_device * dev = device -> device_data ; <S2SV_StartBug> put_device ( & dev -> dev ) ; <S2SV_EndBug> return 0 ; }
void test_checkout_nasty__git_tilde1 ( void ) { <S2SV_StartBug> # ifdef GIT_WIN32 <S2SV_EndBug> test_checkout_fails ( "refs/heads/git_tilde1" , ".git/foobar" ) ; <S2SV_StartBug> # endif <S2SV_EndBug> }
static int jas_iccgetuint32 ( jas_stream_t * in , jas_iccuint32_t * val ) { <S2SV_StartBug> ulonglong tmp ; <S2SV_EndBug> if ( jas_iccgetuint ( in , 4 , & tmp ) ) return - 1 ; * val = tmp ; return 0 ; }
void close_uinput ( void ) { BTIF_TRACE_DEBUG ( "%s" , __FUNCTION__ ) ; if ( uinput_fd > 0 ) { <S2SV_StartBug> ioctl ( uinput_fd , UI_DEV_DESTROY ) ; <S2SV_EndBug> close ( uinput_fd ) ; uinput_fd = - 1 ; } }
static int check_line_charstring ( void ) { char * p = line ; <S2SV_StartBug> while ( isspace ( * p ) ) <S2SV_EndBug> p ++ ; return ( * p == '/' || ( p [ 0 ] == 'd' && p [ 1 ] == 'u' && p [ 2 ] == 'p' ) ) ; }
<S2SV_StartBug> static int read_segment_id ( vp9_reader * r , const struct segmentation * seg ) { <S2SV_EndBug> <S2SV_StartBug> return vp9_read_tree ( r , vp9_segment_tree , seg -> tree_probs ) ; <S2SV_EndBug> }
void * xcalloc ( size_t num , size_t size ) { <S2SV_StartBug> void * ptr = malloc ( num * size ) ; <S2SV_EndBug> if ( ptr ) { <S2SV_StartBug> memset ( ptr , '\\0' , ( num * size ) ) ; <S2SV_EndBug> } return ptr ; }
static vpx_codec_err_t ctrl_set_invert_tile_order ( vpx_codec_alg_priv_t * ctx , <S2SV_StartBug> int ctr_id , va_list args ) { <S2SV_EndBug> ctx -> invert_tile_order = va_arg ( args , int ) ; return VPX_CODEC_OK ; }
static struct o2nm_cluster * to_o2nm_cluster_from_node ( struct o2nm_node * node ) { <S2SV_StartBug> return to_o2nm_cluster ( node -> nd_item . ci_parent -> ci_parent ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>
cJSON * cJSON_GetObjectItem ( cJSON * object , const char * string ) { <S2SV_StartBug> cJSON * c = object -> child ; <S2SV_EndBug> while ( c && cJSON_strcasecmp ( c -> string , string ) ) c = c -> next ; return c ; }
void * sspi_SecureHandleGetUpperPointer ( SecHandle * handle ) { void * pointer ; <S2SV_StartBug> if ( ! handle ) <S2SV_EndBug> return NULL ; pointer = ( void * ) ~ ( ( size_t ) handle -> dwUpper ) ; return pointer ; }
static inline size_t GetPSDRowSize ( Image * image ) { if ( image -> depth == 1 ) <S2SV_StartBug> return ( ( image -> columns + 7 ) / 8 ) ; <S2SV_EndBug> else return ( image -> columns * GetPSDPacketSize ( image ) ) ; }
<S2SV_StartBug> void vp9_tree_probs_from_distribution ( vp9_tree tree , <S2SV_EndBug> unsigned int branch_ct [ ] [ 2 ] , const unsigned int num_events [ ] ) { convert_distribution ( 0 , tree , branch_ct , num_events ) ; }
int scsi_cmd_blk_ioctl ( struct block_device * bd , fmode_t mode , unsigned int cmd , void __user * arg ) { <S2SV_StartBug> return scsi_cmd_ioctl ( bd -> bd_disk -> queue , bd -> bd_disk , mode , cmd , arg ) ; <S2SV_EndBug> }
void free_bprm ( struct linux_binprm * bprm ) { free_arg_pages ( bprm ) ; if ( bprm -> cred ) { mutex_unlock ( & current -> signal -> cred_guard_mutex ) ; abort_creds ( bprm -> cred ) ; } <S2SV_StartBug> kfree ( bprm ) ; <S2SV_EndBug> }
static void put_prev_task ( struct rq * rq , struct task_struct * prev ) { if ( prev -> se . on_rq ) update_rq_clock ( rq ) ; <S2SV_StartBug> rq -> skip_clock_update = 0 ; <S2SV_EndBug> prev -> sched_class -> put_prev_task ( rq , prev ) ; }
<S2SV_StartBug> void ntlm_populate_message_header ( NTLM_MESSAGE_HEADER * header , UINT32 MessageType ) <S2SV_EndBug> { CopyMemory ( header -> Signature , NTLM_SIGNATURE , sizeof ( NTLM_SIGNATURE ) ) ; header -> MessageType = MessageType ; }
<S2SV_StartBug> static void pcrypt_free ( struct crypto_instance * inst ) <S2SV_EndBug> { <S2SV_StartBug> struct pcrypt_instance_ctx * ctx = crypto_instance_ctx ( inst ) ; <S2SV_EndBug> crypto_drop_aead ( & ctx -> spawn ) ; kfree ( inst ) ; }
cJSON * cJSON_GetArrayItem ( cJSON * array , int item ) { <S2SV_StartBug> cJSON * c = array -> child ; <S2SV_EndBug> <S2SV_StartBug> while ( c && item > 0 ) { <S2SV_EndBug> -- item ; c = c -> next ; <S2SV_StartBug> } <S2SV_EndBug> return c ; }
<S2SV_StartBug> static int decode_unsigned_max ( struct vp9_read_bit_buffer * rb , int max ) { <S2SV_EndBug> <S2SV_StartBug> const int data = vp9_rb_read_literal ( rb , get_unsigned_bits ( max ) ) ; <S2SV_EndBug> return data > max ? max : data ; }
void __scm_destroy ( struct scm_cookie * scm ) { struct scm_fp_list * fpl = scm -> fp ; int i ; if ( fpl ) { scm -> fp = NULL ; for ( i = fpl -> count - 1 ; i >= 0 ; i -- ) fput ( fpl -> fp [ i ] ) ; <S2SV_StartBug> kfree ( fpl ) ; <S2SV_EndBug> } }
static unsigned int seedsize ( struct crypto_alg * alg ) { struct rng_alg * ralg = container_of ( alg , struct rng_alg , base ) ; <S2SV_StartBug> return alg -> cra_rng . rng_make_random ? <S2SV_EndBug> alg -> cra_rng . seedsize : ralg -> seedsize ; }
<S2SV_StartBug> static void write_intra_mode ( vp9_writer * w , MB_PREDICTION_MODE mode , <S2SV_EndBug> <S2SV_StartBug> const vp9_prob * probs ) { <S2SV_EndBug> vp9_write_token ( w , vp9_intra_mode_tree , probs , & intra_mode_encodings [ mode ] ) ; }
struct bpf_map * bpf_map_get_with_uref ( u32 ufd ) { struct fd f = fdget ( ufd ) ; struct bpf_map * map ; map = __bpf_map_get ( f ) ; if ( IS_ERR ( map ) ) return map ; <S2SV_StartBug> bpf_map_inc ( map , true ) ; <S2SV_EndBug> fdput ( f ) ; return map ; }
static int amd_gpio_remove ( struct platform_device * pdev ) { struct amd_gpio * gpio_dev ; gpio_dev = platform_get_drvdata ( pdev ) ; gpiochip_remove ( & gpio_dev -> gc ) ; <S2SV_StartBug> pinctrl_unregister ( gpio_dev -> pctrl ) ; <S2SV_EndBug> return 0 ; }
<S2SV_StartBug> static int jas_iccputuint ( jas_stream_t * out , int n , ulonglong val ) <S2SV_EndBug> { int i ; int c ; for ( i = n ; i > 0 ; -- i ) { c = ( val >> ( 8 * ( i - 1 ) ) ) & 0xff ; if ( jas_stream_putc ( out , c ) == EOF ) return - 1 ; } return 0 ; }
<S2SV_StartBug> void vp9_cost_tokens_skip ( int * costs , const vp9_prob * probs , vp9_tree tree ) { <S2SV_EndBug> assert ( tree [ 0 ] <= 0 && tree [ 1 ] > 0 ) ; costs [ - tree [ 0 ] ] = vp9_cost_bit ( probs [ 0 ] , 0 ) ; cost ( costs , tree , probs , 2 , 0 ) ; }
<S2SV_StartBug> static TX_MODE read_tx_mode ( vp9_reader * r ) { <S2SV_EndBug> <S2SV_StartBug> TX_MODE tx_mode = vp9_read_literal ( r , 2 ) ; <S2SV_EndBug> if ( tx_mode == ALLOW_32X32 ) <S2SV_StartBug> tx_mode += vp9_read_bit ( r ) ; <S2SV_EndBug> return tx_mode ; }
static int linear_ioctl ( struct dm_target * ti , unsigned int cmd , unsigned long arg ) { struct linear_c * lc = ( struct linear_c * ) ti -> private ; <S2SV_StartBug> return __blkdev_driver_ioctl ( lc -> dev -> bdev , lc -> dev -> mode , cmd , arg ) ; <S2SV_EndBug> }
<S2SV_StartBug> static void buffer_pipe_buf_get ( struct pipe_inode_info * pipe , <S2SV_EndBug> struct pipe_buffer * buf ) { struct buffer_ref * ref = ( struct buffer_ref * ) buf -> private ; <S2SV_StartBug> ref -> ref ++ ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>
static inline int btif_hl_select_close_connected ( void ) { char sig_on = btif_hl_signal_select_close_connected ; BTIF_TRACE_DEBUG ( "btif_hl_select_close_connected" ) ; <S2SV_StartBug> return send ( signal_fds [ 1 ] , & sig_on , sizeof ( sig_on ) , 0 ) ; <S2SV_EndBug> }
<S2SV_StartBug> void ntlm_free_message_fields_buffer ( NTLM_MESSAGE_FIELDS * fields ) <S2SV_EndBug> { if ( fields ) { if ( fields -> Buffer ) { free ( fields -> Buffer ) ; fields -> Len = 0 ; fields -> MaxLen = 0 ; fields -> Buffer = NULL ; fields -> BufferOffset = 0 ; } } }
void vp9_lookahead_destroy ( struct lookahead_ctx * ctx ) { if ( ctx ) { if ( ctx -> buf ) { unsigned int i ; for ( i = 0 ; i < ctx -> max_sz ; i ++ ) <S2SV_StartBug> vp9_free_frame_buffer ( & ctx -> buf [ i ] . img ) ; <S2SV_EndBug> free ( ctx -> buf ) ; } free ( ctx ) ; } }
mod_ty <S2SV_StartBug> Module ( asdl_seq * body , PyArena * arena ) <S2SV_EndBug> { mod_ty p ; p = ( mod_ty ) PyArena_Malloc ( arena , sizeof ( * p ) ) ; if ( ! p ) return NULL ; p -> kind = Module_kind ; p -> v . Module . body = body ; <S2SV_StartBug> return p ; <S2SV_EndBug> }
int yr_re_ast_create ( RE_AST * * re_ast ) { * re_ast = ( RE_AST * ) yr_malloc ( sizeof ( RE_AST ) ) ; if ( * re_ast == NULL ) return ERROR_INSUFFICIENT_MEMORY ; ( * re_ast ) -> flags = 0 ; <S2SV_StartBug> ( * re_ast ) -> root_node = NULL ; <S2SV_EndBug> return ERROR_SUCCESS ; }
static int er_supported ( ERContext * s ) { if ( s -> avctx -> hwaccel && s -> avctx -> hwaccel -> decode_slice || ! s -> cur_pic . f || <S2SV_StartBug> s -> cur_pic . field_picture || <S2SV_EndBug> s -> avctx -> profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO ) return 0 ; return 1 ; }
void * gdImageGifPtr ( gdImagePtr im , int * size ) { void * rv ; gdIOCtx * out = gdNewDynamicCtx ( 2048 , NULL ) ; <S2SV_StartBug> gdImageGifCtx ( im , out ) ; <S2SV_EndBug> <S2SV_StartBug> rv = gdDPExtractData ( out , size ) ; <S2SV_EndBug> out -> gd_free ( out ) ; return rv ; }
static void <S2SV_StartBug> l2tp_proxy_auth_id_print ( netdissect_options * ndo , const u_char * dat ) <S2SV_EndBug> { <S2SV_StartBug> const uint16_t * ptr = ( const uint16_t * ) dat ; <S2SV_EndBug> ND_PRINT ( ( ndo , "%u" , EXTRACT_16BITS ( ptr ) & L2TP_PROXY_AUTH_ID_MASK ) ) ; }
long jpc_bitstream_getbits ( jpc_bitstream_t * bitstream , int n ) { long v ; int u ; <S2SV_StartBug> assert ( n >= 0 && n < 32 ) ; <S2SV_EndBug> v = 0 ; while ( -- n >= 0 ) { if ( ( u = jpc_bitstream_getbit ( bitstream ) ) < 0 ) { return - 1 ; } v = ( v << 1 ) | u ; } return v ; }