source:
 tdata_t _TIFFmalloc ( tsize_t s ) <S2SV_StartBug> { <S2SV_EndBug> return ( malloc ( ( size_t ) s ) ) ; }


target:
tdata_t _TIFFmalloc ( tsize_t s ) { if ( s == 0 ) return ( ( void * ) NULL ) ; return ( malloc ( ( size_t ) s ) ) ; }
outputs:
tdata_t _TIFFmalloc(tsize_t s) {
  if(s < 0) {
    return NULL;
  }
  return malloc((size_t)s);
}
--------------------
tdata_t _TIFFmalloc(tsize_t s) {
  return calloc(1, (size_t)s);
}
--------------------
tdata_t _TIFFmalloc(tsize_t s) {
  tdata_t ptr = malloc((size_t)s);
  if(ptr == NULL) {
    // handle error
    exit(1);
  }
  return ptr;
}
--------------------
tdata_t _TIFFmalloc(tsize_t s) {
  static tdata_t ptr = NULL;
  ptr = realloc(ptr, (size_t)s);
  if(ptr == NULL) {
    // handle error
    exit(1);
  }
  return ptr;
}
--------------------
#define POOL_SIZE 100
static tdata_t pool[POOL_SIZE];
static int pool_index = 0;

tdata_t _TIFFmalloc(tsize_t s) {
  if(pool_index >= POOL_SIZE) {
    // handle error, pool is full
    exit(1);
  }
  return pool[pool_index++];
}
--------------------
tdata_t _TIFFmalloc(tsize_t s) {
  if(s < 0 || s > SIZE_MAX) {
    return NULL;
  }
  return malloc((size_t)s);
}
--------------------
tdata_t _TIFFmalloc(tsize_t s) {
  return mmap(NULL, (size_t)s, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
}
--------------------
tdata_t _TIFFmalloc(tsize_t s) {
  // implementation of custom allocator using slab allocation
}
--------------------
tdata_t _TIFFmalloc(tsize_t s) {
  // implementation of garbage collector
}
--------------------
#include <memory>

std::unique_ptr<tdata_t> _TIFFmalloc(tsize_t s) {
  return std::unique_ptr<tdata_t>(new tdata_t[s]);
}
--------------------
match:0
source:
static void skcipher_release ( void * private ) { <S2SV_StartBug> crypto_free_skcipher ( private ) ; <S2SV_EndBug> }

target:
static void skcipher_release ( void * private ) { struct skcipher_tfm * tfm = private ; crypto_free_skcipher ( tfm -> skcipher ) ; kfree ( tfm ) ; }

outputs:
static void skcipher_release ( void * private ) {
  if (private) {
    crypto_free_skcipher ( private ) ;
    private = NULL;
  }
}
--------------------
static void skcipher_release ( void * private ) {
    crypto_free_skcipher ( private ) ;
    private = NULL;
}
--------------------
#include <stdlib.h>

static void skcipher_release ( void * private ) {
    if(private) {
        crypto_free_skcipher ( private ) ;
        free(private);
    }
}
--------------------
static void skcipher_release ( void * private ) {
    if (private != NULL) {
        crypto_free_skcipher ( private ) ;
    }
}
--------------------
static void skcipher_release ( void * private ) {
    if (private) {
        crypto_free_skcipher ( private ) ;
        private = NULL;
    }
}
--------------------
#include <stddef.h>

static void skcipher_release ( void * private ) {
    if (private != NULL) {
        crypto_free_skcipher ( private ) ;
        private = NULL;
    }
}
--------------------
#include <stddef.h>

static void skcipher_release ( void * private ) {
    if (private) {
        crypto_free_skcipher ( private ) ;
        private = NULL;
    }
}
--------------------
#include <stddef.h>

static void skcipher_release ( void * private ) {
    if (private != NULL) {
        crypto_free_skcipher ( private ) ;
    }
    private = NULL;
}
--------------------
#include <stddef.h>

static void skcipher_release ( void * private ) {
    if (private != NULL) {
        crypto_free_skcipher ( private ) ;
        private = (void*)0;
    }
}
--------------------
static void skcipher_release ( void * private ) {
    crypto_free_skcipher ( private ) ;
    private = NULL;
}
--------------------
match:0
source:
void _modinit ( module_t * m ) { service_named_bind_command ( "chanserv" , & cs_flags ) ; <S2SV_StartBug> } <S2SV_EndBug>

target:
void _modinit ( module_t * m ) { service_named_bind_command ( "chanserv" , & cs_flags ) ; add_bool_conf_item ( "ANOPE_FLAGS_COMPAT" , & chansvs . me -> conf_table , 0 , & anope_flags_compat , true ) ; hook_add_event ( "nick_can_register" ) ; hook_add_nick_can_register ( check_registration_keywords ) ; hook_add_event ( "user_can_register" ) ; hook_add_user_can_register ( check_registration_keywords ) ; }

outputs:
void _modinit ( module_t * m ) {
    service_named_bind_command ( "chanserv" , & cs_flags ) ;
    // Possible Corrective Action
    // Add other necessary code statements in modinit or use a different method to bind the command such as
    // "service_bind_command" instead of "service_named_bind_command"
}
--------------------
void _modinit ( module_t * m ) {
    // Possible Corrective Action
    // Remove the vulnerable line altogether if the cs_flags global variable is not needed in this block
}
--------------------
void _modinit ( module_t * m ) {
    // Possible Corrective Action
    // Declare and initialize the variable cs_flags before calling the function
    // service_named_bind_command ( "chanserv" , & cs_flags ) ;
}
--------------------
void _modinit ( module_t * m ) {
    // Possible Corrective Action
    // Use a function or method to initialize the global variable cs_flags
    // before calling the service_named_bind_command function
}
--------------------
// Definition of the global variable cs_flags
cs_flags my_flags;

void _modinit ( module_t * m ) {
    service_named_bind_command ( "chanserv" , & my_flags ) ;
}
// Possible Corrective Action
// Define and initialize the global variable before calling service_named_bind_command
--------------------
void _modinit ( module_t * m ) {
    // Possible Corrective Action
    // Use an alias for the service_named_bind_command function so that
    // the global variable is not directly exposed as a parameter
    bind_command("chanserv", &cs_flags);
}
--------------------
void _modinit ( module_t * m ) {
    // Possible Corrective Action
    // Use a different type of variable or structure instead of a global variable
    // for cs_flags that is not accessible externally
    static int cs_flags = 0;
    service_named_bind_command ( "chanserv" , & cs_flags ) ;
}
--------------------
void _modinit ( module_t * m ) {
    // Possible Corrective Action
    // Modify the source code so that it is not necessary the function
    // service_named_bind_command is not needed to execute the functions contained in cs_flags.
}
--------------------
void _modinit ( module_t * m ) {
    // Possible Corrective Action
    // Use a different library or system for the service_named_bind_command
    // function to avoid this vulnerability
}
--------------------
void _modinit ( module_t * m ) {
    // Possible Corrective Action
    // Use a compiler or a security tool to identify and remove the vulnerable
    // lines of code automatically
}
--------------------
match:0
source:
<S2SV_StartBug> void * H264SwDecMalloc ( u32 size ) <S2SV_EndBug> { <S2SV_StartBug> return malloc ( size ) ; <S2SV_EndBug> }

target:
void * H264SwDecMalloc ( u32 size , u32 num ) { if ( size > UINT32_MAX / num ) { return NULL ; } return malloc ( size * num ) ; }

outputs:
void * H264SwDecMalloc ( u32 size ) {
   return malloc ( size ) ;
}

// In this code block, the function is left unchanged. We assume that the function is not vulnerable, therefore, no changes are needed.
--------------------
#include <stdlib.h>

void * H264SwDecMalloc ( u32 size ) {
   return malloc ( size ) ;
}

// In this code block, we have added the include statement for the stdlib.h header file, which contains the declaration for the malloc function.
--------------------
#include <stdlib.h>

void * H264SwDecMalloc ( u32 size ) {
   void *ptr = malloc ( size ) ;

   if ( ptr == NULL ) {
      // Do error handling here
   }

   return ptr ;
}

// In this code block, we have added code to check if the malloc function fails and returns a null pointer. If the function fails, we do error handling here.
--------------------
#include <stdlib.h>

void * H264SwDecMalloc ( u32 size ) {
   void *ptr = malloc ( size ) ;

   if ( ptr == NULL ) {
      // Do error handling here
      exit(1); // Terminate program
   }

   return ptr ;
}

// In this code block, we have added code to exit the program if the malloc function fails.
--------------------
#include <stdlib.h>

void * H264SwDecMalloc ( u32 size ) {
   void *ptr = malloc ( size ) ;

   if ( ptr == NULL ) {
      // Do error handling here
      return NULL; // Return null pointer
   }

   return ptr ;
}

// In this code block, we have added code to return a null pointer if the malloc function fails.
--------------------
#include <stdlib.h>

#define MALLOC_DEBUG 1

void * H264SwDecMalloc ( u32 size ) {
   #ifdef MALLOC_DEBUG
   printf("Trying to allocate memory of size %d\n", size);
   #endif

   void *ptr = malloc ( size ) ;

   #ifdef MALLOC_DEBUG
   if ( ptr == NULL ) {
      printf("Failed to allocate memory of size %d\n", size);
   }
   else {
      printf("Successfully allocated memory of size %d at address %p\n", size, ptr);
   }
   #endif

   return ptr ;
}

// In this code block, we have added debug statements to track the allocation of memory. The MALLOC_DEBUG flag can be used to enable or disable these debug statements.
--------------------
#include <stdlib.h>

void * H264SwDecMalloc ( u32 size ) {
   void *ptr = malloc ( size + 1 ) ;

   if ( ptr == NULL ) {
      // Do error handling here
      return NULL; // Return null pointer
   }

   ((char*) ptr)[size] = 0;

   return ptr ;
}

// In this code block, we have increased the allocated memory size by 1 and set the last byte to 0. This is useful for allocating memory for strings, where the null terminator needs to be added.
--------------------
#include <stdlib.h>
#include <assert.h>

void * H264SwDecMalloc ( u32 size ) {
   void *ptr = malloc ( size ) ;

   assert( ptr != NULL ); // Assertion checks that ptr is not null

   return ptr ;
}

// In this code block, we use the assert function to validate that the pointer returned by malloc is not null.
--------------------
#include <stdlib.h>

void * H264SwDecMalloc ( u32 size ) {
   void *ptr = NULL; // Initialize ptr to null

   if ( size > 0 ) {
      ptr = malloc ( size ) ;

      if ( ptr == NULL ) {
         // Do error handling here
         return NULL;
      }
   }

   return ptr ;
}

// In this code block, we check if size is greater than 0 before calling malloc. If size is 0, we return a null pointer.
--------------------
#include <stdlib.h>

void * H264SwDecMalloc ( u32 size ) {
   size_t allocSize = size * sizeof(char);

   void *ptr = malloc ( allocSize ) ;

   if ( ptr == NULL ) {
      // Do error handling here
      return NULL; // Return null pointer
   }

   return ptr ;
}

// In this code block, we have multiplied the size argument by the size of a char to get the total allocation size. This is useful when allocating memory for arrays of characters.
--------------------
match:0
source:
static void ast_dealloc ( AST_object * self ) <S2SV_StartBug> { <S2SV_EndBug> Py_CLEAR ( self -> dict ) ; Py_TYPE ( self ) -> tp_free ( self ) ; }

target:
static void ast_dealloc ( AST_object * self ) { PyObject_GC_UnTrack ( self ) ; Py_CLEAR ( self -> dict ) ; Py_TYPE ( self ) -> tp_free ( self ) ; }

outputs:
static void ast_dealloc ( AST_object * self ) {
    if (self) {
        if (self->dict != NULL) {
            Py_DECREF(self->dict);
            self->dict = NULL;
        }
        PyTypeObject *type = Py_TYPE(self);
        if (type->tp_free) {
            type->tp_free((PyObject*)self);
        }
    }
}
--------------------
static void ast_dealloc ( AST_object * self ) {
    if (self) {
        if (self->dict != NULL) {
            Py_DECREF(self->dict);
            self->dict = NULL;
        }
        Py_TYPE(self)->tp_free((PyObject*)self);
    }
}
--------------------
static void ast_dealloc ( AST_object * self ) {
    if (self) {
        Py_CLEAR(self->dict);
        Py_TYPE(self)->tp_free((PyObject*)self);
    }
}
--------------------
static void ast_dealloc ( AST_object * self ) {
    if (self) {
        if (self->dict != NULL) {
            Py_DECREF(self->dict);
        }
        Py_TYPE(self)->tp_free((PyObject*)self);
    }
}
--------------------
static void ast_dealloc ( AST_object * self ) {
    if (self) {
        Py_XDECREF(self->dict);
        Py_TYPE(self)->tp_free((PyObject*)self);
    }
}
--------------------
static void ast_dealloc ( AST_object * self ) {
    if (self && self->dict) {
        Py_DECREF(self->dict);
    }
    Py_TYPE(self)->tp_free((PyObject*)self);
}
--------------------
static void ast_dealloc ( AST_object * self ) {
    if (self) {
        if (self->dict) {
            Py_DECREF(self->dict);
        }
        Py_TYPE(self)->tp_free((PyObject*)self);
    }
}
--------------------
static void ast_dealloc ( AST_object * self ) {
    if (self && self->dict) {
        Py_XDECREF(self->dict);
    }
    Py_TYPE(self)->tp_free((PyObject*)self);
}
--------------------
static void ast_dealloc ( AST_object * self ) {
    Py_CLEAR(self->dict);
    Py_TYPE(self)->tp_free((PyObject*)self);
}
--------------------
static void ast_dealloc ( AST_object * self ) {
    if (self) {
        Py_XDECREF(self->dict);
        Py_TYPE(self)->tp_free((PyObject*)self);
    }
    else {
        PyErr_Clear();
    }
}
--------------------
match:0
source:
 <S2SV_StartBug> int file_is_y4m ( const char detect [ 4 ] ) { <S2SV_EndBug> if ( memcmp ( detect , "YUV4" , 4 ) == 0 ) { return 1 ; } return 0 ; }


target:
static int file_is_y4m ( const char detect [ 4 ] ) { if ( memcmp ( detect , "YUV4" , 4 ) == 0 ) { return 1 ; } return 0 ; }
outputs:
int file_is_y4m(const char detect[4]) {
  if (strncmp(detect, "YUV4", 4) == 0 && detect[4] == '\0') {
    return 1;
  }
  return 0;
}
--------------------
int file_is_y4m(const char* detect) {
  size_t len = strlen(detect);
  if (len >= 4 && memcmp(detect, "YUV4", 4) == 0) {
    return 1;
  }
  return 0;
}
--------------------
#define Y4M_MAGIC "YUV4"
int file_is_y4m(const char* detect) {
  size_t len = strlen(detect);
  if (len >= strlen(Y4M_MAGIC) && memcmp(detect, Y4M_MAGIC, strlen(Y4M_MAGIC)) == 0) {
    return 1;
  }
  return 0;
}
--------------------
enum file_format {
  Y4M,
  ...
};
int detect_file_format(const char* detect) {
  if (strlen(detect) < 4) {
    return -1;
  }
  if (memcmp(detect, "YUV4", 4) == 0) {
    return Y4M;
  }
  ...
}
--------------------
enum file_format {
  Y4M,
  ...
};
int detect_file_format(const char* detect) {
  if (strlen(detect) < 4) {
    return -1;
  }
  switch (detect[0]) {
    case 'Y':
      if (memcmp(detect, "YUV4", 4) == 0) {
        return Y4M;
      }
      break;
    ...
  }
  return -1;
}
--------------------
bool file_is_y4m(const char* detect) {
  size_t len = strlen(detect);
  return (len >= strlen(Y4M_MAGIC) && memcmp(detect, Y4M_MAGIC, strlen(Y4M_MAGIC)) == 0);
}
--------------------
const char* const Y4M_MAGIC = "YUV4";
bool file_is_y4m(const char* detect) {
  size_t len = strlen(detect);
  return (len >= strlen(Y4M_MAGIC) && memcmp(detect, Y4M_MAGIC, strlen(Y4M_MAGIC)) == 0);
}
--------------------
const char* const Y4M_MAGIC = "yuv4";
bool file_is_y4m(const char* detect) {
  size_t len = strlen(detect);
  char* detect_lower = strndup(detect, len);
  for (int i = 0; i < len; i++) {
    detect_lower[i] = tolower(detect_lower[i]);
  }
  bool result = (len >= strlen(Y4M_MAGIC) && memcmp(detect_lower, Y4M_MAGIC, strlen(Y4M_MAGIC)) == 0);
  free(detect_lower);
  return result;
}
--------------------
const char* const Y4M_MAGIC = "yuv4";
bool file_is_y4m(const char* detect) {
  size_t len = strlen(detect);
  bool result = (len >= strlen(Y4M_MAGIC) && strncasecmp(detect, Y4M_MAGIC, strlen(Y4M_MAGIC)) == 0);
  return result;
}
--------------------
const char* const Y4M_MAGIC = "YUV4";
bool file_is_y4m(const char* detect) {
  return (strcmp(detect, Y4M_MAGIC) == 0);
}
--------------------
match:0
source:
static void mark_commit ( struct commit * c , void * data ) { <S2SV_StartBug> mark_object ( & c -> object , NULL , NULL , data ) ; <S2SV_EndBug> }

target:
static void mark_commit ( struct commit * c , void * data ) { mark_object ( & c -> object , NULL , data ) ; }

outputs:
static void mark_commit ( struct commit * c , void * data ) {
    mark_object ( &c->object , NULL , NULL , data ) ;
}
--------------------
static void mark_commit ( struct commit * c , void * data ) {
    if (c != NULL) { // Add NULL check to prevent accessing null pointer
        mark_object ( &c->object , NULL , NULL , data ) ;
    }
}
--------------------
static void mark_commit ( struct commit * c , void * data ) {
    if (c == NULL) { // Reverse the condition to prevent accessing null pointer
        return;
    }
    mark_object ( &c->object , NULL , NULL , data ) ;
}
--------------------
static void mark_commit ( struct commit * c , void * data ) {
    if (c == NULL) { // Reverse the condition to prevent accessing null pointer
        return;
    } else { // Add redundant else to make the code easier to read
        mark_object ( &c->object , NULL , NULL , data ) ;
    }
}
--------------------
static void mark_commit ( struct commit * c , void * data ) {
    if (c != NULL) {
        mark_object ( &c->object , NULL , NULL , data ) ;
    } else {
        // Handle the null pointer
        printf("Error: null pointer");
        exit(1);
    }
}
--------------------
static void mark_commit ( struct commit * c , void * data ) {
    if (c != NULL) {
        mark_object ( &c->object , NULL , NULL , data ) ;
    } else {
        // Handle the null pointer
        return; // simply exit the function
    }
}
--------------------
static void mark_commit ( struct commit * c , void * data ) {
    if (c != NULL) {
        mark_object ( &c->object , NULL , NULL , data ) ;
    }
    // No else condition is needed, since the function will exit naturally if `c` is null
}
--------------------
static void mark_commit ( struct commit * c , void * data ) {
    if (!c) { // Use NULL check shorthand to make the code easier to read
        return;
    }
    mark_object ( &c->object , NULL , NULL , data ) ;
}
--------------------
static void mark_commit ( struct commit * c , void * data ) {
    if (c) {
        mark_object ( &c->object , NULL , NULL , data ) ;
    } else { // Handle the null pointer
        mark_object (NULL, NULL, NULL, data);
    }
}
--------------------
static void mark_commit ( struct commit * c , void * data ) {
    mark_object ( &c->object , NULL , NULL , data ) ; // Remove the NULL checks altogether, since they are probably unnecessary
}
--------------------
match:0
source:
static int sock_close ( struct inode * inode , struct file * filp ) { <S2SV_StartBug> sock_release ( SOCKET_I ( inode ) ) ; <S2SV_EndBug> return 0 ; }

target:
static int sock_close ( struct inode * inode , struct file * filp ) { __sock_release ( SOCKET_I ( inode ) , inode ) ; return 0 ; }

outputs:
static int sock_close(struct inode* inode, struct file* filp) {
    socket_inc_users(SOCKET_I(inode));
    sock_release(SOCKET_I(inode));
    return 0;
}
--------------------
static int sock_close(struct inode* inode, struct file* filp) {
    sock_release(SOCKET_I(inode));
    return 0;
}
--------------------
static int sock_close(struct inode* inode, struct file* filp) {
    socket_destruct_data(SOCKET_I(inode));
    sock_release(SOCKET_I(inode));
    return 0;
}
--------------------
static int sock_close(struct inode* inode, struct file* filp) {
    sock_shutdown(SOCKET_I(inode), SHUT_RDWR);
    sock_release(SOCKET_I(inode));
    return 0;
}
--------------------
static int sock_close(struct inode* inode, struct file* filp) {
    fput(SOCKET_I(inode)->file);
    return 0;
}
--------------------
static int sock_close(struct inode* inode, struct file* filp) {
    sock_release(SOCKET_I(inode));
    filp->private_data = NULL;
    return 0;
}
--------------------
static int sock_close(struct inode* inode, struct file* filp) {
    wake_up_interruptible(&SOCKET_I(inode)->wq);
    sock_release(SOCKET_I(inode));
    return 0;
}
--------------------
static int sock_close(struct inode* inode, struct file* filp) {
    socket_drop(inode);
    return 0;
}
--------------------
static int sock_close(struct inode* inode, struct file* filp) {
    sock_def_readable(inode);
    sock_release(SOCKET_I(inode));
    return 0;
}
--------------------
static int sock_close(struct inode* inode, struct file* filp) {
    sock_def_writable(inode);
    sock_release(SOCKET_I(inode));
    return 0;
}
--------------------
match:0
source:
 static int sock_close ( struct inode * inode , struct file * filp ) { <S2SV_StartBug> sock_release ( SOCKET_I ( inode ) ) ; <S2SV_EndBug> return 0 ; }


target:
static int sock_close ( struct inode * inode , struct file * filp ) { __sock_release ( SOCKET_I ( inode ) , inode ) ; return 0 ; }
outputs:
static int sock_close(struct inode *inode, struct file *filp) {
    if(SOCKET_I(inode) != NULL){
        sock_release (SOCKET_I(inode));
    }
    return 0;
}
--------------------
static int sock_close(struct inode *inode, struct file *filp) {
    if (SOCKET_I(inode)) {
        sock_release(SOCKET_I(inode));
    }
    return 0;
}
--------------------
static int sock_close(struct inode *inode, struct file *filp) {
    if (inode && SOCKET_I(inode)) {
        sock_release(SOCKET_I(inode));
    }
    return 0;
}
--------------------
static int sock_close(struct inode *inode, struct file *filp) {
    if (filp->private_data) {
        sock_release(filp->private_data);
    }
    return 0;
}
--------------------
static int sock_close(struct inode *inode, struct file *filp) {
    int ret = 0;
    if (filp->private_data) {
        ret = sock_release(filp->private_data);
        if (ret < 0) {
            printk(KERN_ERR "sock_close: Failed to release socket\n");
        }
    }
    return ret;
}
--------------------
static int sock_close(struct inode *inode, struct file *filp) {
    int ret = 0;
    if (filp->private_data) {
        mutex_lock(&filp->private_data->sk_mutex);
        ret = sock_release(filp->private_data);
        mutex_unlock(&filp->private_data->sk_mutex);
        if (ret < 0) {
            printk(KERN_ERR "sock_close: Failed to release socket\n");
        }
    }
    return ret;
}
--------------------
static int sock_close(struct inode *inode, struct file *filp) {
    int ret = 0;
    if (filp->private_data) {
        spin_lock_bh(&filp->private_data->sk_lock);
        ret = sock_release(filp->private_data);
        spin_unlock_bh(&filp->private_data->sk_lock);
        if (ret < 0) {
            printk(KERN_ERR "sock_close: Failed to release socket\n");
        }
    }
    return ret;
}
--------------------
static int sock_close(struct inode *inode, struct file *filp) {
    int ret = 0;
    struct sock *sk;
    if (filp->private_data) {
        sk = filp->private_data;
        mutex_lock(&sk->sk_mutex);
        if (atomic_dec_and_test(&sk->sk_users)) {
            ret = sock_release(sk);
        }
        mutex_unlock(&sk->sk_mutex);
        if (ret < 0) {
            printk(KERN_ERR "sock_close: Failed to release socket\n");
        }
    }
    return ret;
}
--------------------
static int sock_close(struct inode *inode, struct file *filp) {
    int ret = 0;
    struct sock *sk;
    if (filp->private_data) {
        sk = filp->private_data;
        mutex_lock(&sk->sk_mutex);
        if (atomic_dec_and_test(&sk->sk_users)) {
            ret = sock_release(sk);
        }
        mutex_unlock(&sk->sk_mutex);
        if (ret < 0) {
            printk(KERN_ERR "sock_close: Failed to release socket\n");
        }
        filp->private_data = NULL;
    }
    return ret;
}
--------------------
static int sock_close(struct inode *inode, struct file *filp) {
    int ret = 0;
    struct sock *sk;
    if (filp->private_data) {
        sk = filp->private_data;
        mutex_lock(&sk->sk_mutex);
        if (atomic_dec_and_test(&sk->sk_users)) {
            sock_release(sk);
        }
        mutex_unlock(&sk->sk_mutex);
        kfree(sk);
        filp->private_data = NULL;
    }
    return ret;
}
--------------------
match:0
source:
int pure_strcmp ( const char * const s1 , const char * const s2 ) { <S2SV_StartBug> return pure_memcmp ( s1 , s2 , strlen ( s1 ) + 1U ) ; <S2SV_EndBug> }

target:
int pure_strcmp ( const char * const s1 , const char * const s2 ) { const size_t s1_len = strlen ( s1 ) ; const size_t s2_len = strlen ( s2 ) ; const size_t len = ( s1_len < s2_len ) ? s1_len : s2_len ; return pure_memcmp ( s1 , s2 , len + 1 ) ; }

outputs:
int pure_strcmp ( const char * const s1 , const char * const s2 ) {
    return strcmp(s1, s2);
}
--------------------
int pure_strcmp ( const char * const s1 , const char * const s2 ) {
    return memcmp(s1, s2, strlen(s1) + 1U);
}
--------------------
int pure_strcmp ( const char * const s1 , const char * const s2 ) {
    size_t s1_len = strlen(s1);
    size_t s2_len = strlen(s2);
    int len_diff = s1_len - s2_len;
    int cmp_result = memcmp(s1, s2, (s1_len < s2_len) ? s1_len + 1 : s2_len + 1);
    if (cmp_result != 0) {
        return cmp_result;
    } else {
        return len_diff;
    }
}
--------------------
int pure_strcmp ( const char * const s1 , const char * const s2 ) {
    size_t s1_len = strlen(s1);
    size_t s2_len = strlen(s2);
    if (s1_len != s2_len) {
        return -1;
    }
    for (int i = 0; i < s1_len; i++) {
        if (s1[i] != s2[i]) {
            return -1;
        }
    }
    return 0;
}
--------------------
int pure_strcmp ( const char * const s1 , const char * const s2 ) {
    size_t s1_len = strlen(s1);
    size_t s2_len = strlen(s2);
    if (s1_len != s2_len) {
        return -1;
    }
    for (int i = 0; i < s1_len; i++) {
        if (s1[i] != s2[i]) {
            if (s1[i] < s2[i]) {
                return -1;
            } else {
                return 1;
            }
        }
    }
    return 0;
}
--------------------
int pure_strcmp ( const char * const s1 , const char * const s2 ) {
    size_t s1_len = strlen(s1);
    size_t s2_len = strlen(s2);
    for (int i = 0; i < s1_len || i < s2_len; i++) {
        if (s1[i] != s2[i]) {
            if (s1[i] < s2[i]) {
                return -1;
            } else {
                return 1;
            }
        }
    }
    return 0;
}
--------------------
int pure_strcmp ( const char * const s1 , const char * const s2 ) {
    size_t s1_len = strlen(s1);
    size_t s2_len = strlen(s2);
    for (int i = 0; i < s1_len && i < s2_len; i++) {
        if (s1[i] != s2[i]) {
            if (s1[i] < s2[i]) {
                return -1;
            } else {
                return 1;
            }
        }
    }
    if (s1_len < s2_len) {
        return -1;
    } else if (s1_len > s2_len) {
        return 1;
    } else {
        return 0;
    }
}
--------------------
int pure_strcmp ( const char * const s1 , const char * const s2 ) {
    size_t s1_len = strlen(s1);
    size_t s2_len = strlen(s2);
    for (int i = 0; i < s1_len && i < s2_len; i++) {
        if (s1[i] != s2[i]) {
            if (s1[i] < s2[i]) {
                return -1;
            } else {
                return 1;
            }
        }
    }
    if (s1_len == s2_len) {
        return 0;
    } else if (s1_len < s2_len) {
        return -1;
    } else {
        return 1;
    }
}
--------------------
int pure_strcmp ( const char * const s1 , const char * const s2 ) {
    size_t s1_len = strlen(s1);
    size_t s2_len = strlen(s2);
    int cmp_result = strncmp(s1, s2, (s1_len < s2_len) ? s1_len + 1 : s2_len + 1);
    if (cmp_result != 0) {
        return cmp_result;
    } else {
        return s1_len - s2_len;
    }
}
--------------------
int pure_strcmp ( const char * const s1 , const char * const s2 ) {
    size_t s1_len = strlen(s1);
    size_t s2_len = strlen(s2);
    int cmp_result = strncmp(s1, s2, (s1_len < s2_len) ? s1_len + 1 : s2_len + 1);
    if (cmp_result != 0) {
        return cmp_result;
    } else if (s1_len == s2_len) {
        return 0;
    } else if (s1_len < s2_len) {
        return -1;
    } else {
        return 1;
    }
}
--------------------
match:0
source:
<S2SV_StartBug> static char * print_string ( cJSON * item ) <S2SV_EndBug> { <S2SV_StartBug> return print_string_ptr ( item -> valuestring ) ; <S2SV_EndBug> }

target:
static char * print_string ( cJSON * item , printbuffer * p ) { return print_string_ptr ( item -> valuestring , p ) ; }

outputs:
static char * print_string ( cJSON * item ) {
    if(item == NULL || !cJSON_IsString(item)) {
        return "";
    }
    return print_string_ptr ( item -> valuestring ) ;
}
--------------------
static char * print_string ( cJSON * item ) {
    if(item == NULL || item -> valuestring == NULL){
        return "";
    }
    return print_string_ptr ( item -> valuestring ) ;
}
--------------------
static char * print_string ( cJSON * item ) {
    if(item == NULL || !cJSON_IsString(item)){
        return "NULL";
    }
    return print_string_ptr ( item -> valuestring ) ;
}
--------------------
static char * print_string ( cJSON * item ) {
    if(item == NULL || item -> valuestring == NULL || !cJSON_IsString(item)) {
        return "NULL";
    }
    return print_string_ptr ( item -> valuestring ) ;
}
--------------------
static char * print_string ( cJSON * item ) {
    if(item == NULL){
        return "";
    } else if(item -> valuestring == NULL){
        return "NULL";
    }
    return print_string_ptr ( item -> valuestring ) ;
}
--------------------
static char * print_string ( cJSON * item ) {
    if(!item || !item -> valuestring){
        return "null";
    }
    return print_string_ptr ( item -> valuestring ) ;
}
--------------------
static char * print_string ( cJSON * item ) {
     if(item == NULL){
        return "";
     } else if(!cJSON_IsString(item)){
        return "NULL";
     } else if(item -> valuestring == NULL){
        return "";
     }
     return print_string_ptr ( item -> valuestring ) ;
}
--------------------
static char * print_string ( cJSON * item ) {
     if(!item || !cJSON_IsString(item)){
        return "";
     } else if(!item -> valuestring){
        return "NULL";
     }
     return print_string_ptr ( item -> valuestring ) ;
}
--------------------
static char * print_string ( cJSON * item ) {
     if(item == NULL || item -> valuestring == NULL){
        return "";
     }
     if(!cJSON_IsString(item)){
        return "NULL";
     }
     return print_string_ptr ( item -> valuestring ) ;
}
--------------------
static char * print_string ( cJSON * item ) {
     if(!item || !item -> valuestring){
        return "";
     } else if(!cJSON_IsString(item)){
        return "";
     }
     return print_string_ptr ( item -> valuestring ) ;
}
--------------------
match:0
source:
static inline int mount_entry_on_systemfs ( struct mntent * mntent ) { <S2SV_StartBug> return mount_entry_on_generic ( mntent , mntent -> mnt_dir ) ; <S2SV_EndBug> }

target:
static inline int mount_entry_on_systemfs ( struct mntent * mntent ) { return mount_entry_on_generic ( mntent , mntent -> mnt_dir , NULL ) ; }

outputs:
static inline int mount_entry_on_systemfs ( struct mntent * mntent ) {
    return mount_entry_on_generic ( mntent , mntent -> mnt_dir ) ;
}
--------------------
static inline int mount_entry_on_systemfs ( struct mntent * mntent ) {
    char* mnt_dir = mntent -> mnt_dir;
    return mount_entry_on_generic ( mntent , mnt_dir ) ;
}
--------------------
static inline int mount_entry_on_systemfs ( struct mntent * mntent ) {
    if(mntent == NULL || mntent -> mnt_dir == NULL) {
        return -1;
    }
    return mount_entry_on_generic ( mntent , mntent -> mnt_dir ) ;
}
--------------------
static inline int mount_entry_on_systemfs ( struct mntent * mntent ) {
    if(mntent == NULL || mntent -> mnt_dir == NULL) {
        return -1;
    }
    char* mnt_dir = mntent -> mnt_dir;
    return mount_entry_on_generic ( mntent , mnt_dir ) ;
}
--------------------
static inline int mount_entry_on_systemfs ( struct mntent * mntent ) {
    if(mntent == NULL) {
        return -1;
    }
    char* mnt_dir = mntent -> mnt_dir;
    return mount_entry_on_generic ( mntent , mnt_dir ) ;
}
--------------------
static inline int mount_entry_on_systemfs ( struct mntent * mntent ) {
    if(mntent == NULL || mntent -> mnt_dir == NULL) {
        return -1;
    }
    char* mnt_dir = (char*)malloc(strlen(mntent -> mnt_dir) + 1);
    strcpy(mnt_dir, mntent -> mnt_dir);
    return mount_entry_on_generic ( mntent , mnt_dir ) ;
}
--------------------
static inline int mount_entry_on_systemfs ( struct mntent * mntent ) {
    if(mntent == NULL || mntent -> mnt_dir == NULL) {
        return -1;
    }
    char* mnt_dir = (char*)calloc(strlen(mntent -> mnt_dir) + 1, sizeof(char));
    strcpy(mnt_dir, mntent -> mnt_dir);
    return mount_entry_on_generic ( mntent , mnt_dir ) ;
}
--------------------
static inline int mount_entry_on_systemfs ( struct mntent * mntent ) {
    if(mntent == NULL) {
        return -1;
    }
    char* mnt_dir = mntent -> mnt_dir;
    int result = mount_entry_on_generic ( mntent , mnt_dir );
    free(mnt_dir);
    return result;
}
--------------------
static inline int mount_entry_on_systemfs ( struct mntent * mntent ) {
    if(mntent == NULL || mntent -> mnt_dir == NULL) {
        return -1;
    }
    char* mnt_dir = mntent -> mnt_dir;
    int result = mount_entry_on_generic ( mntent , mnt_dir );
    free(mnt_dir);
    return result;
}
--------------------
static inline int mount_entry_on_systemfs ( struct mntent * mntent ) {
    if(mntent == NULL || mntent -> mnt_dir == NULL) {
        return -1;
    }
    char* mnt_dir = (char*)calloc(strlen(mntent -> mnt_dir) + 1, sizeof(char));
    strcpy(mnt_dir, mntent -> mnt_dir);
    int result = mount_entry_on_generic ( mntent , mnt_dir );
    free(mnt_dir);
    return result;
}
--------------------
match:0
source:
static vpx_codec_err_t encoder_init ( vpx_codec_ctx_t * ctx , vpx_codec_priv_enc_mr_cfg_t * data ) { <S2SV_StartBug> return encoder_common_init ( ctx ) ; <S2SV_EndBug> }

target:
static vpx_codec_err_t encoder_init ( vpx_codec_ctx_t * ctx , vpx_codec_priv_enc_mr_cfg_t * data ) { vpx_codec_err_t res = VPX_CODEC_OK ; ( void ) data ; if ( ctx -> priv == NULL ) { vpx_codec_alg_priv_t * const priv = vpx_calloc ( 1 , sizeof ( * priv ) ) ; if ( priv == NULL ) return VPX_CODEC_MEM_ERROR ; ctx -> priv = ( vpx_codec_priv_t * ) priv ; ctx -> priv -> init_flags = ctx -> init_flags ; ctx -> priv -> enc . total_encoders = 1 ; priv -> buffer_pool = ( BufferPool * ) vpx_calloc ( 1 , sizeof ( BufferPool ) ) ; if ( priv -> buffer_pool == NULL ) return VPX_CODEC_MEM_ERROR ; # if CONFIG_MULTITHREAD if ( pthread_mutex_init ( & priv -> buffer_pool -> pool_mutex , NULL ) ) { return VPX_CODEC_MEM_ERROR ; } # endif if ( ctx -> config . enc ) { priv -> cfg = * ctx -> config . enc ; ctx -> config . enc = & priv -> cfg ; } priv -> extra_cfg = default_extra_cfg ; once ( vp9_initialize_enc ) ; res = validate_config ( priv , & priv -> cfg , & priv -> extra_cfg ) ; if ( res == VPX_CODEC_OK ) { set_encoder_config ( & priv -> oxcf , & priv -> cfg , & priv -> extra_cfg ) ; # if CONFIG_VP9_HIGHBITDEPTH priv -> oxcf . use_highbitdepth = ( ctx -> init_flags & VPX_CODEC_USE_HIGHBITDEPTH ) ? 1 : 0 ; # endif priv -> cpi = vp9_create_compressor ( & priv -> oxcf , priv -> buffer_pool ) ; if ( priv -> cpi == NULL ) res = VPX_CODEC_MEM_ERROR ; else priv -> cpi -> output_pkt_list = & priv -> pkt_list . head ; } } return res ; }

outputs:
static vpx_codec_err_t encoder_init ( vpx_codec_ctx_t * ctx , vpx_codec_priv_enc_mr_cfg_t * data ) {
    encoder_common_init ( ctx );
    return VPX_CODEC_OK;
}
--------------------
static vpx_codec_err_t encoder_init ( vpx_codec_ctx_t * ctx , vpx_codec_priv_enc_mr_cfg_t * data ) {
    vpx_codec_err_t res = encoder_common_init ( ctx );
    if(res != VPX_CODEC_OK) return res;
    return VPX_CODEC_OK;
}
--------------------
static vpx_codec_err_t encoder_init ( vpx_codec_ctx_t * ctx , vpx_codec_priv_enc_mr_cfg_t * data ) {
    if(!ctx) return VPX_CODEC_INVALID_PARAM;
    return encoder_common_init ( ctx ) ;
}
--------------------
static vpx_codec_err_t encoder_init ( vpx_codec_ctx_t * ctx , vpx_codec_priv_enc_mr_cfg_t * data ) {
    vpx_codec_err_t res = encoder_common_init ( ctx );
    if(res == VPX_CODEC_MEM_ERROR) return VPX_CODEC_MEM_ERROR;
    return VPX_CODEC_OK;
}
--------------------
static vpx_codec_err_t encoder_init ( vpx_codec_ctx_t * ctx , vpx_codec_priv_enc_mr_cfg_t * data ) {
    vpx_codec_err_t res = VPX_CODEC_OK;
    if(!ctx) res = VPX_CODEC_INVALID_PARAM;
    if(res == VPX_CODEC_OK) res = encoder_common_init ( ctx );
    return res;
}
--------------------
static vpx_codec_err_t encoder_init ( vpx_codec_ctx_t * ctx , vpx_codec_priv_enc_mr_cfg_t * data ) {
    if(!ctx) return VPX_CODEC_INVALID_PARAM;
    return encoder_common_init ( ctx ) ;
    return VPX_CODEC_OK;
}
--------------------
static vpx_codec_err_t encoder_init ( vpx_codec_ctx_t * ctx , vpx_codec_priv_enc_mr_cfg_t * data ) {
    if(!ctx) return VPX_CODEC_INVALID_PARAM;
    if(encoder_common_init ( ctx ) != VPX_CODEC_OK) return VPX_CODEC_ERROR;
    return VPX_CODEC_OK;
}
--------------------
static vpx_codec_err_t encoder_init ( vpx_codec_ctx_t * ctx , vpx_codec_priv_enc_mr_cfg_t * data ) {
    vpx_codec_err_t res = encoder_common_init ( ctx );
    if(res != VPX_CODEC_OK) return res;
    if(ctx) return VPX_CODEC_OK;
    return VPX_CODEC_INVALID_PARAM;
}
--------------------
static vpx_codec_err_t encoder_init ( vpx_codec_ctx_t * ctx , vpx_codec_priv_enc_mr_cfg_t * data ) {
    vpx_codec_err_t res = encoder_common_init ( ctx );
    if(res != VPX_CODEC_OK) return res;
    if(ctx->priv) return VPX_CODEC_OK;
    return VPX_CODEC_INVALID_PARAM;
}
--------------------
static vpx_codec_err_t encoder_init ( vpx_codec_ctx_t * ctx , vpx_codec_priv_enc_mr_cfg_t * data ) {
    if(!ctx || !ctx->priv) return VPX_CODEC_INVALID_PARAM;
    return encoder_common_init ( ctx ) ;
}
--------------------
match:0
source:
 void vp8_default_coef_probs ( VP8_COMMON * pc ) { <S2SV_StartBug> vpx_memcpy ( pc -> fc . coef_probs , default_coef_probs , <S2SV_EndBug> sizeof ( default_coef_probs ) ) ; }


target:
void vp8_default_coef_probs ( VP8_COMMON * pc ) { memcpy ( pc -> fc . coef_probs , default_coef_probs , sizeof ( default_coef_probs ) ) ; }
outputs:
void vp8_default_coef_probs(VP8_COMMON *pc) {
  if (pc) {
    vpx_memcpy(pc->fc.coef_probs, default_coef_probs, sizeof(default_coef_probs));
  } else {
    // handle error, log or return error code
  }
}
--------------------
void vp8_default_coef_probs(VP8_COMMON *pc) {
  if (pc) {
    memcpy_s(pc->fc.coef_probs, sizeof(pc->fc.coef_probs), default_coef_probs, sizeof(default_coef_probs));
  } else {
    // handle error, log or return error code
  }
}
--------------------
#define COEF_PROBS_SIZE sizeof(default_coef_probs)

void vp8_default_coef_probs(VP8_COMMON *pc) {
  if (pc) {
    vpx_memcpy(pc->fc.coef_probs, default_coef_probs, COEF_PROBS_SIZE);
  } else {
    // handle error, log or return error code
  }
}
--------------------
void vp8_default_coef_probs(VP8_COMMON *pc) {
  size_t size = sizeof(default_coef_probs);
  if (pc) {
    vpx_memcpy(pc->fc.coef_probs, default_coef_probs, size);
  } else {
    // handle error, log or return error code
  }
}
--------------------
void vp8_default_coef_probs(VP8_COMMON *pc) {
  if (pc) {
    memmove(pc->fc.coef_probs, default_coef_probs, sizeof(default_coef_probs));
  } else {
    // handle error, log or return error code
  }
}
--------------------
void vp8_default_coef_probs(VP8_COMMON *pc) {
  if (pc && sizeof(pc->fc.coef_probs) >= sizeof(default_coef_probs)) {
    vpx_memcpy(pc->fc.coef_probs, default_coef_probs, sizeof(default_coef_probs));
  } else {
    // handle error, log or return error code
  }
}
--------------------
void vp8_default_coef_probs(VP8_COMMON *pc) {
  if (!pc) {
    // handle null pointer input error, log or return error code
    return;
  }
  vpx_memcpy(pc->fc.coef_probs, default_coef_probs, sizeof(default_coef_probs));
}
--------------------
void vp8_default_coef_probs(VP8_COMMON *pc) {
  if (pc && sizeof(pc->fc.coef_probs) >= sizeof(default_coef_probs)) {
    volatile int guard = 0;
    // add guard code here
    vpx_memcpy(pc->fc.coef_probs, default_coef_probs, sizeof(default_coef_probs));
    guard += 1; // update guard code to prevent compiler optimization
  } else {
    // handle error, log or return error code
  }
}
--------------------
#define CHECK_NULL_PTR(ptr) if (!ptr) { return; /* or handle error */ }
#define COEF_PROBS_SIZE sizeof(default_coef_probs)

void vp8_default_coef_probs(VP8_COMMON *pc) {
  CHECK_NULL_PTR(pc)
  vpx_memcpy(pc->fc.coef_probs, default_coef_probs, COEF_PROBS_SIZE);
}
--------------------
/**
 * Copies the default coefficient probabilities from the global array to the given VP8_COMMON instance.
 * @param pc Pointer to the VP8_COMMON instance to copy the probabilities to
 */
void vp8_default_coef_probs(VP8_COMMON *pc) {
  if (pc) {
    vpx_memcpy(pc->fc.coef_probs, default_coef_probs, sizeof(default_coef_probs));
  } else {
    // handle error, log or return error code
  }
}
--------------------
match:0
source:
static int hns_xgmac_get_sset_count ( int stringset ) { <S2SV_StartBug> if ( stringset == ETH_SS_STATS ) <S2SV_EndBug> return ARRAY_SIZE ( g_xgmac_stats_string ) ; return 0 ; }

target:
static int hns_xgmac_get_sset_count ( int stringset ) { if ( stringset == ETH_SS_STATS || stringset == ETH_SS_PRIV_FLAGS ) return ARRAY_SIZE ( g_xgmac_stats_string ) ; return 0 ; }

outputs:
static int hns_xgmac_get_sset_count ( int stringset ) {
   if ( stringset == ETH_SS_STATS )
      return (int) ARRAY_SIZE ( g_xgmac_stats_string ) ;
   return 0 ;
}
--------------------
static int hns_xgmac_get_sset_count ( int stringset ) {
   if ( stringset == ETH_SS_STATS )
      return (int) sizeof(g_xgmac_stats_string)/sizeof(g_xgmac_stats_string[0]);
   return 0 ;
}
--------------------
static int hns_xgmac_get_sset_count ( int stringset ) {
   return (stringset == ETH_SS_STATS) ? ARRAY_SIZE(g_xgmac_stats_string) : 0;
}
--------------------
static int hns_xgmac_get_sset_count ( int stringset ) {
   if ( stringset != ETH_SS_STATS )
      return 0 ;
   return ARRAY_SIZE ( g_xgmac_stats_string );
}
--------------------
static int hns_xgmac_get_sset_count ( int stringset ) {
   int count = 0;
   if ( stringset == ETH_SS_STATS )
      count = ARRAY_SIZE ( g_xgmac_stats_string ) ;
   return count;
}
--------------------
static int hns_xgmac_get_sset_count ( int stringset ) {
   return ( stringset == ETH_SS_STATS ) ? (int)ARRAY_SIZE( g_xgmac_stats_string ) : 0;
}
--------------------
#define IS_ETH_SS_STATS(x) (x == ETH_SS_STATS)

static int hns_xgmac_get_sset_count ( int stringset ) {
   if(IS_ETH_SS_STATS(stringset))
      return ARRAY_SIZE(g_xgmac_stats_string);
   return 0;
}
--------------------
static int hns_xgmac_get_sset_count ( int stringset ) {
   int count = 0;
   if(stringset == ETH_SS_STATS)
      count = ARRAY_SIZE(g_xgmac_stats_string);
   else
      count = -EINVAL;
   return count;
}
--------------------
static int hns_xgmac_get_sset_count ( int stringset ) {
   if(stringset != ETH_SS_STATS)
      return EINVAL;
   else
      return ARRAY_SIZE(g_xgmac_stats_string);
}
--------------------
#define ETH_SS_STATS 1

static int hns_xgmac_get_sset_count ( int stringset ) {
   if(stringset == ETH_SS_STATS)
      return ARRAY_SIZE(g_xgmac_stats_string);
   return -EINVAL;
}
--------------------
match:0
source:
void recovery_delete_character ( void ) <S2SV_StartBug> { <S2SV_EndBug> if ( strlen ( mnemonic ) > 0 ) { mnemonic [ strlen ( mnemonic ) - 1 ] = '\\0' ; } next_character ( ) ; }

target:
void recovery_delete_character ( void ) { if ( ! recovery_started ) { recovery_abort ( ) ; fsm_sendFailure ( FailureType_Failure_UnexpectedMessage , "NotinRecoverymode" ) ; layoutHome ( ) ; return ; } if ( strlen ( mnemonic ) > 0 ) { mnemonic [ strlen ( mnemonic ) - 1 ] = '\\0' ; } next_character ( ) ; }

outputs:
void recovery_delete_character ( void ) {
    if ( strlen ( mnemonic ) > 0 ) {
        mnemonic [ strlen ( mnemonic ) - 1 ] = '\0' ;
    }
    next_character ( ) ;
}
--------------------
void recovery_delete_character ( void ) {
    size_t len_mnemonic = strlen(mnemonic);
    if (len_mnemonic > 0) {
        mnemonic [len_mnemonic - 1] = '\0';
    }
    next_character();
}
--------------------
void recovery_delete_character ( void ) {
    // Check for a non-empty mnemonic before deleting the last character
    if (strlen(mnemonic) > 0) {
        mnemonic[strlen(mnemonic) - 1] = '\0';
    }
    next_character();
}
--------------------
void recovery_delete_character (void) {
    if (strlen(mnemonic) < 1) {
        next_character();
        return;
    }

    mnemonic[strlen(mnemonic) - 1] = '\0';
    next_character();
}
--------------------
void recovery_delete_character(void) {
    if (strlen(mnemonic) > 0) {
        mnemonic[strlen(mnemonic) - 1] = 0; // zero assignment equivalent of '\0'
    }
    next_character();
}
--------------------
void recovery_delete_character(void) {
    size_t mnem_len = strlen(mnemonic);
    if (mnem_len > 0) {
        mnemonic[mnem_len - 1] = '\0';
    }
    next_character();
}
--------------------
void recovery_delete_character (void) {
    if (strlen(mnemonic) > 0) {
        mnemonic[strlen(mnemonic) - 1] = '\0';
        next_character();
    } else {
        // Do nothing, the mnemonic is already empty
    }
}
--------------------
void recovery_delete_character (void) {
    if (strlen(mnemonic) <= 0) {
        next_character();
        return;
    }

    mnemonic[strlen(mnemonic) - 1] = '\0';
    next_character();
}
--------------------
void recovery_delete_character (void) {
    if (strlen(mnemonic) > 0) {
        mnemonic[strlen(mnemonic) - 1] = '\0';
    } else {
        // Do not call next_character() if the mnemonic is already empty
        return;
    }
    next_character();
}
--------------------
void recovery_delete_character (void) {
    if (strlen(mnemonic) > 0) {
        mnemonic[strlen(mnemonic) - 1] = 0; // Assigning zero has same effect as assigning '\0'
    }
    next_character();
}
--------------------
match:0
source:
<S2SV_StartBug> void generic_pipe_buf_get ( struct pipe_inode_info * pipe , struct pipe_buffer * buf ) <S2SV_EndBug> { <S2SV_StartBug> get_page ( buf -> page ) ; <S2SV_EndBug> }

target:
bool generic_pipe_buf_get ( struct pipe_inode_info * pipe , struct pipe_buffer * buf ) { return try_get_page ( buf -> page ) ; }

outputs:
void generic_pipe_buf_get (struct pipe_inode_info * pipe , struct pipe_buffer * buf ) {
    get_user_pages(buf->page, 1, FOLL_TOUCH, NULL);
}
--------------------
void generic_pipe_buf_get (struct pipe_inode_info * pipe , struct pipe_buffer * buf ) {
    get_user_pages_remote(current, current->mm, (unsigned long)buf->page, 1, FOLL_TOUCH, NULL, NULL);
}
--------------------
void generic_pipe_buf_get (struct pipe_inode_info * pipe , struct pipe_buffer * buf ) {
    pin_page(buf->page);
}
--------------------
void generic_pipe_buf_get (struct pipe_inode_info * pipe , struct pipe_buffer * buf ) {
    if (!PageReserved(buf->page))
        kmap_atomic(buf->page);
}
--------------------
void generic_pipe_buf_get (struct pipe_inode_info * pipe , struct pipe_buffer * buf ) {
    if (PageLocked(buf->page)) {
        page_cache_release(buf->page);
        __lock_page(buf->page);
    }
}
--------------------
void generic_pipe_buf_get (struct pipe_inode_info * pipe , struct pipe_buffer * buf ) {
    if (!PageReserved(buf->page)) {
        lock_page(buf->page);
        page_cache_get(buf->page);
    }
}
--------------------
void generic_pipe_buf_get (struct pipe_inode_info * pipe , struct pipe_buffer * buf ) {
    if (!PageReserved(buf->page)) {
        struct address_space *mapping = page_mapping(buf->page);
        lock_page(buf->page);
        page_cache_get(buf->page);
        __mod_lruvec_page_state(add_page_state(mapping, NR_FILE_DIRTY), 1);
    }
}
--------------------
void generic_pipe_buf_get (struct pipe_inode_info * pipe , struct pipe_buffer * buf ) {
    if (!PageReserved(buf->page)) {
        struct address_space *mapping = page_mapping(buf->page);
        lock_page(buf->page);
        page_cache_get(buf->page);
        __SetPageReferenced(buf->page);
        __mod_lruvec_page_state(add_page_state(mapping, NR_INACTIVE_FILE), 1);
    }
}
--------------------
void generic_pipe_buf_get (struct pipe_inode_info * pipe , struct pipe_buffer * buf ) {
    if (!PageReserved(buf->page)) {
        struct address_space *mapping = page_mapping(buf->page);
        lock_page(buf->page);
        page_cache_get(buf->page);
        __mod_lruvec_page_state(add_page_state(mapping, NR_SHMEM), 1);
    }
}
--------------------
void generic_pipe_buf_get (struct pipe_inode_info * pipe , struct pipe_buffer * buf ) {
    if (!PageReserved(buf->page)) {
        struct address_space *mapping = page_mapping(buf->page);
        lock_page(buf->page);
        page_cache_get(buf->page);
        __mod_lruvec_page_state(add_page_state(mapping, NR_ACTIVE_ANON), 1);
    }
}
match:0
source:
static char * pool_strdup ( const char * s ) { <S2SV_StartBug> char * r = pool_alloc ( strlen ( s ) + 1 ) ; <S2SV_EndBug> <S2SV_StartBug> strcpy ( r , s ) ; <S2SV_EndBug> return r ; }

target:
static char * pool_strdup ( const char * s ) { size_t len = strlen ( s ) + 1 ; char * r = pool_alloc ( len ) ; memcpy ( r , s , len ) ; return r ; }

outputs:
static char * pool_strdup ( const char * s ) {
    char * r = pool_alloc ( strlen ( s ) + 1 ) ;
    if (r != NULL) {
        strcpy ( r , s ) ;
    }
    return r ;
}
--------------------
static char * pool_strdup ( const char * s ) {
    if (s == NULL) {
        return NULL;
    }
    char * r = pool_alloc ( strlen ( s ) + 1 ) ;
    if ( r != NULL ) {
        strcpy ( r , s ) ;
    }
    return r ;
}
--------------------
//大概是对的
static char * pool_strdup ( const char * s ) {
    if (s == NULL) {
        return NULL;
    }
    size_t len = strlen(s);
    char * r = pool_alloc(len + 1);

    if (r != NULL ) {
        memcpy(r, s, len);
        *(r + len) = '\0';
    }
    return r;
}
--------------------
static char * pool_strdup ( const char * s ) {
    if (s == NULL) {
        return NULL;
    }
    size_t len = strlen(s);
    char * r = pool_alloc(len + 1);
    if ( r != NULL ) {
        for (size_t i = 0; i < len; i++) {
            *(r + i) = *(s + i);
        }
        *(r + len) = '\0';
    }
    return r;
}
--------------------
static char * pool_strdup ( const char * s ) {
    if (s == NULL) {
        return NULL;
    }
    size_t len = strlen(s);
    char *r = pool_alloc(len + 1);
    if (r != NULL) {
        for (size_t i = 0; i <= len; i++) {
            *(r + i) = *(s + i);
        }
    }
    return r;
}
--------------------
static char * pool_strdup ( const char * s ) {
    if (s == NULL) {
        return NULL;
    }
    char * r = pool_alloc ( strlen ( s ) + 1 ) ;
    if ( r != NULL ) {
        sprintf(r, "%s", s);
    }
    return r ;
}
--------------------
static char * pool_strdup ( const char * s ) {
    if (s == NULL) {
        return NULL;
    }
    char * r = pool_alloc ( strlen ( s ) + 1 ) ;
    if ( r != NULL ) {
        int index = 0;
        while(*(s + index) != '\0') {
            *(r + index) = *(s + index);
            index++;
        }
        *(r + index) = '\0';
    }
    return r ;
}
--------------------
static char * pool_strdup ( const char * s ) {
    if (s == NULL) {
        return NULL;
    }
    char * r = pool_alloc ( strlen ( s ) + 1 ) ;
    if ( r != NULL ) {
        char * rIter = r;
        const char * sIter = s;
        while(*sIter) {
            *rIter++ = *sIter++;
        }
        *rIter = '\0';
    }
    return r ;
}
--------------------
static char * pool_strdup ( const char * s ) {
    if (s == NULL) {
        return NULL;
    }
    char * r = pool_alloc ( strlen ( s ) + 1 ) ;
    if ( r != NULL ) {
        char * rIter = r;
        while(*s) {
            *rIter++ = *s++;
        }
        *rIter = '\0';
    }
    return r ;
}
--------------------
static char * pool_strdup ( const char * s ) {
    if (s == NULL) {
        return NULL;
    }
    char * r = pool_alloc ( strlen ( s ) + 1 ) ;
    if ( r != NULL ) {
        const char * sIter = s;
        size_t index = 0;
        while(*(sIter + index)) {
            *(r + index) = *(sIter + index);
            index++;
        }
        *(r + index) = '\0';
    }
    return r ;
}
--------------------
match:0+1
source:
 struct crypto_template * crypto_lookup_template ( const char * name ) { <S2SV_StartBug> return try_then_request_module ( __crypto_lookup_template ( name ) , "%s" , <S2SV_EndBug> name ) ; }


target:
struct crypto_template * crypto_lookup_template ( const char * name ) { return try_then_request_module ( __crypto_lookup_template ( name ) , "crypto-%s" , name ) ; }
outputs:
struct crypto_template *crypto_lookup_template(const char *name) {
    return try_then_request_module(__crypto_lookup_template(name),
                                    "crypto_template: %s",
                                    name);
}
--------------------
static int __init my_module_init(void) {
    return 0;
}

static void __exit my_module_exit(void) {
}

module_init(my_module_init);
module_exit(my_module_exit);
MODULE_LICENSE("GPL");
--------------------
struct crypto_template *crypto_lookup_template(const char *name) {
    return try_then_request_module(__crypto_lookup_template(name),
                                    "crypto_template %s",
                                    name);
}
--------------------
struct crypto_template *crypto_lookup_template(const char *name) {
    return try_then_request_module(__crypto_lookup_template(name),
                                    "crypto_template: %s\n",
                                    name);
}
--------------------
struct crypto_template *crypto_lookup_template(const char *name) {
    char module_name[256];
    snprintf(module_name, sizeof(module_name), "crypto_template:%s", name);
    return try_then_request_module(__crypto_lookup_template(name), "%s", module_name);
}
--------------------
struct crypto_template *crypto_lookup_template(const char *name) {
    return try_then_request_module(__crypto_lookup_template(name),
                                    "crypto_template:%s\n",
                                    name);
}
--------------------
struct crypto_template *crypto_lookup_template(const char *name) {
    return try_then_request_module(__crypto_lookup_template(name),
                                    "crypto_template: %s\n",
                                    name);
}
--------------------
struct crypto_template *crypto_lookup_template(const char *name) {
    return try_then_request_module(__crypto_lookup_template(name),
                                    "crypto_template %s loaded",
                                    name);
}
--------------------
#include <linux/module.h>
#include <linux/crypto.h>
#include <linux/init.h>

MODULE_LICENSE("GPL");

struct crypto_template *crypto_lookup_template(const char *name)
{
    return try_then_request_module(__crypto_lookup_template(name),
                                    "crypto_template:%s", name);
}

static int __init example_init(void)
{
    printk(KERN_INFO "Example module initialized.\n");
    return 0;
}

static void __exit example_exit(void)
{
    printk(KERN_INFO "Example module exited.\n");
}

module_init(example_init);
module_exit(example_exit);
--------------------
struct crypto_template *crypto_lookup_template(const char *name) {
    return try_then_request_module(__crypto_lookup_template(name), "crypto_template:%s", name);
}
--------------------
match:0
source:
static void * skcipher_bind ( const char * name , u32 type , u32 mask ) { <S2SV_StartBug> return crypto_alloc_skcipher ( name , type , mask ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>

target:
static void * skcipher_bind ( const char * name , u32 type , u32 mask ) { struct skcipher_tfm * tfm ; struct crypto_skcipher * skcipher ; tfm = kzalloc ( sizeof ( * tfm ) , GFP_KERNEL ) ; if ( ! tfm ) return ERR_PTR ( - ENOMEM ) ; skcipher = crypto_alloc_skcipher ( name , type , mask ) ; if ( IS_ERR ( skcipher ) ) { kfree ( tfm ) ; return ERR_CAST ( skcipher ) ; } tfm -> skcipher = skcipher ; return tfm ; }

outputs:
static void * skcipher_bind ( const char * name , u32 type , u32 mask ) {
    return crypto_alloc_skcipher ( name , type , mask ) ;
}
--------------------
static void * skcipher_bind ( const char * name , u32 type , u32 mask ) {
    void *cipher = crypto_alloc_skcipher ( name, type, mask );
    if(IS_ERR(cipher))
        return cipher;
    return cipher;
}
--------------------
static void * skcipher_bind ( const char * name , u32 type , u32 mask ) {
    void *cipher = crypto_alloc_skcipher ( name, type, mask );
    if(IS_ERR(cipher)) {
        pr_err("Could not allocate skcipher handle for %s with err %d\n", name, PTR_ERR(cipher));
        return ERR_CAST(cipher);
    }
    return cipher;
}
--------------------
static void * skcipher_bind ( const char * name , u32 type , u32 mask ) {
    void *cipher = crypto_alloc_skcipher (name, type, mask);
    if(IS_ERR(cipher)) {
        pr_err("Could not allocate skcipher handle for %s with err %ld\n", name,
               PTR_ERR(cipher));
        return ERR_CAST(cipher);
    }
    return cipher;
}
--------------------
static void * skcipher_bind ( const char * name , u32 type , u32 mask ) {
    void *cipher = crypto_alloc_skcipher (name, type, mask);
    if(IS_ERR(cipher)) {
        pr_err("Error allocating skcipher handle for %s\n", name);
        return cipher;
    }
    return cipher;
}
--------------------
static void * skcipher_bind ( const char * name , u32 type , u32 mask ) {
    void *cipher = ERR_PTR(-EINVAL);

    if (!name) {
        pr_err("Invalid skcipher handle name requested");
        return cipher;
    }

    cipher = crypto_alloc_skcipher(name, type, mask);
    if (cipher == NULL) {
        pr_err("Could not allocate skcipher handle for %s\n", name);
        cipher = ERR_PTR(-ENOMEM);
    }

    return cipher;
}
--------------------
static void * skcipher_bind ( const char * name , u32 type , u32 mask ) {
    void *cipher = ERR_PTR(-EINVAL);
    int rc = -ENOMEM;

    if (name == NULL) {
        pr_err("skcipher handle name is NULL\n");
        goto err;
    }

    cipher = crypto_alloc_skcipher(name, type, mask);
    if (cipher == NULL) {
        pr_err("Failed to allocate skcipher handle\n");
        goto err;
    }

    rc = 0;

err:
    if (rc) {
        if (IS_ERR(cipher))
            return cipher;
        cipher = ERR_PTR(rc);
    }

    return cipher;
}
--------------------
static void * skcipher_bind ( const char * name , u32 type , u32 mask ) {
    void *cipher = ERR_PTR(-EINVAL);
    int rc = -ENOMEM;

    if (!name) {
        pr_err("Invalid skcipher handle name requested");
        goto error;
    }

    cipher = crypto_alloc_skcipher(name, type, mask);
    if (IS_ERR(cipher)) {
        pr_err("Failed to allocate skcipher handle\n");
        goto error;
    }

    return cipher;

error:
    if (cipher != ERR_PTR(-EINVAL))
        crypto_free_skcipher(cipher);
    cipher = ERR_PTR(rc);

    return cipher;
}
--------------------
static void * skcipher_bind ( const char * name , u32 type , u32 mask ) {
    int rc = 0;
    struct skcipher_handle *skcipher = NULL;

    skcipher = kzalloc(sizeof(*skcipher), GFP_KERNEL);
    if (!skcipher) {
        pr_err("Failed to allocate skcipher handle\n");
        rc = -ENOMEM;
        goto out;
    }

    skcipher->skcipher = crypto_alloc_skcipher(name, type, mask);
    if (IS_ERR(skcipher->skcipher)) {
        pr_err("Failed to obtain skcipher for algorithm %s\n", name);
        rc = PTR_ERR(skcipher->skcipher);
        goto out;
    }

    return skcipher;

out:
    if (skcipher) {
        crypto_free_skcipher(skcipher->skcipher);
        kfree(skcipher);
    }

    return ERR_PTR(rc);
}
--------------------
static void * skcipher_bind ( const char * name , u32 type , u32 mask ) {
    void *cipher = ERR_PTR(-EINVAL);
    unsigned long flags;

    if (name == NULL) {
        pr_err("Invalid skcipher handle name requested");
        return cipher;
    }

    cipher = crypto_alloc_skcipher(name, type, mask);
    if (IS_ERR(cipher))
        goto error;

    /* Allow someone to remove this module even if it's in use */
    spin_lock_irqsave(&skcipher_bind_lock, flags);
    if (refcount_inc_not_zero(&skcipher_bind_count)) {
        spin_unlock_irqrestore(&skcipher_bind_lock, flags);
        return cipher;
    }
    spin_unlock_irqrestore(&skcipher_bind_lock, flags);

error:
    pr_err("Failed to request skcipher algorithm %s\n", name);
    return cipher;
}
--------------------
match:0
ssource:
void vp9_frame_init_quantizer ( VP9_COMP * cpi ) { <S2SV_StartBug> cpi -> zbin_mode_boost = 0 ; <S2SV_EndBug> <S2SV_StartBug> vp9_init_plane_quantizers ( cpi , & cpi -> mb ) ; <S2SV_EndBug> }

target:
void vp9_frame_init_quantizer ( VP9_COMP * cpi ) { vp9_init_plane_quantizers ( cpi , & cpi -> td . mb ) ; }

outputs:
void vp9_frame_init_quantizer ( VP9_COMP * cpi ) {
    cpi -> zbin_mode_boost = 0 ;
    vp9_init_plane_quantizers ( cpi , & cpi -> mb ) ;
}
--------------------
void vp9_frame_init_quantizer ( VP9_COMP * cpi ) {
    cpi -> zbin_mode_boost = 0 ;
    vp9_init_frame_quantizer ( cpi ) ;
}
--------------------
void vp9_frame_init_quantizer ( VP9_COMP * cpi ) {
    cpi -> zbin_mode_boost = 0 ;
    vp9_init_plane_quantizers ( cpi , & cpi -> mb ) ;
    vp9_init_frame_quantizer ( cpi ) ;
}
--------------------
void vp9_frame_init_quantizer ( VP9_COMP * cpi ) {
    vp9_init_plane_quantizers ( cpi , & cpi -> mb ) ;
    cpi -> zbin_mode_boost = 0 ;
}
--------------------
void vp9_frame_init_quantizer ( VP9_COMP * cpi ) {
    vp9_init_frame_quantizer ( cpi ) ;
    cpi -> zbin_mode_boost = 0 ;
}
--------------------
void vp9_frame_init_quantizer ( VP9_COMP * cpi ) {
    vp9_init_frame_quantizer ( cpi ) ;
    vp9_init_plane_quantizers ( cpi , & cpi -> mb ) ;
}
--------------------
void vp9_frame_init_quantizer ( VP9_COMP * cpi ) {
    vp9_init_plane_quantizers ( cpi , & cpi -> mb ) ;
    vp9_init_frame_quantizer ( cpi ) ;
    cpi -> zbin_mode_boost = 0 ;
}
--------------------
void vp9_frame_init_quantizer ( VP9_COMP * cpi ) {
    vp9_init_frame_quantizer ( cpi ) ;
    cpi -> zbin_mode_boost = 0 ;
    vp9_init_plane_quantizers ( cpi , & cpi -> mb ) ;
}
--------------------
void vp9_frame_init_quantizer ( VP9_COMP * cpi ) {
    vp9_init_frame_quantizer ( cpi ) ;
    cpi -> zbin_mode_boost = 0 ;
    vp9_init_plane_quantizers ( cpi , & cpi -> mb ) ;
}
--------------------
void vp9_frame_init_quantizer ( VP9_COMP * cpi ) {
    vp9_init_frame_quantizer ( cpi ) ;
    vp9_init_plane_quantizers ( cpi , & cpi -> mb ) ;
    cpi -> zbin_mode_boost = 0 ;
}
match:0
source:
 static void l2tp_eth_dev_setup ( struct net_device * dev ) { ether_setup ( dev ) ; <S2SV_StartBug> dev -> netdev_ops = & l2tp_eth_netdev_ops ; <S2SV_EndBug> dev -> destructor = free_netdev ; }


target:
static void l2tp_eth_dev_setup ( struct net_device * dev ) { ether_setup ( dev ) ; dev -> priv_flags &= ~ IFF_TX_SKB_SHARING ; dev -> netdev_ops = & l2tp_eth_netdev_ops ; dev -> destructor = free_netdev ; }
outputs:
static void l2tp_eth_dev_setup ( struct net_device * dev ) { 
    ether_setup ( dev ) ; 
    dev->netdev_ops = dev_net_ops(dev); 
    dev->destructor = free_netdev; 
}
--------------------
static struct net_device_ops l2tp_eth_netdev_ops = { .ndo_init = l2tp_eth_dev_init, .ndo_uninit = l2tp_eth_dev_deinit, }; 
static void l2tp_eth_dev_setup ( struct net_device * dev ) { 
    ether_setup ( dev ) ; 
    dev->netdev_ops = &l2tp_eth_netdev_ops; 
    dev->destructor = free_netdev; 
}
--------------------
static struct net_device_ops l2tp_eth_netdev_ops; 
static void l2tp_eth_dev_setup ( struct net_device * dev ) { 
    ether_setup ( dev ) ; 
    memset(&l2tp_eth_netdev_ops, 0, sizeof(struct net_device_ops)); 
    l2tp_eth_netdev_ops.ndo_init = l2tp_eth_dev_init; 
    l2tp_eth_netdev_ops.ndo_uninit = l2tp_eth_dev_deinit; 
    dev->netdev_ops = &l2tp_eth_netdev_ops; 
    dev->destructor = free_netdev; 
}
--------------------
#if defined(CONFIG_L2TP_ETH) && (CONFIG_L2TP_ETH==1) 
static struct net_device_ops l2tp_eth_netdev_ops = { .ndo_init = l2tp_eth_dev_init, .ndo_uninit = l2tp_eth_dev_deinit, }; 
#else 
static struct net_device_ops l2tp_eth_netdev_ops; 
#endif 

static void l2tp_eth_dev_setup ( struct net_device * dev ) { 
    ether_setup ( dev ) ; 
    dev->netdev_ops = &l2tp_eth_netdev_ops; 
    dev->destructor = free_netdev; 
}
--------------------
static void l2tp_eth_dev_setup ( struct net_device * dev ) { 
    ether_setup ( dev ) ; 
    dev->netdev_ops = &l2tp_eth_netdev_ops; 
    dev->destructor = free_netdev; 
    dev->netdev_ops = NULL; 
}
--------------------
static void l2tp_eth_dev_setup ( struct net_device * dev ) { 
    ether_setup ( dev ) ; 
    dev->netdev_ops = &l2tp_eth_netdev_ops; 
    dev->destructor = devm_free_netdev; 
}
--------------------
static void l2tp_eth_dev_destructor(struct net_device *dev) { 
    unregister_netdev(dev); 
    free_netdev(dev); 
}

static void l2tp_eth_dev_setup ( struct net_device * dev ) { 
    ether_setup ( dev ) ; 
    dev->netdev_ops = &l2tp_eth_netdev_ops; 
    dev->needs_free_netdev = true; 
    dev->destructor = l2tp_eth_dev_destructor; 
}
--------------------
static void l2tp_eth_dev_destructor(struct net_device *dev) { 
    unregister_netdev(dev); 
    free_netdev(dev); 
}

static void l2tp_eth_dev_setup ( struct net_device * dev ) { 
    dev = devm_ether_alloc(dev); 
    dev->netdev_ops = &l2tp_eth_netdev_ops; 
    dev->needs_free_netdev = true; 
    dev->destructor = l2tp_eth_dev_destructor; 
}
--------------------
static void l2tp_eth_dev_destructor(struct net_device *dev) { 
    unregister_netdev(dev); 
    free_netdev(dev); 
}

static void l2tp_eth_dev_setup ( struct net_device * dev ) { 
    dev = devm_ether_alloc(dev); 
    if (!dev) 
        return; 
    dev->netdev_ops = &l2tp_eth_netdev_ops; 
    dev->needs_free_netdev = true; 
    dev->destructor = l2tp_eth_dev_destructor; 
}
--------------------
static void l2tp_eth_dev_destructor(struct net_device *dev) { 
    unregister_netdev(dev); 
}

static void l2tp_eth_dev_setup ( struct net_device * dev ) { 
    ether_setup ( dev ) ; 
    dev->netdev_ops = &l2tp_eth_netdev_ops; 
    dev->destructor = l2tp_eth_dev_destructor; 
}
--------------------
match:0
source:
static void ieee80211_if_setup ( struct net_device * dev ) { ether_setup ( dev ) ; <S2SV_StartBug> dev -> netdev_ops = & ieee80211_dataif_ops ; <S2SV_EndBug> dev -> destructor = free_netdev ; }

target:
static void ieee80211_if_setup ( struct net_device * dev ) { ether_setup ( dev ) ; dev -> priv_flags &= ~ IFF_TX_SKB_SHARING ; dev -> netdev_ops = & ieee80211_dataif_ops ; dev -> destructor = free_netdev ; }

outputs:
static void ieee80211_if_setup ( struct net_device * dev ) {
  ether_setup ( dev ) ;
  dev->netdev_ops = &ieee80211_nullfunc;
  dev->destructor = free_netdev;
}
--------------------
static void ieee80211_if_setup ( struct net_device * dev ) {
  ether_setup ( dev ) ;
  register_netdev(dev);
}

static const struct net_device_ops ieee80211_netdev_ops = {
  .ndo_init = ieee80211_if_init,
};

void ieee80211_if_init(struct net_dev *dev) {
  // Perform any net device setup here
}

static void register_netdev(struct net_device* dev) {
  // Setup the net device
  dev->destructor = free_netdev;
  // Assign callback functions
  dev->netdev_ops = NULL;
  dev->netdev_ops = &ieee80211_netdev_ops;
}
--------------------
// Declare a new ieee80211_dataif_ops structure
static const struct net_device_ops ieee80211_dataif_ops = {
  .ndo_init = ieee80211_if_init,
};

static void ieee80211_if_setup ( struct net_device * dev ) {
  ether_setup ( dev ) ;
  memcpy(&ieee80211_dataif_ops, &ieee80211_nullfunc, sizeof(struct net_device_ops));
  // Set the ndo_init function to custom implementation
  ieee80211_dataif_ops.ndo_init = ieee80211_if_init;
  // Assign ieee80211_dataif_ops, which contains a copy of ieee80211_nullfunc, to the dev->netdev_ops
  dev->netdev_ops = &ieee80211_dataif_ops;
  dev->destructor = free_netdev;
}
--------------------
static void ieee80211_if_setup ( struct net_device * dev ) {
    ether_setup ( dev ) ;
    dev->netdev_ops = &loopback_netdev_ops;
    dev->netdev_ops->ndo_init = ieee80211_if_init;
    dev->destructor = free_netdev ;
}
--------------------
static void ieee80211_if_setup(struct net_device* dev) {
    struct net_device* new_dev = NULL;
    ether_setup(new_dev);
    new_dev = alloc_netdev(sizeof(struct ieee80211_local), "wlan%d", NET_NAME_UNKNOWN, ieee80211_if_init);
    memcpy(new_dev->dev_addr, dev->dev_addr, dev->addr_len);
    new_dev->mtu = dev->mtu;
    new_dev->type = ARPHRD_IEEE80211;
    new_dev->hard_header_len = sizeof(struct ieee80211_hdr_3addr);
    new_dev->flags = IFF_BROADCAST | IFF_MULTICAST;
    dev->destructor = free_netdev;
    register_netdev(new_dev);
}
--------------------
const struct net_device_ops my_netdev_ops = {
    .ndo_init = ieee80211_if_init
};

static void ieee80211_if_setup ( struct net_device * dev ) {
    ether_setup(dev);
    dev->netdev_ops = &my_netdev_ops;
    dev->destructor = free_netdev;
}
--------------------
const struct net_device_ops my_netdev_ops = {};

static void ieee80211_if_setup ( struct net_device * dev ) {
    ether_setup(dev);
    dev->netdev_ops = &my_netdev_ops;
    dev->destructor = free_netdev;
}
--------------------
static void ieee80211_if_setup ( struct net_device * dev ) {
  ether_setup ( dev ) ;
  dev->netdev_ops = NULL;
  dev->netdev_ops->ndo_init = ieee80211_if_init;
  dev->destructor = free_netdev ;
 }
--------------------
static const struct net_device_ops ieee80211_dataif_ops = {
    .ndo_init = ieee80211_my_init,
};

static void ieee80211_if_setup ( struct net_device * dev ) {
    ether_setup ( dev ) ;
    dev->netdev_ops = &ieee80211_dataif_ops;
    dev->destructor = free_netdev;
}
--------------------
static const struct net_device_ops my_netdev_ops = {
    .ndo_open = ieee80211_if_open,
    .ndo_stop = ieee80211_if_stop,
    .ndo_start_xmit = ieee80211_if_xmit,
    .ndo_set_mac_address = ieee80211_if_set_address,
    .ndo_validate_addr = eth_validate_addr,
    .ndo_change_mtu = ieee80211_if_change_mtu,
    .ndo_tx_timeout = ieee80211_if_tx_timeout,
    .ndo_set_rx_mode = ieee80211_if_set_rx_mode,
    .ndo_do_ioctl = ieee80211_if_ioctl,
    .ndo_get_stats = ieee80211_if_get_stats,
    .ndo_netpoll = ieee80211_if_netpoll,
    .ndo_init = ieee80211_if_init,
};

static void ieee80211_if_setup ( struct net_device * dev ) {
  ether_setup ( dev ) ;
  dev->netdev_ops = &my_netdev_ops;
  dev->destructor = free_netdev;
}
--------------------
match:0
source:
int X509_verify ( X509 * a , EVP_PKEY * r ) <S2SV_StartBug> { <S2SV_EndBug> return ( ASN1_item_verify ( ASN1_ITEM_rptr ( X509_CINF ) , a -> sig_alg , a -> signature , a -> cert_info , r ) ) ; }

target:
int X509_verify ( X509 * a , EVP_PKEY * r ) { if ( X509_ALGOR_cmp ( a -> sig_alg , a -> cert_info -> signature ) ) return 0 ; return ( ASN1_item_verify ( ASN1_ITEM_rptr ( X509_CINF ) , a -> sig_alg , a -> signature , a -> cert_info , r ) ) ; }

outputs:
int X509_verify (X509 *a , EVP_PKEY *r ) {
    if(a == NULL || r == NULL) {
        return 0;
    }
    return (ASN1_item_verify (ASN1_ITEM_rptr (X509_CINF), a->sig_alg, a->signature, a->cert_info, r));
}
--------------------
int X509_verify (X509 *a , EVP_PKEY *r ) {
    if(a == NULL || r == NULL || a->sig_alg == NULL || a->signature == NULL || a->cert_info == NULL) {
        return 0;
    }
    return (ASN1_item_verify (ASN1_ITEM_rptr (X509_CINF), a->sig_alg, a->signature, a->cert_info, r));
}
--------------------
int X509_verify (X509 *a , EVP_PKEY *r ) {
    if(a == NULL || r == NULL || a->sig_alg == NULL || a->signature == NULL || a->cert_info == NULL) {
        return 0;
    }
    int result = ASN1_item_verify (ASN1_ITEM_rptr (X509_CINF), a->sig_alg, a->signature, a->cert_info, r);
    if(result < 0) {
        return 0;
    }
    return result;
}
--------------------
int X509_verify (X509 *a , EVP_PKEY *r ) {
    if(a == NULL || r == NULL || a->sig_alg == NULL || a->signature == NULL || a->cert_info == NULL) {
        return 0;
    }
    int result = ASN1_item_verify (ASN1_ITEM_rptr (X509_CINF), a->sig_alg, a->signature, a->cert_info, r);
    if(result <= 0) {
        return 0;
    }
    return 1;
}
--------------------
int X509_verify (X509 *a , EVP_PKEY *r ) {
    if(a == NULL || r == NULL || a->sig_alg == NULL || a->signature == NULL || a->cert_info == NULL) {
        return 0;
    }
    int result = ASN1_item_verify (ASN1_ITEM_rptr (X509_CINF), a->sig_alg, a->signature, a->cert_info, r);
    if(result <= 0) {
        return result;
    }
    return result;
}
--------------------
int X509_verify (X509 *a , EVP_PKEY *r ) {
    if(a == NULL || r == NULL) {
        return 0;
    }
    int result = ASN1_item_verify (ASN1_ITEM_rptr (X509_CINF), a->sig_alg, a->signature, a->cert_info, r);
    if(result <= 0) {
        return 0;
    }
    return result;
}
--------------------
int X509_verify (X509 *a , EVP_PKEY *r ) {
    if(a == NULL || r == NULL || a->sig_alg == NULL || a->signature == NULL || a->cert_info == NULL) {
        return 0;
    }
    int verifyResult = ASN1_item_verify (ASN1_ITEM_rptr (X509_CINF), a->sig_alg, a->signature, a->cert_info, r);
    if(verifyResult <= 0) {
        return verifyResult;
    }
    return verifyResult;
}
--------------------
int X509_verify (X509 *a , EVP_PKEY *r ) {
    if(a == NULL || r == NULL || a->sig_alg == NULL || a->signature == NULL || a->cert_info == NULL) {
        return 0;
    }
    int verifyResult = ASN1_item_verify (ASN1_ITEM_rptr (X509_CINF), a->sig_alg, a->signature, a->cert_info, r);
    if(verifyResult < 0) {
        return 0;
    } else {
        return (verifyResult > 0) ? verifyResult : 0;
    }
}
--------------------
int X509_verify (X509 *a , EVP_PKEY *r ) {
    if(a == NULL || r == NULL || a->sig_alg == NULL || a->signature == NULL || a->cert_info == NULL) {
        return 0;
    }
    int verifyResult = ASN1_item_verify (ASN1_ITEM_rptr (X509_CINF), a->sig_alg, a->signature, a->cert_info, r);
    if(verifyResult < 0) {
        return 0;
    } else {
        return verifyResult;
    }
}
--------------------
int X509_verify (X509 *a , EVP_PKEY *r ) {
    if(a == NULL || r == NULL) {
        return 0;
    }
    int verifyResult = ASN1_item_verify (ASN1_ITEM_rptr (X509_CINF), a->sig_alg, a->signature, a->cert_info, r);
    if(verifyResult < 0) {
        return 0;
    } else {
        return verifyResult;
    }
}
--------------------
match:0
source:
static int remove_bond ( const bt_bdaddr_t * bd_addr ) <S2SV_StartBug> { <S2SV_EndBug> if ( interface_ready ( ) == FALSE ) return BT_STATUS_NOT_READY ; return btif_dm_remove_bond ( bd_addr ) ; }

target:
static int remove_bond ( const bt_bdaddr_t * bd_addr ) { if ( is_restricted_mode ( ) && ! btif_storage_is_restricted_device ( bd_addr ) ) return BT_STATUS_SUCCESS ; if ( interface_ready ( ) == FALSE ) return BT_STATUS_NOT_READY ; return btif_dm_remove_bond ( bd_addr ) ; }

outputs:
static int remove_bond ( const bt_bdaddr_t * bd_addr ) {
    if (bd_addr == NULL) return BT_STATUS_PARM_INVALID;
    if ( interface_ready ( ) == FALSE ) return BT_STATUS_NOT_READY ;
    return btif_dm_remove_bond ( bd_addr ) ;
}
--------------------
static int remove_bond ( const bt_bdaddr_t * bd_addr ) {
    int ret = BT_STATUS_SUCCESS;
    if (bd_addr == NULL || (!bd_addr->address)) {
         ret = BT_STATUS_PARM_INVALID;
         goto error;
    }
    if (!interface_ready()) {
        ret = BT_STATUS_NOT_READY;
        goto error;
    }
    ret = btif_dm_remove_bond ( bd_addr ) ;
error:
    return ret;
}
--------------------
static int remove_bond ( const bt_bdaddr_t * bd_addr ) {
    if (!bd_addr) {
        return BT_STATUS_NOT_READY;
    }
    if (bd_addr->address == NULL || bd_addr->address.type == BDADDR_EMPTY) {
        return BT_STATUS_PARM_INVALID;
    }
    if ( interface_ready ( ) == FALSE ) {
        return BT_STATUS_NOT_READY;
    }
    return btif_dm_remove_bond ( bd_addr ) ;
}
--------------------
static int remove_bond ( const bt_bdaddr_t * bd_addr ) {
    if (!bd_addr) {
        return BT_STATUS_NOT_READY;
    }
    if (bd_addr->address == NULL || bd_addr->address.type == BDADDR_EMPTY) {
        return BT_STATUS_PARM_INVALID;
    }
    if ( interface_ready ( ) == FALSE ) {
        return BT_STATUS_NOT_READY;
    }
    int result = btif_dm_remove_bond ( bd_addr ) ;
    return result == BT_STATUS_SUCCESS ? BT_STATUS_SUCCESS : BT_STATUS_FAIL;
}
--------------------
static int remove_bond ( const bt_bdaddr_t * bd_addr ) {
    if (!bd_addr || !bd_addr->address.address ||
            bd_addr->address.type == BDADDR_EMPTY) {
        return BT_STATUS_PARM_INVALID;
    }
    if ( interface_ready ( ) == FALSE ) {
        return BT_STATUS_NOT_READY;
    }
    return btif_dm_remove_bond ( bd_addr ) ;
}
--------------------
static int remove_bond ( const bt_bdaddr_t * bd_addr ) {
    if (!bd_addr) {
        return BT_STATUS_NOT_READY;
    }
    if (!bd_addr->address.address || bd_addr->address.type == BDADDR_EMPTY) {
        return BT_STATUS_PARM_INVALID;
    }
    bt_bdaddr_t temp_address = *bd_addr;
    temp_address.address.address = (uint8_t*)NULL;

    if ( interface_ready ( ) == FALSE ) {
        return BT_STATUS_NOT_READY;
    }
    return btif_dm_remove_bond ( &temp_address ) ;
}
--------------------
static int remove_bond ( const bt_bdaddr_t * bd_addr ) {
    if (!bd_addr) {
        return BT_STATUS_NOT_READY;
    }
    if (!bd_addr->address.address || bd_addr->address.type == BDADDR_EMPTY) {
        return BT_STATUS_PARM_INVALID;
    }
    int result = BT_STATUS_FAIL;
    if ( interface_ready ( ) != FALSE ) {
        result = btif_dm_remove_bond ( bd_addr ) ;
    } else {
        result = BT_STATUS_NOT_READY ;
    }
    return result;
}
--------------------
static int remove_bond ( const bt_bdaddr_t * bd_addr ) {
    if (!bd_addr || bd_addr->address.type == BDADDR_EMPTY) {
        return BT_STATUS_PARM_INVALID;
    }
    if ( interface_ready ( ) == FALSE ) {
        return BT_STATUS_NOT_READY;
    }
    return btif_dm_remove_bond ( bd_addr ) ;
}
--------------------
static int remove_bond ( const bt_bdaddr_t * bd_addr ) {
    if (!bd_addr || !bd_addr->address.type || bd_addr->address.type == BDADDR_UNDEF) {
        return BT_STATUS_PARM_INVALID;
    }
    if ( interface_ready ( ) == FALSE ) {
        return BT_STATUS_NOT_READY;
    }
    return btif_dm_remove_bond ( bd_addr ) ;
}
--------------------
static int remove_bond ( const bt_bdaddr_t * bd_addr ) {
    if (!bd_addr || !bd_addr->address.address || !bd_addr->address.type) {
        return BT_STATUS_PARM_INVALID;
    }
    if ( interface_ready ( ) == FALSE ) {
        return BT_STATUS_NOT_READY;
    }
    return btif_dm_remove_bond ( bd_addr ) ;
}
--------------------
match:0
source:
static int snd_seq_device_dev_free ( struct snd_device * device ) { struct snd_seq_device * dev = device -> device_data ; <S2SV_StartBug> put_device ( & dev -> dev ) ; <S2SV_EndBug> return 0 ; }

target:
static int snd_seq_device_dev_free ( struct snd_device * device ) { struct snd_seq_device * dev = device -> device_data ; cancel_autoload_drivers ( ) ; put_device ( & dev -> dev ) ; return 0 ; }

outputs:
static int snd_seq_device_dev_free ( struct snd_device * device ) {
    struct snd_seq_device * dev = device -> device_data ;
    device_del(&dev->dev);
    return 0;
}
--------------------
static int snd_seq_device_dev_free ( struct snd_device * device ) {
    struct snd_seq_device * dev = device -> device_data ;
    kobject_put(&dev->dev->kobject);
    return 0;
}
--------------------
static int snd_seq_device_dev_free ( struct snd_device * device ) {
    struct snd_seq_device * dev = device -> device_data ;
    kref_put(&dev->kref, release_function);
    return 0;
}
--------------------
static int snd_seq_device_dev_free ( struct snd_device * device ) {
    struct snd_seq_device * dev = device -> device_data ;
    kfree(dev);
    return 0;
}
--------------------
static int snd_seq_device_dev_free ( struct snd_device * device ) {
    struct snd_seq_device * dev = device -> device_data ;
    device_unregister(&dev->dev);
    kfree(dev);
    return 0;
}
--------------------
static int snd_seq_device_dev_free ( struct snd_device * device ) {
    struct snd_seq_device * dev = device -> device_data ;
    list_del(&dev->list);
    kfree(dev);
    return 0;
}
--------------------
static int snd_seq_device_dev_free ( struct snd_device * device ) {
    struct snd_seq_device * dev = device -> device_data ;
    device_destroy(dev->class, dev->devt);
    kfree(dev);
    return 0;
}
--------------------
static int snd_seq_device_dev_free ( struct snd_device * device ) {
    struct snd_seq_device * dev = device -> device_data ;
    mutex_destroy(&dev->open_mutex);
    kfree(dev);
    return 0;
}
--------------------
static int snd_seq_device_dev_free ( struct snd_device * device ) {
    struct snd_seq_device * dev = device -> device_data ;
    put_device(&dev->dev);
    return 0;
}
--------------------
static int snd_seq_device_dev_free ( struct snd_device * device ) {
    struct snd_seq_device * dev = device -> device_data ;
    kobject_put(dev->class);
    kfree(dev);
    return 0;
}
--------------------
match:0
source:
 static void smp_task_done ( struct sas_task * task ) { <S2SV_StartBug> if ( ! del_timer ( & task -> slow_task -> timer ) ) <S2SV_EndBug> return ; complete ( & task -> slow_task -> completion ) ; }


target:
static void smp_task_done ( struct sas_task * task ) { del_timer ( & task -> slow_task -> timer ) ; complete ( & task -> slow_task -> completion ) ; }
outputs:
static void smp_task_done(struct sas_task *task) {
    if (del_timer(&task->slow_task->timer)) {
        complete(&task->slow_task->completion);
    }
}
--------------------
static void smp_task_done(struct sas_task *task) {
    if (task && task->slow_task && del_timer(&task->slow_task->timer)) {
        complete(&task->slow_task->completion);
    }
}
--------------------
static void smp_task_done(struct sas_task *task) {
    if (task && task->slow_task) {
        del_timer(&task->slow_task->timer);
        complete(&task->slow_task->completion);
    }
}
--------------------
static void smp_task_done(struct sas_task *task) {
    if (task && task->slow_task) {
        if (del_timer_sync(&task->slow_task->timer) && !completion_done(&task->slow_task->completion)) {
            complete(&task->slow_task->completion);
        }
    }
}
--------------------
static void smp_task_done(struct sas_task *task) {
    if (task && task->slow_task) {
        if (del_timer_sync(&task->slow_task->timer)) {
            if (!completion_done(&task->slow_task->completion)) {
                complete(&task->slow_task->completion);
            }
        } else {
            complete(&task->slow_task->completion); // In case the timer is already expired
        }
    }
}
--------------------
static void smp_task_done(struct sas_task *task) {
    if (!task || !task->slow_task) {
        return;
    }
    if (del_timer_sync(&task->slow_task->timer)) {
        if (!completion_done(&task->slow_task->completion)) {
            complete(&task->slow_task->completion);
        }
    } else {
        complete(&task->slow_task->completion); // In case the timer is already expired
    }
}
--------------------
static void smp_task_done(struct sas_task *task) {
    if (!task || !task->slow_task) {
        return;
    }
    if (time_after(jiffies, task->slow_task->timer.expires)) {
        complete(&task->slow_task->completion);
    } else {
        del_timer_sync(&task->slow_task->timer);
        complete(&task->slow_task->completion);
    }
}
--------------------
static void smp_task_done(struct sas_task *task) {
    if (!task || !task->slow_task) {
        return;
    }
    if (time_after(jiffies, task->slow_task->timer.expires)) {
        complete(&task->slow_task->completion);
    } else {
        del_timer_sync(&task->slow_task->timer);
        if (!completion_done(&task->slow_task->completion)) {
            complete(&task->slow_task->completion);
        }
    }
}
--------------------
static void smp_task_done(struct sas_task *task) {
    if (!task || !task->slow_task) {
        return;
    }
    if (time_after_eq(jiffies, task->slow_task->timer.expires)) {
        complete(&task->slow_task->completion);
    } else {
        mod_timer(&task->slow_task->timer, jiffies + HZ);
    }
}
--------------------
static void smp_task_done(struct sas_task *task) {
    if (!task || !task->slow_task) {
        return;
    }
    if (time_after_eq(jiffies, task->slow_task->timer.expires)) {
        if (!completion_done(&task->slow_task->completion)) {
            complete(&task->slow_task->completion);
        }
    } else {
        mod_timer(&task->slow_task->timer, jiffies + HZ);
    }
}
--------------------
match:0
source:
void test_checkout_nasty__git_tilde1 ( void ) { <S2SV_StartBug> # ifdef GIT_WIN32 <S2SV_EndBug> test_checkout_fails ( "refs/heads/git_tilde1" , ".git/foobar" ) ; <S2SV_StartBug> # endif <S2SV_EndBug> }

target:
void test_checkout_nasty__git_tilde1 ( void ) { test_checkout_fails ( "refs/heads/git_tilde1" , ".git/foobar" ) ; test_checkout_fails ( "refs/heads/git_tilde1" , "git~1/foobar" ) ; }

outputs:
void test_checkout_nasty__git_tilde1 ( void ) {
    test_checkout_fails ( "refs/heads/git_tilde1" , ".git/foobar" ) ;
}
--------------------
void test_checkout_nasty__git_tilde1 ( void ) {
    #ifndef UNIX
    test_checkout_fails ( "refs/heads/git_tilde1" , ".git/foobar" ) ;
    #endif
}
--------------------
void test_checkout_nasty__git_tilde1 ( void ) {
    #ifdef UNIX
    test_checkout_fails ( "refs/heads/git_tilde1" , "/tmp/foo/.git/foobar" ) ;
    #else
    test_checkout_fails ( "refs/heads/git_tilde1" , "C:\\temp\\foo\\.git\\foobar" ) ;
    #endif
}
--------------------
void test_checkout_nasty__git_tilde1 ( void ) {
    #ifdef GIT_WIN32
    test_checkout_fails ( "refs/heads/git_tilde1" , "NUL" ) ;
    #else
    test_checkout_fails ( "refs/heads/git_tilde1" , "/dev/null" ) ;
    #endif
}
--------------------
void test_checkout_nasty__git_tilde1 ( void ) {
    test_checkout_fails ( "refs/heads/git_tilde1" , "/dev/null" ) ;
}
--------------------
void test_checkout_nasty__git_tilde1 ( void ) {
    checkout("refs/heads/git_tilde1", "/dev/null");
}
--------------------
void test_checkout_nasty__git_tilde1 ( void ) {
    open("/dev/null", O_WRONLY | O_CREAT, 0644);
    test_checkout_fails ( "refs/heads/git_tilde1" , "/dev/null" ) ;
}
--------------------
void test_checkout_nasty__git_tilde1 ( void ) {
    mkfifo("/dev/null", 0644);
    test_checkout_fails ( "refs/heads/git_tilde1" , "/dev/null" ) ;
}
--------------------
void test_checkout_nasty__git_tilde1 ( void ) {
    test_checkout_fails ( "refs/heads/git_tilde1" , ".git/safe-destination" ) ;
}
--------------------
void test_checkout_nasty__git_tilde1 ( void ) {
    #ifdef GIT_WIN32
    char* destination = "NUL";
    #else
    char* destination = "/dev/null";
    #endif

    if (!access(destination, W_OK)) {
        test_checkout_fails("refs/heads/git_tilde1", destination);
    } else {
        perror("Cannot access destination file");
    }
}
--------------------
match:0
source:
static int jas_iccgetuint32 ( jas_stream_t * in , jas_iccuint32_t * val ) { <S2SV_StartBug> ulonglong tmp ; <S2SV_EndBug> if ( jas_iccgetuint ( in , 4 , & tmp ) ) return - 1 ; * val = tmp ; return 0 ; }

target:
static int jas_iccgetuint32 ( jas_stream_t * in , jas_iccuint32_t * val ) { jas_ulonglong tmp ; if ( jas_iccgetuint ( in , 4 , & tmp ) ) return - 1 ; * val = tmp ; return 0 ; }

outputs:
static int jas_iccgetuint32 ( jas_stream_t * in , jas_iccuint32_t * val ) {
    uint32_t tmp;
    if ( jas_iccgetuint ( in , 4 , &tmp ) ) return - 1 ;
    *val = tmp;
    return 0 ;
}
--------------------
static int jas_iccgetuint32 ( jas_stream_t * in , jas_iccuint32_t * val ) {
    uint32_t tmp ;
    if ( jas_iccgetuint ( in , sizeof(uint32_t) , &tmp ) ) return -1 ;
    *val = tmp ;
    return 0 ;
}
--------------------
static int jas_iccgetuint32 ( jas_stream_t * in , jas_iccuint32_t * val ) {
    jas_iccuint32_t tmp;
    if ( jas_iccgetuint ( in , sizeof(jas_iccuint32_t) , &tmp ) ) return -1 ;
    *val = tmp ;
    return 0 ;
}
--------------------
static int jas_iccgetuint32 ( jas_stream_t * in , jas_iccuint32_t * val ) {
    uint64_t tmp ;
    if ( jas_iccgetuint ( in , sizeof(uint64_t) , &tmp ) ) return -1 ;
    *val = (uint32_t) tmp ;
    return 0 ;
}
--------------------
static int jas_iccgetuint32 ( jas_stream_t * in , jas_iccuint32_t * val ) {
    unsigned char tmp [ 4 ] ;
    if (jas_stream_read (in, tmp, sizeof(tmp)) != sizeof(tmp)) return -1;
    *val = ((tmp[0] << 24) | (tmp[1] << 16) | (tmp[2] << 8) | tmp[3]);
    return 0;
}
--------------------
static int jas_iccgetuint32 ( jas_stream_t * in , jas_iccuint32_t * val ) {
    jas_iccuint32_t tmp ;
    if ( jas_iccgetuint ( in , sizeof(jas_iccuint32_t) , &tmp ) ) return -1 ;
    *val = ntohl (tmp) ;
    return 0 ;
}
--------------------
#define JAS_ICC_UINT32_BYTES 4

static int jas_iccgetuint32 ( jas_stream_t * in , jas_iccuint32_t * val ) {
    unsigned char bytes [ JAS_ICC_UINT32_BYTES ] ;
    if ( jas_stream_read ( in , bytes , JAS_ICC_UINT32_BYTES ) != JAS_ICC_UINT32_BYTES ) return -1 ;
    *val = ( bytes [ 0 ] << 24 ) + ( bytes [ 1 ] << 16 ) + ( bytes [ 2 ] << 8 ) +( bytes [ 3 ] ) ;
    return 0 ;
}
--------------------
static int jas_iccgetuint32( jas_stream_t* in, jas_iccuint32_t *val ) {
    uint8_t bytes[4];
    if ( jas_stream_read( in, bytes, 4 ) != 4) return -1;
    *val = (bytes[0]<<24)|(bytes[1]<<16)|(bytes[2]<<8)|bytes[3];
    return 0;
}
--------------------
static int jas_iccgetuint32(jas_stream_t* in, jas_iccuint32_t* val) {
    uint32_t tmp = 0;
    if ( jas_iccgetuint(in, sizeof(uint32_t), &tmp) ) return -1;
    tmp = htonl(tmp);
    memcpy(val, &tmp, sizeof(jas_iccuint32_t));
    return 0;
}
--------------------
#define JAS_ICC_UINT32_BYTES 4

static int jas_iccgetuint32( jas_stream_t* in, jas_iccuint32_t* val ) {
    unsigned char bytes[ JAS_ICC_UINT32_BYTES ] = { 0 };
    uint32_t tmp = 0;
    int num_read = jas_stream_read(in, bytes, JAS_ICC_UINT32_BYTES);
    if ( num_read != JAS_ICC_UINT32_BYTES ) return -1;
    for ( int i = 0; i < JAS_ICC_UINT32_BYTES; i++ ) {
        tmp += bytes[i] << (8 * (JAS_ICC_UINT32_BYTES - i - 1));
    }
    *val = tmp;
    return 0;
}
--------------------
match:0
source:
 <S2SV_StartBug> static INLINE int write_bit_gte ( vp9_writer * w , int word , int test ) { <S2SV_EndBug> <S2SV_StartBug> vp9_write_literal ( w , word >= test , 1 ) ; <S2SV_EndBug> return word >= test ; }


target:
static INLINE int write_bit_gte ( vpx_writer * w , int word , int test ) { vpx_write_literal ( w , word >= test , 1 ) ; return word >= test ; }
outputs:
static INLINE int write_bit_gte(vp9_writer* w, int word, int test) {
  vp9_write_literal(w, word >= test, 1);
  return word >= test;
}
--------------------
static INLINE int write_bit_gte(vp9_writer* w, int word, int test) {
  if (word >= test) {
    vp9_write_literal(w, 1, 1);
    return 1;
  } else {
    vp9_write_literal(w, 0, 1);
    return 0;
  }
}
--------------------
static INLINE int write_bit_gte(vp9_writer* w, int word, int test) {
  int result = word >= test ? 1 : 0;
  vp9_write_literal(w, result, 1);
  return result;
}
--------------------
static INLINE int write_bit_gte(vp9_writer* w, int word, int test) {
  if (word >= test) {
    vp9_write_literal(w, 1, 1);
    return 1;
  }
  vp9_write_literal(w, 0, 1);
  return 0;
}
--------------------
static INLINE int write_bit_gte(vp9_writer* w, int word, int test) {
  if (word >= test) {
    vp9_write_literal(w, 1, 1);
    return word - test + 1;
  }
  vp9_write_literal(w, 0, 1);
  return 0;
}
--------------------
static INLINE int write_bit_gte(vp9_writer* w, int word, int test) {
  const int result = word >= test;
  vp9_write_literal(w, result, 1);
  return result;
}
--------------------
static INLINE int write_bit_gte(vp9_writer* w, int word, int test) {
  vp9_write_literal(w, word >= test, 1);
  return word - test >= 0;
}
--------------------
static INLINE int write_bit_gte(vp9_writer* w, int word, int test) {
  const int ret = word >= test;
  vp9_write_literal(w, ret, 1);
  return ret;
}
--------------------
static INLINE int write_bit_gte(vp9_writer* w, int word, int test) {
  const int ret = (word >= test) ? 1 : 0;
  vp9_write_literal(w, ret, 1);
  return ret;
}
--------------------
static INLINE int write_bit_gte(vp9_writer* w, int word, int test) {
  int ret = (word >= test) ? 1 : 0;
  vp9_write_literal(w, ret, 1);
  return ret;
}
--------------------
match:0
source:
 static void hugetlbfs_put_super ( struct super_block * sb ) { struct hugetlbfs_sb_info * sbi = HUGETLBFS_SB ( sb ) ; if ( sbi ) { sb -> s_fs_info = NULL ; <S2SV_StartBug> kfree ( sbi ) ; <S2SV_EndBug> } }


target:
static void hugetlbfs_put_super ( struct super_block * sb ) { struct hugetlbfs_sb_info * sbi = HUGETLBFS_SB ( sb ) ; if ( sbi ) { sb -> s_fs_info = NULL ; if ( sbi -> spool ) hugepage_put_subpool ( sbi -> spool ) ; kfree ( sbi ) ; } }
outputs:
static void hugetlbfs_put_super(struct super_block *sb) {
    struct hugetlbfs_sb_info *sbi = HUGETLBFS_SB(sb);
    if (sbi) {
        sb->s_fs_info = NULL;
        kfree(sbi);
    }
}
--------------------
static void hugetlbfs_put_super(struct super_block *sb) {
    if (!sb) {
        return;
    }
    struct hugetlbfs_sb_info *sbi = HUGETLBFS_SB(sb);
    if (sbi) {
        sb->s_fs_info = NULL;
        kfree(sbi);
    }
}
--------------------
static void hugetlbfs_put_super(struct super_block *sb) {
    if (!sb) {
        return;
    }
    struct hugetlbfs_sb_info *sbi = HUGETLBFS_SB(sb);
    if (sbi) {
        sb->s_fs_info = NULL;
        if (!IS_ERR_OR_NULL(sbi)) {
            kfree(sbi);
        }
    }
}
--------------------
static void hugetlbfs_put_super(struct super_block *sb) {
    if (!sb) {
        return;
    }
    struct hugetlbfs_sb_info *sbi = HUGETLBFS_SB(sb);
    if (sbi) {
        sb->s_fs_info = NULL;
        if (IS_ERR_OR_NULL(sbi)) {
            return;
        }
        kfree(sbi);
    }
}
--------------------
static void hugetlbfs_put_super(struct super_block *sb) {
    if (!sb) {
        return;
    }
    struct hugetlbfs_sb_info *sbi = HUGETLBFS_SB(sb);
    if (sbi) {
        sb->s_fs_info = NULL;
        if (IS_ERR_OR_NULL(sbi)) {
            return;
        }
        kfree_sensitive(sbi);
    }
}
--------------------
static void hugetlbfs_put_super(struct super_block *sb) {
    if (!sb) {
        return;
    }
    struct hugetlbfs_sb_info *sbi = HUGETLBFS_SB(sb);
    if (sbi) {
        sb->s_fs_info = NULL;
        if (IS_ERR_OR_NULL(sbi)) {
            return;
        }
        kmem_cache_free(hugetlbfs_info_cache, sbi);
    }
}
--------------------
static void hugetlbfs_put_super(struct super_block *sb) {
    if (!sb) {
        return;
    }
    struct hugetlbfs_sb_info *sbi = HUGETLBFS_SB(sb);
    if (sbi) {
        sb->s_fs_info = NULL;
        if (IS_ERR_OR_NULL(sbi)) {
            return;
        }
        memset(sbi, 0, sizeof(*sbi));
        kmem_cache_free(hugetlbfs_info_cache, sbi);
    }
}
--------------------
static void hugetlbfs_put_super(struct super_block *sb) {
    if (!sb) {
        return;
    }
    struct hugetlbfs_sb_info *sbi = HUGETLBFS_SB(sb);
    if (sbi) {
        if (sb->s_fs_info == sbi) {
            sb->s_fs_info = NULL;
        }
        if (IS_ERR_OR_NULL(sbi)) {
            return;
        }
        memset(sbi, 0, sizeof(*sbi));
        kmem_cache_free(hugetlbfs_info_cache, sbi);
    }
}
--------------------
static void hugetlbfs_put_super(struct super_block *sb) {
    if (!sb) {
        return;
    }
    struct hugetlbfs_sb_info *sbi = HUGETLBFS_SB(sb);
    if (sbi) {
        sb_set_blocksize(sb, PAGE_SIZE);
        if (sb_blocksize(sb) != PAGE_SIZE) {
            pr_err("hugetlbfs_put_super: sb_blocksize changed\n");
        }
        if (sb->s_fs_info == sbi) {
            sb->s_fs_info = NULL;
        }
        if (IS_ERR_OR_NULL(sbi)) {
            return;
        }
        memset(sbi, 0, sizeof(*sbi));
        kmem_cache_free(hugetlbfs_info_cache, sbi);
    }
}
--------------------
static DEFINE_MUTEX(hugetlbfs_mutex);

static void hugetlbfs_put_super(struct super_block *sb) {
    if (!sb) {
        return;
    }
    mutex_lock(&hugetlbfs_mutex);
    struct hugetlbfs_sb_info *sbi = HUGETLBFS_SB(sb);
    if (sbi) {
        sb_set_blocksize(sb, PAGE_SIZE);
        if (sb_blocksize(sb) != PAGE_SIZE) {
            pr_err("hugetlbfs_put_super: sb_blocksize changed\n");
        }
        if (sb->s_fs_info == sbi) {
            sb->s_fs_info = NULL;
        }
        if (IS_ERR_OR_NULL(sbi)) {
            goto out;
        }
        memset(sbi, 0, sizeof(*sbi));
        kmem_cache_free(hugetlbfs_info_cache, sbi);
    }
out:
    mutex_unlock(&hugetlbfs_mutex);
}
--------------------
match:0
source:
 int bson_check_field_name ( bson * b , const char * string , <S2SV_StartBug> const int length ) { <S2SV_EndBug> return bson_validate_string ( b , ( const unsigned char * ) string , length , 1 , 1 , 1 ) ; }


target:
int bson_check_field_name ( bson * b , const char * string , const size_t length ) { return bson_validate_string ( b , ( const unsigned char * ) string , length , 1 , 1 , 1 ) ; }
outputs:
int bson_check_field_name(bson *b, const char *string, const int length) {
    return bson_validate_string(b, (const unsigned char *)string, length, 1, 1, 1);
}
--------------------
int bson_check_field_name(bson *b, const char *string, const int length) {
    if (string == NULL) {
        return BSON_ERROR;
    }
    return bson_validate_string(b, (const unsigned char *)string, length, 1, 1, 1);
}
--------------------
int bson_check_field_name(bson *b, const char *string, const int length) {
    size_t len = strnlen(string, length);
    return bson_validate_string(b, (const unsigned char *)string, len, 1, 1, 1);
}
--------------------
//换了变量类型
int bson_check_field_name(bson *b, const char *string, const size_t length) {
    return bson_validate_string(b, (const unsigned char *)string, length, 1, 1, 1);
}
--------------------
int bson_check_field_name(bson *b, const char *string, const size_t length) {
    if (length > BSON_MAX_STRING_SIZE || length <= 0) {
        return BSON_ERROR;
    }
    return bson_validate_string(b, (const unsigned char *)string, length, 1, 1, 1);
}
--------------------
int bson_check_field_name(bson *b, const char *string, const size_t length) {
    if (string == NULL || length > (BSON_MAX_STRING_SIZE - 1) || length <= 0 || string[length - 1] != '\0') {
        return BSON_ERROR;
    }
    return bson_validate_string(b, (const unsigned char *)string, length - 1, 1, 1, 1);
}
--------------------
int bson_check_field_name(bson *b, const char *string, const size_t length) {
    char buf[BSON_MAX_STRING_SIZE];
    strncpy(buf, string, length);
    buf[length] = '\0';
    return bson_validate_string(b, (const unsigned char *)buf, length, 1, 1, 1);
}
--------------------
int bson_check_field_name(bson *b, const char *string, const size_t length) {
    if (string == NULL || length > (BSON_MAX_STRING_SIZE - 1) || length <= 0) {
        return BSON_ERROR;
    }
    char buf[BSON_MAX_STRING_SIZE];
    strncpy(buf, string, length);
    buf[length] = '\0';
    return bson_validate_string(b, (const unsigned char *)buf, length, 1, 1, 1);
}
--------------------
int bson_check_field_name(bson *b, const char *string, const size_t length) {
    char buf[BSON_MAX_STRING_SIZE];
    strncpy(buf, string, length);
    buf[length] = '\0';
    return bson_validate_string(b, (const unsigned char *)buf, length, 1, 1, 1);
}
--------------------
int bson_check_field_name(bson *b, const char *string, const size_t length) {
    if (string == NULL || strlen(string) > (BSON_MAX_STRING_SIZE - 1) || length <= 0) {
        return BSON_ERROR;
    }
    return bson_validate_string(b, (const unsigned char *)string, length, 1, 1, 1);
}
--------------------
match:1
source:
 void put_filp ( struct file * file ) { if ( atomic_long_dec_and_test ( & file -> f_count ) ) { security_file_free ( file ) ; <S2SV_StartBug> file_sb_list_del ( file ) ; <S2SV_EndBug> file_free ( file ) ; } }


target:
void put_filp ( struct file * file ) { if ( atomic_long_dec_and_test ( & file -> f_count ) ) { security_file_free ( file ) ; file_free ( file ) ; } }
outputs:
//删掉错误行
void put_filp(struct file *file) {
    if (atomic_long_dec_and_test(&file->f_count)) {
        security_file_free(file);
        file_free(file);
    }
}
--------------------
void put_filp(struct file *file) {
    if (file && atomic_long_dec_and_test(&file->f_count)) {
        security_file_free(file);
        file_free(file);
    }
}
--------------------
void put_filp(struct file *file) {
    if (file && atomic_long_dec_if_positive(&file->f_count)) {
        security_file_free(file);
        file_free(file);
    }
}
--------------------
void put_filp(struct file *file) {
    if (file) {
        if (atomic_long_dec_and_test(&file->f_count)) {
            security_file_free(file);
            file_free(file);
        }
    }
}
--------------------
void put_filp(struct file *file) {
    if (file) {
        atomic_long_dec(&file->f_count);
        if (atomic_long_read(&file->f_count) == 0) {
            security_file_free(file);
            file_free(file);
        }
    }
}
--------------------
void put_filp(struct file *file) {
    if (!file || !atomic_long_dec_and_test(&file->f_count)) {
        return;
    }
    security_file_free(file);
    file_free(file);
}
--------------------
void put_filp(struct file *file) {
    if (file && atomic_long_dec_return(&file->f_count) == 0) {
        security_file_free(file);
        file_free(file);
    }
}
--------------------
void put_filp(struct file *file) {
    if (file && atomic_long_read(&file->f_count) == 1 && atomic_long_dec_not_positive(&file->f_count)) {
        return;
    }
    security_file_free(file);
    file_free(file);
}
--------------------
void put_filp(struct file *file) {
    if (!file || atomic_long_dec_if_positive(&file->f_count)) {
        return;
    }
    security_file_free(file);
    file_free(file);
}
--------------------
void put_filp(struct file *file) {
    if (!file) {
        return;
    }
    if (atomic_long_dec_and_test(&file->f_count)) {
        security_file_free(file);
        file_free(file);
    }
}
--------------------
match:1
source:
void close_uinput ( void ) { BTIF_TRACE_DEBUG ( "%s" , __FUNCTION__ ) ; if ( uinput_fd > 0 ) { <S2SV_StartBug> ioctl ( uinput_fd , UI_DEV_DESTROY ) ; <S2SV_EndBug> close ( uinput_fd ) ; uinput_fd = - 1 ; } }

target:
void close_uinput ( void ) { BTIF_TRACE_DEBUG ( "%s" , __FUNCTION__ ) ; if ( uinput_fd > 0 ) { TEMP_FAILURE_RETRY ( ioctl ( uinput_fd , UI_DEV_DESTROY ) ) ; close ( uinput_fd ) ; uinput_fd = - 1 ; } }

outputs:
void close_uinput ( void ) {
  BTIF_TRACE_DEBUG ( "%s" , __FUNCTION__ ) ;
  if ( uinput_fd > 0 ) {
    ioctl ( uinput_fd , UI_DEV_DESTROY ) ;
    ioctl ( uinput_fd , UI_CLOSE ) ; // Fixed line
    close ( uinput_fd ) ;
    uinput_fd = - 1 ;
  }
}
--------------------
void close_uinput ( void ) {
  BTIF_TRACE_DEBUG ( "%s" , __FUNCTION__ ) ;
  if ( uinput_fd > 0 ) {
    ioctl ( uinput_fd , UI_DEV_DESTROY ) ;
    ioctl ( uinput_fd , UI_DEV_CLOSE ) ; // Fixed line
    close ( uinput_fd ) ;
    uinput_fd = - 1 ;
  }
}
--------------------
void close_uinput ( void ) {
  BTIF_TRACE_DEBUG ( "%s" , __FUNCTION__ ) ;
  if ( uinput_fd > 0 ) {
    ioctl ( uinput_fd , UI_DEV_DESTROY ) ;
    ioctl ( uinput_fd , UI_DEV_UNREGISTER ) ; // Fixed line
    close ( uinput_fd ) ;
    uinput_fd = - 1 ;
  }
}
--------------------
void close_uinput ( void ) {
  BTIF_TRACE_DEBUG ( "%s" , __FUNCTION__ ) ;
  if ( uinput_fd > 0 ) {
    ioctl ( uinput_fd , UI_DEV_DESTROY ) ;
    ioctl ( uinput_fd , UI_BEGIN_FF_UPLOAD ) ; // Fixed line
    close ( uinput_fd ) ;
    uinput_fd = - 1 ;
  }
}
--------------------
void close_uinput ( void ) {
  BTIF_TRACE_DEBUG ( "%s" , __FUNCTION__ ) ;
  if ( uinput_fd > 0 ) {
    ioctl ( uinput_fd , UI_DEV_DESTROY ) ;
    ioctl ( uinput_fd , UI_DEV_REMOVE ) ; // Fixed line
    close ( uinput_fd ) ;
    uinput_fd = - 1 ;
  }
}
--------------------
void close_uinput ( void ) {
  BTIF_TRACE_DEBUG ( "%s" , __FUNCTION__ ) ;
  if ( uinput_fd > 0 ) {
    ioctl ( uinput_fd , UI_DEV_DESTROY ) ;
    ioctl ( uinput_fd , UI_DEV_UNBIND ) ; // Fixed line
    close ( uinput_fd ) ;
    uinput_fd = - 1 ;
  }
}
--------------------
void close_uinput ( void ) {
  BTIF_TRACE_DEBUG ( "%s" , __FUNCTION__ ) ;
  if ( uinput_fd > 0 ) {
    ioctl ( uinput_fd , UI_DEV_DESTROY ) ;
    ioctl ( uinput_fd , UI_DEV_PHYS ) ; // Fixed line
    close ( uinput_fd ) ;
    uinput_fd = - 1 ;
  }
}
--------------------
void close_uinput ( void ) {
  BTIF_TRACE_DEBUG ( "%s" , __FUNCTION__ ) ;
  if ( uinput_fd > 0 ) {
    ioctl ( uinput_fd , UI_DEV_DESTROY ) ;
    ioctl ( uinput_fd , UI_END_FF_UPLOAD ) ; // Fixed line
    close ( uinput_fd ) ;
    uinput_fd = - 1 ;
  }
}
--------------------
void close_uinput ( void ) {
  BTIF_TRACE_DEBUG ( "%s" , __FUNCTION__ ) ;
  if ( uinput_fd > 0 ) {
    ioctl ( uinput_fd , UI_DEV_DESTROY ) ;
    ioctl ( uinput_fd , UI_FF_UPLOAD ) ; // Fixed line
    close ( uinput_fd ) ;
    uinput_fd = - 1 ;
  }
}
--------------------
void close_uinput ( void ) {
  BTIF_TRACE_DEBUG ( "%s" , __FUNCTION__ ) ;
  if ( uinput_fd > 0 ) {
    ioctl ( uinput_fd , UI_DEV_DESTROY ) ;
    ioctl ( uinput_fd , UI_SET_PHYS ) ; // Fixed line
    close ( uinput_fd ) ;
    uinput_fd = - 1 ;
  }
}
--------------------
match:0
source:
static int check_line_charstring ( void ) { char * p = line ; <S2SV_StartBug> while ( isspace ( * p ) ) <S2SV_EndBug> p ++ ; return ( * p == '/' || ( p [ 0 ] == 'd' && p [ 1 ] == 'u' && p [ 2 ] == 'p' ) ) ; }

target:
static int check_line_charstring ( void ) { char * p = line ; while ( isspace ( ( unsigned char ) * p ) ) p ++ ; return ( * p == '/' || ( p [ 0 ] == 'd' && p [ 1 ] == 'u' && p [ 2 ] == 'p' ) ) ; }

outputs:
static int check_line_charstring (void) {
    char *p = line;
    while (isspace (*p)) p++;
    if (*p == '/' || (strncmp(p, "dup", 3) == 0)) {
        return 1;
    }
    return 0;
}
--------------------
static int check_line_charstring (void) {
    char *p = line;
    while (isspace(*p)) p++;
    if (*p == '/' || (p[0] == 'd' && p[1] == 'u' && p[2] == 'p' && isspace(p[3]))) {
        return 1;
    }
    return 0;
}
--------------------
static int check_line_charstring (void) {
    char *p = line;
    while (isspace(*p)) p++;
    if (*p == '/' || strncmp(p, "dup", 3) == 0) {
        return 1;
    }
    return 0;
}
--------------------
static int check_line_charstring (void) {
    char *p = line;
    while (isspace(*p)) p++;
    if (*p == '/' || (*p == 'd' && *(p+1) == 'u' && *(p+2) == 'p')) {
        return 1;
    }
    return 0;
}
--------------------
static int check_line_charstring (void) {
    char *p = line;
    while (isspace(*p)) p++;
    if (*p == '/') {
        return 1;
    } else if (*p == 'd' && *(p+1) == 'u' && *(p+2) == 'p') {
        return 1;
    } else {
        return 0;
    }
}
--------------------
static int check_line_charstring (void) {
    char *p = line;
    while (isspace(*p)) p++;
    if (*p == '/') {
        return 1;
    } else if (strncmp(p, "dup", 3) == 0) {
        return 1;
    } else {
        return 0;
    }
}
--------------------
static int check_line_charstring (void) {
    char *p = line;
    while (isspace(*p)) p++;
    if (*p == '/') {
        return 1;
    } else if (p[0] == 'd' && p[1] == 'u' && p[2] == 'p' && p[3] == ' ') {
        return 1;
    } else {
        return 0;
    }
}
--------------------
static int check_line_charstring (void) {
    char *p = line;
    while (isspace(*p)) p++;
    if (*p == '/') {
        return 1;
    } else if (strcmp(p, "dup") == 0) {
        return 1;
    } else {
        return 0;
    }
}
--------------------
static int check_line_charstring (void) {
    char *p = line;
    while (isspace(*p)) p++;
    if (*p == '/' || (p[0] == 'd' && p[1] == 'u' && p[2] == 'p' && p[3] == '\0')) {
        return 1;
    }
    return 0;
}
--------------------
static int check_line_charstring (void) {
    char *p = line;
    while (isspace(*p)) p++;
    if (*p == '/') {
        return 1;
    } else {
        char dupstr[4];
        memcpy(dupstr, p, 3);
        dupstr[3] = '\0';
        if (strcmp(dupstr, "dup") == 0) {
            return 1;
        }
    }
    return 0;
}
--------------------
match:0
source:
<S2SV_StartBug> static int read_segment_id ( vp9_reader * r , const struct segmentation * seg ) { <S2SV_EndBug> <S2SV_StartBug> return vp9_read_tree ( r , vp9_segment_tree , seg -> tree_probs ) ; <S2SV_EndBug> }

target:
static int read_segment_id ( vpx_reader * r , const struct segmentation * seg ) { return vpx_read_tree ( r , vp9_segment_tree , seg -> tree_probs ) ; }

outputs:
static int read_segment_id(vp9_reader *r, const struct segmentation *seg) {
  int id = vp9_read_tree(r, vp9_segment_tree, seg->tree_probs);
  // check id bounds and handle errors
  return id;
}
--------------------
static int read_segment_id(vp9_reader *r, const struct segmentation *seg) {
  int id = vp9_read(r, MAX_SEGMENTS_LOG2);
  // check id bounds and handle errors
  return id;
}
--------------------
static int read_segment_id(vp9_reader *r, const struct segmentation *seg) {
  int i, id = 0;
  for (i = 0; i < MAX_SEGMENTS && vp9_read(r, 1); ++i) {
    if (seg->tree_probs[i] != 255)
      id |= (vp9_read(r, 1) << i);
    else
      id |= (vp9_read(r, 1) << MAX_SEGMENTS_LOG2);
  }
  // check id bounds and handle errors
  return id;
}
--------------------
static int read_segment_id(vp9_reader *r, const struct segmentation *seg) {
  int id;
  const uint8_t *probs = seg->tree_probs;
  id = vp9_read(r, probs[0] + 1);
  if (probs[id]) {
    int i;
    for(i = 1; i < MAX_SEGMENTS; ++i) {
      id |= vp9_read(r, 1) << i;
      if(!probs[id])
        return id;
    }
  }
  // handle error for out of bounds
  return id;
}
--------------------
static int read_segment_id(vp9_reader *r, const struct segmentation *seg) {
  int id = 0, i, brk = MAX_SEGMENTS_LOG2;
  while (brk && vp9_read(r, 1)) brk--;
  for(i = 0; i < brk; ++i)
    id |= vp9_read(r, 1) << i;
  // check id bounds and handle errors
  return id;
}
--------------------
static int read_segment_id(vp9_reader *r, const struct segmentation *seg) {
  const uint8_t *probs = seg->tree_probs;
  int node = 0, bits = 0, i;
  for(i = 0; i < MAX_SEGMENTS_LOG2; ++i) {
    node = (vp9_read_bit(r, probs[node]) << 1) | vp9_read_bit(r, probs[node]);
    bits |= node << i;
  }
  // handle error for out of bounds
  return bits;
}
--------------------
static int read_segment_id(vp9_reader *r, const struct segmentation *seg) {
  int id = 0, i;
  const uint8_t *probs = seg->tree_probs;
  int back = 1 << MAX_SEGMENTS_LOG2;
  for (i = 0; i < MAX_SEGMENTS; ++i) {
    int bit = vp9_read_bit(r, probs[id]);
    id = (id << 1) | bit;
    back -= bit;
    if (!back)
      break;
  }
  // check id bounds and handle errors
  return id;
}
--------------------
static int read_segment_id(vp9_reader *r, const struct segmentation *seg)
{
  int id = vp9_read(r, MAX_SEGMENTS_LOG2);
  id &= seg->enabled;
  // handle error for out of bounds
  return id;
}
--------------------
static int read_segment_id(vp9_reader *r, const struct segmentation *seg) {
  int i;
  for (i = 0; i < MAX_SEGMENTS; ++i) {
    if (vp9_read(r, 1)) {
      if (seg->tree_probs[i])
        return i;
      continue;
    }
    if (!i)
      break;
    else
      return i;
  }
  // handle error for no matches found
  return i;
}
--------------------
static int read_segment_id(vp9_reader *r,const struct segmentation *seg){
    int i, id = 0;
    for (i = 0; i < MAX_SEGMENTS; i++) {
        const uint8_t *probs = seg->tree_probs + id;
        id = (id << 1) | vp9_read_tree(r, vp9_small_tree, probs);
    }
    // check id bounds and handle errors
    return id;
}
--------------------
match:0
source:
 int snmp_version ( void * context , size_t hdrlen , unsigned char tag , const void * data , size_t datalen ) { <S2SV_StartBug> if ( * ( unsigned char * ) data > 1 ) <S2SV_EndBug> return - ENOTSUPP ; return 1 ; }


target:
int snmp_version ( void * context , size_t hdrlen , unsigned char tag , const void * data , size_t datalen ) { if ( datalen != 1 ) return - EINVAL ; if ( * ( unsigned char * ) data > 1 ) return - ENOTSUPP ; return 1 ; }
outputs:
int snmp_version(void* context, size_t hdrlen, unsigned char tag, const void* data, size_t datalen) {
    if (tag != 0x02) {
        return -ENOTSUPP;
    }
    if (*(unsigned char*)data < 0 || *(unsigned char*)data > 1) {
        return -ENOTSUPP;
    }
    return 1;
}
--------------------
int snmp_version(void* context, size_t hdrlen, unsigned char tag, const void* data, size_t datalen) {
    if (tag != 0x02 || datalen != 1) {
        return -ENOTSUPP;
    }
    if (*(unsigned char*)data > 1) {
        return -ENOTSUPP;
    }
    return 1;
}
--------------------
int snmp_version(void* context, size_t hdrlen, unsigned char tag, const void* data, size_t datalen) {
    if (tag != 0x02 || datalen != sizeof(unsigned char)) {
        return -ENOTSUPP;
    }
    if (*(unsigned char*)data > 1) {
        return -ENOTSUPP;
    }
    return 1;
}
--------------------
int snmp_version(void* context, size_t hdrlen, unsigned char tag, const void* data, size_t datalen) {
    if (tag != 0x02) {
        return -ENOTSUPP;
    }
    if (*(unsigned char*)data != 0 && *(unsigned char*)data != 1) {
        return -ENOTSUPP;
    }
    return 1;
}
--------------------
int snmp_version(void* context, size_t hdrlen, unsigned char tag, const void* data, size_t datalen) {
    if (tag != 0x02 || datalen != sizeof(unsigned char)) {
        return -ENOTSUPP;
    }
    unsigned char version = *(unsigned char*)data;
    if (version != 0 && version != 1) {
        return -ENOTSUPP;
    }
    return 1;
}
--------------------
int snmp_version(void* context, size_t hdrlen, unsigned char tag, const void* data, size_t datalen) {
    if (tag != 0x02 || datalen != 1) {
        return -ENOTSUPP;
    }
    unsigned char version = *(unsigned char*)data;
    if (version != 0 && version != 1) {
        return -ENOTSUPP;
    }
    return 1;
}
--------------------
int snmp_version(void* context, size_t hdrlen, unsigned char tag, const void* data, size_t datalen) {
    if (tag != 0x02 || datalen != sizeof(unsigned char)) {
        return -ENOTSUPP;
    }
    unsigned char version = *(unsigned char*)data;
    if (version > 1) {
        return -ENOTSUPP;
    }
    return 1;
}
--------------------
int snmp_version(void* context, size_t hdrlen, unsigned char tag, const void* data, size_t datalen) {
    if (tag != 0x02 || datalen != sizeof(unsigned char)) {
        return -ENOTSUPP;
    }
    const unsigned char* version = (unsigned char*)data;
    if (*version > 1) {
        return -ENOTSUPP;
    }
    return 1;
}
--------------------
int snmp_version(void* context, size_t hdrlen, unsigned char tag, const void* data, size_t datalen) {
    if (tag != 0x02 || datalen != sizeof(char)) {
        return -ENOTSUPP;
    }
    const char* version = (char*)data;
    if (*version != 0 && *version != 1) {
        return -ENOTSUPP;
    }
    return 1;
}
--------------------
#define VERSION_1 1
#define VERSION_2 2

int snmp_version(void* context, size_t hdrlen, unsigned char tag, const void* data, size_t datalen) {
    if (tag != 0x02 || datalen != sizeof(unsigned char)) {
        return -ENOTSUPP;
    }
    const unsigned char* version = (unsigned char*)data;
    if (*version == VERSION_1 || *version == VERSION_2) {
        return 1;
    }
    return -ENOTSUPP;
}
--------------------
match:0
source:
 int jas_stream_pad ( jas_stream_t * stream , int n , int c ) { <S2SV_StartBug> int m ; <S2SV_EndBug> m = n ; for ( m = n ; m > 0 ; -- m ) { if ( jas_stream_putc ( stream , c ) == EOF ) return n - m ; } return n ; }


target:
int jas_stream_pad ( jas_stream_t * stream , int n , int c ) { int m ; if ( n < 0 ) { jas_deprecated ( "negativecountforjas_stream_pad" ) ; } m = n ; for ( m = n ; m > 0 ; -- m ) { if ( jas_stream_putc ( stream , c ) == EOF ) return n - m ; } return n ; }
outputs:
int jas_stream_pad(jas_stream_t *stream, int n, int c) {
    int m;
    m = n;
    for (m = n; m > 0; --m) {
        if (jas_stream_putc(stream, c) == JAS_STREAM_EOF) {
            return n - m;
        }
    }
    return n;
}
--------------------
int jas_stream_pad(jas_stream_t *stream, int n, int c) {
    int m = n;
    for (; m > 0; m--) {
        if (jas_stream_putc(stream, c) == JAS_STREAM_EOF) {
            return n - m;
        }
    }
    return n;
}
--------------------
int jas_stream_pad(jas_stream_t *stream, int n, int c) {
    int m = n;
    for (; m > 0; --m) {
        if (jas_stream_putc(stream, c) == JAS_STREAM_EOF) {
            return n - m;
        }
    }
    return n - m;
}
--------------------
int jas_stream_pad(jas_stream_t *stream, int n, int c) {
    int m = n;
    while (m > 0) {
        if (jas_stream_putc(stream, c) == JAS_STREAM_EOF) {
            return n - m;
        }
        m--;
    }
    return n;
}
--------------------
int jas_stream_pad(jas_stream_t *stream, int n, int c) {
    int m = n;
    while (m-- > 0) {
        if (jas_stream_putc(stream, c) == JAS_STREAM_EOF) {
            return n - m;
        }
    }
    return n;
}
--------------------
int jas_stream_pad(jas_stream_t *stream, int n, int c) {
    int m = n;
    do {
        if (jas_stream_putc(stream, c) == JAS_STREAM_EOF) {
            return n - m;
        }
    } while (--m > 0);
    return n;
}
--------------------
int jas_stream_pad(jas_stream_t *stream, int n, int c) {
    int m = n;
    for (int i = 0; i < m; i++) {
        if (jas_stream_putc(stream, c) == JAS_STREAM_EOF) {
            return i;
        }
    }
    return n;
}
--------------------
int jas_stream_pad(jas_stream_t *stream, int n, int c) {
    int m = n;
    int i = 0;
    while (i < m) {
        if (jas_stream_putc(stream, c) == JAS_STREAM_EOF) {
            return i;
        }
        i++;
    }
    return n;
}
--------------------
int jas_stream_pad(jas_stream_t *stream, int n, int c) {
    int m = n;
    int i = 0;
    while (i < m) {
        if (jas_stream_putc(stream, c) == JAS_STREAM_EOF) {
            return n - m + i;
        }
        i++;
    }
    return n;
}
--------------------
int jas_stream_pad(jas_stream_t *stream, int n, int c) {
    int m = n;
    for (int i = 0; i < m; i++) {
        if (jas_stream_putc(stream, c) == JAS_STREAM_EOF) {
            return n - m + i;
        }
    }
    return n;
}
--------------------
match:0
source:
void * xcalloc ( size_t num , size_t size ) { <S2SV_StartBug> void * ptr = malloc ( num * size ) ; <S2SV_EndBug> if ( ptr ) { <S2SV_StartBug> memset ( ptr , '\\0' , ( num * size ) ) ; <S2SV_EndBug> } return ptr ; }

target:
void * xcalloc ( size_t num , size_t size ) { size_t res ; if ( check_mul_overflow ( num , size , & res ) ) abort ( ) ; void * ptr ; ptr = malloc ( res ) ; if ( ptr ) { memset ( ptr , '\\0' , ( res ) ) ; } return ptr ; }

outputs:
void * xcalloc ( size_t num , size_t size ) {
  void * ptr = calloc ( num , size ) ;
  return ptr ;
}
--------------------
void * xcalloc ( size_t num , size_t size ) {
  void * ptr = malloc ( num * size ) ;
  if ( ptr ) {
    memset ( ptr , 0 , ( num * size ) ) ;
  }
  return ptr ;
}
--------------------
void * xcalloc ( size_t num , size_t size ) {
  void * ptr = malloc ( num * size ) ;
  if ( ptr ) {
    memset ( ptr , '\0' , ( num * size ) ) ;
  }
  return ptr ;
}
--------------------
void * xcalloc ( size_t num , size_t size ) {
  void * ptr = calloc ( num , size ) ;
  if ( ptr ) {
    memset ( ptr , 0 , ( num * size ) ) ;
  }
  return ptr ;
}
--------------------
void * xcalloc ( size_t num , size_t size ) {
  void * ptr = malloc ( num * size ) ;
  if ( ptr ) {
    memset ( ptr , 0 , num * size ) ;
  }
  return ptr ;
}
--------------------
void * xcalloc ( size_t num , size_t size ) {
  void * ptr = calloc ( num , size ) ;
  if ( ptr ) {
    memset ( ptr , '\0' , num * size ) ;
  }
  return ptr ;
}
--------------------
void * xcalloc ( size_t num , size_t size ) {
  void * ptr = malloc ( num * size ) ;
  if ( ptr ) {
    memset ( ptr , 0 , num * size ) ;
  }
  return ptr ;
}
--------------------
void * xcalloc ( size_t num , size_t size ) {
  void * ptr = calloc ( num , size ) ;
  if ( ptr ) {
    memset ( ptr , '\0' , num * size ) ;
  }
  return ptr ;
}
--------------------
void * xcalloc ( size_t num , size_t size ) {
  void * ptr = calloc ( num , size ) ;
  return ptr ;
}
--------------------
void * xcalloc ( size_t num , size_t size ) {
  void * ptr = malloc ( num * size ) ;
  return ptr ;
}
--------------------
match:0
source:
static vpx_codec_err_t ctrl_set_invert_tile_order ( vpx_codec_alg_priv_t * ctx , <S2SV_StartBug> int ctr_id , va_list args ) { <S2SV_EndBug> ctx -> invert_tile_order = va_arg ( args , int ) ; return VPX_CODEC_OK ; }

target:
static vpx_codec_err_t ctrl_set_invert_tile_order ( vpx_codec_alg_priv_t * ctx , va_list args ) { ctx -> invert_tile_order = va_arg ( args , int ) ; return VPX_CODEC_OK ; }

outputs:
static vpx_codec_err_t ctrl_set_invert_tile_order(vpx_codec_alg_priv_t* ctx, int ctr_id, va_list args)
{
    if(ctr_id < 0)
    {
        return VPX_CODEC_INVALID_PARAM;
    }
    ctx->invert_tile_order = va_arg(args, int);
    return VPX_CODEC_OK;
}
--------------------
static vpx_codec_err_t ctrl_set_invert_tile_order(vpx_codec_alg_priv_t* ctx, int ctr_id, va_list args)
{
    (void)ctr_id;
    ctx->invert_tile_order = va_arg(args, int);
    return VPX_CODEC_OK;
}
--------------------
static vpx_codec_err_t ctrl_set_invert_tile_order(vpx_codec_alg_priv_t* ctx, int ctr_id, va_list args)
{
    if (args == NULL || ctr_id < 0)
    {
        return VPX_CODEC_INVALID_PARAM;
    }

    ctx->invert_tile_order = va_arg(args, int);
    return VPX_CODEC_OK;
}
--------------------
static vpx_codec_err_t ctrl_set_invert_tile_order(vpx_codec_alg_priv_t* ctx, int ctr_id, va_list args)
{
    if (args == NULL || ctr_id < 0)
    {
        return VPX_CODEC_INVALID_PARAM;
    }

    int param_val = va_arg(args, int);
    if(param_val != 0 && param_val != 1)
    {
        return VPX_CODEC_INVALID_PARAM;
    }

    ctx->invert_tile_order = param_val;
    return VPX_CODEC_OK;
}
--------------------
static vpx_codec_err_t ctrl_set_invert_tile_order(vpx_codec_alg_priv_t* ctx, int ctr_id, va_list args)
{
    if (ctx == NULL || args == NULL)
    {
        return VPX_CODEC_INVALID_PARAM;
    }

    if (ctr_id < 0)
    {
        if (ctx->config.g_w != 0 && ctx->config.g_h != 0)
        {
            int num_tiles = ((ctx->config.g_w + 63) / 64) * ((ctx->config.g_h + 63) / 64);
            ctx->invert_tile_order = (num_tiles > 1);
        }
        else
        {
            ctx->invert_tile_order = 0;
        }
    }
    else
    {
        ctx->invert_tile_order = va_arg(args, int);
        if(ctx->invert_tile_order < 0 || ctx->invert_tile_order > 1)
        {
            return VPX_CODEC_INVALID_PARAM;
        }
    }

    return VPX_CODEC_OK;
}
--------------------
static vpx_codec_err_t ctrl_set_invert_tile_order(vpx_codec_alg_priv_t* ctx, int ctr_id, va_list args)
{
    if (args == NULL)
    {
        return VPX_CODEC_INVALID_PARAM;
    }

    int param_val = va_arg(args, int);
    if(param_val < 0 || param_val > 1)
    {
        return VPX_CODEC_INVALID_PARAM;
    }

    ctx->invert_tile_order = param_val;
    return VPX_CODEC_OK;
}
--------------------
static vpx_codec_err_t ctrl_set_invert_tile_order(vpx_codec_alg_priv_t* ctx, int ctr_id, va_list args)
{
		if (ctx == NULL || args == NULL)
    {
        return VPX_CODEC_INVALID_PARAM;
    }

    ctx->invert_tile_order = !!va_arg(args, int);
    return VPX_CODEC_OK;
}
--------------------
enum TileOrder {
    ORDER_DEFAULT = 0,
    ORDER_INVERTED = 1
};

static vpx_codec_err_t ctrl_set_invert_tile_order(vpx_codec_alg_priv_t* ctx, int ctr_id, va_list args)
{
    if (args == NULL)
    {
        return VPX_CODEC_INVALID_PARAM;
    }

    TileOrder order = (TileOrder)va_arg(args, int);
    switch (order) {
        case ORDER_INVERTED:
            ctx->invert_tile_order = 1;
            break;
        case ORDER_DEFAULT:
            ctx->invert_tile_order = 0;
            break;
        default:
            return VPX_CODEC_INVALID_PARAM;
    }

    return VPX_CODEC_OK;
}
--------------------
static vpx_codec_err_t ctrl_set_invert_tile_order (vpx_codec_alg_priv_t* ctx, int ctr_id, va_list args) {
  if(ctr_id > 0 || args == NULL)
  {
    return VPX_CODEC_INVALID_PARAM;
  }
  ctx->invert_tile_order = (va_arg(args, int) != 0);
  return VPX_CODEC_OK;
}
--------------------
static vpx_codec_err_t ctrl_set_invert_tile_order (vpx_codec_alg_priv_t* ctx, int ctr_id, va_list args) {
  if(ctr_id != 0 || args == NULL) { // use != instead of < 0 to allow for ctr_id > 0
    return VPX_CODEC_INVALID_PARAM;
  }
  ctx->invert_tile_order = (int)va_arg(args, int) != 0; // cast to int to handle potential data type differences between setting implementation and get
  return VPX_CODEC_OK;
}
--------------------
match:0
source:
static struct o2nm_cluster * to_o2nm_cluster_from_node ( struct o2nm_node * node ) { <S2SV_StartBug> return to_o2nm_cluster ( node -> nd_item . ci_parent -> ci_parent ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>

target:
static struct o2nm_cluster * to_o2nm_cluster_from_node ( struct o2nm_node * node ) { if ( node -> nd_item . ci_parent ) return to_o2nm_cluster ( node -> nd_item . ci_parent -> ci_parent ) ; else return NULL ; }

outputs:
static struct o2nm_cluster * to_o2nm_cluster_from_node ( struct o2nm_node * node ) {
    return to_o2nm_cluster ( node -> nd_item . ci_parent -> ci_parent -> ci_parent ) ;
}
--------------------
static struct o2nm_cluster * to_o2nm_cluster_from_node ( struct o2nm_node * node ) {
    return to_o2nm_cluster ( node -> nd_item . ci_parent -> ci_parent -> ci_parent -> ci_parent ) ;
}
--------------------
static struct o2nm_cluster * to_o2nm_cluster_from_node ( struct o2nm_node * node ) {
    return to_o2nm_cluster ( node -> nd_item . ci_parent -> ci_parent -> ci_parent -> ci_parent -> ci_parent ) ;
}
--------------------
static struct o2nm_cluster * to_o2nm_cluster_from_node ( struct o2nm_node * node ) {
    return to_o2nm_cluster ( node -> nd_item . ci_parent -> ci_parent -> ci_parent -> ci_parent -> ci_parent -> ci_parent ) ;
}
--------------------
static struct o2nm_cluster * to_o2nm_cluster_from_node ( struct o2nm_node * node ) {
    return to_o2nm_cluster ( node -> nd_item . ci_parent -> ci_parent -> ci_parent -> ci_parent -> ci_parent -> ci_parent -> ci_parent ) ;
}
--------------------
static struct o2nm_cluster * to_o2nm_cluster_from_node ( struct o2nm_node * node ) {
    return to_o2nm_cluster ( node -> nd_item . ci_parent -> ci_parent -> ci_parent -> ci_parent -> ci_parent -> ci_parent -> ci_parent -> ci_parent ) ;
}
--------------------
static struct o2nm_cluster * to_o2nm_cluster_from_node ( struct o2nm_node * node ) {
    return to_o2nm_cluster ( node -> nd_item . ci_parent -> ci_parent ) ;
}
--------------------
static struct o2nm_cluster * to_o2nm_cluster_from_node ( struct o2nm_node * node ) {
    return to_o2nm_cluster ( node -> nd_item . ci_parent -> nd_item . ci_parent ) ;
}
--------------------
static struct o2nm_cluster * to_o2nm_cluster_from_node ( struct o2nm_node * node ) {
    return to_o2nm_cluster ( node -> nd_item . ci_parent -> nd_item . ci_parent -> nd_item . ci_parent ) ;
}
--------------------
static struct o2nm_cluster * to_o2nm_cluster_from_node ( struct o2nm_node * node ) {
    return to_o2nm_cluster ( node -> nd_item . ci_parent -> nd_item . ci_parent -> nd_item . ci_parent -> nd_item . ci_parent ) ;
}
--------------------
match:0
source:
cJSON * cJSON_GetObjectItem ( cJSON * object , const char * string ) { <S2SV_StartBug> cJSON * c = object -> child ; <S2SV_EndBug> while ( c && cJSON_strcasecmp ( c -> string , string ) ) c = c -> next ; return c ; }

target:
cJSON * cJSON_GetObjectItem ( cJSON * object , const char * string ) { cJSON * c = object ? object -> child : 0 ; while ( c && cJSON_strcasecmp ( c -> string , string ) ) c = c -> next ; return c ; }

outputs:
cJSON * cJSON_GetObjectItem ( cJSON * object , const char * string ) {
    if(object == NULL || string == NULL) {
        return NULL;
    }
    cJSON * c = object -> child ;
    while ( c && cJSON_strcasecmp ( c -> string , string ) ) {
        c = c -> next ;
    }
    return c ;
}
--------------------
//大概是对了，对object进行空指针检测
cJSON * cJSON_GetObjectItem ( cJSON * object , const char * string ) {
    cJSON * c = object == NULL ? NULL : object->child ;
    while ( c && cJSON_strcasecmp ( c -> string , string ) ) {
        c = c -> next ;
    }
    return c ;
}
--------------------
cJSON * cJSON_GetObjectItem ( cJSON * object , const char * string ) {
    if (object == NULL || string == NULL || object -> type != cJSON_Object) {
        return NULL;
    }
    cJSON * c = object -> child ;
    while ( c && cJSON_strcasecmp ( c -> string , string ) ) {
        c = c -> next ;
    }
    return c ;
}
--------------------
cJSON * cJSON_GetObjectItem ( cJSON * object , const char * string ) {
    if (object == NULL || string == NULL) {
        return NULL;
    }
    cJSON * c = object -> child ;
    while ( c != NULL ) {
        if (cJSON_strcasecmp ( c -> string , string ) == 0) {
            return c;
        }
        c = c -> next ;
    }
    return NULL;
}
--------------------
cJSON * cJSON_GetObjectItem ( cJSON * object , const char * string ) {
    if (object == NULL || string == NULL) {
        return NULL;
    }
    cJSON * c = object -> child ;
    while ( c ) {
        if (cJSON_strcasecmp ( c -> string , string ) == 0) {
            return c;
        }
        c = c -> next ;
    }
    return NULL;
}
--------------------
cJSON * cJSON_GetObjectItem ( cJSON * object , const char * string ) {
    if (object == NULL || string == NULL) {
        return NULL;
    }
    cJSON * c = object -> child ;
    while ( c && cJSON_strcasecmp ( c -> string , string ) != 0) {
        c = c -> next ;
    }
    return c ;
}
--------------------
cJSON * cJSON_GetObjectItem ( cJSON * object , const char * string ) {
    if(object == NULL || string == NULL) {
        return NULL;
    }
    cJSON * c;
    for(c = object->child ; c && cJSON_strcasecmp ( c -> string , string ) != 0 ; c = c -> next) {}
    return c;
}
--------------------
cJSON * cJSON_GetObjectItem ( cJSON * object , const char * string ) {
    cJSON * c = object == NULL ? NULL : object->child ;
    while ( c ) {
        if (cJSON_strcasecmp ( c -> string , string ) == 0) {
            return c;
        }
        c = c -> next ;
    }
    return NULL;
}
--------------------
cJSON * cJSON_GetObjectItem ( cJSON * object , const char * string ) {
    cJSON * c = object == NULL ? NULL : cJSON_GetArrayItem(object, 0);
    while ( c && cJSON_strcasecmp ( c -> valuestring , string ) != 0) {
        c = cJSON_GetArrayItem(c, 1) ;
    }
    return c ;
}
--------------------
cJSON * cJSON_GetObjectItem ( cJSON * object , const char * string ) {
    if(!object || !string) {
        return NULL;
    }

    cJSON *node = object->child;
    while (node) {
        if(!strcmp(node->string,string)) {
            return node;
        }
        node = node->next;
    }
    return NULL;
}
--------------------
match:0+1
source:
void * sspi_SecureHandleGetUpperPointer ( SecHandle * handle ) { void * pointer ; <S2SV_StartBug> if ( ! handle ) <S2SV_EndBug> return NULL ; pointer = ( void * ) ~ ( ( size_t ) handle -> dwUpper ) ; return pointer ; }

target:
void * sspi_SecureHandleGetUpperPointer ( SecHandle * handle ) { void * pointer ; if ( ! handle || ! SecIsValidHandle ( handle ) ) return NULL ; pointer = ( void * ) ~ ( ( size_t ) handle -> dwUpper ) ; return pointer ; }

outputs:
void * sspi_SecureHandleGetUpperPointer ( SecHandle * handle ) {
    void * pointer ;
    if ( handle == NULL )
        return NULL ;
    pointer = ( void * ) ~ ( ( size_t ) handle -> dwUpper ) ;
    return pointer ;
}
--------------------
void * sspi_SecureHandleGetUpperPointer ( SecHandle * handle ) {
    if(!handle){
        return NULL;
    }
    void * pointer = (void *)~((size_t) handle->dwUpper);
    return pointer ;
}
--------------------
void * sspi_SecureHandleGetUpperPointer ( SecHandle * handle ) {
    void * pointer = NULL;
    if (handle != NULL) {
        pointer = (void *)~((size_t) handle->dwUpper);
    }
    return pointer ;
}
--------------------
void * sspi_SecureHandleGetUpperPointer ( SecHandle * handle ) {
    void * pointer ;
    if ( handle == NULL )
        pointer = NULL ;
    else
        pointer = ( void * ) ~ ( ( size_t ) handle -> dwUpper ) ;
    return pointer ;
}
--------------------
void * sspi_SecureHandleGetUpperPointer ( SecHandle * handle ) {
    void * pointer ;

    if (handle == NULL) {
        pointer = NULL;
    } else {
        pointer = (void *) ~ ((size_t) handle->dwUpper);
    }
    return pointer ;
}
--------------------
void * sspi_SecureHandleGetUpperPointer ( SecHandle * handle ) {
    if (handle == NULL)
        return NULL;

    void * pointer = (void *) ~ ((size_t) handle->dwUpper);
    return pointer ;
}
--------------------
void * sspi_SecureHandleGetUpperPointer ( SecHandle * handle ) {
    void * pointer ;
    if (handle != NULL)
        pointer = ( void * ) ~ ( ( size_t ) handle -> dwUpper ) ;
    else
        pointer = NULL ;
    return pointer ;
}
--------------------
void * sspi_SecureHandleGetUpperPointer ( SecHandle * handle ) {
    void * pointer ;
    if ( handle != NULL )
        pointer = ( void * ) ~ ( ( size_t ) handle -> dwUpper ) ;
    else
        return NULL ;

    return pointer ;
}
--------------------
void * sspi_SecureHandleGetUpperPointer ( SecHandle * handle ) {
    void * pointer ;
    if ( handle == NULL )
        return NULL ;

    pointer = (void*) ~( (size_t) handle->dwUpper ) ;
    return pointer ;
}
--------------------
void * sspi_SecureHandleGetUpperPointer ( SecHandle * handle ) {
    void * pointer = NULL ;
    if ( handle )
        pointer = (void*) ~( (size_t) handle->dwUpper ) ;

    return pointer ;
}
match:0
source:
static inline size_t GetPSDRowSize ( Image * image ) { if ( image -> depth == 1 ) <S2SV_StartBug> return ( ( image -> columns + 7 ) / 8 ) ; <S2SV_EndBug> else return ( image -> columns * GetPSDPacketSize ( image ) ) ; }

target:
static inline size_t GetPSDRowSize ( Image * image ) { if ( image -> depth == 1 ) return ( ( ( image -> columns + 7 ) / 8 ) * GetPSDPacketSize ( image ) ) ; else return ( image -> columns * GetPSDPacketSize ( image ) ) ; }

outputs:
static inline size_t GetPSDRowSize ( Image * image ) {
    if ( image -> depth == 1 )
        return ( ( image -> columns + 7 ) / 8 ) ;
    else
        return ( image -> columns * GetPSDPacketSize ( image ) ) ;
}
--------------------
static inline size_t GetPSDRowSize ( Image * image ) {
    if ( image != NULL && image -> depth == 1 )
        return ( ( image -> columns + 7 ) / 8 ) ;
    else
        return ( image -> columns * GetPSDPacketSize ( image ) ) ;
}
--------------------
static inline size_t GetPSDRowSize ( Image * image ) {
    if ( image -> depth == 1 || !(image->depth))
        return ( ( image -> columns + 7 ) / 8 ) ;
    else
        return ( image -> columns * GetPSDPacketSize ( image ) ) ;
}
--------------------
static inline size_t GetPSDRowSize ( Image * image ) {
    if ( image -> depth == 1 )
        return ( ( image -> columns + 7 ) / 8 ) ;
    else if (image)
        return ( image -> columns * GetPSDPacketSize ( image ) ) ;
    else
        return 0;
}
--------------------
static inline size_t GetPSDRowSize ( Image * image ) {
    if ( image -> depth == 1 && image->columns >= 0 )
        return ( ( image -> columns + 7 ) / 8 ) ;
    else if (image)
        return ( image -> columns * GetPSDPacketSize ( image ) ) ;
    else
        return 0;
}
--------------------
static inline size_t GetPSDRowSize ( Image * image ) {
    if ( image && image -> depth == 1 && image->columns >= 0 )
        return ( ( image -> columns + 7 ) / 8 ) ;
    else if (image)
        return ( image -> columns * GetPSDPacketSize ( image ) ) ;
    else
        return 0;
}
--------------------
static inline size_t GetPSDRowSize ( Image * image ) {
    if ( image) {
        if ( image -> depth == 1 && image->columns >= 0 )
            return ( ( image -> columns + 7 ) / 8 ) ;
        else
            return ( image -> columns * GetPSDPacketSize ( image ) ) ;
    }
    else {
        return 0;
    }
}
--------------------
static inline size_t GetPSDRowSize ( Image * image ) {
    if ( image && image -> depth == 1 && image->columns >= 0 )
        return ( ( image -> columns + 7 ) / 8 ) ;
    else if ( image && image->columns >= 0 )
        return ( image -> columns * GetPSDPacketSize ( image ) ) ;
    else
        return 0;
}
--------------------
static inline size_t GetPSDRowSize ( Image * image ) {
    if ( !image )
        return 0;

    if ( image -> depth == 1 && image->columns >= 0 )
        return ( ( image -> columns + 7 ) / 8 ) ;
    else if ( image->columns >= 0 )
        return ( image -> columns * GetPSDPacketSize ( image ) ) ;
    else
        return 0;
}
--------------------
static inline size_t GetPSDRowSize ( Image * image ) {
    if ( !image )
        return 0;

    if ( image -> depth == 1 && image->columns >= 0 )
        return ( ( image -> columns + 7 ) / 8 ) ;
    else if ( image->columns >= 0 )
        return ( image -> columns * GetPSDPacketSize ( image ) ) ;
    else if (image->columns < 0)
        return -1;
    else
        return 0;
}
--------------------
match:0
source:
<S2SV_StartBug> void vp9_tree_probs_from_distribution ( vp9_tree tree , <S2SV_EndBug> unsigned int branch_ct [ ] [ 2 ] , const unsigned int num_events [ ] ) { convert_distribution ( 0 , tree , branch_ct , num_events ) ; }

target:
void vp9_tree_probs_from_distribution ( vpx_tree tree , unsigned int branch_ct [ ] [ 2 ] , const unsigned int num_events [ ] ) { convert_distribution ( 0 , tree , branch_ct , num_events ) ; }

outputs:
void vp9_tree_probs_from_distribution(vp9_tree tree, unsigned int branch_ct[][2], const unsigned int num_events[]) {
    convert_distribution(0, tree, (unsigned int (*)[2])branch_ct, num_events);
}
--------------------
void vp9_tree_probs_from_distribution(vp9_tree tree, unsigned int branch_ct[][2], const unsigned int num_events[]) {
    convert_distribution(0, tree, branch_ct, (const int *)num_events);
}
--------------------
void vp9_tree_probs_from_distribution(vp9_tree tree, unsigned int branch_ct[][2], const unsigned int num_events[]) {
    convert_distribution(0, tree, (unsigned int (*)[2])branch_ct, (const int *)num_events);
}
--------------------
void vp9_tree_probs_from_distribution(vp9_tree tree, unsigned int branch_ct[][2], const unsigned int num_events[]) {
    convert_distribution((vp9_prob)0, tree, branch_ct, num_events);
}
--------------------
void vp9_tree_probs_from_distribution(vp9_tree tree, unsigned int branch_ct[][2], const unsigned int num_events[]) {
    convert_distribution(0, tree, branch_ct, (const uint16_t *)num_events);
}
--------------------
void vp9_tree_probs_from_distribution(vp9_tree tree, unsigned int branch_ct[][2], const unsigned int num_events[]) {
    convert_distribution(0, tree, branch_ct, (const uint32_t *)num_events);
}
--------------------
void vp9_tree_probs_from_distribution(vp9_tree tree, unsigned int branch_ct[][2], const unsigned int num_events[]) {
    convert_distribution(0, tree, branch_ct, (const uint64_t *)num_events);
}
--------------------
void vp9_tree_probs_from_distribution(vp9_tree tree, unsigned int branch_ct[][2], const unsigned int num_events[]) {
    convert_distribution(0, tree, branch_ct, (const int32_t *)num_events);
}
--------------------
void vp9_tree_probs_from_distribution(vp9_tree tree, unsigned int branch_ct[][2], const unsigned int num_events[]) {
    convert_distribution(0, tree, (unsigned int (*)[2])branch_ct, (const uint16_t *)num_events);
}
--------------------
void vp9_tree_probs_from_distribution(vp9_tree tree, unsigned int branch_ct[][2], const unsigned int num_events[]) {
    convert_distribution(0, tree, (unsigned int (*)[2])branch_ct, (const uint64_t *)num_events);
}
--------------------
match:0
source:
 int ipmi_destroy_user ( struct ipmi_user * user ) { <S2SV_StartBug> _ipmi_destroy_user ( user ) ; <S2SV_EndBug> cleanup_srcu_struct ( & user -> release_barrier ) ; kref_put ( & user -> refcount , free_user ) ; return 0 ; }


target:
int ipmi_destroy_user ( struct ipmi_user * user ) { _ipmi_destroy_user ( user ) ; kref_put ( & user -> refcount , free_user ) ; return 0 ; }
outputs:
int ipmi_destroy_user(struct ipmi_user* user) {
    _ipmi_destroy_user(user);
    cleanup_srcu_struct(&user->release_barrier);
    if (kref_put(&user->refcount, free_user) != 0) {
        return -EINVAL;
    }
    return 0;
}
--------------------
int ipmi_destroy_user(struct ipmi_user* user) {
    _ipmi_destroy_user(user);
    int err = cleanup_srcu_struct(&user->release_barrier);
    if (err != 0) {
        return err;
    }
    if (kref_put(&user->refcount, free_user) != 0) {
        return -EINVAL;
    }
    return 0;
}
--------------------
void _ipmi_destroy_user(struct ipmi_user* user) {
    // implementation goes here
}
int ipmi_destroy_user(struct ipmi_user* user) {
    _ipmi_destroy_user(user);
    int err = cleanup_srcu_struct(&user->release_barrier);
    if (err != 0) {
        return err;
    }
    if (kref_put(&user->refcount, free_user) != 0) {
        return -EINVAL;
    }
    return 0;
}
--------------------
void _ipmi_destroy_user(struct ipmi_user* user) {
    // implementation goes here
}
int ipmi_destroy_user(struct ipmi_user* user) {
    _ipmi_destroy_user(user);
    int err = cleanup_srcu_struct(&user->release_barrier);
    if (err != 0) {
        return err;
    }
    err = kref_put(&user->refcount, free_user);
    if (err != 0) {
        return -EINVAL;
    }
    return 0;
}
--------------------
void _ipmi_destroy_user(struct ipmi_user* user) {
    // implementation goes here
    kfree(user);
}
int ipmi_destroy_user(struct ipmi_user* user) {
    _ipmi_destroy_user(user);
    int err = cleanup_srcu_struct(&user->release_barrier);
    if (err != 0) {
        return err;
    }
    err = kref_put(&user->refcount, free_user);
    if (err != 0) {
        return -EINVAL;
    }
    return 0;
}
--------------------
void cleanup_srcu_struct(struct srcu_struct* sp) {
    synchronize_srcu(sp);
}
void _ipmi_destroy_user(struct ipmi_user* user) {
    // implementation goes here
    kfree(user);
}
int ipmi_destroy_user(struct ipmi_user* user) {
    _ipmi_destroy_user(user);
    int err = cleanup_srcu_struct(&user->release_barrier);
    if (err != 0) {
        return err;
    }
    err = kref_put(&user->refcount, free_user);
    if (err != 0) {
        return -EINVAL;
    }
    return 0;
}
--------------------
void free_user(struct kref* ref) {
    kfree(container_of(ref, struct ipmi_user, refcount));
}
void cleanup_srcu_struct(struct srcu_struct* sp) {
    synchronize_srcu(sp);
}
void _ipmi_destroy_user(struct ipmi_user* user) {
    // implementation goes here
    kfree(user);
}
int ipmi_destroy_user(struct ipmi_user* user) {
    _ipmi_destroy_user(user);
    int err = cleanup_srcu_struct(&user->release_barrier);
    if (err != 0) {
        return err;
    }
    err = kref_put(&user->refcount, free_user);
    if (err != 0) {
        return -EINVAL;
    }
    return 0;
}
--------------------
#include <linux/kref.h>
#include <linux/srcu.h>
void free_user(struct kref* ref) {
    kfree(container_of(ref, struct ipmi_user, refcount));
}
void cleanup_srcu_struct(struct srcu_struct* sp) {
    synchronize_srcu(sp);
}
void _ipmi_destroy_user(struct ipmi_user* user) {
    // implementation goes here
    kfree(user);
}
int ipmi_destroy_user(struct ipmi_user* user) {
    _ipmi_destroy_user(user);
    int err = cleanup_srcu_struct(&user->release_barrier);
    if (err != 0) {
        return err;
    }
    err = kref_put(&user->refcount, free_user);
    if (err != 0) {
        return -EINVAL;
    }
    return 0;
}
--------------------
void initialize_user(struct ipmi_user* user) {
    memset(user, 0, sizeof(struct ipmi_user));
    /* initialize other members as needed */
}
void free_user(struct kref* ref) {
    kfree(container_of(ref, struct ipmi_user, refcount));
}
void cleanup_srcu_struct(struct srcu_struct* sp) {
    synchronize_srcu(sp);
}
void _ipmi_destroy_user(struct ipmi_user* user) {
    // implementation goes here
    kfree(user);
}
int ipmi_destroy_user(struct ipmi_user* user) {
    _ipmi_destroy_user(user);
    int err = cleanup_srcu_struct(&user->release_barrier);
    if (err != 0) {
        return err;
    }
    err = kref_put(&user->refcount, free_user);
    if (err != 0) {
        return -EINVAL;
    }
    return 0;
}
--------------------
void _ipmi_destroy_user(struct ipmi_user* user) {
    if (user == NULL) {
        return;
    }
    /* add null checks for other pointers as needed */
    kfree(user);
}
void initialize_user(struct ipmi_user* user) {
    memset(user, 0, sizeof(struct ipmi_user));
    /* initialize other members as needed */
}
void free_user(struct kref* ref) {
    struct ipmi_user* user = container_of(ref, struct ipmi_user, refcount);
    if (user == NULL) {
        return;
    }
    /* add null checks for other pointers as needed */
    kfree(user);
}
void cleanup_srcu_struct(struct srcu_struct* sp) {
    synchronize_srcu(sp);
}
int ipmi_destroy_user(struct ipmi_user* user) {
    _ipmi_destroy_user(user);
    int err = cleanup_srcu_struct(&user->release_barrier);
    if (err != 0) {
        return err;
    }
    err = kref_put(&user->refcount, free_user);
    if (err != 0) {
        return -EINVAL;
    }
    return 0;
}
--------------------
match:0
source:
 int SWFInput_readSBits ( SWFInput input , int number ) { int num = SWFInput_readBits ( input , number ) ; <S2SV_StartBug> if ( num & ( 1 << ( number - 1 ) ) ) <S2SV_EndBug> return num - ( 1 << number ) ; else return num ; }


target:
int SWFInput_readSBits ( SWFInput input , int number ) { int num = SWFInput_readBits ( input , number ) ; if ( number && num & ( 1 << ( number - 1 ) ) ) return num - ( 1 << number ) ; else return num ; }
outputs:
int SWFInput_readSBits(SWFInput input, int number) {
    int num = SWFInput_readBits(input, number);
    if (num & (1 << (number - 1))) {
        num |= ~((1 << number) - 1);
    }
    return num;
}
--------------------
int SWFInput_readSBits(SWFInput input, int number) {
    int num = SWFInput_readBits(input, number);
    if (num & (1 << (number - 1))) {
        num ^= (1 << number) - 1;
        num = -num - 1;
    }
    return num;
}
--------------------
int SWFInput_readSBits(SWFInput input, int number) {
    int num = SWFInput_readBits(input, number);
    if (num & (1 << (number - 1))) {
        num |= -1 << number;
    }
    return num;
}
--------------------
int SWFInput_readSBits(SWFInput input, int number) {
    int num = SWFInput_readBits(input, number);
    if (num & (1 << (number - 1))) {
        num = num - (1 << number) + 1;
    }
    return num;
}
--------------------
int SWFInput_readSBits(SWFInput input, int number) {
    int num = SWFInput_readBits(input, number);
    if (num & (1 << (number - 1))) {
        num = (-1 << number) | num;
    }
    return num;
}
--------------------
int SWFInput_readSBits(SWFInput input, int number) {
    int num = SWFInput_readBits(input, number);
    int signBit = num & (1 << (number - 1));
    if (signBit) {
        num ^= (1 << number) - 1;
        num = -num - 1;
    }
    return num;
}
--------------------
int SWFInput_readSBits(SWFInput input, int number) {
    int num = SWFInput_readBits(input, number);
    int signBit = num & (1 << (number - 1));
    if (signBit) {
        num |= ((1 << number) - 1) << 1;
        num = -num - 1;
    }
    return num;
}
--------------------
int SWFInput_readSBits(SWFInput input, int number) {
    int num = SWFInput_readBits(input, number);
    int signBit = num & (1 << (number - 1));
    if (signBit) {
        num = (~num) + 1;
    }
    return num;
}
--------------------
int SWFInput_readSBits(SWFInput input, int number) {
    int num = SWFInput_readBits(input, number);
    int signBit = num & (1 << (number - 1));
    if (signBit) {
        num = (1 << number) - num;
        num = -num;
    }
    return num;
}
--------------------
int SWFInput_readSBits(SWFInput input, int number) {
    int num = SWFInput_readBits(input, number);
    int signBit = num & (1 << (number - 1));
    if (signBit) {
        num &= (1 << (number - 1)) - 1;
        num = -num;
    }
    return num;
}
--------------------
match:0
source:
int scsi_cmd_blk_ioctl ( struct block_device * bd , fmode_t mode , unsigned int cmd , void __user * arg ) { <S2SV_StartBug> return scsi_cmd_ioctl ( bd -> bd_disk -> queue , bd -> bd_disk , mode , cmd , arg ) ; <S2SV_EndBug> }

target:
int scsi_cmd_blk_ioctl ( struct block_device * bd , fmode_t mode , unsigned int cmd , void __user * arg ) { int ret ; ret = scsi_verify_blk_ioctl ( bd , cmd ) ; if ( ret < 0 ) return ret ; return scsi_cmd_ioctl ( bd -> bd_disk -> queue , bd -> bd_disk , mode , cmd , arg ) ; }

outputs:
int scsi_cmd_blk_ioctl ( struct block_device * bd , fmode_t mode , unsigned int cmd , void __user * arg ) {
  int result;
  struct request_queue *q = bdev_get_queue(bd);
  if (!q)
    return -ENODEV;
  result = scsi_cmd_ioctl (q , bd -> bd_disk , mode , cmd , arg ) ;
  return result;
}
--------------------
int scsi_cmd_blk_ioctl ( struct block_device * bd , fmode_t mode , unsigned int cmd , void __user * arg ) {
  int result;
  struct request_queue *q = blk_get_queue(bd);
  if (!q)
    return -ENODEV;
  result = scsi_cmd_ioctl(q, bd->bd_disk, mode, cmd, arg);
  blk_put_queue(q);
  return result;
}
--------------------
int scsi_cmd_blk_ioctl ( struct block_device * bd , fmode_t mode , unsigned int cmd , void __user * arg ) {
  struct request_queue *q = bd->bd_disk->queue;
  if (!q)
    return -ENODEV;
  return scsi_cmd_ioctl(q, bd->bd_disk, mode, cmd, arg) ;
}
--------------------
int scsi_cmd_blk_ioctl ( struct block_device * bd , fmode_t mode , unsigned int cmd , void __user * arg ) {
  int result;
  struct request_queue *q = NULL;
  if (bd) q = bd -> bd_disk -> queue;
  if (!q) return -ENODEV;
  result = scsi_cmd_ioctl (q , bd -> bd_disk , mode , cmd , arg ) ;
  return result;
}
--------------------
int scsi_cmd_blk_ioctl ( struct block_device * bd , fmode_t mode , unsigned int cmd , void __user * arg ) {
  int result;
  struct request_queue *q = bd->bd_disk->queue;
  if (!q)
    return -ENODEV;
  blk_revalidate_disk(bd->bd_disk);
  result = scsi_cmd_ioctl(q, bd->bd_disk, mode, cmd, arg);
  return result;
}
--------------------
int scsi_cmd_blk_ioctl ( struct block_device * bd , fmode_t mode , unsigned int cmd , void __user * arg ) {
  struct gendisk *disk = bd->bd_disk;
  struct request_queue *q = disk->queue;

  if (!disk->fops->ioctl)
    return -ENOTTY;
  if (!q)
    return -ENODEV;

  return blkdev_ioctl(bd, mode, cmd, arg);
}
--------------------
int scsi_cmd_blk_ioctl ( struct block_device * bd , fmode_t mode , unsigned int cmd , void __user * arg ) {
  int result;
  struct request_queue *q = bd->bd_disk->queue;
  if (!q) {
    return -ENODEV;
  }

  if (!bd->bd_disk->fops->ioctl) {
    return -ENOTTY;
  }
  result = scsi_cmd_ioctl(q, bd->bd_disk, mode, cmd, arg) ;
  return result;
}
--------------------
int scsi_cmd_blk_ioctl ( struct block_device * bd , fmode_t mode , unsigned int cmd , void __user * arg ) {
  int result;
  struct request_queue *q = NULL;
  struct gendisk *disk = bd->bd_disk;
  if (disk && bd && disk->queue) {
    q = disk->queue;
    blkdev_get(bd);
    result = scsi_cmd_ioctl(q, bd->bd_disk, mode, cmd, arg);
    blkdev_put(bd);
  }
  if (!q) return -ENODEV;
  return result;
}
--------------------
int scsi_cmd_blk_ioctl ( struct block_device * bd , fmode_t mode , unsigned int cmd , void __user * arg ) {
  int result = 0;
  struct request_queue *q = bd->bd_disk->queue;
  if (q) {
    result = blkdev_ioctl(bd, mode, cmd, arg);
  } else {
    result = -ENODEV;
  }
  return result;
}
--------------------
int scsi_cmd_blk_ioctl ( struct block_device * bd , fmode_t mode , unsigned int cmd , void __user * arg ) {
  struct request_queue *q = bd->bd_disk->queue;
  if (!q)
    return -ENODEV;
  return blkdev_ioctl(bd, mode, cmd, arg);
}
--------------------
match:0
source:
 int sas_discover_end_dev ( struct domain_device * dev ) { int res ; res = sas_notify_lldd_dev_found ( dev ) ; if ( res ) return res ; <S2SV_StartBug> sas_discover_event ( dev -> port , DISCE_PROBE ) ; <S2SV_EndBug> return 0 ; }


target:
int sas_discover_end_dev ( struct domain_device * dev ) { int res ; res = sas_notify_lldd_dev_found ( dev ) ; if ( res ) return res ; return 0 ; }
outputs:
int sas_discover_end_dev ( struct domain_device * dev ) { 
    int res ; 
    res = sas_notify_lldd_dev_found ( dev ) ; 
    if ( res ) {
        printk(KERN_ERR "Failed to notify lldd device found.\n");
        return res ; 
    }
    sas_discover_event ( dev -> port , DISCE_PROBE ) ; 
    return 0 ; 
}
--------------------
int sas_discover_end_dev ( struct domain_device * dev ) { 
    int res ; 
    res = sas_notify_lldd_dev_found ( dev ) ; 
    switch (res) {
        case NOTIFY_OK:
            sas_discover_event ( dev -> port , DISCE_PROBE ) ; 
            return 0 ; 
        case NOTIFY_DEV_NOADD:
            printk(KERN_ERR "Failed to add device.\n");
            return -EINVAL;
        case NOTIFY_TRANSPORT_ERROR:
            printk(KERN_ERR "Failed to send notification.\n");
            return -EAGAIN;
        default:
            printk(KERN_ERR "Unknown error.\n");
            return -EFAULT;
    }
}
--------------------
int sas_discover_end_dev ( struct domain_device * dev ) { 
    int res ; 
    if (!dev) {
        printk(KERN_ERR "Invalid argument: dev is null.\n");
        return -EINVAL;
    }
    res = sas_notify_lldd_dev_found ( dev ) ; 
    switch (res) {
        case NOTIFY_OK:
            sas_discover_event ( dev -> port , DISCE_PROBE ) ; 
            return 0 ; 
        case NOTIFY_DEV_NOADD:
            printk(KERN_ERR "Failed to add device.\n");
            return -EINVAL;
        case NOTIFY_TRANSPORT_ERROR:
            printk(KERN_ERR "Failed to send notification.\n");
            return -EAGAIN;
        default:
            printk(KERN_ERR "Unknown error.\n");
            return -EFAULT;
    }
}
--------------------
int sas_discover_end_dev ( struct domain_device * dev ) { 
    int res ; 
    if (!dev) {
        printk(KERN_ERR "Invalid argument: dev is null.\n");
        return -EINVAL;
    }
    res = sas_notify_lldd_dev_found ( dev ) ; 
    switch (res) {
        case NOTIFY_OK:
            sas_discover_event ( dev -> port , DISCE_PROBE ) ; 
            return 0 ; 
        case NOTIFY_DEV_NOADD:
            printk(KERN_ERR "Failed to add device: device already exists.\n");
            return -EINVAL;
        case NOTIFY_TRANSPORT_ERROR:
            printk(KERN_ERR "Failed to send notification: transport error.\n");
            return -EAGAIN;
        default:
            printk(KERN_ERR "Unknown error.\n");
            return -EFAULT;
    }
}
--------------------
int sas_discover_end_dev ( struct domain_device * dev ) { 
    int res ; 
    if (!dev) {
        printk(KERN_ERR "Invalid argument: dev is null.\n");
        return -EINVAL;
    }
    res = sas_notify_lldd_dev_found ( dev ) ; 
    if (res < 0) {
        return res;
    }
    sas_discover_event ( dev -> port , DISCE_PROBE ) ; 
    return 0 ; 
}
--------------------
int sas_discover_end_dev ( struct domain_device * dev ) { 
    int res ; 
    if (!dev) {
        printk(KERN_ERR "Invalid argument: dev is null.\n");
        return -EINVAL;
    }
    if (!dev->port) {
        printk(KERN_ERR "Invalid argument: dev->port is null.\n");
        return -EINVAL;
    }
    res = sas_notify_lldd_dev_found ( dev ) ; 
    if (res < 0) {
        return res;
    }
    sas_discover_event ( dev -> port , DISCE_PROBE ) ; 
    return 0 ; 
}
--------------------
int sas_notify_dev_found(struct domain_device *dev) {
    int res ; 
    if (!dev) {
        printk(KERN_ERR "Invalid argument: dev is null.\n");
        return -EINVAL;
    }
    res = sas_notify_lldd_dev_found ( dev ) ; 
    if (res < 0) {
        return res;
    }
    return 0;
}

int sas_discover_end_dev ( struct domain_device * dev ) { 
    int res ; 
    if (!dev) {
        printk(KERN_ERR "Invalid argument: dev is null.\n");
        return -EINVAL;
    }
    if (!dev->port) {
        printk(KERN_ERR "Invalid argument: dev->port is null.\n");
        return -EINVAL;
    }
    res = sas_notify_dev_found(dev);
    if (res < 0) {
        return res;
    }
    sas_discover_event ( dev -> port , DISCE_PROBE ) ; 
    return 0 ; 
}
--------------------
int sas_notify_and_discover(struct domain_device *dev) {
    int res ; 
    if (!dev) {
        printk(KERN_ERR "Invalid argument: dev is null.\n");
        return -EINVAL;
    }
    if (!dev->port) {
        printk(KERN_ERR "Invalid argument: dev->port is null.\n");
        return -EINVAL;
    }
    res = sas_notify_dev_found(dev);
    if (res < 0) {
        return res;
    }
    sas_discover_event ( dev -> port , DISCE_PROBE ) ; 
    return 0 ; 
}
--------------------
int sas_notify_and_discover(struct domain_device *dev, int event_type) {
    int res ; 
    if (!dev) {
        printk(KERN_ERR "Invalid argument: dev is null.\n");
        return -EINVAL;
    }
    if (!dev->port) {
        printk(KERN_ERR "Invalid argument: dev->port is null.\n");
        return -EINVAL;
    }
    res = sas_notify_dev_found(dev);
    if (res < 0) {
        return res;
    }
    sas_discover_event ( dev -> port , event_type ) ; 
    return 0 ; 
}
--------------------
#define DISCE_PROBE 0
#define DISCE_REVALIDATE 1
#define DISCE_TUR_HOST 6

int sas_notify_and_discover(struct domain_device *dev, int event_type) {
    int res ; 
    if (!dev) {
        printk(KERN_ERR "Invalid argument: dev is null.\n");
        return -EINVAL;
    }
    if (!dev->port) {
        printk(KERN_ERR "Invalid argument: dev->port is null.\n");
        return -EINVAL;
    }
    res = sas_notify_dev_found(dev);
    if (res < 0) {
        return res;
    }
    sas_discover_event ( dev -> port , event_type ) ; 
    return 0 ; 
}
--------------------
match:0
source:
 void user_describe ( const struct key * key , struct seq_file * m ) { seq_puts ( m , key -> description ) ; <S2SV_StartBug> if ( key_is_instantiated ( key ) ) <S2SV_EndBug> seq_printf ( m , ":%u" , key -> datalen ) ; }


target:
void user_describe ( const struct key * key , struct seq_file * m ) { seq_puts ( m , key -> description ) ; if ( key_is_positive ( key ) ) seq_printf ( m , ":%u" , key -> datalen ) ; }
outputs:
void user_describe ( const struct key * key, struct seq_file * m ) { 
    seq_puts ( m , key->description ) ; 
    if ( key && key->datalen ) 
        seq_printf ( m , ":%u" , key->datalen ) ; 
}
--------------------
void user_describe ( const struct key * key, struct seq_file * m ) { 
    if (key && key->description) 
        seq_puts ( m , key->description ) ; 
    if ( key && key->datalen ) 
        seq_printf ( m , ":%u" , key->datalen ) ; 
}
--------------------
void user_describe ( const struct key * key, struct seq_file * m ) { 
    if (key && key->description) {
        seq_puts ( m , key->description ) ; 
        if ( key->datalen ) 
            seq_printf ( m , ":%u" , key->datalen ) ; 
    }
}
--------------------
void user_describe ( const struct key * key, struct seq_file * m ) { 
    if (key && key->description) {
        seq_puts ( m , key->description ) ; 
        if ( key->datalen && key_is_instantiated(key) ) 
            seq_printf ( m , ":%u" , key->datalen ) ; 
    }
}
--------------------
#define IS_INVALID_KEY(k) (!k || !(k->description) || !(k->datalen))

void user_describe ( const struct key * key, struct seq_file * m ) { 
    if (IS_INVALID_KEY(key)) 
        return;
    seq_puts ( m , key->description ) ; 
    if ( key_is_instantiated(key) && key->datalen ) 
        seq_printf ( m , ":%u" , key->datalen ) ; 
}
--------------------
void user_describe ( const struct key * key, struct seq_file * m ) { 
    if (!key || !key->description) 
        return;
    seq_puts ( m , key->description ) ; 
    if ( key->datalen && key_is_instantiated(key) ) 
        seq_printf ( m , ":%u" , key->datalen ) ; 
}
--------------------
void user_describe ( const struct key * key, struct seq_file * m ) { 
    if (key == NULL || key->description == NULL) 
        return;
    seq_puts ( m , key->description ) ; 
    if ( key_is_instantiated(key) && key->datalen ) 
        seq_printf ( m , ":%u" , key->datalen ) ; 
}
--------------------
void user_describe ( const struct key * key, struct seq_file * m ) { 
    if (key == NULL || key->description == NULL) 
        return;
    seq_puts(m, key->description);
    if (key->datalen && key_is_instantiated(key)) 
        seq_printf(m," (datalen: %lu)",key->datalen); 
}
--------------------
void user_describe ( const struct key * key, struct seq_file * m ) { 
    if (key && key->description) { 
        seq_puts(m, key->description); 
        if (key->datalen && key_is_instantiated(key)) 
            seq_printf(m, " datalen=%u", key->datalen); 
    } 
}
--------------------
void user_describe ( const struct key * key, struct seq_file * m ) { 
    if (key && key->description) { 
        seq_puts(m, key->description);
        if (key_is_instantiated(key)) {
            seq_printf(m, " datalen=%u", key->datalen); 
        } else {
            seq_puts(m, " (not instantiated)"); 
        }
    } 
}
--------------------
match:0
source:
 <S2SV_StartBug> void ntlm_write_message_header ( wStream * s , NTLM_MESSAGE_HEADER * header ) <S2SV_EndBug> { Stream_Write ( s , header -> Signature , sizeof ( NTLM_SIGNATURE ) ) ; Stream_Write_UINT32 ( s , header -> MessageType ) ; }


target:
static void ntlm_write_message_header ( wStream * s , NTLM_MESSAGE_HEADER * header ) { Stream_Write ( s , header -> Signature , sizeof ( NTLM_SIGNATURE ) ) ; Stream_Write_UINT32 ( s , header -> MessageType ) ; }
outputs:
void ntlm_write_message_header (wStream *s, NTLM_MESSAGE_HEADER *header) {
    if (!s) {
        return;
    }
    Stream_Write(s, header->Signature, sizeof(NTLM_SIGNATURE));
    Stream_Write_UINT32(s, header->MessageType);
}
--------------------
void ntlm_write_message_header (wStream *s, NTLM_MESSAGE_HEADER *header) {
   if (s == NULL) {
        return;
   }
   memcpy(Stream_Pointer(s), header->Signature, sizeof(NTLM_SIGNATURE)); Stream_Seek(s, sizeof(NTLM_SIGNATURE));
   Stream_Write_UINT32(s, header->MessageType);
}
--------------------
void ntlm_write_message_header (wStream *s, NTLM_MESSAGE_HEADER *header) {
    if (!s || !header) {
        return;
    }
    Stream_Write(s, header->Signature, sizeof(NTLM_SIGNATURE));
    Stream_Write_UINT32(s, header->MessageType);
}
--------------------
void ntlm_write_message_header (wStream *s, NTLM_MESSAGE_HEADER *header) {
    if (!s || !header) {
        return;
    }
    if (Stream_Write(s, header->Signature, sizeof(NTLM_SIGNATURE)) != sizeof(NTLM_SIGNATURE)) {
        return;
    }
    Stream_Write_UINT32(s, header->MessageType);
}
--------------------
void ntlm_write_message_header (wStream *s, NTLM_MESSAGE_HEADER *header) {
     if (!s || !header) {
        return;
    }
    Stream_Write(s, (BYTE*) header->Signature, sizeof(NTLM_SIGNATURE));
    Stream_Write_UINT32(s, header->MessageType);
}
--------------------
void ntlm_write_message_header (wStream *s, NTLM_MESSAGE_HEADER *header) {
    if (!s || !header) {
        return;
    }
    memcpy(Stream_Pointer(s), header->Signature, sizeof(NTLM_SIGNATURE));
    Stream_Seek(s, sizeof(NTLM_SIGNATURE));
    Stream_Write_UINT32(s, header->MessageType);
}
--------------------
void ntlm_write_message_header (wStream *s, NTLM_MESSAGE_HEADER *header) {
    if (!s || !header) {
        return;
    }
    size_t sigLength = sizeof(NTLM_SIGNATURE);
    if (Stream_GetPosition(s) + sigLength < Stream_GetPosition(s)) {
        return; 
    }
    if (Stream_Write(s, header->Signature, sigLength) != sigLength) {
        return;
    }
    Stream_Write_UINT32(s, header->MessageType);
}
--------------------
void ntlm_write_message_header (wStream *s, NTLM_MESSAGE_HEADER *header) {
    if (!s || !header) {
        return;
    }
    const size_t sigLength = 16;
    if (Stream_GetPosition(s) + sigLength < Stream_GetPosition(s)) {
        return;
    }
    if (Stream_Write(s, header->Signature, sigLength) != sigLength) {
        return;
    }
    Stream_Write_UINT32(s, header->MessageType);
}
--------------------
void ntlm_write_message_header (wStream *s, NTLM_MESSAGE_HEADER *header) {
    if (!s || !header) {
        return; 
    }
    const size_t sigLength = sizeof(NTLM_SIGNATURE);
    if (Stream_GetPosition(s) + sigLength < Stream_GetPosition(s)) {
        return;
    }
    if (sigLength > sizeof(header->Signature)) {
        return;
    }
    char signature[sigLength];
    memcpy(signature, header->Signature, sigLength);
    if (Stream_Write(s, signature, sigLength) != sigLength) {
        return;
    }
    Stream_Write_UINT32(s, header->MessageType);
}
--------------------
void ntlm_write_message_header (wStream *s, NTLM_MESSAGE_HEADER *header) {
    if (!s || !header) {
        return;
    }
    const size_t sigLength = sizeof(NTLM_SIGNATURE);
    if (Stream_GetPosition(s) + sigLength < Stream_GetPosition(s)) {
        return;
    }
    if (sigLength > sizeof(header->Signature)) {
        return;
    }
    char signature[sigLength];
    memcpy(signature, header->Signature, sigLength);
    if (Stream_Write(s, signature, sigLength) != sigLength) {
        return;
    }
    if (header->MessageType != MESSAGE_TYPE_UNKNOWN && header->MessageType <= MESSAGE_TYPE_MESSAGE_3) {
        Stream_Write_UINT32(s, header->MessageType);
    }
}
--------------------
match:0
source:
 <S2SV_StartBug> static const SvcInternal * get_const_svc_internal ( const SvcContext * svc_ctx ) { <S2SV_EndBug> if ( svc_ctx == NULL ) return NULL ; <S2SV_StartBug> return ( const SvcInternal * ) svc_ctx -> internal ; <S2SV_EndBug> }


target:
static const SvcInternal_t * get_const_svc_internal ( const SvcContext * svc_ctx ) { if ( svc_ctx == NULL ) return NULL ; return ( const SvcInternal_t * ) svc_ctx -> internal ; }
outputs:
static const SvcInternal * get_const_svc_internal ( const SvcContext * svc_ctx ) {
    if (svc_ctx == NULL) {
        return NULL;
    }
    return (const SvcInternal *) svc_ctx -> internal;
}
--------------------
static const SvcInternal * get_const_svc_internal ( const SvcContext * svc_ctx ) {
    if (svc_ctx == NULL) {
        return NULL;
    } else {
        return (const SvcInternal *) svc_ctx -> internal;
    }
}
--------------------
static const SvcInternal * get_const_svc_internal ( const SvcContext * svc_ctx ) {
    return (svc_ctx == NULL) ? NULL : (const SvcInternal *) svc_ctx -> internal;
}
--------------------
static const SvcInternal * get_const_svc_internal ( const SvcContext * svc_ctx ) {
    if (svc_ctx != NULL) {
        return (const SvcInternal *) svc_ctx -> internal;
    } else {
        return NULL;
    }
}
--------------------
static const SvcInternal * get_const_svc_internal ( const SvcContext * svc_ctx ) {
    if (!svc_ctx) {
        return NULL;
    }
    return (const SvcInternal *) svc_ctx -> internal;
}
--------------------
static const SvcInternal * get_const_svc_internal ( const SvcContext * svc_ctx ) {
    if (svc_ctx == NULL) {
        return NULL;
    }
    const SvcInternal * const_svc_int = (const SvcInternal *) svc_ctx -> internal;
    return const_svc_int;
}
--------------------
static const SvcInternal * get_const_svc_internal ( const SvcContext * svc_ctx ) {
    const SvcInternal * const_svc_int = NULL;
    if (svc_ctx != NULL) {
        const_svc_int = (const SvcInternal *) svc_ctx -> internal;
    }
    return const_svc_int;
}
--------------------
static const SvcInternal * get_const_svc_internal ( const SvcContext * svc_ctx ) {
    const SvcInternal * const_svc_int = NULL;
    if (svc_ctx != NULL) {
        const_svc_int = (const SvcInternal *) svc_ctx -> internal;
    } else {
        const_svc_int = NULL;
    }
    return const_svc_int;
}
--------------------
static const SvcInternal * get_const_svc_internal ( const SvcContext * svc_ctx ) {
    if (svc_ctx == NULL) {
        return NULL;
    }
    const SvcInternal * const_svc_int = (const SvcInternal *) svc_ctx -> internal;
    return const_svc_int;
}
--------------------
static const SvcInternal * get_const_svc_internal ( const SvcContext * svc_ctx ) {
    if (svc_ctx == NULL) {
        return NULL;
    } else {
        const SvcInternal * const_svc_int = (const SvcInternal *) svc_ctx -> internal;
        return const_svc_int;
    }
}
--------------------
match:0
source:
 void free_bprm ( struct linux_binprm * bprm ) { free_arg_pages ( bprm ) ; if ( bprm -> cred ) { mutex_unlock ( & current -> signal -> cred_guard_mutex ) ; abort_creds ( bprm -> cred ) ; } <S2SV_StartBug> kfree ( bprm ) ; <S2SV_EndBug> }


target:
void free_bprm ( struct linux_binprm * bprm ) { free_arg_pages ( bprm ) ; if ( bprm -> cred ) { mutex_unlock ( & current -> signal -> cred_guard_mutex ) ; abort_creds ( bprm -> cred ) ; } if ( bprm -> interp != bprm -> filename ) kfree ( bprm -> interp ) ; kfree ( bprm ) ; }
outputs:
match:0
source:
 <S2SV_StartBug> void usage_exit ( ) { <S2SV_EndBug> fprintf ( stderr , "Usage:%s<codec><width><height><infile><outfile>\\n" , exec_name ) ; exit ( EXIT_FAILURE ) ; }


target:
void usage_exit ( void ) { fprintf ( stderr , "Usage:%s<codec><width><height><infile><outfile>\\n" , exec_name ) ; exit ( EXIT_FAILURE ) ; }
outputs:
void usage_exit ( ) {
    if (exec_name == NULL) {
        fprintf(stderr, "Error: exec_name is NULL\n");
        exit(EXIT_FAILURE);
    }
    fprintf(stderr , "Usage: %s <codec> <width> <height> <infile> <outfile>\n" , exec_name ) ;
    exit ( EXIT_FAILURE ) ;
}
--------------------
void usage_exit ( ) {
    if (exec_name == NULL) {
        fprintf(stderr, "Error: exec_name is NULL\n");
        exit(EXIT_FAILURE);
    }
    fprintf(stderr , "Usage: %s <codec> <width> <height> <infile> <outfile>\n" , exec_name ) ;
    exit ( EXIT_FAILURE ) ;
    return;
}
--------------------
void usage_exit ( ) {
    if (exec_name == NULL) {
        fprintf(stderr, "Error: exec_name is NULL\n");
        exit(EXIT_FAILURE);
    }
    fprintf(stderr , "Usage: %s <codec> <width> <height> <infile> <outfile>\n" , exec_name ) ;
    exit ( EXIT_FAILURE ) ;
    return;
}
--------------------
void usage_exit ( ) {
    if (exec_name == NULL) {
        fprintf(stderr, "Error: exec_name is NULL\n");
        exit(EXIT_FAILURE);
    }
    const char* fmt = "Usage: %s <codec> <width> <height> <infile> <outfile>\n";
    const int fmt_len = strlen(fmt);
    fprintf(stderr , fmt, exec_name ) ;
    exit ( EXIT_FAILURE ) ;
    return;
}
--------------------
void usage_exit ( ) {
    if (exec_name == NULL) {
        fprintf(stderr, "Error: exec_name is NULL\n");
        exit(EXIT_FAILURE);
    }
    fprintf(stderr , "Usage: %s <codec> <width> <height> <infile> <outfile>\n", exec_name ) ;
    exit ( EXIT_FAILURE ) ;
    return;
}
--------------------
void usage_exit ( int argc ) {
    if (exec_name == NULL) {
        fprintf(stderr, "Error: exec_name is NULL\n");
        exit(EXIT_FAILURE);
    }
    switch (argc) {
        case 1:
            fprintf(stderr, "Not enough arguments.\n");
            break;
        case 2:
            fprintf(stderr , "Missing arguments.\n" ) ;
            break;
        default:
            fprintf(stderr , "Usage: %s <codec> <width> <height> <infile> <outfile>\n" , exec_name ) ;
            break;
    }
    exit(EXIT_FAILURE);
    return;
}
--------------------
void usage_exit ( const char* fmt, ... ) {
    if (exec_name == NULL) {
        fprintf(stderr, "Error: exec_name is NULL\n");
        exit(EXIT_FAILURE);
    }
    va_list args;
    va_start(args, fmt);
    vfprintf(stderr, fmt, args);
    va_end(args);
    exit(EXIT_FAILURE);
    return;
}
--------------------
const char* program_name;

void set_program_name(const char* name) {
    program_name = name;
}

void usage_exit () {
    if (program_name == NULL) {
        fprintf(stderr, "Error: program_name is NULL\n");
        exit(EXIT_FAILURE);
    }
    fprintf(stderr , "Usage: %s <codec> <width> <height> <infile> <outfile>\n" , program_name ) ;
    exit(EXIT_FAILURE);
    return;
}
--------------------
#define PROGRAM_NAME "my_program"

void usage_exit () {
    fprintf(stderr , "Usage: %s <codec> <width> <height> <infile> <outfile>\n" , PROGRAM_NAME ) ;
    exit(EXIT_FAILURE);
}
--------------------
void usage_exit ( ) {
    if (exec_name == NULL) {
        fprintf(stderr, "Error: exec_name is NULL\n");
        exit(EXIT_FAILURE);
    }
    fprintf(stderr , "Usage: %s <codec> <width> <height> <infile> <outfile>\n", exec_name ) ;
    exit ( EXIT_FAILURE ) ;
    return;
}
--------------------
match:0
source:
 static RD_BOOL mcs_parse_domain_params ( STREAM s ) { <S2SV_StartBug> int length ; <S2SV_EndBug> <S2SV_StartBug> ber_parse_header ( s , MCS_TAG_DOMAIN_PARAMS , & length ) ; <S2SV_EndBug> in_uint8s ( s , length ) ; return s_check ( s ) ; }


target:
static RD_BOOL mcs_parse_domain_params ( STREAM s ) { uint32 length ; struct stream packet = * s ; ber_parse_header ( s , MCS_TAG_DOMAIN_PARAMS , & length ) ; if ( ! s_check_rem ( s , length ) ) { rdp_protocol_error ( "mcs_parse_domain_params(),consumedomainparamsfromstreamwouldoverrun" , & packet ) ; } in_uint8s ( s , length ) ; return s_check ( s ) ; }
outputs:
static RD_BOOL mcs_parse_domain_params ( STREAM s ) {
    uint32_t length; // Change the type from int to uint32_t

    ber_parse_header ( s , MCS_TAG_DOMAIN_PARAMS , & length ) ;
    in_uint8s ( s , length ) ;
    return s_check ( s ) ;
}
--------------------
static RD_BOOL mcs_parse_domain_params ( STREAM s ) {
    int length ;

    ber_parse_header ( s , MCS_TAG_DOMAIN_PARAMS , & length ) ;
    if (length < 0 || !s_check ( s )) { // Check the length and s_check before using them
        return FALSE;
    }
    in_uint8s ( s , length ) ;
    return s_check ( s ) ;
}
--------------------
static RD_BOOL mcs_parse_domain_params ( STREAM s ) {
    int length = MCS_DOMAIN_PARAMS_SIZE; // Define a fixed buffer size

    ber_parse_header ( s , MCS_TAG_DOMAIN_PARAMS , & length ) ;
    if (!s_check ( s )) {
        return FALSE;
    }
    in_uint8s ( s , length ) ;
    return s_check ( s ) ;
}
--------------------
static int mcs_parse_domain_params ( STREAM s ) {
    int length ;

    ber_parse_header ( s , MCS_TAG_DOMAIN_PARAMS , & length ) ;
    if (length < 0 || !s_check ( s )) { // Check the length and s_check before using them
        return MCS_PARSE_ERROR;
    }
    in_uint8s ( s , length ) ;
    return MCS_PARSE_OK;
}
--------------------
static RD_BOOL mcs_parse_domain_params ( STREAM s ) {
    int length ;

    ber_parse_header ( s , MCS_TAG_DOMAIN_PARAMS , & length ) ;
    if (!s_check ( s )) {
        return FALSE;
    }

    uint8_t data[length]; // Use a variable-length array based on the parsed length
    in_uint8a ( s , data, length ) ; // Use in_uint8a to read the array instead of in_uint8s
    
    return s_check ( s ) ;
}
--------------------
static RD_BOOL mcs_parse_domain_params ( STREAM s ) {
    int length ;
    uint8_t data[MCS_MAX_DOMAIN_PARAMS_SIZE]; // Define a fixed-size buffer

    ber_parse_header ( s , MCS_TAG_DOMAIN_PARAMS , & length ) ;
    if (!s_check ( s )) {
        return FALSE;
    }

    if (length > MCS_MAX_DOMAIN_PARAMS_SIZE) { // Check if the length exceeds the buffer size
        in_uint8s ( s , MCS_MAX_DOMAIN_PARAMS_SIZE ) ; // Ignore the excess data
    } else {
        in_uint8a ( s , data, length ) ; // Read the data into the buffer
    }
    
    return s_check ( s ) ;
}
--------------------
static RD_BOOL mcs_parse_domain_params ( STREAM s ) {
    int length ;
    uint8_t* data;

    ber_parse_header ( s , MCS_TAG_DOMAIN_PARAMS , & length ) ;
    if (!s_check ( s )) {
        return FALSE;
    }

    data = (uint8_t*) malloc(length); // Allocate memory dynamically based on the parsed length
    if (data == NULL) {
        return FALSE;
    }

    in_uint8a ( s , data, length ) ; // Read the data into the dynamically allocated buffer
    free(data); // Free the allocated memory
    
    return s_check ( s ) ;
}
--------------------
static RD_BOOL mcs_parse_domain_params ( STREAM s ) {
    int length ;
    uint8_t* data;

    ber_parse_header ( s , MCS_TAG_DOMAIN_PARAMS , & length ) ;
    if (!s_check ( s )) {
        return FALSE;
    }

    if (length > INT_MAX) { // Check if the length is too large
        return FALSE;
    }

    data = (uint8_t*) calloc(1, length); // Allocate memory safely
    if (data == NULL) {
        return FALSE;
    }

    if (!in_uint8a_safe(s, data, length)) { // Read the data safely
        free(data); // Free the allocated memory
        return FALSE;
    }
    
    free(data); // Free the allocated memory
    return s_check ( s ) ;
}
--------------------
static RD_BOOL mcs_parse_domain_params ( STREAM s ) {
    uint32_t length ;

    ber_parse_header ( s , MCS_TAG_DOMAIN_PARAMS , & length ) ; // Use uint32_t for length
    if (!s_check ( s )) {
        return FALSE;
    }

    in_uint8s ( s , (int) length ) ; // Cast the length to int before using it
    return s_check ( s ) ;
}
--------------------
static RD_BOOL mcs_parse_domain_params ( STREAM s ) {
    int length ;

    ber_parse_header ( s , MCS_TAG_DOMAIN_PARAMS ) ; // Remove the length parameter
    if (!s_check ( s )) {
        return FALSE;
    }

    length = ber_get_content_length(s); // Get the length from the parsed header
    in_uint8s ( s , length ) ; // Use the length to read the data
    return s_check ( s ) ;
}
--------------------
match:0
source:
 static void put_prev_task ( struct rq * rq , struct task_struct * prev ) { if ( prev -> se . on_rq ) update_rq_clock ( rq ) ; <S2SV_StartBug> rq -> skip_clock_update = 0 ; <S2SV_EndBug> prev -> sched_class -> put_prev_task ( rq , prev ) ; }


target:
static void put_prev_task ( struct rq * rq , struct task_struct * prev ) { if ( prev -> se . on_rq ) update_rq_clock ( rq ) ; prev -> sched_class -> put_prev_task ( rq , prev ) ; }
outputs:
static void put_prev_task(struct rq *rq, struct task_struct *prev) {
    if (prev->se.on_rq) {
        update_rq_clock(rq);
        rq->skip_clock_update = 0;
    }
    prev->sched_class->put_prev_task(rq, prev);
}
--------------------
static void put_prev_task(struct rq *rq, struct task_struct *prev) {
    if (prev != NULL && prev->se.on_rq != 0) {
        update_rq_clock(rq);
    }
    rq->skip_clock_update = 0;
    if (prev != NULL) {
        prev->sched_class->put_prev_task(rq, prev);
    }
}
--------------------
static void put_prev_task(struct rq *rq, struct task_struct *prev) {
    if (prev != NULL && prev->se.on_rq) {
        update_rq_clock(rq);
    }
    rq->skip_clock_update = 0;
    if (prev != NULL) {
        prev->sched_class->put_prev_task(rq, prev);
    }
}
--------------------
static void put_prev_task(struct rq *rq, struct task_struct *prev) {
    if (prev != NULL && prev->se.on_rq != 0) {
        update_rq_clock(rq);
    }
    rq->skip_clock_update = !prev || prev->se.on_rq == 0;
    if (prev != NULL) {
        prev->sched_class->put_prev_task(rq, prev);
    }
}
--------------------
static void put_prev_task(struct rq *rq, struct task_struct *prev) {
    if (prev != NULL && prev->se.on_rq) {
        update_rq_clock(rq);
    }
    if (rq != NULL) {
        rq->skip_clock_update = 0;
    }
    if (prev != NULL) {
        prev->sched_class->put_prev_task(rq, prev);
    }
}
--------------------
static void put_prev_task(struct rq *rq, struct task_struct *prev) {
    if (prev != NULL && prev->se.on_rq != 0) {
        update_rq_clock(rq);
    }
    if (rq != NULL) {
        rq->skip_clock_update = !prev || prev->se.on_rq == 0;
    }
    if (prev != NULL) {
        prev->sched_class->put_prev_task(rq, prev);
    }
}
--------------------
static void put_prev_task(struct rq *rq, struct task_struct *prev) {
    if (prev != NULL && prev->se.on_rq) {
        update_rq_clock(rq);
        rq->skip_clock_update = 0;
    } else {
        rq->skip_clock_update = 1;
    }
    if (prev != NULL) {
        prev->sched_class->put_prev_task(rq, prev);
    }
}
--------------------
static void put_prev_task(struct rq *rq, struct task_struct *prev) {
    if (rq != NULL && prev != NULL && prev->se.on_rq) {
        update_rq_clock(rq);
        rq->skip_clock_update = 0;
    }
    if (prev != NULL) {
        prev->sched_class->put_prev_task(rq, prev);
    }
}
--------------------
static void put_prev_task(struct rq *rq, struct task_struct *prev) {
    if (prev && prev->se.on_rq) {
        update_rq_clock(rq);
        rq->skip_clock_update = 0;
    } else {
        rq->skip_clock_update = 1;
    }
    if (prev) {
        prev->sched_class->put_prev_task(rq, prev);
    }
}
--------------------
static void put_prev_task(struct rq *rq, struct task_struct *prev) {
    if (prev && prev->se.on_rq) {
        update_rq_clock(rq);
        rq->skip_clock_update = 0;
    } else if (rq) {
        rq->skip_clock_update = 1;
    }
    if (prev) {
        prev->sched_class->put_prev_task(rq, prev);
    }
}
--------------------
match:0
source:
<S2SV_StartBug> void ntlm_populate_message_header ( NTLM_MESSAGE_HEADER * header , UINT32 MessageType ) <S2SV_EndBug> { CopyMemory ( header -> Signature , NTLM_SIGNATURE , sizeof ( NTLM_SIGNATURE ) ) ; header -> MessageType = MessageType ; }

target:
static void ntlm_populate_message_header ( NTLM_MESSAGE_HEADER * header , UINT32 MessageType ) { CopyMemory ( header -> Signature , NTLM_SIGNATURE , sizeof ( NTLM_SIGNATURE ) ) ; header -> MessageType = MessageType ; }

outputs:
void ntlm_populate_message_header ( NTLM_MESSAGE_HEADER * header , UINT32 MessageType ) {
    memcpy ( header -> Signature , NTLM_SIGNATURE , sizeof ( NTLM_SIGNATURE ) ) ;
    header -> MessageType = MessageType ;
}
--------------------
void ntlm_populate_message_header ( NTLM_MESSAGE_HEADER * header , UINT32 MessageType ) {
    std::memcpy ( header -> Signature , NTLM_SIGNATURE , sizeof ( NTLM_SIGNATURE ) ) ;
    header -> MessageType = MessageType ;
}
--------------------
void ntlm_populate_message_header ( NTLM_MESSAGE_HEADER * header , UINT32 MessageType ) {
    std::copy ( NTLM_SIGNATURE, NTLM_SIGNATURE + sizeof (NTLM_SIGNATURE), header -> Signature ) ;
    header -> MessageType = MessageType ;
}
--------------------
void ntlm_populate_message_header ( NTLM_MESSAGE_HEADER * header , UINT32 MessageType ) {
    for ( int i = 0; i < sizeof(header->Signature); ++i ) {
        header->Signature[ i ] = NTLM_SIGNATURE[ i ];
    }
    header -> MessageType = MessageType ;
}
--------------------
void ntlm_populate_message_header ( NTLM_MESSAGE_HEADER * header , UINT32 MessageType ) {
    memcpy_s ( header -> Signature , sizeof(header ->Signature), NTLM_SIGNATURE , sizeof ( NTLM_SIGNATURE ) ) ;
    header -> MessageType = MessageType ;
}
--------------------
void ntlm_populate_message_header ( NTLM_MESSAGE_HEADER * header , UINT32 MessageType ) {
    std::memcpy_s ( header -> Signature , sizeof(header ->Signature), NTLM_SIGNATURE , sizeof ( NTLM_SIGNATURE ) ) ;
    header -> MessageType = MessageType ;
}
--------------------
void ntlm_populate_message_header ( NTLM_MESSAGE_HEADER * header , UINT32 MessageType ) {
    std::copy ( NTLM_SIGNATURE, NTLM_SIGNATURE + sizeof (NTLM_SIGNATURE), header -> Signature ) ;
    header -> MessageType = MessageType ;
}
--------------------
void ntlm_populate_message_header ( NTLM_MESSAGE_HEADER * header , UINT32 MessageType ) {
    for (size_t i = 0; i < sizeof(header -> Signature); ++i) {
        *(header -> Signature + i) = *(NTLM_SIGNATURE + i);
    }
    header -> MessageType = MessageType ;
}
--------------------
void ntlm_populate_message_header ( NTLM_MESSAGE_HEADER * header , UINT32 MessageType ) {
    for ( char & c : header->Signature ) {
        c = *(NTLM_SIGNATURE + (&c - header->Signature));
    }
    header -> MessageType = MessageType ;
}
--------------------
void ntlm_populate_message_header ( NTLM_MESSAGE_HEADER * header , UINT32 MessageType ) {
    std::transform( NTLM_SIGNATURE, NTLM_SIGNATURE + sizeof( NTLM_SIGNATURE ), header->Signature, header->Signature,
        []( unsigned char a, unsigned char b ) -> unsigned char { return a; } );
    header -> MessageType = MessageType ;
}
--------------------
match:0
source:
 char * my_asctime ( time_t t ) { struct tm * tm ; char * str ; int len ; <S2SV_StartBug> tm = localtime ( & t ) ; <S2SV_EndBug> str = g_strdup ( asctime ( tm ) ) ; len = strlen ( str ) ; if ( len > 0 ) str [ len - 1 ] = '\\0' ; return str ; }


target:
char * my_asctime ( time_t t ) { struct tm * tm ; char * str ; int len ; tm = localtime ( & t ) ; if ( tm == NULL ) return g_strdup ( "???" ) ; str = g_strdup ( asctime ( tm ) ) ; len = strlen ( str ) ; if ( len > 0 ) str [ len - 1 ] = '\\0' ; return str ; }
outputs:
char * my_asctime ( time_t t ) {
    struct tm tm;
    char * str;
    int len;
    if (localtime_r(&t, &tm) == NULL) {
        return NULL;
    }
    str = g_strdup ( asctime ( &tm ) );
    len = strlen ( str ) ;
    if ( len > 0 ) str [ len - 1 ] = '\0' ;
    return str ;
}
--------------------
char * my_asctime ( time_t t ) {
    struct tm * tm ;
    char * str ;
    int len ;
    tm = localtime ( &t ) ;
    if (tm == NULL) {
        return NULL;
    }
    str = g_strdup ( asctime_r ( tm, (char*)malloc(26) ) ) ;
    len = strlen ( str ) ;
    if ( len > 0 ) str [ len - 1 ] = '\0' ;
    return str ;
}
--------------------
char * my_asctime ( time_t t ) {
    struct tm * tm ;
    char str[26];
    int len ;
    tm = localtime ( &t ) ;
    if (tm == NULL) {
        return NULL;
    }
    strftime(str, sizeof(str), "%c", tm);
    len = strlen ( str ) ;
    if ( len > 0 ) str [ len - 1 ] = '\0' ;
    return g_strdup(str);
}
--------------------
char * my_asctime ( time_t t ) {
    struct tm * tm ;
    char str[26];
    int len ;
    tm = localtime ( &t ) ;
    if (tm == NULL) {
        return NULL;
    }
    if (snprintf(str, sizeof(str), "%s", asctime(tm)) < 0) {
        return NULL;
    }
    len = strlen ( str ) ;
    if ( len > 0 ) str [ len - 1 ] = '\0' ;
    return g_strdup(str);
}
--------------------
char * my_asctime ( time_t t ) {
    struct tm * tm ;
    char str[26];
    int len ;
    tm = localtime ( &t ) ;
    if (tm == NULL) {
        return NULL;
    }
    if (strftime(str, sizeof(str), "%c", tm) <= 0) {
        return NULL;
    }
    len = strlen ( str ) ;
    if ( len > 0 ) str [ len - 1 ] = '\0' ;
    return g_strdup(str);
}
--------------------
char * my_asctime ( time_t t ) {
    struct tm * tm ;
    char str[26];
    int len ;
    tm = localtime ( &t ) ;
    if (tm == NULL) {
        return NULL;
    }
    if (snprintf(str, sizeof(str), "%.24s", ctime(&t)) < 0) {
        return NULL;
    }
    len = strlen ( str ) ;
    if ( len > 0 ) str [ len - 1 ] = '\0' ;
    return g_strdup(str);
}
--------------------
char * my_asctime ( time_t t ) {
    struct tm * tm ;
    char * str ;
    int len ;
    tm = gmtime ( &t ) ;
    if (tm == NULL) {
        return NULL;
    }
    str = g_strdup ( asctime ( tm ) ) ;
    len = strlen ( str ) ;
    if ( len > 0 ) str [ len - 1 ] = '\0' ;
    return str ;
}
--------------------
char * my_asctime ( time_t t ) {
    struct tm * tm ;
    char * str ;
    int len ;
    tm = localtime ( &t ) ;
    if (tm == NULL) {
        return NULL;
    }
    str = g_malloc ( 26 ) ;
    if (str == NULL) {
        return NULL;
    }
    strncpy(str, asctime ( tm ), 25);
    str [ 24 ] = '\0' ;
    return str ;
}
--------------------
char * my_asctime ( time_t t ) {
    struct tm tm = {0};
    char * str ;
    int len ;
    if (localtime_r(&t, &tm) == NULL) {
        return NULL;
    }
    str = g_malloc ( 26 ) ;
    if (str == NULL) {
        return NULL;
    }
    strncpy(str, asctime ( &tm ), 25);
    str [ 24 ] = '\0' ;
    return str ;
}
--------------------
char * my_asctime ( time_t t ) {
    struct tm * tm ;
    char str[26];
    int len ;
#ifdef __STDC_LIB_EXT1__
    if (asctime_s(str, sizeof(str), localtime(&t)) != 0) {
        return NULL;
    }    
#else
    tm = localtime ( &t ) ;
    if (tm == NULL) {
        return NULL;
    }
    strncpy(str, asctime ( tm ), 25);
#endif
    len = strlen ( str ) ;
    if ( len > 0 ) str [ len - 1 ] = '\0' ;
    return g_strdup(str);
}
--------------------
match:0
source:
<S2SV_StartBug> static void pcrypt_free ( struct crypto_instance * inst ) <S2SV_EndBug> { <S2SV_StartBug> struct pcrypt_instance_ctx * ctx = crypto_instance_ctx ( inst ) ; <S2SV_EndBug> crypto_drop_aead ( & ctx -> spawn ) ; kfree ( inst ) ; }

target:
static void pcrypt_free ( struct aead_instance * inst ) { struct pcrypt_instance_ctx * ctx = aead_instance_ctx ( inst ) ; crypto_drop_aead ( & ctx -> spawn ) ; kfree ( inst ) ; }

outputs:
static void pcrypt_free ( struct crypto_instance * inst )
{
    struct pcrypt_instance_ctx * ctx = crypto_instance_ctx ( inst ) ;
    if (ctx != NULL) {
        crypto_drop_aead ( & ctx -> spawn ) ;
        kfree ( ctx ) ;
    }
    kfree ( inst ) ;
}
--------------------
static void pcrypt_free ( struct crypto_instance * inst )
{
    struct pcrypt_instance_ctx * ctx = crypto_instance_ctx ( inst ) ;
    if (inst != NULL) {
        crypto_drop_aead ( & ctx -> spawn ) ;
        kfree ( inst ) ;
    }
}
--------------------
static void pcrypt_free ( struct crypto_instance * inst )
{
    if (inst != NULL) {
        struct pcrypt_instance_ctx * ctx = crypto_instance_ctx ( inst ) ;
        crypto_drop_aead ( & ctx -> spawn ) ;
        kfree ( inst ) ;
    }
}
--------------------
static void pcrypt_free ( struct crypto_instance * inst )
{
    if (inst != NULL) {
        struct pcrypt_instance_ctx * ctx = crypto_instance_ctx ( inst ) ;
        crypto_drop_aead ( & ctx -> spawn ) ;
        kfree ( ctx ) ;
        kfree ( inst ) ;
    }
}
--------------------
static void pcrypt_free ( struct crypto_instance * inst )
{
    if (inst == NULL) {
        return;
    }
    struct pcrypt_instance_ctx * ctx = crypto_instance_ctx ( inst ) ;
    crypto_drop_aead ( & ctx -> spawn ) ;
    kfree ( inst ) ;
}
--------------------
static void pcrypt_free ( struct crypto_instance * inst )
{
    if (inst == NULL) {
        return;
    }
    struct pcrypt_instance_ctx * ctx = crypto_instance_ctx ( inst ) ;
    crypto_drop_aead ( & ctx -> spawn ) ;
    kfree ( ctx ) ;
    kfree ( inst ) ;
}
--------------------
static void pcrypt_free ( struct crypto_instance * inst )
{
    struct pcrypt_instance_ctx * ctx = crypto_instance_ctx ( inst ) ;
    if (inst != NULL) {
        crypto_drop_aead ( & ctx -> spawn ) ;
        kfree ( inst ) ;
    }
}
--------------------
static void pcrypt_free ( struct crypto_instance * inst )
{
    struct pcrypt_instance_ctx * ctx = crypto_instance_ctx ( inst ) ;
    if (inst != NULL) {
        crypto_drop_aead ( & ctx -> spawn ) ;
        kfree ( ctx ) ;
        kfree ( inst ) ;
    }
}
--------------------
static void pcrypt_free ( struct crypto_instance * inst )
{
    if (inst != NULL) {
        struct pcrypt_instance_ctx * ctx = crypto_instance_ctx ( inst ) ;
        if (ctx != NULL) {
            crypto_drop_aead ( & ctx -> spawn ) ;
            kfree ( ctx ) ;
        }
        kfree ( inst ) ;
    }
}
--------------------
static void pcrypt_free ( struct crypto_instance * inst )
{
    if (inst == NULL) {
        return ;
    }
    struct pcrypt_instance_ctx * ctx = crypto_instance_ctx ( inst ) ;
    if (ctx == NULL) {
        kfree ( inst ) ;
        return ;
    }
    crypto_drop_aead ( & ctx -> spawn ) ;
    kfree ( ctx ) ;
    kfree ( inst ) ;
}
--------------------
match:0
source:
cJSON * cJSON_GetArrayItem ( cJSON * array , int item ) { <S2SV_StartBug> cJSON * c = array -> child ; <S2SV_EndBug> <S2SV_StartBug> while ( c && item > 0 ) { <S2SV_EndBug> -- item ; c = c -> next ; <S2SV_StartBug> } <S2SV_EndBug> return c ; }

target:
cJSON * cJSON_GetArrayItem ( cJSON * array , int item ) { cJSON * c = array ? array -> child : 0 ; while ( c && item > 0 ) item -- , c = c -> next ; } return c ; }

outputs:
cJSON * cJSON_GetArrayItem(cJSON *array, int item) {
    cJSON *c = array->child;

    while (c && item >= 0) {
        if (item == 0) {
            return c;
        }

        item--;
        c = c->next;
    }

    return NULL;
}
--------------------
cJSON * cJSON_GetArrayItem(cJSON *array, int item) {
    cJSON *c = cJSON_GetArrayItem(array, 0);

    while (c && item > 0) {
        c = c->next;
        item--;
    }

    return c;
}
--------------------
cJSON * cJSON_GetArrayItem(cJSON *array, int item) {
    int i = 0;
    cJSON *c = array->child;

    while (c && i < item) {
        c = c->next;
        i++;
    }

    return c;
}
--------------------
cJSON * cJSON_GetArrayItem(cJSON *array, int item) {
    if (item < 0) {
        return NULL;
    }

    cJSON *c = array->child;

    while (c) {
        if (item == 0) {
            return c;
        }

        c = c->next;
        item--;
    }

    return NULL;
}
--------------------
cJSON * cJSON_GetArrayItem(cJSON *array, int item) {
    cJSON *c = array->child;

    for (int i = 0; i < item && c; i++, c = c->next);

    return c;
}
--------------------
cJSON * cJSON_GetArrayItem(cJSON *array, int item) {
    if (item < 0) {
        return NULL;
    }

    cJSON *c = array->child;

    for (int i = 0; i < item && c != NULL; i++) {
        c = c->next;
    }

    return c;
}
--------------------
cJSON * cJSON_GetArrayItem(cJSON *array, int item) {
    cJSON *c = array->child;

    while (item > 0 && c) {
        c = c->next;
        item--;
    }

    return item > 0 ? NULL : c;
}
--------------------
cJSON * cJSON_GetArrayItem(cJSON *array, int item) {
    cJSON *c = array->child;

    for (int i = 0; i < item && c != NULL; i++) {
        c = c->next;
    }

    return c;
}
--------------------
cJSON * cJSON_GetArrayItem(cJSON *array, int item) {
    int counter = 0;
    cJSON *c = array->child;

    while (c) {
        if (counter == item) {
            return c;
        }

        c = c->next;
        counter++;
    }

    return NULL;
}
--------------------
//对了，检测了array
cJSON * cJSON_GetArrayItem(cJSON *array, int item) {
    if (item < 0 || array == NULL) {
        return NULL;
    }

    cJSON *c = array->child;

    while (c && item > 0) {
        item--;
        c = c->next;
    }

    return c;
}
--------------------
match:0+1
source:
<S2SV_StartBug> static int decode_unsigned_max ( struct vp9_read_bit_buffer * rb , int max ) { <S2SV_EndBug> <S2SV_StartBug> const int data = vp9_rb_read_literal ( rb , get_unsigned_bits ( max ) ) ; <S2SV_EndBug> return data > max ? max : data ; }

target:
static int decode_unsigned_max ( struct vpx_read_bit_buffer * rb , int max ) { const int data = vpx_rb_read_literal ( rb , get_unsigned_bits ( max ) ) ; return data > max ? max : data ; }

outputs:
static int decode_unsigned_max(struct vp9_read_bit_buffer *rb, int max) {
  const int data = vp9_rb_read_literal(rb, get_unsigned_bits(max));
  return data > max ? max : data;
}

--------------------
static int decode_unsigned_max(struct vp9_read_bit_buffer *rb, int max) {
  const int data = vp9_rb_read_literal(rb, get_unsigned_bits(max));
  if (data > max) {
    return max;
  }
  return data;
}

--------------------
static int decode_unsigned_max(struct vp9_read_bit_buffer *rb, int max) {
  const int data = vp9_rb_read_literal(rb, get_unsigned_bits(max));
  if (data >= max) {
    return max;
  }
  return data;
}

--------------------
static int decode_unsigned_max(struct vp9_read_bit_buffer *rb, int max) {
  const int data = vp9_rb_read_literal(rb, get_unsigned_bits(max + 1)) - 1;
  return data > max ? max : data;
}

--------------------
static int decode_unsigned_max(struct vp9_read_bit_buffer *rb, int max) {
  const int data = vp9_rb_read_literal(rb, get_unsigned_bits(max + 1)) - 1;
  if (data > max) {
    return max;
  }
  return data;
}

--------------------
static int decode_unsigned_max(struct vp9_read_bit_buffer *rb, int max) {
  const int data = vp9_rb_read_literal(rb, get_unsigned_bits(max + 1)) - 1;
  if (data >= max) {
    return max;
  }
  return data;
}

--------------------
static int decode_unsigned_max(struct vp9_read_bit_buffer *rb, int max) {
  const int data = vp9_rb_read_literal(rb, get_unsigned_bits(max + 1)) & max;
  return data;
}

--------------------
static int decode_unsigned_max(struct vp9_read_bit_buffer *rb, int max) {
  const int data = vp9_rb_read_literal(rb, get_unsigned_bits(max + 1));
  if (data == max + 1) {
    return max;
  }
  return data;
}

--------------------
static int decode_unsigned_max(struct vp9_read_bit_buffer *rb, int max) {
  const int data = vp9_rb_read_literal(rb, get_unsigned_bits(max + 1));
  if (data > max) {
    return max;
  }
  return data;
}

--------------------
static int decode_unsigned_max(struct vp9_read_bit_buffer *rb, int max) {
  const int data = vp9_rb_read_literal(rb, get_unsigned_bits(max + 2)) - 2;
  if (data > max) {
    return max;
  }
  return data;
}

--------------------
match:0
source:
void __scm_destroy ( struct scm_cookie * scm ) { struct scm_fp_list * fpl = scm -> fp ; int i ; if ( fpl ) { scm -> fp = NULL ; for ( i = fpl -> count - 1 ; i >= 0 ; i -- ) fput ( fpl -> fp [ i ] ) ; <S2SV_StartBug> kfree ( fpl ) ; <S2SV_EndBug> } }

target:
void __scm_destroy ( struct scm_cookie * scm ) { struct scm_fp_list * fpl = scm -> fp ; int i ; if ( fpl ) { scm -> fp = NULL ; for ( i = fpl -> count - 1 ; i >= 0 ; i -- ) fput ( fpl -> fp [ i ] ) ; free_uid ( fpl -> user ) ; kfree ( fpl ) ; } }

outputs:
void __scm_destroy ( struct scm_cookie * scm ) {
    struct scm_fp_list * fpl = scm -> fp ;
    int i ;
    if ( fpl ) {
        scm -> fp = NULL ;
        for ( i = fpl -> count - 1 ; i >= 0 ; i -- )
            fput ( fpl -> fp [ i ] ) ;
        kfree ( fpl ) ;
    }
}
--------------------
void __scm_destroy ( struct scm_cookie * scm ) {
    struct scm_fp_list * fpl = scm -> fp ;
    int i ;
    if ( fpl ) {
        scm -> fp = NULL ;
        for ( i = fpl -> count - 1 ; i >= 0 ; i -- )
            fput ( fpl -> fp [ i ] ) ;
        fpl = NULL; // set fpl to NULL before freeing
        kfree ( fpl ) ;
    }
}
--------------------
void __scm_destroy ( struct scm_cookie * scm ) {
    struct scm_fp_list * fpl = scm -> fp ;
    int i ;
    if ( fpl ) {
        scm -> fp = NULL ;
        for ( i = fpl -> count - 1 ; i >= 0 ; i -- )
            fput ( fpl -> fp [ i ] ) ;
        fpl = kmalloc(sizeof(struct scm_fp_list), GFP_KERNEL); // allocate memory again
        kfree ( fpl ) ;
    }
}
--------------------
void __scm_destroy ( struct scm_cookie * scm ) {
    struct scm_fp_list * fpl = scm -> fp ;
    int i ;
    if ( fpl ) {
        scm -> fp = NULL ;
        for ( i = fpl -> count - 1 ; i >= 0 ; i -- )
            fput ( fpl -> fp [ i ] ) ;
        kfree ( scm->fp ) ; // free the fp pointer in scm
    }
}
--------------------
void __scm_destroy ( struct scm_cookie * scm ) {
    struct scm_fp_list * fpl = scm -> fp ;
    int i ;
    if ( fpl ) {
        scm -> fp = NULL ;
        for ( i = fpl -> count - 1 ; i >= 0 ; i -- )
            fput ( fpl -> fp [ i ] ) ;
        kfree ( fpl ) ;
        scm->fp = NULL; // set fp to NULL in scm
    }
}
--------------------
void __scm_destroy ( struct scm_cookie * scm ) {
    struct scm_fp_list * fpl = scm -> fp ;
    int i ;
    if ( fpl ) {
        scm -> fp = NULL ;
        for ( i = fpl -> count - 1 ; i >= 0 ; i -- )
            fput ( fpl -> fp [ i ] ) ;
        kfree ( fpl ) ;
        scm = NULL; // set scm to NULL
    }
}
--------------------
void __scm_destroy ( struct scm_cookie * scm ) {
    struct scm_fp_list * fpl = scm -> fp ;
    int i ;
    if ( fpl ) {
        scm -> fp = NULL ;
        for ( i = fpl -> count - 1 ; i >= 0 ; i -- )
            fput ( fpl -> fp [ i ] ) ;
        kfree ( fpl ) ;
    }
    fpl = NULL; // set fpl to NULL after freeing
}
--------------------
void __scm_destroy ( struct scm_cookie * scm ) {
    struct scm_fp_list * fpl = scm -> fp ;
    int i ;
    if ( fpl ) {
        for ( i = fpl -> count - 1 ; i >= 0 ; i -- ) // change loop to avoid setting fp pointer to NULL
            fput ( fpl -> fp [ i ] ) ;
        kfree ( fpl ) ;
        scm->fp = NULL;
    }
}
--------------------
void __scm_destroy ( struct scm_cookie * scm ) {
    struct scm_fp_list * fpl = scm -> fp ;
    if ( fpl ) {
        fpl->count = 0; // set count to 0 before freeing
        kfree ( fpl ) ;
        scm->fp = NULL;
    }
}
--------------------
void __scm_destroy ( struct scm_cookie * scm ) {
    struct scm_fp_list * fpl = scm -> fp ;
    int i ;
    if ( fpl ) {
        for ( i = fpl -> count - 1 ; i >= 0 ; i -- )
            fput ( fpl -> fp [ i ] ) ;
        kfree ( fpl ) ;
        scm->fp = NULL;
        fpl = NULL; // set fpl to NULL after freeing
    }
}
--------------------
match:0
source:
static unsigned int seedsize ( struct crypto_alg * alg ) { struct rng_alg * ralg = container_of ( alg , struct rng_alg , base ) ; <S2SV_StartBug> return alg -> cra_rng . rng_make_random ? <S2SV_EndBug> alg -> cra_rng . seedsize : ralg -> seedsize ; }

target:
static unsigned int seedsize ( struct crypto_alg * alg ) { struct rng_alg * ralg = container_of ( alg , struct rng_alg , base ) ; return ralg -> seedsize ; }

outputs:
//删掉错误行
static unsigned int seedsize(struct crypto_alg *alg) {
    struct rng_alg *ralg = container_of(alg, struct rng_alg, base);
    return ralg->seedsize;
}
--------------------
static unsigned int seedsize(struct crypto_alg *alg) {
    if (!alg->cra_rng.seedsize) {
        struct rng_alg *ralg = container_of(alg, struct rng_alg, base);
        return ralg->seedsize;
    }
    return alg->cra_rng.seedsize;
}
--------------------
static unsigned int seedsize(struct crypto_alg *alg) {
    struct rng_alg *ralg = container_of(alg, struct rng_alg, base);
    if (alg->cra_rng.rng_make_random) {
        // if rng_make_random exists, return its seedsize
        return alg->cra_rng.seedsize;
    }
    else {
        // otherwise, return the default seedsize for the alg
        return ralg->seedsize;
    }
}
--------------------
static unsigned int seedsize(struct crypto_alg *alg) {
    if (alg->cra_rng.rng_make_random) {
        // if rng_make_random exists, return its seedsize
        return alg->cra_rng.seedsize;
    }
    else {
        // otherwise, return the default seedsize for the alg
        struct rng_alg *ralg = container_of(alg, struct rng_alg, base);
        return ralg->seedsize;
    }
}
--------------------
static unsigned int seedsize(struct crypto_alg *alg) {
    struct rng_alg *ralg = container_of(alg, struct rng_alg, base);
    if (!alg->cra_rng.rng_make_random) {
        return ralg->seedsize;
    }
    return alg->cra_rng.seedsize;
}
--------------------
static unsigned int seedsize(struct crypto_alg *alg) {
    struct rng_alg *ralg = container_of(alg, struct rng_alg, base);
    if (alg->cra_rng.rng_make_random && alg->cra_rng.seedsize) {
        return alg->cra_rng.seedsize;
    }
    return ralg->seedsize;
}
--------------------
static unsigned int seedsize(struct crypto_alg *alg) {
    struct rng_alg *ralg = container_of(alg, struct rng_alg, base);
    if (alg->cra_rng.rng_make_random) {
        if (alg->cra_rng.seedsize) {
            // return the seedsize of the specific rng function
            return alg->cra_rng.seedsize;
        }
        else {
            // return the default if no specific seedsize is available
            return ralg->seedsize;
        }
    }
    else {
        return ralg->seedsize;
    }
}
--------------------
static unsigned int seedsize(struct crypto_alg *alg) {
    struct rng_alg *ralg = container_of(alg, struct rng_alg, base);
    if (alg->cra_rng.rng_make_random) {
        if (alg->cra_rng.seedsize) {
            // return the seedsize of the specific rng function
            return alg->cra_rng.seedsize;
        }
    }
    // return the default in all other cases
    return ralg->seedsize;
}
--------------------
static unsigned int seedsize(struct crypto_alg *alg) {
    struct rng_alg *ralg = container_of(alg, struct rng_alg, base);
    if (alg && alg->cra_rng.rng_make_random) {
        return alg->cra_rng.seedsize ?: ralg->seedsize;
    }
    return ralg->seedsize;
}
--------------------
static unsigned int seedsize(struct crypto_alg *alg) {
    if (alg && alg->cra_rng.rng_make_random) {
        return alg->cra_rng.seedsize ?: container_of(alg, struct rng_alg, base)->seedsize;
    }
    return container_of(alg, struct rng_alg, base)->seedsize;
}
--------------------
match:1
source:
<S2SV_StartBug> static void write_intra_mode ( vp9_writer * w , MB_PREDICTION_MODE mode , <S2SV_EndBug> <S2SV_StartBug> const vp9_prob * probs ) { <S2SV_EndBug> vp9_write_token ( w , vp9_intra_mode_tree , probs , & intra_mode_encodings [ mode ] ) ; }

target:
static void write_intra_mode ( vpx_writer * w , MB_PREDICTION_MODE mode , const vpx_prob * probs ) { vp9_write_token ( w , vp9_intra_mode_tree , probs , & intra_mode_encodings [ mode ] ) ; }

outputs:
static void write_intra_mode(vp9_writer *w, MB_PREDICTION_MODE mode, const vp9_prob *probs) {
  vp9_write_token(w, vp9_intra_mode_tree, probs, &intra_mode_encodings[mode]);
}
--------------------
static void write_intra_mode(vp9_writer *w, MB_PREDICTION_MODE mode, const vp9_prob *probs) {
  const vp9_tree_index *tree = vp9_intra_mode_tree;
  vp9_write_token(w, tree, probs, &intra_mode_encodings[mode]);
}
--------------------
void write_intra_mode(vp9_writer *w, MB_PREDICTION_MODE mode, const vp9_prob *probs) {
  const vp9_tree_index *tree = vp9_intra_mode_tree;
  const vp9_coeff_element *e = &intra_mode_encodings[mode];
  vp9_write_token(w, tree, probs, e);
}
--------------------
static void write_intra_mode(vp9_writer *w, MB_PREDICTION_MODE mode, const vp9_prob *probs) {
  const vp9_tree_index *tree = vp9_intra_mode_tree;
  vp9_write_token(w, tree, probs, intra_mode_encodings + mode);
}
--------------------
void write_intra_mode(vp9_writer *w, MB_PREDICTION_MODE mode, const vp9_prob *probs) {
  vp9_write_token(w, vp9_intra_mode_tree, probs, intra_mode_encodings + mode);
}
--------------------
void write_intra_mode(vp9_writer *w, MB_PREDICTION_MODE mode, const vp9_prob *probs) {
  int offset = (mode * sizeof(vp9_coeff_element));
  vp9_write_token(w, vp9_intra_mode_tree, probs, ((const vp9_coeff_element*)intra_mode_encodings) + offset);
}
--------------------
void write_intra_mode(vp9_writer *w, MB_PREDICTION_MODE mode, const vp9_prob *probs) {
  vp9_coeff_element const *e_ptr = intra_mode_encodings + mode;
  const vp9_tree_index *tree = vp9_intra_mode_tree;
  vp9_write_token(w, tree, probs, e_ptr);
}
--------------------
static void write_intra_mode(vp9_writer *w, MB_PREDICTION_MODE mode, const vp9_prob *probs) {
  const vp9_tree_index *tree = vp9_intra_mode_tree;
  vp9_coeff_element const *enc = &intra_mode_encodings[mode];
  vp9_write_token(w, tree, probs, enc);
}
--------------------
static void write_intra_mode(vp9_writer *w, MB_PREDICTION_MODE mode, const vp9_prob *probs) {
  const vp9_tree_index *tree = vp9_intra_mode_tree;
  vp9_write_token(w, tree, probs, &intra_mode_encodings[mode]);
}
--------------------
void write_intra_mode(vp9_writer *w, MB_PREDICTION_MODE mode, const vp9_prob *probs) {
  vp9_write_token(w, vp9_intra_mode_tree, probs, &intra_mode_encodings[mode]);
}
--------------------
match:0
source:
 static void addFormVars ( cchar * buf ) { char * pair , * tok ; pair = stok ( sclone ( buf ) , "&" , & tok ) ; <S2SV_StartBug> while ( pair != 0 ) { <S2SV_EndBug> mprAddItem ( app -> formData , sclone ( pair ) ) ; pair = stok ( 0 , "&" , & tok ) ; } }


target:
static void addFormVars ( cchar * buf ) { char * pair , * tok ; pair = stok ( sclone ( buf ) , "&" , & tok ) ; while ( pair ) { mprAddItem ( app -> formData , sclone ( pair ) ) ; pair = stok ( 0 , "&" , & tok ) ; } }
outputs:
static void addFormVars ( cchar * buf ) { 
  if (buf == NULL) {
    return;
  }
  char * pair , * tok ; 
  pair = stok ( sclone ( buf ) , "&" , & tok ) ; 
  while ( pair != 0 ) { 
    mprAddItem ( app -> formData , sclone ( pair ) ) ; 
    pair = stok ( 0 , "&" , & tok ) ; 
  } 
}
--------------------
static void addFormVars ( cchar * buf ) { 
  if (buf == NULL || app == NULL || app->formData == NULL) {
    return;
  }
  char * pair , * tok ; 
  pair = stok ( sclone ( buf ) , "&" , & tok ) ; 
  while ( pair != 0 ) { 
    mprAddItem ( app -> formData , sclone ( pair ) ) ; 
    pair = stok ( 0 , "&" , & tok ) ; 
  } 
}
--------------------
static void addFormVars ( cchar * buf ) { 
  if (buf == NULL || app == NULL || app->formData == NULL) {
    return;
  }
  char * pair , * tok ; 
  pair = stok ( sclone ( buf ) , "&" , & tok ) ; 
  while ( pair != 0 ) { 
    mprAddItem ( sclone(app->formData) , sclone ( pair ) ) ; 
    pair = stok ( 0 , "&" , & tok ) ; 
  } 
}
--------------------
static void addFormVars ( cchar * buf ) { 
  if (buf == NULL || app == NULL || app->formData == NULL) {
    return;
  }
  char * pair , * tok ; 
  pair = stok ( sclone ( buf ) , "&" , & tok ) ; 
  while ( pair != 0 ) { 
    if (pair != NULL) {
      mprAddItem ( sclone(app->formData) , sclone ( pair ) ) ; 
    }
    pair = stok ( 0 , "&" , & tok ) ; 
  } 
}
--------------------
static void addFormVars ( cchar * buf ) { 
  if (buf == NULL || app == NULL || app->formData == NULL) {
    return;
  }
  char * pair , * tok ; 
  pair = stok ( sclone ( buf ) , "&" , & tok ) ; 
  while ( tok != 0 ) { 
    if (pair != NULL) {
      mprAddItem ( sclone(app->formData) , sclone ( pair ) ) ; 
    }
    pair = stok ( 0 , "&" , & tok ) ; 
  } 
}
--------------------
static void addFormVars ( cchar * buf ) { 
  if (buf == NULL || app == NULL || app->formData == NULL || app->formData->len >= sizeof(app->formData)-1) {
    return;
  }
  char * pair , * tok ; 
  pair = stok ( sclone ( buf ) , "&" , & tok ) ; 
  while ( tok != 0 ) { 
    if (pair != NULL) {
      mprAddItem ( sclone(app->formData) , sclone ( pair ) ) ; 
    }
    pair = stok ( 0 , "&" , & tok ) ; 
  } 
}
--------------------
static void addFormVars ( cchar * buf ) { 
  if (buf == NULL || app == NULL || app->formData == NULL || app->formData->len >= sizeof(app->formData)-1) {
    return;
  }
  char * pair , * tok ; 
  pair = stok ( sclone ( buf ) , "&" , & tok ) ; 
  while ( tok != 0 ) { 
    if (pair != NULL) {
      mprAddItem ( sclone(app->formData) , sclone ( pair ) ) ; 
    }
    pair = stok ( 0 , "&" , & tok ) ; 
    pair = sclone(pair);
  } 
}
--------------------
static void addFormVars ( cchar * buf ) { 
  if (buf == NULL || app == NULL || app->formData == NULL || app->formData->len >= sizeof(app->formData)-1) {
    return;
  }
  char * pair , * tok ; 
  pair = stok ( sclone ( buf ) , "&" , & tok ) ; 
  if (tok == NULL) {
    return;
  }
  while ( tok != 0 ) { 
    if (pair != NULL) {
      mprAddItem ( sclone(app->formData) , sclone ( pair ) ) ; 
    }
    pair = stok ( 0 , "&" , & tok ) ; 
    pair = sclone(pair);
  } 
}
--------------------
static void addFormVars ( cchar * buf ) { 
  if (buf == NULL || app == NULL || app->formData == NULL || app->formData->len >= sizeof(app->formData)-1 || strlen(buf) >= sizeof(buf)-1) {
    return;
  }
  char * pair , * tok ; 
  pair = stok ( sclone ( buf ) , "&" , & tok ) ; 
  if (tok == NULL) {
    return;
  }
  while ( tok != 0 ) { 
    if (pair != NULL) {
      mprAddItem ( sclone(app->formData) , sclone ( pair ) ) ; 
    }
    pair = stok ( 0 , "&" , & tok ) ; 
    pair = sclone(pair);
  } 
}
--------------------
static void addFormVars ( cchar * buf ) { 
  if (buf == NULL || app == NULL || app->formData == NULL || app->formData->len >= sizeof(app->formData)-1 || strlen(buf) >= sizeof(buf)-1) {
    return;
  }
  char * pair , * tok ; 
  pair = stok ( sclone ( buf ) , "&" , & tok ) ; 
  if (tok == NULL) {
    return;
  }
  while ( tok != 0 ) { 
    if (pair != NULL && strlen(pair) < sizeof(pair)-1) {
      mprAddItem ( sclone(app->formData) , sclone ( pair ) ) ; 
    }
    pair = stok ( 0 , "&" , & tok ) ; 
    pair = sclone(pair);
  } 
}
--------------------
match:0
source:
 static void m_stop ( struct seq_file * m , void * v ) { struct proc_maps_private * priv = m -> private ; struct vm_area_struct * vma = v ; <S2SV_StartBug> vma_stop ( priv , vma ) ; <S2SV_EndBug> if ( priv -> task ) put_task_struct ( priv -> task ) ; }


target:
static void m_stop ( struct seq_file * m , void * v ) { struct proc_maps_private * priv = m -> private ; struct vm_area_struct * vma = v ; if ( ! IS_ERR ( vma ) ) vma_stop ( priv , vma ) ; if ( priv -> task ) put_task_struct ( priv -> task ) ; }
outputs:
static void m_stop ( struct seq_file * m , void * v ) { 
    struct proc_maps_private * priv = m -> private ; 
    struct vm_area_struct * vma = v ; 
    if (priv && vma) { // check for null pointers
        vma_stop ( priv , vma ) ; 
        if ( priv -> task ) 
            put_task_struct ( priv -> task ) ; 
    }
}
--------------------
static void m_stop ( struct seq_file * m , void * v ) { 
    if (m) { //check for null pointer
        struct proc_maps_private * priv = m -> private ; 
        struct vm_area_struct * vma = v ; 
        if (priv && vma) { 
            vma_stop ( priv , vma ) ; 
            if ( priv -> task ) 
                put_task_struct ( priv -> task ) ; 
        }
   }
}
--------------------
static void m_stop ( struct seq_file * m , void * v ) { 
    if (m) { 
        struct proc_maps_private * priv = m -> private ; 
        struct vm_area_struct * vma = v ; 
        if (priv && vma) { 
            if (vma_stop ( priv , vma ) == 0) { // check return value
                if ( priv -> task ) 
                    if (put_task_struct ( priv -> task ) == 0) // check return value
                        return; 
            }
        }
   }
}
--------------------
static void m_stop ( struct seq_file * m , void * v ) { 
    if (m) { 
        struct proc_maps_private * priv = m -> private ; 
        struct vm_area_struct * vma = v ; 
        if (priv && vma) { 
            try {
                if (vma_stop ( priv , vma ) == 0) {
                    if ( priv -> task ) 
                        if (put_task_struct ( priv -> task ) == 0) 
                            return; 
                }
            } catch(Exception e) {
                // do something with the exception
            }
        }
   }
}
--------------------
static void m_stop ( struct seq_file * m , void * v ) { 
    if (m) { 
        struct proc_maps_private * priv = m -> private ; 
        struct vm_area_struct * vma = v ; 
        if (priv && vma) { 
            log.info("m_stop started execution");
            try {
                if (vma_stop ( priv , vma ) == 0) {
                    log.info("vma_stop executed successfully");
                    if ( priv -> task ) 
                        if (put_task_struct ( priv -> task ) == 0) {
                            log.info("put_task_struct executed successfully");
                            return; 
                        } else {
                            log.error("put_task_struct failed to execute");
                        }
                } else {
                    log.error("vma_stop failed to execute");
                }
            } catch(Exception e) {
                log.error("An exception occurred during execution: " + e.getMessage());
            }
        } else {
            log.warning("Null pointer detected.");
        }
   } else {
        log.warning("Null pointer detected.");
   }
}
--------------------
static int m_stop ( struct seq_file * m , void * v ) { 
    if (m) { 
        struct proc_maps_private * priv = m -> private ; 
        struct vm_area_struct * vma = v ; 
        if (priv && vma) { 
            log.info("m_stop started execution");
            try {
                if (vma_stop ( priv , vma ) == 0) {
                    log.info("vma_stop executed successfully");
                    if ( priv -> task ) 
                        if (put_task_struct ( priv -> task ) == 0) {
                            log.info("put_task_struct executed successfully");
                            return 0; 
                        } else {
                            log.error("put_task_struct failed to execute");
                            return -1;
                        }
                } else {
                    log.error("vma_stop failed to execute");
                    return -1;
                }
            } catch(Exception e) {
                log.error("An exception occurred during execution: " + e.getMessage());
                return -1;
            }
        } else {
            log.warning("Null pointer detected.");
            return -1;
        }
   } else {
        log.warning("Null pointer detected.");
        return -1;
   }
}
--------------------
/**
 * Stops the mapping of a memory region and releases any related resources.
 * @param m a pointer to the sequential file structure that holds information about the current mapping
 * @param v a pointer to the virtual memory area structure that contains information about the memory region
 * @return 0 on success, -1 on failure.
 */
static int m_stop ( struct seq_file * m , void * v ) { 
    //check for null pointer
    if (!m || !v) { 
        log.warning("Null pointer detected.");
        return -1;
    }
        
    //get the private struct and virtual memory area
    struct proc_maps_private * priv = m -> private ; 
    struct vm_area_struct * vma = v ;
        
    //check for null pointer
    if (priv && vma) { 
        log.info("m_stop started execution");
        try {
            //stop the memory mapping
            if (vma_stop ( priv , vma ) == 0) {
                log.info("vma_stop executed successfully");
                    
                //release any task resources
                if ( priv -> task ) 
                    if (put_task_struct ( priv -> task ) == 0) {
                        log.info("put_task_struct executed successfully");
                        return 0; 
                    } else {
                        log.error("put_task_struct failed to execute");
                        return -1;
                    }
            } else {
                log.error("vma_stop failed to execute");
                return -1;
            }
        } catch(Exception e) {
            log.error("An exception occurred during execution: " + e.getMessage());
            return -1;
        }
    } else {
        log.warning("Null pointer detected.");
        return -1;
    }
}
--------------------
/**
 * Stops the mapping of a memory region and releases any related resources.
 * @param m a pointer to the sequential file structure that holds information about the current mapping
 * @param v a pointer to the virtual memory area structure that contains information about the memory region
 * @return 0 on success, -1 on failure.
 */
static int m_stop ( std::unique_ptr<seq_file> m , std::unique_ptr<vm_area_struct> v ) { 
    //check for null pointer
    if (!m || !v) { 
        log.warning("Null pointer detected.");
        return -1;
    }

    //get the private struct and virtual memory area
    std::unique_ptr<proc_maps_private> priv(m->private); 
        
    //check for null pointer
    if (priv && v) { 
        log.info("m_stop started execution");
        try {
            //stop the memory mapping
            if (vma_stop ( priv.get() , v.get() ) == 0) {
                log.info("vma_stop executed successfully");
                    
                //release any task resources
                if ( priv->task ) 
                    if (put_task_struct ( priv->task ) == 0) {
                        log.info("put_task_struct executed successfully");
                        return 0; 
                    } else {
                        log.error("put_task_struct failed to execute");
                        return -1;
                    }
            } else {
                log.error("vma_stop failed to execute");
                return -1;
            }
        } catch(Exception e) {
            log.error("An exception occurred during execution: " + e.getMessage());
            return -1;
        }
    } else {
        log.warning("Null pointer detected.");
        return -1;
    }
}
--------------------
/**
 * Stops the mapping of a memory region and releases any related resources.
 * @param m a shared pointer to the sequential file structure that holds information about the current mapping
 * @param v a shared pointer to the virtual memory area structure that contains information about the memory region
 * @return 0 on success, -1 on failure.
 */
static int m_stop ( std::shared_ptr<seq_file> m , std::shared_ptr<vm_area_struct> v ) { 
    //check for null pointer
    if (!m || !v) { 
        log.warning("Null pointer detected.");
        return -1;
    }

    //get the private struct and virtual memory area
    std::shared_ptr<proc_maps_private> priv(m->private); 
        
    //check for null pointer
    if (priv && v) { 
        log.info("m_stop started execution");
        try {
            //stop the memory mapping
            if (vma_stop ( priv.get() , v.get() ) == 0) {
                log.info("vma_stop executed successfully");
                    
                //release any task resources
                if ( priv->task ) 
                    if (put_task_struct ( priv->task ) == 0) {
                        log.info("put_task_struct executed successfully");
                        return 0; 
                    } else {
                        log.error("put_task_struct failed to execute");
                        return -1;
                    }
            } else {
                log.error("vma_stop failed to execute");
                return -1;
            }
        } catch(Exception e) {
            log.error("An exception occurred during execution: " + e.getMessage());
            return -1;
        }
    } else {
        log.warning("Null pointer detected.");
        return -1;
    }
}
--------------------
/**
 * Stops the mapping of a memory region and releases any related resources.
 * @param m a reference to the sequential file structure that holds information about the current mapping
 * @param v a reference to the virtual memory area structure that contains information about the memory region
 * @return 0 on success, -1 on failure.
 */
static int m_stop ( seq_file& m , vm_area_struct& v ) { 
    //get the private struct
    proc_maps_private * priv = m.private ; 
    if (!priv) {
        log.warning("Null pointer detected.");
        return -1;
    }
        
    log.info("m_stop started execution");
    try {
        //stop the memory mapping
        if (vma_stop ( priv , &v ) == 0) {
            log.info("vma_stop executed successfully");
                
            //release any task resources
            if ( priv->task ) 
                if (put_task_struct ( priv->task ) == 0) {
                    log.info("put_task_struct executed successfully");
                    return 0; 
                } else {
                    log.error("put_task_struct failed to execute");
                    return -1;
                }
        } else {
            log.error("vma_stop failed to execute");
            return -1;
        }
    } catch(Exception e) {
        log.error("An exception occurred during execution: " + e.getMessage());
        return -1;
    }
}
--------------------
match:0
source:
 int pci_emul_add_msicap ( struct pci_vdev * dev , int msgnum ) { struct msicap msicap ; <S2SV_StartBug> pci_populate_msicap ( & msicap , msgnum , 0 ) ; <S2SV_EndBug> return pci_emul_add_capability ( dev , ( u_char * ) & msicap , sizeof ( msicap ) ) ; }


target:
int pci_emul_add_msicap ( struct pci_vdev * dev , int msgnum ) { struct msicap msicap ; return pci_populate_msicap ( & msicap , msgnum , 0 ) || pci_emul_add_capability ( dev , ( u_char * ) & msicap , sizeof ( msicap ) ) ; }
outputs:
int pci_emul_add_msicap(struct pci_vdev *dev, int msgnum) {
    struct msicap msicap;
    memset(&msicap, 0, sizeof(msicap)); // Initialize structure with 0's
    pci_populate_msicap(&msicap, msgnum, 0);
    return pci_emul_add_capability(dev, (u_char *)&msicap, sizeof(msicap));
}
--------------------
int pci_emul_add_msicap(struct pci_vdev *dev, int msgnum) {
    if (msgnum < 0 || msgnum >= MAX_MSICAP_ENTRIES) { // check if msgnum is within bounds
        return -1;
    }
    struct msicap msicap;
    memset(&msicap, 0, sizeof(msicap)); // Initialize structure with 0's
    pci_populate_msicap(&msicap, msgnum, 0);
    return pci_emul_add_capability(dev, (u_char *)&msicap, sizeof(msicap));
}
--------------------
int pci_emul_add_msicap(struct pci_vdev *dev, int msgnum) {
    if (msgnum < 0 || msgnum >= MAX_MSICAP_ENTRIES) { // check if msgnum is within bounds
        return -1;
    }
    struct msicap msicap;
    memset(&msicap, 0, sizeof(msicap)); // Initialize structure with 0's
    if (pci_populate_msicap(&msicap, msgnum, 0) < 0) { // check the return value of pci_populate_msicap()
        return -1;
    }
    return pci_emul_add_capability(dev, (u_char *)&msicap, sizeof(msicap));
}
--------------------
int pci_emul_add_msicap(struct pci_vdev *dev, int msgnum) {
    if (msgnum < 0 || msgnum >= MAX_MSICAP_ENTRIES) { // check if msgnum is within bounds
        return -1;
    }
    struct msicap msicap;
    memset(&msicap, 0, sizeof(msicap)); // Initialize structure with 0's
    if (pci_populate_msicap(&msicap, msgnum, 0) < 0) { // check the return value of pci_populate_msicap()
        return -1;
    }
    u_char msicap_array[sizeof(struct msicap)]; // create a fixed size array to store msicap structure
    memcpy(msicap_array, &msicap, sizeof(msicap)); // copy msicap structure to the array
    return pci_emul_add_capability(dev, msicap_array, sizeof(msicap));
}
--------------------
void pci_emul_add_msicap(struct pci_vdev *dev, int msgnum, int *ret) {
    if (!ret) return;
    if (msgnum < 0 || msgnum >= MAX_MSICAP_ENTRIES) { // check if msgnum is within bounds
        *ret = -1;
        return;
    }
    struct msicap msicap;
    memset(&msicap, 0, sizeof(msicap)); // Initialize structure with 0's
    if (pci_populate_msicap(&msicap, msgnum, 0) < 0) { // check the return value of pci_populate_msicap()
        *ret = -1;
        return;
    }
    u_char msicap_array[sizeof(struct msicap)]; // create a fixed size array to store msicap structure
    memcpy(msicap_array, &msicap, sizeof(msicap)); // copy msicap structure to the array
    *ret = pci_emul_add_capability(dev, msicap_array, sizeof(msicap));
}
--------------------
int pci_emul_add_msicap(struct pci_vdev *dev, int msgnum) {
    if (msgnum < 0 || msgnum >= MAX_MSICAP_ENTRIES) { // check if msgnum is within bounds
        return -1;
    }
    struct msicap msicap;
    memset(&msicap, 0, sizeof(msicap)); // Initialize structure with 0's
    if (pci_populate_msicap(&msicap, msgnum, 0) < 0) { // check the return value of pci_populate_msicap()
        return -1;
    }
    u_char msicap_array[sizeof(struct msicap)]; // use a fixed size array to store msicap structure
    memcpy(msicap_array, &msicap, sizeof(msicap)); // copy msicap structure to the array
    return pci_emul_add_capability(dev, msicap_array, sizeof(msicap));
}
--------------------
int pci_emul_add_msicap(struct pci_vdev *dev, int msgnum) {
    if (!dev || msgnum < 0 || msgnum >= MAX_MSICAP_ENTRIES) { // check if dev and msgnum are valid
        return -1;
    }
    struct msicap msicap;
    memset(&msicap, 0, sizeof(msicap)); // Initialize structure with 0's
    if (pci_populate_msicap(&msicap, msgnum, 0) < 0) { // check the return value of pci_populate_msicap()
        return -1;
    }
    u_char msicap_array[sizeof(struct msicap)]; // use a fixed size array to store msicap structure
    memcpy(msicap_array, &msicap, sizeof(msicap)); // copy msicap structure to the array
    return pci_emul_add_capability(dev, msicap_array, sizeof(msicap));
}
--------------------
int pci_emul_add_msicap(struct pci_vdev *dev, int msgnum) {
    if (!dev || msgnum < 0 || msgnum >= MAX_MSICAP_ENTRIES) { // check if dev and msgnum are valid
        return -1;
    }
    struct msicap msicap;
    memset(&msicap, 0, sizeof(msicap)); // Initialize structure with 0's
    if (pci_populate_msicap(&msicap, msgnum, 0) < 0) { // check the return value of pci_populate_msicap()
        return -1;
    }
    u_char msicap_array[sizeof(struct msicap)]; // use a fixed size array to store msicap structure
    if (sizeof(msicap_array) < sizeof(msicap)) { // check if the size of msicap_array is greater than the size of msicap structure
        return -1;
    }
    memcpy(msicap_array, &msicap, sizeof(msicap)); // copy msicap structure to the array
    return pci_emul_add_capability(dev, msicap_array, sizeof(msicap));
}
--------------------
int pci_emul_add_msicap(struct pci_vdev *dev, int msgnum) {
    if (!dev || msgnum < 0 || msgnum >= MAX_MSICAP_ENTRIES) { // check if dev and msgnum are valid
        return -1;
    }
    struct msicap msicap;
    memset(&msicap, 0, sizeof(msicap)); // Initialize structure with 0's
    if (pci_populate_msicap(&msicap, msgnum, 0) < 0) { // check the return value of pci_populate_msicap()
        return -1;
    }
    u_char msicap_array[sizeof(struct msicap)]; // use a fixed size array to store msicap structure
    if (sizeof(msicap_array) < sizeof(msicap)) { // check if the size of msicap_array is greater than the size of msicap structure
        return -1;
    }
    memcpy(&msicap_array, &msicap, sizeof(msicap)); // copy msicap structure to the array
    return pci_emul_add_capability(dev, msicap_array, sizeof(msicap));
}
--------------------
int pci_emul_add_msicap(struct pci_vdev *dev, int msgnum) {
    if (!dev || msgnum < 0 || msgnum >= MAX_MSICAP_ENTRIES) { // check if dev and msgnum are valid
        return -1;
    }
    struct msicap msicap;
    memset(&msicap, 0, sizeof(msicap)); // Initialize structure with 0's
    if (pci_populate_msicap(&msicap, msgnum, 0) < 0) { // check the return value of pci_populate_msicap()
        return -1;
    }
    u_char msicap_array[sizeof(struct msicap)]; // use a fixed size array to store msicap structure
    if (sizeof(msicap_array) < sizeof(msicap)) { // check if the size of msicap_array is greater than the size of msicap structure
        return -1;
    }
    memcpy(&msicap_array, &msicap, sizeof(msicap_array)); // copy msicap structure to the array
    return pci_emul_add_capability(dev, msicap_array, sizeof(msicap_array));
}
--------------------
match:0
source:
 <S2SV_StartBug> static void <S2SV_EndBug> swabHorAcc16 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) { uint16 * wp = ( uint16 * ) cp0 ; tmsize_t wc = cc / 2 ; TIFFSwabArrayOfShort ( wp , wc ) ; <S2SV_StartBug> horAcc16 ( tif , cp0 , cc ) ; <S2SV_EndBug> }


target:
static int swabHorAcc16 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) { uint16 * wp = ( uint16 * ) cp0 ; tmsize_t wc = cc / 2 ; TIFFSwabArrayOfShort ( wp , wc ) ; return horAcc16 ( tif , cp0 , cc ) ; }
outputs:
static void swabHorAcc16 (TIFF *tif, uint8 *cp0, tmsize_t cc) {
    if (!tif || !cp0 || cc == 0) {
        return;
    }
    uint16 *wp = (uint16 *) cp0;
    tmsize_t wc = cc / 2;
    TIFFSwabArrayOfShort(wp, wc);
    horAcc16(tif, cp0, cc);
}
--------------------
static void swabHorAcc16(TIFF *tif, void *cp, size_t len) {
    if (!tif || !cp || len == 0) {
        return;
    }
    uint16_t *wp = (uint16_t*)cp;
    size_t wc = len / sizeof(uint16_t);
    TIFFSwabArrayOfShort(wp, wc);
    horAcc16(tif, (uint8_t*)cp, len);
}
--------------------
static void swabHorAcc16(TIFF *tif, void *cp, size_t len) {
    if (!tif || !cp || len == 0 || len % sizeof(uint16_t) != 0) {
        return;
    }
    uint16_t *wp = (uint16_t*)cp;
    size_t wc = len / sizeof(uint16_t);
    for (size_t i = 0; i < wc; i++) {
        wp[i] = ntohs(wp[i]);
    }
    horAcc16(tif, (uint8_t*)cp, len);
}
--------------------
static void swabHorAcc16(TIFF *tif, void *cp, size_t len) {
    if (!tif || !cp || len == 0 || len % sizeof(uint16_t) != 0) {
        return;
    }
    uint16_t *in = (uint16_t*)cp;
    uint16_t *out = (uint16_t*)malloc(len);
    if (!out) {
        return;
    }
    size_t wc = len / sizeof(uint16_t);
    for (size_t i = 0; i < wc; i++) {
        out[i] = ntohs(in[i]);
    }
    horAcc16(tif, (uint8_t*)out, len);
    free(out);
}
--------------------
#include <string.h>

static void swabHorAcc16(TIFF *tif, void *cp, size_t len) {
    if (!tif || !cp || len == 0 || len % sizeof(uint16_t) != 0) {
        return;
    }
    uint16_t *in = (uint16_t*)cp;
    uint16_t *out = (uint16_t*)malloc(len);
    if (!out) {
        return;
    }
    size_t wc = len / sizeof(uint16_t);
    for (size_t i = 0; i < wc; i++) {
        out[i] = ntohs(in[i]);
    }
    horAcc16(tif, (uint8_t*)out, len);
    memcpy(in, out, len);
    free(out);
}
--------------------
#include <string.h>

static void swabHorAcc16(TIFF *tif, void *cp, size_t len) {
    if (!tif || !cp || len == 0 || len % sizeof(uint16_t) != 0) {
        return;
    }
    uint16_t *in = (uint16_t*)cp;
    uint16_t out[1024];
    size_t wc = len / sizeof(uint16_t);
    for (size_t i = 0; i < wc; i += sizeof(out) / sizeof(uint16_t)) {
        size_t block_len = sizeof(out);
        if (i + block_len > wc) {
            block_len = wc - i;
        }
        for (size_t j = 0; j < block_len; j++) {
            out[j] = ntohs(in[i + j]);
        }
        horAcc16(tif, (uint8_t*)out, block_len * sizeof(uint16_t));
        memcpy(in + i, out, block_len * sizeof(uint16_t));
    }
}
--------------------
#include <string.h>
#include <stdint.h>
#include <stddef.h>
#include <limits.h>

static void swabHorAcc16(TIFF* tif, void* cp, size_t len) {
    if (!tif || !cp || len == 0 || len % sizeof(uint16_t) != 0) {
        return;
    }
    uint16_t* in = (uint16_t*)cp;
    uint16_t out[1024];
    size_t wc = len / sizeof(uint16_t);
    for (size_t i = 0; i < wc; i += sizeof(out) / sizeof(uint16_t)) {
        size_t block_len = sizeof(out) / sizeof(uint16_t);
        if (i + block_len > wc) {
            block_len = wc - i;
        }
        for (size_t j = 0; j < block_len; j++) {
            out[j] = ntohs(in[i + j]);
        }
        if (SIZE_MAX / sizeof(uint16_t) < block_len) {
            return;
        }
        size_t block_size = block_len * sizeof(uint16_t);
        horAcc16(tif, (uint8_t*)out, block_size);
        memcpy(in + i, out, block_size);
    }
}
--------------------
#include <string.h>
#include <stdint.h>
#include <stddef.h>
#include <limits.h>

static void swab16(uint16_t* in, size_t len, uint16_t* out) {
    if (!in || !out || len % sizeof(uint16_t) != 0) {
        return;
    }
    size_t wc = len / sizeof(uint16_t);
    for (size_t i = 0; i < wc; i++) {
        out[i] = ntohs(in[i]);
    }
}

static void swabHorAcc16(TIFF* tif, void* cp, size_t len) {
    if (!tif || !cp || len == 0 || len % sizeof(uint16_t) != 0) {
        return;
    }
    uint16_t in[1024];
    uint16_t out[1024];
    size_t wc = len / sizeof(uint16_t);
    for (size_t i = 0; i < wc; i += sizeof(in) / sizeof(uint16_t)) {
        size_t block_len = sizeof(in) / sizeof(uint16_t);
        if (i + block_len > wc) {
            block_len = wc - i;
        }
        swab16((uint16_t*)((uint8_t*)cp + i * sizeof(uint16_t)), block_len * sizeof(uint16_t), in);
        size_t block_size = block_len * sizeof(uint16_t);
        horAcc16(tif, (uint8_t*)in, block_size);
        swab16(in, block_size, (uint16_t*)((uint8_t*)cp + i * sizeof(uint16_t)));
    }
}
--------------------
#include <string.h>
#include <stdint.h>
#include <stddef.h>
#include <limits.h>

static void swab16(uint16_t* in, size_t len, uint16_t* out) {
    if (!in || !out || len % sizeof(uint16_t) != 0) {
        return;
    }
    size_t wc = len / sizeof(uint16_t);
    for (size_t i = 0; i < wc; i++) {
        out[i] = ntohs(in[i]);
    }
}

static void swabHorAcc16(TIFF* tif, void* cp, size_t len) {
    if (!tif || !cp || len == 0 || len % sizeof(uint16_t) != 0) {
        return;
    }
    uint16_t in[128] __attribute__((aligned(sizeof(uint16_t))));
    uint16_t out[128] __attribute__((aligned(sizeof(uint16_t))));
    size_t wc = len / sizeof(uint16_t);
    for (size_t i = 0; i < wc; i += sizeof(in) / sizeof(uint16_t)) {
        size_t block_len = sizeof(in) / sizeof(uint16_t);
        if (i + block_len > wc) {
            block_len = wc - i;
        }
        swab16((uint16_t*)((uint8_t*)cp + i * sizeof(uint16_t)), block_len * sizeof(uint16_t), in);
        size_t block_size = block_len * sizeof(uint16_t);
        horAcc16(tif, (uint8_t*)in, block_size);
        swab16(in, block_size, (uint16_t*)((uint8_t*)cp + i * sizeof(uint16_t)));
    }
}
--------------------
#include <string.h>
#include <stdint.h>
#include <stddef.h>
#include <limits.h>

static void swab16(uint16_t* in, size_t len, uint16_t* out) {
    if (!in || !out || len % sizeof(uint16_t) != 0) {
        return;
    }
    size_t wc = len / sizeof(uint16_t);
    for (size_t i = 0; i < wc; i++) {
        out[i] = ntohs(in[i]);
    }
}

static void swabHorAcc16(TIFF* tif, void* cp, size_t len) {
    if (!tif || !cp || len == 0 || len % sizeof(uint16_t) != 0) {
        return;
    }
    uint16_t in[128] __attribute__((aligned(sizeof(uint16_t))));
    uint16_t out[128] __attribute__((aligned(sizeof(uint16_t))));
    size_t wc = len / sizeof(uint16_t);
    for (size_t i = 0; i < wc; i += sizeof(in) / sizeof(uint16_t)) {
        size_t block_len = sizeof(in) / sizeof(uint16_t);
        if (i + block_len > wc) {
            block_len = wc - i;
        }
        swab16((uint16_t*)((uint8_t*)cp + i * sizeof(uint16_t)), block_len * sizeof(uint16_t), in);
        size_t block_size = block_len * sizeof(uint16_t);
        for (size_t j = 0; j < block_len; j += 8) {
            horAcc16(tif, (uint8_t*)&in[j], 8 * sizeof(uint16_t));
        }
        swab16(in, block_size, (uint16_t*)((uint8_t*)cp + i * sizeof(uint16_t)));
    }
}
--------------------
match:0
source:
struct bpf_map * bpf_map_get_with_uref ( u32 ufd ) { struct fd f = fdget ( ufd ) ; struct bpf_map * map ; map = __bpf_map_get ( f ) ; if ( IS_ERR ( map ) ) return map ; <S2SV_StartBug> bpf_map_inc ( map , true ) ; <S2SV_EndBug> fdput ( f ) ; return map ; }

target:
struct bpf_map * bpf_map_get_with_uref ( u32 ufd ) { struct fd f = fdget ( ufd ) ; struct bpf_map * map ; map = __bpf_map_get ( f ) ; if ( IS_ERR ( map ) ) return map ; map = bpf_map_inc ( map , true ) ; fdput ( f ) ; return map ; }

outputs:
struct bpf_map * bpf_map_get_with_uref ( u32 ufd ) {
    struct fd f = fdget ( ufd ) ;
    struct bpf_map * map ;
    map = __bpf_map_get ( f ) ;
    if ( IS_ERR ( map ) )
        return map ;
    fdput ( f ) ;
    return map ;
}
--------------------
struct bpf_map * bpf_map_get_with_uref ( u32 ufd ) {
    struct fd f = fdget ( ufd ) ;
    struct bpf_map * map ;
    map = __bpf_map_get ( f ) ;
    if ( IS_ERR ( map ) )
        goto cleanup;
    fdput ( f ) ;
    bpf_map_inc ( map , true ) ;
    return map;
cleanup:
    fdput ( f );
    return map;
}
--------------------
struct bpf_map * bpf_map_get_with_uref ( u32 ufd ) {
    struct fd f = fdget ( ufd ) ;
    struct bpf_map * map ;
    map = __bpf_map_get ( f ) ;
    if ( IS_ERR ( map ) ) {
        fdput(f);
        return map ;
    }
    bpf_map_inc ( map , true ) ;
    fdput ( f ) ;
    return map ;
}
--------------------
struct bpf_map * bpf_map_get_with_uref ( u32 ufd ) {
    struct fd f = fdget ( ufd );
    if ( f.file == NULL ) {
        return ERR_PTR(-EBADF);
    }
    struct bpf_map * map ;
    map = __bpf_map_get ( f ) ;
    if ( IS_ERR ( map ) ) {
        fdput(f);
        return map ;
    }
    bpf_map_inc ( map , true ) ;
    fdput ( f ) ;
    return map ;
}
--------------------
struct bpf_map * bpf_map_get_with_uref ( u32 ufd ) {
    struct fd f = fdget ( ufd );
    if ( !f.file )
        return ERR_PTR(-EBADF);
    struct bpf_map * map ;
    map = __bpf_map_get ( f ) ;
    if ( IS_ERR ( map ) ) {
        fdput(f);
        return map ;
    }
    bpf_map_inc ( map , true ) ;
    fdput ( f ) ;
    return map ;
}
--------------------
struct bpf_map * bpf_map_get_with_uref ( u32 ufd ) {
    struct fd f = fdget ( ufd ) ;
    struct bpf_map * map ;
    if (!f.file) {
        return ERR_PTR(-EBADF);
    }
    rcu_read_lock () ;
    map = __bpf_map_get ( f ) ;
    if ( IS_ERR ( map ) ) {
        rcu_read_unlock ();
        fdput ( f ) ;
        return map ;
    }
    bpf_map_inc ( map , true ) ;
    rcu_read_unlock ();
    fdput ( f ) ;
    return map ;
}
--------------------
struct bpf_map * bpf_map_get_with_uref ( u32 ufd ) {
    struct fd f = fdget ( ufd ) ;
    struct bpf_map * map ;
    if (!f.file) {
        return ERR_PTR(-EBADF);
    }
    map = __bpf_map_get ( f ) ;
    if ( IS_ERR ( map ) ) {
        fdput ( f ) ;
        return map ;
    }
    bpf_map_inc ( map , true ) ;
    fdput ( f ) ;
    return map ;
}
--------------------
struct bpf_map * bpf_map_get_with_uref ( u32 ufd ) {
    struct fd f = fdget ( ufd ) ;
    struct bpf_map * map ;
    if (!f.file) {
        return ERR_PTR(-EBADF);
    }
    map = __bpf_map_get ( f ) ;
    if ( !IS_ERR ( map ) ) {
        bpf_map_inc ( map , true ) ;
        fdput ( f );
    }
    return map ;
}
--------------------
struct bpf_map * bpf_map_get_with_uref ( u32 ufd ) {
    struct fd f = fdget ( ufd ) ;
    struct bpf_map * map ;

    if (!f.file) {
        return ERR_PTR(-EBADF);
    }

    map = __bpf_map_get ( f ) ;

    if ( IS_ERR ( map ) ) {
        fdput ( f ) ;
        return map ;
    }

    bpf_map_inc ( map , true ) ;
    fdput ( f );

    return map ;
}
--------------------
struct bpf_map * bpf_map_get_with_uref ( u32 ufd ) {
    struct fd f = fdget ( ufd ) ;
    struct bpf_map * map ;
    map = __bpf_map_get ( f ) ;

    if ( !IS_ERR ( map ) ) {
        bpf_map_inc ( map , true ) ;
    }
    fdput ( f );

    return map ;
}
--------------------
match:0
source:
 int av_reallocp_array ( void * ptr , size_t nmemb , size_t size ) { void * * ptrptr = ptr ; * ptrptr = av_realloc_f ( * ptrptr , nmemb , size ) ; <S2SV_StartBug> if ( ! * ptrptr && ! ( nmemb && size ) ) <S2SV_EndBug> return AVERROR ( ENOMEM ) ; return 0 ; }


target:
int av_reallocp_array ( void * ptr , size_t nmemb , size_t size ) { void * * ptrptr = ptr ; * ptrptr = av_realloc_f ( * ptrptr , nmemb , size ) ; if ( ! * ptrptr && nmemb && size ) ) return AVERROR ( ENOMEM ) ; return 0 ; }
outputs:
int av_reallocp_array(void **ptr, size_t nmemb, size_t size) {
    if (!ptr) {
        return AVERROR(EINVAL);
    }
    void **ptrptr = ptr;
    void *new_ptr = av_realloc_f(*ptrptr, nmemb, size);
    if (!new_ptr && (nmemb || size)) {
        return AVERROR(ENOMEM);
    }
    *ptrptr = new_ptr;
    return 0;
}
--------------------
int av_reallocp_array(void **ptr, size_t nmemb, size_t size) {
    if (!ptr) {
        return AVERROR(EINVAL);
    }
    void **ptrptr = ptr;
    void *new_ptr = av_realloc_f(*ptrptr, nmemb, size);
    if (!new_ptr && (nmemb > 0 || size > 0)) {
        return AVERROR(ENOMEM);
    }
    *ptrptr = new_ptr;
    return 0;
}
--------------------
int av_reallocp_array(void **ptr, size_t nmemb, size_t size) {
    if (!ptr || !*ptr) {
        return AVERROR(EINVAL);
    }
    void **ptrptr = ptr;
    void *new_ptr = av_realloc_f(*ptrptr, nmemb, size);
    if (!new_ptr && (nmemb > 0 || size > 0)) {
        return AVERROR(ENOMEM);
    }
    *ptrptr = new_ptr;
    return 0;
}
--------------------
int av_reallocp_array(void **ptr, size_t nmemb, size_t size) {
    if (!ptr || !*ptr) {
        return AVERROR(EINVAL);
    }
    void **ptrptr = ptr;
    void *new_ptr = av_realloc_f(*ptrptr, nmemb, size);
    if (!new_ptr && nmemb > 0 && size > 0) {
        return AVERROR(ENOMEM);
    }
    *ptrptr = new_ptr;
    return 0;
}
--------------------
int av_reallocp_array(void **ptr, size_t nmemb, size_t size) {
    if (!ptr || !*ptr) {
        return AVERROR(EINVAL);
    }
    void **ptrptr = ptr;
    void *new_ptr = av_realloc_f(*ptrptr, nmemb, size);
    if (!new_ptr) {
        if (nmemb == 0 || size == 0) {
            *ptrptr = NULL;
            return 0;
        } else {
            return AVERROR(ENOMEM);
        }
    }
    *ptrptr = new_ptr;
    return 0;
}
--------------------
int av_reallocp_array(void **ptr, size_t nmemb, size_t size) {
    if (!ptr) {
        return AVERROR(EINVAL);
    }
    void **ptrptr = ptr;
    void *new_ptr = av_realloc_f(*ptrptr, nmemb, size);
    if (!new_ptr) {
        if (nmemb == 0 || size == 0) {
            *ptrptr = NULL;
            return 0;
        } else {
            return AVERROR(ENOMEM);
        }
    }
    *ptrptr = new_ptr;
    return 0;
}
--------------------
int av_reallocp_array(void **ptr, size_t nmemb, size_t size) {
    if (!ptr || !*ptr) {
        return AVERROR(EINVAL);
    }
    void **ptrptr = ptr;
    void *new_ptr = av_realloc_f(*ptrptr, nmemb, size);
    if (!new_ptr) {
        if (nmemb == 0 || size == 0) {
            *ptrptr = NULL;
            return 0;
        } else {
            return AVERROR(ENOMEM);
        }
    }
    memset(new_ptr, 0, nmemb * size);
    *ptrptr = new_ptr;
    return 0;
}
--------------------
int av_reallocp_array(void **ptr, size_t nmemb, size_t size) {
    if (!ptr || !*ptr) {
        return AVERROR(EINVAL);
    }
    void **ptrptr = ptr;
    void *new_ptr = av_realloc_f(*ptrptr, nmemb, size);
    if (!new_ptr) {
        if (nmemb == 0 || size == 0) {
            *ptrptr = NULL;
            return 0;
        } else {
            return AVERROR(ENOMEM);
        }
    }
    if (nmemb > 0 && size > 0) {
        memset(new_ptr + (*ptrptr - new_ptr), 0, nmemb * size);
    }
    *ptrptr = new_ptr;
    return 0;
}
--------------------
int av_reallocp_array(void **ptr, size_t nmemb, size_t size) {
    if (!ptr || !*ptr) {
        return AVERROR(EINVAL);
    }
    void **ptrptr = ptr;
    void *new_ptr = av_realloc_f(*ptrptr, nmemb, size);
    if (!new_ptr) {
        if (nmemb == 0 || size == 0) {
            *ptrptr = NULL;
            return 0;
        } else {
            return AVERROR(ENOMEM);
        }
    }
    if (nmemb > 0 && size > 0) {
        memset(new_ptr + (*ptrptr - *ptr), 0, nmemb * size);
    }
    *ptrptr = new_ptr;
    return 0;
}
--------------------
int av_reallocp_array(void **ptr, size_t nmemb, size_t size) {
    if (!ptr || !*ptr) {
        return AVERROR(EINVAL);
    }
    void **ptrptr = ptr;
    void *new_ptr = av_realloc_f(*ptrptr, nmemb, size);
    if (!new_ptr) {
        if (nmemb == 0 || size == 0) {
            *ptrptr = NULL;
            return 0;
        } else {
            return AVERROR(ENOMEM);
        }
    }
    if (nmemb > 0 && size > 0) {
        memset(new_ptr + (*ptrptr - *ptr), 0, nmemb * size);
    }
    if (nmemb == 0 || size == 0) {
        *ptrptr = NULL;
    }
    *ptrptr = new_ptr;
    return 0;
}
--------------------
match:0
source:
static int amd_gpio_remove ( struct platform_device * pdev ) { struct amd_gpio * gpio_dev ; gpio_dev = platform_get_drvdata ( pdev ) ; gpiochip_remove ( & gpio_dev -> gc ) ; <S2SV_StartBug> pinctrl_unregister ( gpio_dev -> pctrl ) ; <S2SV_EndBug> return 0 ; }

target:
static int amd_gpio_remove ( struct platform_device * pdev ) { struct amd_gpio * gpio_dev ; gpio_dev = platform_get_drvdata ( pdev ) ; gpiochip_remove ( & gpio_dev -> gc ) ; return 0 ; }

outputs:
//删掉错误行
static int amd_gpio_remove ( struct platform_device * pdev ) {
    struct amd_gpio * gpio_dev ;
    gpio_dev = platform_get_drvdata ( pdev ) ;
    gpiochip_remove ( & gpio_dev -> gc ) ;
    return 0 ;
}
--------------------
static int amd_gpio_remove ( struct platform_device * pdev ) {
    struct amd_gpio * gpio_dev ;
    gpio_dev = platform_get_drvdata ( pdev ) ;
    gpiochip_remove ( & gpio_dev -> gc ) ;
    pinctrl_put ( gpio_dev -> pctrl ) ;
    pinctrl_unregister ( gpio_dev -> pctrl ) ;
    return 0 ;
}
--------------------
static int amd_gpio_remove ( struct platform_device * pdev ) {
    struct amd_gpio * gpio_dev ;
    gpio_dev = platform_get_drvdata ( pdev ) ;
    pinctrl_put ( gpio_dev -> pctrl ) ;
    gpiochip_remove ( & gpio_dev -> gc ) ;
    return 0 ;
}
--------------------
static int amd_gpio_remove ( struct platform_device * pdev ) {
    struct amd_gpio * gpio_dev ;
    gpio_dev = platform_get_drvdata ( pdev ) ;
    pinctrl_unregister ( gpio_dev -> pctrl ) ;
    pinctrl_put ( gpio_dev -> pctrl ) ;
    gpiochip_remove ( & gpio_dev -> gc ) ;
    return 0 ;
}
--------------------
 static int amd_gpio_remove ( struct platform_device * pdev ) {
    struct amd_gpio * gpio_dev ;
    gpio_dev = platform_get_drvdata ( pdev ) ;
    pinctrl_unregister ( gpio_dev -> pctrl ) ;
    pinctrl_free ( gpio_dev -> pctrl ) ;
    gpiochip_remove ( & gpio_dev -> gc ) ;
    return 0 ;
 }
--------------------
static int amd_gpio_remove ( struct platform_device * pdev ) {
    struct amd_gpio * gpio_dev ;
    gpio_dev = platform_get_drvdata ( pdev ) ;
    pinctrl_put ( gpio_dev -> pctrl ) ;
    pinctrl_free ( gpio_dev -> pctrl ) ;
    gpiochip_remove ( & gpio_dev -> gc ) ;
    return 0 ;
}
--------------------
static int amd_gpio_remove ( struct platform_device * pdev ) {
    struct amd_gpio * gpio_dev ;
    gpio_dev = platform_get_drvdata ( pdev ) ;
    gpiochip_remove ( & gpio_dev -> gc ) ;
    pinctrl_unregister ( gpio_dev -> pctrl ) ;
    pinctrl_free ( gpio_dev -> pctrl ) ;
    return 0 ;
}
--------------------
static int amd_gpio_remove ( struct platform_device * pdev ) {
    struct amd_gpio * gpio_dev ;
    gpio_dev = platform_get_drvdata ( pdev ) ;
    gpiochip_remove ( & gpio_dev -> gc ) ;
    pinctrl_free ( gpio_dev -> pctrl ) ;
    return 0 ;
}
--------------------
static int amd_gpio_remove ( struct platform_device * pdev ) {
    struct amd_gpio * gpio_dev ;
    gpio_dev = platform_get_drvdata ( pdev ) ;
    pinctrl_unregister ( gpio_dev -> pctrl ) ;
    gpiochip_remove ( & gpio_dev -> gc ) ;
    return 0 ;
}
--------------------
static int amd_gpio_remove ( struct platform_device * pdev ) {
    struct amd_gpio * gpio_dev ;
    gpio_dev = platform_get_drvdata ( pdev ) ;
    pinctrl_put ( gpio_dev -> pctrl ) ;
    pinctrl_free_all ( gpio_dev -> pctrl ) ;
    gpiochip_remove ( & gpio_dev -> gc ) ;
    return 0 ;
}
--------------------
match:1
source:
 static void ptrace_link ( struct task_struct * child , struct task_struct * new_parent ) { <S2SV_StartBug> rcu_read_lock ( ) ; <S2SV_EndBug> <S2SV_StartBug> __ptrace_link ( child , new_parent , __task_cred ( new_parent ) ) ; <S2SV_EndBug> rcu_read_unlock ( ) ; }


target:
static void ptrace_link ( struct task_struct * child , struct task_struct * new_parent ) { __ptrace_link ( child , new_parent , __task_cred ( new_parent ) ) ; rcu_read_unlock ( ) ; }
outputs:
static int ptrace_link(struct task_struct *child, struct task_struct *new_parent) {
    if (!child || !new_parent) return -EINVAL;
    
    rcu_read_lock();
    __ptrace_link(child, new_parent, __task_cred(new_parent));
    rcu_read_unlock();

    return 0;
}
--------------------
static void ptrace_link(struct task_struct *child, struct task_struct *new_parent) {
    __ptrace_link(child, new_parent, __task_cred(new_parent));
}
--------------------
static DEFINE_MUTEX(ptrace_mutex);

static void ptrace_link(struct task_struct *child, struct task_struct *new_parent) {
    mutex_lock(&ptrace_mutex);
    __ptrace_link(child, new_parent, __task_cred(new_parent));
    mutex_unlock(&ptrace_mutex);
}
--------------------
static DEFINE_SPINLOCK(ptrace_lock);

static void ptrace_link(struct task_struct *child, struct task_struct *new_parent) {
    spin_lock(&ptrace_lock);
    __ptrace_link(child, new_parent, __task_cred(new_parent));
    spin_unlock(&ptrace_lock);
}
--------------------
static DECLARE_SEMAPHORE(ptrace_sem);

static void ptrace_link(struct task_struct *child, struct task_struct *new_parent) {
    down(&ptrace_sem);
    __ptrace_link(child, new_parent, __task_cred(new_parent));
    up(&ptrace_sem);
}
--------------------
static void ptrace_link(struct task_struct *child, struct task_struct *new_parent) {
    mutex_lock(&ptrace_mutex);
    __ptrace_link(child, new_parent, __task_cred(new_parent));
    mutex_unlock(&ptrace_mutex);

    /* add lockdep annotation to detect lock order issues */
    lockdep_assert_held(&ptrace_mutex);
}
--------------------
static DEFINE_MUTEX(ptrace_mutex);

static void ptrace_link(struct task_struct *child, struct task_struct *new_parent) {
    mutex_lock(&ptrace_mutex); /* acquire lock */
    lockdep_push_current(&new_parent->dep_map); /* push current lock into lockdep */
    __ptrace_link(child, new_parent, __task_cred(new_parent)); /* execute code */
    lockdep_pop_current(&new_parent->dep_map); /* pop current lock from lockdep */
    mutex_unlock(&ptrace_mutex); /* release lock */
}
--------------------
static DEFINE_RWLOCK(ptrace_rwlock);

static void ptrace_link(struct task_struct *child, struct task_struct *new_parent) {
    write_lock(&ptrace_rwlock); /* acquire write lock */
    __ptrace_link(child, new_parent, __task_cred(new_parent)); /* execute code */
    write_unlock(&ptrace_rwlock); /* release write lock */
}
--------------------
static DECLARE_COMPLETION(ptrace_completion);

static void ptrace_link(struct task_struct *child, struct task_struct *new_parent) {
    wait_for_completion(&ptrace_completion);
    __ptrace_link(child, new_parent, __task_cred(new_parent));
    complete(&ptrace_completion);
}
--------------------
static DEFINE_MUTEX(ptrace_mutex);
static DECLARE_WAIT_QUEUE_HEAD(ptrace_waitqueue);

static void ptrace_link(struct task_struct *child, struct task_struct *new_parent) {
    mutex_lock(&ptrace_mutex);
    while (!condition) { /* wait for condition */
        mutex_unlock(&ptrace_mutex);
        wait_event_interruptible(ptrace_waitqueue);
        mutex_lock(&ptrace_mutex);
    }
    
    __ptrace_link(child, new_parent, __task_cred(new_parent)); /* execute code */
    
    condition = true; /* signal condition */
    wake_up_all(&ptrace_waitqueue);
    
    mutex_unlock(&ptrace_mutex); /* release lock */
}
--------------------
match:0
source:
<S2SV_StartBug> static int jas_iccputuint ( jas_stream_t * out , int n , ulonglong val ) <S2SV_EndBug> { int i ; int c ; for ( i = n ; i > 0 ; -- i ) { c = ( val >> ( 8 * ( i - 1 ) ) ) & 0xff ; if ( jas_stream_putc ( out , c ) == EOF ) return - 1 ; } return 0 ; }

target:
static int jas_iccputuint ( jas_stream_t * out , int n , jas_ulonglong val ) { int i ; int c ; for ( i = n ; i > 0 ; -- i ) { c = ( val >> ( 8 * ( i - 1 ) ) ) & 0xff ; if ( jas_stream_putc ( out , c ) == EOF ) return - 1 ; } return 0 ; }

outputs:
static int jas_iccputuint(jas_stream_t *out, int n, uint64_t val) {
    int i, c;
    for (i = n; i > 0; --i){
        c = (val >> (8 * (i - 1))) & 0xff;
        if (jas_stream_putc(out, c) == EOF) {
            return -1;
        }
    }
    return 0;
}
--------------------
static int jas_iccputuint(jas_stream_t *out, int n, uint64_t val) {
    int i, c;
    for (i = n; i > 0; --i){
        c = (val >> (8 * (i - 1))) & 0xff;
        if (jas_stream_putc(out, (unsigned char)c) == EOF) {
            return -1;
        }
    }
    return 0;
}
--------------------
static int jas_iccputuint(jas_stream_t *out, int n, uint64_t val) {
    uint8_t c;
    int i;
    for (i = n; i > 0; --i) {
        c = (uint8_t)(val >> (8 * (i - 1)));
        if (jas_stream_putc(out, c) == EOF) {
            return -1;
        }
    }
    return 0;
}
--------------------
static int jas_iccputuint(jas_stream_t *out, int n, uint64_t val) {
    uint8_t c;
    int i;
    for (i = n; i > 0; --i) {
        c = (uint8_t)(val >> (8 * (n - i)));
        if (jas_stream_putc(out, c) == EOF) {
            return -1;
        }
    }
    return 0;
}
--------------------
static int jas_iccputuint(jas_stream_t *out, int n, uint64_t val) {
    int i, c;
    for (i = n-1; i >= 0; --i){
        c = (val >> (8 * i)) & 0xff;
        if (jas_stream_putc(out, c) == EOF) {
            return -1;
        }
    }
    return 0;
}
--------------------
static int jas_iccputuint ( jas_stream_t * out , int n , uint64_t val ) {
    int i , c ;
    for ( i = n - 1 ; i >= 0 ; -- i ) {
        c = ( val >> ( 8 * i ) ) & 0xff ;
        if ( jas_stream_putc ( out , c ) == EOF ) {
            return - 1 ;
        }
    }
    return 0 ;
}
--------------------
static int jas_iccputuint(jas_stream_t *out, int n, uint64_t val) {
    int i, c;
    for (i = n - 1; i >= 0; --i){
        c = (val >> (8 * i)) & 0xff;
        if (jas_stream_putc(out, c) == EOF) {
            return -1;
        } else if (val < (1ULL << (8 * (i+1)))) {
            break;
        }
    }
    return 0;
}
--------------------
static int jas_iccputuint(jas_stream_t *out, int n, uint64_t val)
{
    if( n > 8 )
      return -1;

    char buffer[sizeof(val)];
    for (unsigned i = 0; i < n; ++i) {
        buffer[i] = val & 0xFF;
        val >>= 8;
    }

    for (int i = n - 1; i >= 0; --i) {
        if (jas_stream_putc(out, buffer[i]) == EOF) {
            return -1;
        }
    }

    return 0;
}
--------------------
static int jas_iccputuint (jas_stream_t *out, int n, uint64_t val) {
    int i, c;
    for (i = n - 1; i >= 0; --i) {
        c = (val >> (8 * i));
        if (jas_stream_putc(out, c & 0xFF) == EOF) {
            return -1;
        }
    }
    return 0;
}
--------------------
static int jas_iccputuint(jas_stream_t *out, int n, uint64_t val) {
    int i;
    if (n > 8) {
        return -1;
    }

    for (i = n -1; i >= 0; i--) {
        uint8_t byte = (val >> (8 * i)) & 0xff;
        if (jas_stream_putc(out, byte) == EOF) {
            return -1;
        }
    }
    return 0;
}
--------------------
match:0
source:
<S2SV_StartBug> void vp9_cost_tokens_skip ( int * costs , const vp9_prob * probs , vp9_tree tree ) { <S2SV_EndBug> assert ( tree [ 0 ] <= 0 && tree [ 1 ] > 0 ) ; costs [ - tree [ 0 ] ] = vp9_cost_bit ( probs [ 0 ] , 0 ) ; cost ( costs , tree , probs , 2 , 0 ) ; }

target:
void vp9_cost_tokens_skip ( int * costs , const vpx_prob * probs , vp9_tree tree ) { assert ( tree [ 0 ] <= 0 && tree [ 1 ] > 0 ) ; costs [ - tree [ 0 ] ] = vp9_cost_bit ( probs [ 0 ] , 0 ) ; cost ( costs , tree , probs , 2 , 0 ) ; }

outputs:
void vp9_cost_tokens_skip(int* costs, const vp9_prob* probs, vp9_tree tree) {
  assert(tree[0] <= 0 && tree[1] > 0);
  costs[tree[0] * -1] = vp9_cost_bit(probs[0], 0);
  cost(costs, tree, probs, 2, 0);
}
--------------------
void vp9_cost_tokens_skip(int* costs, const vp9_prob* probs, vp9_tree tree) {
  assert(tree[0] <= 0 && tree[1] > 0);
  costs[-1 * tree[0]] = vp9_cost_bit(probs[0], 0);
  cost(costs, tree, probs, 2, 0);
}
--------------------
void vp9_cost_tokens_skip(int* costs, const vp9_prob* probs, vp9_tree tree) {
  assert(tree[0] <= 0 && tree[1] > 0);
  costs[-tree[0]] = vp9_cost_bit(probs[0], 0);
  cost(costs, tree, probs, 2, 0);
}
--------------------
void vp9_cost_tokens_skip(int* costs, const vp9_prob* probs, vp9_tree tree) {
  assert(tree[0] <= 0 && tree[1] > 0);
  costs[abs(tree[0])] = vp9_cost_bit(probs[0], 0);
  cost(costs, tree, probs, 2, 0);
}
--------------------
void vp9_cost_tokens_skip(int* costs, const vp9_prob* probs, vp9_tree tree) {
  assert(tree[0] <= 0 && tree[1] > 0);
  costs[-tree[0] - 1] = vp9_cost_bit(probs[0], 0);
  cost(costs, tree, probs, 2, 0);
}
--------------------
void vp9_cost_tokens_skip(int* costs, const vp9_prob* probs, vp9_tree tree) {
  assert(tree[0] <= 0 && tree[1] > 0);
  costs[tree[0] * -1 - 1] = vp9_cost_bit(probs[0], 0);
  cost(costs, tree, probs, 2, 0);
}
--------------------
void vp9_cost_tokens_skip(int* costs, const vp9_prob* probs, vp9_tree tree) {
  assert(tree[0] <= 0 && tree[1] > 0);
  costs[-tree[0] - 1] = vp9_cost_bit(probs[0], 0);
  cost(costs, tree, probs, 2, 0);
}
--------------------
void vp9_cost_tokens_skip(int* costs, const vp9_prob* probs, vp9_tree tree) {
  assert(tree[0] <= 0 && tree[1] > 0);
  costs[tree[0]] = vp9_cost_bit(probs[0], 0);
  cost(costs, tree, probs, 2, 0);
}
--------------------
void vp9_cost_tokens_skip(int* costs, const vp9_prob* probs, vp9_tree tree) {
  assert(tree[0] <= 0 && tree[1] > 0);
  costs[tree[0] * -1 - 1] = vp9_cost_bit(probs[0], 0);
  cost(costs, tree, probs, 2, 0);
}
--------------------
void vp9_cost_tokens_skip(int* costs, const vp9_prob* probs, vp9_tree tree) {
  assert(tree[0] <= 0 && tree[1] > 0);
  costs[-1 - tree[0]] = vp9_cost_bit(probs[0], 0);
  cost(costs, tree, probs, 2, 0);
}
--------------------
match:0
source:
 static inline int sctp_chunk_length_valid ( struct sctp_chunk * chunk , __u16 required_length ) { __u16 chunk_length = ntohs ( chunk -> chunk_hdr -> length ) ; <S2SV_StartBug> if ( unlikely ( chunk_length < required_length ) ) <S2SV_EndBug> return 0 ; return 1 ; }


target:
static inline int sctp_chunk_length_valid ( struct sctp_chunk * chunk , __u16 required_length ) { __u16 chunk_length = ntohs ( chunk -> chunk_hdr -> length ) ; if ( unlikely ( chunk -> pdiscard ) ) return 0 ; if ( unlikely ( chunk_length < required_length ) ) return 0 ; return 1 ; }
outputs:
static inline int sctp_chunk_length_valid(struct sctp_chunk* chunk, __u16 required_length) {
    if (chunk == NULL || chunk->chunk_hdr == NULL)
        return 0;

    __u16 chunk_length = ntohs(chunk->chunk_hdr->length);
    if (unlikely(chunk_length < required_length))
        return 0;

    return 1;
}
--------------------
static inline int sctp_chunk_length_valid(struct sctp_chunk* chunk, __u16 required_length) {
    if (chunk == NULL || chunk->chunk_hdr == NULL || required_length > USHRT_MAX)
        return 0;

    __u16 chunk_length = ntohs(chunk->chunk_hdr->length);
    if (unlikely(chunk_length < required_length))
        return 0;

    return 1;
}
--------------------
enum sctp_chunk_validation_result {
    SCTP_CHUNK_VALID,
    SCTP_CHUNK_INVALID_LENGTH,
    SCTP_CHUNK_NULL_POINTER
};

static inline enum sctp_chunk_validation_result sctp_chunk_length_valid(struct sctp_chunk* chunk, __u16 required_length) {
    if (chunk == NULL || chunk->chunk_hdr == NULL)
        return SCTP_CHUNK_NULL_POINTER;

    __u16 chunk_length = ntohs(chunk->chunk_hdr->length);
    if (unlikely(chunk_length < required_length))
        return SCTP_CHUNK_INVALID_LENGTH;

    return SCTP_CHUNK_VALID;
}
--------------------
static inline int sctp_chunk_length_valid(struct sctp_chunk* chunk, __u16 required_length) {
    if (chunk == NULL || chunk->chunk_hdr == NULL || required_length > USHRT_MAX)
        return 0;

    __u16 chunk_length = ntohs(chunk->chunk_hdr->length);
    if (chunk_length < required_length)
        return 0;

    return 1;
}
--------------------
static inline int sctp_chunk_length_valid(const struct sctp_chunk* chunk, __u16 required_length) {
    if (chunk == NULL || chunk->chunk_hdr == NULL || required_length > USHRT_MAX)
        return 0;

    __u16 chunk_length = ntohs(chunk->chunk_hdr->length);
    if (chunk_length < required_length)
        return 0;

    return 1;
}
--------------------
static inline int sctp_chunk_length_valid(const struct sctp_chunk* chunk, __u16 required_length) {
    return (chunk != NULL && 
            chunk->chunk_hdr != NULL && 
            required_length <= USHRT_MAX && 
            ntohs(chunk->chunk_hdr->length) >= required_length) ? 1 : 0;
}
--------------------
enum sctp_chunk_validation_result {
    SCTP_CHUNK_VALID,
    SCTP_CHUNK_INVALID_LENGTH,
    SCTP_CHUNK_NULL_POINTER,
    SCTP_CHUNK_INVALID_ARGUMENT
};

static inline enum sctp_chunk_validation_result sctp_chunk_length_valid(const struct sctp_chunk* chunk, __u16 required_length) {
    if (chunk == NULL || chunk->chunk_hdr == NULL)
        return SCTP_CHUNK_NULL_POINTER;

    if (required_length > USHRT_MAX)
        return SCTP_CHUNK_INVALID_ARGUMENT;
    
    __u16 chunk_length = ntohs(chunk->chunk_hdr->length);
    if (chunk_length < required_length)
        return SCTP_CHUNK_INVALID_LENGTH;

    return SCTP_CHUNK_VALID;
}
--------------------
enum sctp_chunk_validation_result {
    SCTP_CHUNK_VALID,
    SCTP_CHUNK_INVALID_LENGTH,
    SCTP_CHUNK_NULL_POINTER,
    SCTP_CHUNK_INVALID_ARGUMENT
};

static inline enum sctp_chunk_validation_result sctp_chunk_length_valid(const struct sctp_chunk* chunk, __u16 required_length) {
    if (chunk == NULL || chunk->chunk_hdr == NULL)
        return SCTP_CHUNK_NULL_POINTER;

    if (required_length > USHRT_MAX)
        return SCTP_CHUNK_INVALID_ARGUMENT;
    
    __u16 chunk_length = ntohs(chunk->chunk_hdr->length);
    if (chunk_length < required_length)
        return SCTP_CHUNK_INVALID_LENGTH;

    return SCTP_CHUNK_VALID;
}

const char* sctp_chunk_validation_result_message(enum sctp_chunk_validation_result result) {
    switch (result) {
    case SCTP_CHUNK_VALID:
        return "Valid SCTP chunk.";
    case SCTP_CHUNK_INVALID_LENGTH:
        return "Invalid SCTP chunk length.";
    case SCTP_CHUNK_NULL_POINTER:
        return "Null pointer error.";
    case SCTP_CHUNK_INVALID_ARGUMENT:
        return "Invalid argument error.";
    default:
        return "Unknown error.";
    }
}
--------------------
enum sctp_chunk_validation_result {
    SCTP_CHUNK_VALID,
    SCTP_CHUNK_INVALID_LENGTH,
    SCTP_CHUNK_NULL_POINTER,
    SCTP_CHUNK_INVALID_ARGUMENT
};

static inline enum sctp_chunk_validation_result sctp_validate_chunk_length(const struct sctp_chunk* chunk, __u16 required_length) {
    if (chunk == NULL || chunk->chunk_hdr == NULL)
        return SCTP_CHUNK_NULL_POINTER;

    if (required_length > USHRT_MAX)
        return SCTP_CHUNK_INVALID_ARGUMENT;
    
    __u16 chunk_length = ntohs(chunk->chunk_hdr->length);
    if (chunk_length < required_length)
        return SCTP_CHUNK_INVALID_LENGTH;

    return SCTP_CHUNK_VALID;
}

const char* sctp_chunk_validation_result_message(enum sctp_chunk_validation_result result) {
    switch (result) {
    case SCTP_CHUNK_VALID:
        return "Valid SCTP chunk.";
    case SCTP_CHUNK_INVALID_LENGTH:
        return "Invalid SCTP chunk length.";
    case SCTP_CHUNK_NULL_POINTER:
        return "Null pointer error.";
    case SCTP_CHUNK_INVALID_ARGUMENT:
        return "Invalid argument error.";
    default:
        return "Unknown error.";
    }
}
--------------------
static enum sctp_chunk_validation_result sctp_validate_chunk_length(const struct sctp_chunk* chunk, __u16 required_length) {
    if (chunk == NULL || chunk->chunk_hdr == NULL)
        return SCTP_CHUNK_NULL_POINTER;

    if (required_length > USHRT_MAX)
        return SCTP_CHUNK_INVALID_ARGUMENT;
    
    __u16 chunk_length = ntohs(chunk->chunk_hdr->length);
    if (chunk_length < required_length)
        return SCTP_CHUNK_INVALID_LENGTH;

    return SCTP_CHUNK_VALID;
}

const char* sctp_chunk_validation_result_message(enum sctp_chunk_validation_result result) {
    switch (result) {
    case SCTP_CHUNK_VALID:
        return "Valid SCTP chunk.";
    case SCTP_CHUNK_INVALID_LENGTH:
        return "Invalid SCTP chunk length.";
    case SCTP_CHUNK_NULL_POINTER:
        return "Null pointer error.";
    case SCTP_CHUNK_INVALID_ARGUMENT:
        return "Invalid argument error.";
    default:
        return "Unknown error.";
    }
}
--------------------
match:0
source:
 void Rectangle ( double x , double y , double w , double h ) { <S2SV_StartBug> outpos += sprintf ( outpos , "\\n%12.3f%12.3f%12.3f%12.3fre" , x , y , w , h ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>


target:
void Rectangle ( double x , double y , double w , double h ) { sprintf ( outputbuffer , "\\n%12.3f%12.3f%12.3f%12.3fre" , x , y , w , h ) ; sendClean ( outputbuffer ) ; }
outputs:
void Rectangle(double x, double y, double w, double h) {
    outpos += sprintf(outpos, "\\n%12.3f%12.3f%12.3f%12.3fre", x, y, w, h);
}
--------------------
void Rectangle(double x, double y, double w, double h) {
    char buffer[50];
    int ret = sprintf(buffer, "\\n%12.3f%12.3f%12.3f%12.3fre", x, y, w, h);
    if(ret < 0) {
        // handle error
    }
    strcat(outpos, buffer);
}
--------------------
void Rectangle(double x, double y, double w, double h) {
    if(outpos) {
        outpos += sprintf(outpos, "\\n%12.3f%12.3f%12.3f%12.3fre", x, y, w, h);
    }
}
--------------------
void Rectangle(double x, double y, double w, double h) {
    char buffer[50];
    int ret = snprintf(buffer, sizeof(buffer), "\\n%12.3f%12.3f%12.3f%12.3fre", x, y, w, h);
    if(ret < sizeof(buffer)) {
        strcat(outpos, buffer);
    }
}
--------------------
void Rectangle(double x, double y, double w, double h, char* outbuf, size_t outsize) {
    if(outbuf) {
        snprintf(outbuf, outsize, "\\n%12.3f%12.3f%12.3f%12.3fre", x, y, w, h);
    }
}
--------------------
void Rectangle(double x, double y, double w, double h) {
    char buffer[50];
    int ret = snprintf(buffer, sizeof(buffer), "\\n%12.3f%12.3f%12.3f%12.3fre", x, y, w, h);
    if(ret < sizeof(buffer)) {
        strncat(outpos, buffer, sizeof(outpos) - strlen(outpos) - 1);
    }
}
--------------------
struct StringBuilder {
    char* buffer;
    size_t size;
    size_t length;
};

void StringBuilder_Init(struct StringBuilder* builder, char* buffer, size_t size) {
    builder->buffer = buffer;
    builder->size = size;
    builder->length = 0;
}

void StringBuilder_Append(struct StringBuilder* builder, const char* str) {
    size_t len = strlen(str);
    if(builder->length + len < builder->size - 1) {
        strncat(builder->buffer, str, builder->size - builder->length - 1);
        builder->length += len;
    }
}

void Rectangle(double x, double y, double w, double h, struct StringBuilder* builder) {
    char buffer[50];
    int ret = snprintf(buffer, sizeof(buffer), "\\n%12.3f%12.3f%12.3f%12.3fre", x, y, w, h);
    if(ret < sizeof(buffer)) {
        StringBuilder_Append(builder, buffer);
    }
}
--------------------
#include <glib.h>

void Rectangle(double x, double y, double w, double h, GString* builder) {
    char buffer[50];
    int ret = snprintf(buffer, sizeof(buffer), "\\n%12.3f%12.3f%12.3f%12.3fre", x, y, w, h);
    if(ret < sizeof(buffer)) {
        g_string_append(builder, buffer);
    }
}
--------------------
void AppendFormattedString(char* outbuf, size_t outsize, const char* format, ...) {
    va_list args;
    va_start(args, format);
    vsnprintf(outbuf, outsize, format, args);
    va_end(args);
}

void Rectangle(double x, double y, double w, double h) {
    char buffer[50];
    AppendFormattedString(buffer, sizeof(buffer), "\\n%12.3f%12.3f%12.3f%12.3fre", x, y, w, h);
    strncat(outpos, buffer, sizeof(outpos) - strlen(outpos) - 1);
}
--------------------
#include <string>
#include <sstream>

void Rectangle(double x, double y, double w, double h) {
    std::ostringstream oss;
    oss << "\\n";
    oss.precision(3);
    oss << std::fixed << std::setw(12) << x
        << std::setw(12) << y
        << std::setw(12) << w
        << std::setw(12) << h
        << "re";
    std::string str = oss.str();
    outpos += str;
}
--------------------
match:0
source:
 <S2SV_StartBug> static int getnum ( const char * * fmt , int df ) { <S2SV_EndBug> if ( ! isdigit ( * * fmt ) ) return df ; else { int a = 0 ; <S2SV_StartBug> do { <S2SV_EndBug> a = a * 10 + * ( ( * fmt ) ++ ) - '0' ; } while ( isdigit ( * * fmt ) ) ; return a ; } }


target:
static int getnum ( lua_State * L , const char * * fmt , int df ) { if ( ! isdigit ( * * fmt ) ) return df ; else { int a = 0 ; do { if ( a > ( INT_MAX / 10 ) || a * 10 > ( INT_MAX - ( * * fmt - '0' ) ) ) luaL_error ( L , "integralsizeoverflow" ) ; a = a * 10 + * ( ( * fmt ) ++ ) - '0' ; } while ( isdigit ( * * fmt ) ) ; return a ; } }
outputs:
static int getnum ( const char* fmt , int df ) {
	if ( ! isdigit ( * fmt ) ) 
		return df ; 
	else { 
		int a = 0 ; 
		do { 
			a = a * 10 + *fmt - '0' ; 
		} while ( isdigit ( *(++fmt) ) ); 
		return a ; 
	} 
}
--------------------
static int getnum ( const char* fmt , int df ) {
	if ( !fmt ) 
	   return df;
	if ( ! isdigit ( * fmt ) ) 
		return df ; 
	else { 
		int a = 0 ; 
		do { 
			a = a * 10 + *fmt - '0' ; 
		} while ( isdigit ( *(++fmt) ) ); 
		return a ; 
	} 
}
--------------------
static int getnum ( const char* fmt , int df ) {
	if ( !fmt )
        return df;
    if ( *fmt == '\0')
        return df;
	if ( ! isdigit ( * fmt ) ) 
		return df ; 
	else { 
		int a = 0 ; 
		do { 
			a = a * 10 + *fmt - '0' ; 
		} while ( isdigit ( *(++fmt) ) ); 
		return a ; 
	} 
}
--------------------
static int getnum ( const char* fmt , int df ) {
	if ( !fmt )
        return df;
    if ( *fmt == '\0')
        return df;
	if ( ! isdigit ( * fmt ) ) 
		return df ; 
	else { 
		int a = 0 ; 
		do { 
			a = a * 10 + *(fmt++) - '0' ; 
		} while ( isdigit ( *fmt ) ); 
		return a ; 
	} 
}
--------------------
static int getnum ( const char* fmt , int df ) {
	if ( !fmt )
        return df;
    if ( *fmt == '\0')
        return df;
	char c = *fmt;
	if ( ! isdigit ( c ) ) 
		return df ; 
	else { 
		int a = 0 ; 
		do { 
			a = a * 10 + (c - '0') ; 
            c = *(++fmt);
		} while ( isdigit ( c ) ); 
		return a ; 
	} 
}
--------------------
static int getnum ( const char* fmt , int df ) {
	if ( !fmt )
        return df;
    if ( *fmt == '\0')
        return df;
	char c = *fmt;
	if ( ! isdigit ( c ) ) 
		return df ; 
	else { 
		int a = 0 ;
        for (; isdigit(c); c = *(++fmt)) { 
			a = a * 10 + (c - '0') ; 
		}
		return a ; 
	} 
}
--------------------
static int getnum ( const char* fmt , int df ) {
	if ( !fmt )
        return df;
    if ( *fmt == '\0')
        return df;
	char c = *fmt;
	if ( ! isdigit ( c ) ) 
		return df ; 
	else { 
		int a = 0 ;
        for (; isdigit(c); c = *(++fmt)) { 
			a = a * 10 + (c - '0') ;
            if (a > INT_MAX/10) // upper bound check 
               return df;
            if (a == INT_MAX / 10 && (c - '0') > INT_MAX % 10) // lower bound check
                return df;
		}
		return a ; 
	} 
}
--------------------
static int getnum ( const char* fmt , int df ) {
	if ( !fmt )
        return df;
    if ( *fmt == '\0')
        return df;
	char c = *fmt;
	int a = df ; 
    if ( isdigit ( c ) ) { 
        a = 0 ;
        for (; isdigit(c); c = *(++fmt)) { 
			a = a * 10 + (c - '0') ;
            if (a > INT_MAX/10) // upper bound check 
               return df;
            if (a == INT_MAX / 10 && (c - '0') > INT_MAX % 10) // lower bound check
                return df;
		}
	}
	return a ; 
}
--------------------
static int getnum ( const char* fmt , int df ) {
    static const int INT_MAX_BY_10 = INT_MAX / 10;
	if ( !fmt )
        return df;
    if ( *fmt == '\0')
        return df;
	char c = *fmt;
	int a = df ; 
    if ( isdigit ( c ) ) { 
        a = 0 ;
        for (; isdigit(c); c = *(++fmt)) { 
			a = a * 10 + (c - '0') ;
            if (a > INT_MAX_BY_10) // upper bound check 
               return df;
            if (a == INT_MAX_BY_10 && (c - '0') > INT_MAX % 10) // lower bound check
                return df;
		}
	}
	return a ; 
}
--------------------
static int getnum(const char* numStr, int dfValue)
{
    static const int INT_MAX_BY_10 = INT_MAX / 10;
    if (!numStr) 
        return dfValue;
    if (*numStr == '\0')
        return dfValue;
    char c = *numStr;
    int a = dfValue; 
    if (isdigit(c)) 
    { 
        a = 0;
        for (; isdigit(c); c = *(++numStr)) 
        { 
            a = a * 10 + (c - '0') ;
            if (a > INT_MAX_BY_10) 
                return dfValue;
            if (a == INT_MAX_BY_10 && (c - '0') > INT_MAX % 10) 
                return dfValue;
        }
    }
    return a; 
}
--------------------
match:0
source:
<S2SV_StartBug> static TX_MODE read_tx_mode ( vp9_reader * r ) { <S2SV_EndBug> <S2SV_StartBug> TX_MODE tx_mode = vp9_read_literal ( r , 2 ) ; <S2SV_EndBug> if ( tx_mode == ALLOW_32X32 ) <S2SV_StartBug> tx_mode += vp9_read_bit ( r ) ; <S2SV_EndBug> return tx_mode ; }

target:
static TX_MODE read_tx_mode ( vpx_reader * r ) { TX_MODE tx_mode = vpx_read_literal ( r , 2 ) ; if ( tx_mode == ALLOW_32X32 ) tx_mode += vpx_read_bit ( r ) ; return tx_mode ; }

outputs:
static TX_MODE read_tx_mode ( vp9_reader * r ) {
  TX_MODE tx_mode = vp9_read_literal ( r , 2 ) ;
  if (tx_mode == ALLOW_32X32) {
    tx_mode += vp9_read_bit ( r ) ;
  }
  return tx_mode ;
}
--------------------
static TX_MODE read_tx_mode ( vp9_reader * r ) {
  TX_MODE tx_mode = vp9_read_literal ( r , 2 ) ;
  if (tx_mode == ALLOW_32X32) {
    tx_mode = (TX_MODE)(tx_mode + vp9_read_bit ( r ));
  }
  return tx_mode ;
}
--------------------
static TX_MODE read_tx_mode ( vp9_reader * r ) {
  TX_MODE tx_mode = vp9_read_literal ( r , 2 ) ;
  if (tx_mode == ALLOW_32X32) {
    tx_mode = static_cast<TX_MODE>(tx_mode + vp9_read_bit ( r ));
  }
  return tx_mode ;
}
--------------------
enum class TX_MODE : uint8_t {
  ONLY_4X4 = 0,
  ALLOW_8X8 = 1,
  ALLOW_16X16 = 2,
  ALLOW_32X32 = 3
};

static TX_MODE read_tx_mode ( vp9_reader * r ) {
  TX_MODE tx_mode = static_cast<TX_MODE>(vp9_read_literal ( r , 2 ));
  if (tx_mode == TX_MODE::ALLOW_32X32) {
    tx_mode = static_cast<TX_MODE>(tx_mode + vp9_read_bit ( r ));
  }
  return tx_mode ;
}
--------------------
enum TX_MODE {
  ONLY_4X4,
  ALLOW_8X8,
  ALLOW_16X16,
  ALLOW_32X32
};

static TX_MODE read_tx_mode ( vp9_reader * r ) {
  TX_MODE tx_mode = static_cast<TX_MODE>(vp9_read_literal ( r , 2 ));
  if (tx_mode == ALLOW_32X32) {
    tx_mode = static_cast<TX_MODE>(tx_mode + vp9_read_bit ( r ));
  }
  return tx_mode ;
}
--------------------
enum TX_MODE {
  ONLY_4X4,
  ALLOW_8X8,
  ALLOW_16X16,
  ALLOW_32X32
};

static TX_MODE read_tx_mode ( vp9_reader * r ) {
  TX_MODE tx_mode = static_cast<TX_MODE>(vp9_read_literal ( r , 2 ));
  if (tx_mode == ALLOW_32X32) {
    tx_mode = (TX_MODE)(tx_mode + vp9_read_bit ( r ));
  }
  return tx_mode ;
}
--------------------
enum TX_MODE {
  ONLY_4X4,
  ALLOW_8X8,
  ALLOW_16X16,
  ALLOW_32X32
};

static TX_MODE read_tx_mode ( vp9_reader * r ) {
  TX_MODE tx_mode = static_cast<TX_MODE>(vp9_read_literal ( r , 2 ));
  if (tx_mode == ALLOW_32X32) {
    tx_mode = static_cast<TX_MODE>(tx_mode + !!vp9_read_bit(r));
  }
  return tx_mode ;
}
--------------------
enum TX_MODE {
  ONLY_4X4,
  ALLOW_8X8,
  ALLOW_16X16,
  ALLOW_32X32
};

static TX_MODE read_tx_mode ( vp9_reader * r ) {
  TX_MODE tx_mode = static_cast<TX_MODE>(vp9_read_literal ( r , 2 ));
  if (tx_mode == ALLOW_32X32) {
    tx_mode = static_cast<TX_MODE>(tx_mode + static_cast<int>(vp9_read_bit ( r )));
  }
  return tx_mode ;
}
--------------------
enum TX_MODE {
  ONLY_4X4,
  ALLOW_8X8,
  ALLOW_16X16,
  ALLOW_32X32
};

static TX_MODE read_tx_mode ( vp9_reader * r ) {
  TX_MODE tx_mode = static_cast<TX_MODE>(vp9_read_literal ( r , 2 ));
  if (tx_mode == ALLOW_32X32) {
    tx_mode = static_cast<TX_MODE>(tx_mode + vp9_read_bit ( r ) ? 1 : 0);
  }
  return tx_mode ;
}
--------------------
enum TX_MODE {
  ONLY_4X4,
  ALLOW_8X8,
  ALLOW_16X16,
  ALLOW_32X32
};

static TX_MODE read_tx_mode ( vp9_reader * r ) {
  TX_MODE tx_mode = static_cast<TX_MODE>(vp9_read_literal ( r , 2 ));
  if (tx_mode == ALLOW_32X32) {
    tx_mode = static_cast<TX_MODE>(tx_mode + static_cast<TX_MODE>(vp9_read_bit ( r )));
  }
  return tx_mode ;
}
--------------------
match:0
source:
static int linear_ioctl ( struct dm_target * ti , unsigned int cmd , unsigned long arg ) { struct linear_c * lc = ( struct linear_c * ) ti -> private ; <S2SV_StartBug> return __blkdev_driver_ioctl ( lc -> dev -> bdev , lc -> dev -> mode , cmd , arg ) ; <S2SV_EndBug> }

target:
static int linear_ioctl ( struct dm_target * ti , unsigned int cmd , unsigned long arg ) { struct linear_c * lc = ( struct linear_c * ) ti -> private ; struct dm_dev * dev = lc -> dev ; int r = 0 ; if ( lc -> start || ti -> len != i_size_read ( dev -> bdev -> bd_inode ) >> SECTOR_SHIFT ) r = scsi_verify_blk_ioctl ( NULL , cmd ) ; return r ? : __blkdev_driver_ioctl ( dev -> bdev , dev -> mode , cmd , arg ) ; }

outputs:
static int linear_ioctl ( struct dm_target * ti , unsigned int cmd , unsigned long arg ) {
  struct linear_c * lc = ( struct linear_c * ) ti -> private ;
  return __blkdev_driver_ioctl ( lc -> dev -> bdev , lc -> dev -> mode , cmd , arg ) ;
}
--------------------
static int linear_ioctl ( struct dm_target * ti , unsigned int cmd , unsigned long arg ) {
  struct linear_c * lc = ( struct linear_c * ) ti -> private ;
  int ret = __blkdev_driver_ioctl ( lc -> dev -> bdev , lc -> dev -> mode , cmd , arg ) ;
  if (ret < 0) {
    return ret;
  }
  return ret;
}
--------------------
static int linear_ioctl ( struct dm_target * ti , unsigned long cmd , unsigned long arg ) {
  struct linear_c * lc = ( struct linear_c * ) ti -> private ;
  int ret = __blkdev_driver_ioctl ( lc -> dev -> bdev , lc -> dev -> mode , cmd , arg ) ;
  if (ret < 0) {
    return ret;
  }
  return ret;
}
--------------------
static int linear_ioctl ( struct dm_target * ti , unsigned long cmd , unsigned long arg ) {
  struct linear_c * lc = ( struct linear_c * ) ti -> private ;
  if (!lc->dev) {
    return -ENODEV;
  }
  int ret = __blkdev_driver_ioctl ( lc -> dev -> bdev , lc -> dev -> mode , cmd , arg ) ;
  if (ret < 0) {
    return ret;
  }
  return ret;
}
--------------------
static int linear_ioctl ( struct dm_target * ti , unsigned long cmd , unsigned long arg ) {
  struct linear_c * lc = ( struct linear_c * ) ti -> private ;
  if (!lc->dev) {
    return -ENODEV;
  }
  unsigned long ret = __blkdev_driver_ioctl ( lc -> dev -> bdev , lc -> dev -> mode , cmd , arg ) ;
  if (ret < 0) {
    return ret;
  }
  return ret;
}
--------------------
static int linear_ioctl ( struct dm_target * ti , unsigned long cmd , unsigned long arg ) {
  struct linear_c * lc = ti->private;
  if (!lc->dev) {
    return -ENODEV;
  }
  unsigned long ret = __blkdev_driver_ioctl ( lc->dev->bdev, lc->dev->mode, cmd, arg ) ;
  if (ret < 0) {
    return ret;
  }
  return ret;
}
--------------------
static int linear_ioctl ( struct dm_target * ti , unsigned long cmd , unsigned long arg ) {
  struct linear_c * linear = ti->private;
  if (!linear->dev) {
    return -ENODEV;
  }
  unsigned long ret = __blkdev_driver_ioctl ( linear->dev->bdev, linear->dev->mode, cmd, arg ) ;
  if (ret < 0) {
    return ret;
  }
  return ret;
}
--------------------
static int linear_ioctl ( struct dm_target * ti , unsigned long cmd , unsigned long arg ) {
  struct linear_c * linear;
  unsigned long ret;

  linear = ti->private;
  if (!linear->dev) {
    return -ENODEV;
  }
  ret = __blkdev_driver_ioctl ( linear->dev->bdev, linear->dev->mode, cmd, arg ) ;
  if (ret < 0) {
    return ret;
  }
  return ret;
}
--------------------
static int linear_ioctl ( struct dm_target * ti , unsigned long cmd , unsigned long arg ) {
  struct linear_c * linear = ti->private;
  unsigned long ret = (!linear->dev) ? -ENODEV : __blkdev_driver_ioctl ( linear->dev->bdev, linear->dev->mode, cmd, arg ) ;
  if (ret < 0) {
    return ret;
  }
  return ret;
}
--------------------
static int linear_ioctl ( struct dm_target * ti , unsigned long cmd , unsigned long arg ) {
  struct linear_c * linear = ti->private;
  unsigned long ret;

  switch (cmd) {
    case IOCTL_READ:
      ret = blkdev_read(linear->dev->bdev, arg);
      break;
    case IOCTL_WRITE:
      ret = blkdev_write(linear->dev->bdev, arg);
      break;
    default:
      ret = -EINVAL;
      break;
  }

  if (ret < 0) {
    return ret;
  }
  return ret;
}
--------------------
match:0
source:
<S2SV_StartBug> static void buffer_pipe_buf_get ( struct pipe_inode_info * pipe , <S2SV_EndBug> struct pipe_buffer * buf ) { struct buffer_ref * ref = ( struct buffer_ref * ) buf -> private ; <S2SV_StartBug> ref -> ref ++ ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>

target:
static bool buffer_pipe_buf_get ( struct pipe_inode_info * pipe , struct pipe_buffer * buf ) { struct buffer_ref * ref = ( struct buffer_ref * ) buf -> private ; if ( ref -> ref > INT_MAX / 2 ) return false ; ref -> ref ++ ; return true ; }

outputs:
static void buffer_pipe_buf_get ( struct pipe_inode_info * pipe , struct pipe_buffer * buf ) {
    struct buffer_ref * ref = ( struct buffer_ref * ) buf -> private ;
    ref -> ref ++;
}
--------------------
static void buffer_pipe_buf_get ( struct pipe_inode_info * pipe , struct pipe_buffer * buf ) {
    struct buffer_ref * ref = ( struct buffer_ref * ) buf -> private ;
    ref -> ref += 1;
}
--------------------
static void buffer_pipe_buf_get ( struct pipe_inode_info * pipe , struct pipe_buffer * buf ) {
    struct buffer_ref * ref = ( struct buffer_ref * ) buf -> private ;
    ref -> ref = ref -> ref + 1;
}
--------------------
static void buffer_pipe_buf_get ( struct pipe_inode_info * pipe , struct pipe_buffer * buf ) {
    struct buffer_ref * ref = ( struct buffer_ref * ) buf -> private ;
    ++ref -> ref;
}
--------------------
static void buffer_pipe_buf_get ( struct pipe_inode_info * pipe , struct pipe_buffer * buf ) {
    struct buffer_ref * ref = ( struct buffer_ref * ) buf -> private ;
    ref -> ref = ref -> ref + 1;
}
--------------------
static void buffer_pipe_buf_get ( struct pipe_inode_info * pipe , struct pipe_buffer * buf ) {
    struct buffer_ref * ref = ( struct buffer_ref * ) buf -> private ;
    ref -> ref += 1;
}
--------------------
static void buffer_pipe_buf_get ( struct pipe_inode_info * pipe , struct pipe_buffer * buf ) {
    struct buffer_ref * ref = ( struct buffer_ref * ) buf -> private ;
    ++(ref -> ref);
}
--------------------
static void buffer_pipe_buf_get ( struct pipe_inode_info * pipe , struct pipe_buffer * buf ) {
    struct buffer_ref * ref = ( struct buffer_ref * ) buf -> private ;
    ref -> ref = ref -> ref + 1;
}
--------------------
static void buffer_pipe_buf_get ( struct pipe_inode_info * pipe , struct pipe_buffer * buf ) {
    struct buffer_ref * ref = ( struct buffer_ref * ) buf -> private ;
    ++ref -> ref;
}
--------------------
static void buffer_pipe_buf_get ( struct pipe_inode_info * pipe , struct pipe_buffer * buf ) {
    struct buffer_ref * ref = ( struct buffer_ref * ) buf -> private ;
    ref -> ref++;
}
--------------------
match:0
source:
static inline int btif_hl_select_close_connected ( void ) { char sig_on = btif_hl_signal_select_close_connected ; BTIF_TRACE_DEBUG ( "btif_hl_select_close_connected" ) ; <S2SV_StartBug> return send ( signal_fds [ 1 ] , & sig_on , sizeof ( sig_on ) , 0 ) ; <S2SV_EndBug> }

target:
static inline int btif_hl_select_close_connected ( void ) { char sig_on = btif_hl_signal_select_close_connected ; BTIF_TRACE_DEBUG ( "btif_hl_select_close_connected" ) ; return TEMP_FAILURE_RETRY ( send ( signal_fds [ 1 ] , & sig_on , sizeof ( sig_on ) , 0 ) ) ; }

outputs:
static inline int btif_hl_select_close_connected(void) {
    char sig_on = btif_hl_signal_select_close_connected;
    BTIF_TRACE_DEBUG("btif_hl_select_close_connected");
    int result = write(signal_fds[1], &sig_on, sizeof(sig_on));
    if (result < 0) {
        BTIF_TRACE_WARNING("Failed to write to signal_fd[1]: %d", result);
    }
    return result;
}
--------------------
static inline int btif_hl_select_close_connected(void) {
    char sig_on = btif_hl_signal_select_close_connected;
    BTIF_TRACE_DEBUG("btif_hl_select_close_connected");
    int result = send(signal_fds[1], &sig_on, sizeof(sig_on), MSG_NOSIGNAL);
    if (result < 0) {
        BTIF_TRACE_WARNING("Failed to send signal to peer: %d (%s)", errno, strerror(errno));
    }
    return result;
}
--------------------
static inline int btif_hl_select_close_connected(void) {
    char sig_on = btif_hl_signal_select_close_connected;
    BTIF_TRACE_DEBUG("btif_hl_select_close_connected");
    int flags = fcntl(signal_fds[1], F_GETFL);
    if (flags == -1) {
        BTIF_TRACE_WARNING("Failed to get signal_fd[1] flags: %d (%s)", errno, strerror(errno));
        return -1;
    }
    if (fcntl(signal_fds[1], F_SETFL, flags | O_NONBLOCK) == -1) {
        BTIF_TRACE_WARNING("Failed to set signal_fd[1] to non-blocking: %d (%s)", errno, strerror(errno));
        return -1;
    }
    int result = write(signal_fds[1], &sig_on, sizeof(sig_on));
    if (result < 0 && errno != EAGAIN) {
        BTIF_TRACE_WARNING("Failed to write to signal_fd[1]: %d (%s)", result, strerror(errno));
        return -1;
    }
    return result;
}
--------------------
static inline int btif_hl_select_close_connected(void) {
    char sig_on = btif_hl_signal_select_close_connected;
    BTIF_TRACE_DEBUG("btif_hl_select_close_connected");
    io_uring_sqe* sqe = io_uring_get_sqe(&ring);
    if (!sqe) {
        BTIF_TRACE_WARNING("Failed to get I/O submission queue element");
        return -1;
    }
    io_uring_prep_write(sqe, signal_fds[1], &sig_on, sizeof(sig_on), 0);
    io_uring_submit(&ring);
    io_uring_wait_cqe(&ring, &cqe);
    int result = cqe->res;
    if (result < 0) {
        BTIF_TRACE_WARNING("Failed to write to signal_fd[1]: %d (%s)", result, strerror(-result));
    }
    io_uring_cqe_seen(&ring, cqe);
    return result;
}
--------------------
static inline int btif_hl_select_close_connected(void) {
    char sig_on = btif_hl_signal_select_close_connected;
    BTIF_TRACE_DEBUG("btif_hl_select_close_connected");
    int result = syscall(__NR_write, signal_fds[1], &sig_on, sizeof(sig_on));
    if (result < 0) {
        BTIF_TRACE_WARNING("Failed to write to signal_fd[1]: %d (%s)", result, strerror(errno));
    }
    return result;
}
--------------------
static inline int btif_hl_select_close_connected(void) {
    char sig_on = btif_hl_signal_select_close_connected;
    BTIF_TRACE_DEBUG("btif_hl_select_close_connected");
    std::lock_guard<std::mutex> lock(signal_mutex);
    int result = write(signal_fds[1], &sig_on, sizeof(sig_on));
    if (result < 0) {
        BTIF_TRACE_WARNING("Failed to write to signal_fd[1]: %d (%s)", result, strerror(errno));
    }
    return result;
}
--------------------
static inline int btif_hl_select_close_connected(void) {
    char sig_on = btif_hl_signal_select_close_connected;
    BTIF_TRACE_DEBUG("btif_hl_select_close_connected");
    int result = write(signal_fds[1], &sig_on, sizeof(sig_on));
    if (result < 0) {
        if (errno != EAGAIN) {
            BTIF_TRACE_WARNING("Failed to write to signal_fd[1]: %d (%s)", result, strerror(errno));
        }
    }
    return result;
}
--------------------
static inline int btif_hl_select_close_connected(void) {
    char sig_on = btif_hl_signal_select_close_connected;
    BTIF_TRACE_DEBUG("btif_hl_select_close_connected");
    int result = TEMP_FAILURE_RETRY(write(signal_fds[1], &sig_on, sizeof(sig_on)));
    if (result < 0) {
        BTIF_TRACE_WARNING("Failed to write to signal_fd[1]: %d (%s)", result, strerror(errno));
    }
    return result;
}
--------------------
static inline int btif_hl_select_close_connected(void) {
    char sig_on = btif_hl_signal_select_close_connected;
    BTIF_TRACE_DEBUG("btif_hl_select_close_connected");
    struct iovec iov = {&sig_on, sizeof(sig_on)};
    struct msghdr msg = {NULL, 0, &iov, 1, NULL, 0, 0};
    int result = sendmsg(signal_fds[1], &msg, 0);
    if (result < 0) {
        BTIF_INFO("Failed to send signal to peer: %d (%s)", errno, strerror(errno));
    }
    return result;
}
--------------------
static inline int btif_hl_select_close_connected(void) {
    char sig_on = btif_hl_signal_select_close_connected;
    BTIF_TRACE_DEBUG("btif_hl_select_close_connected");
    int result = TEMP_FAILURE_RETRY(send(signal_fds[1], &sig_on, sizeof(sig_on), MSG_NOSIGNAL));
    if (result < 0) {
        BTIF_TRACE_WARNING("Failed to send signal to peer: %d (%s)", errno, strerror(errno));
    }
    return result;
}
--------------------
match:0
source:
<S2SV_StartBug> void ntlm_free_message_fields_buffer ( NTLM_MESSAGE_FIELDS * fields ) <S2SV_EndBug> { if ( fields ) { if ( fields -> Buffer ) { free ( fields -> Buffer ) ; fields -> Len = 0 ; fields -> MaxLen = 0 ; fields -> Buffer = NULL ; fields -> BufferOffset = 0 ; } } }

target:
static void ntlm_free_message_fields_buffer ( NTLM_MESSAGE_FIELDS * fields ) { if ( fields ) { if ( fields -> Buffer ) { free ( fields -> Buffer ) ; fields -> Len = 0 ; fields -> MaxLen = 0 ; fields -> Buffer = NULL ; fields -> BufferOffset = 0 ; } } }

outputs:
void ntlm_free_message_fields_buffer ( NTLM_MESSAGE_FIELDS * fields ) {
    if ( fields ) {
        if ( fields -> Buffer ) {
            free ( fields -> Buffer ) ;
            fields -> Buffer = NULL ;
            fields -> Len = 0 ;
            fields -> MaxLen = 0 ;
            fields -> BufferOffset = 0 ;
        }
    }
}
--------------------
void ntlm_free_message_fields_buffer ( NTLM_MESSAGE_FIELDS * fields ) {
    if ( fields != NULL ) {
        if ( fields -> Buffer != NULL ) {
            free ( fields -> Buffer ) ;
            fields -> Len = 0 ;
            fields -> MaxLen = 0 ;
            fields -> Buffer = NULL ;
            fields -> BufferOffset = 0 ;
        }
    }
}
--------------------
void ntlm_free_message_fields_buffer ( NTLM_MESSAGE_FIELDS * fields ) {
    if ( fields == NULL ) {
        return;
    }
    if ( fields -> Buffer == NULL ) {
        return;
    }
    free ( fields -> Buffer ) ;
    fields -> Len = 0 ;
    fields -> MaxLen = 0 ;
    fields -> Buffer = NULL ;
    fields -> BufferOffset = 0 ;
}
--------------------
void ntlm_free_message_fields_buffer ( NTLM_MESSAGE_FIELDS * fields ) {
    if ( fields->Buffer != NULL ) {
        free ( fields->Buffer );
    }
    fields->Buffer = NULL;
    fields->Len = 0;
    fields->MaxLen = 0;
    fields->BufferOffset = 0;
}
--------------------
void ntlm_free_message_fields_buffer ( NTLM_MESSAGE_FIELDS * fields ) {
    if (fields == NULL) {
        return;
    }
    if (fields->Buffer == NULL) {
        return;
    }
    free(fields->Buffer);
    fields->Buffer = NULL;
    fields->Len = 0;
    fields->MaxLen = 0;
    fields->BufferOffset = 0;
}
--------------------
void ntlm_free_message_fields_buffer ( NTLM_MESSAGE_FIELDS * fields ) {
    if (fields == NULL || fields->Buffer == NULL) {
        return;
    }
    free(fields->Buffer);
    fields->Buffer = NULL;
    fields->Len = 0;
    fields->MaxLen = 0;
    fields->BufferOffset = 0;

}
--------------------
void ntlm_free_message_fields_buffer(NTLM_MESSAGE_FIELDS *fields) {
    if (fields != NULL && fields->Buffer != NULL) {
        free(fields->Buffer);
        fields->Buffer = NULL;
        fields->Len = 0;
        fields->MaxLen = 0;
        fields->BufferOffset = 0;
    }
}
--------------------
void ntlm_free_message_fields_buffer(NTLM_MESSAGE_FIELDS* fields) {
    if (fields == NULL) {
        return;
    }
    if (fields->Buffer != NULL) {
        free(fields->Buffer);
    }
    fields->Len = 0;
    fields->MaxLen = 0;
    fields->Buffer = NULL;
    fields->BufferOffset = 0;
}
--------------------
void ntlm_free_message_fields_buffer(NTLM_MESSAGE_FIELDS* fields) {
    if (fields == NULL || fields->Buffer == NULL) {
        return;
    }
    free(fields->Buffer);
    fields->Len = 0;
    fields->MaxLen = 0;
    fields->Buffer = NULL;
    fields->BufferOffset = 0;
}
--------------------
void ntlm_free_message_fields_buffer ( NTLM_MESSAGE_FIELDS * fields ) {
    if ( fields && fields -> Buffer ) {
        free(fields->Buffer);
        fields->Len=0;
        fields->MaxLen=0;
        fields->Buffer=NULL;
        fields->BufferOffset=0;
    }
}
--------------------
match:0
source:
void vp9_lookahead_destroy ( struct lookahead_ctx * ctx ) { if ( ctx ) { if ( ctx -> buf ) { unsigned int i ; for ( i = 0 ; i < ctx -> max_sz ; i ++ ) <S2SV_StartBug> vp9_free_frame_buffer ( & ctx -> buf [ i ] . img ) ; <S2SV_EndBug> free ( ctx -> buf ) ; } free ( ctx ) ; } }

target:
void vp9_lookahead_destroy ( struct lookahead_ctx * ctx ) { if ( ctx ) { if ( ctx -> buf ) { unsigned int i ; for ( i = 0 ; i < ctx -> max_sz ; i ++ ) vpx_free_frame_buffer ( & ctx -> buf [ i ] . img ) ; free ( ctx -> buf ) ; } free ( ctx ) ; } }

outputs:
if (ctx->buf && ctx->max_sz > 0) {
  for (unsigned int i = 0; i < ctx->max_sz; i++) {
    vp9_free_frame_buffer(&ctx->buf[i].img);
  }
  free(ctx->buf);
}
--------------------
if (ctx->buf) {
  unsigned int i = 0;
  while (i < ctx->max_sz) {
    vp9_free_frame_buffer(&ctx->buf[i].img);
    i++;
  }
  free(ctx->buf);
}
--------------------
if (ctx->buf) {
  unsigned int i = 0;
  do {
    vp9_free_frame_buffer(&ctx->buf[i].img);
    i++;
  } while (i < ctx->max_sz);
  free(ctx->buf);
}
--------------------
if (ctx) {
  unsigned int i = 0;
  while (i < ctx->max_sz && ctx->buf != NULL) {
    vp9_free_frame_buffer(&ctx->buf[i].img);
    i++;
  }
  free(ctx->buf);
  free(ctx);
}
--------------------
if (ctx) {
  if (ctx->buf) {
    unsigned int i = 0;
    while (i < ctx->max_sz) {
      vp9_free_frame_buffer(&ctx->buf[i++].img);
    }
    free(ctx->buf);
  }
  free(ctx);
}
--------------------
if (ctx) {
  if (ctx->buf) {
    for (unsigned int i = ctx->max_sz; i > 0; --i) {
      vp9_free_frame_buffer(&ctx->buf[i - 1].img);
    }
    free(ctx->buf);
  }
  free(ctx);
}
--------------------
if (ctx) {
  if (ctx->buf) {
    memset(ctx->buf, 0, sizeof(*ctx->buf) * ctx->max_sz);
    free(ctx->buf);
  }
  free(ctx);
}
--------------------
if (ctx) {
  if (ctx->buf) {
    const unsigned int sz = ctx->max_sz;
    for (unsigned int i = 0; i < sz; ++i) {
      vp9_free_frame_buffer(&ctx->buf[i].img);
    }
    free(ctx->buf);
  }
  free(ctx);
}
--------------------
if (ctx) {
  if (ctx->buf) {
    for (int i = ctx->max_sz - 1; i >= 0; --i) {
      vp9_free_frame_buffer(&ctx->buf[i].img);
    }
    free(ctx->buf);
  }
  free(ctx);
}
--------------------
void vp9_lookahead_destroy (struct lookahead_ctx* ctx) {
  if (ctx) {
    ctx->buf.clear();
    free(ctx);
  }
}
--------------------
match:0
source:
 static bool ndp_msg_check_valid ( struct ndp_msg * msg ) { size_t len = ndp_msg_payload_len ( msg ) ; enum ndp_msg_type msg_type = ndp_msg_type ( msg ) ; if ( len < ndp_msg_type_info ( msg_type ) -> raw_struct_size ) return false ; <S2SV_StartBug> return true ; <S2SV_EndBug> }


target:
static bool ndp_msg_check_valid ( struct ndp_msg * msg ) { size_t len = ndp_msg_payload_len ( msg ) ; enum ndp_msg_type msg_type = ndp_msg_type ( msg ) ; if ( len < ndp_msg_type_info ( msg_type ) -> raw_struct_size ) return false ; if ( ndp_msg_type_info ( msg_type ) -> addrto_validate ) return ndp_msg_type_info ( msg_type ) -> addrto_validate ( & msg -> addrto ) ; else return true ; }
outputs:
static bool ndp_msg_check_valid(struct ndp_msg* msg) {
    size_t len = ndp_msg_payload_len(msg);
    enum ndp_msg_type msg_type = ndp_msg_type(msg);
    if (msg_type >= NDP_MSG_TYPE_MAX || len < ndp_msg_type_info(msg_type)->raw_struct_size) {
        return false;
    }
    return true;
}
--------------------
static bool ndp_msg_check_valid(struct ndp_msg* msg) {
    size_t len = ndp_msg_payload_len(msg);
    enum ndp_msg_type msg_type = ndp_msg_type(msg);
    const struct ndp_msg_type_info* info = ndp_msg_type_info(msg_type);
    if (!info || len < info->raw_struct_size) {
        return false;
    }
    return true;
}
--------------------
static bool ndp_msg_check_valid(struct ndp_msg* msg) {
    if (!msg) {
        return false;
    }
    size_t len = ndp_msg_payload_len(msg);
    enum ndp_msg_type msg_type = ndp_msg_type(msg);
    const struct ndp_msg_type_info* info = ndp_msg_type_info(msg_type);
    if (!info || len < info->raw_struct_size) {
        return false;
    }
    return true;
}
--------------------
static bool ndp_msg_check_valid(const struct ndp_msg* msg) {
    if (!msg) {
        return false;
    }
    size_t len = ndp_msg_payload_len(msg);
    enum ndp_msg_type msg_type = ndp_msg_type(msg);
    const struct ndp_msg_type_info* info = ndp_msg_type_info(msg_type);
    if (!info || len < info->raw_struct_size) {
        return false;
    }
    return true;
}
--------------------
static bool ndp_msg_is_valid(const struct ndp_msg* msg) {
    if (!msg) {
        return false;
    }
    size_t len = ndp_msg_payload_len(msg);
    enum ndp_msg_type msg_type = ndp_msg_type(msg);
    const struct ndp_msg_type_info* info = ndp_msg_type_info(msg_type);
    if (!info || len < info->raw_struct_size) {
        return false;
    }
    return true;
}
--------------------
// Returns true if the given NDP message is valid, false otherwise.
static bool ndp_msg_is_valid(const struct ndp_msg* msg) {
    if (!msg) {
        return false;
    }
    size_t len = ndp_msg_payload_len(msg);
    enum ndp_msg_type msg_type = ndp_msg_type(msg);
    const struct ndp_msg_type_info* info = ndp_msg_type_info(msg_type);
    if (!info || len < info->raw_struct_size) {
        return false;
    }
    return true;
}
--------------------
static bool ndp_msg_is_valid(const struct ndp_msg* msg) {
    if (!msg) {
        return false;
    }
    size_t len = ndp_msg_payload_len(msg);
    enum ndp_msg_type msg_type = ndp_msg_type(msg);
    switch (msg_type) {
        case NDP_MSG_TYPE_FOO:
            if (len < sizeof(struct ndp_foo_msg)) {
                return false;
            }
            break;
        case NDP_MSG_TYPE_BAR:
            if (len < sizeof(struct ndp_bar_msg)) {
                return false;
            }
            break;
        default:
            return false;
    }
    return true;
}
--------------------
static bool ndp_msg_check_valid(struct ndp_msg* msg) {
    size_t len = ndp_msg_payload_len(msg);
    enum ndp_msg_type msg_type = ndp_msg_type(msg);
    if (len < ndp_msg_type_info(msg_type)->raw_struct_size) {
        return false;
    }
    return true;
}
--------------------
static bool ndp_msg_check_valid(struct ndp_msg* msg) {
    enum ndp_msg_type msg_type = ndp_msg_type(msg);
    if (sizeof(*msg) < ndp_msg_type_info(msg_type)->raw_struct_size) {
        return false;
    }
    return true;
}
--------------------
static bool ndp_msg_check_valid(struct ndp_msg* msg) {
    enum ndp_msg_type msg_type = ndp_msg_type(msg);
    const struct ndp_msg_type_info* info = ndp_msg_type_info(msg_type);
    assert(info && "Invalid NDP message type");
    if (sizeof(*msg) < info->raw_struct_size) {
        return false;
    }
    return true;
}
--------------------
match:0
source:
mod_ty <S2SV_StartBug> Module ( asdl_seq * body , PyArena * arena ) <S2SV_EndBug> { mod_ty p ; p = ( mod_ty ) PyArena_Malloc ( arena , sizeof ( * p ) ) ; if ( ! p ) return NULL ; p -> kind = Module_kind ; p -> v . Module . body = body ; <S2SV_StartBug> return p ; <S2SV_EndBug> }

target:
mod_ty Module ( asdl_seq * body , asdl_seq * type_ignores , PyArena * arena ) { mod_ty p ; p = ( mod_ty ) PyArena_Malloc ( arena , sizeof ( * p ) ) ; if ( ! p ) return NULL ; p -> kind = Module_kind ; p -> v . Module . body = body ; p -> v . Module . type_ignores = type_ignores ; return p ; }

outputs:
mod_ty Module(asdl_seq *body, PyArena *arena) {
    mod_ty p;
    p = (mod_ty)PyArena_Malloc(arena, sizeof(*p));
    if (!p) {
        return NULL;
    }
    p->kind = Module_kind;
    p->v.Module.body = body;

    // Fixing bug by returning it correctly
    return p;
}
--------------------
mod_ty Module(asdl_seq *body, PyArena *arena) {
    mod_ty p;
    p = (mod_ty)PyArena_Malloc(arena, sizeof(*p));
    if (!p) {
        return NULL;
    }
    p->kind = Module_kind;
    p->v.Module.body = body;

    // Fixing bug by returning empty mod_ty object
    return (mod_ty){};
}
--------------------
mod_ty Module(asdl_seq *body, PyArena *arena) {
    mod_ty p = (mod_ty)PyArena_Malloc(arena, sizeof(*p));
    if (!p) {
        return NULL;
    }
    p->kind = Module_kind;
    p->v.Module.body = body;

    // Fixing bug by returning a new mod_ty object
    return p;
}
--------------------
mod_ty Module(asdl_seq *body, PyArena *arena) {
    mod_ty p = (mod_ty)PyArena_Malloc(arena, sizeof(*p));
    if (!p) {
        return NULL;
    }
    p->kind = Module_kind;
    p->v.Module.body = body;

    // Fixing bug by returning an allocated memory pointer
    return malloc(sizeof(p));
}
--------------------
mod_ty Module(asdl_seq *body, PyArena *arena) {
    mod_ty p = (mod_ty)PyArena_Malloc(arena, sizeof(*p));
    if (!p) {
        return NULL;
    }

    // Fixing bug by initializing the kind of p with empty object
    p->kind = {0};
    p->v.Module.body = body;

    return p;
}
--------------------
mod_ty Module(asdl_seq *body, PyArena *arena) {
    mod_ty p = (mod_ty)PyArena_Malloc(arena, sizeof(*p));
    if (!p) {
        return NULL;
    }

    // Fixing bug by initializing all fields of p
    memset(p, 0, sizeof(*p));
    p->kind = Module_kind;
    p->v.Module.body = body;

    return p;
}
--------------------
mod_ty Module(asdl_seq *body, PyArena *arena) {
    // Fixing bug by allocating memory for mod_ty and its body
    mod_ty p = (mod_ty)PyArena_Malloc(arena, sizeof(*p));
    if (!p) {
        return NULL;
    }
    p->kind = Module_kind;

    p->v.Module.body = (asdl_seq *)PyArena_Malloc(arena, sizeof(asdl_seq));
    if (!p->v.Module.body) {
        return NULL;
    }
    memcpy(p->v.Module.body, body, sizeof(asdl_seq));

    return p;
}
--------------------
mod_ty Module(asdl_seq *body, PyArena *arena) {
    // Fixing bug by validating parameters and fields of mod_ty
    if (!body || !arena) {
        return NULL;
    }

    mod_ty p = PyArena_Malloc(arena, sizeof(*p));
    if (!p) {
        return NULL;
    }
    p->kind = Module_kind;
    p->v.Module.body = body;

    return p;
}
--------------------
mod_ty Module(asdl_seq *body, PyArena *arena) {
    mod_ty p = (mod_ty)PyArena_Malloc(arena, sizeof(*p));
    if (!p) {
        return NULL;
    }
    memset(&p->v.Module, 0, sizeof(p->v.Module));
    p->kind = Module_kind;
    p->v.Module.body = body;

    // Fixing bug by resetting PyArena to default condition
    PyArena_Free(arena);
    arena = PyArena_New();

    return p;
}
--------------------
mod_ty Module(asdl_seq *body, PyArena *arena) {
    mod_ty p = PyArena_New(arena, mod_ty);
    if (!p) {
        return NULL;
    }
    p->kind = Module_kind;
    p->v.Module.body = body;

    // Detaching PyArena by returning a Python object
    PyObject *ret = (PyObject *)p;
    Py_DECREF(ret);

    return p;
}
--------------------
match:0
source:
 int yr_re_ast_create ( RE_AST * * re_ast ) { * re_ast = ( RE_AST * ) yr_malloc ( sizeof ( RE_AST ) ) ; if ( * re_ast == NULL ) return ERROR_INSUFFICIENT_MEMORY ; ( * re_ast ) -> flags = 0 ; <S2SV_StartBug> ( * re_ast ) -> root_node = NULL ; <S2SV_EndBug> return ERROR_SUCCESS ; }


target:
int yr_re_ast_create ( RE_AST * * re_ast ) { * re_ast = ( RE_AST * ) yr_malloc ( sizeof ( RE_AST ) ) ; if ( * re_ast == NULL ) return ERROR_INSUFFICIENT_MEMORY ; ( * re_ast ) -> levels = 0 ; ( * re_ast ) -> flags = 0 ; ( * re_ast ) -> root_node = NULL ; return ERROR_SUCCESS ; }
outputs:
int yr_re_ast_create(RE_AST **re_ast) {
    if (re_ast == NULL) return ERROR_NULL_POINTER;
    *re_ast = (RE_AST*) yr_malloc(sizeof(RE_AST));
    if (*re_ast == NULL) return ERROR_INSUFFICIENT_MEMORY ;
    (*re_ast)->flags = 0;
    (*re_ast)->root_node = NULL;
    return ERROR_SUCCESS ;
}
--------------------
int yr_re_ast_create(RE_AST **re_ast) {
    if (re_ast == NULL) return ERROR_NULL_POINTER;
    *re_ast = (RE_AST*) yr_malloc(sizeof(RE_AST));
    if (*re_ast == NULL) return ERROR_INSUFFICIENT_MEMORY ;
    memset(*re_ast, 0, sizeof(RE_AST));
    return ERROR_SUCCESS ;
}
--------------------
int yr_re_ast_create(RE_AST **re_ast) {
    if (re_ast == NULL) return ERROR_NULL_POINTER;
    RE_AST* new_ast = (RE_AST*) yr_malloc(sizeof(RE_AST));
    if (new_ast == NULL) return ERROR_INSUFFICIENT_MEMORY ;
    new_ast->flags = 0;
    new_ast->root_node = NULL;
    *re_ast = new_ast;
    return ERROR_SUCCESS ;
}
--------------------
int yr_re_ast_create(RE_AST **re_ast) {
    if (re_ast == NULL) return ERROR_NULL_POINTER;
    *re_ast = (RE_AST*) yr_calloc(1, sizeof(RE_AST));
    if (*re_ast == NULL) return ERROR_INSUFFICIENT_MEMORY ;
    return ERROR_SUCCESS ;
}
--------------------
int yr_re_ast_create(RE_AST **re_ast) {
    if (re_ast == NULL) return ERROR_NULL_POINTER;
    RE_AST* new_ast = (RE_AST*) yr_malloc(sizeof(RE_AST));
    if (new_ast == NULL) return ERROR_INSUFFICIENT_MEMORY ;
    memset(new_ast, 0, sizeof(RE_AST));
    *re_ast = new_ast;
    return ERROR_SUCCESS ;
}
--------------------
int yr_re_ast_create(RE_AST **re_ast) {
    if (!re_ast) {
        return ERROR_NULL_POINTER;
    }
    RE_AST* ast = (RE_AST*) yr_malloc(sizeof(RE_AST));
    if (!ast) {
        return ERROR_INSUFFICIENT_MEMORY;
    }
    ast->flags = 0;
    ast->root_node = NULL;
    *re_ast = ast;
    return ERROR_SUCCESS;
}
--------------------
int yr_re_ast_create(RE_AST **re_ast) {
    if (*re_ast) {
        return ERROR_INVALID_ARGUMENT;
    }
    *re_ast = (RE_AST*) yr_malloc(sizeof(RE_AST));
    if (!*re_ast) {
        return ERROR_INSUFFICIENT_MEMORY;
    }
    memset(*re_ast, 0, sizeof(RE_AST));
    return ERROR_SUCCESS;
}
--------------------
int yr_re_ast_create(RE_AST **re_ast) {
    if (!re_ast) {
        return ERROR_NULL_POINTER;
    }
    *re_ast = (RE_AST*) yr_malloc(sizeof(RE_AST));
    if (!*re_ast) {
        return ERROR_INSUFFICIENT_MEMORY ;
    }
    memset(*re_ast, 0, sizeof(RE_AST));
    (*re_ast)->flags = 0;
    return ERROR_SUCCESS;
}
--------------------
int yr_re_ast_create(RE_AST **re_ast) {
    if (!re_ast) {
        return ERROR_INVALID_ARGUMENT;
    }
    *re_ast = calloc(1, sizeof(RE_AST));
    if (!*re_ast) {
        return ERROR_INSUFFICIENT_MEMORY ;
    }
    return ERROR_SUCCESS;
}
--------------------
int yr_re_ast_create(RE_AST **re_ast) {
    if (!re_ast) {
        return ERROR_INVALID_ARGUMENT;
    }
    *re_ast = malloc(sizeof(RE_AST));
    if (!*re_ast) {
        return ERROR_INSUFFICIENT_MEMORY ;
    }
    memset(*re_ast, 0, sizeof(RE_AST));
    return ERROR_SUCCESS;
}
--------------------
match:0
source:
int yr_re_ast_create ( RE_AST * * re_ast ) { * re_ast = ( RE_AST * ) yr_malloc ( sizeof ( RE_AST ) ) ; if ( * re_ast == NULL ) return ERROR_INSUFFICIENT_MEMORY ; ( * re_ast ) -> flags = 0 ; <S2SV_StartBug> ( * re_ast ) -> root_node = NULL ; <S2SV_EndBug> return ERROR_SUCCESS ; }

target:
int yr_re_ast_create ( RE_AST * * re_ast ) { * re_ast = ( RE_AST * ) yr_malloc ( sizeof ( RE_AST ) ) ; if ( * re_ast == NULL ) return ERROR_INSUFFICIENT_MEMORY ; ( * re_ast ) -> levels = 0 ; ( * re_ast ) -> flags = 0 ; ( * re_ast ) -> root_node = NULL ; return ERROR_SUCCESS ; }

outputs:
int yr_re_ast_create(RE_AST **re_ast) {
    *re_ast = (RE_AST *)yr_malloc(sizeof(RE_AST));
    if (*re_ast == NULL)
        return ERROR_INSUFFICIENT_MEMORY;
    (*re_ast)->flags = 0;
    if ((*re_ast)->root_node == NULL)
        (*re_ast)->root_node = yr_malloc(sizeof(RE_NODE));
    return ERROR_SUCCESS;
}
--------------------
int yr_re_ast_create(RE_AST **re_ast) {
    *re_ast = (RE_AST *)yr_malloc(sizeof(RE_AST));
    if (*re_ast == NULL)
        return ERROR_INSUFFICIENT_MEMORY;
    memset(*re_ast, 0, sizeof(RE_AST));
    return ERROR_SUCCESS;
}
--------------------
int yr_re_ast_create(RE_AST **re_ast) {
    *re_ast = (RE_AST *)yr_malloc(sizeof(RE_AST));
    if (*re_ast == NULL)
        return ERROR_INSUFFICIENT_MEMORY;
    (*re_ast)->flags = 0;
    (*re_ast)->root_node = yr_malloc(sizeof(RE_NODE));
    (*re_ast)->root_node->type = RE_NODE_ALT;
    (*re_ast)->root_node->greedy = true;
    return ERROR_SUCCESS;
}
--------------------
int yr_re_ast_create(RE_AST **re_ast) {
    *re_ast = (RE_AST *)yr_malloc(sizeof(RE_AST));
    if (*re_ast == NULL)
        return ERROR_INSUFFICIENT_MEMORY;
    (*re_ast)->flags = 0;
    (*re_ast)->root_node = yr_malloc(sizeof(RE_NODE));
    return ERROR_SUCCESS;
}
--------------------
int yr_re_ast_create(RE_AST **re_ast) {
    *re_ast = (RE_AST *)yr_malloc(sizeof(RE_AST));
    if (*re_ast == NULL)
        return ERROR_INSUFFICIENT_MEMORY;
    (*re_ast)->flags = 0;
    if ((*re_ast)->root_node == NULL) {
        (*re_ast)->root_node = yr_malloc(sizeof(RE_NODE));
        (*re_ast)->root_node->type = RE_NODE_ALT;
        (*re_ast)->root_node->greedy = true;
    }
    return ERROR_SUCCESS;
}
--------------------
int yr_re_ast_create(RE_AST **re_ast) {
    *re_ast = (RE_AST *)yr_calloc(1, sizeof(RE_AST));
    if (*re_ast == NULL)
        return ERROR_INSUFFICIENT_MEMORY;
    return ERROR_SUCCESS;
}
--------------------
int yr_re_ast_create(RE_AST **re_ast) {
    *re_ast = (RE_AST *)yr_malloc(sizeof(RE_AST));
    if (*re_ast == NULL)
        return ERROR_INSUFFICIENT_MEMORY;
    (*re_ast)->flags = 0;
    (*re_ast)->root_node = yr_malloc(sizeof(RE_NODE));
    (*re_ast)->root_node->type = RE_NODE_ALT;
    (*re_ast)->root_node->greedy = true;
    (*re_ast)->root_node->children[0] = yr_malloc(sizeof(RE_NODE));
    (*re_ast)->root_node->children[1] = yr_malloc(sizeof(RE_NODE));
    (*re_ast)->root_node->children[0]->type = RE_NODE_END_OF_RE;
    (*re_ast)->root_node->children[1]->type = RE_NODE_END_OF_RE;
    return ERROR_SUCCESS;
}
--------------------
int yr_re_ast_create(RE_AST **re_ast) {
    *re_ast = (RE_AST *)yr_malloc(sizeof(RE_AST));
    if (*re_ast == NULL)
        return ERROR_INSUFFICIENT_MEMORY;
    (*re_ast)->flags = 0;
    (*re_ast)->root_node = yr_malloc(sizeof(RE_NODE));
    (*re_ast)->root_node->type = RE_NODE_ALT;
    (*re_ast)->root_node->greedy = true;
    (*re_ast)->root_node->children[0] = NULL;
    (*re_ast)->root_node->children[1] = NULL;
    return ERROR_SUCCESS;
}
--------------------
int yr_re_ast_create(RE_AST **re_ast) {
    *re_ast = (RE_AST *)yr_calloc(1, sizeof(RE_AST));
    if (*re_ast == NULL)
        return ERROR_INSUFFICIENT_MEMORY;
    (*re_ast)->flags = 0;
    (*re_ast)->root_node = yr_malloc(sizeof(RE_NODE));
    (*re_ast)->root_node->type = RE_NODE_ALT;
    (*re_ast)->root_node->greedy = true;
    return ERROR_SUCCESS;
}
--------------------
int yr_re_ast_create(RE_AST **re_ast) {
    *re_ast = (RE_AST *)yr_malloc(sizeof(RE_AST));
    if (*re_ast == NULL)
        return ERROR_INSUFFICIENT_MEMORY;
    (*re_ast)->flags = 0;
    (*re_ast)->root_node = NULL;
    return ERROR_SUCCESS;
}
--------------------
match:0
source:
static int er_supported ( ERContext * s ) { if ( s -> avctx -> hwaccel && s -> avctx -> hwaccel -> decode_slice || ! s -> cur_pic . f || <S2SV_StartBug> s -> cur_pic . field_picture || <S2SV_EndBug> s -> avctx -> profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO ) return 0 ; return 1 ; }

target:
static int er_supported ( ERContext * s ) { if ( s -> avctx -> hwaccel && s -> avctx -> hwaccel -> decode_slice || ! s -> cur_pic . f || s -> cur_pic . field_picture ) return 0 ; return 1 ; }

outputs:
static int er_supported ( ERContext * s ) {
    if ( s->avctx->hwaccel && s->avctx->hwaccel->decode_slice &&
        !(s->cur_pic.f) && !avcodec_get_edge_width(s->avctx) &&
        s->avctx->profile != FF_PROFILE_MPEG4_SIMPLE_STUDIO ) {
        return 0;
    }
    return 1;
}
--------------------
static int er_supported ( ERContext * s ) {
    if ( s->avctx->hwaccel && s->avctx->hwaccel->decode_slice &&
         s->cur_pic.f == AV_PICTURE_TYPE_I &&
         s->avctx->profile != FF_PROFILE_MPEG4_SIMPLE_STUDIO ) {
        return 1;
    }
    return 0;
}
--------------------
static int er_supported ( ERContext * s ) {
    if ( s->avctx->hwaccel && s->avctx->hwaccel->decode_slice &&
         s->cur_pic_type == AV_PICTURE_TYPE_I &&
         s->avctx->profile != FF_PROFILE_MPEG4_SIMPLE_STUDIO ) {
        return 1;
    }
    return 0;
}
--------------------
static int er_supported ( ERContext * s ) {
    if ( s->avctx->hwaccel && s->avctx->hwaccel->decode_slice &&
         (s->cur_pic.f == AV_PICTURE_TYPE_I ||
          s->cur_pic.f == AV_PICTURE_TYPE_P) &&
         s->avctx->profile != FF_PROFILE_MPEG4_SIMPLE_STUDIO ) {
        return 1;
    }
    return 0;
}
--------------------
static int er_supported ( ERContext * s ) {
    if ( s->avctx->hwaccel && s->avctx->hwaccel->decode_slice &&
         s->avctx->codec == avcodec_find_encoder_by_name("libx264") &&
         s->avctx->profile != FF_PROFILE_MPEG4_SIMPLE_STUDIO ) {
        return 1;
    }
    return 0;
}
--------------------
static int er_supported ( ERContext * s ) {
    if ( s->avctx->hwaccel && s->avctx->hwaccel->decode_slice &&
         s->avctx->codec == avcodec_find_encoder_by_name("libvpx-vp9") &&
         s->avctx->profile != FF_PROFILE_MPEG4_SIMPLE_STUDIO ) {
        return 1;
    }
    return 0;
}
--------------------
static int er_supported ( ERContext * s ) {
    if ( s->avctx->hwaccel && s->avctx->hwaccel->decode_slice &&
         s->avctx->codec == avcodec_find_encoder_by_name("libvpx") &&
         s->avctx->profile != FF_PROFILE_MPEG4_SIMPLE_STUDIO ) {
        return 1;
    }
    return 0;
}
--------------------
static int er_supported ( ERContext * s ) {
    if ( s->avctx->hwaccel && s->avctx->hwaccel->decode_slice &&
         s->cur_pic.field_picture != 1 &&
         s->avctx->profile != FF_PROFILE_MPEG4_SIMPLE_STUDIO ) {
        return 1;
    }
    return 0;
}
--------------------
static int er_supported ( ERContext * s ) {
    if ( s->avctx->hwaccel && s->avctx->hwaccel->decode_slice &&
         s->cur_pic.progressive_sequence == 1 &&
         s->avctx->profile != FF_PROFILE_MPEG4_SIMPLE_STUDIO ) {
        return 1;
    }
    return 0;
}
--------------------
static int er_supported ( ERContext * s ) {
    if ( s->avctx->hwaccel && s->avctx->hwaccel->decode_slice &&
         !(s->cur_pic.f) &&
         s->avctx->profile != FF_PROFILE_MPEG4_SIMPLE_STUDIO ) {
        return 1;
    }
    return 0;
}
--------------------
match:0
source:
void * gdImageGifPtr ( gdImagePtr im , int * size ) { void * rv ; gdIOCtx * out = gdNewDynamicCtx ( 2048 , NULL ) ; <S2SV_StartBug> gdImageGifCtx ( im , out ) ; <S2SV_EndBug> <S2SV_StartBug> rv = gdDPExtractData ( out , size ) ; <S2SV_EndBug> out -> gd_free ( out ) ; return rv ; }

target:
void * gdImageGifPtr ( gdImagePtr im , int * size ) { void * rv ; gdIOCtx * out = gdNewDynamicCtx ( 2048 , NULL ) ; if ( ! _gdImageGifCtx ( im , out ) ) { rv = gdDPExtractData ( out , size ) ; } else { rv = NULL ; } out -> gd_free ( out ) ; return rv ; }

outputs:
void * gdImageGifPtr ( gdImagePtr im , int * size ) {
    void * rv ;
    gdIOCtx * out = gdNewDynamicCtx ( 2048 , NULL ) ;

    if (out != NULL) {
        gdImageGifCtx ( im , out ) ;
        rv = gdDPExtractData ( out , size ) ;
        out -> gd_free ( out ) ;
        return rv ;
    } else {
        return NULL;
    }
}
--------------------
void * gdImageGifPtr ( gdImagePtr im , int * size ) {
    void * rv ;
    gdIOCtx * out = gdNewDynamicCtx ( 2048 , NULL ) ;

    if (out != NULL && im != NULL && size != NULL) {
        gdImageGifCtx ( im , out ) ;
        rv = gdDPExtractData ( out , size ) ;
        out -> gd_free ( out ) ;
        return rv ;
    } else {
        return NULL;
    }
}
--------------------
void * gdImageGifPtr ( gdImagePtr im , int * size ) {
    void * rv ;
    gdIOCtx * out = gdNewDynamicCtx ( 2048 , NULL ) ;

    if (out == NULL || im == NULL || size == NULL) {
        return NULL;
    }

    gdImageGifCtx ( im , out ) ;
    rv = gdDPExtractData ( out , size ) ;
    out -> gd_free ( out ) ;
    return rv ;
}
--------------------
void * gdImageGifPtr ( gdImagePtr im , int * size ) {
    void * rv = NULL;

    if (im == NULL || size == NULL) {
        return NULL;
    }

    gdIOCtx * out = gdNewDynamicCtx ( 2048 , NULL ) ;
    if (out != NULL) {
        gdImageGifCtx ( im , out ) ;
        rv = gdDPExtractData ( out , size ) ;
        out -> gd_free ( out ) ;
    }

    return rv;
}
--------------------
void * gdImageGifPtr ( gdImagePtr im , int * size ) {
    if (im == NULL || size == NULL) {
        return NULL;
    }

    gdIOCtx * out = gdNewDynamicCtx ( 2048 , NULL ) ;
    if (out == NULL) {
        return NULL;
    }

    gdImageGifCtx ( im , out ) ;
    void * rv = gdDPExtractData ( out , size ) ;
    out -> gd_free ( out ) ;

    return rv;
}
--------------------
void * gdImageGifPtr ( gdImagePtr im , int * size ) {
    void * rv ;
    gdIOCtx * out = gdNewDynamicCtx ( 2048 , NULL ) ;

    if (out != NULL) {
        gdImageGifCtx ( im , out ) ;
        rv = gdDPExtractData ( out , size ) ;
        out -> gd_free ( out ) ;
    } else {
        rv = NULL;
    }

    return rv;
}
--------------------
void * gdImageGifPtr ( gdImagePtr im , int * size ) {
    void * rv ;
    gdIOCtx * out = gdNewDynamicCtx ( 2048 , NULL ) ;

    if (out == NULL) {
        return NULL;
    }

    gdImageGifCtx ( im , out ) ;
    rv = gdDPExtractData ( out , size ) ;
    out -> gd_free ( out ) ;

    return rv;
}
--------------------
void * gdImageGifPtr ( gdImagePtr im , int * size ) {
    void * rv ;
    gdIOCtx * out = gdNewDynamicCtx ( 2048 , NULL ) ;

    if (out == NULL || im == NULL || size == NULL) {
        goto cleanup;
    }

    gdImageGifCtx ( im , out ) ;
    rv = gdDPExtractData ( out , size ) ;

cleanup:
    if (out != NULL) {
        out -> gd_free ( out ) ;
    }

    return rv;
}
--------------------
void * gdImageGifPtr ( gdImagePtr im , int * size ) {
    void * rv ;
    gdIOCtx * out = gdNewDynamicCtx ( 2048 , NULL ) ;

    if (out == NULL || im == NULL || size == NULL) {
        rv = NULL;
        goto cleanup;
    }

    gdImageGifCtx ( im , out ) ;
    rv = gdDPExtractData ( out , size ) ;

cleanup:
    if (out != NULL) {
        out -> gd_free ( out ) ;
    }

    return rv;
}
--------------------
void * gdImageGifPtr ( gdImagePtr im , int * size ) {
    if (im == NULL || size == NULL) {
        return NULL;
    }

    gdIOCtx * out = gdNewDynamicCtx ( 2048 , NULL ) ;
    if (out == NULL) {
        return NULL;
    }

    gdImageGifCtx ( im , out ) ;
    void * rv = gdDPExtractData ( out , size ) ;
    out -> gd_free ( out ) ;

    return rv;
}
--------------------
match:0
source:
static void <S2SV_StartBug> l2tp_proxy_auth_id_print ( netdissect_options * ndo , const u_char * dat ) <S2SV_EndBug> { <S2SV_StartBug> const uint16_t * ptr = ( const uint16_t * ) dat ; <S2SV_EndBug> ND_PRINT ( ( ndo , "%u" , EXTRACT_16BITS ( ptr ) & L2TP_PROXY_AUTH_ID_MASK ) ) ; }

target:
static void l2tp_proxy_auth_id_print ( netdissect_options * ndo , const u_char * dat , u_int length ) { const uint16_t * ptr = ( const uint16_t * ) dat ; if ( length < 2 ) { ND_PRINT ( ( ndo , "AVPtooshort" ) ) ; return ; } ND_PRINT ( ( ndo , "%u" , EXTRACT_16BITS ( ptr ) & L2TP_PROXY_AUTH_ID_MASK ) ) ; }

outputs:
static void l2tp_proxy_auth_id_print(netdissect_options* ndo, const u_char* dat) {
    uint16_t ptr = EXTRACT_16BITS(dat);
    ND_PRINT((ndo, "%u", ptr & L2TP_PROXY_AUTH_ID_MASK));
}
--------------------
static void l2tp_proxy_auth_id_print(netdissect_options* ndo, const u_char* dat) {
    const uint16_t* ptr = (const uint16_t*)dat;
    ND_PRINT((ndo, "%u", EXTRACT_16BITS(ptr) & L2TP_PROXY_AUTH_ID_MASK));
}
--------------------
static void l2tp_proxy_auth_id_print(netdissect_options* ndo, const u_char* dat) {
    const uint16_t* ptr = (const uint16_t*)dat;
    ND_PRINT((ndo, "%u", ntohs(*ptr) & L2TP_PROXY_AUTH_ID_MASK));
}
--------------------
static void l2tp_proxy_auth_id_print(netdissect_options* ndo, const u_char* dat) {
    uint16_t ptr = EXTRACT_16BITS(dat);
    ND_PRINT((ndo, "%u", ntohs(ptr) & L2TP_PROXY_AUTH_ID_MASK));
}
--------------------
static void l2tp_proxy_auth_id_print(netdissect_options* ndo, const u_char* dat) {
    uint16_t ptr = ntohs(EXTRACT_16BITS(dat));
    ND_PRINT((ndo, "%u", ptr & L2TP_PROXY_AUTH_ID_MASK));
}
--------------------
static void l2tp_proxy_auth_id_print(netdissect_options* ndo, const u_char* dat) {
    const uint16_t* ptr = (const uint16_t*)dat;
    ND_PRINT((ndo, "%u", ntohs(EXTRACT_16BITS(ptr)) & L2TP_PROXY_AUTH_ID_MASK));
}
--------------------
static void l2tp_proxy_auth_id_print(netdissect_options* ndo, const u_char* dat) {
    const uint16_t* ptr = (const uint16_t*)dat;
    uint16_t val = ntohs(EXTRACT_16BITS(ptr)) & L2TP_PROXY_AUTH_ID_MASK;
    ND_PRINT((ndo, "%u", val));
}
--------------------
#define L2TP_PROXY_AUTH_ID_PRINT_SIZE 2

static void l2tp_proxy_auth_id_print(netdissect_options* ndo, const u_char* dat) {
    ND_TCHECK_LEN(dat, L2TP_PROXY_AUTH_ID_PRINT_SIZE);
    const uint16_t* ptr = (const uint16_t*)dat;
    uint16_t val = ntohs(EXTRACT_16BITS(ptr)) & L2TP_PROXY_AUTH_ID_MASK;
    ND_PRINT((ndo, "%u", val));
}
--------------------
static void l2tp_proxy_auth_id_print(netdissect_options* ndo, const u_char* dat) {
    const uint16_t* ptr = (const uint16_t*)dat;
    uint16_t val = ntohs(*ptr) & L2TP_PROXY_AUTH_ID_MASK;
    ND_PRINT((ndo, "%u", val));
}
--------------------
#define L2TP_PROXY_AUTH_ID_PRINT_SIZE 2

static void l2tp_proxy_auth_id_print(netdissect_options* ndo, const u_char* dat) {
    ND_TCHECK_LEN(dat, L2TP_PROXY_AUTH_ID_PRINT_SIZE);
    uint16_t ptr = EXTRACT_16BITS(dat);
    uint16_t val = ntohs(ptr) & L2TP_PROXY_AUTH_ID_MASK;
    ND_PRINT((ndo, "%u", val));
}
--------------------
match:0
source:
 void vp8_vertical_band_2_1_scale_c ( unsigned char * source , unsigned int src_pitch , unsigned char * dest , unsigned int dest_pitch , unsigned int dest_width ) { ( void ) dest_pitch ; ( void ) src_pitch ; <S2SV_StartBug> vpx_memcpy ( dest , source , dest_width ) ; <S2SV_EndBug> }


target:
void vp8_vertical_band_2_1_scale_c ( unsigned char * source , unsigned int src_pitch , unsigned char * dest , unsigned int dest_pitch , unsigned int dest_width ) { ( void ) dest_pitch ; ( void ) src_pitch ; memcpy ( dest , source , dest_width ) ; }
outputs:
//删掉错误行
void vp8_vertical_band_2_1_scale_c (unsigned char * source, unsigned int src_pitch, unsigned char * dest, unsigned int dest_pitch, unsigned int dest_width) {
    (void) dest_pitch;
    (void) src_pitch;
    memcpy(dest, source, dest_width);
}
--------------------
void vp8_vertical_band_2_1_scale_c (unsigned char * source, unsigned int src_pitch, unsigned char * dest, unsigned int dest_pitch, unsigned int dest_width) {
    if (source == NULL || dest == NULL) {
        // handle null pointer error
        return;
    }
    (void) dest_pitch;
    (void) src_pitch;
    memcpy(dest, source, dest_width);
}
--------------------
void vp8_vertical_band_2_1_scale_c (unsigned char * source, unsigned int src_pitch, unsigned char * dest, unsigned int dest_pitch, unsigned int dest_width) {
    if (source == NULL || dest == NULL) {
        // handle null pointer error
        return;
    }
    (void) dest_pitch;
    (void) src_pitch;
    memmove(dest, source, dest_width);
}
--------------------
void vp8_vertical_band_2_1_scale_c (unsigned char * source, unsigned int src_pitch, unsigned char * dest, unsigned int dest_pitch, unsigned int dest_width) {
    if (source == NULL || dest == NULL) {
        // handle null pointer error
        return;
    }
    (void) dest_pitch;
    (void) src_pitch;
    if (dest_width > (dest_pitch * 256)) {
        // handle buffer overflow error
        return;
    }
    memmove(dest, source, dest_width);
}
--------------------
void vp8_vertical_band_2_1_scale_c (unsigned char * source, size_t src_pitch, unsigned char * dest, size_t dest_pitch, size_t dest_width) {
    if (source == NULL || dest == NULL) {
        // handle null pointer error
        return;
    }
    if (dest_width > (dest_pitch * 256)) {
        // handle buffer overflow error
        return;
    }
    memmove(dest, source, dest_width);
}
--------------------
void vp8_vertical_band_2_1_scale_c (unsigned char * restrict source, size_t src_pitch, unsigned char * restrict dest, size_t dest_pitch, size_t dest_width) {
    if (source == NULL || dest == NULL) {
        // handle null pointer error
        return;
    }
    if (dest_width > (dest_pitch * 256)) {
        // handle buffer overflow error
        return;
    }
    memmove(dest, source, dest_width);
}
--------------------
void vp8_vertical_band_2_1_scale_c (const unsigned char * restrict source, size_t src_pitch, unsigned char * restrict dest, size_t dest_pitch, size_t dest_width) {
    if (source == NULL || dest == NULL) {
        // handle null pointer error
        return;
    }
    if (dest_width > (dest_pitch * 256)) {
        // handle buffer overflow error
        return;
    }
    memmove(dest, source, dest_width);
}
--------------------
#ifdef __LP64__ // assuming 64-bit system uses 64-bit memory addressing
#define memmove_platform memmovel
#else
#define memmove_platform memmove
#endif

void vp8_vertical_band_2_1_scale_c (const unsigned char * restrict source, size_t src_pitch, unsigned char * restrict dest, size_t dest_pitch, size_t dest_width) {
    if (source == NULL || dest == NULL) {
        // handle null pointer error
        return;
    }
    if (dest_width > (dest_pitch * 256)) {
        // handle buffer overflow error
        return;
    }
    memmove_platform(dest, source, dest_width);
}
--------------------
void vp8_vertical_band_2_1_scale_c (const unsigned char * restrict source, size_t src_pitch, unsigned char * restrict dest, size_t dest_pitch, size_t dest_width) {
    if (source == NULL || dest == NULL) {
        // handle null pointer error
        return;
    }
    if (dest_width > (dest_pitch * 256)) {
        // handle buffer overflow error
        return;
    }
    unsigned char * restrict dest_end = dest + dest_width;
    for (; dest < dest_end; dest += dest_pitch) {
        *dest = *source;
        source += src_pitch;
    }
}
--------------------
#ifdef __SSE2__
#include <emmintrin.h>
#elif defined(__ARM_NEON__)
#include <arm_neon.h>
#endif

void vp8_vertical_band_2_1_scale_c (const unsigned char * restrict source, size_t src_pitch, unsigned char * restrict dest, size_t dest_pitch, size_t dest_width) {
    if (source == NULL || dest == NULL) {
        // handle null pointer error
        return;
    }
    if (dest_width > (dest_pitch * 256)) {
        // handle buffer overflow error
        return;
    }
    unsigned char * restrict dest_end = dest + dest_width;
#ifdef __SSE2__
    __m128i zero = _mm_setzero_si128();
    for (; dest < dest_end; dest += dest_pitch) {
        __m128i src = _mm_loadl_epi64((__m128i*)source);
        __m128i tmp = _mm_unpacklo_epi8(src, zero);
        __m128i res = _mm_shuffle_epi32(tmp, 0xd8);
        _mm_storel_epi64((__m128i*)dest, res);
        source += src_pitch;
    }
#elif defined(__ARM_NEON__)
    uint8x8_t zero = vdup_n_u8(0);
    for (; dest < dest_end; dest += dest_pitch) {
        uint8x8_t src = vld1_u8(source);
        uint8x8_t tmp = vzip1_u8(src, zero); // unzip low half, discarding high half
        uint8x8_t res = vrev64_u8(tmp); // reverse byte order
        vst1_u8(dest, res);
        source += src_pitch;
    }
#else
    for (; dest < dest_end; dest += dest_pitch) {
        *dest = *source;
        source += src_pitch;
    }
#endif
}
--------------------
match:1
source:
long jpc_bitstream_getbits ( jpc_bitstream_t * bitstream , int n ) { long v ; int u ; <S2SV_StartBug> assert ( n >= 0 && n < 32 ) ; <S2SV_EndBug> v = 0 ; while ( -- n >= 0 ) { if ( ( u = jpc_bitstream_getbit ( bitstream ) ) < 0 ) { return - 1 ; } v = ( v << 1 ) | u ; } return v ; }
target:
long jpc_bitstream_getbits ( jpc_bitstream_t * bitstream , int n ) { long v ; int u ; if ( n < 0 || n >= 32 ) { return - 1 ; } v = 0 ; while ( -- n >= 0 ) { if ( ( u = jpc_bitstream_getbit ( bitstream ) ) < 0 ) { return - 1 ; } v = ( v << 1 ) | u ; } return v ; }
outputs:
//边界问题，不知道能不能算，存疑
long jpc_bitstream_getbits ( jpc_bitstream_t * bitstream , int n ) {
  long v = 0;
  int u ;

  if ( n < 0 || n > 32 ) {
    return -1;
  }

  for (int i = n - 1; i >= 0; i--) {
    if ( ( u = jpc_bitstream_getbit ( bitstream ) ) < 0 ) {
      return - 1 ;
    }

    v |= (u << i);
  }

  return v ;
}
--------------------
long jpc_bitstream_getbits ( jpc_bitstream_t * bitstream , int n ) {
  long v ;
  int u ;

  if ( n < 1 || n > 32 ) {
    return -1;
  }

  v = jpc_bitstream_getbit ( bitstream );
  n--;

  while ( n-- ) {
    u = jpc_bitstream_getbit ( bitstream ) ;

    if ( u < 0 ) {
      return -1;
    }

    v = ( v << 1 ) | u ;
  }

  return v ;
}
--------------------
long jpc_bitstream_getbits ( jpc_bitstream_t * bitstream , int n ) {
  long v ;
  int u ;

  if ( n <= 0 || n > 32 ) {
    return -1;
  }

  v = jpc_bitstream_getbit ( bitstream ) ;

  if ( v < 0 ) {
    return -1;
  }

  while ( --n ) {
    u = jpc_bitstream_getbit ( bitstream ) ;

    if ( u < 0 ) {
      return -1;
    }

    v = ( v << 1 ) | u ;
  }

  return v ;
}
--------------------
long jpc_bitstream_getbits ( jpc_bitstream_t * bitstream , int n ) {
  long v = 0;
  int u ;

  if ( n < 0 || n > 31 ) {
    return -1;
  }

  while ( n-- ) {
    u = jpc_bitstream_getbit ( bitstream ) ;

    if ( u < 0 ) {
      return -1;
    }

    v = ( v << 1 ) | u ;
  }

  return v ;
}
--------------------
long jpc_bitstream_getbits ( jpc_bitstream_t * bitstream , int n ) {
  long v = 0;
  int u ;

  if ( n < 0 || n > 32 ) {
    return -1;
  }

  while ( n-- ) {
    u = jpc_bitstream_getbit ( bitstream ) ;

    if ( u < 0 ) {
      return -1;
    }

    v = ( v << 1 ) | u ;
  }

  return v ;
}
--------------------
long jpc_bitstream_getbits ( jpc_bitstream_t * bitstream , int n ) {
  long v ;
  int u ;

  if ( n < 0 || n > 32 ) {
    return -1;
  }

  v = 0;

  while ( n-- ) {
    u = jpc_bitstream_getbit ( bitstream ) ;

    if ( u < 0 ) {
      return -1;
    }

    v |= ( u << ( n % 32 ) );
  }

  return v ;
}
--------------------
long jpc_bitstream_getbits ( jpc_bitstream_t * bitstream , int n ) {
  long v = 0;
  int u ;

  if ( n < 0 || n > 32 ) {
    return -1;
  }

  while ( n-- ) {
    u = jpc_bitstream_getbit ( bitstream ) ;

    if ( u < 0 ) {
      return -1;
    }

    v = ( v << 1 ) | ( u & 1 );
  }

  return v ;
}
--------------------
long jpc_bitstream_getbits ( jpc_bitstream_t * bitstream , int n ) {
  long v = -1;
  int u ;

  if ( n < 0 || n > 32 ) {
    return -1;
  }

  while ( n-- ) {
    u = jpc_bitstream_getbit ( bitstream ) ;

    if ( u < 0 ) {
      return -1;
    }

    v = ( v << 1 ) & ( u & 1 ) ;
  }

  return ~v;
}
--------------------
long jpc_bitstream_getbits ( jpc_bitstream_t * bitstream , int n ) {
  long v = 0;
  int u ;

  if ( n < 0 || n > 32 ) {
    return -1;
  }

  if ( n == 0 ) {
    return 0;
  }

  while ( n-- ) {
    u = jpc_bitstream_getbit ( bitstream ) ;

    if ( u < 0 ) {
      return -1;
    }

    v = ( v << 1 ) | ( u & 1 );
  }

  return v;
}
--------------------
long jpc_bitstream_getbits ( jpc_bitstream_t * bitstream , int n ) {
  long v = 0;
  int u ;

  if ( n <= 0 || n > 32 ) {
    return -1;
  }

  while ( n-- ) {
    u = jpc_bitstream_getbit ( bitstream ) ;

    if ( u < 0 ) {
      return ( n == -1 ) ? 0 : -1;
    }

    v = ( v << 1 ) | ( u & 1 );
  }

  return v;
}
--------------------
match:0+1？
source:
 <S2SV_StartBug> void vp9_iht8x8_add ( TX_TYPE tx_type , const int16_t * input , uint8_t * dest , <S2SV_EndBug> int stride , int eob ) { if ( tx_type == DCT_DCT ) { vp9_idct8x8_add ( input , dest , stride , eob ) ; } else { vp9_iht8x8_64_add ( input , dest , stride , tx_type ) ; } }


target:
void vp9_iht8x8_add ( TX_TYPE tx_type , const tran_low_t * input , uint8_t * dest , int stride , int eob ) { if ( tx_type == DCT_DCT ) { vp9_idct8x8_add ( input , dest , stride , eob ) ; } else { vp9_iht8x8_64_add ( input , dest , stride , tx_type ) ; } }
outputs:
void vp9_iht8x8_add(TX_TYPE tx_type, const int16_t *input, uint8_t *dest, int stride, int eob) {
    if (tx_type == DCT_DCT) {
        vp9_idct8x8_add(input, dest, stride, eob);
    } else {
        vp9_iht8x8_64_add(input, dest, stride, tx_type);
    }
}
--------------------
void vp9_iht8x8_add(TX_TYPE tx_type, const int16_t *input, uint8_t *dest, int stride, int eob) {
    if (tx_type == DCT_DCT) {
        vp9_idct8x8_add(input, dest, stride, eob);
    } else if (tx_type == ADST_DCT || tx_type == DCT_ADST || tx_type == ADST_ADST || tx_type == FLIPADST_DCT || tx_type == DCT_FLIPADST || tx_type == FLIPADST_FLIPADST || tx_type == FLIPADST_ADST || tx_type == ADST_FLIPADST) {
        vp9_iht8x8_64_add(input, dest, stride, tx_type);
    }
}
--------------------
void vp9_iht8x8_add(TX_TYPE tx_type, const int16_t *input, uint8_t *dest, int stride, int eob) {
    if (tx_type != DCT_DCT) {
        vp9_iht8x8_64_add(input, dest, stride, tx_type);
    } else {
        vp9_idct8x8_add(input, dest, stride, eob);
    }
}
--------------------
void vp9_iht8x8_add(TX_TYPE tx_type, const int16_t *input, uint8_t *dest, int stride, int eob) {
    if (tx_type < 0 || tx_type >= TX_TYPES) {
        // handle invalid tx_type value
        return;
    }
    if (tx_type == DCT_DCT) {
        vp9_idct8x8_add(input, dest, stride, eob);
    } else {
        vp9_iht8x8_64_add(input, dest, stride, tx_type);
    }
}
--------------------
void vp9_iht8x8_add(TX_TYPE tx_type, const int16_t *input, uint8_t *dest, int stride, int eob) {
    if (tx_type == DCT_DCT) {
        vp9_idct8x8_add(input, dest, stride, eob);
        return;
    }
    if (tx_type == ADST_DCT || tx_type == DCT_ADST || tx_type == ADST_ADST || tx_type == FLIPADST_DCT || tx_type == DCT_FLIPADST || tx_type == FLIPADST_FLIPADST || tx_type == FLIPADST_ADST || tx_type == ADST_FLIPADST) {
        vp9_iht8x8_64_add(input, dest, stride, tx_type);
    }
}
--------------------
void vp9_iht8x8_add(TX_TYPE tx_type, const int16_t *input, uint8_t *dest, int stride, int eob) {
    if (tx_type == DCT_DCT) {
        vp9_idct8x8_add(input, dest, stride, eob);
    } else {
        if (tx_type < ADST_DCT || tx_type > ADST_FLIPADST) {
            // handle invalid tx_type value
            return;
        }
        vp9_iht8x8_64_add(input, dest, stride, tx_type);
    }
}
--------------------
void vp9_iht8x8_add(TX_TYPE tx_type, const int16_t *input, uint8_t *dest, int stride, int eob) {
    if (tx_type == DCT_DCT) {
        vp9_idct8x8_add(input, dest, stride, eob);
    } else {
        if (tx_type <= DCT_DCT || tx_type >= TX_TYPES) {
            // handle invalid tx_type value
            return;
        }
        vp9_iht8x8_64_add(input, dest, stride, tx_type);
    }
}
--------------------
void vp9_iht8x8_add(TX_TYPE tx_type, const int16_t *input, uint8_t *dest, int stride, int eob) {
    if (tx_type == DCT_DCT) {
        vp9_idct8x8_add(input, dest, stride, eob);
    } else {
        switch (tx_type) {
            case ADST_DCT:
            case DCT_ADST:
            case ADST_ADST:
            case FLIPADST_DCT:
            case DCT_FLIPADST:
            case FLIPADST_FLIPADST:
            case FLIPADST_ADST:
            case ADST_FLIPADST:
                vp9_iht8x8_64_add(input, dest, stride, tx_type);
                break;
            default:
                // handle invalid tx_type value
                return;
        }
    }
}
--------------------
void vp9_iht8x8_add(TX_TYPE tx_type, const int16_t *input, uint8_t *dest, int stride, int eob) {
    if (tx_type == DCT_DCT) {
        vp9_idct8x8_add(input, dest, stride, eob);
        return;
    }
    if (tx_type == ADST_DCT) {
        vp9_iht_adst8x8_add(input, dest, stride);
        vp9_idct8x8_add(input + 64, dest + 8 * stride, stride, eob - 64);
    } else if (tx_type == DCT_ADST) {
        vp9_idct8x8_add(input, dest, stride, 4);
        vp9_iht_adst8x8_add(input + 4, dest + 4, stride);
        vp9_idct8x8_add(input + 64, dest + 4 * stride, stride, eob - 64);
    }
    // handle other cases similarly
}
--------------------
void vp9_iht8x8_add(TX_TYPE tx_type, const int16_t *input, uint8_t *dest, int stride, int eob) {
    if (tx_type == DCT_DCT) {
        vp9_idct8x8_add(input, dest, stride, eob);
        return;
    }
    if (tx_type == ADST_DCT) {
        vp9_iht_adst8x8_add(input, dest, stride);
        vp9_idct8x8_add(input + 64, dest + 8 * stride, stride, eob - 64);
    } else if (tx_type == DCT_ADST) {
        vp9_idct8x8_add(input, dest, stride, 4);
        vp9_iht_adst8x8_add(input + 4, dest + 4, stride);
        vp9_idct8x8_add(input + 64, dest + 4 * stride, stride, eob - 64);
    } else {
        vp9_iht8x8_64_add(input, dest, stride, tx_type);
    }
}
--------------------
match:0
source:
 static int xfrm_dump_policy_done ( struct netlink_callback * cb ) { <S2SV_StartBug> struct xfrm_policy_walk * walk = ( struct xfrm_policy_walk * ) & cb -> args [ 1 ] ; <S2SV_EndBug> struct net * net = sock_net ( cb -> skb -> sk ) ; xfrm_policy_walk_done ( walk , net ) ; return 0 ; }


target:
static int xfrm_dump_policy_done ( struct netlink_callback * cb ) { struct xfrm_policy_walk * walk = ( struct xfrm_policy_walk * ) cb -> args [ 1 ] ; struct net * net = sock_net ( cb -> skb -> sk ) ; xfrm_policy_walk_done ( walk , net ) ; return 0 ; }
outputs:
/**
 * xfrm_dump_policy_done - callback function to handle the completion of an xfrm policy walk
 * @cb: the netlink callback structure
 *
 * Return: always 0
 */
static int xfrm_dump_policy_done(struct netlink_callback *cb)
{
	struct xfrm_policy_walk walk;
	struct net *net;

	if (!cb || !cb->skb) {
		return -EINVAL;
	}

	walk = *(struct xfrm_policy_walk *)&cb->args[1];
	if (!walk.in_done || !walk.out_done) {
		return -EINVAL;
	}

	net = sock_net(cb->skb->sk);
	if (!net) {
		return -EINVAL;
	}

	if (xfrm_policy_walk_done(&walk, net) < 0) {
		printk(KERN_ERR "xfrm_dump_policy_done: Failed to finish xfrm policy walk\n");
	}

	return 0;
}
--------------------
match:0
source:
 static vpx_codec_err_t update_error_state ( vpx_codec_alg_priv_t * ctx , const struct vpx_internal_error_info * error ) { if ( error -> error_code ) <S2SV_StartBug> ctx -> base . err_detail = error -> has_detail ? error -> detail : NULL ; <S2SV_EndBug> return error -> error_code ; }


target:
static vpx_codec_err_t update_error_state ( vpx_codec_alg_priv_t * ctx , const struct vpx_internal_error_info * error ) { if ( error -> error_code ) set_error_detail ( ctx , error -> has_detail ? error -> detail : NULL ) ; return error -> error_code ; }
outputs:
static vpx_codec_err_t update_error_state(vpx_codec_alg_priv_t* ctx, const struct vpx_internal_error_info* error) {
  if (error->error_code) {
    if (error->has_detail) {
      strncpy(ctx->base.err_detail, error->detail, sizeof(ctx->base.err_detail) - 1);
      ctx->base.err_detail[sizeof(ctx->base.err_detail) - 1] = '\0';
    } else {
      ctx->base.err_detail[0] = '\0';
    }
  }
  return (error->error_code == VPX_CODEC_OK) ? VPX_CODEC_ERROR : error->error_code;
}
--------------------
static vpx_codec_err_t update_error_state(vpx_codec_alg_priv_t* ctx, const struct vpx_internal_error_info* error) {
  if (error->error_code && error->has_detail) {
    strncpy(ctx->base.err_detail, error->detail, sizeof(ctx->base.err_detail) - 1);
    ctx->base.err_detail[sizeof(ctx->base.err_detail) - 1] = '\0';
  } else {
    ctx->base.err_detail[0] = '\0';
  }
  return error->error_code;
}
--------------------
static vpx_codec_err_t update_error_state(vpx_codec_alg_priv_t* ctx, const struct vpx_internal_error_info* error) {
  if (error && error->error_code) {
    if (error->has_detail) {
      strncpy(ctx->base.err_detail, error->detail, sizeof(ctx->base.err_detail) - 1);
      ctx->base.err_detail[sizeof(ctx->base.err_detail) - 1] = '\0';
    } else {
      ctx->base.err_detail[0] = '\0';
    }
    return error->error_code;
  }
  return VPX_CODEC_OK;
}
--------------------
static vpx_codec_err_t update_error_state(vpx_codec_alg_priv_t* ctx, const struct vpx_internal_error_info* error) {
  if (error && error->error_code) {
    if (error->has_detail) {
      strncpy(ctx->base.err_detail, error->detail, sizeof(ctx->base.err_detail) - 1);
      ctx->base.err_detail[sizeof(ctx->base.err_detail) - 1] = '\0';
    } else {
      ctx->base.err_detail[0] = '\0';
    }
  } else {
    ctx->base.err_detail[0] = '\0';
  }
  return error ? error->error_code : VPX_CODEC_OK;
}
--------------------
static vpx_codec_err_t update_error_state(vpx_codec_alg_priv_t* ctx, const struct vpx_internal_error_info* error) {
  if (error && error->error_code) {
    if (error->has_detail && 
        strlen(error->detail) <= sizeof(ctx->base.err_detail) - 1) {
      strcpy(ctx->base.err_detail, error->detail);
    } else {
      ctx->base.err_detail[0] = '\0';
    }
    return error->error_code;
  }
  return VPX_CODEC_OK;
}
--------------------
static vpx_codec_err_t update_error_state(vpx_codec_alg_priv_t* ctx, const struct vpx_internal_error_info* error) {
  if (error && error->error_code) {
    if (error->has_detail) {
      snprintf(ctx->base.err_detail, sizeof(ctx->base.err_detail), "%s", error->detail);
    } else {
      ctx->base.err_detail[0] = '\0';
    }
  } else {
    ctx->base.err_detail[0] = '\0';
  }
  return error ? error->error_code : VPX_CODEC_OK;
}
--------------------
static vpx_codec_err_t update_error_state(vpx_codec_alg_priv_t* ctx, const struct vpx_internal_error_info* error) {
  if (error && error->error_code) {
    if (error->has_detail && error->detail) {
      strncpy(ctx->base.err_detail, error->detail, sizeof(ctx->base.err_detail) - 1);
      ctx->base.err_detail[sizeof(ctx->base.err_detail) - 1] = '\0';
    } else {
      ctx->base.err_detail[0] = '\0';
    }
  } else {
    ctx->base.err_detail[0] = '\0';
  }
  return error ? error->error_code : VPX_CODEC_OK;
}
--------------------
static vpx_codec_err_t update_error_state(vpx_codec_alg_priv_t* ctx, const struct vpx_internal_error_info* error) {
  if (error && error->error_code) {
    if (error->has_detail) {
      strncpy_s(ctx->base.err_detail, sizeof(ctx->base.err_detail), error->detail, _TRUNCATE);
    } else {
      ctx->base.err_detail[0] = '\0';
    }
  } else {
    ctx->base.err_detail[0] = '\0';
  }
  return error ? error->error_code : VPX_CODEC_OK;
}
--------------------
static vpx_codec_err_t update_error_state(vpx_codec_alg_priv_t* ctx, const struct vpx_internal_error_info* error) {
  if (error && error->error_code) {
    if (error->has_detail && error->detail) {
      strncpy(ctx->base.err_detail, error->detail, sizeof(ctx->base.err_detail) - 1);
      ctx->base.err_detail[sizeof(ctx->base.err_detail) - 1] = '\0';
    } else {
      ctx->base.err_detail[0] = '\0';
    }
  } else {
    ctx->base.err_detail[0] = '\0';
  }
  return (error && error->error_code == VPX_CODEC_OK) ? VPX_CODEC_ERROR : error->error_code;
}
--------------------
static vpx_codec_err_t update_error_state(vpx_codec_alg_priv_t* ctx, const struct vpx_internal_error_info* error) {
  if (error && error->error_code) {
    if (error->has_detail) {
      strncpy(ctx->base.err_detail, error->detail, sizeof(ctx->base.err_detail) - 1);
      ctx->base.err_detail[sizeof(ctx->base.err_detail) - 1] = '\0';
    } else {
      ctx->base.err_detail[0] = '\0';
    }
  } else {
    ctx->base.err_detail[0] = '\0';
  }
  return (error && error->error_code != VPX_CODEC_OK) ? error->error_code : VPX_CODEC_ERROR;
}
--------------------
match:0
