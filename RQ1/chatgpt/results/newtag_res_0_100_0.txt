source:
 tdata_t _TIFFmalloc ( tsize_t s ) <S2SV_StartBug> { <S2SV_EndBug> return ( malloc ( ( size_t ) s ) ) ; }

target:
tdata_t _TIFFmalloc ( tsize_t s ) { if ( s == 0 ) return ( ( void * ) NULL ) ; return ( malloc ( ( size_t ) s ) ) ; }
outputs:
tdata_t _TIFFmalloc(tsize_t s) {
  if(s < 0) {
    return NULL;
  }
  return malloc((size_t)s);
}
--------------------
tdata_t _TIFFmalloc(tsize_t s) {
  return calloc(1, (size_t)s);
}
--------------------
tdata_t _TIFFmalloc(tsize_t s) {
  tdata_t ptr = malloc((size_t)s);
  if(ptr == NULL) {
    // handle error
    exit(1);
  }
  return ptr;
}
--------------------
tdata_t _TIFFmalloc(tsize_t s) {
  static tdata_t ptr = NULL;
  ptr = realloc(ptr, (size_t)s);
  if(ptr == NULL) {
    // handle error
    exit(1);
  }
  return ptr;
}
--------------------
#define POOL_SIZE 100
static tdata_t pool[POOL_SIZE];
static int pool_index = 0;

tdata_t _TIFFmalloc(tsize_t s) {
  if(pool_index >= POOL_SIZE) {
    // handle error, pool is full
    exit(1);
  }
  return pool[pool_index++];
}
--------------------
tdata_t _TIFFmalloc(tsize_t s) {
  if(s < 0 || s > SIZE_MAX) {
    return NULL;
  }
  return malloc((size_t)s);
}
--------------------
tdata_t _TIFFmalloc(tsize_t s) {
  return mmap(NULL, (size_t)s, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
}
--------------------
tdata_t _TIFFmalloc(tsize_t s) {
  // implementation of custom allocator using slab allocation
}
--------------------
tdata_t _TIFFmalloc(tsize_t s) {
  // implementation of garbage collector
}
--------------------
#include <memory>

std::unique_ptr<tdata_t> _TIFFmalloc(tsize_t s) {
  return std::unique_ptr<tdata_t>(new tdata_t[s]);
}
--------------------
match:0
source:
 static void skcipher_release ( void * private ) { <S2SV_StartBug> crypto_free_skcipher ( private ) ; <S2SV_EndBug> }

target:
static void skcipher_release ( void * private ) { struct skcipher_tfm * tfm = private ; crypto_free_skcipher ( tfm -> skcipher ) ; kfree ( tfm ) ; }
outputs:
match:0
source:
 void _modinit ( module_t * m ) { service_named_bind_command ( "chanserv" , & cs_flags ) ; <S2SV_StartBug> } <S2SV_EndBug>

target:
void _modinit ( module_t * m ) { service_named_bind_command ( "chanserv" , & cs_flags ) ; add_bool_conf_item ( "ANOPE_FLAGS_COMPAT" , & chansvs . me -> conf_table , 0 , & anope_flags_compat , true ) ; hook_add_event ( "nick_can_register" ) ; hook_add_nick_can_register ( check_registration_keywords ) ; hook_add_event ( "user_can_register" ) ; hook_add_user_can_register ( check_registration_keywords ) ; }
outputs:
match:0
source:
 <S2SV_StartBug> void * H264SwDecMalloc ( u32 size ) <S2SV_EndBug> { <S2SV_StartBug> return malloc ( size ) ; <S2SV_EndBug> }

target:
void * H264SwDecMalloc ( u32 size , u32 num ) { if ( size > UINT32_MAX / num ) { return NULL ; } return malloc ( size * num ) ; }
outputs:
match:0
source:
 static void ast_dealloc ( AST_object * self ) <S2SV_StartBug> { <S2SV_EndBug> Py_CLEAR ( self -> dict ) ; Py_TYPE ( self ) -> tp_free ( self ) ; }

target:
static void ast_dealloc ( AST_object * self ) { PyObject_GC_UnTrack ( self ) ; Py_CLEAR ( self -> dict ) ; Py_TYPE ( self ) -> tp_free ( self ) ; }
outputs:
match:0
source:
 <S2SV_StartBug> int file_is_y4m ( const char detect [ 4 ] ) { <S2SV_EndBug> if ( memcmp ( detect , "YUV4" , 4 ) == 0 ) { return 1 ; } return 0 ; }

target:
static int file_is_y4m ( const char detect [ 4 ] ) { if ( memcmp ( detect , "YUV4" , 4 ) == 0 ) { return 1 ; } return 0 ; }
outputs:
int file_is_y4m(const char detect[4]) {
  if (strncmp(detect, "YUV4", 4) == 0 && detect[4] == '\0') {
    return 1;
  }
  return 0;
}
--------------------
int file_is_y4m(const char* detect) {
  size_t len = strlen(detect);
  if (len >= 4 && memcmp(detect, "YUV4", 4) == 0) {
    return 1;
  }
  return 0;
}
--------------------
#define Y4M_MAGIC "YUV4"
int file_is_y4m(const char* detect) {
  size_t len = strlen(detect);
  if (len >= strlen(Y4M_MAGIC) && memcmp(detect, Y4M_MAGIC, strlen(Y4M_MAGIC)) == 0) {
    return 1;
  }
  return 0;
}
--------------------
enum file_format {
  Y4M,
  ...
};
int detect_file_format(const char* detect) {
  if (strlen(detect) < 4) {
    return -1;
  }
  if (memcmp(detect, "YUV4", 4) == 0) {
    return Y4M;
  }
  ...
}
--------------------
enum file_format {
  Y4M,
  ...
};
int detect_file_format(const char* detect) {
  if (strlen(detect) < 4) {
    return -1;
  }
  switch (detect[0]) {
    case 'Y':
      if (memcmp(detect, "YUV4", 4) == 0) {
        return Y4M;
      }
      break;
    ...
  }
  return -1;
}
--------------------
bool file_is_y4m(const char* detect) {
  size_t len = strlen(detect);
  return (len >= strlen(Y4M_MAGIC) && memcmp(detect, Y4M_MAGIC, strlen(Y4M_MAGIC)) == 0);
}
--------------------
const char* const Y4M_MAGIC = "YUV4";
bool file_is_y4m(const char* detect) {
  size_t len = strlen(detect);
  return (len >= strlen(Y4M_MAGIC) && memcmp(detect, Y4M_MAGIC, strlen(Y4M_MAGIC)) == 0);
}
--------------------
const char* const Y4M_MAGIC = "yuv4";
bool file_is_y4m(const char* detect) {
  size_t len = strlen(detect);
  char* detect_lower = strndup(detect, len);
  for (int i = 0; i < len; i++) {
    detect_lower[i] = tolower(detect_lower[i]);
  }
  bool result = (len >= strlen(Y4M_MAGIC) && memcmp(detect_lower, Y4M_MAGIC, strlen(Y4M_MAGIC)) == 0);
  free(detect_lower);
  return result;
}
--------------------
const char* const Y4M_MAGIC = "yuv4";
bool file_is_y4m(const char* detect) {
  size_t len = strlen(detect);
  bool result = (len >= strlen(Y4M_MAGIC) && strncasecmp(detect, Y4M_MAGIC, strlen(Y4M_MAGIC)) == 0);
  return result;
}
--------------------
const char* const Y4M_MAGIC = "YUV4";
bool file_is_y4m(const char* detect) {
  return (strcmp(detect, Y4M_MAGIC) == 0);
}
--------------------
match:0
source:
 static void mark_commit ( struct commit * c , void * data ) { <S2SV_StartBug> mark_object ( & c -> object , NULL , NULL , data ) ; <S2SV_EndBug> }

target:
static void mark_commit ( struct commit * c , void * data ) { mark_object ( & c -> object , NULL , data ) ; }
outputs:
match:0
source:
 static int sock_close ( struct inode * inode , struct file * filp ) { <S2SV_StartBug> sock_release ( SOCKET_I ( inode ) ) ; <S2SV_EndBug> return 0 ; }

target:
static int sock_close ( struct inode * inode , struct file * filp ) { __sock_release ( SOCKET_I ( inode ) , inode ) ; return 0 ; }
outputs:
match:0
source:
 static int sock_close ( struct inode * inode , struct file * filp ) { <S2SV_StartBug> sock_release ( SOCKET_I ( inode ) ) ; <S2SV_EndBug> return 0 ; }

target:
static int sock_close ( struct inode * inode , struct file * filp ) { __sock_release ( SOCKET_I ( inode ) , inode ) ; return 0 ; }
outputs:
static int sock_close(struct inode *inode, struct file *filp) {
    if(SOCKET_I(inode) != NULL){
        sock_release (SOCKET_I(inode));
    }
    return 0;
}
--------------------
static int sock_close(struct inode *inode, struct file *filp) {
    if (SOCKET_I(inode)) {
        sock_release(SOCKET_I(inode));
    }
    return 0;
}
--------------------
static int sock_close(struct inode *inode, struct file *filp) {
    if (inode && SOCKET_I(inode)) {
        sock_release(SOCKET_I(inode));
    }
    return 0;
}
--------------------
static int sock_close(struct inode *inode, struct file *filp) {
    if (filp->private_data) {
        sock_release(filp->private_data);
    }
    return 0;
}
--------------------
static int sock_close(struct inode *inode, struct file *filp) {
    int ret = 0;
    if (filp->private_data) {
        ret = sock_release(filp->private_data);
        if (ret < 0) {
            printk(KERN_ERR "sock_close: Failed to release socket\n");
        }
    }
    return ret;
}
--------------------
static int sock_close(struct inode *inode, struct file *filp) {
    int ret = 0;
    if (filp->private_data) {
        mutex_lock(&filp->private_data->sk_mutex);
        ret = sock_release(filp->private_data);
        mutex_unlock(&filp->private_data->sk_mutex);
        if (ret < 0) {
            printk(KERN_ERR "sock_close: Failed to release socket\n");
        }
    }
    return ret;
}
--------------------
static int sock_close(struct inode *inode, struct file *filp) {
    int ret = 0;
    if (filp->private_data) {
        spin_lock_bh(&filp->private_data->sk_lock);
        ret = sock_release(filp->private_data);
        spin_unlock_bh(&filp->private_data->sk_lock);
        if (ret < 0) {
            printk(KERN_ERR "sock_close: Failed to release socket\n");
        }
    }
    return ret;
}
--------------------
static int sock_close(struct inode *inode, struct file *filp) {
    int ret = 0;
    struct sock *sk;
    if (filp->private_data) {
        sk = filp->private_data;
        mutex_lock(&sk->sk_mutex);
        if (atomic_dec_and_test(&sk->sk_users)) {
            ret = sock_release(sk);
        }
        mutex_unlock(&sk->sk_mutex);
        if (ret < 0) {
            printk(KERN_ERR "sock_close: Failed to release socket\n");
        }
    }
    return ret;
}
--------------------
static int sock_close(struct inode *inode, struct file *filp) {
    int ret = 0;
    struct sock *sk;
    if (filp->private_data) {
        sk = filp->private_data;
        mutex_lock(&sk->sk_mutex);
        if (atomic_dec_and_test(&sk->sk_users)) {
            ret = sock_release(sk);
        }
        mutex_unlock(&sk->sk_mutex);
        if (ret < 0) {
            printk(KERN_ERR "sock_close: Failed to release socket\n");
        }
        filp->private_data = NULL;
    }
    return ret;
}
--------------------
static int sock_close(struct inode *inode, struct file *filp) {
    int ret = 0;
    struct sock *sk;
    if (filp->private_data) {
        sk = filp->private_data;
        mutex_lock(&sk->sk_mutex);
        if (atomic_dec_and_test(&sk->sk_users)) {
            sock_release(sk);
        }
        mutex_unlock(&sk->sk_mutex);
        kfree(sk);
        filp->private_data = NULL;
    }
    return ret;
}
--------------------
match:0
source:
 int pure_strcmp ( const char * const s1 , const char * const s2 ) { <S2SV_StartBug> return pure_memcmp ( s1 , s2 , strlen ( s1 ) + 1U ) ; <S2SV_EndBug> }

target:
int pure_strcmp ( const char * const s1 , const char * const s2 ) { const size_t s1_len = strlen ( s1 ) ; const size_t s2_len = strlen ( s2 ) ; const size_t len = ( s1_len < s2_len ) ? s1_len : s2_len ; return pure_memcmp ( s1 , s2 , len + 1 ) ; }
outputs:
match:0
source:
 <S2SV_StartBug> static char * print_string ( cJSON * item ) <S2SV_EndBug> { <S2SV_StartBug> return print_string_ptr ( item -> valuestring ) ; <S2SV_EndBug> }

target:
static char * print_string ( cJSON * item , printbuffer * p ) { return print_string_ptr ( item -> valuestring , p ) ; }
outputs:
match:0
source:
 static inline int mount_entry_on_systemfs ( struct mntent * mntent ) { <S2SV_StartBug> return mount_entry_on_generic ( mntent , mntent -> mnt_dir ) ; <S2SV_EndBug> }

target:
static inline int mount_entry_on_systemfs ( struct mntent * mntent ) { return mount_entry_on_generic ( mntent , mntent -> mnt_dir , NULL ) ; }
outputs:
match:0
source:
 static inline int mount_entry_on_systemfs ( struct mntent * mntent ) { <S2SV_StartBug> return mount_entry_on_generic ( mntent , mntent -> mnt_dir ) ; <S2SV_EndBug> }

target:
static inline int mount_entry_on_systemfs ( struct mntent * mntent ) { return mount_entry_on_generic ( mntent , mntent -> mnt_dir , NULL ) ; }
outputs:
match:0
source:
 static vpx_codec_err_t encoder_init ( vpx_codec_ctx_t * ctx , vpx_codec_priv_enc_mr_cfg_t * data ) { <S2SV_StartBug> return encoder_common_init ( ctx ) ; <S2SV_EndBug> }

target:
static vpx_codec_err_t encoder_init ( vpx_codec_ctx_t * ctx , vpx_codec_priv_enc_mr_cfg_t * data ) { vpx_codec_err_t res = VPX_CODEC_OK ; ( void ) data ; if ( ctx -> priv == NULL ) { vpx_codec_alg_priv_t * const priv = vpx_calloc ( 1 , sizeof ( * priv ) ) ; if ( priv == NULL ) return VPX_CODEC_MEM_ERROR ; ctx -> priv = ( vpx_codec_priv_t * ) priv ; ctx -> priv -> init_flags = ctx -> init_flags ; ctx -> priv -> enc . total_encoders = 1 ; priv -> buffer_pool = ( BufferPool * ) vpx_calloc ( 1 , sizeof ( BufferPool ) ) ; if ( priv -> buffer_pool == NULL ) return VPX_CODEC_MEM_ERROR ; # if CONFIG_MULTITHREAD if ( pthread_mutex_init ( & priv -> buffer_pool -> pool_mutex , NULL ) ) { return VPX_CODEC_MEM_ERROR ; } # endif if ( ctx -> config . enc ) { priv -> cfg = * ctx -> config . enc ; ctx -> config . enc = & priv -> cfg ; } priv -> extra_cfg = default_extra_cfg ; once ( vp9_initialize_enc ) ; res = validate_config ( priv , & priv -> cfg , & priv -> extra_cfg ) ; if ( res == VPX_CODEC_OK ) { set_encoder_config ( & priv -> oxcf , & priv -> cfg , & priv -> extra_cfg ) ; # if CONFIG_VP9_HIGHBITDEPTH priv -> oxcf . use_highbitdepth = ( ctx -> init_flags & VPX_CODEC_USE_HIGHBITDEPTH ) ? 1 : 0 ; # endif priv -> cpi = vp9_create_compressor ( & priv -> oxcf , priv -> buffer_pool ) ; if ( priv -> cpi == NULL ) res = VPX_CODEC_MEM_ERROR ; else priv -> cpi -> output_pkt_list = & priv -> pkt_list . head ; } } return res ; }
outputs:
match:0
source:
 void vp8_default_coef_probs ( VP8_COMMON * pc ) { <S2SV_StartBug> vpx_memcpy ( pc -> fc . coef_probs , default_coef_probs , <S2SV_EndBug> sizeof ( default_coef_probs ) ) ; }

target:
void vp8_default_coef_probs ( VP8_COMMON * pc ) { memcpy ( pc -> fc . coef_probs , default_coef_probs , sizeof ( default_coef_probs ) ) ; }
outputs:
void vp8_default_coef_probs(VP8_COMMON *pc) {
  if (pc) {
    vpx_memcpy(pc->fc.coef_probs, default_coef_probs, sizeof(default_coef_probs));
  } else {
    // handle error, log or return error code
  }
}
--------------------
void vp8_default_coef_probs(VP8_COMMON *pc) {
  if (pc) {
    memcpy_s(pc->fc.coef_probs, sizeof(pc->fc.coef_probs), default_coef_probs, sizeof(default_coef_probs));
  } else {
    // handle error, log or return error code
  }
}
--------------------
#define COEF_PROBS_SIZE sizeof(default_coef_probs)

void vp8_default_coef_probs(VP8_COMMON *pc) {
  if (pc) {
    vpx_memcpy(pc->fc.coef_probs, default_coef_probs, COEF_PROBS_SIZE);
  } else {
    // handle error, log or return error code
  }
}
--------------------
void vp8_default_coef_probs(VP8_COMMON *pc) {
  size_t size = sizeof(default_coef_probs);
  if (pc) {
    vpx_memcpy(pc->fc.coef_probs, default_coef_probs, size);
  } else {
    // handle error, log or return error code
  }
}
--------------------
void vp8_default_coef_probs(VP8_COMMON *pc) {
  if (pc) {
    memmove(pc->fc.coef_probs, default_coef_probs, sizeof(default_coef_probs));
  } else {
    // handle error, log or return error code
  }
}
--------------------
void vp8_default_coef_probs(VP8_COMMON *pc) {
  if (pc && sizeof(pc->fc.coef_probs) >= sizeof(default_coef_probs)) {
    vpx_memcpy(pc->fc.coef_probs, default_coef_probs, sizeof(default_coef_probs));
  } else {
    // handle error, log or return error code
  }
}
--------------------
void vp8_default_coef_probs(VP8_COMMON *pc) {
  if (!pc) {
    // handle null pointer input error, log or return error code
    return;
  }
  vpx_memcpy(pc->fc.coef_probs, default_coef_probs, sizeof(default_coef_probs));
}
--------------------
void vp8_default_coef_probs(VP8_COMMON *pc) {
  if (pc && sizeof(pc->fc.coef_probs) >= sizeof(default_coef_probs)) {
    volatile int guard = 0;
    // add guard code here
    vpx_memcpy(pc->fc.coef_probs, default_coef_probs, sizeof(default_coef_probs));
    guard += 1; // update guard code to prevent compiler optimization
  } else {
    // handle error, log or return error code
  }
}
--------------------
#define CHECK_NULL_PTR(ptr) if (!ptr) { return; /* or handle error */ }
#define COEF_PROBS_SIZE sizeof(default_coef_probs)

void vp8_default_coef_probs(VP8_COMMON *pc) {
  CHECK_NULL_PTR(pc)
  vpx_memcpy(pc->fc.coef_probs, default_coef_probs, COEF_PROBS_SIZE);
}
--------------------
/**
 * Copies the default coefficient probabilities from the global array to the given VP8_COMMON instance.
 * @param pc Pointer to the VP8_COMMON instance to copy the probabilities to
 */
void vp8_default_coef_probs(VP8_COMMON *pc) {
  if (pc) {
    vpx_memcpy(pc->fc.coef_probs, default_coef_probs, sizeof(default_coef_probs));
  } else {
    // handle error, log or return error code
  }
}
--------------------
match:0
source:
 static int hns_xgmac_get_sset_count ( int stringset ) { <S2SV_StartBug> if ( stringset == ETH_SS_STATS ) <S2SV_EndBug> return ARRAY_SIZE ( g_xgmac_stats_string ) ; return 0 ; }

target:
static int hns_xgmac_get_sset_count ( int stringset ) { if ( stringset == ETH_SS_STATS || stringset == ETH_SS_PRIV_FLAGS ) return ARRAY_SIZE ( g_xgmac_stats_string ) ; return 0 ; }
outputs:
match:0
source:
 void recovery_delete_character ( void ) <S2SV_StartBug> { <S2SV_EndBug> if ( strlen ( mnemonic ) > 0 ) { mnemonic [ strlen ( mnemonic ) - 1 ] = '\\0' ; } next_character ( ) ; }

target:
void recovery_delete_character ( void ) { if ( ! recovery_started ) { recovery_abort ( ) ; fsm_sendFailure ( FailureType_Failure_UnexpectedMessage , "NotinRecoverymode" ) ; layoutHome ( ) ; return ; } if ( strlen ( mnemonic ) > 0 ) { mnemonic [ strlen ( mnemonic ) - 1 ] = '\\0' ; } next_character ( ) ; }
outputs:
match:0
source:
 <S2SV_StartBug> void generic_pipe_buf_get ( struct pipe_inode_info * pipe , struct pipe_buffer * buf ) <S2SV_EndBug> { <S2SV_StartBug> get_page ( buf -> page ) ; <S2SV_EndBug> }

target:
bool generic_pipe_buf_get ( struct pipe_inode_info * pipe , struct pipe_buffer * buf ) { return try_get_page ( buf -> page ) ; }
outputs:
match:0
source:
 static char * pool_strdup ( const char * s ) { <S2SV_StartBug> char * r = pool_alloc ( strlen ( s ) + 1 ) ; <S2SV_EndBug> <S2SV_StartBug> strcpy ( r , s ) ; <S2SV_EndBug> return r ; }

target:
static char * pool_strdup ( const char * s ) { size_t len = strlen ( s ) + 1 ; char * r = pool_alloc ( len ) ; memcpy ( r , s , len ) ; return r ; }
outputs:
match:0
source:
 struct crypto_template * crypto_lookup_template ( const char * name ) { <S2SV_StartBug> return try_then_request_module ( __crypto_lookup_template ( name ) , "%s" , <S2SV_EndBug> name ) ; }

target:
struct crypto_template * crypto_lookup_template ( const char * name ) { return try_then_request_module ( __crypto_lookup_template ( name ) , "crypto-%s" , name ) ; }
outputs:
struct crypto_template *crypto_lookup_template(const char *name) {
    return try_then_request_module(__crypto_lookup_template(name),
                                    "crypto_template: %s",
                                    name);
}
--------------------
static int __init my_module_init(void) {
    return 0;
}

static void __exit my_module_exit(void) {
}

module_init(my_module_init);
module_exit(my_module_exit);
MODULE_LICENSE("GPL");
--------------------
struct crypto_template *crypto_lookup_template(const char *name) {
    return try_then_request_module(__crypto_lookup_template(name),
                                    "crypto_template %s",
                                    name);
}
--------------------
struct crypto_template *crypto_lookup_template(const char *name) {
    return try_then_request_module(__crypto_lookup_template(name),
                                    "crypto_template: %s\n",
                                    name);
}
--------------------
struct crypto_template *crypto_lookup_template(const char *name) {
    char module_name[256];
    snprintf(module_name, sizeof(module_name), "crypto_template:%s", name);
    return try_then_request_module(__crypto_lookup_template(name), "%s", module_name);
}
--------------------
struct crypto_template *crypto_lookup_template(const char *name) {
    return try_then_request_module(__crypto_lookup_template(name),
                                    "crypto_template:%s\n",
                                    name);
}
--------------------
struct crypto_template *crypto_lookup_template(const char *name) {
    return try_then_request_module(__crypto_lookup_template(name),
                                    "crypto_template: %s\n",
                                    name);
}
--------------------
struct crypto_template *crypto_lookup_template(const char *name) {
    return try_then_request_module(__crypto_lookup_template(name),
                                    "crypto_template %s loaded",
                                    name);
}
--------------------
#include <linux/module.h>
#include <linux/crypto.h>
#include <linux/init.h>

MODULE_LICENSE("GPL");

struct crypto_template *crypto_lookup_template(const char *name)
{
    return try_then_request_module(__crypto_lookup_template(name),
                                    "crypto_template:%s", name);
}

static int __init example_init(void)
{
    printk(KERN_INFO "Example module initialized.\n");
    return 0;
}

static void __exit example_exit(void)
{
    printk(KERN_INFO "Example module exited.\n");
}

module_init(example_init);
module_exit(example_exit);
--------------------
struct crypto_template *crypto_lookup_template(const char *name) {
    return try_then_request_module(__crypto_lookup_template(name), "crypto_template:%s", name);
}
--------------------
match:0
source:
 static void * skcipher_bind ( const char * name , u32 type , u32 mask ) { <S2SV_StartBug> return crypto_alloc_skcipher ( name , type , mask ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>

target:
static void * skcipher_bind ( const char * name , u32 type , u32 mask ) { struct skcipher_tfm * tfm ; struct crypto_skcipher * skcipher ; tfm = kzalloc ( sizeof ( * tfm ) , GFP_KERNEL ) ; if ( ! tfm ) return ERR_PTR ( - ENOMEM ) ; skcipher = crypto_alloc_skcipher ( name , type , mask ) ; if ( IS_ERR ( skcipher ) ) { kfree ( tfm ) ; return ERR_CAST ( skcipher ) ; } tfm -> skcipher = skcipher ; return tfm ; }
outputs:
match:0
source:
 void vp9_frame_init_quantizer ( VP9_COMP * cpi ) { <S2SV_StartBug> cpi -> zbin_mode_boost = 0 ; <S2SV_EndBug> <S2SV_StartBug> vp9_init_plane_quantizers ( cpi , & cpi -> mb ) ; <S2SV_EndBug> }

target:
void vp9_frame_init_quantizer ( VP9_COMP * cpi ) { vp9_init_plane_quantizers ( cpi , & cpi -> td . mb ) ; }
outputs:
match:0
source:
 static void l2tp_eth_dev_setup ( struct net_device * dev ) { ether_setup ( dev ) ; <S2SV_StartBug> dev -> netdev_ops = & l2tp_eth_netdev_ops ; <S2SV_EndBug> dev -> destructor = free_netdev ; }

target:
static void l2tp_eth_dev_setup ( struct net_device * dev ) { ether_setup ( dev ) ; dev -> priv_flags &= ~ IFF_TX_SKB_SHARING ; dev -> netdev_ops = & l2tp_eth_netdev_ops ; dev -> destructor = free_netdev ; }
outputs:
static void l2tp_eth_dev_setup ( struct net_device * dev ) { 
    ether_setup ( dev ) ; 
    dev->netdev_ops = dev_net_ops(dev); 
    dev->destructor = free_netdev; 
}
--------------------
static struct net_device_ops l2tp_eth_netdev_ops = { .ndo_init = l2tp_eth_dev_init, .ndo_uninit = l2tp_eth_dev_deinit, }; 
static void l2tp_eth_dev_setup ( struct net_device * dev ) { 
    ether_setup ( dev ) ; 
    dev->netdev_ops = &l2tp_eth_netdev_ops; 
    dev->destructor = free_netdev; 
}
--------------------
static struct net_device_ops l2tp_eth_netdev_ops; 
static void l2tp_eth_dev_setup ( struct net_device * dev ) { 
    ether_setup ( dev ) ; 
    memset(&l2tp_eth_netdev_ops, 0, sizeof(struct net_device_ops)); 
    l2tp_eth_netdev_ops.ndo_init = l2tp_eth_dev_init; 
    l2tp_eth_netdev_ops.ndo_uninit = l2tp_eth_dev_deinit; 
    dev->netdev_ops = &l2tp_eth_netdev_ops; 
    dev->destructor = free_netdev; 
}
--------------------
#if defined(CONFIG_L2TP_ETH) && (CONFIG_L2TP_ETH==1) 
static struct net_device_ops l2tp_eth_netdev_ops = { .ndo_init = l2tp_eth_dev_init, .ndo_uninit = l2tp_eth_dev_deinit, }; 
#else 
static struct net_device_ops l2tp_eth_netdev_ops; 
#endif 

static void l2tp_eth_dev_setup ( struct net_device * dev ) { 
    ether_setup ( dev ) ; 
    dev->netdev_ops = &l2tp_eth_netdev_ops; 
    dev->destructor = free_netdev; 
}
--------------------
static void l2tp_eth_dev_setup ( struct net_device * dev ) { 
    ether_setup ( dev ) ; 
    dev->netdev_ops = &l2tp_eth_netdev_ops; 
    dev->destructor = free_netdev; 
    dev->netdev_ops = NULL; 
}
--------------------
static void l2tp_eth_dev_setup ( struct net_device * dev ) { 
    ether_setup ( dev ) ; 
    dev->netdev_ops = &l2tp_eth_netdev_ops; 
    dev->destructor = devm_free_netdev; 
}
--------------------
static void l2tp_eth_dev_destructor(struct net_device *dev) { 
    unregister_netdev(dev); 
    free_netdev(dev); 
}

static void l2tp_eth_dev_setup ( struct net_device * dev ) { 
    ether_setup ( dev ) ; 
    dev->netdev_ops = &l2tp_eth_netdev_ops; 
    dev->needs_free_netdev = true; 
    dev->destructor = l2tp_eth_dev_destructor; 
}
--------------------
static void l2tp_eth_dev_destructor(struct net_device *dev) { 
    unregister_netdev(dev); 
    free_netdev(dev); 
}

static void l2tp_eth_dev_setup ( struct net_device * dev ) { 
    dev = devm_ether_alloc(dev); 
    dev->netdev_ops = &l2tp_eth_netdev_ops; 
    dev->needs_free_netdev = true; 
    dev->destructor = l2tp_eth_dev_destructor; 
}
--------------------
static void l2tp_eth_dev_destructor(struct net_device *dev) { 
    unregister_netdev(dev); 
    free_netdev(dev); 
}

static void l2tp_eth_dev_setup ( struct net_device * dev ) { 
    dev = devm_ether_alloc(dev); 
    if (!dev) 
        return; 
    dev->netdev_ops = &l2tp_eth_netdev_ops; 
    dev->needs_free_netdev = true; 
    dev->destructor = l2tp_eth_dev_destructor; 
}
--------------------
static void l2tp_eth_dev_destructor(struct net_device *dev) { 
    unregister_netdev(dev); 
}

static void l2tp_eth_dev_setup ( struct net_device * dev ) { 
    ether_setup ( dev ) ; 
    dev->netdev_ops = &l2tp_eth_netdev_ops; 
    dev->destructor = l2tp_eth_dev_destructor; 
}
--------------------
match:0
source:
 static void ieee80211_if_setup ( struct net_device * dev ) { ether_setup ( dev ) ; <S2SV_StartBug> dev -> netdev_ops = & ieee80211_dataif_ops ; <S2SV_EndBug> dev -> destructor = free_netdev ; }

target:
static void ieee80211_if_setup ( struct net_device * dev ) { ether_setup ( dev ) ; dev -> priv_flags &= ~ IFF_TX_SKB_SHARING ; dev -> netdev_ops = & ieee80211_dataif_ops ; dev -> destructor = free_netdev ; }
outputs:
match:0
source:
 int X509_verify ( X509 * a , EVP_PKEY * r ) <S2SV_StartBug> { <S2SV_EndBug> return ( ASN1_item_verify ( ASN1_ITEM_rptr ( X509_CINF ) , a -> sig_alg , a -> signature , a -> cert_info , r ) ) ; }

target:
int X509_verify ( X509 * a , EVP_PKEY * r ) { if ( X509_ALGOR_cmp ( a -> sig_alg , a -> cert_info -> signature ) ) return 0 ; return ( ASN1_item_verify ( ASN1_ITEM_rptr ( X509_CINF ) , a -> sig_alg , a -> signature , a -> cert_info , r ) ) ; }
outputs:
match:0
source:
 static int remove_bond ( const bt_bdaddr_t * bd_addr ) <S2SV_StartBug> { <S2SV_EndBug> if ( interface_ready ( ) == FALSE ) return BT_STATUS_NOT_READY ; return btif_dm_remove_bond ( bd_addr ) ; }

target:
static int remove_bond ( const bt_bdaddr_t * bd_addr ) { if ( is_restricted_mode ( ) && ! btif_storage_is_restricted_device ( bd_addr ) ) return BT_STATUS_SUCCESS ; if ( interface_ready ( ) == FALSE ) return BT_STATUS_NOT_READY ; return btif_dm_remove_bond ( bd_addr ) ; }
outputs:
match:0
source:
 static int snd_seq_device_dev_free ( struct snd_device * device ) { struct snd_seq_device * dev = device -> device_data ; <S2SV_StartBug> put_device ( & dev -> dev ) ; <S2SV_EndBug> return 0 ; }

target:
static int snd_seq_device_dev_free ( struct snd_device * device ) { struct snd_seq_device * dev = device -> device_data ; cancel_autoload_drivers ( ) ; put_device ( & dev -> dev ) ; return 0 ; }
outputs:
match:0
source:
 static void smp_task_done ( struct sas_task * task ) { <S2SV_StartBug> if ( ! del_timer ( & task -> slow_task -> timer ) ) <S2SV_EndBug> return ; complete ( & task -> slow_task -> completion ) ; }

target:
static void smp_task_done ( struct sas_task * task ) { del_timer ( & task -> slow_task -> timer ) ; complete ( & task -> slow_task -> completion ) ; }
outputs:
static void smp_task_done(struct sas_task *task) {
    if (del_timer(&task->slow_task->timer)) {
        complete(&task->slow_task->completion);
    }
}
--------------------
static void smp_task_done(struct sas_task *task) {
    if (task && task->slow_task && del_timer(&task->slow_task->timer)) {
        complete(&task->slow_task->completion);
    }
}
--------------------
static void smp_task_done(struct sas_task *task) {
    if (task && task->slow_task) {
        del_timer(&task->slow_task->timer);
        complete(&task->slow_task->completion);
    }
}
--------------------
static void smp_task_done(struct sas_task *task) {
    if (task && task->slow_task) {
        if (del_timer_sync(&task->slow_task->timer) && !completion_done(&task->slow_task->completion)) {
            complete(&task->slow_task->completion);
        }
    }
}
--------------------
static void smp_task_done(struct sas_task *task) {
    if (task && task->slow_task) {
        if (del_timer_sync(&task->slow_task->timer)) {
            if (!completion_done(&task->slow_task->completion)) {
                complete(&task->slow_task->completion);
            }
        } else {
            complete(&task->slow_task->completion); // In case the timer is already expired
        }
    }
}
--------------------
static void smp_task_done(struct sas_task *task) {
    if (!task || !task->slow_task) {
        return;
    }
    if (del_timer_sync(&task->slow_task->timer)) {
        if (!completion_done(&task->slow_task->completion)) {
            complete(&task->slow_task->completion);
        }
    } else {
        complete(&task->slow_task->completion); // In case the timer is already expired
    }
}
--------------------
static void smp_task_done(struct sas_task *task) {
    if (!task || !task->slow_task) {
        return;
    }
    if (time_after(jiffies, task->slow_task->timer.expires)) {
        complete(&task->slow_task->completion);
    } else {
        del_timer_sync(&task->slow_task->timer);
        complete(&task->slow_task->completion);
    }
}
--------------------
static void smp_task_done(struct sas_task *task) {
    if (!task || !task->slow_task) {
        return;
    }
    if (time_after(jiffies, task->slow_task->timer.expires)) {
        complete(&task->slow_task->completion);
    } else {
        del_timer_sync(&task->slow_task->timer);
        if (!completion_done(&task->slow_task->completion)) {
            complete(&task->slow_task->completion);
        }
    }
}
--------------------
static void smp_task_done(struct sas_task *task) {
    if (!task || !task->slow_task) {
        return;
    }
    if (time_after_eq(jiffies, task->slow_task->timer.expires)) {
        complete(&task->slow_task->completion);
    } else {
        mod_timer(&task->slow_task->timer, jiffies + HZ);
    }
}
--------------------
static void smp_task_done(struct sas_task *task) {
    if (!task || !task->slow_task) {
        return;
    }
    if (time_after_eq(jiffies, task->slow_task->timer.expires)) {
        if (!completion_done(&task->slow_task->completion)) {
            complete(&task->slow_task->completion);
        }
    } else {
        mod_timer(&task->slow_task->timer, jiffies + HZ);
    }
}
--------------------
match:0
source:
 void test_checkout_nasty__git_tilde1 ( void ) { <S2SV_StartBug> # ifdef GIT_WIN32 <S2SV_EndBug> test_checkout_fails ( "refs/heads/git_tilde1" , ".git/foobar" ) ; <S2SV_StartBug> # endif <S2SV_EndBug> }

target:
void test_checkout_nasty__git_tilde1 ( void ) { test_checkout_fails ( "refs/heads/git_tilde1" , ".git/foobar" ) ; test_checkout_fails ( "refs/heads/git_tilde1" , "git~1/foobar" ) ; }
outputs:
match:0
source:
 static int jas_iccgetuint32 ( jas_stream_t * in , jas_iccuint32_t * val ) { <S2SV_StartBug> ulonglong tmp ; <S2SV_EndBug> if ( jas_iccgetuint ( in , 4 , & tmp ) ) return - 1 ; * val = tmp ; return 0 ; }

target:
static int jas_iccgetuint32 ( jas_stream_t * in , jas_iccuint32_t * val ) { jas_ulonglong tmp ; if ( jas_iccgetuint ( in , 4 , & tmp ) ) return - 1 ; * val = tmp ; return 0 ; }
outputs:
match:0
source:
 static int jas_iccgetuint64 ( jas_stream_t * in , jas_iccuint64_t * val ) { <S2SV_StartBug> ulonglong tmp ; <S2SV_EndBug> if ( jas_iccgetuint ( in , 8 , & tmp ) ) return - 1 ; * val = tmp ; return 0 ; }

target:
static int jas_iccgetuint64 ( jas_stream_t * in , jas_iccuint64_t * val ) { jas_ulonglong tmp ; if ( jas_iccgetuint ( in , 8 , & tmp ) ) return - 1 ; * val = tmp ; return 0 ; }
outputs:
match:0
source:
 <S2SV_StartBug> static INLINE int write_bit_gte ( vp9_writer * w , int word , int test ) { <S2SV_EndBug> <S2SV_StartBug> vp9_write_literal ( w , word >= test , 1 ) ; <S2SV_EndBug> return word >= test ; }

target:
static INLINE int write_bit_gte ( vpx_writer * w , int word , int test ) { vpx_write_literal ( w , word >= test , 1 ) ; return word >= test ; }
outputs:
static INLINE int write_bit_gte(vp9_writer* w, int word, int test) {
  vp9_write_literal(w, word >= test, 1);
  return word >= test;
}
--------------------
static INLINE int write_bit_gte(vp9_writer* w, int word, int test) {
  if (word >= test) {
    vp9_write_literal(w, 1, 1);
    return 1;
  } else {
    vp9_write_literal(w, 0, 1);
    return 0;
  }
}
--------------------
static INLINE int write_bit_gte(vp9_writer* w, int word, int test) {
  int result = word >= test ? 1 : 0;
  vp9_write_literal(w, result, 1);
  return result;
}
--------------------
static INLINE int write_bit_gte(vp9_writer* w, int word, int test) {
  if (word >= test) {
    vp9_write_literal(w, 1, 1);
    return 1;
  }
  vp9_write_literal(w, 0, 1);
  return 0;
}
--------------------
static INLINE int write_bit_gte(vp9_writer* w, int word, int test) {
  if (word >= test) {
    vp9_write_literal(w, 1, 1);
    return word - test + 1;
  }
  vp9_write_literal(w, 0, 1);
  return 0;
}
--------------------
static INLINE int write_bit_gte(vp9_writer* w, int word, int test) {
  const int result = word >= test;
  vp9_write_literal(w, result, 1);
  return result;
}
--------------------
static INLINE int write_bit_gte(vp9_writer* w, int word, int test) {
  vp9_write_literal(w, word >= test, 1);
  return word - test >= 0;
}
--------------------
static INLINE int write_bit_gte(vp9_writer* w, int word, int test) {
  const int ret = word >= test;
  vp9_write_literal(w, ret, 1);
  return ret;
}
--------------------
static INLINE int write_bit_gte(vp9_writer* w, int word, int test) {
  const int ret = (word >= test) ? 1 : 0;
  vp9_write_literal(w, ret, 1);
  return ret;
}
--------------------
static INLINE int write_bit_gte(vp9_writer* w, int word, int test) {
  int ret = (word >= test) ? 1 : 0;
  vp9_write_literal(w, ret, 1);
  return ret;
}
--------------------
match:0
source:
 static void hugetlbfs_put_super ( struct super_block * sb ) { struct hugetlbfs_sb_info * sbi = HUGETLBFS_SB ( sb ) ; if ( sbi ) { sb -> s_fs_info = NULL ; <S2SV_StartBug> kfree ( sbi ) ; <S2SV_EndBug> } }

target:
static void hugetlbfs_put_super ( struct super_block * sb ) { struct hugetlbfs_sb_info * sbi = HUGETLBFS_SB ( sb ) ; if ( sbi ) { sb -> s_fs_info = NULL ; if ( sbi -> spool ) hugepage_put_subpool ( sbi -> spool ) ; kfree ( sbi ) ; } }
outputs:
static void hugetlbfs_put_super(struct super_block *sb) {
    struct hugetlbfs_sb_info *sbi = HUGETLBFS_SB(sb);
    if (sbi) {
        sb->s_fs_info = NULL;
        kfree(sbi);
    }
}
--------------------
static void hugetlbfs_put_super(struct super_block *sb) {
    if (!sb) {
        return;
    }
    struct hugetlbfs_sb_info *sbi = HUGETLBFS_SB(sb);
    if (sbi) {
        sb->s_fs_info = NULL;
        kfree(sbi);
    }
}
--------------------
static void hugetlbfs_put_super(struct super_block *sb) {
    if (!sb) {
        return;
    }
    struct hugetlbfs_sb_info *sbi = HUGETLBFS_SB(sb);
    if (sbi) {
        sb->s_fs_info = NULL;
        if (!IS_ERR_OR_NULL(sbi)) {
            kfree(sbi);
        }
    }
}
--------------------
static void hugetlbfs_put_super(struct super_block *sb) {
    if (!sb) {
        return;
    }
    struct hugetlbfs_sb_info *sbi = HUGETLBFS_SB(sb);
    if (sbi) {
        sb->s_fs_info = NULL;
        if (IS_ERR_OR_NULL(sbi)) {
            return;
        }
        kfree(sbi);
    }
}
--------------------
static void hugetlbfs_put_super(struct super_block *sb) {
    if (!sb) {
        return;
    }
    struct hugetlbfs_sb_info *sbi = HUGETLBFS_SB(sb);
    if (sbi) {
        sb->s_fs_info = NULL;
        if (IS_ERR_OR_NULL(sbi)) {
            return;
        }
        kfree_sensitive(sbi);
    }
}
--------------------
static void hugetlbfs_put_super(struct super_block *sb) {
    if (!sb) {
        return;
    }
    struct hugetlbfs_sb_info *sbi = HUGETLBFS_SB(sb);
    if (sbi) {
        sb->s_fs_info = NULL;
        if (IS_ERR_OR_NULL(sbi)) {
            return;
        }
        kmem_cache_free(hugetlbfs_info_cache, sbi);
    }
}
--------------------
static void hugetlbfs_put_super(struct super_block *sb) {
    if (!sb) {
        return;
    }
    struct hugetlbfs_sb_info *sbi = HUGETLBFS_SB(sb);
    if (sbi) {
        sb->s_fs_info = NULL;
        if (IS_ERR_OR_NULL(sbi)) {
            return;
        }
        memset(sbi, 0, sizeof(*sbi));
        kmem_cache_free(hugetlbfs_info_cache, sbi);
    }
}
--------------------
static void hugetlbfs_put_super(struct super_block *sb) {
    if (!sb) {
        return;
    }
    struct hugetlbfs_sb_info *sbi = HUGETLBFS_SB(sb);
    if (sbi) {
        if (sb->s_fs_info == sbi) {
            sb->s_fs_info = NULL;
        }
        if (IS_ERR_OR_NULL(sbi)) {
            return;
        }
        memset(sbi, 0, sizeof(*sbi));
        kmem_cache_free(hugetlbfs_info_cache, sbi);
    }
}
--------------------
static void hugetlbfs_put_super(struct super_block *sb) {
    if (!sb) {
        return;
    }
    struct hugetlbfs_sb_info *sbi = HUGETLBFS_SB(sb);
    if (sbi) {
        sb_set_blocksize(sb, PAGE_SIZE);
        if (sb_blocksize(sb) != PAGE_SIZE) {
            pr_err("hugetlbfs_put_super: sb_blocksize changed\n");
        }
        if (sb->s_fs_info == sbi) {
            sb->s_fs_info = NULL;
        }
        if (IS_ERR_OR_NULL(sbi)) {
            return;
        }
        memset(sbi, 0, sizeof(*sbi));
        kmem_cache_free(hugetlbfs_info_cache, sbi);
    }
}
--------------------
static DEFINE_MUTEX(hugetlbfs_mutex);

static void hugetlbfs_put_super(struct super_block *sb) {
    if (!sb) {
        return;
    }
    mutex_lock(&hugetlbfs_mutex);
    struct hugetlbfs_sb_info *sbi = HUGETLBFS_SB(sb);
    if (sbi) {
        sb_set_blocksize(sb, PAGE_SIZE);
        if (sb_blocksize(sb) != PAGE_SIZE) {
            pr_err("hugetlbfs_put_super: sb_blocksize changed\n");
        }
        if (sb->s_fs_info == sbi) {
            sb->s_fs_info = NULL;
        }
        if (IS_ERR_OR_NULL(sbi)) {
            goto out;
        }
        memset(sbi, 0, sizeof(*sbi));
        kmem_cache_free(hugetlbfs_info_cache, sbi);
    }
out:
    mutex_unlock(&hugetlbfs_mutex);
}
--------------------
match:0
source:
 int bson_check_field_name ( bson * b , const char * string , <S2SV_StartBug> const int length ) { <S2SV_EndBug> return bson_validate_string ( b , ( const unsigned char * ) string , length , 1 , 1 , 1 ) ; }

target:
int bson_check_field_name ( bson * b , const char * string , const size_t length ) { return bson_validate_string ( b , ( const unsigned char * ) string , length , 1 , 1 , 1 ) ; }
outputs:
int bson_check_field_name(bson *b, const char *string, const int length) {
    return bson_validate_string(b, (const unsigned char *)string, length, 1, 1, 1);
}
--------------------
int bson_check_field_name(bson *b, const char *string, const int length) {
    if (string == NULL) {
        return BSON_ERROR;
    }
    return bson_validate_string(b, (const unsigned char *)string, length, 1, 1, 1);
}
--------------------
int bson_check_field_name(bson *b, const char *string, const int length) {
    size_t len = strnlen(string, length);
    return bson_validate_string(b, (const unsigned char *)string, len, 1, 1, 1);
}
--------------------
int bson_check_field_name(bson *b, const char *string, const size_t length) {
    return bson_validate_string(b, (const unsigned char *)string, length, 1, 1, 1);
}
--------------------
int bson_check_field_name(bson *b, const char *string, const size_t length) {
    if (length > BSON_MAX_STRING_SIZE || length <= 0) {
        return BSON_ERROR;
    }
    return bson_validate_string(b, (const unsigned char *)string, length, 1, 1, 1);
}
--------------------
int bson_check_field_name(bson *b, const char *string, const size_t length) {
    if (string == NULL || length > (BSON_MAX_STRING_SIZE - 1) || length <= 0 || string[length - 1] != '\0') {
        return BSON_ERROR;
    }
    return bson_validate_string(b, (const unsigned char *)string, length - 1, 1, 1, 1);
}
--------------------
int bson_check_field_name(bson *b, const char *string, const size_t length) {
    char buf[BSON_MAX_STRING_SIZE];
    strncpy(buf, string, length);
    buf[length] = '\0';
    return bson_validate_string(b, (const unsigned char *)buf, length, 1, 1, 1);
}
--------------------
int bson_check_field_name(bson *b, const char *string, const size_t length) {
    if (string == NULL || length > (BSON_MAX_STRING_SIZE - 1) || length <= 0) {
        return BSON_ERROR;
    }
    char buf[BSON_MAX_STRING_SIZE];
    strncpy(buf, string, length);
    buf[length] = '\0';
    return bson_validate_string(b, (const unsigned char *)buf, length, 1, 1, 1);
}
--------------------
int bson_check_field_name(bson *b, const char *string, const size_t length) {
    char buf[BSON_MAX_STRING_SIZE];
    strncpy(buf, string, length);
    buf[length] = '\0';
    return bson_validate_string(b, (const unsigned char *)buf, length, 1, 1, 1);
}
--------------------
int bson_check_field_name(bson *b, const char *string, const size_t length) {
    if (string == NULL || strlen(string) > (BSON_MAX_STRING_SIZE - 1) || length <= 0) {
        return BSON_ERROR;
    }
    return bson_validate_string(b, (const unsigned char *)string, length, 1, 1, 1);
}
--------------------
match:1
source:
 void put_filp ( struct file * file ) { if ( atomic_long_dec_and_test ( & file -> f_count ) ) { security_file_free ( file ) ; <S2SV_StartBug> file_sb_list_del ( file ) ; <S2SV_EndBug> file_free ( file ) ; } }

target:
void put_filp ( struct file * file ) { if ( atomic_long_dec_and_test ( & file -> f_count ) ) { security_file_free ( file ) ; file_free ( file ) ; } }
outputs:
void put_filp(struct file *file) {
    if (atomic_long_dec_and_test(&file->f_count)) {
        security_file_free(file);
        file_free(file);
    }
}
--------------------
void put_filp(struct file *file) {
    if (file && atomic_long_dec_and_test(&file->f_count)) {
        security_file_free(file);
        file_free(file);
    }
}
--------------------
void put_filp(struct file *file) {
    if (file && atomic_long_dec_if_positive(&file->f_count)) {
        security_file_free(file);
        file_free(file);
    }
}
--------------------
void put_filp(struct file *file) {
    if (file) {
        if (atomic_long_dec_and_test(&file->f_count)) {
            security_file_free(file);
            file_free(file);
        }
    }
}
--------------------
void put_filp(struct file *file) {
    if (file) {
        atomic_long_dec(&file->f_count);
        if (atomic_long_read(&file->f_count) == 0) {
            security_file_free(file);
            file_free(file);
        }
    }
}
--------------------
void put_filp(struct file *file) {
    if (!file || !atomic_long_dec_and_test(&file->f_count)) {
        return;
    }
    security_file_free(file);
    file_free(file);
}
--------------------
void put_filp(struct file *file) {
    if (file && atomic_long_dec_return(&file->f_count) == 0) {
        security_file_free(file);
        file_free(file);
    }
}
--------------------
void put_filp(struct file *file) {
    if (file && atomic_long_read(&file->f_count) == 1 && atomic_long_dec_not_positive(&file->f_count)) {
        return;
    }
    security_file_free(file);
    file_free(file);
}
--------------------
void put_filp(struct file *file) {
    if (!file || atomic_long_dec_if_positive(&file->f_count)) {
        return;
    }
    security_file_free(file);
    file_free(file);
}
--------------------
void put_filp(struct file *file) {
    if (!file) {
        return;
    }
    if (atomic_long_dec_and_test(&file->f_count)) {
        security_file_free(file);
        file_free(file);
    }
}
--------------------
match:1
source:
 void close_uinput ( void ) { BTIF_TRACE_DEBUG ( "%s" , __FUNCTION__ ) ; if ( uinput_fd > 0 ) { <S2SV_StartBug> ioctl ( uinput_fd , UI_DEV_DESTROY ) ; <S2SV_EndBug> close ( uinput_fd ) ; uinput_fd = - 1 ; } }

target:
void close_uinput ( void ) { BTIF_TRACE_DEBUG ( "%s" , __FUNCTION__ ) ; if ( uinput_fd > 0 ) { TEMP_FAILURE_RETRY ( ioctl ( uinput_fd , UI_DEV_DESTROY ) ) ; close ( uinput_fd ) ; uinput_fd = - 1 ; } }
outputs:
match:0
source:
 static int check_line_charstring ( void ) { char * p = line ; <S2SV_StartBug> while ( isspace ( * p ) ) <S2SV_EndBug> p ++ ; return ( * p == '/' || ( p [ 0 ] == 'd' && p [ 1 ] == 'u' && p [ 2 ] == 'p' ) ) ; }

target:
static int check_line_charstring ( void ) { char * p = line ; while ( isspace ( ( unsigned char ) * p ) ) p ++ ; return ( * p == '/' || ( p [ 0 ] == 'd' && p [ 1 ] == 'u' && p [ 2 ] == 'p' ) ) ; }
outputs:
match:0
source:
 <S2SV_StartBug> static int read_segment_id ( vp9_reader * r , const struct segmentation * seg ) { <S2SV_EndBug> <S2SV_StartBug> return vp9_read_tree ( r , vp9_segment_tree , seg -> tree_probs ) ; <S2SV_EndBug> }

target:
static int read_segment_id ( vpx_reader * r , const struct segmentation * seg ) { return vpx_read_tree ( r , vp9_segment_tree , seg -> tree_probs ) ; }
outputs:
match:0
source:
 int snmp_version ( void * context , size_t hdrlen , unsigned char tag , const void * data , size_t datalen ) { <S2SV_StartBug> if ( * ( unsigned char * ) data > 1 ) <S2SV_EndBug> return - ENOTSUPP ; return 1 ; }

target:
int snmp_version ( void * context , size_t hdrlen , unsigned char tag , const void * data , size_t datalen ) { if ( datalen != 1 ) return - EINVAL ; if ( * ( unsigned char * ) data > 1 ) return - ENOTSUPP ; return 1 ; }
outputs:
int snmp_version(void* context, size_t hdrlen, unsigned char tag, const void* data, size_t datalen) {
    if (tag != 0x02) {
        return -ENOTSUPP;
    }
    if (*(unsigned char*)data < 0 || *(unsigned char*)data > 1) {
        return -ENOTSUPP;
    }
    return 1;
}
--------------------
int snmp_version(void* context, size_t hdrlen, unsigned char tag, const void* data, size_t datalen) {
    if (tag != 0x02 || datalen != 1) {
        return -ENOTSUPP;
    }
    if (*(unsigned char*)data > 1) {
        return -ENOTSUPP;
    }
    return 1;
}
--------------------
int snmp_version(void* context, size_t hdrlen, unsigned char tag, const void* data, size_t datalen) {
    if (tag != 0x02 || datalen != sizeof(unsigned char)) {
        return -ENOTSUPP;
    }
    if (*(unsigned char*)data > 1) {
        return -ENOTSUPP;
    }
    return 1;
}
--------------------
int snmp_version(void* context, size_t hdrlen, unsigned char tag, const void* data, size_t datalen) {
    if (tag != 0x02) {
        return -ENOTSUPP;
    }
    if (*(unsigned char*)data != 0 && *(unsigned char*)data != 1) {
        return -ENOTSUPP;
    }
    return 1;
}
--------------------
int snmp_version(void* context, size_t hdrlen, unsigned char tag, const void* data, size_t datalen) {
    if (tag != 0x02 || datalen != sizeof(unsigned char)) {
        return -ENOTSUPP;
    }
    unsigned char version = *(unsigned char*)data;
    if (version != 0 && version != 1) {
        return -ENOTSUPP;
    }
    return 1;
}
--------------------
int snmp_version(void* context, size_t hdrlen, unsigned char tag, const void* data, size_t datalen) {
    if (tag != 0x02 || datalen != 1) {
        return -ENOTSUPP;
    }
    unsigned char version = *(unsigned char*)data;
    if (version != 0 && version != 1) {
        return -ENOTSUPP;
    }
    return 1;
}
--------------------
int snmp_version(void* context, size_t hdrlen, unsigned char tag, const void* data, size_t datalen) {
    if (tag != 0x02 || datalen != sizeof(unsigned char)) {
        return -ENOTSUPP;
    }
    unsigned char version = *(unsigned char*)data;
    if (version > 1) {
        return -ENOTSUPP;
    }
    return 1;
}
--------------------
int snmp_version(void* context, size_t hdrlen, unsigned char tag, const void* data, size_t datalen) {
    if (tag != 0x02 || datalen != sizeof(unsigned char)) {
        return -ENOTSUPP;
    }
    const unsigned char* version = (unsigned char*)data;
    if (*version > 1) {
        return -ENOTSUPP;
    }
    return 1;
}
--------------------
int snmp_version(void* context, size_t hdrlen, unsigned char tag, const void* data, size_t datalen) {
    if (tag != 0x02 || datalen != sizeof(char)) {
        return -ENOTSUPP;
    }
    const char* version = (char*)data;
    if (*version != 0 && *version != 1) {
        return -ENOTSUPP;
    }
    return 1;
}
--------------------
#define VERSION_1 1
#define VERSION_2 2

int snmp_version(void* context, size_t hdrlen, unsigned char tag, const void* data, size_t datalen) {
    if (tag != 0x02 || datalen != sizeof(unsigned char)) {
        return -ENOTSUPP;
    }
    const unsigned char* version = (unsigned char*)data;
    if (*version == VERSION_1 || *version == VERSION_2) {
        return 1;
    }
    return -ENOTSUPP;
}
--------------------
match:0
source:
 int jas_stream_pad ( jas_stream_t * stream , int n , int c ) { <S2SV_StartBug> int m ; <S2SV_EndBug> m = n ; for ( m = n ; m > 0 ; -- m ) { if ( jas_stream_putc ( stream , c ) == EOF ) return n - m ; } return n ; }

target:
int jas_stream_pad ( jas_stream_t * stream , int n , int c ) { int m ; if ( n < 0 ) { jas_deprecated ( "negativecountforjas_stream_pad" ) ; } m = n ; for ( m = n ; m > 0 ; -- m ) { if ( jas_stream_putc ( stream , c ) == EOF ) return n - m ; } return n ; }
outputs:
int jas_stream_pad(jas_stream_t *stream, int n, int c) {
    int m;
    m = n;
    for (m = n; m > 0; --m) {
        if (jas_stream_putc(stream, c) == JAS_STREAM_EOF) {
            return n - m;
        }
    }
    return n;
}
--------------------
int jas_stream_pad(jas_stream_t *stream, int n, int c) {
    int m = n;
    for (; m > 0; m--) {
        if (jas_stream_putc(stream, c) == JAS_STREAM_EOF) {
            return n - m;
        }
    }
    return n;
}
--------------------
int jas_stream_pad(jas_stream_t *stream, int n, int c) {
    int m = n;
    for (; m > 0; --m) {
        if (jas_stream_putc(stream, c) == JAS_STREAM_EOF) {
            return n - m;
        }
    }
    return n - m;
}
--------------------
int jas_stream_pad(jas_stream_t *stream, int n, int c) {
    int m = n;
    while (m > 0) {
        if (jas_stream_putc(stream, c) == JAS_STREAM_EOF) {
            return n - m;
        }
        m--;
    }
    return n;
}
--------------------
int jas_stream_pad(jas_stream_t *stream, int n, int c) {
    int m = n;
    while (m-- > 0) {
        if (jas_stream_putc(stream, c) == JAS_STREAM_EOF) {
            return n - m;
        }
    }
    return n;
}
--------------------
int jas_stream_pad(jas_stream_t *stream, int n, int c) {
    int m = n;
    do {
        if (jas_stream_putc(stream, c) == JAS_STREAM_EOF) {
            return n - m;
        }
    } while (--m > 0);
    return n;
}
--------------------
int jas_stream_pad(jas_stream_t *stream, int n, int c) {
    int m = n;
    for (int i = 0; i < m; i++) {
        if (jas_stream_putc(stream, c) == JAS_STREAM_EOF) {
            return i;
        }
    }
    return n;
}
--------------------
int jas_stream_pad(jas_stream_t *stream, int n, int c) {
    int m = n;
    int i = 0;
    while (i < m) {
        if (jas_stream_putc(stream, c) == JAS_STREAM_EOF) {
            return i;
        }
        i++;
    }
    return n;
}
--------------------
int jas_stream_pad(jas_stream_t *stream, int n, int c) {
    int m = n;
    int i = 0;
    while (i < m) {
        if (jas_stream_putc(stream, c) == JAS_STREAM_EOF) {
            return n - m + i;
        }
        i++;
    }
    return n;
}
--------------------
int jas_stream_pad(jas_stream_t *stream, int n, int c) {
    int m = n;
    for (int i = 0; i < m; i++) {
        if (jas_stream_putc(stream, c) == JAS_STREAM_EOF) {
            return n - m + i;
        }
    }
    return n;
}
--------------------
match:0
source:
 void * xcalloc ( size_t num , size_t size ) { <S2SV_StartBug> void * ptr = malloc ( num * size ) ; <S2SV_EndBug> if ( ptr ) { <S2SV_StartBug> memset ( ptr , '\\0' , ( num * size ) ) ; <S2SV_EndBug> } return ptr ; }

target:
void * xcalloc ( size_t num , size_t size ) { size_t res ; if ( check_mul_overflow ( num , size , & res ) ) abort ( ) ; void * ptr ; ptr = malloc ( res ) ; if ( ptr ) { memset ( ptr , '\\0' , ( res ) ) ; } return ptr ; }
outputs:
match:0
source:
 static vpx_codec_err_t ctrl_set_invert_tile_order ( vpx_codec_alg_priv_t * ctx , <S2SV_StartBug> int ctr_id , va_list args ) { <S2SV_EndBug> ctx -> invert_tile_order = va_arg ( args , int ) ; return VPX_CODEC_OK ; }

target:
static vpx_codec_err_t ctrl_set_invert_tile_order ( vpx_codec_alg_priv_t * ctx , va_list args ) { ctx -> invert_tile_order = va_arg ( args , int ) ; return VPX_CODEC_OK ; }
outputs:
match:0
source:
 static struct o2nm_cluster * to_o2nm_cluster_from_node ( struct o2nm_node * node ) { <S2SV_StartBug> return to_o2nm_cluster ( node -> nd_item . ci_parent -> ci_parent ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>

target:
static struct o2nm_cluster * to_o2nm_cluster_from_node ( struct o2nm_node * node ) { if ( node -> nd_item . ci_parent ) return to_o2nm_cluster ( node -> nd_item . ci_parent -> ci_parent ) ; else return NULL ; }
outputs:
match:0
source:
 cJSON * cJSON_GetObjectItem ( cJSON * object , const char * string ) { <S2SV_StartBug> cJSON * c = object -> child ; <S2SV_EndBug> while ( c && cJSON_strcasecmp ( c -> string , string ) ) c = c -> next ; return c ; }

target:
cJSON * cJSON_GetObjectItem ( cJSON * object , const char * string ) { cJSON * c = object ? object -> child : 0 ; while ( c && cJSON_strcasecmp ( c -> string , string ) ) c = c -> next ; return c ; }
outputs:
match:0
source:
 void * sspi_SecureHandleGetUpperPointer ( SecHandle * handle ) { void * pointer ; <S2SV_StartBug> if ( ! handle ) <S2SV_EndBug> return NULL ; pointer = ( void * ) ~ ( ( size_t ) handle -> dwUpper ) ; return pointer ; }

target:
void * sspi_SecureHandleGetUpperPointer ( SecHandle * handle ) { void * pointer ; if ( ! handle || ! SecIsValidHandle ( handle ) ) return NULL ; pointer = ( void * ) ~ ( ( size_t ) handle -> dwUpper ) ; return pointer ; }
outputs:
match:0
source:
 static inline size_t GetPSDRowSize ( Image * image ) { if ( image -> depth == 1 ) <S2SV_StartBug> return ( ( image -> columns + 7 ) / 8 ) ; <S2SV_EndBug> else return ( image -> columns * GetPSDPacketSize ( image ) ) ; }

target:
static inline size_t GetPSDRowSize ( Image * image ) { if ( image -> depth == 1 ) return ( ( ( image -> columns + 7 ) / 8 ) * GetPSDPacketSize ( image ) ) ; else return ( image -> columns * GetPSDPacketSize ( image ) ) ; }
outputs:
match:0
source:
 <S2SV_StartBug> void vp9_tree_probs_from_distribution ( vp9_tree tree , <S2SV_EndBug> unsigned int branch_ct [ ] [ 2 ] , const unsigned int num_events [ ] ) { convert_distribution ( 0 , tree , branch_ct , num_events ) ; }

target:
void vp9_tree_probs_from_distribution ( vpx_tree tree , unsigned int branch_ct [ ] [ 2 ] , const unsigned int num_events [ ] ) { convert_distribution ( 0 , tree , branch_ct , num_events ) ; }
outputs:

Fixed code 2:

--------------------

Fixed code 3:

--------------------

Fixed code 4:

--------------------

Fixed code 5:

--------------------

Fixed code 6:

--------------------

Fixed code 7:

--------------------

Fixed code 8:

--------------------

Fixed code 9:

--------------------

Fixed code 10:

--------------------
match:0
source:
 int ipmi_destroy_user ( struct ipmi_user * user ) { <S2SV_StartBug> _ipmi_destroy_user ( user ) ; <S2SV_EndBug> cleanup_srcu_struct ( & user -> release_barrier ) ; kref_put ( & user -> refcount , free_user ) ; return 0 ; }

target:
int ipmi_destroy_user ( struct ipmi_user * user ) { _ipmi_destroy_user ( user ) ; kref_put ( & user -> refcount , free_user ) ; return 0 ; }
outputs:
int ipmi_destroy_user(struct ipmi_user* user) {
    _ipmi_destroy_user(user);
    cleanup_srcu_struct(&user->release_barrier);
    if (kref_put(&user->refcount, free_user) != 0) {
        return -EINVAL;
    }
    return 0;
}
--------------------
int ipmi_destroy_user(struct ipmi_user* user) {
    _ipmi_destroy_user(user);
    int err = cleanup_srcu_struct(&user->release_barrier);
    if (err != 0) {
        return err;
    }
    if (kref_put(&user->refcount, free_user) != 0) {
        return -EINVAL;
    }
    return 0;
}
--------------------
void _ipmi_destroy_user(struct ipmi_user* user) {
    // implementation goes here
}
int ipmi_destroy_user(struct ipmi_user* user) {
    _ipmi_destroy_user(user);
    int err = cleanup_srcu_struct(&user->release_barrier);
    if (err != 0) {
        return err;
    }
    if (kref_put(&user->refcount, free_user) != 0) {
        return -EINVAL;
    }
    return 0;
}
--------------------
void _ipmi_destroy_user(struct ipmi_user* user) {
    // implementation goes here
}
int ipmi_destroy_user(struct ipmi_user* user) {
    _ipmi_destroy_user(user);
    int err = cleanup_srcu_struct(&user->release_barrier);
    if (err != 0) {
        return err;
    }
    err = kref_put(&user->refcount, free_user);
    if (err != 0) {
        return -EINVAL;
    }
    return 0;
}
--------------------
void _ipmi_destroy_user(struct ipmi_user* user) {
    // implementation goes here
    kfree(user);
}
int ipmi_destroy_user(struct ipmi_user* user) {
    _ipmi_destroy_user(user);
    int err = cleanup_srcu_struct(&user->release_barrier);
    if (err != 0) {
        return err;
    }
    err = kref_put(&user->refcount, free_user);
    if (err != 0) {
        return -EINVAL;
    }
    return 0;
}
--------------------
void cleanup_srcu_struct(struct srcu_struct* sp) {
    synchronize_srcu(sp);
}
void _ipmi_destroy_user(struct ipmi_user* user) {
    // implementation goes here
    kfree(user);
}
int ipmi_destroy_user(struct ipmi_user* user) {
    _ipmi_destroy_user(user);
    int err = cleanup_srcu_struct(&user->release_barrier);
    if (err != 0) {
        return err;
    }
    err = kref_put(&user->refcount, free_user);
    if (err != 0) {
        return -EINVAL;
    }
    return 0;
}
--------------------
void free_user(struct kref* ref) {
    kfree(container_of(ref, struct ipmi_user, refcount));
}
void cleanup_srcu_struct(struct srcu_struct* sp) {
    synchronize_srcu(sp);
}
void _ipmi_destroy_user(struct ipmi_user* user) {
    // implementation goes here
    kfree(user);
}
int ipmi_destroy_user(struct ipmi_user* user) {
    _ipmi_destroy_user(user);
    int err = cleanup_srcu_struct(&user->release_barrier);
    if (err != 0) {
        return err;
    }
    err = kref_put(&user->refcount, free_user);
    if (err != 0) {
        return -EINVAL;
    }
    return 0;
}
--------------------
#include <linux/kref.h>
#include <linux/srcu.h>
void free_user(struct kref* ref) {
    kfree(container_of(ref, struct ipmi_user, refcount));
}
void cleanup_srcu_struct(struct srcu_struct* sp) {
    synchronize_srcu(sp);
}
void _ipmi_destroy_user(struct ipmi_user* user) {
    // implementation goes here
    kfree(user);
}
int ipmi_destroy_user(struct ipmi_user* user) {
    _ipmi_destroy_user(user);
    int err = cleanup_srcu_struct(&user->release_barrier);
    if (err != 0) {
        return err;
    }
    err = kref_put(&user->refcount, free_user);
    if (err != 0) {
        return -EINVAL;
    }
    return 0;
}
--------------------
void initialize_user(struct ipmi_user* user) {
    memset(user, 0, sizeof(struct ipmi_user));
    /* initialize other members as needed */
}
void free_user(struct kref* ref) {
    kfree(container_of(ref, struct ipmi_user, refcount));
}
void cleanup_srcu_struct(struct srcu_struct* sp) {
    synchronize_srcu(sp);
}
void _ipmi_destroy_user(struct ipmi_user* user) {
    // implementation goes here
    kfree(user);
}
int ipmi_destroy_user(struct ipmi_user* user) {
    _ipmi_destroy_user(user);
    int err = cleanup_srcu_struct(&user->release_barrier);
    if (err != 0) {
        return err;
    }
    err = kref_put(&user->refcount, free_user);
    if (err != 0) {
        return -EINVAL;
    }
    return 0;
}
--------------------
void _ipmi_destroy_user(struct ipmi_user* user) {
    if (user == NULL) {
        return;
    }
    /* add null checks for other pointers as needed */
    kfree(user);
}
void initialize_user(struct ipmi_user* user) {
    memset(user, 0, sizeof(struct ipmi_user));
    /* initialize other members as needed */
}
void free_user(struct kref* ref) {
    struct ipmi_user* user = container_of(ref, struct ipmi_user, refcount);
    if (user == NULL) {
        return;
    }
    /* add null checks for other pointers as needed */
    kfree(user);
}
void cleanup_srcu_struct(struct srcu_struct* sp) {
    synchronize_srcu(sp);
}
int ipmi_destroy_user(struct ipmi_user* user) {
    _ipmi_destroy_user(user);
    int err = cleanup_srcu_struct(&user->release_barrier);
    if (err != 0) {
        return err;
    }
    err = kref_put(&user->refcount, free_user);
    if (err != 0) {
        return -EINVAL;
    }
    return 0;
}
--------------------
match:0
source:
 int ipmi_destroy_user ( struct ipmi_user * user ) { <S2SV_StartBug> _ipmi_destroy_user ( user ) ; <S2SV_EndBug> cleanup_srcu_struct ( & user -> release_barrier ) ; kref_put ( & user -> refcount , free_user ) ; return 0 ; }

target:
int ipmi_destroy_user ( struct ipmi_user * user ) { _ipmi_destroy_user ( user ) ; kref_put ( & user -> refcount , free_user ) ; return 0 ; }
outputs:
int ipmi_destroy_user(struct ipmi_user* user) {
    cleanup_srcu_struct(&user->release_barrier);
    if (!user) {
        return -EINVAL;
    }
    kref_put(&user->refcount, free_user);
    return 0;
}
--------------------
int ipmi_destroy_user(struct ipmi_user* user) {
    if (!user) {
        return -EINVAL;
    }
    cleanup_srcu_struct(&user->release_barrier);
    kref_put(&user->refcount, free_user);
    return 0;
}
--------------------
int ipmi_destroy_user(struct ipmi_user* user) {
    if (!user) {
        return -EINVAL;
    }
    kref_put(&user->refcount, free_user);
    cleanup_srcu_struct(&user->release_barrier);
    return 0;
}
--------------------
int ipmi_destroy_user(struct ipmi_user* user) {
    if (user == NULL) {
        return -EINVAL;
    }

    cleanup_srcu_struct(&user->release_barrier);

    kref_put(&user->refcount, free_user);

    return 0;
}
--------------------
int ipmi_destroy_user(struct ipmi_user* user) {
    if (user == NULL) {
        return -EINVAL;
    }

    kref_put(&user->refcount, free_user);

    cleanup_srcu_struct(&user->release_barrier);

    return 0;
}
--------------------
int ipmi_destroy_user(struct ipmi_user* user) {
    if (!user) {
        return -EINVAL;
    }

    kref_put(&user->refcount, free_user);
    cleanup_srcu_struct(&user->release_barrier);

    return 0;
}
--------------------
int ipmi_destroy_user(struct ipmi_user* user) {
    if (!user) {
        return -EINVAL;
    }

    cleanup_srcu_struct(&user->release_barrier);
    kref_put(&user->refcount, free_user);

    return 0;
}
--------------------
int ipmi_destroy_user(struct ipmi_user* user) {
    if (user == NULL) {
        return -EINVAL;
    }

    cleanup_srcu_struct(&user->release_barrier);

    kref_put(&user->refcount, free_user);

    return 0;
}
--------------------
int ipmi_destroy_user(struct ipmi_user* user) {
    if (user == NULL) {
        return -EINVAL;
    }

    kref_put(&user->refcount, free_user);

    cleanup_srcu_struct(&user->release_barrier);

    return 0;
}
--------------------
int ipmi_destroy_user(struct ipmi_user* user) {
    if (!user) {
        return -EINVAL;
    }

    kref_put(&user->refcount, free_user);
    cleanup_srcu_struct(&user->release_barrier);

    return 0;
}
--------------------
match:0
source:
 int SWFInput_readSBits ( SWFInput input , int number ) { int num = SWFInput_readBits ( input , number ) ; <S2SV_StartBug> if ( num & ( 1 << ( number - 1 ) ) ) <S2SV_EndBug> return num - ( 1 << number ) ; else return num ; }

target:
int SWFInput_readSBits ( SWFInput input , int number ) { int num = SWFInput_readBits ( input , number ) ; if ( number && num & ( 1 << ( number - 1 ) ) ) return num - ( 1 << number ) ; else return num ; }
outputs:
int SWFInput_readSBits(SWFInput input, int number) {
    int num = SWFInput_readBits(input, number);
    if (num & (1 << (number - 1))) {
        num |= ~((1 << number) - 1);
    }
    return num;
}
--------------------
int SWFInput_readSBits(SWFInput input, int number) {
    int num = SWFInput_readBits(input, number);
    if (num & (1 << (number - 1))) {
        num ^= (1 << number) - 1;
        num = -num - 1;
    }
    return num;
}
--------------------
int SWFInput_readSBits(SWFInput input, int number) {
    int num = SWFInput_readBits(input, number);
    if (num & (1 << (number - 1))) {
        num |= -1 << number;
    }
    return num;
}
--------------------
int SWFInput_readSBits(SWFInput input, int number) {
    int num = SWFInput_readBits(input, number);
    if (num & (1 << (number - 1))) {
        num = num - (1 << number) + 1;
    }
    return num;
}
--------------------
int SWFInput_readSBits(SWFInput input, int number) {
    int num = SWFInput_readBits(input, number);
    if (num & (1 << (number - 1))) {
        num = (-1 << number) | num;
    }
    return num;
}
--------------------
int SWFInput_readSBits(SWFInput input, int number) {
    int num = SWFInput_readBits(input, number);
    int signBit = num & (1 << (number - 1));
    if (signBit) {
        num ^= (1 << number) - 1;
        num = -num - 1;
    }
    return num;
}
--------------------
int SWFInput_readSBits(SWFInput input, int number) {
    int num = SWFInput_readBits(input, number);
    int signBit = num & (1 << (number - 1));
    if (signBit) {
        num |= ((1 << number) - 1) << 1;
        num = -num - 1;
    }
    return num;
}
--------------------
int SWFInput_readSBits(SWFInput input, int number) {
    int num = SWFInput_readBits(input, number);
    int signBit = num & (1 << (number - 1));
    if (signBit) {
        num = (~num) + 1;
    }
    return num;
}
--------------------
int SWFInput_readSBits(SWFInput input, int number) {
    int num = SWFInput_readBits(input, number);
    int signBit = num & (1 << (number - 1));
    if (signBit) {
        num = (1 << number) - num;
        num = -num;
    }
    return num;
}
--------------------
int SWFInput_readSBits(SWFInput input, int number) {
    int num = SWFInput_readBits(input, number);
    int signBit = num & (1 << (number - 1));
    if (signBit) {
        num &= (1 << (number - 1)) - 1;
        num = -num;
    }
    return num;
}
--------------------
match:0
source:
 int scsi_cmd_blk_ioctl ( struct block_device * bd , fmode_t mode , unsigned int cmd , void __user * arg ) { <S2SV_StartBug> return scsi_cmd_ioctl ( bd -> bd_disk -> queue , bd -> bd_disk , mode , cmd , arg ) ; <S2SV_EndBug> }

target:
int scsi_cmd_blk_ioctl ( struct block_device * bd , fmode_t mode , unsigned int cmd , void __user * arg ) { int ret ; ret = scsi_verify_blk_ioctl ( bd , cmd ) ; if ( ret < 0 ) return ret ; return scsi_cmd_ioctl ( bd -> bd_disk -> queue , bd -> bd_disk , mode , cmd , arg ) ; }
outputs:
match:0
source:
 int sas_discover_end_dev ( struct domain_device * dev ) { int res ; res = sas_notify_lldd_dev_found ( dev ) ; if ( res ) return res ; <S2SV_StartBug> sas_discover_event ( dev -> port , DISCE_PROBE ) ; <S2SV_EndBug> return 0 ; }

target:
int sas_discover_end_dev ( struct domain_device * dev ) { int res ; res = sas_notify_lldd_dev_found ( dev ) ; if ( res ) return res ; return 0 ; }
outputs:
int sas_discover_end_dev ( struct domain_device * dev ) { 
    int res ; 
    res = sas_notify_lldd_dev_found ( dev ) ; 
    if ( res ) {
        printk(KERN_ERR "Failed to notify lldd device found.\n");
        return res ; 
    }
    sas_discover_event ( dev -> port , DISCE_PROBE ) ; 
    return 0 ; 
}
--------------------
int sas_discover_end_dev ( struct domain_device * dev ) { 
    int res ; 
    res = sas_notify_lldd_dev_found ( dev ) ; 
    switch (res) {
        case NOTIFY_OK:
            sas_discover_event ( dev -> port , DISCE_PROBE ) ; 
            return 0 ; 
        case NOTIFY_DEV_NOADD:
            printk(KERN_ERR "Failed to add device.\n");
            return -EINVAL;
        case NOTIFY_TRANSPORT_ERROR:
            printk(KERN_ERR "Failed to send notification.\n");
            return -EAGAIN;
        default:
            printk(KERN_ERR "Unknown error.\n");
            return -EFAULT;
    }
}
--------------------
int sas_discover_end_dev ( struct domain_device * dev ) { 
    int res ; 
    if (!dev) {
        printk(KERN_ERR "Invalid argument: dev is null.\n");
        return -EINVAL;
    }
    res = sas_notify_lldd_dev_found ( dev ) ; 
    switch (res) {
        case NOTIFY_OK:
            sas_discover_event ( dev -> port , DISCE_PROBE ) ; 
            return 0 ; 
        case NOTIFY_DEV_NOADD:
            printk(KERN_ERR "Failed to add device.\n");
            return -EINVAL;
        case NOTIFY_TRANSPORT_ERROR:
            printk(KERN_ERR "Failed to send notification.\n");
            return -EAGAIN;
        default:
            printk(KERN_ERR "Unknown error.\n");
            return -EFAULT;
    }
}
--------------------
int sas_discover_end_dev ( struct domain_device * dev ) { 
    int res ; 
    if (!dev) {
        printk(KERN_ERR "Invalid argument: dev is null.\n");
        return -EINVAL;
    }
    res = sas_notify_lldd_dev_found ( dev ) ; 
    switch (res) {
        case NOTIFY_OK:
            sas_discover_event ( dev -> port , DISCE_PROBE ) ; 
            return 0 ; 
        case NOTIFY_DEV_NOADD:
            printk(KERN_ERR "Failed to add device: device already exists.\n");
            return -EINVAL;
        case NOTIFY_TRANSPORT_ERROR:
            printk(KERN_ERR "Failed to send notification: transport error.\n");
            return -EAGAIN;
        default:
            printk(KERN_ERR "Unknown error.\n");
            return -EFAULT;
    }
}
--------------------
int sas_discover_end_dev ( struct domain_device * dev ) { 
    int res ; 
    if (!dev) {
        printk(KERN_ERR "Invalid argument: dev is null.\n");
        return -EINVAL;
    }
    res = sas_notify_lldd_dev_found ( dev ) ; 
    if (res < 0) {
        return res;
    }
    sas_discover_event ( dev -> port , DISCE_PROBE ) ; 
    return 0 ; 
}
--------------------
int sas_discover_end_dev ( struct domain_device * dev ) { 
    int res ; 
    if (!dev) {
        printk(KERN_ERR "Invalid argument: dev is null.\n");
        return -EINVAL;
    }
    if (!dev->port) {
        printk(KERN_ERR "Invalid argument: dev->port is null.\n");
        return -EINVAL;
    }
    res = sas_notify_lldd_dev_found ( dev ) ; 
    if (res < 0) {
        return res;
    }
    sas_discover_event ( dev -> port , DISCE_PROBE ) ; 
    return 0 ; 
}
--------------------
int sas_notify_dev_found(struct domain_device *dev) {
    int res ; 
    if (!dev) {
        printk(KERN_ERR "Invalid argument: dev is null.\n");
        return -EINVAL;
    }
    res = sas_notify_lldd_dev_found ( dev ) ; 
    if (res < 0) {
        return res;
    }
    return 0;
}

int sas_discover_end_dev ( struct domain_device * dev ) { 
    int res ; 
    if (!dev) {
        printk(KERN_ERR "Invalid argument: dev is null.\n");
        return -EINVAL;
    }
    if (!dev->port) {
        printk(KERN_ERR "Invalid argument: dev->port is null.\n");
        return -EINVAL;
    }
    res = sas_notify_dev_found(dev);
    if (res < 0) {
        return res;
    }
    sas_discover_event ( dev -> port , DISCE_PROBE ) ; 
    return 0 ; 
}
--------------------
int sas_notify_and_discover(struct domain_device *dev) {
    int res ; 
    if (!dev) {
        printk(KERN_ERR "Invalid argument: dev is null.\n");
        return -EINVAL;
    }
    if (!dev->port) {
        printk(KERN_ERR "Invalid argument: dev->port is null.\n");
        return -EINVAL;
    }
    res = sas_notify_dev_found(dev);
    if (res < 0) {
        return res;
    }
    sas_discover_event ( dev -> port , DISCE_PROBE ) ; 
    return 0 ; 
}
--------------------
int sas_notify_and_discover(struct domain_device *dev, int event_type) {
    int res ; 
    if (!dev) {
        printk(KERN_ERR "Invalid argument: dev is null.\n");
        return -EINVAL;
    }
    if (!dev->port) {
        printk(KERN_ERR "Invalid argument: dev->port is null.\n");
        return -EINVAL;
    }
    res = sas_notify_dev_found(dev);
    if (res < 0) {
        return res;
    }
    sas_discover_event ( dev -> port , event_type ) ; 
    return 0 ; 
}
--------------------
#define DISCE_PROBE 0
#define DISCE_REVALIDATE 1
#define DISCE_TUR_HOST 6

int sas_notify_and_discover(struct domain_device *dev, int event_type) {
    int res ; 
    if (!dev) {
        printk(KERN_ERR "Invalid argument: dev is null.\n");
        return -EINVAL;
    }
    if (!dev->port) {
        printk(KERN_ERR "Invalid argument: dev->port is null.\n");
        return -EINVAL;
    }
    res = sas_notify_dev_found(dev);
    if (res < 0) {
        return res;
    }
    sas_discover_event ( dev -> port , event_type ) ; 
    return 0 ; 
}
--------------------
match:0
source:
 void user_describe ( const struct key * key , struct seq_file * m ) { seq_puts ( m , key -> description ) ; <S2SV_StartBug> if ( key_is_instantiated ( key ) ) <S2SV_EndBug> seq_printf ( m , ":%u" , key -> datalen ) ; }

target:
void user_describe ( const struct key * key , struct seq_file * m ) { seq_puts ( m , key -> description ) ; if ( key_is_positive ( key ) ) seq_printf ( m , ":%u" , key -> datalen ) ; }
outputs:
void user_describe ( const struct key * key, struct seq_file * m ) { 
    seq_puts ( m , key->description ) ; 
    if ( key && key->datalen ) 
        seq_printf ( m , ":%u" , key->datalen ) ; 
}
--------------------
void user_describe ( const struct key * key, struct seq_file * m ) { 
    if (key && key->description) 
        seq_puts ( m , key->description ) ; 
    if ( key && key->datalen ) 
        seq_printf ( m , ":%u" , key->datalen ) ; 
}
--------------------
void user_describe ( const struct key * key, struct seq_file * m ) { 
    if (key && key->description) {
        seq_puts ( m , key->description ) ; 
        if ( key->datalen ) 
            seq_printf ( m , ":%u" , key->datalen ) ; 
    }
}
--------------------
void user_describe ( const struct key * key, struct seq_file * m ) { 
    if (key && key->description) {
        seq_puts ( m , key->description ) ; 
        if ( key->datalen && key_is_instantiated(key) ) 
            seq_printf ( m , ":%u" , key->datalen ) ; 
    }
}
--------------------
#define IS_INVALID_KEY(k) (!k || !(k->description) || !(k->datalen))

void user_describe ( const struct key * key, struct seq_file * m ) { 
    if (IS_INVALID_KEY(key)) 
        return;
    seq_puts ( m , key->description ) ; 
    if ( key_is_instantiated(key) && key->datalen ) 
        seq_printf ( m , ":%u" , key->datalen ) ; 
}
--------------------
void user_describe ( const struct key * key, struct seq_file * m ) { 
    if (!key || !key->description) 
        return;
    seq_puts ( m , key->description ) ; 
    if ( key->datalen && key_is_instantiated(key) ) 
        seq_printf ( m , ":%u" , key->datalen ) ; 
}
--------------------
void user_describe ( const struct key * key, struct seq_file * m ) { 
    if (key == NULL || key->description == NULL) 
        return;
    seq_puts ( m , key->description ) ; 
    if ( key_is_instantiated(key) && key->datalen ) 
        seq_printf ( m , ":%u" , key->datalen ) ; 
}
--------------------
void user_describe ( const struct key * key, struct seq_file * m ) { 
    if (key == NULL || key->description == NULL) 
        return;
    seq_puts(m, key->description);
    if (key->datalen && key_is_instantiated(key)) 
        seq_printf(m," (datalen: %lu)",key->datalen); 
}
--------------------
void user_describe ( const struct key * key, struct seq_file * m ) { 
    if (key && key->description) { 
        seq_puts(m, key->description); 
        if (key->datalen && key_is_instantiated(key)) 
            seq_printf(m, " datalen=%u", key->datalen); 
    } 
}
--------------------
void user_describe ( const struct key * key, struct seq_file * m ) { 
    if (key && key->description) { 
        seq_puts(m, key->description);
        if (key_is_instantiated(key)) {
            seq_printf(m, " datalen=%u", key->datalen); 
        } else {
            seq_puts(m, " (not instantiated)"); 
        }
    } 
}
--------------------
match:0
source:
 void user_describe ( const struct key * key , struct seq_file * m ) { seq_puts ( m , key -> description ) ; <S2SV_StartBug> if ( key_is_instantiated ( key ) ) <S2SV_EndBug> seq_printf ( m , ":%u" , key -> datalen ) ; }

target:
void user_describe ( const struct key * key , struct seq_file * m ) { seq_puts ( m , key -> description ) ; if ( key_is_positive ( key ) ) seq_printf ( m , ":%u" , key -> datalen ) ; }
outputs:
void user_describe(const struct key *key, struct seq_file *m) {
    if (key && m) {
        seq_puts(m, key->description);
        if (key_is_instantiated(key)) {
            seq_printf(m, ":%u", key->datalen);
        }
    }
}
--------------------
void user_describe(const struct key *key, struct seq_file *m) {
    if (key == NULL || m == NULL) {
        return;
    }
    seq_puts(m, key->description);
    if (key_is_instantiated(key)) {
        seq_printf(m, ":%u", key->datalen);
    }
}
--------------------
void user_describe(const struct key *key, struct seq_file *m) {
    if (key == NULL || m == NULL) {
        goto error_exit;
    }
    seq_puts(m, key->description);
    if (key_is_instantiated(key)) {
        seq_printf(m, ":%u", key->datalen);
    }
    return;

error_exit:
    return;
}
--------------------
void user_describe(const struct key *key, struct seq_file *m) {
    if (key == NULL || m == NULL) {
        return;
    }
    if (key->description) {
        seq_puts(m, key->description);
    }
    if (key_is_instantiated(key)) {
        seq_printf(m, ":%u", key->datalen);
    }
}
--------------------
void user_describe(const struct key *key, struct seq_file *m) {
    if (!key || !m) {
        return;
    }
    if (key->description) {
        seq_puts(m, key->description);
    }
    if (key_is_instantiated(key)) {
        seq_printf(m, ":%u", key->datalen);
    }
}
--------------------
void user_describe(const struct key *key, struct seq_file *m) {
    if (!key || !m) {
        return;
    }
    if (!key->description) {
        return;
    }
    seq_puts(m, key->description);
    if (key_is_instantiated(key)) {
        seq_printf(m, ":%u", key->datalen);
    }
}
--------------------
void user_describe(const struct key *key, struct seq_file *m) {
    if (!key || !m) {
        return;
    }
    if (key->description) {
        seq_puts(m, key->description);
    }
    if (key && key_is_instantiated(key)) {
        seq_printf(m, ":%u", key->datalen);
    }
}
--------------------
void user_describe(const struct key *key, struct seq_file *m) {
    if (!key || !m) {
        return;
    }
    seq_puts(m, key->description ? key->description : "");
    if (key_is_instantiated(key)) {
        seq_printf(m, ":%u", key->datalen);
    }
}
--------------------
void user_describe(const struct key *key, struct seq_file *m) {
    if (key == NULL || m == NULL) {
        return;
    }

    seq_puts(m, key->description ? key->description : "");
    if (key_is_instantiated(key)) {
        seq_printf(m, ":%u", key->datalen);
    }
}
--------------------
void user_describe(const struct key *key, struct seq_file *m) {
    if (key == NULL || m == NULL || key->description == NULL) {
        return;
    }

    seq_puts(m, key->description);
    if (key_is_instantiated(key)) {
        seq_printf(m, ":%u", key->datalen);
    }
}
--------------------
match:0
source:
 <S2SV_StartBug> void ntlm_write_message_header ( wStream * s , NTLM_MESSAGE_HEADER * header ) <S2SV_EndBug> { Stream_Write ( s , header -> Signature , sizeof ( NTLM_SIGNATURE ) ) ; Stream_Write_UINT32 ( s , header -> MessageType ) ; }

target:
static void ntlm_write_message_header ( wStream * s , NTLM_MESSAGE_HEADER * header ) { Stream_Write ( s , header -> Signature , sizeof ( NTLM_SIGNATURE ) ) ; Stream_Write_UINT32 ( s , header -> MessageType ) ; }
outputs:
void ntlm_write_message_header (wStream *s, NTLM_MESSAGE_HEADER *header) {
    if (!s) {
        return;
    }
    Stream_Write(s, header->Signature, sizeof(NTLM_SIGNATURE));
    Stream_Write_UINT32(s, header->MessageType);
}
--------------------
void ntlm_write_message_header (wStream *s, NTLM_MESSAGE_HEADER *header) {
   if (s == NULL) {
        return;
   }
   memcpy(Stream_Pointer(s), header->Signature, sizeof(NTLM_SIGNATURE)); Stream_Seek(s, sizeof(NTLM_SIGNATURE));
   Stream_Write_UINT32(s, header->MessageType);
}
--------------------
void ntlm_write_message_header (wStream *s, NTLM_MESSAGE_HEADER *header) {
    if (!s || !header) {
        return;
    }
    Stream_Write(s, header->Signature, sizeof(NTLM_SIGNATURE));
    Stream_Write_UINT32(s, header->MessageType);
}
--------------------
void ntlm_write_message_header (wStream *s, NTLM_MESSAGE_HEADER *header) {
    if (!s || !header) {
        return;
    }
    if (Stream_Write(s, header->Signature, sizeof(NTLM_SIGNATURE)) != sizeof(NTLM_SIGNATURE)) {
        return;
    }
    Stream_Write_UINT32(s, header->MessageType);
}
--------------------
void ntlm_write_message_header (wStream *s, NTLM_MESSAGE_HEADER *header) {
     if (!s || !header) {
        return;
    }
    Stream_Write(s, (BYTE*) header->Signature, sizeof(NTLM_SIGNATURE));
    Stream_Write_UINT32(s, header->MessageType);
}
--------------------
void ntlm_write_message_header (wStream *s, NTLM_MESSAGE_HEADER *header) {
    if (!s || !header) {
        return;
    }
    memcpy(Stream_Pointer(s), header->Signature, sizeof(NTLM_SIGNATURE));
    Stream_Seek(s, sizeof(NTLM_SIGNATURE));
    Stream_Write_UINT32(s, header->MessageType);
}
--------------------
void ntlm_write_message_header (wStream *s, NTLM_MESSAGE_HEADER *header) {
    if (!s || !header) {
        return;
    }
    size_t sigLength = sizeof(NTLM_SIGNATURE);
    if (Stream_GetPosition(s) + sigLength < Stream_GetPosition(s)) {
        return; 
    }
    if (Stream_Write(s, header->Signature, sigLength) != sigLength) {
        return;
    }
    Stream_Write_UINT32(s, header->MessageType);
}
--------------------
void ntlm_write_message_header (wStream *s, NTLM_MESSAGE_HEADER *header) {
    if (!s || !header) {
        return;
    }
    const size_t sigLength = 16;
    if (Stream_GetPosition(s) + sigLength < Stream_GetPosition(s)) {
        return;
    }
    if (Stream_Write(s, header->Signature, sigLength) != sigLength) {
        return;
    }
    Stream_Write_UINT32(s, header->MessageType);
}
--------------------
void ntlm_write_message_header (wStream *s, NTLM_MESSAGE_HEADER *header) {
    if (!s || !header) {
        return; 
    }
    const size_t sigLength = sizeof(NTLM_SIGNATURE);
    if (Stream_GetPosition(s) + sigLength < Stream_GetPosition(s)) {
        return;
    }
    if (sigLength > sizeof(header->Signature)) {
        return;
    }
    char signature[sigLength];
    memcpy(signature, header->Signature, sigLength);
    if (Stream_Write(s, signature, sigLength) != sigLength) {
        return;
    }
    Stream_Write_UINT32(s, header->MessageType);
}
--------------------
void ntlm_write_message_header (wStream *s, NTLM_MESSAGE_HEADER *header) {
    if (!s || !header) {
        return;
    }
    const size_t sigLength = sizeof(NTLM_SIGNATURE);
    if (Stream_GetPosition(s) + sigLength < Stream_GetPosition(s)) {
        return;
    }
    if (sigLength > sizeof(header->Signature)) {
        return;
    }
    char signature[sigLength];
    memcpy(signature, header->Signature, sigLength);
    if (Stream_Write(s, signature, sigLength) != sigLength) {
        return;
    }
    if (header->MessageType != MESSAGE_TYPE_UNKNOWN && header->MessageType <= MESSAGE_TYPE_MESSAGE_3) {
        Stream_Write_UINT32(s, header->MessageType);
    }
}
--------------------
match:0
source:
 <S2SV_StartBug> static const SvcInternal * get_const_svc_internal ( const SvcContext * svc_ctx ) { <S2SV_EndBug> if ( svc_ctx == NULL ) return NULL ; <S2SV_StartBug> return ( const SvcInternal * ) svc_ctx -> internal ; <S2SV_EndBug> }

target:
static const SvcInternal_t * get_const_svc_internal ( const SvcContext * svc_ctx ) { if ( svc_ctx == NULL ) return NULL ; return ( const SvcInternal_t * ) svc_ctx -> internal ; }
outputs:
static const SvcInternal * get_const_svc_internal ( const SvcContext * svc_ctx ) {
    if (svc_ctx == NULL) {
        return NULL;
    }
    return (const SvcInternal *) svc_ctx -> internal;
}
--------------------
static const SvcInternal * get_const_svc_internal ( const SvcContext * svc_ctx ) {
    if (svc_ctx == NULL) {
        return NULL;
    } else {
        return (const SvcInternal *) svc_ctx -> internal;
    }
}
--------------------
static const SvcInternal * get_const_svc_internal ( const SvcContext * svc_ctx ) {
    return (svc_ctx == NULL) ? NULL : (const SvcInternal *) svc_ctx -> internal;
}
--------------------
static const SvcInternal * get_const_svc_internal ( const SvcContext * svc_ctx ) {
    if (svc_ctx != NULL) {
        return (const SvcInternal *) svc_ctx -> internal;
    } else {
        return NULL;
    }
}
--------------------
static const SvcInternal * get_const_svc_internal ( const SvcContext * svc_ctx ) {
    if (!svc_ctx) {
        return NULL;
    }
    return (const SvcInternal *) svc_ctx -> internal;
}
--------------------
static const SvcInternal * get_const_svc_internal ( const SvcContext * svc_ctx ) {
    if (svc_ctx == NULL) {
        return NULL;
    }
    const SvcInternal * const_svc_int = (const SvcInternal *) svc_ctx -> internal;
    return const_svc_int;
}
--------------------
static const SvcInternal * get_const_svc_internal ( const SvcContext * svc_ctx ) {
    const SvcInternal * const_svc_int = NULL;
    if (svc_ctx != NULL) {
        const_svc_int = (const SvcInternal *) svc_ctx -> internal;
    }
    return const_svc_int;
}
--------------------
static const SvcInternal * get_const_svc_internal ( const SvcContext * svc_ctx ) {
    const SvcInternal * const_svc_int = NULL;
    if (svc_ctx != NULL) {
        const_svc_int = (const SvcInternal *) svc_ctx -> internal;
    } else {
        const_svc_int = NULL;
    }
    return const_svc_int;
}
--------------------
static const SvcInternal * get_const_svc_internal ( const SvcContext * svc_ctx ) {
    if (svc_ctx == NULL) {
        return NULL;
    }
    const SvcInternal * const_svc_int = (const SvcInternal *) svc_ctx -> internal;
    return const_svc_int;
}
--------------------
static const SvcInternal * get_const_svc_internal ( const SvcContext * svc_ctx ) {
    if (svc_ctx == NULL) {
        return NULL;
    } else {
        const SvcInternal * const_svc_int = (const SvcInternal *) svc_ctx -> internal;
        return const_svc_int;
    }
}
--------------------
match:0
source:
 void free_bprm ( struct linux_binprm * bprm ) { free_arg_pages ( bprm ) ; if ( bprm -> cred ) { mutex_unlock ( & current -> signal -> cred_guard_mutex ) ; abort_creds ( bprm -> cred ) ; } <S2SV_StartBug> kfree ( bprm ) ; <S2SV_EndBug> }

target:
void free_bprm ( struct linux_binprm * bprm ) { free_arg_pages ( bprm ) ; if ( bprm -> cred ) { mutex_unlock ( & current -> signal -> cred_guard_mutex ) ; abort_creds ( bprm -> cred ) ; } if ( bprm -> interp != bprm -> filename ) kfree ( bprm -> interp ) ; kfree ( bprm ) ; }
outputs:
match:0
source:
 <S2SV_StartBug> void usage_exit ( ) { <S2SV_EndBug> fprintf ( stderr , "Usage:%s<codec><width><height><infile><outfile>\\n" , exec_name ) ; exit ( EXIT_FAILURE ) ; }

target:
void usage_exit ( void ) { fprintf ( stderr , "Usage:%s<codec><width><height><infile><outfile>\\n" , exec_name ) ; exit ( EXIT_FAILURE ) ; }
outputs:
void usage_exit ( ) {
    if (exec_name == NULL) {
        fprintf(stderr, "Error: exec_name is NULL\n");
        exit(EXIT_FAILURE);
    }
    fprintf(stderr , "Usage: %s <codec> <width> <height> <infile> <outfile>\n" , exec_name ) ;
    exit ( EXIT_FAILURE ) ;
}
--------------------
void usage_exit ( ) {
    if (exec_name == NULL) {
        fprintf(stderr, "Error: exec_name is NULL\n");
        exit(EXIT_FAILURE);
    }
    fprintf(stderr , "Usage: %s <codec> <width> <height> <infile> <outfile>\n" , exec_name ) ;
    exit ( EXIT_FAILURE ) ;
    return;
}
--------------------
void usage_exit ( ) {
    if (exec_name == NULL) {
        fprintf(stderr, "Error: exec_name is NULL\n");
        exit(EXIT_FAILURE);
    }
    fprintf(stderr , "Usage: %s <codec> <width> <height> <infile> <outfile>\n" , exec_name ) ;
    exit ( EXIT_FAILURE ) ;
    return;
}
--------------------
void usage_exit ( ) {
    if (exec_name == NULL) {
        fprintf(stderr, "Error: exec_name is NULL\n");
        exit(EXIT_FAILURE);
    }
    const char* fmt = "Usage: %s <codec> <width> <height> <infile> <outfile>\n";
    const int fmt_len = strlen(fmt);
    fprintf(stderr , fmt, exec_name ) ;
    exit ( EXIT_FAILURE ) ;
    return;
}
--------------------
void usage_exit ( ) {
    if (exec_name == NULL) {
        fprintf(stderr, "Error: exec_name is NULL\n");
        exit(EXIT_FAILURE);
    }
    fprintf(stderr , "Usage: %s <codec> <width> <height> <infile> <outfile>\n", exec_name ) ;
    exit ( EXIT_FAILURE ) ;
    return;
}
--------------------
void usage_exit ( int argc ) {
    if (exec_name == NULL) {
        fprintf(stderr, "Error: exec_name is NULL\n");
        exit(EXIT_FAILURE);
    }
    switch (argc) {
        case 1:
            fprintf(stderr, "Not enough arguments.\n");
            break;
        case 2:
            fprintf(stderr , "Missing arguments.\n" ) ;
            break;
        default:
            fprintf(stderr , "Usage: %s <codec> <width> <height> <infile> <outfile>\n" , exec_name ) ;
            break;
    }
    exit(EXIT_FAILURE);
    return;
}
--------------------
void usage_exit ( const char* fmt, ... ) {
    if (exec_name == NULL) {
        fprintf(stderr, "Error: exec_name is NULL\n");
        exit(EXIT_FAILURE);
    }
    va_list args;
    va_start(args, fmt);
    vfprintf(stderr, fmt, args);
    va_end(args);
    exit(EXIT_FAILURE);
    return;
}
--------------------
const char* program_name;

void set_program_name(const char* name) {
    program_name = name;
}

void usage_exit () {
    if (program_name == NULL) {
        fprintf(stderr, "Error: program_name is NULL\n");
        exit(EXIT_FAILURE);
    }
    fprintf(stderr , "Usage: %s <codec> <width> <height> <infile> <outfile>\n" , program_name ) ;
    exit(EXIT_FAILURE);
    return;
}
--------------------
#define PROGRAM_NAME "my_program"

void usage_exit () {
    fprintf(stderr , "Usage: %s <codec> <width> <height> <infile> <outfile>\n" , PROGRAM_NAME ) ;
    exit(EXIT_FAILURE);
}
--------------------
void usage_exit ( ) {
    if (exec_name == NULL) {
        fprintf(stderr, "Error: exec_name is NULL\n");
        exit(EXIT_FAILURE);
    }
    fprintf(stderr , "Usage: %s <codec> <width> <height> <infile> <outfile>\n", exec_name ) ;
    exit ( EXIT_FAILURE ) ;
    return;
}
--------------------
match:0
source:
 static RD_BOOL mcs_parse_domain_params ( STREAM s ) { <S2SV_StartBug> int length ; <S2SV_EndBug> <S2SV_StartBug> ber_parse_header ( s , MCS_TAG_DOMAIN_PARAMS , & length ) ; <S2SV_EndBug> in_uint8s ( s , length ) ; return s_check ( s ) ; }

target:
static RD_BOOL mcs_parse_domain_params ( STREAM s ) { uint32 length ; struct stream packet = * s ; ber_parse_header ( s , MCS_TAG_DOMAIN_PARAMS , & length ) ; if ( ! s_check_rem ( s , length ) ) { rdp_protocol_error ( "mcs_parse_domain_params(),consumedomainparamsfromstreamwouldoverrun" , & packet ) ; } in_uint8s ( s , length ) ; return s_check ( s ) ; }
outputs:
static RD_BOOL mcs_parse_domain_params ( STREAM s ) {
    uint32_t length; // Change the type from int to uint32_t

    ber_parse_header ( s , MCS_TAG_DOMAIN_PARAMS , & length ) ;
    in_uint8s ( s , length ) ;
    return s_check ( s ) ;
}
--------------------
static RD_BOOL mcs_parse_domain_params ( STREAM s ) {
    int length ;

    ber_parse_header ( s , MCS_TAG_DOMAIN_PARAMS , & length ) ;
    if (length < 0 || !s_check ( s )) { // Check the length and s_check before using them
        return FALSE;
    }
    in_uint8s ( s , length ) ;
    return s_check ( s ) ;
}
--------------------
static RD_BOOL mcs_parse_domain_params ( STREAM s ) {
    int length = MCS_DOMAIN_PARAMS_SIZE; // Define a fixed buffer size

    ber_parse_header ( s , MCS_TAG_DOMAIN_PARAMS , & length ) ;
    if (!s_check ( s )) {
        return FALSE;
    }
    in_uint8s ( s , length ) ;
    return s_check ( s ) ;
}
--------------------
static int mcs_parse_domain_params ( STREAM s ) {
    int length ;

    ber_parse_header ( s , MCS_TAG_DOMAIN_PARAMS , & length ) ;
    if (length < 0 || !s_check ( s )) { // Check the length and s_check before using them
        return MCS_PARSE_ERROR;
    }
    in_uint8s ( s , length ) ;
    return MCS_PARSE_OK;
}
--------------------
static RD_BOOL mcs_parse_domain_params ( STREAM s ) {
    int length ;

    ber_parse_header ( s , MCS_TAG_DOMAIN_PARAMS , & length ) ;
    if (!s_check ( s )) {
        return FALSE;
    }

    uint8_t data[length]; // Use a variable-length array based on the parsed length
    in_uint8a ( s , data, length ) ; // Use in_uint8a to read the array instead of in_uint8s
    
    return s_check ( s ) ;
}
--------------------
static RD_BOOL mcs_parse_domain_params ( STREAM s ) {
    int length ;
    uint8_t data[MCS_MAX_DOMAIN_PARAMS_SIZE]; // Define a fixed-size buffer

    ber_parse_header ( s , MCS_TAG_DOMAIN_PARAMS , & length ) ;
    if (!s_check ( s )) {
        return FALSE;
    }

    if (length > MCS_MAX_DOMAIN_PARAMS_SIZE) { // Check if the length exceeds the buffer size
        in_uint8s ( s , MCS_MAX_DOMAIN_PARAMS_SIZE ) ; // Ignore the excess data
    } else {
        in_uint8a ( s , data, length ) ; // Read the data into the buffer
    }
    
    return s_check ( s ) ;
}
--------------------
static RD_BOOL mcs_parse_domain_params ( STREAM s ) {
    int length ;
    uint8_t* data;

    ber_parse_header ( s , MCS_TAG_DOMAIN_PARAMS , & length ) ;
    if (!s_check ( s )) {
        return FALSE;
    }

    data = (uint8_t*) malloc(length); // Allocate memory dynamically based on the parsed length
    if (data == NULL) {
        return FALSE;
    }

    in_uint8a ( s , data, length ) ; // Read the data into the dynamically allocated buffer
    free(data); // Free the allocated memory
    
    return s_check ( s ) ;
}
--------------------
static RD_BOOL mcs_parse_domain_params ( STREAM s ) {
    int length ;
    uint8_t* data;

    ber_parse_header ( s , MCS_TAG_DOMAIN_PARAMS , & length ) ;
    if (!s_check ( s )) {
        return FALSE;
    }

    if (length > INT_MAX) { // Check if the length is too large
        return FALSE;
    }

    data = (uint8_t*) calloc(1, length); // Allocate memory safely
    if (data == NULL) {
        return FALSE;
    }

    if (!in_uint8a_safe(s, data, length)) { // Read the data safely
        free(data); // Free the allocated memory
        return FALSE;
    }
    
    free(data); // Free the allocated memory
    return s_check ( s ) ;
}
--------------------
static RD_BOOL mcs_parse_domain_params ( STREAM s ) {
    uint32_t length ;

    ber_parse_header ( s , MCS_TAG_DOMAIN_PARAMS , & length ) ; // Use uint32_t for length
    if (!s_check ( s )) {
        return FALSE;
    }

    in_uint8s ( s , (int) length ) ; // Cast the length to int before using it
    return s_check ( s ) ;
}
--------------------
static RD_BOOL mcs_parse_domain_params ( STREAM s ) {
    int length ;

    ber_parse_header ( s , MCS_TAG_DOMAIN_PARAMS ) ; // Remove the length parameter
    if (!s_check ( s )) {
        return FALSE;
    }

    length = ber_get_content_length(s); // Get the length from the parsed header
    in_uint8s ( s , length ) ; // Use the length to read the data
    return s_check ( s ) ;
}
--------------------
match:0
source:
 static void put_prev_task ( struct rq * rq , struct task_struct * prev ) { if ( prev -> se . on_rq ) update_rq_clock ( rq ) ; <S2SV_StartBug> rq -> skip_clock_update = 0 ; <S2SV_EndBug> prev -> sched_class -> put_prev_task ( rq , prev ) ; }

target:
static void put_prev_task ( struct rq * rq , struct task_struct * prev ) { if ( prev -> se . on_rq ) update_rq_clock ( rq ) ; prev -> sched_class -> put_prev_task ( rq , prev ) ; }
outputs:
static void put_prev_task(struct rq *rq, struct task_struct *prev) {
    if (prev->se.on_rq) {
        update_rq_clock(rq);
        rq->skip_clock_update = 0;
    }
    prev->sched_class->put_prev_task(rq, prev);
}
--------------------
static void put_prev_task(struct rq *rq, struct task_struct *prev) {
    if (prev != NULL && prev->se.on_rq != 0) {
        update_rq_clock(rq);
    }
    rq->skip_clock_update = 0;
    if (prev != NULL) {
        prev->sched_class->put_prev_task(rq, prev);
    }
}
--------------------
static void put_prev_task(struct rq *rq, struct task_struct *prev) {
    if (prev != NULL && prev->se.on_rq) {
        update_rq_clock(rq);
    }
    rq->skip_clock_update = 0;
    if (prev != NULL) {
        prev->sched_class->put_prev_task(rq, prev);
    }
}
--------------------
static void put_prev_task(struct rq *rq, struct task_struct *prev) {
    if (prev != NULL && prev->se.on_rq != 0) {
        update_rq_clock(rq);
    }
    rq->skip_clock_update = !prev || prev->se.on_rq == 0;
    if (prev != NULL) {
        prev->sched_class->put_prev_task(rq, prev);
    }
}
--------------------
static void put_prev_task(struct rq *rq, struct task_struct *prev) {
    if (prev != NULL && prev->se.on_rq) {
        update_rq_clock(rq);
    }
    if (rq != NULL) {
        rq->skip_clock_update = 0;
    }
    if (prev != NULL) {
        prev->sched_class->put_prev_task(rq, prev);
    }
}
--------------------
static void put_prev_task(struct rq *rq, struct task_struct *prev) {
    if (prev != NULL && prev->se.on_rq != 0) {
        update_rq_clock(rq);
    }
    if (rq != NULL) {
        rq->skip_clock_update = !prev || prev->se.on_rq == 0;
    }
    if (prev != NULL) {
        prev->sched_class->put_prev_task(rq, prev);
    }
}
--------------------
static void put_prev_task(struct rq *rq, struct task_struct *prev) {
    if (prev != NULL && prev->se.on_rq) {
        update_rq_clock(rq);
        rq->skip_clock_update = 0;
    } else {
        rq->skip_clock_update = 1;
    }
    if (prev != NULL) {
        prev->sched_class->put_prev_task(rq, prev);
    }
}
--------------------
static void put_prev_task(struct rq *rq, struct task_struct *prev) {
    if (rq != NULL && prev != NULL && prev->se.on_rq) {
        update_rq_clock(rq);
        rq->skip_clock_update = 0;
    }
    if (prev != NULL) {
        prev->sched_class->put_prev_task(rq, prev);
    }
}
--------------------
static void put_prev_task(struct rq *rq, struct task_struct *prev) {
    if (prev && prev->se.on_rq) {
        update_rq_clock(rq);
        rq->skip_clock_update = 0;
    } else {
        rq->skip_clock_update = 1;
    }
    if (prev) {
        prev->sched_class->put_prev_task(rq, prev);
    }
}
--------------------
static void put_prev_task(struct rq *rq, struct task_struct *prev) {
    if (prev && prev->se.on_rq) {
        update_rq_clock(rq);
        rq->skip_clock_update = 0;
    } else if (rq) {
        rq->skip_clock_update = 1;
    }
    if (prev) {
        prev->sched_class->put_prev_task(rq, prev);
    }
}
--------------------
match:0
source:
 static void put_prev_task ( struct rq * rq , struct task_struct * prev ) { if ( prev -> se . on_rq ) update_rq_clock ( rq ) ; <S2SV_StartBug> rq -> skip_clock_update = 0 ; <S2SV_EndBug> prev -> sched_class -> put_prev_task ( rq , prev ) ; }

target:
static void put_prev_task ( struct rq * rq , struct task_struct * prev ) { if ( prev -> se . on_rq ) update_rq_clock ( rq ) ; prev -> sched_class -> put_prev_task ( rq , prev ) ; }
outputs:
match:0
source:
 <S2SV_StartBug> void ntlm_populate_message_header ( NTLM_MESSAGE_HEADER * header , UINT32 MessageType ) <S2SV_EndBug> { CopyMemory ( header -> Signature , NTLM_SIGNATURE , sizeof ( NTLM_SIGNATURE ) ) ; header -> MessageType = MessageType ; }

target:
static void ntlm_populate_message_header ( NTLM_MESSAGE_HEADER * header , UINT32 MessageType ) { CopyMemory ( header -> Signature , NTLM_SIGNATURE , sizeof ( NTLM_SIGNATURE ) ) ; header -> MessageType = MessageType ; }
outputs:
match:0
source:
 char * my_asctime ( time_t t ) { struct tm * tm ; char * str ; int len ; <S2SV_StartBug> tm = localtime ( & t ) ; <S2SV_EndBug> str = g_strdup ( asctime ( tm ) ) ; len = strlen ( str ) ; if ( len > 0 ) str [ len - 1 ] = '\\0' ; return str ; }

target:
char * my_asctime ( time_t t ) { struct tm * tm ; char * str ; int len ; tm = localtime ( & t ) ; if ( tm == NULL ) return g_strdup ( "???" ) ; str = g_strdup ( asctime ( tm ) ) ; len = strlen ( str ) ; if ( len > 0 ) str [ len - 1 ] = '\\0' ; return str ; }
outputs:
char * my_asctime ( time_t t ) {
    struct tm tm;
    char * str;
    int len;
    if (localtime_r(&t, &tm) == NULL) {
        return NULL;
    }
    str = g_strdup ( asctime ( &tm ) );
    len = strlen ( str ) ;
    if ( len > 0 ) str [ len - 1 ] = '\0' ;
    return str ;
}
--------------------
char * my_asctime ( time_t t ) {
    struct tm * tm ;
    char * str ;
    int len ;
    tm = localtime ( &t ) ;
    if (tm == NULL) {
        return NULL;
    }
    str = g_strdup ( asctime_r ( tm, (char*)malloc(26) ) ) ;
    len = strlen ( str ) ;
    if ( len > 0 ) str [ len - 1 ] = '\0' ;
    return str ;
}
--------------------
char * my_asctime ( time_t t ) {
    struct tm * tm ;
    char str[26];
    int len ;
    tm = localtime ( &t ) ;
    if (tm == NULL) {
        return NULL;
    }
    strftime(str, sizeof(str), "%c", tm);
    len = strlen ( str ) ;
    if ( len > 0 ) str [ len - 1 ] = '\0' ;
    return g_strdup(str);
}
--------------------
char * my_asctime ( time_t t ) {
    struct tm * tm ;
    char str[26];
    int len ;
    tm = localtime ( &t ) ;
    if (tm == NULL) {
        return NULL;
    }
    if (snprintf(str, sizeof(str), "%s", asctime(tm)) < 0) {
        return NULL;
    }
    len = strlen ( str ) ;
    if ( len > 0 ) str [ len - 1 ] = '\0' ;
    return g_strdup(str);
}
--------------------
char * my_asctime ( time_t t ) {
    struct tm * tm ;
    char str[26];
    int len ;
    tm = localtime ( &t ) ;
    if (tm == NULL) {
        return NULL;
    }
    if (strftime(str, sizeof(str), "%c", tm) <= 0) {
        return NULL;
    }
    len = strlen ( str ) ;
    if ( len > 0 ) str [ len - 1 ] = '\0' ;
    return g_strdup(str);
}
--------------------
char * my_asctime ( time_t t ) {
    struct tm * tm ;
    char str[26];
    int len ;
    tm = localtime ( &t ) ;
    if (tm == NULL) {
        return NULL;
    }
    if (snprintf(str, sizeof(str), "%.24s", ctime(&t)) < 0) {
        return NULL;
    }
    len = strlen ( str ) ;
    if ( len > 0 ) str [ len - 1 ] = '\0' ;
    return g_strdup(str);
}
--------------------
char * my_asctime ( time_t t ) {
    struct tm * tm ;
    char * str ;
    int len ;
    tm = gmtime ( &t ) ;
    if (tm == NULL) {
        return NULL;
    }
    str = g_strdup ( asctime ( tm ) ) ;
    len = strlen ( str ) ;
    if ( len > 0 ) str [ len - 1 ] = '\0' ;
    return str ;
}
--------------------
char * my_asctime ( time_t t ) {
    struct tm * tm ;
    char * str ;
    int len ;
    tm = localtime ( &t ) ;
    if (tm == NULL) {
        return NULL;
    }
    str = g_malloc ( 26 ) ;
    if (str == NULL) {
        return NULL;
    }
    strncpy(str, asctime ( tm ), 25);
    str [ 24 ] = '\0' ;
    return str ;
}
--------------------
char * my_asctime ( time_t t ) {
    struct tm tm = {0};
    char * str ;
    int len ;
    if (localtime_r(&t, &tm) == NULL) {
        return NULL;
    }
    str = g_malloc ( 26 ) ;
    if (str == NULL) {
        return NULL;
    }
    strncpy(str, asctime ( &tm ), 25);
    str [ 24 ] = '\0' ;
    return str ;
}
--------------------
char * my_asctime ( time_t t ) {
    struct tm * tm ;
    char str[26];
    int len ;
#ifdef __STDC_LIB_EXT1__
    if (asctime_s(str, sizeof(str), localtime(&t)) != 0) {
        return NULL;
    }    
#else
    tm = localtime ( &t ) ;
    if (tm == NULL) {
        return NULL;
    }
    strncpy(str, asctime ( tm ), 25);
#endif
    len = strlen ( str ) ;
    if ( len > 0 ) str [ len - 1 ] = '\0' ;
    return g_strdup(str);
}
--------------------
match:0
source:
 <S2SV_StartBug> static void pcrypt_free ( struct crypto_instance * inst ) <S2SV_EndBug> { <S2SV_StartBug> struct pcrypt_instance_ctx * ctx = crypto_instance_ctx ( inst ) ; <S2SV_EndBug> crypto_drop_aead ( & ctx -> spawn ) ; kfree ( inst ) ; }

target:
static void pcrypt_free ( struct aead_instance * inst ) { struct pcrypt_instance_ctx * ctx = aead_instance_ctx ( inst ) ; crypto_drop_aead ( & ctx -> spawn ) ; kfree ( inst ) ; }
outputs:
match:0
source:
 cJSON * cJSON_GetArrayItem ( cJSON * array , int item ) { <S2SV_StartBug> cJSON * c = array -> child ; <S2SV_EndBug> <S2SV_StartBug> while ( c && item > 0 ) { <S2SV_EndBug> -- item ; c = c -> next ; <S2SV_StartBug> } <S2SV_EndBug> return c ; }

target:
cJSON * cJSON_GetArrayItem ( cJSON * array , int item ) { cJSON * c = array ? array -> child : 0 ; while ( c && item > 0 ) item -- , c = c -> next ; } return c ; }
outputs:
match:0
source:
 <S2SV_StartBug> static int decode_unsigned_max ( struct vp9_read_bit_buffer * rb , int max ) { <S2SV_EndBug> <S2SV_StartBug> const int data = vp9_rb_read_literal ( rb , get_unsigned_bits ( max ) ) ; <S2SV_EndBug> return data > max ? max : data ; }

target:
static int decode_unsigned_max ( struct vpx_read_bit_buffer * rb , int max ) { const int data = vpx_rb_read_literal ( rb , get_unsigned_bits ( max ) ) ; return data > max ? max : data ; }
outputs:
match:0
source:
 void __scm_destroy ( struct scm_cookie * scm ) { struct scm_fp_list * fpl = scm -> fp ; int i ; if ( fpl ) { scm -> fp = NULL ; for ( i = fpl -> count - 1 ; i >= 0 ; i -- ) fput ( fpl -> fp [ i ] ) ; <S2SV_StartBug> kfree ( fpl ) ; <S2SV_EndBug> } }

target:
void __scm_destroy ( struct scm_cookie * scm ) { struct scm_fp_list * fpl = scm -> fp ; int i ; if ( fpl ) { scm -> fp = NULL ; for ( i = fpl -> count - 1 ; i >= 0 ; i -- ) fput ( fpl -> fp [ i ] ) ; free_uid ( fpl -> user ) ; kfree ( fpl ) ; } }
outputs:
match:0
source:
 static unsigned int seedsize ( struct crypto_alg * alg ) { struct rng_alg * ralg = container_of ( alg , struct rng_alg , base ) ; <S2SV_StartBug> return alg -> cra_rng . rng_make_random ? <S2SV_EndBug> alg -> cra_rng . seedsize : ralg -> seedsize ; }

target:
static unsigned int seedsize ( struct crypto_alg * alg ) { struct rng_alg * ralg = container_of ( alg , struct rng_alg , base ) ; return ralg -> seedsize ; }
outputs:
match:0
source:
 <S2SV_StartBug> static void write_intra_mode ( vp9_writer * w , MB_PREDICTION_MODE mode , <S2SV_EndBug> <S2SV_StartBug> const vp9_prob * probs ) { <S2SV_EndBug> vp9_write_token ( w , vp9_intra_mode_tree , probs , & intra_mode_encodings [ mode ] ) ; }

target:
static void write_intra_mode ( vpx_writer * w , MB_PREDICTION_MODE mode , const vpx_prob * probs ) { vp9_write_token ( w , vp9_intra_mode_tree , probs , & intra_mode_encodings [ mode ] ) ; }
outputs:
match:0
source:
 static void addFormVars ( cchar * buf ) { char * pair , * tok ; pair = stok ( sclone ( buf ) , "&" , & tok ) ; <S2SV_StartBug> while ( pair != 0 ) { <S2SV_EndBug> mprAddItem ( app -> formData , sclone ( pair ) ) ; pair = stok ( 0 , "&" , & tok ) ; } }

target:
static void addFormVars ( cchar * buf ) { char * pair , * tok ; pair = stok ( sclone ( buf ) , "&" , & tok ) ; while ( pair ) { mprAddItem ( app -> formData , sclone ( pair ) ) ; pair = stok ( 0 , "&" , & tok ) ; } }
outputs:
static void addFormVars ( cchar * buf ) { 
  if (buf == NULL) {
    return;
  }
  char * pair , * tok ; 
  pair = stok ( sclone ( buf ) , "&" , & tok ) ; 
  while ( pair != 0 ) { 
    mprAddItem ( app -> formData , sclone ( pair ) ) ; 
    pair = stok ( 0 , "&" , & tok ) ; 
  } 
}
--------------------
static void addFormVars ( cchar * buf ) { 
  if (buf == NULL || app == NULL || app->formData == NULL) {
    return;
  }
  char * pair , * tok ; 
  pair = stok ( sclone ( buf ) , "&" , & tok ) ; 
  while ( pair != 0 ) { 
    mprAddItem ( app -> formData , sclone ( pair ) ) ; 
    pair = stok ( 0 , "&" , & tok ) ; 
  } 
}
--------------------
static void addFormVars ( cchar * buf ) { 
  if (buf == NULL || app == NULL || app->formData == NULL) {
    return;
  }
  char * pair , * tok ; 
  pair = stok ( sclone ( buf ) , "&" , & tok ) ; 
  while ( pair != 0 ) { 
    mprAddItem ( sclone(app->formData) , sclone ( pair ) ) ; 
    pair = stok ( 0 , "&" , & tok ) ; 
  } 
}
--------------------
static void addFormVars ( cchar * buf ) { 
  if (buf == NULL || app == NULL || app->formData == NULL) {
    return;
  }
  char * pair , * tok ; 
  pair = stok ( sclone ( buf ) , "&" , & tok ) ; 
  while ( pair != 0 ) { 
    if (pair != NULL) {
      mprAddItem ( sclone(app->formData) , sclone ( pair ) ) ; 
    }
    pair = stok ( 0 , "&" , & tok ) ; 
  } 
}
--------------------
static void addFormVars ( cchar * buf ) { 
  if (buf == NULL || app == NULL || app->formData == NULL) {
    return;
  }
  char * pair , * tok ; 
  pair = stok ( sclone ( buf ) , "&" , & tok ) ; 
  while ( tok != 0 ) { 
    if (pair != NULL) {
      mprAddItem ( sclone(app->formData) , sclone ( pair ) ) ; 
    }
    pair = stok ( 0 , "&" , & tok ) ; 
  } 
}
--------------------
static void addFormVars ( cchar * buf ) { 
  if (buf == NULL || app == NULL || app->formData == NULL || app->formData->len >= sizeof(app->formData)-1) {
    return;
  }
  char * pair , * tok ; 
  pair = stok ( sclone ( buf ) , "&" , & tok ) ; 
  while ( tok != 0 ) { 
    if (pair != NULL) {
      mprAddItem ( sclone(app->formData) , sclone ( pair ) ) ; 
    }
    pair = stok ( 0 , "&" , & tok ) ; 
  } 
}
--------------------
static void addFormVars ( cchar * buf ) { 
  if (buf == NULL || app == NULL || app->formData == NULL || app->formData->len >= sizeof(app->formData)-1) {
    return;
  }
  char * pair , * tok ; 
  pair = stok ( sclone ( buf ) , "&" , & tok ) ; 
  while ( tok != 0 ) { 
    if (pair != NULL) {
      mprAddItem ( sclone(app->formData) , sclone ( pair ) ) ; 
    }
    pair = stok ( 0 , "&" , & tok ) ; 
    pair = sclone(pair);
  } 
}
--------------------
static void addFormVars ( cchar * buf ) { 
  if (buf == NULL || app == NULL || app->formData == NULL || app->formData->len >= sizeof(app->formData)-1) {
    return;
  }
  char * pair , * tok ; 
  pair = stok ( sclone ( buf ) , "&" , & tok ) ; 
  if (tok == NULL) {
    return;
  }
  while ( tok != 0 ) { 
    if (pair != NULL) {
      mprAddItem ( sclone(app->formData) , sclone ( pair ) ) ; 
    }
    pair = stok ( 0 , "&" , & tok ) ; 
    pair = sclone(pair);
  } 
}
--------------------
static void addFormVars ( cchar * buf ) { 
  if (buf == NULL || app == NULL || app->formData == NULL || app->formData->len >= sizeof(app->formData)-1 || strlen(buf) >= sizeof(buf)-1) {
    return;
  }
  char * pair , * tok ; 
  pair = stok ( sclone ( buf ) , "&" , & tok ) ; 
  if (tok == NULL) {
    return;
  }
  while ( tok != 0 ) { 
    if (pair != NULL) {
      mprAddItem ( sclone(app->formData) , sclone ( pair ) ) ; 
    }
    pair = stok ( 0 , "&" , & tok ) ; 
    pair = sclone(pair);
  } 
}
--------------------
static void addFormVars ( cchar * buf ) { 
  if (buf == NULL || app == NULL || app->formData == NULL || app->formData->len >= sizeof(app->formData)-1 || strlen(buf) >= sizeof(buf)-1) {
    return;
  }
  char * pair , * tok ; 
  pair = stok ( sclone ( buf ) , "&" , & tok ) ; 
  if (tok == NULL) {
    return;
  }
  while ( tok != 0 ) { 
    if (pair != NULL && strlen(pair) < sizeof(pair)-1) {
      mprAddItem ( sclone(app->formData) , sclone ( pair ) ) ; 
    }
    pair = stok ( 0 , "&" , & tok ) ; 
    pair = sclone(pair);
  } 
}
--------------------
match:0
source:
 static void m_stop ( struct seq_file * m , void * v ) { struct proc_maps_private * priv = m -> private ; struct vm_area_struct * vma = v ; <S2SV_StartBug> vma_stop ( priv , vma ) ; <S2SV_EndBug> if ( priv -> task ) put_task_struct ( priv -> task ) ; }

target:
static void m_stop ( struct seq_file * m , void * v ) { struct proc_maps_private * priv = m -> private ; struct vm_area_struct * vma = v ; if ( ! IS_ERR ( vma ) ) vma_stop ( priv , vma ) ; if ( priv -> task ) put_task_struct ( priv -> task ) ; }
outputs:
static void m_stop ( struct seq_file * m , void * v ) { 
    struct proc_maps_private * priv = m -> private ; 
    struct vm_area_struct * vma = v ; 
    if (priv && vma) { // check for null pointers
        vma_stop ( priv , vma ) ; 
        if ( priv -> task ) 
            put_task_struct ( priv -> task ) ; 
    }
}
--------------------
static void m_stop ( struct seq_file * m , void * v ) { 
    if (m) { //check for null pointer
        struct proc_maps_private * priv = m -> private ; 
        struct vm_area_struct * vma = v ; 
        if (priv && vma) { 
            vma_stop ( priv , vma ) ; 
            if ( priv -> task ) 
                put_task_struct ( priv -> task ) ; 
        }
   }
}
--------------------
static void m_stop ( struct seq_file * m , void * v ) { 
    if (m) { 
        struct proc_maps_private * priv = m -> private ; 
        struct vm_area_struct * vma = v ; 
        if (priv && vma) { 
            if (vma_stop ( priv , vma ) == 0) { // check return value
                if ( priv -> task ) 
                    if (put_task_struct ( priv -> task ) == 0) // check return value
                        return; 
            }
        }
   }
}
--------------------
static void m_stop ( struct seq_file * m , void * v ) { 
    if (m) { 
        struct proc_maps_private * priv = m -> private ; 
        struct vm_area_struct * vma = v ; 
        if (priv && vma) { 
            try {
                if (vma_stop ( priv , vma ) == 0) {
                    if ( priv -> task ) 
                        if (put_task_struct ( priv -> task ) == 0) 
                            return; 
                }
            } catch(Exception e) {
                // do something with the exception
            }
        }
   }
}
--------------------
static void m_stop ( struct seq_file * m , void * v ) { 
    if (m) { 
        struct proc_maps_private * priv = m -> private ; 
        struct vm_area_struct * vma = v ; 
        if (priv && vma) { 
            log.info("m_stop started execution");
            try {
                if (vma_stop ( priv , vma ) == 0) {
                    log.info("vma_stop executed successfully");
                    if ( priv -> task ) 
                        if (put_task_struct ( priv -> task ) == 0) {
                            log.info("put_task_struct executed successfully");
                            return; 
                        } else {
                            log.error("put_task_struct failed to execute");
                        }
                } else {
                    log.error("vma_stop failed to execute");
                }
            } catch(Exception e) {
                log.error("An exception occurred during execution: " + e.getMessage());
            }
        } else {
            log.warning("Null pointer detected.");
        }
   } else {
        log.warning("Null pointer detected.");
   }
}
--------------------
static int m_stop ( struct seq_file * m , void * v ) { 
    if (m) { 
        struct proc_maps_private * priv = m -> private ; 
        struct vm_area_struct * vma = v ; 
        if (priv && vma) { 
            log.info("m_stop started execution");
            try {
                if (vma_stop ( priv , vma ) == 0) {
                    log.info("vma_stop executed successfully");
                    if ( priv -> task ) 
                        if (put_task_struct ( priv -> task ) == 0) {
                            log.info("put_task_struct executed successfully");
                            return 0; 
                        } else {
                            log.error("put_task_struct failed to execute");
                            return -1;
                        }
                } else {
                    log.error("vma_stop failed to execute");
                    return -1;
                }
            } catch(Exception e) {
                log.error("An exception occurred during execution: " + e.getMessage());
                return -1;
            }
        } else {
            log.warning("Null pointer detected.");
            return -1;
        }
   } else {
        log.warning("Null pointer detected.");
        return -1;
   }
}
--------------------
/**
 * Stops the mapping of a memory region and releases any related resources.
 * @param m a pointer to the sequential file structure that holds information about the current mapping
 * @param v a pointer to the virtual memory area structure that contains information about the memory region
 * @return 0 on success, -1 on failure.
 */
static int m_stop ( struct seq_file * m , void * v ) { 
    //check for null pointer
    if (!m || !v) { 
        log.warning("Null pointer detected.");
        return -1;
    }
        
    //get the private struct and virtual memory area
    struct proc_maps_private * priv = m -> private ; 
    struct vm_area_struct * vma = v ;
        
    //check for null pointer
    if (priv && vma) { 
        log.info("m_stop started execution");
        try {
            //stop the memory mapping
            if (vma_stop ( priv , vma ) == 0) {
                log.info("vma_stop executed successfully");
                    
                //release any task resources
                if ( priv -> task ) 
                    if (put_task_struct ( priv -> task ) == 0) {
                        log.info("put_task_struct executed successfully");
                        return 0; 
                    } else {
                        log.error("put_task_struct failed to execute");
                        return -1;
                    }
            } else {
                log.error("vma_stop failed to execute");
                return -1;
            }
        } catch(Exception e) {
            log.error("An exception occurred during execution: " + e.getMessage());
            return -1;
        }
    } else {
        log.warning("Null pointer detected.");
        return -1;
    }
}
--------------------
/**
 * Stops the mapping of a memory region and releases any related resources.
 * @param m a pointer to the sequential file structure that holds information about the current mapping
 * @param v a pointer to the virtual memory area structure that contains information about the memory region
 * @return 0 on success, -1 on failure.
 */
static int m_stop ( std::unique_ptr<seq_file> m , std::unique_ptr<vm_area_struct> v ) { 
    //check for null pointer
    if (!m || !v) { 
        log.warning("Null pointer detected.");
        return -1;
    }

    //get the private struct and virtual memory area
    std::unique_ptr<proc_maps_private> priv(m->private); 
        
    //check for null pointer
    if (priv && v) { 
        log.info("m_stop started execution");
        try {
            //stop the memory mapping
            if (vma_stop ( priv.get() , v.get() ) == 0) {
                log.info("vma_stop executed successfully");
                    
                //release any task resources
                if ( priv->task ) 
                    if (put_task_struct ( priv->task ) == 0) {
                        log.info("put_task_struct executed successfully");
                        return 0; 
                    } else {
                        log.error("put_task_struct failed to execute");
                        return -1;
                    }
            } else {
                log.error("vma_stop failed to execute");
                return -1;
            }
        } catch(Exception e) {
            log.error("An exception occurred during execution: " + e.getMessage());
            return -1;
        }
    } else {
        log.warning("Null pointer detected.");
        return -1;
    }
}
--------------------
/**
 * Stops the mapping of a memory region and releases any related resources.
 * @param m a shared pointer to the sequential file structure that holds information about the current mapping
 * @param v a shared pointer to the virtual memory area structure that contains information about the memory region
 * @return 0 on success, -1 on failure.
 */
static int m_stop ( std::shared_ptr<seq_file> m , std::shared_ptr<vm_area_struct> v ) { 
    //check for null pointer
    if (!m || !v) { 
        log.warning("Null pointer detected.");
        return -1;
    }

    //get the private struct and virtual memory area
    std::shared_ptr<proc_maps_private> priv(m->private); 
        
    //check for null pointer
    if (priv && v) { 
        log.info("m_stop started execution");
        try {
            //stop the memory mapping
            if (vma_stop ( priv.get() , v.get() ) == 0) {
                log.info("vma_stop executed successfully");
                    
                //release any task resources
                if ( priv->task ) 
                    if (put_task_struct ( priv->task ) == 0) {
                        log.info("put_task_struct executed successfully");
                        return 0; 
                    } else {
                        log.error("put_task_struct failed to execute");
                        return -1;
                    }
            } else {
                log.error("vma_stop failed to execute");
                return -1;
            }
        } catch(Exception e) {
            log.error("An exception occurred during execution: " + e.getMessage());
            return -1;
        }
    } else {
        log.warning("Null pointer detected.");
        return -1;
    }
}
--------------------
/**
 * Stops the mapping of a memory region and releases any related resources.
 * @param m a reference to the sequential file structure that holds information about the current mapping
 * @param v a reference to the virtual memory area structure that contains information about the memory region
 * @return 0 on success, -1 on failure.
 */
static int m_stop ( seq_file& m , vm_area_struct& v ) { 
    //get the private struct
    proc_maps_private * priv = m.private ; 
    if (!priv) {
        log.warning("Null pointer detected.");
        return -1;
    }
        
    log.info("m_stop started execution");
    try {
        //stop the memory mapping
        if (vma_stop ( priv , &v ) == 0) {
            log.info("vma_stop executed successfully");
                
            //release any task resources
            if ( priv->task ) 
                if (put_task_struct ( priv->task ) == 0) {
                    log.info("put_task_struct executed successfully");
                    return 0; 
                } else {
                    log.error("put_task_struct failed to execute");
                    return -1;
                }
        } else {
            log.error("vma_stop failed to execute");
            return -1;
        }
    } catch(Exception e) {
        log.error("An exception occurred during execution: " + e.getMessage());
        return -1;
    }
}
--------------------
match:0
source:
 int pci_emul_add_msicap ( struct pci_vdev * dev , int msgnum ) { struct msicap msicap ; <S2SV_StartBug> pci_populate_msicap ( & msicap , msgnum , 0 ) ; <S2SV_EndBug> return pci_emul_add_capability ( dev , ( u_char * ) & msicap , sizeof ( msicap ) ) ; }

target:
int pci_emul_add_msicap ( struct pci_vdev * dev , int msgnum ) { struct msicap msicap ; return pci_populate_msicap ( & msicap , msgnum , 0 ) || pci_emul_add_capability ( dev , ( u_char * ) & msicap , sizeof ( msicap ) ) ; }
outputs:
int pci_emul_add_msicap(struct pci_vdev *dev, int msgnum) {
    struct msicap msicap;
    memset(&msicap, 0, sizeof(msicap)); // Initialize structure with 0's
    pci_populate_msicap(&msicap, msgnum, 0);
    return pci_emul_add_capability(dev, (u_char *)&msicap, sizeof(msicap));
}
--------------------
int pci_emul_add_msicap(struct pci_vdev *dev, int msgnum) {
    if (msgnum < 0 || msgnum >= MAX_MSICAP_ENTRIES) { // check if msgnum is within bounds
        return -1;
    }
    struct msicap msicap;
    memset(&msicap, 0, sizeof(msicap)); // Initialize structure with 0's
    pci_populate_msicap(&msicap, msgnum, 0);
    return pci_emul_add_capability(dev, (u_char *)&msicap, sizeof(msicap));
}
--------------------
int pci_emul_add_msicap(struct pci_vdev *dev, int msgnum) {
    if (msgnum < 0 || msgnum >= MAX_MSICAP_ENTRIES) { // check if msgnum is within bounds
        return -1;
    }
    struct msicap msicap;
    memset(&msicap, 0, sizeof(msicap)); // Initialize structure with 0's
    if (pci_populate_msicap(&msicap, msgnum, 0) < 0) { // check the return value of pci_populate_msicap()
        return -1;
    }
    return pci_emul_add_capability(dev, (u_char *)&msicap, sizeof(msicap));
}
--------------------
int pci_emul_add_msicap(struct pci_vdev *dev, int msgnum) {
    if (msgnum < 0 || msgnum >= MAX_MSICAP_ENTRIES) { // check if msgnum is within bounds
        return -1;
    }
    struct msicap msicap;
    memset(&msicap, 0, sizeof(msicap)); // Initialize structure with 0's
    if (pci_populate_msicap(&msicap, msgnum, 0) < 0) { // check the return value of pci_populate_msicap()
        return -1;
    }
    u_char msicap_array[sizeof(struct msicap)]; // create a fixed size array to store msicap structure
    memcpy(msicap_array, &msicap, sizeof(msicap)); // copy msicap structure to the array
    return pci_emul_add_capability(dev, msicap_array, sizeof(msicap));
}
--------------------
void pci_emul_add_msicap(struct pci_vdev *dev, int msgnum, int *ret) {
    if (!ret) return;
    if (msgnum < 0 || msgnum >= MAX_MSICAP_ENTRIES) { // check if msgnum is within bounds
        *ret = -1;
        return;
    }
    struct msicap msicap;
    memset(&msicap, 0, sizeof(msicap)); // Initialize structure with 0's
    if (pci_populate_msicap(&msicap, msgnum, 0) < 0) { // check the return value of pci_populate_msicap()
        *ret = -1;
        return;
    }
    u_char msicap_array[sizeof(struct msicap)]; // create a fixed size array to store msicap structure
    memcpy(msicap_array, &msicap, sizeof(msicap)); // copy msicap structure to the array
    *ret = pci_emul_add_capability(dev, msicap_array, sizeof(msicap));
}
--------------------
int pci_emul_add_msicap(struct pci_vdev *dev, int msgnum) {
    if (msgnum < 0 || msgnum >= MAX_MSICAP_ENTRIES) { // check if msgnum is within bounds
        return -1;
    }
    struct msicap msicap;
    memset(&msicap, 0, sizeof(msicap)); // Initialize structure with 0's
    if (pci_populate_msicap(&msicap, msgnum, 0) < 0) { // check the return value of pci_populate_msicap()
        return -1;
    }
    u_char msicap_array[sizeof(struct msicap)]; // use a fixed size array to store msicap structure
    memcpy(msicap_array, &msicap, sizeof(msicap)); // copy msicap structure to the array
    return pci_emul_add_capability(dev, msicap_array, sizeof(msicap));
}
--------------------
int pci_emul_add_msicap(struct pci_vdev *dev, int msgnum) {
    if (!dev || msgnum < 0 || msgnum >= MAX_MSICAP_ENTRIES) { // check if dev and msgnum are valid
        return -1;
    }
    struct msicap msicap;
    memset(&msicap, 0, sizeof(msicap)); // Initialize structure with 0's
    if (pci_populate_msicap(&msicap, msgnum, 0) < 0) { // check the return value of pci_populate_msicap()
        return -1;
    }
    u_char msicap_array[sizeof(struct msicap)]; // use a fixed size array to store msicap structure
    memcpy(msicap_array, &msicap, sizeof(msicap)); // copy msicap structure to the array
    return pci_emul_add_capability(dev, msicap_array, sizeof(msicap));
}
--------------------
int pci_emul_add_msicap(struct pci_vdev *dev, int msgnum) {
    if (!dev || msgnum < 0 || msgnum >= MAX_MSICAP_ENTRIES) { // check if dev and msgnum are valid
        return -1;
    }
    struct msicap msicap;
    memset(&msicap, 0, sizeof(msicap)); // Initialize structure with 0's
    if (pci_populate_msicap(&msicap, msgnum, 0) < 0) { // check the return value of pci_populate_msicap()
        return -1;
    }
    u_char msicap_array[sizeof(struct msicap)]; // use a fixed size array to store msicap structure
    if (sizeof(msicap_array) < sizeof(msicap)) { // check if the size of msicap_array is greater than the size of msicap structure
        return -1;
    }
    memcpy(msicap_array, &msicap, sizeof(msicap)); // copy msicap structure to the array
    return pci_emul_add_capability(dev, msicap_array, sizeof(msicap));
}
--------------------
int pci_emul_add_msicap(struct pci_vdev *dev, int msgnum) {
    if (!dev || msgnum < 0 || msgnum >= MAX_MSICAP_ENTRIES) { // check if dev and msgnum are valid
        return -1;
    }
    struct msicap msicap;
    memset(&msicap, 0, sizeof(msicap)); // Initialize structure with 0's
    if (pci_populate_msicap(&msicap, msgnum, 0) < 0) { // check the return value of pci_populate_msicap()
        return -1;
    }
    u_char msicap_array[sizeof(struct msicap)]; // use a fixed size array to store msicap structure
    if (sizeof(msicap_array) < sizeof(msicap)) { // check if the size of msicap_array is greater than the size of msicap structure
        return -1;
    }
    memcpy(&msicap_array, &msicap, sizeof(msicap)); // copy msicap structure to the array
    return pci_emul_add_capability(dev, msicap_array, sizeof(msicap));
}
--------------------
int pci_emul_add_msicap(struct pci_vdev *dev, int msgnum) {
    if (!dev || msgnum < 0 || msgnum >= MAX_MSICAP_ENTRIES) { // check if dev and msgnum are valid
        return -1;
    }
    struct msicap msicap;
    memset(&msicap, 0, sizeof(msicap)); // Initialize structure with 0's
    if (pci_populate_msicap(&msicap, msgnum, 0) < 0) { // check the return value of pci_populate_msicap()
        return -1;
    }
    u_char msicap_array[sizeof(struct msicap)]; // use a fixed size array to store msicap structure
    if (sizeof(msicap_array) < sizeof(msicap)) { // check if the size of msicap_array is greater than the size of msicap structure
        return -1;
    }
    memcpy(&msicap_array, &msicap, sizeof(msicap_array)); // copy msicap structure to the array
    return pci_emul_add_capability(dev, msicap_array, sizeof(msicap_array));
}
--------------------
match:0
source:
 <S2SV_StartBug> static void <S2SV_EndBug> swabHorAcc16 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) { uint16 * wp = ( uint16 * ) cp0 ; tmsize_t wc = cc / 2 ; TIFFSwabArrayOfShort ( wp , wc ) ; <S2SV_StartBug> horAcc16 ( tif , cp0 , cc ) ; <S2SV_EndBug> }

target:
static int swabHorAcc16 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) { uint16 * wp = ( uint16 * ) cp0 ; tmsize_t wc = cc / 2 ; TIFFSwabArrayOfShort ( wp , wc ) ; return horAcc16 ( tif , cp0 , cc ) ; }
outputs:
static void swabHorAcc16 (TIFF *tif, uint8 *cp0, tmsize_t cc) {
    if (!tif || !cp0 || cc == 0) {
        return;
    }
    uint16 *wp = (uint16 *) cp0;
    tmsize_t wc = cc / 2;
    TIFFSwabArrayOfShort(wp, wc);
    horAcc16(tif, cp0, cc);
}
--------------------
static void swabHorAcc16(TIFF *tif, void *cp, size_t len) {
    if (!tif || !cp || len == 0) {
        return;
    }
    uint16_t *wp = (uint16_t*)cp;
    size_t wc = len / sizeof(uint16_t);
    TIFFSwabArrayOfShort(wp, wc);
    horAcc16(tif, (uint8_t*)cp, len);
}
--------------------
static void swabHorAcc16(TIFF *tif, void *cp, size_t len) {
    if (!tif || !cp || len == 0 || len % sizeof(uint16_t) != 0) {
        return;
    }
    uint16_t *wp = (uint16_t*)cp;
    size_t wc = len / sizeof(uint16_t);
    for (size_t i = 0; i < wc; i++) {
        wp[i] = ntohs(wp[i]);
    }
    horAcc16(tif, (uint8_t*)cp, len);
}
--------------------
static void swabHorAcc16(TIFF *tif, void *cp, size_t len) {
    if (!tif || !cp || len == 0 || len % sizeof(uint16_t) != 0) {
        return;
    }
    uint16_t *in = (uint16_t*)cp;
    uint16_t *out = (uint16_t*)malloc(len);
    if (!out) {
        return;
    }
    size_t wc = len / sizeof(uint16_t);
    for (size_t i = 0; i < wc; i++) {
        out[i] = ntohs(in[i]);
    }
    horAcc16(tif, (uint8_t*)out, len);
    free(out);
}
--------------------
#include <string.h>

static void swabHorAcc16(TIFF *tif, void *cp, size_t len) {
    if (!tif || !cp || len == 0 || len % sizeof(uint16_t) != 0) {
        return;
    }
    uint16_t *in = (uint16_t*)cp;
    uint16_t *out = (uint16_t*)malloc(len);
    if (!out) {
        return;
    }
    size_t wc = len / sizeof(uint16_t);
    for (size_t i = 0; i < wc; i++) {
        out[i] = ntohs(in[i]);
    }
    horAcc16(tif, (uint8_t*)out, len);
    memcpy(in, out, len);
    free(out);
}
--------------------
#include <string.h>

static void swabHorAcc16(TIFF *tif, void *cp, size_t len) {
    if (!tif || !cp || len == 0 || len % sizeof(uint16_t) != 0) {
        return;
    }
    uint16_t *in = (uint16_t*)cp;
    uint16_t out[1024];
    size_t wc = len / sizeof(uint16_t);
    for (size_t i = 0; i < wc; i += sizeof(out) / sizeof(uint16_t)) {
        size_t block_len = sizeof(out);
        if (i + block_len > wc) {
            block_len = wc - i;
        }
        for (size_t j = 0; j < block_len; j++) {
            out[j] = ntohs(in[i + j]);
        }
        horAcc16(tif, (uint8_t*)out, block_len * sizeof(uint16_t));
        memcpy(in + i, out, block_len * sizeof(uint16_t));
    }
}
--------------------
#include <string.h>
#include <stdint.h>
#include <stddef.h>
#include <limits.h>

static void swabHorAcc16(TIFF* tif, void* cp, size_t len) {
    if (!tif || !cp || len == 0 || len % sizeof(uint16_t) != 0) {
        return;
    }
    uint16_t* in = (uint16_t*)cp;
    uint16_t out[1024];
    size_t wc = len / sizeof(uint16_t);
    for (size_t i = 0; i < wc; i += sizeof(out) / sizeof(uint16_t)) {
        size_t block_len = sizeof(out) / sizeof(uint16_t);
        if (i + block_len > wc) {
            block_len = wc - i;
        }
        for (size_t j = 0; j < block_len; j++) {
            out[j] = ntohs(in[i + j]);
        }
        if (SIZE_MAX / sizeof(uint16_t) < block_len) {
            return;
        }
        size_t block_size = block_len * sizeof(uint16_t);
        horAcc16(tif, (uint8_t*)out, block_size);
        memcpy(in + i, out, block_size);
    }
}
--------------------
#include <string.h>
#include <stdint.h>
#include <stddef.h>
#include <limits.h>

static void swab16(uint16_t* in, size_t len, uint16_t* out) {
    if (!in || !out || len % sizeof(uint16_t) != 0) {
        return;
    }
    size_t wc = len / sizeof(uint16_t);
    for (size_t i = 0; i < wc; i++) {
        out[i] = ntohs(in[i]);
    }
}

static void swabHorAcc16(TIFF* tif, void* cp, size_t len) {
    if (!tif || !cp || len == 0 || len % sizeof(uint16_t) != 0) {
        return;
    }
    uint16_t in[1024];
    uint16_t out[1024];
    size_t wc = len / sizeof(uint16_t);
    for (size_t i = 0; i < wc; i += sizeof(in) / sizeof(uint16_t)) {
        size_t block_len = sizeof(in) / sizeof(uint16_t);
        if (i + block_len > wc) {
            block_len = wc - i;
        }
        swab16((uint16_t*)((uint8_t*)cp + i * sizeof(uint16_t)), block_len * sizeof(uint16_t), in);
        size_t block_size = block_len * sizeof(uint16_t);
        horAcc16(tif, (uint8_t*)in, block_size);
        swab16(in, block_size, (uint16_t*)((uint8_t*)cp + i * sizeof(uint16_t)));
    }
}
--------------------
#include <string.h>
#include <stdint.h>
#include <stddef.h>
#include <limits.h>

static void swab16(uint16_t* in, size_t len, uint16_t* out) {
    if (!in || !out || len % sizeof(uint16_t) != 0) {
        return;
    }
    size_t wc = len / sizeof(uint16_t);
    for (size_t i = 0; i < wc; i++) {
        out[i] = ntohs(in[i]);
    }
}

static void swabHorAcc16(TIFF* tif, void* cp, size_t len) {
    if (!tif || !cp || len == 0 || len % sizeof(uint16_t) != 0) {
        return;
    }
    uint16_t in[128] __attribute__((aligned(sizeof(uint16_t))));
    uint16_t out[128] __attribute__((aligned(sizeof(uint16_t))));
    size_t wc = len / sizeof(uint16_t);
    for (size_t i = 0; i < wc; i += sizeof(in) / sizeof(uint16_t)) {
        size_t block_len = sizeof(in) / sizeof(uint16_t);
        if (i + block_len > wc) {
            block_len = wc - i;
        }
        swab16((uint16_t*)((uint8_t*)cp + i * sizeof(uint16_t)), block_len * sizeof(uint16_t), in);
        size_t block_size = block_len * sizeof(uint16_t);
        horAcc16(tif, (uint8_t*)in, block_size);
        swab16(in, block_size, (uint16_t*)((uint8_t*)cp + i * sizeof(uint16_t)));
    }
}
--------------------
#include <string.h>
#include <stdint.h>
#include <stddef.h>
#include <limits.h>

static void swab16(uint16_t* in, size_t len, uint16_t* out) {
    if (!in || !out || len % sizeof(uint16_t) != 0) {
        return;
    }
    size_t wc = len / sizeof(uint16_t);
    for (size_t i = 0; i < wc; i++) {
        out[i] = ntohs(in[i]);
    }
}

static void swabHorAcc16(TIFF* tif, void* cp, size_t len) {
    if (!tif || !cp || len == 0 || len % sizeof(uint16_t) != 0) {
        return;
    }
    uint16_t in[128] __attribute__((aligned(sizeof(uint16_t))));
    uint16_t out[128] __attribute__((aligned(sizeof(uint16_t))));
    size_t wc = len / sizeof(uint16_t);
    for (size_t i = 0; i < wc; i += sizeof(in) / sizeof(uint16_t)) {
        size_t block_len = sizeof(in) / sizeof(uint16_t);
        if (i + block_len > wc) {
            block_len = wc - i;
        }
        swab16((uint16_t*)((uint8_t*)cp + i * sizeof(uint16_t)), block_len * sizeof(uint16_t), in);
        size_t block_size = block_len * sizeof(uint16_t);
        for (size_t j = 0; j < block_len; j += 8) {
            horAcc16(tif, (uint8_t*)&in[j], 8 * sizeof(uint16_t));
        }
        swab16(in, block_size, (uint16_t*)((uint8_t*)cp + i * sizeof(uint16_t)));
    }
}
--------------------
match:0
source:
 struct bpf_map * bpf_map_get_with_uref ( u32 ufd ) { struct fd f = fdget ( ufd ) ; struct bpf_map * map ; map = __bpf_map_get ( f ) ; if ( IS_ERR ( map ) ) return map ; <S2SV_StartBug> bpf_map_inc ( map , true ) ; <S2SV_EndBug> fdput ( f ) ; return map ; }

target:
struct bpf_map * bpf_map_get_with_uref ( u32 ufd ) { struct fd f = fdget ( ufd ) ; struct bpf_map * map ; map = __bpf_map_get ( f ) ; if ( IS_ERR ( map ) ) return map ; map = bpf_map_inc ( map , true ) ; fdput ( f ) ; return map ; }
outputs:
match:0
source:
 int av_reallocp_array ( void * ptr , size_t nmemb , size_t size ) { void * * ptrptr = ptr ; * ptrptr = av_realloc_f ( * ptrptr , nmemb , size ) ; <S2SV_StartBug> if ( ! * ptrptr && ! ( nmemb && size ) ) <S2SV_EndBug> return AVERROR ( ENOMEM ) ; return 0 ; }

target:
int av_reallocp_array ( void * ptr , size_t nmemb , size_t size ) { void * * ptrptr = ptr ; * ptrptr = av_realloc_f ( * ptrptr , nmemb , size ) ; if ( ! * ptrptr && nmemb && size ) ) return AVERROR ( ENOMEM ) ; return 0 ; }
outputs:
int av_reallocp_array(void **ptr, size_t nmemb, size_t size) {
    if (!ptr) {
        return AVERROR(EINVAL);
    }
    void **ptrptr = ptr;
    void *new_ptr = av_realloc_f(*ptrptr, nmemb, size);
    if (!new_ptr && (nmemb || size)) {
        return AVERROR(ENOMEM);
    }
    *ptrptr = new_ptr;
    return 0;
}
--------------------
int av_reallocp_array(void **ptr, size_t nmemb, size_t size) {
    if (!ptr) {
        return AVERROR(EINVAL);
    }
    void **ptrptr = ptr;
    void *new_ptr = av_realloc_f(*ptrptr, nmemb, size);
    if (!new_ptr && (nmemb > 0 || size > 0)) {
        return AVERROR(ENOMEM);
    }
    *ptrptr = new_ptr;
    return 0;
}
--------------------
int av_reallocp_array(void **ptr, size_t nmemb, size_t size) {
    if (!ptr || !*ptr) {
        return AVERROR(EINVAL);
    }
    void **ptrptr = ptr;
    void *new_ptr = av_realloc_f(*ptrptr, nmemb, size);
    if (!new_ptr && (nmemb > 0 || size > 0)) {
        return AVERROR(ENOMEM);
    }
    *ptrptr = new_ptr;
    return 0;
}
--------------------
int av_reallocp_array(void **ptr, size_t nmemb, size_t size) {
    if (!ptr || !*ptr) {
        return AVERROR(EINVAL);
    }
    void **ptrptr = ptr;
    void *new_ptr = av_realloc_f(*ptrptr, nmemb, size);
    if (!new_ptr && nmemb > 0 && size > 0) {
        return AVERROR(ENOMEM);
    }
    *ptrptr = new_ptr;
    return 0;
}
--------------------
int av_reallocp_array(void **ptr, size_t nmemb, size_t size) {
    if (!ptr || !*ptr) {
        return AVERROR(EINVAL);
    }
    void **ptrptr = ptr;
    void *new_ptr = av_realloc_f(*ptrptr, nmemb, size);
    if (!new_ptr) {
        if (nmemb == 0 || size == 0) {
            *ptrptr = NULL;
            return 0;
        } else {
            return AVERROR(ENOMEM);
        }
    }
    *ptrptr = new_ptr;
    return 0;
}
--------------------
int av_reallocp_array(void **ptr, size_t nmemb, size_t size) {
    if (!ptr) {
        return AVERROR(EINVAL);
    }
    void **ptrptr = ptr;
    void *new_ptr = av_realloc_f(*ptrptr, nmemb, size);
    if (!new_ptr) {
        if (nmemb == 0 || size == 0) {
            *ptrptr = NULL;
            return 0;
        } else {
            return AVERROR(ENOMEM);
        }
    }
    *ptrptr = new_ptr;
    return 0;
}
--------------------
int av_reallocp_array(void **ptr, size_t nmemb, size_t size) {
    if (!ptr || !*ptr) {
        return AVERROR(EINVAL);
    }
    void **ptrptr = ptr;
    void *new_ptr = av_realloc_f(*ptrptr, nmemb, size);
    if (!new_ptr) {
        if (nmemb == 0 || size == 0) {
            *ptrptr = NULL;
            return 0;
        } else {
            return AVERROR(ENOMEM);
        }
    }
    memset(new_ptr, 0, nmemb * size);
    *ptrptr = new_ptr;
    return 0;
}
--------------------
int av_reallocp_array(void **ptr, size_t nmemb, size_t size) {
    if (!ptr || !*ptr) {
        return AVERROR(EINVAL);
    }
    void **ptrptr = ptr;
    void *new_ptr = av_realloc_f(*ptrptr, nmemb, size);
    if (!new_ptr) {
        if (nmemb == 0 || size == 0) {
            *ptrptr = NULL;
            return 0;
        } else {
            return AVERROR(ENOMEM);
        }
    }
    if (nmemb > 0 && size > 0) {
        memset(new_ptr + (*ptrptr - new_ptr), 0, nmemb * size);
    }
    *ptrptr = new_ptr;
    return 0;
}
--------------------
int av_reallocp_array(void **ptr, size_t nmemb, size_t size) {
    if (!ptr || !*ptr) {
        return AVERROR(EINVAL);
    }
    void **ptrptr = ptr;
    void *new_ptr = av_realloc_f(*ptrptr, nmemb, size);
    if (!new_ptr) {
        if (nmemb == 0 || size == 0) {
            *ptrptr = NULL;
            return 0;
        } else {
            return AVERROR(ENOMEM);
        }
    }
    if (nmemb > 0 && size > 0) {
        memset(new_ptr + (*ptrptr - *ptr), 0, nmemb * size);
    }
    *ptrptr = new_ptr;
    return 0;
}
--------------------
int av_reallocp_array(void **ptr, size_t nmemb, size_t size) {
    if (!ptr || !*ptr) {
        return AVERROR(EINVAL);
    }
    void **ptrptr = ptr;
    void *new_ptr = av_realloc_f(*ptrptr, nmemb, size);
    if (!new_ptr) {
        if (nmemb == 0 || size == 0) {
            *ptrptr = NULL;
            return 0;
        } else {
            return AVERROR(ENOMEM);
        }
    }
    if (nmemb > 0 && size > 0) {
        memset(new_ptr + (*ptrptr - *ptr), 0, nmemb * size);
    }
    if (nmemb == 0 || size == 0) {
        *ptrptr = NULL;
    }
    *ptrptr = new_ptr;
    return 0;
}
--------------------
match:0
source:
 static int amd_gpio_remove ( struct platform_device * pdev ) { struct amd_gpio * gpio_dev ; gpio_dev = platform_get_drvdata ( pdev ) ; gpiochip_remove ( & gpio_dev -> gc ) ; <S2SV_StartBug> pinctrl_unregister ( gpio_dev -> pctrl ) ; <S2SV_EndBug> return 0 ; }

target:
static int amd_gpio_remove ( struct platform_device * pdev ) { struct amd_gpio * gpio_dev ; gpio_dev = platform_get_drvdata ( pdev ) ; gpiochip_remove ( & gpio_dev -> gc ) ; return 0 ; }
outputs:
match:0
source:
 static void ptrace_link ( struct task_struct * child , struct task_struct * new_parent ) { <S2SV_StartBug> rcu_read_lock ( ) ; <S2SV_EndBug> <S2SV_StartBug> __ptrace_link ( child , new_parent , __task_cred ( new_parent ) ) ; <S2SV_EndBug> rcu_read_unlock ( ) ; }

target:
static void ptrace_link ( struct task_struct * child , struct task_struct * new_parent ) { __ptrace_link ( child , new_parent , __task_cred ( new_parent ) ) ; rcu_read_unlock ( ) ; }
outputs:
static int ptrace_link(struct task_struct *child, struct task_struct *new_parent) {
    if (!child || !new_parent) return -EINVAL;
    
    rcu_read_lock();
    __ptrace_link(child, new_parent, __task_cred(new_parent));
    rcu_read_unlock();

    return 0;
}
--------------------
static void ptrace_link(struct task_struct *child, struct task_struct *new_parent) {
    __ptrace_link(child, new_parent, __task_cred(new_parent));
}
--------------------
static DEFINE_MUTEX(ptrace_mutex);

static void ptrace_link(struct task_struct *child, struct task_struct *new_parent) {
    mutex_lock(&ptrace_mutex);
    __ptrace_link(child, new_parent, __task_cred(new_parent));
    mutex_unlock(&ptrace_mutex);
}
--------------------
static DEFINE_SPINLOCK(ptrace_lock);

static void ptrace_link(struct task_struct *child, struct task_struct *new_parent) {
    spin_lock(&ptrace_lock);
    __ptrace_link(child, new_parent, __task_cred(new_parent));
    spin_unlock(&ptrace_lock);
}
--------------------
static DECLARE_SEMAPHORE(ptrace_sem);

static void ptrace_link(struct task_struct *child, struct task_struct *new_parent) {
    down(&ptrace_sem);
    __ptrace_link(child, new_parent, __task_cred(new_parent));
    up(&ptrace_sem);
}
--------------------
static void ptrace_link(struct task_struct *child, struct task_struct *new_parent) {
    mutex_lock(&ptrace_mutex);
    __ptrace_link(child, new_parent, __task_cred(new_parent));
    mutex_unlock(&ptrace_mutex);

    /* add lockdep annotation to detect lock order issues */
    lockdep_assert_held(&ptrace_mutex);
}
--------------------
static DEFINE_MUTEX(ptrace_mutex);

static void ptrace_link(struct task_struct *child, struct task_struct *new_parent) {
    mutex_lock(&ptrace_mutex); /* acquire lock */
    lockdep_push_current(&new_parent->dep_map); /* push current lock into lockdep */
    __ptrace_link(child, new_parent, __task_cred(new_parent)); /* execute code */
    lockdep_pop_current(&new_parent->dep_map); /* pop current lock from lockdep */
    mutex_unlock(&ptrace_mutex); /* release lock */
}
--------------------
static DEFINE_RWLOCK(ptrace_rwlock);

static void ptrace_link(struct task_struct *child, struct task_struct *new_parent) {
    write_lock(&ptrace_rwlock); /* acquire write lock */
    __ptrace_link(child, new_parent, __task_cred(new_parent)); /* execute code */
    write_unlock(&ptrace_rwlock); /* release write lock */
}
--------------------
static DECLARE_COMPLETION(ptrace_completion);

static void ptrace_link(struct task_struct *child, struct task_struct *new_parent) {
    wait_for_completion(&ptrace_completion);
    __ptrace_link(child, new_parent, __task_cred(new_parent));
    complete(&ptrace_completion);
}
--------------------
static DEFINE_MUTEX(ptrace_mutex);
static DECLARE_WAIT_QUEUE_HEAD(ptrace_waitqueue);

static void ptrace_link(struct task_struct *child, struct task_struct *new_parent) {
    mutex_lock(&ptrace_mutex);
    while (!condition) { /* wait for condition */
        mutex_unlock(&ptrace_mutex);
        wait_event_interruptible(ptrace_waitqueue);
        mutex_lock(&ptrace_mutex);
    }
    
    __ptrace_link(child, new_parent, __task_cred(new_parent)); /* execute code */
    
    condition = true; /* signal condition */
    wake_up_all(&ptrace_waitqueue);
    
    mutex_unlock(&ptrace_mutex); /* release lock */
}
--------------------
match:0
source:
 <S2SV_StartBug> static int jas_iccputuint ( jas_stream_t * out , int n , ulonglong val ) <S2SV_EndBug> { int i ; int c ; for ( i = n ; i > 0 ; -- i ) { c = ( val >> ( 8 * ( i - 1 ) ) ) & 0xff ; if ( jas_stream_putc ( out , c ) == EOF ) return - 1 ; } return 0 ; }

target:
static int jas_iccputuint ( jas_stream_t * out , int n , jas_ulonglong val ) { int i ; int c ; for ( i = n ; i > 0 ; -- i ) { c = ( val >> ( 8 * ( i - 1 ) ) ) & 0xff ; if ( jas_stream_putc ( out , c ) == EOF ) return - 1 ; } return 0 ; }
outputs:
match:0
source:
 <S2SV_StartBug> void vp9_cost_tokens_skip ( int * costs , const vp9_prob * probs , vp9_tree tree ) { <S2SV_EndBug> assert ( tree [ 0 ] <= 0 && tree [ 1 ] > 0 ) ; costs [ - tree [ 0 ] ] = vp9_cost_bit ( probs [ 0 ] , 0 ) ; cost ( costs , tree , probs , 2 , 0 ) ; }

target:
void vp9_cost_tokens_skip ( int * costs , const vpx_prob * probs , vp9_tree tree ) { assert ( tree [ 0 ] <= 0 && tree [ 1 ] > 0 ) ; costs [ - tree [ 0 ] ] = vp9_cost_bit ( probs [ 0 ] , 0 ) ; cost ( costs , tree , probs , 2 , 0 ) ; }
outputs:
match:0
source:
 static inline int sctp_chunk_length_valid ( struct sctp_chunk * chunk , __u16 required_length ) { __u16 chunk_length = ntohs ( chunk -> chunk_hdr -> length ) ; <S2SV_StartBug> if ( unlikely ( chunk_length < required_length ) ) <S2SV_EndBug> return 0 ; return 1 ; }

target:
static inline int sctp_chunk_length_valid ( struct sctp_chunk * chunk , __u16 required_length ) { __u16 chunk_length = ntohs ( chunk -> chunk_hdr -> length ) ; if ( unlikely ( chunk -> pdiscard ) ) return 0 ; if ( unlikely ( chunk_length < required_length ) ) return 0 ; return 1 ; }
outputs:
static inline int sctp_chunk_length_valid(struct sctp_chunk* chunk, __u16 required_length) {
    if (chunk == NULL || chunk->chunk_hdr == NULL)
        return 0;

    __u16 chunk_length = ntohs(chunk->chunk_hdr->length);
    if (unlikely(chunk_length < required_length))
        return 0;

    return 1;
}
--------------------
static inline int sctp_chunk_length_valid(struct sctp_chunk* chunk, __u16 required_length) {
    if (chunk == NULL || chunk->chunk_hdr == NULL || required_length > USHRT_MAX)
        return 0;

    __u16 chunk_length = ntohs(chunk->chunk_hdr->length);
    if (unlikely(chunk_length < required_length))
        return 0;

    return 1;
}
--------------------
enum sctp_chunk_validation_result {
    SCTP_CHUNK_VALID,
    SCTP_CHUNK_INVALID_LENGTH,
    SCTP_CHUNK_NULL_POINTER
};

static inline enum sctp_chunk_validation_result sctp_chunk_length_valid(struct sctp_chunk* chunk, __u16 required_length) {
    if (chunk == NULL || chunk->chunk_hdr == NULL)
        return SCTP_CHUNK_NULL_POINTER;

    __u16 chunk_length = ntohs(chunk->chunk_hdr->length);
    if (unlikely(chunk_length < required_length))
        return SCTP_CHUNK_INVALID_LENGTH;

    return SCTP_CHUNK_VALID;
}
--------------------
static inline int sctp_chunk_length_valid(struct sctp_chunk* chunk, __u16 required_length) {
    if (chunk == NULL || chunk->chunk_hdr == NULL || required_length > USHRT_MAX)
        return 0;

    __u16 chunk_length = ntohs(chunk->chunk_hdr->length);
    if (chunk_length < required_length)
        return 0;

    return 1;
}
--------------------
static inline int sctp_chunk_length_valid(const struct sctp_chunk* chunk, __u16 required_length) {
    if (chunk == NULL || chunk->chunk_hdr == NULL || required_length > USHRT_MAX)
        return 0;

    __u16 chunk_length = ntohs(chunk->chunk_hdr->length);
    if (chunk_length < required_length)
        return 0;

    return 1;
}
--------------------
static inline int sctp_chunk_length_valid(const struct sctp_chunk* chunk, __u16 required_length) {
    return (chunk != NULL && 
            chunk->chunk_hdr != NULL && 
            required_length <= USHRT_MAX && 
            ntohs(chunk->chunk_hdr->length) >= required_length) ? 1 : 0;
}
--------------------
enum sctp_chunk_validation_result {
    SCTP_CHUNK_VALID,
    SCTP_CHUNK_INVALID_LENGTH,
    SCTP_CHUNK_NULL_POINTER,
    SCTP_CHUNK_INVALID_ARGUMENT
};

static inline enum sctp_chunk_validation_result sctp_chunk_length_valid(const struct sctp_chunk* chunk, __u16 required_length) {
    if (chunk == NULL || chunk->chunk_hdr == NULL)
        return SCTP_CHUNK_NULL_POINTER;

    if (required_length > USHRT_MAX)
        return SCTP_CHUNK_INVALID_ARGUMENT;
    
    __u16 chunk_length = ntohs(chunk->chunk_hdr->length);
    if (chunk_length < required_length)
        return SCTP_CHUNK_INVALID_LENGTH;

    return SCTP_CHUNK_VALID;
}
--------------------
enum sctp_chunk_validation_result {
    SCTP_CHUNK_VALID,
    SCTP_CHUNK_INVALID_LENGTH,
    SCTP_CHUNK_NULL_POINTER,
    SCTP_CHUNK_INVALID_ARGUMENT
};

static inline enum sctp_chunk_validation_result sctp_chunk_length_valid(const struct sctp_chunk* chunk, __u16 required_length) {
    if (chunk == NULL || chunk->chunk_hdr == NULL)
        return SCTP_CHUNK_NULL_POINTER;

    if (required_length > USHRT_MAX)
        return SCTP_CHUNK_INVALID_ARGUMENT;
    
    __u16 chunk_length = ntohs(chunk->chunk_hdr->length);
    if (chunk_length < required_length)
        return SCTP_CHUNK_INVALID_LENGTH;

    return SCTP_CHUNK_VALID;
}

const char* sctp_chunk_validation_result_message(enum sctp_chunk_validation_result result) {
    switch (result) {
    case SCTP_CHUNK_VALID:
        return "Valid SCTP chunk.";
    case SCTP_CHUNK_INVALID_LENGTH:
        return "Invalid SCTP chunk length.";
    case SCTP_CHUNK_NULL_POINTER:
        return "Null pointer error.";
    case SCTP_CHUNK_INVALID_ARGUMENT:
        return "Invalid argument error.";
    default:
        return "Unknown error.";
    }
}
--------------------
enum sctp_chunk_validation_result {
    SCTP_CHUNK_VALID,
    SCTP_CHUNK_INVALID_LENGTH,
    SCTP_CHUNK_NULL_POINTER,
    SCTP_CHUNK_INVALID_ARGUMENT
};

static inline enum sctp_chunk_validation_result sctp_validate_chunk_length(const struct sctp_chunk* chunk, __u16 required_length) {
    if (chunk == NULL || chunk->chunk_hdr == NULL)
        return SCTP_CHUNK_NULL_POINTER;

    if (required_length > USHRT_MAX)
        return SCTP_CHUNK_INVALID_ARGUMENT;
    
    __u16 chunk_length = ntohs(chunk->chunk_hdr->length);
    if (chunk_length < required_length)
        return SCTP_CHUNK_INVALID_LENGTH;

    return SCTP_CHUNK_VALID;
}

const char* sctp_chunk_validation_result_message(enum sctp_chunk_validation_result result) {
    switch (result) {
    case SCTP_CHUNK_VALID:
        return "Valid SCTP chunk.";
    case SCTP_CHUNK_INVALID_LENGTH:
        return "Invalid SCTP chunk length.";
    case SCTP_CHUNK_NULL_POINTER:
        return "Null pointer error.";
    case SCTP_CHUNK_INVALID_ARGUMENT:
        return "Invalid argument error.";
    default:
        return "Unknown error.";
    }
}
--------------------
static enum sctp_chunk_validation_result sctp_validate_chunk_length(const struct sctp_chunk* chunk, __u16 required_length) {
    if (chunk == NULL || chunk->chunk_hdr == NULL)
        return SCTP_CHUNK_NULL_POINTER;

    if (required_length > USHRT_MAX)
        return SCTP_CHUNK_INVALID_ARGUMENT;
    
    __u16 chunk_length = ntohs(chunk->chunk_hdr->length);
    if (chunk_length < required_length)
        return SCTP_CHUNK_INVALID_LENGTH;

    return SCTP_CHUNK_VALID;
}

const char* sctp_chunk_validation_result_message(enum sctp_chunk_validation_result result) {
    switch (result) {
    case SCTP_CHUNK_VALID:
        return "Valid SCTP chunk.";
    case SCTP_CHUNK_INVALID_LENGTH:
        return "Invalid SCTP chunk length.";
    case SCTP_CHUNK_NULL_POINTER:
        return "Null pointer error.";
    case SCTP_CHUNK_INVALID_ARGUMENT:
        return "Invalid argument error.";
    default:
        return "Unknown error.";
    }
}
--------------------
match:0
source:
 void Rectangle ( double x , double y , double w , double h ) { <S2SV_StartBug> outpos += sprintf ( outpos , "\\n%12.3f%12.3f%12.3f%12.3fre" , x , y , w , h ) ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>

target:
void Rectangle ( double x , double y , double w , double h ) { sprintf ( outputbuffer , "\\n%12.3f%12.3f%12.3f%12.3fre" , x , y , w , h ) ; sendClean ( outputbuffer ) ; }
outputs:
void Rectangle(double x, double y, double w, double h) {
    outpos += sprintf(outpos, "\\n%12.3f%12.3f%12.3f%12.3fre", x, y, w, h);
}
--------------------
void Rectangle(double x, double y, double w, double h) {
    char buffer[50];
    int ret = sprintf(buffer, "\\n%12.3f%12.3f%12.3f%12.3fre", x, y, w, h);
    if(ret < 0) {
        // handle error
    }
    strcat(outpos, buffer);
}
--------------------
void Rectangle(double x, double y, double w, double h) {
    if(outpos) {
        outpos += sprintf(outpos, "\\n%12.3f%12.3f%12.3f%12.3fre", x, y, w, h);
    }
}
--------------------
void Rectangle(double x, double y, double w, double h) {
    char buffer[50];
    int ret = snprintf(buffer, sizeof(buffer), "\\n%12.3f%12.3f%12.3f%12.3fre", x, y, w, h);
    if(ret < sizeof(buffer)) {
        strcat(outpos, buffer);
    }
}
--------------------
void Rectangle(double x, double y, double w, double h, char* outbuf, size_t outsize) {
    if(outbuf) {
        snprintf(outbuf, outsize, "\\n%12.3f%12.3f%12.3f%12.3fre", x, y, w, h);
    }
}
--------------------
void Rectangle(double x, double y, double w, double h) {
    char buffer[50];
    int ret = snprintf(buffer, sizeof(buffer), "\\n%12.3f%12.3f%12.3f%12.3fre", x, y, w, h);
    if(ret < sizeof(buffer)) {
        strncat(outpos, buffer, sizeof(outpos) - strlen(outpos) - 1);
    }
}
--------------------
struct StringBuilder {
    char* buffer;
    size_t size;
    size_t length;
};

void StringBuilder_Init(struct StringBuilder* builder, char* buffer, size_t size) {
    builder->buffer = buffer;
    builder->size = size;
    builder->length = 0;
}

void StringBuilder_Append(struct StringBuilder* builder, const char* str) {
    size_t len = strlen(str);
    if(builder->length + len < builder->size - 1) {
        strncat(builder->buffer, str, builder->size - builder->length - 1);
        builder->length += len;
    }
}

void Rectangle(double x, double y, double w, double h, struct StringBuilder* builder) {
    char buffer[50];
    int ret = snprintf(buffer, sizeof(buffer), "\\n%12.3f%12.3f%12.3f%12.3fre", x, y, w, h);
    if(ret < sizeof(buffer)) {
        StringBuilder_Append(builder, buffer);
    }
}
--------------------
#include <glib.h>

void Rectangle(double x, double y, double w, double h, GString* builder) {
    char buffer[50];
    int ret = snprintf(buffer, sizeof(buffer), "\\n%12.3f%12.3f%12.3f%12.3fre", x, y, w, h);
    if(ret < sizeof(buffer)) {
        g_string_append(builder, buffer);
    }
}
--------------------
void AppendFormattedString(char* outbuf, size_t outsize, const char* format, ...) {
    va_list args;
    va_start(args, format);
    vsnprintf(outbuf, outsize, format, args);
    va_end(args);
}

void Rectangle(double x, double y, double w, double h) {
    char buffer[50];
    AppendFormattedString(buffer, sizeof(buffer), "\\n%12.3f%12.3f%12.3f%12.3fre", x, y, w, h);
    strncat(outpos, buffer, sizeof(outpos) - strlen(outpos) - 1);
}
--------------------
#include <string>
#include <sstream>

void Rectangle(double x, double y, double w, double h) {
    std::ostringstream oss;
    oss << "\\n";
    oss.precision(3);
    oss << std::fixed << std::setw(12) << x
        << std::setw(12) << y
        << std::setw(12) << w
        << std::setw(12) << h
        << "re";
    std::string str = oss.str();
    outpos += str;
}
--------------------
match:0
source:
 <S2SV_StartBug> static int getnum ( const char * * fmt , int df ) { <S2SV_EndBug> if ( ! isdigit ( * * fmt ) ) return df ; else { int a = 0 ; <S2SV_StartBug> do { <S2SV_EndBug> a = a * 10 + * ( ( * fmt ) ++ ) - '0' ; } while ( isdigit ( * * fmt ) ) ; return a ; } }

target:
static int getnum ( lua_State * L , const char * * fmt , int df ) { if ( ! isdigit ( * * fmt ) ) return df ; else { int a = 0 ; do { if ( a > ( INT_MAX / 10 ) || a * 10 > ( INT_MAX - ( * * fmt - '0' ) ) ) luaL_error ( L , "integralsizeoverflow" ) ; a = a * 10 + * ( ( * fmt ) ++ ) - '0' ; } while ( isdigit ( * * fmt ) ) ; return a ; } }
outputs:
static int getnum ( const char* fmt , int df ) {
	if ( ! isdigit ( * fmt ) ) 
		return df ; 
	else { 
		int a = 0 ; 
		do { 
			a = a * 10 + *fmt - '0' ; 
		} while ( isdigit ( *(++fmt) ) ); 
		return a ; 
	} 
}
--------------------
static int getnum ( const char* fmt , int df ) {
	if ( !fmt ) 
	   return df;
	if ( ! isdigit ( * fmt ) ) 
		return df ; 
	else { 
		int a = 0 ; 
		do { 
			a = a * 10 + *fmt - '0' ; 
		} while ( isdigit ( *(++fmt) ) ); 
		return a ; 
	} 
}
--------------------
static int getnum ( const char* fmt , int df ) {
	if ( !fmt )
        return df;
    if ( *fmt == '\0')
        return df;
	if ( ! isdigit ( * fmt ) ) 
		return df ; 
	else { 
		int a = 0 ; 
		do { 
			a = a * 10 + *fmt - '0' ; 
		} while ( isdigit ( *(++fmt) ) ); 
		return a ; 
	} 
}
--------------------
static int getnum ( const char* fmt , int df ) {
	if ( !fmt )
        return df;
    if ( *fmt == '\0')
        return df;
	if ( ! isdigit ( * fmt ) ) 
		return df ; 
	else { 
		int a = 0 ; 
		do { 
			a = a * 10 + *(fmt++) - '0' ; 
		} while ( isdigit ( *fmt ) ); 
		return a ; 
	} 
}
--------------------
static int getnum ( const char* fmt , int df ) {
	if ( !fmt )
        return df;
    if ( *fmt == '\0')
        return df;
	char c = *fmt;
	if ( ! isdigit ( c ) ) 
		return df ; 
	else { 
		int a = 0 ; 
		do { 
			a = a * 10 + (c - '0') ; 
            c = *(++fmt);
		} while ( isdigit ( c ) ); 
		return a ; 
	} 
}
--------------------
static int getnum ( const char* fmt , int df ) {
	if ( !fmt )
        return df;
    if ( *fmt == '\0')
        return df;
	char c = *fmt;
	if ( ! isdigit ( c ) ) 
		return df ; 
	else { 
		int a = 0 ;
        for (; isdigit(c); c = *(++fmt)) { 
			a = a * 10 + (c - '0') ; 
		}
		return a ; 
	} 
}
--------------------
static int getnum ( const char* fmt , int df ) {
	if ( !fmt )
        return df;
    if ( *fmt == '\0')
        return df;
	char c = *fmt;
	if ( ! isdigit ( c ) ) 
		return df ; 
	else { 
		int a = 0 ;
        for (; isdigit(c); c = *(++fmt)) { 
			a = a * 10 + (c - '0') ;
            if (a > INT_MAX/10) // upper bound check 
               return df;
            if (a == INT_MAX / 10 && (c - '0') > INT_MAX % 10) // lower bound check
                return df;
		}
		return a ; 
	} 
}
--------------------
static int getnum ( const char* fmt , int df ) {
	if ( !fmt )
        return df;
    if ( *fmt == '\0')
        return df;
	char c = *fmt;
	int a = df ; 
    if ( isdigit ( c ) ) { 
        a = 0 ;
        for (; isdigit(c); c = *(++fmt)) { 
			a = a * 10 + (c - '0') ;
            if (a > INT_MAX/10) // upper bound check 
               return df;
            if (a == INT_MAX / 10 && (c - '0') > INT_MAX % 10) // lower bound check
                return df;
		}
	}
	return a ; 
}
--------------------
static int getnum ( const char* fmt , int df ) {
    static const int INT_MAX_BY_10 = INT_MAX / 10;
	if ( !fmt )
        return df;
    if ( *fmt == '\0')
        return df;
	char c = *fmt;
	int a = df ; 
    if ( isdigit ( c ) ) { 
        a = 0 ;
        for (; isdigit(c); c = *(++fmt)) { 
			a = a * 10 + (c - '0') ;
            if (a > INT_MAX_BY_10) // upper bound check 
               return df;
            if (a == INT_MAX_BY_10 && (c - '0') > INT_MAX % 10) // lower bound check
                return df;
		}
	}
	return a ; 
}
--------------------
static int getnum(const char* numStr, int dfValue)
{
    static const int INT_MAX_BY_10 = INT_MAX / 10;
    if (!numStr) 
        return dfValue;
    if (*numStr == '\0')
        return dfValue;
    char c = *numStr;
    int a = dfValue; 
    if (isdigit(c)) 
    { 
        a = 0;
        for (; isdigit(c); c = *(++numStr)) 
        { 
            a = a * 10 + (c - '0') ;
            if (a > INT_MAX_BY_10) 
                return dfValue;
            if (a == INT_MAX_BY_10 && (c - '0') > INT_MAX % 10) 
                return dfValue;
        }
    }
    return a; 
}
--------------------
match:0
source:
 <S2SV_StartBug> static TX_MODE read_tx_mode ( vp9_reader * r ) { <S2SV_EndBug> <S2SV_StartBug> TX_MODE tx_mode = vp9_read_literal ( r , 2 ) ; <S2SV_EndBug> if ( tx_mode == ALLOW_32X32 ) <S2SV_StartBug> tx_mode += vp9_read_bit ( r ) ; <S2SV_EndBug> return tx_mode ; }

target:
static TX_MODE read_tx_mode ( vpx_reader * r ) { TX_MODE tx_mode = vpx_read_literal ( r , 2 ) ; if ( tx_mode == ALLOW_32X32 ) tx_mode += vpx_read_bit ( r ) ; return tx_mode ; }
outputs:
match:0
source:
 static int linear_ioctl ( struct dm_target * ti , unsigned int cmd , unsigned long arg ) { struct linear_c * lc = ( struct linear_c * ) ti -> private ; <S2SV_StartBug> return __blkdev_driver_ioctl ( lc -> dev -> bdev , lc -> dev -> mode , cmd , arg ) ; <S2SV_EndBug> }

target:
static int linear_ioctl ( struct dm_target * ti , unsigned int cmd , unsigned long arg ) { struct linear_c * lc = ( struct linear_c * ) ti -> private ; struct dm_dev * dev = lc -> dev ; int r = 0 ; if ( lc -> start || ti -> len != i_size_read ( dev -> bdev -> bd_inode ) >> SECTOR_SHIFT ) r = scsi_verify_blk_ioctl ( NULL , cmd ) ; return r ? : __blkdev_driver_ioctl ( dev -> bdev , dev -> mode , cmd , arg ) ; }
outputs:
match:0
source:
 <S2SV_StartBug> static void buffer_pipe_buf_get ( struct pipe_inode_info * pipe , <S2SV_EndBug> struct pipe_buffer * buf ) { struct buffer_ref * ref = ( struct buffer_ref * ) buf -> private ; <S2SV_StartBug> ref -> ref ++ ; <S2SV_EndBug> <S2SV_StartBug> } <S2SV_EndBug>

target:
static bool buffer_pipe_buf_get ( struct pipe_inode_info * pipe , struct pipe_buffer * buf ) { struct buffer_ref * ref = ( struct buffer_ref * ) buf -> private ; if ( ref -> ref > INT_MAX / 2 ) return false ; ref -> ref ++ ; return true ; }
outputs:
match:0
source:
 static inline int btif_hl_select_close_connected ( void ) { char sig_on = btif_hl_signal_select_close_connected ; BTIF_TRACE_DEBUG ( "btif_hl_select_close_connected" ) ; <S2SV_StartBug> return send ( signal_fds [ 1 ] , & sig_on , sizeof ( sig_on ) , 0 ) ; <S2SV_EndBug> }

target:
static inline int btif_hl_select_close_connected ( void ) { char sig_on = btif_hl_signal_select_close_connected ; BTIF_TRACE_DEBUG ( "btif_hl_select_close_connected" ) ; return TEMP_FAILURE_RETRY ( send ( signal_fds [ 1 ] , & sig_on , sizeof ( sig_on ) , 0 ) ) ; }
outputs:
match:0
source:
 <S2SV_StartBug> void ntlm_free_message_fields_buffer ( NTLM_MESSAGE_FIELDS * fields ) <S2SV_EndBug> { if ( fields ) { if ( fields -> Buffer ) { free ( fields -> Buffer ) ; fields -> Len = 0 ; fields -> MaxLen = 0 ; fields -> Buffer = NULL ; fields -> BufferOffset = 0 ; } } }

target:
static void ntlm_free_message_fields_buffer ( NTLM_MESSAGE_FIELDS * fields ) { if ( fields ) { if ( fields -> Buffer ) { free ( fields -> Buffer ) ; fields -> Len = 0 ; fields -> MaxLen = 0 ; fields -> Buffer = NULL ; fields -> BufferOffset = 0 ; } } }
outputs:
match:0
source:
 void vp9_lookahead_destroy ( struct lookahead_ctx * ctx ) { if ( ctx ) { if ( ctx -> buf ) { unsigned int i ; for ( i = 0 ; i < ctx -> max_sz ; i ++ ) <S2SV_StartBug> vp9_free_frame_buffer ( & ctx -> buf [ i ] . img ) ; <S2SV_EndBug> free ( ctx -> buf ) ; } free ( ctx ) ; } }

target:
void vp9_lookahead_destroy ( struct lookahead_ctx * ctx ) { if ( ctx ) { if ( ctx -> buf ) { unsigned int i ; for ( i = 0 ; i < ctx -> max_sz ; i ++ ) vpx_free_frame_buffer ( & ctx -> buf [ i ] . img ) ; free ( ctx -> buf ) ; } free ( ctx ) ; } }
outputs:
match:0
source:
 static bool ndp_msg_check_valid ( struct ndp_msg * msg ) { size_t len = ndp_msg_payload_len ( msg ) ; enum ndp_msg_type msg_type = ndp_msg_type ( msg ) ; if ( len < ndp_msg_type_info ( msg_type ) -> raw_struct_size ) return false ; <S2SV_StartBug> return true ; <S2SV_EndBug> }

target:
static bool ndp_msg_check_valid ( struct ndp_msg * msg ) { size_t len = ndp_msg_payload_len ( msg ) ; enum ndp_msg_type msg_type = ndp_msg_type ( msg ) ; if ( len < ndp_msg_type_info ( msg_type ) -> raw_struct_size ) return false ; if ( ndp_msg_type_info ( msg_type ) -> addrto_validate ) return ndp_msg_type_info ( msg_type ) -> addrto_validate ( & msg -> addrto ) ; else return true ; }
outputs:
static bool ndp_msg_check_valid(struct ndp_msg* msg) {
    size_t len = ndp_msg_payload_len(msg);
    enum ndp_msg_type msg_type = ndp_msg_type(msg);
    if (msg_type >= NDP_MSG_TYPE_MAX || len < ndp_msg_type_info(msg_type)->raw_struct_size) {
        return false;
    }
    return true;
}
--------------------
static bool ndp_msg_check_valid(struct ndp_msg* msg) {
    size_t len = ndp_msg_payload_len(msg);
    enum ndp_msg_type msg_type = ndp_msg_type(msg);
    const struct ndp_msg_type_info* info = ndp_msg_type_info(msg_type);
    if (!info || len < info->raw_struct_size) {
        return false;
    }
    return true;
}
--------------------
static bool ndp_msg_check_valid(struct ndp_msg* msg) {
    if (!msg) {
        return false;
    }
    size_t len = ndp_msg_payload_len(msg);
    enum ndp_msg_type msg_type = ndp_msg_type(msg);
    const struct ndp_msg_type_info* info = ndp_msg_type_info(msg_type);
    if (!info || len < info->raw_struct_size) {
        return false;
    }
    return true;
}
--------------------
static bool ndp_msg_check_valid(const struct ndp_msg* msg) {
    if (!msg) {
        return false;
    }
    size_t len = ndp_msg_payload_len(msg);
    enum ndp_msg_type msg_type = ndp_msg_type(msg);
    const struct ndp_msg_type_info* info = ndp_msg_type_info(msg_type);
    if (!info || len < info->raw_struct_size) {
        return false;
    }
    return true;
}
--------------------
static bool ndp_msg_is_valid(const struct ndp_msg* msg) {
    if (!msg) {
        return false;
    }
    size_t len = ndp_msg_payload_len(msg);
    enum ndp_msg_type msg_type = ndp_msg_type(msg);
    const struct ndp_msg_type_info* info = ndp_msg_type_info(msg_type);
    if (!info || len < info->raw_struct_size) {
        return false;
    }
    return true;
}
--------------------
// Returns true if the given NDP message is valid, false otherwise.
static bool ndp_msg_is_valid(const struct ndp_msg* msg) {
    if (!msg) {
        return false;
    }
    size_t len = ndp_msg_payload_len(msg);
    enum ndp_msg_type msg_type = ndp_msg_type(msg);
    const struct ndp_msg_type_info* info = ndp_msg_type_info(msg_type);
    if (!info || len < info->raw_struct_size) {
        return false;
    }
    return true;
}
--------------------
static bool ndp_msg_is_valid(const struct ndp_msg* msg) {
    if (!msg) {
        return false;
    }
    size_t len = ndp_msg_payload_len(msg);
    enum ndp_msg_type msg_type = ndp_msg_type(msg);
    switch (msg_type) {
        case NDP_MSG_TYPE_FOO:
            if (len < sizeof(struct ndp_foo_msg)) {
                return false;
            }
            break;
        case NDP_MSG_TYPE_BAR:
            if (len < sizeof(struct ndp_bar_msg)) {
                return false;
            }
            break;
        default:
            return false;
    }
    return true;
}
--------------------
static bool ndp_msg_check_valid(struct ndp_msg* msg) {
    size_t len = ndp_msg_payload_len(msg);
    enum ndp_msg_type msg_type = ndp_msg_type(msg);
    if (len < ndp_msg_type_info(msg_type)->raw_struct_size) {
        return false;
    }
    return true;
}
--------------------
static bool ndp_msg_check_valid(struct ndp_msg* msg) {
    enum ndp_msg_type msg_type = ndp_msg_type(msg);
    if (sizeof(*msg) < ndp_msg_type_info(msg_type)->raw_struct_size) {
        return false;
    }
    return true;
}
--------------------
static bool ndp_msg_check_valid(struct ndp_msg* msg) {
    enum ndp_msg_type msg_type = ndp_msg_type(msg);
    const struct ndp_msg_type_info* info = ndp_msg_type_info(msg_type);
    assert(info && "Invalid NDP message type");
    if (sizeof(*msg) < info->raw_struct_size) {
        return false;
    }
    return true;
}
--------------------
match:0
source:
 mod_ty <S2SV_StartBug> Module ( asdl_seq * body , PyArena * arena ) <S2SV_EndBug> { mod_ty p ; p = ( mod_ty ) PyArena_Malloc ( arena , sizeof ( * p ) ) ; if ( ! p ) return NULL ; p -> kind = Module_kind ; p -> v . Module . body = body ; <S2SV_StartBug> return p ; <S2SV_EndBug> }

target:
mod_ty Module ( asdl_seq * body , asdl_seq * type_ignores , PyArena * arena ) { mod_ty p ; p = ( mod_ty ) PyArena_Malloc ( arena , sizeof ( * p ) ) ; if ( ! p ) return NULL ; p -> kind = Module_kind ; p -> v . Module . body = body ; p -> v . Module . type_ignores = type_ignores ; return p ; }
outputs:
match:0
source:
 int yr_re_ast_create ( RE_AST * * re_ast ) { * re_ast = ( RE_AST * ) yr_malloc ( sizeof ( RE_AST ) ) ; if ( * re_ast == NULL ) return ERROR_INSUFFICIENT_MEMORY ; ( * re_ast ) -> flags = 0 ; <S2SV_StartBug> ( * re_ast ) -> root_node = NULL ; <S2SV_EndBug> return ERROR_SUCCESS ; }

target:
int yr_re_ast_create ( RE_AST * * re_ast ) { * re_ast = ( RE_AST * ) yr_malloc ( sizeof ( RE_AST ) ) ; if ( * re_ast == NULL ) return ERROR_INSUFFICIENT_MEMORY ; ( * re_ast ) -> levels = 0 ; ( * re_ast ) -> flags = 0 ; ( * re_ast ) -> root_node = NULL ; return ERROR_SUCCESS ; }
outputs:
int yr_re_ast_create(RE_AST **re_ast) {
    if (re_ast == NULL) return ERROR_NULL_POINTER;
    *re_ast = (RE_AST*) yr_malloc(sizeof(RE_AST));
    if (*re_ast == NULL) return ERROR_INSUFFICIENT_MEMORY ;
    (*re_ast)->flags = 0;
    (*re_ast)->root_node = NULL;
    return ERROR_SUCCESS ;
}
--------------------
int yr_re_ast_create(RE_AST **re_ast) {
    if (re_ast == NULL) return ERROR_NULL_POINTER;
    *re_ast = (RE_AST*) yr_malloc(sizeof(RE_AST));
    if (*re_ast == NULL) return ERROR_INSUFFICIENT_MEMORY ;
    memset(*re_ast, 0, sizeof(RE_AST));
    return ERROR_SUCCESS ;
}
--------------------
int yr_re_ast_create(RE_AST **re_ast) {
    if (re_ast == NULL) return ERROR_NULL_POINTER;
    RE_AST* new_ast = (RE_AST*) yr_malloc(sizeof(RE_AST));
    if (new_ast == NULL) return ERROR_INSUFFICIENT_MEMORY ;
    new_ast->flags = 0;
    new_ast->root_node = NULL;
    *re_ast = new_ast;
    return ERROR_SUCCESS ;
}
--------------------
int yr_re_ast_create(RE_AST **re_ast) {
    if (re_ast == NULL) return ERROR_NULL_POINTER;
    *re_ast = (RE_AST*) yr_calloc(1, sizeof(RE_AST));
    if (*re_ast == NULL) return ERROR_INSUFFICIENT_MEMORY ;
    return ERROR_SUCCESS ;
}
--------------------
int yr_re_ast_create(RE_AST **re_ast) {
    if (re_ast == NULL) return ERROR_NULL_POINTER;
    RE_AST* new_ast = (RE_AST*) yr_malloc(sizeof(RE_AST));
    if (new_ast == NULL) return ERROR_INSUFFICIENT_MEMORY ;
    memset(new_ast, 0, sizeof(RE_AST));
    *re_ast = new_ast;
    return ERROR_SUCCESS ;
}
--------------------
int yr_re_ast_create(RE_AST **re_ast) {
    if (!re_ast) {
        return ERROR_NULL_POINTER;
    }
    RE_AST* ast = (RE_AST*) yr_malloc(sizeof(RE_AST));
    if (!ast) {
        return ERROR_INSUFFICIENT_MEMORY;
    }
    ast->flags = 0;
    ast->root_node = NULL;
    *re_ast = ast;
    return ERROR_SUCCESS;
}
--------------------
int yr_re_ast_create(RE_AST **re_ast) {
    if (*re_ast) {
        return ERROR_INVALID_ARGUMENT;
    }
    *re_ast = (RE_AST*) yr_malloc(sizeof(RE_AST));
    if (!*re_ast) {
        return ERROR_INSUFFICIENT_MEMORY;
    }
    memset(*re_ast, 0, sizeof(RE_AST));
    return ERROR_SUCCESS;
}
--------------------
int yr_re_ast_create(RE_AST **re_ast) {
    if (!re_ast) {
        return ERROR_NULL_POINTER;
    }
    *re_ast = (RE_AST*) yr_malloc(sizeof(RE_AST));
    if (!*re_ast) {
        return ERROR_INSUFFICIENT_MEMORY ;
    }
    memset(*re_ast, 0, sizeof(RE_AST));
    (*re_ast)->flags = 0;
    return ERROR_SUCCESS;
}
--------------------
int yr_re_ast_create(RE_AST **re_ast) {
    if (!re_ast) {
        return ERROR_INVALID_ARGUMENT;
    }
    *re_ast = calloc(1, sizeof(RE_AST));
    if (!*re_ast) {
        return ERROR_INSUFFICIENT_MEMORY ;
    }
    return ERROR_SUCCESS;
}
--------------------
int yr_re_ast_create(RE_AST **re_ast) {
    if (!re_ast) {
        return ERROR_INVALID_ARGUMENT;
    }
    *re_ast = malloc(sizeof(RE_AST));
    if (!*re_ast) {
        return ERROR_INSUFFICIENT_MEMORY ;
    }
    memset(*re_ast, 0, sizeof(RE_AST));
    return ERROR_SUCCESS;
}
--------------------
match:0
source:
 int yr_re_ast_create ( RE_AST * * re_ast ) { * re_ast = ( RE_AST * ) yr_malloc ( sizeof ( RE_AST ) ) ; if ( * re_ast == NULL ) return ERROR_INSUFFICIENT_MEMORY ; ( * re_ast ) -> flags = 0 ; <S2SV_StartBug> ( * re_ast ) -> root_node = NULL ; <S2SV_EndBug> return ERROR_SUCCESS ; }

target:
int yr_re_ast_create ( RE_AST * * re_ast ) { * re_ast = ( RE_AST * ) yr_malloc ( sizeof ( RE_AST ) ) ; if ( * re_ast == NULL ) return ERROR_INSUFFICIENT_MEMORY ; ( * re_ast ) -> levels = 0 ; ( * re_ast ) -> flags = 0 ; ( * re_ast ) -> root_node = NULL ; return ERROR_SUCCESS ; }
outputs:
match:0
source:
 static int er_supported ( ERContext * s ) { if ( s -> avctx -> hwaccel && s -> avctx -> hwaccel -> decode_slice || ! s -> cur_pic . f || <S2SV_StartBug> s -> cur_pic . field_picture || <S2SV_EndBug> s -> avctx -> profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO ) return 0 ; return 1 ; }

target:
static int er_supported ( ERContext * s ) { if ( s -> avctx -> hwaccel && s -> avctx -> hwaccel -> decode_slice || ! s -> cur_pic . f || s -> cur_pic . field_picture ) return 0 ; return 1 ; }
outputs:
match:0
source:
 void * gdImageGifPtr ( gdImagePtr im , int * size ) { void * rv ; gdIOCtx * out = gdNewDynamicCtx ( 2048 , NULL ) ; <S2SV_StartBug> gdImageGifCtx ( im , out ) ; <S2SV_EndBug> <S2SV_StartBug> rv = gdDPExtractData ( out , size ) ; <S2SV_EndBug> out -> gd_free ( out ) ; return rv ; }

target:
void * gdImageGifPtr ( gdImagePtr im , int * size ) { void * rv ; gdIOCtx * out = gdNewDynamicCtx ( 2048 , NULL ) ; if ( ! _gdImageGifCtx ( im , out ) ) { rv = gdDPExtractData ( out , size ) ; } else { rv = NULL ; } out -> gd_free ( out ) ; return rv ; }
outputs:
match:0
source:
 static void <S2SV_StartBug> l2tp_proxy_auth_id_print ( netdissect_options * ndo , const u_char * dat ) <S2SV_EndBug> { <S2SV_StartBug> const uint16_t * ptr = ( const uint16_t * ) dat ; <S2SV_EndBug> ND_PRINT ( ( ndo , "%u" , EXTRACT_16BITS ( ptr ) & L2TP_PROXY_AUTH_ID_MASK ) ) ; }

target:
static void l2tp_proxy_auth_id_print ( netdissect_options * ndo , const u_char * dat , u_int length ) { const uint16_t * ptr = ( const uint16_t * ) dat ; if ( length < 2 ) { ND_PRINT ( ( ndo , "AVPtooshort" ) ) ; return ; } ND_PRINT ( ( ndo , "%u" , EXTRACT_16BITS ( ptr ) & L2TP_PROXY_AUTH_ID_MASK ) ) ; }
outputs:
match:0
source:
 void vp8_vertical_band_2_1_scale_c ( unsigned char * source , unsigned int src_pitch , unsigned char * dest , unsigned int dest_pitch , unsigned int dest_width ) { ( void ) dest_pitch ; ( void ) src_pitch ; <S2SV_StartBug> vpx_memcpy ( dest , source , dest_width ) ; <S2SV_EndBug> }

target:
void vp8_vertical_band_2_1_scale_c ( unsigned char * source , unsigned int src_pitch , unsigned char * dest , unsigned int dest_pitch , unsigned int dest_width ) { ( void ) dest_pitch ; ( void ) src_pitch ; memcpy ( dest , source , dest_width ) ; }
outputs:
void vp8_vertical_band_2_1_scale_c (unsigned char * source, unsigned int src_pitch, unsigned char * dest, unsigned int dest_pitch, unsigned int dest_width) {
    (void) dest_pitch;
    (void) src_pitch;
    memcpy(dest, source, dest_width);
}
--------------------
void vp8_vertical_band_2_1_scale_c (unsigned char * source, unsigned int src_pitch, unsigned char * dest, unsigned int dest_pitch, unsigned int dest_width) {
    if (source == NULL || dest == NULL) {
        // handle null pointer error
        return;
    }
    (void) dest_pitch;
    (void) src_pitch;
    memcpy(dest, source, dest_width);
}
--------------------
void vp8_vertical_band_2_1_scale_c (unsigned char * source, unsigned int src_pitch, unsigned char * dest, unsigned int dest_pitch, unsigned int dest_width) {
    if (source == NULL || dest == NULL) {
        // handle null pointer error
        return;
    }
    (void) dest_pitch;
    (void) src_pitch;
    memmove(dest, source, dest_width);
}
--------------------
void vp8_vertical_band_2_1_scale_c (unsigned char * source, unsigned int src_pitch, unsigned char * dest, unsigned int dest_pitch, unsigned int dest_width) {
    if (source == NULL || dest == NULL) {
        // handle null pointer error
        return;
    }
    (void) dest_pitch;
    (void) src_pitch;
    if (dest_width > (dest_pitch * 256)) {
        // handle buffer overflow error
        return;
    }
    memmove(dest, source, dest_width);
}
--------------------
void vp8_vertical_band_2_1_scale_c (unsigned char * source, size_t src_pitch, unsigned char * dest, size_t dest_pitch, size_t dest_width) {
    if (source == NULL || dest == NULL) {
        // handle null pointer error
        return;
    }
    if (dest_width > (dest_pitch * 256)) {
        // handle buffer overflow error
        return;
    }
    memmove(dest, source, dest_width);
}
--------------------
void vp8_vertical_band_2_1_scale_c (unsigned char * restrict source, size_t src_pitch, unsigned char * restrict dest, size_t dest_pitch, size_t dest_width) {
    if (source == NULL || dest == NULL) {
        // handle null pointer error
        return;
    }
    if (dest_width > (dest_pitch * 256)) {
        // handle buffer overflow error
        return;
    }
    memmove(dest, source, dest_width);
}
--------------------
void vp8_vertical_band_2_1_scale_c (const unsigned char * restrict source, size_t src_pitch, unsigned char * restrict dest, size_t dest_pitch, size_t dest_width) {
    if (source == NULL || dest == NULL) {
        // handle null pointer error
        return;
    }
    if (dest_width > (dest_pitch * 256)) {
        // handle buffer overflow error
        return;
    }
    memmove(dest, source, dest_width);
}
--------------------
#ifdef __LP64__ // assuming 64-bit system uses 64-bit memory addressing
#define memmove_platform memmovel
#else
#define memmove_platform memmove
#endif

void vp8_vertical_band_2_1_scale_c (const unsigned char * restrict source, size_t src_pitch, unsigned char * restrict dest, size_t dest_pitch, size_t dest_width) {
    if (source == NULL || dest == NULL) {
        // handle null pointer error
        return;
    }
    if (dest_width > (dest_pitch * 256)) {
        // handle buffer overflow error
        return;
    }
    memmove_platform(dest, source, dest_width);
}
--------------------
void vp8_vertical_band_2_1_scale_c (const unsigned char * restrict source, size_t src_pitch, unsigned char * restrict dest, size_t dest_pitch, size_t dest_width) {
    if (source == NULL || dest == NULL) {
        // handle null pointer error
        return;
    }
    if (dest_width > (dest_pitch * 256)) {
        // handle buffer overflow error
        return;
    }
    unsigned char * restrict dest_end = dest + dest_width;
    for (; dest < dest_end; dest += dest_pitch) {
        *dest = *source;
        source += src_pitch;
    }
}
--------------------
#ifdef __SSE2__
#include <emmintrin.h>
#elif defined(__ARM_NEON__)
#include <arm_neon.h>
#endif

void vp8_vertical_band_2_1_scale_c (const unsigned char * restrict source, size_t src_pitch, unsigned char * restrict dest, size_t dest_pitch, size_t dest_width) {
    if (source == NULL || dest == NULL) {
        // handle null pointer error
        return;
    }
    if (dest_width > (dest_pitch * 256)) {
        // handle buffer overflow error
        return;
    }
    unsigned char * restrict dest_end = dest + dest_width;
#ifdef __SSE2__
    __m128i zero = _mm_setzero_si128();
    for (; dest < dest_end; dest += dest_pitch) {
        __m128i src = _mm_loadl_epi64((__m128i*)source);
        __m128i tmp = _mm_unpacklo_epi8(src, zero);
        __m128i res = _mm_shuffle_epi32(tmp, 0xd8);
        _mm_storel_epi64((__m128i*)dest, res);
        source += src_pitch;
    }
#elif defined(__ARM_NEON__)
    uint8x8_t zero = vdup_n_u8(0);
    for (; dest < dest_end; dest += dest_pitch) {
        uint8x8_t src = vld1_u8(source);
        uint8x8_t tmp = vzip1_u8(src, zero); // unzip low half, discarding high half
        uint8x8_t res = vrev64_u8(tmp); // reverse byte order
        vst1_u8(dest, res);
        source += src_pitch;
    }
#else
    for (; dest < dest_end; dest += dest_pitch) {
        *dest = *source;
        source += src_pitch;
    }
#endif
}
--------------------
match:1
source:
 long jpc_bitstream_getbits ( jpc_bitstream_t * bitstream , int n ) { long v ; int u ; <S2SV_StartBug> assert ( n >= 0 && n < 32 ) ; <S2SV_EndBug> v = 0 ; while ( -- n >= 0 ) { if ( ( u = jpc_bitstream_getbit ( bitstream ) ) < 0 ) { return - 1 ; } v = ( v << 1 ) | u ; } return v ; }

target:
long jpc_bitstream_getbits ( jpc_bitstream_t * bitstream , int n ) { long v ; int u ; if ( n < 0 || n >= 32 ) { return - 1 ; } v = 0 ; while ( -- n >= 0 ) { if ( ( u = jpc_bitstream_getbit ( bitstream ) ) < 0 ) { return - 1 ; } v = ( v << 1 ) | u ; } return v ; }
outputs:
match:0
source:
 <S2SV_StartBug> void vp9_iht8x8_add ( TX_TYPE tx_type , const int16_t * input , uint8_t * dest , <S2SV_EndBug> int stride , int eob ) { if ( tx_type == DCT_DCT ) { vp9_idct8x8_add ( input , dest , stride , eob ) ; } else { vp9_iht8x8_64_add ( input , dest , stride , tx_type ) ; } }

target:
void vp9_iht8x8_add ( TX_TYPE tx_type , const tran_low_t * input , uint8_t * dest , int stride , int eob ) { if ( tx_type == DCT_DCT ) { vp9_idct8x8_add ( input , dest , stride , eob ) ; } else { vp9_iht8x8_64_add ( input , dest , stride , tx_type ) ; } }
outputs:
void vp9_iht8x8_add(TX_TYPE tx_type, const int16_t *input, uint8_t *dest, int stride, int eob) {
    if (tx_type == DCT_DCT) {
        vp9_idct8x8_add(input, dest, stride, eob);
    } else {
        vp9_iht8x8_64_add(input, dest, stride, tx_type);
    }
}
--------------------
void vp9_iht8x8_add(TX_TYPE tx_type, const int16_t *input, uint8_t *dest, int stride, int eob) {
    if (tx_type == DCT_DCT) {
        vp9_idct8x8_add(input, dest, stride, eob);
    } else if (tx_type == ADST_DCT || tx_type == DCT_ADST || tx_type == ADST_ADST || tx_type == FLIPADST_DCT || tx_type == DCT_FLIPADST || tx_type == FLIPADST_FLIPADST || tx_type == FLIPADST_ADST || tx_type == ADST_FLIPADST) {
        vp9_iht8x8_64_add(input, dest, stride, tx_type);
    }
}
--------------------
void vp9_iht8x8_add(TX_TYPE tx_type, const int16_t *input, uint8_t *dest, int stride, int eob) {
    if (tx_type != DCT_DCT) {
        vp9_iht8x8_64_add(input, dest, stride, tx_type);
    } else {
        vp9_idct8x8_add(input, dest, stride, eob);
    }
}
--------------------
void vp9_iht8x8_add(TX_TYPE tx_type, const int16_t *input, uint8_t *dest, int stride, int eob) {
    if (tx_type < 0 || tx_type >= TX_TYPES) {
        // handle invalid tx_type value
        return;
    }
    if (tx_type == DCT_DCT) {
        vp9_idct8x8_add(input, dest, stride, eob);
    } else {
        vp9_iht8x8_64_add(input, dest, stride, tx_type);
    }
}
--------------------
void vp9_iht8x8_add(TX_TYPE tx_type, const int16_t *input, uint8_t *dest, int stride, int eob) {
    if (tx_type == DCT_DCT) {
        vp9_idct8x8_add(input, dest, stride, eob);
        return;
    }
    if (tx_type == ADST_DCT || tx_type == DCT_ADST || tx_type == ADST_ADST || tx_type == FLIPADST_DCT || tx_type == DCT_FLIPADST || tx_type == FLIPADST_FLIPADST || tx_type == FLIPADST_ADST || tx_type == ADST_FLIPADST) {
        vp9_iht8x8_64_add(input, dest, stride, tx_type);
    }
}
--------------------
void vp9_iht8x8_add(TX_TYPE tx_type, const int16_t *input, uint8_t *dest, int stride, int eob) {
    if (tx_type == DCT_DCT) {
        vp9_idct8x8_add(input, dest, stride, eob);
    } else {
        if (tx_type < ADST_DCT || tx_type > ADST_FLIPADST) {
            // handle invalid tx_type value
            return;
        }
        vp9_iht8x8_64_add(input, dest, stride, tx_type);
    }
}
--------------------
void vp9_iht8x8_add(TX_TYPE tx_type, const int16_t *input, uint8_t *dest, int stride, int eob) {
    if (tx_type == DCT_DCT) {
        vp9_idct8x8_add(input, dest, stride, eob);
    } else {
        if (tx_type <= DCT_DCT || tx_type >= TX_TYPES) {
            // handle invalid tx_type value
            return;
        }
        vp9_iht8x8_64_add(input, dest, stride, tx_type);
    }
}
--------------------
void vp9_iht8x8_add(TX_TYPE tx_type, const int16_t *input, uint8_t *dest, int stride, int eob) {
    if (tx_type == DCT_DCT) {
        vp9_idct8x8_add(input, dest, stride, eob);
    } else {
        switch (tx_type) {
            case ADST_DCT:
            case DCT_ADST:
            case ADST_ADST:
            case FLIPADST_DCT:
            case DCT_FLIPADST:
            case FLIPADST_FLIPADST:
            case FLIPADST_ADST:
            case ADST_FLIPADST:
                vp9_iht8x8_64_add(input, dest, stride, tx_type);
                break;
            default:
                // handle invalid tx_type value
                return;
        }
    }
}
--------------------
void vp9_iht8x8_add(TX_TYPE tx_type, const int16_t *input, uint8_t *dest, int stride, int eob) {
    if (tx_type == DCT_DCT) {
        vp9_idct8x8_add(input, dest, stride, eob);
        return;
    }
    if (tx_type == ADST_DCT) {
        vp9_iht_adst8x8_add(input, dest, stride);
        vp9_idct8x8_add(input + 64, dest + 8 * stride, stride, eob - 64);
    } else if (tx_type == DCT_ADST) {
        vp9_idct8x8_add(input, dest, stride, 4);
        vp9_iht_adst8x8_add(input + 4, dest + 4, stride);
        vp9_idct8x8_add(input + 64, dest + 4 * stride, stride, eob - 64);
    }
    // handle other cases similarly
}
--------------------
void vp9_iht8x8_add(TX_TYPE tx_type, const int16_t *input, uint8_t *dest, int stride, int eob) {
    if (tx_type == DCT_DCT) {
        vp9_idct8x8_add(input, dest, stride, eob);
        return;
    }
    if (tx_type == ADST_DCT) {
        vp9_iht_adst8x8_add(input, dest, stride);
        vp9_idct8x8_add(input + 64, dest + 8 * stride, stride, eob - 64);
    } else if (tx_type == DCT_ADST) {
        vp9_idct8x8_add(input, dest, stride, 4);
        vp9_iht_adst8x8_add(input + 4, dest + 4, stride);
        vp9_idct8x8_add(input + 64, dest + 4 * stride, stride, eob - 64);
    } else {
        vp9_iht8x8_64_add(input, dest, stride, tx_type);
    }
}
--------------------
match:0
source:
 static int xfrm_dump_policy_done ( struct netlink_callback * cb ) { <S2SV_StartBug> struct xfrm_policy_walk * walk = ( struct xfrm_policy_walk * ) & cb -> args [ 1 ] ; <S2SV_EndBug> struct net * net = sock_net ( cb -> skb -> sk ) ; xfrm_policy_walk_done ( walk , net ) ; return 0 ; }

target:
static int xfrm_dump_policy_done ( struct netlink_callback * cb ) { struct xfrm_policy_walk * walk = ( struct xfrm_policy_walk * ) cb -> args [ 1 ] ; struct net * net = sock_net ( cb -> skb -> sk ) ; xfrm_policy_walk_done ( walk , net ) ; return 0 ; }
outputs:
/**
 * xfrm_dump_policy_done - callback function to handle the completion of an xfrm policy walk
 * @cb: the netlink callback structure
 *
 * Return: always 0
 */
static int xfrm_dump_policy_done(struct netlink_callback *cb)
{
	struct xfrm_policy_walk walk;
	struct net *net;

	if (!cb || !cb->skb) {
		return -EINVAL;
	}

	walk = *(struct xfrm_policy_walk *)&cb->args[1];
	if (!walk.in_done || !walk.out_done) {
		return -EINVAL;
	}

	net = sock_net(cb->skb->sk);
	if (!net) {
		return -EINVAL;
	}

	if (xfrm_policy_walk_done(&walk, net) < 0) {
		printk(KERN_ERR "xfrm_dump_policy_done: Failed to finish xfrm policy walk\n");
	}

	return 0;
}
--------------------
match:0
source:
 static vpx_codec_err_t update_error_state ( vpx_codec_alg_priv_t * ctx , const struct vpx_internal_error_info * error ) { if ( error -> error_code ) <S2SV_StartBug> ctx -> base . err_detail = error -> has_detail ? error -> detail : NULL ; <S2SV_EndBug> return error -> error_code ; }

target:
static vpx_codec_err_t update_error_state ( vpx_codec_alg_priv_t * ctx , const struct vpx_internal_error_info * error ) { if ( error -> error_code ) set_error_detail ( ctx , error -> has_detail ? error -> detail : NULL ) ; return error -> error_code ; }
outputs:
static vpx_codec_err_t update_error_state(vpx_codec_alg_priv_t* ctx, const struct vpx_internal_error_info* error) {
  if (error->error_code) {
    if (error->has_detail) {
      strncpy(ctx->base.err_detail, error->detail, sizeof(ctx->base.err_detail) - 1);
      ctx->base.err_detail[sizeof(ctx->base.err_detail) - 1] = '\0';
    } else {
      ctx->base.err_detail[0] = '\0';
    }
  }
  return (error->error_code == VPX_CODEC_OK) ? VPX_CODEC_ERROR : error->error_code;
}
--------------------
static vpx_codec_err_t update_error_state(vpx_codec_alg_priv_t* ctx, const struct vpx_internal_error_info* error) {
  if (error->error_code && error->has_detail) {
    strncpy(ctx->base.err_detail, error->detail, sizeof(ctx->base.err_detail) - 1);
    ctx->base.err_detail[sizeof(ctx->base.err_detail) - 1] = '\0';
  } else {
    ctx->base.err_detail[0] = '\0';
  }
  return error->error_code;
}
--------------------
static vpx_codec_err_t update_error_state(vpx_codec_alg_priv_t* ctx, const struct vpx_internal_error_info* error) {
  if (error && error->error_code) {
    if (error->has_detail) {
      strncpy(ctx->base.err_detail, error->detail, sizeof(ctx->base.err_detail) - 1);
      ctx->base.err_detail[sizeof(ctx->base.err_detail) - 1] = '\0';
    } else {
      ctx->base.err_detail[0] = '\0';
    }
    return error->error_code;
  }
  return VPX_CODEC_OK;
}
--------------------
static vpx_codec_err_t update_error_state(vpx_codec_alg_priv_t* ctx, const struct vpx_internal_error_info* error) {
  if (error && error->error_code) {
    if (error->has_detail) {
      strncpy(ctx->base.err_detail, error->detail, sizeof(ctx->base.err_detail) - 1);
      ctx->base.err_detail[sizeof(ctx->base.err_detail) - 1] = '\0';
    } else {
      ctx->base.err_detail[0] = '\0';
    }
  } else {
    ctx->base.err_detail[0] = '\0';
  }
  return error ? error->error_code : VPX_CODEC_OK;
}
--------------------
static vpx_codec_err_t update_error_state(vpx_codec_alg_priv_t* ctx, const struct vpx_internal_error_info* error) {
  if (error && error->error_code) {
    if (error->has_detail && 
        strlen(error->detail) <= sizeof(ctx->base.err_detail) - 1) {
      strcpy(ctx->base.err_detail, error->detail);
    } else {
      ctx->base.err_detail[0] = '\0';
    }
    return error->error_code;
  }
  return VPX_CODEC_OK;
}
--------------------
static vpx_codec_err_t update_error_state(vpx_codec_alg_priv_t* ctx, const struct vpx_internal_error_info* error) {
  if (error && error->error_code) {
    if (error->has_detail) {
      snprintf(ctx->base.err_detail, sizeof(ctx->base.err_detail), "%s", error->detail);
    } else {
      ctx->base.err_detail[0] = '\0';
    }
  } else {
    ctx->base.err_detail[0] = '\0';
  }
  return error ? error->error_code : VPX_CODEC_OK;
}
--------------------
static vpx_codec_err_t update_error_state(vpx_codec_alg_priv_t* ctx, const struct vpx_internal_error_info* error) {
  if (error && error->error_code) {
    if (error->has_detail && error->detail) {
      strncpy(ctx->base.err_detail, error->detail, sizeof(ctx->base.err_detail) - 1);
      ctx->base.err_detail[sizeof(ctx->base.err_detail) - 1] = '\0';
    } else {
      ctx->base.err_detail[0] = '\0';
    }
  } else {
    ctx->base.err_detail[0] = '\0';
  }
  return error ? error->error_code : VPX_CODEC_OK;
}
--------------------
static vpx_codec_err_t update_error_state(vpx_codec_alg_priv_t* ctx, const struct vpx_internal_error_info* error) {
  if (error && error->error_code) {
    if (error->has_detail) {
      strncpy_s(ctx->base.err_detail, sizeof(ctx->base.err_detail), error->detail, _TRUNCATE);
    } else {
      ctx->base.err_detail[0] = '\0';
    }
  } else {
    ctx->base.err_detail[0] = '\0';
  }
  return error ? error->error_code : VPX_CODEC_OK;
}
--------------------
static vpx_codec_err_t update_error_state(vpx_codec_alg_priv_t* ctx, const struct vpx_internal_error_info* error) {
  if (error && error->error_code) {
    if (error->has_detail && error->detail) {
      strncpy(ctx->base.err_detail, error->detail, sizeof(ctx->base.err_detail) - 1);
      ctx->base.err_detail[sizeof(ctx->base.err_detail) - 1] = '\0';
    } else {
      ctx->base.err_detail[0] = '\0';
    }
  } else {
    ctx->base.err_detail[0] = '\0';
  }
  return (error && error->error_code == VPX_CODEC_OK) ? VPX_CODEC_ERROR : error->error_code;
}
--------------------
static vpx_codec_err_t update_error_state(vpx_codec_alg_priv_t* ctx, const struct vpx_internal_error_info* error) {
  if (error && error->error_code) {
    if (error->has_detail) {
      strncpy(ctx->base.err_detail, error->detail, sizeof(ctx->base.err_detail) - 1);
      ctx->base.err_detail[sizeof(ctx->base.err_detail) - 1] = '\0';
    } else {
      ctx->base.err_detail[0] = '\0';
    }
  } else {
    ctx->base.err_detail[0] = '\0';
  }
  return (error && error->error_code != VPX_CODEC_OK) ? error->error_code : VPX_CODEC_ERROR;
}
--------------------
match:0
