static void skcipher_release ( void * private ) { struct skcipher_tfm * tfm = private ; crypto_free_skcipher ( tfm -> skcipher ) ; kfree ( tfm ) ; }
void _modinit ( module_t * m ) { service_named_bind_command ( "chanserv" , & cs_flags ) ; add_bool_conf_item ( "ANOPE_FLAGS_COMPAT" , & chansvs . me -> conf_table , 0 , & anope_flags_compat , true ) ; hook_add_event ( "nick_can_register" ) ; hook_add_nick_can_register ( check_registration_keywords ) ; hook_add_event ( "user_can_register" ) ; hook_add_user_can_register ( check_registration_keywords ) ; }
void * H264SwDecMalloc ( u32 size , u32 num ) { if ( size > UINT32_MAX / num ) { return NULL ; } return malloc ( size * num ) ; }
static void ast_dealloc ( AST_object * self ) { PyObject_GC_UnTrack ( self ) ; Py_CLEAR ( self -> dict ) ; Py_TYPE ( self ) -> tp_free ( self ) ; }
static void mark_commit ( struct commit * c , void * data ) { mark_object ( & c -> object , NULL , data ) ; }
static int sock_close ( struct inode * inode , struct file * filp ) { __sock_release ( SOCKET_I ( inode ) , inode ) ; return 0 ; }
int pure_strcmp ( const char * const s1 , const char * const s2 ) { const size_t s1_len = strlen ( s1 ) ; const size_t s2_len = strlen ( s2 ) ; const size_t len = ( s1_len < s2_len ) ? s1_len : s2_len ; return pure_memcmp ( s1 , s2 , len + 1 ) ; }
static char * print_string ( cJSON * item , printbuffer * p ) { return print_string_ptr ( item -> valuestring , p ) ; }
static inline int mount_entry_on_systemfs ( struct mntent * mntent ) { return mount_entry_on_generic ( mntent , mntent -> mnt_dir , NULL ) ; }
static vpx_codec_err_t encoder_init ( vpx_codec_ctx_t * ctx , vpx_codec_priv_enc_mr_cfg_t * data ) { vpx_codec_err_t res = VPX_CODEC_OK ; ( void ) data ; if ( ctx -> priv == NULL ) { vpx_codec_alg_priv_t * const priv = vpx_calloc ( 1 , sizeof ( * priv ) ) ; if ( priv == NULL ) return VPX_CODEC_MEM_ERROR ; ctx -> priv = ( vpx_codec_priv_t * ) priv ; ctx -> priv -> init_flags = ctx -> init_flags ; ctx -> priv -> enc . total_encoders = 1 ; priv -> buffer_pool = ( BufferPool * ) vpx_calloc ( 1 , sizeof ( BufferPool ) ) ; if ( priv -> buffer_pool == NULL ) return VPX_CODEC_MEM_ERROR ; # if CONFIG_MULTITHREAD if ( pthread_mutex_init ( & priv -> buffer_pool -> pool_mutex , NULL ) ) { return VPX_CODEC_MEM_ERROR ; } # endif if ( ctx -> config . enc ) { priv -> cfg = * ctx -> config . enc ; ctx -> config . enc = & priv -> cfg ; } priv -> extra_cfg = default_extra_cfg ; once ( vp9_initialize_enc ) ; res = validate_config ( priv , & priv -> cfg , & priv -> extra_cfg ) ; if ( res == VPX_CODEC_OK ) { set_encoder_config ( & priv -> oxcf , & priv -> cfg , & priv -> extra_cfg ) ; # if CONFIG_VP9_HIGHBITDEPTH priv -> oxcf . use_highbitdepth = ( ctx -> init_flags & VPX_CODEC_USE_HIGHBITDEPTH ) ? 1 : 0 ; # endif priv -> cpi = vp9_create_compressor ( & priv -> oxcf , priv -> buffer_pool ) ; if ( priv -> cpi == NULL ) res = VPX_CODEC_MEM_ERROR ; else priv -> cpi -> output_pkt_list = & priv -> pkt_list . head ; } } return res ; }
static int hns_xgmac_get_sset_count ( int stringset ) { if ( stringset == ETH_SS_STATS || stringset == ETH_SS_PRIV_FLAGS ) return ARRAY_SIZE ( g_xgmac_stats_string ) ; return 0 ; }
void recovery_delete_character ( void ) { if ( ! recovery_started ) { recovery_abort ( ) ; fsm_sendFailure ( FailureType_Failure_UnexpectedMessage , "NotinRecoverymode" ) ; layoutHome ( ) ; return ; } if ( strlen ( mnemonic ) > 0 ) { mnemonic [ strlen ( mnemonic ) - 1 ] = '\\0' ; } next_character ( ) ; }
bool generic_pipe_buf_get ( struct pipe_inode_info * pipe , struct pipe_buffer * buf ) { return try_get_page ( buf -> page ) ; }
static char * pool_strdup ( const char * s ) { size_t len = strlen ( s ) + 1 ; char * r = pool_alloc ( len ) ; memcpy ( r , s , len ) ; return r ; }
static void * skcipher_bind ( const char * name , u32 type , u32 mask ) { struct skcipher_tfm * tfm ; struct crypto_skcipher * skcipher ; tfm = kzalloc ( sizeof ( * tfm ) , GFP_KERNEL ) ; if ( ! tfm ) return ERR_PTR ( - ENOMEM ) ; skcipher = crypto_alloc_skcipher ( name , type , mask ) ; if ( IS_ERR ( skcipher ) ) { kfree ( tfm ) ; return ERR_CAST ( skcipher ) ; } tfm -> skcipher = skcipher ; return tfm ; }
void vp9_frame_init_quantizer ( VP9_COMP * cpi ) { vp9_init_plane_quantizers ( cpi , & cpi -> td . mb ) ; }
static void ieee80211_if_setup ( struct net_device * dev ) { ether_setup ( dev ) ; dev -> priv_flags &= ~ IFF_TX_SKB_SHARING ; dev -> netdev_ops = & ieee80211_dataif_ops ; dev -> destructor = free_netdev ; }
int X509_verify ( X509 * a , EVP_PKEY * r ) { if ( X509_ALGOR_cmp ( a -> sig_alg , a -> cert_info -> signature ) ) return 0 ; return ( ASN1_item_verify ( ASN1_ITEM_rptr ( X509_CINF ) , a -> sig_alg , a -> signature , a -> cert_info , r ) ) ; }
static int remove_bond ( const bt_bdaddr_t * bd_addr ) { if ( is_restricted_mode ( ) && ! btif_storage_is_restricted_device ( bd_addr ) ) return BT_STATUS_SUCCESS ; if ( interface_ready ( ) == FALSE ) return BT_STATUS_NOT_READY ; return btif_dm_remove_bond ( bd_addr ) ; }
static int snd_seq_device_dev_free ( struct snd_device * device ) { struct snd_seq_device * dev = device -> device_data ; cancel_autoload_drivers ( ) ; put_device ( & dev -> dev ) ; return 0 ; }
void test_checkout_nasty__git_tilde1 ( void ) { test_checkout_fails ( "refs/heads/git_tilde1" , ".git/foobar" ) ; test_checkout_fails ( "refs/heads/git_tilde1" , "git~1/foobar" ) ; }
static int jas_iccgetuint32 ( jas_stream_t * in , jas_iccuint32_t * val ) { jas_ulonglong tmp ; if ( jas_iccgetuint ( in , 4 , & tmp ) ) return - 1 ; * val = tmp ; return 0 ; }
void close_uinput ( void ) { BTIF_TRACE_DEBUG ( "%s" , __FUNCTION__ ) ; if ( uinput_fd > 0 ) { TEMP_FAILURE_RETRY ( ioctl ( uinput_fd , UI_DEV_DESTROY ) ) ; close ( uinput_fd ) ; uinput_fd = - 1 ; } }
static int check_line_charstring ( void ) { char * p = line ; while ( isspace ( ( unsigned char ) * p ) ) p ++ ; return ( * p == '/' || ( p [ 0 ] == 'd' && p [ 1 ] == 'u' && p [ 2 ] == 'p' ) ) ; }
static int read_segment_id ( vpx_reader * r , const struct segmentation * seg ) { return vpx_read_tree ( r , vp9_segment_tree , seg -> tree_probs ) ; }
void * xcalloc ( size_t num , size_t size ) { size_t res ; if ( check_mul_overflow ( num , size , & res ) ) abort ( ) ; void * ptr ; ptr = malloc ( res ) ; if ( ptr ) { memset ( ptr , '\\0' , ( res ) ) ; } return ptr ; }
static vpx_codec_err_t ctrl_set_invert_tile_order ( vpx_codec_alg_priv_t * ctx , va_list args ) { ctx -> invert_tile_order = va_arg ( args , int ) ; return VPX_CODEC_OK ; }
static struct o2nm_cluster * to_o2nm_cluster_from_node ( struct o2nm_node * node ) { if ( node -> nd_item . ci_parent ) return to_o2nm_cluster ( node -> nd_item . ci_parent -> ci_parent ) ; else return NULL ; }
cJSON * cJSON_GetObjectItem ( cJSON * object , const char * string ) { cJSON * c = object ? object -> child : 0 ; while ( c && cJSON_strcasecmp ( c -> string , string ) ) c = c -> next ; return c ; }
void * sspi_SecureHandleGetUpperPointer ( SecHandle * handle ) { void * pointer ; if ( ! handle || ! SecIsValidHandle ( handle ) ) return NULL ; pointer = ( void * ) ~ ( ( size_t ) handle -> dwUpper ) ; return pointer ; }
static inline size_t GetPSDRowSize ( Image * image ) { if ( image -> depth == 1 ) return ( ( ( image -> columns + 7 ) / 8 ) * GetPSDPacketSize ( image ) ) ; else return ( image -> columns * GetPSDPacketSize ( image ) ) ; }
void vp9_tree_probs_from_distribution ( vpx_tree tree , unsigned int branch_ct [ ] [ 2 ] , const unsigned int num_events [ ] ) { convert_distribution ( 0 , tree , branch_ct , num_events ) ; }
int scsi_cmd_blk_ioctl ( struct block_device * bd , fmode_t mode , unsigned int cmd , void __user * arg ) { int ret ; ret = scsi_verify_blk_ioctl ( bd , cmd ) ; if ( ret < 0 ) return ret ; return scsi_cmd_ioctl ( bd -> bd_disk -> queue , bd -> bd_disk , mode , cmd , arg ) ; }
void free_bprm ( struct linux_binprm * bprm ) { free_arg_pages ( bprm ) ; if ( bprm -> cred ) { mutex_unlock ( & current -> signal -> cred_guard_mutex ) ; abort_creds ( bprm -> cred ) ; } if ( bprm -> interp != bprm -> filename ) kfree ( bprm -> interp ) ; kfree ( bprm ) ; }
static void put_prev_task ( struct rq * rq , struct task_struct * prev ) { if ( prev -> se . on_rq ) update_rq_clock ( rq ) ; prev -> sched_class -> put_prev_task ( rq , prev ) ; }
static void ntlm_populate_message_header ( NTLM_MESSAGE_HEADER * header , UINT32 MessageType ) { CopyMemory ( header -> Signature , NTLM_SIGNATURE , sizeof ( NTLM_SIGNATURE ) ) ; header -> MessageType = MessageType ; }
static void pcrypt_free ( struct aead_instance * inst ) { struct pcrypt_instance_ctx * ctx = aead_instance_ctx ( inst ) ; crypto_drop_aead ( & ctx -> spawn ) ; kfree ( inst ) ; }
cJSON * cJSON_GetArrayItem ( cJSON * array , int item ) { cJSON * c = array ? array -> child : 0 ; while ( c && item > 0 ) item -- , c = c -> next ; } return c ; }
static int decode_unsigned_max ( struct vpx_read_bit_buffer * rb , int max ) { const int data = vpx_rb_read_literal ( rb , get_unsigned_bits ( max ) ) ; return data > max ? max : data ; }
void __scm_destroy ( struct scm_cookie * scm ) { struct scm_fp_list * fpl = scm -> fp ; int i ; if ( fpl ) { scm -> fp = NULL ; for ( i = fpl -> count - 1 ; i >= 0 ; i -- ) fput ( fpl -> fp [ i ] ) ; free_uid ( fpl -> user ) ; kfree ( fpl ) ; } }
static unsigned int seedsize ( struct crypto_alg * alg ) { struct rng_alg * ralg = container_of ( alg , struct rng_alg , base ) ; return ralg -> seedsize ; }
static void write_intra_mode ( vpx_writer * w , MB_PREDICTION_MODE mode , const vpx_prob * probs ) { vp9_write_token ( w , vp9_intra_mode_tree , probs , & intra_mode_encodings [ mode ] ) ; }
struct bpf_map * bpf_map_get_with_uref ( u32 ufd ) { struct fd f = fdget ( ufd ) ; struct bpf_map * map ; map = __bpf_map_get ( f ) ; if ( IS_ERR ( map ) ) return map ; map = bpf_map_inc ( map , true ) ; fdput ( f ) ; return map ; }
static int amd_gpio_remove ( struct platform_device * pdev ) { struct amd_gpio * gpio_dev ; gpio_dev = platform_get_drvdata ( pdev ) ; gpiochip_remove ( & gpio_dev -> gc ) ; return 0 ; }
static int jas_iccputuint ( jas_stream_t * out , int n , jas_ulonglong val ) { int i ; int c ; for ( i = n ; i > 0 ; -- i ) { c = ( val >> ( 8 * ( i - 1 ) ) ) & 0xff ; if ( jas_stream_putc ( out , c ) == EOF ) return - 1 ; } return 0 ; }
void vp9_cost_tokens_skip ( int * costs , const vpx_prob * probs , vp9_tree tree ) { assert ( tree [ 0 ] <= 0 && tree [ 1 ] > 0 ) ; costs [ - tree [ 0 ] ] = vp9_cost_bit ( probs [ 0 ] , 0 ) ; cost ( costs , tree , probs , 2 , 0 ) ; }
static TX_MODE read_tx_mode ( vpx_reader * r ) { TX_MODE tx_mode = vpx_read_literal ( r , 2 ) ; if ( tx_mode == ALLOW_32X32 ) tx_mode += vpx_read_bit ( r ) ; return tx_mode ; }
static int linear_ioctl ( struct dm_target * ti , unsigned int cmd , unsigned long arg ) { struct linear_c * lc = ( struct linear_c * ) ti -> private ; struct dm_dev * dev = lc -> dev ; int r = 0 ; if ( lc -> start || ti -> len != i_size_read ( dev -> bdev -> bd_inode ) >> SECTOR_SHIFT ) r = scsi_verify_blk_ioctl ( NULL , cmd ) ; return r ? : __blkdev_driver_ioctl ( dev -> bdev , dev -> mode , cmd , arg ) ; }
static bool buffer_pipe_buf_get ( struct pipe_inode_info * pipe , struct pipe_buffer * buf ) { struct buffer_ref * ref = ( struct buffer_ref * ) buf -> private ; if ( ref -> ref > INT_MAX / 2 ) return false ; ref -> ref ++ ; return true ; }
static inline int btif_hl_select_close_connected ( void ) { char sig_on = btif_hl_signal_select_close_connected ; BTIF_TRACE_DEBUG ( "btif_hl_select_close_connected" ) ; return TEMP_FAILURE_RETRY ( send ( signal_fds [ 1 ] , & sig_on , sizeof ( sig_on ) , 0 ) ) ; }
static void ntlm_free_message_fields_buffer ( NTLM_MESSAGE_FIELDS * fields ) { if ( fields ) { if ( fields -> Buffer ) { free ( fields -> Buffer ) ; fields -> Len = 0 ; fields -> MaxLen = 0 ; fields -> Buffer = NULL ; fields -> BufferOffset = 0 ; } } }
void vp9_lookahead_destroy ( struct lookahead_ctx * ctx ) { if ( ctx ) { if ( ctx -> buf ) { unsigned int i ; for ( i = 0 ; i < ctx -> max_sz ; i ++ ) vpx_free_frame_buffer ( & ctx -> buf [ i ] . img ) ; free ( ctx -> buf ) ; } free ( ctx ) ; } }
mod_ty Module ( asdl_seq * body , asdl_seq * type_ignores , PyArena * arena ) { mod_ty p ; p = ( mod_ty ) PyArena_Malloc ( arena , sizeof ( * p ) ) ; if ( ! p ) return NULL ; p -> kind = Module_kind ; p -> v . Module . body = body ; p -> v . Module . type_ignores = type_ignores ; return p ; }
int yr_re_ast_create ( RE_AST * * re_ast ) { * re_ast = ( RE_AST * ) yr_malloc ( sizeof ( RE_AST ) ) ; if ( * re_ast == NULL ) return ERROR_INSUFFICIENT_MEMORY ; ( * re_ast ) -> levels = 0 ; ( * re_ast ) -> flags = 0 ; ( * re_ast ) -> root_node = NULL ; return ERROR_SUCCESS ; }
static int er_supported ( ERContext * s ) { if ( s -> avctx -> hwaccel && s -> avctx -> hwaccel -> decode_slice || ! s -> cur_pic . f || s -> cur_pic . field_picture ) return 0 ; return 1 ; }
void * gdImageGifPtr ( gdImagePtr im , int * size ) { void * rv ; gdIOCtx * out = gdNewDynamicCtx ( 2048 , NULL ) ; if ( ! _gdImageGifCtx ( im , out ) ) { rv = gdDPExtractData ( out , size ) ; } else { rv = NULL ; } out -> gd_free ( out ) ; return rv ; }
static void l2tp_proxy_auth_id_print ( netdissect_options * ndo , const u_char * dat , u_int length ) { const uint16_t * ptr = ( const uint16_t * ) dat ; if ( length < 2 ) { ND_PRINT ( ( ndo , "AVPtooshort" ) ) ; return ; } ND_PRINT ( ( ndo , "%u" , EXTRACT_16BITS ( ptr ) & L2TP_PROXY_AUTH_ID_MASK ) ) ; }
long jpc_bitstream_getbits ( jpc_bitstream_t * bitstream , int n ) { long v ; int u ; if ( n < 0 || n >= 32 ) { return - 1 ; } v = 0 ; while ( -- n >= 0 ) { if ( ( u = jpc_bitstream_getbit ( bitstream ) ) < 0 ) { return - 1 ; } v = ( v << 1 ) | u ; } return v ; }