,source,match,tokenlen
0,"bool initiate_stratum ( struct pool * pool ) { bool ret = false , recvd = false , noresume = false , sockd = false ; char s [ RBUFSIZE ] , * sret = NULL , * nonce1 , * sessionid ; json_t * val = NULL , * res_val , * err_val ; json_error_t err ; int n2size ; resend : if ( ! setup_stratum_socket ( pool ) ) { sockd = false ; goto out ; } sockd = true ; if ( n2size < 1 ) { applog ( LOG_DEBUG , ""Failedtosendsininitiate_stratum"" ) ; goto out ; } if ( ! socket_full ( pool , DEFAULT_SOCKWAIT ) ) { applog ( LOG_DEBUG , ""Timedoutwaitingforresponseinininitiate_stratum"" ) ; goto out ; } sret = recv_line ( pool ) ; if ( ! sret ) goto out ; recvd = true ; val = JSON_LOADS ( sret , & err ) ; free ( sret ) ; if ( ! val ) { applog ( LOG_INFO , ""JSONdecodefailed(%d):%s"" , err . line , err . text ) ; goto out ; } res_val = json_object_get ( val , ""result"" ) ; err_val = json_object_get ( val , ""error"" ) ; if ( ! res_val || json_is_null ( res_val ) || ( err_val && ! json_is_null ( err_val ) ) ) { char * ss ; if ( err_val ) ss = json_dumps ( err_val , JSON_INDENT ( 3 ) ) ; else ss = strdup ( ""(unknownreason)"" ) ; applog ( LOG_INFO , ""JSON-RPCdecodefailed:%s"" , ss ) ; free ( ss ) ; goto out ; } sessionid = get_sessionid ( res_val ) ; if ( n2size < 1 ) { applog ( LOG_DEBUG , ""Failedtosendsininitiate_stratum"" ) ; goto out ; } n2size = json_integer_value ( json_array_get ( res_val , 1 ) ) ; if (
",0,511
1,"void eap_print ( netdissect_options * ndo , register const u_char * cp , u_int length ) { const struct eap_frame_t * eap ; const u_char * tptr ; u_int tlen , type , subtype ; int count = 0 , len ; tptr = cp ; tlen = length ; eap = ( const struct eap_frame_t * ) cp ; ND_TCHECK ( * eap ) ; if ( ndo -> ndo_vflag < 1 ) { ND_PRINT ( ( ndo , ""%s(%u)v%u,len%u"" , tok2str ( eap_frame_type_values , ""unknown"" , subtype ) , subtype ) ) ; return ; } ND_PRINT ( ( ndo , ""%s(%u)v%u,len%u"" , tok2str ( eap_frame_type_values , ""unknown"" , eap -> type ) , eap -> type , eap -> version , EXTRACT_16BITS ( eap -> length ) ) ) ; ND_PRINT ( ( ndo , ""%s(%u)v%u,len%u"" , tok2str ( eap_frame_type_values , ""unknown"" , eap -> type ) , eap -> type , eap -> version , EXTRACT_16BITS ( eap -> length ) ) ) ; tptr += sizeof ( const struct eap_frame_t ) ; tlen -= sizeof ( const struct eap_frame_t ) ; switch ( eap -> type ) { case EAP_FRAME_TYPE_PACKET : type = * ( tptr ) ; len = EXTRACT_16BITS ( tptr + 2 ) ; ND_PRINT ( ( ndo , "",%s(%u),id%u,len%u"" , tok2str ( eap_code_values , ""unknown"" , type ) , type , * ( tptr + 1 ) , len ) ) ; ND_TCHECK2 ( * tptr , len ) ; if ( type <= 2 ) { ND_TCHECK_8BITS ( tptr + 4 ) ; subtype = * ( tptr + 4 ) ; ND_PRINT ( ( ndo , ""\\n
",0,511
2,"int ath9k_wmi_cmd ( struct wmi * wmi , enum wmi_cmd_id cmd_id , u8 * cmd_buf , u32 cmd_len , u8 * rsp_buf , u32 rsp_len , u32 timeout ) { struct ath_hw * ah = wmi -> drv_priv -> ah ; struct ath_common * common = ath9k_hw_common ( ah ) ; u16 headroom = sizeof ( struct htc_frame_hdr ) + sizeof ( struct wmi_cmd_hdr ) ; struct sk_buff * skb ; unsigned long time_left ; int ret = 0 ; if ( ah -> ah_flags & AH_UNPLUGGED ) return 0 ; skb = alloc_skb ( headroom + cmd_len , GFP_ATOMIC ) ; if ( ! skb ) return - ENOMEM ; skb_reserve ( skb , headroom ) ; if ( cmd_len != 0 && cmd_buf != NULL ) { skb_put_data ( skb , cmd_buf , cmd_len ) ; } mutex_lock ( & wmi -> op_mutex ) ; if ( unlikely ( wmi -> stopped ) ) { ret = - EPROTO ; goto out ; } wmi -> cmd_rsp_buf = rsp_buf ; wmi -> cmd_rsp_len = rsp_len ; ret = ath9k_wmi_cmd_issue ( wmi , skb , cmd_id , cmd_len ) ; if ( ret ) goto out ; time_left = wait_for_completion_timeout ( & wmi -> cmd_wait , timeout ) ; if ( ! time_left ) { ath_dbg ( common , WMI , ""TimeoutwaitingforWMIcommand:%s\\n"" , wmi_cmd_to_name ( cmd_id ) ) ; mutex_unlock ( & wmi -> op_mutex ) ; ret = - ETIMEDOUT ; goto out ; } mutex_unlock ( & wmi -> op_mutex ) ; return 0 ; out : ath_dbg ( common , WMI , ""WMIfailurefor:%s\\n"" , wmi_cmd_to_name ( cmd_id ) ) ; mutex_
",0,511
3,"static int yam_ioctl ( struct net_device * dev , struct ifreq * ifr , int cmd ) { struct yam_port * yp = netdev_priv ( dev ) ; struct yamdrv_ioctl_cfg yi ; struct yamdrv_ioctl_mcs * ym ; int ioctl_cmd ; if ( copy_from_user ( & ioctl_cmd , ifr -> ifr_data , sizeof ( int ) ) ) return - EFAULT ; if ( yp -> magic != YAM_MAGIC ) return - EINVAL ; if ( ! capable ( CAP_NET_ADMIN ) ) return - EPERM ; if ( cmd != SIOCDEVPRIVATE ) return - EINVAL ; switch ( ioctl_cmd ) { case SIOCYAMRESERVED : return - EINVAL ; case SIOCYAMSMCS : if ( netif_running ( dev ) ) return - EINVAL ; if ( ( ym = kmalloc ( sizeof ( struct yamdrv_ioctl_mcs ) , GFP_KERNEL ) ) == NULL ) return - ENOBUFS ; if ( copy_from_user ( ym , ifr -> ifr_data , sizeof ( struct yamdrv_ioctl_mcs ) ) ) { kfree ( ym ) ; return - EFAULT ; } if ( ym -> bitrate > YAM_MAXBITRATE ) { kfree ( ym ) ; return - EINVAL ; } add_mcs ( ym -> bits , ym -> bitrate , 0 ) ; kfree ( ym ) ; break ; case SIOCYAMSCFG : if ( ! capable ( CAP_SYS_RAWIO ) ) return - EPERM ; if ( copy_from_user ( & yi , ifr -> ifr_data , sizeof ( struct yamdrv_ioctl_cfg ) ) ) return - EFAULT ; if ( ( yi . cfg . mask & YAM_IOBASE ) && netif_running ( dev ) ) return - EINVAL ; if ( ( yi . cfg . mask & YAM_IRQ ) && netif_running ( dev ) ) return - EINVAL ; if ( ( yi . cfg . mask & YAM_
",0,511
4,"static struct sk_buff * udp6_ufo_fragment ( struct sk_buff * skb , netdev_features_t features ) { struct sk_buff * segs = ERR_PTR ( - EINVAL ) ; unsigned int mss ; unsigned int unfrag_ip6hlen , unfrag_len ; struct frag_hdr * fptr ; u8 * packet_start , * prevhdr ; u8 nexthdr ; u8 frag_hdr_sz = sizeof ( struct frag_hdr ) ; int offset ; __wsum csum ; int tnl_hlen ; mss = skb_shinfo ( skb ) -> gso_size ; if ( unlikely ( skb -> len <= mss ) ) goto out ; if ( skb_gso_ok ( skb , features | NETIF_F_GSO_ROBUST ) ) { int type = skb_shinfo ( skb ) -> gso_type ; if ( unlikely ( type & ~ ( SKB_GSO_UDP | SKB_GSO_DODGY | SKB_GSO_UDP_TUNNEL | SKB_GSO_GRE | SKB_GSO_IPIP | SKB_GSO_SIT | SKB_GSO_MPLS ) || ! ( type & ( SKB_GSO_UDP ) ) ) ) goto out ; skb_shinfo ( skb ) -> gso_segs = DIV_ROUND_UP ( skb -> len , mss ) ; segs = NULL ; goto out ; } if ( skb -> encapsulation && skb_shinfo ( skb ) -> gso_type & SKB_GSO_UDP_TUNNEL ) segs = skb_udp_tunnel_segment ( skb , features ) ; else { offset = skb_checksum_start_offset ( skb ) ; csum = skb_checksum ( skb , offset , skb -> len - offset , 0 ) ; offset += skb -> csum_offset ; * ( __sum16 * ) ( skb -> data + offset ) = csum_fold ( csum ) ; skb -> ip_summed = CHECKSUM_NONE ; t
",0,511
5,"static int read_tfra ( MOVContext * mov , AVIOContext * f ) { MOVFragmentIndex * index = NULL ; int version , fieldlength , i , j ; int64_t pos = avio_tell ( f ) ; uint32_t size = avio_rb32 ( f ) ; void * tmp ; if ( avio_rb32 ( f ) != MKBETAG ( 't' , 'f' , 'r' , 'a' ) ) { return 1 ; } av_log ( mov -> fc , AV_LOG_VERBOSE , ""foundtfra\\n"" ) ; index = av_mallocz ( sizeof ( MOVFragmentIndex ) ) ; if ( ! index ) { return AVERROR ( ENOMEM ) ; } tmp = av_realloc_array ( mov -> fragment_index_data , mov -> fragment_index_count + 1 , sizeof ( MOVFragmentIndex * ) ) ; if ( ! tmp ) { av_freep ( & index ) ; return AVERROR ( ENOMEM ) ; } mov -> fragment_index_data = tmp ; mov -> fragment_index_data [ mov -> fragment_index_count ++ ] = index ; version = avio_r8 ( f ) ; avio_rb24 ( f ) ; index -> track_id = avio_rb32 ( f ) ; fieldlength = avio_rb32 ( f ) ; index -> item_count = avio_rb32 ( f ) ; index -> items = av_mallocz_array ( index -> item_count , sizeof ( MOVFragmentIndexItem ) ) ; if ( ! index -> items ) { index -> item_count = 0 ; return AVERROR ( ENOMEM ) ; } for ( i = 0 ; i < index -> item_count ; i ++ ) { int64_t time , offset ; if ( avio_feof ( f ) ) { index -> item_count = 0 ; av_freep ( & index -> items ) ; return AVERROR_INVALIDDATA ; } if ( version == 1 ) { time = avio_rb64 ( f ) ; offset = avio_rb64 ( f ) ; } else { time = avio_rb32 ( f ) ; offset = avio_rb32 ( f ) ; } index -> items [ i ] . time
",0,511
6,"static struct se_portal_group * vhost_scsi_make_tpg ( struct se_wwn * wwn , struct config_group * group , const char * name ) { struct vhost_scsi_tport * tport = container_of ( wwn , struct vhost_scsi_tport , tport_wwn ) ; struct vhost_scsi_tpg * tpg ; unsigned long tpgt ; int ret ; if ( strstr ( name , ""tpgt_"" ) != name ) return ERR_PTR ( - EINVAL ) ; tpgt = tpgalloc ( sizeof ( struct vhost_scsi_tpg ) , GFP_KERNEL ) ; if ( ! tpg ) { pr_err ( ""Unabletoallocatestructvhost_scsi_tpg"" ) ; return ERR_PTR ( - ENOMEM ) ; } mutex_init ( & tpg -> tv_tpg_mutex ) ; INIT_LIST_HEAD ( & tpg -> tv_tpg_list ) ; tpg -> tport = tport ; tpg -> tport_tpgt = tpgt ; ret = core_tpg_register ( & vhost_scsi_fabric_configfs -> tf_ops , wwn , & tpg -> se_tpg , tpg , TRANSPORT_TPG_TYPE_NORMAL ) ; if ( ret < 0 ) { kfree ( tpg ) ; return NULL ; } mutex_lock ( & vhost_scsi_mutex ) ; list_add_tail ( & tpg -> tv_tpg_list , & vhost_scsi_list ) ; mutex_unlock ( & vhost_scsi_mutex ) ; return & tpg -> se_tpg ; }
",0,408
7,"void CleanWriters ( GF_List * writers ) { while ( gf_list_count ( writers ) ) { TrackWriter * writer = ( TrackWriter * ) gf_list_get ( writers , 0 ) ; gf_isom_box_del ( writer -> stco ) ; gf_isom_box_del ( ( GF_Box * ) writer -> stsc ) ; gf_free ( writer ) ; gf_list_rem ( writers , 0 ) ; } }
",0,108
8,"void kvm_lapic_sync_from_vapic ( struct kvm_vcpu * vcpu ) { u32 data ; if ( test_bit ( KVM_APIC_PV_EOI_PENDING , & vcpu -> arch . apic_attention ) ) apic_sync_pv_eoi_from_guest ( vcpu , vcpu -> arch . apic ) ; if ( ! test_bit ( KVM_APIC_CHECK_VAPIC , & vcpu -> arch . apic_attention ) ) return ; kvm_read_guest_cached ( vcpu -> kvm , & vcpu -> arch . apic -> vapic_cache , & data , sizeof ( u32 ) ) ; apic_set_tpr ( vcpu -> arch . apic , data & 0xff ) ; }
",1,192
9,"int arch_dup_task_struct ( struct task_struct * dst , struct task_struct * src ) { flush_fp_to_thread ( src ) ; __switch_to_tm ( src ) ; flush_altivec_to_thread ( src ) ; flush_vsx_to_thread ( src ) ; flush_spe_to_thread ( src ) ; * dst = * src ; clear_task_ebb ( dst ) ; return 0 ; }
",0,103
10,"cJSON * cJSON_GetArrayItem ( cJSON * array , int item ) { cJSON * c = array -> child ; while ( c && item > 0 ) c = c -> next ; } return c ; }
",0,48
11,"static ext3_fsblk_t get_sb_block ( void * * data , struct super_block * sb ) { ext3_fsblk_t sb_block ; char * options = ( char * ) * data ; if ( ! options || strncmp ( options , ""sb="" , 3 ) != 0 ) return 1 ; options += 3 ; sb_block = simple_strtoul ( options , & options , 0 ) ; if ( * options && * options != ',' ) { ext3_msg ( sb , KERN_ERR , ""error:invalidsbspecification:%s"" , ( char * ) * data ) ; return 1 ; } if ( * options == ',' ) options ++ ; * data = ( void * ) options ; return sb_block ; }
",1,179
12,"static struct sk_buff * udp6_ufo_fragment ( struct sk_buff * skb , u32 features ) { struct sk_buff * segs = ERR_PTR ( - EINVAL ) ; unsigned int mss ; unsigned int unfrag_ip6hlen , unfrag_len ; struct frag_hdr * fptr ; u8 * mac_start , * prevhdr ; u8 nexthdr ; u8 frag_hdr_sz = sizeof ( struct frag_hdr ) ; int offset ; __wsum csum ; mss = skb_shinfo ( skb ) -> gso_size ; if ( unlikely ( skb -> len <= mss ) ) goto out ; if ( skb_gso_ok ( skb , features | NETIF_F_GSO_ROBUST ) ) { int type = skb_shinfo ( skb ) -> gso_type ; if ( unlikely ( type & ~ ( SKB_GSO_UDP | SKB_GSO_DODGY ) || ! ( type & ( SKB_GSO_UDP ) ) ) ) goto out ; skb_shinfo ( skb ) -> gso_segs = DIV_ROUND_UP ( skb -> len , mss ) ; segs = NULL ; goto out ; } offset = skb_checksum_start_offset ( skb ) ; csum = skb_checksum ( skb , offset , skb -> len - offset , 0 ) ; offset += skb -> csum_offset ; * ( __sum16 * ) ( skb -> data + offset ) = csum_fold ( csum ) ; skb -> ip_summed = CHECKSUM_NONE ; if ( ( skb_mac_header ( skb ) < skb -> head + frag_hdr_sz ) && pskb_expand_head ( skb , frag_hdr_sz , 0 , GFP_ATOMIC ) ) goto out ; unfrag_ip6hlen = ip6_find_1stfragopt ( skb , & prevhdr ) ; nexthdr = * prevhdr ; * prevhdr = NEXTHDR_FRAGMENT ; unfrag_len = skb_network
",0,511
13,"void __perf_sw_event ( u32 event_id , u64 nr , int nmi , struct pt_regs * regs , u64 addr ) { struct perf_sample_data data ; int rctx ; preempt_disable_notrace ( ) ; rctx = perf_swevent_get_recursion_context ( ) ; if ( rctx < 0 ) return ; perf_sample_data_init ( & data , addr ) ; perf_swevent_put_recursion_context ( rctx ) ; preempt_enable_notrace ( ) ; }
",0,126
14,"static grub_disk_addr_t grub_ext2_read_block ( grub_fshelp_node_t node , grub_disk_addr_t fileblock ) { struct grub_ext2_data * data = node -> data ; struct grub_ext2_inode * inode = & node -> inode ; int blknr = - 1 ; unsigned int blksz = EXT2_BLOCK_SIZE ( data ) ; int log2_blksz = LOG2_EXT2_BLOCK_SIZE ( data ) ; if ( grub_le_to_cpu32 ( inode -> flags ) & EXT4_EXTENTS_FLAG ) { char buf [ EXT2_BLOCK_SIZE ( data ) ] ; char * buf = grub_malloc ( EXT2_BLOCK_SIZE ( data ) ) ; # else char * buf = grub_malloc ( EXT2_BLOCK_SIZE ( data ) ) ; struct grub_ext4_extent_header * leaf ; struct grub_ext4_extent * ext ; int i ; leaf = grub_ext4_find_leaf ( data , buf , ( struct grub_ext4_extent_header * ) inode -> blocks . dir_blocks , fileblock ) ; if ( ! leaf ) { grub_error ( GRUB_ERR_BAD_FS , ""invalidextent"" ) ; return - 1 ; } ext = ( struct grub_ext4_extent * ) ( leaf + 1 ) ; for ( i = 0 ; i < grub_le_to_cpu16 ( leaf -> entries ) ; i ++ ) { if ( fileblock < grub_le_to_cpu32 ( ext [ i ] . block ) ) break ; } if ( -- i >= 0 ) { fileblock -= grub_le_to_cpu32 ( ext [ i ] . block ) ; if ( fileblock >= grub_le_to_cpu16 ( ext [ i ] . len ) ) return 0 ; } else { grub_disk_addr_t start ; start = grub_le_to_cpu16 ( ext [ i ] . start_hi ) ; start = ( start << 32 ) + grub_le_to_cpu32 ( ext [ i ] . start ) ; return file
",0,511
15,"static void fdct16 ( const tran_low_t in [ 16 ] , tran_low_t out [ 16 ] ) { int step1 [ 8 ] ; tran_high_t step2 [ 8 ] ; tran_high_t step3 [ 8 ] ; int input [ 8 ] ; tran_high_t temp1 , temp2 ; input [ 0 ] = in [ 0 ] + in [ 15 ] ; input [ 1 ] = in [ 1 ] + in [ 14 ] ; input [ 2 ] = in [ 2 ] + in [ 13 ] ; input [ 3 ] = in [ 3 ] + in [ 12 ] ; input [ 4 ] = in [ 4 ] + in [ 11 ] ; input [ 5 ] = in [ 5 ] + in [ 10 ] ; input [ 6 ] = in [ 6 ] + in [ 9 ] ; input [ 7 ] = in [ 7 ] + in [ 8 ] ; step1 [ 0 ] = in [ 7 ] - in [ 8 ] ; step1 [ 1 ] = in [ 6 ] - in [ 9 ] ; step1 [ 2 ] = in [ 5 ] - in [ 10 ] ; step1 [ 3 ] = in [ 4 ] - in [ 11 ] ; step1 [ 4 ] = in [ 3 ] - in [ 12 ] ; step1 [ 5 ] = in [ 2 ] - in [ 13 ] ; step1 [ 6 ] = in [ 1 ] - in [ 14 ] ; step1 [ 7 ] = in [ 0 ] - in [ 15 ] ; { tran_high_t s0 , s1 , s2 , s3 , s4 , s5 , s6 , s7 ; tran_high_t t0 , t1 , t2 , t3 ; tran_high_t x0 , x1 , x2 , x3 ; s0 = input [ 0 ] + input [ 7 ] ; s1 = input [ 1 ] + input [ 6 ] ; s2 = input [ 2 ] + input [ 5 ] ; s3 = input [ 3 ] + input [ 4 ] ; s4 = input [ 3 ] - input [ 4 ] ; s5 = input [ 2 ] - input [ 5 ] ; s6 = input [ 1 ] - input [ 6 ] ; s7 = input [ 0 ] - input [ 7 ] ; x0 = s0 + s3 ; x1
",0,511
16,"int bpf_check ( struct bpf_prog * * prog , union bpf_attr * attr ) { struct bpf_verifier_env * env ; struct bpf_verifer_log * log ; int ret = - EINVAL ; if ( ARRAY_SIZE ( bpf_verifier_ops ) == 0 ) return - EINVAL ; env = kzalloc ( sizeof ( struct bpf_verifier_env ) , GFP_KERNEL ) ; if ( ! env ) return - ENOMEM ; log = & env -> log ; env -> insn_aux_data = vzalloc ( sizeof ( struct bpf_insn_aux_data ) * ( * prog ) -> len ) ; ret = - ENOMEM ; if ( ! env -> insn_aux_data ) goto err_free_env ; env -> prog = * prog ; env -> ops = bpf_verifier_ops [ env -> prog -> type ] ; mutex_lock ( & bpf_verifier_lock ) ; if ( attr -> log_level || attr -> log_buf || attr -> log_size ) { log -> level = attr -> log_level ; log -> ubuf = ( char __user * ) ( unsigned long ) attr -> log_buf ; log -> len_total = attr -> log_size ; ret = - EINVAL ; if ( log -> len_total < 128 || log -> len_total > UINT_MAX >> 8 || ! log -> level || ! log -> ubuf ) goto err_unlock ; } env -> strict_alignment = ! ! ( attr -> prog_flags & BPF_F_STRICT_ALIGNMENT ) ; if ( ! IS_ENABLED ( CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS ) ) env -> strict_alignment = true ; if ( env -> prog -> aux -> offload ) { ret = bpf_prog_offload_verifier_prep ( env ) ; if ( ret ) goto err_unlock ; } ret = replace_map_fd_with_map_ptr ( env ) ; if ( ret < 0 ) goto skip_full_check ; env -> explored_states = kcalloc ( env -> prog -> len , sizeof
",0,511
17,"int WavpackSetConfiguration64 ( WavpackContext * wpc , WavpackConfig * config , int64_t total_samples , const unsigned char * chan_ids ) { uint32_t flags , bps = 0 ; uint32_t chan_mask = config -> channel_mask ; int num_chans = config -> num_channels ; int i , mask ; wpc -> stream_version = ( config -> flags & CONFIG_COMPATIBLE_WRITE ) ? CUR_STREAM_VERS : MAX_STREAM_VERS ; if ( ( config -> qmode & QMODE_DSD_AUDIO ) && config -> bytes_per_sample == 1 && config -> bits_per_sample == 8 ) { # ifdef ENABLE_DSD wpc -> dsd_multiplier = 1 ; flags = DSD_FLAG ; for ( i = 14 ; i >= 0 ; -- i ) if ( config -> sample_rate % sample_rates [ i ] == 0 ) { int divisor = config -> sample_rate / sample_rates [ i ] ; if ( divisor && ( divisor & ( divisor - 1 ) ) == 0 ) { config -> sample_rate /= divisor ; wpc -> dsd_multiplier = divisor ; break ; } } if ( config -> flags & CONFIG_HYBRID_FLAG ) { strcpy ( wpc -> error_message , ""hybridmodenotavailableforDSD!"" ) ; return FALSE ; } config -> flags &= ( CONFIG_HIGH_FLAG | CONFIG_MD5_CHECKSUM | CONFIG_PAIR_UNDEF_CHANS ) ; config -> float_norm_exp = config -> xmode = 0 ; # else strcpy ( wpc -> error_message , ""libwavpacknotconfiguredforDSD!"" ) ; return FALSE ; # endif } else flags = config -> bytes_per_sample - 1 ; wpc -> total_samples = total_samples ; wpc -> config . sample_rate = config -> sample_rate ; wpc -> config . num_channels = config -> num_channels ; wpc -> config . channel_mask = config -> channel_mask ; wpc -> config . bits_per_sample = config -> bits_per_sample ; wpc -> config
",0,511
18,"int sr_do_ioctl ( Scsi_CD * cd , struct packet_command * cgc ) { struct scsi_device * SDev ; struct scsi_sense_hdr sshdr ; int result , err = 0 , retries = 0 ; unsigned char sense_buffer [ SCSI_SENSE_BUFFERSIZE ] , * senseptr = NULL ; SDev = cd -> device ; if ( cgc -> sense ) senseptr = sense_buffer ; retry : if ( ! scsi_block_when_processing_errors ( SDev ) ) { err = - ENODEV ; goto out ; } result = scsi_execute ( SDev , cgc -> cmd , cgc -> data_direction , cgc -> buffer , cgc -> buflen , senseptr , & sshdr , cgc -> timeout , IOCTL_RETRIES , 0 , 0 , NULL ) ; if ( driver_byte ( result ) != 0 ) { switch ( sshdr . sense_key ) { case UNIT_ATTENTION : SDev -> changed = 1 ; if ( ! cgc -> quiet ) sr_printk ( KERN_INFO , cd , ""discchangedetected.\\n"" ) ; if ( retries ++ < 10 ) goto retry ; err = - ENOMEDIUM ; break ; case NOT_READY : if ( sshdr . asc == 0x04 && sshdr . ascq == 0x01 ) { if ( ! cgc -> quiet ) sr_printk ( KERN_INFO , cd , ""CDROMnotreadyyet.\\n"" ) ; if ( retries ++ < 10 ) { ssleep ( 2 ) ; goto retry ; } else { err = - ENOMEDIUM ; break ; } } if ( ! cgc -> quiet ) sr_printk ( KERN_INFO , cd , ""CDROMnotready.Makesurethere"" ""isadiscinthedrive.\\n"" ) ; err = - ENOMEDIUM ; break ; case ILLEGAL_REQUEST : err = - EIO ; if ( sshdr . asc == 0x20 && sshdr . ascq == 0x00 ) err = - EDRIVE_CANT_DO_THIS ; break ; default : err = - EIO ; } } out : cgc -> stat
",0,503
19,"int CLASS parse_jpeg ( int offset ) { int len , save , hlen , mark ; fseek ( ifp , offset , SEEK_SET ) ; if ( fgetc ( ifp ) != 0xff || fgetc ( ifp ) != 0xd8 ) return 0 ; while ( fgetc ( ifp ) == 0xff && ( mark = fgetc ( ifp ) ) != 0xda ) { order = 0x4d4d ; len = get2 ( ) - 2 ; save = ftell ( ifp ) ; if ( mark == 0xc0 || mark == 0xc3 || mark == 0xc9 ) { fgetc ( ifp ) ; raw_height = get2 ( ) ; raw_width = get2 ( ) ; } order = get2 ( ) ; hlen = get4 ( ) ; if ( get4 ( ) == 0x48454150 ) { # ifdef LIBRAW_LIBRARY_BUILD imgdata . lens . makernotes . CameraMount = LIBRAW_MOUNT_FixedLens ; imgdata . lens . makernotes . LensMount = LIBRAW_MOUNT_FixedLens ; # endif parse_ciff ( save + hlen , len - hlen , 0 ) ; } if ( parse_tiff ( save + 6 ) ) apply_tiff ( ) ; fseek ( ifp , save + len , SEEK_SET ) ; } return 1 ; }
",0,316
20,"static void search_filter_level ( const YV12_BUFFER_CONFIG * sd , VP9_COMP * cpi , int partial_frame , int depth ) { VP9_COMMON * const cm = & cpi -> common ; struct loopfilter * const lf = & cpi -> lf ; const int min_filter_level = 0 ; const int max_filter_level = get_max_filter_level ( cpi ) ; int best_err ; int filt_best ; int filt_direction = 0 ; int filt_mid = clamp ( lf -> filter_level , min_filter_level , max_filter_level ) ; int filter_step = filt_mid < 16 ? 4 : filt_mid / 4 ; int ss_err [ MAX_LOOP_FILTER + 1 ] ; memset ( ss_err , 0xFF , sizeof ( ss_err ) ) ; vpx_yv12_copy_y ( cm -> frame_to_show , & cpi -> last_frame_uf ) ; best_err = try_filter_frame ( sd , cpi , filt_mid , partial_frame ) ; filt_best = filt_mid ; ss_err [ filt_mid ] = best_err ; while ( filter_step > 0 ) { const int filt_high = MIN ( filt_mid + filter_step , max_filter_level ) ; const int filt_low = MAX ( filt_mid - filter_step , min_filter_level ) ; int filter_err ; int bias = ( best_err >> ( 15 - ( filt_mid / 8 ) ) ) * filter_step ; if ( cpi -> twopass . section_intra_rating < 20 ) { if ( ss_err [ filt_low ] < 0 ) { filt_err = try_filter_frame ( sd , cpi , filt_low , partial_frame , depth + 1 ) ; } else { filt_err = try_filter_frame ( sd , cpi , filt_low , partial_frame , depth + 1 ) ; } if ( cpi -> twopass . section_intra_rating < 50 ) { if ( ss_err [ filt_low ] < 0 ) { filt_err = try_
",0,511
21,"int mp_unpack_full ( lua_State * L , int limit , int offset ) { size_t len ; const char * s ; mp_cur c ; int cnt ; int decode_all = ( ! limit && ! offset ) ; s = luaL_checklstring ( L , 1 , & len ) ; if ( offset < 0 || limit < 0 ) return luaL_error ( L , ""Invalidrequesttounpackwithoffsetof%dandlimitof%d."" , offset , len ) ; else if ( offset > len ) return luaL_error ( L , ""Startoffset%dgreaterthaninputlength%d."" , offset , len ) ; if ( decode_all ) limit = INT_MAX ; mp_cur_init ( & c , ( const unsigned char * ) s + offset , len - offset ) ; for ( cnt = 0 ; c . left > 0 && cnt < limit ; cnt ++ ) { mp_decode_to_lua_type ( L , & c ) ; if ( c . err == MP_CUR_ERROR_EOF ) { return luaL_error ( L , ""Missingbytesininput."" ) ; } else if ( c . err == MP_CUR_ERROR_BADFMT ) { return luaL_error ( L , ""Baddataformatininput."" ) ; } } if ( ! decode_all ) { int offset = len - c . left ; luaL_checkstack ( L , 1 , ""infunctionmp_unpack"" ) ; lua_insert ( L , 2 ) ; cnt += 1 ; } return cnt ; }
",0,361
22,"static void encode_mv_component ( vpx_writer * w , int comp , const nmv_component * mvcomp , int usehp ) { int offset ; const int sign = comp < 0 ; const int mag = sign ? - comp : comp ; const int mv_class = vp9_get_mv_class ( mag - 1 , & offset ) ; const int d = offset >> 3 ; const int fr = ( offset >> 1 ) & 3 ; const int hp = offset & 1 ; assert ( comp != 0 ) ; vpx_write ( w , sign , mvcomp -> sign ) ; vpx_write_token ( w , vp9_mv_class_tree , mvcomp -> classes , & mv_class_encodings [ mv_class ] ) ; if ( mv_class == MV_CLASS_0 ) { vp9_write_token ( w , vp9_mv_class0_tree , mvcomp -> class0 , & mv_class0_encodings [ d ] ) ; } else { int i ; const int n = mv_class + CLASS0_BITS - 1 ; for ( i = 0 ; i < n ; ++ i ) vpx_write ( w , ( d >> i ) & 1 , mvcomp -> bits [ i ] ) ; } vp9_write_token ( w , vp9_mv_fp_tree , mv_class == MV_CLASS_0 ? mvcomp -> class0_fp [ d ] : mvcomp -> fp , & mv_fp_encodings [ fr ] ) ; if ( usehp ) vpx_write ( w , hp , mv_class == MV_CLASS_0 ? mvcomp -> class0_hp : mvcomp -> hp ) ; }
",0,404
23,"static unsigned int seedsize ( struct crypto_alg * alg ) { struct rng_alg * ralg = container_of ( alg , struct rng_alg , base ) ; return ralg -> cra_rng . rng_make_random ? alg -> cra_rng . seedsize : ralg -> seedsize ; }
",0,75
24,"static int pptp_connect ( struct socket * sock , struct sockaddr * uservaddr , int sockaddr_len , int flags ) { struct sock * sk = sock -> sk ; struct sockaddr_pppox * sp = ( struct sockaddr_pppox * ) uservaddr ; struct pppox_sock * po = pppox_sk ( sk ) ; struct pptp_opt * opt = & po -> proto . pptp ; struct rtable * rt ; struct flowi4 fl4 ; int error = 0 ; if ( sockaddr_len < sizeof ( struct sockaddr_pppox ) ) return - EINVAL ; if ( sp -> sa_protocol != PX_PROTO_PPTP ) return - EINVAL ; if ( lookup_chan_dst ( sp -> sa_addr . pptp . call_id , sp -> sa_addr . pptp . sin_addr . s_addr ) ) return - EALREADY ; lock_sock ( sk ) ; if ( sk -> sk_state & PPPOX_CONNECTED ) { error = - EBUSY ; goto end ; } if ( sk -> sk_state & PPPOX_DEAD ) { error = - EALREADY ; goto end ; } if ( ! opt -> src_addr . sin_addr . s_addr || ! sp -> sa_addr . pptp . sin_addr . s_addr ) { error = - EINVAL ; goto end ; } po -> chan . private = sk ; po -> chan . ops = & pptp_chan_ops ; rt = ip_route_output_ports ( sock_net ( sk ) , & fl4 , sk , opt -> dst_addr . sin_addr . s_addr , opt -> src_addr . sin_addr . s_addr , 0 , 0 , IPPROTO_GRE , RT_CONN_FLAGS ( sk ) , 0 ) ; if ( IS_ERR ( rt ) ) { error = - EHOSTUNREACH ; goto end ; } sk_setup_caps ( sk , & rt -> dst ) ; po -> chan . mtu = dst_mtu ( & rt -> dst ) ; if ( ! po -> chan . mtu ) po -> chan . mtu = PPP_
",0,511
25,"error_t coapClientSetRxBlockSize ( CoapClientRequest * request , uint_t blockSize ) { if ( request == NULL ) return ERROR_INVALID_PARAMETER ; osAcquireMutex ( & request -> context -> mutex ) ; if ( blockSize == 16 ) { request -> rxBlockSzx = COAP_BLOCK_SIZE_16 ; } else if ( blockSize == 32 ) { request -> rxBlockSzx = COAP_BLOCK_SIZE_32 ; } else if ( blockSize == 64 ) { request -> rxBlockSzx = COAP_BLOCK_SIZE_64 ; } else if ( blockSize == 128 ) { request -> rxBlockSzx = COAP_BLOCK_SIZE_128 ; } else if ( blockSize == 256 ) { request -> rxBlockSzx = COAP_BLOCK_SIZE_256 ; } else if ( blockSize == 512 ) { request -> rxBlockSzx = COAP_BLOCK_SIZE_512 ; } else { request -> rxBlockSzx = COAP_BLOCK_SIZE_1024 ; } if ( request -> rxBlockSzx > coapClientGetMaxBlockSize ( ) ) { request -> rxBlockSzx = coapClientGetMaxBlockSize ( ) ; } osReleaseMutex ( & request -> context -> mutex ) ; return NO_ERROR ; }
",1,308
26,"int main ( int argc , char * * argv ) { int fmtid ; int id ; char * infile ; jas_stream_t * instream ; jas_image_t * image ; int width ; int height ; int depth ; int numcmpts ; int verbose ; char * fmtname ; int debug ; if ( jas_init ( ) ) { abort ( ) ; } cmdname = argv [ 0 ] ; infile = 0 ; debug = 0 ; verbose = 0 ; while ( ( id = jas_getopt ( argc , argv , opts ) ) >= 0 ) { switch ( id ) { case OPT_VERBOSE : verbose = 1 ; break ; case OPT_DEBUG : debug = 0 ; break ; case OPT_VERSION : printf ( ""%s\\n"" , JAS_VERSION ) ; exit ( EXIT_SUCCESS ) ; break ; case OPT_INFILE : infile = jas_optarg ; break ; case OPT_HELP : default : usage ( ) ; break ; } } jas_setdbglevel ( debug ) ; if ( infile ) { if ( ! ( instream = jas_stream_fopen ( infile , ""rb"" ) ) ) { jas_stream_close ( instream ) ; fprintf ( stderr , ""cannotopeninputimagefile%s\\n"" , infile ) ; exit ( EXIT_FAILURE ) ; } } else { if ( ! ( instream = jas_stream_fdopen ( 0 , ""rb"" ) ) ) { jas_stream_close ( instream ) ; fprintf ( stderr , ""cannotopenstandardinput\\n"" ) ; exit ( EXIT_FAILURE ) ; } } if ( ( fmtid = jas_image_getfmt ( instream ) ) < 0 ) { fprintf ( stderr , ""unknownimageformat\\n"" ) ; } if ( ! ( image = jas_image_decode ( instream , fmtid , 0 ) ) ) { fprintf ( stderr , ""cannotloadimage\\n"" ) ; return EXIT_FAILURE ; } jas_stream_close ( instream ) ; numcmpts = jas_image_numcmpts ( image ) ; width = jas
",0,511
27,"asmlinkage void bad_mode ( struct pt_regs * regs ) { pr_crit ( ""Badmodein%shandlerdetected,code0x%08x\\n"" , handler [ reason ] , esr ) ; }
",0,55
28,"static void l2tp_ppp_discon_cc_print ( netdissect_options * ndo , const u_char * dat , u_int length ) { const uint16_t * ptr = ( const uint16_t * ) dat ; if ( length < 2 ) { ND_PRINT ( ( ndo , ""AVPtooshort"" ) ) ; return ; } ND_PRINT ( ( ndo , ""%04x,"" , EXTRACT_16BITS ( ptr ) ) ) ; ptr ++ ; length -= 2 ; ND_PRINT ( ( ndo , ""%04x"" , EXTRACT_16BITS ( ptr ) ) ) ; ptr ++ ; ND_PRINT ( ( ndo , ""%s"" , tok2str ( l2tp_cc_direction2str , ""Direction-#%u"" , * ( ( const u_char * ) ptr ++ ) ) ) ) ; if ( length > 5 ) { ND_PRINT ( ( ndo , """" ) ) ; print_string ( ndo , ( const u_char * ) ptr , length - 5 ) ) ; } }
",0,247
29,"static int uas_switch_interface ( struct usb_device * udev , struct usb_interface * intf ) { struct usb_host_interface * alt ; alt = uas_find_uas_alt_setting ( intf ) ; if ( ! alt ) return - ENODEV ; return usb_set_interface ( udev , alt -> desc . bInterfaceNumber , alt -> desc . bAlternateSetting ) ; }
",1,94
30,"static int udf_pc_to_char ( struct super_block * sb , unsigned char * from , int fromlen , unsigned char * to , int tolen ) { struct pathComponent * pc ; int elen = 0 ; int comp_len ; unsigned char * p = to ; tolen -- ; while ( elen < fromlen ) { pc = ( struct pathComponent * ) ( from + elen ) ; switch ( pc -> componentType ) { case 1 : if ( pc -> lengthComponentIdent > 0 ) break ; case 2 : if ( tolen < 3 ) return - ENAMETOOLONG ; p = to ; * p ++ = '/' ; tolen -- ; break ; case 3 : if ( tolen < 2 ) return - ENAMETOOLONG ; memcpy ( p , ""../"" , 3 ) ; p += 3 ; tolen -= 3 ; break ; case 4 : if ( tolen < 2 ) return - ENAMETOOLONG ; memcpy ( p , ""./"" , 2 ) ; p += 2 ; tolen -= 2 ; if ( tolen == 0 ) return - ENAMETOOLONG ; p += udf_get_filename ( sb , pc -> componentIdent , p , pc -> lengthComponentIdent ) ; * p ++ = '/' ; tolen -- ; break ; } elen += sizeof ( struct pathComponent ) + pc -> lengthComponentIdent ; } if ( p > to + 1 ) p [ - 1 ] = '\\0' ; return 0 ; else p [ 0 ] = '\\0' ; }
",0,337
31,"void loadServerConfigFromString ( char * config ) { char * err = NULL ; int linenum = 0 , totlines , i ; int slaveof_linenum = 0 ; sds * lines ; lines = sdssplitlen ( config , strlen ( config ) , ""\\n"" , 1 , & totlines ) ; for ( i = 0 ; i < totlines ; i ++ ) { sds * argv ; int argc ; linenum = i + 1 ; lines [ i ] = sdstrim ( lines [ i ] , ""\\t\\r\\n"" ) ; if ( lines [ i ] [ 0 ] == '#' || lines [ i ] [ 0 ] == '\\0' ) continue ; argv = sdssplitargs ( lines [ i ] , & argc ) ; if ( argv == NULL ) { err = ""Unbalancedquotesinconfigurationline"" ; goto loaderr ; } if ( argc == 0 ) { sdsfreesplitres ( argv , argc ) ; continue ; } sdstolower ( argv [ 0 ] ) ; if ( ! strcasecmp ( argv [ 0 ] , ""timeout"" ) && argc == 2 ) { server . maxidletime = atoi ( argv [ 1 ] ) ; if ( server . maxidletime < 0 ) { err = ""Invalidtimeoutvalue"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""tcp-keepalive"" ) && argc == 2 ) { server . tcpkeepalive = atoi ( argv [ 1 ] ) ; if ( server . tcpkeepalive < 0 ) { err = ""Invalidtcp-keepalivevalue"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""protected-mode"" ) && argc == 2 ) { if ( ( server . protected_mode = yesnotoi ( argv [ 1 ] ) ) == - 1 ) { err = ""argumentmustbe\'yes\'or\'no\'"" ; goto loaderr ; } } else if ( ! strcasecmp ( argv [ 0 ] , ""port"" ) && argc == 2 ) { server . port = atoi ( argv [ 1 ] ) ; if ( server . port < 0 || server . port > 65535
",0,511
32,"static struct nvmet_fc_tgt_queue * nvmet_fc_find_target_queue ( struct nvmet_fc_tgtport * tgtport , u64 connection_id ) { struct nvmet_fc_tgt_assoc * assoc ; struct nvmet_fc_tgt_queue * queue ; u64 association_id = nvmet_fc_getassociationid ( connection_id ) ; u16 qid = nvmet_fc_getqueueid ( connection_id ) ; unsigned long flags ; if ( qid > NVMET_NR_QUEUES ) return NULL ; spin_lock_irqsave ( & tgtport -> lock , flags ) ; list_for_each_entry ( assoc , & tgtport -> assoc_list , a_list ) { if ( association_id == assoc -> association_id ) { queue = assoc -> queues [ qid ] ; if ( queue && ( ! atomic_read ( & queue -> connected ) || ! nvmet_fc_tgt_q_get ( queue ) ) ) queue = NULL ; spin_unlock_irqrestore ( & tgtport -> lock , flags ) ; return queue ; } } spin_unlock_irqrestore ( & tgtport -> lock , flags ) ; return NULL ; }
",1,298
33,"static int tower_probe ( struct usb_interface * interface , const struct usb_device_id * id ) { struct device * idev = & interface -> dev ; struct usb_device * udev = interface_to_usbdev ( interface ) ; struct lego_usb_tower * dev = NULL ; struct usb_host_interface * iface_desc ; struct usb_endpoint_descriptor * endpoint ; struct tower_get_version_reply get_version_reply ; int i ; int retval = - ENOMEM ; int result ; dev = kmalloc ( sizeof ( struct lego_usb_tower ) , GFP_KERNEL ) ; if ( ! dev ) goto exit ; mutex_init ( & dev -> lock ) ; dev -> udev = udev ; dev -> open_count = 0 ; dev -> read_buffer = NULL ; dev -> read_buffer_length = 0 ; dev -> read_packet_length = 0 ; spin_lock_init ( & dev -> read_buffer_lock ) ; dev -> packet_timeout_jiffies = msecs_to_jiffies ( packet_timeout ) ; dev -> read_last_arrival = jiffies ; init_waitqueue_head ( & dev -> read_wait ) ; init_waitqueue_head ( & dev -> write_wait ) ; dev -> interrupt_in_buffer = NULL ; dev -> interrupt_in_endpoint = NULL ; dev -> interrupt_in_urb = NULL ; dev -> interrupt_in_running = 0 ; dev -> interrupt_in_done = 0 ; dev -> interrupt_out_buffer = NULL ; dev -> interrupt_out_endpoint = NULL ; dev -> interrupt_out_urb = NULL ; dev -> interrupt_out_busy = 0 ; iface_desc = interface -> cur_altsetting ; for ( i = 0 ; i < iface_desc -> desc . bNumEndpoints ; ++ i ) { endpoint = & iface_desc -> endpoint [ i ] . desc ; if ( usb_endpoint_xfer_int ( endpoint ) ) { if ( usb_endpoint_dir_in ( endpoint ) ) dev -> interrupt_in_endpoint = endpoint ; else dev -> interrupt_out_endpoint = endpoint ; } } if ( dev -> interrupt_in_endpoint == NULL ) { dev_err ( idev
",0,511
34,"static Sdb * store_versioninfo_gnu_verdef ( ELFOBJ * bin , Elf_ ( Shdr ) * shdr , int sz ) { const char * section_name = """" ; const char * link_section_name = """" ; char * end = NULL ; Elf_ ( Shdr ) * link_shdr = NULL ; ut8 dfs [ sizeof ( Elf_ ( Verdef ) ) ] = { 0 } ; Sdb * sdb ; int cnt , i ; if ( shdr -> sh_link > bin -> ehdr . e_shnum ) { return false ; } link_shdr = & bin -> shdr [ shdr -> sh_link ] ; if ( shdr -> sh_size < 1 || shdr -> sh_size > SIZE_MAX ) { return false ; } Elf_ ( Verdef ) * defs = calloc ( shdr -> sh_size , sizeof ( char ) ) ; if ( ! defs ) { return false ; } if ( bin -> shstrtab && shdr -> sh_name < bin -> shstrtab_size ) { section_name = & bin -> shstrtab [ shdr -> sh_name ] ; } if ( link_shdr && bin -> shstrtab && link_shdr -> sh_name < bin -> shstrtab_size ) { link_section_name = & bin -> shstrtab [ link_shdr -> sh_name ] ; } if ( ! defs ) { bprintf ( ""Warning:Cannotallocatememory(CheckElf_(Verdef))\\n"" ) ; return NULL ; } sdb = sdb_new0 ( ) ; end = ( char * ) defs + shdr -> sh_size ; sdb_set ( sdb , ""section_name"" , section_name , 0 ) ; sdb_num_set ( sdb , ""entries"" , shdr -> sh_info , 0 ) ; sdb_num_set ( sdb , ""addr"" , shdr -> sh_addr , 0 ) ; sdb_num_set ( sdb , ""offset"" , shdr -> sh_offset , 0 ) ; sdb_num_set ( sdb , ""link"" , shdr -> sh_link , 0 ) ; sdb_set ( sdb , ""link_section_name""
",0,511
35,"static void construct_get_dest_keyring ( struct key * * _dest_keyring ) { struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) break ; } } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; break ; } kleave ( ""%p"" , dest_keyring ) ;
",0,511
36,"static OM_uint32 init_ctx_new ( OM_uint32 * minor_status , spnego_gss_cred_id_t spcred , gss_ctx_id_t * ctx , send_token_flag * tokflag ) { OM_uint32 ret ; spnego_gss_ctx_id_t sc = NULL ; sc = TEMP_FAILURE_RETRY ( create_spnego_ctx ( ) ) ; if ( sc == NULL ) return GSS_S_FAILURE ; ret = get_negotiable_mechs ( minor_status , spcred , GSS_C_INITIATE , & sc -> mech_set ) ; if ( ret != GSS_S_COMPLETE ) goto cleanup ; sc -> internal_mech = & sc -> mech_set -> elements [ 0 ] ; if ( put_mech_set ( sc -> mech_set , & sc -> DER_mechTypes ) < 0 ) { ret = GSS_S_FAILURE ; goto cleanup ; } sc -> ctx_handle = GSS_C_NO_CONTEXT ; * ctx = ( gss_ctx_id_t ) sc ; sc = NULL ; * tokflag = INIT_TOKEN_SEND ; ret = GSS_S_CONTINUE_NEEDED ; cleanup : release_spnego_ctx ( & sc ) ; return ret ; }
",0,322
37,"static int l2tp_ip_bind ( struct sock * sk , struct sockaddr * uaddr , int addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct sockaddr_l2tpip * addr = ( struct sockaddr_l2tpip * ) uaddr ; struct net * net = sock_net ( sk ) ; int ret ; int chk_addr_ret ; if ( addr_len < sizeof ( struct sockaddr_l2tpip ) ) return - EINVAL ; if ( addr -> l2tp_family != AF_INET ) return - EINVAL ; ret = - EADDRINUSE ; read_lock_bh ( & l2tp_ip_lock ) ; if ( __l2tp_ip_bind_lookup ( net , addr -> l2tp_addr . s_addr , sk -> sk_bound_dev_if , addr -> l2tp_conn_id ) ) goto out_in_use ; read_unlock_bh ( & l2tp_ip_lock ) ; lock_sock ( sk ) ; if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) goto out ; if ( addr_len < sizeof ( struct sockaddr_l2tpip ) ) return - EINVAL ; if ( addr -> l2tp_family != AF_INET ) goto out ; ret = - EADDRINUSE ; read_lock_bh ( & l2tp_ip_lock ) ; if ( __l2tp_ip_bind_lookup ( net , addr -> l2tp_addr . s_addr , sk -> sk_bound_dev_if , addr -> l2tp_conn_id ) ) goto out ; read_unlock_bh ( & l2tp_ip_lock ) ; if ( ! sock_flag ( sk , SOCK_ZAPPED ) ) goto out ; chk_addr_ret = inet_addr_type ( net , addr -> l2tp_addr . s_addr ) ; ret = - EADDRNOTAVAIL ; if ( addr -> l2tp_addr . s_addr && chk_addr_ret != RTN_LOCAL && chk_addr_ret != RTN_MULTICAST && chk_addr_ret !=
",0,511
38,"static unsigned long stack_maxrandom_size ( void ) { unsigned long max = 0 ; if ( ( current -> flags & PF_RANDOMIZE ) && ! ( current -> personality & ADDR_NO_RANDOMIZE ) ) { max = ( ( - 1UL ) & STACK_RND_MASK ) << PAGE_SHIFT ; } return max ; }
",1,82
39,"static void activate_desktop_file ( ActivateParameters * parameters , NautilusFile * file ) { ActivateParametersDesktop * parameters_desktop ; char * primary , * secondary , * display_name ; GtkWidget * dialog ; GdkScreen * screen ; char * uri ; screen = gtk_widget_get_screen ( GTK_WIDGET ( parameters -> parent_window ) ) ; if ( ! nautilus_file_is_trusted_link ( file ) ) { parameters_desktop = g_new0 ( ActivateParametersDesktop , 1 ) ; if ( parameters -> parent_window ) { parameters_desktop -> parent_window = parameters -> parent_window ; g_object_add_weak_pointer ( G_OBJECT ( parameters_desktop -> parent_window ) , ( gpointer * ) & parameters_desktop -> parent_window ) ; } parameters_desktop -> file = nautilus_file_ref ( file ) ; primary = _ ( ""Untrustedapplicationlauncher"" ) ; display_name = nautilus_file_get_display_name ( file ) ; secondary = g_strdup_printf ( _ ( ""Theapplicationlauncher“%s”hasnotbeenmarkedastrusted."" ""Ifyoudonotknowthesourceofthisfile,launchingitmaybeunsafe."" ) , display_name ) ; dialog = gtk_message_dialog_new ( parameters -> parent_window , 0 , GTK_MESSAGE_WARNING , GTK_BUTTONS_NONE , NULL ) ; g_object_set ( dialog , ""text"" , primary , ""secondary-text"" , secondary , NULL ) ; gtk_dialog_add_button ( GTK_DIALOG ( dialog ) , _ ( ""_Cancel"" ) , GTK_RESPONSE_CANCEL ) ; gtk_dialog_set_default_response ( GTK_DIALOG ( dialog ) , GTK_RESPONSE_CANCEL ) ; if ( nautilus_file_can_set_permissions ( file ) ) { gtk_dialog_add_button ( GTK_DIALOG ( dialog ) , _ ( ""Trustand_Launch"" ) , GTK_RESPONSE_OK ) ; } gtk_dialog_add_button ( GTK
",0,511
40,"char * my_asctime ( time_t t ) { struct tm * tm ; char * str ; int len ; tm = localtime ( & t ) ; str = g_strdup ( asctime ( tm ) ) ; len = strlen ( str ) ; if ( len > 0 ) str [ len - 1 ] = '\\0' ; return str ; }
",0,86
41,"static void add_password ( AUTH_HDR * request , unsigned char type , CONST char * password , char * secret ) { MD5_CTX md5_secret , my_md5 ; unsigned char misc [ AUTH_VECTOR_LEN ] ; int i ; int length = strlen ( password ) ; unsigned char hashed [ 256 + AUTH_PASS_LEN ] ; unsigned char * vector ; attribute_t * attr ; if ( length > MAXPASS ) { length = MAXPASS ; } if ( length == 0 ) { length = AUTH_PASS_LEN ; } if ( ( length & ( AUTH_PASS_LEN - 1 ) ) != 0 ) { length += ( AUTH_PASS_LEN - 1 ) ; length &= ~ ( AUTH_PASS_LEN - 1 ) ; } memset ( hashed , 0 , length ) ; memcpy ( hashed , password , strlen ( password ) ) ; attr = find_attribute ( request , PW_PASSWORD ) ; if ( type == PW_PASSWORD ) { vector = request -> vector ; } else { vector = attr -> data ; } MD5Init ( & md5_secret ) ; MD5Update ( & md5_secret , ( unsigned char * ) secret , strlen ( secret ) ) ; my_md5 = md5_secret ; MD5Update ( & my_md5 , vector , AUTH_VECTOR_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( hashed , misc , AUTH_PASS_LEN ) ; for ( i = 1 ; i < ( length >> 4 ) ; i ++ ) { my_md5 = md5_secret ; MD5Update ( & my_md5 , & hashed [ ( i - 1 ) * AUTH_PASS_LEN ] , AUTH_PASS_LEN ) ; MD5Final ( misc , & my_md5 ) ; xor ( & hashed [ i * AUTH_PASS_LEN ] , misc , AUTH_PASS_LEN ) ; } if ( type == PW_OLD_PASSWORD ) { attr = find_attribute ( request , PW_OLD_PASSWORD ) ; } if ( ! attr ) { add_attribute ( request , type , hashed , length ) ; } else { memcpy ( attr
",0,511
42,"static int m88rs2000_frontend_attach ( struct dvb_usb_adapter * adap ) { struct dvb_usb_device * d = adap -> dev ; u8 obuf [ ] = { 0x51 } ; u8 ibuf [ ] = { 0 } ; if ( dvb_usb_generic_rw ( d -> dev , obuf , 1 , ibuf , 1 , 0 ) < 0 ) err ( ""command0x51transferfailed."" ) ; d -> fe_adap [ 0 ] . fe = dvb_attach ( m88rs2000_attach , & s421_m88rs2000_config , & d -> dev -> i2c_adap ) ; if ( d -> fe_adap [ 0 ] . fe == NULL ) return - EIO ; if ( dvb_attach ( ts2020_attach , d -> fe_adap [ 0 ] . fe , & dw2104_ts2020_config , & d -> dev -> i2c_adap ) ) { info ( ""AttachedRS2000/TS2020!"" ) ; return 0 ; } info ( ""FailedtoattachRS2000/TS2020!"" ) ; return - EIO ; }
",0,267
43,"void sctp_generate_heartbeat_event ( unsigned long data ) { int error = 0 ; struct sctp_transport * transport = ( struct sctp_transport * ) data ; struct sctp_association * asoc = transport -> asoc ; struct sock * sk = asoc -> base . sk ; struct net * net = sock_net ( sk ) ; bh_lock_sock ( asoc -> base . sk ) ; if ( sock_owned_by_user ( sk ) ) { pr_debug ( ""%s:sockisbusy\\n"" , __func__ ) ; if ( ! mod_timer ( & transport -> hb_timer , jiffies + ( HZ / 20 ) ) ) sctp_transport_hold ( transport ) ; goto out_unlock ; } if ( transport -> dead ) goto out_unlock ; error = sctp_do_sm ( net , SCTP_EVENT_T_TIMEOUT , SCTP_ST_TIMEOUT ( SCTP_EVENT_TIMEOUT_HEARTBEAT ) , asoc -> state , asoc -> ep , asoc , transport , GFP_ATOMIC ) ; if ( error ) sk -> sk_err = - error ; out_unlock : bh_unlock_sock ( sk ) ; sctp_transport_put ( transport ) ; }
",1,310
44,"inline int web_client_api_request_v1_data ( RRDHOST * host , struct web_client * w , char * url ) { debug ( D_WEB_CLIENT , ""%llu:APIv1datawithURL\'%s\'"" , w -> id , url ) ; int ret = 400 ; BUFFER * dimensions = NULL ; buffer_flush ( w -> response . data ) ; char * google_version = ""0.6"" , * google_reqId = ""0"" , * google_sig = ""0"" , * google_out = ""json"" , * responseHandler = NULL , * outFileName = NULL ; time_t last_timestamp_in_data = 0 , google_timestamp = 0 ; char * chart = NULL , * before_str = NULL , * after_str = NULL , * group_time_str = NULL , * points_str = NULL ; int group = RRDR_GROUPING_AVERAGE ; uint32_t format = DATASOURCE_JSON ; uint32_t options = 0x00000000 ; while ( url ) { char * value = mystrsep ( & url , ""?&"" ) ; if ( ! value || ! * value ) continue ; char * name = mystrsep ( & value , ""="" ) ; if ( ! name || ! * name ) continue ; if ( ! value || ! * value ) continue ; debug ( D_WEB_CLIENT , ""%llu:APIv1dataqueryparam\'%s\'withvalue\'%s\'"" , w -> id , name , value ) ; if ( ! strcmp ( name , ""chart"" ) ) chart = value ; else if ( ! strcmp ( name , ""dimension"" ) || ! strcmp ( name , ""dim"" ) || ! strcmp ( name , ""dimensions"" ) || ! strcmp ( name , ""dims"" ) ) { if ( ! dimensions ) dimensions = buffer_create ( 100 ) ; buffer_strcat ( dimensions , ""|"" ) ; buffer_strcat ( dimensions , value ) ; } else if ( ! strcmp ( name , ""after"" ) ) after_str = value ; else if ( ! strcmp ( name , ""before"" ) ) before_str = value ; else if ( ! strcmp ( name , ""points"" ) ) points_
",0,511
45,"static int horAcc8 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) { tmsize_t stride = PredictorState ( tif ) -> stride ; unsigned char * cp = ( unsigned char * ) cp0 ; if ( ( cc % stride ) != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , ""horAcc8"" , ""%s"" , ""(cc%stride)!=0"" ) ; return 0 ; } if ( cc > stride ) { if ( stride == 3 ) { unsigned int cr = cp [ 0 ] ; unsigned int cg = cp [ 1 ] ; unsigned int cb = cp [ 2 ] ; cc -= 3 ; cp += 3 ; while ( cc > 0 ) { cp [ 0 ] = ( unsigned char ) ( ( cr += cp [ 0 ] ) & 0xff ) ; cp [ 1 ] = ( unsigned char ) ( ( cg += cp [ 1 ] ) & 0xff ) ; cp [ 2 ] = ( unsigned char ) ( ( cb += cp [ 2 ] ) & 0xff ) ; cc -= 3 ; cp += 3 ; } } else if ( stride == 4 ) { unsigned int cr = cp [ 0 ] ; unsigned int cg = cp [ 1 ] ; unsigned int cb = cp [ 2 ] ; unsigned int ca = cp [ 3 ] ; cc -= 4 ; cp += 4 ; while ( cc > 0 ) { cp [ 0 ] = ( unsigned char ) ( ( cr += cp [ 0 ] ) & 0xff ) ; cp [ 1 ] = ( unsigned char ) ( ( cg += cp [ 1 ] ) & 0xff ) ; cp [ 2 ] = ( unsigned char ) ( ( cb += cp [ 2 ] ) & 0xff ) ; cp [ 3 ] = ( unsigned char ) ( ( ca += cp [ 3 ] ) & 0xff ) ; cc -= 4 ; cp += 4 ; } } else { cc -= stride ; do { REPEAT4 ( stride , cp [ stride ] = ( unsigned char ) ( ( cp [ stride ] + * cp ) & 0xff ) ; cp ++ ) cc -= stride ; } while ( cc > 0 ) ; } } return 1 ; }
",0,471
46,"DECLAREcpFunc ( cpContig2SeparateByRow ) { tsize_t scanlinesizein = TIFFScanlineSize ( in ) ; tsize_t scanlinesizeout = TIFFScanlineSize ( out ) ; tdata_t inbuf ; tdata_t outbuf ; register uint8 * inp , * outp ; register uint32 n ; uint32 row ; tsample_t s ; uint16 bps = 0 ; ( void ) TIFFGetField ( in , TIFFTAG_BITSPERSAMPLE , & bps ) ; if ( bps != 8 ) { TIFFError ( TIFFFileName ( in ) , ""Error,canonlyhandleBitsPerSample=8in%s"" , ""cpContig2SeparateByRow"" ) ; return 0 ; } inbuf = _TIFFmalloc ( scanlinesizein ) ; outbuf = _TIFFmalloc ( scanlinesizeout ) ; if ( ! inbuf || ! outbuf ) goto bad ; _TIFFmemset ( inbuf , 0 , scanlinesizein ) ; _TIFFmemset ( outbuf , 0 , scanlinesizeout ) ; for ( s = 0 ; s < spp ; s ++ ) { for ( row = 0 ; row < imagelength ; row ++ ) { if ( TIFFReadScanline ( in , inbuf , row , 0 ) < 0 && ! ignore ) { TIFFError ( TIFFFileName ( in ) , ""Error,can\'treadscanline%lu"" , ( unsigned long ) row ) ; goto bad ; } inp = ( ( uint8 * ) inbuf ) + s ; outp = ( uint8 * ) outbuf ; for ( n = imagewidth ; n -- > 0 ; ) { * outp ++ = * inp ; inp += spp ; } if ( TIFFWriteScanline ( out , outbuf , row , s ) < 0 ) { TIFFError ( TIFFFileName ( out ) , ""Error,can\'twritescanline%lu"" , ( unsigned long ) row ) ; goto bad ; } } } if ( inbuf ) _TIFFfree ( inbuf ) ; if
",0,480
47,"static void free_huge_page ( struct page * page ) { struct hstate * h = page_hstate ( page ) ; int nid = page_to_nid ( page ) ; struct hugepage_subpool * spool = ( struct hugepage_subpool * ) page_private ( page ) ; set_page_private ( page , 0 ) ; page -> mapping = NULL ; BUG_ON ( page_count ( page ) ) ; BUG_ON ( page_mapcount ( page ) ) ; INIT_LIST_HEAD ( & page -> lru ) ; spin_lock ( & hugetlb_lock ) ; hugepage_subpool_put_pages ( spool , 1 ) ; }
",1,156
48,"static int read_part_of_packet ( AVFormatContext * s , int64_t * pts , int * len , int * strid , int read_packet ) { AVIOContext * pb = s -> pb ; PVAContext * pvactx = s -> priv_data ; int syncword , streamid , reserved , flags , length , pts_flag ; int64_t pva_pts = AV_NOPTS_VALUE , startpos ; int ret ; recover : startpos = avio_tell ( pb ) ; syncword = avio_rb16 ( pb ) ; streamid = avio_r8 ( pb ) ; avio_r8 ( pb ) ; reserved = avio_r8 ( pb ) ; flags = avio_r8 ( pb ) ; length = avio_rb16 ( pb ) ; pts_flag = flags & 0x10 ; if ( syncword != PVA_MAGIC ) { pva_log ( s , AV_LOG_ERROR , ""invalidsyncword\\n"" ) ; return AVERROR ( EIO ) ; } if ( streamid != PVA_VIDEO_PAYLOAD && streamid != PVA_AUDIO_PAYLOAD ) { pva_log ( s , AV_LOG_ERROR , ""invalidstreamid\\n"" ) ; return AVERROR ( EIO ) ; } if ( reserved != 0x55 ) { pva_log ( s , AV_LOG_WARNING , ""expectedreservedbytetobe0x55\\n"" ) ; } if ( length > PVA_MAX_PAYLOAD_LENGTH ) { pva_log ( s , AV_LOG_ERROR , ""invalidpayloadlength%u\\n"" , length ) ; return AVERROR ( EIO ) ; } if ( streamid == PVA_VIDEO_PAYLOAD && pts_flag ) { pva_pts = avio_rb32 ( pb ) ; length -= 4 ; } else if ( streamid == PVA_AUDIO_PAYLOAD ) { if ( ! pvactx -> continue_pes ) { int pes_signal , pes_header_data_length , pes_packet_length , pes_flags ; unsigned char pes_header_data [ 256 ]
",0,511
49,"enum nss_status _nss_mymachines_getpwnam_r ( const char * name , struct passwd * pwd , char * buffer , size_t buflen , int * errnop ) { _cleanup_bus_error_free_ sd_bus_error error = SD_BUS_ERROR_NULL ; _cleanup_bus_message_unref_ sd_bus_message * reply = NULL ; _cleanup_bus_flush_close_unref_ sd_bus * bus = NULL ; const char * p , * e , * machine ; uint32_t mapped ; uid_t uid ; size_t l ; int r ; assert ( name ) ; assert ( pwd ) ; p = startswith ( name , ""vu-"" ) ; if ( ! p ) goto not_found ; e = strrchr ( p , '-' ) ; if ( ! e || e == p ) goto not_found ; r = parse_uid ( e + 1 , & uid ) ; if ( r < 0 ) goto not_found ; machine = strndupa ( p , e - p ) ; if ( ! machine_name_is_valid ( machine ) ) goto not_found ; r = sd_bus_open_system ( & bus ) ; if ( r < 0 ) goto fail ; r = sd_bus_call_method ( bus , ""org.freedesktop.machine1"" , ""/org/freedesktop/machine1"" , ""org.freedesktop.machine1.Manager"" , ""MapFromMachineUser"" , & error , & reply , ""su"" , machine , ( uint32_t ) uid ) ; if ( r < 0 ) { if ( sd_bus_error_has_name ( & error , BUS_ERROR_NO_SUCH_USER_MAPPING ) ) goto not_found ; goto fail ; } r = sd_bus_message_read ( reply , ""u"" , & mapped ) ; if ( r < 0 ) goto fail ; l = strlen ( name ) ; if ( buflen < l + 1 ) { * errnop = ENOMEM ; return NSS_STATUS_TRYAGAIN ; } memcpy ( buffer , name , l + 1 ) ; pwd -> pw_name = name
",0,511
50,"bool generic_pipe_buf_get ( struct pipe_inode_info * pipe , struct pipe_buffer * buf ) { return try_get_page ( buf -> page ) ; }
",1,41
51,"static const u_char * ikev2_t_print ( netdissect_options * ndo , int tcount , const struct isakmp_gen * ext , u_int item_len , const u_char * ep ) { const struct ikev2_t * p ; struct ikev2_t t ; uint16_t t_id ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; p = ( const struct ikev2_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; ikev2_pay_print ( ndo , NPSTR ( ISAKMP_NPTYPE_T ) , t . h . critical ) ; t_id = ntohs ( t . t_id ) ; map = NULL ; nmap = 0 ; switch ( t . t_type ) { case IV2_T_ENCR : idstr = STR_OR_ID ( t_id , esp_p_map ) ; map = encr_t_map ; nmap = sizeof ( encr_t_map ) / sizeof ( encr_t_map [ 0 ] ) ; break ; case IV2_T_PRF : idstr = STR_OR_ID ( t_id , prf_p_map ) ; break ; case IV2_T_INTEG : idstr = STR_OR_ID ( t_id , integ_p_map ) ; break ; case IV2_T_DH : idstr = STR_OR_ID ( t_id , dh_p_map ) ; break ; case IV2_T_ESN : idstr = STR_OR_ID ( t_id , esn_p_map ) ; break ; default : idstr = NULL ; break ; } if ( idstr ) ND_PRINT ( ( ndo , ""#%utype=%sid=%s"" , tcount , STR_OR_ID ( t . t_type , ikev2_t_type_map ) , idstr ) ) ; else ND_PRINT ( ( ndo , ""#%utype=%sid=%u"" , tcount
",0,511
52,"int inode_change_ok ( const struct inode * inode , struct iattr * attr ) { unsigned int ia_valid = attr -> ia_valid ; if ( ia_valid & ATTR_SIZE ) { int error = inode_newsize_ok ( inode , attr -> ia_size ) ; if ( error ) return error ; } if ( ia_valid & ATTR_FORCE ) return 0 ; if ( ( ia_valid & ATTR_UID ) && ( ! uid_eq ( current_fsuid ( ) , inode -> i_uid ) || ! uid_eq ( attr -> ia_uid , inode -> i_uid ) ) && ! capable_wrt_inode_uidgid ( inode , CAP_CHOWN ) ) return - EPERM ; if ( ( ia_valid & ATTR_GID ) && ( ! uid_eq ( current_fsuid ( ) , inode -> i_uid ) || ( ! in_group_p ( attr -> ia_gid ) && ! gid_eq ( attr -> ia_gid , inode -> i_gid ) ) ) && ! capable_wrt_inode_uidgid ( inode , CAP_CHOWN ) ) return - EPERM ; if ( ia_valid & ATTR_MODE ) { if ( ! inode_owner_or_capable ( inode ) ) return - EPERM ; if ( ! in_group_p ( ( ia_valid & ATTR_GID ) ? attr -> ia_gid : inode -> i_gid ) && ! capable_wrt_inode_uidgid ( inode , CAP_FSETID ) ) attr -> ia_mode &= ~ S_ISGID ; } if ( ia_valid & ( ATTR_MTIME_SET | ATTR_ATIME_SET | ATTR_TIMES_SET ) ) { if ( ! inode_owner_or_capable ( inode ) ) return - EPERM ; } return 0 ; }
",0,477
53,"static bool has_byte ( const eager_reader_t * reader ) { assert ( reader != NULL ) ; fd_set read_fds ; FD_ZERO ( & read_fds ) ; FD_SET ( reader -> bytes_available_fd , & read_fds ) ; struct timeval timeout ; timeout . tv_sec = 0 ; timeout . tv_usec = 0 ; select ( reader -> bytes_available_fd + 1 , & read_fds , NULL , NULL , & timeout , & timeout ) ; return FD_ISSET ( reader -> bytes_available_fd , & read_fds ) ; }
",0,137
54,"static void fpm_child_init ( struct fpm_worker_pool_s * wp ) { fpm_globals . max_requests = wp -> config -> pm_max_requests ; fpm_globals . listening_socket = dup ( wp -> listening_socket ) ; if ( 0 > fpm_stdio_init_child ( wp ) || 0 > fpm_log_init_child ( wp ) || 0 > fpm_status_init_child ( wp ) || 0 > fpm_unix_init_child ( wp ) || 0 > fpm_signals_init_child ( ) || 0 > fpm_env_init_child ( wp ) || 0 > fpm_php_init_child ( wp ) ) { zlog ( ZLOG_ERROR , ""[pool%s]childfailedtoinitialize"" , wp -> config -> name ) ; exit ( FPM_EXIT_SOFTWARE ) ; } }
",1,220
55,"static int detect_transition_to_still ( TWO_PASS * twopass , int frame_interval , intstill_interval , double loop_decay_rate , double last_decay_rate ) { TWO_PASS * const twopass = twopass -> stats_in ; const FIRSTPASS_STATS * position = twopass -> stats_in ; const FIRSTPASS_STATS * tmp_next_frame ; for ( j = 0 ; j < still_interval ; ++ j ) { if ( input_stats ( twopass , & tmp_next_frame ) ) { break ; } if ( tmp_next_frame . pcnt_inter - tmp_next_frame . pcnt_motion < 0.999 ) { break ; } } reset_fpf_position ( twopass , position ) ; if ( j == still_interval ) trans_to_still = 1 ; } return trans_to_still ; }
",0,208
56,"int __ext4_journal_stop ( const char * where , unsigned int line , handle_t * handle ) { struct super_block * sb ; int err ; int rc ; if ( ! ext4_handle_valid ( handle ) ) { ext4_put_nojournal ( handle ) ; return 0 ; } err = handle -> h_err ; if ( ! handle -> h_transaction ) { rc = jbd2_journal_stop ( handle ) ; return err ? err : rc ; } sb = handle -> h_transaction -> t_journal -> j_private ; rc = jbd2_journal_stop ( handle ) ; if ( ! err ) err = rc ; if ( err ) __ext4_std_error ( sb , where , line , err ) ; return err ; }
",1,175
57,"static int ext4_end_io_nolock ( ext4_io_end_t * io ) { struct inode * inode = io -> inode ; loff_t offset = io -> offset ; ssize_t size = io -> size ; int ret = 0 ; ext4_debug ( ""ext4_end_io_nolock:io0x%pfrominode%lu,list->next0x%p,"" ""list->prev0x%p\\n"" , io , inode -> i_ino , io -> list . next , io -> list . prev ) ; if ( list_empty ( & io -> list ) ) return ret ; if ( io -> flag != EXT4_IO_UNWRITTEN ) return ret ; size = io -> size ; ret = ext4_convert_unwritten_extents ( inode , offset , size ) ; if ( ret < 0 ) { printk ( KERN_EMERG ""%s:failedtoconvertunwritten"" ""extentstowrittenextents,erroris%d"" ""ioisstilloninode%luaiodiolist\\n"" , __func__ , ret , inode -> i_ino ) ; return ret ; } io -> flag = 0 ; return ret ; }
",0,281
58,"STATIC int xfs_attr3_leaf_add_work ( struct xfs_buf * bp , struct xfs_attr3_icleaf_hdr * ichdr , struct xfs_da_args * args , int mapindex ) { struct xfs_attr_leafblock * leaf ; struct xfs_attr_leaf_entry * entry ; struct xfs_attr_leaf_name_local * name_loc ; struct xfs_attr_leaf_name_remote * name_rmt ; struct xfs_mount * mp ; int tmp ; int i ; trace_xfs_attr_leaf_add_work ( args ) ; leaf = bp -> b_addr ; ASSERT ( mapindex >= 0 && mapindex < XFS_ATTR_LEAF_MAPSIZE ) ; ASSERT ( args -> index >= 0 && args -> index <= ichdr -> count ) ; entry = & xfs_attr3_leaf_entryp ( leaf ) [ args -> index ] ; if ( args -> index < ichdr -> count ) { tmp = ichdr -> count - args -> index ; tmp *= sizeof ( xfs_attr_leaf_entry_t ) ; memmove ( entry + 1 , entry , tmp ) ; xfs_trans_log_buf ( args -> trans , bp , XFS_DA_LOGRANGE ( leaf , entry , tmp + sizeof ( * entry ) ) ) ; } ichdr -> count ++ ; mp = args -> trans -> t_mountp ; ASSERT ( ichdr -> freemap [ mapindex ] . base < XFS_LBSIZE ( mp ) ) ; ASSERT ( ( ichdr -> freemap [ mapindex ] . base & 0x3 ) == 0 ) ; ASSERT ( ichdr -> freemap [ mapindex ] . size >= xfs_attr_leaf_newentsize ( args -> namelen , args -> valuelen , mp -> m_sb . sb_blocksize , NULL ) ) ; ASSERT ( ichdr -> freemap [ mapindex ] . size < XFS_LBSIZE ( mp ) ) ; ASSERT ( ( ichdr -> freemap [ mapindex ] . size & 0x3 ) == 0 ) ; ichdr -> freemap [ mapindex ] . size -= xfs_
",0,511
59,"struct crypto_alg * crypto_larval_lookup ( const char * name , u32 type , u32 mask ) { struct crypto_alg * alg ; if ( ! name ) return ERR_PTR ( - ENOENT ) ; mask &= ~ ( CRYPTO_ALG_LARVAL | CRYPTO_ALG_DEAD ) ; type &= mask ; alg = crypto_alg_lookup ( name , type , mask ) ; if ( ! alg ) { return crypto_alg_add ( name , type , mask ) ; } if ( alg ) return crypto_is_larval ( alg ) ? crypto_larval_wait ( alg ) : alg ; return crypto_larval_add ( name , type , mask ) ; }
",0,172
60,"static int isis_print_mt_capability_subtlv ( netdissect_options * ndo , const uint8_t * tptr , int len ) { int stlv_type , stlv_len , tmp ; while ( len > 2 ) { ND_TCHECK2 ( * tptr , 2 ) ; stlv_type = * ( tptr ++ ) ; stlv_len = * ( tptr ++ ) ; ND_PRINT ( ( ndo , ""\\n\\t%ssubTLV#%u,length:%u"" , tok2str ( isis_mt_capability_subtlv_values , ""unknown"" , stlv_type ) , stlv_type , stlv_len ) ) ; len = len - 2 ; if ( len < stlv_len ) goto trunc ; ND_TCHECK2 ( * tptr , stlv_len ) ; switch ( stlv_type ) { case ISIS_SUBTLV_SPB_INSTANCE : if ( stlv_len < ISIS_SUBTLV_SPB_INSTANCE_MIN_LEN ) goto trunc ; ND_PRINT ( ( ndo , ""\\n\\tCISTRoot-ID:%08x"" , EXTRACT_32BITS ( tptr ) ) ) ; tptr = tptr + 4 ; ND_PRINT ( ( ndo , ""%08x"" , EXTRACT_32BITS ( tptr ) ) ) ; tptr = tptr + 4 ; ND_PRINT ( ( ndo , "",PathCost:%08x"" , EXTRACT_32BITS ( tptr ) ) ) ; tptr = tptr + 4 ; ND_PRINT ( ( ndo , "",Prio:%d"" , EXTRACT_16BITS ( tptr ) ) ) ; tptr = tptr + 2 ; ND_PRINT ( ( ndo , ""\\n\\tRES:%d"" , EXTRACT_16BITS ( tptr ) >> 5 ) ) ; ND_PRINT ( ( ndo , "",V:%d"" , ( EXTRACT_16BITS ( tptr ) >> 4 ) & 0x0001 ) ) ; ND_PRINT ( ( ndo , "",SPSource-ID:%d"" , ( EXTRACT
",0,511
61,"static void dispatch_cmd ( conn c ) { int r , i , timeout = - 1 ; size_t z ; unsigned int count ; job j ; unsigned char type ; char * size_buf , * delay_buf , * ttr_buf , * pri_buf , * end_buf , * name ; unsigned int pri , body_size ; usec delay , ttr ; uint64_t id ; tube t = NULL ; c -> cmd [ c -> cmd_len - 2 ] = '\\0' ; if ( strlen ( c -> cmd ) != c -> cmd_len - 2 ) { return reply_msg ( c , MSG_BAD_FORMAT ) ; } type = which_cmd ( c ) ; dprintf ( ""got%scommand:\\""%s\\""\\n"" , op_names [ ( int ) type ] , c -> cmd ) ; switch ( type ) { case OP_PUT : r = read_pri ( & pri , c -> cmd + 4 , & delay_buf ) ; if ( r ) return reply_msg ( c , MSG_BAD_FORMAT ) ; r = read_delay ( & delay , delay_buf , & ttr_buf ) ; if ( r ) return reply_msg ( c , MSG_BAD_FORMAT ) ; r = read_ttr ( & ttr , ttr_buf , & size_buf ) ; if ( r ) return reply_msg ( c , MSG_BAD_FORMAT ) ; r = read_ttr ( & ttr , ttr_buf , & size_buf ) ; if ( r ) return reply_msg ( c , MSG_BAD_FORMAT ) ; errno = 0 ; body_size = strtoul ( size_buf , & end_buf , 10 ) ; if ( errno ) return reply_msg ( c , MSG_BAD_FORMAT ) ; if ( body_size > job_data_size_limit ) { return reply_msg ( c , MSG_JOB_TOO_BIG ) ; } if ( end_buf [ 0 ] != '\\0' ) return reply_msg ( c , MSG_BAD_FORMAT ) ; conn_set_producer ( c ) ; c -> in_job = make_job ( pri , delay , ttr ? : 1 , body_size + 2
",0,511
62,"long dgnc_mgmt_ioctl ( struct file * file , unsigned int cmd , unsigned long arg ) { unsigned long flags ; void __user * uarg = ( void __user * ) arg ; switch ( cmd ) { case DIGI_GETDD : { struct digi_dinfo ddi ; spin_lock_irqsave ( & dgnc_global_lock , flags ) ; memset ( & ddi , 0 , sizeof ( ddi ) ) ; ddi . dinfo_nboards = dgnc_NumBoards ; sprintf ( ddi . dinfo_version , ""%s"" , DG_PART ) ; spin_unlock_irqrestore ( & dgnc_global_lock , flags ) ; if ( copy_to_user ( uarg , & ddi , sizeof ( ddi ) ) ) return - EFAULT ; break ; } case DIGI_GETBD : { int brd ; struct digi_info di ; if ( copy_from_user ( & brd , uarg , sizeof ( int ) ) ) return - EFAULT ; if ( brd < 0 || brd >= dgnc_NumBoards ) return - ENODEV ; memset ( & di , 0 , sizeof ( di ) ) ; di . info_bdnum = brd ; spin_lock_irqsave ( & dgnc_Board [ brd ] -> bd_lock , flags ) ; di . info_bdtype = dgnc_Board [ brd ] -> dpatype ; di . info_bdstate = dgnc_Board [ brd ] -> dpastatus ; di . info_ioport = 0 ; di . info_physaddr = ( ulong ) dgnc_Board [ brd ] -> membase ; di . info_physsize = ( ulong ) dgnc_Board [ brd ] -> membase - dgnc_Board [ brd ] -> membase_end ; if ( dgnc_Board [ brd ] -> state != BOARD_FAILED ) di . info_nports = dgnc_Board [ brd ] -> nasync ; else di . info_nports = 0 ; spin_unlock_irqrestore ( & dgnc_Board [ brd ] -> bd_lock , flags ) ; if (
",0,511
63,"static int mp_capable_print ( netdissect_options * ndo , const u_char * opt , u_int opt_len , u_char flags ) { const struct mp_capable * mpc = ( const struct mp_capable * ) opt ; if ( ! ( opt_len == 12 && ( flags & TH_SYN ) ) && ! ( opt_len == 20 && ( flags & ( TH_SYN | TH_ACK ) ) == TH_ACK ) ) return 0 ; if ( MP_CAPABLE_OPT_VERSION ( mpc -> sub_ver ) != 0 ) { ND_PRINT ( ( ndo , ""UnknownVersion(%d)"" , MP_CAPABLE_OPT_VERSION ( mpc -> sub_ver ) ) ) ; return 1 ; } if ( mpc -> flags & MP_CAPABLE_C ) ND_PRINT ( ( ndo , ""csum"" ) ) ; ND_PRINT ( ( ndo , ""{0x%"" PRIx64 , EXTRACT_64BITS ( mpc -> sender_key ) ) ) ; if ( opt_len == 20 ) ND_PRINT ( ( ndo , "",0x%"" PRIx64 , EXTRACT_64BITS ( mpc -> receiver_key ) ) ) ; ND_PRINT ( ( ndo , ""}"" ) ) ; return 1 ; }
",1,303
64,"static int attach_child_main ( void * data ) { struct attach_clone_payload * payload = ( struct attach_clone_payload * ) data ; int ipc_socket = payload -> ipc_socket ; lxc_attach_options_t * options = payload -> options ; struct lxc_proc_context_info * init_ctx = payload -> init_ctx ; # if HAVE_SYS_PERSONALITY_H long new_personality ; # endif int ret ; int status ; int expected ; long flags ; int fd ; int lsm_labelfd ; uid_t new_uid ; gid_t new_gid ; expected = 0 ; status = - 1 ; ret = lxc_read_nointr_expect ( ipc_socket , & status , sizeof ( status ) , & expected ) ; if ( ret <= 0 ) { ERROR ( ""ErrorusingIPCtoreceivenotificationfrominitialprocess(0):%s."" , strerror ( errno ) ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } if ( ! ( options -> namespaces & CLONE_NEWNS ) && ( options -> attach_flags & LXC_ATTACH_REMOUNT_PROC_SYS ) ) { ret = lxc_attach_remount_sys_proc ( ) ; if ( ret < 0 ) { shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } } # if HAVE_SYS_PERSONALITY_H if ( options -> personality < 0 ) new_personality = init_ctx -> personality ; else new_personality = options -> personality ; if ( options -> attach_flags & LXC_ATTACH_SET_PERSONALITY ) { ret = personality ( new_personality ) ; if ( ret < 0 ) { SYSERROR ( ""couldnotensurecorrectarchitecture"" ) ; shutdown ( ipc_socket , SHUT_RDWR ) ; rexit ( - 1 ) ; } } # endif if ( options -> attach_flags & LXC_ATTACH_DROP_CAPABILITIES ) { ret = lxc_attach_drop_privs ( init_ctx ) ; if ( ret < 0 ) { ERROR ( ""ErrorusingIPCtonotifyinitial
",0,511
65,"static int ng_pkt ( git_pkt * * out , const char * line , size_t len ) { git_pkt_ng * pkt ; const char * ptr ; size_t alloclen ; pkt = git__malloc ( sizeof ( * pkt ) ) ; GITERR_CHECK_ALLOC ( pkt ) ; pkt -> ref = NULL ; pkt -> type = GIT_PKT_NG ; if ( ! ( ptr = strchr ( line , '' ) ) ) goto out_err ; len = ptr - line ; GITERR_CHECK_ALLOC_ADD ( & alloclen , len , 1 ) ; pkt -> ref = git__malloc ( alloclen ) ; GITERR_CHECK_ALLOC ( pkt -> ref ) ; memcpy ( pkt -> ref , line , len ) ; pkt -> ref [ len ] = '\\0' ; line = ptr + 1 ; if ( ! ( ptr = strchr ( line , '\\n' ) ) ) goto out_err ; len = ptr - line ; GITERR_CHECK_ALLOC_ADD ( & alloclen , len , 1 ) ; pkt -> msg = git__malloc ( alloclen ) ; GITERR_CHECK_ALLOC ( pkt -> msg ) ; memcpy ( pkt -> msg , line , len ) ; pkt -> msg [ len ] = '\\0' ; * out = ( git_pkt * ) pkt ; return 0 ; out_err : giterr_set ( GITERR_NET , ""invalidpacketline"" ) ; git__free ( pkt -> ref ) ; git__free ( pkt ) ; return - 1 ; }
",0,382
66,"static OPJ_BOOL bmp_read_info_header ( FILE * IN , OPJ_BITMAPINFOHEADER * header ) { memset ( header , 0 , sizeof ( * header ) ) ; header -> biSize = ( OPJ_UINT32 ) getc ( IN ) ; header -> biSize |= ( OPJ_UINT32 ) getc ( IN ) << 8 ; header -> biSize |= ( OPJ_UINT32 ) getc ( IN ) << 16 ; header -> biSize |= ( OPJ_UINT32 ) getc ( IN ) << 24 ; switch ( header -> biBitCount ) { case 12U : case 40U : case 52U : case 56U : case 108U : case 124U : break ; default : fprintf ( stderr , ""Error,unknownBMPheadersize%d\\n"" , header -> biSize ) ; return OPJ_FALSE ; } header -> biWidth = ( OPJ_UINT32 ) getc ( IN ) ; header -> biWidth |= ( OPJ_UINT32 ) getc ( IN ) << 8 ; header -> biWidth |= ( OPJ_UINT32 ) getc ( IN ) << 16 ; header -> biWidth |= ( OPJ_UINT32 ) getc ( IN ) << 24 ; header -> biHeight = ( OPJ_UINT32 ) getc ( IN ) ; header -> biHeight |= ( OPJ_UINT32 ) getc ( IN ) << 8 ; header -> biHeight |= ( OPJ_UINT32 ) getc ( IN ) << 16 ; header -> biHeight |= ( OPJ_UINT32 ) getc ( IN ) << 24 ; header -> biPlanes = ( OPJ_UINT16 ) getc ( IN ) ; header -> biPlanes |= ( OPJ_UINT16 ) ( ( OPJ_UINT32 ) getc ( IN ) << 8 ) ; header -> biBitCount = ( OPJ_UINT16 ) getc ( IN ) ; header -> biBitCount |= ( OPJ_UINT16 ) ( ( OPJ_UINT32 ) getc ( IN ) << 8 ) ; header -> biBitCount |= ( OPJ_UINT16 ) ( ( OPJ_UINT32 ) getc ( IN ) << 8 )
",0,511
67,"static void sas_discover_domain ( struct work_struct * work ) { struct domain_device * dev ; int error = 0 ; struct sas_discovery_event * ev = to_sas_discovery_event ( work ) ; struct asd_sas_port * port = ev -> port ; clear_bit ( DISCE_DISCOVER_DOMAIN , & port -> disc . pending ) ; if ( port -> port_dev ) return ; error = sas_get_port_device ( port ) ; if ( error ) return ; dev = port -> port_dev ; SAS_DPRINTK ( ""DOINGDISCOVERYonport%d,pid:%d\\n"" , port -> id , task_pid_nr ( current ) ) ; switch ( dev -> dev_type ) { case SAS_END_DEVICE : error = sas_discover_end_dev ( dev ) ; break ; case SAS_EDGE_EXPANDER_DEVICE : case SAS_FANOUT_EXPANDER_DEVICE : error = sas_discover_root_expander ( dev ) ; break ; case SAS_SATA_DEV : case SAS_SATA_PM : # ifdef CONFIG_SCSI_SAS_ATA error = sas_discover_sata ( dev ) ; break ; # else SAS_DPRINTK ( ""ATAdeviceseenbutCONFIG_SCSI_SAS_ATA=Nsocannotattach\\n"" ) ; # endif default : error = - ENXIO ; SAS_DPRINTK ( ""unhandleddevice%d\\n"" , dev -> dev_type ) ; break ; } if ( error ) { sas_rphy_free ( dev -> rphy ) ; list_del_init ( & dev -> disco_list_node ) ; spin_lock_irq ( & port -> dev_list_lock ) ; list_del_init ( & dev -> dev_list_node ) ; spin_unlock_irq ( & port -> dev_list_lock ) ; sas_put_device ( dev ) ; port -> port_dev = NULL ; } sas_probe_devices ( port ) ; SAS_DPRINTK ( ""DONEDISCOVERYonport%d,pid:%d,result:%
",0,511
68,"static Image * ReadTGAImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image ; MagickBooleanType status ; PixelInfo pixel ; Quantum index ; register Quantum * q ; register ssize_t i , x ; size_t base , flag , offset , real , skip ; ssize_t count , y ; TGAInfo tga_info ; unsigned char j , k , pixels [ 4 ] , runlength ; unsigned int alpha_bits ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } count = ReadBlob ( image , 1 , & tga_info . id_length ) ; tga_info . colormap_type = ( unsigned char ) ReadBlobByte ( image ) ; tga_info . image_type = ( TGAImageType ) ReadBlobByte ( image ) ; if ( ( count != 1 ) || ( ( tga_info . image_type != TGAColormap ) && ( tga_info . image_type != TGARGB ) && ( tga_info . image_type != TGAMonochrome ) && ( tga_info . image_type != TGARLEColormap ) && ( tga_info . image_type != TGARLERGB ) && ( tga_info . image_type != TGARLEMonochrome ) ) || ( ( ( tga_info . image_type == TGAColormap ) || ( tga_info . image_type == TGARLEColormap ) ) && ( tga_info . colormap_type == 0 ) ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" )
",0,511
69,"static int jas_iccgetuint32 ( jas_stream_t * in , jas_iccuint32_t * val ) { jas_ulonglong tmp ; if ( jas_iccgetuint ( in , 4 , & tmp ) ) return - 1 ; * val = tmp ; return 0 ; }
",1,71
70,"static int wanxl_ioctl ( struct net_device * dev , struct ifreq * ifr , int cmd ) { const size_t size = sizeof ( sync_serial_settings ) ; sync_serial_settings line ; port_t * port = dev_to_port ( dev ) ; if ( cmd != SIOCWANDEV ) return hdlc_ioctl ( dev , ifr , cmd ) ; switch ( ifr -> ifr_settings . type ) { case IF_GET_IFACE : ifr -> ifr_settings . type = IF_IFACE_SYNC_SERIAL ; if ( ifr -> ifr_settings . size < size ) { ifr -> ifr_settings . size = size ; return - ENOBUFS ; } memset ( & line , 0 , sizeof ( line ) ) ; line . clock_type = get_status ( port ) -> clocking ; line . clock_rate = 0 ; line . loopback = 0 ; if ( copy_to_user ( ifr -> ifr_settings . ifs_ifsu . sync , & line , size ) ) return - EFAULT ; return 0 ; case IF_IFACE_SYNC_SERIAL : if ( ! capable ( CAP_NET_ADMIN ) ) return - EPERM ; if ( dev -> flags & IFF_UP ) return - EBUSY ; if ( copy_from_user ( & line , ifr -> ifr_settings . ifs_ifsu . sync , size ) ) return - EFAULT ; if ( line . clock_type != CLOCK_EXT && line . clock_type != CLOCK_TXFROMRX ) return - EINVAL ; if ( line . loopback != 0 ) return - EINVAL ; get_status ( port ) -> clocking = line . clock_type ; return 0 ; default : return hdlc_ioctl ( dev , ifr , cmd ) ; } }
",1,423
71,"int scsi_cmd_blk_ioctl ( struct block_device * bd , fmode_t mode , unsigned int cmd , void __user * arg ) { int ret ; ret = scsi_verify_blk_ioctl ( bd , cmd ) ; if ( ret < 0 ) return ret ; return scsi_cmd_ioctl ( bd -> bd_disk -> queue , bd -> bd_disk , mode , cmd , arg ) ; }
",1,105
72,"void nego_process_negotiation_request ( rdpNego * nego , wStream * s ) { UINT16 length ; if ( s == NULL ) return ; Stream_Read_UINT8 ( s , flags ) ; Stream_Read_UINT16 ( s , length ) ; Stream_Read_UINT32 ( s , nego -> RequestedProtocols ) ; WLog_DBG ( TAG , ""RDP_NEG_REQ:RequestedProtocol:0x%08"" PRIX32 """" , nego -> RequestedProtocols ) ; nego -> state = NEGO_STATE_FINAL ; }
",0,143
73,"int qeth_snmp_command ( struct qeth_card * card , char __user * udata ) { struct qeth_cmd_buffer * iob ; struct qeth_ipa_cmd * cmd ; struct qeth_snmp_ureq * ureq ; unsigned int req_len ; struct qeth_arp_query_info qinfo = { 0 , } ; int rc = 0 ; QETH_CARD_TEXT ( card , 3 , ""snmpcmd"" ) ; if ( card -> info . guestlan ) return - EOPNOTSUPP ; if ( ( ! qeth_adp_supported ( card , IPA_SETADP_SET_SNMP_CONTROL ) ) && ( ! card -> options . layer2 ) ) { return - EOPNOTSUPP ; } if ( copy_from_user ( & req_len , udata + sizeof ( int ) , sizeof ( int ) ) ) return - EFAULT ; ureq = memdup_user ( udata , req_len + sizeof ( struct qeth_snmp_ureq_hdr ) ) ; if ( IS_ERR ( ureq ) ) { QETH_CARD_TEXT ( card , 2 , ""snmpnome"" ) ; return PTR_ERR ( ureq ) ; } qinfo . udata_len = ureq -> hdr . data_len ; qinfo . udata = kzalloc ( qinfo . udata_len , GFP_KERNEL ) ; if ( ! qinfo . udata ) { kfree ( ureq ) ; return - ENOMEM ; } qinfo . udata_offset = sizeof ( struct qeth_snmp_ureq_hdr ) ; iob = qeth_get_adapter_cmd ( card , IPA_SETADP_SET_SNMP_CONTROL , QETH_SNMP_SETADP_CMDLENGTH + req_len ) ; cmd = ( struct qeth_ipa_cmd * ) ( iob -> data + IPA_PDU_HEADER_SIZE ) ; memcpy ( & cmd -> data . setadapterparms . data . snmp , & ureq -> cmd , req_len ) ; rc = qeth_send_ipa_snmp_cmd ( card , iob , QETH_
",0,511
74,"int jas_stream_pad ( jas_stream_t * stream , int n , int c ) { int m ; if ( n < 0 ) { jas_deprecated ( ""negativecountforjas_stream_pad"" ) ; } m = n ; for ( m = n ; m > 0 ; -- m ) { if ( jas_stream_putc ( stream , c ) == EOF ) return n - m ; } return n ; }
",1,100
75,"static int track_header ( VividasDemuxContext * viv , AVFormatContext * s , uint8_t * buf , int size ) { int i , j , ret ; int64_t off ; int val_1 ; int num_video ; AVIOContext pb0 , * pb = & pb0 ; ffio_init_context ( pb , buf , size , 0 , NULL , NULL , NULL , NULL ) ; ffio_read_varlen ( pb ) ; avio_r8 ( pb ) ; val_1 = ffio_read_varlen ( pb ) ; for ( i = 0 ; i < val_1 ; i ++ ) { int c = avio_r8 ( pb ) ; if ( avio_feof ( pb ) ) return AVERROR_EOF ; for ( j = 0 ; j < c ; j ++ ) { if ( avio_feof ( pb ) ) return AVERROR_EOF ; avio_r8 ( pb ) ; avio_r8 ( pb ) ; } } avio_r8 ( pb ) ; off = avio_tell ( pb ) ; off += ffio_read_varlen ( pb ) ; avio_r8 ( pb ) ; num_video = avio_r8 ( pb ) ; avio_seek ( pb , off , SEEK_SET ) ; if ( num_video != 1 ) { av_log ( s , AV_LOG_ERROR , ""numberofvideotracks%disnot1\\n"" , num_video ) ; return AVERROR_PATCHWELCOME ; } for ( i = 0 ; i < num_video ; i ++ ) { AVStream * st = avformat_new_stream ( s , NULL ) ; int num , den ; if ( ! st ) return AVERROR ( ENOMEM ) ; st -> id = i ; st -> codecpar -> codec_type = AVMEDIA_TYPE_VIDEO ; st -> codecpar -> codec_id = AV_CODEC_ID_VP6 ; off = avio_tell ( pb ) ; off += ffio_read_varlen ( pb ) ; avio_r8 ( pb ) ; avio_r8
",0,511
76,"static int mxf_parse_structural_metadata ( MXFContext * mxf ) { MXFPackage * material_package = NULL ; int i , j , k , ret ; av_log ( mxf -> fc -> fc , AV_LOG_TRACE , ""metadatasetscount%d\\n"" , mxf -> metadata_sets_count ) ; for ( i = 0 ; i < mxf -> packages_count ; i ++ ) { material_package = mxf_resolve_strong_ref ( mxf , & mxf -> packages_refs [ i ] , MaterialPackage ) ; if ( material_package ) break ; } if ( ! material_package ) { av_log ( mxf -> fc , AV_LOG_ERROR , ""nomaterialpackagefound\\n"" ) ; return AVERROR_INVALIDDATA ; } mxf_add_umid_metadata ( & mxf -> fc -> metadata , ""material_package_umid"" , material_package ) ; if ( material_package -> name && material_package -> name [ 0 ] ) av_dict_set ( & mxf -> fc -> metadata , ""material_package_name"" , material_package -> name , 0 ) ; mxf_parse_package_comments ( mxf , & mxf -> fc -> metadata , material_package ) ; for ( i = 0 ; i < material_package -> tracks_count ; i ++ ) { MXFPackage * source_package = NULL ; MXFTrack * material_track = NULL ; MXFTrack * source_track = NULL ; MXFTrack * temp_track = NULL ; MXFDescriptor * descriptor = NULL ; MXFStructuralComponent * component = NULL ; MXFTimecodeComponent * mxf_tc = NULL ; UID * essence_container_ul = NULL ; const MXFCodecUL * codec_ul = NULL ; const MXFCodecUL * container_ul = NULL ; const MXFCodecUL * pix_fmt_ul = NULL ; AVStream * st ; AVTimecode tc ; int flags ; if ( ! ( material_track = mxf_resolve_strong_ref ( mxf , & material_package -> tracks_refs [ i ] , Track ) ) ) { av_log ( mxf -> fc , AV_LOG_
",0,511
77,"static int mount_entry_on_relative_rootfs ( struct mntent * mntent , const char * rootfs ) { char path [ MAXPATHLEN ] ; int ret ; ret = snprintf ( path , sizeof ( path ) , ""%s/%s"" , rootfs , mntent -> mnt_dir ) ; if ( ret >= sizeof ( path ) ) { ERROR ( ""pathnametoolong"" ) ; return - 1 ; } return mount_entry_on_generic ( mntent , path , rootfs ) ; }
",1,121
78,"int id3_skip ( SF_PRIVATE * psf ) { unsigned char buf [ 10 ] ; memset ( buf , 0 , sizeof ( buf ) ) ; psf_binheader_readf ( psf , ""pb"" , 0 , buf , 10 ) ; if ( buf [ 0 ] == 'I' && buf [ 1 ] == 'D' && buf [ 2 ] == '3' ) { int offset = buf [ 6 ] & 0x7f ; offset = ( offset << 7 ) | ( buf [ 7 ] & 0x7f ) ; offset = ( offset << 7 ) | ( buf [ 8 ] & 0x7f ) ; offset = ( offset << 7 ) | ( buf [ 9 ] & 0x7f ) ; psf_log_printf ( psf , ""ID3length:%d\\n--------------------\\n"" , offset ) ; if ( offset < 0 ) return 0 ; psf -> fileoffset += offset + 10 ; if ( psf -> fileoffset < psf -> filelength ) { psf_binheader_readf ( psf , ""p"" , psf -> fileoffset ) ; return 1 ; } ; } ; return 0 ; }
",1,258
79,"static int juniper_parse_header ( netdissect_options * ndo , const u_char * p , const struct pcap_pkthdr * h , struct juniper_l2info_t * l2info ) { const struct juniper_cookie_table_t * lp = juniper_cookie_table ; u_int idx , jnx_ext_len , jnx_header_len = 0 ; uint8_t tlv_type , tlv_len ; uint32_t control_word ; int tlv_value ; const u_char * tptr ; l2info -> header_len = 0 ; l2info -> cookie_len = 0 ; l2info -> proto = 0 ; l2info -> length = h -> len ; l2info -> caplen = h -> caplen ; ND_TCHECK2 ( p [ 0 ] , 4 ) ; l2info -> flags = p [ 3 ] ; l2info -> direction = p [ 3 ] & JUNIPER_BPF_PKT_IN ; if ( EXTRACT_24BITS ( p ) != JUNIPER_MGC_NUMBER ) { ND_PRINT ( ( ndo , ""nomagic-numberfound!"" ) ) ; return 0 ; } if ( ndo -> ndo_eflag ) ND_PRINT ( ( ndo , ""%3s"" , tok2str ( juniper_direction_values , ""---"" , l2info -> direction ) ) ) ; jnx_header_len = 4 ; if ( ndo -> ndo_vflag > 1 ) ND_PRINT ( ( ndo , ""\\n\\tJuniperPCAPFlags[%s]"" , bittok2str ( jnx_flag_values , ""none"" , l2info -> flags ) ) ) ; if ( ( l2info -> flags & JUNIPER_BPF_EXT ) == JUNIPER_BPF_EXT ) { tptr = p + jnx_header_len ; ND_TCHECK2 ( tptr [ 0 ] , 2 ) ; jnx_ext_len = EXTRACT_16BITS ( tptr ) ; jnx_header_len += 2 ; tptr += 2 ; jnx_header_len += jn
",0,511
80,"static unsigned int ipv6_defrag ( void * priv , struct sk_buff * skb , const struct nf_hook_state * state ) { int err ; # if IS_ENABLED ( CONFIG_NF_CONNTRACK ) if ( skb -> nfct && ! nf_ct_is_template ( ( struct nf_conn * ) skb -> nfct ) ) return NF_ACCEPT ; # endif err = nf_ct_frag6_gather ( state -> net , skb , nf_ct6_defrag_user ( state -> hook , skb ) ) ; if ( err == - EINPROGRESS ) return NF_STOLEN ; return err == 0 ? NF_ACCEPT : NF_DROP ; }
",1,173
81,"static int xfrm_alloc_replay_state_esn ( struct xfrm_replay_state_esn * * replay_esn , struct xfrm_replay_state_esn * * preplay_esn , struct nlattr * rta ) { struct xfrm_replay_state_esn * p , * pp , * up ; int klen , ulen ; if ( ! rta ) return 0 ; up = nla_data ( rta ) ; klen = xfrm_replay_state_esn_len ( up ) ; ulen = nla_len ( rta ) - klen ; p = kzalloc ( klen , GFP_KERNEL ) ; if ( ! p ) return - ENOMEM ; pp = kzalloc ( klen , GFP_KERNEL ) ; if ( ! pp ) { kfree ( p ) ; return - ENOMEM ; } memcpy ( p , up , ulen ) ; memcpy ( pp , up , ulen ) ; * replay_esn = p ; * preplay_esn = pp ; return 0 ; }
",0,257
82,"int ipmi_si_mem_setup ( struct si_sm_io * io ) { unsigned long addr = io -> addr_data ; int mapsize , idx ; if ( ! addr ) return - ENODEV ; switch ( io -> regsize ) { case 1 : io -> inputb = intf_mem_inb ; io -> outputb = intf_mem_outb ; break ; case 2 : io -> inputb = intf_mem_inw ; io -> outputb = intf_mem_outw ; break ; case 4 : io -> inputb = intf_mem_inl ; io -> outputb = intf_mem_outl ; break ; # ifdef readq case 8 : io -> inputb = mem_inq ; io -> outputb = mem_outq ; break ; # endif default : dev_warn ( io -> dev , ""Invalidregistersize:%d\\n"" , io -> regsize ) ; return - EINVAL ; } for ( idx = 0 ; idx < io -> io_size ; idx ++ ) { if ( request_mem_region ( addr + idx * io -> regspacing , io -> regsize , DEVICE_NAME ) == NULL ) { mem_region_cleanup ( io , idx ) ; return - EIO ; } } mapsize = ( ( io -> io_size * io -> regspacing ) - ( io -> regspacing - io -> regsize ) ) ; io -> addr = ioremap ( addr , mapsize ) ; if ( io -> addr == NULL ) { mem_region_cleanup ( io , io -> io_size ) ; return - EIO ; } io -> addr = ioremap ( addr , mapsize ) ; if ( io -> addr == NULL ) { mem_region_cleanup ( io , io -> io_size ) ; return - EIO ; } return 0 ; }
",0,417
83,"static MagickRealType ApplyEvaluateOperator ( RandomInfo * random_info , const Quantum pixel , const MagickEvaluateOperator op , const MagickRealType value ) { MagickRealType result ; result = 0.0 ; switch ( op ) { case UndefinedEvaluateOperator : break ; case AbsEvaluateOperator : { result = ( MagickRealType ) fabs ( ( double ) ( pixel + value ) ) ; break ; } case AddEvaluateOperator : { result = ( MagickRealType ) ( pixel + value ) ; break ; } case ModulusEvaluateOperator : { result = pixel + value ; result -= ( QuantumRange + 1.0 ) * floor ( ( double ) result / ( QuantumRange + 1.0 ) ) ; break ; } case AndEvaluateOperator : { result = ( MagickRealType ) ( ( size_t ) pixel & ( size_t ) ( value + 0.5 ) ) ; result -= ( QuantumRange + 1.0 ) * floor ( ( double ) result / ( QuantumRange + 1.0 ) ) ; break ; } case CosineEvaluateOperator : { result = ( MagickRealType ) ( QuantumRange * ( 0.5 * cos ( ( double ) ( 2.0 * MagickPI * QuantumScale * pixel * value ) ) + 0.5 ) ) ; break ; } case DivideEvaluateOperator : { result = pixel / ( value == 0.0 ? 1.0 : value ) ; break ; } case ExponentialEvaluateOperator : { result = ( MagickRealType ) ( QuantumRange * exp ( ( double ) ( value * QuantumScale * pixel ) ) ) ; break ; } case GaussianNoiseEvaluateOperator : { result = ( MagickRealType ) GenerateDifferentialNoise ( random_info , pixel , GaussianNoise , value ) ; break ; } case ImpulseNoiseEvaluateOperator : { result = ( MagickRealType ) GenerateDifferentialNoise ( random_info , pixel , ImpulseNoise , value ) ; break ; } case LaplacianNoiseEvaluateOperator : { result = ( MagickRealType ) (
",0,487
84,"bt_status_t btif_storage_add_bonded_device ( bt_bdaddr_t * remote_bd_addr , LINK_KEY link_key , uint8_t key_type , uint8_t pin_length ) { bdstr_t bdstr ; bdaddr_to_string ( remote_bd_addr , bdstr , sizeof ( bdstr ) ) ; int ret = btif_config_set_int ( bdstr , ""LinkKeyType"" , ( int ) key_type ) ; ret &= btif_config_set_int ( bdstr , ""PinLength"" , ( int ) pin_length ) ; ret &= btif_config_set_bin ( bdstr , ""LinkKey"" , link_key , sizeof ( LINK_KEY ) ) ; return ret ? BT_STATUS_SUCCESS : BT_STATUS_FAIL ; }
",0,205
85,"void jpc_qmfb_split_colres ( jpc_fix_t * a , int numrows , int numcols , int stride , int parity ) { int bufsize = JPC_CEILDIVPOW2 ( numrows , 1 ) ; jpc_fix_t splitbuf [ QMFB_SPLITBUFSIZE * JPC_QMFB_COLGRPSIZE ] ; jpc_fix_t * buf = splitbuf ; jpc_fix_t * srcptr ; jpc_fix_t * dstptr ; register jpc_fix_t * srcptr2 ; register jpc_fix_t * dstptr2 ; register int n ; register int i ; int m ; int hstartcol ; if ( bufsize > QMFB_SPLITBUFSIZE ) { if ( ! ( buf = jas_alloc3 ( bufsize , sizeof ( jpc_fix_t ) ) ) ) { abort ( ) ; } } if ( numrows >= 2 ) { hstartcol = ( numrows + 1 - parity ) >> 1 ; m = numrows - hstartcol ; n = m ; dstptr = buf ; srcptr = & a [ ( 1 - parity ) * stride ] ; while ( n -- > 0 ) { dstptr2 = dstptr ; srcptr2 = srcptr ; for ( i = 0 ; i < numcols ; ++ i ) { * dstptr2 = * srcptr2 ; ++ dstptr2 ; ++ srcptr2 ; } dstptr += numcols ; srcptr += stride << 1 ; } dstptr = & a [ ( 1 - parity ) * stride ] ; srcptr = & a [ ( 2 - parity ) * stride ] ; n = numrows - m - ( ! parity ) ; while ( n -- > 0 ) { dstptr2 = dstptr ; srcptr2 = srcptr ; for ( i = 0 ; i < numcols ; ++ i ) { * dstptr2 = * srcptr2 ; ++ dstptr2 ; ++ srcptr2 ; } dstptr += stride ; srcptr += stride << 1 ; } dstptr = & a [ hstartcol * stride ] ; srcptr = buf ; n = m ; while ( n -- > 0 ) { dstptr2 = dstptr ; srcptr2 = srcptr ; for ( i = 0 ; i <
",0,511
86,"vpx_codec_err_t vpx_codec_enc_config_default ( vpx_codec_iface_t * iface , vpx_codec_enc_cfg_t * cfg , unsigned int usage ) { vpx_codec_err_t res ; vpx_codec_enc_cfg_map_t * map ; if ( ! iface || ! cfg || usage > INT_MAX ) res = VPX_CODEC_INVALID_PARAM ; else if ( ! ( iface -> caps & VPX_CODEC_CAP_ENCODER ) ) res = VPX_CODEC_INCAPABLE ; else { res = VPX_CODEC_INVALID_PARAM ; for ( map = iface -> enc . cfg_maps ; map -> usage >= 0 ; map ++ ) { if ( map -> usage == ( int ) usage ) { * cfg = map -> cfg ; cfg -> g_usage = usage ; res = VPX_CODEC_OK ; break ; } } } return res ; }
",0,244
87,"static int netbk_set_skb_gso ( struct xenvif * vif , struct sk_buff * skb , struct xen_netif_extra_info * gso ) { if ( ! gso -> u . gso . size ) { netdev_err ( vif -> dev , ""GSOsizemustnotbezero.\\n"" ) ; netbk_fatal_tx_err ( vif ) ; return - EINVAL ; } if ( gso -> u . gso . type != XEN_NETIF_GSO_TYPE_TCPV4 ) { netdev_err ( vif -> dev , ""BadGSOtype%d.\\n"" , gso -> u . gso . type ) ; netbk_fatal_tx_err ( vif ) ; return - EINVAL ; } skb_shinfo ( skb ) -> gso_size = gso -> u . gso . size ; skb_shinfo ( skb ) -> gso_type = SKB_GSO_TCPV4 ; skb_shinfo ( skb ) -> gso_type |= SKB_GSO_DODGY ; skb_shinfo ( skb ) -> gso_segs = 0 ; return 0 ; }
",1,289
88,"static void show_object ( struct object * object , const char * last , void * data ) { struct bitmap * base = data ; int bitmap_pos ; bitmap_pos = bitmap_position ( object -> oid . hash ) ; if ( bitmap_pos < 0 ) bitmap_pos = ext_index_add_object ( object , name ) ; free ( name ) ; } bitmap_set ( base , bitmap_pos ) ; }
",1,101
89,"int do_command ( unsigned char c ) { static int dtr_up = 0 ; int newbaud , newflow , newparity , newbits ; const char * xfr_cmd ; char * fname ; int r ; switch ( c ) { case KEY_EXIT : return 1 ; case KEY_QUIT : term_set_hupcl ( tty_fd , 0 ) ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; term_erase ( tty_fd ) ; return 1 ; case KEY_STATUS : show_status ( dtr_up ) ; break ; case KEY_PULSE : fd_printf ( STO , ""\\r\\n***pulseDTR***\\r\\n"" ) ; if ( term_pulse_dtr ( tty_fd ) < 0 ) fd_printf ( STO , ""***FAILED\\r\\n"" ) ; break ; case KEY_TOGGLE : if ( dtr_up ) r = term_lower_dtr ( tty_fd ) ; else r = term_raise_dtr ( tty_fd ) ; if ( r >= 0 ) dtr_up = ! dtr_up ; fd_printf ( STO , ""\\r\\n***DTR:%s***\\r\\n"" , dtr_up ? ""up"" : ""down"" ) ; break ; case KEY_BAUD_UP : case KEY_BAUD_DN : if ( c == KEY_BAUD_UP ) opts . baud = baud_up ( opts . baud ) ; else opts . baud = baud_down ( opts . baud ) ; term_set_baudrate ( tty_fd , opts . baud ) ; tty_q . len = 0 ; term_flush ( tty_fd ) ; term_apply ( tty_fd ) ; newbaud = term_get_baudrate ( tty_fd , NULL ) ; if ( opts . baud != newbaud ) { fd_printf ( STO , ""\\r\\n***baud:%d(%d)***\\r\\n"" , opts . baud , newbaud ) ; } else { fd_printf
",0,511
90,"static void snd_usb_mixer_free ( struct usb_mixer_interface * mixer ) { snd_usb_mixer_disconnect ( mixer ) ; kfree ( mixer -> id_elems ) ; if ( mixer -> urb ) { kfree ( mixer -> urb -> transfer_buffer ) ; usb_free_urb ( mixer -> urb ) ; } usb_free_urb ( mixer -> rc_urb ) ; kfree ( mixer -> rc_setup_packet ) ; kfree ( mixer ) ; }
",1,116
91,"static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_rollover * rollover = NULL ; struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } mutex_lock ( & fanout_mutex ) ; err = - EINVAL ; if ( ! po -> running ) goto out ; err = - EALREADY ; if ( po -> fanout ) goto out ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { err = - ENOMEM ; rollover = kzalloc ( sizeof ( * rollover ) , GFP_KERNEL ) ; if ( ! rollover ) goto out ; atomic_long_set ( & po -> rollover -> num , 0 ) ; atomic_long_set ( & rollover -> num_huge , 0 ) ; atomic_long_set ( & rollover -> num_failed , 0 ) ; } mutex_lock ( & fanout_mutex ) ; return err ; }
",1,406
92,"static struct sock * sctp_v6_create_accept_sk ( struct sock * sk , struct sctp_association * asoc , bool kern ) { struct sock * newsk ; struct ipv6_pinfo * newnp , * np = inet6_sk ( sk ) ; struct sctp6_sock * newsctp6sk ; struct ipv6_txoptions * opt ; newsk = sk_alloc ( sock_net ( sk ) , PF_INET6 , GFP_KERNEL , sk -> sk_prot , kern ) ; if ( ! newsk ) goto out ; sock_init_data ( NULL , newsk ) ; sctp_copy_sock ( newsk , sk , asoc ) ; sock_reset_flag ( sk , SOCK_ZAPPED ) ; newsctp6sk = ( struct sctp6_sock * ) newsk ; inet_sk ( newsk ) -> pinet6 = & newsctp6sk -> inet6 ; sctp_sk ( newsk ) -> v4mapped = sctp_sk ( sk ) -> v4mapped ; newnp = inet6_sk ( newsk ) ; opt = rcu_dereference ( np -> opt ) ; if ( opt ) opt = ipv6_dup_options ( newsk , opt ) ; RCU_INIT_POINTER ( newnp -> opt , opt ) ; rcu_read_unlock ( ) ; sctp_v6_to_sk_daddr ( & asoc -> peer . primary_addr , newsk ) ; newsk -> sk_v6_rcv_saddr = sk -> sk_v6_rcv_saddr ; sk_refcnt_debug_inc ( newsk ) ; if ( newsk -> sk_prot -> init ( newsk ) ) { sk_common_release ( newsk ) ; newsk = NULL ; } out : return newsk ; }
",0,441
93,"static struct scatterlist * alloc_sgtable ( int size ) { int alloc_size , nents , i ; struct page * new_page ; struct scatterlist * iter ; struct scatterlist * table ; nents = DIV_ROUND_UP ( size , PAGE_SIZE ) ; table = kcalloc ( nents , sizeof ( * table ) , GFP_KERNEL ) ; if ( ! table ) return NULL ; sg_init_table ( table , nents ) ; iter = table ; for_each_sg ( table , iter , sg_nents ( table ) , i ) { new_page = alloc_page ( GFP_KERNEL ) ; if ( ! new_page ) { iter = table ; for_each_sg ( table , iter , sg_nents ( table ) , i ) { new_page = sg_page ( iter ) ; if ( new_page ) __free_page ( new_page ) ; } alloc_size = min_t ( int , size , PAGE_SIZE ) ; size -= PAGE_SIZE ; sg_set_page ( iter , new_page , alloc_size , 0 ) ; } return table ; }
",0,259
94,"void show_progress ( int frame_in , int frame_out , uint64_t dx_time ) { fprintf ( stderr , ""%ddecodedframes/%dshowedframesin%"" PRId64 ""us(%.2ffps)\\r"" , frame_in , frame_out , dx_time , ( double ) frame_out * 1000000.0 / ( double ) dx_time ) ; }
",0,93
95,"AV * dbd_st_fetch ( SV * sth , imp_sth_t * imp_sth ) { dTHX ; int num_fields , ChopBlanks , i , rc ; unsigned long * lengths ; AV * av ; int av_length , av_readonly ; MYSQL_ROW cols ; D_imp_dbh_from_sth ; MYSQL * svsock = imp_dbh -> pmysql ; imp_sth_fbh_t * fbh ; D_imp_xxh ( sth ) ; # if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION MYSQL_BIND * buffer ; # endif MYSQL_FIELD * fields ; if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\t->dbd_st_fetch\\n"" ) ; # if MYSQL_ASYNC if ( imp_dbh -> async_query_in_flight ) { if ( mysql_db_async_result ( sth , & imp_sth -> result ) <= 0 ) { return Nullav ; } } # endif # if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION if ( imp_sth -> use_server_side_prepare ) { if ( ! DBIc_ACTIVE ( imp_sth ) ) { do_error ( sth , JW_ERR_SEQUENCE , ""nostatementexecuting\\n"" , NULL ) ; return Nullav ; } if ( imp_sth -> fetch_done ) { do_error ( sth , JW_ERR_SEQUENCE , ""fetch()butfetchalreadydone"" , NULL ) ; return Nullav ; } if ( ! imp_sth -> done_desc ) { if ( ! dbd_describe ( sth , imp_sth ) ) { do_error ( sth , JW_ERR_SEQUENCE , ""Errorwhiledescriberesultset."" , NULL ) ; return Nullav ; } } } } # endif ChopBlanks = DBIc_is ( imp_sth , DBIcf_ChopBlanks ) ; if ( DBIc_TRACE_LEVEL
",0,511
96,"error_t enc28j60SendPacket ( NetInterface * interface , const NetBuffer * buffer , size_t offset , NetTxAncillary * ancillary ) { size_t length ; length = netBufferGetLength ( buffer ) - offset ; if ( length > 1536 ) { osSetEvent ( & interface -> nicTxEvent ) ; return ERROR_INVALID_LENGTH ; } if ( ! interface -> linkState ) { osSetEvent ( & interface -> nicTxEvent ) ; return NO_ERROR ; } enc28j60SetBit ( interface , ENC28J60_ECON1 , ECON1_TXRST ) ; enc28j60ClearBit ( interface , ENC28J60_ECON1 , ECON1_TXRST ) ; enc28j60ClearBit ( interface , ENC28J60_EIR , EIR_TXIF | ENC28J60_EIR_TXERIF ) ; enc28j60WriteReg ( interface , ENC28J60_ETXSTL , LSB ( ENC28J60_TX_BUFFER_START ) ) ; enc28j60WriteReg ( interface , ENC28J60_ETXSTH , MSB ( ENC28J60_TX_BUFFER_START ) ) ; enc28j60WriteReg ( interface , ENC28J60_EWRPTL , LSB ( ENC28J60_TX_BUFFER_START ) ) ; enc28j60WriteReg ( interface , ENC28J60_EWRPTH , MSB ( ENC28J60_TX_BUFFER_START ) ) ; enc28j60WriteBuffer ( interface , buffer , offset ) ; enc28j60WriteReg ( interface , ENC28J60_ETXNDL , LSB ( ENC28J60_TX_BUFFER_START + length ) ) ; enc28j60WriteReg ( interface , ENC28J60_ETXNDH , MSB ( ENC28J60_TX_BUFFER_START + length ) ) ; enc28j60SetBit ( interface , ENC28J60_ECON1 , ECON1_TXRST ) ; enc28j60SetBit ( interface , ENC28J60_ECON1 , ECON1_TX
",0,511
97,"PyObject * ast2obj_arg ( void * _o ) { arg_ty o = ( arg_ty ) _o ; PyObject * result = NULL , * value = NULL ; if ( ! o ) { Py_RETURN_NONE ; } result = PyType_GenericNew ( arg_type , NULL , NULL ) ; if ( ! result ) return NULL ; value = ast2obj_identifier ( o -> arg ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_arg , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_expr ( o -> annotation ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_annotation , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_int ( o -> lineno ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_lineno , value ) < 0 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_int ( o -> col_offset ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_col_offset , value ) < 0 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_int ( o -> end_lineno ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_end_lineno , value ) < 0 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_int ( o -> end_col_offset ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_end_col_offset , value ) < 0 ) goto failed ; Py_DECREF ( value ) ; return result ; failed : Py_XDECREF ( value ) ; Py_XDECREF ( result ) ; return NULL ; }
",0,468
98,"void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send
",0,511
99,"static int ext4_ext_handle_uninitialized_extents ( handle_t * handle , struct inode * inode , ext4_lblk_t iblock , unsigned int max_blocks , struct ext4_ext_path * path , int flags , unsigned int allocated , struct buffer_head * bh_result , ext4_fsblk_t newblock ) { int ret = 0 ; int err = 0 ; ext4_io_end_t * io = EXT4_I ( inode ) -> cur_aio_dio ; ext_debug ( ""ext4_ext_handle_uninitialized_extents:inode%lu,logical"" ""block%llu,max_blocks%u,flags%d,allocated%u"" , inode -> i_ino , ( unsigned long long ) iblock , max_blocks , flags , allocated ) ; ext4_ext_show_leaf ( inode , path ) ; if ( ( flags & EXT4_GET_BLOCKS_PRE_IO ) ) ret = ext4_split_unwritten_extents ( handle , inode , path , iblock , max_blocks , flags ) ; if ( io ) io -> flag = EXT4_IO_UNWRITTEN ; else ext4_set_inode_state ( inode , EXT4_STATE_DIO_UNWRITTEN ) ; if ( ( flags & EXT4_GET_BLOCKS_CONVERT ) ) ret = ext4_convert_unwritten_extents_endio ( handle , inode , path ) ; if ( ret >= 0 ) ext4_update_inode_fsync_trans ( handle , inode , 1 ) ; goto out2 ; } if ( flags & EXT4_GET_BLOCKS_UNINIT_EXT ) goto map_out ; if ( ( flags & EXT4_GET_BLOCKS_CREATE ) == 0 ) { set_buffer_unwritten ( bh_result ) ; goto out1 ; } ret = ext4_ext_convert_to_initialized ( handle , inode , path , iblock , max_blocks ) ; if ( ret >= 0 ) ext4_update_inode_fsync_trans ( handle , inode , 1 ) ; out : if ( ret < 0 ) set_buffer_
",0,511
100,"static int print_ipcp_config_options ( netdissect_options * ndo , const u_char * p , int length ) { int len , opt ; u_int compproto , ipcomp_subopttotallen , ipcomp_subopt , ipcomp_suboptlen ; if ( length < 2 ) return 0 ; ND_TCHECK2 ( * p , 2 ) ; len = p [ 1 ] ; opt = p [ 0 ] ; if ( length < len ) return 0 ; if ( len < 2 ) { ND_PRINT ( ( ndo , ""\\n\\t%sOption(0x%02x),length%u(lengthbogus,shouldbe>=2)"" , tok2str ( ipcpopt_values , ""unknown"" , opt ) , opt , len ) ) ; return 0 ; } ND_PRINT ( ( ndo , ""\\n\\t%sOption(0x%02x),length%u"" , tok2str ( ipcpopt_values , ""unknown"" , opt ) , opt , len ) ) ; switch ( opt ) { case IPCPOPT_2ADDR : if ( len != 10 ) { ND_PRINT ( ( ndo , ""(lengthbogus,shouldbe=10)"" ) ) ; return len ; } ND_TCHECK2 ( * ( p + 6 ) , 4 ) ; ND_PRINT ( ( ndo , "":src%s,dst%s"" , ipaddr_string ( ndo , p + 2 ) , ipaddr_string ( ndo , p + 6 ) ) ) ; break ; case IPCPOPT_IPCOMP : if ( len < 4 ) { ND_PRINT ( ( ndo , ""(lengthbogus,shouldbe>=4)"" ) ) ; return 0 ; } ND_TCHECK2 ( * ( p + 2 ) , 2 ) ; compproto = EXTRACT_16BITS ( p + 2 ) ; ND_PRINT ( ( ndo , "":%s(0x%02x):"" , tok2str ( ipcpopt_compproto_values , ""Unknown"" , compproto ) , compproto ) ) ; switch ( compproto ) { case PPP_VJC : break ; case I
",0,511
101,"static int cg_getattr ( const char * path , struct stat * sb ) { struct timespec now ; struct fuse_context * fc = fuse_get_context ( ) ; char * cgdir = NULL ; char * fpath = NULL , * path1 , * path2 ; struct cgfs_files * k = NULL ; const char * cgroup ; const char * controller = NULL ; int ret = - ENOENT ; if ( ! fc ) return - EIO ; memset ( sb , 0 , sizeof ( struct stat ) ) ; if ( clock_gettime ( CLOCK_REALTIME , & now ) < 0 ) return - EINVAL ; sb -> st_uid = sb -> st_gid = 0 ; sb -> st_atim = sb -> st_mtim = sb -> st_ctim = now ; sb -> st_size = 0 ; if ( strcmp ( path , ""/cgroup"" ) == 0 ) { sb -> st_mode = S_IFDIR | 00755 ; sb -> st_nlink = 2 ; return 0 ; } controller = pick_controller_from_path ( fc , path ) ; if ( ! controller ) return - EIO ; cgroup = find_cgroup_in_path ( path ) ; if ( ! cgroup ) { sb -> st_mode = S_IFDIR | 00755 ; sb -> st_nlink = 2 ; return 0 ; } get_cgdir_and_path ( cgroup , & cgdir , & fpath ) ; if ( ! fpath ) { path1 = ""/"" ; path2 = cgdir ; } else { path1 = cgdir ; path2 = fpath ; } if ( is_child_cgroup ( controller , path1 , path2 ) ) { if ( ! caller_is_in_ancestor ( fc -> pid , controller , cgroup , NULL ) ) { sb -> st_mode = S_IFDIR | 00555 ; sb -> st_nlink = 2 ; ret = 0 ; goto out ; } if ( ! fc_may_access ( fc , controller , cgroup , NULL , O_RDONLY ) ) { ret = - EACCES ; goto out ; } sb -> st_mode = S_IF
",0,511
102,"void vp8_de_noise ( VP8_COMMON * cm , YV12_BUFFER_CONFIG * source , YV12_BUFFER_CONFIG * post , int q , int low_var_thresh ) { double level = 6.0e-05 * q * q * q - .0067 * q * q + .306 * q + .0065 ; int ppl = ( int ) ( level + .5 ) ; int mb_rows = source -> y_width >> 4 ; int mb_cols = source -> y_height >> 4 ; unsigned char * limits = cm -> pp_limits_buffer ; int mbr , mbc ; ( void ) post ; ( void ) low_var_thresh ; ( void ) flag ; vpx_memset ( limits , ( unsigned char ) ppl , 16 * mb_cols , 16 * mb_rows ) ; for ( mbr = 0 ; mbr < mb_rows ; mbr ++ ) { vp8_post_proc_down_and_across_mb_row ( source -> y_buffer + 16 * mbr * source -> y_stride , source -> y_buffer + 16 * mbr * source -> y_stride , source -> y_stride , source -> y_width , limits , 16 ) ; vpx_post_proc_down_and_across_mb_row ( source -> u_buffer + 8 * mbr * source -> uv_stride , source -> u_buffer + 8 * mbr * source -> uv_stride , source -> uv_stride , source -> uv_stride , source -> uv_width , limits , 8 ) ; vp8_post_proc_down_and_across_mb_row ( source -> v_buffer + 8 * mbr * source -> uv_stride , source -> v_buffer + 8 * mbr * source -> uv_stride , source -> uv_stride , source -> uv_width , limits , 8 ) ; } }
",0,458
103,"static int raw_cmd_copyout ( int cmd , void __user * param , struct floppy_raw_cmd * ptr ) { int ret ; while ( ptr ) { ret = copy_to_user ( param , & ptr , sizeof ( * ptr ) ) ; if ( ret ) return - EFAULT ; param += sizeof ( struct floppy_raw_cmd ) ; if ( ( ptr -> flags & FD_RAW_READ ) && ptr -> buffer_length ) { if ( ptr -> length >= 0 && ptr -> length <= ptr -> buffer_length ) { long length = ptr -> buffer_length - ptr -> length ; ret = fd_copyout ( ptr -> data , ptr -> kernel_data , length ) ; if ( ret ) return ret ; } } ptr = ptr -> next ; } return 0 ; }
",0,172
104,"int cap_bprm_set_creds ( struct linux_binprm * bprm ) { const struct cred * old = current_cred ( ) ; struct cred * new = bprm -> cred ; bool effective , has_cap = false ; int ret ; effective = false ; ret = get_file_caps ( bprm , & effective , & has_cap ) ; if ( ret < 0 ) return ret ; if ( ! issecure ( SECURE_NOROOT ) ) { if ( has_cap && new -> uid != 0 && new -> euid == 0 ) { warn_setuid_and_fcaps_mixed ( bprm -> filename ) ; goto skip ; } if ( new -> euid == 0 || new -> uid == 0 ) { new -> cap_permitted = cap_combine ( old -> cap_bset , old -> cap_inheritable ) ; } if ( new -> euid == 0 ) effective = true ; } skip : if ( ( new -> euid != old -> uid || new -> egid != old -> gid || ! cap_issubset ( new -> cap_permitted , old -> cap_permitted ) ) && bprm -> unsafe & ~ LSM_UNSAFE_PTRACE_CAP ) { if ( ! capable ( CAP_SETUID ) ) { new -> euid = new -> uid ; new -> egid = new -> gid ; } new -> cap_permitted = cap_intersect ( new -> cap_permitted , old -> cap_permitted ) ; } new -> suid = new -> fsuid = new -> euid ; new -> sgid = new -> fsgid = new -> egid ; if ( effective ) new -> cap_effective = new -> cap_permitted ; else cap_clear ( new -> cap_effective ) ; bprm -> cap_effective = effective ; if ( ! cap_isclear ( new -> cap_effective ) ) { if ( ! cap_issubset ( CAP_FULL_SET , new -> cap_effective ) || new -> euid != 0 || new -> uid != 0 || issecure ( SECURE_NOROOT ) ) { ret = audit_log_bprm_fcaps ( bprm , new , old ) ; if ( ret < 0 )
",0,511
105,"static int ext4_xattr_cache_insert ( struct mb2_cache * ext4_mb_cache , struct buffer_head * bh ) { __u32 hash = le32_to_cpu ( BHDR ( bh ) -> h_hash ) ; struct mb2_cache_entry * ce ; int error ; ce = mb2_cache_entry_alloc ( ext4_mb_cache , GFP_NOFS ) ; if ( ! ce ) { ea_bdebug ( bh , ""outofmemory"" ) ; return ; } error = mb2_cache_entry_insert ( ce , bh -> b_bdev , bh -> b_blocknr , hash ) ; if ( error ) { mb2_cache_entry_free ( ce ) ; if ( error == - EBUSY ) { ea_bdebug ( bh , ""alreadyincache"" ) ; error = 0 ; } } else { ea_bdebug ( bh , ""inserting[%x]"" , ( int ) hash ) ; mb2_cache_entry_release ( ce ) ; } return error ; }
",0,253
106,"R_API char * r_socket_http_post ( const char * url , const char * data , int * code , int * rlen ) { RSocket * s ; bool ssl = r_str_startswith ( url , ""https://"" ) ; char * uri = strdup ( url ) ; if ( ! uri ) { return NULL ; } char * host = strstr ( uri , ""://"" ) ; if ( ! host ) { free ( uri ) ; printf ( ""InvalidURI"" ) ; return NULL ; } host += 3 ; char * port = strchr ( host , ':' ) ; if ( ! port ) { port = ( ssl ) ? ""443"" : ""80"" ; } else { * port ++ = 0 ; } char * path = strchr ( host , '/' ) ; if ( ! path ) { path = """" ; } else { * path ++ = 0 ; } s = r_socket_new ( ssl ) ; if ( ! s ) { printf ( ""Cannotcreatesocket\\n"" ) ; free ( uri ) ; return NULL ; } if ( ! r_socket_connect_tcp ( s , host , port , 0 ) ) { eprintf ( ""Cannotconnectto%s:%s\\n"" , host , port ) ; free ( uri ) ; return NULL ; } r_socket_printf ( s , ""POST/%sHTTP/1.0\\r\\n"" ""User-Agent:radare2"" R2_VERSION ""\\r\\n"" ""Accept:*/*\\r\\n"" ""Host:%s\\r\\n"" ""Content-Length:%i\\r\\n"" ""Content-Type:application/x-www-form-urlencoded\\r\\n"" ""\\r\\n"" , path , host , ( int ) strlen ( data ) ) ; free ( uri ) ; r_socket_write ( s , ( void * ) data , strlen ( data ) ) ; }
",0,443
107,"static void f_parser ( lua_State * L , void * ud ) { int i ; Proto * tf ; Closure * cl ; struct SParser * p = cast ( struct SParser * , ud ) ; int c = luaZ_lookahead ( p -> z ) ; luaC_checkGC ( L ) ; tf = ( luaY_parser ) ( L , p -> z , & p -> buff , p -> name ) ; cl = luaF_newLclosure ( L , tf -> nups , hvalue ( gt ( L ) ) ) ; cl -> l . p = tf ; for ( i = 0 ; i < tf -> nups ; i ++ ) cl -> l . upvals [ i ] = luaF_newupval ( L ) ; setclvalue ( L , L -> top , cl ) ; incr_top ( L ) ; }
",1,195
108,"static int inet_create ( struct net * net , struct socket * sock , int protocol , int kern ) { struct sock * sk ; struct inet_protosw * answer ; struct inet_sock * inet ; struct proto * answer_prot ; unsigned char answer_flags ; int try_loading_module = 0 ; int err ; if ( protocol < 0 || protocol >= IPPROTO_MAX ) return - EINVAL ; sock -> state = SS_UNCONNECTED ; lookup_protocol : err = - ESOCKTNOSUPPORT ; rcu_read_lock ( ) ; list_for_each_entry_rcu ( answer , & inetsw [ sock -> type ] , list ) { err = 0 ; if ( protocol == answer -> protocol ) { if ( protocol != IPPROTO_IP ) break ; } else { if ( IPPROTO_IP == protocol ) { protocol = answer -> protocol ; break ; } if ( IPPROTO_IP == answer -> protocol ) break ; } err = - EPROTONOSUPPORT ; } if ( unlikely ( err ) ) { if ( try_loading_module < 2 ) { rcu_read_unlock ( ) ; if ( ++ try_loading_module == 1 ) request_module ( ""net-pf-%d-proto-%d-type-%d"" , PF_INET , protocol , sock -> type ) ; else request_module ( ""net-pf-%d-proto-%d"" , PF_INET , protocol ) ; goto lookup_protocol ; } else goto out_rcu_unlock ; } err = - EPERM ; if ( sock -> type == SOCK_RAW && ! kern && ! ns_capable ( net -> user_ns , CAP_NET_RAW ) ) goto out_rcu_unlock ; sock -> ops = answer -> ops ; answer_prot = answer -> prot ; answer_flags = answer -> flags ; rcu_read_unlock ( ) ; WARN_ON ( ! answer_prot -> slab ) ; err = - ENOBUFS ; sk = sk_alloc ( net , PF_INET , GFP_KERNEL , answer_prot , kern ) ; if ( ! sk ) goto out ; err = 0 ; if ( INET_PROTOSW_REUSE
",0,511
109,"int ip_options_get_from_user ( struct net * net , struct ip_options_rcu * * optp , unsigned char __user * data , int optlen ) { struct ip_options_rcu * opt = ip_options_get_alloc ( optlen ) ; if ( ! opt ) return - ENOMEM ; if ( optlen && copy_from_user ( & opt -> opt . __data , data , optlen ) ) { kfree ( opt ) ; return - EFAULT ; } return ip_options_get_finish ( net , optp , opt , optlen ) ; }
",0,134
110,"static int rfcomm_get_dev_list ( void __user * arg ) { struct rfcomm_dev * dev ; struct rfcomm_dev_list_req * dl ; struct rfcomm_dev_info * di ; int n = 0 , size , err ; u16 dev_num ; BT_DBG ( """" ) ; if ( get_user ( dev_num , ( u16 __user * ) arg ) ) return - EFAULT ; if ( ! dev_num || dev_num > ( PAGE_SIZE * 4 ) / sizeof ( * di ) ) return - EINVAL ; size = sizeof ( * dl ) + dev_num * sizeof ( * di ) ; dl = kzalloc ( size , GFP_KERNEL ) ; if ( ! dl ) return - ENOMEM ; di = dl -> dev_info ; spin_lock ( & rfcomm_dev_lock ) ; list_for_each_entry ( dev , & rfcomm_dev_list , list ) { if ( test_bit ( RFCOMM_TTY_RELEASED , & dev -> flags ) ) continue ; ( di + n ) -> id = dev -> id ; ( di + n ) -> flags = dev -> flags ; ( di + n ) -> state = dev -> dlc -> state ; ( di + n ) -> channel = dev -> channel ; bacpy ( & ( di + n ) -> src , & dev -> src ) ; bacpy ( & ( di + n ) -> dst , & dev -> dst ) ; if ( ++ n >= dev_num ) break ; } spin_unlock ( & rfcomm_dev_lock ) ; dl -> dev_num = n ; size = sizeof ( * dl ) + n * sizeof ( * di ) ; err = copy_to_user ( arg , dl , size ) ; kfree ( dl ) ; return err ? - EFAULT : 0 ; }
",1,426
111,"static void rpl_dio_print ( netdissect_options * ndo , const u_char * bp , u_int length ) { const struct nd_rpl_dio * dio = ( const struct nd_rpl_dio * ) bp ; const char * dagid_str ; ND_TCHECK ( * dio ) ; dagid_str = ip6addr_string ( ndo , dio -> rpl_dagid ) ; ND_PRINT ( ( ndo , ""[dagid:%s,seq:%u,instance:%u,rank:%u,%smop:%s,prf:%u]"" , dagid_str , dio -> rpl_dtsn , dio -> rpl_instanceid , EXTRACT_16BITS ( & dio -> rpl_dagrank ) , RPL_DIO_GROUNDED ( dio -> rpl_mopprf ) ? ""grounded,"" : """" , tok2str ( rpl_mop_values , ""mop%u"" , RPL_DIO_MOP ( dio -> rpl_mopprf ) ) , RPL_DIO_PRF ( dio -> rpl_mopprf ) ) ) ; if ( ndo -> ndo_vflag > 1 ) { const struct rpl_dio_genoption * opt = ( const struct rpl_dio_genoption * ) & dio [ 1 ] ; rpl_dio_printopt ( ndo , opt , length ) ; } return ; trunc : ND_PRINT ( ( ndo , ""[|truncated]"" ) ) ; return ; }
",0,375
112,"static u_int rpki_rtr_pdu_print ( netdissect_options * ndo , const u_char * tptr , const u_int len , const u_char * msg ) { const rpki_rtr_pdu * pdu_header ; u_int pdu_type , pdu_len , hexdump ; const u_char * msg ; ND_TCHECK_8BITS ( tptr ) ; ND_PRINT ( ( ndo , ""%sRPKI-RTRv%u,%sPDU(%u),length:%u"" , indent_string ( 8 ) , pdu_header -> version , tok2str ( rpki_rtr_pdu_values , ""Unknown"" , pdu_type ) , pdu_type , pdu_len ) ) ; switch ( pdu_type ) { case RPKI_RTR_SERIAL_NOTIFY_PDU : case RPKI_RTR_SERIAL_QUERY_PDU : case RPKI_RTR_END_OF_DATA_PDU : if ( len < sizeof ( rpki_rtr_pdu ) - 1 ) goto trunc ; ND_TCHECK2 ( * tptr , pdu_len ) ; hexdump = FALSE ; ND_PRINT ( ( ndo , ""%sSessionID:0x%04x,Serial:%u"" , indent_string ( indent + 2 ) , EXTRACT_16BITS ( pdu_header -> u . session_id ) , EXTRACT_32BITS ( msg ) ) ) ; break ; case RPKI_RTR_RESET_QUERY_PDU : case RPKI_RTR_CACHE_RESET_PDU : if ( len < sizeof ( rpki_rtr_pdu ) - 1 ) goto trunc ; ND_PRINT ( ( ndo , ""%sSessionID:0x%04x"" , indent_string ( indent + 2 ) , EXTRACT_16BITS ( pdu_header -> u . session_id ) ) ) ; break ; case RPKI_RTR_CACHE_RESPONSE_PDU : ND_PRINT ( ( ndo , ""%sSessionID:0x%04x"" , indent_string ( indent
",0,511
113,"int rose_rx_call_request ( struct sk_buff * skb , struct net_device * dev , struct rose_neigh * neigh , unsigned int lci ) { struct sock * sk ; struct sock * make ; struct rose_sock * make_rose ; struct rose_facilities_struct facilities ; int n ; skb -> sk = NULL ; memset ( & facilities , 0x00 , sizeof ( struct rose_facilities_struct ) ) ; if ( ( ( skb -> data [ 3 ] >> 4 ) & 0x0F ) + 1 ) >> 1 ; len += ( ( ( skb -> data [ 3 ] >> 0 ) & 0x0F ) + 1 ) >> 1 ; if ( ! rose_parse_facilities ( skb -> data + len + 4 , & facilities ) ) { rose_transmit_clear_request ( neigh , lci , ROSE_INVALID_FACILITY , 76 ) ; return 0 ; } sk = rose_find_listener ( & facilities . source_addr , & facilities . source_call ) ; if ( sk == NULL || sk_acceptq_is_full ( sk ) || ( make = rose_make_new ( sk ) ) == NULL ) { rose_transmit_clear_request ( neigh , lci , ROSE_NETWORK_CONGESTION , 120 ) ; return 0 ; } skb -> sk = make ; make -> sk_state = TCP_ESTABLISHED ; make_rose = rose_sk ( make ) ; make_rose -> lci = lci ; make_rose -> dest_addr = facilities . dest_addr ; make_rose -> dest_call = facilities . dest_call ; make_rose -> dest_ndigis = facilities . dest_ndigis ; for ( n = 0 ; n < facilities . dest_ndigis ; n ++ ) make_rose -> dest_digis [ n ] = facilities . dest_digis [ n ] ; make_rose -> source_addr = facilities . source_addr ; make_rose -> source_call = facilities . source_call ; make_rose -> source_ndigis = facilities . source_ndigis ; for ( n = 0 ; n < facilities . source_ndigis ; n ++ ) make_rose -> source_digis [ n ] = facilities . source_dig
",0,511
114,"int socket_accept ( int fd , uint16_t port ) { # ifdef WIN32 int addr_len ; # else socklen_t addr_len ; # endif int result ; struct sockaddr_in addr ; memset ( & addr , 0 , sizeof ( addr ) ) ; addr . sin_family = AF_INET ; addr . sin_addr . s_addr = htonl ( INADDR_LOOPBACK ) ; addr . sin_port = htons ( port ) ; addr_len = sizeof ( addr ) ; result = accept ( fd , ( struct sockaddr * ) & addr , & addr_len ) ; return result ; }
",1,144
115,"static char_u * did_set_string_option ( int opt_idx , char_u * * varp , int new_value_alloced , char_u * oldval , char_u * errbuf , int opt_flags ) { char_u * errmsg = NULL ; char_u * s , * p ; int did_chartab = FALSE ; char_u * * gvarp ; long_u free_oldval = ( options [ opt_idx ] . flags & P_ALLOCED ) ; # ifdef FEAT_GUI int redraw_gui_only = FALSE ; # endif gvarp = ( char_u * * ) get_varp_scope ( & ( options [ opt_idx ] ) , OPT_GLOBAL ) ; if ( ( secure # ifdef HAVE_SANDBOX || sandbox != 0 # endif ) && ( options [ opt_idx ] . flags & P_SECURE ) ) { errmsg = e_secure ; } else if ( ( options [ opt_idx ] . flags & P_NFNAME ) && vim_strpbrk ( * varp , ( char_u * ) ""/\\\\*?[|<>"" ) != NULL ) { errmsg = e_invarg ; } else if ( varp == & T_NAME ) { if ( T_NAME [ 0 ] == NUL ) errmsg = ( char_u * ) N_ ( ""E529:Cannotset\'term\'toemptystring"" ) ; # ifdef FEAT_GUI if ( gui . in_use ) errmsg = ( char_u * ) N_ ( ""E530:CannotchangeterminGUI"" ) ; else if ( term_is_gui ( T_NAME ) ) errmsg = ( char_u * ) N_ ( ""E531:Use\\"":gui\\""tostarttheGUI"" ) ; # endif else if ( set_termname ( T_NAME ) == FAIL ) errmsg = ( char_u * ) N_ ( ""E522:Notfoundintermcap"" ) ; else redraw_later_clear ( ) ; } else if ( gvarp == & p_bkc ) { char_u * bkc = p_bkc ; unsigned int * flags = & bkc_flags ; if (
",0,511
116,"int ceph_set_acl ( struct inode * inode , struct posix_acl * acl , int type ) { int ret = 0 , size = 0 ; const char * name = NULL ; char * value = NULL ; struct iattr newattrs ; umode_t new_mode = inode -> i_mode , old_mode = inode -> i_mode ; switch ( type ) { case ACL_TYPE_ACCESS : name = XATTR_NAME_POSIX_ACL_ACCESS ; if ( acl ) { ret = posix_acl_update_mode ( inode , & new_mode ) ; if ( ret < 0 ) goto out ; if ( ret == 0 ) acl = NULL ; } break ; case ACL_TYPE_DEFAULT : if ( ! S_ISDIR ( inode -> i_mode ) ) { ret = acl ? - EINVAL : 0 ; goto out ; } name = XATTR_NAME_POSIX_ACL_DEFAULT ; break ; default : ret = - EINVAL ; goto out ; } if ( acl ) { size = posix_acl_xattr_size ( acl -> a_count ) ; value = kmalloc ( size , GFP_NOFS ) ; if ( ! value ) { ret = - ENOMEM ; goto out ; } ret = posix_acl_to_xattr ( & init_user_ns , acl , value , size ) ; if ( ret < 0 ) goto out_free ; } if ( new_mode != old_mode ) { newattrs . ia_mode = new_mode ; newattrs . ia_valid = ATTR_MODE ; ret = __ceph_setattr ( inode , & newattrs ) ; if ( ret ) goto out_free ; } ret = __ceph_setxattr ( inode , name , value , size , 0 ) ; if ( ret ) { if ( new_mode != old_mode ) { newattrs . ia_mode = old_mode ; newattrs . ia_valid = ATTR_MODE ; __ceph_setattr ( inode , & newattrs ) ; } goto out_free ; } ceph_set_cached_acl ( inode , type , acl ) ; out_free : inode
",0,511
117,"static ssize_t o2nm_node_ipv4_address_store ( struct config_item * item , const char * page , size_t count ) { struct o2nm_node * node = to_o2nm_node ( item ) ; struct o2nm_cluster * cluster ; int ret , i ; struct rb_node * * p , * parent ; unsigned int octets [ 4 ] ; __be32 ipv4_addr = 0 ; ret = sscanf ( page , ""%3u.%3u.%3u.%3u"" , & octets [ 3 ] , & octets [ 2 ] , & octets [ 1 ] , & octets [ 0 ] ) ; if ( ret != 4 ) return - EINVAL ; for ( i = 0 ; i < ARRAY_SIZE ( octets ) ; i ++ ) { if ( octets [ i ] > 255 ) return - ERANGE ; be32_add_cpu ( & ipv4_addr , octets [ i ] << ( i * 8 ) ) ; } o2nm_lock_subsystem ( ) ; cluster = to_o2nm_cluster_from_node ( node ) ; if ( ! cluster ) { o2nm_unlock_subsystem ( ) ; return - EINVAL ; } ret = 0 ; write_lock ( & cluster -> cl_nodes_lock ) ; o2nm_unlock_subsystem ( ) ; if ( o2nm_node_ip_tree_lookup ( cluster , ipv4_addr , & p , & parent ) ) ret = - EEXIST ; else if ( test_and_set_bit ( O2NM_NODE_ATTR_ADDRESS , & node -> nd_set_attributes ) ) ret = - EBUSY ; else { rb_link_node ( & node -> nd_ip_node , parent , p ) ; rb_insert_color ( & node -> nd_ip_node , & cluster -> cl_node_ip_tree ) ; } write_unlock ( & cluster -> cl_nodes_lock ) ; if ( ret ) return ret ; memcpy ( & node -> nd_ipv4_address , & ipv4_addr , sizeof ( ipv4_addr ) ) ; return count
",0,512
118,"u_int null_if_print ( netdissect_options * ndo , const struct pcap_pkthdr * h , const u_char * p ) { u_int length = h -> len ; u_int caplen = h -> caplen ; u_int family ; if ( caplen < NULL_HDRLEN ) { ND_PRINT ( ( ndo , ""[|null]"" ) ) ; return ( NULL_HDRLEN ) ; } memcpy ( ( char * ) & family , ( const char * ) p , sizeof ( family ) ) ; if ( ( family & 0xFFFF0000 ) != 0 ) family = SWAPLONG ( family ) ; if ( ndo -> ndo_eflag ) null_hdr_print ( ndo , family , length ) ; length -= NULL_HDRLEN ; caplen -= NULL_HDRLEN ; p += NULL_HDRLEN ; switch ( family ) { case BSD_AFNUM_INET : ip_print ( ndo , p , length ) ; break ; case BSD_AFNUM_INET6_BSD : case BSD_AFNUM_INET6_FREEBSD : case BSD_AFNUM_INET6_DARWIN : ip6_print ( ndo , p , length ) ; break ; case BSD_AFNUM_ISO : isoclns_print ( ndo , p , length , caplen ) ; break ; case BSD_AFNUM_APPLETALK : atalk_print ( ndo , p , length ) ; break ; case BSD_AFNUM_IPX : ipx_print ( ndo , p , length ) ; break ; default : if ( ! ndo -> ndo_eflag ) null_hdr_print ( ndo , family , length + NULL_HDRLEN ) ; if ( ! ndo -> ndo_suppress_default_print ) ND_DEFAULTPRINT ( p , caplen ) ; } return ( NULL_HDRLEN ) ; }
",1,454
119,"static int cleanup_pathname ( struct archive_write_disk * a ) { char * dest , * src ; char separator = '\\0' ; dest = src = a -> name ; if ( * src == '\\0' ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC , ""Invalidemptypathname"" ) ; return ( ARCHIVE_FAILED ) ; } # if defined ( __CYGWIN__ ) cleanup_pathname_win ( a ) ; # endif if ( * src == '/' ) { separator = * src ++ ; } for ( ; ; ) { if ( src [ 0 ] == '\\0' ) { break ; } else if ( src [ 0 ] == '/' ) { src ++ ; continue ; } else if ( src [ 0 ] == '.' ) { if ( src [ 1 ] == '\\0' ) { break ; } else if ( src [ 1 ] == '/' ) { src += 2 ; continue ; } else if ( src [ 1 ] == '.' ) { if ( src [ 2 ] == '/' || src [ 2 ] == '\\0' ) { if ( a -> flags & ARCHIVE_EXTRACT_SECURE_NODOTDOT ) { archive_set_error ( & a -> archive , ARCHIVE_ERRNO_MISC , ""Pathcontains\'..\'"" ) ; return ( ARCHIVE_FAILED ) ; } } } } } if ( separator ) * dest ++ = '/' ; while ( * src != '\\0' && * src != '/' ) { * dest ++ = * src ++ ; } if ( * src == '\\0' ) break ; separator = * src ++ ; } if ( dest == a -> name ) { if ( separator ) * dest ++ = '/' ; else * dest ++ = '.' ; } * dest = '\\0' ; return ( ARCHIVE_OK ) ; }
",0,434
120,"TPM_RC tpm_kdfa ( TPMI_ALG_HASH hashAlg , TPM2B * key , char * label , TPM2B * contextU , TPM2B * contextV , UINT16 bits , TPM2B_MAX_BUFFER * resultKey ) { TPM2B_DIGEST tpm2bLabel , tpm2bBits , tpm2b_i_2 ; UINT8 * tpm2bBitsPtr = & tpm2bBits . t . buffer [ 0 ] ; UINT8 * tpm2b_i_2Ptr = & tpm2b_i_2 . t . buffer [ 0 ] ; TPM2B_DIGEST * bufferList [ 8 ] ; UINT32 bitsSwizzled , i_Swizzled ; TPM_RC rval = TPM_RC_SUCCESS ; int i , j ; UINT16 bytes = bits / 8 ; resultKey -> t . size = 0 ; tpm2b_i_2 . t . size = 4 ; tpm2bBits . t . size = 4 ; bitsSwizzled = string_bytes_endian_convert_32 ( bits ) ; * ( UINT32 * ) tpm2bBitsPtr = bitsSwizzled ; for ( i = 0 ; label [ i ] != 0 ; i ++ ) ; tpm2bLabel . t . size = i + 1 ; for ( i = 0 ; i < tpm2bLabel . t . size ; i ++ ) { tpm2bLabel . t . buffer [ i ] = label [ i ] ; } resultKey -> t . size = 0 ; i = 1 ; const EVP_MD * md = tpm_algorithm_to_openssl_digest ( hashAlg ) ; if ( ! md ) { LOG_ERR ( ""Algorithmnotsupportedforhmac:%x"" , hashAlg ) ; return TPM_RC_HASH ; } HMAC_CTX ctx ; HMAC_CTX_init ( & ctx ) ; int rc = HMAC_Init_ex ( & ctx , key -> buffer , key -> size , md , NULL ) ; if ( rc != 0 ) { LOG_ERR ( ""HMACInitfailed
",0,511
121,"static jas_image_cmpt_t * jas_image_cmpt_create ( int_fast32_t tlx , int_fast32_t tly , int_fast32_t hstep , int_fast32_t vstep , int_fast32_t width , int_fast32_t height , uint_fast16_t depth , bool sgnd , uint_fast32_t inmem ) { jas_image_cmpt_t * cmpt ; size_t size ; size = 0 ; cmpt = 0 ; if ( width < 0 || height < 0 || hstep <= 0 || vstep <= 0 ) { goto error ; } if ( ! jas_safe_intfast32_add ( tlx , width , 0 ) || ! jas_safe_intfast32_add ( tly , height , 0 ) ) { goto error ; } if ( ! ( cmpt = jas_malloc ( sizeof ( jas_image_cmpt_t ) ) ) ) { goto error ; } cmpt -> type_ = JAS_IMAGE_CT_UNKNOWN ; cmpt -> tlx_ = tlx ; cmpt -> tly_ = tly ; cmpt -> hstep_ = hstep ; cmpt -> vstep_ = vstep ; cmpt -> width_ = width ; cmpt -> height_ = height ; cmpt -> prec_ = depth ; cmpt -> sgnd_ = sgnd ; cmpt -> stream_ = 0 ; cmpt -> cps_ = ( depth + 7 ) / 8 ; if ( ! jas_safe_size_mul ( size , cmpt -> width_ , cmpt -> height_ , & size ) || ! jas_safe_size_mul ( size , cmpt -> cps_ , & size ) ) { goto error ; } cmpt -> stream_ = ( inmem ) ? jas_stream_memopen2 ( 0 , size ) : jas_stream_tmpfile ( ) ; if ( ! cmpt -> stream_ ) { goto error ; } if ( size > 0 ) { if ( size - 1 > LONG_MAX ) { goto error ; } if ( jas_stream_seek ( cmpt -> stream_ , size - 1 , SEEK_SET ) < 0 || jas_stream
",0,511
122,"tdata_t _TIFFmalloc ( tsize_t s ) { if ( s == 0 ) return ( ( void * ) NULL ) ; return ( malloc ( ( size_t ) s ) ) ; }
",1,48
123,"static ssize_t qib_write ( struct file * fp , const char __user * data , size_t count , loff_t * off ) { const struct qib_cmd __user * ucmd ; struct qib_ctxtdata * rcd ; const void __user * src ; size_t consumed , copy = 0 ; struct qib_cmd cmd ; ssize_t ret = 0 ; void * dest ; if ( WARN_ON_ONCE ( ! ib_safe_file_access ( fp ) ) ) return - EACCES ; if ( count < sizeof ( cmd . type ) ) { ret = - EINVAL ; goto bail ; } ucmd = ( const struct qib_cmd __user * ) data ; if ( copy_from_user ( & cmd . type , & ucmd -> type , sizeof ( cmd . type ) ) ) { ret = - EFAULT ; goto bail ; } consumed = sizeof ( cmd . type ) ; switch ( cmd . type ) { case QIB_CMD_ASSIGN_CTXT : case QIB_CMD_USER_INIT : copy = sizeof ( cmd . cmd . user_info ) ; dest = & cmd . cmd . user_info ; src = & ucmd -> cmd . user_info ; break ; case QIB_CMD_RECV_CTRL : copy = sizeof ( cmd . cmd . recv_ctrl ) ; dest = & cmd . cmd . recv_ctrl ; src = & ucmd -> cmd . recv_ctrl ; break ; case QIB_CMD_CTXT_INFO : copy = sizeof ( cmd . cmd . ctxt_info ) ; dest = & cmd . cmd . ctxt_info ; src = & ucmd -> cmd . ctxt_info ; break ; case QIB_CMD_TID_UPDATE : case QIB_CMD_TID_FREE : copy = sizeof ( cmd . cmd . tid_info ) ; dest = & cmd . cmd . tid_info ; src = & ucmd -> cmd . tid_info ; break ; case QIB_CMD_SET_PART_KEY : copy = sizeof ( cmd . cmd . part_key ) ; dest = & cmd . cmd . part_key ; src = & ucmd -> cmd . part_key ; break ; case QIB_CMD_DISARM_BU
",0,511
124,"static Image * ReadMATImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image , * image2 = NULL , * rotated_image ; register Quantum * q ; unsigned int status ; MATHeader MATLAB_HDR ; size_t size ; size_t CellType ; QuantumInfo * quantum_info ; ImageInfo * clone_info ; int i ; ssize_t ldblk ; unsigned char * BImgBuff = NULL ; double MinVal , MaxVal ; unsigned z , z2 ; unsigned Frames ; int logging ; int sample_size ; MagickOffsetType filepos = 0x80 ; BlobInfo * blob ; size_t one ; unsigned int ( * ReadBlobXXXLong ) ( Image * image ) ; unsigned short ( * ReadBlobXXXShort ) ( Image * image ) ; void ( * ReadBlobDoublesXXX ) ( Image * image , size_t len , double * data ) ; void ( * ReadBlobFloatsXXX ) ( Image * image , size_t len , float * data ) ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; logging = LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""enter"" ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } clone_info = CloneImageInfo ( image_info ) ; if ( ReadBlob ( image , 124 , ( unsigned char * ) & MATLAB_HDR . identific ) != 124 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( strncmp ( MATLAB_HDR . identific , ""MATLAB"" , 6 ) != 0 ) { image2 = ReadMATImageV4 ( image_info , image , exception ) ; if ( image2 == NULL ) goto MATLAB_KO ; image = image2 ; goto END_OF_READING ; } MATLAB_HDR . Version = ReadBl
",0,511
125,"struct net * get_net_ns_by_id ( struct net * net , int id ) { struct net * peer ; if ( id < 0 ) return NULL ; rcu_read_lock ( ) ; spin_lock_bh ( & net -> nsid_lock ) ; peer = idr_find ( & net -> netns_ids , id ) ; if ( peer ) peer = maybe_get_net ( peer ) ; spin_unlock_bh ( & net -> nsid_lock ) ; rcu_read_unlock ( ) ; return peer ; }
",1,124
126,"void * getHTTPResponse ( int s , int * size ) { char buf [ 2048 ] ; int n ; int endofheaders = 0 ; int chunked = 0 ; int content_length = - 1 ; unsigned int chunksize = 0 ; unsigned int bytestocopy = 0 ; char * header_buf ; unsigned int header_buf_len = 2048 ; unsigned int header_buf_used = 0 ; char * content_buf ; unsigned int content_buf_len = 2048 ; unsigned int content_buf_used = 0 ; char chunksize_buf [ 32 ] ; unsigned int chunksize_buf_index ; header_buf = malloc ( header_buf_len ) ; content_buf = malloc ( content_buf_len ) ; chunksize_buf [ 0 ] = '\\0' ; chunksize_buf_index = 0 ; while ( ( n = receivedata ( s , buf , 2048 , 5000 , NULL ) ) > 0 ) { if ( endofheaders == 0 ) { int i ; int linestart = 0 ; int colon = 0 ; int valuestart = 0 ; if ( header_buf_used + n > header_buf_len ) { header_buf = realloc ( header_buf , header_buf_used + n ) ; header_buf_len = header_buf_used + n ; } memcpy ( header_buf + header_buf_used , buf , n ) ; header_buf_used += n ; i = 0 ; while ( i < ( ( int ) header_buf_used - 1 ) && ( endofheaders == 0 ) ) { if ( header_buf [ i ] == '\\r' ) { i ++ ; if ( header_buf [ i ] == '\\n' ) { i ++ ; if ( i < ( int ) header_buf_used && header_buf [ i ] == '\\r' ) { i ++ ; if ( i < ( int ) header_buf_used && header_buf [ i ] == '\\n' ) { endofheaders = i + 1 ; } } } } } else if ( header_buf [ i ] == '\\n' ) { i ++ ; if ( header_buf [ i ] == '\\n' ) { endofheaders = i + 1 ; } } i ++ ; } if ( endofheaders == 0 ) continue ; for
",0,511
127,"static int _lldp_send ( struct lldpd * global , struct lldpd_hardware * hardware , u_int8_t c_id_subtype , char * c_id , int c_id_len , u_int8_t p_id_subtype , char * p_id , int p_id_len , int shutdown ) { struct lldpd_port * port ; struct lldpd_chassis * chassis ; struct lldpd_frame * frame ; int length ; u_int8_t * packet , * pos , * tlv ; struct lldpd_mgmt * mgmt ; int proto ; u_int8_t mcastaddr [ ] = LLDP_MULTICAST_ADDR ; # ifdef ENABLE_DOT1 const u_int8_t dot1 [ ] = LLDP_TLV_ORG_DOT1 ; struct lldpd_vlan * vlan ; struct lldpd_ppvid * ppvid ; struct lldpd_pi * pi ; # endif # ifdef ENABLE_DOT3 const u_int8_t dot3 [ ] = LLDP_TLV_ORG_DOT3 ; # endif # ifdef ENABLE_LLDPMED int i ; const u_int8_t med [ ] = LLDP_TLV_ORG_MED ; # endif # ifdef ENABLE_CUSTOM struct lldpd_custom * custom ; # endif port = & hardware -> h_lport ; chassis = port -> p_chassis ; length = hardware -> h_mtu ; if ( ( packet = ( u_int8_t * ) calloc ( 1 , length ) ) == NULL ) return ENOMEM ; pos = packet ; if ( ! ( POKE_BYTES ( mcastaddr , sizeof ( mcastaddr ) ) && POKE_BYTES ( & hardware -> h_lladdr , ETHER_ADDR_LEN ) && POKE_UINT16 ( ETHERTYPE_LLDP ) ) ) goto toobig ; if ( ! ( POKE_START_LLDP_TLV ( LLDP_TLV_CHASSIS_ID ) && POKE_UINT8 ( c_id_subtype ) && POKE_BYTES
",0,511
128,"int asn1_ber_decoder ( const struct asn1_decoder * decoder , void * context , const unsigned char * data , size_t datalen ) { const unsigned char * machine = decoder -> machine ; const asn1_action_t * actions = decoder -> actions ; size_t machlen = decoder -> machlen ; enum asn1_opcode op ; unsigned char tag = 0 , csp = 0 , jsp = 0 , optag = 0 , hdr = 0 ; const char * errmsg ; size_t pc = 0 , dp = 0 , tdp = 0 , len = 0 ; int ret ; unsigned char flags = 0 ; # define FLAG_INDEFINITE_LENGTH 0x01 # define FLAG_MATCHED 0x02 # define FLAG_LAST_MATCHED 0x04 # define FLAG_CONS 0x20 # define NR_CONS_STACK 10 unsigned short cons_dp_stack [ NR_CONS_STACK ] ; unsigned short cons_datalen_stack [ NR_CONS_STACK ] ; unsigned char cons_hdrlen_stack [ NR_CONS_STACK ] ; # define NR_JUMP_STACK 10 unsigned char jump_stack [ NR_JUMP_STACK ] ; if ( datalen > 65535 ) return - EMSGSIZE ; next_op : pr_debug ( ""next_op:pc=\\e[32m%zu\\e[m/%zudp=\\e[33m%zu\\e[m/%zuC=%dJ=%d\\n"" , pc , machlen , dp , datalen , csp , jsp ) ; if ( unlikely ( pc >= machlen ) ) goto machine_overrun_error ; op = machine [ pc ] ; if ( unlikely ( pc + asn1_op_lengths [ op ] > machlen ) ) goto machine_overrun_error ; if ( op <= ASN1_OP__MATCHES_TAG ) { unsigned char tmp ; if ( ( op & ASN1_OP_MATCH__COND && flags & FLAG_MATCHED ) || dp == datalen ) { flags &= ~ FLAG_LAST_MATCHED ; pc += AS
",0,511
129,"static int sctp_init_sock ( struct sock * sk ) { struct net * net = sock_net ( sk ) ; spin_lock_bh ( & net -> sctp . sock_lock ) ; sp = sctp_sk ( sk ) ; switch ( sk -> sk_type ) { case SOCK_SEQPACKET : sp -> type = SCTP_SOCKET_UDP ; break ; case SOCK_STREAM : sp -> type = SCTP_SOCKET_TCP ; break ; default : return - ESOCKTNOSUPPORT ; } sp -> default_stream = 0 ; sp -> default_ppid = 0 ; sp -> default_flags = 0 ; sp -> default_context = 0 ; sp -> default_timetolive = 0 ; sp -> default_rcv_context = 0 ; sp -> max_burst = net -> sctp . max_burst ; sp -> sctp_hmac_alg = net -> sctp . sctp_hmac_alg ; sp -> initmsg . sinit_num_ostreams = sctp_max_outstreams ; sp -> initmsg . sinit_max_instreams = sctp_max_instreams ; sp -> initmsg . sinit_max_attempts = net -> sctp . max_retrans_init ; sp -> initmsg . sinit_max_init_timeo = net -> sctp . rto_max ; sp -> rtoinfo . srto_initial = net -> sctp . rto_initial ; sp -> rtoinfo . srto_max = net -> sctp . rto_max ; sp -> rtoinfo . srto_min = net -> sctp . rto_min ; sp -> assocparams . sasoc_asocmaxrxt = net -> sctp . max_retrans_association ; sp -> assocparams . sasoc_number_peer_destinations = 0 ; sp -> assocparams . sasoc_peer_rwnd = 0 ; sp -> assocparams . sasoc_local_rwnd = 0 ; sp -> assocparams . sasoc_cookie_life = net -> sctp . sasoc_cookie_life ; sp -> sasoc
",0,511
130,"static int mpeg4_decode_profile_level ( MpegEncContext * s , GetBitContext * gb , int * profile , int * level ) { * profile = get_bits ( gb , 4 ) ; * level = get_bits ( gb , 4 ) ; if ( * profile == 0 && s -> avctx -> level == 8 ) { * level = 0 ; } return 0 ; }
",1,90
131,"void snd_msndmidi_input_read ( void * mpuv ) { unsigned long flags ; struct snd_msndmidi * mpu = mpuv ; void * pwMIDQData = mpu -> dev -> mappedbase + MIDQ_DATA_BUFF ; u16 head , tail , size ; spin_lock_irqsave ( & mpu -> input_lock , flags ) ; head = readw ( mpu -> dev -> MIDQ + JQS_wHead ) ; tail = readw ( mpu -> dev -> MIDQ + JQS_wTail ) ; size = readw ( pwMIDQData + 2 * head + 2 * tail ) ; if ( head > size ) goto out ; while ( head != tail ) { unsigned char val = readw ( pwMIDQData + 2 * head + 2 * tail ) ; if ( test_bit ( MSNDMIDI_MODE_BIT_INPUT_TRIGGER , & mpu -> mode ) ) snd_rawmidi_receive ( mpu -> substream_input , ( unsigned char * ) & val , size ) ; else writew ( head , mpu -> dev -> MIDQ + JQS_wHead ) ; else writew ( head , mpu -> dev -> MIDQ + JQS_wHead ) ; } spin_unlock_irqrestore ( & mpu -> input_lock , flags ) ; }
",0,320
132,"static int ima_lsm_rule_init ( struct ima_measure_rule_entry * entry , char * args , int lsm_rule , int audit_type ) { int result ; if ( entry -> lsm [ lsm_rule ] . rule ) return - EINVAL ; entry -> lsm [ lsm_rule ] . type = audit_type ; result = security_filter_rule_init ( entry -> lsm [ lsm_rule ] . type , Audit_equal , args , & entry -> lsm [ lsm_rule ] . rule ) ; if ( ! entry -> lsm [ lsm_rule ] . rule ) return - EINVAL ; return result ; }
",1,153
133,"void put_filp ( struct file * file ) { if ( atomic_long_dec_and_test ( & file -> f_count ) ) { security_file_free ( file ) ; file_sb_list_del ( file ) ; file_free ( file ) ; } }
",0,63
134,"static void ikev2_parent_inI1outR1_continue ( struct pluto_crypto_req_cont * pcrc , struct pluto_crypto_req * r , err_t ugh ) { struct ke_continuation * ke = ( struct ke_continuation * ) pcrc ; struct msg_digest * md = ke -> md ; struct state * const st = md -> st ; stf_status e ; DBG ( DBG_CONTROLMORE , DBG_log ( ""ikev2parentinI1outR1:calculatedke+nonce,sendingR1"" ) ) ; if ( st == NULL ) { loglog ( RC_LOG_SERIOUS , ""%s:Requestwasdisconnectedfromstate"" , __FUNCTION__ ) ; if ( ke -> md ) release_md ( ke -> md ) ; return ; } passert ( ugh == NULL ) ; passert ( cur_state == NULL ) ; passert ( st != NULL ) ; passert ( st -> st_suspended_md == ke -> md ) ; set_suspended ( st , NULL ) ; set_cur_state ( st ) ; st -> st_calculating = FALSE ; e = ikev2_parent_inI1outR1_tail ( pcrc , r ) ; if ( ke -> md != NULL ) { complete_v2_state_transition ( & ke -> md , e ) ; if ( ke -> md ) release_md ( ke -> md ) ; } reset_globals ( ) ; }
",1,344
135,"static int oidc_handle_session_management_iframe_rp ( request_rec * r , oidc_cfg * c , oidc_session_t * session , const char * client_id , const char * check_session_iframe ) { oidc_debug ( r , ""enter"" ) ; const char * java_script = ""<scripttype=\\""text/javascript\\>\\n"" ""vartargetOrigin=\'%s\';\\n"" ""varmessage=\'%s\'+\'\'+\'%s\';\\n"" ""\tvartimerID;\\n"" ""\\n"" ""functioncheckSession(){\\n"" ""console.debug(\'checkSession:posting\'+message+\'to\'+targetOrigin);\\n"" ""varwin=window.parent.document.getElementById(\'%s\').contentWindow;\\n"" ""win.postMessage(message,targetOrigin);\\n"" ""}\\n"" ""\\n"" ""functionsetTimer(){\\n"" ""checkSession();\\n"" ""timerID=setInterval(\'checkSession()\',%s);\\n"" ""}\\n"" ""\\n"" ""functionreceiveMessage(e){\\n"" ""console.debug(\'receiveMessage:\'+e.data+\'from\'+e.origin);\\n"" ""if(e.origin
",0,311
136,"static int decode_getacl ( struct xdr_stream * xdr , struct rpc_rqst * req , size_t * acl_len ) { __be32 * savep ; uint32_t attrlen , bitmap [ 3 ] = { 0 , 0 } ; struct kvec * iov = req -> rq_rcv_buf . head ; int status ; * acl_len = 0 ; if ( ( status = decode_op_hdr ( xdr , OP_GETATTR ) ) != 0 ) goto out ; if ( ( status = decode_attr_bitmap ( xdr , bitmap ) ) != 0 ) goto out ; if ( ( status = decode_attr_length ( xdr , & attrlen , & savep ) ) != 0 ) goto out ; if ( unlikely ( bitmap [ 0 ] & ( FATTR4_WORD0_ACL - 1U ) ) ) return - EIO ; if ( likely ( bitmap [ 0 ] & FATTR4_WORD0_ACL ) ) { size_t hdrlen ; u32 recvd ; hdrlen = ( u8 * ) xdr -> p - ( u8 * ) iov -> iov_base ; recvd = req -> rq_rcv_buf . len - hdrlen ; if ( attrlen > recvd ) { dprintk ( ""NFS:servercheatingingetattr"" ""aclreply:attrlen%u>recvd%u\\n"" , attrlen , recvd ) ; return - EINVAL ; } xdr_read_pages ( xdr , attrlen ) ; * acl_len = attrlen ; } else status = - EOPNOTSUPP ; out : return status ; }
",0,389
137,"static struct sk_buff * udp6_ufo_fragment ( struct sk_buff * skb , netdev_features_t features ) { struct sk_buff * segs = ERR_PTR ( - EINVAL ) ; unsigned int mss ; unsigned int unfrag_ip6hlen , unfrag_len ; struct frag_hdr * fptr ; u8 * packet_start , * prevhdr ; u8 nexthdr ; u8 frag_hdr_sz = sizeof ( struct frag_hdr ) ; __wsum csum ; int tnl_hlen ; mss = skb_shinfo ( skb ) -> gso_size ; if ( unlikely ( skb -> len <= mss ) ) goto out ; if ( skb_gso_ok ( skb , features | NETIF_F_GSO_ROBUST ) ) { skb_shinfo ( skb ) -> gso_segs = DIV_ROUND_UP ( skb -> len , mss ) ; if ( ! skb_shinfo ( skb ) -> ip6_frag_id ) ipv6_proxy_select_ident ( dev_net ( skb -> dev ) , skb ) ; segs = NULL ; goto out ; } if ( skb -> encapsulation && skb_shinfo ( skb ) -> gso_type & ( SKB_GSO_UDP_TUNNEL | SKB_GSO_UDP_TUNNEL_CSUM ) ) segs = skb_udp_tunnel_segment ( skb , features , true ) ; else { const struct ipv6hdr * ipv6h ; struct udphdr * uh ; if ( ! pskb_may_pull ( skb , sizeof ( struct udphdr ) ) ) goto out ; uh = udp_hdr ( skb ) ; ipv6h = ipv6_hdr ( skb ) ; uh -> check = 0 ; csum = skb_checksum ( skb , 0 , skb -> len , 0 ) ; uh -> check = udp_v6_check ( skb -> len , & ipv6h -> saddr , & ipv6h -> daddr , csum ) ; if (
",0,511
138,"GF_Err urn_Read ( GF_Box * s , GF_BitStream * bs ) { u32 i , to_read ; char * tmpName ; GF_DataEntryURNBox * ptr = ( GF_DataEntryURNBox * ) s ; if ( ! ptr -> size ) return GF_OK ; to_read = ( u32 ) ptr -> size ; tmpName = ( char * ) gf_malloc ( sizeof ( char ) * to_read ) ; if ( ! tmpName ) return GF_OUT_OF_MEM ; gf_bs_read_data ( bs , tmpName , to_read ) ; i = 0 ; while ( ( i < to_read ) && ( tmpName [ i ] != 0 ) ) { i ++ ; } if ( i == to_read ) { gf_free ( tmpName ) ; return GF_ISOM_INVALID_FILE ; } if ( i == to_read - 1 ) { ptr -> nameURN = tmpName ; ptr -> location = NULL ; return GF_OK ; } ptr -> nameURN = ( char * ) gf_malloc ( sizeof ( char ) * ( i + 1 ) ) ; if ( ! ptr -> nameURN ) { gf_free ( tmpName ) ; return GF_OUT_OF_MEM ; } ptr -> location = ( char * ) gf_malloc ( sizeof ( char ) * ( to_read - i - 1 ) ) ; if ( ! ptr -> location ) { gf_free ( tmpName ) ; gf_free ( ptr -> nameURN ) ; ptr -> nameURN = NULL ; return GF_OUT_OF_MEM ; } memcpy ( ptr -> nameURN , tmpName , i + 1 ) ; memcpy ( ptr -> location , tmpName + i + 1 , ( to_read - i - 1 ) ) ; gf_free ( tmpName ) ; return GF_OK ; }
",1,422
139,"static inline void jiffies_to_compat_timeval ( unsigned long jiffies , struct compat_timeval * value ) { u64 nsec = ( u64 ) jiffies * TICK_NSEC ; u32 rem ; value -> tv_sec = div_u64_rem ( nsec , NSEC_PER_SEC , & rem ) ; value -> tv_usec = rem / NSEC_PER_USEC ; }
",1,99
140,"static int filter_frame ( AVFilterLink * inlink , AVFrame * in ) { AVFilterContext * ctx = inlink -> dst ; FlipContext * s = ctx -> priv ; AVFilterLink * outlink = ctx -> outputs [ 0 ] ; AVFrame * out ; uint8_t * inrow , * outrow ; int i , j , plane , step ; out = ff_get_video_buffer ( outlink , outlink -> w , outlink -> h ) ; if ( ! out ) { av_frame_free ( & in ) ; return AVERROR ( ENOMEM ) ; } av_frame_copy_props ( out , in ) ; if ( av_pix_fmt_desc_get ( inlink -> format ) -> flags & AV_PIX_FMT_FLAG_PAL ) memcpy ( out -> data [ 1 ] , in -> data [ 1 ] , AVPALETTE_SIZE ) ; for ( plane = 0 ; plane < 4 && in -> data [ plane ] && in -> linesize [ plane ] ; plane ++ ) { const int width = ( plane == 1 || plane == 2 ) ? FF_CEIL_RSHIFT ( inlink -> w , s -> hsub ) : inlink -> w ; const int height = ( plane == 1 || plane == 2 ) ? FF_CEIL_RSHIFT ( inlink -> h , s -> vsub ) : inlink -> h ; step = s -> max_step [ plane ] ; outrow = out -> data [ plane ] ; inrow = in -> data [ plane ] + ( width - 1 ) * step ; for ( i = 0 ; i < height ; i ++ ) { switch ( step ) { case 1 : for ( j = 0 ; j < width ; j ++ ) outrow [ j ] = inrow [ - j ] ; break ; case 2 : { uint16_t * outrow16 = ( uint16_t * ) outrow ; uint16_t * inrow16 = ( uint16_t * ) inrow ; for ( j = 0 ; j < width ; j ++ ) outrow16 [ j ] = inrow16 [ - j ] ; } break ; case 3 : { uint8_t * in = inrow ; uint8_t * out = outrow ; for ( j = 0 ; j <
",0,511
141,"BOOL SQLWriteFileDSN ( LPCSTR pszFileName , LPCSTR pszAppName , LPCSTR pszKeyName , LPCSTR pszString ) { HINI hIni ; char szFileName [ ODBC_FILENAME_MAX + 1 ] ; if ( pszFileName [ 0 ] == '/' ) { strncpy ( szFileName , pszFileName , sizeof ( szFileName ) - 5 ) ; } else { char szPath [ ODBC_FILENAME_MAX + 1 ] ; * szPath = '\\0' ; _odbcinst_FileINI ( szPath ) ; snprintf ( szFileName , sizeof ( szFileName ) - 5 , ""%s/%s"" , szPath , pszFileName ) ; } if ( strlen ( szFileName ) < 4 || strcmp ( szFileName + strlen ( szFileName ) - 4 , "".dsn"" ) ) { strcat ( szFileName , "".dsn"" ) ; } # ifdef __OS2__ if ( iniOpen ( & hIni , szFileName , ""#;"" , '[' , ']' , '=' , TRUE , 0L ) != INI_SUCCESS ) # else if ( iniOpen ( & hIni , szFileName , ""#;"" , '[' , ']' , '=' , TRUE ) != INI_SUCCESS ) # endif { inst_logPushMsg ( __FILE__ , __FILE__ , __LINE__ , LOG_CRITICAL , ODBC_ERROR_INVALID_PATH , """" ) ; return FALSE ; } if ( pszString == NULL && pszKeyName == NULL ) { if ( iniObjectSeek ( hIni , ( char * ) pszAppName ) == INI_SUCCESS ) { iniObjectDelete ( hIni ) ; } } else if ( pszString == NULL ) { if ( iniPropertySeek ( hIni , ( char * ) pszAppName , ( char * ) pszKeyName , """" ) == INI_SUCCESS ) { iniPropertyDelete ( hIni ) ; } } else { if ( iniObjectSeek ( hIni , ( char * )
",0,511
142,"static int makeDirDirective ( MaState * state , cchar * key , cchar * value ) { MprPath info ; char * auth , * dirs , * path , * perms , * tok ; cchar * dir , * group , * owner ; int gid , mode , uid ; if ( ! maTokenize ( state , value , ""%S?*"" , & auth , & dirs ) ) { return MPR_ERR_BAD_SYNTAX ; } uid = gid = 0 ; mode = 0750 ; if ( schr ( auth , ':' ) ) { owner = stok ( auth , "":"" , & tok ) ; if ( owner && * owner ) { if ( snumber ( owner ) ) { uid = ( int ) stoi ( owner ) ; } else if ( smatch ( owner , ""APPWEB"" ) ) { uid = HTTP -> uid ; } else { uid = userToID ( owner ) ; } } group = stok ( tok , "":"" , & perms ) ; if ( group && * group ) { if ( snumber ( group ) ) { gid = ( int ) stoi ( group ) ; } else if ( smatch ( owner , ""APPWEB"" ) ) { gid = HTTP -> gid ; } else { gid = groupToID ( group ) ; } } if ( perms && snumber ( perms ) ) { mode = ( int ) stoiradix ( perms , - 1 , NULL ) ; } else { mode = 0 ; } if ( gid < 0 || uid < 0 ) { return MPR_ERR_BAD_SYNTAX ; } } } else { dirs = auth ; auth = 0 ; } tok = dirs ; for ( tok = sclone ( dirs ) ; ( dir = stok ( tok , "","" , & tok ) ) != 0 ; ) { path = httpMakePath ( state -> route , state -> configDir , dir ) ; if ( mprGetPathInfo ( path , & info ) == 0 && info . isDir ) { continue ; } if ( mprMakeDir ( path , mode , uid , gid , 1 ) < 0 ) { return MPR_ERR_BAD_SYNTAX ; } }
",0,510
143,"int cdf_read_property_info ( const cdf_stream_t * sst , const cdf_header_t * h , uint32_t offs , cdf_property_info_t * * info , size_t * count , size_t * maxcount ) { const cdf_section_header_t * shp ; cdf_section_header_t sh ; const uint8_t * p , * q , * e ; int16_t s16 ; int32_t s32 ; uint32_t u32 ; int64_t s64 ; uint64_t u64 ; cdf_timestamp_t tp ; size_t i , o , o4 , nelements , j ; cdf_property_info_t * inp ; if ( offs > UINT32_MAX / 4 ) { errno = EFTYPE ; goto out ; } shp = CAST ( const cdf_section_header_t * , ( const void * ) ( ( const char * ) sst -> sst_tab + offs ) ) ; if ( cdf_check_stream_offset ( sst , h , shp , sizeof ( * shp ) , __LINE__ ) == - 1 ) goto out ; sh . sh_len = CDF_TOLE4 ( shp -> sh_len ) ; # define CDF_SHLEN_LIMIT ( UINT32_MAX / 8 ) if ( sh . sh_len > CDF_SHLEN_LIMIT ) { errno = EFTYPE ; goto out ; } sh . sh_properties = CDF_TOLE4 ( shp -> sh_properties ) ; # define CDF_PROP_LIMIT ( UINT32_MAX / ( 4 * sizeof ( * inp ) ) ) if ( sh . sh_properties > CDF_PROP_LIMIT ) goto out ; DPRINTF ( ( ""sectionlen:%uproperties%u\\n"" , sh . sh_len , sh . sh_properties ) ) ; if ( * maxcount ) { if ( * maxcount > CDF_PROP_LIMIT ) goto out ; * maxcount += sh . sh_properties ; inp = CAST ( cdf_property_info_t * , realloc (
",0,511
144,"static int inet_sk_reselect_saddr ( struct sock * sk ) { struct inet_sock * inet = inet_sk ( sk ) ; __be32 old_saddr = inet -> inet_saddr ; __be32 daddr = inet -> inet_daddr ; struct flowi4 fl4 ; struct rtable * rt ; __be32 new_saddr ; struct ip_options_rcu * inet_opt ; inet_opt = rcu_dereference_protected ( inet -> inet_opt , sock_owned_by_user ( sk ) ) ; if ( inet_opt && inet_opt -> opt . srr ) daddr = inet_opt -> opt . faddr ; rt = ip_route_connect ( & fl4 , daddr , 0 , RT_CONN_FLAGS ( sk ) , sk -> sk_bound_dev_if , sk -> sk_protocol , inet -> inet_sport , inet -> inet_dport , sk , false ) ; if ( IS_ERR ( rt ) ) return PTR_ERR ( rt ) ; sk_setup_caps ( sk , & rt -> dst ) ; new_saddr = rt -> rt_src ; if ( new_saddr == old_saddr ) return 0 ; if ( sysctl_ip_dynaddr > 1 ) { printk ( KERN_INFO ""%s():shiftinginet->saddrfrom%pI4to%pI4\\n"" , __func__ , & old_saddr , & new_saddr ) ; } inet -> inet_saddr = inet -> inet_rcv_saddr = new_saddr ; __sk_prot_rehash ( sk ) ; return 0 ; }
",1,406
145,"static int check_entry_size_and_hooks ( struct ipt_entry * e , struct xt_table_info * newinfo , const unsigned char * base , const unsigned char * limit , const unsigned int * hook_entries , const unsigned int * underflows , unsigned int valid_hooks ) { unsigned int h ; int err ; if ( ( unsigned long ) e % __alignof__ ( struct ipt_entry ) != 0 || ( unsigned char * ) e + sizeof ( struct ipt_entry ) >= limit || ( unsigned char * ) e + e -> next_offset > limit ) { duprintf ( ""Badoffset%p\\n"" , e ) ; return - EINVAL ; } if ( e -> next_offset < sizeof ( struct ipt_entry ) + sizeof ( struct xt_entry_target ) ) { pr_debug ( ""Underflowsmustbeunconditionaland"" ""usetheSTANDARDtargetwith"" ""ACCEPT/DROP\\n"" ) ; return - EINVAL ; } newinfo -> underflow [ h ] = underflows [ h ] ; } } e -> counters = ( ( struct xt_counters ) { 0 , 0 } ) ; e -> comefrom = 0 ; return 0 ; }
",1,274
146,"void eigrp_print ( netdissect_options * ndo , register const u_char * pptr , register u_int len ) { const struct eigrp_common_header * eigrp_com_header ; const struct eigrp_tlv_header * eigrp_tlv_header ; const u_char * tptr , * tlv_tptr ; u_int tlen , eigrp_tlv_len , eigrp_tlv_type , tlv_tlen , byte_length , bit_length ; uint8_t prefix [ 4 ] ; union { const struct eigrp_tlv_general_parm_t * eigrp_tlv_general_parm ; const struct eigrp_tlv_sw_version_t * eigrp_tlv_sw_version ; const struct eigrp_tlv_ip_int_t * eigrp_tlv_ip_int ; const struct eigrp_tlv_ip_ext_t * eigrp_tlv_ip_ext ; const struct eigrp_tlv_at_cable_setup_t * eigrp_tlv_at_cable_setup ; const struct eigrp_tlv_at_int_t * eigrp_tlv_at_int ; const struct eigrp_tlv_at_ext_t * eigrp_tlv_at_ext ; } tlv_ptr ; tptr = pptr ; eigrp_com_header = ( const struct eigrp_common_header * ) pptr ; ND_TCHECK ( * eigrp_com_header ) ; if ( eigrp_com_header -> version != EIGRP_VERSION ) { ND_PRINT ( ( ndo , ""EIGRPversion%upacketnotsupported"" , eigrp_com_header -> version ) ) ; return ; } if ( ndo -> ndo_vflag < 1 ) { ND_PRINT ( ( ndo , ""EIGRP%s,length:%u"" , tok2str ( eigrp_opcode_values , ""unknown(%u)"" , eigrp_com_header -> opcode ) , len ) ) ; return ; } tlen = len -
",0,511
147,"void * vpx_memalign ( size_t align , size_t size ) { void * addr , * x = NULL ; # if CONFIG_MEM_MANAGER if ( vpx_mm_create_heap_memory ( ) < 0 ) { _P ( printf ( ""[vpx][mm]ERRORvpx_memalign()Couldn\'tcreatememoryforHeap.\\n"" ) ; ) ; } number_aau = ( ( size + align - 1 + ADDRESS_STORAGE_SIZE ) >> SHIFT_HMM_ADDR_ALIGN_UNIT ) + 1 ; addr = hmm_alloc ( & hmm_d , number_aau ) ; # else addr = VPX_MALLOC_L ( size + align - 1 + ADDRESS_STORAGE_SIZE ) ; if ( addr ) { x = align_addr ( ( unsigned char * ) addr + ADDRESS_STORAGE_SIZE , ( int ) align ) ; ( ( size_t * ) x ) [ - 1 ] = ( size_t ) addr ; } return x ; }
",0,247
148,"static int parse_exports_table ( long long * table_start ) { int res ; int indexes = SQUASHFS_LOOKUP_BLOCKS ( sBlk . s . inodes ) ; long long export_index_table [ indexes ] ; res = read_fs_bytes ( fd , sBlk . s . lookup_table_start , SQUASHFS_LOOKUP_BLOCK_BYTES ( sBlk . s . inodes ) , export_index_table ) ; if ( res == FALSE ) { ERROR ( ""parse_exports_table:failedtoreadexportindextable\\n"" ) ; return FALSE ; } SQUASHFS_INSWAP_LOOKUP_BLOCKS ( export_index_table , indexes ) ; * table_start = export_index_table [ 0 ] ; return TRUE ; }
",0,190
149,"static int devzvol_readdir ( struct vnode * dvp , struct uio * uiop , struct cred * cred , int * eofp , caller_context_t * ct_unused , int flags_unused ) { struct sdev_node * sdvp = VTOSDEV ( dvp ) ; char * ptr ; sdcmn_err13 ( ( ""zvreaddirof\'%s\'%s\'"" , sdvp -> sdev_path , sdvp -> sdev_name ) ) ; if ( strcmp ( sdvp -> sdev_path , ZVOL_DIR ) == 0 ) { struct vnode * vp ; rw_exit ( & sdvp -> sdev_contents ) ; ( void ) devname_lookup_func ( sdvp , ""dsk"" , & vp , cred , devzvol_create_dir , SDEV_VATTR ) ; VN_RELE ( vp ) ; ( void ) devname_lookup_func ( sdvp , ""rdsk"" , & vp , cred , devzvol_create_dir , SDEV_VATTR ) ; VN_RELE ( vp ) ; rw_enter ( & sdvp -> sdev_contents , RW_READER ) ; return ( devname_readdir_func ( dvp , uiop , cred , eofp , 0 ) ) ; } if ( uiop -> uio_offset == 0 ) devzvol_prunedir ( sdvp ) ; ptr = sdvp -> sdev_path + strlen ( ZVOL_DIR ) ; if ( ( strcmp ( ptr , ""/dsk"" ) == 0 ) || ( strcmp ( ptr , ""/rdsk"" ) == 0 ) ) { rw_exit ( & sdvp -> sdev_contents ) ; devzvol_create_pool_dirs ( dvp ) ; rw_enter ( & sdvp -> sdev_contents , RW_READER ) ; return ( devname_readdir_func ( dvp , uiop , cred , eofp , 0 ) ) ; } ptr = strchr ( ptr + 1 , '/' ) ; if ( ptr == NULL ) return ( ENOENT ) ; ptr ++ ; rw_exit ( & sdvp -> sdev_contents
",0,511
150,"static int ext4_split_unwritten_extents ( handle_t * handle , struct inode * inode , struct ext4_map_blocks * map , struct ext4_ext_path * path , int flags ) { ext4_lblk_t eof_block ; ext4_lblk_t ee_block ; struct ext4_extent * ex ; unsigned int ee_len ; int split_flag = 0 , depth ; ext_debug ( ""ext4_split_unwritten_extents:inode%lu,logical"" ""block%llu,max_blocks%u\\n"" , inode -> i_ino , ( unsigned long long ) map -> m_lblk , map -> m_len ) ; eof_block = ( inode -> i_size + inode -> i_sb -> s_blocksize - 1 ) >> inode -> i_sb -> s_blocksize_bits ; if ( eof_block < map -> m_lblk + map -> m_len ) eof_block = map -> m_lblk + map -> m_len ; depth = ext_depth ( inode ) ; ex = path [ depth ] . p_ext ; ee_block = le32_to_cpu ( ex -> ee_block ) ; ee_len = ext4_ext_get_actual_len ( ex ) ; split_flag |= ee_block + ee_len <= eof_block ? EXT4_EXT_MAY_ZEROOUT : 0 ; split_flag |= EXT4_EXT_MARK_UNINIT2 ; if ( flags & ( EXT4_GET_BLOCKS_CONVERT | EXT4_EXT_DATA_VALID2 ) ) split_flag |= EXT4_EXT_DATA_VALID1 ; flags |= EXT4_GET_BLOCKS_PRE_IO ; return ext4_split_extent ( handle , inode , path , map , split_flag , flags ) ; }
",0,449
151,"int ceph_set_acl ( struct inode * inode , struct posix_acl * acl , int type ) { int ret = 0 , size = 0 ; const char * name = NULL ; char * value = NULL ; struct iattr newattrs ; umode_t new_mode = inode -> i_mode , old_mode = inode -> i_mode ; switch ( type ) { case ACL_TYPE_ACCESS : name = XATTR_NAME_POSIX_ACL_ACCESS ; if ( acl ) { ret = posix_acl_update_mode ( inode , & new_mode ) ; if ( ret < 0 ) goto out ; if ( ret == 0 ) acl = NULL ; } break ; case ACL_TYPE_DEFAULT : if ( ! S_ISDIR ( inode -> i_mode ) ) { ret = acl ? - EINVAL : 0 ; goto out ; } name = XATTR_NAME_POSIX_ACL_DEFAULT ; break ; default : ret = - EINVAL ; goto out ; } if ( acl ) { size = posix_acl_xattr_size ( acl -> a_count ) ; value = kmalloc ( size , GFP_NOFS ) ; if ( ! value ) { ret = - ENOMEM ; goto out ; } ret = posix_acl_to_xattr ( & init_user_ns , acl , value , size ) ; if ( ret < 0 ) goto out_free ; } if ( new_mode != old_mode ) { newattrs . ia_mode = new_mode ; newattrs . ia_valid = ATTR_MODE ; ret = __ceph_setattr ( inode , & newattrs ) ; if ( ret ) goto out_free ; } ret = __ceph_setxattr ( inode , name , value , size , 0 ) ; if ( ret ) { if ( new_mode != old_mode ) { newattrs . ia_mode = old_mode ; newattrs . ia_valid = ATTR_MODE ; __ceph_setattr ( inode , & newattrs ) ; } goto out_free ; } ceph_set_cached_acl ( inode , type , acl ) ; out_free : inode
",0,511
152,"static const char * cmd_hash_engine ( cmd_parms * cmd , void * _dcfg , const char * p1 ) { directory_config * dcfg = ( directory_config * ) _dcfg ; if ( dcfg == NULL ) return NULL ; if ( strcasecmp ( p1 , ""on"" ) == 0 ) { dcfg -> hash_is_enabled = HASH_ENABLED ; dcfg -> hash_enforcement = HASH_ENABLED ; } else if ( strcasecmp ( p1 , ""off"" ) == 0 ) { dcfg -> hash_is_enabled = HASH_DISABLED ; dcfg -> hash_enforcement = HASH_DISABLED ; } else return apr_psprintf ( cmd -> pool , ""ModSecurity:InvalidvalueforSecRuleEngine:%s"" , p1 ) ; return NULL ; }
",0,189
153,"int inet6_sk_rebuild_header ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct dst_entry * dst ; dst = __sk_dst_check ( sk , np -> dst_cookie ) ; if ( ! dst ) { struct inet_sock * inet = inet_sk ( sk ) ; struct in6_addr * final_p , final ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; rcu_read_lock ( ) ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = sk -> sk_v6_daddr ; fl6 . saddr = np -> saddr ; fl6 . flowlabel = np -> flow_label ; fl6 . flowi6_oif = sk -> sk_bound_dev_if ; fl6 . flowi6_mark = sk -> sk_mark ; fl6 . fl6_dport = inet -> inet_dport ; fl6 . fl6_sport = inet -> inet_sport ; security_sk_classify_flow ( sk , flowi6_to_flowi ( & fl6 ) ) ; final_p = fl6_update_dst ( & fl6 , rcu_dereference ( np -> opt ) , & final ) ; rcu_read_unlock ( ) ; dst = ip6_dst_lookup_flow ( sk , & fl6 , final_p ) ; if ( IS_ERR ( dst ) ) { sk -> sk_route_caps = 0 ; sk -> sk_err_soft = - PTR_ERR ( dst ) ; return PTR_ERR ( dst ) ; } __ip6_dst_store ( sk , dst , NULL , NULL ) ; } return 0 ; }
",1,425
154,"static int loadImage ( TIFF * in , struct image_data * image , struct dump_opts * dump , unsigned char * * read_ptr ) { uint32 i ; float xres = 0.0 , yres = 0.0 ; uint32 nstrips = 0 , ntiles = 0 ; uint16 planar = 0 ; uint16 bps = 0 , spp = 0 , res_unit = 0 ; uint16 orientation = 0 ; uint16 input_compression = 0 , input_photometric = 0 ; uint16 subsampling_horiz , subsampling_vert ; uint32 width = 0 , length = 0 ; uint32 stsize = 0 , tlsize = 0 , buffsize = 0 , scanlinesize = 0 ; uint32 tw = 0 , tl = 0 ; uint32 tile_rowsize = 0 ; unsigned char * read_buff = NULL ; unsigned char * new_buff = NULL ; int readunit = 0 ; static uint32 prev_readsize = 0 ; TIFFGetFieldDefaulted ( in , TIFFTAG_BITSPERSAMPLE , & bps ) ; TIFFGetFieldDefaulted ( in , TIFFTAG_SAMPLESPERPIXEL , & spp ) ; TIFFGetFieldDefaulted ( in , TIFFTAG_PLANARCONFIG , & planar ) ; TIFFGetFieldDefaulted ( in , TIFFTAG_ORIENTATION , & orientation ) ; if ( ! TIFFGetFieldDefaulted ( in , TIFFTAG_PHOTOMETRIC , & input_photometric ) ) TIFFError ( ""loadImage"" , ""ImagelacksPhotometricinterpreationtag"" ) ; if ( ! TIFFGetField ( in , TIFFTAG_IMAGEWIDTH , & width ) ) TIFFError ( ""loadimage"" , ""Imagelacksimagewidthtag"" ) ; if ( ! TIFFGetField ( in , TIFFTAG_IMAGELENGTH , & length ) ) TIFFError ( ""loadimage"" , ""Imagelacksimagelengthtag"" ) ; TIFFGetFieldDefaulted ( in , TIFFTAG_XRESOLUTION , & xres ) ; TIFFGetFieldDefaulted ( in , TIFFTAG_YRESOLUTION , & yres ) ; if (
",0,511
155,"static int parse_stream_params ( struct VpxEncoderConfig * global , struct stream_state * stream , char * * argv ) { char * * argi , * * argj ; struct arg arg ; static const arg_def_t * * ctrl_args = no_args ; static const int * ctrl_args_map = NULL ; struct stream_config * config = & stream -> config ; int eos_mark_found = 0 ; if ( 0 ) { # if CONFIG_VP8_ENCODER } else if ( strcmp ( global -> codec -> name , ""vp8"" ) == 0 ) { ctrl_args = vp8_args ; ctrl_args_map = vp8_arg_ctrl_map ; # endif # if CONFIG_VP9_ENCODER } else if ( strcmp ( global -> codec -> name , ""vp9"" ) == 0 ) { ctrl_args = vp9_args ; ctrl_args_map = vp9_arg_ctrl_map ; # endif # if CONFIG_VP10_ENCODER } else if ( strcmp ( global -> codec -> name , ""vp10"" ) == 0 ) { ctrl_args = vp10_args ; ctrl_args_map = vp10_arg_ctrl_map ; # endif } for ( argi = argj = argv ; ( * argj = * argi ) ; argi += arg . argv_step ) { arg . argv_step = 1 ; if ( eos_mark_found ) { argj ++ ; continue ; } else if ( ! strcmp ( * argj , ""--"" ) ) { eos_mark_found = 1 ; continue ; } if ( arg_match ( & arg , & outputfile , argi ) ) { config -> out_fn = arg . val ; } else if ( arg_match ( & arg , & fpf_name , argi ) ) { config -> stats_fn = arg . val ; } else if ( arg_match ( & arg , & use_ivf , argi ) ) { config -> write_webm = 0 ; } else if ( arg_match ( & arg , & threads , argi ) ) { config -> cfg . g_threads = arg_parse_uint ( & arg ) ; }
",0,511
156,"static int server_input_global_request ( int type , u_int32_t seq , void * ctxt ) { char * rtype ; int want_reply ; int r , success = 0 , allocated_listen_port = 0 ; struct sshbuf * resp = NULL ; rtype = packet_get_string ( NULL ) ; want_reply = packet_get_char ( ) ; debug ( ""server_input_global_request:rtype%swant_reply%d"" , rtype , want_reply ) ; if ( strcmp ( rtype , ""tcpip-forward"" ) == 0 ) { struct passwd * pw ; struct Forward fwd ; pw = the_authctxt -> pw ; if ( pw == NULL || ! the_authctxt -> valid ) fatal ( ""server_input_global_request:no/invaliduser"" ) ; memset ( & fwd , 0 , sizeof ( fwd ) ) ; fwd . listen_host = packet_get_string ( NULL ) ; fwd . listen_port = ( u_short ) packet_get_int ( ) ; debug ( ""server_input_global_request:tcpip-forwardlisten%sport%d"" , fwd . listen_host , fwd . listen_port ) ; if ( ( options . allow_tcp_forwarding & FORWARD_REMOTE ) == 0 || no_port_forwarding_flag || options . disable_forwarding || ( ! want_reply && fwd . listen_port == 0 ) || ( fwd . listen_port != 0 && ! bind_permitted ( fwd . listen_port , pw -> pw_uid ) ) ) { success = 0 ; packet_send_debug ( ""Serverhasdisabledportforwarding."" ) ; } else { success = channel_setup_remote_fwd_listener ( & fwd , & allocated_listen_port , & options . fwd_opts ) ; } free ( fwd . listen_host ) ; if ( ( resp = sshbuf_new ( ) ) == NULL ) fatal ( ""%s:sshbuf_new"" , __func__ ) ; if ( allocated_listen_port != 0 && ( r = sshbuf_put_u32 ( resp , allocated_listen_port ) ) != 0 )
",0,511
157,"static void l2tp_eth_dev_setup ( struct net_device * dev ) { ether_setup ( dev ) ; dev -> priv_flags &= ~ IFF_TX_SKB_SHARING ; dev -> netdev_ops = & l2tp_eth_netdev_ops ; dev -> destructor = free_netdev ; }
",1,78
158,"static Image * ReadCINImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define MonoColorType 1 # define RGBColorType 3 char property [ MagickPathExtent ] ; CINInfo cin ; const unsigned char * pixels ; Image * image ; MagickBooleanType status ; MagickOffsetType offset ; QuantumInfo * quantum_info ; QuantumType quantum_type ; register ssize_t i ; register Quantum * q ; size_t length ; ssize_t count , y ; unsigned char magick [ 4 ] ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } offset = 0 ; count = ReadBlob ( image , 4 , magick ) ; offset += count ; if ( ( count != 4 ) || ( ( LocaleNCompare ( ( char * ) magick , ""\\200\\052\\137\\327"" , 4 ) != 0 ) ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; memset ( & cin , 0 , sizeof ( cin ) ) ; image -> endian = ( magick [ 0 ] == 0x80 ) && ( magick [ 1 ] == 0x2a ) && ( magick [ 2 ] == 0x5f ) && ( magick [ 3 ] == 0xd7 ) ? MSBEndian : LSBEndian ; cin . file . image_offset = ReadBlobLong ( image ) ; offset += 4 ; cin . file . generic_length = ReadBlobLong ( image ) ; offset += 4 ; cin . file . industry_length = ReadBlobLong ( image ) ; offset += 4 ; cin . file . user_length
",0,511
159,"static bool_t svcauth_gss_accept_sec_context ( struct svc_req * rqst , struct rpc_gss_init_res * gr ) { struct svc_rpc_gss_data * gd ; struct rpc_gss_cred * gc ; gss_buffer_desc recv_tok , seqbuf ; gss_OID mech ; OM_uint32 maj_stat = 0 , min_stat = 0 , ret_flags , seq ; log_debug ( ""insvcauth_gss_accept_context()"" ) ; gd = SVCAUTH_PRIVATE ( rqst -> rq_xprt -> xp_auth ) ; gc = ( struct rpc_gss_cred * ) rqst -> rq_clntcred ; memset ( gr , 0 , sizeof ( * gr ) ) ; memset ( & recv_tok , 0 , sizeof ( recv_tok ) ) ; if ( ! svc_getargs ( rqst -> rq_xprt , xdr_rpc_gss_init_args , ( caddr_t ) & recv_tok ) ) return ( FALSE ) ; gr -> gr_major = gss_accept_sec_context ( & gr -> gr_minor , & gd -> ctx , svcauth_gss_creds , & recv_tok , GSS_C_NO_CHANNEL_BINDINGS , & gd -> client_name , & mech , & gr -> gr_token , & ret_flags , NULL , NULL ) ; svc_freeargs ( rqst -> rq_xprt , xdr_rpc_gss_init_args , ( caddr_t ) & recv_tok ) ; log_status ( ""accept_sec_context"" , gr -> gr_major , gr -> gr_minor ) ; if ( gr -> gr_major != GSS_S_COMPLETE && gr -> gr_major != GSS_S_CONTINUE_NEEDED ) { badauth ( gr -> gr_major , gr -> gr_minor , rqst -> rq_xprt ) ; gd -> ctx = GSS_
",0,511
160,"static int ext4_ext_grow_indepth ( handle_t * handle , struct inode * inode , unsigned int flags ) { struct ext4_extent_header * neh ; struct buffer_head * bh ; ext4_fsblk_t newblock , goal = 0 ; struct ext4_super_block * es = EXT4_SB ( inode -> i_sb ) -> s_es ; int err = 0 ; if ( ext_depth ( inode ) ) goal = ext4_idx_pblock ( EXT_FIRST_INDEX ( ext_inode_hdr ( inode ) ) ) ; if ( goal > le32_to_cpu ( es -> s_first_data_block ) ) { flags |= EXT4_MB_HINT_TRY_GOAL ; goal -- ; } else goal = ext4_inode_to_goal_block ( inode ) ; newblock = ext4_new_meta_blocks ( handle , inode , goal , flags , NULL , & err ) ; if ( newblock == 0 ) return err ; bh = sb_getblk_gfp ( inode -> i_sb , newblock , __GFP_MOVABLE | GFP_NOFS ) ; if ( unlikely ( ! bh ) ) return - ENOMEM ; lock_buffer ( bh ) ; err = ext4_journal_get_create_access ( handle , bh ) ; if ( err ) { unlock_buffer ( bh ) ; goto out ; } ext4_write_block ( & neh -> b_data , EXT4_I ( inode ) -> i_data , sizeof ( EXT4_I ( inode ) -> i_data ) ) ; memmove ( bh -> b_data , EXT4_I ( inode ) -> i_data , sizeof ( EXT4_I ( inode ) -> i_data ) ) ; neh = ext_block_hdr ( bh ) ; if ( ext_depth ( inode ) ) neh -> eh_max = cpu_to_le16 ( ext4_ext_space_block_idx ( inode , 0 ) ) ; else neh -> eh_max = cpu_to_le16 ( ext4_ext_space_block ( inode , 0 ) ) ;
",0,511
161,"NOEXPORT int verify_callback ( int preverify_ok , X509_STORE_CTX * callback_ctx ) { SSL * ssl ; CLI * c ; ssl = X509_STORE_CTX_get_ex_data ( callback_ctx , SSL_get_ex_data_X509_STORE_CTX_idx ( ) ) ; c = SSL_get_ex_data ( ssl , index_ssl_cli ) ; if ( ! c -> opt -> option . verify_chain && ! c -> opt -> option . verify_peer ) { s_log ( LOG_INFO , ""Certificateverificationdisabled"" ) ; return 1 ; } if ( SSL_SESSION_get_ex_data ( ssl , c -> ssl ) ) { SSL_SESSION * sess = SSL_get1_session ( c -> ssl ) ; if ( sess ) { int ok = SSL_SESSION_set_ex_data ( sess , index_session_authenticated , ( void * ) ( - 1 ) ) ; SSL_SESSION_free ( sess ) ; if ( ! ok ) { sslerror ( ""SSL_SESSION_set_ex_data"" ) ; return 0 ; } } return 1 ; }
",0,278
162,"int create_user_ns ( struct cred * new ) { struct user_namespace * ns , * parent_ns = new -> user_ns ; kuid_t owner = new -> euid ; kgid_t group = new -> egid ; int ret ; if ( current_chrooted ( ) ) return - EPERM ; if ( ! kuid_has_mapping ( parent_ns , owner ) || ! kgid_has_mapping ( parent_ns , group ) ) return - EPERM ; ns = kmem_cache_zalloc ( user_ns_cachep , GFP_KERNEL ) ; if ( ! ns ) return - ENOMEM ; ret = proc_alloc_inum ( & ns -> proc_inum ) ; if ( ret ) { kmem_cache_free ( user_ns_cachep , ns ) ; return ret ; } atomic_set ( & ns -> count , 1 ) ; ns -> parent = parent_ns ; ns -> owner = owner ; ns -> group = group ; set_cred_user_ns ( new , ns ) ; return 0 ; }
",1,244
163,"int secure_decrypt ( void * data , unsigned int data_length , int is_signed ) { at91_aes_key_size_t key_size ; unsigned int cmac_key [ 8 ] , cipher_key [ 8 ] ; unsigned int iv [ AT91_AES_IV_SIZE_WORD ] ; unsigned int computed_cmac [ AT91_AES_BLOCK_SIZE_WORD ] ; unsigned int fixed_length ; const unsigned int * cmac ; int rc = - 1 ; init_keys ( & key_size , cipher_key , cmac_key , iv ) ; at91_aes_init ( ) ; if ( is_signed ) { if ( at91_aes_cmac ( data_length , data , computed_cmac , key_size , cmac_key ) ) goto exit ; fixed_length = at91_aes_roundup ( data_length ) ; cmac = ( const unsigned int * ) ( ( char * ) data + fixed_length ) ; if ( memcmp ( cmac , computed_cmac , AT91_AES_BLOCK_SIZE_BYTE ) ) goto exit ; } if ( at91_aes_cbc ( data_length , data , data , 0 , key_size , cipher_key , iv ) ) goto exit ; rc = 0 ; exit : at91_aes_cleanup ( ) ; memset ( cmac_key , 0 , sizeof ( cmac_key ) ) ; memset ( cipher_key , 0 , sizeof ( cipher_key ) ) ; memset ( iv , 0 , sizeof ( iv ) ) ; return rc ; }
",0,363
164,"static int get_cox ( Jpeg2000DecoderContext * s , Jpeg2000CodingStyle * c ) { uint8_t byte ; if ( bytestream2_get_bytes_left ( & s -> g ) < 5 ) return AVERROR_INVALIDDATA ; c -> nreslevels = bytestream2_get_byteu ( & s -> g ) + 1 ; if ( c -> nreslevels >= JPEG2000_MAX_RESLEVELS ) { av_log ( s -> avctx , AV_LOG_ERROR , ""nreslevels%disinvalid\\n"" , c -> nreslevels ) ; return AVERROR_INVALIDDATA ; } if ( c -> nreslevels < s -> reduction_factor ) c -> nreslevels2decode = 1 ; else c -> nreslevels2decode = c -> nreslevels - s -> reduction_factor ; c -> log2_cblk_width = ( bytestream2_get_byteu ( & s -> g ) & 15 ) + 2 ; c -> log2_cblk_height = ( bytestream2_get_byteu ( & s -> g ) & 15 ) + 2 ; if ( c -> log2_cblk_width > 10 || c -> log2_cblk_height > 10 || c -> log2_cblk_width + c -> log2_cblk_height > 12 ) { av_log ( s -> avctx , AV_LOG_ERROR , ""cblksizeinvalid\\n"" ) ; return AVERROR_INVALIDDATA ; } if ( c -> log2_cblk_width > 6 || c -> log2_cblk_height > 6 ) { avpriv_request_sample ( s -> avctx , ""cblksize>64"" ) ; return AVERROR_PATCHWELCOME ; } c -> cblk_style = bytestream2_get_byteu ( & s -> g ) ; if ( c -> cblk_style != 0 ) { av_log ( s -> avctx , AV_LOG_WARNING , ""extracblkstyles%X\\n"" , c -> cblk_style ) ; } c -> transform = bytestream2_get_byteu ( & s -> g
",0,511
165,"qboolean S_AL_Init ( soundInterface_t * si ) { # ifdef USE_OPENAL const char * device = NULL ; const char * inputdevice = NULL ; int i ; if ( ! si ) { return qfalse ; } for ( i = 0 ; i < MAX_RAW_STREAMS ; i ++ ) { streamSourceHandles [ i ] = - 1 ; streamPlaying [ i ] = qfalse ; streamSources [ i ] = 0 ; streamNumBuffers [ i ] = 0 ; streamBufIndex [ i ] = 0 ; } s_alPrecache = Cvar_Get ( ""s_alPrecache"" , ""1"" , CVAR_ARCHIVE ) ; s_alGain = Cvar_Get ( ""s_alGain"" , ""1.0"" , CVAR_ARCHIVE ) ; s_alSources = Cvar_Get ( ""s_alSources"" , ""128"" , CVAR_ARCHIVE ) ; s_alDopplerFactor = Cvar_Get ( ""s_alDopplerFactor"" , ""1.0"" , CVAR_ARCHIVE ) ; s_alDopplerSpeed = Cvar_Get ( ""s_alDopplerSpeed"" , ""9000"" , CVAR_ARCHIVE ) ; s_alMinDistance = Cvar_Get ( ""s_alMinDistance"" , ""120"" , CVAR_CHEAT ) ; s_alMaxDistance = Cvar_Get ( ""s_alMaxDistance"" , ""1024"" , CVAR_CHEAT ) ; s_alRolloff = Cvar_Get ( ""s_alRolloff"" , ""2"" , CVAR_CHEAT ) ; s_alGraceDistance = Cvar_Get ( ""s_alGraceDistance"" , ""512"" , CVAR_CHEAT ) ; s_alDriver = Cvar_Get ( ""s_alDriver"" , ALDRIVER_DEFAULT , CVAR_ARCHIVE | CVAR_LATCH | CVAR_PROTECTED ) ; s_alInputDevice = Cvar_Get ( ""s_alInputDevice"" , """" , CVAR_ARCHIVE | CVAR_LATCH ) ; if ( COM_CompareExtension ( s_alDriver -> string , "".pk3"" )
",0,511
166,"static int tpacket_rcv ( struct sk_buff * skb , struct net_device * dev , struct packet_type * pt , struct net_device * orig_dev ) { struct sock * sk ; struct packet_sock * po ; struct sockaddr_ll * sll ; union tpacket_uhdr h ; u8 * skb_head = skb -> data ; int skb_len = skb -> len ; unsigned int snaplen , res ; unsigned long status = TP_STATUS_USER ; unsigned short macoff , netoff , hdrlen ; struct sk_buff * copy_skb = NULL ; struct timespec ts ; __u32 ts_status ; bool is_drop_n_account = false ; bool do_vnet = false ; BUILD_BUG_ON ( TPACKET_ALIGN ( sizeof ( * h . h2 ) ) != 32 ) ; BUILD_BUG_ON ( TPACKET_ALIGN ( sizeof ( * h . h3 ) ) != 48 ) ; if ( do_vnet ) { if ( sk -> sk_type != SOCK_DGRAM ) skb_push ( skb , skb -> data - skb_mac_header ( skb ) ) ; else if ( skb -> pkt_type == PACKET_OUTGOING ) { skb_pull ( skb , skb_network_offset ( skb ) ) ; } } snaplen = skb -> len ; res = run_filter ( skb , sk , snaplen ) ; if ( ! res ) goto drop_n_restore ; if ( skb -> ip_summed == CHECKSUM_PARTIAL ) status |= TP_STATUS_CSUMNOTREADY ; else if ( skb -> pkt_type != PACKET_OUTGOING && ( skb -> ip_summed == CHECKSUM_COMPLETE || skb_csum_unnecessary ( skb ) ) ) status |= TP_STATUS_CSUM_VALID ; if ( snaplen > res ) snaplen = res ; BUILD_BUG_ON ( TPACKET_ALIGN ( sizeof ( * h . h2 ) ) != 32 ) ; BUILD_BUG_ON ( TPACKET_ALIGN ( sizeof ( * h
",0,511
167,"void sctp_assoc_update ( struct sctp_association * asoc , struct sctp_association * new ) { struct sctp_transport * trans ; struct list_head * pos , * temp ; asoc -> c = new -> c ; asoc -> peer . rwnd = new -> peer . rwnd ; asoc -> peer . sack_needed = new -> peer . sack_needed ; asoc -> peer . auth_capable = new -> peer . auth_capable ; asoc -> peer . i = new -> peer . i ; sctp_tsnmap_init ( & asoc -> peer . tsn_map , SCTP_TSN_MAP_INITIAL , asoc -> peer . i . initial_tsn , GFP_ATOMIC ) ; list_for_each_safe ( pos , temp , & asoc -> peer . transport_addr_list ) { trans = list_entry ( pos , struct sctp_transport , transports ) ; if ( ! sctp_assoc_lookup_paddr ( new , & trans -> ipaddr ) ) { sctp_assoc_rm_peer ( asoc , trans ) ; continue ; } if ( asoc -> state >= SCTP_STATE_ESTABLISHED ) sctp_transport_reset ( trans ) ; } if ( asoc -> state >= SCTP_STATE_ESTABLISHED ) { asoc -> next_tsn = new -> next_tsn ; asoc -> ctsn_ack_point = new -> ctsn_ack_point ; asoc -> adv_peer_ack_point = new -> adv_peer_ack_point ; sctp_ssnmap_clear ( asoc -> ssnmap ) ; sctp_ulpq_flush ( & asoc -> ulpq ) ; asoc -> overall_error_count = 0 ; } else { list_for_each_entry ( trans , & new -> peer . transport_addr_list , transports ) { if ( ! sctp_assoc_lookup_paddr ( asoc , & trans -> ipaddr ) ) sctp_assoc_add_peer ( asoc , & trans -> ipaddr , GFP_ATOMIC , trans -> state
",0,511
168,"static bool ndp_msg_check_valid ( struct ndp_msg * msg ) { size_t len = ndp_msg_payload_len ( msg ) ; enum ndp_msg_type msg_type = ndp_msg_type ( msg ) ; if ( len < ndp_msg_type_info ( msg_type ) -> raw_struct_size ) return false ; if ( ndp_msg_type_info ( msg_type ) -> addrto_validate ) return ndp_msg_type_info ( msg_type ) -> addrto_validate ( & msg -> addrto ) ; else return true ; }
",1,142
169,"int lsm_set_label_at ( int lsm_labelfd , int on_exec , char * lsm_label ) { int fret = - 1 ; int ret = 0 ; const char * name ; char * command = NULL ; name = lsm_name ( ) ; if ( strcmp ( name , ""nop"" ) == 0 ) return 0 ; if ( strcmp ( name , ""none"" ) == 0 ) return 0 ; if ( strcmp ( name , ""AppArmor"" ) == 0 ) on_exec = 0 ; if ( strcmp ( name , ""AppArmor"" ) == 0 ) { int size ; command = malloc ( strlen ( lsm_label ) + strlen ( ""changeprofile"" ) + 1 ) ; if ( ! command ) { SYSERROR ( ""Failedtowriteapparmorprofile"" ) ; ret = - 1 ; goto out ; } size = sprintf ( command , ""changeprofile%s"" , lsm_label ) ; if ( size < 0 ) { SYSERROR ( ""Failedtowriteapparmorprofile"" ) ; goto out ; } if ( write ( labelfd , command , size + 1 ) < 0 ) { SYSERROR ( ""UnabletosetLSMlabel"" ) ; goto out ; } INFO ( ""SetLSMlabelto:%s."" , lsm_label ) ; } else { ERROR ( ""UnabletorestorelabelforunknownLSM:%s"" , name ) ; ret = - 1 ; goto out ; } out : free ( command ) ; return fret ; }
",0,342
170,"static OPJ_BOOL opj_pi_next_cprl ( opj_pi_iterator_t * pi ) { opj_pi_comp_t * comp = NULL ; opj_pi_resolution_t * res = NULL ; OPJ_UINT32 index = 0 ; if ( ! pi -> first ) { comp = & pi -> comps [ pi -> compno ] ; goto LABEL_SKIP ; } else { pi -> first = 0 ; } for ( pi -> compno = pi -> poc . compno0 ; pi -> compno < pi -> poc . compno1 ; pi -> compno ++ ) { OPJ_UINT32 resno ; comp = & pi -> comps [ pi -> compno ] ; pi -> dx = 0 ; pi -> dy = 0 ; for ( resno = 0 ; resno < comp -> numresolutions ; resno ++ ) { OPJ_UINT32 dx , dy ; res = & comp -> resolutions [ resno ] ; dx = comp -> dx * ( 1u << ( res -> pdx + comp -> numresolutions - 1 - resno ) ) ; dy = comp -> dy * ( 1u << ( res -> pdy + comp -> numresolutions - 1 - resno ) ) ; pi -> dx = ! pi -> dx ? dx : opj_uint_min ( pi -> dx , dx ) ; pi -> dy = ! pi -> dy ? dy : opj_uint_min ( pi -> dy , dy ) ; } if ( ! pi -> tp_on ) { pi -> poc . ty0 = pi -> ty0 ; pi -> poc . tx0 = pi -> tx0 ; pi -> poc . ty1 = pi -> ty1 ; pi -> poc . tx1 = pi -> tx1 ; } for ( pi -> y = pi -> poc . ty0 ; pi -> y < pi -> poc . ty1 ; pi -> y += ( OPJ_INT32 ) ( pi -> dy - ( OPJ_UINT32 ) ( pi -> y % ( OPJ_INT32 ) pi -> dy ) ) ) { for ( pi -> x = pi -> poc . tx0 ; pi -> x < pi -> poc . tx1 ; pi -> x += ( OPJ_INT32 ) ( pi -> dx - ( OPJ_UINT32
",0,511
171,"static void record_and_restart ( struct perf_event * event , unsigned long val , struct pt_regs * regs ) { u64 period = event -> hw . sample_period ; s64 prev , delta , left ; int record = 0 ; if ( event -> hw . state & PERF_HES_STOPPED ) { write_pmc ( event -> hw . idx , 0 ) ; return ; } prev = local64_read ( & event -> hw . prev_count ) ; delta = check_and_compute_delta ( prev , val ) ; local64_add ( delta , & event -> count ) ; val = 0 ; left = local64_read ( & event -> hw . period_left ) - delta ; if ( period ) { if ( left <= 0 ) { left += period ; if ( left <= 0 ) left = period ; record = 1 ; event -> hw . last_period = event -> hw . sample_period ; } if ( left < 0x80000000LL ) val = 0x80000000LL - left ; } write_pmc ( event -> hw . idx , val ) ; local64_set ( & event -> hw . prev_count , val ) ; local64_set ( & event -> hw . period_left , left ) ; perf_event_update_userpage ( event ) ; if ( record ) { struct perf_sample_data data ; perf_sample_data_init ( & data , ~ 0ULL ) ; data . period = event -> hw . last_period ; if ( event -> attr . sample_type & PERF_SAMPLE_ADDR ) perf_get_data_addr ( regs , & data . addr ) ; if ( perf_event_overflow ( event , & data , regs ) ) power_pmu_stop ( event , 0 ) ; } }
",1,414
172,"void vp9_twopass_postencode_update ( VP9_COMP * cpi ) { # ifdef DISABLE_RC_LONG_TERM_MEM const uint64_t bits_used = cpi -> rc . this_frame_target ; # else const uint64_t bits_used = cpi -> rc . projected_frame_size ; # endif cpi -> twopass . bits_left -= bits_used ; cpi -> twopass . bits_left = MAX ( cpi -> twopass . bits_left , 0 ) ; if ( is_one_pass_cbr_svc ( cpi ) ) { twopass . gf_group_bits += cpi -> rc . this_frame_target - bits_used ; } else { cpi -> twopass . gf_group_bits -= bits_used ; cpi -> twopass . gf_group_bits = MAX ( cpi -> twopass . gf_group_bits , 0 ) ; } cpi -> twopass . kf_group_bits = MAX ( cpi -> twopass . kf_group_bits , 0 ) ; }
",0,262
173,"Datum lquery_in ( PG_FUNCTION_ARGS ) { char * buf = ( char * ) PG_GETARG_POINTER ( 0 ) ; char * ptr ; int num = 0 , totallen = 0 , numOR = 0 ; int state = LQPRS_WAITLEVEL ; lquery * result ; nodeitem * lptr = NULL ; lquery_level * cur , * curqlevel , * tmpql ; lquery_variant * lrptr = NULL ; bool hasnot = false ; bool wasbad = false ; int charlen ; int pos = 0 ; ptr = buf ; while ( * ptr ) { charlen = pg_mblen ( ptr ) ; if ( charlen == 1 ) { if ( t_iseq ( ptr , '.' ) ) num ++ ; else if ( t_iseq ( ptr , '|' ) ) numOR ++ ; } ptr += charlen ; } num ++ ; if ( num > MaxAllocSize / ITEMSIZE ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""numberoflevels(%d)exceedsthemaximumallowed(%d)"" , num , ( int ) ( MaxAllocSize / ITEMSIZE ) ) ) ) ; curqlevel = tmpql = ( lquery_level * ) palloc0 ( ITEMSIZE * num ) ; ptr = buf ; while ( * ptr ) { charlen = pg_mblen ( ptr ) ; if ( state == LQPRS_WAITLEVEL ) { if ( ISALNUM ( ptr ) ) { GETVAR ( curqlevel ) = lptr = ( nodeitem * ) palloc0 ( sizeof ( nodeitem ) * ( numOR + 1 ) ) ; lptr -> start = ptr ; state = LQPRS_WAITDELIM ; curqlevel -> numvar = 1 ; } else if ( charlen == 1 && t_iseq ( ptr , '!' ) ) { GETVAR ( curqlevel ) = lptr = ( nodeitem * ) palloc0 ( sizeof ( nodeitem ) * ( numOR + 1 ) ) ; lptr -> start = ptr + 1 ; state = LQPRS_WAITDELIM ; curqlevel -> numvar = 1
",0,511
174,"static struct buffer_head * ext4_xattr_cache_find ( struct inode * inode , struct ext4_xattr_header * header , struct mb2_cache_entry * * pce ) { __u32 hash = le32_to_cpu ( header -> h_hash ) ; struct mb2_cache_entry * ce ; struct mb2_cache * ext4_mb_cache = EXT4_GET_MB_CACHE ( inode ) ; if ( ! header -> h_hash ) return NULL ; ea_idebug ( inode , ""lookingforcachedblocks[%x]"" , ( int ) hash ) ; ce = mb2_cache_entry_find_first ( ext4_mb_cache , inode -> i_sb -> s_bdev , hash ) ; while ( ce ) { struct buffer_head * bh ; bh = sb_bread ( inode -> i_sb , ce -> e_block ) ; if ( ! bh ) { EXT4_ERROR_INODE ( inode , ""block%lureaderror"" , ( unsigned long ) ce -> e_block ) ; } else if ( le32_to_cpu ( BHDR ( bh ) -> h_refcount ) >= EXT4_XATTR_REFCOUNT_MAX ) { ea_idebug ( inode , ""block%lurefcount%d>=%d"" , ( unsigned long ) ce -> e_block , le32_to_cpu ( BHDR ( bh ) -> h_refcount ) , EXT4_XATTR_REFCOUNT_MAX ) ; } else if ( ext4_xattr_cmp ( header , BHDR ( bh ) ) == 0 ) { * pce = ce ; return bh ; } brelse ( bh ) ; ce = mb2_cache_entry_find_next ( ext4_mb_cache , ce ) ; } return NULL ; }
",1,437
175,"static gboolean cosine_read ( wtap * wth , int * err , gchar * * err_info , gint64 * data_offset ) { gint64 offset ; char line [ COSINE_LINE_LENGTH ] ; offset = cosine_seek_next_packet ( wth , err , err_info , line ) ; if ( offset < 0 ) return FALSE ; * data_offset = offset ; return parse_cosine_packet ( wth -> fh , & wth -> phdr , pkt_len , wth -> frame_buffer , line , err , err_info ) ; }
",1,139
176,"static int add_push_report_sideband_pkt ( git_push * push , git_pkt_data * data_pkt , git_buf * data_pkt_buf ) { git_pkt * pkt ; const char * line , * line_end = NULL ; size_t line_len ; int error ; int reading_from_buf = data_pkt_buf -> size > 0 ; if ( reading_from_buf ) { git_buf_put ( data_pkt_buf , data_pkt -> data , data_pkt -> len ) ; line = data_pkt_buf -> ptr ; line_len = data_pkt_buf -> size ; } else { line = data_pkt -> data ; line_len = data_pkt -> len ; } while ( line_len > 0 ) { error = git_pkt_parse_line ( & pkt , line , & line_end , line_len ) ; if ( error == GIT_EBUFS ) { if ( ! reading_from_buf ) git_buf_put ( data_pkt_buf , line , line_len ) ; error = 0 ; goto done ; } else if ( error < 0 ) goto done ; line_len -= ( line_end - line ) ; line = line_end ; error = add_push_report_pkt ( push , pkt ) ; git_pkt_free ( pkt ) ; if ( error < 0 && error != GIT_ITEROVER ) goto done ; } error = 0 ; done : if ( reading_from_buf ) git_buf_consume ( data_pkt_buf , line_end ) ; return error ; }
",1,375
177,"int ssl3_read_n ( SSL * s , int n , int max , int extend ) { int i , len , left ; long align = 0 ; unsigned char * pkt ; SSL3_BUFFER * rb ; if ( n <= 0 ) return n ; rb = & ( s -> s3 -> rbuf ) ; if ( rb -> buf == NULL ) if ( ! ssl3_setup_read_buffer ( s ) ) return - 1 ; left = rb -> left ; # if defined ( SSL3_ALIGN_PAYLOAD ) && SSL3_ALIGN_PAYLOAD != 0 align = ( long ) rb -> buf + SSL3_RT_HEADER_LENGTH ; align = ( - align ) & ( SSL3_ALIGN_PAYLOAD - 1 ) ; # endif if ( ! extend ) { if ( left == 0 ) rb -> offset = align ; else if ( align != 0 && left >= SSL3_RT_HEADER_LENGTH ) { pkt = rb -> buf + rb -> offset ; if ( pkt [ 0 ] == SSL3_RT_APPLICATION_DATA && ( pkt [ 3 ] << 8 | pkt [ 4 ] ) >= 128 ) { memmove ( rb -> buf + align , pkt , left ) ; rb -> offset = align ; } } s -> packet = rb -> buf + rb -> offset ; s -> packet_length = 0 ; } if ( SSL_IS_DTLS ( s ) ) { if ( left > 0 && n > left ) n = left ; } if ( left >= n ) { s -> packet_length += n ; rb -> left = left - n ; rb -> offset += n ; return ( n ) ; } len = s -> packet_length ; pkt = rb -> buf + align ; if ( s -> packet != pkt ) { memmove ( pkt , s -> packet , len + left ) ; s -> packet = pkt ; rb -> offset = len + align ; } if ( n > ( int ) ( rb -> len - rb -> offset ) ) { SSLerr ( SSL_F_SSL3_READ_N , ERR_R_INTERNAL_ERROR ) ; return - 1 ; } if ( ! s -> read_ahead ) max = n ; else { str
",0,511
178,"static grub_disk_addr_t grub_ext2_read_block ( grub_fshelp_node_t node , grub_disk_addr_t fileblock ) { struct grub_ext2_data * data = node -> data ; struct grub_ext2_inode * inode = & node -> inode ; int blknr = - 1 ; unsigned int blksz = EXT2_BLOCK_SIZE ( data ) ; int log2_blksz = LOG2_EXT2_BLOCK_SIZE ( data ) ; if ( grub_le_to_cpu32 ( inode -> flags ) & EXT4_EXTENTS_FLAG ) { char buf [ EXT2_BLOCK_SIZE ( data ) ] ; char * buf = grub_malloc ( EXT2_BLOCK_SIZE ( data ) ) ; # else char * buf = grub_malloc ( EXT2_BLOCK_SIZE ( data ) ) ; struct grub_ext4_extent_header * leaf ; struct grub_ext4_extent * ext ; int i ; leaf = grub_ext4_find_leaf ( data , buf , ( struct grub_ext4_extent_header * ) inode -> blocks . dir_blocks , fileblock ) ; if ( ! leaf ) { grub_error ( GRUB_ERR_BAD_FS , ""invalidextent"" ) ; return - 1 ; } ext = ( struct grub_ext4_extent * ) ( leaf + 1 ) ; for ( i = 0 ; i < grub_le_to_cpu16 ( leaf -> entries ) ; i ++ ) { if ( fileblock < grub_le_to_cpu32 ( ext [ i ] . block ) ) break ; } if ( -- i >= 0 ) { fileblock -= grub_le_to_cpu32 ( ext [ i ] . block ) ; if ( fileblock >= grub_le_to_cpu16 ( ext [ i ] . len ) ) return 0 ; } else { grub_disk_addr_t start ; start = grub_le_to_cpu16 ( ext [ i ] . start_hi ) ; start = ( start << 32 ) + grub_le_to_cpu32 ( ext [ i ] . start ) ; return file
",0,511
179,"static Image * ReadWPGImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { typedef struct { size_t FileId ; MagickOffsetType DataOffset ; unsigned int ProductType ; unsigned int FileType ; unsigned char MajorVersion ; unsigned char MinorVersion ; unsigned int EncryptKey ; unsigned int Reserved ; } WPGHeader ; typedef struct { unsigned char RecType ; size_t RecordLength ; } WPGRecord ; typedef struct { unsigned char Class ; unsigned char RecType ; size_t Extension ; size_t RecordLength ; } WPG2Record ; typedef struct { unsigned HorizontalUnits ; unsigned VerticalUnits ; unsigned char PosSizePrecision ; } WPG2Start ; typedef struct { unsigned int Width ; unsigned int Height ; unsigned int Depth ; unsigned int HorzRes ; unsigned int VertRes ; } WPGBitmapType1 ; typedef struct { unsigned int Width ; unsigned int Height ; unsigned char Depth ; unsigned char Compression ; } WPG2BitmapType1 ; typedef struct { unsigned int RotAngle ; unsigned int LowLeftX ; unsigned int LowLeftY ; unsigned int UpRightX ; unsigned int UpRightY ; unsigned int Width ; unsigned int Height ; unsigned int Depth ; unsigned int HorzRes ; unsigned int VertRes ; } WPGBitmapType2 ; typedef struct { unsigned int StartIndex ; unsigned int NumOfEntries ; } WPGColorMapRec ; Image * image ; unsigned int status ; WPGHeader Header ; WPGRecord Rec ; WPG2Record Rec2 ; WPG2Start StartWPG ; WPGBitmapType1 BitmapHeader1 ; WPG2BitmapType1 Bitmap2Header1 ; WPGBitmapType2 BitmapHeader2 ; WPGColorMapRec WPG_Palette ; int i , bpp , WPG2Flags ; ssize_t ldblk ; size_t one ; unsigned char * BImgBuff ; tCTM CTM ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; one = 1 ; image = AcquireImage ( image_info , exception ) ; image -> depth = 8 ; status = OpenBlob ( image_info
",0,511
180,"static long vbg_misc_device_ioctl ( struct file * filp , unsigned int req , unsigned long arg ) { struct vbg_session * session = filp -> private_data ; size_t returned_size , size ; struct vbg_ioctl_hdr hdr ; bool is_vmmdev_req ; int ret = 0 ; void * buf ; if ( copy_from_user ( & hdr , ( void * ) arg + sizeof ( hdr ) , hdr . size_in - sizeof ( hdr ) ) ) return - EFAULT ; if ( hdr . version != VBG_IOCTL_HDR_VERSION ) return - EINVAL ; if ( hdr . size_in < sizeof ( hdr ) || ( hdr . size_out && hdr . size_out < sizeof ( hdr ) ) ) return - EINVAL ; size = max ( hdr . size_in , hdr . size_out ) ; if ( _IOC_SIZE ( req ) && _IOC_SIZE ( req ) != size ) return - EINVAL ; if ( size > SZ_16M ) return - E2BIG ; is_vmmdev_req = ( req & ~ IOCSIZE_MASK ) == VBG_IOCTL_VMMDEV_REQUEST ( 0 ) || req == VBG_IOCTL_VMMDEV_REQUEST_BIG ; if ( is_vmmdev_req ) buf = vbg_req_alloc ( size , VBG_IOCTL_HDR_TYPE_DEFAULT ) ; else buf = kmalloc ( size , GFP_KERNEL ) ; if ( ! buf ) return - ENOMEM ; size = size ; if ( copy_from_user ( buf , ( void * ) arg + hdr . size_in ) ) { ret = - EFAULT ; goto out ; } if ( hdr . size_in < size ) memset ( buf + hdr . size_in , 0 , size - hdr . size_in ) ; ret = vbg_core_ioctl ( session , req , buf ) ; if ( ret ) goto out ; returned_size = ( ( struct vbg_ioctl_hdr * ) buf ) -> size_out ; if ( returned_size > size ) { vbg_debug
",0,511
181,"void jpc_qmfb_split_colgrp ( jpc_fix_t * a , int numrows , int stride , int parity ) { int bufsize = JPC_CEILDIVPOW2 ( numrows , 1 ) ; jpc_fix_t splitbuf [ QMFB_SPLITBUFSIZE * JPC_QMFB_COLGRPSIZE ] ; jpc_fix_t * buf = splitbuf ; jpc_fix_t * srcptr ; jpc_fix_t * dstptr ; register jpc_fix_t * srcptr2 ; register jpc_fix_t * dstptr2 ; register int n ; register int i ; int m ; int hstartrow ; if ( bufsize > QMFB_SPLITBUFSIZE ) { if ( ! ( buf = jas_alloc3 ( bufsize , JPC_QMFB_COLGRPSIZE , sizeof ( jpc_fix_t ) ) ) ) { abort ( ) ; } } if ( numrows >= 2 ) { hstartrow = ( numrows + 1 - parity ) >> 1 ; m = numrows - hstartrow ; n = m ; dstptr = buf ; srcptr = & a [ hstartrow * stride ] ; while ( n -- > 0 ) { dstptr2 = dstptr ; srcptr2 = srcptr ; for ( i = 0 ; i < JPC_QMFB_COLGRPSIZE ; ++ i ) { * dstptr2 = * srcptr2 ; ++ dstptr2 ; ++ srcptr2 ; } dstptr += JPC_QMFB_COLGRPSIZE ; srcptr += stride << 1 ; } dstptr = & a [ ( 1 - parity ) * stride ] ; srcptr = & a [ ( 2 - parity ) * stride ] ; n = numrows - m - ( ! parity ) ; while ( n -- > 0 ) { dstptr2 = dstptr ; srcptr2 = srcptr ; for ( i = 0 ; i < JPC_QMFB_COLGRPSIZE ; ++ i ) { * dstptr2 = * srcptr2 ; ++ dstptr2 ; ++ srcptr2 ; } dstptr += stride ; srcptr += stride << 1 ; } dstptr = & a [ hstartcol * stride ] ; srcptr = buf ; n = m ;
",0,511
182,"static Image * ReadSUNImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define RMT_EQUAL_RGB 1 # define RMT_NONE 0 # define RMT_RAW 2 # define RT_STANDARD 1 # define RT_ENCODED 2 # define RT_FORMAT_RGB 3 typedef struct _SUNInfo { unsigned int magic , width , height , depth , length , type , maptype , maplength ; } SUNInfo ; Image * image ; int bit ; MagickBooleanType status ; MagickSizeType number_pixels ; register Quantum * q ; register ssize_t i , x ; register unsigned char * p ; size_t bytes_per_line , extent , height , length ; ssize_t count , y ; SUNInfo sun_info ; unsigned char * sun_data , * sun_pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) ResetMagickMemory ( & sun_info , 0 , sizeof ( sun_info ) ) ; sun_info . magic = ReadBlobMSBLong ( image ) ; do { if ( sun_info . magic != 0x59a66a95 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; sun_info . width = ReadBlobMSBLong ( image ) ; sun_info . height = ReadBlobMSBLong ( image ) ; sun_info . depth = ReadBlobMSBLong ( image ) ; sun_info . length = ReadBlobMSBLong ( image ) ; sun_info . type = ReadBlobMSBLong ( image ) ; sun_info . maptype
",0,511
183,"static Image * ReadRLEImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define SkipLinesOp 0x01 # define SetColorOp 0x02 # define SkipPixelsOp 0x03 # define ByteDataOp 0x05 # define RunDataOp 0x06 # define EOFOp 0x07 # define EOFOp 1 ) char magick [ 12 ] ; Image * image ; int opcode , operand , status ; MagickStatusType flags ; MagickSizeType number_pixels ; MemoryInfo * pixel_info ; Quantum index ; register ssize_t x ; register Quantum * q ; register ssize_t i ; register unsigned char * p ; size_t bits_per_pixel , map_length , number_colormaps , number_planes , number_planes_filled , one , pixel_info_length ; ssize_t count , offset , y ; unsigned char background_color [ 256 ] , * colormap , pixel , plane , * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ; if ( ( count != 2 ) || ( memcmp ( magick , ""\\122\\314"" , 2 ) != 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; do { image -> page . x = MagickLSBShort ( image ) ; image -> page . y = MagickLSBShort ( image ) ; image -> columns = ReadBlobLSBShort ( image ) ; image -> rows = ReadBlobLSBShort ( image ) ; flags = ( MagickStatusType ) ReadBlobByte ( image ) ; image ->
",0,511
184,"static void ext2_put_super ( struct super_block * sb ) { int db_count ; int i ; struct ext2_sb_info * sbi = EXT2_SB ( sb ) ; dquot_disable ( sb , - 1 , DQUOT_USAGE_ENABLED | DQUOT_LIMITS_ENABLED ) ; if ( sbi -> s_mb_cache ) { ext2_xattr_destroy_cache ( sbi -> s_mb_cache ) ; sbi -> s_mb_cache = NULL ; } if ( ! ( sb -> s_flags & MS_RDONLY ) ) { struct ext2_super_block * es = sbi -> s_es ; spin_lock ( & sbi -> s_lock ) ; es -> s_state = cpu_to_le16 ( sbi -> s_mount_state ) ; spin_unlock ( & sbi -> s_lock ) ; ext2_sync_super ( sb , es , 1 ) ; } db_count = sbi -> s_gdb_count ; for ( i = 0 ; i < db_count ; i ++ ) if ( sbi -> s_group_desc [ i ] ) brelse ( sbi -> s_group_desc [ i ] ) ; kfree ( sbi -> s_group_desc ) ; kfree ( sbi -> s_debts ) ; percpu_counter_destroy ( & sbi -> s_freeblocks_counter ) ; percpu_counter_destroy ( & sbi -> s_freeinodes_counter ) ; percpu_counter_destroy ( & sbi -> s_dirs_counter ) ; brelse ( sbi -> s_sbh ) ; sb -> s_fs_info = NULL ; kfree ( sbi -> s_blockgroup_lock ) ; kfree ( sbi ) ; }
",1,418
185,"static int gtco_probe ( struct usb_interface * usbinterface , const struct usb_device_id * id ) { struct gtco * gtco ; struct input_dev * input_dev ; struct hid_descriptor * hid_desc ; char * report ; int result = 0 , retry ; int error ; struct usb_endpoint_descriptor * endpoint ; gtco = kzalloc ( sizeof ( struct gtco ) , GFP_KERNEL ) ; input_dev = input_allocate_device ( ) ; if ( ! gtco || ! input_dev ) { dev_err ( & usbinterface -> dev , ""Nomorememory\\n"" ) ; error = - ENOMEM ; goto err_free_devs ; } gtco -> inputdevice = input_dev ; gtco -> usbdev = interface_to_usbdev ( usbinterface ) ; gtco -> intf = usbinterface ; gtco -> buffer = usb_alloc_coherent ( gtco -> usbdev , REPORT_MAX_SIZE , GFP_KERNEL , & gtco -> buf_dma ) ; if ( ! gtco -> buffer ) { dev_err ( & usbinterface -> dev , ""Nomorememoryforusbuffers\\n"" ) ; error = - ENOMEM ; goto err_free_devs ; } gtco -> urbinfo = usb_alloc_urb ( 0 , GFP_KERNEL ) ; if ( ! gtco -> urbinfo ) { dev_err ( & usbinterface -> dev , ""FailedtoallocateURB\\n"" ) ; error = - ENOMEM ; goto err_free_buf ; } endpoint = & usbinterface -> altsetting [ 0 ] . endpoint [ 0 ] . desc ; dev_dbg ( & usbinterface -> dev , ""gtco#interfaces:%d\\n"" , usbinterface -> num_altsetting ) ; dev_dbg ( & usbinterface -> dev , ""numendpoints:%d\\n"" , usbinterface -> cur_altsetting -> desc . bNumEndpoints ) ; dev_dbg ( & usbinterface -> dev , ""interfaceclass:%d\\n"" , usbinterface -> cur_altsetting -> desc . bInterfaceClass ) ; dev_dbg (
",0,511
186,"void bandwidth_pid ( pid_t pid , const char * command , const char * dev , int down , int up ) { EUID_ASSERT ( ) ; EUID_ROOT ( ) ; char * comm = pid_proc_comm ( pid ) ; EUID_USER ( ) ; if ( ! comm ) { fprintf ( stderr , ""Error:cannotfindsandbox\\n"" ) ; exit ( 1 ) ; } if ( strcmp ( comm , ""firejail"" ) != 0 ) { fprintf ( stderr , ""Error:cannotfindsandbox\\n"" ) ; exit ( 1 ) ; } free ( comm ) ; char * name ; if ( asprintf ( & name , ""/run/firejail/network/%d-netmap"" , pid ) == - 1 ) errExit ( ""asprintf"" ) ; struct stat s ; if ( stat ( name , & s ) == - 1 ) { fprintf ( stderr , ""Error:thesandboxdoesn\'tuseanewnetworknamespace\\n"" ) ; exit ( 1 ) ; } pid_t child ; if ( find_child ( pid , & child ) == - 1 ) { fprintf ( stderr , ""Error:cannotjointhenetworknamespace\\n"" ) ; exit ( 1 ) ; } EUID_ROOT ( ) ; if ( join_namespace ( child , ""net"" ) ) { fprintf ( stderr , ""Error:cannotjointhenetworknamespace\\n"" ) ; exit ( 1 ) ; } if ( strcmp ( command , ""set"" ) == 0 ) bandwidth_set ( pid , dev , down , up ) ; else if ( strcmp ( command , ""clear"" ) == 0 ) bandwidth_remove ( pid , dev ) ; char * devname = NULL ; if ( dev ) { char * fname ; if ( asprintf ( & fname , ""%s/%d-netmap"" , RUN_FIREJAIL_NETWORK_DIR , ( int ) pid ) == - 1 ) errExit ( ""asprintf"" ) ; FILE * fp = fopen ( fname , ""r"" ) ; if ( ! fp ) { fprintf ( stderr , ""Error:cannotreadnetworkmapfile%s\\n"" , fname ) ; exit (
",0,511
187,"static struct o2nm_cluster * to_o2nm_cluster_from_node ( struct o2nm_node * node ) { if ( node -> nd_item . ci_parent ) return to_o2nm_cluster ( node -> nd_item . ci_parent -> ci_parent ) ; else return NULL ; }
",1,80
188,"static void nfs_set_open_stateid ( struct nfs4_state * state , nfs4_stateid * stateid , fmode_t fmode ) { write_seqlock ( & state -> seqlock ) ; nfs_set_open_stateid_locked ( state , stateid , fmode ) ; write_sequnlock ( & state -> seqlock ) ; }
",1,87
189,"static int mv_read_header ( AVFormatContext * avctx ) { MvContext * mv = avctx -> priv_data ; AVIOContext * pb = avctx -> pb ; AVStream * ast = NULL , * vst = NULL ; int version , i ; int ret ; avio_skip ( pb , 4 ) ; version = avio_rb16 ( pb ) ; if ( avio_feof ( pb ) ) return AVERROR_INVALIDDATA ; if ( version == 2 ) { uint64_t timestamp ; int v ; avio_skip ( pb , 22 ) ; ast = avformat_new_stream ( avctx , NULL ) ; if ( ! ast ) return AVERROR ( ENOMEM ) ; vst = avformat_new_stream ( avctx , NULL ) ; if ( ! vst ) return AVERROR ( ENOMEM ) ; avpriv_set_pts_info ( vst , 64 , 1 , 15 ) ; vst -> codecpar -> codec_type = AVMEDIA_TYPE_VIDEO ; vst -> avg_frame_rate = av_inv_q ( vst -> time_base ) ; vst -> nb_frames = avio_rb32 ( pb ) ; v = avio_rb32 ( pb ) ; switch ( v ) { case 1 : vst -> codecpar -> codec_id = AV_CODEC_ID_MVC1 ; break ; case 2 : vst -> codecpar -> format = AV_PIX_FMT_ARGB ; vst -> codecpar -> codec_id = AV_CODEC_ID_RAWVIDEO ; break ; default : avpriv_request_sample ( avctx , ""Videocompression%i"" , v ) ; break ; } vst -> codecpar -> codec_tag = 0 ; vst -> codecpar -> width = avio_rb32 ( pb ) ; vst -> codecpar -> height = avio_rb32 ( pb ) ; avio_skip ( pb , 12 ) ; ast -> codecpar -> codec_type = AVMEDIA_TYPE_AUDIO ; ast -> nb_frames = vst -> nb_frames ; ast -> codecpar -> sample_rate = avio_rb32 ( pb ) ; if ( ast ->
",0,511
190,"int cdf_read_property_info ( const cdf_stream_t * sst , const cdf_header_t * h , uint32_t offs , cdf_property_info_t * * info , size_t * count , size_t * maxcount ) { const cdf_section_header_t * shp ; cdf_section_header_t sh ; const uint8_t * p , * q , * e ; int16_t s16 ; int32_t s32 ; uint32_t u32 ; int64_t s64 ; uint64_t u64 ; cdf_timestamp_t tp ; size_t i , o , o4 , nelements , j ; cdf_property_info_t * inp ; if ( offs > UINT32_MAX / 4 ) { errno = EFTYPE ; goto out ; } shp = CAST ( const cdf_section_header_t * , ( const void * ) ( ( const char * ) sst -> sst_tab + offs ) ) ; if ( cdf_check_stream_offset ( sst , h , shp , sizeof ( * shp ) , __LINE__ ) == - 1 ) goto out ; sh . sh_len = CDF_TOLE4 ( shp -> sh_len ) ; # define CDF_SHLEN_LIMIT ( UINT32_MAX / 8 ) if ( sh . sh_len > CDF_SHLEN_LIMIT ) { errno = EFTYPE ; goto out ; } sh . sh_properties = CDF_TOLE4 ( shp -> sh_properties ) ; # define CDF_PROP_LIMIT ( UINT32_MAX / ( 4 * sizeof ( * inp ) ) ) if ( sh . sh_properties > CDF_PROP_LIMIT ) goto out ; DPRINTF ( ( ""sectionlen:%uproperties%u\\n"" , sh . sh_len , sh . sh_properties ) ) ; if ( * maxcount ) { if ( * maxcount > CDF_PROP_LIMIT ) goto out ; * maxcount += sh . sh_properties ; inp = CAST ( cdf_property_info_t * , realloc (
",0,511
191,"void init_util ( void ) { filegen_register ( statsdir , ""peerstats"" , & peerstats ) ; filegen_register ( statsdir , ""loopstats"" , & loopstats ) ; filegen_register ( statsdir , ""clockstats"" , & clockstats ) ; filegen_register ( statsdir , ""rawstats"" , & rawstats ) ; filegen_register ( statsdir , ""sysstats"" , & sysstats ) ; filegen_register ( statsdir , ""protostats"" , & protostats ) ; filegen_register ( statsdir , ""cryptostats"" , & cryptostats ) ; filegen_register ( statsdir , ""timingstats"" , & timingstats ) ; # endif step_callback = & ntpd_time_stepped ; # ifdef DEBUG atexit ( & uninit_util ) ; # endif }
",1,191
192,"static FILE * pw_tmpfile ( int lockfd ) { FILE * fd ; char * tmpname = NULL ; char * dir = ""/tmp"" ; if ( ( fd = xfmkstemp ( & tmpname , dir ) ) == NULL ) { ulckpwdf ( ) ; err ( EXIT_FAILURE , _ ( ""can\'topentemporaryfile"" ) ) ; } copyfile ( lockfd , fileno ( fd ) ) ; tmp_file = tmpname ; return fd ; }
",0,115
193,"static void commit_tree ( struct mount * mnt , struct mount * shadows ) { struct mount * parent = mnt -> mnt_parent ; struct mount * m ; LIST_HEAD ( head ) ; struct mnt_namespace * n = parent -> mnt_ns ; BUG_ON ( parent == mnt ) ; list_add_tail ( & head , & mnt -> mnt_list ) ; list_for_each_entry ( m , & head , mnt_list ) m -> mnt_ns = n ; list_splice ( & head , n -> list . prev ) ; n -> mounts += n -> pending_mounts ; n -> pending_mounts = 0 ; attach_shadowed ( mnt , parent , shadows ) ; touch_mnt_namespace ( n ) ; }
",1,177
194,"__visible __notrace_funcgraph struct task_struct * __switch_to ( struct task_struct * prev_p , struct task_struct * next_p ) { struct thread_struct * prev = & prev_p -> thread ; struct thread_struct * next = & next_p -> thread ; int cpu = smp_processor_id ( ) ; struct tss_struct * tss = & per_cpu ( init_tss , cpu ) ; unsigned fsindex , gsindex ; fpu_switch_t fpu ; fpu = switch_fpu_prepare ( prev_p , next_p , cpu ) ; load_sp0 ( tss , next ) ; savesegment ( fs , fsindex ) ; savesegment ( gs , gsindex ) ; load_TLS ( next , cpu ) ; arch_end_context_switch ( next_p ) ; savesegment ( fs , fsindex ) ; savesegment ( gs , gsindex ) ; load_TLS ( next , cpu ) ; arch_end_context_switch ( next_p ) ; savesegment ( fs , fsindex ) ; savesegment ( gs , gsindex ) ; load_TLS ( next , cpu ) ; savesegment ( ds , prev -> ds ) ; if ( unlikely ( fsindex | next -> fsindex | prev -> fs ) ) { loadsegment ( fs , next -> fsindex ) ; if ( fsindex ) prev -> fs = 0 ; } if ( next -> fs ) wrmsrl ( MSR_FS_BASE , next -> fs ) ; prev -> fsindex = fsindex ; if ( unlikely ( gsindex | next -> gsindex | prev -> gs ) ) { load_gs_index ( next -> gsindex ) ; if ( gsindex ) prev -> gs = 0 ; } if ( next -> gs ) wrmsrl ( MSR_KERNEL_GS_BASE , next -> gs ) ; prev -> gsindex = gsindex ; switch_fpu_finish ( next_p , fpu ) ; prev -> usersp = this_cpu_read ( old_rsp ) ; this_cpu_write ( old_rsp , next -> usersp ) ; this_cpu_write ( current_task , next_p ) ; task
",0,511
195,"static void save_text_if_changed ( const char * name , const char * new_value ) { if ( ! g_hash_table_lookup ( g_loaded_texts , name ) ) return ; const char * old_value = g_cd ? problem_data_get_content_or_NULL ( g_cd , name ) : """" ; if ( ! old_value ) old_value = """" ; if ( strcmp ( new_value , old_value ) != 0 ) { struct dump_dir * dd = wizard_open_directory_for_writing ( g_dump_dir_name ) ; if ( dd ) dd_save_text ( dd , name , new_value ) ; dd_close ( dd ) ; } }
",1,164
196,"IHEVCD_ERROR_T ihevcd_parse_pps ( codec_t * ps_codec ) { IHEVCD_ERROR_T ret = ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ; WORD32 value ; WORD32 pps_id ; pps_t * ps_pps ; sps_t * ps_sps ; bitstrm_t * ps_bitstrm = & ps_codec -> s_parse . s_bitstrm ; if ( 0 == ps_codec -> i4_sps_done ) return IHEVCD_INVALID_HEADER ; UEV_PARSE ( ""pic_parameter_set_id"" , value , ps_bitstrm ) ; pps_id = value ; if ( ( pps_id >= MAX_PPS_CNT ) || ( pps_id < 0 ) ) { if ( ps_codec -> i4_pps_done ) return IHEVCD_UNSUPPORTED_PPS_ID ; else pps_id = 0 ; } ps_pps = ( ps_codec -> s_parse . ps_pps_base + MAX_PPS_CNT - 1 ) ; ps_pps -> i1_pps_id = pps_id ; UEV_PARSE ( ""seq_parameter_set_id"" , value , ps_bitstrm ) ; ps_pps -> i1_sps_id = value ; ps_pps -> i1_sps_id = CLIP3 ( ps_pps -> i1_sps_id , 0 , MAX_SPS_CNT - 2 ) ; ps_sps = ( ps_codec -> s_parse . ps_sps_base + ps_pps -> i1_sps_id ) ; if ( 0 == ps_sps -> i1_sps_valid ) { return IHEVCD_INVALID_HEADER ; } BITS_PARSE ( ""dependent_slices_enabled_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_dependent_slice_enabled_flag = value ; BITS_PARSE ( ""output_flag_present_flag"" , value , ps_bitstrm ,
",0,511
197,"static void update_exception_bitmap ( struct kvm_vcpu * vcpu ) { u32 eb ; eb = ( 1u << PF_VECTOR ) | ( 1u << UD_VECTOR ) | ( 1u << MC_VECTOR ) | ( 1u << NM_VECTOR ) | ( 1u << DB_VECTOR ) | ( 1u << AC_VECTOR ) ; if ( ( vcpu -> guest_debug & ( KVM_GUESTDBG_ENABLE | KVM_GUESTDBG_USE_SW_BP ) ) == ( KVM_GUESTDBG_ENABLE | KVM_GUESTDBG_USE_SW_BP ) ) eb |= 1u << BP_VECTOR ; if ( to_vmx ( vcpu ) -> rmode . vm86_active ) eb = ~ 0 ; if ( enable_ept ) eb &= ~ ( 1u << PF_VECTOR ) ; if ( vcpu -> fpu_active ) eb &= ~ ( 1u << NM_VECTOR ) ; if ( is_guest_mode ( vcpu ) ) eb |= get_vmcs12 ( vcpu ) -> exception_bitmap ; vmcs_write32 ( EXCEPTION_BITMAP , eb ) ; }
",1,289
198,"static void nfs_printfh ( netdissect_options * ndo , register const uint32_t * dp , const u_int len ) { my_fsid fsid ; uint32_t ino ; const char * sfsname = NULL ; char * spacep ; if ( ndo -> ndo_uflag ) { u_int i ; char const * sep = """" ; ND_PRINT ( ( ndo , ""fh["" ) ) ; for ( i = 0 ; i < len ; i ++ ) { ND_PRINT ( ( ndo , ""%s%x"" , sep , dp [ i ] ) ) ; sep = "":"" ; } ND_PRINT ( ( ndo , ""]"" ) ) ; return ; } Parse_fh ( ( const u_char * ) dp , len , & fsid , & ino , NULL , & sfsname , 0 ) ; if ( sfsname ) { char temp [ NFSX_V3FHMAX + 1 ] ; strncpy ( temp , sfsname , NFSX_V3FHMAX ) ; temp [ sizeof ( temp ) - 1 ] = '\\0' ; spacep = strchr ( temp , '' ) ; if ( spacep ) * spacep = '\\0' ; ND_PRINT ( ( ndo , ""fh%s/"" , temp ) ) ; } else { ND_PRINT ( ( ndo , ""fh%d,%d/"" , fsid . Fsid_dev . Major , fsid . Fsid_dev . Minor ) ) ; } if ( fsid . Fsid_dev . Minor == 257 ) ND_PRINT ( ( ndo , ""%s"" , fsid . Opaque_Handle ) ) ; else ND_PRINT ( ( ndo , ""%ld"" , ( long ) ino ) ) ; }
",0,409
199,"static inline int ip6_ufo_append_data ( struct sock * sk , int getfrag ( void * from , char * to , int offset , int len , int odd , struct sk_buff * skb ) , void * from , int length , int hh_len , int fragheaderlen , int transhdrlen , int mtu , unsigned int flags , struct sk_buff * skb ) { struct sk_buff * skb ; int err ; if ( ( skb = skb_peek_tail ( & sk -> sk_write_queue ) ) == NULL ) { skb = sock_alloc_send_skb ( sk , hh_len + fragheaderlen + transhdrlen + 20 , ( flags & MSG_DONTWAIT ) , & err ) ; if ( skb == NULL ) return - ENOMEM ; skb_reserve ( skb , hh_len ) ; skb_put ( skb , fragheaderlen + transhdrlen ) ; skb_reset_network_header ( skb ) ; skb -> transport_header = skb -> network_header + fragheaderlen ; skb -> ip_summed = CHECKSUM_PARTIAL ; skb -> csum = 0 ; } err = skb_append_datato_frags ( sk , skb , getfrag , from , ( length - transhdrlen ) ) ; if ( ! err ) { struct frag_hdr fhdr ; skb_shinfo ( skb ) -> gso_size = ( mtu - fragheaderlen - sizeof ( struct frag_hdr ) ) & ~ 7 ; skb_shinfo ( skb ) -> gso_type = SKB_GSO_UDP ; ipv6_select_ident ( & fhdr , & skb ) ; skb_shinfo ( skb ) -> ip6_frag_id = fhdr . identification ; __skb_queue_tail ( & sk -> sk_write_queue , skb ) ; return 0 ; } kfree_skb ( skb ) ; return err ; }
",0,467
200,"int hsr_dev_finalize ( struct net_device * hsr_dev , struct net_device * slave [ 2 ] , unsigned char multicast_spec , u8 protocol_version ) { struct hsr_priv * hsr ; struct hsr_port * port ; int res ; hsr = netdev_priv ( hsr_dev ) ; INIT_LIST_HEAD ( & hsr -> ports ) ; INIT_LIST_HEAD ( & hsr -> node_db ) ; INIT_LIST_HEAD ( & hsr -> self_node_db ) ; ether_addr_copy ( hsr_dev -> dev_addr , slave [ 0 ] -> dev_addr ) ; res = hsr_create_self_node ( & hsr -> self_node_db , hsr_dev -> dev_addr , slave [ 1 ] -> dev_addr ) ; if ( res < 0 ) return res ; spin_lock_init ( & hsr -> seqnr_lock ) ; hsr -> sequence_nr = HSR_SEQNR_START ; hsr -> sup_sequence_nr = HSR_SUP_SEQNR_START ; timer_setup ( & hsr -> announce_timer , hsr_announce , 0 ) ; timer_setup ( & hsr -> prune_timer , hsr_prune_nodes , 0 ) ; ether_addr_copy ( hsr -> sup_multicast_addr , def_multicast_addr ) ; hsr -> sup_multicast_addr [ ETH_ALEN - 1 ] = multicast_spec ; hsr -> protVersion = protocol_version ; netif_carrier_off ( hsr_dev ) ; res = hsr_add_port ( hsr , hsr_dev , HSR_PT_MASTER ) ; if ( res ) goto err_add_port ; res = register_netdevice ( hsr_dev ) ; if ( res ) goto fail ; res = hsr_add_port ( hsr , slave [ 0 ] , HSR_PT_SLAVE_A ) ; if ( res ) goto fail ; res = hsr_add_port ( hsr , slave [ 1 ] , HSR_PT_SLAVE_B ) ; if ( res ) goto fail ; mod_timer ( & hsr ->
",0,511
201,"void parser ( void ) { char * arg ; # ifndef MINIMAL char * sitearg ; # endif # ifdef WITH_RFC2640 char * narg = NULL ; # endif size_t n ; # ifdef IMPLICIT_TLS ( void ) tls_init_new_session ( ) ; data_protection_level = CPL_PRIVATE ; # endif for ( ; ; ) { xferfd = - 1 ; if ( state_needs_update != 0 ) { state_needs_update = 0 ; setprocessname ( ""pure-ftpd(IDLE)"" ) ; # ifdef FTPWHO if ( shm_data_cur != NULL ) { ftpwho_lock ( ) ; shm_data_cur -> state = FTPWHO_STATE_IDLE ; * shm_data_cur -> filename = 0 ; ftpwho_unlock ( ) ; } # endif } doreply ( ) ; alarm ( idletime * 2 ) ; switch ( sfgets ( ) ) { case - 1 : # ifdef BORING_MODE die ( 421 , LOG_INFO , MSG_TIMEOUT ) ; # else die ( 421 , LOG_INFO , MSG_TIMEOUT_PARSER ) ; # endif case - 2 : return ; } # ifdef DEBUG if ( debug != 0 ) { addreply ( 0 , ""%s"" , cmd ) ; } # endif n = ( size_t ) 0U ; while ( ( isalpha ( ( unsigned char ) cmd [ n ] ) || cmd [ n ] == '@' ) && n < cmdsize ) { cmd [ n ] = ( char ) tolower ( ( unsigned char ) cmd [ n ] ) ; n ++ ; } if ( n >= cmdsize ) { die ( 421 , LOG_WARNING , MSG_LINE_TOO_LONG ) ; } if ( n == ( size_t ) 0U ) { nop : addreply_noformat ( 500 , ""?"" ) ; continue ; } # ifdef SKIP_COMMAND_TRAILING_SPACES while ( isspace ( ( unsigned char ) cmd [ n ] ) && n < cmdsize ) { cmd [ n ++ ] = 0 ; } arg = cmd + n ; while ( cmd [ n ] != 0 && n < cmdsize ) { n ++ ; } n -- ; while ( isspace (
",0,511
202,"void vp9_setup_dst_planes ( MACROBLOCKD * xd , const YV12_BUFFER_CONFIG * src , int mi_row , int mi_col ) { uint8_t * const buffers [ 4 ] = { src -> y_buffer , src -> u_buffer , src -> v_buffer , src -> alpha_buffer , src -> mask_table [ i ] , src -> subsampling_x , pd -> subsampling_y ) ; } }
",0,111
203,"int nfs3svc_decode_writeargs ( struct svc_rqst * rqstp , __be32 * p , struct nfsd3_writeargs * args ) { unsigned int len , v , hdr , dlen ; u32 max_blocksize = svc_max_payload ( rqstp ) ; struct kvec * head = rqstp -> rq_arg . head ; struct kvec * tail = rqstp -> rq_arg . tail ; p = decode_fh ( p , & args -> fh ) ; if ( ! p ) return 0 ; p = xdr_decode_hyper ( p , & args -> offset ) ; args -> count = ntohl ( * p ++ ) ; if ( args -> count != args -> len ) return 0 ; hdr = ( void * ) p - head -> iov_base ; dlen = head -> iov_len + rqstp -> rq_arg . page_len + tail -> iov_len - hdr ; if ( dlen < XDR_QUADLEN ( len ) * 4 ) return 0 ; if ( args -> count > max_blocksize ) { args -> count = max_blocksize ; len = args -> len = max_blocksize ; } rqstp -> rq_vec [ 0 ] . iov_base = ( void * ) p ; rqstp -> rq_vec [ 0 ] . iov_len = head -> iov_len - hdr ; v = 0 ; while ( len > rqstp -> rq_vec [ v ] . iov_len ) { len -= rqstp -> rq_vec [ v ] . iov_len ; v ++ ; rqstp -> rq_vec [ v ] . iov_base = page_address ( rqstp -> rq_pages [ v ] ) ; rqstp -> rq_vec [ v ] . iov_len = PAGE_SIZE ; } rqstp -> rq_vec [ v ] . iov_len = len ; args -> vlen = v + 1 ; return 1 ; }
",0,482
204,"static inline int assign_eip_near ( struct x86_emulate_ctxt * ctxt , ulong dst ) { return assign_eip_far ( ctxt , dst , ctxt -> mode == X86EMUL_MODE_PROT64 ) ; }
",1,60
205,"static vpx_codec_err_t ctrl_set_invert_tile_order ( vpx_codec_alg_priv_t * ctx , va_list args ) { ctx -> invert_tile_order = va_arg ( args , int ) ; return VPX_CODEC_OK ; }
",1,74
206,"static int dissect_spoolss_uint16uni ( tvbuff_t * tvb , int offset , packet_info * pinfo _U_ , proto_tree * tree , guint8 * drep _U_ , char * * data , int hf_name ) { gint len , remaining ; char * text ; if ( offset % 2 ) offset += 2 - ( offset % 2 ) ; remaining = tvb_captured_length_remaining ( tvb , offset , 2 ) ; if ( remaining <= 0 ) { if ( data ) * data = g_strdup ( """" ) ; return offset ; } text = tvb_get_string_enc ( NULL , tvb , offset , remaining , ENC_UTF_16 | ENC_LITTLE_ENDIAN ) ; len = ( int ) strlen ( text ) ; proto_tree_add_string ( tree , hf_name , tvb , offset , len * 2 , text ) ; if ( data ) * data = text ; else g_free ( text ) ; return offset + ( len + 1 ) * 2 ; }
",0,241
207,"static ssize_t ocfs2_direct_IO ( struct kiocb * iocb , struct iov_iter * iter ) { struct file * file = iocb -> ki_filp ; struct inode * inode = file -> f_mapping -> host ; struct ocfs2_super * osb = OCFS2_SB ( inode -> i_sb ) ; get_block_t * get_block ; if ( OCFS2_I ( inode ) -> ip_dyn_features & OCFS2_INLINE_DATA_FL ) return 0 ; if ( iocb -> ki_pos + iter -> count > i_size_read ( inode ) && ! ocfs2_supports_append_dio ( osb ) ) return 0 ; if ( iov_iter_rw ( iter ) == READ ) get_block = ocfs2_get_block ; else get_block = ocfs2_dio_get_block ; return __blockdev_direct_IO ( iocb , inode , inode -> i_sb -> s_bdev , iter , get_block , ocfs2_dio_end_io , NULL , 0 ) ; }
",0,272
208,"static int rawsock_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { int noblock = flags & MSG_DONTWAIT ; struct sock * sk = sock -> sk ; struct sk_buff * skb ; int copied ; int rc ; pr_debug ( ""sock=%psk=%plen=%zuflags=%d\\n"" , sock , sk , len , flags ) ; skb = skb_recv_datagram ( sk , flags , noblock , & rc ) ; if ( ! skb ) return rc ; copied = skb -> len ; if ( len < copied ) { msg -> msg_flags |= MSG_TRUNC ; copied = len ; } rc = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; skb_free_datagram ( sk , skb ) ; return rc ? : copied ; }
",1,225
209,"void M_LoadDefaults ( void ) { int i ; int len ; FILE * f ; char def [ 80 ] ; char strparm [ 100 ] ; char * newstring ; int parm ; boolean isstring ; numdefaults = sizeof ( defaults ) / sizeof ( defaults [ 0 ] ) ; for ( i = 0 ; i < numdefaults ; i ++ ) * defaults [ i ] . location = defaults [ i ] . defaultvalue ; i = M_CheckParm ( ""-config"" ) ; if ( i && i < myargc - 1 ) { defaultfile = myargv [ i + 1 ] ; printf ( ""\tdefaultfile:%s\\n"" , defaultfile ) ; } else defaultfile = basedefault ; f = fopen ( defaultfile , ""r"" ) ; if ( f ) { while ( ! feof ( f ) ) { isstring = false ; if ( fscanf ( f , ""%79s%[^\\n]\\n"" , def , strparm ) && ( strparm [ 0 ] == \'""\' ) { isstring = true ; len = strlen ( strparm ) ; newstring = ( char * ) malloc ( len ) ; strparm [ len - 1 ] = 0 ; strcpy ( newstring , strparm + 1 ) ; } else if ( strparm [ 0 ] == '0' && strparm [ 1 ] == 'x' ) sscanf ( strparm + 2 , ""%x"" , & parm ) ; else sscanf ( strparm , ""%i"" , & parm ) ; for ( i = 0 ; i < numdefaults ; i ++ ) if ( ! strcmp ( def , defaults [ i ] . name ) ) { if ( ! isstring ) * defaults [ i ] . location = parm ; else * defaults [ i ] . location = ( int ) newstring ; break ; } } } fclose ( f ) ; } for ( i = 0 ; i < numdefaults ; i ++ ) { if ( defaults [ i ] . scantranslate ) { parm = * defaults [ i ] . location ; defaults [ i ] . untranslated = parm ; * defaults [ i ] . location = scantokey [ parm ] ; } } }
",0,496
210,"static void perf_event_interrupt ( struct pt_regs * regs ) { int i ; struct cpu_hw_events * cpuhw = & __get_cpu_var ( cpu_hw_events ) ; struct perf_event * event ; unsigned long val ; int found = 0 ; int nmi ; if ( cpuhw -> n_limited ) freeze_limited_counters ( cpuhw , mfspr ( SPRN_PMC5 ) , mfspr ( SPRN_PMC6 ) ) ; perf_read_regs ( regs ) ; nmi = perf_intr_is_nmi ( regs ) ; if ( nmi ) nmi_enter ( ) ; else irq_enter ( ) ; for ( i = 0 ; i < cpuhw -> n_events ; ++ i ) { event = cpuhw -> event [ i ] ; if ( ! event -> hw . idx || is_limited_pmc ( event -> hw . idx ) ) continue ; val = read_pmc ( event -> hw . idx ) ; if ( ( int ) val < 0 ) { found = 1 ; record_and_restart ( event , val , regs , nmi ) ; } } if ( ! found ) { for ( i = 0 ; i < ppmu -> n_counter ; ++ i ) { if ( is_limited_pmc ( i + 1 ) ) continue ; val = read_pmc ( i + 1 ) ; write_pmc ( i + 1 , 0 ) ; } } write_mmcr0 ( cpuhw , cpuhw -> mmcr [ 0 ] ) ; if ( nmi ) nmi_exit ( ) ; else irq_exit ( ) ; }
",0,382
211,"static ssize_t next_line ( struct archive_read * a , const char * * b , ssize_t * avail , ssize_t * ravail , ssize_t * nl ) { ssize_t len ; int quit ; quit = 0 ; if ( * avail == 0 ) { * nl = 0 ; len = 0 ; } else len = get_line_size ( * b , * avail + len , nl ) ; while ( * nl == 0 && len == * avail && ! quit ) { ssize_t diff = * ravail - * avail ; size_t nbytes_req = ( * ravail + 1023 ) & ~ 1023U ; ssize_t tested ; if ( nbytes_req < ( size_t ) * ravail + 160 ) nbytes_req <<= 1 ; * b = __archive_read_ahead ( a , nbytes_req , avail ) ; if ( * b == NULL ) { if ( * ravail >= * avail ) return ( 0 ) ; * b = __archive_read_ahead ( a , * avail , avail ) ; quit = 1 ; } * ravail = * avail ; * b += diff ; * avail -= diff ; tested = len ; len = get_line_size ( * b , * avail , nl ) ; if ( len >= 0 ) len += tested ; } return ( len ) ; }
",0,305
212,"static expr_ty fstring_compile_expr ( const char * expr_start , const char * expr_end , struct compiling * c , const node * n ) { const char * start = expr_start ; char * str ; PyObject * o , * fstring_name ; Py_ssize_t len ; Py_ssize_t i ; assert ( expr_end >= expr_start ) ; assert ( * ( expr_start - 1 ) == '{' ) ; assert ( * expr_end == '}' || * expr_end == '!' || * expr_end == ':' ) ; o = PyUnicode_DecodeUTF8 ( expr_start , expr_end - expr_start , NULL , NULL ) ; if ( o == NULL ) return NULL ; len = PyUnicode_GET_LENGTH ( o ) ; kind = PyUnicode_KIND ( o ) ; data = PyUnicode_DATA ( o ) ; for ( i = 0 ; i < len ; i ++ ) { if ( ! Py_UNICODE_ISSPACE ( PyUnicode_READ ( kind , data , i ) ) ) { all_whitespace = 0 ; break ; } } Py_DECREF ( o ) ; if ( all_whitespace ) { ast_error ( c , n , ""f-string:emptyexpressionnotallowed"" ) ; return NULL ; } len = expr_end - expr_start ; str = PyMem_RawMalloc ( len + 3 ) ; if ( str == NULL ) return NULL ; str [ 0 ] = '(' ; memcpy ( str + 1 , expr_start , len ) ; str [ len + 1 ] = ')' ; str [ len + 2 ] = 0 ; cf . cf_flags = PyCF_ONLY_AST ; fstring_name = PyUnicode_FromString ( ""<fstring>"" ) ; mod = string_object_to_c_ast ( str , fstring_name , Py_eval_input , & cf , c -> c_feature_version , c -> c_arena ) ; Py_DECREF ( fstring_name ) ; PyMem_RawFree ( str ) ; if ( ! cf . cf_flags ) { Py_DECREF ( start ) ; return NULL ; } Py_DECREF ( cf . cf_flags
",0,511
213,"static void ntlm_print_message_fields ( NTLM_MESSAGE_FIELDS * fields , const char * name ) { WLog_DBG ( TAG , ""%s(Len:%"" PRIu16 ""MaxLen:%"" PRIu16 ""BufferOffset:%"" PRIu32 "")"" , name , fields -> Len , fields -> MaxLen , fields -> BufferOffset ) ; if ( fields -> Len > 0 ) winpr_HexDump ( TAG , WLOG_DEBUG , fields -> Buffer , fields -> Len ) ; }
",1,123
214,"cJSON * cJSON_GetObjectItem ( cJSON * object , const char * string ) { cJSON * c = object -> child ; while ( c && cJSON_strcasecmp ( c -> string , string ) ) c = c -> next ; return c ; }
",0,59
215,"static inline key_ref_t __key_update ( key_ref_t key_ref , struct key_preparsed_payload * prep ) { struct key * key = key_ref_to_ptr ( key_ref ) ; int ret ; ret = key_permission ( key_ref , KEY_NEED_WRITE ) ; if ( ret < 0 ) goto error ; ret = - EEXIST ; if ( ! key -> type -> update ) goto error ; down_write ( & key -> sem ) ; ret = key -> type -> update ( key , prep ) ; if ( ret == 0 ) mark_key_instantiated ( key , 0 ) ; up_write ( & key -> sem ) ; if ( ret < 0 ) goto error ; out : return key_ref ; error : key_put ( key ) ; key_ref = ERR_PTR ( ret ) ; goto out ; }
",1,198
216,"int net_get ( int s , void * arg , int * len ) { struct net_hdr nh ; int plen ; if ( net_read_exact ( s , & nh , sizeof ( nh ) ) == - 1 ) { return - 1 ; } plen = ntohl ( nh . nh_len ) ; if ( ! ( plen <= * len && plen > 0 ) ) printf ( ""PLEN%dtype%dlen%d\\n"" , plen , nh . nh_type , * len ) ; assert ( plen <= * len ) ; * len = plen ; if ( ( * len ) && ( net_read_exact ( s , arg , * len ) == - 1 ) ) { return - 1 ; } return nh . nh_type ; }
",1,183
217,"int xfs_attr3_leaf_list_int ( struct xfs_buf * bp , struct xfs_attr_list_context * context ) { struct attrlist_cursor_kern * cursor ; struct xfs_attr_leafblock * leaf ; struct xfs_attr3_icleaf_hdr ichdr ; struct xfs_attr_leaf_entry * entries ; struct xfs_attr_leaf_entry * entry ; int retval ; int i ; trace_xfs_attr_list_leaf ( context ) ; leaf = bp -> b_addr ; xfs_attr3_leaf_hdr_from_disk ( & ichdr , leaf ) ; entries = xfs_attr3_leaf_entryp ( leaf ) ; cursor = context -> cursor ; cursor -> initted = 1 ; if ( context -> resynch ) { entry = & entries [ 0 ] ; for ( i = 0 ; i < ichdr . count ; entry ++ , i ++ ) { if ( be32_to_cpu ( entry -> hashval ) == cursor -> hashval ) { if ( cursor -> offset == context -> dupcnt ) { context -> dupcnt = 0 ; break ; } context -> dupcnt ++ ; } else if ( be32_to_cpu ( entry -> hashval ) > cursor -> hashval ) { context -> dupcnt = 0 ; break ; } } if ( i == ichdr . count ) { trace_xfs_attr_list_notfound ( context ) ; return 0 ; } } else { entry = & entries [ 0 ] ; i = 0 ; } context -> resynch = 0 ; retval = 0 ; for ( ; i < ichdr . count ; entry ++ , i ++ ) { if ( be32_to_cpu ( entry -> hashval ) != cursor -> hashval ) { cursor -> hashval = be32_to_cpu ( entry -> hashval ) ; cursor -> offset = 0 ; } if ( entry -> flags & XFS_ATTR_INCOMPLETE ) continue ; if ( entry -> flags & XFS_ATTR_LOCAL ) { xfs_attr_leaf_name_local_t * name_loc = xfs_attr3_leaf_name_local ( leaf , i ) ; retval = context -> put_listent ( context , entry
",0,511
218,"asmlinkage long compat_sys_recvmmsg ( int fd , struct compat_mmsghdr __user * mmsg , unsigned int vlen , unsigned int flags , struct compat_timespec __user * timeout ) { int datagrams ; struct timespec ktspec ; if ( timeout == NULL ) return __sys_recvmmsg ( fd , ( struct mmsghdr __user * ) mmsg , vlen , flags | MSG_CMSG_COMPAT , NULL ) ; if ( get_compat_timespec ( & ktspec , timeout ) ) return - EFAULT ; datagrams = __sys_recvmmsg ( fd , ( struct mmsghdr __user * ) mmsg , vlen , flags | MSG_CMSG_COMPAT , & ktspec ) ; if ( compat_get_timespec ( & ktspec , timeout ) ) datagrams = - EFAULT ; return datagrams ; }
",1,213
219,"static Image * ReadSUNImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define RMT_EQUAL_RGB 1 # define RMT_NONE 0 # define RMT_RAW 2 # define RT_STANDARD 1 # define RT_ENCODED 2 # define RT_FORMAT_RGB 3 typedef struct _SUNInfo { unsigned int magic , width , height , depth , length , type , maptype , maplength ; } SUNInfo ; Image * image ; int bit ; MagickBooleanType status ; MagickSizeType number_pixels ; register Quantum * q ; register ssize_t i , x ; register unsigned char * p ; size_t bytes_per_line , extent , length ; ssize_t count , y ; SUNInfo sun_info ; unsigned char * sun_data , * sun_pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) ResetMagickMemory ( & sun_info , 0 , sizeof ( sun_info ) ) ; sun_info . magic = ReadBlobMSBLong ( image ) ; do { if ( sun_info . magic != 0x59a66a95 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; sun_info . width = ReadBlobMSBLong ( image ) ; sun_info . height = ReadBlobMSBLong ( image ) ; sun_info . depth = ReadBlobMSBLong ( image ) ; sun_info . length = ReadBlobMSBLong ( image ) ; sun_info . type = ReadBlobMSBLong ( image ) ; sun_info . maptype = Read
",0,511
220,"static netdev_tx_t hns_nic_net_xmit ( struct sk_buff * skb , struct net_device * ndev ) { struct hns_nic_priv * priv = netdev_priv ( ndev ) ; assert ( skb -> queue_mapping < ndev -> ae_handle -> q_num ) ; return hns_nic_net_xmit_hw ( ndev , skb , & tx_ring_data ( priv , skb -> queue_mapping ) ) ; }
",1,116
221,"static int hash_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct hash_ctx * ctx = ask -> private ; unsigned ds = crypto_ahash_digestsize ( crypto_ahash_reqtfm ( & ctx -> req ) ) ; int err ; if ( len > ds ) len = ds ; else if ( len < ds ) msg -> msg_flags |= MSG_TRUNC ; msg -> msg_namelen = 0 ; lock_sock ( sk ) ; if ( ctx -> more ) { ctx -> more = 0 ; ahash_request_set_crypt ( & ctx -> req , NULL , ctx -> result , 0 ) ; err = af_alg_wait_for_completion ( crypto_ahash_final ( & ctx -> req ) , & ctx -> completion ) ; if ( err ) goto unlock ; } err = memcpy_toiovec ( msg -> msg_iov , ctx -> result , len ) ; unlock : release_sock ( sk ) ; return err ? : len ; }
",0,283
222,"int main ( int argc , char * * argv ) { int c ; bool lock_memory = false ; bool do_daemonize = false ; bool preallocate = false ; int maxcore = 0 ; char * username = NULL ; char * pid_file = NULL ; struct passwd * pw ; struct rlimit rlim ; char * buf ; char unit = '\\0' ; int size_max = 0 ; int retval = EXIT_SUCCESS ; static int * l_socket = NULL ; static int * u_socket = NULL ; bool protocol_specified = false ; bool tcp_specified = false ; bool udp_specified = false ; bool start_lru_maintainer = true ; bool start_lru_crawler = true ; bool start_assoc_maint = true ; enum hashfunc_type hash_type = MURMUR3_HASH ; uint32_t tocrawl ; uint32_t slab_sizes [ MAX_NUMBER_OF_SLAB_CLASSES ] ; bool use_slab_sizes = false ; char * slab_sizes_unparsed = NULL ; bool slab_chunk_size_changed = false ; # ifdef EXTSTORE void * storage = NULL ; char * storage_file = NULL ; struct extstore_conf ext_cf ; # endif char * subopts , * subopts_orig ; char * subopts_value ; enum { MAXCONNS_FAST = 0 , HASHPOWER_INIT , NO_HASHEXPAND , SLAB_REASSIGN , SLAB_AUTOMOVE , SLAB_AUTOMOVE_RATIO , SLAB_AUTOMOVE_WINDOW , TAIL_REPAIR_TIME , HASH_ALGORITHM , LRU_CRAWLER , LRU_CRAWLER_SLEEP , LRU_CRAWLER_TOCRAWL , LRU_MAINTAINER , HOT_LRU_PCT , WARM_LRU_PCT , HOT_MAX_FACTOR , WARM_MAX_FACTOR , TEMPORARY_TTL , IDLE_TIMEOUT , WATCHER_LOGBUF_SIZE , WORKER_LOGBUF_SIZE , SLAB_SIZES , SLAB
",0,511
223,"INST_HANDLER ( sbrx ) { int b = buf [ 0 ] & 0x7 ; int r = ( ( buf [ 0 ] >> 4 ) & 0xf ) | ( ( buf [ 1 ] & 0x01 ) << 4 ) ; RAnalOp next_op = { 0 } ; avr_op_analyze ( anal , & next_op , op -> addr + op -> size , buf + op -> size , len - op -> size , cpu ) ; r_strbuf_fini ( & next_op . esil ) ; op -> jump = op -> addr + next_op . size + 2 ; op -> cycles = 1 ; ESIL_A ( ""%d,1,<<,r%d,&,"" , b , r ) ; ESIL_A ( ( buf [ 1 ] & 0xe ) == 0xc ? ""
",0,188
224,"static gboolean prplcb_xfer_new_send_cb ( gpointer data , gint fd , b_input_condition cond ) { PurpleXfer * xfer = data ; struct im_connection * ic = purple_ic_by_pa ( xfer -> account ) ; struct prpl_xfer_data * px = xfer -> ui_data ; PurpleBuddy * buddy ; const char * who ; buddy = purple_find_buddy ( xfer -> account , xfer -> who ) ; who = buddy ? purple_buddy_get_name ( buddy ) : xfer -> who ; px -> ft = imcb_file_send_start ( ic , ( char * ) who , xfer -> filename , xfer -> size ) ; px -> ft -> data = px ; px -> ft -> accept = prpl_xfer_accept ; px -> ft -> canceled = prpl_xfer_canceled ; px -> ft -> free = prpl_xfer_free ; px -> ft -> write_request = prpl_xfer_write_request ; return FALSE ; }
",0,250
225,"int perf_config ( config_fn_t fn , void * data ) { int ret = 0 , found = 0 ; const char * home = NULL ; if ( config_exclusive_filename ) return perf_config_from_file ( fn , config_exclusive_filename , data ) ; if ( perf_config_system ( ) && ! access ( perf_etc_perfconfig ( ) , R_OK ) ) { ret += perf_config_from_file ( fn , perf_etc_perfconfig ( ) , data ) ; found += 1 ; } home = getenv ( ""HOME"" ) ; if ( perf_config_global ( ) && home ) { char * user_config = strdup ( mkpath ( ""%s/.perfconfig"" , home ) ) ; if ( ! access ( user_config , R_OK ) ) { ret += perf_config_from_file ( fn , user_config , data ) ; found += 1 ; } free ( user_config ) ; } if ( found == 0 ) return - 1 ; return ret ; }
",1,230
226,"static int validate_event ( struct pmu * pmu , struct pmu_hw_events * hw_events , struct perf_event * event ) { struct arm_pmu * armpmu ; struct hw_perf_event fake_event = event -> hw ; struct pmu * leader_pmu = event -> group_leader -> pmu ; if ( is_software_event ( event ) ) return 1 ; if ( event -> pmu != pmu ) return 0 ; if ( event -> pmu != leader_pmu || event -> state < PERF_EVENT_STATE_OFF ) return 1 ; armpmu = to_arm_pmu ( event -> pmu ) ; if ( is_software_event ( event ) ) return 1 ; if ( event -> state == PERF_EVENT_STATE_OFF && ! event -> attr . enable_on_exec ) return 1 ; return armpmu -> get_event_idx ( hw_events , & fake_event ) >= 0 ; }
",0,224
227,"static bool new_idmap_permitted ( const struct file * file , struct user_namespace * ns , int cap_setid , struct uid_gid_map * new_map ) { if ( ( new_map -> nr_extents == 1 ) && ( new_map -> extent [ 0 ] . count == 1 ) ) { u32 id = new_map -> extent [ 0 ] . lower_first ; if ( cap_setid == CAP_SETUID ) { kuid_t uid = make_kuid ( ns -> parent , id ) ; if ( uid_eq ( uid , current_fsuid ( ) ) ) return true ; } else if ( cap_setid == CAP_SETGID ) { kgid_t gid = make_kgid ( ns -> parent , id ) ; if ( gid_eq ( gid , current_fsgid ( ) ) ) return true ; } } if ( ! cap_valid ( cap_setid ) ) return true ; if ( ns_capable ( ns -> parent , cap_setid ) && file_ns_capable ( file , ns -> parent , cap_setid ) ) return true ; return false ; }
",1,266
228,"static VarLenData * * get_html_data ( MAPI_Attr * a ) { VarLenData * * body = XCALLOC ( VarLenData * , a -> num_values + 1 ) ; int j ; for ( j = 0 ; j < a -> num_values ; j ++ ) { if ( a -> type == szMAPI_BINARY ) { body [ j ] = XMALLOC ( VarLenData , 1 ) ; body [ j ] -> len = a -> values [ j ] . len ; body [ j ] -> data = CHECKED_XCALLOC ( unsigned char , a -> values [ j ] . len ) ; memmove ( body [ j ] -> data , a -> values [ j ] . data . buf , body [ j ] -> len ) ; } } return body ; }
",1,182
229,"int usb_cypress_load_firmware ( struct usb_device * udev , const struct firmware * fw , int type ) { struct hexline * hx ; u8 * buf ; int ret , pos = 0 ; u16 cpu_cs_register = cypress [ type ] . cpu_cs_register , & reset , 1 ) ) != 1 ) err ( ""couldnotstoptheUSBcontrollerCPU."" ) ; while ( ( ret = dvb_usb_get_hexline ( fw , hx , & pos ) ) > 0 ) { deb_fw ( ""writingtoaddress0x%04x(buffer:0x%02x%02x)\\n"" , hx -> addr , hx -> len , hx -> chk ) ; ret = usb_cypress_writemem ( udev , hx -> addr , hx -> data , hx -> len ) ; if ( ret != hx -> len ) { err ( ""errorwhiletransferringfirmware(transferredsize:%d,blocksize:%d)"" , ret , hx -> len ) ; ret = - EINVAL ; break ; } } if ( ret < 0 ) { err ( ""firmwaredownloadfailedat%dwith%d"" , pos , ret ) ; kfree ( hx ) ; return ret ; } if ( ret == 0 ) { reset = 0 ; if ( ret || usb_cypress_writemem ( udev , cypress [ type ] . cpu_cs_register , & reset , 1 ) != 1 ) { err ( ""couldnotrestarttheUSBcontrollerCPU."" ) ; ret = - EINVAL ; } } else ret = - EIO ; kfree ( hx ) ; return ret ; }
",0,384
230,"static void l2tp_call_errors_print ( netdissect_options * ndo , const u_char * dat , u_int length ) { const uint16_t * ptr = ( const uint16_t * ) dat ; uint16_t val_h , val_l ; if ( length < 2 ) goto trunc ; ptr ++ ; length -= 2 ; val_h = EXTRACT_16BITS ( ptr ) ; ptr ++ ; length -= 2 ; val_l = EXTRACT_16BITS ( ptr ) ; ptr ++ ; ND_PRINT ( ( ndo , ""CRCErr=%u"" , ( val_h << 16 ) + val_l ) ) ; val_h = EXTRACT_16BITS ( ptr ) ; ptr ++ ; val_l = EXTRACT_16BITS ( ptr ) ; ptr ++ ; ND_PRINT ( ( ndo , ""FrameErr=%u"" , ( val_h << 16 ) + val_l ) ) ; val_h = EXTRACT_16BITS ( ptr ) ; ptr ++ ; val_l = EXTRACT_16BITS ( ptr ) ; ptr ++ ; ND_PRINT ( ( ndo , ""HardOver=%u"" , ( val_h << 16 ) + val_l ) ) ; val_h = EXTRACT_16BITS ( ptr ) ; ptr ++ ; val_l = EXTRACT_16BITS ( ptr ) ; ptr ++ ; ND_PRINT ( ( ndo , ""BufOver=%u"" , ( val_h << 16 ) + val_l ) ) ; val_h = EXTRACT_16BITS ( ptr ) ; ptr ++ ; val_l = EXTRACT_16BITS ( ptr ) ; ptr ++ ; ND_PRINT ( ( ndo , ""Timeout=%u"" , ( val_h << 16 ) + val_l ) ) ; val_h = EXTRACT_16BITS ( ptr ) ; ptr ++ ; val_l = EXTRACT_16BITS ( ptr ) ; ptr ++ ; ND_PRINT ( ( ndo , ""AlignErr=%u"" , ( val_h << 16 ) + val_l ) ) ; }
",0,492
231,"static int check_rpcsec_auth ( struct svc_req * rqstp ) { gss_ctx_id_t ctx ; krb5_context kctx ; OM_uint32 maj_stat , min_stat ; gss_name_t name ; krb5_principal princ ; int ret , success ; krb5_data * c1 , * c2 , * realm ; gss_buffer_desc gss_str ; kadm5_server_handle_t handle ; size_t slen ; char * sdots ; success = 0 ; handle = ( kadm5_server_handle_t ) global_server_handle ; if ( rqstp -> rq_cred . oa_flavor != RPCSEC_GSS ) return 0 ; ctx = rqstp -> rq_svccred ; maj_stat = gss_inquire_context ( & min_stat , ctx , NULL , & name , NULL , NULL , NULL , NULL ) ; if ( maj_stat != GSS_S_COMPLETE ) { krb5_klog_syslog ( LOG_ERR , _ ( ""check_rpcsec_auth:failed"" ""inquire_context,stat=%u"" ) , maj_stat ) ; log_badauth ( maj_stat , min_stat , rqstp -> rq_xprt , NULL ) ; goto fail_name ; } kctx = handle -> context ; ret = gss_to_krb5_name_1 ( rqstp , kctx , name , & princ , & gss_str ) ; if ( ret == 0 ) goto fail_name ; slen = gss_str . length ; trunc_name ( & slen , & sdots ) ; if ( krb5_princ_size ( kctx , princ ) != 2 ) goto fail_princ ; c1 = krb5_princ_component ( kctx , princ , 0 ) ; c2 = krb5_princ_component ( kctx , princ , 1 ) ; realm = krb5_princ_realm ( kctx , princ ) ; success = data_eq_string ( * realm , handle -> params . realm ) && data_eq_string ( * c1 , *
",0,511
232,"static int vc4_get_bcl ( struct drm_device * dev , struct vc4_exec_info * exec ) { struct drm_vc4_submit_cl * args = exec -> args ; void * temp = NULL ; void * bin ; int ret = 0 ; uint32_t bin_offset = 0 ; uint32_t shader_rec_offset = roundup ( bin_offset + args -> bin_cl_size , 16 ) ; uint32_t uniforms_offset = shader_rec_offset + args -> shader_rec_size ; uint32_t exec_size = uniforms_offset + args -> uniforms_size ; uint32_t temp_size = exec_size + ( sizeof ( struct vc4_shader_state ) * args -> shader_rec_count ) ; struct vc4_bo * bo ; if ( shader_rec_offset < args -> bin_cl_size || uniforms_offset < shader_rec_offset || exec_size < uniforms_offset || args -> shader_rec_count >= ( UINT_MAX / sizeof ( struct vc4_shader_state ) ) || temp_size < exec_size ) { DRM_ERROR ( ""overflowinexecarguments\\n"" ) ; goto fail ; } temp = drm_malloc_ab ( temp_size , 1 ) ; if ( ! temp ) { DRM_ERROR ( ""Failedtoallocatestorageforcopying"" ""inbin/renderCLs.\\n"" ) ; ret = - ENOMEM ; goto fail ; } bin = temp + bin_offset ; exec -> shader_rec_u = temp + shader_rec_offset ; exec -> uniforms_u = temp + uniforms_offset ; exec -> shader_state = temp + exec_size ; exec -> shader_state_size = args -> shader_rec_count ; if ( copy_from_user ( bin , ( void __user * ) ( uintptr_t ) args -> bin_cl , args -> bin_cl_size ) ) { ret = - EFAULT ; goto fail ; } if ( copy_from_user ( exec -> shader_rec_u , ( void __user * ) ( uintptr_t ) args -> shader_rec , args -> shader_rec_size ) ) { ret = - EFAULT ; goto fail ; } if ( copy_from
",0,511
233,"static int archive_read_format_zip_cleanup ( struct archive_read * a ) { struct zip * zip ; struct zip_entry * zip_entry , * next_zip_entry ; zip = ( struct zip * ) ( a -> format -> data ) ; # ifdef HAVE_ZLIB_H if ( zip -> stream_valid ) inflateEnd ( & zip -> stream ) ; # endif # if HAVE_LZMA_H && HAVE_LIBLZMA if ( zip -> zipx_lzma_valid ) { lzma_end ( & zip -> zipx_lzma_stream ) ; } # endif # ifdef HAVE_BZLIB_H if ( zip -> bzstream_valid ) { BZ2_bzDecompressEnd ( & zip -> bzstream ) ; } # endif free ( zip -> uncompressed_buffer ) ; if ( zip -> ppmd8_valid ) __archive_ppmd8_functions . Ppmd8_Free ( & zip -> ppmd8 ) ; if ( zip -> zip_entries ) { zip_entry = zip -> zip_entries ; while ( zip_entry != NULL ) { next_zip_entry = zip_entry -> next ; archive_string_free ( & zip_entry -> rsrcname ) ; free ( zip_entry ) ; zip_entry = next_zip_entry ; } } free ( zip -> decrypted_buffer ) ; if ( zip -> cctx_valid ) archive_decrypto_aes_ctr_release ( & zip -> cctx ) ; if ( zip -> hctx_valid ) archive_hmac_sha1_cleanup ( & zip -> hctx ) ; free ( zip -> iv ) ; free ( zip -> erd ) ; free ( zip -> v_data ) ; archive_string_free ( & zip -> format_name ) ; free ( zip ) ; ( a -> format -> data ) = NULL ; return ( ARCHIVE_OK ) ; }
",1,433
234,"int ext4_page_mkwrite ( struct vm_area_struct * vma , struct vm_fault * vmf ) { struct page * page = vmf -> page ; loff_t size ; unsigned long len ; int ret ; struct file * file = vma -> vm_file ; struct inode * inode = file_inode ( file ) ; struct address_space * mapping = inode -> i_mapping ; handle_t * handle ; get_block_t * get_block ; int retries = 0 ; sb_start_pagefault ( inode -> i_sb ) ; if ( test_opt ( inode -> i_sb , DELALLOC ) && ! ext4_should_journal_data ( inode ) && ! ext4_nonda_switch ( inode -> i_sb ) ) { do { ret = block_page_mkwrite ( vma , vmf , ext4_da_get_block_prep ) ; } while ( ret == - ENOSPC && ext4_should_retry_alloc ( inode -> i_sb , & retries ) ) ; goto out_ret ; } lock_page ( page ) ; size = i_size_read ( inode ) ; if ( page -> mapping != mapping || page_offset ( page ) > size ) { unlock_page ( page ) ; ret = VM_FAULT_NOPAGE ; goto out ; } if ( page -> index == size >> PAGE_CACHE_SHIFT ) len = size & ~ PAGE_CACHE_MASK ; else len = PAGE_CACHE_SIZE ; if ( page_has_buffers ( page ) ) { if ( ! ext4_walk_page_buffers ( NULL , page_buffers ( page ) , 0 , len , NULL , ext4_bh_unmapped ) ) { wait_for_stable_page ( page ) ; ret = VM_FAULT_LOCKED ; goto out ; } } unlock_page ( page ) ; if ( ext4_should_dioread_nolock ( inode ) ) get_block = ext4_get_block_write ; else get_block = ext4_get_block ; retry_alloc : handle = ext4_journal_start ( inode ) ; if ( ! ( page_write ( page ) ) )
",0,511
235,"static int jas_iccgetuint64 ( jas_stream_t * in , jas_iccuint64_t * val ) { jas_ulonglong tmp ; if ( jas_iccgetuint ( in , 8 , & tmp ) ) return - 1 ; * val = tmp ; return 0 ; }
",1,71
236,"static char * __filterShell ( const char * arg ) { char ch = * arg ; switch ( ch ) { case '@' : case '`' : case '|' : case ';' : case '=' : case '\\n' : break ; default : * b ++ = * arg ; break ; } arg ++ ; } * b = 0 ; return a ; }
",1,82
237,"static const u_char * ikev1_t_print ( netdissect_options * ndo , u_char tpay _U_ , const struct isakmp_gen * ext , u_int item_len , const u_char * ep , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto , int depth _U_ ) { const struct ikev1_pl_t * p ; struct ikev1_pl_t t ; const u_char * cp ; const char * idstr ; const struct attrmap * map ; size_t nmap ; const u_char * ep2 ; ND_PRINT ( ( ndo , ""%s:"" , NPSTR ( ISAKMP_NPTYPE_T ) ) ) ; p = ( const struct ikev1_pl_t * ) ext ; ND_TCHECK ( * p ) ; UNALIGNED_MEMCPY ( & t , ext , sizeof ( t ) ) ; switch ( proto ) { case 1 : idstr = STR_OR_ID ( t . t_id , ikev1_p_map ) ; map = oakley_t_map ; nmap = sizeof ( oakley_t_map ) / sizeof ( oakley_t_map [ 0 ] ) ; break ; case 2 : idstr = STR_OR_ID ( t . t_id , ah_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 3 : idstr = STR_OR_ID ( t . t_id , esp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; case 4 : idstr = STR_OR_ID ( t . t_id , ipcomp_p_map ) ; map = ipsec_t_map ; nmap = sizeof ( ipsec_t_map ) / sizeof ( ipsec_t_map [ 0 ] ) ; break ; default : idstr = NULL ; map = NULL ; nmap = 0 ; break ; } if ( idstr ) ND_PRINT ( ( n
",0,511
238,"G_DEFINE_TYPE ( GsmXsmpServer , gsm_xsmp_server , G_TYPE_OBJECT ) typedef struct { GsmXsmpServer * server ; IceListenObj listener ; } GsmIceConnectionData ; typedef struct { guint watch_id ; guint protocol_timeout ; } GsmIceConnectionWatch ; static void disconnect_ice_connection ( IceConn ice_conn ) { IceSetShutdownNegotiation ( ice_conn , FALSE ) ; IceCloseConnection ( ice_conn ) ; }
",1,117
239,"static struct sk_buff * udp6_ufo_fragment ( struct sk_buff * skb , u32 features ) { struct sk_buff * segs = ERR_PTR ( - EINVAL ) ; unsigned int mss ; unsigned int unfrag_ip6hlen , unfrag_len ; struct frag_hdr * fptr ; u8 * mac_start , * prevhdr ; u8 nexthdr ; u8 frag_hdr_sz = sizeof ( struct frag_hdr ) ; int offset ; __wsum csum ; mss = skb_shinfo ( skb ) -> gso_size ; if ( unlikely ( skb -> len <= mss ) ) goto out ; if ( skb_gso_ok ( skb , features | NETIF_F_GSO_ROBUST ) ) { int type = skb_shinfo ( skb ) -> gso_type ; if ( unlikely ( type & ~ ( SKB_GSO_UDP | SKB_GSO_DODGY ) || ! ( type & ( SKB_GSO_UDP ) ) ) ) goto out ; skb_shinfo ( skb ) -> gso_segs = DIV_ROUND_UP ( skb -> len , mss ) ; segs = NULL ; goto out ; } offset = skb -> csum_start - skb_headroom ( skb ) ; csum = skb_checksum ( skb , offset , skb -> len - offset , 0 ) ; offset += skb -> csum_offset ; * ( __sum16 * ) ( skb -> data + offset ) = csum_fold ( csum ) ; skb -> ip_summed = CHECKSUM_NONE ; if ( ( skb_mac_header ( skb ) < skb -> head + frag_hdr_sz ) && pskb_expand_head ( skb , frag_hdr_sz , 0 , GFP_ATOMIC ) ) goto out ; unfrag_ip6hlen = ip6_find_1stfragopt ( skb , & prevhdr ) ; nexthdr = * prevhdr ; * prevhdr = NEXTHDR_FRAGMENT ; unfrag_len =
",0,511
240,"void test_checkout_nasty__git_tilde1 ( void ) { # ifdef GIT_WIN32 test_checkout_fails ( ""refs/heads/git_tilde1"" , "".git/foobar"" ) ; # endif }
",0,59
241,"int sock_getsockopt ( struct socket * sock , int level , int optname , char __user * optval , int __user * optlen ) { struct sock * sk = sock -> sk ; union { int val ; struct linger ling ; struct timeval tm ; } v ; int lv = sizeof ( int ) ; int len ; if ( get_user ( len , optlen ) ) return - EFAULT ; if ( len < 0 ) return - EINVAL ; memset ( & v , 0 , sizeof ( v ) ) ; switch ( optname ) { case SO_DEBUG : v . val = ! ! sock_flag ( sk , SOCK_DBG ) ; break ; case SO_DONTROUTE : v . val = sock_flag ( sk , SOCK_LOCALROUTE ) ; break ; case SO_BROADCAST : v . val = ! ! sock_flag ( sk , SOCK_BROADCAST ) ; break ; case SO_SNDBUF : v . val = sk -> sk_sndbuf ; break ; case SO_RCVBUF : v . val = sk -> sk_rcvbuf ; break ; case SO_REUSEADDR : v . val = sk -> sk_reuse ; break ; case SO_KEEPALIVE : v . val = ! ! sock_flag ( sk , SOCK_KEEPOPEN ) ; break ; case SO_TYPE : v . val = sk -> sk_type ; break ; case SO_PROTOCOL : v . val = sk -> sk_protocol ; break ; case SO_DOMAIN : v . val = sk -> sk_family ; break ; case SO_ERROR : v . val = - sock_error ( sk ) ; if ( v . val == 0 ) v . val = xchg ( & sk -> sk_err_soft , 0 ) ; break ; case SO_OOBINLINE : v . val = ! ! sock_flag ( sk , SOCK_URGINLINE ) ; break ; case SO_NO_CHECK : v . val = sk -> sk_no_check ; break ; case SO_PRIORITY : v . val = sk -> sk_priority ; break ; case SO_LINGER : lv = sizeof ( v . ling ) ; v . ling . l_onoff = ! ! sock_flag ( sk
",0,511
242,"int bt_sock_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { int noblock = flags & MSG_DONTWAIT ; struct sock * sk = sock -> sk ; struct sk_buff * skb ; size_t copied ; int err ; BT_DBG ( ""sock%psk%plen%zu"" , sock , sk , len ) ; if ( flags & ( MSG_OOB ) ) return - EOPNOTSUPP ; skb = skb_recv_datagram ( sk , flags , noblock , & err ) ; if ( ! skb ) { if ( sk -> sk_shutdown & RCV_SHUTDOWN ) return 0 ; return err ; } copied = skb -> len ; if ( len < copied ) { msg -> msg_flags |= MSG_TRUNC ; copied = len ; } skb_reset_transport_header ( skb ) ; err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; if ( err == 0 ) { sock_recv_ts_and_drops ( msg , sk , skb ) ; if ( bt_sk ( sk ) -> skb_msg_name ) bt_sk ( sk ) -> skb_msg_name ( skb , msg -> msg_name , & msg -> msg_namelen ) ; } skb_free_datagram ( sk , skb ) ; return err ? : copied ; }
",1,350
243,"SQLWCHAR * _multi_string_alloc_and_expand ( LPCSTR in ) { SQLWCHAR * chr ; int len = 0 ; if ( ! in ) { return NULL ; } while ( in [ len ] != 0 || in [ len + 1 ] != 0 ) { len ++ ; } chr = malloc ( sizeof ( SQLWCHAR ) * ( len + 2 ) ) ; len = 0 ; while ( in [ len ] != 0 || in [ len + 1 ] != 0 ) { chr [ len ] = in [ len ] ; len ++ ; } chr [ len ++ ] = 0 ; chr [ len ++ ] = 0 ; return chr ; }
",1,149
244,"void vp9_setup_pre_planes ( MACROBLOCKD * xd , int idx , const YV12_BUFFER_CONFIG * src , int mi_row , int mi_col , const struct scale_factors * sf ) { if ( src != NULL ) { int i ; uint8_t * const buffers [ 4 ] = { src -> y_buffer , src -> u_buffer , src -> v_buffer , src -> alpha_buffer } ; const int strides [ 4 ] = { src -> y_stride , src -> uv_stride , src -> uv_stride , src -> alpha_stride } ; for ( i = 0 ; i < MAX_MB_PLANE ; ++ i ) { struct macroblockd_plane * const pd = & xd -> plane [ i ] ; setup_pred_plane ( & pd -> pre [ idx ] , buffers [ i ] , strides [ i ] , mi_row , mi_col , sf , pd -> subsampling_x , pd -> subsampling_y ) ; } } }
",0,243
245,"static krb5_error_code get_matching_data ( krb5_context context , pkinit_plg_crypto_context plg_cryptoctx , pkinit_req_crypto_context req_cryptoctx , X509 * cert , pkinit_cert_matching_data * * md_out ) { krb5_error_code ret = ENOMEM ; pkinit_cert_matching_data * md = NULL ; krb5_principal * pkinit_sans = NULL , * upn_sans = NULL ; size_t i , j ; char buf [ NAME_BUF_LEN ] ; unsigned int bufsize = sizeof ( buf ) ; * md_out = NULL ; md = calloc ( 1 , sizeof ( * md ) ) ; if ( md == NULL ) goto cleanup ; X509_NAME_oneline_ex ( X509_get_subject_name ( cert ) , buf , & bufsize , XN_FLAG_SINGLE ) ; md -> subject_dn = strdup ( buf ) ; if ( md -> subject_dn ) ; if ( ret ) goto cleanup ; ret = crypto_retrieve_X509_sans ( context , plg_cryptoctx , req_cryptoctx , cert , & pkinit_sans , & upn_sans , NULL ) ; if ( ret ) goto cleanup ; j = 0 ; if ( pkinit_sans != NULL ) { for ( i = 0 ; pkinit_sans [ i ] != NULL ; i ++ ) j ++ ; } if ( upn_sans != NULL ) { for ( i = 0 ; upn_sans [ i ] != NULL ; i ++ ) j ++ ; } if ( j != 0 ) { md -> sans = calloc ( ( size_t ) j + 1 , sizeof ( * md -> sans ) ) ; if ( md -> sans == NULL ) { ret = ENOMEM ; goto cleanup ; } ret = crypto_retrieve_X509_sans ( context , plg_cryptoctx , req_cryptoctx , cert , & pkinit_sans , & upn_sans , NULL ) ; if ( ret ) goto cleanup ; j = 0 ; if ( pkinit_sans != NULL )
",0,511
246,"int __kvm_set_memory_region ( struct kvm * kvm , struct kvm_userspace_memory_region * mem , int user_alloc ) { int r ; gfn_t base_gfn ; unsigned long npages ; unsigned long i ; struct kvm_memory_slot * memslot ; struct kvm_memory_slot old , new ; struct kvm_memslots * slots , * old_memslots ; r = check_memory_region_flags ( mem ) ; if ( r ) goto out ; r = - EINVAL ; if ( mem -> memory_size & ( PAGE_SIZE - 1 ) ) goto out ; if ( mem -> guest_phys_addr & ( PAGE_SIZE - 1 ) ) goto out ; if ( user_alloc && ( ( mem -> userspace_addr & ( PAGE_SIZE - 1 ) ) || ! access_ok ( VERIFY_WRITE , ( void __user * ) ( unsigned long ) mem -> userspace_addr , mem -> memory_size ) ) ) goto out ; if ( mem -> slot >= KVM_MEM_SLOTS_NUM ) goto out ; if ( mem -> guest_phys_addr + mem -> memory_size < mem -> guest_phys_addr ) goto out ; memslot = id_to_memslot ( kvm -> memslots , mem -> slot ) ; base_gfn = mem -> guest_phys_addr >> PAGE_SHIFT ; npages = mem -> memory_size >> PAGE_SHIFT ; r = - EINVAL ; if ( npages > KVM_MEM_MAX_NR_PAGES ) goto out ; if ( ! npages ) mem -> flags &= ~ KVM_MEM_LOG_DIRTY_PAGES ; new = old = * memslot ; new . id = mem -> slot ; new . base_gfn = base_gfn ; new . npages = npages ; new . flags = mem -> flags ; r = - EINVAL ; if ( npages && old . npages && npages != old . npages ) goto out_free ; r = - EEXIST ; for ( i = 0 ; i < KVM_MEMORY_SLOTS ; ++ i ) { struct kvm_memory_slot * s = & kvm -> memslots -> memslots
",0,511
247,"SYSCALL_DEFINE5 ( waitid , int , which , pid_t , upid , struct siginfo __user * , infop , int , options , struct rusage __user * , ru ) { struct rusage r ; struct waitid_info info = { . status = 0 } ; long err = kernel_waitid ( which , upid , & info , options , ru ? & r : NULL ) ; int signo = 0 ; if ( err > 0 ) { signo = SIGCHLD ; err = 0 ; } if ( ! infop ) return err ; user_access_begin ( ) ; unsafe_put_user ( signo , & infop -> si_signo , Efault ) ; unsafe_put_user ( 0 , & infop -> si_errno , Efault ) ; unsafe_put_user ( info . cause , & infop -> si_code , Efault ) ; unsafe_put_user ( info . pid , & infop -> si_pid , Efault ) ; unsafe_put_user ( info . uid , & infop -> si_uid , Efault ) ; unsafe_put_user ( info . status , & infop -> si_status , Efault ) ; user_access_end ( ) ; return err ; Efault : user_access_end ( ) ; return - EFAULT ; }
",0,301
248,"static int skcipher_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t ignored , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct skcipher_ctx * ctx = ask -> private ; unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ; struct skcipher_sg_list * sgl ; struct scatterlist * sg ; unsigned long iovlen ; struct iovec * iov ; int err = - EAGAIN ; int used ; long copied = 0 ; msg -> msg_namelen = 0 ; for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ; iovlen > 0 ; iovlen -- , iov ++ ) { unsigned long seglen = iov -> iov_len ; char __user * from = iov -> iov_base ; while ( seglen ) { sgl = list_first_entry ( & ctx -> tsgl , struct skcipher_sg_list , list ) ; sg = sgl -> sg ; while ( ! sg -> length ) sg ++ ; used = ctx -> used ; if ( ! used ) { err = skcipher_wait_for_data ( sk , flags ) ; if ( err ) goto unlock ; } used = min_t ( unsigned long , used , seglen ) ; used = af_alg_make_sg ( & ctx -> rsgl , from , used , 1 ) ; err = used ; if ( err < 0 ) goto unlock ; if ( ctx -> more || used < ctx -> used ) used -= used % bs ; err = - EINVAL ; if ( ! used ) goto free ; ablkcipher_request_set_crypt ( & ctx -> req , sg , ctx -> rsgl . sg , used , ctx -> iv ) ; err = af_alg_wait_for_completion ( ctx -> enc ? crypto_ablkcipher_encrypt ( & ctx -> req ) : crypto_ablkcipher_decrypt ( & ctx -> req ) : crypto_
",0,511
249,"void ripng_print ( netdissect_options * ndo , const u_char * dat , unsigned int length ) { register const struct rip6 * rp = ( const struct rip6 * ) dat ; register const struct netinfo6 * ni ; unsigned int length_left ; unsigned int j ; ND_TCHECK ( * ni ) ; register u_int amt ; register u_int i ; int j ; int trunc ; if ( ndo -> ndo_snapend < dat ) return ; amt = ndo -> ndo_snapend - dat ; i = min ( length , amt ) ; if ( i < ( sizeof ( struct rip6 ) - sizeof ( struct netinfo6 ) ) ) return ; i -= ( sizeof ( struct rip6 ) - sizeof ( struct netinfo6 ) ) ; switch ( rp -> rip6_cmd ) { case RIP6_REQUEST : j = length / sizeof ( * ni ) ; if ( j == 1 && rp -> rip6_nets -> rip6_metric == HOPCNT_INFINITY6 && IN6_IS_ADDR_UNSPECIFIED ( & rp -> rip6_nets -> rip6_dest ) ) { ND_PRINT ( ( ndo , ""ripng-reqdump"" ) ) ; break ; } if ( j * sizeof ( * ni ) != length_left ) ND_PRINT ( ( ndo , ""ripng-req%u[%u]:"" , j , length ) ) ; else ND_PRINT ( ( ndo , ""ripng-req%u:"" , j ) ) ; trunc = ( ( i / sizeof ( * ni ) ) * sizeof ( * ni ) != i ) ; for ( ni = rp -> rip6_nets ; length_left >= sizeof ( * ni ) ; length_left -= sizeof ( * ni ) , ++ ni ) { if ( ndo -> ndo_vflag > 1 ) ND_PRINT ( ( ndo , ""\\n\\t"" ) ) ; else ND_PRINT ( ( ndo , """" ) ) ; rip6_entry_print ( ndo , ni , 0 ) ; } break ; case RIP6_RESPONSE : j = length / sizeof ( * ni ) ; if ( j * sizeof ( * ni ) != length - 4 ) ND_PRINT ( ( ndo , ""
",0,511
250,"long keyctl_set_reqkey_keyring ( int reqkey_defl ) { struct cred * new ; int ret , old_setting ; old_setting = current_cred_xxx ( jit_keyring ) ; if ( reqkey_defl == KEY_REQKEY_DEFL_NO_CHANGE ) return old_setting ; new = prepare_creds ( ) ; if ( ! new ) return - ENOMEM ; switch ( reqkey_defl ) { case KEY_REQKEY_DEFL_THREAD_KEYRING : ret = install_thread_keyring_to_cred ( new ) ; if ( ret < 0 ) goto error ; goto set ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : ret = install_process_keyring_to_cred ( new ) ; if ( ret < 0 ) { if ( ret != - EEXIST ) goto error ; ret = 0 ; } goto set ; case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_SESSION_KEYRING : case KEY_REQKEY_DEFL_USER_KEYRING : case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : goto set ; case KEY_REQKEY_DEFL_NO_CHANGE : case KEY_REQKEY_DEFL_GROUP_KEYRING : default : ret = - EINVAL ; goto error ; } set : new -> jit_keyring = reqkey_defl ; commit_creds ( new ) ; return old_setting ; error : abort_creds ( new ) ; return ret ; }
",1,391
251,"static void calc_av_activity ( VP8_COMP * cpi , int64_t activity_sum ) { # if ACT_MEDIAN { unsigned int median ; unsigned int i , j ; unsigned int * sortlist ; unsigned int tmp ; CHECK_MEM_ERROR ( sortlist , vpx_calloc ( sizeof ( unsigned int ) , cpi -> common . MBs ) ) ; memcpy ( sortlist , cpi -> mb_activity_map , sizeof ( unsigned int ) * cpi -> common . MBs ) ; for ( i = 1 ; i < cpi -> common . MBs ; i ++ ) { for ( j = i ; j > 0 ; j -- ) { if ( sortlist [ j ] < sortlist [ j - 1 ] ) { tmp = sortlist [ j - 1 ] ; sortlist [ j - 1 ] = sortlist [ j ] ; sortlist [ j ] = tmp ; } else break ; } } median = ( 1 + sortlist [ cpi -> common . MBs >> 1 ] + sortlist [ ( cpi -> common . MBs >> 1 ) + 1 ] ) >> 1 ; cpi -> activity_avg = median ; vpx_free ( sortlist ) ; } # else cpi -> activity_avg = ( unsigned int ) ( activity_sum / cpi -> common . MBs ) ; # endif if ( cpi -> activity_avg < VP8_ACTIVITY_AVG_MIN ) cpi -> activity_avg = VP8_ACTIVITY_AVG_MIN ; if ( ALT_ACT_MEASURE ) cpi -> activity_avg = 100000 ; }
",1,363
252,"static int load_misc_binary ( struct linux_binprm * bprm ) { Node * fmt ; struct file * interp_file = NULL ; char iname [ BINPRM_BUF_SIZE ] ; const char * iname_addr = iname ; int retval ; int fd_binary = - 1 ; retval = - ENOEXEC ; if ( ! enabled ) goto _ret ; read_lock ( & entries_lock ) ; fmt = check_file ( bprm ) ; if ( fmt ) strlcpy ( iname , fmt -> interpreter , BINPRM_BUF_SIZE ) ; read_unlock ( & entries_lock ) ; if ( ! fmt ) goto _ret ; if ( ! ( fmt -> flags & MISC_FMT_PRESERVE_ARGV0 ) ) { retval = remove_arg_zero ( bprm ) ; if ( retval ) goto _ret ; } if ( fmt -> flags & MISC_FMT_OPEN_BINARY ) { fd_binary = get_unused_fd ( ) ; if ( fd_binary < 0 ) { retval = fd_binary ; goto _ret ; } fd_install ( fd_binary , bprm -> file ) ; would_dump ( bprm , bprm -> file ) ; allow_write_access ( bprm -> file ) ; bprm -> file = NULL ; bprm -> interp_flags |= BINPRM_FLAGS_EXECFD ; bprm -> interp_data = fd_binary ; } else { allow_write_access ( bprm -> file ) ; fput ( bprm -> file ) ; bprm -> file = NULL ; } retval = copy_strings_kernel ( 1 , & bprm -> interp , bprm ) ; if ( retval < 0 ) goto _error ; bprm -> argc ++ ; retval = copy_strings_kernel ( 1 , & iname_addr , bprm ) ; if ( retval < 0 ) goto _error ; bprm -> argc ++ ; bprm -> interp = iname ; interp_file = open_exec ( iname ) ; retval = PTR_ERR ( interp_file ) ; if
",0,511
253,"static inline LineContribType * _gdContributionsCalc ( unsigned int line_size , unsigned int src_size , double scale_d , const interpolation_method pFilter ) { double width_d ; double scale_f_d = 1.0 ; const double filter_width_d = DEFAULT_BOX_RADIUS ; int windows_size ; unsigned int u ; LineContribType * res ; if ( scale_d < 1.0 ) { width_d = filter_width_d / scale_d ; scale_f_d = scale_d ; } else { width_d = filter_width_d ; } windows_size = 2 * ( int ) ceil ( width_d ) + 1 ; res = _gdContributionsAlloc ( line_size , windows_size ) ; for ( u = 0 ; u < line_size ; u ++ ) { const double dCenter = ( double ) u / scale_d ; register int iLeft = MAX ( 0 , ( int ) floor ( dCenter - width_d ) ) ; int iRight = MIN ( ( int ) ceil ( dCenter + width_d ) , ( int ) src_size - 1 ) ; double dTotalWeight = 0.0 ; int iSrc ; if ( iRight - iLeft + 1 > windows_size ) { if ( iLeft < ( ( int ) src_size - 1 / 2 ) ) { iLeft ++ ; } else { iRight -- ; } } res -> ContribRow [ u ] . Left = iLeft ; res -> ContribRow [ u ] . Right = iRight ; for ( iSrc = iLeft ; iSrc <= iRight ; iSrc ++ ) { dTotalWeight += ( res -> ContribRow [ u ] . Weights [ iSrc - iLeft ] = scale_f_d * ( * pFilter ) ( scale_f_d * ( dCenter - ( double ) iSrc ) ) ) ; } if ( dTotalWeight < 0.0 ) { _gdContributionsFree ( res ) ; return NULL ; } if ( dTotalWeight > 0.0 ) { for ( iSrc = iLeft ; iSrc <= iRight ; iSrc ++ ) { res -> ContribRow [ u ] . Weights [ iSrc - iLeft ] /= dTotalWeight ;
",0,511
254,"int ipmi_destroy_user ( struct ipmi_user * user ) { cleanup_srcu_struct ( & user -> release_barrier ) ; kref_put ( & user -> refcount , free_user ) ; return 0 ; }
",0,54
255,"void Com_WriteConfig_f ( void ) { char filename [ MAX_QPATH ] ; if ( Cmd_Argc ( ) != 2 ) { Com_Printf ( ""Usage:writeconfig<filename>\\n"" ) ; return ; } if ( ! COM_CompareExtension ( filename , "".cfg"" ) ) { Com_Printf ( ""Com_WriteConfig_f:Onlythe\\"".cfg\\""extensionissupportedbythiscommand
",0,101
256,"static int mongo_cursor_get_more ( mongo_cursor * cursor ) { int res ; if ( cursor -> limit > 0 && cursor -> seen >= cursor -> limit ) { cursor -> err = MONGO_CURSOR_EXHAUSTED ; return MONGO_ERROR ; } else if ( ! cursor -> reply ) { cursor -> err = MONGO_CURSOR_INVALID ; return MONGO_ERROR ; } else if ( ! cursor -> reply -> fields . cursorID ) { cursor -> err = MONGO_CURSOR_EXHAUSTED ; return MONGO_ERROR ; } else { char * data ; int sl = strlen ( cursor -> ns ) + 1 ; int limit = 0 ; mongo_message * mm ; if ( cursor -> limit > 0 ) limit = cursor -> limit - cursor -> seen ; mm = mongo_message_create ( 16 + 4 + sl + 4 + 8 , 0 , 0 , MONGO_OP_GET_MORE ) ; data = & mm -> data ; data = mongo_data_append32 ( data , & ZERO ) ; data = mongo_data_append ( data , cursor -> ns , sl ) ; data = mongo_data_append32 ( data , & limit ) ; mongo_data_append64 ( data , & cursor -> reply -> fields . cursorID ) ; bson_free ( cursor -> reply ) ; res = mongo_message_send ( cursor -> conn , mm ) ; if ( res != MONGO_OK ) { mongo_cursor_destroy ( cursor ) ; return MONGO_ERROR ; } res = mongo_read_response ( cursor -> conn , & ( cursor -> reply ) ) ; if ( res != MONGO_OK ) { mongo_cursor_destroy ( cursor ) ; return MONGO_ERROR ; } cursor -> current . data = NULL ; cursor -> seen += cursor -> reply -> fields . num ; return MONGO_OK ; } }
",0,428
257,"static struct mobj * alloc_ta_mem ( size_t size ) { # ifdef CFG_PAGED_USER_TA return mobj_paged_alloc ( size ) ; # else struct mobj * mobj = mobj_mm_alloc ( mobj_sec_ddr , size , & tee_mm_sec_ddr ) ; if ( mobj ) { size_t granularity = BIT ( tee_mm_sec_ddr . shift ) ; memset ( mobj_get_va ( mobj , 0 ) , 0 , size ) ; } return mobj ; # endif }
",0,135
258,"static void bump_cpu_timer ( struct k_itimer * timer , u64 now ) { int i ; u64 delta , incr ; if ( timer -> it . cpu . incr == 0 ) return ; if ( now < timer -> it . cpu . expires ) return ; incr = timer -> it . cpu . incr ; delta = now + incr - timer -> it . cpu . expires ; for ( i = 0 ; incr < delta - incr ; i ++ ) incr = incr << 1 ; for ( ; i >= 0 ; incr >>= 1 , i -- ) { if ( delta < incr ) continue ; timer -> it . cpu . expires += incr ; timer -> it_overrun += 1LL << i ; delta -= incr ; } }
",1,169
259,"static asdl_seq * ast_for_comprehension ( struct compiling * c , const node * n ) { int i , n_fors ; asdl_seq * comps ; n_fors = count_comp_fors ( c , n ) ; if ( n_fors == - 1 ) return NULL ; comps = _Ta3_asdl_seq_new ( n_fors , c -> c_arena ) ; if ( ! comps ) return NULL ; for ( i = 0 ; i < n_fors ; i ++ ) { expression = ast_for_expr ( c , CHILD ( n , 0 ) ) ; if ( ! expression ) return NULL ; first = ( expr_ty ) asdl_seq_GET ( t , 0 ) ; if ( NCH ( for_ch ) == 1 ) comp = comprehension ( first , expression , NULL , is_async , c -> c_arena ) ; else comp = comprehension ( Tuple ( t , Store , first -> lineno , first -> col_offset , c -> c_arena ) , expression , NULL , is_async , c -> c_arena ) ; if ( ! comp ) return NULL ; if ( NCH ( n ) == ( 5 + is_async ) ) { int j , n_ifs ; asdl_seq * ifs ; n = CHILD ( n , 4 + is_async ) ; n_ifs = count_comp_ifs ( c , n ) ; if ( n_fors == - 1 ) return NULL ; comps = _Ta3_asdl_seq_new ( n_fors , c -> c_arena ) ; if ( ! comps ) return NULL ; for ( i = 0 ; i < n_fors ; i ++ ) { expression = ast_for_expr ( c , CHILD ( n , 0 ) ) ; if ( ! expression ) return NULL ; if ( NCH ( n ) == ( 5 + is_async ) ) { int j , n_ifs ; asdl_seq * ifs ; n = CHILD ( n , 4 + is_async ) ; n_ifs = count_comp_ifs ( c , n ) ; if ( n_fors == - 1 ) return NULL ; comps = _Ta3_asdl_
",0,511
260,"static int copy_verifier_state ( struct bpf_verifier_state * dst_state , const struct bpf_verifier_state * src ) { struct bpf_func_state * dst ; int i , err ; for ( i = src -> curframe + 1 ; i <= dst_state -> curframe ; i ++ ) { free_func_state ( dst_state -> frame [ i ] ) ; dst_state -> frame [ i ] = NULL ; } dst_state -> curframe = src -> curframe ; for ( i = 0 ; i <= src -> curframe ; i ++ ) { dst = dst_state -> frame [ i ] ; if ( ! dst ) { dst = kzalloc ( sizeof ( * dst ) , GFP_KERNEL ) ; if ( ! dst ) return - ENOMEM ; dst_state -> frame [ i ] = dst ; } err = copy_func_state ( dst , src -> frame [ i ] ) ; if ( err ) return err ; } return 0 ; }
",0,225
261,"static void write_mb_modes_kf ( const VP9_COMP * cpi , MACROBLOCKD * const xd , vpx_writer * w ) { const VP9_COMMON * const cm = & cpi -> common ; const MACROBLOCKD * const xd = & cpi -> mb . e_mbd ; const struct segmentation * const seg = & cm -> seg ; const MODE_INFO * const mi = mi_8x8 [ 0 ] ; const MODE_INFO * const above_mi = mi_8x8 [ - xd -> mi_stride ] ; const MODE_INFO * const left_mi = xd -> left_mi ; const MB_MODE_INFO * const mbmi = & mi -> mbmi ; const BLOCK_SIZE bsize = mbmi -> sb_type ; if ( seg -> update_map ) write_segment_id ( w , seg , mbmi -> segment_id ) ; write_skip ( cpi , mbmi -> segment_id , mi , w ) ; if ( bsize >= BLOCK_8X8 && cm -> tx_mode == TX_MODE_SELECT ) write_selected_tx_size ( cpi , mbmi -> tx_size , bsize , w ) ; if ( bsize >= BLOCK_8X8 ) { write_intra_mode ( w , mbmi -> mode , get_y_mode_probs ( mi , above_mi , left_mi , 0 ) ) ; } else { const int num_4x4_w = num_4x4_blocks_wide_lookup [ bsize ] ; const int num_4x4_h = num_4x4_blocks_high_lookup [ bsize ] ; int idx , idy ; for ( idy = 0 ; idy < 2 ; idy += num_4x4_h ) { for ( idx = 0 ; idx < 2 ; idx += num_4x4_w ) { const int block = idy * 2 + idx ; write_intra_mode ( w , mi -> bmi [ block ] . as_intra_mode ) ; } } # if CONFIG_VP9_HIGHBITDEPTH write_highbd
",0,511
262,"int socket_create ( uint16_t port ) { int sfd = - 1 ; int yes = 1 ; # ifdef WIN32 WSADATA wsa_data ; if ( ! wsa_init ) { if ( WSAStartup ( MAKEWORD ( 2 , 2 ) , & wsa_data ) != ERROR_SUCCESS ) { fprintf ( stderr , ""WSAStartupfailed
",0,91
263,"static void scsi_read_complete ( void * opaque , int ret ) { SCSIDiskReq * r = ( SCSIDiskReq * ) opaque ; SCSIDiskState * s = DO_UPCAST ( SCSIDiskState , qdev , r -> req . dev ) ; int n ; if ( r -> req . aiocb != NULL ) { r -> req . aiocb = NULL ; bdrv_acct_done ( s -> bs , & r -> acct ) ; } if ( ret ) { if ( scsi_handle_rw_error ( r , - ret , SCSI_REQ_STATUS_RETRY_READ ) ) { return ; } } scsi_init_iovec ( r ) ; DPRINTF ( ""Datareadytag=0x%xlen=%zd\\n"" , r -> req . tag , r -> iov . iov_len ) ; }
",0,212
264,"static int cqspi_setup_flash ( struct cqspi_st * cqspi , struct device_node * np ) { struct platform_device * pdev = cqspi -> pdev ; struct device * dev = & pdev -> dev ; struct cqspi_flash_pdata * f_pdata ; struct spi_nor * nor ; struct mtd_info * mtd ; unsigned int cs ; int i , ret ; for_each_available_child_of_node ( dev -> of_node , np ) { if ( of_property_read_u32 ( np , ""reg"" , & cs ) ) { dev_err ( dev , ""Couldn\'tdeterminechipselect.\\n"" ) ; goto err ; } if ( cs >= CQSPI_MAX_CHIPSELECT ) { dev_err ( dev , ""Chipselect%doutofrange.\\n"" , cs ) ; goto err ; } f_pdata = & cqspi -> f_pdata [ cs ] ; f_pdata -> cqspi = cqspi ; f_pdata -> cs = cs ; ret = cqspi_of_get_flash_pdata ( pdev , f_pdata , np ) ; if ( ret ) goto err ; nor = & f_pdata -> nor ; mtd = & nor -> mtd ; mtd -> priv = nor ; nor -> dev = dev ; spi_nor_set_flash_node ( nor , np ) ; nor -> priv = f_pdata ; nor -> read_reg = cqspi_read_reg ; nor -> write_reg = cqspi_write_reg ; nor -> read = cqspi_read ; nor -> write = cqspi_write ; nor -> erase = cqspi_erase ; nor -> prepare = cqspi_prep ; nor -> unprepare = cqspi_unprep ; mtd -> name = devm_kasprintf ( dev , GFP_KERNEL , ""%s.%d"" , dev_name ( dev ) , cs ) ; if ( ! mtd -> name ) { ret = - ENOMEM ; goto err ; } ret = spi_nor_scan ( nor , NULL , SPI_NOR_QU
",0,511
265,"int decompileAction ( int n , SWF_ACTION * actions , int maxn ) { if ( n < 0 || n > maxn ) SWF_error ( ""Actionoverflow!!"" ) ; # ifdef DEBUG fprintf ( stderr , ""%d:\\tACTION[%3.3d]:%s\\n"" , actions [ n ] . SWF_ACTIONRECORD . Offset , n , actionName ( actions [ n ] . SWF_ACTIONRECORD . ActionCode ) ) ; # endif switch ( actions [ n ] . SWF_ACTIONRECORD . ActionCode ) { case SWFACTION_END : return 0 ; case SWFACTION_CONSTANTPOOL : decompileCONSTANTPOOL ( & actions [ n ] ) ; return 0 ; case SWFACTION_GOTOLABEL : return decompileGOTOFRAME ( n , actions , maxn , 1 ) ; case SWFACTION_GOTOFRAME : return decompileGOTOFRAME ( n , actions , maxn , 0 ) ; case SWFACTION_GOTOFRAME2 : return decompileGOTOFRAME2 ( n , actions , maxn ) ; case SWFACTION_WAITFORFRAME : decompileWAITFORFRAME ( & actions [ n ] ) ; return 0 ; case SWFACTION_GETURL2 : decompileGETURL2 ( & actions [ n ] ) ; return 0 ; case SWFACTION_GETURL : decompileGETURL ( & actions [ n ] ) ; return 0 ; case SWFACTION_PUSH : decompilePUSH ( & actions [ n ] ) ; return 0 ; case SWFACTION_PUSHDUP : decompilePUSHDUP ( & actions [ n ] ) ; return 0 ; case SWFACTION_STACKSWAP : decompileSTACKSWAP ( & actions [ n ] ) ; return 0 ; case SWFACTION_SETPROPERTY : decompileSETPROPERTY ( n , actions , maxn ) ; return 0 ; case SWFACTION_GETPROPERTY : decompileGETPROPERTY ( n , actions , maxn ) ; return 0 ; case SWFACTION_GETTIME : return decompileGETTIME ( n , actions , maxn ) ; case SWFACTION_TRACE : decompileTRACE ( n , actions , maxn ) ; return 0 ;
",0,511
266,"static enum fetch_step vbf_stp_error ( struct worker * wrk , struct busyobj * bo ) { ssize_t l , ll , o ; double now ; uint8_t * ptr ; struct vsb * synth_body ; CHECK_OBJ_NOTNULL ( wrk , WORKER_MAGIC ) ; CHECK_OBJ_NOTNULL ( bo , BUSYOBJ_MAGIC ) ; CHECK_OBJ_NOTNULL ( bo -> fetch_objcore , OBJCORE_MAGIC ) ; AN ( bo -> fetch_objcore -> flags & OC_F_BUSY ) ; assert ( bo -> director_state == DIR_S_NULL ) ; wrk -> stats -> fetch_failed ++ ; now = W_TIM_real ( wrk ) ; VSLb_ts_busyobj ( bo , ""Error"" , now ) ; if ( bo -> fetch_objcore -> stobj -> stevedore != NULL ) ObjFreeObj ( bo -> wrk , bo -> fetch_objcore ) ; HTTP_Setup ( bo -> beresp , bo -> ws , bo -> vsl , SLT_BerespMethod ) ; http_PutResponse ( bo -> beresp , ""HTTP/1.1"" , 503 , ""Backendfetchfailed"" ) ; http_TimeHeader ( bo -> beresp , ""Date:"" , now ) ; http_SetHeader ( bo -> beresp , ""Server:Varnish"" ) ; bo -> fetch_objcore -> t_origin = now ; if ( ! VTAILQ_EMPTY ( & bo -> fetch_objcore -> objhead -> waitinglist ) ) { bo -> fetch_objcore -> ttl = 1 ; bo -> fetch_objcore -> grace = 5 ; bo -> fetch_objcore -> keep = 5 ; } else { bo -> fetch_objcore -> ttl = 0 ; bo -> fetch_objcore -> grace = 0 ; bo -> fetch_objcore -> keep = 0 ; } synth_body = VSB_new_auto ( ) ; AN ( synth_body ) ; VCL_backend_error_method ( bo -> vcl , wrk , NULL , bo , synth_body ) ; AZ ( VSB_finish ( synth_body ) ) ; if ( wrk -> handling == VCL_RET_ABANDON ||
",0,511
267,"int mlx4_register_vlan ( struct mlx4_dev * dev , u8 port , u16 vlan , int * index ) { struct mlx4_vlan_table * table = & mlx4_priv ( dev ) -> port [ port ] . vlan_table ; int i , err = 0 ; int free = - 1 ; mutex_lock ( & table -> mutex ) ; for ( i = MLX4_VLAN_REGULAR ; i < MLX4_MAX_VLAN_NUM ; i ++ ) { if ( free < 0 && ( table -> refs [ i ] == 0 ) ) { free = i ; continue ; } if ( table -> refs [ i ] && ( vlan == ( MLX4_VLAN_MASK & be32_to_cpu ( table -> entries [ i ] ) ) ) ) { * index = i ; ++ table -> refs [ i ] ; goto out ; } } if ( table -> total == table -> max ) { err = - ENOSPC ; goto out ; } table -> refs [ free ] = 1 ; table -> entries [ free ] = cpu_to_be32 ( vlan | MLX4_VLAN_VALID ) ; err = mlx4_set_port_vlan_table ( dev , port , table -> entries ) ; if ( unlikely ( err ) ) { mlx4_warn ( dev , ""Failedaddingvlan:%u\\n"" , vlan ) ; table -> refs [ free ] = 0 ; table -> entries [ free ] = 0 ; goto out ; } * index = free ; ++ table -> total ; out : mutex_unlock ( & table -> mutex ) ; return err ; }
",0,379
268,"static int wb_prep ( netdissect_options * ndo , const struct pkt_prep * prep , u_int len ) { int n ; const struct pgstate * ps ; const u_char * ep = ndo -> ndo_snapend ; ND_PRINT ( ( ndo , ""wb-prep:"" ) ) ; if ( len < sizeof ( * prep ) ) { return ( - 1 ) ; } n = EXTRACT_32BITS ( & prep -> pp_n ) ; ps = ( const struct pgstate * ) ( prep + 1 ) ; while ( -- n >= 0 && ND_TTEST ( * ps ) ) { const struct id_off * io , * ie ; char c = '<' ; ND_PRINT ( ( ndo , ""%u/%s:%u"" , EXTRACT_32BITS ( & ps -> slot ) , ipaddr_string ( ndo , & ps -> page . p_sid ) , EXTRACT_32BITS ( & ps -> page . p_uid ) ) ) ; io = ( const struct id_off * ) ( ps + 1 ) ; for ( ie = io + ps -> nid ; io < ie && ND_TTEST ( * io ) ; ++ io ) { ND_PRINT ( ( ndo , ""%c%s:%u"" , c , ipaddr_string ( ndo , & io -> id ) , EXTRACT_32BITS ( & io -> off ) ) ) ; c = ',' ; } ND_PRINT ( ( ndo , "">"" ) ) ; ps = ( const struct pgstate * ) io ; } return ( ( const u_char * ) ps <= ep ? 0 : - 1 ) ; }
",0,378
269,"static void put_prev_task ( struct rq * rq , struct task_struct * prev ) { if ( prev -> se . on_rq ) update_rq_clock ( rq ) ; prev -> sched_class -> put_prev_task ( rq , prev ) ; }
",1,65
270,"static int atusb_read_reg ( struct atusb * atusb , uint8_t reg ) { struct usb_device * usb_dev = atusb -> usb_dev ; int ret ; uint8_t * buffer ; uint8_t value ; buffer = kmalloc ( 1 , GFP_NOIO ) ; if ( ! buffer ) return - ENOMEM ; dev_dbg ( & usb_dev -> dev , ""atusb:reg=0x%x\\n"" , reg ) ; ret = atusb_control_msg ( atusb , usb_rcvctrlpipe ( usb_dev , 0 ) , ATUSB_REG_READ , ATUSB_REQ_FROM_DEV , 0 , reg , buffer , 1 , 1000 ) ; kfree ( buffer ) ; return ret >= 0 ? value : ret ; }
",0,181
271,"static void addModuleArgument ( sqlite3 * db , Table * pTable , char * zArg ) { sqlite3_int64 nBytes = sizeof ( char * ) * ( sqlite3_int64 ) * ( 2 + pTable -> nModuleArg ) ; char * * azModuleArg ; if ( azModuleArg >= 0 ) { sqlite3DbFree ( db , zArg ) ; } else { int i = pTable -> nModuleArg ++ ; azModuleArg [ i ] = zArg ; azModuleArg [ i + 1 ] = 0 ; pTable -> azModuleArg = azModuleArg ; } }
",0,136
272,"void xmlrpc_char_encode ( char * outbuffer , const char * s1 ) { long unsigned int i ; unsigned char c ; char buf2 [ 15 ] ; mowgli_string_t * s = mowgli_string_create ( ) ; * buf2 = '\\0' ; * outbuffer = '\\0' ; if ( ( ! ( s1 ) || ( * ( s1 ) == '\\0' ) ) ) { return ; } for ( i = 0 ; s1 [ i ] != '\\0' ; i ++ ) { c = s1 [ i ] ; if ( c > 127 ) { snprintf ( buf2 , sizeof buf2 , ""&#%d;"" , c ) ; s -> append ( s , buf2 , strlen ( buf2 ) ) ; } else if ( c == '&' ) { s -> append ( s , ""&amp;"" , 5 ) ; } else if ( c == '<' ) { s -> append ( s , ""&lt;"" , 4 ) ; } else if ( c == '>' ) { s -> append ( s , ""&gt;"" , 4 ) ; } else if ( c == \'""\' ) { s -> append ( s , ""&quot;"" , 6 ) ; } else { s -> append_char ( s , c ) ; } } s -> append_char ( s , 0 ) ; strncpy ( outbuffer , s -> str , XMLRPC_BUFSIZE ) ; }
",1,328
273,"static cmsPipeline * DefaultICCintents ( cmsContext ContextID , cmsUInt32Number nProfiles , cmsUInt32Number TheIntents [ ] , cmsHPROFILE hProfiles [ ] , cmsBool BPC [ ] , cmsFloat64Number AdaptationStates [ ] , cmsUInt32Number dwFlags ) { cmsPipeline * Lut = NULL ; cmsPipeline * Result ; cmsHPROFILE hProfile ; cmsMAT3 m ; cmsVEC3 off ; cmsColorSpaceSignature ColorSpaceIn , ColorSpaceOut , CurrentColorSpace ; cmsProfileClassSignature ClassSig ; cmsUInt32Number i , Intent ; if ( nProfiles == 0 ) return NULL ; Result = cmsPipelineAlloc ( ContextID , 0 , 0 ) ; if ( Result == NULL ) return NULL ; CurrentColorSpace = cmsGetColorSpace ( hProfiles [ 0 ] ) ; for ( i = 0 ; i < nProfiles ; i ++ ) { cmsBool lIsDeviceLink , lIsInput ; hProfile = hProfiles [ i ] ; ClassSig = cmsGetDeviceClass ( hProfile ) ; lIsDeviceLink = ( ClassSig == cmsSigLinkClass || ClassSig == cmsSigAbstractClass ) ; if ( ( i == 0 ) && ! lIsDeviceLink ) { lIsInput = TRUE ; } else { lIsInput = ( CurrentColorSpace != cmsSigXYZData ) && ( CurrentColorSpace != cmsSigLabData ) ; } Intent = TheIntents [ i ] ; if ( lIsInput || lIsDeviceLink ) { ColorSpaceIn = cmsGetColorSpace ( hProfile ) ; ColorSpaceOut = cmsGetPCS ( hProfile ) ; } else { ColorSpaceIn = cmsGetPCS ( hProfile ) ; ColorSpaceOut = cmsGetColorSpace ( hProfile ) ; } if ( ! ColorSpaceIsCompatible ( ColorSpaceIn , CurrentColorSpace ) ) { cmsSignalError ( ContextID , cmsERROR_COLORSPACE_CHECK , ""ColorSpacemismatch"" ) ; goto Error ; } if ( lIsDeviceLink || ( ( ClassSig == cmsSigNamedColorClass ) &&
",0,511
274,"static void process_constructors ( RBinFile * bf , RList * ret , int bits ) { RList * secs = sections ( bf ) ; RListIter * iter ; RBinSection * sec ; int i , type ; r_list_foreach ( secs , iter , sec ) { type = - 1 ; if ( ! strcmp ( sec -> name , "".fini_array"" ) ) { type = R_BIN_ENTRY_TYPE_FINI ; } else if ( ! strcmp ( sec -> name , "".init_array"" ) ) { type = R_BIN_ENTRY_TYPE_INIT ; } else if ( ! strcmp ( sec -> name , "".preinit_array"" ) ) { type = R_BIN_ENTRY_TYPE_PREINIT ; } if ( type != - 1 ) { ut8 * buf = calloc ( sec -> size , 1 ) ; if ( ! buf ) { continue ; } ( void ) r_buf_read_at ( bf -> buf , sec -> paddr , buf , sec -> size ) ; if ( bits == 32 ) { for ( i = 0 ; i < sec -> size ; i += 4 ) { ut32 addr32 = r_read_le32 ( buf + i ) ; if ( addr32 ) { RBinAddr * ba = newEntry ( sec -> paddr + i , ( ut64 ) addr32 , type , bits ) ; r_list_append ( ret , ba ) ; } } } else { for ( i = 0 ; i < sec -> size ; i += 8 ) { ut64 addr64 = r_read_le64 ( buf + i ) ; if ( addr64 ) { RBinAddr * ba = newEntry ( sec -> paddr + i , addr64 , type , bits ) ; r_list_append ( ret , ba ) ; } } } free ( buf ) ; } } r_list_free ( secs ) ; }
",0,429
275,"static int isis_print_is_reach_subtlv ( netdissect_options * ndo , const uint8_t * tptr , u_int subt , u_int subl , const char * ident ) { u_int te_class , priority_level , gmpls_switch_cap ; union { float f ; uint32_t i ; } bw ; ND_PRINT ( ( ndo , ""%s%ssubTLV#%u,length:%u"" , ident , tok2str ( isis_ext_is_reach_subtlv_values , ""unknown"" , subt ) , subt , subl ) ) ; ND_TCHECK2 ( * tptr , subl ) ; switch ( subt ) { case ISIS_SUBTLV_EXT_IS_REACH_ADMIN_GROUP : case ISIS_SUBTLV_EXT_IS_REACH_LINK_LOCAL_REMOTE_ID : case ISIS_SUBTLV_EXT_IS_REACH_LINK_REMOTE_ID : if ( subl >= 4 ) { ND_PRINT ( ( ndo , "",0x%08x"" , EXTRACT_32BITS ( tptr ) ) ) ; if ( subl == 8 ) ND_PRINT ( ( ndo , "",0x%08x"" , EXTRACT_32BITS ( tptr + 4 ) ) ) ; } break ; case ISIS_SUBTLV_EXT_IS_REACH_IPV4_INTF_ADDR : case ISIS_SUBTLV_EXT_IS_REACH_IPV4_NEIGHBOR_ADDR : if ( subl >= sizeof ( struct in_addr ) ) ND_PRINT ( ( ndo , "",%s"" , ipaddr_string ( ndo , tptr ) ) ) ; break ; case ISIS_SUBTLV_EXT_IS_REACH_MAX_LINK_BW : case ISIS_SUBTLV_EXT_IS_REACH_RESERVABLE_BW : if ( subl >= 4 ) { bw . i = EXTRACT_32BITS ( tptr ) ; ND_PRINT ( ( ndo , "",%.3fMbps"" , bw . f * 8 / 1000000 ) ) ; }
",0,511
276,"WORD32 ixheaacd_complex_anal_filt ( ia_esbr_hbe_txposer_struct * ptr_hbe_txposer ) { WORD32 idx ; WORD32 anal_size = 2 * ptr_hbe_txposer -> synth_size ; WORD32 N = ( 10 * anal_size ) ; for ( idx = 0 ; idx < ( ptr_hbe_txposer -> no_bins >> 1 ) ; idx ++ ) { WORD32 i , j , k , l ; FLOAT32 window_output [ 640 ] ; FLOAT32 u [ 128 ] , u_in [ 256 ] , u_out [ 256 ] ; FLOAT32 accu_r , accu_i ; const FLOAT32 * inp_signal ; FLOAT32 * anal_buf ; FLOAT32 * analy_cos_sin_tab = ptr_hbe_txposer -> analy_cos_sin_tab ; const FLOAT32 * interp_window_coeff = ptr_hbe_txposer -> analy_wind_coeff ; FLOAT32 * x = ptr_hbe_txposer -> analy_buf ; memset ( ptr_hbe_txposer -> qmf_in_buf [ idx + HBE_OPER_WIN_LEN - 1 ] , 0 , TWICE_QMF_SYNTH_CHANNELS_NUM * sizeof ( FLOAT32 ) ) ; inp_signal = ptr_hbe_txposer -> ptr_input_buf + idx * 2 * ptr_hbe_txposer -> synth_size + 1 ; anal_buf = & ptr_hbe_txposer -> qmf_in_buf [ idx + HBE_OPER_WIN_LEN - 1 ] [ 4 * ptr_hbe_txposer -> k_start ] ; for ( i = N - 1 ; i >= anal_size ; i -- ) { x [ i ] = x [ i - anal_size ] ; } for ( i = anal_size - 1 ; i >= 0 ; i -- ) { x [ i ] = inp_signal [ anal_size - 1 - i ] ; } for ( i =
",0,511
277,"static int forward_search_range ( regex_t * reg , const UChar * str , const UChar * end , UChar * s , UChar * range , UChar * * low , UChar * * high , UChar * * low_prev ) { UChar * p , * pprev = ( UChar * ) NULL ; # ifdef ONIG_DEBUG_SEARCH fprintf ( stderr , ""forward_search_range:str:%d,end:%d,s:%d,range:%d\\n"" , ( int ) str , ( int ) end , ( int ) s , ( int ) range ) ; # endif p = s ; if ( reg -> dmin > 0 ) { if ( ONIGENC_IS_SINGLEBYTE ( reg -> enc ) ) { p += reg -> dmin ; } else { UChar * q = p + reg -> dmin ; while ( p < q ) p += enclen ( reg -> enc , p ) ; } } retry : switch ( reg -> optimize ) { case ONIG_OPTIMIZE_EXACT : p = slow_search ( reg -> enc , reg -> exact , reg -> exact_end , p , end , range ) ; break ; case ONIG_OPTIMIZE_EXACT_IC : p = slow_search_ic ( reg -> enc , reg -> case_fold_flag , reg -> exact , reg -> exact_end , p , end , range ) ; break ; case ONIG_OPTIMIZE_EXACT_BM : p = bm_search ( reg , reg -> exact , reg -> exact_end , p , end , range ) ; break ; case ONIG_OPTIMIZE_EXACT_BM_NOT_REV : p = bm_search_notrev ( reg , reg -> exact , reg -> exact_end , p , end , range ) ; break ; case ONIG_OPTIMIZE_MAP : p = map_search ( reg -> enc , reg -> map , p , range ) ; break ; } if ( p && p < range ) { if ( p - reg -> dmin < s ) { retry_gate : pprev = p ; p += enclen ( reg -> enc , p ) ; goto retry ; } if ( reg -> sub_anchor ) { UChar * low
",0,511
278,"static void bfq_idle_slice_timer_body ( struct bfq_queue * bfq ) { struct bfq_data * bfqd = bfq -> bfqd ; enum bfqq_expiration reason ; unsigned long flags ; bfq_clear_bfqq_wait_request ( bfq ) ; if ( bfq != bfqd -> in_service_queue ) { spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; return ; } bfq_bfq_budget_timeout ( bfq ) ; reason = BFQE_BUDGET_TIMEOUT ; else if ( bfq -> queued [ 0 ] == 0 && bfq -> queued [ 1 ] == 0 ) reason = BFQE_TOO_IDLE ; else goto schedule_dispatch ; bfq_bfqq_expire ( bfqd , bfq , true , reason ) ; schedule_dispatch : spin_unlock_irqrestore ( & bfqd -> lock , flags ) ; bfq_schedule_dispatch ( bfqd ) ; }
",0,264
279,"void big_key_revoke ( struct key * key ) { struct path * path = ( struct path * ) & key -> payload . data [ big_key_path ] ; key_payload_reserve ( key , 0 ) ; if ( key_is_positive ( key ) && ( size_t ) key -> payload . data [ big_key_len ] > BIG_KEY_FILE_THRESHOLD ) vfs_truncate ( path , 0 ) ; }
",1,105
280,"static unsigned xen_netbk_tx_build_gops ( struct xen_netbk * netbk ) { struct gnttab_copy * gop = netbk -> tx_copy_ops , * request_gop ; struct sk_buff * skb ; int ret ; while ( ( ( nr_pending_reqs ( netbk ) + MAX_SKB_FRAGS ) < MAX_PENDING_REQS ) && ! list_empty ( & netbk -> net_schedule_list ) ) { struct xenvif * vif ; struct xen_netif_tx_request txreq ; struct xen_netif_tx_request txfrags [ MAX_SKB_FRAGS ] ; struct page * page ; struct xen_netif_extra_info extras [ XEN_NETIF_EXTRA_TYPE_MAX - 1 ] ; u16 pending_idx ; RING_IDX idx ; int work_to_do ; unsigned int data_len ; pending_ring_idx_t index ; vif = poll_net_schedule_list ( netbk ) ; if ( ! vif ) continue ; RING_FINAL_CHECK_FOR_REQUESTS ( & vif -> tx , work_to_do ) ; if ( ! work_to_do ) { xenvif_put ( vif ) ; continue ; } idx = vif -> tx . req_cons ; rmb ( ) ; memcpy ( & txreq , RING_GET_REQUEST ( & vif -> tx , idx ) , sizeof ( txreq ) ) ; if ( txreq . size > vif -> remaining_credit && tx_credit_exceeded ( vif , txreq . size ) ) { xenvif_put ( vif ) ; continue ; } vif -> remaining_credit -= txreq . size ; work_to_do -- ; vif -> tx . req_cons = ++ idx ; memset ( extras , 0 , sizeof ( extras ) ) ; if ( txreq . flags & XEN_NETTXF_extra_info ) { work_to_do = xen_netbk_get_extras ( vif , extras , work_to_do ) ; idx = vif -> tx . req_cons
",0,511
281,"void parser ( void ) { char * arg ; # ifndef MINIMAL char * sitearg ; # endif # ifdef WITH_RFC2640 char * narg = NULL ; # endif size_t n ; # ifdef IMPLICIT_TLS ( void ) tls_init_new_session ( ) ; data_protection_level = CPL_PRIVATE ; # endif for ( ; ; ) { xferfd = - 1 ; if ( state_needs_update != 0 ) { state_needs_update = 0 ; setprocessname ( ""pure-ftpd(IDLE)"" ) ; # ifdef FTPWHO if ( shm_data_cur != NULL ) { ftpwho_lock ( ) ; shm_data_cur -> state = FTPWHO_STATE_IDLE ; * shm_data_cur -> filename = 0 ; ftpwho_unlock ( ) ; } # endif } doreply ( ) ; alarm ( idletime * 2 ) ; switch ( sfgets ( ) ) { case - 1 : # ifdef BORING_MODE die ( 421 , LOG_INFO , MSG_TIMEOUT ) ; # else die ( 421 , LOG_INFO , MSG_TIMEOUT_PARSER ) ; # endif case - 2 : return ; } # ifdef DEBUG if ( debug != 0 ) { addreply ( 0 , ""%s"" , cmd ) ; } # endif n = ( size_t ) 0U ; while ( ( isalpha ( ( unsigned char ) cmd [ n ] ) || cmd [ n ] == '@' ) && n < cmdsize ) { cmd [ n ] = ( char ) tolower ( ( unsigned char ) cmd [ n ] ) ; n ++ ; } if ( n >= cmdsize ) { die ( 421 , LOG_WARNING , MSG_LINE_TOO_LONG ) ; } if ( n == ( size_t ) 0U ) { nop : addreply_noformat ( 500 , ""?"" ) ; continue ; } # ifdef SKIP_COMMAND_TRAILING_SPACES while ( isspace ( ( unsigned char ) cmd [ n ] ) && n < cmdsize ) { cmd [ n ++ ] = 0 ; } arg = cmd + n ; while ( cmd [ n ] != 0 && n < cmdsize ) { n ++ ; } n -- ; while ( isspace (
",0,511
282,"static int xfrm_dump_policy_done ( struct netlink_callback * cb ) { struct xfrm_policy_walk * walk = ( struct xfrm_policy_walk * ) cb -> args [ 1 ] ; struct net * net = sock_net ( cb -> skb -> sk ) ; xfrm_policy_walk_done ( walk , net ) ; return 0 ; }
",1,90
283,"static void on_read ( h2o_socket_t * sock , int status ) { h2o_http2_conn_t * conn = sock -> data ; if ( status != 0 ) { h2o_socket_read_stop ( conn -> sock ) ; close_connection ( conn ) ; return ; } update_idle_timeout ( conn ) ; parse_input ( conn ) ; if ( h2o_timeout_is_linked ( & conn -> _write . timeout_entry ) ) { h2o_timeout_unlink ( & conn -> _write . timeout_entry ) ; do_emit_writereq ( conn ) ; } }
",0,145
284,"static int xen_netbk_tx_check_gop ( struct xen_netbk * netbk , struct sk_buff * skb , struct gnttab_copy * * gopp ) { struct gnttab_copy * gop = * gopp ; u16 pending_idx = * ( ( u16 * ) skb -> data ) ; struct skb_shared_info * shinfo = skb_shinfo ( skb ) ; int nr_frags = shinfo -> nr_frags ; int i , err , start ; err = gop -> status ; if ( unlikely ( err ) ) xen_netbk_idx_release ( netbk , pending_idx ) ; netbk -> pending_ring [ index ] = pending_idx ; xenvif_put ( vif ) ; } start = ( frag_get_pending_idx ( & shinfo -> frags [ 0 ] ) == pending_idx ) ; for ( i = start ; i < nr_frags ; i ++ ) { int j , newerr ; pending_idx = frag_get_pending_idx ( & shinfo -> frags [ i ] ) ; newerr = ( ++ gop ) -> status ; if ( likely ( ! newerr ) ) { if ( unlikely ( err ) ) xen_netbk_idx_release ( netbk , pending_idx ) ; continue ; } xen_netbk_idx_release ( netbk , pending_idx , XEN_NETIF_RSP_OKAY ) ; index = pending_index ( netbk -> pending_prod ++ ) ; txp = & pending_tx_info [ pending_idx ] . req ; make_tx_response ( vif , txp , XEN_NETIF_RSP_OKAY ) ; netbk -> pending_ring [ index ] = pending_idx ; xenvif_put ( vif ) ; } start = ( frag_get_pending_idx ( & shinfo -> frags [ 0 ] ) == pending_idx ) ; for ( i = start ; i < nr_frags ; i ++ ) { int j , newerr ; pending_idx = frag_get_pending_idx ( & shinfo
",0,511
285,"static Image * ReadYUVImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * chroma_image , * image , * resize_image ; InterlaceType interlace ; MagickBooleanType status ; register const Quantum * chroma_pixels ; register ssize_t x ; register Quantum * q ; register unsigned char * p ; ssize_t count , horizontal_factor , vertical_factor , y ; size_t length , quantum ; unsigned char * scanline ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; if ( ( image -> columns == 0 ) || ( image -> rows == 0 ) ) ThrowReaderException ( OptionError , ""MustSpecifyImageSize"" ) ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; quantum = ( ssize_t ) ( image -> depth <= 8 ? 1 : 2 ) ; interlace = image_info -> interlace ; horizontal_factor = 2 ; vertical_factor = 2 ; if ( image_info -> sampling_factor != ( char * ) NULL ) { GeometryInfo geometry_info ; MagickStatusType flags ; flags = ParseGeometry ( image_info -> sampling_factor , & geometry_info ) ; horizontal_factor = ( ssize_t ) geometry_info . rho ; vertical_factor = ( ssize_t ) geometry_info . sigma ; if ( ( flags & SigmaValue ) == 0 ) vertical_factor = horizontal_factor ; if ( ( horizontal_factor != 1 ) && ( horizontal_factor != 2 ) && ( vertical_factor != 1 ) && ( vertical_factor != 2 ) ) ThrowReaderException ( CorruptImageError , ""UnexpectedSamplingFactor"" ) ; } if ( ( interlace == UndefinedInterlace ) || ( ( interlace == NoInterlace ) && (
",0,511
286,"int main ( void ) { int fd , len , sock_opt ; int error ; struct cn_msg * message ; struct pollfd pfd ; struct nlmsghdr * incoming_msg ; struct cn_msg * incoming_cn_msg ; struct hv_kvp_msg * hv_msg ; char * p ; char * key_value ; char * key_name ; int op ; int pool ; char * if_name ; struct hv_kvp_ipaddr_value * kvp_ip_val ; daemon ( 1 , 0 ) ; openlog ( ""KVP"" , 0 , LOG_USER ) ; syslog ( LOG_INFO , ""KVPstarting;pidis:%d"" , getpid ( ) ) ; kvp_get_os_info ( ) ; if ( kvp_file_init ( ) ) { syslog ( LOG_ERR , ""Failedtoinitializethepools"" ) ; exit ( EXIT_FAILURE ) ; } fd = socket ( AF_NETLINK , SOCK_DGRAM , NETLINK_CONNECTOR ) ; if ( fd < 0 ) { syslog ( LOG_ERR , ""netlinksocketcreationfailed;error:%d"" , fd ) ; exit ( EXIT_FAILURE ) ; } addr . nl_family = AF_NETLINK ; addr . nl_pad = 0 ; addr . nl_pid = 0 ; addr . nl_groups = CN_KVP_IDX ; error = bind ( fd , ( struct sockaddr * ) & addr , sizeof ( addr ) ) ; if ( error < 0 ) { syslog ( LOG_ERR , ""bindfailed;error:%d"" , error ) ; close ( fd ) ; exit ( EXIT_FAILURE ) ; } sock_opt = addr . nl_groups ; setsockopt ( fd , 270 , 1 , & sock_opt , sizeof ( sock_opt ) ) ; message = ( struct cn_msg * ) kvp_send_buffer ; message -> id . idx = CN_KVP_IDX ; message -> id . val = CN_KVP_VAL ; hv_msg = ( struct hv_kvp_msg * ) message -> data ; hv_msg -> kvp_
",0,511
287,"int handle_unaligned_access ( insn_size_t instruction , struct pt_regs * regs , struct mem_access * ma , int expected , unsigned long address ) { u_int rm ; int ret , index ; if ( instruction_size ( instruction ) != 2 ) return - EINVAL ; index = ( instruction >> 8 ) & 15 ; rm = regs -> regs [ index ] ; if ( ! expected ) { unaligned_fixups_notify ( current , instruction , regs ) ; perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , regs , address ) ; } ret = - EFAULT ; switch ( instruction & 0xF000 ) { case 0x0000 : if ( instruction == 0x000B ) { ret = handle_delayslot ( regs , instruction , ma ) ; if ( ret == 0 ) regs -> pc = regs -> pr ; } else if ( ( instruction & 0x00FF ) == 0x0023 ) { ret = handle_delayslot ( regs , instruction , ma ) ; if ( ret == 0 ) regs -> pc += rm + 4 ; } else if ( ( instruction & 0x00FF ) == 0x0003 ) { ret = handle_delayslot ( regs , instruction , ma ) ; if ( ret == 0 ) { regs -> pr = regs -> pc + 4 ; regs -> pc += rm + 4 ; } } else { goto simple ; } break ; case 0x1000 : goto simple ; case 0x2000 : goto simple ; case 0x4000 : if ( ( instruction & 0x00FF ) == 0x002B ) { ret = handle_delayslot ( regs , instruction , ma ) ; if ( ret == 0 ) regs -> pc = rm ; } else if ( ( instruction & 0x00FF ) == 0x000B ) { ret = handle_delayslot ( regs , instruction , ma ) ; if ( ret == 0 ) { regs -> pr = regs -> pc + 4 ; regs -> pc = rm ; } } else { goto simple ; } break ; case 0x5000 : goto simple ; case 0x6000 : goto simple ; case 0x8000 : switch ( instruction & 0x0F00 ) { case 0x0100 : goto simple ; case 0x8000 :
",0,511
288,"gboolean cib_notify_client ( gpointer key , gpointer value , gpointer user_data ) { const char * type = NULL ; gboolean do_send = FALSE ; cib_client_t * client = value ; xmlNode * update_msg = user_data ; CRM_CHECK ( client != NULL , return TRUE ) ; if ( client -> ipc == NULL || client -> ipc == NULL ) { crm_warn ( ""SkippingclientwithNULLchannel"" ) ; return FALSE ; } type = crm_element_value ( update_msg , F_SUBTYPE ) ; CRM_LOG_ASSERT ( type != NULL ) ; if ( client -> diffs && safe_str_eq ( type , T_CIB_DIFF_NOTIFY ) ) { do_send = TRUE ; } else if ( client -> replace && safe_str_eq ( type , T_CIB_REPLACE_NOTIFY ) ) { do_send = TRUE ; } else if ( client -> confirmations && safe_str_eq ( type , T_CIB_UPDATE_CONFIRM ) ) { do_send = TRUE ; } else if ( client -> pre_notify && safe_str_eq ( type , T_CIB_PRE_NOTIFY ) ) { do_send = TRUE ; } else if ( client -> post_notify && safe_str_eq ( type , T_CIB_POST_NOTIFY ) ) { do_send = TRUE ; } if ( do_send ) { if ( client -> ipc ) { if ( crm_ipcs_send ( client -> ipc , 0 , update_msg , TRUE ) == FALSE ) { crm_warn ( ""Notificationofclient%s/%sfailed"" , client -> name , client -> id ) ; } # ifdef HAVE_GNUTLS_GNUTLS_H } else if ( client -> session ) { crm_debug ( ""Sent%snotificationtoclient%s/%s"" , type , client -> name , client -> id ) ; crm_send_remote_msg ( client -> session , update_msg , client -> encrypted ) ; # endif } else { crm_err ( ""Unknowntransportfor%s"" , client ) ; } do_send : TRUE ;
",0,511
289,"static PyObject * patch ( PyObject * self , PyObject * args ) { char * origData , * newData , * diffBlock , * extraBlock , * diffPtr , * extraPtr ; Py_ssize_t origDataLength , newDataLength , diffBlockLength , extraBlockLength ; PyObject * controlTuples , * tuple , * results ; off_t oldpos , newpos , x , y , z ; int i , j , numTuples ; if ( ! PyArg_ParseTuple ( args , ""s#nO
",0,120
290,"static struct fileIdentDesc * udf_find_entry ( struct inode * dir , const struct qstr * child , struct udf_fileident_bh * fibh , struct fileIdentDesc * cfi ) { struct fileIdentDesc * fi = NULL ; loff_t f_pos ; int block , flen ; unsigned char * fname = NULL ; unsigned char * nameptr ; uint8_t lfi ; uint16_t liu ; loff_t size ; struct kernel_lb_addr eloc ; uint32_t elen ; sector_t offset ; struct extent_position epos = { } ; struct udf_inode_info * dinfo = UDF_I ( dir ) ; int isdotdot = child -> len == 2 && child -> name [ 0 ] == '.' && child -> name [ 1 ] == '.' ; size = udf_ext0_offset ( dir ) + dir -> i_size ; f_pos = udf_ext0_offset ( dir ) ; fibh -> sbh = fibh -> ebh = NULL ; fibh -> soffset = fibh -> eoffset = f_pos & ( dir -> i_sb -> s_blocksize - 1 ) ; if ( dinfo -> i_alloc_type != ICBTAG_FLAG_AD_IN_ICB ) { if ( inode_bmap ( dir , f_pos >> dir -> i_sb -> s_blocksize_bits , & epos , & eloc , & elen , & offset ) != ( EXT_RECORDED_ALLOCATED >> 30 ) ) goto out_err ; block = udf_get_lb_pblock ( dir -> i_sb , & eloc , offset ) ; if ( ( ++ offset << dir -> i_sb -> s_blocksize_bits ) < elen ) { if ( dinfo -> i_alloc_type == ICBTAG_FLAG_AD_SHORT ) epos . offset -= sizeof ( struct short_ad ) ; else if ( dinfo -> i_alloc_type == ICBTAG_FLAG_AD_LONG ) epos . offset -= sizeof ( struct long_ad ) ; } else offset = 0 ; fibh -> sbh = fibh -> ebh = udf_tread ( dir -> i_sb , block ) ; if ( ! fib
",0,511
291,"static int do_ip_vs_get_ctl ( struct sock * sk , int cmd , void __user * user , int * len ) { unsigned char arg [ 128 ] ; int ret = 0 ; unsigned int copylen ; struct net * net = sock_net ( sk ) ; struct netns_ipvs * ipvs = net_ipvs ( net ) ; BUG_ON ( ! net ) ; if ( ! capable ( CAP_NET_ADMIN ) ) return - EPERM ; if ( cmd < IP_VS_BASE_CTL || cmd > IP_VS_SO_GET_MAX ) return - EINVAL ; if ( * len < get_arglen [ GET_CMDID ( cmd ) ] ) { pr_err ( ""get_ctl:len%u<%u\\n"" , * len , get_arglen [ GET_CMDID ( cmd ) ] ) ; return - EINVAL ; } copylen = get_arglen [ GET_CMDID ( cmd ) ] ; if ( copylen > 128 ) return - EINVAL ; if ( copy_from_user ( arg , user , copylen ) != 0 ) return - EFAULT ; if ( cmd == IP_VS_SO_GET_DAEMON ) { struct ip_vs_daemon_user d [ 2 ] ; memset ( & d , 0 , sizeof ( d ) ) ; if ( mutex_lock_interruptible ( & ipvs -> sync_mutex ) ) return - ERESTARTSYS ; if ( ipvs -> sync_state & IP_VS_STATE_MASTER ) { d [ 0 ] . state = IP_VS_STATE_MASTER ; strlcpy ( d [ 0 ] . mcast_ifn , ipvs -> master_mcast_ifn , sizeof ( d [ 0 ] . mcast_ifn ) ) ; d [ 0 ] . syncid = ipvs -> master_syncid ; } if ( ipvs -> sync_state & IP_VS_STATE_BACKUP ) { d [ 1 ] . state = IP_VS_STATE_BACKUP ; strlcpy ( d [ 1 ] . mcast_ifn , ipvs -> backup_mcast_ifn , sizeof ( d [ 1 ] . mcast_ifn ) ) ; d [ 1 ] .
",0,511
292,"static int tcp_v6_send_synack ( const struct sock * sk , struct dst_entry * dst , struct flowi * fl , struct request_sock * req , struct tcp_fastopen_cookie * foc , bool attach_req ) { struct inet_request_sock * ireq = inet_rsk ( req ) ; struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct flowi6 * fl6 = & fl -> u . ip6 ; struct sk_buff * skb ; int err = - ENOMEM ; if ( ! dst && ( dst = inet6_csk_route_req ( sk , fl6 , req , IPPROTO_TCP ) ) == NULL ) goto done ; skb = tcp_make_synack ( sk , dst , req , foc , attach_req ) ; if ( skb ) { __tcp_v6_send_check ( skb , & ireq -> ir_v6_loc_addr , & ireq -> ir_v6_rmt_addr ) ; fl6 -> daddr = ireq -> ir_v6_rmt_addr ; if ( np -> repflow && ireq -> pktopts ) fl6 -> flowlabel = ip6_flowlabel ( ipv6_hdr ( ireq -> pktopts ) ) ; err = ip6_xmit_eval ( sk , skb , fl6 , np -> opt , np -> tclass ) ; } done : return err ; }
",0,337
293,"static ssize_t ib_ucm_write ( struct file * filp , const char __user * buf , size_t len , loff_t * pos ) { struct ib_ucm_file * file = filp -> private_data ; struct ib_ucm_cmd_hdr hdr ; ssize_t result ; if ( WARN_ON_ONCE ( ! ib_safe_file_access ( filp ) ) ) return - EACCES ; if ( len < sizeof ( hdr ) ) return - EINVAL ; if ( copy_from_user ( & hdr , buf , sizeof ( hdr ) ) ) return - EFAULT ; if ( hdr . cmd >= ARRAY_SIZE ( ucm_cmd_table ) ) return - EINVAL ; if ( hdr . in + sizeof ( hdr ) > len ) return - EINVAL ; result = ucm_cmd_table [ hdr . cmd ] ( file , buf + sizeof ( hdr ) , hdr . in , hdr . out ) ; if ( ! result ) result = len ; return result ; }
",1,242
294,"int cg_mkdir ( const char * path , mode_t mode ) { struct fuse_context * fc = fuse_get_context ( ) ; char * fpath = NULL , * path1 , * cgdir = NULL , * controller , * next = NULL ; const char * cgroup ; int ret ; if ( ! fc ) return - EIO ; controller = pick_controller_from_path ( fc , path ) ; if ( ! controller ) return - EINVAL ; cgroup = find_cgroup_in_path ( path ) ; if ( ! cgroup ) return - EINVAL ; get_cgdir_and_path ( cgroup , & cgdir , & fpath ) ; if ( ! fpath ) path1 = ""/"" ; else path1 = cgdir ; if ( ! caller_is_in_ancestor ( fc -> pid , controller , path1 , & next ) ) { ret = - EACCES ; goto out ; } if ( ! fc_may_access ( fc , controller , path1 , & next ) ) { ret = - EACCES ; goto out ; } ret = cgfs_create ( controller , cgroup , fc -> uid , fc -> gid ) ; printf ( ""cgfs_createreturned%dfor%s%s\\n"" , ret , controller , cgroup ) ; out : free ( cgdir ) ; free ( next ) ; return ret ; }
",0,324
295,"static void pcd_init_units ( void ) { struct pcd_unit * cd ; int unit ; pcd_drive_count = 0 ; for ( unit = 0 , cd = pcd ; unit < PCD_UNITS ; unit ++ , cd ++ ) { struct gendisk * disk = alloc_disk ( 1 ) ; if ( ! disk ) continue ; disk -> queue = blk_mq_init_sq_queue ( & cd -> tag_set , & pcd_mq_ops , 1 , BLK_MQ_F_SHOULD_MERGE ) ; if ( IS_ERR ( disk -> queue ) ) { disk -> queue = NULL ; continue ; } INIT_LIST_HEAD ( & cd -> rq_list ) ; disk -> queue -> queuedata = cd ; blk_queue_bounce_limit ( disk -> queue , BLK_BOUNCE_HIGH ) ; cd -> disk = disk ; cd -> pi = & cd -> pia ; cd -> present = 0 ; cd -> last_sense = 0 ; cd -> changed = 1 ; cd -> drive = ( * drives [ unit ] ) [ D_SLV ] ; if ( ( * drives [ unit ] ) [ D_PRT ] ) pcd_drive_count ++ ; cd -> name = & cd -> info . name [ 0 ] ; snprintf ( cd -> name , sizeof ( cd -> info . name ) , ""%s%d"" , name , unit ) ; cd -> info . ops = & pcd_dops ; cd -> info . handle = cd ; cd -> info . speed = 0 ; cd -> info . capacity = 1 ; cd -> info . mask = 0 ; disk -> major = major ; disk -> first_minor = unit ; strcpy ( disk -> disk_name , cd -> name ) ; disk -> fops = & pcd_bdops ; disk -> flags = GENHD_FL_BLOCK_EVENTS_ON_EXCL_WRITE ; } }
",0,432
296,"static void ntlm_write_message_header ( wStream * s , NTLM_MESSAGE_HEADER * header ) { Stream_Write ( s , header -> Signature , sizeof ( NTLM_SIGNATURE ) ) ; Stream_Write_UINT32 ( s , header -> MessageType ) ; }
",1,71
297,"static Image * ReadVIFFImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define VFF_CM_genericRGB 15 # define VFF_CM_ntscRGB 1 # define VFF_CM_NONE 0 # define VFF_DEP_DECORDER 0x4 # define VFF_DEP_NSORDER 0x8 # define VFF_DES_RAW 0 # define VFF_LOC_IMPLICIT 1 # define VFF_MAPTYP_NONE 0 # define VFF_MAPTYP_1_BYTE 1 # define VFF_MAPTYP_2_BYTE 2 # define VFF_MAPTYP_4_BYTE 4 # define VFF_MAPTYP_FLOAT 5 # define VFF_MAPTYP_DOUBLE 7 # define VFF_MS_NONE 0 # define VFF_MS_ONEPERBAND 1 # define VFF_MS_SHARED 3 # define VFF_TYP_BIT 0 # define VFF_TYP_1_BYTE 1 # define VFF_TYP_2_BYTE 2 # define VFF_TYP_4_BYTE 4 # define VFF_TYP_FLOAT 5 # define VFF_TYP_DOUBLE 9 typedef struct _ViffInfo { unsigned char identifier , file_type , release , version , machine_dependency , reserve [ 3 ] ; char comment [ 512 ] ; unsigned int rows , columns , subrows ; int x_offset , y_offset ; float x_bits_per_pixel , y_bits_per_pixel ; unsigned int location_type , location_dimension , number_of_images , number_data_bands , data_storage_type , data_encode_scheme , map_scheme , map_storage_type , map_rows , map_columns , map_subrows , map_enable , maps_per_cycle , color_space_model ; } ViffInfo ; double min_value , scale_factor , value ; Image * image ; int bit ; MagickBooleanType status ; MagickSizeType number_pixels ; register ssize_t x ; register Quantum * q ; register ssize_t i ; register unsigned char * p ; size_t bytes_per_pixel , max_pack
",0,511
298,"static int asf_build_simple_index ( AVFormatContext * s , int stream_index ) { ff_asf_guid g ; ASFContext * asf = s -> priv_data ; int64_t current_pos = avio_tell ( s -> pb ) ; int64_t ret ; if ( ( ret = avio_seek ( s -> pb , asf -> data_object_offset + asf -> data_object_size , SEEK_SET ) ) < 0 ) { return ret ; } if ( ( ret = ff_get_guid ( s -> pb , & g ) ) < 0 ) goto end ; while ( ff_guidcmp ( & g , & ff_asf_simple_index_header ) ) { int64_t gsize = avio_rl64 ( s -> pb ) ; if ( gsize < 24 || avio_feof ( s -> pb ) ) { goto end ; } avio_skip ( s -> pb , gsize - 24 ) ; if ( ( ret = ff_get_guid ( s -> pb , & g ) ) < 0 ) goto end ; } { int64_t itime , last_pos = - 1 ; int pct , ict ; int i ; int64_t av_unused gsize = avio_rl64 ( s -> pb ) ; if ( ( ret = ff_get_guid ( s -> pb , & g ) ) < 0 ) goto end ; itime = avio_rl64 ( s -> pb ) ; pct = avio_rl32 ( s -> pb ) ; ict = avio_rl32 ( s -> pb ) ; av_log ( s , AV_LOG_DEBUG , ""itime:0x%"" PRIx64 "",pct:%d,ict:%d\\n"" , itime , pct , ict ) ; for ( i = 0 ; i < ict ; i ++ ) { int pktnum = avio_rl32 ( s -> pb ) ; int pktct = avio_rl16 ( s -> pb ) ; int64_t pos = s -> internal -> data_offset + s -> packet_size * ( int64_t ) pktnum ; int64_t index_pts
",0,511
299,"static long sg_ioctl ( struct file * filp , unsigned int cmd_in , unsigned long arg ) { void __user * p = ( void __user * ) arg ; int __user * ip = p ; int result , val , read_only ; Sg_device * sdp ; Sg_fd * sfp ; Sg_request * srp ; unsigned long iflags ; if ( ( ! ( sfp = ( Sg_fd * ) filp -> private_data ) ) || ( ! ( sdp = sfp -> parentdp ) ) ) return - ENXIO ; SCSI_LOG_TIMEOUT ( 3 , sg_printk ( KERN_INFO , sdp , ""sg_ioctl:cmd=0x%x\\n"" , ( int ) cmd_in ) ) ; read_only = ( O_RDWR != ( filp -> f_flags & O_ACCMODE ) ) ; switch ( cmd_in ) { case SG_IO : if ( atomic_read ( & sdp -> detaching ) ) return - ENODEV ; if ( ! scsi_block_when_processing_errors ( sdp -> device ) ) return - ENXIO ; if ( ! access_ok ( VERIFY_WRITE , p , SZ_SG_IO_HDR ) ) return - EFAULT ; result = sg_new_write ( sfp , filp , p , SZ_SG_IO_HDR , 1 , read_only , 1 , & srp ) ; if ( result < 0 ) return result ; result = wait_event_interruptible ( sfp -> read_wait , ( srp_done ( sfp , srp ) || atomic_read ( & sdp -> detaching ) ) ) ; if ( atomic_read ( & sdp -> detaching ) ) return - ENODEV ; write_lock_irq ( & sfp -> rq_list_lock ) ; if ( srp -> done ) { srp -> done = 2 ; write_unlock_irq ( & sfp -> rq_list_lock ) ; result = sg_new_read ( sfp , p , SZ_SG_IO_HDR , srp ) ; return ( result < 0 ) ? result : 0 ; } srp -> orphan = 1 ; write
",0,511
300,"void init_global_keywords ( bool global_active ) { install_keyword_root ( ""linkbeat_use_polling"" , use_polling_handler , global_active ) ; # if HAVE_DECL_CLONE_NEWNET install_keyword_root ( ""net_namespace"" , & net_namespace_handler , global_active ) ; install_keyword_root ( ""namespace_with_ipsets"" , & namespace_ipsets_handler , global_active ) ; # endif install_keyword_root ( ""use_pid_dir"" , & use_pid_dir_handler , global_active ) ; install_keyword_root ( ""instance"" , & instance_handler , global_active ) ; install_keyword_root ( ""child_wait_time"" , & child_wait_handler , global_active ) ; install_keyword_root ( ""global_defs"" , NULL , global_active ) ; install_keyword ( ""router_id"" , & routerid_handler ) ; install_keyword ( ""notification_email_from"" , & emailfrom_handler ) ; install_keyword ( ""smtp_server"" , & smtpserver_handler ) ; install_keyword ( ""smtp_helo_name"" , & smtphelo_handler ) ; install_keyword ( ""smtp_connect_timeout"" , & smtpto_handler ) ; install_keyword ( ""notification_email"" , & email_handler ) ; install_keyword ( ""smtp_alert"" , & smtp_alert_handler ) ; # ifdef _WITH_VRRP_ install_keyword ( ""smtp_alert_vrrp"" , & smtp_alert_vrrp_handler ) ; # endif # ifdef _WITH_LVS_ install_keyword ( ""smtp_alert_checker"" , & smtp_alert_checker_handler ) ; # endif # ifdef _WITH_VRRP_ install_keyword ( ""dynamic_interfaces"" , & dynamic_interfaces_handler ) ; install_keyword ( ""no_email_faults"" , & no_email_faults_handler ) ; install_keyword ( ""default_interface"" , & default_
",0,511
301,"static vpx_codec_err_t encoder_init ( vpx_codec_ctx_t * ctx , vpx_codec_priv_enc_mr_cfg_t * data ) { ( void ) data ; return encoder_common_init ( ctx ) ; }
",0,66
302,"int iscsi_decode_text_input ( u8 phase , u8 sender , char * textbuf , u32 length , struct iscsi_conn * conn ) { struct iscsi_param_list * param_list = conn -> param_list ; char * tmpbuf , * start = NULL , * end = NULL ; tmpbuf = kzalloc ( length + 1 , GFP_KERNEL ) ; if ( ! tmpbuf ) { pr_err ( ""Unabletoallocatememoryfortmpbuf.\\n"" ) ; return - 1 ; } memcpy ( tmpbuf , textbuf , length ) ; tmpbuf [ length ] = '\\0' ; start = tmpbuf ; end = ( start + length ) ; while ( start < end ) { char * key , * value ; struct iscsi_param * param ; if ( iscsi_extract_key_value ( start , & key , & value ) < 0 ) { kfree ( tmpbuf ) ; return - 1 ; } pr_debug ( ""Gotkey:%s=%s\\n"" , key , value ) ; if ( phase & PHASE_SECURITY ) { if ( iscsi_check_for_auth_key ( key ) > 0 ) { char * tmpptr = key + strlen ( key ) ; * tmpptr = '=' ; kfree ( tmpbuf ) ; return 1 ; } } param = iscsi_check_key ( key , phase , sender , param_list ) ; if ( ! param ) { if ( iscsi_add_notunderstood_response ( key , value , param_list ) < 0 ) { kfree ( tmpbuf ) ; return - 1 ; } start += strlen ( key ) + strlen ( value ) + 2 ; continue ; } if ( iscsi_check_value ( param , value ) < 0 ) { kfree ( tmpbuf ) ; return - 1 ; } start += strlen ( key ) + strlen ( value ) + 2 ; if ( IS_PSTATE_PROPOSER ( param ) ) { if ( iscsi_check_proposer_state ( param , value ) < 0 ) { kfree ( tmpbuf ) ; return - 1 ; } SET_PSTATE_RESPONSE_GOT ( param ) ; } else
",0,511
303,"static int timer_start ( Unit * u ) { Timer * t = TIMER ( u ) ; TimerValue * v ; assert ( t ) ; assert ( t -> state == TIMER_DEAD || t -> state == TIMER_FAILED ) ; if ( UNIT_TRIGGER ( u ) -> load_state != UNIT_LOADED ) return - ENOENT ; t -> last_trigger = DUAL_TIMESTAMP_NULL ; LIST_FOREACH ( value , v , t -> values ) if ( v -> base == TIMER_ACTIVE ) v -> disabled = false ; if ( t -> stamp_path ) { struct stat st ; if ( stat ( t -> stamp_path , & st ) >= 0 ) t -> last_trigger . realtime = timespec_load ( & st . st_atim ) ; else if ( errno == ENOENT ) touch_file ( t -> stamp_path , true , USEC_INFINITY , UID_INVALID , GID_INVALID , MODE_INVALID ) ; } t -> result = TIMER_SUCCESS ; timer_enter_waiting ( t , true ) ; return 1 ; }
",1,263
304,"jp2_box_t * jp2_box_get ( jas_stream_t * in ) { jp2_box_t * box ; jp2_boxinfo_t * boxinfo ; jas_stream_t * tmpstream ; uint_fast32_t len ; uint_fast64_t extlen ; bool dataflag ; box = 0 ; tmpstream = 0 ; if ( ! ( box = jas_malloc ( sizeof ( jp2_box_t ) ) ) ) { goto error ; } box -> ops = & jp2_boxinfo_unk . ops ; if ( jp2_getuint32 ( in , & len ) || jp2_getuint32 ( in , & box -> type ) ) { goto error ; } boxinfo = jp2_boxinfolookup ( box -> type ) ; box -> info = boxinfo ; box -> len = len ; JAS_DBGLOG ( 10 , ( ""preliminaryprocessingofJP2box:type=%c%s%c(0x%08x);length=%"" PRIuFAST32 ""\\n"" , \'""\' , boxinfo -> name , \'""\' , box -> type , box -> len ) ) ; if ( box -> len == 1 ) { JAS_DBGLOG ( 10 , ( ""biglength\\n"" ) ) ; if ( jp2_getuint64 ( in , & extlen ) ) { goto error ; } if ( extlen > 0xffffffffUL ) { jas_eprintf ( ""warning:cannothandlelarge64-bitboxlength\\n"" ) ; extlen = 0xffffffffUL ; } box -> len = extlen ; box -> datalen = extlen - JP2_BOX_HDRLEN ( true ) ; } else { box -> datalen = box -> len - JP2_BOX_HDRLEN ( false ) ; } if ( box -> len != 0 && box -> len < 8 ) { goto error ; } dataflag = ! ( box -> info -> flags & ( JP2_BOX_SUPER | JP2_BOX_NODATA ) ) ; if ( dataflag ) { if ( ! ( tmpstream = jas_stream_memopen ( 0 , 0 ) ) ) { goto error ; } if
",0,511
305,"static int _Unpickler_ResizeMemoList ( UnpicklerObject * self , size_t new_size ) { size_t i ; assert ( new_size > self -> memo_size ) ; PyObject * * memo_new = self -> memo ; PyMem_RESIZE ( memo_new , PyObject * , new_size ) ; if ( memo_new == NULL ) { PyErr_NoMemory ( ) ; return - 1 ; } self -> memo = memo_new ; for ( i = self -> memo_size ; i < new_size ; i ++ ) self -> memo [ i ] = NULL ; self -> memo_size = new_size ; return 0 ; }
",0,151
306,"static ssize_t macvtap_get_user ( struct macvtap_queue * q , struct msghdr * m , const struct iovec * iv , unsigned long total_len , size_t count , int noblock ) { struct sk_buff * skb ; struct macvlan_dev * vlan ; unsigned long len = total_len ; int err ; struct virtio_net_hdr vnet_hdr = { 0 } ; int vnet_hdr_len = 0 ; int copylen ; bool zerocopy = false ; if ( q -> flags & IFF_VNET_HDR ) { vnet_hdr_len = q -> vnet_hdr_sz ; err = - EINVAL ; if ( len < vnet_hdr_len ) goto err ; len -= vnet_hdr_len ; err = memcpy_fromiovecend ( ( void * ) & vnet_hdr , iv , 0 , sizeof ( vnet_hdr ) ) ; if ( err < 0 ) goto err ; if ( ( vnet_hdr . flags & VIRTIO_NET_HDR_F_NEEDS_CSUM ) && vnet_hdr . csum_start + vnet_hdr . csum_offset + 2 > vnet_hdr . hdr_len ) vnet_hdr . hdr_len = vnet_hdr . csum_start + vnet_hdr . csum_offset + 2 ; err = - EINVAL ; if ( vnet_hdr . hdr_len > len ) goto err ; } err = - EINVAL ; if ( unlikely ( len < ETH_HLEN ) ) goto err ; if ( m && m -> msg_control && sock_flag ( & q -> sk , SOCK_ZEROCOPY ) ) zerocopy = true ; if ( zerocopy ) { if ( count > MAX_SKB_FRAGS ) len = MAX_SKB_FRAGS ; copylen = vnet_hdr . hdr_len ; if ( ! copylen ) copylen = GOODCOPY_LEN ; } skb = macvtap_alloc_skb ( & q -> sk , NET_IP_ALIGN
",0,511
307,"int ip6_find_1stfragopt ( struct sk_buff * skb , u8 * * nexthdr ) { u16 offset = sizeof ( struct ipv6hdr ) ; struct ipv6_opt_hdr * exthdr = ( struct ipv6_opt_hdr * ) ( ipv6_hdr ( skb ) + 1 ) ; unsigned int packet_len = skb_tail_pointer ( skb ) - skb_network_header ( skb ) ; int found_rhdr = 0 ; * nexthdr = & ipv6_hdr ( skb ) -> nexthdr ; while ( offset <= packet_len && * nexthdr ) { switch ( * * nexthdr ) { case NEXTHDR_HOP : break ; case NEXTHDR_ROUTING : found_rhdr = 1 ; break ; case NEXTHDR_DEST : # if IS_ENABLED ( CONFIG_IPV6_MIP6 ) if ( ipv6_find_tlv ( skb , offset , IPV6_TLV_HAO ) >= 0 ) break ; # endif if ( found_rhdr ) return offset ; break ; default : return offset ; } exthdr = ( struct ipv6_opt_hdr * ) ( skb_network_header ( skb ) + offset ) ; } return offset ; }
",0,314
308,"static void write_delta_q ( struct vpx_write_bit_buffer * wb , int delta_q ) { if ( delta_q < 0 ) { vpx_wb_write_bit ( wb , 1 ) ; vp9_wb_write_literal ( wb , abs ( delta_q ) , 4 ) ; vpx_wb_write_bit ( wb , delta_q < 0 ) ; } else { vpx_wb_write_bit ( wb , 0 ) ; } }
",0,116
309,"void vp8_mv_pred ( VP8_COMP * cpi , MACROBLOCKD * xd , const MODE_INFO * here , int_mv * mvp , int refframe , int * ref_frame_sign_bias , int * sr , int near_sadidx [ ] ) { const MODE_INFO * above = here - xd -> mode_info_stride ; const MODE_INFO * left = here - 1 ; const MODE_INFO * aboveleft = above - 1 ; int_mv near_mvs [ 8 ] ; int near_ref [ 8 ] ; int_mv mv ; int vcnt = 0 ; int find = 0 ; int mb_offset ; int mvx [ 8 ] ; int mvy [ 8 ] ; int i ; mv . as_int = 0 ; if ( here -> mbmi . ref_frame != INTRA_FRAME ) { near_mvs [ 0 ] . as_int = near_mvs [ 1 ] . as_int = near_mvs [ 2 ] . as_int = near_mvs [ 3 ] . as_int = near_mvs [ 4 ] . as_int = near_mvs [ 5 ] . as_int = near_mvs [ 6 ] . as_int = near_mvs [ 7 ] . as_int = 0 ; near_ref [ 0 ] = near_ref [ 1 ] = near_ref [ 2 ] = near_ref [ 3 ] = near_ref [ 4 ] = near_ref [ 5 ] = near_ref [ 6 ] = near_ref [ 7 ] = 0 ; if ( above -> mbmi . ref_frame != INTRA_FRAME ) { near_mvs [ vcnt ] . as_int = above -> mbmi . mv . as_int ; mv_bias ( ref_frame_sign_bias [ above -> mbmi . ref_frame ] , refframe , & near_mvs [ vcnt ] , ref_frame_sign_bias ) ; near_ref [ vcnt ] = above -> mbmi . ref_frame ; } vcnt ++ ; if ( left -> mbmi . ref_frame != INTRA_FRAME ) { near_
",0,511
310,"static int packet_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { struct sock * sk = sock -> sk ; struct sk_buff * skb ; int copied , err ; struct sockaddr_ll * sll ; int vnet_hdr_len = 0 ; err = - EINVAL ; if ( flags & ~ ( MSG_PEEK | MSG_DONTWAIT | MSG_TRUNC | MSG_CMSG_COMPAT | MSG_ERRQUEUE ) ) goto out ; # if 0 if ( pkt_sk ( sk ) -> ifindex < 0 ) return - ENODEV ; # endif if ( flags & MSG_ERRQUEUE ) { err = packet_recv_error ( sk , msg , len ) ; goto out ; } skb = skb_recv_datagram ( sk , flags , flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out ; if ( pkt_sk ( sk ) -> has_vnet_hdr ) { struct virtio_net_hdr vnet_hdr = { 0 } ; err = - EINVAL ; vnet_hdr_len = sizeof ( vnet_hdr ) ; if ( len < vnet_hdr_len ) goto out_free ; len -= vnet_hdr_len ; if ( skb_is_gso ( skb ) ) { struct skb_shared_info * sinfo = skb_shinfo ( skb ) ; vnet_hdr . hdr_len = skb_headlen ( skb ) ; vnet_hdr . gso_size = sinfo -> gso_size ; if ( sinfo -> gso_type & SKB_GSO_TCPV4 ) vnet_hdr . gso_type = VIRTIO_NET_HDR_GSO_TCPV4 ; else if ( sinfo -> gso_type & SKB_GSO_TCPV6 ) vnet_hdr . gso_type = VIRTIO_NET_HDR_GSO_TCPV6 ; else if ( sinfo -> gso_type & SKB_GSO
",0,511
311,"static void logi_dj_recv_add_djhid_device ( struct dj_receiver_dev * djrcv_dev , struct dj_report * dj_report ) { struct hid_device * djrcv_hdev = djrcv_dev -> hdev ; struct usb_interface * intf = to_usb_interface ( djrcv_hdev -> dev . parent ) ; struct usb_device * usbdev = interface_to_usbdev ( intf ) ; struct hid_device * dj_hiddev ; struct dj_device * dj_dev ; unsigned char tmpstr [ 3 ] ; if ( dj_report -> report_params [ DEVICE_PAIRED_PARAM_SPFUNCTION ] & SPFUNCTION_DEVICE_LIST_EMPTY ) { dbg_hid ( ""%s:devicelistisempty\\n"" , __func__ ) ; djrcv_dev -> querying_devices = false ; return ; } if ( djrcv_dev -> device_index < DJ_DEVICE_INDEX_MIN ) || ( dj_report -> device_index > DJ_DEVICE_INDEX_MAX ) ) { dev_err ( & djrcv_hdev -> dev , ""%s:invaliddeviceindex:%d\\n"" , __func__ , dj_report -> device_index ) ; return ; } if ( djrcv_dev -> paired_dj_devices [ dj_report -> device_index ] ) { dbg_hid ( ""%s:deviceisalreadyknown\\n"" , __func__ ) ; return ; } dj_hiddev = hid_allocate_device ( ) ; if ( IS_ERR ( dj_hiddev ) ) { dev_err ( & djrcv_hdev -> dev , ""%s:hid_allocate_devicefailed\\n"" , __func__ ) ; return ; } dj_hiddev -> ll_driver = & logi_dj_ll_driver ; dj_hiddev -> dev . parent = & djrcv_hdev -> dev ; dj_hiddev -> bus = BUS_USB ; dj_hiddev -> vendor = le16_to_cpu ( usbdev -> descriptor . idVendor ) ; dj_hiddev -> product = le16_to_cpu ( usbdev
",0,511
312,"static inline int check_entry_size_and_hooks ( struct arpt_entry * e , struct xt_table_info * newinfo , const unsigned char * base , const unsigned char * limit , const unsigned int * hook_entries , const unsigned int * underflows , unsigned int valid_hooks ) { unsigned int h ; int err ; if ( ( unsigned long ) e % __alignof__ ( struct arpt_entry ) != 0 || ( unsigned char * ) e + sizeof ( struct arpt_entry ) >= limit || ( unsigned char * ) e + e -> next_offset > limit ) { duprintf ( ""Badoffset%p\\n"" , e ) ; return - EINVAL ; } if ( e -> next_offset < sizeof ( struct arpt_entry ) + sizeof ( struct xt_entry_target ) ) { pr_debug ( ""Underflowsmustbeunconditionaland"" ""usetheSTANDARDtargetwith"" ""ACCEPT/DROP\\n"" ) ; return - EINVAL ; } newinfo -> underflow [ h ] = underflows [ h ] ; } } e -> counters = ( ( struct xt_counters ) { 0 , 0 } ) ; e -> comefrom = 0 ; return 0 ; }
",1,275
313,"int bson_check_field_name ( bson * b , const char * string , const size_t length ) { return bson_validate_string ( b , ( const unsigned char * ) string , length , 1 , 1 , 1 ) ; }
",1,57
314,"struct sctp_chunk * sctp_process_asconf ( struct sctp_association * asoc , struct sctp_chunk * asconf ) { sctp_addip_chunk_t * addip = ( sctp_addip_chunk_t * ) asconf -> chunk_hdr ; sctp_addiphdr_t * hdr ; union sctp_addr_param * addr_param ; sctp_addip_param_t * asconf_param ; struct sctp_chunk * asconf_ack ; __be16 err_code ; int length = 0 ; int chunk_len ; __u32 serial ; chunk_len = ntohs ( asconf -> chunk_hdr -> length ) - sizeof ( sctp_chunkhdr_t ) ; hdr = ( sctp_addiphdr_t * ) asconf -> skb -> data ; serial = ntohl ( hdr -> serial ) ; length = sizeof ( sctp_addiphdr_t ) ; addr_param = ( union sctp_addr_param * ) ( asconf -> skb -> data + length ) ; chunk_len -= length ; length = ntohs ( addr_param -> p . length ) ; asconf_param = ( void * ) addr_param + length ; chunk_len -= length ; asconf_ack = sctp_make_asconf_ack ( asoc , serial , chunk_len * 4 ) ; if ( ! asconf_ack ) goto done ; sctp_walk_params ( asconf , addip , addip_hdr . params ) { sctp_walk_params ( asconf , addip , addip_hdr . params , asconf_param ) ; if ( SCTP_ERROR_NO_ERROR != err_code ) all_param_pass = 0 ; if ( ! all_param_pass ) sctp_add_asconf_response ( asconf_ack , asconf_param -> crr_id , err_code , asconf_param ) ; if ( SCTP_ERROR_RSRC_LOW == err_code ) goto done ; length = ntohs ( asconf_param -> param_hdr . length ) ; asconf
",0,511
315,"void * jas_realloc ( void * ptr , size_t size ) { void * result ; JAS_DBGLOG ( 101 , ( ""jas_realloc(%x,%zu)\\n"" , ptr , size ) ) ; result = realloc ( ptr , size ) ; JAS_DBGLOG ( 100 , ( ""jas_realloc(%p,%zu)->%p\\n"" , ptr , size , result ) ) ; return result ; }
",1,106
316,"static int recv_msg ( struct kiocb * iocb , struct socket * sock , struct msghdr * m , size_t buf_len , int flags ) { struct sock * sk = sock -> sk ; struct tipc_port * tport = tipc_sk_port ( sk ) ; struct sk_buff * buf ; struct tipc_msg * msg ; long timeout ; unsigned int sz ; u32 err ; int res ; if ( unlikely ( ! buf_len ) ) return - EINVAL ; lock_sock ( sk ) ; if ( unlikely ( sock -> state == SS_UNCONNECTED ) ) { res = - ENOTCONN ; goto exit ; } m -> msg_namelen = 0 ; timeout = sock_rcvtimeo ( sk , flags & MSG_DONTWAIT ) ; restart : while ( skb_queue_empty ( & sk -> sk_receive_queue ) ) { if ( sock -> state == SS_DISCONNECTING ) { res = - ENOTCONN ; goto exit ; } if ( timeout <= 0L ) { res = timeout ? timeout : - EWOULDBLOCK ; goto exit ; } release_sock ( sk ) ; timeout = wait_event_interruptible_timeout ( * sk_sleep ( sk ) , tipc_rx_ready ( sock ) , timeout ) ; lock_sock ( sk ) ; } buf = skb_peek ( & sk -> sk_receive_queue ) ; msg = buf_msg ( buf ) ; sz = msg_data_sz ( msg ) ; err = msg_errcode ( msg ) ; if ( ( ! sz ) && ( ! err ) ) { advance_rx_queue ( sk ) ; goto restart ; } set_orig_addr ( m , msg ) ; res = anc_data_recv ( m , msg , tport ) ; if ( res ) goto exit ; if ( ! err ) { if ( unlikely ( buf_len < sz ) ) { sz = buf_len ; m -> msg_flags |= MSG_TRUNC ; } res = skb_copy_datagram_iovec ( buf , msg_hdr_sz ( msg ) , m -> msg_iov , sz ) ; if ( res ) goto exit ; res = sz ; }
",0,510
317,"int kvm_vm_ioctl_check_extension ( struct kvm * kvm , long ext ) { int r ; int hv_enabled = kvmppc_hv_ops ? 1 : 0 ; if ( kvm ) { hv_enabled = is_kvmppc_hv_enabled ( kvm ) ; } switch ( ext ) { # ifdef CONFIG_BOOKE case KVM_CAP_PPC_BOOKE_SREGS : case KVM_CAP_PPC_BOOKE_WATCHDOG : case KVM_CAP_PPC_EPR : # else case KVM_CAP_PPC_SEGSTATE : case KVM_CAP_PPC_HIOR : case KVM_CAP_PPC_PAPR : # endif case KVM_CAP_PPC_UNSET_IRQ : case KVM_CAP_PPC_IRQ_LEVEL : case KVM_CAP_ENABLE_CAP : case KVM_CAP_ENABLE_CAP_VM : case KVM_CAP_ONE_REG : case KVM_CAP_IOEVENTFD : case KVM_CAP_DEVICE_CTRL : case KVM_CAP_IMMEDIATE_EXIT : r = 1 ; break ; case KVM_CAP_PPC_PAIRED_SINGLES : case KVM_CAP_PPC_OSI : case KVM_CAP_PPC_GET_PVINFO : # if defined ( CONFIG_KVM_E500V2 ) || defined ( CONFIG_KVM_E500MC ) case KVM_CAP_SW_TLB : # endif r = ! hv_enabled ; break ; # ifdef CONFIG_KVM_MPIC case KVM_CAP_IRQ_MPIC : r = 1 ; break ; # endif # ifdef CONFIG_PPC_BOOK3S_64 case KVM_CAP_SPAPR_TCE : case KVM_CAP_SPAPR_TCE_64 : case KVM_CAP_SPAPR_TCE_VFIO : case KVM_CAP_PPC_RTAS : case KVM_CAP_PPC_FIXUP_HCALL : case KVM_CAP_PPC_ENABLE_HCALL : # ifdef CONFIG
",0,511
318,"int pci_emul_add_msicap ( struct pci_vdev * dev , int msgnum ) { struct msicap msicap ; if ( msgnum < 0 ) { pr_err ( ""%s:invalidnumberofmsimessages
",0,59
319,"static void kvp_respond_to_host ( char * key , char * value , int error ) { struct hv_kvp_msg * kvp_msg ; struct hv_kvp_msg_enumerate * kvp_data ; char * key_name ; struct icmsg_hdr * icmsghdrp ; int keylen , valuelen ; u32 buf_len ; struct vmbus_channel * channel ; u64 req_id ; if ( ! kvp_transaction . active ) { pr_warn ( ""KVP:Transactionnotactive\\n"" ) ; return ; } buf_len = kvp_transaction . recv_len ; channel = kvp_transaction . recv_channel ; req_id = kvp_transaction . recv_req_id ; kvp_transaction . active = false ; if ( channel -> onchannel_callback == NULL ) return ; icmsghdrp = ( struct icmsg_hdr * ) & recv_buffer [ sizeof ( struct vmbuspipe_hdr ) ] ; kvp_msg = ( struct hv_kvp_msg * ) & recv_buffer [ sizeof ( struct vmbuspipe_hdr ) + sizeof ( struct icmsg_hdr ) ] ; kvp_data = & kvp_msg -> kvp_data ; key_name = key ; if ( error ) { icmsghdrp -> status = HV_E_FAIL ; goto response_done ; } keylen = utf8s_to_utf16s ( key_name , strlen ( key_name ) , UTF16_HOST_ENDIAN , ( wchar_t * ) kvp_data -> data . key ) ; kvp_data -> data . key_size = 2 * ( keylen + 1 ) ; valuelen = utf8s_to_utf16s ( value , strlen ( value ) , UTF16_HOST_ENDIAN , ( wchar_t * ) kvp_data -> data . value ) ; kvp_data -> data . value_size = 2 * ( valuelen + 1 ) ; kvp_data -> data . value_type = REG_SZ ; icmsghdrp -> status = HV_S_OK ; response_done : icmsgh
",0,511
320,"long vhost_dev_ioctl ( struct vhost_dev * d , unsigned int ioctl , void __user * argp ) { struct file * eventfp , * filep = NULL ; struct eventfd_ctx * ctx = NULL ; u64 p ; long r ; int i , fd ; if ( ioctl == VHOST_SET_OWNER ) { r = vhost_dev_set_owner ( d ) ; goto done ; } r = vhost_dev_check_owner ( d ) ; if ( r ) goto done ; switch ( ioctl ) { case VHOST_SET_MEM_TABLE : r = vhost_set_memory ( d , argp ) ; break ; case VHOST_SET_LOG_BASE : if ( copy_from_user ( & p , argp , sizeof p ) ) { r = - EFAULT ; break ; } if ( ( u64 ) ( unsigned long ) p != p ) { r = - EFAULT ; break ; } for ( i = 0 ; i < d -> nvqs ; ++ i ) { struct vhost_virtqueue * vq ; void __user * base = ( void __user * ) ( unsigned long ) p ; vq = d -> vqs [ i ] ; mutex_lock ( & vq -> mutex ) ; if ( vq -> private_data && ! vq_log_access_ok ( vq , base ) ) r = - EFAULT ; else vq -> log_base = base ; mutex_unlock ( & vq -> mutex ) ; } break ; case VHOST_SET_LOG_FD : r = get_user ( fd , ( int __user * ) argp ) ; if ( r < 0 ) break ; eventfp = fd == - 1 ? NULL : eventfd_fget ( fd ) ; if ( IS_ERR ( eventfp ) ) { r = PTR_ERR ( eventfp ) ; break ; } if ( eventfp != d -> log_file ) { filep = d -> log_file ; d -> log_file = eventfp ; ctx = d -> log_ctx ; d -> log_ctx = eventfp ? eventfd_ctx_fileget ( eventfp ) : NULL ; } else filep = eventfp ; for ( i = 0 ; i
",0,511
321,"void color_sycc_to_rgb ( opj_image_t * img ) { if ( img -> numcomps < 3 ) { img -> color_space = OPJ_CLRSPC_GRAY ; return ; } }
",1,54
322,"long video_usercopy ( struct file * file , unsigned int cmd , unsigned long arg , v4l2_kioctl func ) { char sbuf [ 128 ] ; void * mbuf = NULL ; void * parg = ( void * ) arg ; long err = - EINVAL ; int is_ext_ctrl ; size_t ctrls_size = 0 ; void __user * user_ptr = NULL ; is_ext_ctrl = ( cmd == VIDIOC_S_EXT_CTRLS || cmd == VIDIOC_G_EXT_CTRLS || cmd == VIDIOC_TRY_EXT_CTRLS ) ; switch ( _IOC_DIR ( cmd ) ) { case _IOC_NONE : parg = NULL ; break ; case _IOC_READ : case _IOC_WRITE : case ( _IOC_WRITE | _IOC_READ ) : if ( _IOC_SIZE ( cmd ) <= sizeof ( sbuf ) ) { parg = sbuf ; } else { mbuf = kmalloc ( _IOC_SIZE ( cmd ) , GFP_KERNEL ) ; if ( NULL == mbuf ) return - ENOMEM ; parg = mbuf ; } err = - EFAULT ; if ( _IOC_DIR ( cmd ) & _IOC_WRITE ) if ( copy_from_user ( parg , ( void __user * ) arg , _IOC_SIZE ( cmd ) ) ) goto out ; break ; } if ( is_ext_ctrl ) { struct v4l2_ext_controls * p = parg ; p -> error_idx = p -> count ; user_ptr = ( void __user * ) p -> controls ; if ( p -> count ) { ctrls_size = sizeof ( struct v4l2_ext_control ) * p -> count ; mbuf = kmalloc ( ctrls_size , GFP_KERNEL ) ; err = - ENOMEM ; if ( NULL == mbuf ) goto out_ext_ctrl ; err = - EFAULT ; if ( copy_from_user ( mbuf , user_ptr , ctrls_size ) ) goto out_ext_ctrl ; p -> controls = mbuf ; } } err = func ( file , cmd , parg ) ; if ( err ) return
",0,511
323,"int processCommand ( redisClient * c ) { struct redisCommand * cmd ; if ( ! strcasecmp ( c -> argv [ 0 ] -> ptr , ""quit"" ) ) { addReply ( c , shared . ok ) ; c -> flags |= REDIS_CLOSE_AFTER_REPLY ; return REDIS_ERR ; } cmd = lookupCommand ( c -> argv [ 0 ] -> ptr ) ; if ( ! cmd ) { addReplyErrorFormat ( c , ""unknowncommand\'%s\'"" , ( char * ) c -> argv [ 0 ] -> ptr ) ; return REDIS_OK ; } else if ( ( cmd -> arity > 0 && cmd -> arity != c -> argc ) || ( c -> argc < - cmd -> arity ) ) { addReplyErrorFormat ( c , ""wrongnumberofargumentsfor\'%s\'command"" , cmd -> name ) ; return REDIS_OK ; } if ( server . requirepass && ! c -> authenticated && cmd -> proc != authCommand ) { addReplyError ( c , ""operationnotpermitted"" ) ; return REDIS_OK ; } if ( server . maxmemory ) freeMemoryIfNeeded ( ) ; if ( server . maxmemory && ( cmd -> flags & REDIS_CMD_DENYOOM ) && zmalloc_used_memory ( ) > server . maxmemory ) { addReplyError ( c , ""commandnotallowedwhenusedmemory>\'maxmemory\'"" ) ; return REDIS_OK ; } if ( ( dictSize ( c -> pubsub_channels ) > 0 || listLength ( c -> pubsub_patterns ) > 0 ) && cmd -> proc != subscribeCommand && cmd -> proc != unsubscribeCommand && cmd -> proc != psubscribeCommand && cmd -> proc != punsubscribeCommand ) { addReplyError ( c , ""only(P)SUBSCRIBE/(P)UNSUBSCRIBE/QUITallowedinthiscontext"" ) ; return REDIS_OK ; } if ( server . masterhost && server . replstate != REDIS_REPL_CONNECTED && server . repl_serve_stale_data == 0 && cmd -> proc != infoCommand && cmd -> proc != slaveofCommand ) { addReplyError ( c , ""linkwithMASTERisdownandslave-serve-st
",0,511
324,"static int set_registers ( rtl8150_t * dev , u16 indx , u16 size , const void * data ) { void * buf ; int ret ; buf = kmemdup ( data , size , GFP_NOIO ) ; if ( ! buf ) return - ENOMEM ; ret = usb_control_msg ( dev -> udev , usb_sndctrlpipe ( dev -> udev , 0 ) , RTL8150_REQ_SET_REGS , RTL8150_REQT_WRITE , indx , 0 , buf , size , 500 ) ; kfree ( buf ) ; return ret ; }
",1,143
325,"static int gtco_probe ( struct usb_interface * usbinterface , const struct usb_device_id * id ) { struct gtco * gtco ; struct input_dev * input_dev ; struct hid_descriptor * hid_desc ; char * report ; int result = 0 , retry ; int error ; struct usb_endpoint_descriptor * endpoint ; gtco = kzalloc ( sizeof ( struct gtco ) , GFP_KERNEL ) ; input_dev = input_allocate_device ( ) ; if ( ! gtco || ! input_dev ) { dev_err ( & usbinterface -> dev , ""Nomorememory\\n"" ) ; error = - ENOMEM ; goto err_free_devs ; } gtco -> inputdevice = input_dev ; gtco -> usbdev = interface_to_usbdev ( usbinterface ) ; gtco -> intf = usbinterface ; gtco -> buffer = usb_alloc_coherent ( gtco -> usbdev , REPORT_MAX_SIZE , GFP_KERNEL , & gtco -> buf_dma ) ; if ( ! gtco -> buffer ) { dev_err ( & usbinterface -> dev , ""Nomorememoryforusbuffers\\n"" ) ; error = - ENOMEM ; goto err_free_devs ; } gtco -> urbinfo = usb_alloc_urb ( 0 , GFP_KERNEL ) ; if ( ! gtco -> urbinfo ) { dev_err ( & usbinterface -> dev , ""FailedtoallocateURB\\n"" ) ; error = - ENOMEM ; goto err_free_buf ; } endpoint = & usbinterface -> altsetting [ 0 ] . endpoint [ 0 ] . desc ; dev_dbg ( & usbinterface -> dev , ""gtco#interfaces:%d\\n"" , usbinterface -> num_altsetting ) ; dev_dbg ( & usbinterface -> dev , ""numendpoints:%d\\n"" , usbinterface -> cur_altsetting -> desc . bNumEndpoints ) ; dev_dbg ( & usbinterface -> dev , ""interfaceclass:%d\\n"" , usbinterface -> cur_altsetting -> desc . bInterfaceClass ) ; dev_dbg (
",0,511
326,"static void untrusted_launcher_response_callback ( GtkDialog * dialog , int response_id , ActivateParametersDesktop * parameters ) { GdkScreen * screen ; char * uri ; GFile * file ; switch ( response_id ) { case GTK_RESPONSE_OK : { file = nautilus_file_get_location ( parameters -> file ) ; nautilus_file_mark_desktop_file_executable ( file , parameters -> parent_window , TRUE , NULL , NULL ) ; nautilus_file_invalidate_all_attributes ( parameters -> file ) ; screen = gtk_widget_get_screen ( GTK_WIDGET ( parameters -> parent_window ) ) ; uri = nautilus_file_get_uri ( parameters -> file ) ; DEBUG ( ""Launchinguntrustedlauncher%s"" , uri ) ; nautilus_launch_desktop_file ( screen , uri , NULL , parameters -> parent_window ) ; g_free ( uri ) ; } break ; case GTK_RESPONSE_REJECTED : { file = nautilus_file_get_location ( parameters -> file ) ; nautilus_file_mark_desktop_file_executable ( file , parameters -> parent_window , TRUE , NULL , NULL ) ; nautilus_file_invalidate_all_attributes ( parameters -> file ) ; screen = gtk_widget_get_screen ( GTK_WIDGET ( parameters -> parent_window ) ) ; uri = nautilus_file_get_uri ( parameters -> file ) ; DEBUG ( ""Launchinguntrustedlauncher%s"" , uri ) ; nautilus_launch_desktop_file ( screen , uri , NULL , parameters -> parent_window ) ; g_free ( uri ) ; } break ; default : { } break ; } gtk_widget_destroy ( GTK_WIDGET ( dialog ) ) ; activate_parameters_desktop_free ( parameters ) ; }
",0,447
327,"static void edge_bulk_in_callback ( struct urb * urb ) { struct edgeport_port * edge_port = urb -> context ; struct device * dev = & edge_port -> port -> dev ; unsigned char * data = urb -> transfer_buffer ; int retval = 0 ; int port_number ; int status = urb -> status ; switch ( status ) { case 0 : break ; case - ECONNRESET : case - ENOENT : case - ESHUTDOWN : dev_dbg ( & urb -> dev -> dev , ""%s-urbshuttingdownwithstatus:%d\\n"" , __func__ , status ) ; return ; default : dev_err ( & urb -> dev -> dev , ""%s-nonzeroreadbulkstatusreceived:%d\\n"" , __func__ , status ) ; } if ( status == - EPIPE ) goto exit ; if ( status ) { dev_err ( & urb -> dev -> dev , ""%s-stoppingread
",0,226
328,"static struct cifsSesInfo * cifs_find_smb_ses ( struct TCP_Server_Info * server , struct smb_vol * vol ) { struct cifsSesInfo * ses ; write_lock ( & cifs_tcp_ses_lock ) ; list_for_each_entry ( ses , & server -> smb_ses_list ) { ses = list_entry ( tmp , struct cifsSesInfo , smb_ses_list ) ; if ( strncmp ( ses -> userName , vol -> username , MAX_USERNAME_SIZE ) ) continue ; if ( strlen ( vol -> username ) != 0 && strncmp ( ses -> password , vol -> password , MAX_PASSWORD_SIZE ) ) continue ; } ++ ses -> ses_count ; write_unlock ( & cifs_tcp_ses_lock ) ; return ses ; } write_unlock ( & cifs_tcp_ses_lock ) ; return NULL ; }
",1,231
329,"static vpx_codec_err_t vp8e_set_config ( vpx_codec_alg_priv_t * ctx , const vpx_codec_enc_cfg_t * cfg ) { vpx_codec_err_t res ; if ( ( ( cfg -> g_w != ctx -> cfg . g_w ) || ( cfg -> g_h != ctx -> cfg . g_h ) ) && ( cfg -> g_lag_in_frames > 1 || cfg -> g_pass != VPX_RC_ONE_PASS ) ) { ERROR ( ""Cannotchangewidthorheightafterinitialization"" ) ; if ( ( cfg -> g_lag_in_frames > 1 || cfg -> g_pass != VPX_RC_ONE_PASS ) ) ERROR ( ""Cannotincreaselag_in_frames"" ) ; res = validate_config ( ctx , cfg , & ctx -> vp8_cfg , 0 ) ; if ( ! res ) { ctx -> cfg = * cfg ; set_vp8e_config ( & ctx -> oxcf , ctx -> cfg , ctx -> vp8_cfg , NULL ) ; vp8_change_config ( ctx -> cpi , & ctx -> oxcf ) ; } return res ; }
",0,303
330,"static int cmd_mount ( void * data , const char * _input ) { ut64 off = 0 ; char * input , * oinput , * ptr , * ptr2 ; RList * list ; RListIter * iter ; RFSFile * file ; RFSRoot * root ; RFSPlugin * plug ; RFSPartition * part ; RCore * core = ( RCore * ) data ; if ( ! strncmp ( ""kdir"" , _input , 4 ) ) { return cmd_mkdir ( data , _input ) ; } if ( ! strncmp ( ""v"" , _input , 1 ) ) { return cmd_mv ( data , _input ) ; } input = oinput = strdup ( _input ) ; switch ( * input ) { case '' : input ++ ; if ( input [ 0 ] == '' ) { input ++ ; } ptr = strchr ( input , '' ) ; if ( ptr ) { * ptr = 0 ; ptr ++ ; ptr2 = strchr ( ptr , '' ) ; if ( ptr2 ) { * ptr2 = 0 ; off = r_num_math ( core -> num , ptr2 + 1 ) ; } if ( ! r_fs_mount ( core -> fs , ptr , input , off ) ) { eprintf ( ""Cannotmount%s\\n"" , input ) ; } } else { if ( ! ( ptr = r_fs_name ( core -> fs , core -> offset ) ) ) { eprintf ( ""Unknownfilesystemtype\\n"" ) ; } else if ( ! r_fs_mount ( core -> fs , ptr , input , core -> offset ) ) { eprintf ( ""Cannotmount%s\\n"" , input ) ; } free ( ptr ) ; } break ; case '-' : r_fs_umount ( core -> fs , input + 1 ) ; break ; case '*' : eprintf ( ""Listcommandsinradareformat\\n"" ) ; r_list_foreach ( core -> fs -> roots , iter , root ) { r_cons_printf ( ""m%s%s0x%"" PFMT64x ""\\n"" , root -> path , root -> p -> name , root -> delta ) ; } break ; case '\\0' : r_list_foreach ( core -> fs -> roots , iter , root ) { r
",0,511
331,"int hugetlb_reserve_pages ( struct inode * inode , long from , long to , struct vm_area_struct * vma , vm_flags_t vm_flags ) { long ret , chg ; struct hstate * h = hstate_inode ( inode ) ; struct hugepage_subpool * spool = subpool_inode ( inode ) ; if ( hugepage_subpool_get_pages ( spool , chg ) ) return - ENOSPC ; ret = hugetlb_acct_memory ( h , chg ) ; if ( ret < 0 ) { hugetlb_put_quota ( inode -> i_mapping , chg ) ; return ret ; } if ( ! vma || vma -> vm_flags & VM_MAYSHARE ) region_add ( & inode -> i_mapping -> private_list , from , to ) ; return 0 ; }
",1,205
332,"int install_thread_keyring_to_cred ( struct cred * new ) { struct key * keyring ; if ( new -> thread_keyring ) return 0 ; keyring = keyring_alloc ( ""_tid"" , new -> uid , new -> gid , new , KEY_POS_ALL | KEY_USR_VIEW , KEY_ALLOC_QUOTA_OVERRUN , NULL , NULL ) ; if ( IS_ERR ( keyring ) ) return PTR_ERR ( keyring ) ; new -> thread_keyring = keyring ; return 0 ; }
",1,129
333,"int sfgets ( void ) { struct pollfd pfd ; int pollret ; ssize_t readnb ; signed char seen_r = 0 ; size_t scanned ; static size_t readnbd ; if ( scanned > ( size_t ) 0U ) { readnbd -= scanned ; memmove ( cmd , cmd + scanned , readnbd ) ; scanned = ( size_t ) 0U ; } pfd . fd = clientfd ; # ifdef __APPLE_CC__ pfd . events = POLLIN | POLLERR | POLLHUP ; # else pfd . events = POLLIN | POLLPRI | POLLERR | POLLHUP ; # endif while ( scanned < cmdsize ) { if ( scanned >= readnbd ) { pfd . revents = 0 ; while ( ( pollret = poll ( & pfd , 1U , idletime * 1000UL ) ) < 0 && errno == EINTR ) ; if ( pollret == 0 ) { return - 1 ; } if ( pollret <= 0 || ( pfd . revents & ( POLLERR | POLLHUP | POLLNVAL ) ) != 0 ) { return - 2 ; } if ( ( pfd . revents & ( POLLIN | POLLPRI ) ) == 0 ) { continue ; } if ( readnbd >= cmdsize ) { break ; } # ifdef WITH_TLS if ( tls_cnx != NULL ) { while ( ( readnb = SSL_read ( tls_cnx , cmd + readnbd , cmdsize - readnbd ) ) < ( ssize_t ) 0 && errno == EINTR ) ; } else # endif { while ( ( readnb = read ( clientfd , cmd + readnbd , cmdsize - readnbd ) ) < ( ssize_t ) 0 && errno == EINTR ) ; } if ( readnb <= ( ssize_t ) 0 ) { return - 2 ; } readnbd += readnb ; if ( readnbd > cmdsize ) { return - 2 ; } } # ifdef RFC_CONFORMANT_LINES if ( seen_r != 0 ) { # endif if ( cmd [ scanned ] == '\\n' ) { # ifndef RFC_CONFORMANT_LINES if
",0,511
334,"mrb_value mrb_io_initialize_copy ( mrb_state * mrb , mrb_value copy ) { mrb_value orig ; mrb_value buf ; struct mrb_io * fptr_copy ; struct mrb_io * fptr_orig ; mrb_bool failed = TRUE ; mrb_get_args ( mrb , ""o"" , & orig ) ; fptr_orig = io_get_open_fptr ( mrb , orig ) ; fptr_copy = ( struct mrb_io * ) DATA_PTR ( copy ) ; if ( fptr_copy != NULL ) { fptr_finalize ( mrb , fptr_copy , FALSE ) ; mrb_free ( mrb , fptr_copy ) ; } fptr_copy = ( struct mrb_io * ) mrb_io_alloc ( mrb ) ; DATA_TYPE ( copy ) = & mrb_io_type ; DATA_PTR ( copy ) = fptr_copy ; buf = mrb_iv_get ( mrb , orig , mrb_intern_cstr ( mrb , ""@buf"" ) ) ; mrb_iv_set ( mrb , copy , mrb_intern_cstr ( mrb , ""@buf"" ) , buf ) ; fptr_copy -> fd = mrb_dup ( mrb , fptr_orig -> fd , & failed ) ; if ( failed ) { mrb_sys_fail ( mrb , 0 ) ; } mrb_fd_cloexec ( mrb , fptr_copy -> fd ) ; if ( fptr_orig -> fd2 != - 1 ) { fptr_copy -> fd2 = mrb_dup ( mrb , fptr_orig -> fd2 , & failed ) ; if ( failed ) { close ( fptr_copy -> fd ) ; mrb_sys_fail ( mrb , 0 ) ; } mrb_fd_cloexec ( mrb , fptr_copy -> fd2 ) ; } fptr_copy -> pid = fptr_orig -> pid ; fptr_copy -> readable = fptr_orig -> readable ; fptr_copy -> writable = fptr_orig -> writable ; fptr_copy -> sync = fptr_orig ->
",0,511
335,"struct key * key_get_instantiation_authkey ( key_serial_t target_id ) { char description [ 16 ] ; struct keyring_search_context ctx = { . index_key . type = & key_type_request_key_auth , . index_key . description = description , . cred = current_cred ( ) , . match_data . cmp = key_default_cmp , . match_data . raw_data = description , . match_data . lookup_type = KEYRING_SEARCH_LOOKUP_DIRECT , } ; struct key * authkey ; key_ref_t authkey_ref ; sprintf ( description , ""%x"" , target_id ) ; authkey_ref = search_process_keyrings ( & ctx ) ; if ( IS_ERR ( authkey_ref ) ) { authkey = ERR_CAST ( authkey_ref ) ; if ( authkey == ERR_PTR ( - EAGAIN ) ) authkey = ERR_PTR ( - ENOKEY ) ; goto error ; } authkey = key_ref_to_ptr ( authkey_ref ) ; if ( test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) { key_put ( authkey ) ; authkey = ERR_PTR ( - EKEYREVOKED ) ; } error : return authkey ; }
",1,315
336,"void vp9_frame_init_quantizer ( VP9_COMP * cpi ) { if ( cpi -> oxcf . pass == 2 ) { vp9_init_plane_quantizers ( cpi , & cpi -> mb ) ; } }
",0,60
337,"static TEE_Result tee_svc_copy_param ( struct tee_ta_session * sess , struct tee_ta_session * called_sess , struct utee_params * callee_params , struct tee_ta_param * param , void * tmp_buf_va [ TEE_NUM_PARAMS ] , struct mobj * * mobj_tmp ) { size_t n ; TEE_Result res ; size_t req_mem = 0 ; size_t s ; uint8_t * dst = 0 ; bool ta_private_memref [ TEE_NUM_PARAMS ] ; struct user_ta_ctx * utc = to_user_ta_ctx ( sess -> ctx ) ; void * va ; size_t dst_offs ; if ( ! callee_params ) { memset ( param , 0 , sizeof ( * param ) ) ; } else { res = tee_mmu_check_access_rights ( utc , TEE_MEMORY_ACCESS_READ | TEE_MEMORY_ACCESS_ANY_OWNER , ( uaddr_t ) callee_params , sizeof ( struct utee_params ) ) ; if ( res != TEE_SUCCESS ) return res ; memset ( param , 0 , sizeof ( * param ) ) ; } if ( called_sess && is_pseudo_ta_ctx ( called_sess -> ctx ) ) { return TEE_SUCCESS ; } for ( n = 0 ; n < TEE_NUM_PARAMS ; n ++ ) { ta_private_memref [ n ] = false ; switch ( TEE_PARAM_TYPE_GET ( param -> types , n ) ) { case TEE_PARAM_TYPE_MEMREF_INPUT : case TEE_PARAM_TYPE_MEMREF_OUTPUT : case TEE_PARAM_TYPE_MEMREF_INOUT : va = ( void * ) param -> u [ n ] . mem . offs ; s = param -> u [ n ] . mem . size ; if ( ! va ) { if ( s ) return TEE_ERROR_BAD_PARAMETERS ; break ; } if ( tee_mmu_is_vbuf_inside_ta_private ( utc ) ) return T
",0,511
338,"static int em_call_far ( struct x86_emulate_ctxt * ctxt ) { u16 sel , old_cs ; ulong old_eip ; int rc ; struct desc_struct old_desc , new_desc ; const struct x86_emulate_ops * ops = ctxt -> ops ; u8 cpl = ctxt -> ops -> cpl ( ctxt ) ; old_eip = ctxt -> _eip ; ops -> get_segment ( ctxt , & old_cs , & old_desc , NULL , VCPU_SREG_CS ) ; memcpy ( & sel , ctxt -> src . valptr + ctxt -> op_bytes , 2 ) ; rc = __load_segment_descriptor ( ctxt , sel , VCPU_SREG_CS , cpl , false , & new_desc ) ; if ( rc != X86EMUL_CONTINUE ) return rc ; rc = assign_eip_far ( ctxt , ctxt -> src . val , new_desc . l ) ; if ( rc != X86EMUL_CONTINUE ) goto fail ; ctxt -> src . val = old_cs ; rc = em_push ( ctxt ) ; if ( rc != X86EMUL_CONTINUE ) goto fail ; ctxt -> src . val = old_eip ; rc = em_push ( ctxt ) ; if ( rc != X86EMUL_CONTINUE ) goto fail ; ctxt -> src . val = old_eip ; return em_push ( ctxt ) ; }
",0,349
339,"int ff_jpeg2000_init_component ( Jpeg2000Component * comp , Jpeg2000CodingStyle * codsty , Jpeg2000QuantStyle * qntsty , int cbps , int dx , int dy , AVCodecContext * avctx ) { uint8_t log2_band_prec_width , log2_band_prec_height ; int reslevelno , bandno , gbandno = 0 , ret , i , j ; uint32_t csize ; if ( codsty -> nreslevels2decode <= 0 ) { av_log ( avctx , AV_LOG_ERROR , ""nreslevels2decode%dinvalidoruninitialized\\n"" , codsty -> nreslevels2decode ) ; return AVERROR_INVALIDDATA ; } if ( ret = ff_jpeg2000_dwt_init ( & comp -> dwt , comp -> coord , codsty -> nreslevels2decode - 1 , codsty -> transform ) ) return ret ; csize = ( comp -> coord [ 0 ] [ 1 ] - comp -> coord [ 0 ] [ 0 ] ) * ( comp -> coord [ 1 ] [ 1 ] - comp -> coord [ 1 ] [ 0 ] ) ; if ( codsty -> transform == FF_DWT97 ) { comp -> i_data = NULL ; comp -> f_data = av_malloc_array ( csize , sizeof ( * comp -> f_data ) ) ; if ( ! comp -> f_data ) return AVERROR ( ENOMEM ) ; } else { comp -> f_data = NULL ; comp -> i_data = av_malloc_array ( csize , sizeof ( * comp -> i_data ) ) ; if ( ! comp -> i_data ) return AVERROR ( ENOMEM ) ; } comp -> reslevel = av_malloc_array ( codsty -> nreslevels , sizeof ( * comp -> reslevel ) ) ; if ( ! comp -> reslevel ) return AVERROR ( ENOMEM ) ; for ( reslevelno = 0 ; reslevelno < codsty -> nreslevels ; reslevelno ++ ) { int declvl = codsty -> nreslevels - reslevelno ; Jpeg2000ResLevel * reslevel = comp -> reslevel + reslevelno ; for ( i = 0 ; i < 2 ; i
",0,511
340,"void Con_Dump_f ( void ) { int l , x , i ; short * line ; fileHandle_t f ; int bufferlen ; char * buffer ; char filename [ MAX_QPATH ] ; if ( Cmd_Argc ( ) != 2 ) { Com_Printf ( ""usage:condump<filename>\\n"" ) ; return ; } Q_strncpyz ( filename , Cmd_Argv ( 1 ) , sizeof ( filename ) ) ; COM_DefaultExtension ( filename , sizeof ( filename ) , "".txt"" ) ; if ( ! COM_CompareExtension ( filename , "".txt"" ) ) { Com_Printf ( ""Con_Dump_f:Onlythe\\"".txt\\""extensionissupportedbythiscommand
",0,168
341,"static RList * relocs ( RBinFile * arch ) { struct r_bin_bflt_obj * obj = ( struct r_bin_bflt_obj * ) arch -> o -> bin_obj ; RList * list = r_list_newf ( ( RListFree ) free ) ; int i , len , n_got , amount ; if ( ! list || ! obj ) { r_list_free ( list ) ; return NULL ; } if ( obj -> hdr -> flags & FLAT_FLAG_GOTPIC ) { n_got = get_ngot_entries ( obj ) ; if ( n_got ) { amount = n_got * sizeof ( struct reloc_struct_t ) ; if ( amount < n_reloc || amount > UT32_MAX ) { goto out_error ; } struct reloc_struct_t * got_table = calloc ( 1 , n_got * sizeof ( ut32 ) ) ; if ( got_table ) { ut32 offset = 0 ; for ( i = 0 ; i < n_got ; offset += 4 , i ++ ) { ut32 got_entry ; if ( obj -> hdr -> data_start + offset + 4 > obj -> size || obj -> hdr -> data_start + offset + 4 < offset ) { break ; } len = r_buf_read_at ( obj -> b , obj -> hdr -> data_start + offset , ( ut8 * ) & got_entry , sizeof ( ut32 ) ) ; if ( ! VALID_GOT_ENTRY ( got_entry ) || len != sizeof ( ut32 ) ) { break ; } got_table [ i ] . addr_to_patch = got_entry ; got_table [ i ] . data_offset = got_entry + BFLT_HDR_SIZE ; } obj -> n_got = n_got ; obj -> got_table = got_table ; } } } if ( obj -> hdr -> reloc_count > 0 ) { int n_reloc = obj -> hdr -> reloc_count ; amount = n_reloc * sizeof ( struct reloc_struct_t ) ; if ( amount < n_reloc || amount > UT32_MAX ) { goto out_error ; } struct reloc_struct_t * reloc_table = calloc
",0,511
342,"long do_rt_tgsigqueueinfo ( pid_t tgid , pid_t pid , int sig , siginfo_t * info ) { if ( pid <= 0 || tgid <= 0 ) return - EINVAL ; if ( info -> si_code != SI_QUEUE ) return - EPERM ; info -> si_signo = sig ; return do_send_specific ( tgid , pid , sig , info ) ; }
",0,101
343,"void opj_get_all_encoding_parameters ( const opj_image_t * p_image , const opj_cp_t * p_cp , OPJ_UINT32 tileno , OPJ_INT32 * p_tx0 , OPJ_INT32 * p_tx1 , OPJ_INT32 * p_ty0 , OPJ_INT32 * p_ty1 , OPJ_UINT32 * p_dx_min , OPJ_UINT32 * p_dy_min , OPJ_UINT32 * p_max_prec , OPJ_UINT32 * p_max_res , OPJ_UINT32 * * p_resolutions ) { OPJ_UINT32 compno , resno ; const opj_tcp_t * tcp = 00 ; const opj_tccp_t * l_tccp = 00 ; const opj_image_comp_t * l_img_comp = 00 ; OPJ_UINT32 * lResolutionPtr ; OPJ_UINT32 p , q ; assert ( p_cp != 00 ) ; assert ( p_image != 00 ) ; assert ( tileno < p_cp -> tw * p_cp -> th ) ; tcp = & p_cp -> tcps [ tileno ] ; l_tccp = tcp -> tccps ; l_img_comp = p_image -> comps ; p = tileno % p_cp -> tw ; q = tileno / p_cp -> tw ; * p_tx0 = ( OPJ_INT32 ) opj_uint_max ( p_cp -> tx0 + p * p_cp -> tdx , p_image -> x0 ) ; * p_tx1 = opj_int_min ( ( OPJ_INT32 ) ( p_cp -> tx0 + ( p + 1 ) * p_cp -> tdx , p_image -> x1 ) ; * p_ty0 = opj_int_max ( ( OPJ_INT32 ) ( p_cp -> ty0 + q * p_cp -> tdy , p_image -> y0 ) ; * p_ty1 = opj_int_min ( ( OPJ_INT32 ) ( p_cp -> ty0 + ( q + 1 ) *
",0,511
344,"static char * create_output_name ( unsigned char * fname , int lower , int isunix , int utf8 ) { unsigned char * p , * name , c , * fe , sep , slash ; unsigned int x ; sep = ( isunix ) ? '/' : '\\\\' ; slash = ( isunix ) ? '\\\\' : '/' ; x = strlen ( ( char * ) fname ) ; if ( utf8 ) x *= 3 * ( utf8 ) ; if ( dir ) x += strlen ( ( char * ) dir ) ; if ( ! ( name = ( unsigned char * ) malloc ( x + 2 ) ) ) { fprintf ( stderr , ""outofmemory
",0,159
345,"PHP_FUNCTION ( unserialize ) { char * buf = NULL ; size_t buf_len ; const unsigned char * p ; php_unserialize_data_t var_hash ; zval * options = NULL , * classes = NULL ; zval * retval ; HashTable * class_hash = NULL ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) , ""s|a"" , & buf , & buf_len , & options ) == FAILURE ) { RETURN_FALSE ; } if ( buf_len == 0 ) { RETURN_FALSE ; } p = ( const unsigned char * ) buf ; PHP_VAR_UNSERIALIZE_INIT ( var_hash ) ; if ( options != NULL ) { classes = zend_hash_str_find ( Z_ARRVAL_P ( options ) , ""allowed_classes"" , sizeof ( ""allowed_classes"" ) - 1 ) ; if ( classes && ( Z_TYPE_P ( classes ) == IS_ARRAY || ! zend_is_true ( classes ) ) ) { ALLOC_HASHTABLE ( class_hash ) ; zend_hash_init ( class_hash , ( Z_TYPE_P ( classes ) == IS_ARRAY ) ? zend_hash_num_elements ( Z_ARRVAL_P ( classes ) ) : 0 , NULL , NULL , 0 ) ; } if ( class_hash && Z_TYPE_P ( classes ) == IS_ARRAY ) { zval * entry ; zend_string * lcname ; ZEND_HASH_FOREACH_VAL ( Z_ARRVAL_P ( classes ) , entry ) { convert_to_string_ex ( entry ) ; lcname = zend_string_tolower ( Z_STR_P ( entry ) ) ; zend_hash_add_empty_element ( class_hash , lcname ) ; zend_string_release ( lcname ) ; } ZEND_HASH_FOREACH_END ( ) ; } } retval = var_tmp_var ( & var_hash ) ; if ( ! php_var_unserialize_ex ( retval , & p , p + buf_len , & var_hash , class_hash ) ) { PHP_VAR_
",0,511
346,"static int snd_timer_user_tselect ( struct file * file , struct snd_timer_select __user * _tselect ) { struct snd_timer_user * tu ; struct snd_timer_select tselect ; char str [ 32 ] ; int err = 0 ; tu = file -> private_data ; if ( tu -> timeri ) { snd_timer_close ( tu -> timeri ) ; tu -> timeri = NULL ; } if ( copy_from_user ( & tselect , _tselect , sizeof ( tselect ) ) ) { err = - EFAULT ; goto __err ; tu -> qhead = tu -> qtail = tu -> qused = 0 ; } sprintf ( str , ""application%i"" , current -> pid ) ; if ( tselect . id . dev_class != SNDRV_TIMER_CLASS_SLAVE ) tselect . id . dev_sclass = SNDRV_TIMER_SCLASS_APPLICATION ; err = snd_timer_open ( & tu -> timeri , str , & tselect . id , current -> pid ) ; if ( err < 0 ) goto __err ; kfree ( tu -> queue ) ; tu -> queue = NULL ; kfree ( tu -> tqueue ) ; tu -> tqueue = NULL ; if ( tu -> tread ) { tu -> tqueue = kmalloc ( tu -> queue_size * sizeof ( struct snd_timer_tread ) , GFP_KERNEL ) ; if ( tu -> tqueue == NULL ) err = - ENOMEM ; } else { tu -> queue = kmalloc ( tu -> queue_size * sizeof ( struct snd_timer_read ) , GFP_KERNEL ) ; if ( tu -> queue == NULL ) err = - ENOMEM ; } if ( err < 0 ) { snd_timer_close ( tu -> timeri ) ; tu -> timeri = NULL ; } else { tu -> timeri -> flags |= SNDRV_TIMER_IFLG_FAST ; tu -> timeri -> callback = tu -> tread ? snd_timer_user_tinterrupt : snd_timer_user_interrupt ; tu -> timeri -> ccallback = snd_timer_user_ccallback ; tu -> timeri -> callback_data = ( void *
",0,511
347,"GF_Err abst_box_read ( GF_Box * s , GF_BitStream * bs ) { GF_AdobeBootstrapInfoBox * ptr = ( GF_AdobeBootstrapInfoBox * ) s ; int i ; u32 tmp_strsize ; char * tmp_str ; GF_Err e ; ISOM_DECREASE_SIZE ( ptr , 25 ) ptr -> bootstrapinfo_version = gf_bs_read_u32 ( bs ) ; ptr -> profile = gf_bs_read_int ( bs , 2 ) ; ptr -> live = gf_bs_read_int ( bs , 1 ) ; ptr -> update = gf_bs_read_int ( bs , 1 ) ; ptr -> reserved = gf_bs_read_int ( bs , 4 ) ; ptr -> time_scale = gf_bs_read_u32 ( bs ) ; ptr -> current_media_time = gf_bs_read_u64 ( bs ) ; ptr -> smpte_time_code_offset = gf_bs_read_u64 ( bs ) ; i = 0 ; if ( ptr -> size < 8 ) return GF_ISOM_INVALID_FILE ; tmp_strsize = ( u32 ) ptr -> size - 8 ; tmp_str = gf_malloc ( sizeof ( char ) * tmp_strsize ) ; if ( ! tmp_str ) return GF_OUT_OF_MEM ; memset ( tmp_str , 0 , sizeof ( char ) * tmp_strsize ) ; while ( tmp_strsize ) { ISOM_DECREASE_SIZE ( ptr , 1 ) tmp_str [ i ] = gf_bs_read_u8 ( bs ) ; tmp_strsize -- ; if ( ! tmp_str [ i ] ) break ; i ++ ; } if ( i ) { ptr -> movie_identifier = gf_strdup ( tmp_str ) ; } ISOM_DECREASE_SIZE ( ptr , 1 ) ptr -> server_entry_count = gf_bs_read_u8 ( bs ) ; for ( i = 0 ; i < ptr -> server_entry_count ; i ++ ) { int j = 0 ; tmp_strsize = ( u32 ) ptr -> size ; if
",0,511
348,"vpx_fixed_buf_t * vpx_codec_get_global_headers ( vpx_codec_ctx_t * ctx ) { vpx_fixed_buf_t * buf = NULL ; if ( ctx ) { if ( ! ctx -> iface || ! ctx -> priv ) ctx -> err = VPX_CODEC_ERROR ; else if ( ! ( ctx -> iface -> caps & VPX_CODEC_CAP_ENCODER ) ) ctx -> err = VPX_CODEC_INCAPABLE ; else if ( ! ctx -> iface -> enc . get_glob_hdrs ) ctx -> err = VPX_CODEC_INCAPABLE ; else buf = ctx -> iface -> enc . get_glob_hdrs ( get_alg_priv ( ctx ) ) ; } return buf ; }
",1,198
349,"int main ( int argc , char * * cargv ) { uschar * * argv = USS cargv ; int arg_receive_timeout = - 1 ; int arg_smtp_receive_timeout = - 1 ; int arg_error_handling = error_handling ; int filter_sfd = - 1 ; int filter_ufd = - 1 ; int group_count ; int i , rv ; int list_queue_option = 0 ; int msg_action = 0 ; int msg_action_arg = - 1 ; int namelen = ( argv [ 0 ] == NULL ) ? 0 : Ustrlen ( argv [ 0 ] ) ; int queue_only_reason = 0 ; # ifdef EXIM_PERL int perl_start_option = 0 ; # endif int recipients_arg = argc ; int sender_address_domain = 0 ; int test_retry_arg = - 1 ; int test_rewrite_arg = - 1 ; BOOL arg_queue_only = FALSE ; BOOL bi_option = FALSE ; BOOL checking = FALSE ; BOOL count_queue = FALSE ; BOOL expansion_test = FALSE ; BOOL extract_recipients = FALSE ; BOOL flag_G = FALSE ; BOOL flag_n = FALSE ; BOOL forced_delivery = FALSE ; BOOL f_end_dot = FALSE ; BOOL deliver_give_up = FALSE ; BOOL list_queue = FALSE ; BOOL list_options = FALSE ; BOOL list_config = FALSE ; BOOL local_queue_only ; BOOL more = TRUE ; BOOL one_msg_action = FALSE ; BOOL opt_D_used = FALSE ; BOOL queue_only_set = FALSE ; BOOL receiving_message = TRUE ; BOOL sender_ident_set = FALSE ; BOOL session_local_queue_only ; BOOL unprivileged ; BOOL removed_privilege = FALSE ; BOOL usage_wanted = FALSE ; BOOL verify_address_mode = FALSE ; BOOL verify_as_sender = FALSE ; BOOL version_printed = FALSE ; uschar * alias_arg = NULL ; uschar * called_as = US """" ; uschar * cmdline_syslog_name = NULL ; uschar * start_queue_run_id = NULL ; uschar * stop_queue
",0,511
350,"long do_rt_tgsigqueueinfo ( pid_t tgid , pid_t pid , int sig , siginfo_t * info ) { if ( pid <= 0 || tgid <= 0 ) return - EINVAL ; if ( info -> si_code != SI_QUEUE ) return - EPERM ; info -> si_signo = sig ; return do_send_specific ( tgid , pid , sig , info ) ; }
",0,101
351,"static void parse_content_range ( URLContext * h , const char * p ) { HTTPContext * s = h -> priv_data ; const char * slash ; if ( ! strncmp ( p , ""bytes"" , 6 ) ) { p += 6 ; s -> off = strtoull ( p , NULL , 10 ) ; if ( ( slash = strchr ( p , '/' ) ) && strlen ( slash ) > 0 ) s -> filesize = strtoull ( slash + 1 , NULL , 10 ) ; } if ( s -> seekable == - 1 && ( ! s -> is_akamai || s -> filesize != 2147483647 ) ) h -> is_streamed = 0 ; }
",1,159
352,"static void sycc422_to_rgb ( opj_image_t * img ) { int * d0 , * d1 , * d2 , * r , * g , * b ; const int * y , * cb , * cr ; size_t maxw , maxh , max , offx , loopmaxw , offy , loopmaxh ; int offset , upb ; size_t i ; upb = ( int ) img -> comps [ 0 ] . prec ; offset = 1 << ( upb - 1 ) ; upb = ( 1 << upb ) - 1 ; maxw = ( size_t ) img -> comps [ 0 ] . w ; maxh = ( size_t ) img -> comps [ 0 ] . h ; max = maxw * maxh ; y = img -> comps [ 0 ] . data ; cb = img -> comps [ 1 ] . data ; cr = img -> comps [ 2 ] . data ; d0 = r = ( int * ) malloc ( sizeof ( int ) * max ) ; d1 = g = ( int * ) malloc ( sizeof ( int ) * max ) ; d2 = b = ( int * ) malloc ( sizeof ( int ) * max ) ; if ( r == NULL || g == NULL || b == NULL ) goto fails ; offx = img -> x0 & 1U ; loopmaxw = maxw - offx ; offy = img -> y0 & 1U ; for ( i = 0U ; i < maxh ; ++ i ) { size_t j ; if ( offy > 0U ) { sycc_to_rgb ( offset , upb , * y , 0 , 0 , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; } for ( j = 0U ; j < ( loopmaxw & ~ ( unsigned int ) 1U ) ; j += 2U ) { sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; sycc_to_rgb ( offset , upb , * y , * cb , * cr , r , g , b ) ; ++ y ; ++ r ; ++ g ; ++ b ; ++ cb ; ++ cr ;
",0,511
353,"int nfs4_state_set_mode_locked ( struct nfs4_state * state , fmode_t mode ) { if ( state -> state == mode ) return nfs4_list_move ( & state -> open_states , & state -> owner -> so_states ) ; else list_move_tail ( & state -> open_states , & state -> owner -> so_states ) ; } state -> state = mode ; return 0 ; }
",0,99
354,"int kex_input_kexinit ( int type , u_int32_t seq , void * ctxt ) { struct ssh * ssh = ctxt ; struct kex * kex = ssh -> kex ; const u_char * ptr ; u_int i ; size_t dlen ; int r ; debug ( ""SSH2_MSG_KEXINITreceived"" ) ; if ( kex == NULL ) return SSH_ERR_INVALID_ARGUMENT ; ssh_dispatch_set ( ssh , SSH2_MSG_KEXINIT , NULL ) ; ptr = sshpkt_ptr ( ssh , & dlen ) ; if ( ( r = sshbuf_put ( kex -> peer , ptr , dlen ) ) != 0 ) return r ; for ( i = 0 ; i < KEX_COOKIE_LEN ; i ++ ) if ( ( r = sshpkt_get_u8 ( ssh , NULL ) ) != 0 ) return r ; for ( i = 0 ; i < PROPOSAL_MAX ; i ++ ) if ( ( r = sshpkt_get_string ( ssh , NULL , NULL ) ) != 0 ) return r ; if ( ( r = sshpkt_get_u8 ( ssh , NULL ) ) != 0 || ( r = sshpkt_get_u32 ( ssh , NULL ) ) != 0 || ( r = sshpkt_get_end ( ssh ) ) != 0 ) return r ; if ( ! ( kex -> flags & KEX_INIT_SENT ) ) if ( ( r = kex_send_kexinit ( ssh ) ) != 0 ) return r ; if ( ( r = kex_choose_conf ( ssh ) ) != 0 ) return r ; if ( kex -> kex_type < KEX_MAX && kex -> kex [ kex -> kex_type ] != NULL ) return ( kex -> kex [ kex -> kex_type ] ) ( ssh ) ; return SSH_ERR_INTERNAL_ERROR ; }
",1,456
355,"static void test_modules ( ) { assert_true_rule ( ""import\\""tests\\""\\\nruletest{\\\ncondition:tests.constants.one+1==tests.constants.two\\\n}"" , NULL ) ; assert_true_rule ( ""import\\""tests\\""\\\nruletest{\\\ncondition:tests.constants.foo==\\""foo\\""\\\n}"" , NULL ) ; assert_true_rule ( ""import\\""tests\\""\\\nruletest{\\\ncondition:tests.constants.empty==\\""\\""\\\n}"" , NULL ) ; assert_true_rule ( ""import\\""tests\\""\\\nruletest{\\\ncondition:tests.empty()==\\""\\""\\\n}"" , NULL ) ; assert_true_rule ( ""import\\""tests\\""\\\nruletest{\\\ncondition:tests.struct_array[1].i==1\\\n}"" , NULL ) ; assert_true_rule ( ""import\\""tests\\""\\\nruletest{\\\ncondition:tests.struct_array[0].i==1ortrue\\\n}"" , NULL ) ; assert_true_rule ( ""import\\""tests\\""\\\nruletest{\\\ncondition:tests.integer_array[0]==0\\\n}"" , NULL ) ; assert_true_rule ( ""import\\""tests\\""\\\nruletest{\\\ncondition:tests.integer_array[1]==1\\\n}"" , NULL ) ; assert_true_rule ( ""import\\""tests\\""\\\nruletest{\\\ncondition:tests.string_array[0]==\\""foo\\""\\\n}"" , NULL ) ; assert_true_rule ( ""import\\""tests\\""\\\nruletest{\\\ncondition:tests.string_array[2]==\\""baz\\""\\\n}"" , NULL ) ; assert_true_rule ( ""import\\""tests\\""\\\nruletest{\\\ncondition:tests.string_dict[\\""foo\\""]==\\""foo\\
",0,511
356,"static Image * ReadPWPImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { FILE * file ; Image * image , * next_image , * pwp_image ; ImageInfo * read_info ; int c , unique_file ; MagickBooleanType status ; register Image * p ; register ssize_t i ; size_t filesize , length ; ssize_t count ; unsigned char magick [ MaxTextExtent ] ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; pwp_image = AcquireImage ( image_info ) ; image = pwp_image ; status = OpenBlob ( image_info , pwp_image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) return ( ( Image * ) NULL ) ; count = ReadBlob ( pwp_image , 5 , magick ) ; if ( ( count != 5 ) || ( LocaleNCompare ( ( char * ) magick , ""SFW95"" , 5 ) != 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; read_info = CloneImageInfo ( image_info ) ; ( void ) SetImageInfoProgressMonitor ( read_info , ( MagickProgressMonitor ) NULL , ( void * ) NULL ) ; SetImageInfoBlob ( read_info , ( void * ) NULL , 0 ) ; unique_file = AcquireUniqueFileResource ( read_info -> filename ) ; for ( ; ; ; ) { for ( c = ReadBlobByte ( pwp_image ) ; c != EOF ; c = ReadBlobByte ( pwp_image ) ) { for ( i = 0 ; i < 17 ; i ++ ) magick [ i ] = magick [ i + 1 ] ; magick [ 17 ] = ( unsigned char ) c ; if ( LocaleNCompare ( ( char * ) ( magick + 12 ) , ""SFW94A"" , 6 ) == 0 )
",0,511
357,"int main ( int argc , char * * argv ) { test_cmp_parameters inParam ; FILE * fbase = NULL , * ftest = NULL ; int same = 0 ; char lbase [ 512 ] ; char strbase [ 256 ] ; char ltest [ 256 ] ; char strtest [ 256 ] ; if ( parse_cmdline_cmp ( argc , argv , & inParam ) == 1 ) { compare_dump_files_help_display ( ) ; goto cleanup ; } printf ( ""******Parameters*********\\n"" ) ; printf ( ""base_filename=%s\\n"" ""test_filename=%s\\n"" , inParam . base_filename , inParam . test_filename ) ; printf ( ""*************************\\n"" ) ; printf ( ""Trytoopen:%sforreading..."" , inParam . base_filename ) ; if ( ( fbase = fopen ( inParam . base_filename , ""rb"" ) ) == NULL ) { goto cleanup ; } printf ( ""Ok.\\n"" ) ; printf ( ""Trytoopen:%sforreading..."" , inParam . test_filename ) ; if ( ( ftest = fopen ( inParam . test_filename , ""rb"" ) ) == NULL ) { goto cleanup ; } printf ( ""Ok.\\n"" ) ; while ( fgets ( lbase , ""%511[^\\r\\n]"" , strtest ) ) { int nbase = sscanf ( lbase , ""%255[^\\r\\n]"" , strtest ) ; int ntest = sscanf ( ltest , ""%255[^\\r\\n]"" , strtest ) ; assert ( nbase != 255 && ntest != 255 ) ; if ( nbase != 1 || ntest != 1 ) { fprintf ( stderr , ""couldnotparselinefromfiles\\n"" ) ; goto cleanup ; } if ( strcmp ( strbase , strtest ) != 0 ) { fprintf ( stderr , ""<%s>vs.<%s>\\n"" , strbase , strtest ) ; goto cleanup ; } } same = 1 ; printf ( ""\\n*****TESTSUCCEED:Filesarethesame.*****\\n"" ) ; cleanup : if ( fbase ) fclose ( fbase ) ; if ( ftest ) fclose (
",0,511
358,"static int cdc_ncm_bind ( struct usbnet * dev , struct usb_interface * intf ) { if ( cdc_ncm_select_altsetting ( intf ) != CDC_NCM_COMM_ALTSETTING_NCM ) return - ENODEV ; return cdc_ncm_bind_common ( dev , intf , CDC_NCM_DATA_ALTSETTING_NCM , 0 ) ; }
",1,101
359,"static size_t send_control_msg ( VirtIOSerial * vser , void * buf , size_t len ) { VirtQueueElement elem ; VirtQueue * vq ; vq = vser -> c_ivq ; if ( ! virtio_queue_ready ( vq ) ) { return 0 ; } if ( ! virtqueue_pop ( vq , & elem ) ) { return 0 ; } memcpy ( elem . in_sg [ 0 ] . iov_base , buf , len ) ; virtqueue_push ( vq , & elem , len ) ; virtio_notify ( VIRTIO_DEVICE ( vser ) , vq ) ; return len ; }
",0,156
360,"static int jpc_qcd_dumpparms ( jpc_ms_t * ms , FILE * out ) { jpc_qcd_t * qcd = & ms -> parms . qcd ; int i ; fprintf ( out , ""qntsty=%d;numguard=%d;numstepsizes=%d\\n"" , ( int ) qcd -> compparms . qntsty , qcd -> compparms . numguard , qcd -> compparms . numstepsizes ) ; for ( i = 0 ; i < qcd -> compparms . numstepsizes ; ++ i ) { fprintf ( out , ""expn[%d]=0x%04x;mant[%d]=0x%04x;\\n"" , i , ( unsigned ) JPC_QCX_GETEXPN ( qcd -> compparms . stepsizes [ i ] ) , i , ( unsigned ) JPC_QCX_GETMANT ( qcd -> compparms . stepsizes [ i ] ) ) ; } return 0 ; }
",0,239
361,"static int check_entry_size_and_hooks ( struct ip6t_entry * e , struct xt_table_info * newinfo , const unsigned char * base , const unsigned char * limit , const unsigned int * hook_entries , const unsigned int * underflows , unsigned int valid_hooks ) { unsigned int h ; int err ; if ( ( unsigned long ) e % __alignof__ ( struct ip6t_entry ) != 0 || ( unsigned char * ) e + sizeof ( struct ip6t_entry ) >= limit || ( unsigned char * ) e + e -> next_offset > limit ) { duprintf ( ""Badoffset%p\\n"" , e ) ; return - EINVAL ; } if ( e -> next_offset < sizeof ( struct ip6t_entry ) + sizeof ( struct xt_entry_target ) ) { duprintf ( ""checking:element%psize%u\\n"" , e , e -> elems , e -> next_offset ) ; return - EINVAL ; } if ( ! ip6_checkentry ( & e -> ipv6 ) ) return - EINVAL ; err = xt_check_entry_offsets ( e , e -> target_offset , e -> next_offset ) ; if ( err ) return err ; for ( h = 0 ; h < NF_INET_NUMHOOKS ; h ++ ) { if ( ! ( valid_hooks & ( 1 << h ) ) ) continue ; if ( ( unsigned char * ) e - base == hook_entries [ h ] ) newinfo -> hook_entry [ h ] = hook_entries [ h ] ; if ( ( unsigned char * ) e - base == underflows [ h ] ) { if ( ! check_underflow ( e ) ) { pr_debug ( ""Underflowsmustbeunconditionaland"" ""usetheSTANDARDtargetwith"" ""ACCEPT/DROP\\n"" ) ; return - EINVAL ; } newinfo -> underflow [ h ] = underflows [ h ] ; } } e -> counters = ( ( struct xt_counters ) { 0 , 0 } ) ; e -> comefrom = 0 ; return 0 ; }
",1,480
362,"static int cdxl_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * pkt ) { CDXLVideoContext * c = avctx -> priv_data ; AVFrame * const p = data ; int ret , w , h , encoding , aligned_width , buf_size = pkt -> size ; const uint8_t * buf = pkt -> data ; if ( buf_size < 32 ) return AVERROR_INVALIDDATA ; encoding = buf [ 1 ] & 7 ; c -> format = buf [ 1 ] & 0xE0 ; w = AV_RB16 ( & buf [ 14 ] ) ; h = AV_RB16 ( & buf [ 16 ] ) ; c -> bpp = buf [ 19 ] ; c -> palette_size = AV_RB16 ( & buf [ 20 ] ) ; c -> palette = buf + 32 ; c -> video = c -> palette + c -> palette_size ; c -> video_size = buf_size - c -> palette_size - 32 ; if ( c -> palette_size > 512 ) return AVERROR_INVALIDDATA ; if ( buf_size < c -> palette_size + 32 ) return AVERROR_INVALIDDATA ; if ( c -> bpp < 1 ) return AVERROR_INVALIDDATA ; if ( c -> format != BIT_PLANAR && c -> format != BIT_LINE && c -> format != CHUNKY ) { avpriv_request_sample ( avctx , ""Pixelformat0x%0x"" , c -> format ) ; return AVERROR_PATCHWELCOME ; } if ( ( ret = ff_set_dimensions ( avctx , w , h ) ) < 0 ) return ret ; if ( c -> format == CHUNKY ) aligned_width = avctx -> width ; else aligned_width = FFALIGN ( c -> avctx -> width , 16 ) ; c -> padded_bits = aligned_width - c -> avctx -> width ; if ( c -> video_size < aligned_width * avctx -> height * ( int64_t ) c -> bpp / 8 ) return AVERROR_INVALIDDATA ; if ( ! encoding && c -> palette_size && c -> bpp <= 8 && c -> format != CHUNKY ) { av
",0,511
363,"int ethertype_print ( netdissect_options * ndo , u_short ether_type , const u_char * p , u_int length , u_int caplen , const struct lladdr_info * src , const struct lladdr_info * dst ) { switch ( ether_type ) { case ETHERTYPE_IP : ip_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_IPV6 : ip6_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_ARP : case ETHERTYPE_REVARP : arp_print ( ndo , p , length , caplen ) ; return ( 1 ) ; case ETHERTYPE_DN : decnet_print ( ndo , p , length , caplen ) ; return ( 1 ) ; case ETHERTYPE_ATALK : if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""et1"" ) ) ; atalk_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_AARP : aarp_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_IPX : ND_PRINT ( ( ndo , ""(NOV-ETHII)"" ) ) ; ipx_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_ISO : if ( length == 0 || caplen == 0 ) { ND_PRINT ( ( ndo , ""[|osi]"" ) ) ; return ( 1 ) ; } isoclns_print ( ndo , p + 1 , length - 1 ) ; return ( 1 ) ; case ETHERTYPE_PPPOED : case ETHERTYPE_PPPOES : case ETHERTYPE_PPPOED2 : case ETHERTYPE_PPPOES2 : pppoe_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_EAPOL : eap_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_RRCP : rrcp_print ( ndo , p , length , src , dst ) ; return ( 1 ) ; case ETHERTYPE_PPP : if ( length ) { p [ 0 ] = '\\
",0,511
364,"static void queue_delete ( struct snd_seq_queue * q ) { mutex_lock ( & q -> timer_mutex ) ; snd_seq_timer_stop ( q -> timer ) ; snd_seq_timer_close ( q ) ; mutex_unlock ( & q -> timer_mutex ) ; snd_use_lock_sync ( & q -> use_lock ) ; snd_seq_prioq_delete ( & q -> tickq ) ; snd_seq_prioq_delete ( & q -> timeq ) ; snd_seq_timer_delete ( & q -> timer ) ; kfree ( q ) ; }
",1,148
365,"static int fallocate_chunk ( struct inode * inode , loff_t offset , loff_t len , int mode ) { struct gfs2_inode * ip = GFS2_I ( inode ) ; struct buffer_head * dibh ; int error ; unsigned int nr_blks ; sector_t lblock = offset >> inode -> i_blkbits ; error = gfs2_meta_inode_buffer ( ip , & dibh ) ; if ( unlikely ( error ) ) goto out ; gfs2_trans_add_bh ( ip -> i_gl , dibh , 1 ) ; if ( gfs2_is_stuffed ( ip ) ) { error = gfs2_unstuff_dinode ( ip , NULL ) ; if ( unlikely ( error ) ) goto out ; } gfs2_trans_add_bh ( ip -> i_gl , dibh , 1 ) ; if ( gfs2_is_stuffed ( ip ) ) { error = gfs2_unstuff_dinode ( ip , NULL ) ; if ( unlikely ( error ) ) goto out ; } curr = start ; offset = start << PAGE_CACHE_SHIFT ; from = start_offset ; to = PAGE_CACHE_SIZE ; while ( curr <= end ) { page = grab_cache_page_write_begin ( inode -> i_mapping , curr , AOP_FLAG_NOFS ) ; if ( unlikely ( ! page ) ) { error = - ENOMEM ; goto out ; } if ( curr == end ) to = end_offset ; error = write_empty_blocks ( page , from , to , mode ) ; if ( ! error && offset + to > inode -> i_size && ! ( mode & FALLOC_FL_KEEP_SIZE ) ) { i_size_write ( inode , offset + to ) ; } unlock_page ( page ) ; page_cache_release ( page ) ; if ( error ) goto out ; curr ++ ; offset += PAGE_CACHE_SIZE ; from = 0 ; } mark_inode_dirty ( inode ) ; brelse ( dibh ) ; error = gfs2_block_inode ( inode , offset ) ; if (
",0,505
366,"static void * vips_foreign_load_start ( VipsImage * out , void * a , void * b ) { VipsForeignLoad * load = VIPS_FOREIGN_LOAD ( b ) ; VipsForeignLoadClass * class = VIPS_FOREIGN_LOAD_GET_CLASS ( load ) ; if ( load -> error ) return ( NULL ) ; if ( ! load -> real ) { if ( ! ( load -> real = vips_foreign_load_temp ( load ) ) ) return ( NULL ) ; # ifdef DEBUG printf ( ""vips_foreign_load_start:triggering->load()\\n"" ) ; # endif load -> real -> progress_signal = load -> out ; g_object_set_qdata ( G_OBJECT ( load -> real ) , vips__foreign_load_operation , load ) ; if ( class -> load ( load ) || vips_image_pio_input ( load -> real ) ) return ( NULL ) ; if ( ! vips_foreign_load_iscompat ( load -> real , out ) ) return ( NULL ) ; vips_image_pipelinev ( load -> out , load -> out -> dhint , load -> real , NULL ) ; } return ( vips_region_new ( load -> real ) ) ; }
",0,286
367,"static int fit_image_verify_sig ( const void * fit , int image_noffset , const char * data , size_t size , const void * sig_blob , int sig_offset ) { int noffset ; char * err_msg = """" ; int verified = 0 ; int ret ; fdt_for_each_subnode ( noffset , fit , image_noffset ) { const char * name = fit_get_name ( fit , noffset , NULL ) ; if ( name == NULL ) { ret = fit_image_check_sig ( fit , noffset , data , size , - 1 , & err_msg ) ; if ( ret ) { puts ( ""-"" ) ; } else { puts ( ""+"" ) ; verified = 1 ; break ; } } } if ( noffset == - FDT_ERR_TRUNCATED || noffset == - FDT_ERR_BADSTRUCTURE ) { err_msg = ""Corruptedortruncatedtree"" ; goto error ; } return verified ? 0 : - EPERM ; error : printf ( ""error
",0,246
368,"int xfs_attr3_leaf_list_int ( struct xfs_buf * bp , struct xfs_attr_list_context * context ) { struct attrlist_cursor_kern * cursor ; struct xfs_attr_leafblock * leaf ; struct xfs_attr3_icleaf_hdr ichdr ; struct xfs_attr_leaf_entry * entries ; struct xfs_attr_leaf_entry * entry ; int retval ; int i ; struct xfs_mount * mp = context -> dp -> i_mount ; trace_xfs_attr_list_leaf ( context ) ; leaf = bp -> b_addr ; xfs_attr3_leaf_hdr_from_disk ( mp -> m_attr_geo , & ichdr , leaf ) ; entries = xfs_attr3_leaf_entryp ( leaf ) ; cursor = context -> cursor ; cursor -> initted = 1 ; if ( context -> resynch ) { entry = & entries [ 0 ] ; for ( i = 0 ; i < ichdr . count ; entry ++ , i ++ ) { if ( be32_to_cpu ( entry -> hashval ) == cursor -> hashval ) { if ( cursor -> offset == context -> dupcnt ) { context -> dupcnt = 0 ; break ; } context -> dupcnt ++ ; } else if ( be32_to_cpu ( entry -> hashval ) > cursor -> hashval ) { context -> dupcnt = 0 ; break ; } } if ( i == ichdr . count ) { trace_xfs_attr_list_notfound ( context ) ; return 0 ; } } else { entry = & entries [ 0 ] ; i = 0 ; } context -> resynch = 0 ; retval = 0 ; for ( ; i < ichdr . count ; entry ++ , i ++ ) { if ( be32_to_cpu ( entry -> hashval ) != cursor -> hashval ) { cursor -> hashval = be32_to_cpu ( entry -> hashval ) ; cursor -> offset = 0 ; } if ( entry -> flags & XFS_ATTR_INCOMPLETE ) continue ; if ( entry -> flags & XFS_ATTR_LOCAL ) { xfs_attr_leaf_name_local_t * name_loc = xfs_attr
",0,511
369,"int cx23888_ir_probe ( struct cx23885_dev * dev ) { struct cx23888_ir_state * state ; struct v4l2_subdev * sd ; struct v4l2_subdev_ir_parameters default_params ; int ret ; state = kzalloc ( sizeof ( struct cx23888_ir_state ) , GFP_KERNEL ) ; if ( state == NULL ) return - ENOMEM ; spin_lock_init ( & state -> rx_kfifo_lock ) ; if ( kfifo_alloc ( & state -> rx_kfifo , CX23888_IR_RX_KFIFO_SIZE , GFP_KERNEL ) ) return - ENOMEM ; state -> dev = dev ; sd = & state -> sd ; v4l2_subdev_init ( sd , & cx23888_ir_controller_ops ) ; v4l2_set_subdevdata ( sd , state ) ; snprintf ( sd -> name , sizeof ( sd -> name ) , ""%s/888-ir"" , dev -> name ) ; sd -> grp_id = CX23885_HW_888_IR ; ret = v4l2_device_register_subdev ( & dev -> v4l2_dev , sd ) ; if ( ret == 0 ) { cx23888_ir_write4 ( dev , CX23888_IR_IRQEN_REG , 0 ) ; mutex_init ( & state -> rx_params_lock ) ; default_params = default_rx_params ; v4l2_subdev_call ( sd , ir , rx_s_parameters , & default_params ) ; mutex_init ( & state -> tx_params_lock ) ; default_params = default_tx_params ; v4l2_subdev_call ( sd , ir , tx_s_parameters , & default_params ) ; } else { kfifo_free ( & state -> rx_kfifo ) ; } return ret ; }
",0,460
370,"int nfc_llcp_send_connect ( struct nfc_llcp_sock * sock ) { struct nfc_llcp_local * local ; struct sk_buff * skb ; u8 * service_name_tlv = NULL , service_name_tlv_length ; u8 * miux_tlv = NULL , miux_tlv_length ; u8 * rw_tlv = NULL , rw_tlv_length , rw ; int err ; u16 size = 0 ; __be16 miux ; pr_debug ( ""SendingCONNECT\\n"" ) ; local = sock -> local ; if ( local == NULL ) return - ENODEV ; if ( sock -> service_name != NULL ) { service_name_tlv = nfc_llcp_build_tlv ( LLCP_TLV_SN , sock -> service_name , sock -> service_name_len , & service_name_tlv_length ) ; if ( ! service_name_tlv ) { err = - ENOMEM ; goto error_tlv ; } size += service_name_tlv_length ; } miux = be16_to_cpu ( sock -> miux ) > LLCP_MAX_MIUX ? local -> miux : sock -> miux ; rw = sock -> rw > LLCP_MAX_RW ? local -> rw : sock -> rw ; miux_tlv = nfc_llcp_build_tlv ( LLCP_TLV_MIUX , ( u8 * ) & miux , 0 , & miux_tlv_length ) ; if ( ! miux_tlv ) { err = - ENOMEM ; goto error_tlv ; } size += miux_tlv_length ; rw_tlv = nfc_llcp_build_tlv ( LLCP_TLV_RW , & rw , 0 , & rw_tlv_length ) ; if ( ! rw_tlv ) { err = - ENOMEM ; goto error_tlv ; } size += rw_tlv_length ; pr_debug ( ""SKBsize%dSNlength%zu\\n"" , size , sock -> service_name_len ) ; skb = llcp_allocate_pdu ( sock , LLC
",0,511
371,"struct monitor * monitor_init ( void ) { struct monitor * mon ; mon = xcalloc ( 1 , sizeof ( * mon ) ) ; monitor_openfds ( mon , 1 ) ; if ( options . compression ) { mon -> m_zback = mm_create ( NULL , MM_MEMSIZE ) ; mon -> m_zlib = mm_create ( mon -> m_zback , 20 * MM_MEMSIZE ) ; ssh_packet_set_compress_hooks ( ssh , mon -> m_zlib , ( ssh_packet_comp_alloc_func * ) mm_zalloc , ( ssh_packet_comp_free_func * ) mm_zfree ) ; } return mon ; }
",0,160
372,"vpx_codec_err_t vpx_codec_dec_init_ver ( vpx_codec_ctx_t * ctx , vpx_codec_iface_t * iface , vpx_codec_dec_cfg_t * cfg , vpx_codec_flags_t flags , int ver ) { vpx_codec_err_t res ; if ( ver != VPX_DECODER_ABI_VERSION ) res = VPX_CODEC_ABI_MISMATCH ; else if ( ! ctx || ! iface ) res = VPX_CODEC_INVALID_PARAM ; else if ( iface -> abi_version != VPX_CODEC_INTERNAL_ABI_VERSION ) res = VPX_CODEC_ABI_MISMATCH ; else if ( ( flags & VPX_CODEC_USE_XMA ) && ! ( iface -> caps & VPX_CODEC_CAP_XMA ) ) res = VPX_CODEC_INCAPABLE ; else if ( ( flags & VPX_CODEC_USE_POSTPROC ) && ! ( iface -> caps & VPX_CODEC_CAP_POSTPROC ) ) res = VPX_CODEC_INCAPABLE ; else if ( ( flags & VPX_CODEC_USE_ERROR_CONCEALMENT ) && ! ( iface -> caps & VPX_CODEC_CAP_ERROR_CONCEALMENT ) ) res = VPX_CODEC_INCAPABLE ; else if ( ( flags & VPX_CODEC_USE_INPUT_FRAGMENTS ) && ! ( iface -> caps & VPX_CODEC_CAP_INPUT_FRAGMENTS ) ) res = VPX_CODEC_INCAPABLE ; else if ( ! ( iface -> caps & VPX_CODEC_CAP_DECODER ) ) res = VPX_CODEC_INCAPABLE ; else { memset ( ctx , 0 , sizeof ( * ctx ) ) ; ctx -> iface = iface ; ctx -> name = iface -> name ; ctx -> priv = NULL ; ctx -> init_flags = flags ; res = v
",0,511
373,"static int jp2_cdef_getdata ( jp2_box_t * box , jas_stream_t * in ) { jp2_cdef_t * cdef = & box -> data . cdef ; jp2_cdefchan_t * chan ; unsigned int channo ; if ( jp2_getuint16 ( in , & cdef -> ents ) ) { return - 1 ; } if ( ! ( cdef -> ents = jas_alloc2 ( cdef -> numchans , sizeof ( jp2_cdefchan_t ) ) ) ) { return - 1 ; } for ( channo = 0 ; channo < cdef -> numchans ; ++ channo ) { chan = & cdef -> ents [ channo ] ; if ( jp2_getuint16 ( in , & chan -> channo ) || jp2_getuint16 ( in , & chan -> type ) || jp2_getuint16 ( in , & chan -> assoc ) ) { return - 1 ; } } return 0 ; }
",0,249
374,"error_t tja1100Init ( NetInterface * interface ) { uint16_t value ; TRACE_INFO ( ""InitializingTJA1100...\\r\\n"" ) ; if ( interface -> phyAddr >= 32 ) { interface -> phyAddr = TJA1100_PHY_ADDR ; } if ( interface -> smiDriver != NULL ) { interface -> smiDriver -> init ( ) ; } if ( interface -> extIntDriver != NULL ) { interface -> extIntDriver -> init ( ) ; } tja1100WritePhyReg ( interface , TJA1100_BASIC_CTRL , TJA1100_BASIC_CTRL_RESET ) ; while ( tja1100ReadPhyReg ( interface , TJA1100_BASIC_CTRL ) & TJA1100_BASIC_CTRL_RESET ) { } tja1100DumpPhyReg ( interface ) ; value = tja1100ReadPhyReg ( interface , TJA1100_EXTENDED_CTRL ) ; value |= TJA1100_EXTENDED_CTRL_CONFIG_EN ; tja1100WritePhyReg ( interface , TJA1100_EXTENDED_CTRL , value ) ; value = tja1100ReadPhyReg ( interface , TJA1100_CONFIG1 ) ; value &= ~ TJA1100_CONFIG1_MII_MODE ; value |= TJA1100_CONFIG1_MII_MODE_RMII_25MHZ ; tja1100WritePhyReg ( interface , TJA1100_CONFIG1 , value ) ; value = tja1100ReadPhyReg ( interface , TJA1100_CONFIG1 ) ; value |= TJA1100_CONFIG1_AUTO_OP ; tja1100WritePhyReg ( interface , TJA1100_CONFIG1 , value ) ; interface -> phyEvent = TRUE ; osSetEvent ( & netEvent ) ; return NO_ERROR ; }
",0,429
375,"void icmp_send ( struct sk_buff * skb_in , int type , int code , __be32 info ) { struct iphdr * iph ; int room ; struct icmp_bxm icmp_param ; struct rtable * rt = skb_rtable ( skb_in ) ; struct ipcm_cookie ipc ; __be32 saddr ; u8 tos ; struct net * net ; struct sock * sk ; if ( ! rt ) goto out ; net = dev_net ( rt -> dst . dev ) ; iph = ip_hdr ( skb_in ) ; if ( ( u8 * ) iph < skb_in -> head || ( skb_in -> network_header + sizeof ( * iph ) ) > skb_in -> tail ) goto out ; if ( skb_in -> pkt_type != PACKET_HOST ) goto out ; if ( rt -> rt_flags & ( RTCF_BROADCAST | RTCF_MULTICAST ) ) goto out ; if ( iph -> frag_off & htons ( IP_OFFSET ) ) goto out ; if ( icmp_pointers [ type ] . error ) { if ( iph -> protocol == IPPROTO_ICMP ) { u8 _inner_type , * itp ; itp = skb_header_pointer ( skb_in , skb_network_header ( skb_in ) + ( iph -> ihl << 2 ) + offsetof ( struct icmphdr , type ) - skb_in -> data , sizeof ( _inner_type ) , & _inner_type ) ; if ( itp == NULL ) goto out ; if ( * itp > NR_ICMP_TYPES || icmp_pointers [ * itp ] . error ) goto out ; } } sk = icmp_xmit_lock ( net ) ; if ( sk == NULL ) return ; saddr = iph -> daddr ; if ( ! ( rt -> rt_flags & RTCF_LOCAL ) ) { struct net_device * dev = NULL ; rcu_read_lock ( ) ; if ( rt_is_input_route ( rt ) && net -> ipv4 . sysctl_icmp_errors_use_inbound_
",0,511
376,"static int print_bacp_config_options ( netdissect_options * ndo , const u_char * p , int length ) { int len , opt ; if ( length < 2 ) return 0 ; ND_TCHECK2 ( * p , 2 ) ; len = p [ 1 ] ; opt = p [ 0 ] ; if ( length < len ) return 0 ; if ( len < 2 ) { ND_PRINT ( ( ndo , ""\\n\\t%sOption(0x%02x),length%u(lengthbogus,shouldbe>=2)"" , tok2str ( bacconfopts_values , ""Unknown"" , opt ) , opt , len ) ) ; return 0 ; } ND_PRINT ( ( ndo , ""\\n\\t%sOption(0x%02x),length%u"" , tok2str ( bacconfopts_values , ""Unknown"" , opt ) , opt , len ) ) ; switch ( opt ) { case BACPOPT_FPEER : if ( len != 6 ) { ND_PRINT ( ( ndo , ""(lengthbogus,shouldbe=6)"" ) ) ; return len ; } ND_TCHECK_32BITS ( p + 2 ) ; ND_PRINT ( ( ndo , "":Magic-Num0x%08x"" , EXTRACT_32BITS ( p + 2 ) ) ) ; break ; default : if ( ndo -> ndo_vflag < 2 ) print_unknown_data ( ndo , & p [ 2 ] , ""\\n\\t"" , len - 2 ) ; break ; } if ( ndo -> ndo_vflag > 1 ) print_unknown_data ( ndo , & p [ 2 ] , ""\\n\\t"" , len - 2 ) ; return len ; trunc : ND_PRINT ( ( ndo , ""[|bacp]"" ) ) ; return 0 ; }
",0,427
377,"void ipv4_pktinfo_prepare ( const struct sock * sk , struct sk_buff * skb ) { struct in_pktinfo * pktinfo = PKTINFO_SKB_CB ( skb ) ; bool prepare = ( inet_sk ( sk ) -> cmsg_flags & IP_CMSG_PKTINFO ) || ipv6_sk_rxinfo ( sk ) ; if ( prepare && skb_rtable ( skb ) ) { if ( pktinfo -> ipi_ifindex == LOOPBACK_IFINDEX ) pktinfo -> ipi_ifindex = inet_iif ( skb ) ; pktinfo -> ipi_spec_dst . s_addr = fib_compute_spec_dst ( skb ) ; } else { pktinfo -> ipi_ifindex = 0 ; pktinfo -> ipi_spec_dst . s_addr = 0 ; } skb_dst_drop ( skb ) ; }
",0,224
378,"static void skcipher_release ( void * private ) { struct skcipher_tfm * tfm = private ; crypto_free_skcipher ( tfm -> skcipher ) ; kfree ( tfm ) ; }
",1,51
379,"int prepare_binprm ( struct linux_binprm * bprm ) { int retval ; bprm -> cred -> euid = current_euid ( ) ; bprm -> cred -> egid = current_egid ( ) ; if ( ! ( bprm -> file -> f_path . mnt -> mnt_flags & MNT_NOSUID ) && ! task_no_new_privs ( current ) && kuid_has_mapping ( bprm -> cred -> user_ns , inode -> i_uid ) && kgid_has_mapping ( bprm -> cred -> user_ns , inode -> i_gid ) ) { if ( mode & S_ISUID ) { bprm -> per_clear |= PER_CLEAR_ON_SETID ; bprm -> cred -> euid = inode -> i_uid ; } if ( ( mode & ( S_ISGID | S_IXGRP ) ) == ( S_ISGID | S_IXGRP ) ) { bprm -> per_clear |= PER_CLEAR_ON_SETID ; bprm -> cred -> egid = inode -> i_gid ; } } retval = security_bprm_set_creds ( bprm ) ; if ( retval ) return retval ; bprm -> cred_prepared = 1 ; memset ( bprm -> buf , 0 , BINPRM_BUF_SIZE ) ; return kernel_read ( bprm -> file , 0 , bprm -> buf , BINPRM_BUF_SIZE ) ; }
",1,365
380,"static int get_rx_bufs ( struct vhost_virtqueue * vq , struct vring_used_elem * heads , int datalen , unsigned * iovcount , struct vhost_log * log , unsigned * log_num , unsigned int quota ) { unsigned int out , in ; int seg = 0 ; int headcount = 0 ; unsigned d ; int r , nlogs = 0 ; while ( datalen > 0 && headcount < quota ) { if ( unlikely ( seg >= UIO_MAXIOV ) ) { r = - ENOBUFS ; goto err ; } d = vhost_get_vq_desc ( vq -> dev , vq , vq -> iov + seg , ARRAY_SIZE ( vq -> iov ) - seg , & out , & in , log , log_num ) ; if ( d == vq -> num ) { r = 0 ; goto err ; } if ( unlikely ( out || in <= 0 ) ) { vq_err ( vq , ""unexpecteddescriptorformatforRX:"" ""out%d,in%d\\n"" , out , in ) ; r = - EINVAL ; goto err ; } if ( unlikely ( log ) ) { nlogs += * log_num ; log += * log_num ; } heads [ headcount ] . id = d ; heads [ headcount ] . len = iov_length ( vq -> iov + seg , in ) ; datalen -= heads [ headcount ] . len ; ++ headcount ; seg += in ; } heads [ headcount - 1 ] . len += datalen ; * iovcount = seg ; if ( unlikely ( log ) ) * log_num = nlogs ; if ( unlikely ( datalen > 0 ) ) { r = UIO_MAXIOV + 1 ; goto err ; } return headcount ; err : vhost_discard_vq_desc ( vq , headcount ) ; return r ; }
",1,444
381,"void imap_quote_string ( char * dest , size_t dlen , const char * src , bool quote_backtick ) { const char * quote = ""`\\""\\\\"" ; if ( ! quote_backtick ) quote ++ ; char * pt = dest ; const char * s = src ; * pt ++ = \'""\' ; dlen -= 2 ; * pt ++ = '\\\\' ; * pt ++ = * s ; } else { * pt ++ = * s ; dlen -- ; } } * pt ++ = \'""\' ; * pt = '\\0' ; }
",1,128
382,"static void bt_tags_for_each ( struct blk_mq_tags * tags , struct blk_mq_bitmap_tags * bt , unsigned int off , busy_tag_iter_fn * fn , void * data , bool reserved ) { struct request * rq ; int bit , i ; if ( ! tags -> rqs ) return ; for ( i = 0 ; i < bt -> map_nr ; i ++ ) { struct blk_align_bitmap * bm = & bt -> map [ i ] ; for ( bit = find_first_bit ( & bm -> word , bm -> depth ) ; bit < bm -> depth ; bit = find_next_bit ( & bm -> word , bm -> depth , bit + 1 ) ) { rq = tags -> rqs [ off + bit ) ; fn ( rq , data , reserved ) ; } off += ( 1 << bt -> bits_per_word ) ; } }
",1,216
383,"vpx_codec_err_t vpx_codec_enc_init_multi_ver ( vpx_codec_ctx_t * ctx , vpx_codec_iface_t * iface , vpx_codec_enc_cfg_t * cfg , int num_enc , vpx_codec_flags_t flags , vpx_rational_t * dsf , int ver ) { vpx_codec_err_t res = VPX_CODEC_OK ; if ( ver != VPX_ENCODER_ABI_VERSION ) res = VPX_CODEC_ABI_MISMATCH ; else if ( ! ctx || ! iface || ! cfg || ( num_enc > 16 || num_enc < 1 ) ) res = VPX_CODEC_INVALID_PARAM ; else if ( iface -> abi_version != VPX_CODEC_INTERNAL_ABI_VERSION ) res = VPX_CODEC_ABI_MISMATCH ; else if ( ! ( iface -> caps & VPX_CODEC_CAP_ENCODER ) ) res = VPX_CODEC_INCAPABLE ; else if ( ( flags & VPX_CODEC_USE_XMA ) && ! ( iface -> caps & VPX_CODEC_CAP_XMA ) ) res = VPX_CODEC_INCAPABLE ; else if ( ( flags & VPX_CODEC_USE_PSNR ) && ! ( iface -> caps & VPX_CODEC_CAP_PSNR ) ) res = VPX_CODEC_INCAPABLE ; else if ( ( flags & VPX_CODEC_USE_OUTPUT_PARTITION ) && ! ( iface -> caps & VPX_CODEC_CAP_OUTPUT_PARTITION ) ) res = VPX_CODEC_INCAPABLE ; else { int i ; void * mem_loc = NULL ; if ( ! ( res = iface -> enc . mr_get_mem_loc ( cfg , & mem_loc ) ) ) { for ( i = 0 ; i < num_enc ; i ++ ) { vpx_codec_priv_enc_mr_cfg .
",0,511
384,"static int vmci_transport_dgram_dequeue ( struct kiocb * kiocb , struct vsock_sock * vsk , struct msghdr * msg , size_t len , int flags ) { int err ; int noblock ; struct vmci_datagram * dg ; size_t payload_len ; struct sk_buff * skb ; noblock = flags & MSG_DONTWAIT ; if ( flags & MSG_OOB || flags & MSG_ERRQUEUE ) return - EOPNOTSUPP ; msg -> msg_namelen = 0 ; err = 0 ; skb = skb_recv_datagram ( & vsk -> sk , flags , noblock , & err ) ; if ( err ) return err ; if ( ! skb ) return - EAGAIN ; dg = ( struct vmci_datagram * ) skb -> data ; if ( ! dg ) goto out ; payload_len = dg -> payload_size ; if ( payload_len != skb -> len - sizeof ( * dg ) ) { err = - EINVAL ; goto out ; } if ( payload_len > len ) { payload_len = len ; msg -> msg_flags |= MSG_TRUNC ; } err = skb_copy_datagram_iovec ( skb , sizeof ( * dg ) , msg -> msg_iov , payload_len ) ; if ( err ) goto out ; if ( msg -> msg_name ) { struct sockaddr_vm * vm_addr ; vm_addr = ( struct sockaddr_vm * ) msg -> msg_name ; vsock_addr_init ( vm_addr , dg -> src . context , dg -> src . resource ) ; msg -> msg_namelen = sizeof ( * vm_addr ) ; } err = payload_len ; out : skb_free_datagram ( & vsk -> sk , skb ) ; return err ; }
",0,429
385,"static u64 __skb_get_nlattr ( u64 ctx , u64 A , u64 X , u64 r4 , u64 r5 ) { struct sk_buff * skb = ( struct sk_buff * ) ( long ) ctx ; struct nlattr * nla ; if ( skb -> len < sizeof ( struct nlattr ) ) return 0 ; nla = nla_find ( ( struct nlattr * ) & skb -> data [ A ] , skb -> len - A , X ) ; if ( nla ) return ( void * ) nla - ( void * ) skb -> data ; return 0 ; }
",0,144
386,"static inline void encode_openhdr ( struct xdr_stream * xdr , const struct nfs_openargs * arg ) { __be32 * p ; RESERVE_SPACE ( 8 ) ; WRITE32 ( OP_OPEN ) ; WRITE32 ( arg -> seqid -> sequence -> counter ) ; encode_share_access ( xdr , arg -> fmode ) ; RESERVE_SPACE ( 28 ) ; WRITE64 ( arg -> clientid ) ; WRITE32 ( 16 ) ; WRITEMEM ( ""openid:"" , 8 ) ; WRITE64 ( arg -> id ) ; }
",1,130
387,"static void gre_print_0 ( netdissect_options * ndo , const u_char * bp , u_int length ) { u_int len = length ; uint16_t flags , prot ; flags = EXTRACT_16BITS ( bp ) ; if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "",Flags[%s]"" , bittok2str ( gre_flag_values , ""none"" , flags ) ) ) ; len -= 2 ; bp += 2 ; ND_TCHECK2 ( * bp , 2 ) ; if ( len < 2 ) goto trunc ; prot = EXTRACT_16BITS ( bp ) ; len -= 2 ; bp += 2 ; if ( ( flags & GRE_CP ) | ( flags & GRE_RP ) ) { ND_TCHECK2 ( * bp , 2 ) ; if ( len < 2 ) goto trunc ; if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , "",sum0x%x"" , EXTRACT_16BITS ( bp ) ) ) ; bp += 2 ; len -= 2 ; ND_TCHECK2 ( * bp , 2 ) ; if ( len < 2 ) goto trunc ; ND_PRINT ( ( ndo , "",off0x%x"" , EXTRACT_16BITS ( bp ) ) ) ; bp += 2 ; len -= 2 ; } if ( flags & GRE_KP ) { ND_TCHECK2 ( * bp , 4 ) ; if ( len < 4 ) goto trunc ; ND_PRINT ( ( ndo , "",key=0x%x"" , EXTRACT_32BITS ( bp ) ) ) ; bp += 4 ; len -= 4 ; } if ( flags & GRE_SP ) { ND_TCHECK2 ( * bp , 4 ) ; if ( len < 4 ) goto trunc ; ND_PRINT ( ( ndo , "",seq%u"" , EXTRACT_32BITS ( bp ) ) ) ; bp += 4 ; len -= 4 ; } if ( flags & GRE_RP ) { for ( ; ; ) { uint16_t af ; uint8_t sreoff ; uint8_t srelen ; ND_TCHECK2 ( * bp , 4 )
",0,511
388,"static int readContigTilesIntoBuffer ( TIFF * in , uint8 * buf , uint32 imagelength , uint32 imagewidth , uint32 tw , uint32 tl , tsample_t spp , uint16 bps ) { int status = 1 ; tsample_t sample = 0 ; tsample_t count = spp ; uint32 row , col , trow ; uint32 nrow , ncol ; uint32 dst_rowsize , shift_width ; uint32 bytes_per_sample , bytes_per_pixel ; uint32 trailing_bits , prev_trailing_bits ; uint32 tile_rowsize = TIFFTileRowSize ( in ) ; uint32 src_offset , dst_offset ; uint32 row_offset , col_offset ; uint8 * bufp = ( uint8 * ) buf ; unsigned char * src = NULL ; unsigned char * dst = NULL ; tsize_t tbytes = 0 , tile_buffsize = 0 ; tsize_t tilesize = TIFFTileSize ( in ) ; unsigned char * tilebuf = NULL ; bytes_per_sample = ( bps + 7 ) / 8 ; bytes_per_pixel = ( ( bps * spp ) + 7 ) / 8 ; if ( ( bps % 8 ) == 0 ) shift_width = 0 ; else { if ( bytes_per_pixel < ( bytes_per_sample + 1 ) ) shift_width = bytes_per_pixel ; else shift_width = bytes_per_sample + 1 ; } tile_buffsize = tilesize ; if ( tilesize == 0 || tile_rowsize == 0 ) { TIFFError ( ""readContigTilesIntoBuffer"" , ""Tilesizeortilerowsizeiszero"" ) ; exit ( - 1 ) ; } if ( tilesize < ( tsize_t ) ( tl * tile_rowsize ) ) { # ifdef DEBUG2 TIFFError ( ""readContigTilesIntoBuffer"" , ""Tilesize%luistoosmall,usingalternatecalculation%u"" , tilesize , tl * tile_rowsize ) ; # endif tile_buffsize = tl * tile_rowsize ; if ( tl != ( tile_buffsize / tile_rowsize ) ) { TIFFError ( ""readContigTilesIntoBuffer
",0,511
389,"static bool parse_cmdline ( int argc , char * * argv ) { int c ; bool reopen_log = false ; int signum ; struct utsname uname_buf ; int longindex ; int curind ; bool bad_option = false ; unsigned facility ; mode_t new_umask_val ; struct option long_options [ ] = { { ""use-file"" , required_argument , NULL , 'f' } , # if defined _WITH_VRRP_ && defined _WITH_LVS_ { ""vrrp"" , no_argument , NULL , 'P' } , { ""check"" , no_argument , NULL , 'C' } , # endif # ifdef _WITH_BFD_ { ""no_bfd"" , no_argument , NULL , 'B' } , # endif { ""all"" , no_argument , NULL , 3 } , { ""log-console"" , no_argument , NULL , 'l' } , { ""log-detail"" , no_argument , NULL , 'D' } , { ""log-facility"" , required_argument , NULL , 'S' } , { ""log-file"" , optional_argument , NULL , 'g' } , { ""flush-log-file"" , no_argument , NULL , 2 } , { ""no-syslog"" , no_argument , NULL , 'G' } , { ""umask"" , required_argument , NULL , 'u' } , # ifdef _WITH_VRRP_ { ""release-vips"" , no_argument , NULL , 'X' } , { ""dont-release-vrrp"" , no_argument , NULL , 'V' } , # endif # ifdef _WITH_LVS_ { ""dont-release-ipvs"" , no_argument , NULL , 'I' } , # endif { ""dont-respawn"" , no_argument , NULL , 'R' } , { ""dont-fork"" , no_argument , NULL , 'n' } , { ""dump-conf"" , no_argument , NULL , 'd' } , { ""pid"" , required_argument , NULL , 'p' } , # ifdef _WITH_VRRP_ { ""vrrp_pid"" , required_argument , NULL , '
",0,511
390,"static int modify_bar_registration ( struct pci_vdev * dev , int idx , int registration ) { int error ; struct inout_port iop ; struct mem_range mr ; if ( is_pci_gvt ( dev ) ) { printf ( ""modify_bar_registration:bypassforpci-gvt\\n"" ) ; return - 1 ; } switch ( dev -> bar [ idx ] . type ) { case PCIBAR_IO : bzero ( & iop , sizeof ( struct inout_port ) ) ; iop . name = dev -> name ; iop . port = dev -> bar [ idx ] . addr ; iop . size = dev -> bar [ idx ] . size ; if ( registration ) { iop . flags = IOPORT_F_INOUT ; iop . handler = pci_emul_io_handler ; iop . arg = dev ; error = register_inout ( & iop ) ; } else error = unregister_inout ( & iop ) ; break ; case PCIBAR_MEM32 : case PCIBAR_MEM64 : bzero ( & mr , sizeof ( struct mem_range ) ) ; mr . name = dev -> name ; mr . base = dev -> bar [ idx ] . addr ; mr . size = dev -> bar [ idx ] . size ; if ( registration ) { mr . flags = MEM_F_RW ; mr . handler = pci_emul_mem_handler ; mr . arg1 = dev ; mr . arg2 = idx ; error = register_mem ( & mr ) ; } else error = unregister_mem ( & mr ) ; break ; default : error = EINVAL ; break ; } if ( error != 0 ) { pr_err ( ""%s:%d\\n"" , __func__ , error ) ; } return error ; }
",0,422
391,"static ssize_t o2nm_node_local_store ( struct config_item * item , const char * page , size_t count ) { struct o2nm_node * node = to_o2nm_node ( item ) ; struct o2nm_cluster * cluster ; unsigned long tmp ; char * p = ( char * ) page ; ssize_t ret ; tmp = simple_strtoul ( p , & p , 0 ) ; if ( ! p || ( * p && ( * p != '\\n' ) ) ) return - EINVAL ; tmp = ! ! tmp ; if ( ! test_bit ( O2NM_NODE_ATTR_ADDRESS , & node -> nd_set_attributes ) || ! test_bit ( O2NM_NODE_ATTR_NUM , & node -> nd_set_attributes ) || ! test_bit ( O2NM_NODE_ATTR_PORT , & node -> nd_set_attributes ) ) return - EINVAL ; if ( tmp && tmp == cluster -> cl_has_local_or_nodemode && cluster -> cl_local_node != node -> nd_num ) return - EBUSY ; if ( tmp && ! cluster -> cl_has_local ) { ret = o2net_start_listening ( node ) ; if ( ret ) return ret ; } if ( ! tmp && cluster -> cl_has_local && cluster -> cl_local_node == node -> nd_num ) { o2net_stop_listening ( node ) ; cluster -> cl_local_node = O2NM_INVALID_NODE_NUM ; } node -> nd_local = tmp ; if ( node -> nd_local ) { cluster -> cl_has_local = tmp ; cluster -> cl_local_node = node -> nd_num ; } o2net_stop_listening ( node ) ; return count ; }
",0,431
392,"PTA * ptaReadStream ( FILE * fp ) { char typestr [ 128 ] ; l_int32 i , n , ix , iy , type , version ; l_float32 x , y ; PTA * pta ; PROCNAME ( ""ptaReadStream"" ) ; if ( ! fp ) return ( PTA * ) ERROR_PTR ( ""streamnotdefined"" , procName , NULL ) ; if ( fscanf ( fp , ""Numberofpts=%d;format=%127s\\n"" , & n , typestr ) != 2 ) return ( PTA * ) ERROR_PTR ( ""notaptafile"" , procName , NULL ) ; if ( ! strcmp ( typestr , ""float"" ) ) type = 0 ; else type = 1 ; if ( ( pta = ptaCreate ( n ) ) == NULL ) return ( PTA * ) ERROR_PTR ( ""ptanotmade"" , procName , NULL ) ; for ( i = 0 ; i < n ; i ++ ) { if ( type == 0 ) { if ( fscanf ( fp , ""(%f,%f)\\n"" , & x , & y ) != 2 ) { ptaDestroy ( & pta ) ; return ( PTA * ) ERROR_PTR ( ""errorreadingfloats"" , procName , NULL ) ; } ptaAddPt ( pta , x , y ) ; } else { if ( fscanf ( fp , ""(%d,%d)\\n"" , & ix , & iy ) != 2 ) { ptaDestroy ( & pta ) ; return ( PTA * ) ERROR_PTR ( ""errorreadingints"" , procName , NULL ) ; } ptaAddPt ( pta , ix , iy ) ; } } return pta ; }
",1,409
393,"static int _6502_op ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * data , int len ) { char addrbuf [ 64 ] ; const int buffsize = sizeof ( addrbuf ) - 1 ; memset ( op , '\\0' , sizeof ( RAnalOp ) ) ; op -> size = snes_op_get_size ( 1 , 1 , & snes_op [ data [ 0 ] ] ) ; op -> addr = addr ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> id = data [ 0 ] ; r_strbuf_init ( & op -> esil ) ; switch ( data [ 0 ] ) { case 0x02 : case 0x03 : case 0x04 : case 0x07 : case 0x0b : case 0x0c : case 0x0f : case 0x12 : case 0x13 : case 0x14 : case 0x17 : case 0x1a : case 0x1b : case 0x1c : case 0x1f : case 0x22 : case 0x23 : case 0x27 : case 0x2b : case 0x2f : case 0x2f : case 0x32 : case 0x33 : case 0x34 : case 0x37 : case 0x3a : case 0x3b : case 0x3c : case 0x3f : case 0x42 : case 0x43 : case 0x44 : case 0x47 : case 0x4b : case 0x4f : case 0x52 : case 0x53 : case 0x54 : case 0x57 : case 0x5a : case 0x5b : case 0x5c : case 0x5f : case 0x62 : case 0x63 : case 0x64 : case 0x67 : case 0x6b : case 0x6f : case 0x72 : case 0x73 : case 0x74 : case 0x77 : case 0x7a : case 0x7b : case 0x7c : case 0x7f : case 0x80 : case 0x82 : case 0x83 : case 0x87 : case 0x89 : case 0x8b : case 0x8f : case 0x
",0,511
394,"void sctp_generate_t3_rtx_event ( unsigned long peer ) { int error ; struct sctp_transport * transport = ( struct sctp_transport * ) peer ; struct sctp_association * asoc = transport -> asoc ; struct sock * sk = asoc -> base . sk ; struct net * net = sock_net ( sk ) ; bh_lock_sock ( asoc -> base . sk ) ; if ( sock_owned_by_user ( sk ) ) { pr_debug ( ""%s:sockisbusy\\n"" , __func__ ) ; if ( ! mod_timer ( & transport -> T3_rtx_timer , jiffies + ( HZ / 20 ) ) ) sctp_transport_hold ( transport ) ; goto out_unlock ; } if ( transport -> dead ) goto out_unlock ; error = sctp_do_sm ( net , SCTP_EVENT_T_TIMEOUT , SCTP_ST_TIMEOUT ( SCTP_EVENT_TIMEOUT_T3_RTX ) , asoc -> state , asoc -> ep , asoc , transport , GFP_ATOMIC ) ; if ( error ) sk -> sk_err = - error ; out_unlock : bh_unlock_sock ( sk ) ; sctp_transport_put ( transport ) ; }
",1,315
395,"error_t httpParseRequestLine ( HttpConnection * connection , char_t * requestLine ) { error_t error ; char_t * token ; char_t * p ; char_t * s ; token = osStrtok_r ( requestLine , ""\\r\\n"" , & p ) ; if ( token == NULL ) return ERROR_INVALID_REQUEST ; error = strSafeCopy ( connection -> request . method , token , HTTP_SERVER_METHOD_MAX_LEN ) ; if ( error ) return ERROR_INVALID_REQUEST ; token = osStrtok_r ( NULL , ""\\r\\n"" , & p ) ; if ( token == NULL ) return ERROR_INVALID_REQUEST ; s = osStrchr ( token , '?' ) ; if ( s != NULL ) { * s = '\\0' ; error = httpDecodePercentEncodedString ( token , connection -> request . uri , HTTP_SERVER_URI_MAX_LEN ) ; if ( error ) return ERROR_INVALID_REQUEST ; if ( osStrlen ( s + 1 ) > HTTP_SERVER_QUERY_STRING_MAX_LEN ) return ERROR_INVALID_REQUEST ; osStrcpy ( connection -> request . queryString , s + 1 ) ; } else { error = httpDecodePercentEncodedString ( token , connection -> request . uri , HTTP_SERVER_URI_MAX_LEN ) ; if ( error ) return ERROR_INVALID_REQUEST ; connection -> request . queryString [ 0 ] = '\\0' ; } if ( ! osStrcasecmp ( connection -> request . uri , ""/"" ) ) osStrcpy ( connection -> request . uri , connection -> settings -> defaultDocument ) ; pathCanonicalize ( connection -> request . uri ) ; token = osStrtok_r ( NULL , ""\\r\\n"" , & p ) ; if ( token == NULL ) { connection -> request . version = HTTP_VERSION_0_9 ; connection -> request . keepAlive = FALSE ; } else if ( ! osStrcasecmp ( token , ""HTTP/1.0"" ) ) { connection -> request . version = HTTP_VERSION_1_0 ; connection -> request . keepAlive = FALSE
",0,511
396,"int write_output ( void ) { int fd ; struct filter_op * fop ; struct filter_header fh ; size_t ninst , i ; u_char * data ; ninst = compile_tree ( & fop ) ; if ( fop == NULL ) return - E_NOTHANDLED ; if ( ninst == 0 ) return - E_INVALID ; fd = open ( EF_GBL_OPTIONS -> output_file , O_CREAT | O_RDWR | O_TRUNC | O_BINARY , 0644 ) ; ON_ERROR ( fd , - 1 , ""Can\'tcreatefile%s"" , EF_GBL_OPTIONS -> output_file ) ; fprintf ( stdout , ""Writingoutputto\\\'%s\\\'"" , EF_GBL_OPTIONS -> output_file ) ; fflush ( stdout ) ; fh . magic = htons ( EC_FILTER_MAGIC ) ; strncpy ( fh . version , EC_VERSION , sizeof ( fh . version ) ) ; fh . data = sizeof ( fh ) ; data = create_data_segment ( & fh , fop , ninst ) ; write ( fd , & fh , sizeof ( struct filter_header ) ) ; write ( fd , data , fh . code - fh . data ) ; for ( i = 0 ; i <= ninst ; i ++ ) { print_progress_bar ( & fop [ i ] ) ; write ( fd , & fop [ i ] , sizeof ( struct filter_op ) ) ; } close ( fd ) ; fprintf ( stdout , ""done.\\n\\n"" ) ; fprintf ( stdout , ""->Scriptencodedinto%dinstructions.\\n\\n"" , ( int ) ( i - 1 ) ) ; return E_SUCCESS ; }
",1,422
397,"static int ospf6_print_lshdr ( netdissect_options * ndo , register const struct lsa6_hdr * lshp , const u_char * dataend ) { if ( ( const u_char * ) ( lshp + 1 ) > dataend ) goto trunc ; if ( ( const u_char * ) ( lshp + 2 ) > dataend ) goto trunc ; ND_TCHECK ( lshp -> ls_type ) ; ND_TCHECK ( lshp -> ls_seq ) ; ND_PRINT ( ( ndo , ""\\n\\tAdvertisingRouter%s,seq0x%08x,age%us,length%u"" , ipaddr_string ( ndo , & lshp -> ls_router ) , EXTRACT_32BITS ( & lshp -> ls_seq ) , EXTRACT_16BITS ( & lshp -> ls_age ) , EXTRACT_16BITS ( & lshp -> ls_length ) - ( u_int ) sizeof ( struct lsa6_hdr ) ) ) ; ospf6_print_ls_type ( ndo , EXTRACT_16BITS ( & lshp -> ls_type ) , & lshp -> ls_stateid ) ; return ( 0 ) ; trunc : return ( 1 ) ; }
",0,304
398,"static int jas_iccputuint ( jas_stream_t * out , int n , jas_ulonglong val ) { int i ; int c ; for ( i = n ; i > 0 ; -- i ) { c = ( val >> ( 8 * ( i - 1 ) ) ) & 0xff ; if ( jas_stream_putc ( out , c ) == EOF ) return - 1 ; } return 0 ; }
",1,97
399,"static int parse_elements ( netdissect_options * ndo , struct mgmt_body_t * pbody , const u_char * p , int offset , u_int length ) { u_int elementlen ; struct ssid_t ssid ; struct challenge_t challenge ; struct rates_t rates ; struct ds_t ds ; struct cf_t cf ; struct tim_t tim ; pbody -> challenge_present = 0 ; pbody -> ssid_present = 0 ; pbody -> rates_present = 0 ; pbody -> ds_present = 0 ; pbody -> cf_present = 0 ; pbody -> tim_present = 0 ; while ( length != 0 ) { if ( ! ND_TTEST2 ( * ( p + offset ) , 2 ) ) return 0 ; if ( length < 2 ) return 0 ; elementlen = * ( p + offset + 1 ) ; if ( ! ND_TTEST2 ( * ( p + offset + 2 ) , elementlen ) ) return 0 ; if ( length < elementlen + 2 ) return 0 ; switch ( * ( p + offset ) ) { case E_SSID : memcpy ( & ssid , p + offset , 2 ) ; offset += 2 ; length -= 2 ; if ( ssid . length != 0 ) { if ( ssid . length > sizeof ( ssid . ssid ) - 1 ) return 0 ; if ( ! ND_TTEST2 ( * ( p + offset ) , ssid . length ) ) return 0 ; if ( length < ssid . length ) return 0 ; memcpy ( & ssid . ssid , p + offset , ssid . length ) ; offset += ssid . length ; length -= ssid . length ; } ssid . ssid [ ssid . length ] = '\\0' ; if ( ! pbody -> ssid_present ) { pbody -> ssid = ssid ; pbody -> ssid_present = 1 ; } break ; case E_CHALLENGE : memcpy ( & challenge , p + offset , 2 ) ; offset += 2 ; length -= 2 ; if ( challenge . length != 0 ) { if ( challenge . length > sizeof ( challenge . text ) - 1 ) return 0 ; if ( ! ND_TTEST2 ( * ( p + offset ) , challenge . length ) ) return 0 ; if ( length
",0,511
400,"static int splice_pipe_to_pipe ( struct pipe_inode_info * ipipe , struct pipe_inode_info * opipe , size_t len , unsigned int flags ) { struct pipe_buffer * ibuf , * obuf ; int ret = 0 , nbuf ; bool input_wakeup = false ; retry : ret = ipipe_prep ( ipipe , flags ) ; if ( ret ) return ret ; ret = opipe_prep ( opipe , flags ) ; if ( ret ) return ret ; pipe_double_lock ( ipipe , opipe ) ; do { if ( ! opipe -> readers ) { send_sig ( SIGPIPE , current , 0 ) ; if ( ! ret ) ret = - EPIPE ; break ; } if ( ! ipipe -> nrbufs && ! ipipe -> writers ) break ; if ( ! ipipe -> nrbufs || opipe -> nrbufs >= opipe -> buffers ) { if ( ret ) break ; if ( flags & SPLICE_F_NONBLOCK ) { ret = - EAGAIN ; break ; } pipe_unlock ( ipipe ) ; pipe_unlock ( opipe ) ; goto retry ; } ibuf = ipipe -> bufs + ipipe -> curbuf ; nbuf = ( opipe -> curbuf + opipe -> nrbufs ) & ( opipe -> buffers - 1 ) ; obuf = opipe -> bufs + nbuf ; if ( len >= ibuf -> len ) { * obuf = * ibuf ; ibuf -> ops = NULL ; opipe -> nrbufs ++ ; ipipe -> curbuf = ( ipipe -> curbuf + 1 ) & ( ipipe -> buffers - 1 ) ; ipipe -> nrbufs -- ; input_wakeup = true ; } else { if ( ! pipe_buf_get ( ipipe , ibuf ) ) { if ( ret == 0 ) ret = - EFAULT ; break ; } * obuf = * ibuf ; obuf -> flags &= ~ PIPE_BUF_FLAG_GIFT ; pipe_buf_mark_unmergeable ( obuf ) ; obuf -> len = len ; opipe -> nrbufs ++ ; ibuf -> offset += obuf -> len ; ibuf -> len -= obuf -> len ; }
",0,511
401,"static void * load_bytes ( RBinFile * arch , const ut8 * buf , ut64 sz , ut64 loaddr , Sdb * sdb ) { if ( ! buf || ! sz || sz == UT64_MAX ) { return NULL ; } RBuffer * tbuf = r_buf_new ( ) ; if ( ! tbuf ) { return NULL ; } r_buf_set_bytes ( tbuf , buf , sz ) ; struct r_bin_bflt_obj * res = r_bin_bflt_new_buf ( tbuf ) ; r_buf_free ( tbuf ) ; return res ? res : NULL ; }
",1,146
402,"SYSCALL_DEFINE4 ( osf_wait4 , pid_t , pid , int __user * , ustatus , int , options , struct rusage32 __user * , ur ) { struct rusage r ; long ret , err ; unsigned int status = 0 ; mm_segment_t old_fs ; if ( ! ur ) return sys_wait4 ( pid , ustatus , options , NULL ) ; old_fs = get_fs ( ) ; set_fs ( KERNEL_DS ) ; ret = sys_wait4 ( pid , ustatus , options , ( struct rusage __user * ) & status ) ; set_fs ( old_fs ) ; if ( ! access_ok ( VERIFY_WRITE , ur , sizeof ( * ur ) ) ) return - EFAULT ; err = 0 ; err |= put_user ( status , ustatus ) ; err |= __put_user ( r . ru_utime . tv_sec , & ur -> ru_utime . tv_sec ) ; err |= __put_user ( r . ru_utime . tv_usec , & ur -> ru_utime . tv_usec ) ; err |= __put_user ( r . ru_stime . tv_sec , & ur -> ru_stime . tv_sec ) ; err |= __put_user ( r . ru_stime . tv_usec , & ur -> ru_stime . tv_usec ) ; err |= __put_user ( r . ru_maxrss , & ur -> ru_maxrss ) ; err |= __put_user ( r . ru_ixrss , & ur -> ru_ixrss ) ; err |= __put_user ( r . ru_idrss , & ur -> ru_idrss ) ; err |= __put_user ( r . ru_isrss , & ur -> ru_isrss ) ; err |= __put_user ( r . ru_minflt , & ur -> ru_minflt ) ; err |= __put_user ( r . ru_majflt , & ur -> ru_majflt ) ; err |= __put_user ( r . ru_nswap , & ur -> ru_nswap ) ; err |= __put_user ( r . ru
",0,511
403,"static int lxc_mount_auto_mounts ( struct lxc_conf * conf , int flags , struct lxc_handler * handler ) { int r ; size_t i ; static struct { int match_mask ; int match_flag ; const char * source ; const char * destination ; const char * fstype ; unsigned long flags ; const char * options ; } default_mounts [ ] = { { LXC_AUTO_PROC_MASK , LXC_AUTO_PROC_MIXED , ""proc"" , ""%r/proc"" , ""proc"" , MS_NODEV | MS_NOEXEC | MS_NOSUID , NULL } , { LXC_AUTO_PROC_MASK , LXC_AUTO_PROC_MIXED , ""%r/proc/sys/net"" , ""%r/proc/net"" , NULL , MS_BIND , NULL } , { LXC_AUTO_PROC_MASK , LXC_AUTO_PROC_MIXED , ""%r/proc/sys"" , ""%r/proc/sys"" , NULL , MS_BIND , NULL } , { LXC_AUTO_PROC_MASK , LXC_AUTO_PROC_MIXED , ""%r/proc/sys"" , ""%r/proc/sys"" , NULL , MS_REMOUNT | MS_BIND | MS_RDONLY , NULL } , { LXC_AUTO_PROC_MASK , LXC_AUTO_PROC_MIXED , ""%r/proc/net"" , ""%r/proc/sys/net"" , NULL , MS_MOVE , NULL } , { LXC_AUTO_PROC_MASK , LXC_AUTO_PROC_MIXED , ""%r/proc/sysrq-trigger"" , ""%r/proc/sysrq-trigger"" , NULL , MS_BIND , NULL } , { LXC_AUTO_PROC_MASK , LXC_AUTO_PROC_MIXED , NULL , ""%r/proc/sysrq-trigger"" , NULL , MS_REMOUNT | MS_BIND | MS_RDONLY , NULL } , { LXC_AUTO_PROC_MASK , LXC_AUT
",0,511
404,"stf_status ikev2parent_inI1outR1 ( struct msg_digest * md ) { struct state * st = md -> st ; lset_t policy = POLICY_IKEV2_ALLOW ; struct connection * c = find_host_connection ( & md -> iface -> ip_addr , md -> iface -> port , & md -> sender , md -> sender_port , POLICY_IKEV2_ALLOW ) ; # if 0 if ( c == NULL ) { pb_stream pre_sa_pbs = sa_pd -> pbs ; policy = preparse_isakmp_sa_body ( & pre_sa_pbs ) ; c = find_host_connection ( & md -> iface -> ip_addr , pluto_port , ( ip_address * ) NULL , md -> sender_port , policy ) ; } # endif if ( c == NULL ) { { struct connection * d ; d = find_host_connection ( & md -> iface -> ip_addr , pluto_port , ( ip_address * ) NULL , md -> sender_port , policy ) ; for ( ; d != NULL ; d = d -> hp_next ) { if ( d -> kind == CK_GROUP ) { } else { if ( d -> kind == CK_TEMPLATE && ! ( d -> policy & POLICY_OPPO ) ) { c = d ; break ; } if ( addrinsubnet ( & md -> sender , & d -> spd . that . client ) && ( c == NULL || ! subnetinsubnet ( & c -> spd . that . client , & d -> spd . that . client ) ) ) c = d ; } } } } if ( c == NULL ) { loglog ( RC_LOG_SERIOUS , ""initialparentSAmessagereceivedon%s:%u"" ""butnoconnectionhasbeenauthorized%s%s"" , ip_str ( & md -> iface -> ip_addr ) , ntohs ( portof ( & md -> iface -> ip_addr ) ) , ( policy != LEMPTY ) ? ""withpolicy="" : """" , ( policy != LEMPTY ) ? bitnamesof ( sa_policy_bit_names , policy ) : """" ) ; return STF_FA
",0,511
405,"BOOL nsc_encode ( NSC_CONTEXT * context , const BYTE * bmpdata , UINT32 rowstride ) { if ( ! context ) return FALSE ; if ( context -> ChromaSubsamplingLevel ) { if ( ! nsc_encode_subsampling ( context ) ) return FALSE ; } return TRUE ; }
",0,77
406,"void vp9_tree_probs_from_distribution ( vpx_tree tree , unsigned int branch_ct [ ] [ 2 ] , const unsigned int num_events [ ] ) { convert_distribution ( 0 , tree , branch_ct , num_events ) ; }
",1,62
407,"static int hns_xgmac_get_sset_count ( int stringset ) { if ( stringset == ETH_SS_STATS || stringset == ETH_SS_PRIV_FLAGS ) return ARRAY_SIZE ( g_xgmac_stats_string ) ; return 0 ; }
",1,68
408,"static inline size_t GetPSDRowSize ( Image * image ) { if ( image -> depth == 1 ) return ( ( image -> columns + 7 ) / 8 ) ; else return ( image -> columns * GetPSDPacketSize ( image ) ) ; }
",0,56
409,"void bta_hh_co_open ( UINT8 dev_handle , UINT8 sub_class , tBTA_HH_ATTR_MASK attr_mask , UINT8 app_id ) { UINT32 i ; btif_hh_device_t * p_dev = NULL ; if ( dev_handle == BTA_HH_INVALID_HANDLE ) { APPL_TRACE_WARNING ( ""%s:Oops,dev_handle(%d)isinvalid..."" , __FUNCTION__ , dev_handle ) ; return ; } for ( i = 0 ; i < BTIF_HH_MAX_HID ; i ++ ) { p_dev = & btif_hh_cb . devices [ i ] ; if ( p_dev -> dev_status != BTHH_CONN_STATE_UNKNOWN && p_dev -> dev_handle == dev_handle ) { APPL_TRACE_WARNING ( ""%s:Foundanexistingdevicewiththesamehandle"" ""dev_status=%d"" , __FUNCTION__ , p_dev -> dev_status ) ; APPL_TRACE_WARNING ( ""%s:bd_addr=[%02X:%02X:%02X:%02X:%02X:]"" , __FUNCTION__ , p_dev -> bd_addr . address [ 0 ] , p_dev -> bd_addr . address [ 1 ] , p_dev -> bd_addr . address [ 2 ] , p_dev -> bd_addr . address [ 3 ] , p_dev -> bd_addr . address [ 4 ] ) ; APPL_TRACE_WARNING ( ""%s:attr_mask=0x%04x,sub_class=0x%02x,app_id=%d"" , __FUNCTION__ , p_dev -> attr_mask , p_dev -> sub_class , p_dev -> app_id ) ; if ( p_dev -> fd < 0 ) { p_dev -> fd = open ( dev_path , O_RDWR | O_CLOEXEC ) ; if ( p_dev -> fd < 0 ) { APPL_TRACE_ERROR ( ""%s:Error:failedtoopenuhid,err:%s"" , __FUN
",0,511
410,"static int ims_pcu_parse_cdc_data ( struct usb_interface * intf , struct ims_pcu * pcu ) { const struct usb_cdc_union_desc * union_desc ; struct usb_host_interface * alt ; union_desc = ims_pcu_get_cdc_union_desc ( intf ) ; if ( ! union_desc ) return - EINVAL ; pcu -> ctrl_intf = usb_ifnum_to_if ( pcu -> udev , union_desc -> bMasterInterface0 ) ; if ( ! pcu -> ctrl_intf ) return - EINVAL ; alt = pcu -> ctrl_intf -> cur_altsetting ; pcu -> ep_ctrl = & alt -> endpoint [ 0 ] . desc ; pcu -> max_ctrl_size = usb_endpoint_maxp ( pcu -> ep_ctrl ) ; pcu -> data_intf = usb_ifnum_to_if ( pcu -> udev , union_desc -> bSlaveInterface0 ) ; if ( ! pcu -> data_intf ) return - EINVAL ; alt = pcu -> data_intf -> cur_altsetting ; if ( alt -> desc . bNumEndpoints != 2 ) { dev_err ( pcu -> dev , ""Incorrectnumberofendpointsondatainterface(%d)\\n"" , alt -> desc . bNumEndpoints ) ; return - EINVAL ; } pcu -> ep_out = & alt -> endpoint [ 0 ] . desc ; if ( ! usb_endpoint_is_bulk_out ( pcu -> ep_out ) ) { dev_err ( pcu -> dev , ""FirstendpointondatainterfaceisnotBULKOUT\\n"" ) ; return - EINVAL ; } pcu -> max_out_size = usb_endpoint_maxp ( pcu -> ep_out ) ; if ( pcu -> max_out_size < 8 ) { dev_err ( pcu -> dev , ""MaxOUTpacketsizeistoosmall(%zd)\\n"" , pcu -> max_out_size ) ; return - EINVAL ; } pcu -> ep_in = & alt -> endpoint [ 1 ] . desc ;
",0,511
411,"void dvb_usbv2_disconnect ( struct usb_interface * intf ) { struct dvb_usb_device * d = usb_get_intfdata ( intf ) ; struct dev = d -> udev -> dev ; dev_dbg ( & d -> udev -> dev , ""%s:bInterfaceNumber=%d\\n"" , __func__ , intf -> cur_altsetting -> desc . bInterfaceNumber ) ; if ( d -> props -> exit ) d -> props -> exit ( d ) ; dvb_usbv2_exit ( d ) ; dev_info ( & dev , ""%s:\'%s\'successfullydeinitializedanddisconnected\\n"" , MBUILD_MODNAME , name ) ; }
",0,166
412,"static int jpc_pi_nextpcrl ( register jpc_pi_t * pi ) { int rlvlno ; jpc_pirlvl_t * pirlvl ; jpc_pchg_t * pchg ; int prchind ; int prcvind ; int * prclyrno ; int compno ; jpc_picomp_t * picomp ; int xstep ; int ystep ; uint_fast32_t trx0 ; uint_fast32_t try0 ; uint_fast32_t r ; uint_fast32_t rpx ; uint_fast32_t rpy ; pchg = pi -> pchg ; if ( ! pi -> prgvolfirst ) { goto skip ; } else { pi -> xstep = 0 ; pi -> ystep = 0 ; for ( compno = 0 , picomp = pi -> picomps ; compno < pi -> numcomps ; ++ compno , ++ picomp ) { for ( rlvlno = 0 , pirlvl = picomp -> pirlvls ; rlvlno < picomp -> numrlvls ; ++ rlvlno , ++ pirlvl ) { if ( pirlvl -> prcwidthexpn + pi -> picomp -> numrlvls > JAS_UINTFAST32_NUMBITS - 2 || pirlvl -> prcheightexpn + pi -> picomp -> numrlvls > JAS_UINTFAST32_NUMBITS - 2 ) { return - 1 ; } xstep = picomp -> hsamp * ( JAS_CAST ( uint_fast32_t , 1 ) << ( pirlvl -> prcwidthexpn + picomp -> numrlvls - rlvlno - 1 ) ) ; ystep = picomp -> vsamp * ( JAS_CAST ( uint_fast32_t , 1 ) << ( pirlvl -> prcheightexpn + picomp -> numrlvls - rlvlno - 1 ) ) ; pi -> xstep = ( ! pi -> xstep ) ? xstep : JAS_MIN ( pi -> xstep , xstep ) ; pi -> ystep = ( ! pi -> ystep ) ? ystep : JAS_MIN ( pi -> ystep , ystep ) ; } } pi -> prg
",0,511
413,"extern int onig_new_deluxe ( regex_t * * reg , const UChar * pattern , const UChar * pattern_end , OnigCompileInfo * ci , OnigErrorInfo * einfo ) { int r ; UChar * cpat , * cpat_end ; if ( IS_NOT_NULL ( einfo ) ) einfo -> par = ( UChar * ) NULL ; if ( ci -> pattern_enc != ci -> target_enc ) { return ONIGERR_NOT_SUPPORTED_ENCODING_COMBINATION ; } else { cpat = ( UChar * ) pattern ; cpat_end = ( UChar * ) pattern_end ; } * reg = ( regex_t * ) xmalloc ( sizeof ( regex_t ) ) ; if ( IS_NULL ( * reg ) ) { r = ONIGERR_MEMORY ; goto err2 ; } r = onig_reg_init ( * reg , ci -> option , ci -> case_fold_flag , ci -> target_enc , ci -> syntax ) ; if ( r != 0 ) goto err ; r = onig_compile ( * reg , cpat , cpat_end , einfo ) ; if ( r != 0 ) { err : onig_free ( * reg ) ; * reg = NULL ; } err2 : if ( cpat != pattern ) xfree ( cpat ) ; return r ; }
",1,320
414,"static void InsertRow ( Image * image , ssize_t depth , unsigned char * p , ssize_t y , ExceptionInfo * exception ) { size_t bit ; Quantum index ; register Quantum * q ; Quantum index ; index = 0 ; switch ( depth ) { case 1 : { for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 7 ) ; x += 4 ) { index = ( Quantum ) ( ( ( * p ) & ( 0x80 >> bit ) ) != 0 ) ? 0x01 : 0x00 ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( ( image -> columns % 8 ) != 0 ) { for ( bit = 0 ; bit < ( image -> columns % 8 ) ; bit ++ ) { index = ( Quantum ) ( ( ( ( * p ) & ( 0x80 >> bit ) ) != 0 ) ? 0x01 : 0x00 ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } if ( ( image -> columns % 8 ) != 0 ) { for ( bit = 0 ; bit < ( image -> columns % 8 ) ; bit ++ ) { index = ( Quantum ) ( ( ( ( * p ) & ( 0x80 >> bit ) ) != 0 ) ? 0x01 : 0x00 ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; } p ++ ; } ( void ) SyncAuthenticPixels ( image , exception ) ; break ; } case 2 : { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( Quantum * ) NULL ) break ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 1 ) ; x += 2 ) { index = ConstrainColormapIndex ( image , ( * p >> 6 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image ) ; index = ConstrainColormapIndex ( image , ( * p >> 4 ) & 0x3 , exception ) ; SetPixelIndex ( image , index , q ) ; q += GetPixelChannels ( image )
",0,511
415,"static int cfm_network_addr_print ( netdissect_options * ndo , register const u_char * tptr , const u_int length ) { u_int network_addr_type ; u_int hexdump = FALSE ; if ( length < 1 ) { ND_PRINT ( ( ndo , ""\\n\\tNetworkAddressType(invalid,nodata"" ) ) ; return hexdump ; } network_addr_type = * tptr ; ND_PRINT ( ( ndo , ""\\n\\tNetworkAddressType%s(%u)"" , tok2str ( af_values , ""Unknown"" , network_addr_type ) , network_addr_type ) ) ; switch ( network_addr_type ) { case AFNUM_INET : if ( length < 1 ) { ND_PRINT ( ( ndo , ""(invalidIPv4addresslength%u)"" , length ) ) ; hexdump = TRUE ; break ; } ND_PRINT ( ( ndo , "",%s"" , ipaddr_string ( ndo , tptr + 1 ) ) ) ; break ; case AFNUM_INET6 : if ( length < 1 ) { ND_PRINT ( ( ndo , ""(invalidIPv6addresslength%u)"" , length ) ) ; hexdump = TRUE ; break ; } ND_PRINT ( ( ndo , "",%s"" , ip6addr_string ( ndo , tptr + 1 ) ) ) ; break ; default : hexdump = TRUE ; break ; } return hexdump ; }
",0,340
416,"static int em_sysexit ( struct x86_emulate_ctxt * ctxt ) { const struct x86_emulate_ops * ops = ctxt -> ops ; struct desc_struct cs , ss ; u64 msr_data , rcx , rdx ; int usermode ; u16 cs_sel = 0 , ss_sel = 0 ; if ( ctxt -> mode == X86EMUL_MODE_REAL || ctxt -> mode == X86EMUL_MODE_VM86 ) return emulate_gp ( ctxt , 0 ) ; setup_syscalls_segments ( ctxt , & cs , & ss ) ; if ( ( ctxt -> rex_prefix & 0x8 ) != 0x0 ) usermode = X86EMUL_MODE_PROT64 ; else usermode = X86EMUL_MODE_PROT32 ; rcx = reg_read ( ctxt , VCPU_REGS_RCX ) ; rdx = reg_read ( ctxt , VCPU_REGS_RDX ) ; cs . dpl = 3 ; ss . dpl = 3 ; ops -> get_msr ( ctxt , MSR_IA32_SYSENTER_CS , & msr_data ) ; switch ( usermode ) { case X86EMUL_MODE_PROT32 : cs_sel = ( u16 ) ( msr_data + 16 ) ; if ( ( msr_data & 0xfffc ) == 0x0 ) return emulate_gp ( ctxt , 0 ) ; ss_sel = ( u16 ) ( msr_data + 24 ) ; break ; case X86EMUL_MODE_PROT64 : cs_sel = ( u16 ) ( msr_data + 32 ) ; if ( msr_data == 0x0 ) return emulate_gp ( ctxt , 0 ) ; ss_sel = cs_sel + 8 ; cs . d = 0 ; cs . l = 1 ; if ( rcx != 0 ) ops -> get_msr ( ctxt , MSR_IA32_SYSENTER_CS , & msr_data ) ; break ; } cs_sel |= SELECTOR_RPL_MASK ; ss_sel |= SELECTOR_RPL_MASK ; ops -> set_segment ( ctxt , cs_sel ,
",0,511
417,"static ssize_t driver_override_show ( struct device * dev , struct device_attribute * attr , char * buf ) { struct platform_device * pdev = to_platform_device ( dev ) ; ssize_t len ; device_lock ( dev ) ; len = sprintf ( buf , ""%s\\n"" , pdev -> driver_override ) ; device_unlock ( dev ) ; return len ; }
",1,95
418,"static int cms_copy_content ( BIO * out , BIO * in , unsigned int flags ) { unsigned char buf [ 4096 ] ; int r = 0 , i ; BIO * tmpout ; tmpout = cms_get_text_bio ( out , flags ) ; if ( ! tmpout ) { CMSerr ( CMS_F_CMS_COPY_CONTENT , ERR_R_MALLOC_FAILURE ) ; goto err ; } for ( ; ; ) { i = BIO_read ( in , buf , sizeof ( buf ) ) ; if ( i <= 0 ) { if ( BIO_method_type ( in ) == BIO_TYPE_CIPHER ) { if ( ! BIO_get_cipher_status ( in ) ) goto err ; } if ( i < 0 ) goto err ; break ; } if ( tmpout && ( BIO_write ( tmpout , buf , i ) != i ) ) goto err ; } if ( flags & CMS_TEXT ) { if ( ! tmpout ) { CMSerr ( CMS_F_CMS_COPY_CONTENT , ERR_R_MALLOC_FAILURE ) ; goto err ; } for ( ; ; ) { i = BIO_read ( in , buf , sizeof ( buf ) ) ; if ( i <= 0 ) { if ( BIO_method_type ( in ) == BIO_TYPE_CIPHER ) { if ( ! BIO_get_cipher_status ( in ) ) goto err ; } if ( i < 0 ) goto err ; break ; } if ( tmpout && ( BIO_write ( tmpout , buf , i ) != i ) ) goto err ; } if ( flags & CMS_TEXT ) { if ( ! SMIME_text ( tmpout , out ) ) { CMSerr ( CMS_F_CMS_COPY_CONTENT , CMS_R_SMIME_TEXT_ERROR ) ; goto err ; } } r = 1 ; err : if ( tmpout && ( tmpout != out ) ) BIO_free ( tmpout ) ; return r ; }
",1,465
419,"static void on_response ( void * data , krb5_error_code retval , otp_response response ) { struct request_state rs = * ( struct request_state * ) data ; free ( data ) ; if ( retval == 0 && response != otp_response_success ) retval = KRB5_PREAUTH_FAILED ; rs . enc_tkt_reply ( rs . arg , retval , NULL , NULL , NULL ) ; }
",0,104
420,"static void cost ( int * costs , vpx_tree tree , const vpx_prob * probs , int i , int c ) { const vpx_prob prob = probs [ i / 2 ] ; int b ; for ( b = 0 ; b <= 1 ; ++ b ) { const int cc = c + vp9_cost_bit ( prob , b ) ; const vpx_tree_index ii = tree [ i + b ] ; if ( ii <= 0 ) costs [ - ii ] = cc ; else cost ( costs , tree , probs , ii , cc ) ; } }
",0,131
421,"void init_rc ( void ) { int i ; struct stat st ; FILE * f ; if ( rc_dir != NULL ) goto open_rc ; rc_dir = expandPath ( RC_DIR ) ; i = strlen ( rc_dir ) ; if ( i > 1 && rc_dir [ i - 1 ] == '/' ) rc_dir [ i - 1 ] = '\\0' ; # ifdef USE_M17N display_charset_str = wc_get_ces_list ( ) ; document_charset_str = display_charset_str ; system_charset_str = display_charset_str ; # endif if ( stat ( rc_dir , & st ) < 0 ) { if ( errno == ENOENT ) { if ( do_mkdir ( rc_dir , 0700 ) < 0 ) { goto rc_dir_err ; } else { stat ( rc_dir , & st ) ; } } else { goto rc_dir_err ; } } if ( ! S_ISDIR ( st . st_mode ) ) { goto rc_dir_err ; } if ( ! ( st . st_mode & S_IWUSR ) ) { goto rc_dir_err ; } no_rc_dir = FALSE ; tmp_dir = rc_dir ; if ( config_file == NULL ) config_file = rcFile ( CONFIG_FILE ) ; create_option_search_table ( ) ; open_rc : if ( ( f = fopen ( etcFile ( W3MCONFIG ) , ""rt"" ) ) != NULL ) { interpret_rc ( f ) ; fclose ( f ) ; } if ( ( f = fopen ( confFile ( CONFIG_FILE ) , ""rt"" ) ) != NULL ) { interpret_rc ( f ) ; fclose ( f ) ; } if ( config_file && ( f = fopen ( config_file , ""rt"" ) ) != NULL ) { interpret_rc ( f ) ; fclose ( f ) ; } return ; rc_dir_err : no_rc_dir = TRUE ; if ( ( ( tmp_dir = getenv ( ""TMPDIR"" ) ) == NULL || * tmp_dir == '\\0' ) && ( ( tmp_dir = getenv ( ""TMP"" ) ) == NULL || *
",0,511
422,"static inline void get_conn_text ( const conn * c , const int af , char * addr , struct sockaddr * sock_addr ) { char addr_text [ MAXPATHLEN ] ; addr_text [ 0 ] = '\\0' ; const char * protoname = ""?"" ; unsigned short port = 0 ; size_t pathlen = 0 ; switch ( af ) { case AF_INET : ( void ) inet_ntop ( af , & ( ( struct sockaddr_in * ) sock_addr ) -> sin_addr , addr_text , sizeof ( addr_text ) - 1 ) ; port = ntohs ( ( ( struct sockaddr_in * ) sock_addr ) -> sin_port ) ; protoname = IS_UDP ( c -> transport ) ? ""udp"" : ""tcp"" ; break ; case AF_INET6 : addr_text [ 0 ] = '[' ; addr_text [ 1 ] = '\\0' ; if ( inet_ntop ( af , & ( ( struct sockaddr_in6 * ) sock_addr ) -> sin6_addr , addr_text + 1 , sizeof ( addr_text ) - 2 ) ) { strcat ( addr_text , ""]"" ) ; } port = ntohs ( ( ( struct sockaddr_in6 * ) sock_addr ) -> sin6_port ) ; protoname = IS_UDP ( c -> transport ) ? ""udp6"" : ""tcp6"" ; break ; case AF_UNIX : pathlen = sizeof ( ( ( struct sockaddr_un * ) sock_addr ) -> sun_path ) ; strncpy ( addr_text , ( ( struct sockaddr_un * ) sock_addr ) -> sun_path , pathlen ) ; addr_text [ pathlen ] = '\\0' ; protoname = ""unix"" ; break ; } if ( strlen ( addr_text ) < 2 ) { sprintf ( addr_text , ""<AF%d>"" , af ) ; } if ( port ) { sprintf ( addr , ""%s:%s:%u"" , protoname , addr_text , port ) ; } else { sprintf ( addr , ""%s:%s"" , protoname , addr_text ) ; } }
",0,504
423,"static INLINE void write_buffer_16x16 ( tran_low_t * output , __m128i * in0 , __m128i * in1 , int stride ) { write_buffer_8x8 ( output , in0 , stride ) ; write_buffer_8x8 ( output + 8 * stride , in0 + 8 , stride ) ; output += 8 ; write_buffer_8x8 ( output , in1 , stride ) ; write_buffer_8x8 ( output + 8 * stride , in1 + 8 , stride ) ; }
",1,123
424,"int sequencer_write ( int dev , struct file * file , const char __user * buf , int count ) { unsigned char event_rec [ EV_SZ ] , ev_code ; int p = 0 , c , ev_size ; int mode = translate_mode ( file ) ; dev = dev >> 4 ; DEB ( printk ( ""sequencer_write(dev=%d,count=%d)\\n"" , dev , count ) ) ; if ( mode == OPEN_READ ) return - EIO ; c = count ; while ( c >= 4 ) { if ( copy_from_user ( ( char * ) event_rec , & ( buf ) [ p ] , 4 ) ) goto out ; ev_code = event_rec [ 0 ] ; if ( ev_code == SEQ_FULLSIZE ) { int err , fmt ; dev = * ( unsigned short * ) & event_rec [ 2 ] ; if ( dev < 0 || dev >= max_synthdev || synth_devs [ dev ] == NULL ) return - ENXIO ; if ( ! ( synth_open_mask & ( 1 << dev ) ) ) return - ENXIO ; fmt = ( * ( short * ) & event_rec [ 0 ] ) & 0xffff ; err = synth_devs [ dev ] -> load_patch ( dev , fmt , buf , p + 4 , c , 0 ) ; if ( err < 0 ) return err ; return err ; } if ( ev_code >= 128 ) { if ( seq_mode == SEQ_2 && ev_code == SEQ_EXTENDED ) { printk ( KERN_WARNING ""Sequencer:Invalidlevel2event%x\\n"" , ev_code ) ; return - EINVAL ; } ev_size = 8 ; if ( c < ev_size ) { if ( ! seq_playing ) seq_startplay ( ) ; return count - c ; } if ( copy_from_user ( ( char * ) & event_rec [ 4 ] , & ( buf ) [ p + 4 ] , 4 ) ) goto out ; } else { if ( seq_mode == SEQ_2 ) { printk ( KERN_WARNING ""Sequencer:4byteeventinlevel2mode\\n"" ) ; return - EINVAL ; } ev_size = 4 ; if ( event_rec [ 0 ]
",0,511
425,"static struct page * alloc_huge_page ( struct vm_area_struct * vma , unsigned long addr , int avoid_reserve ) { struct page * page = dequeue_huge_page_vma ( h , vma , addr , avoid_reserve ) ; spin_lock ( & hugetlb_lock ) ; page = dequeue_huge_page_vma ( h , vma , addr , avoid_reserve ) ; spin_unlock ( & hugetlb_lock ) ; if ( ! page ) { page = alloc_buddy_huge_page ( h , NUMA_NO_NODE ) ; if ( ! page ) { page_put_pages ( page ) ; return ERR_PTR ( - VM_FAULT_SIGBUS ) ; } } set_page_private ( page , ( unsigned long ) mapping ) ; vma_commit_reservation ( h , vma , addr ) ; return page ; }
",0,208
426,"static void config_monitor ( config_tree * ptree ) { int_node * pfilegen_token ; const char * filegen_string ; const char * filegen_file ; FILEGEN * filegen ; filegen_node * my_node ; attr_val * my_opts ; int filegen_type ; int filegen_flag ; if ( ptree -> stats_dir ) stats_config ( STATS_STATSDIR , ptree -> stats_dir ) ; pfilegen_token = HEAD_PFIFO ( ptree -> stats_list ) ; for ( ; pfilegen_token != NULL ; pfilegen_token = pfilegen_token -> link ) { filegen_string = keyword ( pfilegen_token -> i ) ; filegen = filegen_get ( filegen_string ) ; if ( NULL == filegen ) { msyslog ( LOG_ERR , ""stats%sunrecognized"" , filegen_string ) ; continue ; } DPRINTF ( 4 , ( ""enablingfilegenfor%sstatistics\'%s%s\'\\n"" , filegen_string , filegen -> prefix , filegen -> basename ) ) ; filegen -> flag |= FGEN_FLAG_ENABLED ; } my_node = HEAD_PFIFO ( ptree -> filegen_opts ) ; for ( ; my_node != NULL ; my_node = my_node -> link ) { filegen_file = keyword ( my_node -> filegen_token ) ; filegen = filegen_get ( filegen_file ) ; if ( NULL == filegen ) { msyslog ( LOG_ERR , ""filegencategory\'%s\'unrecognized"" , filegen_file ) ; continue ; } filegen_flag = filegen -> flag ; filegen_type = filegen -> type ; filegen_flag |= FGEN_FLAG_ENABLED ; my_opts = HEAD_PFIFO ( my_node -> options ) ; for ( ; my_opts != NULL ; my_opts = my_opts -> link ) { switch ( my_opts -> attr ) { case T_File : filegen_file = my_opts -> value . s ; break ; case T_Type : switch ( my_opts -> value . i ) {
",0,511
427,"static void timer_enter_running ( Timer * t ) { _cleanup_bus_error_free_ sd_bus_error error = SD_BUS_ERROR_NULL ; int r ; assert ( t ) ; if ( unit_stop_pending ( UNIT ( t ) ) ) return ; r = manager_add_job ( UNIT ( t ) -> manager , JOB_START , UNIT_TRIGGER ( UNIT ( t ) ) , JOB_REPLACE , true , & error , NULL ) ; if ( r < 0 ) goto fail ; dual_timestamp_get ( & t -> last_trigger ) ; if ( t -> stamp_path ) touch_file ( t -> stamp_path , true , t -> last_trigger . realtime , UID_INVALID , GID_INVALID , MODE_INVALID ) ; timer_set_state ( t , TIMER_RUNNING ) ; return ; fail : log_unit_warning ( UNIT ( t ) , ""Failedtoqueueunitstartupjob:%s"" , bus_error_message ( & error , r ) ) ; timer_enter_dead ( t , TIMER_FAILURE_RESOURCES ) ; }
",1,272
428,"static void fadst16 ( const tran_low_t * input , tran_low_t * output ) { int s0 , s1 , s2 , s3 , s4 , s5 , s6 , s7 , s8 , s9 , s11 , s12 , s13 , s14 , s15 ; tran_high_t x0 = input [ 15 ] ; tran_high_t x1 = input [ 0 ] ; tran_high_t x2 = input [ 13 ] ; tran_high_t x3 = input [ 2 ] ; tran_high_t x4 = input [ 9 ] ; tran_high_t x5 = input [ 4 ] ; tran_high_t x6 = input [ 9 ] ; tran_high_t x7 = input [ 6 ] ; tran_high_t x8 = input [ 7 ] ; tran_high_t x9 = input [ 8 ] ; tran_high_t x10 = input [ 5 ] ; tran_high_t x11 = input [ 10 ] ; tran_high_t x12 = input [ 3 ] ; tran_high_t x13 = input [ 12 ] ; tran_high_t x14 = input [ 1 ] ; tran_high_t x15 = input [ 14 ] ; s0 = x0 * cospi_1_64 + x1 * cospi_31_64 ; s1 = x0 * cospi_31_64 - x1 * cospi_1_64 ; s2 = x2 * cospi_5_64 + x3 * cospi_27_64 ; s3 = x2 * cospi_27_64 - x3 * cospi_5_64 ; s4 = x4 * cospi_9_64 + x5 * cospi_23_64 ; s5 = x4 * cospi_23_64 - x5 * cospi_9_64 ; s6 = x6 * cospi_13_64 + x7 * cospi_19_64 ; s7 = x6 * cospi_19_64 - x7 * cospi_13_64 ; s8 = x8 * cospi_17_64
",0,511
429,"int arm_cpu_caps ( void ) { int flags ; int mask ; if ( ! arm_cpu_env_flags ( & flags ) ) { return flags ; } mask = arm_cpu_env_mask ( ) ; if ( mask & ( ~ flags ) ) { return flags ; } flags |= HAS_EDSP ; # if HAVE_EDSP flags |= HAS_EDSP ; # endif # if HAVE_MEDIA flags |= HAS_MEDIA ; # endif # if HAVE_NEON flags |= HAS_NEON ; # endif return flags & mask ; }
",0,125
430,"PREDICTION_MODE vp9_left_block_mode ( const MODE_INFO * cur_mi , const MODE_INFO * left_mi , int b ) { if ( b == 0 || b == 2 ) { if ( ! left_mi || is_inter_block ( & left_mi -> mbmi ) ) return DC_PRED ; return get_y_mode ( left_mi , b + 1 ) ; } else { assert ( b == 1 || b == 3 ) ; return cur_mi -> bmi [ b - 1 ] . as_mode ; } }
",1,130
431,"static int swabHorAcc16 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) { uint16 * wp = ( uint16 * ) cp0 ; tmsize_t wc = cc / 2 ; TIFFSwabArrayOfShort ( wp , wc ) ; return horAcc16 ( tif , cp0 , cc ) ; }
",1,85
432,"struct ipv6_txoptions * ipv6_renew_options ( struct sock * sk , struct ipv6_txoptions * opt , int newtype , struct ipv6_opt_hdr __user * newopt , int newoptlen ) { int tot_len = 0 ; char * p ; struct ipv6_txoptions * opt2 ; int err ; if ( opt ) { if ( newtype != IPV6_HOPOPTS && opt -> hopopt ) tot_len += CMSG_ALIGN ( ipv6_optlen ( opt -> hopopt ) ) ; if ( newtype != IPV6_RTHDRDSTOPTS && opt -> dst0opt ) tot_len += CMSG_ALIGN ( ipv6_optlen ( opt -> dst0opt ) ) ; if ( newtype != IPV6_RTHDR && opt -> srcrt ) tot_len += CMSG_ALIGN ( ipv6_optlen ( opt -> srcrt ) ) ; if ( newtype != IPV6_DSTOPTS && opt -> dst1opt ) tot_len += CMSG_ALIGN ( ipv6_optlen ( opt -> dst1opt ) ) ; } if ( newopt && newoptlen ) tot_len += CMSG_ALIGN ( newoptlen ) ; if ( ! tot_len ) return NULL ; tot_len += sizeof ( * opt2 ) ; opt2 = sock_kmalloc ( sk , tot_len , GFP_ATOMIC ) ; if ( ! opt2 ) return ERR_PTR ( - ENOBUFS ) ; memset ( opt2 , 0 , tot_len ) ; opt2 -> tot_len = tot_len ; p = ( char * ) ( opt2 + 1 ) ; err = ipv6_renew_option ( opt ? opt -> hopopt : NULL , newopt , newoptlen , newtype != IPV6_HOPOPTS , & opt2 -> hopopt , & p ) ; if ( err ) goto out ; err = ipv6_renew_option ( opt ? opt -> dst0opt : NULL , newopt , newoptlen , newtype != IPV6_RTHDRDSTOPTS , & opt2 -> dst0opt , & p ) ; if ( err ) goto out ; err
",0,511
433,"static int cine_read_header ( AVFormatContext * avctx ) { AVIOContext * pb = avctx -> pb ; AVStream * st ; unsigned int version , compression , offImageHeader , offSetup , offImageOffsets , biBitCount , length , CFA ; int vflip ; char * description ; uint64_t i ; st = avformat_new_stream ( avctx , NULL ) ; if ( ! st ) return AVERROR ( ENOMEM ) ; st -> codecpar -> codec_type = AVMEDIA_TYPE_VIDEO ; st -> codecpar -> codec_id = AV_CODEC_ID_RAWVIDEO ; st -> codecpar -> codec_tag = 0 ; avio_skip ( pb , 4 ) ; compression = avio_rl16 ( pb ) ; version = avio_rl16 ( pb ) ; if ( version != 1 ) { avpriv_request_sample ( avctx , ""unknownversion%i"" , version ) ; return AVERROR_INVALIDDATA ; } avio_skip ( pb , 12 ) ; st -> duration = avio_rl32 ( pb ) ; offImageHeader = avio_rl32 ( pb ) ; offSetup = avio_rl32 ( pb ) ; offImageOffsets = avio_rl32 ( pb ) ; avio_skip ( pb , 8 ) ; avio_seek ( pb , offImageHeader , SEEK_SET ) ; avio_skip ( pb , 4 ) ; st -> codecpar -> width = avio_rl32 ( pb ) ; st -> codecpar -> height = avio_rl32 ( pb ) ; if ( avio_rl16 ( pb ) != 1 ) return AVERROR_INVALIDDATA ; biBitCount = avio_rl16 ( pb ) ; if ( biBitCount != 8 && biBitCount != 16 && biBitCount != 24 && biBitCount != 48 ) { avpriv_request_sample ( avctx , ""unsupportedbiBitCount%i"" , biBitCount ) ; return AVERROR_INVALIDDATA ; } switch ( avio_rl32 ( pb ) ) { case BMP_RGB : vflip = 0 ; break ; case 0x100 : st -> codecpar -> codec_tag
",0,511
434,"int asn1_ber_decoder ( const struct asn1_decoder * decoder , void * context , const unsigned char * data , size_t datalen ) { const unsigned char * machine = decoder -> machine ; const asn1_action_t * actions = decoder -> actions ; size_t machlen = decoder -> machlen ; enum asn1_opcode op ; unsigned char tag = 0 , csp = 0 , jsp = 0 , optag = 0 , hdr = 0 ; const char * errmsg ; size_t pc = 0 , dp = 0 , tdp = 0 , len = 0 ; int ret ; unsigned char flags = 0 ; # define FLAG_INDEFINITE_LENGTH 0x01 # define FLAG_MATCHED 0x02 # define FLAG_LAST_MATCHED 0x04 # define FLAG_CONS 0x20 # define NR_CONS_STACK 10 unsigned short cons_dp_stack [ NR_CONS_STACK ] ; unsigned short cons_datalen_stack [ NR_CONS_STACK ] ; unsigned char cons_hdrlen_stack [ NR_CONS_STACK ] ; # define NR_JUMP_STACK 10 unsigned char jump_stack [ NR_JUMP_STACK ] ; if ( datalen > 65535 ) return - EMSGSIZE ; next_op : pr_debug ( ""next_op:pc=\\e[32m%zu\\e[m/%zudp=\\e[33m%zu\\e[m/%zuC=%dJ=%d\\n"" , pc , machlen , dp , datalen , csp , jsp ) ; if ( unlikely ( pc >= machlen ) ) goto machine_overrun_error ; op = machine [ pc ] ; if ( unlikely ( pc + asn1_op_lengths [ op ] > machlen ) ) goto machine_overrun_error ; if ( op <= ASN1_OP__MATCHES_TAG ) { unsigned char tmp ; if ( ( op & ASN1_OP_MATCH__COND && flags & FLAG_MATCHED ) || dp == datalen ) { flags &= ~ FLAG_LAST_MATCHED ; pc += AS
",0,511
435,"static int cg_rmdir ( const char * path ) { struct fuse_context * fc = fuse_get_context ( ) ; char * fpath = NULL , * cgdir = NULL , * controller , * next = NULL ; const char * cgroup ; int ret ; if ( ! fc ) return - EIO ; controller = pick_controller_from_path ( fc , path ) ; if ( ! controller ) return - EINVAL ; cgroup = find_cgroup_in_path ( path ) ; if ( ! cgroup ) return - EINVAL ; get_cgdir_and_path ( cgroup , & cgdir , & fpath ) ; if ( ! fpath ) { ret = - EINVAL ; goto out ; } if ( ! fc_may_access ( fc , controller , cgdir , NULL , O_WRONLY ) ) { ret = - EACCES ; goto out ; } if ( ! fpath || ! caller_is_in_ancestor ( fc -> pid , controller , cgroup , & next ) ) { ret = - EACCES ; goto out ; } if ( ! fc_may_access ( fc , controller , cgdir , NULL , O_WRONLY ) ) { ret = - EACCES ; goto out ; } if ( ! cgfs_remove ( controller , cgroup ) ) { ret = - EINVAL ; goto out ; } ret = 0 ; out : free ( cgdir ) ; free ( next ) ; return ret ; }
",0,341
436,"static struct mount * clone_mnt ( struct mount * old , struct dentry * root , int flag ) { struct super_block * sb = old -> mnt . mnt_sb ; struct mount * mnt ; int err ; mnt = alloc_vfsmnt ( old -> mnt_devname ) ; if ( ! mnt ) return ERR_PTR ( - ENOMEM ) ; if ( flag & ( CL_SLAVE | CL_PRIVATE | CL_SHARED_TO_SLAVE ) ) mnt -> mnt_group_id = 0 ; else mnt -> mnt_group_id = old -> mnt_group_id ; if ( ( flag & CL_MAKE_SHARED ) && ! mnt -> mnt_group_id ) { err = mnt_alloc_group_id ( mnt ) ; if ( err ) goto out_free ; } mnt -> mnt . mnt_flags = old -> mnt . mnt_flags & ~ ( MNT_WRITE_HOLD | MNT_MARKED ) ; if ( ( flag & CL_UNPRIVILEGED ) && ( mnt -> mnt . mnt_flags & MNT_READONLY ) ) mnt -> mnt . mnt_flags |= MNT_LOCK_READONLY ; if ( ( flag & CL_UNPRIVILEGED ) && list_empty ( & old -> mnt_expire ) ) mnt -> mnt . mnt_flags |= MNT_LOCKED ; atomic_inc ( & sb -> s_active ) ; mnt -> mnt . mnt_sb = sb ; mnt -> mnt . mnt_root = dget ( root ) ; mnt -> mnt_mountpoint = mnt -> mnt . mnt_root ; mnt -> mnt_parent = mnt ; lock_mount_hash ( ) ; list_add_tail ( & mnt -> mnt_instance , & sb -> s_mounts ) ; unlock_mount_hash ( ) ; if ( ( flag & CL_SLAVE ) || ( ( flag & CL_SHARED_TO_SLAVE ) && IS_MNT_SHARED ( old ) ) ) { list_add_tail
",0,511
437,"static struct rds_connection * __rds_conn_create ( struct net * net , __be32 laddr , __be32 faddr , struct rds_transport * trans , gfp_t gfp , int is_outgoing ) { struct rds_connection * conn , * parent = NULL ; struct hlist_head * head = rds_conn_bucket ( laddr , faddr ) ; struct rds_transport * loop_trans ; unsigned long flags ; int ret ; rcu_read_lock ( ) ; conn = rds_conn_lookup ( net , head , laddr , faddr , trans ) ; if ( conn && conn -> c_loopback && conn -> c_trans != & rds_loop_transport && laddr == faddr && ! is_outgoing ) { parent = conn ; conn = parent -> c_passive ; } rcu_read_unlock ( ) ; if ( conn ) goto out ; conn = kmem_cache_zalloc ( rds_conn_slab , gfp ) ; if ( ! conn ) { conn = ERR_PTR ( - ENOMEM ) ; goto out ; } INIT_HLIST_NODE ( & conn -> c_hash_node ) ; conn -> c_laddr = laddr ; conn -> c_faddr = faddr ; spin_lock_init ( & conn -> c_lock ) ; conn -> c_next_tx_seq = 1 ; rds_conn_net_set ( conn , net ) ; init_waitqueue_head ( & conn -> c_waitq ) ; INIT_LIST_HEAD ( & conn -> c_send_queue ) ; INIT_LIST_HEAD ( & conn -> c_retrans ) ; ret = rds_cong_get_maps ( conn ) ; if ( ret ) { kmem_cache_free ( rds_conn_slab , conn ) ; conn = ERR_PTR ( ret ) ; goto out ; } loop_trans = rds_trans_get_preferred ( net , faddr ) ; if ( loop_trans ) { rds_trans_put ( loop_trans ) ; conn -> c_loopback = 1 ; if ( is_outgoing && trans -> t_prefer_loopback ) { trans = & rds_loop
",0,511
438,"static __u8 * sp_report_fixup ( struct hid_device * hdev , __u8 * rdesc , unsigned int * rsize ) { if ( * rsize >= 112 && rdesc [ 104 ] == 0x26 && rdesc [ 105 ] == 0x80 && rdesc [ 106 ] == 0x03 ) { hid_info ( hdev , ""fixingupSunplusWirelessDesktopreportdescriptor\\n"" ) ; rdesc [ 105 ] = rdesc [ 110 ] = 0x03 ; rdesc [ 106 ] = rdesc [ 111 ] = 0x21 ; } return rdesc ; }
",1,137
439,"static INT AirPDcapScanForKeys ( PAIRPDCAP_CONTEXT ctx , const guint8 * data , const guint mac_header_len , const guint tot_len , AIRPDCAP_SEC_ASSOCIATION_ID id ) { const UCHAR * addr ; guint bodyLength ; PAIRPDCAP_SEC_ASSOCIATION sta_sa ; PAIRPDCAP_SEC_ASSOCIATION sa ; guint offset = 0 ; const guint8 dot1x_header [ ] = { 0xAA , 0xAA , 0x03 , 0x00 , 0x00 , 0x00 , 0x88 , 0x8E } ; const guint8 bt_dot1x_header [ ] = { 0xAA , 0xAA , 0x03 , 0x00 , 0x19 , 0x58 , 0x00 , 0x03 } ; const guint8 tdls_header [ ] = { 0xAA , 0xAA , 0x03 , 0x00 , 0x00 , 0x00 , 0x89 , 0x0D , 0x02 , 0X0C } ; const EAPOL_RSN_KEY * pEAPKey ; # ifdef _DEBUG # define MSGBUF_LEN 255 CHAR msgbuf [ MSGBUF_LEN ] ; # endif AIRPDCAP_DEBUG_TRACE_START ( ""AirPDcapScanForKeys"" ) ; offset = mac_header_len ; if ( memcmp ( data + offset , dot1x_header , 8 ) == 0 || memcmp ( data + offset , bt_dot1x_header , 8 ) == 0 ) { AIRPDCAP_DEBUG_PRINT_LINE ( ""AirPDcapScanForKeys"" , ""Authentication:EAPOLpacket"" , AIRPDCAP_DEBUG_LEVEL_3 ) ; offset += 8 ; if ( data [ offset + 1 ] != 3 ) { AIRPDCAP_DEBUG_PRINT_LINE ( ""AirPDcapScanForKeys"" , ""NotEAPOL-Key"" , AIRPDCAP_DEBUG_LEVEL_3 ) ; return AIRPDCAP_RET_NO_VALID_HANDSHAKE ; } bodyLength = pntoh16 ( data + offset + 2 ) ; if ( ( ( tot_
",0,511
440,"static irqreturn_t i8042_interrupt ( int irq , void * dev_id ) { struct i8042_port * port ; struct serio * serio ; unsigned long flags ; unsigned char str , data ; unsigned int dfl ; unsigned int port_no ; bool filtered ; int ret = 1 ; spin_lock_irqsave ( & i8042_lock , flags ) ; str = i8042_read_status ( ) ; if ( unlikely ( ~ str & I8042_STR_OBF ) ) { spin_unlock_irqrestore ( & i8042_lock , flags ) ; if ( irq ) dbg ( ""Interrupt%d,withoutanydata\\n"" , irq ) ; ret = 0 ; goto out ; } data = i8042_read_data ( ) ; if ( i8042_mux_present && ( str & I8042_STR_AUXDATA ) ) { static unsigned long last_transmit ; static unsigned char last_str ; dfl = 0 ; if ( str & I8042_STR_MUXERR ) { dbg ( ""MUXerror,statusis%02x,datais%02x\\n"" , str , data ) ; switch ( data ) { default : if ( time_before ( jiffies , last_transmit + HZ / 10 ) ) { str = last_str ; break ; } case 0xfc : case 0xfd : case 0xfe : dfl = SERIO_TIMEOUT ; data = 0xfe ; break ; case 0xff : dfl = SERIO_PARITY ; data = 0xfe ; break ; } } port_no = I8042_MUX_PORT_NO + ( ( str >> 6 ) & 3 ) ; last_str = str ; last_transmit = jiffies ; } else { dfl = ( ( str & I8042_STR_PARITY ) ? SERIO_PARITY : 0 ) | ( ( str & I8042_STR_TIMEOUT && ! i8042_notimeout ) ? SERIO_TIMEOUT : 0 ) ; port_no = ( str & I8042_STR_AUXDATA ) ? I8042_AUX_PORT_NO : I8042_KBD_PORT_NO ; } port = &
",0,511
441,"static void interp_reply ( netdissect_options * ndo , const struct sunrpc_msg * rp , uint32_t proc , uint32_t vers , int length ) { register const uint32_t * dp ; register int v3 ; int er ; v3 = ( vers == NFS_VER3 ) ; if ( ! v3 && proc < NFS_NPROCS ) proc = nfsv3_procid [ proc ] ; ND_PRINT ( ( ndo , ""%s"" , tok2str ( nfsproc_str , ""proc-%u"" , proc ) ) ) ; switch ( proc ) { case NFSPROC_GETATTR : dp = parserep ( ndo , rp , length ) ; if ( dp != NULL && parseattrstat ( ndo , dp , ! ndo -> ndo_qflag , v3 ) != 0 ) return ; break ; case NFSPROC_SETATTR : if ( ! ( dp = parserep ( ndo , rp , length ) ) ) return ; if ( v3 ) { if ( parsewccres ( ndo , dp , ndo -> ndo_vflag ) ) return ; } else { if ( parseattrstat ( ndo , dp , ! ndo -> ndo_qflag , 0 ) != 0 ) return ; } break ; case NFSPROC_LOOKUP : if ( ! ( dp = parserep ( ndo , rp , length ) ) ) break ; if ( v3 ) { if ( ! ( dp = parsestatus ( ndo , dp , & er ) ) ) break ; if ( er ) { if ( ndo -> ndo_vflag > 1 ) { ND_PRINT ( ( ndo , ""postdattr:"" ) ) ; dp = parse_post_op_attr ( ndo , dp , ndo -> ndo_vflag ) ; } } else { if ( ! ( dp = parsefh ( ndo , dp , v3 ) ) ) break ; if ( ( dp = parse_post_op_attr ( ndo , dp , ndo -> ndo_vflag ) ) && ndo -> ndo_vflag > 1 ) { ND_PRINT ( ( ndo , ""post
",0,511
442,"static int udf_translate_to_linux ( uint8_t * newName , int newLen , uint8_t * udfName , int udfLen , uint8_t * fidName , int fidNameLen ) { int index , newIndex = 0 , needsCRC = 0 ; int extIndex = 0 , newExtIndex = 0 , hasExt = 0 ; unsigned short valueCRC ; uint8_t curr ; if ( udfName [ 0 ] == '.' && ( udfLen == 1 || ( udfLen == 2 && udfName [ 1 ] == '.' ) ) ) { needsCRC = 1 ; newIndex = udfLen ; memcpy ( newName , udfName , udfLen ) ; } else { for ( index = 0 ; index < udfLen ; index ++ ) { curr = udfName [ index ] ; if ( curr == '/' || curr == 0 ) { needsCRC = 1 ; curr = ILLEGAL_CHAR_MARK ; while ( index + 1 < udfLen && ( udfName [ index + 1 ] == '/' || udfName [ index + 1 ] == 0 ) ) index ++ ; } if ( curr == EXT_MARK && ( udfLen - index - 1 ) <= EXT_SIZE ) { if ( udfLen == index + 1 ) hasExt = 0 ; else { hasExt = 1 ; extIndex = index ; newExtIndex = newIndex ; } } if ( newIndex < newLen ) newName [ newIndex ++ ] = curr ; else needsCRC = 1 ; } } if ( needsCRC ) { uint8_t ext [ EXT_SIZE ] ; int localExtIndex = 0 ; if ( hasExt ) { int maxFilenameLen ; for ( index = 0 ; index < EXT_SIZE && extIndex + index + 1 < udfLen ; index ++ ) { curr = udfName [ extIndex + index + 1 ] ; if ( curr == '/' || curr == 0 ) { needsCRC = 1 ; curr = ILLEGAL_CHAR_MARK ; while ( extIndex + index + 2 < udfLen && ( index + 1 < EXT_SIZE && ( udfName [ extIndex + index + 2 ] == '/' || udfName [ extIndex +
",0,511
443,"static void count_segs_sb ( const VP9_COMMON * cm , MACROBLOCKD * xd , const TileInfo * const tile , MODE_INFO * * mi_8x8 , int * no_pred_segcounts , int ( * temporal_predictor_count ) [ 2 ] , int * t_unpred_seg_counts , int mi_row , int mi_col , BLOCK_SIZE bsize ) { const VP9_COMMON * const cm = & cpi -> common ; const int mis = cm -> mi_stride ; int bw , bh ; const int bs = num_8x8_blocks_wide_lookup [ bsize ] , hbs = bs / 2 ; if ( mi_row >= cm -> mi_rows || mi_col >= cm -> mi_cols ) return ; bw = num_8x8_blocks_wide_lookup [ mi_8x8 [ 0 ] -> mbmi . sb_type ] ; bh = num_8x8_blocks_high_lookup [ mi_8x8 [ 0 ] -> mbmi . sb_type ] ; if ( bw == bs && bh == bs ) { count_segs ( cpi , xd , tile , mi_8x8 , no_pred_segcounts , temporal_predictor_count , t_unpred_seg_counts , bs , bs , mi_row , mi_col ) ; } else if ( bw == bs && bh < bs ) { count_segs ( xd , tile , mi_8x8 , no_pred_segcounts , temporal_predictor_count , t_unpred_seg_counts , bs , hbs , mi_row , mi_col ) ; count_segs ( xd , tile , mi_8x8 + hbs * mis , no_pred_segcounts , temporal_predictor_count , t_unpred_seg_counts , bs , hbs , mi_row + hbs , mi_col ) ; } else if ( bw < bs && bh == bs ) { count_segs ( xd , tile , mi
",0,511
444,"void processInputBuffer ( client * c ) { server . current_client = c ; while ( sdslen ( c -> querybuf ) ) { if ( ! ( c -> flags & CLIENT_SLAVE ) && clientsArePaused ( ) ) break ; if ( c -> flags & CLIENT_BLOCKED ) break ; if ( c -> flags & CLIENT_CLOSE_AFTER_REPLY ) break ; if ( ! c -> reqtype ) { if ( c -> querybuf [ 0 ] == '*' ) { c -> reqtype = PROTO_REQ_MULTIBULK ; } else { c -> reqtype = PROTO_REQ_INLINE ; } } if ( c -> reqtype == PROTO_REQ_INLINE ) { if ( processInlineBuffer ( c ) != C_OK ) break ; } else if ( c -> reqtype == PROTO_REQ_MULTIBULK ) { if ( processMultibulkBuffer ( c ) != C_OK ) break ; } else { serverPanic ( ""Unknownrequesttype"" ) ; } if ( c -> argc == 0 ) { resetClient ( c ) ; } else { if ( processCommand ( c ) == C_OK ) resetClient ( c ) ; if ( server . current_client == NULL ) break ; } } server . current_client = NULL ; }
",0,296
445,"static int mpage_da_map_blocks ( struct mpage_da_data * mpd ) { int err , blks , get_blocks_flags ; struct buffer_head new ; sector_t next = mpd -> b_blocknr ; unsigned max_blocks = mpd -> b_size >> mpd -> inode -> i_blkbits ; loff_t disksize = EXT4_I ( mpd -> inode ) -> i_disksize ; handle_t * handle = NULL ; if ( ( mpd -> b_state & ( 1 << BH_Mapped ) ) && ! ( mpd -> b_state & ( 1 << BH_Delay ) ) && ! ( mpd -> b_state & ( 1 << BH_Unwritten ) ) ) return 0 ; if ( ! mpd -> b_size ) return 0 ; handle = ext4_journal_current_handle ( ) ; BUG_ON ( ! handle ) ; new . b_state = 0 ; get_blocks_flags = EXT4_GET_BLOCKS_CONVERT ; if ( mpd -> b_state & ( 1 << BH_Delay ) ) get_blocks_flags |= EXT4_GET_BLOCKS_DELALLOC_RESERVE ; blks = ext4_get_blocks ( handle , mpd -> inode , next , max_blocks , & new , get_blocks_flags ) ; if ( blks < 0 ) { err = blks ; if ( err == - EAGAIN ) return 0 ; if ( err == - ENOSPC && ext4_count_free_blocks ( mpd -> inode -> i_sb ) ) { mpd -> retval = err ; return 0 ; } ext4_msg ( mpd -> inode -> i_sb , KERN_CRIT , ""delayedblockallocationfailedforinode%luat"" ""logicaloffset%lluwithmaxblocks%zdwith"" ""error%d\\n"" , mpd -> inode -> i_ino , ( unsigned long long ) next , mpd -> b_size >> mpd -> inode -> i_blkbits , err ) ; printk ( KERN_CRIT ""Thisshouldnothappen!!"" ""Datawillbelost\\n"" ) ; if ( mp
",0,511
446,"int DSA_verify ( int type , const unsigned char * dgst , int dgst_len , const unsigned char * sigbuf , int siglen , DSA * dsa ) { DSA_SIG * s ; const unsigned char * p = sigbuf ; unsigned char * der = NULL ; int derlen = - 1 ; int ret = - 1 ; s = DSA_SIG_new ( ) ; if ( s == NULL ) return ( ret ) ; if ( d2i_DSA_SIG ( & s , & p , siglen ) == NULL ) goto err ; derlen = i2d_DSA_SIG ( s , & der ) ; if ( derlen != siglen || memcmp ( sigbuf , der , derlen ) ) goto err ; ret = DSA_do_verify ( dgst , dgst_len , s , dsa ) ; err : if ( derlen > 0 ) { OPENSSL_cleanse ( der , derlen ) ; OPENSSL_free ( der ) ; } DSA_SIG_free ( s ) ; return ( ret ) ; }
",1,247
447,"void * gdImageGifPtr ( gdImagePtr im , int * size ) { void * rv ; gdIOCtx * out = gdNewDynamicCtx ( 2048 , NULL ) ; if ( ! _gdImageGifCtx ( im , out ) ) { rv = gdDPExtractData ( out , size ) ; } else { rv = NULL ; } out -> gd_free ( out ) ; return rv ; }
",1,102
448,"void free_bprm ( struct linux_binprm * bprm ) { free_arg_pages ( bprm ) ; if ( bprm -> cred ) { mutex_unlock ( & current -> signal -> cred_guard_mutex ) ; abort_creds ( bprm -> cred ) ; } kfree ( bprm ) ; }
",0,82
449,"static int _hostresolver_getaddrinfo ( oe_resolver_t * resolver , const char * node , const char * service , const struct oe_addrinfo * hints , struct oe_addrinfo * * res ) { int ret = OE_EAI_FAIL ; uint64_t handle = 0 ; struct oe_addrinfo * head = NULL ; struct oe_addrinfo * tail = NULL ; struct oe_addrinfo * p = NULL ; OE_UNUSED ( resolver ) ; if ( res ) * res = NULL ; if ( ! res ) { ret = OE_EAI_SYSTEM ; OE_RAISE_ERRNO ( OE_EINVAL ) ; } { int retval = OE_EAI_FAIL ; if ( oe_syscall_getaddrinfo_open_ocall ( & retval , node , service , hints , & handle ) != OE_OK ) { ret = OE_EAI_SYSTEM ; OE_RAISE_ERRNO ( OE_EINVAL ) ; } if ( ! handle ) { ret = retval ; goto done ; } } for ( ; ; ) { int retval = 0 ; size_t canonnamelen = 0 ; size_t addrlen = 0 ; if ( ! ( p = oe_calloc ( 1 , sizeof ( struct oe_addrinfo ) ) ) ) { ret = OE_EAI_MEMORY ; goto done ; } if ( oe_syscall_getaddrinfo_read_ocall ( & retval , handle , & p -> ai_flags , & p -> ai_family , & p -> ai_socktype , & p -> ai_protocol , p -> ai_addrlen , & p -> ai_addrlen , NULL , canonnamelen , & canonnamelen , NULL ) != OE_OK ) { ret = OE_EAI_SYSTEM ; OE_RAISE_ERRNO ( OE_EINVAL ) ; } if ( retval == 1 ) break ; if ( retval != - 1 || oe_errno != OE_ENAMETOOLONG ) { ret = OE_EAI_SYSTEM ; OE_RAISE_ER
",0,511
450,"void httpParseAuthorizationField ( HttpConnection * connection , char_t * value ) { char_t * p ; char_t * token ; token = osStrtok_r ( value , ""\\t"" , & p ) ; if ( token == NULL ) { return ; } # if ( HTTP_SERVER_BASIC_AUTH_SUPPORT == ENABLED ) else if ( ! osStrcasecmp ( token , ""Basic"" ) ) { error_t error ; size_t n ; char_t * separator ; connection -> request . auth . mode = HTTP_AUTH_MODE_BASIC ; token = osStrtok_r ( NULL , ""\\t"" , & p ) ; if ( token != NULL ) { error = base64Decode ( token , osStrlen ( token ) , token , & n ) ; if ( ! error ) { token [ n ] = '\\0' ; separator = osStrchr ( token , ':' ) ; if ( separator != NULL ) { * separator = '\\0' ; strSafeCopy ( connection -> request . auth . user , token , HTTP_SERVER_USERNAME_MAX_LEN ) ; token = separator + 1 ; connection -> request . auth . password = token ; } } } } TRACE_DEBUG ( ""Authorizationheader:\\r\\n"" ) ; TRACE_DEBUG ( ""username:%s\\r\\n"" , connection -> request . auth . user ) ; TRACE_DEBUG ( ""password:%s\\r\\n"" , connection -> request . auth . password ) ; } # endif # if ( HTTP_SERVER_DIGEST_AUTH_SUPPORT == ENABLED ) else if ( ! osStrcasecmp ( token , ""Digest"" ) ) { size_t n ; char_t * separator ; char_t * name ; connection -> request . auth . mode = HTTP_AUTH_MODE_DIGEST ; token = osStrtok_r ( NULL , "","" , & p ) ; while ( token != NULL ) { separator = osStrchr ( token , '=' ) ; if ( separator != NULL ) { * separator = '\\0' ; name = strTrimWhitespace ( token ) ; value = strTrimWhitespace
",0,511
451,"static int iwgif_read_image ( struct iwgifrcontext * rctx ) { int retval = 0 ; struct lzwdeccontext d ; size_t subblocksize ; int has_local_ct ; int local_ct_size ; unsigned int root_codesize ; if ( ! iwgif_read ( rctx , rctx -> rbuf , 9 ) ) goto done ; rctx -> image_left = ( int ) iw_get_ui16le ( & rctx -> rbuf [ 0 ] ) ; rctx -> image_top = ( int ) iw_get_ui16le ( & rctx -> rbuf [ 2 ] ) ; rctx -> image_width = ( int ) iw_get_ui16le ( & rctx -> rbuf [ 4 ] ) ; rctx -> image_height = ( int ) iw_get_ui16le ( & rctx -> rbuf [ 6 ] ) ; rctx -> interlaced = ( int ) ( ( rctx -> rbuf [ 8 ] >> 6 ) & 0x01 ) ; has_local_ct = ( int ) ( ( rctx -> rbuf [ 8 ] >> 7 ) & 0x01 ) ; if ( has_local_ct ) { local_ct_size = ( int ) ( rctx -> rbuf [ 8 ] & 0x07 ) ; rctx -> colortable . num_entries = 1 << ( 1 + local_ct_size ) ; } if ( has_local_ct ) { if ( ! iwgif_read_color_table ( rctx , & rctx -> colortable ) ) goto done ; } if ( rctx -> has_transparency ) { rctx -> colortable . entry [ rctx -> trans_color_index ] . a = 0 ; } if ( ! iwgif_read ( rctx , rctx -> rbuf , 1 ) ) goto done ; root_codesize = ( unsigned int ) rctx -> rbuf [ 0 ] ; if ( root_codesize < 2 || root_codesize > 11 ) { iw_set_error ( rctx -> ctx , ""InvalidLZWminimumcodesize"" ) ; goto done ; } if ( ! iwgif_init_screen ( rctx ) ) goto done ; rctx -> total_npixels =
",0,511
452,"void vp8_default_coef_probs ( VP8_COMMON * pc ) { memcpy ( pc -> fc . coef_probs , default_coef_probs , sizeof ( default_coef_probs ) ) ; }
",1,59
453,"static int set_registers ( pegasus_t * pegasus , __u16 indx , __u16 size , void * data ) { u8 * buf ; int ret ; buf = kmemdup ( data , size , GFP_NOIO ) ; if ( ! buf ) return - ENOMEM ; ret = usb_control_msg ( pegasus -> usb , usb_sndctrlpipe ( pegasus -> usb , 0 ) , PEGASUS_REQ_SET_REGS , PEGASUS_REQT_WRITE , 0 , indx , buf , size , 100 ) ; if ( ret < 0 ) netif_dbg ( pegasus , drv , pegasus -> net , ""%sreturned%d\\n"" , __func__ , ret ) ; kfree ( buf ) ; return ret ; }
",0,190
454,"mod_ty Module ( asdl_seq * body ) { mod_ty p ; p = ( mod_ty ) PyArena_Malloc ( arena , sizeof ( * p ) ) ; if ( ! p ) return NULL ; p -> kind = Module_kind ; p -> v . Module . body = body ; return p ; }
",0,72
455,"void sas_unregister_dev ( struct asd_sas_port * port , struct domain_device * dev ) { if ( ! test_bit ( SAS_DEV_DESTROY , & dev -> state ) && ! list_empty ( & dev -> disco_list_node ) ) { list_del_init ( & dev -> disco_list_node ) ; sas_rphy_free ( dev -> rphy ) ; sas_unregister_common_dev ( port , dev ) ; return ; } if ( ! test_and_set_bit ( SAS_DEV_DESTROY , & dev -> state ) ) { sas_rphy_unlink ( dev -> rphy ) ; list_move_tail ( & dev -> disco_list_node , & port -> destroy_list ) ; } }
",1,180
456,"int vp9_lookahead_push ( struct lookahead_ctx * ctx , YV12_BUFFER_CONFIG * src , int64_t ts_start , int64_t ts_end , unsigned int flags ) { struct lookahead_entry * buf ; # if USE_PARTIAL_COPY int row , col , active_end ; int mb_rows = ( src -> y_height + 15 ) >> 4 ; int mb_cols = ( src -> y_width + 15 ) >> 4 ; # if CONFIG_VP9_HIGHBITDEPTH if ( ctx -> sz + 1 + MAX_PRE_FRAMES > ctx -> max_sz ) return 1 ; ctx -> sz ++ ; buf = pop ( ctx , & ctx -> write_idx ) ; # if USE_PARTIAL_COPY # if ( ctx -> max_sz == 1 && active_map && ! flags ) { for ( row = 0 ; row < mb_rows ; ++ row ) { col = 0 ; while ( 1 ) { for ( ; col < mb_cols ; ++ col ) { if ( active_map [ col ] ) break ; } if ( col == mb_cols ) break ; active_end = col ; for ( ; active_end < mb_cols ; ++ active_end ) { if ( ! active_map [ active_end ] ) break ; } vp9_copy_and_extend_frame_with_rect ( src , & buf -> img , row << 4 , col << 4 , 16 , ( active_end - col ) << 4 ) ; col = active_end ; } active_map += mb_cols ; } } else { vp9_copy_and_extend_frame ( src , & buf -> img ) ; } # else vp9_copy_and_extend_frame ( src , & buf -> img ) ; # endif buf -> ts_start = ts_start ; buf -> ts_end = ts_end ; buf -> flags = flags ; return 0 ; }
",0,460
457,"static int cuse_channel_release ( struct inode * inode , struct file * file ) { struct fuse_dev * fud = file -> private_data ; struct cuse_conn * cc = fc_to_cc ( fud -> fc ) ; int rc ; mutex_lock ( & cuse_lock ) ; list_del_init ( & cc -> list ) ; mutex_unlock ( & cuse_lock ) ; if ( cc -> dev ) device_unregister ( cc -> dev ) ; if ( cc -> cdev ) { unregister_chrdev_region ( cc -> cdev -> dev , 1 ) ; cdev_del ( cc -> cdev ) ; } fuse_conn_put ( & cc -> conn ) ; rc = fuse_dev_release ( inode , file ) ; return rc ; }
",0,184
458,"static krb5_error_code kdc_process_s4u_x509_user ( krb5_context context , krb5_kdc_req * request , krb5_pa_data * pa_data , krb5_keyblock * tgs_subkey , krb5_keyblock * tgs_session , krb5_pa_s4u_x509_user * * s4u_x509_user , const char * * status ) { krb5_error_code code ; krb5_data req_data ; req_data . length = pa_data -> length ; req_data . data = ( char * ) pa_data -> contents ; code = decode_krb5_pa_s4u_x509_user ( & req_data , s4u_x509_user ) ; if ( code ) { * status = ""DECODE_PA_S4U2SELF_CHECKSUM"" ; krb5_free_pa_s4u_x509_user ( context , * s4u_x509_user ) ; * s4u_x509_user = NULL ; return code ; } if ( krb5_princ_size ( context , ( * s4u_x509_user ) -> user_id . user ) == 0 || ( * s4u_x509_user ) -> user_id . subject_cert . length != 0 ) { * status = ""INVALID_S4U2SELF_REQUEST"" ; krb5_free_pa_s4u_x509_user ( context , * s4u_x509_user ) ; * s4u_x509_user = NULL ; return KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN ; } return 0 ; }
",0,407
459,"static int scsi_disk_emulate_command ( SCSIDiskReq * r ) { SCSIRequest * req = & r -> req ; SCSIDiskState * s = DO_UPCAST ( SCSIDiskState , qdev , req -> dev ) ; uint64_t nb_sectors ; int buflen = 0 ; switch ( req -> cmd . buf [ 0 ] ) { case TEST_UNIT_READY : if ( s -> tray_open || ! bdrv_is_inserted ( s -> bs ) ) goto not_ready ; break ; case INQUIRY : buflen = scsi_disk_emulate_inquiry ( req , outbuf ) ; if ( buflen < 0 ) goto illegal_request ; break ; case MODE_SENSE : case MODE_SENSE_10 : buflen = scsi_disk_emulate_mode_sense ( r , outbuf ) ; if ( buflen < 0 ) goto illegal_request ; break ; case READ_TOC : buflen = scsi_disk_emulate_read_toc ( req , outbuf ) ; if ( buflen < 0 ) goto illegal_request ; break ; case RESERVE : if ( req -> cmd . buf [ 1 ] & 1 ) goto illegal_request ; break ; case RESERVE_10 : if ( req -> cmd . buf [ 1 ] & 3 ) goto illegal_request ; break ; case RELEASE : if ( req -> cmd . buf [ 1 ] & 1 ) goto illegal_request ; break ; case RELEASE_10 : if ( req -> cmd . buf [ 1 ] & 3 ) goto illegal_request ; break ; case START_STOP : if ( scsi_disk_emulate_start_stop ( r ) < 0 ) { return - 1 ; } break ; case ALLOW_MEDIUM_REMOVAL : s -> tray_locked = req -> cmd . buf [ 4 ] & 1 ; bdrv_lock_medium ( s -> bs , req -> cmd . buf [ 4 ] & 1 ) ; break ; case READ_CAPACITY_10 : memset ( outbuf , 0 , 8 ) ; bdrv_get_geometry ( s -> bs , & nb_sectors ) ; if ( ! nb_sectors ) { s ->
",0,511
460,"static int er_supported ( ERContext * s ) { if ( s -> avctx -> hwaccel && s -> avctx -> hwaccel -> decode_slice || ! s -> cur_pic . f || s -> cur_pic . field_picture ) return 0 ; return 1 ; }
",1,65
461,"static int rds_loop_xmit ( struct rds_connection * conn , struct rds_message * rm , unsigned int hdr_off , unsigned int sg , unsigned int off ) { struct scatterlist * sgp = & rm -> data . op_sg [ sg ] ; int ret = sizeof ( struct rds_header ) + be32_to_cpu ( rm -> m_inc . i_hdr . h_len ) ; if ( rm -> m_inc . i_hdr . h_flags & RDS_FLAG_CONG_BITMAP ) { rds_cong_map_updated ( conn -> c_fcong , ~ ( u64 ) 0 ) ; ret = min_t ( int , ret , sgp -> length - conn -> c_xmit_data_off ) ; return ret ; } BUG_ON ( hdr_off || sg || off ) ; rds_inc_init ( & rm -> m_inc , conn , conn -> c_laddr ) ; rds_message_addref ( rm ) ; rds_recv_incoming ( conn , conn -> c_laddr , conn -> c_faddr , & rm -> m_inc , GFP_KERNEL , KM_USER0 ) ; rds_send_drop_acked ( conn , be64_to_cpu ( rm -> m_inc . i_hdr . h_sequence ) , NULL ) ; rds_inc_put ( & rm -> m_inc ) ; return ret ; }
",0,335
462,"static struct grub_ext4_extent_header * grub_ext4_find_leaf ( struct grub_ext2_data * data , char * buf , struct grub_ext4_extent_header * ext_block , grub_uint32_t fileblock ) { struct grub_ext4_extent_idx * index ; while ( 1 ) { int i ; grub_disk_addr_t block ; index = ( struct grub_ext4_extent_idx * ) ( ext_block + 1 ) ; if ( grub_le_to_cpu16 ( ext_block -> magic ) != EXT4_EXT_MAGIC ) return 0 ; if ( ext_block -> depth == 0 ) return ext_block ; for ( i = 0 ; i < grub_le_to_cpu16 ( ext_block -> entries ) ; i ++ ) { if ( fileblock < grub_le_to_cpu32 ( index [ i ] . block ) ) break ; } if ( -- i < 0 ) return 0 ; block = grub_le_to_cpu16 ( index [ i ] . leaf_hi ) ; block = ( block << 32 ) + grub_le_to_cpu32 ( index [ i ] . leaf ) ; if ( grub_disk_read ( data -> disk , block << LOG2_EXT2_BLOCK_SIZE ( data ) , 0 , EXT2_BLOCK_SIZE ( data ) , buf ) ) { return 0 ; } ext_block = ( struct grub_ext4_extent_header * ) buf ; } }
",1,354
463,"long keyctl_read_key ( key_serial_t keyid , char __user * buffer , size_t buflen ) { struct key * key ; key_ref_t key_ref ; long ret ; key_ref = lookup_user_key ( keyid , 0 , 0 ) ; if ( IS_ERR ( key_ref ) ) { ret = - ENOKEY ; goto error ; } key = key_ref_to_ptr ( key_ref ) ; ret = key_read_state ( key ) ; if ( ret < 0 ) goto error ; ret = key_permission ( key_ref , KEY_NEED_READ ) ; if ( ret == 0 ) goto can_read_key ; if ( ret != - EACCES ) goto error2 ; if ( ! is_key_possessed ( key_ref ) ) { ret = - EACCES ; goto error2 ; } can_read_key : ret = - EOPNOTSUPP ; if ( key -> type -> read ) { down_read ( & key -> sem ) ; ret = key_validate ( key ) ; if ( ret == 0 ) ret = key -> type -> read ( key , buffer , buflen ) ; up_read ( & key -> sem ) ; } error2 : key_put ( key ) ; error : return ret ; }
",0,293
464,"int mobility_print ( netdissect_options * ndo , const u_char * bp , const u_char * bp2 _U_ ) { const struct ip6_mobility * mh ; const u_char * ep ; unsigned mhlen , hlen ; uint8_t type ; mh = ( const struct ip6_mobility * ) bp ; ep = ndo -> ndo_snapend ; if ( ! ND_TTEST ( mh -> ip6m_len ) ) { mhlen = ep - bp ; goto trunc ; } mhlen = ( mh -> ip6m_len + 1 ) << 3 ; ND_TCHECK ( mh -> ip6m_type ) ; type = mh -> ip6m_type ; if ( type <= IP6M_MAX && mhlen < ip6m_hdrlen [ type ] ) { ND_PRINT ( ( ndo , ""(headerlength%uistoosmallfortype%u)"" , mhlen , type ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""mobility:%s"" , tok2str ( ip6m_str , ""type-#%u"" , type ) ) ) ; switch ( type ) { case IP6M_BINDING_REQUEST : hlen = IP6M_MINLEN ; break ; case IP6M_HOME_TEST_INIT : case IP6M_CAREOF_TEST_INIT : hlen = IP6M_MINLEN ; if ( ndo -> ndo_vflag ) { ND_TCHECK_32BITS ( & bp [ hlen + 4 ] ) ; ND_PRINT ( ( ndo , ""%sInitCookie=%08x:%08x"" , type == IP6M_HOME_TEST_INIT ? ""Home"" : ""Care-of"" , EXTRACT_32BITS ( & bp [ hlen ] ) , EXTRACT_32BITS ( & bp [ hlen + 4 ] ) ) ) ; } hlen += 8 ; break ; case IP6M_HOME_TEST : case IP6M_CAREOF_TEST : ND_TCHECK ( mh -> ip6m_data16 [ 0 ] ) ;
",0,511
465,"static void ieee80211_if_setup ( struct net_device * dev ) { ether_setup ( dev ) ; dev -> priv_flags &= ~ IFF_TX_SKB_SHARING ; dev -> netdev_ops = & ieee80211_dataif_ops ; dev -> destructor = free_netdev ; }
",1,76
466,"struct _mdi * _WM_ParseNewHmi ( uint8_t * hmi_data , uint32_t hmi_size ) { uint32_t hmi_tmp = 0 ; uint8_t * hmi_base = hmi_data ; uint32_t data_siz ; uint16_t hmi_bpm = 0 ; uint16_t hmi_division = 0 ; uint32_t hmi_track_cnt = 0 ; uint32_t * hmi_track_offset = NULL ; uint32_t i = 0 ; uint32_t j = 0 ; uint8_t * hmi_addr = NULL ; uint32_t * hmi_track_header_length = NULL ; struct _mdi * hmi_mdi = NULL ; uint32_t tempo_f = 5000000.0 ; uint32_t * hmi_track_end = NULL ; uint8_t hmi_tracks_ended = 0 ; uint8_t * hmi_running_event = NULL ; uint32_t setup_ret = 0 ; uint32_t * hmi_delta = NULL ; uint32_t smallest_delta = 0 ; uint32_t subtract_delta = 0 ; uint32_t sample_count = 0 ; float sample_count_f = 0 ; float sample_remainder = 0 ; float samples_per_delta_f = 0.0 ; struct _note { uint32_t length ; uint8_t channel ; } * note ; if ( hmi_track_offset [ i ] >= hmi_size ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMI , ""filetooshort"" , 0 ) ; goto _hmi_end ; } data_siz = hmi_size - hmi_track_offset [ i ] ; if ( memcmp ( hmi_data , ""HMI-MIDISONG061595"" , 18 ) ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_HMI , NULL , 0 ) ; return NULL ; } hmi_bpm = hmi_data [ 212 ] ; hmi_division = 60 ; h
",0,511
467,"static int hci_sock_getname ( struct socket * sock , struct sockaddr * addr , int * addr_len , int peer ) { struct sockaddr_hci * haddr = ( struct sockaddr_hci * ) addr ; struct sock * sk = sock -> sk ; struct hci_dev * hdev = hci_pi ( sk ) -> hdev ; BT_DBG ( ""sock%psk%p"" , sock , sk ) ; if ( ! hdev ) return - EBADFD ; lock_sock ( sk ) ; * addr_len = sizeof ( * haddr ) ; haddr -> hci_family = AF_BLUETOOTH ; haddr -> hci_dev = hdev -> id ; haddr -> hci_channel = 0 ; release_sock ( sk ) ; return 0 ; }
",1,186
468,"static int isofs_export_encode_fh ( struct inode * inode , __u32 * fh32 , int * max_len , struct inode * parent ) { struct iso_inode_info * ei = ISOFS_I ( inode ) ; int len = * max_len ; int type = 1 ; __u16 * fh16 = ( __u16 * ) fh32 ; if ( parent && ( len < 5 ) ) { * max_len = 5 ; return 255 ; } else if ( len < 3 ) { * max_len = 3 ; return 255 ; } len = 3 ; fh32 [ 0 ] = ei -> i_iget5_block ; fh16 [ 2 ] = ( __u16 ) ei -> i_iget5_offset ; fh16 [ 3 ] = inode -> i_generation ; if ( parent ) { struct iso_inode_info * eparent ; eparent = ISOFS_I ( parent ) ; fh32 [ 3 ] = eparent -> i_iget5_block ; fh16 [ 3 ] = ( __u16 ) eparent -> i_iget5_offset ; fh32 [ 4 ] = parent -> i_generation ; len = 5 ; type = 2 ; } * max_len = len ; return type ; }
",0,295
469,"int validate_as_request ( kdc_realm_t * kdc_active_realm , register krb5_kdc_req * request , krb5_db_entry client , krb5_db_entry server , krb5_timestamp kdc_time , const char * * status , krb5_pa_data * * * e_data ) { int errcode ; krb5_error_code ret ; if ( request -> kdc_options & AS_INVALID_OPTIONS ) { * status = ""INVALIDASOPTIONS"" ; return KDC_ERR_BADOPTION ; } if ( client . expiration && client . expiration < kdc_time ) { * status = ""CLIENTEXPIRED"" ; if ( vague_errors ) return ( KRB_ERR_GENERIC ) ; else return ( KDC_ERR_NAME_EXP ) ; } if ( client . pw_expiration && client . pw_expiration < kdc_time && ! isflagset ( server . attributes , KRB5_KDB_PWCHANGE_SERVICE ) ) { * status = ""CLIENTKEYEXPIRED"" ; if ( vague_errors ) return ( KRB_ERR_GENERIC ) ; else return ( KDC_ERR_KEY_EXP ) ; } if ( server . expiration && server . expiration < kdc_time ) { * status = ""SERVICEEXPIRED"" ; return ( KDC_ERR_SERVICE_EXP ) ; } if ( isflagset ( client . attributes , KRB5_KDB_REQUIRES_PWCHANGE ) && ! isflagset ( server . attributes , KRB5_KDB_PWCHANGE_SERVICE ) ) { * status = ""REQUIREDPWCHANGE"" ; return ( KDC_ERR_KEY_EXP ) ; } if ( ( isflagset ( request -> kdc_options , KDC_OPT_ALLOW_POSTDATE ) || isflagset ( request -> kdc_options , KDC_OPT_POSTDATED ) ) && ( isflagset ( client . attributes , KRB5_KDB_DISALLOW_POSTDATED ) || isflagset ( server . attributes , KRB5_K
",0,511
470,"static int adjust_scalar_min_max_vals ( struct bpf_verifier_env * env , struct bpf_insn * insn , struct bpf_reg_state * dst_reg , struct bpf_reg_state src_reg ) { struct bpf_reg_state * regs = cur_regs ( env ) ; u8 opcode = BPF_OP ( insn -> code ) ; bool src_known , dst_known ; s64 smin_val , smax_val ; u64 umin_val , umax_val ; if ( BPF_CLASS ( insn -> code ) != BPF_ALU64 ) { coerce_reg_to_32 ( dst_reg ) ; coerce_reg_to_32 ( & src_reg ) ; } smin_val = src_reg . smin_value ; smax_val = src_reg . smax_value ; umin_val = src_reg . umin_value ; umax_val = src_reg . umax_value ; src_known = tnum_is_const ( src_reg . var_off ) ; dst_known = tnum_is_const ( dst_reg -> var_off ) ; switch ( opcode ) { case BPF_ADD : if ( signed_add_overflows ( dst_reg -> smin_value , smin_val ) || signed_add_overflows ( dst_reg -> smax_value , smax_val ) ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value += smin_val ; dst_reg -> smax_value += smax_val ; } if ( dst_reg -> umin_value + umin_val < umin_val || dst_reg -> umax_value + umax_val < umax_val ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value += umin_val ; dst_reg -> umax_value += umax_val ; } dst_reg -> var_off = tnum_add ( dst
",0,511
471,"void vp9_pick_filter_level ( const YV12_BUFFER_CONFIG * sd , VP9_COMP * cpi , LPF_PICK_METHOD method ) { VP9_COMMON * const cm = & cpi -> common ; struct loopfilter * const lf = & cm -> lf ; lf -> sharpness_level = cm -> frame_type == KEY_FRAME ? 0 : cpi -> oxcf . sharpness ; if ( method == LPF_PICK_FROM_Q ) { const int min_filter_level = 0 ; const int max_filter_level = get_max_filter_level ( cpi ) ; const int q = vp9_ac_quant ( cm -> base_qindex , cm -> bit_depth ) ; int filt_guess = ROUND_POWER_OF_TWO ( q * 20723 + 1015158 , 18 ) ; if ( cm -> frame_type == KEY_FRAME ) filt_guess -= 4 ; lf -> filter_level = clamp ( filt_guess , min_filter_level , max_filter_level ) ; } else { search_filter_level ( sd , cpi , method == LPF_PICK_FROM_SUBIMAGE ) ; } }
",0,287
472,"static void btif_dm_upstreams_evt ( UINT16 event , char * p_param ) { tBTA_DM_SEC * p_data = ( tBTA_DM_SEC * ) p_param ; tBTA_SERVICE_MASK service_mask ; uint32_t i ; bt_bdaddr_t bd_addr ; BTIF_TRACE_EVENT ( ""btif_dm_upstreams_cbackev:%s"" , dump_dm_event ( event ) ) ; switch ( event ) { case BTA_DM_ENABLE_EVT : { BD_NAME bdname ; bt_status_t status ; bt_property_t prop ; prop . type = BT_PROPERTY_BDNAME ; prop . len = BD_NAME_LEN ; prop . val = ( void * ) bdname ; status = btif_storage_get_adapter_property ( & prop ) ; if ( status == BT_STATUS_SUCCESS ) { BTA_DmSetDeviceName ( ( char * ) prop . val ) ; } else { BTA_DmSetDeviceName ( btif_get_default_local_name ( ) ) ; } # if ( defined ( BLE_INCLUDED ) && ( BLE_INCLUDED == TRUE ) ) BTA_DmBleConfigLocalPrivacy ( BLE_LOCAL_PRIVACY_ENABLED ) ; # endif service_mask = btif_get_enabled_services_mask ( ) ; for ( i = 0 ; i <= BTA_MAX_SERVICE_ID ; i ++ ) { if ( service_mask & ( tBTA_SERVICE_MASK ) ( BTA_SERVICE_ID_TO_SERVICE_MASK ( i ) ) ) { btif_in_execute_service_request ( i , TRUE ) ; } } memset ( & pairing_cb , 0 , sizeof ( btif_dm_pairing_cb_t ) ) ; pairing_cb . bond_type = BOND_TYPE_PERSISTENT ; btif_storage_load_bonded_devices ( ) ; btif_storage_load_autopair_device_list ( ) ; btif_enable_bluetooth_evt (
",0,511
473,"static Image * ReadYCBCRImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { const unsigned char * pixels ; Image * canvas_image , * image ; MagickBooleanType status ; MagickOffsetType scene ; QuantumInfo * quantum_info ; QuantumType quantum_type ; register const Quantum * p ; register ssize_t i , x ; register Quantum * q ; size_t length ; ssize_t count , y ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; if ( ( image -> columns == 0 ) || ( image -> rows == 0 ) ) ThrowReaderException ( OptionError , ""MustSpecifyImageSize"" ) ; status = SetImageExtent ( image , image -> columns , image -> rows , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; SetImageColorspace ( image , YCbCrColorspace , exception ) ; if ( image_info -> interlace != PartitionInterlace ) { status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } if ( DiscardBlobBytes ( image , image -> offset ) == MagickFalse ) ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; } canvas_image = CloneImage ( image , image -> extract_info . width , 1 , MagickFalse , exception ) ; ( void ) SetImageVirtualPixelMethod ( canvas_image , BlackVirtualPixelMethod , exception ) ; quantum_info = AcquireQuantumInfo ( image_info , canvas_image ) ; if ( quantum_info == ( QuantumInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; quantum_type = RGBQuantum ;
",0,511
474,"static void controloptions ( lua_State * L , int opt , const char * * fmt , Header * h ) { switch ( opt ) { case '' : return ; case '>' : h -> endian = BIG ; return ; case '<' : h -> endian = LITTLE ; return ; case '!' : { int a = getnum ( fmt , MAXALIGN ) ; if ( ! isp2 ( a ) ) luaL_error ( L , ""alignment%disnotapowerof2"" , a ) ; h -> align = a ; return ; } default : { const char * msg = lua_pushfstring ( L , ""invalidformatoption\'%c\'"" , opt ) ; luaL_argerror ( L , 1 , msg ) ; } } }
",0,175
475,"void usage_exit ( void ) { fprintf ( stderr , ""Usage:%s<codec><width><height><infile><outfile>\\n"" , exec_name ) ; exit ( EXIT_FAILURE ) ; }
",1,55
476,"void edge_sparse_csr_reader_double ( const char * i_csr_file_in , unsigned int * * o_row_idx , unsigned int * * o_column_idx , double * * o_values , unsigned int * o_row_count , unsigned int * o_column_count , unsigned int * o_element_count ) { FILE * l_csr_file_handle ; const unsigned int l_line_length = 512 ; char l_line [ 512 + 1 ] ; unsigned int l_header_read = 0 ; unsigned int * l_row_idx_id = NULL ; unsigned int l_i = 0 ; l_csr_file_handle = fopen ( i_csr_file_in , ""r"" ) ; if ( l_csr_file_handle == NULL ) { fprintf ( stderr , ""cannotopenCSRfile
",0,201
477,"static Image * ReadCMYKImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * canvas_image , * image ; MagickBooleanType status ; MagickOffsetType scene ; QuantumInfo * quantum_info ; QuantumType quantum_type ; register ssize_t i ; size_t length ; ssize_t count , y ; unsigned char * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; if ( ( image -> columns == 0 ) || ( image -> rows == 0 ) ) ThrowReaderException ( OptionError , ""MustSpecifyImageSize"" ) ; SetImageColorspace ( image , CMYKColorspace ) ; if ( image_info -> interlace != PartitionInterlace ) { status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } if ( DiscardBlobBytes ( image , image -> offset ) == MagickFalse ) ThrowFileException ( exception , CorruptImageError , ""UnexpectedEndOfFile"" , image -> filename ) ; } canvas_image = CloneImage ( image , image -> extract_info . width , 1 , MagickFalse , exception ) ; ( void ) SetImageVirtualPixelMethod ( canvas_image , BlackVirtualPixelMethod ) ; quantum_info = AcquireQuantumInfo ( image_info , canvas_image ) ; if ( quantum_info == ( QuantumInfo * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; pixels = GetQuantumPixels ( quantum_info ) ; quantum_type = CMYKQuantum ; if ( LocaleCompare ( image_info -> magick , ""CMYKA"" ) == 0 ) { quantum_type = CMYKAQuantum ; image -> matte = MagickTrue ; } if ( image_
",0,511
478,"static inline void jiffies_to_compat_timeval ( unsigned long jiffies , struct compat_timeval * value ) { u64 nsec = ( u64 ) jiffies * TICK_NSEC ; u32 rem ; value -> tv_sec = div_u64_rem ( nsec , NSEC_PER_SEC , & rem ) ; value -> tv_usec = rem / NSEC_PER_USEC ; }
",1,99
479,"vpx_codec_err_t vpx_codec_decode ( vpx_codec_ctx_t * ctx , const uint8_t * data , unsigned int data_sz , void * user_priv , long deadline ) { vpx_codec_err_t res ; if ( ! ctx || ( ! data && data_sz ) ) res = VPX_CODEC_INVALID_PARAM ; else if ( ! ctx -> iface || ! ctx -> priv ) res = VPX_CODEC_ERROR ; else { res = ctx -> iface -> dec . decode ( get_alg_priv ( ctx ) , data , data_sz , user_priv , deadline ) ; } return SAVE_STATUS ( ctx , res ) ; }
",0,180
480,"static int sdp_parse_fmtp_config_h264 ( AVFormatContext * s , AVStream * stream , PayloadContext * h264_data , const char * attr , const char * value ) { AVCodecParameters * par = stream -> codecpar ; if ( ! strcmp ( attr , ""packetization-mode"" ) ) { av_log ( s , AV_LOG_DEBUG , ""RTPPacketizationMode:%d\\n"" , atoi ( value ) ) ; h264_data -> packetization_mode = atoi ( value ) ; if ( h264_data -> packetization_mode > 1 ) av_log ( s , AV_LOG_ERROR , ""InterleavedRTPmodeisnotsupportedyet.\\n"" ) ; } else if ( ! strcmp ( attr , ""profile-level-id"" ) ) { if ( strlen ( value ) == 6 ) parse_profile_level_id ( s , h264_data , value ) ; } else if ( ! strcmp ( attr , ""sprop-parameter-sets"" ) ) { int ret ; if ( value [ strlen ( value ) - 1 ] == ',' ) { av_log ( s , AV_LOG_WARNING , ""MissingPPSinsprop-parameter-sets,ignoring\\n"" ) ; return 0 ; } par -> extradata_size = 0 ; av_freep ( & par -> extradata ) ; ret = ff_h264_parse_sprop_parameter_sets ( s , & par -> extradata , & par -> extradata_size , value ) ; av_log ( s , AV_LOG_DEBUG , ""Extradatasetto%p(size:%d)\\n"" , par -> extradata , par -> extradata_size ) ; return ret ; } return 0 ; }
",0,408
481,"static int isofs_read_inode ( struct inode * inode , u_int flags ) { struct super_block * sb = inode -> i_sb ; struct isofs_sb_info * sbi = ISOFS_SB ( sb ) ; unsigned long bufsize = ISOFS_BUFFER_SIZE ( inode ) ; unsigned long block ; int high_sierra = sbi -> s_high_sierra ; struct buffer_head * bh = NULL ; struct iso_directory_record * de ; struct iso_directory_record * tmpde = NULL ; unsigned int de_len ; unsigned long offset ; struct iso_inode_info * ei = ISOFS_I ( inode ) ; int ret = - EIO ; block = ei -> i_iget5_block ; bh = sb_bread ( inode -> i_sb , block ) ; if ( ! bh ) goto out_badread ; offset = ei -> i_iget5_offset ; de = ( struct iso_directory_record * ) ( bh -> b_data + offset ) ; de_len = * ( unsigned char * ) de ; if ( offset + de_len > bufsize ) { int frag1 = bufsize - offset ; tmpde = kmalloc ( de_len , GFP_KERNEL ) ; if ( tmpde == NULL ) { printk ( KERN_INFO ""%s:outofmemory\\n"" , __func__ ) ; ret = - ENOMEM ; goto fail ; } memcpy ( tmpde , bh -> b_data + offset , frag1 ) ; brelse ( bh ) ; bh = sb_bread ( inode -> i_sb , ++ block ) ; if ( ! bh ) goto out_badread ; memcpy ( ( char * ) tmpde + frag1 , bh -> b_data , de_len - frag1 ) ; de = tmpde ; } inode -> i_ino = isofs_get_ino ( ei -> i_iget5_block , ei -> i_iget5_offset , ISOFS_BUFFER_BITS ( inode ) ) ; ei -> i_file_format = isofs_file_normal ; if ( de -> flags [ - high_sierra ] &
",0,511
482,"void Con_Dump_f ( void ) { int l , x , i ; short * line ; fileHandle_t f ; int bufferlen ; char * buffer ; char filename [ MAX_QPATH ] ; if ( Cmd_Argc ( ) != 2 ) { Com_Printf ( ""usage:condump<filename>\\n"" ) ; return ; } Q_strncpyz ( filename , Cmd_Argv ( 1 ) , sizeof ( filename ) ) ; COM_DefaultExtension ( filename , sizeof ( filename ) , "".txt"" ) ; if ( ! COM_CompareExtension ( filename , "".txt"" ) ) { Com_Printf ( ""Con_Dump_f:Onlythe\\"".txt\\""extensionissupportedbythiscommand
",0,168
483,"static void esis_print ( netdissect_options * ndo , const uint8_t * pptr , u_int length ) { const uint8_t * optr ; u_int li , esis_pdu_type , source_address_length , source_address_number ; const struct esis_header_t * esis_header ; if ( ! ndo -> ndo_eflag ) ND_PRINT ( ( ndo , ""ES-IS"" ) ) ; if ( length <= 2 ) { ND_PRINT ( ( ndo , ndo -> ndo_qflag ? ""badpkt!"" : ""noheaderatall!"" ) ) ; return ; } esis_header = ( const struct esis_header_t * ) pptr ; ND_TCHECK ( * pptr ) ; ND_TCHECK ( * pptr ) ; ND_PRINT ( ( ndo , "",v:%u%s"" , esis_header -> version , esis_header -> version ) ) ; if ( li > length ) { ND_PRINT ( ( ndo , ""lengthindicator(%u)>PDUsize(%u)!"" , li , length ) ) ; return ; } if ( li < sizeof ( struct esis_header_t ) + 2 ) { ND_PRINT ( ( ndo , ""lengthindicator%u<minPDUsize:"" , li ) ) ; while ( pptr < ndo -> ndo_snapend ) ND_PRINT ( ( ndo , ""%02X"" , * pptr ++ ) ) ; return ; } esis_pdu_type = esis_header -> type & ESIS_PDU_TYPE_MASK ; if ( ndo -> ndo_vflag < 1 ) { ND_PRINT ( ( ndo , ""%s%s,length%u"" , ndo -> ndo_eflag ? """" : "","" , tok2str ( esis_pdu_type ) ) ) ; return ; } ND_TCHECK ( * pptr ) ; ND_PRINT ( ( ndo , "",v:%u%s"" , esis_header -> version , esis_header -> version ) ) ; if ( li > length ) { ND_PRINT ( ( ndo , "",lengthindicator(%u)>
",0,511
484,"void SetColor ( double c , double m , double y , double k , int par ) { if ( par == STROKING ) { sprintf ( outputbuffer , ""%12.3f%12.3f%12.3f%12.3fK"" , c , m , y , k ) ; } else { sprintf ( outputbuffer , ""%12.3f%12.3f%12.3f%12.3fk"" , c , m , y , k ) ; } sendClean ( outputbuffer ) ; }
",1,118
485,"static bool access_pmu_evcntr ( struct kvm_vcpu * vcpu , struct sys_reg_params * p , const struct sys_reg_desc * r ) { u64 idx ; if ( ! kvm_arm_pmu_v3_ready ( vcpu ) ) return trap_raz_wi ( vcpu , p , r ) ; if ( r -> CRn == 9 && r -> CRm == 13 ) { if ( r -> Op2 == 2 ) { if ( pmu_access_event_counter_el0_disabled ( vcpu ) ) return false ; idx = vcpu_sys_reg ( vcpu , PMSELR_EL0 ) & ARMV8_PMU_COUNTER_MASK ; } else if ( r -> Op2 == 0 ) { if ( pmu_access_cycle_counter_el0_disabled ( vcpu ) ) return false ; idx = ARMV8_PMU_CYCLE_IDX ; } else { BUG ( ) ; } } else if ( r -> CRn == 14 && ( r -> CRm & 12 ) == 8 ) { if ( pmu_access_event_counter_el0_disabled ( vcpu ) ) return false ; idx = ( ( r -> CRm & 3 ) << 3 ) | ( r -> Op2 & 7 ) ; } else { BUG ( ) ; } if ( ! pmu_counter_idx_valid ( vcpu , idx ) ) return false ; if ( p -> is_write ) { if ( pmu_access_el0_disabled ( vcpu ) ) return false ; kvm_pmu_set_counter_value ( vcpu , idx , p -> regval ) ; } else { p -> regval = kvm_pmu_get_counter_value ( vcpu , idx ) ; } return true ; }
",0,417
486,"PHP_FUNCTION ( imageaffine ) { zval * IM ; gdImagePtr src ; gdImagePtr dst ; gdRect rect ; gdRectPtr pRect = NULL ; zval * z_rect = NULL ; zval * z_affine ; zval * * tmp ; double affine [ 6 ] ; int i , nelems ; zval * * zval_affine_elem = NULL ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , ""ra|a"" , & IM , & z_affine , & z_rect ) == FAILURE ) { return ; } ZEND_FETCH_RESOURCE ( src , gdImagePtr , & IM , - 1 , ""Image"" , le_gd ) ; if ( ( nelems = zend_hash_num_elements ( Z_ARRVAL_P ( z_affine ) ) ) != 6 ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Affinearraymusthavesixelements"" ) ; RETURN_FALSE ; } for ( i = 0 ; i < nelems ; i ++ ) { if ( zend_hash_index_find ( Z_ARRVAL_P ( z_affine ) , i , ( void * * ) & zval_affine_elem ) == SUCCESS ) { switch ( Z_TYPE_PP ( zval_affine_elem ) ) { case IS_LONG : affine [ i ] = Z_LVAL_PP ( zval_affine_elem ) ; break ; case IS_DOUBLE : affine [ i ] = Z_DVAL_PP ( zval_affine_elem ) ; break ; case IS_STRING : { zval dval ; dval = * * zval_affine_elem ; zval_copy_ctor ( & dval ) ; convert_to_double ( & dval ) ; affine [ i ] = Z_DVAL ( dval ) ; } break ; default : php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Invalidtypeforelement%i"" , i ) ; RETURN_FALSE ; } } } if (
",0,511
487,"static void ast_dealloc ( AST_object * self ) { Py_CLEAR ( self -> dict ) ; Py_TYPE ( self ) -> tp_free ( self ) ; }
",0,41
488,"static int ExecuteSQL ( SQLHDBC hDbc , char * szSQL , char cDelimiter , int bColumnNames , int bHTMLTable ) { SQLHSTMT hStmt ; SQLTCHAR szSepLine [ 32001 ] ; SQLTCHAR szUcSQL [ 32001 ] ; SQLSMALLINT cols ; SQLINTEGER ret ; SQLLEN nRows = 0 ; szSepLine [ 0 ] = 0 ; ansi_to_unicode ( szSQL , szUcSQL ) ; if ( SQLAllocStmt ( hDbc , & hStmt ) != SQL_SUCCESS ) { if ( bVerbose ) DumpODBCLog ( hEnv , hDbc , 0 ) ; fprintf ( stderr , ""[ISQL]ERROR:CouldnotSQLAllocStmt\\n"" ) ; return 0 ; } if ( buseED ) { ret = SQLExecDirect ( hStmt , szUcSQL , SQL_NTS ) ; if ( ret == SQL_NO_DATA ) { fprintf ( stderr , ""[ISQL]INFO:SQLExecDirectreturnedSQL_NO_DATA\\n"" ) ; } else if ( ret == SQL_SUCCESS_WITH_INFO ) { if ( bVerbose ) DumpODBCLog ( hEnv , hDbc , hStmt ) ; fprintf ( stderr , ""[ISQL]INFO:SQLExecDirectreturnedSQL_SUCCESS_WITH_INFO\\n"" ) ; } else if ( ret != SQL_SUCCESS ) { if ( bVerbose ) DumpODBCLog ( hEnv , hDbc , hStmt ) ; fprintf ( stderr , ""[ISQL]ERROR:CouldnotSQLExecDirect\\n"" ) ; SQLFreeStmt ( hStmt , SQL_DROP ) ; return 0 ; } } else { if ( SQLPrepare ( hStmt , szUcSQL , SQL_NTS ) != SQL_SUCCESS ) { if ( bVerbose ) DumpODBCLog ( hEnv , hDbc , hStmt ) ; fprintf ( stderr , ""[ISQL]ERROR:CouldnotSQL
",0,511
489,"int kvm_read_guest_page ( struct kvm * kvm , gfn_t gfn , void * data , int offset , int len ) { int r ; unsigned long addr ; addr = gfn_to_hva ( kvm , gfn ) ; if ( kvm_is_error_hva ( addr ) ) return - EFAULT ; r = __copy_from_user ( data , ( void __user * ) addr + offset , len ) ; if ( r ) return - EFAULT ; return 0 ; }
",1,118
490,"int main ( int argc , char * argv [ ] ) { char * p , * q , * r ; Clp_Parser * clp = Clp_NewParser ( argc , ( const char * const * ) argv , sizeof ( options ) / sizeof ( options [ 0 ] ) , options ) ; program_name = Clp_ProgramName ( clp ) ; while ( 1 ) { int opt = Clp_Next ( clp ) ; switch ( opt ) { case BLOCK_LEN_OPT : blocklen = clp -> val . i ; break ; output_file : case OUTPUT_OPT : if ( ofp ) fatal_error ( ""outputfilealreadyspecified"" ) ; if ( strcmp ( clp -> vstr , ""-"" ) == 0 ) ofp = stdout ; else if ( ! ( ofp = fopen ( clp -> vstr , ""w"" ) ) ) fatal_error ( ""%s:%s"" , clp -> vstr , strerror ( errno ) ) ; break ; case PFB_OPT : pfb = 1 ; break ; case PFA_OPT : pfb = 0 ; break ; case HELP_OPT : usage ( ) ; exit ( 0 ) ; break ; case VERSION_OPT : printf ( ""t1asm(LCDFt1utils)%s\\n"" , VERSION ) ; printf ( ""Copyright(C)1992-2010I.LeeHetherington,EddieKohleretal.\\n\\\nThisisfreesoftware;seethesourceforcopyingconditions.\\n\\\nThereisNOwarranty,notevenformerchantabilityorfitnessfora\\n\\\nparticularpurpose.\\n"" ) ; exit ( 0 ) ; break ; case Clp_NotOption : if ( ifp && ofp ) fatal_error ( ""toomanyarguments"" ) ; else if ( ifp ) goto output_file ; if ( strcmp ( clp -> vstr , ""-"" ) == 0 ) ifp = stdin ; else if ( ! ( ifp = fopen ( clp -> vstr , ""r"" ) ) ) fatal_error ( ""%s:%s"" , clp -> vstr , strerror ( errno ) ) ; break ; case Cl
",0,511
491,"static int usb_console_setup ( struct console * co , char * options ) { struct usbcons_info * info = & usbcons_info ; int baud = 9600 ; int bits = 8 ; int parity = 'n' ; int doflow = 0 ; int cflag = CREAD | HUPCL | CLOCAL ; char * s ; struct usb_serial * serial ; struct usb_serial_port * port ; int retval ; struct tty_struct * tty = NULL ; struct ktermios dummy ; if ( options ) { baud = simple_strtoul ( options , NULL , 10 ) ; s = options ; while ( * s >= '0' && * s <= '9' ) s ++ ; if ( * s ) parity = * s ++ ; if ( * s ) bits = * s ++ - '0' ; if ( * s ) doflow = ( * s ++ == 'r' ) ; } if ( baud == 0 ) baud = 9600 ; switch ( bits ) { case 7 : cflag |= CS7 ; break ; default : case 8 : cflag |= CS8 ; break ; } switch ( parity ) { case 'o' : case 'O' : cflag |= PARODD ; break ; case 'e' : case 'E' : cflag |= PARENB ; break ; } co -> cflag = cflag ; port = usb_serial_port_get_by_minor ( co -> index ) ; if ( port == NULL ) { pr_err ( ""NoUSBdeviceconnectedtottyUSB%i\\n"" , co -> index ) ; return - ENODEV ; } serial = port -> serial ; retval = usb_autopm_get_interface ( serial -> interface ) ; if ( retval ) goto error_get_interface ; tty_port_tty_set ( & port -> port , NULL ) ; info -> port = port ; ++ port -> port . count ; if ( ! tty_port_initialized ( & port -> port ) ) { if ( serial -> type -> set_termios ) { tty = kzalloc ( sizeof ( * tty ) , GFP_KERNEL ) ; if ( ! tty ) { retval = - ENOMEM ; goto reset_open_count ; } kref_init ( & tty -> kref
",0,511
492,"int perf_pmu_register ( struct pmu * pmu , const char * name , int type ) { int cpu , ret ; mutex_lock ( & pmus_lock ) ; ret = - ENOMEM ; pmu -> pmu_disable_count = alloc_percpu ( int ) ; if ( ! pmu -> pmu_disable_count ) goto unlock ; pmu -> type = - 1 ; if ( ! name ) goto skip_type ; pmu -> name = name ; if ( type < 0 ) { type = idr_alloc ( & pmu_idr , pmu , PERF_TYPE_MAX , 0 , GFP_KERNEL ) ; if ( type < 0 ) { ret = type ; goto free_pdc ; } } pmu -> type = type ; if ( pmu_bus_running ) { ret = pmu_dev_alloc ( pmu ) ; if ( ret ) goto free_idr ; } skip_type : pmu -> pmu_cpu_context = find_pmu_context ( pmu -> task_ctx_nr ) ; if ( pmu -> pmu_cpu_context ) goto got_cpu_context ; ret = - ENOMEM ; pmu -> pmu_cpu_context = alloc_percpu ( struct perf_cpu_context ) ; if ( ! pmu -> pmu_cpu_context ) goto free_dev ; for_each_possible_cpu ( cpu ) { struct perf_cpu_context * cpuctx ; cpuctx = per_cpu_ptr ( pmu -> pmu_cpu_context , cpu ) ; __perf_event_init_context ( & cpuctx -> ctx ) ; lockdep_set_class ( & cpuctx -> ctx . pmu = pmu ; __perf_cpu_hrtimer_init ( cpuctx , cpu ) ; INIT_LIST_HEAD ( & cpuctx -> rotation_list ) ; cpuctx -> unique_pmu = pmu ; } got_cpu_context : if ( ! pmu -> start_txn ) { if ( pmu -> pmu_enable ) { pmu -> start_txn = perf_pmu_start_txn ; pmu -> commit_txn = perf_pmu_commit_txn ; pmu -> cancel_
",0,511
493,"static ssize_t aio_setup_single_vector ( struct kiocb * kiocb , int rw , char __user * buf , unsigned long * nr_segs , size_t len , struct iovec * iovec , struct iov_iter * iter ) { if ( len > MAX_RW_COUNT ) len = MAX_RW_COUNT ; if ( unlikely ( ! access_ok ( ! rw , buf , len ) ) ) return - EFAULT ; iovec -> iov_base = buf ; iovec -> iov_len = len ; * nr_segs = 1 ; iov_iter_init ( iter , rw , iovec , * nr_segs , len ) ; return 0 ; }
",1,171
494,"static int ext4_fill_flex_info ( struct super_block * sb ) { struct ext4_sb_info * sbi = EXT4_SB ( sb ) ; struct ext4_group_desc * gdp = NULL ; ext4_group_t flex_group_count ; ext4_group_t flex_group ; int groups_per_flex = 0 ; size_t size ; int i ; sbi -> s_log_groups_per_flex = sbi -> s_es -> s_log_groups_per_flex ; if ( sbi -> s_log_groups_per_flex < 2 ) { sbi -> s_log_groups_per_flex = 0 ; return 1 ; } flex_group_count = ( ( sbi -> s_groups_count + groups_per_flex - 1 ) + ( ( le16_to_cpu ( sbi -> s_es -> s_reserved_gdt_blocks ) + 1 ) << EXT4_DESC_PER_BLOCK_BITS ( sb ) ) ) / groups_per_flex ; size = flex_group_count * sizeof ( struct flex_groups ) ; sbi -> s_flex_groups = ext4_kvzalloc ( size , GFP_KERNEL ) ; if ( sbi -> s_flex_groups == NULL ) { ext4_msg ( sb , KERN_ERR , ""notenoughmemoryfor%uflexgroups"" , flex_group_count ) ; goto failed ; } for ( i = 0 ; i < sbi -> s_groups_count ; i ++ ) { gdp = ext4_get_group_desc ( sb , i , NULL ) ; flex_group = ext4_flex_group ( sbi , i ) ; atomic_add ( ext4_free_inodes_count ( sb , gdp ) , & sbi -> s_flex_groups [ flex_group ] . free_inodes ) ; atomic_add ( ext4_free_group_clusters ( sb , gdp ) , & sbi -> s_flex_groups [ flex_group ] . free_clusters ) ; atomic_add ( ext4_used_dirs_count ( sb , gdp ) , & sbi -> s_flex_groups [ flex_group
",0,511
495,"static inline int sctp_chunk_length_valid ( struct sctp_chunk * chunk , __u16 required_length ) { __u16 chunk_length = ntohs ( chunk -> chunk_hdr -> length ) ; if ( chunk_length >= required_length ) return 0 ; return 1 ; }
",0,72
496,"cJSON * cJSON_CreateStringArray ( const char * * strings , int count ) { int i ; cJSON * n = 0 , * p = 0 , * a = cJSON_CreateArray ( ) ; for ( i = 0 ; a && i < count ; i ++ ) { n = cJSON_CreateString ( strings [ i ] ) ; if ( ! i ) a -> child = n ; else suffix_object ( p , n ) ; p = n ; } return a ; }
",0,107
497,"int m_authenticate ( struct Client * cptr , struct Client * sptr , int parc , char * parv [ ] ) { struct Client * acptr ; int first = 0 ; char realhost [ HOSTLEN + 3 ] ; char * hoststr = ( cli_sockhost ( cptr ) ? cli_sockhost ( cptr ) : cli_sock_ip ( cptr ) ) ; if ( ! CapActive ( cptr , CAP_SASL ) ) return 0 ; if ( parc < 2 ) return need_more_params ( cptr , ""AUTHENTICATE"" ) ; if ( strlen ( parv [ 1 ] ) > 400 ) return send_reply ( cptr , ERR_SASLTOOLONG ) ; if ( IsSASLComplete ( cptr ) ) return send_reply ( cptr , ERR_SASLALREADY ) ; if ( ! ( acptr = cli_saslagent ( cptr ) ) ) { if ( strcmp ( feature_str ( FEAT_SASL_SERVER ) , ""*"" ) ) acptr = find_match_server ( ( char * ) feature_str ( FEAT_SASL_SERVER ) ) ; else acptr = NULL ; } if ( ! acptr && strcmp ( feature_str ( FEAT_SASL_SERVER ) , ""*"" ) ) return send_reply ( cptr , ERR_SASLFAIL , "":serviceunavailable"" ) ; if ( acptr && IsMe ( acptr ) ) return 0 ; if ( ! cli_saslcookie ( cptr ) ) { do { cli_saslcookie ( cptr ) = ircrandom ( ) & 0x7fffffff ; } while ( ! cli_saslcookie ( cptr ) ) ; first = 1 ; } if ( strchr ( hoststr , ':' ) != NULL ) ircd_snprintf ( 0 , realhost , sizeof ( realhost ) , ""[%s]"" , hoststr ) ; else ircd_strncpy ( realhost , hoststr , sizeof ( realhost ) ) ; if ( acptr ) { if ( first ) { if ( ! EmptyString ( cli_sslclifp ( cptr )
",0,511
498,"static void diff_bytes_c ( uint8_t * dst , const uint8_t * src1 , const uint8_t * src2 , int w ) { long i ; # if ! HAVE_FAST_UNALIGNED if ( ( long ) src2 & ( sizeof ( long ) - 1 ) ) { for ( i = 0 ; i + 7 < w ; i += 8 ) { dst [ i + 0 ] = src1 [ i + 0 ] - src2 [ i + 0 ] ; dst [ i + 1 ] = src1 [ i + 1 ] - src2 [ i + 1 ] ; dst [ i + 2 ] = src1 [ i + 2 ] - src2 [ i + 2 ] ; dst [ i + 3 ] = src1 [ i + 3 ] - src2 [ i + 3 ] ; dst [ i + 4 ] = src1 [ i + 4 ] - src2 [ i + 4 ] ; dst [ i + 5 ] = src1 [ i + 5 ] - src2 [ i + 5 ] ; dst [ i + 6 ] = src1 [ i + 6 ] - src2 [ i + 6 ] ; dst [ i + 7 ] = src1 [ i + 7 ] - src2 [ i + 7 ] ; } } else # endif for ( i = 0 ; i <= w - sizeof ( long ) ; i += sizeof ( long ) ) { long a = * ( long * ) ( src1 + i ) ; long b = * ( long * ) ( src2 + i ) ; * ( long * ) ( dst + i ) = ( ( a | pb_80 ) - ( b & pb_7f ) ) ^ ( ( a ^ b ^ pb_80 ) & pb_80 ) ; } for ( ; i < w ; i ++ ) dst [ i + 0 ] = src1 [ i + 0 ] - src2 [ i + 0 ] ; }
",0,415
499,"int _yr_scan_match_callback ( uint8_t * match_data , int32_t match_length , int flags , void * args ) { CALLBACK_ARGS * callback_args = ( CALLBACK_ARGS * ) args ; YR_STRING * string = callback_args -> string ; YR_MATCH * new_match ; int result = ERROR_SUCCESS ; int tidx = callback_args -> context -> tidx ; size_t match_offset = match_data - callback_args -> data ; match_length += callback_args -> forward_matches ; if ( callback_args -> full_word ) { if ( flags & RE_FLAGS_WIDE ) { if ( match_offset >= 2 && * ( match_data - 1 ) == 0 && isalnum ( * ( match_data - 2 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length + 1 < callback_args -> data_size && * ( match_data + match_length + 1 ) == 0 && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } else { if ( match_offset >= 1 && isalnum ( * ( match_data - 1 ) ) ) return ERROR_SUCCESS ; if ( match_offset + match_length < callback_args -> data_size && isalnum ( * ( match_data + match_length ) ) ) return ERROR_SUCCESS ; } } if ( STRING_IS_CHAIN_PART ( string ) ) { result = _yr_scan_verify_chained_string_match ( string , callback_args -> context , match_data , callback_args -> data_base , match_offset , match_length ) ; } else { if ( string -> matches [ tidx ] . count == 0 ) { FAIL_ON_ERROR ( yr_arena_write_data ( callback_args -> context -> matching_strings_arena , & string , sizeof ( string ) , NULL ) ) ; } FAIL_ON_ERROR ( yr_arena_allocate_memory ( callback_args -> context -> matches_arena , sizeof ( YR_MATCH ) , ( void * * ) & new_match ) ) ; new_match -> data_length = yr_are
",0,511
500,"static Channel * server_request_direct_streamlocal ( void ) { Channel * c = NULL ; char * target , * originator ; u_short originator_port ; target = packet_get_string ( NULL ) ; originator = packet_get_string ( NULL ) ; originator_port = packet_get_int ( ) ; packet_check_eom ( ) ; debug ( ""server_request_direct_streamlocal:originator%sport%d,target%s"" , originator , originator_port , target ) ; if ( ( options . allow_streamlocal_forwarding & FORWARD_LOCAL ) != 0 && ! no_port_forwarding_flag && ! options . disable_forwarding ) { c = channel_connect_to_path ( target , ""direct-streamlocal@openssh.com"" , ""direct-streamlocal"" ) ; } else { logit ( ""refusedstreamlocalportforward:"" ""originator%sport%d,target%s"" , originator , originator_port , target ) ; } free ( originator ) ; free ( target ) ; return c ; }
",0,247
501,"static int smacker_decode_tree ( BitstreamContext * bc , HuffContext * hc , uint32_t prefix , int length ) { if ( length > SMKTREE_DECODE_MAX_RECURSION ) { av_log ( NULL , AV_LOG_ERROR , ""Maximumtreerecursionlevelexceeded.\\n"" ) ; return AVERROR_INVALIDDATA ; } if ( ! bitstream_read_bit ( bc ) ) { if ( hc -> current >= 256 ) { av_log ( NULL , AV_LOG_ERROR , ""Treesizeexceeded
",0,135
502,"int verify_iovec ( struct msghdr * m , struct iovec * iov , struct sockaddr_storage * address , int mode ) { int size , ct , err ; if ( m -> msg_namelen ) { if ( mode == VERIFY_READ ) { void __user * namep ; namep = ( void __user __force * ) m -> msg_name ; err = move_addr_to_kernel ( namep , m -> msg_namelen , address ) ; if ( err < 0 ) return err ; } if ( m -> msg_name ) m -> msg_name = address ; } else { m -> msg_name = NULL ; } size = m -> msg_iovlen * sizeof ( struct iovec ) ; if ( copy_from_user ( iov , ( void __user __force * ) m -> msg_iov , size ) ) return - EFAULT ; m -> msg_iov = iov ; err = 0 ; for ( ct = 0 ; ct < m -> msg_iovlen ; ct ++ ) { size_t len = iov [ ct ] . iov_len ; if ( len > INT_MAX - err ) { len = INT_MAX - err ; iov [ ct ] . iov_len = len ; } err += len ; } return err ; }
",1,296
503,"int obj2ast_mod ( PyObject * obj , mod_ty * out , PyArena * arena ) { int isinstance ; PyObject * tmp = NULL ; if ( obj == Py_None ) { * out = NULL ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Module_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * body ; asdl_seq * type_ignores ; if ( lookup_attr_id ( obj , & PyId_body ) ) { int res ; Py_ssize_t len ; Py_ssize_t i ; tmp = _PyObject_GetAttrId ( obj , & PyId_body ) ; if ( tmp == NULL ) goto failed ; if ( ! PyList_Check ( tmp ) ) { PyErr_Format ( PyExc_TypeError , ""Modulefield\\""body\\""mustbealist,nota%.200s"" , tmp -> ob_type -> tp_name ) ; goto failed ; } len = PyList_GET_SIZE ( tmp ) ; body = _Ta3_asdl_seq_new ( len , arena ) ; if ( body == NULL ) goto failed ; for ( i = 0 ; i < len ; i ++ ) { stmt_ty value ; res = obj2ast_stmt ( PyList_GET_ITEM ( tmp , i ) , & value , arena ) ; if ( res != 0 ) goto failed ; if ( len != PyList_GET_SIZE ( tmp ) ) { PyErr_SetString ( PyExc_RuntimeError , ""Modulefield\\""body\\""changedsizeduringiteration"" ) ; goto failed ; } asdl_seq_SET ( body , i , value ) ; } Py_CLEAR ( tmp ) ; } else { PyErr_SetString ( PyExc_TypeError , ""requiredfield\\""body\\""missingfromModule"" ) ; return 1 ; } if ( _PyObject_HasAttrId ( obj , & PyId_type_ignores ) ) { int res ; Py_ssize_t len ; Py_ssize_t i ; tmp = _PyObject_GetAttrId ( obj , & PyId_type_ignores ) ; if ( tmp == NULL ) goto
",0,511
504,"void jpc_qmfb_split_col ( jpc_fix_t * a , int numrows , int stride , int parity ) { int bufsize = JPC_CEILDIVPOW2 ( numrows , 1 ) ; jpc_fix_t splitbuf [ QMFB_SPLITBUFSIZE ] ; jpc_fix_t * buf = splitbuf ; register jpc_fix_t * srcptr ; register jpc_fix_t * dstptr ; register int n ; register int m ; int hstartrow ; if ( bufsize > QMFB_SPLITBUFSIZE ) { if ( ! ( buf = jas_alloc2 ( bufsize , sizeof ( jpc_fix_t ) ) ) ) { abort ( ) ; } } if ( numrows >= 2 ) { hstartrow = ( numrows + 1 - parity ) >> 1 ; m = numrows - hstartrow ; n = m ; dstptr = buf ; srcptr = & a [ hstartrow * stride ] ; while ( n -- > 0 ) { * dstptr = * srcptr ; ++ dstptr ; srcptr += stride << 1 ; } dstptr = & a [ ( 1 - parity ) * stride ] ; srcptr = & a [ ( 2 - parity ) * stride ] ; n = numrows - m - ( ! parity ) ; while ( n -- > 0 ) { * dstptr = * srcptr ; dstptr += stride ; srcptr += stride << 1 ; } dstptr = & a [ hstartcol * stride ] ; srcptr = buf ; n = m ; while ( n -- > 0 ) { * dstptr = * srcptr ; dstptr += stride ; ++ srcptr ; } } if ( buf != splitbuf ) { jas_free ( buf ) ; } }
",1,392
505,"static int iwl_process_add_sta_resp ( struct iwl_priv * priv , struct iwl_addsta_cmd * addsta , struct iwl_rx_packet * pkt ) { u8 sta_id = addsta -> sta . sta_id ; unsigned long flags ; int ret = - EIO ; if ( pkt -> hdr . flags & IWL_CMD_FAILED_MSK ) { IWL_ERR ( priv , ""BadreturnfromREPLY_ADD_STA(0x%08X)\\n"" , pkt -> hdr . flags ) ; return ret ; } IWL_DEBUG_INFO ( priv , ""Processingresponseforaddingstation%u\\n"" , sta_id ) ; spin_lock_irqsave ( & priv -> shrd -> sta_lock , flags ) ; switch ( pkt -> u . add_sta . status ) { case ADD_STA_SUCCESS_MSK : IWL_DEBUG_INFO ( priv , ""REPLY_ADD_STAPASSED\\n"" ) ; ret = 0 ; break ; case ADD_STA_NO_ROOM_IN_TABLE : IWL_ERR ( priv , ""Addingstation%dfailed,noroomintable.\\n"" , sta_id ) ; break ; case ADD_STA_NO_BLOCK_ACK_RESOURCE : IWL_ERR ( priv , ""Addingstation%dfailed,noblockack"" ""resource.\\n"" , sta_id ) ; break ; case ADD_STA_MODIFY_NON_EXIST_STA : IWL_ERR ( priv , ""Attemptingtomodifynon-existingstation%d\\n"" , sta_id ) ; break ; default : IWL_DEBUG_ASSOC ( priv , ""ReceivedREPLY_ADD_STA:(0x%08X)\\n"" , pkt -> u . add_sta . status ) ; break ; } IWL_DEBUG_INFO ( priv , ""%sstationid%uaddr%pM\\n"" , priv -> stations [ sta_id ] . sta_id ) ; return ret ; }
",0,501
506,"static void open_log_file ( const char * name , const char * prog , const char * namespace , const char * instance ) { char * file_name ; if ( log_file ) { fclose ( log_file ) ; log_file = NULL ; } if ( ! name ) return ; file_name = make_file_name ( name , prog , namespace , instance ) ; if ( ! file_name ) { int n = fileno ( log_file ) ; fcntl ( n , F_SETFD , FD_CLOEXEC | fcntl ( n , F_GETFD ) ) ; fcntl ( n , F_SETFL , O_NONBLOCK | fcntl ( n , F_GETFL ) ) ; } FREE ( file_name ) ; }
",0,179
507,"void test_re ( ) { assert_true_rule ( ""ruletest{strings:$a=/ssi/condition:$a}"" , ""mississippi\\tmississippi.mississippi\\nmississippi"" ) ; assert_true_rule ( ""ruletest{strings:$a=/ssi(s|p)/condition:$a}"" , ""mississippi\\tmississippi.mississippi\\nmississippi"" ) ; assert_true_rule ( ""ruletest{strings:$a=/ssim*/condition:$a}"" , ""mississippi\\tmississippi.mississippi\\nmississippi"" ) ; assert_true_rule ( ""ruletest{strings:$a=/ssa?/condition:$a}"" , ""mississippi\\tmississippi.mississippi\\nmississippi"" ) ; assert_true_rule ( ""ruletest{strings:$a=/Miss/nocasecondition:$a}"" , ""mississippi\\tmississippi.mississippi\\nmississippi"" ) ; assert_true_rule ( ""ruletest{strings:$a=/(M|N)iss/nocasecondition:$a}"" , ""mississippi\\tmississippi.mississippi\\nmississippi"" ) ; assert_true_rule ( ""ruletest{strings:$a=/[M-N]iss/nocasecondition:$a}"" , ""mississippi\\tmississippi.mississippi\\nmississippi"" ) ; assert_true_rule ( ""ruletest{strings:$a=/(Mi|ssi)ssippi/nocasecondition:$a}"" , ""mississippi\\tmississippi.mississippi\\nmississippi"" ) ; assert_true_rule ( ""ruletest{strings:$a=/ppi\\\\tmi/condition:$a}"" , ""mississippi\\tmississippi.mississippi\\nmississippi"" ) ; assert_true_rule ( ""ruletest{strings:$a=/ppi\\\\.mi/condition:$a}"" , ""mississippi\\tmississippi.mississippi\\nmississippi"" ) ; assert_true_rule ( ""
",0,511
508,"int hashbin_delete ( hashbin_t * hashbin , FREE_FUNC free_func ) { irda_queue_t * queue ; unsigned long flags = 0 ; int i ; IRDA_ASSERT ( hashbin != NULL , return - 1 ; ) ; IRDA_ASSERT ( hashbin -> magic == HB_MAGIC , return - 1 ; ) ; if ( hashbin -> hb_type & HB_LOCK ) { spin_lock_irqsave_nested ( & hashbin -> hb_spinlock , flags , hashbin_lock_depth ++ ) ; } for ( i = 0 ; i < HASHBIN_SIZE ; i ++ ) { queue = dequeue_first ( ( irda_queue_t * ) & hashbin -> hb_queue [ i ] ) ; while ( queue ) { if ( free_func ) ( * free_func ) ( queue ) ; queue = dequeue_first ( ( irda_queue_t * * ) & hashbin -> hb_queue [ i ] ) ; } } hashbin -> hb_current = NULL ; hashbin -> magic = ~ HB_MAGIC ; if ( hashbin -> hb_type & HB_LOCK ) { spin_unlock_irqrestore ( & hashbin -> hb_spinlock , flags ) ; # ifdef CONFIG_LOCKDEP hashbin_lock_depth -- ; # endif } kfree ( hashbin ) ; return 0 ; }
",0,321
509,"static int do_remount ( struct path * path , int flags , int mnt_flags , void * data ) { int err ; struct super_block * sb = path -> mnt -> mnt_sb ; struct mount * mnt = real_mount ( path -> mnt ) ; if ( ! check_mnt ( mnt ) ) return - EINVAL ; if ( path -> dentry != path -> mnt -> mnt_root ) return - EINVAL ; if ( ( mnt -> mnt . mnt_flags & MNT_LOCK_READONLY ) && ! ( mnt_flags & MNT_READONLY ) ) { return - EPERM ; } if ( ( mnt -> mnt . mnt_flags & MNT_LOCK_NODEV ) && ( mnt_flags & MNT_NODEV ) ) { return - EPERM ; } err = security_sb_remount ( sb , data ) ; if ( err ) return err ; down_write ( & sb -> s_umount ) ; if ( flags & MS_BIND ) err = change_mount_flags ( path -> mnt , flags ) ; else if ( ! capable ( CAP_SYS_ADMIN ) ) err = - EPERM ; else err = do_remount_sb ( sb , flags , data , 0 ) ; if ( ! err ) { lock_mount_hash ( ) ; mnt_flags |= mnt -> mnt . mnt_flags & ~ MNT_USER_SETTABLE_MASK ; mnt -> mnt . mnt_flags = mnt_flags ; touch_mnt_namespace ( mnt -> mnt_ns ) ; unlock_mount_hash ( ) ; } up_write ( & sb -> s_umount ) ; return err ; }
",0,404
510,"static int packet_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { struct sock * sk = sock -> sk ; struct sk_buff * skb ; int copied , err ; msg -> msg_namelen = 0 ; struct sockaddr_ll * sll ; int vnet_hdr_len = 0 ; err = - EINVAL ; if ( flags & ~ ( MSG_PEEK | MSG_DONTWAIT | MSG_TRUNC | MSG_CMSG_COMPAT | MSG_ERRQUEUE ) ) goto out ; # if 0 if ( pkt_sk ( sk ) -> ifindex < 0 ) return - ENODEV ; # endif if ( flags & MSG_ERRQUEUE ) { err = sock_recv_errqueue ( sk , msg , len , SOL_PACKET , PACKET_TX_TIMESTAMP ) ; goto out ; } skb = skb_recv_datagram ( sk , flags , flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out ; if ( pkt_sk ( sk ) -> has_vnet_hdr ) { struct virtio_net_hdr vnet_hdr = { 0 } ; err = - EINVAL ; vnet_hdr_len = sizeof ( vnet_hdr ) ; if ( len < vnet_hdr_len ) goto out_free ; len -= vnet_hdr_len ; if ( skb_is_gso ( skb ) ) { struct skb_shared_info * sinfo = skb_shinfo ( skb ) ; vnet_hdr . hdr_len = skb_headlen ( skb ) ; vnet_hdr . gso_size = sinfo -> gso_size ; if ( sinfo -> gso_type & SKB_GSO_TCPV4 ) vnet_hdr . gso_type = VIRTIO_NET_HDR_GSO_TCPV4 ; else if ( sinfo -> gso_type & SKB_GSO_TCPV6 ) vnet_hdr . gso_type = VIRTIO_NET_
",0,511
511,"int ras_validate ( jas_stream_t * in ) { jas_uchar buf [ RAS_MAGICLEN ] ; int i ; int n ; uint_fast32_t magic ; assert ( JAS_STREAM_MAXPUTBACK >= RAS_MAGICLEN ) ; if ( ( n = jas_stream_read ( in , buf , RAS_MAGICLEN ) ) < 0 ) { return - 1 ; } for ( i = n - 1 ; i >= 0 ; -- i ) { if ( jas_stream_ungetc ( in , buf [ i ] ) == EOF ) { return - 1 ; } } if ( n < RAS_MAGICLEN ) { return - 1 ; } magic = ( JAS_CAST ( uint_fast32_t , buf [ 0 ] ) << 24 ) | ( JAS_CAST ( uint_fast32_t , buf [ 1 ] ) << 16 ) | ( JAS_CAST ( uint_fast32_t , buf [ 2 ] ) << 8 ) | buf [ 3 ] ; if ( magic != RAS_MAGIC ) { return - 1 ; } return 0 ; }
",1,259
512,"static int clie_5_attach ( struct usb_serial * serial ) { struct usb_serial_port * port ; unsigned int pipe ; int j ; if ( serial -> num_bulk_out < 2 ) return - 1 ; port = serial -> port [ 0 ] ; port -> bulk_out_endpointAddress = serial -> port [ 1 ] -> bulk_out_endpointAddress ; pipe = usb_sndbulkpipe ( serial -> dev , port -> bulk_out_endpointAddress ) ; for ( j = 0 ; j < ARRAY_SIZE ( port -> write_urbs ) ; ++ j ) port -> write_urbs [ j ] -> pipe = pipe ; return 0 ; }
",1,152
513,"int WriteRiffHeader ( FILE * outfile , WavpackContext * wpc , int64_t total_samples , int qmode , int bytes_per_sample ) { int do_rf64 = 0 , write_junk = 1 ; ChunkHeader ds64hdr , datahdr , fmthdr ; RiffChunkHeader riffhdr ; int32_t bcount ; int64_t total_data_bytes , total_riff_bytes ; int num_channels = WavpackGetNumChannels ( wpc ) ; int32_t channel_mask = WavpackGetChannelMask ( wpc ) ; int32_t sample_rate = WavpackGetSampleRate ( wpc ) ; int bytes_per_sample = WavpackGetBytesPerSample ( wpc ) ; int bits_per_sample = WavpackGetBitsPerSample ( wpc ) ; int format = WavpackGetFloatNormExp ( wpc ) ? 3 : 1 ; int wavhdrsize = 16 ; if ( format == 3 && WavpackGetFloatNormExp ( wpc ) != 127 ) { error_line ( ""can\'tcreatevalidRIFFwavheaderfornon-normalizedfloatingdata!"" ) ; return FALSE ; } if ( total_samples == - 1 ) total_samples = 0x7ffff000 / ( bytes_per_sample * num_channels ) ; total_data_bytes = total_samples * bytes_per_sample * num_channels ; if ( total_data_bytes > 0xff000000 ) { if ( debug_logging_mode ) error_line ( ""total_data_bytes=%lld,sorf64"" , total_data_bytes ) ; write_junk = 0 ; do_rf64 = 1 ; } else if ( debug_logging_mode ) error_line ( ""total_data_bytes=%lld,soriff"" , total_data_bytes ) ; CLEAR ( wavhdr ) ; wavhdr . FormatTag = format ; wavhdr . NumChannels = num_channels ; wavhdr . SampleRate = sample_rate ; wavhdr . BytesPerSample = ( int64_t ) total_data_bytes * bytes_per_sample ;
",0,511
514,"static int ___sys_recvmsg ( struct socket * sock , struct msghdr __user * msg , struct msghdr * msg_sys , unsigned int flags , int nosec ) { struct compat_msghdr __user * msg_compat = ( struct compat_msghdr __user * ) msg ; struct iovec iovstack [ UIO_FASTIOV ] ; struct iovec * iov = iovstack ; unsigned long cmsg_ptr ; int err , total_len , len ; struct sockaddr_storage addr ; struct sockaddr __user * uaddr ; int __user * uaddr_len ; if ( MSG_CMSG_COMPAT & flags ) { if ( get_compat_msghdr ( msg_sys , msg_compat ) ) return - EFAULT ; } else { err = copy_msghdr_from_user ( msg_sys , msg ) ; if ( err ) return err ; } if ( msg_sys -> msg_iovlen > UIO_FASTIOV ) { err = - EMSGSIZE ; if ( msg_sys -> msg_iovlen > UIO_MAXIOV ) goto out ; err = - ENOMEM ; iov = kmalloc ( msg_sys -> msg_iovlen * sizeof ( struct iovec ) , GFP_KERNEL ) ; if ( ! iov ) goto out ; } uaddr = ( __force void __user * ) msg_sys -> msg_name ; uaddr_len = COMPAT_NAMELEN ( msg ) ; if ( MSG_CMSG_COMPAT & flags ) msg -> msg_namelen = 0 ; if ( MSG_CMSG_COMPAT & flags ) { err = verify_compat_iovec ( msg_sys , iov , & addr , VERIFY_WRITE ) ; } else err = verify_iovec ( msg_sys , iov , & addr , VERIFY_WRITE ) ; if ( err < 0 ) goto out_freeiov ; total_len = err ; cmsg_ptr = ( unsigned long ) msg_sys -> msg_control ; msg_sys -> msg_flags = flags & ( MSG_CMSG_CLOEXEC | MSG_CMSG_COMPAT ) ; if ( sock -> file ->
",0,511
515,"static int gfs2_bmap_alloc ( struct inode * inode , const sector_t lblock , struct buffer_head * bh_map , struct metapath * mp , const unsigned int sheight , const unsigned int height , const unsigned int maxlen ) { struct gfs2_inode * ip = GFS2_I ( inode ) ; struct gfs2_sbd * sdp = GFS2_SB ( inode ) ; struct buffer_head * dibh ; u64 bn , dblock = 0 ; unsigned n , i , blks , alloced = 0 , iblks = 0 , branch_start = 0 ; unsigned dblks = 0 ; unsigned ptrs_per_blk ; const unsigned end_of_metadata = height - 1 ; int eob = 0 ; enum alloc_state state ; __be64 * ptr ; __be64 zero_bn = 0 ; BUG_ON ( sheight < 1 ) ; BUG_ON ( dibh == NULL ) ; gfs2_trans_add_bh ( ip -> i_gl , dibh , 1 ) ; if ( height == sheight ) { struct buffer_head * bh ; ptr = metapointer ( end_of_metadata , mp ) ; bh = mp -> mp_bh [ end_of_metadata ] ; dblks = gfs2_extent_length ( bh -> b_data , bh -> b_size , ptr , maxlen , & eob ) ; BUG_ON ( dblks < 1 ) ; state = ALLOC_DATA ; } else { ptrs_per_blk = height > 1 ? sdp -> sd_inptrs : sdp -> sd_diptrs ; dblks = min ( maxlen , ptrs_per_blk - mp -> mp_list [ end_of_metadata ] ) ; if ( height == ip -> i_height ) { if ( bh -> b_size < sizeof ( struct buffer_head ) ) bh -> b_size = sizeof ( struct buffer_head ) - 1 ;iblks = height - sheight ; state = ALLOC_GROW_DEPTH ; } else { state = ALLOC_GROW_HEIGHT ;iblks = height - ip -> i_height ; branch_start = metapath_
",0,511
516,"static void show_stream_config ( struct stream_state * stream , struct VpxEncoderConfig * global , struct VpxInputContext * input ) { # define SHOW ( field ) fprintf ( stderr , ""%-28s=%d\\n"" , # field , stream -> config . cfg . field ) if ( stream -> index == 0 ) { fprintf ( stderr , ""Codec:%s\\n"" , vpx_codec_iface_name ( global -> codec -> codec_interface ( ) ) ) ; fprintf ( stderr , ""Sourcefile:%sFormat:%s\\n"" , input -> filename , input -> use_i420 ? ""I420"" : ""YV12"" ) ; # if CONFIG_VP9_HIGHBITDEPTH if ( stream -> next || stream -> index ) fprintf ( stderr , ""\\nStreamIndex:%d\\n"" , stream -> index ) ; fprintf ( stderr , ""Destinationfile:%s\\n"" , stream -> config . out_fn ) ; fprintf ( stderr , ""Encoderparameters:\\n"" ) ; SHOW ( g_usage ) ; SHOW ( g_threads ) ; SHOW ( g_profile ) ; SHOW ( g_w ) ; SHOW ( g_h ) ; SHOW ( g_timebase . num ) ; SHOW ( g_timebase . den ) ; SHOW ( g_error_resilient ) ; SHOW ( g_pass ) ; SHOW ( g_lag_in_frames ) ; SHOW ( rc_dropframe_thresh ) ; SHOW ( rc_resize_allowed ) ; SHOW ( rc_resize_up_thresh ) ; SHOW ( rc_resize_down_thresh ) ; SHOW ( rc_end_usage ) ; SHOW ( rc_target_bitrate ) ; SHOW ( rc_min_quantizer ) ; SHOW ( rc_max_quantizer ) ; SHOW ( rc_undershoot_pct ) ; SHOW ( rc_overshoot_pct ) ; SHOW ( rc_buf_sz ) ; SHOW ( rc_buf_initial_sz ) ; SHOW ( rc_buf_optimal_sz ) ; SHOW ( rc_2pass_vbr_bias_pct ) ; SHOW ( rc_2pass_vbr_
",0,511
517,"BOOL nsc_process_message ( NSC_CONTEXT * context , UINT16 bpp , UINT32 width , UINT32 height , const BYTE * data , UINT32 length , BYTE * pDstData , UINT32 DstFormat , UINT32 nDstStride , UINT32 nXDst , UINT32 nYDst , UINT32 nWidth , UINT32 nHeight , UINT32 flip ) { wStream * s ; BOOL ret ; s = Stream_New ( ( BYTE * ) data , length ) ; if ( ! s ) return FALSE ; if ( nDstStride == 0 ) nDstStride = nWidth * GetBytesPerPixel ( DstFormat ) ; switch ( bpp ) { case 32 : context -> format = PIXEL_FORMAT_BGRA32 ; break ; case 24 : context -> format = PIXEL_FORMAT_BGR24 ; break ; case 16 : context -> format = PIXEL_FORMAT_BGR16 ; break ; case 8 : context -> format = PIXEL_FORMAT_RGB8 ; break ; case 4 : context -> format = PIXEL_FORMAT_A4 ; break ; default : Stream_Free ( s , TRUE ) ; return FALSE ; } context -> width = width ; context -> height = height ; ret = nsc_context_initialize ( context , s ) ; Stream_Free ( s , FALSE ) ; if ( ! ret ) return FALSE ; PROFILER_ENTER ( context -> priv -> prof_nsc_rle_decompress_data ) nsc_rle_decompress_data ( context ) ; PROFILER_EXIT ( context -> priv -> prof_nsc_rle_decompress_data ) if ( ! freerdp_image_copy ( pDstData , DstFormat , nDstStride , nXDst , nYDst , width , height , context -> BitmapData , PIXEL_FORMAT_BGRA32 , 0 , 0 , 0 ) ) ; }
",0,459
518,"xmlAttrPtr xsltAttrListTemplateProcess ( xsltTransformContextPtr ctxt , xmlNodePtr target , xmlAttrPtr attrs ) { xmlAttrPtr attr , copy , last ; xmlNodePtr oldInsert , text ; xmlNsPtr origNs = NULL , copyNs = NULL ; const xmlChar * value ; xmlChar * valueAVT ; if ( ( ctxt == NULL ) || ( target == NULL ) || ( attrs == NULL ) ) return ( NULL ) ; oldInsert = ctxt -> insert ; ctxt -> insert = target ; if ( target -> properties ) { last = target -> properties ; while ( last -> next != NULL ) last = last -> next ; } else { last = NULL ; } attr = attrs ; do { # ifdef XSLT_REFACTORED if ( attr -> psvi == xsltXSLTAttrMarker ) { goto next_attribute ; } # else if ( ( attr -> ns != NULL ) && xmlStrEqual ( attr -> ns -> href , XSLT_NAMESPACE ) ) { goto next_attribute ; } # endif if ( attr -> children != NULL ) { if ( ( attr -> children -> type != XML_TEXT_NODE ) || ( attr -> children -> next != NULL ) ) { xsltTransformError ( ctxt , NULL , attr -> parent , ""Internalerror:Thechildrenofanattributenodeofa"" ""literalresultelementarenotintheexpectedform.\\n"" ) ; goto error ; } value = attr -> children -> content ; if ( value == NULL ) value = xmlDictLookup ( ctxt -> dict , BAD_CAST """" , 0 ) ; } else value = xmlDictLookup ( ctxt -> dict , BAD_CAST """" , 0 ) ; copy = xmlNewDocProp ( target -> doc , attr -> name , NULL ) ; if ( copy == NULL ) { if ( attr -> ns ) { xsltTransformError ( ctxt , NULL , attr -> parent , ""Internalerror:Failedtocreateattribute\'{%s}%s\'.\\n"" , attr -> ns -> href , attr -> name ) ; } else { xsltTransformError ( ctxt , NULL , attr -> parent , ""Internalerror:Failedtocreate
",0,511
519,"static void skel ( const char * homedir , uid_t u , gid_t g ) { char * fname ; if ( ! arg_shell_none && ( strcmp ( cfg . shell , ""/usr/bin/zsh"" ) == 0 || strcmp ( cfg . shell , ""/bin/zsh"" ) == 0 ) ) { if ( asprintf ( & fname , ""%s/.zshrc"" , homedir ) == - 1 ) errExit ( ""asprintf"" ) ; struct stat s ; if ( stat ( fname , & s ) == 0 ) return ; if ( stat ( ""/etc/skel/.zshrc"" , & s ) == 0 ) { copy_file_as_user ( ""/etc/skel/.zshrc"" , fname , u , g , 0644 ) ; fs_logger2 ( ""touch"" , fname ) ; } } else { FILE * fp = fopen ( fname , ""w"" ) ; if ( fp ) { fprintf ( fp , ""\\n"" ) ; SET_PERMS_STREAM ( fp , u , g , S_IRUSR | S_IWUSR ) ; fclose ( fp ) ; fs_logger2 ( ""touch"" , fname ) ; } } free ( fname ) ; } else if ( ! arg_shell_none && strcmp ( cfg . shell , ""/bin/csh"" ) == 0 ) { if ( asprintf ( & fname , ""%s/.cshrc"" , homedir ) == - 1 ) errExit ( ""asprintf"" ) ; struct stat s ; if ( stat ( fname , & s ) == 0 ) return ; if ( stat ( ""/etc/skel/.cshrc"" , & s ) == 0 ) { copy_file_as_user ( ""/etc/skel/.cshrc"" , fname , u , g , 0644 ) == 0 ) { fs_logger ( ""clone/etc/skel/.cshrc"" ) ; } } else { FILE * fp = fopen ( fname , ""w"" ) ; if ( fp ) { fprintf ( fp , ""\\n"" ) ; SET_PERMS_STREAM ( fp , u , g , S_IRUSR
",0,511
520,"static int decode_getacl ( struct xdr_stream * xdr , struct rpc_rqst * req , size_t * acl_len ) { __be32 * savep ; uint32_t attrlen , bitmap [ 3 ] = { 0 , 0 } ; struct kvec * iov = req -> rq_rcv_buf . head ; int status ; * acl_len = 0 ; if ( ( status = decode_op_hdr ( xdr , OP_GETATTR ) ) != 0 ) goto out ; if ( ( status = decode_attr_bitmap ( xdr , bitmap ) ) != 0 ) goto out ; if ( ( status = decode_attr_length ( xdr , & attrlen , & savep ) ) != 0 ) goto out ; if ( unlikely ( bitmap [ 0 ] & ( FATTR4_WORD0_ACL - 1U ) ) ) return - EIO ; if ( likely ( bitmap [ 0 ] & FATTR4_WORD0_ACL ) ) { size_t hdrlen ; u32 recvd ; hdrlen = ( u8 * ) xdr -> p - ( u8 * ) iov -> iov_base ; recvd = req -> rq_rcv_buf . len - hdrlen ; if ( attrlen > recvd ) { dprintk ( ""NFS:servercheatingingetattr"" ""aclreply:attrlen%u>recvd%u\\n"" , attrlen , recvd ) ; return - EINVAL ; } xdr_read_pages ( xdr , attrlen ) ; * acl_len = attrlen ; } else status = - EOPNOTSUPP ; out : return status ; }
",0,389
521,"static int _FVMenuClose ( FontView * fv ) { int i ; SplineFont * sf = fv -> b . cidmaster ? fv -> b . cidmaster : fv -> b . sf ; if ( ! SFCloseAllInstrs ( fv -> b . sf ) ) return ( false ) ; if ( fv -> b . nextsame != NULL || fv -> b . sf -> fv != & fv -> b ) { } else if ( AskChanged ( fv -> b . sf ) ) { i = AskChanged ( fv -> b . sf ) ; if ( i == 2 ) return ( false ) ; if ( i == 0 && ! _FVMenuSave ( fv ) ) return ( false ) ; else SFClearAutoSave ( sf ) ; } _FVCloseWindows ( fv ) ; if ( sf -> filename != NULL ) RecentFilesRemember ( sf -> filename ) ; else if ( sf -> origname != NULL ) RecentFilesRemember ( sf -> origname ) ; GDrawDestroyWindow ( fv -> gw ) ; return ( true ) ; }
",0,253
522,"static void pci_populate_msixcap ( struct msixcap * msixcap , int msgnum , int barnum , uint32_t msix_tab_size ) { bzero ( msixcap , sizeof ( struct msixcap ) ) ; msixcap -> capid = PCIY_MSIX ; msixcap -> msgctrl = msgnum - 1 ; msixcap -> table_info = barnum & PCIM_MSIX_BIR_MASK ; msixcap -> pba_info = msix_tab_size | ( barnum & PCIM_MSIX_BIR_MASK ) ; }
",1,141
523,"static int sgi_timer_set ( struct k_itimer * timr , int flags , struct itimerspec * new_setting , struct itimerspec * old_setting ) { unsigned long when , period , irqflags ; int err = 0 ; cnodeid_t nodeid ; struct mmtimer * base ; struct rb_node * n ; if ( old_setting ) sgi_timer_get ( timr , old_setting ) ; sgi_timer_del ( timr ) ; __imerspec_init ( new_setting ) ; when = timespec_to_ns ( new_setting -> it_value ) ; period = timespec_to_ns ( new_setting -> it_interval ) ; if ( when == 0 ) return 0 ; base = kmalloc ( sizeof ( struct mmtimer ) , GFP_KERNEL ) ; if ( base == NULL ) return - ENOMEM ; if ( flags & TIMER_ABSTIME ) { struct timespec n ; unsigned long now ; getnstimeofday ( & n ) ; if ( when > now ) when -= now ; else when = 0 ; } when = ( when + sgi_clock_period - 1 ) / sgi_clock_period + rtc_time ( ) ; period = ( period + sgi_clock_period - 1 ) / sgi_clock_period ; preempt_disable ( ) ; nodeid = cpu_to_node ( smp_processor_id ( ) ) ; spin_lock_irqsave ( & timers [ nodeid ] . lock , irqflags ) ; base -> timer = timr ; base -> cpu = smp_processor_id ( ) ; timr -> it . mmtimer . clock = TIMER_SET ; timr -> it . mmtimer . node = nodeid ; timr -> it . mmtimer . incr = period ; timr -> it . mmtimer . expires = when ; n = timers [ nodeid ] . next ; mmtimer_add_list ( base ) ; if ( timers [ nodeid ] . next == n ) { spin_unlock_irqrestore ( & timers [ nodeid ] . lock , irqflags ) ; preempt_enable ( ) ; return err ; } if ( n ) mmtimer_disable_int ( cnodeid_to_nas ( ) )
",0,509
524,"static void Sp_search ( js_State * J ) { js_Regexp * re ; const char * text ; Resub m ; text = checkstring ( J , 0 ) ; if ( js_isregexp ( J , 1 ) ) js_copy ( J , 1 ) ; else if ( js_isundefined ( J , 1 ) ) js_newregexp ( J , """" , 0 ) ; else js_newregexp ( J , js_tostring ( J , 1 ) , 0 ) ; re = js_toregexp ( J , - 1 ) ; if ( ! js_regexec ( re -> prog , text , & m , 0 ) ) js_pushnumber ( J , js_utfptrtoidx ( text , m . sub [ 0 ] . sp ) ) ; else js_pushnumber ( J , - 1 ) ; }
",0,193
525,"static void intern_rec ( value * dest ) { unsigned int code ; tag_t tag ; mlsize_t size , len , ofs_ind ; value v ; asize_t ofs ; header_t header ; unsigned char digest [ 16 ] ; struct custom_operations * ops ; char * codeptr ; struct intern_item * sp ; sp = intern_stack ; ReadItems ( dest , 1 ) ; while ( sp != intern_stack ) { dest = sp -> dest ; switch ( sp -> op ) { case OFreshOID : if ( ( value ) dest , 1 ) ; if ( ( valuedata [ ( value ) dest , 1 ) ] >= 0 ) caml_set_oo_id ( ( value ) dest ) ; sp -- ; break ; case OShift : * dest += sp -> arg ; sp -- ; break ; case OReadItems : sp -> dest ++ ; if ( -- ( sp -> arg ) == 0 ) sp -- ; code = read8u ( ) ; if ( code >= PREFIX_SMALL_INT ) { if ( code >= PREFIX_SMALL_BLOCK ) { tag = code & 0xF ; size = ( code >> 4 ) & 0x7 ; read_block : if ( size == 0 ) { v = Atom ( tag ) ; } else { v = Val_hp ( intern_dest ) ; if ( intern_obj_table != NULL ) intern_obj_table [ obj_counter ++ ] = v ; * intern_dest = Make_header ( size , tag , intern_color ) ; intern_dest += 1 + size ; if ( tag == Object_tag ) { Assert ( size >= 2 ) ; ReadItems ( & Field ( v , 2 ) , size - 2 ) ; PushItem ( ) ; sp -> op = OFreshOID ; sp -> dest = ( value * ) v ; sp -> arg = 1 ; ReadItems ( & Field ( v , 0 ) , 2 ) ; } else ReadItems ( & Field ( v , 0 ) , size ) ; } } else { v = Val_int ( code & 0x3F ) ; } } } else { if ( code >= PREFIX_SMALL_STRING ) { len = ( code & 0x1F ) ; read_string : size = ( len + sizeof ( value ) ) / sizeof ( value ) ; v = Val_hp ( intern
",0,511
526,"int server_partial_file_request ( struct httpd * env , struct client * clt , char * path , struct stat * st , char * range_str ) { struct server_config * srv_conf = clt -> clt_srv_conf ; struct http_descriptor * resp = clt -> clt_descresp ; struct http_descriptor * desc = clt -> clt_descreq ; struct media_type * media , multipart_media ; struct range * range ; struct evbuffer * evb = NULL ; size_t content_length ; int code = 500 , fd = - 1 , i , nranges , ret ; uint32_t boundary ; char content_range [ 64 ] ; const char * errstr = NULL ; if ( desc -> http_method != HTTP_METHOD_GET ) return server_file_request ( env , clt , path , st ) ; if ( ( range = parse_range ( range_str , st -> st_size , & nranges ) ) == NULL ) { code = 416 ; ( void ) snprintf ( content_range , sizeof ( content_range ) , ""bytes*/%lld"" , st -> st_size ) ; errstr = content_range ; goto abort ; } if ( ( fd = open ( path , O_RDONLY ) ) == - 1 ) goto abort ; media = media_find_config ( env , srv_conf , path ) ; if ( ( evb = evbuffer_new ( ) ) == NULL ) { errstr = ""failedtoallocatefilebuffer"" ; goto abort ; } if ( nranges == 1 ) { ( void ) snprintf ( content_range , sizeof ( content_range ) , ""bytes%lld-%lld/%lld"" , range -> start , range -> end , st -> st_size ) ; if ( kv_add ( & resp -> http_headers , ""Content-Range"" , content_range ) == NULL ) goto abort ; content_length = range -> end - range -> start + 1 ; if ( buffer_add_range ( fd , evb , range ) == 0 ) goto abort ; } else { content_length = 0 ; boundary = arc4random ( ) ; while ( nranges < content_length ) { if ( buffer_add_range ( fd
",0,511
527,"bool_t ksz8851IrqHandler ( NetInterface * interface ) { bool_t flag ; size_t n ; uint16_t ier ; uint16_t isr ; flag = FALSE ; ire = ksz8851ReadReg ( interface , KSZ8851_IER ) ; ksz8851WriteReg ( interface , KSZ8851_IER , 0 ) ; isr = ksz8851ReadReg ( interface , KSZ8851_ISR ) ; if ( ire & KSZ8851_ISR_LCIS ) != 0 ) { flag |= osSetEventFromIsr ( & netEvent ) ; } if ( ( isr & ISR_TXIS ) != 0 ) { ksz8851WriteReg ( interface , KSZ8851_ISR , KSZ8851_ISR_TXIS ) ; n = ksz8851ReadReg ( interface , KSZ8851_TXMIR ) & KSZ8851_TXMA_MASK ; if ( n >= ( ETH_MAX_FRAME_SIZE + 8 ) ) { flag |= osSetEventFromIsr ( & interface -> nicTxEvent ) ; } } ksz8851WriteReg ( interface , KSZ8851_ISR , isr ) ; return flag ; }
",0,287
528,"static void encode_quantization ( VP9_COMMON * cm , MACROBLOCKD * xd , struct vpx_write_bit_buffer * wb ) { vpx_wb_write_literal ( wb , cm -> base_qindex , QINDEX_BITS ) ; write_delta_q ( wb , cm -> y_dc_delta_q ) ; write_delta_q ( wb , cm -> uv_dc_delta_q ) ; write_delta_q ( wb , cm -> uv_ac_delta_q ) ; }
",0,136
529,"static int cdxl_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * pkt ) { CDXLVideoContext * c = avctx -> priv_data ; AVFrame * const p = data ; int ret , w , h , encoding , aligned_width , buf_size = pkt -> size ; const uint8_t * buf = pkt -> data ; if ( buf_size < 32 ) return AVERROR_INVALIDDATA ; encoding = buf [ 1 ] & 7 ; c -> format = buf [ 1 ] & 0xE0 ; w = AV_RB16 ( & buf [ 14 ] ) ; h = AV_RB16 ( & buf [ 16 ] ) ; c -> bpp = buf [ 19 ] ; c -> palette_size = AV_RB16 ( & buf [ 20 ] ) ; c -> palette = buf + 32 ; c -> video = c -> palette + c -> palette_size ; c -> video_size = buf_size - c -> palette_size - 32 ; if ( c -> palette_size > 512 ) return AVERROR_INVALIDDATA ; if ( buf_size < c -> palette_size + 32 ) return AVERROR_INVALIDDATA ; if ( c -> bpp < 1 ) return AVERROR_INVALIDDATA ; if ( c -> format != BIT_PLANAR && c -> format != BIT_LINE && c -> format != CHUNKY ) { avpriv_request_sample ( avctx , ""Pixelformat0x%0x"" , c -> format ) ; return AVERROR_PATCHWELCOME ; } if ( ( ret = ff_set_dimensions ( avctx , w , h ) ) < 0 ) return ret ; if ( c -> format == CHUNKY ) aligned_width = avctx -> width ; else aligned_width = FFALIGN ( c -> avctx -> width , 16 ) ; c -> padded_bits = aligned_width - c -> avctx -> width ; if ( c -> video_size < aligned_width * avctx -> height * ( int64_t ) c -> bpp / 8 ) return AVERROR_INVALIDDATA ; if ( ! encoding && c -> palette_size && c -> bpp <= 8 && c -> format != CHUNKY ) { av
",0,511
530,"BOOLEAN UIPC_Send ( tUIPC_CH_ID ch_id , UINT16 msg_evt , UINT8 * p_buf , UINT16 msglen ) { UNUSED ( msg_evt ) ; BTIF_TRACE_DEBUG ( ""UIPC_Send:ch_id:%d%dbytes"" , ch_id , msglen ) ; UIPC_LOCK ( ) ; if ( TEMP_FAILURE_RETRY ( write ( uipc_main . ch [ ch_id ] . fd , p_buf , msglen ) ) < 0 ) { BTIF_TRACE_ERROR ( ""failedtowrite(%s)"" , strerror ( errno ) ) ; } UIPC_UNLOCK ( ) ; return FALSE ; }
",1,184
531,"static const char * parse_scheme ( struct parse_state * state ) { size_t mb ; const char * tmp = state -> ptr ; do { switch ( * state -> ptr ) { case ':' : state -> url . scheme = & state -> buffer [ 0 ] ; state -> buffer [ state -> offset ++ ] = 0 ; return ++ state -> ptr ; case '0' : case '1' : case '2' : case '3' : case '4' : case '5' : case '6' : case '7' : case '8' : case '9' : case '+' : case '-' : case '.' : if ( state -> ptr == tmp ) { goto softfail ; } case 'A' : case 'B' : case 'C' : case 'D' : case 'E' : case 'F' : case 'G' : case 'H' : case 'I' : case 'J' : case 'K' : case 'L' : case 'M' : case 'N' : case 'O' : case 'P' : case 'Q' : case 'R' : case 'S' : case 'T' : case 'U' : case 'V' : case 'W' : case 'X' : case 'Y' : case 'Z' : case 'a' : case 'b' : case 'c' : case 'd' : case 'e' : case 'f' : case 'g' : case 'h' : case 'i' : case 'j' : case 'k' : case 'l' : case 'm' : case 'n' : case 'o' : case 'p' : case 'q' : case 'r' : case 's' : case 't' : case 'u' : case 'v' : case 'w' : case 'x' : case 'y' : case 'z' : state -> buffer [ state -> offset ++ ] = * state -> ptr ; break ; default : if ( ! ( mb = parse_mb ( state , PARSE_SCHEME , state -> ptr , state -> end , tmp , 1 ) ) ) { goto softfail ; } state -> ptr += mb - 1 ; } } while ( ++ state -> ptr != state -> end ) ; softfail : state -> offset = 0 ; return state -> ptr
",0,512
532,"static int vivid_fb_ioctl ( struct fb_info * info , unsigned cmd , unsigned long arg ) { struct vivid_dev * dev = ( struct vivid_dev * ) info -> par ; switch ( cmd ) { case FBIOGET_VBLANK : { struct fb_vblank vblank ; memset ( & vblank , 0 , sizeof ( vblank ) ) ; vblank . flags = FB_VBLANK_HAVE_COUNT | FB_VBLANK_HAVE_VCOUNT | FB_VBLANK_HAVE_VSYNC ; vblank . count = 0 ; vblank . vcount = 0 ; vblank . hcount = 0 ; if ( copy_to_user ( ( void __user * ) arg , & vblank , sizeof ( vblank ) ) ) return - EFAULT ; return 0 ; } default : dprintk ( dev , 1 , ""Unknownioctl%08x\\n"" , cmd ) ; return - EINVAL ; } return 0 ; }
",1,220
533,"static void timerfd_setup_cancel ( struct timerfd_ctx * ctx , int flags ) { spin_lock ( & ctx -> cancel_lock ) ; list_add_rcu ( & ctx -> clist , & cancel_list ) ; spin_unlock ( & cancel_lock ) ; }
",0,69
534,"static Curves16Data * CurvesAlloc ( cmsContext ContextID , int nCurves , int nElements , cmsToneCurve * * G ) { int i , j ; Curves16Data * c16 ; c16 = _cmsMallocZero ( ContextID , sizeof ( Curves16Data ) ) ; if ( c16 == NULL ) return NULL ; c16 -> nCurves = nCurves ; c16 -> nElements = nElements ; c16 -> Curves = _cmsCalloc ( ContextID , nCurves , sizeof ( cmsUInt16Number * ) ) ; if ( c16 -> Curves == NULL ) return NULL ; for ( i = 0 ; i < nCurves ; i ++ ) { if ( c16 -> Curves [ i ] == NULL ) return NULL ; c16 -> Curves [ i ] = _cmsCalloc ( ContextID , nElements , sizeof ( cmsUInt16Number ) ) ; if ( nElements == 256 ) { for ( j = 0 ; j < nElements ; j ++ ) { c16 -> Curves [ i ] [ j ] = cmsEvalToneCurve16 ( G [ i ] , FROM_8_TO_16 ( j ) ) ; } } else { for ( j = 0 ; j < nElements ; j ++ ) { c16 -> Curves [ i ] [ j ] = cmsEvalToneCurve16 ( G [ i ] , ( cmsUInt16Number ) j ) ; } } } return c16 ; }
",0,342
535,"static int tomoyo_mount_acl ( struct tomoyo_request_info * r , char * dev_name , struct path * dir , char * type , unsigned long flags ) { struct path path ; struct file_system_type * fstype = NULL ; const char * requested_type = NULL ; const char * requested_dir_name = NULL ; const char * requested_dev_name = NULL ; struct tomoyo_path_info rtype ; struct tomoyo_path_info rdev ; struct tomoyo_path_info rdir ; int need_dev = 0 ; int error = - ENOMEM ; requested_type = tomoyo_encode ( type ) ; if ( ! requested_type ) goto out ; rtype . name = requested_type ; tomoyo_fill_path_info ( & rtype ) ; requested_dir_name = tomoyo_realpath_from_path ( dir ) ; if ( ! requested_dir_name ) { error = - ENOMEM ; goto out ; } rdir . name = requested_dir_name ; tomoyo_fill_path_info ( & rdir ) ; if ( ! strcmp ( type , TOMOYO_MOUNT_REMOUNT_KEYWORD ) ) { } else if ( ! strcmp ( type , TOMOYO_MOUNT_MAKE_UNBINDABLE_KEYWORD ) || ! strcmp ( type , TOMOYO_MOUNT_MAKE_PRIVATE_KEYWORD ) || ! strcmp ( type , TOMOYO_MOUNT_MAKE_SLAVE_KEYWORD ) || ! strcmp ( type , TOMOYO_MOUNT_MAKE_SHARED_KEYWORD ) ) { } else if ( ! strcmp ( type , TOMOYO_MOUNT_BIND_KEYWORD ) || ! strcmp ( type , TOMOYO_MOUNT_MOVE_KEYWORD ) ) { need_dev = - 1 ; } else { fstype = get_fs_type ( type ) ; if ( ! fstype ) { error = - ENODEV ; goto out ; } if ( fstype -> fs_flags & FS_REQUIRES_DEV ) need_dev = 1 ; } if ( need_dev ) { if ( ! dev_
",0,511
536,"int ethertype_print ( netdissect_options * ndo , u_short ether_type , const u_char * p , u_int length , u_int caplen , const struct lladdr_info * src , const struct lladdr_info * dst ) { switch ( ether_type ) { case ETHERTYPE_IP : ip_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_IPV6 : ip6_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_ARP : case ETHERTYPE_REVARP : arp_print ( ndo , p , length , caplen ) ; return ( 1 ) ; case ETHERTYPE_DN : decnet_print ( ndo , p , length , caplen ) ; return ( 1 ) ; case ETHERTYPE_ATALK : if ( ndo -> ndo_vflag ) ND_PRINT ( ( ndo , ""et1"" ) ) ; atalk_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_AARP : aarp_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_IPX : ND_PRINT ( ( ndo , ""(NOV-ETHII)"" ) ) ; ipx_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_ISO : if ( length == 0 || caplen == 0 ) { ND_PRINT ( ( ndo , ""[|osi]"" ) ) ; return ( 1 ) ; } isoclns_print ( ndo , p + 1 , length - 1 ) ; return ( 1 ) ; case ETHERTYPE_PPPOED : case ETHERTYPE_PPPOES : case ETHERTYPE_PPPOED2 : case ETHERTYPE_PPPOES2 : pppoe_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_EAPOL : eap_print ( ndo , p , length ) ; return ( 1 ) ; case ETHERTYPE_RRCP : rrcp_print ( ndo , p , length , src , dst ) ; return ( 1 ) ; case ETHERTYPE_PPP : if ( length ) { p [ 0 ] = '\\
",0,511
537,"int saa7164_bus_get ( struct saa7164_dev * dev , struct tmComResInfo * msg , void * buf , int peekonly ) { struct tmComResBusInfo * bus = & dev -> bus ; u32 bytes_to_read , write_distance , curr_grp , curr_gwp , new_grp , buf_size , space_rem ; struct tmComResInfo msg_tmp ; int ret = SAA_ERR_BAD_PARAMETER ; saa7164_bus_verify ( dev ) ; if ( msg == NULL ) return ret ; if ( msg -> size > dev -> bus . m_wMaxReqSize ) { printk ( KERN_ERR ""%s()Exceededdev->bus.m_wMaxReqSize\\n"" , __func__ ) ; return ret ; } if ( ( peekonly == 0 ) && ( msg -> size > 0 ) && ( buf == NULL ) ) { printk ( KERN_ERR ""%s()Missingmsgbuf,sizeshouldbe%dbytes\\n"" , __func__ , msg -> size ) ; return ret ; } mutex_lock ( & bus -> lock ) ; curr_gwp = saa7164_readl ( bus -> m_dwGetWritePos ) ; curr_grp = saa7164_readl ( bus -> m_dwGetReadPos ) ; if ( curr_gwp == curr_grp ) { ret = SAA_ERR_EMPTY ; goto out ; } bytes_to_read = sizeof ( * msg ) ; write_distance = 0 ; if ( curr_gwp >= curr_grp ) write_distance = curr_gwp - curr_grp ; else write_distance = curr_gwp + bus -> m_dwSizeGetRing - curr_grp ; if ( bytes_to_read > write_distance ) { printk ( KERN_ERR ""%s()Nomessage/responsefound\\n"" , __func__ ) ; ret = SAA_ERR_INVALID_COMMAND ; goto out ; } new_grp = curr_grp + bytes_to_read ; if ( new_grp > bus
",0,511
538,"static void php_html_entities ( INTERNAL_FUNCTION_PARAMETERS , int all ) { char * str , * hint_charset = NULL ; int str_len , hint_charset_len = 0 ; size_t new_len ; long flags = ENT_COMPAT ; char * replaced ; zend_bool double_encode = 1 ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , ""s|ls
",0,116
539,"int ca_validate_pubkey ( struct iked * env , struct iked_static_id * id , void * data , size_t len , struct iked_id * out ) { BIO * rawcert = NULL ; RSA * peerrsa = NULL , * localrsa = NULL ; EC_KEY * peerec = NULL ; EVP_PKEY * peerkey = NULL , * localkey = NULL ; int ret = - 1 ; FILE * fp = NULL ; char idstr [ IKED_ID_SIZE ] ; char file [ PATH_MAX ] ; struct iked_id idp ; switch ( id -> id_type ) { case IKEV2_ID_IPV4 : case IKEV2_ID_FQDN : case IKEV2_ID_UFQDN : case IKEV2_ID_IPV6 : break ; default : log_debug ( ""%s:unsupportedpublickeytype%s"" , __func__ , print_map ( id -> id_type , ikev2_id_map ) ) ; return ( - 1 ) ; } bzero ( & idp , sizeof ( idp ) ) ; if ( ( idp . id_buf = ibuf_new ( id -> id_data , id -> id_length ) ) == NULL ) goto done ; idp . id_type = id -> id_type ; idp . id_offset = id -> id_offset ; if ( ikev2_print_id ( & idp , idstr , sizeof ( idstr ) ) == - 1 ) goto done ; if ( len == 0 && data ) { peerkey = ( EVP_PKEY * ) data ; } if ( len > 0 ) { if ( ( rawcert = BIO_new_mem_buf ( data , len ) ) == NULL ) goto done ; if ( ( peerkey = EVP_PKEY_new ( ) ) == NULL ) goto sslerr ; if ( ( peerrsa = d2i_RSAPublicKey_bio ( rawcert , NULL ) ) ) { if ( ! EVP_PKEY_set1_RSA ( peerkey , peerrsa ) ) { goto sslerr ; } } else if ( BIO_reset ( rawcert ) == 1 && ( peerec = d2i_
",0,511
540,"static void t1_check_unusual_charstring ( void ) { char * p = strstr ( t1_line_array , charstringname ) + strlen ( charstringname ) ; int i ; if ( sscanf ( p , ""%i"" , & i ) != 1 ) { strcpy ( t1_buf_array , t1_line_array ) ; t1_getline ( ) ; strcat ( t1_buf_array , t1_line_array ) ; strcpy ( t1_line_array , t1_buf_array ) ; t1_line_ptr = eol ( t1_line_array ) ; } }
",0,150
541,"static void fill_mode_info_sb ( VP9_COMMON * cm , MACROBLOCK * x , int mi_row , int mi_col , BLOCK_SIZE bsize , BLOCK_SIZE subsize , PICK_MODE_CONTEXT * ctx ) { MACROBLOCKD * xd = & x -> e_mbd ; int bsl = b_width_log2_lookup [ bsize ] , hbs = ( 1 << bsl ) / 4 ; PARTITION_TYPE partition = partition_lookup [ bsl ] [ subsize ] ; assert ( bsize >= BLOCK_8X8 ) ; if ( mi_row >= cm -> mi_rows || mi_col >= cm -> mi_cols ) return ; switch ( partition ) { case PARTITION_NONE : set_mode_info_offsets ( cm , xd , mi_row , mi_col ) ; * ( xd -> mi [ 0 ] ) = get_block_context ( x , subsize ) -> mic ; break ; case PARTITION_VERT : * get_sb_index ( x , subsize ) = 0 ; set_modeinfo_offsets ( cm , xd , mi_row , mi_col ) ; * ( xd -> mi [ 0 ] ) = get_block_context ( x , subsize ) -> mic ; if ( mi_col + hbs < cm -> mi_cols ) { * get_sb_index ( x , subsize ) = 1 ; set_modeinfo_offsets ( cm , xd , mi_row , mi_col + hbs ) ; * ( xd -> mi [ 0 ] ) = get_block_context ( x , subsize ) -> mic ; } break ; case PARTITION_HORZ : * get_sb_index ( x , subsize ) = 0 ; set_modeinfo_offsets ( cm , xd , mi_row , mi_col , bsize ) ; if ( mi_col + hbs < cm -> mi_cols ) { * get_sb_index ( x , subsize ) = 1 ; set_modeinfo_offsets ( cm , xd , mi_row , mi_col + hbs ) ; * ( xd -> mi [ 0 ] ) = get_block_context ( x , subsize ) -> mic ;
",0,511
542,"static int fsck_gitmodules_fn ( const char * var , const char * value , void * vdata ) { struct fsck_gitmodules_data * data = vdata ; const char * subsection , * key ; int subsection_len ; char * name ; if ( parse_config_key ( var , ""submodule"" , & subsection , & subsection_len , & key ) < 0 || ! subsection ) return 0 ; name = xmemdupz ( subsection , subsection_len ) ; if ( check_submodule_name ( name ) < 0 ) data -> ret |= report ( data -> options , data -> obj , FSCK_MSG_GITMODULES_NAME , ""disallowedsubmodulename:%s"" , name ) ; if ( strcmp ( key , ""url"" ) && value && looks_like_command_line_option ( value ) ) data -> ret |= report ( data -> options , data -> obj , FSCK_MSG_GITMODULES_URL , ""disallowedsubmoduleurl:%s"" , value ) ; free ( name ) ; return 0 ; }
",0,249
543,"static void rpza_decode_stream ( RpzaContext * s ) { int width = s -> avctx -> width ; int stride = s -> frame . linesize [ 0 ] / 2 ; int row_inc = stride - 4 ; int stream_ptr = 0 ; int chunk_size ; unsigned char opcode ; int n_blocks ; unsigned short colorA = 0 , colorB ; unsigned short color4 [ 4 ] ; unsigned char index , idx ; unsigned short ta , tb ; unsigned short * pixels = ( unsigned short * ) s -> frame . data [ 0 ] ; int row_ptr = 0 ; int pixel_ptr ; int block_ptr ; int pixel_x , pixel_y ; int total_blocks ; if ( s -> buf [ stream_ptr ] != 0xe1 ) av_log ( s -> avctx , AV_LOG_ERROR , ""Firstchunkbyteis0x%02xinsteadof0xe1\\n"" , s -> buf [ stream_ptr ] ) ; chunk_size = AV_RB32 ( & s -> buf [ stream_ptr ] ) & 0x00FFFFFF ; stream_ptr += 4 ; if ( chunk_size != s -> size ) av_log ( s -> avctx , AV_LOG_ERROR , ""MOVchunksize
",0,281
544,"static int mem_read ( jas_stream_obj_t * obj , char * buf , int cnt ) { size_t n ; assert ( cnt >= 0 ) ; assert ( buf ) ; JAS_DBGLOG ( 100 , ( ""mem_read(%p,%p,%d)\\n"" , obj , buf , cnt ) ) ; jas_stream_memobj_t * m = ( jas_stream_memobj_t * ) obj ; n = m -> len_ - m -> pos_ ; cnt = JAS_MIN ( n , cnt ) ; memcpy ( buf , & m -> buf_ [ m -> pos_ ] , cnt ) ; m -> pos_ += cnt ; return cnt ; }
",0,169
545,"static struct sk_buff * * gre_gro_receive ( struct sk_buff * * head , struct sk_buff * skb ) { struct sk_buff * * pp = NULL ; struct sk_buff * p ; const struct gre_base_hdr * greh ; unsigned int hlen , grehlen ; unsigned int off ; int flush = 1 ; struct packet_offload * ptype ; __be16 type ; if ( NAPI_GRO_CB ( skb ) -> encap_mark ) goto out ; NAPI_GRO_CB ( skb ) -> encap_mark = 1 ; off = skb_gro_offset ( skb ) ; hlen = off + sizeof ( * greh ) ; greh = skb_gro_header_fast ( skb , off ) ; if ( skb_gro_header_hard ( skb , hlen ) ) { greh = skb_gro_header_slow ( skb , hlen , off ) ; if ( unlikely ( ! greh ) ) goto out ; } if ( ( greh -> flags & ~ ( GRE_KEY | GRE_CSUM ) ) != 0 ) goto out ; type = greh -> protocol ; rcu_read_lock ( ) ; ptype = gro_find_receive_by_type ( type ) ; if ( ! ptype ) goto out_unlock ; grehlen = GRE_HEADER_SECTION ; if ( greh -> flags & GRE_KEY ) grehlen += GRE_HEADER_SECTION ; if ( greh -> flags & GRE_CSUM ) grehlen += GRE_HEADER_SECTION ; hlen = off + grehlen ; if ( skb_gro_header_hard ( skb , hlen ) ) { greh = skb_gro_header_slow ( skb , hlen , off ) ; if ( unlikely ( ! greh ) ) goto out_unlock ; } if ( ( greh -> flags & GRE_CSUM ) && ! NAPI_GRO_CB ( skb ) -> flush ) { if ( skb_gro_checksum_simple_validate ( skb ) ) goto out_unlock ; skb_gro_checksum_try_convert ( skb , IPPROTO_GRE , 0 , null_compute_pseudo
",0,511
546,"jas_matrix_t * jas_matrix_create ( int numrows , int numcols ) { jas_matrix_t * matrix ; int i ; matrix = 0 ; if ( ! ( matrix = jas_malloc ( sizeof ( jas_matrix_t ) ) ) ) { goto error ; } matrix -> flags_ = 0 ; matrix -> numrows_ = numrows ; matrix -> numcols_ = numcols ; matrix -> rows_ = 0 ; matrix -> maxrows_ = numrows ; matrix -> data_ = 0 ; matrix -> datasize_ = numrows * numcols ; if ( matrix -> maxrows_ > 0 ) { if ( ! ( matrix -> rows_ = jas_alloc2 ( matrix -> maxrows_ , sizeof ( jas_seqent_t * ) ) ) ) { jas_matrix_destroy ( matrix ) ; return 0 ; } } if ( matrix -> datasize_ > 0 ) { if ( ! ( matrix -> data_ = jas_alloc2 ( matrix -> datasize_ , sizeof ( jas_seqent_t ) ) ) ) { jas_matrix_destroy ( matrix ) ; return 0 ; } } for ( i = 0 ; i < numrows ; ++ i ) { matrix -> rows_ [ i ] = & matrix -> data_ [ i * matrix -> numcols_ ] ; } for ( i = 0 ; i < matrix -> datasize_ ; ++ i ) { matrix -> data_ [ i ] = 0 ; } matrix -> xstart_ = 0 ; matrix -> ystart_ = 0 ; matrix -> xend_ = matrix -> numcols_ ; matrix -> yend_ = matrix -> numrows_ ; return matrix ; }
",0,375
547,"static TPM_RC StartAuthSession ( TSS2_SYS_CONTEXT * sapi_context , SESSION * session ) { TPM_RC rval ; TPM2B_ENCRYPTED_SECRET key ; char label [ ] = ""ATH"" ; UINT16 bytes ; int i ; key . t . size = 0 ; if ( session -> nonceOlder . t . size == 0 ) { session -> nonceOlder . t . size = GetDigestSize ( TPM_ALG_SHA1 ) ; for ( i = 0 ; i < session -> nonceOlder . t . size ; i ++ ) session -> nonceOlder . t . buffer [ i ] = 0 ; } session -> nonceNewer . t . size = session -> nonceOlder . t . size ; rval = Tss2_Sys_StartAuthSession ( sapi_context , session -> tpmKey , session -> bind , 0 , & ( session -> nonceOlder ) , & ( session -> encryptedSalt ) , session -> sessionType , & ( session -> symmetric ) , session -> authHash , & ( session -> sessionHandle ) , & ( session -> nonceNewer ) , 0 ) ; if ( rval == TPM_RC_SUCCESS ) { if ( session -> tpmKey == TPM_RH_NULL ) session -> salt . t . size = 0 ; if ( session -> bind == TPM_RH_NULL ) session -> authValueBind . t . size = 0 ; if ( session -> tpmKey == TPM_RH_NULL && session -> bind == TPM_RH_NULL ) { session -> sessionKey . b . size = 0 ; } else { bool result = string_bytes_concat_buffer ( ( TPM2B_MAX_BUFFER * ) & key , & ( session -> authValueBind . b ) ) ; if ( ! result ) { return TSS2_SYS_RC_BAD_VALUE ; } result = string_bytes_concat_buffer ( ( TPM2B_MAX_BUFFER * ) & key , & ( session -> salt . b ) ) ; if ( ! result ) { return TSS2_SYS_RC_BAD_VALUE ; } bytes = GetDigestSize ( session -> authHash ) ; if ( key . t
",0,511
548,"long keyctl_read_key ( key_serial_t keyid , char __user * buffer , size_t buflen ) { struct key * key ; key_ref_t key_ref ; long ret ; key_ref = lookup_user_key ( keyid , 0 , 0 ) ; if ( IS_ERR ( key_ref ) ) { ret = - ENOKEY ; goto error ; } key = key_ref_to_ptr ( key_ref ) ; ret = key_permission ( key_ref , KEY_NEED_READ ) ; if ( ret == 0 ) ret = key -> type -> read ) { down_read ( & key -> sem ) ; ret = key_validate ( key ) ; if ( ret == 0 ) ret = key -> type -> read ( key , buffer , buflen ) ; up_read ( & key -> sem ) ; } error2 : key_put ( key ) ; error : return ret ; }
",0,209
549,"WORD32 ih264d_video_decode ( iv_obj_t * dec_hdl , void * pv_api_ip , void * pv_api_op ) { dec_struct_t * ps_dec = ( dec_struct_t * ) ( dec_hdl -> pv_codec_handle ) ; WORD32 i4_err_status = 0 ; UWORD8 * pu1_buf = NULL ; WORD32 buflen ; UWORD32 u4_max_ofst , u4_length_of_start_code = 0 ; UWORD32 bytes_consumed = 0 ; UWORD32 cur_slice_is_nonref = 0 ; UWORD32 u4_next_is_aud ; UWORD32 u4_first_start_code_found = 0 ; WORD32 ret = 0 , api_ret_value = IV_SUCCESS ; WORD32 header_data_left = 0 , frame_data_left = 0 ; UWORD8 * pu1_bitstrm_buf ; ivd_video_decode_ip_t * ps_dec_ip ; ivd_video_decode_op_t * ps_dec_op ; ithread_set_name ( ( void * ) ""Parse_thread"" ) ; ps_dec_ip = ( ivd_video_decode_ip_t * ) pv_api_ip ; ps_dec_op = ( ivd_video_decode_op_t * ) pv_api_op ; { UWORD32 u4_size ; u4_size = ps_dec_op -> u4_size ; memset ( ps_dec_op , 0 , sizeof ( ivd_video_decode_op_t ) ) ; ps_dec_op -> u4_size = u4_size ; } ps_dec -> pv_dec_out = ps_dec_op ; if ( ps_dec -> init_done != 1 ) { return IV_FAIL ; } DATA_SYNC ( ) ; if ( 0 == ps_dec -> u1_flushfrm ) { if ( ps_dec_ip -> pv_stream_buffer == NULL ) { ps_dec_op -> u4_error_code |= 1 << IVD_UN
",0,511
550,"static int adjust_scalar_min_max_vals ( struct bpf_verifier_env * env , struct bpf_insn * insn , struct bpf_reg_state * dst_reg , struct bpf_reg_state src_reg ) { struct bpf_reg_state * regs = cur_regs ( env ) ; u8 opcode = BPF_OP ( insn -> code ) ; bool src_known , dst_known ; s64 smin_val , smax_val ; u64 umin_val , umax_val ; u64 insn_bitness = ( BPF_CLASS ( insn -> code ) == BPF_ALU64 ) ? 64 : 32 ; smin_val = src_reg . smin_value ; smax_val = src_reg . smax_value ; umin_val = src_reg . umin_value ; umax_val = src_reg . umax_value ; src_known = tnum_is_const ( src_reg . var_off ) ; dst_known = tnum_is_const ( dst_reg -> var_off ) ; switch ( opcode ) { case BPF_ADD : if ( signed_add_overflows ( dst_reg -> smin_value , smin_val ) || signed_add_overflows ( dst_reg -> smax_value , smax_val ) ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value += smin_val ; dst_reg -> smax_value += smax_val ; } if ( dst_reg -> umin_value + umin_val < umin_val || dst_reg -> umax_value + umax_val < umax_val ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value += umin_val ; dst_reg -> umax_value += umax_val ; } dst_reg -> var_off = tnum_add ( dst_reg -> var_off , src_reg . var_off ) ; break ; }
",0,511
551,"struct dentry * cifs_lookup ( struct inode * parent_dir_inode , struct dentry * direntry , struct nameidata * nd ) { int xid ; int rc = 0 ; __u32 oplock = enable_oplocks ? REQ_OPLOCK : 0 ; __u16 fileHandle = 0 ; bool posix_open = false ; struct cifs_sb_info * cifs_sb ; struct tcon_link * tlink ; struct cifs_tcon * pTcon ; struct cifsFileInfo * cfile ; struct inode * newInode = NULL ; char * full_path = NULL ; struct file * filp ; xid = GetXid ( ) ; cFYI ( 1 , ""parentinode=0x%pnameis:%sanddentry=0x%p"" , parent_dir_inode , direntry -> d_name . name , direntry ) ; cifs_sb = CIFS_SB ( parent_dir_inode -> i_sb ) ; tlink = cifs_sb_tlink ( cifs_sb ) ; if ( IS_ERR ( tlink ) ) { FreeXid ( xid ) ; return ( struct dentry * ) tlink ; } pTcon = tlink_tcon ( tlink ) ; if ( ! ( cifs_sb -> mnt_cifs_flags & CIFS_MOUNT_POSIX_PATHS ) ) { int i ; for ( i = 0 ; i < direntry -> d_name . len ; i ++ ) if ( direntry -> d_name . name [ i ] == '\\\\' ) { cFYI ( 1 , ""Invalidfilename"" ) ; rc = - EINVAL ; goto lookup_out ; } } if ( nd && ( nd -> flags & LOOKUP_EXCL ) ) { d_instantiate ( direntry , NULL ) ; rc = 0 ; goto lookup_out ; } full_path = build_path_from_dentry ( direntry ) ; if ( full_path == NULL ) { rc = - ENOMEM ; goto lookup_out ; } if ( direntry -> d_inode != NULL ) { cFYI ( 1 , ""
",0,511
552,"static long vfio_pci_ioctl ( void * device_data , unsigned int cmd , unsigned long arg ) { struct vfio_pci_device * vdev = device_data ; unsigned long minsz ; if ( cmd == VFIO_DEVICE_GET_INFO ) { struct vfio_device_info info ; minsz = offsetofend ( struct vfio_device_info , num_irqs ) ; if ( copy_from_user ( & info , ( void __user * ) arg , minsz ) ) return - EFAULT ; if ( info . argsz < minsz ) return - EINVAL ; info . flags = VFIO_DEVICE_FLAGS_PCI ; if ( vdev -> reset_works ) info . flags |= VFIO_DEVICE_FLAGS_RESET ; info . num_regions = VFIO_PCI_NUM_REGIONS + vdev -> num_regions ; info . num_irqs = VFIO_PCI_NUM_IRQS ; return copy_to_user ( ( void __user * ) arg , & info , minsz ) ? - EFAULT : 0 ; } else if ( cmd == VFIO_DEVICE_GET_REGION_INFO ) { struct pci_dev * pdev = vdev -> pdev ; struct vfio_region_info info ; struct vfio_info_cap caps = { . buf = NULL , . size = 0 } ; int i , ret ; minsz = offsetofend ( struct vfio_region_info , offset ) ; if ( copy_from_user ( & info , ( void __user * ) arg , minsz ) ) return - EFAULT ; if ( info . argsz < minsz ) return - EINVAL ; switch ( info . index ) { case VFIO_PCI_CONFIG_REGION_INDEX : info . offset = VFIO_PCI_INDEX_TO_OFFSET ( info . index ) ; info . size = pdev -> cfg_size ; info . flags = VFIO_REGION_INFO_FLAG_READ | VFIO_REGION_INFO_FLAG_WRITE ; break ; case VFIO_PCI_BAR0_REGION_INDEX ... VFIO_
",0,511
553,"static int ext4_write_end ( struct file * file , struct address_space * mapping , loff_t pos , unsigned len , unsigned copied , struct page * page , void * fsdata ) { handle_t * handle = ext4_journal_current_handle ( ) ; struct inode * inode = mapping -> host ; loff_t old_size = inode -> i_size ; int ret = 0 , ret2 ; int i_size_changed = 0 ; trace_ext4_write_end ( inode , pos , len , copied ) ; if ( ext4_has_inline_data ( inode ) ) { ret = ext4_write_inline_data_end ( inode , pos , len , copied , page ) ; if ( ret < 0 ) goto errout ; copied = ret ; } else copied = block_write_end ( file , mapping , pos , len , copied , page , fsdata ) ; i_size_changed = ext4_update_inode_size ( inode , pos + copied ) ; unlock_page ( page ) ; put_page ( page ) ; if ( old_size < pos ) pagecache_isize_extended ( inode , old_size , pos ) ; if ( i_size_changed ) ext4_mark_inode_dirty ( handle , inode ) ; if ( pos + len > inode -> i_size && ext4_can_truncate ( inode ) ) ext4_orphan_add ( handle , inode ) ; errout : ret2 = ext4_journal_stop ( handle ) ; if ( ! ret ) ret = ret2 ; if ( pos + len > inode -> i_size ) { ext4_truncate_failed_write ( inode ) ; if ( inode -> i_nlink ) ext4_orphan_del ( NULL , inode ) ; } return ret ? ret : copied ; }
",1,422
554,"static int http_open ( URLContext * h , const char * uri , int flags , AVDictionary * * options ) { HTTPContext * s = h -> priv_data ; int ret ; if ( s -> seekable == 1 ) h -> is_streamed = 0 ; else h -> is_streamed = 1 ; s -> filesize = UINT64_MAX ; s -> location = av_strdup ( uri ) ; if ( ! s -> location ) return AVERROR ( ENOMEM ) ; if ( options ) av_dict_copy ( & s -> chained_options , * options , 0 ) ; if ( s -> headers ) { int len = strlen ( s -> headers ) ; if ( len < 2 || strcmp ( ""\\r\\n"" , s -> headers + len - 2 ) ) { av_log ( h , AV_LOG_WARNING , ""NotrailingCRLFfoundinHTTPheader.\\n"" ) ; ret = av_reallocp ( & s -> headers , len + 3 ) ; if ( ret < 0 ) return ret ; s -> headers [ len ] = '\\r' ; s -> headers [ len + 1 ] = '\\n' ; s -> headers [ len + 2 ] = '\\0' ; } } if ( s -> listen ) { return http_listen ( h , uri , flags , options ) ; } ret = http_open_cnx ( h , options ) ; if ( ret < 0 ) av_dict_free ( & s -> chained_options ) ; return ret ; }
",1,340
555,"struct sock * cookie_v4_check ( struct sock * sk , struct sk_buff * skb , struct ip_options * opt ) { struct tcp_options_received tcp_opt ; u8 * hash_location ; struct inet_request_sock * ireq ; struct tcp_request_sock * treq ; struct tcp_sock * tp = tcp_sk ( sk ) ; const struct tcphdr * th = tcp_hdr ( skb ) ; __u32 cookie = ntohl ( th -> ack_seq ) - 1 ; struct sock * ret = sk ; struct request_sock * req ; int mss ; struct rtable * rt ; __u8 rcv_wscale ; bool ecn_ok ; if ( ! sysctl_tcp_syncookies || ! th -> ack || th -> rst ) goto out ; if ( tcp_synq_no_recent_overflow ( sk ) || ( mss = cookie_check ( skb , cookie ) ) == 0 ) { NET_INC_STATS_BH ( sock_net ( sk ) , LINUX_MIB_SYNCOOKIESFAILED ) ; goto out ; } NET_INC_STATS_BH ( sock_net ( sk ) , LINUX_MIB_SYNCOOKIESRECV ) ; memset ( & tcp_opt , 0 , sizeof ( tcp_opt ) ) ; tcp_parse_options ( skb , & tcp_opt , & hash_location , 0 ) ; if ( ! cookie_check_timestamp ( & tcp_opt , & ecn_ok ) ) goto out ; ret = NULL ; req = inet_reqsk_alloc ( & tcp_request_sock_ops ) ; if ( ! req ) goto out ; ireq = inet_rsk ( req ) ; treq = tcp_rsk ( req ) ; treq -> rcv_isn = ntohl ( th -> seq ) - 1 ; treq -> snt_isn = cookie ; req -> mss = mss ; ireq -> loc_port = th -> dest ; ireq -> rmt_port = th -> source ; ireq -> loc_addr = ip_hdr ( skb ) -> daddr ; ireq -> rmt_addr = ip_hdr ( skb
",0,511
556,"int mutt_b64_decode ( char * out , const char * in , size_t olen ) { int len = 0 ; unsigned char digit4 ; do { const unsigned char digit1 = in [ 0 ] ; if ( ( digit1 > 127 ) || ( base64val ( digit1 ) == BAD ) ) return - 1 ; const unsigned char digit2 = in [ 1 ] ; if ( ( digit2 > 127 ) || ( base64val ( digit2 ) == BAD ) ) return - 1 ; const unsigned char digit3 = in [ 2 ] ; if ( ( digit3 > 127 ) || ( ( digit3 != '=' ) && ( base64val ( digit3 ) == BAD ) ) ) return - 1 ; digit4 = in [ 3 ] ; if ( ( digit4 > 127 ) || ( ( digit4 != '=' ) && ( base64val ( digit4 ) == BAD ) ) ) return - 1 ; in += 4 ; if ( len == olen ) return len ; * out ++ = ( base64val ( digit1 ) << 2 ) | ( base64val ( digit2 ) >> 4 ) ; len ++ ; if ( digit3 != '=' ) { if ( len == olen ) return len ; * out ++ = ( ( base64val ( digit2 ) << 4 ) & 0xf0 ) | ( base64val ( digit3 ) >> 2 ) ; len ++ ; if ( digit4 != '=' ) { if ( len == olen ) return len ; * out ++ = ( ( base64val ( digit3 ) << 6 ) & 0xc0 ) | base64val ( digit4 ) ; len ++ ; } } } while ( * in && digit4 != '=' ) ; return len ; }
",1,372
557,"static int amd_gpio_remove ( struct platform_device * pdev ) { struct amd_gpio * gpio_dev ; gpio_dev = platform_get_drvdata ( pdev ) ; gpiochip_remove ( & gpio_dev -> gc ) ; return 0 ; }
",1,67
558,"static ssize_t cifs_iovec_write ( struct file * file , const struct iovec * iov , unsigned long nr_segs , loff_t * poffset ) { unsigned long nr_pages , i ; size_t bytes , copied , len , cur_len ; ssize_t total_written = 0 ; loff_t offset ; struct iov_iter it ; struct cifsFileInfo * open_file ; struct cifs_tcon * tcon ; struct cifs_sb_info * cifs_sb ; struct cifs_writedata * wdata , * tmp ; struct list_head wdata_list ; int rc ; pid_t pid ; len = iov_length ( iov , nr_segs ) ; if ( ! len ) return 0 ; rc = generic_write_checks ( file , poffset , & len , 0 ) ; if ( rc ) return rc ; INIT_LIST_HEAD ( & wdata_list ) ; cifs_sb = CIFS_SB ( file -> f_path . dentry -> d_sb ) ; open_file = file -> private_data ; tcon = tlink_tcon ( open_file -> tlink ) ; if ( ! tcon -> ses -> server -> ops -> async_writev ) return - ENOSYS ; offset = * poffset ; if ( cifs_sb -> mnt_cifs_flags & CIFS_MOUNT_RWPIDFORWARD ) pid = open_file -> pid ; else pid = current -> tgid ; iov_iter_init ( & it , iov , nr_segs , len , 0 ) ; do { size_t save_len ; nr_pages = get_numpages ( cifs_sb -> wsize , len , & cur_len ) ; wdata = cifs_writedata_alloc ( nr_pages , cifs_uncached_writev_complete ) ; if ( ! wdata ) { rc = - ENOMEM ; break ; } rc = cifs_write_allocate_pages ( wdata -> pages , nr_pages ) ; if ( rc ) { kfree ( wdata ) ; break ; } save_len =
",0,511
559,"static __u8 * cp_report_fixup ( struct hid_device * hdev , __u8 * rdesc , unsigned int * rsize ) { unsigned long quirks = ( unsigned long ) hid_get_drvdata ( hdev ) ; unsigned int i ; if ( ! ( quirks & CP_RDESC_SWAPPED_MIN_MAX ) ) return rdesc ; if ( * rsize < 4 ) return rdesc ; for ( i = 0 ; i < * rsize - 4 ; i ++ ) if ( rdesc [ i ] == 0x29 && rdesc [ i + 2 ] == 0x19 ) { rdesc [ i ] = 0x19 ; rdesc [ i + 2 ] = 0x29 ; swap ( rdesc [ i + 3 ] , rdesc [ i + 1 ] ) ; } return rdesc ; }
",1,185
560,"const char * vpx_svc_dump_statistics ( SvcContext * svc_ctx ) { int number_of_frames , number_of_keyframes , encode_frame_count ; int i , j ; uint32_t bytes_total = 0 ; double scale [ COMPONENTS ] ; double psnr [ COMPONENTS ] ; double mse [ COMPONENTS ] ; double y_scale ; SvcInternal_t * const si = get_svc_internal ( svc_ctx ) ; if ( svc_ctx == NULL || si == NULL ) return NULL ; svc_log_reset ( svc_ctx ) ; encode_frame_count = ( svc_ctx -> encode_frame_count - 1 ) / ( svc_ctx -> encode_frame_count - 1 ) ; if ( svc_ctx -> encode_frame_count <= 0 ) return vpx_svc_get_message ( svc_ctx ) ; svc_log ( svc_ctx , SVC_LOG_INFO , ""\\n"" ) ; number_of_keyframes = encode_frame_count / si -> kf_dist + 1 ; for ( i = 0 ; i < si -> layers ; ++ i ) { number_of_frames = encode_frame_count ; if ( svc_ctx -> encoding_mode == ALT_INTER_LAYER_PREDICTION_IP && ( i == 1 || i == 3 ) ) { number_of_frames -= number_of_keyframes ; } svc_log ( svc_ctx , SVC_LOG_INFO , ""Layer%dAveragePSNR=[%2.3f,%2.3f,%2.3f,%2.3f],Bytes=[%u]\\n"" , i , ( double ) si -> psnr_sum [ i ] [ 0 ] / number_of_frames , ( double ) si -> psnr_sum [ i ] [ 1 ] / number_of_frames , ( double ) si -> psnr_sum [ i ] [ 2 ] / number_of_frames , ( double ) si -> psnr_sum [ i ] [ 3 ] / number_of_frames , si -> bytes_sum [ i ] ) ; y_scale = si -> width * si -> height * 255
",0,511
561,"static BOOL nsc_rle_decode ( BYTE * in , BYTE * out , UINT32 outSize , UINT32 originalSize ) { UINT32 len ; UINT32 left ; BYTE value ; left = originalSize ; while ( left > 4 ) { value = * in ++ ; if ( left == 5 ) { if ( outSize < 1 ) return FALSE ; outSize -- ; * out ++ = value ; left -- ; } else if ( value == * in ) { in ++ ; if ( * in < 0xFF ) { len = ( UINT32 ) * in ++ ; len += 2 ; } else { in ++ ; len = * ( ( UINT32 * ) in ) ; in += 4 ; } if ( outSize < len ) return FALSE ; outSize -= len ; FillMemory ( out , len , value ) ; out += len ; left -= len ; } else { if ( outSize < 1 ) return FALSE ; outSize -- ; * out ++ = value ; left -- ; } } * ( ( UINT32 * ) out ) = * ( ( UINT32 * ) in ) ; }
",0,244
562,"static int resize ( int new_rows , int new_cols , VTermPos * delta , void * user ) { VTermScreen * screen = user ; int is_altscreen = ( screen -> buffers [ 1 ] && screen -> buffer == screen -> buffers [ 1 ] ) ; int old_rows = screen -> rows ; int old_cols = screen -> cols ; int first_blank_row ; if ( ! is_altscreen && new_rows < old_rows ) { VTermPos pos = { 0 , 0 } ; VTermPos cursor = screen -> state -> pos ; for ( pos . row = old_rows - 1 ; pos . row >= new_rows ; pos . row -- ) if ( ! vterm_screen_is_eol ( screen , pos ) || cursor . row == pos . row ) break ; first_blank_row = pos . row + 1 ; if ( first_blank_row > new_rows ) { VTermRect rect = { 0 , 0 , 0 , 0 } ; rect . end_row = old_rows ; rect . end_col = old_cols ; scrollrect ( rect , first_blank_row - new_rows , 0 , user ) ; vterm_screen_flush_damage ( screen ) ; delta -> row -= first_blank_row - new_rows ; } } screen -> buffers [ 0 ] = realloc_buffer ( screen , screen -> buffers [ 0 ] , new_rows , new_cols ) ; if ( screen -> buffers [ 1 ] ) screen -> buffers [ 1 ] = realloc_buffer ( screen , screen -> buffers [ 1 ] , new_rows , new_cols ) ; screen -> buffer = is_altscreen ? screen -> buffers [ 1 ] : screen -> buffers [ 0 ] ; screen -> rows = new_rows ; screen -> cols = new_cols ; if ( screen -> sb_buffer ) vterm_allocator_free ( screen -> vt , screen -> sb_buffer ) ; screen -> sb_buffer = vterm_allocator_malloc ( screen -> vt , sizeof ( VTermScreenCell ) * new_cols ) ; if ( new_cols > old_cols ) { VTermRect rect ; rect . start_row = 0 ; rect . end_row = old_rows ; rect . start_col =
",0,511
563,"static int fstring_find_literal ( const char * * str , const char * end , int raw , PyObject * * literal , int recurse_lvl , struct compiling * c , const node * n ) { const char * literal_start = * str ; const char * literal_end ; int in_named_escape = 0 ; int result = 0 ; assert ( * literal == NULL ) ; for ( ; * str < end && * literal != NULL ; ( * str ) ++ ) { char ch = * * str ; if ( ! in_named_escape && ch == '{' && ( * str ) - literal_start >= 2 && * ( * str - 2 ) == '\\\\' && * ( * str - 1 ) == 'N' ) { in_named_escape = 1 ; } else if ( in_named_escape && ch == '}' ) { if ( recurse_lvl == 0 ) { if ( * str + 1 < end && * ( * str + 1 ) == ch ) { literal_end = * str + 1 ; * str += 2 ; result = 1 ; goto done ; } if ( ch == '}' ) { ast_error ( c , n , ""f-string:single\'}\'isnotallowed"" ) ; return - 1 ; } } else { ast_error ( c , n , ""f-string:both\'}\'isnotallowed"" ) ; return - 1 ; } } break ; } } literal_end = * str ; if ( literal_start != literal_end ) { if ( raw ) * literal = PyUnicode_DecodeUTF8Stateful ( literal_start , literal_end - literal_start , NULL , NULL ) ; else * literal = decode_unicode_with_escapes ( c , n , literal_start , literal_end - literal_start ) ; if ( ! * literal ) return - 1 ; } return result ; }
",0,415
564,"static int mem_resize ( jas_stream_memobj_t * m , size_t bufsize ) { unsigned char * buf ; assert ( bufsize >= 0 ) ; JAS_DBGLOG ( 100 , ( ""mem_resize(%p,%d)\\n"" , m , bufsize ) ) ; if ( ! ( buf = jas_realloc2 ( m -> buf_ , bufsize , sizeof ( unsigned char ) ) ) && bufsize ) { JAS_DBGLOG ( 100 , ( ""mem_resizereallocfailed\\n"" ) ) ; return - 1 ; } JAS_DBGLOG ( 100 , ( ""mem_resizereallocsucceeded\\n"" ) ) ; m -> buf_ = buf ; m -> bufsize_ = bufsize ; return 0 ; }
",0,182
565,"char * problem_data_save ( problem_data_t * pd ) { load_abrt_conf ( ) ; struct dump_dir * dd = create_dump_dir_from_problem_data ( pd , g_settings_dump_location ) ; char * problem_id = NULL ; if ( dd ) { problem_id = xstrdup ( dd -> dd_dirname ) ; dd_close ( dd ) ; } log_info ( ""problemid:\'%s\'"" , problem_id ) ; return problem_id ; }
",0,122
566,"static bool ResolveStateAndPredicate ( ExprDef * expr , enum xkb_match_operation * pred_rtrn , xkb_mod_mask_t * mods_rtrn , CompatInfo * info ) { if ( expr == NULL ) { * pred_rtrn = MATCH_ANY_OR_NONE ; * mods_rtrn = MOD_REAL_MASK_ALL ; return true ; } * pred_rtrn = MATCH_EXACTLY ; if ( expr -> expr . op == EXPR_ACTION_DECL ) { const char * pred_txt = xkb_atom_text ( info -> ctx , expr -> action . name ) ; if ( lookupString ( symInterpretMatchMaskNames , pred_txt , pred_rtrn ) ) { log_err ( info -> ctx , ""Illegalmodifierpredicate\\""%s\\"";Ignored\\n"" , pred_txt ) ; return false ; } expr = expr -> action . args ; } else if ( expr -> expr . op == EXPR_IDENT ) { const char * pred_txt = xkb_atom_text ( info -> ctx , expr -> ident . ident ) ; if ( pred_txt && istreq ( pred_txt , ""any"" ) ) { * pred_rtrn = MATCH_ANY ; * mods_rtrn = MOD_REAL_MASK_ALL ; return true ; } } return ExprResolveModMask ( info -> ctx , expr , MOD_REAL , & info -> mods , mods_rtrn ) ; }
",0,352
567,"static void pcrypt_free ( struct aead_instance * inst ) { struct pcrypt_instance_ctx * ctx = aead_instance_ctx ( inst ) ; crypto_drop_aead ( & ctx -> spawn ) ; kfree ( inst ) ; }
",1,59
568,"void rfbScaledScreenUpdateRect ( rfbScreenInfoPtr screen , rfbScreenInfoPtr ptr , int x0 , int y0 , int w0 , int h0 ) { int x , y , w , v , z ; int x1 , y1 , w1 , h1 ; int bitsPerPixel , bytesPerPixel , bytesPerLine , areaX , areaY , area2 ; unsigned char * srcptr , * dstptr ; if ( screen == ptr ) return ; x1 = x0 ; y1 = y0 ; w1 = w0 ; h1 = h0 ; rfbScaledCorrection ( screen , ptr , & x1 , & y1 , & w1 , & h1 , ""rfbScaledScreenUpdateRect"" ) ; x0 = ScaleX ( ptr , screen , x1 ) ; y0 = ScaleY ( ptr , screen , y1 ) ; w0 = ScaleX ( ptr , screen , w1 ) ; h0 = ScaleY ( ptr , screen , h1 ) ; bitsPerPixel = screen -> bitsPerPixel ; bytesPerPixel = bitsPerPixel / 8 ; bytesPerLine = w1 * bytesPerPixel ; srcptr = ( unsigned char * ) ( screen -> frameBuffer + ( y0 * screen -> paddedWidthInBytes + x0 * bytesPerPixel ) ) ; dstptr = ( unsigned char * ) ( ptr -> frameBuffer + ( y1 * ptr -> paddedWidthInBytes + x1 * bytesPerPixel ) ) ; areaX = ScaleX ( ptr , screen , 1 ) ; areaY = ScaleY ( ptr , screen , 1 ) ; area2 = areaX * areaY ; if ( ( x1 + w1 ) > ( ptr -> width ) ) { if ( x1 == 0 ) w1 = ptr -> width ; else x1 = ptr -> width - w1 ; } if ( ( y1 + h1 ) > ( ptr -> height ) ) { if ( y1 == 0 ) h1 = ptr -> height ; else y1 = ptr -> height - h1 ; } if ( screen -> serverFormat . trueColour ) { unsigned char * srcptr2 ; unsigned long pixel_value , red , green , blue ; unsigned int redShift = screen -> serverFormat . redShift ; unsigned int greenShift = screen -> serverFormat . greenShift ; unsigned int blueShift = screen -> serverFormat . blueShift
",0,511
569,"static Image * ReadSGIImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image ; MagickBooleanType status ; MagickSizeType number_pixels ; MemoryInfo * pixel_info ; register Quantum * q ; register ssize_t i , x ; register unsigned char * p ; SGIInfo iris_info ; size_t bytes_per_pixel , quantum ; ssize_t count , y , z ; unsigned char * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } iris_info . magic = ReadBlobMSBShort ( image ) ; do { if ( iris_info . magic != 0x01DA ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; iris_info . storage = ( unsigned char ) ReadBlobByte ( image ) ; switch ( iris_info . storage ) { case 0x00 : image -> compression = NoCompression ; break ; case 0x01 : image -> compression = RLECompression ; break ; default : ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } iris_info . bytes_per_pixel = ( unsigned char ) ReadBlobByte ( image ) ; if ( ( iris_info . bytes_per_pixel == 0 ) || ( iris_info . bytes_per_pixel > 2 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; iris_info . dimension = ReadBlobMSBShort ( image ) ; iris_info . columns = ReadBlobMSBShort ( image ) ; iris_info . rows = ReadBlobMSB
",0,511
570,"static void ndisc_router_discovery ( struct sk_buff * skb ) { struct ra_msg * ra_msg = ( struct ra_msg * ) skb_transport_header ( skb ) ; struct neighbour * neigh = NULL ; struct inet6_dev * in6_dev ; struct rt6_info * rt = NULL ; int lifetime ; struct ndisc_options ndopts ; int optlen ; unsigned int pref = 0 ; __u8 * opt = ( __u8 * ) ( ra_msg + 1 ) ; optlen = ( skb_tail_pointer ( skb ) - skb_transport_header ( skb ) ) - sizeof ( struct ra_msg ) ; ND_PRINTK ( 2 , info , ""RA:%s,dev:%s\\n"" , __func__ , skb -> dev -> name ) ; if ( ! ( ipv6_addr_type ( & ipv6_hdr ( skb ) -> saddr ) & IPV6_ADDR_LINKLOCAL ) ) { ND_PRINTK ( 2 , warn , ""RA:sourceaddressisnotlink-local\\n"" ) ; return ; } if ( optlen < 0 ) { ND_PRINTK ( 2 , warn , ""RA:packettooshort\\n"" ) ; return ; } # ifdef CONFIG_IPV6_NDISC_NODETYPE if ( skb -> ndisc_nodetype == NDISC_NODETYPE_HOST ) { ND_PRINTK ( 2 , warn , ""RA:fromhostorunauthorizedrouter\\n"" ) ; return ; } # endif in6_dev = __in6_dev_get ( skb -> dev ) ; if ( in6_dev == NULL ) { ND_PRINTK ( 0 , err , ""RA:can\'tfindinet6devicefor%s\\n"" , skb -> dev -> name ) ; return ; } if ( ! ndisc_parse_options ( opt , optlen , & ndopts ) ) { ND_PRINTK ( 2 , warn , ""RA:invalidNDoptions\\n"" ) ; return ; } if ( ! ipv6_accept_ra ( in6_dev ) ) { ND_PRINTK
",0,511
571,"static void l2tp_proxy_auth_id_print ( netdissect_options * ndo , const u_char * dat , u_int length ) { const uint16_t * ptr = ( const uint16_t * ) dat ; if ( length < 2 ) { ND_PRINT ( ( ndo , ""AVPtooshort"" ) ) ; return ; } ND_PRINT ( ( ndo , ""%u"" , EXTRACT_16BITS ( ptr ) & L2TP_PROXY_AUTH_ID_MASK ) ) ; }
",1,126
572,"static inline int xfrm_replay_verify_len ( struct xfrm_replay_state_esn * replay_esn , struct nlattr * rp ) { struct xfrm_replay_state_esn * up ; int ulen ; if ( ! replay_esn || ! rp ) return 0 ; up = nla_data ( rp ) ; ulen = xfrm_replay_state_esn_len ( up ) ; if ( nla_len ( rp ) < ulen || xfrm_replay_state_esn_len ( up ) ) return - EINVAL ; return 0 ; }
",0,149
573,"int perf_cpu_time_max_percent_handler ( struct ctl_table * table , int write , void __user * buffer , size_t * lenp , loff_t * ppos ) { int ret = proc_dointvec_minmax ( table , write , buffer , lenp , ppos ) ; if ( ret || ! write ) return ret ; if ( sysctl_perf_cpu_time_max_percent == 100 || sysctl_perf_cpu_time_max_percent == 0 ) { printk ( KERN_WARNING ""perf:Dynamicinterruptthrottlingdisabled,canhangyoursystem
",0,140
574,"int vp8_full_search_sadx3 ( MACROBLOCK * x , BLOCK * b , BLOCKD * d , int_mv * ref_mv , int sad_per_bit , int distance , vp8_variance_fn_ptr_t * fn_ptr , int * mvcost [ 2 ] , int_mv * center_mv ) { unsigned char * what = ( * ( b -> base_src ) + b -> src ) ; int what_stride = b -> src_stride ; unsigned char * in_what ; int pre_stride = x -> e_mbd . pre . y_stride ; unsigned char * base_pre = x -> e_mbd . pre . y_buffer ; int in_what_stride = pre_stride ; int mv_stride = pre_stride ; unsigned char * bestaddress ; int_mv * best_mv = & d -> bmi . mv ; int_mv this_mv ; unsigned int bestsad ; unsigned int thissad ; int r , c ; unsigned char * check_here ; int ref_row = ref_mv -> as_mv . row ; int ref_col = ref_mv -> as_mv . col ; int row_min = ref_row - distance ; int row_max = ref_row + distance ; int col_min = ref_col - distance ; int col_max = ref_col + distance ; unsigned int sad_array [ 3 ] ; int * mvsadcost [ 2 ] ; int_mv fcenter_mv ; mvsadcost [ 0 ] = x -> mvsadcost [ 0 ] ; mvsadcost [ 1 ] = x -> mvsadcost [ 1 ] ; fcenter_mv . as_mv . row = center_mv -> as_mv . row >> 3 ; fcenter_mv . as_mv . col = center_mv -> as_mv . col >> 3 ; in_what = base_pre + d -> offset ; bestaddress = in_what + ( ref_row * pre_stride ) + ref_col ; best_mv -> as_mv . row = ref_row ; best_mv -> as_mv . col
",0,511
575,"opj_pi_iterator_t * opj_pi_create_decode ( opj_image_t * p_image , opj_cp_t * p_cp , OPJ_UINT32 p_tile_no ) { OPJ_UINT32 pino ; OPJ_UINT32 compno , resno ; OPJ_UINT32 * l_tmp_data ; OPJ_UINT32 * * l_tmp_ptr ; OPJ_UINT32 l_max_res ; OPJ_UINT32 l_max_prec ; OPJ_INT32 l_tx0 , l_tx1 , l_ty0 , l_ty1 ; OPJ_UINT32 l_dx_min , l_dy_min ; OPJ_UINT32 l_bound ; OPJ_UINT32 l_step_p , l_step_c , l_step_r , l_step_l ; OPJ_UINT32 l_data_stride ; opj_pi_iterator_t * l_pi = 00 ; opj_tcp_t * l_tcp = 00 ; const opj_tccp_t * l_tccp = 00 ; opj_pi_comp_t * l_current_comp = 00 ; opj_image_comp_t * l_img_comp = 00 ; opj_pi_iterator_t * l_current_pi = 00 ; OPJ_UINT32 * l_encoding_value_ptr = 00 ; assert ( p_cp != 00 ) ; assert ( p_image != 00 ) ; assert ( p_tile_no < p_cp -> tw * p_cp -> th ) ; l_tcp = & p_cp -> tcps [ p_tile_no ] ; l_bound = l_tcp -> numpocs + 1 ; l_data_stride = 4 * OPJ_J2K_MAXRLVLS ; l_tmp_data = ( OPJ_UINT32 * ) opj_malloc ( l_data_stride * p_image -> numcomps * sizeof ( OPJ_UINT32 ) ) ; if ( ! l_tmp_data ) { return 00 ; } l_tmp_ptr = ( OPJ_UINT32
",0,511
576,"struct crypto_template * crypto_lookup_template ( const char * name ) { return try_then_request_module ( __crypto_lookup_template ( name ) , ""crypto-%s"" , name ) ; }
",1,52
577,"static int kvm_vm_ioctl_set_pit2 ( struct kvm * kvm , struct kvm_pit_state2 * ps ) { int start = 0 ; u32 prev_legacy , cur_legacy ; mutex_lock ( & kvm -> arch . vpit -> pit_state . lock ) ; prev_legacy = kvm -> arch . vpit -> pit_state . flags & KVM_PIT_FLAGS_HPET_LEGACY ; cur_legacy = ps -> flags & KVM_PIT_FLAGS_HPET_LEGACY ; if ( ! prev_legacy && cur_legacy ) start = 1 ; memcpy ( & kvm -> arch . vpit -> pit_state . channels , & ps -> channels , sizeof ( kvm -> arch . vpit -> pit_state . channels ) ) ; kvm -> arch . vpit -> pit_state . flags = ps -> flags ; if ( kvm_pit_load_count ( kvm , 0 , & kvm -> arch . vpit -> pit_state . channels [ 0 ] . count , start ) ) ; mutex_unlock ( & kvm -> arch . vpit -> pit_state . lock ) ; return 0 ; }
",0,276
578,"static void encode_nonrd_sb_row ( VP9_COMP * cpi , ThreadData * td , TileDataEnc * tile_data , MACROBLOCKD * xd , int mi_row , TOKENEXTRA * * tp ) { VP9_COMMON * cm = & cpi -> common ; MACROBLOCKD * xd = & cpi -> mb . e_mbd ; int mi_col ; vpx_memset ( & xd -> left_context , 0 , sizeof ( xd -> left_context ) ) ; vpx_memset ( xd -> left_seg_context , 0 , sizeof ( xd -> left_seg_context ) ) ; vpx_memset ( xd -> left_seg_dist , 0 , sizeof ( xd -> left_seg_dist ) ) ; for ( mi_col = tile_data -> mi_col_start ; mi_col < tile_data -> mi_col_end ; mi_col += MI_BLOCK_SIZE ) { int dummy_rate = 0 ; int64_t dummy_dist = 0 ; const int idx_str = cm -> mi_stride * mi_row + mi_col ; MODE_INFO * * mi_8x8 = cm -> mi_grid_visible + idx_str ; MODE_INFO * * prev_mi_8x8 = cm -> prev_mi_grid_visible + idx_str ; BLOCK_SIZE bsize ; if ( prev_mi_8x8 == NULL ) break ; cpi -> mb . source_variance = UINT_MAX ; vp9_zero ( cpi -> mb . pred_mv ) ; switch ( cpi -> sf . partition_search_type ) { case VAR_BASED_PARTITION : cpi -> mb . source_variance = UINT_MAX ; vp9_zero ( cpi -> mb . pred_mv ) ; break ; case SOURCE_VAR_BASED_PARTITION : set_offsets ( cpi , tile_data , mi_row , mi_col , BLOCK_64X64 , mi_row , mi_col , BLOCK_64X
",0,493
579,"static int link_pipe ( struct pipe_inode_info * ipipe , struct pipe_inode_info * opipe , size_t len , unsigned int flags ) { struct pipe_buffer * ibuf , * obuf ; int ret = 0 , i = 0 , nbuf ; pipe_double_lock ( ipipe , opipe ) ; do { if ( ! opipe -> readers ) { send_sig ( SIGPIPE , current , 0 ) ; if ( ! ret ) ret = - EPIPE ; break ; } if ( i >= ipipe -> nrbufs || opipe -> nrbufs >= opipe -> buffers ) break ; ibuf = ipipe -> bufs + ( ( ipipe -> curbuf + i ) & ( ipipe -> buffers - 1 ) ) ; nbuf = ( opipe -> curbuf + opipe -> nrbufs ) & ( opipe -> buffers - 1 ) ; if ( ! pipe_buf_get ( ipipe , ibuf ) ) { if ( ret == 0 ) ret = - EFAULT ; break ; } obuf = opipe -> bufs + nbuf ; * obuf = * ibuf ; obuf -> flags &= ~ PIPE_BUF_FLAG_GIFT ; if ( obuf -> len > len ) obuf -> len = len ; opipe -> nrbufs ++ ; ret += obuf -> len ; len -= obuf -> len ; i ++ ; } while ( len ) ; if ( ! ret && ipipe -> waiting_writers && ( flags & SPLICE_F_NONBLOCK ) ) ret = - EAGAIN ; pipe_unlock ( ipipe ) ; pipe_unlock ( opipe ) ; if ( ret > 0 ) wakeup_pipe_readers ( opipe ) ; return ret ; }
",1,394
580,"static bool dccp_new ( struct nf_conn * ct , const struct sk_buff * skb , unsigned int dataoff , unsigned int * timeouts ) { struct net * net = nf_ct_net ( ct ) ; struct dccp_net * dn ; struct dccp_hdr _dh , * dh ; const char * msg ; u_int8_t state ; dh = skb_header_pointer ( skb , dataoff , sizeof ( _dh ) , & _dh ) ; BUG_ON ( dh == NULL ) ; state = dccp_state_table [ CT_DCCP_ROLE_CLIENT ] [ dh -> dccph_type ] [ CT_DCCP_NONE ] ; switch ( state ) { default : dn = dccp_pernet ( net ) ; if ( dn -> dccp_loose == 0 ) { msg = ""nf_ct_dccp:notpickingupexistingconnection"" ; goto out_invalid ; } case CT_DCCP_REQUEST : break ; case CT_DCCP_INVALID : msg = ""nf_ct_dccp:invalidstatetransition"" ; goto out_invalid ; } ct -> proto . dccp . role [ IP_CT_DIR_ORIGINAL ] = CT_DCCP_ROLE_CLIENT ; ct -> proto . dccp . role [ IP_CT_DIR_REPLY ] = CT_DCCP_ROLE_SERVER ; ct -> proto . dccp . state = CT_DCCP_NONE ; ct -> proto . dccp . last_pkt = DCCP_PKT_REQUEST ; ct -> proto . dccp . last_dir = IP_CT_DIR_ORIGINAL ; ct -> proto . dccp . handshake_seq = 0 ; return true ; out_invalid : if ( LOG_INVALID ( net , IPPROTO_DCCP ) ) nf_log_packet ( net , nf_ct_l3num ( ct ) , 0 , skb , NULL , NULL , NULL , ""%s"" , msg ) ; return false ; }
",1,503
581,"static int http_RecvPostMessage ( http_parser_t * parser , SOCKINFO * info , char * filename , struct SendInstruction * Instr ) { size_t Data_Buf_Size = 1024 ; char Buf [ 1024 ] ; int Timeout = - 1 ; FILE * Fp ; parse_status_t status = PARSE_OK ; int ok_on_close = FALSE ; size_t entity_offset = 0 ; int num_read = 0 ; int ret_code = HTTP_OK ; if ( Instr && Instr -> IsVirtualFile ) { Fp = ( virtualDirCallback . open ) ( filename , UPNP_WRITE ) ; if ( Fp == NULL ) return HTTP_INTERNAL_SERVER_ERROR ; } else { # ifdef UPNP_ENABLE_POST_WRITE Fp = fopen ( filename , ""wb"" ) ; if ( Fp == NULL ) return HTTP_UNAUTHORIZED ; # else return HTTP_NOT_FOUND ; # endif } parser -> position = POS_ENTITY ; do { if ( parser -> position != POS_COMPLETE ) status = parser_parse_entity ( parser ) ; if ( status == PARSE_INCOMPLETE_ENTITY ) { ok_on_close = TRUE ; } else if ( ( status != PARSE_SUCCESS ) && ( status != PARSE_CONTINUE_1 ) && ( status != PARSE_INCOMPLETE ) ) { ret_code = HTTP_BAD_REQUEST ; goto ExitFunction ; } while ( entity_offset + Data_Buf_Size > parser -> msg . entity . length && parser -> position != POS_COMPLETE ) { num_read = sock_read ( info , Buf , sizeof ( Buf ) , & Timeout ) ; if ( num_read > 0 ) { if ( membuffer_append ( & parser -> msg . msg , Buf , ( size_t ) num_read ) != 0 ) { parser -> http_error_code = HTTP_INTERNAL_SERVER_ERROR ; ret_code = HTTP_INTERNAL_SERVER_ERROR ; goto ExitFunction ; } status = parser_parse_entity ( parser ) ; if ( status == PARSE_INCOMPLETE_ENTITY ) { ok_on_close = TRUE ; } else if ( ( status !=
",0,511
582,"static FILE * pw_tmpfile ( int lockfd ) { FILE * fd ; char * tmpname = NULL ; char * dir = ""/tmp"" ; if ( ( fd = xfmkstemp ( & tmpname , dir ) ) == NULL ) { ulckpwdf ( ) ; err ( EXIT_FAILURE , _ ( ""can\'topentemporaryfile"" ) ) ; } copyfile ( lockfd , fileno ( fd ) ) ; tmp_file = tmpname ; return fd ; }
",0,115
583,"int blkcg_init_queue ( struct request_queue * q ) { struct blkcg_gq * new_blkg , * blkg ; bool preloaded ; int ret ; new_blkg = blkg_alloc ( & blkcg_root , q , GFP_KERNEL ) ; if ( ! new_blkg ) return - ENOMEM ; preloaded = ! radix_tree_preload ( GFP_KERNEL ) ; rcu_read_lock ( ) ; spin_lock_irq ( q -> queue_lock ) ; blkg = blkg_create ( & blkcg_root , q , new_blkg ) ; spin_unlock_irq ( q -> queue_lock ) ; rcu_read_unlock ( ) ; if ( preloaded ) radix_tree_preload_end ( ) ; if ( IS_ERR ( blkg ) ) { blkg_free ( new_blkg ) ; return PTR_ERR ( blkg ) ; } q -> root_blkg = blkg ; q -> root_rl . blkg = blkg ; ret = blk_throtl_init ( q ) ; if ( ret ) { spin_lock_irq ( q -> queue_lock ) ; blkg_destroy_all ( q ) ; spin_unlock_irq ( q -> queue_lock ) ; } return ret ; }
",0,315
584,"static int xwd_decode_frame ( AVCodecContext * avctx , void * data , int * got_frame , AVPacket * avpkt ) { AVFrame * p = data ; const uint8_t * buf = avpkt -> data ; int i , ret , buf_size = avpkt -> size ; uint32_t version , header_size , vclass , ncolors ; uint32_t xoffset , be , bpp , lsize , rsize ; uint32_t pixformat , pixdepth , bunit , bitorder , bpad ; uint32_t rgb [ 3 ] ; uint8_t * ptr ; GetByteContext gb ; if ( buf_size < XWD_HEADER_SIZE ) return AVERROR_INVALIDDATA ; bytestream2_init ( & gb , buf , buf_size ) ; header_size = bytestream2_get_be32u ( & gb ) ; version = bytestream2_get_be32u ( & gb ) ; if ( version != XWD_VERSION ) { av_log ( avctx , AV_LOG_ERROR , ""unsupportedversion\\n"" ) ; return AVERROR_INVALIDDATA ; } if ( buf_size < header_size || header_size < XWD_HEADER_SIZE ) { av_log ( avctx , AV_LOG_ERROR , ""invalidheadersize\\n"" ) ; return AVERROR_INVALIDDATA ; } pixformat = bytestream2_get_be32u ( & gb ) ; pixdepth = bytestream2_get_be32u ( & gb ) ; avctx -> width = bytestream2_get_be32u ( & gb ) ; avctx -> height = bytestream2_get_be32u ( & gb ) ; xoffset = bytestream2_get_be32u ( & gb ) ; be = bytestream2_get_be32u ( & gb ) ; bunit = bytestream2_get_be32u ( & gb ) ; bitorder = bytestream2_get_be32u ( & gb ) ; bpad = bytestream2_get_be32u ( & gb ) ; bpp =
",0,511
585,"static krb5_error_code tgs_build_reply ( krb5_context context , krb5_kdc_configuration * config , KDC_REQ * req , KDC_REQ_BODY * b , hdb_entry_ex * krbtgt , krb5_enctype krbtgt_etype , const krb5_keyblock * replykey , int rk_is_subkey , krb5_ticket * ticket , krb5_data * reply , const char * from , const char * * e_text , AuthorizationData * * auth_data , const struct sockaddr * from_addr ) { krb5_error_code ret ; krb5_principal cp = NULL , sp = NULL , rsp = NULL , tp = NULL , dp = NULL ; krb5_principal krbtgt_out_principal = NULL ; char * spn = NULL , * cpn = NULL , * tpn = NULL , * dpn = NULL , * krbtgt_out_n = NULL ; hdb_entry_ex * server = NULL , * client = NULL , * s4u2self_impersonated_client = NULL ; HDB * clientdb , * s4u2self_impersonated_clientdb ; krb5_realm ref_realm = NULL ; EncTicketPart * tgt = & ticket -> ticket ; krb5_principals spp = NULL ; const EncryptionKey * ekey ; krb5_keyblock sessionkey ; krb5_kvno kvno ; krb5_data rspac ; const char * tgt_realm = krb5_principal_get_realm ( context , krbtgt -> entry . principal ) ; const char * our_realm = krb5_principal_get_comp_string ( context , krbtgt -> entry . principal , 1 ) ; char * * capath = NULL ; size_t num_capath = 0 ; hdb_entry_ex * krbtgt_out = NULL ; METHOD_DATA enc_pa_data ; PrincipalName * s ; Realm r ; EncTicketPart adtkt ; char opt_str [ 128 ] ; int signed
",0,511
586,"static __always_inline int __do_follow_link ( struct path * path , struct nameidata * nd ) { int error ; void * cookie ; struct dentry * dentry = path -> dentry ; touch_atime ( path -> mnt , dentry ) ; nd_set_link ( nd , NULL ) ; if ( path -> mnt != nd -> path . mnt ) { path_to_nameidata ( path , nd ) ; dget ( dentry ) ; } mntget ( path -> mnt ) ; nd -> last_type = LAST_BIND ; cookie = dentry -> d_inode -> i_op -> follow_link ( dentry , nd ) ; error = PTR_ERR ( cookie ) ; if ( ! IS_ERR ( cookie ) ) { char * s = nd_get_link ( nd ) ; error = 0 ; if ( s ) error = __vfs_follow_link ( nd , s ) ; else if ( nd -> last_type == LAST_BIND ) { error = force_reval_path ( & nd -> path , nd ) ; if ( error ) path_put ( & nd -> path ) ; } if ( dentry -> d_inode -> i_op -> put_link ) dentry -> d_inode -> i_op -> put_link ( dentry , nd , cookie ) ; } return error ; }
",1,320
587,"static int proc_connectinfo ( struct usb_dev_state * ps , void __user * arg ) { struct usbdevfs_connectinfo ci ; memset ( & ci , 0 , sizeof ( ci ) ) ; ci . devnum = ps -> dev -> devnum ; ci . slow = ps -> dev -> speed == USB_SPEED_LOW ; if ( copy_to_user ( arg , & ci , sizeof ( ci ) ) ) return - EFAULT ; return 0 ; }
",1,112
588,"static int ip_options_get_finish ( struct net * net , struct ip_options_rcu * * optp , struct ip_options_rcu * opt , int optlen ) { while ( optlen & 3 ) opt -> opt . __data [ optlen ++ ] = IPOPT_END ; opt -> optlen = sizeof ( * optp ) - 1 ; if ( optlen && ip_options_compile ( net , opt , NULL ) ) { kfree ( opt ) ; return - EINVAL ; } kfree ( * optp ) ; * optp = opt ; return 0 ; }
",0,134
589,"STATIC int xfs_attr_leaf_addname ( xfs_da_args_t * args ) { xfs_inode_t * dp ; struct xfs_buf * bp ; int retval , error , committed , forkoff ; trace_xfs_attr_leaf_addname ( args ) ; dp = args -> dp ; args -> blkno = 0 ; error = xfs_attr3_leaf_read ( args -> trans , args -> dp , args -> blkno , - 1 , & bp ) ; if ( error ) return error ; retval = xfs_attr3_leaf_lookup_int ( bp , args ) ; if ( ( args -> flags & ATTR_REPLACE ) && ( retval == ENOATTR ) ) { xfs_trans_brelse ( args -> trans , bp ) ; return retval ; } else if ( retval == EEXIST ) { if ( args -> flags & ATTR_CREATE ) { xfs_trans_brelse ( args -> trans , bp ) ; return retval ; } trace_xfs_attr_leaf_replace ( args ) ; args -> op_flags |= XFS_DA_OP_RENAME ; args -> blkno2 = args -> blkno ; args -> index2 = args -> index ; args -> rmtblkno2 = args -> rmtblkno ; args -> rmtblkcnt2 = args -> rmtblkcnt ; args -> rmtvaluelen2 = args -> rmtvaluelen ; args -> rmtblkno = 0 ; args -> rmtblkcnt = 0 ; } retval = xfs_attr3_leaf_add ( bp , args ) ; if ( retval == ENOSPC ) { xfs_bmap_init ( args -> flist , args -> firstblock ) ; error = xfs_attr3_leaf_to_node ( args ) ; if ( ! error ) { error = xfs_bmap_finish ( & args -> trans , args -> flist , & committed ) ; } if ( error ) { ASSERT ( committed ) ; args -> trans = NULL ; xfs_bmap_cancel ( args -> flist ) ; return ( error ) ; } if
",0,511
590,"NTSTATUS ProcessMainDeviceControlIrp ( PDEVICE_OBJECT DeviceObject , PEXTENSION Extension , PIRP Irp ) { PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation ( Irp ) ; NTSTATUS ntStatus ; switch ( irpSp -> Parameters . DeviceIoControl . IoControlCode ) { case TC_IOCTL_GET_DRIVER_VERSION : case TC_IOCTL_LEGACY_GET_DRIVER_VERSION : if ( ValidateIOBufferSize ( Irp , sizeof ( LONG ) , ValidateOutput ) ) { LONG tmp = VERSION_NUM ; memcpy ( Irp -> AssociatedIrp . SystemBuffer , & tmp , 4 ) ; Irp -> IoStatus . Information = sizeof ( LONG ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } break ; case TC_IOCTL_GET_DEVICE_REFCOUNT : if ( ValidateIOBufferSize ( Irp , sizeof ( int ) , ValidateOutput ) ) { * ( int * ) Irp -> AssociatedIrp . SystemBuffer = DeviceObject -> ReferenceCount ; Irp -> IoStatus . Information = sizeof ( int ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } break ; case TC_IOCTL_IS_DRIVER_UNLOAD_DISABLED : if ( ValidateIOBufferSize ( Irp , sizeof ( int ) , ValidateOutput ) ) { LONG deviceObjectCount = 0 ; * ( int * ) Irp -> AssociatedIrp . SystemBuffer = DriverUnloadDisabled ; if ( IoEnumerateDeviceObjectList ( TCDriverObject , NULL , 0 , & deviceObjectCount ) == STATUS_BUFFER_TOO_SMALL && deviceObjectCount > 1 ) * ( int * ) Irp -> AssociatedIrp . SystemBuffer = TRUE ; Irp -> IoStatus . Information = sizeof ( int ) ; Irp -> IoStatus . Status = STATUS_SUCCESS ; } break ; case TC_IOCTL_IS_ANY_VOLUME_MOUNTED : if ( ValidateIOBufferSize ( Irp , sizeof ( int ) , ValidateOutput ) ) { int drive ; * ( int * ) Irp -> AssociatedIrp . SystemBuffer = 0 ; for ( drive = MIN_
",0,511
591,"static int on_http_message_complete ( http_parser * parser ) { struct clt_info * info = parser -> data ; ws_svr * svr = ws_svr_from_ses ( info -> ses ) ; info -> request -> version_major = parser -> http_major ; info -> request -> version_minor = parser -> http_minor ; info -> request -> method = parser -> method ; dict_entry * entry ; dict_iterator * iter = dict_get_iterator ( info -> request -> headers ) ; while ( ( entry = dict_next ( iter ) ) != NULL ) { log_trace ( ""Header:%s:%s"" , ( char * ) entry -> key , ( char * ) entry -> val ) ; } dict_release_iterator ( iter ) ; if ( info -> request -> method != HTTP_GET ) goto error ; if ( http_request_get_header ( info -> request , ""Host"" ) == NULL ) goto error ; double version = info -> request -> version_major + info -> request -> version_minor * 0.1 ; if ( version < 1.1 ) goto error ; const char * upgrade = http_request_get_header ( info -> request , ""Upgrade"" ) ; if ( upgrade == NULL || strcasecmp ( upgrade , ""websocket"" ) != 0 ) goto error ; const char * connection = http_request_get_header ( info -> request , ""Connection"" ) ; if ( connection == NULL ) goto error ; else { bool found_upgrade = false ; int count ; sds * tokens = sdssplitlen ( connection , strlen ( connection ) , "","" , 1 , & count ) ; if ( tokens == NULL ) goto error ; for ( int i = 0 ; i < count ; i ++ ) { sds token = tokens [ i ] ; sdstrim ( token , """" ) ; if ( strcasecmp ( token , ""Upgrade"" ) == 0 ) { found_upgrade = true ; break ; } } sdsfreesplitres ( tokens , count ) ; if ( ! found_upgrade ) goto error ; } const char * ws_version = http_request_get_header ( info -> request , ""Sec-WebSocket-Version"" ) ; if ( ws_version == NULL || strcmp ( ws_version ,
",0,510
592,"static int daemon_msg_findallif_req ( uint8 ver , struct daemon_slpars * pars , uint32 plen ) { char errbuf [ PCAP_ERRBUF_SIZE ] ; char errmsgbuf [ PCAP_ERRBUF_SIZE ] ; char sendbuf [ RPCAP_NETBUF_SIZE ] ; int sendbufidx = 0 ; pcap_if_t * alldevs = NULL ; pcap_if_t * d ; struct pcap_addr * address ; struct rpcap_findalldevs_if * findalldevs_if ; uint16 nif = 0 ; if ( rpcapd_discard ( pars -> sockctrl , plen ) == - 1 ) { return - 1 ; } if ( pcap_findalldevs ( & alldevs , errmsgbuf ) == - 1 ) goto error ; if ( alldevs == NULL ) { if ( rpcap_senderror ( pars -> sockctrl , ver , PCAP_ERR_NOREMOTEIF , ""Nointerfacesfound
",0,239
593,"static int create_problem_dir ( GHashTable * problem_info , unsigned pid ) { if ( g_settings_nMaxCrashReportsSize > 0 ) { if ( low_free_space ( g_settings_nMaxCrashReportsSize , g_settings_dump_location ) ) exit ( 1 ) ; } gchar * dir_basename = g_hash_table_lookup ( problem_info , ""basename"" ) ; if ( ! dir_basename ) dir_basename = g_hash_table_lookup ( problem_info , FILENAME_TYPE ) ; char * path = xasprintf ( ""%s/%s-%s-%u.new"" , g_settings_dump_location , dir_basename , iso_date_string ( NULL ) , pid ) ; g_hash_table_remove ( problem_info , ""basename"" ) ; dd = dd_create ( path , client_uid , DEFAULT_DUMP_DIR_MODE ) ; if ( ! dd ) { error_msg_and_die ( ""Errorcreatingproblemdirectory\'%s\'"" , path ) ; } dd_create_basic_files ( dd , client_uid , NULL ) ; dd_save_text ( dd , FILENAME_ABRT_VERSION , VERSION ) ; gpointer gpkey = g_hash_table_lookup ( problem_info , FILENAME_CMDLINE ) ; if ( ! gpkey ) { char * cmdline = get_cmdline ( pid ) ; if ( cmdline ) { dd_save_text ( dd , FILENAME_CMDLINE , cmdline ) ; free ( cmdline ) ; } } char uid_str [ sizeof ( long ) * 3 + 2 ] ; sprintf ( uid_str , ""%lu"" , ( long ) client_uid ) ; dd_save_text ( dd , FILENAME_UID , uid_str ) ; GHashTableIter iter ; gpointer gpvalue ; g_hash_table_iter_init ( & iter , problem_info ) ; while ( g_hash_table_iter_next ( & iter , & gpkey , & gpvalue ) ) { dd_save_text ( dd , ( gchar * ) gpkey , ( gchar * ) gpvalue ) ; } }
",0,507
594,"static void InsertRow ( unsigned char * p , ssize_t y , Image * image , int bpp ) { ExceptionInfo * exception ; int bit ; ssize_t x ; register PixelPacket * q ; IndexPacket index ; register IndexPacket * indexes ; exception = ( & image -> exception ) ; switch ( bpp ) { case 1 : { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; indexes = GetAuthenticIndexQueue ( image ) ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 7 ) ; x += 8 ) { for ( bit = 0 ; bit < 8 ; bit ++ ) { index = ( ( * p ) & ( 0x80 >> bit ) ? 0x01 : 0x00 ) ; SetPixelIndex ( indexes + x + bit , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; q ++ ; } p ++ ; } if ( ( image -> columns % 8 ) != 0 ) { for ( bit = 0 ; bit < ( ssize_t ) ( image -> columns % 8 ) ; bit ++ ) { index = ( ( * p ) & ( 0x80 >> bit ) ? 0x01 : 0x00 ) ; SetPixelIndex ( indexes + x + bit , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; q ++ ; } p ++ ; } if ( ! SyncAuthenticPixels ( image , exception ) ) break ; break ; } case 2 : { q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; indexes = GetAuthenticIndexQueue ( image ) ; for ( x = 0 ; x < ( ( ssize_t ) image -> columns - 1 ) ; x += 2 ) { index = ConstrainColormapIndex ( image , ( * p >> 6 ) & 0x3 ) ; SetPixelIndex ( indexes + x , index ) ; SetPixelRGBO ( q , image -> colormap + ( ssize_t ) index ) ; q ++ ; index = ConstrainColormapIndex
",0,511
595,"void bn_sqr_comba8 ( BN_ULONG * r , const BN_ULONG * a ) { BN_ULONG c1 , c2 , c3 ; c1 = 0 ; c2 = 0 ; c3 = 0 ; sqr_add_c ( a , 0 , c1 , c2 , c3 ) ; r [ 0 ] = c1 ; c1 = 0 ; sqr_add_c2 ( a , 1 , 0 , c2 , c3 , c1 ) ; r [ 1 ] = c2 ; c2 = 0 ; sqr_add_c ( a , 1 , c3 , c1 , c2 ) ; sqr_add_c2 ( a , 2 , 0 , c3 , c1 , c2 ) ; r [ 2 ] = c3 ; c3 = 0 ; sqr_add_c2 ( a , 3 , 0 , c1 , c2 , c3 ) ; sqr_add_c2 ( a , 2 , 1 , c1 , c2 , c3 ) ; r [ 3 ] = c1 ; c1 = 0 ; sqr_add_c ( a , 2 , c2 , c3 , c1 ) ; sqr_add_c2 ( a , 3 , 1 , c2 , c3 , c1 ) ; sqr_add_c2 ( a , 4 , 0 , c2 , c3 , c1 , c2 ) ; r [ 4 ] = c2 ; c2 = 0 ; sqr_add_c2 ( a , 5 , 0 , c3 , c1 , c2 ) ; sqr_add_c2 ( a , 4 , 1 , c3 , c1 , c2 ) ; sqr_add_c2 ( a , 3 , 2 , c3 , c1 , c2 ) ; r [ 5 ] = c3 ; c3 = 0 ; sqr_add_c ( a , 3 , c1 , c2 , c3 ) ; sqr_add_c2 ( a , 4 , 2 , c1 , c2 , c3 ) ; sqr_add_c2 ( a , 5 , 1 , c1 , c2 , c3 ) ; sqr_add_c2 ( a , 6 , 0 , c2 , c3 ) ; r [
",0,511
596,"static void __skb_complete_tx_timestamp ( struct sk_buff * skb , struct sock * sk , int tstype , bool opt_stats ) { struct sock_exterr_skb * serr ; int err ; BUILD_BUG_ON ( sizeof ( struct sock_exterr_skb ) > sizeof ( skb -> cb ) ) ; serr = SKB_EXT_ERR ( skb ) ; memset ( serr , 0 , sizeof ( * serr ) ) ; serr -> ee . ee_errno = ENOMSG ; serr -> ee . ee_origin = SO_EE_ORIGIN_TIMESTAMPING ; serr -> opt_stats = opt_stats ; if ( sk -> sk_tsflags & SOF_TIMESTAMPING_OPT_ID ) { serr -> ee . ee_data = skb_shinfo ( skb ) -> tskey ; if ( sk -> sk_protocol == IPPROTO_TCP && sk -> sk_type == SOCK_STREAM ) serr -> ee . ee_data -= sk -> sk_tskey ; } err = sock_queue_err_skb ( sk , skb ) ; if ( err ) kfree_skb ( skb ) ; }
",0,294
597,"static Image * ReadDDSImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image ; MagickBooleanType status , cubemap = MagickFalse , volume = MagickFalse , matte ; CompressionType compression ; DDSInfo dds_info ; DDSDecoder * decoder ; size_t n , num_images ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } if ( ReadDDSInfo ( image , & dds_info ) != MagickTrue ) { ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; } if ( dds_info . ddscaps2 & DDSCAPS2_CUBEMAP ) cubemap = MagickTrue ; if ( dds_info . ddscaps2 & DDSCAPS2_VOLUME && dds_info . depth > 0 ) volume = MagickTrue ; ( void ) SeekBlob ( image , 128 , SEEK_SET ) ; if ( dds_info . pixelformat . flags & DDPF_RGB ) { compression = NoCompression ; if ( dds_info . pixelformat . flags & DDPF_ALPHAPIXELS ) { matte = MagickTrue ; decoder = ReadUncompressedRGBA ; } else { matte = MagickTrue ; decoder = ReadUncompressedRGB ; } } else if ( dds_info . pixelformat . flags & DDPF_LUMINANCE ) { compression = NoCompression ; if ( dds_info . pixelformat . flags & DDPF_ALPHAPIXELS ) { ThrowReaderException ( CorruptImageError , ""ImageTypeNotSupported"" ) ;
",0,511
598,"void vrrp_print ( netdissect_options * ndo , register const u_char * bp , register u_int len , register const u_char * bp2 , int ttl ) { int version , type , auth_type = VRRP_AUTH_NONE ; const char * type_s ; ND_TCHECK ( bp [ 0 ] ) ; version = ( bp [ 0 ] & 0xf0 ) >> 4 ; type = bp [ 0 ] & 0x0f ; type_s = tok2str ( type2str , ""unknowntype(%u)"" , type ) ; ND_PRINT ( ( ndo , ""VRRPv%u,%s"" , version , type_s ) ) ; if ( ttl != 255 ) ND_PRINT ( ( ndo , "",(ttl%u)"" , ttl ) ) ; if ( version < 2 || version > 3 || type != VRRP_TYPE_ADVERTISEMENT ) return ; ND_TCHECK ( bp [ 2 ] ) ; ND_PRINT ( ( ndo , "",vrid%u,prio%u"" , bp [ 1 ] , bp [ 2 ] ) ) ; ND_TCHECK ( bp [ 5 ] ) ; if ( version == 2 ) { auth_type = bp [ 4 ] ; ND_PRINT ( ( ndo , "",authtype%s"" , tok2str ( auth2str , NULL , auth_type ) ) ) ; ND_PRINT ( ( ndo , "",intvl%us,length%u"" , bp [ 5 ] , len ) ) ; } else { uint16_t intvl = ( bp [ 4 ] & 0x0f ) << 8 | bp [ 5 ] ; ND_PRINT ( ( ndo , "",intvl%ucs,length%u"" , intvl , len ) ) ; } if ( ndo -> ndo_vflag ) { int naddrs = bp [ 3 ] ; int i ; char c ; if ( version == 2 && ND_TTEST2 ( bp [ 0 ] , len ) ) { struct cksum_vec vec [ 1 ] ; vec [ 0 ] . ptr = bp ; vec [ 0 ] . len = len ; if ( in_cksum ( vec , 1 ) ) goto
",0,511
599,"static void test_burl_normalize ( void ) { buffer * psrc = buffer_init ( ) ; buffer * ptmp = buffer_init ( ) ; int flags ; flags = HTTP_PARSEOPT_URL_NORMALIZE_UNRESERVED ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""no-slash"" ) , CONST_STR_LEN ( ""no-slash"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/"" ) , CONST_STR_LEN ( ""/"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/abc"" ) , CONST_STR_LEN ( ""/abc"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/abc/"" ) , CONST_STR_LEN ( ""/abc/"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/abc/def"" ) , CONST_STR_LEN ( ""/abc/def"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/abc?"" ) , CONST_STR_LEN ( ""/abc?"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/abc?d"" ) , CONST_STR_LEN ( ""/abc?d"" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_LEN ( ""/abc?d="" ) , CONST_STR_LEN ( ""/abc?d="" ) ) ; run_burl_normalize ( psrc , ptmp , flags , __LINE__ , CONST_STR_L
",0,511
600,"static int __ptrace_may_access ( struct task_struct * task , unsigned int mode ) { const struct cred * cred = current_cred ( ) , * tcred ; int dumpable = 0 ; if ( same_thread_group ( task , current ) ) return 0 ; rcu_read_lock ( ) ; tcred = __task_cred ( task ) ; if ( uid_eq ( cred -> uid , tcred -> euid ) && uid_eq ( cred -> uid , tcred -> suid ) && uid_eq ( cred -> uid , tcred -> uid ) && gid_eq ( cred -> gid , tcred -> egid ) && gid_eq ( cred -> gid , tcred -> sgid ) && gid_eq ( cred -> gid , tcred -> gid ) ) goto ok ; if ( ptrace_has_cap ( tcred -> user_ns , mode ) ) goto ok ; rcu_read_unlock ( ) ; return - EPERM ; ok : rcu_read_unlock ( ) ; smp_rmb ( ) ; if ( task -> mm ) dumpable = get_dumpable ( task -> mm ) ; rcu_read_lock ( ) ; if ( ! dumpable && ! ptrace_has_cap ( __task_cred ( task ) -> user_ns , mode ) ) { rcu_read_unlock ( ) ; return - EPERM ; } rcu_read_unlock ( ) ; return security_ptrace_access_check ( task , mode ) ; }
",0,351
601,"static void add_bytes_l2_c ( uint8_t * dst , uint8_t * src1 , uint8_t * src2 , int w ) { long i ; for ( i = 0 ; i <= w - ( int ) sizeof ( long ) ; i += sizeof ( long ) ) { long a = * ( long * ) ( src1 + i ) ; long b = * ( long * ) ( src2 + i ) ; * ( long * ) ( dst + i ) = ( ( a & pb_7f ) + ( b & pb_7f ) ) ^ ( ( a ^ b ) & pb_80 ) ; } for ( ; i < w ; i ++ ) dst [ i ] = src1 [ i ] + src2 [ i ] ; }
",1,173
602,"static void * __dma_alloc_coherent ( struct device * dev , size_t size , dma_addr_t * dma_handle , gfp_t flags , struct dma_attrs * attrs ) { if ( dev == NULL ) { WARN_ONCE ( 1 , ""UseanactualdevicestructureforDMAallocation\\n"" ) ; return NULL ; } if ( IS_ENABLED ( CONFIG_ZONE_DMA ) && dev -> coherent_dma_mask <= DMA_BIT_MASK ( 32 ) ) flags |= GFP_DMA ; if ( IS_ENABLED ( CONFIG_DMA_CMA ) && ( flags & __GFP_WAIT ) ) { struct page * page ; void * addr ; size = PAGE_ALIGN ( size ) ; page = dma_alloc_from_contiguous ( dev , size >> PAGE_SHIFT , get_order ( size ) ) ; if ( ! page ) return NULL ; * dma_handle = phys_to_dma ( dev , page_to_phys ( page ) ) ; addr = page_address ( page ) ; memset ( addr , 0 , size ) ; return addr ; } else { return swiotlb_alloc_coherent ( dev , size , dma_handle , flags ) ; } }
",1,293
603,"void jas_matrix_clip ( jas_matrix_t * matrix , jas_seqent_t minval , jas_seqent_t maxval ) { jas_matind_t i ; jas_matind_t j ; jas_seqent_t v ; jas_seqent_t * rowstart ; jas_seqent_t * data ; jas_matind_t rowstep ; if ( jas_matrix_numrows ( matrix ) > 0 && jas_matrix_numcols ( matrix ) > 0 ) { assert ( matrix -> rows_ ) ; rowstep = jas_matrix_rowstep ( matrix ) ; for ( i = matrix -> numrows_ , rowstart = matrix -> rows_ [ 0 ] ; i > 0 ; -- i , rowstart += rowstep ) { data = rowstart ; for ( j = matrix -> numcols_ , data = rowstart ; j > 0 ; -- j , ++ data ) { v = * data ; if ( v < minval ) { * data = minval ; } else if ( v > maxval ) { * data = maxval ; } } } } }
",1,261
604,"void ihevcd_parse_sei_payload ( codec_t * ps_codec , UWORD32 u4_payload_type , UWORD32 u4_payload_size , WORD8 i1_nal_type ) { parse_ctxt_t * ps_parse = & ps_codec -> s_parse ; bitstrm_t * ps_bitstrm = & ps_parse -> s_bitstrm ; WORD32 payload_bits_remaining = 0 ; sps_t * ps_sps ; UWORD32 i ; for ( i = 0 ; i < MAX_SPS_CNT ; i ++ ) { ps_sps = ps_codec -> ps_sps_base + i ; if ( ps_sps -> i1_sps_valid ) { break ; } } if ( NULL == ps_sps ) { return ; } if ( NAL_PREFIX_SEI == i1_nal_type ) { switch ( u4_payload_type ) { case SEI_BUFFERING_PERIOD : ps_parse -> s_sei_params . i1_sei_parameters_present_flag = 1 ; ihevcd_parse_buffering_period_sei ( ps_codec , ps_sps ) ; break ; case SEI_PICTURE_TIMING : ps_parse -> s_sei_params . i1_sei_parameters_present_flag = 1 ; ihevcd_parse_pic_timing_sei ( ps_codec , ps_sps ) ; break ; case SEI_TIME_CODE : ps_parse -> s_sei_params . i1_sei_parameters_present_flag = 1 ; ihevcd_parse_time_code_sei ( ps_codec ) ; break ; case SEI_MASTERING_DISPLAY_COLOUR_VOLUME : ps_parse -> s_sei_params . i4_sei_mastering_disp_colour_vol_params_present_flags = 1 ; ihevcd_parse_mastering_disp_params_sei ( ps_codec ) ; break ; case SEI_USER_DATA_REGISTERED_ITU_T_T35 : ps_parse ->
",0,511
605,"static int cypress_generic_port_probe ( struct usb_serial_port * port ) { struct usb_serial * serial = port -> serial ; struct cypress_private * priv ; if ( ! port -> interrupt_out_urb || ! port -> interrupt_in_urb ) { dev_err ( & port -> dev , ""requiredendpointismissing\\n"" ) ; return - ENODEV ; } priv = kzalloc ( sizeof ( struct cypress_private ) , GFP_KERNEL ) ; if ( ! priv ) return - ENOMEM ; priv -> comm_is_ok = ! 0 ; spin_lock_init ( & priv -> lock ) ; if ( kfifo_alloc ( & priv -> write_fifo , CYPRESS_BUF_SIZE , GFP_KERNEL ) ) { kfree ( priv ) ; return - ENOMEM ; } if ( ! is_frwd ( serial -> dev ) ) usb_reset_configuration ( serial -> dev ) ; priv -> cmd_ctrl = 0 ; priv -> line_control = 0 ; priv -> termios_initialized = 0 ; priv -> rx_flags = 0 ; if ( port -> interrupt_out_size > 9 ) priv -> pkt_fmt = packet_format_1 ; else priv -> pkt_fmt = packet_format_2 ; if ( interval > 0 ) { priv -> write_urb_interval = interval ; priv -> read_urb_interval = interval ; dev_dbg ( & port -> dev , ""%s-read&writeintervalsforcedto%d\\n"" , __func__ , interval ) ; } else { priv -> write_urb_interval = port -> interrupt_out_urb -> interval ; priv -> read_urb_interval = port -> interrupt_in_urb -> interval ; dev_dbg ( & port -> dev , ""%s-intervals:read=%dwrite=%d\\n"" , __func__ , priv -> read_urb_interval , priv -> write_urb_interval ) ; } usb_set_serial_port_data ( port , priv ) ; port -> port . drain_delay = 256 ; return 0 ; }
",1,478
606,"int sdma_init ( struct hfi1_devdata * dd , u8 port ) { unsigned this_idx ; struct sdma_engine * sde ; struct rhashtable * tmp_sdma_rht ; u16 descq_cnt ; void * curr_head ; struct hfi1_pportdata * ppd = dd -> pport + port ; u32 per_sdma_credits ; uint idle_cnt = sdma_idle_cnt ; size_t num_engines = chip_sdma_engines ( dd ) ; int ret = - ENOMEM ; if ( ! HFI1_CAP_IS_KSET ( SDMA ) ) { HFI1_CAP_CLEAR ( SDMA_AHG ) ; return 0 ; } if ( mod_num_sdma && mod_num_sdma <= chip_sdma_engines ( dd ) && mod_num_sdma >= num_vls ) num_engines = mod_num_sdma ; dd_dev_info ( dd , ""SDMAmod_num_sdma:%u\\n"" , mod_num_sdma ) ; dd_dev_info ( dd , ""SDMAchip_sdma_engines:%u\\n"" , chip_sdma_engines ( dd ) ) ; dd_dev_info ( dd , ""SDMAchip_sdma_mem_size:%u\\n"" , chip_sdma_mem_size ( dd ) ) ; per_sdma_credits = chip_sdma_mem_size ( dd ) / ( num_engines * SDMA_BLOCK_SIZE ) ; init_waitqueue_head ( & dd -> sdma_unfreeze_wq ) ; atomic_set ( & dd -> sdma_unfreeze_count , 0 ) ; descq_cnt = sdma_get_descq_cnt ( ) ; dd_dev_info ( dd , ""SDMAengines%zudescq_cnt%u\\n"" , num_engines , descq_cnt ) ; dd -> per_sdma = kcalloc_node ( num_engines , sizeof ( * dd -> per_sdma ) , GFP_KERNEL , dd -> node ) ; if ( ! dd
",0,511
607,"static int snd_seq_device_dev_free ( struct snd_device * device ) { struct snd_seq_device * dev = device -> device_data ; cancel_autoload_drivers ( ) ; put_device ( & dev -> dev ) ; return 0 ; }
",1,63
608,"int mi_repair_parallel ( MI_CHECK * param , register MI_INFO * info , const char * name , int rep_quick , my_bool no_copy_stat ) { int got_error ; uint i , key , total_key_length , istep ; ulong rec_length ; ha_rows start_records ; my_off_t new_header_length , del ; File new_file ; MI_SORT_PARAM * sort_param = 0 ; MYISAM_SHARE * share = info -> s ; ulong * rec_per_key_part ; HA_KEYSEG * keyseg ; char llbuff [ 22 ] ; IO_CACHE new_data_cache ; IO_CACHE_SHARE io_share ; SORT_INFO sort_info ; ulonglong UNINIT_VAR ( key_map ) ; pthread_attr_t thr_attr ; ulong max_pack_reclength ; int error ; DBUG_ENTER ( ""mi_repair_parallel"" ) ; start_records = info -> state -> records ; got_error = 1 ; new_file = - 1 ; new_header_length = ( param -> testflag & T_UNPACK ) ? 0 : share -> pack . header_length ; if ( ! ( param -> testflag & T_SILENT ) ) { printf ( ""-parallelrecovering(withsort)MyISAM-table\'%s\'\\n"" , name ) ; printf ( ""Datarecords:%s\\n"" , llstr ( start_records , llbuff ) ) ; } param -> testflag |= T_REP ; if ( info -> s -> options & ( HA_OPTION_CHECKSUM | HA_OPTION_COMPRESS_RECORD ) ) param -> testflag |= T_CALC_CHECKSUM ; DBUG_PRINT ( ""info"" , ( ""isquickrepair:%d"" , rep_quick ) ) ; bzero ( ( char * ) & sort_info , sizeof ( sort_info ) ) ; mysql_mutex_init ( mi_key_mutex_MI_SORT_INFO_mutex , & sort_info . mutex , MY_MUTEX_INIT_FAST ) ; mysql_cond_init (
",0,511
609,"Image * AutoResizeImage ( const Image * image , const char * option , MagickOffsetType * count , ExceptionInfo * exception ) { # define MAX_SIZES 16 char * q ; const char * p ; Image * resized , * images ; register ssize_t i ; size_t sizes [ MAX_SIZES ] = { 256 , 192 , 128 , 96 , 64 , 48 , 40 , 32 , 24 , 16 } ; images = NULL ; * count = 0 ; i = 0 ; p = option ; while ( * p != '\\0' && i < MAX_SIZES ) { size_t size ; while ( ( isspace ( ( int ) ( ( unsigned char ) * p ) ) != 0 ) ) p ++ ; size = ( size_t ) strtol ( p , & q , 10 ) ; if ( ( p == q ) || ( size < 16 || size > 256 ) ) return ( ( Image * ) NULL ) ; p = q ; sizes [ i ++ ] = size ; while ( ( isspace ( ( int ) ( ( unsigned char ) * p ) ) != 0 ) || ( * p == ',' ) ) p ++ ; } if ( i == 0 ) i = 10 ; * count = i ; for ( i = 0 ; i < * count ; i ++ ) { resized = ResizeImage ( image , sizes [ i ] , sizes [ i ] , image -> filter , exception ) ; if ( resized == ( Image * ) NULL ) return ( DestroyImageList ( images ) ) ; if ( images == ( Image * ) NULL ) images = resized ; else AppendImageToList ( & images , resized ) ; } return ( images ) ; }
",1,368
610,"STATIC int xfs_attr_calc_size ( struct xfs_inode * ip , int namelen , int valuelen , int * local ) { struct xfs_mount * mp = ip -> i_mount ; int size ; int nblks ; size = xfs_attr_leaf_newentsize ( namelen , valuelen , mp -> m_sb . sb_blocksize , local ) ; nblks = XFS_DAENTER_SPACE_RES ( mp , XFS_ATTR_FORK ) ; if ( * local ) { if ( size > ( mp -> m_sb . sb_blocksize >> 1 ) ) { nblks *= 2 ; } } else { uint dblocks = xfs_attr3_rmt_blocks ( mp , valuelen ) ; nblks += dblocks ; nblks += XFS_NEXTENTADD_SPACE_RES ( mp , dblocks , XFS_ATTR_FORK ) ; } return nblks ; }
",1,230
611,"Datum hstore_recv ( PG_FUNCTION_ARGS ) { int32 buflen ; HStore * out ; Pairs * pairs ; int32 i ; int32 pcount ; StringInfo buf = ( StringInfo ) PG_GETARG_POINTER ( 0 ) ; pcount = pq_getmsgint ( buf , 4 ) ; if ( pcount == 0 ) { out = hstorePairs ( NULL , 0 , 0 ) ; PG_RETURN_POINTER ( out ) ; } for ( i = 0 ; i < pcount ; ++ i ) { int rawlen = pq_getmsgint ( buf , 4 ) ; int len ; if ( rawlen < 0 ) ereport ( ERROR , ( errcode ( ERRCODE_NULL_VALUE_NOT_ALLOWED ) , errmsg ( ""nullvaluenotallowedforhstorekey"" ) ) ) ; pairs [ i ] . key = pq_getmsgtext ( buf , rawlen , & len ) ; pairs [ i ] . keylen = hstoreCheckKeyLen ( len ) ; pairs [ i ] . needfree = true ; rawlen = pq_getmsgint ( buf , 4 ) ; if ( rawlen < 0 ) { pairs [ i ] . val = NULL ; pairs [ i ] . vallen = 0 ; pairs [ i ] . isnull = true ; } else { pairs [ i ] . val = pq_getmsgtext ( buf , rawlen , & len ) ; pairs [ i ] . vallen = hstoreCheckValLen ( len ) ; pairs [ i ] . isnull = false ; } } pcount = hstoreUniquePairs ( pairs , pcount , & buflen ) ; out = hstorePairs ( pairs , pcount , buflen ) ; PG_RETURN_POINTER ( out ) ; }
",0,406
612,"static void parserule ( struct scanner * s , struct environment * env ) { struct rule * r ; char * var ; struct evalstring * val ; bool hascommand = false , hasrspfile = false , hasrspcontent = false ; r = mkrule ( scanname ( s ) ) ; scannewline ( s ) ; while ( scanindent ( s ) ) { var = scanname ( s ) ; parselet ( s , & val ) ; } if ( strcmp ( var , ""command"" ) == 0 ) hascommand = true ; else if ( strcmp ( var , ""rspfile"" ) == 0 ) hasrspfile = true ; else if ( strcmp ( var , ""rspfile_content"" ) == 0 ) hasrspcontent = true ; } if ( ! hascommand ) fatal ( ""rule\'%s\'hasnocommand"" , r -> name ) ; if ( hasrspfile != hasrspcontent ) fatal ( ""rule\'%s\'hasrspfileandnorspfile_contentorviceversa"" , r -> name ) ; envaddrule ( env , r ) ; }
",0,250
613,"int read_escaped_char ( yyscan_t yyscanner , uint8_t * escaped_char ) { char text [ 4 ] = { 0 , 0 , 0 , 0 } ; text [ 0 ] = '\\\\' ; text [ 1 ] = RE_YY_INPUT ( yyscanner ) ; if ( text [ 1 ] == EOF || text [ 1 ] == 0 ) return 0 ; if ( ! isxdigit ( text [ 1 ] == 'x' ) { text [ 2 ] ) ) return 0 ; text [ 3 ] = RE_YY_INPUT ( yyscanner ) ; if ( ! isxdigit ( text [ 3 ] ) ) return 0 ; } * escaped_char = escaped_char_value ( text ) ; return 1 ; }
",1,171
614,"static HeadReturn con_header_read ( agooCon c , size_t * mlenp ) { char * hend = strstr ( c -> buf , ""\\r\\n\\r\\n"" ) ; agooMethod method ; struct _agooSeg path ; char * query = NULL ; char * qend ; char * b ; size_t clen = 0 ; long mlen ; agooHook hook = NULL ; agooPage p ; struct _agooErr err = AGOO_ERR_INIT ; if ( NULL == hend ) { if ( sizeof ( c -> buf ) - 1 <= c -> bcnt ) { return bad_request ( c , 431 , __LINE__ ) ; } return HEAD_AGAIN ; } if ( agoo_req_cat . on ) { * hend = '\\0' ; agoo_log_cat ( & agoo_req_cat , ""%s%llu:%s"" , agoo_con_kind_str ( c -> bind -> kind ) , ( unsigned long long ) c -> id , c -> buf ) ; * hend = '\\r' ; } for ( b = c -> buf ; '' != * b ; b ++ ) { if ( '\\0' == * b ) { return bad_request ( c , 400 , __LINE__ ) ; } } switch ( toupper ( * c -> buf ) ) { case 'G' : if ( 3 != b - c -> buf || 0 != strncmp ( ""GET"" , c -> buf , 3 ) ) { return bad_request ( c , 400 , __LINE__ ) ; } method = AGOO_GET ; break ; case 'P' : { const char * v ; int vlen = 0 ; char * vend ; if ( 3 == b - c -> buf && 0 == strncmp ( ""PUT"" , c -> buf , 3 ) ) { method = AGOO_PUT ; } else if ( 4 == b - c -> buf && 0 == strncmp ( ""POST"" , c -> buf , 4 ) ) { method = AGOO_POST ; } else { return bad_request ( c , 400 , __LINE__ ) ; } if ( NULL == ( v = agoo_con_header_value ( c -> buf , ( int ) ( hend - c -> buf ) , ""Content-Length""
",0,511
615,"void vp9_fht16x16_c ( const tran_low_t * input , tran_low_t * output , int stride , int tx_type ) { if ( tx_type == DCT_DCT ) { vpx_fdct16x16_c ( input , output , stride ) ; } else { tran_low_t out [ 256 ] ; int16_t * outptr = & out [ 0 ] ; int i , j ; tran_low_t temp_in [ 16 ] , temp_out [ 16 ] ; const transform_2d ht = FHT_16 [ tx_type ] ; for ( i = 0 ; i < 16 ; ++ i ) { for ( j = 0 ; j < 16 ; ++ j ) out [ i * stride + i ] * 4 ; ht . cols ( temp_in , temp_out ) ; for ( j = 0 ; j < 16 ; ++ j ) outptr [ j * 16 + i ] = ( temp_out [ j ] + 1 + ( temp_out [ j ] < 0 ) ) >> 2 ; } for ( i = 0 ; i < 16 ; ++ i ) { for ( j = 0 ; j < 16 ; ++ j ) temp_in [ j ] = out [ j + i * 16 ] ; ht . rows ( temp_in , temp_out ) ; for ( j = 0 ; j < 16 ; ++ j ) output [ j + i * 16 ] = temp_out [ j ] ; } } }
",0,334
616,"static gboolean export_desktop_file ( const char * app , const char * branch , const char * arch , GKeyFile * metadata , const char * const * previous_ids , int parent_fd , const char * name , struct stat * stat_buf , char * * target , GCancellable * cancellable , GError * * error ) { gboolean ret = FALSE ; glnx_autofd int desktop_fd = - 1 ; g_autofree char * tmpfile_name = g_strdup_printf ( ""export-desktop-XXXXXX"" ) ; g_autoptr ( GOutputStream ) out_stream = NULL ; g_autofree gchar * data = NULL ; gsize data_len ; g_autofree gchar * new_data = NULL ; gsize new_data_len ; g_autoptr ( GKeyFile ) keyfile = NULL ; g_autofree gchar * old_exec = NULL ; gint old_argc ; g_auto ( GStrv ) old_argv = NULL ; g_auto ( GStrv ) groups = NULL ; GString * new_exec = NULL ; g_autofree char * escaped_app = maybe_quote ( app ) ; g_autofree char * escaped_branch = maybe_quote ( branch ) ; g_autofree char * escaped_arch = maybe_quote ( arch ) ; int i ; if ( ! flatpak_openat_noatime ( parent_fd , name , & desktop_fd , cancellable , error ) ) goto out ; if ( ! read_fd ( desktop_fd , stat_buf , & data , & data_len , error ) ) goto out ; keyfile = g_key_file_new ( ) ; if ( ! g_key_file_load_from_data ( keyfile , data , data_len , G_KEY_FILE_KEEP_TRANSLATIONS , error ) ) goto out ; if ( g_str_has_suffix ( name , "".service"" ) ) { g_autofree gchar * dbus_name = NULL ; g_autofree gchar * expected_dbus_name = g_strndup ( name , strlen ( name ) - strlen ( "".service"" ) ) ; dbus_name
",0,511
617,"static __be32 nfsd3_proc_setacl ( struct svc_rqst * rqstp , struct nfsd3_setaclargs * argp , struct nfsd3_attrstat * resp ) { struct inode * inode ; svc_fh * fh ; __be32 nfserr = 0 ; int error ; fh = fh_copy ( & resp -> fh , & argp -> fh ) ; nfserr = fh_verify ( rqstp , & resp -> fh , 0 , NFSD_MAY_SATTR ) ; if ( nfserr ) goto out ; inode = d_inode ( fh -> fh_dentry ) ; error = fh_want_write ( fh ) ; if ( error ) goto out_errno ; } error = fh_want_write ( fh ) ; if ( error ) goto out_errno ; fh_lock ( fh ) ; error = set_posix_acl ( inode , ACL_TYPE_ACCESS , argp -> acl_access ) ; if ( error ) goto out_drop_lock ; error = set_posix_acl ( inode , ACL_TYPE_DEFAULT , argp -> acl_default , ACL_TYPE_DEFAULT ) ; out_drop_write : fh_drop_write ( fh ) ; out_errno : nfserr = nfserrno ( error ) ; out : posix_acl_release ( argp -> acl_access ) ; posix_acl_release ( argp -> acl_default ) ; RETURN_STATUS ( nfserr ) ; }
",1,381
618,"size_t compile_tree ( struct filter_op * * fop ) { int i = 1 ; struct filter_op * array = NULL ; struct unfold_elm * ue ; if ( tree_root == NULL ) return 0 ; fprintf ( stdout , ""Unfoldingthemeta-tree"" ) ; fflush ( stdout ) ; unfold_blk ( & tree_root ) ; fprintf ( stdout , ""done.\\n\\n"" ) ; labels_to_offsets ( ) ; TAILQ_FOREACH ( ue , & unfolded_tree , next ) { if ( ue -> label == 0 ) { SAFE_REALLOC ( array , i * sizeof ( struct filter_op ) ) ; memcpy ( & array [ i - 1 ] , & ue -> fop , sizeof ( struct filter_op ) ) ; i ++ ; } } SAFE_REALLOC ( array , i * sizeof ( struct filter_op ) ) ; array [ i - 1 ] . opcode = FOP_EXIT ; * fop = array ; return ( i ) ; }
",1,241
619,"bool config_save ( const config_t * config , const char * filename ) { assert ( config != NULL ) ; assert ( filename != NULL ) ; assert ( * filename != '\\0' ) ; char * temp_filename = osi_calloc ( strlen ( filename ) + 5 ) ; if ( ! temp_filename ) { LOG_ERROR ( ""%sunabletoallocatememoryforfilename."" , __func__ ) ; return false ; } strcpy ( temp_filename , filename ) ; strcat ( temp_filename , "".new"" ) ; FILE * fp = fopen ( temp_filename , ""wt"" ) ; if ( ! fp ) { LOG_ERROR ( ""%sunabletowritefile\'%s\':%s"" , __func__ , temp_filename , strerror ( errno ) ) ; goto error ; } for ( const list_node_t * node = list_begin ( config -> sections ) ; node != list_end ( config -> sections ) ; node = list_next ( node ) ) { const section_t * section = ( const section_t * ) list_node ( node ) ; fprintf ( fp , ""[%s]\\n"" , section -> name ) ; for ( const list_node_t * enode = list_begin ( section -> entries ) ; enode != list_end ( section -> entries ) ; enode = list_next ( enode ) ) { const entry_t * entry = ( const entry_t * ) list_node ( enode ) ; fprintf ( fp , ""%s=%s\\n"" , entry -> key , entry -> value ) ; } if ( list_next ( node ) != list_end ( config -> sections ) ) fputc ( '\\n' , fp ) ; } fflush ( fp ) ; fclose ( fp ) ; if ( chmod ( temp_filename , S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP ) == - 1 ) { LOG_ERROR ( ""%sunabletochangefilepermissions\'%s\':%s"" , __func__ , filename , strerror ( errno ) ) ; goto error ; } if ( rename ( temp_filename , filename ) == - 1 ) { LOG_ERROR ( ""%sunabletochangefileper
",0,511
620,"static int udf_pc_to_char ( struct super_block * sb , unsigned char * from , int fromlen , unsigned char * to , int tolen ) { struct pathComponent * pc ; int elen = 0 ; int comp_len ; unsigned char * p = to ; tolen -- ; while ( elen < fromlen ) { pc = ( struct pathComponent * ) ( from + elen ) ; elen += sizeof ( struct pathComponent ) ; switch ( pc -> componentType ) { case 1 : if ( pc -> lengthComponentIdent > 0 ) { elen += pc -> lengthComponentIdent ; break ; } } if ( p > to + 1 ) p [ - 1 ] = '\\0' ; else p [ 0 ] = '\\0' ; return 0 ; }
",1,170
621,"void nfsreq_print_noaddr ( netdissect_options * ndo , register const u_char * bp , u_int length , register const u_char * bp2 ) { register const struct sunrpc_msg * rp ; register const uint32_t * dp ; nfs_type type ; int v3 ; uint32_t proc ; uint32_t access_flags ; struct nfsv3_sattr sa3 ; ND_PRINT ( ( ndo , ""%d"" , length ) ) ; nfserr = 0 ; rp = ( const struct sunrpc_msg * ) bp ; if ( ! xid_map_enter ( ndo , rp , bp2 ) ) goto trunc ; v3 = ( EXTRACT_32BITS ( & rp -> rm_call . cb_vers ) == NFS_VER3 ) ; proc = EXTRACT_32BITS ( & rp -> rm_call . cb_proc ) ; if ( ! v3 && proc < NFS_NPROCS ) proc = nfsv3_procid [ proc ] ; ND_PRINT ( ( ndo , ""%s"" , tok2str ( nfsproc_str , ""proc-%u"" , proc ) ) ) ; switch ( proc ) { case NFSPROC_GETATTR : case NFSPROC_SETATTR : case NFSPROC_READLINK : case NFSPROC_FSSTAT : case NFSPROC_FSINFO : case NFSPROC_PATHCONF : if ( ( dp = parsereq ( ndo , rp , length ) ) != NULL && parsefh ( ndo , dp , v3 ) != NULL ) return ; break ; case NFSPROC_LOOKUP : case NFSPROC_CREATE : case NFSPROC_MKDIR : case NFSPROC_REMOVE : case NFSPROC_RMDIR : if ( ( dp = parsereq ( ndo , rp , length ) ) != NULL && parsefhn ( ndo , dp , v3 ) != NULL ) return ; break ; case NFSPROC_ACCESS : if ( ( dp = parsereq ( ndo , rp , length ) ) != NULL &&
",0,511
622,"void vtp_print ( netdissect_options * ndo , const u_char * pptr , u_int length ) { int type , len , tlv_len , tlv_value , mgmtd_len ; const u_char * tptr ; const struct vtp_vlan_ * vtp_vlan ; if ( length < VTP_HEADER_LEN ) goto trunc ; tptr = pptr ; ND_TCHECK2 ( * tptr , VTP_HEADER_LEN ) ; type = * ( tptr + 1 ) ; ND_PRINT ( ( ndo , ""VTPv%u,Message%s(0x%02x),length%u"" , * tptr , tok2str ( vtp_message_type_values , ""Unknownmessagetype"" , type ) , type , length ) ) ; if ( ndo -> ndo_vflag < 1 ) { return ; } ND_PRINT ( ( ndo , ""\\n\\tDomainname:"" ) ) ; mgmtd_len = * ( tptr + 3 ) ; if ( mgmtd_len < 1 || mgmtd_len > 32 ) { ND_PRINT ( ( ndo , ""[invalidMgmtDLen%d]"" , mgmtd_len ) ) ; return ; } fn_printzp ( ndo , tptr + 4 , mgmtd_len , NULL ) ; ND_PRINT ( ( ndo , "",%s:%u"" , tok2str ( vtp_header_values , ""Unknown"" , type ) , * ( tptr + 2 ) ) ) ; tptr += VTP_HEADER_LEN ; switch ( type ) { case VTP_SUMMARY_ADV : ND_TCHECK2 ( * tptr , 8 ) ; ND_PRINT ( ( ndo , ""\\n\\tConfigRev%x,Updater%s"" , EXTRACT_32BITS ( tptr ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; tptr += 8 ; ND_TCHECK2 ( * tptr , VTP_UPDATE_TIMESTAMP_LEN ) ; ND_PRINT ( ( ndo , "",Timestamp0x%08x0x%08x0
",0,511
623,"void xmlParsePI ( xmlParserCtxtPtr ctxt ) { xmlChar * buf = NULL ; int len = 0 ; int size = XML_PARSER_BUFFER_SIZE ; int cur , l ; const xmlChar * target ; xmlParserInputState state ; int count = 0 ; if ( ( RAW == '<' ) && ( NXT ( 1 ) == '?' ) ) { xmlParserInputPtr input = ctxt -> input ; state = ctxt -> instate ; ctxt -> instate = XML_PARSER_PI ; SKIP ( 2 ) ; SHRINK ; target = xmlParsePITarget ( ctxt ) ; if ( target != NULL ) { if ( ( RAW == '?' ) && ( NXT ( 1 ) == '>' ) ) { if ( input != ctxt -> input ) { xmlFatalErrMsg ( ctxt , XML_ERR_ENTITY_BOUNDARY , ""PIdeclarationdoesn\'tstartandstopinthesameentity\\n"" ) ; } SKIP ( 2 ) ; if ( ( ctxt -> sax ) && ( ! ctxt -> disableSAX ) && ( ctxt -> sax -> processingInstruction != NULL ) ) ctxt -> sax -> processingInstruction ( ctxt -> userData , ctxt -> input ) ; ctxt -> instate = state ; return ; } buf = ( xmlChar * ) xmlMallocAtomic ( size * sizeof ( xmlChar ) ) ; if ( buf == NULL ) { xmlErrMemory ( ctxt , NULL ) ; ctxt -> instate = state ; return ; } cur = CUR ; if ( ! IS_BLANK ( cur ) ) { xmlFatalErrMsgStr ( ctxt , XML_ERR_SPACE_REQUIRED , ""ParsePI:PI%sspaceexpected\\n"" , target ) ; } SKIP_BLANKS ; cur = CUR_CHAR ( l ) ; while ( IS_CHAR ( cur ) && ( ( cur != '?' ) || ( NXT ( 1 ) != '>' ) ) ) { if ( len + 5 >= size ) { xmlChar * tmp ; size *= 2 ; tmp = ( xmlChar * ) xmlRealloc ( buf , size * sizeof ( xmlChar ) ) ; if ( tmp == NULL ) { xmlErrMemory ( ctxt , NULL ) ; xmlFree ( buf ) ; c
",0,511
624,"int udp_recvmsg ( struct kiocb * iocb , struct sock * sk , struct msghdr * msg , size_t len , int noblock , int flags , int * addr_len ) { struct inet_sock * inet = inet_sk ( sk ) ; struct sockaddr_in * sin = ( struct sockaddr_in * ) msg -> msg_name ; struct sk_buff * skb ; unsigned int ulen , copied ; int peeked , off = 0 ; int err ; int is_udplite = IS_UDPLITE ( sk ) ; bool slow ; if ( addr_len ) * addr_len = sizeof ( * sin ) ; if ( flags & MSG_ERRQUEUE ) return ip_recv_error ( sk , msg , len ) ; try_again : skb = __skb_recv_datagram ( sk , flags | ( noblock ? MSG_DONTWAIT : 0 ) , & peeked , & off , & err ) ; if ( ! skb ) goto out ; ulen = skb -> len - sizeof ( struct udphdr ) ; copied = len ; if ( copied > ulen ) copied = ulen ; else if ( copied < ulen ) msg -> msg_flags |= MSG_TRUNC ; if ( copied < ulen || UDP_SKB_CB ( skb ) -> partial_cov ) { if ( udp_lib_checksum_complete ( skb ) ) goto csum_copy_err ; } if ( skb_csum_unnecessary ( skb ) ) err = skb_copy_datagram_iovec ( skb , sizeof ( struct udphdr ) , msg -> msg_iov , copied ) ; else { err = skb_copy_and_csum_datagram_iovec ( skb , sizeof ( struct udphdr ) , msg -> msg_iov ) ; if ( err == - EINVAL ) goto csum_copy_err ; } if ( unlikely ( err ) ) { trace_kfree_skb ( skb , udp_recvmsg ) ; if ( ! peeked ) { atomic_inc ( & sk -> sk_drops ) ; UDP_INC_STATS_USER ( sock_net ( sk ) , UDP_MIB
",0,511
625,"void rpki_rtr_print ( netdissect_options * ndo , register const u_char * pptr , register u_int len ) { u_int tlen , pdu_type , pdu_len ; const u_char * tptr ; const rpki_rtr_pdu * pdu_header ; tptr = pptr ; tlen = len ; if ( ! ndo -> ndo_vflag ) { ND_PRINT ( ( ndo , "",RPKI-RTR"" ) ) ; return ; } while ( tlen >= sizeof ( rpki_rtr_pdu ) ) { ND_TCHECK2 ( * tptr , sizeof ( rpki_rtr_pdu ) ) ; pdu_header = ( const rpki_rtr_pdu * ) tptr ; pdu_type = pdu_header -> pdu_type ; pdu_len = EXTRACT_32BITS ( pdu_header -> length ) ; ND_TCHECK2 ( * tptr , pdu_len ) ; if ( ! pdu_type || ! pdu_len ) { break ; } if ( tlen < pdu_len ) { goto trunc ; } if ( rpki_rtr_pdu_print ( ndo , tptr , len , pdu_len ) ) goto trunc ; tlen -= pdu_len ; tptr += pdu_len ; } }
",0,320
626,"RD_BOOL cssp_read_tsrequest ( STREAM token , STREAM pubkey ) { STREAM s ; int length ; int tagval ; struct stream packet ; s = tcp_recv ( NULL , 4 ) ; if ( s == NULL ) return False ; if ( s -> p [ 0 ] != ( BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED ) ) { logger ( Protocol , Error , ""cssp_read_tsrequest(),expectedBER_TAG_SEQUENCE|BER_TAG_CONSTRUCTED,got%x"" , s -> p [ 0 ] ) ; return False ; } if ( s -> p [ 1 ] < 0x80 ) length = s -> p [ 1 ] - 2 ; else if ( s -> p [ 1 ] == 0x81 ) length = s -> p [ 2 ] - 1 ; else if ( s -> p [ 1 ] == 0x82 ) length = ( s -> p [ 2 ] << 8 ) | s -> p [ 3 ] ; else return False ; s = tcp_recv ( s , length ) ; if ( ! ber_in_header ( s , & tagval , & length ) || tagval != ( BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 0 ) ) return False ; if ( ! ber_in_header ( s , & tagval , & length ) || tagval != ( BER_TAG_CTXT_SPECIFIC | BER_TAG_CONSTRUCTED | 1 ) ) return False ; if ( ! ber_in_header ( s , & tagval , & length ) || tagval != ( BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED ) ) return False ; if ( ! ber_in_header ( s , & tagval , & length ) || tagval != ( BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED ) ) return False ; if ( ! ber_in_header ( s , & tagval , & length ) || tagval != ( BER_TAG_SEQUENCE | BER_TAG_CONSTRUCTED ) ) return False ; if ( ! ber_in_header ( s , & tagval , & length ) || tagval != ( BER_TAG_CTXT_SPECIFIC | BER_TAG_CON
",0,511
627,"const u_char * ns_nprint ( netdissect_options * ndo , register const u_char * cp , register const u_char * bp ) { register u_int i , l ; register const u_char * rp = NULL ; register int compress = 0 ; u_int elt ; u_int data_size = ndo -> ndo_snapend - bp ; if ( ( l = labellen ( ndo , cp ) ) == ( u_int ) - 1 ) return ( NULL ) ; if ( ! ND_TTEST2 ( * cp , 1 ) ) return ( NULL ) ; if ( ! ND_TTEST2 ( * cp , elt ) ) return ( NULL ) ; chars_processed = 1 ; if ( ( ( i = * cp ++ ) & INDIR_MASK ) != INDIR_MASK ) { compress = 0 ; rp = cp + l ; } if ( i != 0 ) while ( i && cp < ndo -> ndo_snapend ) { if ( ( i & INDIR_MASK ) == INDIR_MASK ) { if ( ! compress ) { rp = cp + 1 ; compress = 1 ; } if ( ! ND_TTEST2 ( * cp , 1 ) ) return ( NULL ) ; cp = bp + ( ( ( i << 8 ) | * cp ) & 0x3fff ) ; if ( ( l = labellen ( ndo , cp ) ) == ( u_int ) - 1 ) return ( NULL ) ; if ( ! ND_TTEST2 ( * cp , 1 ) ) return ( NULL ) ; i = * cp ++ ; chars_processed ++ ; if ( chars_processed >= data_size ) { ND_PRINT ( ( ndo , ""<LOOP>"" ) ) ; return ( NULL ) ; } continue ; } if ( ( i & INDIR_MASK ) == EDNS0_MASK ) { elt = ( i & ~ INDIR_MASK ) ; switch ( elt ) { case EDNS0_ELT_BITLABEL : if ( blabel_print ( ndo , cp ) == NULL ) return ( NULL ) ; break ; default : ND_PRINT ( ( ndo , ""<ELT%d>"" , elt ) ) ; return ( NULL ) ; } } else { if ( fn_print
",0,511
628,"int xfs_attr_rmtval_set ( struct xfs_da_args * args ) { struct xfs_inode * dp = args -> dp ; struct xfs_mount * mp = dp -> i_mount ; struct xfs_bmbt_irec map ; xfs_dablk_t lblkno ; xfs_fileoff_t lfileoff = 0 ; __uint8_t * src = args -> value ; int blkcnt ; int valuelen ; int nmap ; int error ; int offset = 0 ; trace_xfs_attr_rmtval_set ( args ) ; blkcnt = xfs_attr3_rmt_blocks ( mp , args -> rmtvaluelen ) ; error = xfs_bmap_first_unused ( args -> trans , args -> dp , blkcnt , & lfileoff , XFS_ATTR_FORK ) ; if ( error ) return error ; args -> rmtblkno = lblkno = ( xfs_dablk_t ) lfileoff ; args -> rmtblkcnt = blkcnt ; while ( blkcnt > 0 ) { int committed ; xfs_bmap_init ( args -> flist , args -> firstblock ) ; nmap = 1 ; error = xfs_bmapi_write ( args -> trans , dp , ( xfs_fileoff_t ) lblkno , blkcnt , XFS_BMAPI_ATTRFORK | XFS_BMAPI_METADATA , args -> firstblock , args -> total , & map , & nmap , args -> flist ) ; if ( ! error ) { error = xfs_bmap_finish ( & args -> trans , args -> flist , & committed ) ; } if ( error ) { ASSERT ( committed ) ; args -> trans = NULL ; xfs_bmap_cancel ( args -> flist ) ; return ( error ) ; } if ( committed ) xfs_trans_ijoin ( args -> trans , dp , 0 ) ; ASSERT ( nmap == 1 ) ; ASSERT ( ( map . br_startblock != DELAYSTARTBLOCK ) && ( map . br_startblock != HOLESTARTBLOCK )
",0,511
629,"static void _send ( Socket_T S , const char * request , StringBuffer_T data ) { _argument ( data , ""format"" , ""text"" ) ; char * _auth = _getBasicAuthHeader ( ) ; int rv = Socket_print ( S , ""POST%sHTTP/1.0\\r\\n"" ""Content-Type:application/x-www-form-urlencoded\\r\\n"" ""Content-Length:%d\\r\\n"" ""%s"" ""\\r\\n"" ""%s"" , request , StringBuffer_length ( data ) , _auth ? _auth : """" , StringBuffer_toString ( data ) ) ; FREE ( _auth ) ; if ( rv < 0 ) THROW ( IOException , ""Monit:cannotsendcommandtothemonitdaemon--%s"" , STRERROR ) ; }
",0,192
630,"static void copy_asoundrc ( void ) { char * src = RUN_ASOUNDRC_FILE ; char * dest ; if ( asprintf ( & dest , ""%s/.asoundrc"" , cfg . homedir ) == - 1 ) errExit ( ""asprintf"" ) ; if ( is_link ( dest ) ) { fprintf ( stderr , ""Error:%sisasymboliclink\\n"" , dest ) ; exit ( 1 ) ; } copy_file_as_user ( src , dest ) ; if ( rv ) fprintf ( stderr , ""Warning:cannottransfer.asoundrcinprivatehomedirectory\\n"" ) ; else { fs_logger2 ( ""clone"" , dest ) ; } _exit ( 0 ) ; } waitpid ( child , NULL , 0 ) ; if ( chown ( dest , getuid ( ) , getgid ( ) , S_IRUSR | S_IWUSR ) < 0 ) errExit ( ""chmod"" ) ; unlink ( src ) ; }
",1,234
631,"static struct fc_host_statistics * bfad_im_get_stats ( struct Scsi_Host * shost ) { struct bfad_im_port_s * im_port = ( struct bfad_im_port_s * ) shost -> hostdata [ 0 ] ; struct bfad_s * bfad = im_port -> bfad ; struct bfad_hal_comp fcomp ; union bfa_port_stats_u * fcstats ; struct fc_host_statistics * hstats ; bfa_status_t rc ; unsigned long flags ; fcstats = kzalloc ( sizeof ( union bfa_port_stats_u ) , GFP_KERNEL ) ; if ( fcstats == NULL ) return NULL ; hstats = & bfad -> link_stats ; init_completion ( & fcomp . comp ) ; spin_lock_irqsave ( & bfad -> bfad_lock , flags ) ; memset ( hstats , 0 , sizeof ( struct fc_host_statistics ) ) ; rc = bfa_port_get_stats ( BFA_FCPORT ( & bfad -> bfa ) , fcstats , bfad_hcb_comp , & fcomp ) ; spin_unlock_irqrestore ( & bfad -> bfad_lock , flags ) ; if ( rc != BFA_STATUS_OK ) return NULL ; wait_for_completion ( & fcomp . comp ) ; hstats -> seconds_since_last_reset = fcstats -> fc . secs_reset ; hstats -> tx_frames = fcstats -> fc . tx_frames ; hstats -> tx_words = fcstats -> fc . tx_words ; hstats -> rx_frames = fcstats -> fc . rx_frames ; hstats -> rx_words = fcstats -> fc . rx_words ; hstats -> lip_count = fcstats -> fc . lip_count ; hstats -> nos_count = fcstats -> fc . nos_count ; hstats -> error_frames = fcstats -> fc . error_frames ; hstats -> dumped_frames = fcstats -> fc . dropped_frames ;
",0,511
632,"static inline void VectorClamp3 ( DDSVector3 * value ) { value -> x = MinF ( 1.0f , MaxF ( 0.0f , value -> x ) ) ; value -> y = MinF ( 1.0f , MaxF ( 0.0f , value -> y ) ) ; value -> z = MinF ( 1.0f , MaxF ( 0.0f , value -> z ) ) ; }
",0,96
633,"int git_pkt_parse_line ( git_pkt * * head , const char * line , const char * * out , size_t bufflen ) { int ret ; int32_t len ; if ( bufflen > 0 && bufflen < PKT_LEN_SIZE ) return GIT_EBUFS ; len = parse_len ( line ) ; if ( len < 0 ) { if ( bufflen >= 4 && ! git__prefixcmp ( line , ""PACK"" ) ) { giterr_clear ( ) ; * out = line ; return pack_pkt ( head ) ; } return ( int ) len ; } if ( bufflen > 0 && bufflen < ( size_t ) len ) return GIT_EBUFS ; if ( len != 0 && len < PKT_LEN_SIZE ) return GIT_ERROR ; line += PKT_LEN_SIZE ; if ( len == PKT_LEN_SIZE ) { giterr_set_str ( GITERR_NET , ""Invalidemptypacket"" ) ; return GIT_ERROR ; } if ( len == 0 ) { * out = line ; return flush_pkt ( head ) ; } len -= PKT_LEN_SIZE ; if ( * line == GIT_SIDE_BAND_DATA ) ret = data_pkt ( head , line , len ) ; else if ( * line == GIT_SIDE_BAND_PROGRESS ) ret = sideband_progress_pkt ( head , line , len ) ; else if ( * line == GIT_SIDE_BAND_ERROR ) ret = sideband_error_pkt ( head , line , len ) ; else if ( ! git__prefixcmp ( line , ""ACK"" ) ) ret = ack_pkt ( head , line , len ) ; else if ( ! git__prefixcmp ( line , ""NAK"" ) ) ret = nak_pkt ( head ) ; else if ( ! git__prefixcmp ( line , ""ERR"" ) ) ret = err_pkt ( head , line , len ) ; else if ( * line == '#' ) ret = comment_pkt ( head , line , len ) ; else if ( ! git__prefixcmp ( line , ""ok"" ) ) ret = ok_pkt ( head ,
",0,511
634,"static int do_anonymous_page ( struct mm_struct * mm , struct vm_area_struct * vma , unsigned long address , pte_t * page_table , pmd_t * pmd , unsigned int flags ) { struct mem_cgroup * memcg ; struct page * page ; spinlock_t * ptl ; pte_t entry ; pte_unmap ( page_table ) ; if ( vma -> vm_flags & VM_SHARED ) return VM_FAULT_SIGBUS ; if ( check_stack_guard_page ( vma , address ) < 0 ) return VM_FAULT_SIGSEGV ; if ( ! ( flags & FAULT_FLAG_WRITE ) && ! mm_forbids_zeropage ( mm ) ) { entry = pte_mkspecial ( pfn_pte ( my_zero_pfn ( address ) , vma -> vm_page_prot ) ) ; page_table = pte_offset_map_lock ( mm , pmd , address , & ptl ) ; if ( ! pte_none ( * page_table ) ) goto unlock ; goto setpte ; } if ( unlikely ( anon_vma_prepare ( vma ) ) ) goto oom ; page = alloc_zeroed_user_highpage_movable ( vma , address ) ; if ( ! page ) goto oom ; if ( mem_cgroup_try_charge ( page , mm , GFP_KERNEL , & memcg ) ) goto oom_free_page ; __SetPageUptodate ( page ) ; entry = mk_pte ( page , vma -> vm_page_prot ) ; if ( vma -> vm_flags & VM_WRITE ) entry = pte_mkwrite ( pte_mkdirty ( entry ) ) ; page_table = pte_offset_map_lock ( mm , pmd , address , & ptl ) ; if ( ! pte_none ( * page_table ) ) goto release ; inc_mm_counter_fast ( mm , MM_ANONPAGES ) ; page_add_new_anon_rmap ( page , vma , address ) ; mem_cgroup_commit_charge ( page , memcg , false ) ; lru_cache
",0,511
635,"static void sig_server_connect_copy ( SERVER_CONNECT_REC * * dest , IRC_SERVER_CONNECT_REC * src ) { IRC_SERVER_CONNECT_REC * rec ; g_return_if_fail ( dest != NULL ) ; if ( ! IS_IRC_SERVER_CONNECT ( src ) ) return ; rec = g_new0 ( IRC_SERVER_CONNECT_REC , 1 ) ; rec -> chat_type = IRC_PROTOCOL ; rec -> max_cmds_at_once = src -> max_cmds_at_once ; rec -> cmd_queue_speed = src -> cmd_queue_speed ; rec -> max_query_chans = src -> max_query_chans ; rec -> max_kicks = src -> max_kicks ; rec -> max_modes = src -> max_modes ; rec -> max_msgs = src -> max_msgs ; rec -> max_whois = src -> max_whois ; rec -> usermode = g_strdup ( src -> usermode ) ; rec -> alternate_nick = g_strdup ( src -> alternate_nick ) ; rec -> sasl_mechanism = src -> sasl_mechanism ; rec -> sasl_username = g_strdup ( src -> alternate_nick ) ; rec -> sasl_password = src -> sasl_password ; * dest = ( SERVER_CONNECT_REC * ) rec ; }
",0,332
636,"static int adjust_insn_aux_data ( struct bpf_verifier_env * env , u32 prog_len , u32 off , u32 cnt ) { struct bpf_insn_aux_data * new_data , * old_data = env -> insn_aux_data ; if ( cnt == 1 ) return 0 ; new_data = vzalloc ( sizeof ( struct bpf_insn_aux_data ) * prog_len ) ; if ( ! new_data ) return - ENOMEM ; memcpy ( new_data , old_data , sizeof ( struct bpf_insn_aux_data ) * off ) ; memcpy ( new_data + off + cnt - 1 , old_data + off , sizeof ( struct bpf_insn_aux_data ) * ( prog_len - off - cnt + 1 ) ) ; if ( cnt == 1 ) return 0 ; env -> insn_aux_data = new_data ; vfree ( old_data ) ; return 0 ; }
",0,236
637,"int frag6_print ( netdissect_options * ndo , register const u_char * bp , register const u_char * bp2 ) { register const struct ip6_frag * dp ; register const struct ip6_hdr * ip6 ; dp = ( const struct ip6_frag * ) bp ; ip6 = ( const struct ip6_hdr * ) bp2 ; ND_TCHECK ( * dp ) ; if ( ndo -> ndo_vflag ) { ND_PRINT ( ( ndo , ""frag(0x%08x:%d|%ld)"" , EXTRACT_32BITS ( & dp -> ip6f_ident ) , EXTRACT_16BITS ( & dp -> ip6f_offlg ) & IP6F_OFF_MASK , sizeof ( struct ip6_hdr ) + EXTRACT_16BITS ( & ip6 -> ip6_plen ) - ( long ) ( bp - bp2 ) - sizeof ( struct ip6_frag ) ) ) ; } else { ND_PRINT ( ( ndo , ""frag(%d|%ld)"" , EXTRACT_16BITS ( & dp -> ip6f_offlg ) & IP6F_OFF_MASK , sizeof ( struct ip6_hdr ) + EXTRACT_16BITS ( & ip6 -> ip6_plen ) - ( long ) ( bp - bp2 ) - sizeof ( struct ip6_frag ) ) ) ; } if ( ( EXTRACT_16BITS ( & dp -> ip6f_offlg ) & IP6F_OFF_MASK ) != 0 ) return - 1 ; else { ND_PRINT ( ( ndo , """" ) ) ; return sizeof ( struct ip6_frag ) ; } trunc : ND_PRINT ( ( ndo , ""[|frag]"" ) ) ; return - 1 ; }
",1,441
638,"static int mobility_opt_print ( netdissect_options * ndo , const u_char * bp , const unsigned len ) { unsigned i , optlen ; for ( i = 0 ; i < len ; i += optlen ) { ND_TCHECK ( bp [ i ] ) ; if ( bp [ i ] == IP6MOPT_PAD1 ) optlen = 1 ; else { if ( i + 1 < len ) { ND_TCHECK ( bp [ i + 1 ] ) ; optlen = bp [ i + 1 ] + 2 ; } else goto trunc ; } ND_TCHECK_128BITS ( & bp [ i + 2 ] ) ; if ( i + optlen > len ) goto trunc ; ND_TCHECK ( bp [ i + optlen ] ) ; switch ( bp [ i ] ) { case IP6MOPT_PAD1 : ND_PRINT ( ( ndo , ""(pad1)"" ) ) ; break ; case IP6MOPT_PADN : if ( len - i < IP6MOPT_MINLEN ) { ND_PRINT ( ( ndo , ""(padn:trunc)"" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""(padn)"" ) ) ; break ; case IP6MOPT_REFRESH : if ( len - i < IP6MOPT_REFRESH_MINLEN ) { ND_PRINT ( ( ndo , ""(refresh:trunc)"" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""(refresh:%u)"" , EXTRACT_16BITS ( & bp [ i + 2 ] ) << 2 ) ) ; break ; case IP6MOPT_ALTCOA : if ( len - i < IP6MOPT_ALTCOA_MINLEN ) { ND_PRINT ( ( ndo , ""(altcoa:trunc)"" ) ) ; goto trunc ; } ND_PRINT ( ( ndo , ""(alt-CoA:%s)"" , ip6addr_string ( ndo , & bp [ i + 2 ] ) ) ) ; break ; case IP6MOPT_NONCEID : if ( len - i < IP6MOPT_NONCEID_MINLEN
",0,511
639,"static void update_alt_ref_frame_stats ( VP8_COMP * cpi ) { VP8_COMMON * cm = & cpi -> common ; if ( ! cpi -> auto_gold ) cpi -> frames_till_gf_update_due = DEFAULT_GF_INTERVAL ; if ( ( cpi -> pass != 2 ) && cpi -> frames_till_gf_update_due ) { cpi -> current_gf_interval = cpi -> frames_till_gf_update_due ; cpi -> gf_overspend_bits += cpi -> projected_frame_size ; cpi -> non_gf_bitrate_adjustment = cpi -> gf_overspend_bits / cpi -> frames_till_gf_update_due ; } memset ( cpi -> gf_active_flags , 1 , ( cm -> mb_rows * cm -> mb_cols ) ) ; cpi -> gf_active_count = cm -> mb_rows * cm -> mb_cols ; cpi -> frames_since_golden = 0 ; cpi -> source_alt_ref_pending = 0 ; cpi -> source_alt_ref_active = 1 ; }
",1,282
640,"static int PredictorDecodeTile ( TIFF * tif , uint8 * op0 , tmsize_t occ0 , uint16 s ) { TIFFPredictorState * sp = PredictorState ( tif ) ; assert ( sp != NULL ) ; assert ( sp -> decodetile != NULL ) ; if ( ( * sp -> decodetile ) ( tif , op0 , occ0 , s ) ) { tmsize_t rowsize = sp -> rowsize ; assert ( rowsize > 0 ) ; if ( ( occ0 % rowsize ) != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , ""PredictorDecodeTile"" , ""%s"" , ""(occ0%rowsize)!=0"" ) ; return 0 ; } assert ( sp -> decodepfunc != NULL ) ; while ( occ0 > 0 ) { ( * sp -> decodepfunc ) ( tif , op0 , rowsize ) ) return 0 ; occ0 -= rowsize ; op0 += rowsize ; } return 1 ; } else return 0 ; }
",0,237
641,"static void exif_mnote_data_canon_load ( ExifMnoteData * ne , const unsigned char * buf , unsigned int buf_size ) { ExifMnoteDataCanon * n = ( ExifMnoteDataCanon * ) ne ; ExifShort c ; size_t i , tcount , o , datao ; if ( CHECKOVERFLOW ( datao , buf_size , 2 ) ) { exif_log ( ne -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteCanon"" , ""ShortMakerNote"" ) ; return ; } datao = 6 + n -> offset ; if ( CHECKOVERFLOW ( datao , buf_size , 2 ) ) { exif_log ( ne -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteCanon"" , ""ShortMakerNote"" ) ; return ; } c = exif_get_short ( buf + datao , n -> order ) ; datao += 2 ; exif_mnote_data_canon_clear ( n ) ; n -> entries = exif_mem_alloc ( ne -> mem , sizeof ( MnoteCanonEntry ) * c ) ; if ( ! n -> entries ) { EXIF_LOG_NO_MEMORY ( ne -> log , ""ExifMnoteCanon"" , sizeof ( MnoteCanonEntry ) * c ) ; return ; } tcount = 0 ; for ( i = c , o = datao ; i ; -- i , o += 12 ) { size_t s ; memset ( & n -> entries [ tcount ] , 0 , sizeof ( MnoteCanonEntry ) ) ; if ( CHECKOVERFLOW ( o , buf_size , 12 ) ) { exif_log ( ne -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteCanon"" , ""ShortMakerNote"" ) ; break ; } n -> entries [ tcount ] . tag = exif_get_short ( buf + o , n -> order ) ; n -> entries [ tcount ] . format = exif_get_short ( buf + o + 2 , n -> order ) ; n -> entries [ tcount ] . components = exif_get_long
",0,511
642,"OM_uint32 kg_unseal_iov ( OM_uint32 * minor_status , gss_ctx_id_t context_handle , int * conf_state , gss_qop_t * qop_state , gss_iov_buffer_desc * iov , int iov_count , int toktype ) { krb5_gss_ctx_id_rec * ctx ; OM_uint32 code ; ctx = ( krb5_gss_ctx_id_rec * ) context_handle ; if ( ctx -> terminated || ! ctx -> established ) { * minor_status = KG_CTX_INCOMPLETE ; return GSS_S_NO_CONTEXT ; } if ( kg_locate_iov ( iov , iov_count , GSS_IOV_BUFFER_TYPE_STREAM ) != NULL ) { code = kg_unseal_stream_iov ( minor_status , ctx , conf_state , qop_state , iov , iov_count , toktype ) ; } else { code = kg_unseal_iov_token ( minor_status , ctx , conf_state , qop_state , iov , iov_count , toktype ) ; } return code ; }
",1,287
643,"static void hugetlbfs_put_super ( struct super_block * sb ) { struct hugetlbfs_sb_info * sbi = HUGETLBFS_SB ( sb ) ; if ( sbi ) { sb -> s_fs_info = NULL ; if ( sbi -> spool ) hugepage_put_subpool ( sbi -> spool ) ; kfree ( sbi ) ; } }
",1,95
644,"static int myisamchk ( MI_CHECK * param , char * filename ) { int error , lock_type , recreate ; int rep_quick = param -> testflag & ( T_QUICK | T_FORCE_UNIQUENESS ) ; MI_INFO * info ; File datafile ; char llbuff [ 22 ] , llbuff2 [ 22 ] ; my_bool state_updated = 0 ; MYISAM_SHARE * share ; DBUG_ENTER ( ""myisamchk"" ) ; param -> out_flag = error = param -> warning_printed = param -> error_printed = recreate = 0 ; datafile = 0 ; param -> isam_file_name = filename ; if ( ! ( info = mi_open ( filename , ( param -> testflag & ( T_DESCRIPT | T_READONLY ) ) ? O_RDONLY : O_RDWR , HA_OPEN_FOR_REPAIR | ( ( param -> testflag & T_WAIT_FOREVER ) ? HA_OPEN_WAIT_IF_LOCKED : ( param -> testflag & T_DESCRIPT ) ? HA_OPEN_IGNORE_IF_LOCKED : HA_OPEN_ABORT_IF_LOCKED ) ) ) ) { param -> error_printed = 1 ; switch ( my_errno ) { case HA_ERR_CRASHED : mi_check_print_error ( param , ""\'%s\'doesn\'thaveacorrectindexdefinition.Youneedtorecreateitbeforeyoucandoarepair"" , filename ) ; break ; case HA_ERR_NOT_A_TABLE : mi_check_print_error ( param , ""\'%s\'isnotaMyISAM-table"" , filename ) ; break ; case HA_ERR_CRASHED_ON_USAGE : mi_check_print_error ( param , ""\'%s\'ismarkedascrashed"" , filename ) ; break ; case HA_ERR_CRASHED_ON_REPAIR : mi_check_print_error ( param , ""\'%s\'ismarkedascrashedafterlastrepair"" , filename ) ; break ; case HA_ERR_OLD_FILE : mi_check_print_error ( param , ""\'%s\'isanoldtypeofMy
",0,511
645,"char * curl_easy_unescape ( CURL * handle , const char * string , int length , int * olen , char * curl_easy_unescape_options * options ) { int alloc = ( length ? length : ( int ) strlen ( string ) ) + 1 ; char * ns = malloc ( alloc ) ; unsigned char in ; int strindex = 0 ; unsigned long hex ; if ( ! ns ) return NULL ; while ( -- alloc > 0 ) { in = * string ; if ( ( '%' == in ) && ISXDIGIT ( string [ 1 ] ) && ISXDIGIT ( string [ 2 ] ) ) { char hexstr [ 3 ] ; char * ptr ; hexstr [ 0 ] = string [ 1 ] ; hexstr [ 1 ] = string [ 2 ] ; hexstr [ 2 ] = 0 ; hex = strtoul ( hexstr , & ptr , 16 ) ; in = curlx_ultouc ( hex ) ; if ( res ) { free ( ns ) ; return NULL ; } string += 2 ; alloc -= 2 ; } ns [ strindex ++ ] = in ; string ++ ; } ns [ strindex ] = 0 ; if ( olen ) * olen = strindex ; return ns ; }
",0,270
646,"INST_HANDLER ( cpse ) { int r = ( buf [ 0 ] & 0xf ) | ( ( buf [ 1 ] & 0x2 ) << 3 ) ; int d = ( ( buf [ 0 ] >> 4 ) & 0xf ) | ( ( buf [ 1 ] & 0x1 ) << 4 ) ; RAnalOp next_op = { 0 } ; avr_op_analyze ( anal , & next_op , op -> addr + op -> size , buf + op -> size , len - op -> size , cpu ) ; r_strbuf_fini ( & next_op . esil ) ; op -> jump = op -> addr + next_op . size + 2 ; op -> cycles = 1 ; ESIL_A ( ""r%d,r%d,^,
",0,176
647,"static ssize_t generic_perform_write ( struct file * file , struct iov_iter * i , loff_t pos ) { struct address_space * mapping = file -> f_mapping ; const struct address_space_operations * a_ops = mapping -> a_ops ; long status = 0 ; ssize_t written = 0 ; unsigned int flags = 0 ; if ( segment_eq ( get_fs ( ) , KERNEL_DS ) ) flags |= AOP_FLAG_UNINTERRUPTIBLE ; do { struct page * page ; pgoff_t index ; unsigned long offset ; unsigned long bytes ; size_t copied ; void * fsdata ; offset = ( pos & ( PAGE_CACHE_SIZE - 1 ) ) ; index = pos >> PAGE_CACHE_SHIFT ; bytes = min_t ( unsigned long , PAGE_CACHE_SIZE - offset , iov_iter_count ( i ) ) ; again : if ( unlikely ( iov_iter_fault_in_readable ( i , bytes ) ) ) { status = - EFAULT ; break ; } status = a_ops -> write_begin ( file , mapping , pos , bytes , flags , & page , & fsdata ) ; if ( unlikely ( status ) ) break ; pagefault_disable ( ) ; iov_iter_advance ( i , copied ) ; copied = iov_iter_copy_from_user_atomic ( page , i , offset , bytes ) ; pagefault_enable ( ) ; flush_dcache_page ( page ) ; status = a_ops -> write_end ( file , mapping , pos , bytes , copied , page , fsdata ) ; if ( unlikely ( status < 0 ) ) break ; copied = status ; cond_resched ( ) ; if ( unlikely ( copied == 0 ) ) { bytes = min_t ( unsigned long , PAGE_CACHE_SIZE - offset , iov_iter_single_seg_count ( i ) ) ; goto again ; } pos += copied ; written += copied ; balance_dirty_pages_ratelimited ( mapping ) ; } while ( iov_iter_count ( i ) ) ; return written ? written : status ; }
",1,485
648,"static void dma_rx ( struct b43_dmaring * ring , int * slot ) { const struct b43_dma_ops * ops = ring -> ops ; struct b43_dmadesc_generic * desc ; struct b43_dmadesc_meta * meta ; struct b43_rxhdr_fw4 * rxhdr ; struct sk_buff * skb ; u16 len ; int err ; dma_addr_t dmaaddr ; desc = ops -> idx2desc ( ring , * slot , & meta ) ; sync_descbuffer_for_cpu ( ring , meta -> dmaaddr , ring -> rx_buffersize ) ; skb = meta -> skb ; rxhdr = ( struct b43_rxhdr_fw4 * ) skb -> data ; len = le16_to_cpu ( rxhdr -> frame_len ) ; if ( len == 0 ) { int i = 0 ; do { udelay ( 2 ) ; barrier ( ) ; len = le16_to_cpu ( rxhdr -> frame_len ) ; } while ( len == 0 && i ++ < 5 ) ; if ( unlikely ( len == 0 ) ) { dmaaddr = meta -> dmaaddr ; goto drop_recycle_buffer ; } } if ( unlikely ( b43_rx_buffer_is_poisoned ( ring , skb ) ) ) { b43dbg ( ring -> dev -> wl , ""DMARX:Droppingpoisonedbuffer.\\n"" ) ; dmaaddr = meta -> dmaaddr ; goto drop_recycle_buffer ; } if ( unlikely ( len > ring -> rx_buffersize ) ) { int cnt = 0 ; s32 tmp = len ; while ( 1 ) { desc = ops -> idx2desc ( ring , * slot , & meta ) ; b43_poison_rx_buffer ( ring , meta -> skb ) ; sync_descbuffer_for_device ( ring , meta -> dmaaddr , ring -> rx_buffersize ) ; * slot = next_slot ( ring , * slot ) ; cnt ++ ; tmp -= ring -> rx_buffersize ; if ( tmp <= 0 ) break ; } b43err ( ring -> dev -> wl , ""DMARXbuffertoosm
",0,510
649,"void init_usm ( void ) { struct snmp_secmod_def * def ; char * type ; DEBUGMSGTL ( ( ""init_usm"" , ""unit_usm:%"" NETSNMP_PRIo ""u%"" NETSNMP_PRIo ""u\\n"" , usmNoPrivProtocol [ 0 ] , usmNoPrivProtocol [ 1 ] ) ) ; sc_init ( ) ; def = SNMP_MALLOC_STRUCT ( snmp_secmod_def ) ; if ( def == NULL ) return ; def -> encode_reverse = usm_secmod_rgenerate_out_msg ; def -> encode_forward = usm_secmod_generate_out_msg ; def -> decode = usm_secmod_process_in_msg ; def -> pdu_free_state_ref = usm_free_usmStateReference ; def -> session_setup = usm_session_init ; def -> handle_report = usm_handle_report ; def -> probe_engineid = usm_discover_engineid ; def -> post_probe_engineid = usm_create_user_from_session_hook ; if ( register_sec_mod ( USM_SEC_MODEL_NUMBER , ""usm"" , def ) != SNMPERR_SUCCESS ) { SNMP_FREE ( def ) ; snmp_log ( LOG_ERR , ""couldnotregisterusmsecmod\\n"" ) ; return ; } snmp_register_callback ( SNMP_CALLBACK_LIBRARY , SNMP_CALLBACK_POST_PREMIB_READ_CONFIG , init_usm_post_config , NULL ) ; snmp_register_callback ( SNMP_CALLBACK_LIBRARY , SNMP_CALLBACK_SHUTDOWN , deinit_usm_post_config , NULL ) ; snmp_register_callback ( SNMP_CALLBACK_LIBRARY , SNMP_CALLBACK_SHUTDOWN , free_engineID , NULL ) ; register_config_handler ( ""snmp"" , ""defAuthType"" , snmpv3_authtype_conf , NULL , ""MD5|SHA|SHA-512|SHA-384|SHA-256|\\
",0,511
650,"void traverse_commit_list ( struct rev_info * revs , show_commit_fn show_commit , show_object_fn show_object , void * data ) { int i ; struct commit * commit ; struct strbuf base ; strbuf_init ( & base , PATH_MAX ) ; while ( ( commit = get_revision ( revs ) ) != NULL ) { if ( commit -> tree ) add_pending_tree ( revs , commit -> tree ) ; show_commit ( commit , data ) ; } for ( i = 0 ; i < revs -> pending . nr ; i ++ ) { struct object_array_entry * pending = revs -> pending . objects + i ; struct object * obj = pending -> item ; const char * name = pending -> name ; const char * path = pending -> path ; if ( obj -> flags & ( UNINTERESTING | SEEN ) ) continue ; if ( obj -> type == OBJ_TAG ) { obj -> flags |= SEEN ; show_object ( obj , name , data ) ; continue ; } if ( ! path ) path = """" ; if ( obj -> type == OBJ_TREE ) { process_tree ( revs , ( struct tree * ) obj , show_object , & base , path , data ) ; continue ; } if ( obj -> type == OBJ_BLOB ) { process_blob ( revs , ( struct blob * ) obj , show_object , NULL , path , data ) ; continue ; } die ( ""unknownpendingobject%s(%s)"" , oid_to_hex ( & obj -> oid ) , name ) ; } object_array_clear ( & revs -> pending ) ; strbuf_release ( & base ) ; }
",1,379
651,"int regexec ( Reprog * prog , const char * sp , Resub * sub , int eflags ) { Resub scratch ; int i ; if ( ! sub ) sub = & scratch ; sub -> nsub = prog -> nsub ; for ( i = 0 ; i < MAXSUB ; ++ i ) sub -> sub [ i ] . sp = sub -> sub [ i ] . ep = NULL ; return match ( prog -> start , sp , sp , prog -> flags | eflags , sub ) ; }
",0,109
652,"static int kempf_decode_tile ( G2MContext * c , int tile_x , int tile_y , const uint8_t * src , int src_size ) { int width , height ; int hdr , zsize , npal , tidx = - 1 , ret ; int i , j ; const uint8_t * src_end = src + src_size ; uint8_t pal [ 768 ] , transp [ 3 ] ; uLongf dlen = ( c -> tile_width + 1 ) * c -> tile_height ; int sub_type ; int nblocks , cblocks , bstride ; int bits , bitbuf , coded ; uint8_t * dst = c -> framebuf + tile_x * c -> tile_width * 3 + tile_y * c -> tile_height * c -> framebuf_stride ; if ( src_size < 2 ) return AVERROR_INVALIDDATA ; width = FFMIN ( c -> width - tile_x * c -> tile_width , c -> tile_width ) ; height = FFMIN ( c -> height - tile_y * c -> tile_height , c -> tile_height ) ; hdr = * src ++ ; sub_type = hdr >> 5 ; if ( sub_type == 0 ) { int j ; memcpy ( transp , src , 3 ) ; src += 3 ; for ( j = 0 ; j < height ; j ++ , dst += c -> framebuf_stride ) for ( i = 0 ; i < width ; i ++ ) memcpy ( dst + i * 3 , transp , 3 ) ; return 0 ; } else if ( sub_type == 1 ) { return jpg_decode_data ( & c -> jc , width , height , src , src_end - src , dst , c -> framebuf_stride , NULL , 0 , 0 , 0 ) ; } if ( sub_type != 2 ) { memcpy ( transp , src , 3 ) ; src += 3 ; } npal = * src ++ + 1 ; memcpy ( pal , src , npal * 3 ) ; src += npal * 3 ; if ( sub_type != 2 ) { for ( i = 0 ; i < npal ; i ++ ) { if ( ! memcmp ( pal + i * 3 , transp
",0,511
653,"static void unqueue_me_pi ( struct futex_q * q ) { WARN_ON ( plist_node_empty ( & q -> list ) ) ; plist_del ( & q -> list , & q -> list . plist ) ; BUG_ON ( ! q -> pi_state ) ; free_pi_state ( q -> pi_state ) ; q -> pi_state = NULL ; spin_unlock ( q -> lock_ptr ) ; }
",1,103
654,"int fixExec2Error ( int action , u_char * var_val , u_char var_val_type , size_t var_val_len , u_char * statP , oid * name , size_t name_len ) { netsnmp_old_extend * exten = NULL ; unsigned int idx ; idx = name [ name_len - 1 ] - 1 ; exten = & compatability_entries [ idx ] ; if ( var_val_type != ASN_INTEGER ) { snmp_log ( LOG_ERR , ""Wrongtype
",0,133
655,"static ssize_t DecodePSDPixels ( const size_t number_compact_pixels , const unsigned char * compact_pixels , const ssize_t depth , const size_t number_pixels , unsigned char * pixels ) { # define CheckNumberCompactPixels if ( packets == 0 ) return ( i ) ; packets -- # define CheckNumberPixels ( count ) if ( ( ( ssize_t ) i + count ) > ( ssize_t ) number_pixels ) return ( i ) ; i += count int pixel ; register ssize_t i , j ; size_t length ; ssize_t packets ; packets = ( ssize_t ) number_compact_pixels ; for ( i = 0 ; ( packets > 1 ) && ( i < ( ssize_t ) number_pixels ) ; ) { packets -- ; length = ( size_t ) ( * compact_pixels ++ ) ; if ( length == 128 ) continue ; if ( length > 128 ) { length = 256 - length + 1 ; CheckNumberCompactPixels ; pixel = ( * compact_pixels ++ ) ; for ( j = 0 ; j < ( ssize_t ) length ; j ++ ) { switch ( depth ) { case 1 : { CheckNumberPixels ( 8 ) ; * pixels ++ = ( pixel >> 7 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( pixel >> 6 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( pixel >> 5 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( pixel >> 4 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( pixel >> 3 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( pixel >> 2 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( pixel >> 1 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( pixel >> 0 ) & 0x01 ? 0U : 255U ; break ; } case 2 : { CheckNumberPixels ( 4 ) ; * pixels ++ = ( unsigned char ) ( ( pixel >> 6 ) & 0x03 ) ; * pixels ++ = ( unsigned char ) ( ( pixel >> 4 ) & 0x03 ) ; * pixels ++ = ( unsigned char ) ( ( pixel >> 2
",0,511
656,"int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_
",0,511
657,"static int print_ccp_config_options ( netdissect_options * ndo , const u_char * p , int length ) { int len , opt ; if ( length < 2 ) return 0 ; ND_TCHECK2 ( * p , 2 ) ; len = p [ 1 ] ; opt = p [ 0 ] ; if ( length < len ) return 0 ; if ( len < 2 ) { ND_PRINT ( ( ndo , ""\\n\\t%sOption(0x%02x),length%u(lengthbogus,shouldbe>=2)"" , tok2str ( ccpconfopts_values , ""Unknown"" , opt ) , opt , len ) ) ; return 0 ; } ND_PRINT ( ( ndo , ""\\n\\t%sOption(0x%02x),length%u"" , tok2str ( ccpconfopts_values , ""Unknown"" , opt ) , opt , len ) ) ; switch ( opt ) { case CCPOPT_BSDCOMP : if ( len < 3 ) { ND_PRINT ( ( ndo , ""(lengthbogus,shouldbe>=3)"" ) ) ; return len ; } ND_TCHECK ( p [ 2 ] ) ; ND_PRINT ( ( ndo , "":Version:%u,DictionaryBits:%u"" , p [ 2 ] >> 5 , p [ 2 ] & 0x1f ) ) ; break ; case CCPOPT_MVRCA : if ( len < 4 ) { ND_PRINT ( ( ndo , ""(lengthbogus,shouldbe>=4)"" ) ) ; return len ; } ND_TCHECK ( p + 2 ) , 1 ) ; ND_PRINT ( ( ndo , "":Features:%u,PxP:%s,History:%u,#CTX-ID:%u"" , ( p [ 2 ] & 0xc0 ) >> 6 , ( p [ 2 ] & 0x20 ) ? ""Enabled"" : ""Disabled"" , p [ 2 ] & 0x1f , p [ 3 ] ) ) ; break ; case CCPOPT_DEFLATE : if ( len < 4 ) { ND_PRINT ( ( ndo , ""(lengthbogus,shouldbe>=4)"" ) ) ; return len ;
",0,511
658,"R_API int r_core_bin_set_env ( RCore * r , RBinFile * binfile ) { RBinObject * binobj = binfile ? binfile -> o : NULL ; RBinInfo * info = binobj ? binobj -> info : NULL ; if ( info ) { int va = info -> has_va ; char * arch = info -> arch ; ut16 bits = info -> bits ; ut64 baseaddr = r_bin_get_baddr ( r -> bin ) ; r_config_set_i ( r -> config , ""io.va"" , ( binobj -> info ) ? binobj -> info -> has_va : 0 ) ; r_config_set_i ( r -> config , ""bin.baddr"" , baseaddr ) ; r_config_set ( r -> config , ""asm.arch"" , arch ) ; r_config_set_i ( r -> config , ""asm.bits"" , bits ) ; r_config_set ( r -> config , ""anal.arch"" , arch ) ; if ( cpu && * info -> cpu ) { r_config_set ( r -> config , ""anal.cpu"" , cpu ) ; } else { r_config_set ( r -> config , ""anal.cpu"" , arch ) ; } r_asm_use ( r -> assembler , arch ) ; r_core_bin_info ( r , R_CORE_BIN_ACC_ALL , R_CORE_BIN_SET , va , NULL , NULL ) ; r_core_bin_set_cur ( r , binfile ) ; free ( cpu ) ; free ( arch ) ; return true ; } return false ; }
",1,371
659,"static void sas_probe_devices ( struct asd_sas_port * port ) { struct domain_device * dev , * n ; list_for_each_entry ( dev , & port -> disco_list , disco_list_node ) { spin_lock_irq ( & port -> dev_list_lock ) ; list_add_tail ( & dev -> dev_list_node , & port -> dev_list ) ; spin_unlock_irq ( & port -> dev_list_lock ) ; } sas_probe_sata ( port ) ; list_for_each_entry_safe ( dev , n , & port -> disco_list , disco_list_node ) { int err ; err = sas_rphy_add ( dev -> rphy ) ; if ( err ) sas_fail_probe ( dev , __func__ , err ) ; else list_del_init ( & dev -> disco_list_node ) ; } }
",1,215
660,"WORD32 ih264d_parse_islice ( dec_struct_t * ps_dec , UWORD16 u2_first_mb_in_slice ) { dec_pic_params_t * ps_pps = ps_dec -> ps_cur_pps ; dec_slice_params_t * ps_slice = ps_dec -> ps_cur_slice ; UWORD32 * pu4_bitstrm_buf = ps_dec -> ps_bitstrm -> pu4_buffer ; UWORD32 * pu4_bitstrm_ofst = & ps_dec -> ps_bitstrm -> u4_ofst ; UWORD32 u4_temp ; WORD32 i_temp ; WORD32 ret ; if ( ps_slice -> u1_nal_ref_idc != 0 ) { if ( ! ps_dec -> ps_dpb_cmds -> u1_dpb_commands_read && ps_dec -> u4_bitoffset != ih264d_read_mmco_commands ( ps_dec ) ; else ps_dec -> ps_bitstrm -> u4_ofst += ps_dec -> u4_bitoffset ; } i_temp = ps_pps -> u1_pic_init_qp + ih264d_sev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; if ( ( i_temp < 0 ) || ( i_temp > 51 ) ) return ERROR_INV_RANGE_QP_T ; ps_slice -> u1_slice_qp = i_temp ; COPYTHECONTEXT ( ""SH:slice_qp_delta"" , ps_slice -> u1_slice_qp - ps_pps -> u1_pic_init_qp ) ; if ( ps_pps -> u1_deblocking_filter_parameters_present_flag == 1 ) { u4_temp = ih264d_uev ( pu4_bitstrm_ofst , pu4_bitstrm_buf ) ; COPYTHECONTEXT ( ""SH:disable_deblocking_filter_idc"" , u4_temp ) ; if ( u4_temp > SLICE_BOUNDARY_DBLK_DISABLED ) return
",0,511
661,"static gboolean netscreen_read ( wtap * wth , int * err , gchar * * err_info , gint64 * data_offset ) { gint64 offset ; char line [ NETSCREEN_LINE_LENGTH ] ; char cap_int [ NETSCREEN_MAX_INT_NAME_LENGTH ] ; gboolean cap_dir ; char cap_dst [ 13 ] ; offset = netscreen_seek_next_packet ( wth , err , err_info , line ) ; if ( offset < 0 ) return FALSE ; line = parse_netscreen_packet ( wth , line , cap_int , & cap_dir , cap_dst , err , err_info ) ; if ( line == - 1 ) return FALSE ; if ( ! parse_netscreen_hex_dump ( wth -> fh , pkt_len , cap_int , cap_dst , & wth -> phdr , wth -> frame_buffer , line , err , err_info ) ) return FALSE ; if ( wth -> file_encap == WTAP_ENCAP_UNKNOWN ) wth -> file_encap = wth -> phdr . pkt_encap ; else { if ( wth -> file_encap != wth -> phdr . pkt_encap ) wth -> file_encap = WTAP_ENCAP_PER_PACKET ; } * data_offset = offset ; return TRUE ; }
",0,324
662,"static int dtls1_process_buffered_records ( SSL * s ) { pitem * item ; item = pqueue_peek ( s -> d1 -> unprocessed_rcds . q ) ; if ( item ) { if ( s -> d1 -> unprocessed_rcds . epoch != s -> d1 -> r_epoch ) return ( 1 ) ; while ( pqueue_peek ( s -> d1 -> unprocessed_rcds . q ) ) { dtls1_get_unprocessed_record ( s ) ; if ( ! dtls1_process_record ( s ) ) return ( 0 ) ; } } s -> d1 -> processed_rcds . epoch = s -> d1 -> r_epoch ; s -> d1 -> unprocessed_rcds . epoch = s -> d1 -> r_epoch + 1 ; return ( 1 ) ; }
",0,201
663,"void DDGifSlurp ( GifInfo * info , bool decode , bool exitAfterFrame ) { GifRecordType RecordType ; GifByteType * ExtData ; int ExtFunction ; GifFileType * gifFilePtr ; gifFilePtr = info -> gifFilePtr ; uint_fast32_t lastAllocatedGCBIndex = 0 ; do { if ( DGifGetRecordType ( gifFilePtr , & RecordType ) == GIF_ERROR ) { break ; } bool isInitialPass = ! decode && ! exitAfterFrame ; switch ( RecordType ) { case IMAGE_DESC_RECORD_TYPE : if ( DGifGetImageDesc ( gifFilePtr , isInitialPass ) == GIF_ERROR ) { break ; } if ( isInitialPass ) { int_fast32_t widthOverflow = gifFilePtr -> Image . Width - gifFilePtr -> SWidth ; int_fast32_t heightOverflow = gifFilePtr -> Image . Height - gifFilePtr -> SHeight ; if ( widthOverflow > 0 || heightOverflow > 0 ) { gifFilePtr -> SWidth += widthOverflow ; gifFilePtr -> SHeight += heightOverflow ; } SavedImage * sp = & gifFilePtr -> SavedImages [ gifFilePtr -> ImageCount - 1 ] ; int_fast32_t topOverflow = gifFilePtr -> Image . Top + gifFilePtr -> Image . Height - gifFilePtr -> SHeight ; if ( topOverflow > 0 ) { sp -> ImageDesc . Top -= topOverflow ; } int_fast32_t leftOverflow = gifFilePtr -> Image . Left + gifFilePtr -> Image . Width - gifFilePtr -> SWidth ; if ( leftOverflow > 0 ) { sp -> ImageDesc . Left -= leftOverflow ; } if ( ! updateGCB ( info , & lastAllocatedGCBIndex ) ) { break ; } } if ( decode ) { int_fast32_t widthOverflow = gifFilePtr -> Image . Width - info -> originalWidth ; int_fast32_t heightOverflow = gifFilePtr -> Image . Height - info -> originalHeight ; const uint_fast32_t newRasterSize = gifFilePtr -> Image . Width * gifFilePtr -> Image . Height ; if ( newRasterSize > info -> rasterSize || widthOverflow > height )
",0,511
664,"long keyctl_read_key ( key_serial_t keyid , char __user * buffer , size_t buflen ) { struct key * key ; key_ref_t key_ref ; long ret ; key_ref = lookup_user_key ( keyid , 0 , 0 ) ; if ( IS_ERR ( key_ref ) ) { ret = - ENOKEY ; goto error ; } key = key_ref_to_ptr ( key_ref ) ; ret = key_permission ( key_ref , KEY_NEED_READ ) ; if ( ret == 0 ) ret = key -> type -> read ) { down_read ( & key -> sem ) ; ret = key -> type -> read ( key , buffer , buflen ) ; up_read ( & key -> sem ) ; } } error2 : key_put ( key ) ; error : return ret ; }
",0,194
665,"ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || cherokee_buffer_is_empty ( & conn -> validator -> user , 0 ) ) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtreesearch(%s):done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error
",0,511
666,"static Image * ReadPICTImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define ThrowPICTException ( exception , message ) \\\n{ if ( tile_image != ( Image * ) NULL ) tile_image = DestroyImage ( tile_image ) ; if ( read_info != ( ImageInfo * ) NULL ) read_info = DestroyImageInfo ( read_info ) ; ThrowReaderException ( ( exception ) , ( message ) ) ; \\\n} char geometry [ MagickPathExtent ] , header_ole [ 4 ] ; Image * image , * tile_image ; ImageInfo * read_info ; int c , code ; MagickBooleanType jpeg , status ; PICTRectangle frame ; PICTPixmap pixmap ; Quantum index ; register Quantum * q ; register ssize_t i , x ; size_t extent , length ; ssize_t count , flags , j , version , y ; StringInfo * profile ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } read_info = ( ImageInfo * ) NULL ; tile_image = ( Image * ) NULL ; pixmap . bits_per_pixel = 0 ; pixmap . component_count = 0 ; header_ole [ 0 ] = ReadBlobByte ( image ) ; header_ole [ 1 ] = ReadBlobByte ( image ) ; header_ole [ 2 ] = ReadBlobByte ( image ) ; header_ole [ 3 ] = ReadBlobByte ( image ) ; if ( ! ( ( header_ole [ 0 ] == 0x50 ) && ( header_ole [ 1 ] == 0x49 ) && ( header_ole [ 2 ]
",0,511
667,"static int jas_iccgetsint32 ( jas_stream_t * in , jas_iccsint32_t * val ) { jas_ulonglong tmp ; if ( jas_iccgetuint ( in , 4 , & tmp ) ) return - 1 ; * val = ( tmp & 0x80000000 ) ? ( - JAS_CAST ( jas_longlong , ( ( ( ~ tmp ) & 0x7fffffff ) + 1 ) ) ) : JAS_CAST ( jas_longlong , tmp ) ; return 0 ; }
",1,124
668,"int rds_cmsg_atomic ( struct rds_sock * rs , struct rds_message * rm , struct cmsghdr * cmsg ) { struct page * page = NULL ; struct rds_atomic_args * args ; int ret = 0 ; if ( cmsg -> cmsg_len < CMSG_LEN ( sizeof ( struct rds_atomic_args ) ) || rm -> atomic . op_active ) return - EINVAL ; args = CMSG_DATA ( cmsg ) ; switch ( cmsg -> cmsg_type ) { case RDS_CMSG_ATOMIC_FADD : rm -> atomic . op_type = RDS_ATOMIC_TYPE_FADD ; rm -> atomic . op_m_fadd . add = args -> fadd . add ; rm -> atomic . op_m_fadd . nocarry_mask = 0 ; break ; case RDS_CMSG_MASKED_ATOMIC_FADD : rm -> atomic . op_type = RDS_ATOMIC_TYPE_FADD ; rm -> atomic . op_m_fadd . add = args -> m_fadd . add ; rm -> atomic . op_m_fadd . nocarry_mask = args -> m_fadd . nocarry_mask ; break ; case RDS_CMSG_ATOMIC_CSWP : rm -> atomic . op_type = RDS_ATOMIC_TYPE_CSWP ; rm -> atomic . op_m_cswp . compare = args -> cswp . compare ; rm -> atomic . op_m_cswp . swap = args -> cswp . swap ; rm -> atomic . op_m_cswp . compare_mask = ~ 0 ; rm -> atomic . op_m_cswp . swap_mask = ~ 0 ; break ; case RDS_CMSG_MASKED_ATOMIC_CSWP : rm -> atomic . op_type = RDS_ATOMIC_TYPE_CSWP ; rm -> atomic . op_m_cswp . compare = args -> m_cswp . compare ; rm -> atomic . op_m_cswp . swap = args -> m_cswp . swap ; rm -> atomic . op_m_cswp . compare
",0,511
669,"void pci_lintr_release ( struct pci_vdev * dev ) { struct businfo * bi ; struct slotinfo * si ; int pin ; bi = pci_businfo [ dev -> bus ] ; if ( bi == NULL ) return ; si = & bi -> slotinfo [ dev -> slot ] ; for ( pin = 1 ; pin < 4 ; pin ++ ) { si -> si_intpins [ pin ] . ii_count = 0 ; si -> si_intpins [ pin ] . ii_pirq_pin = 0 ; si -> si_intpins [ pin ] . ii_ioapic_irq = 0 ; } }
",0,139
670,"int rds_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t size , int msg_flags ) { struct sock * sk = sock -> sk ; struct rds_sock * rs = rds_sk_to_rs ( sk ) ; long timeo ; int ret = 0 , nonblock = msg_flags & MSG_DONTWAIT ; struct sockaddr_in * sin ; struct rds_incoming * inc = NULL ; timeo = sock_rcvtimeo ( sk , nonblock ) ; rdsdebug ( ""size%zuflags0x%xtimeo%ld\\n"" , size , msg_flags , timeo ) ; msg -> msg_namelen = 0 ; if ( msg_flags & MSG_OOB ) goto out ; while ( 1 ) { if ( ! list_empty ( & rs -> rs_notify_queue ) ) { ret = rds_notify_queue_get ( rs , msg ) ; break ; } if ( rs -> rs_cong_notify ) { ret = rds_notify_cong ( rs , msg ) ; break ; } if ( ! rds_next_incoming ( rs , & inc ) ) { if ( nonblock ) { ret = - EAGAIN ; break ; } timeo = wait_event_interruptible_timeout ( * sk_sleep ( sk ) , ( ! list_empty ( & rs -> rs_notify_queue ) || rs -> rs_cong_notify || rds_next_incoming ( rs , & inc ) ) , timeo ) ; rdsdebug ( ""recvmsgwokeinc%ptimeo%ld\\n"" , inc , timeo ) ; if ( timeo > 0 || timeo == MAX_SCHEDULE_TIMEOUT ) continue ; ret = timeo ; if ( ret == 0 ) ret = - ETIMEDOUT ; break ; } rdsdebug ( ""copyinginc%pfrom%pI4:%utouser\\n"" , inc , & inc -> i_conn -> c_faddr , ntohs ( inc -> i_hdr . h_sport ) ) ; ret = inc -> i_conn -> c_trans -> inc_copy_to_user ( inc , msg -> msg_cons
",0,511
671,"int set_interface_var ( const char * iface , const char * var , const char * name , uint32_t val ) { FILE * fp ; char spath [ 64 + IFNAMSIZ ] ; if ( snprintf ( spath , sizeof ( spath ) ) ) return - 1 ; if ( strstr ( name , "".."" ) || strchr ( name , '/' ) , var , iface ) >= sizeof ( spath ) ) return - 1 ; if ( access ( spath , F_OK ) != 0 ) return - 1 ; fp = fopen ( spath , ""w"" ) ; if ( ! fp ) { if ( name ) flog ( LOG_ERR , ""failedtoset%s(%u)for%s:%s"" , name , val , iface , strerror ( errno ) ) ; return - 1 ; } fprintf ( fp , ""%u"" , val ) ; fclose ( fp ) ; return 0 ; }
",0,221
672,"static void t1mac_output_ascii ( char * s , int len ) { if ( blocktyp == POST_BINARY ) { output_current_post ( ) ; blocktyp = POST_ASCII ; } if ( len > 0 && s [ len - 1 ] == '\\n' ) s [ len - 1 ] = '\\r' ; t1mac_output_data ( ( byte * ) s , len ) ; if ( strncmp ( s , ""/FontName"" , 9 ) == 0 ) { for ( s += 9 ; isspace ( * s ) ; s ++ ) ; if ( * s == '/' ) { const char * t = ++ s ; while ( * t && ! isspace ( * t ) ) t ++ ; free ( font_name ) ; font_name = ( char * ) malloc ( t - s + 1 ) ; memcpy ( font_name , s , t - s ) ; font_name [ t - s ] = 0 ; } } }
",0,220
673,"static int pop_sync_mailbox ( struct Context * ctx , int * index_hint ) { int i , j , ret = 0 ; char buf [ LONG_STRING ] ; struct PopData * pop_data = ( struct PopData * ) ctx -> data ; struct Progress progress ; # ifdef USE_HCACHE header_cache_t * hc = NULL ; # endif pop_data -> check_time = 0 ; while ( true ) { if ( pop_reconnect ( ctx ) < 0 ) return - 1 ; mutt_progress_init ( & progress , _ ( ""Markingmessagesdeleted..."" ) , MUTT_PROGRESS_MSG , WriteInc , ctx -> deleted ) ; # ifdef USE_HCACHE hc = pop_hcache_open ( pop_data , ctx -> path ) ; # endif for ( i = 0 , j = 0 , ret = 0 ; ret == 0 && i < ctx -> msgcount ; i ++ ) { if ( ctx -> hdrs [ i ] -> deleted && ctx -> hdrs [ i ] -> refno != - 1 ) { j ++ ; if ( ! ctx -> quiet ) mutt_progress_update ( & progress , j , - 1 ) ; snprintf ( buf , sizeof ( buf ) , ""DELE%d\\r\\n"" , ctx -> hdrs [ i ] -> refno ) ; ret = pop_query ( pop_data , buf , sizeof ( buf ) ) ; if ( ret == 0 ) { mutt_bcache_del ( pop_data -> bcache , cache_id ( ctx -> hdrs [ i ] -> data ) ) ; # ifdef USE_HCACHE mutt_hcache_delete ( hc , cache_id ( ctx -> hdrs [ i ] -> data , strlen ( ctx -> hdrs [ i ] -> data ) ) ) ; # endif } } # ifdef USE_HCACHE if ( ctx -> hdrs [ i ] -> changed ) { mutt_hcache_store ( hc , ctx -> hdrs [ i ] -> data , strlen ( ctx -> hdrs [ i ] -> data ) , ctx -> hdrs [ i ] , 0 ) ; } # endif } # ifdef USE
",0,511
674,"bool_t xdr_krb5_principal ( XDR * xdrs , krb5_principal * objp ) { int ret ; char * p = NULL ; krb5_principal pr = NULL ; static krb5_context context = NULL ; if ( ! context && kadm5_init_krb5_context ( & context ) ) return ( FALSE ) ; switch ( xdrs -> x_op ) { case XDR_ENCODE : if ( * objp ) { if ( ( ret = krb5_unparse_name ( context , * objp , & p ) ) != 0 ) return FALSE ; } if ( ! xdr_nullstring ( xdrs , & p ) ) return FALSE ; if ( p ) free ( p ) ; break ; case XDR_DECODE : if ( ! xdr_nullstring ( xdrs , & p ) ) return FALSE ; if ( p ) { ret = krb5_parse_name ( context , p , & pr ) ; if ( ret != 0 ) return FALSE ; * objp = pr ; free ( p ) ; } else * objp = NULL ; break ; case XDR_FREE : if ( * objp != NULL ) krb5_free_principal ( context , * objp ) ; if ( ! xdr_free_principal ( context , objp ) ) return FALSE ; break ; } return TRUE ; }
",0,317
675,"static void uipc_read_task ( void * arg ) { int ch_id ; int result ; UNUSED ( arg ) ; prctl ( PR_SET_NAME , ( unsigned long ) ""uipc-main"" , 0 , 0 , 0 ) ; raise_priority_a2dp ( TASK_UIPC_READ ) ; while ( uipc_main . running ) { uipc_main . read_set = uipc_main . active_set ; if ( result == 0 ) { BTIF_TRACE_EVENT ( ""selecttimeout"" ) ; continue ; } else if ( result < 0 ) { BTIF_TRACE_EVENT ( ""selectfailed%s"" , strerror ( errno ) ) ; continue ; } UIPC_LOCK ( ) ; uipc_check_interrupt_locked ( ) ; uipc_check_task_flags_locked ( ) ; uipc_check_fd_locked ( UIPC_CH_ID_AV_AUDIO ) ; for ( ch_id = 0 ; ch_id < UIPC_CH_NUM ; ch_id ++ ) { if ( ch_id != UIPC_CH_ID_AV_AUDIO ) uipc_check_fd_locked ( ch_id ) ; } UIPC_UNLOCK ( ) ; } BTIF_TRACE_EVENT ( ""UIPCREADTHREADEXITING"" ) ; uipc_main_cleanup ( ) ; uipc_main . tid = 0 ; BTIF_TRACE_EVENT ( ""UIPCREADTHREADDONE"" ) ; }
",0,365
676,"int dccp_rcv_state_process ( struct sock * sk , struct sk_buff * skb , struct dccp_hdr * dh , unsigned int len ) { struct dccp_sock * dp = dccp_sk ( sk ) ; struct dccp_skb_cb * dcb = DCCP_SKB_CB ( skb ) ; const int old_state = sk -> sk_state ; int queued = 0 ; if ( sk -> sk_state == DCCP_LISTEN ) { if ( dh -> dccph_type == DCCP_PKT_REQUEST ) { if ( inet_csk ( sk ) -> icsk_af_ops -> conn_request ( sk , skb ) < 0 ) return 1 ; consume_skb ( skb ) ; return 0 ; } if ( dh -> dccph_type == DCCP_PKT_RESET ) goto discard ; dcb -> dccpd_reset_code = DCCP_RESET_CODE_NO_CONNECTION ; return 1 ; } else if ( sk -> sk_state == DCCP_CLOSED ) { dcb -> dccpd_reset_code = DCCP_RESET_CODE_NO_CONNECTION ; return 1 ; } if ( sk -> sk_state != DCCP_REQUESTING && dccp_check_seqno ( sk , skb ) ) goto discard ; if ( ( dp -> dccps_role != DCCP_ROLE_CLIENT && dh -> dccph_type == DCCP_PKT_RESPONSE ) || ( dp -> dccps_role == DCCP_ROLE_CLIENT && dh -> dccph_type == DCCP_PKT_REQUEST ) || ( sk -> sk_state == DCCP_RESPOND && dh -> dccph_type == DCCP_PKT_DATA ) ) { dccp_send_sync ( sk , dcb -> dccpd_seq , DCCP_PKT_SYNC ) ; goto discard ; } if ( dccp_parse_options ( sk , NULL , skb ) ) return 1 ; if ( dh -> dccph_type == DCCP_PK
",0,511
677,"int pci_emul_add_msixcap ( struct pci_vdev * dev , int msgnum , int barnum ) { uint32_t tab_size ; struct msixcap msixcap ; if ( msgnum < 1 || msgnum > MAX_MSIX_TABLE_ENTRIES ) { pr_err ( ""%s:invalidnumberofmsixcap(%d)\\n"" , __func__ , msgnum ) ; return - 1 ; } tab_size = msgnum * MSIX_TABLE_ENTRY_SIZE ; tab_size = roundup2 ( tab_size , 4096 ) ; dev -> msix . table_bar = barnum ; dev -> msix . pba_bar = barnum ; dev -> msix . table_offset = 0 ; dev -> msix . table_count = msgnum ; dev -> msix . pba_offset = tab_size ; dev -> msix . pba_size = PBA_SIZE ( msgnum ) ; return ( pci_emul_add_capability ( dev , ( u_char * ) & msixcap , sizeof ( msixcap ) ) ) ; }
",0,257
678,"int ovl_setattr ( struct dentry * dentry , struct iattr * attr ) { int err ; struct dentry * upperdentry ; err = ovl_want_write ( dentry ) ; mutex_lock ( & upperdentry -> d_inode -> i_mutex ) ; err = notify_change ( upperdentry , attr , NULL ) ; mutex_unlock ( & upperdentry -> d_inode -> i_mutex ) ; } else { err = ovl_copy_up_last ( dentry , attr , false ) ; } ovl_drop_write ( dentry ) ; out : return err ; }
",1,147
679,"static int check_line_charstring ( void ) { char * p = line ; while ( isspace ( ( unsigned char ) * p ) ) p ++ ; return ( * p == '/' || ( p [ 0 ] == 'd' && p [ 1 ] == 'u' && p [ 2 ] == 'p' ) ) ; }
",1,74
680,"static int userauth_hostbased ( struct ssh * ssh ) { Authctxt * authctxt = ssh -> authctxt ; struct sshbuf * b ; struct sshkey * key = NULL ; char * pkalg , * cuser , * chost ; u_char * pkblob , * sig ; size_t alen , blen , slen ; int r , pktype , authenticated = 0 ; if ( ( r = sshpkt_get_cstring ( ssh , & pkalg , & alen ) ) != 0 || ( r = sshpkt_get_string ( ssh , & pkblob , & blen ) ) != 0 || ( r = sshpkt_get_cstring ( ssh , & chost , NULL ) ) != 0 || ( r = sshpkt_get_cstring ( ssh , & cuser , NULL ) ) != 0 || ( r = sshpkt_get_string ( ssh , & sig , & slen ) ) != 0 ) fatal ( ""%s:packetparsing:%s"" , __func__ , ssh_err ( r ) ) ; debug ( ""%s:cuser%schost%spkalg%sslen%zu"" , __func__ , cuser , chost , pkalg , slen ) ; # ifdef DEBUG_PK debug ( ""signature:"" ) ; sshbuf_dump_data ( sig , siglen , stderr ) ; # endif pktype = sshkey_type_from_name ( pkalg ) ; if ( pktype == KEY_UNSPEC ) { logit ( ""%s:unsupportedpublickeyalgorithm:%s"" , __func__ , pkalg ) ; goto done ; } if ( ( r = sshkey_from_blob ( pkblob , blen , & key ) ) != 0 ) { error ( ""%s:key_from_blob:%s"" , __func__ , ssh_err ( r ) ) ; goto done ; } if ( key == NULL ) { error ( ""%s:cannotdecodekey:%s"" , __func__ , pkalg ) ; goto done ; } if ( key == NULL ) { error ( ""%s:cannotdecodekey:%s"" , __func__ , pkalg ) ; goto done ; } if
",0,511
681,"static int decode_unsigned_max ( struct vpx_read_bit_buffer * rb , int max ) { const int data = vpx_rb_read_literal ( rb , get_unsigned_bits ( max ) ) ; return data > max ? max : data ; }
",1,63
682,"static int fetch_uidl ( char * line , void * data ) { int i , index ; struct Context * ctx = ( struct Context * ) data ; struct PopData * pop_data = ( struct PopData * ) ctx -> data ; char * endp = NULL ; errno = 0 ; index = strtol ( line , & endp , 10 ) ; if ( errno ) return - 1 ; while ( * endp == '' ) endp ++ ; memmove ( line , endp , strlen ( endp ) + 1 ) ; if ( strlen ( line ) == 0 ) return - 1 ; for ( i = 0 ; i < ctx -> msgcount ; i ++ ) if ( mutt_str_strcmp ( line , ctx -> hdrs [ i ] -> data ) == 0 ) break ; if ( i == ctx -> msgcount ) { mutt_debug ( 1 , ""newheader%d%s\\n"" , index , line ) ; if ( i >= ctx -> hdrmax ) mx_alloc_memory ( ctx ) ; ctx -> msgcount ++ ; ctx -> hdrs [ i ] = mutt_header_new ( ) ; ctx -> hdrs [ i ] -> data = mutt_str_strdup ( line ) ; } else if ( ctx -> hdrs [ i ] -> index != index - 1 ) pop_data -> clear_cache = true ; ctx -> hdrs [ i ] -> refno = index ; ctx -> hdrs [ i ] -> index = index - 1 ; return 0 ; }
",1,351
683,"krb5_error_code pkinit_check_kdc_pkid ( krb5_context context , pkinit_plg_crypto_context plg_cryptoctx , pkinit_req_crypto_context req_cryptoctx , pkinit_identity_crypto_context id_cryptoctx , unsigned char * pdid_buf , unsigned int pkid_len , int * valid_kdcPkId ) { krb5_error_code retval = KRB5KDC_ERR_PREAUTH_FAILED ; PKCS7_ISSUER_AND_SERIAL * is = NULL ; const unsigned char * p = pdid_buf ; int status = 1 ; X509 * kdc_cert = sk_X509_value ( id_cryptoctx -> my_certs , id_cryptoctx -> cert_index ) ; * valid_kdcPkId = 0 ; pkiDebug ( ""foundkdcPkIdinASREQ\\n"" ) ; is = d2i_PKCS7_ISSUER_AND_SERIAL ( NULL , & p , ( int ) pkid_len ) ; if ( is == NULL ) goto cleanup ; status = X509_NAME_cmp ( X509_get_issuer_name ( kdc_cert ) , is -> issuer ) ; if ( ! status ) { status = ASN1_INTEGER_cmp ( X509_get_serialNumber ( kdc_cert ) , is -> serial ) ; if ( ! status ) * valid_kdcPkId = 1 ; } retval = 0 ; cleanup : X509_NAME_free ( is -> issuer ) ; ASN1_INTEGER_free ( is -> serial ) ; free ( is ) ; return retval ; }
",0,402
684,"void ff_jpeg2000_cleanup ( Jpeg2000Component * comp , Jpeg2000CodingStyle * codsty ) { int reslevelno , bandno , precno ; for ( reslevelno = 0 ; comp -> reslevel && reslevelno < codsty -> nreslevels ; reslevelno ++ ) { Jpeg2000ResLevel * reslevel = comp -> reslevel + reslevelno ; for ( bandno = 0 ; bandno < reslevel -> nbands ; bandno ++ ) { Jpeg2000Band * band = reslevel -> band + bandno ; for ( precno = 0 ; precno < reslevel -> num_precincts_x * reslevel -> num_precincts_y ; precno ++ ) { Jpeg2000Prec * prec = band -> prec + precno ; av_freep ( & prec -> zerobits ) ; av_freep ( & prec -> cblkincl ) ; av_freep ( & prec -> cblk ) ; } av_freep ( & band -> prec ) ; } av_freep ( & reslevel -> band ) ; } ff_dwt_destroy ( & comp -> dwt ) ; av_freep ( & comp -> reslevel ) ; av_freep ( & comp -> i_data ) ; av_freep ( & comp -> f_data ) ; }
",0,298
685,"void xmlParsePEReference ( xmlParserCtxtPtr ctxt ) { const xmlChar * name ; xmlEntityPtr entity = NULL ; xmlParserInputPtr input ; if ( RAW != '%' ) return ; NEXT ; name = xmlParseName ( ctxt ) ; if ( name == NULL ) { xmlFatalErrMsg ( ctxt , XML_ERR_PEREF_NO_NAME , ""PEReference:noname\\n"" ) ; return ; } if ( xmlParserDebugEntities ) xmlGenericError ( xmlGenericErrorContext , ""PEReference:%s\\n"" , name ) ; if ( RAW != ';' ) { xmlFatalErr ( ctxt , XML_ERR_PEREF_SEMICOL_MISSING , NULL ) ; return ; } NEXT ; ctxt -> nbentities ++ ; if ( ( ctxt -> sax != NULL ) && ( ctxt -> sax -> getParameterEntity != NULL ) ) entity = ctxt -> sax -> getParameterEntity ( ctxt -> userData , name ) ; if ( ctxt -> instate == XML_PARSER_EOF ) return ; if ( entity == NULL ) { if ( ( ctxt -> standalone == 1 ) || ( ( ctxt -> hasExternalSubset == 0 ) && ( ctxt -> hasPErefs == 0 ) ) ) { xmlFatalErrMsgStr ( ctxt , XML_ERR_UNDECLARED_ENTITY , ""PEReference:%%%s;notfound\\n"" , name ) ; } else { if ( ( ctxt -> validate ) && ( ctxt -> vctxt . error != NULL ) ) { xmlValidityError ( ctxt , XML_WAR_UNDECLARED_ENTITY , ""PEReference:%%%s;notfound\\n"" , name , NULL ) ; } else xmlWarningMsg ( ctxt , XML_WAR_UNDECLARED_ENTITY , ""PEReference:%%%s;notfound\\n"" , name , NULL ) ; ctxt -> valid = 0 ; } xmlParserEntityCheck ( ctxt , 0 , NULL , 0 ) ; } else { if ( ( entity -> etype != XML_INTERNAL_PARAMETER_ENTITY ) && ( entity -> etype != XML_EXTERNAL_PARAMET
",0,511
686,"static int dccp_v6_send_response ( const struct sock * sk , struct request_sock * req ) { struct inet_request_sock * ireq = inet_rsk ( req ) ; struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct sk_buff * skb ; struct in6_addr * final_p , final ; struct flowi6 fl6 ; int err = - 1 ; struct dst_entry * dst ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; rcu_read_lock ( ) ; fl6 . flowi6_proto = IPPROTO_DCCP ; fl6 . daddr = ireq -> ir_v6_rmt_addr ; fl6 . saddr = ireq -> ir_v6_loc_addr ; fl6 . flowlabel = 0 ; fl6 . flowi6_oif = ireq -> ir_iif ; fl6 . fl6_dport = ireq -> ir_rmt_port ; fl6 . fl6_sport = htons ( ireq -> ir_num ) ; security_req_classify_flow ( req , flowi6_to_flowi ( & fl6 ) ) ; final_p = fl6_update_dst ( & fl6 , rcu_dereference ( np -> opt ) , np -> tclass ) ; rcu_read_unlock ( ) ; err = net_xmit_eval ( err ) ; } done : dst_release ( dst ) ; return err ; }
",1,351
687,"static TX_MODE select_tx_mode ( const VP9_COMP * cpi ) { if ( cpi -> oxcf . lossless ) { return ONLY_4X4 ; } else if ( cpi -> common . current_video_frame == 0 ) { return TX_MODE_SELECT ; } else { if ( cpi -> sf . tx_size_search_method == USE_LARGESTALL ) { return ALLOW_32X32 ; } else if ( cpi -> sf . tx_size_search_method == USE_FULL_RD ) { const MV_REFERENCE_FRAME frame_type = get_frame_type ( cpi ) ; return cpi -> rd_tx_select_threshes [ frame_type ] [ ALLOW_32X32 ] > cpi -> rd_tx_select_threshes [ frame_type ] [ TX_MODE_SELECT ] ? ALLOW_32X32 : TX_MODE_SELECT ; } else { return cpi -> common . tx_mode ; } } }
",0,234
688,"void * H264SwDecMalloc ( u32 size , u32 num ) { if ( size > UINT32_MAX / num ) { return NULL ; } return malloc ( size * num ) ; }
",1,46
689,"int print_calc ( image_desc_t * im ) { long i , ii , validsteps ; double printval ; struct tm tmvdef ; int graphelement = 0 ; long vidx ; int max_ii ; double magfact = - 1 ; char * si_symb = """" ; char * percent_s ; int prline_cnt = 0 ; time_t now = time ( NULL ) ; localtime_r ( & now , & tmvdef ) ; for ( i = 0 ; i < im -> gdes_c ; i ++ ) { vidx = im -> gdes [ i ] . vidx ; switch ( im -> gdes [ i ] . gf ) { case GF_PRINT : case GF_GPRINT : if ( im -> gdes [ vidx ] . gf == GF_VDEF ) { printval = im -> gdes [ vidx ] . vf . val ; localtime_r ( & im -> gdes [ vidx ] . vf . when , & tmvdef ) ; } else { max_ii = ( ( im -> gdes [ vidx ] . end - im -> gdes [ vidx ] . start ) / im -> gdes [ vidx ] . step * im -> gdes [ vidx ] . ds_cnt ) ; printval = DNAN ; validsteps = 0 ; for ( ii = im -> gdes [ vidx ] . ds ; ii < max_ii ; ii += im -> gdes [ vidx ] . ds_cnt ) { if ( ! finite ( im -> gdes [ vidx ] . data [ ii ] ) ) continue ; if ( isnan ( printval ) ) { printval = im -> gdes [ vidx ] . data [ ii ] ; validsteps ++ ; continue ; } switch ( im -> gdes [ i ] . cf ) { case CF_HWPREDICT : case CF_MHWPREDICT : case CF_DEVPREDICT : case CF_DEVSEASONAL : case CF_SEASONAL : case CF_AVERAGE : validsteps ++ ; printval += im -> gdes [ vidx ] . data [ ii ] ; break ; case CF_MINIMUM : printval = min ( printval
",0,511
690,"static Sdb * store_versioninfo_gnu_verneed ( ELFOBJ * bin , Elf_ ( Shdr ) * shdr , int sz ) { ut8 * end , * need = NULL ; const char * section_name = """" ; Elf_ ( Shdr ) * link_shdr = NULL ; const char * link_section_name = """" ; Sdb * sdb_vernaux = NULL ; Sdb * sdb_version = NULL ; Sdb * sdb = NULL ; int i , cnt ; if ( ! bin || ! bin -> dynstr ) { return NULL ; } if ( shdr -> sh_link > bin -> ehdr . e_shnum ) { return NULL ; } if ( shdr -> sh_size < 1 || shdr -> sh_size > SIZE_MAX ) { return NULL ; } sdb = sdb_new0 ( ) ; if ( ! sdb ) { return NULL ; } link_shdr = & bin -> shdr [ shdr -> sh_link ] ; if ( bin -> shstrtab && shdr -> sh_name < bin -> shstrtab_size ) { section_name = & bin -> shstrtab [ shdr -> sh_name ] ; } if ( bin -> shstrtab && link_shdr -> sh_name < bin -> shstrtab_size ) { link_section_name = & bin -> shstrtab [ link_shdr -> sh_name ] ; } if ( ! ( need = ( ut8 * ) calloc ( R_MAX ( 1 , shdr -> sh_size ) , sizeof ( ut8 ) ) ) ) { bprintf ( ""Warning:CannotallocatememoryforElf_(Verneed)\\n"" ) ; goto beach ; } end = need + shdr -> sh_size ; sdb_set ( sdb , ""section_name"" , section_name , 0 ) ; sdb_num_set ( sdb , ""num_entries"" , shdr -> sh_info , 0 ) ; sdb_num_set ( sdb , ""addr"" , shdr -> sh_addr , 0 ) ; sdb_num_set ( sdb , ""offset"" , shdr -> sh_offset , 0 ) ; sdb_num_set ( sdb , ""link"" , shdr -> sh_link ,
",0,511
691,"static int compare_tile_buffers ( const void * a , const void * b ) { const TileBuffer * const buf1 = ( const TileBuffer * ) a ; const TileBuffer * const buf2 = ( const TileBuffer * ) b ; if ( buf1 -> size < buf2 -> size ) { return 1 ; } else if ( buf1 -> size == buf2 -> size ) { return 0 ; } else { return - 1 ; } }
",0,96
692,"protected int file_trycdf ( struct magic_set * ms , int fd , const unsigned char * buf , size_t nbytes ) { cdf_info_t info ; cdf_header_t h ; cdf_sat_t sat , ssat ; cdf_stream_t sst , scn ; cdf_dir_t dir ; int i ; const char * expn = """" ; const char * corrupt = ""corrupt:"" ; info . i_fd = fd ; info . i_buf = buf ; info . i_len = nbytes ; if ( ms -> flags & MAGIC_APPLE ) return 0 ; if ( cdf_read_header ( & info , & h ) == - 1 ) return 0 ; # ifdef CDF_DEBUG cdf_dump_header ( & h ) ; # endif if ( ( i = cdf_read_sat ( & info , & h , & sat ) ) == - 1 ) { expn = ""Can\'treadSAT"" ; goto out0 ; } # ifdef CDF_DEBUG cdf_dump_sat ( ""SAT"" , & sat , CDF_SEC_SIZE ( & h ) ) ; # endif if ( ( i = cdf_read_ssat ( & info , & h , & sat , & ssat ) ) == - 1 ) { expn = ""Can\'treadSSAT"" ; goto out1 ; } # ifdef CDF_DEBUG cdf_dump_sat ( ""SSAT"" , & ssat , CDF_SHORT_SEC_SIZE ( & h ) ) ; # endif if ( ( i = cdf_read_dir ( & info , & h , & sat , & dir ) ) == - 1 ) { expn = ""Can\'treaddirectory"" ; goto out2 ; } const cdf_directory_t * root_storage ; if ( ( i = cdf_read_short_stream ( & info , & h , & sat , & dir , & sst , & root_storage ) ) == - 1 ) { expn = ""Cannotreadshortstream"" ; goto out3 ; } # ifdef CDF_DEBUG cdf_dump_dir ( & info , & h , & sat , & ssat , & sst , & dir ) ; # endif # ifdef notdef if
",0,511
693,"struct xt_table_info * xt_alloc_table_info ( unsigned int size ) { struct xt_table_info * info = NULL ; size_t sz = sizeof ( * info ) + size ; if ( ( SMP_ALIGN ( size ) >> PAGE_SHIFT ) + 2 > totalram_pages ) return NULL ; if ( sz <= ( PAGE_SIZE << PAGE_ALLOC_COSTLY_ORDER ) ) info = kmalloc ( sz , GFP_KERNEL | __GFP_NOWARN | __GFP_NORETRY ) ; if ( ! info ) { info = vmalloc ( sz ) ; if ( ! info ) return NULL ; } memset ( info , 0 , sizeof ( * info ) ) ; info -> size = size ; return info ; }
",0,180
694,"static inline int add_post_vars ( zval * arr , post_var_data_t * vars , zend_bool eof TSRMLS_DC ) { uint64_t max_vars = PG ( max_input_vars ) ; vars -> ptr = vars -> str . c ; vars -> end = vars -> str . c + vars -> str . len ; while ( add_post_var ( arr , vars , eof TSRMLS_CC ) ) { if ( ++ vars -> cnt > max_vars ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Inputvariablesexceeded%"" PRIu64 ""."" ""Toincreasethelimitchangemax_input_varsinphp.ini."" , max_vars ) ; return FAILURE ; } } if ( ! eof && vars -> str . c != vars -> ptr ) { memmove ( vars -> str . c , vars -> ptr , vars -> str . len = vars -> end - vars -> ptr ) ; } return SUCCESS ; }
",1,256
695,"static int ax25_create ( struct net * net , struct socket * sock , int protocol , int kern ) { struct sock * sk ; ax25_cb * ax25 ; if ( protocol < 0 || protocol == PF_AX25 ) protocol = AX25_P_TEXT ; break ; case SOCK_SEQPACKET : switch ( protocol ) { case 0 : case PF_AX25 : protocol = AX25_P_TEXT ; break ; case AX25_P_SEGMENT : # ifdef CONFIG_INET case AX25_P_ARP : case AX25_P_IP : # endif # ifdef CONFIG_NETROM case AX25_P_NETROM : # endif # ifdef CONFIG_ROSE case AX25_P_ROSE : # endif return - ESOCKTNOSUPPORT ; # ifdef CONFIG_NETROM_MODULE case AX25_P_NETROM : if ( ax25_protocol_is_registered ( AX25_P_NETROM ) ) return - ESOCKTNOSUPPORT ; break ; # endif # ifdef CONFIG_ROSE_MODULE case AX25_P_ROSE : if ( ax25_protocol_is_registered ( AX25_P_ROSE ) ) return - ESOCKTNOSUPPORT ; # endif default : break ; } break ; case SOCK_RAW : break ; default : return - ESOCKTNOSUPPORT ; } sk = sk_alloc ( net , PF_AX25 , GFP_ATOMIC , & ax25_proto , kern ) ; if ( sk == NULL ) return - ENOMEM ; ax25 = ax25_sk ( sk ) -> cb = ax25_create_cb ( ) ; if ( ! ax25 ) { sk_free ( sk ) ; return - ENOMEM ; } sock_init_data ( sock , sk ) ; sk -> sk_destruct = ax25_free_sock ; sock -> ops = & ax25_proto_ops ; sk -> sk_protocol = protocol ; ax25 -> sk = sk ; return 0 ; }
",0,454
696,"asmlinkage void do_page_fault ( struct pt_regs * regs , unsigned long writeaccess , unsigned long textaccess , unsigned long address ) { struct task_struct * tsk ; struct mm_struct * mm ; struct vm_area_struct * vma ; const struct exception_table_entry * fixup ; pte_t * pte ; int fault ; tsk = current ; mm = tsk -> mm ; local_irq_enable ( ) ; perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS , 1 , regs , address ) ; if ( in_atomic ( ) || ! mm ) goto no_context ; down_read ( & mm -> mmap_sem ) ; vma = find_vma ( mm , address ) ; if ( ! vma ) { # ifdef DEBUG_FAULT print_task ( tsk ) ; printk ( ""%s:%dfault,addressis0x%08xPC%016Lxtextaccess%dwriteaccess%d\\n"" , __func__ , __LINE__ , address , regs -> pc , textaccess , writeaccess ) ; show_regs ( regs ) ; # endif goto bad_area ; } if ( vma -> vm_start <= address ) { goto good_area ; } if ( ! ( vma -> vm_flags & VM_GROWSDOWN ) ) { # ifdef DEBUG_FAULT print_task ( tsk ) ; printk ( ""%s:%dfault,addressis0x%08xPC%016Lxtextaccess%dwriteaccess%d\\n"" , __func__ , __LINE__ , address , regs -> pc , textaccess , writeaccess ) ; show_regs ( regs ) ; print_vma ( vma ) ; # endif goto bad_area ; } if ( expand_stack ( vma , address ) ) { # ifdef DEBUG_FAULT print_task ( tsk ) ; printk ( ""%s:%dfault,addressis0x%08xPC%016Lxtextaccess%dwriteaccess%d\\n"" , __func__ , __LINE__ , address , regs -> pc , textaccess , writeaccess ) ; show_regs ( regs ) ; # endif goto bad_area ; } good_area : if ( ! (
",0,511
697,"static int em_grp45 ( struct x86_emulate_ctxt * ctxt ) { int rc = X86EMUL_CONTINUE ; switch ( ctxt -> modrm_reg ) { case 2 : { long int old_eip ; old_eip = ctxt -> _eip ; rc = assign_eip_near ( ctxt , ctxt -> src . val ) ; if ( rc != X86EMUL_CONTINUE ) break ; ctxt -> src . val = old_eip ; rc = em_push ( ctxt ) ; break ; } case 4 : rc = assign_eip_near ( ctxt , ctxt -> src . val ) ; break ; case 5 : rc = em_jmp_far ( ctxt ) ; break ; case 6 : rc = em_push ( ctxt ) ; break ; } return rc ; }
",1,192
698,"static void cmd_parse_lsub ( struct ImapData * idata , char * s ) { char buf [ STRING ] ; char errstr [ STRING ] ; struct Buffer err , token ; struct Url url ; struct ImapList list ; if ( idata -> cmddata && idata -> cmdtype == IMAP_CT_LIST ) { cmd_parse_list ( idata , s ) ; return ; } if ( ! ImapCheckSubscribed ) return ; idata -> cmdtype = IMAP_CT_LIST ; idata -> cmddata = & list ; cmd_parse_list ( idata , s ) ; idata -> cmddata = NULL ; if ( ! list . name , true || list . noselect ) return ; mutt_debug ( 3 , ""Subscribingto%s\\n"" , list . name ) ; mutt_str_strfcpy ( buf , ""mailboxes\\"""" , sizeof ( buf ) ) ; mutt_account_tourl ( & idata -> conn -> account , & url ) ; imap_quote_string ( errstr , sizeof ( errstr ) , list . name ) ; url . path = errstr + 1 ; url . path [ strlen ( url . path ) - 1 ] = '\\0' ; if ( mutt_str_strcmp ( url . user , ImapUser ) == 0 ) url . user = NULL ; url_tostring ( & url , buf + 11 , sizeof ( buf ) - 11 , 0 ) ; mutt_str_strcat ( buf , sizeof ( buf ) , ""\\"""" ) ; mutt_buffer_init ( & token ) ; mutt_buffer_init ( & err ) ; err . data = errstr ; err . dsize = sizeof ( errstr ) ; if ( mutt_parse_rc_line ( buf , & token , & err ) ) mutt_debug ( 1 , ""Erroraddingsubscribedmailbox:%s\\n"" , errstr ) ; FREE ( & token . data ) ; }
",1,446
699,"static int process_one_ticket ( struct ceph_auth_client * ac , struct ceph_crypto_key * secret , void * * p , void * end ) { struct ceph_x_info * xi = ac -> private ; int type ; u8 tkt_struct_v , blob_struct_v ; struct ceph_x_ticket_handler * th ; void * dbuf = NULL ; void * dp , * dend ; int dlen ; char is_enc ; struct timespec validity ; struct ceph_crypto_key old_key ; void * ticket_buf = NULL ; void * tp , * tpend ; struct ceph_timespec new_validity ; struct ceph_crypto_key new_session_key ; struct ceph_buffer * new_ticket_blob ; unsigned long new_expires , new_renew_after ; u64 new_secret_id ; int ret ; ceph_decode_need ( p , end , & dbuf , TEMP_TICKET_BUF_LEN ) ; if ( tkt_struct_v != 1 ) goto bad ; th = get_ticket_handler ( ac , type ) ; if ( IS_ERR ( th ) ) { ret = PTR_ERR ( th ) ; goto out ; } dlen = ceph_x_decrypt ( secret , p , end , dbuf , TEMP_TICKET_BUF_LEN ) ; if ( dlen <= 0 ) { ret = dlen ; goto out ; } dout ( ""decrypted%dbytes\\n"" , dlen ) ; dp = dbuf ; dend = dp + dlen ; tkt_struct_v = ceph_decode_8 ( & dp ) ; if ( tkt_struct_v != 1 ) goto bad ; memcpy ( & old_key , & th -> session_key , sizeof ( old_key ) ) ; ret = ceph_crypto_key_decode ( & new_session_key , & dp , end ) ; if ( ret ) goto out ; ceph_decode_copy ( & dp , & new_validity , sizeof ( new_validity ) ) ; ceph_decode_timespec ( & validity ) ; ceph_decode_
",0,511
700,"Datum hstore_from_array ( PG_FUNCTION_ARGS ) { ArrayType * in_array = PG_GETARG_ARRAYTYPE_P ( 0 ) ; int ndims = ARR_NDIM ( in_array ) ; int count ; int32 buflen ; HStore * out ; Pairs * pairs ; Datum * in_datums ; bool * in_nulls ; int in_count ; int i ; Assert ( ARR_ELEMTYPE ( in_array ) == TEXTOID ) ; switch ( ndims ) { case 0 : out = hstorePairs ( NULL , 0 , 0 ) ; PG_RETURN_POINTER ( out ) ; case 1 : if ( ( ARR_DIMS ( in_array ) [ 0 ] ) % 2 ) ereport ( ERROR , ( errcode ( ERRCODE_ARRAY_SUBSCRIPT_ERROR ) , errmsg ( ""arraymusthaveevennumberofelements"" ) ) ) ; break ; case 2 : if ( ( ARR_DIMS ( in_array ) [ 1 ] ) != 2 ) ereport ( ERROR , ( errcode ( ERRCODE_ARRAY_SUBSCRIPT_ERROR ) , errmsg ( ""arraymusthavetwocolumns"" ) ) ) ; break ; default : ereport ( ERROR , ( errcode ( ERRCODE_ARRAY_SUBSCRIPT_ERROR ) , errmsg ( ""wrongnumberofarraysubscripts"" ) ) ) ; } deconstruct_array ( in_array , TEXTOID , - 1 , false , 'i' , & in_datums , & in_nulls , & in_count ) ; count = in_count / 2 ; if ( count > MaxAllocSize / sizeof ( Pairs ) ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""numberofpairs(%d)exceedsthemaximumallowed(%d)"" , count , ( int ) ( MaxAllocSize / sizeof ( Pairs ) ) ) ) ) ; pairs = palloc ( count * sizeof ( Pairs ) ) ; for ( i = 0 ; i < count ; ++ i ) { if ( in_nulls [ i * 2
",0,511
701,"static void put_prev_task ( struct rq * rq , struct task_struct * prev ) { if ( prev -> se . on_rq ) update_rq_clock ( rq ) ; prev -> sched_class -> put_prev_task ( rq , prev ) ; }
",1,65
702,"int ssl3_get_new_session_ticket ( SSL * s ) { int ok , al , ret = 0 , ticklen ; long n ; const unsigned char * p ; unsigned char * d ; n = s -> method -> ssl_get_message ( s , SSL3_ST_CR_SESSION_TICKET_A , SSL3_ST_CR_SESSION_TICKET_B , SSL3_MT_NEWSESSION_TICKET , 16384 , & ok ) ; if ( ! ok ) return ( ( int ) n ) ; if ( n < 6 ) { al = SSL_AD_DECODE_ERROR ; SSLerr ( SSL_F_SSL3_GET_NEW_SESSION_TICKET , SSL_R_LENGTH_MISMATCH ) ; goto f_err ; } p = d = ( unsigned char * ) s -> init_msg ; if ( s -> session -> session_id_length > 0 ) { al = SSL_AD_DECODE_ERROR ; SSLerr ( SSL_F_SSL3_GET_NEW_SESSION_TICKET , SSL_R_LENGTH_MISMATCH ) ; goto f_err ; } n2l ( p , s -> session -> tlsext_tick_lifetime_hint ) ; n2s ( p , ticklen ) ; if ( ticklen + 6 != n ) { al = SSL_AD_DECODE_ERROR ; SSLerr ( SSL_F_SSL3_GET_NEW_SESSION_TICKET , SSL_R_LENGTH_MISMATCH ) ; goto f_err ; } OPENSSL_free ( s -> session -> tlsext_tick ) ; s -> session -> tlsext_ticklen = 0 ; s -> session -> tlsext_tick = OPENSSL_malloc ( ticklen ) ; if ( ! s -> session -> tlsext_tick ) { SSLerr ( SSL_F_SSL3_GET_NEW_SESSION_TICKET , ERR_R_MALLOC_FAILURE ) ; goto err ; } memcpy ( s -> session -> tlsext_tick , p , ticklen ) ; s -> session -> tlsext_ticklen = ticklen ; EVP_Digest ( p , ticklen , s -> session
",0,511
703,"int button_open ( Button * b ) { char * p , name [ 256 ] ; int r ; assert ( b ) ; b -> fd = safe_close ( b -> fd ) ; p = strjoina ( ""/dev/input/"" , b -> name ) ; b -> fd = open ( p , O_RDWR | O_CLOEXEC | O_NOCTTY | O_NONBLOCK ) ; if ( b -> fd < 0 ) return log_warning_errno ( errno , ""Failedtoopen%s:%m"" , p ) ; r = button_suitable ( b ) ; if ( r < 0 ) return log_warning_errno ( r , ""Failedtodeterminewhetherinputdeviceisrelevanttous:%m"" ) ; if ( r == 0 ) return log_debug_errno ( SYNTHETIC_ERRNO ( EADDRNOTAVAIL ) , ""Device%sdoesnotexposekeysorswitchesrelevanttous,ignoring."" , p ) ; if ( ioctl ( b -> fd , EVIOCGNAME ( sizeof ( name ) ) , name ) < 0 ) { r = log_error_errno ( errno , ""Failedtogetinputname:%m"" ) ; goto fail ; } ( void ) button_set_mask ( b ) ; r = sd_event_add_io ( b -> manager -> event , & b -> io_event_source , b -> fd , EPOLLIN , button_dispatch , b ) ; if ( r < 0 ) { log_error_errno ( r , ""Failedtoaddbuttonevent:%m"" ) ; goto fail ; } log_info ( ""Watchingsystembuttonson/dev/input/%s(%s)"" , b -> name , name ) ; return 0 ; fail : b -> fd = safe_close ( b -> fd ) ; return r ; }
",0,435
704,"int test ( char * URL ) { int errors = 0 ; ( void ) URL ; errors += test_weird_arguments ( ) ; errors += test_unsigned_short_formatting ( ) ; errors += test_signed_short_formatting ( ) ; errors += test_unsigned_int_formatting ( ) ; errors += test_signed_long_formatting ( ) ; errors += test_curl_off_t_formatting ( ) ; errors += test_string_formatting ( ) ; if ( errors ) return TEST_ERR_MAJOR_BAD ; else return 0 ; }
",0,132
705,"bool ExprResolveLhs ( struct xkb_context * ctx , const ExprDef * expr , const char * * elem_rtrn , const char * * field_rtrn , ExprDef * * index_rtrn ) { switch ( expr -> expr . op ) { case EXPR_IDENT : * elem_rtrn = NULL ; * field_rtrn = xkb_atom_text ( ctx , expr -> ident . ident ) ; * index_rtrn = NULL ; return ( * elem_rtrn != NULL ) ; case EXPR_ARRAY_REF : * elem_rtrn = xkb_atom_text ( ctx , expr -> array_ref . element ) ; * field_rtrn = xkb_atom_text ( ctx , expr -> array_ref . field ) ; * index_rtrn = expr -> array_ref . entry ; if ( expr -> array_ref . element != XKB_ATOM_NONE && * elem_rtrn == NULL ) return false ; return true ; default : break ; } log_wsgo ( ctx , ""Unexpectedoperator%dinResolveLhs\\n"" , expr -> expr . op ) ; return false ; }
",0,279
706,"static void sas_scsi_clear_queue_lu ( struct list_head * error_q , struct scsi_cmnd * my_cmd ) { struct scsi_cmnd * cmd , * n ; list_for_each_entry_safe ( cmd , n , error_q , eh_entry ) { if ( cmd -> device -> sdev_target == my_cmd -> device -> sdev_target && cmd -> device -> lun == my_cmd -> device -> lun ) sas_eh_defer_cmd ( cmd ) ; } }
",0,122
707,"static stmt_ty ast_for_funcdef_impl ( struct compiling * c , const node * n0 , asdl_seq * decorator_seq , bool is_async ) { const node * const n = is_async ? CHILD ( n0 , 1 ) : n0 ; identifier name ; arguments_ty args ; asdl_seq * body ; expr_ty returns = NULL ; int name_i = 1 ; int end_lineno , end_col_offset ; REQ ( n , funcdef ) ; name = NEW_IDENTIFIER ( CHILD ( n , name_i ) ) ; if ( ! name ) return NULL ; if ( forbidden_name ( c , name , CHILD ( n , name_i ) , 0 ) ) return NULL ; args = ast_for_arguments ( c , CHILD ( n , name_i + 1 ) ) ; if ( ! args ) return NULL ; if ( TYPE ( CHILD ( n , name_i + 2 ) ) == RARROW ) { returns = ast_for_expr ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! returns ) return NULL ; name_i += 2 ; } body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! body ) return NULL ; get_last_end_pos ( body , & end_lineno , & end_col_offset ) ; if ( is_async ) return AsyncFunctionDef ( name , args , body , decorator_seq , returns , LINENO ( n0 ) , n0 -> n_col_offset , end_lineno , end_col_offset , c -> c_arena ) ; else return FunctionDef ( name , args , body , decorator_seq , returns , LINENO ( n ) , n -> n_col_offset , end_lineno , end_col_offset , c -> c_arena ) ; }
",0,432
708,"int sctp_do_peeloff ( struct sock * sk , sctp_assoc_t id , struct socket * * sockp ) { struct sctp_association * asoc = sctp_id2assoc ( sk , id ) ; struct sctp_sock * sp = sctp_sk ( sk ) ; struct socket * sock ; int err = 0 ; if ( waitqueue_active ( & asoc -> wait ) ) return - EBUSY ; if ( ! sctp_style ( sk , UDP ) ) return - EINVAL ; err = sock_create ( sk -> sk_family , SOCK_SEQPACKET , IPPROTO_SCTP , & sock ) ; if ( err < 0 ) return err ; sctp_copy_sock ( sock -> sk , sk , asoc ) ; sp -> pf -> to_sk_daddr ( & asoc -> peer . primary_addr , sk ) ; sctp_sock_migrate ( sk , sock -> sk , asoc , SCTP_SOCKET_UDP_HIGH_BANDWIDTH ) ; * sockp = sock ; return err ; }
",0,265
709,"static int encrypt ( struct blkcipher_desc * desc , struct scatterlist * dst , struct scatterlist * src , unsigned int nbytes ) { struct blkcipher_walk walk ; struct crypto_blkcipher * tfm = desc -> tfm ; struct salsa20_ctx * ctx = crypto_blkcipher_ctx ( tfm ) ; int err ; blkcipher_walk_init ( & walk , dst , src , nbytes ) ; err = blkcipher_walk_virt_block ( desc , & walk , 64 ) ; salsa20_ivsetup ( ctx , walk . iv ) ; while ( walk . nbytes >= 64 ) { salsa20_encrypt_bytes ( ctx , walk . dst . virt . addr , walk . src . virt . addr , walk . nbytes - ( walk . nbytes % 64 ) ) ; err = blkcipher_walk_done ( desc , & walk , walk . nbytes % 64 ) ; } if ( walk . nbytes ) { salsa20_encrypt_bytes ( ctx , walk . dst . virt . addr , walk . src . virt . addr , walk . nbytes ) ; err = blkcipher_walk_done ( desc , & walk , 0 ) ; } return err ; }
",1,280
710,"static int vsock_stream_recvmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { struct sock * sk ; struct vsock_sock * vsk ; int err ; size_t target ; ssize_t copied ; long timeout ; struct vsock_transport_recv_notify_data recv_data ; DEFINE_WAIT ( wait ) ; sk = sock -> sk ; vsk = vsock_sk ( sk ) ; err = 0 ; msg -> msg_namelen = 0 ; lock_sock ( sk ) ; if ( sk -> sk_state != SS_CONNECTED ) { if ( sock_flag ( sk , SOCK_DONE ) ) err = 0 ; else err = - ENOTCONN ; goto out ; } if ( flags & MSG_OOB ) { err = - EOPNOTSUPP ; goto out ; } if ( sk -> sk_shutdown & RCV_SHUTDOWN ) { err = 0 ; goto out ; } if ( ! len ) { err = 0 ; goto out ; } target = sock_rcvlowat ( sk , flags & MSG_WAITALL , len ) ; if ( target >= transport -> stream_rcvhiwat ( vsk ) ) { err = - ENOMEM ; goto out ; } timeout = sock_rcvtimeo ( sk , flags & MSG_DONTWAIT ) ; copied = 0 ; err = transport -> notify_recv_init ( vsk , target , & recv_data ) ; if ( err < 0 ) goto out ; prepare_to_wait ( sk_sleep ( sk ) , & wait , TASK_INTERRUPTIBLE ) ; while ( 1 ) { s64 ready = vsock_stream_has_data ( vsk ) ; if ( ready < 0 ) { err = - ENOMEM ; goto out_wait ; } else if ( ready > 0 ) { ssize_t read ; err = transport -> notify_recv_pre_dequeue ( vsk , target , & recv_data ) ; if ( err < 0 ) break ; read = transport -> stream_dequeue ( vsk , msg -> msg_iov , len - copied , flags ) ; if ( read < 0 ) { err = - EN
",0,511
711,"int my_csr_reader ( const char * i_csr_file_in , unsigned int * * o_row_idx , unsigned int * * o_column_idx , REALTYPE * * o_values , unsigned int * o_row_count , unsigned int * o_column_count , unsigned int * o_element_count ) { FILE * l_csr_file_handle ; const unsigned int l_line_length = 512 ; char l_line [ 512 + 1 ] ; unsigned int l_header_read = 0 ; unsigned int * l_row_idx_id = NULL ; unsigned int l_i = 0 ; l_csr_file_handle = fopen ( i_csr_file_in , ""r"" ) ; if ( l_csr_file_handle == NULL ) { fprintf ( stderr , ""cannotopenCSRfile
",0,197
712,"static Image * ReadWPGImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { typedef struct { size_t FileId ; MagickOffsetType DataOffset ; unsigned int ProductType ; unsigned int FileType ; unsigned char MajorVersion ; unsigned char MinorVersion ; unsigned int EncryptKey ; unsigned int Reserved ; } WPGHeader ; typedef struct { unsigned char RecType ; size_t RecordLength ; } WPGRecord ; typedef struct { unsigned char Class ; unsigned char RecType ; size_t Extension ; size_t RecordLength ; } WPG2Record ; typedef struct { unsigned HorizontalUnits ; unsigned VerticalUnits ; unsigned char PosSizePrecision ; } WPG2Start ; typedef struct { unsigned int Width ; unsigned int Height ; unsigned int Depth ; unsigned int HorzRes ; unsigned int VertRes ; } WPGBitmapType1 ; typedef struct { unsigned int Width ; unsigned int Height ; unsigned char Depth ; unsigned char Compression ; } WPG2BitmapType1 ; typedef struct { unsigned int RotAngle ; unsigned int LowLeftX ; unsigned int LowLeftY ; unsigned int UpRightX ; unsigned int UpRightY ; unsigned int Width ; unsigned int Height ; unsigned int Depth ; unsigned int HorzRes ; unsigned int VertRes ; } WPGBitmapType2 ; typedef struct { unsigned int StartIndex ; unsigned int NumOfEntries ; } WPGColorMapRec ; Image * image ; unsigned int status ; WPGHeader Header ; WPGRecord Rec ; WPG2Record Rec2 ; WPG2Start StartWPG ; WPGBitmapType1 BitmapHeader1 ; WPG2BitmapType1 Bitmap2Header1 ; WPGBitmapType2 BitmapHeader2 ; WPGColorMapRec WPG_Palette ; int i , bpp , WPG2Flags ; ssize_t ldblk ; size_t one ; unsigned char * BImgBuff ; tCTM CTM ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; one = 1 ; image = AcquireImage ( image_info , exception ) ; image -> depth = 8 ; status = OpenBlob ( image_info
",0,511
713,"static int em_loop ( struct x86_emulate_ctxt * ctxt ) { int rc = X86EMUL_CONTINUE ; register_address_increment ( ctxt , reg_rmw ( ctxt , VCPU_REGS_RCX ) , - 1 ) ; if ( ( address_mask ( ctxt , reg_read ( ctxt , VCPU_REGS_RCX ) ) != 0 ) && ( ctxt -> b == 0xe2 || test_cc ( ctxt -> b ^ 0x5 , ctxt -> eflags ) ) ) rc = jmp_rel ( ctxt , ctxt -> src . val ) ; return rc ; }
",1,149
714,"static int hi3660_stub_clk_probe ( struct platform_device * pdev ) { struct device * dev = & pdev -> dev ; struct resource * res ; unsigned int i ; int ret ; stub_clk_chan . cl . dev = dev ; stub_clk_chan . cl . tx_done = NULL ; stub_clk_chan . cl . tx_block = false ; stub_clk_chan . cl . knows_txdone = false ; stub_clk_chan . mbox = mbox_request_channel ( & stub_clk_chan . cl , 0 ) ; if ( IS_ERR ( stub_clk_chan . mbox ) ) return PTR_ERR ( stub_clk_chan . mbox ) ; res = platform_get_resource ( pdev , IORESOURCE_MEM , 0 ) ; if ( res == 0 ) return - ENOMEM ; freq_reg = devm_ioremap ( dev , res -> start , resource_size ( res ) ) ; if ( ! freq_reg ) return - ENOMEM ; freq_reg += HI3660_STUB_CLOCK_DATA ; for ( i = 0 ; i < HI3660_CLK_STUB_NUM ; i ++ ) { ret = devm_clk_hw_register ( & pdev -> dev , & hi3660_stub_clks [ i ] . hw ) ; if ( ret ) return ret ; } return devm_of_clk_add_hw_provider ( & pdev -> dev , hi3660_stub_clk_hw_get , hi3660_stub_clks ) ; }
",0,380
715,"static void header_seek ( SF_PRIVATE * psf , sf_count_t position , int whence ) { switch ( whence ) { case SEEK_SET : psf_fseek ( psf , position , whence ) ; return ; }
",0,56
716,"int ext4_collapse_range ( struct inode * inode , loff_t offset , loff_t len ) { struct super_block * sb = inode -> i_sb ; ext4_lblk_t punch_start , punch_stop ; handle_t * handle ; unsigned int credits ; loff_t new_size , ioffset ; int ret ; if ( ! ext4_test_inode_flag ( inode , EXT4_INODE_EXTENTS ) ) return - EOPNOTSUPP ; if ( offset & ( EXT4_CLUSTER_SIZE ( sb ) - 1 ) || len & ( EXT4_CLUSTER_SIZE ( sb ) - 1 ) ) return - EINVAL ; if ( ! S_ISREG ( inode -> i_mode ) ) return - EINVAL ; trace_ext4_collapse_range ( inode , offset , len ) ; punch_start = offset >> EXT4_BLOCK_SIZE_BITS ( sb ) ; punch_stop = ( offset + len ) >> EXT4_BLOCK_SIZE_BITS ( sb ) ; if ( ext4_should_journal_data ( inode ) ) { ret = ext4_force_commit ( inode -> i_sb ) ; if ( ret ) return ret ; } ioffset = round_down ( offset , PAGE_SIZE ) ; ret = filemap_write_and_wait_range ( inode -> i_mapping , ioffset , LLONG_MAX ) ; if ( ret ) return ret ; mutex_lock ( & inode -> i_mutex ) ; if ( offset + len >= i_size_read ( inode ) ) { ret = - EINVAL ; goto out_mutex ; } ext4_inode_block_unlocked_dio ( inode ) ; inode_dio_wait ( inode ) ; down_write ( & EXT4_I ( inode ) -> i_mmap_sem ) ; if ( ! ext4_test_inode_flag ( inode , EXT4_INODE_EXTENTS ) ) { ret = - EOPNOTSUPP ; goto out_mutex ; } truncate_pagecache ( inode , ioffset ) ; credits = ext4_writepage_trans
",0,511
717,"struct _mdi * _WM_ParseNewMidi ( uint8_t * midi_data , uint32_t midi_size ) { struct _mdi * mdi ; uint32_t tmp_val ; uint32_t midi_type ; uint8_t * * tracks ; uint32_t * track_size ; uint32_t end_of_tracks = 0 ; uint32_t no_tracks ; uint32_t i ; uint32_t divisions = 96 ; uint32_t tempo = 500000 ; float samples_per_delta_f = 0.0 ; uint32_t sample_count = 0 ; float sample_count_f = 0.0 ; float sample_remainder = 0.0 ; uint8_t * sysex_store = NULL ; uint32_t * track_delta ; uint8_t * track_end ; uint32_t smallest_delta = 0 ; uint32_t subtract_delta = 0 ; uint8_t * running_event ; uint32_t setup_ret = 0 ; if ( midi_size < 14 ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , ""(tooshort)"" , 0 ) ; return ( NULL ) ; } if ( ! memcmp ( midi_data , ""RIFF"" , 4 ) ) { if ( midi_size < 34 ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_CORUPT , ""(tooshort)"" , 0 ) ; return ( NULL ) ; } midi_data += 20 ; midi_size -= 20 ; } if ( memcmp ( midi_data , ""MThd"" , 4 ) ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_MIDI , NULL , 0 ) ; return ( NULL ) ; } midi_data += 4 ; midi_size -= 4 ; tmp_val = * midi_data ++ << 24 ; tmp_val |= * midi_data ++ << 16 ; tmp_val |= * midi_data ++ << 8 ; tmp_val |= * midi_data ++ ; midi_size
",0,511
718,"int sock_setsockopt ( struct socket * sock , int level , int optname , char __user * optval , unsigned int optlen ) { struct sock * sk = sock -> sk ; int val ; int valbool ; struct linger ling ; int ret = 0 ; if ( optname == SO_BINDTODEVICE ) return sock_setbindtodevice ( sk , optval , optlen ) ; if ( optlen < sizeof ( int ) ) return - EINVAL ; if ( get_user ( val , ( int __user * ) optval ) ) return - EFAULT ; valbool = val ? 1 : 0 ; lock_sock ( sk ) ; switch ( optname ) { case SO_DEBUG : if ( val && ! capable ( CAP_NET_ADMIN ) ) ret = - EACCES ; else sock_valbool_flag ( sk , SOCK_DBG , valbool ) ; break ; case SO_REUSEADDR : sk -> sk_reuse = ( valbool ? SK_CAN_REUSE : SK_NO_REUSE ) ; break ; case SO_REUSEPORT : sk -> sk_reuseport = valbool ; break ; case SO_TYPE : case SO_PROTOCOL : case SO_DOMAIN : case SO_ERROR : ret = - ENOPROTOOPT ; break ; case SO_DONTROUTE : sock_valbool_flag ( sk , SOCK_LOCALROUTE , valbool ) ; break ; case SO_BROADCAST : sock_valbool_flag ( sk , SOCK_BROADCAST , valbool ) ; break ; case SO_SNDBUF : val = min_t ( u32 , val , sysctl_wmem_max ) ; set_sndbuf : sk -> sk_userlocks |= SOCK_SNDBUF_LOCK ; sk -> sk_sndbuf = max_t ( int , val * 2 , SOCK_MIN_SNDBUF ) ; sk -> sk_write_space ( sk ) ; break ; case SO_SNDBUFFORCE : if ( ! capable ( CAP_NET_ADMIN ) ) { ret = - EPERM ; break ; } goto set_sndbuf ; case SO_RCVBUF : val = min_t ( u32 , val , sysctl_
",0,511
719,"static int udf_load_logicalvol ( struct super_block * sb , sector_t block , struct kernel_lb_addr * fileset ) { struct logicalVolDesc * lvd ; int i , j , offset ; uint8_t type ; struct udf_sb_info * sbi = UDF_SB ( sb ) ; struct genericPartitionMap * gpm ; uint16_t ident ; struct buffer_head * bh ; int ret = 0 ; bh = udf_read_tagged ( sb , block , block , & ident ) ; if ( ! bh ) return 1 ; BUG_ON ( ident != TAG_IDENT_LVD ) ; lvd = ( struct logicalVolDesc * ) bh -> b_data ; ret = udf_sb_alloc_partition_maps ( sb , le32_to_cpu ( lvd -> numPartitionMaps ) ) ; if ( ret ) goto out_bh ; for ( i = 0 , offset = 0 ; i < sbi -> s_partitions && offset < le32_to_cpu ( lvd -> mapTableLength ) ; i ++ , offset += gpm -> partitionMapLength ) { struct udf_part_map * map = & sbi -> s_partmaps [ i ] ; gpm = ( struct genericPartitionMap * ) & ( lvd -> partitionMaps [ offset ] ) ; type = gpm -> partitionMapType ; if ( type == 1 ) { struct genericPartitionMap1 * gpm1 = ( struct genericPartitionMap1 * ) gpm ; map -> s_partition_type = UDF_TYPE1_MAP15 ; map -> s_volumeseqnum = le16_to_cpu ( gpm1 -> volSeqNum ) ; map -> s_partition_num = le16_to_cpu ( gpm1 -> partitionNum ) ; map -> s_partition_func = NULL ; } else if ( type == 2 ) { struct udfPartitionMap2 * upm2 = ( struct udfPartitionMap2 * ) gpm ; if ( ! strncmp ( upm2 -> partIdent . ident , UDF_ID_VIRTUAL , strlen ( UDF_ID_VIRTUAL ) ) ) { u16 suf = le16_to_cpu
",0,510
720,"jas_image_t * bmp_decode ( jas_stream_t * in , char * optstr ) { jas_image_t * image ; bmp_hdr_t hdr ; bmp_info_t * info ; uint_fast16_t cmptno ; jas_image_cmptparm_t cmptparms [ 3 ] ; jas_image_cmptparm_t * cmptparm ; uint_fast16_t numcmpts ; long n ; image = 0 ; info = 0 ; if ( optstr ) { jas_eprintf ( ""warning:ignoringBMPdecoderoptions\\n"" ) ; } jas_eprintf ( ""THEBMPFORMATISNOTFULLYSUPPORTED
",0,174
721,"void qedi_dbg_notice ( struct qedi_dbg_ctx * qedi , const char * func , u32 line , const char * fmt , ... ) { va_list va ; struct va_format vaf ; va_start ( va , fmt ) ; vaf . fmt = fmt ; vaf . va = & va ; if ( ! ( qedi_dbg_log & QEDI_LOG_NOTICE ) ) goto ret ; if ( likely ( qedi ) && likely ( qedi -> pdev ) ) pr_notice ( ""[%s]:[%s:%d]:%d:%pV"" , dev_name ( & qedi -> pdev -> dev ) , func , line , qedi -> host_no , & vaf ) ; else pr_notice ( ""[0000:00:00.0]:[%s:%d]:%pV"" , func , line , & vaf ) ; ret : va_end ( va ) ; }
",1,215
722,"IHEVCD_ERROR_T ihevcd_cabac_init ( cab_ctxt_t * ps_cabac , bitstrm_t * ps_bitstrm , WORD32 qp , WORD32 cabac_init_idc , const UWORD8 * pu1_init_ctxt ) { ASSERT ( ps_cabac != NULL ) ; ASSERT ( ps_bitstrm != NULL ) ; ASSERT ( ( qp >= 0 ) && ( qp < 52 ) ) ; ASSERT ( ( cabac_init_idc >= 0 ) && ( cabac_init_idc < 3 ) ) ; UNUSED ( qp ) ; UNUSED ( cabac_init_idc ) ; # if FULLRANGE ps_cabac -> u4_range = ( UWORD32 ) 510 << RANGE_SHIFT ; BITS_GET ( ps_cabac -> u4_ofst , ps_bitstrm -> pu4_buf , ps_bitstrm -> u4_bit_ofst , ps_bitstrm -> u4_cur_word , ps_bitstrm -> u4_nxt_word , ( 9 + RANGE_SHIFT ) ) ; # else ps_cabac -> u4_range = ( UWORD32 ) 510 ; BITS_GET ( ps_cabac -> u4_ofst , ps_bitstrm -> pu4_buf , ps_bitstrm -> u4_bit_ofst , ps_bitstrm -> u4_cur_word , ps_bitstrm -> u4_nxt_word , 9 ) ; # endif memcpy ( ps_cabac -> au1_ctxt_models , pu1_init_ctxt , IHEVC_CAB_CTXT_END ) ; DEBUG_RANGE_OFST ( ""init"" , ps_cabac -> u4_range , ps_cabac -> u4_ofst ) ; return ( ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ) ; }
",0,468
723,"static void on_page_prepare ( GtkNotebook * assistant , GtkWidget * page , gpointer user_data ) { if ( ! is_processing_finished ( ) ) { show_next_step_button ( ) ; clear_warnings ( ) ; } gtk_widget_hide ( g_btn_detail ) ; gtk_widget_hide ( g_btn_onfail ) ; if ( ! g_expert_mode ) gtk_widget_hide ( g_btn_repeat ) ; save_items_from_notepad ( ) ; save_text_from_text_view ( g_tv_comment , FILENAME_COMMENT ) ; if ( pages [ PAGENO_SUMMARY ] . page_widget == page ) { if ( ! g_expert_mode ) { int n = select_next_page_no ( pages [ PAGENO_SUMMARY ] . page_no , NULL ) ; log_info ( ""switchingtopage_no:%d"" , n ) ; gtk_notebook_set_current_page ( assistant , n ) ; return ; } } if ( pages [ PAGENO_EDIT_ELEMENTS ] . page_widget == page ) { if ( highlight_forbidden ( ) ) { add_sensitive_data_warning ( ) ; show_warnings ( ) ; gtk_expander_set_expanded ( g_exp_search , TRUE ) ; } else gtk_toggle_button_set_active ( GTK_TOGGLE_BUTTON ( g_rb_custom_search ) , TRUE ) ; show_warnings ( ) ; } if ( pages [ PAGENO_REVIEW_DATA ] . page_widget == page ) { update_ls_details_checkboxes ( g_event_selected ) ; gtk_widget_set_sensitive ( g_btn_next , gtk_toggle_button_get_active ( g_tb_approve_bt ) ) ; } if ( pages [ PAGENO_EDIT_COMMENT ] . page_widget == page ) { gtk_widget_show ( g_btn_detail ) ; gtk_widget_set_sensitive ( g_btn_next , false ) ; on_comment_changed ( gtk_text_view_
",0,510
724,"static long __media_device_enum_links ( struct media_device * mdev , struct media_links_enum * links ) { struct media_entity * entity ; entity = find_entity ( mdev , links -> entity ) ; if ( entity == NULL ) return - EINVAL ; if ( links -> pads ) { unsigned int p ; for ( p = 0 ; p < entity -> num_pads ; p ++ ) { struct media_pad_desc pad ; media_device_kpad_to_upad ( & entity -> pads [ p ] , & pad ) ; if ( copy_to_user ( & links -> pads [ p ] , & pad , sizeof ( pad ) ) ) return - EFAULT ; } } if ( links -> links ) { struct media_link_desc __user * ulink ; unsigned int l ; for ( l = 0 , ulink = links -> links ; l < entity -> num_links ; l ++ ) { struct media_link_desc link ; if ( entity -> links [ l ] . source -> entity != entity ) continue ; media_device_kpad_to_upad ( & entity -> links [ l ] . source , & link . source ) ; media_device_kpad_to_upad ( entity -> links [ l ] . sink , & link . sink ) ; link . flags = entity -> links [ l ] . flags ; if ( copy_to_user ( ulink , & link , sizeof ( * ulink ) ) ) return - EFAULT ; ulink ++ ; } } return 0 ; }
",0,335
725,"static int md_analyze_line ( MD_CTX * ctx , OFF beg , OFF * p_end , const MD_LINE_ANALYSIS * pivot_line , MD_LINE_ANALYSIS * line ) { unsigned total_indent = 0 ; int n_parents = 0 ; int n_brothers = 0 ; int n_children = 0 ; MD_CONTAINER container = { 0 } ; int prev_line_has_list_loosening_effect = ctx -> last_line_has_list_loosening_effect ; OFF off = beg ; OFF hr_killer = 0 ; int ret = 0 ; line -> indent = md_line_indentation ( ctx , total_indent , off , & off ) ; total_indent += line -> indent ; line -> beg = off ; while ( n_parents < ctx -> n_containers ) { MD_CONTAINER * c = & ctx -> containers [ n_parents ] ; if ( c -> ch == _T ( '>' ) && line -> indent < ctx -> code_indent_offset && off < ctx -> size && CH ( off ) == _T ( '>' ) ) { off ++ ; total_indent ++ ; line -> indent = md_line_indentation ( ctx , total_indent , off , & off ) ; total_indent += line -> indent ; if ( line -> indent > 0 ) line -> indent -- ; line -> beg = off ; } else if ( c -> ch != _T ( '>' ) && line -> indent >= c -> contents_indent ) { line -> indent -= c -> contents_indent ; } else { break ; } n_parents ++ ; } if ( off >= ctx -> size || ISNEWLINE ( off ) ) { if ( n_brothers + n_children == 0 ) { while ( n_parents < ctx -> n_containers && ctx -> containers [ n_parents ] . ch != _T ( '>' ) ) n_parents ++ ; } } while ( TRUE ) { if ( pivot_line -> type == MD_LINE_FENCEDCODE ) { line -> beg = off ; if ( line -> indent < ctx -> code_indent_offset ) { if ( md_is_closing_code_
",0,511
726,"static Image * ReadSUNImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define RMT_EQUAL_RGB 1 # define RMT_NONE 0 # define RMT_RAW 2 # define RT_STANDARD 1 # define RT_ENCODED 2 # define RT_FORMAT_RGB 3 typedef struct _SUNInfo { unsigned int magic , width , height , depth , length , type , maptype , maplength ; } SUNInfo ; Image * image ; int bit ; MagickBooleanType status ; MagickSizeType number_pixels ; register Quantum * q ; register ssize_t i , x ; register unsigned char * p ; size_t bytes_per_line , extent , height , length ; ssize_t count , y ; SUNInfo sun_info ; unsigned char * sun_data , * sun_pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) ResetMagickMemory ( & sun_info , 0 , sizeof ( sun_info ) ) ; sun_info . magic = ReadBlobMSBLong ( image ) ; do { if ( sun_info . magic != 0x59a66a95 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; sun_info . width = ReadBlobMSBLong ( image ) ; sun_info . height = ReadBlobMSBLong ( image ) ; sun_info . depth = ReadBlobMSBLong ( image ) ; sun_info . length = ReadBlobMSBLong ( image ) ; sun_info . type = ReadBlobMSBLong ( image ) ; sun_info . maptype
",0,511
727,"static krb5_error_code tgs_make_reply ( krb5_context context , krb5_kdc_configuration * config , KDC_REQ_BODY * b , krb5_const_principal tgt_name , const EncTicketPart * tgt , const krb5_keyblock * replykey , int rk_is_subkey , const EncryptionKey * serverkey , const krb5_keyblock * sessionkey , krb5_kvno kvno , AuthorizationData * auth_data , hdb_entry_ex * server , krb5_principal server_principal , const char * server_name , hdb_entry_ex * client , krb5_principal client_principal , hdb_entry_ex * krbtgt , krb5_enctype krbtgt_etype , krb5_principals spp , const krb5_data * rspac , const METHOD_DATA * enc_pa_data , const char * * e_text , krb5_data * reply ) { KDC_REP rep ; EncKDCRepPart ek ; EncTicketPart et ; KDCOptions f = b -> kdc_options ; krb5_error_code ret ; int is_weak = 0 ; memset ( & rep , 0 , sizeof ( rep ) ) ; memset ( & et , 0 , sizeof ( et ) ) ; memset ( & ek , 0 , sizeof ( ek ) ) ; rep . pvno = 5 ; rep . msg_type = krb_tgs_rep ; et . authtime = tgt -> authtime ; _kdc_fix_time ( & b -> till ) ; et . endtime = min ( tgt -> endtime , * b -> till ) ; ALLOC ( et . starttime ) ; * et . starttime = kdc_time ; ret = check_tgs_flags ( context , config , b , tgt , & et ) ; if ( ret ) goto out ; # define GLOBAL_FORCE_TRANSITED_CHECK ( config -> trpolicy == TRPOLICY_ALWAYS_CHECK ) # define GLOBAL_ALLOW_PER_PRINCIPAL ( config -> policy
",0,511
728,"static Image * ReadBMPImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { BMPInfo bmp_info ; Image * image ; MagickBooleanType status ; MagickOffsetType offset , start_position ; MemoryInfo * pixel_info ; Quantum index ; register Quantum * q ; register ssize_t i , x ; register unsigned char * p ; size_t bit , bytes_per_line , length ; ssize_t count , y ; unsigned char magick [ 12 ] , * pixels ; unsigned int blue , green , offset_bits , red ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) memset ( & bmp_info , 0 , sizeof ( bmp_info ) ) ; bmp_info . ba_offset = 0 ; start_position = 0 ; offset_bits = 0 ; count = ReadBlob ( image , 2 , magick ) ; if ( count != 2 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; do { PixelInfo quantum_bits ; PixelPacket shift ; start_position = TellBlob ( image ) - 2 ; bmp_info . ba_offset = 0 ; while ( LocaleNCompare ( ( char * ) magick , ""BA"" , 2 ) == 0 ) { bmp_info . file_size = ReadBlobLSBLong ( image ) ; bmp_info . ba_offset = ReadBlobLSBLong ( image ) ; bmp_info . offset_bits = ReadBlobLSBLong ( image ) ; count = ReadBlob ( image , 2 , magick ) ; if ( count != 2 ) break ; } if (
",0,511
729,"struct sock * dccp_v4_request_recv_sock ( struct sock * sk , struct sk_buff * skb , struct request_sock * req , struct dst_entry * dst ) { struct inet_request_sock * ireq ; struct inet_sock * newinet ; struct sock * newsk ; if ( sk_acceptq_is_full ( sk ) ) goto exit_overflow ; if ( dst == NULL && ( dst = inet_csk_route_req ( sk , req ) ) == NULL ) goto exit ; newsk = dccp_create_openreq_child ( sk , req , skb ) ; if ( newsk == NULL ) goto exit_nonewsk ; sk_setup_caps ( newsk , dst ) ; newinet = inet_sk ( newsk ) ; ireq = inet_rsk ( req ) ; newinet -> inet_daddr = ireq -> rmt_addr ; newinet -> inet_rcv_saddr = ireq -> loc_addr ; newinet -> inet_saddr = ireq -> loc_addr ; newinet -> opt = ireq -> opt ; ireq -> opt = NULL ; newinet -> mc_index = inet_iif ( skb ) ; newinet -> mc_ttl = ip_hdr ( skb ) -> ttl ; newinet -> inet_id = jiffies ; dccp_sync_mss ( newsk , dst_mtu ( dst ) ) ; if ( __inet_inherit_port ( sk , newsk ) < 0 ) { sock_put ( newsk ) ; goto exit ; } __inet_hash_nolisten ( newsk , NULL ) ; return newsk ; exit_overflow : NET_INC_STATS_BH ( sock_net ( sk ) , LINUX_MIB_LISTENOVERFLOWS ) ; exit_nonewsk : dst_release ( dst ) ; exit : NET_INC_STATS_BH ( sock_net ( sk ) , LINUX_MIB_LISTENDROPS ) ; return NULL ; }
",0,472
730,"void ParseNameValue ( const char * buffer , int bufsize , struct NameValueParserData * data ) { struct xmlparser parser ; memset ( data , 0 , sizeof ( struct NameValueParserData ) ) ; parser . xmlstart = buffer ; parser . xmlsize = bufsize ; parser . data = data ; parser . starteltfunc = NameValueParserStartElt ; parser . endeltfunc = NameValueParserEndElt ; parser . datafunc = NameValueParserGetData ; parser . attfunc = 0 ; parsexml ( & parser ) ; }
",1,121
731,"static void ip_cmsg_recv_checksum ( struct msghdr * msg , struct sk_buff * skb , int tlen , int offset ) { __wsum csum = skb -> csum ; if ( skb -> ip_summed != CHECKSUM_COMPLETE ) return ; if ( offset != 0 ) { int tend_off = skb_transport_offset ( skb ) + tlen ; csum = csum_sub ( csum , skb_checksum ( skb , tend_off , offset , 0 ) ) ; } put_cmsg ( msg , SOL_IP , IP_CHECKSUM , sizeof ( __wsum ) , & csum ) ; }
",1,157
732,"int kvm_iommu_map_pages ( struct kvm * kvm , struct kvm_memory_slot * slot ) { gfn_t gfn , end_gfn ; pfn_t pfn ; int r = 0 ; struct iommu_domain * domain = kvm -> arch . iommu_domain ; int flags ; if ( ! domain ) return 0 ; gfn = slot -> base_gfn ; end_gfn = gfn + slot -> npages ; flags = IOMMU_READ ; if ( ! ( slot -> flags & KVM_MEM_READONLY ) ) flags |= IOMMU_WRITE ; if ( ! kvm -> arch . iommu_noncoherent ) flags |= IOMMU_CACHE ; while ( gfn < end_gfn ) { unsigned long page_size ; if ( iommu_iova_to_phys ( domain , gfn_to_gpa ( gfn ) ) ) { gfn += 1 ; continue ; } page_size = kvm_host_page_size ( kvm , gfn ) ; while ( ( gfn + ( page_size >> PAGE_SHIFT ) ) > end_gfn ) page_size >>= 1 ; while ( ( gfn << PAGE_SHIFT ) & ( page_size - 1 ) ) page_size >>= 1 ; while ( __gfn_to_hva_memslot ( slot , gfn ) & ( page_size - 1 ) ) page_size >>= 1 ; pfn = kvm_pin_pages ( slot , gfn , page_size ) ; if ( is_error_noslot_pfn ( pfn ) ) { gfn += 1 ; continue ; } r = iommu_map ( domain , gfn_to_gpa ( gfn ) , pfn_to_hpa ( pfn ) , page_size , flags ) ; if ( r ) { printk ( KERN_ERR ""kvm_iommu_map_address:"" ""iommufailedtomappfn=%llx\\n"" , pfn ) ; kvm_unpin_pages ( kvm , pfn ) ; goto unmap_pages ; } gfn += page_size >> PAGE_SHIFT ; } return 0 ; unmap
",0,511
733,"static int ttusbdecfe_dvbs_diseqc_send_master_cmd ( struct dvb_frontend * fe , struct dvb_diseqc_master_cmd * cmd ) { struct ttusbdecfe_state * state = ( struct ttusbdecfe_state * ) fe -> demodulator_priv ; u8 b [ ] = { 0x00 , 0xff , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 } ; if ( cmd -> msg_len > sizeof ( b ) - 4 ) return - EINVAL ; memcpy ( & b [ 4 ] , cmd -> msg , cmd -> msg_len ) ; state -> config -> send_command ( fe , 0x72 , sizeof ( b ) - ( 6 - cmd -> msg_len ) , b , NULL , NULL ) ; return 0 ; }
",0,206
734,"void perf_event_disable ( struct perf_event * event ) { struct perf_event_context * ctx ; ctx = perf_event_ctx_lock ( event ) ; if ( ! ctx ) return ; retry : if ( ! task_function_call ( task , __perf_event_disable , event ) ) return ; raw_spin_lock_irq ( & ctx -> lock ) ; if ( event -> state == PERF_EVENT_STATE_ACTIVE ) { raw_spin_unlock_irq ( & ctx -> lock ) ; task = ctx -> task ; goto retry ; } if ( event -> state == PERF_EVENT_STATE_INACTIVE ) { update_group_times ( event ) ; event -> state = PERF_EVENT_STATE_OFF ; } raw_spin_unlock_irq ( & ctx -> lock ) ; }
",0,199
735,"static inline unsigned int ReadPropertyUnsignedLong ( const EndianType endian , const unsigned char * buffer ) { unsigned int value ; if ( endian == LSBEndian ) { value = ( unsigned int ) buffer [ 3 ] << 24 ) | ( buffer [ 2 ] << 16 ) | ( buffer [ 1 ] << 8 ) | ( buffer [ 0 ] ) ) ; return ( ( unsigned int ) ( value & 0xffffffff ) ) ; } value = ( unsigned int ) ( ( buffer [ 0 ] << 24 ; value |= ( unsigned int ) buffer [ 2 ] << 8 ) | buffer [ 3 ] ) ; return ( value & 0xffffffff ) ; }
",1,144
736,"static bool add_free_nid ( struct f2fs_sb_info * sbi , nid_t nid , bool build ) { struct f2fs_nm_info * nm_i = NM_I ( sbi ) ; struct free_nid * i , * e ; struct nat_entry * ne ; int err = - EINVAL ; bool ret = false ; if ( unlikely ( nid == 0 ) ) return false ; i = f2fs_kmem_cache_alloc ( free_nid_slab , GFP_NOFS ) ; i -> nid = nid ; i -> state = NID_NEW ; if ( radix_tree_preload ( GFP_NOFS ) ) goto err ; spin_lock ( & nm_i -> nid_list_lock ) ; err = __insert_nid_to_list ( sbi , i , FREE_NID_LIST , true ) ; spin_unlock ( & nm_i -> nid_list_lock ) ; radix_tree_preload_end ( ) ; if ( err ) { kmem_cache_free ( free_nid_slab , i ) ; return true ; } return true ; }
",0,268
737,"static void set_ppflags ( const vpx_codec_alg_priv_t * ctx , vp9_ppflags_t * flags ) { flags -> post_proc_flag = # if CONFIG_POSTPROC_VISUALIZER ( ctx -> dbg_color_ref_frame_flag ? VP9D_DEBUG_CLR_FRM_REF_BLKS : 0 ) | ( ctx -> dbg_color_mb_modes_flag ? VP9D_DEBUG_CLR_BLK_MODES : 0 ) | ( ctx -> dbg_color_b_modes_flag ? VP9D_DEBUG_CLR_BLK_MODES : 0 ) | ( ctx -> dbg_display_mv_flag ? VP9D_DEBUG_DRAW_MV : 0 ) | # endif ctx -> postproc_cfg . post_proc_flag ; flags -> deblocking_level = ctx -> postproc_cfg . deblocking_level ; flags -> noise_level = ctx -> postproc_cfg . noise_level ; flags -> display_ref_frame_flag = ctx -> dbg_color_ref_frame_flag ; flags -> display_mb_modes_flag = ctx -> dbg_color_mb_modes_flag ; flags -> display_b_modes_flag = ctx -> dbg_color_b_modes_flag ; flags -> display_mv_flag = ctx -> dbg_display_mv_flag ; # endif }
",0,343
738,"static int xen_netbk_get_extras ( struct xenvif * vif , struct xen_netif_extra_info * extras , int work_to_do ) { struct xen_netif_extra_info extra ; RING_IDX cons = vif -> tx . req_cons ; do { if ( unlikely ( work_to_do -- <= 0 ) ) { netdev_err ( vif -> dev , ""Missingextrainfo\\n"" ) ; netbk_fatal_tx_err ( vif ) ; return - EBADR ; } memcpy ( & extra , RING_GET_REQUEST ( & vif -> tx , cons ) , sizeof ( extra ) ) ; if ( unlikely ( ! extra . type || extra . type >= XEN_NETIF_EXTRA_TYPE_MAX ) ) { vif -> tx . req_cons = ++ cons ; netdev_err ( vif -> dev , ""Invalidextratype:%d\\n"" , extra . type ) ; netbk_fatal_tx_err ( vif ) ; return - EINVAL ; } memcpy ( & extras [ extra . type - 1 ] , & extra , sizeof ( extra ) ) ; vif -> tx . req_cons = ++ cons ; } while ( extra . flags & XEN_NETIF_EXTRA_FLAG_MORE ) ; return work_to_do ; }
",1,313
739,"static int key_notify_policy_flush ( const struct km_event * c ) { struct sk_buff * skb_out ; struct sadb_msg * hdr ; skb_out = alloc_skb ( sizeof ( struct sadb_msg ) + 16 , GFP_ATOMIC ) ; if ( ! skb_out ) return - ENOBUFS ; hdr = ( struct sadb_msg * ) skb_put ( skb_out , sizeof ( struct sadb_msg ) ) ; hdr -> sadb_msg_satype = SADB_SATYPE_UNSPEC ; hdr -> sadb_msg_len = ( sizeof ( struct sadb_msg ) / sizeof ( uint64_t ) ) ; pfkey_broadcast ( skb_out , GFP_ATOMIC , BROADCAST_ALL , NULL , c -> net ) ; return 0 ; }
",0,203
740,"static void snd_timer_user_ccallback ( struct snd_timer_instance * timeri , int event , struct timespec * tstamp , unsigned long resolution ) { struct snd_timer_user * tu = timeri -> callback_data ; struct snd_timer_tread r1 ; unsigned long flags ; if ( event >= SNDRV_TIMER_EVENT_START && event <= SNDRV_TIMER_EVENT_PAUSE ) tu -> tstamp = * tstamp ; if ( ( tu -> filter & ( 1 << event ) ) == 0 || ! tu -> tread ) return ; memset ( & r1 , 0 , sizeof ( r1 ) ) ; r1 . event = event ; r1 . tstamp = * tstamp ; r1 . val = resolution ; spin_lock_irqsave ( & tu -> qlock , flags ) ; snd_timer_user_append_to_tqueue ( tu , & r1 ) ; spin_unlock_irqrestore ( & tu -> qlock , flags ) ; kill_fasync ( & tu -> fasync , SIGIO , POLL_IN ) ; wake_up ( & tu -> qchange_sleep ) ; }
",1,276
741,"static int b_unpack ( lua_State * L ) { Header h ; const char * fmt = luaL_checkstring ( L , 1 ) ; size_t ld ; const char * data = luaL_checklstring ( L , 2 , & ld ) ; size_t pos = luaL_optinteger ( L , 3 , 1 ) - 1 ; int n = 0 ; defaultoptions ( & h ) ; while ( * fmt ) { int opt = * fmt ++ ; size_t size = optsize ( L , 0 , & fmt ) ; pos += gettoalign ( pos , & h , opt , size ) ; n -- ; luaL_argcheck ( L , pos + size <= ld , 2 , ""datastringtooshort"" ) ; luaL_checkstack ( L , 1 , ""toomanyresults"" ) ; switch ( opt ) { case 'b' : case 'B' : case 'h' : case 'H' : case 'l' : case 'L' : case 'T' : case 'i' : case 'I' : { int issigned = islower ( opt ) ; lua_Number res = getinteger ( data + pos , h . endian , issigned , size ) ; lua_pushnumber ( L , res ) ; n -- ; break ; } case 'x' : { break ; } case 'f' : { float f ; memcpy ( & f , data + pos , size ) ; correctbytes ( ( char * ) & f , sizeof ( f ) , h . endian ) ; lua_pushnumber ( L , f ) ; n -- ; break ; } case 'd' : { double d ; memcpy ( & d , data + pos , size ) ; correctbytes ( ( char * ) & d , sizeof ( d ) , h . endian ) ; lua_pushnumber ( L , d ) ; n -- ; break ; } case 'c' : { if ( size == 0 ) { if ( ! lua_isnumber ( L , - 1 ) ) luaL_error ( L , ""format\'c0\'needsaprevioussize"" ) ; size = lua_tonumber ( L , - 1 ) ; lua_pop ( L , 1 ) ; lua_push ( L , - 1 ) ; }
",0,511
742,"void olsr_print ( netdissect_options * ndo , const u_char * pptr , u_int length , int is_ipv6 ) { union { const struct olsr_common * common ; const struct olsr_msg4 * msg4 ; const struct olsr_msg6 * msg6 ; const struct olsr_hello * hello ; const struct olsr_hello_link * hello_link ; const struct olsr_tc * tc ; const struct olsr_hna4 * hna ; } ptr ; u_int msg_type , msg_len , msg_tlen , hello_len ; uint16_t name_entry_type , name_entry_len ; u_int name_entry_padding ; uint8_t link_type , neighbor_type ; const u_char * tptr , * msg_data ; tptr = pptr ; if ( length < sizeof ( struct olsr_common ) ) { goto trunc ; } ND_TCHECK2 ( * tptr , sizeof ( struct olsr_common ) ) ; ptr . common = ( const struct olsr_common * ) tptr ; length = min ( length , EXTRACT_16BITS ( ptr . common -> packet_len ) ) ; ND_PRINT ( ( ndo , ""OLSRv%i,seq0x%04x,length%u"" , ( is_ipv6 == 0 ) ? 4 : 6 , EXTRACT_16BITS ( ptr . common -> packet_seq ) , length ) ) ; tptr += sizeof ( struct olsr_common ) ; if ( ndo -> ndo_vflag < 1 ) { return ; } while ( tptr < ( pptr + length ) ) { union { const struct olsr_msg4 * v4 ; const struct olsr_msg6 * v6 ; } msgptr ; int msg_len_valid = 0 ; if ( length > sizeof ( struct olsr_msg4 ) - 4 ) { return ; } ND_TCHECK2 ( * tptr , sizeof ( struct olsr_msg4 ) ) ; msg_len_valid = sizeof ( msgptr . msg_len ) ; if ( is_ipv6 ) { msgptr . v6 = ( const struct olsr_msg6 * )
",0,511
743,"static void oz_usb_handle_ep_data ( struct oz_usb_ctx * usb_ctx , struct oz_usb_hdr * usb_hdr , int len ) { struct oz_data * data_hdr = ( struct oz_data * ) usb_hdr ; switch ( data_hdr -> format ) { case OZ_DATA_F_MULTIPLE_FIXED : { struct oz_multiple_fixed * body = ( struct oz_multiple_fixed * ) data_hdr ; u8 * data = body -> data ; unsigned int n ; if ( ! body -> unit_size ) break ; n = ( len - sizeof ( struct oz_multiple_fixed ) + 1 ) / body -> unit_size ; while ( n -- ) { oz_hcd_data_ind ( usb_ctx -> hport , body -> endpoint , data , body -> unit_size ) ; data += body -> unit_size ; } } break ; case OZ_DATA_F_ISOC_FIXED : { struct oz_isoc_fixed * body = ( struct oz_isoc_fixed * ) data_hdr ; int data_len = len - sizeof ( struct oz_isoc_fixed ) + 1 ; int unit_size = body -> unit_size ; u8 * data = body -> data ; int count ; int i ; if ( ! unit_size ) break ; count = data_len / unit_size ; for ( i = 0 ; i < count ; i ++ ) { oz_hcd_data_ind ( usb_ctx -> hport , body -> endpoint , data , unit_size ) ; data += unit_size ; } } break ; } }
",0,366
744,"int vp8_receive_raw_frame ( VP8_COMP * cpi , unsigned int frame_flags , YV12_BUFFER_CONFIG * sd , int64_t time_stamp , int64_t end_time ) { VP8_COMMON * cm = & cpi -> common ; # endif struct vpx_usec_timer timer ; int res = 0 ; # if HAVE_NEON # if CONFIG_RUNTIME_CPU_DETECT if ( cm -> cpu_caps & HAS_NEON ) # endif { vp8_push_neon ( store_reg ) ; } # endif vpx_usec_timer_start ( & timer ) ; if ( sd -> y_width != cpi -> oxcf . Width || sd -> y_height != cpi -> oxcf . Height ) { assert ( cpi -> oxcf . lag_in_frames < 2 ) ; dealloc_raw_frame_buffers ( cpi ) ; alloc_raw_frame_buffers ( cpi ) ; } if ( vp8_lookahead_push ( cpi -> lookahead , sd , time_stamp , end_time , frame_flags , cpi -> active_map_enabled ? cpi -> active_map : NULL ) ) res = - 1 ; vpx_usec_timer_mark ( & timer ) ; cpi -> time_receive_data += vpx_usec_timer_elapsed ( & timer ) ; # if HAVE_NEON # if CONFIG_RUNTIME_CPU_DETECT if ( cm -> cpu_caps & HAS_NEON ) # endif { vp8_pop_neon ( store_reg ) ; } # endif return res ; }
",0,382
745,"static int store_xauthority ( void ) { fs_build_mnt_dir ( ) ; char * src ; char * dest = RUN_XAUTHORITY_FILE ; FILE * fp = fopen ( dest , ""w"" ) ; if ( fp ) { fprintf ( fp , ""\\n"" ) ; SET_PERMS_STREAM ( fp , getuid ( ) , getgid ( ) , 0600 ) ; fclose ( fp ) ; } if ( asprintf ( & src , ""%s/.Xauthority"" , cfg . homedir ) == - 1 ) errExit ( ""asprintf"" ) ; struct stat s ; if ( stat ( src , & s ) == 0 ) { if ( is_link ( src ) ) { char * rp = realpath ( src , NULL ) ; fprintf ( stderr , ""Error:invalid.Xauthorityfile\\n"" ) ; exit ( 1 ) ; } pid_t child = fork ( ) ; if ( child < 0 ) errExit ( ""fork"" ) ; if ( child == 0 ) { drop_privs ( 0 ) ; int rv = copy_file ( src , dest ) ; if ( rv ) fprintf ( stderr , ""Warning:cannottransfer.Xauthorityinprivatehomedirectory\\n"" ) ; else { fs_logger2 ( ""clone"" , dest ) ; } _exit ( 0 ) ; } waitpid ( child , NULL , 0 ) ; if ( chown ( dest , getuid ( ) , getgid ( ) ) == - 1 ) errExit ( ""fchown"" ) ; if ( chmod ( dest , 0600 ) == - 1 ) errExit ( ""fchmod"" ) ; return 1 ; } return 0 ; }
",0,395
746,"static void cmd_parse_status ( struct ImapData * idata , char * s ) { char * value = NULL ; struct Buffy * inc = NULL ; struct ImapMbox mx ; struct ImapStatus * status = NULL ; unsigned int olduv , oldun ; unsigned int litlen ; short new = 0 ; short new_msg_count = 0 ; char * mailbox = imap_next_word ( s ) ; if ( imap_get_literal_count ( mailbox , & litlen ) == 0 ) { if ( imap_cmd_step ( idata ) != IMAP_CMD_CONTINUE ) { idata -> status = IMAP_FATAL ; return ; } if ( strlen ( idata -> buf ) < litlen ) { mutt_debug ( 1 , ""ErrorparsingSTATUSmailbox\\n"" ) ; return ; } mailbox = idata -> buf ; s = mailbox + litlen ; * s = '\\0' ; s ++ ; SKIPWS ( s ) ; } else { s = imap_next_word ( mailbox ) ; * ( s - 1 ) = '\\0' ; imap_unmunge_mbox_name ( idata , mailbox ) ; } status = imap_mboxcache_get ( idata , mailbox , 1 ) ; olduv = status -> uidvalidity ; oldun = status -> uidnext ; if ( * s ++ != '(' ) { mutt_debug ( 1 , ""ErrorparsingSTATUS\\n"" ) ; return ; } while ( * s && * s != ')' ) { value = imap_next_word ( s ) ; errno = 0 ; const unsigned long ulcount = strtoul ( value , & value , 10 ) ; if ( ( ( errno == ERANGE ) && ( ulcount == ULONG_MAX ) ) || ( ( unsigned int ) ulcount != ulcount ) ) { mutt_debug ( 1 , ""ErrorparsingSTATUSnumber\\n"" ) ; return ; } const unsigned int count = ( unsigned int ) ulcount ; if ( mutt_str_strncmp ( ""MESSAGES"" , s , 8 ) == 0 ) { status -> messages = count ; new_msg_count = 1 ; } else if ( mutt_str_strncmp (
",0,511
747,"int sas_discover_end_dev ( struct domain_device * dev ) { int res ; res = sas_notify_lldd_dev_found ( dev ) ; if ( res ) return res ; return 0 ; }
",1,52
748,"static int ext4_ext_split ( handle_t * handle , struct inode * inode , unsigned int flags , struct ext4_ext_path * path , struct ext4_extent * newext , int at ) { struct buffer_head * bh = NULL ; int depth = ext_depth ( inode ) ; struct ext4_extent_header * neh ; struct ext4_extent_idx * fidx ; int i = at , k , m , a ; ext4_fsblk_t newblock , oldblock ; __le32 border ; ext4_fsblk_t * ablocks = NULL ; int err = 0 ; if ( unlikely ( path [ depth ] . p_ext > EXT_MAX_EXTENT ( path [ depth ] . p_hdr ) ) ) { EXT4_ERROR_INODE ( inode , ""p_ext>EXT_MAX_EXTENT!"" ) ; return - EFSCORRUPTED ; } if ( path [ depth ] . p_ext != EXT_MAX_EXTENT ( path [ depth ] . p_hdr ) ) { border = path [ depth ] . p_ext [ 1 ] . ee_block ; ext_debug ( ""leafwillbesplit."" ""nextleafstartsat%d\\n"" , le32_to_cpu ( border ) ) ; } else { border = newext -> ee_block ; ext_debug ( ""leafwillbeadded."" ""nextleafstartsat%d\\n"" , le32_to_cpu ( border ) ) ; } ext_locks = kcalloc ( depth , sizeof ( ext4_fsblk_t ) , GFP_NOFS ) ; if ( ! ext_locks ) return - ENOMEM ; ext_debug ( ""allocate%dblocksforindexes/leaf\\n"" , depth - at ) ; for ( a = 0 ; a < depth - at ; a ++ ) { newblock = ext4_ext_new_meta_block ( handle , inode , path , newext , & err , flags ) ; if ( newblock == 0 ) goto cleanup ; ablocks [ a ] = newblock ; } newblock = ablocks [ -- a ] ; if ( unlikely ( newblock == 0 ) ) { EXT4_ERROR_INODE ( inode , ""new
",0,511
749,"WORD32 ixheaacd_qmf_hbe_data_reinit ( ia_esbr_hbe_txposer_struct * ptr_hbe_txposer , WORD16 * p_freq_band_tab [ 2 ] , WORD16 * p_num_sfb , WORD32 upsamp_4_flag ) { WORD32 synth_size , sfb , patch , stop_patch ; if ( ptr_hbe_txposer != NULL ) { ptr_hbe_txposer -> start_band = p_freq_band_tab [ LOW ] [ 0 ] ; ptr_hbe_txposer -> end_band = p_freq_band_tab [ LOW ] [ p_num_sfb [ LOW ] ] ; ptr_hbe_txposer -> synth_size = 4 * ( ( ptr_hbe_txposer -> start_band + 4 ) / 8 + 1 ) ; ptr_hbe_txposer -> k_start = ixheaacd_start_subband2kL_tbl [ ptr_hbe_txposer -> start_band ] ; ptr_hbe_txposer -> upsamp_4_flag = upsamp_4_flag ; if ( upsamp_4_flag ) { if ( ptr_hbe_txposer -> k_start + ptr_hbe_txposer -> synth_size > 16 ) ptr_hbe_txposer -> k_start = 16 - ptr_hbe_txposer -> synth_size ; } else if ( ptr_hbe_txposer -> core_frame_length == 768 ) { if ( ptr_hbe_txposer -> k_start + ptr_hbe_txposer -> synth_size > 24 ) ptr_hbe_txposer -> k_start = 24 - ptr_hbe_txposer -> synth_size ; } memset ( ptr_hbe_txposer -> synth_buf , 0 , 1280 * sizeof ( FLOAT32 ) ) ; synth_size = ptr_hbe_txposer -> synth_size ; ptr_hbe_txposer -> synth_buf_offset = 18 * synth_size ; switch ( synth_size ) { case 4 : ptr_
",0,511
750,"static int tga_readheader ( FILE * fp , unsigned int * bits_per_pixel , unsigned int * width , unsigned int * height , int * flip_image ) { int palette_size ; unsigned char tga [ TGA_HEADER_SIZE ] ; unsigned char id_len , image_type ; unsigned char pixel_depth , image_desc ; unsigned short cmap_len , cmap_entry_size ; unsigned short image_w , image_h ; if ( ! bits_per_pixel || ! width || ! height || ! flip_image ) { return 0 ; } if ( fread ( tga , TGA_HEADER_SIZE , 1 , fp ) != 1 ) { fprintf ( stderr , ""\\nError:freadreturnanumberofelementdifferentfromtheexpected.\\n"" ) ; return 0 ; } id_len = tga [ 0 ] ; image_type = tga [ 2 ] ; cmap_len = get_ushort ( & tga [ 5 ] ) ; cmap_entry_size = tga [ 7 ] ; # if 0 x_origin = get_ushort ( & tga [ 8 ] ) ; y_origin = get_ushort ( & tga [ 10 ] ) ; # endif image_w = get_ushort ( & tga [ 12 ] ) ; image_h = get_ushort ( & tga [ 14 ] ) ; pixel_depth = tga [ 16 ] ; image_desc = tga [ 17 ] ; * bits_per_pixel = ( unsigned int ) pixel_depth ; * width = ( unsigned int ) image_w ; * height = ( unsigned int ) image_h ; if ( id_len ) { unsigned char * id = ( unsigned char * ) malloc ( id_len ) ; if ( id == 0 ) { fprintf ( stderr , ""tga_readheader:memoryout\\n"" ) ; return 0 ; } if ( ! fread ( id , id_len , 1 , fp ) ) { fprintf ( stderr , ""\\nError:freadreturnanumberofelementdifferentfromtheexpected.\\n"" ) ; free ( id ) ; return 0 ; } free ( id ) ; } if ( image_type > 8 ) { fprintf ( stderr , ""tga_readheader:memory
",0,511
751,"static ssize_t ucma_write ( struct file * filp , const char __user * buf , size_t len , loff_t * pos ) { struct ucma_file * file = filp -> private_data ; struct rdma_ucm_cmd_hdr hdr ; ssize_t ret ; if ( WARN_ON_ONCE ( ! ib_safe_file_access ( filp ) ) ) return - EACCES ; if ( len < sizeof ( hdr ) ) return - EINVAL ; if ( copy_from_user ( & hdr , buf , sizeof ( hdr ) ) ) return - EFAULT ; if ( hdr . cmd >= ARRAY_SIZE ( ucma_cmd_table ) ) return - EINVAL ; if ( hdr . in + sizeof ( hdr ) > len ) return - EINVAL ; if ( ! ucma_cmd_table [ hdr . cmd ] ) return - ENOSYS ; ret = ucma_cmd_table [ hdr . cmd ] ( file , buf + sizeof ( hdr ) , hdr . in , hdr . out ) ; if ( ! ret ) ret = len ; return ret ; }
",1,267
752,"static void sample_to_timespec ( const clockid_t which_clock , union cpu_time_count cpu , struct timespec * tp ) { if ( CPUCLOCK_WHICH ( which_clock ) == CPUCLOCK_SCHED ) * tp = ns_to_timespec ( cpu . sched , NSEC_PER_SEC , & tp -> tv_nsec ) ; }
",1,90
753,"uint32 TIFFNumberOfStrips ( TIFF * tif ) { TIFFDirectory * td = & tif -> tif_dir ; uint32 nstrips ; nstrips = ( td -> td_rowsperstrip == ( uint32 ) - 1 ? 1 : TIFFhowmany_32 ( td -> td_imagelength , td -> td_rowsperstrip ) ) ; if ( td -> td_planarconfig == PLANARCONFIG_SEPARATE ) nstrips = _TIFFMultiply32 ( tif , nstrips , ( uint32 ) td -> td_samplesperpixel , ""TIFFNumberOfStrips"" ) ; return ( nstrips ) ; }
",1,156
754,"int rds_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t size , int msg_flags ) { struct sock * sk = sock -> sk ; struct rds_sock * rs = rds_sk_to_rs ( sk ) ; long timeo ; int ret = 0 , nonblock = msg_flags & MSG_DONTWAIT ; struct sockaddr_in * sin ; struct rds_incoming * inc = NULL ; timeo = sock_rcvtimeo ( sk , nonblock ) ; rdsdebug ( ""size%zuflags0x%xtimeo%ld\\n"" , size , msg_flags , timeo ) ; msg -> msg_namelen = 0 ; if ( msg_flags & MSG_OOB ) goto out ; while ( 1 ) { if ( ! list_empty ( & rs -> rs_notify_queue ) ) { ret = rds_notify_queue_get ( rs , msg ) ; break ; } if ( rs -> rs_cong_notify ) { ret = rds_notify_cong ( rs , msg ) ; break ; } if ( ! rds_next_incoming ( rs , & inc ) ) { if ( nonblock ) { ret = - EAGAIN ; break ; } timeo = wait_event_interruptible_timeout ( * sk_sleep ( sk ) , ( ! list_empty ( & rs -> rs_notify_queue ) || rs -> rs_cong_notify || rds_next_incoming ( rs , & inc ) ) , timeo ) ; rdsdebug ( ""recvmsgwokeinc%ptimeo%ld\\n"" , inc , timeo ) ; if ( timeo > 0 || timeo == MAX_SCHEDULE_TIMEOUT ) continue ; ret = timeo ; if ( ret == 0 ) ret = - ETIMEDOUT ; break ; } rdsdebug ( ""copyinginc%pfrom%pI4:%utouser\\n"" , inc , & inc -> i_conn -> c_faddr , ntohs ( inc -> i_hdr . h_sport ) ) ; ret = inc -> i_conn -> c_trans -> inc_copy_to_user ( inc , msg -> msg_cons
",0,511
755,"static authz_status lua_authz_check ( request_rec * r , const char * require_line , const void * parsed_require_line ) { apr_pool_t * pool ; ap_lua_vm_spec * spec ; lua_State * L ; ap_lua_server_cfg * server_cfg = ap_get_module_config ( r -> server -> module_config , & lua_module ) ; const ap_lua_dir_cfg * cfg = ap_get_module_config ( r -> per_dir_config , & lua_module ) ; const lua_authz_provider_spec * prov_spec = parsed_require_line ; int result ; int nargs = 0 ; spec = create_vm_spec ( & pool , r , cfg , server_cfg , prov_spec -> file_name , NULL , 0 , prov_spec -> function_name , ""authzprovider"" ) ; L = ap_lua_get_lua_state ( pool , spec , r ) ; if ( L == NULL ) { ap_log_rerror ( APLOG_MARK , APLOG_ERR , 0 , r , APLOGNO ( 02314 ) ""UnabletocompileVMforauthzprovider%s"" , prov_spec -> name ) ; return AUTHZ_GENERAL_ERROR ; } lua_getglobal ( L , prov_spec -> function_name ) ; if ( ! lua_isfunction ( L , - 1 ) ) { ap_log_rerror ( APLOG_MARK , APLOG_CRIT , 0 , r , APLOGNO ( 02319 ) ""Unabletofindentryfunction\'%s\'in%s(notavalidfunction)"" , prov_spec -> function_name , prov_spec -> file_name ) ; ap_lua_release_state ( L , spec , r ) ; return AUTHZ_GENERAL_ERROR ; } ap_lua_run_lua_request ( L , r ) ; if ( L == NULL ) { ap_log_rerror ( APLOG_MARK , APLOG_CRIT , 0 , r , APLOGNO ( 02319 ) ""Unabletofindentryfunction\'%s\'in%s(notavalidfunction)"" , prov_spec -> function_name , prov
",0,511
756,"int expand_downwards ( struct vm_area_struct * vma , unsigned long address ) { struct mm_struct * mm = vma -> vm_mm ; struct vm_area_struct * prev ; int error = 0 ; address &= PAGE_MASK ; if ( address < mmap_min_addr ) return - EPERM ; prev = vma -> vm_prev ; if ( prev && ! ( prev -> vm_flags & VM_GROWSDOWN ) && ( prev -> vm_flags & ( VM_WRITE | VM_READ | VM_EXEC ) ) ) { if ( address - prev -> vm_end < stack_guard_gap ) return - ENOMEM ; } if ( unlikely ( anon_vma_prepare ( vma ) ) ) return - ENOMEM ; anon_vma_lock_write ( vma -> anon_vma ) ; if ( address < vma -> vm_start ) { unsigned long size , grow ; size = vma -> vm_end - address ; grow = ( vma -> vm_start - address ) >> PAGE_SHIFT ; error = - ENOMEM ; if ( grow <= vma -> vm_pgoff ) { error = acct_stack_growth ( vma , size , grow ) ; if ( ! error ) { spin_lock ( & mm -> page_table_lock ) ; if ( vma -> vm_flags & VM_LOCKED ) mm -> locked_vm += grow ; vm_stat_account ( mm , vma -> vm_flags , grow ) ; anon_vma_interval_tree_pre_update_vma ( vma ) ; vma -> vm_start = address ; vma -> vm_pgoff -= grow ; anon_vma_interval_tree_post_update_vma ( vma ) ; vma_gap_update ( vma ) ; spin_unlock ( & mm -> page_table_lock ) ; perf_event_mmap ( vma ) ; } } } anon_vma_unlock_write ( vma -> anon_vma ) ; khugepaged_enter_vma_merge ( vma , vma -> vm_flags ) ; validate_mm ( mm ) ; return error ; }
",1,501
757,"int xfs_set_acl ( struct inode * inode , struct posix_acl * acl , int type ) { int error = 0 ; if ( ! acl ) goto set_acl ; error = - E2BIG ; if ( acl -> a_count > XFS_ACL_MAX_ENTRIES ( XFS_M ( inode -> i_sb ) ) ) return error ; if ( type == ACL_TYPE_ACCESS ) { umode_t mode ; error = posix_acl_equiv_mode ( acl , & mode , & acl ) ; if ( error ) return error ; } error = xfs_set_mode ( inode , mode ) ; if ( error ) return error ; } set_acl : return __xfs_set_acl ( inode , type , acl ) ; }
",1,186
758,"static int mount_entry ( const char * fsname , const char * target , const char * fstype , unsigned long mountflags , const char * data , int optional , uid_t * rootuid ) { # ifdef HAVE_STATVFS struct statvfs sb ; # endif if ( mount ( fsname , target , fstype , mountflags & ~ MS_REMOUNT , data ) ) { if ( optional ) { INFO ( ""failedtomount\'%s\'on\'%s\'(optional):%s"" , fsname , target , strerror ( errno ) ) ; return 0 ; } else { SYSERROR ( ""failedtomount\'%s\'on\'%s\'"" , fsname , target ) ; return - 1 ; } } if ( ( mountflags & MS_REMOUNT ) || ( mountflags & MS_BIND ) ) { DEBUG ( ""remounting%son%storespectbindorremountoptions"" , fsname ? fsname : ""(none)"" , target ? target : ""(none)"" ) ; unsigned long rqd_flags = 0 ; if ( mountflags & MS_RDONLY ) rqd_flags |= MS_RDONLY ; # ifdef HAVE_STATVFS if ( statvfs ( fsname , & sb ) == 0 ) { unsigned long required_flags = rqd_flags ; if ( sb . f_flag & MS_NOSUID ) required_flags |= MS_NOSUID ; if ( sb . f_flag & MS_NODEV ) required_flags |= MS_NODEV ; if ( sb . f_flag & MS_RDONLY ) required_flags |= MS_RDONLY ; if ( sb . f_flag & MS_NOEXEC ) required_flags |= MS_NOEXEC ; DEBUG ( ""(atremount)flagsfor%swas%lu,requiredextraflagsare%lu"" , fsname , sb . f_flag , required_flags ) ; if ( ! ( mountflags & MS_REMOUNT ) ) { if ( ! ( required_flags & ~ mountflags ) && rqd_flags == 0 ) { DEBUG ( ""mountflagsalreadywas%lu,skippingremount"" , mountflags ) ; goto skipremount ; } } mountflags |= required_
",0,511
759,"static Image * ReadDPXImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { char magick [ 4 ] , value [ MaxTextExtent ] ; DPXInfo dpx ; Image * image ; MagickBooleanType status ; MagickOffsetType offset ; QuantumInfo * quantum_info ; QuantumType quantum_type ; register ssize_t i ; size_t extent , samples_per_pixel ; ssize_t count , n , row , y ; unsigned char component_type ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } offset = 0 ; count = ReadBlob ( image , 4 , ( unsigned char * ) magick ) ; offset += count ; if ( ( count != 4 ) || ( ( LocaleNCompare ( magick , ""SDPX"" , 4 ) != 0 ) && ( LocaleNCompare ( ( char * ) magick , ""XPDS"" , 4 ) != 0 ) ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; image -> endian = LSBEndian ; if ( LocaleNCompare ( magick , ""SDPX"" , 4 ) == 0 ) image -> endian = MSBEndian ; ( void ) ResetMagickMemory ( & dpx , 0 , sizeof ( dpx ) ) ; dpx . file . image_offset = ReadBlobLong ( image ) ; offset += 4 ; offset += ReadBlob ( image , sizeof ( dpx . file . version ) , ( unsigned char * ) dpx . file . version ) ; ( void ) FormatImageProperty ( image , ""dpx:file.version"" , ""%.8s"" , dpx . file . version ) ; d
",0,511
760,"void posixtimer_rearm ( struct siginfo * info ) { struct k_itimer * timr ; unsigned long flags ; timr = lock_timer ( info -> si_tid , & flags ) ; if ( ! timr ) return ; if ( timr -> it_requeue_pending == info -> si_sys_private ) { timr -> kclock -> timer_rearm ( timr ) ; timr -> it_active = 1 ; timr -> it_overrun_last = timr -> it_overrun ; timr -> it_overrun = - 1LL ; ++ timr -> it_requeue_pending ; info -> si_overrun = timer_overrun_to_int ( timr , info -> si_overrun ) ; } unlock_timer ( timr , flags ) ; }
",1,182
761,"int credential_from_url_gently ( struct credential * c , const char * url , int quiet ) { const char * at , * colon , * cp , * slash , * host , * proto_end ; credential_clear ( c ) ; proto_end = strstr ( url , ""://"" ) ; if ( ! proto_end ) return 0 ; cp = proto_end + 3 ; at = strchr ( cp , '@' ) ; colon = strchr ( cp , ':' ) ; slash = strchrnul ( cp , '/' ) ; if ( ! at || slash <= at ) { host = cp ; } else if ( ! colon || at <= colon ) { c -> username = url_decode_mem ( cp , at - cp ) ; host = at + 1 ; } else { c -> username = url_decode_mem ( cp , colon - cp ) ; c -> password = url_decode_mem ( colon + 1 , at - ( colon + 1 ) ) ; host = at + 1 ; } if ( proto_end - url > 0 ) c -> protocol = xmemdupz ( url , proto_end - url ) ; c -> host = url_decode_mem ( host , slash - host ) ; while ( * slash == '/' ) slash ++ ; if ( * slash ) { char * p ; c -> path = url_decode ( slash ) ; p = c -> path + strlen ( c -> path ) - 1 ; while ( p > c -> path && * p == '/' ) * p -- = '\\0' ; } if ( check_url_component ( url , quiet , ""username"" , c -> username ) < 0 || check_url_component ( url , quiet , ""password"" , c -> password ) < 0 || check_url_component ( url , quiet , ""protocol"" , c -> protocol ) < 0 || check_url_component ( url , quiet , ""host"" , c -> host ) < 0 || check_url_component ( url , quiet , ""path"" , c -> path ) < 0 ) return - 1 ; return 0 ; }
",0,461
762,"bool __net_get_random_once ( void * buf , int nbytes , bool * done , struct static_key * once_key ) { static DEFINE_SPINLOCK ( lock ) ; unsigned long flags ; spin_lock_irqsave ( & lock , flags ) ; if ( * done ) { spin_unlock_irqrestore ( & lock , flags ) ; return false ; } get_random_bytes ( buf , nbytes ) ; * done = true ; spin_unlock_irqrestore ( & lock , flags ) ; __net_random_once_disable_jump ( once_key ) ; return true ; }
",1,141
763,"static void ffs_user_copy_worker ( struct work_struct * work ) { struct ffs_io_data * io_data = container_of ( work , struct ffs_io_data , work ) ; int ret = io_data -> req -> status ? io_data -> req -> status : io_data -> req -> actual ; io_data -> mm -> kiocb -> ki_complete ( io_data -> kiocb , ret , ret ) ; if ( io_data -> ffs -> ffs_eventfd && ! ( io_data -> kiocb -> ki_flags & IOCB_EVENTFD ) ) eventfd_signal ( io_data -> ffs -> ffs_eventfd , 1 ) ; usb_ep_free_request ( io_data -> ep , io_data -> req ) ; io_data -> kiocb -> private = NULL ; if ( io_data -> read ) kfree ( io_data -> to_free ) ; kfree ( io_data -> buf ) ; kfree ( io_data ) ; }
",0,234
764,"int ip_forward ( struct sk_buff * skb ) { u32 mtu ; struct iphdr * iph ; struct rtable * rt ; struct ip_options * opt = & ( IPCB ( skb ) -> opt ) ; if ( IPCB ( skb ) -> flags & IPSKB_DOREDIRECT && ! opt -> srr && ! skb_sec_path ( skb ) ) ip_rt_send_redirect ( skb ) ; skb -> priority = IPCB_PRIORITY_HIGH ; skb_forward_csum ( skb ) ; if ( ip_hdr ( skb ) -> ttl <= 1 ) goto too_many_hops ; if ( ! xfrm4_route_forward ( skb ) ) goto drop ; rt = skb_rtable ( skb ) ; if ( opt -> is_strictroute && rt -> rt_uses_gateway ) goto sr_failed ; IPCB ( skb ) -> flags |= IPSKB_FORWARDED ; mtu = ip_dst_mtu_maybe_forward ( & rt -> dst , true ) ; if ( ! ip_may_fragment ( skb ) && ip_exceeds_mtu ( skb , mtu ) ) { IP_INC_STATS ( dev_net ( rt -> dst . dev ) , IPSTATS_MIB_FRAGFAILS ) ; icmp_send ( skb , ICMP_DEST_UNREACH , ICMP_FRAG_NEEDED , htonl ( mtu ) ) ; goto drop ; } if ( skb_cow ( skb , LL_RESERVED_SPACE ( rt -> dst . dev ) + rt -> dst . header_len ) ) goto drop ; iph = ip_hdr ( skb ) ; ip_decrease_ttl ( iph ) ; if ( rt -> rt_flags & RTCF_DOREDIRECT && ! opt -> srr && ! skb_sec_path ( skb ) ) ip_rt_send_redirect ( skb ) ; skb -> priority = IPCB_PRIORITY_HIGH ; skb_forward_csum ( skb ) ; if ( ip_h
",0,511
765,"static void ikev2_parent_inR1outI2_continue ( struct pluto_crypto_req_cont * pcrc , struct pluto_crypto_req * r , err_t ugh ) { struct dh_continuation * dh = ( struct dh_continuation * ) pcrc ; struct msg_digest * md = dh -> md ; struct state * const st = md -> st ; stf_status e ; DBG ( DBG_CONTROLMORE , DBG_log ( ""ikev2parentinR1outI2:calculatingg^{xy},sendingI2"" ) ) ; if ( st == NULL ) { loglog ( RC_LOG_SERIOUS , ""%s:Requestwasdisconnectedfromstate"" , __FUNCTION__ ) ; if ( dh -> md ) release_md ( dh -> md ) ; return ; } passert ( ugh == NULL ) ; passert ( cur_state == NULL ) ; passert ( st != NULL ) ; passert ( st -> st_suspended_md == dh -> md ) ; set_suspended ( st , NULL ) ; set_cur_state ( st ) ; st -> st_calculating = FALSE ; e = ikev2_parent_inR1outI2_tail ( pcrc , r ) ; if ( dh -> md != NULL ) { complete_v2_state_transition ( & dh -> md , e ) ; if ( dh -> md ) release_md ( dh -> md ) ; } reset_globals ( ) ; }
",1,344
766,"static int trusted_update ( struct key * key , struct key_preparsed_payload * prep ) { struct trusted_key_payload * p = key -> payload . data [ 0 ] ; struct trusted_key_payload * new_p ; size_t datalen = prep -> datalen ; char * datablob ; int ret = 0 ; if ( key_is_negative ( key ) ) return - EINVAL ; if ( datalen <= 0 || datalen > 32767 || ! prep -> data ) return - EINVAL ; datablob = kmalloc ( datalen + 1 , GFP_KERNEL ) ; if ( ! datablob ) return - ENOMEM ; new_o = trusted_options_alloc ( ) ; if ( ! new_o ) { ret = - ENOMEM ; goto out ; } new_p = trusted_payload_alloc ( key ) ; if ( ! new_p ) { ret = - ENOMEM ; goto out ; } memcpy ( datablob , prep -> data , datalen ) ; datablob [ datalen ] = '\\0' ; ret = datablob_parse ( datablob , new_p , new_o ) ; if ( ret != Opt_update ) { ret = - EINVAL ; kfree ( new_p ) ; goto out ; } if ( ! new_o -> keyhandle ) { ret = - EINVAL ; kfree ( new_p ) ; goto out ; } new_p -> migratable = p -> migratable ; new_p -> key_len = p -> key_len ; memcpy ( new_p -> key , p -> key , p -> key_len ) ; dump_payload ( p ) ; dump_payload ( new_p ) ; ret = key_seal ( new_p , new_o ) ; if ( ret < 0 ) { pr_info ( ""trusted_key:key_sealfailed(%d)\\n"" , ret ) ; kfree ( new_p ) ; goto out ; } if ( new_o -> pcrlock ) { ret = pcrlock ( new_o -> pcrlock ) ; if ( ret < 0 ) { pr_info ( ""trusted_key:key_sealfailed(%d)\\n
",0,511
767,"static int bmp_getint32 ( jas_stream_t * in , int_fast32_t * val ) { int n ; uint_fast32_t v ; int c ; for ( n = 4 , v = 0 ; ; ) { if ( ( c = jas_stream_getc ( in ) ) == EOF ) { return - 1 ; } v |= ( JAS_CAST ( uint_fast32_t , c ) << 24 ) ; if ( -- n <= 0 ) { break ; } v >>= 8 ; } if ( val ) { * val = v ; } return 0 ; }
",1,136
768,"static void rose_loopback_timer ( unsigned long param ) { struct sk_buff * skb ; struct net_device * dev ; rose_address * dest ; struct sock * sk ; unsigned short frametype ; unsigned int lci_i , lci_o ; while ( ( skb = skb_dequeue ( & loopback_queue ) ) != NULL ) { if ( skb -> len < ROSE_MIN_LEN ) { kfree_skb ( skb ) ; continue ; } lci_i = ( ( skb -> data [ 0 ] << 8 ) & 0xF00 ) + ( ( skb -> data [ 1 ] << 0 ) & 0x0FF ) ; frametype = skb -> data [ 2 ] ; if ( frametype == ROSE_CALL_REQUEST ) { if ( ( dev = rose_dev_get ( dest ) ) != NULL ) { if ( rose_rx_call_request ( skb , dev , rose_loopback_neigh , lci_o ) == 0 ) kfree_skb ( skb ) ; } else { kfree_skb ( skb ) ; } } else { kfree_skb ( skb ) ; } } }
",0,271
769,"int __kvm_set_memory_region ( struct kvm * kvm , struct kvm_userspace_memory_region * mem , int user_alloc ) { int r ; gfn_t base_gfn ; unsigned long npages ; struct kvm_memory_slot * memslot , * slot ; struct kvm_memory_slot old , new ; struct kvm_memslots * slots , * old_memslots ; r = check_memory_region_flags ( mem ) ; if ( r ) goto out ; r = - EINVAL ; if ( mem -> memory_size & ( PAGE_SIZE - 1 ) ) goto out ; if ( mem -> guest_phys_addr & ( PAGE_SIZE - 1 ) ) goto out ; if ( user_alloc && ( ( mem -> userspace_addr & ( PAGE_SIZE - 1 ) ) || ! access_ok ( VERIFY_WRITE , ( void __user * ) ( unsigned long ) mem -> userspace_addr , mem -> memory_size ) ) ) goto out ; if ( mem -> slot >= KVM_MEM_SLOTS_NUM ) goto out ; if ( mem -> guest_phys_addr + mem -> memory_size < mem -> guest_phys_addr ) goto out ; memslot = id_to_memslot ( kvm -> memslots , mem -> slot ) ; base_gfn = mem -> guest_phys_addr >> PAGE_SHIFT ; npages = mem -> memory_size >> PAGE_SHIFT ; r = - EINVAL ; if ( npages > KVM_MEM_MAX_NR_PAGES ) goto out ; if ( ! npages ) mem -> flags &= ~ KVM_MEM_LOG_DIRTY_PAGES ; new = old = * memslot ; new . id = mem -> slot ; new . base_gfn = base_gfn ; new . npages = npages ; new . flags = mem -> flags ; r = - EINVAL ; if ( npages && old . npages && npages != old . npages ) goto out_free ; if ( ! npages && ! old . npages ) goto out_free ; r = - EEXIST ; kvm_for_each_memslot ( slot , kvm -> memslots ) { if ( slot -> id >=
",0,511
770,"unsigned int nf_nat_redirect_ipv4 ( struct sk_buff * skb , const struct nf_nat_ipv4_multi_range_compat * mr , unsigned int hooknum ) { struct nf_conn * ct ; enum ip_conntrack_info ctinfo ; __be32 newdst ; struct nf_nat_range newrange ; NF_CT_ASSERT ( hooknum == NF_INET_PRE_ROUTING || hooknum == NF_INET_LOCAL_OUT ) ; ct = nf_ct_get ( skb , & ctinfo ) ; NF_CT_ASSERT ( ct && ( ctinfo == IP_CT_NEW || ctinfo == IP_CT_RELATED ) ) ; if ( hooknum == NF_INET_LOCAL_OUT ) { newdst = htonl ( 0x7F000001 ) ; } else { struct in_device * indev ; struct in_ifaddr * ifa ; newdst = 0 ; rcu_read_lock ( ) ; indev = __in_dev_get_rcu ( skb -> dev ) ; if ( indev && indev -> ifa_list ) { ifa = indev -> ifa_list ; newdst = ifa -> ifa_local ; } rcu_read_unlock ( ) ; if ( ! newdst ) return NF_DROP ; } memset ( & newrange . min_addr , 0 , sizeof ( newrange . min_addr ) ) ; memset ( & newrange . max_addr , 0 , sizeof ( newrange . max_addr ) ) ; newrange . flags = mr -> range [ 0 ] . flags | NF_NAT_RANGE_MAP_IPS ; newrange . min_addr . ip = newdst ; newrange . max_addr . ip = newdst ; newrange . min_proto = mr -> range [ 0 ] . min ; newrange . max_proto = mr -> range [ 0 ] . max ; return nf_nat_setup_info ( ct , & newrange , NF_NAT_MANIP_DST ) ; }
",1,488
771,"int fdt_find_regions ( const void * fdt , char * const inc [ ] , int inc_count , char * const exc_prop [ ] , int exc_prop_count , struct fdt_region region [ ] , int max_regions , char * path , int path_len , int add_string_tab ) { int stack [ FDT_MAX_DEPTH ] = { 0 } ; char * end ; int nextoffset = 0 ; uint32_t tag ; int count = 0 ; int start = - 1 ; int depth = - 1 ; int want = 0 ; int base = fdt_off_dt_struct ( fdt ) ; int end = path ; * end = '\\0' ; do { const struct fdt_property * prop ; const char * name ; const char * str ; int include = 0 ; int stop_at = 0 ; int offset ; int len ; offset = nextoffset ; tag = fdt_next_tag ( fdt , offset , & nextoffset ) ; stop_at = nextoffset ; switch ( tag ) { case FDT_PROP : include = want >= 2 ; stop_at = offset ; prop = fdt_get_property_by_offset ( fdt , offset , NULL ) ; str = fdt_string ( fdt , fdt32_to_cpu ( prop -> nameoff ) ) ; if ( ! str ) return - FDT_ERR_BADSTRUCTURE ; if ( str_in_list ( str , exc_prop , exc_prop_count ) ) include = 0 ; break ; case FDT_NOP : include = want >= 2 ; stop_at = offset ; break ; case FDT_BEGIN_NODE : depth ++ ; if ( depth == FDT_MAX_DEPTH ) return - FDT_ERR_BADSTRUCTURE ; name = fdt_get_name ( fdt , offset , & len ) ; if ( end - path + 2 + len >= path_len ) return - FDT_ERR_NOSPACE ; if ( end != path + 1 ) * end ++ = '/' ; strcpy ( end , name ) ; end += len ; stack [ depth ] = want ; if ( want == 1 ) stop_at = offset ; if ( str_in_list ( path , inc , inc_count ) )
",0,511
772,"int ParseDsdiffHeaderConfig ( FILE * infile , char * infilename , char * fourcc , WavpackContext * wpc , WavpackConfig * config ) { int64_t infilesize , total_samples ; DFFFileHeader dff_file_header ; DFFChunkHeader dff_chunk_header ; uint32_t bcount ; infilesize = DoGetFileSize ( infile ) ; memcpy ( & dff_file_header , fourcc , 4 ) ; if ( ( ! DoReadFile ( infile , ( ( char * ) & dff_file_header ) + 4 , sizeof ( DFFFileHeader ) - 4 , & bcount ) || bcount != sizeof ( DFFFileHeader ) - 4 ) || strncmp ( dff_file_header . formType , ""DSD"" , 4 ) ) { error_line ( ""%sisnotavalid.DFFfile!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & dff_file_header , sizeof ( DFFFileHeader ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } # if 1 WavpackBigEndianToNative ( & dff_file_header , DFFFileHeaderFormat ) ; if ( infilesize && ! ( config -> qmode & QMODE_IGNORE_LENGTH ) && dff_file_header . ckDataSize && dff_file_header . ckDataSize + 1 && dff_file_header . ckDataSize + 12 != infilesize ) { error_line ( ""%sisnotavalid.DFFfile(bytotalsize)!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( debug_logging_mode ) error_line ( ""fileheaderindicatedlength=%lld"" , dff_file_header . ckDataSize ) ; # endif while ( 1 ) { if ( ! DoReadFile ( infile , & dff_chunk_header , sizeof ( DFF
",0,511
773,"BIO * PKCS7_dataDecode ( PKCS7 * p7 , EVP_PKEY * pkey , BIO * in_bio , X509 * pcert ) { int i , j ; BIO * out = NULL , * btmp = NULL , * etmp = NULL , * bio = NULL ; X509_ALGOR * xa ; ASN1_OCTET_STRING * data_body = NULL ; const EVP_MD * evp_md ; const EVP_CIPHER * evp_cipher = NULL ; EVP_CIPHER_CTX * evp_ctx = NULL ; X509_ALGOR * enc_alg = NULL ; STACK_OF ( X509_ALGOR ) * md_sk = NULL ; STACK_OF ( PKCS7_RECIP_INFO ) * rsk = NULL ; PKCS7_RECIP_INFO * ri = NULL ; unsigned char * ek = NULL , * tkey = NULL ; int eklen = 0 , tkeylen = 0 ; if ( p7 == NULL ) { PKCS7err ( PKCS7_F_PKCS7_DATADECODE , PKCS7_R_INVALID_NULL_POINTER ) ; return NULL ; } if ( p7 -> d . ptr == NULL ) { PKCS7err ( PKCS7_F_PKCS7_DATADECODE , PKCS7_R_NO_CONTENT ) ; return NULL ; } i = OBJ_obj2nid ( p7 -> type ) ; p7 -> state = PKCS7_S_HEADER ; switch ( i ) { case NID_pkcs7_signed : data_body = PKCS7_get_octet_string ( p7 -> d . sign -> contents ) ; if ( ! PKCS7_is_detached ( p7 ) && data_body == NULL ) { PKCS7err ( PKCS7_F_PKCS7_DATADECODE , PKCS7_R_INVALID_SIGNED_DATA_TYPE ) ; goto err ; } md_sk = p7 -> d . sign -> md_algs ; break ; case NID_pkcs7_signedAndEnveloped : rsk = p7 -> d
",0,511
774,"int serverCron ( struct aeEventLoop * eventLoop , long long id , void * clientData ) { int j , loops = server . cronloops ++ ; REDIS_NOTUSED ( eventLoop ) ; REDIS_NOTUSED ( id ) ; REDIS_NOTUSED ( clientData ) ; server . unixtime = time ( NULL ) ; updateLRUClock ( ) ; if ( server . shutdown_asap ) { if ( prepareForShutdown ( ) == REDIS_OK ) exit ( 0 ) ; redisLog ( REDIS_WARNING , ""SIGTERMreceivedbuterrorstryingtoshutdowntheserver,checkthelogsformoreinformation"" ) ; } for ( j = 0 ; j < server . dbnum ; j ++ ) { long long size , used , vkeys ; size = dictSlots ( server . db [ j ] . dict ) ; used = dictSize ( server . db [ j ] . dict ) ; vkeys = dictSize ( server . db [ j ] . expires ) ; if ( ! ( loops % 50 ) && ( used || vkeys ) ) { redisLog ( REDIS_VERBOSE , ""DB%d:%lldkeys(%lldvolatile)in%lldslotsHT."" , j , used , vkeys , size ) ; } } if ( server . bgsavechildpid == - 1 && server . bgrewritechildpid == - 1 ) { if ( ! ( loops % 10 ) ) tryResizeHashTables ( ) ; if ( server . activerehashing ) incrementallyRehash ( ) ; } if ( ! ( loops % 50 ) ) { redisLog ( REDIS_VERBOSE , ""%dclientsconnected(%dslaves),%zubytesinuse"" , listLength ( server . clients ) - listLength ( server . slaves ) , listLength ( server . slaves ) , zmalloc_used_memory ( ) ) ; } if ( ( server . maxidletime && ! ( loops % 100 ) ) || server . bpop_blocked_clients ) closeTimedoutClients ( ) ; if ( server . bgsavechildpid != - 1 || server . bgrewritechildpid != - 1 ) { int statloc ; pid_t pid ; if ( ( pid = wait
",0,511
775,"static void uv__process_child_init ( const uv_process_options_t * options , int stdio_count , int ( * pipes ) [ 2 ] , int error_fd ) { int close_fd ; int use_fd ; int fd ; if ( options -> flags & UV_PROCESS_DETACHED ) setsid ( ) ; for ( fd = 0 ; fd < stdio_count ; fd ++ ) { close_fd = pipes [ fd ] [ 0 ] ; use_fd = pipes [ fd ] [ 1 ] ; if ( use_fd < 0 ) { if ( fd >= 3 ) continue ; else { use_fd = open ( ""/dev/null"" , fd == 0 ? O_RDONLY : O_RDWR ) ; close_fd = use_fd ; if ( use_fd == - 1 ) { uv__write_int ( error_fd , - errno ) ; perror ( ""failedtoopenstdio"" ) ; _exit ( 127 ) ; } } } if ( fd == use_fd ) uv__cloexec ( use_fd , 0 ) ; else dup2 ( use_fd , fd ) ; if ( fd <= 2 ) uv__nonblock ( fd , 0 ) ; if ( close_fd != - 1 ) uv__close ( close_fd ) ; } for ( fd = 0 ; fd < stdio_count ; fd ++ ) { use_fd = pipes [ fd ] [ 1 ] ; if ( use_fd >= 0 && fd != use_fd ) close ( use_fd ) ; } if ( options -> cwd != NULL && chdir ( options -> cwd ) ) { uv__write_int ( error_fd , - errno ) ; perror ( ""chdir()"" ) ; _exit ( 127 ) ; } if ( ( options -> flags & UV_PROCESS_SETGID ) && setgid ( options -> gid ) ) { uv__write_int ( error_fd , - errno ) ; perror ( ""setgid()"" ) ; _exit ( 127 ) ; } if ( ( options -> flags & UV_PROCESS_SETUID ) && setuid ( options -> uid ) ) { uv__write_int ( error
",0,511
776,"static int cxusb_ctrl_msg ( struct dvb_usb_device * d , u8 cmd , u8 * wbuf , int wlen , u8 * rbuf , int rlen ) { struct cxusb_state * st = d -> priv ; int ret ; if ( 1 + wlen > MAX_XFER_SIZE ) { warn ( ""i2cwr:len=%distoobig
",0,93
777,"static void setup_connection ( GsmXSMPClient * client ) { GIOChannel * channel ; int fd ; g_debug ( ""GsmXSMPClient:Settingupnewconnection"" ) ; fd = IceConnectionNumber ( client -> priv -> ice_connection ) ; fcntl ( fd , F_SETFD , fcntl ( fd , F_GETFD , 0 ) | FD_CLOEXEC ) ; channel = g_io_channel_unix_new ( fd ) ; client -> priv -> watch_id = g_io_add_watch ( channel , G_IO_IN | G_IO_ERR , ( GIOFunc ) client_iochannel_watch , client ) ; g_io_channel_unref ( channel ) ; g_debug ( ""GsmXSMPClient:Newclient\'%s\'"" , client -> priv -> description ) ; }
",0,204
778,"long vorbis_book_decodev_add ( codebook * book , ogg_int32_t * a , oggpack_buffer * b , int n , int point ) { if ( book -> used_entries > 0 ) { ogg_int32_t * v = book -> dec_buf ; int i , j ; if ( ! v ) return - 1 ; for ( i = 0 ; i < n ; ) { if ( decode_map ( book , b , v , point ) ) return - 1 ; for ( j = 0 ; j < book -> dim && i < n ; j ++ ) a [ i ++ ] += v [ j ] ; } } return 0 ; }
",1,153
779,"void BezierCircle ( double r , char * action ) { sprintf ( outputbuffer , ""%12.3f0m%12.3f%12.3f%12.3f%12.3f%12.3fc\\n"" , - r , - r , r * BzK , - r * BzK , r , r ) ; outpos += sprintf ( outputbuffer , ""%12.3f%12.3f%12.3f%12.3f%12.3f0%12.3fc\\n"" , r * BzK , r , r , r ) ; outpos += sprintf ( outpos , ""%12.3f%12.3f%12.3f%12.3f%12.3f0c\\n"" , r * BzK , r , r , r ) ; outpos += sprintf ( outpos , ""%12.3f%12.3f%12.3f%12.3f%12.3f0c%s\\n"" , r * BzK , - r , - r , - r * BzK , - r , action ) ; }
",0,260
780,"static noinline int create_pending_snapshot ( struct btrfs_trans_handle * trans , struct btrfs_fs_info * fs_info , struct btrfs_pending_snapshot * pending ) { struct btrfs_key key ; struct btrfs_root_item * new_root_item ; struct btrfs_root * tree_root = fs_info -> tree_root ; struct btrfs_root * root = pending -> root ; struct btrfs_root * parent_root ; struct btrfs_block_rsv * rsv ; struct inode * parent_inode ; struct btrfs_path * path ; struct btrfs_dir_item * dir_item ; struct dentry * parent ; struct dentry * dentry ; struct extent_buffer * tmp ; struct extent_buffer * old ; struct timespec cur_time = CURRENT_TIME ; int ret ; u64 to_reserve = 0 ; u64 index = 0 ; u64 objectid ; u64 root_flags ; uuid_le new_uuid ; path = btrfs_alloc_path ( ) ; if ( ! path ) { ret = pending -> error = - ENOMEM ; goto path_alloc_fail ; } new_root_item = kmalloc ( sizeof ( * new_root_item ) , GFP_NOFS ) ; if ( ! new_root_item ) { ret = pending -> error = - ENOMEM ; goto root_item_alloc_fail ; } ret = btrfs_find_free_objectid ( tree_root , & objectid ) ; if ( ret ) { pending -> error = ret ; goto no_free_objectid ; } btrfs_reloc_pre_snapshot ( trans , pending , & to_reserve ) ; if ( to_reserve > 0 ) { ret = btrfs_block_rsv_add ( root , & pending -> block_rsv , to_reserve , BTRFS_RESERVE_NO_FLUSH ) ; if ( ret ) { pending -> error = ret ; goto no_free_objectid ; } } ret = btrfs_qgroup_inherit ( trans , fs_info , root -> root_key . objectid , objectid , pending -> inherit ) ; if ( ret ) {
",0,511
781,"void unix_notinflight ( struct file * fp ) { struct sock * s = unix_get_socket ( fp ) ; spin_lock ( & unix_gc_lock ) ; if ( s ) { struct unix_sock * u = unix_sk ( s ) ; BUG_ON ( list_empty ( & u -> link ) ) ; if ( atomic_long_dec_and_test ( & u -> inflight ) ) list_del_init ( & u -> link ) ; unix_tot_inflight -- ; } fp -> f_cred -> user -> unix_inflight -- ; spin_unlock ( & unix_gc_lock ) ; }
",1,157
782,"static int aiff_read_chanmap ( SF_PRIVATE * psf , unsigned dword ) { const AIFF_CAF_CHANNEL_MAP * map_info ; unsigned channel_bitmap , channel_decriptions , bytesread ; int layout_tag ; bytesread = psf_binheader_readf ( psf , ""444"" , & layout_tag , & channel_bitmap , & channel_decriptions ) ; if ( ( map_info = aiff_caf_of_channel_layout_tag ( layout_tag ) ) == NULL ) return 0 ; psf_log_printf ( psf , ""Tag:%x\\n"" , layout_tag ) ; if ( map_info ) psf_log_printf ( psf , ""Layout:%s\\n"" , map_info -> name ) ; if ( bytesread < dword ) psf_binheader_readf ( psf , ""j"" , dword - bytesread ) ; if ( map_info -> channel_map != NULL ) { size_t chanmap_size = SF_MIN ( psf -> sf . channels , sizeof ( psf -> channel_map [ 0 ] ) ) ; free ( psf -> channel_map ) ; if ( ( psf -> channel_map = malloc ( chanmap_size ) ) == NULL ) return SFE_MALLOC_FAILED ; memcpy ( psf -> channel_map , map_info -> channel_map , chanmap_size ) ; } ; return 0 ; }
",0,344
783,"void vp9_setup_scale_factors_for_frame ( struct scale_factors * sf , int other_w , int other_h , int this_w , int this_h ) { if ( other_w < 0 || other_h < 0 ) return ; if ( ! check_scale_factors ( other_w , other_h , this_w , this_h ) ) { sf -> x_scale_fp = REF_INVALID_SCALE ; sf -> y_scale_fp = REF_INVALID_SCALE ; return ; } sf -> x_scale_fp = get_fixed_point_scale_factor ( other_w , this_w ) ; sf -> y_scale_fp = get_fixed_point_scale_factor ( other_h , this_h ) ; sf -> x_step_q4 = scaled_x ( 16 , sf ) ; sf -> y_step_q4 = scaled_y ( 16 , sf ) ; if ( vp9_is_scaled ( sf ) ) { sf -> scale_value_x = scaled_x ; sf -> scale_value_y = scaled_y ; } else { sf -> scale_value_x = unscaled_value ; sf -> scale_value_y = unscaled_value ; } if ( sf -> x_step_q4 == 16 ) { if ( sf -> y_step_q4 == 16 ) { sf -> predict [ 0 ] [ 0 ] [ 0 ] = vp9_convolve_copy ; sf -> predict [ 0 ] [ 0 ] [ 1 ] = vp9_convolve_avg ; sf -> predict [ 0 ] [ 1 ] [ 0 ] = vp9_convolve8_vert ; sf -> predict [ 0 ] [ 1 ] [ 1 ] = vp9_convolve8_avg_vert ; sf -> predict [ 1 ] [ 0 ] [ 0 ] = vp9_convolve8_horiz ; sf -> predict [ 1 ] [ 0 ] [ 1 ] = vp9_convolve8_avg_horiz ; } else { sf -> predict [ 0 ] [ 0 ] [ 0 ] [ 0 ] = vp9_convolve8_
",0,511
784,"GPMF_ERR IsValidSize ( GPMF_stream * ms , uint32_t size ) { if ( ms ) { uint32_t nestsize = ( int32_t ) ms -> nest_size [ ms -> nest_level ] ; if ( nestsize == 0 && ms -> nest_level == 0 ) nestsize = ms -> buffer_size_longs ; if ( size + 2 <= nestsize ) return GPMF_OK ; } return GPMF_ERROR_BAD_STRUCTURE ; }
",1,115
785,"int handle_unaligned_access ( insn_size_t instruction , struct pt_regs * regs , struct mem_access * ma , int expected , unsigned long address ) { u_int rm ; int ret , index ; if ( instruction_size ( instruction ) != 2 ) return - EINVAL ; index = ( instruction >> 8 ) & 15 ; rm = regs -> regs [ index ] ; if ( ! expected ) { unaligned_fixups_notify ( current , instruction , regs ) ; perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , regs , address ) ; } ret = - EFAULT ; switch ( instruction & 0xF000 ) { case 0x0000 : if ( instruction == 0x000B ) { ret = handle_delayslot ( regs , instruction , ma ) ; if ( ret == 0 ) regs -> pc = regs -> pr ; } else if ( ( instruction & 0x00FF ) == 0x0023 ) { ret = handle_delayslot ( regs , instruction , ma ) ; if ( ret == 0 ) regs -> pc += rm + 4 ; } else if ( ( instruction & 0x00FF ) == 0x0003 ) { ret = handle_delayslot ( regs , instruction , ma ) ; if ( ret == 0 ) { regs -> pr = regs -> pc + 4 ; regs -> pc += rm + 4 ; } } else { goto simple ; } break ; case 0x1000 : goto simple ; case 0x2000 : goto simple ; case 0x4000 : if ( ( instruction & 0x00FF ) == 0x002B ) { ret = handle_delayslot ( regs , instruction , ma ) ; if ( ret == 0 ) regs -> pc = rm ; } else if ( ( instruction & 0x00FF ) == 0x000B ) { ret = handle_delayslot ( regs , instruction , ma ) ; if ( ret == 0 ) { regs -> pr = regs -> pc + 4 ; regs -> pc = rm ; } } else { goto simple ; } break ; case 0x5000 : goto simple ; case 0x6000 : goto simple ; case 0x8000 : switch ( instruction & 0x0F00 ) { case 0x0100 : goto simple ; case 0x8000 :
",0,511
786,"static int mark_source_chains ( const struct xt_table_info * newinfo , unsigned int valid_hooks , void * entry0 ) { unsigned int hook ; for ( hook = 0 ; hook < NF_INET_NUMHOOKS ; hook ++ ) { unsigned int pos = newinfo -> hook_entry [ hook ] ; struct ip6t_entry * e = ( struct ip6t_entry * ) ( entry0 + pos ) ; if ( ! ( valid_hooks & ( 1 << hook ) ) ) continue ; e -> counters . pcnt = pos ; for ( ; ; ) { const struct xt_standard_target * t = ( void * ) ip6t_get_target_c ( e ) ; int visited = e -> comefrom & ( 1 << hook ) ; if ( e -> comefrom & ( 1 << NF_INET_NUMHOOKS ) ) { pr_err ( ""iptables:loophook%upos%u%08X.\\n"" , hook , pos , e -> comefrom ) ; return 0 ; } e -> comefrom |= ( ( 1 << hook ) | ( 1 << NF_INET_NUMHOOKS ) ) ; size = sizeof ( struct ip6t_entry ) && ( strcmp ( t -> target . u . user . name , XT_STANDARD_TARGET ) == 0 ) && t -> verdict < 0 && unconditional ( & e -> ipv6 ) ) || visited ) { unsigned int oldpos , size ; if ( ( strcmp ( t -> target . u . user . name , XT_STANDARD_TARGET ) == 0 ) && t -> verdict < - NF_MAX_VERDICT - 1 ) { duprintf ( ""mark_source_chains:bad"" ""negativeverdict(%i)\\n"" , t -> verdict ) ; return 0 ; } do { e -> comefrom ^= ( 1 << NF_INET_NUMHOOKS ) ; # ifdef DEBUG_IP_FIREWALL_USER if ( e -> comefrom & ( 1 << NF_INET_NUMHOOKS ) ) { duprintf ( ""Backunset"" ""onhook%u"" ""rule%u\\n"" , hook , pos ) ; } # endif } while ( ! e -> counters . pcnt
",0,511
787,"int pdf_load_xrefs ( FILE * fp , pdf_t * pdf ) { int i , ver , is_linear ; long pos , pos_count ; char x , * c , buf [ 256 ] ; c = NULL ; pdf -> n_xrefs = 0 ; fseek ( fp , 0 , SEEK_SET ) ; while ( get_next_eof ( fp ) >= 0 ) ++ pdf -> n_xrefs ; if ( ! pdf -> n_xrefs ) return 0 ; fseek ( fp , 0 , SEEK_SET ) ; pdf -> xrefs = safe_calloc ( sizeof ( xref_t ) * pdf -> n_xrefs ) ; ver = 1 ; for ( i = 0 ; i < pdf -> n_xrefs ; i ++ ) { if ( ( pos = get_next_eof ( fp ) ) < 0 ) break ; pdf -> xrefs [ i ] . version = ver ++ ; pos_count = 0 ; while ( SAFE_F ( fp , ( ( x = fgetc ( fp ) ) != 'f' ) ) ) fseek ( fp , pos - ( ++ pos_count ) , SEEK_SET ) ; if ( pos_count >= sizeof ( buf ) ) { ERR ( ""Failedtolocatethestartxreftoken."" ""ThismightbeacorruptPDF.\\n"" ) ; return - 1 ; } memset ( buf , 0 , sizeof ( buf ) ) ; SAFE_E ( fread ( buf , 1 , pos_count , fp ) , pos_count , ""Failedtoreadstartxref.\\n"" ) ; c = buf ; while ( * c == '' || * c == '\\n' || * c == '\\r' ) ++ c ; pdf -> xrefs [ i ] . start = atol ( c ) ; if ( pdf -> xrefs [ i ] . start == 0 ) get_xref_linear_skipped ( fp , & pdf -> xrefs [ i ] ) ; else { pos = ftell ( fp ) ; fseek ( fp , pdf -> xrefs [ i ] . start , SEEK_SET ) ; pdf -> xrefs [ i ] . end = get_next_eof
",0,511
788,"static ssize_t _hostsock_recv ( oe_fd_t * sock_ , void * buf , size_t count , int flags ) { ssize_t ret = - 1 ; sock_t * sock = _cast_sock ( sock_ ) ; oe_errno = 0 ; if ( ! sock || ( count && ! buf ) || count > OE_SSIZE_MAX ) OE_RAISE_ERRNO ( OE_EINVAL ) ; if ( buf ) { if ( oe_memset_s ( buf , count , 0 , count ) != OE_OK ) OE_RAISE_ERRNO ( OE_EINVAL ) ; } if ( oe_syscall_recv_ocall ( & ret , sock -> host_fd , buf , count , flags ) != OE_OK ) OE_RAISE_ERRNO ( OE_EINVAL ) ; done : return ret ; }
",0,217
789,"void inet6_destroy_sock ( struct sock * sk ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct sk_buff * skb ; struct ipv6_txoptions * opt ; skb = xchg ( & np -> pktoptions , NULL ) ; if ( skb ) kfree_skb ( skb ) ; skb = xchg ( & np -> rxpmtu , NULL ) ; if ( skb ) kfree_skb ( skb ) ; fl6_free_socklist ( sk ) ; opt = xchg ( & np -> opt , NULL ) ; if ( opt ) { atomic_sub ( & sk -> socklist , & skb -> sock ) ; sock_kfree_s ( sk , opt , opt -> tot_len ) ; } }
",0,187
790,"int CMS_verify ( CMS_ContentInfo * cms , STACK_OF ( X509 ) * certs , X509_STORE * store , BIO * dcont , BIO * out , unsigned int flags ) { CMS_SignerInfo * si ; STACK_OF ( CMS_SignerInfo ) * sinfos ; STACK_OF ( X509 ) * cms_certs = NULL ; STACK_OF ( X509_CRL ) * crls = NULL ; X509 * signer ; int i , scount = 0 , ret = 0 ; BIO * cmsbio = NULL , * tmpin = NULL , * tmpout = NULL ; if ( ! dcont && ! check_content ( cms ) ) return 0 ; sinfos = CMS_get0_SignerInfos ( cms ) ; if ( sk_CMS_SignerInfo_num ( sinfos ) <= 0 ) { CMSerr ( CMS_F_CMS_VERIFY , CMS_R_NO_SIGNERS ) ; goto err ; } for ( i = 0 ; i < sk_CMS_SignerInfo_num ( sinfos ) ; i ++ ) { si = sk_CMS_SignerInfo_value ( sinfos , i ) ; CMS_SignerInfo_get0_algs ( si , NULL , & signer , NULL , NULL ) ; if ( signer ) scount ++ ; } if ( scount != sk_CMS_SignerInfo_num ( sinfos ) ) scount += CMS_set1_signers_certs ( cms , certs , flags ) ; if ( scount != sk_CMS_SignerInfo_num ( sinfos ) ) { CMSerr ( CMS_F_CMS_VERIFY , CMS_R_SIGNER_CERTIFICATE_NOT_FOUND ) ; goto err ; } if ( ! ( flags & CMS_NO_SIGNER_CERT_VERIFY ) ) { cms_certs = CMS_get1_certs ( cms ) ; if ( ! ( flags & CMS_NOCRL ) ) crls = CMS_get1_crls ( cms ) ; for ( i = 0 ; i < sk_CMS_SignerInfo_num ( sinfos ) ; i ++
",0,511
791,"static int do_ipv6_getsockopt ( struct sock * sk , int level , int optname , char __user * optval , int __user * optlen , unsigned int flags ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; int len ; int val ; if ( ip6_mroute_opt ( optname ) ) return ip6_mroute_getsockopt ( sk , optname , optval , optlen ) ; if ( get_user ( len , optlen ) ) return - EFAULT ; switch ( optname ) { case IPV6_ADDRFORM : if ( sk -> sk_protocol != IPPROTO_UDP && sk -> sk_protocol != IPPROTO_UDPLITE && sk -> sk_protocol != IPPROTO_TCP ) return - ENOPROTOOPT ; if ( sk -> sk_state != TCP_ESTABLISHED ) return - ENOTCONN ; val = sk -> sk_family ; break ; case MCAST_MSFILTER : { struct group_filter gsf ; int err ; if ( len < GROUP_FILTER_SIZE ( 0 ) ) return - EINVAL ; if ( copy_from_user ( & gsf , optval , GROUP_FILTER_SIZE ( 0 ) ) ) return - EFAULT ; if ( gsf . gf_group . ss_family != AF_INET6 ) return - EADDRNOTAVAIL ; lock_sock ( sk ) ; err = ip6_mc_msfget ( sk , & gsf , ( struct group_filter __user * ) optval , optlen ) ; release_sock ( sk ) ; return err ; } case IPV6_2292PKTOPTIONS : { struct msghdr msg ; struct sk_buff * skb ; if ( sk -> sk_type != SOCK_STREAM ) return - ENOPROTOOPT ; msg . msg_control = optval ; msg . msg_controllen = len ; msg . msg_flags = flags ; lock_sock ( sk ) ; skb = np -> pktoptions ; if ( skb ) ip6_datagram_recv_ctl ( sk , & msg , skb ) ; release_sock ( sk ) ; if ( ! skb
",0,511
792,"static __exit void sctp_exit ( void ) { sctp_v6_del_protocol ( ) ; sctp_v4_del_protocol ( ) ; unregister_pernet_subsys ( & sctp_net_ops ) ; sctp_v6_protosw_exit ( ) ; sctp_v4_protosw_exit ( ) ; sctp_v6_pf_exit ( ) ; sctp_v4_pf_exit ( ) ; sctp_sysctl_unregister ( ) ; free_pages ( ( unsigned long ) sctp_assoc_hashtable , get_order ( sctp_assoc_hashsize * sizeof ( struct sctp_hashbucket ) ) ) ; kfree ( sctp_ep_hashtable ) ; free_pages ( ( unsigned long ) sctp_port_hashtable , get_order ( sctp_port_hashsize * sizeof ( struct sctp_bind_hashbucket ) ) ) ; percpu_counter_destroy ( & sctp_sockets_allocated ) ; rcu_barrier ( ) ; kmem_cache_destroy ( sctp_chunk_cachep ) ; kmem_cache_destroy ( sctp_bucket_cachep ) ; }
",0,300
793,"void _modinit ( module_t * m ) { service_named_bind_command ( ""chanserv"" , & cs_flags ) ; hook_del_nick_can_register ( check_registration_keywords ) ; hook_del_user_can_register ( check_registration_keywords ) ; }
",0,72
794,"static int masq_inet_event ( struct notifier_block * this , unsigned long event , void * ptr ) { struct in_device * idev = ( ( struct in_ifaddr * ) ptr ) -> ifa_dev ; struct netdev_notifier_info info ; if ( idev -> dead ) return NOTIFY_DONE ; netdev_notifier_info_init ( & info , idev -> dev ) ; return masq_device_event ( this , event , & info ) ; }
",1,113
795,"void flush_tlb_mm_range ( struct mm_struct * mm , unsigned long start , unsigned long end , unsigned long vmflag ) { unsigned long addr ; unsigned long base_pages_to_flush = TLB_FLUSH_ALL ; preempt_disable ( ) ; if ( current -> active_mm != mm ) { smp_mb ( ) ; goto out ; } if ( ! current -> mm ) { leave_mm ( smp_processor_id ( ) ) ; smp_mb ( ) ; goto out ; } if ( ( end != TLB_FLUSH_ALL ) && ! ( vmflag & VM_HUGETLB ) ) base_pages_to_flush = ( end - start ) >> PAGE_SHIFT ; if ( base_pages_to_flush > tlb_single_page_flush_ceiling ) { base_pages_to_flush = TLB_FLUSH_ALL ; count_vm_tlb_event ( NR_TLB_LOCAL_FLUSH_ALL ) ; local_flush_tlb ( ) ; } else { for ( addr = start ; addr < end ; addr += PAGE_SIZE ) { count_vm_tlb_event ( NR_TLB_LOCAL_FLUSH_ONE ) ; __flush_tlb_single ( addr ) ; } } trace_tlb_flush ( TLB_LOCAL_MM_SHOOTDOWN , base_pages_to_flush ) ; out : if ( base_pages_to_flush == TLB_FLUSH_ALL ) { start = 0UL ; end = TLB_FLUSH_ALL ; } if ( cpumask_any_but ( mm_cpumask ( mm ) , smp_processor_id ( ) ) < nr_cpu_ids ) flush_tlb_others ( mm_cpumask ( mm ) , mm , start , end ) ; preempt_enable ( ) ; }
",1,421
796,"static void show_psnr ( struct stream_state * stream ) { int i ; double ovpsnr ; if ( ! stream -> psnr_count ) return ; fprintf ( stderr , ""Stream%dPSNR(Overall/Avg/Y/U/V)"" , stream -> index ) ; ovpsnr = sse_to_psnr ( ( double ) stream -> psnr_samples_total , 255.0 , ( double ) stream -> psnr_sse_total ) ; fprintf ( stderr , ""%.3f"" , ovpsnr ) ; for ( i = 0 ; i < 4 ; i ++ ) { fprintf ( stderr , ""%.3f"" , stream -> psnr_totals [ i ] / stream -> psnr_count ) ; } fprintf ( stderr , ""\\n"" ) ; }
",0,194
797,"static char * get_pid_environ_val ( pid_t pid , char * val ) { int temp_size = 500 ; char * temp = malloc ( temp_size ) ; int i = 0 ; int foundit = 0 ; FILE * fp ; sprintf ( temp , ""/proc/%d/environ"" , pid ) ; fp = fopen ( temp , ""r"" ) ; if ( fp == NULL ) return NULL ; for ( ; ; ) { if ( i >= temp_size ) { temp_size *= 2 ; temp = realloc ( temp , temp_size ) ; } temp [ i ] = fgetc ( fp ) ; if ( foundit == 1 && ( temp [ i ] == 0 || temp [ i ] == '\\0' || temp [ i ] == EOF ) ) { char * ret ; temp [ i ] = 0 ; ret = malloc ( strlen ( temp ) + 10 ) ; sprintf ( ret , ""%s"" , temp ) ; fclose ( fp ) ; return ret ; } switch ( temp [ i ] ) { case EOF : fclose ( fp ) ; return NULL ; case '=' : temp [ i ] = 0 ; if ( ! strcmp ( temp , val ) ) { foundit = 1 ; } i = 0 ; break ; case '\\0' : i = 0 ; break ; default : i ++ ; } } }
",1,307
798,"static void smp_task_done ( struct sas_task * task ) { del_timer ( & task -> slow_task -> timer ) ; complete ( & task -> slow_task -> completion ) ; }
",1,46
799,"void pdf_summarize ( FILE * fp , const pdf_t * pdf , const char * name , pdf_flag_t flags ) { int i , j , page , n_versions , n_entries ; FILE * dst , * out ; char * dst_name , * c ; dst = NULL ; dst_name = NULL ; if ( name ) { dst_name = safe_calloc ( strlen ( name ) * 2 + 16 ) ; sprintf ( dst_name , ""%s/%s"" , name , name ) ; if ( ( c = strrchr ( dst_name , '.' ) ) && ( strncmp ( c , "".pdf"" , 4 ) == 0 ) ) * c = '\\0' ; strcat ( dst_name , "".summary"" ) ; if ( ! ( dst = fopen ( dst_name , ""w"" ) ) ) { ERR ( ""Couldnotopenfile\'%s\'forwriting\\n"" , dst_name ) ; return ; } } out = ( dst ) ? dst : stdout ; n_versions = pdf -> n_xrefs ; if ( n_versions && pdf -> xrefs [ 0 ] . is_linear ) -- n_versions ; for ( i = 1 ; i < pdf -> n_xrefs ; ++ i ) if ( pdf -> xrefs [ i ] . end == 0 ) -- n_versions ; if ( ! pdf -> n_xrefs || ( ! n_versions && pdf -> xrefs [ 0 ] . is_linear ) ) n_versions = 1 ; n_entries = 0 ; for ( i = 0 ; ! ( const int ) pdf -> has_xref_streams && i < pdf -> n_xrefs ; i ++ ) { if ( flags & PDF_FLAG_QUIET ) continue ; for ( j = 0 ; j < pdf -> xrefs [ i ] . n_entries ; j ++ ) { ++ n_entries ; fprintf ( out , ""%s:--%c--Version%d--Object%d(%s)"" , pdf -> name , pdf_get_object_status ( pdf , i , j ) , pdf -> xrefs [ i ] . version , pdf -> xrefs [ i ] . entries [ j ] . obj_id , get_type ( fp ,
",0,511
800,"int lldp_decode ( struct lldpd * cfg , char * frame , int s , struct lldpd_hardware * hardware , struct lldpd_chassis * * newchassis , struct lldpd_port * * newport ) { struct lldpd_chassis * chassis ; struct lldpd_port * port ; const char lldpaddr [ ] = LLDP_MULTICAST_ADDR ; const char dot1 [ ] = LLDP_TLV_ORG_DOT1 ; const char dot3 [ ] = LLDP_TLV_ORG_DOT3 ; const char med [ ] = LLDP_TLV_ORG_MED ; const char dcbx [ ] = LLDP_TLV_ORG_DCBX ; unsigned char orgid [ 3 ] ; int length , gotend = 0 , ttl_received = 0 ; int tlv_size , tlv_type , tlv_subtype ; u_int8_t * pos , * tlv ; char * b ; # ifdef ENABLE_DOT1 struct lldpd_vlan * vlan = NULL ; int vlan_len ; struct lldpd_ppvid * ppvid ; struct lldpd_pi * pi = NULL ; # endif struct lldpd_mgmt * mgmt ; int af ; u_int8_t addr_str_length , addr_str_buffer [ 32 ] ; u_int8_t addr_family , addr_length , * addr_ptr , iface_subtype ; u_int32_t iface_number , iface ; # ifdef ENABLE_CUSTOM struct lldpd_custom * custom = NULL ; # endif log_debug ( ""lldp"" , ""receiveLLDPPDUon%s"" , hardware -> h_ifname ) ; if ( ( chassis = calloc ( 1 , sizeof ( struct lldpd_chassis ) ) ) == NULL ) { log_warn ( ""lldp"" , ""failedtoallocateremotechassis"" ) ; return - 1 ; } TAILQ_INIT ( & chassis -> c_mgmt ) ; if ( ( port = calloc ( 1 , sizeof ( struct lldpd_port ) ) ) == NULL ) { log_warn ( ""lldp"" ,
",0,511
801,"static plist_t parse_bin_node ( struct bplist_data * bplist , const char * * object ) { uint16_t type = 0 ; uint64_t size = 0 ; if ( ! object ) return NULL ; type = ( * * object ) & BPLIST_MASK ; size = ( * * object ) & BPLIST_FILL ; ( * object ) ++ ; if ( size == BPLIST_FILL ) { switch ( type ) { case BPLIST_DATA : case BPLIST_STRING : case BPLIST_UNICODE : case BPLIST_ARRAY : case BPLIST_SET : case BPLIST_DICT : { uint16_t next_size = * * object & BPLIST_FILL ; if ( ( * * object & BPLIST_MASK ) != BPLIST_UINT ) { PLIST_BIN_ERR ( ""%s:invalidsizenodetypefornodetype0x%02x:found0x%02x,expected0x%02x\\n"" , __func__ , type , * * object & BPLIST_MASK , BPLIST_UINT ) ; return NULL ; } ( * object ) ++ ; next_size = 1 << next_size ; if ( * object + next_size > bplist -> offset_table ) { PLIST_BIN_ERR ( ""%s:sizenodedatabytesfornodetype0x%02xpointoutsideofvalidrange\\n"" , __func__ , type ) ; return NULL ; } size = UINT_TO_HOST ( * object , next_size ) ; ( * object ) += next_size ; break ; } default : break ; } } switch ( type ) { case BPLIST_NULL : switch ( size ) { case BPLIST_TRUE : { plist_data_t data = plist_new_plist_data ( ) ; data -> type = PLIST_BOOLEAN ; data -> boolval = TRUE ; data -> length = 1 ; return node_create ( NULL , data ) ; } case BPLIST_FALSE : { plist_data_t data = plist_new_plist_data ( ) ; data -> type = PLIST_BOOLE
",0,511
802,"error_t ksz8851Init ( NetInterface * interface ) { Ksz8851Context * context ; context = ( Ksz8851Context * ) interface -> nicContext ; TRACE_INFO ( ""InitializingKSZ8851Ethernetcontroller...\\r\\n"" ) ; # if ( KSZ8851_SPI_SUPPORT == ENABLED ) interface -> spiDriver -> init ( ) ; # endif interface -> extIntDriver -> init ( ) ; TRACE_DEBUG ( ""CIDER=0x%04"" PRIX16 ""\\r\\n"" , ksz8851ReadReg ( interface , KSZ8851_CIDER ) ) ; TRACE_DEBUG ( ""PHY1ILR=0x%04"" PRIX16 ""\\r\\n"" , ksz8851ReadReg ( interface , KSZ8851_PHY1ILR ) ) ; TRACE_DEBUG ( ""PHY1IHR=0x%04"" PRIX16 ""\\r\\n"" , ksz8851ReadReg ( interface , KSZ8851_PHY1IHR ) ) ; if ( ksz8851ReadReg ( interface , KSZ8851_CIDER ) != KSZ8851_REV_A3_ID ) { return ERROR_WRONG_IDENTIFIER ; } ksz8851DumpReg ( interface ) ; context -> frameId = 0 ; context -> txBuffer = memPoolAlloc ( ETH_MAX_FRAME_SIZE ) ; context -> rxBuffer = memPoolAlloc ( ETH_MAX_FRAME_SIZE ) ; if ( context -> txBuffer == NULL || context -> rxBuffer == NULL ) { memPoolFree ( context -> txBuffer ) ; memPoolFree ( context -> rxBuffer ) ; return ERROR_OUT_OF_MEMORY ; } ksz8851WriteReg ( interface , KSZ8851_MARH , htons ( interface -> macAddr . w [ 0 ] ) ) ; ksz8851WriteReg ( interface , KSZ8851_MARM , htons ( interface -> macAddr . w [ 1 ] ) ) ; ksz8851WriteReg ( interface , KSZ8851_MARM , htons ( interface -> macAddr . w [ 2 ] ) ) ; k
",0,511
803,"void ppp_unregister_channel ( struct ppp_channel * chan ) { struct channel * pch = chan -> ppp ; struct ppp_net * pn ; if ( ! pch ) return ; chan -> ppp = NULL ; down_write ( & pch -> chan_sem ) ; spin_lock_bh ( & pch -> downl ) ; pch -> chan = NULL ; spin_unlock_bh ( & pch -> downl ) ; up_write ( & pch -> chan_sem ) ; ppp_disconnect_channel ( pch ) ; pn = ppp_pernet ( pch -> chan_net ) ; spin_lock_bh ( & pn -> all_channels_lock ) ; pch -> file . dead = 1 ; wake_up_interruptible ( & pch -> file . rwait ) ; if ( atomic_dec_and_test ( & pch -> file . refcnt ) ) ppp_destroy_channel ( pch ) ; }
",0,230
804,"static int do_setxattr ( struct btrfs_trans_handle * trans , struct inode * inode , const char * name , const void * value , size_t size , int flags ) { struct btrfs_dir_item * di = NULL ; struct btrfs_root * root = BTRFS_I ( inode ) -> root ; struct btrfs_path * path ; size_t name_len = strlen ( name ) ; int ret = 0 ; if ( name_len + size > BTRFS_MAX_XATTR_SIZE ( root ) ) return - ENOSPC ; path = btrfs_alloc_path ( ) ; if ( ! path ) return - ENOMEM ; path -> skip_release_on_error = 1 ; path -> skip_release_flags &= ~ XATTR_REPLACE ; if ( flags & XATTR_REPLACE ) { di = btrfs_lookup_xattr ( trans , root , path , btrfs_ino ( inode ) , name , name_len , - 1 ) ; if ( IS_ERR ( di ) ) { ret = PTR_ERR ( di ) ; goto out ; } else if ( ! di ) { ret = - ENODATA ; goto out ; } ret = btrfs_delete_one_dir_name ( trans , root , path , di ) ; if ( ret ) goto out ; btrfs_release_path ( path ) ; if ( ! value ) goto out ; } else { di = btrfs_lookup_xattr ( NULL , root , path , btrfs_ino ( inode ) , name , name_len , 0 ) ; if ( IS_ERR ( di ) ) { ret = PTR_ERR ( di ) ; goto out ; } if ( ! di && ! value ) goto out ; btrfs_release_path ( path ) ; } again : ret = btrfs_insert_xattr_item ( trans , root , path , btrfs_ino ( inode ) , name , name_len , value , size ) ; if ( ret == - EOVERFLOW ) ret = - EEXIST ; if ( ret == - EEXIST ) { if ( flags & XATTR_CREATE ) goto out ; btrfs_release_
",0,511
805,"int wasm_dis ( WasmOp * op , const unsigned char * buf , int buf_len ) { op -> len = 1 ; op -> op = buf [ 0 ] ; if ( op -> op > 0xbf ) return 1 ; WasmOpDef * opdef = & opcodes [ op -> op ] ; switch ( op -> op ) { case WASM_OP_TRAP : case WASM_OP_NOP : case WASM_OP_ELSE : case WASM_OP_RETURN : case WASM_OP_DROP : case WASM_OP_SELECT : case WASM_OP_I32EQZ : case WASM_OP_I32EQ : case WASM_OP_I32NE : case WASM_OP_I32LTS : case WASM_OP_I32LTU : case WASM_OP_I32GTS : case WASM_OP_I32GTU : case WASM_OP_I32LES : case WASM_OP_I32LEU : case WASM_OP_I32GES : case WASM_OP_I32GEU : case WASM_OP_I64EQZ : case WASM_OP_I64EQ : case WASM_OP_I64NE : case WASM_OP_I64LTS : case WASM_OP_I64LTU : case WASM_OP_I64GTS : case WASM_OP_I64GTU : case WASM_OP_I64LES : case WASM_OP_I64LEU : case WASM_OP_I64GES : case WASM_OP_I64GEU : case WASM_OP_F32EQ : case WASM_OP_F32NE : case WASM_OP_F32LT : case WASM_OP_F32GT : case WASM_OP_F32LE : case WASM_OP_F32GE : case WASM_OP_F64EQ : case WASM_OP_F64NE : case WASM_OP_F64LT : case WASM_OP_F64GT : case WASM_OP_F64LE : case WASM_OP_F64GE : case WASM_OP_I32CLZ : case WASM_OP_I32CT :
",0,511
806,"static void flatpak_proxy_client_finalize ( GObject * object ) { FlatpakProxyClient * client = FLATPAK_PROXY_CLIENT ( object ) ; client -> proxy ) ; g_byte_array_free ( client -> auth_buffer , TRUE -> clients = g_list_remove ( client -> proxy -> clients , client ) ; g_clear_object ( & client -> proxy ) ; g_hash_table_destroy ( client -> rewrite_reply ) ; g_hash_table_destroy ( client -> get_owner_reply ) ; g_hash_table_destroy ( client -> unique_id_policy ) ; free_side ( & client -> client_side ) ; free_side ( & client -> bus_side ) ; G_OBJECT_CLASS ( flatpak_proxy_client_parent_class ) -> finalize ( object ) ; }
",1,189
807,"void vp9_encode_intra_block_plane ( MACROBLOCK * x , BLOCK_SIZE bsize , int plane ) { const MACROBLOCKD * const xd = & x -> e_mbd ; struct encode_b_args arg = { x , NULL , & xd -> mi [ 0 ] -> mbmi . skip } ; vp9_foreach_transformed_block_in_plane ( xd , bsize , plane , & arg ) ; }
",0,111
808,"static int trusted_update ( struct key * key , struct key_preparsed_payload * prep ) { struct trusted_key_payload * p ; struct trusted_key_payload * new_p ; struct trusted_key_options * new_o ; size_t datalen = prep -> datalen ; char * datablob ; int ret = 0 ; if ( key_is_negative ( key ) ) return - ENOKEY ; p = key -> payload . data [ 0 ] ; if ( ! p -> migratable ) return - EPERM ; if ( datalen <= 0 || datalen > 32767 || ! prep -> data ) return - EINVAL ; datablob = kmalloc ( datalen + 1 , GFP_KERNEL ) ; if ( ! datablob ) return - ENOMEM ; new_o = trusted_options_alloc ( ) ; if ( ! new_o ) { ret = - ENOMEM ; goto out ; } new_p = trusted_payload_alloc ( key ) ; if ( ! new_p ) { ret = - ENOMEM ; goto out ; } memcpy ( datablob , prep -> data , datalen ) ; datablob [ datalen ] = '\\0' ; ret = datablob_parse ( datablob , new_p , new_o ) ; if ( ret != Opt_update ) { ret = - EINVAL ; kzfree ( new_p ) ; goto out ; } if ( ! new_o -> keyhandle ) { ret = - EINVAL ; kzfree ( new_p ) ; goto out ; } new_p -> migratable = p -> migratable ; new_p -> key_len = p -> key_len ; memcpy ( new_p -> key , p -> key , p -> key_len ) ; dump_payload ( p ) ; dump_payload ( new_p ) ; ret = key_seal ( new_p , new_o ) ; if ( ret < 0 ) { pr_info ( ""trusted_key:key_sealfailed(%d)\\n"" , ret ) ; kzfree ( new_p ) ; goto out ; } if ( new_o -> pcrlock ) { ret = pcrlock ( new_o -> pcrlock
",0,511
809,"int lzo1x_decompress_safe ( const unsigned char * in , size_t in_len , unsigned char * out , size_t * out_len ) { unsigned char * op ; const unsigned char * ip ; size_t t , next ; size_t state = 0 ; const unsigned char * m_pos ; const unsigned char * const ip_end = in + in_len ; unsigned char * const op_end = out + * out_len ; op = out ; ip = in ; if ( unlikely ( in_len < 3 ) ) goto input_overrun ; if ( * ip > 17 ) { t = * ip ++ - 17 ; if ( t < 4 ) { next = t ; goto match_next ; } goto copy_literal_run ; } for ( ; ; ) { t = * ip ++ ; if ( t < 16 ) { if ( likely ( state == 0 ) ) { if ( unlikely ( t == 0 ) ) { while ( unlikely ( * ip == 0 ) ) { t += 255 ; ip ++ ; NEED_IP ( 1 , 0 ) ; } t += 15 + * ip ++ ; } t += 3 ; copy_literal_run : # if defined ( CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS ) if ( likely ( HAVE_IP ( t , 15 ) && HAVE_OP ( t , 15 ) ) ) { const unsigned char * ie = ip + t ; unsigned char * oe = op + t ; do { COPY8 ( op , ip ) ; op += 8 ; ip += 8 ; COPY8 ( op , ip ) ; op += 8 ; ip += 8 ; } while ( ip < ie ) ; ip = ie ; op = oe ; } else # endif { NEED_OP ( t , 0 ) ; NEED_IP ( t , 3 ) ; do { * op ++ = * ip ++ ; } while ( -- t > 0 ) ; } state = 4 ; continue ; } else if ( state != 4 ) { next = t & 3 ; m_pos = op - 1 ; m_pos -= t >> 2 ; m_pos -= * ip ++ << 2 ; TEST_LB ( m_pos ) ; NEED_OP ( 2 , 0 ) ; op [ 0 ] = m_pos [ 0 ] ; op [ 1 ] = m_pos [ 1 ] ; op += 2 ;
",0,511
810,"int fit_image_load ( bootm_headers_t * images , ulong addr , const char * * fit_unamep , const char * * fit_uname_configp , int arch , int image_type , int bootstage_id , enum fit_load_op load_op , ulong * datap , ulong * lenp ) { int cfg_noffset , noffset ; const char * fit_uname ; const char * fit_uname_config ; const char * fit_base_uname_config ; const void * fit ; void * buf ; void * loadbuf ; size_t size ; int type_ok , os_ok ; ulong load , load_end , data , len ; uint8_t os , comp ; # ifndef USE_HOSTCC uint8_t os_arch ; # endif const char * prop_name ; int ret ; fit = map_sysmem ( addr , 0 ) ; fit_uname = fit_unamep ? * fit_unamep : NULL ; fit_uname_config = fit_uname_configp ? * fit_uname_configp : NULL ; fit_base_uname_config = NULL ; prop_name = fit_get_image_type_property ( image_type ) ; printf ( ""##Loading%sfromFITImageat%08lx...\\n"" , prop_name , addr ) ; bootstage_mark ( bootstage_id + BOOTSTAGE_SUB_FORMAT ) ; if ( fit_check_format ( fit , IMAGE_SIZE_INVAL ) ) { printf ( ""BadFIT%simageformat
",0,366
811,"void receive_tcppacket ( connection_t * c , const char * buffer , int len ) { vpn_packet_t outpkt ; if ( len > sizeof outpkt . data ) return ; outpkt . len = len ; if ( c -> options & OPTION_TCPONLY ) outpkt . priority = 0 ; else outpkt . priority = - 1 ; memcpy ( outpkt . data , buffer , len ) ; receive_packet ( c -> node , & outpkt ) ; }
",1,111
812,"static __init int hardware_setup ( void ) { int r = - ENOMEM , i , msr ; rdmsrl_safe ( MSR_EFER , & host_efer ) ; for ( i = 0 ; i < ARRAY_SIZE ( vmx_msr_index ) ; ++ i ) kvm_define_shared_msr ( i , vmx_msr_index [ i ] ) ; vmx_io_bitmap_a = ( unsigned long * ) __get_free_page ( GFP_KERNEL ) ; if ( ! vmx_io_bitmap_a ) return r ; vmx_io_bitmap_b = ( unsigned long * ) __get_free_page ( GFP_KERNEL ) ; if ( ! vmx_io_bitmap_b ) goto out ; vmx_msr_bitmap_legacy = ( unsigned long * ) __get_free_page ( GFP_KERNEL ) ; if ( ! vmx_msr_bitmap_legacy ) goto out1 ; vmx_msr_bitmap_legacy_x2apic = ( unsigned long * ) __get_free_page ( GFP_KERNEL ) ; if ( ! vmx_msr_bitmap_legacy_x2apic ) goto out2 ; vmx_msr_bitmap_longmode = ( unsigned long * ) __get_free_page ( GFP_KERNEL ) ; if ( ! vmx_msr_bitmap_longmode ) goto out3 ; vmx_msr_bitmap_longmode_x2apic = ( unsigned long * ) __get_free_page ( GFP_KERNEL ) ; if ( ! vmx_msr_bitmap_longmode_x2apic ) goto out4 ; if ( nested ) { vmx_msr_bitmap_nested = ( unsigned long * ) __get_free_page ( GFP_KERNEL ) ; if ( ! vmx_msr_bitmap_nested ) goto out5 ; } vmx_vmread_bitmap = ( unsigned long * ) __get_free_page ( GFP_KERNEL ) ; if ( ! vmx_vmread_bitmap ) goto out6 ;
",0,511
813,"static Sdb * store_versioninfo_gnu_verdef ( ELFOBJ * bin , Elf_ ( Shdr ) * shdr , int sz ) { const char * section_name = """" ; const char * link_section_name = """" ; char * end = NULL ; Elf_ ( Shdr ) * link_shdr = NULL ; ut8 dfs [ sizeof ( Elf_ ( Verdef ) ) ] = { 0 } ; Sdb * sdb ; int cnt , i ; if ( shdr -> sh_link > bin -> ehdr . e_shnum ) { return false ; } link_shdr = & bin -> shdr [ shdr -> sh_link ] ; if ( shdr -> sh_size < 1 || shdr -> sh_size > SIZE_MAX ) { return false ; } Elf_ ( Verdef ) * defs = calloc ( shdr -> sh_size , sizeof ( char ) ) ; if ( ! defs ) { return false ; } if ( bin -> shstrtab && shdr -> sh_name < bin -> shstrtab_size ) { section_name = & bin -> shstrtab [ shdr -> sh_name ] ; } if ( link_shdr && bin -> shstrtab && link_shdr -> sh_name < bin -> shstrtab_size ) { link_section_name = & bin -> shstrtab [ link_shdr -> sh_name ] ; } if ( ! defs ) { bprintf ( ""Warning:Cannotallocatememory(CheckElf_(Verdef))\\n"" ) ; return NULL ; } sdb = sdb_new0 ( ) ; end = ( char * ) defs + shdr -> sh_size ; sdb_set ( sdb , ""section_name"" , section_name , 0 ) ; sdb_num_set ( sdb , ""entries"" , shdr -> sh_info , 0 ) ; sdb_num_set ( sdb , ""addr"" , shdr -> sh_addr , 0 ) ; sdb_num_set ( sdb , ""offset"" , shdr -> sh_offset , 0 ) ; sdb_num_set ( sdb , ""link"" , shdr -> sh_link , 0 ) ; sdb_set ( sdb , ""link_section_name""
",0,511
814,"void close_uinput ( void ) { BTIF_TRACE_DEBUG ( ""%s"" , __FUNCTION__ ) ; if ( uinput_fd > 0 ) { ioctl ( uinput_fd , UI_DEV_DESTROY ) ; uinput_fd = - 1 ; } }
",0,66
815,"static int calc_pframe_target_size_one_pass_vbr ( const VP9_COMP * const cpi ) { static const int af_ratio = 10 ; const RATE_CONTROL * const rc = & cpi -> rc ; int target ; # if USE_ALTREF_FOR_ONE_PASS target = ( ! rc -> is_src_frame_alt_ref && ( cpi -> refresh_golden_frame || cpi -> refresh_alt_ref_frame ) ) ? ( rc -> avg_frame_bandwidth * rc -> baseline_gf_interval * af_ratio ) / ( rc -> baseline_gf_interval + af_ratio - 1 ) : ( rc -> avg_frame_bandwidth * rc -> baseline_gf_interval ) / ( rc -> baseline_gf_interval + af_ratio - 1 ) ; # else target = rc -> avg_frame_bandwidth ; # endif return vp9_rc_clamp_pframe_target_size ( cpi , target ) ; }
",0,237
816,"int main ( int argc , const char * argv [ ] ) { struct group * grent ; const char * cmd ; const char * path ; int i ; struct passwd * pw ; grent = getgrnam ( ABUILD_GROUP ) ; if ( grent == NULL ) errx ( 1 , ""%s:Groupnotfound"" , ABUILD_GROUP ) ; char * name = NULL ; pw = getpwuid ( getuid ( ) ) ; if ( pw ) name = pw -> pw_name ; if ( ! is_in_group ( grent -> gr_gid ) ) { errx ( 1 , ""User%sisnotamemberofgroup%s\\n"" , name ? name : ""(unknown)"" , ABUILD_GROUP ) ; } if ( name == NULL ) warnx ( ""Couldnotfindusernameforuid%d\\n"" , getuid ( ) ) ; setenv ( ""USER"" , name ? : """" , 1 ) ; cmd = strrchr ( argv [ 0 ] , '/' ) ; if ( cmd ) cmd ++ ; else cmd = argv [ 0 ] ; cmd = strchr ( cmd , '-' ) ; if ( cmd == NULL ) errx ( 1 , ""Callingcommandhasno\'-\'"" ) ; cmd ++ ; path = get_command_path ( cmd ) ; if ( path == NULL ) errx ( 1 , ""%s:Notavalidsubcommand"" , cmd ) ; for ( i = 1 ; i < argc ; i ++ ) if ( strcmp ( argv [ i ] , ""--allow-untrusted"" ) == 0 || strcmp ( argv [ i ] , ""--allow-untrusted"" ) == 0 ) errx ( 1 , ""%s:notallowedoption"" , ""--allow-untrusted"" ) ; argv [ 0 ] = path ; setuid ( 0 ) ; setgid ( 0 ) ; execv ( path , ( char * const * ) argv ) ; perror ( path ) ; return 1 ; }
",0,449
817,"PyObject * ast2obj_mod ( void * _o ) { mod_ty o = ( mod_ty ) _o ; PyObject * result = NULL , * value = NULL ; if ( ! o ) { Py_RETURN_NONE ; } switch ( o -> kind ) { case Module_kind : result = PyType_GenericNew ( Module_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . Module . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . Module . type_ignores , ast2obj_type_ignore ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_type_ignores , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Interactive_kind : result = PyType_GenericNew ( Interactive_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . Interactive . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case Expression_kind : result = PyType_GenericNew ( Expression_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . Expression . body ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; case FunctionType_kind : result = PyType_GenericNew ( FunctionType_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_list ( o -> v . FunctionType . argtypes , ast2obj_expr ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & Py
",0,511
818,"static void feed_table_block_tag ( struct table * tbl , char * line , struct table_mode * mode , int indent , int cmd ) { int offset ; if ( mode -> indent_level <= 0 && indent == - 1 ) return ; if ( mode -> indent_level >= CHAR_MAX && indent == 1 ) return ; setwidth ( tbl , mode ) ; feed_table_inline_tag ( tbl , line , mode , - 1 ) ; clearcontentssize ( tbl , mode ) ; if ( indent == 1 ) { mode -> indent_level ++ ; if ( mode -> indent_level <= MAX_INDENT_LEVEL ) tbl -> indent += INDENT_INCR ; } if ( tbl -> indent < 0 ) tbl -> indent = 0 ; offset = tbl -> indent ; if ( cmd == HTML_DT ) { if ( mode -> indent_level > 0 && mode -> indent_level <= MAX_INDENT_LEVEL ) offset -= INDENT_INCR ; } if ( tbl -> indent > 0 ) { check_minimum0 ( tbl , 0 ) ; addcontentssize ( tbl , offset ) ; } }
",0,253
819,"static int cdf_check_stream_offset ( const cdf_stream_t * sst , const cdf_header_t * h , const void * p , size_t tail , int line ) { const char * b = ( const char * ) sst -> sst_tab ; const char * e = ( ( const char * ) p ) + tail ; size_t ss = sst -> sst_dirlen < h -> h_min_size_standard_stream ? CDF_SHORT_SEC_SIZE ( h ) : CDF_SEC_SIZE ( h ) ; ( void ) & line ; if ( e >= b && ( size_t ) ( e - b ) <= ss * sst -> sst_len ) return 0 ; DPRINTF ( ( ""%d:offsetbegin%p<end%p||%"" SIZE_T_FORMAT ""u"" "">%"" SIZE_T_FORMAT ""u[%"" SIZE_T_FORMAT ""u%"" SIZE_T_FORMAT ""u]\\n"" , line , b , e , ( size_t ) ( e - b ) , ss * sst -> sst_len , CDF_SEC_SIZE ( h ) , sst -> sst_len ) ) ; errno = EFTYPE ; return - 1 ; }
",1,293
820,"int yyparse ( void * yyscanner , HEX_LEX_ENVIRONMENT * lex_env ) { int yychar ; YY_INITIAL_VALUE ( static YYSTYPE yyval_default ; ) YYSTYPE yylval YY_INITIAL_VALUE ( = yyval_default ) ; int yynerrs ; int yystate ; int yyerrstatus ; yytype_int16 yyssa [ YYINITDEPTH ] ; yytype_int16 * yyss ; yytype_int16 * yyssp ; YYSTYPE yyvsa [ YYINITDEPTH ] ; YYSTYPE * yyvs ; YYSTYPE * yyvsp ; YYSIZE_T yystacksize ; int yyn ; int yyresult ; int yytoken = 0 ; YYSTYPE yyval ; # if YYERROR_VERBOSE char yymsgbuf [ 128 ] ; char * yymsg = yymsgbuf ; YYSIZE_T yymsg_alloc = sizeof yymsgbuf ; # endif # define YYPOPSTACK ( N ) ( yyvsp -= ( N ) , yyssp -= ( N ) ) int yylen = 0 ; yyssp = yyss = yyssa ; yyvsp = yyvs = yyvsa ; yystacksize = YYINITDEPTH ; YYDPRINTF ( ( stderr , ""Startingparse\\n"" ) ) ; yystate = 0 ; yyerrstatus = 0 ; yynerrs = 0 ; yychar = YYEMPTY ; goto yysetstate ; yynewstate : yyssp ++ ; yysetstate : * yyssp = yystate ; if ( yyss + yystacksize - 1 <= yyssp ) { YYSIZE_T yysize = yyssp - yyss + 1 ; # ifdef yyoverflow { YYSTYPE * yyvs1 = yyvs ; yytype_int16 * yyss1 = yyss ; yyoverflow ( YY_ ( ""memoryexhausted"" ) , & yyss1 , yysize
",0,511
821,"static void optimize_b ( MACROBLOCK * mb , int ib , int type , ENTROPY_CONTEXT * a , ENTROPY_CONTEXT * l ) { BLOCK * b ; BLOCKD * d ; vp8_token_state tokens [ 17 ] [ 2 ] ; unsigned best_mask [ 2 ] ; const short * dequant_ptr ; const short * coeff_ptr ; short * qcoeff_ptr ; short * dqcoeff_ptr ; int eob ; int i0 ; int rc ; int x ; int sz = 0 ; int next ; int rdmult ; int rddiv ; int final_eob ; int rd_cost0 ; int rd_cost1 ; int rate0 ; int rate1 ; int error0 ; int error1 ; int t0 ; int t1 ; int best ; int band ; int pt ; int i ; int err_mult = plane_rd_mult [ type ] ; b = & mb -> block [ ib ] ; d = & mb -> e_mbd . block [ ib ] ; # if 0 vpx_strict_quantize_b ( b , d ) ; # endif dequant_ptr = d -> dequant ; coeff_ptr = b -> coeff ; qcoeff_ptr = d -> qcoeff ; dqcoeff_ptr = d -> dqcoeff ; i0 = ! type ; eob = * d -> eob ; rdmult = mb -> rdmult * err_mult ; if ( mb -> e_mbd . mode_info_context -> mbmi . ref_frame == INTRA_FRAME ) rdmult = ( rdmult * 9 ) >> 4 ; rddiv = mb -> rddiv ; best_mask [ 0 ] = best_mask [ 1 ] = 0 ; tokens [ eob ] [ 0 ] . rate = 0 ; tokens [ eob ] [ 0 ] . error = 0 ; tokens [ eob ] [ 0 ] . next = 16 ; tokens [ eob ] [ 0 ] . token = DCT_EOB_TOKEN ; tokens [ eob ] [ 0 ] . qc = 0 ; * ( tokens [ eob ] + 1 ) = * ( tokens [ eob ] + 0 ) ; next = eob ; for ( i =
",0,511
822,"static int process_options ( int argc , char * argv [ ] , char * operation ) { int error = 0 ; int i = 0 ; if ( ( error = handle_options ( & argc , & argv , my_long_options , get_one_option ) ) ) goto exit ; if ( opt_print_defaults ) { error = - 1 ; goto exit ; } if ( opt_basedir ) { i = ( int ) strlength ( opt_basedir ) ; if ( opt_basedir [ i - 1 ] != FN_LIBCHAR || opt_basedir [ i - 1 ] != FN_LIBCHAR2 ) { char buff [ FN_REFLEN ] ; if ( strlen ( buff ) > sizeof ( buff ) - 1 ) strncpy ( buff , opt_basedir , sizeof ( buff ) - 1 ) ; # ifdef __WIN__ strncat ( buff , ""/"" , sizeof ( buff ) - strlen ( buff ) - 1 ) ; # else strncat ( buff , FN_DIRSEP , sizeof ( buff ) - strlen ( buff ) - 1 ) ; # endif buff [ sizeof ( buff ) - 1 ] = 0 ; my_free ( opt_basedir ) ; opt_basedir = my_strdup ( buff , MYF ( MY_FAE ) ) ; } } if ( ! opt_no_defaults && ( ( error = get_default_values ( ) ) ) ) { error = - 1 ; goto exit ; } strcpy ( operation , """" ) ; if ( ( error = check_options ( argc , argv , operation ) ) ) { goto exit ; } if ( opt_verbose ) { printf ( ""#basedir=%s\\n"" , opt_basedir ) ; printf ( ""#plugin_dir=%s\\n"" , opt_plugin_dir ) ; printf ( ""#datadir=%s\\n"" , opt_datadir ) ; printf ( ""#plugin_ini=%s\\n"" , opt_plugin_ini ) ; } exit : return error ; }
",0,456
823,"int user_update ( struct key * key , struct key_preparsed_payload * prep ) { struct user_key_payload * zap = NULL ; int ret ; ret = key_payload_reserve ( key , prep -> datalen ) ; if ( key_is_positive ( key ) ) zap = dereference_key_locked ( key ) ; rcu_assign_keypointer ( key , prep -> payload . data [ 0 ] ) ; prep -> payload . data [ 0 ] = NULL ; if ( zap ) call_rcu ( & zap -> rcu , user_free_payload_rcu ) ; return ret ; }
",1,147
824,"static int hci_sock_getsockopt ( struct socket * sock , int level , int optname , char __user * optval , int __user * optlen ) { struct hci_ufilter uf ; struct sock * sk = sock -> sk ; int len , opt , err = 0 ; BT_DBG ( ""sk%p,opt%d"" , sk , optname ) ; if ( get_user ( len , optlen ) ) return - EFAULT ; lock_sock ( sk ) ; if ( hci_pi ( sk ) -> channel != HCI_CHANNEL_RAW ) { err = - EINVAL ; goto done ; } switch ( optname ) { case HCI_DATA_DIR : if ( hci_pi ( sk ) -> cmsg_mask & HCI_CMSG_DIR ) opt = 1 ; else opt = 0 ; if ( put_user ( opt , optval ) ) err = - EFAULT ; break ; case HCI_TIME_STAMP : if ( hci_pi ( sk ) -> cmsg_mask & HCI_CMSG_TSTAMP ) opt = 1 ; else opt = 0 ; if ( put_user ( opt , optval ) ) err = - EFAULT ; break ; case HCI_FILTER : { struct hci_filter * f = & hci_pi ( sk ) -> filter ; memset ( & uf , 0 , sizeof ( uf ) ) ; uf . type_mask = f -> type_mask ; uf . opcode = f -> opcode ; uf . event_mask [ 0 ] = * ( ( u32 * ) f -> event_mask + 0 ) ; uf . event_mask [ 1 ] = * ( ( u32 * ) f -> event_mask + 1 ) ; } len = min_t ( unsigned int , len , sizeof ( uf ) ) ; if ( copy_to_user ( optval , & uf , len ) ) err = - EFAULT ; break ; default : err = - ENOPROTOOPT ; break ; } done : release_sock ( sk ) ; return err ; }
",1,471
825,"int vp8_decode_frame ( VP8D_COMP * pbi ) { vp8_reader * const bc = & pbi -> mbc [ 8 ] ; VP8_COMMON * const pc = & pbi -> common ; MACROBLOCKD * const xd = & pbi -> mb ; const unsigned char * data = pbi -> fragments . ptrs [ 0 ] ; const unsigned char * data_end = data + pbi -> fragments . sizes [ 0 ] ; ptrdiff_t first_partition_length_in_bytes ; int i , j , k , l ; const int * const mb_feature_data_bits = vp8_mb_feature_data_bits ; int corrupt_tokens = 0 ; int prev_independent_partitions = pbi -> independent_partitions ; YV12_BUFFER_CONFIG * yv12_fb_new = pbi -> dec_fb_ref [ INTRA_FRAME ] ; xd -> corrupted = 0 ; yv12_fb_new -> corrupted = 0 ; if ( data_end - data < 3 ) { if ( ! pbi -> ec_active ) { vpx_internal_error ( & pc -> error , VPX_CODEC_CORRUPT_FRAME , ""Truncatedpacket"" ) ; } pc -> frame_type = INTER_FRAME ; pc -> version = 0 ; pc -> show_frame = 1 ; first_partition_length_in_bytes = 0 ; } else { unsigned char clear_buffer [ 10 ] ; const unsigned char * clear = data ; if ( pbi -> decrypt_cb ) { int n = ( int ) ( data_end - data ) ; if ( n > 10 ) n = 10 ; pbi -> decrypt_cb ( pbi -> decrypt_state , data , clear_buffer , n ) ; clear = clear_buffer ; } pc -> frame_type = ( FRAME_TYPE ) ( clear [ 0 ] & 1 ) ; pc -> version = ( clear [ 0 ] >> 1 ) & 7 ; pc -> show_frame = ( clear [ 0 ] >> 4 ) & 1 ; first_partition_length_in_bytes = ( clear [ 0 ] | ( clear [ 1 ] << 8 ) | ( clear [ 2 ] << 16 ) ) >> 5 ; if (
",0,511
826,"private void getprivs_ret * get_privs_2_svc ( krb5_ui_4 * arg , struct svc_req * rqstp ) { static getprivs_ret ret ; gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER ; OM_uint32 minor_stat ; kadm5_server_handle_t handle ; const char * errmsg = NULL ; xdr_free ( xdr_getprivs_ret , & ret ) ; if ( ( ret . code = new_server_handle ( * arg , rqstp , & handle ) ) ) goto exit_func ; if ( ( ret . code = check_handle ( ( void * ) handle ) ) ) goto exit_func ; ret . api_version = handle -> api_version ; if ( setup_gss_names ( rqstp , & client_name , & service_name ) < 0 ) { ret . code = KADM5_FAILURE ; goto exit_func ; } ret . code = kadm5_get_privs ( ( void * ) handle , & ret . privs ) ; if ( ret . code != 0 ) errmsg = krb5_get_error_message ( handle -> context , ret . code ) ; log_done ( ""kadm5_get_privs"" , client_name . value , errmsg , & client_name , & service_name , rqstp ) ; if ( errmsg != NULL ) krb5_free_error_message ( handle -> context , errmsg ) ; free_server_handle ( handle ) ; return & ret ; }
",0,388
827,"void sctp_assoc_update ( struct sctp_association * asoc , struct sctp_association * new ) { struct sctp_transport * trans ; struct list_head * pos , * temp ; asoc -> c = new -> c ; asoc -> peer . rwnd = new -> peer . rwnd ; asoc -> peer . sack_needed = new -> peer . sack_needed ; asoc -> peer . i = new -> peer . i ; sctp_tsnmap_init ( & asoc -> peer . tsn_map , SCTP_TSN_MAP_INITIAL , asoc -> peer . i . initial_tsn , GFP_ATOMIC ) ; list_for_each_safe ( pos , temp , & asoc -> peer . transport_addr_list ) { trans = list_entry ( pos , struct sctp_transport , transports ) ; if ( ! sctp_assoc_lookup_paddr ( new , & trans -> ipaddr ) ) { sctp_assoc_rm_peer ( asoc , trans ) ; continue ; } if ( asoc -> state >= SCTP_STATE_ESTABLISHED ) sctp_transport_reset ( trans ) ; } if ( asoc -> state >= SCTP_STATE_ESTABLISHED ) { asoc -> next_tsn = new -> next_tsn ; asoc -> ctsn_ack_point = new -> ctsn_ack_point ; asoc -> adv_peer_ack_point = new -> adv_peer_ack_point ; sctp_ssnmap_clear ( asoc -> ssnmap ) ; sctp_ulpq_flush ( & asoc -> ulpq ) ; asoc -> overall_error_count = 0 ; } else { list_for_each_entry ( trans , & new -> peer . transport_addr_list , transports ) { if ( ! sctp_assoc_lookup_paddr ( asoc , & trans -> ipaddr ) ) sctp_assoc_add_peer ( asoc , & trans -> ipaddr , GFP_ATOMIC , trans -> state ) ; } asoc -> ctsn_ack_point = asoc -> next_
",0,511
828,"static int aac_send_raw_srb ( struct aac_dev * dev , void __user * arg ) { struct fib * srbfib ; int status ; struct aac_srb * srbcmd = NULL ; struct user_aac_srb * user_srbcmd = NULL ; struct user_aac_srb __user * user_srb = arg ; struct aac_srb_reply __user * user_reply ; struct aac_srb_reply * reply ; u32 fibsize = 0 ; u32 flags = 0 ; s32 rcode = 0 ; u32 data_dir ; void __user * sg_user [ 32 ] ; void * sg_list [ 32 ] ; u32 sg_indx = 0 ; u32 byte_count = 0 ; u32 actual_fibsize64 , actual_fibsize = 0 ; int i ; if ( dev -> in_reset ) { dprintk ( ( KERN_DEBUG ""aacraid:sendrawsrb-EBUSY\\n"" ) ) ; return - EBUSY ; } if ( ! capable ( CAP_SYS_ADMIN ) ) { dprintk ( ( KERN_DEBUG ""aacraid:Nopermissiontosendrawsrb\\n"" ) ) ; return - EPERM ; } if ( ! ( srbfib = aac_fib_alloc ( dev ) ) ) { return - ENOMEM ; } aac_fib_init ( srbfib ) ; srbfib -> hw_fib_va -> header . XferState &= ~ cpu_to_le32 ( FastResponseCapable ) ; srbcmd = ( struct aac_srb * ) fib_data ( srbfib ) ; memset ( sg_list , 0 , sizeof ( sg_list ) ) ; if ( copy_from_user ( & fibsize , & user_srb -> count , sizeof ( u32 ) ) ) { dprintk ( ( KERN_DEBUG ""aacraid:Couldnotcopydatasizefromuser\\n"" ) ) ; rcode = - EFAULT ; goto cleanup ; } if ( fibsize > ( dev -> max_fib_size - sizeof ( struct aac_fibhdr ) ) ) { rcode = - E
",0,511
829,"static int PredictorEncodeTile ( TIFF * tif , uint8 * bp0 , tmsize_t cc0 , uint16 s ) { static const char module [ ] = ""PredictorEncodeTile"" ; TIFFPredictorState * sp = PredictorState ( tif ) ; uint8 * working_copy ; tmsize_t cc = cc0 , rowsize ; unsigned char * bp ; int result_code ; assert ( sp != NULL ) ; assert ( sp -> encodepfunc != NULL ) ; assert ( sp -> encodetile != NULL ) ; working_copy = ( uint8 * ) _TIFFmalloc ( cc0 ) ; if ( working_copy == NULL ) { TIFFErrorExt ( tif -> tif_clientdata , module , ""Outofmemoryallocating"" TIFF_SSIZE_FORMAT ""bytetempbuffer."" , cc0 ) ; return 0 ; } memcpy ( working_copy , bp0 , cc0 ) ; bp = working_copy ; rowsize = sp -> rowsize ; assert ( rowsize > 0 ) ; if ( ( cc0 % rowsize ) != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , ""PredictorEncodeTile"" , ""%s"" , ""(cc0%rowsize)!=0"" ) ; return 0 ; } while ( cc > 0 ) { ( * sp -> encodepfunc ) ( tif , bp , rowsize ) ; cc -= rowsize ; bp += rowsize ; } result_code = ( * sp -> encodetile ) ( tif , working_copy , cc0 , s ) ; _TIFFfree ( working_copy ) ; return result_code ; }
",1,382
830,"void sctp_generate_proto_unreach_event ( unsigned long data ) { struct sctp_transport * transport = ( struct sctp_transport * ) data ; struct sctp_association * asoc = transport -> asoc ; struct sock * sk = asoc -> base . sk ; struct net * net = sock_net ( sk ) ; bh_lock_sock ( asoc -> base . sk ) ; if ( sock_owned_by_user ( sk ) ) { pr_debug ( ""%s:sockisbusy\\n"" , __func__ ) ; if ( ! mod_timer ( & transport -> proto_unreach_timer , jiffies + ( HZ / 20 ) ) ) sctp_association_hold ( asoc ) ; goto out_unlock ; } if ( asoc -> base . dead ) goto out_unlock ; sctp_do_sm ( net , SCTP_EVENT_T_OTHER , SCTP_ST_OTHER ( SCTP_EVENT_ICMP_PROTO_UNREACH ) , asoc -> state , asoc -> ep , asoc , transport , GFP_ATOMIC ) ; out_unlock : bh_unlock_sock ( sk ) ; sctp_association_put ( asoc ) ; }
",1,300
831,"int yr_re_exec ( uint8_t * re_code , uint8_t * input_data , size_t input_forwards_size , size_t input_backwards_size , int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args ) { uint8_t * ip ; uint8_t * input ; uint8_t mask ; uint8_t value ; RE_FIBER_LIST fibers ; RE_THREAD_STORAGE * storage ; RE_FIBER * fiber ; RE_FIBER * next_fiber ; int error ; int bytes_matched ; int max_bytes_matched ; int match ; int character_size ; int input_incr ; int kill ; int action ; int result = - 1 ; # define ACTION_NONE 0 # define ACTION_CONTINUE 1 # define ACTION_KILL 2 # define ACTION_KILL_TAIL 3 # define prolog { if ( ( bytes_matched < max_bytes_matched ) || ( character_size < 2 ) ) { action = ACTION_KILL ; break ; } } # define fail_if_error ( e ) { switch ( e ) { case ERROR_INSUFFICIENT_MEMORY : return - 2 ; case ERROR_TOO_MANY_RE_FIBERS : return - 4 ; } } if ( _yr_re_alloc_storage ( & storage ) != ERROR_SUCCESS ) return - 2 ; if ( flags & RE_FLAGS_WIDE ) character_size = 2 ; else character_size = 1 ; input = input_data ; input_incr = character_size ; if ( flags & RE_FLAGS_BACKWARDS ) { max_bytes_matched = ( int ) yr_min ( input_forwards_size , RE_SCAN_LIMIT ) ; max_bytes_matched = max_bytes_matched - max_bytes_matched % character_size ; bytes_matched = 0 ; error = _yr_re_fiber_create ( & storage -> fiber_pool , & fiber ) ; fail_if_error ( error ) ; fiber -> ip = re_code ; fibers . head = fiber ; fibers . tail = fiber ; error = _yr_re_fiber_sync ( & fibers , & storage -> fiber_pool ,
",0,511
832,"void vp8_rd_pick_inter_mode ( VP8_COMP * cpi , MACROBLOCK * x , int recon_yoffset , int recon_uvoffset , int * returnrate , int * returndistortion , int * returnintra , vpx_bit_depth_t bit_depth ) { BLOCK * b = & x -> block [ 0 ] ; BLOCKD * d = & x -> e_mbd . block [ 0 ] ; MACROBLOCKD * xd = & x -> e_mbd ; int_mv best_ref_mv_sb [ 2 ] ; int_mv mode_mv_sb [ 2 ] [ MB_MODE_COUNT ] ; int_mv best_ref_mv ; int_mv * mode_mv ; MB_PREDICTION_MODE this_mode ; int num00 ; int best_mode_index = 0 ; BEST_MODE best_mode ; int i ; int mode_index ; int mdcounts [ 4 ] ; int rate ; RATE_DISTORTION rd ; int uv_intra_rate , uv_intra_distortion , uv_intra_rate_tokenonly ; int uv_intra_tteob = 0 ; int uv_intra_done = 0 ; MB_PREDICTION_MODE uv_intra_mode = 0 ; int_mv mvp ; int near_sadidx [ 8 ] = { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 } ; int saddone = 0 ; int sr = 0 ; unsigned char * plane [ 4 ] [ 3 ] ; int ref_frame_map [ 4 ] ; int sign_bias = 0 ; int intra_rd_penalty = 10 * vp8_dc_quant ( cpi -> common . base_qindex , cpi -> common . y1dc_delta_q ) ; # if CONFIG_TEMPORAL_DENOISING unsigned int zero_mv_sse = INT_MAX , best_sse = INT_MAX , best_rd_sse = INT_MAX ; # endif mode_mv = mode_mv_sb [ sign_bias ] ; best_ref_mv . as_int =
",0,511
833,"static void init_vmcb ( struct vcpu_svm * svm ) { struct vmcb_control_area * control = & svm -> vmcb -> control ; struct vmcb_save_area * save = & svm -> vmcb -> save ; svm -> vcpu . fpu_active = 1 ; svm -> vcpu . arch . hflags = 0 ; set_cr_intercept ( svm , INTERCEPT_CR0_READ ) ; set_cr_intercept ( svm , INTERCEPT_CR3_READ ) ; set_cr_intercept ( svm , INTERCEPT_CR4_READ ) ; set_cr_intercept ( svm , INTERCEPT_CR0_WRITE ) ; set_cr_intercept ( svm , INTERCEPT_CR3_WRITE ) ; set_cr_intercept ( svm , INTERCEPT_CR4_WRITE ) ; set_cr_intercept ( svm , INTERCEPT_CR8_WRITE ) ; set_dr_intercepts ( svm ) ; set_exception_intercept ( svm , PF_VECTOR ) ; set_exception_intercept ( svm , UD_VECTOR ) ; set_exception_intercept ( svm , MC_VECTOR ) ; set_intercept ( svm , INTERCEPT_INTR ) ; set_intercept ( svm , INTERCEPT_NMI ) ; set_intercept ( svm , INTERCEPT_SMI ) ; set_intercept ( svm , INTERCEPT_SELECTIVE_CR0 ) ; set_intercept ( svm , INTERCEPT_RDPMC ) ; set_intercept ( svm , INTERCEPT_CPUID ) ; set_intercept ( svm , INTERCEPT_INVD ) ; set_intercept ( svm , INTERCEPT_HLT ) ; set_intercept ( svm , INTERCEPT_INVLPG ) ; set_intercept ( svm , INTERCEPT_INVLPGA ) ; set_intercept ( svm , INTERCEPT_IOIO_PROT ) ; set_intercept ( svm , INTERCEPT_MSR_PROT ) ; set_intercept ( svm , INTERCEPT_TASK_SWITCH ) ; set_intercept ( svm , INTERCEPT_SHAR
",0,511
834,"hive_h * hivex_open ( const char * filename , int flags ) { hive_h * h = NULL ; assert ( sizeof ( struct ntreg_header ) == 0x1000 ) ; assert ( offsetof ( struct ntreg_header , csum ) == 0x1fc ) ; h = calloc ( 1 , sizeof * h ) ; if ( h == NULL ) goto error ; h -> msglvl = flags & HIVEX_OPEN_MSGLVL_MASK ; const char * debug = getenv ( ""HIVEX_DEBUG"" ) ; if ( debug && STREQ ( debug , ""1"" ) ) h -> msglvl = 2 ; DEBUG ( 2 , ""createdhandle%p"" , h ) ; h -> writable = ! ! ( flags & HIVEX_OPEN_WRITE ) ; h -> filename = strdup ( filename ) ; if ( h -> filename == NULL ) goto error ; if ( h -> filename == NULL ) goto error ; # ifdef O_CLOEXEC h -> fd = open ( filename , O_RDONLY | O_CLOEXEC | O_BINARY ) ; # else h -> fd = open ( filename , O_RDONLY | O_BINARY ) ; # endif if ( h -> fd == - 1 ) goto error ; # ifndef O_CLOEXEC fcntl ( h -> fd , F_SETFD , FD_CLOEXEC ) ; # endif struct stat statbuf ; if ( fstat ( h -> fd , & statbuf ) == - 1 ) goto error ; size_t st_size ; if ( ! h -> writable ) { h -> addr = mmap ( NULL , h -> size , PROT_READ , MAP_SHARED , h -> fd , 0 ) ; if ( h -> addr == MAP_FAILED ) goto error ; DEBUG ( 2 , ""mappedfileat%p"" , h -> addr ) ; } else { h -> addr = malloc ( h -> size ) ; if ( h -> addr == NULL ) goto error ; if ( full_read ( h -> fd , h -> addr , h -> size ) < h -> size ) goto error ; if ( close ( h -> fd ) == - 1 ) goto error ; h -> fd = - 1
",0,511
835,"private int cdf_file_summary_info ( struct magic_set * ms , const cdf_header_t * h , const cdf_stream_t * sst , const uint64_t clsid [ 2 ] ) { cdf_summary_info_header_t si ; cdf_property_info_t * info ; size_t count ; int m ; if ( cdf_unpack_summary_info ( sst , h , & si , & info , & count ) == - 1 ) return - 1 ; if ( NOTMIME ( ms ) ) { const char * str ; if ( file_printf ( ms , ""CompositeDocumentFileV2Document"" ) == - 1 ) return - 1 ; if ( file_printf ( ms , "",%sEndian"" , si . si_byte_order == 0xfffe ? ""Little"" : ""Big"" ) == - 1 ) return - 2 ; switch ( si . si_os ) { case 2 : if ( file_printf ( ms , "",Os:Windows,Version%d.%d"" , si . si_os_version & 0xff , ( uint32_t ) si . si_os_version >> 8 ) == - 1 ) return - 2 ; break ; case 1 : if ( file_printf ( ms , "",Os:MacOS,Version%d.%d"" , ( uint32_t ) si . si_os_version >> 8 , si . si_os_version & 0xff ) == - 1 ) return - 2 ; break ; default : if ( file_printf ( ms , "",Os%d,Version:%d.%d"" , si . si_os , si . si_os_version & 0xff , ( uint32_t ) si . si_os_version >> 8 ) == - 1 ) return - 2 ; break ; } info = cdf_file_property_info ( ms , info , count , clsid ) ; free ( info ) ; return m == - 1 ? - 2 : m ; }
",0,440
836,"WORD32 ih264d_parse_sps ( dec_struct_t * ps_dec , dec_bit_stream_t * ps_bitstrm ) { UWORD8 i ; dec_seq_params_t * ps_seq = NULL ; int u1_max_frm_num ; UWORD32 * pu4_bitstrm_buf = ps_bitstrm -> pu4_buffer ; UWORD32 * pu4_bitstrm_ofst = & ps_bitstrm -> u4_ofst ; UWORD8 u1_frm , uc_constraint_set0_flag , uc_constraint_set1_flag ; WORD32 i4_cropped_ht , i4_cropped_wd ; UWORD32 u4_temp ; WORD32 pic_height_in_map_units_minus1 = 0 ; UWORD32 u2_pic_wd = 0 ; UWORD32 u2_pic_ht = 0 ; UWORD32 u2_frm_wd_y = 0 ; UWORD32 u2_frm_ht_y = 0 ; UWORD32 u2_frm_wd_uv = 0 ; UWORD32 u2_crop_offset_y = 0 ; UWORD32 u2_crop_offset_uv = 0 ; WORD32 ret ; UWORD32 u4_num_reorder_frames ; WORD32 i4_i ; UWORD8 u1_frame_cropping_flag , u1_frame_cropping_rect_left_ofst , u1_frame_cropping_rect_right_ofst , u1_frame_cropping_rect_top_ofst , u1_frame_cropping_rect_bottom_ofst ; SWITCHONTRACE ; u1_profile_idc = ih264d_get_bits_h264 ( ps_bitstrm , 8 ) ; COPYTHECONTEXT ( ""SPS:profile_idc"" , u1_profile_idc ) ; uc_constraint_set_left_ofst += u1_frame_cropping_rect_left_ofst ; u1_frame_cropping_rect_right_ofst += u1_frame_cropping_rect_top_
",0,511
837,"static int do_video_set_spu_palette ( unsigned int fd , unsigned int cmd , struct compat_video_spu_palette __user * up ) { struct video_spu_palette __user * up_native ; compat_uptr_t palp ; int length , err ; err = get_user ( palp , & up -> palette ) ; err |= get_user ( length , & up -> length ) ; if ( err ) return - EFAULT ; up_native = compat_alloc_user_space ( sizeof ( struct video_spu_palette ) ) ; err = put_user ( compat_ptr ( palp ) , & up_native -> palette ) ; err |= put_user ( length , & up_native -> length ) ; if ( err ) return - EFAULT ; err = sys_ioctl ( fd , cmd , ( unsigned long ) up_native ) ; return err ; }
",1,203
838,"static vpx_codec_err_t ctrl_set_svc_parameters ( vpx_codec_alg_priv_t * ctx , va_list args ) { VP9_COMP * const cpi = ctx -> cpi ; vpx_svc_parameters_t * const params = va_arg ( args , vpx_svc_parameters_t * ) ; if ( params == NULL ) return VPX_CODEC_INVALID_PARAM ; cpi -> svc . spatial_layer_id = params -> spatial_layer ; cpi -> svc . temporal_layer_id = params -> temporal_layer ; cpi -> lst_fb_idx = params -> lst_fb_idx ; cpi -> gld_fb_idx = params -> gld_fb_idx ; cpi -> alt_fb_idx = params -> alt_fb_idx ; if ( vp9_set_size_literal ( ctx -> cpi , params -> width , params -> height ) != 0 ) return VPX_CODEC_INVALID_PARAM ; ctx -> cfg . rc_max_quantizer = params -> max_quantizer ; ctx -> cfg . rc_min_quantizer = params -> min_quantizer ; set_encoder_config ( & ctx -> oxcf , & ctx -> cfg , & ctx -> extra_cfg ) ; vp9_change_config ( ctx -> cpi , & ctx -> oxcf ) ; return VPX_CODEC_OK ; }
",0,358
839,"static int ip6_frag_queue ( struct frag_queue * fq , struct sk_buff * skb , struct frag_hdr * fhdr , int nhoff ) { struct sk_buff * prev , * next ; struct net_device * dev ; int offset , end ; struct net * net = dev_net ( skb_dst ( skb ) -> dev ) ; if ( fq -> q . last_in & INET_FRAG_COMPLETE ) goto err ; offset = ntohs ( fhdr -> frag_off ) & ~ 0x7 ; end = offset + ( ntohs ( ipv6_hdr ( skb ) -> payload_len ) - ( ( u8 * ) ( fhdr + 1 ) - ( u8 * ) ( ipv6_hdr ( skb ) + 1 ) ) ) ; if ( ( unsigned int ) end > IPV6_MAXPLEN ) { IP6_INC_STATS_BH ( net , ip6_dst_idev ( skb_dst ( skb ) ) , IPSTATS_MIB_INHDRERRORS ) ; icmpv6_param_prob ( skb , ICMPV6_HDR_FIELD , ( ( u8 * ) & fhdr -> frag_off - skb_network_header ( skb ) ) ) ; return - 1 ; } if ( skb -> ip_summed == CHECKSUM_COMPLETE ) { const unsigned char * nh = skb_network_header ( skb ) ; skb -> csum = csum_sub ( skb -> csum , csum_partial ( nh , ( u8 * ) ( fhdr + 1 ) - nh , 0 ) ) ; } if ( ! ( fhdr -> frag_off & htons ( IP6_MF ) ) ) { if ( end < fq -> q . len || ( ( fq -> q . last_in & INET_FRAG_LAST_IN ) && end != fq -> q . len ) ) goto err ; fq -> q . last_in |= INET_FRAG_LAST_IN ; fq -> q . len = end ; } else { if ( end & 0x7 ) { IP6_INC
",0,511
840,"static int tiffcp ( TIFF * in , TIFF * out ) { uint16 bitspersample = 0 , samplesperpixel ; uint16 input_compression , input_photometric ; copyFunc cf ; uint32 width , length ; struct cpTag * p ; CopyField ( TIFFTAG_IMAGEWIDTH , width ) ; CopyField ( TIFFTAG_IMAGELENGTH , length ) ; CopyField ( TIFFTAG_BITSPERSAMPLE , bitspersample ) ; CopyField ( TIFFTAG_SAMPLESPERPIXEL , samplesperpixel ) ; if ( compression != ( uint16 ) - 1 ) TIFFSetField ( out , TIFFTAG_COMPRESSION , compression ) ; else CopyField ( TIFFTAG_COMPRESSION , compression ) ; TIFFGetFieldDefaulted ( in , TIFFTAG_COMPRESSION , & input_compression ) ; TIFFGetFieldDefaulted ( in , TIFFTAG_PHOTOMETRIC , & input_photometric ) ; if ( input_compression == COMPRESSION_JPEG ) { TIFFSetField ( in , TIFFTAG_JPEGCOLORMODE , JPEGCOLORMODE_RGB ) ; } else if ( input_photometric == PHOTOMETRIC_YCBCR ) { uint16 subsamplinghor , subsamplingver ; TIFFGetFieldDefaulted ( in , TIFFTAG_YCBCRSUBSAMPLING , & subsamplinghor , & subsamplingver ) ; if ( subsamplinghor != 1 || subsamplingver != 1 ) { fprintf ( stderr , ""tiffcp:%s:Can\'tcopy/convertsubsampledimage.\\n"" , TIFFFileName ( in ) ) ; return FALSE ; } } if ( compression == COMPRESSION_JPEG ) { if ( input_photometric == PHOTOMETRIC_RGB && jpegcolormode == JPEGCOLORMODE_RGB ) TIFFSetField ( out , TIFFTAG_PHOTOMETRIC , PHOTOMETRIC_YCBCR ) ; else TIFFSetField ( out , TIFFTAG_PHOTOMETRIC , input_photometric ) ; } else if ( compression == COMPRESSION_SGILOG || compression == COMPRESS
",0,511
841,"static int check_symlinks ( struct archive_write_disk * a ) { # if ! defined ( HAVE_LSTAT ) ( void ) a ; return ( ARCHIVE_OK ) ; # else char * pn ; char c ; int r ; struct stat st ; pn = a -> name ; if ( archive_strlen ( & ( a -> path_safe ) ) > 0 ) { char * p = a -> path_safe . s ; while ( ( * pn != '\\0' ) && ( * p == * pn ) ) ++ p , ++ pn ; } if ( pn == a -> name && pn [ 0 ] == '/' ) ++ pn ; c = pn [ 0 ] ; while ( pn [ 0 ] != '\\0' && ( pn [ 0 ] != '/' || pn [ 1 ] != '\\0' ) ) { while ( * pn != '\\0' && * pn != '/' ) ++ pn ; c = pn [ 0 ] ; pn [ 0 ] = '\\0' ; r = lstat ( a -> name , & st ) ; if ( r != 0 ) { if ( errno == ENOENT ) { break ; } else { return ( ARCHIVE_FAILED ) ; } } else if ( S_ISLNK ( st . st_mode ) ) { if ( c == '\\0' ) { if ( unlink ( a -> name ) ) { archive_set_error ( & a -> archive , errno , ""Couldnotremovesymlink%s"" , a -> name ) ; pn [ 0 ] = c ; return ( ARCHIVE_FAILED ) ; } } a -> pst = NULL ; if ( ! S_ISLNK ( a -> mode ) ) { archive_set_error ( & a -> archive , 0 , ""Removingsymlink%s"" , a -> name ) ; } pn [ 0 ] = c ; return ( 0 ) ; } else if ( a -> flags & ARCHIVE_EXTRACT_UNLINK ) { if ( unlink ( a -> name ) != 0 ) { archive_set_error ( & a -> archive , 0 , ""Cannotremoveinterveningsymlink%s"" , a -> name ) ; } pn [ 0 ] =
",0,511
842,"static int fill_autodev ( const struct lxc_rootfs * rootfs ) { int ret ; char path [ MAXPATHLEN ] ; int i ; mode_t cmask ; INFO ( ""Creatinginitialconsolesundercontainer/dev"" ) ; ret = snprintf ( path , MAXPATHLEN , ""%s/dev"" , rootfs -> path ? rootfs -> mount : """" ) ; if ( safe_mount ( hostpath , path , 0 , MS_BIND , NULL , rootfs -> path ? rootfs -> mount : NULL ) != 0 ) { SYSERROR ( ""Failedbindmountingdevice%sfromhostintocontainer"" , d -> name ) ; return - 1 ; } } } umask ( cmask ) ; INFO ( ""Populatedcontainer/dev"" ) ; return 0 ; }
",1,180
843,"static void __udf_read_inode ( struct inode * inode ) { struct buffer_head * bh = NULL ; struct fileEntry * fe ; struct extendedFileEntry * efe ; uint16_t ident ; struct udf_inode_info * iinfo = UDF_I ( inode ) ; struct udf_sb_info * sbi = UDF_SB ( inode -> i_sb ) ; unsigned int link_count ; bh = udf_read_ptagged ( inode -> i_sb , & iinfo -> i_location , 0 , & ident ) ; if ( ! bh ) { udf_err ( inode -> i_sb , ""(ino%ld)failed
",0,158
844,"static void build_masks ( const loop_filter_info_n * const lfi_n , const MODE_INFO * mi , const int shift_y , const int shift_uv , LOOP_FILTER_MASK * lfm ) { const MB_MODE_INFO * mbmi = & mi -> mbmi ; const BLOCK_SIZE block_size = mbmi -> sb_type ; const TX_SIZE tx_size_y = mbmi -> tx_size ; const TX_SIZE tx_size_uv = get_uv_tx_size ( mbmi , block_size ) ; const int filter_level = get_filter_level ( lfi_n , mbmi ) ; uint64_t * const left_y = & lfm -> left_y [ tx_size_y ] ; uint64_t * const above_y = & lfm -> above_y [ tx_size_y ] ; uint64_t * const int_4x4_y = & lfm -> int_4x4_y ; uint16_t * const left_uv = & lfm -> left_uv [ tx_size_uv ] ; uint16_t * const above_uv = & lfm -> above_uv [ tx_size_uv ] ; uint16_t * const int_4x4_uv = & lfm -> int_4x4_uv ; int i ; if ( ! filter_level ) { return ; } else { const int w = num_8x8_blocks_wide_lookup [ block_size ] ; const int h = num_8x8_blocks_high_lookup [ block_size ] ; int index = shift_y ; for ( i = 0 ; i < h ; i ++ ) { memset ( & lfm -> lfl_y [ index ] , filter_level , w ) ; index += 8 ; } } * above_y |= above_prediction_mask [ block_size ] << shift_y ; * above_uv |= above_prediction_mask_uv [ block_size ] << shift_uv ; * left_y |= left_prediction_mask [ block_size ] << shift_y ; * left_uv |= left_prediction_mask_uv [ block_size ] << shift_uv
",0,511
845,"int ff_amf_get_field_value ( const uint8_t * data , const uint8_t * data_end , const uint8_t * name , uint8_t * dst , int dst_size ) { int namelen = strlen ( name ) ; int len ; while ( * data != AMF_DATA_TYPE_OBJECT && data < data_end ) { len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 ) len = data_end - data ; data += len ; } if ( data_end - data < 3 ) return - 1 ; data ++ ; for ( ; ; ) { int size = bytestream_get_be16 ( & data ) ; if ( data >= data_end ) return - 1 ; data += size ; if ( size == namelen && ! memcmp ( data - size , name , dst , dst_size ) ) { switch ( * data ++ ) { case AMF_DATA_TYPE_NUMBER : snprintf ( dst , dst_size , ""%g"" , av_int2double ( AV_RB64 ( data ) ) ) ; break ; case AMF_DATA_TYPE_BOOL : snprintf ( dst , dst_size , ""%s"" , * data ? ""true"" : ""false"" ) ; break ; case AMF_DATA_TYPE_STRING : len = bytestream_get_be16 ( & data ) ; av_strlcpy ( dst , data , FFMIN ( len + 1 , dst_size ) ) ; break ; default : return - 1 ; } return 0 ; } len = ff_amf_tag_size ( data , data_end ) ; if ( len < 0 || len >= data_end - data ) return - 1 ; data += len ; } return - 1 ; }
",0,401
846,"static void t1_check_unusual_charstring ( void ) { char * p = strstr ( t1_line_array , charstringname ) + strlen ( charstringname ) ; int i ; if ( sscanf ( p , ""%i"" , & i ) != 1 ) { strcpy ( t1_buf_array , t1_line_array ) ; t1_getline ( ) ; strcat ( t1_buf_array , t1_line_array ) ; strcpy ( t1_line_array , t1_buf_array ) ; t1_line_ptr = eol ( t1_line_array ) ; } }
",0,150
847,"static void flush_end_io ( struct request * flush_rq , int error ) { struct request_queue * q = flush_rq -> q ; struct list_head * running ; bool queued = false ; struct request * rq , * n ; unsigned long flags = 0 ; struct blk_flush_queue * fq = blk_get_flush_queue ( q , flush_rq -> mq_ctx ) ; if ( q -> mq_ops ) { struct blk_pending_idx * pending_idx = q -> mq_running_idx ; spin_lock_irqsave ( & fq -> mq_flush_lock , flags ) ; flush_rq -> tag = - 1 ; } running = & fq -> flush_queue [ fq -> flush_running_idx ] ; BUG_ON ( fq -> flush_pending_idx == fq -> flush_running_idx ) ; fq -> flush_running_idx ^= 1 ; if ( ! q -> mq_ops ) elv_completed_request ( q , flush_rq ) ; list_for_each_entry_safe ( rq , n , running , flush . list ) { unsigned int seq = blk_flush_cur_seq ( rq ) ; BUG_ON ( seq != REQ_FSEQ_PREFLUSH && seq != REQ_FSEQ_POSTFLUSH ) ; queued |= blk_flush_complete_seq ( rq , fq , seq , error ) ; } if ( queued || fq -> flush_queue_delayed ) { WARN_ON ( q -> mq_ops ) ; blk_run_queue_async ( q ) ; } fq -> flush_queue_delayed = 0 ; if ( q -> mq_ops ) spin_unlock_irqrestore ( & fq -> mq_flush_lock , flags ) ; }
",0,435
848,"uint32_t virtio_config_readb ( VirtIODevice * vdev , uint32_t addr ) { VirtioDeviceClass * k = VIRTIO_DEVICE_GET_CLASS ( vdev ) ; uint8_t val ; if ( addr + sizeof ( val ) ) ) return ( uint32_t ) - 1 ; val = ldub_p ( vdev -> config + addr ) ; return val ; }
",0,97
849,"int regexec ( Reprog * prog , const char * sp , Resub * sub , int eflags ) { Resub scratch ; int i ; if ( ! sub ) sub = & scratch ; sub -> nsub = prog -> nsub ; for ( i = 0 ; i < MAXSUB ; ++ i ) sub -> sub [ i ] . sp = sub -> sub [ i ] . ep = NULL ; return match ( prog -> start , sp , sp , prog -> flags | eflags , sub ) ; }
",0,109
850,"static int swabHorDiff16 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) { uint16 * wp = ( uint16 * ) cp0 ; tmsize_t wc = cc / 2 ; if ( ! horDiff16 ( tif , cp0 , cc ) ) return 0 ; TIFFSwabArrayOfShort ( wp , wc ) ; return 1 ; }
",1,93
851,"static int sessionCookieDirective ( MaState * state , cchar * key , cchar * value ) { char * options , * option , * ovalue , * tok ; if ( ! maTokenize ( state , value , ""%*"" , & options ) ) { return MPR_ERR_BAD_SYNTAX ; } if ( smatch ( options , ""disable"" ) ) { httpSetAuthSession ( state -> route -> auth , 0 ) ; return 0 ; } else if ( smatch ( options , ""enable"" ) ) { httpSetAuthSession ( state -> route -> auth , 1 ) ; return 0 ; } for ( option = maGetNextArg ( options , & tok ) ; option ; option = maGetNextArg ( tok , & tok ) ) { option = sanitize ( option , ""=\\t,"" , & ovalue ) ; ovalue = strim ( ovalue , ""\\""\'"" , MPR_TRIM_BOTH ) ; if ( ! ovalue || * ovalue == '\\0' ) continue ; if ( smatch ( option , ""visible"" ) ) { httpSetRouteSessionVisibility ( state -> route , scaselessmatch ( ovalue , ""visible"" ) ) ; } else if ( smatch ( option , ""name"" ) ) { httpSetRouteCookie ( state -> route , ovalue ) ; } else { mprLog ( ""errorappwebconfig"" , 0 , ""UnknownSessionCookieoption%s"" , option ) ; return MPR_ERR_BAD_SYNTAX ; } } return 0 ; }
",0,351
852,"int inet_sk_rebuild_header ( struct sock * sk ) { struct inet_sock * inet = inet_sk ( sk ) ; struct rtable * rt = ( struct rtable * ) __sk_dst_check ( sk , 0 ) ; __be32 daddr ; struct ip_options_rcu * inet_opt ; int err ; if ( inet_opt && inet_opt -> opt . srr ) daddr = inet_opt -> opt . faddr ; rcu_read_unlock ( ) ; rt = ip_route_output_ports ( sock_net ( sk ) , sk , daddr , inet -> inet_saddr , inet -> inet_dport , inet -> inet_sport , sk -> sk_protocol , RT_CONN_FLAGS ( sk ) , sk -> sk_bound_dev_if ) ; if ( ! IS_ERR ( rt ) ) { err = 0 ; sk_setup_caps ( sk , & rt -> dst ) ; } else { err = PTR_ERR ( rt ) ; sk -> sk_route_caps = 0 ; if ( ! sysctl_ip_dynaddr || sk -> sk_state != TCP_SYN_SENT || ( sk -> sk_userlocks & SOCK_BINDADDR_LOCK ) || ( err = inet_sk_reselect_saddr ( sk ) ) != 0 ) sk -> sk_err_soft = - err ; } return err ; }
",1,341
853,"static void ntlm_populate_message_header ( NTLM_MESSAGE_HEADER * header , UINT32 MessageType ) { CopyMemory ( header -> Signature , NTLM_SIGNATURE , sizeof ( NTLM_SIGNATURE ) ) ; header -> MessageType = MessageType ; }
",1,69
854,"fm_mgr_config_errno_t fm_mgr_config_mgr_connect ( fm_config_conx_hdl * hdl , fm_mgr_type_t mgr ) { char s_path [ 256 ] ; char c_path [ 256 ] ; char * mgr_prefix ; p_hsm_com_client_hdl_t * mgr_hdl ; memset ( s_path , 0 , sizeof ( s_path ) ) ; memset ( c_path , 0 , sizeof ( c_path ) ) ; if ( * mgr_hdl == NULL ) { if ( hcom_client_init ( mgr_hdl , s_path , c_path , 32768 ) != HSM_COM_OK ) { return FM_CONF_INIT_ERR ; } } if ( hcom_client_connect ( * mgr_hdl ) == HSM_COM_OK ) { hdl -> conx_mask |= mgr ; return FM_CONF_OK ; } return FM_CONF_CONX_ERR ; }
",0,249
855,"static int fx_command ( effect_handle_t self , uint32_t cmdCode , uint32_t cmdSize , void * pCmdData , uint32_t * replySize , void * pReplyData ) { struct effect_s * effect = ( struct effect_s * ) self ; if ( effect == NULL ) return - EINVAL ; switch ( cmdCode ) { case EFFECT_CMD_INIT : if ( pReplyData == NULL || * replySize != sizeof ( int ) ) return - EINVAL ; * ( int * ) pReplyData = 0 ; break ; case EFFECT_CMD_SET_CONFIG : { if ( pCmdData == NULL || cmdSize != sizeof ( effect_config_t ) || pReplyData == NULL || * replySize != sizeof ( int ) ) { ALOGV ( ""fx_command()EFFECT_CMD_SET_CONFIGinvalidargs"" ) ; return - EINVAL ; } * ( int * ) pReplyData = session_set_config ( effect -> session , ( effect_config_t * ) pCmdData ) ; if ( * ( int * ) pReplyData != 0 ) break ; if ( effect -> state != EFFECT_STATE_ACTIVE ) * ( int * ) pReplyData = effect_set_state ( effect , EFFECT_STATE_CONFIG ) ; } break ; case EFFECT_CMD_GET_CONFIG : if ( pReplyData == NULL || * replySize != sizeof ( effect_config_t ) ) { ALOGV ( ""fx_command()EFFECT_CMD_GET_CONFIGinvalidargs"" ) ; return - EINVAL ; } session_get_config ( effect -> session , ( effect_config_t * ) pReplyData ) ; break ; case EFFECT_CMD_RESET : break ; case EFFECT_CMD_GET_PARAM : { if ( pCmdData == NULL || cmdSize < ( int ) sizeof ( effect_param_t ) || pReplyData == NULL || replySize < ( int ) sizeof ( effect_param_t ) ) { ALOGV ( ""fx_command()EFFECT_CMD_GET_PARAMinvalidargs"" ) ; return - EINVAL ; } effect_param_t * p = ( effect_param_t * ) p
",0,511
856,"static Image * ReadPSImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define BoundingBox ""BoundingBox:"" # define BeginDocument ""BeginDocument:"" # define BeginXMPPacket ""<?xpacketbegin="" # define EndXMPPacket ""<?xpacketend="" # define ICCProfile ""BeginICCProfile:"" # define CMYKCustomColor ""CMYKCustomColor:"" # define CMYKProcessColor ""CMYKProcessColor:"" # define DocumentMedia ""DocumentMedia:"" # define DocumentCustomColors ""DocumentCustomColors:"" # define DocumentProcessColors ""DocumentProcessColors:"" # define EndDocument ""EndDocument:"" # define HiResBoundingBox ""HiResBoundingBox:"" # define ImageData ""ImageData:"" # define PageBoundingBox ""PageBoundingBox:"" # define LanguageLevel ""LanguageLevel:"" # define PageMedia ""PageMedia:"" # define Pages ""Pages:"" # define PhotoshopProfile ""BeginPhotoshop:"" # define PostscriptLevel ""
",0,217
857,"static int do_ipv6_getsockopt ( struct sock * sk , int level , int optname , char __user * optval , int __user * optlen , unsigned int flags ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; int len ; int val ; if ( ip6_mroute_opt ( optname ) ) return ip6_mroute_getsockopt ( sk , optname , optval , optlen ) ; if ( get_user ( len , optlen ) ) return - EFAULT ; switch ( optname ) { case IPV6_ADDRFORM : if ( sk -> sk_protocol != IPPROTO_UDP && sk -> sk_protocol != IPPROTO_UDPLITE && sk -> sk_protocol != IPPROTO_TCP ) return - ENOPROTOOPT ; if ( sk -> sk_state != TCP_ESTABLISHED ) return - ENOTCONN ; val = sk -> sk_family ; break ; case MCAST_MSFILTER : { struct group_filter gsf ; int err ; if ( len < GROUP_FILTER_SIZE ( 0 ) ) return - EINVAL ; if ( copy_from_user ( & gsf , optval , GROUP_FILTER_SIZE ( 0 ) ) ) return - EFAULT ; if ( gsf . gf_group . ss_family != AF_INET6 ) return - EADDRNOTAVAIL ; lock_sock ( sk ) ; err = ip6_mc_msfget ( sk , & gsf , ( struct group_filter __user * ) optval , optlen ) ; release_sock ( sk ) ; return err ; } case IPV6_2292PKTOPTIONS : { struct msghdr msg ; struct sk_buff * skb ; if ( sk -> sk_type != SOCK_STREAM ) return - ENOPROTOOPT ; msg . msg_control = optval ; msg . msg_controllen = len ; msg . msg_flags = flags ; lock_sock ( sk ) ; skb = np -> pktoptions ; if ( skb ) ip6_datagram_recv_ctl ( sk , & msg , skb ) ; release_sock ( sk ) ; if ( ! skb
",0,511
858,"static struct berval * * krb5_encode_krbsecretkey ( krb5_key_data * key_data_in , int n_key_data , krb5_kvno mkvno ) { struct berval * * ret = NULL ; int currkvno ; int num_versions = 1 ; int i , j , last ; krb5_error_code err = 0 ; krb5_key_data * key_data ; if ( n_key_data <= 0 ) return NULL ; key_data = k5calloc ( n_key_data , sizeof ( * key_data ) , & err ) ; if ( key_data_in == NULL ) goto cleanup ; memcpy ( key_data , key_data_in , n_key_data * sizeof ( * key_data ) ) ; for ( i = 0 ; i < n_key_data ; i ++ ) { if ( key_data [ i ] . key_data_ver == 1 ) { key_data [ i ] . key_data_ver = 2 ; key_data [ i ] . key_data_type [ 1 ] = KRB5_KDB_SALTTYPE_NORMAL ; key_data [ i ] . key_data_length [ 1 ] = 0 ; key_data [ i ] . key_data_contents [ 1 ] = NULL ; } } for ( i = 0 ; i < n_key_data - 1 ; i ++ ) if ( key_data [ i ] . key_data_kvno != key_data [ i + 1 ] . key_data_kvno ) num_versions ++ ; ret = ( struct berval * * ) calloc ( num_versions + 1 , sizeof ( struct berval * ) ) ; if ( ret == NULL ) { err = ENOMEM ; goto cleanup ; } for ( i = 0 , last = 0 , j = 0 , currkvno = key_data [ 0 ] . key_data_kvno ; i < n_key_data ; i ++ ) { krb5_data * code ; if ( i == n_key_data - 1 || key_data [ i + 1 ] . key_data_kvno != currkvno ) { ret [ j ] = k5
",0,511
859,"static void ctrycatchfinally ( JF , js_Ast * trystm , js_Ast * catchvar , js_Ast * catchstm , js_Ast * finallystm ) { int L1 , L2 , L3 ; L1 = emitjump ( J , F , OP_TRY ) ; { L2 = emitjump ( J , F , OP_TRY ) ; { cstm ( J , F , finallystm ) ; emit ( J , F , OP_THROW ) ; } label ( J , F , L2 ) ; if ( F -> strict ) { checkfutureword ( J , F , catchvar ) ; if ( ! strcmp ( catchvar -> string , ""arguments"" ) ) jsC_error ( J , catchvar , ""redefining\'arguments\'isnotallowedinstrictmode"" ) ; if ( ! strcmp ( catchvar -> string , ""eval"" ) ) jsC_error ( J , catchvar , ""redefining\'eval\'isnotallowedinstrictmode"" ) ; } emitline ( J , F , catchvar ) ; emitstring ( J , F , OP_CATCH , catchvar -> string ) ; cstm ( J , F , catchstm ) ; emit ( J , F , OP_ENDCATCH ) ; emit ( J , F , OP_ENDTRY ) ; L3 = emitjump ( J , F , OP_JUMP ) ; } label ( J , F , L1 ) ; cstm ( J , F , trystm ) ; emit ( J , F , OP_ENDTRY ) ; label ( J , F , L3 ) ; cstm ( J , F , finallystm ) ; }
",1,372
860,"LIBXSMM_API_INTERN void libxsmm_sparse_csc_reader ( libxsmm_generated_code * io_generated_code , const char * i_csc_file_in , unsigned int * * o_row_idx , unsigned int * * o_column_idx , double * * o_values , unsigned int * o_row_count , unsigned int * o_column_count , unsigned int * o_element_count ) { FILE * l_csc_file_handle ; const unsigned int l_line_length = 512 ; char l_line [ 512 + 1 ] ; unsigned int l_header_read = 0 ; unsigned int * l_column_idx_id = NULL ; unsigned int l_i = 0 ; l_csc_file_handle = fopen ( i_csc_file_in , ""r"" ) ; if ( l_csc_file_handle == NULL ) { LIBXSMM_HANDLE_ERROR ( io_generated_code , LIBXSMM_ERR_CSC_INPUT ) ; return ; } while ( fgets ( l_line , l_line_length , l_csc_file_handle ) != NULL ) { if ( 3 == strlen ( l_line ) == l_line_length ) { free ( * o_row_idx ) ; free ( * o_column_idx ) ; free ( * o_values ) ; free ( l_column_idx_id ) ; * o_row_idx = 0 ; * o_column_idx = 0 ; * o_values = 0 ; fclose ( l_csc_file_handle ) ; LIBXSMM_HANDLE_ERROR ( io_generated_code , LIBXSMM_ERR_CSC_READ_LEN ) ; return ; } if ( l_line [ 0 ] == '%' ) { continue ; } else { if ( l_header_read == 0 ) { if ( sscanf ( l_line , ""%u%u%u"" , o_row_count , o_column_count , o_element_count ) && 0 != * o_row_count && 0 != * o_column_count && 0 != * o_element_count ) { * o_row_
",0,511
861,"static int tcos_decipher ( sc_card_t * card , const u8 * crgram , size_t crgram_len , u8 * out , size_t outlen ) { sc_context_t * ctx ; sc_apdu_t apdu ; u8 rbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; u8 sbuf [ SC_MAX_APDU_BUFFER_SIZE ] ; tcos_data * data ; int tcos3 , r ; assert ( card != NULL && crgram != NULL && out != NULL ) ; ctx = card -> ctx ; tcos3 = ( card -> type == SC_CARD_TYPE_TCOS_V3 ) ; data = ( tcos_data * ) card -> drv_data ; LOG_FUNC_CALLED ( ctx ) ; sc_log ( ctx , ""TCOS3:%dPKCS1:%d\\n"" , tcos3 , ! ! ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ) ; sc_format_apdu ( card , & apdu , crgram_len > 255 ? SC_APDU_CASE_4_EXT : SC_APDU_CASE_4_SHORT , 0x2A , 0x80 , 0x86 ) ; apdu . resp = rbuf ; apdu . resplen = sizeof ( rbuf ) ; apdu . le = crgram_len ; apdu . data = sbuf ; apdu . lc = apdu . datalen = crgram_len + 1 ; sbuf [ 0 ] = tcos3 ? 0x00 : ( ( data -> pad_flags & SC_ALGORITHM_RSA_PAD_PKCS1 ) ? 0x81 : 0x02 ) ; if ( ( apdu . sw1 == 0x90 && apdu . sw2 == 0x00 ) ) { size_t len = ( apdu . resplen > outlen ) ? ( apdu . len > outlen ) ? ( apdu . len > outlen ) ? ( apdu . len > outlen ) ? ( apdu . len > outlen ) ? ( apdu . len > outlen ) ? ( apdu . len >
",0,511
862,"static RD_BOOL mcs_recv_connect_response ( STREAM mcs_data ) { UNUSED ( mcs_data ) ; uint8 result ; uint32 length ; STREAM s ; struct stream packet ; RD_BOOL is_fastpath ; uint8 fastpath_hdr ; logger ( Protocol , Debug , ""%s()"" , __func__ ) ; s = iso_recv ( & is_fastpath , & fastpath_hdr ) ; if ( s == NULL ) return False ; packet = * s ; ber_parse_header ( s , MCS_CONNECT_RESPONSE , & length ) ; if ( ! s_check_rem ( s , length ) ) { rdp_protocol_error ( ""mcs_recv_connect_response(),consumeconnectidfromstreamwouldoverrun"" , & packet ) ; } ber_parse_header ( s , BER_TAG_RESULT , & length ) ; in_uint8 ( s , result ) ; if ( result != 0 ) { logger ( Protocol , Error , ""mcs_recv_connect_response(),result=%d"" , result ) ; return False ; } ber_parse_header ( s , BER_TAG_INTEGER , & length ) ; in_uint8s ( s , length ) ; mcs_parse_domain_params ( s ) ; ber_parse_header ( s , BER_TAG_OCTET_STRING , & length ) ; sec_process_mcs_data ( s ) ; return s_check_end ( s ) ; }
",1,351
863,"krb5_error_code process_tgs_req ( struct server_handle * handle , krb5_data * pkt , const krb5_fulladdr * from , krb5_data * * response ) { krb5_keyblock * subkey = 0 ; krb5_keyblock * header_key = NULL ; krb5_kdc_req * request = 0 ; krb5_db_entry * server = NULL ; krb5_db_entry * stkt_server = NULL ; krb5_kdc_rep reply ; krb5_enc_kdc_rep_part reply_encpart ; krb5_ticket ticket_reply , * header_ticket = 0 ; int st_idx = 0 ; krb5_enc_tkt_part enc_tkt_reply ; int newtransited = 0 ; krb5_error_code retval = 0 ; krb5_keyblock encrypting_key ; krb5_timestamp kdc_time , authtime = 0 ; krb5_keyblock session_key ; krb5_keyblock * reply_key = NULL ; krb5_key_data * server_key ; krb5_principal cprinc = NULL , sprinc = NULL , altcprinc = NULL ; krb5_last_req_entry * nolrarray [ 2 ] , nolrentry ; int errcode ; const char * status = 0 ; krb5_enc_tkt_part * header_enc_tkt = NULL ; krb5_enc_tkt_part * subject_tkt = NULL ; krb5_db_entry * client = NULL , * header_server = NULL ; krb5_db_entry * local_tgt , * local_tgt_storage = NULL ; krb5_pa_s4u_x509_user * s4u_x509_user = NULL ; krb5_authdata * * kdc_issued_auth_data = NULL ; unsigned int c_flags = 0 , s_flags = 0 ; krb5_boolean is_referral ; const char * emsg = NULL ; krb5_kvno ticket_kvno = 0 ; struct kdc_request_state * state = NULL ;
",0,511
864,"static const xmlChar * xmlParseNameComplex ( xmlParserCtxtPtr ctxt ) { int len = 0 , l ; int c ; int count = 0 ; # ifdef DEBUG nbParseNameComplex ++ ; # endif GROW ; if ( ctxt -> instate == XML_PARSER_EOF ) return ( NULL ) ; c = CUR_CHAR ( l ) ; if ( ( ctxt -> options & XML_PARSE_OLD10 ) == 0 ) { if ( ( c == '' ) || ( c == '>' ) || ( c == '/' ) || ( ! ( ( c >= 'a' ) && ( c <= 'z' ) ) || ( ( c >= 'A' ) && ( c <= 'Z' ) ) || ( c == '_' ) || ( c == ':' ) || ( ( c >= 0xC0 ) && ( c <= 0xD6 ) ) || ( ( c >= 0xD8 ) && ( c <= 0xF6 ) ) || ( ( c >= 0xF8 ) && ( c <= 0x2FF ) ) || ( ( c >= 0x370 ) && ( c <= 0x37D ) ) || ( ( c >= 0x37F ) && ( c <= 0x1FFF ) ) || ( ( c >= 0x200C ) && ( c <= 0x200D ) ) || ( ( c >= 0x2070 ) && ( c <= 0x218F ) ) || ( ( c >= 0x2C00 ) && ( c <= 0x2FEF ) ) || ( ( c >= 0x3001 ) && ( c <= 0xD7FF ) ) || ( ( c >= 0xF900 ) && ( c <= 0xFDCF ) ) || ( ( c >= 0xFDF0 ) && ( c <= 0xFFFD ) ) || ( ( c >= 0x10000 ) && ( c <= 0xEFFFF ) ) ) ) ) { return ( NULL ) ; } len += l ; NEXTL ( l ) ; c = CUR_CHAR ( l ) ; while ( ( c != '' ) && ( c != '>' ) && ( c != '/' ) && ( ( ( c >= 'a' ) && ( c <= 'z' ) ) || ( ( c >= 'A' ) && ( c <= 'Z
",0,511
865,"static int i40e_setup_macvlans ( struct i40e_vsi * vsi , u16 macvlan_cnt , u16 qcnt , struct net_device * vdev ) { struct i40e_pf * pf = vsi -> back ; struct i40e_hw * hw = & pf -> hw ; struct i40e_vsi_context ctxt ; u16 sections , qmap , num_qps ; struct i40e_channel * ch ; int i , pow , ret = 0 ; u8 offset = 0 ; if ( vsi -> type != I40E_VSI_MAIN || ! macvlan_cnt ) return - EINVAL ; num_qps = vsi -> num_queue_pairs - ( macvlan_cnt * qcnt ) ; pow = fls ( roundup_pow_of_two ( num_qps ) - 1 ) ; qmap = ( offset << I40E_AQ_VSI_TC_QUE_OFFSET_SHIFT ) | ( pow << I40E_AQ_VSI_TC_QUE_NUMBER_SHIFT ) ; sections = I40E_AQ_VSI_PROP_QUEUE_MAP_VALID ; sections |= I40E_AQ_VSI_PROP_SCHED_VALID ; memset ( & ctxt , 0 , sizeof ( ctxt ) ) ; ctxt . seid = vsi -> seid ; ctxt . pf_num = vsi -> back -> hw . pf_id ; ctxt . vf_num = 0 ; ctxt . uplink_seid = vsi -> uplink_seid ; ctxt . info = vsi -> info ; ctxt . info . tc_mapping [ 0 ] = cpu_to_le16 ( qmap ) ; ctxt . info . mapping_flags |= cpu_to_le16 ( I40E_AQ_VSI_QUE_MAP_CONTIG ) ; ctxt . info . queue_mapping [ 0 ] = cpu_to_le16 ( vsi -> base_queue ) ; ctxt . info . valid_sections |= cpu_to_le16 ( sections ) ; vsi -> rss
",0,511
866,"static __u8 * ch_report_fixup ( struct hid_device * hdev , __u8 * rdesc , unsigned int * rsize ) { if ( * rsize >= 18 && rdesc [ 11 ] == 0x3c && rdesc [ 12 ] == 0x02 ) { hid_info ( hdev , ""fixingupCherryCymotionreportdescriptor\\n"" ) ; rdesc [ 11 ] = rdesc [ 16 ] = 0xff ; rdesc [ 12 ] = rdesc [ 17 ] = 0x03 ; } return rdesc ; }
",1,127
867,"static ssize_t map_write ( struct file * file , const char __user * buf , size_t count , loff_t * ppos , int cap_setid , struct uid_gid_map * map , struct uid_gid_map * parent_map ) { struct seq_file * seq = file -> private_data ; struct user_namespace * ns = seq -> private ; struct uid_gid_map new_map ; unsigned idx ; struct uid_gid_extent extent ; char * kbuf = NULL , * pos , * next_line ; ssize_t ret ; if ( ( * ppos != 0 ) || ( count >= PAGE_SIZE ) ) return - EINVAL ; kbuf = memdup_user_nul ( buf , count ) ; if ( IS_ERR ( kbuf ) ) return PTR_ERR ( kbuf ) ; mutex_lock ( & userns_state_mutex ) ; memset ( & new_map , 0 , sizeof ( struct uid_gid_map ) ) ; ret = - EPERM ; if ( map -> nr_extents != 0 ) goto out ; if ( cap_valid ( cap_setid ) && ! file_ns_capable ( file , ns , CAP_SYS_ADMIN ) ) goto out ; ret = - EINVAL ; pos = kbuf ; for ( ; pos ; pos = next_line ) { next_line = strchr ( pos , '\\n' ) ; if ( next_line ) { * next_line = '\\0' ; next_line ++ ; if ( * next_line == '\\0' ) next_line = NULL ; } pos = skip_spaces ( pos ) ; extent . first = simple_strtoul ( pos , & pos , 10 ) ; if ( ! isspace ( * pos ) ) goto out ; pos = skip_spaces ( pos ) ; extent . lower_first = simple_strtoul ( pos , & pos , 10 ) ; if ( ! isspace ( * pos ) ) goto out ; pos = skip_spaces ( pos ) ; extent . count = simple_strtoul ( pos , & pos , 10 ) ; if ( * pos && ! isspace ( * pos ) ) goto out ; pos = skip
",0,511
868,"static int _server_handle_vCont ( libgdbr_t * g , int ( * cmd_cb ) ( void * , const char * , char * , size_t ) , void * core_ptr ) { char * action = NULL ; if ( send_ack ( g ) < 0 ) { return - 1 ; } g -> data [ g -> data_len ] = '\\0' ; if ( g -> data [ 5 ] == '?' ) { return send_msg ( g , ""vCont;c;s"" ) ; } if ( ! ( action = strtok ( g -> data , "";"" ) ) ) { return send_msg ( g , ""E01"" ) ; } while ( action = strtok ( NULL , "";"" ) ) { eprintf ( ""action:%s\\n"" , action ) ; switch ( action [ 0 ] ) { case 's' : if ( cmd_cb ( core_ptr , ""ds"" , NULL , 0 ) < 0 ) { send_msg ( g , ""E01"" ) ; return - 1 ; } return send_msg ( g , ""OK"" ) ; case 'c' : if ( cmd_cb ( core_ptr , ""dc"" , NULL , 0 ) < 0 ) { send_msg ( g , ""E01"" ) ; return - 1 ; } return send_msg ( g , ""OK"" ) ; default : return send_msg ( g , ""E01"" ) ; } } }
",0,321
869,"smb_sdrc_t smb2_flush ( smb_request_t * sr ) { uint16_t StructSize ; uint16_t reserved1 ; uint32_t reserved2 ; smb2fid_t smb2fid ; uint32_t status ; int rc = 0 ; rc = smb_mbc_decodef ( & sr -> smb_data , ""wwlqq"" , & StructSize , & reserved1 , & reserved2 , & smb2fid . persistent , & smb2fid . temporal ) ; if ( rc ) return ( SDRC_ERROR ) ; if ( StructSize != 24 ) return ( SDRC_ERROR ) ; status = smb2sr_lookup_fid ( sr , & smb2fid ) ; if ( status ) { smb2sr_put_error ( sr , status ) ; return ( SDRC_SUCCESS ) ; } smb_ofile_flush ( sr , sr -> fid_ofile , sr -> f_cr , of -> f_node ) ; ( void ) smb_mbc_encodef ( & sr -> reply , ""wwl"" , 4 , 0 ) ; return ( SDRC_SUCCESS ) ; }
",0,275
870,"jpc_streamlist_t * jpc_ppmstabtostreams ( jpc_ppxstab_t * tab ) { jpc_streamlist_t * streams ; jpc_ppxstabent_t * ent ; int entno ; jas_stream_t * stream ; int n ; if ( ! ( streams = jpc_streamlist_create ( ) ) ) { goto error ; } if ( ! tab -> numents ) { return streams ; } entno = 0 ; ent = tab -> ents [ entno ] ; dataptr = ent -> data ; datacnt = ent -> len ; for ( ; ; ) { if ( datacnt < 4 ) { goto error ; } if ( ! ( stream = jas_stream_memopen ( 0 , 0 ) ) ) { goto error ; } if ( jpc_streamlist_insert ( streams , jpc_streamlist_numstreams ( streams ) , stream ) ) { goto error ; } tpcnt = ( dataptr [ 0 ] << 24 ) | ( dataptr [ 1 ] << 16 ) | ( dataptr [ 2 ] << 8 ) | dataptr [ 3 ] ; datacnt -= 4 ; dataptr += 4 ; while ( tpcnt ) { if ( ! datacnt ) { if ( ++ entno >= tab -> numents ) { goto error ; } ent = tab -> ents [ entno ] ; dataptr = ent -> data ; datacnt = ent -> len ; } n = JAS_MIN ( tpcnt , datacnt ) ; if ( jas_stream_write ( stream , dataptr , n ) != n ) { goto error ; } tpcnt -= n ; dataptr += n ; datacnt -= n ; } jas_stream_rewind ( stream ) ; if ( ! datacnt ) { if ( ++ entno >= tab -> numents ) { break ; } ent = tab -> ents [ entno ] ; dataptr = ent -> data ; datacnt = ent -> len ; } } return streams ; error : if ( streams ) { jpc_streamlist_destroy ( streams ) ; } return 0 ; }
",0,468
871,"static void decode_mb_rows ( VP8D_COMP * pbi ) { VP8_COMMON * const pc = & pbi -> common ; MACROBLOCKD * const xd = & pbi -> mb ; MODE_INFO * lf_mic = xd -> mode_info_context ; int ibc = 0 ; int num_part = 1 << pc -> multi_token_partition ; int recon_yoffset , recon_uvoffset ; int mb_row , mb_col ; int mb_idx = 0 ; YV12_BUFFER_CONFIG * yv12_fb_new = pbi -> dec_fb_ref [ INTRA_FRAME ] ; int recon_y_stride = yv12_fb_new -> y_stride ; int recon_uv_stride = yv12_fb_new -> uv_stride ; unsigned char * ref_buffer [ MAX_REF_FRAMES ] [ 3 ] ; unsigned char * dst_buffer [ 3 ] ; unsigned char * lf_dst [ 3 ] ; unsigned char * eb_dst [ 3 ] ; int i ; int ref_fb_corrupted [ MAX_REF_FRAMES ] ; ref_fb_corrupted [ INTRA_FRAME ] = 0 ; for ( i = 1 ; i < MAX_REF_FRAMES ; i ++ ) { YV12_BUFFER_CONFIG * this_fb = pbi -> dec_fb_ref [ i ] ; ref_buffer [ i ] [ 0 ] = this_fb -> y_buffer ; ref_buffer [ i ] [ 1 ] = this_fb -> u_buffer ; ref_buffer [ i ] [ 2 ] = this_fb -> v_buffer ; ref_fb_corrupted [ i ] = this_fb -> corrupted ; } eb_dst [ 0 ] = lf_dst [ 0 ] = dst_buffer [ 0 ] = yv12_fb_new -> y_buffer ; eb_dst [ 1 ] = lf_dst [ 1 ] = dst_buffer [ 1 ] = dst_buffer [ 1 ] = yv12_fb_new -> u_buffer ; eb_dst [ 2 ] = lf_dst [ 2 ] = dst_buffer [ 2 ] = yv12_fb
",0,511
872,"static void set_orig_addr ( struct msghdr * m , struct tipc_msg * msg ) { struct sockaddr_tipc * addr = ( struct sockaddr_tipc * ) m -> msg_name ; if ( addr ) { addr -> family = AF_TIPC ; addr -> addrtype = TIPC_ADDR_ID ; memset ( & addr -> addr , 0 , sizeof ( addr -> addr ) ) ; addr -> addr . id . ref = msg_origport ( msg ) ; addr -> addr . id . node = msg_orignode ( msg ) ; addr -> addr . name . domain = 0 ; addr -> scope = 0 ; m -> msg_namelen = sizeof ( struct sockaddr_tipc ) ; } }
",1,165
873,"int __kvm_set_memory_region ( struct kvm * kvm , struct kvm_userspace_memory_region * mem , int user_alloc ) { int r ; gfn_t base_gfn ; unsigned long npages ; unsigned long i ; struct kvm_memory_slot * memslot ; struct kvm_memory_slot old , new ; struct kvm_memslots * slots , * old_memslots ; r = - EINVAL ; if ( mem -> memory_size & ( PAGE_SIZE - 1 ) ) goto out ; if ( mem -> guest_phys_addr & ( PAGE_SIZE - 1 ) ) goto out ; if ( user_alloc && ( ( mem -> userspace_addr & ( PAGE_SIZE - 1 ) ) && ! access_ok ( VERIFY_WRITE , mem -> userspace_addr , mem -> memory_size ) ) ) goto out ; if ( mem -> slot >= KVM_MEMORY_SLOTS + KVM_PRIVATE_MEM_SLOTS ) goto out ; if ( mem -> guest_phys_addr + mem -> memory_size < mem -> guest_phys_addr ) goto out ; memslot = & kvm -> memslots -> memslots [ mem -> slot ] ; base_gfn = mem -> guest_phys_addr >> PAGE_SHIFT ; npages = mem -> memory_size >> PAGE_SHIFT ; r = - EINVAL ; if ( npages > KVM_MEM_MAX_NR_PAGES ) goto out ; if ( ! npages ) mem -> flags &= ~ KVM_MEM_LOG_DIRTY_PAGES ; new = old = * memslot ; new . id = mem -> slot ; new . base_gfn = base_gfn ; new . npages = npages ; new . flags = mem -> flags ; r = - EINVAL ; if ( npages && old . npages && npages != old . npages ) goto out_free ; r = - EEXIST ; for ( i = 0 ; i < KVM_MEMORY_SLOTS ; ++ i ) { struct kvm_memory_slot * s = & kvm -> memslots -> memslots [ i ] ; if ( s == memslot || ! s -> npages ) continue ; if (
",0,511
874,"static Image * ReadMATImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image , * image2 = NULL , * rotated_image ; register Quantum * q ; unsigned int status ; MATHeader MATLAB_HDR ; size_t size ; size_t CellType ; QuantumInfo * quantum_info ; ImageInfo * clone_info ; int i ; ssize_t ldblk ; unsigned char * BImgBuff = NULL ; double MinVal , MaxVal ; unsigned z , z2 ; unsigned Frames ; int logging ; int sample_size ; MagickOffsetType filepos = 0x80 ; BlobInfo * blob ; size_t one ; unsigned int ( * ReadBlobXXXLong ) ( Image * image ) ; unsigned short ( * ReadBlobXXXShort ) ( Image * image ) ; void ( * ReadBlobDoublesXXX ) ( Image * image , size_t len , double * data ) ; void ( * ReadBlobFloatsXXX ) ( Image * image , size_t len , float * data ) ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; logging = LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""enter"" ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } memset ( image , 0 , sizeof ( image ) ) ; clone_info = CloneImageInfo ( image_info ) ; if ( ReadBlob ( image , 124 , ( unsigned char * ) & MATLAB_HDR . identific ) != 124 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( strncmp ( MATLAB_HDR . identific , ""MATLAB"" , 6 ) != 0 ) { image2 = ReadMATImageV4 ( image_info , image , exception ) ; if ( image2 == NULL ) goto MATLAB_KO ; image = image2 ; goto END_OF_READ
",0,511
875,"php_stream * php_stream_url_wrap_http_ex ( php_stream_wrapper * wrapper , const char * path , const char * mode , int options , char * * opened_path , php_stream_context * context , int redirect_max , int flags STREAMS_DC TSRMLS_DC ) { php_stream * stream = NULL ; php_url * resource = NULL ; int use_ssl ; int use_proxy = 0 ; char * scratch = NULL ; char * tmp = NULL ; char * ua_str = NULL ; zval * * ua_zval = NULL , * * tmpzval = NULL , * ssl_proxy_peer_name = NULL ; int scratch_len = 0 ; int body = 0 ; char location [ HTTP_HEADER_BLOCK_SIZE ] ; zval * response_header = NULL ; int reqok = 0 ; char * http_header_line = NULL ; char tmp_line [ 128 ] ; size_t chunk_size = 0 , file_size = 0 ; int eol_detect = 0 ; char * transport_string , * errstr = NULL ; int transport_len , have_header = 0 , request_fulluri = 0 , ignore_errors = 0 ; char * protocol_version = NULL ; int protocol_version_len = 3 ; struct timeval timeout ; char * user_headers = NULL ; int header_init = ( ( flags & HTTP_WRAPPER_HEADER_INIT ) != 0 ) ; int redirected = ( ( flags & HTTP_WRAPPER_REDIRECTED ) != 0 ) ; int follow_location = 1 ; php_stream_filter * transfer_encoding = NULL ; int response_code ; tmp_line [ 0 ] = '\\0' ; if ( redirect_max < 1 ) { php_stream_wrapper_log_error ( wrapper , options TSRMLS_CC , ""Redirectionlimitreached,aborting"" ) ; return NULL ; } resource = php_url_parse ( path ) ; if ( resource == NULL ) { return NULL ; } if ( strncasecmp ( resource -> scheme , ""http"" , sizeof ( ""http"" ) ) && strncasecmp ( resource -> scheme , ""https"" , sizeof ( ""https"" ) ) ) { if ( ! context || php_stream_context_get
",0,511
876,"static PyObject * decode_unicode_with_escapes ( struct compiling * c , const node * n , const char * s , size_t len ) { PyObject * u ; char * buf ; char * p ; const char * end ; if ( len > SIZE_MAX / 6 ) return NULL ; u = PyBytes_FromStringAndSize ( ( char * ) NULL , len * 6 ) ; if ( u == NULL ) return NULL ; p = buf = PyBytes_AsString ( u ) ; end = s + len ; while ( s < end ) { if ( * s == '\\\\' ) { * p ++ = * s ++ ; if ( * s & 0x80 ) { strcpy ( p , ""u005c"" ) ; p += 5 ; } } if ( * s & 0x80 ) { PyObject * w ; int kind ; void * data ; Py_ssize_t len , i ; w = decode_utf8 ( c , & s , end ) ; if ( w == NULL ) { Py_DECREF ( u ) ; return NULL ; } kind = PyUnicode_KIND ( w ) ; data = PyUnicode_DATA ( w ) ; len = PyUnicode_GET_LENGTH ( w ) ; for ( i = 0 ; i < len ; i ++ ) { Py_UCS4 chr = PyUnicode_READ ( kind , data , i ) ; sprintf ( p , ""\\\\U%08x"" , chr ) ; p += 10 ; } if ( len < Py_SIZE ( u ) ) return NULL ; Py_DECREF ( w ) ; } else { * p ++ = * s ++ ; } } len = p - buf ; s = buf ; return PyUnicode_DecodeUnicodeEscape ( s , len , NULL ) ; }
",0,402
877,"int libevt_record_values_read_event ( libevt_record_values_t * record_values , uint8_t * record_data , size_t record_data_size , uint8_t strict_mode , libcerror_error_t * * error ) { static char * function = ""libevt_record_values_read_event"" ; size_t record_data_offset = 0 ; size_t strings_data_offset = 0 ; ssize_t value_data_size = 0 ; uint32_t data_offset = 0 ; uint32_t data_size = 0 ; uint32_t members_data_size = 0 ; uint32_t size = 0 ; uint32_t size_copy = 0 ; uint32_t strings_offset = 0 ; uint32_t strings_size = 0 ; uint32_t user_sid_offset = 0 ; uint32_t user_sid_size = 0 ; # if defined ( HAVE_DEBUG_OUTPUT ) uint32_t value_32bit = 0 ; uint16_t value_16bit = 0 ; # endif if ( record_values == NULL ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_ARGUMENTS , LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE , ""%s:invalidrecordvalues."" , function ) ; return ( - 1 ) ; } if ( record_data == NULL ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_ARGUMENTS , LIBCERROR_ARGUMENT_ERROR_INVALID_VALUE , ""%s:invalidrecorddata."" , function ) ; return ( - 1 ) ; } if ( record_data_size > ( size_t ) SSIZE_MAX ) { libcerror_error_set ( error , LIBCERROR_ERROR_DOMAIN_ARGUMENTS , LIBCERROR_ARGUMENT_ERROR_VALUE_EXCEEDS_MAXIMUM , ""%s:invalidrecorddatasizevalueexceedsmaximum."" , function ) ; return ( - 1 ) ; } if ( record_data_size < ( sizeof ( evt_record_event_header_t ) + 4 ) ) { libcerror_error
",0,511
878,"int ParseWave64HeaderConfig ( FILE * infile , char * infilename , char * fourcc , WavpackContext * wpc , WavpackConfig * config ) { int64_t total_samples = 0 , infilesize ; Wave64ChunkHeader chunk_header ; Wave64FileHeader filehdr ; WaveHeader WaveHeader ; int format_chunk = 0 ; uint32_t bcount ; CLEAR ( WaveHeader ) ; infilesize = DoGetFileSize ( infile ) ; memcpy ( & filehdr , fourcc , 4 ) ; if ( ! DoReadFile ( infile , ( ( char * ) & filehdr ) + 4 , sizeof ( Wave64FileHeader ) - 4 , & bcount ) || bcount != sizeof ( Wave64FileHeader ) - 4 || memcmp ( filehdr . ckID , riff_guid , sizeof ( riff_guid ) ) || memcmp ( filehdr . formType , wave_guid , sizeof ( wave_guid ) ) ) { error_line ( ""%sisnotavalid.W64file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & filehdr , sizeof ( filehdr ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } # if 1 WavpackLittleEndianToNative ( & filehdr , Wave64ChunkHeaderFormat ) ; if ( infilesize && ! ( config -> qmode & QMODE_IGNORE_LENGTH ) && filehdr . ckSize && filehdr . ckSize + 1 && filehdr . ckSize != infilesize ) { error_line ( ""%sisnotavalid.W64file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } # endif while ( 1 ) { if ( ! DoReadFile ( infile , & chunk_header , sizeof ( Wave64ChunkHeader ) , & bcount ) || bcount != sizeof ( Wave64ChunkHeader ) ) { error_line ( ""%sisnotavalid.W64file
",0,511
879,"int ParseDsdiffHeaderConfig ( FILE * infile , char * infilename , char * fourcc , WavpackContext * wpc , WavpackConfig * config ) { int64_t infilesize , total_samples ; DFFFileHeader dff_file_header ; DFFChunkHeader dff_chunk_header ; uint32_t bcount ; infilesize = DoGetFileSize ( infile ) ; memcpy ( & dff_file_header , fourcc , 4 ) ; if ( ( ! DoReadFile ( infile , ( ( char * ) & dff_file_header ) + 4 , sizeof ( DFFFileHeader ) - 4 , & bcount ) || bcount != sizeof ( DFFFileHeader ) - 4 ) || strncmp ( dff_file_header . formType , ""DSD"" , 4 ) ) { error_line ( ""%sisnotavalid.DFFfile!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & dff_file_header , sizeof ( DFFFileHeader ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } # if 1 WavpackBigEndianToNative ( & dff_file_header , DFFFileHeaderFormat ) ; if ( infilesize && ! ( config -> qmode & QMODE_IGNORE_LENGTH ) && dff_file_header . ckDataSize && dff_file_header . ckDataSize + 1 && dff_file_header . ckDataSize + 12 != infilesize ) { error_line ( ""%sisnotavalid.DFFfile(bytotalsize)!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } if ( debug_logging_mode ) error_line ( ""fileheaderindicatedlength=%lld"" , dff_file_header . ckDataSize ) ; # endif while ( 1 ) { if ( ! DoReadFile ( infile , & dff_chunk_header , sizeof ( DFF
",0,511
880,"void vtp_print ( netdissect_options * ndo , const u_char * pptr , u_int length ) { int type , len , tlv_len , tlv_value , mgmtd_len ; const u_char * tptr ; const struct vtp_vlan_ * vtp_vlan ; if ( length < VTP_HEADER_LEN ) goto trunc ; tptr = pptr ; ND_TCHECK2 ( * tptr , VTP_HEADER_LEN ) ; type = * ( tptr + 1 ) ; ND_PRINT ( ( ndo , ""VTPv%u,Message%s(0x%02x),length%u"" , * tptr , tok2str ( vtp_message_type_values , ""Unknownmessagetype"" , type ) , type , length ) ) ; if ( ndo -> ndo_vflag < 1 ) { return ; } ND_PRINT ( ( ndo , ""\\n\\tDomainname:"" ) ) ; mgmtd_len = * ( tptr + 3 ) ; if ( mgmtd_len < 1 || mgmtd_len > 32 ) { ND_PRINT ( ( ndo , ""[invalidMgmtDLen%d]"" , mgmtd_len ) ) ; return ; } fn_printzp ( ndo , tptr + 4 , mgmtd_len , NULL ) ; ND_PRINT ( ( ndo , "",%s:%u"" , tok2str ( vtp_header_values , ""Unknown"" , type ) , * ( tptr + 2 ) ) ) ; tptr += VTP_HEADER_LEN ; switch ( type ) { case VTP_SUMMARY_ADV : ND_TCHECK2 ( * tptr , 8 ) ; ND_PRINT ( ( ndo , ""\\n\\tConfigRev%x,Updater%s"" , EXTRACT_32BITS ( tptr ) , ipaddr_string ( ndo , tptr + 4 ) ) ) ; tptr += 8 ; ND_TCHECK2 ( * tptr , VTP_UPDATE_TIMESTAMP_LEN ) ; ND_PRINT ( ( ndo , "",Timestamp0x%08x0x%08x0
",0,511
881,"static int _snd_timer_stop ( struct snd_timer_instance * timeri , int keep_flag , int event ) { struct snd_timer * timer ; unsigned long flags ; if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { if ( ! keep_flag ) { spin_lock_irqsave ( & slave_active_lock , flags ) ; timeri -> flags &= ~ SNDRV_TIMER_IFLG_RUNNING ; list_del_init ( & timeri -> ack_list ) ; list_del_init ( & timeri -> active_list ) ; if ( ( timeri -> flags & SNDRV_TIMER_IFLG_RUNNING ) && ! ( -- timer -> running ) ) { timer -> hw . stop ( timer ) ; if ( timer -> flags & SNDRV_TIMER_FLG_RESCHED ) { timer -> flags &= ~ SNDRV_TIMER_FLG_RESCHED ; snd_timer_reschedule ( timer , 0 ) ; if ( timer -> flags & SNDRV_TIMER_FLG_CHANGE ) { timer -> flags &= ~ SNDRV_TIMER_FLG_CHANGE ; timer -> hw . start ( timer ) ; } } } } if ( ! keep_flag ) timeri -> flags &= ~ ( SNDRV_TIMER_IFLG_RUNNING | SNDRV_TIMER_IFLG_START ) ; spin_unlock_irqrestore ( & timer -> lock , flags ) ; __end : if ( event != SNDRV_TIMER_EVENT_RESOLUTION ) snd_timer_notify1 ( timeri , event ) ; return 0 ; }
",0,429
882,"void sink ( int argc , char * * argv , const char * src ) { static BUF buffer ; struct stat stb ; BUF * bp ; off_t i ; size_t j , count ; int amt , exists , first , ofd ; mode_t mode , omode , mask ; off_t size , statbytes ; unsigned long long ull ; int setimes , targisdir , wrerrno = 0 ; char ch , * cp , * np , * targ , * why , * vect [ 1 ] , buf [ 2048 ] , visbuf [ 2048 ] ; char * * patterns = NULL ; size_t n , npatterns = 0 ; struct timeval tv [ 2 ] ; # define atime tv [ 0 ] # define mtime tv [ 1 ] # define SCREWUP ( str ) { why = str ; goto screwup ; } if ( TYPE_OVERFLOW ( time_t , 0 ) || TYPE_OVERFLOW ( off_t , 0 ) ) SCREWUP ( ""Unexpectedoff_t/time_tsize"" ) ; setimes = targisdir = 0 ; mask = umask ( 0 ) ; if ( ! pflag ) ( void ) umask ( mask ) ; if ( argc != 1 ) { run_err ( ""ambiguoustarget"" ) ; exit ( 1 ) ; } targ = * argv ; if ( targetshouldbedirectory ) verifydir ( targ ) ; ( void ) atomicio ( vwrite , remout , """" , 1 ) ; if ( stat ( targ , & stb ) == 0 && S_ISDIR ( stb . st_mode ) ) targisdir = 1 ; if ( src != NULL && ! iamrecursive && ! Tflag ) { if ( brace_expand ( src , & patterns , & npatterns ) != 0 ) fatal ( ""%s:couldnotexpandpattern"" , __func__ ) ; } for ( first = 1 ; ; first = 0 ) { cp = buf ; if ( atomicio ( read , remin , cp , 1 ) != 1 ) goto done ; if ( * cp ++ == '\\n' ) SCREWUP ( ""unexpected<newline>"" ) ; do { if ( atomicio ( read , remin , cp , 1 ) != 1 ) goto done ; if ( * cp ++
",0,511
883,"static void cs_cmd_flags ( sourceinfo_t * si , int parc , char * parv [ ] ) { chanacs_t * ca ; mowgli_node_t * n ; char * channel = parv [ 0 ] ; char * target = sstrdup ( parv [ 1 ] ) ; char * flagstr = parv [ 2 ] ; const char * str1 ; unsigned int addflags , removeflags , restrictflags ; hook_channel_acl_req_t req ; mychan_t * mc ; if ( parc < 1 ) { command_fail ( si , fault_needmoreparams , STR_INSUFFICIENT_PARAMS , ""FLAGS"" ) ; command_fail ( si , fault_needmoreparams , _ ( ""Syntax:FLAGS<channel>[target][flags]"" ) ) ; return ; } mc = mychan_find ( channel ) ; if ( ! mc ) { command_fail ( si , fault_nosuch_target , _ ( ""Channel\\2%s\\2isnotregistered."" ) , channel ) ; return ; } if ( metadata_find ( mc , ""private:close:closer"" ) && ( target || ! has_priv ( si , PRIV_CHAN_AUSPEX ) ) ) { command_fail ( si , fault_noprivs , _ ( ""\\2%s\\2isclosed."" ) , channel ) ; return ; } if ( ! target || ( target && target [ 0 ] == '+' && flagstr == NULL ) ) { unsigned int flags = ( target != NULL ) ? flags_to_bitmask ( target , 0 ) : 0 ; do_list ( si , mc , flags ) ; return ; } } else if ( ! strcasecmp ( target , ""LIST"" ) && myentity_find_ext ( target ) == NULL ) { do_list ( si , mc , 0 ) ; free ( target ) ; return ; } else if ( ! strcasecmp ( target , ""CLEAR"" ) && myentity_find_ext ( target ) == NULL ) { free ( target ) ; if ( ! chanacs_source_has_flag ( mc , si , CA_FOUNDER ) ) { command_fail ( si , fault_noprivs , ""Youarenotauthorizedtoperformthisoperation."" ) ; free
",0,511
884,"static int ghash_final ( struct shash_desc * desc , u8 * dst ) { struct ghash_desc_ctx * dctx = shash_desc_ctx ( desc ) ; struct ghash_ctx * ctx = crypto_shash_ctx ( desc -> tfm ) ; u8 * buf = dctx -> buffer ; if ( ! ctx -> gf128 ) return - ENOKEY ; ghash_flush ( ctx , dctx ) ; memcpy ( dst , buf , GHASH_BLOCK_SIZE ) ; return 0 ; }
",1,124
885,"static int read_gab2_sub ( AVFormatContext * s , AVStream * st , AVPacket * pkt ) { if ( pkt -> size >= 7 && pkt -> size < INT_MAX - AVPROBE_PADDING_SIZE && ! strcmp ( pkt -> data , ""GAB2"" ) && AV_RL16 ( pkt -> data + 5 ) == 2 ) { uint8_t desc [ 256 ] ; int score = AVPROBE_SCORE_EXTENSION , ret ; AVIStream * ast = st -> priv_data ; AVInputFormat * sub_demuxer ; AVRational time_base ; int size ; AVIOContext * pb = avio_alloc_context ( pkt -> data + 7 , pkt -> size - 7 , 0 , NULL , NULL , NULL , NULL ) ; AVProbeData pd ; unsigned int desc_len = avio_rl32 ( pb ) ; if ( desc_len > pb -> buf_end - pb -> buf_ptr ) goto error ; ret = avio_get_str16le ( pb , desc_len , desc , sizeof ( desc ) ) ; avio_skip ( pb , desc_len - ret ) ; if ( * desc ) av_dict_set ( & st -> metadata , ""title"" , desc , 0 ) ; avio_rl16 ( pb ) ; avio_rl32 ( pb ) ; size = pb -> buf_end - pb -> buf_ptr ; pd = ( AVProbeData ) { . buf = av_mallocz ( size + AVPROBE_PADDING_SIZE ) , . buf_size = size } ; if ( ! pd . buf ) goto error ; memcpy ( pd . buf , pb -> buf_ptr , size ) ; sub_demuxer = av_probe_input_format2 ( & pd , 1 , & score ) ; av_freep ( & pd . buf ) ; if ( ! sub_demuxer ) goto error ; if ( ! ( ast -> sub_ctx = avformat_alloc_context ( ) ) ) goto error ; ast -> sub_ctx -> pb = pb ; if ( ff_copy_whiteblacklists ( ast -> sub_ctx , s ) )
",0,511
886,"static krb5_error_code recvauth_common ( krb5_context context , krb5_auth_context * auth_context , krb5_pointer fd , char * appl_version , krb5_principal server , krb5_int32 flags , krb5_keytab keytab , krb5_ticket * * ticket , krb5_data * version ) { krb5_auth_context new_auth_context ; krb5_flags ap_option = 0 ; krb5_error_code retval , problem ; krb5_data inbuf ; krb5_data outbuf ; krb5_rcache rcache = 0 ; krb5_octet response ; krb5_data null_server ; int need_error_free = 0 ; int local_rcache = 0 , local_authcon = 0 ; problem = 0 ; response = 0 ; if ( ! ( flags & KRB5_RECVAUTH_SKIP_VERSION ) ) { if ( ( retval = krb5_read_message ( context , fd , & inbuf ) ) ) return ( retval ) ; if ( strcmp ( inbuf . data , sendauth_version ) ) { problem = KRB5_SENDAUTH_BADAUTHVERS ; response = 1 ; } free ( inbuf . data ) ; } if ( flags & KRB5_RECVAUTH_BADAUTHVERS ) { problem = KRB5_SENDAUTH_BADAUTHVERS ; response = 1 ; } if ( ( retval = krb5_read_message ( context , fd , & inbuf ) ) ) return ( retval ) ; free ( inbuf . data ) ; if ( ( krb5_net_write ( context , * ( ( int * ) fd ) , ( char * ) & response , 1 ) ) < 0 ) { return ( problem ) ; } if ( problem ) return ( problem ) ; if ( ( retval = krb5_read_message ( context , fd , & inbuf ) ) ) return ( retval ) ; if ( appl_version && strcmp ( inbuf . data , appl_version ) ) { if ( ! problem ) { problem = KRB5_SENDAUTH_BADAPPLVERS ; response = 2 ;
",0,511
887,"static INLINE int write_bit_gte ( vpx_writer * w , int word , int test ) { vpx_write_literal ( w , word >= test , 1 ) ; return ( word >= test ) ; }
",0,51
888,"static int __btrfs_set_acl ( struct btrfs_trans_handle * trans , struct inode * inode , struct posix_acl * acl , int type ) { int ret , size = 0 ; const char * name ; char * value = NULL ; switch ( type ) { case ACL_TYPE_ACCESS : name = XATTR_NAME_POSIX_ACL_ACCESS ; if ( acl ) { ret = posix_acl_update_mode ( inode , & inode -> i_mode ) ; if ( ret < 0 ) return ret ; if ( ret == 0 ) acl = NULL ; } ret = 0 ; break ; case ACL_TYPE_DEFAULT : if ( ! S_ISDIR ( inode -> i_mode ) ) return acl ? - EINVAL : 0 ; name = XATTR_NAME_POSIX_ACL_DEFAULT ; break ; default : return - EINVAL ; } if ( acl ) { size = posix_acl_xattr_size ( acl -> a_count ) ; value = kmalloc ( size , GFP_KERNEL ) ; if ( ! value ) { ret = - ENOMEM ; goto out ; } ret = posix_acl_to_xattr ( & init_user_ns , acl , value , size ) ; if ( ret < 0 ) goto out ; } ret = __btrfs_setxattr ( trans , inode , name , value , size , 0 ) ; out : kfree ( value ) ; if ( ! ret ) set_cached_acl ( inode , type , acl ) ; return ret ; }
",0,363
889,"void rose_write_internal ( struct sock * sk , int frametype ) { struct rose_sock * rose = rose_sk ( sk ) ; struct sk_buff * skb ; unsigned char * dptr ; unsigned char lci1 , lci2 ; char buffer [ 100 ] ; int len , faclen = 0 ; len = AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + ROSE_MIN_LEN + 1 ; switch ( frametype ) { case ROSE_CALL_REQUEST : len += 1 + ROSE_ADDR_LEN + ROSE_ADDR_LEN ; faclen = rose_create_facilities ( buffer , rose ) ; len += faclen ; break ; case ROSE_CALL_ACCEPTED : case ROSE_CLEAR_REQUEST : case ROSE_RESET_REQUEST : len += 2 ; break ; } if ( ( skb = alloc_skb ( len , GFP_ATOMIC ) ) == NULL ) return ; skb_reserve ( skb , AX25_BPQ_HEADER_LEN + AX25_MAX_HEADER_LEN + 1 ) ; dptr = skb_put ( skb , skb_tailroom ( skb ) ) ; lci1 = ( rose -> lci >> 8 ) & 0x0F ; lci2 = ( rose -> lci >> 0 ) & 0xFF ; switch ( frametype ) { case ROSE_CALL_REQUEST : * dptr ++ = ROSE_CALL_REQ_ADDR_LEN_VAL ; memcpy ( dptr , & rose -> dest_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , & rose -> source_addr , ROSE_ADDR_LEN ) ; dptr += ROSE_ADDR_LEN ; memcpy ( dptr , buffer , faclen ) ; dptr += faclen ; break ; case ROSE_CALL_ACCEPTED : * dptr ++ = ROSE_GFI | lci1 ; * dptr ++ = lci2 ; * dptr ++ = frametype ; * dptr ++ = 0x00 ; * d
",0,511
890,"struct mnt_namespace * copy_mnt_ns ( unsigned long flags , struct mnt_namespace * ns , struct user_namespace * user_ns , struct fs_struct * new_fs ) { struct mnt_namespace * new_ns ; struct vfsmount * rootmnt = NULL , * pwdmnt = NULL ; struct mount * p , * q ; struct mount * old ; struct mount * new ; int copy_flags ; BUG_ON ( ! ns ) ; if ( likely ( ! ( flags & CLONE_NEWNS ) ) ) { get_mnt_ns ( ns ) ; return ns ; } old = ns -> root ; new_ns = alloc_mnt_ns ( user_ns ) ; if ( IS_ERR ( new_ns ) ) return new_ns ; namespace_lock ( ) ; copy_flags = CL_COPY_UNBINDABLE | CL_EXPIRE ; if ( user_ns != ns -> user_ns ) copy_flags |= CL_SHARED_TO_SLAVE | CL_UNPRIVILEGED ; new = copy_tree ( old , old -> mnt . mnt_root , copy_flags ) ; if ( IS_ERR ( new ) ) { namespace_unlock ( ) ; free_mnt_ns ( new_ns ) ; return ERR_CAST ( new ) ; } new_ns -> root = new ; list_add_tail ( & new_ns -> list , & new -> mnt_list ) ; p = old ; q = new ; while ( p ) { q -> mnt_ns = new_ns ; new_ns -> mounts ++ ; if ( new_fs ) { if ( & p -> mnt == new_fs -> root . mnt ) { new_fs -> root . mnt = mntget ( & q -> mnt ) ; rootmnt = & p -> mnt ; } if ( & p -> mnt == new_fs -> pwd . mnt ) { new_fs -> pwd . mnt = mntget ( & q -> mnt ) ; pwdmnt = & p -> mnt ; } } p = next_mnt ( p , old ) ; q = next_mnt ( q , new ) ; if ( ! q ) break ;
",0,511
891,"int vp8_alloc_frame_buffers ( VP8_COMMON * oci , int width , int height ) { int i ; vp8_de_alloc_frame_buffers ( oci ) ; if ( ( width & 0xf ) != 0 ) width += 16 - ( width & 0xf ) ; if ( ( height & 0xf ) != 0 ) height += 16 - ( height & 0xf ) ; for ( i = 0 ; i < NUM_YV12_BUFFERS ; i ++ ) { oci -> fb_idx_ref_cnt [ i ] = 0 ; oci -> yv12_fb [ i ] . flags = 0 ; if ( vp8_yv12_alloc_frame_buffer ( & oci -> yv12_fb [ i ] , width , height , VP8BORDERINPIXELS ) < 0 ) goto allocation_fail ; } oci -> new_fb_idx = 0 ; oci -> lst_fb_idx = 1 ; oci -> gld_fb_idx = 2 ; oci -> alt_fb_idx = 3 ; oci -> fb_idx_ref_cnt [ 0 ] = 1 ; oci -> fb_idx_ref_cnt [ 1 ] = 1 ; oci -> fb_idx_ref_cnt [ 2 ] = 1 ; oci -> fb_idx_ref_cnt [ 3 ] = 1 ; if ( vp8_yv12_alloc_frame_buffer ( & oci -> temp_scale_frame , width , 16 , VP8BORDERINPIXELS ) < 0 ) goto allocation_fail ; oci -> mb_rows = height >> 4 ; oci -> mb_cols = width >> 4 ; oci -> MBs = oci -> mb_rows * oci -> mb_cols ; oci -> mode_info_stride = oci -> mb_cols + 1 ; oci -> mip = vpx_calloc ( ( oci -> mb_cols + 1 ) * ( oci -> mb_rows + 1 ) , sizeof ( MODE_INFO ) ) ; if ( ! oci -> mip ) goto allocation_fail ; oci -> mi = o
",0,511
892,"static PHP_MINIT_FUNCTION ( zip ) { # ifdef PHP_ZIP_USE_OO zend_class_entry ce ; memcpy ( & zip_object_handlers , zend_get_std_object_handlers ( ) , sizeof ( zend_object_handlers ) ) ; zip_object_handlers . clone_obj = NULL ; zip_object_handlers . get_property_ptr_ptr = php_zip_get_property_ptr_ptr ; zip_object_handlers . get_properties = php_zip_get_properties ; zip_object_handlers . read_property = php_zip_read_property ; zip_object_handlers . has_property = php_zip_has_property ; INIT_CLASS_ENTRY ( ce , ""ZipArchive"" , zip_class_functions ) ; ce . create_object = php_zip_object_new ; zip_class_entry = zend_register_internal_class ( & ce TSRMLS_CC ) ; zend_hash_init ( & zip_prop_handlers , 0 , NULL , NULL , 1 ) ; php_zip_register_prop_handler ( & zip_prop_handlers , ""status"" , php_zip_status , NULL , NULL , IS_LONG TSRMLS_CC ) ; php_zip_register_prop_handler ( & zip_prop_handlers , ""statusSys"" , php_zip_status_sys , NULL , NULL , IS_LONG TSRMLS_CC ) ; php_zip_register_prop_handler ( & zip_prop_handlers , ""numFiles"" , php_zip_get_num_files , NULL , NULL , IS_LONG TSRMLS_CC ) ; php_zip_register_prop_handler ( & zip_prop_handlers , ""filename"" , NULL , NULL , php_zipobj_get_filename , IS_STRING TSRMLS_CC ) ; php_zip_register_prop_handler ( & zip_prop_handlers , ""comment"" , NULL , php_zipobj_get_zip_comment , NULL , IS_STRING TSRMLS_CC ) ; REGISTER_ZIP_CLASS_CONST_LONG ( ""CREATE"" ,
",0,510
893,"int mem_check_range ( struct rxe_mem * mem , u64 iova , size_t length ) { switch ( mem -> type ) { case RXE_MEM_TYPE_DMA : return 0 ; case RXE_MEM_TYPE_MR : case RXE_MEM_TYPE_FMR : if ( ( iova < mem -> iova ) || ( ( iova + length ) > ( mem -> iova + length ) ) ) { return - EFAULT : 0 ; } default : return - EFAULT ; } }
",0,120
894,"static void icmp6_nodeinfo_print ( netdissect_options * ndo , u_int icmp6len , const u_char * bp , const u_char * ep ) { const struct icmp6_nodeinfo * ni6 ; const struct icmp6_hdr * dp ; const u_char * cp ; size_t siz , i ; int needcomma ; if ( ep < bp ) return ; dp = ( const struct icmp6_hdr * ) bp ; ni6 = ( const struct icmp6_nodeinfo * ) bp ; siz = ep - bp ; switch ( ni6 -> ni_type ) { case ICMP6_NI_QUERY : if ( siz == sizeof ( * dp ) + 4 ) { ND_PRINT ( ( ndo , ""%s"" , icmp6_tstr ) ) ; break ; } ND_PRINT ( ( ndo , ""nodeinformationquery"" ) ) ; ND_TCHECK2 ( * dp , sizeof ( * ni6 ) ) ; ni6 = ( const struct icmp6_nodeinfo * ) dp ; ND_PRINT ( ( ndo , ""("" ) ) ; switch ( EXTRACT_16BITS ( & ni6 -> ni_qtype ) ) { case NI_QTYPE_NOOP : ND_PRINT ( ( ndo , ""noop"" ) ) ; break ; case NI_QTYPE_SUPTYPES : ND_PRINT ( ( ndo , ""supportedqtypes"" ) ) ; i = EXTRACT_16BITS ( & ni6 -> ni_flags ) ; if ( i ) ND_PRINT ( ( ndo , ""[%s]"" , ( i & 0x01 ) ? ""C"" : """" ) ) ; break ; case NI_QTYPE_FQDN : ND_PRINT ( ( ndo , ""DNSname"" ) ) ; break ; case NI_QTYPE_NODEADDR : ND_PRINT ( ( ndo , ""nodeaddresses"" ) ) ; i = ni6 -> ni_flags ; if ( ! i ) break ; ND_PRINT ( ( ndo , ""[%s%s%s%s%s%s]"" , ( i & NI_NODEADDR_FLAG_ANYCAST ) ? ""
",0,511
895,"static void finish_object ( struct object * obj , const char * name , void * cb_data ) { struct rev_list_info * info = cb_data ; if ( obj -> type == OBJ_BLOB && ! has_object_file ( & obj -> oid ) ) die ( ""missingblobobject\'%s\'"" , oid_to_hex ( & obj -> oid ) ) ; if ( info -> revs -> verify_objects && ! obj -> parsed && obj -> type != OBJ_COMMIT ) parse_object ( obj -> oid . hash ) ; }
",1,132
896,"static int smb_send_kvec ( struct TCP_Server_Info * server , struct kvec * iov , size_t n_vec , size_t * sent ) { int rc = 0 ; int i = 0 ; struct msghdr smb_msg ; unsigned int remaining ; size_t first_vec = 0 ; struct socket * ssocket = server -> ssocket ; * sent = 0 ; smb_msg . msg_name = ( struct sockaddr * ) & server -> dstaddr ; smb_msg . msg_namelen = sizeof ( struct sockaddr ) ; smb_msg . msg_control = NULL ; smb_msg . msg_controllen = 0 ; if ( server -> noblocksnd ) smb_msg . msg_flags = MSG_DONTWAIT + MSG_NOSIGNAL ; else smb_msg . msg_flags = MSG_NOSIGNAL ; remaining = 0 ; for ( i = 0 ; i < n_vec ; i ++ ) remaining += iov [ i ] . iov_len ; i = 0 ; while ( remaining ) { rc = kernel_sendmsg ( ssocket , & smb_msg , & iov [ first_vec ] , n_vec - first_vec , remaining ) ; if ( rc == - ENOSPC || rc == - EAGAIN ) { WARN_ON_ONCE ( rc == - ENOSPC ) ; i ++ ; if ( i >= 14 || ( ! server -> noblocksnd && ( i > 2 ) ) ) { cERROR ( 1 , ""sendsonsock%pstuckfor15"" ""seconds"" , ssocket ) ; rc = - EAGAIN ; break ; } msleep ( 1 << i ) ; continue ; } if ( rc < 0 ) break ; * sent += rc ; if ( rc == remaining ) { remaining = 0 ; break ; } if ( rc > remaining ) { cERROR ( 1 , ""sent%drequested%d"" , rc , remaining ) ; break ; } if ( rc == 0 ) { cERROR ( 1 , ""tcpsentnodata"" ) ; msleep ( 500 ) ; continue ; } remaining -= rc ; for ( i = first_vec ; i < n_vec ; i ++ ) { if ( iov [ i ] . iov_len ) { if ( rc > iov [
",0,511
897,"static bool buffer_pipe_buf_get ( struct pipe_inode_info * pipe , struct pipe_buffer * buf ) { struct buffer_ref * ref = ( struct buffer_ref * ) buf -> private ; if ( ref -> ref > INT_MAX / 2 ) return false ; ref -> ref ++ ; return true ; }
",1,71
898,"void set_fat ( DOS_FS * fs , uint32_t cluster , int32_t new ) { unsigned char * data = NULL ; int size ; loff_t offs ; if ( new == - 1 ) new = FAT_EOF ( fs ) ; else if ( ( long ) new == - 2 ) new = FAT_BAD ( fs ) ; switch ( fs -> fat_bits ) { case 12 : data = fs -> fat + cluster * 3 / 2 ; offs = fs -> fat_start + cluster * 3 / 2 ; if ( cluster & 1 ) { FAT_ENTRY prevEntry ; get_fat ( & prevEntry , fs -> fat , cluster - 1 , fs ) ; data [ 0 ] = ( ( new & 0xf ) << 4 ) | ( prevEntry . value >> 8 ) ; data [ 1 ] = new >> 4 ; } else { FAT_ENTRY subseqEntry ; if ( cluster != fs -> clusters - 1 ) get_fat ( & subseqEntry , fs -> fat , cluster + 1 , fs ) ; else subseqEntry . value = 0 ; data [ 0 ] = new & 0xff ; data [ 1 ] = ( new >> 8 ) | ( ( 0xff & subseqEntry . value ) << 4 ) ; } size = 2 ; break ; case 16 : data = fs -> fat + cluster * 2 ; offs = fs -> fat_start + cluster * 2 ; * ( unsigned short * ) data = htole16 ( new ) ; size = 2 ; break ; case 32 : { FAT_ENTRY curEntry ; get_fat ( & curEntry , fs -> fat , cluster , fs ) ; data = fs -> fat + cluster * 4 ; offs = fs -> fat_start + cluster * 4 ; * ( uint32_t * ) data = htole32 ( ( new & 0xfffffff ) | ( curEntry . reserved << 28 ) ) ; size = 4 ; } break ; default : die ( ""BadFATentrysize:%dbits."" , fs -> fat_bits ) ; } fs_write ( offs , size , data ) ; if ( fs -> nfats > 1 ) { fs_write ( offs + fs -> fat_size , size , data ) ; } }
",0,486
899,"void vp8_optimize_mby ( MACROBLOCK * x ) { int b ; int type ; int has_2nd_order ; ENTROPY_CONTEXT_PLANES t_above , t_left ; ENTROPY_CONTEXT * ta ; ENTROPY_CONTEXT * tl ; if ( ! x -> e_mbd . above_context ) return ; memcpy ( & t_above , x -> e_mbd . above_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; memcpy ( & t_left , x -> e_mbd . left_context , sizeof ( ENTROPY_CONTEXT_PLANES ) ) ; ta = ( ENTROPY_CONTEXT * ) & t_above ; tl = ( ENTROPY_CONTEXT * ) & t_left ; has_2nd_order = ( x -> e_mbd . mode_info_context -> mbmi . mode != B_PRED && x -> e_mbd . mode_info_context -> mbmi . mode != SPLITMV ) ; type = has_2nd_order ? PLANE_TYPE_Y_NO_DC : PLANE_TYPE_Y_WITH_DC ; for ( b = 0 ; b < 16 ; b ++ ) { optimize_b ( x , b , type , ta + vp8_block2above [ b ] , tl + vp8_block2left [ b ] ) ; } if ( has_2nd_order ) { b = 24 ; optimize_b ( x , b , PLANE_TYPE_Y2 , ta + vp8_block2above [ b ] , tl + vp8_block2left [ b ] ) ; check_reset_2nd_coeffs ( & x -> e_mbd , PLANE_TYPE_Y2 , ta + vp8_block2above [ b ] , tl + vp8_block2left [ b ] ) ; } }
",0,454
900,"void ping_unhash ( struct sock * sk ) { struct inet_sock * isk = inet_sk ( sk ) ; pr_debug ( ""ping_unhash(isk=%p,isk->num=%u)\\n"" , isk , isk -> inet_num ) ; if ( sk_hashed ( sk ) ) { write_lock_bh ( & ping_table . lock ) ; hlist_nulls_del ( & sk -> sk_nulls_node ) ; sk_nulls_node_init ( & sk -> sk_nulls_node ) ; sock_put ( sk ) ; isk -> inet_num = 0 ; isk -> inet_sport = 0 ; sock_prot_inuse_add ( sock_net ( sk ) , sk -> sk_prot , - 1 ) ; write_unlock_bh ( & ping_table . lock ) ; } }
",1,204
901,"WORD32 ih264d_mark_err_slice_skip ( dec_struct_t * ps_dec , WORD32 num_mb_skip , UWORD8 u1_is_idr_slice , UWORD16 u2_frame_num , pocstruct_t * ps_cur_poc , WORD32 prev_slice_err ) { WORD32 i2_cur_mb_addr ; UWORD32 u1_num_mbs , u1_num_mbsNby2 ; UWORD32 u1_mb_idx = ps_dec -> u1_mb_idx ; UWORD32 i2_mb_skip_run ; UWORD32 u1_num_mbs_next , u1_end_of_row ; const UWORD32 i2_pic_wdin_mbs = ps_dec -> u2_frm_wd_in_mbs ; UWORD32 u1_slice_end ; UWORD32 u1_tfr_n_mb ; UWORD32 u1_decode_nmb ; dec_bit_stream_t * const ps_bitstrm = ps_dec -> ps_bitstrm ; dec_slice_params_t * ps_slice = ps_dec -> ps_cur_slice ; UWORD32 * pu4_bitstrm_buf = ps_bitstrm -> pu4_buffer ; UWORD32 * pu4_bitstrm_ofst = & ps_bitstrm -> u4_ofst ; deblk_mb_t * ps_cur_deblk_mb ; dec_mb_info_t * ps_cur_mb_info ; parse_pmbarams_t * ps_parse_mb_data ; UWORD32 u1_inter_mb_type ; UWORD32 u1_deblk_mb_type ; UWORD16 u2_total_mbs_coded ; UWORD32 u1_mbaff = ps_slice -> u1_mbaff_frame_flag ; parse_part_params_t * ps_part_info ; WORD32 ret ; if ( ps_dec -> ps_dec_err_status -> u1_err_flag & REJECT_CUR_PIC ) { ih264d_err_pic_dis
",0,511
902,"static ssize_t environ_read ( struct file * file , char __user * buf , size_t count , loff_t * ppos ) { char * page ; unsigned long src = * ppos ; int ret = 0 ; struct mm_struct * mm = file -> private_data ; unsigned long env_start , env_end ; if ( ! mm || ! mm -> env_end ) return 0 ; page = ( char * ) __get_free_page ( GFP_TEMPORARY ) ; if ( ! page ) return - ENOMEM ; ret = 0 ; if ( ! atomic_inc_not_zero ( & mm -> mm_users ) ) goto free ; down_read ( & mm -> mmap_sem ) ; env_start = mm -> env_start ; env_end = mm -> env_end ; up_read ( & mm -> mmap_sem ) ; while ( count > 0 ) { size_t this_len , max_len ; int retval ; if ( src >= ( env_end - env_start ) ) break ; this_len = env_end - ( env_start + src ) ; max_len = min_t ( size_t , PAGE_SIZE , count ) ; this_len = min ( max_len , this_len ) ; retval = access_remote_vm ( mm , ( env_start + src ) , page , this_len , 0 ) ; if ( retval <= 0 ) { ret = retval ; break ; } if ( copy_to_user ( buf , page , retval ) ) { ret = - EFAULT ; break ; } ret += retval ; src += retval ; buf += retval ; count -= retval ; } * ppos = src ; mmput ( mm ) ; free : free_page ( ( unsigned long ) page ) ; return ret ; }
",1,404
903,"int parse_rock_ridge_inode ( struct iso_directory_record * de , struct inode * inode , int relocated ) { int flags = relocated ? RR_RELOC_DE : 0 ; int result = parse_rock_ridge_inode_internal ( de , inode , flags ) ; if ( ( ISOFS_SB ( inode -> i_sb ) -> s_rock_offset == - 1 ) && ( ISOFS_SB ( inode -> i_sb ) -> s_rock == 2 ) ) { result = parse_rock_ridge_inode_internal ( de , inode , flags | RR_REGARD_XA ) ; } return result ; }
",1,149
904,"static struct fsnotify_group * inotify_new_group ( unsigned int max_events ) { struct fsnotify_group * group ; group = fsnotify_alloc_group ( & inotify_fsnotify_ops ) ; if ( IS_ERR ( group ) ) return group ; group -> max_events = max_events ; spin_lock_init ( & group -> inotify_data . fa = NULL ; group -> inotify_data . last_wd = 0 ; group -> inotify_data . user = user ; group -> inotify_data . user = get_current_user ( ) ; if ( atomic_inc_return ( & group -> inotify_data . user -> inotify_devs ) > inotify_max_user_instances ) { fsnotify_put_group ( group ) ; return ERR_PTR ( - EMFILE ) ; } return group ; }
",1,208
905,"static int filter_frame ( AVFilterLink * inlink , AVFrame * in ) { GradFunContext * s = inlink -> dst -> priv ; AVFilterLink * outlink = inlink -> dst -> outputs [ 0 ] ; AVFrame * out ; int p , direct ; if ( av_frame_is_writable ( in ) ) { direct = 1 ; out = in ; } else { direct = 0 ; out = ff_get_video_buffer ( outlink , outlink -> w , outlink -> h ) ; if ( ! out ) { av_frame_free ( & in ) ; return AVERROR ( ENOMEM ) ; } av_frame_copy_props ( out , in ) ; } for ( p = 0 ; p < 4 && in -> data [ p ] && in -> linesize [ p ] ; p ++ ) { int w = inlink -> w ; int h = inlink -> h ; int r = s -> radius ; if ( p ) { w = s -> chroma_w ; h = s -> chroma_h ; r = s -> chroma_r ; } if ( FFMIN ( w , h ) > 2 * r ) filter ( s , out -> data [ p ] , in -> data [ p ] , w , h , out -> linesize [ p ] , in -> linesize [ p ] , r ) ; else if ( out -> data [ p ] != in -> data [ p ] ) av_image_copy_plane ( out -> data [ p ] , out -> linesize [ p ] , in -> data [ p ] , in -> linesize [ p ] , w , h ) ; } if ( ! direct ) av_frame_free ( & in ) ; return ff_filter_frame ( outlink , out ) ; }
",1,386
906,"Datum hstore_recv ( PG_FUNCTION_ARGS ) { int32 buflen ; HStore * out ; Pairs * pairs ; int32 i ; int32 pcount ; StringInfo buf = ( StringInfo ) PG_GETARG_POINTER ( 0 ) ; pcount = pq_getmsgint ( buf , 4 ) ; if ( pcount == 0 ) { out = hstorePairs ( NULL , 0 , 0 ) ; PG_RETURN_POINTER ( out ) ; } for ( i = 0 ; i < pcount ; ++ i ) { int rawlen = pq_getmsgint ( buf , 4 ) ; int len ; if ( rawlen < 0 ) ereport ( ERROR , ( errcode ( ERRCODE_NULL_VALUE_NOT_ALLOWED ) , errmsg ( ""nullvaluenotallowedforhstorekey"" ) ) ) ; pairs [ i ] . key = pq_getmsgtext ( buf , rawlen , & len ) ; pairs [ i ] . keylen = hstoreCheckKeyLen ( len ) ; pairs [ i ] . needfree = true ; rawlen = pq_getmsgint ( buf , 4 ) ; if ( rawlen < 0 ) { pairs [ i ] . val = NULL ; pairs [ i ] . vallen = 0 ; pairs [ i ] . isnull = true ; } else { pairs [ i ] . val = pq_getmsgtext ( buf , rawlen , & len ) ; pairs [ i ] . vallen = hstoreCheckValLen ( len ) ; pairs [ i ] . isnull = false ; } } pcount = hstoreUniquePairs ( pairs , pcount , & buflen ) ; out = hstorePairs ( pairs , pcount , buflen ) ; PG_RETURN_POINTER ( out ) ; }
",0,406
907,"INTERNAL void vterm_screen_free ( VTermScreen * screen ) { vterm_allocator_free ( screen -> vt , screen -> buffers [ 0 ] ) ; if ( screen -> buffers [ 1 ] ) vterm_allocator_free ( screen -> vt , screen -> buffers [ 1 ] ) ; vterm_allocator_free ( screen -> vt , screen -> sb_buffer ) ; vterm_allocator_free ( screen -> vt , screen ) ; }
",0,108
908,"static int check_mem_access ( struct bpf_verifier_env * env , int insn_idx , u32 regno , int off , int bpf_size , enum bpf_access_type t , int value_regno ) { struct bpf_verifier_state * state = env -> cur_state ; struct bpf_reg_state * regs = cur_regs ( env ) ; struct bpf_reg_state * reg = regs + regno ; int size , err = 0 ; size = bpf_size_to_bytes ( bpf_size ) ; if ( size < 0 ) return size ; err = check_ptr_alignment ( env , reg , off , size ) ; if ( err ) return err ; off += reg -> off ; if ( reg -> type == PTR_TO_MAP_VALUE ) { if ( t == BPF_WRITE && value_regno >= 0 && is_pointer_value ( env , value_regno ) ) { verbose ( env , ""R%dleaksaddrintomap\\n"" , value_regno ) ; return - EACCES ; } err = check_map_access ( env , regno , off , size , false ) ; if ( ! err && t == BPF_READ && value_regno >= 0 ) mark_reg_unknown ( env , regs , value_regno ) ; } else if ( reg -> type == PTR_TO_CTX ) { enum bpf_reg_type reg_type = SCALAR_VALUE ; if ( t == BPF_WRITE && value_regno >= 0 && is_pointer_value ( env , value_regno ) ) { verbose ( env , ""R%dleaksaddrintoctx\\n"" , value_regno ) ; return - EACCES ; } if ( reg -> off ) { verbose ( env , ""dereferenceofmodifiedctxptrR%doff=%d+%d,ctx+constisallowed,ctx+const+constisnot\\n"" , regno , reg -> off , off - reg -> off ) ; return - EACCES ; } if ( ! tnum_is_const ( reg -> var_off ) || reg -> var_off . value ) { char
",0,511
909,"static int readContigStripsIntoBuffer ( TIFF * in , uint8 * buf ) { uint8 * bufp = buf ; int32 bytes_read = 0 ; uint32 strip , nstrips = TIFFNumberOfStrips ( in ) ; uint32 stripsize = TIFFStripSize ( in ) ; uint32 rows = 0 ; uint32 rps = TIFFGetFieldDefaulted ( in , TIFFTAG_ROWSPERSTRIP , & rps ) ; tsize_t scanline_size = TIFFScanlineSize ( in ) ; if ( scanline_size == 0 ) { TIFFError ( """" , ""TIFFscanlinesizeiszero!"" ) ; return 0 ; } for ( strip = 0 ; strip < nstrips ; strip ++ ) { bytes_read = TIFFReadEncodedStrip ( in , strip , bufp , - 1 ) ; rows = bytes_read / scanline_size ; if ( ( strip < ( nstrips - 1 ) ) && ( bytes_read != ( int32 ) stripsize ) ) TIFFError ( """" , ""Strip%d:read%lubytes,stripsize%lu"" , ( int ) strip + 1 , ( unsigned long ) bytes_read , ( unsigned long ) stripsize ) ; if ( bytes_read < 0 && ! ignore ) { TIFFError ( """" , ""Errorreadingstrip%luafter%lurows"" , ( unsigned long ) strip , ( unsigned long ) rows ) ; return 0 ; } bufp += bytes_read ; } return 1 ; }
",1,344
910,"static char * search_make_new ( const struct search_state * const state , int n , const char * const base_name ) { const size_t base_len = strlen ( base_name ) ; char need_to_append_dot ; struct search_domain * dom ; if ( ! base_len ) return NULL ; need_to_append_dot = base_name [ base_len - 1 ] == '.' ? 0 : 1 ; for ( dom = state -> head ; dom ; dom = dom -> next ) { if ( ! n -- ) { const u8 * const postfix = ( ( u8 * ) dom ) + sizeof ( struct search_domain ) ; const int postfix_len = dom -> len ; char * const newname = ( char * ) mm_malloc ( base_len + need_to_append_dot + postfix_len + 1 ) ; if ( ! newname ) return NULL ; memcpy ( newname , base_name , base_len ) ; if ( need_to_append_dot ) newname [ base_len ] = '.' ; memcpy ( newname + base_len + need_to_append_dot , postfix , postfix_len ) ; newname [ base_len + need_to_append_dot + postfix_len ] = 0 ; return newname ; } } EVUTIL_ASSERT ( 0 ) ; return NULL ; }
",1,311
911,"void GKI_delay ( UINT32 timeout_ms ) { struct timespec delay ; delay . tv_sec = timeout_ms / 1000 ; delay . tv_nsec = 1000 * 1000 * ( timeout_ms % 1000 ) ; int err ; do { err = nanosleep ( & delay , & delay ) ; } while ( err == - 1 && errno == EINTR ) ; }
",0,86
912,"static int caif_stream_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t size , int flags ) { struct sock * sk = sock -> sk ; int copied = 0 ; int target ; int err = 0 ; long timeo ; err = - EOPNOTSUPP ; if ( flags & MSG_OOB ) goto out ; err = - EAGAIN ; if ( sk -> sk_state == CAIF_CONNECTING ) goto out ; caif_read_lock ( sk ) ; target = sock_rcvlowat ( sk , flags & MSG_WAITALL , size ) ; timeo = sock_rcvtimeo ( sk , flags & MSG_DONTWAIT ) ; do { int chunk ; struct sk_buff * skb ; lock_sock ( sk ) ; skb = skb_dequeue ( & sk -> sk_receive_queue ) ; caif_check_flow_release ( sk ) ; if ( skb == NULL ) { if ( copied >= target ) goto unlock ; err = sock_error ( sk ) ; if ( err ) goto unlock ; err = - ECONNRESET ; if ( sk -> sk_shutdown & RCV_SHUTDOWN ) goto unlock ; err = - EPIPE ; if ( sk -> sk_state != CAIF_CONNECTED ) goto unlock ; if ( sock_flag ( sk , SOCK_DEAD ) ) goto unlock ; release_sock ( sk ) ; err = - EAGAIN ; if ( ! timeo ) break ; caif_read_unlock ( sk ) ; timeo = caif_stream_data_wait ( sk , timeo ) ; if ( signal_pending ( current ) ) { err = sock_intr_errno ( timeo ) ; goto out ; } caif_read_lock ( sk ) ; continue ; unlock : release_sock ( sk ) ; break ; } release_sock ( sk ) ; chunk = min_t ( unsigned int , skb -> len , size ) ; if ( memcpy_toiovec ( msg -> msg_iov , skb -> data , chunk ) ) { skb_queue_head ( & sk -> sk_receive_queue , skb ) ; msg -> msg_namelen =
",0,511
913,"static Image * ReadRLEImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define SkipLinesOp 0x01 # define SetColorOp 0x02 # define SkipPixelsOp 0x03 # define ByteDataOp 0x05 # define RunDataOp 0x06 # define EOFOp 0x07 char magick [ 12 ] ; Image * image ; int opcode , operand , status ; MagickStatusType flags ; MagickSizeType number_pixels ; MemoryInfo * pixel_info ; Quantum index ; register ssize_t x ; register Quantum * q ; register ssize_t i ; register unsigned char * p ; size_t bits_per_pixel , map_length , number_colormaps , number_planes , number_planes_filled , one , offset , pixel_info_length ; ssize_t count , y ; unsigned char background_color [ 256 ] , * colormap , pixel , plane , * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ; if ( ( count != 2 ) || ( memcmp ( magick , ""\\122\\314"" , 2 ) != 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; do { image -> page . x = ReadBlobLSBShort ( image ) ; image -> page . y = ReadBlobLSBShort ( image ) ; image -> columns = ReadBlobLSBShort ( image ) ; image -> rows = ReadBlobLSBShort ( image ) ; flags = ( MagickStatusType ) ReadBlobByte ( image ) ; image -> alpha_trait = 0
",0,511
914,"static BOOL nsc_rle_decompress_data ( NSC_CONTEXT * context ) { UINT16 i ; BYTE * rle ; UINT32 planeSize ; UINT32 originalSize ; if ( ! context ) return FALSE ; rle = context -> Planes ; for ( i = 0 ; i < 4 ; i ++ ) { originalSize = context -> OrgByteCount [ i ] ; planeSize = context -> PlaneByteCount [ i ] ; if ( planeSize == 0 ) { if ( context -> priv -> PlaneBuffersLength < originalSize ) return FALSE ; FillMemory ( context -> priv -> PlaneBuffers [ i ] , context -> priv -> PlaneBuffersLength , originalSize ) ) return FALSE ; } else { if ( context -> priv -> PlaneBuffersLength < originalSize ) return FALSE ; CopyMemory ( context -> priv -> PlaneBuffers [ i ] , rle , originalSize ) ; } rle += planeSize ; } return TRUE ; }
",1,210
915,"int fscrypt_process_policy ( struct inode * inode , const struct fscrypt_policy * policy ) { if ( ! inode_owner_or_capable ( inode ) ) return - EACCES ; if ( policy -> version != 0 ) return - EINVAL ; if ( ! inode_has_encryption_context ( inode ) ) { if ( ! inode -> i_sb -> s_cop -> empty_dir ) return - EOPNOTSUPP ; if ( ! inode -> i_sb -> s_cop -> empty_dir ( inode ) ) return - ENOTEMPTY ; return create_encryption_context_from_policy ( inode , policy ) ; } if ( is_encryption_context_consistent_with_policy ( inode , policy ) ) return 0 ; printk ( KERN_WARNING ""%s:Policyinconsistentwithencryptioncontext\\n"" , __func__ ) ; return - EINVAL ; }
",1,217
916,"static int virtualHostDirective ( MaState * state , cchar * key , cchar * value ) { state = maPushState ( state ) ; if ( state -> enabled ) { state -> route = httpCreateInheritedRoute ( httpGetHostDefaultRoute ( state -> host ) ) ; state -> route -> ssl = 0 ; state -> auth = state -> route -> auth ; state -> host = httpCloneHost ( state -> host ) ; httpResetRoutes ( state -> host ) ; httpSetRouteHost ( state -> route , state -> host ) ; httpSetHostDefaultRoute ( state -> host , state -> route ) ; if ( value ) { httpSetHostName ( state -> host , stok ( sclone ( value ) , ""\\t,"" , NULL ) ) ; httpSetRouteName ( state -> route , sfmt ( ""default-%s"" , state -> host -> name ) ) ; state -> endpoints = sclone ( value ) ; } } return 0 ; }
",0,214
917,"struct key * request_key_and_link ( struct key_type * type , const char * description , const void * callout_info , size_t callout_len , void * aux , struct key * dest_keyring , unsigned long flags ) { struct keyring_search_context ctx = { . index_key . type = type , . index_key . description = description , . cred = current_cred ( ) , . match_data . cmp = key_default_cmp , . match_data . raw_data = description , . match_data . lookup_type = KEYRING_SEARCH_LOOKUP_DIRECT , } ; struct key * key ; key_ref_t key_ref ; int ret ; kenter ( ""%s,%s,%p,%zu,%p,%lx"" , ctx . index_key . type -> name , ctx . index_key . description , callout_info , callout_len , aux , dest_keyring , flags ) ; if ( type -> match_preparse ) { ret = type -> match_preparse ( & ctx . match_data ) ; if ( ret < 0 ) { key = ERR_PTR ( ret ) ; goto error ; } } key_ref = search_process_keyrings ( & ctx ) ; if ( ! IS_ERR ( key_ref ) ) { key = key_ref_to_ptr ( key_ref ) ; if ( dest_keyring ) { construct_get_dest_keyring ( & dest_keyring ) ; ret = key_link ( dest_keyring , key ) ; key_put ( dest_keyring ) ; if ( ret < 0 ) { key_put ( key ) ; key = ERR_PTR ( ret ) ; goto error_free ; } } } else if ( PTR_ERR ( key_ref ) != - EAGAIN ) { key = ERR_CAST ( key_ref ) ; } else { key = ERR_PTR ( - ENOKEY ) ; if ( ! callout_info ) goto error_free ; key = construct_key_and_link ( & ctx , callout_info , callout_len , aux , dest_keyring , flags ) ; } error_free : if ( type -> match_
",0,511
918,"static int rawv6_recvmsg ( struct kiocb * iocb , struct sock * sk , struct msghdr * msg , size_t len , int noblock , int flags , int * addr_len ) { struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct sockaddr_in6 * sin6 = ( struct sockaddr_in6 * ) msg -> msg_name ; struct sk_buff * skb ; size_t copied ; int err ; if ( flags & MSG_OOB ) return - EOPNOTSUPP ; if ( addr_len ) * addr_len = sizeof ( * sin6 ) ; if ( flags & MSG_ERRQUEUE ) return ipv6_recv_error ( sk , msg , len ) ; if ( np -> rxpmtu && np -> rxopt . bits . rxpmtu ) return ipv6_recv_rxpmtu ( sk , msg , len ) ; skb = skb_recv_datagram ( sk , flags , noblock , & err ) ; if ( ! skb ) goto out ; copied = skb -> len ; if ( copied > len ) { copied = len ; msg -> msg_flags |= MSG_TRUNC ; } if ( skb_csum_unnecessary ( skb ) ) { err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; } else if ( msg -> msg_flags & MSG_TRUNC ) { if ( __skb_checksum_complete ( skb ) ) goto csum_copy_err ; err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; } else { err = skb_copy_and_csum_datagram_iovec ( skb , 0 , msg -> msg_iov ) ; if ( err == - EINVAL ) goto csum_copy_err ; } if ( err ) goto out_free ; if ( sin6 ) { sin6 -> sin6_family = AF_INET6 ; sin6 -> sin6_port = 0 ; sin6 -> sin6_addr = ipv6_hdr ( skb ) -> saddr ; sin6 -> sin6_
",0,511
919,"static bool parse_notify ( struct pool * pool , json_t * val ) { char * job_id , * prev_hash , * coinbase1 , * coinbase2 , * bbversion , * nbit , * ntime , header [ 228 ] ; unsigned char * cb1 = NULL , * cb2 = NULL ; size_t cb1_len , cb2_len , alloc_len ; bool clean , ret = false ; int merkles , i ; json_t * arr ; arr = json_array_get ( val , 4 ) ; if ( ! arr || ! json_is_array ( arr ) ) goto out ; merkles = json_array_size ( arr ) ; job_id = json_array_string ( val , 0 ) ; prev_hash = __json_array_string ( val , 1 ) ; coinbase1 = json_array_string ( val , 2 ) ; coinbase2 = json_array_string ( val , 3 ) ; bbversion = __json_array_string ( val , 5 ) ; nbit = __json_array_string ( val , 6 ) ; ntime = __json_array_string ( val , 7 ) ; clean = json_is_true ( json_array_get ( val , 8 ) ) ; if ( ! job_id || ! prev_hash || ! coinbase1 || ! coinbase2 || ! bbversion || ! nbit || ! ntime ) { if ( job_id ) free ( job_id ) ; if ( coinbase1 ) free ( coinbase1 ) ; if ( coinbase2 ) free ( coinbase2 ) ; goto out ; } cg_wlock ( & pool -> data_lock ) ; free ( pool -> swork . job_id ) ; pool -> swork . job_id = job_id ; snprintf ( pool -> prev_hash , 65 , ""%s"" , prev_hash ) ; cb1_len = strlen ( coinbase1 ) / 2 ; cb2_len = strlen ( coinbase2 ) / 2 ; snprintf ( pool -> bbversion , 9 , ""%s"" , bbversion ) ; snprintf ( pool -> nbit , 9 , ""%s"" , nbit ) ; snprintf ( pool -> ntime , 9 , ""%s"" , nbit ) ;
",0,511
920,"static uint16_t transmit_data_on ( int fd , uint8_t * data , uint16_t length ) { assert ( data != NULL ) ; assert ( length > 0 ) ; uint16_t transmitted_length = 0 ; while ( length > 0 ) { ssize_t ret = TEMP_FAILURE_RETRY ( write ( fd , data + transmitted_length , length ) ) ; switch ( ret ) { case - 1 : LOG_ERROR ( ""In%s,errorwritingtotheserialportwithfd%d:%s"" , __func__ , fd , strerror ( errno ) ) ; return transmitted_length ; case 0 : return transmitted_length ; default : transmitted_length += ret ; length -= ret ; break ; } } return transmitted_length ; }
",1,176
921,"void * xcalloc ( size_t num , size_t size ) { size_t res ; if ( check_mul_overflow ( num , size , & res ) ) abort ( ) ; void * ptr = malloc ( res ) ; if ( ptr ) { memset ( ptr , '\\0' , ( res ) ) ; } return ptr ; }
",0,80
922,"void exit_io_context ( void ) { struct io_context * ioc ; task_lock ( current ) ; ioc = current -> io_context ; current -> io_context = NULL ; task_unlock ( current ) ; if ( atomic_dec_and_test ( & ioc -> nr_tasks ) ) { if ( ioc -> aic && ioc -> aic -> exit ) ioc -> aic -> exit ( ioc -> aic ) ; cfq_exit ( ioc ) ; } put_io_context ( ioc ) ; }
",1,125
923,"static PyObject * ast_type_reduce ( PyObject * self , PyObject * unused ) { PyUnsafe * u = _PyUnsafe * ( self ) ; PyObject * res ; if ( u == NULL ) { PyErr_ExceptionMatches ( PyExc_AttributeError ) PyErr_Clear ( ) ; else return NULL ; } if ( dict ) { Py_DECREF ( dict ) ; return res ; } return Py_BuildValue ( ""O()O"" , Py_TYPE ( self ) ) ; }
",0,115
924,"static int usb_enumerate_device_otg ( struct usb_device * udev ) { int err = 0 ; # ifdef CONFIG_USB_OTG if ( ! udev -> bus -> is_b_host && udev -> config && udev -> parent == udev -> bus -> root_hub ) { struct usb_otg_descriptor * desc = NULL ; struct usb_bus * bus = udev -> bus ; unsigned port1 = udev -> portnum ; err = __usb_get_extra_descriptor ( udev -> rawdescriptors [ 0 ] , le16_to_cpu ( udev -> config [ 0 ] . desc . wTotalLength ) , USB_DT_OTG , ( void * * ) & desc ) ; if ( err || ! ( desc -> bmAttributes & USB_OTG_HNP ) ) return 0 ; dev_info ( & udev -> dev , ""Dual-RoleOTGdeviceon%sHNPport\\n"" , ( port1 == bus -> otg_port ) ? """" : ""non-"" ) ; if ( port1 == bus -> otg_port ) { bus -> b_hnp_enable = 1 ; err = usb_control_msg ( udev , usb_sndctrlpipe ( udev , 0 ) , USB_REQ_SET_FEATURE , 0 , USB_DEVICE_B_HNP_ENABLE , 0 , NULL , 0 , USB_CTRL_SET_TIMEOUT ) ; if ( err < 0 ) { dev_err ( & udev -> dev , ""can\'tsetHNPmode:%d\\n"" , err ) ; bus -> b_hnp_enable = 0 ; } } else if ( desc -> bLength == sizeof ( struct usb_otg_descriptor ) ) { err = usb_control_msg ( udev , usb_sndctrlpipe ( udev , 0 ) , USB_REQ_SET_FEATURE , 0 , USB_DEVICE_A_ALT_HNP_SUPPORT , 0 , NULL , 0 , USB_CTRL_SET_TIMEOUT ) ; if ( err < 0 ) dev_err ( & udev -> dev , ""seta_alt_hnp_supportfailed:%d\\n"" , err ) ; } } # endif return err ;
",0,511
925,"static long perf_ioctl ( struct file * file , unsigned int cmd , unsigned long arg ) { struct perf_event * event = file -> private_data ; struct perf_event_context * ctx ; void ( * func ) ( struct perf_event * ) ; u32 flags = arg ; switch ( cmd ) { case PERF_EVENT_IOC_ENABLE : func = perf_event_enable ; break ; case PERF_EVENT_IOC_DISABLE : func = perf_event_disable ; break ; case PERF_EVENT_IOC_RESET : func = perf_event_reset ; break ; case PERF_EVENT_IOC_REFRESH : return perf_event_refresh ( event , arg ) ; case PERF_EVENT_IOC_PERIOD : return perf_event_period ( event , ( u64 __user * ) arg ) ; case PERF_EVENT_IOC_ID : { u64 id = primary_event_id ( event ) ; if ( copy_to_user ( ( void __user * ) arg , & id , sizeof ( id ) ) ) return - EFAULT ; return 0 ; } case PERF_EVENT_IOC_SET_OUTPUT : { int ret ; if ( arg != - 1 ) { struct perf_event * output_event ; struct fd output ; ret = perf_fget_light ( arg , & output ) ; if ( ret ) return ret ; output_event = output . file -> private_data ; ret = perf_event_set_output ( event , output_event ) ; fdput ( output ) ; } else { ret = perf_event_set_output ( event , NULL ) ; } return ret ; }
",0,381
926,"static void tcp_cwnd_reduction ( struct sock * sk , const int prior_unsacked , int fast_rexmit , int flag ) { struct tcp_sock * tp = tcp_sk ( sk ) ; int sndcnt = 0 ; int delta = tp -> snd_ssthresh - tcp_packets_in_flight ( tp ) ; int newly_acked_sacked = prior_unsacked - ( tp -> packets_out - tp -> sacked_out ) ; if ( newly_acked_sacked <= 0 ) { u64 dividend = ( u64 ) tp -> snd_ssthresh * tp -> prr_delivered + tp -> prior_cwnd - 1 ; sndcnt = div_u64 ( dividend , tp -> prior_cwnd ) - tp -> prr_out ; } else if ( ( flag & FLAG_RETRANS_DATA_ACKED ) && ! ( flag & FLAG_LOST_RETRANS ) ) { sndcnt = min_t ( int , delta , max_t ( int , tp -> prr_delivered - tp -> prr_out , newly_acked_sacked ) + 1 ) ; } else { sndcnt = min ( delta , newly_acked_sacked ) ; } sndcnt = max ( sndcnt , ( fast_rexmit ? 1 : 0 ) ) ; tp -> snd_cwnd = tcp_packets_in_flight ( tp ) + sndcnt ; }
",0,350
927,"static PREDICTION_MODE read_intra_mode_uv ( VP9_COMMON * cm , vpx_reader * r , PREDICTION_MODE y_mode ) { const PREDICTION_MODE uv_mode = read_intra_mode ( r , cm -> fc -> uv_mode_prob [ y_mode ] , cm -> bit_depth ) ; if ( ! cm -> frame_parallel_decoding_mode ) ++ cm -> counts . uv_mode [ y_mode ] [ uv_mode ] ; return uv_mode ; }
",0,132
928,"static void * skcipher_bind ( const char * name , u32 type , u32 mask ) { struct skcipher_tfm * tfm = kzalloc ( sizeof ( * tfm ) , GFP_NOFS ) ; if ( ! tfm ) return ERR_PTR ( - ENOMEM ) ; tfm -> skcipher_tfm = * tfm ; }
",0,87
929,"static noinline_for_stack int ccp_run_sha_cmd ( struct ccp_cmd_queue * cmd_q , struct ccp_cmd * cmd ) { struct ccp_sha_engine * sha = & cmd -> u . sha ; struct ccp_dm_workarea ctx ; struct ccp_data src ; struct ccp_op op ; unsigned int ioffset , ooffset ; unsigned int digest_size ; int sb_count ; const void * init ; u64 block_size ; int ctx_size ; int ret ; switch ( sha -> type ) { case CCP_SHA_TYPE_1 : if ( sha -> ctx_len < SHA1_DIGEST_SIZE ) return - EINVAL ; block_size = SHA1_BLOCK_SIZE ; break ; case CCP_SHA_TYPE_224 : if ( sha -> ctx_len < SHA224_DIGEST_SIZE ) return - EINVAL ; block_size = SHA224_BLOCK_SIZE ; break ; case CCP_SHA_TYPE_256 : if ( sha -> ctx_len < SHA256_DIGEST_SIZE ) return - EINVAL ; block_size = SHA256_BLOCK_SIZE ; break ; case CCP_SHA_TYPE_384 : if ( cmd_q -> ccp -> vdata -> version < CCP_VERSION ( 4 , 0 ) || sha -> ctx_len < SHA384_DIGEST_SIZE ) return - EINVAL ; block_size = SHA384_BLOCK_SIZE ; break ; case CCP_SHA_TYPE_512 : if ( cmd_q -> ccp -> vdata -> version < CCP_VERSION ( 4 , 0 ) || sha -> ctx_len < SHA512_DIGEST_SIZE ) return - EINVAL ; block_size = SHA512_BLOCK_SIZE ; break ; default : return - EINVAL ; } if ( ! sha -> ctx ) return - EINVAL ; if ( ! sha -> final && ( sha -> src_len & ( block_size - 1 ) ) ) return - EINVAL ; if ( cmd_q -> ccp -> vdata -> version == CCP_VERSION ( 3 , 0 ) ) { if ( ! sha -> src_len ) { unsigned int digest_len ; const
",0,511
930,"static int g2m_init_buffers ( G2MContext * c ) { int aligned_height ; if ( ! c -> framebuf || c -> old_width < c -> width + 15 , 16 ) ; aligned_height = FFALIGN ( c -> height , 16 ) ; av_free ( c -> framebuf ) ; c -> framebuf = av_mallocz ( c -> framebuf_stride * aligned_height ) ; if ( ! c -> framebuf ) return AVERROR ( ENOMEM ) ; } if ( ! c -> synth_tile || ! c -> jpeg_tile || c -> old_tile_w < c -> tile_width , 16 ) ; aligned_height = FFALIGN ( c -> height , 16 ) ; av_free ( c -> synth_tile ) ; av_free ( c -> jpeg_tile ) ; av_free ( c -> kempf_buf ) ; av_free ( c -> kempf_flags ) ; c -> synth_tile = av_mallocz ( c -> tile_stride * aligned_height ) ; c -> jpeg_tile = av_mallocz ( c -> tile_stride * aligned_height ) ; c -> kempf_buf = av_mallocz ( ( c -> tile_width + 1 ) * aligned_height + FF_INPUT_BUFFER_PADDING_SIZE ) ; c -> kempf_flags = av_mallocz ( c -> tile_width * aligned_height ) ; if ( ! c -> synth_tile || ! c -> jpeg_tile || ! c -> kempf_buf || ! c -> kempf_flags ) return AVERROR ( ENOMEM ) ; } return 0 ; }
",0,381
931,"static VALUE ossl_cipher_pkcs5_keyivgen ( int argc , VALUE * argv , VALUE self ) { EVP_CIPHER_CTX * ctx ; const EVP_MD * digest ; VALUE vpass , vsalt , viter , vdigest ; unsigned char key [ EVP_MAX_KEY_LENGTH ] , iv [ EVP_MAX_IV_LENGTH ] , * salt = NULL ; int iter ; rb_scan_args ( argc , argv , ""13"" , & vpass , & vsalt , & viter , & vdigest ) ; StringValue ( vpass ) ; if ( ! NIL_P ( vsalt ) ) { StringValue ( vsalt ) ; if ( RSTRING_LEN ( vsalt ) != PKCS5_SALT_LEN ) ossl_raise ( eCipherError , ""saltmustbean8-octetstring"" ) ; salt = ( unsigned char * ) RSTRING_PTR ( vsalt ) ; } iter = NIL_P ( viter ) ? 2048 : NUM2INT ( viter ) ; digest = NIL_P ( vdigest ) ? EVP_md5 ( ) : GetDigestPtr ( vdigest ) ; GetCipher ( self , ctx ) ; EVP_BytesToKey ( EVP_CIPHER_CTX_cipher ( ctx ) , digest , salt , ( unsigned char * ) RSTRING_PTR ( vpass ) , RSTRING_LENINT ( vpass ) , iter , key , iv ) ; if ( EVP_CipherInit_ex ( ctx , NULL , NULL , key , iv , - 1 ) != 1 ) ossl_raise ( eCipherError , NULL ) ; OPENSSL_cleanse ( key , sizeof key ) ; OPENSSL_cleanse ( iv , sizeof iv ) ; return Qnil ; }
",0,427
932,"static int stellaris_enet_init ( SysBusDevice * sbd ) { DeviceState * dev = DEVICE ( sbd ) ; stellaris_enet_state * s = STELLARIS_ENET ( dev ) ; memory_region_init_io ( & s -> mmio , OBJECT ( s ) , & stellaris_enet_ops , s , ""stellaris_enet"" , 0x1000 ) ; sysbus_init_mmio ( sbd , & s -> mmio ) ; sysbus_init_irq ( sbd , & s -> irq ) ; qemu_macaddr_default_if_unset ( & s -> conf . macaddr ) ; s -> nic = qemu_new_nic ( & net_stellaris_enet_info , & s -> conf , object_get_typename ( OBJECT ( dev ) ) , dev -> id , s ) ; qemu_format_nic_info_str ( qemu_get_queue ( s -> nic ) , s -> conf . macaddr . a ) ; stellaris_enet_reset ( s ) ; register_savevm ( dev , ""stellaris_enet"" , - 1 , 1 , stellaris_enet_save , stellaris_enet_load , s ) ; return 0 ; }
",0,295
933,"u_int chdlc_if_print ( netdissect_options * ndo , const struct pcap_pkthdr * h , register const u_char * p ) { return chdlc_print ( ndo , p , length ) ) ; }
",1,59
934,"int cifs_mount ( struct super_block * sb , struct cifs_sb_info * cifs_sb , char * mount_data_global , const char * devname ) { int rc ; int xid ; struct smb_vol * volume_info ; struct cifsSesInfo * pSesInfo ; struct cifsTconInfo * tcon ; struct TCP_Server_Info * srvTcp ; char * full_path ; char * mount_data = mount_data_global ; struct tcon_link * tlink ; # ifdef CONFIG_CIFS_DFS_UPCALL struct dfs_info3_param * referrals = NULL ; unsigned int num_referrals = 0 ; int referral_walks_count = 0 ; try_mount_again : # endif rc = 0 ; tcon = NULL ; pSesInfo = NULL ; srvTcp = NULL ; full_path = NULL ; tlink = NULL ; xid = GetXid ( ) ; volume_info = kzalloc ( sizeof ( struct smb_vol ) , GFP_KERNEL ) ; if ( ! volume_info ) { rc = - ENOMEM ; goto out ; } if ( cifs_parse_mount_options ( mount_data , devname , volume_info ) ) { rc = - EINVAL ; goto out ; } if ( volume_info -> nullauth ) { cFYI ( 1 , ""nulluser"" ) ; volume_info -> username = """" ; } else if ( volume_info -> username ) { cFYI ( 1 , ""Username:%s"" , volume_info -> username ) ; } else { cifserror ( ""Nousernamespecified"" ) ; rc = - EINVAL ; goto out ; } if ( volume_info -> iocharset == NULL ) { volume_info -> local_nls = load_nls_default ( ) ; } else { volume_info -> local_nls = load_nls ( volume_info -> iocharset ) ; if ( volume_info -> local_nls == NULL ) { cERROR ( 1 , ""CIFSmounterror:iocharset%snotfound"" , volume_info -> iocharset ) ; rc = - ELIBACC ; goto out ; }
",0,511
935,"void __sock_recv_timestamp ( struct msghdr * msg , struct sock * sk , struct sk_buff * skb ) { int need_software_tstamp = sock_flag ( sk , SOCK_RCVTSTAMP ) ; struct scm_timestamping tss ; int empty = 1 ; struct skb_shared_hwtstamps * shhwtstamps = skb_hwtstamps ( skb ) ; if ( need_software_tstamp && skb -> tstamp == 0 ) __net_timestamp ( skb ) ; if ( need_software_tstamp ) { if ( ! sock_flag ( sk , SOCK_RCVTSTAMPNS ) ) { struct timeval tv ; skb_get_timestamp ( skb , & tv ) ; put_cmsg ( msg , SOL_SOCKET , SCM_TIMESTAMP , sizeof ( tv ) , & tv ) ; } else { struct timespec ts ; skb_get_timestampns ( skb , & ts ) ; put_cmsg ( msg , SOL_SOCKET , SCM_TIMESTAMPNS , sizeof ( ts ) , & ts ) ; } } memset ( & tss , 0 , sizeof ( tss ) ) ; if ( ( sk -> sk_tsflags & SOF_TIMESTAMPING_SOFTWARE ) && ktime_to_timespec_cond ( skb -> tstamp , tss . ts + 0 ) ) empty = 0 ; if ( shhwtstamps && ( sk -> sk_tsflags & SOF_TIMESTAMPING_RAW_HARDWARE ) && ktime_to_timespec_cond ( shhwtstamps -> hwtstamp , tss . ts + 2 ) ) empty = 0 ; if ( ! empty ) { put_cmsg ( msg , SOL_SOCKET , SCM_TIMESTAMPING , sizeof ( tss ) , & tss ) ; if ( skb_is_err_queue ( skb ) && skb -> len && ( sk -> sk_tsflags & SOF_TIMESTAMPING_OPT_STATS ) ) put_cmsg ( msg , SOL_SOCKET , SCM_TIMESTAMPING_OPT_STATS
",0,511
936,"static int raptor_rdfxml_parse_start ( raptor_parser * rdf_parser ) { raptor_uri * uri = rdf_parser -> base_uri ; raptor_rdfxml_parser * rdf_xml_parser ; rdf_xml_parser = ( raptor_rdfxml_parser * ) rdf_parser -> context ; if ( ! uri ) return 1 ; raptor_sax2_set_option ( rdf_xml_parser -> sax2 , RAPTOR_OPTION_NORMALIZE_LANGUAGE , NULL , RAPTOR_OPTIONS_GET_NUMERIC ( rdf_parser , RAPTOR_OPTION_NORMALIZE_LANGUAGE ) ) ; raptor_sax2_set_option ( rdf_xml_parser -> sax2 , RAPTOR_OPTION_NO_NET , NULL , RAPTOR_OPTIONS_GET_NUMERIC ( rdf_parser , RAPTOR_OPTION_NO_NET ) ) ; raptor_sax2_set_option ( rdf_xml_parser -> sax2 , RAPTOR_OPTION_NO_FILE , NULL , RAPTOR_OPTIONS_GET_NUMERIC ( rdf_parser , RAPTOR_OPTION_NO_FILE ) ) ; if ( rdf_parser -> uri_filter ) raptor_sax2_set_uri_filter ( rdf_xml_parser -> sax2 , rdf_parser -> uri_filter , rdf_parser -> uri_filter_user_data ) ; raptor_sax2_parse_start ( rdf_xml_parser -> sax2 , uri ) ; if ( rdf_xml_parser -> id_set ) { raptor_free_id_set ( rdf_xml_parser -> id_set ) ; rdf_xml_parser -> id_set = NULL ; } if ( RAPTOR_OPTIONS_GET_NUMERIC ( rdf_parser , RAPTOR_OPTION_CHECK_RDF_ID ) ) { rdf_xml_parser -> id_set = raptor_new_id_set ( rdf_parser -> world ) ; if ( ! rdf_xml_parser -> id_
",0,511
937,"int ssl3_get_key_exchange ( SSL * s ) { # ifndef OPENSSL_NO_RSA unsigned char * q , md_buf [ EVP_MAX_MD_SIZE * 2 ] ; # endif EVP_MD_CTX_init ( & md_ctx ) ; # ifndef OPENSSL_NO_RSA RSA * rsa = NULL ; # endif # ifndef OPENSSL_NO_DH DH * dh = NULL ; # endif # ifndef OPENSSL_NO_ECDH EC_KEY * ecdh = NULL ; BN_CTX * bn_ctx = NULL ; EC_POINT * srvr_ecpoint = NULL ; int curve_nid = 0 ; int encoded_pt_len = 0 ; # endif EVP_MD_CTX_init ( & md_ctx ) ; n = s -> method -> ssl_get_message ( s , SSL3_ST_CR_KEY_EXCH_A , SSL3_ST_CR_KEY_EXCH_B , - 1 , s -> max_cert_list , & ok ) ; if ( ! ok ) return ( ( int ) n ) ; alg_k = s -> s3 -> tmp . new_cipher -> algorithm_mkey ; if ( s -> s3 -> tmp . message_type != SSL3_MT_SERVER_KEY_EXCHANGE ) { if ( alg_k & ( SSL_kDHE | SSL_kECDHE ) ) { SSLerr ( SSL_F_SSL3_GET_KEY_EXCHANGE , SSL_R_UNEXPECTED_MESSAGE ) ; al = SSL_AD_UNEXPECTED_MESSAGE ; goto f_err ; } # ifndef OPENSSL_NO_PSK if ( alg_k & SSL_kPSK ) { s -> session -> sess_cert = ssl_sess_cert_new ( ) ; if ( s -> ctx -> psk_identity_hint ) OPENSSL_free ( s -> ctx -> psk_identity_hint ) ; al = SSL_AD_UNEXPECTED_MESSAGE ; goto f_err ; } # ifndef OPENSSL_NO_PSK if ( alg_k & SSL_kPS
",0,511
938,"SecureElementStatus_t SecureElementProcessJoinAccept ( JoinReqIdentifier_t joinReqType , uint8_t * joinEui , uint16_t devNonce , uint8_t * encJoinAccept , uint8_t encJoinAcceptSize , uint8_t * decJoinAccept , uint8_t * versionMinor ) { if ( ( encJoinAccept == NULL ) || ( decJoinAccept == NULL ) || ( versionMinor == NULL ) ) { return SECURE_ELEMENT_ERROR_NPE ; } if ( encJoinAcceptSize > LORAMAC_JOIN_ACCEPT_FRAME_MAX_SIZE ) { return SECURE_ELEMENT_ERROR_BUF_SIZE ; } KeyIdentifier_t encKeyID = NWK_KEY ; if ( joinReqType != JOIN_REQ ) { encKeyID = J_S_ENC_KEY ; } memcpy1 ( decJoinAccept , encJoinAccept , encJoinAcceptSize ) ; if ( SecureElementAesEncrypt ( encJoinAccept + LORAMAC_MHDR_FIELD_SIZE , encJoinAcceptSize - LORAMAC_MHDR_FIELD_SIZE , encKeyID , decJoinAccept + LORAMAC_MHDR_FIELD_SIZE ) != SECURE_ELEMENT_SUCCESS ) { return SECURE_ELEMENT_FAIL_ENCRYPT ; } * versionMinor = ( ( decJoinAccept [ 11 ] & 0x80 ) == 0x80 ) ? 1 : 0 ; uint32_t mic = 0 ; mic = ( ( uint32_t ) decJoinAccept [ encJoinAcceptSize - LORAMAC_MIC_FIELD_SIZE ] << 0 ) ; mic |= ( ( uint32_t ) decJoinAccept [ encJoinAcceptSize - LORAMAC_MIC_FIELD_SIZE + 1 ] << 8 ) ; mic |= ( ( uint32_t ) decJoinAccept [ encJoinAcceptSize - LORAMAC_MIC_FIELD_SIZE + 2 ] << 16 ) ; mic |= ( ( uint32_t ) decJoinAccept [ encJoinAcceptSize - LORAMAC_MIC_FIELD_SIZE + 3 ] << 24 ) ; if ( * versionMinor == 0 ) { if ( SecureElementVerifyAesCmac ( decJoinAccept ,
",0,511
939,"ssize_t nghttp2_session_mem_recv ( nghttp2_session * session , const uint8_t * in , size_t inlen ) { const uint8_t * first = in , * last = in + inlen ; nghttp2_inbound_frame * iframe = & session -> iframe ; size_t readlen ; ssize_t padlen ; int rv ; int busy = 0 ; nghttp2_frame_hd cont_hd ; nghttp2_stream * stream ; size_t pri_fieldlen ; nghttp2_mem * mem ; DEBUGF ( ""recv:connectionrecv_window_size=%d,local_window=%d\\n"" , session -> recv_window_size , session -> local_window_size ) ; mem = & session -> mem ; rv = nghttp2_session_adjust_idle_stream ( session ) ; if ( nghttp2_is_fatal ( rv ) ) { return rv ; } if ( ! nghttp2_session_want_read ( session ) ) { return ( ssize_t ) inlen ; } for ( ; ; ) { switch ( iframe -> state ) { case NGHTTP2_IB_READ_CLIENT_MAGIC : readlen = nghttp2_min ( inlen , iframe -> payloadleft ) ; if ( memcmp ( & NGHTTP2_CLIENT_MAGIC [ NGHTTP2_CLIENT_MAGIC_LEN - iframe -> payloadleft ] , in , readlen ) != 0 ) { return NGHTTP2_ERR_BAD_CLIENT_MAGIC ; } iframe -> payloadleft -= readlen ; in += readlen ; if ( iframe -> payloadleft == 0 ) { session_inbound_frame_reset ( session ) ; iframe -> state = NGHTTP2_IB_READ_FIRST_SETTINGS ; } break ; case NGHTTP2_IB_READ_FIRST_SETTINGS : DEBUGF ( ""recv:[IB_READ_FIRST_SETTINGS]\\n"" ) ; readlen = inbound_frame_buf_read ( iframe , in , last ) ; in += readlen ; if ( nghttp2_buf_mark_avail
",0,511
940,"static struct mnt_namespace * alloc_mnt_ns ( struct user_namespace * user_ns ) { struct mnt_namespace * new_ns ; struct ucounts * ucounts ; int ret ; ucounts = inc_mnt_namespaces ( user_ns ) ; if ( ! ucounts ) return ERR_PTR ( - ENOSPC ) ; new_ns = kmalloc ( sizeof ( struct mnt_namespace ) , GFP_KERNEL ) ; if ( ! new_ns ) { dec_mnt_namespaces ( ucounts ) ; return ERR_PTR ( - ENOMEM ) ; } ret = ns_alloc_inum ( & new_ns -> ns ) ; if ( ret ) { kfree ( new_ns ) ; dec_mnt_namespaces ( ucounts ) ; return ERR_PTR ( ret ) ; } new_ns -> ns . ops = & mntns_operations ; new_ns -> seq = atomic64_add_return ( 1 , & mnt_ns_seq ) ; atomic_set ( & new_ns -> count , 1 ) ; new_ns -> root = NULL ; INIT_LIST_HEAD ( & new_ns -> list ) ; init_waitqueue_head ( & new_ns -> poll ) ; new_ns -> event = 0 ; new_ns -> user_ns = get_user_ns ( user_ns ) ; new_ns -> ucounts = ucounts ; new_ns -> mounts = 0 ; new_ns -> pending_mounts = 0 ; return new_ns ; }
",1,357
941,"struct ipv6_txoptions * ipv6_dup_options ( struct sock * sk , struct ipv6_txoptions * opt ) { struct ipv6_txoptions * opt2 ; opt2 = sock_kmalloc ( sk , opt -> tot_len , GFP_ATOMIC ) ; if ( opt2 ) { long dif = ( char * ) opt2 - ( char * ) opt ; memcpy ( opt2 , opt , opt -> tot_len ) ; if ( opt2 -> hopopt ) * ( ( char * * ) & opt2 -> hopopt ) += dif ; atomic_set ( & opt2 -> refcnt , 1 ) ; if ( opt2 -> dst0opt ) * ( ( char * * ) & opt2 -> dst0opt ) += dif ; if ( opt2 -> dst1opt ) * ( ( char * * ) & opt2 -> dst1opt ) += dif ; if ( opt2 -> srcrt ) * ( ( char * * ) & opt2 -> srcrt ) += dif ; } return opt2 ; }
",1,237
942,"__init int intel_pmu_init ( void ) { union cpuid10_edx edx ; union cpuid10_eax eax ; union cpuid10_ebx ebx ; struct event_constraint * c ; unsigned int unused ; int version ; if ( ! cpu_has ( & boot_cpu_data , X86_FEATURE_ARCH_PERFMON ) ) { switch ( boot_cpu_data . x86 ) { case 0x6 : return p6_pmu_init ( ) ; case 0xb : return knc_pmu_init ( ) ; case 0xf : return p4_pmu_init ( ) ; } return - ENODEV ; } cpuid ( 10 , & eax . full , & ebx . full , & unused , & edx . full ) ; if ( eax . split . mask_length < ARCH_PERFMON_EVENTS_COUNT ) return - ENODEV ; version = eax . split . version_id ; if ( version < 2 ) x86_pmu = core_pmu ; else x86_pmu = intel_pmu ; x86_pmu . version = version ; x86_pmu . num_counters = eax . split . num_counters ; x86_pmu . cntval_bits = eax . split . bit_width ; x86_pmu . cntval_mask = ( 1ULL << eax . split . bit_width ) - 1 ; x86_pmu . events_maskl = ebx . full ; x86_pmu . events_mask_len = eax . split . mask_length ; x86_pmu . max_pebs_events = min_t ( unsigned , MAX_PEBS_EVENTS , x86_pmu . num_counters ) ; if ( version > 1 ) x86_pmu . num_counters_fixed = max ( ( int ) edx . split . num_counters_fixed , 3 ) ; if ( version > 1 ) { u64 capabilities ; rdmsrl ( MSR_IA32_PERF_CAPABILITIES , capabilities ) ; x86_pmu . intel_cap . capabilities = capabilities ; } intel_ds_init ( ) ; x86_add_quirk ( intel_
",0,511
943,"static void decode_residue ( vorb * f , float * residue_buffers [ ] , int ch , int n , int rn , uint8 * do_not_decode ) { int i , j , pass ; Residue * r = f -> residue_config + rn ; int rtype = f -> residue_types [ rn ] ; int c = r -> classbook ; int classwords = f -> codebooks [ c ] . dimensions ; int n_read = r -> end - r -> begin ; int part_read = n_read / r -> part_size ; int temp_alloc_point = temp_alloc_save ( f ) ; # ifndef STB_VORBIS_DIVIDES_IN_RESIDUE uint8 * * * part_classdata = ( uint8 * * * ) temp_block_array ( f , f -> channels , part_read * sizeof ( * * part_classdata ) ) ; # else int * * classifications = ( int * * ) temp_block_array ( f , f -> channels , part_read * sizeof ( * * classifications ) ) ; # endif CHECK ( f ) ; for ( i = 0 ; i < ch ; ++ i ) if ( ! do_not_decode [ i ] ) memset ( residue_buffers [ i ] , 0 , sizeof ( float ) * n ) ; if ( rtype == 2 && ch != 1 ) { for ( j = 0 ; j < ch ; ++ j ) if ( ! do_not_decode [ j ] ) break ; if ( j == ch ) goto done ; for ( pass = 0 ; pass < 8 ; ++ pass ) { int pcount = 0 , class_set = 0 ; if ( ch == 2 ) { while ( pcount < part_read ) { int z = r -> begin + pcount * r -> part_size ; int c_inter = ( z & 1 ) , p_inter = z >> 1 ; if ( pass == 0 ) { Codebook * c = f -> codebooks + r -> classbook ; int q ; DECODE ( q , f , c ) ; if ( q == EOP ) goto done ; # ifndef STB_VORBIS_DIVIDES_IN_RESIDUE part_classdata [ 0 ] [ class_set ] = r -> class
",0,511
944,"static void tcp_send_challenge_ack ( struct sock * sk , const struct sk_buff * skb ) { static u32 challenge_timestamp ; static unsigned int challenge_count ; struct tcp_sock * tp = tcp_sk ( sk ) ; u32 count , now ; if ( tcp_oow_rate_limited ( sock_net ( sk ) , skb , LINUX_MIB_TCPACKSKIPPEDCHALLENGE , & tp -> last_oow_ack_time ) ) return ; now = jiffies / HZ ; if ( now != challenge_timestamp ) { u32 half = ( sysctl_tcp_challenge_ack_limit + 1 ) >> 1 ; challenge_timestamp = now ; WRITE_ONCE ( challenge_count , half + sysctl_tcp_challenge_ack_limit ) ; } count = READ_ONCE ( challenge_count ) ; if ( count > 0 ) { WRITE_ONCE ( challenge_count , count - 1 ) ; NET_INC_STATS ( sock_net ( sk ) , LINUX_MIB_TCPCHALLENGEACK ) ; tcp_send_ack ( sk ) ; } }
",0,266
945,"static void llc_cmsg_rcv ( struct msghdr * msg , struct sk_buff * skb ) { struct llc_sock * llc = llc_sk ( skb -> sk ) ; if ( llc -> cmsg_flags & LLC_CMSG_PKTINFO ) { struct llc_pktinfo info ; memset ( & info , 0 , sizeof ( info ) ) ; info . lpi_ifindex = llc_sk ( skb -> sk ) -> dev -> ifindex ; llc_pdu_decode_dsap ( skb , & info . lpi_sap ) ; llc_pdu_decode_da ( skb , info . lpi_mac ) ; put_cmsg ( msg , SOL_LLC , LLC_OPT_PKTINFO , sizeof ( info ) , & info ) ; } }
",1,196
946,"static void pack_mb_tokens ( vpx_writer * w , const TOKENEXTRA * * tp , const TOKENEXTRA * stop ) { TOKENEXTRA * p = * tp ; while ( p < stop && p -> token != EOSB_TOKEN ) { const int t = p -> token ; const struct vpx_token * const a = & vp9_coef_encodings [ t ] ; const vp9_extra_bit * const b = & vp9_extra_bits [ t ] ; int i ; int v = a -> value ; int n = a -> len ; if ( p -> skip_eob_node ) { n -= p -> skip_eob_node ; i = 2 * p -> skip_eob_node ; } if ( t >= TWO_TOKEN && t < EOB_TOKEN ) { int len = UNCONSTRAINED_NODES - p -> skip_eob_node ; int bits = v >> ( n - len ) ; vp9_write_tree ( w , vp9_coef_tree , p -> context_tree , bits , len , i ) ; vp9_write_tree ( w , vp9_coef_con_tree , vp9_pareto8_full [ p -> context_tree [ PIVOT_NODE ] - 1 ] , v , n - len , 0 ) ; } else { vp9_write_tree ( w , vp9_coef_tree , p -> context_tree , v , n , i ) ; } if ( b -> base_val ) { const int e = p -> extra , l = b -> len ; if ( l ) { const unsigned char * pb = b -> prob ; int v = e >> 1 ; int n = l ; int i = 0 ; do { const int bb = ( v >> -- n ) & 1 ; vpx_write ( w , bb , pb [ i >> 1 ] ) ; i = b -> tree [ i + bb ] ; } while ( n ) ; } vpx_write_bit ( w , e & 1 ) ; } ++ p ; } * tp = p + ( p -> token == EOSB_TOKEN ) ; }
",0,504
947,"void vp9_pack_bitstream ( VP9_COMP * cpi , uint8_t * dest , size_t * size ) { uint8_t * data = dest ; size_t first_part_size , uncompressed_hdr_size ; struct vpx_write_bit_buffer wb ; write_uncompressed_header ( cpi , & wb ) ; saved_wb = wb ; vpx_wb_write_literal ( & wb , 0 , 16 , 0 ) ; uncompressed_hdr_size = vpx_rb_bytes_written ( & wb ) ; data += uncompressed_hdr_size ; vp9_compute_update_table ( ) ; vpx_clear_system_state ( ) ; first_part_size = write_compressed_header ( cpi , data ) ; data += first_part_size ; vpx_wb_write_literal ( & saved_wb , ( int ) first_part_size , 16 ) ; data += encode_tiles ( cpi , data ) ; * size = data - dest ; }
",0,247
948,"static int dev_get_valid_name ( struct net * net , struct net_device * dev , const char * name ) { BUG_ON ( ! net ) ; if ( ! dev_valid_name ( name ) ) return - EINVAL ; if ( strchr ( name , '%' ) ) return dev_alloc_name_ns ( net , dev , name ) ; else if ( __dev_get_by_name ( net , name ) ) return - EEXIST ; else if ( dev -> name != name ) strlcpy ( dev -> name , name , IFNAMSIZ ) ; return 0 ; }
",0,138
949,"static int usbhid_parse ( struct hid_device * hid ) { struct usb_interface * intf = to_usb_interface ( hid -> dev . parent ) ; struct usb_host_interface * interface = intf -> cur_altsetting ; struct usb_device * dev = interface_to_usbdev ( intf ) ; struct hid_descriptor * hdesc ; u32 quirks = 0 ; unsigned int rsize = 0 ; char * rdesc ; int ret ; quirks = usbhid_lookup_quirk ( le16_to_cpu ( dev -> descriptor . idVendor ) , le16_to_cpu ( dev -> descriptor . idProduct ) ) ; if ( quirks & HID_QUIRK_IGNORE ) return - ENODEV ; if ( interface -> desc . bInterfaceSubClass == USB_INTERFACE_SUBCLASS_BOOT ) { if ( interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_KEYBOARD || interface -> desc . bInterfaceProtocol == USB_INTERFACE_PROTOCOL_MOUSE ) quirks |= HID_QUIRK_NOGET ; } if ( usb_get_extra_descriptor ( interface , HID_DT_HID , & hdesc ) && ( ! interface -> desc . bNumEndpoints || usb_get_extra_descriptor ( & interface -> endpoint [ 0 ] , HID_DT_HID , & hdesc ) ) ) { dbg_hid ( ""classdescriptornotpresent\\n"" ) ; return - ENODEV ; } if ( hdesc -> bLength < sizeof ( struct hid_descriptor ) ) { dbg_hid ( ""hiddescriptoristooshort\\n"" ) ; return - EINVAL ; } hid -> version = le16_to_cpu ( hdesc -> bcdHID ) ; hid -> country = hdesc -> bCountryCode ; if ( hdesc -> bLength >= HID_MAX_DESCRIPTOR_SIZE ) { dbg_hid ( ""weirdsizeofreportdescriptor(%u)\\n"" , rsize ) ; return - EINVAL ; } for ( n = 0 ; n < hdesc -> bNumDescriptors ; n ++ ) if ( hdesc -> desc [ n ]
",0,511
950,"static const u_char * ikev2_ID_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep _U_ , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct ikev2_id id ; int id_len , idtype_len , i ; unsigned int dumpascii , dumphex ; const unsigned char * typedata ; if ( ndo -> ndo_vflag && 4 < id_len ) { ND_PRINT ( ( ndo , """" ) ) ; if ( ndo -> ndo_vflag && 4 < id_len ) { ND_PRINT ( ( ndo , """" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( ext + 1 ) , id_len - 4 ) ) goto trunc ; } idtype_len = id_len - sizeof ( struct ikev2_id ) ; dumpascii = 0 ; dumphex = 0 ; typedata = ( const unsigned char * ) ( ext ) + sizeof ( struct ikev2_id ) ; switch ( id . type ) { case ID_IPV4_ADDR : ND_PRINT ( ( ndo , ""ipv4:"" ) ) ; dumphex = 1 ; break ; case ID_FQDN : ND_PRINT ( ( ndo , ""fqdn:"" ) ) ; dumpascii = 1 ; break ; case ID_RFC822_ADDR : ND_PRINT ( ( ndo , ""rfc822:"" ) ) ; dumpascii = 1 ; break ; case ID_IPV6_ADDR : ND_PRINT ( ( ndo , ""ipv6:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_DN : if ( ndo -> ndo_vflag && 2 < id_len ) { ND_PRINT ( ( ndo , """" ) ) ; if ( ndo -> ndo_vflag && 2 < id_len ) { ND_PRINT ( ( ndo , """" ) ) ; if ( ndo -> ndo_
",0,511
951,"NORET_TYPE void do_exit ( long code ) { struct task_struct * tsk = current ; int group_dead ; profile_task_exit ( tsk ) ; WARN_ON ( atomic_read ( & tsk -> fs_excl ) ) ; if ( unlikely ( in_interrupt ( ) ) ) panic ( ""Aiee,killinginterrupthandler!"" ) ; if ( unlikely ( ! tsk -> pid ) ) panic ( ""Attemptedtokilltheidletask!"" ) ; tracehook_report_exit ( & code ) ; if ( unlikely ( tsk -> flags & PF_EXITING ) ) { printk ( KERN_ALERT ""Fixingrecursivefaultbutrebootisneeded
",0,160
952,"static void show_object ( struct object * obj , const char * last , void * data ) { char * name = path_name ( path , last ) ; add_preferred_base_object ( name ) ; add_object_entry ( obj -> oid . hash , obj -> type , name , 0 ) ; obj -> flags |= OBJECT_ADDED ; }
",1,81
953,"static int mif_process_cmpt ( mif_hdr_t * hdr , char * buf ) { jas_tvparser_t * tvp ; mif_cmpt_t * cmpt ; int id ; cmpt = 0 ; tvp = 0 ; if ( ! ( cmpt = mif_cmpt_create ( ) ) ) { goto error ; } cmpt -> tlx = 0 ; cmpt -> tly = 0 ; cmpt -> sampperx = 0 ; cmpt -> samppery = 0 ; cmpt -> width = 0 ; cmpt -> height = 0 ; cmpt -> prec = 0 ; cmpt -> sgnd = - 1 ; cmpt -> data = 0 ; if ( ! ( tvp = jas_tvparser_create ( buf ) ) ) { goto error ; } while ( ! ( id = jas_tvparser_next ( tvp ) ) ) { switch ( jas_taginfo_nonull ( jas_taginfos_lookup ( mif_tags , jas_tvparser_gettag ( tvp ) ) ) -> id ) { case MIF_TLX : cmpt -> tlx = atoi ( jas_tvparser_getval ( tvp ) ) ; break ; case MIF_TLY : cmpt -> tly = atoi ( jas_tvparser_getval ( tvp ) ) ; break ; case MIF_WIDTH : cmpt -> width = atoi ( jas_tvparser_getval ( tvp ) ) ; break ; case MIF_HEIGHT : cmpt -> height = atoi ( jas_tvparser_getval ( tvp ) ) ; break ; case MIF_HSAMP : cmpt -> sampperx = atoi ( jas_tvparser_getval ( tvp ) ) ; break ; case MIF_VSAMP : cmpt -> samppery = atoi ( jas_tvparser_getval ( tvp ) ) ; break ; case MIF_PREC : cmpt -> prec = atoi ( jas_tvparser_getval ( tvp ) ) ; break ; case MIF_SGND : cmpt -> sgnd = atoi ( jas_tvparser_getval ( tvp ) ) ; break ; case MIF_DATA : if
",0,511
954,"static int ath10k_usb_hif_tx_sg ( struct ath10k * ar , u8 pipe_id , struct ath10k_hif_sg_item * items , int n_items ) { struct ath10k_usb * ar_usb = ath10k_usb_priv ( ar ) ; struct ath10k_usb_pipe * pipe = & ar_usb -> pipes [ pipe_id ] ; struct ath10k_urb_context * urb_context ; struct sk_buff * skb ; struct urb * urb ; int ret , i ; for ( i = 0 ; i < n_items ; i ++ ) { urb_context = ath10k_usb_alloc_urb_from_pipe ( pipe ) ; if ( ! urb_context ) { ret = - ENOMEM ; goto err ; } skb = items [ i ] . transfer_context ; urb_context -> skb = skb ; urb = usb_alloc_urb ( 0 , GFP_ATOMIC ) ; if ( ! urb ) { ret = - ENOMEM ; goto err_free_urb_to_pipe ; } usb_fill_bulk_urb ( urb , ar_usb -> udev , pipe -> usb_pipe_handle , skb -> data , skb -> len , ath10k_usb_transmit_complete , urb_context ) ; if ( ! ( skb -> len % pipe -> max_packet_size ) ) { urb -> transfer_flags |= URB_ZERO_PACKET ; } usb_anchor_urb ( urb , & pipe -> urb_submitted ) ; ret = usb_submit_urb ( urb , GFP_ATOMIC ) ; if ( ret ) { ath10k_dbg ( ar , ATH10K_DBG_USB_BULK , ""usbbulktransmitfailed:%d\\n"" , ret ) ; usb_unanchor_urb ( urb ) ; ret = - EINVAL ; goto err_free_urb_to_pipe ; } usb_free_urb ( urb ) ; } return 0 ; err_free_urb_to_pipe : ath10k_usb_free_urb_to_pipe ( urb_context -> pipe , urb_
",0,510
955,"VOID ixheaacd_esbr_radix4bfly ( const WORD32 * w , WORD32 * x , WORD32 index1 , WORD32 index ) { int i ; WORD32 l1 , l2 , h2 , fft_jmp ; WORD32 xt0_0 , yt0_0 , xt1_0 , yt1_0 , xt2_0 , yt2_0 ; WORD32 xh0_0 , xh1_0 , xh20_0 , xh21_0 , xl0_0 , xl1_0 , xl20_0 , xl21_0 ; WORD32 x_0 , x_1 , x_l1_0 , x_l1_1 , x_l2_0 , x_l2_1 ; WORD32 x_h2_0 , x_h2_1 ; WORD32 si10 , si20 , si30 , co10 , co20 , co30 ; WORD64 mul_1 , mul_2 , mul_3 , mul_4 , mul_5 , mul_6 ; WORD64 mul_7 , mul_8 , mul_9 , mul_10 , mul_11 , mul_12 ; WORD32 * x_l1 ; WORD32 * x_l2 ; WORD32 * x_h2 ; const WORD32 * w_ptr = w ; WORD32 i1 ; h2 = index << 1 ; l1 = index << 2 ; l2 = ( index << 2 ) + ( index << 1 ) ; x_l1 = & ( x [ l1 ] ) ; x_l2 = & ( x [ l2 ] ) ; x_h2 = & ( x [ h2 ] ) ; fft_jmp = 6 * ( index ) ; for ( i1 = 0 ; i1 < index1 ; i1 ++ ) { for ( i = 0 ; i < index ; i ++ ) { si10 = ( * w_ptr ++ ) ; co10 = ( * w_ptr ++ ) ; si20 = ( * w_ptr ++ ) ; co20 = ( * w_ptr ++ ) ; si30 = ( * w_ptr ++ ) ; co30 = ( * w_ptr ++ ) ; co
",0,511
956,"static int asn1_find_indefinite_length ( const unsigned char * data , size_t datalen , size_t * _dp , size_t * _len , const char * * _errmsg ) { unsigned char tag , tmp ; size_t dp = * _dp , len , n ; int indef_level = 1 ; next_tag : if ( unlikely ( datalen - dp < 2 ) ) { if ( datalen == dp ) goto missing_eoc ; goto data_overrun_error ; } tag = data [ dp ++ ] ; if ( tag == ASN1_EOC ) { if ( data [ dp ++ ] != 0 ) goto invalid_eoc ; if ( -- indef_level <= 0 ) { * _len = dp - * _dp ; * _dp = dp ; return 0 ; } goto next_tag ; } if ( unlikely ( ( tag & 0x1f ) == ASN1_LONG_TAG ) ) { do { if ( unlikely ( datalen - dp < 2 ) ) goto data_overrun_error ; tmp = data [ dp ++ ] ; } while ( tmp & 0x80 ) ; } len = data [ dp ++ ] ; if ( len <= 0x7f ) goto check_length ; do { if ( unlikely ( datalen - dp < 2 ) ) goto data_overrun_error ; tmp = data [ dp ++ ] ; } while ( tmp & 0x80 ) ; } len = data [ dp ++ ] ; if ( len <= 0x7f ) goto check_length ; if ( unlikely ( len == ASN1_INDEFINITE_LENGTH ) ) { if ( unlikely ( ( tag & ASN1_CONS_BIT ) == ASN1_PRIM << 5 ) ) goto indefinite_len_primitive ; indef_level ++ ; goto next_tag ; } n = len - 0x80 ; if ( unlikely ( n > sizeof ( len ) - 1 ) ) goto length_too_long ; if ( unlikely ( n > datalen - dp ) ) goto data_overrun_error ; len <<= 8 ; len |= data [ dp ++ ] ; } dp += len ; goto next_tag ; length_too_long : * _errmsg = ""Un
",0,511
957,"static void * __alloc_from_pool ( size_t size , struct page * * ret_page , gfp_t flags ) { unsigned long val ; void * ptr = NULL ; if ( ! atomic_pool ) { WARN ( 1 , ""coherentpoolnotinitialised
",0,60
958,"static inline int mount_entry_on_systemfs ( struct mntent * mntent ) { return mount_entry_on_generic ( mntent , mntent -> mnt_dir ) ; }
",0,47
959,"int phar_verify_signature ( php_stream * fp , size_t end_of_phar , php_uint32 sig_type , char * sig , int sig_len , char * fname , char * * signature , int * signature_len , char * * error ) { int read_size , len ; zend_off_t read_len ; unsigned char buf [ 1024 ] ; php_stream_rewind ( fp ) ; switch ( sig_type ) { case PHAR_SIG_OPENSSL : { # ifdef PHAR_HAVE_OPENSSL BIO * in ; EVP_PKEY * key ; EVP_MD * mdtype = ( EVP_MD * ) EVP_sha1 ( ) ; EVP_MD_CTX md_ctx ; # else int tempsig ; # endif zend_string * pubkey = NULL ; char * pfile ; php_stream * pfp ; # ifndef PHAR_HAVE_OPENSSL if ( ! zend_hash_str_exists ( & module_registry , ""openssl"" , sizeof ( ""openssl"" ) - 1 ) ) { if ( error ) { spprintf ( error , 0 , ""opensslnotloaded"" ) ; } return FAILURE ; } # endif spprintf ( & pfile , 0 , ""%s.pubkey"" , fname ) ; pfp = php_stream_open_wrapper ( pfile , ""rb"" , 0 , NULL ) ; efree ( pfile ) ; if ( ! pfp || ! ( pubkey = php_stream_copy_to_mem ( pfp , PHP_STREAM_COPY_ALL , 0 ) ) || ! ZSTR_LEN ( pubkey ) ) { if ( pfp ) { php_stream_close ( pfp ) ; } if ( error ) { spprintf ( error , 0 , ""opensslpublickeycouldnotberead"" ) ; } return FAILURE ; } php_stream_close ( pfp ) ; # ifndef PHAR_HAVE_OPENSSL tempsig = sig_len ; if ( FAILURE == phar_call_openssl_signverify ( 0 , fp , end_of_phar , pubkey ? ZSTR
",0,511
960,"static void hid_input_field ( struct hid_device * hid , struct hid_field * field , __u8 * data , int interrupt ) { unsigned n ; unsigned count = field -> report_count ; unsigned offset = field -> report_offset ; unsigned size = field -> report_size ; __s32 min = field -> logical_minimum ; __s32 max = field -> logical_maximum ; __s32 * value ; value = kmalloc ( sizeof ( __s32 ) * count , GFP_ATOMIC ) ; if ( ! value ) return ; for ( n = 0 ; n < count ; n ++ ) { value [ n ] = min < 0 ? snto32 ( hid_field_extract ( hid , data , offset + n * size , size ) , size ) : hid_field_extract ( hid , data , offset + n * size , size ) ; if ( ! ( field -> flags & HID_MAIN_ITEM_VARIABLE ) && value [ n ] >= min && value [ n ] <= max && field -> usage [ value [ n ] - min ] . hid == HID_UP_KEYBOARD + 1 ) goto exit ; } for ( n = 0 ; n < count ; n ++ ) { if ( HID_MAIN_ITEM_VARIABLE & field -> flags ) { hid_process_event ( hid , field , & field -> usage [ n ] , value [ n ] , interrupt ) ; continue ; } if ( field -> value [ n ] >= min && field -> value [ n ] <= max && field -> usage [ field -> value [ n ] - min ] . hid && search ( value , field -> value [ n ] , count ) ) hid_process_event ( hid , field , & field -> usage [ field -> value [ n ] - min ] , 0 , interrupt ) ; if ( value [ n ] >= min && value [ n ] <= max && field -> usage [ value [ n ] - min ] . hid && search ( field -> value , value [ n ] , count ) ) hid_process_event ( hid , field , & field -> usage [ value [ n ] - min ] , 1 , interrupt ) ; } memcpy ( field -> value , value , count * sizeof ( __s32 ) ) ; exit : kfree ( value ) ; }
",0,503
961,"static void write_display_size ( const VP9_COMMON * cm , MACROBLOCKD * xd , struct vpx_write_bit_buffer * wb ) { const int scaling_active = cm -> width != cm -> display_width || cm -> height != cm -> display_height ; vpx_wb_write_bit ( wb , scaling_active ) ; if ( scaling_active ) { vpx_wb_write_literal ( wb , cm -> display_width - 1 , 16 ) ; vpx_wb_write_literal ( wb , cm -> display_height - 1 , 16 ) ; } }
",0,141
962,"static void dex_parse_debug_item ( RBinFile * binfile , RBinDexObj * bin , RBinDexClass * c , int MI , int MA , int paddr , int ins_size , int insns_size , char * class_name , int regsz , int debug_info_off ) { struct r_bin_t * rbin = binfile -> rbin ; const ut8 * p4 = r_buf_get_at ( binfile -> buf , debug_info_off , NULL ) ; const ut8 * p4_end = p4 + binfile -> buf -> length - debug_info_off ; ut64 line_start ; ut64 parameters_size ; ut64 param_type_idx ; ut16 argReg = regsz - ins_size ; ut64 source_file_idx = c -> source_file ; RList * params , * debug_positions , * emitted_debug_locals = NULL ; bool keep = true ; if ( argReg > regsz ) { return ; } p4 = r_uleb128 ( p4 , p4_end - p4 , & line_start ) ; p4 = r_uleb128 ( p4 , p4_end - p4 , & parameters_size ) ; ut32 address = 0 ; ut32 line = line_start ; if ( ! ( debug_positions = r_list_newf ( ( RListFree ) free ) ) ) { return ; } if ( ! ( emitted_debug_locals = r_list_newf ( ( RListFree ) free ) ) ) { r_list_free ( debug_positions ) ; return ; } struct dex_debug_local_t debug_locals [ regsz ] ; memset ( debug_locals , 0 , sizeof ( struct dex_debug_local_t ) * regsz ) ; if ( ! ( MA & 0x0008 ) ) { debug_locals [ argReg ] . name = ""this"" ; debug_locals [ argReg ] . descriptor = r_str_newf ( ""%s;"" , class_name ) ; debug_locals [ argReg ] . startAddress = 0 ; debug_locals [ argReg ] . signature = NULL ; debug_locals [ argReg ] . live = true ; argReg ++
",0,511
963,"NOEXPORT int request_env ( agooReq req , VALUE self ) { if ( Qnil == ( VALUE ) req -> env ) { volatile VALUE env = rb_hash_new ( ) ; rb_hash_aset ( env , request_method_val , req_method ( req ) ) ; rb_hash_aset ( env , script_name_val , req_script_name ( req ) ) ; rb_hash_aset ( env , path_info_val , req_path_info ( req ) ) ; rb_hash_aset ( env , query_string_val , req_query_string ( req ) ) ; fill_headers ( req , env ) ; rb_hash_aset ( env , rack_version_val , rack_version_val_val ) ; rb_hash_aset ( env , rack_url_scheme_val , req_rack_url_scheme ( req ) ) ; rb_hash_aset ( env , rack_input_val , req_rack_input ( req ) ) ; rb_hash_aset ( env , rack_errors_val , req_rack_errors ( req ) ) ; rb_hash_aset ( env , rack_multithread_val , req_rack_multithread ( req ) ) ; rb_hash_aset ( env , rack_multiprocess_val , Qfalse ) ; rb_hash_aset ( env , rack_run_once_val , Qfalse ) ; rb_hash_aset ( env , rack_logger_val , req_rack_logger ( req ) ) ; rb_hash_aset ( env , rack_upgrade_val , req_rack_upgrade ( req ) ) ; rb_hash_aset ( env , rack_hijackq_val , Qtrue ) ; rb_hash_aset ( env , rack_hijack_val , self ) ; rb_hash_aset ( env , rack_hijack_io_val , Qtrue ) ; rb_hash_aset ( env , rack_hijack_io_val , self ) ; }
",0,491
964,"int xfs_attr3_leaf_getvalue ( struct xfs_buf * bp , struct xfs_da_args * args ) { struct xfs_attr_leafblock * leaf ; struct xfs_attr3_icleaf_hdr ichdr ; struct xfs_attr_leaf_entry * entry ; struct xfs_attr_leaf_name_local * name_loc ; struct xfs_attr_leaf_name_remote * name_rmt ; int valuelen ; leaf = bp -> b_addr ; xfs_attr3_leaf_hdr_from_disk ( & ichdr , leaf ) ; ASSERT ( ichdr . count < XFS_LBSIZE ( args -> dp -> i_mount ) / 8 ) ; ASSERT ( args -> index < ichdr . count ) ; entry = & xfs_attr3_leaf_entryp ( leaf ) [ args -> index ] ; if ( entry -> flags & XFS_ATTR_LOCAL ) { name_loc = xfs_attr3_leaf_name_local ( leaf , args -> index ) ; ASSERT ( name_loc -> namelen == args -> namelen ) ; ASSERT ( memcmp ( args -> name , name_loc -> nameval , args -> namelen ) == 0 ) ; args -> rmtvaluelen = be32_to_cpu ( name_rmt -> valuelen ) ; args -> rmtblkno = be32_to_cpu ( name_rmt -> valuelen ) ; args -> valuelen = valuelen ; return 0 ; } if ( args -> valuelen < valuelen ) { args -> valuelen = valuelen ; return XFS_ERROR ( ERANGE ) ; } args -> valuelen = valuelen ; }
",0,400
965,"struct xt_table_info * xt_alloc_table_info ( unsigned int size ) { struct xt_table_info * info = NULL ; size_t sz = sizeof ( * info ) + size ; if ( ( SMP_ALIGN ( size ) >> PAGE_SHIFT ) + 2 > totalram_pages ) return NULL ; if ( sz <= ( PAGE_SIZE << PAGE_ALLOC_COSTLY_ORDER ) ) info = kmalloc ( sz , GFP_KERNEL | __GFP_NOWARN | __GFP_NORETRY ) ; if ( ! info ) { info = vmalloc ( sz ) ; if ( ! info ) return NULL ; } memset ( info , 0 , sizeof ( * info ) ) ; info -> size = size ; return info ; }
",0,180
966,"int dbd_st_prepare ( SV * sth , imp_sth_t * imp_sth , char * statement , SV * attribs ) { int i ; SV * * svp ; dTHX ; # if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION # if MYSQL_VERSION_ID < CALL_PLACEHOLDER_VERSION char * str_ptr , * str_last_ptr ; # if MYSQL_VERSION_ID < LIMIT_PLACEHOLDER_VERSION int limit_flag = 0 ; # endif int col_type , prepare_retval ; MYSQL_BIND * bind , * bind_end ; imp_sth_phb_t * fbind ; # endif D_imp_xxh ( sth ) ; D_imp_dbh_from_sth ; if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""\\t->dbd_st_prepareMYSQL_VERSION_ID%d,SQLstatement:%s\\n"" , MYSQL_VERSION_ID , statement ) ; # if MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION imp_sth -> use_server_side_prepare = imp_dbh -> use_server_side_prepare ; if ( attribs ) { svp = DBD_ATTRIB_GET_SVP ( attribs , ""mysql_server_prepare"" , 20 ) ; imp_sth -> use_server_side_prepare = ( svp ) ? SvTRUE ( * svp ) : imp_dbh -> use_server_side_prepare ; svp = DBD_ATTRIB_GET_SVP ( attribs , ""async"" , 5 ) ; if ( svp && SvTRUE ( * svp ) ) { # if MYSQL_ASYNC imp_sth -> is_async = TRUE ; imp_sth -> use_server_side_prepare = FALSE ; # else do_error ( sth , 2000 , ""AsyncsupportwasnotbuiltintothisversionofDBD::mysql"" , ""HY000"" ) ; return 0 ; # endif } s
",0,511
967,"static noinline void key_gc_unused_keys ( struct list_head * keys ) { while ( ! list_empty ( keys ) ) { struct key * key = list_entry ( keys -> next , struct key , graveyard_link ) ; list_del ( & key -> graveyard_link ) ; kdebug ( ""-%u"" , key -> serial ) ; key_check ( key ) ; if ( test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) && ! test_bit ( KEY_FLAG_NEGATIVE , & key -> flags ) ) key -> type -> destroy ( key ) ; security_key_free ( key ) ; if ( test_bit ( KEY_FLAG_IN_QUOTA , & key -> flags ) ) { spin_lock ( & key -> user -> lock ) ; key -> user -> qnkeys -- ; key -> user -> qnbytes -= key -> quotalen ; spin_unlock ( & key -> user -> lock ) ; } atomic_dec ( & key -> user -> nkeys ) ; if ( test_bit ( KEY_FLAG_INSTANTIATED , & key -> flags ) ) atomic_dec ( & key -> user -> nikeys ) ; key_user_put ( key -> user ) ; kfree ( key -> description ) ; # ifdef KEY_DEBUGGING key -> magic = KEY_DEBUG_MAGIC_X ; # endif kmem_cache_free ( key_jar , key ) ; } }
",0,321
968,"static ltxtquery * queryin ( char * buf ) { QPRS_STATE state ; int32 i ; ltxtquery * query ; int32 commonlen ; ITEM * ptr ; NODE * tmp ; int32 pos = 0 ; # ifdef BS_DEBUG char pbuf [ 16384 ] , * cur ; # endif state . buf = buf ; state . state = WAITOPERAND ; state . count = 0 ; state . num = 0 ; state . str = NULL ; state . sumlen = 0 ; state . lenop = 64 ; state . curop = state . op = ( char * ) palloc ( state . lenop ) ; * ( state . curop ) = '\\0' ; makepol ( & state ) ; if ( ! state . num ) ereport ( ERROR , ( errcode ( ERRCODE_SYNTAX_ERROR ) , errmsg ( ""syntaxerror"" ) , errdetail ( ""Emptyquery."" ) ) ) ; if ( LTXTQUERY_TOO_BIG ( state . num , state . sumlen ) ) ereport ( ERROR , ( errcode ( ERRCODE_PROGRAM_LIMIT_EXCEEDED ) , errmsg ( ""ltxtqueryistoolarge"" ) ) ) ; commonlen = COMPUTESIZE ( state . num , state . sumlen ) ; query = ( ltxtquery * ) palloc ( commonlen ) ; SET_VARSIZE ( query , commonlen ) ; query -> size = state . num ; ptr = GETQUERY ( query ) ; for ( i = 0 ; i < state . num ; i ++ ) { ptr [ i ] . type = state . str -> type ; ptr [ i ] . val = state . str -> val ; ptr [ i ] . distance = state . str -> distance ; ptr [ i ] . length = state . str -> length ; ptr [ i ] . flag = state . str -> flag ; tmp = state . str -> next ; pfree ( state . str ) ; state . str = tmp ; } memcpy ( ( void * ) GETOPERAND ( query ) , ( void * ) state . op , state . sumlen ) ; pfree ( state . op ) ; pos = 0 ; findoprnd ( ptr , & pos ) ; return query ; }
",1,502
969,"static void SaltTextAway ( XtermWidget xw , int which , CELL * cellc , CELL * cell ) { TScreen * screen = TScreenOf ( xw ) ; SelectedCells * scp ; int i ; int eol ; char * line ; char * lp ; CELL first = * cellc ; CELL last = * cell ; if ( which < 0 || which >= MAX_SELECTIONS ) { TRACE ( ( ""SaltTextAway-whichselection?\\n"" ) ) ; return ; } scp = & ( screen -> selected_cells [ which ] ) ; TRACE ( ( ""SaltTextAwaywhich=%d,first=%d,%d,last=%d,%d\\n"" , which , first . row , first . col , last . row , last . col ) ) ; if ( isSameRow ( & first , & last ) && first . col > last . col ) { int tmp ; EXCHANGE ( first . col , last . col , tmp ) ; } -- last . col ; if ( isSameRow ( & last , & first ) ) { need = Length ( screen , first . row , first . col , last . col ) ; } else { need += Length ( screen , first . row , first . col , screen -> max_col ) + 1 ; for ( i = first . row + 1 ; i < last . row ; i ++ ) need += Length ( screen , i , 0 , screen -> max_col ) + 1 ; if ( last . col >= 0 ) need += Length ( screen , last . row , 0 , last . col ) ; } if_OPT_WIDE_CHARS ( screen , { need *= 4 ; } ) ; if ( need < 0 ) return ; if ( scp -> data_limit <= ( unsigned ) need ) { if ( ( line = ( Char * ) malloc ( ( size_t ) need + 1 ) ) == 0 ) SysError ( ERROR_BMALLOC2 ) ; free ( scp -> data_buffer ) ; scp -> data_buffer = line ; scp -> data_limit = ( size_t ) ( need + 1 ) ; } else { line = scp -> data_buffer ; } if ( line == 0 ) return ; line [ need ] = '\\0' ; }
",0,504
970,"int ext4_orphan_del ( handle_t * handle , struct inode * inode ) { struct list_head * prev ; struct ext4_inode_info * ei = EXT4_I ( inode ) ; struct ext4_sb_info * sbi ; __u32 ino_next ; struct ext4_iloc iloc ; int err = 0 ; if ( ! EXT4_SB ( inode -> i_sb ) -> s_journal ) return 0 ; mutex_lock ( & EXT4_SB ( inode -> i_sb ) -> s_orphan_lock ) ; if ( list_empty ( & ei -> i_orphan ) ) goto out ; ino_next = NEXT_ORPHAN ( inode ) ; prev = ei -> i_orphan . prev ; sbi = EXT4_SB ( inode -> i_sb ) ; jbd_debug ( 4 , ""removeinode%lufromorphanlist\\n"" , inode -> i_ino ) ; list_del_init ( & ei -> i_orphan ) ; if ( sbi -> s_journal && ! handle ) goto out ; err = ext4_reserve_inode_write ( handle , inode , & iloc ) ; if ( err ) goto out_err ; if ( prev == & sbi -> s_orphan ) { jbd_debug ( 4 , ""superblockwillpointto%u\\n"" , ino_next ) ; BUFFER_TRACE ( sbi -> s_sbh , ""get_write_access"" ) ; err = ext4_journal_get_write_access ( handle , sbi -> s_sbh ) ; if ( err ) goto out_brelse ; sbi -> s_es -> s_last_orphan = cpu_to_le32 ( ino_next ) ; err = ext4_handle_dirty_super ( handle , inode -> i_sb ) ; } else { struct ext4_iloc iloc2 ; struct inode * i_prev = & list_entry ( prev , struct ext4_inode_info , i_orphan ) -> vfs_inode ; jbd_debug ( 4 , ""orphaninode%luwillpointto%u\\n"" , i_prev -> i
",0,511
971,"void ftoa_bounded_extra ( JsVarFloat val , char * str , size_t len , int radix , int fractionalDigits ) { const JsVarFloat stopAtError = 0.0001001 ; if ( isnan ( val ) ) strncpy ( str , ""NaN"" , len ) ; else if ( ! isfinite ( val ) ) { if ( val < 0 ) strncpy ( str , ""-Infinity"" , len ) ; else strncpy ( str , ""Infinity"" , len ) ; } else { if ( val < 0 ) { if ( -- len <= 0 ) { * str = 0 ; return ; } * ( str ++ ) = '-' ; val = - val ; } if ( ( JsVarInt ) ( val + stopAtError ) ) == ( 1 + ( JsVarInt ) val ) ) val = ( JsVarFloat ) ( 1 + ( JsVarInt ) val ) ; JsVarFloat d = 1 ; while ( d * radix <= val ) d *= radix ; while ( d >= 1 ) { int v = ( int ) ( val / d ) ; val -= v * d ; if ( -- len <= 0 ) { * str = 0 ; return ; } * ( str ++ ) = itoch ( v ) ; d /= radix ; } # ifndef USE_NO_FLOATS if ( ( ( fractionalDigits < 0 ) && val > 0 ) || fractionalDigits > 0 ) { bool hasPt = false ; val *= radix ; while ( ( ( fractionalDigits < 0 ) && ( fractionalDigits > - 12 ) && ( val > stopAtError ) ) || ( fractionalDigits > 0 ) ) { int v = ( int ) ( val + ( ( fractionalDigits == 1 ) ? 0.4 : 0.00000001 ) ) ; val = ( val - v ) * radix ; if ( v == radix ) v = radix - 1 ; if ( ! hasPt ) { hasPt = true ; if ( -- len <= 0 ) { * str = 0 ; return ; } * ( str ++ ) = '.' ; } if ( -- len <= 0 ) { * str = 0 ; return ; } * ( str ++ ) = itoch ( v ) ; d /= radix
",0,511
972,"opj_image_t * pgxtoimage ( const char * filename , opj_cparameters_t * parameters ) { FILE * f = NULL ; int w , h , prec ; int i , numcomps , max ; OPJ_COLOR_SPACE color_space ; opj_image_cmptparm_t cmptparm ; opj_image_t * image = NULL ; int adjustS , ushift , dshift , force8 ; char endian1 , endian2 , sign ; char signtmp [ 32 ] ; char temp [ 32 ] ; int bigendian ; opj_image_comp_t * comp = NULL ; numcomps = 1 ; color_space = OPJ_CLRSPC_GRAY ; memset ( & cmptparm , 0 , sizeof ( opj_image_cmptparm_t ) ) ; max = 0 ; f = fopen ( filename , ""rb"" ) ; if ( ! f ) { fprintf ( stderr , ""Failedtoopen%sforreading
",0,232
973,"static void test_function ( char * ( * my_asnprintf ) ( char * , size_t * , const char * , ... ) ) { char buf [ 8 ] ; int size ; for ( size = 0 ; size <= 8 ; size ++ ) { size_t length = size ; char * result = my_asnprintf ( NULL , & length , ""%d"" , 12345 ) ; ASSERT ( result != NULL ) ; ASSERT ( strcmp ( result , ""12345"" ) == 0 ) ; ASSERT ( length == 5 ) ; free ( result ) ; } for ( size = 0 ; size <= 8 ; size ++ ) { size_t length ; char * result ; memcpy ( buf , ""DEADBEEF"" , 8 ) ; length = size ; result = my_asnprintf ( buf , & length , ""%d"" , 12345 ) ; ASSERT ( result != NULL ) ; ASSERT ( strcmp ( result , ""12345"" ) == 0 ) ; ASSERT ( length == 5 ) ; if ( size < 2 ) ASSERT ( result != buf ) ; ASSERT ( memcmp ( buf + size , & ""DEADBEEF"" [ size ] , 8 - size ) == 0 ) ; if ( result != buf ) free ( result ) ; } }
",0,281
974,"void add_interrupt_randomness ( int irq , int irq_flags ) { struct entropy_store * r ; struct fast_pool * fast_pool = this_cpu_ptr ( & irq_randomness ) ; struct pt_regs * regs = get_irq_regs ( ) ; unsigned long now = jiffies ; cycles_t cycles = random_get_entropy ( ) ; __u32 c_high , j_high ; __u64 ip ; unsigned long seed ; int credit = 0 ; if ( cycles == 0 ) cycles = get_reg ( fast_pool , regs ) ; c_high = ( sizeof ( cycles ) > 4 ) ? cycles >> 32 : 0 ; j_high = ( sizeof ( now ) > 4 ) ? now >> 32 : 0 ; fast_pool -> pool [ 0 ] ^= cycles ^ j_high ^ irq ; fast_pool -> pool [ 1 ] ^= now ^ c_high ; ip = regs ? instruction_pointer ( regs ) : _RET_IP_ ; fast_pool -> pool [ 2 ] ^= ip ; fast_pool -> pool [ 3 ] ^= ( sizeof ( ip ) > 4 ) ? ip >> 32 : get_reg ( fast_pool , regs ) ; fast_mix ( fast_pool ) ; add_interrupt_bench ( cycles ) ; if ( unlikely ( crng_init == 0 ) ) { if ( ( fast_pool -> count >= 64 ) && crng_fast_load ( ( char * ) fast_pool -> pool , sizeof ( fast_pool -> pool ) ) ) { fast_pool -> count = 0 ; fast_pool -> last = now ; } return ; } if ( ( fast_pool -> count < 64 ) && ! time_after ( now , fast_pool -> last + HZ ) ) return ; r = & input_pool ; if ( ! spin_trylock ( & r -> lock ) ) return ; fast_pool -> last = now ; __mix_pool_bytes ( r , & fast_pool -> pool , sizeof ( fast_pool -> pool ) ) ; if ( arch_get_random_seed_long ( & seed ) ) { __mix_pool_bytes ( r , & seed , sizeof ( seed ) ) ; credit = 1 ; } spin_unlock ( & r -> lock ) ; fast_pool ->
",0,511
975,"void jslGetTokenString ( char * str , size_t len ) { if ( lex -> tk == LEX_ID ) { strncpy ( str , ""ID:"" , len ) ; strncat ( str , jslGetTokenValueAsString ( ) , len ) ; } else if ( lex -> tk == LEX_STR ) { strncpy ( str , ""String:\'"" , len ) ; strncat ( str , jslGetTokenValueAsString ( ) , len ) ; strncat ( str , ""\'"" , len ) ; } else jslTokenAsString ( lex -> tk , str , len ) ; }
",0,142
976,"local void process ( char * path ) { int method = - 1 ; size_t len ; struct stat st ; static char * sufs [ ] = { "".z"" , ""-z"" , ""_z"" , "".Z"" , "".gz"" , ""-gz"" , "".zz"" , ""-zz"" , "".zip"" , "".ZIP"" , "".tgz"" , NULL } ; if ( path == NULL ) { strcpy ( g . inf , ""<stdin>"" ) ; g . ind = 0 ; g . name = NULL ; g . mtime = g . headis & 2 ? ( fstat ( g . ind , & st ) ? time ( NULL ) : st . st_mtime ) : 0 ; len = 0 ; } else { if ( path != g . inf ) { strncpy ( g . inf , path , sizeof ( g . inf ) ) ; if ( g . inf [ sizeof ( g . inf ) - 1 ] ) bail ( ""nametoolong:"" , path ) ; } len = strlen ( g . inf ) ; if ( lstat ( g . inf , & st ) ) { if ( errno == ENOENT && ( g . list || g . decode ) ) { char * * try = sufs ; do { if ( * try == NULL || len + strlen ( * try ) >= sizeof ( g . inf ) ) break ; strcpy ( g . inf + len , * try ++ ) ; errno = 0 ; } while ( lstat ( g . inf , & st ) && errno == ENOENT ) ; } # ifdef EOVERFLOW if ( errno == EOVERFLOW || errno == EFBIG ) bail ( g . inf , ""toolarge--notcompiledwithlargefilesupport"" ) ; # endif if ( errno ) { g . inf [ len ] = 0 ; complain ( ""%sdoesnotexist--skipping"" , g . inf ) ; return ; } len = strlen ( g . inf ) ; } if ( ( st . st_mode & S_IFMT ) != S_IFREG && ( st . st_mode & S_IFMT ) != S_IFLNK && ( st . st_mode & S_IFMT ) != S_IFDIR ) { complain ( ""%sisaspecialfileordevice--skipping"" , g . inf )
",0,511
977,"static MagickBooleanType ConcatenateImages ( int argc , char * * argv , ExceptionInfo * exception ) { FILE * input , * output ; MagickBooleanType status ; int c ; register ssize_t i ; if ( ExpandFilenames ( & argc , & argv ) == MagickFalse ) ThrowFileException ( exception , ResourceLimitError , ""MemoryAllocationFailed"" , GetExceptionMessage ( errno ) ) ; output = fopen_utf8 ( argv [ argc - 1 ] , ""wb"" ) ; if ( output == ( FILE * ) NULL ) { ThrowFileException ( exception , FileOpenError , ""UnableToOpenFile"" , argv [ argc - 1 ] ) ; return ( MagickFalse ) ; } status = MagickTrue ; for ( i = 2 ; i < ( ssize_t ) ( argc - 1 ) ; i ++ ) { input = fopen_utf8 ( argv [ i ] , ""rb"" ) ; if ( input == ( FILE * ) NULL ) { ThrowFileException ( exception , FileOpenError , ""UnableToOpenFile"" , argv [ i ] ) ; continue ; } for ( c = fgetc ( input ) ; c != EOF ; c = fgetc ( input ) ) ( void ) fputc ( ( char ) c , output ) ; ( void ) fclose ( input ) ; ( void ) fclose ( input ) ; ( void ) remove_utf8 ( argv [ i ] ) ; } ( void ) fclose ( output ) ; return ( MagickTrue ) ; }
",0,349
978,"vpx_codec_err_t vpx_svc_set_options ( SvcContext * svc_ctx , const char * options ) { SvcInternal_t * const si = get_svc_internal ( svc_ctx ) ; if ( svc_ctx == NULL || options == NULL || si == NULL ) { return VPX_CODEC_INVALID_PARAM ; } strncpy ( si -> options , options , sizeof ( si -> options ) ) ; si -> options [ sizeof ( si -> options ) - 1 ] = '\\0' ; return VPX_CODEC_OK ; }
",1,139
979,"static struct block_device * ext3_blkdev_get ( dev_t dev , struct super_block * sb ) { struct block_device * bdev ; char b [ BDEVNAME_SIZE ] ; bdev = blkdev_get_by_dev ( dev , FMODE_READ | FMODE_WRITE | FMODE_EXCL , sb ) ; if ( IS_ERR ( bdev ) ) goto fail ; return bdev ; fail : ext3_msg ( sb , KERN_ERR , ""error:failedtoopenjournaldevice%s:%ld"" , __bdevname ( dev , b ) , PTR_ERR ( bdev ) ) ; return NULL ; }
",1,161
980,"int setpwnam ( struct passwd * pwd , const char * prefix ) { FILE * fp = NULL , * pwf = NULL ; int save_errno ; int found ; int namelen ; int buflen = 256 ; int contlen , rc ; char * linebuf = NULL ; char * tmpname = NULL ; char * atomic_dir = NULL ; char * pw_init ( ) ; if ( ( fp = xfmkstemp ( & tmpname , atomic_dir ) ) == NULL ) return - 1 ; if ( fchown ( fileno ( fp ) , ( uid_t ) 0 , ( gid_t ) 0 ) < 0 ) goto fail ; if ( lckpwdf ( ) < 0 ) goto fail ; pwf = fopen ( PASSWD_FILE , ""r"" ) ; if ( ! pwf ) goto fail ; namelen = strlen ( pwd -> pw_name ) ; linebuf = malloc ( buflen ) ; if ( ! linebuf ) goto fail ; found = false ; while ( fgets ( linebuf , buflen , pwf ) != NULL ) { contlen = strlen ( linebuf ) ; while ( linebuf [ contlen - 1 ] != '\\n' && ! feof ( pwf ) ) { char * tmp ; buflen *= 2 ; tmp = realloc ( linebuf , buflen ) ; if ( tmp == NULL ) goto fail ; linebuf = tmp ; if ( fgets ( & linebuf [ contlen ] , buflen / 2 , pwf ) == NULL ) break ; contlen = strlen ( linebuf ) ; } if ( ! found && linebuf [ namelen ] == ':' && ! strncmp ( linebuf , pwd -> pw_name , namelen ) ) { if ( putpwent ( pwd , fp ) < 0 ) goto fail ; found = true ; continue ; } fputs ( linebuf , fp ) ; } if ( fchmod ( fileno ( fp ) , 0644 ) < 0 ) goto fail ; rc = close_stream ( fp ) ; fp = NULL ; if ( rc != 0 ) goto fail ; fclose ( pwf ) ; pwf = NULL ; if ( ! found ) {
",0,511
981,"static unsigned int convert_distribution ( unsigned int i , vpx_tree tree , unsigned int branch_ct [ ] [ 2 ] , const unsigned int num_events [ ] ) { unsigned int left , right ; if ( tree [ i ] <= 0 ) left = num_events [ - tree [ i ] ] ; else left = convert_distribution ( tree [ i ] , tree , branch_ct , num_events ) ; if ( tree [ i + 1 ] <= 0 ) right = num_events [ - tree [ i + 1 ] ] ; else right = convert_distribution ( tree [ i + 1 ] , tree , branch_ct , num_events ) ; branch_ct [ i >> 1 ] [ 0 ] = left ; branch_ct [ i >> 1 ] [ 1 ] = right ; return left + right ; }
",1,178
982,"int pure_strcmp ( const char * const s1 , const char * const s2 ) { return pure_memcmp ( s1 , s2 , strlen ( s1 ) + 1U , strlen ( s2 ) ) ; }
",0,53
983,"static gboolean _handle_carbons ( xmpp_stanza_t * const stanza ) { xmpp_stanza_t * carbons = xmpp_stanza_get_child_by_ns ( stanza , STANZA_NS_CARBONS ) ; if ( ! carbons ) { return FALSE ; } const char * name = xmpp_stanza_get_name ( carbons ) ; if ( ! name ) { log_error ( ""UnabletoretrievestanzanameforCarbon"" ) ; return TRUE ; } if ( g_strcmp0 ( name , ""private"" ) == 0 ) { log_info ( ""Carbonreceivedwithprivateelement."" ) ; return FALSE ; } if ( ( g_strcmp0 ( name , ""received"" ) != 0 ) && ( g_strcmp0 ( name , ""sent"" ) != 0 ) ) { log_warning ( ""Carbonreceivedwithunrecognisedstanzaname:%s"" , name ) ; return TRUE ; } xmpp_stanza_t * forwarded = xmpp_stanza_get_child_by_ns ( carbons , STANZA_NS_FORWARD ) ; if ( ! forwarded ) { log_warning ( ""Carbonreceivedwithnoforwardedelement"" ) ; return TRUE ; } xmpp_stanza_t * message = xmpp_stanza_get_child_by_name ( forwarded , STANZA_NAME_MESSAGE ) ; if ( ! message ) { log_warning ( ""Carbonreceivedwithnomessageelement"" ) ; return TRUE ; } char * message_txt = xmpp_message_get_body ( message ) ; if ( ! message_txt ) { log_warning ( ""Carbonreceivedwithnomessage."" ) ; return TRUE ; } const gchar * to = xmpp_stanza_get_to ( message ) ; const gchar * from = xmpp_stanza_get_from ( message ) ; Jid * jid_from = jid_create ( from ) ; Jid * jid_to = jid_create ( to ) ; Jid * my_jid = jid_create ( connection_get_fulljid ( ) ) ; const char * my_jid = jid_create
",0,511
984,"void configSetCommand ( client * c ) { robj * o ; long long ll ; int err ; serverAssertWithInfo ( c , c -> argv [ 2 ] , sdsEncodedObject ( c -> argv [ 2 ] ) ) ; serverAssertWithInfo ( c , c -> argv [ 3 ] , sdsEncodedObject ( c -> argv [ 3 ] ) ) ; o = c -> argv [ 3 ] ; if ( 0 ) { config_set_special_field ( ""dbfilename"" ) { if ( ! pathIsBaseName ( o -> ptr ) ) { addReplyError ( c , ""dbfilenamecan\'tbeapath,justafilename"" ) ; return ; } zfree ( server . rdb_filename ) ; server . rdb_filename = zstrdup ( o -> ptr ) ; } config_set_special_field ( ""requirepass"" ) { if ( sdslen ( o -> ptr ) > CONFIG_AUTHPASS_MAX_LEN ) goto badfmt ; zfree ( server . requirepass ) ; server . requirepass = ( ( char * ) o -> ptr ) [ 0 ] ? zstrdup ( o -> ptr ) : NULL ; } config_set_special_field ( ""masterauth"" ) { zfree ( server . masterauth ) ; server . masterauth = ( ( char * ) o -> ptr ) [ 0 ] ? zstrdup ( o -> ptr ) : NULL ; } config_set_special_field ( ""cluster-announce-ip"" ) { zfree ( server . cluster_announce_ip ) ; server . cluster_announce_ip = ( ( char * ) o -> ptr ) [ 0 ] ? zstrdup ( o -> ptr ) : NULL ; } config_set_special_field ( ""maxclients"" ) { int orig_value = server . maxclients ; if ( getLongLongFromObject ( o , & ll ) == C_ERR || ll < 1 ) goto badfmt ; server . maxclients = ll ; if ( ll > orig_value ) { adjustOpenFilesLimit ( ) ; if ( server . maxclients != ll ) { addReplyErrorFormat ( c , ""Theoperatingsystemisnotabletohandlethespecifiednumberofclients,trywith%d"" , server
",0,511
985,"static int dev_get_valid_name ( struct net * net , struct net_device * dev , const char * name ) { BUG_ON ( ! net ) ; if ( ! dev_valid_name ( name ) ) return - EINVAL ; if ( strchr ( name , '%' ) ) return dev_alloc_name_ns ( net , dev , name ) ; else if ( __dev_get_by_name ( net , name ) ) return - EEXIST ; else if ( dev -> name != name ) strlcpy ( dev -> name , name , IFNAMSIZ ) ; return 0 ; }
",0,138
986,"int options_cmdline ( char * arg1 , char * arg2 ) { char * name ; CONF_TYPE type ; # ifdef USE_WIN32 ( void ) arg2 ; # endif if ( ! arg1 ) { name = # ifdef CONFDIR CONFDIR # ifdef USE_WIN32 ""\\\\"" # else ""/"" # endif # endif ""stunnel.conf"" ; type = CONF_FILE ; } else if ( ! strcasecmp ( arg1 , ""-help"" ) ) { char_print_global_option ( CMD_PRINT_HELP , NULL , NULL ) ; parse_global_option ( CMD_PRINT_HELP , NULL , NULL , NULL ) ; log_flush ( LOG_MODE_INFO ) ; return 2 ; } else if ( ! strcasecmp ( arg1 , ""-version"" ) ) { parse_global_option ( CMD_PRINT_DEFAULTS , NULL , NULL ) ; parse_service_option ( CMD_PRINT_DEFAULTS , NULL , NULL , NULL ) ; log_flush ( LOG_MODE_INFO ) ; return 2 ; } else if ( ! strcasecmp ( arg1 , ""-sockets"" ) ) { socket_options_print ( ) ; log_flush ( LOG_MODE_INFO ) ; return 2 ; } else if ( ! strcasecmp ( arg1 , ""-options"" ) ) { print_ssl_options ( ) ; log_flush ( LOG_MODE_INFO ) ; return 2 ; } else # ifndef USE_WIN32 if ( ! strcasecmp ( arg1 , ""-fd"" ) ) { if ( ! arg2 ) { s_log ( LOG_ERR , ""Nofiledescriptorspecified"" ) ; print_syntax ( ) ; return 1 ; } name = arg2 ; type = CONF_FD ; } else # endif { name = arg1 ; type = CONF_FILE ; } if ( type == CONF_FILE ) { # ifdef HAVE_REALPATH char * real_path = NULL ; # ifdef MAXPATHLEN real_path = malloc ( MAXPATHLEN ) ; # endif real_path = realpath ( name , real_path ) ; if ( ! real_path ) { s_log ( LOG_ERR , ""Invalidconfigurationfilename""
",0,511
987,"int bt_sock_stream_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t size , int flags ) { struct sock * sk = sock -> sk ; int err = 0 ; size_t target , copied = 0 ; long timeo ; if ( flags & MSG_OOB ) return - EOPNOTSUPP ; msg -> msg_namelen = 0 ; BT_DBG ( ""sk%psize%zu"" , sk , size ) ; lock_sock ( sk ) ; target = sock_rcvlowat ( sk , flags & MSG_WAITALL , size ) ; timeo = sock_rcvtimeo ( sk , flags & MSG_DONTWAIT ) ; do { struct sk_buff * skb ; int chunk ; skb = skb_dequeue ( & sk -> sk_receive_queue ) ; if ( ! skb ) { if ( copied >= target ) break ; err = sock_error ( sk ) ; if ( err ) break ; if ( sk -> sk_shutdown & RCV_SHUTDOWN ) break ; err = - EAGAIN ; if ( ! timeo ) break ; timeo = bt_sock_data_wait ( sk , timeo ) ; if ( signal_pending ( current ) ) { err = sock_intr_errno ( timeo ) ; goto out ; } continue ; } chunk = min_t ( unsigned int , skb -> len , size ) ; if ( skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , chunk ) ) { skb_queue_head ( & sk -> sk_receive_queue , skb ) ; if ( ! copied ) copied = - EFAULT ; break ; } copied += chunk ; size -= chunk ; sock_recv_ts_and_drops ( msg , sk , skb ) ; if ( ! ( flags & MSG_PEEK ) ) { int skb_len = skb_headlen ( skb ) ; if ( chunk <= skb_len ) { __skb_pull ( skb , chunk ) ; } else { struct sk_buff * frag ; __skb_pull ( skb , skb_len ) ; chunk -= skb_len ; skb_len
",0,511
988,"PyObject * ast2obj_excepthandler ( void * _o ) { excepthandler_ty o = ( excepthandler_ty ) _o ; PyObject * result = NULL , * value = NULL ; if ( ! o ) { Py_RETURN_NONE ; } switch ( o -> kind ) { case ExceptHandler_kind : result = PyType_GenericNew ( ExceptHandler_type , NULL , NULL ) ; if ( ! result ) goto failed ; value = ast2obj_expr ( o -> v . ExceptHandler . type ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_type , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_identifier ( o -> v . ExceptHandler . name ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_name , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_list ( o -> v . ExceptHandler . body , ast2obj_stmt ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_body , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; break ; } value = ast2obj_int ( o -> lineno ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_lineno , value ) < 0 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_int ( o -> col_offset ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_col_offset , value ) < 0 ) goto failed ; Py_DECREF ( value ) ; return result ; failed : Py_XDECREF ( value ) ; Py_XDECREF ( result ) ; return NULL ; }
",1,450
989,"void process_packet_tail ( struct msg_digest * md ) { struct state * st = md -> st ; enum state_kind from_state = md -> v1_from_state ; const struct state_v1_microcode * smc = md -> smc ; bool new_iv_set = md -> new_iv_set ; bool self_delete = FALSE ; if ( md -> hdr . isa_flags & ISAKMP_FLAGS_v1_ENCRYPTION ) { endpoint_buf b ; dbg ( ""receivedencryptedpacketfrom%s"" , str_endpoint ( & md -> sender , & b ) ) ; if ( st == NULL ) { libreswan_log ( ""discardingencryptedmessageforanunknownISAKMPSA"" ) ; return ; } if ( st -> st_skeyid_e_nss == NULL ) { loglog ( RC_LOG_SERIOUS , ""discardingencryptedmessagebecausewehaven\'tyetnegotiatedkeyingmaterial"" ) ; return ; } md -> encrypted = TRUE ; const struct encrypt_desc * e = st -> st_oakley . ta_encrypt ; if ( pbs_left ( & md -> message_pbs ) % e -> enc_blocksize != 0 ) { loglog ( RC_LOG_SERIOUS , ""malformedmessage:notamultipleofencryptionblocksize"" ) ; return ; } md -> raw_packet = clone_bytes_as_chunk ( md -> packet_pbs . start , pbs_room ( & md -> packet_pbs ) , ""rawpacket"" ) ; if ( ! new_iv_set ) { if ( st -> st_v1_iv . len == 0 ) { init_phase2_iv ( st , & md -> hdr . isa_msgid ) ; } else { restore_new_iv ( st , st -> st_v1_iv ) ; } } passert ( st -> st_v1_new_iv . len >= e -> enc_blocksize ) ; st -> st_v1_new_iv . len = e -> enc_blocksize ; if ( DBGP ( DBG_CRYPT ) ) { DBG_log ( ""decrypting%ubytesusingalgorithm%s"" , ( unsigned )
",0,511
990,"void impeg2d_dec_hdr ( void * pv_dec , impeg2d_video_decode_ip_t * ps_ip , impeg2d_video_decode_op_t * ps_op ) { UWORD32 u4_bits_read ; dec_state_t * ps_dec ; UWORD32 u4_size = ps_ip -> s_ivd_video_decode_ip_t . u4_num_Bytes ; ps_dec = ( dec_state_t * ) pv_dec ; ps_op -> s_ivd_video_decode_op_t . u4_error_code = 0 ; if ( u4_size > MAX_BITSTREAM_BUFFER_SIZE ) { u4_size = MAX_BITSTREAM_BUFFER_SIZE ; } memcpy ( ps_dec -> pu1_input_buffer , ps_ip -> s_ivd_video_decode_ip_t . pv_stream_buffer , u4_size ) ; impeg2d_bit_stream_init ( & ( ps_dec -> s_bit_stream ) , ps_dec -> pu1_input_buffer , u4_size ) ; { { IMPEG2D_ERROR_CODES_T e_error ; e_error = impeg2d_process_video_header ( ps_dec ) ; if ( ( IMPEG2D_ERROR_CODES_T ) IVD_ERROR_NONE != e_error ) { ps_op -> s_ivd_video_decode_op_t . u4_error_code = e_error ; u4_bits_read = impeg2d_bit_stream_num_bits_read ( & ps_dec -> s_bit_stream ) ; ps_op -> s_ivd_video_decode_op_t . u4_num_bytes_consumed = u4_bits_read >> 3 ; if ( ps_op -> s_ivd_video_decode_op_t . u4_num_bytes_consumed > ps_ip -> s_ivd_video_decode_ip_t . u4_num_Bytes ) { ps_op -> s_ivd_video_dec
",0,511
991,"bool layer_resize ( int layer , int x_size , int y_size ) { int old_height ; int old_width ; struct map_tile * tile ; int tile_width ; int tile_height ; struct map_tile * tilemap ; struct map_trigger * trigger ; struct map_zone * zone ; size_t tilemap_size ; int x , y , i ; old_width = s_map -> layers [ layer ] . width ; old_height = s_map -> layers [ layer ] . height ; tilemap_size = x_size * y_size * sizeof ( struct map_tile ) ; if ( ! ( tilemap = malloc ( tilemap_size ) ) ) return false ; for ( x = 0 ; x < x_size ; ++ x ) { for ( y = 0 ; y < y_size ; ++ y ) { if ( x < old_width && y < old_height ) { tilemap [ x + y * x_size ] = s_map -> layers [ layer ] . tilemap [ x + y * old_width ] ; } else { tile = & tilemap [ x + y * x_size ] ; tile -> frames_left = tileset_get_delay ( s_map -> tileset , 0 ) ; tile -> tile_index = 0 ; } } } free ( s_map -> layers [ layer ] . tilemap ) ; s_map -> layers [ layer ] . tilemap = tilemap ; s_map -> layers [ layer ] . width = x_size ; s_map -> layers [ layer ] . height = y_size ; tileset_get_size ( s_map -> tileset , & tile_width , & tile_height ) ; s_map -> width = 0 ; s_map -> height = 0 ; for ( i = 0 ; i < s_map -> num_layers ; ++ i ) { if ( ! s_map -> layers [ i ] . is_parallax ) { s_map -> width = fmax ( s_map -> width , s_map -> layers [ i ] . width * tile_width ) ; s_map -> height = fmax ( s_map -> height , s_map -> layers [ i ] . height * tile_height ) ; } } for ( i = ( int ) vector_len ( s_map -> zones ) -
",0,511
992,"static int ip_printroute ( netdissect_options * ndo , register const u_char * cp , u_int length ) { register u_int ptr ; register u_int len ; if ( length < 3 ) { ND_PRINT ( ( ndo , ""[badlength%u]"" , length ) ) ; return ( 0 ) ; } if ( ( length + 1 ) & 3 ) ND_PRINT ( ( ndo , ""[badlength%u]"" , length ) ) ; ND_TCHECK ( cp [ 2 ] ) ; ptr = cp [ 2 ] - 1 ; if ( ptr < 3 || ( ( ptr + 1 ) & 3 ) || ptr > length + 1 ) ND_PRINT ( ( ndo , ""[badptr%u]"" , cp [ 2 ] ) ) ; for ( len = 3 ; len < length ; len += 4 ) { ND_TCHECK2 ( cp [ len ] , 4 ) ; ND_PRINT ( ( ndo , ""%s"" , ipaddr_string ( ndo , & cp [ len ] ) ) ) ; if ( ptr > len ) ND_PRINT ( ( ndo , "","" ) ) ; } return ( 0 ) ; trunc : return ( - 1 ) ; }
",1,265
993,"static char * print_string ( cJSON * item , printbuffer * p ) { return print_string_ptr ( item -> valuestring , p ) ; }
",1,37
994,"vpx_codec_err_t vpx_codec_encode ( vpx_codec_ctx_t * ctx , const vpx_image_t * img , vpx_codec_pts_t pts , unsigned long duration , vpx_enc_frame_flags_t flags , unsigned long deadline ) { vpx_codec_err_t res = VPX_CODEC_OK ; if ( ! ctx || ( img && ! duration ) ) res = VPX_CODEC_INVALID_PARAM ; else if ( ! ctx -> iface || ! ctx -> priv ) res = VPX_CODEC_ERROR ; else if ( ! ( ctx -> iface -> caps & VPX_CODEC_CAP_ENCODER ) ) res = VPX_CODEC_INCAPABLE ; else { unsigned int num_enc = ctx -> priv -> enc . total_encoders ; FLOATING_POINT_INIT ( ) ; if ( num_enc == 1 ) res = ctx -> iface -> enc . encode ( get_alg_priv ( ctx ) , img , pts , duration , flags , deadline ) ; else { int i ; ctx += num_enc - 1 ; if ( img ) img += num_enc - 1 ; for ( i = num_enc - 1 ; i >= 0 ; i -- ) { if ( ( res = ctx -> iface -> enc . encode ( ctx -> priv -> alg_priv , img , pts , duration , flags , deadline ) ) ) break ; ctx -- ; if ( img ) img -- ; } ctx ++ ; } FLOATING_POINT_RESTORE ( ) ; } return SAVE_STATUS ( ctx , res ) ; }
",0,393
995,"int main ( int argc , char * * argv ) { char * filein , * str , * tempfile , * prestring , * outprotos , * protostr ; const char * spacestr = """" ; char buf [ L_BUFSIZE ] ; l_uint8 * allheaders ; l_int32 i , maxindex , in_line , nflags , protos_added , firstfile , len , ret ; size_t nbytes ; L_BYTEA * ba , * ba2 ; SARRAY * sa , * safirst ; static char mainName [ ] = ""xtractprotos"" ; if ( argc == 1 ) { fprintf ( stderr , ""xtractprotos[-prestring=<string>][-protos=<where>]"" ""[listofCfiles]\\n"" ""wheretheprestringisprependedtoeachprototype,and\\n"" ""protoscanbeeither\'inline\'orthenameofanoutput"" ""prototypefile\\n"" ) ; return 1 ; } prestring = outprotos = NULL ; in_line = FALSE ; nflags = 0 ; maxindex = L_MIN ( 3 , argc ) ; for ( i = 1 ; i < maxindex ; i ++ ) { if ( argv [ i ] [ 0 ] == '-' ) { if ( ! strncmp ( argv [ i ] , ""-prestring"" , 10 ) ) { nflags ++ ; ret = sscanf ( argv [ i ] + 1 , ""prestring=%490s"" , buf ) ; if ( ret != 1 ) { fprintf ( stderr , ""parsefailureforprestring\\n"" ) ; return 1 ; } if ( ( len = strlen ( buf ) ) > L_BUFSIZE - 3 ) { L_WARNING ( ""prestringtoolarge;omitting
",0,411
996,"static unsigned char * read_chunk ( struct mschm_decompressor_p * self , struct mschmd_header * chm , struct mspack_file * fh , unsigned int chunk_num ) { struct mspack_system * sys = self -> system ; unsigned char * buf ; if ( chunk_num >= chm -> num_chunks ) return NULL ; if ( ! chm -> chunk_cache ) { size_t size = sizeof ( unsigned char * ) * chm -> num_chunks ; if ( ! ( chm -> chunk_cache = ( unsigned char * * ) sys -> alloc ( sys , size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } memset ( chm -> chunk_cache , 0 , size ) ; } if ( chm -> chunk_cache [ chunk_num ] ) return chm -> chunk_cache [ chunk_num ] ; if ( ! ( buf = ( unsigned char * ) sys -> alloc ( sys , chm -> chunk_size ) ) ) { self -> error = MSPACK_ERR_NOMEMORY ; return NULL ; } if ( sys -> seek ( fh , ( off_t ) ( chm -> dir_offset + ( chunk_num * chm -> chunk_size ) ) , MSPACK_SYS_SEEK_START ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } if ( sys -> read ( fh , buf , ( int ) chm -> chunk_size ) != ( int ) chm -> chunk_size ) { self -> error = MSPACK_ERR_READ ; sys -> free ( buf ) ; return NULL ; } if ( ! ( ( buf [ 0 ] == 0x50 ) && ( buf [ 1 ] == 0x4D ) && ( buf [ 2 ] == 0x47 ) && ( ( buf [ 3 ] == 0x4C ) || ( buf [ 3 ] == 0x49 ) ) ) ) ) { self -> error = MSPACK_ERR_SEEK ; sys -> free ( buf ) ; return NULL ; } return chm -> chunk_cache [ chunk_num ] = buf ; }
",0,494
997,"static int validate_group ( struct perf_event * event ) { struct perf_event * sibling , * leader = event -> group_leader ; struct pmu_hw_events fake_pmu ; DECLARE_BITMAP ( fake_used_mask , ARMPMU_MAX_HWEVENTS ) ; memset ( fake_used_mask , 0 , sizeof ( fake_used_mask ) ) ; fake_pmu . used_mask = fake_used_mask ; if ( ! validate_event ( event -> pmu , & fake_pmu , leader ) ) return - EINVAL ; list_for_each_entry ( sibling , & leader -> sibling_list , group_entry ) { if ( ! validate_event ( event -> pmu , & fake_pmu , sibling ) ) return - EINVAL ; } if ( ! validate_event ( event -> pmu , & fake_pmu , event ) ) return - EINVAL ; return 0 ; }
",1,212
998,"static void do_winop ( void ) { int arg1 = term . csi_argv [ 1 ] , arg2 = term . csi_argv [ 2 ] ; if ( * cfg . suppress_win && contains ( cfg . suppress_win , term . csi_argv [ 0 ] ) ) return ; switch ( term . csi_argv [ 0 ] ) { when 1 : win_set_iconic ( false ) ; when 2 : win_set_iconic ( true ) ; when 3 : win_set_pos ( arg1 , arg2 ) ; when 4 : win_set_pixels ( arg1 , arg2 ) ; when 5 : if ( term . csi_argc != 1 ) return ; win_set_zorder ( true ) ; when 6 : if ( term . csi_argc != 1 ) return ; win_set_zorder ( false ) ; when 7 : win_invalidate_all ( false ) ; when 8 : { int def1 = term . csi_argv_defined [ 1 ] , def2 = term . csi_argv_defined [ 2 ] ; int rows , cols ; win_get_screen_chars ( & rows , & cols ) ; win_set_chars ( arg1 ? : def1 ? rows : term . rows , arg2 ? : def2 ? cols : term . cols ) ; } when 9 : { if ( term . csi_argc != 2 ) return ; int rows0 = term . rows0 , cols0 = term . cols0 ; if ( arg1 == 2 ) { win_set_geom ( 0 , - 1 , 0 , - 1 ) ; term . rows0 = rows0 ; term . cols0 = cols0 ; } else if ( arg1 == 3 ) { win_set_geom ( - 1 , 0 , - 1 , 0 ) ; term . rows0 = rows0 ; term . cols0 = cols0 ; } else if ( arg1 == 1 ) { win_maximise ( 1 ) ; term . rows0 = rows0 ; term . cols0 = cols0 ; } else if ( arg1 == 0 ) { win_maximise ( 0 ) ; win_set_chars ( rows0 , cols0 ) ; } }
",0,511
999,"int ff_mpeg4_decode_picture_header ( Mpeg4DecContext * ctx , GetBitContext * gb ) { MpegEncContext * s = & ctx -> m ; unsigned startcode , v ; int ret ; int vol = 0 ; align_get_bits ( gb ) ; if ( ! s -> studio_profile && s -> avctx -> bits_per_raw_sample != 8 ) s -> avctx -> bits_per_raw_sample = 0 ; if ( s -> codec_tag == AV_RL32 ( ""WV1F"" ) && show_bits ( gb , 24 ) == 0x575630 ) { skip_bits ( gb , 24 ) ; if ( get_bits ( gb , 8 ) == 0xF0 ) goto end ; } startcode = 0xff ; for ( ; ; ) { if ( get_bits_count ( gb ) >= gb -> size_in_bits ) { if ( gb -> size_in_bits == 8 && ( ctx -> divx_version >= 0 || ctx -> xvid_build >= 0 ) || s -> codec_tag == AV_RL32 ( ""QMP4"" ) ) { av_log ( s -> avctx , AV_LOG_VERBOSE , ""frameskip%d\\n"" , gb -> size_in_bits ) ; return FRAME_SKIPPED ; } else return AVERROR_INVALIDDATA ; } v = get_bits ( gb , 8 ) ; startcode = ( ( startcode << 8 ) | v ) & 0xffffffff ; if ( ( startcode & 0xFFFFFF00 ) != 0x100 ) continue ; if ( s -> avctx -> debug & FF_DEBUG_STARTCODE ) { av_log ( s -> avctx , AV_LOG_DEBUG , ""startcode:%3X"" , startcode ) ; if ( startcode <= 0x11F ) av_log ( s -> avctx , AV_LOG_DEBUG , ""VideoObjectStart"" ) ; else if ( startcode <= 0x12F ) av_log ( s -> avctx , AV_LOG_DEBUG , ""VideoObjectLayerStart"" ) ; else if ( startcode <= 0x13F ) av_log ( s -> avctx , AV_LOG_DEBUG , ""Res
",0,511
1000,"asmlinkage long sys_oabi_semtimedop ( int semid , struct oabi_sembuf __user * tsops , unsigned nsops , const struct timespec __user * timeout ) { struct sembuf * sops ; struct timespec local_timeout ; long err ; int i ; if ( nsops < 1 || nsops > SEMOPM ) return - EINVAL ; sops = kmalloc ( sizeof ( * sops ) * nsops , GFP_KERNEL ) ; if ( ! sops ) return - ENOMEM ; err = 0 ; for ( i = 0 ; i < nsops ; i ++ ) { __get_user_error ( sops [ i ] . sem_num , & tsops -> sem_num , err ) ; __get_user_error ( sops [ i ] . sem_op , & tsops -> sem_op , err ) ; __get_user_error ( sops [ i ] . sem_flg , & tsops -> sem_flg , err ) ; tsops ++ ; } if ( timeout ) { err |= copy_from_user ( & local_timeout , timeout , sizeof ( * timeout ) ) ; timeout = & local_timeout ; } if ( err ) { err = - EFAULT ; } else { mm_segment_t fs = get_fs ( ) ; set_fs ( KERNEL_DS ) ; err = sys_semtimedop ( semid , sops , nsops , timeout ) ; set_fs ( fs ) ; } kfree ( sops ) ; return err ; }
",1,347
1001,"void vp8_mbpost_proc_across_ip_c ( unsigned char * src , int pitch , int rows , int cols , int flimit ) { int r , c , i ; unsigned char * s = src ; unsigned char d [ 16 ] ; for ( r = 0 ; r < rows ; r ++ ) { int sumsq = 0 ; int sum = 0 ; for ( i = - 8 ; i < 0 ; i ++ ) s [ i ] = s [ 0 ] ; for ( i = cols ; i < cols + 17 ; i ++ ) s [ i ] = s [ cols - 1 ] ; for ( i = - 8 ; i <= 6 ; i ++ ) { sumsq += s [ i ] * s [ i ] ; sum += s [ i ] ; d [ i + 8 ] = 0 ; } for ( c = 0 ; c < cols + 8 ; c ++ ) { int x = s [ c + 7 ] - s [ c - 8 ] ; int y = s [ c + 7 ] + s [ c - 8 ] ; sum += x ; sumsq += x * y ; d [ c & 15 ] = s [ c ] ; if ( sumsq * 15 - sum * sum < flimit ) { d [ c & 15 ] = ( 8 + sum + s [ c ] ) >> 4 ; } s [ c - 8 ] = d [ ( c - 8 ) & 15 ] ; } s += pitch ; } }
",0,320
1002,"static grub_disk_addr_t grub_ext2_read_block ( grub_fshelp_node_t node , grub_disk_addr_t fileblock ) { struct grub_ext2_data * data = node -> data ; struct grub_ext2_inode * inode = & node -> inode ; int blknr = - 1 ; unsigned int blksz = EXT2_BLOCK_SIZE ( data ) ; int log2_blksz = LOG2_EXT2_BLOCK_SIZE ( data ) ; if ( grub_le_to_cpu32 ( inode -> flags ) & EXT4_EXTENTS_FLAG ) { # ifndef _MSC_VER char buf [ EXT2_BLOCK_SIZE ( data ) ] ; # else char * buf = grub_malloc ( EXT2_BLOCK_SIZE ( data ) ) ; # endif struct grub_ext4_extent_header * leaf ; struct grub_ext4_extent * ext ; int i ; leaf = grub_ext4_find_leaf ( data , buf , ( struct grub_ext4_extent_header * ) inode -> blocks . dir_blocks , fileblock ) ; if ( ! leaf ) { grub_error ( GRUB_ERR_BAD_FS , ""invalidextent"" ) ; return - 1 ; } ext = ( struct grub_ext4_extent * ) ( leaf + 1 ) ; for ( i = 0 ; i < grub_le_to_cpu16 ( leaf -> entries ) ; i ++ ) { if ( fileblock < grub_le_to_cpu32 ( ext [ i ] . block ) ) break ; } if ( -- i >= 0 ) { fileblock -= grub_le_to_cpu32 ( ext [ i ] . block ) ; if ( fileblock >= grub_le_to_cpu16 ( ext [ i ] . len ) ) return 0 ; else { grub_disk_addr_t start ; start = grub_le_to_cpu16 ( ext [ i ] . start_hi ) ; start = ( start << 32 ) + grub_le_to_cpu32 ( ext [ i ] . start ) ; return fileblock + start ; } } else { grub_error
",0,511
1003,"static int DecodeGifImg ( struct ngiflib_img * i ) { struct ngiflib_decode_context context ; long npix ; u8 * stackp ; u8 * stack_top ; u16 clr ; u16 eof ; u16 free ; u16 act_code = 0 ; u16 old_code = 0 ; u16 read_byt ; u16 ab_prfx [ 4096 ] ; u8 ab_suffx [ 4096 ] ; u8 ab_stack [ 4096 ] ; u8 flags ; u8 casspecial = 0 ; if ( ! i ) return - 1 ; i -> posX = GetWord ( i -> parent ) ; i -> posY = GetWord ( i -> parent ) ; i -> width = GetWord ( i -> parent ) ; i -> height = GetWord ( i -> parent ) ; if ( ( i -> width > i -> parent -> width ) || ( i -> height > i -> parent -> height ) ) { # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent -> log ) fprintf ( i -> parent -> log , ""***ERROR***ImagebiggerthanglobalGIFcanvas
",0,258
1004,"int cdf_read_property_info ( const cdf_stream_t * sst , const cdf_header_t * h , uint32_t offs , cdf_property_info_t * * info , size_t * count , size_t * maxcount ) { const cdf_section_header_t * shp ; cdf_section_header_t sh ; const uint8_t * p , * q , * e ; int16_t s16 ; int32_t s32 ; uint32_t u32 ; int64_t s64 ; uint64_t u64 ; cdf_timestamp_t tp ; size_t i , o , o4 , nelements , j ; cdf_property_info_t * inp ; if ( offs > UINT32_MAX / 4 ) { errno = EFTYPE ; goto out ; } shp = CAST ( const cdf_section_header_t * , ( const void * ) ( ( const char * ) sst -> sst_tab + offs ) ) ; if ( cdf_check_stream_offset ( sst , h , shp , sizeof ( * shp ) , __LINE__ ) == - 1 ) goto out ; sh . sh_len = CDF_TOLE4 ( shp -> sh_len ) ; # define CDF_SHLEN_LIMIT ( UINT32_MAX / 8 ) if ( sh . sh_len > CDF_SHLEN_LIMIT ) { errno = EFTYPE ; goto out ; } sh . sh_properties = CDF_TOLE4 ( shp -> sh_properties ) ; # define CDF_PROP_LIMIT ( UINT32_MAX / ( 4 * sizeof ( * inp ) ) ) if ( sh . sh_properties > CDF_PROP_LIMIT ) goto out ; DPRINTF ( ( ""sectionlen:%uproperties%u\\n"" , sh . sh_len , sh . sh_properties ) ) ; if ( * maxcount ) { if ( * maxcount > CDF_PROP_LIMIT ) goto out ; * maxcount += sh . sh_properties ; inp = CAST ( cdf_property_info_t * , realloc (
",0,511
1005,"int yr_re_fast_exec ( uint8_t * code , uint8_t * input_data , size_t input_forwards_size , size_t input_backwards_size , int flags , RE_MATCH_CALLBACK_FUNC callback , void * callback_args , int * matches ) { RE_REPEAT_ANY_ARGS * repeat_any_args ; uint8_t * code_stack [ MAX_FAST_RE_STACK ] ; uint8_t * input_stack [ MAX_FAST_RE_STACK ] ; int matches_stack [ MAX_FAST_RE_STACK ] ; uint8_t * ip = code ; uint8_t * input = input_data ; uint8_t * next_input ; uint8_t * next_opcode ; uint8_t mask ; uint8_t value ; int i ; int stop ; int input_incr ; int sp = 0 ; int bytes_matched ; int max_bytes_matched ; max_bytes_matched = flags & RE_FLAGS_BACKWARDS ? ( int ) input_backwards_size : ( int ) input_forwards_size ; input_incr = flags & RE_FLAGS_BACKWARDS ? - 1 : 1 ; if ( flags & RE_FLAGS_BACKWARDS ) input -- ; code_stack [ sp ] = code ; input_stack [ sp ] = input ; matches_stack [ sp ] = 0 ; sp ++ ; while ( sp > 0 ) { sp -- ; ip = code_stack [ sp ] ; input = input_stack [ sp ] ; bytes_matched = matches_stack [ sp ] ; stop = FALSE ; while ( ! stop ) { if ( * ip == RE_OPCODE_MATCH ) { if ( flags & RE_FLAGS_EXHAUSTIVE ) { FAIL_ON_ERROR ( callback ( flags & RE_FLAGS_BACKWARDS ? input + 1 : input_data , bytes_matched , flags , callback_args ) ) ; break ; } else { if ( matches != NULL ) * matches = bytes_matched ; return ERROR_SUCCESS ; } } if ( bytes_matched >= max_bytes_matched ) break ; switch ( * ip ) { case RE_OPCODE_LITERAL : if ( * input
",0,511
1006,"void jslTokenAsString ( int token , char * str , size_t len ) { if ( token == 32 && token < 128 ) { assert ( len >= 4 ) ; str [ 0 ] = '\\'' ; str [ 1 ] = ( char ) token ; str [ 2 ] = '\\'' ; str [ 3 ] = 0 ; return ; } switch ( token ) { case LEX_EOF : strncpy ( str , ""EOF"" , len ) ; return ; case LEX_ID : strncpy ( str , ""ID"" , len ) ; return ; case LEX_INT : strncpy ( str , ""INT"" , len ) ; return ; case LEX_FLOAT : strncpy ( str , ""FLOAT"" , len ) ; return ; case LEX_STR : strncpy ( str , ""STRING"" , len ) ; return ; case LEX_UNFINISHED_STR : strncpy ( str , ""UNFINISHEDSTRING"" , len ) ; return ; case LEX_TEMPLATE_LITERAL : strncpy ( str , ""TEMPLATELITERAL"" , len ) ; return ; case LEX_UNFINISHED_TEMPLATE_LITERAL : strncpy ( str , ""UNFINISHEDTEMPLATELITERAL"" , len ) ; return ; case LEX_REGEX : strncpy ( str , ""REGEX"" , len ) ; return ; case LEX_UNFINISHED_REGEX : strncpy ( str , ""UNFINISHEDREGEX"" , len ) ; return ; case LEX_UNFINISHED_COMMENT : strncpy ( str , ""UNFINISHEDCOMMENT"" , len ) ; return ; } if ( token >= _LEX_OPERATOR_START && token < _LEX_R_LIST_END ) { const char tokenNames [ ] = ""==\\0"" ""===\\0"" ""
",0,435
1007,"static void mntput_no_expire ( struct mount * mnt ) { rcu_read_lock ( ) ; mnt_add_count ( mnt , - 1 ) ; if ( likely ( mnt -> mnt_ns ) ) { rcu_read_unlock ( ) ; return ; } lock_mount_hash ( ) ; if ( mnt_get_count ( mnt ) ) { rcu_read_unlock ( ) ; unlock_mount_hash ( ) ; return ; } if ( unlikely ( mnt -> mnt . mnt_flags & MNT_DOOMED ) ) { rcu_read_unlock ( ) ; unlock_mount_hash ( ) ; return ; } mnt -> mnt . mnt_flags |= MNT_DOOMED ; rcu_read_unlock ( ) ; list_del ( & mnt -> mnt_instance ) ; if ( unlikely ( ! list_empty ( & mnt -> mnt_mounts ) ) ) { struct mount * p , * tmp ; list_for_each_entry_safe ( p , tmp , & mnt -> mnt_mounts , mnt_child ) { umount_mnt ( p ) ; } } unlock_mount_hash ( ) ; if ( likely ( ! ( mnt -> mnt . mnt_flags & MNT_INTERNAL ) ) ) { struct task_struct * task = current ; if ( likely ( ! ( task -> flags & PF_KTHREAD ) ) ) { init_task_work ( & mnt -> mnt_rcu , __cleanup_mnt ) ; if ( ! task_work_add ( task , & mnt -> mnt_rcu , true ) ) return ; } if ( llist_add ( & mnt -> mnt_llist , & delayed_mntput_list ) ) schedule_delayed_work ( & delayed_mntput_work , 1 ) ; return ; } cleanup_mnt ( mnt ) ; }
",1,444
1008,"static void encode_term_subexp ( vpx_writer * w , int word ) { if ( ! write_bit_gte ( w , word , 16 ) ) { vpx_write_literal ( w , word , 4 ) ; } else if ( ! write_bit_gte ( w , word , 32 ) ) { vpx_write_literal ( w , word - 16 , 4 ) ; } else if ( ! write_bit_gte ( w , word , 64 ) ) { vpx_write_literal ( w , word - 32 , 5 ) ; } else { encode_uniform ( w , word - 64 ) ; } }
",1,145
1009,"enum nss_status _nss_mymachines_getpwnam_r ( const char * name , struct passwd * pwd , char * buffer , size_t buflen , int * errnop ) { _cleanup_bus_error_free_ sd_bus_error error = SD_BUS_ERROR_NULL ; _cleanup_bus_message_unref_ sd_bus_message * reply = NULL ; _cleanup_bus_flush_close_unref_ sd_bus * bus = NULL ; const char * p , * e , * machine ; uint32_t mapped ; uid_t uid ; size_t l ; int r ; assert ( name ) ; assert ( pwd ) ; p = startswith ( name , ""vu-"" ) ; if ( ! p ) goto not_found ; e = strrchr ( p , '-' ) ; if ( ! e || e == p ) goto not_found ; r = parse_uid ( e + 1 , & uid ) ; if ( r < 0 ) goto not_found ; machine = strndupa ( p , e - p ) ; if ( ! machine_name_is_valid ( machine ) ) goto not_found ; r = sd_bus_open_system ( & bus ) ; if ( r < 0 ) goto fail ; r = sd_bus_call_method ( bus , ""org.freedesktop.machine1"" , ""/org/freedesktop/machine1"" , ""org.freedesktop.machine1.Manager"" , ""MapFromMachineUser"" , & error , & reply , ""su"" , machine , ( uint32_t ) uid ) ; if ( r < 0 ) { if ( sd_bus_error_has_name ( & error , BUS_ERROR_NO_SUCH_USER_MAPPING ) ) goto not_found ; goto fail ; } r = sd_bus_message_read ( reply , ""u"" , & mapped ) ; if ( r < 0 ) goto fail ; l = strlen ( name ) ; if ( buflen < l + 1 ) { * errnop = ENOMEM ; return NSS_STATUS_TRYAGAIN ; } memcpy ( buffer , name , l + 1 ) ; pwd -> pw_name = name
",0,511
1010,"static int udf_symlink_filler ( struct file * file , struct page * page ) { struct inode * inode = page -> mapping -> host ; struct buffer_head * bh = NULL ; unsigned char * symlink ; size_t pos ; iinfo = UDF_I ( inode ) ; pos = udf_block_map ( inode , 0 ) ; down_read ( & iinfo -> i_data_sem ) ; if ( iinfo -> i_alloc_type == ICBTAG_FLAG_AD_IN_ICB ) { symlink = iinfo -> i_ext . i_data + iinfo -> i_lenEAttr ; } else { bh = sb_bread ( inode -> i_sb , pos ) ; if ( ! bh ) goto out ; symlink = bh -> b_data ; } udf_pc_to_char ( inode -> i_sb , symlink , inode -> i_size , p ) ; brelse ( bh ) ; up_read ( & iinfo -> i_data_sem ) ; SetPageUptodate ( page ) ; kunmap ( page ) ; unlock_page ( page ) ; return 0 ; out : up_read ( & iinfo -> i_data_sem ) ; SetPageError ( page ) ; kunmap ( page ) ; unlock_page ( page ) ; return err ; }
",0,315
1011,"static void vmx_set_msr_bitmap ( struct kvm_vcpu * vcpu ) { unsigned long * msr_bitmap ; if ( is_guest_mode ( vcpu ) ) msr_bitmap = vmx_msr_bitmap_nested ; else if ( cpu_has_secondary_exec_ctrls ( ) ) { if ( is_long_mode ( vcpu ) ) msr_bitmap = vmx_msr_bitmap_longmode_x2apic ; else msr_bitmap = vmx_msr_bitmap_legacy_x2apic ; } else { if ( is_long_mode ( vcpu ) ) msr_bitmap = vmx_msr_bitmap_longmode ; else msr_bitmap = vmx_msr_bitmap_legacy ; } vmcs_write64 ( MSR_BITMAP , __pa ( msr_bitmap ) ) ; }
",0,218
1012,"static krb5_error_code krb5_ldap_get_password_policy_from_dn ( krb5_context context , char * pol_name , char * pol_dn , osa_policy_ent_t * policy ) { krb5_error_code st = 0 , tempst = 0 ; LDAP * ld = NULL ; LDAPMessage * result = NULL , * ent = NULL ; kdb5_dal_handle * dal_handle = NULL ; krb5_ldap_context * ldap_context = NULL ; krb5_ldap_server_handle * ldap_server_handle = NULL ; krb5_clear_error_message ( context ) ; if ( pol_dn == NULL ) return EINVAL ; * policy = NULL ; SETUP_CONTEXT ( ) ; GET_HANDLE ( ) ; * ( policy ) = ( osa_policy_ent_t ) malloc ( sizeof ( osa_policy_ent_rec ) ) ; if ( * policy == NULL ) { st = ENOMEM ; goto cleanup ; } memset ( * policy , 0 , sizeof ( osa_policy_ent_rec ) ) ; LDAP_SEARCH ( pol_dn , LDAP_SCOPE_BASE , ""(objectclass=krbPwdPolicy)"" , password_policy_attributes ) ; ent = ldap_first_entry ( ld , result ) ; if ( ent == NULL ) { st = KRB5_KDB_NOENTRY ; goto cleanup ; } st = populate_policy ( context , ld , ent , pol_name , * policy ) ; cleanup : ldap_msgfree ( result ) ; if ( st != 0 ) { if ( * policy != NULL ) { krb5_ldap_free_password_policy ( context , * policy ) ; * policy = NULL ; } } krb5_ldap_put_handle_to_pool ( ldap_context , ldap_server_handle ) ; return st ; }
",1,450
1013,"IHEVCD_ERROR_T ihevcd_parse_pps ( codec_t * ps_codec ) { IHEVCD_ERROR_T ret = ( IHEVCD_ERROR_T ) IHEVCD_SUCCESS ; WORD32 value ; WORD32 pps_id ; pps_t * ps_pps ; sps_t * ps_sps ; bitstrm_t * ps_bitstrm = & ps_codec -> s_parse . s_bitstrm ; if ( 0 == ps_codec -> i4_sps_done ) return IHEVCD_INVALID_HEADER ; UEV_PARSE ( ""pic_parameter_set_id"" , value , ps_bitstrm ) ; pps_id = value ; if ( ( pps_id >= MAX_PPS_CNT ) || ( pps_id < 0 ) ) { if ( ps_codec -> i4_pps_done ) return IHEVCD_UNSUPPORTED_PPS_ID ; else pps_id = 0 ; } ps_pps = ( ps_codec -> s_parse . ps_pps_base + MAX_PPS_CNT - 1 ) ; ps_pps -> i1_pps_id = pps_id ; UEV_PARSE ( ""seq_parameter_set_id"" , value , ps_bitstrm ) ; ps_pps -> i1_sps_id = value ; ps_pps -> i1_sps_id = CLIP3 ( ps_pps -> i1_sps_id , 0 , MAX_SPS_CNT - 2 ) ; ps_sps = ( ps_codec -> s_parse . ps_sps_base + ps_pps -> i1_sps_id ) ; if ( 0 == ps_sps -> i1_sps_valid ) { return IHEVCD_INVALID_HEADER ; } BITS_PARSE ( ""dependent_slices_enabled_flag"" , value , ps_bitstrm , 1 ) ; ps_pps -> i1_dependent_slice_enabled_flag = value ; BITS_PARSE ( ""output_flag_present_flag"" , value , ps_bitstrm ,
",0,511
1014,"static int gfs2_bmap_alloc ( struct inode * inode , const sector_t lblock , struct buffer_head * bh_map , struct metapath * mp , const unsigned int sheight , const unsigned int height , const unsigned int maxlen ) { struct gfs2_inode * ip = GFS2_I ( inode ) ; struct gfs2_sbd * sdp = GFS2_SB ( inode ) ; struct buffer_head * dibh ; u64 bn , dblock = 0 ; unsigned n , i , blks , alloced = 0 , iblks = 0 , branch_start = 0 ; unsigned dblks = 0 ; unsigned ptrs_per_blk ; const unsigned end_of_metadata = height - 1 ; int eob = 0 ; enum alloc_state state ; __be64 * ptr ; __be64 zero_bn = 0 ; BUG_ON ( sheight < 1 ) ; BUG_ON ( dibh == NULL ) ; gfs2_trans_add_bh ( ip -> i_gl , dibh , 1 ) ; if ( height == sheight ) { struct buffer_head * bh ; ptr = metapointer ( end_of_metadata , mp ) ; bh = mp -> mp_bh [ end_of_metadata ] ; dblks = gfs2_extent_length ( bh -> b_data , bh -> b_size , ptr , maxlen , & eob ) ; BUG_ON ( dblks < 1 ) ; state = ALLOC_DATA ; } else { ptrs_per_blk = height > 1 ? sdp -> sd_inptrs : sdp -> sd_diptrs ; dblks = min ( maxlen , ptrs_per_blk - mp -> mp_list [ end_of_metadata ] ) ; if ( height == ip -> i_height ) { if ( bh -> b_size < sizeof ( struct buffer_head ) ) bh -> b_size = sizeof ( struct buffer_head ) - 1 ;iblks = height - sheight ; state = ALLOC_GROW_DEPTH ; } else { state = ALLOC_GROW_HEIGHT ;iblks = height - ip -> i_height ; branch_start = metapath_
",0,511
1015,"int psf_binheader_writef ( SF_PRIVATE * psf , const char * format , ... ) { va_list argptr ; sf_count_t countdata ; unsigned long longdata ; unsigned int data ; float floatdata ; double doubledata ; void * bindata ; size_t size ; char c , * strptr ; int count = 0 , trunc_8to4 ; trunc_8to4 = SF_FALSE ; va_start ( argptr , format ) ; while ( ( c = * format ++ ) ) { switch ( c ) { case '' : break ; case 'e' : psf -> rwf_endian = SF_ENDIAN_LITTLE ; break ; case 'E' : psf -> rwf_endian = SF_ENDIAN_BIG ; break ; case 't' : trunc_8to4 = SF_TRUE ; break ; case 'T' : trunc_8to4 = SF_FALSE ; break ; case 'm' : data = va_arg ( argptr , unsigned int ) ; header_put_marker ( psf , data ) ; count += 4 ; break ; case '1' : data = va_arg ( argptr , unsigned int ) ; header_put_byte ( psf , data ) ; count += 1 ; break ; case '2' : data = va_arg ( argptr , unsigned int ) ; if ( psf -> rwf_endian == SF_ENDIAN_BIG ) { header_put_be_short ( psf , data ) ; } else { header_put_le_short ( psf , data ) ; } ; count += 2 ; break ; case '3' : data = va_arg ( argptr , unsigned int ) ; if ( psf -> rwf_endian == SF_ENDIAN_BIG ) { header_put_be_3byte ( psf , data ) ; } else { header_put_le_3byte ( psf , data ) ; } ; count += 3 ; break ; case '4' : data = va_arg ( argptr , unsigned int ) ; if ( psf -> rwf_endian == SF_ENDIAN_BIG ) { header_put_be_int ( psf , data ) ; } else { header_put_le_3
",0,511
1016,"static int cx24116_send_diseqc_msg ( struct dvb_frontend * fe , struct dvb_diseqc_master_cmd * d ) { struct cx24116_state * state = fe -> demodulator_priv ; int i , ret ; if ( d -> msg_len > sizeof ( d -> msg ) ) return - EINVAL ; if ( debug ) { printk ( KERN_INFO ""cx24116:%s("" , __func__ ) ; for ( i = 0 ; i < d -> msg_len ; ) { printk ( KERN_INFO ""0x%02x"" , d -> msg [ i ] ) ; if ( ++ i < d -> msg_len ) printk ( KERN_INFO "","" ) ; } for ( i = 0 ; i < d -> msg_len ; i ++ ) state -> dsec_cmd . args [ CX24116_DISEQC_MSGOFS + i ] = d -> msg [ i ] ; state -> dsec_cmd . args [ CX24116_DISEQC_MSGLEN ] = d -> msg_len ; state -> dsec_cmd . len = CX24116_DISEQC_MSGOFS + state -> dsec_cmd . args [ CX24116_DISEQC_MSGLEN ] ; if ( toneburst == CX24116_DISEQC_MESGCACHE ) return 0 ; else if ( toneburst == CX24116_DISEQC_TONEOFF ) state -> dsec_cmd . args [ CX24116_DISEQC_BURST ] = 0 ; else if ( toneburst == CX24116_DISEQC_TONECACHE ) { if ( d -> msg_len >= 4 && d -> msg [ 2 ] == 0x38 ) state -> dsec_cmd . args [ CX24116_DISEQC_BURST ] = ( ( d -> msg [ 3 ] & 4 ) >> 2 ) ; if ( debug ) dprintk ( ""%sburst=%d\\n"" , __func__ , state -> dsec_cmd . args [ CX24116_DISEQC_BURST ] ) ; } ret = cx24116_wait_for_lnb
",0,511
1017,"static int sco_sock_getsockopt_old ( struct socket * sock , int optname , char __user * optval , int __user * optlen ) { struct sock * sk = sock -> sk ; struct sco_options opts ; struct sco_conninfo cinfo ; int len , err = 0 ; BT_DBG ( ""sk%p"" , sk ) ; if ( get_user ( len , optlen ) ) return - EFAULT ; lock_sock ( sk ) ; switch ( optname ) { case SCO_OPTIONS : if ( sk -> sk_state != BT_CONNECTED ) { err = - ENOTCONN ; break ; } memset ( & cinfo , 0 , sizeof ( cinfo ) ) ; opts . mtu = sco_pi ( sk ) -> conn -> mtu ; BT_DBG ( ""mtu%d"" , opts . mtu ) ; len = min_t ( unsigned int , len , sizeof ( opts ) ) ; if ( copy_to_user ( optval , ( char * ) & opts , len ) ) err = - EFAULT ; break ; case SCO_CONNINFO : if ( sk -> sk_state != BT_CONNECTED ) { err = - ENOTCONN ; break ; } memcpy ( cinfo . dev_class , sco_pi ( sk ) -> conn -> hcon -> dev_class , 3 ) ; len = min_t ( unsigned int , len , sizeof ( cinfo ) ) ; if ( copy_to_user ( optval , ( char * ) & cinfo , len ) ) err = - EFAULT ; break ; default : err = - ENOPROTOOPT ; break ; } release_sock ( sk ) ; return err ; }
",0,393
1018,"static Image * ReadSUNImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define RMT_EQUAL_RGB 1 # define RMT_NONE 0 # define RMT_RAW 2 # define RT_STANDARD 1 # define RT_ENCODED 2 # define RT_FORMAT_RGB 3 typedef struct _SUNInfo { unsigned int magic , width , height , depth , length , type , maptype , maplength ; } SUNInfo ; Image * image ; int bit ; MagickBooleanType status ; MagickSizeType number_pixels ; register Quantum * q ; register ssize_t i , x ; register unsigned char * p ; size_t bytes_per_line , extent , length ; ssize_t count , y ; SUNInfo sun_info ; unsigned char * sun_data , * sun_pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) ResetMagickMemory ( & sun_info , 0 , sizeof ( sun_info ) ) ; sun_info . magic = ReadBlobMSBLong ( image ) ; do { if ( sun_info . magic != 0x59a66a95 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; sun_info . width = ReadBlobMSBLong ( image ) ; sun_info . height = ReadBlobMSBLong ( image ) ; sun_info . depth = ReadBlobMSBLong ( image ) ; sun_info . length = ReadBlobMSBLong ( image ) ; sun_info . type = ReadBlobMSBLong ( image ) ; sun_info . maptype = Read
",0,511
1019,"static int store_xauthority ( void ) { fs_build_mnt_dir ( ) ; char * src ; char * dest = RUN_XAUTHORITY_FILE ; FILE * fp = fopen ( dest , ""w"" ) ; if ( fp ) { fprintf ( fp , ""\\n"" ) ; SET_PERMS_STREAM ( fp , getuid ( ) , getgid ( ) , 0600 ) ; fclose ( fp ) ; } if ( asprintf ( & src , ""%s/.Xauthority"" , cfg . homedir ) == - 1 ) errExit ( ""asprintf"" ) ; struct stat s ; if ( stat ( src , & s ) == 0 ) { if ( is_link ( src ) ) { fprintf ( stderr , ""Warning:invalid.Xauthorityfile\\n"" ) ; return 0 ; } if ( stat ( src , & s ) == 0 ) { if ( is_link ( src ) ) { fprintf ( stderr , ""Warning:cannottransfer.Xauthorityinprivatehomedirectory\\n"" ) ; else { fs_logger2 ( ""clone"" , dest ) ; } _exit ( 0 ) ; } waitpid ( child , NULL , 0 ) ; return 1 ; } return 0 ; }
",0,291
1020,"static gboolean parse_toshiba_packet ( FILE_T fh , struct wtap_pkthdr * phdr , Buffer * buf , int * err , gchar * * err_info ) { union wtap_pseudo_header * pseudo_header = & phdr -> pseudo_header ; char line [ TOSHIBA_LINE_LENGTH ] ; int num_items_scanned ; int pkt_len ; int pktnum , hr , min , sec , csec ; char channel [ 10 ] , direction [ 10 ] ; int i , hex_lines ; guint8 * pd ; if ( file_gets ( line , TOSHIBA_LINE_LENGTH , fh ) == NULL ) { * err = file_error ( fh , err_info ) ; if ( * err == 0 ) { * err = WTAP_ERR_SHORT_READ ; } return FALSE ; } num_items_scanned = sscanf ( line , ""%9d]%2d:%2d:%2d.%9d%9s%9s"" , & pktnum , & hr , & min , & sec , & csec , channel , direction ) ; if ( num_items_scanned != 7 ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( ""toshiba:recordheaderisn\'tvalid"" ) ; return FALSE ; } do { if ( file_gets ( line , TOSHIBA_LINE_LENGTH , fh ) == NULL ) { * err = file_error ( fh , err_info ) ; if ( * err == 0 ) { * err = WTAP_ERR_SHORT_READ ; } return FALSE ; } line [ 16 ] = '\\0' ; } while ( strcmp ( line , ""OFFSET0001-0203"" ) != 0 ) ; num_items_scanned = sscanf ( line + 64 , ""LEN=%9d"" , & pkt_len ) ; if ( num_items_scanned != 1 ) { * err = WTAP_ERR_BAD_FILE ; * err_info = g_strdup ( ""toshiba:OFFSETlinedoesn\'thavevalidLENitem"" ) ;
",0,511
1021,"static int iucv_sock_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t len , int flags ) { int noblock = flags & MSG_DONTWAIT ; struct sock * sk = sock -> sk ; struct iucv_sock * iucv = iucv_sk ( sk ) ; unsigned int copied , rlen ; struct sk_buff * skb , * rskb , * cskb ; int err = 0 ; msg -> msg_namelen = 0 ; if ( ( sk -> sk_state == IUCV_DISCONN ) && skb_queue_empty ( & iucv -> backlog_skb_q ) && skb_queue_empty ( & sk -> sk_receive_queue ) && list_empty ( & iucv -> message_q . list ) ) return 0 ; if ( flags & ( MSG_OOB ) ) return - EOPNOTSUPP ; skb = skb_recv_datagram ( sk , flags , noblock , & err ) ; if ( ! skb ) { if ( sk -> sk_shutdown & RCV_SHUTDOWN ) return 0 ; return err ; } rlen = skb -> len ; copied = min_t ( unsigned int , rlen , len ) ; if ( ! rlen ) sk -> sk_shutdown = sk -> sk_shutdown | RCV_SHUTDOWN ; cskb = skb ; if ( skb_copy_datagram_iovec ( cskb , 0 , msg -> msg_iov , copied ) ) { if ( ! ( flags & MSG_PEEK ) ) skb_queue_head ( & sk -> sk_receive_queue , skb ) ; return - EFAULT ; } if ( sk -> sk_type == SOCK_SEQPACKET ) { if ( copied < rlen ) msg -> msg_flags |= MSG_TRUNC ; msg -> msg_flags |= MSG_EOR ; } err = put_cmsg ( msg , SOL_IUCV , SCM_IUCV_TRGCLS , CB_TRGCLS_LEN , CB_TRGCLS ( skb ) ) ; if ( err ) { if ( ! ( flags &
",0,511
1022,"static inline int process_nested_data ( UNSERIALIZE_PARAMETER , HashTable * ht , long elements , int objprops ) { while ( elements -- > 0 ) { zval * key , * data , * * old_data ; ALLOC_INIT_ZVAL ( key ) ; if ( zend_hash_find ( ht , Z_LVAL_P ( key ) , ( void * * ) & old_data ) == SUCCESS ) { var_push_dtor ( var_hash , old_data ) ; } zend_hash_index_update ( ht , Z_LVAL_P ( key ) , & data , sizeof ( data ) , NULL ) ; break ; case IS_STRING : if ( zend_symtable_find ( ht , Z_STRVAL_P ( key ) , Z_STRLEN_P ( key ) + 1 , ( void * * ) & old_data ) == SUCCESS ) { var_push_dtor ( var_hash , old_data ) ; } zend_symtable_update ( ht , Z_STRVAL_P ( key ) , Z_STRLEN_P ( key ) + 1 , & data , sizeof ( data ) , NULL ) ; break ; } } else { convert_to_string ( key ) ; if ( zend_symtable_find ( ht , Z_STRVAL_P ( key ) , Z_STRLEN_P ( key ) + 1 , ( void * * ) & old_data ) == SUCCESS ) { var_push_dtor ( var_hash , old_data ) ; } zend_hash_update ( ht , Z_STRVAL_P ( key ) , Z_STRLEN_P ( key ) + 1 , & data , sizeof ( data ) , NULL ) ; break ; } } return 0 ; }
",0,416
1023,"static int tipc_nl_compat_link_dump ( struct tipc_nl_compat_msg * msg , struct nlattr * * attrs ) { struct nlattr * link [ TIPC_NLA_LINK_MAX + 1 ] ; struct tipc_link_info link_info ; int err ; if ( ! attrs [ TIPC_NLA_LINK ] ) return - EINVAL ; err = nla_parse_nested ( link , TIPC_NLA_LINK_MAX , attrs [ TIPC_NLA_LINK ] , NULL ) ; if ( err ) return err ; link_info . dest = nla_get_flag ( link [ TIPC_NLA_LINK_DEST ] ) ; link_info . up = htonl ( nla_get_flag ( link [ TIPC_NLA_LINK_UP ] ) ) ; nla_strlcpy ( link_info . str , nla_data ( link [ TIPC_NLA_LINK_NAME ] ) , TIPC_MAX_LINK_NAME ) ; return tipc_add_tlv ( msg -> rep , TIPC_TLV_LINK_INFO , & link_info , sizeof ( link_info ) ) ; }
",1,294
1024,"int ipmi_si_mem_setup ( struct si_sm_io * io ) { unsigned long addr = io -> addr_data ; int mapsize , idx ; if ( ! addr ) return - ENODEV ; switch ( io -> regsize ) { case 1 : io -> inputb = intf_mem_inb ; io -> outputb = intf_mem_outb ; break ; case 2 : io -> inputb = intf_mem_inw ; io -> outputb = intf_mem_outw ; break ; case 4 : io -> inputb = intf_mem_inl ; io -> outputb = intf_mem_outl ; break ; # ifdef readq case 8 : io -> inputb = mem_inq ; io -> outputb = mem_outq ; break ; # endif default : dev_warn ( io -> dev , ""Invalidregistersize:%d\\n"" , io -> regsize ) ; return - EINVAL ; } for ( idx = 0 ; idx < io -> io_size ; idx ++ ) { if ( request_mem_region ( addr + idx * io -> regspacing , io -> regsize , DEVICE_NAME ) == NULL ) { mem_region_cleanup ( io , idx ) ; return - EIO ; } } mapsize = ( ( io -> io_size * io -> regspacing ) - ( io -> regspacing - io -> regsize ) ) ; io -> addr = ioremap ( addr , mapsize ) ; if ( io -> addr == NULL ) { mem_region_cleanup ( io , io -> io_size ) ; return - EIO ; } io -> addr = ioremap ( addr , mapsize ) ; if ( io -> addr == NULL ) { mem_region_cleanup ( io , io -> io_size ) ; return - EIO ; } return 0 ; }
",0,417
1025,"static int splice_pipe_to_pipe ( struct pipe_inode_info * ipipe , struct pipe_inode_info * opipe , size_t len , unsigned int flags ) { struct pipe_buffer * ibuf , * obuf ; int ret = 0 , nbuf ; bool input_wakeup = false ; retry : ret = ipipe_prep ( ipipe , flags ) ; if ( ret ) return ret ; ret = opipe_prep ( opipe , flags ) ; if ( ret ) return ret ; pipe_double_lock ( ipipe , opipe ) ; do { if ( ! opipe -> readers ) { send_sig ( SIGPIPE , current , 0 ) ; if ( ! ret ) ret = - EPIPE ; break ; } if ( ! ipipe -> nrbufs && ! ipipe -> writers ) break ; if ( ! ipipe -> nrbufs || opipe -> nrbufs >= opipe -> buffers ) { if ( ret ) break ; if ( flags & SPLICE_F_NONBLOCK ) { ret = - EAGAIN ; break ; } pipe_unlock ( ipipe ) ; pipe_unlock ( opipe ) ; goto retry ; } ibuf = ipipe -> bufs + ipipe -> curbuf ; nbuf = ( opipe -> curbuf + opipe -> nrbufs ) & ( opipe -> buffers - 1 ) ; obuf = opipe -> bufs + nbuf ; if ( len >= ibuf -> len ) { * obuf = * ibuf ; ibuf -> ops = NULL ; opipe -> nrbufs ++ ; ipipe -> curbuf = ( ipipe -> curbuf + 1 ) & ( ipipe -> buffers - 1 ) ; ipipe -> nrbufs -- ; input_wakeup = true ; } else { if ( ! pipe_buf_get ( ipipe , ibuf ) ) { if ( ret == 0 ) ret = - EFAULT ; break ; } * obuf = * ibuf ; obuf -> flags &= ~ PIPE_BUF_FLAG_GIFT ; obuf -> len = len ; opipe -> nrbufs ++ ; ibuf -> offset += obuf -> len ; ibuf -> len -= obuf -> len ; } ret += obuf -> len ; len -= obuf -> len ; }
",0,511
1026,"static void tokenadd ( struct jv_parser * p , char c ) { assert ( p -> tokenpos <= p -> tokenlen ) ; if ( p -> tokenpos == p -> tokenlen ) { p -> tokenlen = p -> tokenlen * 2 + 256 ; p -> tokenbuf = jv_mem_realloc ( p -> tokenbuf , p -> tokenlen ) ; } assert ( p -> tokenpos < p -> tokenlen ) ; p -> tokenbuf [ p -> tokenpos ++ ] = c ; }
",0,111
1027,"static vp9_variance_fn_t get_block_variance_fn ( vpx_bit_depth_t bit_depth ) { switch ( bit_depth ) { case BLOCK_8X8 : return vp9_mse8x8 ; case BLOCK_16X8 : return vpx_mse16x8 ; case BLOCK_8X16 : return vp9_mse8x16 ; default : return vpx_mse16x16 ; } }
",0,111
1028,"static void _isdn_setup ( struct net_device * dev ) { isdn_net_local * lp = netdev_priv ( dev ) ; ether_setup ( dev ) ; dev -> priv_flags &= ~ IFF_TX_SKB_SHARING ; dev -> flags = IFF_NOARP | IFF_POINTOPOINT ; dev -> header_ops = NULL ; dev -> netdev_ops = & isdn_netdev_ops ; dev -> tx_queue_len = 30 ; lp -> p_encap = ISDN_NET_ENCAP_RAWIP ; lp -> magic = ISDN_NET_MAGIC ; lp -> last = lp ; lp -> next = lp ; lp -> isdn_device = - 1 ; lp -> isdn_channel = - 1 ; lp -> pre_device = - 1 ; lp -> pre_channel = - 1 ; lp -> exclusive = - 1 ; lp -> ppp_slot = - 1 ; lp -> pppbind = - 1 ; skb_queue_head_init ( & lp -> super_tx_queue ) ; lp -> l2_proto = ISDN_PROTO_L2_X75I ; lp -> l3_proto = ISDN_PROTO_L3_TRANS ; lp -> triggercps = 6000 ; lp -> slavedelay = 10 * HZ ; lp -> hupflags = ISDN_INHUP ; lp -> onhtime = 10 ; lp -> dialmax = 1 ; lp -> flags = ISDN_NET_CBHUP | ISDN_NET_DM_MANUAL ; lp -> cbdelay = 25 ; lp -> dialtimeout = - 1 ; lp -> dialwait = 5 * HZ ; lp -> dialstarted = 0 ; lp -> dialwait_timer = 0 ; }
",1,422
1029,"static av_cold int rl2_read_header ( AVFormatContext * s ) { AVIOContext * pb = s -> pb ; AVStream * st ; unsigned int frame_count ; unsigned int audio_frame_counter = 0 ; unsigned int video_frame_counter = 0 ; unsigned int back_size ; unsigned short sound_rate ; unsigned short rate ; unsigned short channels ; unsigned short def_sound_size ; unsigned int signature ; unsigned int pts_den = 11025 ; unsigned int pts_num = 1103 ; unsigned int * chunk_offset = NULL ; int * chunk_size = NULL ; int * audio_size = NULL ; int i ; int ret = 0 ; avio_skip ( pb , 4 ) ; back_size = avio_rl32 ( pb ) ; signature = avio_rb32 ( pb ) ; avio_skip ( pb , 4 ) ; frame_count = avio_rl32 ( pb ) ; if ( back_size > INT_MAX / 2 || frame_count > INT_MAX / sizeof ( uint32_t ) ) return AVERROR_INVALIDDATA ; avio_skip ( pb , 2 ) ; sound_rate = avio_rl16 ( pb ) ; rate = avio_rl16 ( pb ) ; channels = avio_rl16 ( pb ) ; def_sound_size = avio_rl16 ( pb ) ; st = avformat_new_stream ( s , NULL ) ; if ( ! st ) return AVERROR ( ENOMEM ) ; st -> codecpar -> codec_type = AVMEDIA_TYPE_VIDEO ; st -> codecpar -> codec_id = AV_CODEC_ID_RL2 ; st -> codecpar -> codec_tag = 0 ; st -> codecpar -> width = 320 ; st -> codecpar -> height = 200 ; st -> codecpar -> extradata_size = EXTRADATA1_SIZE ; if ( signature == RLV3_TAG && back_size > 0 ) st -> codecpar -> extradata_size += back_size ; if ( ff_get_extradata ( s , st -> codecpar , pb , st -> codecpar -> extradata_size ) < 0 ) return AVERROR ( ENOMEM ) ; if ( sound_rate ) { if ( ! channels || channels
",0,511
1030,"static OPJ_BOOL opj_pi_next_pcrl ( opj_pi_iterator_t * pi ) { opj_pi_comp_t * comp = NULL ; opj_pi_resolution_t * res = NULL ; OPJ_UINT32 index = 0 ; if ( ! pi -> first ) { comp = & pi -> comps [ pi -> compno ] ; goto LABEL_SKIP ; } else { OPJ_UINT32 compno , resno ; pi -> first = 0 ; pi -> dx = 0 ; pi -> dy = 0 ; for ( compno = 0 ; compno < pi -> numcomps ; compno ++ ) { comp = & pi -> comps [ compno ] ; for ( resno = 0 ; resno < comp -> numresolutions ; resno ++ ) { OPJ_UINT32 dx , dy ; res = & comp -> resolutions [ resno ] ; dx = comp -> dx * ( 1u << ( res -> pdx + comp -> numresolutions - 1 - resno ) ) ; dy = comp -> dy * ( 1u << ( res -> pdy + comp -> numresolutions - 1 - resno ) ) ; pi -> dx = ! pi -> dx ? dx : opj_uint_min ( pi -> dx , dx ) ; pi -> dy = ! pi -> dy ? dy : opj_uint_min ( pi -> dy , dy ) ; } } } if ( ! pi -> tp_on ) { pi -> poc . ty0 = pi -> ty0 ; pi -> poc . tx0 = pi -> tx0 ; pi -> poc . ty1 = pi -> ty1 ; pi -> poc . tx1 = pi -> tx1 ; } for ( pi -> y = pi -> poc . ty0 ; pi -> y < pi -> poc . ty1 ; pi -> y += ( OPJ_INT32 ) ( pi -> dy - ( OPJ_UINT32 ) ( pi -> y % ( OPJ_INT32 ) pi -> dy ) ) ) { for ( pi -> x = pi -> poc . tx0 ; pi -> x < pi -> poc . tx1 ; pi -> x += ( OPJ_INT32 ) ( pi -> dx - ( OPJ_UINT32 ) ( pi -> x % ( OPJ_INT32 ) pi
",0,511
1031,"static krb5_error_code pkinit_server_return_padata ( krb5_context context , krb5_pa_data * padata , krb5_data * req_pkt , krb5_kdc_req * request , krb5_kdc_rep * reply , krb5_keyblock * encrypting_key , krb5_pa_data * * send_pa , krb5_kdcpreauth_callbacks cb , krb5_kdcpreauth_rock rock , krb5_kdcpreauth_moddata moddata , krb5_kdcpreauth_modreq modreq ) { krb5_error_code retval = 0 ; krb5_data scratch = { 0 , 0 , NULL } ; krb5_pa_pk_as_req * reqp = NULL ; krb5_pa_pk_as_req_draft9 * reqp9 = NULL ; int i = 0 ; unsigned char * subjectPublicKey = NULL ; unsigned char * dh_pubkey = NULL , * server_key = NULL ; unsigned int subjectPublicKey_len = 0 ; unsigned int server_key_len = 0 , dh_pubkey_len = 0 ; krb5_kdc_dh_key_info dhkey_info ; krb5_data * encoded_dhkey_info = NULL ; krb5_pa_pk_as_rep * rep = NULL ; krb5_pa_pk_as_rep_draft9 * rep9 = NULL ; krb5_data * out_data = NULL ; krb5_octet_data secret ; krb5_enctype enctype = - 1 ; krb5_reply_key_pack * key_pack = NULL ; krb5_reply_key_pack_draft9 * key_pack9 = NULL ; krb5_data * encoded_key_pack = NULL ; pkinit_kdc_context plgctx ; pkinit_kdc_req_context reqctx ; int fixed_keypack = 0 ; * send_pa = NULL ; if ( padata -> pa_type == KRB5_PADATA_PKINIT_KX ) { return return_pkinit_kx ( context ,
",0,511
1032,"MagickExport void * AcquireQuantumMemory ( const size_t count , const size_t quantum ) { size_t extent ; if ( HeapOverflowSanityCheck ( count , quantum ) != MagickFalse ) return ( ( void * ) NULL ) ; extent = count * quantum ; return ( AcquireMagickMemory ( extent ) ) ; }
",1,77
1033,"static bool parse_reconnect ( struct pool * pool , json_t * val ) { char * sockaddr_url , * stratum_port , * tmp ; char * url , * port , address [ 256 ] ; memset ( address , 0 , 255 ) ; url = ( char * ) json_string_value ( json_array_get ( val , 0 ) ) ; if ( ! url ) url = pool -> sockaddr_url ; else { char * dot_pool , * dot_reconnect ; dot_pool = strchr ( pool -> sockaddr_url , '.' ) ; if ( ! dot_pool ) { applog ( LOG_ERR , ""Deniedstratumreconnectrequestforpoolwithoutdomain\'%s\'"" , pool -> sockaddr_url ) ; return false ; } dot_reconnect = strchr ( url , '.' ) ; if ( ! dot_reconnect ) { applog ( LOG_ERR , ""Deniedstratumreconnectrequesttourlwithoutdomain\'%s\'"" , url ) ; return false ; } if ( strcmp ( dot_pool , dot_reconnect ) ) { applog ( LOG_ERR , ""Deniedstratumreconnectrequesttonon-matchingdomainurl\'%s\'"" , pool -> sockaddr_url ) ; return false ; } } port = ( char * ) json_string_value ( json_array_get ( val , 1 ) ) ; if ( ! port ) port = pool -> stratum_port ; snprintf ( address , 254 , ""%s:%s"" , url , port ) ; if ( ! extract_sockaddr ( address , & sockaddr_url , & stratum_port ) ) return false ; applog ( LOG_WARNING , ""Stratumreconnectrequestedfrompool%dto%s"" , pool -> pool_no , address ) ; clear_pool_work ( pool ) ; mutex_lock ( & pool -> stratum_lock ) ; __suspend_stratum ( pool ) ; tmp = pool -> sockaddr_url ; pool -> sockaddr_url = sockaddr_url ; pool -> stratum_url = pool -> sockaddr_url ; free ( tmp ) ; tmp = pool -> stratum_port ; pool -> stratum_port = stratum_port ; free ( tmp ) ; mutex_un
",0,511
1034,"void wiki_handle_rest_call ( HttpRequest * req , HttpResponse * res , char * func ) { if ( func != NULL && * func != '\\0' ) { if ( ! strcmp ( func , ""page/get"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""%s"" , file_read ( page ) ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/set"" ) ) { char * wikitext = NULL , * page = NULL ; if ( ( ( wikitext = http_request_param_get ( req , ""text"" ) ) != NULL ) && ( ( page = http_request_param_get ( req , ""page"" ) ) != NULL ) ) { file_write ( page , wikitext ) ; http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/delete"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( unlink ( page ) > 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send ( res ) ; return ; } } else if ( ! strcmp ( func , ""page/exists"" ) ) { char * page = http_request_param_get ( req , ""page"" ) ; if ( page == NULL ) page = http_request_get_query_string ( req ) ; if ( page && ( access ( page , R_OK ) == 0 ) ) { http_response_printf ( res , ""success"" ) ; http_response_send
",0,511
1035,"static int start_decoder ( vorb * f ) { uint8 header [ 6 ] , x , y ; int len , i , j , k , max_submaps = 0 ; int longest_floorlist = 0 ; if ( current_length >= 32 ) return error ( f , VORBIS_invalid_setup ) ; if ( ! start_page ( f ) ) return FALSE ; if ( ! ( f -> page_flag & PAGEFLAG_first_page ) ) return error ( f , VORBIS_invalid_first_page ) ; if ( f -> page_flag & PAGEFLAG_last_page ) return error ( f , VORBIS_invalid_first_page ) ; if ( f -> page_flag & PAGEFLAG_continued_packet ) return error ( f , VORBIS_invalid_first_page ) ; if ( f -> segment_count != 1 ) return error ( f , VORBIS_invalid_first_page ) ; if ( f -> segments [ 0 ] != 30 ) return error ( f , VORBIS_invalid_first_page ) ; if ( get8 ( f ) != VORBIS_packet_id ) return error ( f , VORBIS_invalid_first_page ) ; if ( ! getn ( f , header , 6 ) ) return error ( f , VORBIS_unexpected_eof ) ; if ( ! vorbis_validate ( header ) ) return error ( f , VORBIS_invalid_first_page ) ; if ( get32 ( f ) != 0 ) return error ( f , VORBIS_invalid_first_page ) ; f -> channels = get8 ( f ) ; if ( ! f -> channels ) return error ( f , VORBIS_invalid_first_page ) ; if ( f -> channels > STB_VORBIS_MAX_CHANNELS ) return error ( f , VORBIS_too_many_channels ) ; f -> sample_rate = get32 ( f ) ; if ( ! f -> sample_rate ) return error ( f , VORBIS_invalid_first_page ) ; get32 ( f ) ; get32 ( f ) ; get32 ( f ) ; get32 ( f ) ; x = get
",0,511
1036,"int nfssvc_decode_writeargs ( struct svc_rqst * rqstp , __be32 * p , struct nfsd_writeargs * args ) { unsigned int len , hdr , dlen ; struct kvec * head = rqstp -> rq_arg . head ; int v ; p = decode_fh ( p , & args -> fh ) ; if ( ! p ) return 0 ; p ++ ; args -> offset = ntohl ( * p ++ ) ; p ++ ; len = args -> len = ntohl ( * p ++ ) ; if ( len > NFSSVC_MAXBLKSIZE_V2 ) return 0 ; if ( hdr && len < XDR_QUADLEN ( len ) * 4 ) return 0 ; rqstp -> rq_vec [ 0 ] . iov_base = ( void * ) p ; rqstp -> rq_vec [ 0 ] . iov_len = head -> iov_len - hdr ; v = 0 ; while ( len > rqstp -> rq_vec [ v ] . iov_len ) { len -= rqstp -> rq_vec [ v ] . iov_len ; v ++ ; rqstp -> rq_vec [ v ] . iov_base = page_address ( rqstp -> rq_pages [ v ] ) ; rqstp -> rq_vec [ v ] . iov_len = PAGE_SIZE ; } rqstp -> rq_vec [ v ] . iov_len = len ; args -> vlen = v + 1 ; return 1 ; }
",0,370
1037,"static ssize_t o2nm_node_num_store ( struct config_item * item , const char * page , size_t count ) { struct o2nm_node * node = to_o2nm_node ( item ) ; struct o2nm_cluster * cluster ; unsigned long tmp ; char * p = ( char * ) page ; int ret = 0 ; tmp = simple_strtoul ( p , & p , 0 ) ; if ( ! p || ( * p && ( * p != '\\n' ) ) ) return - EINVAL ; o2nm_lock_subsystem ( ) ; cluster = to_o2nm_cluster_from_node ( node ) ; o2nm_unlock_subsystem ( ) ; if ( ! cluster ) { o2nm_unlock_subsystem ( ) ; return - EINVAL ; } write_lock ( & cluster -> cl_nodes_lock ) ; o2nm_unlock_subsystem ( ) ; if ( cluster -> cl_nodes [ tmp ] ) ret = - EEXIST ; else if ( test_and_set_bit ( O2NM_NODE_ATTR_NUM , & node -> nd_set_attributes ) ) ret = - EBUSY ; else { cluster -> cl_nodes [ tmp ] = node ; node -> nd_num = tmp ; set_bit ( tmp , cluster -> cl_nodes_bitmap ) ; } write_unlock ( & cluster -> cl_nodes_lock ) ; o2nm_unlock_subsystem ( ) ; if ( ret ) return ret ; return count ; }
",0,359
1038,"static void tw5864_handle_frame ( struct tw5864_h264_frame * frame ) { # define SKIP_VLCBUF_BYTES 3 struct tw5864_input * input = frame -> input ; struct tw5864_dev * dev = input -> root ; struct tw5864_buf * vb ; struct vb2_v4l2_buffer * v4l2_buf ; int frame_len = frame -> vlc_len - SKIP_VLCBUF_BYTES ; u8 * dst = input -> buf_cur_ptr ; u8 tail_mask , vlc_mask = 0 ; int i ; u8 vlc_first_byte = ( ( u8 * ) ( frame -> vlc . addr + SKIP_VLCBUF_BYTES ) ) [ 0 ] ; unsigned long flags ; int zero_run ; u8 * src ; u8 * src_end ; # ifdef DEBUG if ( frame -> checksum != tw5864_vlc_checksum ( ( u32 * ) frame -> vlc . addr , frame_len ) ) dev_err ( & dev -> pci -> dev , ""Checksumofencodedframedoesn\'tmatch
",0,270
1039,"void * zcalloc ( size_t size ) { ASSERT_NO_SIZE_OVERFLOW ( size ) ; void * ptr = calloc ( 1 , size + PREFIX_SIZE ) ; if ( ! ptr ) zmalloc_oom_handler ( size ) ; # ifdef HAVE_MALLOC_SIZE update_zmalloc_stat_alloc ( zmalloc_size ( ptr ) ) ; return ptr ; # else * ( ( size_t * ) ptr ) = size ; update_zmalloc_stat_alloc ( size + PREFIX_SIZE ) ; return ( char * ) ptr + PREFIX_SIZE ; # endif }
",1,141
1040,"sf_count_t psf_fwrite ( const void * ptr , sf_count_t bytes , sf_count_t items , SF_PRIVATE * psf ) { sf_count_t total = 0 ; ssize_t count ; if ( bytes == 0 || items == 0 ) return 0 ; if ( psf -> virtual_io ) return psf -> vio . write ( ptr , bytes * items , psf -> vio_user_data ) / bytes ; items *= bytes ; if ( items <= 0 ) return 0 ; while ( items > 0 ) { count = ( items > SENSIBLE_SIZE ) ? SENSIBLE_SIZE : items ; count = write ( psf -> file . filedes , ( ( const char * ) ptr ) + total , count ) ; if ( count == - 1 ) { if ( errno == EINTR ) continue ; psf_log_syserr ( psf , errno ) ; break ; } ; if ( count == 0 ) break ; total += count ; items -= count ; } ; if ( psf -> is_pipe ) psf -> pipeoffset += total ; return total / bytes ; }
",1,255
1041,"static int rx_cache_find ( const struct rx_header * rxh , const struct ip * ip , int sport , int32_t * opcode ) { int i ; struct rx_cache_entry * rxent ; uint32_t clip ; uint32_t sip ; UNALIGNED_MEMCPY ( & clip , & ip -> ip_dst , sizeof ( uint32_t ) ) ; UNALIGNED_MEMCPY ( & sip , & ip -> ip_src , sizeof ( uint32_t ) ) ; i = rx_cache_hint ; do { rxent = & rx_cache [ i ] ; if ( rxent -> callnum == EXTRACT_32BITS ( & rxh -> callNumber ) && rxent -> client . s_addr == clip && rxent -> server . s_addr == sip && rxent -> serviceId == EXTRACT_32BITS ( & rxh -> serviceId ) && rxent -> dport == sport ) { rx_cache_hint = i ; * opcode = rxent -> opcode ; return ( 1 ) ; } if ( ++ i >= RX_CACHE_SIZE ) i = 0 ; } while ( i != rx_cache_hint ) ; return ( 0 ) ; }
",0,298
1042,"long keyctl_read_key ( key_serial_t keyid , char __user * buffer , size_t buflen ) { struct key * key ; key_ref_t key_ref ; long ret ; key_ref = lookup_user_key ( keyid , 0 , 0 ) ; if ( IS_ERR ( key_ref ) ) { ret = - ENOKEY ; goto error ; } key = key_ref_to_ptr ( key_ref ) ; ret = key_permission ( key_ref , KEY_NEED_READ ) ; if ( ret == 0 ) ret = key -> type -> read ) { down_read ( & key -> sem ) ; ret = key_validate ( key ) ; if ( ret == 0 ) ret = key -> type -> read ( key , buffer , buflen ) ; up_read ( & key -> sem ) ; } error2 : key_put ( key ) ; error : return ret ; }
",0,209
1043,"int mwifiex_cmd_802_11_ad_hoc_start ( struct mwifiex_private * priv , struct host_cmd_ds_command * cmd , struct cfg80211_ssid * req_ssid ) { int rsn_ie_len = 0 ; struct mwifiex_adapter * adapter = priv -> adapter ; struct host_cmd_ds_802_11_ad_hoc_start * adhoc_start = & cmd -> params . adhoc_start ; struct mwifiex_bssdescriptor * bss_desc ; u32 cmd_append_size = 0 ; u32 i ; u16 tmp_cap ; struct mwifiex_ie_types_chan_list_param_set * chan_tlv ; u8 radio_type ; struct mwifiex_ie_types_htcap * ht_cap ; struct mwifiex_ie_types_htinfo * ht_info ; u8 * pos = ( u8 * ) adhoc_start + sizeof ( struct host_cmd_ds_802_11_ad_hoc_start ) ; if ( ! adapter ) return - 1 ; cmd -> command = cpu_to_le16 ( HostCmd_CMD_802_11_AD_HOC_START ) ; bss_desc = & priv -> curr_bss_params . bss_descriptor ; priv -> attempted_bss_desc = bss_desc ; if ( ! adapter ) return - 1 ; memset ( adhoc_start -> ssid , 0 , IEEE80211_MAX_SSID_LEN ) ; memcpy ( adhoc_start -> ssid , req_ssid -> ssid , req_ssid -> ssid_len ) ; mwifiex_dbg ( adapter , INFO , ""info:ADHOC_S_CMD:SSID=%s\\n"" , adhoc_start -> ssid ) ; memset ( bss_desc -> ssid . ssid , 0 , IEEE80211_MAX_SSID_LEN ) ; memcpy ( bss_desc -> ssid . ssid , req_ssid -> ssid , req_ssid -> ssid_
",0,511
1044,"int xfs_attr_shortform_list ( xfs_attr_list_context_t * context ) { attrlist_cursor_kern_t * cursor ; xfs_attr_sf_sort_t * sbuf , * sbp ; xfs_attr_shortform_t * sf ; xfs_attr_sf_entry_t * sfe ; xfs_inode_t * dp ; int sbsize , nsbuf , count , i ; int error ; ASSERT ( context != NULL ) ; dp = context -> dp ; ASSERT ( dp != NULL ) ; ASSERT ( dp -> i_afp != NULL ) ; sf = ( xfs_attr_shortform_t * ) dp -> i_afp -> if_u1 . if_data ; ASSERT ( sf != NULL ) ; if ( ! sf -> hdr . count ) return 0 ; cursor = context -> cursor ; ASSERT ( cursor != NULL ) ; trace_xfs_attr_list_sf ( context ) ; if ( context -> bufsize == 0 || ( XFS_ISRESET_CURSOR ( cursor ) && ( dp -> i_afp -> if_bytes + sf -> hdr . count * 16 ) < context -> bufsize ) ) { for ( i = 0 , sfe = & sf -> list [ 0 ] ; i < sf -> hdr . count ; i ++ ) { error = context -> put_listent ( context , sfe -> flags , sfe -> nameval , ( int ) sfe -> namelen , ( int ) sfe -> valuelen , & sfe -> nameval [ sfe -> namelen ] ) ; if ( context -> seen_enough ) break ; if ( error ) return error ; sfe = XFS_ATTR_SF_NEXTENTRY ( sfe ) ; } trace_xfs_attr_list_sf_all ( context ) ; return 0 ; } if ( context -> bufsize == 0 ) return 0 ; sbsize = sf -> hdr . count * sizeof ( * sbuf ) ; sbp = sbuf = kmem_alloc ( sbsize , KM_SLEEP | KM_NOFS ) ; nsbuf = 0 ; for ( i = 0 , sfe = & s
",0,511
1045,"int X509_verify ( X509 * a , EVP_PKEY * r ) { if ( X509_ALGOR_cmp ( a -> sig_alg , a -> cert_info -> signature ) ) return 0 ; return ( ASN1_item_verify ( ASN1_ITEM_rptr ( X509_CINF ) , a -> sig_alg , a -> signature , a -> cert_info , r ) ) ; }
",1,101
1046,"static int snd_hrtimer_start ( struct snd_timer * t ) { struct snd_hrtimer * stime = t -> private_data ; atomic_set ( & stime -> running , 0 ) ; hrtimer_try_to_cancel ( & stime -> hrt ) ; hrtimer_start ( & stime -> hrt , ns_to_ktime ( t -> sticks * resolution ) , HRTIMER_MODE_REL ) ; atomic_set ( & stime -> running , 1 ) ; return 0 ; }
",1,120
1047,"static int forward_search_range ( regex_t * reg , const UChar * str , const UChar * end , UChar * s , UChar * range , UChar * * low , UChar * * high , UChar * * low_prev ) { UChar * p , * pprev = ( UChar * ) NULL ; # ifdef ONIG_DEBUG_SEARCH fprintf ( stderr , ""forward_search_range:str:%d,end:%d,s:%d,range:%d\\n"" , ( int ) str , ( int ) end , ( int ) s , ( int ) range ) ; # endif p = s ; if ( reg -> dmin > 0 ) { if ( ONIGENC_IS_SINGLEBYTE ( reg -> enc ) ) { p += reg -> dmin ; } else { UChar * q = p + reg -> dmin ; while ( p < q ) p += enclen ( reg -> enc , p ) ; } } retry : switch ( reg -> optimize ) { case ONIG_OPTIMIZE_EXACT : p = slow_search ( reg -> enc , reg -> exact , reg -> exact_end , p , end , range ) ; break ; case ONIG_OPTIMIZE_EXACT_IC : p = slow_search_ic ( reg -> enc , reg -> case_fold_flag , reg -> exact , reg -> exact_end , p , end , range ) ; break ; case ONIG_OPTIMIZE_EXACT_BM : p = bm_search ( reg , reg -> exact , reg -> exact_end , p , end , range ) ; break ; case ONIG_OPTIMIZE_EXACT_BM_NOT_REV : p = bm_search_notrev ( reg , reg -> exact , reg -> exact_end , p , end , range ) ; break ; case ONIG_OPTIMIZE_MAP : p = map_search ( reg -> enc , reg -> map , p , range ) ; break ; } if ( p && p < range ) { if ( p - reg -> dmin < s ) { retry_gate : pprev = p ; p += enclen ( reg -> enc , p ) ; goto retry ; } if ( reg -> sub_anchor ) { UChar * low
",0,511
1048,"static int l2cap_build_conf_req ( struct sock * sk , void * data ) { struct l2cap_pinfo * pi = l2cap_pi ( sk ) ; struct l2cap_conf_req * req = data ; struct l2cap_conf_rfc rfc = { . mode = L2CAP_MODE_BASIC } ; void * ptr = req -> data ; BT_DBG ( ""sk%p"" , sk ) ; switch ( pi -> mode ) { case L2CAP_MODE_STREAMING : if ( pi -> imtu != L2CAP_DEFAULT_MTU ) l2cap_add_conf_opt ( & ptr , L2CAP_CONF_MTU , 2 , pi -> imtu ) ; break ; case L2CAP_MODE_ERTM : rfc . mode = L2CAP_MODE_ERTM ; rfc . txwin_size = L2CAP_DEFAULT_RX_WINDOW ; rfc . max_transmit = L2CAP_DEFAULT_MAX_RECEIVE ; rfc . retrans_timeout = cpu_to_le16 ( L2CAP_DEFAULT_RETRANS_TO ) ; rfc . monitor_timeout = cpu_to_le16 ( L2CAP_DEFAULT_MONITOR_TO ) ; rfc . max_pdu_size = cpu_to_le16 ( L2CAP_DEFAULT_MAX_RX_APDU ) ; l2cap_add_conf_opt ( & ptr , L2CAP_CONF_RFC , sizeof ( rfc ) , ( unsigned long ) & rfc ) ; break ; } req -> dcid = cpu_to_le16 ( pi -> dcid ) ; req -> flags = cpu_to_le16 ( 0 ) ; return ptr - data ; }
",0,406
1049,"int sock_recv_all ( int sock_fd , uint8_t * buf , int len ) { int r = len ; int ret = - 1 ; while ( r ) do { ret = TEMP_FAILURE_RETRY ( recv ( sock_fd , buf , r , MSG_WAITALL ) ) ; while ( ret < 0 && errno == EINTR ) ; if ( ret <= 0 ) { BTIF_TRACE_ERROR ( ""sockfd:%drecverrno:%d,ret:%d"" , sock_fd , errno , ret ) ; return - 1 ; } buf += ret ; r -= ret ; } return len ; }
",0,151
1050,"static int http_read_header ( URLContext * h , int * new_location ) { HTTPContext * s = h -> priv_data ; char line [ MAX_URL_SIZE ] ; int err = 0 ; s -> chunksize = UINT64_MAX ; for ( ; ; ) { if ( ( err = http_get_line ( s , line , sizeof ( line ) ) ) < 0 ) return err ; av_log ( h , AV_LOG_TRACE , ""header=\'%s\'\\n"" , line ) ; err = process_line ( h , line , s -> line_count , new_location ) ; if ( err < 0 ) return err ; if ( err == 0 ) break ; s -> line_count ++ ; } if ( s -> seekable == - 1 && s -> is_mediagateway && s -> filesize == 2000000000 ) h -> is_streamed = 1 ; cookie_string ( s -> cookie_dict , & s -> cookies ) ; av_dict_free ( & s -> cookie_dict ) ; return err ; }
",1,233
1051,"WORD32 ih264d_parse_nal_unit ( iv_obj_t * dec_hdl , ivd_video_decode_op_t * ps_dec_op , UWORD8 * pu1_buf , UWORD32 u4_length ) { dec_bit_stream_t * ps_bitstrm ; dec_struct_t * ps_dec = ( dec_struct_t * ) dec_hdl -> pv_codec_handle ; ivd_video_decode_ip_t * ps_dec_in = ( ivd_video_decode_ip_t * ) ps_dec -> pv_dec_in ; dec_slice_params_t * ps_cur_slice = ps_dec -> ps_cur_slice ; UWORD8 u1_first_byte , u1_nal_ref_idc ; UWORD8 u1_nal_unit_type ; WORD32 i_status = OK ; ps_bitstrm = ps_dec -> ps_bitstrm ; if ( pu1_buf ) { if ( u4_length ) { ps_dec_op -> u4_frame_decoded_flag = 0 ; ih264d_process_nal_unit ( ps_dec -> ps_bitstrm , pu1_buf , u4_length ) ; SWITCHOFFTRACE ; u1_first_byte = ih264d_get_bits_h264 ( ps_bitstrm , 8 ) ; if ( NAL_FORBIDDEN_BIT ( u1_first_byte ) ) { H264_DEC_DEBUG_PRINT ( ""\\nForbiddenbitsetinNalUnit,Let\'stry\\n"" ) ; } u1_nal_unit_type = NAL_UNIT_TYPE ( u1_first_byte ) ; if ( ( ps_dec -> u4_slice_start_code_found == 1 ) && ( ps_dec -> u1_pic_decode_done != 1 ) && ( u1_nal_unit_type > IDR_SLICE_NAL ) ) { return ERROR_INCOMPLETE_FRAME ; } ps_dec -> u1_nal_unit_type = u1_nal_unit_type ; u
",0,511
1052,"static void addFormVars ( cchar * buf ) { char * pair , * tok ; pair = stok ( sclone ( buf ) , ""&"" , & tok ) ; while ( pairing && ( pair != 0 ) ) { mprAddItem ( app -> formData , sclone ( pair ) ) ; pair = stok ( 0 , ""&"" , & tok ) ; } }
",0,88
1053,"int crypto_rng_reset ( struct crypto_rng * tfm , const u8 * seed , unsigned int slen ) { u8 * buf = NULL ; int err ; if ( ! seed && slen ) { buf = kmalloc ( slen , GFP_KERNEL ) ; if ( ! buf ) return - ENOMEM ; get_random_bytes ( buf , slen ) ; seed = buf ; } err = crypto_rng_alg ( tfm ) -> seed ( tfm , seed , slen ) ; kfree ( buf ) ; return err ; }
",1,127
1054,"static struct ucounts * get_ucounts ( struct user_namespace * ns , kuid_t uid ) { struct hlist_head * hashent = ucounts_hashentry ( ns , uid ) ; struct ucounts * ucounts , * new ; spin_lock_irq ( & ucounts_lock ) ; ucounts = find_ucounts ( ns , uid , hashent ) ; if ( ! ucounts ) { spin_unlock_irq ( & ucounts_lock ) ; new = kzalloc ( sizeof ( * new ) , GFP_KERNEL ) ; if ( ! new ) return NULL ; new -> ns = ns ; new -> uid = uid ; new -> count , 0 ) ; spin_lock_irq ( & ucounts_lock ) ; ucounts = find_ucounts ( ns , uid , hashent ) ; if ( ucounts ) { kfree ( new ) ; } else { hlist_add_head ( & new -> node , hashent ) ; ucounts = new ; } } if ( ucounts -> count , 1 , INT_MAX ) ) ucounts = NULL ; spin_unlock_irq ( & ucounts_lock ) ; return ucounts ; }
",1,288
1055,"int __sys_recvmmsg ( int fd , struct mmsghdr __user * mmsg , unsigned int vlen , unsigned int flags , struct timespec * timeout ) { int fput_needed , err , datagrams ; struct socket * sock ; struct mmsghdr __user * entry ; struct compat_mmsghdr __user * compat_entry ; struct msghdr msg_sys ; struct timespec end_time ; if ( timeout && poll_select_set_timeout ( & end_time , timeout -> tv_sec , timeout -> tv_nsec ) ) return - EINVAL ; datagrams = 0 ; sock = sockfd_lookup_light ( fd , & err , & fput_needed ) ; if ( ! sock ) return err ; err = sock_error ( sock -> sk ) ; if ( err ) goto out_put ; entry = mmsg ; compat_entry = ( struct compat_mmsghdr __user * ) mmsg ; while ( datagrams < vlen ) { if ( MSG_CMSG_COMPAT & flags ) { err = ___sys_recvmsg ( sock , ( struct user_msghdr __user * ) compat_entry , & msg_sys , flags & ~ MSG_WAITFORONE , datagrams ) ; if ( err < 0 ) break ; err = __put_user ( err , & compat_entry -> msg_len ) ; ++ compat_entry ; } else { err = ___sys_recvmsg ( sock , ( struct user_msghdr __user * ) entry , & msg_sys , flags & ~ MSG_WAITFORONE , datagrams ) ; if ( err < 0 ) break ; err = put_user ( err , & entry -> msg_len ) ; ++ entry ; } if ( err ) break ; ++ datagrams ; if ( flags & MSG_WAITFORONE ) flags |= MSG_DONTWAIT ; if ( timeout ) { ktime_get_ts ( timeout ) ; * timeout = timespec_sub ( end_time , * timeout ) ; if ( timeout -> tv_sec < 0 ) { timeout -> tv_sec = timeout -> tv_nsec = 0 ; break ; } if ( timeout -> tv_nsec == 0 && timeout -> tv_sec == 0 ) break ; } if ( msg_sys
",0,511
1056,"static void ntlm_free_message_fields_buffer ( NTLM_MESSAGE_FIELDS * fields ) { if ( fields ) { if ( fields -> Buffer ) { free ( fields -> Buffer ) ; fields -> Len = 0 ; fields -> MaxLen = 0 ; fields -> Buffer = NULL ; fields -> BufferOffset = 0 ; } } }
",1,79
1057,"static inline void prefetch_table ( const volatile byte * tab , size_t len ) { size_t i ; for ( i = 0 ; len - i >= 8 * 32 ; i += 8 * 32 ) { ( void ) tab [ i + 0 * 32 ] ; ( void ) tab [ i + 1 * 32 ] ; ( void ) tab [ i + 2 * 32 ] ; ( void ) tab [ i + 3 * 32 ] ; ( void ) tab [ i + 4 * 32 ] ; ( void ) tab [ i + 5 * 32 ] ; ( void ) tab [ i + 6 * 32 ] ; ( void ) tab [ i + 7 * 32 ] ; } ( void ) tab [ len - 1 ] ; }
",0,155
1058,"int ext4_ext_get_blocks ( handle_t * handle , struct inode * inode , ext4_lblk_t iblock , unsigned int max_blocks , struct buffer_head * bh_result , int flags ) { struct ext4_ext_path * path = NULL ; struct ext4_extent_header * eh ; struct ext4_extent newex , * ex , * last_ex ; ext4_fsblk_t newblock ; int err = 0 , depth , ret , cache_type ; unsigned int allocated = 0 ; struct ext4_allocation_request ar ; ext4_io_end_t * io = EXT4_I ( inode ) -> cur_aio_dio ; __clear_bit ( BH_New , & bh_result -> b_state ) ; ext_debug ( ""blocks%u/%urequestedforinode%lu\\n"" , iblock , max_blocks , inode -> i_ino ) ; cache_type = ext4_ext_in_cache ( inode , iblock , & newex ) ; if ( cache_type ) { if ( cache_type == EXT4_EXT_CACHE_GAP ) { if ( ( flags & EXT4_GET_BLOCKS_CREATE ) == 0 ) { goto out2 ; } } else if ( cache_type == EXT4_EXT_CACHE_EXTENT ) { newblock = iblock - le32_to_cpu ( newex . ee_block ) + ext_pblock ( & newex ) ; allocated = ext4_ext_get_actual_len ( & newex ) - ( iblock - le32_to_cpu ( newex . ee_block ) ) ; goto out ; } else { BUG ( ) ; } } path = ext4_ext_find_extent ( inode , iblock , NULL ) ; if ( IS_ERR ( path ) ) { err = PTR_ERR ( path ) ; path = NULL ; goto out2 ; } depth = ext_depth ( inode ) ; if ( path [ depth ] . p_ext == NULL && depth != 0 ) { ext4_error ( inode -> i_sb , ""badextentaddress"" ""inode:%lu,iblock:
",0,511
1059,"static int update_open_stateid ( struct nfs4_state * state , nfs4_stateid * open_stateid , nfs4_stateid * delegation , fmode_t fmode ) { struct nfs_inode * nfsi = NFS_I ( state -> inode ) ; struct nfs_delegation * deleg_cur ; int ret = 0 ; fmode &= ( FMODE_READ | FMODE_WRITE ) ; rcu_read_lock ( ) ; deleg_cur = rcu_dereference ( nfsi -> delegation ) ; if ( deleg_cur == NULL ) goto no_delegation ; spin_lock ( & deleg_cur -> lock ) ; if ( nfsi -> delegation != deleg_cur || ( ( deleg_cur -> type & open_flags ) != open_flags ) ) goto no_delegation_unlock ; if ( delegation == NULL ) delegation = & deleg_cur -> stateid ; else if ( memcmp ( deleg_cur -> stateid . data , delegation -> data , NFS4_STATEID_SIZE ) != 0 ) goto no_delegation_unlock ; nfs_mark_delegation_referenced ( deleg_cur ) ; fmode &= ( FMODE_READ | FMODE_WRITE ) ; rcu_read_unlock ( ) ; if ( ! ret && open_stateid != NULL ) { __update_open_stateid ( state , fmode , open_stateid , NULL , fmode ) ; ret = 1 ; } return ret ; }
",0,346
1060,"static Image * ReadGIFImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define BitSet ( byte , bit ) ( ( ( byte ) & ( bit ) ) == ( bit ) ) # define LSBFirstOrder ( x , y ) ( ( ( y ) << 8 ) | ( x ) ) Image * image , * meta_image ; int number_extensionss = 0 ; MagickBooleanType status ; RectangleInfo page ; register ssize_t i ; register unsigned char * p ; size_t delay , dispose , duration , global_colors , image_count , iterations , one ; ssize_t count , opacity ; unsigned char background , c , flag , * global_colormap , buffer [ 257 ] ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } count = ReadBlob ( image , 6 , buffer ) ; if ( ( count != 6 ) || ( ( LocaleNCompare ( ( char * ) buffer , ""GIF87"" , 5 ) != 0 ) && ( LocaleNCompare ( ( char * ) buffer , ""GIF89"" , 5 ) != 0 ) ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; page . width = ReadBlobLSBShort ( image ) ; page . height = ReadBlobLSBShort ( image ) ; flag = ( unsigned char ) ReadBlobByte ( image ) ; background = ( unsigned char ) ReadBlobByte ( image ) ; c = ( unsigned char ) ReadBlobByte ( image ) ; one = 1 ; global_colors = one << ( ( ( size_t ) flag & 0x07 ) + 1 ) ; global_
",0,511
1061,"static inline int btif_hl_select_close_connected ( void ) { char sig_on = btif_hl_signal_select_close_connected ; BTIF_TRACE_DEBUG ( ""btif_hl_select_close_connected"" ) ; return TEMP_FAILURE_RETRY ( send ( signal_fds [ 1 ] , & sig_on , sizeof ( sig_on ) , 0 ) ) ; }
",1,97
1062,"static void oidc_scrub_headers ( request_rec * r ) { oidc_cfg * cfg = ap_get_module_config ( r -> server -> module_config , & auth_openidc_module ) ; if ( cfg -> scrub_request_headers != 0 ) { oidc_scrub_request_headers ( r , OIDC_DEFAULT_HEADER_PREFIX , oidc_cfg_dir_authn_header ( r ) ) ; if ( ( strstr ( cfg -> claim_prefix , OIDC_DEFAULT_HEADER_PREFIX ) != cfg -> claim_prefix ) ) { oidc_scrub_request_headers ( r , cfg -> claim_prefix , NULL ) ; } } }
",0,175
1063,"static void model_rd_for_sb ( VP9_COMP * cpi , ThreadData * td , BLOCK_SIZE bsize , MACROBLOCK * x , MACROBLOCKD * xd , int * out_rate_sum , int64_t * out_dist_sum , const VP9_COMMON * cm , PC_TREE * pc_tree ) { int i ; int64_t rate_sum = 0 ; int64_t dist_sum = 0 ; const int ref = xd -> mi [ 0 ] -> mbmi . ref_frame [ 0 ] ; unsigned int sse ; if ( cm -> frame_type != KEY_FRAME ) return ; for ( i = 0 ; i < MAX_MB_PLANE ; ++ i ) { struct macroblock_plane * const p = & x -> plane [ i ] ; struct macroblockd_plane * const pd = & xd -> plane [ i ] ; const BLOCK_SIZE bs = get_plane_block_size ( bsize , pd ) ; const BLOCK_SIZE bs_per_sample = ( pd -> dequant [ 1 ] >> 3 ) ; const int quantizer = ( pd -> dequant [ 1 ] >> 3 ) ; if ( quantizer < 120 ) rate = ( square_error * ( 280 - quantizer ) ) >> 8 ; else rate = 0 ; dist = ( square_error * quantizer ) >> 8 ; rate_sum += rate ; dist_sum += dist ; } else { int rate ; int64_t dist ; vp9_model_rd_from_var_lapndz ( sse , 1 << num_pels_log2_lookup [ bs ] , pd -> dequant [ 1 ] >> 3 , & rate , & dist ) ; rate_sum += rate ; dist_sum += dist ; } } * out_rate_sum = ( int ) rate_sum ; * out_dist_sum = dist_sum << 4 ; }
",0,436
1064,"static void mincore_pmd_range ( struct vm_area_struct * vma , pud_t * pud , unsigned long addr , unsigned long end , unsigned char * vec ) { unsigned long next ; pmd_t * pmd ; pmd = pmd_offset ( pud , addr ) ; do { next = pmd_addr_end ( addr , end ) ; if ( pmd_trans_huge ( * pmd ) ) { if ( mincore_huge_pmd ( vma , pmd , addr , next , vec ) ) { vec += ( next - addr ) >> PAGE_SHIFT ; continue ; } } if ( pmd_none_or_clear_bad ( pmd ) ) mincore_unmapped_range ( vma , addr , next , vec ) ; else mincore_pte_range ( vma , pmd , addr , next , vec ) ; vec += ( next - addr ) >> PAGE_SHIFT ; } while ( pmd ++ , addr = next , addr != end ) ; }
",0,229
1065,"static void esis_print ( netdissect_options * ndo , const uint8_t * pptr , u_int length ) { const uint8_t * optr ; u_int li , esis_pdu_type , source_address_length , source_address_number ; const struct esis_header_t * esis_header ; if ( ! ndo -> ndo_eflag ) ND_PRINT ( ( ndo , ""ES-IS"" ) ) ; if ( length <= 2 ) { ND_PRINT ( ( ndo , ndo -> ndo_qflag ? ""badpkt!"" : ""noheaderatall!"" ) ) ; return ; } esis_header = ( const struct esis_header_t * ) pptr ; ND_TCHECK ( * pptr ) ; ND_TCHECK ( * pptr ) ; ND_PRINT ( ( ndo , "",v:%u%s"" , esis_header -> version , esis_header -> version ) ) ; if ( li > length ) { ND_PRINT ( ( ndo , ""lengthindicator(%u)>PDUsize(%u)!"" , li , length ) ) ; return ; } if ( li < sizeof ( struct esis_header_t ) + 2 ) { ND_PRINT ( ( ndo , ""lengthindicator%u<minPDUsize:"" , li ) ) ; while ( pptr < ndo -> ndo_snapend ) ND_PRINT ( ( ndo , ""%02X"" , * pptr ++ ) ) ; return ; } esis_pdu_type = esis_header -> type & ESIS_PDU_TYPE_MASK ; if ( ndo -> ndo_vflag < 1 ) { ND_PRINT ( ( ndo , ""%s%s,length%u"" , ndo -> ndo_eflag ? """" : "","" , tok2str ( esis_pdu_type ) ) ) ; return ; } ND_TCHECK ( * pptr ) ; ND_PRINT ( ( ndo , "",v:%u%s"" , esis_header -> version , esis_header -> version ) ) ; if ( li > length ) { ND_PRINT ( ( ndo , "",lengthindicator(%u)>
",0,511
1066,"static int parse_user_name ( char * user_input , char * * ret_username ) { register char * ptr ; register int index = 0 ; char username [ PAM_MAX_RESP_SIZE ] ; * ret_username = NULL ; bzero ( ( void * ) username , PAM_MAX_RESP_SIZE ) ; ptr = user_input ; while ( ( * ptr == '' ) || ( * ptr == '\\t' ) ) ptr ++ ; if ( * ptr == '\\0' ) { return ( PAM_BUF_ERR ) ; } while ( * ptr != '\\0' ) { if ( ( * ptr == '' ) || ( * ptr == '\\t' ) ) break ; else { username [ index ] = * ptr ; index ++ ; ptr ++ ; } } ptr = NULL ; if ( ( * ret_username = malloc ( index + 1 ) ) == NULL ) return ( PAM_BUF_ERR ) ; ( void ) strcpy ( * ret_username , username ) ; return ( PAM_SUCCESS ) ; }
",0,238
1067,"static int read_segment_id ( vpx_reader * r , const struct segmentation * seg ) { return seg -> tree_probs ; }
",0,36
1068,"int vmw_gb_surface_define_ioctl ( struct drm_device * dev , void * data , struct drm_file * file_priv ) { struct vmw_private * dev_priv = vmw_priv ( dev ) ; struct vmw_user_surface * user_srf ; struct vmw_surface * srf ; struct vmw_resource * res ; struct vmw_resource * tmp ; union drm_vmw_gb_surface_create_arg * arg = ( union drm_vmw_gb_surface_create_arg * ) data ; struct drm_vmw_gb_surface_create_req * req = & arg -> req ; struct drm_vmw_gb_surface_create_rep * rep = & arg -> rep ; struct ttm_object_file * tfile = vmw_fpriv ( file_priv ) -> tfile ; int ret ; uint32_t size ; uint32_t backup_handle ; if ( req -> multisample_count != 0 ) return - EINVAL ; if ( req -> mip_levels > DRM_VMW_MAX_MIP_LEVELS ) return - EINVAL ; if ( unlikely ( vmw_user_surface_size == 0 ) ) vmw_user_surface_size = ttm_round_pot ( sizeof ( * user_srf ) ) + 128 ; size = vmw_user_surface_size + 128 ; ret = vmw_surface_gb_priv_define ( dev , size , req -> svga3d_flags , req -> format , req -> drm_surface_flags & drm_vmw_surface_flag_scanout , req -> mip_levels , req -> multisample_count , req -> array_size , req -> base_size , & srf ) ; if ( unlikely ( ret != 0 ) ) return ret ; user_srf = container_of ( srf , struct vmw_user_surface , srf ) ; if ( drm_is_primary_client ( file_priv ) ) user_srf -> master = drm_master_get ( file_priv -> master ) ; ret = ttm_read_lock ( & dev_priv -> reservation_sem , true ) ; if ( unlikely ( ret != 0 ) ) return ret ; res = & user_sr
",0,511
1069,"static bool get_desc ( struct desc_struct * out , unsigned short sel ) { struct desc_ptr gdt_desc = { 0 , 0 } ; unsigned long desc_base ; # ifdef CONFIG_MODIFY_LDT_SYSCALL if ( ( sel & SEGMENT_TI_MASK ) == SEGMENT_LDT ) { bool success = false ; struct ldt_struct * ldt ; sel >>= 3 ; mutex_lock ( & current -> active_mm -> context . lock ) ; ldt = current -> active_mm -> context . ldt ; if ( ldt && sel < ldt -> nr_entries ) { * out = ldt -> entries [ sel ] ; success = true ; } mutex_unlock ( & current -> active_mm -> context . lock ) ; return success ; } # endif native_store_gdt ( & gdt_desc ) ; desc_base = sel & ~ ( SEGMENT_RPL_MASK | SEGMENT_TI_MASK ) ; if ( desc_base > gdt_desc . size ) return false ; * out = * ( struct desc_struct * ) ( gdt_desc . address + desc_base ) ; return true ; }
",1,277
1070,"static void extend_plane ( uint8_t * const src , int src_stride , int width , int height , int extend_top , int extend_left , int extend_bottom , int extend_right ) { int i ; const int linesize = extend_left + extend_right + width ; uint8_t * src_ptr1 = src ; uint8_t * src_ptr2 = src + width - 1 ; uint8_t * dst_ptr1 = src - extend_left ; uint8_t * dst_ptr2 = src + width ; for ( i = 0 ; i < height ; ++ i ) { memset ( dst_ptr1 , src_ptr1 [ 0 ] , extend_left ) ; memset ( dst_ptr2 , src_ptr2 [ 0 ] , extend_right ) ; src_ptr1 += src_stride ; src_ptr2 += src_stride ; dst_ptr1 += src_stride ; dst_ptr2 += src_stride ; } src_ptr1 = src - extend_left ; src_ptr2 = src + src_stride * ( height - 1 ) - extend_left ; dst_ptr1 = src + src_stride * - extend_top - extend_left ; dst_ptr2 = src + src_stride * height - extend_left ; for ( i = 0 ; i < extend_top ; ++ i ) { memcpy ( dst_ptr1 , src_ptr1 , linesize ) ; dst_ptr1 += src_stride ; } for ( i = 0 ; i < extend_bottom ; ++ i ) { memcpy ( dst_ptr2 , src_ptr2 , linesize ) ; dst_ptr2 += src_stride ; } }
",1,384
1071,"static void sctp_v6_get_dst ( struct sctp_transport * t , union sctp_addr * saddr , struct flowi * fl , struct sock * sk ) { struct sctp_association * asoc = t -> asoc ; struct dst_entry * dst = NULL ; struct flowi6 * fl6 = & fl -> u . ip6 ; struct sctp_bind_addr * bp ; struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct sctp_sockaddr_entry * laddr ; union sctp_addr * baddr = NULL ; union sctp_addr * daddr = & t -> ipaddr ; union sctp_addr dst_saddr ; struct ip6_proto ip6_proto = IPPROTO_SCTP ; if ( ipv6_addr_type ( & daddr -> v6 . sin6_addr ) & IPV6_ADDR_LINKLOCAL ) fl6 -> flowi6_oif = daddr -> v6 . sin6_scope_id ; pr_debug ( ""%s:dst=%pI6"" , __func__ , & fl6 -> daddr ) ; if ( asoc ) fl6 -> fl6_sport = htons ( asoc -> base . bind_addr . port ) ; if ( saddr ) { fl6 -> saddr = saddr -> v6 . sin6_addr ; fl6 -> fl6_sport = saddr -> v6 . sin6_port ; pr_debug ( ""src=%pI6-"" , & fl6 -> saddr ) ; } np -> saddr = saddr -> v6 . sin6_addr ; dst = ip6_dst_lookup_flow ( sk , fl6 , NULL , false ) ; if ( ! asoc || saddr ) goto out ; bp = & asoc -> base . bind_addr ; scope = sctp_scope ( daddr ) ; if ( ! IS_ERR ( dst ) ) { sctp_v6_saddr_ipv6_dst_ipv6_dst_ipv6_ipv6_ipv6_dst_ipv6_ipv6_ipv6_
",0,511
1072,"static void kgdb_hw_overflow_handler ( struct perf_event * event , struct perf_sample_data * data , struct pt_regs * regs ) { struct task_struct * tsk = current ; int i ; for ( i = 0 ; i < 4 ; i ++ ) if ( breakinfo [ i ] . enabled ) tsk -> thread . debugreg6 |= ( DR_TRAP0 << i ) ; }
",1,96
1073,"const u_char * smb_fdata ( netdissect_options * ndo , const u_char * buf , const char * fmt , const u_char * maxbuf , int unicodestr ) { static int depth = 0 ; char s [ 128 ] ; char * p ; while ( * fmt ) { switch ( * fmt ) { case '*' : fmt ++ ; while ( buf < maxbuf ) { const u_char * buf2 ; depth ++ ; buf2 = smb_fdata ( ndo , buf , fmt , maxbuf , unicodestr ) ; depth -- ; if ( buf2 == NULL ) return ( NULL ) ; if ( buf2 == buf ) return ( buf ) ; buf = buf2 ; } return ( buf ) ; case '|' : fmt ++ ; if ( buf >= maxbuf ) return ( buf ) ; break ; case '%' : fmt ++ ; buf = maxbuf ; break ; case '#' : fmt ++ ; return ( buf ) ; break ; case '[' : fmt ++ ; if ( buf >= maxbuf ) return ( buf ) ; memset ( s , 0 , sizeof ( s ) ) ; p = strchr ( fmt , ']' ) ; if ( ( size_t ) ( p - fmt + 1 ) > sizeof ( s ) ) { return ( buf ) ; } strncpy ( s , fmt , p - fmt ) ; s [ p - fmt ] = '\\0' ; fmt = p + 1 ; buf = smb_fdata1 ( ndo , buf , s , maxbuf , unicodestr ) ; if ( buf == NULL ) return ( NULL ) ; break ; default : ND_PRINT ( ( ndo , ""%c"" , * fmt ) ) ; fmt ++ ; break ; } } if ( ! depth && buf < maxbuf ) { size_t len = PTR_DIFF ( maxbuf , buf ) ; ND_PRINT ( ( ndo , ""Data:(%lubytes)\\n"" , ( unsigned long ) len ) ) ; smb_print_data ( ndo , buf , len ) ; return ( buf + len ) ; } return ( buf ) ; }
",0,472
1074,"void gsm_xsmp_client_connect ( GsmXSMPClient * client , SmsConn conn , unsigned long * mask_ret , SmsCallbacks * callbacks_ret ) { client -> priv -> conn = conn ; g_debug ( ""GsmXSMPClient:Initializingclient%s"" , client -> priv -> description ) ; * mask_ret = 0 ; * mask_ret |= SmsRegisterClientProcMask ; callbacks_ret -> register_client . callback = register_client_callback ; callbacks_ret -> register_client . manager_data = client ; * mask_ret |= SmsInteractRequestProcMask ; callbacks_ret -> interact_request . callback = interact_request_callback ; callbacks_ret -> interact_request . manager_data = client ; * mask_ret |= SmsInteractDoneProcMask ; callbacks_ret -> interact_done . callback = interact_done_callback ; callbacks_ret -> interact_done . manager_data = client ; * mask_ret |= SmsSaveYourselfRequestProcMask ; callbacks_ret -> save_yourself_request . callback = save_yourself_request_callback ; callbacks_ret -> save_yourself_request . manager_data = client ; * mask_ret |= SmsSaveYourselfP2RequestProcMask ; callbacks_ret -> save_yourself_phase2_request . callback = save_yourself_phase2_request_callback ; callbacks_ret -> save_yourself_phase2_request . manager_data = client ; * mask_ret |= SmsSaveYourselfDoneProcMask ; callbacks_ret -> save_yourself_done . callback = save_yourself_done_callback ; callbacks_ret -> save_yourself_done . manager_data = client ; * mask_ret |= SmsCloseConnectionProcMask ; callbacks_ret -> close_connection . callback = close_connection_callback ; callbacks_ret -> close_connection . manager_data = client ; * mask_ret |= SmsSetPropertiesProcMask ; callbacks_ret -> set_properties . callback = set_properties_callback ; callbacks_ret -> set_properties . manager_data = client ; * mask_ret |= SmsDeleteProperties
",0,511
1075,"static int wb_prep ( netdissect_options * ndo , const struct pkt_prep * prep , u_int len ) { int n ; const struct pgstate * ps ; const u_char * ep = ndo -> ndo_snapend ; ND_PRINT ( ( ndo , ""wb-prep:"" ) ) ; if ( len < sizeof ( * prep ) ) { return ( - 1 ) ; } n = EXTRACT_32BITS ( & prep -> pp_n ) ; ps = ( const struct pgstate * ) ( prep + 1 ) ; while ( -- n >= 0 && ND_TTEST2 ( * ps ) ) { const struct id_off * io , * ie ; char c = '<' ; ND_PRINT ( ( ndo , ""%u/%s:%u"" , EXTRACT_32BITS ( & ps -> slot ) , ipaddr_string ( ndo , & ps -> page . p_sid ) , EXTRACT_32BITS ( & ps -> page . p_uid ) ) ) ; io = ( struct id_off * ) ( ps + 1 ) ; for ( ie = io + ps -> nid ; io < ie && ND_TTEST2 ( * io ) ; ++ io ) { ND_PRINT ( ( ndo , ""%c%s:%u"" , c , ipaddr_string ( ndo , & io -> id ) , EXTRACT_32BITS ( & io -> off ) ) ) ; c = ',' ; } ND_PRINT ( ( ndo , "">"" ) ) ; ps = ( struct pgstate * ) io ; } return ( ( u_char * ) ps <= ep ? 0 : - 1 ) ; }
",0,377
1076,"error_t ksz8851SendPacket ( NetInterface * interface , const NetBuffer * buffer , size_t offset , NetTxAncillary * ancillary ) { size_t n ; size_t length ; Ksz8851TxHeader header ; Ksz8851Context * context ; context = ( Ksz8851Context * ) interface -> nicContext ; length = netBufferGetLength ( buffer ) - offset ; if ( length > ETH_MAX_FRAME_SIZE ) { osSetEvent ( & interface -> nicTxEvent ) ; return ERROR_INVALID_LENGTH ; } n = ksz8851ReadReg ( interface , KSZ8851_REG_TXMIR ) & TXMIR_TXMA_MASK ; if ( n < ( length + 8 ) ) { return ERROR_FAILURE ; } netBufferRead ( context -> txBuffer , buffer , offset , length ) ; header . controlWord = htole16 ( TX_CTRL_TXIC | ( context -> frameId ++ & TX_CTRL_TXFID ) ) ; header . byteCount = htole16 ( length ) ; ksz8851SetBit ( interface , KSZ8851_RXQCR , RXQCR_SDA ) ; ksz8851WriteFifo ( interface , ( uint8_t * ) & header , sizeof ( Ksz8851TxHeader ) ) ; ksz8851WriteFifo ( interface , context -> txBuffer , length ) ; ksz8851ClearBit ( interface , KSZ8851_RXQCR , RXQCR_SDA ) ; ksz8851SetBit ( interface , KSZ8851_TXQCR , TXQCR_METFE ) ; n = ksz8851ReadReg ( interface , KSZ8851_REG_TXMIR ) & TXMIR_TXMA_MASK ; if ( n >= ( ETH_MAX_FRAME_SIZE + 8 ) ) { osSetEvent ( & interface -> nicTxEvent ) ; } return NO_ERROR ; }
",0,457
1077,"static VALUE ossl_cipher_set_key ( VALUE self , VALUE key ) { EVP_CIPHER_CTX * ctx ; int key_len ; StringValue ( key ) ; GetCipher ( self , ctx ) ; key_len = EVP_CIPHER_CTX_key_length ( ctx ) ; if ( RSTRING_LEN ( key ) != key_len ) ossl_raise ( rb_eArgError , ""keymustbe%dbytes"" , key_len ) ; if ( EVP_CipherInit_ex ( ctx , NULL , NULL , ( unsigned char * ) RSTRING_PTR ( key ) , NULL , - 1 ) != 1 ) ossl_raise ( eCipherError , NULL ) ; rb_ivar_set ( self , id_key_set , Qtrue ) ; return key ; }
",1,199
1078,"static bool assoc_array_insert_into_terminal_node ( struct assoc_array_edit * edit , const struct assoc_array_ops * ops , const void * index_key , struct assoc_array_walk_result * result ) { struct assoc_array_shortcut * shortcut , * new_s0 ; struct assoc_array_node * node , * new_n0 , * new_n1 , * side ; struct assoc_array_ptr * ptr ; unsigned long dissimilarity , base_seg , blank ; size_t keylen ; bool have_meta ; int level , diff ; int slot , next_slot , free_slot , i , j ; node = result -> terminal_node . node ; level = result -> terminal_node . level ; edit -> segment_cache [ ASSOC_ARRAY_FAN_OUT ] = result -> terminal_node . slot ; pr_devel ( ""-->%s()\\n"" , __func__ ) ; free_slot = - 1 ; for ( i = 0 ; i < ASSOC_ARRAY_FAN_OUT ; i ++ ) { ptr = node -> slots [ i ] ; if ( ! ptr ) { free_slot = i ; continue ; } if ( assoc_array_ptr_is_leaf ( ptr ) && ops -> compare_object ( assoc_array_ptr_to_leaf ( ptr ) , index_key ) ) { pr_devel ( ""replaceinslot%d\\n"" , i ) ; edit -> leaf_p = & node -> slots [ i ] ; edit -> dead_leaf = node -> slots [ i ] ; pr_devel ( ""<--%s()=ok[replace]\\n"" , __func__ ) ; return true ; } } if ( free_slot >= 0 ) { pr_devel ( ""insertinfreeslot%d\\n"" , free_slot ) ; edit -> leaf_p = & node -> slots [ free_slot ] ; edit -> adjust_count_on = node ; pr_devel ( ""<--%s()=ok[insert]\\n"" , __func__ ) ; return true ; } new_n0 = kzalloc ( sizeof ( struct assoc_array_node ) , GFP_KERNEL ) ; if ( ! new_n0 ) return false
",0,511
1079,"static void settings_init ( void ) { settings . use_cas = true ; settings . access = 0700 ; settings . port = 11211 ; settings . udpport = 0 ; settings . inter = NULL ; settings . maxbytes = 64 * 1024 * 1024 ; settings . maxconns = 1024 ; settings . verbose = 0 ; settings . oldest_live = 0 ; settings . oldest_cas = 0 ; settings . evict_to_free = 1 ; settings . socketpath = NULL ; settings . factor = 1.25 ; settings . chunk_size = 48 ; settings . num_threads = 4 ; settings . num_threads_per_udp = 0 ; settings . prefix_delimiter = ':' ; settings . detail_enabled = 0 ; settings . reqs_per_event = 20 ; settings . backlog = 1024 ; settings . binding_protocol = negotiating_prot ; settings . item_size_max = 1024 * 1024 ; settings . slab_page_size = 1024 * 1024 ; settings . slab_chunk_size_max = settings . slab_page_size / 2 ; settings . sasl = false ; settings . maxconns_fast = true ; settings . lru_crawler = false ; settings . lru_crawler_sleep = 100 ; settings . lru_crawler_tocrawl = 0 ; settings . lru_maintainer_thread = false ; settings . lru_segmented = true ; settings . hot_lru_pct = 20 ; settings . warm_lru_pct = 40 ; settings . hot_max_factor = 0.2 ; settings . warm_max_factor = 2.0 ; settings . inline_ascii_response = false ; settings . temp_lru = false ; settings . temporary_ttl = 61 ; settings . idle_timeout = 0 ; settings . hashpower_init = 0 ; settings . slab_reassign = true ; settings . slab_automove = 1 ; settings . slab_automove_ratio = 0.8 ; settings . slab_automove_window = 30 ; settings . shutdown_command = false ; settings . tail_repair_time = TAIL_REPAIR_TIME_DEFAULT ; settings . flush_enabled = true ; settings . dump_enabled = true ; settings . crawls_persleep = 1000 ; settings .
",0,511
1080,"static guint32 finalizer_thread ( gpointer unused ) { while ( ! finished ) { g_assert ( mono_domain_get ( ) == mono_get_root_domain ( ) ) ; # ifdef MONO_HAS_SEMAPHORES MONO_SEM_WAIT ( & finalizer_sem ) ; # else WaitForSingleObjectEx ( finalizer_event , INFINITE , FALSE ) ; # endif mono_console_handle_async_ops ( ) ; # ifndef DISABLE_ATTACH mono_attach_maybe_start ( NULL ) ; mono_console_handle_async_ops ( ) ; if ( domains_to_finalize ) { mono_finalizer_lock ( ) ; if ( domains_to_finalize ) { DomainFinalizationReq * req = domains_to_finalize -> data ; domains_to_finalize = g_slist_remove ( domains_to_finalize , req ) ; mono_finalizer_unlock ( ) ; finalize_domain_objects ( req ) ; } else { mono_finalizer_unlock ( ) ; } } mono_gc_invoke_finalizers ( ) ; SetEvent ( pending_done_event ) ; } SetEvent ( shutdown_event ) ; return 0 ; }
",0,281
1081,"VOID ixheaacd_esbr_postradixcompute2 ( WORD32 * ptr_y , WORD32 * ptr_x , const WORD32 * pdig_rev_tbl , WORD32 npoints ) { WORD32 i , k ; WORD32 h2 ; WORD32 x_0 , x_1 , x_2 , x_3 ; WORD32 x_4 , x_5 , x_6 , x_7 ; WORD32 x_8 , x_9 , x_a , x_b , x_c , x_d , x_e , x_f ; WORD32 n00 , n10 , n20 , n30 , n01 , n11 , n21 , n31 ; WORD32 n02 , n12 , n22 , n32 , n03 , n13 , n23 , n33 ; WORD32 n0 , j0 ; WORD32 * x2 , * x0 ; WORD32 * y0 , * y1 , * y2 , * y3 ; y0 = ptr_y ; y2 = ptr_y + ( WORD32 ) npoints ; x0 = ptr_x ; x2 = ptr_x + ( WORD32 ) ( npoints >> 1 ) ; y1 = y0 + ( WORD32 ) ( npoints >> 2 ) ; y3 = y2 + ( WORD32 ) ( npoints >> 2 ) ; j0 = 8 ; n0 = npoints >> 1 ; for ( k = 0 ; k < 2 ; k ++ ) { for ( i = 0 ; i < npoints >> 1 ; i += 8 ) { h2 = * pdig_rev_tbl ++ >> 2 ; x_0 = * x0 ++ ; x_1 = * x0 ++ ; x_2 = * x0 ++ ; x_3 = * x0 ++ ; x_4 = * x0 ++ ; x_5 = * x0 ++ ; x_6 = * x0 ++ ; x_7 = * x0 ++ ; n00 = x_0 + x_2 ; n01 = x_1 + x_3 ; n20 = x_0 - x_2 ; n21 = x_1 - x_3 ; n10 = x_4 + x_6 ; n11 = x_5
",0,511
1082,"int drm_mode_dirtyfb_ioctl ( struct drm_device * dev , void * data , struct drm_file * file_priv ) { struct drm_clip_rect __user * clips_ptr ; struct drm_clip_rect * clips = NULL ; struct drm_mode_fb_dirty_cmd * r = data ; struct drm_mode_object * obj ; struct drm_framebuffer * fb ; unsigned flags ; int num_clips ; int ret = 0 ; if ( ! drm_core_check_feature ( dev , DRIVER_MODESET ) ) return - EINVAL ; mutex_lock ( & dev -> mode_config . mutex ) ; obj = drm_mode_object_find ( dev , r -> fb_id , DRM_MODE_OBJECT_FB ) ; if ( ! obj ) { DRM_ERROR ( ""invalidframebufferid\\n"" ) ; ret = - EINVAL ; goto out_err1 ; } fb = obj_to_fb ( obj ) ; num_clips = r -> num_clips ; clips_ptr = ( struct drm_clip_rect * ) ( unsigned long ) r -> clips_ptr ; if ( ! num_clips != ! clips_ptr ) { ret = - EINVAL ; goto out_err1 ; } flags = DRM_MODE_FB_DIRTY_FLAGS & r -> flags ; if ( flags & DRM_MODE_FB_DIRTY_ANNOTATE_COPY && ( num_clips % 2 ) ) { ret = - EINVAL ; goto out_err1 ; } if ( num_clips && clips_ptr ) { if ( num_clips + 1 > r -> num_clips ) return - EINVAL ; clips = kzalloc ( num_clips * sizeof ( * clips ) , GFP_KERNEL ) ; if ( ! clips ) { ret = - ENOMEM ; goto out_err1 ; } ret = copy_from_user ( clips , clips_ptr , num_clips * sizeof ( * clips ) ) ; if ( ret ) { ret = - EFAULT ; goto out_err2 ; } } if ( fb -> funcs -> dirty ) { ret = fb -> funcs -> dirty ( fb , file_priv , flags , r -> color , clips , num
",0,511
1083,"static inline int unuse_pmd_range ( struct vm_area_struct * vma , pud_t * pud , unsigned long addr , unsigned long end , swp_entry_t entry , struct page * page ) { pmd_t * pmd ; unsigned long next ; int ret ; pmd = pmd_offset ( pud , addr ) ; do { next = pmd_addr_end ( addr , end ) ; if ( unlikely ( pmd_trans_huge ( * pmd ) ) ) continue ; if ( pmd_none_or_clear_bad ( pmd ) ) continue ; ret = unuse_pte_range ( vma , pmd , addr , next , entry , page ) ; if ( ret ) return ret ; } while ( pmd ++ , addr = next , addr != end ) ; return 0 ; }
",0,187
1084,"static int misaligned_fpu_store ( struct pt_regs * regs , __u32 opcode , int displacement_not_indexed , int width_shift , int do_paired_load ) { int error ; int srcreg ; __u64 address ; error = generate_and_check_address ( regs , opcode , displacement_not_indexed , width_shift , & address ) ; if ( error < 0 ) { return error ; } perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , regs , address ) ; srcreg = ( opcode >> 4 ) & 0x3f ; if ( user_mode ( regs ) ) { __u64 buffer ; __u32 buflo = 0xffffffffUL , bufhi = 0xffffffffUL ; if ( ! access_ok ( VERIFY_WRITE , ( unsigned long ) address , 1UL << width_shift ) ) { return - 1 ; } if ( last_task_used_math == current ) { enable_fpu ( ) ; save_fpu ( current ) ; disable_fpu ( ) ; last_task_used_math = NULL ; regs -> sr |= SR_FD ; } switch ( width_shift ) { case 2 : buflo = current -> thread . xstate -> hardfpu . fp_regs [ srcreg ] ; break ; case 3 : if ( do_paired_load ) { buflo = current -> thread . xstate -> hardfpu . fp_regs [ srcreg ] ; bufhi = current -> thread . xstate -> hardfpu . fp_regs [ srcreg + 1 ] ; } else { # if defined ( CONFIG_CPU_LITTLE_ENDIAN ) bufhi = current -> thread . xstate -> hardfpu . fp_regs [ srcreg ] ; buflo = current -> thread . xstate -> hardfpu . fp_regs [ srcreg + 1 ] ; # else buflo = current -> thread . xstate -> hardfpu . fp_regs [ srcreg ] ; bufhi = current -> thread . xstate -> hardfpu . fp_regs [ srcreg + 1 ] ; # endif } break ; default : printk ( ""Unexpectedwidth_shift%dinmis
",0,511
1085,"static void core_anal_bytes ( RCore * core , const ut8 * buf , int len , int nops , int fmt ) { int stacksize = r_config_get_i ( core -> config , ""esil.stack.depth"" ) ; bool iotrap = r_config_get_i ( core -> config , ""esil.iotrap"" ) ; bool romem = r_config_get_i ( core -> config , ""esil.romem"" ) ; bool stats = r_config_get_i ( core -> config , ""esil.stats"" ) ; bool be = core -> print -> big_endian ; bool use_color = core -> print -> flags & R_PRINT_FLAGS_COLOR ; core -> parser -> relsub = r_config_get_i ( core -> config , ""asm.relsub"" ) ; int ret , i , j , idx , size ; const char * color = """" ; const char * esilstr ; const char * opexstr ; RAnalHint * hint ; RAnalEsil * esil = NULL ; RAsmOp asmop ; RAnalOp op = { 0 } ; ut64 addr ; bool isFirst = true ; unsigned int addrsize = r_config_get_i ( core -> config , ""esil.addr.size"" ) ; int totalsize = 0 ; if ( use_color ) { color = core -> cons -> pal . label ; } switch ( fmt ) { case 'j' : r_cons_printf ( ""["" ) ; break ; case 'r' : esil = r_anal_esil_new ( stacksize , iotrap , addrsize ) ; if ( ! esil ) { return ; } r_anal_esil_to_reil_setup ( esil , core -> anal , romem , stats ) ; r_anal_esil_set_pc ( esil , core -> offset ) ; break ; } for ( i = idx = ret = 0 ; idx < len && ( ! nops || ( nops && i < nops ) ) ; i ++ , idx += ret ) { addr = core -> offset + idx ; hint = r_anal_hint_get ( core -> anal , addr ) ; r_asm_set_
",0,511
1086,"int main ( int argc , char * argv [ ] ) { char * fin , * fout ; FILE * fpin , * fpout ; uint8_t * inbuf , * outbuf ; uint8_t * inbuf_u , * outbuf_u ; uint8_t * inbuf_v , * outbuf_v ; int f , frames ; int width , height , target_width , target_height ; if ( argc < 5 ) { printf ( ""Incorrectparameters:\\n"" ) ; usage ( argv [ 0 ] ) ; return 1 ; } fin = argv [ 1 ] ; fout = argv [ 4 ] ; if ( ! parse_dim ( argv [ 2 ] , & width , & height ) ) { printf ( ""Incorrectparameters:%s\\n"" , argv [ 2 ] ) ; usage ( argv [ 0 ] ) ; return 1 ; } if ( ! parse_dim ( argv [ 3 ] , & target_width , & target_height ) ) { printf ( ""Incorrectparameters:%s\\n"" , argv [ 3 ] ) ; usage ( argv [ 0 ] ) ; return 1 ; } fpin = fopen ( fin , ""rb"" ) ; if ( fpin == NULL ) { printf ( ""Can\'topenfile%storead\\n"" , fin ) ; usage ( argv [ 0 ] ) ; return 1 ; } fpout = fopen ( fout , ""wb"" ) ; if ( fpout == NULL ) { printf ( ""Can\'topenfile%stowrite\\n"" , fout ) ; usage ( argv [ 0 ] ) ; return 1 ; } if ( argc >= 6 ) frames = atoi ( argv [ 5 ] ) ; else frames = INT_MAX ; printf ( ""Inputsize:%dx%d\\n"" , width , height ) ; printf ( ""Targetsize:%dx%d,Frames:"" , target_width , target_height ) ; if ( frames == INT_MAX ) printf ( ""All\\n"" ) ; else printf ( ""%d\\n"" , frames ) ; inbuf = ( uint8_t * ) malloc ( width * height * 3 / 2 ) ; outbuf = ( uint8_t * ) malloc ( width * height * 3 / 4
",0,511
1087,"static irqreturn_t snd_msnd_interrupt ( int irq , void * dev_id ) { struct snd_msnd * chip = dev_id ; void * pwDSPQData = chip -> mappedbase + DSPQ_DATA_BUFF ; u16 head , tail , size ; head = readw ( chip -> DSPQ + JQS_wHead ) + 1 ; if ( wTmp > readw ( chip -> DSPQ + JQS_wSize ) ) writew ( 0 , chip -> DSPQ + JQS_wHead ) ; else writew ( wTmp , chip -> DSPQ + JQS_wHead ) ; } inb ( chip -> io + HP_RXL ) ; return IRQ_HANDLED ; }
",1,179
1088,"static OPCODE_DESC * avr_op_analyze ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * buf , int len , CPU_MODEL * cpu ) { OPCODE_DESC * opcode_desc ; if ( len < 2 ) { return NULL ; } ut16 ins = ( buf [ 1 ] << 8 ) | buf [ 0 ] ; int fail ; char * t ; memset ( op , 0 , sizeof ( RAnalOp ) ) ; op -> ptr = UT64_MAX ; op -> val = UT64_MAX ; op -> jump = UT64_MAX ; r_strbuf_init ( & op -> esil ) ; for ( opcode_desc = opcodes ; opcode_desc -> handler ; opcode_desc ++ ) { if ( ( ins & opcode_desc -> mask ) == opcode_desc -> selector ) { fail = 0 ; op -> cycles = opcode_desc -> cycles ; op -> size = opcode_desc -> size ; op -> type = opcode_desc -> type ; op -> jump = UT64_MAX ; op -> fail = UT64_MAX ; op -> addr = addr ; r_strbuf_setf ( & op -> esil , """" ) ; opcode_desc -> handler ( anal , op , buf , len , & fail , cpu ) ; if ( fail ) { goto INVALID_OP ; } if ( op -> cycles <= 0 ) { opcode_desc -> cycles = 2 ; } op -> nopcode = ( op -> type == R_ANAL_OP_TYPE_UNK ) ; t = r_strbuf_get ( & op -> esil ) ; if ( t && strlen ( t ) > 1 ) { t += strlen ( t ) - 1 ; if ( * t == ',' ) { * t = '\\0' ; } } return opcode_desc ; } } if ( ( ins & 0xff00 ) == 0xff00 && ( ins & 0xf ) > 7 ) { goto INVALID_OP ; } INVALID_OP : op -> family = R_ANAL_OP_FAMILY_UNKNOWN ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> addr = addr ; op -> fail = UT64_MAX ; op ->
",0,511
1089,"void acpi_ns_terminate ( void ) { acpi_status status ; union acpi_operand_object * prev ; union acpi_operand_object * next ; ACPI_FUNCTION_TRACE ( ns_terminate ) ; next = acpi_gbl_module_code_list ; while ( next ) { prev = next ; next = next -> method . mutex ; prev -> method . mutex = NULL ; acpi_ut_remove_reference ( prev ) ; } acpi_ns_delete_namespace_subtree ( acpi_gbl_root_node ) ; status = acpi_ut_acquire_mutex ( ACPI_MTX_NAMESPACE ) ; if ( ACPI_FAILURE ( status ) ) { return_VOID ; } acpi_ns_delete_node ( acpi_gbl_root_node ) ; ( void ) acpi_ut_release_mutex ( ACPI_MTX_NAMESPACE ) ; ACPI_DEBUG_PRINT ( ( ACPI_DB_INFO , ""Namespacefreed\\n"" ) ) ; return_VOID ; }
",1,251
1090,"void ParseNameValue ( const char * buffer , int bufsize , struct NameValueParserData * data ) { struct xmlparser parser ; memset ( data , 0 , sizeof ( struct NameValueParserData ) ) ; parser . xmlstart = buffer ; parser . xmlsize = bufsize ; parser . data = data ; parser . starteltfunc = NameValueParserStartElt ; parser . endeltfunc = NameValueParserEndElt ; parser . datafunc = NameValueParserGetData ; parser . attfunc = 0 ; parsexml ( & parser ) ; }
",1,121
1091,"int mp4client_main ( int argc , char * * argv ) { char c ; const char * str ; int ret_val = 0 ; u32 i , times [ 100 ] , nb_times , dump_mode ; u32 simulation_time_in_ms = 0 ; u32 initial_service_id = 0 ; Bool auto_exit = GF_FALSE ; Bool logs_set = GF_FALSE ; Bool start_fs = GF_FALSE ; Bool use_rtix = GF_FALSE ; Bool pause_at_first = GF_FALSE ; Bool no_cfg_save = GF_FALSE ; Bool is_cfg_only = GF_FALSE ; Double play_from = 0 ; # ifdef GPAC_MEMORY_TRACKING GF_MemTrackerType mem_track = GF_MemTrackerNone ; # endif Double fps = GF_IMPORT_DEFAULT_FPS ; Bool fill_ar , visible , do_uncache , has_command ; char * url_arg , * out_arg , * the_cfg , * rti_file , * views , * mosaic ; FILE * logfile = NULL ; Float scale = 1 ; # ifndef WIN32 dlopen ( NULL , RTLD_NOW | RTLD_GLOBAL ) ; # endif strcpy ( the_url , ""."" ) ; memset ( & user , 0 , sizeof ( GF_User ) ) ; dump_mode = DUMP_NONE ; fill_ar = visible = do_uncache = has_command = GF_FALSE ; url_arg = out_arg = the_cfg = rti_file = views = mosaic = NULL ; nb_times = 0 ; times [ 0 ] = 0 ; for ( i = 1 ; i < ( u32 ) argc ; i ++ ) { char * arg = argv [ i ] ; if ( ! strcmp ( arg , ""-c"" ) || ! strcmp ( arg , ""-cfg"" ) ) { the_cfg = argv [ i + 1 ] ; i ++ ; } else if ( ! strcmp ( arg , ""-mem-track"" ) || ! strcmp ( arg , ""-mem-track-stack"" ) ) { # ifdef GPAC_MEMORY_TRACKING mem_track = ! strcmp (
",0,511
1092,"static int add_attributes ( PyTypeObject * type , char * * attrs , int num_fields ) { int i , result ; _Py_IDENTIFIER ( _attributes ) ; PyObject * s , * l = PyTuple_New ( num_fields ) ; if ( ! l ) return 0 ; for ( i = 0 ; i < num_fields ; i ++ ) { s = PyUnicode_FromString ( attrs [ i ] ) ; if ( ! s ) { Py_DECREF ( l ) ; return 0 ; } PyTuple_SET_ITEM ( l , i , s ) ; } result = _PyObject_SetAttrId ( ( PyObject * ) type , & PyId__attributes , l ) >= 0 ; Py_DECREF ( l ) ; return result ; }
",0,180
1093,"struct key * request_key_and_link ( struct key_type * type , const char * description , const void * callout_info , size_t callout_len , void * aux , struct key * dest_keyring , unsigned long flags ) { struct keyring_search_context ctx = { . index_key . type = type , . index_key . description = description , . cred = current_cred ( ) , . match_data . cmp = key_default_cmp , . match_data . raw_data = description , . match_data . lookup_type = KEYRING_SEARCH_LOOKUP_DIRECT , } ; struct key * key ; key_ref_t key_ref ; int ret ; kenter ( ""%s,%s,%p,%zu,%p,%lx"" , ctx . index_key . type -> name , ctx . index_key . description , callout_info , callout_len , aux , dest_keyring , flags ) ; if ( type -> match_preparse ) { ret = type -> match_preparse ( & ctx . match_data ) ; if ( ret < 0 ) { key = ERR_PTR ( ret ) ; goto error ; } } key_ref = search_process_keyrings ( & ctx ) ; if ( ! IS_ERR ( key_ref ) ) { key = key_ref_to_ptr ( key_ref ) ; if ( dest_keyring ) { construct_get_dest_keyring ( & dest_keyring ) ; ret = key_link ( dest_keyring , key ) ; key_put ( dest_keyring ) ; if ( ret < 0 ) { key_put ( key ) ; key = ERR_PTR ( ret ) ; goto error_free ; } } } else if ( PTR_ERR ( key_ref ) != - EAGAIN ) { key = ERR_CAST ( key_ref ) ; } else { key = ERR_PTR ( - ENOKEY ) ; if ( ! callout_info ) goto error_free ; key = construct_key_and_link ( & ctx , callout_info , callout_len , aux , dest_keyring , flags ) ; } error_free : if ( type -> match_
",0,511
1094,"static vpx_codec_err_t vp8e_init ( vpx_codec_ctx_t * ctx , vpx_codec_priv_enc_mr_cfg_t * mr_cfg ) { vpx_codec_err_t res = VPX_CODEC_OK ; struct vpx_codec_alg_priv * priv ; vpx_codec_enc_cfg_t * cfg ; unsigned int i ; struct VP8_COMP * optr ; vp8_rtcd ( ) ; if ( ! ctx -> priv ) { return VPX_CODEC_MEM_ERROR ; } priv = safe_calloc ( sizeof ( struct vpx_codec_alg_priv ) ) ; if ( ! priv ) { return VPX_CODEC_MEM_ERROR ; } ctx -> priv = & priv -> base ; ctx -> priv -> sz = sizeof ( * ctx -> priv ) ; ctx -> priv -> iface = ctx -> iface ; ctx -> priv -> alg_priv = priv ; ctx -> priv -> init_flags = ctx -> init_flags ; if ( ctx -> config . enc ) { priv -> cfg = * ctx -> config . enc ; ctx -> config . enc = & priv -> alg_priv -> cfg ; } priv -> cfg = & ctx -> priv -> alg_priv -> cfg ; for ( i = 0 ; extracfg_map [ i ] . usage && extracfg_map [ i ] . usage != cfg -> g_usage ; i ++ ) ; } priv -> vp8_cfg = extracfg_map [ i ] . cfg ; priv -> vp8_cfg . pkt_list = & priv -> pkt_list . head ; priv -> cx_data_sz = priv -> cfg . g_w * priv -> cfg . g_h * 3 / 2 * 2 ; if ( priv -> cx_data_sz < 32768 ) priv -> cx_data_sz = 32768 ; priv -> cx_data = malloc ( priv -> cx_data_sz ) ; if ( ! priv -> cx_data ) { return VPX_CODEC_MEM_ERROR ; } if ( ! priv -> cx_
",0,511
1095,"int xfs_attr_shortform_to_leaf ( struct xfs_da_args * args , struct xfs_buf * * leaf_bp ) { xfs_inode_t * dp ; xfs_attr_shortform_t * sf ; xfs_attr_sf_entry_t * sfe ; xfs_da_args_t nargs ; char * tmpbuffer ; int error , i , size ; xfs_dablk_t blkno ; struct xfs_buf * bp ; xfs_ifork_t * ifp ; trace_xfs_attr_sf_to_leaf ( args ) ; dp = args -> dp ; ifp = dp -> i_afp ; sf = ( xfs_attr_shortform_t * ) ifp -> if_u1 . if_data ; size = be16_to_cpu ( sf -> hdr . totsize ) ; tmpbuffer = kmem_alloc ( size , KM_SLEEP ) ; ASSERT ( tmpbuffer != NULL ) ; memcpy ( tmpbuffer , ifp -> if_u1 . if_data , size ) ; sf = ( xfs_attr_shortform_t * ) tmpbuffer ; xfs_idata_realloc ( dp , - size , XFS_ATTR_FORK ) ; xfs_bmap_local_to_extents_empty ( dp , XFS_ATTR_FORK ) ; bp = NULL ; error = xfs_da_grow_inode ( args , & blkno ) ; if ( error ) { if ( error == - EIO ) goto out ; xfs_idata_realloc ( dp , size , XFS_ATTR_FORK ) ; memcpy ( ifp -> if_u1 . if_data , tmpbuffer , size ) ; goto out ; } ASSERT ( blkno == 0 ) ; error = xfs_attr3_leaf_create ( args , blkno , & bp ) ; if ( error ) { memcpy ( ifp -> if_u1 . if_data , tmpbuffer , size ) ; goto out ; } xfs_da_shrink_inode ( args , 0 , bp ) ; bp = NULL ; if (
",0,511
1096,"static int decode_unit ( SCPRContext * s , PixelModel * pixel , unsigned step , unsigned * rval ) { GetByteContext * gb = & s -> gb ; RangeCoder * rc = & s -> rc ; unsigned totfr = pixel -> total_freq ; unsigned value , x = 0 , cumfr = 0 , cnt_x = 0 ; int i , j , ret , c , cnt_c ; if ( ( ret = s -> get_freq ( rc , totfr , & value ) ) < 0 ) return ret ; while ( x < 16 ) { cnt_x = pixel -> lookup [ x ] ; if ( value >= cumfr + cnt_x ) cumfr += cnt_x ; else break ; x ++ ; } c = x * 16 ; cnt_c = 0 ; while ( c < 256 ) { cnt_c = pixel -> freq [ c ] ; if ( value >= cumfr + cnt_c ) cumfr += cnt_c ; else break ; c ++ ; } if ( ( ret = s -> decode ( gb , rc , cumfr , cnt_c , totfr ) ) < 0 ) return ret ; pixel -> freq [ c ] = cnt_c + step ; pixel -> lookup [ x ] = cnt_x + step ; totfr += step ; if ( totfr > BOT ) { totfr = 0 ; for ( i = 0 ; i < 256 ; i ++ ) { unsigned nc = ( pixel -> freq [ i ] >> 1 ) + 1 ; pixel -> freq [ i ] = nc ; totfr += nc ; } for ( i = 0 ; i < 16 ; i ++ ) { unsigned sum = 0 ; unsigned i16_17 = i << 4 ; for ( j = 0 ; j < 16 ; j ++ ) sum += pixel -> freq [ i16_17 + j ] ; pixel -> lookup [ i ] = sum ; } } pixel -> total_freq = totfr ; * rval = c & s -> cbits ; return 0 ; }
",0,451
1097,"int snd_timer_close ( struct snd_timer_instance * timeri ) { struct snd_timer * timer = NULL ; struct snd_timer_instance * slave , * tmp ; if ( snd_BUG_ON ( ! timeri ) ) return - ENXIO ; snd_timer_stop ( timeri ) ; if ( timeri -> flags & SNDRV_TIMER_IFLG_SLAVE ) { spin_lock_irq ( & slave_active_lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & slave_active_lock ) ; udelay ( 10 ) ; spin_lock_irq ( & slave_active_lock ) ; } spin_unlock_irq ( & slave_active_lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; mutex_unlock ( & register_mutex ) ; } else { timer = timeri -> timer ; if ( snd_BUG_ON ( ! timer ) ) goto out ; spin_lock_irq ( & timer -> lock ) ; while ( timeri -> flags & SNDRV_TIMER_IFLG_CALLBACK ) { spin_unlock_irq ( & timer -> lock ) ; udelay ( 10 ) ; spin_lock_irq ( & timer -> lock ) ; } spin_unlock_irq ( & timer -> lock ) ; mutex_lock ( & register_mutex ) ; list_del ( & timeri -> open_list ) ; if ( timer && list_empty ( & timer -> open_list_head ) && timer -> hw . close ) timer -> hw . close ( timer ) ; list_for_each_entry_safe ( slave , tmp , & timeri -> slave_list_head , open_list ) { spin_lock_irq ( & slave_active_lock ) ; _snd_timer_stop ( slave , 1 , SNDRV_TIMER_EVENT_RESOLUTION ) ; list_move_tail ( & slave -> open_list , & snd_timer_slave_list ) ; slave -> master = NULL ; slave -> timer = NULL ; spin_
",0,511
1098,"int tipc_nl_publ_dump ( struct sk_buff * skb , struct netlink_callback * cb ) { int err ; u32 tsk_portid = cb -> args [ 0 ] ; u32 last_publ = cb -> args [ 1 ] ; u32 done = cb -> args [ 2 ] ; struct net * net = sock_net ( skb -> sk ) ; struct tipc_sock * tsk ; if ( ! tsk_portid ) { struct nlattr * * attrs ; struct nlattr * sock [ TIPC_NLA_SOCK_MAX + 1 ] ; err = tipc_nlmsg_parse ( cb -> nlh , & attrs ) ; if ( err ) return err ; if ( ! attrs [ TIPC_NLA_SOCK ] , tipc_nl_sock_policy ) ; if ( err ) return err ; if ( ! sock [ TIPC_NLA_SOCK_REF ] ) return - EINVAL ; err = nla_parse_nested ( sock , TIPC_NLA_SOCK_MAX , attrs [ TIPC_NLA_SOCK ] , tipc_nl_sock_policy ) ; if ( err ) return err ; if ( ! sock [ TIPC_NLA_SOCK_REF ] ) return - EINVAL ; tsk_portid = nla_get_u32 ( sock [ TIPC_NLA_SOCK_REF ] ) ; } if ( done ) return 0 ; tsk = tipc_sk_lookup ( net , tsk_portid ) ; if ( ! tsk ) return - EINVAL ; lock_sock ( & tsk -> sk ) ; err = __tipc_nl_list_sk_publ ( skb , cb , tsk , & last_publ ) ; if ( ! err ) done = 1 ; release_sock ( & tsk -> sk ) ; sock_put ( & tsk -> sk ) ; cb -> args [ 0 ] = tsk_portid ; cb -> args [ 1 ] = last_publ ; cb -> args [ 2 ] = done ; return skb -> len ; }
",1,499
1099,"static int update_fragments ( vpx_codec_alg_priv_t * ctx , const uint8_t * data , unsigned int data_sz , vpx_codec_err_t * res ) { * res = VPX_CODEC_OK ; if ( ctx -> fragments . count == 0 ) { memset ( ( void * ) ctx -> fragments . ptrs , 0 , sizeof ( ctx -> fragments . ptrs ) ) ; vpx_memset ( ctx -> fragments . sizes , 0 , sizeof ( ctx -> fragments . sizes ) ) ; } if ( ctx -> fragments . enabled && ! ( data == NULL && data_sz == 0 ) ) { ctx -> fragments . ptrs [ ctx -> fragments . count ] = data ; ctx -> fragments . sizes [ ctx -> fragments . count ] = data_sz ; ctx -> fragments . count ++ ; if ( ctx -> fragments . count > ( 1 << EIGHT_PARTITION ) + 1 ) { ctx -> fragments . count = 0 ; * res = VPX_CODEC_INVALID_PARAM ; return - 1 ; } return 0 ; }
",0,259
1100,"static void m_stop ( struct seq_file * m , void * v ) { struct proc_maps_private * priv = m -> private ; struct vm_area_struct * vma = v ; if ( ! IS_ERR ( vma ) ) vma_stop ( priv , vma ) ; if ( priv -> task ) put_task_struct ( priv -> task ) ; }
",1,85
1101,"int usb_get_bos_descriptor ( struct usb_device * dev ) { struct device * ddev = & dev -> dev ; struct usb_bos_descriptor * bos ; struct usb_dev_cap_header * cap ; unsigned char * buffer ; int length , total_len , num , i ; int ret ; bos = kzalloc ( sizeof ( struct usb_bos_descriptor ) , GFP_KERNEL ) ; if ( ! bos ) return - ENOMEM ; ret = usb_get_descriptor ( dev , USB_DT_BOS , 0 , bos , USB_DT_BOS_SIZE ) ; if ( ret < USB_DT_BOS_SIZE ) { dev_err ( ddev , ""unabletogetBOSdescriptor\\n"" ) ; if ( ret >= 0 ) ret = - ENOMSG ; kfree ( bos ) ; return ret ; } length = bos -> bLength ; total_len = le16_to_cpu ( bos -> wTotalLength ) ; num = bos -> bNumDeviceCaps ; kfree ( bos ) ; if ( total_len < length ) return - EINVAL ; dev -> bos = kzalloc ( sizeof ( struct usb_host_bos ) , GFP_KERNEL ) ; if ( ! dev -> bos ) return - ENOMEM ; buffer = kzalloc ( total_len , GFP_KERNEL ) ; if ( ! buffer ) { ret = - ENOMEM ; goto err ; } dev -> bos -> desc = ( struct usb_bos_descriptor * ) buffer ; if ( total_len < sizeof ( * cap ) || total_len < cap -> bLength ; if ( total_len < length ) break ; total_len -= length ; if ( cap -> bDescriptorType != USB_DT_DEVICE_CAPABILITY ) { dev_warn ( ddev , ""descriptortypeinvalid,skip\\n"" ) ; continue ; } switch ( cap -> bDevCapabilityType ) { case USB_CAP_TYPE_WIRELESS_USB : break ; case USB_CAP_TYPE_EXT : dev -> bos -> ext_cap = ( struct usb_ext_cap_descriptor * ) buffer ; break ; case USB_SS_CAP_TYPE : dev -> bos -> ss_cap = (
",0,511
1102,"void fput ( struct file * file ) { if ( atomic_long_dec_and_test ( & file -> f_count ) ) { struct task_struct * task = current ; if ( likely ( ! in_interrupt ( ) && ! ( task -> flags & PF_KTHREAD ) ) ) { init_task_work ( & file -> f_u . fu_rcuhead , ____fput ) ; if ( ! task_work_add ( task , & file -> f_u . fu_rcuhead , true ) ) return ; } if ( llist_add ( & file -> f_u . fu_llist , & delayed_fput_list ) ) schedule_work ( & delayed_fput_work ) ; } }
",1,166
1103,"static int udf_read_inode ( struct inode * inode , bool hidden_inode ) { struct buffer_head * bh = NULL ; struct fileEntry * fe ; struct extendedFileEntry * efe ; uint16_t ident ; struct udf_inode_info * iinfo = UDF_I ( inode ) ; struct udf_sb_info * sbi = UDF_SB ( inode -> i_sb ) ; struct kernel_lb_addr * iloc = & iinfo -> i_location ; unsigned int link_count ; unsigned int indirections = 0 ; int ret = - EIO ; reread : if ( iloc -> logicalBlockNum >= sbi -> s_partmaps [ iloc -> partitionReferenceNum ] . s_partition_len ) { udf_debug ( ""block=%d,partition=%doutofrange\\n"" , iloc -> logicalBlockNum , iloc -> partitionReferenceNum ) ; return - EIO ; } bh = udf_read_ptagged ( inode -> i_sb , iloc , 0 , & ident ) ; if ( ! bh ) { udf_err ( inode -> i_sb , ""(ino%ld)failed
",0,270
1104,"void enc28j60WritePhyReg ( NetInterface * interface , uint16_t address , uint16_t data ) { uint16_t status ; enc28j60WriteReg ( interface , ENC28J60_MIREGADR , address & REG_ADDR_MASK ) ; enc28j60WriteReg ( interface , ENC28J60_MIWRL , LSB ( data ) ) ; enc28j60WriteReg ( interface , ENC28J60_MIWRH , MSB ( data ) ) ; while ( ( enc28j60ReadReg ( interface , ENC28J60_MISTAT ) & ENC28J60_MISTAT_BUSY ) != 0 ) { } }
",0,160
1105,"static int bad_format_imginfo ( char * fmt , char * * ptr ) { if ( * ptr == fmt ) return 1 ; if ( * ptr == '\\0' ) return 1 ; if ( * ptr == '%' ) ptr ++ ; else if ( * ptr == 's' || * ptr == 'S' ) { n = 1 ; ptr ++ ; } else { if ( * ptr == '' ) ptr ++ ; while ( * ptr >= '0' && * ptr <= '9' ) ptr ++ ; if ( * ptr ++ != 'l' ) return 1 ; if ( * ptr == 'u' ) ptr ++ ; else return 1 ; n ++ ; } } return ( n != 3 ) ; }
",0,155
1106,"void inet_sock_destruct ( struct sock * sk ) { struct inet_sock * inet = inet_sk ( sk ) ; __skb_queue_purge ( & sk -> sk_receive_queue ) ; __skb_queue_purge ( & sk -> sk_error_queue ) ; sk_mem_reclaim ( sk ) ; if ( sk -> sk_type == SOCK_STREAM && sk -> sk_state != TCP_CLOSE ) { pr_err ( ""AttempttoreleaseTCPsocketinstate%d%p\\n"" , sk -> sk_state , sk ) ; return ; } if ( ! sock_flag ( sk , SOCK_DEAD ) ) { pr_err ( ""Attempttoreleasealiveinetsocket%p\\n"" , sk ) ; return ; } WARN_ON ( atomic_read ( & sk -> sk_rmem_alloc ) ) ; WARN_ON ( atomic_read ( & sk -> sk_wmem_alloc ) ) ; WARN_ON ( sk -> sk_wmem_queued ) ; WARN_ON ( sk -> sk_forward_alloc ) ; kfree ( rcu_dereference_protected ( inet -> inet_opt , 1 ) ) ; sk_refcnt_debug_dec ( sk ) ; }
",0,291
1107,"static int encrypt ( struct blkcipher_desc * desc , struct scatterlist * dst , struct scatterlist * src , unsigned int nbytes ) { struct blkcipher_walk walk ; struct crypto_blkcipher * tfm = desc -> tfm ; struct salsa20_ctx * ctx = crypto_blkcipher_ctx ( tfm ) ; int err ; blkcipher_walk_init ( & walk , dst , src , nbytes ) ; err = blkcipher_walk_virt_block ( desc , & walk , 64 ) ; salsa20_ivsetup ( ctx , walk . iv ) ; while ( walk . nbytes >= 64 ) { salsa20_encrypt_bytes ( ctx , walk . dst . virt . addr , walk . src . virt . addr , walk . nbytes - ( walk . nbytes % 64 ) ) ; err = blkcipher_walk_done ( desc , & walk , walk . nbytes % 64 ) ; } if ( walk . nbytes ) { salsa20_encrypt_bytes ( ctx , walk . dst . virt . addr , walk . src . virt . addr , walk . nbytes ) ; err = blkcipher_walk_done ( desc , & walk , 0 ) ; } return err ; }
",1,280
1108,"static int resp_get_length ( netdissect_options * ndo , register const u_char * bp , int len , const u_char * * endp ) { int result ; u_char c ; int saw_digit ; int neg ; int too_large ; if ( len == 0 ) goto trunc ; ND_TCHECK ( * bp ) ; too_large = 0 ; neg = 0 ; if ( * bp == '-' ) { neg = 1 ; bp ++ ; len -- ; } result = 0 ; saw_digit = 0 ; for ( ; ; ) { if ( len == 0 ) goto trunc ; ND_TCHECK ( * bp ) ; c = * bp ; if ( ! ( c >= '0' && c <= '9' ) ) { if ( ! saw_digit ) { bp ++ ; break ; } c -= '0' ; if ( result > ( INT_MAX / 10 ) ) { too_large = 1 ; } else { result *= 10 ; if ( result == INT_MAX && c > ( INT_MAX % 10 ) ) { too_large = 1 ; } else result += c ; } bp ++ ; len -- ; saw_digit = 1 ; } if ( ! saw_digit ) goto invalid ; if ( len == 0 ) goto trunc ; ND_TCHECK ( * bp ) ; if ( * bp != '\\r' ) { bp ++ ; } bp ++ ; len -- ; if ( len == 0 ) goto trunc ; ND_TCHECK ( * bp ) ; if ( * bp != '\\n' ) { bp ++ ; } bp ++ ; len -- ; * endp = bp ; if ( neg ) { if ( too_large || result != 1 ) return ( - 4 ) ; result = - 1 ; } return ( too_large ? - 3 : result ) ; trunc : * endp = bp ; return ( - 2 ) ; invalid : * endp = bp ; return ( - 5 ) ; }
",0,438
1109,"int xfs_attr3_leaf_lookup_int ( struct xfs_buf * bp , struct xfs_da_args * args ) { struct xfs_attr_leafblock * leaf ; struct xfs_attr3_icleaf_hdr ichdr ; struct xfs_attr_leaf_entry * entry ; struct xfs_attr_leaf_entry * entries ; struct xfs_attr_leaf_name_local * name_loc ; struct xfs_attr_leaf_name_remote * name_rmt ; xfs_dahash_t hashval ; int probe ; int span ; trace_xfs_attr_leaf_lookup ( args ) ; leaf = bp -> b_addr ; xfs_attr3_leaf_hdr_from_disk ( & ichdr , leaf ) ; entries = xfs_attr3_leaf_entryp ( leaf ) ; ASSERT ( ichdr . count < XFS_LBSIZE ( args -> dp -> i_mount ) / 8 ) ; hashval = args -> hashval ; probe = span = ichdr . count / 2 ; for ( entry = & entries [ probe ] ; span > 4 ; entry = & entries [ probe ] ) { span /= 2 ; if ( be32_to_cpu ( entry -> hashval ) < hashval ) probe += span ; else if ( be32_to_cpu ( entry -> hashval ) > hashval ) probe -= span ; else break ; } ASSERT ( probe >= 0 && ( ! ichdr . count || probe < ichdr . count ) ) ; ASSERT ( span <= 4 || be32_to_cpu ( entry -> hashval ) == hashval ) ; while ( probe > 0 && be32_to_cpu ( entry -> hashval ) >= hashval ) { entry -- ; probe -- ; } while ( probe < ichdr . count && be32_to_cpu ( entry -> hashval ) < hashval ) { entry ++ ; probe ++ ; } if ( probe == ichdr . count || be32_to_cpu ( entry -> hashval ) != hashval ) { args -> index = probe ; return XFS_ERROR ( ENOATTR ) ; } for ( ; probe < ichdr . count && ( be32_to_cpu ( entry -> hashval ) == hashval
",0,511
1110,"void DefragRegisterTests ( void ) { # ifdef UNITTESTS UtRegisterTest ( ""DefragInOrderSimpleTest"" , DefragInOrderSimpleTest ) ; UtRegisterTest ( ""DefragReverseSimpleTest"" , DefragReverseSimpleTest ) ; UtRegisterTest ( ""DefragSturgesNovakBsdTest"" , DefragSturgesNovakBsdTest ) ; UtRegisterTest ( ""DefragSturgesNovakLinuxTest"" , DefragSturgesNovakLinuxTest ) ; UtRegisterTest ( ""DefragSturgesNovakWindowsTest"" , DefragSturgesNovakWindowsTest ) ; UtRegisterTest ( ""DefragSturgesNovakSolarisTest"" , DefragSturgesNovakSolarisTest ) ; UtRegisterTest ( ""DefragSturgesNovakFirstTest"" , DefragSturgesNovakFirstTest ) ; UtRegisterTest ( ""DefragSturgesNovakLastTest"" , DefragSturgesNovakLastTest ) ; UtRegisterTest ( ""DefragIPv4NoDataTest"" , DefragIPv4NoDataTest ) ; UtRegisterTest ( ""DefragIPv4TooLargeTest"" , DefragIPv4TooLargeTest ) ; UtRegisterTest ( ""IPV6DefragInOrderSimpleTest"" , IPV6DefragInOrderSimpleTest ) ; UtRegisterTest ( ""IPV6DefragReverseSimpleTest"" , IPV6DefragReverseSimpleTest ) ; UtRegisterTest ( ""IPV6DefragSturgesNovakBsdTest"" , IPV6DefragSturgesNovakBsdTest ) ; UtRegisterTest ( ""IPV6DefragSturgesNovakLinuxTest"" , IPV6DefragSturgesNovakLinuxTest ) ; UtRegisterTest ( ""IPV6DefragSturgesNovakWindowsTest"" , IPV6DefragSturgesNovakWindowsTest ) ; UtRegisterTest ( ""IPV6DefragSturgesNovakSolarisTest"" , IPV6DefragSturgesNovakSolarisTest ) ; UtRegisterTest ( ""IPV6DefragSturgesNovakFirstTest"" , IPV6DefragSturgesNovakFirstTest ) ; UtRegisterTest ( ""IPV6
",0,511
1111,"static int coolkey_add_object ( coolkey_private_data_t * priv , unsigned long object_id , const u8 * object_data , size_t object_length , int add_v1_record ) { sc_cardctl_coolkey_object_t new_object ; int r ; memset ( & new_object , 0 , sizeof ( new_object ) ) ; new_object . path = coolkey_template_path ; new_object . path . len = 4 ; ulong2bebytes ( new_object . path . value , object_id ) ; new_object . id = object_id ; new_object . length = object_length ; if ( object_data ) { new_object . data = malloc ( object_length + add_v1_record ) ; if ( new_object . data == NULL ) { return SC_ERROR_OUT_OF_MEMORY ; } if ( add_v1_record ) { new_object . data [ 0 ] = COOLKEY_V1_OBJECT ; new_object . length ++ ; } memcpy ( & new_object . data [ add_v1_record ] , object_data , object_length ) ; } r = coolkey_add_object_to_list ( & priv -> objects_list , & new_object ) ; if ( r != SC_SUCCESS ) { free ( new_object . data ) ; new_object . data = NULL ; } return r ; }
",0,327
1112,"static Sdb * store_versioninfo_gnu_verdef ( ELFOBJ * bin , Elf_ ( Shdr ) * shdr , int sz ) { const char * section_name = """" ; const char * link_section_name = """" ; char * end = NULL ; Elf_ ( Shdr ) * link_shdr = NULL ; ut8 dfs [ sizeof ( Elf_ ( Verdef ) ) ] = { 0 } ; Sdb * sdb ; int cnt , i ; if ( shdr -> sh_link > bin -> ehdr . e_shnum ) { return false ; } link_shdr = & bin -> shdr [ shdr -> sh_link ] ; if ( ( int ) shdr -> sh_size < 1 ) { return false ; } Elf_ ( Verdef ) * defs = calloc ( shdr -> sh_size , sizeof ( char ) ) ; if ( ! defs ) { return false ; } if ( bin -> shstrtab && shdr -> sh_name < bin -> shstrtab_size ) { section_name = & bin -> shstrtab [ shdr -> sh_name ] ; } if ( link_shdr && bin -> shstrtab && link_shdr -> sh_name < bin -> shstrtab_size ) { link_section_name = & bin -> shstrtab [ link_shdr -> sh_name ] ; } if ( ! defs ) { bprintf ( ""Warning:Cannotallocatememory(CheckElf_(Verdef))\\n"" ) ; return NULL ; } sdb = sdb_new0 ( ) ; end = ( char * ) defs + shdr -> sh_size ; sdb_set ( sdb , ""section_name"" , section_name , 0 ) ; sdb_num_set ( sdb , ""entries"" , shdr -> sh_info , 0 ) ; sdb_num_set ( sdb , ""addr"" , shdr -> sh_addr , 0 ) ; sdb_num_set ( sdb , ""offset"" , shdr -> sh_offset , 0 ) ; sdb_num_set ( sdb , ""link"" , shdr -> sh_link , 0 ) ; sdb_set ( sdb , ""link_section_name"" , link_section_name , 0 )
",0,511
1113,"error_t webSocketParseAuthenticateField ( WebSocket * webSocket , char_t * value ) { # if ( WEB_SOCKET_BASIC_AUTH_SUPPORT == ENABLED || WEB_SOCKET_DIGEST_AUTH_SUPPORT == ENABLED ) size_t n ; char_t * p ; char_t * token ; char_t * separator ; char_t * name ; WebSocketAuthContext * authContext ; authContext = & webSocket -> authContext ; token = osStrtok_r ( value , ""\\t"" , & p ) ; if ( token == NULL ) return ERROR_INVALID_SYNTAX ; if ( ! osStrcasecmp ( token , ""Basic"" ) ) { authContext -> requiredAuthMode = WS_AUTH_MODE_BASIC ; } else if ( ! osStrcasecmp ( token , ""Digest"" ) ) { authContext -> requiredAuthMode = WS_AUTH_MODE_DIGEST ; } else { return ERROR_INVALID_SYNTAX ; } token = osStrtok_r ( NULL , "","" , & p ) ; while ( token != NULL ) { separator = osStrchr ( token , '=' ) ; if ( separator != NULL ) { * separator = '\\0' ; name = strTrimWhitespace ( token ) ; value = strTrimWhitespace ( separator + 1 ) ; n = osStrlen ( value ) ; if ( n > 0 && value [ n - 1 ] == \'\\""\' ) value [ n - 1 ] = '\\0' ; if ( value [ 0 ] == \'\\""\' ) value ++ ; if ( ! osStrcasecmp ( name , ""realm"" ) ) { strSafeCopy ( authContext -> realm , value , WEB_SOCKET_REALM_MAX_LEN ) ; } # if ( WEB_SOCKET_DIGEST_AUTH_SUPPORT == ENABLED ) else if ( ! osStrcasecmp ( name , ""nonce"" ) ) { strSafeCopy ( authContext -> nonce , value , WEB_SOCKET_NONCE_MAX_LEN + 1 ) ; } else if ( !
",0,511
1114,"static int name_parse ( u8 * packet , int length , int * idx , char * name_out , int name_out_len ) { int name_end = - 1 ; int j = * idx ; int ptr_count = 0 ; # define GET32 ( x ) do { if ( j + 4 > length ) goto err ; memcpy ( & t32_ , packet + j , 4 ) ; j += 4 ; x = ntohl ( t32_ ) ; } while ( 0 ) # define GET16 ( x ) do { if ( j + 2 > length ) goto err ; memcpy ( & t_ , packet + j , 2 ) ; j += 2 ; x = ntohs ( t_ ) ; } while ( 0 ) # define GET8 ( x ) do { if ( j >= length ) goto err ; x = packet [ j ++ ] ; } while ( 0 ) char * cp = name_out ; const char * const end = name_out + name_out_len ; for ( ; ; ) { u8 label_len ; GET8 ( label_len ) ; if ( ! label_len ) break ; if ( label_len & 0xc0 ) { u8 ptr_low ; GET8 ( ptr_low ) ; if ( name_end < 0 ) name_end = j ; j = ( ( ( int ) label_len & 0x3f ) << 8 ) + ptr_low ; if ( j < 0 || j >= length ) return - 1 ; if ( ++ ptr_count > length ) return - 1 ; continue ; } if ( label_len > 63 ) return - 1 ; if ( cp != name_out ) { if ( cp + 1 >= end ) return - 1 ; * cp ++ = '.' ; } if ( cp + label_len >= end ) return - 1 ; memcpy ( cp , packet + j , label_len ) ; cp += label_len ; j += label_len ; } if ( cp >= end ) return - 1 ; * cp = '\\0' ; if ( name_end < 0 ) * idx = j ; else * idx = name_end ; return 0 ; err : return - 1 ; }
",0,478
1115,"static int fpAcc ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) { tmsize_t stride = PredictorState ( tif ) -> stride ; uint32 bps = tif -> tif_dir . td_bitspersample / 8 ; tmsize_t wc = cc / bps ; tmsize_t count = cc ; uint8 * cp = ( uint8 * ) cp0 ; uint8 * tmp = ( uint8 * ) _TIFFmalloc ( cc ) ; if ( ( cc % ( bps * stride ) ) != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , ""fpAcc"" , ""%s"" , ""(cc%(bps*stride))
",0,167
1116,"static int handle_pte_fault ( struct mm_struct * mm , struct vm_area_struct * vma , unsigned long address , pte_t * pte , pmd_t * pmd , unsigned int flags ) { pte_t entry ; spinlock_t * ptl ; entry = * pte ; barrier ( ) ; if ( ! pte_present ( entry ) ) { if ( pte_none ( entry ) ) { if ( vma -> vm_ops ) return do_fault ( mm , vma , address , pte , pmd , flags , entry ) ; } return do_anonymous_page ( mm , vma , address , pte , pmd , flags ) ; } return do_swap_page ( mm , vma , address , pte , pmd , flags , entry ) ; } if ( pte_protnone ( entry ) ) return do_numa_page ( mm , vma , address , entry , pte , pmd ) ; ptl = pte_lockptr ( mm , pmd ) ; spin_lock ( ptl ) ; if ( unlikely ( ! pte_same ( * pte , entry ) ) ) goto unlock ; if ( flags & FAULT_FLAG_WRITE ) { if ( ! pte_write ( entry ) ) return do_wp_page ( mm , vma , address , pte , pmd , ptl , entry ) ; entry = pte_mkdirty ( entry ) ; } entry = pte_mkyoung ( entry ) ; if ( ptep_set_access_flags ( vma , address , pte , entry , flags & FAULT_FLAG_WRITE ) ) { update_mmu_cache ( vma , address , pte ) ; } else { if ( flags & FAULT_FLAG_WRITE ) flush_tlb_fix_spurious_fault ( vma , address ) ; } unlock : pte_unmap_unlock ( pte , ptl ) ; return 0 ; }
",1,446
1117,"static char * pool_strdup ( const char * s ) { size_t len = strlen ( s ) + 1 ; char * r = pool_alloc ( len ) ; memcpy ( r , s , len ) ; return r ; }
",1,55
1118,"void user_describe ( const struct key * key , struct seq_file * m ) { seq_puts ( m , key -> description ) ; if ( key_is_positive ( key ) ) seq_printf ( m , "":%u"" , key -> datalen ) ; }
",1,64
1119,"static ssize_t map_write ( struct file * file , const char __user * buf , size_t count , loff_t * ppos , int cap_setid , struct uid_gid_map * map , struct uid_gid_map * parent_map ) { struct seq_file * seq = file -> private_data ; struct user_namespace * ns = seq -> private ; struct uid_gid_map new_map ; unsigned idx ; struct uid_gid_extent * extent = NULL ; unsigned long page = 0 ; char * kbuf , * pos , * next_line ; ssize_t ret = - EINVAL ; mutex_lock ( & id_map_mutex ) ; ret = - EPERM ; if ( map -> nr_extents != 0 ) goto out ; if ( cap_valid ( cap_setid ) && ! ns_capable ( ns , cap_setid ) ) goto out ; ret = - ENOMEM ; page = __get_free_page ( GFP_TEMPORARY ) ; kbuf = ( char * ) page ; if ( ! page ) goto out ; ret = - EINVAL ; if ( ( * ppos != 0 ) || ( count >= PAGE_SIZE ) ) goto out ; ret = - EFAULT ; if ( copy_from_user ( kbuf , buf , count ) ) goto out ; kbuf [ count ] = '\\0' ; ret = - EINVAL ; pos = kbuf ; new_map . nr_extents = 0 ; for ( ; pos ; pos = next_line ) { extent = & new_map . extent [ new_map . nr_extents ] ; next_line = strchr ( pos , '\\n' ) ; if ( next_line ) { * next_line = '\\0' ; next_line ++ ; if ( * next_line == '\\0' ) next_line = NULL ; } pos = skip_spaces ( pos ) ; extent -> first = simple_strtoul ( pos , & pos , 10 ) ; if ( ! isspace ( * pos ) ) goto out ; pos = skip_spaces ( pos ) ; extent -> lower_first = simple_strtoul ( pos , & pos , 10 ) ; if ( ! isspace
",0,511
1120,"static const ut8 * r_bin_dwarf_parse_comp_unit ( Sdb * s , const ut8 * obuf , RBinDwarfCompUnit * cu , const RBinDwarfDebugAbbrev * da , size_t offset , const ut8 * debug_str , size_t debug_str_len ) { const ut8 * buf = obuf , * buf_end = obuf + ( cu -> hdr . length - 7 ) ; ut64 abbr_code ; size_t i ; if ( cu -> hdr . length > debug_str_len ) { return NULL ; } while ( buf && buf < buf_end && buf >= obuf ) { if ( cu -> length && cu -> capacity == cu -> length ) { r_bin_dwarf_expand_cu ( cu ) ; } buf = r_uleb128 ( buf , buf_end - buf , & abbr_code ) ; if ( abbr_code > da -> length || ! buf ) { return NULL ; } r_bin_dwarf_init_die ( & cu -> dies [ cu -> length ] ) ; if ( ! abbr_code ) { cu -> dies [ cu -> length ] . abbrev_code = 0 ; cu -> length ++ ; buf ++ ; continue ; } cu -> dies [ cu -> length ] . abbrev_code = abbr_code ; cu -> dies [ cu -> length ] . tag = da -> decls [ abbr_code - 1 ] . tag ; abbr_code += offset ; if ( da -> capacity < abbr_code ) { return NULL ; } for ( i = 0 ; i < da -> decls [ abbr_code - 1 ] . length ; i ++ ) { if ( cu -> dies [ cu -> length ] . length == cu -> dies [ cu -> length ] . capacity ) { r_bin_dwarf_expand_die ( & cu -> dies [ cu -> length ] ) ; } if ( i >= cu -> dies [ cu -> length ] . capacity || i >= da -> decls [ abbr_code - 1 ] . capacity ) { eprintf ( ""Warning:malformeddwarfattributecapacitydoesn\'tmatchlength\\n"" ) ; break ; } memset ( & cu -> dies [ cu -> length ] . attr_values
",0,511
1121,"static block_t * Encode ( encoder_t * p_enc , picture_t * p_pic ) { encoder_sys_t * p_sys = p_enc -> p_sys ; block_t * p_block , * p_output_chain = NULL ; SchroFrame * p_frame ; bool b_go = true ; if ( ! p_pic ) { if ( ! p_sys -> started || p_sys -> b_eos_pulled ) return NULL ; if ( ! p_sys -> b_eos_signalled ) { p_sys -> b_eos_signalled = 1 ; schro_encoder_end_of_stream ( p_sys -> p_schro ) ; } } else { p_sys -> p_format -> interlaced = ! p_pic -> b_progressive ; p_sys -> p_format -> top_field_first = p_pic -> b_top_field_first ; if ( p_sys -> b_auto_field_coding ) schro_encoder_setting_set_double ( p_sys -> p_schro , ""interlaced_coding"" , ! p_pic -> b_progressive ) ; } if ( ! p_sys -> started ) { date_t date ; if ( p_pic -> format . i_chroma != p_enc -> fmt_in . i_codec ) { char chroma_in [ 5 ] , chroma_out [ 5 ] ; vlc_fourcc_to_char ( p_pic -> format . i_chroma , chroma_in ) ; chroma_in [ 4 ] = '\\0' ; chroma_out [ 4 ] = '\\0' ; vlc_fourcc_to_char ( p_enc -> fmt_in . i_codec , chroma_out ) ; msg_Warn ( p_enc , ""Resettingchromafrom%sto%s"" , chroma_out , chroma_in ) ; if ( ! SetEncChromaFormat ( p_enc , p_pic -> format . i_chroma ) ) { msg_Err ( p_enc , ""Couldnotresetchromaformatto%s"" , chroma_in ) ; return NULL ; } } date_Init ( & date , p_
",0,511
1122,"static mf_t * open_mf_pattern ( void * talloc_ctx , struct demuxer * d , char * filename ) { struct mp_log * log = d -> log ; int error_count = 0 ; int count = 0 ; mf_t * mf = talloc_zero ( talloc_ctx , mf_t ) ; mf -> log = log ; if ( filename [ 0 ] == '@' ) { struct stream * s = stream_create ( filename + 1 , d -> stream_origin | STREAM_READ , d -> cancel , d -> global ) ; if ( s ) { while ( 1 ) { char buf [ 512 ] ; int len = stream_read_peek ( s , buf , sizeof ( buf ) ) ; if ( ! len ) break ; bstr data = ( bstr ) { buf , len } ; int pos = bstrchr ( data , '\\n' ) ; data = bstr_splice ( data , 0 , pos < 0 ? data . len : pos + 1 ) ; bstr fname = bstr_strip ( data ) ; if ( fname . len ) { if ( bstrchr ( fname , '\\0' ) >= 0 ) { mp_err ( log , ""invalidfilename\\n"" ) ; break ; } char * entry = bstrto0 ( mf , fname ) ; if ( ! mp_path_exists ( entry ) ) { mp_verbose ( log , ""filenotfound:\'%s\'\\n"" , entry ) ; } else { MP_TARRAY_APPEND ( mf , mf -> names , mf -> nr_of_files , entry ) ; } } stream_seek_skip ( s , stream_tell ( s ) + data . len ) ; } free_stream ( s ) ; mp_info ( log , ""numberoffiles:%d\\n"" , mf -> nr_of_files ) ; goto exit_mf ; } mp_info ( log , ""%sisnotindirectfilelist\\n"" , filename + 1 ) ; } if ( strchr ( filename , ',' ) ) { mp_info ( log , ""filelist:%s\\n"" , filename ) ; bstr bfilename = bstr0 ( filename ) ; while ( bfilename
",0,511
1123,"void ip6_print ( netdissect_options * ndo , const u_char * bp , u_int length ) { register const struct ip6_hdr * ip6 ; register int advance ; u_int len ; const u_char * ipend ; register const u_char * cp ; register u_int payload_len ; int nh ; int fragmented = 0 ; u_int flow ; ip6 = ( const struct ip6_hdr * ) bp ; ND_TCHECK ( * ip6 ) ; if ( length < sizeof ( struct ip6_hdr ) ) { ND_PRINT ( ( ndo , ""truncated-ip6%u"" , length ) ) ; return ; } if ( ! ndo -> ndo_eflag ) ND_PRINT ( ( ndo , ""IP6"" ) ) ; if ( IP6_VERSION ( ip6 ) != 6 ) { ND_PRINT ( ( ndo , ""versionerror:%u
",0,214
1124,"MAPI_Attr * * mapi_attr_read ( size_t len , unsigned char * buf ) { size_t idx = 0 ; uint32 i , j ; assert ( len > 4 ) ; uint32 num_properties = GETINT32 ( buf + idx ) ; MAPI_Attr * * attrs = CHECKED_XMALLOC ( MAPI_Attr * , ( num_properties + 1 ) ) ; idx += 4 ; if ( ! attrs ) return NULL ; for ( i = 0 ; i < num_properties ; i ++ ) { MAPI_Attr * a = attrs [ i ] = CHECKED_XCALLOC ( MAPI_Attr , 1 ) ; MAPI_Value * v = NULL ; CHECKINT16 ( idx , len ) ; a -> type = GETINT16 ( buf + idx ) ; idx += 2 ; CHECKINT16 ( idx , len ) ; a -> name = GETINT16 ( buf + idx ) ; idx += 2 ; if ( a -> name & GUID_EXISTS_FLAG ) { a -> guid = CHECKED_XMALLOC ( GUID , 1 ) ; copy_guid_from_buf ( a -> guid , buf + idx , len ) ; idx += sizeof ( GUID ) ; CHECKINT32 ( idx , len ) ; a -> num_names = GETINT32 ( buf + idx ) ; idx += 4 ; if ( a -> num_names > 0 ) { size_t i ; a -> names = CHECKED_XCALLOC ( VarLenData , a -> num_names ) ; for ( i = 0 ; i < a -> num_names ; i ++ ) { size_t j ; CHECKINT32 ( idx , len ) ; a -> names [ i ] . len = GETINT32 ( buf + idx ) ; idx += 4 ; a -> names [ i ] . data = CHECKED_XMALLOC ( unsigned char , a -> names [ i ] . len ) ; for ( j = 0 ; j < ( a -> names [ i ] . len >> 1 ) ; j ++ ) a -> names [ i ] . data [ j ] = ( buf + idx ) [ j * 2 ] ; idx += pad_to_4 ( idx
",0,511
1125,"static int udf_read_inode ( struct inode * inode , bool hidden_inode ) { struct buffer_head * bh = NULL ; struct fileEntry * fe ; struct extendedFileEntry * efe ; uint16_t ident ; struct udf_inode_info * iinfo = UDF_I ( inode ) ; struct udf_sb_info * sbi = UDF_SB ( inode -> i_sb ) ; struct kernel_lb_addr * iloc = & iinfo -> i_location ; unsigned int link_count ; unsigned int indirections = 0 ; int ret = - EIO ; reread : if ( iloc -> logicalBlockNum >= sbi -> s_partmaps [ iloc -> partitionReferenceNum ] . s_partition_len ) { udf_debug ( ""block=%d,partition=%doutofrange\\n"" , iloc -> logicalBlockNum , iloc -> partitionReferenceNum ) ; return - EIO ; } bh = udf_read_ptagged ( inode -> i_sb , iloc , 0 , & ident ) ; if ( ! bh ) { udf_err ( inode -> i_sb , ""(ino%ld)failed
",0,270
1126,"static int userfaultfd_unregister ( struct userfaultfd_ctx * ctx , unsigned long arg ) { struct mm_struct * mm = ctx -> mm ; struct vm_area_struct * vma , * prev , * cur ; int ret ; struct uffdio_range uffdio_unregister ; unsigned long new_flags ; bool found ; unsigned long start , end , vma_end ; const void __user * buf = ( void __user * ) arg ; ret = - EFAULT ; if ( copy_from_user ( & uffdio_unregister , buf , sizeof ( uffdio_unregister ) ) ) goto out ; ret = validate_range ( mm , uffdio_unregister . start , uffdio_unregister . len ) ; if ( ret ) goto out ; start = uffdio_unregister . start ; end = start + uffdio_unregister . len ; ret = - ENOMEM ; if ( ! mmget_not_zero ( mm ) ) goto out ; down_write ( & mm -> mmap_sem ) ; if ( ! mmget_still_valid ( mm ) ) goto out_unlock ; vma = find_vma_prev ( mm , start , & prev ) ; if ( ! vma ) goto out_unlock ; ret = - EINVAL ; if ( vma -> vm_start >= end ) goto out_unlock ; if ( is_vm_hugetlb_page ( vma ) ) { unsigned long vma_hpagesize = vma_kernel_pagesize ( vma ) ; if ( start & ( vma_hpagesize - 1 ) ) goto out_unlock ; } found = false ; ret = - EINVAL ; for ( cur = vma ; cur && cur -> vm_start < end ; cur = cur -> vm_next ) { cond_resched ( ) ; BUG_ON ( ! ! cur -> vm_userfaultfd_ctx . ctx ^ ! ! ( cur -> vm_flags & ( VM_UFFD_MISSING | VM_UFFD_WP ) ) ) ; WARN_ON ( ! ( vma -> vm_flags & VM_MAYWRITE ) ) ; if ( ! vma_can_userfault ( cur ) )
",0,511
1127,"static unsigned int tt_activity_measure ( VP8_COMP * cpi , MACROBLOCK * x ) { unsigned int act ; unsigned int sse ; act = vpx_variance16x16 ( x -> src . y_buffer , x -> src . y_stride , VP8_VAR_OFFS , 0 , & sse ) ; act = act << 4 ; if ( act < 8 << 12 ) act = act < 5 << 12 ? act : 5 << 12 ; return act ; }
",0,114
1128,"static void t1_check_unusual_charstring ( void ) { char * p = strstr ( t1_line_array , charstringname ) + strlen ( charstringname ) ; int i ; if ( sscanf ( p , ""%i"" , & i ) != 1 ) { strcpy ( t1_buf_array , t1_line_array ) ; * ( strend ( t1_buf_array ) - 1 ) = '' ; t1_getline ( ) ; alloc_array ( t1_buf ) ; strcat ( t1_buf_array , t1_line_array ) ; alloc_array ( t1_line_array , t1_buf_array ) ; t1_line_ptr = eol ( t1_line_array ) ; } }
",0,178
1129,"static vpx_codec_err_t ctrl_get_reference ( vpx_codec_alg_priv_t * ctx , va_list args ) { vp9_ref_frame_t * data = va_arg ( args , vp9_ref_frame_t * ) ; if ( ctx -> frame_workers ) { VPxWorker * const worker = ctx -> frame_workers ; FrameWorkerData * const frame_worker_data = ( FrameWorkerData * ) worker -> data1 ; YV12_BUFFER_CONFIG * fb ; vp9_get_reference_dec ( ctx -> pbi , data -> idx , & fb ) ; yuvconfig2image ( & data -> img , fb , NULL ) ; return VPX_CODEC_OK ; } else { return VPX_CODEC_INVALID_PARAM ; } }
",0,204
1130,"static int em_syscall ( struct x86_emulate_ctxt * ctxt ) { struct x86_emulate_ops * ops = ctxt -> ops ; struct desc_struct cs , ss ; u64 msr_data ; u16 cs_sel , ss_sel ; u64 efer = 0 ; if ( ctxt -> mode == X86EMUL_MODE_REAL || ctxt -> mode == X86EMUL_MODE_VM86 ) return emulate_ud ( ctxt ) ; if ( ! ( em_syscall_is_enabled ( ctxt ) ) ) return emulate_ud ( ctxt ) ; ops -> get_msr ( ctxt , MSR_EFER , & efer ) ; setup_syscalls_segments ( ctxt , & cs , & ss ) ; ops -> get_msr ( ctxt , MSR_STAR , & msr_data ) ; msr_data >>= 32 ; cs_sel = ( u16 ) ( msr_data & 0xfffc ) ; ss_sel = ( u16 ) ( msr_data + 8 ) ; if ( efer & EFER_LMA ) { cs . d = 0 ; cs . l = 1 ; } ops -> set_segment ( ctxt , cs_sel , & cs , 0 , VCPU_SREG_CS ) ; ops -> set_segment ( ctxt , ss_sel , & ss , 0 , VCPU_SREG_SS ) ; ctxt -> regs [ VCPU_REGS_RCX ] = ctxt -> _eip ; if ( efer & EFER_LMA ) { # ifdef CONFIG_X86_64 ctxt -> regs [ VCPU_REGS_R11 ] = ctxt -> eflags & ~ EFLG_RF ; ops -> get_msr ( ctxt , ctxt -> mode == X86EMUL_MODE_PROT64 ? MSR_LSTAR : MSR_CSTAR , & msr_data ) ; ctxt -> _eip = msr_data ; ops -> get_msr ( ctxt , MSR_SYSCALL_MASK , & msr_data ) ; ctxt -> eflags &= ~ ( msr_data | EFLG_RF ) ; # endif } else { ops -> get
",0,511
1131,"static int cbs_jpeg_split_fragment ( CodedBitstreamContext * ctx , CodedBitstreamFragment * frag , int header ) { AVBufferRef * data_ref ; uint8_t * data ; size_t data_size ; int unit , start , end , marker , next_start , next_marker ; int err , i , j , length ; if ( frag -> data_size < 4 ) { return AVERROR_INVALIDDATA ; } for ( i = 0 ; i + 1 < frag -> data_size && frag -> data [ i ] != 0xff ; i ++ ) ; if ( i > 0 ) { av_log ( ctx -> log_ctx , AV_LOG_WARNING , ""Discarding%dbytesat"" ""beginningofimage.\\n"" , i ) ; } for ( ++ i ; i + 1 < frag -> data_size && frag -> data [ i ] == 0xff ; i ++ ) ; if ( i + 1 >= frag -> data_size && frag -> data [ i ] ) { av_log ( ctx -> log_ctx , AV_LOG_ERROR , ""InvalidJPEGimage:"" ""noSOImarkerfound.\\n"" ) ; return AVERROR_INVALIDDATA ; } marker = frag -> data [ i ] ; if ( marker != JPEG_MARKER_SOI ) { av_log ( ctx -> log_ctx , AV_LOG_ERROR , ""InvalidJPEGimage:first"" ""markeris%02x,shouldbeSOI.\\n"" , marker ) ; return AVERROR_INVALIDDATA ; } for ( ++ i ; i + 1 < frag -> data_size && frag -> data [ i ] == 0xff ; i ++ ) ; if ( i + 1 >= frag -> data_size ) { av_log ( ctx -> log_ctx , AV_LOG_ERROR , ""InvalidJPEGimage:"" ""noimagecontentfound.\\n"" ) ; return AVERROR_INVALIDDATA ; } marker = frag -> data [ i ] ; start = i + 1 ; for ( unit = 0 ; unit ++ ) { if ( marker == JPEG_MARKER_EOI ) { break ; } else if ( marker == JPEG_MARKER_SOS ) { for ( i = start ; i +
",0,511
1132,"static stmt_ty ast_for_expr_stmt ( struct compiling * c , const node * n ) { REQ ( n , expr_stmt ) ; if ( NCH ( n ) == 1 ) { expr_ty e = ast_for_testlist ( c , CHILD ( n , 0 ) ) ; if ( ! e ) return NULL ; return Expr ( e , LINENO ( n ) , n -> n_col_offset , n -> n_end_lineno , n -> n_end_col_offset , c -> c_arena ) ; } else if ( TYPE ( CHILD ( n , 1 ) ) == augassign ) { expr_ty expr1 , expr2 ; operator_ty newoperator ; node * ch = CHILD ( n , 0 ) ; expr1 = ast_for_testlist ( c , ch ) ; if ( ! expr1 ) return NULL ; if ( ! set_context ( c , expr1 , Store , ch ) ) return NULL ; switch ( expr1 -> kind ) { case Name_kind : case Attribute_kind : case Subscript_kind : break ; default : ast_error ( c , ch , ""illegalexpressionforaugmentedassignment"" ) ; return NULL ; } ch = CHILD ( n , 2 ) ; if ( TYPE ( ch ) == testlist ) expr2 = ast_for_testlist ( c , ch ) ; else expr2 = ast_for_expr ( c , ch ) ; if ( ! expr2 ) return NULL ; newoperator = ast_for_augassign ( c , CHILD ( n , 1 ) ) ; if ( ! newoperator ) return NULL ; return AugAssign ( expr1 , newoperator , expr2 , LINENO ( n ) , n -> n_col_offset , n -> n_end_lineno , n -> n_end_col_offset , c -> c_arena ) ; } else if ( TYPE ( CHILD ( n , 1 ) ) == annassign ) { expr_ty expr1 , expr2 , expr3 ; node * ch = CHILD ( n , 0 ) ; node * deep , * ann = CHILD ( n , 1 ) ; int simple = 1 ; deep = ch ; while ( NCH ( deep ) == 1 ) { deep = CHILD ( deep , 0 ) ; } expr
",0,511
1133,"int vp8_denoiser_filter_c ( unsigned char * mc_running_avg_y , unsigned char * mc_avg_y_stride , unsigned char * signal , unsigned int motion_magnitude , int y_offset , int uv_offset ) { unsigned char * sig = signal -> thismb ; int sig_stride = 16 ; unsigned char * mc_running_avg_y = mc_running_avg -> y_buffer + y_offset ; int mc_avg_y_stride = mc_running_avg -> y_stride ; unsigned char * running_avg_y = running_avg -> y_buffer + y_offset ; int avg_y_stride = running_avg -> y_stride ; int r , c , i ; int sum_diff = 0 ; int * adj_val [ 3 ] = { 3 , 4 , 6 } ; if ( motion_magnitude <= MOTION_MAGNITUDE_THRESHOLD ) { for ( i = 0 ; i < 3 ; i ++ ) adj_val [ i ] += 1 ; } for ( r = 0 ; r < 16 ; ++ r ) { for ( c = 0 ; c < 16 ; ++ c ) { int diff = 0 ; int adjustment = 0 ; int absdiff = 0 ; diff = mc_running_avg_y [ c ] - sig [ c ] ; absdiff = abs ( diff ) ; if ( absdiff <= 3 ) { running_avg_y [ c ] = mc_running_avg_y [ c ] ; sum_diff += diff ; } else { if ( absdiff >= 4 && absdiff <= 7 ) adjustment = adj_val [ 0 ] ; else if ( absdiff >= 8 && absdiff <= 15 ) adjustment = adj_val [ 1 ] ; else adjustment = adj_val [ 2 ] ; if ( diff > 0 ) { if ( ( sig [ c ] + adjustment ) > 255 ) running_avg_y [ c ] = 255 ; else running_avg_y [ c ] = sig [ c ] + adjustment ; sum_diff += adjustment ; } else { if ( ( sig [ c ] - adjustment ) < 0 ) running_avg_y [ c ] = 255 ; else running_avg_y [ c ] = sig [ c
",0,511
1134,"static SockState SockParse ( Sock * sockPtr ) { const Tcl_DString * bufPtr ; const Driver * drvPtr ; Request * reqPtr ; char save ; SockState result ; NS_NONNULL_ASSERT ( sockPtr != NULL ) ; drvPtr = sockPtr -> drvPtr ; NsUpdateProgress ( ( Ns_Sock * ) sockPtr ) ; reqPtr = sockPtr -> reqPtr ; bufPtr = & reqPtr -> buffer ; while ( reqPtr -> coff == 0u ) { char * s , * e ; size_t cnt ; s = bufPtr -> string + reqPtr -> roff ; e = memchr ( s , INTCHAR ( '\\n' ) , reqPtr -> avail ) ; if ( unlikely ( e == NULL ) ) { return SOCK_MORE ; } if ( unlikely ( ( e - s ) > drvPtr -> maxline ) ) { sockPtr -> keep = NS_FALSE ; if ( reqPtr -> request . line == NULL ) { Ns_Log ( DriverDebug , ""SockParse:maxlinereachedof%dbytes"" , drvPtr -> maxline ) ; sockPtr -> flags = NS_CONN_REQUESTURITOOLONG ; Ns_Log ( Warning , ""requestlineistoolong(%dbytes)"" , ( int ) ( e - s ) ) ; } else { sockPtr -> flags = NS_CONN_LINETOOLONG ; Ns_Log ( Warning , ""requestheaderlineistoolong(%dbytes)"" , ( int ) ( e - s ) ) ; } } cnt = ( size_t ) ( e - s ) + 1u ; reqPtr -> roff += cnt ; reqPtr -> avail -= cnt ; if ( likely ( e > s ) && likely ( * ( e - 1 ) == '\\r' ) ) { -- e ; } if ( unlikely ( e == s ) && ( reqPtr -> coff == 0u ) ) { reqPtr -> coff = EndOfHeader ( sockPtr ) ; if ( ( sockPtr -> flags & NS_CONN_CONTINUE ) != 0u ) { Ns_Log ( Ns_LogRequestDebug , ""honoring100-continue"" ) ; if ( ( sockPtr -> flags & NS_CONN_ENTITYTOOLAR
",0,511
1135,"int ptrace_setxregs ( struct task_struct * child , void __user * uregs ) { struct thread_info * ti = task_thread_info ( child ) ; struct pt_regs * regs = task_pt_regs ( child ) ; elf_xtregs_t * xtregs = uregs ; int ret = 0 ; # if XTENSA_HAVE_COPROCESSORS coprocessor_flush_all ( ti ) ; coprocessor_release_all ( ti ) ; ret |= __copy_from_user ( & ti -> xtregs_cp , & xtregs -> cp0 , sizeof ( xtregs_coprocessor_t ) ) ; # endif ret |= __copy_from_user ( & regs -> xtregs_opt , & xtregs -> opt , sizeof ( xtregs -> opt ) ) ; ret |= __copy_from_user ( & ti -> xtregs_user , & xtregs -> user , sizeof ( xtregs -> user ) ) ; return ret ? - EFAULT : 0 ; }
",0,258
1136,"error_t rawSocketReceiveIpPacket ( Socket * socket , SocketMsg * message , uint_t flags ) { error_t error ; SocketQueueItem * queueItem ; if ( ( flags & SOCKET_FLAG_DONT_WAIT ) == 0 ) { if ( socket -> receiveQueue == NULL ) { socket -> eventMask = SOCKET_EVENT_RX_READY ; osResetEvent ( & socket -> event ) ; osReleaseMutex ( & netMutex ) ; osWaitForEvent ( & socket -> event , socket -> timeout ) ; osAcquireMutex ( & netMutex ) ; } } if ( socket -> receiveQueue != NULL ) { queueItem = socket -> receiveQueue ; message -> interface = queueItem -> interface ; message -> length = netBufferRead ( message -> data , queueItem -> buffer , queueItem -> offset , message -> size ) ; message -> srcIpAddr = queueItem -> srcIpAddr ; message -> srcPort = queueItem -> srcPort ; message -> destIpAddr = queueItem -> destIpAddr ; message -> ttl = queueItem -> ancillary . ttl ; # if ( ETH_SUPPORT == ENABLED ) message -> srcMacAddr = queueItem -> ancillary . srcMacAddr ; message -> destMacAddr = queueItem -> ancillary . destMacAddr ; # endif # if ( ETH_PORT_TAGGING_SUPPORT == ENABLED ) message -> switchPort = queueItem -> ancillary . port ; # endif # if ( ETH_TIMESTAMP_SUPPORT == ENABLED ) message -> timestamp = queueItem -> ancillary . timestamp ; # endif if ( ( flags & SOCKET_FLAG_PEEK ) == 0 ) { socket -> receiveQueue = queueItem -> next ; netBufferFree ( queueItem -> buffer ) ; } rawSocketUpdateEvents ( socket ) ; error = NO_ERROR ; } else { message -> length = 0 ; error = ERROR_TIMEOUT ; } return error ; }
",1,449
1137,"static void xcopy_pt_undepend_remotedev ( struct xcopy_op * xop ) { struct se_device * remote_dev ; pr_debug ( ""Callingconfigfs_undepend_itemfor"" ""remote_dev:%premote_dev->dev_group:%p\\n"" , remote_dev , & remote_dev -> dev_group . cg_item ) ; target_undepend_item ( & remote_dev -> dev_group . cg_item ) ; }
",0,112
1138,"static int ndp_sock_open ( struct ndp * ndp ) { int sock ; int ret ; int err ; int val ; sock = socket ( PF_INET6 , SOCK_RAW , IPPROTO_ICMPV6 ) ; if ( sock == - 1 ) { err ( ndp , ""FailedtocreateICMP6socket."" ) ; return - errno ; } val = 1 ; ret = setsockopt ( sock , IPPROTO_IPV6 , IPV6_RECVPKTINFO , & val , sizeof ( val ) ) ; if ( ret == - 1 ) { err ( ndp , ""FailedtosetsockoptIPV6_RECVPKTINFO."" ) ; err = - errno ; goto close_sock ; } val = 255 ; ret = setsockopt ( sock , IPPROTO_IPV6 , IPV6_MULTICAST_HOPS , & val , sizeof ( val ) ) ; if ( ret == - 1 ) { err ( ndp , ""FailedtosetsockoptIPV6_MULTICAST_HOPS."" ) ; err = - errno ; goto close_sock ; } ndp -> sock = sock ; return 0 ; close_sock : close ( sock ) ; return err ; }
",0,284
1139,"static int ext2_xattr_set2 ( struct inode * inode , struct buffer_head * old_bh , struct ext2_xattr_header * header ) { struct super_block * sb = inode -> i_sb ; struct buffer_head * new_bh = NULL ; int error ; struct mb2_cache * ext2_mb_cache = EXT2_SB ( inode -> i_sb ) -> s_mb_cache ; if ( header ) { new_bh = ext2_xattr_cache_find ( inode , header ) ; if ( new_bh ) { if ( new_bh == old_bh ) { ea_bdebug ( new_bh , ""keepingthisblock"" ) ; } else { ea_bdebug ( new_bh , ""reusingblock"" ) ; error = dquot_alloc_block ( inode , 1 ) ; if ( error ) { unlock_buffer ( new_bh ) ; goto cleanup ; } le32_add_cpu ( & HDR ( new_bh ) -> h_refcount , 1 ) ; ea_bdebug ( new_bh , ""refcountnow=%d"" , le32_to_cpu ( HDR ( new_bh ) -> h_refcount ) ) ; } unlock_buffer ( new_bh ) ; } else if ( old_bh && header == HDR ( old_bh ) ) { new_bh = old_bh ; get_bh ( new_bh ) ; ext2_xattr_cache_insert ( new_bh ) ; } else { ext2_fsblk_t goal = ext2_group_first_block_no ( sb , EXT2_I ( inode ) -> i_block_group ) ; int block = ext2_new_block ( inode , goal , & error ) ; if ( error ) goto cleanup ; ea_idebug ( inode , ""creatingblock%d"" , block ) ; new_bh = sb_getblk ( sb , block ) ; if ( unlikely ( ! new_bh ) ) { ext2_free_blocks ( inode , block , 1 ) ; mark_inode_dirty ( inode ) ; error = - ENOMEM ; goto cleanup ; } lock_buffer ( new_bh ) ; memcpy ( new_bh -> b
",0,511
1140,"static int crypto_report_comp ( struct sk_buff * skb , struct crypto_alg * alg ) { struct crypto_report_comp rcomp ; strncpy ( rcomp . type , CRYPTO_MAX_ALG_NAME , ""%s"" , ""compression"" ) ; if ( nla_put ( skb , CRYPTOCFGA_REPORT_COMPRESS , sizeof ( struct crypto_report_comp ) , & rcomp ) ) goto nla_put_failure ; return 0 ; nla_put_failure : return - EMSGSIZE ; }
",1,130
1141,"static vpx_codec_err_t ctrl_set_active_map ( vpx_codec_alg_priv_t * ctx , va_list args ) { vpx_active_map_t * const map = va_arg ( args , vpx_active_map_t * ) ; if ( map ) { if ( ! vp9_set_active_map ( ctx -> cpi , map -> active_map , map -> rows , map -> cols ) ) return VPX_CODEC_OK ; else return VPX_CODEC_INVALID_PARAM ; } else { return VPX_CODEC_INVALID_PARAM ; } }
",0,156
1142,"static int __jfs_set_acl ( tid_t tid , struct inode * inode , int type , struct posix_acl * acl ) { char * ea_name ; int rc ; int size = 0 ; char * value = NULL ; switch ( type ) { case ACL_TYPE_ACCESS : ea_name = XATTR_NAME_POSIX_ACL_ACCESS ; if ( acl ) { rc = posix_acl_update_mode ( inode , & inode -> i_mode ) ; if ( rc < 0 ) return rc ; inode -> i_ctime = CURRENT_TIME ; mark_inode_dirty ( inode ) ; if ( rc == 0 ) acl = NULL ; } break ; case ACL_TYPE_DEFAULT : ea_name = XATTR_NAME_POSIX_ACL_DEFAULT ; break ; default : return - EINVAL ; } if ( acl ) { size = posix_acl_xattr_size ( acl -> a_count ) ; value = kmalloc ( size , GFP_KERNEL ) ; if ( ! value ) return - ENOMEM ; rc = posix_acl_to_xattr ( & init_user_ns , acl , value , size ) ; if ( rc < 0 ) goto out ; } rc = __jfs_setxattr ( tid , inode , ea_name , value , size , 0 ) ; out : kfree ( value ) ; if ( ! rc ) set_cached_acl ( inode , type , acl ) ; return rc ; }
",0,354
1143,"static Image * ReadXCFImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { char magick [ 14 ] ; Image * image ; int foundPropEnd = 0 ; MagickBooleanType status ; MagickOffsetType offset ; register ssize_t i ; size_t image_type , length ; ssize_t count ; XCFDocInfo doc_info ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } count = ReadBlob ( image , 14 , ( unsigned char * ) magick ) ; if ( ( count != 14 ) || ( LocaleNCompare ( ( char * ) magick , ""gimpxcf"" , 8 ) != 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; ( void ) ResetMagickMemory ( & doc_info , 0 , sizeof ( XCFDocInfo ) ) ; doc_info . exception = exception ; doc_info . width = ReadBlobMSBLong ( image ) ; doc_info . height = ReadBlobMSBLong ( image ) ; if ( ( doc_info . width > 262144 ) || ( doc_info . height > 262144 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; doc_info . image_type = ReadBlobMSBLong ( image ) ; image -> columns = doc_info . width ; image -> rows = doc_info . height ; image_type = doc_info . image_type ; doc_info . file_size = GetBlobSize ( image ) ; image -> compression = NoCompression ; image -> depth = 8 ; status = SetImageExtent ( image , image -> columns , image -> rows )
",0,511
1144,"static void perf_event_task_output ( struct perf_event * event , struct perf_task_event * task_event ) { struct perf_output_handle handle ; struct perf_sample_data sample ; struct task_struct * task = task_event -> task ; int ret , size = task_event -> event_id . header . size ; perf_event_header__init_id ( & task_event -> event_id . header , & sample , event ) ; ret = perf_output_begin ( & handle , event , task_event -> event_id . header . size , 0 , 0 ) ; if ( ret ) goto out ; task_event -> event_id . pid = perf_event_pid ( event , task ) ; task_event -> event_id . ppid = perf_event_pid ( event , current ) ; task_event -> event_id . tid = perf_event_tid ( event , task ) ; task_event -> event_id . ptid = perf_event_tid ( event , current ) ; perf_output_put ( & handle , task_event -> event_id ) ; perf_event__output_id_sample ( event , & handle , & sample ) ; perf_output_end ( & handle ) ; out : task_event -> event_id . header . size = size ; }
",0,292
1145,"php_http_url_t * php_http_url_parse ( const char * str , size_t len , unsigned flags TSRMLS_DC ) { size_t maxlen = 3 * len + 8 ; struct parse_state * state = ecalloc ( 1 , sizeof ( * state ) + maxlen ) ; state -> end = str + len ; state -> ptr = str ; state -> flags = flags ; state -> maxlen = maxlen ; TSRMLS_SET_CTX ( state -> ts ) ; if ( ! parse_scheme ( state ) ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""FailedtoparseURLscheme:\'%s\'"" , state -> ptr ) ; efree ( state ) ; return NULL ; } if ( ! parse_hier ( state ) ) { efree ( state ) ; return NULL ; } if ( ! parse_query ( state ) ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""FailedtoparseURLquery:\'%s\'"" , state -> ptr ) ; efree ( state ) ; return NULL ; } if ( ! parse_fragment ( state ) ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""FailedtoparseURLfragment:\'%s\'"" , state -> ptr ) ; efree ( state ) ; return NULL ; } return ( php_http_url_t * ) state ; }
",1,333
1146,"static void php_imagepolygon ( INTERNAL_FUNCTION_PARAMETERS , int filled ) { zval * IM , * POINTS ; long NPOINTS , COL ; zval * * var = NULL ; gdImagePtr im ; gdPointPtr points ; int npoints , col , nelem , i ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , ""rall"" , & IM , & POINTS , & NPOINTS , & COL ) == FAILURE ) { return ; } ZEND_FETCH_RESOURCE ( im , gdImagePtr , & IM , - 1 , ""Image"" , le_gd ) ; npoints = NPOINTS ; col = COL ; nelem = zend_hash_num_elements ( Z_ARRVAL_P ( POINTS ) ) ; if ( nelem < 6 ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Youmusthaveatleast3pointsinyourarray"" ) ; RETURN_FALSE ; } if ( npoints <= 0 ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Youmustgiveapositivenumberofpoints"" ) ; RETURN_FALSE ; } if ( nelem < npoints * 2 ) { php_error_docref ( NULL TSRMLS_CC , E_WARNING , ""Tryingtouse%dpointsinarraywithonly%dpoints"" , npoints , nelem / 2 ) ; RETURN_FALSE ; } points = ( gdPointPtr ) safe_emalloc ( npoints , sizeof ( gdPoint ) , 0 ) ; for ( i = 0 ; i < npoints ; i ++ ) { if ( zend_hash_index_find ( Z_ARRVAL_P ( POINTS ) , ( i * 2 ) , ( void * * ) & var ) == SUCCESS ) { if ( Z_TYPE_PP ( var ) != IS_LONG ) { zval lval ; lval = * * var ; zval_copy_ctor ( & lval ) ; convert_to_long ( & lval ) ; points [ i ] . x = Z_LVAL ( lval
",0,511
1147,"void common_timer_get ( struct k_itimer * timr , struct itimerspec64 * cur_setting ) { const struct k_clock * kc = timr -> kclock ; ktime_t now , remaining , iv ; struct timespec64 ts64 ; bool sig_none ; if ( timr -> it_sigev_notify & ~ SIGEV_THREAD_ID ) == SIGEV_NONE ; sig_none = timr -> it_sigev_notify & ~ SIGEV_THREAD_ID ) == SIGEV_NONE ; iv = timr -> it_interval ; if ( iv ) { cur_setting -> it_interval = ktime_to_timespec64 ( iv ) ; } else if ( ! timr -> it_active ) { if ( ! sig_none ) return ; } kc -> clock_get ( timr -> it_clock , & ts64 ) ; now = timespec64_to_ktime ( ts64 ) ; if ( iv && ( timr -> it_requeue_pending & REQUEUE_PENDING || sig_none ) ) timr -> it_overrun += kc -> timer_forward ( timr , now ) ; remaining = kc -> timer_remaining ( timr , now ) ; if ( remaining <= 0 ) { if ( ! sig_none ) cur_setting -> it_value . tv_nsec = 1 ; } else { cur_setting -> it_value = ktime_to_timespec64 ( remaining ) ; } }
",0,342
1148,"MagickBooleanType sixel_decode ( unsigned char * p , unsigned char * * pixels , size_t * pwidth , size_t * pheight , unsigned char * * palette , size_t * ncolors ) { int n , i , r , g , b , sixel_vertical_mask , c ; int posision_x , posision_y ; int max_x , max_y ; int attributed_pan , attributed_pad ; int attributed_ph , attributed_pv ; int repeat_count , color_index , max_color_index = 2 , background_color_index ; int param [ 10 ] ; int sixel_palet [ SIXEL_PALETTE_MAX ] ; unsigned char * imbuf , * dmbuf ; int imsx , imsy ; int dmsx , dmsy ; int y ; posision_x = posision_y = 0 ; max_x = max_y = 0 ; attributed_pan = 2 ; attributed_pad = 1 ; attributed_ph = attributed_pv = 0 ; repeat_count = 1 ; color_index = 0 ; background_color_index = 0 ; imsx = 2048 ; imsy = 2048 ; imbuf = ( unsigned char * ) AcquireQuantumMemory ( imsx , imsy ) ; if ( imbuf == NULL ) { return ( MagickFalse ) ; } for ( n = 0 ; n < 16 ; n ++ ) { sixel_palet [ n ] = sixel_default_color_table [ n ] ; } for ( r = 0 ; r < 6 ; r ++ ) { for ( g = 0 ; g < 6 ; g ++ ) { for ( b = 0 ; b < 6 ; b ++ ) { sixel_palet [ n ++ ] = SIXEL_RGB ( r * 51 , g * 51 , b * 51 ) ; } } } for ( i = 0 ; i < 24 ; i ++ ) { sixel_palet [ n ++ ] = SIXEL_RGB ( i * 11 , i * 11 , i * 11 ) ; } for ( ; n < SIXEL_PALETTE_MAX ; n ++ ) { sixel_palet [ n ] = SIXEL_RGB ( 255 , 255 , 255 ) ; } ( void ) ResetMagickMemory ( im
",0,511
1149,"static void t1_check_unusual_charstring ( void ) { char * p = strstr ( t1_line_array , charstringname ) + strlen ( charstringname ) ; int i ; if ( sscanf ( p , ""%i"" , & i ) != 1 ) { strcpy ( t1_buf_array , t1_line_array ) ; * ( strend ( t1_buf_array ) - 1 ) = '' ; t1_getline ( ) ; alloc_array ( t1_buf ) ; strcat ( t1_buf_array , t1_line_array ) ; alloc_array ( t1_line_array , t1_buf_array ) ; t1_line_ptr = eol ( t1_line_array ) ; } }
",0,178
1150,"static vpx_codec_err_t ctrl_copy_reference ( vpx_codec_alg_priv_t * ctx , va_list args ) { vpx_ref_frame_t * data = va_arg ( args , vpx_ref_frame_t * ) ; if ( data ) { vpx_ref_frame_t * frame = ( vpx_ref_frame_t * ) data ; YV12_BUFFER_CONFIG sd ; VP9EncoderConfig * const oxcf = & ctx -> oxcf ; image2yuvconfig ( & frame -> img , & sd ) ; return vp9_copy_reference_dec ( ctx -> pbi , ( VP9_REFFRAME ) frame -> frame_type , & sd ) ; } else { return VPX_CODEC_INVALID_PARAM ; } }
",0,195
1151,"static CURLcode pop3_parse_url_path ( struct connectdata * conn ) { struct pop3_conn * pop3c = & conn -> proto . pop3c ; struct SessionHandle * data = conn -> data ; const char * path = data -> state . path ; return Curl_urldecode ( data , path , 0 , NULL , NULL ) ; if ( ! pop3c -> mailbox , NULL , TRUE ) ; }
",0,96
1152,"int rose_parse_facilities ( unsigned char * p , struct rose_facilities_struct * facilities ) { int facilities_len , len ; facilities_len = * p ++ ; if ( facilities_len == 0 ) return 0 ; while ( facilities_len > 0 ) { if ( * p == 0x00 ) { facilities_len -- ; p ++ ; switch ( * p ) { case FAC_NATIONAL : len = rose_parse_national ( p + 1 , facilities , facilities_len - 1 ) ; if ( len < 0 ) return 0 ; facilities_len -= len + 1 ; p += len + 1 ; break ; case FAC_CCITT : len = rose_parse_ccitt ( p + 1 , facilities , facilities_len - 1 ) ; if ( len < 0 ) return 0 ; facilities_len -= len + 1 ; p += len + 1 ; break ; default : printk ( KERN_DEBUG ""ROSE:rose_parse_facilities-unknownfacilitiesfamily%02X\\n"" , * p ) ; facilities_len -- ; p ++ ; break ; } } else break ; } return 1 ; }
",1,244
1153,"static int hls_slice_header ( HEVCContext * s ) { GetBitContext * gb = & s -> HEVClc -> gb ; SliceHeader * sh = & s -> sh ; int i , ret ; sh -> first_slice_in_pic_flag = get_bits1 ( gb ) ; if ( ( IS_IDR ( s ) || IS_BLA ( s ) ) && sh -> first_slice_in_pic_flag ) { s -> seq_decode = ( s -> seq_decode + 1 ) & 0xff ; s -> max_ra = INT_MAX ; if ( IS_IDR ( s ) ) ff_hevc_clear_refs ( s ) ; } sh -> no_output_of_prior_pics_flag = 0 ; if ( IS_IRAP ( s ) ) sh -> no_output_of_prior_pics_flag = get_bits1 ( gb ) ; sh -> pps_id = get_ue_golomb_long ( gb ) ; if ( sh -> pps_id >= HEVC_MAX_PPS_COUNT || ! s -> ps . pps_list [ sh -> pps_id ] ) { av_log ( s -> avctx , AV_LOG_ERROR , ""PPSidoutofrange:%d\\n"" , sh -> pps_id ) ; return AVERROR_INVALIDDATA ; } if ( ! sh -> first_slice_in_pic_flag && s -> ps . pps != ( HEVCPPS * ) s -> ps . pps_list [ sh -> pps_id ] -> data ) { av_log ( s -> avctx , AV_LOG_ERROR , ""PPSchangedbetweenslices.\\n"" ) ; return AVERROR_INVALIDDATA ; } s -> ps . pps = ( HEVCPPS * ) s -> ps . pps_list [ sh -> pps_id ] -> data ; if ( s -> nal_unit_type == HEVC_NAL_CRA_NUT && s -> last_eos == 1 ) sh -> no_output_of_prior_pics_flag = 1 ; if ( s -> ps . sps != ( HEVCSPS * ) s
",0,511
1154,"WORD32 ih264d_mark_err_slice_skip ( dec_struct_t * ps_dec , WORD32 num_mb_skip , UWORD8 u1_is_idr_slice , UWORD16 u2_frame_num , pocstruct_t * ps_cur_poc , WORD32 prev_slice_err ) { WORD32 i2_cur_mb_addr ; UWORD32 u1_num_mbs , u1_num_mbsNby2 ; UWORD32 u1_mb_idx = ps_dec -> u1_mb_idx ; UWORD32 i2_mb_skip_run ; UWORD32 u1_num_mbs_next , u1_end_of_row ; const UWORD32 i2_pic_wdin_mbs = ps_dec -> u2_frm_wd_in_mbs ; UWORD32 u1_slice_end ; UWORD32 u1_tfr_n_mb ; UWORD32 u1_decode_nmb ; dec_bit_stream_t * const ps_bitstrm = ps_dec -> ps_bitstrm ; dec_slice_params_t * ps_slice = ps_dec -> ps_cur_slice ; UWORD32 * pu4_bitstrm_buf = ps_bitstrm -> pu4_buffer ; UWORD32 * pu4_bitstrm_ofst = & ps_bitstrm -> u4_ofst ; deblk_mb_t * ps_cur_deblk_mb ; dec_mb_info_t * ps_cur_mb_info ; parse_pmbarams_t * ps_parse_mb_data ; UWORD32 u1_inter_mb_type ; UWORD32 u1_deblk_mb_type ; UWORD16 u2_total_mbs_coded ; UWORD32 u1_mbaff = ps_slice -> u1_mbaff_frame_flag ; parse_part_params_t * ps_part_info ; WORD32 ret ; if ( ps_dec -> ps_dec_err_status -> u1_err_flag & REJECT_CUR_PIC ) { ih264d_err_pic_dis
",0,511
1155,"IMPEG2D_ERROR_CODES_T impeg2d_dec_p_b_slice ( dec_state_t * ps_dec ) { WORD16 * pi2_vld_out ; UWORD32 i ; yuv_buf_t * ps_cur_frm_buf = & ps_dec -> s_cur_frm_buf ; UWORD32 u4_frm_offset = 0 ; const dec_mb_params_t * ps_dec_mb_params ; IMPEG2D_ERROR_CODES_T e_error = ( IMPEG2D_ERROR_CODES_T ) IVD_ERROR_NONE ; pi2_vld_out = ps_dec -> ai2_vld_buf ; memset ( ps_dec -> ai2_pred_mv , 0 , sizeof ( ps_dec -> ai2_pred_mv ) ) ; ps_dec -> u2_prev_intra_mb = 0 ; ps_dec -> u2_first_mb = 1 ; ps_dec -> u2_picture_width = ps_dec -> u2_frame_width ; if ( ps_dec -> u2_picture_structure != FRAME_PICTURE ) { ps_dec -> u2_picture_width <<= 1 ; if ( ps_dec -> u2_picture_structure == BOTTOM_FIELD ) { u4_frm_offset = ps_dec -> u2_frame_width ; } } do { UWORD32 u4_x_offset , u4_y_offset ; int u4_x_dst_offset = ps_dec -> u2_frame_width ; UWORD32 u4_x_dst_offset = 0 ; UWORD8 * pu1_out_p ; UWORD8 * pu1_pred ; WORD32 u4_pred_strd ; IMPEG2D_TRACE_MB_START ( ps_dec -> u2_mb_x , ps_dec -> u2_mb_y ) ; if ( ps_dec -> e_pic_type == B_PIC ) impeg2d_dec_pnb_mb_params ( ps_dec ) ; else impeg2d_dec_p_mb_params (
",0,511
1156,"vpx_codec_err_t vp9_copy_reference_dec ( VP9Decoder * pbi , VP9_REFFRAME ref_frame_flag , YV12_BUFFER_CONFIG * sd ) { VP9_COMMON * cm = & pbi -> common ; if ( ref_frame_flag == VP9_LAST_FLAG ) { const YV12_BUFFER_CONFIG * const cfg = cm -> frame_bufs [ cm -> ref_frame_map [ 0 ] ] ; if ( ! equal_dimensions ( cfg , sd ) ) vpx_internal_error ( & cm -> error , VPX_CODEC_ERROR , ""Incorrectbufferdimensions"" ) ; else vp8_yv12_copy_frame ( cfg , sd ) ; } else { vpx_internal_error ( & cm -> error , VPX_CODEC_ERROR , ""Invalidreferenceframe"" ) ; } return cm -> error . error_code ; }
",0,224
1157,"void jas_matrix_asr ( jas_matrix_t * matrix , jas_matind_t n ) { jas_matind_t i ; jas_matind_t j ; jas_seqent_t * rowstart ; int rowstep ; jas_seqent_t * data ; assert ( n >= 0 ) ; if ( jas_matrix_numrows ( matrix ) > 0 && jas_matrix_numcols ( matrix ) > 0 ) { assert ( matrix -> rows_ ) ; rowstep = jas_matrix_rowstep ( matrix ) ; for ( i = matrix -> numrows_ , rowstart = matrix -> rows_ [ 0 ] ; i > 0 ; -- i , rowstart += rowstep ) { for ( j = matrix -> numcols_ , data = rowstart ; j > 0 ; -- j , ++ data ) { * data = jas_seqent_asr ( * data , n ) ; } } } }
",0,220
1158,"void vp9_foreach_transformed_block_in_plane ( const MACROBLOCKD * const xd , BLOCK_SIZE bsize , int plane , foreach_transformed_block_visitor visit , void * arg ) { const struct macroblockd_plane * const pd = & xd -> plane [ plane ] ; const MB_MODE_INFO * mbmi = & xd -> mi [ 0 ] -> mbmi ; const TX_SIZE tx_size = plane ? get_uv_tx_size ( mbmi , & xd -> plane [ plane ] ) : mbmi -> tx_size ; const BLOCK_SIZE plane_bsize = get_plane_block_size ( bsize , pd ) ; const int num_4x4_w = num_4x4_blocks_wide_lookup [ plane_bsize ] ; const int num_4x4_h = num_4x4_blocks_high_lookup [ plane_bsize ] ; const int step = 1 << ( tx_size << 1 ) ; int i ; if ( xd -> mb_to_right_edge < 0 || xd -> mb_to_bottom_edge < 0 ) { int r , c ; int max_blocks_wide = num_4x4_w ; int max_blocks_high = num_4x4_h ; if ( xd -> mb_to_right_edge < 0 ) max_blocks_wide += ( xd -> mb_to_right_edge >> ( 5 + pd -> subsampling_x ) ) ; if ( xd -> mb_to_bottom_edge < 0 ) max_blocks_high += ( xd -> mb_to_bottom_edge >> ( 5 + pd -> subsampling_y ) ) ; i = 0 ; for ( r = 0 ; r < num_4x4_h ; r += ( 1 << tx_size ) ) { for ( c = 0 ; c < num_4x4_w ; c += ( 1 << tx_size ) ) { if ( r < max_blocks_high && c < max_blocks_wide ) visit ( plane , i , plane_bsize , tx_size , arg ) ; i += step ; } } } } }
",0,508
1159,"void arch_pick_mmap_layout ( struct mm_struct * mm ) { unsigned long random_factor = 0UL ; if ( current -> flags & PF_RANDOMIZE ) random_factor = arch_mmap_rnd ( ) ; mm -> mmap_legacy_base = TASK_UNMAPPED_BASE + random_factor ; if ( mmap_is_legacy ( ) ) { mm -> mmap_base = mm -> mmap_legacy_base ; mm -> get_unmapped_area = arch_get_unmapped_area ; } else { mm -> mmap_base = mmap_base ( random_factor ) ; mm -> get_unmapped_area = arch_get_unmapped_area_topdown ; } }
",1,176
1160,"void vp8_copy_mem8x4_c ( unsigned char * src , int src_stride , unsigned char * dst , int dst_stride ) { int r ; for ( r = 0 ; r < 4 ; r ++ ) { memcpy ( dst , src , 4 ) ; src += src_stride ; dst += dst_stride ; } }
",0,82
1161,"static size_t optsize ( lua_State * L , char opt , const char * * fmt ) { switch ( opt ) { case 'B' : case 'b' : return sizeof ( char ) ; case 'H' : case 'h' : return sizeof ( short ) ; case 'L' : case 'l' : return sizeof ( long ) ; case 'T' : return sizeof ( size_t ) ; case 'f' : return sizeof ( float ) ; case 'd' : return sizeof ( double ) ; case 'x' : return 1 ; case 'c' : return getnum ( fmt , 1 ) ; case 'i' : case 'I' : { int sz = getnum ( fmt , sizeof ( int ) ) ; if ( sz > MAXINTSIZE ) luaL_error ( L , ""integralsize%dislargerthanlimitof%d"" , sz , MAXINTSIZE ) ; return sz ; } default : return 0 ; } }
",1,215
1162,"static int gtStripSeparate ( TIFFRGBAImage * img , uint32 * raster , uint32 w , uint32 h ) { TIFF * tif = img -> tif ; tileSeparateRoutine put = img -> put . separate ; unsigned char * buf = NULL ; unsigned char * p0 = NULL , * p1 = NULL , * p2 = NULL , * pa = NULL ; uint32 row , y , nrow , rowstoread ; tmsize_t pos ; tmsize_t scanline ; uint32 rowsperstrip , offset_row ; uint32 imagewidth = img -> width ; tmsize_t stripsize ; tmsize_t bufsize ; int32 fromskew , toskew ; int alpha = img -> alpha ; int ret = 1 , flip ; uint16 colorchannels ; stripsize = TIFFStripSize ( tif ) ; bufsize = _TIFFMultiplySSize ( tif , alpha ? 4 : 3 , stripsize , ""gtStripSeparate"" ) ; if ( bufsize == 0 ) { return ( 0 ) ; } flip = setorientation ( img ) ; if ( flip & FLIP_VERTICALLY ) { y = h - 1 ; toskew = - ( int32 ) ( w + w ) ; } else { y = 0 ; toskew = - ( int32 ) ( w - w ) ; } switch ( img -> photometric ) { case PHOTOMETRIC_MINISWHITE : case PHOTOMETRIC_MINISBLACK : case PHOTOMETRIC_PALETTE : colorchannels = 1 ; break ; default : colorchannels = 3 ; break ; } TIFFGetFieldDefaulted ( tif , TIFFTAG_ROWSPERSTRIP , & rowsperstrip ) ; scanline = TIFFScanlineSize ( tif ) ; fromskew = ( w < imagewidth ? imagewidth - w : 0 ) ; for ( row = 0 ; row < h ; row += nrow ) { uint32 temp ; rowstoread = rowsperstrip - ( row + img -> row_offset ) % rowsperstrip ; nrow = ( row + rowstoread > h ? h - row : rowstoread ) ; offset_row = row + img -> row_
",0,511
1163,"static int num_stmts ( const node * n ) { int i , l ; node * ch ; switch ( TYPE ( n ) ) { case single_input : if ( TYPE ( CHILD ( n , 0 ) ) == NEWLINE ) return 0 ; else return num_stmts ( CHILD ( n , 0 ) ) ; case file_input : l = 0 ; for ( i = 0 ; i < NCH ( n ) ; i ++ ) { ch = CHILD ( n , i ) ; if ( TYPE ( ch ) == stmt ) l += num_stmts ( ch ) ; } return l ; case stmt : return num_stmts ( CHILD ( n , 0 ) ) ; case compound_stmt : return 1 ; case simple_stmt : return NCH ( n ) / 2 ; case suite : if ( NCH ( n ) == 1 ) return num_stmts ( CHILD ( n , 0 ) ) ; else { i = 2 ; l = 0 ; if ( TYPE ( CHILD ( n , 1 ) ) == TYPE_COMMENT ) i += 2 ; for ( ; i < ( NCH ( n ) - 1 ) ; i ++ ) l += num_stmts ( CHILD ( n , i ) ) ; return l ; } default : { char buf [ 128 ] ; sprintf ( buf , ""Non-statementfound:%d%d"" , TYPE ( n ) , NCH ( n ) ) ; Py_FatalError ( buf ) ; } } return 0 ; }
",0,332
1164,"static inline void header_put_be_short ( SF_PRIVATE * psf , int x ) { psf -> header ) - 2 ) { psf -> header [ psf -> headindex ++ ] = ( x >> 8 ) ; psf -> header [ psf -> headindex ++ ] = x ; }
",0,69
1165,"long kernel_wait4 ( pid_t upid , int __user * stat_addr , int options , struct rusage * ru ) { struct wait_opts wo ; struct pid * pid = NULL ; enum pid_type type ; long ret ; if ( options & ~ ( WNOHANG | WUNTRACED | WCONTINUED | __WNOTHREAD | __WCLONE | __WALL ) ) return - EINVAL ; if ( upid == INT_MIN ) return - ESRCH ; if ( upid == - 1 ) type = PIDTYPE_MAX ; else if ( upid < 0 ) { type = PIDTYPE_PGID ; pid = find_get_pid ( - upid ) ; } else if ( upid == 0 ) { type = PIDTYPE_PGID ; pid = get_task_pid ( current , PIDTYPE_PGID ) ; } else { type = PIDTYPE_PID ; pid = find_get_pid ( upid ) ; } wo . wo_type = type ; wo . wo_pid = pid ; wo . wo_flags = options | WEXITED ; wo . wo_info = NULL ; wo . wo_stat = 0 ; wo . wo_rusage = ru ; ret = do_wait ( & wo ) ; put_pid ( pid ) ; if ( ret > 0 && stat_addr && put_user ( wo . wo_stat , stat_addr ) ) ret = - EFAULT ; return ret ; }
",1,323
1166,"static int unix_stream_sendmsg ( struct kiocb * kiocb , struct socket * sock , struct msghdr * msg , size_t len ) { struct sock_iocb * siocb = kiocb_to_siocb ( kiocb ) ; struct sock * sk = sock -> sk ; struct sock * other = NULL ; int err , size ; struct sk_buff * skb ; int sent = 0 ; struct scm_cookie tmp_scm ; bool fds_sent = false ; int max_level ; if ( NULL == siocb -> scm , false ) siocb -> scm = & tmp_scm ; wait_for_unix_gc ( ) ; err = scm_send ( sock , msg , siocb -> scm ) ; if ( err < 0 ) return err ; err = - EOPNOTSUPP ; if ( msg -> msg_flags & MSG_OOB ) goto out_err ; if ( msg -> msg_namelen ) { err = sk -> sk_state == TCP_ESTABLISHED ? - EISCONN : - EOPNOTSUPP ; goto out_err ; } else { err = - ENOTCONN ; other = unix_peer ( sk ) ; if ( ! other ) goto out_err ; } if ( sk -> sk_shutdown & SEND_SHUTDOWN ) goto pipe_err ; while ( sent < len ) { size = len - sent ; if ( size > ( ( sk -> sk_sndbuf >> 1 ) - 64 ) ) size = ( sk -> sk_sndbuf >> 1 ) - 64 ; if ( size > SKB_MAX_ALLOC ) size = SKB_MAX_ALLOC ; skb = sock_alloc_send_skb ( sk , size , msg -> msg_flags & MSG_DONTWAIT , & err ) ; if ( skb == NULL ) goto out_err ; size = min_t ( int , size , skb_tailroom ( skb ) ) ; err = unix_scm_to_skb ( siocb -> scm , skb , ! fds_sent ) ; if ( err < 0 ) { kfree_skb ( skb ) ; goto out_err ; } max_level = err + 1 ; fds
",0,511
1167,"int SWFInput_readSBits ( SWFInput input , int number ) { int num = SWFInput_readBits ( input , number ) ; if ( num & ( 1U << ( number - 1 ) ) ) return num - ( 1U << ( number - 1 ) ) ; else return num ; }
",0,69
1168,"int vpx_img_read ( vpx_image_t * img , FILE * file ) { int plane ; for ( plane = 0 ; plane < 3 ; ++ plane ) { unsigned char * buf = img -> planes [ plane ] ; const int stride = img -> stride [ plane ] ; const int w = vpx_img_plane_width ( img , plane ) * ( ( img -> fmt & VPX_IMG_FMT_HIGHBITDEPTH ) ? 2 : 1 ) ; const int h = vpx_img_plane_height ( img , plane ) ; int y ; for ( y = 0 ; y < h ; ++ y ) { if ( fread ( buf , 1 , w , file ) != w ) return 0 ; buf += stride ; } } return 1 ; }
",0,172
1169,"static int decode_avp ( struct l2tp_avp_t * avp , const struct l2tp_attr_t * RV , const char * secret , size_t secret_len ) { MD5_CTX md5_ctx ; uint8_t md5 [ MD5_DIGEST_LENGTH ] ; uint8_t p1 [ MD5_DIGEST_LENGTH ] ; uint8_t * prev_block = NULL ; uint16_t attr_len ; uint16_t orig_attr_len ; uint16_t bytes_left ; uint16_t blocks_left ; uint16_t last_block_len ; uint16_t buffer_size ; if ( avp -> length < sizeof ( struct l2tp_avp_t ) + 2 ) { log_warn ( ""l2tp:incorrecthiddenavpreceived(type%hu):"" ""lengthtoosmall(%hubytes)\\n"" , ntohs ( avp -> type ) , avp -> length ) ; return - 1 ; } buffer_size = sizeof ( struct l2tp_avp_t ) + 2 ; attr_len = avp -> length - sizeof ( struct l2tp_avp_t ) ; MD5_Init ( & md5_ctx ) ; MD5_Update ( & md5_ctx , & avp -> type , sizeof ( avp -> type ) ) ; MD5_Update ( & md5_ctx , secret , secret_len ) ; MD5_Update ( & md5_ctx , RV -> val . octets , RV -> length ) ; MD5_Final ( p1 , & md5_ctx ) ; if ( attr_len <= MD5_DIGEST_LENGTH ) { memxor ( avp -> val , p1 , attr_len ) ; return 0 ; } memxor ( p1 , avp -> val , MD5_DIGEST_LENGTH ) ; orig_attr_len = ntohs ( * ( uint16_t * ) p1 ) ; if ( orig_attr_len <= MD5_DIGEST_LENGTH - 2 ) { memcpy ( avp -> val , p1 , MD5_DIGEST_LENGTH ) ; return 0 ; } if ( orig
",0,511
1170,"static int linear_ioctl ( struct dm_target * ti , unsigned int cmd , unsigned long arg ) { struct linear_c * lc = ( struct linear_c * ) ti -> private ; struct dm_dev * dev = lc -> dev ; int r = 0 ; if ( lc -> start || ti -> len != i_size_read ( dev -> bdev -> bd_inode ) >> SECTOR_SHIFT ) r = scsi_verify_blk_ioctl ( NULL , cmd ) ; return r ? : __blkdev_driver_ioctl ( dev -> bdev , dev -> mode , cmd , arg ) ; }
",1,146
1171,"static int chacha20_poly1305_ctrl ( EVP_CIPHER_CTX * ctx , int type , int arg , void * ptr ) { EVP_CHACHA_AEAD_CTX * actx = aead_data ( ctx ) ; switch ( type ) { case EVP_CTRL_INIT : if ( actx == NULL ) actx = ctx -> cipher_data = OPENSSL_zalloc ( sizeof ( * actx ) + Poly1305_ctx_size ( ) ) ; if ( actx == NULL ) { EVPerr ( EVP_F_CHACHA20_POLY1305_CTRL , EVP_R_INITIALIZATION_ERROR ) ; return 0 ; } actx -> len . aad = 0 ; actx -> len . text = 0 ; actx -> aad = 0 ; actx -> mac_inited = 0 ; actx -> tag_len = 0 ; actx -> nonce_len = 12 ; actx -> tls_payload_length = NO_TLS_PAYLOAD_LENGTH ; return 1 ; case EVP_CTRL_COPY : if ( actx ) { EVP_CIPHER_CTX * dst = ( EVP_CIPHER_CTX * ) ptr ; dst -> cipher_data = OPENSSL_memdup ( actx , sizeof ( * actx ) + Poly1305_ctx_size ( ) ) ; if ( dst -> cipher_data == NULL ) { EVPerr ( EVP_F_CHACHA20_POLY1305_CTRL , EVP_R_COPY_ERROR ) ; return 0 ; } } return 1 ; case EVP_CTRL_AEAD_SET_IVLEN : if ( arg <= 0 || arg > CHACHA_CTR_SIZE ) return 0 ; actx -> nonce_len = arg ; return 1 ; case EVP_CTRL_AEAD_SET_IV_FIXED : if ( arg != 12 ) return 0 ; actx -> nonce [ 0 ] = actx -> key . counter [ 1 ] = CHACHA_U8TOU32 ( ( unsigned char * ) ptr ) ; actx -> nonce [ 1 ] = actx -> key . counter [ 2 ] = CHAC
",0,511
1172,"struct crypto_alg * crypto_larval_lookup ( const char * name , u32 type , u32 mask ) { struct crypto_alg * alg ; if ( ! name ) return ERR_PTR ( - ENOENT ) ; mask &= ~ ( CRYPTO_ALG_LARVAL | CRYPTO_ALG_DEAD ) ; type &= mask ; alg = crypto_alg_lookup ( name , type , mask ) ; if ( ! alg ) { return crypto_alg_add ( name , type , mask ) ; } if ( alg ) return crypto_is_larval ( alg ) ? crypto_larval_wait ( alg ) : alg ; return crypto_larval_add ( name , type , mask ) ; }
",0,172
1173,"static void perf_event_comm_output ( struct perf_event * event , struct perf_comm_event * comm_event ) { struct perf_output_handle handle ; struct perf_sample_data sample ; int size = comm_event -> event_id . header . size ; int ret ; perf_event_header__init_id ( & comm_event -> event_id . header , & sample , event ) ; ret = perf_output_begin ( & handle , event , comm_event -> event_id . header . size , 0 , 0 ) ; if ( ret ) goto out ; comm_event -> event_id . pid = perf_event_pid ( event , comm_event -> task ) ; comm_event -> event_id . tid = perf_event_tid ( event , comm_event -> task ) ; perf_output_put ( & handle , comm_event -> event_id ) ; __output_copy ( & handle , comm_event -> comm , comm_event -> comm_size ) ; perf_event__output_id_sample ( event , & handle , & sample ) ; perf_output_end ( & handle ) ; out : comm_event -> event_id . header . size = size ; }
",0,266
1174,"void fslib_copy_libs ( const char * full_path ) { assert ( full_path ) ; if ( arg_debug || arg_debug_private_lib ) printf ( ""fslib_copy_libs%s\\n"" , full_path ) ; if ( access ( full_path , R_OK ) ) { if ( arg_debug || arg_debug_private_lib ) printf ( ""cannotfind%sforprivate-lib,skipping...\\n"" , full_path ) ; return ; } unlink ( RUN_LIB_FILE ) ; create_empty_file_as_root ( RUN_LIB_FILE , 0644 ) ; if ( chown ( RUN_LIB_FILE , getuid ( ) , getgid ( ) ) ) errExit ( ""chown"" ) ; if ( arg_debug || arg_debug_private_lib ) printf ( ""runningfldd%s\\n"" , full_path ) ; sbox_run ( SBOX_USER | SBOX_SECCOMP | SBOX_CAPS_NONE , 3 , PATH_FLDD , full_path , RUN_LIB_FILE ) ; FILE * fp = fopen ( RUN_LIB_FILE , ""r"" ) ; if ( ! fp ) errExit ( ""fopen"" ) ; char buf [ MAXBUF ] ; while ( fgets ( buf , MAXBUF , fp ) ) { char * ptr = strchr ( buf , '\\n' ) ; if ( ptr ) * ptr = '\\0' ; fslib_duplicate ( buf ) ; } fclose ( fp ) ; unlink ( RUN_LIB_FILE ) ; }
",1,372
1175,"void user_describe ( const struct key * key , struct seq_file * m ) { seq_puts ( m , key -> description ) ; if ( key_is_positive ( key ) ) seq_printf ( m , "":%u"" , key -> datalen ) ; }
",1,64
1176,"static int rfcomm_sock_getname ( struct socket * sock , struct sockaddr * addr , int * len , int peer ) { struct sockaddr_rc * sa = ( struct sockaddr_rc * ) addr ; struct sock * sk = sock -> sk ; BT_DBG ( ""sock%p,sk%p"" , sock , sk ) ; if ( peer ) bacpy ( & sa -> rc_bdaddr , & bt_sk ( sk ) -> dst ) ; else bacpy ( & sa -> rc_bdaddr , & bt_sk ( sk ) -> src ) ; * len = sizeof ( struct sockaddr_rc ) ; return 0 ; }
",0,149
1177,"static int handle_packet ( unsigned char * data , int data_len ) { struct mt_mactelnet_hdr pkthdr ; if ( data_len < MT_HEADER_LEN ) { return - 1 ; } parse_packet ( data , & pkthdr ) ; if ( pkthdr . seskey != sessionkey ) { return - 1 ; } if ( pkthdr . ptype == MT_PTYPE_DATA ) { struct mt_packet odata ; struct mt_mactelnet_control_hdr cpkt ; int success = 0 ; init_packet ( & odata , MT_PTYPE_ACK , srcmac , dstmac , sessionkey , pkthdr . counter + ( data_len - MT_HEADER_LEN ) ) ; send_udp ( & odata , 0 ) ; if ( pkthdr . counter > incounter || ( incounter - pkthdr . counter ) > 65535 ) { incounter = pkthdr . counter ; } else { return - 1 ; } success = parse_control_packet ( data + MT_HEADER_LEN , data_len - MT_HEADER_LEN , & cpkt ) ; while ( success ) { if ( cpkt . cptype == MT_CPTYPE_PASSSALT ) { const char * raw = NULL ; int len = 0 ; if ( * cpkt . cptype == MT_CPTYPE_AUTH ) { fwrite ( ( const void * ) cpkt . data , 1 , cpkt . length , stdout ) ; } else if ( cpkt . cptype == MT_CPTYPE_PLAINDATA ) { fwrite ( ( const void * ) cpkt . data , 1 , cpkt . length , stdout ) ; } else if ( cpkt . cptype == MT_CPTYPE_END_AUTH ) { terminal_mode = 1 ; if ( is_a_tty ) { raw_term ( ) ; setvbuf ( stdin , ( char * ) NULL , _IONBF , 0 ) ; signal ( SIGWINCH , sig_winch ) ; } } success = parse_control_packet ( NULL , 0 , & cpkt ) ; } } else if ( pkthdr . ptype == MT_P
",0,511
1178,"int build_ntlmssp_auth_blob ( unsigned char * * pbuffer , u16 * buflen , struct cifs_ses * ses , const struct nls_table * nls_cp ) { int rc ; AUTHENTICATE_MESSAGE * sec_blob ; __u32 flags ; unsigned char * tmp ; rc = setup_ntlmv2_rsp ( ses , nls_cp ) ; if ( rc ) { cifs_dbg ( VFS , ""Error%dduringNTLMSSPauthentication\\n"" , rc ) ; * buflen = 0 ; goto setup_ntlmv2_ret ; } * pbuffer = kmalloc ( size_of_ntlmssp_blob ( ses ) , GFP_KERNEL ) ; sec_blob = ( AUTHENTICATE_MESSAGE * ) * pbuffer ; memcpy ( sec_blob -> Signature , NTLMSSP_SIGNATURE , 8 ) ; sec_blob -> MessageType = NtLmAuthenticate ; flags = NTLMSSP_NEGOTIATE_56 | NTLMSSP_REQUEST_TARGET | NTLMSSP_NEGOTIATE_TARGET_INFO | NTLMSSP_NEGOTIATE_128 | NTLMSSP_NEGOTIATE_UNICODE | NTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC | NTLMSSP_NEGOTIATE_SEAL ; if ( ses -> server -> sign ) flags |= NTLMSSP_NEGOTIATE_SIGN ; if ( ! ses -> server -> session_estab || ses -> ntlmssp -> sesskey_per_smbsess ) flags |= NTLMSSP_NEGOTIATE_KEY_XCH ; tmp = * pbuffer + sizeof ( AUTHENTICATE_MESSAGE ) ; sec_blob -> NegotiateFlags = cpu_to_le32 ( flags ) ; sec_blob -> LmChallengeResponse . BufferOffset = cpu_to_le32 ( sizeof ( AUTHENTICATE_MESSAGE ) ) ; sec_bl
",0,511
1179,"int imap_open_connection ( struct ImapAccountData * adata ) { if ( mutt_socket_open ( adata -> conn ) < 0 ) return - 1 ; adata -> state = IMAP_CONNECTED ; if ( imap_cmd_step ( adata ) != IMAP_RES_OK ) { imap_close_connection ( adata ) ; return - 1 ; } if ( mutt_istr_startswith ( adata -> buf , ""*OK"" ) ) { if ( ! mutt_istr_startswith ( adata -> buf , ""*OK[CAPABILITY"" ) && check_capabilities ( adata ) ) { goto bail ; } # ifdef USE_SSL if ( ( adata -> conn -> ssf == 0 ) && ( C_SslForceTls || ( adata -> capabilities & IMAP_CAP_STARTTLS ) ) ) { enum QuadOption ans ; if ( C_SslForceTls ) ans = MUTT_YES ; else if ( ( ans = query_quadoption ( C_SslStarttls , _ ( ""SecureconnectionwithTLS?"" ) ) ) == MUTT_ABORT ) { goto err_close_conn ; } if ( ans == MUTT_YES ) { enum ImapExecResult rc = imap_exec ( adata , ""STARTTLS"" , IMAP_CMD_SINGLE ) ; mutt_socket_empty ( adata -> conn ) ; if ( rc == IMAP_EXEC_FATAL ) goto bail ; if ( rc != IMAP_EXEC_ERROR ) { if ( mutt_ssl_starttls ( adata -> conn ) ) { mutt_error ( _ ( ""CouldnotnegotiateTLSconnection"" ) ) ; goto err_close_conn ; } else { if ( imap_exec ( adata , ""CAPABILITY"" , IMAP_CMD_NO_FLAGS ) ) goto bail ; } } } } } if ( C_SslForceTls && ( adata -> conn -> ssf == 0 ) ) { mutt_error ( _ ( ""Encryptedconnectionunavailable"" ) ) ; goto err_close_conn ; } # endif } else if ( mutt_istr_startswith ( adata
",0,511
1180,"static int crypto_report_kpp ( struct sk_buff * skb , struct crypto_alg * alg ) { struct crypto_report_kpp rkpp ; strncpy ( rkpp . type , ""kpp"" , sizeof ( rkpp . type ) ) ; if ( nla_put ( skb , CRYPTOCFGA_REPORT_KPP , sizeof ( struct crypto_report_kpp ) , & rkpp ) ) goto nla_put_failure ; return 0 ; nla_put_failure : return - EMSGSIZE ; }
",1,130
1181,"static int horDiff8 ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) { TIFFPredictorState * sp = PredictorState ( tif ) ; tmsize_t stride = sp -> stride ; unsigned char * cp = ( unsigned char * ) cp0 ; if ( ( cc % stride ) != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , ""horDiff8"" , ""%s"" , ""(cc%stride)!=0"" ) ; return 0 ; } if ( cc > stride ) { cc -= stride ; if ( stride == 3 ) { unsigned int r1 , g1 , b1 ; unsigned int r2 = cp [ 0 ] ; unsigned int g2 = cp [ 1 ] ; unsigned int b2 = cp [ 2 ] ; do { r1 = cp [ 3 ] ; cp [ 3 ] = ( unsigned char ) ( ( r1 - r2 ) & 0xff ) ; r2 = r1 ; g1 = cp [ 4 ] ; cp [ 4 ] = ( unsigned char ) ( ( g1 - g2 ) & 0xff ) ; g2 = g1 ; b1 = cp [ 5 ] ; cp [ 5 ] = ( unsigned char ) ( ( b1 - b2 ) & 0xff ) ; b2 = b1 ; cp += 3 ; } while ( ( cc -= 3 ) > 0 ) ; } else if ( stride == 4 ) { unsigned int r1 , g1 , b1 , a1 ; unsigned int r2 = cp [ 0 ] ; unsigned int g2 = cp [ 1 ] ; unsigned int b2 = cp [ 2 ] ; unsigned int a2 = cp [ 3 ] ; do { r1 = cp [ 4 ] ; cp [ 4 ] = ( unsigned char ) ( ( r1 - r2 ) & 0xff ) ; r2 = r1 ; g1 = cp [ 5 ] ; cp [ 5 ] = ( unsigned char ) ( ( g1 - g2 ) & 0xff ) ; g2 = g1 ; b1 = cp [ 6 ] ; cp [ 6 ] = ( unsigned char ) ( ( b1 - b2 ) & 0xff ) ; b2 = b1 ; a1 = cp [ 7 ] ; cp [ 7 ] = ( unsigned char ) ( ( a1 - a2 ) & 0xff ) ; a2 = a1
",0,511
1182,"static int set_geometry ( unsigned int cmd , struct floppy_struct * g , int drive , int type , struct block_device * bdev ) { int cnt ; if ( g -> sect <= 0 || ( int ) g -> head <= 0 || ( int ) g -> track <= 0 || g -> track > UDP -> tracks >> STRETCH ( g ) || ( g -> stretch & ~ ( FD_STRETCH | FD_SWAPSIDES | FD_SECTBASEMASK ) ) != 0 ) return - EINVAL ; if ( type ) { if ( ! capable ( CAP_SYS_ADMIN ) ) return - EPERM ; mutex_lock ( & open_lock ) ; if ( lock_fdc ( drive ) ) { mutex_unlock ( & open_lock ) ; return - EINTR ; } floppy_type [ type ] = * g ; floppy_type [ type ] . name = ""userformat"" ; for ( cnt = type << 2 ; cnt < ( type << 2 ) + 4 ; cnt ++ ) floppy_sizes [ cnt ] = floppy_sizes [ cnt + 0x80 ] = floppy_type [ type ] . size + 1 ; process_fd_request ( ) ; for ( cnt = 0 ; cnt < N_DRIVE ; cnt ++ ) { struct block_device * bdev = opened_bdev [ cnt ] ; if ( ! bdev || ITYPE ( drive_state [ cnt ] . fd_device ) != type ) continue ; __invalidate_device ( bdev , true ) ; } mutex_unlock ( & open_lock ) ; } else { int oldStretch ; if ( lock_fdc ( drive ) ) return - EINTR ; if ( cmd != FDDEFPRM ) { if ( poll_drive ( true , FD_RAW_NEED_DISK ) == - EINTR ) return - EINTR ; } oldStretch = g -> stretch ; user_params [ drive ] = * g ; if ( buffer_drive == drive ) SUPBOUND ( buffer_max , user_params [ drive ] . sect ) ; current_type [ drive ] = & user_params [ drive ] ; floppy_sizes [ drive ] = user_params [ drive ] . size ; if ( cmd == FDDEFPRM
",0,511
1183,"void gps_tracker ( void ) { ssize_t unused ; int gpsd_sock ; char line [ 256 ] , * temp ; struct sockaddr_in gpsd_addr ; int ret , is_json , pos ; fd_set read_fd ; struct timeval timeout ; pos = 0 ; gpsd_sock = socket ( AF_INET , SOCK_STREAM , 0 ) ; if ( gpsd_sock < 0 ) { return ; } gpsd_addr . sin_family = AF_INET ; gpsd_addr . sin_port = htons ( 2947 ) ; gpsd_addr . sin_addr . s_addr = inet_addr ( ""127.0.0.1"" ) ; if ( connect ( gpsd_sock , ( struct sockaddr * ) & gpsd_addr , sizeof ( gpsd_addr ) ) < 0 ) { return ; } FD_ZERO ( & read_fd ) ; FD_SET ( gpsd_sock , & read_fd ) ; timeout . tv_sec = 1 ; timeout . tv_usec = 0 ; is_json = select ( gpsd_sock + 1 , & read_fd , NULL , NULL , & timeout ) ; if ( is_json ) { if ( recv ( gpsd_sock , line , sizeof ( line ) - 1 , 0 ) <= 0 ) return ; is_json = ( line [ 0 ] == '{' ) ; if ( is_json ) { memset ( line , 0 , sizeof ( line ) ) ; strcpy ( line , ""?WATCH={\\""json\\"":true};\\n"" ) ; if ( send ( gpsd_sock , line , 22 , 0 ) != 22 ) return ; memset ( line , 0 , sizeof ( line ) ) ; if ( recv ( gpsd_sock , line , sizeof ( line ) - 1 , 0 ) <= 0 ) return ; if ( strncmp ( line , ""{\\""class\\"":\\""DEVICES\\"",\\""devices\\"":[]}"" , 32 ) == 0 ) { close ( gpsd_sock ) ; return ; } else { pos = strlen ( line ) ; } } } } while ( G . do_exit == 0 ) {
",0,511
1184,"krb5_error_code k5_asn1_full_decode ( const krb5_data * code , const struct atype_info * a , void * * retrep ) { krb5_error_code ret ; const uint8_t * contents , * remainder ; size_t clen , rlen ; taginfo t ; * retrep = NULL ; ret = get_tag ( ( uint8_t * ) code -> data , code -> length , & t , & contents , & clen , & remainder , & rlen , NULL ) ; if ( ret ) return ret ; if ( ! check_atype_tag ( a , & t ) ) return ASN1_BAD_ID ; return decode_atype_to_ptr ( & t , contents , clen , a , retrep ) ; }
",0,180
1185,"static void user_login ( struct mt_connection * curconn , struct mt_mactelnet_hdr * pkthdr ) { struct mt_packet pdata ; unsigned char md5sum [ 17 ] ; char md5data [ 100 ] ; struct mt_credentials * user ; char * slavename ; int len = 0 ; read_userfile ( ) ; if ( ( user = find_user ( curconn -> username ) ) != NULL ) { md5_state_t state ; # if defined ( __linux__ ) && defined ( _POSIX_MEMLOCK_RANGE ) mlock ( md5data , sizeof ( md5data ) ) ; mlock ( md5sum , sizeof ( md5sum ) ) ; if ( user -> password != NULL ) { mlock ( user -> password , strlen ( user -> password ) ) ; } # endif len = strlen ( user -> password ) ; } # endif md5data [ 0 ] = 0 ; strncpy ( md5data + 1 , user -> password , len ) ; strncpy ( md5data + 1 + strlen ( user -> password ) , curconn -> pass_salt , 16 ) ; md5_init ( & state ) ; md5_append ( & state , ( const md5_byte_t * ) md5data , strlen ( user -> password ) + 17 ) ; md5_finish ( & state , ( md5_byte_t * ) md5sum + 1 ) ; md5sum [ 0 ] = 0 ; init_packet ( & pdata , MT_PTYPE_DATA , pkthdr -> dstaddr , pkthdr -> srcaddr , pkthdr -> seskey , curconn -> outcounter ) ; curconn -> outcounter += add_control_packet ( & pdata , MT_CPTYPE_END_AUTH , NULL , 0 ) ; send_udp ( curconn , & pdata ) ; if ( curconn -> state == STATE_ACTIVE ) { return ; } } if ( user == NULL || memcmp ( md5sum , curconn -> trypassword , 17 ) != 0 ) { syslog ( LOG_NOTICE , _ ( ""(%d)Invalidloginby%s."" ) , curconn -> seskey , curconn -> username ) ; abort_connection ( curconn
",0,511
1186,"static int mount_entry_on_absolute_rootfs ( struct mntent * mntent , const struct lxc_rootfs * rootfs , const char * lxc_name ) { char * aux ; char path [ MAXPATHLEN ] ; int r , ret = 0 , offset ; const char * lxcpath ; lxcpath = lxc_global_config_value ( ""lxc.lxcpath"" ) ; if ( ! lxcpath ) { ERROR ( ""Outofmemory"" ) ; return - 1 ; } r = snprintf ( path , MAXPATHLEN , ""%s/%s/rootfs"" , lxcpath , lxc_name ) ; if ( r < 0 || r >= MAXPATHLEN ) goto skipvarlib ; aux = strstr ( mntent -> mnt_dir , path ) ; if ( aux ) { offset = strlen ( path ) ; goto skipabs ; } skipvarlib : aux = strstr ( mntent -> mnt_dir , rootfs -> path ) ; if ( ! aux ) { WARN ( ""ignoringmountpoint\'%s\'"" , mntent -> mnt_dir ) ; return ret ; } offset = strlen ( rootfs -> path ) ; skipabs : r = snprintf ( path , MAXPATHLEN , ""%s/%s"" , rootfs -> mount , aux + offset ) ; if ( r < 0 || r >= MAXPATHLEN ) { WARN ( ""pathnmetoolongfor\'%s\'"" , mntent -> mnt_dir ) ; return - 1 ; } return mount_entry_on_generic ( mntent , path , rootfs -> mount ) ; }
",1,375
1187,"static int forbidden_name ( struct compiling * c , identifier name , const node * n , int full_checks ) { assert ( PyUnicode_Check ( name ) ) ; if ( PyUnicode_CompareWithASCIIString ( name , ""__debug__"" ) == 0 || PyUnicode_CompareWithASCIIString ( n , ""assignmenttokeyword"" ) ) { ast_error ( c , n , ""assignmenttokeyword"" ) ; return 1 ; } } return 0 ; }
",0,112
1188,"struct bio * bio_map_user_iov ( struct request_queue * q , const struct iov_iter * iter , gfp_t gfp_mask ) { int j ; int nr_pages = 0 ; struct page * * pages ; struct bio * bio ; int cur_page = 0 ; int ret , offset ; struct iov_iter i ; struct iovec iov ; iov_for_each ( iov , i , * iter ) { unsigned long uaddr = ( unsigned long ) iov . iov_base ; unsigned long len = iov . iov_len ; unsigned long end = ( uaddr + len + PAGE_SIZE - 1 ) >> PAGE_SHIFT ; unsigned long start = uaddr >> PAGE_SHIFT ; if ( unlikely ( end < start ) return ERR_PTR ( - EINVAL ) ; nr_pages += end - start ; if ( uaddr & queue_dma_alignment ( q ) ) return ERR_PTR ( - EINVAL ) ; } if ( ! nr_pages ) return ERR_PTR ( - EINVAL ) ; bio = bio_kmalloc ( gfp_mask , nr_pages ) ; if ( ! bio ) return ERR_PTR ( - ENOMEM ) ; ret = - ENOMEM ; pages = kcalloc ( nr_pages , sizeof ( struct page * ) , gfp_mask ) ; if ( ! pages ) goto out ; iov_for_each ( iov , i , * iter ) { unsigned long uaddr = ( unsigned long ) iov . iov_base ; unsigned long len = iov . iov_len ; unsigned long end = ( uaddr + len + PAGE_SIZE - 1 ) >> PAGE_SHIFT ; unsigned long start = uaddr >> PAGE_SHIFT ; const int local_nr_pages = end - start ; const int page_limit = cur_page + local_nr_pages ; ret = get_user_pages_fast ( uaddr , local_nr_pages , ( iter -> type & WRITE ) != WRITE , & pages [ cur_page ] ) ; if ( ret < local_nr_pages ) { ret = - EFAULT ; goto out_unmap ; } offset = offset_in_page ( uaddr ) ; for ( j = cur_page ; j
",0,511
1189,"static int ras_getcmap ( jas_stream_t * in , ras_hdr_t * hdr , ras_cmap_t * cmap ) { int i ; int j ; int x ; int c ; int numcolors ; int actualnumcolors ; switch ( hdr -> maptype ) { case RAS_MT_NONE : break ; case RAS_MT_EQUALRGB : { jas_eprintf ( ""warning:palettizedimagesnotfullysupported\\n"" ) ; numcolors = 1 << hdr -> depth ; if ( numcolors > RAS_CMAP_MAXSIZ ) { return - 1 ; } actualnumcolors = hdr -> maplength / 3 ; for ( i = 0 ; i < numcolors ; i ++ ) { cmap -> data [ i ] = 0 ; } if ( ( hdr -> maplength % 3 ) || hdr -> maplength < 0 || hdr -> maplength > 3 * numcolors ) { return - 1 ; } for ( i = 0 ; i < 3 ; i ++ ) { for ( j = 0 ; j < actualnumcolors ; j ++ ) { if ( ( c = jas_stream_getc ( in ) ) == EOF ) { return - 1 ; } x = 0 ; switch ( i ) { case 0 : x = RAS_RED ( c ) ; break ; case 1 : x = RAS_GREEN ( c ) ; break ; case 2 : x = RAS_BLUE ( c ) ; break ; } cmap -> data [ j ] |= x ; } } } break ; default : return - 1 ; break ; } return 0 ; }
",1,380
1190,"static CURLcode smtp_connect ( struct connectdata * conn , bool * done ) { CURLcode result ; struct smtp_conn * smtpc = & conn -> proto . smtpc ; struct SessionHandle * data = conn -> data ; struct pingpong * pp = & smtpc -> pp ; const char * path = conn -> data -> state . path ; int len ; char localhost [ HOSTNAME_MAX + 1 ] ; * done = FALSE ; Curl_reset_reqproto ( conn ) ; result = smtp_init ( conn ) ; if ( CURLE_OK != result ) return result ; conn -> bits . close = FALSE ; pp -> response_time = RESP_TIMEOUT ; pp -> statemach_act = smtp_statemach_act ; pp -> endofresp = smtp_endofresp ; pp -> conn = conn ; if ( conn -> bits . tunnel_proxy && conn -> bits . httpproxy ) { struct HTTP http_proxy ; struct FTP * smtp_save ; smtp_save = data -> state . proto . smtp ; memset ( & http_proxy , 0 , sizeof ( http_proxy ) ) ; data -> state . proto . http = & http_proxy ; result = Curl_proxyCONNECT ( conn , FIRSTSOCKET , conn -> host . name , conn -> remote_port ) ; data -> state . proto . smtp = smtp_save ; if ( CURLE_OK != result ) return result ; } if ( ( conn -> handler -> protocol & CURLPROTO_SMTPS ) && data -> state . used_interface != Curl_if_multi ) { result = Curl_ssl_connect ( conn , FIRSTSOCKET ) ; if ( result ) return result ; } Curl_pp_init ( pp ) ; pp -> response_time = RESP_TIMEOUT ; pp -> statemach_act = smtp_statemach_act ; pp -> endofresp = smtp_endofresp ; pp -> conn = conn ; if ( ! * path ) { if ( ! Curl_gethostname ( localhost , sizeof localhost ) ) path = localhost ; else path = ""localhost"" ; } smtpc -> domain = curl_easy_unescape ( conn -> data , path , 0 , & len ) ; if ( smt
",0,511
1191,"void jslGetTokenString ( char * str , size_t len ) { if ( lex -> tk == LEX_ID ) { strncpy ( str , ""ID:"" , len ) ; strncat ( str , jslGetTokenValueAsString ( ) , len ) ; } else if ( lex -> tk == LEX_STR ) { strncpy ( str , ""String:\'"" , len ) ; strncat ( str , jslGetTokenValueAsString ( ) , len ) ; strncat ( str , ""\'"" , len ) ; } else jslTokenAsString ( lex -> tk , str , len ) ; }
",0,142
1192,"uint32 armass_assemble ( const char * str , ut64 off , int thumb ) { int i , j ; char buf [ 128 ] ; ArmOpcode aop = { . off = off } ; if ( str [ i ] ; i ++ , j ++ ) { if ( str [ j ] == '#' ) { i -- ; continue ; } buf [ i ] = tolower ( ( const ut8 ) str [ j ] ) ; } buf [ i ] = 0 ; arm_opcode_parse ( & aop , buf ) ; aop . off = off ; if ( thumb < 0 || thumb > 1 ) { return - 1 ; } if ( ! assemble [ thumb ] ( & aop , off , buf ) ) { return - 1 ; } return aop . o ; }
",0,172
1193,"int pnm_validate ( jas_stream_t * in ) { jas_uchar buf [ 2 ] ; int i ; int n ; assert ( JAS_STREAM_MAXPUTBACK >= 2 ) ; if ( ( n = jas_stream_read ( in , buf , 2 ) ) < 0 ) { return - 1 ; } for ( i = n - 1 ; i >= 0 ; -- i ) { if ( jas_stream_ungetc ( in , buf [ i ] ) == EOF ) { return - 1 ; } } if ( n < 2 ) { return - 1 ; } if ( buf [ 0 ] == 'P' && isdigit ( buf [ 1 ] ) ) { return 0 ; } return - 1 ; }
",1,164
1194,"int rds_ib_xmit ( struct rds_connection * conn , struct rds_message * rm , unsigned int hdr_off , unsigned int sg , unsigned int off ) { struct rds_ib_connection * ic = conn -> c_transport_data ; struct ib_device * dev = ic -> i_cm_id -> device ; struct rds_ib_send_work * send = NULL ; struct rds_ib_send_work * first ; struct rds_ib_send_work * prev ; struct ib_send_wr * failed_wr ; struct scatterlist * scat ; u32 pos ; u32 i ; u32 work_alloc ; u32 credit_alloc = 0 ; u32 posted ; u32 adv_credits = 0 ; int send_flags = 0 ; int bytes_sent = 0 ; int ret ; int flow_controlled = 0 ; int nr_sig = 0 ; BUG_ON ( off % RDS_FRAG_SIZE ) ; BUG_ON ( hdr_off != 0 && hdr_off != sizeof ( struct rds_header ) ) ; if ( conn -> c_loopback && rm -> m_inc . i_hdr . h_flags & RDS_FLAG_CONG_BITMAP ) { rds_cong_map_updated ( conn -> c_fcong , ~ ( u64 ) 0 ) ; ret = sizeof ( struct rds_header ) + RDS_CONG_MAP_BYTES ; goto out ; } if ( be32_to_cpu ( rm -> m_inc . i_hdr . h_len ) == 0 ) i = 1 ; else i = ceil ( be32_to_cpu ( rm -> m_inc . i_hdr . h_len ) , RDS_FRAG_SIZE ) ; work_alloc = rds_ib_ring_alloc ( & ic -> i_send_ring , i , & pos ) ; if ( work_alloc == 0 ) { set_bit ( RDS_LL_SEND_FULL , & conn -> c_flags ) ; rds_ib_stats_inc ( s_ib_tx_ring_full ) ; ret = - ENOMEM ; goto out ; } if ( ic -> i_flowctl ) { credit_alloc = rds_ib
",0,511
1195,"static int unimac_mdio_probe ( struct platform_device * pdev ) { struct unimac_mdio_pdata * pdata = pdev -> dev . platform_data ; struct unimac_mdio_priv * priv ; struct device_node * np ; struct mii_bus * bus ; struct resource * r ; int ret ; np = pdev -> dev . of_node ; priv = devm_kzalloc ( & pdev -> dev , sizeof ( * priv ) , GFP_KERNEL ) ; if ( ! priv ) return - ENOMEM ; r = platform_get_resource ( pdev , IORESOURCE_MEM , 0 ) ; if ( ! r ) return - EINVAL ; priv -> base = devm_ioremap ( & pdev -> dev , r -> start , resource_size ( r ) ) ; if ( ! priv -> base ) { dev_err ( & pdev -> dev , ""failedtoremapregister\\n"" ) ; return - ENOMEM ; } priv -> mii_bus = mdiobus_alloc ( ) ; if ( ! priv -> mii_bus ) return - ENOMEM ; bus = priv -> mii_bus ; bus -> priv = priv ; if ( pdata ) { bus -> name = pdata -> bus_name ; priv -> wait_func = pdata -> wait_func ; priv -> wait_func_data = pdata -> wait_func_data ; bus -> phy_mask = ~ pdata -> phy_mask ; } else { bus -> name = ""unimacMIIbus"" ; priv -> wait_func_data = priv ; priv -> wait_func = unimac_mdio_poll ; } bus -> parent = & pdev -> dev ; bus -> read = unimac_mdio_read ; bus -> write = unimac_mdio_write ; bus -> reset = unimac_mdio_reset ; snprintf ( bus -> id , MII_BUS_ID_SIZE , ""%s-%d"" , pdev -> name , pdev -> id ) ; ret = of_mdiobus_register ( bus , np ) ; if ( ret ) { dev_err ( & pdev -> dev , ""MDIObusregistrationfailed\\n"" ) ; goto out_mdio_free ; } platform
",0,511
1196,"BOOL transport_connect_nla ( rdpTransport * transport ) { freerdp * instance ; rdpSettings * settings ; if ( transport -> layer == TRANSPORT_LAYER_TSG ) return TRUE ; if ( ! transport_connect_tls ( transport ) ) return FALSE ; if ( transport -> settings -> Authentication != TRUE ) return TRUE ; settings = transport -> settings ; instance = ( freerdp * ) settings -> instance ; if ( transport -> credssp == NULL ) transport -> credssp = credssp_new ( instance , transport , settings ) ; if ( credssp_authenticate ( transport -> credssp ) < 0 ) { if ( ! connectErrorCode ) connectErrorCode = AUTHENTICATIONERROR ; fprintf ( stderr , ""Authenticationfailure,checkcredentials.\\n"" ""Ifcredentialsarevalid,theNTLMSSPimplementationmaybetoblame.\\n"" ) ; credssp_free ( transport -> credssp ) ; return FALSE ; } credssp_free ( transport -> credssp ) ; return TRUE ; }
",0,242
1197,"static int bin_symbols ( RCore * r , int mode , ut64 laddr , int va , ut64 at , const char * name , bool exponly , const char * args ) { RBinInfo * info = r_bin_get_info ( r -> bin ) ; RList * entries = r_bin_get_entries ( r -> bin ) ; RBinSymbol * symbol ; RBinAddr * entry ; RListIter * iter ; bool firstexp = true ; bool printHere = false ; int i = 0 , lastfs = 's' ; bool bin_demangle = r_config_get_i ( r -> config , ""bin.demangle"" ) ; if ( ! info ) { return 0 ; } if ( args && * args == '.' ) { printHere = true ; } bool is_arm = info && info -> arch && ! strncmp ( info -> arch , ""arm"" , 3 ) ; const char * lang = bin_demangle ? r_config_get ( r -> config , ""bin.lang"" ) : NULL ; RList * symbols = r_bin_get_symbols ( r -> bin ) ; r_spaces_push ( & r -> anal -> meta_spaces , ""bin"" ) ; if ( IS_MODE_JSON ( mode ) && ! printHere ) { r_cons_printf ( ""["" ) ; } else if ( IS_MODE_SET ( mode ) ) { r_flag_space_set ( r -> flags , R_FLAGS_FS_SYMBOLS ) ; } else if ( ! at && exponly ) { if ( IS_MODE_RAD ( mode ) ) { r_cons_printf ( ""fsexports\\n"" ) ; } else if ( IS_MODE_NORMAL ( mode ) ) { r_cons_printf ( printHere ? """" : ""[Exports]\\n"" ) ; } } else if ( ! at && ! exponly ) { if ( IS_MODE_RAD ( mode ) ) { r_cons_printf ( ""fssymbols\\n"" ) ; } else if ( IS_MODE_NORMAL ( mode ) ) { r_cons_printf ( printHere ? """" : ""[Symbols]\\n"" ) ; } } if ( IS_MODE_NORMAL ( mode ) ) { r
",0,511
1198,"static int nfs4_xdr_dec_getacl ( struct rpc_rqst * rqstp , struct xdr_stream * xdr , struct nfs_getaclres * res ) { struct compound_hdr hdr ; int status ; status = decode_compound_hdr ( xdr , & hdr ) ; if ( status ) goto out ; status = decode_sequence ( xdr , & res -> seq_res , rqstp ) ; if ( status ) goto out ; status = decode_putfh ( xdr ) ; if ( status ) goto out ; status = decode_getacl ( xdr , rqstp , res ) ; out : return status ; }
",1,156
1199,"static inline int mount_entry_on_systemfs ( struct mntent * mntent ) { return mount_entry_on_generic ( mntent , mntent -> mnt_dir ) ; }
",0,47
1200,"static VALUE ossl_cipher_pkcs5_keyivgen ( int argc , VALUE * argv , VALUE self ) { EVP_CIPHER_CTX * ctx ; const EVP_MD * digest ; VALUE vpass , vsalt , viter , vdigest ; unsigned char key [ EVP_MAX_KEY_LENGTH ] , iv [ EVP_MAX_IV_LENGTH ] , * salt = NULL ; int iter ; rb_scan_args ( argc , argv , ""13"" , & vpass , & vsalt , & viter , & vdigest ) ; StringValue ( vpass ) ; if ( ! NIL_P ( vsalt ) ) { StringValue ( vsalt ) ; if ( RSTRING_LEN ( vsalt ) != PKCS5_SALT_LEN ) ossl_raise ( eCipherError , ""saltmustbean8-octetstring"" ) ; salt = ( unsigned char * ) RSTRING_PTR ( vsalt ) ; } iter = NIL_P ( viter ) ? 2048 : NUM2INT ( viter ) ; digest = NIL_P ( vdigest ) ? EVP_md5 ( ) : GetDigestPtr ( vdigest ) ; GetCipher ( self , ctx ) ; EVP_BytesToKey ( EVP_CIPHER_CTX_cipher ( ctx ) , digest , salt , ( unsigned char * ) RSTRING_PTR ( vpass ) , RSTRING_LENINT ( vpass ) , iter , key , iv ) ; if ( EVP_CipherInit_ex ( ctx , NULL , NULL , key , iv , - 1 ) != 1 ) ossl_raise ( eCipherError , NULL ) ; OPENSSL_cleanse ( key , sizeof key ) ; OPENSSL_cleanse ( iv , sizeof iv ) ; return Qnil ; }
",0,427
1201,"krb5_error_code kdc_process_s4u2proxy_req ( kdc_realm_t * kdc_active_realm , krb5_kdc_req * request , const krb5_enc_tkt_part * t2enc , const krb5_db_entry * server , krb5_const_principal server_princ , krb5_const_principal proxy_princ , const char * * status ) { krb5_error_code errcode ; if ( request -> kdc_options & ( NON_TGT_OPTION | KDC_OPT_ENC_TKT_IN_SKEY ) ) { * status = ""INVALID_S4U2PROXY_OPTIONS"" ; return KRB5KDC_ERR_BADOPTION ; } if ( ! krb5_principal_compare ( kdc_context , server -> princ , server_princ ) ) { * status = ""EVIDENCE_TICKET_MISMATCH"" ; return KRB5KDC_ERR_SERVER_NOMATCH ; } if ( ! isflagset ( t2enc -> flags , TKT_FLG_FORWARDABLE ) ) { * status = ""EVIDENCE_TICKET_NOT_FORWARDABLE"" ; return KRB5_TKT_NOT_FORWARDABLE ; } errcode = check_allowed_to_delegate_to ( kdc_context , t2enc -> client , server , proxy_princ ) ; if ( errcode ) { * status = ""NOT_ALLOWED_TO_DELEGATE"" ; return errcode ; } return 0 ; }
",0,389
1202,"int copy_thread ( unsigned long clone_flags , unsigned long stack_start , unsigned long stk_sz , struct task_struct * p ) { struct thread_info * thread = task_thread_info ( p ) ; struct pt_regs * childregs = task_pt_regs ( p ) ; memset ( & thread -> cpu_context , 0 , sizeof ( struct cpu_context_save ) ) ; if ( likely ( ! ( p -> flags & PF_KTHREAD ) ) ) { * childregs = * current_pt_regs ( ) ; childregs -> ARM_r0 = 0 ; if ( stack_start ) childregs -> ARM_sp = stack_start ; } else { memset ( childregs , 0 , sizeof ( struct pt_regs ) ) ; thread -> cpu_context . r4 = stk_sz ; thread -> cpu_context . r5 = stack_start ; childregs -> ARM_cpsr = SVC_MODE ; } thread -> cpu_context . pc = ( unsigned long ) ret_from_fork ; thread -> cpu_context . sp = ( unsigned long ) childregs ; clear_ptrace_hw_breakpoint ( p ) ; if ( clone_flags & CLONE_SETTLS ) thread -> tp_value [ 0 ] = childregs -> ARM_r3 ; thread_notify ( THREAD_NOTIFY_COPY , thread ) ; return 0 ; }
",0,324
1203,"jas_stream_t * jas_stream_memopen ( char * buf , int bufsize ) { char * new_buf ; size_t new_bufsize ; JAS_DBGLOG ( 100 , ( ""jas_stream_memopen(%p,%d)\\n"" , buf , bufsize ) ) ; if ( bufsize < 0 ) { jas_deprecated ( ""negativebuffersizeforjas_stream_memopen"" ) ; } if ( buf && bufsize <= 0 ) { obj -> bufsize_ = 1024 ; obj -> growable_ = 1 ; } else { obj -> bufsize_ = bufsize ; obj -> growable_ = 0 ; } if ( buf ) { obj -> buf_ = ( unsigned char * ) buf ; } else { obj -> buf_ = jas_malloc ( obj -> bufsize_ ) ; obj -> myalloc_ = 1 ; } if ( ! obj -> buf_ ) { jas_stream_close ( stream ) ; return 0 ; } JAS_DBGLOG ( 100 , ( ""jas_stream_memopenbufferbuf=%pmyalloc=%d\\n"" , obj -> buf_ , obj -> myalloc_ ) ) ; if ( bufsize > 0 && buf ) { obj -> len_ = bufsize ; } else { obj -> len_ = 0 ; } obj -> pos_ = 0 ; return stream ; }
",0,305
1204,"static int userauth_pubkey ( struct ssh * ssh ) { Authctxt * authctxt = ssh -> authctxt ; struct passwd * pw = authctxt -> pw ; struct sshbuf * b = NULL ; struct sshkey * key = NULL ; char * pkalg = NULL , * userstyle = NULL , * key_s = NULL , * ca_s = NULL ; u_char * pkblob = NULL , * sig = NULL , have_sig ; size_t blen , slen ; int r , pktype ; int authenticated = 0 ; struct sshauthopt * authopts = NULL ; if ( ( r = sshpkt_get_u8 ( ssh , & have_sig ) ) != 0 || ( r = sshpkt_get_cstring ( ssh , & pkalg , NULL ) ) != 0 || ( r = sshpkt_get_string ( ssh , & pkblob , & blen ) ) != 0 ) fatal ( ""%s:parserequestfailed:%s"" , __func__ , ssh_err ( r ) ) ; pktype = sshkey_type_from_name ( pkalg ) ; if ( pktype == KEY_UNSPEC ) { verbose ( ""%s:unsupportedpublickeyalgorithm:%s"" , __func__ , pkalg ) ; goto done ; } if ( ( r = sshkey_from_blob ( pkblob , blen , & key ) ) != 0 ) { error ( ""%s:couldnotparsekey:%s"" , __func__ , ssh_err ( r ) ) ; goto done ; } if ( key == NULL ) { error ( ""%s:cannotdecodekey:%s"" , __func__ , pkalg ) ; goto done ; } if ( key -> type != pktype ) { error ( ""%s:typemismatchfordecodedkey"" ""(received%d,expected%d)"" , __func__ , key -> type , pktype ) ; goto done ; } if ( sshkey_type_plain ( key -> type ) == KEY_RSA && ( ssh -> compat & SSH_BUG_RSAS_PBKEY ) && ( ssh -> compat & SSH_BUG_RSAS_CLIENT_ID ) != 0 ) { pkblob = ssh
",0,511
1205,"int ParseWave64HeaderConfig ( FILE * infile , char * infilename , char * fourcc , WavpackContext * wpc , WavpackConfig * config ) { int64_t total_samples = 0 , infilesize ; Wave64ChunkHeader chunk_header ; Wave64FileHeader filehdr ; WaveHeader WaveHeader ; int format_chunk = 0 ; uint32_t bcount ; CLEAR ( WaveHeader ) ; infilesize = DoGetFileSize ( infile ) ; memcpy ( & filehdr , fourcc , 4 ) ; if ( ! DoReadFile ( infile , ( ( char * ) & filehdr ) + 4 , sizeof ( Wave64FileHeader ) - 4 , & bcount ) || bcount != sizeof ( Wave64FileHeader ) - 4 || memcmp ( filehdr . ckID , riff_guid , sizeof ( riff_guid ) ) || memcmp ( filehdr . formType , wave_guid , sizeof ( wave_guid ) ) ) { error_line ( ""%sisnotavalid.W64file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } else if ( ! ( config -> qmode & QMODE_NO_STORE_WRAPPER ) && ! WavpackAddWrapper ( wpc , & filehdr , sizeof ( filehdr ) ) ) { error_line ( ""%s"" , WavpackGetErrorMessage ( wpc ) ) ; return WAVPACK_SOFT_ERROR ; } # if 1 WavpackLittleEndianToNative ( & filehdr , Wave64ChunkHeaderFormat ) ; if ( infilesize && ! ( config -> qmode & QMODE_IGNORE_LENGTH ) && filehdr . ckSize && filehdr . ckSize + 1 && filehdr . ckSize != infilesize ) { error_line ( ""%sisnotavalid.W64file!"" , infilename ) ; return WAVPACK_SOFT_ERROR ; } # endif while ( 1 ) { if ( ! DoReadFile ( infile , & chunk_header , sizeof ( Wave64ChunkHeader ) , & bcount ) || bcount != sizeof ( Wave64ChunkHeader ) ) { error_line ( ""%sisnotavalid.W64file
",0,511
1206,"static ssize_t ocfs2_direct_IO ( struct kiocb * iocb , struct iov_iter * iter ) { struct file * file = iocb -> ki_filp ; struct inode * inode = file -> f_mapping -> host ; struct ocfs2_super * osb = OCFS2_SB ( inode -> i_sb ) ; get_block_t * get_block ; if ( OCFS2_I ( inode ) -> ip_dyn_features & OCFS2_INLINE_DATA_FL ) return 0 ; if ( iocb -> ki_pos + iter -> count > i_size_read ( inode ) && ! ocfs2_supports_append_dio ( osb ) ) return 0 ; if ( iov_iter_rw ( iter ) == READ ) get_block = ocfs2_get_block ; else get_block = ocfs2_dio_get_block ; return __blockdev_direct_IO ( iocb , inode , inode -> i_sb -> s_bdev , iter , get_block , ocfs2_dio_end_io , NULL , 0 ) ; }
",0,272
1207,"static void _sx_sasl_client_process ( sx_t s , sx_plugin_t p , Gsasl_session * sd , const char * mech , const char * in , int inlen ) { _sx_sasl_t ctx = ( _sx_sasl_t ) p -> private ; _sx_sasl_sess_t sctx = NULL ; char * buf = NULL , * out = NULL , * realm = NULL , * * ext_id ; char hostname [ 256 ] ; int ret ; # ifdef HAVE_SSL int i ; # endif size_t buflen , outlen ; assert ( ctx ) ; assert ( ctx -> cb ) ; if ( mech != NULL ) { _sx_debug ( ZONE , ""authrequestfromclient(mechanism=%s)"" , mech ) && ( ! gsasl_server_support_p ( ctx -> gsasl_ctx , mech ) ) ) { _sx_debug ( ZONE , ""clientrequestedmechanism(%s)thatwedidn\'toffer"" , mech ) ; _sx_nad_write ( s , _sx_sasl_failure ( s , _sasl_err_INVALID_MECHANISM , NULL ) , 0 ) ; return ; } ret = gsasl_server_start ( ctx -> gsasl_ctx , mech , & sd ) ; if ( ret != GSASL_OK ) { _sx_debug ( ZONE , ""gsasl_server_startfailed,nosaslforthisconn;(%d):%s"" , ret , gsasl_strerror ( ret ) ) ; _sx_nad_write ( s , _sx_sasl_failure ( s , _sasl_err_TEMPORARY_FAILURE , gsasl_strerror ( ret ) ) , 0 ) ; return ; } ( ctx -> cb ) ( sx_sasl_cb_GET_REALM , NULL , ( void * * ) & realm , s , ctx -> cbarg ) ; sctx = gsasl_session_hook_get ( s
",0,511
1208,"static int check_stack_boundary ( struct bpf_verifier_env * env , int regno , int access_size , bool zero_size_allowed , struct bpf_call_arg_meta * meta ) { struct bpf_verifier_state * state = env -> cur_state ; struct bpf_reg_state * regs = state -> regs ; int off , i , slot , spi ; if ( regs [ regno ] . type != PTR_TO_STACK ) { if ( zero_size_allowed && access_size == 0 && register_is_null ( regs [ regno ] ) ) return 0 ; verbose ( env , ""R%dtype=%sexpected=%s\\n"" , regno , reg_type_str [ regs [ regno ] . type ] , reg_type_str [ PTR_TO_STACK ] ) ; return - EACCES ; } if ( ! tnum_is_const ( regs [ regno ] . var_off ) ) { char tn_buf [ 48 ] ; tnum_strn ( tn_buf , sizeof ( tn_buf ) , regs [ regno ] . var_off ) ; verbose ( env , ""invalidvariablestackreadR%dvar_off=%s\\n"" , regno , tn_buf ) ; return - EACCES ; } off = regs [ regno ] . off + regs [ regno ] . var_off . value ; if ( off >= 0 || off < - MAX_BPF_STACK || off + access_size > 0 || access_size < 0 || ( access_size == 0 && ! zero_size_allowed ) ) { verbose ( env , ""invalidstacktypeR%doff=%daccess_size=%d\\n"" , regno , off , access_size ) ; return - EACCES ; } if ( env -> prog -> aux -> stack_depth < - off ) env -> prog -> aux -> stack_depth = - off ; if ( meta && meta -> raw_mode ) { meta -> access_size = access_size ; meta -> regno = regno ; return 0 ; } for ( i = 0 ; i < access_size ; i ++ ) { slot = -
",0,511
1209,"static void exif_mnote_data_fuji_load ( ExifMnoteData * en , const unsigned char * buf , unsigned int buf_size ) { ExifMnoteDataFuji * n = ( ExifMnoteDataFuji * ) en ; ExifLong c ; size_t i , tcount , o , datao ; if ( ! n || ! buf || ! buf_size ) { exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteDataFuji"" , ""ShortMakerNote"" ) ; return ; } datao = 6 + n -> offset ; if ( CHECKOVERFLOW ( datao , buf_size , 12 ) ) { exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteDataFuji"" , ""ShortMakerNote"" ) ; return ; } n -> order = EXIF_BYTE_ORDER_INTEL ; datao += exif_get_long ( buf + datao + 8 , EXIF_BYTE_ORDER_INTEL ) ; if ( CHECKOVERFLOW ( datao , buf_size , 2 ) ) { exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteDataFuji"" , ""ShortMakerNote"" ) ; return ; } c = exif_get_short ( buf + datao , EXIF_BYTE_ORDER_INTEL ) ; datao += 2 ; exif_mnote_data_fuji_clear ( n ) ; n -> entries = exif_mem_alloc ( en -> mem , sizeof ( MnoteFujiEntry ) * c ) ; if ( ! n -> entries ) { EXIF_LOG_NO_MEMORY ( en -> log , ""ExifMnoteDataFuji"" , sizeof ( MnoteFujiEntry ) * c ) ; return ; } tcount = 0 ; for ( i = c , o = datao ; i ; -- i , o += 12 ) { size_t s ; if ( CHECKOVERFLOW ( o , buf_size , 12 ) ) { exif_log ( en -> log , EXIF_LOG_CODE_CORRUP
",0,511
1210,"static int ext2_fill_super ( struct super_block * sb , void * data , int silent ) { struct buffer_head * bh ; struct ext2_sb_info * sbi ; struct ext2_super_block * es ; struct inode * root ; unsigned long block ; unsigned long sb_block = get_sb_block ( & data ) ; unsigned long logic_sb_block ; unsigned long offset = 0 ; unsigned long def_mount_opts ; long ret = - EINVAL ; int blocksize = BLOCK_SIZE ; int db_count ; int i , j ; __le32 features ; int err ; err = - ENOMEM ; sbi = kzalloc ( sizeof ( * sbi ) , GFP_KERNEL ) ; if ( ! sbi ) goto failed ; sbi -> s_blockgroup_lock = kzalloc ( sizeof ( struct blockgroup_lock ) , GFP_KERNEL ) ; if ( ! sbi -> s_blockgroup_lock ) { kfree ( sbi ) ; goto failed ; } sb -> s_fs_info = sbi ; sbi -> s_sb_block = sb_block ; spin_lock_init ( & sbi -> s_lock ) ; blocksize = sb_min_blocksize ( sb , BLOCK_SIZE ) ; if ( ! blocksize ) { ext2_msg ( sb , KERN_ERR , ""error:unabletosetblocksize"" ) ; goto failed_sbi ; } if ( blocksize != BLOCK_SIZE ) { logic_sb_block = ( sb_block * BLOCK_SIZE ) / blocksize ; offset = ( sb_block * BLOCK_SIZE ) % blocksize ; } else { logic_sb_block = sb_block ; } if ( ! ( bh = sb_bread ( sb , logic_sb_block ) ) ) { ext2_msg ( sb , KERN_ERR , ""error:unabletoreadsuperblock"" ) ; goto failed_sbi ; } es = ( struct ext2_super_block * ) ( ( ( char * ) bh -> b_data ) + offset ) ; sbi -> s_es = es ; sb -> s_magic = le16_to_cpu ( es
",0,511
1211,"static int remove_bond ( const bt_bdense_t * bd_addr ) { if ( interface_ready ( ) == FALSE ) return BT_STATUS_NOT_READY ; return btif_dm_remove_bond ( bd_addr ) ; }
",0,62
1212,"static int tcpmss_mangle_packet ( struct sk_buff * skb , const struct xt_action_param * par , unsigned int family , unsigned int tcphoff , unsigned int minlen ) { const struct xt_tcpmss_info * info = par -> targinfo ; struct tcphdr * tcph ; int len , tcp_hdrlen ; unsigned int i ; __be16 oldval ; u16 newmss ; u8 * opt ; if ( par -> fragoff != 0 ) return 0 ; if ( ! skb_make_writable ( skb , skb -> len ) ) return - 1 ; len = skb -> len - tcphoff ; if ( len < ( int ) sizeof ( struct tcphdr ) ) return - 1 ; tcph = ( struct tcphdr * ) ( skb_network_header ( skb ) + tcphoff ) ; tcp_hdrlen = tcph -> doff * 4 ; if ( len < tcp_hdrlen ) return - 1 ; if ( tcp_hdrlen >= 15 * 4 ) return - 1 ; if ( info -> mss == XT_TCPMSS_CLAMP_PMTU ) { struct net * net = xt_net ( par ) ; unsigned int in_mtu = tcpmss_reverse_mtu ( net , skb , family ) ; unsigned int min_mtu = min ( dst_mtu ( skb_dst ( skb ) ) , in_mtu ) ; if ( min_mtu <= minlen ) { net_err_ratelimited ( ""unknownorinvalidpath-MTU(%u)\\n"" , min_mtu ) ; return - 1 ; } newmss = min_mtu - minlen ; } else newmss = info -> mss ; opt = ( u_int8_t * ) tcph ; for ( i = sizeof ( struct tcphdr ) ; i <= tcp_hdrlen - TCPOLEN_MSS ; i += optlen ( opt , i ) ) { if ( opt [ i ] == TCPOPT_MSS && opt [ i + 1 ] == TCPOLEN_MSS ) { u_int16_t oldmss ; oldmss = ( opt [ i + 2 ] << 8 ) | opt [ i + 3 ]
",0,511
1213,"jas_matrix_t * jas_matrix_create ( int numrows , int numcols ) { jas_matrix_t * matrix ; int i ; matrix = 0 ; if ( numrows < 0 || numcols < 0 ) { goto error ; } if ( ! ( matrix = jas_malloc ( sizeof ( jas_matrix_t ) ) ) ) { goto error ; } matrix -> flags_ = 0 ; matrix -> numrows_ = numrows ; matrix -> numcols_ = numcols ; matrix -> rows_ = 0 ; matrix -> maxrows_ = numrows ; matrix -> data_ = 0 ; matrix -> datasize_ = 0 ; if ( matrix -> maxrows_ > 0 ) { if ( ! ( matrix -> rows_ = jas_alloc2 ( matrix -> maxrows_ , sizeof ( jas_seqent_t * ) ) ) ) { jas_matrix_destroy ( matrix ) ; return 0 ; } } if ( matrix -> datasize_ > 0 ) { if ( ! ( matrix -> data_ = jas_alloc2 ( matrix -> datasize_ , sizeof ( jas_seqent_t ) ) ) ) { jas_matrix_destroy ( matrix ) ; return 0 ; } } for ( i = 0 ; i < numrows ; ++ i ) { matrix -> rows_ [ i ] = & matrix -> data_ [ i * matrix -> numcols_ ] ; } for ( i = 0 ; i < matrix -> datasize_ ; ++ i ) { matrix -> data_ [ i ] = 0 ; } matrix -> xstart_ = 0 ; matrix -> ystart_ = 0 ; matrix -> xend_ = matrix -> numcols_ ; matrix -> yend_ = matrix -> numrows_ ; return matrix ; error : if ( matrix ) { jas_matrix_destroy ( matrix ) ; } return 0 ; }
",0,410
1214,"int ip6_fragment ( struct sk_buff * skb , int ( * output ) ( struct sk_buff * ) ) { struct sk_buff * frag ; struct rt6_info * rt = ( struct rt6_info * ) skb_dst ( skb ) ; struct ipv6_pinfo * np = skb -> sk ? inet6_sk ( skb -> sk ) : NULL ; struct ipv6hdr * tmp_hdr ; struct frag_hdr * fh ; unsigned int mtu , hlen , left , len ; __be32 frag_id = 0 ; int ptr , offset = 0 , err = 0 ; u8 * prevhdr , nexthdr = 0 ; struct net * net = dev_net ( skb_dst ( skb ) -> dev ) ; hlen = ip6_find_1stfragopt ( skb , & prevhdr ) ; nexthdr = * prevhdr ; mtu = ip6_skb_dst_mtu ( skb ) ; if ( ! skb -> local_df && skb -> len > mtu ) { skb -> dev = skb_dst ( skb ) -> dev ; icmpv6_send ( skb , ICMPV6_PKT_TOOBIG , 0 , mtu ) ; IP6_INC_STATS ( net , ip6_dst_idev ( skb_dst ( skb ) ) , IPSTATS_MIB_FRAGFAILS ) ; kfree_skb ( skb ) ; return - EMSGSIZE ; } if ( np && np -> frag_size < mtu ) { if ( np -> frag_size ) mtu = np -> frag_size ; } mtu -= hlen + sizeof ( struct frag_hdr ) ; if ( skb_has_frag_list ( skb ) ) { int first_len = skb_pagelen ( skb ) ; struct sk_buff * frag2 ; if ( first_len - hlen > mtu || ( ( first_len - hlen ) & 7 ) || skb_cloned ( skb ) ) goto slow_path ; skb_walk_frags ( skb , frag ) { if ( frag -> len >
",0,511
1215,"static int ext4_xattr_cache_insert ( struct mb2_cache * ext4_mb_cache , struct buffer_head * bh ) { __u32 hash = le32_to_cpu ( BHDR ( bh ) -> h_hash ) ; struct mb2_cache_entry * ce ; int error ; ce = mb2_cache_entry_alloc ( ext4_mb_cache , GFP_NOFS ) ; if ( ! ce ) { ea_bdebug ( bh , ""outofmemory"" ) ; return ; } error = mb2_cache_entry_insert ( ce , bh -> b_bdev , bh -> b_blocknr , hash ) ; if ( error ) { mb2_cache_entry_free ( ce ) ; if ( error == - EBUSY ) { ea_bdebug ( bh , ""alreadyincache"" ) ; error = 0 ; } } else { ea_bdebug ( bh , ""inserting[%x]"" , ( int ) hash ) ; mb2_cache_entry_release ( ce ) ; } return error ; }
",0,253
1216,"static SCSIRequest * scsi_new_request ( SCSIDevice * d , uint32_t tag , uint32_t lun , void * hba_private ) { SCSIDiskState * s = DO_UPCAST ( SCSIDiskState , qdev , d ) ; SCSIRequest * req ; req = scsi_req_alloc ( & scsi_disk_reqops , & s -> qdev , tag , lun , hba_private ) ; return req ; }
",1,111
1217,"Datum txid_snapshot_recv ( PG_FUNCTION_ARGS ) { StringInfo buf = ( StringInfo ) PG_GETARG_POINTER ( 0 ) ; TxidSnapshot * snap ; txid last = 0 ; int nxip ; int i ; int avail ; int expect ; txid xmin , xmax ; nxip = pq_getmsgint ( buf , 4 ) ; avail = buf -> len - buf -> cursor ; if ( nxip < 0 || nxip > avail || expect > avail ) goto bad_format ; xmin = pq_getmsgint64 ( buf ) ; xmax = pq_getmsgint64 ( buf ) ; if ( xmin == 0 || xmax == 0 || xmin > xmax || xmax > MAX_TXID ) goto bad_format ; snap = palloc ( TXID_SNAPSHOT_SIZE ( nxip ) ) ; snap -> xmin = xmin ; snap -> xmax = xmax ; snap -> nxip = nxip ; SET_VARSIZE ( snap , TXID_SNAPSHOT_SIZE ( nxip ) ) ; for ( i = 0 ; i < nxip ; i ++ ) { txid cur = pq_getmsgint64 ( buf ) ; if ( cur <= last || cur < xmin || cur >= xmax ) goto bad_format ; snap -> xip [ i ] = cur ; last = cur ; } PG_RETURN_POINTER ( snap ) ; bad_format : elog ( ERROR , ""invalidsnapshotdata"" ) ; return ( Datum ) NULL ; }
",0,363
1218,"static inline void header_put_le_3byte ( SF_PRIVATE * psf , int x ) { psf -> header ) - 3 ) { psf -> header [ psf -> headindex ++ ] = x ; psf -> header [ psf -> headindex ++ ] = ( x >> 8 ) ; psf -> header [ psf -> header [ psf -> headindex ++ ] = ( x >> 16 ) ; }
",0,94
1219,"static int rds_ib_laddr_check ( __be32 addr ) { int ret ; struct rdma_cm_id * cm_id ; struct sockaddr_in sin ; cm_id = rdma_create_id ( NULL , NULL , RDMA_PS_TCP , IB_QPT_RC ) ; if ( IS_ERR ( cm_id ) ) return PTR_ERR ( cm_id ) ; memset ( & sin , 0 , sizeof ( sin ) ) ; sin . sin_family = AF_INET ; sin . sin_addr . s_addr = addr ; ret = rdma_bind_addr ( cm_id , ( struct sockaddr * ) & sin , false ) ; if ( ret || cm_id -> device -> node_type != RDMA_NODE_IB_CA ) ret = - EADDRNOTAVAIL ; rdsdebug ( ""addr%pI4ret%dnodetype%d\\n"" , & addr , ret , cm_id -> device ? cm_id -> device -> node_type : - 1 ) ; rdma_destroy_id ( cm_id ) ; return ret ; }
",0,260
1220,"static int xfrm_dump_policy ( struct sk_buff * skb , struct netlink_callback * cb ) { struct net * net = sock_net ( skb -> sk ) ; struct xfrm_policy_walk * walk = ( struct xfrm_policy_walk * ) cb -> args [ 1 ] ; struct xfrm_dump_info info ; info . in_skb = cb -> skb ; info . out_skb = skb ; info . nlmsg_seq = cb -> nlh -> nlmsg_seq ; info . nlmsg_flags = NLM_F_MULTI ; if ( ! cb -> args [ 0 ] ) { cb -> args [ 0 ] = 1 ; xfrm_policy_walk_init ( walk , XFRM_POLICY_TYPE_ANY ) ; } ( void ) xfrm_policy_walk ( net , walk , dump_one_policy , & info ) ; return skb -> len ; }
",1,225
1221,"static ssize_t _epoll_write ( oe_fd_t * epoll_ , const void * buf , size_t count ) { ssize_t ret = - 1 ; epoll_t * epoll = _cast_epoll ( epoll_ ) ; oe_errno = 0 ; if ( oe_syscall_write_ocall ( & ret , epoll -> host_fd , buf , count ) != OE_OK ) OE_RAISE_ERRNO ( OE_EINVAL ) ; done : return ret ; }
",0,127
1222,"static int ovl_remove_upper ( struct dentry * dentry , bool is_dir ) { struct dentry * upperdir = ovl_dentry_upper ( dentry -> d_parent ) ; struct inode * dir = upperdir -> d_inode ; struct dentry * upper ; int err ; inode_lock_nested ( dir , I_MUTEX_PARENT ) ; upper = lookup_one_len ( dentry -> d_name . name , & upperdir -> d_name . len ) ; err = PTR_ERR ( upper ) ; if ( IS_ERR ( upper ) ) goto out_unlock ; err = - ESTALE ; if ( upper == ovl_dentry_upper ( dentry ) ) { if ( is_dir ) err = vfs_rmdir ( dir , upper ) ; else err = vfs_unlink ( dir , upper , NULL ) ; ovl_dentry_version_inc ( dentry -> d_parent ) ; } dput ( upper ) ; ovl_dentry_version_inc ( dentry -> d_parent ) ; return err ; }
",0,250
1223,"NOEXPORT int init_section ( int eof , SERVICE_OPTIONS * * section_ptr ) { char * errstr ; # ifndef USE_WIN32 ( * section_ptr ) -> option . log_stderr = new_global_options . option . log_stderr ; # endif if ( * section_ptr == & new_service_options ) { errstr = parse_global_option ( CMD_INITIALIZE , NULL , NULL , 0 ) ; if ( errstr ) { s_log ( LOG_ERR , ""Globaloptions:%s"" , errstr ) ; return 1 ; } } if ( * section_ptr != & new_service_options || eof ) { if ( * section_ptr == & new_service_options ) s_log ( LOG_INFO , ""Initializinginetdmodeconfiguration"" ) ; else s_log ( LOG_INFO , ""Initializingservice[%s]"" , ( * section_ptr ) -> servname ) ; errstr = parse_service_option ( CMD_INITIALIZE , section_ptr , NULL , NULL ) ; if ( errstr ) { if ( * section_ptr == & new_service_options ) s_log ( LOG_ERR , ""Inetdmode:%s"" , errstr ) ; else s_log ( LOG_ERR , ""Service[%s]:%s"" , ( * section_ptr ) -> servname , errstr ) ; return 1 ; } } return 0 ; }
",0,336
1224,"int av_reallocp_array ( void * ptr , size_t nmemb , size_t size ) { void * * ptrptr = ptr ; * ptrptr = av_realloc_f ( * ptrptr , nmemb , size ) ; if ( ! * ptrptr && nmemb && size ) ) return AVERROR ( ENOMEM ) ; return 0 ; }
",1,85
1225,"int parse_file ( FILE * input_file , char * directory , char * body_filename , char * body_pref , int flags ) { uint32 d ; uint16 key ; Attr * attr = NULL ; File * file = NULL ; int rtf_size = 0 , html_size = 0 ; MessageBody body ; memset ( & body , '\\0' , sizeof ( MessageBody ) ) ; g_flags = flags ; d = geti32 ( input_file ) ; if ( d != TNEF_SIGNATURE ) { fprintf ( stdout , ""SeemsnottobeaTNEFfile\\n"" ) ; return 1 ; } key = geti16 ( input_file ) ; debug_print ( ""TNEFKey:%hx\\n"" , key ) ; while ( data_left ( input_file ) ) { attr = read_object ( input_file ) ; if ( attr == NULL ) break ; if ( attr -> name == attATTACHRENDDATA ) { if ( file ) { file_write ( file , directory ) ; file_free ( file ) ; } else { file = CHECKED_XCALLOC ( File , 1 ) ; } } switch ( attr -> lvl_type ) { case LVL_MESSAGE : if ( attr -> name == attBODY ) { body . text_body = get_text_data ( attr ) ; } else if ( attr -> name == attMAPIPROPS ) { MAPI_Attr * * mapi_attrs = mapi_attr_read ( attr -> len , attr -> buf ) ; if ( mapi_attrs ) { int i ; for ( i = 0 ; mapi_attrs [ i ] ; i ++ ) { MAPI_Attr * a = mapi_attrs [ i ] ; if ( a -> type == szMAPI_BINARY && a -> name == MAPI_BODY_HTML ) { body . html_bodies = get_html_data ( a ) ; html_size = a -> num_values ; } else if ( a -> type == szMAPI_BINARY && a -> name == MAPI_RTF_COMPRESSED ) { body . rtf_bodies = get_rtf_data ( a
",0,511
1226,"static int DecodeGifImg ( struct ngiflib_img * i ) { struct ngiflib_decode_context context ; long npix ; u8 * stackp ; u8 * stack_top ; u16 clr ; u16 eof ; u16 free ; u16 act_code = 0 ; u16 old_code = 0 ; u16 read_byt ; u16 ab_prfx [ 4096 ] ; u8 ab_suffx [ 4096 ] ; u8 ab_stack [ 4096 ] ; u8 flags ; u8 casspecial = 0 ; if ( ! i ) return - 1 ; i -> posX = GetWord ( i -> parent ) ; i -> posY = GetWord ( i -> parent ) ; i -> width = GetWord ( i -> parent ) ; i -> height = GetWord ( i -> parent ) ; if ( ( i -> width > i -> parent -> width ) || ( i -> height > i -> parent -> height ) ) { # if ! defined ( NGIFLIB_NO_FILE ) if ( i -> parent -> log ) fprintf ( i -> parent -> log , ""***ERROR***ImagebiggerthanglobalGIFcanvas
",0,258
1227,"public int magic_getparam ( struct magic_set * ms , int param , void * val ) { switch ( param ) { case MAGIC_PARAM_INDIR_MAX : * ( size_t * ) val = ms -> indir_max ; return 0 ; case MAGIC_PARAM_ELF_NOTES_MAX : * ( size_t * ) val = ms -> elf_notes_max ; return 0 ; case MAGIC_PARAM_ELF_PHNUM_MAX : * ( size_t * ) val = ms -> elf_phnum_max ; return 0 ; case MAGIC_PARAM_ELF_SHNUM_MAX : * ( size_t * ) val = ms -> elf_shnum_max ; return 0 ; default : errno = EINVAL ; return - 1 ; } }
",0,178
1228,"jas_image_t * jp2_decode ( jas_stream_t * in , char * optstr ) { jp2_box_t * box ; int found ; jas_image_t * image ; jp2_dec_t * dec ; bool samedtype ; int dtype ; unsigned int i ; jp2_cmap_t * cmapd ; jp2_pclr_t * pclrd ; jp2_cdef_t * cdefd ; unsigned int channo ; int newcmptno ; int_fast32_t * lutents ; # if 0 jp2_cdefchan_t * cdefent ; int cmptno ; # endif jp2_cmapent_t * cmapent ; jas_icchdr_t icchdr ; jas_iccprof_t * iccprof ; dec = 0 ; box = 0 ; image = 0 ; if ( ! ( dec = jp2_dec_create ( ) ) ) { goto error ; } if ( ! ( box = jp2_box_get ( in ) ) ) { jas_eprintf ( ""error:cannotgetbox\\n"" ) ; goto error ; } if ( box -> type != JP2_BOX_JP ) { jas_eprintf ( ""error:expectingsignaturebox\\n"" ) ; goto error ; } if ( box -> data . jp . magic != JP2_JP_MAGIC ) { jas_eprintf ( ""incorrectmagicnumber\\n"" ) ; goto error ; } jp2_box_destroy ( box ) ; box = 0 ; if ( ! ( box = jp2_box_get ( in ) ) ) { goto error ; } if ( box -> type != JP2_BOX_FTYP ) { jas_eprintf ( ""expectingfiletypebox\\n"" ) ; goto error ; } jp2_box_destroy ( box ) ; box = 0 ; found = 0 ; while ( ( box = jp2_box_get ( in ) ) ) { if ( jas_getdbglevel ( ) >= 1 ) { jas_eprintf ( ""boxtype%s\\n"" , box -> info -> name , box -> type ) ; }
",0,511
1229,"int sequencer_write ( int dev , struct file * file , const char __user * buf , int count ) { unsigned char event_rec [ EV_SZ ] , ev_code ; int p = 0 , c , ev_size ; int mode = translate_mode ( file ) ; dev = dev >> 4 ; DEB ( printk ( ""sequencer_write(dev=%d,count=%d)\\n"" , dev , count ) ) ; if ( mode == OPEN_READ ) return - EIO ; c = count ; while ( c >= 4 ) { if ( copy_from_user ( ( char * ) event_rec , & ( buf ) [ p ] , 4 ) ) goto out ; ev_code = event_rec [ 0 ] ; if ( ev_code == SEQ_FULLSIZE ) { int err , fmt ; dev = * ( unsigned short * ) & event_rec [ 2 ] ; if ( dev < 0 || dev >= max_synthdev || synth_devs [ dev ] == NULL ) return - ENXIO ; if ( ! ( synth_open_mask & ( 1 << dev ) ) ) return - ENXIO ; fmt = ( * ( short * ) & event_rec [ 0 ] ) & 0xffff ; err = synth_devs [ dev ] -> load_patch ( dev , fmt , buf , p + 4 , c , 0 ) ; if ( err < 0 ) return err ; return err ; } if ( ev_code >= 128 ) { if ( seq_mode == SEQ_2 && ev_code == SEQ_EXTENDED ) { printk ( KERN_WARNING ""Sequencer:Invalidlevel2event%x\\n"" , ev_code ) ; return - EINVAL ; } ev_size = 8 ; if ( c < ev_size ) { if ( ! seq_playing ) seq_startplay ( ) ; return count - c ; } if ( copy_from_user ( ( char * ) & event_rec [ 4 ] , & ( buf ) [ p + 4 ] , 4 ) ) goto out ; } else { if ( seq_mode == SEQ_2 ) { printk ( KERN_WARNING ""Sequencer:4byteeventinlevel2mode\\n"" ) ; return - EINVAL ; } ev_size = 4 ; if ( event_rec [ 0 ]
",0,511
1230,"static void ext4_invalidatepage ( struct page * page , unsigned long offset ) { struct journal_t * journal = EXT4_JOURNAL ( page -> mapping -> host ) ; if ( offset == 0 ) ClearPageChecked ( page ) ; if ( journal ) jbd2_journal_invalidatepage ( journal , page , offset ) ; else block_invalidatepage ( page , offset ) ; }
",0,93
1231,"GF_Err SetupWriters ( MovieWriter * mw , GF_List * writers , u8 interleaving ) { u32 i , trackCount ; TrackWriter * writer ; GF_TrackBox * trak ; GF_ISOFile * movie = mw -> movie ; mw -> total_samples = mw -> nb_done = 0 ; if ( ! movie -> moov ) return GF_OK ; trackCount = gf_list_count ( movie -> moov -> trackList ) ; for ( i = 0 ; i < trackCount ; i ++ ) { if ( ! movie -> moov ) return GF_OK ; trak = gf_isom_get_track ( movie -> moov , i + 1 ) ; GF_SAFEALLOC ( writer , TrackWriter ) ; if ( ! writer ) goto exit ; writer -> sampleNumber = 1 ; writer -> mdia = trak -> Media ; writer -> stbl = trak -> Media -> information -> sampleTable ; writer -> timeScale = trak -> Media -> mediaHeader -> timeScale ; writer -> all_dref_mode = Media_SelfContainedType ( writer -> mdia ) ; if ( trak -> sample_encryption ) writer -> prevent_dispatch = GF_TRUE ; writer -> isDone = 0 ; writer -> DTSprev = 0 ; writer -> chunkDur = 0 ; writer -> chunkSize = 0 ; writer -> constant_size = writer -> constant_dur = 0 ; if ( writer -> stbl -> SampleSize -> sampleSize ) writer -> constant_size = writer -> stbl -> SampleSize -> sampleSize ; if ( writer -> stbl -> TimeToSample -> nb_entries == 1 ) { writer -> constant_dur = writer -> stbl -> TimeToSample -> entries [ 0 ] . sampleDelta ; if ( writer -> constant_dur > 1 ) writer -> constant_dur = 0 ; } if ( ! writer -> constant_dur || ! writer -> constant_size || ( writer -> constant_size >= 10 ) ) writer -> constant_size = writer -> constant_dur = 0 ; writer -> stsc = ( GF_SampleToChunkBox * ) gf_isom_box_new ( GF_ISOM_BOX_TYPE_STSC ) ; if ( ! writer -> stsc ) return GF_OUT_OF_MEM ;
",0,511
1232,"static UINT32 nsc_rle_encode ( const BYTE * in , BYTE * out , UINT32 originalSize ) { UINT32 left ; UINT32 runlength = 1 ; UINT32 planeSize = 0 ; left = originalSize ; while ( left > 4 && planeSize < originalSize - 4 ) { if ( left > 5 && * in == * ( in + 1 ) ) { runlength ++ ; } else if ( runlength == 1 ) { * out ++ = * in ; planeSize ++ ; } else if ( runlength < 256 ) { * out ++ = * in ; * out ++ = * in ; * out ++ = runlength - 2 ; runlength = 1 ; planeSize += 3 ; } else { * out ++ = * in ; * out ++ = * in ; * out ++ = 0xFF ; * out ++ = ( runlength & 0x000000FF ) ; * out ++ = ( runlength & 0x0000FF00 ) >> 8 ; * out ++ = ( runlength & 0x00FF0000 ) >> 16 ; * out ++ = ( runlength & 0xFF000000 ) >> 24 ; runlength = 1 ; planeSize += 7 ; } in ++ ; left -- ; } if ( planeSize < originalSize - 4 ) CopyMemory ( out , in , 4 ) ; planeSize += 4 ; return planeSize ; }
",1,295
1233,"static void send_auth ( char * username , char * password ) { struct mt_packet data ; unsigned short width = 0 ; unsigned short height = 0 ; char * terminal = getenv ( ""TERM"" ) ; char md5data [ 100 ] ; unsigned char md5sum [ 17 ] ; int plen ; md5_state_t state ; # if defined ( __linux__ ) && defined ( _POSIX_MEMLOCK_RANGE ) mlock ( md5data , sizeof ( md5data ) ) ; mlock ( md5sum , sizeof ( md5data ) ) ; # endif strncpy ( md5data + 1 , password , state ) ; md5data [ 83 ] = '\\0' ; strncpy ( md5data + 1 + strlen ( password ) , pass_salt , 16 ) ; md5_init ( & state ) ; md5_append ( & state , ( const md5_byte_t * ) md5data , strlen ( password ) + 17 ) ; md5_finish ( & state , ( md5_byte_t * ) md5sum + 1 ) ; md5sum [ 0 ] = 0 ; init_packet ( & data , MT_PTYPE_DATA , srcmac , dstmac , sessionkey , outcounter ) ; plen = add_control_packet ( & data , MT_CPTYPE_PASSWORD , md5sum , 17 ) ; plen += add_control_packet ( & data , MT_CPTYPE_USERNAME , username , strlen ( username ) ) ; plen += add_control_packet ( & data , MT_CPTYPE_TERM_TYPE , terminal , strlen ( terminal ) ) ; if ( is_a_tty && get_terminal_size ( & width , & height ) != - 1 ) { width = htole16 ( width ) ; height = htole16 ( height ) ; plen += add_control_packet ( & data , MT_CPTYPE_TERM_WIDTH , & width , 2 ) ; plen += add_control_packet ( & data , MT_CPTYPE_TERM_HEIGHT , & height , 2 ) ; } outcounter += plen ; send_udp ( & data , VERM_AUTH ) ; }
",0,505
1234,"void * Sys_LoadDll ( const char * name , qboolean useSystemLib ) { void * dllhandle ; if ( COM_CompareExtension ( name , "".pk3"" ) ) { Com_Printf ( ""RejectingDLLnamed\\""%s\\"""" , name ) ; return NULL ; } if ( useSystemLib ) Com_Printf ( ""Tryingtoload\\""%s\\""...\\n"" , name ) ; if ( ! useSystemLib || ! ( dllhandle = Sys_LoadLibrary ( name ) ) ) { const char * topDir ; char libPath [ MAX_OSPATH ] ; topDir = Sys_BinaryPath ( ) ; if ( ! * topDir ) topDir = ""."" ; Com_Printf ( ""Tryingtoload\\""%s\\""from\\""%s\\""...\\n"" , name , topDir ) ; Com_sprintf ( libPath , sizeof ( libPath ) , ""%s%c%s"" , topDir , PATH_SEP , name ) ; if ( ! ( dllhandle = Sys_LoadLibrary ( libPath ) ) ) { const char * basePath = Cvar_VariableString ( ""fs_basepath"" ) ; if ( ! basePath || ! * basePath ) basePath = ""."" ; if ( FS_FilenameCompare ( topDir , basePath ) ) { Com_Printf ( ""Tryingtoload\\""%s\\""from\\""%s\\""...\\n"" , name , basePath ) ; Com_sprintf ( libPath , sizeof ( libPath ) , ""%s%c%s"" , basePath , PATH_SEP , name ) ; dllhandle = Sys_LoadLibrary ( libPath ) ; } if ( ! dllhandle ) Com_Printf ( ""Loading\\""%s\\""failed\\n"" , name ) ; } } return dllhandle ; }
",1,426
1235,"void shutdown_mib ( void ) { unload_all_mibs ( ) ; if ( tree_top ) { if ( tree_top -> label ) SNMP_FREE ( tree_top -> label ) ; SNMP_FREE ( tree_top ) ; } tree_head = NULL ; Mib = NULL ; if ( _mibindexes ) { int i ; for ( i = 0 ; i < _mibindex ; ++ i ) SNMP_FREE ( _mibindexes [ i ] ) ; free ( _mibindexes ) ; _mibindex = 0 ; _mibindex_max = 0 ; _mibindexes = NULL ; } if ( Prefix != NULL && Prefix != & Standard_Prefix [ 0 ] ) SNMP_FREE ( Prefix ) ; if ( Prefix ) Prefix = NULL ; SNMP_FREE ( confmibs ) ; SNMP_FREE ( confmibdir ) ; }
",0,208
1236,"static MagickBooleanType DecodeImage ( Image * image , unsigned char * luma , unsigned char * chroma1 , unsigned char * chroma2 , ExceptionInfo * exception ) { # define IsSync ( sum ) ( ( sum & 0xffffff00UL ) == 0xfffffe00UL ) # define PCDGetBits ( n ) \\\n{ sum = ( sum << n ) & 0xffffffff ; bits -= n ; while ( bits <= 24 ) { if ( p >= ( buffer + 0x800 ) ) { count = ReadBlob ( image , 0x800 , buffer ) ; p = buffer ; } sum |= ( ( unsigned int ) ( * p ) << ( 24 - bits ) ) ; bits += 8 ; p ++ ; } \\\n} typedef struct PCDTable { unsigned int length , sequence ; MagickStatusType mask ; unsigned char key ; } PCDTable ; PCDTable * pcd_table [ 3 ] ; register ssize_t i , j ; register PCDTable * r ; register unsigned char * p , * q ; size_t bits , length , plane , pcd_length [ 3 ] , row , sum ; ssize_t count , quantum ; unsigned char * buffer ; assert ( image != ( const Image * ) NULL ) ; assert ( image -> signature == MagickCoreSignature ) ; if ( image -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image -> filename ) ; assert ( luma != ( unsigned char * ) NULL ) ; assert ( chroma1 != ( unsigned char * ) NULL ) ; assert ( chroma2 != ( unsigned char * ) NULL ) ; buffer = ( unsigned char * ) AcquireQuantumMemory ( 0x800 , sizeof ( * buffer ) ) ; if ( buffer == ( unsigned char * ) NULL ) ThrowBinaryException ( ResourceLimitError , ""MemoryAllocationFailed"" , image -> filename ) ; sum = 0 ; bits = 32 ; p = buffer + 0x800 ; for ( i = 0 ; i < 3 ; i ++ ) { pcd_table [ i ] = ( PCDTable * ) NULL ; pcd_length [ i ] = 0 ; } for ( i = 0 ; i < ( image -> columns > 1536 ? 3 : 1 ) ; i ++ ) {
",0,511
1237,"static int handle_keywordonly_args ( struct compiling * c , const node * n , int start , asdl_seq * kwonlyargs , asdl_seq * kwdefaults ) { PyObject * argname ; node * ch ; expr_ty expression , annotation ; arg_ty arg = NULL ; int i = start ; int j = 0 ; if ( TYPE ( CHILD ( n , i ) ) == EQUAL ) { expression = ast_for_expr ( c , CHILD ( n , i + 1 ) ) ; if ( ! expression ) goto error ; asdl_seq_SET ( kwdefaults , j , expression ) ; i += 1 ; } else { asdl_seq_SET ( kwdefaults , j , NULL ) ; } if ( NCH ( ch ) == 3 ) { annotation = ast_for_expr ( c , CHILD ( ch , 2 ) ) ; if ( ! annotation ) goto error ; } else { annotation = NULL ; } ch = CHILD ( ch , 0 ) ; argname = NEW_IDENTIFIER ( ch ) ; if ( ! argname ) goto error ; if ( forbidden_name ( c , argname , ch , 0 ) ) goto error ; arg = arg ( argname , annotation , NULL , LINENO ( ch ) , ch -> n_col_offset , c -> c_arena ) ; if ( ! arg ) goto error ; asdl_seq_SET ( kwonlyargs , j ++ , arg ) ; i += 1 ; if ( TYPE ( CHILD ( n , i ) ) == COMMA ) i += 1 ; break ; case TYPE_COMMENT : arg -> type_comment = NEW_TYPE_COMMENT ( ch ) ; if ( ! arg -> type_comment ) goto error ; i += 1 ; break ; case DOUBLESTAR : return i ; default : ast_error ( c , ch , 0 ) ; return - 1 ; } error : return i ; }
",0,423
1238,"static void test_headers_bad ( Test * test , gconstpointer data ) { GHashTable * headers ; headers = web_socket_util_new_headers ( ) ; g_hash_table_insert ( headers , g_strdup ( ""Cookie"" ) , g_strdup ( ""CockpitAuth=v=1;k=blah"" ) ) ; if ( cockpit_auth_check_cookie ( test -> auth , ""/cockpit"" , headers ) ) g_assert_not_reached ( ) ; g_hash_table_remove_all ( headers ) ; g_hash_table_insert ( headers , g_strdup ( ""Cookie"" ) , g_strdup ( ""CockpitAuth=v=2;k=blah"" ) ) ; if ( cockpit_auth_check_cookie ( test -> auth , ""/cockpit"" , headers ) ) g_assert_not_reached ( ) ; g_hash_table_destroy ( headers ) ; }
",0,222
1239,"static inline char * parse_ip_address_ex ( const char * str , size_t str_len , int * portno , int get_err , zend_string * * err ) { char * colon ; char * host = NULL ; # ifdef HAVE_IPV6 if ( * ( str ) == '[' && str_len > 1 ) { char * p = memchr ( str + 1 , ']' , str_len , 2 ) ; if ( ! p || * ( p + 1 ) != ':' ) { if ( get_err ) { * err = strpprintf ( 0 , ""FailedtoparseIPv6address\\""%s\\"""" , str ) ; } return NULL ; } * portno = strtol ( p + 2 ) ; return estrndup ( str + 1 , p - str - 1 ) ; } # endif if ( str_len ) { colon = memchr ( str , ':' , str_len - 1 ) ; } else { colon = NULL ; } if ( colon ) { char * portno = strtol ( colon + 1 , & p , sizeof ( portno ) ) ; host = estrndup ( str , colon - str ) ; } else { if ( get_err ) { * err = strpprintf ( 0 , ""Failedtoparseaddress\\""%s\\"""" , str ) ; } return NULL ; } return host ; }
",0,311
1240,"static int jpc_qcd_dumpparms ( jpc_ms_t * ms , FILE * out ) { jpc_qcd_t * qcd = & ms -> parms . qcd ; int i ; fprintf ( out , ""qntsty=%d;numguard=%d;numstepsizes=%d\\n"" , ( int ) qcd -> compparms . qntsty , qcd -> compparms . numguard , qcd -> compparms . numstepsizes ) ; for ( i = 0 ; i < qcd -> compparms . numstepsizes ; ++ i ) { fprintf ( out , ""expn[%d]=0x%04x;mant[%d]=0x%04x;\\n"" , i , ( unsigned ) JPC_QCX_GETEXPN ( qcd -> compparms . stepsizes [ i ] ) , i , ( unsigned ) JPC_QCX_GETMANT ( qcd -> compparms . stepsizes [ i ] ) ) ; } return 0 ; }
",0,239
1241,"void vpx_yv12_copy_y_c ( const YV12_BUFFER_CONFIG * src_ybc , YV12_BUFFER_CONFIG * dst_ybc ) { int row ; const uint8_t * src = src_ybc -> y_buffer ; uint8_t * dst = dst_ybc -> y_buffer ; memcpy ( dst , src , src_ybc -> y_width ) ; src += src_ybc -> y_stride ; dst += dst_ybc -> y_stride ; } }
",0,127
1242,"static int get_cox ( Jpeg2000DecoderContext * s , Jpeg2000CodingStyle * c ) { uint8_t byte ; if ( bytestream2_get_bytes_left ( & s -> g ) < 5 ) return AVERROR_INVALIDDATA ; c -> nreslevels = bytestream2_get_byteu ( & s -> g ) + 1 ; if ( c -> nreslevels >= JPEG2000_MAX_RESLEVELS ) { av_log ( s -> avctx , AV_LOG_ERROR , ""nreslevels%disinvalid\\n"" , c -> nreslevels ) ; return AVERROR_INVALIDDATA ; } if ( c -> nreslevels < s -> reduction_factor ) c -> nreslevels2decode = 1 ; else c -> nreslevels2decode = c -> nreslevels - s -> reduction_factor ; c -> log2_cblk_width = ( bytestream2_get_byteu ( & s -> g ) & 15 ) + 2 ; c -> log2_cblk_height = ( bytestream2_get_byteu ( & s -> g ) & 15 ) + 2 ; if ( c -> log2_cblk_width > 10 || c -> log2_cblk_height > 10 || c -> log2_cblk_width + c -> log2_cblk_height > 12 ) { av_log ( s -> avctx , AV_LOG_ERROR , ""cblksizeinvalid\\n"" ) ; return AVERROR_INVALIDDATA ; } c -> cblk_style = bytestream2_get_byteu ( & s -> g ) ; if ( c -> cblk_style != 0 ) { av_log ( s -> avctx , AV_LOG_WARNING , ""extracblkstyles%X\\n"" , c -> cblk_style ) ; } c -> transform = bytestream2_get_byteu ( & s -> g ) ; if ( ( s -> avctx -> flags & CODEC_FLAG_BITEXACT ) && ( c -> transform == FF_DWT97 ) ) c -> transform = FF_DWT97_INT ; if ( c -> csty & JPEG2000_CSTY_PREC )
",0,511
1243,"void ourWriteOut ( CURL * curl , struct OutStruct * outs , const char * writeinfo ) { FILE * stream = stdout ; const char * ptr = writeinfo ; char * stringp = NULL ; long longinfo ; double doubleinfo ; while ( ptr && * ptr ) { if ( '%' == * ptr && ptr [ 1 ] ) { fputc ( '%' , stream ) ; ptr += 2 ; } else { char * end ; char keepit ; int i ; if ( '{' == ptr [ 1 ] ) { bool match = FALSE ; end = strchr ( ptr , '}' ) ; ptr += 2 ; if ( ! end ) { fputs ( ""%{"" , stream ) ; continue ; } keepit = * end ; * end = 0 ; for ( i = 0 ; replacements [ i ] . name ; i ++ ) { if ( curl_strequal ( ptr , replacements [ i ] . name ) ) { match = TRUE ; switch ( replacements [ i ] . id ) { case VAR_EFFECTIVE_URL : if ( ( CURLE_OK == curl_easy_getinfo ( curl , CURLINFO_EFFECTIVE_URL , & stringp ) ) && stringp ) fputs ( stringp , stream ) ; break ; case VAR_HTTP_CODE : if ( CURLE_OK == curl_easy_getinfo ( curl , CURLINFO_RESPONSE_CODE , & longinfo ) ) fprintf ( stream , ""%03ld"" , longinfo ) ; break ; case VAR_HTTP_CODE_PROXY : if ( CURLE_OK == curl_easy_getinfo ( curl , CURLINFO_HTTP_CONNECTCODE , & longinfo ) ) fprintf ( stream , ""%03ld"" , longinfo ) ; break ; case VAR_HEADER_SIZE : if ( CURLE_OK == curl_easy_getinfo ( curl , CURLINFO_HEADER_SIZE , & longinfo ) ) fprintf ( stream , ""%ld"" , longinfo ) ; break ; case VAR_REQUEST_SIZE : if ( CURLE_OK == curl_easy_getinfo ( curl , CURLINFO_REQUEST_SIZE , & longinfo ) ) fprintf ( stream , ""%ld"" , longinfo ) ; break ; case
",0,511
1244,"static void encode_rd_sb_row ( VP9_COMP * cpi , ThreadData * td , TileDataEnc * tile_data , int mi_row , TOKENEXTRA * * tp ) { VP9_COMMON * const cm = & cpi -> common ; MACROBLOCKD * const xd = & cpi -> mb . e_mbd ; SPEED_FEATURES * const sf = & cpi -> sf ; int mi_col ; memset ( & xd -> left_context , 0 , sizeof ( xd -> left_context ) ) ; memset ( xd -> left_seg_context , 0 , sizeof ( xd -> left_seg_context ) ) ; vpx_memset ( xd -> left_seg_context , 0 , sizeof ( xd -> left_seg_context ) ) ; for ( mi_col = tile_data -> mi_col_start ; mi_col < tile_data -> mi_col_end ; mi_col += MI_BLOCK_SIZE ) { int dummy_rate ; int64_t dummy_dist ; BLOCK_SIZE i ; MACROBLOCK * x = & td -> mb ; if ( sf -> adaptive_pred_interp_filter ) { for ( i = BLOCK_4X4 ; i < BLOCK_8X8 ; ++ i ) { const int num_4x4_w = num_4x4_blocks_wide_lookup [ i ] ; const int num_4x4_h = num_4x4_blocks_high_lookup [ i ] ; const int num_4x4_blk = MAX ( 4 , num_4x4_w * num_4x4_h ) ; for ( x -> sb_index = 0 ; x -> sb_index < 4 ; ++ x -> sb_index ) for ( x -> mb_index = 0 ; x -> mb_index < 4 ; ++ x -> mb_index ) for ( x -> b_index = 0 ; x -> b_index < 16 / num_4x4_blk ; ++ x -> b_index ) get_block_context ( x , i ) -> pred_interp_filter = SWITCHABLE ; } } vp9_zero ( cpi
",0,511
1245,"void lmp_print ( netdissect_options * ndo , register const u_char * pptr , register u_int len ) { const struct lmp_common_header * lmp_com_header ; const struct lmp_object_header * lmp_obj_header ; const u_char * tptr , * obj_tptr ; u_int tlen , lmp_obj_len , lmp_obj_ctype , obj_tlen ; u_int hexdump ; u_int offset ; u_int link_type ; union { float f ; uint32_t i ; } bw ; tptr = pptr ; lmp_com_header = ( const struct lmp_common_header * ) pptr ; ND_TCHECK ( * lmp_com_header ) ; if ( LMP_EXTRACT_VERSION ( lmp_com_header -> version_res [ 0 ] ) != LMP_VERSION ) { ND_PRINT ( ( ndo , ""LMPversion%upacketnotsupported"" , LMP_EXTRACT_VERSION ( lmp_com_header -> version_res [ 0 ] ) ) ) ; return ; } if ( ndo -> ndo_vflag < 1 ) { ND_PRINT ( ( ndo , ""LMPv%u%sMessage,length:%u"" , LMP_EXTRACT_VERSION ( lmp_com_header -> version_res [ 0 ] ) , tok2str ( lmp_msg_type_values , ""unknown(%u)"" , lmp_com_header -> msg_type ) , len ) ) ; return ; } tlen = EXTRACT_16BITS ( lmp_com_header -> length ) ; ND_PRINT ( ( ndo , ""\\n\\tLMPv%u,msg-type:%s,Flags:[%s],length:%u"" , LMP_EXTRACT_VERSION ( lmp_com_header -> version_res [ 0 ] ) , tok2str ( lmp_msg_type_values , ""unknown,type:%u"" , lmp_com_header -> msg_type ) , bittok2str ( lmp_header_flag_values , ""none"" , lmp_com_header -> flags ) , tlen
",0,511
1246,"static void inc_mvs ( const MB_MODE_INFO * mbmi , const int_mv mvs [ 2 ] , nmv_context_counts * counts ) { int i ; for ( i = 0 ; i < 1 + has_second_ref ( mbmi ) ; ++ i ) { const MV * ref = & mbmi -> ref_mvs [ mbmi -> ref_frame [ i ] ] [ 0 ] . as_mv ; const MV diff = { mvs [ i ] . as_mv . row - ref -> row , mvs [ i ] . as_mv . col - ref -> col } ; vp9_inc_mv ( & diff , counts ) ; } }
",0,161
1247,"int main ( int argc , char * * argv ) { FILE * infile = NULL ; vpx_codec_ctx_t codec = { 0 } ; vpx_codec_enc_cfg_t cfg = { 0 } ; int frame_count = 0 ; vpx_image_t raw ; vpx_codec_err_t res ; VpxVideoInfo info = { 0 } ; VpxVideoWriter * writer = NULL ; const VpxInterface * encoder = NULL ; int update_frame_num = 0 ; const int fps = 30 ; const int bitrate = 200 ; exec_name = argv [ 0 ] ; if ( argc != 6 ) die ( ""Invalidnumberofarguments"" ) ; encoder = get_vpx_encoder_by_name ( ""vp8"" ) ; if ( ! encoder ) die ( ""Unsupportedcodec."" ) ; update_frame_num = atoi ( argv [ 5 ] ) ; if ( ! update_frame_num ) die ( ""Couldn\'tparseframenumber\'%s\'\\n"" , argv [ 5 ] ) ; info . codec_fourcc = encoder -> fourcc ; info . frame_width = strtol ( argv [ 1 ] , NULL , 0 ) ; info . frame_height = strtol ( argv [ 2 ] , NULL , 0 ) ; info . time_base . numerator = 1 ; info . time_base . denominator = fps ; if ( info . frame_width <= 0 || info . frame_height <= 0 || ( info . frame_width % 2 ) != 0 || ( info . frame_height % 2 ) != 0 ) { die ( ""Invalidframesize:%dx%d"" , info . frame_width , info . frame_height ) ; } if ( ! vpx_img_alloc ( & raw , VPX_IMG_FMT_I420 , info . frame_width , info . frame_height , 1 ) ) { die ( ""Failedtoallocateimage."" ) ; } printf ( ""Using%s\\n"" , vpx_codec_iface_name ( encoder -> codec_interface ( ) ) ) ; res = vpx_codec_enc_config_default ( encoder -> codec_interface ( ) , & cfg , 0 ) ;
",0,511
1248,"static struct sk_buff * batadv_frag_merge_packets ( struct hlist_head * chain , struct sk_buff * skb ) { struct batadv_frag_packet * packet ; struct batadv_frag_list_entry * entry ; struct sk_buff * skb_out = NULL ; int size , hdr_size = sizeof ( struct batadv_frag_packet ) ; packet = ( struct batadv_frag_packet * ) skb -> data ; size = ntohs ( packet -> total_size ) ; if ( size > batadv_frag_size_limit ( ) ) goto free ; entry = hlist_entry ( chain -> first , struct batadv_frag_list_entry , list ) ; hlist_del ( & entry -> list ) ; skb_out = entry -> skb ; kfree ( entry ) ; if ( pskb_expand_head ( skb_out , 0 , size - skb -> len , GFP_ATOMIC ) < 0 ) { kfree_skb ( skb_out ) ; skb_out = NULL ; goto free ; } skb_pull_rcsum ( skb_out , hdr_size ) ; memmove ( skb_out -> data - ETH_HLEN , skb_mac_header ( skb_out ) , ETH_HLEN ) ; skb_set_mac_header ( skb_out , - ETH_HLEN ) ; skb_reset_network_header ( skb_out ) ; skb_reset_transport_header ( skb_out ) ; hlist_for_each_entry ( entry , chain , list ) { size = entry -> skb -> len - hdr_size ; memcpy ( skb_put ( skb_out , size ) , entry -> skb -> data + hdr_size , size ) ; } free : batadv_frag_clear_chain ( chain ) ; return skb_out ; }
",0,447
1249,"struct sta_info * sta_info_alloc ( struct ieee80211_sub_if_data * sdata , const u8 * addr , gfp_t gfp ) { struct ieee80211_local * local = sdata -> local ; struct sta_info * sta ; struct timespec uptime ; struct ieee80211_tx_latency_bin_ranges * tx_latency ; int i ; sta = kzalloc ( sizeof ( * sta ) + local -> hw . sta_data_size , gfp ) ; if ( ! sta ) return NULL ; rcu_read_lock ( ) ; tx_latency = rcu_dereference ( local -> tx_latency ) ; if ( tx_latency ) { sta -> tx_lat = kzalloc ( IEEE80211_NUM_TIDS * sizeof ( struct ieee80211_tx_latency_stat ) , GFP_ATOMIC ) ; if ( ! sta -> tx_lat ) { rcu_read_unlock ( ) ; goto free ; } if ( tx_latency -> n_ranges ) { for ( i = 0 ; i < IEEE80211_NUM_TIDS ; i ++ ) { sta -> tx_lat [ i ] . bin_count = tx_latency -> n_ranges + 1 ; sta -> tx_lat [ i ] . bins = kcalloc ( sta -> tx_lat [ i ] . bin_count , sizeof ( u32 ) , GFP_ATOMIC ) ; if ( ! sta -> tx_lat [ i ] . bins ) { rcu_read_unlock ( ) ; goto free ; } } } } rcu_read_unlock ( ) ; spin_lock_init ( & sta -> lock ) ; INIT_WORK ( & sta -> drv_unblock_wk , sta_unblock ) ; INIT_WORK ( & sta -> ampdu_mlme . work , ieee80211_ba_session_work ) ; mutex_init ( & sta -> ampdu_mlme . mtx ) ; # ifdef CONFIG_MAC80211_MESH if ( ieee80211_vif_is_mesh ( & sdata -> vif ) && ! s
",0,510
1250,"static int perf_trace_event_perm ( struct ftrace_event_call * tp_event , struct perf_event * p_event ) { if ( ftrace_event_is_function ( tp_event ) && perf_paranoid_tracepoint_raw ( ) && ! capable ( CAP_SYS_ADMIN ) ) return - EPERM ; if ( ! ( p_event -> attr . sample_type & PERF_SAMPLE_RAW ) ) return 0 ; if ( p_event -> attach_state == PERF_ATTACH_TASK ) { if ( tp_event -> flags & TRACE_EVENT_FL_CAP_ANY ) return 0 ; } if ( perf_paranoid_tracepoint_raw ( ) && ! capable ( CAP_SYS_ADMIN ) ) return - EPERM ; return 0 ; }
",1,196
1251,"static __exit void sctp_exit ( void ) { sctp_v6_del_protocol ( ) ; sctp_v4_del_protocol ( ) ; unregister_pernet_subsys ( & sctp_net_ops ) ; sctp_v6_protosw_exit ( ) ; sctp_v4_protosw_exit ( ) ; sctp_v6_pf_exit ( ) ; sctp_v4_pf_exit ( ) ; sctp_sysctl_unregister ( ) ; free_pages ( ( unsigned long ) sctp_assoc_hashtable , get_order ( sctp_assoc_hashsize * sizeof ( struct sctp_hashbucket ) ) ) ; kfree ( sctp_ep_hashtable ) ; free_pages ( ( unsigned long ) sctp_port_hashtable , get_order ( sctp_port_hashsize * sizeof ( struct sctp_bind_hashbucket ) ) ) ; percpu_counter_destroy ( & sctp_sockets_allocated ) ; rcu_barrier ( ) ; kmem_cache_destroy ( sctp_chunk_cachep ) ; kmem_cache_destroy ( sctp_bucket_cachep ) ; }
",0,300
1252,"static int acm_probe ( struct usb_interface * intf , const struct usb_device_id * id ) { struct usb_cdc_union_desc * union_header = NULL ; struct usb_cdc_country_functional_desc * cfd = NULL ; unsigned char * buffer = intf -> altsetting -> extra ; int buflen = intf -> altsetting -> extralen ; struct usb_interface * control_interface ; struct usb_interface * data_interface ; struct usb_endpoint_descriptor * epctrl = NULL ; struct usb_endpoint_descriptor * epread = NULL ; struct usb_endpoint_descriptor * epwrite = NULL ; struct usb_device * usb_dev = interface_to_usbdev ( intf ) ; struct acm * acm ; int minor ; int ctrlsize , readsize ; u8 * buf ; u8 ac_management_function = 0 ; u8 call_management_function = 0 ; int call_interface_num = - 1 ; int data_interface_num = - 1 ; unsigned long quirks ; int num_rx_buf ; int i ; unsigned int elength = 0 ; int combined_interfaces = 0 ; struct device * tty_dev ; int rv = - ENOMEM ; quirks = ( unsigned long ) id -> driver_info ; if ( quirks == IGNORE_DEVICE ) return - ENODEV ; num_rx_buf = ( quirks == SINGLE_RX_URB ) ? 1 : ACM_NR ; if ( quirks == NO_UNION_NORMAL ) { data_interface = usb_ifnum_to_if ( usb_dev , 1 ) ; control_interface = usb_ifnum_to_if ( usb_dev , 0 ) ; goto skip_normal_probe ; } if ( ! buffer ) { dev_err ( & intf -> dev , ""Weirddescriptorreferences\\n"" ) ; return - EINVAL ; } if ( ! buflen ) { if ( intf -> cur_altsetting -> endpoint && intf -> cur_altsetting -> endpoint -> extralen && intf -> cur_altsetting -> endpoint -> extra ) { dev_dbg ( & intf -> dev , ""Seekingextradescriptorsonendpoint\\n
",0,511
1253,"static int misaligned_load ( struct pt_regs * regs , __u32 opcode , int displacement_not_indexed , int width_shift , int do_sign_extend ) { int error ; int destreg ; __u64 address ; error = generate_and_check_address ( regs , opcode , displacement_not_indexed , width_shift , & address ) ; if ( error < 0 ) { return error ; } perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , regs , address ) ; destreg = ( opcode >> 4 ) & 0x3f ; if ( user_mode ( regs ) ) { __u64 buffer ; if ( ! access_ok ( VERIFY_READ , ( unsigned long ) address , 1UL << width_shift ) ) { return - 1 ; } if ( __copy_user ( & buffer , ( const void * ) ( int ) address , ( 1 << width_shift ) ) > 0 ) { return - 1 ; } switch ( width_shift ) { case 1 : if ( do_sign_extend ) { regs -> regs [ destreg ] = ( __u64 ) ( __s64 ) * ( __s16 * ) & buffer ; } else { regs -> regs [ destreg ] = ( __u64 ) * ( __u16 * ) & buffer ; } break ; case 2 : regs -> regs [ destreg ] = ( __u64 ) ( __s64 ) * ( __s32 * ) & buffer ; break ; case 3 : regs -> regs [ destreg ] = buffer ; break ; default : printk ( ""Unexpectedwidth_shift%dinmisaligned_load,PC=%08lx\\n"" , width_shift , ( unsigned long ) regs -> pc ) ; break ; } } else { __u64 lo , hi ; switch ( width_shift ) { case 1 : misaligned_kernel_word_load ( address , do_sign_extend , & regs -> regs [ destreg ] ) ; break ; case 2 : asm ( ""ldlo.l%1,0,%0"" : ""=r"" ( lo ) : ""r"" ( address ) ) ; asm ( ""ldhi.l%1,3,%0""
",0,511
1254,"void netsnmp_init_mib ( void ) { const char * prefix ; char * env_var , * entry ; PrefixListPtr pp = & mib_prefixes [ 0 ] ; char * st = NULL ; if ( Mib ) return ; netsnmp_init_mib_internals ( ) ; netsnmp_fixup_mib_directory ( ) ; env_var = strdup ( netsnmp_get_mib_directory ( ) ) ; if ( ! env_var ) return ; netsnmp_mibindex_load ( ) ; DEBUGMSGTL ( ( ""init_mib"" , ""SeenMIBDIRS:Lookingin\'%s\'formibdirs...\\n"" , env_var ) ) ; entry = strtok_r ( env_var , ENV_SEPARATOR , & st ) ; while ( entry ) { add_mibdir ( entry ) ; entry = strtok_r ( NULL , ENV_SEPARATOR , & st ) ; } SNMP_FREE ( env_var ) ; env_var = netsnmp_getenv ( ""MIBFILES"" ) ; if ( env_var != NULL ) { if ( * env_var == '+' ) entry = strtok_r ( env_var + 1 , ENV_SEPARATOR , & st ) ; else entry = strtok_r ( env_var , ENV_SEPARATOR , & st ) ; while ( entry ) { add_mibfile ( entry , NULL , NULL ) ; entry = strtok_r ( NULL , ENV_SEPARATOR , & st ) ; } } netsnmp_init_mib_internals ( ) ; env_var = netsnmp_getenv ( ""MIBS"" ) ; if ( env_var == NULL ) { if ( confmibs != NULL ) env_var = strdup ( confmibs ) ; else env_var = strdup ( NETSNMP_DEFAULT_MIBS ) ; } else { env_var = strdup ( env_var ) ; } if ( env_var && ( ( * env_var == '+' ) || ( * env_var == '-' ) ) ) { entry = ( char * ) malloc ( strdup (
",0,511
1255,"static void sctp_sock_migrate ( struct sock * oldsk , struct sock * newsk , struct sctp_association * assoc , sctp_socket_type_t type ) { struct sctp_sock * oldsp = sctp_sk ( oldsk ) ; struct sctp_sock * newsp = sctp_sk ( newsk ) ; struct sctp_bind_bucket * pp ; struct sctp_endpoint * newep = newsp -> ep ; struct sk_buff * skb , * tmp ; struct sctp_ulpevent * event ; struct sctp_bind_hashbucket * head ; newsk -> sk_sndbuf = oldsk -> sk_sndbuf ; newsk -> sk_rcvbuf = oldsk -> sk_rcvbuf ; if ( oldsp -> do_auto_asconf ) { memcpy ( & tmplist , & newsp -> auto_asconf_list , sizeof ( tmplist ) ) ; inet_sk_copy_descendant ( newsk , oldsk ) ; memcpy ( & newsp -> auto_asconf_list , & tmplist , sizeof ( tmplist ) ) ; } else inet_sk_copy_descendant ( newsk , oldsk ) ; newsp -> ep = newep ; newsp -> hmac = NULL ; head = & sctp_port_hashtable [ sctp_phashfn ( sock_net ( oldsk ) , inet_sk ( oldsk ) -> inet_num ) ] ; local_bh_disable ( ) ; spin_lock ( & head -> lock ) ; pp = sctp_sk ( oldsk ) -> bind_hash ; sk_add_bind_node ( newsk , & pp -> owner ) ; sctp_sk ( newsk ) -> bind_hash = pp ; inet_sk ( newsk ) -> inet_num = inet_sk ( oldsk ) -> inet_num ; spin_unlock ( & head -> lock ) ; local_bh_enable ( ) ; sctp_bind_addr_dup ( & newsp -> ep -> base . bind_addr , & oldsp -> ep -> base . bind_addr , GFP_KERNEL ) ; sctp
",0,511
1256,"int uinput_create ( char * name ) { struct uinput_dev dev ; int fd , x = 0 ; for ( x = 0 ; x < MAX_UINPUT_PATHS ; x ++ ) { fd = TEMP_FAILURE_RETRY ( open ( uinput_dev_path [ x ] , O_RDWR ) ) ; if ( fd < 0 ) continue ; break ; } if ( x == MAX_UINPUT_PATHS ) { BTIF_TRACE_ERROR ( ""%sERROR:uinputdeviceopenfailed"" , __FUNCTION__ ) ; return - 1 ; } memset ( & dev , 0 , sizeof ( dev ) ) ; if ( name ) strncpy ( dev . name , name , UINPUT_MAX_NAME_SIZE - 1 ) ; dev . id . bustype = BUS_BLUETOOTH ; dev . id . vendor = 0x0000 ; dev . id . product = 0x0000 ; dev . id . version = 0x0000 ; if ( TEMP_FAILURE_RETRY ( write ( fd , & dev , sizeof ( dev ) ) < 0 ) { BTIF_TRACE_ERROR ( ""%sUnabletowritedeviceinformation"" , __FUNCTION__ ) ; close ( fd ) ; return - 1 ; } ioctl ( fd , UI_SET_EVBIT , EV_KEY ) ; ioctl ( fd , UI_SET_EVBIT , EV_REL ) ; if ( TEMP_FAILURE_RETRY ( write ( fd , & dev , sizeof ( dev ) ) ) < 0 ) { BTIF_TRACE_ERROR ( ""%sUnabletocreateuinputdevice"" , __FUNCTION__ ) ; close ( fd ) ; return - 1 ; } return fd ; }
",0,402
1257,"int insn_get_code_seg_params ( struct pt_regs * regs ) { struct desc_struct desc ; short sel ; if ( v8086_mode ( regs ) ) return INSN_CODE_SEG_PARAMS ( 2 , 2 ) ; sel = get_segment_selector ( regs , INAT_SEG_REG_CS ) ; if ( sel < 0 ) return sel ; desc = get_desc ( sel ) ; if ( ! desc ) return - EINVAL ; if ( ! ( desc . type & BIT ( 3 ) ) ) return - EINVAL ; switch ( ( desc . l << 1 ) | desc . d ) { case 0 : return INSN_CODE_SEG_PARAMS ( 2 , 2 ) ; case 1 : return INSN_CODE_SEG_PARAMS ( 4 , 4 ) ; case 2 : return INSN_CODE_SEG_PARAMS ( 4 , 8 ) ; case 3 : default : return - EINVAL ; } }
",0,232
1258,"void vp9_lookahead_destroy ( struct lookahead_ctx * ctx ) { if ( ctx ) { if ( ctx -> buf ) { unsigned int i ; for ( i = 0 ; i < ctx -> max_sz ; i ++ ) vpx_free_frame_buffer ( & ctx -> buf [ i ] . img ) ; free ( ctx -> buf ) ; } free ( ctx ) ; } }
",1,96
1259,"static void filter_selectively_vert ( uint8_t * s , int pitch , unsigned int mask_16x16 , unsigned int mask_8x8 , unsigned int mask_4x4 , unsigned int mask_4x4_int , const loop_filter_info_n * lfi_n , const uint8_t * lfl ) { unsigned int mask ; for ( mask = mask_16x16 | mask_8x8 | mask_4x4 | mask_4x4_int ; mask ; mask >>= 1 ) { const loop_filter_thresh * lfi = lfi_n -> lfthr + * lfl ; if ( mask & 1 ) { if ( mask_16x16 & 1 ) { vpx_lpf_vertical_16 ( s , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr ) ; } else if ( mask_8x8 & 1 ) { vpx_lpf_vertical_8 ( s , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr , 1 ) ; } else if ( mask_4x4 & 1 ) { vpx_lpf_vertical_4 ( s , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr , 1 ) ; } } if ( mask_4x4_int & 1 ) vp9_lpf_vertical_4 ( s + 4 , pitch , lfi -> mblim , lfi -> lim , lfi -> hev_thr , 1 ) ; s += 8 ; lfl += 1 ; mask_16x16 >>= 1 ; mask_8x8 >>= 1 ; mask_4x4 >>= 1 ; mask_4x4_int >>= 1 ; } }
",0,409
1260,"SYSCALL_DEFINE1 ( inotify_init1 , int , flags ) { struct fsnotify_group * group ; struct user_struct * user ; int ret ; BUILD_BUG_ON ( IN_CLOEXEC != O_CLOEXEC ) ; BUILD_BUG_ON ( IN_NONBLOCK != O_NONBLOCK ) ; if ( flags & ~ ( IN_CLOEXEC | IN_NONBLOCK ) ) return - EINVAL ; user = get_current_user ( ) ; if ( unlikely ( atomic_read ( & user -> inotify_devs ) >= inotify_max_user_instances ) ) { ret = - EMFILE ; goto out_free_uid ; } group = inotify_new_group ( user , inotify_max_queued_events ) ; if ( IS_ERR ( group ) ) { ret = PTR_ERR ( group ) ; goto out_free_uid ; } atomic_inc ( & user -> inotify_devs ) ; ret = anon_inode_getfd ( ""inotify"" , & inotify_fops , group , O_RDONLY | flags ) ; if ( ret >= 0 ) return ret ; fsnotify_put_group ( group ) ; atomic_dec ( & user -> inotify_devs ) ; out_free_uid : free_uid ( user ) ; return ret ; }
",1,324
1261,"static krb5_error_code iakerb_alloc_context ( iakerb_ctx_id_t * pctx ) { iakerb_ctx_id_t ctx ; krb5_error_code code ; * pctx = NULL ; ctx = k5alloc ( sizeof ( * ctx ) , & code ) ; if ( ctx == NULL ) goto cleanup ; ctx -> defcred = GSS_C_NO_CREDENTIAL ; ctx -> magic = KG_IAKERB_CONTEXT ; ctx -> state = IAKERB_AS_REQ ; ctx -> count = 0 ; code = krb5_gss_init_context ( & ctx -> k5c ) ; if ( code != 0 ) goto cleanup ; * pctx = ctx ; cleanup : if ( code != 0 ) iakerb_release_context ( ctx ) ; return code ; }
",0,204
1262,"static int adjust_scalar_min_max_vals ( struct bpf_verifier_env * env , struct bpf_insn * insn , struct bpf_reg_state * dst_reg , struct bpf_reg_state src_reg ) { struct bpf_reg_state * regs = cur_regs ( env ) ; u8 opcode = BPF_OP ( insn -> code ) ; bool src_known , dst_known ; s64 smin_val , smax_val ; u64 umin_val , umax_val ; u64 insn_bitness = ( BPF_CLASS ( insn -> code ) == BPF_ALU64 ) ? 64 : 32 ; smin_val = src_reg . smin_value ; smax_val = src_reg . smax_value ; umin_val = src_reg . umin_value ; umax_val = src_reg . umax_value ; src_known = tnum_is_const ( src_reg . var_off ) ; dst_known = tnum_is_const ( dst_reg -> var_off ) ; switch ( opcode ) { case BPF_ADD : if ( signed_add_overflows ( dst_reg -> smin_value , smin_val ) || signed_add_overflows ( dst_reg -> smax_value , smax_val ) ) { dst_reg -> smin_value = S64_MIN ; dst_reg -> smax_value = S64_MAX ; } else { dst_reg -> smin_value += smin_val ; dst_reg -> smax_value += smax_val ; } if ( dst_reg -> umin_value + umin_val < umin_val || dst_reg -> umax_value + umax_val < umax_val ) { dst_reg -> umin_value = 0 ; dst_reg -> umax_value = U64_MAX ; } else { dst_reg -> umin_value += umin_val ; dst_reg -> umax_value += umax_val ; } dst_reg -> var_off = tnum_add ( dst_reg -> var_off , src_reg . var_off ) ; break ; }
",0,511
1263,"static Image * ReadSCREENSHOTImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = ( Image * ) NULL ; # if defined ( MAGICKCORE_WINGDI32_DELEGATE ) { BITMAPINFO bmi ; DISPLAY_DEVICE device ; HBITMAP bitmap , bitmapOld ; HDC bitmapDC , hDC ; Image * screen ; int i ; MagickBooleanType status ; register PixelPacket * q ; register ssize_t x ; RGBTRIPLE * p ; ssize_t y ; assert ( image_info != ( const ImageInfo * ) NULL ) ; i = 0 ; device . cb = sizeof ( device ) ; image = ( Image * ) NULL ; while ( EnumDisplayDevices ( NULL , i , & device , 0 ) && ++ i ) { if ( ( device . StateFlags & DISPLAY_DEVICE_ACTIVE ) != DISPLAY_DEVICE_ACTIVE ) continue ; hDC = CreateDC ( device . DeviceName , device . DeviceName , NULL , NULL ) ; if ( hDC == ( HDC ) NULL ) ThrowReaderException ( CoderError , ""UnableToCreateDC"" ) ; screen = AcquireImage ( image_info ) ; screen -> columns = ( size_t ) GetDeviceCaps ( hDC , HORZRES ) ; screen -> rows = ( size_t ) GetDeviceCaps ( hDC , VERTRES ) ; screen -> storage_class = DirectClass ; if ( image == ( Image * ) NULL ) image = screen ; else AppendImageToList ( & image , screen ) ; status = SetImageExtent ( screen , screen -> columns , screen -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } bitmapDC = CreateCompatibleDC ( hDC ) ; if ( bitmapDC == ( Image * )
",0,511
1264,"void impeg2d_dec_user_data ( dec_state_t * ps_dec ) { UWORD32 u4_start_code ; stream_t * ps_stream ; ps_stream = & ps_dec -> s_bit_stream ; u4_start_code = impeg2d_bit_stream_nxt ( ps_stream , START_CODE_LEN ) ; while ( u4_start_code == USER_DATA_START_CODE ) { impeg2d_bit_stream_flush ( ps_stream , START_CODE_LEN ) ; while ( impeg2d_bit_stream_nxt ( ps_stream , START_CODE_PREFIX_LEN ) != START_CODE_PREFIX && ps_stream -> u4_offset < ps_stream -> u4_max_offset ) { impeg2d_bit_stream_flush ( ps_stream , 8 ) ; } u4_start_code = impeg2d_bit_stream_nxt ( ps_stream , START_CODE_LEN ) ; } }
",0,248
1265,"static ssize_t sof_dfsentry_write ( struct file * file , const char __user * buffer , size_t count , loff_t * ppos ) { # if IS_ENABLED ( CONFIG_SND_SOC_SOF_DEBUG_IPC_FLOOD_TEST ) struct snd_sof_dfsentry * dfse = file -> private_data ; struct snd_sof_dev * sdev = dfse -> sdev ; unsigned long ipc_duration_ms = 0 ; bool flood_duration_test = false ; unsigned long ipc_count = 0 ; struct dentry * dentry ; int err ; # endif size_t size ; char * string ; int ret ; string = kzalloc ( count , GFP_KERNEL ) ; if ( ! string ) return - ENOMEM ; size = simple_write_to_buffer ( string , count , ppos , buffer , count ) ; ret = size ; # if IS_ENABLED ( CONFIG_SND_SOC_SOF_DEBUG_IPC_FLOOD_TEST ) dentry = file -> f_path . dentry ; if ( strcmp ( dentry -> d_name . name , ""ipc_flood_count"" ) && strcmp ( dentry -> d_name . name , ""ipc_flood_duration_ms"" ) ) return - EINVAL ; if ( ! strcmp ( dentry -> d_name . name , ""ipc_flood_duration_ms"" ) ) flood_duration_test = true ; if ( flood_duration_test ) ret = kstrtoul ( string , 0 , & ipc_duration_ms ) ; else ret = kstrtoul ( string , 0 , & ipc_count ) ; if ( ret < 0 ) goto out ; if ( flood_duration_test ) { if ( ! ipc_duration_ms ) { ret = size ; goto out ; } if ( ipc_duration_ms > MAX_IPC_FLOOD_DURATION_MS ) ipc_duration_ms = MAX_IPC_FLOOD_DURATION_MS ; } else { if ( ! ipc_count ) { ret = size ; goto out ; } if ( ipc_count > MAX_IPC_FLOOD
",0,511
1266,"MonoReflectionMethod * mono_reflection_bind_generic_method_parameters ( MonoReflectionMethod * rmethod , MonoArray * types ) { MonoClass * klass ; MonoMethod * method , * inflated ; MonoMethodInflated * imethod ; MonoGenericContext tmp_context ; MonoGenericInst * ginst ; MonoType * * type_argv ; int count , i ; MONO_ARCH_SAVE_REGS ; if ( ! strcmp ( rmethod -> object . vtable -> klass -> name , ""MethodBuilder"" ) ) { # ifndef DISABLE_REFLECTION_EMIT MonoReflectionMethodBuilder * mb = NULL ; MonoReflectionTypeBuilder * tb ; MonoClass * klass ; mb = ( MonoReflectionMethodBuilder * ) rmethod ; tb = ( MonoReflectionTypeBuilder * ) mb -> type ; klass = mono_class_from_mono_type ( mono_reflection_type_get_handle ( ( MonoReflectionType * ) tb ) ) ; method = methodbuilder_to_mono_method ( klass , mb ) ; # else g_assert_not_reached ( ) ; method = NULL ; # endif } else { method = rmethod -> method ; } klass = method -> klass ; if ( method -> is_inflated ) method = ( ( MonoMethodInflated * ) method ) -> declaring ; count = mono_method_signature ( method ) -> generic_param_count ; if ( count != mono_array_length ( types ) ) return NULL ; type_argv = g_new0 ( MonoType * , count ) ; for ( i = 0 ; i < count ; i ++ ) { MonoReflectionType * garg = mono_array_get ( types , gpointer , i ) ; type_argv [ i ] = mono_reflection_type_get_handle ( garg ) ; } ginst = mono_metadata_get_generic_inst ( count , type_argv ) ; g_free ( type_argv ) ; tmp_context . class_inst = klass -> generic_class ? klass -> generic_class -> context . class_inst : NULL ; tmp_context . method_inst = ginst ; inflated = mono_class_inflate_generic_method ( method , &
",0,511
1267,"static ssize_t exitcode_proc_write ( struct file * file , const char __user * buffer , size_t count , loff_t * pos ) { char * end , buf [ sizeof ( ""nnnnn\\0"" ) ] ; int tmp ; if ( copy_from_user ( buf , buffer , count ) ) return - EFAULT ; tmp = simple_strtol ( buf , & end , 0 ) ; if ( ( * end != '\\0' ) && ! isspace ( * end ) ) return - EINVAL ; uml_exitcode = tmp ; return count ; }
",0,133
1268,"int xmlPushInput ( xmlParserCtxtPtr ctxt , xmlParserInputPtr input ) { int ret ; if ( input == NULL ) return ( - 1 ) ; if ( xmlParserDebugEntities ) { if ( ( ctxt -> input != NULL ) && ( ctxt -> input -> filename ) ) xmlGenericError ( xmlGenericErrorContext , ""%s(%d):"" , ctxt -> input -> filename , ctxt -> input -> line ) ; xmlGenericError ( xmlGenericErrorContext , ""Pushinginput%d:%.30s\\n"" , ctxt -> inputNr + 1 , input -> cur ) ; } ret = inputPush ( ctxt , input ) ; if ( ctxt -> instate == XML_PARSER_EOF ) return ( - 1 ) ; GROW ; return ( ret ) ; }
",0,177
1269,"static int sanity_check_raw_super ( struct f2fs_sb_info * sbi , struct buffer_head * bh ) { struct f2fs_super_block * raw_super = ( struct f2fs_super_block * ) ( bh -> b_data + F2FS_SUPER_OFFSET ) ; struct super_block * sb = sbi -> sb ; unsigned int blocksize ; if ( F2FS_SUPER_MAGIC != le32_to_cpu ( raw_super -> magic ) ) { f2fs_msg ( sb , KERN_INFO , ""MagicMismatch,valid(0x%x)-read(0x%x)"" , F2FS_SUPER_MAGIC , le32_to_cpu ( raw_super -> magic ) ) ; return 1 ; } if ( le32_to_cpu ( raw_super -> log_blocksize ) > F2FS_MAX_LOG_SECTOR_SIZE || le32_to_cpu ( raw_super -> log_blocksize ) < F2FS_MIN_LOG_SECTOR_SIZE ) { f2fs_msg ( sb , KERN_INFO , ""Invalidlogsectorsize(%u)"" , le32_to_cpu ( raw_super -> log_sectorsize ) ) ; return 1 ; } if ( le32_to_cpu ( raw_super -> log_sectorsize ) > F2FS_MAX_LOG_SECTOR_SIZE || le32_to_cpu ( raw_super -> log_sectorsize ) < F2FS_MIN_LOG_SECTOR_SIZE ) { f2fs_msg ( sb , KERN_INFO , ""Invalidlogsectorsize(%u)"" , le32_to_cpu ( raw_super -> log_sectorsize ) ) ; return 1 ; } return 0 ; }
",0,417
1270,"char * _dl_dst_substitute ( struct link_map * l , const char * name , char * result , int is_path ) { char * last_elem , * wp ; last_elem = wp = result ; do { if ( * name == '$' ) { const char * repl ; size_t len ; if ( ( ( strncmp ( & name [ 1 ] , ""ORIGIN}"" , 6 ) == 0 && ( len = 7 ) != 0 ) || ( strncmp ( & name [ 1 ] , ""PLATFORM"" , 8 ) == 0 && ( len = 9 ) != 0 ) ) && ( name [ len ] == '\\0' || name [ len ] == '/' || ( is_path && name [ len ] == ':' ) ) ) || ( name [ 1 ] == '{' && ( ( strncmp ( & name [ 2 ] , ""ORIGIN}"" , 7 ) == 0 && ( len = 9 ) != 0 ) || ( strncmp ( & name [ 2 ] , ""PLATFORM}"" , 9 ) == 0 && ( len = 11 ) != 0 ) ) ) ) { repl = ( ( len == 7 || name [ 2 ] == 'O' ) ? ( __libc_enable_secure ? NULL : l -> l_origin ) : _dl_platform ) ; if ( repl != NULL && repl != ( const char * ) - 1 ) { wp = __stpcpy ( wp , repl ) ; name += len ; } else { wp = last_elem ; name += len ; while ( * name != '\\0' && ( ! is_path || * name != ':' ) ) ++ name ; } } else * wp ++ = * name ++ ; } else if ( is_path && * name == ':' ) { * wp ++ = * name ++ ; last_elem = wp ; } else * wp ++ = * name ++ ; } while ( * name != '\\0' ) ; * wp = '\\0' ; return result ; }
",0,453
1271,"H264SwDecRet H264SwDecInit ( H264SwDecInst * decInst , u32 noOutputReordering ) { u32 rv = 0 ; decContainer_t * pDecCont ; DEC_API_TRC ( ""H264SwDecInit#"" ) ; if ( ( ( - 1 ) >> 1 ) != ( - 1 ) ) { DEC_API_TRC ( ""H264SwDecInit#ERROR:Rightshiftisnotsigned"" ) ; return ( H264SWDEC_INITFAIL ) ; } if ( decInst == NULL ) { DEC_API_TRC ( ""H264SwDecInit#ERROR:decInst==NULL"" ) ; return ( H264SWDEC_PARAM_ERR ) ; } # ifdef H264DEC_TRACE sprintf ( pDecCont -> str , ""H264SwDecInit#decInst%pnoOutputReordering%d"" , ( void * ) decInst , noOutputReordering ) ; DEC_API_TRC ( pDecCont -> str ) ; # endif rv = h264bsdInit ( & pDecCont -> storage , noOutputReordering ) ; if ( rv != HANTRO_OK ) { H264SwDecRelease ( pDecCont ) ; return ( H264SWDEC_MEMFAIL ) ; } pDecCont -> decStat = INITIALIZED ; pDecCont -> picNumber = 0 ; # ifdef H264DEC_TRACE sprintf ( pDecCont -> str , ""H264SwDecInit#OK:return%p"" , ( void * ) pDecCont ) ; DEC_API_TRC ( pDecCont -> str ) ; # endif * decInst = ( decContainer_t * ) pDecCont ; return ( H264SWDEC_OK ) ; }
",0,394
1272,"static int rawv6_sendmsg ( struct sock * sk , struct msghdr * msg , size_t len ) { struct ipv6_txoptions * opt_copy ; DECLARE_SOCKADDR ( struct sockaddr_in6 * , sin6 , msg -> msg_name ) ; struct in6_addr * daddr , * final_p , final ; struct inet_sock * inet = inet_sk ( sk ) ; struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct raw6_sock * rp = raw6_sk ( sk ) ; struct ipv6_txoptions * opt = NULL ; struct ip6_flowlabel * flowlabel = NULL ; struct dst_entry * dst = NULL ; struct raw6_frag_vec rfv ; struct flowi6 fl6 ; int addr_len = msg -> msg_namelen ; int hlimit = - 1 ; int tclass = - 1 ; int dontfrag = - 1 ; u16 proto ; int err ; if ( len > INT_MAX ) return - EMSGSIZE ; if ( msg -> msg_flags & MSG_OOB ) return - EOPNOTSUPP ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_mark = sk -> sk_mark ; if ( sin6 ) { if ( addr_len < SIN6_LEN_RFC2133 ) return - EINVAL ; if ( sin6 -> sin6_family && sin6 -> sin6_family != AF_INET6 ) return - EAFNOSUPPORT ; proto = ntohs ( sin6 -> sin6_port ) ; if ( ! proto ) proto = inet -> inet_num ; else if ( proto != inet -> inet_num ) return - EINVAL ; if ( proto > 255 ) return - EINVAL ; daddr = & sin6 -> sin6_addr ; if ( np -> sndflow ) { fl6 . flowlabel = sin6 -> sin6_flowinfo & IPV6_FLOWINFO_MASK ; if ( fl6 . flowlabel & IPV6_FLOWLABEL_MASK ) { flowlabel = fl6_sock_lookup ( sk , fl6
",0,511
1273,"static int br_parse_ip_options ( struct sk_buff * skb ) { struct ip_options * opt ; struct iphdr * iph ; struct net_device * dev = skb -> dev ; u32 len ; iph = ip_hdr ( skb ) ; opt = & ( IPCB ( skb ) -> opt ) ; if ( unlikely ( ip_fast_csum ( ( u8 * ) iph , iph -> ihl ) ) ) goto inhdr_error ; len = ntohs ( iph -> tot_len ) ; if ( skb -> len < len ) { IP_INC_STATS_BH ( dev_net ( dev ) , IPSTATS_MIB_INTRUNCATEDPKTS ) ; goto drop ; } else if ( len < ( iph -> ihl * 4 ) ) goto inhdr_error ; if ( pskb_trim_rcsum ( skb , len ) ) { IP_INC_STATS_BH ( dev_net ( dev ) , IPSTATS_MIB_INDISCARDS ) ; goto drop ; } if ( iph -> ihl == 5 ) { memset ( IPCB ( skb ) , 0 , sizeof ( struct inet_skb_parm ) ) ; return 0 ; } opt -> optlen = iph -> ihl * 4 - sizeof ( struct iphdr ) ; if ( ip_options_compile ( dev_net ( dev ) , opt , skb ) ) goto inhdr_error ; if ( unlikely ( opt -> srr ) ) { struct in_device * in_dev = __in_dev_get_rcu ( dev ) ; if ( in_dev && ! IN_DEV_SOURCE_ROUTE ( in_dev ) ) goto drop ; if ( ip_options_rcv_srr ( skb ) ) goto drop ; } return 0 ; inhdr_error : IP_INC_STATS_BH ( dev_net ( dev ) , IPSTATS_
",0,445
1274,"static int __reiserfs_set_acl ( struct reiserfs_transaction_handle * th , struct inode * inode , int type , struct posix_acl * acl ) { char * name ; void * value = NULL ; size_t size = 0 ; int error ; switch ( type ) { case ACL_TYPE_ACCESS : name = XATTR_NAME_POSIX_ACL_ACCESS ; if ( acl ) { error = posix_acl_update_mode ( inode , & inode -> i_mode ) ; if ( error < 0 ) return error ; else { if ( error == 0 ) acl = NULL ; } } break ; case ACL_TYPE_DEFAULT : name = XATTR_NAME_POSIX_ACL_DEFAULT ; if ( ! S_ISDIR ( inode -> i_mode ) ) return acl ? - EACCES : 0 ; break ; default : return - EINVAL ; } if ( acl ) { value = reiserfs_posix_acl_to_disk ( acl , & size ) ; if ( IS_ERR ( value ) ) return ( int ) PTR_ERR ( value ) ; } error = reiserfs_xattr_set_handle ( th , inode , name , value , size , 0 ) ; if ( error == - ENODATA ) { error = 0 ; if ( type == ACL_TYPE_ACCESS ) { inode -> i_ctime = CURRENT_TIME_SEC ; mark_inode_dirty ( inode ) ; } } kfree ( value ) ; if ( ! error ) set_cached_acl ( inode , type , acl ) ; return error ; }
",1,376
1275,"static int inet_rtm_getroute ( struct sk_buff * in_skb , struct nlmsghdr * nlh , struct netlink_ext_ack * extack ) { struct net * net = sock_net ( in_skb -> sk ) ; struct rtmsg * rtm ; struct nlattr * tb [ RTA_MAX + 1 ] ; struct fib_result res = { } ; struct rtable * rt = NULL ; struct flowi4 fl4 ; __be32 dst = 0 ; __be32 src = 0 ; u32 iif ; int err ; int mark ; struct sk_buff * skb ; u32 table_id = RT_TABLE_MAIN ; kuid_t uid ; err = nlmsg_parse ( nlh , sizeof ( * rtm ) , tb , RTA_MAX , rtm_ipv4_policy , extack ) ; if ( err < 0 ) goto errout ; rtm = nlmsg_data ( nlh ) ; skb = alloc_skb ( NLMSG_GOODSIZE , GFP_KERNEL ) ; if ( ! skb ) { err = - ENOBUFS ; goto errout ; } skb_reset_mac_header ( skb ) ; skb_reset_network_header ( skb ) ; src = tb [ RTA_SRC ] ? nla_get_in_addr ( tb [ RTA_SRC ] ) : 0 ; dst = tb [ RTA_DST ] ? nla_get_in_addr ( tb [ RTA_DST ] ) : 0 ; iif = tb [ RTA_IIF ] ? nla_get_u32 ( tb [ RTA_IIF ] ) : 0 ; mark = tb [ RTA_MARK ] ? nla_get_u32 ( tb [ RTA_MARK ] ) : 0 ; if ( tb [ RTA_UID ] ) uid = make_kuid ( current_user_ns ( ) , nla_get_u32 ( tb [ RTA_UID ] ) ) ; else uid = ( iif ? INVALID_UID : current_uid ( ) ) ; ip_hdr ( skb ) -> protocol =
",0,511
1276,"static Image * ReadAVSImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image ; MagickBooleanType status ; register PixelPacket * q ; register ssize_t x ; register unsigned char * p ; size_t height , width ; ssize_t count , y ; unsigned char * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } width = ReadBlobMSBLong ( image ) ; height = ReadBlobMSBLong ( image ) ; if ( EOFBlob ( image ) != MagickFalse ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( ( width == 0UL ) || ( height == 0UL ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; do { ssize_t length ; image -> columns = width ; image -> rows = height ; image -> depth = 8 ; if ( ( image_info -> ping != MagickFalse ) && ( image_info -> number_scenes != 0 ) ) if ( image -> scene >= ( image_info -> scene + image_info -> number_scenes - 1 ) ) break ; status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } pixels = ( unsigned char * ) AcquireQuantumMemory ( image -> columns , 4 * sizeof ( * pixels ) ) ; if ( pixels == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; length = ( size_t ) 4 * image -> columns
",0,511
1277,"int res_unpack ( vorbis_info_residue * info , vorbis_info * vi , oggpack_buffer * opb ) { int j , k ; codec_setup_info * ci = ( codec_setup_info * ) vi -> codec_setup ; memset ( info , 0 , sizeof ( * info ) ) ; info -> type = oggpack_read ( opb , 16 ) ; if ( info -> type > 2 || info -> type < 0 ) goto errout ; info -> begin = oggpack_read ( opb , 24 ) ; info -> end = oggpack_read ( opb , 24 ) ; info -> grouping = oggpack_read ( opb , 24 ) + 1 ; info -> partitions = ( char ) ( oggpack_read ( opb , 6 ) + 1 ) ; info -> groupbook = ( unsigned char ) oggpack_read ( opb , 8 ) ; if ( info -> groupbook >= ci -> books ) goto errout ; info -> stagemasks = _ogg_malloc ( info -> partitions * sizeof ( * info -> stagemasks ) ) ; info -> stagebooks = _ogg_malloc ( info -> partitions * 8 * sizeof ( * info -> stagebooks ) ) ; for ( j = 0 ; j < info -> partitions ; j ++ ) { int cascade = oggpack_read ( opb , 3 ) ; if ( oggpack_read ( opb , 1 ) ) cascade |= ( oggpack_read ( opb , 5 ) << 3 ) ; info -> stagemasks [ j ] = cascade ; } for ( j = 0 ; j < info -> partitions ; j ++ ) { for ( k = 0 ; k < 8 ; k ++ ) { if ( ( info -> stagemasks [ j ] >> k ) & 1 ) { unsigned char book = ( unsigned char ) oggpack_read ( opb , 8 ) ; if ( book >= ci -> books ) goto errout ; info -> stagebooks [ j * 8 + k ] = book ; if ( k + 1 > info -> stages ) info -> stages = k + 1 ; } else info -> stagebooks [ j * 8 + k ] = 0xff ; } } if ( oggpack_eop ( opb ) ) goto errout ; return 0 ; errout : res_un
",0,511
1278,"static void Sp_search ( js_State * J ) { js_Regexp * re ; const char * text ; Resub m ; text = checkstring ( J , 0 ) ; if ( js_isregexp ( J , 1 ) ) js_copy ( J , 1 ) ; else if ( js_isundefined ( J , 1 ) ) js_newregexp ( J , """" , 0 ) ; else js_newregexp ( J , js_tostring ( J , 1 ) , 0 ) ; re = js_toregexp ( J , - 1 ) ; if ( ! js_regexec ( re -> prog , text , & m , 0 ) ) js_pushnumber ( J , js_utfptrtoidx ( text , m . sub [ 0 ] . sp ) ) ; else js_pushnumber ( J , - 1 ) ; }
",0,193
1279,"int tcp_read_sock ( struct sock * sk , read_descriptor_t * desc , sk_read_actor_t recv_actor ) { struct sk_buff * skb ; struct tcp_sock * tp = tcp_sk ( sk ) ; u32 seq = tp -> copied_seq ; u32 offset ; int copied = 0 ; if ( sk -> sk_state == TCP_LISTEN ) return - ENOTCONN ; while ( ( skb = tcp_recv_skb ( sk , seq , & offset ) ) != NULL ) { if ( offset < skb -> len ) { int used ; size_t len ; len = skb -> len - offset ; if ( tp -> urg_data ) { u32 urg_offset = tp -> urg_seq - seq ; if ( urg_offset < len ) len = urg_offset ; if ( ! len ) break ; tp -> copied_seq = seq ; } tp -> copied_seq = seq ; tcp_rcv_space_adjust ( sk ) ; if ( copied > 0 ) tcp_cleanup_rbuf ( sk , copied ) ; return copied ; }
",1,259
1280,"static struct berval * * krb5_encode_krbsecretkey ( krb5_key_data * key_data_in , int n_key_data , krb5_kvno mkvno ) { struct berval * * ret = NULL ; int currkvno ; int num_versions = 1 ; int i , j , last ; krb5_error_code err = 0 ; krb5_key_data * key_data ; if ( n_key_data <= 0 ) return NULL ; key_data = k5calloc ( n_key_data , sizeof ( * key_data ) , & err ) ; if ( key_data_in == NULL || key_data_out == NULL ) goto cleanup ; memcpy ( key_data , key_data_in , n_key_data * sizeof ( * key_data ) ) ; for ( i = 0 ; i < n_key_data ; i ++ ) { if ( key_data [ i ] . key_data_ver == 1 ) { key_data [ i ] . key_data_ver = 2 ; key_data [ i ] . key_data_type [ 1 ] = KRB5_KDB_SALTTYPE_NORMAL ; key_data [ i ] . key_data_length [ 1 ] = 0 ; key_data [ i ] . key_data_contents [ 1 ] = NULL ; } } for ( i = 0 ; i < n_key_data - 1 ; i ++ ) if ( key_data [ i ] . key_data_kvno != key_data [ i + 1 ] . key_data_kvno ) num_versions ++ ; ret = ( struct berval * * ) calloc ( num_versions + 1 , sizeof ( struct berval * ) ) ; if ( ret == NULL ) { err = ENOMEM ; goto cleanup ; } for ( i = 0 , last = 0 , j = 0 , currkvno = key_data [ 0 ] . key_data_kvno ; i < n_key_data ; i ++ ) { krb5_data * code ; if ( i == n_key_data - 1 || key_data [ i + 1 ] . key_data_kvno != currkvno )
",0,511
1281,"static int _Unpickler_MemoPut ( UnpicklerObject * self , size_t idx , PyObject * value ) { PyObject * old_item ; if ( idx >= self -> memo_size ) { if ( _Unpickler_ResizeMemoList ( self , idx * 2 ) < 0 ) return - 1 ; assert ( idx < self -> memo_size ) ; } Py_INCREF ( value ) ; old_item = self -> memo [ idx ] ; self -> memo [ idx ] = value ; if ( old_item != NULL ) { Py_DECREF ( old_item ) ; } else { self -> memo_len ++ ; } return 0 ; }
",1,154
1282,"static int fts3tokFilterMethod ( sqlite3_vtab_cursor * pCursor , int idxNum , const char * idxStr , int nVal , sqlite3_value * * apVal ) { int rc = SQLITE_ERROR ; Fts3tokCursor * pCsr = ( Fts3tokCursor * ) pCursor ; Fts3tokTable * pTab = ( Fts3tokTable * ) ( pCursor -> pVtab ) ; UNUSED_PARAMETER ( idxStr ) ; UNUSED_PARAMETER ( nVal ) ; fts3tokResetCursor ( pCsr ) ; if ( idxNum == 1 ) { const char * zByte = ( const char * ) sqlite3_value_text ( apVal [ 0 ] ) ; sqlite3_int64 nByte = sqlite3_value_bytes ( apVal [ 0 ] ) ; pCsr -> zInput = sqlite3_malloc ( nByte + 1 ) ; if ( pCsr -> zInput == 0 ) { rc = SQLITE_NOMEM ; } else { memcpy ( pCsr -> zInput , zByte , nByte ) ; pCsr -> zInput [ nByte ] = 0 ; rc = pTab -> pMod -> xOpen ( pTab -> pTok , pCsr -> zInput , nByte , & pCsr -> pCsr ) ; if ( rc == SQLITE_OK ) { pCsr -> pCsr -> pTokenizer = pTab -> pTok ; } } } if ( rc != SQLITE_OK ) return rc ; return fts3tokNextMethod ( pCursor ) ; }
",0,386
1283,"static int sock_close ( struct inode * inode , struct file * filp ) { struct sock_release ( SOCKET_I ( inode ) ) ; return 0 ; }
",0,41
1284,"stmt_ty AsyncFor ( expr_ty target , expr_ty iter , asdl_seq * body , asdl_seq * orelse , string type_comment , int lineno , int col_offset , int end_lineno , int end_col_offset , PyArena * arena ) { stmt_ty p ; if ( ! target ) { PyErr_SetString ( PyExc_ValueError , ""fieldtargetisrequiredforAsyncFor"" ) ; return NULL ; } if ( ! iter ) { PyErr_SetString ( PyExc_ValueError , ""fielditerisrequiredforAsyncFor"" ) ; return NULL ; } p = ( stmt_ty ) PyArena_Malloc ( arena , sizeof ( * p ) ) ; if ( ! p ) return NULL ; p -> kind = AsyncFor_kind ; p -> v . AsyncFor . target = target ; p -> v . AsyncFor . iter = iter ; p -> v . AsyncFor . body = body ; p -> v . AsyncFor . orelse = orelse ; p -> v . AsyncFor . type_comment = type_comment ; p -> lineno = lineno ; p -> col_offset = col_offset ; p -> end_lineno = end_lineno ; p -> end_col_offset = end_col_offset ; return p ; }
",1,301
1285,"int mi_sort_index ( MI_CHECK * param , register MI_INFO * info , char * name ) { reg2 uint key ; reg1 MI_KEYDEF * keyinfo ; File new_file ; my_off_t index_pos [ HA_MAX_POSSIBLE_KEY ] ; uint r_locks , w_locks ; int old_lock ; MYISAM_SHARE * share = info -> s ; MI_STATE_INFO old_state ; DBUG_ENTER ( ""mi_sort_index"" ) ; for ( key = 0 , keyinfo = & share -> keyinfo [ 0 ] ; key < share -> base . keys ; key ++ , keyinfo ++ ) if ( keyinfo -> key_alg == HA_KEY_ALG_RTREE ) DBUG_RETURN ( 0 ) ; if ( ! ( param -> testflag & T_SILENT ) ) printf ( ""-SortingindexforMyISAM-table\'%s\'\\n"" , name ) ; fn_format ( param -> temp_filename , name , """" , MI_NAME_IEXT , 2 + 4 + 32 ) ; if ( ( new_file = mysql_file_create ( mi_key_file_datatmp , fn_format ( param -> temp_filename , param -> temp_filename , """" , INDEX_TMP_EXT , 2 + 4 ) , 0 , param -> tmpfile_createflag , MYF ( 0 ) ) ) <= 0 ) { mi_check_print_error ( param , ""Can\'tcreatenewtempfile:\'%s\'"" , param -> temp_filename ) ; DBUG_RETURN ( - 1 ) ; } if ( filecopy ( param , new_file , share -> kfile , 0L , ( ulong ) share -> base . keystart , ""headerblock"" ) ) goto err ; param -> new_file_pos = share -> base . keystart ; for ( key = 0 , keyinfo = & share -> keyinfo [ 0 ] ; key < share -> base . keys ; key ++ , keyinfo ++ ) { if ( ! mi_is_key_active ( info -> s -> state . key_map , key ) ) continue ; if ( share -> state . key_root [ key ] != HA_OFFSET_ERROR ) { index_pos [ key ] = param -> new_file_
",0,511
1286,"static struct ipv6_txoptions * ipv6_update_options ( struct sock * sk , struct ipv6_txoptions * opt ) { if ( inet_sk ( sk ) -> is_icsk ) { if ( opt && ! ( ( 1 << sk -> sk_state ) & ( TCPF_LISTEN | TCPF_CLOSE ) ) && inet_sk ( sk ) -> inet_daddr != LOOPBACK4_IPV6 ) { struct inet_connection_sock * icsk = inet_csk ( sk ) ; icsk -> icsk_ext_hdr_len = opt -> opt_flen + opt -> opt_nflen ; icsk -> icsk_sync_mss ( sk , icsk -> icsk_pmtu_cookie ) ; } } opt = xchg ( ( __force struct ipv6_txoptions * * ) & inet6_sk ( sk ) -> opt , opt ) ; sk_dst_reset ( sk ) ; return opt ; }
",1,235
1287,"static int handle_exception ( struct kvm_vcpu * vcpu ) { struct vcpu_vmx * vmx = to_vmx ( vcpu ) ; struct kvm_run * kvm_run = vcpu -> run ; u32 intr_info , ex_no , error_code ; unsigned long cr2 , rip , dr6 ; u32 vect_info ; enum emulation_result er ; vect_info = vmx -> idt_vectoring_info ; intr_info = vmx -> exit_intr_info ; if ( is_nmi ( intr_info ) ) return 1 ; if ( is_no_device ( intr_info ) ) { vmx_fpu_activate ( vcpu ) ; return 1 ; } if ( is_invalid_opcode ( intr_info ) ) { if ( is_guest_mode ( vcpu ) ) { kvm_queue_exception ( vcpu , UD_VECTOR ) ; return 1 ; } er = emulate_instruction ( vcpu , EMULTYPE_TRAP_UD ) ; if ( er != EMULATE_DONE ) kvm_queue_exception ( vcpu , UD_VECTOR ) ; return 1 ; } error_code = 0 ; if ( intr_info & INTR_INFO_DELIVER_CODE_MASK ) error_code = vmcs_read32 ( VM_EXIT_INTR_ERROR_CODE ) ; if ( ( vect_info & VECTORING_INFO_VALID_MASK ) && ! ( is_page_fault ( intr_info ) && ! ( error_code & PFERR_RSVD_MASK ) ) ) { vcpu -> run -> exit_reason = KVM_EXIT_INTERNAL_ERROR ; vcpu -> run -> internal . suberror = KVM_INTERNAL_ERROR_SIMUL_EX ; vcpu -> run -> internal . ndata = 3 ; vcpu -> run -> internal . data [ 0 ] = vect_info ; vcpu -> run -> internal . data [ 1 ] = intr_info ; return 0 ; }
",0,472
1288,"const char * nghttp2_strerror ( int error_code ) { switch ( error_code ) { case 0 : return ""Success"" ; case NGHTTP2_ERR_INVALID_ARGUMENT : return ""Invalidargument"" ; case NGHTTP2_ERR_BUFFER_ERROR : return ""Outofbufferspace"" ; case NGHTTP2_ERR_UNSUPPORTED_VERSION : return ""UnsupportedSPDYversion"" ; case NGHTTP2_ERR_WOULDBLOCK : return ""Operationwouldblock"" ; case NGHTTP2_ERR_PROTO : return ""Protocolerror"" ; case NGHTTP2_ERR_INVALID_FRAME : return ""Invalidframeoctets"" ; case NGHTTP2_ERR_EOF : return ""EOF"" ; case NGHTTP2_ERR_DEFERRED : return ""Datatransferdeferred"" ; case NGHTTP2_ERR_STREAM_ID_NOT_AVAILABLE : return ""NomoreStreamIDavailable"" ; case NGHTTP2_ERR_STREAM_CLOSED : return ""Streamwasalreadyclosedorinvalid"" ; case NGHTTP2_ERR_STREAM_CLOSING : return ""Streamisclosing"" ; case NGHTTP2_ERR_STREAM_SHUT_WR : return ""Thetransmissionisnotallowedforthisstream"" ; case NGHTTP2_ERR_INVALID_STREAM_ID : return ""StreamIDisinvalid"" ; case NGHTTP2_ERR_INVALID_STREAM_STATE : return ""Invalidstreamstate"" ; case NGHTTP2_ERR_DEFERRED_DATA_EXIST : return ""AnotherDATAframehasalreadybeendeferred"" ; case NGHTTP2_ERR_START_STREAM_NOT_ALLOWED : return ""requestHEADERSisnotallowed"" ; case NGHTTP2_ERR_GOAWAY_ALREADY_SENT : return ""GOAWAYhasalreadybeensent"" ; case NGHTTP2_ERR_INVALID_HEADER_BLOCK : return ""Invalidheaderblock"" ; case NGHTTP2_ERR_INVALID_STATE : return ""Invalidstate"" ; case NGHTTP2_ERR_TEMPORAL_
",0,511
1289,"static UINT rdpei_recv_pdu ( RDPEI_CHANNEL_CALLBACK * callback , wStream * s ) { UINT16 eventId ; UINT32 pduLength ; UINT error ; Stream_Read_UINT16 ( s , eventId ) ; Stream_Read_UINT32 ( s , pduLength ) ; # ifdef WITH_DEBUG_RDPEI WLog_DBG ( TAG , ""rdpei_recv_pdu:eventId:%"" PRIu16 ""(%s)length:%"" PRIu32 """" , eventId , rdpei_eventid_string ( eventId ) , pduLength ) ; # endif switch ( eventId ) { case EVENTID_SC_READY : if ( ( error = rdpei_recv_sc_ready_pdu ( callback , s ) ) ) { WLog_ERR ( TAG , ""rdpei_recv_sc_ready_pdufailedwitherror%"" PRIu32 ""!"" , error ) ; return error ; } if ( ( error = rdpei_send_cs_ready_pdu ( callback ) ) ) { WLog_ERR ( TAG , ""rdpei_send_cs_ready_pdufailedwitherror%"" PRIu32 ""!"" , error ) ; return error ; } break ; case EVENTID_SUSPEND_TOUCH : if ( ( error = rdpei_recv_suspend_touch_pdu ( callback , s ) ) ) { WLog_ERR ( TAG , ""rdpei_recv_suspend_touch_pdufailedwitherror%"" PRIu32 ""!"" , error ) ; return error ; } break ; case EVENTID_RESUME_TOUCH : if ( ( error = rdpei_recv_resume_touch_pdu ( callback , s ) ) ) { WLog_ERR ( TAG , ""rdpei_recv_resume_touch_pdufailedwitherror%"" PRIu32 ""!"" , error ) ; return error ; } break ; default : break ; } return CHANNEL_RC_OK ; }
",0,478
1290,"static rsRetVal initZMQ ( instanceData * pData ) { DEFiRet ; if ( NULL == s_context ) { zsys_handler_set ( NULL ) ; s_context = zctx_new ( ) ; if ( s_workerThreads > 0 ) zctx_set_iothreads ( s_context , s_workerThreads ) ; } pData -> socket = zsocket_new ( s_context , pData -> type ) ; if ( NULL == pData -> socket ) { errmsg . LogError ( 0 , RS_RET_NO_ERRCODE , ""omzmq3:zsocket_newfailedfor%s:%s"" , pData -> description , zmq_strerror ( errno ) ) ; ABORT_FINALIZE ( RS_RET_NO_ERRCODE ) ; } if ( pData -> identity ) zsocket_set_identity ( pData -> socket , ( char * ) pData -> identity ) ; if ( pData -> sndBuf > - 1 ) zsocket_set_sndbuf ( pData -> socket , pData -> sndBuf ) ; if ( pData -> rcvBuf > - 1 ) zsocket_set_sndbuf ( pData -> socket , pData -> rcvBuf ) ; if ( pData -> linger > - 1 ) zsocket_set_linger ( pData -> socket , pData -> linger ) ; if ( pData -> backlog > - 1 ) zsocket_set_backlog ( pData -> socket , pData -> backlog ) ; if ( pData -> sndTimeout > - 1 ) zsocket_set_sndtimeo ( pData -> socket , pData -> sndTimeout ) ; if ( pData -> rcvTimeout > - 1 ) zsocket_set_rcvtimeo ( pData -> socket , pData -> rcvTimeout ) ; if ( pData -> maxMsgSize > - 1 ) zsocket_set_maxmsgsize ( pData -> socket , pData -> maxMsgSize ) ; if ( pData -> rate > - 1 ) zsocket_set_rate ( pData -> socket , pData -> rate ) ; if ( pData -> recoveryIVL > - 1 ) zsocket_set_recovery_ivl ( pData -> socket , pData -> recoveryIV
",0,511
1291,"int hugetlb_reserve_pages ( struct inode * inode , long from , long to , struct vm_area_struct * vma , vm_flags_t vm_flags ) { long ret , chg ; struct hstate * h = hstate_inode ( inode ) ; struct hugepage_subpool * spool = subpool_inode ( inode ) ; if ( vm_flags & VM_NORESERVE ) return 0 ; if ( ! vma || vma -> vm_flags & VM_MAYSHARE ) chg = region_chg ( & inode -> i_mapping -> private_list , from , to ) ; else { struct resv_map * resv_map = resv_map_alloc ( ) ; if ( ! resv_map ) return - ENOMEM ; chg = to - from ; set_vma_resv_map ( vma , resv_map ) ; set_vma_resv_flags ( vma , HPAGE_RESV_OWNER ) ; } if ( chg < 0 ) return chg ; if ( hugepage_subpool_get_pages ( spool , chg ) ) return - ENOSPC ; ret = hugetlb_acct_memory ( h , chg ) ; if ( ret < 0 ) { hugepage_subpool_put_pages ( spool , chg ) ; return ret ; } if ( ! vma || vma -> vm_flags & VM_MAYSHARE ) region_add ( & inode -> i_mapping -> private_list , from , to ) ; return 0 ; }
",0,360
1292,"static int sctp_v6_xmit ( struct sk_buff * skb , struct sctp_transport * transport ) { struct sock * sk = skb -> sk ; struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; rcu_read_lock ( ) ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = transport -> ipaddr . v6 . sin6_addr ; fl6 . saddr = transport -> saddr . v6 . sin6_addr ; fl6 . flowlabel = np -> flow_label ; IP6_ECN_flow_xmit ( sk , fl6 . flowlabel ) ; if ( ipv6_addr_type ( & fl6 . saddr ) & IPV6_ADDR_LINKLOCAL ) fl6 . flowi6_oif = transport -> saddr . v6 . sin6_scope_id ; else fl6 . flowi6_oif = sk -> sk_bound_dev_if ; if ( np -> opt && np -> opt -> srcrt ) { struct rt0_hdr * rt0 = ( struct rt0_hdr * ) np -> opt -> srcrt ; fl6 . daddr = * rt0 -> addr ; } pr_debug ( ""%s:skb:%p,len:%d,src:%pI6dst:%pI6\\n"" , __func__ , skb , skb -> len , & fl6 . saddr , & fl6 . daddr ) ; SCTP_INC_STATS ( sock_net ( sk ) , SCTP_MIB_OUTSCTPPACKS ) ; if ( ! ( transport -> param_flags & SPP_PMTUD_ENABLE ) ) skb -> local_df = 1 ; return ip6_xmit ( sk , skb , & fl6 , rcu_dereference ( np -> opt ) , np -> tclass ) ; }
",0,473
1293,"static struct dentry * ecryptfs_mount ( struct file_system_type * fs_type , int flags , const char * dev_name , void * raw_data ) { struct super_block * s ; struct ecryptfs_sb_info * sbi ; struct ecryptfs_dentry_info * root_info ; const char * err = ""Gettingsbfailed"" ; struct inode * inode ; struct path path ; uid_t check_ruid ; int rc ; sbi = kmem_cache_zalloc ( ecryptfs_sb_info_cache , GFP_KERNEL ) ; if ( ! sbi ) { rc = - ENOMEM ; goto out ; } rc = ecryptfs_parse_options ( sbi , raw_data , & check_ruid ) ; if ( rc ) { err = ""Errorparsingoptions"" ; goto out ; } s = sget ( fs_type , NULL , set_anon_super , flags , NULL ) ; if ( IS_ERR ( s ) ) { rc = PTR_ERR ( s ) ; goto out ; } rc = bdi_setup_and_register ( & sbi -> bdi , ""ecryptfs"" , BDI_CAP_MAP_COPY ) ; if ( rc ) goto out1 ; ecryptfs_set_superblock_private ( s , sbi ) ; s -> s_bdi = & sbi -> bdi ; sbi = NULL ; s -> s_op = & ecryptfs_sops ; s -> s_d_op = & ecryptfs_dops ; err = ""Readingsbfailed"" ; rc = kern_path ( dev_name , LOOKUP_FOLLOW | LOOKUP_DIRECTORY , & path ) ; if ( rc ) { ecryptfs_printk ( KERN_WARNING , ""kern_path()failed\\n"" ) ; goto out1 ; } if ( path . dentry -> d_sb -> s_type == & ecryptfs_fs_type ) { rc = - EINVAL ; printk ( KERN_ERR ""Mountonfilesystemoftype"" ""eCryptfsexplicitlydisalloweddueto"" ""knownincompatibilities\\n"" ) ; goto out_free ; } if ( check_ruid
",0,511
1294,"static int simulate_rdhwr ( struct pt_regs * regs , unsigned int opcode ) { struct thread_info * ti = task_thread_info ( current ) ; if ( ( opcode & OPCODE ) == SPEC3 && ( opcode & FUNC ) == RDHWR ) { int rd = ( opcode & RD ) >> 11 ; int rt = ( opcode & RT ) >> 16 ; perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , regs , 0 ) ; switch ( rd ) { case 0 : regs -> regs [ rt ] = smp_processor_id ( ) ; return 0 ; case 1 : regs -> regs [ rt ] = min ( current_cpu_data . dcache . linesz , current_cpu_data . icache . linesz ) ; return 0 ; case 2 : regs -> regs [ rt ] = read_c0_count ( ) ; return 0 ; case 3 : switch ( current_cpu_data . cputype ) { case CPU_20KC : case CPU_25KF : regs -> regs [ rt ] = 1 ; break ; default : regs -> regs [ rt ] = 2 ; } return 0 ; case 29 : regs -> regs [ rt ] = ti -> tp_value ; return 0 ; default : return - 1 ; } } return - 1 ; }
",1,318
1295,"static Image * ReadMATImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image , * image2 = NULL , * rotated_image ; PixelPacket * q ; unsigned int status ; MATHeader MATLAB_HDR ; size_t size ; size_t CellType ; QuantumInfo * quantum_info ; ImageInfo * clone_info ; int i ; ssize_t ldblk ; unsigned char * BImgBuff = NULL ; double MinVal , MaxVal ; size_t Unknown6 ; unsigned z , z2 ; unsigned Frames ; int logging ; int sample_size ; MagickOffsetType filepos = 0x80 ; BlobInfo * blob ; size_t one ; unsigned int ( * ReadBlobXXXLong ) ( Image * image ) ; unsigned short ( * ReadBlobXXXShort ) ( Image * image ) ; void ( * ReadBlobDoublesXXX ) ( Image * image , size_t len , double * data ) ; void ( * ReadBlobFloatsXXX ) ( Image * image , size_t len , float * data ) ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; logging = LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""enter"" ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } clone_info = CloneImageInfo ( image_info ) ; if ( ReadBlob ( image , 124 , ( unsigned char * ) & MATLAB_HDR . identific ) != 124 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( strncmp ( MATLAB_HDR . identific , ""MATLAB"" , 6 ) != 0 ) { image2 = ReadMATImageV4 ( image_info , image , exception ) ; if ( image2 == NULL ) goto MATLAB_KO ; image = image2 ; goto END_OF_READING ; } MATLAB_HDR . Version
",0,511
1296,"void nego_process_negotiation_failure ( rdpNego * nego , wStream * s ) { UINT16 length ; UINT32 failureCode ; WLog_DBG ( TAG , ""RDP_NEG_FAILURE"" ) ; Stream_Read_UINT8 ( s , flags ) ; Stream_Read_UINT16 ( s , length ) ; Stream_Read_UINT32 ( s , failureCode ) ; switch ( failureCode ) { case SSL_REQUIRED_BY_SERVER : WLog_WARN ( TAG , ""Error:SSL_REQUIRED_BY_SERVER"" ) ; break ; case SSL_NOT_ALLOWED_BY_SERVER : WLog_WARN ( TAG , ""Error:SSL_NOT_ALLOWED_BY_SERVER"" ) ; nego -> sendNegoData = TRUE ; break ; case SSL_CERT_NOT_ON_SERVER : WLog_ERR ( TAG , ""Error:SSL_CERT_NOT_ON_SERVER"" ) ; nego -> sendNegoData = TRUE ; break ; case INCONSISTENT_FLAGS : WLog_ERR ( TAG , ""Error:INCONSISTENT_FLAGS"" ) ; break ; case HYBRID_REQUIRED_BY_SERVER : WLog_WARN ( TAG , ""Error:HYBRID_REQUIRED_BY_SERVER"" ) ; break ; default : WLog_ERR ( TAG , ""Error:Unknownprotocolsecurityerror%"" PRIu32 """" , failureCode ) ; break ; } nego -> state = NEGO_STATE_FAIL ; }
",0,365
1297,"kadm5_ret_t kadm5_randkey_principal_3 ( void * server_handle , krb5_principal principal , krb5_boolean keepold , int n_ks_tuple , krb5_key_salt_tuple * ks_tuple , krb5_keyblock * * keyblocks , int * n_keys ) { krb5_db_entry * kdb ; osa_princ_ent_rec adb ; krb5_int32 now ; kadm5_policy_ent_rec pol ; int ret , last_pwd ; krb5_boolean have_pol = FALSE ; kadm5_server_handle_t handle = server_handle ; krb5_keyblock * act_mkey ; krb5_kvno act_kvno ; int new_n_ks_tuple = 0 ; krb5_key_salt_tuple * new_ks_tuple = NULL ; if ( keyblocks ) * keyblocks = NULL ; CHECK_HANDLE ( server_handle ) ; krb5_clear_error_message ( handle -> context ) ; if ( principal == NULL ) return EINVAL ; if ( ( ret = kdb_get_entry ( handle , principal , & kdb , & adb ) ) ) return ( ret ) ; ret = apply_keysalt_policy ( handle , adb . policy , n_ks_tuple , ks_tuple , & new_n_ks_tuple , & new_ks_tuple ) ; if ( ret ) goto done ; if ( krb5_principal_compare ( handle -> context , principal , hist_princ ) ) { if ( keepold ) return KADM5_PROTECT_PRINCIPAL ; new_n_ks_tuple = 1 ; } ret = kdb_get_active_mkey ( handle , & act_kvno , & act_mkey ) ; if ( ret ) goto done ; ret = krb5_dbe_crk ( handle -> context , act_mkey , new_ks_tuple , new_n_ks_tuple , keepold , kdb ) ; if ( ret ) goto done ; ret = krb
",0,511
1298,"static int pad_pkcs1 ( bn_t m , int * p_len , int m_len , int k_len , int operation ) { uint8_t * id , pad = 0 ; int len , result = RLC_ERR ; bn_t t ; bn_null ( t ) ; RLC_TRY { bn_new ( t ) ; switch ( operation ) { case RSA_ENC : bn_zero ( m ) ; bn_lsh ( m , m , 8 ) ; bn_add_dig ( m , m , RSA_PUB ) ; * p_len = k_len - 3 - m_len ; for ( int i = 0 ; i < * p_len ; i ++ ) { bn_lsh ( m , m , 8 ) ; do { rand_bytes ( & pad , 1 ) ; } while ( pad == 0 ) ; bn_add_dig ( m , m , pad ) ; } bn_lsh ( m , m , 8 ) ; bn_add_dig ( m , m , 0 ) ; bn_lsh ( m , m , m_len * 8 ) ; result = RLC_OK ; break ; case RSA_DEC : m_len = k_len - 1 ; bn_rsh ( t , m , 8 * m_len ) ; if ( ! bn_is_zero ( t ) ) { result = RLC_ERR ; } * p_len = m_len ; m_len -- ; bn_rsh ( t , m , 8 * m_len ) ; pad = ( uint8_t ) t -> dp [ 0 ] ; if ( pad != RSA_PUB ) { result = RLC_ERR ; } do { m_len -- ; bn_rsh ( t , m , 8 * m_len ) ; pad = ( uint8_t ) t -> dp [ 0 ] ; } while ( pad != 0 && m_len > 0 ) ; * p_len -= ( m_len - 1 ) ; bn_mod_2b ( m , m , ( k_len - * p_len ) * 8 ) ; break ; case RSA_SIG : id = hash_id ( MD_MAP , & len ) ; bn_set_dig ( m
",0,511
1299,"int yr_execute_code ( YR_RULES * rules , YR_SCAN_CONTEXT * context , int timeout , time_t start_time ) { int64_t mem [ MEM_SIZE ] ; int32_t sp = 0 ; uint8_t * ip = rules -> code_start ; YR_VALUE args [ MAX_FUNCTION_ARGS ] ; YR_VALUE * stack ; YR_VALUE r1 ; YR_VALUE r2 ; YR_VALUE r3 ; # ifdef PROFILING_ENABLED YR_RULE * current_rule = NULL ; # endif YR_RULE * rule ; YR_MATCH * match ; YR_OBJECT_FUNCTION * function ; char * identifier ; char * args_fmt ; int i ; int found ; int count ; int result = ERROR_SUCCESS ; int stop = FALSE ; int cycle = 0 ; int tidx = context -> tidx ; int stack_size ; # ifdef PROFILING_ENABLED clock_t start = clock ( ) ; # endif yr_get_configuration ( YR_CONFIG_STACK_SIZE , ( void * ) & stack_size ) ; stack = ( YR_VALUE * ) yr_malloc ( stack_size * sizeof ( YR_VALUE ) ) ; if ( stack == NULL ) return ERROR_INSUFFICIENT_MEMORY ; while ( ! stop ) { switch ( * ip ) { case OP_HALT : assert ( sp == 0 ) ; stop = TRUE ; break ; case OP_PUSH : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; push ( r1 ) ; break ; case OP_POP : pop ( r1 ) ; break ; case OP_CLEAR_M : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; mem [ r1 . i ] = 0 ; break ; case OP_ADD_M : r1 . i = * ( uint64_t * ) ( ip + 1 ) ; ip += sizeof ( uint64_t ) ; pop ( r2 ) ; if ( ! is_undef ( r2 ) ) mem [ r
",0,511
1300,"static vpx_codec_err_t vp8_get_reference ( vpx_codec_alg_priv_t * ctx , va_list args ) { vpx_ref_frame_t * data = va_arg ( args , vpx_ref_frame_t * ) ; if ( data && ! ctx -> yv12_frame_buffers . use_frame_threads ) { vpx_ref_frame_t * frame = ( vpx_ref_frame_t * ) data ; YV12_BUFFER_CONFIG sd ; image2yuvconfig ( & frame -> img , & sd ) ; return vp8dx_get_reference ( ctx -> yv12_frame_buffers . pbi [ 0 ] , frame -> frame_type , & sd ) ; } else return VPX_CODEC_INVALID_PARAM ; }
",1,199
1301,"static void bt_for_each ( struct blk_mq_hw_ctx * hctx , struct blk_mq_bitmap_tags * bt , unsigned int off , busy_iter_fn * fn , void * data , bool reserved ) { struct request * rq ; int bit , i ; for ( i = 0 ; i < bt -> map_nr ; i ++ ) { struct blk_align_bitmap * bm = & bt -> map [ i ] ; for ( bit = find_first_bit ( & bm -> word , bm -> depth ) ; bit < bm -> depth ; bit = find_next_bit ( & bm -> word , bm -> depth , bit + 1 ) ) { rq = hctx -> tags , off + bit ) ; if ( rq -> q == hctx -> queue ) fn ( hctx , rq , data , reserved ) ; } off += ( 1 << bt -> bits_per_word ) ; } }
",1,220
1302,"SNDFILE * sf_open ( const char * path , int mode , SF_INFO * sfinfo ) { SF_PRIVATE * psf ; assert ( sizeof ( sf_count_t ) == 8 ) ; if ( ( psf = psf_allocate ( ) ) == NULL ) { sf_errno = SFE_MALLOC_FAILED ; return NULL ; } ; psf_init_files ( psf ) ; psf_log_printf ( psf , ""File:%s\\n"" , path ) ; if ( copy_filename ( psf , path ) != 0 ) { sf_errno = psf -> error ; return NULL ; } ; psf -> file . mode = mode ; if ( strcmp ( path , ""-"" ) == 0 ) psf -> error = psf_set_stdio ( psf ) ; else psf -> error = psf_fopen ( psf ) ; return psf_open_file ( psf , sfinfo ) ; }
",1,227
1303,"static void fix_interp_filter ( VP9_COMMON * cm , MACROBLOCKD * xd ) { if ( cm -> interp_filter == SWITCHABLE ) { int count [ SWITCHABLE_FILTERS ] ; int i , j , c = 0 ; for ( i = 0 ; i < SWITCHABLE_FILTERS ; ++ i ) { count [ i ] = 0 ; for ( j = 0 ; j < SWITCHABLE_FILTER_CONTEXTS ; ++ j ) count [ i ] += cm -> counts . switchable_interp [ j ] [ i ] ; c += ( count [ i ] > 0 ) ; } if ( c == 1 ) { for ( i = 0 ; i < SWITCHABLE_FILTERS ; ++ i ) { if ( count [ i ] ) { cm -> interp_filter = i ; break ; } } } }
",0,195
1304,"static bool parseOperands ( char * str , ArmOp * op ) { char * t = strdup ( str ) ; int operand = 0 ; char * token = t ; char * x ; int imm_count = 0 ; int mem_opt = 0 ; if ( ! token ) { return false ; } while ( token ) { char * next = strchr ( token , ',' ) ; if ( next ) { * next ++ = 0 ; } while ( token [ 0 ] == '' ) { token ++ ; } if ( operand >= MAX_OPERANDS ) { return false ; } op -> operands [ operand ] . type = ARM_NOTYPE ; op -> operands [ operand ] . reg_type = ARM_UNDEFINED ; op -> operands [ operand ] . shift = ARM_NO_SHIFT ; while ( token [ 0 ] == '' || token [ 0 ] == '[' || token [ 0 ] == ']' ) { token ++ ; } if ( ! strncmp ( token , ""lsl"" , 3 ) ) { op -> operands [ operand ] . shift = ARM_LSL ; } else if ( ! strncmp ( token , ""lsr"" , 3 ) ) { op -> operands [ operand ] . shift = ARM_LSR ; } else if ( ! strncmp ( token , ""asr"" , 3 ) ) { op -> operands [ operand ] . shift = ARM_ASR ; } if ( op -> operands [ operand ] . shift != ARM_NO_SHIFT ) { op -> operands_count ++ ; op -> operands [ operand ] . shift_amount = r_num_math ( NULL , token + 4 ) ; if ( op -> operands [ operand ] . shift_amount > 63 ) { return false ; } operand ++ ; token = next ; continue ; } switch ( token [ 0 ] ) { case 'x' : x = strchr ( token , ',' ) ; if ( x ) { x [ 0 ] = '\\0' ; } op -> operands_count ++ ; op -> operands [ operand ] . type = ARM_GPR ; op -> operands [ operand ] . reg_type = ARM_REG64 ; op -> operands [ operand ] . reg = r_num_math ( NULL ,
",0,511
1305,"static void init_encode_frame_mb_context ( VP9_COMP * cpi ) { MACROBLOCK * const x = & cpi -> td . mb ; VP9_COMMON * const cm = & cpi -> common ; MACROBLOCKD * const xd = & x -> e_mbd ; const int aligned_mi_cols = mi_cols_aligned_to_sb ( cm -> mi_cols ) ; x -> act_zbin_adj = 0 ; vpx_setup_src_planes ( x , cpi -> Source , 0 , 0 ) ; vp9_setup_pre_planes ( xd , 0 , get_ref_frame_buffer ( cpi , LAST_FRAME ) , 0 , 0 , NULL ) ; vp9_setup_dst_planes ( xd , get_frame_new_buffer ( cm ) , 0 , 0 ) ; vp9_setup_block_planes ( & x -> e_mbd , cm -> subsampling_x , cm -> subsampling_y ) ; xd -> mi [ 0 ] -> mbmi . mode = DC_PRED ; xd -> mi [ 0 ] -> mbmi . uv_mode = DC_PRED ; memset ( xd -> above_context [ 0 ] , 0 , sizeof ( * xd -> above_context [ 0 ] ) * 2 * aligned_mi_cols * MAX_MB_PLANE ) ; memset ( xd -> above_seg_context , 0 , sizeof ( * xd -> above_seg_context ) * aligned_mi_cols ) ; }
",0,363
1306,"void pdf_summarize ( FILE * fp , const pdf_t * pdf , const char * name , pdf_flag_t flags ) { int i , j , page , n_versions , n_entries ; FILE * dst , * out ; char * dst_name , * c ; dst = NULL ; dst_name = NULL ; if ( name ) { dst_name = safe_calloc ( strlen ( name ) * 2 + 16 ) ; sprintf ( dst_name , ""%s/%s"" , name , name ) ; if ( ( c = strrchr ( dst_name , '.' ) ) && ( strncmp ( c , "".pdf"" , 4 ) == 0 ) ) * c = '\\0' ; strcat ( dst_name , "".summary"" ) ; if ( ! ( dst = fopen ( dst_name , ""w"" ) ) ) { ERR ( ""Couldnotopenfile\'%s\'forwriting\\n"" , dst_name ) ; return ; } } out = ( dst ) ? dst : stdout ; n_versions = pdf -> n_xrefs ; if ( n_versions && pdf -> xrefs [ 0 ] . is_linear ) -- n_versions ; for ( i = 1 ; i < pdf -> n_xrefs ; ++ i ) if ( pdf -> xrefs [ i ] . end == 0 ) -- n_versions ; if ( ! pdf -> n_xrefs || ( ! n_versions && pdf -> xrefs [ 0 ] . is_linear ) ) n_versions = 1 ; n_entries = 0 ; for ( i = 0 ; ! ( const int ) pdf -> has_xref_streams && i < pdf -> n_xrefs ; i ++ ) { if ( flags & PDF_FLAG_QUIET ) continue ; for ( j = 0 ; j < pdf -> xrefs [ i ] . n_entries ; j ++ ) { ++ n_entries ; fprintf ( out , ""%s:--%c--Version%d--Object%d(%s)"" , pdf -> name , pdf_get_object_status ( pdf , i , j ) , pdf -> xrefs [ i ] . version , pdf -> xrefs [ i ] . entries [ j ] . obj_id , get_type ( fp ,
",0,511
1307,"uint16_t http_DissectRequest ( struct sess * sp ) { struct http_conn * htc ; struct http * hp ; uint16_t retval ; CHECK_OBJ_NOTNULL ( sp , SESS_MAGIC ) ; htc = sp -> htc ; CHECK_OBJ_NOTNULL ( htc , HTTP_CONN_MAGIC ) ; hp = sp -> http ; CHECK_OBJ_NOTNULL ( hp , HTTP_MAGIC ) ; hp -> logtag = HTTP_Rx ; retval = http_splitline ( sp -> wrk , sp -> fd , hp , htc , HTTP_HDR_REQ , HTTP_HDR_URL , HTTP_HDR_PROTO ) ; if ( retval != 0 ) { WSPR ( sp , SLT_HttpGarbage , htc -> rxbuf ) ; return ( retval ) ; } http_ProtoVer ( hp ) ; retval = htc_request_check_host_hdr ( hp ) ; if ( retval != 0 ) { WSP ( sp , SLT_Error , ""DuplicatedHostheader"" ) ; return ( retval ) ; } retval = htc_request_check_host_hdr ( hp , false ) ; if ( retval != 0 ) { WSP ( sp , SLT_Error , ""DuplicatedHostheader"" ) ; return ( retval ) ; } return ( retval ) ; }
",0,323
1308,"static Image * ReadRLEImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define SkipLinesOp 0x01 # define SetColorOp 0x02 # define SkipPixelsOp 0x03 # define ByteDataOp 0x05 # define RunDataOp 0x06 # define EOFOp 0x07 # define EOFOp 1 ) char magick [ 12 ] ; Image * image ; IndexPacket index ; int opcode , operand , status ; MagickStatusType flags ; MagickSizeType number_pixels ; MemoryInfo * pixel_info ; register IndexPacket * indexes ; register ssize_t x ; register PixelPacket * q ; register ssize_t i ; register unsigned char * p ; size_t bits_per_pixel , map_length , number_colormaps , number_planes , number_planes_filled , one , pixel_info_length ; ssize_t count , offset , y ; unsigned char background_color [ 256 ] , * colormap , pixel , plane , * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ; if ( ( count != 2 ) || ( memcmp ( magick , ""\\122\\314"" , 2 ) != 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; do { image -> page . x = MagickLSBShort ( image ) ; image -> page . y = MagickLSBShort ( image ) ; image -> columns = MagickLSBShort ( image ) ; image -> rows = MagickLSBShort ( image ) ; flags = ( MagickStatusType ) ReadBlob ( image
",0,511
1309,"int snd_card_new ( struct device * parent , int idx , const char * xid , struct module * module , int extra_size , struct snd_card * * card_ret ) { struct snd_card * card ; int err ; if ( snd_BUG_ON ( ! card_ret ) ) return - EINVAL ; * card_ret = NULL ; if ( extra_size < 0 ) extra_size = 0 ; card = kzalloc ( sizeof ( * card ) + extra_size , GFP_KERNEL ) ; if ( ! card ) return - ENOMEM ; if ( extra_size > 0 ) card -> private_data = ( char * ) card + sizeof ( struct snd_card ) ; if ( xid ) strlcpy ( card -> id , xid , sizeof ( card -> id ) ) ; err = 0 ; mutex_lock ( & snd_card_mutex ) ; if ( idx < 0 ) idx = get_slot_from_bitmask ( idx , module_slot_match , module ) ; if ( idx < 0 ) idx = get_slot_from_bitmask ( idx , check_empty_slot , module ) ; if ( idx < 0 ) err = - ENODEV ; else if ( idx < snd_ecards_limit ) { if ( test_bit ( idx , snd_cards_lock ) ) err = - EBUSY ; } else if ( idx >= SNDRV_CARDS ) err = - ENODEV ; if ( err < 0 ) { mutex_unlock ( & snd_card_mutex ) ; dev_err ( parent , ""cannotfindtheslotforindex%d(range0-%i),error:%d\\n"" , idx , snd_ecards_limit - 1 , err ) ; kfree ( card ) ; return err ; } set_bit ( idx , snd_cards_lock ) ; if ( idx >= snd_ecards_limit ) snd_ecards_limit = idx + 1 ; mutex_unlock ( & snd_card_mutex ) ; card -> dev = parent ; card -> number = idx ; card -> module = module ; INIT_LIST_HEAD ( & card -> devices )
",0,511
1310,"err_t verify_signed_hash ( const struct RSA_public_key * k , u_char * s , unsigned int s_max_octets , u_char * * psig , size_t hash_len , const u_char * sig_val , size_t sig_len ) { unsigned int padlen ; { chunk_t temp_s ; MP_INT c ; n_to_mpz ( & c , sig_val , sig_len ) ; oswcrypto . mod_exp ( & c , & c , & k -> e , & k -> n ) ; temp_s = mpz_to_n ( & c , sig_len ) ; if ( s_max_octets < sig_len ) { return ""2"" ""exponentiationfailed;toomanyoctets"" ; } memcpy ( s , temp_s . ptr , sig_len ) ; pfree ( temp_s . ptr ) ; mpz_clear ( & c ) ; } padlen = sig_len - 3 - hash_len ; DBG ( DBG_CRYPT , DBG_dump ( ""verify_shdecryptedSIG1:"" , s , sig_len ) ) ; DBG ( DBG_CRYPT , DBG_log ( ""pad_lencalculated:%dhash_len:%d"" , padlen , ( int ) hash_len ) ) ; if ( s [ 0 ] != 0x00 || s [ 1 ] != 0x01 || s [ padlen + 2 ] != 0x00 ) { return ""3"" ""SIGpaddingdoesnotcheckout"" ; } s += padlen + 3 ; ( * psig ) = s ; return NULL ; }
",0,377
1311,"int btpan_tap_send ( int tap_fd , const BD_ADDR src , const BD_ADDR dst , UINT16 proto , const char * buf , UINT16 len , BOOLEAN ext , BOOLEAN forward ) { UNUSED ( ext ) ; UNUSED ( forward ) ; if ( tap_fd != INVALID_FD ) { tETH_HDR eth_hdr ; memcpy ( & eth_hdr . h_dest , dst , ETH_ADDR_LEN ) ; memcpy ( & eth_hdr . h_src , src , ETH_ADDR_LEN ) ; eth_hdr . h_proto = htons ( proto ) ; char packet [ TAP_MAX_PKT_WRITE_LEN + sizeof ( tETH_HDR ) ] ; memcpy ( packet , & eth_hdr , sizeof ( tETH_HDR ) ) ; if ( len > TAP_MAX_PKT_WRITE_LEN ) { LOG_ERROR ( ""btpan_tap_sendethpacketsize:%disexceededlimit!"" , len ) ; return - 1 ; } memcpy ( packet + sizeof ( tETH_HDR ) , buf , len ) ; int ret = TAP_TEMP_FAILURE_RETRY ( write ( tap_fd , packet , len + sizeof ( tETH_HDR ) ) ) ; BTIF_TRACE_DEBUG ( ""ret:%d"" , ret ) ; return ret ; } return - 1 ; }
",0,345
1312,"WORD32 ih264d_start_of_pic ( dec_struct_t * ps_dec , WORD32 i4_poc , pocstruct_t * ps_temp_poc , UWORD16 u2_frame_num , dec_pic_params_t * ps_pps ) { pocstruct_t * ps_prev_poc = & ps_dec -> s_cur_pic_poc ; pocstruct_t * ps_cur_poc = ps_temp_poc ; pic_buffer_t * pic_buf ; ivd_video_decode_op_t * ps_dec_output = ( ivd_video_decode_op_t * ) ps_dec -> pv_dec_out ; dec_slice_params_t * ps_cur_slice = ps_dec -> ps_cur_slice ; dec_seq_params_t * ps_seq = ps_pps -> ps_sps ; UWORD8 u1_bottom_field_flag = ps_cur_slice -> u1_bottom_field_flag ; UWORD8 u1_field_pic_flag = ps_cur_slice -> u1_field_pic_flag ; high_profile_tools_t s_high_profile ; WORD32 ret ; H264_MUTEX_LOCK ( & ps_dec -> process_disp_mutex ) ; ps_prev_poc -> i4_pic_order_cnt_lsb = ps_cur_poc -> i4_pic_order_cnt_lsb ; ps_prev_poc -> i4_pic_order_cnt_msb = ps_cur_poc -> i4_pic_order_cnt_msb ; ps_prev_poc -> i4_delta_pic_order_cnt_bottom = ps_cur_poc -> i4_delta_pic_order_cnt_bottom ; ps_prev_poc -> i4_delta_pic_order_cnt [ 0 ] = ps_cur_poc -> i4_delta_pic_order_cnt [ 0 ] ; ps_prev_poc -> i4_delta_pic_order_cnt [ 1 ] = ps_cur_poc -> i
",0,511
1313,"static int dtls1_buffer_record ( SSL * s , record_pqueue * queue , unsigned char * priority ) { DTLS1_RECORD_DATA * rdata ; pitem * item ; if ( pqueue_size ( queue -> q ) >= 100 ) return 0 ; rdata = OPENSSL_malloc ( sizeof ( DTLS1_RECORD_DATA ) ) ; item = pitem_new ( priority , rdata ) ; if ( rdata == NULL || item == NULL ) { if ( rdata != NULL ) OPENSSL_free ( rdata ) ; if ( item != NULL ) pitem_free ( item ) ; SSLerr ( SSL_F_DTLS1_BUFFER_RECORD , ERR_R_INTERNAL_ERROR ) ; return ( 0 ) ; } rdata -> packet = s -> packet ; rdata -> packet_length = s -> packet_length ; memcpy ( & ( rdata -> rbuf ) , & ( s -> s3 -> rbuf ) , sizeof ( SSL3_BUFFER ) ) ; memcpy ( & ( rdata -> rrec ) , & ( s -> s3 -> rrec ) , sizeof ( SSL3_RECORD ) ) ; item -> data = rdata ; # ifndef OPENSSL_NO_SCTP if ( BIO_dgram_is_sctp ( SSL_get_rbio ( s ) ) && ( s -> state == SSL3_ST_SR_FINISHED_A || s -> state == SSL3_ST_CR_FINISHED_A ) ) { BIO_ctrl ( SSL_get_rbio ( s ) , BIO_CTRL_DGRAM_SCTP_GET_RCVINFO , sizeof ( rdata -> recordinfo ) , & rdata -> recordinfo ) ; } # endif s -> packet = NULL ; s -> packet_length = 0 ; memset ( & ( s -> s3 -> rbuf ) , 0 , sizeof ( SSL3_BUFFER ) ) ; memset ( & ( s -> s3 -> rrec ) , 0 , sizeof ( SSL3_RECORD ) ) ; if ( ! ssl3_setup_buffers ( s ) ) { SSLerr ( SSL_F_DTLS1_BUFFER_RECORD , ERR_R_INTERNAL_ERROR )
",0,511
1314,"static int sctp_v6_xmit ( struct sk_buff * skb , struct sctp_transport * transport ) { struct sock * sk = skb -> sk ; struct ipv6_pinfo * np = inet6_sk ( sk ) ; struct flowi6 fl6 ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; rcu_read_lock ( ) ; fl6 . flowi6_proto = sk -> sk_protocol ; fl6 . daddr = transport -> ipaddr . v6 . sin6_addr ; fl6 . saddr = transport -> saddr . v6 . sin6_addr ; fl6 . flowlabel = np -> flow_label ; IP6_ECN_flow_xmit ( sk , fl6 . flowlabel ) ; if ( ipv6_addr_type ( & fl6 . saddr ) & IPV6_ADDR_LINKLOCAL ) fl6 . flowi6_oif = transport -> saddr . v6 . sin6_scope_id ; else fl6 . flowi6_oif = sk -> sk_bound_dev_if ; if ( np -> opt && np -> opt -> srcrt ) { struct rt0_hdr * rt0 = ( struct rt0_hdr * ) np -> opt -> srcrt ; fl6 . daddr = * rt0 -> addr ; } pr_debug ( ""%s:skb:%p,len:%d,src:%pI6dst:%pI6\\n"" , __func__ , skb , skb -> len , & fl6 . saddr , & fl6 . daddr ) ; SCTP_INC_STATS ( sock_net ( sk ) , SCTP_MIB_OUTSCTPPACKS ) ; if ( ! ( transport -> param_flags & SPP_PMTUD_ENABLE ) ) skb -> local_df = 1 ; return ip6_xmit ( sk , skb , & fl6 , rcu_dereference ( np -> opt ) , np -> tclass ) ; }
",0,473
1315,"int i915_gem_execbuffer2 ( struct drm_device * dev , void * data , struct drm_file * file ) { struct drm_i915_gem_execbuffer2 * args = data ; struct drm_i915_gem_exec_object2 * exec2_list = NULL ; int ret ; if ( args -> buffer_count < 1 || args -> buffer_count > UINT_MAX / sizeof ( * exec2_list ) ) { DRM_DEBUG ( ""execbuf2with%dbuffers\\n"" , args -> buffer_count ) ; return - EINVAL ; } exec2_list = kmalloc ( sizeof ( * exec2_list ) * args -> buffer_count , GFP_KERNEL | __GFP_NOWARN | __GFP_NORETRY ) ; if ( exec2_list == NULL ) exec2_list = drm_malloc_ab ( sizeof ( * exec2_list ) , args -> buffer_count ) ; if ( exec2_list == NULL ) { DRM_DEBUG ( ""Failedtoallocateexeclistfor%dbuffers\\n"" , args -> buffer_count ) ; return - ENOMEM ; } ret = copy_from_user ( exec2_list , ( struct drm_i915_relocation_entry __user * ) ( uintptr_t ) args -> buffers_ptr , sizeof ( * exec2_list ) * args -> buffer_count ) ; if ( ret != 0 ) { DRM_DEBUG ( ""copy%dexecentriesfailed%d\\n"" , args -> buffer_count , ret ) ; drm_free_large ( exec2_list ) ; return - EFAULT ; } ret = i915_gem_do_execbuffer ( dev , data , file , args , exec2_list ) ; if ( ! ret ) { ret = copy_to_user ( ( struct drm_i915_relocation_entry __user * ) ( uintptr_t ) args -> buffers_ptr , exec2_list , sizeof ( * exec2_list ) * args -> buffer_count ) ; if ( ret ) { ret = - EFAULT ; DRM_DEBUG ( ""failedtocopy%dexecentries"" ""backtouser(%d)\\n"" , args -> buffer_count , ret )
",0,511
1316,"static int mptctl_getiocinfo ( MPT_ADAPTER * ioc , unsigned long arg , unsigned int data_size ) { struct mpt_ioctl_iocinfo __user * uarg = ( void __user * ) arg ; struct mpt_ioctl_iocinfo * karg ; struct pci_dev * pdev ; int iocnum ; unsigned int port ; int cim_rev ; struct scsi_device * sdev ; VirtDevice * vdevice ; if ( data_size == sizeof ( struct mpt_ioctl_iocinfo_rev0 ) ) cim_rev = 0 ; else if ( data_size == sizeof ( struct mpt_ioctl_iocinfo_rev1 ) ) cim_rev = 1 ; else if ( data_size == sizeof ( struct mpt_ioctl_iocinfo ) ) cim_rev = 2 ; else if ( data_size == ( sizeof ( struct mpt_ioctl_iocinfo_rev0 ) + 12 ) ) cim_rev = 0 ; else return - EFAULT ; karg = memdup_user ( uarg , data_size ) ; if ( IS_ERR ( karg ) ) { printk ( KERN_ERR MYNAM ""%s@%d::mpt_ioctl_iocinfo()-memdup_userreturnederror[%ld]\\n"" , __FILE__ , __LINE__ , PTR_ERR ( karg ) ) ; return PTR_ERR ( karg ) ; } if ( ( ( iocnum = mpt_verify_adapter ( karg -> hdr . iocnum , & ioc ) ) < 0 ) || ( ioc == NULL ) ) { printk ( KERN_DEBUG MYNAM ""%s::mptctl_getiocinfo()@%d-ioc%dnotfound
",0,418
1317,"int mp_unpack_full ( lua_State * L , int limit , int offset ) { size_t len ; const char * s ; mp_cur c ; int cnt ; int decode_all = ( ! limit && ! offset ) ; s = luaL_checklstring ( L , 1 , & len ) ; if ( offset < 0 || limit < 0 ) return luaL_error ( L , ""Invalidrequesttounpackwithoffsetof%dandlimitof%d."" , offset , len ) ; else if ( offset > len ) return luaL_error ( L , ""Startoffset%dgreaterthaninputlength%d."" , offset , len ) ; if ( decode_all ) limit = INT_MAX ; mp_cur_init ( & c , ( const unsigned char * ) s + offset , len - offset ) ; for ( cnt = 0 ; c . left > 0 && cnt < limit ; cnt ++ ) { mp_decode_to_lua_type ( L , & c ) ; if ( c . err == MP_CUR_ERROR_EOF ) { return luaL_error ( L , ""Missingbytesininput."" ) ; } else if ( c . err == MP_CUR_ERROR_BADFMT ) { return luaL_error ( L , ""Baddataformatininput."" ) ; } } if ( ! decode_all ) { int offset = len - c . left ; luaL_checkstack ( L , 1 , ""infunctionmp_unpack"" ) ; lua_insert ( L , 2 ) ; cnt += 1 ; } return cnt ; }
",0,361
1318,"static inline int mount_entry_on_generic ( struct mntent * mntent , const char * path , const char * rootfs ) { unsigned long mntflags ; char * mntdata ; int ret ; bool optional = hasmntopt ( mntent , ""optional"" ) != NULL ; ret = mount_entry_create_dir_file ( mntent , path ) ; if ( ret < 0 ) return optional ? 0 : - 1 ; cull_mntent_opt ( mntent ) ; if ( parse_mntopts ( mntent -> mnt_opts , & mntflags , & mntdata ) < 0 ) { free ( mntdata ) ; return - 1 ; } ret = mount_entry ( mntent -> mnt_fsname , path , mntent -> mnt_type , mntflags , mntdata , optional , rootfs ) ; free ( mntdata ) ; return ret ; }
",1,210
1319,"static Image * ReadHRZImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image ; MagickBooleanType status ; register ssize_t x ; register PixelPacket * q ; register unsigned char * p ; ssize_t count , y ; size_t length ; unsigned char * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } status = SetImageExtent ( image , image -> columns , image -> rows ) ; if ( status == MagickFalse ) { InheritException ( exception , & image -> exception ) ; return ( DestroyImageList ( image ) ) ; } image -> columns = 256 ; image -> rows = 240 ; image -> depth = 8 ; pixels = ( unsigned char * ) AcquireQuantumMemory ( image -> columns , 3 * sizeof ( * pixels ) ) ; if ( pixels == ( unsigned char * ) NULL ) ThrowReaderException ( ResourceLimitError , ""MemoryAllocationFailed"" ) ; length = ( size_t ) ( 3 * image -> columns ) ; for ( y = 0 ; y < ( ssize_t ) image -> rows ; y ++ ) { count = ReadBlob ( image , length , pixels ) ; if ( ( size_t ) count != length ) ThrowReaderException ( CorruptImageError , ""UnableToReadImageData"" ) ; p = pixels ; q = QueueAuthenticPixels ( image , 0 , y , image -> columns , 1 , exception ) ; if ( q == ( PixelPacket * ) NULL ) break ; for ( x = 0 ; x < ( ssize_t ) image -> columns ; x ++ ) { SetPixelRed ( q , ScaleCharToQuantum ( 4 * * p ++ )
",0,511
1320,"static void audit_log_execve_info ( struct audit_context * context , struct audit_buffer * * ab ) { long len_max ; long len_rem ; long len_full ; long len_full_max ; long len_full_max ; long len_full_max ; long len_full_max ; long len_full_max ; long len_full_max ; long len_full_max ; long len_full_max ; long len_full_max ; long len_full_max ; long len_full_max ; long len_full_max ; long len_full_max ; long len_full_max ; long len_full_max ; long len_full_max ; long len_full_max ; long len_full_max ; long len_full_max ; long len_full_max ; long len_full_max ; long len_full_max ; long len_full_max ; long len_full_max ; long len_full_max ; long len_full_max ; long len_full_max ; long len_full_max ; long len_full_max ; long len_full_max ; long len_full_max ; long len_full_max ; long len_full_max ; long len_full_max ; long len_full_max ; long len_full_max ; long len_full_max ; long len_full_max ; long len_full_max ; long len_full_max ; long len_full_max ; long len_full_max ; long len_full_max ; long len_full_max ; long len_full_max ; long len_full_max ; long len_full_max ; long len_full_max ; long len_full_max ; long len_full_max ; long len_full_max ; long len_full_max ; long len_full_max ; long len_full_max ; long len_full_max ; long len_full_max ; long len_full_max ; long len_full_max ; long len_full_max ; long len_full_max ; long len_full_max ; long len_full_max ; long len_full_max ; long len_full_max ; long len_full_max ; long len_full_max ; long len_full_max ; long
",0,513
1321,"int touch_file ( const char * path , bool parents , usec_t stamp , uid_t uid , gid_t gid , mode_t mode ) { _cleanup_close_ int fd ; int r ; assert ( path ) ; if ( parents ) mkdir_parents ( path , 0755 ) ; fd = open ( path , O_WRONLY | O_CREAT | O_CLOEXEC | O_NOCTTY , ( mode == 0 || mode == MODE_INVALID ) ? 0644 : mode ) ; if ( fd < 0 ) return - errno ; if ( mode != MODE_INVALID ) { r = fchmod ( fd , mode ) ; if ( r < 0 ) return - errno ; } if ( uid != UID_INVALID || gid != GID_INVALID ) { r = fchown ( fd , uid , gid ) ; if ( r < 0 ) return - errno ; } if ( stamp != USEC_INFINITY ) { struct timespec ts [ 2 ] ; timespec_store ( & ts [ 0 ] , stamp ) ; ts [ 1 ] = ts [ 0 ] ; r = futimens ( fd , ts ) ; } else r = futimens ( fd , NULL ) ; if ( r < 0 ) return - errno ; return 0 ; }
",1,306
1322,"static gboolean netscreen_seek_read ( wtap * wth , gint64 seek_off , struct wtap_pkthdr * phdr , Buffer * buf , int * err , gchar * * err_info ) { char line [ NETSCREEN_LINE_LENGTH ] ; char cap_int [ NETSCREEN_MAX_INT_NAME_LENGTH ] ; gboolean cap_dir ; char cap_dst [ 13 ] ; if ( file_seek ( wth -> random_fh , seek_off , SEEK_SET , err ) == - 1 ) { return FALSE ; } if ( file_gets ( line , NETSCREEN_LINE_LENGTH , wth -> random_fh ) == NULL ) { * err = file_error ( wth -> random_fh , err_info ) ; if ( * err == 0 ) { * err = WTAP_ERR_SHORT_READ ; } return FALSE ; } pkt_len = parse_netscreen_rec_hdr ( phdr , line , cap_int , & cap_dir , cap_dst , phdr , buf , err , err_info ) ; if ( pkt_len == - 1 ) return FALSE ; if ( ! parse_netscreen_hex_dump ( wth -> random_fh , pkt_len , cap_int , cap_dst , phdr , buf , err , err_info ) ) return FALSE ; return TRUE ; }
",0,327
1323,"inline void update_rq_clock ( struct rq * rq ) { int cpu = cpu_of ( rq ) ; u64 irq_time ; if ( rq -> skip_clock_update ) return ; rq -> clock = sched_clock_cpu ( cpu ) ; irq_time = irq_time_cpu ( cpu ) ; if ( rq -> clock - irq_time > rq -> clock_task ) rq -> clock_task = rq -> clock - irq_time ; sched_irq_time_avg_update ( rq , irq_time ) ; }
",1,136
1324,"static ssize_t DecodePSDPixels ( const size_t number_compact_pixels , const unsigned char * compact_pixels , const ssize_t depth , const size_t number_pixels , unsigned char * pixels ) { # define CheckNumberCompactPixels if ( packets == 0 ) return ( i ) ; packets -- # define CheckNumberPixels ( count ) if ( ( ( ssize_t ) i + count ) > ( ssize_t ) number_pixels ) return ( i ) ; i += count int pixel ; register ssize_t i , j ; size_t length ; ssize_t packets ; packets = ( ssize_t ) number_compact_pixels ; for ( i = 0 ; ( packets > 1 ) && ( i < ( ssize_t ) number_pixels ) ; ) { packets -- ; length = ( size_t ) ( * compact_pixels ++ ) ; if ( length == 128 ) continue ; if ( length > 128 ) { length = 256 - length + 1 ; CheckNumberCompactPixels ; pixel = ( * compact_pixels ++ ) ; for ( j = 0 ; j < ( ssize_t ) length ; j ++ ) { switch ( depth ) { case 1 : { CheckNumberPixels ( 8 ) ; * pixels ++ = ( pixel >> 7 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( pixel >> 6 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( pixel >> 5 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( pixel >> 4 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( pixel >> 3 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( pixel >> 2 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( pixel >> 1 ) & 0x01 ? 0U : 255U ; * pixels ++ = ( pixel >> 0 ) & 0x01 ? 0U : 255U ; break ; } case 2 : { CheckNumberPixels ( 4 ) ; * pixels ++ = ( unsigned char ) ( ( pixel >> 6 ) & 0x03 ) ; * pixels ++ = ( unsigned char ) ( ( pixel >> 4 ) & 0x03 ) ; * pixels ++ = ( unsigned char ) ( ( pixel >> 2
",0,511
1325,"static void process_options ( argc , argv ) int argc ; char * argv [ ] ; { int i , l ; while ( argc > 1 && argv [ 1 ] [ 0 ] == '-' ) { argv ++ ; argc -- ; l = ( int ) strlen ( * argv ) ; if ( l < 4 ) l = 4 ; switch ( argv [ 0 ] [ 1 ] ) { case 'D' : case 'd' : if ( ( argv [ 0 ] [ 1 ] == 'D' && ! argv [ 0 ] [ 2 ] ) || ! strcmpi ( * argv , ""-debug"" ) ) { wizard = TRUE , discover = FALSE ; } else if ( ! strncmpi ( * argv , ""-DECgraphics"" , l ) ) { load_symset ( ""DECGraphics"" , PRIMARY ) ; switch_symbols ( TRUE ) ; } else { raw_printf ( ""Unknownoption:%s"" , * argv ) ; } break ; case 'X' : discover = TRUE , wizard = FALSE ; break ; # ifdef NEWS case 'n' : iflags . news = FALSE ; break ; # endif case 'u' : if ( argv [ 0 ] [ 2 ] ) { ( void ) strncpy ( plname , argv [ 0 ] + 2 , sizeof plname - 1 ) ; } else if ( argc > 1 ) { argc -- ; argv ++ ; ( void ) strncpy ( plname , argv [ 0 ] , sizeof plname - 1 ) ; } else { raw_print ( ""Playernameexpectedafter-u"" ) ; } break ; case 'I' : case 'i' : if ( ! strncmpi ( * argv , ""-IBMgraphics"" , l ) ) { load_symset ( ""IBMGraphics"" , PRIMARY ) ; load_symset ( "" RogueIBM"" , ROGUESET ) ; switch_symbols ( TRUE ) ; } else { raw_printf ( ""Unknownoption:%s"" , * argv ) ; } break ; case 'p' : if ( argv [ 0 ] [ 2 ] ) { if ( ( i = str2role ( & argv [ 0 ] [ 2 ] ) ) >= 0 ) flags . initrole ; raw_
",0,511
1326,"static void make_response ( struct xen_blkif_ring * ring , u64 id , unsigned short op , int st ) { struct blkif_response resp = NULL ; unsigned long flags ; union blkif_back_rings * blk_rings ; int notify ; resp . id = id ; resp . operation = op ; resp . status = st ; spin_lock_irqsave ( & ring -> blk_ring_lock , flags ) ; blk_rings = & ring -> blk_rings ; switch ( ring -> blkif -> blk_protocol ) { case BLKIF_PROTOCOL_NATIVE : memcpy ( RING_GET_RESPONSE ( & blk_rings -> native , blk_rings -> native . rsp_prod_pvt ) , & resp , sizeof ( resp ) ) ; break ; case BLKIF_PROTOCOL_X86_32 : memcpy ( RING_GET_RESPONSE ( & blk_rings -> x86_32 , blk_rings -> x86_32 . rsp_prod_pvt ) , & resp , sizeof ( resp ) ) ; break ; case BLKIF_PROTOCOL_X86_64 : memcpy ( RING_GET_RESPONSE ( & blk_rings -> x86_64 , blk_rings -> x86_64 . rsp_prod_pvt ) , & resp , sizeof ( resp ) ) ; break ; default : BUG ( ) ; } blk_rings -> common . rsp_prod_pvt ++ ; RING_PUSH_RESPONSES_AND_CHECK_NOTIFY ( & blk_rings -> common , notify ) ; spin_unlock_irqrestore ( & ring -> blk_ring_lock , flags ) ; if ( notify ) notify_remote_via_irq ( ring -> irq ) ; }
",0,431
1327,"static void check_1_6_dummy ( kadm5_principal_ent_t entry , long mask , int n_ks_tuple , krb5_key_salt_tuple * ks_tuple , char * * passptr ) { int i ; char * password = * passptr ; if ( password == NULL || ! ( mask & KADM5_ATTRIBUTES ) || ! ( entry -> attributes & KRB5_KDB_DISALLOW_ALL_TIX ) ) return ; for ( i = 0 ; ( unsigned char ) password [ i ] == i + 1 ; i ++ ) ; if ( password [ i ] != '\\0' || i != 255 ) return ; * passptr = NULL ; }
",1,168
1328,"static void exif_mnote_data_fuji_load ( ExifMnoteData * en , const unsigned char * buf , unsigned int buf_size ) { ExifMnoteDataFuji * n = ( ExifMnoteDataFuji * ) en ; ExifLong c ; size_t i , tcount , o , datao ; if ( ! n || ! buf || ! buf_size ) { exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteDataFuji"" , ""ShortMakerNote"" ) ; return ; } datao = 6 + n -> offset ; if ( ( datao + 12 < datao ) || ( datao + 12 < 12 ) || ( datao + 12 > buf_size ) ) { exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteDataFuji"" , ""ShortMakerNote"" ) ; return ; } n -> order = EXIF_BYTE_ORDER_INTEL ; datao += exif_get_long ( buf + datao + 8 , EXIF_BYTE_ORDER_INTEL ) ; if ( ( datao + 2 < datao ) || ( datao + 2 < 2 ) || ( datao + 2 > buf_size ) ) { exif_log ( en -> log , EXIF_LOG_CODE_CORRUPT_DATA , ""ExifMnoteDataFuji"" , ""ShortMakerNote"" ) ; return ; } c = exif_get_short ( buf + datao , EXIF_BYTE_ORDER_INTEL ) ; datao += 2 ; exif_mnote_data_fuji_clear ( n ) ; n -> entries = exif_mem_alloc ( en -> mem , sizeof ( MnoteFujiEntry ) * c ) ; if ( ! n -> entries ) { EXIF_LOG_NO_MEMORY ( en -> log , ""ExifMnoteDataFuji"" , sizeof ( MnoteFujiEntry ) * c ) ; return ; } tcount = 0 ; for ( i = c , o = datao ; i ; -- i , o += 12 ) { size_t s ; if ( ( o + 12 < o ) || ( datao
",0,511
1329,"static l_int32 pixHtmlViewer ( const char * dirin , const char * dirout , const char * rootname , l_int32 thumbwidth , l_int32 viewwidth ) { char * fname , * fullname , * outname ; char * mainname , * linkname , * linknameshort ; char * viewfile , * thumbfile ; char * shtml , * slink ; char buf [ 512 ] ; char htmlstring [ ] = ""<html>"" ; char framestring [ ] = ""</frameset></html>"" ; l_int32 i , nfiles , index , w , d , nimages , ret ; l_float32 factor ; PIX * pix , * pixthumb , * pixview ; SARRAY * safiles , * sathumbs , * saviews , * sahtml , * salink ; PROCNAME ( ""pixHtmlViewer"" ) ; if ( ! dirin ) return ERROR_INT ( ""dirinnotdefined"" , procName , 1 ) ; if ( ! dirout ) return ERROR_INT ( ""diroutnotdefined"" , procName , 1 ) ; if ( ! rootname ) return ERROR_INT ( ""rootnamenotdefined"" , procName , 1 ) ; if ( thumbwidth == 0 ) thumbwidth = DEFAULT_THUMB_WIDTH ; if ( thumbwidth < MIN_THUMB_WIDTH ) { L_WARNING ( ""thumbwidthtoosmall;usingminvalue\\n"" , procName ) ; thumbwidth = MIN_THUMB_WIDTH ; } if ( viewwidth == 0 ) viewwidth = DEFAULT_VIEW_WIDTH ; if ( viewwidth < MIN_VIEW_WIDTH ) { L_WARNING ( ""viewwidthtoosmall;usingminvalue\\n"" , procName ) ; viewwidth = MIN_VIEW_WIDTH ; } # ifndef _WIN32 snprintf ( charbuf , sizeof ( charbuf ) , ""mkdir-p%s"" , dirout ) ; ret = system ( charbuf ) ; # else ret = CreateDirectory ( dirout , NULL ) ? 0 : 1 ; # endif if ( ret ) { L_ERROR ( ""outputdirectory%snotmade\\n"" , procName , dirout ) ; return 1 ; } if ( (
",0,511
1330,"void icmp_print ( netdissect_options * ndo , const u_char * bp , u_int plen , const u_char * bp2 , int fragmented ) { char * cp ; const struct icmp * dp ; const struct icmp_ext_t * ext_dp ; const struct ip * ip ; const char * str , * fmt ; const struct ip * oip ; const struct udphdr * ouh ; const uint8_t * obj_tptr ; uint32_t raw_label ; const u_char * snapend_save ; const struct icmp_mpls_ext_object_header_t * icmp_mpls_ext_object_header ; u_int hlen , dport , mtu , obj_tlen , obj_class_num , obj_ctype ; char buf [ MAXHOSTNAMELEN + 100 ] ; struct cksum_vec vec [ 1 ] ; dp = ( const struct icmp * ) bp ; ext_dp = ( const struct icmp_ext_t * ) bp ; ip = ( const struct ip * ) bp2 ; str = buf ; ND_TCHECK ( dp -> icmp_code ) ; switch ( dp -> icmp_type ) { case ICMP_ECHO : case ICMP_ECHOREPLY : ND_TCHECK ( dp -> icmp_seq ) ; ( void ) snprintf ( buf , sizeof ( buf ) , ""echo%s,id%u,seq%u"" , dp -> icmp_type == ICMP_ECHO ? ""request"" : ""reply"" , EXTRACT_16BITS ( & dp -> icmp_id ) , EXTRACT_16BITS ( & dp -> icmp_seq ) ) ; break ; case ICMP_UNREACH : ND_TCHECK ( dp -> icmp_ip . ip_dst ) ; switch ( dp -> icmp_code ) { case ICMP_UNREACH_PROTOCOL : ND_TCHECK ( dp -> icmp_ip . ip_p ) ; ( void ) snprintf ( buf , sizeof ( buf ) , ""%sprotocol%dunreachable"" , ipaddr_string ( ndo , & dp -> icmp_ip .
",0,511
1331,"static int fscrypt_d_revalidate ( struct dentry * dentry , unsigned int flags ) { struct dentry * dir ; dir = dget_parent ( dentry ) ; if ( ! d_inode ( dir ) -> i_sb -> s_cop -> is_encrypted ( d_inode ( dir ) ) ) { dput ( dir ) ; return 0 ; } spin_lock ( & dentry -> d_lock ) ; cached_with_key = dentry -> d_flags & DCACHE_ENCRYPTED_WITH_KEY ; spin_unlock ( & dentry -> d_lock ) ; dir_has_key = ( ci != NULL ) ; dput ( dir ) ; if ( ( ! cached_with_key && d_is_negative ( dentry ) ) || ( ! cached_with_key && dir_has_key ) || ( cached_with_key && ! dir_has_key ) ) return 0 ; return 1 ; }
",0,217
1332,"void unbind_ports ( void ) { SERVICE_OPTIONS * opt ; s_poll_init ( fds , 1 ) ; service_options . next = NULL ; service_options . next = NULL ; service_free ( & service_options ) ; while ( opt ) { unsigned i ; s_log ( LOG_DEBUG , ""Unbindingservice[%s]"" , opt -> servname ) ; for ( i = 0 ; i < opt -> local_addr . num ; ++ i ) unbind_port ( opt , i ) ; if ( opt -> exec_name && opt -> connect_addr . names ) { opt -> option . retry = 0 ; } if ( opt -> ctx ) SSL_CTX_flush_sessions ( & opt -> ctx , ( long ) time ( NULL ) + opt -> session_timeout + 1 ) ; s_log ( LOG_DEBUG , ""Service[%s]closed"" , opt -> servname ) ; } } CRYPTO_THREAD_unlock ( stunnel_locks [ LOCK_SECTIONS ] ) ; }
",0,235
1333,"static int parse_device ( dev_t * pdev , struct archive * a , char * val ) { # define MAX_PACK_ARGS 3 unsigned long numbers [ MAX_PACK_ARGS ] ; char * p , * dev ; int argc ; pack_t * pack ; dev_t result ; const char * error = NULL ; memset ( pdev , 0 , sizeof ( * pdev ) ) ; if ( ( dev = strchr ( val , ',' ) ) != NULL ) { * dev ++ = '\\0' ; if ( ( pack = pack_find ( val ) ) == NULL ) { archive_set_error ( a , ARCHIVE_ERRNO_FILE_FORMAT , ""Unknownformat`%s\'"" , val ) ; return ARCHIVE_WARN ; } if ( argc >= MAX_PACK_ARGS ) { archive_set_error ( a , ARCHIVE_ERRNO_FILE_FORMAT , ""Toomanyarguments"" ) ; return ARCHIVE_WARN ; } argc = 0 ; while ( ( p = la_strsep ( & dev , "","" ) ) != NULL ) { if ( * p == '\\0' ) { archive_set_error ( a , ARCHIVE_ERRNO_FILE_FORMAT , ""Missingnumber"" ) ; return ARCHIVE_WARN ; } numbers [ argc ++ ] = ( unsigned long ) mtree_atol ( & p ) ; } if ( argc < 2 ) { archive_set_error ( a , ARCHIVE_ERRNO_FILE_FORMAT , ""Notenougharguments"" ) ; return ARCHIVE_WARN ; } result = ( * pack ) ( argc , numbers , & error ) ; if ( error != NULL ) { archive_set_error ( a , ARCHIVE_ERRNO_FILE_FORMAT , ""%s"" , error ) ; return ARCHIVE_WARN ; } } else { result = ( dev_t ) mtree_atol ( & val ) ; } * pdev = result ; return ARCHIVE_OK ; # undef MAX_PACK_ARGS }
",1,473
1334,"static int DecodeGifImg ( struct ngiflib_img * i ) { struct ngiflib_decode_context context ; long npix ; u8 * stackp ; u8 * stack_top ; u16 clr ; u16 eof ; u16 free ; u16 act_code = 0 ; u16 old_code = 0 ; u16 read_byt ; u16 ab_prfx [ 4096 ] ; u8 ab_suffx [ 4096 ] ; u8 ab_stack [ 4096 ] ; u8 flags ; u8 casspecial = 0 ; if ( ! i ) return - 1 ; i -> posX = GetWord ( i -> parent ) ; if ( ( i -> width > i -> parent -> width ) || ( i -> height > i -> parent -> height ) ) return - 1 ; i -> posY = GetWord ( i -> parent ) ; i -> width = GetWord ( i -> parent ) ; i -> height = GetWord ( i -> parent ) ; context . Xtogo = i -> width ; context . curY = i -> posY ; # ifdef NGIFLIB_INDEXED_ONLY # ifdef NGIFLIB_ENABLE_CALLBACKS context . line_p . p8 = i -> parent -> frbuff . p8 + ( u32 ) i -> posY * i -> parent -> width ; context . frbuff_p . p8 = context . line_p . p8 + i -> posX ; # else context . frbuff_p . p8 = i -> parent -> frbuff . p8 + ( u32 ) i -> posY * i -> parent -> width + i -> posX ; # endif # else if ( i -> parent -> mode & NGIFLIB_MODE_INDEXED ) { # ifdef NGIFLIB_ENABLE_CALLBACKS context . line_p . p8 = i -> parent -> frbuff . p8 + ( u32 ) i -> posY * i -> parent -> width ; context . frbuff_p . p8 = context . line_p . p8 + i -> posX ; # else context . frbuff_p . p8 = i -> parent -> frbuff . p8 + ( u32 ) i -> posY * i -> parent -> width + i -> posX ; # endif } else { # ifdef
",0,511
1335,"void processRequest ( struct reqelem * req ) { ssize_t n ; unsigned int l , m ; unsigned char buf [ 2048 ] ; const unsigned char * p ; enum request_type type ; struct device * d = devlist ; unsigned char rbuf [ RESPONSE_BUFFER_SIZE ] ; unsigned char * rp ; unsigned char nrep = 0 ; time_t t ; struct service * newserv = NULL ; struct service * serv ; n = read ( req -> socket , buf , sizeof ( buf ) ) ; if ( n < 0 ) { if ( errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK ) return ; syslog ( LOG_ERR , ""(s=%d)processRequest():read():%m"" , req -> socket ) ; goto error ; } if ( n == 0 ) { syslog ( LOG_INFO , ""(s=%d)requestconnectionclosed"" , req -> socket ) ; goto error ; } t = time ( NULL ) ; type = buf [ 0 ] ; p = buf + 1 ; DECODELENGTH_CHECKLIMIT ( l , p , buf + n ) ; if ( p + l > buf + n - p ) { syslog ( LOG_WARNING , ""badrequest(lengthencodingl=%un=%u)"" , l , ( unsigned ) n ) ; goto error ; } if ( l == 0 && type != MINISSDPD_SEARCH_ALL && type != MINISSDPD_GET_VERSION && type != MINISSDPD_NOTIF ) { syslog ( LOG_WARNING , ""badrequest(length=0,type=%d)"" , type ) ; goto error ; } syslog ( LOG_INFO , ""(s=%d)requesttype=%dstr=\'%.*s\'"" , req -> socket , type , l , p ) ; switch ( type ) { case MINISSDPD_GET_VERSION : rp = rbuf ; CODELENGTH ( ( sizeof ( MINISSDPD_VERSION ) - 1 ) , rp ) ; memcpy ( rp , MINISSDPD_VERSION , sizeof ( MINISSDPD_VERSION ) - 1 ) ; rp += ( sizeof ( MINISSDPD_VERSION ) - 1 ) ; if ( write_or_buffer ( req , rbuf , rp
",0,511
1336,"INST_HANDLER ( cpse ) { int r = ( buf [ 0 ] & 0xf ) | ( ( buf [ 1 ] & 0x2 ) << 3 ) ; int d = ( ( buf [ 0 ] >> 4 ) & 0xf ) | ( ( buf [ 1 ] & 0x1 ) << 4 ) ; RAnalOp next_op = { 0 } ; avr_op_analyze ( anal , & next_op , op -> addr + op -> size , buf + op -> size , len - op -> size , cpu ) ; r_strbuf_fini ( & next_op . esil ) ; op -> jump = op -> addr + next_op . size + 2 ; op -> cycles = 1 ; ESIL_A ( ""r%d,r%d,^,
",0,176
1337,"static Image * ReadDCMImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define ThrowDCMException ( exception , message ) \\\n{ if ( info . scale != ( Quantum * ) NULL ) info . scale = ( Quantum * ) RelinquishMagickMemory ( info . scale ) ; if ( data != ( unsigned char * ) NULL ) data = ( unsigned char * ) RelinquishMagickMemory ( data ) ; if ( graymap != ( int * ) NULL ) graymap = ( int * ) RelinquishMagickMemory ( graymap ) ; if ( bluemap != ( int * ) NULL ) bluemap = ( int * ) RelinquishMagickMemory ( bluemap ) ; if ( greenmap != ( int * ) NULL ) greenmap = ( int * ) RelinquishMagickMemory ( greenmap ) ; if ( redmap != ( int * ) NULL ) redmap = ( int * ) RelinquishMagickMemory ( redmap ) ; if ( stream_info -> offsets != ( ssize_t * ) NULL ) stream_info -> offsets = ( ssize_t * ) RelinquishMagickMemory ( stream_info -> offsets ) ; if ( stream_info != ( DCMStreamInfo * ) NULL ) stream_info = ( DCMStreamInfo * ) RelinquishMagickMemory ( stream_info ) ; ThrowReaderException ( ( exception ) , ( message ) ) ; \\\n} char explicit_vr [ MagickPathExtent ] , implicit_vr [ MagickPathExtent ] , magick [ MagickPathExtent ] , photometric [ MagickPathExtent ] ; DCMInfo info ; DCMStreamInfo * stream_info ; Image * image ; int * bluemap , datum , * greenmap , * graymap , * redmap ; MagickBooleanType explicit_file , explicit_retry , use_explicit ; MagickOffsetType offset ; register unsigned char * p ; register ssize_t i ; size_t colors , height , length , number_scenes , quantum , status , width ; ssize_t count , scene ; unsigned char * data ; unsigned short group , element ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug
",0,511
1338,"void recovery_delete_character ( void ) { if ( strlen ( mnemonic ) > 0 ) { mnemonic [ strlen ( mnemonic ) - 1 ] = '\\0' ; } next_character ( ) ; }
",0,52
1339,"error_t enc624j600UpdateMacAddrFilter ( NetInterface * interface ) { uint_t i ; uint_t k ; uint32_t crc ; uint16_t hashTable [ 4 ] ; MacFilterEntry * entry ; TRACE_DEBUG ( ""UpdatingMACfilter...\\r\\n"" ) ; osMemset ( hashTable , 0 , sizeof ( hashTable ) ) ; for ( i = 0 ; i < MAC_ADDR_FILTER_SIZE ; i ++ ) { entry = & interface -> macAddrFilter [ i ] ; if ( entry -> refCount > 0 ) { crc = enc624j600CalcCrc ( & entry -> addr , sizeof ( MacAddr ) ) ; k = ( crc >> 23 ) & 0x3F ; hashTable [ k / 16 ] |= ( 1 << ( k % 16 ) ) ; } } enc624j600WriteReg ( interface , ENC624J600_EHT1 , hashTable [ 0 ] ) ; enc624j600WriteReg ( interface , ENC624J600_EHT2 , hashTable [ 1 ] ) ; enc624j600WriteReg ( interface , ENC624J600_EHT3 , hashTable [ 2 ] ) ; enc624j600WriteReg ( interface , ENC624J600_EHT4 , hashTable [ 3 ] ) ; enc624j600WriteReg ( interface , ENC624J600_EHT5 , hashTable [ 4 ] ) ; TRACE_DEBUG ( ""EHT1=%04"" PRIX16 ""\\r\\n"" , enc624j600ReadReg ( interface , ENC624J600_EHT1 ) ) ; TRACE_DEBUG ( ""EHT2=%04"" PRIX16 ""\\r\\n"" , enc624j600ReadReg ( interface , ENC624J600_EHT2 ) ) ; TRACE_DEBUG ( ""EHT3=%04"" PRIX16 ""\\r\\n"" , enc624j600ReadReg ( interface , ENC624J600_EHT1 ) ) ; TRACE_DEBUG ( ""EHT4=%04"" PRIX16 ""\\r\\n"" , enc624j600ReadReg ( interface , ENC624J600
",0,511
1340,"static Image * ReadPDBImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { unsigned char attributes , tag [ 3 ] ; Image * image ; MagickBooleanType status ; PDBImage pdb_image ; PDBInfo pdb_info ; Quantum index ; register ssize_t x ; register Quantum * q ; register unsigned char * p ; size_t bits_per_pixel , num_pad_bytes , one , packets ; ssize_t count , img_offset , comment_offset = 0 , y ; unsigned char * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } count = ReadBlob ( image , sizeof ( pdb_info . name ) , ( unsigned char * ) pdb_info . name ) ; if ( count != sizeof ( pdb_info . name ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; pdb_info . attributes = ( short ) ReadBlobMSBShort ( image ) ; pdb_info . version = ( short ) ReadBlobMSBShort ( image ) ; pdb_info . create_time = ReadBlobMSBLong ( image ) ; pdb_info . modify_time = ReadBlobMSBLong ( image ) ; pdb_info . archive_time = ReadBlobMSBLong ( image ) ; pdb_info . modify_number = ReadBlobMSBLong ( image ) ; pdb_info . application_info = ReadBlobMSBLong ( image ) ; pdb_info . sort_info = ReadBlobMSBLong ( image ) ; ( void ) ReadBlob ( image , 4 , ( unsigned char
",0,511
1341,"void processRequest ( struct reqelem * req ) { ssize_t n ; unsigned int l , m ; unsigned char buf [ 2048 ] ; const unsigned char * p ; int type ; struct device * d = devlist ; unsigned char rbuf [ 4096 ] ; unsigned char * rp = rbuf + 1 ; unsigned char nrep = 0 ; time_t t ; struct service * newserv = NULL ; struct service * serv ; n = read ( req -> socket , buf , sizeof ( buf ) ) ; if ( n < 0 ) { if ( errno == EINTR || errno == EAGAIN || errno == EWOULDBLOCK ) return ; syslog ( LOG_ERR , ""(s=%d)processRequest():read():%m"" , req -> socket ) ; goto error ; } if ( n == 0 ) { syslog ( LOG_INFO , ""(s=%d)requestconnectionclosed"" , req -> socket ) ; goto error ; } t = time ( NULL ) ; type = buf [ 0 ] ; p = buf + 1 ; DECODELENGTH_CHECKLIMIT ( l , p , buf + n ) ; if ( p + l > buf + n ) { syslog ( LOG_WARNING , ""badrequest(lengthencoding)"" ) ; goto error ; } if ( l == 0 && type != 3 ) { syslog ( LOG_WARNING , ""badrequest(length=0)"" ) ; goto error ; } syslog ( LOG_INFO , ""(s=%d)requesttype=%dstr=\'%.*s\'"" , req -> socket , type , l , p ) ; switch ( type ) { case 1 : case 2 : case 3 : while ( d && ( nrep < 255 ) ) { if ( d -> t < t ) { syslog ( LOG_INFO , ""outdateddevice"" ) ; } else { if ( d -> headers [ HEADER_LOCATION ] . l + d -> headers [ HEADER_NT ] . l + d -> headers [ HEADER_USN ] . l + 6 + ( rp - rbuf ) >= ( int ) sizeof ( rbuf ) ) break ; if ( ( type == 1 && 0 == memcmp ( d -> headers [ HEADER_NT ] . p , p , l ) ) || ( type == 2 && 0 == memcmp ( d -> headers [ HEADER_
",0,511
1342,"WORD32 ihevcd_ref_list ( codec_t * ps_codec , pps_t * ps_pps , sps_t * ps_sps , slice_header_t * ps_slice_hdr ) { WORD32 i ; WORD32 st_rps_idx ; WORD32 num_neg_pics , num_pos_pics ; WORD8 * pi1_used ; WORD16 * pi2_delta_poc ; UWORD32 u4_max_poc_lsb ; pic_buf_t * ps_pic_buf ; mv_buf_t * ps_mv_buf ; UWORD32 r_idx ; dpb_mgr_t * ps_dpb_mgr = ( dpb_mgr_t * ) ps_codec -> pv_dpb_mgr ; buf_mgr_t * ps_mv_buf_mgr = ( buf_mgr_t * ) ps_codec -> pv_mv_buf_mgr ; WORD32 ai4_poc_st_curr_before [ MAX_DPB_SIZE ] , ai4_poc_st_foll [ MAX_DPB_SIZE ] , ai4_poc_st_curr_after [ MAX_DPB_SIZE ] ; WORD32 ai4_poc_lt_curr [ MAX_DPB_SIZE ] , ai4_poc_lt_foll [ MAX_DPB_SIZE ] ; UWORD32 u4_num_st_curr_before , u4_num_st_foll , u4_num_st_curr_after , u4_num_lt_curr , u4_num_lt_foll ; UWORD32 u4_num_total_curr ; WORD8 ai1_curr_delta_poc_msb_present_flag [ MAX_DPB_SIZE ] , ai1_foll_delta_poc_msb_present_flag [ MAX_DPB_SIZE ] ; pic_buf_t * as_ref_pic_lt_curr [ MAX_DPB_SIZE ] ; pic_buf_t * as
",0,511
1343,"long arch_ptrace ( struct task_struct * child , long request , unsigned long addr , unsigned long data ) { int ret ; unsigned long __user * datap = ( unsigned long __user * ) data ; switch ( request ) { case PTRACE_PEEKUSR : ret = ptrace_read_user ( child , addr , datap ) ; break ; case PTRACE_POKEUSR : ret = ptrace_write_user ( child , addr , data ) ; break ; case PTRACE_GETREGS : ret = copy_regset_to_user ( child , & user_arm_view , REGSET_GPR , 0 , sizeof ( struct pt_regs ) , datap ) ; break ; case PTRACE_SETREGS : ret = copy_regset_from_user ( child , & user_arm_view , REGSET_GPR , 0 , sizeof ( struct pt_regs ) , datap ) ; break ; case PTRACE_GETFPREGS : ret = copy_regset_to_user ( child , & user_arm_view , REGSET_FPR , 0 , sizeof ( union fp_state ) , datap ) ; break ; case PTRACE_SETFPREGS : ret = copy_regset_from_user ( child , & user_arm_view , REGSET_FPR , 0 , sizeof ( union fp_state ) , datap ) ; break ; # ifdef CONFIG_IWMMXT case PTRACE_GETWMMXREGS : ret = ptrace_getwmmxregs ( child , datap ) ; break ; case PTRACE_SETWMMXREGS : ret = ptrace_setwmmxregs ( child , datap ) ; break ; # endif case PTRACE_GET_THREAD_AREA : ret = put_user ( task_thread_info ( child ) -> tp_value , datap ) ; break ; case PTRACE_SET_SYSCALL : task_thread_info ( child ) -> syscall = data ; ret = 0 ; break ; # ifdef CONFIG_CRUNCH case PTRACE_GETCRUNCHREGS : ret = ptrace_getcrunchregs ( child , datap ) ; break ; case PTRACE_SET
",0,511
1344,"static int vc4_get_bcl ( struct drm_device * dev , struct vc4_exec_info * exec ) { struct drm_vc4_submit_cl * args = exec -> args ; void * temp = NULL ; void * bin ; int ret = 0 ; uint32_t bin_offset = 0 ; uint32_t shader_rec_offset = roundup ( bin_offset + args -> bin_cl_size , 16 ) ; uint32_t uniforms_offset = shader_rec_offset + args -> shader_rec_size ; uint32_t exec_size = uniforms_offset + args -> uniforms_size ; uint32_t temp_size = exec_size + ( sizeof ( struct vc4_shader_state ) * args -> shader_rec_count ) ; struct vc4_bo * bo ; if ( shader_rec_offset < args -> bin_cl_size || uniforms_offset < shader_rec_offset || exec_size < uniforms_offset || args -> shader_rec_count >= ( UINT_MAX / sizeof ( struct vc4_shader_state ) ) || temp_size < exec_size ) { DRM_ERROR ( ""overflowinexecarguments\\n"" ) ; ret = - EINVAL ; goto fail ; } temp = drm_malloc_ab ( temp_size , 1 ) ; if ( ! temp ) { DRM_ERROR ( ""Failedtoallocatestorageforcopying"" ""inbin/renderCLs.\\n"" ) ; ret = - ENOMEM ; goto fail ; } bin = temp + bin_offset ; exec -> shader_rec_u = temp + shader_rec_offset ; exec -> uniforms_u = temp + uniforms_offset ; exec -> shader_state = temp + exec_size ; exec -> shader_state_size = args -> shader_rec_count ; if ( copy_from_user ( bin , ( void __user * ) ( uintptr_t ) args -> bin_cl , args -> bin_cl_size ) ) { ret = - EFAULT ; goto fail ; } if ( copy_from_user ( exec -> shader_rec_u , ( void __user * ) ( uintptr_t ) args -> shader_rec , args -> shader_rec_size ) ) { ret = - EFAULT ; goto fail
",0,511
1345,"static char * print_object ( cJSON * item , int depth , int fmt , printbuffer * p ) { char * * entries = 0 , * * names = 0 ; char * out = 0 , * ptr , * ret , * str ; int len = 7 , i = 0 , j ; cJSON * child = item -> child ; int numentries = 0 , fail = 0 ; while ( child ) numentries ++ , child = child -> next ; } if ( ! ( entries = ( char * * ) cJSON_malloc ( numentries * sizeof ( char * ) ) ) ) return 0 ; if ( ! ( names = ( char * * ) cJSON_malloc ( numentries * sizeof ( char * ) ) ) ) { cJSON_free ( entries ) ; return 0 ; } memset ( entries , 0 , sizeof ( char * ) * numentries ) ; memset ( names , 0 , sizeof ( char * ) * numentries ) ; child = item -> child ; ++ depth ; if ( fmt ) len += depth ; while ( child ) { if ( p ) str = print_string_ptr ( child -> string ) ; entries [ i ++ ] = ret = print_value ( child , depth , fmt ) ; if ( str && ret ) len += strlen ( ret ) + strlen ( str ) + 2 + ( fmt ? 2 + depth : 0 ) ; else fail = 1 ; child = child -> next ; } if ( ! fail ) { if ( p ) str = cJSON_malloc ( len ) ; if ( ! str ) fail = 1 ; } if ( fail ) { for ( i = 0 ; i < numentries ; i ) { if ( names [ i ] ) cJSON_free ( names [ i ] ) ; if ( entries [ i ] ) cJSON_free ( entries [ i ] ) ; } cJSON_free ( names ) ; cJSON_free ( entries ) ; return 0 ; } * out = '{' ; ptr = out + 1 ; if ( fmt ) * ptr ++ = '\\n' ; * ptr = 0 ; for ( i = 0 ; i < numentries ; i ) { if ( fmt ) for ( j = 0 ; j < depth ; ++ j ) * ptr ++ = '\\t' ; str = str + i ; if ( ! str ) strcpy ( ptr , str )
",0,511
1346,"static const u_char * ikev2_ID_print ( netdissect_options * ndo , u_char tpay , const struct isakmp_gen * ext , u_int item_len _U_ , const u_char * ep _U_ , uint32_t phase _U_ , uint32_t doi _U_ , uint32_t proto _U_ , int depth _U_ ) { struct ikev2_id id ; int id_len , idtype_len , i ; unsigned int dumpascii , dumphex ; const unsigned char * typedata ; if ( ndo -> ndo_vflag && 4 < id_len ) { ND_PRINT ( ( ndo , """" ) ) ; if ( ndo -> ndo_vflag && 4 < id_len ) { ND_PRINT ( ( ndo , """" ) ) ; if ( ! rawprint ( ndo , ( const uint8_t * ) ( ext + 1 ) , id_len - 4 ) ) goto trunc ; } idtype_len = id_len - sizeof ( struct ikev2_id ) ; dumpascii = 0 ; dumphex = 0 ; typedata = ( const unsigned char * ) ( ext ) + sizeof ( struct ikev2_id ) ; switch ( id . type ) { case ID_IPV4_ADDR : ND_PRINT ( ( ndo , ""ipv4:"" ) ) ; dumphex = 1 ; break ; case ID_FQDN : ND_PRINT ( ( ndo , ""fqdn:"" ) ) ; dumpascii = 1 ; break ; case ID_RFC822_ADDR : ND_PRINT ( ( ndo , ""rfc822:"" ) ) ; dumpascii = 1 ; break ; case ID_IPV6_ADDR : ND_PRINT ( ( ndo , ""ipv6:"" ) ) ; dumphex = 1 ; break ; case ID_DER_ASN1_DN : if ( ndo -> ndo_vflag && 2 < id_len ) { ND_PRINT ( ( ndo , """" ) ) ; if ( ndo -> ndo_vflag && 2 < id_len ) { ND_PRINT ( ( ndo , """" ) ) ; if ( ndo -> ndo_
",0,511
1347,"RD_BOOL ber_parse_header ( STREAM s , int tagval , uint32 * length ) { int tag , len ; if ( tagval > 0xff ) { in_uint16_be ( s , tag ) ; } else { in_uint8 ( s , tag ) ; } if ( tag != tagval ) { logger ( Core , Error , ""ber_parse_header(),expectedtag%d,got%d"" , tagval , tag ) ; return False ; } in_uint8 ( s , len ) ; if ( len & 0x80 ) { len &= ~ 0x80 ; * length = 0 ; while ( len -- ) next_be ( s , * length ) ; } else * length = len ; return s_check ( s ) ; }
",1,169
1348,"static unsigned int unix_dgram_poll ( struct file * file , struct socket * sock , poll_table * wait ) { struct sock * sk = sock -> sk , * other ; unsigned int mask , writable ; sock_poll_wait ( file , sk_sleep ( sk ) , wait ) ; mask = 0 ; if ( sk -> sk_err || ! skb_queue_empty ( & sk -> sk_error_queue ) ) mask |= POLLERR | ( sock_flag ( sk , SOCK_SELECT_ERR_QUEUE ) ? POLLPRI : 0 ) ; if ( sk -> sk_shutdown & RCV_SHUTDOWN ) mask |= POLLRDHUP | POLLIN | POLLRDNORM ; if ( sk -> sk_shutdown == SHUTDOWN_MASK ) mask |= POLLHUP ; if ( ! skb_queue_empty ( & sk -> sk_receive_queue ) ) mask |= POLLIN | POLLRDNORM ; if ( sk -> sk_type == SOCK_SEQPACKET ) { if ( sk -> sk_state == TCP_CLOSE ) mask |= POLLHUP ; if ( sk -> sk_state == TCP_SYN_SENT ) return mask ; } if ( ! ( poll_requested_events ( wait ) & ( POLLWRBAND | POLLWRNORM | POLLOUT ) ) ) return mask ; writable = unix_writable ( sk ) ; other = unix_peer_get ( sk ) ; if ( other ) { if ( unix_peer ( other ) != sk ) { sock_poll_wait ( file , & unix_sk ( other ) -> peer_wait , wait ) ; if ( unix_recvq_full ( other ) ) writable = 0 ; } sock_put ( other ) ; } if ( writable ) mask |= POLLOUT | POLLWRNORM | POLLWRBAND ; else set_bit ( SOCK_ASYNC_NOSPACE , & sk -> sk_socket -> flags ) ; return mask ; }
",0,466
1349,"static inline signed int ReadPropertyMSBLong ( const unsigned char * * p , size_t * length ) { union { unsigned int unsigned_value ; signed int signed_value ; } quantum ; int c ; register ssize_t i ; unsigned char buffer [ 4 ] ; unsigned int value ; if ( * length < 4 ) return ( - 1 ) ; for ( i = 0 ; i < 4 ; i ++ ) { c = ( int ) ( * ( * p ) ++ ) ; ( * length ) -- ; buffer [ i ] = ( unsigned char ) c ; } value = ( unsigned int ) buffer [ 0 ] << 24 ; value |= ( unsigned int ) buffer [ 1 ] << 16 ; value |= ( unsigned int ) buffer [ 2 ] << 8 ; value |= ( unsigned int ) buffer [ 3 ] ; quantum . unsigned_value = value & 0xffffffff ) ; return ( quantum . signed_value ) ; }
",1,199
1350,"void Rectangle ( double x , double y , double w , double h ) { sprintf ( outputbuffer , ""\\n%12.3f%12.3f%12.3f%12.3fre"" , x , y , w , h ) ; sendClean ( outputbuffer ) ; }
",1,66
1351,"static struct sk_buff * batadv_frag_merge_packets ( struct hlist_head * chain , struct sk_buff * skb ) { struct batadv_frag_packet * packet ; struct batadv_frag_list_entry * entry ; struct sk_buff * skb_out = NULL ; int size , hdr_size = sizeof ( struct batadv_frag_packet ) ; packet = ( struct batadv_frag_packet * ) skb -> data ; size = ntohs ( packet -> total_size ) ; if ( size > batadv_frag_size_limit ( ) ) goto free ; entry = hlist_entry ( chain -> first , struct batadv_frag_list_entry , list ) ; hlist_del ( & entry -> list ) ; skb_out = entry -> skb ; kfree ( entry ) ; if ( pskb_expand_head ( skb_out , 0 , size - skb -> len , GFP_ATOMIC ) < 0 ) { kfree_skb ( skb_out ) ; skb_out = NULL ; goto free ; } skb_pull_rcsum ( skb_out , hdr_size ) ; memmove ( skb_out -> data - ETH_HLEN , skb_mac_header ( skb_out ) , ETH_HLEN ) ; skb_set_mac_header ( skb_out , - ETH_HLEN ) ; skb_reset_network_header ( skb_out ) ; skb_reset_transport_header ( skb_out ) ; hlist_for_each_entry ( entry , chain , list ) { size = entry -> skb -> len - hdr_size ; memcpy ( skb_put ( skb_out , size ) , entry -> skb -> data + hdr_size , size ) ; } free : batadv_frag_clear_chain ( chain ) ; return skb_out ; }
",0,447
1352,"void exit_io_context ( struct task_struct * task ) { struct io_context * ioc ; task_lock ( task ) ; ioc = current -> io_context ; task -> io_context = NULL ; task_unlock ( task ) ; if ( atomic_dec_and_test ( & ioc -> nr_tasks ) ) { if ( ioc -> aic && ioc -> aic -> exit ) ioc -> aic -> exit ( ioc -> aic ) ; cfq_exit ( ioc ) ; } put_io_context ( ioc ) ; }
",1,130
1353,"int ptrace_setxregs ( struct task_struct * child , void __user * uregs ) { struct thread_info * ti = task_thread_info ( child ) ; struct pt_regs * regs = task_pt_regs ( child ) ; elf_xtregs_t * xtregs = uregs ; int ret = 0 ; # if XTENSA_HAVE_COPROCESSORS coprocessor_flush_all ( ti ) ; coprocessor_release_all ( ti ) ; ret |= __copy_from_user ( & ti -> xtregs_cp , & xtregs -> cp0 , sizeof ( xtregs_coprocessor_t ) ) ; # endif ret |= __copy_from_user ( & regs -> xtregs_opt , & xtregs -> opt , sizeof ( xtregs -> opt ) ) ; ret |= __copy_from_user ( & ti -> xtregs_user , & xtregs -> user , sizeof ( xtregs -> user ) ) ; return ret ? - EFAULT : 0 ; }
",0,258
1354,"static OM_uint32 kg_unseal_v1_iov ( krb5_context context , OM_uint32 * minor_status , krb5_gss_ctx_id_rec * ctx , gss_iov_buffer_desc * iov , int iov_count , size_t token_wrapper_len , int * conf_state , gss_qop_t * qop_state , int toktype ) { OM_uint32 code ; gss_iov_buffer_t header ; gss_iov_buffer_t trailer ; unsigned char * ptr ; int sealalg ; int signalg ; krb5_checksum cksum ; krb5_checksum md5cksum ; size_t cksum_len = 0 ; size_t conflen = 0 ; int direction ; krb5_ui_4 seqnum ; OM_uint32 retval ; size_t sumlen ; krb5_keyusage sign_usage = KG_USAGE_SIGN ; md5cksum . length = cksum . length = 0 ; md5cksum . contents = cksum . contents = NULL ; header = kg_locate_header_iov ( iov , iov_count , toktype ) ; assert ( header != NULL ) ; trailer = kg_locate_iov ( iov , iov_count , GSS_IOV_BUFFER_TYPE_TRAILER ) ; if ( trailer != NULL && trailer -> buffer . length != 0 ) { * minor_status = ( OM_uint32 ) KRB5_BAD_MSIZE ; return GSS_S_DEFECTIVE_TOKEN ; } if ( header -> buffer . length < token_wrapper_len + 14 ) { * minor_status = 0 ; return GSS_S_DEFECTIVE_TOKEN ; } ptr = ( unsigned char * ) header -> buffer . value + token_wrapper_len ; signalg = ptr [ 0 ] ; signalg |= ptr [ 1 ] << 8 ; sealalg = ptr [ 2 ] ; sealalg |= ptr [ 3 ] << 8 ; if ( ptr [ 4 ] != 0xFF || ptr [ 5 ] != 0xFF ) { * minor_status = 0 ; return GSS_S_DEFECTIVE_TOKEN ; } if ( ptr [ 4
",0,511
1355,"static int command_read ( struct pci_dev * dev , int offset , u16 * value , void * data ) { int ret = pci_read_config_word ( dev , offset , value , data ) ; if ( ! pci_is_enabled ( dev ) ) return ret ; for ( i = 0 ; i < PCI_ROM_RESOURCE ; i ++ ) { if ( dev -> resource [ i ] . flags & IORESOURCE_IO ) * value |= cmd -> val & ~ PCI_COMMAND_GUEST ; return ret ; }
",1,121
1356,"static vpx_codec_err_t ctrl_get_reference ( vpx_codec_alg_priv_t * ctx , va_list args ) { vp9_ref_frame_t * frame = va_arg ( args , vp9_ref_frame_t * ) ; if ( frame != NULL ) { VPxWorker * const worker = ctx -> worker ; FrameWorkerData * const frame_worker_data = ( FrameWorkerData * ) worker -> data1 ; vpx_get_reference_enc ( ctx -> cpi , frame -> idx , & frame_worker_data -> img , fb ) ; yuvconfig2image ( & frame -> img , fb , NULL ) ; return VPX_CODEC_OK ; } else { return VPX_CODEC_INVALID_PARAM ; } }
",0,193
1357,"void __scm_destroy ( struct scm_cookie * scm ) { struct scm_fp_list * fpl = scm -> fp ; int i ; if ( fpl ) { scm -> fp = NULL ; for ( i = fpl -> count - 1 ; i >= 0 ; i -- ) fput ( fpl -> fp [ i ] ) ; free_uid ( fpl -> user ) ; kfree ( fpl ) ; } }
",1,102
1358,"long do_io_submit ( aio_context_t ctx_id , long nr , struct iocb __user * __user * iocbpp , bool compat ) { struct kioctx * ctx ; long ret = 0 ; int i = 0 ; struct blk_plug plug ; struct kiocb_batch batch ; if ( unlikely ( nr < 0 ) ) return - EINVAL ; if ( unlikely ( nr > LONG_MAX / sizeof ( * iocbpp ) ) ) nr = LONG_MAX / sizeof ( * iocbpp ) ; if ( unlikely ( ! access_ok ( VERIFY_READ , iocbpp , ( nr * sizeof ( * iocbpp ) ) ) ) ) return - EFAULT ; ctx = lookup_ioctx ( ctx_id ) ; if ( unlikely ( ! ctx ) ) { pr_debug ( ""EINVAL:io_submit:invalidcontextid\\n"" ) ; return - EINVAL ; } kiocb_batch_init ( & batch , nr ) ; blk_start_plug ( & plug ) ; for ( i = 0 ; i < nr ; i ++ ) { struct iocb __user * user_iocb ; struct iocb tmp ; if ( unlikely ( __get_user ( user_iocb , iocbpp + i ) ) ) { ret = - EFAULT ; break ; } if ( unlikely ( copy_from_user ( & tmp , user_iocb , sizeof ( tmp ) ) ) ) { ret = - EFAULT ; break ; } ret = io_submit_one ( ctx , user_iocb , & tmp , & batch , compat ) ; if ( ret ) break ; } blk_finish_plug ( & plug ) ; put_ioctx ( ctx ) ; return i ? i : ret ; }
",0,414
1359,"void dwc3_gadget_giveback ( struct dwc3_ep * dep , struct dwc3_request * req , int status ) { struct dwc3 * dwc = dep -> dwc ; dwc3_gadget_del_and_unmap_request ( dep , req , status ) ; spin_unlock ( & dwc -> lock ) ; }
",1,85
1360,"int yyparse ( void ) # else int yyparse ( ) # endif # endif { int yystate ; int yyerrstatus ; yytype_int16 yyssa [ YYINITDEPTH ] ; yytype_int16 * yyss ; yytype_int16 * yyssp ; YYSTYPE yyvsa [ YYINITDEPTH ] ; YYSTYPE * yyvs ; YYSTYPE * yyvsp ; YYSIZE_T yystacksize ; int yyn ; int yyresult ; int yytoken ; YYSTYPE yyval ; # if YYERROR_VERBOSE char yymsgbuf [ 128 ] ; char * yymsg = yymsgbuf ; YYSIZE_T yymsg_alloc = sizeof yymsgbuf ; # endif # define YYPOPSTACK ( N ) ( yyvsp -= ( N ) , yyssp -= ( N ) ) int yylen = 0 ; yytoken = 0 ; yyss = yyssa ; yyvs = yyvsa ; yystacksize = YYINITDEPTH ; YYDPRINTF ( ( stderr , ""Startingparse\\n"" ) ) ; yystate = 0 ; yyerrstatus = 0 ; yynerrs = 0 ; yychar = YYEMPTY ; yyssp = yyss ; yyvsp = yyvs ; goto yysetstate ; yynewstate : yyssp ++ ; yysetstate : * yyssp = yystate ; if ( yyss + yystacksize - 1 <= yyssp ) { YYSIZE_T yysize = yyssp - yyss + 1 ; # ifdef yyoverflow { YYSTYPE * yyvs1 = yyvs ; yytype_int16 * yyss1 = yyss ; yyoverflow ( YY_ ( ""memoryexhausted"" ) , & yyss1 , yysize * sizeof ( * yyssp ) , & yyvs1 , yysize * sizeof ( * yyvsp ) , & yystacksize ) ; yyss = yyss1 ; yyvs = yyvs1 ; } # else #
",0,511
1361,"void sas_init_disc ( struct sas_discovery * disc , struct asd_sas_port * port ) { int i ; static const work_func_t sas_event_fns [ DISC_NUM_EVENTS ] = { [ DISCE_DISCOVER_DOMAIN ] = sas_discover_domain , [ DISCE_REVALIDATE_DOMAIN ] = sas_revalidate_domain , [ DISCE_SUSPEND ] = sas_suspend_devices , [ DISCE_RESUME ] = sas_resume_devices , [ DISCE_DESTRUCT ] = sas_destruct_devices , } ; disc -> pending = 0 ; for ( i = 0 ; i < DISC_NUM_EVENTS ; i ++ ) { INIT_SAS_WORK ( & disc -> disc_work [ i ] . work , sas_event_fns [ i ] ) ; disc -> disc_work [ i ] . port = port ; } }
",1,225
1362,"int mi_repair_by_sort ( MI_CHECK * param , register MI_INFO * info , const char * name ) { int got_error ; uint i ; ulong length ; ha_rows start_records ; my_off_t new_header_length , del ; File new_file ; MI_SORT_PARAM sort_param ; MYISAM_SHARE * share = info -> s ; HA_KEYSEG * keyseg ; ulong * rec_per_key_part ; char llbuff [ 22 ] ; SORT_INFO sort_info ; ulonglong UNINIT_VAR ( key_map ) ; DBUG_ENTER ( ""mi_repair_by_sort"" ) ; start_records = info -> state -> records ; got_error = 1 ; new_file = - 1 ; new_header_length = ( param -> testflag & T_UNPACK ) ? 0 : share -> pack . header_length ; if ( ! ( param -> testflag & T_SILENT ) ) { printf ( ""-recovering(withsort)MyISAM-table\'%s\'\\n"" , name ) ; printf ( ""Datarecords:%s\\n"" , llstr ( start_records , llbuff ) ) ; } param -> testflag |= T_REP ; if ( info -> s -> options & ( HA_OPTION_CHECKSUM | HA_OPTION_COMPRESS_RECORD ) ) param -> testflag |= T_CALC_CHECKSUM ; bzero ( ( char * ) & sort_info , sizeof ( sort_info ) ) ; bzero ( ( char * ) & sort_param , sizeof ( sort_param ) ) ; if ( ! ( sort_info . key_block = alloc_key_blocks ( param , ( uint ) param -> sort_key_blocks , share -> base . max_key_block_length ) ) || init_io_cache ( & param -> read_cache , info -> dfile , ( uint ) param -> read_buffer_length , READ_CACHE , share -> pack . header_length , 1 , MYF ( MY_WME ) ) || ( ! rep_quick && init_io_cache ( & info -> rec_cache , info -> dfile , ( uint ) param -> read_buffer_
",0,511
1363,"static int uECC_sign_with_k ( const uint8_t * private_key , const uint8_t * message_hash , unsigned hash_size , uECC_word_t * k , uint8_t * signature , uECC_Curve curve ) { uECC_word_t tmp [ uECC_MAX_WORDS ] ; uECC_word_t s [ uECC_MAX_WORDS ] ; uECC_word_t * k2 [ 2 ] = { tmp , s } ; uECC_word_t * p ) = ( uECC_word_t * ) signature ; # else uECC_word_t p [ uECC_MAX_WORDS * 2 ] ; # endif uECC_word_t carry ; wordcount_t num_words = curve -> num_words ; wordcount_t num_n_words = BITS_TO_WORDS ( curve -> num_n_bits ) ; bitcount_t num_n_bits = curve -> num_n_bits ; if ( uECC_vli_isZero ( k , num_words ) || uECC_vli_cmp ( curve -> n , k , num_n_words ) != 1 ) { return 0 ; } carry = regularize_k ( k , tmp , s , curve ) ; EccPoint_mult ( p , curve -> G , k2 [ ! carry ] , 0 , num_n_bits + 1 , curve ) ; if ( uECC_vli_isZero ( p , num_words ) ) { return 0 ; } if ( ! g_rng_function ) { uECC_vli_clear ( tmp , num_n_words ) ; tmp [ 0 ] = 1 ; } else if ( ! uECC_generate_random_int ( tmp , curve -> n , num_n_words ) ) { return 0 ; } uECC_vli_modMult ( k , k , tmp , curve -> n , num_n_words ) ; uECC_vli_modInv ( k , k , curve -> n , num_n_words ) ; uECC_vli_modMult ( k , k , curve -> n , num_n_words ) ; uECC_vli_
",0,511
1364,"static void rpl_daoack_print ( netdissect_options * ndo , const u_char * bp , u_int length ) { const struct nd_rpl_daoack * daoack = ( const struct nd_rpl_daoack * ) bp ; const char * dagid_str = ""<elided>"" ; ND_TCHECK2 ( * daoack , ND_RPL_DAOACK_MIN_LEN ) ; if ( length < ND_RPL_DAOACK_MIN_LEN ) goto tooshort ; bp += ND_RPL_DAOACK_MIN_LEN ; length -= ND_RPL_DAOACK_MIN_LEN ; if ( RPL_DAOACK_D ( daoack -> rpl_flags ) ) { ND_TCHECK2 ( daoack -> rpl_dagid , DAGID_LEN ) ; if ( length < DAGID_LEN ) goto tooshort ; dagid_str = ip6addr_string ( ndo , ""%s"" , rpl_tstr ) ) ; if ( ndo -> ndo_vflag > 1 ) { const struct rpl_dio_genoption * opt = ( const struct rpl_dio_genoption * ) bp ; rpl_dio_printopt ( ndo , opt , length ) ; } return ; trunc : ND_PRINT ( ( ndo , ""[|dao-truncated]"" ) ) ; return ; tooshort : ND_PRINT ( ( ndo , ""[|dao-lengthtooshort]"" ) ) ; return ; }
",1,369
1365,"int ping_recvmsg ( struct kiocb * iocb , struct sock * sk , struct msghdr * msg , size_t len , int noblock , int flags , int * addr_len ) { struct inet_sock * isk = inet_sk ( sk ) ; int family = sk -> sk_family ; struct sk_buff * skb ; int copied , err ; pr_debug ( ""ping_recvmsg(sk=%p,sk->num=%u)\\n"" , isk , isk -> inet_num ) ; err = - EOPNOTSUPP ; if ( flags & MSG_OOB ) goto out ; if ( flags & MSG_ERRQUEUE ) { if ( family == AF_INET ) { struct sockaddr_in * addr_len = sizeof ( * sin ) ; else if ( family == AF_INET6 && addr_len ) * addr_len = sizeof ( * sin6 ) ; } if ( flags & MSG_ERRQUEUE ) { if ( family == AF_INET ) { return ip_recv_error ( sk , msg , len ) ; # if IS_ENABLED ( CONFIG_IPV6 ) } else if ( family == AF_INET6 ) { return pingv6_ops . ipv6_recv_error ( sk , msg , len ) ; # endif } } skb = skb_recv_datagram ( sk , flags , noblock , & err ) ; if ( ! skb ) goto out ; copied = skb -> len ; if ( copied > len ) { msg -> msg_flags |= MSG_TRUNC ; copied = len ; } err = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; if ( err ) goto done ; sock_recv_timestamp ( msg , sk , skb ) ; if ( family == AF_INET ) { sin = ( struct sockaddr_in * ) msg -> msg_name ; sin -> sin_family = AF_INET ; sin -> sin_port = 0 ; sin -> sin_addr . s_addr = ip_hdr ( skb ) -> saddr ; memset ( sin -> sin_zero , 0 , sizeof ( * addr_len ) ) ; }
",0,510
1366,"static long ext4_zero_range ( struct file * file , loff_t offset , loff_t len , int mode ) { struct inode * inode = file_inode ( file ) ; handle_t * handle = NULL ; unsigned int max_blocks ; loff_t new_size = 0 ; int ret = 0 ; int flags ; int credits ; int partial_begin , partial_end ; loff_t start , end ; ext4_lblk_t lblk ; struct address_space * mapping = inode -> i_mapping ; unsigned int blkbits = inode -> i_blkbits ; trace_ext4_zero_range ( inode , offset , len , mode ) ; if ( ! S_ISREG ( inode -> i_mode ) ) return - EINVAL ; if ( ext4_should_journal_data ( inode ) ) { ret = ext4_force_commit ( inode -> i_sb ) ; if ( ret ) return ret ; } if ( mapping -> nrpages && mapping_tagged ( mapping , PAGECACHE_TAG_DIRTY ) ) { ret = filemap_write_and_wait_range ( mapping , offset , offset + len - 1 ) ; if ( ret ) return ret ; } start = round_up ( offset , 1 << blkbits ) ; end = round_down ( ( offset + len ) , 1 << blkbits ) ; if ( start < offset || end > offset + len ) return - EINVAL ; partial_begin = offset & ( ( 1 << blkbits ) - 1 ) ; partial_end = ( offset + len ) & ( ( 1 << blkbits ) - 1 ) ; lblk = start >> blkbits ; max_blocks = ( end >> blkbits ) ; if ( max_blocks < lblk ) max_blocks = 0 ; else max_blocks -= lblk ; mutex_lock ( & inode -> i_mutex ) ; if ( ! ( ext4_test_inode_flag ( inode , EXT4_INODE_EXTENTS ) ) ) { ret = - EOPNOTSUPP ; goto out_mutex ; } if ( mode & FALLOC_FL_KEEP_SIZE ) flags |= EXT4_GET_BLOCKS_KEEP_
",0,511
1367,"void nw_buf_free ( nw_buf_pool * pool , nw_buf * buf ) { if ( pool -> free < pool -> free_total ) { pool -> free_arr [ pool -> free ++ ] = buf ; } else { uint32_t new_free_total = pool -> free_total * 2 ; void * new_arr = realloc ( pool -> free_arr , new_free_total * sizeof ( nw_buf * ) ) ; if ( new_arr ) { pool -> free_total = new_free_total ; pool -> free_arr = new_arr ; pool -> free_arr [ pool -> free ++ ] = buf ; } else { free ( buf ) ; } } }
",0,159
1368,"struct bpf_map * bpf_map_get_with_uref ( u32 ufd ) { struct fd f = fdget ( ufd ) ; struct bpf_map * map ; map = __bpf_map_get ( f ) ; if ( IS_ERR ( map ) ) return map ; bpf_map_inc ( map , true ) ; fdput ( f ) ; return map ; }
",0,99
1369,"STATIC_OVL void escapes ( cp , tp ) const char * cp ; char * tp ; { while ( * cp ) { cp ++ ; int cval = 0 , meta = 0 ; if ( * cp == '\\\\' && cp [ 1 ] && index ( ""mM"" , cp [ 1 ] ) && cp [ 2 ] ) { meta = 1 ; cp += 2 ; } if ( * cp == '\\\\' && cp [ 1 ] && index ( ""0123456789xXoO"" , cp [ 1 ] ) && cp [ 2 ] ) { NEARATA const char hex [ ] = ""00112233445566778899aAbBcCdDeEfF"" ; const char * dp ; cp ++ ; if ( * cp == 'x' || * cp == 'X' ) for ( ++ cp ; * cp && ( dp = index ( hex , * cp ) ) && ( dcount ++ < 2 ) ; cp ++ ) cval = ( cval * 16 ) + ( ( int ) ( dp - hex ) / 2 ) ; else if ( * cp == 'o' || * cp == 'O' ) for ( ++ cp ; * cp && ( index ( ""01234567"" , * cp ) ) && ( dcount ++ < 3 ) ; cp ++ ) cval = ( cval * 8 ) + ( * cp - '0' ) ; } else if ( * cp == '\\\\' && cp [ 1 ] ) { switch ( * ++ cp ) { case '\\\\' : cval = '\\\\' ; break ; case 'n' : cval = '\\n' ; break ; case 't' : cval = '\\t' ; break ; case 'b' : cval = '\\b' ; break ; case 'r' : cval = '\\r' ; break ; default : cval = * cp ; } cp ++ ; } } }
",0,421
1370,"int file_is_y4m ( const char detect [ 4 ] ) { if ( memcmp ( detect , ""YUV4"" , 4 ) == 0 ) { return 1 ; } return 0 ; }
",0,45
1371,"static void Process_ipfix_template_add ( exporter_ipfix_domain_t * exporter , void * DataPtr , uint32_t size_left , FlowSource_t * fs ) { input_translation_t * translation_table ; ipfix_template_record_t * ipfix_template_record ; ipfix_template_elements_std_t * NextElement ; int i ; while ( size_left ) { uint32_t table_id , count , size_required ; uint32_t num_extensions = 0 ; if ( size_left < 4 ) { LogError ( ""Process_ipfix[%u]Templatesizeerrorat%sline%u"" , exporter -> info . id , __FILE__ , __LINE__ , strerror ( errno ) ) ; size_left = 0 ; continue ; } ipfix_template_record = ( ipfix_template_record_t * ) DataPtr ; size_left -= 4 ; table_id = ntohs ( ipfix_template_record -> TemplateID ) ; count = ntohs ( ipfix_template_record -> FieldCount ) ; dbg_printf ( ""\\n[%u]TemplateID:%u\\n"" , exporter -> info . id , table_id ) ; dbg_printf ( ""FieldCount:%ubuffersize:%u\\n"" , count , size_left ) ; memset ( ( void * ) cache . common_extensions , 0 , ( Max_num_extensions + 1 ) * sizeof ( uint32_t ) ) ; memset ( ( void * ) cache . lookup_info , 0 , 65536 * sizeof ( struct element_param_s ) ) ; for ( i = 1 ; ipfix_element_map [ i ] . id != 0 ; i ++ ) { uint32_t Type = ipfix_element_map [ i ] . id ; if ( ipfix_element_map [ i ] . id == ipfix_element_map [ i - 1 ] . id ) continue ; cache . lookup_info [ Type ] . index = i ; } cache . input_order = calloc ( count , sizeof ( struct order_s ) ) ; if ( ! cache . input_order ) { LogError ( ""Process_ipfix:Panic
",0,506
1372,"PIX * pixFewColorsOctcubeQuantMixed ( PIX * pixs , l_int32 level , l_int32 darkthresh , l_int32 lightthresh , l_int32 diffthresh , l_float32 minfract , l_int32 maxspan ) { l_int32 i , j , w , h , wplc , wplm , wpld , ncolors , index ; l_int32 rval , gval , bval , val , minval , maxval ; l_int32 * lut ; l_uint32 * datac , * datam , * datad , * linec , * linem , * lined ; PIX * pixc , * pixm , * pixg , * pixd ; PIXCMAP * cmap , * cmapd ; PROCNAME ( ""pixFewColorsOctcubeQuantMixed"" ) ; if ( ! pixs || pixGetDepth ( pixs ) != 32 ) return ( PIX * ) ERROR_PTR ( ""pixsundefinedornot32bpp"" , procName , NULL ) ; if ( level <= 0 ) level = 3 ; if ( level > 6 ) return ( PIX * ) ERROR_PTR ( ""invalidlevel"" , procName , NULL ) ; if ( darkthresh <= 0 ) darkthresh = 20 ; if ( lightthresh <= 0 ) lightthresh = 244 ; if ( diffthresh <= 0 ) diffthresh = 20 ; if ( minfract <= 0.0 ) minfract = 0.05 ; if ( maxspan <= 2 ) maxspan = 15 ; if ( ( pixc = pixFewColorsOctcubeQuant1 ( pixs , level ) ) == NULL ) return ( PIX * ) ERROR_PTR ( ""toomanycolors"" , procName , NULL ) ; cmap = pixGetColormap ( pixc ) ; ncolors = pixcmapGetCount ( cmap ) ; cmapd = pixcmapCreate ( 8 ) ; lut = ( l_int32 * ) LEPT_CALLOC ( 256 , sizeof ( l_int32 ) ) ; for ( i = 0 ; i < 256 ; i ++ ) lut [ i ] . lut [
",0,511
1373,"int BN_GF2m_mod_inv ( BIGNUM * r , const BIGNUM * a , const BIGNUM * p , BN_CTX * ctx ) { BIGNUM * b , * c = NULL , * u = NULL , * v = NULL , * tmp ; int ret = 0 ; bn_check_top ( a ) ; bn_check_top ( p ) ; BN_CTX_start ( ctx ) ; if ( ( b = BN_CTX_get ( ctx ) ) == NULL ) goto err ; if ( ( c = BN_CTX_get ( ctx ) ) == NULL ) goto err ; if ( ( u = BN_CTX_get ( ctx ) ) == NULL ) goto err ; if ( ( v = BN_CTX_get ( ctx ) ) == NULL ) goto err ; if ( ! BN_GF2m_mod ( u , a , p ) ) goto err ; if ( BN_is_zero ( u ) ) goto err ; if ( ! BN_copy ( v , p ) ) goto err ; # if 0 if ( ! BN_one ( b ) ) goto err ; while ( 1 ) { while ( ! BN_is_odd ( u ) ) { if ( BN_is_zero ( u ) ) goto err ; if ( ! BN_rshift1 ( u , u ) ) goto err ; if ( BN_is_odd ( b ) ) { if ( ! BN_GF2m_add ( b , b , p ) ) goto err ; } if ( ! BN_rshift1 ( b , b ) ) goto err ; } if ( BN_abs_is_word ( u , 1 ) ) break ; if ( BN_num_bits ( u ) < BN_num_bits ( v ) ) { tmp = u ; u = v ; v = tmp ; tmp = b ; b = c ; c = tmp ; } if ( ! BN_GF2m_add ( u , u , v ) ) goto err ; if ( ! BN_GF2m_add ( b , b , c ) ) goto err ; } # else { int i , ubits = BN_num_bits ( u ) , vbits = BN_num_
",0,511
1374,"static void first_pass_motion_search ( VP8_COMP * cpi , MACROBLOCK * x , int_mv * ref_mv , MV * best_mv , YV12_BUFFER_CONFIG * recon_buffer , int * best_motion_err , int recon_yoffset ) { MACROBLOCKD * const xd = & x -> e_mbd ; BLOCK * b = & x -> block [ 0 ] ; BLOCKD * d = & x -> e_mbd . block [ 0 ] ; int num00 ; int_mv tmp_mv ; int_mv ref_mv_full ; int tmp_err ; int step_param = 3 ; int further_steps = ( MAX_MVSEARCH_STEPS - 1 ) - step_param ; int n ; vp8_variance_fn_ptr_t v_fn_ptr = cpi -> fn_ptr [ BLOCK_16X16 ] ; int new_mv_mode_penalty = 256 ; v_fn_ptr . vf = vp8_mse16x16 ; xd -> pre . y_buffer = recon_buffer -> y_buffer + recon_yoffset ; tmp_mv . as_int = 0 ; ref_mv_full . as_mv . col = ref_mv -> as_mv . col >> 3 ; ref_mv_full . as_mv . row = ref_mv -> as_mv . row >> 3 ; tmp_err = cpi -> diamond_search_sad ( x , b , d , & ref_mv_full , & tmp_mv , step_param , x -> sadperbit16 , & num00 , & v_fn_ptr , x -> mvcost , ref_mv ) ; if ( tmp_err < INT_MAX - new_mv_mode_penalty ) tmp_err += new_mv_mode_penalty ; if ( tmp_err < * best_motion_err ) { * best_motion_err = tmp_err ; best_mv -> row = tmp_mv . as_mv . row ; best_mv -> col = tmp_mv . as_mv . col ; } n = num00 ; if
",0,511
1375,"static int crypto_report_kpp ( struct sk_buff * skb , struct crypto_alg * alg ) { struct crypto_report_kpp rkpp ; strncpy ( rkpp . type , ""kpp"" , sizeof ( rkpp . type ) ) ; if ( nla_put ( skb , CRYPTOCFGA_REPORT_KPP , sizeof ( struct crypto_report_kpp ) , & rkpp ) ) goto nla_put_failure ; return 0 ; nla_put_failure : return - EMSGSIZE ; }
",1,130
1376,"char * curl_easy_escape ( CURL * handle , const char * string , int inlength ) { size_t alloc = ( inlength ? ( size_t ) inlength : strlen ( string ) ) + 1 ; char * ns ; char * testing_ptr = NULL ; unsigned char in ; size_t newlen = alloc ; size_t strindex = 0 ; size_t length ; CURLcode res ; ns = malloc ( alloc ) ; if ( ! ns ) return NULL ; length = alloc - 1 ; while ( length -- ) { in = * string ; if ( Curl_isunreserved ( in ) ) ns [ strindex ++ ] = in ; else { newlen += 2 ; if ( newlen > alloc ) { alloc *= 2 ; testing_ptr = realloc ( ns , alloc ) ; if ( ! testing_ptr ) { free ( ns ) ; return NULL ; } else { ns = testing_ptr ; } } res = Curl_convert_to_network ( handle , & in , 1 ) ; if ( res ) { free ( ns ) ; return NULL ; } snprintf ( & ns [ strindex ] , 4 , ""%%%02X"" , in ) ; strindex += 3 ; } string ++ ; } ns [ strindex ] = 0 ; return ns ; }
",1,284
1377,"int MSG_ReadBits ( msg_t * msg , int bits ) { int value ; int get ; qboolean sgn ; int i , nbits ; if ( msg -> readcount > msg -> cursize ) { return 0 ; } value = 0 ; if ( bits < 0 ) { bits = - bits ; sgn = qtrue ; } else { sgn = qfalse ; } if ( msg -> oob ) { if ( msg -> readcount == msg -> cursize ) { value = msg -> data [ msg -> readcount ] ; msg -> readcount += 1 ; msg -> bit += 8 ; } else if ( bits == 16 ) { short temp ; CopyLittleShort ( & temp , & msg -> data [ msg -> readcount ] ) ; value = temp ; msg -> readcount += 2 ; msg -> bit += 16 ; } else if ( bits == 32 ) { CopyLittleLong ( & value , & msg -> data [ msg -> readcount ] ) ; msg -> readcount += 4 ; msg -> bit += 32 ; } else Com_Error ( ERR_DROP , ""can\'tread%dbits"" , bits ) ; } else { nbits = 0 ; if ( bits & 7 ) { nbits = bits & 7 ; for ( i = 0 ; i < nbits ; i ++ ) { value |= ( Huff_getBit ( msg -> data , & msg -> bit ) << i ) ; } bits = bits - nbits ; } if ( bits ) { for ( i = 0 ; i < bits ; i += 8 ) { Huff_offsetReceive ( msgHuff . decompressor . tree , & get , msg -> data , & msg -> bit ) ; value |= ( get << ( i + nbits ) ) ; } } msg -> readcount = ( msg -> bit >> 3 ) + 1 ; } if ( sgn && bits > 0 && bits < 32 ) { if ( value & ( 1 << ( bits - 1 ) ) ) { value |= - 1 ^ ( ( 1 << bits ) - 1 ) ; } } return value ; }
",0,444
1378,"int snd_ctl_add ( struct snd_card * card , struct snd_kcontrol * kcontrol ) { struct snd_ctl_elem_id id ; unsigned int idx ; unsigned int count ; int err = - EINVAL ; if ( ! kcontrol ) return err ; if ( snd_BUG_ON ( ! card || ! kcontrol -> info ) ) goto error ; id = kcontrol -> id ; down_write ( & card -> controls_rwsem ) ; if ( snd_ctl_find_id ( card , & id ) ) { up_write ( & card -> controls_rwsem ) ; dev_err ( card -> dev , ""control%i:%i:%i:%s:%iisalreadypresent\\n"" , id . iface , id . device , id . subdevice , id . name , id . index ) ; err = - EBUSY ; goto error ; } if ( snd_ctl_find_hole ( card , kcontrol -> count ) < 0 ) { up_write ( & card -> controls_rwsem ) ; err = - ENOMEM ; goto error ; } list_add_tail ( & kcontrol -> list , & card -> controls ) ; card -> controls_count += kcontrol -> count ; count = kcontrol -> count ; kcontrol -> id . numid = card -> last_numid + 1 ; card -> last_numid += kcontrol -> count ; up_write ( & card -> controls_rwsem ) ; for ( idx = 0 ; idx < count ; idx ++ , id . index ++ , id . numid ++ ) snd_ctl_notify ( card , SNDRV_CTL_EVENT_MASK_ADD , & id ) ; return 0 ; error : snd_ctl_free_one ( kcontrol ) ; return err ; }
",1,406
1379,"int usbnet_probe ( struct usb_interface * udev , const struct usb_device_id * prod ) { struct usbnet * dev ; struct net_device * net ; struct usb_host_interface * interface ; struct driver_info * info ; struct usb_device * xdev ; int status ; const char * name ; struct usb_driver * driver = to_usb_driver ( udev -> dev . driver ) ; if ( ! driver -> supports_autosuspend ) { driver -> supports_autosuspend = 1 ; pm_runtime_enable ( & udev -> dev ) ; } name = udev -> dev . driver -> name ; info = ( struct driver_info * ) prod -> driver_info ; if ( ! info ) { dev_dbg ( & udev -> dev , ""blacklistedby%s\\n"" , name ) ; return - ENODEV ; } xdev = interface_to_usbdev ( udev ) ; interface = udev -> cur_altsetting ; status = - ENOMEM ; net = alloc_etherdev ( sizeof ( * dev ) ) ; if ( ! net ) goto out ; SET_NETDEV_DEV ( net , & udev -> dev ) ; dev = netdev_priv ( net ) ; dev -> udev = xdev ; dev -> intf = udev ; dev -> driver_info = info ; dev -> driver_name = name ; dev -> msg_enable = netif_msg_init ( msg_level , NETIF_MSG_DRV | NETIF_MSG_PROBE | NETIF_MSG_LINK ) ; init_waitqueue_head ( & dev -> wait ) ; skb_queue_head_init ( & dev -> rxq ) ; skb_queue_head_init ( & dev -> txq ) ; skb_queue_head_init ( & dev -> done ) ; skb_queue_head_init ( & dev -> rxq_pause ) ; dev -> bh . func = usbnet_bh ; dev -> bh . data = ( unsigned long ) dev ; INIT_WORK ( & dev -> kevent , usbnet_deferred_kevent ) ; init_usb_anchor ( & dev -> deferred ) ; dev -> delay . function = usbnet_bh ; dev -> delay . data = ( unsigned long
",0,511
1380,"MONGO_EXPORT int mongo_insert_batch ( mongo * conn , const char * ns , const bson * * bsons , int count , mongo_write_concern * custom_write_concern , int flags ) { mongo_message * mm ; mongo_write_concern * write_concern = NULL ; int i ; char * data ; int overhead = 16 + 4 + strlen ( ns ) + 1 ; int size = sizeof ( mongo_data ) ; int size = overhead ; if ( mongo_validate_ns ( conn , ns ) != MONGO_OK ) return MONGO_ERROR ; for ( i = 0 ; i < count ; i ++ ) { size += bson_size ( bsons [ i ] ) ; if ( mongo_bson_valid ( conn , bsons [ i ] , 1 ) != MONGO_OK ) return MONGO_ERROR ; } if ( ( size - overhead ) > conn -> max_bson_size ) { conn -> err = MONGO_BSON_TOO_LARGE ; return MONGO_ERROR ; } if ( mongo_choose_write_concern ( conn , custom_write_concern , & write_concern ) == MONGO_ERROR ) { return MONGO_ERROR ; } mm = mongo_message_create ( size , 0 , 0 , MONGO_OP_INSERT ) ; data = & mm -> data ; if ( flags & MONGO_CONTINUE_ON_ERROR ) data = mongo_data_append32 ( data , & ONE ) ; else data = mongo_data_append32 ( data , & ZERO ) ; data = mongo_data_append ( data , ns , strlen ( ns ) + 1 ) ; for ( i = 0 ; i < count ; i ++ ) { data = mongo_data_append ( data , bsons [ i ] -> data , bson_size ( bsons [ i ] ) ) ; } if ( write_concern ) { if ( mongo_message_send ( conn , mm ) == MONGO_ERROR ) { return MONGO_ERROR ; } return mongo_check_last_error ( conn , ns , write_concern ) ; } else { return mongo_message_send ( conn , mm ) ; } }
",0,512
1381,"static void tv_details_row_activated ( GtkTreeView * tree_view , GtkTreePath * tree_path_UNUSED , GtkTreeViewColumn * column , gpointer user_data ) { gchar * item_name ; struct problem_item * item = get_current_problem_item_or_NULL ( tree_view , & item_name ) ; if ( ! item || ! ( item -> flags & CD_FLAG_TXT ) ) goto ret ; if ( ! strchr ( item -> content , '\\n' ) ) goto ret ; gint exitcode ; gchar * arg [ 3 ] ; arg [ 0 ] = ( char * ) ""xdg-open"" ; arg [ 1 ] = concat_path_file ( g_dump_dir_name , item_name ) ; arg [ 2 ] = NULL ; const gboolean spawn_ret = g_spawn_sync ( NULL , arg , NULL , G_SPAWN_SEARCH_PATH | G_SPAWN_STDOUT_TO_DEV_NULL , NULL , NULL , NULL , NULL , & exitcode , NULL ) ; if ( spawn_ret == FALSE || exitcode != EXIT_SUCCESS ) { GtkWidget * dialog = gtk_dialog_new_with_buttons ( _ ( ""View/editatextfile"" ) , GTK_WINDOW ( g_wnd_assistant ) , GTK_DIALOG_MODAL | GTK_DIALOG_DESTROY_WITH_PARENT , NULL , NULL ) ; GtkWidget * vbox = gtk_dialog_get_content_area ( GTK_DIALOG ( dialog ) ) ; GtkWidget * scrolled = gtk_scrolled_window_new ( NULL , NULL ) ; GtkWidget * textview = gtk_text_view_new ( ) ; gtk_dialog_add_button ( GTK_DIALOG ( dialog ) , _ ( ""_Save"" ) , GTK_RESPONSE_OK ) ; gtk_dialog_add_button ( GTK_DIALOG ( dialog ) , _ ( ""_Cancel"" ) , GTK_RESPONSE_CANCEL ) ; gtk_box_pack_start ( GTK_BOX ( vbox ) ,
",0,511
1382,"int handle ( int s , unsigned char * data , int len , struct sockaddr_in * s_in ) { char buf [ 2048 ] ; unsigned short * cmd = ( unsigned short * ) buf ; int plen ; struct in_addr * addr = & s_in -> sin_addr ; unsigned short * pid = ( unsigned short * ) data ; if ( len == S_HELLO_LEN && memcmp ( data , ""sorbo"" , 5 ) == 0 ) { unsigned short * id = ( unsigned short * ) ( data + 5 ) ; int x = 2 + 4 + 2 ; * cmd = htons ( S_CMD_INET_CHECK ) ; memcpy ( cmd + 1 , addr , 4 ) ; memcpy ( cmd + 1 + 2 , id , 2 ) ; printf ( ""Inetcheckby%s%d\\n"" , inet_ntoa ( * addr ) , ntohs ( * id ) ) ; if ( send ( s , buf , x , 0 ) != x ) return 1 ; return 0 ; } * cmd ++ = htons ( S_CMD_PACKET ) ; * cmd ++ = * pid ; plen = len - 2 ; if ( plen < 0 ) return 0 ; last_id = ntohs ( * pid ) ; if ( last_id > 20000 ) wrap = 1 ; if ( wrap && last_id < 100 ) { wrap = 0 ; memset ( ids , 0 , sizeof ( ids ) ) ; } printf ( ""Gotpacket%d%d"" , last_id , plen ) ; if ( is_dup ( last_id ) ) { printf ( ""(DUP)\\n"" ) ; return 0 ; } printf ( ""\\n"" ) ; * cmd ++ = htons ( plen ) ; memcpy ( cmd , data + 2 , plen ) ; plen += 2 + 2 + 2 ; assert ( plen <= ( int ) sizeof ( buf ) ) ; if ( send ( s , buf , plen , 0 ) != plen ) return 1 ; return 0 ; }
",1,459
1383,"static int v9fs_xattr_set_acl ( const struct xattr_handler * handler , struct dentry * dentry , struct inode * inode , const char * name , const void * value , size_t size , int flags ) { int retval ; struct posix_acl * acl ; struct v9fs_session_info * v9ses ; v9ses = v9fs_dentry2v9ses ( dentry ) ; if ( ( v9ses -> flags & V9FS_ACCESS_MASK ) != V9FS_ACCESS_CLIENT ) return v9fs_xattr_set ( dentry , handler -> name , value , size , flags ) ; if ( S_ISLNK ( inode -> i_mode ) ) return - EOPNOTSUPP ; if ( ! inode_owner_or_capable ( inode ) ) return - EPERM ; if ( value ) { acl = posix_acl_from_xattr ( & init_user_ns , value , size ) ; if ( IS_ERR ( acl ) ) return PTR_ERR ( acl ) ; else if ( acl ) { retval = posix_acl_valid ( inode -> i_sb -> s_user_ns , acl ) ; if ( retval ) goto err_out ; } } else acl = NULL ; switch ( handler -> flags ) { case ACL_TYPE_ACCESS : if ( acl ) { umode_t mode ; retval = posix_acl_update_mode ( inode , & mode ) ; if ( retval < 0 ) goto err_out ; } else { struct iattr iattr ; if ( retval == 0 ) { acl = NULL ; value = NULL ; size = 0 ; } iattr . ia_mode = ( ( mode & S_IALLUGO ) | ( inode -> i_mode & ~ S_IALLUGO ) ) ; iattr . ia_valid = ATTR_MODE ; v9fs_vfs_setattr_dotl ( dentry , & iattr ) ; } } break ; case ACL_TYPE_DEFAULT : if ( ! S_ISDIR ( inode -> i_mode ) ) { retval = acl ? - EINVAL : 0 ; goto err
",0,511
1384,"static int dex_loadcode ( RBinFile * arch , RBinDexObj * bin ) { struct r_bin_t * rbin = arch -> rbin ; int i ; int * methods = NULL ; int sym_count = 0 ; if ( ! bin || bin -> methods_list ) { return false ; } bin -> code_from = UT64_MAX ; bin -> code_to = 0 ; bin -> methods_list = r_list_newf ( ( RListFree ) free ) ; if ( ! bin -> methods_list ) { return false ; } bin -> imports_list = r_list_newf ( ( RListFree ) free ) ; if ( ! bin -> imports_list ) { r_list_free ( bin -> methods_list ) ; return false ; } bin -> classes_list = r_list_newf ( ( RListFree ) __r_bin_class_free ) ; if ( ! bin -> classes_list ) { r_list_free ( bin -> methods_list ) ; r_list_free ( bin -> imports_list ) ; return false ; } if ( bin -> header . method_size > bin -> size ) { bin -> header . method_size = 0 ; return false ; } bin -> header . method_size = R_MIN ( bin -> header . method_size , bin -> size ) ; bin -> header . class_size = R_MIN ( bin -> header . class_size , bin -> size ) ; bin -> header . strings_size = R_MIN ( bin -> header . strings_size , bin -> size ) ; if ( bin -> header . strings_size > bin -> size ) { eprintf ( ""Invalidstringssize\\n"" ) ; return false ; } if ( bin -> classes ) { ut64 amount = sizeof ( int ) * bin -> header . method_size ; if ( amount > UT32_MAX || amount < bin -> header . method_size ) { return false ; } methods = calloc ( 1 , amount + 1 ) ; for ( i = 0 ; i < bin -> header . class_size ; i ++ ) { char * super_name , * class_name ; struct dex_class_t * c = & bin -> classes [ i ] ; class_name = dex_class_name ( bin , c ) ; super_name = dex_class_super_name ( bin ,
",0,511
1385,"int rpc_type_of_NPPVariable ( int variable ) { int type ; switch ( variable ) { case NPPVpluginNameString : case NPPVpluginDescriptionString : case NPPVformValue : case NPPVpluginNativeAccessibleAtkPlugId : type = RPC_TYPE_STRING ; break ; case NPPVpluginWindowSize : case NPPVpluginTimerInterval : type = RPC_TYPE_INT32 ; break ; case NPPVpluginNeedsXEmbed : case NPPVpluginWindowBool : case NPPVpluginTransparentBool : case NPPVjavascriptPushCallerBool : case NPPVpluginKeepLibraryInMemory : case NPPVpluginUrlRequestsDisplayedBool : case NPPVpluginWantsAllNetworkStreams : case NPPVpluginCancelSrcStream : case NPPVSupportsAdvancedKeyHandling : type = RPC_TYPE_BOOLEAN ; break ; case NPPVpluginScriptableNPObject : type = RPC_TYPE_NP_OBJECT ; break ; default : type = RPC_ERROR_GENERIC ; break ; } return type ; }
",1,253
1386,"char * curl_easy_unescape ( CURL * handle , const char * string , int length , int * olen , char * curl_easy_unescape_options * options ) { int alloc = ( length ? length : ( int ) strlen ( string ) ) + 1 ; char * ns = malloc ( alloc ) ; unsigned char in ; int strindex = 0 ; unsigned long hex ; if ( ! ns ) return NULL ; while ( -- alloc > 0 ) { in = * string ; if ( ( '%' == in ) && ISXDIGIT ( string [ 1 ] ) && ISXDIGIT ( string [ 2 ] ) ) { char hexstr [ 3 ] ; char * ptr ; hexstr [ 0 ] = string [ 1 ] ; hexstr [ 1 ] = string [ 2 ] ; hexstr [ 2 ] = 0 ; hex = strtoul ( hexstr , & ptr , 16 ) ; in = curlx_ultouc ( hex ) ; if ( res ) { free ( ns ) ; return NULL ; } string += 2 ; alloc -= 2 ; } ns [ strindex ++ ] = in ; string ++ ; } ns [ strindex ] = 0 ; if ( olen ) * olen = strindex ; return ns ; }
",0,270
1387,"void nego_process_negotiation_response ( rdpNego * nego , wStream * s ) { UINT16 length ; WLog_DBG ( TAG , ""RDP_NEG_RSP"" ) ; if ( Stream_GetRemainingLength ( s ) < 7 ) { WLog_ERR ( TAG , ""InvalidRDP_NEG_RSP"" ) ; nego -> state = NEGO_STATE_FAIL ; return ; } Stream_Read_UINT8 ( s , nego -> flags ) ; Stream_Read_UINT16 ( s , length ) ; Stream_Read_UINT32 ( s , nego -> SelectedProtocol ) ; nego -> state = NEGO_STATE_FINAL ; }
",0,166
1388,"int vp9_rc_regulate_q ( const VP9_COMP * cpi , int target_bits_per_frame , int active_best_quality , int active_worst_quality ) { const VP9_COMMON * const cm = & cpi -> common ; int q = active_worst_quality ; int last_error = INT_MAX ; int i , target_bits_per_mb ; const double correction_factor = get_rate_correction_factor ( cpi ) ; target_bits_per_mb = ( ( uint64_t ) target_bits_per_frame << BPER_MB_NORMBITS ) / cm -> MBs ; i = active_best_quality ; do { const int bits_per_mb_at_this_q = ( int ) vpx_rc_bits_per_mb ( cm -> frame_type , i , correction_factor ) ; if ( bits_per_mb_at_this_q <= target_bits_per_mb ) { if ( ( target_bits_per_mb - bits_per_mb_at_this_q ) <= last_error ) q = i ; else q = i - 1 ; break ; } else { last_error = bits_per_mb_at_this_q - target_bits_per_mb ; } } while ( ++ i <= active_worst_quality ) ; return q ; }
",0,309
1389,"error_t tja1101Init ( NetInterface * interface ) { uint16_t value ; TRACE_INFO ( ""InitializingTJA1101...\\r\\n"" ) ; if ( interface -> phyAddr >= 32 ) { interface -> phyAddr = TJA1101_PHY_ADDR ; } if ( interface -> smiDriver != NULL ) { interface -> smiDriver -> init ( ) ; } if ( interface -> extIntDriver != NULL ) { interface -> extIntDriver -> init ( ) ; } tja1101WritePhyReg ( interface , TJA1101_BASIC_CTRL , TJA1101_BASIC_CTRL_RESET ) ; while ( tja1101ReadPhyReg ( interface , TJA1101_BASIC_CTRL ) & TJA1101_BASIC_CTRL_RESET ) { } tja1101DumpPhyReg ( interface ) ; value = tja1101ReadPhyReg ( interface , TJA1101_EXTENDED_CTRL ) ; value |= TJA1101_EXTENDED_CTRL_CONFIG_EN ; tja1101WritePhyReg ( interface , TJA1101_EXTENDED_CTRL , value ) ; value = tja1101ReadPhyReg ( interface , TJA1101_CONFIG1 ) ; value &= ~ TJA1101_CONFIG1_MII_MODE ; value |= TJA1101_CONFIG1_MII_MODE_RMII_25MHZ ; tja1101WritePhyReg ( interface , TJA1101_CONFIG1 , value ) ; value = tja1101ReadPhyReg ( interface , TJA1101_COMM_CTRL ) ; value |= TJA1101_COMM_CTRL_AUTO_OP ; tja1101WritePhyReg ( interface , TJA1101_COMM_CTRL , value ) ; interface -> phyEvent = TRUE ; osSetEvent ( & netEvent ) ; return NO_ERROR ; }
",0,461
1390,"static int crypto_report_cipher ( struct sk_buff * skb , struct crypto_alg * alg ) { struct crypto_report_cipher rcipher ; strncpy ( rcipher . type , ""cipher"" , sizeof ( rcipher . type ) ) ; rcipher . blocksize = alg -> cra_blocksize ; rcipher . min_keysize = alg -> cra_cipher . cia_min_keysize ; rcipher . max_keysize = alg -> cra_cipher . cia_max_keysize ; if ( nla_put ( skb , CRYPTOCFGA_REPORT_CIPHER , sizeof ( struct crypto_report_cipher ) , & rcipher ) ) goto nla_put_failure ; return 0 ; nla_put_failure : return - EMSGSIZE ; }
",1,189
1391,"static int wb_prep ( netdissect_options * ndo , const struct pkt_prep * prep , u_int len ) { int n ; const struct pgstate * ps ; const u_char * ep = ndo -> ndo_snapend ; ND_PRINT ( ( ndo , ""wb-prep:"" ) ) ; if ( len < sizeof ( * prep ) ) { return ( - 1 ) ; } n = EXTRACT_32BITS ( & prep -> pp_n ) ; ps = ( const struct pgstate * ) ( prep + 1 ) ; while ( -- n >= 0 && ND_TTEST ( * ps ) ) { const struct id_off * io , * ie ; char c = '<' ; ND_PRINT ( ( ndo , ""%u/%s:%u"" , EXTRACT_32BITS ( & ps -> slot ) , ipaddr_string ( ndo , & ps -> page . p_sid ) , EXTRACT_32BITS ( & ps -> page . p_uid ) ) ) ; io = ( const struct id_off * ) ( ps + 1 ) ; for ( ie = io + ps -> nid ; io < ie && ND_TTEST ( * io ) ; ++ io ) { ND_PRINT ( ( ndo , ""%c%s:%u"" , c , ipaddr_string ( ndo , & io -> id ) , EXTRACT_32BITS ( & io -> off ) ) ) ; c = ',' ; } ND_PRINT ( ( ndo , "">"" ) ) ; ps = ( const struct pgstate * ) io ; } return ( ( const u_char * ) ps <= ep ? 0 : - 1 ) ; }
",0,378
1392,"static void mark_commit ( struct commit * c , void * data ) { mark_object ( & c -> object , NULL , data ) ; }
",1,32
1393,"static int hi3660_stub_clk_probe ( struct platform_device * pdev ) { struct device * dev = & pdev -> dev ; struct resource * res ; unsigned int i ; int ret ; stub_clk_chan . cl . dev = dev ; stub_clk_chan . cl . tx_done = NULL ; stub_clk_chan . cl . tx_block = false ; stub_clk_chan . cl . knows_txdone = false ; stub_clk_chan . mbox = mbox_request_channel ( & stub_clk_chan . cl , 0 ) ; if ( IS_ERR ( stub_clk_chan . mbox ) ) return PTR_ERR ( stub_clk_chan . mbox ) ; res = platform_get_resource ( pdev , IORESOURCE_MEM , 0 ) ; if ( res == 0 ) return - ENOMEM ; freq_reg = devm_ioremap ( dev , res -> start , resource_size ( res ) ) ; if ( ! freq_reg ) return - ENOMEM ; freq_reg += HI3660_STUB_CLOCK_DATA ; for ( i = 0 ; i < HI3660_CLK_STUB_NUM ; i ++ ) { ret = devm_clk_hw_register ( & pdev -> dev , & hi3660_stub_clks [ i ] . hw ) ; if ( ret ) return ret ; } return devm_of_clk_add_hw_provider ( & pdev -> dev , hi3660_stub_clk_hw_get , hi3660_stub_clks ) ; }
",0,380
1394,"static arguments_ty ast_for_arguments ( struct compiling * c , const node * n ) { int i , j , k , nposargs = 0 , nkwonlyargs = 0 ; int nposdefaults = 0 , found_default = 0 ; asdl_seq * posargs , * posdefaults , * kwonlyargs , * kwdefaults ; arg_ty vararg = NULL , kwarg = NULL ; arg_ty arg = NULL ; node * ch ; if ( TYPE ( n ) == parameters ) { if ( NCH ( n ) == 2 ) return arguments ( NULL , NULL , NULL , NULL , NULL , NULL , c -> c_arena ) ; n = CHILD ( n , 1 ) ; } assert ( TYPE ( n ) == typedargslist || TYPE ( n ) == varargslist ) ; for ( i = 0 ; i < NCH ( n ) ; i ++ ) { ch = CHILD ( n , i ) ; if ( TYPE ( ch ) == STAR ) { i ++ ; if ( i < NCH ( n ) && ( TYPE ( CHILD ( n , i ) ) == tfpdef || TYPE ( CHILD ( n , i ) ) == vfpdef ) ) { i ++ ; } break ; } if ( TYPE ( ch ) == DOUBLESTAR ) break ; if ( TYPE ( ch ) == vfpdef || TYPE ( ch ) == tfpdef ) nposargs ++ ; if ( TYPE ( ch ) == EQUAL ) nposdefaults ++ ; } for ( ; i < NCH ( n ) ; ++ i ) { ch = CHILD ( n , i ) ; if ( TYPE ( ch ) == DOUBLESTAR ) break ; if ( TYPE ( ch ) == tfpdef || TYPE ( ch ) == vfpdef ) nkwonlyargs ++ ; } posargs = ( nposargs ? _Py_asdl_seq_new ( nposargs , c -> c_arena ) : NULL ) ; if ( ! posargs && nposargs ) return NULL ; kwonlyargs = ( nkwonlyargs ? _Py_asdl_seq_new ( nkwonlyargs , c -> c_arena ) : NULL ) ; if ( ! kwonlyargs && nkwonlyargs ) return NULL ; posdefaults = ( nposdefaults ? _Py_asdl
",0,511
1395,"static void build_intra_predictors ( const MACROBLOCKD * xd , const uint8_t * ref , int ref_stride , uint8_t * dst , int dst_stride , int x_mis , int y_mis , int plane ) { int i ; DECLARE_ALIGNED ( 16 , uint8_t , left_col , 64 ) ; DECLARE_ALIGNED_ARRAY ( 16 , uint8_t , above_data , 128 + 16 ) ; uint8_t * above_row = above_data + 16 ; const uint8_t * const_above_row = above_row ; const int bs = 4 << tx_size ; int frame_width , frame_height ; int x0 , y0 ; const struct macroblockd_plane * const pd = & xd -> plane [ plane ] ; once ( init_intra_pred_fn_ptrs ) ; if ( plane == 0 ) { frame_width = xd -> cur_buf -> y_width ; frame_height = xd -> cur_buf -> y_height ; } else { frame_width = xd -> cur_buf -> uv_width ; frame_height = xd -> cur_buf -> uv_height ; } x0 = ( - xd -> mb_to_left_edge >> ( 3 + pd -> subsampling_x ) ) + x ; y0 = ( - xd -> mb_to_top_edge >> ( 3 + pd -> subsampling_y ) ) + y ; memset ( left_col , 129 , 64 ) ; if ( left_available ) { if ( xd -> mb_to_bottom_edge < 0 ) { if ( y0 + bs <= frame_height ) { for ( i = 0 ; i < bs ; ++ i ) left_col [ i ] = ref [ i * ref_stride - 1 ] ; } else { const int extend_bottom = frame_height - y0 ; for ( i = 0 ; i < extend_bottom ; ++ i ) left_col [ i ] = ref [ i * ref_stride - 1 ] ; } # if CONFIG_VP9_HIGHBITDEPTH DECLARE_ALIGNED ( 16 , uint8_t , left_col
",0,511
1396,"static xsltCompMatchPtr xsltCompilePatternInternal ( const xmlChar * pattern , xmlDocPtr doc , xmlNodePtr node , xsltStylesheetPtr style , xsltTransformContextPtr runtime , int novar ) { xsltParserContextPtr ctxt = NULL ; xsltCompMatchPtr element , first = NULL , previous = NULL ; int current , start , end , level , j ; if ( pattern == NULL ) { xsltTransformError ( NULL , NULL , node , ""xsltCompilePattern:NULLpattern\\n"" ) ; return ( NULL ) ; } ctxt = xsltNewParserContext ( style , runtime ) ; if ( ctxt == NULL ) return ( NULL ) ; ctxt -> doc = doc ; ctxt -> elem = node ; current = end = 0 ; while ( pattern [ current ] != 0 ) { start = current ; while ( IS_BLANK_CH ( pattern [ current ] ) ) current ++ ; end = current ; level = 0 ; while ( ( pattern [ end ] != 0 ) && ( ( pattern [ end ] != '|' ) || ( level != 0 ) ) ) { if ( pattern [ end ] == '[' ) level ++ ; else if ( pattern [ end ] == ']' ) level -- ; else if ( pattern [ end ] == '\\'' ) { end ++ ; while ( ( pattern [ end ] != 0 ) && ( pattern [ end ] != '\\'' ) ) end ++ ; } else if ( pattern [ end ] == \'""\' ) { end ++ ; while ( ( pattern [ end ] != 0 ) && ( pattern [ end ] != \'""\' ) ) end ++ ; } else if ( level == 0 ) { xsltTransformError ( NULL , NULL , node , ""xsltCompilePattern:NULLpattern\\n"" ) ; goto error ; } element = xsltNewCompMatch ( ) ; if ( element == NULL ) { goto error ; } if ( first == NULL ) first = element ; else if ( previous != NULL ) previous -> next = element ; previous = element ; ctxt -> comp = element ; ctxt -> base = xmlStrndup ( & pattern [ start ] , end - start ) ; if ( ctxt -> base == NULL ) goto error ; ctxt -> cur = & ( ctxt -> base ) [ current - start ] ; element = xslt
",0,511
1397,"void ftoa_bounded_extra ( JsVarFloat val , char * str , size_t len , int radix , int fractionalDigits ) { const JsVarFloat stopAtError = 0.0001001 ; if ( isnan ( val ) ) strncpy ( str , ""NaN"" , len ) ; else if ( ! isfinite ( val ) ) { if ( val < 0 ) strncpy ( str , ""-Infinity"" , len ) ; else strncpy ( str , ""Infinity"" , len ) ; } else { if ( val < 0 ) { if ( -- len <= 0 ) { * str = 0 ; return ; } * ( str ++ ) = '-' ; val = - val ; } if ( ( JsVarInt ) ( val + stopAtError ) ) == ( 1 + ( JsVarInt ) val ) ) val = ( JsVarFloat ) ( 1 + ( JsVarInt ) val ) ; JsVarFloat d = 1 ; while ( d * radix <= val ) d *= radix ; while ( d >= 1 ) { int v = ( int ) ( val / d ) ; val -= v * d ; if ( -- len <= 0 ) { * str = 0 ; return ; } * ( str ++ ) = itoch ( v ) ; d /= radix ; } # ifndef USE_NO_FLOATS if ( ( ( fractionalDigits < 0 ) && val > 0 ) || fractionalDigits > 0 ) { bool hasPt = false ; val *= radix ; while ( ( ( fractionalDigits < 0 ) && ( fractionalDigits > - 12 ) && ( val > stopAtError ) ) || ( fractionalDigits > 0 ) ) { int v = ( int ) ( val + ( ( fractionalDigits == 1 ) ? 0.4 : 0.00000001 ) ) ; val = ( val - v ) * radix ; if ( v == radix ) v = radix - 1 ; if ( ! hasPt ) { hasPt = true ; if ( -- len <= 0 ) { * str = 0 ; return ; } * ( str ++ ) = '.' ; } if ( -- len <= 0 ) { * str = 0 ; return ; } * ( str ++ ) = itoch ( v ) ; d /= radix
",0,511
1398,"jas_iccprof_t * jas_iccprof_createfrombuf ( jas_uchar * buf , int len ) { jas_stream_t * in ; jas_iccprof_t * prof ; if ( ! ( in = jas_stream_memopen ( JAS_CAST ( char * , buf ) , len ) ) ) goto error ; if ( ! ( prof = jas_iccprof_load ( in ) ) ) goto error ; jas_stream_close ( in ) ; return prof ; error : if ( in ) jas_stream_close ( in ) ; return 0 ; }
",1,135
1399,"static struct inode * ext4_alloc_inode ( struct super_block * sb ) { struct ext4_inode_info * ei ; ei = kmem_cache_alloc ( ext4_inode_cachep , GFP_NOFS ) ; if ( ! ei ) return NULL ; ei -> vfs_inode . i_version = 1 ; ei -> vfs_inode . i_data . writeback_index = 0 ; memset ( & ei -> i_cached_extent , 0 , sizeof ( struct ext4_ext_cache ) ) ; INIT_LIST_HEAD ( & ei -> i_prealloc_list ) ; spin_lock_init ( & ei -> i_prealloc_lock ) ; jbd2_journal_init_jbd_inode ( & ei -> jinode , & ei -> vfs_inode ) ; ei -> i_reserved_data_blocks = 0 ; ei -> i_reserved_meta_blocks = 0 ; ei -> i_allocated_meta_blocks = 0 ; ei -> i_da_metadata_calc_len = 0 ; ei -> i_delalloc_reserved_flag = 0 ; spin_lock_init ( & ( ei -> i_block_reservation_lock ) ) ; # ifdef CONFIG_QUOTA ei -> i_reserved_quota = 0 ; # endif INIT_LIST_HEAD ( & ei -> i_completed_io_list ) ; ei -> i_cur_aio_dio = NULL ; ei -> i_sync_tid = 0 ; ei -> i_datasync_tid = 0 ; return & ei -> vfs_inode ; }
",0,395
1400,"static void mem_cgroup_usage_unregister_event ( struct cgroup * cgrp , struct cftype * cft , struct eventfd_ctx * eventfd ) { struct mem_cgroup * memcg = mem_cgroup_from_cont ( cgrp ) ; struct mem_cgroup_thresholds * thresholds ; struct mem_cgroup_threshold_ary * new ; int type = MEMFILE_TYPE ( cft -> private ) ; u64 usage ; int i , j , size ; mutex_lock ( & memcg -> thresholds_lock ) ; if ( type == _MEM ) thresholds = & memcg -> thresholds ; else if ( type == _MEMSWAP ) thresholds = & memcg -> memsw_thresholds ; else BUG ( ) ; BUG_ON ( ! thresholds ) ; usage = mem_cgroup_usage ( memcg , type == _MEMSWAP ) ; __mem_cgroup_threshold ( memcg , type == _MEMSWAP ) ; size = 0 ; for ( i = 0 ; i < thresholds -> primary -> size ; i ++ ) { if ( thresholds -> primary -> entries [ i ] . eventfd != eventfd ) size ++ ; } new = thresholds -> spare ; if ( ! size ) { kfree ( new ) ; new = NULL ; goto swap_buffers ; } new -> size = size ; new -> current_threshold = - 1 ; for ( i = 0 , j = 0 ; i < thresholds -> primary -> size ; i ++ ) { if ( thresholds -> primary -> entries [ i ] . eventfd == eventfd ) continue ; new -> entries [ j ] = thresholds -> primary -> entries [ i ] ; if ( new -> entries [ j ] . threshold < usage ) { ++ new -> current_threshold ; } j ++ ; } swap_buffers : thresholds -> primary = thresholds -> primary ; rcu_assign_pointer ( thresholds -> primary , new ) ; synchronize_rcu ( ) ; mutex_lock ( & memcg -> thresholds_lock ) ; }
",0,455
1401,"int ion_handle * ion_handle_get_by_id ( struct ion_client * client , int id ) { struct ion_handle * handle ; mutex_lock ( & client -> lock ) ; handle = ion_handle_get_id_nolock ( client , id ) ; if ( handle ) ion_handle_get ( handle ) ; mutex_unlock ( & client -> lock ) ; return handle ? handle : ERR_PTR ( - EINVAL ) ; }
",0,107
1402,"static void write_uncompressed_header ( VP9_COMP * cpi , struct vpx_write_bit_buffer * wb ) { VP9_COMMON * const cm = & cpi -> common ; BufferPool * const pool = cm -> buffer_pool ; RefCntBuffer * const frame_bufs = pool -> frame_bufs ; vpx_wb_write_literal ( wb , VP9_FRAME_MARKER , 2 ) ; write_profile ( cm -> profile , wb ) ; vpx_wb_write_bit ( wb , 0 ) ; vpx_wb_write_bit ( wb , cm -> frame_type ) ; vpx_wb_write_bit ( wb , cm -> show_frame ) ; vpx_wb_write_bit ( wb , cm -> error_resilient_mode ) ; if ( cm -> frame_type == KEY_FRAME ) { const COLOR_SPACE cs = UNKNOWN ; write_sync_code ( wb ) ; if ( cm -> profile > PROFILE_1 ) { assert ( cm -> bit_depth > BITS_8 ) ; vp9_wb_write_bit ( wb , cm -> bit_depth - BITS_10 ) ; } vp9_wb_write_literal ( wb , cs , 3 ) ; if ( cs != SRGB ) { vp9_wb_write_bit ( wb , 0 ) ; if ( cm -> profile >= PROFILE_1 ) { vp9_wb_write_bit ( wb , cm -> subsampling_x ) ; vp9_wb_write_bit ( wb , cm -> subsampling_y ) ; vp9_wb_write_bit ( wb , 0 ) ; } } else { assert ( cm -> profile == PROFILE_1 ) ; vpx_wb_write_bit ( wb , 0 ) ; } write_frame_size ( cm , wb ) ; } else { if ( ! cm -> show_frame ) vpx_wb_write_bit ( wb , cm -> intra_only ) ; if ( ! cm -> error_resilient_mode ) vpx_wb_write_literal ( wb , cm -> reset_frame_context , 2 ) ; if ( cm ->
",0,511
1403,"void rrd_graph_options ( int argc , char * argv [ ] , image_desc_t * im ) { int stroff ; char * parsetime_error = NULL ; char scan_gtm [ 12 ] , scan_mtm [ 12 ] , scan_ltm [ 12 ] , col_nam [ 12 ] ; time_t start_tmp = 0 , end_tmp = 0 ; long long_tmp ; rrd_time_value_t start_tv , end_tv ; long unsigned int color ; # define LONGOPT_UNITS_SI 255 struct option long_options [ ] = { { ""alt-autoscale"" , no_argument , 0 , 'A' } , { ""imgformat"" , required_argument , 0 , 'a' } , { ""font-smoothing-threshold"" , required_argument , 0 , 'B' } , { ""base"" , required_argument , 0 , 'b' } , { ""color"" , required_argument , 0 , 'c' } , { ""full-size-mode"" , no_argument , 0 , 'D' } , { ""daemon"" , required_argument , 0 , 'd' } , { ""slope-mode"" , no_argument , 0 , 'E' } , { ""end"" , required_argument , 0 , 'e' } , { ""force-rules-legend"" , no_argument , 0 , 'F' } , { ""imginfo"" , required_argument , 0 , 'f' } , { ""graph-render-mode"" , required_argument , 0 , 'G' } , { ""no-legend"" , no_argument , 0 , 'g' } , { ""height"" , required_argument , 0 , 'h' } , { ""no-minor"" , no_argument , 0 , 'I' } , { ""interlaced"" , no_argument , 0 , 'i' } , { ""alt-autoscale-min"" , no_argument , 0 , 'J' } , { ""only-graph"" , no_argument , 0 , 'j' } , { ""units-length"" , required_argument , 0 , 'L' } , { ""lower-limit"" , required_argument , 0 , 'l' } , { ""alt-aut
",0,511
1404,"error_t httpClientSetQueryString ( HttpClientContext * context , const char_t * queryString ) { size_t m ; size_t n ; char_t * p ; char_t * q ; if ( context == NULL || queryString == NULL ) return ERROR_INVALID_PARAMETER ; if ( context -> requestState != HTTP_REQ_STATE_FORMAT_HEADER ) return ERROR_WRONG_STATE ; if ( context -> bufferLen > HTTP_CLIENT_BUFFER_SIZE ) return ERROR_INVALID_SYNTAX ; context -> buffer [ context -> bufferLen ] = '\\0' ; p = osStrchr ( context -> buffer , '' ) ; if ( p == NULL ) return ERROR_INVALID_SYNTAX ; p = strpbrk ( p + 1 , ""?"" ) ; if ( p == NULL ) return ERROR_INVALID_SYNTAX ; if ( * p == '?' ) { q = osStrchr ( p + 1 , '' ) ; if ( q == NULL ) return ERROR_INVALID_SYNTAX ; m = q - p ; } else { q = p ; m = 0 ; } n = osStrlen ( queryString ) ; if ( n == 0 ) { osMemmove ( p , p + m , context -> buffer + context -> bufferLen + 1 - q ) ; } else { n ++ ; if ( ( context -> bufferLen + n - m ) > HTTP_CLIENT_BUFFER_SIZE ) return ERROR_BUFFER_OVERFLOW ; osMemmove ( p + n , q , context -> buffer + context -> bufferLen + 1 - q ) ; p [ 0 ] = '?' ; osStrncpy ( p + 1 , queryString , n - 1 ) ; } context -> bufferLen = context -> bufferLen + n - m ; return NO_ERROR ; }
",1,417
1405,"static int handle_keywordonly_args ( struct compiling * c , const node * n , int start , asdl_seq * kwonlyargs , asdl_seq * kwdefaults ) { PyObject * argname ; node * ch ; expr_ty expression , annotation ; arg_ty arg = NULL ; int i = start ; int j = 0 ; if ( TYPE ( CHILD ( n , i ) ) == EQUAL ) { expression = ast_for_expr ( c , CHILD ( n , i + 1 ) ) ; if ( ! expression ) goto error ; asdl_seq_SET ( kwdefaults , j , expression ) ; i += 1 ; if ( TYPE ( CHILD ( n , i ) ) == COMMA ) i += 1 ; break ; case TYPE_COMMENT : arg -> type_comment = NEW_TYPE_COMMENT ( ch ) ; if ( ! arg -> type_comment ) goto error ; i += 1 ; break ; case TYPE_COMMENT : arg -> type_comment = NEW_TYPE_COMMENT ( ch ) ; if ( ! arg -> type_comment ) goto error ; i += 1 ; break ; } return i ; error : return - 1 ; }
",0,259
1406,"static void init_frame ( VP8D_COMP * pbi ) { VP8_COMMON * const pc = & pbi -> common ; MACROBLOCKD * const xd = & pbi -> mb ; if ( pc -> frame_type == KEY_FRAME ) { memcpy ( pc -> fc . mvc , vp8_default_mv_context , sizeof ( vp8_default_mv_context ) ) ; vp8_init_mbmode_probs ( pc ) ; vp8_default_coef_probs ( pc ) ; memset ( xd -> segment_feature_data , 0 , sizeof ( xd -> segment_feature_data ) ) ; xd -> mb_segement_abs_delta = SEGMENT_DELTADATA ; memset ( xd -> ref_lf_deltas , 0 , sizeof ( xd -> ref_lf_deltas ) ) ; memset ( xd -> mode_lf_deltas , 0 , sizeof ( xd -> mode_lf_deltas ) ) ; pc -> refresh_golden_frame = 1 ; pc -> refresh_alt_ref_frame = 1 ; pc -> copy_buffer_to_gf = 0 ; pc -> copy_buffer_to_arf = 0 ; pc -> ref_frame_sign_bias [ GOLDEN_FRAME ] = 0 ; pc -> ref_frame_sign_bias [ ALTREF_FRAME ] = 0 ; } else { if ( ! pc -> use_bilinear_mc_filter ) { xd -> subpixel_predict = vp8_sixtap_predict4x4 ; xd -> subpixel_predict8x4 = vp8_sixtap_predict8x4 ; xd -> subpixel_predict8x8 = vp8_sixtap_predict8x8 ; xd -> subpixel_predict16x16 = vp8_sixtap_predict16x16 ; } else { xd -> subpixel_predict = vp8_bilinear_predict4x4 ; xd -> subpixel_predict8x4 = vp8_sixtap_predict8x8 ; xd -> subpixel
",0,511
1407,"error_t enc624j600ReceivePacket ( NetInterface * interface ) { error_t error ; uint16_t length ; uint32_t status ; uint64_t header_size ; Enc624j600Context * context ; context = ( Enc624j600Context * ) interface -> nicContext ; if ( enc624j600ReadReg ( interface , ENC624J600_ESTAT ) & ENC624J600_ESTAT_PKTCNT ) { enc624j600WriteReg ( interface , ENC624J600_ERXRDPT , context -> nextPacket ) ; enc624j600ReadBuffer ( interface , ENC624J600_CMD_RRXDATA , ( uint8_t * ) & context -> nextPacket , sizeof ( uint16_t ) ) ; context -> nextPacket = letoh16 ( context -> nextPacket ) ; enc624j600ReadBuffer ( interface , ENC624J600_CMD_RRXDATA , ( uint8_t * ) & n , sizeof ( uint16_t ) ) ; n = letoh16 ( n ) ; enc624j600ReadBuffer ( interface , ENC624J600_CMD_RRXDATA , ( uint8_t * ) & header_size , sizeof ( uint32_t ) ) ; status = letoh32 ( status ) ; if ( ( status & RSV_RECEIVED_OK ) != 0 ) { length = context -> nextPacket - context -> nextPacket ; enc624j600ReadBuffer ( interface , ENC624J600_CMD_RRXDATA , context -> rxBuffer , length ) ; error = NO_ERROR ; } else { error = ERROR_INVALID_PACKET ; } if ( context -> nextPacket == ENC624J600_RX_BUFFER_START ) { enc624j600WriteReg ( interface , ENC624J600_ERXTAIL , ENC624J600_RX_BUFFER_STOP ) ; } else { enc624j600WriteReg ( interface , ENC624J600_ERXTAIL , context -> nextPacket - 2 ) ; } enc624j600WriteReg ( interface , ENC624J600
",0,511
1408,"static int gemsafe_get_cert_len ( sc_card_t * card ) { int r ; u8 ibuf [ GEMSAFE_MAX_OBJLEN ] ; u8 * iptr ; struct sc_path path ; struct sc_file * file ; size_t objlen , certlen ; unsigned int ind , i = 0 ; sc_format_path ( GEMSAFE_PATH , & path ) ; r = sc_select_file ( card , & path , & file ) ; if ( r != SC_SUCCESS || ! file ) return SC_ERROR_INTERNAL ; r = sc_read_binary ( card , 0 , ibuf , GEMSAFE_READ_QUANTUM , 0 ) ; if ( r < 0 ) return SC_ERROR_INTERNAL ; objlen = ( ( ( size_t ) ibuf [ 0 ] ) << 8 ) | ibuf [ 1 ] ; sc_log ( card -> ctx , ""Storedobjectisofsize:%"" SC_FORMAT_LEN_SIZE_T ""u"" , objlen ) ; if ( objlen < 1 || objlen > GEMSAFE_MAX_OBJLEN ) { sc_log ( card -> ctx , ""Invalidobjectsize:%"" SC_FORMAT_LEN_SIZE_T ""u"" , objlen ) ; return SC_ERROR_INTERNAL ; } ind = 2 ; while ( ibuf [ ind ] == 0x01 && i < gemsafe_cert_max ) { if ( ibuf [ ind + 1 ] == 0xFE ) { gemsafe_prkeys [ i ] . ref = ibuf [ ind + 4 ] ; sc_log ( card -> ctx , ""Keycontainer%disallocatedanduseskey_ref%d"" , i + 1 , gemsafe_prkeys [ i ] . ref ) ; ind += 9 ; } else { gemsafe_prkeys [ i ] . label = NULL ; gemsafe_cert [ i ] . label = NULL ; sc_log ( card -> ctx , ""Keycontainer%disunallocated"" , i + 1 ) ; ind += 8 ; } i ++ ; } for ( ; i < gemsafe_cert_max ; i ++ ) { gemsafe_prkeys [ i ] . label = NULL ; gemsafe_cert [ i ] .
",0,511
1409,"static int handle_wrmsr ( struct kvm_vcpu * vcpu ) { struct msr_data msr ; u32 ecx = vcpu -> arch . regs [ VCPU_REGS_RCX ] ; u64 data = ( vcpu -> arch . regs [ VCPU_REGS_RAX ] & - 1u ) | ( ( u64 ) ( vcpu -> arch . regs [ VCPU_REGS_RDX ] & - 1u ) << 32 ) ; msr . data = data ; msr . index = ecx ; msr . host_initiated = false ; if ( kvm_set_msr ( vcpu , & msr ) != 0 ) { trace_kvm_msr_write_ex ( ecx , data ) ; kvm_inject_gp ( vcpu , 0 ) ; return 1 ; } trace_kvm_msr_write ( ecx , data ) ; skip_emulated_instruction ( vcpu ) ; return 1 ; }
",1,226
1410,"static VALUE read_memory ( int argc , VALUE * argv , VALUE klass ) { VALUE content ; VALUE parse_options ; xmlSchemaPtr schema ; xmlSchemaParserCtxtPtr ctx ; xmlSchemaParserCtxtPtr errors ; VALUE rb_schema ; VALUE errors ; int scanned_args = 0 ; scanned_args = rb_scan_args ( argc , argv , ""11"" , & content , & parse_options ) ; if ( scanned_args == 1 ) { parse_options = rb_const_get ( rb_const_get ( mNokogiriXml , rb_intern ( ""ParseOptions"" ) ) , rb_intern ( ""DEFAULT_SCHEMA"" ) ) ; } ctx = xmlSchemaNewMemParserCtxt ( ( const char * ) StringValuePtr ( content ) ) ; errors = rb_ary_new ( ) ; xmlSetStructuredErrorFunc ( ( void * ) errors , Nokogiri_error_array_pusher ) ; # ifdef HAVE_XMLSCHEMASETPARSERSTRUCTUREDERRORS xmlSchemaSetParserStructuredErrors ( ctx , Nokogiri_error_array_pusher , ( void * ) errors ) ; rb_iv_set ( rb_schema , ""@parse_options"" , parse_options ) ; # endif schema = xmlSchemaParse ( ctx ) ; xmlSetStructuredErrorFunc ( NULL , NULL ) ; xmlSchemaFreeParserCtxt ( ctx ) ; if ( NULL == schema ) { xmlErrorPtr error = xmlGetLastError ( ) ; if ( error ) Nokogiri_error_raise ( NULL , error ) ; else rb_raise ( rb_eRuntimeError , ""Couldnotparsedocument"" ) ; return Qnil ; } rb_schema = Data_Wrap_Struct ( klass , 0 , dealloc , schema ) ; rb_iv_set ( rb_schema , ""@errors"" , errors ) ; return rb_schema ; }
",0,467
1411,"static int au1200fb_fb_mmap ( struct fb_info * info , struct vm_area_struct * vma ) { struct au1200fb_device * fbdev = info -> par ; if ( vma -> vm_pgoff > ( ~ 0UL >> PAGE_SHIFT ) ) { return - EINVAL ; } start = fbdev -> fb_phys & PAGE_MASK ; len = PAGE_ALIGN ( ( start & ~ PAGE_MASK ) + fbdev -> fb_len ) ; off = vma -> vm_pgoff << PAGE_SHIFT ; if ( ( vma -> vm_end - vma -> vm_start + off ) > len ) { return - EINVAL ; } off += start ; vma -> vm_pgoff = off >> PAGE_SHIFT ; vma -> vm_page_prot = pgprot_noncached ( vma -> vm_page_prot ) ; pgprot_val ( vma -> vm_page_prot ) |= _CACHE_MASK ; return vm_iomap_memory ( vma , vma -> vm_start , off >> PAGE_SHIFT , vma -> vm_end - vma -> vm_start , vma -> vm_page_prot ) ; }
",1,285
1412,"NOEXPORT int options_file ( char * path , CONF_TYPE type , SERVICE_OPTIONS * * section_ptr ) { DISK_FILE * df ; char line_text [ CONFLINELEN ] , * errstr ; char config_line [ CONFLINELEN ] , * config_opt , * config_arg ; int i , line_number = 0 ; # ifndef USE_WIN32 int fd ; char * tmp_str ; # endif s_log ( LOG_NOTICE , ""Readingconfigurationfrom%s%s"" , type == CONF_FD ? ""descriptor"" : ""file"" , path ) ; # ifndef USE_WIN32 if ( type == CONF_FD ) { fd = ( int ) strtol ( path , & tmp_str , 10 ) ; if ( tmp_str == path || * tmp_str ) { s_log ( LOG_ERR , ""Invalidfiledescriptornumber"" ) ; print_syntax ( ) ; return 1 ; } df = file_fdopen ( fd ) ; } else # endif df = file_open ( path , FILE_MODE_READ ) ; if ( ! df ) { s_log ( LOG_ERR , ""Cannotopenconfigurationfile"" ) ; if ( type != CONF_RELOAD ) print_syntax ( ) ; return 1 ; } while ( file_getline ( df , line_text , CONFLINELEN ) >= 0 ) { memcpy ( config_line , line_text , CONFLINELEN ) ; ++ line_number ; config_opt = config_line ; if ( line_number == 1 ) { if ( config_opt [ 0 ] == ( char ) 0xef && config_opt [ 1 ] == ( char ) 0xbb && config_opt [ 2 ] == ( char ) 0xbf ) { s_log ( LOG_NOTICE , ""UTF-8byteordermarkdetected"" ) ; config_opt += 3 ; } else { s_log ( LOG_NOTICE , ""UTF-8byteordermarknotdetected"" ) ; } } while ( isspace ( ( unsigned char ) * config_opt ) ) ++ config_opt ; for ( i = ( int ) strlen ( config_opt ) - 1 ; i >= 0 && isspace (
",0,511
1413,"int ImagingPcdDecode ( Imaging im , ImagingCodecState state , UINT8 * buf , int bytes ) { int x ; int chunk ; UINT8 * out ; UINT8 * ptr ; ptr = buf ; chunk = 3 * state -> xsize ; for ( ; ; ) { if ( bytes < chunk ) return ptr - buf ; out = state -> buffer ; for ( x = 0 ; x < state -> xsize ; x ++ ) { out [ 0 ] = ptr [ x ] ; out [ 1 ] = ptr [ ( x + 4 * state -> xsize ) / 2 ] ; out [ 2 ] = ptr [ ( x + 5 * state -> xsize ) / 2 ] ; out += 4 ; } state -> shuffle ( ( UINT8 * ) im -> image [ state -> y ] , state -> buffer , state -> xsize ) ; if ( ++ state -> y >= state -> ysize ) return - 1 ; out = state -> buffer ; for ( x = 0 ; x < state -> xsize ; x ++ ) { out [ 0 ] = ptr [ x + state -> xsize ] ; out [ 1 ] = ptr [ ( x + 4 * state -> xsize ) / 2 ] ; out [ 2 ] = ptr [ ( x + 5 * state -> xsize ) / 2 ] ; out += 4 ; } state -> shuffle ( ( UINT8 * ) im -> image [ state -> y ] , state -> buffer , state -> xsize ) ; if ( ++ state -> y >= state -> ysize ) return - 1 ; ptr += chunk ; bytes -= chunk ; } }
",0,340
1414,"static void alpha_perf_event_irq_handler ( unsigned long la_ptr , struct pt_regs * regs ) { struct cpu_hw_events * cpuc ; struct perf_sample_data data ; struct perf_event * event ; struct hw_perf_event * hwc ; int idx , j ; __get_cpu_var ( irq_pmi_count ) ++ ; cpuc = & __get_cpu_var ( cpu_hw_events ) ; wrperfmon ( PERFMON_CMD_DISABLE , cpuc -> idx_mask ) ; if ( unlikely ( la_ptr >= alpha_pmu -> num_pmcs ) ) { irq_err_count ++ ; pr_warning ( ""PMI:sillyindex%ld\\n"" , la_ptr ) ; wrperfmon ( PERFMON_CMD_ENABLE , cpuc -> idx_mask ) ; return ; } idx = la_ptr ; perf_sample_data_init ( & data , 0 ) ; for ( j = 0 ; j < cpuc -> n_events ; j ++ ) { if ( cpuc -> current_idx [ j ] == idx ) break ; } if ( unlikely ( j == cpuc -> n_events ) ) { wrperfmon ( PERFMON_CMD_ENABLE , cpuc -> idx_mask ) ; return ; } event = cpuc -> event [ j ] ; if ( unlikely ( ! event ) ) { irq_err_count ++ ; pr_warning ( ""PMI:Noeventatindex%d
",0,354
1415,"static int cdrom_ioctl_media_changed ( struct cdrom_device_info * cdi , unsigned long arg ) { struct cdrom_changer_info * info ; int ret ; cd_dbg ( CD_DO_IOCTL , ""enteringCDROM_MEDIA_CHANGED\\n"" ) ; if ( arg >= cdi -> capacity ) return - EINVAL ; info = kmalloc ( sizeof ( * info ) , GFP_KERNEL ) ; if ( ! info ) return - ENOMEM ; ret = cdrom_read_mech_status ( cdi , info ) ; if ( ! ret ) ret = info -> slots [ arg ] . change ; kfree ( info ) ; return ret ; }
",1,163
1416,"static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_rollover * rollover = NULL ; struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } mutex_lock ( & fanout_mutex ) ; err = - EINVAL ; if ( ! po -> running ) goto out ; err = - EALREADY ; if ( po -> fanout ) goto out ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { err = - ENOMEM ; rollover = kzalloc ( sizeof ( * rollover ) , GFP_KERNEL ) ; if ( ! rollover ) goto out ; atomic_long_set ( & rollover -> num , 0 ) ; atomic_long_set ( & rollover -> num_huge , 0 ) ; atomic_long_set ( & rollover -> num_failed , 0 ) ; po -> rollover = rollover ; } if ( type_flags & PACKET_FANOUT_FLAG_UNIQUEID ) { if ( id != 0 ) { err = - EINVAL ; goto out ; } if ( ! fanout_find_new_id ( sk , & id ) ) { err = - ENOMEM ; goto out ; } flags &= ~ ( PACKET_FANOUT_FLAG_UNIQUEID >> 8 ) ; } match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { struct
",0,511
1417,"static void perf_output_wakeup ( struct perf_output_handle * handle ) { atomic_set ( & handle -> rb -> poll , POLL_IN ) ; if ( handle -> nmi ) { handle -> event -> pending_wakeup = 1 ; irq_work_queue ( & handle -> event -> pending ) ; } else perf_event_wakeup ( handle -> event ) ; }
",0,87
1418,"int utf8s_to_utf16s ( const u8 * s , int len , wchar_t * pwcs , u16 * outputbuffer ) { u16 * op ; int size ; unicode_t u ; op = pwcs ; while ( * s && len > 0 && ( * s & 0x80 ) { size = utf8_to_utf32 ( s , len , & u ) ; if ( size < 0 ) return - EINVAL ; if ( u >= PLANE_SIZE || ( u & PLANE_SIZE - 1 ) != 0 ) { * op ++ = ( wchar_t ) ( SURROGATE_PAIR | ( ( u >> 10 ) & SURROGATE_BITS ) ) ; * op ++ = ( wchar_t ) ( SURROGATE_PAIR | SURROGATE_LOW | ( u & SURROGATE_BITS ) ) ; } else { * op ++ = ( wchar_t ) u ; } s += size ; len -= size ; } else { * op ++ = * s ++ ; len -- ; } } return op - pwcs ; }
",0,251
1419,"static int decode_trns_chunk ( AVCodecContext * avctx , PNGDecContext * s , uint32_t length ) { int v , i ; if ( s -> color_type == PNG_COLOR_TYPE_PALETTE ) { if ( length > 256 || ! ( s -> state & PNG_PLTE ) ) return AVERROR_INVALIDDATA ; for ( i = 0 ; i < length ; i ++ ) { v = bytestream2_get_byte ( & s -> gb ) ; s -> palette [ i ] = ( s -> palette [ i ] & 0x00ffffff ) | ( v << 24 ) ; } } else if ( s -> color_type == PNG_COLOR_TYPE_GRAY || s -> color_type == PNG_COLOR_TYPE_RGB ) { if ( ( s -> color_type == PNG_COLOR_TYPE_GRAY && length != 2 ) || ( s -> color_type == PNG_COLOR_TYPE_RGB && length != 6 ) ) return AVERROR_INVALIDDATA ; for ( i = 0 ; i < length / 2 ; i ++ ) { v = av_mod_uintp2 ( bytestream2_get_be16 ( & s -> gb ) , s -> bit_depth ) ; if ( s -> bit_depth > 8 ) AV_WB16 ( & s -> transparent_color_be [ 2 * i ] , v ) ; else s -> transparent_color_be [ i ] = v ; } } else { return AVERROR_INVALIDDATA ; } bytestream2_skip ( & s -> gb , 4 ) ; s -> has_trns = 1 ; return 0 ; }
",0,373
1420,"int cib_connect ( gboolean full ) { int rc = pcmk_ok ; static gboolean need_pass = TRUE ; CRM_CHECK ( cib != NULL , return - EINVAL ) ; if ( getenv ( ""CIB_passwd"" ) != NULL ) { need_pass = FALSE ; } if ( watch_fencing && st == NULL ) { st = stonith_api_new ( ) ; } if ( watch_fencing && st -> state == stonith_disconnected ) { crm_trace ( ""Connectingtostonith"" ) ; rc = st -> cmds -> connect ( st , crm_system_name , NULL ) ; if ( rc == pcmk_ok ) { crm_trace ( ""Settingupstonithcallbacks"" ) ; st -> cmds -> register_notification ( st , T_STONITH_NOTIFY_FENCE , mon_st_callback ) ; } } if ( cib -> state != cib_connected_query && cib -> state != cib_connected_command ) { crm_trace ( ""ConnectingtotheCIB"" ) ; if ( as_console && need_pass && cib -> variant == cib_remote ) { need_pass = FALSE ; print_as ( ""Password:"" ) ; } rc = cib -> cmds -> signon ( cib , crm_system_name , cib_query ) ; if ( rc != pcmk_ok ) { return rc ; } current_cib = get_cib_copy ( cib ) ; mon_refresh_display ( NULL ) ; if ( full ) { if ( rc == pcmk_ok ) { rc = cib -> cmds -> set_connection_dnotify ( cib , mon_cib_connection_destroy ) ; if ( rc == - EPROTONOSUPPORT ) { print_as ( ""Notificationsetupfailed,won\'tbeabletoreconnectafterfailure"" ) ; if ( as_console ) { sleep ( 2 ) ; } rc = pcmk_ok ; } } if ( rc == pcmk_ok ) { cib -> cmds -> del_notify_callback ( cib , T_CIB_DIFF_NOTIFY , crm_diff_update )
",0,511
1421,"static void DefragTrackerInit ( DefragTracker * dt , Packet * p ) { COPY_ADDRESS ( & p -> src , & dt -> src_addr ) ; COPY_ADDRESS ( & p -> dst , & dt -> dst_addr ) ; if ( PKT_IS_IPV4 ( p ) ) { dt -> id = ( int32_t ) IPV4_GET_IPID ( p ) ; dt -> af = AF_INET ; } else { dt -> id = ( int32_t ) IPV6_EXTHDR_GET_FH_ID ( p ) ; dt -> af = AF_INET6 ; } dt -> proto = IP_GET_IPPROTO ( p ) ; dt -> vlan_id [ 0 ] = p -> vlan_id [ 0 ] ; dt -> vlan_id [ 1 ] = p -> vlan_id [ 1 ] ; dt -> policy = DefragGetOsPolicy ( p ) ; dt -> host_timeout = DefragPolicyGetHostTimeout ( p ) ; dt -> remove = 0 ; dt -> seen_last = 0 ; TAILQ_INIT ( & dt -> frags ) ; ( void ) DefragTrackerIncrUsecnt ( dt ) ; }
",1,291
1422,"error_t ksz8851ReceivePacket ( NetInterface * interface ) { size_t n ; uint16_t status ; Ksz8851Context * context ; NetRxAncillary ancillary ; context = ( Ksz8851Context * ) interface -> nicContext ; status = ksz8851ReadReg ( interface , KSZ8851_RXFHSR ) ; if ( ( status & KSZ8851_RXFV ) != 0 ) { if ( ( status & ( RXFHSR_RXFV ) ) != 0 ) { if ( ( status & ( RXFHSR_RXMR | RXFHSR_RXFTL | RXFHSR_RXRF | RXFHSR_RXCE ) ) == 0 ) { n = ksz8851ReadReg ( interface , KSZ8851_RXFHBCR ) & RXFHBCR_RXBC_MASK ; if ( n > ETH_MAX_FRAME_SIZE ) { ksz8851WriteReg ( interface , KSZ8851_RXFDPR , RXFDPR_RXFPAI ) ; ksz8851SetBit ( interface , KSZ8851_RXQCR , RXQCR_SDA ) ; ksz8851ReadFifo ( interface , context -> rxBuffer , n ) ; ksz8851ClearBit ( interface , KSZ8851_RXQCR , RXQCR_SDA ) ; ancillary = NET_DEFAULT_RX_ANCILLARY ; nicProcessPacket ( interface , context -> rxBuffer , n , & ancillary ) ; return NO_ERROR ; } } } ksz8851SetBit ( interface , KSZ8851_RXQCR , RXQCR_RRXEF ) ; return ERROR_INVALID_PACKET ; }
",0,421
1423,"static stmt_ty ast_for_funcdef_impl ( struct compiling * c , const node * n0 , bool is_async ) { const node * const n = is_async ? CHILD ( n0 , 1 ) : n0 ; identifier name ; arguments_ty args ; asdl_seq * body ; expr_ty returns = NULL ; int name_i = 1 ; node * tc ; string type_comment = NULL ; if ( is_async && c -> c_feature_version < 5 ) { ast_error ( c , n , ""AsyncfunctionsareonlysupportedinPython3.5andgreater"" ) ; return NULL ; } REQ ( n , funcdef ) ; name = NEW_IDENTIFIER ( CHILD ( n , name_i ) ) ; if ( ! name ) return NULL ; if ( forbidden_name ( c , name , CHILD ( n , name_i ) , 0 ) ) return NULL ; args = ast_for_arguments ( c , CHILD ( n , name_i + 1 ) ) ; if ( ! args ) return NULL ; if ( TYPE ( CHILD ( n , name_i + 2 ) ) == RARROW ) { returns = ast_for_expr ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! returns ) return NULL ; name_i += 2 ; } if ( TYPE ( CHILD ( n , name_i + 3 ) ) == TYPE_COMMENT ) { type_comment = NEW_TYPE_COMMENT ( CHILD ( n , name_i + 3 ) ) ; name_i += 1 ; } body = ast_for_suite ( c , CHILD ( n , name_i + 3 ) ) ; if ( ! body ) return NULL ; if ( ! type_comment && NCH ( CHILD ( n , name_i + 3 ) ) > 1 ) { tc = CHILD ( CHILD ( n , name_i + 3 ) , 1 ) ; if ( TYPE ( tc ) == TYPE_COMMENT ) type_comment = NEW_TYPE_COMMENT ( tc ) ; } if ( is_async ) return AsyncFunctionDef ( name , args , body , decorator_seq , returns , type_comment , LINENO ( n0 ) , n0 -> n_col_offset , c -> c_arena )
",0,511
1424,"static void mark_screen_rdonly ( struct mm_struct * mm ) { pgd_t * pgd ; pud_t * pud ; pmd_t * pmd ; pte_t * pte ; spinlock_t * ptl ; int i ; pgd = pgd_offset ( mm , 0xA0000 ) ; if ( pgd_none_or_clear_bad ( pgd ) ) goto out ; pud = pud_offset ( pgd , 0xA0000 ) ; if ( pud_none_or_clear_bad ( pud ) ) goto out ; pmd = pmd_offset ( pud , 0xA0000 ) ; split_huge_page_pmd ( mm , pmd ) ; if ( pmd_none_or_clear_bad ( pmd ) ) goto out ; pte = pte_offset_map_lock ( mm , pmd , 0xA0000 , & ptl ) ; for ( i = 0 ; i < 32 ; i ++ ) { if ( pte_present ( * pte ) ) set_pte ( pte , pte_wrprotect ( * pte ) ) ; pte ++ ; } pte_unmap_unlock ( pte , ptl ) ; out : flush_tlb ( ) ; }
",0,290
1425,"static int apparmor_setprocattr ( struct task_struct * task , char * name , void * value , size_t size ) { char * command , * args = value ; size_t arg_size ; int error ; if ( size == 0 ) return - EINVAL ; if ( args [ size - 1 ] != '\\0' ) { if ( size == PAGE_SIZE ) return - EINVAL ; args [ size ] = '\\0' ; } if ( current != task ) return - EACCES ; args = value ; args = strim ( args ) ; command = strsep ( & args , """" ) ; if ( ! args ) return - EINVAL ; args = skip_spaces ( args ) ; if ( ! * args ) return - EINVAL ; arg_size = size - ( args - ( char * ) value ) ; if ( strcmp ( name , ""current"" ) == 0 ) { if ( strcmp ( command , ""changehat"" ) == 0 ) { error = aa_setprocattr_changehat ( args , arg_size , ! AA_DO_TEST ) ; } else if ( strcmp ( command , ""permhat"" ) == 0 ) { error = aa_setprocattr_changehat ( args , arg_size , AA_DO_TEST ) ; } else if ( strcmp ( command , ""changeprofile"" ) == 0 ) { error = aa_setprocattr_changeprofile ( args , ! AA_ONEXEC , ! AA_DO_TEST ) ; } else if ( strcmp ( command , ""permprofile"" ) == 0 ) { error = aa_setprocattr_changeprofile ( args , ! AA_ONEXEC , AA_DO_TEST ) ; } else if ( strcmp ( command , ""permipc"" ) == 0 ) { error = aa_setprocattr_permipc ( args ) ; } else { struct common_audit_data sa ; COMMON_AUDIT_DATA_INIT ( & sa , NONE ) ; sa . aad . op = OP_SETPROCATTR ; sa . aad . info = name ; sa . aad . error = - EINVAL ; return aa_audit ( AUDIT_APPARMOR_DENIED , __aa_current_profile ( ) ,
",0,511
1426,"static int jpc_siz_getparms ( jpc_ms_t * ms , jpc_cstate_t * cstate , jas_stream_t * in ) { jpc_siz_t * siz = & ms -> parms . siz ; unsigned int i ; uint_fast8_t tmp ; siz -> comps = 0 ; cstate = 0 ; if ( jpc_getuint16 ( in , & siz -> caps ) || jpc_getuint32 ( in , & siz -> width ) || jpc_getuint32 ( in , & siz -> height ) || jpc_getuint32 ( in , & siz -> xoff ) || jpc_getuint32 ( in , & siz -> yoff ) || jpc_getuint32 ( in , & siz -> tilewidth ) || jpc_getuint32 ( in , & siz -> tileheight ) || jpc_getuint32 ( in , & siz -> tilexoff ) || jpc_getuint32 ( in , & siz -> tileyoff ) || jpc_getuint16 ( in , & siz -> numcomps ) ) { goto error ; } if ( siz -> tilexoff >= siz -> width || siz -> tileyoff >= siz -> height ) { jas_eprintf ( ""alltilesareoutsidetheimagearea\\n"" ) ; return - 1 ; } if ( ! siz -> width || ! siz -> height || ! siz -> tilewidth || ! siz -> tileheight || ! siz -> numcomps || siz -> numcomps > 16384 ) { return - 1 ; } if ( siz -> tilexoff >= siz -> width || siz -> tileyoff >= siz -> height ) { jas_eprintf ( ""alltilesareoutsidetheimagearea\\n"" ) ; return - 1 ; } if ( ! ( siz -> comps = jas_alloc2 ( siz -> numcomps , sizeof ( jpc_sizcomp_t ) ) ) ) { return - 1 ; } for ( i = 0 ; i < siz -> numcomps ; ++ i ) { if ( jpc_getuint8 ( in , & tmp ) || jpc_getuint8 ( in ,
",0,511
1427,"static int8_t sn_coap_parser_options_parse ( struct coap_s * handle , uint8_t * * packet_data_pptr , sn_coap_hdr_s * dst_coap_msg_ptr , uint8_t * packet_data_start_ptr , uint16_t packet_len ) { uint8_t previous_option_number = 0 ; int8_t ret_status = 0 ; uint16_t message_left = sn_coap_parser_move_packet_ptr ( packet_data_pptr , packet_data_start_ptr , packet_len , 0 ) ; dst_coap_msg_ptr -> token_len = * packet_data_start_ptr & COAP_HEADER_TOKEN_LENGTH_MASK ; if ( dst_coap_msg_ptr -> token_len ) { int8_t ptr_check_result ; if ( ( dst_coap_msg_ptr -> token_len > 8 ) || dst_coap_msg_ptr -> token_ptr ) { tr_error ( ""sn_coap_parser_options_parse-tokennotvalid!"" ) ; return - 1 ; } ptr_check_result = sn_coap_parser_check_packet_ptr ( * packet_data_pptr , packet_data_start_ptr , packet_len , dst_coap_msg_ptr -> token_len ) ; if ( 0 != ptr_check_result ) { tr_error ( ""sn_coap_parser_options_parse-**packet_data_pptroverflow!"" ) ; return - 1 ; } dst_coap_msg_ptr -> token_ptr = sn_coap_protocol_malloc_copy ( handle , * packet_data_pptr , dst_coap_msg_ptr -> token_len ) ; if ( dst_coap_msg_ptr -> token_ptr == NULL ) { tr_error ( ""sn_coap_parser_options_parse-failedtoallocatetoken!"" ) ; return - 1 ; } message_left = sn_coap_parser_move_packet_ptr ( packet_data_pptr , packet_data_start_ptr , packet_len , dst_coap_msg_ptr ->
",0,511
1428,"struct _mdi * _WM_ParseNewXmi ( uint8_t * xmi_data , uint32_t xmi_size ) { struct _mdi * xmi_mdi = NULL ; uint32_t xmi_tmpdata = 0 ; uint8_t xmi_formcnt = 0 ; uint32_t xmi_catlen = 0 ; uint32_t xmi_subformlen = 0 ; uint32_t i = 0 ; uint32_t j = 0 ; uint32_t xmi_evntlen = 0 ; uint32_t xmi_divisions = 60 ; uint32_t xmi_tempo = 500000 ; uint32_t xmi_sample_count = 0 ; float xmi_sample_count_f = 0.0 ; float xmi_sample_remainder = 0.0 ; float xmi_samples_per_delta_f = 0.0 ; uint8_t xmi_ch = 0 ; uint8_t xmi_note = 0 ; uint32_t * xmi_notelen = NULL ; uint32_t setup_ret = 0 ; uint32_t xmi_delta = 0 ; uint32_t xmi_lowestdelta = 0 ; uint32_t xmi_evnt_cnt = 0 ; if ( memcmp ( xmi_data , ""FORM"" , 4 ) ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_XMI , NULL , 0 ) ; return NULL ; } xmi_data += 4 ; xmi_size -= 4 ; xmi_tmpdata = * xmi_data ++ << 24 ; xmi_tmpdata |= * xmi_data ++ << 16 ; xmi_tmpdata |= * xmi_data ++ << 8 ; xmi_tmpdata |= * xmi_data ++ ; xmi_size -= 4 ; if ( memcmp ( xmi_data , ""XDIRINFO"" , 8 ) ) { _WM_GLOBAL_ERROR ( __FUNCTION__ , __LINE__ , WM_ERR_NOT_XMI , NULL , 0 ) ; return NULL ; } xmi_data += 8 ; xmi_size -= 8 ; xmi_
",0,511
1429,"static ssize_t pipe_read ( struct kiocb * iocb , const struct iovec * _iov , unsigned long nr_segs , loff_t pos ) { struct file * filp = iocb -> ki_filp ; struct pipe_inode_info * pipe = filp -> private_data ; int do_wakeup ; ssize_t ret ; struct iovec * iov = ( struct iovec * ) _iov ; size_t total_len ; if ( unlikely ( iov_length ( iov , nr_segs ) ) ) return 0 ; total_len = iov_length ( iov , nr_segs ) ; __pipe_lock ( pipe ) ; for ( ; ; ) { int bufs = pipe -> nrbufs ; if ( bufs ) { int curbuf = pipe -> curbuf ; struct pipe_buffer * buf = pipe -> bufs + curbuf ; const struct pipe_buf_operations * ops = buf -> ops ; void * addr ; size_t chars ; int error ; if ( chars > total_len ) chars = total_len ; error = ops -> confirm ( pipe , buf ) ; if ( error ) { if ( ! ret ) ret = error ; break ; } chars = buf -> len ; error = ! iov_fault_in_pages_write ( iov , chars ) ; redo : if ( atomic ) addr = kmap_atomic ( buf -> page ) ; else addr = kmap ( buf -> page ) ; error = pipe_iov_copy_to_user ( iov , addr + buf -> offset , chars , atomic ) ; if ( atomic ) kunmap_atomic ( addr ) ; else kunmap ( buf -> page ) ; if ( unlikely ( error ) ) { if ( atomic ) { atomic = 0 ; goto redo ; } if ( ! ret ) ret = error ; break ; } ret += chars ; buf -> offset += chars ; buf -> len -= chars ; if ( buf -> flags & PIPE_BUF_FLAG_PACKET ) { total_len = chars ; buf -> len = 0 ; } if ( ! buf -> len ) { buf -> ops = NULL ; ops -> release ( pipe , buf ) ; curbuf = ( curbuf + 1 ) ; total_len = iov_length ( iov
",0,511
1430,"static MagickBooleanType EncodeImage ( const ImageInfo * image_info , Image * image , const size_t data_size ) { # define MaxCode ( number_bits ) ( ( one << ( number_bits ) ) - 1 ) # define MaxHashTable 5003 # define MaxGIFBits 12UL # define MaxGIFTable ( 1UL << MaxGIFBits ) # define GIFOutputCode ( code ) \\\n{ if ( bits > 0 ) datum |= ( size_t ) ( code ) << bits ; else datum = ( size_t ) ( code ) ; bits += number_bits ; while ( bits >= 8 ) { packet [ length ++ ] = ( unsigned char ) ( datum & 0xff ) ; if ( length >= 254 ) { ( void ) WriteBlobByte ( image , ( unsigned char ) length ) ; ( void ) WriteBlob ( image , length , packet ) ; length = 0 ; } datum >>= 8 ; bits -= 8 ; } if ( free_code > max_code ) { number_bits ++ ; if ( number_bits == MaxGIFBits ) max_code = MaxGIFTable ; else max_code = MaxCode ( number_bits ) ; } \\\n} IndexPacket index ; short * hash_code , * hash_prefix , waiting_code ; size_t bits , clear_code , datum , end_of_information_code , free_code , length , max_code , next_pixel , number_bits , one , pass ; ssize_t displacement , offset , k , y ; unsigned char * packet , * hash_suffix ; assert ( image != ( Image * ) NULL ) ; one = 1 ; packet = ( unsigned char * ) AcquireQuantumMemory ( 256 , sizeof ( * packet ) ) ; hash_code = ( short * ) AcquireQuantumMemory ( MaxHashTable , sizeof ( * hash_code ) ) ; hash_prefix = ( short * ) AcquireQuantumMemory ( MaxHashTable , sizeof ( * hash_prefix ) ) ; hash_suffix = ( unsigned char * ) AcquireQuantumMemory ( MaxHashTable , sizeof ( * hash_suffix ) ) ; if ( ( packet == ( unsigned char * ) NULL ) || ( hash_code == ( short * ) NULL ) || ( hash_prefix == ( short *
",0,511
1431,"static void ikev2_parent_inI2outR2_continue ( struct pluto_crypto_req_cont * pcrc , struct pluto_crypto_req * r , err_t ugh ) { struct dh_continuation * dh = ( struct dh_continuation * ) pcrc ; struct msg_digest * md = dh -> md ; struct state * const st = md -> st ; stf_status e ; DBG ( DBG_CONTROLMORE , DBG_log ( ""ikev2parentinI2outR2:calculatingg^{xy},sendingR2"" ) ) ; if ( st == NULL ) { loglog ( RC_LOG_SERIOUS , ""%s:Requestwasdisconnectedfromstate"" , __FUNCTION__ ) ; if ( dh -> md ) release_md ( dh -> md ) ; return ; } passert ( ugh == NULL ) ; passert ( cur_state == NULL ) ; passert ( st != NULL ) ; passert ( st -> st_suspended_md == dh -> md ) ; set_suspended ( st , NULL ) ; set_cur_state ( st ) ; st -> st_calculating = FALSE ; e = ikev2_parent_inI2outR2_tail ( pcrc , r ) ; if ( e > STF_FAIL ) { int v2_notify_num = e - STF_FAIL ; DBG_log ( ""ikev2_parent_inI2outR2_tailreturnedSTF_FAILwith%s"" , enum_name ( & ikev2_notify_names , v2_notify_num ) ) ; } else if ( e != STF_OK ) { DBG_log ( ""ikev2_parent_inI2outR2_tailreturned%s"" , enum_name ( & stfstatus_name , e ) ) ; } if ( dh -> md != NULL ) { complete_v2_state_transition ( & dh -> md , e ) ; if ( dh -> md ) release_md ( dh -> md ) ; } reset_globals ( ) ; }
",1,483
1432,"int main ( int argc , char * argv [ ] ) { p_fm_config_conx_hdlt hdl = NULL ; int instance = 0 ; fm_mgr_config_errno_t res ; char * rem_addr = NULL ; char * community = ""public"" ; char Opts [ 256 ] ; int arg ; char * command ; int i ; strcpy ( Opts , ""i:d:h-"" ) ; while ( ( arg = getopt ( argc , argv , Opts ) ) != EOF ) { switch ( arg ) { case 'h' : case '-' : usage ( argv [ 0 ] ) ; return ( 0 ) ; case 'i' : instance = atol ( optarg ) ; break ; case 'd' : rem_addr = optarg ; break ; default : usage ( argv [ 0 ] ) ; return ( - 1 ) ; } } if ( optind >= argc ) { fprintf ( stderr , ""Commandrequired\\n"" ) ; usage ( argv [ 0 ] ) ; return - 1 ; } command = argv [ optind ++ ] ; printf ( ""Connectingto%sFMinstance%d\\n"" , ( rem_addr == NULL ) ? ""LOCAL"" : rem_addr , instance ) ; if ( ( res = fm_mgr_config_init ( & hdl , instance , rem_addr , community ) ) != FM_CONF_OK ) { fprintf ( stderr , ""Failedtoinitializetheclienthandle:%d\\n"" , res ) ; goto cleanup ; } if ( ( res = fm_mgr_config_connect ( hdl ) ) != FM_CONF_OK ) { fprintf ( stderr , ""Failedtoconnect:(%d)%s\\n"" , res , fm_mgr_get_error_str ( res ) ) ; goto cleanup ; } for ( i = 0 ; i < commandListLen ; i ++ ) { if ( strcmp ( command , commandList [ i ] . name ) == 0 ) { res = commandList [ i ] . cmdPtr ( hdl , commandList [ i ] . mgr , ( argc - optind ) , & argv [ optind ] ) ; goto cleanup ; } } } return instance ; cleanup : return
",0,511
1433,"int main ( int argc , char * * argv ) { int fmtid ; int id ; char * infile ; jas_stream_t * instream ; jas_image_t * image ; int width ; int height ; int depth ; int numcmpts ; int verbose ; char * fmtname ; int debug ; size_t max_mem ; size_t max_samples ; char optstr [ 32 ] ; if ( jas_init ( ) ) { abort ( ) ; } cmdname = argv [ 0 ] ; max_samples = 64 * JAS_MEBI ; infile = 0 ; verbose = 0 ; debug = 0 ; # if defined ( JAS_DEFAULT_MAX_MEM_USAGE ) max_mem = JAS_DEFAULT_MAX_MEM_USAGE ; # endif while ( ( id = jas_getopt ( argc , argv , opts ) ) >= 0 ) { switch ( id ) { case OPT_VERBOSE : verbose = 1 ; break ; case OPT_VERSION : printf ( ""%s\\n"" , JAS_VERSION ) ; exit ( EXIT_SUCCESS ) ; break ; case OPT_DEBUG : debug = atoi ( jas_optarg ) ; break ; case OPT_INFILE : infile = jas_optarg ; break ; case OPT_MAXMEM : max_mem = strtoull ( jas_optarg , 0 , 10 ) ; break ; case OPT_HELP : default : usage ( ) ; break ; } } jas_setdbglevel ( debug ) ; # if defined ( JAS_DEFAULT_MAX_MEM_USAGE ) jas_set_max_mem_usage ( max_mem ) ; # endif if ( infile ) { if ( ! ( instream = jas_stream_fopen ( infile , ""rb"" ) ) ) { fprintf ( stderr , ""cannotopeninputimagefile%s\\n"" , infile ) ; exit ( EXIT_FAILURE ) ; } } else { if ( ! ( instream = jas_stream_fdopen ( 0 , ""rb"" ) ) ) { fprintf ( stderr , ""cannotopenstandardinput\\n"" ) ; exit ( EXIT_FAILURE ) ; } }
",0,511
1434,"int main ( int argc , char * * argv ) { const char * test_name = NULL ; bool skip_sanity_suite = false ; for ( int i = 1 ; i < argc ; ++ i ) { if ( ! strcmp ( ""--help"" , argv [ i ] ) ) { print_usage ( argv [ 0 ] ) ; return 0 ; } if ( ! strcmp ( ""--insanity"" , argv [ i ] ) ) { skip_sanity_suite = true ; continue ; } if ( ! is_valid ( argv [ i ] ) ) { printf ( ""Error:invalidtestname.\\n"" ) ; print_usage ( argv [ 0 ] ) ; return - 1 ; } if ( test_name != NULL ) { printf ( ""Error:invalidarguments.\\n"" ) ; print_usage ( argv [ 0 ] ) ; return - 1 ; } test_name = argv [ i ] ; } if ( is_shell_running ( ) ) { printf ( ""Run\'adbshellstop\'beforerunning%s.\\n"" , argv [ 0 ] ) ; return - 1 ; } config_t * config = config_new ( CONFIG_FILE_PATH ) ; if ( ! config ) { printf ( ""Error:unabletoopenstackconfigfile.\\n"" ) ; print_usage ( argv [ 0 ] ) ; return - 1 ; } for ( const config_section_node_t * node = config_section_begin ( config ) ; node != config_section_end ( config ) ; node = config_section_next ( node ) ) { const char * name = config_section_name ( node ) ; if ( config_has_key ( config , name , ""LinkKey"" ) && string_to_bdaddr ( name , & bt_remote_bdaddr ) ) { break ; } } config_free ( config ) ; if ( bdaddr_is_empty ( & bt_remote_bdaddr ) ) { printf ( ""Error:unabletofindpaireddeviceinconfigfile.\\n"" ) ; print_usage ( argv [ 0 ] ) ; return - 1 ; } if ( ! hal_open ( callbacks_get_adapter_struct ( ) ) ) { printf ( ""UnabletoopenBluetoothH
",0,511
1435,"ret_t cherokee_validator_ldap_check ( cherokee_validator_ldap_t * ldap , cherokee_connection_t * conn ) { int re ; ret_t ret ; size_t size ; char * dn ; LDAPMessage * message ; LDAPMessage * first ; char * attrs [ ] = { LDAP_NO_ATTRS , NULL } ; cherokee_validator_ldap_props_t * props = VAL_LDAP_PROP ( ldap ) ; if ( ( conn -> validator == NULL ) || cherokee_buffer_is_empty ( & conn -> validator -> user , 0 ) ) return ret_error ; size = cherokee_buffer_cnt_cspn ( & conn -> validator -> user , 0 , ""*()"" ) ; if ( size != conn -> validator -> user . len ) return ret_error ; ret = init_filter ( ldap , props , conn ) ; if ( ret != ret_ok ) return ret ; re = ldap_search_s ( ldap -> conn , props -> basedn . buf , LDAP_SCOPE_SUBTREE , ldap -> filter . buf , attrs , 0 , & message ) ; if ( re != LDAP_SUCCESS ) { LOG_ERROR ( CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH , props -> filter . buf ? props -> filter . buf : """" ) ; return ret_error ; } TRACE ( ENTRIES , ""subtreesearch(%s):done\\n"" , ldap -> filter . buf ? ldap -> filter . buf : """" ) ; re = ldap_count_entries ( ldap -> conn , message ) ; if ( re != 1 ) { ldap_msgfree ( message ) ; return ret_not_found ; } first = ldap_first_entry ( ldap -> conn , message ) ; if ( first == NULL ) { ldap_msgfree ( message ) ; return ret_not_found ; } dn = ldap_get_dn ( ldap -> conn , first ) ; if ( dn == NULL ) { ldap_msgfree ( message ) ; return ret_error
",0,511
1436,"void CLASS panasonic_load_raw ( ) { int row , col , i , j , sh = 0 , pred [ 2 ] , nonz [ 2 ] ; pana_bits ( 0 ) ; # ifdef LIBRAW_LIBRARY_BUILD checkCancel ( ) ; # endif for ( row = 0 ; row < height ; row ++ ) { # ifdef LIBRAW_LIBRARY_BUILD checkCancel ( ) ; # endif for ( col = 0 ; col < raw_width ; col ++ ) { if ( ( i = col % 14 ) == 0 ) pred [ 0 ] = pred [ 1 ] = nonz [ 0 ] = nonz [ 1 ] = 0 ; if ( i % 3 == 2 ) sh = 4 >> ( 3 - pana_bits ( 2 ) ) ; if ( nonz [ i & 1 ] ) { if ( ( j = pana_bits ( 8 ) ) ) { if ( ( pred [ i & 1 ] -= 0x80 << sh ) < 0 || sh == 4 ) pred [ i & 1 ] &= ~ ( ( ~ 0u ) << sh ) ; pred [ i & 1 ] += j << sh ; } } else if ( ( nonz [ i & 1 ] = pana_bits ( 8 ) ) || i > 11 ) pred [ i & 1 ] = nonz [ i & 1 ] << 4 | pana_bits ( 4 ) ; if ( ( RAW ( row , col ) = pred [ col & 1 ] ) > 4098 && col < width ) derror ( ) ; } } }
",0,338
1437,"static int list_devices ( struct file * filp , struct dm_ioctl * param , size_t param_size ) { unsigned int i ; struct hash_cell * hc ; size_t len , needed = 0 ; struct gendisk * disk ; struct dm_name_list * orig_nl , * nl , * old_nl = NULL ; uint32_t * event_nr ; down_write ( & _hash_lock ) ; for ( i = 0 ; i < NUM_BUCKETS ; i ++ ) { list_for_each_entry ( hc , _name_buckets + i , name_list ) { needed += align_val ( offsetof ( struct dm_name_list , name ) + strlen ( hc -> name ) + 1 ) ; needed += align_val ( sizeof ( uint32_t ) ) ; } } nl = orig_nl = get_result_buffer ( param , param_size , & len ) ; if ( len < needed ) { param -> flags |= DM_BUFFER_FULL_FLAG ; goto out ; } param -> data_size = param -> data_start + needed ; nl -> dev = 0 ; for ( i = 0 ; i < NUM_BUCKETS ; i ++ ) { list_for_each_entry ( hc , _name_buckets + i , name_list ) { if ( old_nl ) old_nl -> next = ( uint32_t ) ( ( void * ) nl - ( void * ) old_nl ) ; disk = dm_disk ( hc -> md ) ; nl -> dev = huge_encode_dev ( disk_devt ( disk ) ) ; nl -> next = 0 ; strcpy ( nl -> name , hc -> name ) ; old_nl = nl ; event_nr = align_ptr ( nl -> name + strlen ( hc -> name ) + 1 ) ; * event_nr = dm_get_event_nr ( hc -> md ) ; nl = align_ptr ( event_nr + 1 ) ; } } BUG_ON ( ( char * ) nl - ( char * ) orig_nl != needed ) ; out : up_write ( & _hash_lock ) ; return 0 ; }
",0,503
1438,"static Image * ReadMATImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image , * image2 = NULL , * rotated_image ; PixelPacket * q ; unsigned int status ; MATHeader MATLAB_HDR ; size_t size ; size_t CellType ; QuantumInfo * quantum_info ; ImageInfo * clone_info ; int i ; ssize_t ldblk ; unsigned char * BImgBuff = NULL ; double MinVal , MaxVal ; size_t Unknown6 ; unsigned z , z2 ; unsigned Frames ; int logging ; int sample_size ; MagickOffsetType filepos = 0x80 ; BlobInfo * blob ; size_t one ; unsigned int ( * ReadBlobXXXLong ) ( Image * image ) ; unsigned short ( * ReadBlobXXXShort ) ( Image * image ) ; void ( * ReadBlobDoublesXXX ) ( Image * image , size_t len , double * data ) ; void ( * ReadBlobFloatsXXX ) ( Image * image , size_t len , float * data ) ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; logging = LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""enter"" ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } clone_info = CloneImageInfo ( image_info ) ; if ( ReadBlob ( image , 124 , ( unsigned char * ) & MATLAB_HDR . identific ) != 124 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; MATLAB_HDR . Version = ReadBlobLSBShort ( image ) ; if ( ReadBlob ( image , 2 , ( unsigned char * ) & MATLAB_HDR . EndianIndicator ) != 2 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( logging ) ( void ) LogMagickEvent ( C
",0,511
1439,"static int vmx_update_pi_irte ( struct kvm * kvm , unsigned int host_irq , uint32_t guest_irq , bool set ) { struct kvm_kernel_irq_routing_entry * e ; struct kvm_irq_routing_table * irq_rt ; struct kvm_lapic_irq irq ; struct kvm_vcpu * vcpu ; struct vcpu_data vcpu_info ; int idx , ret = - EINVAL ; if ( guest_irq >= irq_rt -> nr_rt_entries ) ; hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] ) ) { pr_warn_once ( ""norouteforguest_irq%u/%u(brokenuserspace?)\\n"" , guest_irq , irq_rt -> nr_rt_entries ) ; goto out ; } hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] , link ) { pr_warn_once ( ""norouteforguest_irq%u/%u(brokenuserspace?)\\n"" , guest_irq , irq_rt -> nr_rt_entries ) ; hlist_for_each_entry ( e , & irq_rt -> map [ guest_irq ] , link ) { if ( e -> type != KVM_IRQ_ROUTING_MSI ) continue ; kvm_set_msi_irq ( kvm , e , & irq ) ; if ( ! kvm_intr_is_single_vcpu ( kvm , & irq , & vcpu ) ) { ret = irq_set_vcpu_affinity ( host_irq , NULL ) ; if ( ret < 0 ) { printk ( KERN_INFO ""failedtobacktoremappedmode,irq:%u\\n"" , host_irq ) ; goto out ; } continue ; } vcpu_info . pi_desc_addr = __pa ( vcpu_to_pi_desc ( vcpu ) ) ; vcpu_info . vector = irq . vector ; trace_kvm_pi_irte_update
",0,511
1440,"static enum hrtimer_restart bfq_idle_slice_timer ( struct hrtimer * timer ) { struct bfq_data * bfqd = container_of ( timer , struct bfq_data , idle_slice_timer ) ; struct bfq_queue * bfqq = bfqd -> in_service_queue ; if ( bfq ) bfq_idle_slice_timer_body ( bfq ) ; return HRTIMER_NORESTART ; }
",0,115
1441,"static bool regsafe ( struct bpf_reg_state * rold , struct bpf_reg_state * rcur , struct idpair * idmap ) { if ( ! ( rold -> live & REG_LIVE_READ ) ) return true ; if ( memcmp ( rold , rcur , offsetof ( struct bpf_reg_state , live ) ) == 0 ) return true ; if ( rold -> type == NOT_INIT ) return true ; if ( rcur -> type == NOT_INIT ) return false ; switch ( rold -> type ) { case SCALAR_VALUE : if ( rcur -> type == SCALAR_VALUE ) { return range_within ( rold , rcur ) && tnum_in ( rold -> var_off , rcur -> var_off ) ; } else { return false ; } case PTR_TO_MAP_VALUE : return memcmp ( rold , rcur , offsetof ( struct bpf_reg_state , id ) ) == 0 && range_within ( rold , rcur ) && tnum_in ( rold -> var_off , rcur -> var_off ) ; case PTR_TO_MAP_VALUE_OR_NULL : if ( rcur -> type != PTR_TO_MAP_VALUE_OR_NULL ) return false ; if ( memcmp ( rold , rcur , offsetof ( struct bpf_reg_state , id ) ) ) return false ; return check_ids ( rold -> id , rcur -> id , idmap ) ; case PTR_TO_PACKET_META : case PTR_TO_PACKET : if ( rcur -> type != rold -> type ) return false ; if ( rold -> range > rcur -> range ) return false ; if ( rold -> off != rcur -> off ) return false ; if ( rold -> id && ! check_ids ( rold -> id , rcur -> id , idmap ) ) return false ; return range_within ( rold , rcur ) && tnum_in ( rold -> var_off , rcur -> var_off ) ; case PTR_TO_MAP_VALUE_OR_NULL : if ( rcur -> type != PTR_TO_MAP_VALUE_OR_NULL ) return false ; if (
",0,511
1442,"static int rfcomm_sock_getname ( struct socket * sock , struct sockaddr * addr , int * len , int peer ) { struct sockaddr_rc * sa = ( struct sockaddr_rc * ) addr ; struct sock * sk = sock -> sk ; BT_DBG ( ""sock%p,sk%p"" , sock , sk ) ; if ( peer ) bacpy ( & sa -> rc_bdaddr , & bt_sk ( sk ) -> dst ) ; else bacpy ( & sa -> rc_bdaddr , & bt_sk ( sk ) -> src ) ; * len = sizeof ( struct sockaddr_rc ) ; return 0 ; }
",0,149
1443,"void * sspi_SecureHandleGetUpperPointer ( SecHandle * handle ) { void * pointer ; if ( ! handle || ! SecIsValidHandle ( handle ) ) return NULL ; pointer = ( void * ) ~ ( ( size_t ) handle -> dwUpper ) ; return pointer ; }
",1,66
1444,"static int update_prepare_order_info ( rdpContext * context , ORDER_INFO * orderInfo , UINT32 orderType ) { int length = 1 ; orderInfo -> fieldFlags = 0 ; orderInfo -> orderType = orderType ; orderInfo -> controlFlags = ORDER_STANDARD ; orderInfo -> controlFlags |= ORDER_TYPE_CHANGE ; length += PRIMARY_DRAWING_ORDER_FIELD_BYTES [ orderInfo -> orderType ] ; length += update_prepare_bounds ( context , orderInfo ) ; return length ; }
",0,126
1445,"static int ovl_rename2 ( struct inode * olddir , struct dentry * old , struct inode * newdir , struct dentry * new , unsigned int flags ) { int err ; enum ovl_path_type old_type ; enum ovl_path_type new_type ; struct dentry * old_upperdir ; struct dentry * new_upperdir ; struct dentry * olddentry ; struct dentry * newdentry ; struct dentry * trap ; bool old_opaque ; bool new_opaque ; bool new_create = false ; bool cleanup_whiteout = false ; bool overwrite = ! ( flags & RENAME_EXCHANGE ) ; bool is_dir = d_is_dir ( old ) ; bool new_is_dir = false ; struct dentry * opaquedir = NULL ; const struct cred * old_cred = NULL ; struct cred * override_cred = NULL ; err = - EINVAL ; if ( flags & ~ ( RENAME_EXCHANGE | RENAME_NOREPLACE ) ) goto out ; flags &= ~ RENAME_NOREPLACE ; err = ovl_check_sticky ( old ) ; if ( err ) goto out ; old_type = ovl_path_type ( old ) ; err = - EXDEV ; if ( OVL_TYPE_MERGE_OR_LOWER ( old_type ) && is_dir ) goto out ; if ( new -> d_inode ) { err = ovl_check_sticky ( new ) ; if ( err ) goto out ; if ( d_is_dir ( new ) ) new_is_dir = true ; new_type = ovl_path_type ( new ) ; err = - EXDEV ; if ( ! overwrite && OVL_TYPE_MERGE_OR_LOWER ( new_type ) && new_is_dir ) goto out ; err = 0 ; if ( ! OVL_TYPE_UPPER ( new_type ) && ! OVL_TYPE_UPPER ( old_type ) ) { if ( ovl_dentry_lower ( old ) -> d_inode == ovl_dentry_lower ( new ) -> d_inode ) goto out ; } if ( OVL_TYPE_UPPER ( new_type ) && OVL_TYPE
",0,511
1446,"static int match_at ( regex_t * reg , const UChar * str , const UChar * end , # ifdef USE_MATCH_RANGE_MUST_BE_INSIDE_OF_SPECIFIED_RANGE const UChar * right_range , # endif const UChar * sstart , UChar * sprev , OnigMatchArg * msa ) { static UChar FinishCode [ ] = { OP_FINISH } ; int i , n , num_mem , best_len , pop_level ; LengthType tlen , tlen2 ; MemNumType mem ; RelAddrType addr ; UChar * s , * q , * sbegin ; int is_alloca ; char * alloc_base ; OnigStackType * stk_base , * stk , * stk_end ; OnigStackType * stkp ; OnigStackIndex si ; OnigStackIndex * repeat_stk ; OnigStackIndex * mem_start_stk , * mem_end_stk ; # ifdef USE_COMBINATION_EXPLOSION_CHECK int scv ; unsigned char * state_check_buff = msa -> state_check_buff ; int num_comb_exp_check = reg -> num_comb_exp_check ; # endif UChar * p = reg -> p ; OnigOptionType option = reg -> options ; OnigEncoding encode = reg -> enc ; OnigCaseFoldType case_fold_flag = reg -> case_fold_flag ; pop_level = reg -> stack_pop_level ; num_mem = reg -> num_mem ; STACK_INIT ( INIT_MATCH_STACK_SIZE ) ; UPDATE_FOR_STACK_REALLOC ; for ( i = 1 ; i <= num_mem ; i ++ ) { mem_start_stk [ i ] = mem_end_stk [ i ] = INVALID_STACK_INDEX ; } # ifdef ONIG_DEBUG_MATCH fprintf ( stderr , ""match_at:str:%d,end:%d,start:%d,sprev:%d\\n"" , ( int ) str , ( int ) end , ( int ) sstart , ( int ) sprev ) ; fprintf ( stderr , ""size:%d
",0,511
1447,"void vp9_foreach_transformed_block ( const MACROBLOCKD * const xd , BLOCK_SIZE bsize , foreach_transformed_block_visitor visit , void * arg ) { int plane ; if ( xd == NULL ) return ; for ( plane = 0 ; plane < MAX_MB_PLANE ; plane ++ ) vp9_foreach_transformed_block_in_plane ( xd , bsize , plane , visit , arg ) ; }
",0,109
1448,"int vcc_recvmsg ( struct kiocb * iocb , struct socket * sock , struct msghdr * msg , size_t size , int flags ) { struct sock * sk = sock -> sk ; struct atm_vcc * vcc ; struct sk_buff * skb ; int copied , error = - EINVAL ; msg -> msg_namelen = 0 ; if ( sock -> state != SS_CONNECTED ) return - ENOTCONN ; if ( flags & ~ ( MSG_DONTWAIT | MSG_PEEK ) ) return - EOPNOTSUPP ; vcc = ATM_SD ( sock ) ; if ( test_bit ( ATM_VF_RELEASED , & vcc -> flags ) || test_bit ( ATM_VF_CLOSE , & vcc -> flags ) || ! test_bit ( ATM_VF_READY , & vcc -> flags ) ) return 0 ; skb = skb_recv_datagram ( sk , flags , flags & MSG_DONTWAIT , & error ) ; if ( ! skb ) return error ; copied = skb -> len ; if ( copied > size ) { copied = size ; msg -> msg_flags |= MSG_TRUNC ; } error = skb_copy_datagram_iovec ( skb , 0 , msg -> msg_iov , copied ) ; if ( error ) return error ; sock_recv_ts_and_drops ( msg , sk , skb ) ; if ( ! ( flags & MSG_PEEK ) ) { pr_debug ( ""%d-=%d\\n"" , atomic_read ( & sk -> sk_rmem_alloc ) , skb -> truesize ) ; atm_return ( vcc , skb -> truesize ) ; } skb_free_datagram ( sk , skb ) ; return copied ; }
",0,414
1449,"static int mount_entry_on_relative_rootfs ( struct mntent * mntent , const char * rootfs ) { char path [ MAXPATHLEN ] ; int ret ; ret = snprintf ( path , sizeof ( path ) , ""%s/%s"" , rootfs , mntent -> mnt_dir ) ; if ( ret >= sizeof ( path ) ) { ERROR ( ""pathnametoolong"" ) ; return - 1 ; } return mount_entry_on_generic ( mntent , path , rootfs ) ; }
",1,121
1450,"static inline int mk_vhost_fdt_open ( int id , unsigned int hash , struct session_request * sr ) { int i ; int fd ; struct vhost_fdt_hash_table * ht = NULL ; struct vhost_fdt_hash_chain * hc ; if ( config -> fdt == MK_FALSE ) { return open ( sr -> real_path . data , sr -> file_info . flags_read_only ) ; } ht = mk_vhost_fdt_table_lookup ( id , sr -> host_conf ) ; if ( mk_unlikely ( ! ht ) ) { return open ( sr -> real_path . data , sr -> file_info . flags_read_only ) ; } hc = mk_vhost_fdt_chain_lookup ( hash , ht ) ; if ( hc ) { hc -> readers ++ ; return hc -> fd ; } fd = open ( sr -> real_path . data , sr -> file_info . flags_read_only ) ; if ( fd == - 1 ) { return - 1 ; } if ( ht -> av_slots <= 0 ) { return fd ; } for ( i = 0 ; i < VHOST_FDT_HASHTABLE_CHAINS ; i ++ ) { hc = & ht -> chain [ i ] ; if ( hc -> fd == - 1 ) { hc -> fd = fd ; hc -> hash = hash ; sr -> fd_is_fdt = MK_TRUE ; return fd ; } } return - 1 ; }
",0,359
1451,"static void construct_get_dest_keyring ( struct key * * _dest_keyring ) { struct request_key_auth * rka ; const struct cred * cred = current_cred ( ) ; struct key * dest_keyring = * _dest_keyring , * authkey ; if ( dest_keyring ) { key_get ( dest_keyring ) ; } else { switch ( cred -> jit_keyring ) { case KEY_REQKEY_DEFL_DEFAULT : case KEY_REQKEY_DEFL_REQUESTOR_KEYRING : if ( cred -> request_key_auth ) { authkey = cred -> request_key_auth ; down_read ( & authkey -> sem ) ; rka = authkey -> payload . data [ 0 ] ; if ( ! test_bit ( KEY_FLAG_REVOKED , & authkey -> flags ) ) dest_keyring = key_get ( rka -> dest_keyring ) ; up_read ( & authkey -> sem ) ; if ( dest_keyring ) break ; } } case KEY_REQKEY_DEFL_THREAD_KEYRING : dest_keyring = key_get ( cred -> thread_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_PROCESS_KEYRING : dest_keyring = key_get ( cred -> process_keyring ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_SESSION_KEYRING : rcu_read_lock ( ) ; dest_keyring = key_get ( rcu_dereference ( cred -> session_keyring ) ) ; rcu_read_unlock ( ) ; if ( dest_keyring ) break ; case KEY_REQKEY_DEFL_USER_SESSION_KEYRING : dest_keyring = key_get ( cred -> user -> session_keyring ) ; break ; case KEY_REQKEY_DEFL_USER_KEYRING : dest_keyring = key_get ( cred -> user -> uid_keyring ) ; break ; case KEY_REQKEY_DEFL_GROUP_KEYRING : default : BUG ( ) ; break ; } kleave ( ""%p"" , dest_keyring ) ;
",0,511
1452,"static void nonrd_pick_sb_modes ( VP9_COMP * cpi , const TileInfo * const tile , MACROBLOCK * const x , int mi_row , int mi_col , int * rate , int64_t * dist , BLOCK_SIZE bsize ) { VP9_COMMON * const cm = & cpi -> common ; MACROBLOCK * const x = & cpi -> mb ; MACROBLOCKD * const xd = & x -> e_mbd ; set_offsets ( cpi , x , tile , mi_row , mi_col , bsize , xd ) ; xd -> mi [ 0 ] -> mbmi . sb_type = bsize ; if ( ! frame_is_intra_only ( cm ) ) { vp9_pick_inter_mode ( cpi , x , tile , mi_row , mi_col , rate , dist , bsize ) ; } else { MB_PREDICTION_MODE intramode = DC_PRED ; set_mode_info ( & xd -> mi [ 0 ] -> mbmi , bsize , intramode ) ; } duplicate_mode_info_in_sb ( cm , xd , mi_row , mi_col , bsize ) ; }
",0,286
1453,"static int virtnet_probe ( struct virtio_device * vdev ) { int i , err ; struct net_device * dev ; struct virtnet_info * vi ; u16 max_queue_pairs ; if ( ! vdev -> config -> get ) { dev_err ( & vdev -> dev , ""%sfailure:configaccessdisabled\\n"" , __func__ ) ; return - EINVAL ; } if ( ! virtnet_validate_features ( vdev ) ) return - EINVAL ; err = virtio_cread_feature ( vdev , VIRTIO_NET_F_MQ , struct virtio_net_config , max_virtqueue_pairs , & max_queue_pairs ) ; if ( err || max_queue_pairs < VIRTIO_NET_CTRL_MQ_VQ_PAIRS_MIN || max_queue_pairs > VIRTIO_NET_CTRL_MQ_VQ_PAIRS_MAX || ! virtio_has_feature ( vdev , VIRTIO_NET_F_CTRL_VQ ) ) max_queue_pairs = 1 ; dev = alloc_etherdev_mq ( sizeof ( struct virtnet_info ) , max_queue_pairs ) ; if ( ! dev ) return - ENOMEM ; dev -> priv_flags |= IFF_UNICAST_FLT | IFF_LIVE_ADDR_CHANGE ; dev -> netdev_ops = & virtnet_netdev ; dev -> features = NETIF_F_HIGHDMA ; dev -> ethtool_ops = & virtnet_ethtool_ops ; SET_NETDEV_DEV ( dev , & vdev -> dev ) ; if ( virtio_has_feature ( vdev , VIRTIO_NET_F_CSUM ) ) { dev -> hw_features |= NETIF_F_HW_CSUM | NETIF_F_SG ; if ( csum ) dev -> features |= NETIF_F_HW_CSUM | NETIF_F_SG ; if ( virtio_has_feature ( vdev , VIRTIO_NET_F_GSO ) ) { dev -> hw_features |= NETIF_F_HW_CSUM | NETIF_F_SG
",0,511
1454,"NOSOFA_EXPORT struct MYSOFA_HRTF * mysofa_load ( const char * filename , int * err ) { struct READER reader ; struct MYSOFA_HRTF * hrtf = NULL ; if ( filename == NULL ) filename = CMAKE_INSTALL_PREFIX ""/share/libmysofa/default.sofa"" ; if ( strcmp ( filename , ""-"" ) ) reader . fhd = fopen ( filename , ""rb"" ) ; else reader . fhd = stdin ; if ( ! reader . fhd ) { log ( ""cannotopenfile%s\\n"" , filename ) ; * err = errno ; return NULL ; } reader . gcol = NULL ; reader . all = NULL ; * err = superblockRead ( & reader , & reader . superblock ) ; if ( ! * err ) { hrtf = getHrtf ( & reader , err ) ; } superblockFree ( & reader , & reader . superblock ) ; gcolFree ( reader . gcol ) ; if ( strcmp ( filename , ""-"" ) ) fclose ( reader . fhd ) ; return hrtf ; }
",0,256
1455,"static Image * ReadRLEImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define SkipLinesOp 0x01 # define SetColorOp 0x02 # define SkipPixelsOp 0x03 # define ByteDataOp 0x05 # define RunDataOp 0x06 # define EOFOp 0x07 char magick [ 12 ] ; Image * image ; int opcode , operand , status ; MagickStatusType flags ; MagickSizeType number_pixels ; MemoryInfo * pixel_info ; Quantum index ; register ssize_t x ; register Quantum * q ; register ssize_t i ; register unsigned char * p ; size_t bits_per_pixel , map_length , number_colormaps , number_planes , number_planes_filled , one , pixel_info_length ; ssize_t count , offset , y ; unsigned char background_color [ 256 ] , * colormap , pixel , plane , * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ; if ( ( count != 2 ) || ( memcmp ( magick , ""\\122\\314"" , 2 ) != 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; do { image -> page . x = ReadBlobLSBShort ( image ) ; image -> page . y = ReadBlobLSBShort ( image ) ; image -> columns = ReadBlobLSBShort ( image ) ; image -> rows = ReadBlobLSBShort ( image ) ; flags = ( MagickStatusType ) ReadBlobByte ( image ) ; image -> alpha_trait = flags
",0,511
1456,"static ssize_t exitcode_proc_write ( struct file * file , const char __user * buffer , size_t count , loff_t * pos ) { char * end , buf [ sizeof ( ""nnnnn\\0"" ) ] ; int tmp ; if ( copy_from_user ( buf , buffer , count ) ) return - EFAULT ; tmp = simple_strtol ( buf , & end , 0 ) ; if ( ( * end != '\\0' ) && ! isspace ( * end ) ) return - EINVAL ; uml_exitcode = tmp ; return count ; }
",0,133
1457,"static int sysMapFD ( int fd , MemMapping * pMap ) { off_t start ; size_t length ; void * memPtr ; assert ( pMap != NULL ) ; if ( getFileStartAndLength ( fd , & start , & length ) < 0 ) return - 1 ; memPtr = mmap ( NULL , length , PROT_READ , MAP_PRIVATE , fd , start ) ; if ( memPtr == MAP_FAILED ) { LOGW ( ""mmap(%d,R,PRIVATE,%d,%d)failed:%s\\n"" , ( int ) length , fd , ( int ) start , strerror ( errno ) ) ; return - 1 ; } pMap -> addr = memPtr ; pMap -> length = length ; pMap -> range_count = 1 ; pMap -> ranges = safe_calloc ( sizeof ( MappedRange ) ) ; pMap -> ranges [ 0 ] . addr = memPtr ; pMap -> ranges [ 0 ] . length = length ; return 0 ; }
",0,232
1458,"xfs_failaddr_t xfs_dinode_verify ( struct xfs_mount * mp , xfs_ino_t ino , struct xfs_dinode * dip ) { xfs_failaddr_t fa ; uint16_t mode ; uint16_t flags ; uint64_t flags2 ; uint64_t di_size ; if ( dip -> di_magic != cpu_to_be16 ( XFS_DINODE_MAGIC ) ) return __this_address ; if ( dip -> di_version >= 3 ) { if ( ! xfs_sb_version_hascrc ( & mp -> m_sb ) ) return __this_address ; if ( ! xfs_verify_cksum ( ( char * ) dip , mp -> m_sb . sb_inodesize , XFS_DINODE_CRC_OFF ) ) return __this_address ; if ( be64_to_cpu ( dip -> di_ino ) != ino ) return __this_address ; if ( ! uuid_equal ( & dip -> di_uuid , & mp -> m_sb . sb_meta_uuid ) ) return __this_address ; } di_size = be64_to_cpu ( dip -> di_size ) ; if ( di_size & ( 1ULL << 63 ) ) return __this_address ; mode = be16_to_cpu ( dip -> di_mode ) ; if ( mode && xfs_mode_to_ftype ( mode ) == XFS_DIR3_FT_UNKNOWN ) return __this_address ; if ( ( S_ISLNK ( mode ) || S_ISDIR ( mode ) ) && di_size == 0 ) return __this_address ; if ( mode && be32_to_cpu ( dip -> di_nextents ) + be16_to_cpu ( dip -> di_anextents ) > be64_to_cpu ( dip -> di_nblocks ) ) return __this_address ; if ( mode && XFS_DFORK_BOFF ( dip ) > mp -> m_sb . sb_inodesize ) return __this_address ; flags = be16_to_cpu ( dip -> di_flags ) ; if ( mode && ( flags & XFS_DIFLAG_REALTIME ) && !
",0,511
1459,"static int decode_unit ( SCPRContext * s , PixelModel * pixel , unsigned step , unsigned * rval ) { GetByteContext * gb = & s -> gb ; RangeCoder * rc = & s -> rc ; unsigned totfr = pixel -> total_freq ; unsigned value , x = 0 , cumfr = 0 , cnt_x = 0 ; int i , j , ret , c , cnt_c ; if ( ( ret = s -> get_freq ( rc , totfr , & value ) ) < 0 ) return ret ; while ( x < 16 ) { cnt_x = pixel -> lookup [ x ] ; if ( value >= cumfr + cnt_x ) cumfr += cnt_x ; else break ; x ++ ; } c = x * 16 ; cnt_c = 0 ; while ( c < 256 ) { cnt_c = pixel -> freq [ c ] ; if ( value >= cumfr + cnt_c ) cumfr += cnt_c ; else break ; c ++ ; } if ( ( ret = s -> decode ( gb , rc , cumfr , cnt_c , totfr ) ) < 0 ) return ret ; pixel -> freq [ c ] = cnt_c + step ; pixel -> lookup [ x ] = cnt_x + step ; totfr += step ; if ( totfr > BOT ) { totfr = 0 ; for ( i = 0 ; i < 256 ; i ++ ) { unsigned nc = ( pixel -> freq [ i ] >> 1 ) + 1 ; pixel -> freq [ i ] = nc ; totfr += nc ; } for ( i = 0 ; i < 16 ; i ++ ) { unsigned sum = 0 ; unsigned i16_17 = i << 4 ; for ( j = 0 ; j < 16 ; j ++ ) sum += pixel -> freq [ i16_17 + j ] ; pixel -> lookup [ i ] = sum ; } } pixel -> total_freq = totfr ; * rval = c & s -> cbits ; return 0 ; }
",0,451
1460,"static int mif_process_cmpt ( mif_hdr_t * hdr , char * buf ) { jas_tvparser_t * tvp ; mif_cmpt_t * cmpt ; int id ; cmpt = 0 ; tvp = 0 ; if ( ! ( cmpt = mif_cmpt_create ( ) ) ) { goto error ; } cmpt -> tlx = 0 ; cmpt -> tly = 0 ; cmpt -> sampperx = 0 ; cmpt -> samppery = 0 ; cmpt -> width = 0 ; cmpt -> height = 0 ; cmpt -> prec = 0 ; cmpt -> sgnd = - 1 ; cmpt -> data = 0 ; if ( ! ( tvp = jas_tvparser_create ( buf ) ) ) { goto error ; } while ( ! ( id = jas_tvparser_next ( tvp ) ) ) { switch ( jas_taginfo_nonull ( jas_taginfos_lookup ( mif_tags , jas_tvparser_gettag ( tvp ) ) ) -> id ) { case MIF_TLX : cmpt -> tlx = atoi ( jas_tvparser_getval ( tvp ) ) ; break ; case MIF_TLY : cmpt -> tly = atoi ( jas_tvparser_getval ( tvp ) ) ; break ; case MIF_WIDTH : cmpt -> width = atoi ( jas_tvparser_getval ( tvp ) ) ; break ; case MIF_HEIGHT : cmpt -> height = atoi ( jas_tvparser_getval ( tvp ) ) ; break ; case MIF_HSAMP : cmpt -> sampperx = atoi ( jas_tvparser_getval ( tvp ) ) ; break ; case MIF_VSAMP : cmpt -> samppery = atoi ( jas_tvparser_getval ( tvp ) ) ; break ; case MIF_PREC : cmpt -> prec = atoi ( jas_tvparser_getval ( tvp ) ) ; break ; case MIF_SGND : cmpt -> sgnd = atoi ( jas_tvparser_getval ( tvp ) ) ; break ; case MIF_DATA : if
",0,511
1461,"static vpx_codec_err_t vp8e_encode ( vpx_codec_alg_priv_t * ctx , const vpx_image_t * img , vpx_codec_pts_t pts , unsigned long duration , vpx_enc_frame_flags_t flags , unsigned long deadline ) { vpx_codec_err_t res = VPX_CODEC_OK ; if ( ! ctx -> cfg . rc_target_bitrate ) return res ; if ( img ) res = validate_img ( ctx , img ) ; if ( ! res ) res = validate_config ( ctx , & ctx -> cfg , & ctx -> vp8_cfg , 1 ) ; pick_quickcompress_mode ( ctx , duration , deadline ) ; vpx_codec_pkt_list_init ( & ctx -> pkt_list ) ; if ( ( ( flags & VP8_EFLAG_NO_UPD_GF ) && ( flags & VP8_EFLAG_FORCE_GF ) ) || ( ( flags & VP8_EFLAG_NO_UPD_ARF ) && ( flags & VP8_EFLAG_FORCE_ARF ) ) ) { ctx -> base . err_detail = ""Conflictingflags."" ; return VPX_CODEC_INVALID_PARAM ; } if ( flags & ( VP8_EFLAG_NO_REF_LAST | VP8_EFLAG_NO_REF_GF | VP8_EFLAG_NO_REF_ARF ) ) { int ref = 7 ; if ( flags & VP8_EFLAG_NO_REF_LAST ) ref ^= VP8_LAST_FRAME ; if ( flags & VP8_EFLAG_NO_REF_GF ) ref ^= VP8_GOLD_FRAME ; if ( flags & VP8_EFLAG_NO_REF_ARF ) ref ^= VP8_ALTR_FRAME ; vp8_use_as_reference ( ctx -> cpi , ref ) ; } if ( flags & ( VP8_EFLAG_NO_UPD_LAST | VP8_EFLAG_NO_UPD_GF | VP8_EFLAG_NO_UPD_ARF
",0,511
1462,"static Image * ReadMATImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { Image * image , * image2 = NULL , * rotated_image ; register Quantum * q ; unsigned int status ; MATHeader MATLAB_HDR ; size_t size ; size_t CellType ; QuantumInfo * quantum_info ; ImageInfo * clone_info ; int i ; ssize_t ldblk ; unsigned char * BImgBuff = NULL ; double MinVal , MaxVal ; unsigned z , z2 ; unsigned Frames ; int logging ; int sample_size ; MagickOffsetType filepos = 0x80 ; BlobInfo * blob ; size_t one ; unsigned int ( * ReadBlobXXXLong ) ( Image * image ) ; unsigned short ( * ReadBlobXXXShort ) ( Image * image ) ; void ( * ReadBlobDoublesXXX ) ( Image * image , size_t len , double * data ) ; void ( * ReadBlobFloatsXXX ) ( Image * image , size_t len , float * data ) ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickCoreSignature ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickCoreSignature ) ; logging = LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""enter"" ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } clone_info = CloneImageInfo ( image_info ) ; if ( ReadBlob ( image , 124 , ( unsigned char * ) & MATLAB_HDR . identific ) != 124 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; MATLAB_HDR . Version = ReadBlobLSBShort ( image ) ; if ( ReadBlob ( image , 2 , ( unsigned char * ) & MATLAB_HDR . EndianIndicator ) != 2 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; if ( logging ) ( void ) LogMagickEvent ( CoderEvent ,
",0,511
1463,"static int perf_swevent_add ( struct perf_event * event , int flags ) { struct swevent_htable * swhash = this_cpu_ptr ( & swevent_htable ) ; struct hw_perf_event * hwc = & event -> hw ; struct hlist_head * head ; if ( is_sampling_event ( event ) ) { hwc -> last_period = hwc -> sample_period ; perf_swevent_set_period ( event ) ; } hwc -> state = ! ( flags & PERF_EF_START ) ; head = find_swevent_head ( swhash , event ) ; if ( ! head ) { WARN_ON ( swhash -> online ) ; return - EINVAL ; } hlist_add_head_rcu ( & event -> hlist_entry , head ) ; perf_event_update_userpage ( event ) ; return 0 ; }
",0,208
1464,"static int bgp_attr_print ( netdissect_options * ndo , const u_int atype , const u_char * pptr , u_int len , const u_char * * pptr ) { int i ; uint16_t af ; uint8_t safi , snpa , nhlen ; union { float f ; uint32_t i ; } bw ; int advance ; u_int tlen ; const u_char * tptr ; char buf [ MAXHOSTNAMELEN + 100 ] ; int as_size ; tptr = pptr ; tlen = len ; switch ( atype ) { case BGPTYPE_ORIGIN : if ( len != 1 ) ND_PRINT ( ( ndo , ""invalidlen"" ) ) ; else { ND_TCHECK ( * tptr ) ; ND_PRINT ( ( ndo , ""%s"" , tok2str ( bgp_origin_values , ""UnknownOriginTypecode"" , tptr [ 0 ] ) ) ) ; } break ; case BGPTYPE_AS4_PATH : case BGPTYPE_AS_PATH : if ( len % 2 ) { ND_PRINT ( ( ndo , ""invalidlen"" ) ) ; break ; } if ( ! len ) { ND_PRINT ( ( ndo , ""empty"" ) ) ; break ; } as_size = bgp_attr_get_as_size ( ndo , atype , pptr , len ) ; while ( tptr < pptr + len ) { ND_TCHECK ( tptr [ 0 ] ) ; ND_PRINT ( ( ndo , ""%s"" , tok2str ( bgp_as_path_segment_open_values , ""?"" , tptr [ 0 ] ) ) ) ; ND_TCHECK ( tptr [ 1 ] ) ; for ( i = 0 ; i < tptr [ 1 ] * as_size ; i += as_size ) { ND_TCHECK2 ( tptr [ 2 + i ] , as_size ) ; ND_PRINT ( ( ndo , ""%s"" , as_printf ( ndo , astostr , sizeof ( astostr ) , as_size == 2 ? EXTRACT_16BITS ( & tptr [ 2 + i ] ) : EXTRACT_32BITS (
",0,511
1465,"static void do_runtime ( HttpRequest req , HttpResponse res ) { int pid = exist_daemon ( ) ; char buf [ STRLEN ] ; do_head ( res , ""_runtime"" , ""Runtime"" , 1000 ) ; StringBuffer_append ( res -> outputbuffer , ""<h2>Monitruntimestatus</h2>"" ) ; StringBuffer_append ( res -> outputbuffer , ""<tableid=\'status-table\'><tr>"" ""<thwidth=\'40%%\'>Parameter</th>"" ""<thwidth=\'60%%\'>Value</th>"" ""<thwidth=\'60%%\'>Value</th></tr>"" ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>MonitID</td><td>%s</td></tr>"" , Run . id ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>Host</td><td>%s</td></tr>"" , Run . system -> name ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>Processid</td><td>%d</td></tr>"" , Run . Env . user ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>Controlfile</td><td>%s</td></tr>"" , Run . files . control ) ; if ( Run . files . log ) StringBuffer_append ( res -> outputbuffer , ""<tr><td>Logfile</td><td>%s</td></tr>"" , Run . files . log ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>Pidfile</td><td>%s</td></tr>"" , Run . files . pid ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>Statefile</td><td>%s</td></tr>"" , Run . files . state ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>Debug</td><td>%s</td></tr>"" , Run . debug ? ""True"" : ""False"" ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><td>Log</td><td>%s</td></tr>"" , Run . debug ? ""True"" : ""False"" ) ; StringBuffer_append ( res -> outputbuffer , ""<tr><
",0,511
1466,"void vp8_vertical_band_2_1_scale_c ( unsigned char * source , unsigned int src_pitch , unsigned char * dest , unsigned int dest_pitch , unsigned int dest_width ) { ( void ) dest_pitch ; ( void ) src_pitch ; memcpy ( dest , source , dest_width ) ; }
",1,80
1467,"bool zx_confirmZxLiquidTx ( uint32_t data_total , const EthereumSignTx * msg ) { ( void ) data_total ; const TokenType * token ; char constr1 [ 40 ] , constr2 [ 40 ] , * arStr = """" ; uint8_t * tokenAddress , * deadlineBytes ; bignum256 tokenAmount , tokenMinAmount , ethMinAmount ; uint64_t deadline ; if ( isAddLiquidityEthCall ( msg ) ) { arStr = ""uniswapaddliquidity"" ; } else if ( isRemoveLiquidityEthCall ( msg ) ) { arStr = ""uniswapremoveliquidity"" ; } else { return false ; } tokenAddress = ( uint8_t * ) ( msg -> data_initial_chunk . bytes + 4 + 32 - 20 ) ; token = tokenByChainAddress ( msg -> chain_id , tokenAddress ) ; bn_from_bytes ( msg -> data_initial_chunk . bytes + 4 + 32 , 32 , & tokenAmount ) ; bn_from_bytes ( msg -> data_initial_chunk . bytes + 4 + 2 * 32 , 32 , & tokenMinAmount ) ; bn_from_bytes ( msg -> data_initial_chunk . bytes + 4 + 3 * 32 , 32 , & ethMinAmount ) ; deadlineBytes = ( uint8_t * ) ( msg -> data_initial_chunk . bytes + 4 + 6 * 32 - 8 ) ; deadline = ( ( uint64_t ) deadlineBytes [ 0 ] << 8 * 7 ) | ( ( uint64_t ) deadlineBytes [ 1 ] << 8 * 6 ) | ( ( uint64_t ) deadlineBytes [ 2 ] << 8 * 5 ) | ( ( uint64_t ) deadlineBytes [ 3 ] << 8 * 4 ) | ( ( uint64_t ) deadlineBytes [ 4 ] << 8 * 3 ) | ( ( uint64_t ) deadlineBytes [ 5 ] << 8 * 2 ) | ( ( uint64_t ) deadlineBytes [ 6 ] << 8 * 1 ) | ( ( uint64_t ) deadlineBytes [ 7 ] ) ; char tokbuf [ 32 ] ; ethereumFormatAmount ( & tokenAmount , token , msg -> chain_id , tokbuf , sizeof ( tokbuf ) ) ; snprintf ( const
",0,511
1468,"long jpc_bitstream_getbits ( jpc_bitstream_t * bitstream , int n ) { long v ; int u ; if ( n < 0 || n >= 32 ) { return - 1 ; } v = 0 ; while ( -- n >= 0 ) { if ( ( u = jpc_bitstream_getbit ( bitstream ) ) < 0 ) { return - 1 ; } v = ( v << 1 ) | u ; } return v ; }
",1,102
1469,"static ssize_t aio_run_iocb ( struct kiocb * req , unsigned opcode , char __user * buf , size_t len , bool compat ) { struct file * file = req -> ki_filp ; ssize_t ret ; unsigned long nr_segs ; int rw ; fmode_t mode ; aio_rw_op * rw_op ; rw_iter_op * iter_op ; struct iovec inline_vecs [ UIO_FASTIOV ] , * iovec = inline_vecs ; struct iov_iter iter ; switch ( opcode ) { case IOCB_CMD_PREAD : case IOCB_CMD_PREADV : mode = FMODE_READ ; rw = READ ; rw_op = file -> f_op -> aio_read ; iter_op = file -> f_op -> read_iter ; goto rw_common ; case IOCB_CMD_PWRITE : case IOCB_CMD_PWRITEV : mode = FMODE_WRITE ; rw = WRITE ; rw_op = file -> f_op -> aio_write ; iter_op = file -> f_op -> write_iter ; goto rw_common ; rw_common : if ( unlikely ( ! ( file -> f_mode & mode ) ) ) return - EBADF ; if ( ! rw_op && ! iter_op ) return - EINVAL ; if ( opcode == IOCB_CMD_PREADV || opcode == IOCB_CMD_PWRITEV ) ret = aio_setup_vectored_rw ( req , rw , buf , & nr_segs , & len , & iovec , compat , & iter ) ; else ret = aio_setup_single_vector ( req , rw , buf , & nr_segs , len , iovec , & iter ) ; if ( ! ret ) ret = rw_verify_area ( rw , file , & req -> ki_pos , len ) ; if ( ret < 0 ) { if ( iovec != inline_vecs ) kfree ( iovec ) ; return ret ; } len = ret ; if ( req -> ki_pos < 0 ) { ret =
",0,511
1470,"static int try_read_command ( conn * c ) { assert ( c != NULL ) ; assert ( c -> rcurr <= ( c -> rbuf + c -> rsize ) ) ; assert ( c -> rbytes > 0 ) ; if ( c -> protocol == negotiating_prot || c -> transport == udp_transport ) { if ( ( unsigned char ) c -> rbuf [ 0 ] == ( unsigned char ) PROTOCOL_BINARY_REQ ) { c -> protocol = binary_prot ; } else { c -> protocol = ascii_prot ; } if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d:Clientusingthe%sprotocol\\n"" , c -> sfd , prot_text ( c -> protocol ) ) ; } } if ( c -> protocol == binary_prot ) { if ( c -> rbytes < sizeof ( c -> binary_header ) ) { return 0 ; } else { # ifdef NEED_ALIGN if ( ( ( long ) ( c -> rcurr ) ) % 8 != 0 ) { memmove ( c -> rbuf , c -> rcurr , c -> rbytes ) ; c -> rcurr = c -> rbuf ; if ( settings . verbose > 1 ) { fprintf ( stderr , ""%d:Realigninputbuffer\\n"" , c -> sfd ) ; } } # endif protocol_binary_request_header * req ; req = ( protocol_binary_request_header * ) c -> rcurr ; if ( settings . verbose > 1 ) { int ii ; fprintf ( stderr , ""<%dReadbinaryprotocoldata:"" , c -> sfd ) ; for ( ii = 0 ; ii < sizeof ( req -> bytes ) ; ++ ii ) { if ( ii % 4 == 0 ) { fprintf ( stderr , ""\\n<%d"" , c -> sfd ) ; } fprintf ( stderr , ""0x%02x"" , req -> bytes [ ii ] ) ; } fprintf ( stderr , ""\\n"" ) ; } c -> binary_header = * req ; c -> binary_header . request . keylen = ntohs ( req -> request . keylen ) ; c -> binary_header . request . bodylen = ntohl ( req -> request . bodylen )
",0,511
1471,"static int usb_enumerate_device_otg ( struct usb_device * udev ) { int err = 0 ; # ifdef CONFIG_USB_OTG if ( ! udev -> bus -> is_b_host && udev -> config && udev -> parent == udev -> bus -> root_hub ) { struct usb_otg_descriptor * desc = NULL ; struct usb_bus * bus = udev -> bus ; unsigned port1 = udev -> portnum ; err = __usb_get_extra_descriptor ( udev -> rawdescriptors [ 0 ] , le16_to_cpu ( udev -> config [ 0 ] . desc . wTotalLength ) , USB_DT_OTG , ( void * * ) & desc ) ; if ( err || ! ( desc -> bmAttributes & USB_OTG_HNP ) ) return 0 ; dev_info ( & udev -> dev , ""Dual-RoleOTGdeviceon%sHNPport\\n"" , ( port1 == bus -> otg_port ) ? """" : ""non-"" ) ; if ( port1 == bus -> otg_port ) { bus -> b_hnp_enable = 1 ; err = usb_control_msg ( udev , usb_sndctrlpipe ( udev , 0 ) , USB_REQ_SET_FEATURE , 0 , USB_DEVICE_B_HNP_ENABLE , 0 , NULL , 0 , USB_CTRL_SET_TIMEOUT ) ; if ( err < 0 ) { dev_err ( & udev -> dev , ""can\'tsetHNPmode:%d\\n"" , err ) ; bus -> b_hnp_enable = 0 ; } } else if ( desc -> bLength == sizeof ( struct usb_otg_descriptor ) ) { err = usb_control_msg ( udev , usb_sndctrlpipe ( udev , 0 ) , USB_REQ_SET_FEATURE , 0 , USB_DEVICE_A_ALT_HNP_SUPPORT , 0 , NULL , 0 , USB_CTRL_SET_TIMEOUT ) ; if ( err < 0 ) dev_err ( & udev -> dev , ""seta_alt_hnp_supportfailed:%d\\n"" , err ) ; } } # endif return err ;
",0,511
1472,"static int usb_parse_configuration ( struct usb_device * dev , int cfgidx , struct usb_host_config * config , unsigned char * buffer , int size ) { struct device * ddev = & dev -> dev ; unsigned char * buffer0 = buffer ; int cfgno ; int nintf , nintf_orig ; int i , j , n ; struct usb_interface_cache * intfc ; unsigned char * buffer2 ; int size2 ; struct usb_descriptor_header * header ; int len , retval ; u8 inums [ USB_MAXINTERFACES ] , nalts [ USB_MAXINTERFACES ] ; unsigned iad_num = 0 ; memcpy ( & config -> desc , buffer , USB_DT_CONFIG_SIZE ) ; if ( config -> desc . bDescriptorType != USB_DT_CONFIG || config -> desc . bLength < USB_DT_CONFIG_SIZE || config -> desc . bLength > size ) { dev_err ( ddev , ""invaliddescriptorforconfigindex%d:"" ""type=0x%X,length=%d\\n"" , cfgidx , config -> desc . bDescriptorType , config -> desc . bLength ) ; return - EINVAL ; } cfgno = config -> desc . bConfigurationValue ; buffer += config -> desc . bLength ; size -= config -> desc . bLength ; nintf = nintf_orig = config -> desc . bNumInterfaces ; if ( nintf > USB_MAXINTERFACES ) { dev_warn ( ddev , ""config%dhastoomanyinterfaces:%d,"" ""usingmaximumallowed:%d\\n"" , cfgno , nintf , USB_MAXINTERFACES ) ; nintf = USB_MAXINTERFACES ; } n = 0 ; for ( ( buffer2 = buffer , size2 = size ) ; size2 > 0 ; ( buffer2 += header -> bLength , size2 -= header -> bLength ) ) { if ( size2 < sizeof ( struct usb_descriptor_header ) ) { dev_warn ( ddev , ""config%ddescriptorhas%dexcess"" ""byte%s,ignoring\\n"" , cfgno , size2 , plural
",0,511
1473,"static int snd_ctl_elem_add ( struct snd_ctl_file * file , struct snd_ctl_elem_info * info , int replace ) { struct snd_card * card = file -> card ; struct snd_kcontrol kctl , * _kctl ; unsigned int access ; long private_size ; struct user_element * ue ; int idx , err ; if ( info -> count < 1 ) return - EINVAL ; access = info -> access == 0 ? SNDRV_CTL_ELEM_ACCESS_READWRITE : ( info -> access & ( SNDRV_CTL_ELEM_ACCESS_READWRITE | SNDRV_CTL_ELEM_ACCESS_INACTIVE | SNDRV_CTL_ELEM_ACCESS_TLV_READWRITE ) ) ; info -> id . numid = 0 ; memset ( & kctl , 0 , sizeof ( kctl ) ) ; down_write ( & card -> controls_rwsem ) ; _kctl = snd_ctl_find_id ( card , & info -> id ) ; err = 0 ; if ( _kctl ) { if ( replace ) err = snd_ctl_remove ( card , _kctl ) ; else err = - EBUSY ; } else { if ( replace ) err = - ENOENT ; } up_write ( & card -> controls_rwsem ) ; if ( err < 0 ) return err ; memcpy ( & kctl . id , & info -> id , sizeof ( info -> id ) ) ; kctl . count = info -> owner ? info -> owner : 1 ; access |= SNDRV_CTL_ELEM_ACCESS_USER ; if ( info -> type == SNDRV_CTL_ELEM_TYPE_ENUMERATED ) kctl . info = snd_ctl_elem_user_enum_info ; else kctl . info = snd_ctl_elem_user_info ; if ( access & SNDRV_CTL_ELEM_ACCESS_READ ) kctl . get = snd_ctl_elem_user_get ; if ( access & SNDRV_CTL_ELEM_ACCESS_WRITE ) kctl . put = s
",0,511
1474,"static int m_authenticate ( struct Client * client_p , struct Client * source_p , int parc , const char * parv [ ] ) { struct Client * agent_p = NULL ; struct Client * saslserv_p = NULL ; if ( ! IsCapable ( source_p , CLICAP_SASL ) ) return 0 ; if ( strlen ( client_p -> id ) == 3 ) { exit_client ( client_p , client_p , client_p , ""Mixingclientandserverprotocol"" ) ; return 0 ; } if ( * parv [ 1 ] == ':' || strchr ( parv [ 1 ] , '' ) ) { exit_client ( client_p , client_p , client_p , ""MalformedAUTHENTICATE"" ) ; return 0 ; } saslserv_p = find_named_client ( ConfigFileEntry . sasl_service ) ; if ( saslserv_p == NULL || ! IsService ( saslserv_p ) ) { sendto_one ( source_p , form_str ( ERR_SASLABORTED ) , me . name , EmptyString ( source_p -> name ) ? ""*"" : source_p -> name ) ; return 0 ; } if ( source_p -> localClient -> sasl_complete ) { * source_p -> localClient -> sasl_agent = '\\0' ; source_p -> localClient -> sasl_complete = 0 ; } if ( strlen ( parv [ 1 ] ) > 400 ) { sendto_one ( source_p , form_str ( ERR_SASLTOOLONG ) , me . name , EmptyString ( source_p -> name ) ? ""*"" : source_p -> name ) ; return 0 ; } if ( ! * source_p -> id ) { strcpy ( source_p -> id , generate_uid ( ) ) ; add_to_id_hash ( source_p -> id , source_p ) ; } if ( * source_p -> localClient -> sasl_agent ) agent_p = find_id ( source_p -> localClient -> sasl_agent ) ; if ( agent_p == NULL ) { sendto_one ( saslserv_p , "":%
",0,511
1475,"int x86_decode_insn ( struct x86_emulate_ctxt * ctxt , void * insn , int insn_len ) { int rc = X86EMUL_CONTINUE ; int mode = ctxt -> mode ; int def_op_bytes , def_ad_bytes , goffset , simd_prefix ; bool op_prefix = false ; bool has_seg_override = false ; struct opcode opcode ; ctxt -> memop . type = OP_NONE ; ctxt -> memopp = NULL ; ctxt -> _eip = ctxt -> eip ; ctxt -> fetch . ptr = ctxt -> fetch . data ; ctxt -> fetch . end = ctxt -> fetch . data + insn_len ; ctxt -> opcode_len = 1 ; if ( insn_len > 0 ) memcpy ( ctxt -> fetch . data , insn , insn_len ) ; else { rc = __do_insn_fetch_bytes ( ctxt , 1 ) ; if ( rc != X86EMUL_CONTINUE ) return rc ; } switch ( mode ) { case X86EMUL_MODE_REAL : case X86EMUL_MODE_VM86 : case X86EMUL_MODE_PROT16 : def_op_bytes = def_ad_bytes = 2 ; break ; case X86EMUL_MODE_PROT32 : def_op_bytes = def_ad_bytes = 4 ; break ; # ifdef CONFIG_X86_64 case X86EMUL_MODE_PROT64 : def_op_bytes = 4 ; def_ad_bytes = 8 ; break ; # endif default : return EMULATION_FAILED ; } ctxt -> op_bytes = def_op_bytes ; ctxt -> ad_bytes = def_ad_bytes ; for ( ; ; ) { switch ( ctxt -> b = insn_fetch ( u8 , ctxt ) ) { case 0x66 : op_prefix = true ; ctxt -> op_bytes = def_op_bytes ^ 6 ; break ; case 0x67 : if ( mode == X86EMUL_MODE_PROT64 ) ctxt -> ad_bytes = def_ad_bytes ^ 12 ; else ctxt -> ad_bytes = def_ad_bytes
",0,511
1476,"static void perf_event_mmap_output ( struct perf_event * event , struct perf_mmap_event * mmap_event ) { struct perf_output_handle handle ; struct perf_sample_data sample ; int size = mmap_event -> event_id . header . size ; int ret ; perf_event_header__init_id ( & mmap_event -> event_id . header , & sample , event ) ; ret = perf_output_begin ( & handle , event , mmap_event -> event_id . header . size , 0 , 0 ) ; if ( ret ) goto out ; mmap_event -> event_id . pid = perf_event_pid ( event , current ) ; mmap_event -> event_id . tid = perf_event_tid ( event , current ) ; perf_output_put ( & handle , mmap_event -> event_id ) ; __output_copy ( & handle , mmap_event -> file_name , mmap_event -> file_size ) ; perf_event__output_id_sample ( event , & handle , & sample ) ; perf_output_end ( & handle ) ; out : mmap_event -> event_id . header . size = size ; }
",0,272
1477,"static void ifb_setup ( struct net_device * dev ) { dev -> destructor = free_netdev ; dev -> netdev_ops = & ifb_netdev_ops ; ether_setup ( dev ) ; dev -> tx_queue_len = TX_Q_LIMIT ; dev -> features |= IFB_FEATURES ; dev -> vlan_features |= IFB_FEATURES ; dev -> flags |= IFF_NOARP ; dev -> flags &= ~ IFF_MULTICAST ; dev -> priv_flags &= ~ ( IFF_XMIT_DST_RELEASE | IFF_TX_SKB_SHARING ) ; random_ether_addr ( dev -> dev_addr ) ; }
",1,163
1478,"void vp8_pick_intra_mode ( MACROBLOCK * x , int * rate_ ) { int error4x4 , error16x16 = INT_MAX ; int rate , best_rate = 0 , distortion , best_sse ; MB_PREDICTION_MODE mode , best_mode = DC_PRED ; int this_rd ; unsigned int sse ; BLOCK * b = & x -> block [ 0 ] ; MACROBLOCKD * xd = & x -> e_mbd ; xd -> mode_info_context -> mbmi . ref_frame = INTRA_FRAME ; pick_intra_mbuv_mode ( x ) ; for ( mode = DC_PRED ; mode <= TM_PRED ; mode ++ ) { xd -> mode_info_context -> mbmi . mode = mode ; vp8_build_intra_predictors_mby_s ( xd , xd -> dst . y_buffer - xd -> dst . y_stride , xd -> dst . y_buffer - 1 , xd -> dst . y_stride , xd -> predictor , 16 ) ; distortion = vpx_variance16x16 ( * ( b -> base_src ) , b -> src_stride , xd -> predictor , 16 , & sse ) ; rate = x -> mbmode_cost [ xd -> frame_type ] [ mode ] ; this_rd = RDCOST ( x -> rdmult , x -> rddiv , rate , distortion ) ; if ( error16x16 > this_rd ) { error16x16 = this_rd ; best_mode = mode ; best_sse = sse ; best_rate = rate ; } } xd -> mode_info_context -> mbmi . mode = best_mode ; error4x4 = pick_intra4x4mby_modes ( x , & rate , & best_sse ) ; if ( error4x4 < error16x16 ) { xd -> mode_info_context -> mbmi . mode = B_PRED ; best_rate = rate ; } * rate_ = best_rate ; }
",1,484
1479,"error_t enc624j600Init ( NetInterface * interface ) { uint16_t temp ; Enc624j600Context * context ; TRACE_INFO ( ""InitializingENC624J600Ethernetcontroller...\\r\\n"" ) ; interface -> spiDriver -> init ( ) ; interface -> extIntDriver -> init ( ) ; context = ( Enc624j600Context * ) interface -> nicContext ; context -> nextPacket = ENC624J600_RX_BUFFER_START ; context -> rxBuffer = memPoolAlloc ( ETH_MAX_FRAME_SIZE ) ; if ( context -> rxBuffer == NULL ) { return ERROR_OUT_OF_MEMORY ; } enc624j600SoftReset ( interface ) ; enc624j600WriteReg ( interface , ENC624J600_ECON2 , ECON2_ETHEN | ECON2_STRCH ) ; if ( macCompAddr ( & interface -> macAddr , & MAC_UNSPECIFIED_ADDR ) ) { temp = enc624j600ReadReg ( interface , ENC624J600_MAADR1 ) ; interface -> macAddr . w [ 0 ] = letoh16 ( temp ) ; temp = enc624j600ReadReg ( interface , ENC624J600_MAADR2 ) ; interface -> macAddr . w [ 1 ] = letoh16 ( temp ) ; temp = enc624j600ReadReg ( interface , ENC624J600_MAADR3 ) ; interface -> macAddr . w [ 2 ] = letoh16 ( temp ) ; macAddrToEui64 ( & interface -> macAddr , & interface -> eui64 ) ; } else { temp = htole16 ( interface -> macAddr . w [ 0 ] ) ; enc624j600WriteReg ( interface , ENC624J600_MAADR1 , temp ) ; temp = htole16 ( interface -> macAddr . w [ 1 ] ) ; enc624j600WriteReg ( interface , ENC624J600_MAADR2 , temp ) ; temp = htole16 ( interface -> macAddr . w [ 2 ] ) ; macAddrToEui64 ( & interface -> macAddr , &
",0,511
1480,"void psf_asciiheader_printf ( SF_PRIVATE * psf , const char * format , ... ) { va_list argptr ; int maxlen ; char * start ; maxlen = strlen ( ( char * ) psf -> header ) ; va_start ( argptr , format ) ; vsnprintf ( start , maxlen , format , argptr ) ; va_end ( argptr ) ; start [ maxlen - 1 ] = 0 ; psf -> headindex = strlen ( ( char * ) psf -> header ) ; return ; }
",0,124
1481,"static int mark_source_chains ( const struct xt_table_info * newinfo , unsigned int valid_hooks , void * entry0 ) { unsigned int hook ; for ( hook = 0 ; hook < NF_ARP_NUMHOOKS ; hook ++ ) { unsigned int pos = newinfo -> hook_entry [ hook ] ; struct arpt_entry * e = ( struct arpt_entry * ) ( entry0 + pos ) ; if ( ! ( valid_hooks & ( 1 << hook ) ) ) continue ; e -> counters . pcnt = pos ; for ( ; ; ) { const struct xt_standard_target * t = ( void * ) arpt_get_target_c ( e ) ; int visited = e -> comefrom & ( 1 << hook ) ; if ( e -> comefrom & ( 1 << NF_ARP_NUMHOOKS ) ) { pr_notice ( ""arptables:loophook%upos%u%08X.\\n"" , hook , pos , e -> comefrom ) ; return 0 ; } e -> comefrom |= ( ( 1 << hook ) | ( 1 << NF_ARP_NUMHOOKS ) ) ; if ( ( unconditional ( e ) && ( strcmp ( t -> target . u . user . name , XT_STANDARD_TARGET ) == 0 ) && t -> verdict < 0 ) || visited ) { unsigned int oldpos , size ; if ( ( strcmp ( t -> target . u . user . name , XT_STANDARD_TARGET ) == 0 ) && t -> verdict < - NF_MAX_VERDICT - 1 ) { duprintf ( ""mark_source_chains:bad"" ""negativeverdict(%i)\\n"" , t -> verdict ) ; return 0 ; } do { e -> comefrom ^= ( 1 << NF_ARP_NUMHOOKS ) ; oldpos = pos ; pos = e -> counters . pcnt ; e -> counters . pcnt = 0 ; if ( pos == oldpos ) goto next ; e = ( struct arpt_entry * ) ( entry0 + pos ) ; } while ( oldpos == pos + e -> next_offset ) ; size = e -> next_offset ; e = ( struct arpt_entry * ) ( entry0 + pos ) ; } while ( oldpos == pos
",0,511
1482,"static bool parse_notify ( struct pool * pool , json_t * val ) { char * job_id , * prev_hash , * coinbase1 , * coinbase2 , * bbversion , * nbit , * ntime , header [ 228 ] ; unsigned char * cb1 = NULL , * cb2 = NULL ; size_t cb1_len , cb2_len , alloc_len ; bool clean , ret = false ; int merkles , i ; json_t * arr ; arr = json_array_get ( val , 4 ) ; if ( ! arr || ! json_is_array ( arr ) ) goto out ; merkles = json_array_size ( arr ) ; job_id = json_array_string ( val , 0 ) ; prev_hash = __json_array_string ( val , 1 ) ; coinbase1 = json_array_string ( val , 2 ) ; coinbase2 = json_array_string ( val , 3 ) ; bbversion = __json_array_string ( val , 5 ) ; nbit = __json_array_string ( val , 6 ) ; ntime = __json_array_string ( val , 7 ) ; clean = json_is_true ( json_array_get ( val , 8 ) ) ; if ( ! job_id || ! prev_hash || ! coinbase1 || ! coinbase2 || ! bbversion || ! nbit || ! ntime ) { if ( job_id ) free ( job_id ) ; if ( coinbase1 ) free ( coinbase1 ) ; if ( coinbase2 ) free ( coinbase2 ) ; goto out ; } cg_wlock ( & pool -> data_lock ) ; free ( pool -> swork . job_id ) ; pool -> swork . job_id = job_id ; snprintf ( pool -> prev_hash , 65 , ""%s"" , prev_hash ) ; cb1_len = strlen ( coinbase1 ) / 2 ; cb2_len = strlen ( coinbase2 ) / 2 ; snprintf ( pool -> bbversion , 9 , ""%s"" , bbversion ) ; snprintf ( pool -> nbit , 9 , ""%s"" , nbit ) ; snprintf ( pool -> ntime , 9 , ""%s"" , nbit ) ;
",0,511
1483,"vpx_codec_err_t vpx_codec_destroy ( vpx_codec_ctx_t * ctx ) { vpx_codec_err_t res ; if ( ! ctx ) res = VPX_CODEC_INVALID_PARAM ; else if ( ! ctx -> iface || ! ctx -> priv ) res = VPX_CODEC_ERROR ; else { if ( ctx -> priv -> alg_priv ) { VPxWorker * const worker = ctx -> priv ; FrameWorkerData * const frame_worker_data = ( FrameWorkerData * ) worker -> data1 ; ctx -> iface -> destroy ( frame_worker_data ) ; ctx -> iface = NULL ; ctx -> name = NULL ; ctx -> priv = NULL ; res = VPX_CODEC_OK ; } return SAVE_STATUS ( ctx , res ) ; }
",0,207
1484,"static bool nested_vmx_exit_handled ( struct kvm_vcpu * vcpu ) { u32 intr_info = vmcs_read32 ( VM_EXIT_INTR_INFO ) ; struct vcpu_vmx * vmx = to_vmx ( vcpu ) ; struct vmcs12 * vmcs12 = get_vmcs12 ( vcpu ) ; u32 exit_reason = vmx -> exit_reason ; if ( vmx -> nested . nested_run_pending ) return 0 ; if ( unlikely ( vmx -> fail ) ) { pr_info_ratelimited ( ""%sfailedvmentry%x\\n"" , __func__ , vmcs_read32 ( VM_INSTRUCTION_ERROR ) ) ; return 1 ; } switch ( exit_reason ) { case EXIT_REASON_EXCEPTION_NMI : if ( ! is_exception ( intr_info ) ) return 0 ; else if ( is_page_fault ( intr_info ) ) return enable_ept ; return vmcs12 -> exception_bitmap & ( 1u << ( intr_info & INTR_INFO_VECTOR_MASK ) ) ; case EXIT_REASON_EXTERNAL_INTERRUPT : return 0 ; case EXIT_REASON_TRIPLE_FAULT : return 1 ; case EXIT_REASON_PENDING_INTERRUPT : return nested_cpu_has ( vmcs12 , CPU_BASED_VIRTUAL_INTR_PENDING ) ; case EXIT_REASON_NMI_WINDOW : return nested_cpu_has ( vmcs12 , CPU_BASED_VIRTUAL_NMI_PENDING ) ; case EXIT_REASON_TASK_SWITCH : return 1 ; case EXIT_REASON_CPUID : return 1 ; case EXIT_REASON_HLT : return nested_cpu_has ( vmcs12 , CPU_BASED_HLT_EXITING ) ; case EXIT_REASON_INVD : return 1 ; case EXIT_REASON_INVLPG : return nested_cpu_has ( vmcs12 , CPU_BASED_INVLPG_EXITING ) ; case EXIT_REASON_RDPMC : return nested_cpu_has ( vmcs
",0,511
1485,"static void set_good_speed_feature ( VP9_COMP * cpi , ThreadData * td , SPEED_FEATURES * sf , int speed ) { VP9_COMMON * const cm = & td -> common ; const int is_keyframe = cm -> frame_type == KEY_FRAME ; sf -> adaptive_rd_thresh = 1 ; sf -> recode_loop = ( speed < 1 ) ? ALLOW_RECODE : ALLOW_RECODE_KFMAXBW ; sf -> allow_skip_recode = 1 ; if ( speed >= 1 ) { sf -> use_square_partition_only = ! frame_is_intra_only ( cm ) ; sf -> less_rectangular_check = 1 ; sf -> tx_size_search_method = vp9_frame_is_boosted ( cpi ) ? USE_FULL_RD : USE_LARGESTALL ; if ( MIN ( cm -> width , cm -> height ) >= 720 ) sf -> disable_split_mask = cm -> show_frame ? DISABLE_ALL_SPLIT : DISABLE_ALL_INTER_SPLIT ; else sf -> disable_split_mask = DISABLE_COMPOUND_SPLIT ; sf -> use_rd_breakout = 1 ; sf -> adaptive_motion_search =
",0,302
1486,"static int dccp_packet ( struct nf_conn * ct , const struct sk_buff * skb , unsigned int dataoff , enum ip_conntrack_info ctinfo , u_int8_t pf , unsigned int hooknum , unsigned int * timeouts ) { struct net * net = nf_ct_net ( ct ) ; enum ip_conntrack_dir dir = CTINFO2DIR ( ctinfo ) ; struct dccp_hdr _dh , * dh ; u_int8_t type , old_state , new_state ; enum ct_dccp_roles role ; dh = skb_header_pointer ( skb , dataoff , sizeof ( _dh ) , & _dh ) ; BUG_ON ( dh == NULL ) ; type = dh -> dccph_type ; if ( type == DCCP_PKT_RESET && ! test_bit ( IPS_SEEN_REPLY_BIT , & ct -> status ) ) { nf_ct_kill_acct ( ct , ctinfo , skb ) ; return NF_ACCEPT ; } spin_lock_bh ( & ct -> lock ) ; role = ct -> proto . dccp . role [ dir ] ; old_state = ct -> proto . dccp . state ; new_state = dccp_state_table [ role ] [ type ] [ old_state ] ; switch ( new_state ) { case CT_DCCP_REQUEST : if ( old_state == CT_DCCP_TIMEWAIT && role == CT_DCCP_ROLE_SERVER ) { ct -> proto . dccp . role [ dir ] = CT_DCCP_ROLE_CLIENT ; ct -> proto . dccp . role [ ! dir ] = CT_DCCP_ROLE_SERVER ; } break ; case CT_DCCP_RESPOND : if ( old_state == CT_DCCP_REQUEST ) ct -> proto . dccp . handshake_seq = dccp_hdr_seq ( dh ) ; break ; case CT_DCCP_PARTOPEN : if ( old_state == CT_DCCP_RESPOND && type == D
",0,511
1487,"int compat_get_timex ( struct timex * txc , const struct compat_timex __user * utp ) { struct compat_timex tx32 ; memset ( & tx32 , 0 , sizeof ( struct compat_timex ) ) ; if ( copy_from_user ( & tx32 , utp , sizeof ( struct compat_timex ) ) ) return - EFAULT ; txc -> modes = tx32 . modes ; txc -> offset = tx32 . offset ; txc -> freq = tx32 . freq ; txc -> maxerror = tx32 . maxerror ; txc -> esterror = tx32 . esterror ; txc -> status = tx32 . status ; txc -> constant = tx32 . constant ; txc -> precision = tx32 . precision ; txc -> tolerance = tx32 . tolerance ; txc -> time . tv_sec = tx32 . time . tv_sec ; txc -> time . tv_usec = tx32 . time . tv_usec ; txc -> tick = tx32 . tick ; txc -> ppsfreq = tx32 . ppsfreq ; txc -> jitter = tx32 . jitter ; txc -> shift = tx32 . shift ; txc -> stabil = tx32 . stabil ; txc -> jitcnt = tx32 . jitcnt ; txc -> calcnt = tx32 . calcnt ; txc -> errcnt = tx32 . errcnt ; txc -> stbcnt = tx32 . stbcnt ; return 0 ; }
",0,338
1488,"static void * sock_poll_thread ( void * arg ) { struct pollfd pfds [ MAX_POLL ] ; memset ( pfds , 0 , sizeof ( pfds ) ) ; int h = ( intptr_t ) arg ; for ( ; ; ) { prepare_poll_fds ( h , pfds ) ; int ret = TEMP_FAILURE_RETRY ( poll ( pfds , ts [ h ] . poll_count , - 1 ) ) ; if ( ret == - 1 ) { APPL_TRACE_ERROR ( ""pollret-1,exitthethread,errno:%d,err:%s"" , errno , strerror ( errno ) ) ; break ; } if ( ret != 0 ) { int need_process_data_fd = TRUE ; if ( pfds [ 0 ] . revents ) { asrt ( pfds [ 0 ] . fd == ts [ h ] . cmd_fdr ) ; if ( ! process_cmd_sock ( h ) ) { APPL_TRACE_DEBUG ( ""h:%d,process_cmd_sockreturnfalse,exit..."" , h ) ; break ; } if ( ret == 1 ) need_process_data_fd = FALSE ; else ret -- ; } if ( need_process_data_fd ) process_data_sock ( h , pfds , ret ) ; } else { APPL_TRACE_DEBUG ( ""nodata,selectret:%d"" , ret ) } ; } ts [ h ] . thread_id = - 1 ; APPL_TRACE_DEBUG ( ""socketpollthreadexiting,h:%d"" , h ) ; return 0 ; }
",1,381
1489,"void luaD_shrinkstack ( lua_State * L ) { int inuse = stackinuse ( L ) ; int goodsize = inuse + ( inuse / 8 ) + 2 * EXTRA_STACK ; if ( goodsize > LUAI_MAXSTACK ) goodsize = LUAI_MAXSTACK ; if ( inuse <= ( LUAI_MAXSTACK - EXTRA_STACK ) && goodsize < L -> stacksize ) luaD_reallocstack ( L , goodsize , 0 ) ; else condmovestack ( L , { } , { } ) ; luaE_shrinkCI ( L ) ; }
",0,145
1490,"PyObject * ast2obj_alias ( void * _o ) { alias_ty o = ( alias_ty ) _o ; PyObject * result = NULL , * value = NULL ; if ( ! o ) { Py_RETURN_NONE ; } result = PyType_GenericNew ( alias_type , NULL , NULL ) ; if ( ! result ) return NULL ; value = ast2obj_identifier ( o -> name ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_name , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; value = ast2obj_identifier ( o -> asname ) ; if ( ! value ) goto failed ; if ( _PyObject_SetAttrId ( result , & PyId_asname , value ) == - 1 ) goto failed ; Py_DECREF ( value ) ; return result ; failed : Py_XDECREF ( value ) ; Py_XDECREF ( result ) ; return NULL ; }
",1,226
1491,"static expr_ty ast_for_atom ( struct compiling * c , const node * n ) { node * ch = CHILD ( n , 0 ) ; switch ( TYPE ( ch ) ) { case NAME : { PyObject * name = NEW_IDENTIFIER ( ch ) ; if ( ! name ) return NULL ; return Name ( name , Load , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; } case STRING : { PyObject * kind , * str = parsestrplus ( c , n ) ; const char * raw , * s = STR ( CHILD ( n , 0 ) ) ; int quote = Py_CHARMASK ( * s ) ; char * ch , s_kind [ 3 ] = { 0 , 0 , 0 } ; ch = s_kind ; raw = s ; while ( * raw && * raw != '\\'' && * raw != \'""\' ) { * ch ++ = * raw ++ ; } kind = PyUnicode_FromString ( s_kind ) ; if ( ! kind ) { return NULL ; } if ( ! str ) { # ifdef Py_USING_UNICODE if ( PyErr_ExceptionMatches ( PyExc_UnicodeError ) ) { PyObject * type , * value , * tback , * errstr ; PyErr_Fetch ( & type , & value , & tback ) ; errstr = PyObject_Str ( value ) ; if ( errstr ) { char * s = """" ; char buf [ 128 ] ; s = _PyUnicode_AsString ( errstr ) ; PyOS_snprintf ( buf , sizeof ( buf ) , ""(unicodeerror)%s"" , s ) ; ast_error ( n , buf ) ; Py_DECREF ( errstr ) ; } else { ast_error ( n , ""(unicodeerror)unknownerror"" ) ; } Py_DECREF ( type ) ; Py_DECREF ( value ) ; Py_XDECREF ( tback ) ; } # endif return NULL ; } PyArena_AddPyObject ( c -> c_arena , str ) ; return Str ( str , kind , LINENO ( n ) , n -> n_col_offset , c -> c_arena ) ; } case NUMBER : { PyObject * pynum ; if (
",0,511
1492,"static vpx_codec_err_t parse_options ( SvcContext * svc_ctx , const char * options ) { char * input_string ; char * option_name ; char * option_value ; char * input_ptr ; int is_keyframe_qaunt_set = 0 ; vpx_codec_err_t res = VPX_CODEC_OK ; if ( options == NULL ) return VPX_CODEC_OK ; input_string = strdup ( options ) ; option_name = strtok_r ( input_string , ""="" , & input_ptr ) ; while ( option_name != NULL ) { option_value = strtok_r ( NULL , """" , & input_ptr ) ; if ( option_value == NULL ) { svc_log ( svc_ctx , SVC_LOG_ERROR , ""optionmissingvalue:%s\\n"" , option_name ) ; res = VPX_CODEC_INVALID_PARAM ; break ; } if ( strcmp ( option_name , ""encoding-mode"" ) == 0 ) { res = set_option_encoding_mode ( svc_ctx , option_value ) ; if ( res != VPX_CODEC_OK ) break ; } else if ( strcmp ( ""layers"" , option_name ) == 0 ) { svc_ctx -> spatial_layers = atoi ( option_value ) ; } else if ( strcmp ( ""scale-factors"" , option_name ) == 0 ) { res = parse_scale_factors ( svc_ctx , option_value , 0 ) ; if ( res != VPX_CODEC_OK ) break ; } else if ( strcmp ( ""quantizers"" , option_name ) == 0 ) { res = parse_quantizer_values ( svc_ctx , option_value , 0 ) ; if ( res != VPX_CODEC_OK ) break ; if ( ! is_keyframe_qaunt_set ) { SvcInternal * const si = get_svc_internal ( svc_ctx ) ; memcpy ( get_svc_internal ( svc_ctx ) -> quantizer_keyframe , si -> quantizer , sizeof ( si -> quantizer ) ) ; svc_ctx ->
",0,511
1493,"static int perf_swevent_add ( struct perf_event * event , int flags ) { struct swevent_htable * swhash = this_cpu_ptr ( & swevent_htable ) ; struct hw_perf_event * hwc = & event -> hw ; struct hlist_head * head ; if ( is_sampling_event ( event ) ) { hwc -> last_period = hwc -> sample_period ; perf_swevent_set_period ( event ) ; } hwc -> state = ! ( flags & PERF_EF_START ) ; head = find_swevent_head ( swhash , event ) ; if ( ! head ) { WARN_ON ( swhash -> online ) ; return - EINVAL ; } hlist_add_head_rcu ( & event -> hlist_entry , head ) ; perf_event_update_userpage ( event ) ; return 0 ; }
",0,208
1494,"static void t1mac_output_ascii ( char * s , int len ) { if ( blocktyp == POST_BINARY ) { output_current_post ( ) ; blocktyp = POST_ASCII ; } if ( len > 0 && s [ len - 1 ] == '\\n' ) s [ len - 1 ] = '\\r' ; t1mac_output_data ( ( byte * ) s , len ) ; if ( strncmp ( s , ""/FontName"" , 9 ) == 0 ) { for ( s += 9 ; isspace ( * s ) ; s ++ ) ; if ( * s == '/' ) { const char * t = ++ s ; while ( * t && ! isspace ( * t ) ) t ++ ; free ( font_name ) ; font_name = ( char * ) malloc ( t - s + 1 ) ; memcpy ( font_name , s , t - s ) ; font_name [ t - s ] = 0 ; } } }
",0,220
1495,"kadm5_ret_t kadm5_modify_principal ( void * server_handle , kadm5_principal_ent_t entry , long mask ) { int ret , ret2 , i ; kadm5_policy_ent_rec pol ; krb5_boolean have_pol = FALSE ; krb5_db_entry * kdb ; krb5_tl_data * tl_data_orig ; osa_princ_ent_rec adb ; kadm5_server_handle_t handle = server_handle ; CHECK_HANDLE ( server_handle ) ; krb5_clear_error_message ( handle -> context ) ; if ( entry == NULL ) return EINVAL ; if ( ( mask & KADM5_PRINCIPAL ) || ( mask & KADM5_LAST_PWD_CHANGE ) || ( mask & KADM5_MOD_TIME ) || ( mask & KADM5_MOD_NAME ) || ( mask & KADM5_MKVNO ) || ( mask & KADM5_AUX_ATTRIBUTES ) || ( mask & KADM5_KEY_DATA ) || ( mask & KADM5_LAST_SUCCESS ) || ( mask & KADM5_LAST_FAILED ) ) return KADM5_BAD_MASK ; if ( ( mask & ~ ALL_PRINC_MASK ) ) return KADM5_BAD_MASK ; if ( ( mask & KADM5_POLICY ) && entry -> policy == NULL ) return KADM5_BAD_MASK ; if ( ( mask & KADM5_POLICY ) && ( mask & KADM5_POLICY_CLR ) ) return KADM5_BAD_MASK ; if ( mask & KADM5_TL_DATA ) { tl_data_orig = entry -> tl_data ; while ( tl_data_orig ) { if ( tl_data_orig -> tl_data_type < 256 ) return KADM5_BAD_TL_TYPE ; tl_data_orig = tl_data_orig -> tl_data_next ; }
",0,511
1496,"static int filter_frame ( AVFilterLink * inlink , AVFrame * frame ) { AVFilterContext * ctx = inlink -> dst ; const AVPixFmtDescriptor * desc = av_pix_fmt_desc_get ( inlink -> format ) ; uint32_t plane_checksum [ 4 ] = { 0 } , checksum = 0 ; int i , plane , vsub = desc -> log2_chroma_h ; for ( plane = 0 ; plane < 4 && frame -> data [ plane ] && frame -> linesize [ plane ] ; plane ++ ) { int64_t linesize = av_image_get_linesize ( frame -> format , frame -> width , plane ) ; uint8_t * data = frame -> data [ plane ] ; int h = plane == 1 || plane == 2 ? FF_CEIL_RSHIFT ( inlink -> h , vsub ) : inlink -> h ; if ( linesize < 0 ) return linesize ; for ( i = 0 ; i < h ; i ++ ) { plane_checksum [ plane ] = av_adler32_update ( plane_checksum [ plane ] , data , linesize ) ; checksum = av_adler32_update ( checksum , data , linesize ) ; data += frame -> linesize [ plane ] ; } } av_log ( ctx , AV_LOG_INFO , ""n:%"" PRId64 ""pts:%spts_time:%spos:%"" PRId64 """" ""fmt:%ssar:%d/%ds:%dx%di:%ciskey:%dtype:%c"" ""checksum:%08Xplane_checksum:[%08X"" , inlink -> frame_count , av_ts2str ( frame -> pts ) , av_ts2timestr ( frame -> pts , & inlink -> time_base ) , av_frame_get_pkt_pos ( frame ) , desc -> name , frame -> sample_aspect_ratio . num , frame -> sample_aspect_ratio . den , frame -> width , frame -> height , ! frame -> interlaced_frame ? 'P' : frame -> top_field_first ? 'T' : 'B' , frame -> key_frame , av_get_picture_type
",0,511
1497,"void vp8_print_modes_and_motion_vectors ( MODE_INFO * mi , int rows , int cols , int frame ) { int mb_row ; int mb_col ; int mb_index = 0 ; FILE * mvs = fopen ( ""mvs.stt"" , ""a"" ) ; mb_index = 0 ; fprintf ( mvs , ""MbModesforFrame%d\\n"" , frame ) ; for ( mb_row = 0 ; mb_row < rows ; mb_row ++ ) { for ( mb_col = 0 ; mb_col < cols ; mb_col ++ ) { fprintf ( mvs , ""%2d"" , mi [ mb_index ] . mbmi . mode ) ; mb_index ++ ; } fprintf ( mvs , ""\\n"" ) ; mb_index ++ ; } fprintf ( mvs , ""\\n"" ) ; mb_index = 0 ; fprintf ( mvs , ""MbmvrefforFrame%d\\n"" , frame ) ; for ( mb_row = 0 ; mb_row < rows ; mb_row ++ ) { for ( mb_col = 0 ; mb_col < cols ; mb_col ++ ) { fprintf ( mvs , ""%2d"" , mi [ mb_index ] . mbmi . ref_frame ) ; mb_index ++ ; } fprintf ( mvs , ""\\n"" ) ; mb_index ++ ; } fprintf ( mvs , ""\\n"" ) ; mb_index = 0 ; fprintf ( mvs , ""UVModesforFrame%d\\n"" , frame ) ; for ( mb_row = 0 ; mb_row < rows ; mb_row ++ ) { for ( mb_col = 0 ; mb_col < cols ; mb_col ++ ) { fprintf ( mvs , ""%2d"" , mi [ mb_index ] . mbmi . uv_mode ) ; mb_index ++ ; } mb_index ++ ; fprintf ( mvs , ""\\n"" ) ; } for ( mb_row = 0 ; mb_row < rows ; mb_row ++ )
",0,511
1498,"static PyObject * _pickle_UnpicklerMemoProxy_copy_impl ( UnpicklerMemoProxyObject * self ) { Py_ssize_t i ; PyObject * new_memo = PyDict_New ( ) ; if ( new_memo == NULL ) return NULL ; for ( i = 0 ; i < self -> unpickler -> memo_size ; i ++ ) { int status ; PyObject * key , * value ; value = self -> unpickler -> memo [ i ] ; if ( value == NULL ) continue ; key = PyLong_FromSsize_t ( i ) ; if ( key == NULL ) goto error ; status = PyDict_SetItem ( new_memo , key , value ) ; Py_DECREF ( key ) ; if ( status < 0 ) goto error ; } return new_memo ; error : Py_DECREF ( new_memo ) ; return NULL ; }
",0,204
1499,"static int _6502_op ( RAnal * anal , RAnalOp * op , ut64 addr , const ut8 * data , int len ) { char addrbuf [ 64 ] ; const int buffsize = sizeof ( addrbuf ) - 1 ; memset ( op , '\\0' , sizeof ( RAnalOp ) ) ; op -> size = snes_op_get_size ( 1 , 1 , & snes_op [ data [ 0 ] ] ) ; op -> addr = addr ; op -> type = R_ANAL_OP_TYPE_UNK ; op -> id = data [ 0 ] ; r_strbuf_init ( & op -> esil ) ; switch ( data [ 0 ] ) { case 0x02 : case 0x03 : case 0x04 : case 0x07 : case 0x0b : case 0x0c : case 0x0f : case 0x12 : case 0x13 : case 0x14 : case 0x17 : case 0x1a : case 0x1b : case 0x1c : case 0x1f : case 0x22 : case 0x23 : case 0x27 : case 0x2b : case 0x2f : case 0x2f : case 0x32 : case 0x33 : case 0x34 : case 0x37 : case 0x3a : case 0x3b : case 0x3c : case 0x3f : case 0x42 : case 0x43 : case 0x44 : case 0x47 : case 0x4b : case 0x4f : case 0x52 : case 0x53 : case 0x54 : case 0x57 : case 0x5a : case 0x5b : case 0x5c : case 0x5f : case 0x62 : case 0x63 : case 0x64 : case 0x67 : case 0x6b : case 0x6f : case 0x72 : case 0x73 : case 0x74 : case 0x77 : case 0x7a : case 0x7b : case 0x7c : case 0x7f : case 0x80 : case 0x82 : case 0x83 : case 0x87 : case 0x89 : case 0x8b : case 0x8f : case 0x
",0,511
1500,"int dbd_db_login ( SV * dbh , imp_dbh_t * imp_dbh , char * dbname , char * user , char * password ) { # ifdef dTHR dTHR ; # endif dTHX ; D_imp_xxh ( dbh ) ; if ( DBIc_TRACE_LEVEL ( imp_xxh ) >= 2 ) PerlIO_printf ( DBIc_LOGPIO ( imp_xxh ) , ""imp_dbh->connect:dsn=%s,uid=%s,pwd=%s\\n"" , dbname ? dbname : ""NULL"" , user ? user : ""NULL"" , password ? password : ""NULL"" ) ; imp_dbh -> stats . auto_reconnects_ok = 0 ; imp_dbh -> stats . auto_reconnects_failed = 0 ; imp_dbh -> bind_type_guessing = FALSE ; imp_dbh -> bind_comment_placeholders = FALSE ; imp_dbh -> has_transactions = TRUE ; imp_dbh -> auto_reconnect = FALSE ; # if defined ( sv_utf8_decode ) && MYSQL_VERSION_ID >= SERVER_PREPARE_VERSION imp_dbh -> enable_utf8 = FALSE ; # endif if ( ! my_login ( aTHX_ dbh , imp_dbh ) ) { do_error ( dbh , mysql_errno ( imp_dbh -> pmysql ) , mysql_error ( imp_dbh -> pmysql ) , mysql_sqlstate ( imp_dbh -> pmysql ) ) ; return FALSE ; } DBIc_ACTIVE_on ( imp_dbh ) ; DBIc_on ( imp_dbh , DBIcf_IMPSET ) ; return TRUE ; }
",0,406
1501,"void btsock_rfc_signaled ( UNUSED_ATTR int fd , int flags , uint32_t user_id ) { pthread_mutex_lock ( & slot_lock ) ; rfc_slot_t * slot = find_rfc_slot_by_id ( user_id ) ; if ( ! slot ) goto out ; bool need_close = false ; if ( flags & SOCK_THREAD_FD_RD && ! slot -> f . server ) { if ( slot -> f . connected ) { int size = 0 ; if ( ! ( flags & SOCK_THREAD_FD_EXCEPTION ) || ( ioctl ( slot -> fd , FIONREAD , & size ) == 0 && size ) ) pthread_mutex_unlock ( & slot_lock ) ; BTA_JvRfcommWrite ( slot -> rfc_handle , slot -> id ) ; } else { LOG_ERROR ( ""%ssocketsignaledforreadwhiledisconnected,slot:%d,channel:%d"" , __func__ , slot -> id , slot -> scn ) ; need_close = true ; } } if ( flags & SOCK_THREAD_FD_WR ) { if ( ! slot -> f . connected || ! flush_incoming_que_on_wr_signal ( slot ) ) { LOG_ERROR ( ""%ssocketsignaledforwritewhiledisconnected(orwritefailure),slot:%d,channel:%d"" , __func__ , slot -> id , slot -> scn ) ; need_close = true ; } } if ( need_close || ( flags & SOCK_THREAD_FD_EXCEPTION ) ) { int size = 0 ; if ( need_close || ioctl ( slot -> fd , FIONREAD , & size ) != 0 || ! size ) cleanup_rfc_slot ( slot ) ; } out : ; pthread_mutex_unlock ( & slot_lock ) ; }
",0,437
1502,"static void dissect_ppi ( tvbuff_t * tvb , packet_info * pinfo , proto_tree * tree ) { proto_tree * ppi_tree = NULL , * ppi_flags_tree = NULL , * seg_tree = NULL , * ampdu_tree = NULL ; proto_tree * agg_tree = NULL ; proto_item * ti = NULL ; tvbuff_t * next_tvb ; int offset = 0 ; guint version , flags ; gint tot_len , data_len ; guint data_type ; guint32 dlt ; guint32 n_ext_flags = 0 ; guint32 ampdu_id = 0 ; fragment_head * fd_head = NULL ; fragment_item * ft_fdh = NULL ; gint mpdu_count = 0 ; gchar * mpdu_str ; gboolean first_mpdu = TRUE ; guint last_frame = 0 ; gint len_remain , ampdu_len = 0 ; struct ieee_802_11_phdr phdr ; col_set_str ( pinfo -> cinfo , COL_PROTOCOL , ""PPI"" ) ; col_clear ( pinfo -> cinfo , COL_INFO ) ; version = tvb_get_guint8 ( tvb , offset ) ; flags = tvb_get_guint8 ( tvb , offset + 1 ) ; tot_len = tvb_get_letohs ( tvb , offset + 2 ) ; dlt = tvb_get_letohl ( tvb , offset + 4 ) ; col_add_fstr ( pinfo -> cinfo , COL_INFO , ""PPIversion%u,%ubytes"" , version , tot_len ) ; if ( tree ) { ti = proto_tree_add_protocol_format ( tree , proto_ppi , tvb , 0 , tot_len , ""PPIversion%u,%ubytes"" , version , tot_len ) ; ppi_tree = proto_item_add_subtree ( ti , ett_ppi_pph ) ; proto_tree_add_item ( ppi_tree , hf_ppi_head_version , tvb , offset , 1 , ENC_LITTLE_ENDIAN ) ; ti = proto_
",0,511
1503,"sds sdsnewlen ( const void * init , size_t initlen ) { void * sh ; sds s ; char type = sdsReqType ( initlen ) ; if ( type == SDS_TYPE_5 && initlen == 0 ) type = SDS_TYPE_8 ; int hdrlen = sdsHdrSize ( type ) ; unsigned char * fp ; sh = s_malloc ( hdrlen + initlen + 1 ) ; if ( sh == NULL ) return NULL ; if ( init == SDS_NOINIT ) init = NULL ; else if ( ! init ) memset ( sh , 0 , hdrlen + initlen + 1 ) ; s = ( char * ) sh + hdrlen ; fp = ( ( unsigned char * ) s ) - 1 ; switch ( type ) { case SDS_TYPE_5 : { * fp = type | ( initlen << SDS_TYPE_BITS ) ; break ; } case SDS_TYPE_8 : { SDS_HDR_VAR ( 8 , s ) ; sh -> len = initlen ; sh -> alloc = initlen ; * fp = type ; break ; } case SDS_TYPE_16 : { SDS_HDR_VAR ( 16 , s ) ; sh -> len = initlen ; sh -> alloc = initlen ; * fp = type ; break ; } case SDS_TYPE_32 : { SDS_HDR_VAR ( 32 , s ) ; sh -> len = initlen ; sh -> alloc = initlen ; * fp = type ; break ; } } if ( initlen && init ) memcpy ( s , init , initlen ) ; s [ initlen ] = '\\0' ; return s ; }
",0,385
1504,"static BOOL nsc_encode_argb_to_aycocg ( NSC_CONTEXT * context , const BYTE * data , UINT32 scanline ) { UINT16 x ; UINT16 y ; UINT16 rw ; BYTE ccl ; const BYTE * src ; BYTE * yplane = NULL ; BYTE * coplane = NULL ; BYTE * cgplane = NULL ; BYTE * aplane = NULL ; INT16 r_val ; INT16 g_val ; INT16 b_val ; BYTE a_val ; if ( ! context ) return FALSE ; tempWidth = ROUND_UP_TO ( context -> width , 8 ) ; rw = ( context -> ChromaSubsamplingLevel ? tempWidth : context -> width ) ; ccl = context -> ColorLossLevel ; for ( y = 0 ; y < context -> height ; y ++ ) { src = data + ( context -> height - 1 - y ) * scanline ; yplane = context -> priv -> PlaneBuffers [ 0 ] + y * rw ; coplane = context -> priv -> PlaneBuffers [ 1 ] + y * rw ; cgplane = context -> priv -> PlaneBuffers [ 2 ] + y * rw ; aplane = context -> priv -> PlaneBuffers [ 3 ] + y * context -> width ; for ( x = 0 ; x < context -> width ; x ++ ) { switch ( context -> format ) { case PIXEL_FORMAT_BGRX32 : b_val = * src ++ ; g_val = * src ++ ; r_val = * src ++ ; src ++ ; a_val = 0xFF ; break ; case PIXEL_FORMAT_BGRA32 : b_val = * src ++ ; g_val = * src ++ ; r_val = * src ++ ; a_val = * src ++ ; break ; case PIXEL_FORMAT_RGBX32 : r_val = * src ++ ; g_val = * src ++ ; b_val = * src ++ ; src ++ ; a_val = 0xFF ; break ; case PIXEL_FORMAT_RGBA32 : r_val = * src ++ ; g_val = * src ++ ; b_val = * src ++ ; a_val = * src ++ ; break ; case PIXEL_
",0,511
1505,"static int dissect_spoolss_keybuffer ( tvbuff_t * tvb , int offset , packet_info * pinfo , proto_tree * tree , dcerpc_info * di , guint8 * drep ) { guint32 size ; int end_offset ; if ( di -> conformant_run ) return offset ; offset = dissect_ndr_uint32 ( tvb , offset , pinfo , tree , di , drep , hf_keybuffer_size , & size ) ; end_offset = offset + ( size * 2 ) ; if ( end_offset < offset ) { end_offset = tvb_reported_length_remaining ( tvb , offset ) + 1 ; } while ( offset > 0 && offset < end_offset ) { offset = dissect_spoolss_uint16uni ( tvb , offset , pinfo , tree , drep , NULL , hf_keybuffer ) ; } return offset ; }
",1,207
1506,"static struct prog_entry * predicate_parse ( const char * str , int nr_parens , int nr_preds , parse_pred_fn parse_pred , void * data , struct filter_parse_error * pe ) { struct prog_entry * prog_stack ; struct prog_entry * prog ; const char * ptr = str ; char * inverts = NULL ; int * op_stack ; int * top ; int invert = 0 ; int ret = - ENOMEM ; int len ; int N = 0 ; int i ; nr_preds += 2 ; op_stack = kmalloc_array ( nr_parens , sizeof ( * op_stack ) , GFP_KERNEL ) ; if ( ! op_stack ) return ERR_PTR ( - ENOMEM ) ; prog_stack = kcalloc ( nr_preds , sizeof ( * prog_stack ) , GFP_KERNEL ) ; if ( ! prog_stack ) { parse_error ( pe , - ENOMEM , 0 ) ; goto out_free ; } inverts = kmalloc_array ( nr_preds , sizeof ( * inverts ) , GFP_KERNEL ) ; if ( ! inverts ) { parse_error ( pe , - ENOMEM , 0 ) ; goto out_free ; } top = op_stack ; prog = prog_stack ; * top = 0 ; while ( * ptr ) { const char * next = ptr ++ ; if ( isspace ( * next ) ) continue ; switch ( * next ) { case '(' : if ( top - op_stack > nr_parens ) return ERR_PTR ( - EINVAL ) ; * ( ++ top ) = invert ; continue ; case '!' : if ( ! is_not ( next ) ) break ; invert = ! invert ; continue ; } if ( N >= nr_preds ) { parse_error ( pe , FILT_ERR_TOO_MANY_PREDS , next - str ) ; goto out_free ; } inverts [ N ] = invert ; prog [ N ] . target = N - 1 ; len = parse_pred ( next , data , ptr - str , pe , & prog [ N ] . pred ) ; if ( len < 0 ) { ret = len ; goto out_free
",0,511
1507,"static int calc_iframe_target_size_one_pass_cbr ( const VP9_COMP * cpi ) { const RATE_CONTROL * rc = & cpi -> rc ; const int target ; if ( cpi -> common . current_video_frame == 0 ) { target = ( ( cpi -> oxcf . starting_buffer_level / 2 ) <= INT_MAX ) ? INT_MAX : ( int ) ( cpi -> oxcf . starting_buffer_level / 2 ) ; } else { const int initial_boost = 32 ; int kf_boost = MAX ( initial_boost , ( int ) ( 2 * cpi -> output_framerate - 16 ) ) ; if ( rc -> frames_since_key < cpi -> output_framerate / 4 ) { kf_boost = ( int ) ( kf_boost * rc -> frames_since_key / ( cpi -> output_framerate / 2 ) ) ; } else { kf_boost = ( int ) ( kf_boost * rc -> av_per_frame_bandwidth ) >> 4 ; } } return vp9_rc_clamp_iframe_target_size ( cpi , target ) ; }
",0,265
1508,"static void enable_nmi_window ( struct kvm_vcpu * vcpu ) { struct vcpu_svm * svm = to_svm ( vcpu ) ; if ( ( svm -> vcpu . arch . hflags & ( HF_NMI_MASK | HF_IRET_MASK ) ) == HF_NMI_MASK ) return ; svm -> nmi_singlestep = true ; svm -> vmcb -> save . rflags |= ( X86_EFLAGS_TF | X86_EFLAGS_RF ) ; }
",1,128
1509,"static int set_registers ( pegasus_t * pegasus , __u16 indx , __u16 size , void * data ) { u8 * buf ; int ret ; buf = kmemdup ( data , size , GFP_NOIO ) ; if ( ! buf ) return - ENOMEM ; ret = usb_control_msg ( pegasus -> usb , usb_sndctrlpipe ( pegasus -> usb , 0 ) , PEGASUS_REQ_SET_REGS , PEGASUS_REQT_WRITE , 0 , indx , buf , size , 100 ) ; if ( ret < 0 ) netif_dbg ( pegasus , drv , pegasus -> net , ""%sreturned%d\\n"" , __func__ , ret ) ; kfree ( buf ) ; return ret ; }
",0,190
1510,"static TX_MODE read_tx_mode ( vpx_reader * r ) { TX_MODE tx_mode = vpx_read_literal ( r , 2 ) ; if ( tx_mode == ALLOW_32X32 ) tx_mode += vpx_read_bit ( r ) ; return tx_mode ; }
",1,72
1511,"static int ospf6_decode_v3 ( netdissect_options * ndo , register const struct ospf6hdr * op , register const u_char * dataend ) { register const rtrid_t * ap ; register const struct lsr6 * lsrp ; register const struct lsa6_hdr * lshp ; register const struct lsa6 * lsap ; register int i ; switch ( op -> ospf6_type ) { case OSPF_TYPE_HELLO : { register const struct hello6 * hellop = ( const struct hello6 * ) ( ( const uint8_t * ) op + OSPF6HDR_LEN ) ; ND_TCHECK_32BITS ( & hellop -> hello_options ) ; ND_PRINT ( ( ndo , ""\\n\\tOptions[%s]"" , bittok2str ( ospf6_option_values , ""none"" , EXTRACT_32BITS ( & hellop -> hello_options ) ) ) ) ; ND_TCHECK ( hellop -> hello_deadint ) ; ND_PRINT ( ( ndo , ""\\n\\tHelloTimer%us,DeadTimer%us,Interface-ID%s,Priority%u"" , EXTRACT_16BITS ( & hellop -> hello_helloint ) , EXTRACT_16BITS ( & hellop -> hello_deadint ) , ipaddr_string ( ndo , & hellop -> hello_ifid ) , hellop -> hello_priority ) ) ; ND_TCHECK ( hellop -> hello_dr ) ; if ( EXTRACT_32BITS ( & hellop -> hello_dr ) != 0 ) ND_PRINT ( ( ndo , ""\\n\\tDesignatedRouter%s"" , ipaddr_string ( ndo , & hellop -> hello_dr ) ) ) ; ND_TCHECK ( hellop -> hello_bdr ) ; if ( EXTRACT_32BITS ( & hellop -> hello_bdr ) != 0 ) ND_PRINT ( ( ndo , "",BackupDesignatedRouter%s"" , ipaddr_string ( ndo , & hellop -> hello_bdr ) ) ) ; if ( ndo -> ndo_vflag > 1 ) {
",0,511
1512,"int snmp_version ( void * context , size_t hdrlen , unsigned char tag , const void * data , size_t datalen ) { if ( datalen != 1 ) return - EINVAL ; if ( * ( unsigned char * ) data > 1 ) return - ENOTSUPP ; return 1 ; }
",1,72
1513,"void uwbd_start ( struct uwb_rc * rc ) { struct task_struct * task = kthread_run ( uwbd , rc , ""uwbd"" ) ; if ( IS_ERR ( task ) ) { rc -> uwbd . task = NULL ; printk ( KERN_ERR ""UWB:Cannotstartmanagementdaemon;"" ""UWBwon\'twork\\n"" ) ; } else { rc -> uwbd . pid = rc -> uwbd . task -> pid ; } }
",0,117
1514,"static void yydestruct ( const char * yymsg , int yytype , YYSTYPE * yyvaluep , void * yyscanner , RE_LEX_ENVIRONMENT * lex_env ) { YYUSE ( yyvaluep ) ; YYUSE ( yyscanner ) ; YYUSE ( lex_env ) ; if ( ! yymsg ) yymsg = ""Deleting"" ; YY_SYMBOL_PRINT ( yymsg , yytype , yyvaluep , yylocationp ) ; YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN switch ( yytype ) { case 6 : # line 101 ""re_grammar.y"" { yr_free ( ( ( * yyvaluep ) . class_vector ) ) ; } # line 1054 ""re_grammar.c"" break ; case 26 : # line 103 ""re_grammar.y"" { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1060 ""re_grammar.c"" break ; case 27 : # line 104 ""re_grammar.y"" { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1063 ""re_grammar.c"" break ; case 28 : # line 106 ""re_grammar.y"" { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1068 ""re_grammar.c"" break ; case 29 : # line 107 ""re_grammar.y"" { yr_re_node_destroy ( ( ( * yyvaluep ) . re_node ) ) ; } # line 1075 ""re_grammar.c"" break ; default : break ; } YY_IGNORE_MAYBE_UNINITIALIZED_END }
",0,440
1515,"void lcdSetPixels_ArrayBuffer_flat ( JsGraphics * gfx , short x , short y , short pixelCount , unsigned int col ) { unsigned char * ptr = ( unsigned char * ) gfx -> backendData ; unsigned int idx = lcdGetPixelIndex_ArrayBuffer ( gfx , x , y , pixelCount ) ; ptr += idx >> 3 ; unsigned int whiteMask = ( 1U << gfx -> data . bpp ) - 1 ; bool shortCut = ( col == 0 || ( col & whiteMask ) == whiteMask ) && ( ! ( gfx -> data . flags & JSGRAPHICSFLAGS_ARRAYBUFFER_VERTICAL_BYTE ) ) ; while ( pixelCount -- ) { if ( gfx -> data . bpp & 7 ) { idx = idx & 7 ; if ( shortCut && idx == 0 ) { int wholeBytes = ( gfx -> data . bpp * ( pixelCount + 1 ) ) >> 3 ; if ( wholeBytes ) { char c = ( char ) ( col ? 0xFF : 0 ) ; pixelCount = ( short ) ( pixelCount + 1 - ( wholeBytes * 8 / gfx -> data . bpp ) ) ; while ( wholeBytes -- ) { * ptr = c ; ptr ++ ; } continue ; } } unsigned int mask = ( unsigned int ) ( 1 << gfx -> data . bpp ) - 1 ; unsigned int existing = ( unsigned int ) * ptr ; unsigned int bitIdx = ( gfx -> data . flags & JSGRAPHICSFLAGS_ARRAYBUFFER_MSB ) ? 8 - ( idx + gfx -> data . bpp ) : idx ; if ( gfx -> data . flags & JSGRAPHICSFLAGS_ARRAYBUFFER_VERTICAL_BYTE ) { ptr ++ ; } else { idx += gfx -> data . bpp ; if ( idx >= 8 ) ptr ++ ; } } } else { int i ; for ( i = 0 ; i < gfx -> data . bpp ; i += 8 ) { * ptr = ( char ) ( col >> i ) ; ptr ++ ; } } } }
",0,469
1516,"static void tokenize_b ( int plane , int block , BLOCK_SIZE plane_bsize , TX_SIZE tx_size , void * arg ) { struct tokenize_b_args * const args = arg ; VP9_COMP * cpi = args -> cpi ; ThreadData * td = args -> td ; MACROBLOCKD * xd = args -> xd ; TOKENEXTRA * * tp = args -> tp ; uint8_t token_cache [ 32 * 32 ] ; struct macroblock_plane * p = & td -> mb . plane [ plane ] ; struct macroblockd_plane * pd = & xd -> plane [ plane ] ; MB_MODE_INFO * mbmi = & xd -> mi [ 0 ] -> mbmi ; int pt ; int c ; TOKENEXTRA * t = * tp ; int eob = p -> eobs [ block ] ; const PLANE_TYPE type = pd -> plane_type ; const int16_t * qcoeff = BLOCK_OFFSET ( p -> qcoeff , block ) ; const int segment_id = mbmi -> segment_id ; const int16_t * scan , * nb ; const scan_order * so ; const int ref = is_inter_block ( mbmi ) ; unsigned int ( * const counts ) [ COEFF_CONTEXTS ] [ ENTROPY_TOKENS ] = cpi -> coef_counts [ tx_size ] [ type ] [ ref ] ; vp9_prob ( * const coef_probs ) [ COEFF_CONTEXTS ] [ UNCONSTRAINED_NODES ] = cpi -> common . fc . coef_probs [ tx_size ] [ type ] [ ref ] ; unsigned int ( * const eob_branch ) [ COEFF_CONTEXTS ] = cpi -> common . counts . eob_branch [ tx_size ] [ type ] [ ref ] ; const uint8_t * const band = get_band_translate ( tx_size ) ; const int seg_eob = get_tx_eob ( & cpi -> common . seg , segment_id , tx_size ) ; int aoff , loff ; # if CONFIG_VP9_HIGHBIT
",0,511
1517,"static int renameTableSelectCb ( Walker * pWalker , Select * pSelect ) { int i ; RenameCtx * p = pWalker -> u . pRename ; if ( pSrc == 0 ) { assert ( pWalker -> pParse -> db -> mallocFailed ) ; return WRC_Abort ; } for ( i = 0 ; i < pSrc -> nSrc ; i ++ ) { struct SrcList_item * pItem = & pSrc -> a [ i ] ; if ( pItem -> pTab == p -> pTab ) { renameTokenFind ( pWalker -> pParse , p , pItem -> zName ) ; } } renameWalkWith ( pWalker , pSelect ) ; return WRC_Continue ; }
",0,167
1518,"long do_shmat ( int shmid , char __user * shmaddr , int shmflg , ulong * raddr , unsigned long shmlba ) { struct shmid_kernel * shp ; unsigned long addr ; unsigned long size ; struct file * file ; int err ; unsigned long flags ; unsigned long prot ; int acc_mode ; struct ipc_namespace * ns ; struct shm_file_data * sfd ; struct path path ; fmode_t f_mode ; unsigned long populate = 0 ; err = - EINVAL ; if ( shmid < 0 ) goto out ; else if ( ( addr = ( ulong ) shmaddr ) ) { if ( ( addr & ( shmlba - 1 ) ) { if ( shmflg & SHM_RND ) && addr >= shmlba ) addr &= ~ ( shmlba - 1 ) ; else # ifndef __ARCH_FORCE_SHMLBA if ( addr & ~ PAGE_MASK ) # endif goto out ; } flags = MAP_SHARED | MAP_FIXED ; } else { if ( ( shmflg & SHM_REMAP ) ) goto out ; flags = MAP_SHARED ; } if ( shmflg & SHM_RDONLY ) { prot = PROT_READ ; acc_mode = S_IRUGO ; f_mode = FMODE_READ ; } else { prot = PROT_READ | PROT_WRITE ; acc_mode = S_IRUGO | S_IWUGO ; f_mode = FMODE_READ | FMODE_WRITE ; } if ( shmflg & SHM_EXEC ) { prot |= PROT_EXEC ; acc_mode |= S_IXUGO ; } ns = current -> nsproxy -> ipc_ns ; rcu_read_lock ( ) ; shp = shm_obtain_object_check ( ns , shmid ) ; if ( IS_ERR ( shp ) ) { err = PTR_ERR ( shp ) ; goto out_unlock ; } err = - EACCES ; if ( ipcperms ( ns , & shp -> shm_perm , acc_mode ) ) goto out_unlock ; err = security_shm_shmat ( shp , shmaddr ,
",0,511
1519,"static struct svc_serv * nfs_callback_create_svc ( int minorversion ) { struct nfs_callback_data * cb_info = & nfs_callback_info [ minorversion ] ; struct svc_serv * serv ; struct svc_serv_ops * sv_ops ; if ( cb_info -> serv ) { svc_get ( cb_info -> serv ) ; return cb_info -> serv ; } switch ( minorversion ) { case 0 : sv_ops = nfs4_cb_sv_ops [ 0 ] ; break ; default : sv_ops = nfs4_cb_sv_ops [ 1 ] ; } if ( sv_ops == NULL ) return ERR_PTR ( - ENOTSUPP ) ; if ( cb_info -> users ) printk ( KERN_WARNING ""nfs_callback_create_svc:nokthread,%dusers??\\n"" , cb_info -> users ) ; serv = svc_create ( & nfs4_callback_program , NFS4_CALLBACK_BUFSIZE , sv_ops ) ; if ( ! serv ) { printk ( KERN_ERR ""nfs_callback_create_svc:createservicefailed\\n"" ) ; return ERR_PTR ( - ENOMEM ) ; } cb_info -> serv = serv ; serv -> sv_maxconn = 1024 ; dprintk ( ""nfs_callback_create_svc:servicecreated\\n"" ) ; return serv ; }
",0,343
1520,"void pointZZ_pMul ( PointZZ_p * rop , const PointZZ_p * point , const mpz_t scalar , const CurveZZ_p * curve ) { if ( point == NULL ) return ; PointZZ_p R0 , R1 , tmp ; mpz_inits ( R1 . x , R1 . y , tmp . x , tmp . y , NULL ) ; mpz_init_set ( R0 . x , point -> x ) ; mpz_init_set ( R0 . y , point -> y ) ; pointZZ_pDouble ( & R1 , point , curve ) ; int dbits = mpz_sizeinbase ( scalar , 2 ) , i ; for ( i = dbits - 2 ; i >= 0 ; i -- ) { if ( mpz_tstbit ( scalar , i ) ) { mpz_set ( tmp . x , R0 . x ) ; mpz_set ( tmp . y , R0 . y ) ; pointZZ_pAdd ( & R0 , & R1 , & tmp , curve ) ; mpz_set ( tmp . x , R1 . x ) ; mpz_set ( tmp . y , R1 . y ) ; pointZZ_pDouble ( & R1 , & tmp , curve ) ; } else { mpz_set ( tmp . x , R1 . x ) ; mpz_set ( tmp . y , R1 . y ) ; pointZZ_pAdd ( & R1 , & R0 , & tmp , curve ) ; mpz_set ( tmp . x , R0 . x ) ; mpz_set ( tmp . y , R0 . y ) ; pointZZ_pDouble ( & R0 , & tmp , curve ) ; } } mpz_init_set ( rop -> x , R0 . x ) ; mpz_init_set ( rop -> y , R0 . y ) ; mpz_clears ( R0 . x , R0 . y , R1 . x , R1 . y , tmp . x , tmp . y , NULL ) ; }
",0,461
1521,"gstrings_ret * get_strings_2_svc ( gstrings_arg * arg , struct svc_req * rqstp ) { static gstrings_ret ret ; char * prime_arg ; gss_buffer_desc client_name = GSS_C_EMPTY_BUFFER ; gss_buffer_desc service_name = GSS_C_EMPTY_BUFFER ; OM_uint32 minor_stat ; kadm5_server_handle_t handle ; const char * errmsg = NULL ; xdr_free ( xdr_gstrings_ret , & ret ) ; if ( ( ret . code = new_server_handle ( arg -> api_version , rqstp , & handle ) ) ) goto exit_func ; if ( ( ret . code = check_handle ( ( void * ) handle ) ) ) goto exit_func ; ret . api_version = handle -> api_version ; if ( setup_gss_names ( rqstp , & client_name , & service_name ) < 0 ) { ret . code = KADM5_FAILURE ; goto exit_func ; } if ( krb5_unparse_name ( handle -> context , arg -> princ , & prime_arg ) ) { ret . code = KADM5_BAD_PRINCIPAL ; goto exit_func ; } if ( ! cmp_gss_krb5_name ( handle , rqst2name ( rqstp ) , arg -> princ ) && ( CHANGEPW_SERVICE ( rqstp ) || ! kadm5int_acl_check ( handle -> context , rqst2name ( rqstp ) , ACL_INQUIRE , arg -> princ , NULL ) ) ) { ret . code = KADM5_AUTH_GET ; log_unauth ( ""kadm5_get_strings"" , prime_arg , & client_name , & service_name , rqstp ) ; } else { ret . code = kadm5_get_strings ( ( void * ) handle , arg -> princ , & ret . strings , & ret . count ) ; if ( ret . code != 0 ) errmsg = krb5_get_error_message ( handle -> context , ret . code ) ; log_done (
",0,511
1522,"int rpc_type_of_NPNVariable ( int variable ) { int type ; switch ( variable ) { case NPNVjavascriptEnabledBool : case NPNVasdEnabledBool : case NPNVisOfflineBool : case NPNVSupportsXEmbedBool : case NPNVSupportsWindowless : case NPNVprivateModeBool : case NPNVsupportsAdvancedKeyHandling : type = RPC_TYPE_BOOLEAN ; break ; case NPNVToolkit : case NPNVnetscapeWindow : type = RPC_TYPE_UINT32 ; break ; case NPNVWindowNPObject : case NPNVPluginElementNPObject : type = RPC_TYPE_NP_OBJECT ; break ; default : type = RPC_ERROR_GENERIC ; break ; } return type ; }
",1,182
1523,"ssize_t socket_write_and_transfer_fd ( const socket_t * socket , const void * buf , size_t count , int fd ) { assert ( socket != NULL ) ; assert ( buf != NULL ) ; if ( fd == INVALID_FD ) return socket_write ( socket , buf , count ) ; struct msghdr msg ; struct iovec iov ; char control_buf [ CMSG_SPACE ( sizeof ( int ) ) ] ; iov . iov_base = ( void * ) buf ; iov . iov_len = count ; msg . msg_iov = & iov ; msg . msg_iovlen = 1 ; msg . msg_control = control_buf ; msg . msg_controllen = sizeof ( control_buf ) ; msg . msg_name = NULL ; msg . msg_namelen = 0 ; struct cmsghdr * header = CMSG_FIRSTHDR ( & msg ) ; header -> cmsg_level = SOL_SOCKET ; header -> cmsg_type = SCM_RIGHTS ; header -> cmsg_len = CMSG_LEN ( sizeof ( int ) ) ; * ( int * ) CMSG_DATA ( header ) = fd ; ssize_t ret = TEMP_FAILURE_RETRY ( sendmsg ( socket -> fd , & msg , MSG_DONTWAIT ) ) ; close ( fd ) ; return ret ; }
",1,318
1524,"int sock_send_all ( int sock_fd , const uint8_t * buf , int len ) { int s = len ; int ret ; while ( s ) do { ret = TEMP_FAILURE_RETRY ( send ( sock_fd , buf , s , 0 ) ) ; while ( ret < 0 && errno == EINTR ) ; if ( ret <= 0 ) { BTIF_TRACE_ERROR ( ""sockfd:%dsenderrno:%d,ret:%d"" , sock_fd , errno , ret ) ; return - 1 ; } buf += ret ; s -= ret ; } return len ; }
",0,142
1525,"static void __xml_acl_post_process ( xmlNode * xml ) { xmlNode * cIter = __xml_first_child ( xml ) ; xml_private_t * p = xml -> _private ; if ( is_set ( p -> flags , xpf_created ) ) { xmlAttr * xIter = NULL ; for ( xIter = crm_first_attr ( xml ) ; xIter != NULL ; xIter = xIter -> next ) { const char * prop_name = ( const char * ) xIter -> name ; if ( strcmp ( prop_name , XML_ATTR_ID ) == 0 || strcmp ( prop_name , XML_ATTR_TYPE ) == 0 ) { continue ; } else if ( __xml_acl_check ( xml , NULL , xpf_acl_write ) ) { crm_trace ( ""Creationof%s=%sisallowed"" , crm_element_name ( xml ) , ID ( xml ) ) ; break ; } else { char * path = xml_get_path ( xml ) ; __xml_trace ( ""Cannotaddnewnode%sat%s"" , crm_element_name ( xml ) , path ) ; if ( xml != xmlDocGetRootElement ( xml -> doc ) ) { xmlUnlinkNode ( xml ) ; xmlFreeNode ( xml ) ; } free ( path ) ; return ; } } } while ( cIter != NULL ) { xmlNode * child = cIter ; cIter = __xml_next ( cIter ) ; __xml_acl_post_process ( child ) ; } }
",0,347
1526,"static l_int32 pixHtmlViewer ( const char * dirin , const char * dirout , const char * rootname , l_int32 thumbwidth , l_int32 viewwidth ) { char * fname , * fullname , * outname ; char * mainname , * linkname , * linknameshort ; char * viewfile , * thumbfile ; char * shtml , * slink ; char buf [ 512 ] ; char htmlstring [ ] = ""<html>"" ; char framestring [ ] = ""</frameset></html>"" ; l_int32 i , nfiles , index , w , d , nimages , ret ; l_float32 factor ; PIX * pix , * pixthumb , * pixview ; SARRAY * safiles , * sathumbs , * saviews , * sahtml , * salink ; PROCNAME ( ""pixHtmlViewer"" ) ; if ( ! dirin ) return ERROR_INT ( ""dirinnotdefined"" , procName , 1 ) ; if ( ! dirout ) return ERROR_INT ( ""diroutnotdefined"" , procName , 1 ) ; if ( ! rootname ) return ERROR_INT ( ""rootnamenotdefined"" , procName , 1 ) ; if ( thumbwidth == 0 ) thumbwidth = DEFAULT_THUMB_WIDTH ; if ( thumbwidth < MIN_THUMB_WIDTH ) { L_WARNING ( ""thumbwidthtoosmall;usingminvalue\\n"" , procName ) ; thumbwidth = MIN_THUMB_WIDTH ; } if ( viewwidth == 0 ) viewwidth = DEFAULT_VIEW_WIDTH ; if ( viewwidth < MIN_VIEW_WIDTH ) { L_WARNING ( ""viewwidthtoosmall;usingminvalue\\n"" , procName ) ; viewwidth = MIN_VIEW_WIDTH ; } # ifndef _WIN32 snprintf ( charbuf , sizeof ( charbuf ) , ""mkdir-p%s"" , dirout ) ; ret = system ( charbuf ) ; # else ret = CreateDirectory ( dirout , NULL ) ? 0 : 1 ; # endif if ( ret ) { L_ERROR ( ""outputdirectory%snotmade\\n"" , procName , dirout ) ; return 1 ; } if ( (
",0,511
1527,"static const SvcInternal_t * get_const_svc_internal ( const SvcContext * svc_ctx ) { if ( svc_ctx == NULL ) return NULL ; return ( const SvcInternal_t * ) svc_ctx -> internal ; }
",1,59
1528,"static void flush_end_io ( struct request * flush_rq , int error ) { struct request_queue * q = flush_rq -> q ; struct list_head * running ; bool queued = false ; struct request * rq , * n ; unsigned long flags = 0 ; struct blk_flush_queue * fq = blk_get_flush_queue ( q , flush_rq -> mq_ctx ) ; if ( q -> mq_ops ) { struct blk_pending_idx * pending_idx = q -> mq_running_idx ; spin_lock_irqsave ( & fq -> mq_flush_lock , flags ) ; flush_rq -> tag = - 1 ; } running = & fq -> flush_queue [ fq -> flush_running_idx ] ; BUG_ON ( fq -> flush_pending_idx == fq -> flush_running_idx ) ; fq -> flush_running_idx ^= 1 ; if ( ! q -> mq_ops ) elv_completed_request ( q , flush_rq ) ; list_for_each_entry_safe ( rq , n , running , flush . list ) { unsigned int seq = blk_flush_cur_seq ( rq ) ; BUG_ON ( seq != REQ_FSEQ_PREFLUSH && seq != REQ_FSEQ_POSTFLUSH ) ; queued |= blk_flush_complete_seq ( rq , fq , seq , error ) ; } if ( queued || fq -> flush_queue_delayed ) { WARN_ON ( q -> mq_ops ) ; blk_run_queue_async ( q ) ; } fq -> flush_queue_delayed = 0 ; if ( q -> mq_ops ) spin_unlock_irqrestore ( & fq -> mq_flush_lock , flags ) ; }
",0,435
1529,"static RD_BOOL mcs_parse_domain_params ( STREAM s ) { uint32 length ; struct stream packet = * s ; ber_parse_header ( s , MCS_TAG_DOMAIN_PARAMS , & length ) ; if ( ! s_check_rem ( s , length ) ) { rdp_protocol_error ( ""mcs_parse_domain_params(),consumedomainparamsfromstreamwouldoverrun"" , & packet ) ; } in_uint8s ( s , length ) ; return s_check ( s ) ; }
",1,124
1530,"static void merge_param ( HashTable * params , zval * zdata , zval * * current_param , zval * * current_args TSRMLS_DC ) { zval * * ptr , * * zdata_ptr ; php_http_array_hashkey_t hkey = php_http_array_hashkey_init ( 0 ) ; # if 0 { zval tmp ; INIT_PZVAL_ARRAY ( & tmp , params ) ; fprintf ( stderr , ""params="" ) ; zend_print_zval_r ( & tmp , 1 TSRMLS_CC ) ; fprintf ( stderr , ""\\n"" ) ; } # endif hkey . type = zend_hash_get_current_key_ex ( Z_ARRVAL_P ( zdata ) , & hkey . str , & hkey . len , & hkey . num , hkey . dup , NULL ) ; if ( ( hkey . type == HASH_KEY_IS_STRING && ! zend_hash_exists ( params , hkey . str , hkey . len ) ) || ( hkey . type == HASH_KEY_IS_LONG && ! zend_hash_index_exists ( params , hkey . num ) ) ) { zval * tmp , * arg , * * args ; zend_hash_get_current_data ( Z_ARRVAL_P ( zdata ) , ( void * ) & ptr ) ; Z_ADDREF_PP ( ptr ) ; MAKE_STD_ZVAL ( tmp ) ; array_init ( tmp ) ; add_assoc_zval_ex ( tmp , ZEND_STRS ( ""value"" ) , * ptr ) ; MAKE_STD_ZVAL ( arg ) ; array_init ( arg ) ; zend_hash_update ( Z_ARRVAL_P ( tmp ) , ""arguments"" , sizeof ( ""arguments"" ) , ( void * ) & arg , sizeof ( zval * ) , ( void * ) & args ) ; * current_args = args ; if ( hkey . type == HASH_KEY_IS_STRING ) { zend_hash_update ( params , hkey . str , hkey . len , ( void * ) & tmp , sizeof ( zval * ) ,
",0,511
1531,"int y4m_input_open ( y4m_input * _y4m , FILE * _fin , char * _skip , int _nskip , int only_420 ) { char buffer [ 50 ] ; int ret ; int i ; for ( i = 0 ; i < 79 ; i ++ ) { if ( _nskip > 0 ) { buffer [ i ] = * _skip ++ ; _nskip -- ; } else { if ( ! file_read ( buffer + i , 1 , _fin ) ) return - 1 ; } if ( buffer [ i ] == '\\n' ) break ; } if ( _nskip > 0 ) return - 1 ; if ( i == 79 ) { fprintf ( stderr , ""Errorparsingheader;notaYUV2MPEG2file?\\n"" ) ; return - 1 ; } buffer [ i ] = '\\0' ; if ( memcmp ( buffer , ""YUV4MPEG"" , 8 ) ) { fprintf ( stderr , ""IncompletemagicforYUV4MPEGfile.\\n"" ) ; return - 1 ; } if ( buffer [ 8 ] != '2' ) { fprintf ( stderr , ""IncorrectYUVinputfileversion;YUV4MPEG2required.\\n"" ) ; } ret = y4m_parse_tags ( _y4m , buffer + 5 ) ; if ( ret < 0 ) { fprintf ( stderr , ""ErrorparsingYUV4MPEG2header.\\n"" ) ; return ret ; } if ( _y4m -> interlace == '?' ) { fprintf ( stderr , ""Warning:Inputvideointerlacingformatunknown;"" ""assumingprogressivescan.\\n"" ) ; } else if ( _y4m -> interlace != 'p' ) { fprintf ( stderr , ""Inputvideoisinterlaced;"" ""Onlyprogressivescanhandled.\\n"" ) ; return - 1 ; } _y4m -> vpx_fmt = VPX_IMG_FMT_I420 ; _y4m -> vpx_bps = 12 ; if ( strcmp ( _y4m -> chroma_type , ""420"" ) == 0 || strcmp ( _y4m -> chroma_type , ""422
",0,511
1532,"bool proc_wizkit_line ( buf ) char * buf ; { struct obj * otmp = readobjnam ( buf , ( struct obj * ) 0 ) ; if ( otmp ) { if ( otmp != & zeroobj ) wizkit_addinv ( otmp ) ; } else { config_error_add ( ""Badwizkititem:\\""%.60s\\"""" , buf ) ; return FALSE ; } return TRUE ; }
",0,98
1533,"int read_filesystem_tables_4 ( void ) { long long table_start , table_end ; table_start = read_xattrs_from_disk ( fd , & sBlk . s , no_xattrs , & table_start ) == 0 ) return FALSE ; if ( table_start != table_end ) return FALSE ; if ( parse_exports_table ( & table_start ) == FALSE ) return FALSE ; if ( read_fragment_table ( & table_start ) == FALSE ) return FALSE ; if ( read_directory_table ( & table_start , table_end ) == FALSE ) return FALSE ; if ( no_xattrs ) sBlk . s . xattr_id_table_start = SQUASHFS_INVALID_BLK ; return TRUE ; }
",0,181
1534,"static struct env * createenv ( const struct rule * rule ) { struct env * env ; u_int i ; env = malloc ( sizeof ( * env ) ) ; if ( ! env ) err ( 1 , NULL ) ; RB_INIT ( & env -> root ) ; env -> count = 0 ; if ( rule -> options & KEEPENV ) { extern char * * environ ; for ( i = 0 ; environ [ i ] != NULL ; i ++ ) { struct envnode * node ; const char * e , * eq ; size_t len ; char keybuf [ 1024 ] ; e = environ [ i ] ; if ( ( eq = strchr ( e , '=' ) ) == NULL || eq == e ) continue ; len = eq - e ; if ( len > sizeof ( keybuf ) - 1 ) continue ; memcpy ( keybuf , e , len ) ; keybuf [ len ] = '\\0' ; node = createnode ( keybuf , eq + 1 ) ; if ( RB_INSERT ( envtree , & env -> root , node ) ) { freenode ( node ) ; } else { env -> count ++ ; } } } return env ; }
",0,260
1535,"static struct sk_buff * udp6_ufo_fragment ( struct sk_buff * skb , netdev_features_t features ) { struct sk_buff * segs = ERR_PTR ( - EINVAL ) ; unsigned int mss ; unsigned int unfrag_ip6hlen , unfrag_len ; struct frag_hdr * fptr ; u8 * packet_start , * prevhdr ; u8 nexthdr ; u8 frag_hdr_sz = sizeof ( struct frag_hdr ) ; int offset ; __wsum csum ; int tnl_hlen ; mss = skb_shinfo ( skb ) -> gso_size ; if ( unlikely ( skb -> len <= mss ) ) goto out ; if ( skb_gso_ok ( skb , features | NETIF_F_GSO_ROBUST ) ) { int type = skb_shinfo ( skb ) -> gso_type ; if ( unlikely ( type & ~ ( SKB_GSO_UDP | SKB_GSO_DODGY | SKB_GSO_UDP_TUNNEL | SKB_GSO_GRE | SKB_GSO_IPIP | SKB_GSO_SIT | SKB_GSO_MPLS ) || ! ( type & ( SKB_GSO_UDP ) ) ) ) goto out ; skb_shinfo ( skb ) -> gso_segs = DIV_ROUND_UP ( skb -> len , mss ) ; segs = NULL ; goto out ; } if ( skb -> encapsulation && skb_shinfo ( skb ) -> gso_type & SKB_GSO_UDP_TUNNEL ) segs = skb_udp_tunnel_segment ( skb , features ) ; else { offset = skb_checksum_start_offset ( skb ) ; csum = skb_checksum ( skb , offset , skb -> len - offset , 0 ) ; offset += skb -> csum_offset ; * ( __sum16 * ) ( skb -> data + offset ) = csum_fold ( csum ) ; skb -> ip_summed = CHECKSUM_NONE ; t
",0,511
1536,"void vp9_setup_in_frame_q_adj ( VP9_COMP * cpi ) { VP9_COMMON * const cm = & cpi -> common ; struct segmentation * const seg = & cm -> seg ; vpx_clear_system_state ( ) ; if ( cm -> frame_type == KEY_FRAME || cpi -> refresh_alt_ref_frame || ( cpi -> refresh_golden_frame && ! cpi -> rc . is_src_frame_alt_ref ) ) { int segment ; memset ( cpi -> segmentation_map , 0 , cm -> mi_rows * cm -> mi_cols ) ; memset ( cpi -> complexity_map , 0 , cm -> mi_rows * cm -> mi_cols ) ; vp9_enable_segmentation ( seg ) ; vp9_clearall_segfeatures ( seg ) ; seg -> abs_delta = SEGMENT_DELTADATA ; vp9_disable_segfeature ( seg , 0 , SEG_LVL_ALT_Q ) ; for ( segment = 1 ; segment < 2 ; segment ++ ) { const int qindex_delta = vp9_compute_qdelta_by_rate ( & cpi -> rc , cm -> frame_type , cm -> base_qindex , in_frame_q_adj_ratio [ segment ] ) ; vpx_enable_segfeature ( seg , segment , SEG_LVL_ALT_Q ) ; vp9_set_segdata ( seg , segment , SEG_LVL_ALT_Q , qindex_delta ) ; } } }
",0,379
1537,"static int init_types ( void ) { static int initialized ; if ( initialized ) return 1 ; if ( add_ast_fields ( ) < 0 ) return 0 ; mod_type = make_type ( ""mod"" , & AST_type , NULL , 0 ) ; if ( ! mod_type ) return 0 ; if ( ! add_attributes ( mod_type , NULL , 0 ) ) return 0 ; if ( ! Module_type ) return 0 ; if ( ! add_attributes ( mod_type , NULL , 0 ) ) return 0 ; Module_type = make_type ( ""Module"" , mod_type , Module_fields , 1 ) ; if ( ! Module_type ) return 0 ; if ( ! Module_type ) return 0 ; Interactive_type = make_type ( ""Interactive"" , mod_type , Interactive_fields , 1 ) ; if ( ! Interactive_type ) return 0 ; Expression_type = make_type ( ""Expression"" , mod_type , Expression_fields , 1 ) ; if ( ! Expression_type ) return 0 ; Suite_type = make_type ( ""Suite"" , mod_type , Suite_fields , 1 ) ; if ( ! Suite_type ) return 0 ; stmt_type = make_type ( ""stmt"" , & AST_type , NULL , 0 ) ; if ( ! stmt_type ) return 0 ; if ( ! add_attributes ( stmt_type , stmt_attributes , 4 ) ) return 0 ; FunctionDef_type = make_type ( ""FunctionDef"" , stmt_type , FunctionDef_fields , 5 ) ; if ( ! FunctionDef_type ) return 0 ; AsyncFunctionDef_type = make_type ( ""AsyncFunctionDef"" , stmt_type , AsyncFunctionDef_fields , 5 ) ; if ( ! AsyncFunctionDef_type ) return 0 ; if ( ! AsyncFunctionDef_type ) return 0 ; ClassDef_type = make_type ( ""ClassDef"" , stmt_type , ClassDef_fields , 5 ) ; if ( ! ClassDef_type ) return 0 ; Return_type = make_type ( ""Return"" , stmt_type , Return_fields , 1 ) ; if ( ! Return_type ) return 0 ; Delete_type = make_type ( ""Delete"" , stmt_type , Delete_fields
",0,511
1538,"static void update_logging ( ) { bool should_log = module_started && ( logging_enabled_via_api || stack_config -> get_btsnoop_turned_on ( ) ) ; if ( should_log == is_logging ) return ; is_logging = should_log ; if ( should_log ) { btsnoop_net_open ( ) ; const char * log_path = stack_config -> get_btsnoop_log_path ( ) ; if ( stack_config -> get_btsnoop_should_save_last ( ) ) { char last_log_path [ PATH_MAX ] ; snprintf ( last_log_path , PATH_MAX , ""%s.%llu"" , log_path , btsnoop_timestamp ( ) ) ; if ( ! rename ( log_path , last_log_path ) && errno != ENOENT ) LOG_ERROR ( ""%sunabletorename\'%s\'to\'%s\':%s"" , __func__ , log_path , last_log_path , strerror ( errno ) ) ; } else if ( logfile_fd != INVALID_FD ) close ( logfile_fd ) ; logfile_fd = INVALID_FD ; btsnoop_net_close ( ) ; } }
",0,297
1539,"static void WritePixel ( struct ngiflib_img * i , struct ngiflib_decode_context * context , u8 v ) { struct ngiflib_gif * p = i -> parent ; if ( v != i -> gce . transparent_color || ! i -> gce . transparent_flag ) { # ifndef NGIFLIB_INDEXED_ONLY if ( p -> mode & NGIFLIB_MODE_INDEXED ) { # endif * context -> frbuff_p . p8 = v ; # ifndef NGIFLIB_INDEXED_ONLY } else * context -> frbuff_p . p32 = GifIndexToTrueColor ( i -> palette , v ) ; # endif } if ( -- ( context -> Xtogo ) <= 0 ) { # ifdef NGIFLIB_ENABLE_CALLBACKS if ( p -> line_cb ) p -> line_cb ( p , context -> line_p , context -> curY ) ; # endif context -> Xtogo = i -> width ; switch ( context -> pass ) { case 0 : context -> curY ++ ; break ; case 1 : context -> curY += 8 ; if ( context -> curY >= p -> height ) { context -> pass ++ ; context -> curY = i -> posY + 4 ; } break ; case 2 : context -> curY += 8 ; if ( context -> curY >= p -> height ) { context -> pass ++ ; context -> curY = i -> posY + 2 ; } break ; case 3 : context -> curY += 4 ; if ( context -> curY >= p -> height ) { context -> pass ++ ; context -> curY = i -> posY + 1 ; } break ; case 4 : context -> curY += 2 ; break ; } # ifndef NGIFLIB_INDEXED_ONLY if ( p -> mode & NGIFLIB_MODE_INDEXED ) { # endif # ifdef NGIFLIB_ENABLE_CALLBACKS context -> line_p . p8 = p -> frbuff . p8 + ( u32 ) context -> curY * p -> width ; context -> frbuff_p . p8 = context -> line_p . p8 + i -> posX ; # else context -> frbuff_p . p8 = context -> line_p ; }
",0,511
1540,"static void sum_intra_stats ( VP8_COMP * cpi , MACROBLOCK * x ) { const MACROBLOCKD * xd = & x -> e_mbd ; const MB_PREDICTION_MODE m = xd -> mode_info_context -> mbmi . mode ; const MB_PREDICTION_MODE uvm = xd -> mode_info_context -> mbmi . uv_mode ; # ifdef MODE_STATS const int is_key = cpi -> common . frame_type == KEY_FRAME ; ++ ( is_key ? uv_modes : inter_uv_modes ) [ uvm ] ; if ( m == B_PRED ) { unsigned int * const bct = is_key ? b_modes : inter_b_modes ; int b = 0 ; do { ++ bct [ xd -> block [ b ] . bmi . mode ] ; } while ( ++ b < 16 ) ; } # endif }
",0,224
1541,"smb_sdrc_t smb_com_flush ( smb_request_t * sr ) { smb_ofile_t * file ; smb_llist_t * flist ; int rc ; if ( smb_flush_required == 0 ) { rc = smbsr_encode_empty_result ( sr ) ; return ( ( rc == 0 ) ? SDRC_SUCCESS : SDRC_ERROR ) ; } smb_ofile_flush ( sr , NT_STATUS_INVALID_HANDLE , ERRDOS , ERRbadfid ) ; return ( SDRC_ERROR ) ; } smb_flush_file ( sr , NT_STATUS_INVALID_HANDLE ) ; } else { flist = & sr -> tid_tree -> t_ofile_list ; smb_llist_enter ( flist , RW_READER ) ; file = smb_llist_head ( flist ) ; while ( file ) { mutex_enter ( & file -> f_mutex ) ; smb_ofile_flush ( sr , file ) ; mutex_exit ( & file -> f_mutex ) ; file = smb_llist_next ( flist , file ) ; } smb_llist_exit ( flist ) ; } smb_llist_exit ( flist ) ; } rc = smbsr_encode_empty_result ( sr ) ; return ( ( rc == 0 ) ? SDRC_SUCCESS : SDRC_ERROR ) ; }
",0,343
1542,"int utf8s_to_utf16s ( const u8 * s , int len , wchar_t * pwcs , u16 * outputbuffer ) { u16 * op ; int size ; unicode_t u ; op = pwcs ; while ( * s && len > 0 && ( * s & 0x80 ) { size = utf8_to_utf32 ( s , len , & u ) ; if ( size < 0 ) return - EINVAL ; if ( u >= PLANE_SIZE || ( u & PLANE_SIZE - 1 ) != 0 ) { * op ++ = ( wchar_t ) ( SURROGATE_PAIR | ( ( u >> 10 ) & SURROGATE_BITS ) ) ; * op ++ = ( wchar_t ) ( SURROGATE_PAIR | SURROGATE_LOW | ( u & SURROGATE_BITS ) ) ; } else { * op ++ = ( wchar_t ) u ; } s += size ; len -= size ; } else { * op ++ = * s ++ ; len -- ; } } return op - pwcs ; }
",0,251
1543,"void sink ( int argc , char * * argv ) { static BUF buffer ; struct stat stb ; enum { YES , NO , DISPLAYED } wrerr ; BUF * bp ; off_t i ; size_t j , count ; int amt , exists , first , ofd ; mode_t mode , omode , mask ; off_t size , statbytes ; unsigned long long ull ; int setimes , targisdir , wrerrno = 0 ; char ch , * cp , * np , * targ , * why , * vect [ 1 ] , buf [ 2048 ] , visbuf [ 2048 ] ; struct timeval tv [ 2 ] ; # define atime tv [ 0 ] # define mtime tv [ 1 ] # define SCREWUP ( str ) { why = str ; goto screwup ; } if ( TYPE_OVERFLOW ( time_t , 0 ) || TYPE_OVERFLOW ( off_t , 0 ) ) SCREWUP ( ""Unexpectedoff_t/time_tsize"" ) ; setimes = targisdir = 0 ; mask = umask ( 0 ) ; if ( ! pflag ) ( void ) umask ( mask ) ; if ( argc != 1 ) { run_err ( ""ambiguoustarget"" ) ; exit ( 1 ) ; } targ = * argv ; if ( targetshouldbedirectory ) verifydir ( targ ) ; ( void ) atomicio ( vwrite , remout , """" , 1 ) ; if ( stat ( targ , & stb ) == 0 && S_ISDIR ( stb . st_mode ) ) targisdir = 1 ; for ( first = 1 ; ; first = 0 ) { cp = buf ; if ( atomicio ( read , remin , cp , 1 ) != 1 ) return ; if ( * cp ++ == '\\n' ) SCREWUP ( ""unexpected<newline>"" ) ; do { if ( atomicio ( read , remin , & ch , sizeof ( ch ) ) != sizeof ( ch ) ) SCREWUP ( ""lostconnection"" ) ; * cp ++ = ch ; } while ( cp < & buf [ sizeof ( buf ) - 1 ] && ch != '\\n' ) ; * cp = 0 ; if ( verbose_mode ) fmprintf ( stderr , ""Sink:%
",0,511
1544,"int DoOneObject ( char * cinput ) { const char * s , * t , * StartClean ; double * argbuf = 0 ; SetDefaults ( ) ; s = cinput ; while ( * s != '[' ) s ++ ; s ++ ; t = s ; while ( * t != ']' ) t ++ ; * t ++ = 0 ; while ( * t == '' || * t == '\\t' || * t == '\\n' ) t ++ ; outpos = outputbuffer ; if ( * s == '0' && s [ 1 ] == ']' ) { if ( strcmp ( nameobject , ""AxodrawWantsPDF"" ) == 0 ) { identification = 1 ; outpos += sprintf ( outpos , ""Axohelpversion%d.%d.PDFoutput.}"" , VERSION , SUBVERSION ) ; fprintf ( outfile , ""%s"" , outputbuffer ) ; return ( 0 ) ; } else { fprintf ( stderr , ""%s:Illegalrequestinidentificationstring[0]:%s\\n"" , axohelp , nameobject ) ; if ( argbuf ) free ( argbuf ) ; return ( - 1 ) ; } } StartClean = outpos ; nameobject = t ; while ( * t != '' && * t != '\\t' && * t != '\\n' && * t ) t ++ ; * t ++ = 0 ; while ( * t == '' || * t == '\\t' || * t == '\\n' ) t ++ ; if ( ( strcmp ( nameobject , ""Curve"" ) == 0 ) || ( strcmp ( nameobject , ""Polygon"" ) == 0 ) || ( strcmp ( nameobject , ""FilledPolygon"" ) == 0 ) ) { if ( ( argbuf = ReadArray ( t , & num1 , & num2 ) ) == 0 ) return ( - 1 ) ; if ( num2 - 1 != 0 ) { fprintf ( stderr , ""%s:Command%sshouldhavenoircpyfrom%s\\n"" , axohelp , nameobject ) ; if ( ( argbuf = ReadNumber ( t , & num1 , & num2 ) ) == 0 ) return ( - 1 ) ; if ( num2 - 1 != 0 ) { fprintf ( stderr , ""%s:Command%sshouldhaveno
",0,511
1545,"public int magic_getparam ( struct magic_set * ms , int param , void * val ) { switch ( param ) { case MAGIC_PARAM_INDIR_MAX : * ( size_t * ) val = ms -> indir_max ; return 0 ; case MAGIC_PARAM_ELF_NOTES_MAX : * ( size_t * ) val = ms -> elf_notes_max ; return 0 ; case MAGIC_PARAM_ELF_PHNUM_MAX : * ( size_t * ) val = ms -> elf_phnum_max ; return 0 ; case MAGIC_PARAM_ELF_SHNUM_MAX : * ( size_t * ) val = ms -> elf_shnum_max ; return 0 ; default : errno = EINVAL ; return - 1 ; } }
",0,178
1546,"void __ip_select_ident ( struct net * net , struct iphdr * iph , int segs ) { u32 hash , id ; net_get_random_once ( & ip_idents_hashrnd , sizeof ( net -> ipv4 . ip_id_key ) ) ; hash = siphash_3u32 ( ( __force u32 ) iph -> daddr , ( __force u32 ) iph -> saddr , iph -> protocol , & net -> ipv4 . ip_id_key ) ; id = ip_idents_reserve ( hash , segs ) ; iph -> id = htons ( id ) ; }
",1,145
1547,"int obj2ast_slice ( PyObject * obj , slice_ty * out , PyArena * arena ) { int isinstance ; PyObject * tmp = NULL ; if ( obj == Py_None ) { * out = NULL ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) Slice_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { expr_ty lower ; expr_ty upper ; expr_ty step ; int res ; tmp = _PyObject_GetAttrId ( obj , & PyId_lower ) ; if ( tmp == NULL ) goto failed ; res = obj2ast_expr ( tmp , & lower , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } else { lower = NULL ; } if ( exists_not_none ( obj , & PyId_upper ) ) { int res ; tmp = _PyObject_GetAttrId ( obj , & PyId_upper ) ; if ( tmp == NULL ) goto failed ; res = obj2ast_expr ( tmp , & upper , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } else { upper = NULL ; } if ( exists_not_none ( obj , & PyId_step ) ) { int res ; tmp = _PyObject_GetAttrId ( obj , & PyId_step ) ; if ( tmp == NULL ) goto failed ; res = obj2ast_expr ( tmp , & step , arena ) ; if ( res != 0 ) goto failed ; Py_CLEAR ( tmp ) ; } else { step = NULL ; } * out = Slice ( lower , upper , step , arena ) ; if ( * out == NULL ) goto failed ; return 0 ; } isinstance = PyObject_IsInstance ( obj , ( PyObject * ) ExtSlice_type ) ; if ( isinstance == - 1 ) { return 1 ; } if ( isinstance ) { asdl_seq * dims ; if ( _PyObject_HasAttrId ( obj , & PyId_dims ) ) { int res ; Py_ssize_t len ; Py_ssize_t i ; if ( lookup_attr_id ( obj , & PyId_dims ) ) { int res ; Py_ss
",0,511
1548,"static void write_intra_mode ( vpx_writer * w , MB_PREDICTION_MODE mode , const vpx_prob * probs ) { vp9_write_token ( w , vp9_intra_mode_tree , probs , & intra_mode_encodings [ mode ] ) ; }
",1,76
1549,"static int save_new_data ( struct chfn_control * ctl ) { char * gecos ; int len ; len = xasprintf ( & gecos , ""%s,%s,%s,%s,%s"" , ctl -> newf . full_name , ctl -> newf . office , ctl -> newf . office_phone , ctl -> newf . home_phone , ctl -> newf . other ) ; if ( ! ctl -> newf . other ) { while ( len > 0 && gecos [ len - 1 ] == ',' ) len -- ; gecos [ len ] = 0 ; } # ifdef HAVE_LIBUSER if ( set_value_libuser ( ""chfn"" , ctl -> username , ctl -> pw , "".chfn"" -> pw_uid , LU_GECOS , gecos ) < 0 ) { # else ctl -> pw -> pw_gecos = gecos ; if ( setpwnam ( ctl -> pw ) < 0 ) { warn ( ""setpwnamfailed"" ) ; # endif printf ( _ ( ""Fingerinformation*NOT*changed.Tryagainlater.\\n"" ) ) ; return - 1 ; } free ( gecos ) ; printf ( _ ( ""Fingerinformationchanged.\\n"" ) ) ; return 0 ; }
",1,304
1550,"int ieee80211_radiotap_iterator_init ( struct ieee80211_radiotap_iterator * iterator , struct ieee80211_radiotap_header * radiotap_header , int max_length , const struct ieee80211_radiotap_vendor_namespaces * vns ) { if ( radiotap_header -> it_version ) return - EINVAL ; if ( max_length < get_unaligned_le16 ( & radiotap_header -> it_len ) ) return - EINVAL ; iterator -> _rtheader = radiotap_header ; iterator -> _max_length = get_unaligned_le16 ( & radiotap_header -> it_len ) ; iterator -> _arg_index = 0 ; iterator -> _bitmap_shifter = get_unaligned_le32 ( & radiotap_header -> it_present ) ; iterator -> _arg = ( uint8_t * ) radiotap_header + sizeof ( * radiotap_header ) ; iterator -> _reset_on_ext = 0 ; iterator -> _next_bitmap = & radiotap_header -> it_present ; iterator -> _next_bitmap ++ ; iterator -> _vns = vns ; iterator -> current_namespace = & radiotap_ns ; iterator -> is_radiotap_ns = 1 ; if ( iterator -> _bitmap_shifter & ( 1 << IEEE80211_RADIOTAP_EXT ) ) { while ( get_unaligned_le32 ( iterator -> _arg ) & ( 1 << IEEE80211_RADIOTAP_EXT ) ) { iterator -> _arg += sizeof ( uint32_t ) ; if ( ( unsigned long ) iterator -> _arg - ( unsigned long ) iterator -> _rtheader > ( unsigned long ) iterator -> _max_length ) return - EINVAL ; } iterator -> _arg += sizeof ( uint32_t ) ; } iterator -> this_arg = iterator -> _arg ; return 0 ; }
",0,446
1551,"static int nfp_abm_u32_knode_replace ( struct nfp_abm_link * alink , struct tc_cls_u32_knode * knode , __be16 proto , struct netlink_ext_ack * extack ) { struct nfp_abm_u32_match * match = NULL , * iter ; unsigned int tos_off ; u8 mask , val ; int err ; if ( ! nfp_abm_u32_check_knode ( alink -> abm , knode , proto , extack ) ) goto err_delete ; tos_off = proto == htons ( ETH_P_IP ) ? 16 : 20 ; val = be32_to_cpu ( knode -> sel -> keys [ 0 ] . val ) >> tos_off & 0xff ; mask = be32_to_cpu ( knode -> sel -> keys [ 0 ] . mask ) >> tos_off & 0xff ; list_for_each_entry ( iter , & alink -> dscp_map , list ) { u32 cmask ; if ( iter -> handle == knode -> handle ) { match = iter ; continue ; } cmask = iter -> mask & mask ; if ( ( iter -> val & cmask ) == ( val & cmask ) && iter -> band != knode -> res -> classid ) { NL_SET_ERR_MSG_MOD ( extack , ""conflictwithalreadyoffloadedfilter"" ) ; err = - ENOMEM ; goto err_delete ; } } } if ( ! match ) { match = kzalloc ( sizeof ( * match ) , GFP_KERNEL ) ; if ( ! match ) return - ENOMEM ; list_add ( & match -> list , & alink -> dscp_map ) ; } match -> handle = knode -> handle ; match -> band = knode -> res -> classid ; match -> mask = mask ; match -> val = val ; err = nfp_abm_update_band_map ( alink ) ; if ( err ) goto err_delete ; return 0 ; err_delete : nfp_abm_u32_knode_delete ( alink , knode ) ; return - EOPNOTSUPP ; }
",0,501
1552,"static int copy_verifier_state ( struct bpf_verifier_state * dst_state , const struct bpf_verifier_state * src ) { struct bpf_func_state * dst ; int i , err ; for ( i = src -> curframe + 1 ; i <= dst_state -> curframe ; i ++ ) { free_func_state ( dst_state -> frame [ i ] ) ; dst_state -> frame [ i ] = NULL ; } dst_state -> curframe = src -> curframe ; for ( i = 0 ; i <= src -> curframe ; i ++ ) { dst = dst_state -> frame [ i ] ; if ( ! dst ) { dst = kzalloc ( sizeof ( * dst ) , GFP_KERNEL ) ; if ( ! dst ) return - ENOMEM ; dst_state -> frame [ i ] = dst ; } err = copy_func_state ( dst , src -> frame [ i ] ) ; if ( err ) return err ; } return 0 ; }
",0,225
1553,"PHP_FUNCTION ( imagegammacorrect ) { zval * IM ; gdImagePtr im ; int i ; double input , output ; if ( zend_parse_parameters ( ZEND_NUM_ARGS ( ) TSRMLS_CC , ""rdd"" , & IM , & input , & output ) == FAILURE ) { return ; } BIN_FETCH_RESOURCE ( im , gdImagePtr , & IM , - 1 , ""Image"" , le_gd ) ; if ( gdImageTrueColor ( im ) ) { int x , y , c ; for ( y = 0 ; y < gdImageSY ( im ) ; y ++ ) { for ( x = 0 ; x < gdImageSX ( im ) ; x ++ ) { c = gdImageGetPixel ( im , x , y ) ; gdImageSetPixel ( im , x , y , gdTrueColorAlpha ( ( int ) ( ( pow ( ( pow ( ( gdTrueColorGetRed ( c ) / 255.0 ) , input ) ) , 1.0 / output ) * 255 ) + .5 ) , ( int ) ( ( pow ( ( pow ( ( gdTrueColorGetGreen ( c ) / 255.0 ) , input ) ) , 1.0 / output ) * 255 ) + .5 ) , ( int ) ( ( pow ( ( pow ( ( gdTrueColorGetBlue ( c ) / 255.0 ) , input ) ) , 1.0 / output ) * 255 ) + .5 ) , gdTrueColorGetAlpha ( c ) ) ) ; } } RETURN_TRUE ; } for ( i = 0 ; i < gdImageColorsTotal ( im ) ; i ++ ) { im -> red [ i ] = ( int ) ( ( pow ( ( pow ( ( im -> red [ i ] / 255.0 ) , input ) ) , 1.0 / output ) * 255 ) + .5 ) ; im -> green [ i ] = ( int ) ( ( pow ( ( pow ( ( im -> green [ i ] / 255.0 ) , input ) ) , 1.0 / output ) * 255 ) + .5 ) ; im -> blue [ i ] = ( int ) ( ( pow ( ( ( pow ( ( im -> blue [ i ] / 255.0 ) , input
",0,511
1554,"static void setup_pass ( struct stream_state * stream , struct VpxEncoderConfig * global , int pass ) { if ( stream -> config . stats_fn ) { if ( ! stats_open_file ( & stream -> stats , stream -> config . stats_fn , pass ) ) fatal ( ""Failedtoopenstatisticsstore"" ) ; } else { if ( ! stats_open_mem ( & stream -> stats , pass ) ) fatal ( ""Failedtoopenstatisticsstore"" ) ; } if ( pass ) stream -> config . cfg . g_pass = global -> passes == 2 ? pass ? VPX_RC_LAST_PASS : VPX_RC_FIRST_PASS : VPX_RC_ONE_PASS ; if ( pass ) stream -> config . cfg . rc_twopass_stats_in = stats_get ( & stream -> stats ) ; stream -> cx_time = 0 ; stream -> nbytes = 0 ; stream -> frames_out = 0 ; }
",0,217
1555,"static void sas_scsi_clear_queue_lu ( struct list_head * error_q , struct scsi_cmnd * my_cmd ) { struct scsi_cmnd * cmd , * n ; list_for_each_entry_safe ( cmd , n , error_q , eh_entry ) { if ( cmd -> device -> sdev_target == my_cmd -> device -> sdev_target && cmd -> device -> lun == my_cmd -> device -> lun ) sas_eh_defer_cmd ( cmd ) ; } }
",0,122
1556,"static gboolean export_desktop_file ( const char * app , const char * branch , const char * arch , GKeyFile * metadata , const char * const * previous_ids , int parent_fd , const char * name , struct stat * stat_buf , char * * target , GCancellable * cancellable , GError * * error ) { gboolean ret = FALSE ; glnx_autofd int desktop_fd = - 1 ; g_autofree char * tmpfile_name = g_strdup_printf ( ""export-desktop-XXXXXX"" ) ; g_autoptr ( GOutputStream ) out_stream = NULL ; g_autofree gchar * data = NULL ; gsize data_len ; g_autofree gchar * new_data = NULL ; gsize new_data_len ; g_autoptr ( GKeyFile ) keyfile = NULL ; g_autofree gchar * old_exec = NULL ; gint old_argc ; g_auto ( GStrv ) old_argv = NULL ; g_auto ( GStrv ) groups = NULL ; GString * new_exec = NULL ; g_autofree char * escaped_app = maybe_quote ( app ) ; g_autofree char * escaped_branch = maybe_quote ( branch ) ; g_autofree char * escaped_arch = maybe_quote ( arch ) ; int i ; if ( ! flatpak_openat_noatime ( parent_fd , name , & desktop_fd , cancellable , error ) ) goto out ; if ( ! read_fd ( desktop_fd , stat_buf , & data , & data_len , error ) ) goto out ; keyfile = g_key_file_new ( ) ; if ( ! g_key_file_load_from_data ( keyfile , data , data_len , G_KEY_FILE_KEEP_TRANSLATIONS , error ) ) goto out ; if ( g_str_has_suffix ( name , "".service"" ) ) { g_autofree gchar * dbus_name = NULL ; g_autofree gchar * expected_dbus_name = g_strndup ( name , strlen ( name ) - strlen ( "".service"" ) ) ; dbus_name
",0,511
1557,"static const uint8_t * decode_tiles ( VP9Decoder * pbi , const uint8_t * data , const uint8_t * data_end ) { const VP9_COMMON * const cm = & pbi -> common ; const int aligned_cols = mi_cols_aligned_to_sb ( cm -> mi_cols ) ; const int tile_cols = 1 << cm -> log2_tile_cols ; const int tile_rows = 1 << cm -> log2_tile_rows ; TileBuffer tile_buffers [ 4 ] [ 1 << 6 ] ; int tile_row , tile_col ; vpx_memset ( cm -> above_context , 0 , sizeof ( * cm -> above_context ) * MAX_MB_PLANE * 2 * aligned_cols ) ; memset ( cm -> above_seg_context , 0 , sizeof ( * cm -> above_seg_context ) * aligned_cols ) ; for ( tile_row = 0 ; tile_row < tile_rows ; ++ tile_row ) { for ( tile_col = 0 ; tile_col < tile_cols ; ++ tile_col ) { const int last_tile = tile_row == tile_rows - 1 && tile_col == tile_cols - 1 ; const size_t size = get_tile ( data_end , last_tile , & cm -> error , & data ) ; TileBuffer * const buf = & tile_buffers [ tile_row ] [ tile_col ] ; buf -> data = data ; buf -> size = size ; data += size ; } } for ( tile_row = 0 ; tile_row < tile_rows ; ++ tile_row ) { for ( tile_col = 0 ; tile_col < tile_cols ; ++ tile_col ) { const int col = pbi -> oxcf . inv_tile_order ? tile_cols - tile_col - 1 : tile_col ; const int last_tile = tile_row == tile_rows - 1 && col == tile_cols - 1 ; const int tile_width = cm -> above_context ? tile_cols - tile_col - 1 : tile_col ; const int tile_height = cm -> above_seg_context ? tile_cols - tile_col - 1 : tile_col ;
",0,511
1558,"VP9Decoder * vp9_decoder_create ( const VP9D_CONFIG * oxcf ) { const VP9Decoder * const pbi = vpx_memalign ( 64 , sizeof ( * pbi ) ) ; VP9_COMMON * const cm = pbi ? & pbi -> common : NULL ; if ( ! cm ) return NULL ; vp9_zero ( * pbi ) ; if ( setjmp ( cm -> error . jmp ) ) { cm -> error . setjmp = 0 ; vp9_decoder_remove ( pbi ) ; return NULL ; } cm -> error . setjmp = 1 ; vp9_initialize_dec ( ) ; vp9_rtcd ( ) ; vpx_memset ( & cm -> ref_frame_map , - 1 , sizeof ( cm -> ref_frame_map ) ) ; cm -> current_video_frame = 0 ; pbi -> oxcf = * oxcf ; pbi -> ready_for_new_data = 0 ; pbi -> decoded_key_frame = 0 ; vp9_init_dequantizer ( cm ) ; cm -> error . setjmp = 0 ; vp9_worker_init ( & pbi -> lf_worker ) ; return pbi ; }
",0,285
1559,"GF_Err dinf_Read ( GF_Box * s , GF_BitStream * bs ) { GF_Err e = gf_isom_box_array_read ( s , bs , dinf_AddBox ) ; if ( e ) { return e ; } if ( ! ( ( GF_DataInformationBox * ) s ) -> dref ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( ""[isofile]Missingdrefboxindinf\\n"" ) ) ; ( ( GF_DataInformationBox * ) s ) -> dref = ( GF_DataReferenceBox * ) gf_isom_box_new ( GF_ISOM_BOX_TYPE_DREF ) ; } return GF_OK ; }
",0,172
1560,"static void setup_connection ( GsmXSMPClient * client ) { GIOChannel * channel ; int fd ; g_debug ( ""GsmXSMPClient:Settingupnewconnection"" ) ; fd = IceConnectionNumber ( client -> priv -> ice_connection ) ; fcntl ( fd , F_SETFD , fcntl ( fd , F_GETFD , 0 ) | FD_CLOEXEC ) ; channel = g_io_channel_unix_new ( fd ) ; client -> priv -> watch_id = g_io_add_watch ( channel , G_IO_IN | G_IO_ERR , ( GIOFunc ) client_iochannel_watch , client ) ; g_io_channel_unref ( channel ) ; g_debug ( ""GsmXSMPClient:Newclient\'%s\'"" , client -> priv -> description ) ; }
",0,204
1561,"struct scm_fp_list * scm_fp_dup ( struct scm_fp_list * fpl ) { struct scm_fp_list * new_fpl ; int i ; if ( ! fpl ) return NULL ; new_fpl = kmemdup ( fpl , offsetof ( struct scm_fp_list , fp [ fpl -> count ] ) , GFP_KERNEL ) ; if ( new_fpl ) { for ( i = 0 ; i < fpl -> count ; i ++ ) get_file ( fpl -> fp [ i ] ) ; new_fpl -> max = new_fpl -> count ; } return new_fpl ; }
",0,156
1562,"void cipso_v4_req_delattr ( struct request_sock * req ) { struct ip_options_rcu * opt ; struct inet_request_sock * req_inet ; req_inet = inet_rsk ( req ) ; opt = req_inet -> opt ; if ( opt == NULL || opt -> cipso == 0 ) return ; cipso_v4_delopt ( & req_inet -> opt ) ; }
",0,102
1563,"static void tree2tok ( struct vpx_token * tokens , const vpx_tree_index * tree , int i , int v , int l ) { v += v ; ++ l ; do { const vpx_tree_index j = tree [ i ++ ] ; if ( j <= 0 ) { tokens [ - j ] . value = v ; tokens [ - j ] . len = l ; } else { tree2tok ( tokens , tree , j , v , l ) ; } } while ( ++ v & 1 ) ; }
",0,117
1564,"static vpx_codec_err_t encoder_encode ( vpx_codec_alg_priv_t * ctx , const vpx_image_t * img , vpx_codec_pts_t pts , unsigned long duration , vpx_enc_frame_flags_t flags , unsigned long deadline ) { vpx_codec_err_t res = VPX_CODEC_OK ; if ( img ) { res = validate_img ( ctx , img ) ; } pick_quickcompress_mode ( ctx , duration , deadline ) ; vpx_codec_pkt_list_init ( & ctx -> pkt_list ) ; if ( ( ( flags & VP8_EFLAG_NO_UPD_GF ) && ( flags & VP8_EFLAG_FORCE_GF ) ) || ( ( flags & VP8_EFLAG_NO_UPD_ARF ) && ( flags & VP8_EFLAG_FORCE_ARF ) ) ) { ctx -> base . err_detail = ""Conflictingflags."" ; return VPX_CODEC_INVALID_PARAM ; } if ( ( flags & ( VP8_EFLAG_NO_REF_LAST | VP8_EFLAG_NO_REF_GF | VP8_EFLAG_NO_REF_ARF ) ) ) { int ref = 7 ; if ( flags & VP8_EFLAG_NO_REF_LAST ) ref ^= VP9_LAST_FLAG ; if ( flags & VP8_EFLAG_NO_REF_GF ) ref ^= VP9_GOLD_FLAG ; if ( flags & VP8_EFLAG_NO_REF_ARF ) ref ^= VP9_ALT_FLAG ; vp9_use_as_reference ( ctx -> cpi , ref ) ; } if ( flags & ( VP8_EFLAG_NO_UPD_LAST | VP8_EFLAG_NO_UPD_GF | VP8_EFLAG_NO_UPD_ARF | VP8_EFLAG_FORCE_GF | VP8_EFLAG_FORCE_ARF ) ) { int upd = 7 ; if ( flags & VP8_EFLAG_NO_UPD_LAST ) upd ^= VP9_
",0,511
1565,"SYSCALL_DEFINE2 ( timerfd_create , int , clockid , int , flags ) { int ufd ; struct timerfd_ctx * ctx ; BUILD_BUG_ON ( TFD_CLOEXEC != O_CLOEXEC ) ; BUILD_BUG_ON ( TFD_NONBLOCK != O_NONBLOCK ) ; if ( ( flags & ~ TFD_CREATE_FLAGS ) || ( clockid != CLOCK_MONOTONIC && clockid != CLOCK_REALTIME && clockid != CLOCK_REALTIME_ALARM && clockid != CLOCK_BOOTTIME && clockid != CLOCK_BOOTTIME_ALARM ) ) return - EINVAL ; if ( ! capable ( CAP_WAKE_ALARM ) && ( clockid == CLOCK_REALTIME_ALARM || clockid == CLOCK_BOOTTIME_ALARM ) ) return - EPERM ; ctx = kzalloc ( sizeof ( * ctx ) , GFP_KERNEL ) ; if ( ! ctx ) return - ENOMEM ; init_waitqueue_head ( & ctx -> wqh ) ; spin_lock_init ( & ctx -> lock ) ; ctx -> clockid = clockid ; if ( isalarm ( ctx ) ) alarm_init ( & ctx -> t . alarm , ctx -> clockid == CLOCK_REALTIME_ALARM ? ALARM_REALTIME : ALARM_BOOTTIME , timerfd_alarmproc ) ; else hrtimer_init ( & ctx -> t . tmr , clockid , HRTIMER_MODE_ABS ) ; ctx -> moffs = ktime_mono_to_real ( 0 ) ; ufd = anon_inode_getfd ( ""[timerfd]"" , & timerfd_fops , ctx , O_RDWR | ( flags & TFD_SHARED_FCNTL_FLAGS ) ) ; if ( ufd < 0 ) kfree ( ctx ) ; return ufd ; }
",0,462
1566,"static int attach_recursive_mnt ( struct mount * source_mnt , struct mount * dest_mnt , struct mountpoint * dest_mp , struct path * parent_path ) { HLIST_HEAD ( tree_list ) ; struct mount * child , * p ; struct hlist_node * n ; int err ; if ( IS_MNT_SHARED ( dest_mnt ) ) { err = invent_group_ids ( source_mnt , true ) ; if ( err ) goto out ; err = propagate_mnt ( dest_mnt , dest_mp , source_mnt , & tree_list ) ; lock_mount_hash ( ) ; if ( err ) goto out_cleanup_ids ; for ( p = source_mnt ; p ; p = next_mnt ( p , source_mnt ) ) set_mnt_shared ( p ) ; } else { lock_mount_hash ( ) ; } if ( parent_path ) { detach_mnt ( source_mnt , parent_path ) ; attach_mnt ( source_mnt , dest_mnt , dest_mp ) ; touch_mnt_namespace ( source_mnt -> mnt_ns ) ; } else { mnt_set_mountpoint ( dest_mnt , dest_mp , source_mnt ) ; commit_tree ( source_mnt , NULL ) ; } hlist_for_each_entry_safe ( child , n , & tree_list , mnt_hash ) { struct mount * q ; hlist_del_init ( & child -> mnt_hash ) ; q = __lookup_mnt_last ( & child -> mnt_parent -> mnt , child -> mnt_mountpoint ) ; commit_tree ( child , q ) ; } unlock_mount_hash ( ) ; return 0 ; out_cleanup_ids : while ( ! hlist_empty ( & tree_list ) ) { child = hlist_entry ( tree_list . first , struct mount , mnt_hash ) ; if ( child -> mnt_mountpoint == child -> mnt_mountpoint && child -> mnt_ns ) { umount_tree ( child , UMOUNT_CONNECTED ) ; } } unlock_mount_hash ( ) ; cleanup_group_ids ( source_mnt ,
",0,513
1567,"static krb5_error_code decode_sequence_of ( const uint8_t * asn1 , size_t len , const struct atype_info * elemtype , void * * seq_out , size_t * count_out ) { krb5_error_code ret ; void * seq = NULL , * elem , * newseq ; const uint8_t * contents ; size_t clen , count = 0 ; taginfo t ; * seq_out = NULL ; * count_out = 0 ; while ( len > 0 ) { ret = get_tag ( asn1 , len , & t , & contents , & clen , & asn1 , & len , 0 ) ; if ( ret ) goto error ; if ( ! check_atype_tag ( elemtype , & t ) ) { ret = ASN1_BAD_ID ; goto error ; } newseq = realloc ( seq , ( count + 1 ) * elemtype -> size ) ; if ( newseq == NULL ) { ret = ENOMEM ; goto error ; } seq = newseq ; elem = ( char * ) seq + count * elemtype -> size ; memset ( elem , 0 , elemtype -> size ) ; ret = decode_atype ( & t , contents , clen , elemtype , elem ) ; if ( ret ) goto error ; count ++ ; } * seq_out = seq ; * count_out = count ; return 0 ; error : free_sequence_of ( elemtype , seq , count ) ; free ( seq ) ; return ret ; }
",1,347
1568,"static void fadst16_8col ( __m128i * in ) { __m128i s [ 16 ] , x [ 16 ] , u [ 32 ] , v [ 32 ] ; const __m128i k__cospi_p01_p31 = pair_set_epi16 ( cospi_1_64 , cospi_31_64 ) ; const __m128i k__cospi_p31_m01 = pair_set_epi16 ( cospi_31_64 , - cospi_1_64 ) ; const __m128i k__cospi_p05_p27 = pair_set_epi16 ( cospi_5_64 , cospi_27_64 ) ; const __m128i k__cospi_p27_m05 = pair_set_epi16 ( cospi_27_64 , - cospi_5_64 ) ; const __m128i k__cospi_p09_p23 = pair_set_epi16 ( cospi_9_64 , cospi_23_64 ) ; const __m128i k__cospi_p23_m09 = pair_set_epi16 ( cospi_23_64 , - cospi_9_64 ) ; const __m128i k__cospi_p13_p19 = pair_set_epi16 ( cospi_13_64 , cospi_19_64 ) ; const __m128i k__cospi_p19_m13 = pair_set_epi16 ( cospi_19_64 , - cospi_13_64 ) ; const __m128i k__cospi_p17_p15 = pair_set_epi16 ( cospi_17_64 , cospi_15_64 ) ; const __m128i k__cospi_p15_m17 = pair_set_epi16 ( cospi_15_64 , - cospi_17_64 ) ; const __m128i k__cospi_p21_p11 = pair_set_epi16 ( cospi_21_64 , cospi_11_64 ) ; const
",0,511
1569,"static int frame_max_bits ( const RATE_CONTROL * rc , const VP9_CONFIG * oxcf ) { int64_t max_bits = ( ( int64_t ) rc -> avg_frame_bandwidth * ( int64_t ) oxcf -> two_pass_vbrmax_section ) / 100 ; if ( max_bits < 0 ) max_bits = 0 ; else if ( max_bits > rc -> max_frame_bandwidth ) max_bits = rc -> max_frame_bandwidth ; return ( int ) max_bits ; }
",0,128
1570,"static mif_hdr_t * mif_hdr_get ( jas_stream_t * in ) { jas_uchar magicbuf [ MIF_MAGICLEN ] ; char buf [ 4096 ] ; mif_hdr_t * hdr ; bool done ; jas_tvparser_t * tvp ; int id ; hdr = 0 ; tvp = 0 ; if ( jas_stream_read ( in , magicbuf , MIF_MAGICLEN ) != MIF_MAGICLEN ) { goto error ; } if ( magicbuf [ 0 ] != ( MIF_MAGIC >> 24 ) || magicbuf [ 1 ] != ( ( MIF_MAGIC >> 16 ) & 0xff ) || magicbuf [ 2 ] != ( ( MIF_MAGIC >> 8 ) & 0xff ) || magicbuf [ 3 ] != ( MIF_MAGIC & 0xff ) ) { jas_eprintf ( ""error:badsignature\\n"" ) ; goto error ; } if ( ! ( hdr = mif_hdr_create ( 0 ) ) ) { goto error ; } done = false ; do { if ( ! mif_getline ( in , buf , sizeof ( buf ) ) ) { jas_eprintf ( ""mif_getlinefailed\\n"" ) ; goto error ; } if ( buf [ 0 ] == '\\0' ) { continue ; } JAS_DBGLOG ( 10 , ( ""headerline:len=%d;%s\\n"" , strlen ( buf ) , buf ) ) ; if ( ! ( tvp = jas_tvparser_create ( buf ) ) ) { jas_eprintf ( ""jas_tvparser_createfailed\\n"" ) ; goto error ; } if ( jas_tvparser_next ( tvp ) ) { jas_eprintf ( ""cannotgetrecordtype\\n"" ) ; goto error ; } id = jas_taginfo_nonull ( jas_taginfos_lookup ( mif_tags2 , jas_tvparser_gettag ( tvp ) ) ) -> id ; jas_tvparser_destroy ( tvp ) ; tvp = 0 ; switch ( id ) { case MIF_CMPT : if ( mif_process
",0,511
1571,"void Huff_transmit ( huff_t * huff , int ch , byte * fout , int maxoffset ) { int i ; if ( huff -> loc [ ch ] == NULL ) { Huff_transmit ( huff , NYT , fout , maxoffset ) ; for ( i = 7 ; i >= 0 ; i -- ) { add_bit ( ( char ) ( ( ch >> i ) & 0x1 ) , fout ) ; } } else { send ( huff -> loc [ ch ] , NULL , fout , maxoffset ) ; } }
",1,123
1572,"static void encode_superblock ( VP9_COMP * cpi , ThreadData * td , TOKENEXTRA * * t , int output_enabled , int mi_row , int mi_col , BLOCK_SIZE bsize , PC_TREE * pc_tree ) { VP9_COMMON * const cm = & cpi -> common ; MACROBLOCK * const x = & td -> mb ; MACROBLOCKD * const xd = & x -> e_mbd ; MODE_INFO * * mi_8x8 = xd -> mi ; MODE_INFO * mi = mi_8x8 [ 0 ] ; MB_MODE_INFO * mbmi = & mi -> mbmi ; PICK_MODE_CONTEXT * ctx = & pc_tree -> none ; unsigned int segment_id = mbmi -> segment_id ; const int mis = cm -> mi_stride ; const int mi_width = num_8x8_blocks_wide_lookup [ bsize ] ; const int mi_height = num_8x8_blocks_high_lookup [ bsize ] ; const int skip_recode = ! x -> select_txfm_size && mbmi -> sb_type >= BLOCK_8X8 && cpi -> oxcf . aq_mode != COMPLEXITY_AQ && cpi -> oxcf . aq_mode != CYCLIC_REFRESH_AQ && cpi -> sf . allow_skip_recode ; if ( cpi -> oxcf . aq_mode != COMPLEXITY_AQ && cpi -> oxcf . aq_mode != CYCLIC_REFRESH_AQ && cpi -> sf . allow_skip_encode ) return ; ctx -> is_coded = 1 ; x -> use_lp32x32fdct = cpi -> sf . use_lp32x32fdct ; x -> skip_encode = ( ! output_enabled && cpi -> sf . skip_encode_frame && x -> q_index < QIDX_SKIP_THRESH ) ; if ( x -> skip_encode ) return ; if ( cm -> frame_type == KEY_FRAME ) { if ( cpi -> oxcf . tuning == VP8_TUNE_
",0,511
1573,"static int usb_parse_configuration ( struct usb_device * dev , int cfgidx , struct usb_host_config * config , unsigned char * buffer , int size ) { struct device * ddev = & dev -> dev ; unsigned char * buffer0 = buffer ; int cfgno ; int nintf , nintf_orig ; int i , j , n ; struct usb_interface_cache * intfc ; unsigned char * buffer2 ; int size2 ; struct usb_descriptor_header * header ; int len , retval ; u8 inums [ USB_MAXINTERFACES ] , nalts [ USB_MAXINTERFACES ] ; unsigned iad_num = 0 ; memcpy ( & config -> desc , buffer , USB_DT_CONFIG_SIZE ) ; if ( config -> desc . bDescriptorType != USB_DT_CONFIG || config -> desc . bLength < USB_DT_CONFIG_SIZE || config -> desc . bLength > size ) { dev_err ( ddev , ""invaliddescriptorforconfigindex%d:"" ""type=0x%X,length=%d\\n"" , cfgidx , config -> desc . bDescriptorType , config -> desc . bLength ) ; return - EINVAL ; } cfgno = config -> desc . bConfigurationValue ; buffer += config -> desc . bLength ; size -= config -> desc . bLength ; nintf = nintf_orig = config -> desc . bNumInterfaces ; if ( nintf > USB_MAXINTERFACES ) { dev_warn ( ddev , ""config%dhastoomanyinterfaces:%d,"" ""usingmaximumallowed:%d\\n"" , cfgno , nintf , USB_MAXINTERFACES ) ; nintf = USB_MAXINTERFACES ; } n = 0 ; for ( ( buffer2 = buffer , size2 = size ) ; size2 > 0 ; ( buffer2 += header -> bLength , size2 -= header -> bLength ) ) { if ( size2 < sizeof ( struct usb_descriptor_header ) ) { dev_warn ( ddev , ""config%ddescriptorhas%dexcess"" ""byte%s,ignoring\\n"" , cfgno , size2 , plural
",0,511
1574,"static int smbhash ( unsigned char * out , const unsigned char * in , unsigned char * key ) { int rc ; unsigned char key2 [ 8 ] ; struct crypto_skcipher * tfm_des ; struct scatterlist sgin , sgout ; struct skcipher_request * req ; str_to_key ( key , key2 ) ; tfm_des = crypto_alloc_skcipher ( ""ecb(des)"" , 0 , CRYPTO_ALG_ASYNC ) ; if ( IS_ERR ( tfm_des ) ) { rc = PTR_ERR ( tfm_des ) ; goto smbhash_err ; } req = skcipher_request_alloc ( tfm_des , GFP_KERNEL ) ; if ( ! req ) { rc = - ENOMEM ; cifs_dbg ( VFS , ""couldnotallocatedescryptoAPI\\n"" ) ; goto smbhash_free_skcipher ; } crypto_skcipher_setkey ( tfm_des , key2 , 8 ) ; sg_init_one ( & sgin , in , 8 ) ; sg_init_one ( & sgout , out , 8 ) ; skcipher_request_set_callback ( req , 0 , NULL , NULL ) ; skcipher_request_set_crypt ( req , & sgin , & sgout , 8 , NULL ) ; rc = crypto_skcipher_encrypt ( req ) ; if ( rc ) cifs_dbg ( VFS , ""couldnotencryptcryptkeyrc:%d\\n"" , rc ) ; skcipher_request_free ( req ) ; smbhash_free_skcipher : crypto_free_skcipher ( tfm_des ) ; smbhash_err : kfree_skcipher ( tfm_des ) ; return rc ; }
",0,422
1575,"static inline void header_put_be_int ( SF_PRIVATE * psf , int x ) { psf -> header ) - 4 ) { psf -> header [ psf -> headindex ++ ] = ( x >> 24 ) ; psf -> header [ psf -> headindex ++ ] = ( x >> 16 ) ; psf -> header [ psf -> headindex ++ ] = ( x >> 8 ) ; psf -> header [ psf -> header [ psf -> headindex ++ ] = x ; }
",0,112
1576,"static int cbs_av1_read_uvlc ( CodedBitstreamContext * ctx , GetBitContext * gbc , const char * name , uint32_t * write_to , uint32_t range_min , uint32_t range_max ) { int position , zeroes , i , j , a , b ; char bits [ 65 ] ; if ( ctx -> trace_enable ) position = get_bits_count ( gbc ) ; zeroes = i = 0 ; while ( 1 ) { if ( get_bits_left ( gbc ) < zeroes + 1 ) { av_log ( ctx -> log_ctx , AV_LOG_ERROR , ""Invaliduvlccodeat"" ""%s:bitstreamended.\\n"" , name ) ; return AVERROR_INVALIDDATA ; } a = get_bits ( gbc ) ; bits [ i ++ ] = '1' ; break ; } else { bits [ i ++ ] = '0' ; ++ zeroes ; } } if ( zeroes >= 32 ) { value = MAX_UINT_BITS ( 32 ) ; } else { value = get_bits_long ( gbc , zeroes ) ; for ( j = 0 ; j < zeroes ; j ++ ) bits [ i ++ ] = ( value >> ( zeroes - j - 1 ) & 1 ) ? '1' : '0' ; value += ( a << ( zeroes - j - 1 ) & 1 ) ? '0' : 0 ; } if ( ctx -> trace_enable ) { bits [ i ] = 0 ; ff_cbs_trace_syntax_element ( ctx , position , name , NULL , bits , value ) ; } if ( value < range_min || value > range_max ) { av_log ( ctx -> log_ctx , AV_LOG_ERROR , ""%soutofrange:"" ""%"" PRIu32 "",butmustbein[%"" PRIu32 "",%"" PRIu32 ""].\\n"" , name , value , range_min , range_max ) ; return AVERROR_INVALIDDATA ; } * write_to = value ; return 0 ; }
",0,484
1577,"static void adjust_branches ( struct bpf_prog * prog , int pos , int delta ) { struct bpf_insn * insn = prog -> insnsi ; int insn_cnt = prog -> len ; int i ; for ( i = 0 ; i < insn_cnt ; i ++ , insn ++ ) { if ( BPF_CLASS ( insn -> code ) != BPF_JMP || BPF_OP ( insn -> code ) == BPF_CALL || BPF_OP ( insn -> code ) == BPF_EXIT ) continue ; if ( i < pos && i + insn -> off + 1 <= pos + delta ) insn -> off += delta ; else if ( i > pos && i + insn -> off + 1 < pos ) insn -> off -= delta ; } }
",0,186
1578,"static bool nested_vmx_exit_handled ( struct kvm_vcpu * vcpu ) { u32 intr_info = vmcs_read32 ( VM_EXIT_INTR_INFO ) ; struct vcpu_vmx * vmx = to_vmx ( vcpu ) ; struct vmcs12 * vmcs12 = get_vmcs12 ( vcpu ) ; u32 exit_reason = vmx -> exit_reason ; trace_kvm_nested_vmexit ( kvm_rip_read ( vcpu ) , exit_reason , vmcs_readl ( EXIT_QUALIFICATION ) , vmx -> idt_vectoring_info , intr_info , vmcs_read32 ( VM_EXIT_INTR_ERROR_CODE ) , KVM_ISA_VMX ) ; if ( vmx -> nested . nested_run_pending ) return 0 ; if ( unlikely ( vmx -> fail ) ) { pr_info_ratelimited ( ""%sfailedvmentry%x\\n"" , __func__ , vmcs_read32 ( VM_INSTRUCTION_ERROR ) ) ; return 1 ; } switch ( exit_reason ) { case EXIT_REASON_EXCEPTION_NMI : if ( ! is_exception ( intr_info ) ) return 0 ; else if ( is_page_fault ( intr_info ) ) return enable_ept ; else if ( is_no_device ( intr_info ) && ! ( vmcs12 -> guest_cr0 & X86_CR0_TS ) ) return 0 ; return vmcs12 -> exception_bitmap & ( 1u << ( intr_info & INTR_INFO_VECTOR_MASK ) ) ; case EXIT_REASON_EXTERNAL_INTERRUPT : return 0 ; case EXIT_REASON_TRIPLE_FAULT : return 1 ; case EXIT_REASON_PENDING_INTERRUPT : return nested_cpu_has ( vmcs12 , CPU_BASED_VIRTUAL_INTR_PENDING ) ; case EXIT_REASON_NMI_WINDOW : return nested_cpu_has ( vmcs12 , CPU_BASED_VIRTUAL_NMI_PENDING ) ; case EXIT_REASON_TASK_
",0,511
1579,"error_t httpParseParam ( const char_t * * pos , HttpParam * param ) { error_t error ; size_t i ; uint8_t c ; bool_t escapeFlag ; bool_t separatorFound ; const char_t * p ; if ( pos == NULL || param == NULL ) return ERROR_INVALID_PARAMETER ; param -> name = NULL ; param -> nameLen = 0 ; param -> value = NULL ; param -> valueLen = 0 ; escapeFlag = FALSE ; separatorFound = FALSE ; error = ERROR_IN_PROGRESS ; i = 0 ; p = * pos ; while ( error == ERROR_IN_PROGRESS ) { c = ( uint8_t ) p [ i ] ; if ( param -> name == NULL ) { if ( c == '\\0' ) { error = ERROR_NOT_FOUND ; } else if ( c == '' || c == '\\t' || c == ',' || c == ';' ) { } else if ( isalnum ( c ) || strchr ( ""
",0,235
1580,"static void ndpi_reset_packet_line_info ( struct ndpi_packet_struct * packet ) { packet -> parsed_lines = 0 , packet -> empty_line_position_set = 0 , packet -> host_line . ptr = NULL , packet -> host_line . len = 0 , packet -> referer_line . ptr = NULL , packet -> referer_line . len = 0 , packet -> content_line . ptr = NULL , packet -> content_line . len = 0 , packet -> accept_line . ptr = NULL , packet -> accept_line . len = 0 , packet -> user_agent_line . ptr = NULL , packet -> user_agent_line . len = 0 , packet -> http_url_name . ptr = NULL , packet -> http_url_name . len = 0 , packet -> http_encoding . ptr = NULL , packet -> http_encoding . len = 0 , packet -> http_transfer_encoding . ptr = NULL , packet -> http_transfer_encoding . len = 0 , packet -> http_transfer_encoding . len = 0 , packet -> http_contentlen . ptr = NULL , packet -> http_contentlen . len = 0 , packet -> http_cookie . ptr = NULL , packet -> http_cookie . len = 0 , packet -> http_origin . len = 0 , packet -> http_origin . ptr = NULL , packet -> http_x_session_type . ptr = NULL , packet -> http_x_session_type . len = 0 , packet -> server_line . ptr = NULL , packet -> server_line . len = 0 , packet -> http_method . ptr = NULL , packet -> http_method . len = 0 , packet -> http_response . ptr = NULL , packet -> http_response . len = 0 , packet -> http_num_headers = 0 ; }
",0,401
1581,"static void * proc_pid_follow_link ( struct dentry * dentry , struct nameidata * nd ) { struct inode * inode = dentry -> d_inode ; int error = - EACCES ; path_put ( & nd -> path ) ; out : return ERR_PTR ( error ) ; }
",1,75
1582,"static int lookup1_values ( int entries , int dim ) { int r = ( int ) floor ( exp ( ( float ) log ( ( float ) entries ) / dim ) ) ; if ( ( int ) floor ( pow ( ( float ) r + 1 , dim ) ) <= entries ) ++ r ; if ( pow ( ( float ) r + 1 , dim ) <= entries ) return - 1 ; return r ; }
",0,89
1583,"static MagickBooleanType ReadDXT1 ( Image * image , DDSInfo * dds_info , ExceptionInfo * exception ) { DDSColors colors ; PixelPacket * q ; register ssize_t i , x ; size_t bits ; ssize_t j , y ; unsigned char code ; unsigned short c0 , c1 ; for ( y = 0 ; y < ( ssize_t ) dds_info -> height ; y += 4 ) { for ( x = 0 ; x < ( ssize_t ) dds_info -> width ; x += 4 ) { q = QueueAuthenticPixels ( image , x , y , MagickMin ( 4 , dds_info -> width - x ) , MagickMin ( 4 , dds_info -> height - y ) , exception ) ; if ( q == ( PixelPacket * ) NULL ) return MagickFalse ; c0 = ReadBlobLSBShort ( image ) ; c1 = ReadBlobLSBShort ( image ) ; bits = ReadBlobLSBLong ( image ) ; CalculateColors ( c0 , c1 , & colors , MagickFalse ) ; for ( j = 0 ; j < 4 ; j ++ ) { for ( i = 0 ; i < 4 ; i ++ ) { if ( ( x + i ) < ( ssize_t ) dds_info -> width && ( y + j ) < ( ssize_t ) dds_info -> height ) { code = ( unsigned char ) ( ( bits >> ( ( j * 4 + i ) * 2 ) ) & 0x3 ) ; SetPixelRed ( q , ScaleCharToQuantum ( colors . r [ code ] ) ) ; SetPixelGreen ( q , ScaleCharToQuantum ( colors . g [ code ] ) ) ; SetPixelBlue ( q , ScaleCharToQuantum ( colors . b [ code ] ) ) ; SetPixelOpacity ( q , ScaleCharToQuantum ( colors . a [ code ] ) ) ; if ( colors . a [ code ] && image -> matte == MagickFalse ) image -> matte = MagickTrue ; q ++ ; } } } } if ( SyncAuthenticPixels ( image , exception ) == MagickFalse ) return MagickFalse ; } }
",0,491
1584,"static int br_parse_ip_options ( struct sk_buff * skb ) { struct ip_options * opt ; struct iphdr * iph ; struct net_device * dev = skb -> dev ; u32 len ; iph = ip_hdr ( skb ) ; opt = & ( IPCB ( skb ) -> opt ) ; if ( unlikely ( ip_fast_csum ( ( u8 * ) iph , iph -> ihl ) ) ) goto inhdr_error ; len = ntohs ( iph -> tot_len ) ; if ( skb -> len < len ) { IP_INC_STATS_BH ( dev_net ( dev ) , IPSTATS_MIB_INTRUNCATEDPKTS ) ; goto drop ; } else if ( len < ( iph -> ihl * 4 ) ) goto inhdr_error ; if ( pskb_trim_rcsum ( skb , len ) ) { IP_INC_STATS_BH ( dev_net ( dev ) , IPSTATS_MIB_INDISCARDS ) ; goto drop ; } if ( iph -> ihl == 5 ) { memset ( IPCB ( skb ) , 0 , sizeof ( struct inet_skb_parm ) ) ; return 0 ; } opt -> optlen = iph -> ihl * 4 - sizeof ( struct iphdr ) ; if ( ip_options_compile ( dev_net ( dev ) , opt , skb ) ) goto inhdr_error ; if ( unlikely ( opt -> srr ) ) { struct in_device * in_dev = __in_dev_get_rcu ( dev ) ; if ( in_dev && ! IN_DEV_SOURCE_ROUTE ( in_dev ) ) goto drop ; if ( ip_options_rcv_srr ( skb ) ) goto drop ; } return 0 ; inhdr_error : IP_INC_STATS_BH ( dev_net ( dev ) , IPSTATS_
",0,445
1585,"static void merge_param ( HashTable * params , zval * zdata , zval * * current_param , zval * * current_args TSRMLS_DC ) { zval * * ptr , * * zdata_ptr ; php_http_array_hashkey_t hkey = php_http_array_hashkey_init ( 0 ) ; # if 0 { zval tmp ; INIT_PZVAL_ARRAY ( & tmp , params ) ; fprintf ( stderr , ""params="" ) ; zend_print_zval_r ( & tmp , 1 TSRMLS_CC ) ; fprintf ( stderr , ""\\n"" ) ; } # endif hkey . type = zend_hash_get_current_key_ex ( Z_ARRVAL_P ( zdata ) , & hkey . str , & hkey . len , & hkey . num , hkey . dup , NULL ) ; if ( ( hkey . type == HASH_KEY_IS_STRING && ! zend_hash_exists ( params , hkey . str , hkey . len ) ) || ( hkey . type == HASH_KEY_IS_LONG && ! zend_hash_index_exists ( params , hkey . num ) ) ) { zval * tmp , * arg , * * args ; zend_hash_get_current_data ( Z_ARRVAL_P ( zdata ) , ( void * ) & ptr ) ; Z_ADDREF_PP ( ptr ) ; MAKE_STD_ZVAL ( tmp ) ; array_init ( tmp ) ; add_assoc_zval_ex ( tmp , ZEND_STRS ( ""value"" ) , * ptr ) ; MAKE_STD_ZVAL ( arg ) ; array_init ( arg ) ; zend_hash_update ( Z_ARRVAL_P ( tmp ) , ""arguments"" , sizeof ( ""arguments"" ) , ( void * ) & arg , sizeof ( zval * ) , ( void * ) & args ) ; * current_args = args ; if ( hkey . type == HASH_KEY_IS_STRING ) { zend_hash_update ( params , hkey . str , hkey . len , ( void * ) & tmp , sizeof ( zval * ) ,
",0,511
1586,"static int a2dp_ctrl_receive ( struct a2dp_stream_common * common , void * buffer , int length ) { int ret = TEMP_FAILURE_RETRY ( recv ( common -> ctrl_fd , buffer , length , MSG_NOSIGNAL ) ) ; if ( ret < 0 ) { ERROR ( ""ackfailed(%s)"" , strerror ( errno ) ) ; if ( errno == EINTR ) { ret = TEMP_FAILURE_RETRY ( recv ( common -> ctrl_fd , buffer , length , MSG_NOSIGNAL ) ) ; if ( ret < 0 ) { ERROR ( ""ackfailed(%s)"" , strerror ( errno ) ) ; skt_disconnect ( common -> ctrl_fd ) ; common -> ctrl_fd = AUDIO_SKT_DISCONNECTED ; return - 1 ; } } else { skt_disconnect ( common -> ctrl_fd ) ; common -> ctrl_fd = AUDIO_SKT_DISCONNECTED ; return - 1 ; } } return ret ; }
",1,246
1587,"void BezierOval ( double w , double h , char * action , vpx_bit_depth_t bit_depth ) { outpos += sprintf ( outpos , ""%12.3f0m%12.3f%12.3f%12.3f%12.3f%12.3f0%12.3fc\\n"" , - w , - w , h * BzK , - w * BzK , h , h ) ; outpos += sprintf ( outpos , ""%12.3f%12.3f%12.3f%12.3f%12.3f0c\\n"" , w * BzK , h , w , h * BzK , w ) ; outpos += sprintf ( outpos , ""%12.3f%12.3f%12.3f%12.3f%12.3f0c%s\\n"" , - w * BzK , - h , - w , - h * BzK , - w , action ) ; }
",0,234
1588,"static void parse_cfg ( int flags , int argc , const char * * argv , cfg_t * cfg ) { struct stat st ; int i ; memset ( cfg , 0 , sizeof ( cfg_t ) ) ; cfg -> debug_file = stderr ; for ( i = 0 ; i < argc ; i ++ ) { if ( strncmp ( argv [ i ] , ""max_devices="" , 12 ) == 0 ) sscanf ( argv [ i ] , ""max_devices=%u"" , & cfg -> max_devs ) ; if ( strcmp ( argv [ i ] , ""manual"" ) == 0 ) cfg -> manual = 1 ; if ( strcmp ( argv [ i ] , ""debug"" ) == 0 ) cfg -> debug = 1 ; if ( strcmp ( argv [ i ] , ""nouserok"" ) == 0 ) cfg -> nouserok = 1 ; if ( strcmp ( argv [ i ] , ""openasuser"" ) == 0 ) cfg -> openasuser = 1 ; if ( strcmp ( argv [ i ] , ""alwaysok"" ) == 0 ) cfg -> alwaysok = 1 ; if ( strcmp ( argv [ i ] , ""interactive"" ) == 0 ) cfg -> interactive = 1 ; if ( strcmp ( argv [ i ] , ""cue"" ) == 0 ) cfg -> cue = 1 ; if ( strcmp ( argv [ i ] , ""nodetect"" ) == 0 ) cfg -> nodetect = 1 ; if ( strncmp ( argv [ i ] , ""authfile="" , 9 ) == 0 ) cfg -> auth_file = argv [ i ] + 9 ; if ( strncmp ( argv [ i ] , ""authpending_file="" , 17 ) == 0 ) cfg -> authpending_file = argv [ i ] + 17 ; if ( strncmp ( argv [ i ] , ""origin="" , 7 ) == 0 ) cfg -> origin = argv [ i ] + 7 ; if ( strncmp ( argv [ i ] , ""appid="" , 6 ) == 0 ) cfg -> appid = argv [ i ] + 6 ; if ( strncmp ( argv [ i ]
",0,511
1589,"int build_segment_manager ( struct f2fs_sb_info * sbi ) { struct f2fs_super_block * raw_super = F2FS_RAW_SUPER ( sbi ) ; struct f2fs_checkpoint * ckpt = F2FS_CKPT ( sbi ) ; struct f2fs_sm_info * sm_info ; int err ; sm_info = kzalloc ( sizeof ( struct f2fs_sm_info ) , GFP_KERNEL ) ; if ( ! sm_info ) return - ENOMEM ; sbi -> sm_info = sm_info ; sm_info -> seg0_blkaddr = le32_to_cpu ( raw_super -> segment0_blkaddr ) ; sm_info -> main_blkaddr = le32_to_cpu ( raw_super -> main_blkaddr ) ; sm_info -> segment_count = le32_to_cpu ( raw_super -> segment_count ) ; sm_info -> reserved_segments = le32_to_cpu ( ckpt -> rsvd_segment_count ) ; sm_info -> ovp_segments = le32_to_cpu ( ckpt -> overprov_segment_count ) ; sm_info -> main_segments = le32_to_cpu ( raw_super -> segment_count_main ) ; sm_info -> ssa_blkaddr = le32_to_cpu ( raw_super -> ssa_blkaddr ) ; sm_info -> rec_prefree_segments = sm_info -> main_segments * DEF_RECLAIM_PREFREE_SEGMENTS / 100 ; if ( sm_info -> rec_prefree_segments > DEF_MAX_RECLAIM_PREFREE_SEGMENTS ) sm_info -> rec_prefree_segments = DEF_MAX_RECLAIM_PREFREE_SEGMENTS ; if ( ! test_opt ( sbi , LFS ) ) sm_info -> ipu_policy = 1 << F2FS_IPU_FSYNC ; sm_info -> min_ipu_util = DEF_MIN_IPU_UTIL ; sm_info -> min_fsync_blocks = DEF_MIN_FSYNC_BLOCKS ;
",0,511
1590,"static Image * ReadSUNImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define RMT_EQUAL_RGB 1 # define RMT_NONE 0 # define RMT_RAW 2 # define RT_STANDARD 1 # define RT_ENCODED 2 # define RT_FORMAT_RGB 3 typedef struct _SUNInfo { unsigned int magic , width , height , depth , length , type , maptype , maplength ; } SUNInfo ; Image * image ; int bit ; MagickBooleanType status ; MagickSizeType number_pixels ; register Quantum * q ; register ssize_t i , x ; register unsigned char * p ; size_t bytes_per_line , extent , length ; ssize_t count , y ; SUNInfo sun_info ; unsigned char * sun_data , * sun_pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } ( void ) ResetMagickMemory ( & sun_info , 0 , sizeof ( sun_info ) ) ; sun_info . magic = ReadBlobMSBLong ( image ) ; do { if ( sun_info . magic != 0x59a66a95 ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; sun_info . width = ReadBlobMSBLong ( image ) ; sun_info . height = ReadBlobMSBLong ( image ) ; sun_info . depth = ReadBlobMSBLong ( image ) ; sun_info . length = ReadBlobMSBLong ( image ) ; sun_info . type = ReadBlobMSBLong ( image ) ; sun_info . maptype = Read
",0,511
1591,"void SetTransferMatrix ( double x11 , double x12 , double x21 , double x22 , double x , double y ) { if ( ( fabs ( x11 - 1. ) > 0.001 ) || ( fabs ( x22 - 1. ) > 0.001 ) || ( fabs ( x12 ) > 0.001 ) || ( fabs ( x21 ) > 0.001 ) || ( fabs ( x ) > 0.001 ) || ( fabs ( y ) > 0.001 ) ) { sprintf ( outputbuffer , ""%12.3f%12.3f%12.3f%12.3f%12.3f%12.3fcm\\n"" , x11 , x12 , x21 , x22 , x , y ) ; sendClean ( outputbuffer ) ; } }
",1,181
1592,"static BOOL autodetect_recv_bandwidth_measure_results ( rdpRdp * rdp , wStream * s , AUTODETECT_RSP_PDU * autodetectRspPdu ) { BOOL success = TRUE ; if ( autodetectRspPdu -> headerLength != 0x0E ) return FALSE ; WLog_VRB ( AUTODETECT_TAG , ""receivedBandwidthMeasureResultsPDU"" ) ; return TRUE ; }
",0,110
1593,"int ipmi_destroy_user ( struct ipmi_user * user ) { cleanup_srcu_struct ( & user -> release_barrier ) ; kref_put ( & user -> refcount , free_user ) ; return 0 ; }
",0,54
1594,"static void encode_mb_row ( VP8_COMP * cpi , VP8_COMMON * cm , int mb_row , MACROBLOCK * x , MACROBLOCKD * xd , TOKENEXTRA * * tp , int * segment_counts , int * totalrate ) { int recon_yoffset , recon_uvoffset ; int mb_col ; int ref_fb_idx = cm -> lst_fb_idx ; int dst_fb_idx = cm -> new_fb_idx ; int recon_y_stride = cm -> yv12_fb [ ref_fb_idx ] . y_stride ; int recon_uv_stride = cm -> yv12_fb [ ref_fb_idx ] . uv_stride ; int map_index = ( mb_row * cpi -> common . mb_cols ) ; # if ( CONFIG_REALTIME_ONLY & CONFIG_ONTHEFLY_BITPACKING ) const int num_part = ( 1 << cm -> multi_token_partition ) ; TOKENEXTRA * tp_start = cpi -> tok ; vp8_writer * w ; # endif # if CONFIG_MULTITHREAD const int nsync = cpi -> mt_sync_range ; const int rightmost_col = cm -> mb_cols + nsync ; volatile const int * last_row_current_mb_col ; volatile int * current_mb_col = & cpi -> mt_current_mb_col [ mb_row ] ; if ( ( cpi -> b_multi_threaded != 0 ) && ( mb_row != 0 ) ) last_row_current_mb_col = & cpi -> mt_current_mb_col [ mb_row - 1 ] ; else last_row_current_mb_col = & rightmost_col ; # endif # if ( CONFIG_REALTIME_ONLY & CONFIG_ONTHEFLY_BITPACKING ) if ( num_part > 1 ) w = & cpi -> bc [ 1 + ( mb_row % num_part ) ] ; else w = & cpi -> bc [ 1 ] ; # endif xd -> above_context = cm -> above_context ; xd
",0,511
1595,"static int fr_add_pvc ( struct net_device * frad , unsigned int dlci , int type ) { hdlc_device * hdlc = dev_to_hdlc ( frad ) ; pvc_device * pvc ; struct net_device * dev ; int used ; if ( type == ARPHRD_ETHER ) dev = alloc_netdev ( 0 , ""pvceth%d"" , ether_setup ) ; else dev = alloc_netdev ( 0 , ""pvc%d"" , pvc_setup ) ; if ( ! dev ) { netdev_warn ( frad , ""Memorysqueezeonfr_pvc()\\n"" ) ; delete_unused_pvcs ( hdlc ) ; return - ENOBUFS ; } if ( type == ARPHRD_ETHER ) random_ether_addr ( dev -> dev_addr ) ; else { * ( __be16 * ) dev -> dev_addr = htons ( dlci ) ; dlci_to_q922 ( dev -> broadcast , dlci ) ; } dev -> netdev_ops = & pvc_ops ; dev -> mtu = HDLC_MAX_MTU ; dev -> tx_queue_len = 0 ; dev -> ml_priv = pvc ; if ( register_netdevice ( dev ) != 0 ) { free_netdev ( dev ) ; delete_unused_pvcs ( hdlc ) ; return - EIO ; } dev -> destructor = free_netdev ; * get_dev_p ( pvc , type ) = dev ; if ( ! used ) { state ( hdlc ) -> dce_changed = 1 ; state ( hdlc ) -> dce_pvc_count ++ ; } return 0 ; }
",0,395
1596,"static void cliprdr_process ( STREAM s ) { uint16 type , status ; uint32 length , format ; uint8 * data ; struct stream packet = * s ; in_uint16_le ( s , type ) ; in_uint16_le ( s , status ) ; in_uint32_le ( s , length ) ; data = s -> p ; logger ( Clipboard , Debug , ""cliprdr_process(),type=%d,status=%d,length=%d"" , type , status , length ) ; if ( ! s_check_rem ( s , length ) ) { rdp_protocol_error ( ""cliprdr_process(),consumeofpacketfromstreamwouldoverrun"" , & packet ) ; } if ( status == CLIPRDR_ERROR ) { switch ( type ) { case CLIPRDR_FORMAT_ACK : cliprdr_send_native_format_announce ( last_formats , last_formats_length ) ; break ; case CLIPRDR_DATA_RESPONSE : ui_clip_request_failed ( ) ; break ; default : logger ( Clipboard , Warning , ""cliprdr_process(),unhandlederror(type=%d)"" , type ) ; } return ; } switch ( type ) { case CLIPRDR_CONNECT : ui_clip_sync ( ) ; break ; case CLIPRDR_FORMAT_ANNOUNCE : ui_clip_format_announce ( data , length ) ; cliprdr_send_packet ( CLIPRDR_FORMAT_ACK , CLIPRDR_RESPONSE , NULL , 0 ) ; return ; case CLIPRDR_FORMAT_ACK : break ; case CLIPRDR_DATA_REQUEST : in_uint32_le ( s , format ) ; ui_clip_request_data ( format ) ; break ; case CLIPRDR_DATA_RESPONSE : ui_clip_handle_data ( data , length ) ; break ; case 7 : break ; default : logger ( Clipboard , Warning , ""cliprdr_process(),unhandledpackettype%d"" , type ) ; } }
",1,482
1597,"int vp8_remove_decoder_instances ( struct frame_buffers * fb ) { if ( ! fb -> use_frame_threads ) { VP8D_COMP * pbi = fb -> pbi [ 0 ] ; if ( ! pbi ) return VPX_CODEC_ERROR ; # if CONFIG_MULTITHREAD if ( pbi -> b_multithreaded_rd ) vp8mt_de_alloc_temp_buffers ( pbi , pbi -> common . mb_rows ) ; vp8_decoder_remove_threads ( pbi ) ; # endif remove_decompressor ( pbi ) ; } else { } return VPX_CODEC_OK ; }
",0,166
1598,"void formUpdateBuffer ( Anchor * a , Buffer * buf , FormItemList * form ) { Buffer save ; char * p ; int spos , epos , rows , c_rows , pos , col = 0 ; Line * l ; copyBuffer ( & save , buf ) ; gotoLine ( buf , a -> start . line ) ; switch ( form -> type ) { case FORM_TEXTAREA : case FORM_INPUT_TEXT : case FORM_INPUT_FILE : case FORM_INPUT_PASSWORD : case FORM_INPUT_CHECKBOX : case FORM_INPUT_RADIO : # ifdef MENU_SELECT case FORM_SELECT : # endif spos = a -> start . pos ; epos = a -> end . pos ; break ; default : spos = a -> start . pos + 1 ; epos = a -> end . pos - 1 ; } switch ( form -> type ) { case FORM_INPUT_CHECKBOX : case FORM_INPUT_RADIO : if ( buf -> currentLine == NULL || spos >= buf -> currentLine -> len || spos < 0 ) break ; if ( form -> checked ) buf -> currentLine -> lineBuf [ spos ] = '*' ; else buf -> currentLine -> lineBuf [ spos ] = '' ; break ; case FORM_INPUT_TEXT : case FORM_INPUT_FILE : case FORM_INPUT_PASSWORD : case FORM_TEXTAREA : # ifdef MENU_SELECT case FORM_SELECT : if ( form -> type == FORM_SELECT ) { p = form -> label -> ptr ; updateSelectOption ( form , form -> select_option ) ; } else # endif { if ( ! form -> value ) break ; p = form -> value -> ptr ; } l = buf -> currentLine ; if ( ! l ) break ; if ( form -> type == FORM_TEXTAREA ) { int n = a -> y - buf -> currentLine -> linenumber ; if ( n > 0 ) for ( ; l && n ; l = l -> prev , n -- ) ; else if ( n < 0 ) for ( ; l && n ; l = l -> prev , n ++ ) ; if ( ! l ) break ; } rows = form -> rows ? form -> rows : 1 ; col = COLPOS ( l , a -> start . pos ) ; for ( c_
",0,511
1599,"void * pvPortMalloc ( size_t xWantedSize ) { BlockLink_t * pxBlock , * pxPreviousBlock , * pxNewBlockLink ; void * pvReturn = NULL ; configASSERT ( pxEnd ) ; vTaskSuspendAll ( ) ; { if ( ( xWantedSize & xBlockAllocatedBit ) == 0 ) { if ( ( xWantedSize + xHeapStructSize ) > xWantedSize ) { xWantedSize += xHeapStructSize ; if ( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 ) { if ( ( xWantedSize + ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) ) ) > xWantedSize ) { xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) ) ; } else { mtCOVERAGE_TEST_MARKER ( ) ; } } else { mtCOVERAGE_TEST_MARKER ( ) ; } if ( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) ) { pxPreviousBlock = & xStart ; pxBlock = xStart . pxNextFreeBlock ; while ( ( pxBlock -> xBlockSize < xWantedSize ) && ( pxBlock -> pxNextFreeBlock != NULL ) ) { pxPreviousBlock = pxBlock ; pxBlock = pxBlock -> pxNextFreeBlock ; } if ( pxBlock != pxEnd ) { pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock -> pxNextFreeBlock ) + xHeapStructSize ) ; pxPreviousBlock -> pxNextFreeBlock = pxBlock -> pxNextFreeBlock ; if ( ( pxBlock -> xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE ) { pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize ) ; pxNewBlockLink -> xBlockSize = pxBlock -> xBlockSize - xWantedSize ; pxBlock -> x
",0,511
1600,"void vp9_iht8x8_add ( TX_TYPE tx_type , const tran_low_t * input , uint8_t * dest , int stride , int eob ) { if ( tx_type == DCT_DCT ) { vp9_idct8x8_add ( input , dest , stride , eob ) ; } else { vp9_iht8x8_64_add ( input , dest , stride , tx_type ) ; } }
",1,111
1601,"static int misaligned_store ( struct pt_regs * regs , __u32 opcode , int displacement_not_indexed , int width_shift ) { int error ; int srcreg ; __u64 address ; error = generate_and_check_address ( regs , opcode , displacement_not_indexed , width_shift , & address ) ; if ( error < 0 ) { return error ; } perf_sw_event ( PERF_COUNT_SW_ALIGNMENT_FAULTS , 1 , regs , address ) ; srcreg = ( opcode >> 4 ) & 0x3f ; if ( user_mode ( regs ) ) { __u64 buffer ; if ( ! access_ok ( VERIFY_WRITE , ( unsigned long ) address , 1UL << width_shift ) ) { return - 1 ; } switch ( width_shift ) { case 1 : * ( __u16 * ) & buffer = ( __u16 ) regs -> regs [ srcreg ] ; break ; case 2 : * ( __u32 * ) & buffer = ( __u32 ) regs -> regs [ srcreg ] ; break ; case 3 : buffer = regs -> regs [ srcreg ] ; break ; default : printk ( ""Unexpectedwidth_shift%dinmisaligned_store,PC=%08lx\\n"" , width_shift , ( unsigned long ) regs -> pc ) ; break ; } if ( __copy_user ( ( void * ) ( int ) address , & buffer , ( 1 << width_shift ) ) > 0 ) { return - 1 ; } } else { __u64 val = regs -> regs [ srcreg ] ; switch ( width_shift ) { case 1 : misaligned_kernel_word_store ( address , val ) ; break ; case 2 : asm ( ""stlo.l%1,0,%0"" : : ""r"" ( val ) , ""r"" ( address ) ) ; asm ( ""sthi.l%1,3,%0"" : : : ""r"" ( val ) , ""r"" ( address ) ) ; break ; case 3 : asm ( ""stlo.q%1,0,%0"" : : : ""r"" ( val ) , ""r"" ( address ) ) ; asm ( ""sthi.q
",0,511
1602,"static int fpDiff ( TIFF * tif , uint8 * cp0 , tmsize_t cc ) { tmsize_t stride = PredictorState ( tif ) -> stride ; uint32 bps = tif -> tif_dir . td_bitspersample / 8 ; tmsize_t wc = cc / bps ; tmsize_t count ; uint8 * cp = ( uint8 * ) cp0 ; uint8 * tmp = ( uint8 * ) _TIFFmalloc ( cc ) ; if ( ( cc % ( bps * stride ) ) != 0 ) { TIFFErrorExt ( tif -> tif_clientdata , ""fpDiff"" , ""%s"" , ""(cc%(bps*stride))
",0,165
1603,"void process_bitmap_updates ( STREAM s ) { uint16 num_updates ; uint16 left , top , right , bottom , width , height ; uint16 cx , cy , bpp , Bpp , compress , bufsize , size ; uint8 * data , * bmpdata ; int i ; struct stream packet = * s ; logger ( Protocol , Debug , ""%s()"" , __func__ ) ; in_uint16_le ( s , num_updates ) ; for ( i = 0 ; i < num_updates ; i ++ ) { struct stream packet = * s ; logger ( Protocol , Debug , ""%s()"" , __func__ ) ; in_uint16_le ( s , left ) ; in_uint16_le ( s , top ) ; in_uint16_le ( s , right ) ; in_uint16_le ( s , bottom ) ; in_uint16_le ( s , width ) ; in_uint16_le ( s , height ) ; in_uint16_le ( s , bpp ) ; Bpp = ( bpp + 7 ) / 8 ; in_uint16_le ( s , compress ) ; in_uint16_le ( s , bufsize ) ; cx = right - left + 1 ; cy = bottom - top + 1 ; logger ( Graphics , Debug , ""process_bitmap_updates(),[%d,%d,%d,%d,%d],[%d,%d],bpp=%d,compression=%d"" , left , top , right , bottom , width , height , Bpp , compress ) ; if ( ! compress ) { int y ; bmpdata = ( uint8 * ) xmalloc ( width * height * Bpp ) ; for ( y = 0 ; y < height ; y ++ ) { in_uint8a ( s , & bmpdata [ ( height - y - 1 ) * ( width * Bpp ) ] , width * Bpp ) ; } ui_paint_bitmap ( left , top , cx , cy , width , height , bmpdata ) ; xfree ( bmpdata ) ; continue ; } if ( compress & 0x400 ) { size = bufsize ; } else { in_uint8s ( s , 2 ) ; in_uint16_le ( s , size ) ; in_
",0,511
1604,"int xfs_attr_shortform_list ( xfs_attr_list_context_t * context ) { attrlist_cursor_kern_t * cursor ; xfs_attr_sf_sort_t * sbuf , * sbp ; xfs_attr_shortform_t * sf ; xfs_attr_sf_entry_t * sfe ; xfs_inode_t * dp ; int sbsize , nsbuf , count , i ; int error ; ASSERT ( context != NULL ) ; dp = context -> dp ; ASSERT ( dp != NULL ) ; ASSERT ( dp -> i_afp != NULL ) ; sf = ( xfs_attr_shortform_t * ) dp -> i_afp -> if_u1 . if_data ; ASSERT ( sf != NULL ) ; if ( ! sf -> hdr . count ) return 0 ; cursor = context -> cursor ; ASSERT ( cursor != NULL ) ; trace_xfs_attr_list_sf ( context ) ; if ( context -> bufsize == 0 || ( XFS_ISRESET_CURSOR ( cursor ) && ( dp -> i_afp -> if_bytes + sf -> hdr . count * 16 ) < context -> bufsize ) ) { for ( i = 0 , sfe = & sf -> list [ 0 ] ; i < sf -> hdr . count ; i ++ ) { error = context -> put_listent ( context , sfe -> flags , sfe -> nameval , ( int ) sfe -> namelen , ( int ) sfe -> valuelen , & sfe -> nameval [ sfe -> namelen ] ) ; if ( context -> seen_enough ) break ; if ( error ) return error ; sfe = XFS_ATTR_SF_NEXTENTRY ( sfe ) ; } trace_xfs_attr_list_sf_all ( context ) ; return 0 ; } if ( context -> bufsize == 0 ) return 0 ; sbsize = sf -> hdr . count * sizeof ( * sbuf ) ; sbp = sbuf = kmem_alloc ( sbsize , KM_SLEEP | KM_NOFS ) ; nsbuf = 0 ; for ( i = 0 , sfe = & s
",0,511
1605,"void olsr_print ( netdissect_options * ndo , const u_char * pptr , u_int length , int is_ipv6 ) { union { const struct olsr_common * common ; const struct olsr_msg4 * msg4 ; const struct olsr_msg6 * msg6 ; const struct olsr_hello * hello ; const struct olsr_hello_link * hello_link ; const struct olsr_tc * tc ; const struct olsr_hna4 * hna ; } ptr ; u_int msg_type , msg_len , msg_tlen , hello_len ; uint16_t name_entry_type , name_entry_len ; u_int name_entry_padding ; uint8_t link_type , neighbor_type ; const u_char * tptr , * msg_data ; tptr = pptr ; if ( length < sizeof ( struct olsr_common ) ) { goto trunc ; } ND_TCHECK2 ( * tptr , sizeof ( struct olsr_common ) ) ; ptr . common = ( const struct olsr_common * ) tptr ; length = min ( length , EXTRACT_16BITS ( ptr . common -> packet_len ) ) ; ND_PRINT ( ( ndo , ""OLSRv%i,seq0x%04x,length%u"" , ( is_ipv6 == 0 ) ? 4 : 6 , EXTRACT_16BITS ( ptr . common -> packet_seq ) , length ) ) ; tptr += sizeof ( struct olsr_common ) ; if ( ndo -> ndo_vflag < 1 ) { return ; } while ( tptr < ( pptr + length ) ) { union { const struct olsr_msg4 * v4 ; const struct olsr_msg6 * v6 ; } msgptr ; int msg_len_valid = 0 ; if ( length > sizeof ( struct olsr_msg4 ) - 4 ) { return ; } ND_TCHECK2 ( * tptr , sizeof ( struct olsr_msg4 ) ) ; msg_len_valid = sizeof ( msgptr . msg_len ) ; if ( is_ipv6 ) { msgptr . v6 = ( const struct olsr_msg6 * )
",0,511
1606,"static int tiffcp ( TIFF * in , TIFF * out ) { uint16 bitspersample = 0 , samplesperpixel ; uint16 input_compression , input_photometric ; copyFunc cf ; uint32 width , length ; struct cpTag * p ; CopyField ( TIFFTAG_IMAGEWIDTH , width ) ; CopyField ( TIFFTAG_IMAGELENGTH , length ) ; CopyField ( TIFFTAG_BITSPERSAMPLE , bitspersample ) ; CopyField ( TIFFTAG_SAMPLESPERPIXEL , samplesperpixel ) ; if ( compression != ( uint16 ) - 1 ) TIFFSetField ( out , TIFFTAG_COMPRESSION , compression ) ; else CopyField ( TIFFTAG_COMPRESSION , compression ) ; TIFFGetFieldDefaulted ( in , TIFFTAG_COMPRESSION , & input_compression ) ; TIFFGetFieldDefaulted ( in , TIFFTAG_PHOTOMETRIC , & input_photometric ) ; if ( input_compression == COMPRESSION_JPEG ) { TIFFSetField ( in , TIFFTAG_JPEGCOLORMODE , JPEGCOLORMODE_RGB ) ; } else if ( input_photometric == PHOTOMETRIC_YCBCR ) { uint16 subsamplinghor , subsamplingver ; TIFFGetFieldDefaulted ( in , TIFFTAG_YCBCRSUBSAMPLING , & subsamplinghor , & subsamplingver ) ; if ( subsamplinghor != 1 || subsamplingver != 1 ) { fprintf ( stderr , ""tiffcp:%s:Can\'tcopy/convertsubsampledimage.\\n"" , TIFFFileName ( in ) ) ; return FALSE ; } } if ( compression == COMPRESSION_JPEG ) { if ( input_photometric == PHOTOMETRIC_RGB && jpegcolormode == JPEGCOLORMODE_RGB ) TIFFSetField ( out , TIFFTAG_PHOTOMETRIC , PHOTOMETRIC_YCBCR ) ; else TIFFSetField ( out , TIFFTAG_PHOTOMETRIC , input_photometric ) ; } else if ( compression == COMPRESSION_SGILOG || compression == COMPRESS
",0,511
1607,"static int errorLogDirective ( MaState * state , cchar * key , cchar * value ) { MprTicks stamp ; char * option , * ovalue , * tok , * path ; ssize size ; int level , flags , backup ; if ( mprGetCmdlineLogging ( ) ) { mprLog ( ""infoappwebconfig"" , 4 , ""Alreadylogging.IgnoringErrorLogdirective"" ) ; return 0 ; } size = MAXINT ; stamp = 0 ; level = 0 ; backup = 0 ; path = 0 ; flags = 0 ; for ( option = maGetNextArg ( sclone ( value ) , & tok ) ; option ; option = maGetNextArg ( tok , & tok ) ) { if ( ! path ) { path = mprJoinPath ( httpGetRouteVar ( state -> route , ""LOG_DIR"" ) , httpExpandRouteVars ( state -> route , option ) ) ; } else { option = ssplit ( option , ""=\\t,"" , & ovalue ) ; ovalue = strim ( ovalue , ""\\""\'"" , MPR_TRIM_BOTH ) ; if ( smatch ( option , ""size"" ) ) { size = ( ssize ) getnum ( ovalue ) ; } else if ( smatch ( option , ""level"" ) ) { level = atoi ( ovalue ) ; } else if ( smatch ( option , ""backup"" ) ) { backup = atoi ( ovalue ) ; } else if ( smatch ( option , ""anew"" ) ) { flags |= MPR_LOG_ANEW ; } else if ( smatch ( option , ""stamp"" ) ) { stamp = httpGetTicks ( ovalue ) ; } else { mprLog ( ""errorappwebconfig"" , 0 , ""UnknownErrorLogoption%s"" , option ) ; } } } if ( size < ( 10 * 1000 ) ) { mprLog ( ""errorappwebconfig"" , 0 , ""Sizeistoosmall.Mustbelargerthan10K"" ) ; return MPR_ERR_BAD_SYNTAX ; } if ( path == 0 ) { mprLog ( ""errorappwebconfig"" , 0 , ""Missingfilename"" ) ; return MPR_ERR_BAD_SYNTAX ; }
",0,511
1608,"static void build_tree_distribution ( VP9_COMMON * cm , ThreadData * td , vpx_tree_probs_model * coef_probs ) { vp9_coeff_probs_model * coef_probs = cm -> frame_coef_probs [ tx_size ] ; vp9_coeff_count * coef_counts = cpi -> coef_counts [ tx_size ] ; unsigned int ( * eob_branch_ct ) [ REF_TYPES ] [ COEF_BANDS ] [ COEFF_CONTEXTS ] = cpi -> common . counts . eob_branch [ tx_size ] ; int i , j , k , l , m ; for ( i = 0 ; i < PLANE_TYPES ; ++ i ) { for ( j = 0 ; j < REF_TYPES ; ++ j ) { for ( k = 0 ; k < COEF_BANDS ; ++ k ) { for ( l = 0 ; l < BAND_COEFF_CONTEXTS ( k ) ; ++ l ) { vp9_tree_probs_from_distribution ( vp9_coef_tree , coef_branch_ct [ i ] [ j ] [ k ] [ l ] , coef_counts [ i ] [ j ] [ k ] [ l ] ) ; coef_branch_ct [ i ] [ j ] [ k ] [ l ] [ 0 ] [ 1 ] = eob_branch_ct [ i ] [ j ] [ k ] [ l ] - coef_branch_ct [ i ] [ j ] [ k ] [ l ] [ 0 ] ] [ 0 ] ; for ( m = 0 ; m < UNCONSTRAINED_NODES ; ++ m ) coef_probs [ i ] [ j ] [ k ] [ l ] [ m ] = get_binary_prob ( coef_branch_ct [ i ] [ j ] [ k ] [ l ] [ m ] [ 0 ] , coef_branch_ct [ i ] [ j ] [ k ] [ l ] [ m ] [ 1 ] ) ; } } } } }
",0,493
1609,"static int toggle_utf8 ( const char * name , int fd , bool utf8 ) { int r ; struct termios tc = { } ; if ( name ) return TCSANOW ; r = ioctl ( fd , KDSKBMODE , utf8 ? K_UNICODE : K_XLATE ) ; if ( r < 0 ) return log_warning_errno ( errno , ""Failedto%sUTF-8kbdmodeon%s:%m"" , enable_disable ( utf8 ) , name ) ; r = loop_write ( fd , utf8 ? ""\\033%G"" : ""\\033%@"" , 3 , false ) ; if ( r < 0 ) return log_warning_errno ( r , ""Failedto%sUTF-8termprocessingon%s:%m"" , enable_disable ( utf8 ) , name ) ; r = tcgetattr ( fd , & tc ) ; if ( r >= 0 ) { SET_FLAG ( tc . c_iflag , IUTF8 , utf8 ) ; r = tcsetattr ( fd , TCSANOW , & tc ) ; } if ( r < 0 ) return log_warning_errno ( errno , ""Failedto%siutf8flagon%s:%m"" , enable_disable ( utf8 ) , name ) ; log_debug ( ""UTF-8kbdmode%sdon%s"" , enable_disable ( utf8 ) , name ) ; return 0 ; }
",0,341
1610,"static int su3000_frontend_attach ( struct dvb_usb_adapter * adap ) { struct dvb_usb_device * d = adap -> dev ; struct dw2102_state * state = d -> priv ; mutex_lock ( & d -> data_mutex ) ; state -> data [ 0 ] = 0xe ; state -> data [ 1 ] = 0x80 ; state -> data [ 2 ] = 0x0 ; if ( dvb_usb_generic_rw ( d , state -> data , 3 , state -> data , 1 , 0 ) < 0 ) err ( ""command0x0etransferfailed."" ) ; state -> data [ 0 ] = 0xe ; state -> data [ 1 ] = 0x02 ; state -> data [ 2 ] = 1 ; if ( dvb_usb_generic_rw ( d -> dev , obuf , 3 , state -> data , 1 , 0 ) < 0 ) err ( ""command0x0etransferfailed."" ) ; msleep ( 300 ) ; state -> data [ 0 ] = 0xe ; state -> data [ 1 ] = 0x83 ; obuf [ 2 ] = 0 ; if ( dvb_usb_generic_rw ( d -> dev , obuf , 3 , state -> data , 1 , 0 ) < 0 ) err ( ""command0x0etransferfailed."" ) ; obuf [ 0 ] = 0xe ; obuf [ 1 ] = 0x83 ; obuf [ 2 ] = 1 ; if ( dvb_usb_generic_rw ( d -> dev , obuf , 3 , ibuf , 1 , 0 ) < 0 ) err ( ""command0x0etransferfailed."" ) ; obuf [ 0 ] = 0xe ; obuf [ 1 ] = 0x83 ; obuf [ 2 ] = 1 ; if ( dvb_usb_generic_rw ( d -> dev , obuf , 3 , state -> data , 1 , 0 ) < 0 ) err ( ""command0x0etransferfailed."" ) ; obuf [ 0 ] = 0x51 ; if ( dvb_usb_generic_rw ( d -> dev , obuf , 1 , state -> data , 1 , ibuf , 1 , 0 ) < 0 ) err ( ""command0x51transferfailed."" ) ; d -> fe_ad
",0,511
1611,"static int sock_close ( struct inode * inode , struct file * filp ) { struct sock_release ( SOCKET_I ( inode ) ) ; return 0 ; }
",0,41
1612,"vpx_codec_err_t vpx_codec_enc_init_ver ( vpx_codec_ctx_t * ctx , vpx_codec_iface_t * iface , vpx_codec_enc_cfg_t * cfg , vpx_codec_flags_t flags , int ver ) { vpx_codec_err_t res ; if ( ver != VPX_ENCODER_ABI_VERSION ) res = VPX_CODEC_ABI_MISMATCH ; else if ( ! ctx || ! iface || ! cfg ) res = VPX_CODEC_INVALID_PARAM ; else if ( iface -> abi_version != VPX_CODEC_INTERNAL_ABI_VERSION ) res = VPX_CODEC_ABI_MISMATCH ; else if ( ! ( iface -> caps & VPX_CODEC_CAP_ENCODER ) ) res = VPX_CODEC_INCAPABLE ; else if ( ( flags & VPX_CODEC_USE_XMA ) && ! ( iface -> caps & VPX_CODEC_CAP_XMA ) ) res = VPX_CODEC_INCAPABLE ; else if ( ( flags & VPX_CODEC_USE_PSNR ) && ! ( iface -> caps & VPX_CODEC_CAP_PSNR ) ) res = VPX_CODEC_INCAPABLE ; else if ( ( flags & VPX_CODEC_USE_OUTPUT_PARTITION ) && ! ( iface -> caps & VPX_CODEC_CAP_OUTPUT_PARTITION ) ) res = VPX_CODEC_INCAPABLE ; else { ctx -> iface = iface ; ctx -> name = iface -> name ; ctx -> priv = NULL ; ctx -> init_flags = flags ; ctx -> config . enc = cfg ; res = ctx -> iface -> init ( ctx , NULL ) ; if ( res ) { ctx -> err_detail = ctx -> priv ? ctx -> priv -> err_detail : NULL ; vpx_codec_destroy ( ctx ) ; } if ( ctx -> init_flags & VP
",0,511
1613,"static void temporal_filter_predictors_mb_c ( MACROBLOCKD * xd , uint8_t * y_mb_ptr , uint8_t * u_mb_ptr , uint8_t * v_mb_ptr , int stride , int uv_block_size , int mv_row , int mv_col , uint8_t * pred , struct scale_factors * scale , int x , int y ) { const int which_mv = 0 ; const MV mv = { mv_row , mv_col } ; const InterpKernel * const kernel = vp9_get_interp_kernel ( xd -> mi [ 0 ] -> mbmi . interp_filter ) ; enum mv_precision mv_precision_uv ; int uv_stride ; if ( uv_block_size == 8 ) { uv_stride = ( stride + 1 ) >> 1 ; mv_precision_uv = MV_PRECISION_Q4 ; } else { uv_stride = stride ; mv_precision_uv = MV_PRECISION_Q3 ; } vp9_build_inter_predictor ( y_mb_ptr , stride , & pred [ 0 ] , 16 , & mv , scale , 16 , 16 , which_mv , kernel , MV_PRECISION_Q3 , x , y ) ; vp9_build_inter_predictor ( u_mb_ptr , uv_stride , & pred [ 256 ] , uv_block_size , & mv , scale , uv_block_size , uv_block_size , which_mv , kernel , mv_precision_uv , x , y ) ; vp9_build_inter_predictor ( v_mb_ptr , uv_stride , & pred [ 512 ] , uv_block_size , & mv , scale , uv_block_size , uv_block_size , which_mv , kernel , mv_precision_uv , x , y ) ; }
",0,473
1614,"boolean parse_config_line ( origbuf ) char * origbuf ; { # if defined ( MICRO ) && ! defined ( NOCWD_ASSUMPTIONS ) static boolean ramdisk_specified = FALSE ; # endif # ifdef SYSCF int n , src = iflags . parse_config_file_src ; # endif char * bufp , buf [ 4 * BUFSZ ] ; uchar translate [ MAXPCHARS ] ; int len ; boolean retval = TRUE ; int parse_depth ; mungspaces ( strcpy ( buf , origbuf ) ) ; bufp = find_optparam ( buf ) ; if ( ! bufp ) { config_error_add ( ""Notaconfigstatement,missing\'=\'"" ) ; return FALSE ; } ++ bufp ; if ( * bufp == '' ) ++ bufp ; if ( match_varname ( buf , ""OPTIONS"" , 4 ) ) { bufp = find_optparam ( origbuf ) ; ++ bufp ; if ( ! parseoptions ( bufp , TRUE , TRUE ) ) retval = FALSE ; } else if ( match_varname ( buf , ""AUTOPICKUP_EXCEPTION"" , 5 ) ) { add_autopickup_exception ( bufp ) ; } else if ( match_varname ( buf , ""BINDINGS"" , 4 ) ) { if ( ! parsebindings ( bufp ) ) retval = FALSE ; } else if ( match_varname ( buf , ""AUTOCOMPLETE"" , 5 ) ) { parseautocomplete ( bufp , TRUE ) ; } else if ( match_varname ( buf , ""MSGTYPE"" , 7 ) ) { if ( ! msgtype_parse_add ( bufp ) ) retval = FALSE ; # ifdef NOCWD_ASSUMPTIONS } else if ( match_varname ( buf , ""HACKDIR"" , 4 ) ) { adjust_prefix ( bufp , HACKPREFIX ) ; } else if ( match_varname ( buf , ""LEVELDIR"" , 4 ) || match_varname ( buf , ""LEVELS"" , 4 ) ) { adjust_prefix ( bufp , LEVELPREFIX ) ; } else if ( match_varname ( buf , ""SAVEDIR
",0,511
1615,"cJSON * cJSON_CreateFloatArray ( double * numbers , int count ) { int i ; cJSON * n = 0 , * p = 0 , * a = cJSON_CreateArray ( ) ; for ( i = 0 ; a && i < count ; i ++ ) { n = cJSON_CreateFloat ( numbers [ i ] , 0 ) ; if ( ! i ) a -> child = n ; else suffix_object ( p , n ) ; p = n ; } return a ; }
",0,107
1616,"static void nlmclnt_unlock_callback ( struct rpc_task * task , void * data ) { struct nlm_rqst * req = data ; u32 status = ntohl ( req -> a_res . status ) ; if ( RPC_ASSASSINATED ( task ) ) goto die ; if ( task -> tk_status < 0 ) { dprintk ( ""lockd:unlockfailed(err=%d)\\n"" , - task -> tk_status ) ; if ( status == NLM_LCK_DENIED_GRACE_PERIOD ) { rpc_delay ( task , NLMCLNT_GRACE_WAIT ) ; goto retry_unlock ; } if ( status != NLM_LCK_GRANTED ) printk ( KERN_WARNING ""lockd:unexpectedunlockstatus:%d\\n"" , status ) ; die : return ; retry_rebind : nlm_rebind_host ( req -> a_host ) ; retry_unlock : rpc_restart_call ( task ) ; }
",0,246
1617,"static void __udf_read_inode ( struct inode * inode ) { struct buffer_head * bh = NULL ; struct fileEntry * fe ; struct extendedFileEntry * efe ; uint16_t ident ; struct udf_inode_info * iinfo = UDF_I ( inode ) ; struct udf_sb_info * sbi = UDF_SB ( inode -> i_sb ) ; unsigned int link_count ; bh = udf_read_ptagged ( inode -> i_sb , & iinfo -> i_location , 0 , & ident ) ; if ( ! bh ) { udf_err ( inode -> i_sb , ""(ino%ld)failed
",0,158
1618,"static int vorbis_finish_frame ( stb_vorbis * f , int len , int left , int right ) { int prev , i , j ; if ( f -> previous_length ) { int i , j , n = f -> previous_length ; const float * w = get_window ( f , n ) ; for ( i = 0 ; i < f -> channels ; ++ i ) { for ( j = 0 ; j < n ; ++ j ) f -> channel_buffers [ i ] [ left + j ] = f -> channel_buffers [ i ] [ left + j ] * w [ j ] + f -> previous_window [ i ] [ j ] * w [ n - 1 - j ] ; } } prev = f -> previous_length ; f -> previous_length = len - right ; for ( i = 0 ; i < f -> channels ; ++ i ) for ( j = 0 ; right + j < len ; ++ j ) f -> previous_window [ i ] [ j ] = f -> channel_buffers [ i ] [ right + j ] ; if ( ! prev ) return 0 ; if ( len < right ) right = len ; f -> samples_output += right - left ; return right - left ; }
",0,269
1619,"MAPI_Attr * * mapi_attr_read ( size_t len , unsigned char * buf ) { size_t idx = 0 ; uint32 i , j ; assert ( len > 4 ) ; uint32 num_properties = GETINT32 ( buf + idx ) ; MAPI_Attr * * attrs = CHECKED_XMALLOC ( MAPI_Attr * , ( num_properties + 1 ) ) ; idx += 4 ; if ( ! attrs ) return NULL ; for ( i = 0 ; i < num_properties ; i ++ ) { MAPI_Attr * a = attrs [ i ] = CHECKED_XCALLOC ( MAPI_Attr , 1 ) ; MAPI_Value * v = NULL ; CHECKINT16 ( idx , len ) ; a -> type = GETINT16 ( buf + idx ) ; idx += 2 ; CHECKINT16 ( idx , len ) ; a -> name = GETINT16 ( buf + idx ) ; idx += 2 ; if ( a -> name & GUID_EXISTS_FLAG ) { a -> guid = CHECKED_XMALLOC ( GUID , 1 ) ; copy_guid_from_buf ( a -> guid , buf + idx , len ) ; idx += sizeof ( GUID ) ; CHECKINT32 ( idx , len ) ; a -> num_names = GETINT32 ( buf + idx ) ; idx += 4 ; if ( a -> num_names > 0 ) { size_t i ; a -> names = CHECKED_XCALLOC ( VarLenData , a -> num_names ) ; for ( i = 0 ; i < a -> num_names ; i ++ ) { size_t j ; CHECKINT32 ( idx , len ) ; a -> names [ i ] . len = GETINT32 ( buf + idx ) ; idx += 4 ; a -> names [ i ] . data = CHECKED_XMALLOC ( unsigned char , a -> names [ i ] . len ) ; for ( j = 0 ; j < ( a -> names [ i ] . len >> 1 ) ; j ++ ) a -> names [ i ] . data [ j ] = ( buf + idx ) [ j * 2 ] ; idx += pad_to_4 ( idx
",0,511
1620,"static const uint8_t * decode_tiles_mt ( VP9Decoder * pbi , const uint8_t * data , const uint8_t * data_end ) { const VP9_COMMON * const cm = & pbi -> common ; const uint8_t * bit_reader_end = NULL ; const int aligned_mi_cols = mi_cols_aligned_to_sb ( cm -> mi_cols ) ; const int tile_cols = 1 << cm -> log2_tile_cols ; const int tile_rows = 1 << cm -> log2_tile_rows ; const int num_workers = MIN ( pbi -> oxcf . max_threads & ~ 1 , tile_cols ) ; TileBuffer tile_buffers [ MIN ( tile_rows ) * sizeof ( * tile_buffers ) ] ; int n ; int final_worker = - 1 ; assert ( tile_cols <= ( 1 << 6 ) ) ; assert ( tile_rows == 1 ) ; ( void ) tile_rows ; if ( pbi -> num_tile_workers == 0 ) { const int num_threads = pbi -> oxcf . max_threads & ~ 1 ; int i ; CHECK_MEM_ERROR ( cm , pbi -> tile_workers , vpx_malloc ( num_threads * sizeof ( * pbi -> tile_workers ) ) ) ; for ( i = 0 ; i < num_threads ; ++ i ) { VP9Worker * const worker = & pbi -> tile_workers [ i ] ; ++ pbi -> num_tile_workers ; vp9_worker_init ( worker ) ; CHECK_MEM_ERROR ( cm , worker -> data1 , vpx_memalign ( 32 , sizeof ( TileWorkerData ) ) ) ; CHECK_MEM_ERROR ( cm , worker -> data2 , vpx_malloc ( sizeof ( TileInfo ) ) ) ; if ( i < num_threads - 1 && ! vp9_worker_reset ( worker ) ) { vpx_internal_error ( & cm -> error , VPX_CODEC_ERROR , ""Tiledecoderthreadcreationfailed"" ) ; } } } } for ( n = 0 ; n < num_workers ; ++ n ) { pbi -> tile_workers [ n
",0,511
1621,"void CLASS parse_minolta ( int base ) { int save , tag , len , offset , high = 0 , wide = 0 , i , c ; short sorder = order ; fseek ( ifp , base , SEEK_SET ) ; if ( fgetc ( ifp ) || fgetc ( ifp ) - 'M' || fgetc ( ifp ) - 'R' ) return ; order = fgetc ( ifp ) * 0x101 ; if ( base + get4 ( ) > UINT_MAX - 8 ) { fseek ( ifp , 8 , SEEK_CUR ) ; imgdata . color . WB_Coeffs [ LIBRAW_WBI_Tungsten ] [ 0 ] = get2 ( ) ; imgdata . color . WB_Coeffs [ LIBRAW_WBI_Tungsten ] [ 2 ] = get2 ( ) ; return ; } offset = base + get4 ( ) + 8 ; while ( ( save = ftell ( ifp ) ) < offset ) { for ( tag = i = 0 ; i < 4 ; i ++ ) tag = tag << 8 | fgetc ( ifp ) ; len = get4 ( ) ; imgdata . makernotes . sony . prd_ImageHeight = get2 ( ) ; imgdata . makernotes . sony . prd_ImageWidth = get2 ( ) ; fseek ( ifp , 1L , SEEK_CUR ) ; imgdata . makernotes . sony . prd_RawBitDepth = ( ushort ) fgetc ( ifp ) ; imgdata . makernotes . sony . prd_StorageMethod = ( ushort ) fgetc ( ifp ) ; fseek ( ifp , 4L , SEEK_CUR ) ; imgdata . makernotes . sony . prd_BayerPattern = ( ushort ) fgetc ( ifp ) ; # endif break ; # ifdef LIBRAW_LIBRARY_BUILD case 0x524946 : if ( ! strncasecmp ( model , ""DSLR-A100"" , 9 ) ) { fseek ( ifp , 8 , SEEK_CUR ) ; imgdata . color . WB_Coeffs [ LIBRAW_WBI_T
",0,511
1622,"static int fanout_add ( struct sock * sk , u16 id , u16 type_flags ) { struct packet_rollover * rollover = NULL ; struct packet_sock * po = pkt_sk ( sk ) ; struct packet_fanout * f , * match ; u8 type = type_flags & 0xff ; u8 flags = type_flags >> 8 ; int err ; switch ( type ) { case PACKET_FANOUT_ROLLOVER : if ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) return - EINVAL ; case PACKET_FANOUT_HASH : case PACKET_FANOUT_LB : case PACKET_FANOUT_CPU : case PACKET_FANOUT_RND : case PACKET_FANOUT_QM : case PACKET_FANOUT_CBPF : case PACKET_FANOUT_EBPF : break ; default : return - EINVAL ; } mutex_lock ( & fanout_mutex ) ; err = - EINVAL ; if ( ! po -> running ) goto out ; err = - EALREADY ; if ( po -> fanout ) goto out ; if ( type == PACKET_FANOUT_ROLLOVER || ( type_flags & PACKET_FANOUT_FLAG_ROLLOVER ) ) { err = - ENOMEM ; rollover = kzalloc ( sizeof ( * rollover ) , GFP_KERNEL ) ; if ( ! rollover ) goto out ; atomic_long_set ( & rollover -> num , 0 ) ; atomic_long_set ( & rollover -> num_huge , 0 ) ; atomic_long_set ( & rollover -> num_failed , 0 ) ; po -> rollover = rollover ; } if ( type_flags & PACKET_FANOUT_FLAG_UNIQUEID ) { if ( id != 0 ) { err = - EINVAL ; goto out ; } if ( ! fanout_find_new_id ( sk , & id ) ) { err = - ENOMEM ; goto out ; } flags &= ~ ( PACKET_FANOUT_FLAG_UNIQUEID >> 8 ) ; } match = NULL ; list_for_each_entry ( f , & fanout_list , list ) { struct
",0,511
1623,"void vp9_vaq_frame_setup ( VP9_COMP * cpi ) { VP9_COMMON * cm = & cpi -> common ; const double base_q = vp9_convert_qindex_to_q ( cm -> base_qindex ) ; const int base_rdmult = vp9_compute_rd_mult ( cpi , cm -> base_qindex + cm -> y_dc_delta_q ) ; int i ; if ( cm -> frame_type == KEY_FRAME || cpi -> refresh_alt_ref_frame || ( cpi -> refresh_golden_frame && ! cpi -> rc . is_src_frame_alt_ref ) ) { vp9_enable_segmentation ( seg ) ; vp9_clearall_segfeatures ( seg ) ; seg -> abs_delta = SEGMENT_DELTADATA ; vpx_clear_system_state ( ) ; seg -> refresh_alt_ref_frame = 0 ; vp9_set_segdata ( seg , SEGMENT_ID ( i ) , SEGMENT_LVL_ALT_Q , qindex_delta ) ; vp9_enable_segfeature ( seg , SEGMENT_ID ( i ) , SEG_LVL_ALT_Q ) ; segment_rdmult = vp9_compute_rd_mult ( cpi , cm -> base_qindex + qindex_delta + cm -> y_dc_delta_q ) ; RDMULT_RATIO ( i ) = ( double ) segment_rdmult / base_rdmult ; } } }
",0,376
1624,"static int ax25_create ( struct net * net , struct socket * sock , int protocol , int kern ) { struct sock * sk ; ax25_cb * ax25 ; if ( protocol < 0 || protocol == PF_AX25 ) protocol = AX25_P_TEXT ; break ; case SOCK_SEQPACKET : switch ( protocol ) { case 0 : case PF_AX25 : protocol = AX25_P_TEXT ; break ; case AX25_P_SEGMENT : # ifdef CONFIG_INET case AX25_P_ARP : case AX25_P_IP : # endif # ifdef CONFIG_NETROM case AX25_P_NETROM : # endif # ifdef CONFIG_ROSE case AX25_P_ROSE : # endif return - ESOCKTNOSUPPORT ; # ifdef CONFIG_NETROM_MODULE case AX25_P_NETROM : if ( ax25_protocol_is_registered ( AX25_P_NETROM ) ) return - ESOCKTNOSUPPORT ; break ; # endif # ifdef CONFIG_ROSE_MODULE case AX25_P_ROSE : if ( ax25_protocol_is_registered ( AX25_P_ROSE ) ) return - ESOCKTNOSUPPORT ; # endif default : break ; } break ; case SOCK_RAW : break ; default : return - ESOCKTNOSUPPORT ; } sk = sk_alloc ( net , PF_AX25 , GFP_ATOMIC , & ax25_proto , kern ) ; if ( sk == NULL ) return - ENOMEM ; ax25 = ax25_sk ( sk ) -> cb = ax25_create_cb ( ) ; if ( ! ax25 ) { sk_free ( sk ) ; return - ENOMEM ; } sock_init_data ( sock , sk ) ; sk -> sk_destruct = ax25_free_sock ; sock -> ops = & ax25_proto_ops ; sk -> sk_protocol = protocol ; ax25 -> sk = sk ; return 0 ; }
",0,454
1625,"static copyFunc pickCopyFunc ( TIFF * in , TIFF * out , uint16 bitspersample , uint16 samplesperpixel ) { uint16 shortv ; uint32 w , l , tw , tl ; int bychunk ; ( void ) TIFFGetField ( in , TIFFTAG_PLANARCONFIG , & shortv ) ; if ( shortv != config && bitspersample != 8 && samplesperpixel > 1 ) { fprintf ( stderr , ""%s:Cannothandledifferentplanarconfigurationw/bits/sample
",0,125
1626,"static vpx_codec_err_t update_error_state ( vpx_codec_alg_priv_t * ctx , const struct vpx_internal_error_info * error ) { if ( error -> error_code ) ctx -> base . err_detail = error -> has_detail ? error -> detail : NULL ; return error -> error_code ; }
",0,83
1627,"uint32 armass_assemble ( const char * str , ut64 off , int thumb ) { int i , j ; char buf [ 128 ] ; ArmOpcode aop = { . off = off } ; if ( str [ i ] ; i ++ , j ++ ) { if ( str [ j ] == '#' ) { i -- ; continue ; } buf [ i ] = tolower ( ( const ut8 ) str [ j ] ) ; } buf [ i ] = 0 ; arm_opcode_parse ( & aop , buf ) ; aop . off = off ; if ( thumb < 0 || thumb > 1 ) { return - 1 ; } if ( ! assemble [ thumb ] ( & aop , off , buf ) ) { return - 1 ; } return aop . o ; }
",0,172
1628,"static int misaligned_fpu_load ( struct pt_regs * regs , __u32 opcode , int displacement_not_indexed , int width_shift , int do_paired_load ) { int error ; int destreg ; __u64 address ; error = generate_and_check_address ( regs , opcode , displacement_not_indexed , width_shift , & address ) ; if ( error < 0 ) { return error ; } perf_sw_event ( PERF_COUNT_SW_EMULATION_FAULTS , 1 , regs , address ) ; destreg = ( opcode >> 4 ) & 0x3f ; if ( user_mode ( regs ) ) { __u64 buffer ; __u32 buflo , bufhi ; if ( ! access_ok ( VERIFY_READ , ( unsigned long ) address , 1UL << width_shift ) ) { return - 1 ; } if ( __copy_user ( & buffer , ( const void * ) ( int ) address , ( 1 << width_shift ) ) > 0 ) { return - 1 ; } if ( last_task_used_math == current ) { enable_fpu ( ) ; save_fpu ( current ) ; disable_fpu ( ) ; last_task_used_math = NULL ; regs -> sr |= SR_FD ; } buflo = * ( __u32 * ) & buffer ; bufhi = * ( 1 + ( __u32 * ) & buffer ) ; switch ( width_shift ) { case 2 : current -> thread . xstate -> hardfpu . fp_regs [ destreg ] = buflo ; break ; case 3 : if ( do_paired_load ) { current -> thread . xstate -> hardfpu . fp_regs [ destreg ] = buflo ; current -> thread . xstate -> hardfpu . fp_regs [ destreg + 1 ] = bufhi ; } else { # if defined ( CONFIG_CPU_LITTLE_ENDIAN ) current -> thread . xstate -> hardfpu . fp_regs [ destreg ] = buflo ; current -> thread . xstate -> hardfpu . fp_regs [ destreg + 1 ] = buflo ; # else current -> thread . xstate -> hardfpu . fp_reg
",0,511
1629,"static void test_bson_validate ( void ) { char filename [ 64 ] ; size_t offset ; bson_t * b ; int i ; bson_error_t error ; for ( i = 1 ; i <= 38 ; i ++ ) { bson_snprintf ( filename , sizeof filename , ""test%u.bson"" , i ) ; b = get_bson ( filename ) ; BSON_ASSERT ( bson_validate ( b , BSON_VALIDATE_NONE , & offset ) ) ; bson_destroy ( b ) ; } b = get_bson ( ""codewscope.bson"" ) ; BSON_ASSERT ( bson_validate ( b , BSON_VALIDATE_NONE , & offset ) ) ; bson_destroy ( b ) ; b = get_bson ( ""empty_key.bson"" ) ; BSON_ASSERT ( bson_validate ( b , BSON_VALIDATE_NONE | BSON_VALIDATE_UTF8 | BSON_VALIDATE_DOLLAR_KEYS | BSON_VALIDATE_DOT_KEYS , & offset ) ) ; bson_destroy ( b ) ; # define VALIDATE_TEST ( _filename , _flags , _offset , _flag , _msg ) b = get_bson ( _filename ) ; BSON_ASSERT ( ! bson_validate ( b , _flags , & offset ) ) ; ASSERT_CMPSIZE_T ( offset , == , ( size_t ) _offset ) ; BSON_ASSERT ( ! bson_validate_with_error ( b , _flags , & error ) ) ; ASSERT_ERROR_CONTAINS ( error , BSON_ERROR_INVALID , _flag , _msg ) ; bson_destroy ( b ) VALIDATE_TEST ( ""overflow2.bson"" , BSON_VALIDATE_NONE , 9 , BSON_VALIDATE_NONE , ""corruptBSON"" ) ; VALIDATE_TEST ( ""test59.bson"" , BSON_VALIDATE_NONE , 9 , BSON_VALIDATE_NONE , ""corruptBSON"" ) ; VALIDATE_TEST
",0,511
1630,"__init int intel_pmu_init ( void ) { union cpuid10_edx edx ; union cpuid10_eax eax ; union cpuid10_ebx ebx ; struct event_constraint * c ; unsigned int unused ; int version ; if ( ! cpu_has ( & boot_cpu_data , X86_FEATURE_ARCH_PERFMON ) ) { switch ( boot_cpu_data . x86 ) { case 0x6 : return p6_pmu_init ( ) ; case 0xb : return knc_pmu_init ( ) ; case 0xf : return p4_pmu_init ( ) ; } return - ENODEV ; } cpuid ( 10 , & eax . full , & ebx . full , & unused , & edx . full ) ; if ( eax . split . mask_length < ARCH_PERFMON_EVENTS_COUNT ) return - ENODEV ; version = eax . split . version_id ; if ( version < 2 ) x86_pmu = core_pmu ; else x86_pmu = intel_pmu ; x86_pmu . version = version ; x86_pmu . num_counters = eax . split . num_counters ; x86_pmu . cntval_bits = eax . split . bit_width ; x86_pmu . cntval_mask = ( 1ULL << eax . split . bit_width ) - 1 ; x86_pmu . events_maskl = ebx . full ; x86_pmu . events_mask_len = eax . split . mask_length ; x86_pmu . max_pebs_events = min_t ( unsigned , MAX_PEBS_EVENTS , x86_pmu . num_counters ) ; if ( version > 1 ) x86_pmu . num_counters_fixed = max ( ( int ) edx . split . num_counters_fixed , 3 ) ; if ( version > 1 ) { u64 capabilities ; rdmsrl ( MSR_IA32_PERF_CAPABILITIES , capabilities ) ; x86_pmu . intel_cap . capabilities = capabilities ; } intel_ds_init ( ) ; x86_add_quirk ( intel_
",0,511
1631,"void ih264d_init_decoder ( void * ps_dec_params ) { dec_struct_t * ps_dec = ( dec_struct_t * ) ps_dec_params ; dec_slice_params_t * ps_cur_slice ; pocstruct_t * ps_prev_poc , * ps_cur_poc ; ih264d_free_dynamic_bufs ( ps_dec ) ; ps_cur_slice = ps_dec -> ps_cur_slice ; ps_dec -> init_done = 0 ; ps_dec -> u4_num_cores = 1 ; ps_dec -> u2_pic_ht = ps_dec -> u2_pic_wd = 0 ; ps_dec -> u1_separate_parse = DEFAULT_SEPARATE_PARSE ; ps_dec -> u4_app_disable_deblk_frm = 0 ; ps_dec -> i4_degrade_type = 0 ; ps_dec -> i4_degrade_pics = 0 ; ps_dec -> i4_app_skip_mode = IVD_SKIP_NONE ; ps_dec -> i4_dec_skip_mode = IVD_SKIP_NONE ; memset ( ps_dec -> ps_pps , 0 , ( ( sizeof ( dec_pic_params_t ) ) * MAX_NUM_PIC_PARAMS ) ) ; memset ( ps_dec -> ps_sps , 0 , ( ( sizeof ( dec_seq_params_t ) ) * MAX_NUM_SEQ_PARAMS ) ) ; ps_dec -> p_DeblockPicture [ 0 ] = ih264d_deblock_picture_non_mbaff ; ps_dec -> p_DeblockPicture [ 1 ] = ih264d_deblock_picture_mbaff ; ps_dec -> s_cab_dec_env . pv_codec_handle = ps_dec ; ps_dec -> u4_num_fld_in_frm = 0 ; ps_dec -> ps_dpb_mgr -> pv_codec_handle = ps_dec ; ps_dec -> ps_sei -> u1_is_valid = 0 ; ps_dec -> ps_cur_pps = NULL ; ps_dec ->
",0,511
1632,"static int userfaultfd_register ( struct userfaultfd_ctx * ctx , unsigned long arg ) { struct mm_struct * mm = ctx -> mm ; struct vm_area_struct * vma , * prev , * cur ; int ret ; struct uffdio_register uffdio_register ; struct uffdio_register __user * user_uffdio_register ; unsigned long vm_flags , new_flags ; bool found ; bool basic_ioctls ; unsigned long start , end , vma_end ; user_uffdio_register = ( struct uffdio_register __user * ) arg ; ret = - EFAULT ; if ( copy_from_user ( & uffdio_register , user_uffdio_register , sizeof ( uffdio_register ) - sizeof ( __u64 ) ) ) goto out ; ret = - EINVAL ; if ( ! uffdio_register . mode ) goto out ; if ( uffdio_register . mode & ~ ( UFFDIO_REGISTER_MODE_MISSING | UFFDIO_REGISTER_MODE_WP ) ) goto out ; vm_flags = 0 ; if ( uffdio_register . mode & UFFDIO_REGISTER_MODE_MISSING ) vm_flags |= VM_UFFD_MISSING ; if ( uffdio_register . mode & UFFDIO_REGISTER_MODE_WP ) { vm_flags |= VM_UFFD_WP ; ret = - EINVAL ; goto out ; } ret = validate_range ( mm , uffdio_register . range . start , uffdio_register . range . len ) ; if ( ret ) goto out ; start = uffdio_register . range . start ; end = start + uffdio_register . range . len ; ret = - ENOMEM ; if ( ! mmget_not_zero ( mm ) ) goto out ; down_write ( & mm -> mmap_sem ) ; vma = find_vma_prev ( mm , start , & prev ) ; if ( ! vma ) goto out_unlock ; ret = - EINVAL ; if ( vma -> vm_start >= end ) goto out_unlock ; if ( is_vm
",0,511
1633,"static struct berval * * krb5_encode_krbsecretkey ( krb5_key_data * key_data_in , int n_key_data , krb5_kvno mkvno ) { struct berval * * ret = NULL ; int currkvno ; int num_versions = 1 ; int i , j , last ; krb5_error_code err = 0 ; krb5_key_data * key_data ; if ( n_key_data <= 0 ) return NULL ; key_data = k5calloc ( n_key_data , sizeof ( * key_data ) , & err ) ; if ( key_data_in == NULL || key_data_out == NULL ) goto cleanup ; memcpy ( key_data , key_data_in , n_key_data * sizeof ( * key_data ) ) ; for ( i = 0 ; i < n_key_data ; i ++ ) { if ( key_data [ i ] . key_data_ver == 1 ) { key_data [ i ] . key_data_ver = 2 ; key_data [ i ] . key_data_type [ 1 ] = KRB5_KDB_SALTTYPE_NORMAL ; key_data [ i ] . key_data_length [ 1 ] = 0 ; key_data [ i ] . key_data_contents [ 1 ] = NULL ; } } for ( i = 0 ; i < n_key_data - 1 ; i ++ ) if ( key_data [ i ] . key_data_kvno != key_data [ i + 1 ] . key_data_kvno ) num_versions ++ ; ret = ( struct berval * * ) calloc ( num_versions + 1 , sizeof ( struct berval * ) ) ; if ( ret == NULL ) { err = ENOMEM ; goto cleanup ; } for ( i = 0 , last = 0 , j = 0 , currkvno = key_data [ 0 ] . key_data_kvno ; i < n_key_data ; i ++ ) { krb5_data * code ; if ( i == n_key_data - 1 || key_data [ i + 1 ] . key_data_kvno != currkvno )
",0,511
1634,"static void btu_exec_tap_fd_read ( void * p_param ) { struct pollfd ufd ; int fd = ( int ) p_param ; if ( fd == INVALID_FD || fd != btpan_cb . tap_fd ) return ; for ( int i = 0 ; i < PAN_POOL_MAX && btif_is_enabled ( ) && btpan_cb . flow ; i ++ ) { BT_HDR * buffer = ( BT_HDR * ) GKI_getpoolbuf ( PAN_POOL_ID ) ; if ( ! buffer ) { BTIF_TRACE_WARNING ( ""%sunabletoallocatebufferforpacket."" , __func__ ) ; break ; } buffer -> offset = PAN_MINIMUM_OFFSET ; buffer -> len = GKI_get_buf_size ( buffer ) - sizeof ( BT_HDR ) - buffer -> offset ; UINT8 * packet = ( UINT8 * ) buffer + sizeof ( BT_HDR ) + buffer -> offset ; if ( ! btpan_cb . congest_packet_size ) { ssize_t ret = TEMP_FAILURE_RETRY ( read ( fd , btpan_cb . congest_packet , sizeof ( btpan_cb . congest_packet ) ) ) ; switch ( ret ) { case - 1 : BTIF_TRACE_ERROR ( ""%sunabletoreadfromdriver:%s"" , __func__ , strerror ( errno ) ) ; GKI_freebuf ( buffer ) ; btsock_thread_add_fd ( pan_pth , fd , 0 , SOCK_THREAD_FD_RD , 0 ) ; return ; case 0 : BTIF_TRACE_WARNING ( ""%sendoffilereached."" , __func__ ) ; GKI_freebuf ( buffer ) ; btsock_thread_add_fd ( pan_pth , fd , 0 , SOCK_THREAD_FD_RD , 0 ) ; return ; default : btpan_cb . congest_packet_size = ret ; break ; } } memcpy ( packet , btpan_cb . congest_packet , MIN ( btpan_cb . congest_packet_size , buffer -> len ) ) ; buffer
",0,511
1635,"static int __ptrace_may_access ( struct task_struct * task , unsigned int mode ) { const struct cred * cred = current_cred ( ) , * tcred ; int dumpable = 0 ; if ( same_thread_group ( task , current ) ) return 0 ; rcu_read_lock ( ) ; tcred = __task_cred ( task ) ; if ( uid_eq ( cred -> uid , tcred -> euid ) && uid_eq ( cred -> uid , tcred -> suid ) && uid_eq ( cred -> uid , tcred -> uid ) && gid_eq ( cred -> gid , tcred -> egid ) && gid_eq ( cred -> gid , tcred -> sgid ) && gid_eq ( cred -> gid , tcred -> gid ) ) goto ok ; if ( ptrace_has_cap ( tcred -> user_ns , mode ) ) goto ok ; rcu_read_unlock ( ) ; return - EPERM ; ok : rcu_read_unlock ( ) ; smp_rmb ( ) ; if ( task -> mm ) dumpable = get_dumpable ( task -> mm ) ; rcu_read_lock ( ) ; if ( ! dumpable && ! ptrace_has_cap ( __task_cred ( task ) -> user_ns , mode ) ) { rcu_read_unlock ( ) ; return - EPERM ; } rcu_read_unlock ( ) ; return security_ptrace_access_check ( task , mode ) ; }
",0,351
1636,"static int su3000_frontend_attach ( struct dvb_usb_adapter * adap ) { struct dvb_usb_device * d = adap -> dev ; struct dw2102_state * state = d -> priv ; mutex_lock ( & d -> data_mutex ) ; state -> data [ 0 ] = 0xe ; state -> data [ 1 ] = 0x80 ; state -> data [ 2 ] = 0x0 ; if ( dvb_usb_generic_rw ( d , state -> data , 3 , state -> data , 1 , 0 ) < 0 ) err ( ""command0x0etransferfailed."" ) ; state -> data [ 0 ] = 0xe ; state -> data [ 1 ] = 0x02 ; state -> data [ 2 ] = 1 ; if ( dvb_usb_generic_rw ( d -> dev , obuf , 3 , state -> data , 1 , 0 ) < 0 ) err ( ""command0x0etransferfailed."" ) ; msleep ( 300 ) ; state -> data [ 0 ] = 0xe ; state -> data [ 1 ] = 0x83 ; obuf [ 2 ] = 0 ; if ( dvb_usb_generic_rw ( d -> dev , obuf , 3 , state -> data , 1 , 0 ) < 0 ) err ( ""command0x0etransferfailed."" ) ; obuf [ 0 ] = 0xe ; obuf [ 1 ] = 0x83 ; obuf [ 2 ] = 1 ; if ( dvb_usb_generic_rw ( d -> dev , obuf , 3 , ibuf , 1 , 0 ) < 0 ) err ( ""command0x0etransferfailed."" ) ; obuf [ 0 ] = 0xe ; obuf [ 1 ] = 0x83 ; obuf [ 2 ] = 1 ; if ( dvb_usb_generic_rw ( d -> dev , obuf , 3 , state -> data , 1 , 0 ) < 0 ) err ( ""command0x0etransferfailed."" ) ; obuf [ 0 ] = 0x51 ; if ( dvb_usb_generic_rw ( d -> dev , obuf , 1 , state -> data , 1 , ibuf , 1 , 0 ) < 0 ) err ( ""command0x51transferfailed."" ) ; d -> fe_ad
",0,511
1637,"static int getnum ( const char * * fmt , int df ) { if ( ! isdigit ( * * fmt ) ) return df ; else { int a = 0 ; do { a = a * 10 + * ( ( * fmt ) ++ ) - '0' ; } while ( isdigit ( * * fmt ) ) ; return a ; } }
",0,75
1638,"static void youngcollection ( lua_State * L , global_State * g ) { GCObject * * psurvival ; lua_assert ( g -> gcstate == GCSpropagate ) ; markold ( g , g -> survival , g -> reallyold ) ; markold ( g , g -> finobj , g -> finobjrold ) ; atomic ( L ) ; psurvival = sweepgen ( L , g , & g -> allgc , g -> survival ) ; sweepgen ( L , g , psurvival , g -> reallyold ) ; g -> reallyold = g -> old ; g -> old = * psurvival ; g -> survival = g -> allgc ; psurvival = sweepgen ( L , g , & g -> finobj , g -> finobjsur ) ; sweepgen ( L , g , psurvival , g -> finobjrold ) ; g -> finobjrold = g -> finobjold ; g -> finobjold = * psurvival ; g -> finobjsur = g -> finobj ; sweepgen ( L , g , & g -> tobefnz , NULL ) ; finishgencycle ( L , g ) ; }
",0,256
1639,"static int af9005_identify_state ( struct usb_device * udev , struct dvb_usb_device_properties * props , struct dvb_usb_device_description * * desc , int * cold ) { int ret ; u8 reply , * buf ; buf = kmalloc ( FW_BULKOUT_SIZE + 2 , GFP_KERNEL ) ; if ( ! buf ) return - ENOMEM ; ret = af9005_boot_packet ( udev , FW_CONFIG , & reply , buf , FW_BULKOUT_SIZE + 2 ) ; if ( ret ) goto err ; deb_info ( ""resultofFW_CONFIGinidentifystate%d\\n"" , reply ) ; if ( reply == 0x01 ) * cold = 1 ; else if ( reply == 0x02 ) * cold = 0 ; else return - EIO ; deb_info ( ""Identifystatecold=%d\\n"" , * cold ) ; err : kfree ( buf ) ; return ret ; }
",0,229
1640,"NOEXPORT char * pgsql_server ( CLI * c , SERVICE_OPTIONS * opt , const PHASE phase ) { uint8_t buffer [ 8 ] , ssl_ok [ 1 ] = { 'S' } ; ( void ) opt ; if ( phase != PROTOCOL_EARLY ) return NULL ; memset ( buffer , 0 , sizeof buffer ) ; s_read ( c , c -> local_rfd . fd , buffer , sizeof buffer ) ; if ( safe_memcmp ( buffer , ssl_request , sizeof ssl_request ) ) { s_log ( LOG_ERR , ""PostgreSQLclientdidnotrequestTLS,rejecting"" ) ; return NULL ; } s_write ( c , c -> local_wfd . fd , ssl_ok , sizeof ssl_ok ) ; }
",0,185
1641,"static int cib_tls_signon ( cib_t * cib , struct remote_connection_s * connection ) { int sock ; cib_remote_opaque_t * private = cib -> variant_opaque ; struct sockaddr_in addr ; int rc = 0 ; char * server = private -> server ; int ret_ga ; struct addrinfo * res ; struct addrinfo hints ; xmlNode * answer = NULL ; xmlNode * login = NULL ; static struct mainloop_fd_callbacks cib_fd_callbacks = { . dispatch = cib_remote_dispatch , . destroy = cib_remote_connection_destroy , } ; connection -> socket = 0 ; connection -> session = NULL ; sock = socket ( PF_INET , SOCK_STREAM , IPPROTO_TCP ) ; if ( sock == - 1 ) { crm_perror ( LOG_ERR , ""Socketcreationfailed"" ) ; return - 1 ; } bzero ( & hints , sizeof ( struct addrinfo ) ) ; hints . ai_flags = AI_CANONNAME ; hints . ai_family = AF_INET ; hints . ai_socktype = SOCK_RAW ; if ( hints . ai_family == AF_INET6 ) { hints . ai_protocol = IPPROTO_ICMPV6 ; } else { hints . ai_protocol = IPPROTO_ICMP ; } crm_debug ( ""Lookingup%s"" , server ) ; ret_ga = getaddrinfo ( server , NULL , & hints , & res ) ; if ( ret_ga ) { crm_err ( ""getaddrinfo:%s"" , gai_strerror ( ret_ga ) ) ; close ( sock ) ; return - 1 ; } if ( res -> ai_canonname ) { server = res -> ai_canonname ; } crm_debug ( ""Gotaddress%sfor%s"" , server , private -> server ) ; if ( ! res -> ai_addr ) { fprintf ( stderr , ""getaddrinfofailed"" ) ; crm_exit ( 1 ) ; } # if 1 memcpy ( & addr , res -> ai_addr , res -> ai_addr , private -> server ) ; if ( ! res -> ai
",0,511
1642,"void vp8_create_compressor ( VP8_CONFIG * oxcf ) { int i ; VP8_COMP * cpi ; VP8_COMMON * cm ; cpi = vpx_memalign ( 32 , sizeof ( VP8_COMP ) ) ; if ( ! cpi ) return 0 ; cm = & cpi -> common ; memset ( cpi , 0 , sizeof ( VP8_COMP ) ) ; if ( setjmp ( cm -> error . jmp ) ) { cpi -> common . error . setjmp = 0 ; vp8_remove_compressor ( & cpi ) ; return 0 ; } cpi -> common . error . setjmp = 1 ; CHECK_MEM_ERROR ( cpi -> mb . ss , vpx_calloc ( sizeof ( search_site ) , ( MAX_MVSEARCH_STEPS * 8 ) + 1 ) ) ; vp8_create_common ( & cpi -> common ) ; init_config ( cpi , oxcf ) ; memcpy ( cpi -> base_skip_false_prob , vp8cx_base_skip_false_prob , sizeof ( vp8cx_base_skip_false_prob ) ) ; cpi -> common . current_video_frame = 0 ; cpi -> temporal_pattern_counter = 0 ; memcpy ( cpi -> base_skip_false_prob , vp8cx_base_skip_false_prob , sizeof ( vp8cx_base_skip_false_prob ) ) ; cpi -> kf_overspend_bits = 0 ; cpi -> kf_bitrate_adjustment = 0 ; cpi -> frames_till_gf_update_due = 0 ; cpi -> gf_overspend_bits = 0 ; cpi -> non_gf_bitrate_adjustment = 0 ; cpi -> prob_last_coded = 128 ; cpi -> prob_gf_coded = 128 ; cpi -> prob_intra_coded = 63 ; cpi -> recent_ref_frame_usage [ INTRA_FRAME ] = 1 ; cpi -> recent_ref_frame_usage [ LAST_FRAME ] = 1 ; cpi -> recent_ref_frame_usage [
",0,511
1643,"static bool dccp_new ( struct nf_conn * ct , const struct sk_buff * skb , unsigned int dataoff , unsigned int * timeouts ) { struct net * net = nf_ct_net ( ct ) ; struct dccp_net * dn ; struct dccp_hdr _dh , * dh ; const char * msg ; u_int8_t state ; dh = skb_header_pointer ( skb , dataoff , sizeof ( _dh ) , & _dh ) ; BUG_ON ( dh == NULL ) ; state = dccp_state_table [ CT_DCCP_ROLE_CLIENT ] [ dh -> dccph_type ] [ CT_DCCP_NONE ] ; switch ( state ) { default : dn = dccp_pernet ( net ) ; if ( dn -> dccp_loose == 0 ) { msg = ""nf_ct_dccp:notpickingupexistingconnection"" ; goto out_invalid ; } case CT_DCCP_REQUEST : break ; case CT_DCCP_INVALID : msg = ""nf_ct_dccp:invalidstatetransition"" ; goto out_invalid ; } ct -> proto . dccp . role [ IP_CT_DIR_ORIGINAL ] = CT_DCCP_ROLE_CLIENT ; ct -> proto . dccp . role [ IP_CT_DIR_REPLY ] = CT_DCCP_ROLE_SERVER ; ct -> proto . dccp . state = CT_DCCP_NONE ; ct -> proto . dccp . last_pkt = DCCP_PKT_REQUEST ; ct -> proto . dccp . last_dir = IP_CT_DIR_ORIGINAL ; ct -> proto . dccp . handshake_seq = 0 ; return true ; out_invalid : if ( LOG_INVALID ( net , IPPROTO_DCCP ) ) nf_log_packet ( net , nf_ct_l3num ( ct ) , 0 , skb , NULL , NULL , NULL , ""%s"" , msg ) ; return false ; }
",1,503
1644,"static inline int do_exception ( struct pt_regs * regs , int access , unsigned long trans_exc_code ) { struct task_struct * tsk ; struct mm_struct * mm ; struct vm_area_struct * vma ; unsigned long address ; unsigned int flags ; int fault ; if ( notify_page_fault ( regs ) ) return 0 ; tsk = current ; mm = tsk -> mm ; fault = VM_FAULT_BADCONTEXT ; if ( unlikely ( ! user_space_fault ( trans_exc_code ) || in_atomic ( ) || ! mm ) ) goto out ; address = trans_exc_code & __FAIL_ADDR_MASK ; perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS , 1 , regs , address ) ; flags = FAULT_FLAG_ALLOW_RETRY ; if ( access == VM_WRITE || ( trans_exc_code & store_indication ) == 0x400 ) flags |= FAULT_FLAG_WRITE ; retry : down_read ( & mm -> mmap_sem ) ; fault = VM_FAULT_BADMAP ; vma = find_vma ( mm , address ) ; if ( ! vma ) goto out_up ; if ( unlikely ( vma -> vm_start > address ) ) { if ( ! ( vma -> vm_flags & VM_GROWSDOWN ) ) goto out_up ; if ( expand_stack ( vma , address ) ) goto out_up ; } fault = VM_FAULT_BADACCESS ; if ( unlikely ( ! ( vma -> vm_flags & access ) ) ) goto out_up ; if ( is_vm_hugetlb_page ( vma ) ) address &= HPAGE_MASK ; fault = handle_mm_fault ( mm , vma , address , flags ) ; if ( unlikely ( fault & VM_FAULT_ERROR ) ) goto out_up ; if ( flags & FAULT_FLAG_ALLOW_RETRY ) { if ( fault & VM_FAULT_MAJOR ) { tsk -> maj_flt ++ ; perf_sw_event ( PERF_COUNT_SW_PAGE_FAULTS_MAJ , 1 , regs , address ) ; } else { tsk
",0,511
1645,"static void mldv2_query_print ( netdissect_options * ndo , const u_char * bp , u_int len ) { const struct icmp6_hdr * icp = ( const struct icmp6_hdr * ) bp ; u_int mrc ; int mrt , qqi ; u_int nsrcs ; register u_int i ; if ( len < 28 ) { ND_PRINT ( ( ndo , ""[invalidlen%d]"" , len ) ) ; return ; } ND_TCHECK ( icp -> icmp6_data16 [ 0 ] ) ; mrc = EXTRACT_16BITS ( & icp -> icmp6_data16 [ 0 ] ) ; if ( mrc < 32768 ) { mrt = mrc ; } else { mrt = ( ( mrc & 0x0fff ) | 0x1000 ) << ( ( ( mrc & 0x7000 ) >> 12 ) + 3 ) ; } if ( ndo -> ndo_vflag ) { ND_PRINT ( ( ndo , ""[maxrespdelay=%d]"" , mrt ) ) ; } ND_TCHECK2 ( bp [ 8 ] , sizeof ( struct in6_addr ) ) ; ND_PRINT ( ( ndo , ""[gaddr%s"" , ip6addr_string ( ndo , & bp [ 8 ] ) ) ) ; if ( ndo -> ndo_vflag ) { ND_TCHECK ( bp [ 25 ] ) ; if ( bp [ 24 ] & 0x08 ) { ND_PRINT ( ( ndo , ""sflag"" ) ) ; } if ( bp [ 24 ] & 0x07 ) { ND_PRINT ( ( ndo , ""robustness=%d"" , bp [ 24 ] & 0x07 ) ) ; } if ( bp [ 25 ] < 128 ) { qqi = bp [ 25 ] ; } else { qqi = ( ( bp [ 25 ] & 0x0f ) | 0x10 ) << ( ( ( bp [ 25 ] & 0x70 ) >> 4 ) + 3 ) ; } ND_PRINT ( ( ndo , ""qqi=%d"" , qqi ) ) ; } ND_TCHECK2 ( bp [ 26 ] ,
",0,511
1646,"bool ExprResolveBoolean ( struct xkb_context * ctx , const ExprDef * expr , bool * set_rtrn ) { bool ok = false ; const char * ident ; switch ( expr -> expr . op ) { case EXPR_VALUE : if ( expr -> expr . value_type != EXPR_TYPE_BOOLEAN ) { log_err ( ctx , ""Foundconstantoftype%swherebooleanwasexpected\\n"" , expr_value_type_to_string ( expr -> expr . value_type ) ) ; return false ; } * set_rtrn = expr -> boolean . set ; return true ; case EXPR_IDENT : ident = xkb_atom_text ( ctx , expr -> ident . ident ) ; if ( ident ) { if ( istreq ( ident , ""true"" ) || istreq ( ident , ""yes"" ) || istreq ( ident , ""on"" ) ) { * set_rtrn = true ; return true ; } else if ( istreq ( ident , ""false"" ) || istreq ( ident , ""no"" ) || istreq ( ident , ""off"" ) ) { * set_rtrn = false ; return true ; } } log_err ( ctx , ""Identifier\\""%s\\""oftypebooleanisunknown\\n"" , ident ) ; return false ; case EXPR_FIELD_REF : log_err ( ctx , ""Default\\""%s.%s\\""oftypebooleanisunknown\\n"" , xkb_atom_text ( ctx , expr -> field_ref . element ) , xkb_atom_text ( ctx , expr -> field_ref . field ) ) ; return false ; case EXPR_INVERT : case EXPR_NOT : ok = ExprResolveBoolean ( ctx , expr , set_rtrn ) ; if ( ok ) * set_rtrn = ! * set_rtrn ; return ok ; case EXPR_ADD : case EXPR_SUBTRACT : case EXPR_MULTIPLY : case EXPR_DIVIDE : case EXPR_ASSIGN : case EXPR_NEGATE : case EXPR_UNARY_PLUS : log_err ( ctx , ""%sofbooleanolean
",0,511
1647,"static Image * ReadHDRImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { char format [ MaxTextExtent ] , keyword [ MaxTextExtent ] , tag [ MaxTextExtent ] , value [ MaxTextExtent ] ; double gamma ; Image * image ; int c ; MagickBooleanType status , value_expected ; register Quantum * q ; register ssize_t i , x ; register unsigned char * p ; ssize_t count , y ; unsigned char * end , pixel [ 4 ] , * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } image -> columns = 0 ; image -> rows = 0 ; * format = '\\0' ; c = ReadBlobByte ( image ) ; if ( c == EOF ) { image = DestroyImage ( image ) ; return ( ( Image * ) NULL ) ; } while ( isgraph ( c ) && ( image -> columns == 0 ) && ( image -> rows == 0 ) ) { if ( c == ( int ) '#' ) { char * comment ; register char * p ; size_t length ; length = MaxTextExtent ; comment = AcquireString ( ( char * ) NULL ) ; for ( p = comment ; comment != ( char * ) NULL ; p ++ ) { c = ReadBlobByte ( image ) ; if ( ( c == EOF ) || ( c == ( int ) '\\n' ) ) break ; if ( ( size_t ) ( p - comment + 1 ) >= length ) { * p = '\\0' ; length <<= 1 ; comment = ( char * ) ResizeQuantumMemory ( comment , length + MaxTextExtent , sizeof ( * comment ) )
",0,511
1648,"static int mptctl_mpt_command ( MPT_ADAPTER * ioc , unsigned long arg ) { struct mpt_ioctl_command __user * uarg = ( void __user * ) arg ; struct mpt_ioctl_command karg ; if ( copy_from_user ( & karg , uarg , sizeof ( struct mpt_ioctl_command ) ) ) { printk ( KERN_ERR MYNAM ""%s@%d::mptctl_mpt_command-"" ""Unabletoreadinmpt_ioctl_commandstruct@%p\\n"" , __FILE__ , __LINE__ , uarg ) ; return - EFAULT ; } if ( ( ( iocnum = mpt_verify_adapter ( karg . hdr . iocnum , & ioc ) ) < 0 ) || ( ioc == NULL ) ) { printk ( KERN_DEBUG MYNAM ""%s::mptctl_mpt_command()@%d-ioc%dnotfound
",0,229
1649,"static Image * ReadXBMImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { char buffer [ MaxTextExtent ] , name [ MaxTextExtent ] ; Image * image ; int c ; MagickBooleanType status ; register IndexPacket * indexes ; register ssize_t i , x ; register PixelPacket * q ; register unsigned char * p ; short int hex_digits [ 256 ] ; ssize_t y ; unsigned char * data ; unsigned int bit , byte , bytes_per_line , height , length , padding , version , width ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } width = 0 ; height = 0 ; while ( ReadBlobString ( image , buffer ) != ( char * ) NULL ) if ( sscanf ( buffer , ""#define%32s%u"" , name , & width ) == 2 ) if ( ( strlen ( name ) >= 6 ) && ( LocaleCompare ( name + strlen ( name ) - 6 , ""_width"" ) == 0 ) ) break ; while ( ReadBlobString ( image , buffer ) != ( char * ) NULL ) if ( sscanf ( buffer , ""#define%32s%u"" , name , & height ) == 2 ) if ( ( strlen ( name ) >= 7 ) && ( LocaleCompare ( name + strlen ( name ) - 7 , ""_height"" ) == 0 ) ) break ; image -> columns = width ; image -> rows = height ; image -> depth = 8 ; image -> storage_class = PseudoClass ; image -> colors = 2 ; version = 11 ; while ( ReadBlobString ( image , buffer ) != ( char * ) NULL ) { if ( ssize_
",0,511
1650,"static int jpc_enc_encodemainhdr ( jpc_enc_t * enc ) { jpc_siz_t * siz ; jpc_cod_t * cod ; jpc_qcd_t * qcd ; int i ; long startoff ; long mainhdrlen ; jpc_enc_cp_t * cp ; jpc_qcc_t * qcc ; jpc_enc_tccp_t * tccp ; uint_fast16_t cmptno ; jpc_tsfb_band_t bandinfos [ JPC_MAXBANDS ] ; jpc_fix_t mctsynweight ; jpc_enc_tcp_t * tcp ; jpc_tsfb_t * tsfb ; jpc_tsfb_band_t * bandinfo ; uint_fast16_t numbands ; uint_fast16_t bandno ; uint_fast16_t rlvlno ; uint_fast16_t analgain ; jpc_fix_t absstepsize ; char buf [ 1024 ] ; jpc_com_t * com ; cp = enc -> cp ; startoff = jas_stream_getrwcount ( enc -> out ) ; if ( ! ( enc -> mrk = jpc_ms_create ( JPC_MS_SOC ) ) ) { return - 1 ; } if ( jpc_putms ( enc -> out , enc -> cstate , enc -> mrk ) ) { jas_eprintf ( ""cannotwriteSOCmarker\\n"" ) ; return - 1 ; } jpc_ms_destroy ( enc -> mrk ) ; enc -> mrk = 0 ; if ( ! ( enc -> mrk = jpc_ms_create ( JPC_MS_SIZ ) ) ) { return - 1 ; } siz = & enc -> mrk -> parms . siz ; siz -> caps = 0 ; siz -> xoff = cp -> imgareatlx ; siz -> yoff = cp -> imgareatly ; siz -> width = cp -> refgrdwidth ; siz -> height = cp -> refgrdheight ; siz -> tilexoff = cp -> tilegrdoffx ; siz -> tileyoff = cp -> tilegrdoffy ;
",0,511
1651,"void irc_mode_channel_update ( struct t_irc_server * server , struct t_irc_channel * channel , char set_flag , char chanmode , const char * argument ) { char * pos_args , * str_modes , * * argv , * pos , * ptr_arg ; char * new_modes , * new_args , str_mode [ 2 ] , * str_temp ; int argc , current_arg , chanmode_found , length ; if ( ! channel -> modes ) channel -> modes = strdup ( ""+"" ) ; if ( ! channel -> modes ) return ; argc = 0 ; argv = NULL ; pos_args = strchr ( channel -> modes , '' ) ; if ( pos_args ) { str_modes = weechat_strndup ( channel -> modes , pos_args - channel -> modes ) ; if ( ! str_modes ) return ; pos_args ++ ; while ( pos_args [ 0 ] == '' ) pos_args ++ ; argv = weechat_string_split ( pos_args , """" , NULL , WEECHAT_STRING_SPLIT_STRIP_LEFT | WEECHAT_STRING_SPLIT_STRIP_RIGHT | WEECHAT_STRING_SPLIT_COLLAPSE_SEPS , 0 , & argc ) ; } else { str_modes = strdup ( channel -> modes ) ; if ( ! str_modes ) return ; } new_modes = malloc ( strlen ( channel -> modes ) + 1 + 1 ) ; new_args = malloc ( ( ( pos_args ) ? strlen ( pos_args ) : 0 ) + ( ( argument ) ? 1 + strlen ( argument ) : 0 ) + 1 ) ; if ( new_modes && new_args ) { new_modes [ 0 ] = '\\0' ; new_args [ 0 ] = '\\0' ; current_arg = 0 ; chanmode_found = 0 ; pos = str_modes ; while ( pos && pos [ 0 ] ) { if ( ( pos [ 0 ] == '+' ) || ( pos [ 0 ] == '-' ) ) { str_mode [ 0 ] = pos [ 0 ] ; str_mode [ 1 ] = '
",0,511
1652,"static int decode_uniform ( vpx_reader * r ) { const int l = 8 ; const int m = ( 1 << l ) - 191 ; const int v = vpx_read_literal ( r , l - 1 ) ; return v < m ? v : ( v << 1 ) - m + vp9_read_bit ( r ) ; }
",0,80
1653,"static int http_connect ( http_subtransport * t ) { int error ; if ( t -> connected && http_should_keep_alive ( & t -> parser ) && t -> parse_finished ) return 0 ; if ( t -> io ) { git_stream_close ( t -> io ) ; git_stream_free ( t -> io ) ; t -> io = NULL ; t -> connected = 0 ; } if ( t -> connection_data . use_ssl ) { error = git_tls_stream_new ( & t -> io , t -> connection_data . host , t -> connection_data . port ) ; } else { # ifdef GIT_CURL error = git_curl_stream_new ( & t -> io , t -> connection_data . host , t -> connection_data . port ) ; # else error = git_socket_stream_new ( & t -> io , t -> connection_data . host , t -> connection_data . port ) ; # endif } if ( error < 0 ) return error ; GITERR_CHECK_VERSION ( t -> io , GIT_STREAM_VERSION , ""git_stream"" ) ; apply_proxy_config ( t ) ; error = git_stream_connect ( t -> io ) ; if ( ( ! error || error == GIT_ECERTIFICATE ) && t -> owner -> certificate_check_cb != NULL && git_stream_is_encrypted ( t -> io ) ) { git_cert * cert ; int is_valid = ( error == GIT_OK ) ; if ( ( error = git_stream_certificate ( & cert , t -> io ) ) < 0 ) return error ; giterr_clear ( ) ; error = t -> owner -> certificate_check_cb ( cert , is_valid , t -> connection_data . host , t -> owner -> message_cb_payload ) ; if ( error < 0 ) { if ( ! giterr_last ( ) ) giterr_set ( GITERR_NET , ""usercancelledcertificatecheck"" ) ; return error ; } } if ( error < 0 ) return error ; t -> connected = 1 ; return 0 ; }
",1,477
1654,"void vp9_cost_tokens_skip ( int * costs , const vpx_prob * probs , vp9_tree tree ) { assert ( tree [ 0 ] <= 0 && tree [ 1 ] > 0 ) ; costs [ - tree [ 0 ] = vp9_cost_bit ( probs [ 0 ] , 0 ) ; cost ( costs , tree , probs , 2 , 0 ) ; }
",0,93
1655,"static REFERENCE_MODE read_block_reference_mode ( VP9_COMMON * cm , const MACROBLOCKD * xd , vpx_reader * r ) { if ( cm -> reference_mode == REFERENCE_MODE_SELECT ) { const int ctx = vp9_get_reference_mode_context ( cm , xd ) ; const REFERENCE_MODE mode = vpx_read ( r , cm -> fc -> comp_inter_prob [ ctx ] ) ; FRAME_COUNTS * counts = xd -> counts ; if ( counts ) ++ counts -> comp_inter [ ctx ] [ mode ] ; return mode ; } else { return cm -> reference_mode ; } }
",0,160
1656,"static int _server_handle_vCont ( libgdbr_t * g , int ( * cmd_cb ) ( void * , const char * , char * , size_t ) , void * core_ptr ) { char * action = NULL ; if ( send_ack ( g ) < 0 ) { return - 1 ; } g -> data [ g -> data_len ] = '\\0' ; if ( g -> data [ 5 ] == '?' ) { return send_msg ( g , ""vCont;c;s"" ) ; } if ( ! ( action = strtok ( g -> data , "";"" ) ) ) { return send_msg ( g , ""E01"" ) ; } while ( action = strtok ( NULL , "";"" ) ) { eprintf ( ""action:%s\\n"" , action ) ; switch ( action [ 0 ] ) { case 's' : if ( cmd_cb ( core_ptr , ""ds"" , NULL , 0 ) < 0 ) { send_msg ( g , ""E01"" ) ; return - 1 ; } return send_msg ( g , ""OK"" ) ; case 'c' : if ( cmd_cb ( core_ptr , ""dc"" , NULL , 0 ) < 0 ) { send_msg ( g , ""E01"" ) ; return - 1 ; } return send_msg ( g , ""OK"" ) ; default : return send_msg ( g , ""E01"" ) ; } } }
",0,321
1657,"static struct stream_state * new_stream ( struct VpxEncoderConfig * global , struct stream_state * prev ) { struct stream_state * stream ; stream = calloc ( 1 , sizeof ( * stream ) ) ; if ( ! stream ) fatal ( ""Failedtoallocatenewstream."" ) ; if ( prev ) { memcpy ( stream , prev , sizeof ( * stream ) ) ; stream -> index ++ ; prev -> next = stream ; } else { vpx_codec_err_t res ; res = vpx_codec_enc_config_default ( global -> codec -> interface ( ) , & stream -> config . cfg , global -> usage ) ; if ( res ) fatal ( ""Failedtogetconfig:%s\\n"" , vpx_codec_err_to_string ( res ) ) ; stream -> config . cfg . g_timebase . den = 1000 ; stream -> config . cfg . g_w = 0 ; stream -> config . cfg . g_h = 0 ; stream -> config . stereo_fmt = STEREO_FORMAT_MONO ; stream -> config . write_webm = 1 ; # if CONFIG_WEBM_IO stream -> ebml . last_pts_ms = - 1 ; # endif stream -> ebml . debug = global -> debug ; if ( global -> deadline == VPX_DL_REALTIME ) stream -> config . cfg . g_lag_in_frames = 0 ; } stream -> config . out_fn = NULL ; stream -> next = NULL ; return stream ; }
",0,344
1658,"static void icmp6_opt_print ( netdissect_options * ndo , const u_char * bp , int resid ) { const struct nd_opt_hdr * op ; const struct nd_opt_prefix_info * opp ; const struct nd_opt_mtu * opm ; const struct nd_opt_rdnss * oprd ; const struct nd_opt_dnssl * opds ; const struct nd_opt_advinterval * opa ; const struct nd_opt_homeagent_info * oph ; const struct nd_opt_route_info * opri ; const u_char * cp , * ep , * domp ; struct in6_addr in6 ; const struct in6_addr * in6p ; size_t l ; u_int i ; # define ECHECK ( var ) if ( ( const u_char * ) & ( var ) > ep - sizeof ( var ) ) return cp = bp ; ep = ndo -> ndo_snapend ; while ( cp < ep ) { op = ( const struct nd_opt_hdr * ) cp ; ECHECK ( op -> nd_opt_len ) ; if ( resid <= 0 ) return ; if ( op -> nd_opt_len == 0 ) goto trunc ; if ( cp + ( op -> nd_opt_len << 3 ) > ep ) goto trunc ; ND_PRINT ( ( ndo , ""\\n\\t%soption(%u),length%u(%u):"" , tok2str ( icmp6_opt_values , ""unknown"" , op -> nd_opt_type ) , op -> nd_opt_type , op -> nd_opt_len << 3 , op -> nd_opt_len ) ) ; switch ( op -> nd_opt_type ) { case ND_OPT_SOURCE_LINKADDR : l = ( op -> nd_opt_len << 3 ) - 2 ; print_lladdr ( ndo , cp + 2 , l ) ; break ; case ND_OPT_TARGET_LINKADDR : l = ( op -> nd_opt_len << 3 ) - 2 ; print_lladdr ( ndo , cp + 2 , l ) ; break ; case ND_OPT_
",0,511
1659,"int yr_re_ast_create ( RE_AST * * re_ast ) { * re_ast = ( RE_AST * ) yr_malloc ( sizeof ( RE_AST ) ) ; if ( * re_ast == NULL ) return ERROR_INSUFFICIENT_MEMORY ; ( * re_ast ) -> flags = 0 ; ( * re_ast ) -> root_node = re_ast_malloc ( sizeof ( RE_AST ) ) ; return ERROR_SUCCESS ; }
",0,111
1660,"static unsigned int unix_dgram_poll ( struct file * file , struct socket * sock , poll_table * wait ) { struct sock * sk = sock -> sk , * other ; unsigned int mask , writable ; sock_poll_wait ( file , sk_sleep ( sk ) , wait ) ; mask = 0 ; if ( sk -> sk_err || ! skb_queue_empty ( & sk -> sk_error_queue ) ) mask |= POLLERR | ( sock_flag ( sk , SOCK_SELECT_ERR_QUEUE ) ? POLLPRI : 0 ) ; if ( sk -> sk_shutdown & RCV_SHUTDOWN ) mask |= POLLRDHUP | POLLIN | POLLRDNORM ; if ( sk -> sk_shutdown == SHUTDOWN_MASK ) mask |= POLLHUP ; if ( ! skb_queue_empty ( & sk -> sk_receive_queue ) ) mask |= POLLIN | POLLRDNORM ; if ( sk -> sk_type == SOCK_SEQPACKET ) { if ( sk -> sk_state == TCP_CLOSE ) mask |= POLLHUP ; if ( sk -> sk_state == TCP_SYN_SENT ) return mask ; } if ( ! ( poll_requested_events ( wait ) & ( POLLWRBAND | POLLWRNORM | POLLOUT ) ) ) return mask ; writable = unix_writable ( sk ) ; other = unix_peer_get ( sk ) ; if ( other ) { if ( unix_peer ( other ) != sk ) { sock_poll_wait ( file , & unix_sk ( other ) -> peer_wait , wait ) ; if ( unix_recvq_full ( other ) ) writable = 0 ; } sock_put ( other ) ; } if ( writable ) mask |= POLLOUT | POLLWRNORM | POLLWRBAND ; else set_bit ( SOCK_ASYNC_NOSPACE , & sk -> sk_socket -> flags ) ; return mask ; }
",0,466
1661,"static int db_dict_iter_lookup_key_values ( struct db_dict_value_iter * iter ) { struct db_dict_iter_key * key ; string_t * path ; const char * error ; int ret ; array_sort ( & iter -> keys , db_dict_iter_key_cmp ) ; path = t_str_new ( 128 ) ; str_append ( path , DICT_PATH_SHARED ) ; array_foreach_modifiable ( & iter -> keys , key ) { if ( ! key -> used ) continue ; str_truncate ( path , strlen ( DICT_PATH_SHARED ) ) ; ret = var_expand ( path , key -> key -> key , iter -> var_expand_table , & error ) ; if ( ret <= 0 ) { auth_request_log_error ( iter -> auth_request , AUTH_SUBSYS_DB , ""Failedtoexpandkey%s:%s"" , key -> key -> key , error ) ; return - 1 ; } ret = dict_lookup ( iter -> conn -> dict , iter -> pool , str_c ( path ) , & key -> value , & error ) ; if ( ret > 0 ) { auth_request_log_debug ( iter -> auth_request , AUTH_SUBSYS_DB , ""Lookup:%s=%s"" , str_c ( path ) , key -> value ) ; } else if ( ret < 0 ) { auth_request_log_error ( iter -> auth_request , AUTH_SUBSYS_DB , ""Failedtolookupkey%s:%s"" , str_c ( path ) , error ) ; return - 1 ; } else if ( key -> key -> default_value != NULL ) { auth_request_log_debug ( iter -> auth_request , AUTH_SUBSYS_DB , ""Lookup:%snotfound,usingdefaultvalue%s"" , str_c ( path ) , key -> key -> default_value ) ; key -> value = key -> key -> default_value ; } else { return 0 ; } } return 1 ; }
",0,470
1662,"static u64 __skb_get_nlattr_nest ( u64 ctx , u64 A , u64 X , u64 r4 , u64 r5 ) { struct sk_buff * skb = ( struct sk_buff * ) ( long ) ctx ; struct nlattr * nla ; if ( skb_is_nonlinear ( skb ) ) return 0 ; if ( skb -> len < sizeof ( struct nlattr ) ) return 0 ; nla = ( struct nlattr * ) & skb -> data [ A ] ; if ( nla -> nla_len > skb -> len - A ) return 0 ; nla = nla_find_nested ( nla , X ) ; if ( nla ) return ( void * ) nla - ( void * ) skb -> data ; return 0 ; }
",0,186
1663,"static Image * ReadICONImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { IconFile icon_file ; IconInfo icon_info ; Image * image ; MagickBooleanType status ; register ssize_t i , x ; register Quantum * q ; register unsigned char * p ; size_t bit , byte , bytes_per_line , one , scanline_pad ; ssize_t count , offset , y ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; ( void ) LogMagickEvent ( CoderEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info , exception ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) { image = DestroyImageList ( image ) ; return ( ( Image * ) NULL ) ; } icon_file . reserved = ( short ) ReadBlobLSBShort ( image ) ; icon_file . resource_type = ( short ) ReadBlobLSBShort ( image ) ; icon_file . count = ( short ) ReadBlobLSBShort ( image ) ; if ( ( icon_file . reserved != 0 ) || ( ( icon_file . resource_type != 1 ) && ( icon_file . resource_type != 2 ) ) || ( icon_file . count > MaxIcons ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; for ( i = 0 ; i < icon_file . count ; i ++ ) { icon_file . directory [ i ] . width = ( unsigned char ) ReadBlobByte ( image ) ; icon_file . directory [ i ] . height = ( unsigned char ) ReadBlobByte ( image ) ; icon_file . directory [ i ] . colors = ( unsigned char ) ReadBlobByte ( image ) ; icon_file . directory [ i ] . reserved = ( unsigned char ) ReadBlobByte ( image ) ; icon_file . directory [ i ] . planes = ( unsigned short ) ReadBlobLSBShort ( image ) ; icon_file . directory [ i ]
",0,511
1664,"void receive_carbon ( void * * state ) { prof_input ( ""/carbonson"" ) ; prof_connect ( ) ; assert_true ( stbbr_received ( ""<iqid=\'*\'type=\'set\'><enablexmlns=\'urn:xmpp:carbons:2\'/></iq>"" ) ) ; stbbr_send ( ""<messagetype=\'chat\'to=\'stabber@localhost/profanity\'from=\'stabber@localhost\'>"" ""<receivedxmlns=\'urn:xmpp:carbons:2\'>"" ""<forwardedxmlns=\'urn:xmpp:forward:0\'>"" ""<messageid=\'prof_msg_7\'xmlns=\'jabber:client\'type=\'chat\'lang=\'en\'to=\'stabber@localhost/profanity\'from=\'buddy1@localhost/mobile\'>"" ""<body>testcarbonfromrecipient</body>"" ""</message>"" ""</forwarded>"" ""</received>"" ""</message>"" ) ; assert_true ( prof_output_regex ( ""Buddy1/mobile:.+testcarbonfromrecipient"" ) ) ; }
",1,259
1665,"static int cac_get_serial_nr_from_CUID ( sc_card_t * card , sc_serial_number_t * serial ) { cac_private_data_t * priv = CAC_DATA ( card ) ; SC_FUNC_CALLED ( card -> ctx , SC_LOG_DEBUG_NORMAL ) ; if ( card -> serialnr . len ) { * serial = card -> serialnr ; SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_NORMAL , SC_SUCCESS ) ; } if ( priv -> cac_id_len ) { serial -> len = MIN ( priv -> cac_id_len , SC_MAX_SERIALNR ) ; memcpy ( serial -> value , priv -> cac_id , serial -> len ) ; SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_NORMAL , SC_SUCCESS ) ; } SC_FUNC_RETURN ( card -> ctx , SC_LOG_DEBUG_NORMAL , SC_ERROR_FILE_NOT_FOUND ) ; }
",1,243
1666,"static struct tok_state * tok_new ( void ) { struct tok_state * tok = ( struct tok_state * ) PyMem_MALLOC ( sizeof ( struct tok_state ) ) ; if ( tok == NULL ) return NULL ; tok -> buf = tok -> cur = tok -> end = tok -> inp = tok -> start = NULL ; tok -> done = E_OK ; tok -> fp = NULL ; tok -> input = NULL ; tok -> tabsize = TABSIZE ; tok -> indent = 0 ; tok -> indstack [ 0 ] = 0 ; tok -> atbol = 1 ; tok -> pendin = 0 ; tok -> prompt = tok -> nextprompt = NULL ; tok -> lineno = 0 ; tok -> level = 0 ; tok -> altwarning = 1 ; tok -> alterror = 1 ; tok -> alttabsize = 1 ; tok -> altindstack [ 0 ] = 0 ; tok -> decoding_state = STATE_INIT ; tok -> decoding_erred = 0 ; tok -> read_coding_spec = 0 ; tok -> enc = NULL ; tok -> encoding = NULL ; tok -> cont_line = 0 ; # ifndef PGEN tok -> filename = NULL ; tok -> decoding_readline = NULL ; tok -> decoding_buffer = NULL ; # endif tok -> async_def = 0 ; tok -> async_def_indent = 0 ; tok -> async_def_nl = 0 ; return tok ; }
",0,351
1667,"void AV1_RewriteESDescriptorEx ( GF_MPEGVisualSampleEntryBox * av1 , GF_MediaBox * mdia ) { GF_BitRateBox * btrt = gf_isom_sample_entry_get_bitrate ( ( GF_SampleEntryBox * ) av1 , GF_FALSE ) ; if ( av1 -> emul_esd ) gf_odf_desc_del ( ( GF_Descriptor * ) av1 -> emul_esd ) ; av1 -> emul_esd = gf_odf_desc_esd_new ( 2 ) ; av1 -> emul_esd -> decoderConfig -> streamType = GF_STREAM_VISUAL ; av1 -> emul_esd -> decoderConfig -> objectTypeIndication = GF_CODECID_AV1 ; if ( btrt ) { av1 -> emul_esd -> decoderConfig -> bufferSizeDB = btrt -> bufferSizeDB ; av1 -> emul_esd -> decoderConfig -> avgBitrate = btrt -> avgBitrate ; av1 -> emul_esd -> decoderConfig -> maxBitrate = btrt -> maxBitrate ; } av1 -> av1_config ) { GF_AV1Config * av1_cfg = AV1_DuplicateConfig ( av1 -> av1_config -> config ) ; if ( av1_cfg ) { gf_odf_av1_cfg_write ( av1_cfg , & av1 -> emul_esd -> decoderConfig -> decoderSpecificInfo -> data , & av1 -> emul_esd -> decoderConfig -> decoderSpecificInfo -> dataLength ) ; gf_odf_av1_cfg_del ( av1_cfg ) ; } } }
",0,406
1668,"GF_Err dinf_Read ( GF_Box * s , GF_BitStream * bs ) { GF_Err e = gf_isom_box_array_read ( s , bs , dinf_AddBox ) ; if ( e ) { return e ; } if ( ! ( ( GF_DataInformationBox * ) s ) -> dref ) { GF_LOG ( GF_LOG_ERROR , GF_LOG_CONTAINER , ( ""[isofile]Missingdrefboxindinf\\n"" ) ) ; ( ( GF_DataInformationBox * ) s ) -> dref = ( GF_DataReferenceBox * ) gf_isom_box_new ( GF_ISOM_BOX_TYPE_DREF ) ; } return GF_OK ; }
",0,172
1669,"static int sc_pkcs15emu_esteid_init ( sc_pkcs15_card_t * p15card ) { sc_card_t * card = p15card -> card ; unsigned char buff [ 128 ] ; int r , i ; size_t field_length = 0 , modulus_length = 0 ; sc_path_t tmppath ; set_string ( & p15card -> tokeninfo -> label , ""ID-kaart"" ) ; set_string ( & p15card -> tokeninfo -> manufacturer_id , ""ASSertifitseerimiskeskus"" ) ; sc_format_path ( ""3f00eeee5044"" , & tmppath ) ; r = sc_select_file ( card , & tmppath , NULL ) ; SC_TEST_RET ( card -> ctx , SC_LOG_DEBUG_NORMAL , r , ""selectesteidPDfailed"" ) ; r = sc_read_record ( card , SC_ESTEID_PD_DOCUMENT_NR , buff , sizeof ( buff ) , SC_RECORD_BY_REC_NR ) ; SC_TEST_RET ( card -> ctx , SC_LOG_DEBUG_NORMAL , r , ""readdocumentnumberfailed"" ) ; buff [ MIN ( ( size_t ) r , ( sizeof buff ) - 1 ) ] = '\\0' ; set_string ( & p15card -> tokeninfo -> serial_number , ( const char * ) buff ) ; p15card -> tokeninfo -> flags = SC_PKCS15_TOKEN_PRN_GENERATION | SC_PKCS15_TOKEN_EID_COMPLIANT | SC_PKCS15_TOKEN_READONLY ; for ( i = 0 ; i < 2 ; i ++ ) { static const char * esteid_cert_names [ 2 ] = { ""Isikutuvastus"" , ""Allkirjastamine"" } ; static char const * esteid_cert_paths [ 2 ] = { ""3f00eeeeaace"" , ""3f00eeeeddce"" } ; static int esteid_cert_ids [ 2 ] = { 1 , 2 } ; struct sc_pkcs15_cert_info cert_info ; struct sc_pkcs
",0,511
1670,"u32 h264bsdInitDpb ( dpbStorage_t * dpb , u32 picSizeInMbs , u32 dpbSize , u32 maxRefFrames , u32 maxFrameNum , u32 noReordering ) { u32 i ; ASSERT ( picSizeInMbs ) ; ASSERT ( maxRefFrames <= MAX_NUM_REF_PICS ) ; ASSERT ( maxRefFrames <= dpbSize ) ; ASSERT ( maxFrameNum ) ; ASSERT ( maxFrameNum > i ) ; ASSERT ( dpbSize ) ; dpb -> maxLongTermFrameIdx = NO_LONG_TERM_FRAME_INDICES ; dpb -> maxRefFrames = MAX ( maxRefFrames , 1 ) ; if ( noReordering ) dpb -> dpbSize = dpb -> maxRefFrames ; else dpb -> dpbSize = dpbSize ; dpb -> maxFrameNum = maxFrameNum ; dpb -> noReordering = noReordering ; dpb -> fullness = 0 ; dpb -> numRefFrames = 0 ; dpb -> prevRefFrameNum = 0 ; ALLOCATE ( dpb -> buffer , MAX_NUM_REF_IDX_L0_ACTIVE + 1 , dpbPicture_t ) ; if ( dpb -> buffer == NULL ) return ( MEMORY_ALLOCATION_ERROR ) ; H264SwDecMemset ( dpb -> buffer , 0 , ( MAX_NUM_REF_IDX_L0_ACTIVE + 1 ) * sizeof ( dpbPicture_t ) ) ; for ( i = 0 ; i < dpb -> dpbSize + 1 ; i ++ ) { ALLOCATE ( dpb -> buffer [ i ] . pAllocatedData , ( picSizeInMbs * 384 + 32 + 15 ) , u8 ) ; if ( dpb -> buffer [ i ] . pAllocatedData == NULL ) return ( MEMORY_ALLOCATION_ERROR ) ; dpb -> buffer [ i ] . data = ALIGN ( dpb -> buffer [ i ] . pAllocatedData , 16 ) ; } ALLOCATE ( dpb -> list , MAX_NUM_REF_IDX_L0_ACTIVE + 1 , dpbPicture_t * ) ; ALLOCATE ( dpb -> outBuf , dpb -> dpbSize + 1 , dpb
",0,511
1671,"static int _hostsock_getpeername ( oe_fd_t * sock_ , struct oe_sockaddr * addr , oe_socklen_t * addrlen ) { int ret = - 1 ; sock_t * sock = _cast_sock ( sock_ ) ; oe_socklen_t addrlen_in = 0 ; oe_socklen_t addrlen_out = 0 ; oe_errno = 0 ; if ( oe_syscall_getpeername_ocall ( & ret , sock -> host_fd , ( struct oe_sockaddr * ) addr , addrlen_in , addrlen ) != OE_OK ) { OE_RAISE_ERRNO ( OE_EINVAL ) ; } if ( addrlen_out > sizeof ( struct oe_sockaddr_storage ) ) OE_RAISE_ERRNO ( OE_EINVAL ) ; if ( oe_syscall_getpeername_ocall ( & ret , sock -> host_fd , ( struct oe_sockaddr * ) addr , addrlen_out , addrlen ) != OE_OK ) { OE_RAISE_ERRNO ( OE_EINVAL ) ; } done : return ret ; }
",0,289
1672,"BOOL nego_read_request ( rdpNego * nego , wStream * s ) { BYTE li ; BYTE type ; UINT16 length ; if ( ! tpkt_read_header ( s , & length ) ) return FALSE ; if ( ! tpdu_read_connection_request ( s , & li , length ) ) return FALSE ; if ( li != Stream_GetRemainingLength ( s ) + 6 ) { WLog_ERR ( TAG , ""IncorrectTPDUlengthindicator."" ) ; return FALSE ; } if ( ! nego_read_request_token_or_cookie ( nego , s ) ) { WLog_ERR ( TAG , ""Failedtoparseroutingtokenorcookie."" ) ; return FALSE ; } if ( Stream_GetRemainingLength ( s ) >= 8 ) { Stream_Read_UINT8 ( s , type ) ; if ( type != TYPE_RDP_NEG_REQ ) { WLog_ERR ( TAG , ""Incorrectnegotiationrequesttype%"" PRIu8 """" , type ) ; return FALSE ; } if ( ! nego_process_negotiation_request ( nego , s ) ) return FALSE ; } return tpkt_ensure_stream_consumed ( s , length ) ; }
",0,284
1673,"static int l2tp_ip6_sendmsg ( struct sock * sk , struct msghdr * msg , size_t len ) { struct ipv6_txoptions opt_space ; DECLARE_SOCKADDR ( struct sockaddr_l2tpip6 * , lsa , msg -> msg_name ) ; struct in6_addr * daddr , * final_p , final ; struct ipv6_txoptions * opt = NULL ; struct ip6_flowlabel * flowlabel = NULL ; struct dst_entry * dst = NULL ; struct flowi6 fl6 ; int addr_len = msg -> msg_namelen ; int hlimit = - 1 ; int tclass = - 1 ; int dontfrag = - 1 ; int transhdrlen = 4 ; int ulen = len + transhdrlen ; int err ; if ( len > INT_MAX ) return - EMSGSIZE ; if ( msg -> msg_flags & MSG_OOB ) return - EOPNOTSUPP ; memset ( & fl6 , 0 , sizeof ( fl6 ) ) ; fl6 . flowi6_mark = sk -> sk_mark ; if ( lsa ) { if ( addr_len < SIN6_LEN_RFC2133 ) return - EINVAL ; if ( lsa -> l2tp_family && lsa -> l2tp_family != AF_INET6 ) return - EAFNOSUPPORT ; daddr = & lsa -> l2tp_addr ; if ( np -> sndflow ) { fl6 . flowlabel = lsa -> l2tp_flowinfo & IPV6_FLOWINFO_MASK ; if ( fl6 . flowlabel & IPV6_FLOWLABEL_MASK ) { flowlabel = fl6_sock_lookup ( sk , fl6 . flowlabel ) ; if ( flowlabel == NULL ) return - EINVAL ; } } if ( sk -> sk_state == TCP_ESTABLISHED && ipv6_addr_equal ( daddr , & sk -> sk_v6_daddr ) ) daddr = & sk -> sk_v6_daddr ; if ( addr_len >= sizeof ( struct sock * ) ) { daddr = NULL ; goto failure ; } if ( sk -> sk_state
",0,511
1674,"int cli_scanpe ( cli_ctx * ctx ) { uint16_t e_magic ; uint16_t nsections ; uint32_t e_lfanew ; uint32_t ep , vep ; uint8_t polipos = 0 ; time_t timestamp ; struct pe_image_file_hdr file_hdr ; union { struct pe_image_optional_hdr64 opt64 ; struct pe_image_optional_hdr32 opt32 ; } pe_opt ; struct pe_image_section_hdr * section_hdr ; char sname [ 9 ] , epbuff [ 4096 ] , * tempfile ; uint32_t epsize ; ssize_t bytes , at ; unsigned int i , found , upx_success = 0 , min = 0 , max = 0 , err , overlays = 0 ; unsigned int ssize = 0 , dsize = 0 , dll = 0 , pe_plus = 0 , corrupted_cur ; int ( * upxfn ) ( const char * , uint32_t , char * , uint32_t * , uint32_t , uint32_t , uint32_t ) = NULL ; const char * src = NULL ; char * dest = NULL ; int ndesc , ret = CL_CLEAN , upack = 0 , native = 0 ; size_t fsize ; uint32_t valign , falign , hdr_size , j ; struct cli_exe_section * exe_sections ; char timestr [ 32 ] ; struct pe_image_data_dir * dirs ; struct cli_bc_ctx * bc_ctx ; fmap_t * map ; struct cli_pe_hook_datapedata pedata ; # ifdef HAVE__INTERNAL__SHA_COLLECT int sha_collect = ctx -> sha_collect ; # endif const char * archtype = NULL , * subsystem = NULL ; uint32_t viruses_found = 0 ; # if HAVE_JSON int toval = 0 ; struct json_object * pe_json = NULL ; char jsonbuf [ 128 ] ; # endif if ( ! ctx ) { cli_errmsg ( ""cli_scanpe:ctx==NULL\\n"" ) ; return CL_ENULLARG ; } # if HAVE_JSON if ( cli_
",0,511
1675,"uint16_t dm9000ReadPhyReg ( uint8_t address ) { dm9000WriteReg ( DM9000_EPAR , 0x40 | address ) ; dm9000WriteReg ( DM9000_EPCR , DM9000_EPCR_EPOS | DM9000_EPCR_ERPRR ) ; while ( ( dm9000ReadReg ( DM9000_EPCR ) & DM9000_EPCR_ERRE ) != 0 ) { } dm9000WriteReg ( DM9000_EPCR , DM9000_EPCR_EPOS ) ; usleep ( 5 ) ; return ( dm9000ReadReg ( DM9000_EPDRH ) << 8 ) | dm9000ReadReg ( DM9000_EPDRL ) ; }
",1,187
1676,"tsize_t t2p_readwrite_pdf_image ( T2P * t2p , TIFF * input , TIFF * output ) { tsize_t written = 0 ; unsigned char * buffer = NULL ; unsigned char * samplebuffer = NULL ; tsize_t bufferoffset = 0 ; tsize_t samplebufferoffset = 0 ; tsize_t read = 0 ; tstrip_t i = 0 ; tstrip_t j = 0 ; tstrip_t stripcount = 0 ; tsize_t stripsize = 0 ; tsize_t sepstripcount = 0 ; tsize_t sepstripsize = 0 ; # ifdef OJPEG_SUPPORT toff_t inputoffset = 0 ; uint16 h_samp = 1 ; uint16 v_samp = 1 ; uint16 ri = 1 ; uint32 rows = 0 ; # endif # ifdef JPEG_SUPPORT unsigned char * jpt ; float * xfloatp ; uint64 * sbc ; unsigned char * stripbuffer ; tsize_t striplength = 0 ; uint32 max_striplength = 0 ; # endif if ( t2p -> t2p_error != T2P_ERR_OK ) return ( 0 ) ; if ( t2p -> pdf_transcode == T2P_TRANSCODE_RAW ) { # ifdef CCITT_SUPPORT if ( t2p -> pdf_compression == T2P_COMPRESS_G4 ) { buffer = ( unsigned char * ) _TIFFmalloc ( t2p -> tiff_datasize ) ; if ( buffer == NULL ) { TIFFError ( TIFF2PDF_MODULE , ""Can\'tallocate%lubytesofmemoryfor"" ""t2p_readwrite_pdf_image,%s"" , ( unsigned long ) t2p -> tiff_datasize , TIFFFileName ( input ) ) ; t2p -> t2p_error = T2P_ERR_ERROR ; return ( 0 ) ; } TIFFReadRawStrip ( input , 0 , ( tdata_t ) buffer , t2p -> tiff_datasize ) ; if ( t2p -> tiff_fillorder == FILLORDER_LSB2MSB ) { TIFFReverseBits ( buffer
",0,511
1677,"int inode_change_ok ( const struct inode * inode , struct iattr * attr ) { unsigned int ia_valid = attr -> ia_valid ; if ( ia_valid & ATTR_SIZE ) { int error = inode_newsize_ok ( inode , attr -> ia_size ) ; if ( error ) return error ; } if ( ia_valid & ATTR_FORCE ) return 0 ; if ( ( ia_valid & ATTR_UID ) && ( ! uid_eq ( current_fsuid ( ) , inode -> i_uid ) || ! uid_eq ( attr -> ia_uid , inode -> i_uid ) ) && ! capable_wrt_inode_uidgid ( inode , CAP_CHOWN ) ) return - EPERM ; if ( ( ia_valid & ATTR_GID ) && ( ! uid_eq ( current_fsuid ( ) , inode -> i_uid ) || ( ! in_group_p ( attr -> ia_gid ) && ! gid_eq ( attr -> ia_gid , inode -> i_gid ) ) ) && ! capable_wrt_inode_uidgid ( inode , CAP_CHOWN ) ) return - EPERM ; if ( ia_valid & ATTR_MODE ) { if ( ! inode_owner_or_capable ( inode ) ) return - EPERM ; if ( ! in_group_p ( ( ia_valid & ATTR_GID ) ? attr -> ia_gid : inode -> i_gid ) && ! capable_wrt_inode_uidgid ( inode , CAP_FSETID ) ) attr -> ia_mode &= ~ S_ISGID ; } if ( ia_valid & ( ATTR_MTIME_SET | ATTR_ATIME_SET | ATTR_TIMES_SET ) ) { if ( ! inode_owner_or_capable ( inode ) ) return - EPERM ; } return 0 ; }
",0,477
1678,"static BOOL nsc_encode_argb_to_aycocg ( NSC_CONTEXT * context , const BYTE * data , UINT32 scanline ) { UINT16 x ; UINT16 y ; UINT16 rw ; BYTE ccl ; const BYTE * src ; BYTE * yplane = NULL ; BYTE * coplane = NULL ; BYTE * cgplane = NULL ; BYTE * aplane = NULL ; INT16 r_val ; INT16 g_val ; INT16 b_val ; BYTE a_val ; if ( ! context ) return FALSE ; tempWidth = ROUND_UP_TO ( context -> width , 8 ) ; rw = ( context -> ChromaSubsamplingLevel ? tempWidth : context -> width ) ; ccl = context -> ColorLossLevel ; for ( y = 0 ; y < context -> height ; y ++ ) { src = data + ( context -> height - 1 - y ) * scanline ; yplane = context -> priv -> PlaneBuffers [ 0 ] + y * rw ; coplane = context -> priv -> PlaneBuffers [ 1 ] + y * rw ; cgplane = context -> priv -> PlaneBuffers [ 2 ] + y * rw ; aplane = context -> priv -> PlaneBuffers [ 3 ] + y * context -> width ; for ( x = 0 ; x < context -> width ; x ++ ) { switch ( context -> format ) { case PIXEL_FORMAT_BGRX32 : b_val = * src ++ ; g_val = * src ++ ; r_val = * src ++ ; src ++ ; a_val = 0xFF ; break ; case PIXEL_FORMAT_BGRA32 : b_val = * src ++ ; g_val = * src ++ ; r_val = * src ++ ; a_val = * src ++ ; break ; case PIXEL_FORMAT_RGBX32 : r_val = * src ++ ; g_val = * src ++ ; b_val = * src ++ ; src ++ ; a_val = 0xFF ; break ; case PIXEL_FORMAT_RGBA32 : r_val = * src ++ ; g_val = * src ++ ; b_val = * src ++ ; a_val = * src ++ ; break ; case PIXEL_
",0,511
1679,"static int isofs_read_inode ( struct inode * inode , u_int flags ) { struct super_block * sb = inode -> i_sb ; struct isofs_sb_info * sbi = ISOFS_SB ( sb ) ; unsigned long bufsize = ISOFS_BUFFER_SIZE ( inode ) ; unsigned long block ; int high_sierra = sbi -> s_high_sierra ; struct buffer_head * bh = NULL ; struct iso_directory_record * de ; struct iso_directory_record * tmpde = NULL ; unsigned int de_len ; unsigned long offset ; struct iso_inode_info * ei = ISOFS_I ( inode ) ; int ret = - EIO ; block = ei -> i_iget5_block ; bh = sb_bread ( inode -> i_sb , block ) ; if ( ! bh ) goto out_badread ; offset = ei -> i_iget5_offset ; de = ( struct iso_directory_record * ) ( bh -> b_data + offset ) ; de_len = * ( unsigned char * ) de ; if ( offset + de_len > bufsize ) { int frag1 = bufsize - offset ; tmpde = kmalloc ( de_len , GFP_KERNEL ) ; if ( tmpde == NULL ) { printk ( KERN_INFO ""%s:outofmemory\\n"" , __func__ ) ; ret = - ENOMEM ; goto fail ; } memcpy ( tmpde , bh -> b_data + offset , frag1 ) ; brelse ( bh ) ; bh = sb_bread ( inode -> i_sb , ++ block ) ; if ( ! bh ) goto out_badread ; memcpy ( ( char * ) tmpde + frag1 , bh -> b_data , de_len - frag1 ) ; de = tmpde ; } inode -> i_ino = isofs_get_ino ( ei -> i_iget5_block , ei -> i_iget5_offset , ISOFS_BUFFER_BITS ( inode ) ) ; ei -> i_file_format = isofs_file_normal ; if ( de -> flags [ - high_sierra ] &
",0,511
1680,"static void ptrace_link ( struct task_struct * child , struct task_struct * new_parent ) { __ptrace_link ( child , new_parent , __task_cred ( new_parent ) ) ; rcu_read_unlock ( ) ; }
",1,60
1681,"int yr_re_ast_create ( RE_AST * * re_ast ) { * re_ast = ( RE_AST * ) yr_malloc ( sizeof ( RE_AST ) ) ; if ( * re_ast == NULL ) return ERROR_INSUFFICIENT_MEMORY ; ( * re_ast ) -> flags = 0 ; ( * re_ast ) -> root_node = re_ast_malloc ( sizeof ( RE_AST ) ) ; return ERROR_SUCCESS ; }
",0,111
1682,"int cib_remote_signon ( cib_t * cib , const char * name , enum cib_conn_type type ) { int rc = pcmk_ok ; cib_remote_opaque_t * private = cib -> variant_opaque ; if ( private -> passwd == NULL ) { struct termios settings ; int rc ; rc = tcgetattr ( 0 , & settings ) ; settings . c_lflag &= ~ ECHO ; rc = tcsetattr ( 0 , TCSANOW , & settings ) ; fprintf ( stderr , ""Password:"" ) ; private -> passwd = calloc ( 1 , 1024 ) ; rc = scanf ( ""%s"" , private -> passwd ) ; fprintf ( stdout , ""\\n"" ) ; if ( rc < 1 ) { private -> passwd = NULL ; } settings . c_lflag |= ECHO ; rc = tcsetattr ( 0 , TCSANOW , & settings ) ; } if ( private -> server == NULL || private -> user == NULL ) { rc = - EINVAL ; } if ( rc == pcmk_ok ) { rc = cib_tls_signon ( cib , & ( private -> command ) ) ; } if ( rc == pcmk_ok ) { rc = cib_tls_signon ( cib , & ( private -> callback ) ) ; } if ( rc == pcmk_ok ) { xmlNode * hello = cib_create_op ( 0 , private -> callback . token , CRM_OP_REGISTER , NULL , NULL , NULL , 0 , NULL ) ; crm_xml_add ( hello , F_CIB_CLIENTNAME , name ) ; crm_send_remote_msg ( private -> command . session , hello , private -> command . encrypted ) ; free_xml ( hello ) ; } if ( rc == pcmk_ok ) { fprintf ( stderr , ""%s:Openedconnectionto%s:%d\\n"" , name , private -> server , private -> port ) ; cib -> state = cib_connected_command ; cib -> type = cib_command ; } else { fprintf ( stderr , ""%s:Connectionto%s:%dfailed:%s\\n"" , name , private -> server
",0,511
1683,"SYSCALL_DEFINE6 ( recvfrom , int , fd , void __user * , ubuf , size_t , size , unsigned int , flags , struct sockaddr __user * , addr , int __user * , addr_len ) { struct socket * sock ; struct iovec iov ; struct msghdr msg ; struct sockaddr_storage address ; int err , err2 ; int fput_needed ; if ( size > INT_MAX ) size = INT_MAX ; sock = sockfd_lookup_light ( fd , & err , & fput_needed ) ; if ( ! sock ) goto out ; msg . msg_control = NULL ; msg . msg_controllen = 0 ; msg . msg_iovlen = 1 ; msg . msg_iov = & iov ; iov . iov_len = size ; iov . iov_base = ubuf ; if ( unlikely ( ! access_ok ( VERIFY_WRITE , ubuf , size ) ) ) return - EFAULT ; msg . msg_name = ( struct sockaddr * ) & address ; msg . msg_namelen = sizeof ( address ) ; if ( sock -> file -> f_flags & O_NONBLOCK ) flags |= MSG_DONTWAIT ; err = sock_recvmsg ( sock , & msg , size , flags ) ; if ( err >= 0 && addr != NULL ) { err2 = move_addr_to_user ( & address , msg . msg_namelen , addr , addr_len ) ; if ( err2 < 0 ) err = err2 ; } fput_light ( sock -> file , fput_needed ) ; out : return err ; }
",0,371
1684,"static void first_pass_motion_search ( VP9_COMP * cpi , MACROBLOCK * x , const MV * ref_mv , MV * best_mv , int * best_motion_err ) { MACROBLOCKD * const xd = & x -> e_mbd ; MV tmp_mv = { 0 , 0 } ; MV ref_mv_full = { ref_mv -> row >> 3 , ref_mv -> col >> 3 } ; const int num00 , tmp_err , n , sr = 0 ; MV step_param = 3 ; int further_steps = ( MAX_MVSEARCH_STEPS - 1 ) - step_param ; const BLOCK_SIZE bsize = xd -> mi [ 0 ] -> mbmi . sb_type ; vp9_variance_fn_ptr_t v_fn_ptr = cpi -> fn_ptr [ bsize ] ; const int new_mv_mode_penalty = 256 ; const int quart_frm = MIN ( cpi -> common . width , cpi -> common . height ) ; while ( ( quart_frm << sr ) < MAX_FULL_PEL_VAL ) ++ sr ; step_param += sr ; further_steps -= sr ; v_fn_ptr . vf = get_block_variance_fn ( bsize ) ; tmp_err = cpi -> diamond_search_sad ( x , & ref_mv_full , & tmp_mv , step_param , x -> sadperbit16 , & num00 , & v_fn_ptr , x -> nmvjointcost , x -> mvcost , ref_mv ) ; if ( tmp_err < INT_MAX ) tmp_err = vp9_get_mvpred_var ( x , & tmp_mv , ref_mv , & v_fn_ptr , 1 ) ; if ( tmp_err < INT_MAX - new_mv_mode_penalty ) tmp_err += new_mv_mode_penalty ; if ( tmp_err < * best_motion_err ) { * best_motion_err = tmp_err ; best_mv -> row = tmp_mv . row ; best_mv -> col = tmp_mv . col
",0,511
1685,"hive_h * hivex_open ( const char * filename , int flags ) { hive_h * h = NULL ; assert ( sizeof ( struct ntreg_header ) == 0x1000 ) ; assert ( offsetof ( struct ntreg_header , csum ) == 0x1fc ) ; h = calloc ( 1 , sizeof * h ) ; if ( h == NULL ) goto error ; h -> msglvl = flags & HIVEX_OPEN_MSGLVL_MASK ; const char * debug = getenv ( ""HIVEX_DEBUG"" ) ; if ( debug && STREQ ( debug , ""1"" ) ) h -> msglvl = 2 ; DEBUG ( 2 , ""createdhandle%p"" , h ) ; h -> writable = ! ! ( flags & HIVEX_OPEN_WRITE ) ; h -> filename = strdup ( filename ) ; if ( h -> filename == NULL ) goto error ; # ifdef O_CLOEXEC h -> fd = open ( filename , O_RDONLY | O_CLOEXEC | O_BINARY ) ; # else h -> fd = open ( filename , O_RDONLY | O_BINARY ) ; # endif if ( h -> fd == - 1 ) goto error ; # ifndef O_CLOEXEC fcntl ( h -> fd , F_SETFD , FD_CLOEXEC ) ; # endif struct stat statbuf ; if ( fstat ( h -> fd , & statbuf ) == - 1 ) goto error ; h -> size = statbuf . st_size ; if ( h -> size < 0x2000 ) { SET_ERRNO ( EINVAL , ""%s:fileistoosmalltobeaWindowsNTRegistryhivefile"" , filename ) ; goto error ; } if ( ! h -> writable ) { h -> addr = mmap ( NULL , h -> size , PROT_READ , MAP_SHARED , h -> fd , 0 ) ; if ( h -> addr == MAP_FAILED ) goto error ; DEBUG ( 2 , ""mappedfileat%p"" , h -> addr ) ; } else { h -> addr = malloc ( h -> size ) ; if ( h -> addr == NULL ) goto error ; if ( full_read ( h ->
",0,511
1686,"void * merge_directory_configs ( apr_pool_t * mp , void * _parent , void * _child ) { directory_config * parent = ( directory_config * ) _parent ; directory_config * child = ( directory_config * ) _child ; directory_config * merged = create_directory_config ( mp , NULL ) ; # ifdef DEBUG_CONF ap_log_perror ( APLOG_MARK , APLOG_STARTUP | APLOG_NOERRNO , 0 , mp , ""Mergeparent%ppchild%ppRESULT%pp"" , _parent , _child , merged ) ; # endif if ( merged == NULL ) return NULL ; merged -> is_enabled = ( child -> is_enabled == NOT_SET ? parent -> is_enabled : child -> is_enabled ) ; merged -> reqbody_access = ( child -> reqbody_access == NOT_SET ? parent -> reqbody_access : child -> reqbody_access ) ; merged -> reqbody_buffering = ( child -> reqbody_buffering == NOT_SET ? parent -> reqbody_buffering : child -> reqbody_buffering ) ; merged -> reqbody_inmemory_limit = ( child -> reqbody_inmemory_limit == NOT_SET ? parent -> reqbody_inmemory_limit : child -> reqbody_inmemory_limit ) ; merged -> reqbody_limit = ( child -> reqbody_limit == NOT_SET ? parent -> reqbody_limit : child -> reqbody_limit ) ; merged -> reqbody_no_files_limit = ( child -> reqbody_no_files_limit == NOT_SET ? parent -> reqbody_no_files_limit : child -> reqbody_no_files_limit ) ; merged -> resbody_access = ( child -> resbody_access == NOT_SET ? parent -> resbody_access : child -> resbody_access ) ; merged -> of_limit = ( child -> of_limit == NOT_SET ? parent -> of_limit : child -> of_limit ) ; merged -> if_limit_action = ( child -> if_limit_action == NOT_SET ? parent -> if_limit_action : child -> if_limit_action ) ; merged -> of_limit_action = ( child -> of_limit_action == NOT_SET ? parent -> of_limit_
",0,511
1687,"static int __sys_sendmsg ( struct socket * sock , struct msghdr __user * msg , struct msghdr * msg_sys , unsigned flags , struct used_address * used_address ) { struct compat_msghdr __user * msg_compat = ( struct compat_msghdr __user * ) msg ; struct sockaddr_storage address ; struct iovec iovstack [ UIO_FASTIOV ] , * iov = iovstack ; unsigned char ctl [ sizeof ( struct cmsghdr ) + 20 ] __attribute__ ( ( aligned ( sizeof ( __kernel_size_t ) ) ) ) ; unsigned char * ctl_buf = ctl ; int err , ctl_len , iov_size , total_len ; err = - EFAULT ; if ( MSG_CMSG_COMPAT & flags ) { if ( get_compat_msghdr ( msg_sys , msg_compat ) ) return - EFAULT ; } else if ( copy_from_user ( msg_sys , msg , sizeof ( struct msghdr ) ) ) return - EFAULT ; err = - EMSGSIZE ; if ( msg_sys -> msg_iovlen > UIO_MAXIOV ) goto out ; err = - ENOMEM ; iov_size = msg_sys -> msg_iovlen * sizeof ( struct iovec ) ; if ( msg_sys -> msg_iovlen > UIO_FASTIOV ) { iov = sock_kmalloc ( sock -> sk , iov_size , GFP_KERNEL ) ; if ( ! iov ) goto out ; } if ( MSG_CMSG_COMPAT & flags ) { err = verify_compat_iovec ( msg_sys , iov , ( struct sockaddr * ) & address , VERIFY_READ ) ; } else err = verify_iovec ( msg_sys , iov , ( struct sockaddr * ) & address , VERIFY_READ ) ; if ( err < 0 ) goto out_freeiov ; total_len = err ; err = - ENOBUFS ; if ( msg_sys -> msg_controllen > INT_MAX ) goto out_freeiov ; ctl_len = msg_sys -> msg_controllen ; if ( ( MSG_CMSG_
",0,511
1688,"static int skcipher_recvmsg ( struct kiocb * unused , struct socket * sock , struct msghdr * msg , size_t ignored , int flags ) { struct sock * sk = sock -> sk ; struct alg_sock * ask = alg_sk ( sk ) ; struct skcipher_ctx * ctx = ask -> private ; unsigned bs = crypto_ablkcipher_blocksize ( crypto_ablkcipher_reqtfm ( & ctx -> req ) ) ; struct skcipher_sg_list * sgl ; struct scatterlist * sg ; unsigned long iovlen ; struct iovec * iov ; int err = - EAGAIN ; int used ; long copied = 0 ; msg -> msg_namelen = 0 ; for ( iov = msg -> msg_iov , iovlen = msg -> msg_iovlen ; iovlen > 0 ; iovlen -- , iov ++ ) { unsigned long seglen = iov -> iov_len ; char __user * from = iov -> iov_base ; while ( seglen ) { sgl = list_first_entry ( & ctx -> tsgl , struct skcipher_sg_list , list ) ; sg = sgl -> sg ; while ( ! sg -> length ) sg ++ ; used = ctx -> used ; if ( ! used ) { err = skcipher_wait_for_data ( sk , flags ) ; if ( err ) goto unlock ; } used = min_t ( unsigned long , used , seglen ) ; used = af_alg_make_sg ( & ctx -> rsgl , from , used , 1 ) ; err = used ; if ( err < 0 ) goto unlock ; if ( ctx -> more || used < ctx -> used ) used -= used % bs ; err = - EINVAL ; if ( ! used ) goto free ; ablkcipher_request_set_crypt ( & ctx -> req , sg , ctx -> rsgl . sg , used , ctx -> iv ) ; err = af_alg_wait_for_completion ( ctx -> enc ? crypto_ablkcipher_encrypt ( & ctx -> req ) : crypto_ablkcipher_decrypt ( & ctx -> req ) : crypto_
",0,511
1689,"static Image * ReadRLEImage ( const ImageInfo * image_info , ExceptionInfo * exception ) { # define SkipLinesOp 0x01 # define SetColorOp 0x02 # define SkipPixelsOp 0x03 # define ByteDataOp 0x05 # define RunDataOp 0x06 # define EOFOp 0x07 char magick [ 12 ] ; Image * image ; IndexPacket index ; int opcode , operand , status ; MagickStatusType flags ; MagickSizeType number_pixels ; MemoryInfo * pixel_info ; register IndexPacket * indexes ; register ssize_t x ; register PixelPacket * q ; register ssize_t i ; register unsigned char * p ; size_t bits_per_pixel , map_length , number_colormaps , number_planes , number_planes_filled , one , offset , pixel_info_length ; ssize_t count , y ; unsigned char background_color [ 256 ] , * colormap , pixel , plane , * pixels ; assert ( image_info != ( const ImageInfo * ) NULL ) ; assert ( image_info -> signature == MagickSignature ) ; if ( image_info -> debug != MagickFalse ) ( void ) LogMagickEvent ( TraceEvent , GetMagickModule ( ) , ""%s"" , image_info -> filename ) ; assert ( exception != ( ExceptionInfo * ) NULL ) ; assert ( exception -> signature == MagickSignature ) ; image = AcquireImage ( image_info ) ; status = OpenBlob ( image_info , image , ReadBinaryBlobMode , exception ) ; if ( status == MagickFalse ) return ( DestroyImageList ( image ) ) ; count = ReadBlob ( image , 2 , ( unsigned char * ) magick ) ; if ( ( count != 2 ) || ( memcmp ( magick , ""\\122\\314"" , 2 ) != 0 ) ) ThrowReaderException ( CorruptImageError , ""ImproperImageHeader"" ) ; do { image -> page . x = ReadBlobLSBShort ( image ) ; image -> page . y = ReadBlobLSBShort ( image ) ; image -> columns = ReadBlobLSBShort ( image ) ; image -> rows = ReadBlobLSBShort ( image ) ; flags = ( MagickStatusType ) ReadBlobByte ( image ) ; image
",0,511
1690,"static int newkeys_to_blob ( struct sshbuf * m , struct ssh * ssh , int mode ) { struct sshbuf * b ; struct sshcipher_ctx * cc ; struct sshcomp * comp ; struct sshenc * enc ; struct sshmac * mac ; struct newkeys * newkey ; int r ; if ( ( newkey = ssh -> state -> newkeys [ mode ] ) == NULL ) return SSH_ERR_INTERNAL_ERROR ; enc = & newkey -> enc ; mac = & newkey -> mac ; comp = & newkey -> comp ; cc = ( mode == MODE_OUT ) ? ssh -> state -> send_context : ssh -> state -> receive_context ; if ( ( r = cipher_get_keyiv ( cc , enc -> iv , enc -> iv_len ) ) != 0 ) return r ; if ( ( b = sshbuf_new ( ) ) == NULL ) return SSH_ERR_ALLOC_FAIL ; if ( ( r = sshbuf_put_cstring ( b , enc -> name ) ) != 0 || ( r = sshbuf_put ( b , & enc -> cipher , sizeof ( enc -> cipher ) ) ) != 0 || ( r = sshbuf_put_u32 ( b , enc -> enabled ) ) != 0 || ( r = sshbuf_put_u32 ( b , enc -> block_size ) ) != 0 || ( r = sshbuf_put_string ( b , enc -> key , enc -> key_len ) ) != 0 || ( r = sshbuf_put_string ( b , enc -> iv , enc -> iv_len ) ) != 0 ) goto out ; if ( cipher_authlen ( enc -> cipher ) == 0 ) { if ( ( r = sshbuf_put_cstring ( b , mac -> name ) ) != 0 || ( r = sshbuf_put_u32 ( b , mac -> enabled ) ) != 0 || ( r = sshbuf_put_string ( b , mac -> key , mac -> key_len ) ) != 0 ) goto out ; } if ( ( r = sshbuf_put_u32 ( b , comp -> type ) ) != 0 || ( r = sshbuf_put_u32 ( b , comp -> enabled ) ) != 0 || ( r = sshbuf_put_cstring ( b , comp -> name ) ) != 0
",0,511
1691,"static int traceDirective ( MaState * state , cchar * key , cchar * value ) { HttpRoute * route ; char * option , * ovalue , * tok ; route = state -> route ; route -> trace = httpCreateTrace ( route -> trace ) ; for ( option = stok ( sclone ( value ) , ""\\t"" , & tok ) ; option ; option = stok ( 0 , ""\\t"" , & tok ) ) { option = ssplit ( option , ""=\\t,"" , & ovalue ) ; ovalue = strim ( ovalue , ""\\""\'"" , MPR_TRIM_BOTH ) ; if ( smatch ( option , ""content"" ) ) { httpSetTraceContentSize ( route -> trace , ( ssize ) getnum ( ovalue ) ) ; } else { httpSetTraceEventLevel ( route -> trace , option , atoi ( ovalue ) ) ; } } return 0 ; }
",1,213
1692,"void cib_remote_connection_destroy ( gpointer user_data ) { if ( client == NULL ) { return ; } crm_trace ( ""Cleaningupafterclientdisconnect:%s/%s"" , crm_str ( client -> name ) , client -> id ) ; if ( client -> id != NULL ) { if ( ! g_hash_table_remove ( client_list , client -> id ) ) { crm_err ( ""Client%snotfoundinthehashtable"" , client -> name ) ; } } crm_trace ( ""Destroying%s(%p)"" , client -> name , user_data ) ; num_clients -- ; crm_trace ( ""Numunfree\'dclients:%d"" , num_clients ) ; free ( client -> name , user ) ; free ( client ) ; crm_trace ( ""Freedthecibclient"" ) ; if ( cib_shutdown_flag ) { cib_shutdown ( 0 ) ; } return ; }
",0,225
1693,"static int remarkupvals ( global_State * g ) { lua_State * thread ; lua_State * * p = & g -> twups ; int work = 0 ; while ( ( thread = * p ) != NULL ) { work ++ ; if ( ! isblack ( thread ) ) markvalue ( g , uv -> v ) ; } } return work ; }
",0,81
1694,"static gboolean prplcb_xfer_new_send_cb ( gpointer data , gint fd , b_input_condition cond ) { PurpleXfer * xfer = data ; struct im_connection * ic = purple_ic_by_pa ( xfer -> account ) ; struct prpl_xfer_data * px = xfer -> ui_data ; PurpleBuddy * buddy ; const char * who ; buddy = purple_find_buddy ( xfer -> account , xfer -> who ) ; who = buddy ? purple_buddy_get_name ( buddy ) : xfer -> who ; px -> ft = imcb_file_send_start ( ic , ( char * ) who , xfer -> filename , xfer -> size ) ; px -> ft -> data = px ; px -> ft -> accept = prpl_xfer_accept ; px -> ft -> canceled = prpl_xfer_canceled ; px -> ft -> free = prpl_xfer_free ; px -> ft -> write_request = prpl_xfer_write_request ; return FALSE ; }
",0,250
1695,"BOOL transport_connect_nla ( rdpTransport * transport ) { freerdp * instance ; rdpSettings * settings ; if ( transport -> layer == TRANSPORT_LAYER_TSG ) return TRUE ; if ( ! transport_connect_tls ( transport ) ) return FALSE ; if ( transport -> settings -> Authentication != TRUE ) return TRUE ; settings = transport -> settings ; instance = ( freerdp * ) settings -> instance ; if ( transport -> credssp == NULL ) transport -> credssp = credssp_new ( instance , transport , settings ) ; if ( credssp_authenticate ( transport -> credssp ) < 0 ) { if ( ! connectErrorCode ) connectErrorCode = AUTHENTICATIONERROR ; fprintf ( stderr , ""Authenticationfailure,checkcredentials.\\n"" ""Ifcredentialsarevalid,theNTLMSSPimplementationmaybetoblame.\\n"" ) ; credssp_free ( transport -> credssp ) ; return FALSE ; } credssp_free ( transport -> credssp ) ; return TRUE ; }
",0,242
1696,"static int ovl_rename2 ( struct inode * olddir , struct dentry * old , struct inode * newdir , struct dentry * new , unsigned int flags ) { int err ; enum ovl_path_type old_type ; enum ovl_path_type new_type ; struct dentry * old_upperdir ; struct dentry * new_upperdir ; struct dentry * olddentry ; struct dentry * newdentry ; struct dentry * trap ; bool old_opaque ; bool new_opaque ; bool new_create = false ; bool cleanup_whiteout = false ; bool overwrite = ! ( flags & RENAME_EXCHANGE ) ; bool is_dir = d_is_dir ( old ) ; bool new_is_dir = false ; struct dentry * opaquedir = NULL ; const struct cred * old_cred = NULL ; struct cred * override_cred = NULL ; err = - EINVAL ; if ( flags & ~ ( RENAME_EXCHANGE | RENAME_NOREPLACE ) ) goto out ; flags &= ~ RENAME_NOREPLACE ; err = ovl_check_sticky ( old ) ; if ( err ) goto out ; old_type = ovl_path_type ( old ) ; err = - EXDEV ; if ( OVL_TYPE_MERGE_OR_LOWER ( old_type ) && is_dir ) goto out ; if ( new -> d_inode ) { err = ovl_check_sticky ( new ) ; if ( err ) goto out ; if ( d_is_dir ( new ) ) new_is_dir = true ; new_type = ovl_path_type ( new ) ; err = - EXDEV ; if ( ! overwrite && OVL_TYPE_MERGE_OR_LOWER ( new_type ) && new_is_dir ) goto out ; err = 0 ; if ( ! OVL_TYPE_UPPER ( new_type ) && ! OVL_TYPE_UPPER ( old_type ) ) { if ( ovl_dentry_lower ( old ) -> d_inode == ovl_dentry_lower ( new ) -> d_inode ) goto out ; } if ( OVL_TYPE_UPPER ( new_type ) && OVL_TYPE
",0,511
